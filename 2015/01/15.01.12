00:02:41 <calvinx> Given this simple identity monad (“Position”) that I have written (http://lpaste.net/118308), is this understanding correct? ——> It is because of the bind definition in line 18, that allows me to subsequently perform function composition like those in lines 25 and 26 (function composition such as `g . h . i`).  Bind operations in monads are are what makes composition on my expanded type (“Position”) work.
00:03:27 <jle`> calvinx: not quite...it doesn't really have anything to do with monad
00:03:45 <jle`> monad lets you compose (a -> m b)'s
00:04:09 <Zemyla> :t ap const const
00:04:10 <lambdabot> a -> a
00:04:26 <jle`> functor is what lets you turn a composition of (a -> b)'s meaningfully composition of (m a -> m b)'s
00:04:32 <EvanR> :t (>=>)
00:04:33 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
00:05:25 <jle`> calvinx: if your functions were g x = Position (x + 2), for example
00:05:36 <jle`> then bind would help you compose them
00:05:47 <calvinx> AH
00:06:01 <calvinx> That makes sense.
00:06:16 <jle`> as you have them now, you have things like g = fmap (+2), h = fmap (+5), i = fmap (subtract 13)
00:06:33 <jle`> one "revelation" that you might be able to make from what you wrote there
00:06:53 <jle`> is that fmap (+2) . fmap (+5) . fmap (subtract 13) = fmap ((+2) . (+3) . subtract 13)
00:07:20 <jle`> which says that the composition of the "lifted" functions behaves the "same way" as lifting the unlifted composition
00:07:37 <calvinx> that makes a lot of sense.
00:07:48 <jle`> that you can analyze the behavior of g . h . i by analyzing the behavior of (+2) . (+5) . subtract 13
00:07:49 <Zemyla> :t ap (ap (const ap) const)
00:07:50 <lambdabot> ((a -> b) -> b1 -> a) -> (a -> b) -> b1 -> b
00:08:30 <Zemyla> \n f x -> f (n f x)
00:08:38 <Zemyla> :t \n f x -> f (n f x)
00:08:39 <lambdabot> ((t1 -> t) -> t2 -> t1) -> (t1 -> t) -> t2 -> t
00:08:41 <jle`> it's actually something that we take for granted pretty often
00:09:15 <Zemyla> :t const id
00:09:16 <lambdabot> b -> a -> a
00:09:39 <Zemyla> :t \x y -> id x y
00:09:40 <lambdabot> (t1 -> t) -> t1 -> t
00:10:01 <Zemyla> @pl \n f x -> f (n f x)
00:10:01 <lambdabot> ap (.)
00:10:53 <Zemyla> :t const (const const)
00:10:54 <lambdabot> b -> b1 -> a -> b2 -> a
00:10:57 <shachaf> Zemyla: Please use /msg to experiment with lambdabot unless you're showing something to the channel.
00:11:03 <Zemyla> Okay.
00:11:39 <cybercap> I'm trying to understand the list monad correctly. But I have one question, shouldnt these two functions operate the same?
00:11:40 <cybercap> let h = [1..] >>= \x -> [1..x] >>  [] >>= \y -> return (x,y)
00:11:49 <cybercap> let f = [1..] >>= \x -> [1..x] >>= \y -> return (x,y)
00:12:49 <cybercap> if I for example write take 10 f, i will get 10 values. But if i do the same for h it will never return anything
00:12:58 <shachaf> Neither of those is a function.
00:13:16 <Twey> [] >>= _ = []
00:13:25 <cybercap> then what can I call such a thing?
00:13:29 <shachaf> Lists?
00:13:34 <shachaf> Or values, in general.
00:13:36 <Twey> ‘Expression’ is probably what you wanted.
00:13:41 <cybercap> mm thats true
00:13:44 <glguy> In the monad instance for list, []>>=f is []
00:14:07 <cybercap> okay but why is it not returning []
00:14:21 <karshan> > [] >>= undefined
00:14:22 <lambdabot>  []
00:14:25 <cybercap> or it will never "reach" the return and just grow forever
00:15:24 <shachaf> Let's simplify. Do you have the same objection to [1..] >>= (\_ -> []) ?
00:17:05 <Twey> cybercap: Maybe it would be clearer in comprehension form: h = [ (x, y) | x ← [1 ..], y ← [1 .. x], _ ← [] ]; f = [ (x, y) | x ← [1 ..], y ← [1 .. x] ]
00:18:20 <Twey> > [ x | x ← [1 .. 5] ]
00:18:22 <lambdabot>  [1,2,3,4,5]
00:18:26 <Twey> > [ x | x ← [1 .. 5], _ ← [] ]
00:18:27 <lambdabot>  []
00:20:23 <cybercap> But if I instead of [1..] >>= (\_ -> []) ? wrote [1..] >>= (\_ -> [1]) ?. Then I would get a infinite list of ones. But is that because []>>= f is undefined
00:20:40 <int-e> [] >>= f is defined.
00:20:46 <cybercap> concat map f [] = []
00:20:59 <cybercap> or no
00:21:10 <cybercap> that depends on f ofc
00:21:20 <shachaf> It doesn't.
00:21:33 <int-e> for  [1..] >>= \_ -> []  there is no way to tell (from the outside) whether there is some value for which \_ -> [] returns a non-empty list
00:21:33 <shachaf> Well, it's a type error. But if you mean concat (map f []), that's always []
00:21:49 <Twey> @src concatMap
00:21:49 <lambdabot> concatMap f = foldr ((++) . f) []
00:21:55 <int-e> > [1..] >>= \x -> if x == 1000 then [x] else []
00:21:59 <lambdabot>  mueval-core: Time limit exceeded
00:22:01 <Twey> That was probably less informative than I'd hoped.
00:22:24 <nbouscal> map f [] is kind of like n * 0
00:22:53 <nbouscal> and adding concat doesn't change that
00:22:56 <int-e> Oh, timeouts are not proper errors. In ghci, that prints [1000  and then stops, looping.
00:23:15 <bernalex> does anyone know what that online game programming IDE thingy that supports haskell is called? I can't remember the name
00:23:54 <cybercap> mm. I think I understand. Thanks a lot!
00:25:19 <gamegoblin> Is there a way I can bitscan something in haskell? Like if I have a word64 and I want to find the index of the lowest set bit
00:25:32 <gamegoblin> there is an x86 instruction for it, but I can’t figure out how to do that in haskell
00:26:16 <opqdonut> gamegoblin: I think there's a package that provides access to that stuff
00:26:29 <gamegoblin> opqdonut: any chance you would know what to search for?
00:26:39 <merijn> gamegoblin: Data.Bits ?
00:26:47 <gamegoblin> merijn: It’s not in there
00:26:50 <merijn> oh, wait
00:27:24 <merijn> gamegoblin: I don't think that's builtin into GHC and I don't think you can write it using Cmm, so there's two options to do that
00:27:46 <bernalex> http://www.codingame.com/start was- it
00:27:54 <merijn> gamegoblin: 1) FFI out to C wrapper with inline asm 2) patch a new primitive into GHC (although, do check with #ghc first to be SURE it doesn't exist yet)
00:28:00 <Twey> cybercap: Basically, [ … | x ← xs, y ← ys ] means something like ‘for each x in xs, take each y from ys’ — the total size of the list will be |xs| × |ys|.  If ys is empty, it will give you nothing for any of the xs… but if there are an infinite number of xs then it takes an infinite amount of time to figure out that you're never going to get anything, because ys is parameterized by x and it
00:28:01 <opqdonut> gamegoblin: hmm right, Data.Bits has e.g. popcount but not that one
00:28:02 <Twey> *might* turn out that for some sufficiently large (or rather, late in xs) value of x, you'll get a non-empty ys.
00:28:36 <opqdonut> gamegoblin: a ha, http://hackage.haskell.org/package/bits-extras-0.1.3/docs/Data-Bits-Extras.html ?
00:28:53 <opqdonut> gamegoblin: "implemented using GCC builtins" so should use the machine instructions where applicable
00:29:15 <tdammers> merijn: gamegoblin: you can do it without the x86 instruction... if performance is not crucial, this might be a better idea, because you *can* implement that in plain Haskell
00:29:25 <tdammers> http://graphics.stanford.edu/~seander/bithacks.html
00:29:26 <cybercap> Twey: Thanks!
00:29:44 <gamegoblin> tdammers: of course, but performance *is* criticial which is why I want the ASM
00:30:01 <merijn> tdammers: Obviously you can do it without x86, but presumably anyone knowing that instruction exists (I didn't) is asking about it for performance reasons
00:30:03 <tdammers> gamegoblin: ah yes. In that case, FFI into C would be the canonical solution
00:30:17 <merijn> gamegoblin: If such a primitive exists, it'd be in GHC.Prim, so check your local docs for that
00:30:46 <Twey> cybercap: As int-e demonstrated up there, [ x | x ← [1 ..], y ← if x == 1000 then [x] else [] ] produces a single item, but not for a thousand steps.
00:31:14 <gamegoblin> Data.Bits.Extras has it
00:31:21 <gamegoblin> it calls out to C to do it
00:32:05 <tdammers> yes, indeed
00:32:08 <tdammers> c_ffsll
00:32:14 <gamegoblin> Yup
00:32:17 <gamegoblin> http://linux.die.net/man/3/ffsl
00:33:14 <merijn> gamegoblin: If this is gonna be in a tight inner loop you may wanna make sure it's foreign imported as unsafe
00:33:43 <gamegoblin> merijn: How would I do that?
00:33:44 <opqdonut> foreign import ccall unsafe "bitops-gcc.h ffsl"
00:33:50 <opqdonut> see http://hackage.haskell.org/package/bits-extras-0.1.3/docs/src/Data-Bits-Extras.html
00:33:53 <opqdonut> so it's alright
00:34:01 <merijn> opqdonut: By looking at the source like that :p
00:34:09 <tdammers> merijn: it is
00:34:12 <gamegoblin> Gotcha
00:34:36 <gamegoblin> How much slower is wrapping it in haskell?
00:34:41 <gamegoblin> Any idea?
00:34:47 <merijn> gamegoblin: Basically, unsafe calls are "direct" calls, i.e. like C does them. Safe calls (the default) move the call into a different thread and release the haskell capability so it doesn't block haskell threads
00:35:03 <gamegoblin> I’ll profile it and find out, I guess
00:35:19 <merijn> gamegoblin: Unsafe FFI calls should be exactly the same cost as a C function call (plus any potential marshalling of values)
00:35:32 <gamegoblin> Ah, awesome
00:36:06 <merijn> gamegoblin: Although after recommending using unsafe calls here I feel compelled to point out that you usually shouldn't do that: http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/
00:46:10 * hackagebot hi 1.1.0.2 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-1.1.0.2 (DaisukeFujimura)
01:12:39 <Zemyla> Oh, yay. I found reallyUnsafePtrEquality#.
01:24:52 <forked> would it be feasible torun haskell on a 1GHz 256MB RAM ARM MCU? Or do you need an OS underneath haskell?
01:26:14 <whald> forked, IIRC there is some project which allows to run Haskell directly on some hypervisor. i don't think it's possible to run on bare metal, though.
01:27:00 <whald> forked, that: https://github.com/GaloisInc/HaLVM
01:29:22 <merijn> Zemyla: In the same category as "accursedUnutterablePerformIO" ;)
01:29:56 <merijn> forked: Depends how willing you are to invest time hacking your way through problems
01:30:15 <merijn> forked: There's HaLVM as whald pointed out and House, both are aimed at running haskell on bare metal
01:31:12 * hackagebot extensible 0.2.1 - Poly-kinded, extensible ADTs  http://hackage.haskell.org/package/extensible-0.2.1 (FumiakiKinoshita)
01:32:04 <Zemyla> merijn: The only function I would want to use reallyUnsafePtrEquality in is length.
01:33:15 <whald> merijn, i wasn't aware of House. looks interesting.
01:34:22 <merijn> whald: After that they started working on Habit (strict Haskell for systems programming), but I haven't heard about that in a while and the last publications seem a few years old, so it's unclear whether that language is dead
01:35:47 <srenatus> forked: just a pointer, there's https://github.com/nerves-project which provides a layer over buildroot to create erlang-and-only-erlang-on-linux images for embedded devices
01:42:40 <srenatus> (the same thing with haskell  would be rather cool I think)
01:47:14 <forked> whald, merijn : ty interesting. i might be willing to put in quite a lot of work. say 200 hours over 6 months. but what kind of MCU do you thunk is needed for it? 50Mhz, 256MHz, %00, 1Ghz?
01:47:22 <forked> and what kind of memory?
01:49:12 <whald> forked, that really depends on your application. personally i'v had success running a haskell app on a x386 CPU with 8MB of RAM.
01:49:30 <whald> in the trunk of my car. not kidding. :-)
01:50:03 <whald> but it was only feeding MP3s to a custom hardware decoder wired to the parallel port.
01:51:56 <merijn> forked: See also https://ghc.haskell.org/trac/ghc/wiki/Platforms
01:52:08 <merijn> forked: I'd find out where the arm/iOS people are hanging out and talk to them
01:53:07 <merijn> There's a bunch of people working on running haskell on stuff like that and there is work to improve cross-compilation with GHC. I think it's actually fairly usable by now, but there's still a certain amount of "googling your way through obscure problems"
01:53:25 <merijn> Also, people in #ghc may know more on who's working on what
02:03:24 <forked> do you think there wqould be any interest in haskell on a MCU? or haskell programmers are not to interested in MCU programming? There is also the problem if it would only be for prototyping/hobbyists, further limiting the interest. Being able to write much more compact programs in C, C still reigns this realm.
02:03:49 <vanila> you could use a DSL inside haskell to program a MCU
02:03:53 <vanila> but not haskell itself
02:04:13 <vanila> e.g. http://smaccmpilot.org/
02:13:21 <gamegoblin> I’m having trouble doing cabal-install on bits-extras, cabal is giving me the error "Missing C library: gcc_s"
02:13:35 <gamegoblin> I’m on a mac OS X, I think I have gcc installed (as well as clang)
02:13:37 <gamegoblin> ideas?
02:14:07 <gamegoblin> in /usr/lib/ I have libgcc_s.1.dylib     libgcc_s.10.4.dylib  libgcc_s.10.5.dylib
02:14:15 <gamegoblin> which I’m not sure if they are what I need
02:14:17 <merijn> gamegoblin: Did you install gcc from macports/homebrew?
02:14:37 <gamegoblin> merijn: I think I homebrewed it
02:15:04 <merijn> Maybe bits-extras is relying on pkg-config and thus not finding
02:15:41 <gamegoblin> If I try cabal install -p bits-extras --extra-lib-dirs=/usr/lib/ it still fails
02:17:00 <merijn> gamegoblin: If you try "cabal get" to extract the source and try to manually compile the C file using gcc, does that work?
02:17:15 <gamegoblin> merijn: haven’t tried...
02:19:46 <favetelinguis> Why is this patterna match not working, test (_ c1 c2 _) = c1 it complains about the first underscore, i just want to get the c1 and c2 values no mather what the first value is
02:20:09 <vanila> you have to use a constructor
02:20:35 <Axman6> including types would make it easier to tell btw
02:21:37 <favetelinguis> sorry, here is the whole code
02:21:38 <favetelinguis> http://lpaste.net/118309
02:22:21 <ibid> favetelinguis: haskell does not support that sort of wildcarding.
02:22:35 <gamegoblin> merijn: dumb C question, but it’s just a .c and a .h (no main() or anything — just a library sort of thing), what should my gcc command look like?
02:24:13 <merijn> "gcc -c foo.c -lgcc_s -L/usr/lib" or something like that
02:24:38 <merijn> Ensure that gcc is in fact your homebrew gcc "gcc --version" see if it says "Apple LLVM" or not
02:25:02 <merijn> favetelinguis: You can't skip over constructors
02:25:09 <merijn> favetelinguis: You have to specify them
02:25:41 <forked> vanila: i was talking about porting haskell to MCU with the help of HalVM, nerves, House, or other suitable project. I know i canjt program a MCU with haskell today.
02:26:26 <favetelinguis> merijn: aa ok you mean data constructors
02:26:33 <merijn> favetelinguis: Yeah
02:26:35 <forked> but maybe DSL is the way to go. Generate C code from a DSL.
02:26:53 <vanila> yeah
02:26:55 <vanila> good idea
02:26:56 <gamegoblin> merijn: I ran "   /usr/local/bin/gcc-4.2 -c bitops-gcc.c -lgcc_s -L/usr/lib    "
02:26:58 <merijn> forked: Some people have done this and it would be fairly easy to create an (E)DSL in haskell and produce C
02:27:02 <gamegoblin> and got i686-apple-darwin11-gcc-4.2.1: -lgcc_s: linker input file unused because linking not done
02:27:10 <vanila> those guys are using ivory to do juust that
02:27:12 <merijn> gamegoblin: oh, right >.<
02:27:57 <gamegoblin> merijn: advice?
02:29:04 <merijn> "int main(int argc, char **argv) { /* call function from bitops here */ return 0; }" recompile but leave out '-c' and add this new source file :p
02:29:27 <merijn> See if it compiles and runs, if not, cry and become a gardener ;)
02:30:32 <gamegoblin> merijn: ld: library not found for -lgcc_s
02:31:09 <merijn> Right, so that's something fishy
02:31:33 <gamegoblin> merijn: any advice on how to proceed?
02:32:19 <merijn> Clearly the gcc you're using is not finding the libraries in /usr/lib. I expect that somehow your gcc install is not able to deal with the dylib format? (4.2 is pretty ancient...)
02:32:30 <merijn> Try the system "gcc" and see if that works?
02:33:13 <gamegoblin> Same error with system gcc (which is LLVM)
02:35:11 <merijn> Then I dunno what to do off the top of my head
02:35:24 <gamegoblin> merijn: damn, oh well, thanks
02:36:48 <jnj> I seem to be unable to profile my program all of the sudden: I keep getting 100% time in main (and oddly, 0 entries into main) instead of more detailed info on the actual functions called in main: http://lpaste.net/118310
02:36:59 <jnj> Everything is build with cabal configure --enable-profiling -p
02:50:21 <Guest72078> Hello, I'm a bit of a haskell newbie, and I'm struggling with aeson a bit.  I'm using deriveJSON to automatically derive the to and from json functions for my data types, and I'm wondering if there's a way to pass the string name of the data type to my FieldLabelModifier function so that I can chop it off the beginning of the field labels.
02:52:38 <bergmark> drewbert: sounds similar to what the example in the docs does: $(deriveJSON defaultOptions{fieldLabelModifier = drop 4, constructorTagModifier = map toLower} ''D)
02:55:10 <drewbert> bergmark: Exactly, but I will be doing this for many data types with names of varying lengths, so I'm not sure that "drop 4" is the smartest way to move forward.  If I could get that ''D over to the fieldLabelModifier... maybe by means of a wrapper template haskell function? then I wouldn't have to count characters or repeat the class name in multiple places.
02:56:14 * hackagebot mutable-containers 0.2.1 - Abstactions and concrete implementations of mutable containers  http://hackage.haskell.org/package/mutable-containers-0.2.1 (MichaelSnoyman)
02:58:29 <drewbert> By class name I mean data type name.  Old habits die hard...
02:59:36 <solarus> drewbert: can't you just write `fieldLabelModifier = myFun "D", ...' or am I missing something?
03:00:14 <gamegoblin> if I made a function that had like… 64 special cases like f 1 = blah; f 2 = hah; f 4 = wah; f 8 = zah; …. f (2^64) = heh, would it be normal for my compile time to be really really long with -O or -O2 turned on?
03:00:25 <gamegoblin> 'cause it’s been compiling for a few minutes now
03:01:19 <merijn> gamegoblin: Yes
03:01:30 <gamegoblin> merijn: what exactly is the compiler doing, any idea?
03:01:37 <drewbert> solarus: then I am writing $(deriveJSON defaultOptions{fieldLabelModifier=myFun "D"} ''D) for every D
03:01:37 <gamegoblin> it compiled fairly quickly without optimization
03:01:41 <merijn> gamegoblin: Because it'll probably try to inline them, blowing up the code size
03:02:00 <Hijiri> inline them with a huge case expression?
03:02:07 <merijn> gamegoblin: Inlining stuff, which blows up the code size and then all the other optimisations take ages
03:02:14 <gamegoblin> merijn: mmm. I actually only call it from one other function
03:02:15 <gamegoblin> gotcha
03:02:21 <Hijiri> I thought ghc was fairly conservative about inlining
03:02:22 <gamegoblin> Ah it finished!
03:02:26 <merijn> Hijiri: Wut?
03:02:36 <merijn> Hijiri: With -O2 GHC inlines shit everywhere
03:02:39 <Hijiri> oh
03:02:43 <merijn> Hijiri: Hell, it does cross package inlining
03:02:46 <Hijiri> I guess I heard wrong
03:02:54 <gamegoblin> with was with -O, I’ll try -O2 in a bit and see how long it takes
03:03:18 <merijn> Hijiri: It might be conservative in what it *considers* for inlining, but the actually inlining goes everywhere :)
03:04:47 <aomm> Hi! I'm doing some HTML parsing using HXT, and would really appreciate some guidance! I believe it is quite straightforward but I am a noob. Here is HTML/expected result: http://pastebin.com/9ahgwkMv
03:06:18 <aomm> I think I want to "fold" over the input somehow, having a procedure which parses one of the Headers which I apply until everything is consumed
03:10:07 <aomm> parse header text, parse header rows. Create new object and add to list of results. Then, remove the parsed rows from the tree, and run procedure again
03:11:11 <aomm> so I would somehow need to pass the modified tree along all computation steps, with it continually shrinking in size
03:11:51 <aomm> this is my cloudy intuition. :) would appreciate if someone could take a look
03:12:15 <pavonia> Isn't your parse an instance of Applicative? You could do something like "many $ Header <$> parseHeader <*> many parseRow" then
03:12:15 <aomm> be right back
03:13:26 <aomm> will look into this, thanks!
03:15:25 <Haskellfant> it's been quite a while since I used hxt, but iirc the tree structure is something like data Tree a = Tree a [Tree a]
03:15:39 <Haskellfant> so you should be able to get a list of the nodes containing the trs
03:15:55 <Haskellfant> by filtering you only get the once you are interested in
03:16:05 <Haskellfant> so then you can just fold over the list
03:28:10 <jnj> I seem to be unable to profile my program all of the sudden: I keep getting 100% time in main (and oddly, 0 entries into main) instead of more detailed info on the actual functions called in main: http://lpaste.net/118310
03:28:11 <jnj> Everything is build with cabal configure --enable-profiling -p
03:32:02 <mpickering> jnj:  you have no cost centres right?
03:32:31 <dcoutts> jnj: you need to have some cost centres in the packages you're interested in (probably only your main program, but possibly in some other lib)
03:32:35 <mpickering> You need to compile with -auto-all to get automatic cost centres
03:36:06 <jnj> mpickering, is this not done by cabal? I seem to recall profiling working fine a few days ago
03:36:32 <jnj> thank you dcoutts, mpickering for the info though, it is something I can google
03:36:39 <mpickering> you can specify the -auto-all option in your cabal file
03:36:43 <mpickering> under ghc-options
03:39:35 <jnj> Well, it works now - great - thank you both
03:43:54 <alpounet> mpickering, jnj: actually, you can also have a "ghc-prof-options" field in your library/executable section in the cabal file, that'll only be used when you build with --enable-library-profiling (for library sections) or --enable-executable-profiling (for executable sections), like here: https://github.com/alpmestan/taggy/blob/master/taggy.cabal#L70
03:44:49 <alpounet> cabal configure --enable-executable-profiling && cabal build && dist/build/foo/foo +RTS -p   for example
03:50:24 <mpickering> oh that's useful to know thanks
03:53:34 <jnj> yeah, that is nice to know, thank you
03:56:17 * hackagebot tables 0.4.1.1 - In-memory storage with multiple keys using lenses and traversals  http://hackage.haskell.org/package/tables-0.4.1.1 (EdwardKmett)
03:59:55 <merijn> edwardk: So, I was wondering: How much sense would it make to have a language only exposes lenses/prisms instead of constructors? i.e. having all those lens ideas built directly into the compiler. Would there be any problems with that? Or has no one done it only because the whole lens stuff is fairly new?
04:00:18 <edwardk> merijn: the exhaustiveness checker may be tricky
04:00:27 <edwardk> and yeah its mainly coz its new
04:01:41 <merijn> edwardk: Exhaustiveness checker is already tricky, if the state of GHC's checker for GADTs is an indication ;)
04:02:20 <merijn> I wonder if the work Tom Schrijvers is supervising is landing in 7.10 or not, no one seems to know. Which makes me worry that it won't be in GHC until even later :\
04:23:41 <merijn> hmm, suppose I have a category with the objects Void, Bool and (), then Void would be the initial object, () the terminal object and Bool would have arrows coming from Void and () and going to (), right?
04:24:45 <Iceland_jack> merijn: Yes, it would have unique arrows by definition if they're initial/terminal
04:24:59 <Iceland_jack> The empty map from Void to Bool
04:43:27 <booba> Greetings! I'm still new to Haskell was doing some exercises on Typeclasses. In a process of completing one (http://lpaste.net/118313 I had to introduce instance Ring Mod5) I wondered if there's a more idiomatic and functional way of implementing the function add for Ring Mod5
04:43:45 <d3lxa_> I can't find the function: Maybe (m a) -> m (Maybe a), it should exist right? I'm quite sure it's even generalized to any function f
04:43:49 <d3lxa_> *functor f
04:44:23 <booba> My feeling is that I could abstract on arguments in function add
04:45:01 <Hijiri> is there meant to be a $ between toMod5 and add (toInt a) (toInt b) ?
04:45:06 <Hijiri> or parens, or something
04:45:06 <Iceland_jack> :t T.sequence :: Monad m => Maybe (m a) -> m (Maybe a)
04:45:07 <lambdabot> Monad m => Maybe (m a) -> m (Maybe a)
04:45:21 <booba> Hijiri: yes, a typo, sorry
04:45:47 <Iceland_jack> d3lxa_: It's 'sequence' from Data.Traversable, it's not generalisable to any Functor
04:46:30 <Iceland_jack> You can how ever generealise it to Applicative:
04:46:30 <Iceland_jack> :t T.sequenceA :: Applicative f => Maybe (f a) -> f (Maybe a)
04:46:31 <d3lxa_> Iceland_jack: thanks! weird, hayoo failed on this one
04:46:31 <lambdabot> Applicative f => Maybe (f a) -> f (Maybe a)
04:47:01 <booba> Edited: http://lpaste.net/118313
04:47:26 <Hijiri> booba: I think it would look cleaner pattern matching on MkMod, but I don't know if there is a cleaner pointfree solution
04:47:35 <d3lxa_> booba: if I understood correctly, maybe with Control.Arrows: unzip $ (toInt &&& toInt) something
04:47:57 <Hijiri> @pl add a b = toMod5 add' (toInt a) (toInt b)
04:47:57 <lambdabot> add = (. toInt) . toMod5 add' . toInt
04:48:14 <Hijiri> you probably don't want this in your code
04:50:12 <booba> Thanks for your reply. If I were doing production I'd leave it as is. Just and "academic" curiosity.
04:51:19 <booba> It just seems that  instances for subset data types should be easily derived from instances on original data types
04:52:37 <booba> Like I have data type definition and a pair of translators like toInd and to Mod5. That feels like enought to straightfowardly define typeclass functions that have instances on "parent" datatype
05:00:49 <wz1000> Pacman says I have an update for cabal-install. However, I installed it via cabal itself a few days ago. Will it be OK to update via pacman?
05:03:28 <dropp> hey hey
05:04:39 <mpickering> wz1000: I don't see why not..
05:05:05 <mpickering> updating via cabal will but the executable in ~/.cabal/bin
05:05:11 <mpickering> I imagine pacman puts it somewhere else
05:05:34 <mpickering> I just manage my cabal installation with cabal tho, not my system package manager
05:06:20 * hackagebot prednote 0.28.0.2 - Evaluate and display trees of predicates  http://hackage.haskell.org/package/prednote-0.28.0.2 (OmariNorman)
05:13:14 <wz1000> mpickering: ~/.cabal/bin comes before /usr/bin in my path
05:18:12 <pantsman> wz1000: which one do *you* want to use; the one you installed yourself, or pacman's?
05:18:49 <jle`> :t T.sequenceA `asAppliedTo` Nothing
05:18:50 <lambdabot> Applicative f => Maybe (f a) -> f (Maybe a)
05:20:16 <merijn> <3 `asAppliedTo`
05:20:27 <mpickering> :t asAppliedTo
05:20:28 <lambdabot> (a -> b) -> a -> a -> b
05:20:49 <merijn> mpickering: It's just const with a fancy type :)
05:20:57 <merijn> But it's very useful for showing examples
05:22:40 <ddellacosta> hello again folks, back with more questions re: FFI.  This time, trying to figure out how I can create a data structure in haskell to pass into a C function that is structured the same way as a char array of ints.  The code I am referencing: https://xiph.org/ao/doc/ao_example.c (see the buffer most of the way down)
05:26:38 <ddellacosta> I've tried doing stuff like creating a list of CChar and passing in a pointer to that via withArray, but no luck.
05:28:29 <merijn> ah, withArray is for the exact opposite of what you want :)
05:29:08 <merijn> ddellacosta: Why not mallocArray/allocaArray ?
05:29:49 <ddellacosta> merijn: ah, okay, I'll look into that.  Even just creating the data structure seems to create different values than I'm getting
05:29:59 <ddellacosta> compared to in the C version I mean
05:31:16 <merijn> In what way?
05:31:20 * hackagebot matchers 0.24.0.0 - Text matchers  http://hackage.haskell.org/package/matchers-0.24.0.0 (OmariNorman)
05:32:09 <ddellacosta> merijn: the actual values seem to be different--I've wrapped the C code in an FFI call so I can test the rest of the code, and if I dump out the first 10 or so values of that and compare that to what I am creating in Haskell, it's not the same
05:32:40 <ddellacosta> merijn: more specifically, it seems to be the same up until when it gets put into the char* array in C vs. when I put it into a seq/list in Haskell
05:32:56 <ddellacosta> merijn: so I assume there is something going on with the coercion to int in C that I just don't understand
05:32:59 <merijn> What's the type of your haskell list?
05:33:13 <ddellacosta> merijn: CChar
05:33:39 <merijn> Hard to tell without haskell code for reference, tbh
05:33:48 <ddellacosta> merijn: actually right now I've got Seq CChar that I'm converting to [CChar]
05:33:52 <ddellacosta> merijn: yeah, fair enough
05:33:55 <ddellacosta> one sec
05:34:54 <ddellacosta> merijn: forgot I pasted this last week: https://gist.github.com/ddellacosta/0d5c98a248010ccc4709
05:35:16 <ddellacosta> merijn: I've confirmed the sample fn generates the exact same thing as the equivalent C code
05:36:27 <ddellacosta> I also am pretty sure the bit shifting is right, or at least it is identical to what is going on in C.  I'm just stumped
05:36:37 <merijn> This doesn't show the FFI code, though
05:37:11 <ddellacosta> merijn: sorry, which FFI code, the stuff wrapping the C?
05:37:30 <ddellacosta> merijn: this is basically just the haskell version of that buffer creation code in the C example.
05:37:34 <merijn> oh!
05:37:48 <merijn> Wait, you said it produced the same thing as C?
05:37:50 <ddellacosta> (or rather, my failing attempt to do so)
05:37:52 <merijn> That's odd
05:38:13 <ddellacosta> merijn: no, it definitely doesn't--I'm screwing something up, so your "that's odd" makes sense if you're seeing something wrong there. :-)
05:38:15 <merijn> Because *floor* is not the same as cast to int
05:38:49 <merijn> floor "rounds to the greatest integer not greater than input"
05:38:55 <merijn> Casting to int truncates
05:38:56 <ddellacosta> merijn: yeah, and that's exactly where it begins to go wrong--so you've gotten to the heart of my question: how *do* I do the equivalent to cast to int in Haskell?
05:39:13 <merijn> :t truncate
05:39:14 <lambdabot> (RealFrac a, Integral b) => a -> b
05:39:19 <merijn> truncate 7.8
05:39:21 <merijn> eh
05:39:25 <nkar> is there a way to ignore the cabal.config file?
05:39:33 <merijn> > truncate 7.8
05:39:35 <lambdabot>  7
05:39:38 <merijn> > floor 7.8
05:39:40 <lambdabot>  7
05:39:52 <merijn> > floor -7.8
05:39:54 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
05:39:54 <lambdabot>    arising from a use of ‘M501924225563685315630300.show_M5019242255636853156...
05:39:54 <lambdabot>  The type variable ‘b0’ is ambiguous
05:39:55 <ddellacosta> merijn: okay, that's good, maybe that's my big mistake
05:39:59 <merijn> > floor (-7.8)
05:40:00 <lambdabot>  -8
05:40:04 <ddellacosta> right, gotcha
05:40:06 <merijn> > truncate (-7.8)
05:40:07 <lambdabot>  -7
05:40:20 <ddellacosta> dumb arithmetic mistake then!  thanks merijn, let me see if that does it
05:47:58 <ddellacosta> merijn: blah, still no luck--I'm getting different values
05:48:14 <shock_one> Hi. How would I call tax and fees in one word?
05:48:24 <shock_one> *taxes.
05:49:43 <ddellacosta> https://gist.github.com/ddellacosta/d7f0d402cadc253ace64
05:51:21 * hackagebot exhaustive 1.1.0 - Compile time checks that a computation considers producing data through all possible constructors  http://hackage.haskell.org/package/exhaustive-1.1.0 (OliverCharles)
05:52:40 <pavonia> shock_one: Ask in ##English maybe?
05:52:58 <shock_one> I'm sorry, I wrote into a wrong channel.
05:58:28 <merijn> ddellacosta: I wonder if pi and M_PI have the same precision...
05:58:51 <tdammers> merijn: pi is polymorphic, M_PI isn't
05:58:54 <merijn> ddellacosta: The C code seems to be using float
05:59:14 <merijn> tdammers: So? A specific instance of pi has a specific precision
05:59:30 <ddellacosta> merijn: yeah, but my sample code is Floating a--I tried to mimic the C code as much as possible
05:59:31 <merijn> ddellacosta: Your use of floor might be causing the return type of sample to default to Double
05:59:40 <ddellacosta> merijn: well, I swapped out w/truncate
05:59:48 <merijn> ddellacosta: float in C is not the same type as Double
06:00:13 <ddellacosta> okay, yeah, I need to read up on C types
06:00:17 <merijn> ddellacosta: Try making sample's type "CFloat -> CFloat -> CFloat"?
06:01:12 <ddellacosta> merijn: doesn't seem to make a difference--I get the same results in both cases
06:01:39 <ddellacosta> merijn: moreover, I can confirm that I get the same values with the C sample code as with the Haskell up to that point, actually
06:08:04 <merijn> hmmm
06:08:29 <merijn> ddellacosta: The only thing I can think of is carefully trying each bit of the codepath to find where they diverge
06:08:49 <ddellacosta> merijn: it seems to be after the truncate (what used to be floor)
06:09:22 <phaazon_> hi
06:09:25 <ddellacosta> merijn: but yeah, will keep poking at it, that's all there is to it really.  Thanks for your help!
06:09:41 <ddellacosta> phaazon_: hi
06:09:46 <phaazon_> is there a TH module that adds syntactic sugar to monoids?
06:10:04 <favetelinguis> an i correct to say that foldl is tail recursice but foldr is not, forll' adds strict evaluation to the game also?
06:10:06 <phaazon_> I mean, monads are not so that different from monoid
06:10:24 <merijn> phaazon_: heh
06:10:30 <merijn> phaazon_: What would that even do?
06:10:39 <phaazon_> merijn: mconcat
06:10:53 <merijn> phaazon_: Why not just write "mconcat"?
06:11:03 <phaazon_> merijn: because I have to write down a list
06:11:07 <phaazon_> [a,b,c,d]
06:11:10 <phaazon_> instead of a b c d
06:11:14 <phaazon_> (on each line)
06:11:35 <benzrf> favetelinguis: well
06:11:38 <benzrf> favetelinguis: check the source:
06:11:41 <benzrf> @src foldl
06:11:41 <lambdabot> foldl f z []     = z
06:11:41 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:12:04 <fProgrammer_> Quick Question: How do I use a do statement correctly here? http://lpaste.net/118316 I get a compile time error of type mismatch
06:12:07 <benzrf> favetelinguis: you are correct, yes. but you almost NEVER want to use foldl because the folding functoin will be applied lazily even though the fold itself is tail recursive
06:12:26 <phaazon__> damned network
06:12:44 <favetelinguis> benzrf: ok so i always go for foldl' then?
06:12:45 <benzrf> favetelinguis: if you want strict tail recursion, use foldl'
06:12:57 <benzrf> favetelinguis: if you want laziness, use foldr
06:13:01 <benzrf> foldl is almost useless
06:13:13 <mpickering> fProgrammer_: I think your typ signature is wrong?
06:13:15 <benzrf> fyi, foldr is what you want most of the time
06:13:22 <benzrf> you should only need foldl' for performance reasons
06:13:24 <clrnd> fProgrammer_, your type signature says listPythonFiles takes an IO String and returns an IO String
06:13:32 <clrnd> bit it is not taking any arguments
06:13:52 <fProgrammer_> mpickering: which I do, I return myString of the type IO String, where am I going wrong?
06:14:11 <clrnd> fProgrammer_, but the type sig says it also TAKES a string
06:14:14 <clrnd> which it isn't
06:14:44 <benzrf> favetelinguis: tail recursion in haskell has different advantages from in strict languages
06:15:15 <fProgrammer_> clrnd: Oh lord, really sorry for this silly error, I should take my meds :D
06:15:28 <favetelinguis> benzrf: like what?
06:15:32 <clrnd> fProgrammer_, no problem mate :P
06:16:15 <benzrf> favetelinguis: well, for one thing, stack overflows in ghc dont happen for the same reasons
06:16:18 <benzrf> in fact they are quite rare
06:16:51 <benzrf> favetelinguis: ghc doesn't use the system stack for every haskell function application
06:17:03 <merijn> favetelinguis: Basically, the way function calls are implemented in GHC *every* function call is a tail call
06:17:19 <benzrf> favetelinguis: instead, it has a kind of reified but compiled expression graph at runtime that it crawls along and reduces
06:17:31 <merijn> favetelinguis: There's still a stack, but it's a "pattern match stack"
06:17:54 <benzrf> favetelinguis: so if your function recurses a ton, you may just end up with a really long leg of the graph
06:18:09 <benzrf> favetelinguis: and depending on what your function does, ghc may not have to use the system stack to descend into the graph
06:18:29 <benzrf> favetelinguis: tail recursion is usually more of a space issue than a stack issue in ghc haskell
06:18:35 <benzrf> merijn: right?
06:19:19 <favetelinguis> ok so if it is only a space issue i can see why foldl would be pointless compared with foldl'
06:19:32 <benzrf> favetelinguis: it's a little complicated
06:19:54 <phooby> how are infinite lists implemented in haskell? i get that expressions are translated into graph so that thunks can be shared but how this applies to infinite lists?
06:20:24 <benzrf> favetelinguis: ghc uses the sytsem stack when reducing part of the graph requires that another part be reduced first
06:20:42 <benzrf> favetelinguis: so it pushes the current graph location onto the stack, then jumps over and reduces, then jumps back
06:21:02 <benzrf> favetelinguis: therefore, a stack overflow happens if expression A forces evaluation of expression B, then expr B forces C, etc
06:21:45 <benzrf> favetelinguis: but if A only relies on B being /partly/ reduced, ghc can return before completely reducing B
06:21:57 <merijn> benzrf: I would say it differently
06:22:07 <benzrf> merijn: go ahead, i only half understand this stuff :P
06:22:25 <merijn> benzrf: "Solving space leaks due to laziness often requires rewriting to tail recursion to be able to write a sufficiently strict version"
06:23:15 <merijn> It's not that tail recursion that solves the problem, it's strictness annotation. But it's hard (perhaps impossible?) to write the relevant strictness annotation without transforming to tail recursion
06:23:23 <benzrf> alright :)
06:23:36 <merijn> phooby: No values get computed until inspected
06:23:53 <merijn> phooby: Basically, the "tail" part of an infinite list isn't computed until you try to look at it
06:23:54 <benzrf> favetelinguis: lets step back a moment?
06:23:56 <Cale> phooby: Well, you just have data structures which contain expressions for other data structures, possibly even themselves.
06:24:03 <Cale> Like,  ones = 1 : ones
06:24:09 <Cale> will be cyclic
06:24:25 <Cale> and you can have things like  upFrom n = n : upFrom (n+1)
06:24:59 <Cale> When you evaluate upFrom 0, it will evaluate to 0 : upFrom (0+1), which if you're matching it against the patter (x:xs), is enough evaluation to be done.
06:25:10 <Cale> pattern*
06:25:34 <phooby> i know this much, but i can't connect how it is especially the graph that enables this?
06:25:56 <Cale> (x will get bound to 0, and xs will get bound to upFrom (0+1), and the latter only needs to be evaluated if xs needs to be evaluated)
06:26:08 <phooby> is it because of blowing stack or something?
06:26:11 <Cale> The graph enables sharing
06:26:30 <phooby> yeah
06:26:35 <Cale> Okay, I'll give the example I usually like to give
06:26:39 <phooby> ok :)
06:26:48 <Cale> Suppose we have double x = x + x
06:26:56 <Cale> and we're trying to evaluate double (double 5)
06:27:22 <Cale> If we were just doing outermost-first evaluation, the reduction steps would look something like this:
06:27:27 <Cale> double (double 5)
06:27:33 <Cale> -> (double 5) + (double 5)
06:27:42 <Cale> -> (5 + 5) + (double 5)
06:27:46 <Cale> -> 10 + (double 5)
06:27:50 <Cale> -> 10 + (5 + 5)
06:27:52 <Cale> -> 10 + 10
06:27:54 <Cale> -> 20
06:28:49 <Cale> This obviously wastes work evaluating double 5 twice, because the parameter x of double occurred twice in the function body, which resulted in duplication of work
06:29:15 <phooby> and that's why you have the graph linking to the same thunk, right?
06:29:18 <Cale> So, lazy evaluation / graph reduction makes an improvement to this
06:30:08 <Cale> where we still evaluate outermost first, but any occurrences of a variable share a reference to the expression to be evaluated, so that work done evaluating one of the copies is shared with the others
06:30:28 <Cale> We can represent the sharing using a let/in expression, and it'll look like this:
06:30:32 <Cale> double (double 5)
06:30:49 <Cale> -> let x = double 5 in x + x  -- note that we still evaluated the outermost double first
06:30:56 <Cale> -> let x = 5 + 5 in x + x
06:31:03 <Cale> -> let x = 10 in x + x
06:31:07 <Cale> -> 10 + 10
06:31:08 <Cale> -> 20
06:33:15 <Cale> So, you might imagine that the expression  let x = double 5 in x + x  in memory looks like a graph with (+) having two arcs coming out of it to double which has an arc coming out of it to 5.
06:33:22 <phooby> yes :) can you explain how this applies to infinite lists? why they wouldn't be possible without translating to graph?
06:33:40 <Cale> Oh, they're still possible
06:33:52 <phooby> but they would easily blow the stack or something?
06:34:06 <Cale> It's just the graph reduction saves effort evaluating the same subexpressions over and over
06:34:17 <Cale> Consider something like iterate
06:34:20 <Cale> @src iterate
06:34:20 <lambdabot> iterate f x = x : iterate f (f x)
06:35:20 <Cale> iterate f x generates a list which looks something like [x, f x, f (f x), f (f (f x)), ...]
06:35:48 <Cale> We might hope that if we spend the time evaluating earlier elements of this list, that the work we did will be used when computing the next one
06:36:01 <Cale> and graph reduction enables that
06:36:23 * hackagebot pipes-interleave 0.2.1 - Interleave and merge streams of elements  http://hackage.haskell.org/package/pipes-interleave-0.2.1 (BenGamari)
06:36:40 <Cale> the "f (f x)" in the third element of the list is actually f applied to the second element of the list, and so evaluating one will help out with the other
06:37:24 <Cale> You can get into trouble with iterate though
06:38:23 <Cale> If you walk a long distance along the list without evaluating any of the elements, and then finally evaluate the 10 millionth element, and f happens to be strict (i.e. it pattern matches on its argument before producing any of its result), then you may blow the stack
06:38:56 <Cale> Because each occurrence of f will contribute a case expression to the stack, waiting for its scrutinee to be evaluated before it can match
06:38:58 <phooby> i see :)
06:39:09 <muzzle> quick question about cabal: I have an executable and a test suite is it possible to share build dependencies between the two ? (Without explicitly stating them for both)
06:39:20 <mpickering> yes
06:39:29 <phooby> hum... but as an implementation detail: why it can't be optimized to just hold the latest evaluated element and discard all the rest? no need for the graph?
06:39:32 <Cale> (the stack in GHC Haskell is not so much a call stack as it is a pattern matching stack)
06:39:51 <Cale> You can't tell which elements you'll need in the future
06:39:55 <rom1504> isn't tail recursion a thing in haskell ?
06:39:58 <benzrf> when u pattern match on a thunk, the thunk must be forced, so the stack gets pushed
06:40:14 <phooby> cale, ah, true :)
06:40:14 <muzzle> mpickering: can you tell me how plz ?
06:40:17 <mpickering> muzzle: In the build-depends for the tests add the name of the library you are building
06:40:17 <benzrf> once the thunk is evaluated to whnf, the stack pops and the match is computed
06:40:25 <Cale> rom1504: Tail recursion is a thing, but tail call optimisation is hard to talk about when you don't have a call stack
06:40:37 <phooby> cale, thank you!
06:40:38 <benzrf> if evaluating the thunk to whnf requires another pattern match, you push the stack again
06:40:52 <rom1504> hmm
06:41:07 <Cale> phooby: The elements will be cleaned up by the garbage collector if you lose reference to them
06:41:27 <Cale> phooby: So it's possible that only a small number of elements of the list reside in memory at any point
06:41:42 <benzrf> @let overflow = case overflow of True -> True; False -> False -- will this overflow?
06:41:43 <merijn> muzzle: Usually what I do is: implement most of the code as library, have tests and executable depend on the library
06:41:44 <lambdabot>  Defined.
06:41:47 <benzrf> > overflow
06:41:51 <lambdabot>  mueval-core: Time limit exceeded
06:41:56 <benzrf> Cale: why doesnt that overflow
06:42:15 <benzrf> sharing?
06:42:33 <Cale> benzrf: I believe black hole detection eventually gets it
06:42:38 <benzrf> ach
06:42:40 <merijn> It produces <<loop>> for me
06:42:48 <merijn> So yeah, blackholing gets it
06:42:58 <benzrf> @let overflow n = case overflow (n + 1) of True -> True; False -> False -- will this overflow?
06:42:59 <lambdabot>  .L.hs:219:1:
06:42:59 <lambdabot>      Multiple declarations of ‘overflow’
06:42:59 <lambdabot>      Declared at: .L.hs:206:1
06:43:01 <benzrf> oh
06:43:08 <Cale> @undefine
06:43:09 <lambdabot> Undefined.
06:43:14 <phooby> cale, so in this case some kind of cache of computation up to the last non garbaged collected item must be kept, i think?
06:43:16 <benzrf> @let overflow n = case overflow (n + 1) of True -> True; False -> False -- will this overflow?
06:43:18 <lambdabot>  Defined.
06:43:19 <benzrf> > overflow
06:43:20 <tdammers> Haskell troll of the week: putStrLn "<<loop>>"
06:43:21 <lambdabot>  <Integer -> Bool>
06:43:25 <benzrf> > overflow 0
06:43:30 <lambdabot>  mueval-core: Time limit exceeded
06:43:30 <lambdabot>  mueval: ExitFailure 1
06:43:33 <benzrf> :D
06:43:35 <benzrf> it worked
06:43:36 <wei2912> well
06:43:44 <wei2912> got to try that in GHCi
06:44:09 <phooby> cale, so it basically does this "optimization" at some point nevertheless and frees nodes?
06:44:17 <wei2912> it consumes more and more memory
06:44:36 <Cale> phooby: Well, yeah, it's a big mess of pointers and cons cells in memory, and as things lose reference to the cons cells, and later elements of the list have their elements fully evaluated, the earlier elements of the list become garbage
06:45:18 <Cale> If you're doing nothing other than printing out the list, for instance
06:45:39 <Cale> Then as soon as you've printed one element and computed the next for printing, then the previous element can be freed.
06:46:14 <Cale> GHC's generational GC is pretty good at dealing with lots of short-lived garbage like this
06:47:03 <Cale> But also there are rewrite rules in the list library which will hope to eliminate intermediate lists where possible.
06:47:59 <merijn> phooby: It's not so much an optimisation as it is just "garbage collection"
06:48:03 <phooby> cale, cool
06:48:16 <merijn> phooby: If you keep a reference to the start of the list alive, then you WILL run out of memory at some point
06:48:39 <benzrf> does ghc use refcounting or what
06:48:44 <merijn> benzrf: No
06:48:48 <clrnd> Cale, very cool
06:48:50 <phooby> merijn, can't the compiler remove nodes in-between?
06:48:51 <benzrf> whats it use
06:48:59 <merijn> benzrf: It uses generational tracing GC
06:49:13 <tdammers> benzrf: naive refcounting wouldn't work
06:49:25 <merijn> phooby: No, because then it'd have to "roll back" evaluated values to thunks
06:49:29 <tdammers> benzrf: refcounting can't cope with cycles
06:49:32 <Cale> phooby: Nope, because the first (:) cell has a reference to the next one
06:49:48 <merijn> phooby: To do that you'd have to store all thunks forever in case you ever need to rollback
06:49:50 <geekosaur> phooby, what happens if your reference to the start eventually gets used to go further into the list?
06:50:12 <tdammers> benzrf: PHP and Python both use refcounting - Python tackles the problem by adding cycle detection, PHP just bleeds memory and assumes that the process will die soon anyway
06:50:26 <Cale> https://ghc.haskell.org/trac/ghc/wiki/GarbageCollectorNotes -- information on GHC's garbage collector
06:50:38 <Cale> It's a combination of copy collection and mark and sweep.
06:51:16 <phooby> geekosaur, i thought you could then re-evaluate them, but of course then it'd lead to the problem merjin just pointed out: you'd have to keep the thunks
06:51:35 <phooby> merijn, makes sense
06:52:02 <geekosaur> right. there's actually been a little work on that but it's proved difficult even in the restricted context that was being worked on
06:52:03 <phooby> very informative, thanks everyone!
06:52:12 <neuroserpens> phooby: You're welcome
06:52:21 <neuroserpens> phooby: If you need anything else I'm right here.
06:52:56 <phooby> geekosaur, ok. interesting to hear
06:53:10 <Cale> (the notes are unfortunately a bit incomplete...)
06:53:25 <phooby> one thing i really love about this channel and community is that you can actually ask these questions :)
06:53:29 <Athas> When I do C-c C-l in haskell-mode to load my code into GHCi, how can I easily navigate the resulting errors?
06:53:37 <phooby> cale, i'll read them, thanks :)
06:53:48 <Athas> They are highlighted and hyperlinked in the *haskell* buffer, but it's inconvenient to click on them.
06:54:32 <Cale> I seem to recall something at least a little more complete about GHC's garbage collector out there
06:55:05 <geekosaur> shouldn't it be using the usual emacs error thing? C-x ` usually
06:55:11 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/local-gc.pdf -- well, there's this paper
06:55:26 <Athas> geekosaur: oh, right, that works.
06:55:41 <Athas> It never works in latex-mode, so I never even bothered trying.
06:59:46 <Cale> It should be required that if you write a paper about things implemented in the context of GHC, that you mention which release version of GHC they're in, if any :)
07:00:35 <phooby> Cale, thanks!
07:00:48 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html#gc -- there are a bunch more papers on GC here if you're super interested
07:01:42 <Cale> Actually, I think the older papers do a better job of explaining what's going on in many cases
07:02:21 <phooby> any specific suggestions?
07:03:09 <phooby> generational garbage collection for haskell maye?
07:03:10 <phooby> maybe
07:04:53 <Cale> I forget which papers were best to get started with. It might actually be a good idea to read the STG machine paper before any of this actually...
07:05:34 <Cale> http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf -- here's a copy of that one
07:06:08 <Cale> This doesn't talk much specifically about GC, but it gives an excellent overview of what's going on at a low level.
07:06:31 <Cale> (which is still fairly relevant to the modern implementation, even if it's been tweaked a lot)
07:07:00 <Cale> It also gives an overview of a bunch of other methods for implementing lazy evaluation
07:07:12 <phooby> cale, this is great! thanks!
07:07:29 <Cale> the stuff under the heading "3 Exploring the design space"
07:07:31 <Cale> in particular
07:07:51 <phooby> roger
07:27:00 <eXeC64> I know I've been using Haskell too much lately when I'm looking at a few dozen lines of Python and thinking, "This could've been 5 beautiful little lines."
07:28:00 <tdammers> eXeC64: no such thing as "using Haskell too much"
07:28:50 <tdammers> it's kind of difficult to explain to my PHP-wielding colleagues why I think Python isn't a great language after all though
07:29:08 <eXeC64> Yeah. I used to love it's apparent beauty and simplicity
07:29:15 <eXeC64> Now all I see is trapdoors and pitfalls.
07:29:23 <tdammers> yeah
07:29:34 <tzaeru> *scratch* I rather find Python one of the best languages around. not that any language was particularly awesome.
07:29:35 <tdammers> pretending that types don't exist isn't simple at all
07:29:36 <vanila> I tried to wrte something in python recently and i had to keep messing around with indentation when commenting stuff out to test things
07:29:57 <tzaeru> vanila, that sounds more like an IDE than language issue..
07:30:06 <vanila> its because python uses indentation for syntax
07:30:27 <tzaeru> um, yes. just don't change indentation when adding a comment character(s)? :P
07:30:28 <tdammers> also, it baffles me how much people obsess about syntax, while there are blatant semantic problems at hand that easily dwarf any tabs-vs-spaces or semicolons-yes-or-no debate
07:30:36 <eXeC64> golang makes that sort of thing a language issue. Unusued variable or import? compilation fails. No, it can't be temporarily turned off.
07:30:39 <vanila> that doesn't work
07:30:50 <eXeC64> commenting stuff out in golang is a pain
07:31:08 <tdammers> tzaeru: that doesn't solve the issue completely
07:31:09 <vanila> go is really stupid too, there's a patch that removes that excessively anal error about unused variable
07:31:22 <eXeC64> I do still like go though
07:31:28 <eXeC64> it makes writing server software really easy
07:31:28 <tzaeru> I've really not had issues with indentation and comments in Python..
07:31:31 <tdammers> tzaeru: for example, you cannot comment out the only statement in a block; you need to add "pass", too
07:31:35 <eXeC64> and the concurrency is nice
07:31:47 <eXeC64> s/concurrency/concurrency primitves/
07:32:10 <eXeC64> I need to do more real-world stuff with Haskell
07:32:29 <tzaeru> tdammers, well, only if your function doesn't return anything
07:32:46 <tzaeru> erm.. :P sorry, misread.
07:32:50 <tzaeru> obviously that doesn't work with other blocks.
07:33:45 <tzaeru> but then you can generally as well comment out the whole block if it's not a function.
07:35:25 <tzaeru> anyway, I find python pretty awesome for a lot of general problems. I don't know Haskell very well, but to me, it doesn't look like very fun to do say, GUIs or games or web servers with.
07:35:44 <tzaeru> by "very well" I mean "barely at all"
07:35:53 <darkroom> I am currently getting this error when i try to load ghci does anyone know why this is happening? Do i need to give more information XOR.hs:10:8:     Could not find module `Network.Trainer.BackpropTrainer'     Use -v to see a list of the files searched for.
07:36:24 <Athas> tzaeru: web servers are OK.  GUIs and games... it's not too bad, but I agree you can find better options.
07:36:29 <tdammers> tzaeru: if you comment out the only statement inside a block in Python, without adding "pass" in its place, you get an IndentationError
07:36:43 <Athas> Although parts are nice in Haskell, those things really fit an OOP design very well.
07:37:08 <tzaeru> tdammers, yes. but if it's a function, it's suggested that it has a return statement which you really wouldn't need to comment out. if it's not a function, then you can comment out the whole block
07:37:21 <tzaeru> to me, it's a very minor issue.
07:38:29 <tdammers> it makes a lot of things unnecessarily inconvenient, and if you compare it to how Ruby has an explicit end-of-block keyword and is still extremely readable, I don't see how the Python way is better, really
07:38:40 <tdammers> but again, those are just syntax shenanigans
07:38:47 <tdammers> the really issues are elsewhere
07:39:04 <vanila> yes very inconvenient
07:39:19 <Athas> It's not like Haskell doesn't have semantic whitspace either!
07:39:19 <vanila> and there's like 30 ways to take the length of the list, only the last (most nonsensical one) works
07:39:32 <vanila> list.len list.length list.length() length(list) len(list)
07:39:44 <tzaeru> tdammers, I don't think anyone thinks Python way is better in that respect. but it's not a big issue for most, I think
07:39:49 <vanila> i dont know why anyone would make such a complex language
07:40:17 <clrnd> this piece of the go docs makes me shiver http://blog.golang.org/defer-panic-and-recover
07:40:17 <vanila> how do you do an if list is []? about 5 ways all with strange complex tradeoffs
07:40:21 <tzaeru> why is len(list) the least sensical?
07:40:33 <tdammers> tzaeru: try and argue that explicit end-of-block is better than python's indentation-defines-block approach on /r/python. I dare you.
07:40:51 <tzaeru> tdammers, mh :P
07:40:51 <Athas> tzaeru: abbreviated name, and logically a property.
07:41:06 <vanila> A big problem in go is that you can't do type safe polymorphism, and the community is so hostile if you try to suggest a solultion to this
07:41:14 <tzaeru> well, that kind of logic is just a construction that differs from language to language and paradigm to paradigm
07:41:20 <vanila> I think similar to haskell programmers, they really want thir language to 'win' so they silence criticism
07:41:48 <clrnd> Go has goto
07:41:50 <tdammers> Athas: Haskell has semantic whitespace, and while I think it's one of its darkest corners, it's waaay less problematic than in Python
07:41:54 <narendraj9> Python2 --> Python3 was irritating, to me.
07:41:58 <tzaeru> to me, python is hundreds of times simpler than Haskell. I admit that I don't know Haskell really at all, but (again, to me, not in general) it's hugely more complex and harder to understand than Python
07:42:02 <tzaeru> or C++
07:42:02 <tzaeru> or 6502 asm
07:42:05 <vanila> goto and no tail calls
07:42:07 <vanila> its horrible
07:42:12 <vanila> such bad language design
07:42:15 <clrnd> Go has `defer`
07:42:49 <tzaeru> tdammers, I think the major reason for those semantic whitespaces is really readability. and they aren't necessarily a bad solution from some perspectives.
07:42:51 <Athas> tzaeru: Haskell has fewer rules, but the rules are more general and deep.  It's a different kind of complexity, I feel.
07:42:55 <exio4> tzaeru, what is complex and harder to understand?
07:42:59 <tzaeru> exio4, haskell
07:43:08 <Athas> Although when compared to C++... man, if you think Haskell is more complex, then you don't really know C++.
07:43:19 <tzaeru> Athas, why's that?
07:43:44 <Athas> C++ has a huge number of strange semantics.
07:44:00 <exio4> tzaeru, I'd say other languages tend to be more complex, as their "primitive operators" (or things that must be built-in in the language) are more complicated
07:44:11 <tzaeru> Athas, that doesn't mean it can't feel more simple to a person than haskell, though :P
07:44:18 <tzaeru> particularly if the person learned it as a little wee kid.
07:44:23 <Athas> Every part of the design has weird complexity, from things like Koenig lookup for lexical scoping, to how virtual/non-virtual multiple inheritance interacts.
07:44:31 <Athas> And, of course, the entire template system.
07:44:38 <geekosaur> it certainly can feel more simple right up until you try to do something "obvious" and get 350 lines of template error
07:45:02 <tzaeru> well. for the record, C++ was the first language I learned +10 years ago and I've spent years on working on it professionaly, academically and as a hobby.
07:45:09 <tzaeru> granted, it's not exactly my favorite language to be working on.
07:45:10 <augustss> tzaeru: The basic things you need to know to understand Haskell are quite simple.  You can build very complex things on top of that, but the core is simple.
07:45:20 <narendraj9> Haskell is pretty cool when you have to implement an algorithm. I tried insertion sort in Java. Took some time and odd book keeping. Did in Haskell in one line with foldl.
07:45:23 <tzaeru> but to me, it feels simple. perhaps haskell would feel equally simple if I had as much experience with haskell
07:45:26 <exio4> haskell is a bunch of "typechecked syntatic sugar"
07:45:35 <narendraj9> But it's hard to reason about the space complexity.
07:45:47 <narendraj9> Atleast to me.
07:45:55 <augustss> tzaeru: It's like Go, a few moments to learn, a lifetime to master.
07:46:21 <zq> that's disconcerting
07:46:22 <augustss> narendraj9: It's hard for all of us.
07:46:37 <zq> haskell's a tool, a means to an end. go is a game, an end in itself.
07:47:07 <clrnd> I can code Haskell even if I never run it, it's so beautiful
07:47:13 <Athas> tzaeru: well, many algorithms are really hard to express in Haskell, unfortunately.
07:47:19 <tzaeru> so I've understood.
07:47:35 <Athas> Many depend on random-access mutable updates to achieve their asymptotic performance.
07:47:42 <zq> so use ST
07:47:43 <tzaeru> and really, when I've looked at example code for small "games", it looks strikingly much like trying to feel and look like an imperative language.
07:47:45 <tzaeru> just with a more confusing syntax.
07:47:46 <Athas> Okay, so they are not "really hard", but they tend to become ugly.
07:47:46 <clrnd> 2yeah, imperative algorithms
07:48:02 <clrnd> tzaeru, lookup FRP
07:48:15 <augustss> zq: I don't think it's disconcerting.  As an example, Haskell was over 20 years old when the beautiful lens abstractions were discovered.
07:48:23 <vanila> its good to be able to program in different styles, game stuff might often require imperative style so being able to do that in haskell is ok
07:48:29 <clrnd> well if you code a game using a main loop like in Java it will feel imperative, yeah
07:48:36 <narendraj9> Athas: examples please. I just started CLRS with the aim of implementing things in Haskell.
07:48:57 <Athas> narendraj9: the classical in-place Quicksort, for example.
07:49:04 <tzaeru> perhaps I'm generally motivated to code things that simply get a bit more complicated in Haskell than they'd be in say, Python.
07:49:10 <tzaeru> it's a curious language, though ^_^
07:49:18 <Athas> Oh Van Emde Boas trees, maybe.
07:49:34 <vanila> augustss, I've heard about this lens stuff a lot but never really understood the use of it - do you know a good code that shows why its helpful?
07:49:45 <narendraj9> Athas: Oh. Yes. Any resouces that would be helpful? I will probably need them.
07:49:56 <zq> augustss: i'm not sure how that fits into "haskell requires a lifetime to master" not being disconcerting
07:50:02 <eXeC64> I feel like learning Haskell made me smarter. Made me think about problems in a new way, and see new paths and simplifications I could make in imperative languages/code.
07:50:02 <Athas> narendraj9: well, read Purely Functional Data Structures.
07:50:25 <Athas> There are some truly beautiful and efficient alternatives to traditional imperative algorithms and data structures.
07:50:42 <tzaeru> eXeC64, I haven't yet felt like that :P
07:51:26 * hackagebot shake-language-c 0.6.4 - Utilities for cross-compiling with Shake  http://hackage.haskell.org/package/shake-language-c-0.6.4 (StefanKersten)
07:51:27 <tzaeru> though then, I've been overall changing my style to concern less about objects and more about interfaces to pieces of functionality, with classes more as a nice way to organize the code itself.
07:51:36 <tzaeru> so perhaps that revelation, to me, came from elsewhere than Haskell
07:51:52 <Athas> tzaeru: much OOP is going that way as well.
07:51:54 <tzaeru> actually starting that kind of a swift in paradigm was probably why Haskell is now somewhat intereting to me
07:52:12 <narendraj9> Haskell makes me feel bad when I repeat myself in other languages. Probably because of higher order functions. Which is good, I think.
07:52:14 <Athas> Modularity and abstraction is basically The Thing That Matters, no matter the language.
07:52:28 <tzaeru> it's a bit silly that "objects" are still considered the most fundamental way of thinking and approaching most problems
07:52:42 <tzaeru> I don't think they're really a comfortable abstraction level to be thinking in, not even in OOP languages.
07:52:48 <tzaeru> that doesn't mean I thought FP was the solution either, though
07:53:08 <Athas> Well, it makes sense if you just think of an "object" as an "abstract data type".  That's how I write Haskell as well as OOP languages.
07:53:25 <tzaeru> well, most of the time you're still thinking on a bit higher level, no?
07:54:08 <Athas> Well sure, but abstract data types are how I construct the actual program.
07:54:20 <tzaeru> like the actual task might be "I need house door opened" and the mapping of it into objects "Door, Key, House" is really the secondary mapping of the problem :P
07:54:42 <tzaeru> ..okay, that was a terrible analogue.
07:55:04 <tdammers> tzaeru: you don't open the door. You send messages to a robot controller over some network protocol.
07:55:26 <Athas> Nono, the proper analogue for programming is preparing a burrito.
07:55:43 <tdammers> sometimes, having objects in your code that are somewhat isomorphic to real doors and opening them is the right way to design your application
07:56:21 <tdammers> but more often, I would argue that the door itself can be reduced to a two-state (or maybe four-state) variable
08:07:14 <Cale> zq: Are you trying to tell me that Haskell isn't a game now? :D
08:07:56 <Cale> Programming and mathematics are among the best games constructed by humanity
08:09:48 <clrnd> type juggling, the game of trying to fit a type into another type
08:10:16 <geekosaur> type tetris?
08:11:05 <clrnd> thats better
08:11:27 * hackagebot sitemap 0.1.2 - Sitemap parser  http://hackage.haskell.org/package/sitemap-0.1.2 (AlpMestanogullari)
08:21:30 <zq> Cale: anything can be framed as a game
08:23:01 <zq> Cale: the utility in doing so varies in each case
08:23:26 <Cale> zq: Yeah, pretty much. But these are activities which we don't only partake in for the sake of getting things done.
08:24:49 <Cale> Especially mathematics. While pure mathematicians are often happy to hear that their work has applications, those aren't usually the thing which drives them.
08:25:30 <tdammers> Cale: hardly anything I do has "getting stuff done" as its primary motivation
08:25:36 <augustss> zq: I think it's great that Haskell is powerful enough that when the lens abstraction was discovered it didn't need any language extensions, it could just be encoded in what we already have rather than adding new features.
08:26:28 <tdammers> augustss: I'd argue that a *practically comfortable* implementation of lenses does necessitate a bit of TH or similar metaprogramming
08:38:04 <wyager> Any Haskell experts want to critique my project? Especially re. concurrency and networking. https://github.com/wyager/Neks
08:50:39 <aisqwe> does a ! at the beginning of a value cunstructor in a data type declaration mean something special?
08:50:58 <clrnd> aisqwe, it'sa a strictness declaration
08:50:59 <wyager> It means that the field should be evaluated strictly
08:51:28 * hackagebot duplo 1.6.19 - Frontend development build tool  http://hackage.haskell.org/package/duplo-1.6.19 (kenhkan)
08:53:00 <SrPx> Is there any shorthard for `if cond then Just x else Nothing` ?
08:53:30 <clrnd> @hoogle Bool -> Maybe a
08:53:32 <lambdabot> Prelude Just :: a -> Maybe a
08:53:32 <lambdabot> Data.Maybe Just :: a -> Maybe a
08:53:32 <lambdabot> Prelude return :: Monad m => a -> m a
08:53:41 <wyager> @hoogle Bool -> a -> Maybe a
08:53:41 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
08:53:42 <lambdabot> Control.Exception assert :: Bool -> a -> a
08:53:42 <lambdabot> Control.OldException assert :: Bool -> a -> a
08:53:54 <lpaste> topi pasted “Drawing a string tree” at http://lpaste.net/118324
08:53:55 <wyager> So no
08:54:26 <SrPx> clrnd: ah... obvious! Thank you. I need to hire my brain into hoogling like that.
08:54:45 <c_wraith> > [ 10 | True ] :: Maybe Int
08:54:46 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe GHC.Types.Int’
08:54:46 <lambdabot>              with actual type ‘[t0]’
08:54:46 <SrPx> wire*
08:55:03 <c_wraith> Ok, lambdabot doesn't have monadcomprehensions enabled
08:55:27 <n4x> > guard True >> return 10 :: Maybe Int
08:55:29 <lambdabot>  Just 10
08:55:53 <eXeC64> > guard False >> return 10 :: Maybe Int
08:55:54 <lambdabot>  Nothing
08:55:57 <eXeC64> Hmm, nice
08:56:21 <clrnd> good one
08:57:54 <SrPx> Interesting ! Thanks :)
08:58:46 <eXeC64> I'd argue that's less readable than the if clause though
08:58:57 <SrPx> Anyway, I asked this other day but nobody answered. Suppose I want to define a function such as "foo cond val = guard cond >> return val" on my project. Where do I define it? It has nothing to do with the particular data structure so I find it awkward to define it inside the file.
08:59:31 <wyager> SrPx: if it's a one-off function, just define it in a "where" clause
08:59:40 <SrPx> I often have this kind of issue when defining a function that "should be in a library I'm using" but isn't
08:59:48 <SrPx> wyager: but what if I use it in several places?
09:00:30 <wyager> Up to your judgement. Might make sense to write it out at all call sites if it's simple enough.
09:00:33 <quchen> SrPx: "Utilities" module
09:01:03 <SrPx> is it possible to create a file that will overshadow "Data.Monad" on my project? This way I could define that function there, as an extension to the original library.
09:01:20 <SrPx> quchen: that's a good idea I guess :)
09:01:32 <SrPx> although a little unspecific
09:04:28 <clrnd> SrPx, you can define a module called MonadUtilities that re-exports Data.Monad
09:04:41 <clrnd> so you save yourself 1 import :P
09:04:52 <clrnd> (I'd just go for the Util module, I always have one)
09:08:45 <topi> I'm looking for a neat solution on how to end up with a render like this: http://i.imgur.com/ElJz3dM.png , the code I got so far is http://lpaste.net/118324 (thanks to ski), anyway, the question in short: if I use say foldlM instead of mapM_, and use the accumulator to keep track of the angle, can I access the number of subbranches for each branch and calculate correct angle for each of them?
09:10:02 <topi> my thinking could be totally flawed, so please correct me
09:13:28 <clrnd> topi, sounds reasonable, you can also keep several values in the accumulator using a tuple
09:16:55 <fozworth> i am trying to get optional nested data out of JSON using aeson. i use `(o .: "k1") >>= (.: "k2")` for required data, but `(o .:? "k1") >>= (.:? "k2")` doesn't work for nested data. what's the right way to do this?
09:18:52 <fozworth> my current hacky solution is to do this: (o .:? "k1") >>= (\ m -> case m of Just x -> x .:? "k2"; Nothing -> o .:? "_")
09:19:23 <topi> clrnd: on thing I'm not entirely sure how to construct is the correct form for foldlM as the type for this is "(a -> b -> m a) -> a -> t b -> m a" and for mapM "(a -> m b) -> t a -> m ()". The fold suggest therefore that I should be able to pass an parameter to the Render () in my case, correct?
09:20:58 <clrnd> topi, you are using mapM_, foldM also has a foldm_ variety
09:21:05 <clrnd> :t foldM_
09:21:05 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m ()
09:22:01 <topi> o.. oh.. thanks
09:23:38 <clrnd> topi, I'd suggest you separate the rendering from the calculating
09:23:56 <clrnd> why not build a data structure that contains the angle information first, and then render it?
09:24:05 <trunks1ace> Define a function suffixes :: [a] -> [[a]] that returns the lists of all suffixes of a given string in descending order of length. For example, suffixes "perl" should return ["perl","erl","rl","l"] in that order. Hint: one way to do this is by repeated application of the tail function
09:24:09 <developernotes> I am attempting to install cabal-dev with a fresh haskell install on OS X.  I receive the following error (http://pastie.org/9827794) as it checks the dependencies.  Any suggestions?
09:24:19 <trunks1ace> how is this done, ive been trying for ages
09:24:46 <mpickering> fozworth: The correct way is to have a FromJSON instance for the nested data and then just have (o .:? "k1")
09:25:11 <fozworth> mpickering: that makes sense, thanks
09:26:06 <trunks1ace> can someone give me some help with this: Define a function suffixes :: [a] -> [[a]] that returns the lists of all suffixes of a given string in descending order of length. For example, suffixes "perl" should return ["perl","erl","rl","l"] in that order. Hint: one way to do this is by repeated application of the tail function
09:26:29 <topi> clrnd, yeah that sounds reasonable
09:27:05 <fozworth> trunks1ace: look at Data.List.tails
09:27:36 <fozworth> http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Data-List.html#tails
09:27:56 <developernotes> trunks1ace is this homework?
09:28:48 <k00mi> trunks1ace: do you see the recursive structure of the resulting list?
09:29:12 <trunks1ace> developernotes: No, its a practice exam, in the exam you are not allowed to import modules
09:29:38 <trunks1ace> fozworth: its a practice exam and your not allowed to import modules...
09:30:06 <fozworth> trunks1ace: so reimplement it
09:30:21 <trunks1ace> k00mi: I do see the recursive structure but am not sure how to implement it
09:30:36 <trunks1ace> fozworth: oh yah! lol lemme try that, thanks
09:30:38 <developernotes> trunks1ace try typing tail "perl" in ghci
09:30:59 <Ferdirand> a list is either an empty list, or a head and a tail
09:31:13 <Ferdirand> what are the tails of an empty list ? what are the tails of a non-empty list ?
09:31:53 <developernotes> trunks1ace another thing to look at is let (x:xs) = "perl".  Now check the values of x and xs
09:32:54 <nyuszika7h> trunks1ace: not allowed to import modules? but that means you can't use prelude either! </sarcasm>
09:33:35 <developernotes> Has anyone run into a similar failure when attempting to install cabal-dev: http://pastie.org/9827794
09:35:27 <mpickering> cabal-dev is unmaintained now I think
09:35:32 <mpickering> what do you need it for?
09:36:09 <srhb> Not just unmaintained, deprecated (in favor of cabal sandbox) :)
09:36:49 <developernotes> mpickering oh interesting, I was looking for a way to perform sandbox installs of dependencies.  Is that available through another means now?
09:37:06 <srhb> developernotes: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
09:37:11 <developernotes> srhb ah, cabal sandbox is the ticket then, I will look into that.
09:37:13 <developernotes> thanks!
09:37:43 <srhb> So if cabal --version >= 1.18 on your system, you're good to go
09:37:47 <trunks1ace> developernotes: so far I have suffixes [] = [] br/ suffixes (x:xs) = (tail (x:xs) : suffixes xs)
09:38:16 <developernotes> trunks1ace have you tried loading it into ghci?
09:38:21 <k0ral> given that the "MonadReader r m | m -> r" class restricts r by fundep, would there be a benefit in implementing a tagged version "MonadReader r tag m | tag m -> r" (tag being a phantom type) to allow multiple MonadReader on a single monad m ?
09:38:23 <trunks1ace> developernotes: but this gives me ["erl,"rl","l"]
09:39:31 <kuribas> trunks1ace: you don't need to call tail, because xs is already the tail.
09:39:36 <k0ral> since I was unable to find any litterature on this topic, I may as well ask: why is a tagged MonadReader a bad approach ?
09:40:41 <trunks1ace> kurbias: oh yah, the question says: Hint: one way to do this is by repeated application of the tail function.
09:43:03 <trunks1ace> kurbias: suffixes [] = [] br/ suffixes x = (tail x : suffixes (tail x)) --this makes more sense using the hint
09:43:57 <nkar> augustss: I wonder how you manage dependencies at work.  do you use cabal-install?
09:44:07 <kuribas> trunks1ace: that looks better.
09:45:22 <kuribas> trunks1ace: now substitute "perl" for x, and you'll see the bug.
09:49:23 <trunks1ace> kurbias: suffixes [] = [] br/ suffixes x = (x : suffixes (tail x)) --Thanks !! dont know why that took me so long
09:51:39 <SrPx> I'm mutiplying a number by a vector using Linear, but GHC thinks my number is actually a vector. Which is weird, because it is clearly a number. Does anyone know why? http://lpaste.net/118325
09:52:30 <SrPx> The problem is in the "(dot ... ...) * rDir" part. The first term is a number, the second is a vector. It works on GHCI (for example, "3 * (V3 1 2 3)" works fine). But seems like on that code specifically it doesn't work...
09:56:19 <SrPx> Nevermind that last paste, I've managed to isolate way shorter: http://lpaste.net/118326
09:56:48 <jfischoff> SrPx: That is probably because the “3” is being converted to a V3 using fromInteger
09:56:52 <geekosaur> SrPx: does vector have ... that
09:57:05 <geekosaur> if it hasa  Num instace then fromInteger will be used to coerce numeric literals
09:57:19 <SrPx> What 3?
09:57:28 <jfischoff> you can’t use *  on two different types
09:57:59 <clrnd> Vector doesn't have a Num instance...
09:58:00 <geekosaur> "the first term is a number"
09:58:13 <SrPx> jfischoff: I thought it too, but it works ...!
09:58:35 <jfischoff> clrnd: V3 does
09:58:37 <geekosaur> but a number times a vector is a type error unless (a) there is a Num instance that can be used to coerce the numeric literal to a vector (b) you reimplemented Num so (*) is not Num a => a -> a -> a
09:58:39 <clrnd> ohhh
09:59:20 <jfischoff> SrPx: the type of “3” is `V3 a`
09:59:34 <jfischoff> in your ghci example that “works"
09:59:39 <SrPx> jfischoff: uh okay I see the point, but what do I do to fix my code?
10:00:05 <SrPx> I need to tell GHC that the "dot ... ..." is of type "V3 a", then, right? But adding a type annotation didn't fix it
10:00:21 <jfischoff> You need to use the operation for scaling a vector
10:00:46 <SrPx> what is it?
10:00:51 <geekosaur> "dot" sounds like a dot product which would be a scalar... so you'd need to fromInteger or  fromIntegral it to make a V3, like ghc does with the numeric literal
10:01:07 <SrPx> but it is not an Integer
10:01:17 <SrPx> dot returns a floating
10:01:25 <jfischoff> geekosaur: perhaps the Num instance might be pointwise multiplication though
10:01:29 <jfischoff> err
10:01:32 <jfischoff> which is fine
10:01:39 <geekosaur> :t (*)
10:01:40 <lambdabot> Num a => a -> a -> a
10:02:04 <jfischoff> geekosaur: your suggestion will probably work, I doubt it is the recommended way to use the library
10:02:47 <jfischoff> https://hackage.haskell.org/package/linear-1.15.5/docs/Linear-Vector.html#v:-42--94-
10:03:08 <jfischoff> SrPx, geekosaur ^
10:03:10 <geekosaur> yeh, I have no real idea there
10:03:51 <geekosaur> ok, yeh, that looks like the right way to do it
10:04:04 <geekosaur> (*) itself can't because types must match
10:05:51 <SrPx> jfischoff: ah... there it is! I couldn't ever find this function. Thanks! brb gonna refactor a ton of "fmap (* x) vec"
10:06:04 <jfischoff> np
10:08:07 <athan> So, I have an inductive list at the type level, and -XConstraintKinds, and found myself "folding" over the list to give a crazy constraint... I feel like my Haskell code is evolving or something
10:08:42 <HeladoDeBrownie> metaprogramming skill level up!
10:16:31 * hackagebot resolve-trivial-conflicts 0.2.0.1 - Remove trivial conflict markers in a git repository  http://hackage.haskell.org/package/resolve-trivial-conflicts-0.2.0.1 (EyalLotem)
10:21:51 <athan> HeladoDeBrownie: This isn't metaprogramming... it's more like... exaprogramming or something :P
10:26:00 <lpaste> biglama pasted “monadreader14” at http://lpaste.net/118328
10:26:23 <biglama> hi guys, can you help me understand this function (decodeLetter) ? it's from the monad reader http://themonadreader.files.wordpress.com/2009/07/issue142.pdf
10:26:56 <athan> biglama: What are you confused on?
10:26:56 <biglama> and i don't understand the foldl syntax : there is not enough arguments for me...
10:27:00 <athan> Do you know how folds work?
10:27:01 <athan> oh dude
10:27:11 <athan> okay, so checkt his out
10:27:20 <athan> :t foldl -- biglama
10:27:21 <lambdabot> (b -> a -> b) -> b -> [a] -> b
10:27:22 <biglama> yeah, but it's supposed to have a function, an accumulator and a list
10:27:47 <athan> yep, where the function looks like: the accumulator comes first, then the element in the list, then return the acc type
10:28:06 <athan> biglama: You'll get a hang of reading this way
10:28:21 <athan> so we have the function `flip step`
10:28:29 <athan> and the acc `dict`
10:28:42 <timmy_tofu> Since upgrading to 7.8.4 and cabal 1.22 I can no longer use ghc-mod - I get '{path}/dist/setup-config: hGetContents: invalid argument (invalid byte sequence)' - anyone else having this problem?
10:28:50 <biglama> i thought dict was supposed to be the accumulator ?
10:29:06 <athan> biglama: You're right, i just abbreviated to acc
10:29:24 <timmy_tofu> looking in dist/setup-config I see 'Saved package config for {package} written by Cabal-1.22.0.0 using ghc-7.10', the GHC version is obviously wrong, but I don't think that's a big deal
10:29:51 <athan> biglama: So, decode_letter expects still the list itself
10:30:03 <athan> (and applies `tag` after the fold is complete)
10:30:14 <marioxcc> Hi.
10:30:23 <athan> hello (:
10:30:25 <marioxcc> I'm trying to define an infinite list with the Fibonacci sequence.
10:30:42 <marioxcc> “fibonacciTail f1 f2 = [f1 : fibonacciTail f2 (f1 + f2)]” doesn't compile because of type errors. What I am doing wrong?
10:31:03 <marioxcc> (The plan was to do “fibonacci = fibonacciTail 0 1”)
10:31:03 <johnw> the syntax is wrong first
10:31:15 <johnw> (x:y), rather than [x:y]
10:31:25 <athan> marioxcc: do you know how `cons` works?
10:31:41 <marioxcc> athan: I know how it works in Lisp only.
10:31:57 <athan> > 1:2:3:[] == [1,2,3] -- marioxcc
10:31:58 <lambdabot>  True
10:31:59 <biglama> athan: right, I was confused for nothing. Thanks for explaining !
10:32:08 <biglama> do you know what the tag function is by the way ?
10:32:34 <athan> biglama: Can't say :\ (maybe for unification?)
10:32:43 <biglama> okay
10:33:02 <biglama> and why did they use a flip step, instead of writing the inverse function directly ?
10:33:14 <athan> :t (:) -- marioxcc
10:33:15 <lambdabot> a -> [a] -> [a]
10:33:21 <marioxcc> athan: Ok, right. What's the difference between [x:y] and (x:y). I think that the later is a cons, but isn't the first equivalent to the later as well?.
10:33:24 <biglama> like : step' Left = '.'
10:33:49 <johnw> [x:y] would be a list of one element consisting of the list (x:y)
10:33:57 <athan> marioxcc: `[1,2]` == (1:2:[])` :)
10:34:22 <athan> biglama: So, flip just swaps the first two parameters of a function
10:34:24 <athan> :t flip
10:34:25 <lambdabot> (a -> b -> c) -> b -> a -> c
10:34:57 <athan> they probably mean to see `step` as the correct order, there
10:35:11 <tremon> biglama: tag looks to be the value of a tree node, see line 2
10:35:19 <athan> often we have to flip the folding function when collapsing a list with a simple function
10:35:32 <marioxcc> Ok
10:35:36 <athan> > foldl (:) [] [1,2,3,4] -- biglama
10:35:38 <lambdabot>  Occurs check: cannot construct the infinite type: t ~ [t]
10:35:38 <lambdabot>  Expected type: [t] -> [[t]] -> [t]
10:35:38 <lambdabot>    Actual type: [t] -> [[t]] -> [[t]]
10:35:42 <athan> her derp
10:36:11 <athan> > foldl (flip (:)) [] [1,2,3,4] -- biglama
10:36:13 <lambdabot>  [4,3,2,1]
10:36:15 <athan> :)
10:36:24 <athan> > foldl (++) [] [1,2,3,4] -- biglama
10:36:25 <lambdabot>  No instance for (GHC.Show.Show a0)
10:36:25 <lambdabot>    arising from a use of ‘M37106651577767406582385.show_M37106651577767406582...
10:36:25 <lambdabot>  The type variable ‘a0’ is ambiguous
10:36:28 <athan> erm
10:36:29 <athan> shoot
10:37:06 <HeladoDeBrownie> athan, maybe test out what you want to say in a pm with lambdabot first :)
10:39:14 <biglama> athan: i think i got it, thanks :)
10:40:54 <marioxcc> Why is it that one can Show 1 but one can't Read "1" without a type declaration?
10:41:22 <marioxcc> Read "1" :: Int works. I know that haskell needs to know the type, but why doesn't it needs to know the type of 1 in Show 1?
10:41:27 <marioxcc> (I.e: Int, Integer, etc...)
10:41:38 <shachaf> marioxcc: Defaulting.
10:42:06 <marioxcc> Ok.
10:43:32 <hodapp> nooooo... I might need another monad transformer...
10:43:52 <ReinH> :t \x y -> [x:y] -- marioxcc
10:43:53 <lambdabot> a -> [a] -> [[a]]
10:43:54 <athan> hodapp: Applicative transformer?
10:44:04 <ReinH> marioxcc: [x:y] = [(x:y)]
10:44:27 <ReinH> It conses x onto the list y and wraps the result in the singleton list
10:44:41 <marioxcc> ReinH: Ok, thanks.
10:44:53 <athan> marioxcc: String values don't uniquely identify the type they would inhabit if it was parsed into a value
10:45:53 <marioxcc> athan: Right. I'm aware of that, but not of why “show 1” works given that 1 isn't of a specific type.
10:47:57 <athan> marioxcc: Well, in theory yes it is
10:48:10 <athan> so base-10 literals are overloaded and polymorphic:
10:48:14 <athan> @type 1
10:48:15 <lambdabot> Num a => a
10:48:39 <athan> marioxcc: But I think when `show`ing a number literal, it defaults to the `Integer` instance
10:48:48 <athan> @type show 1
10:48:49 <lambdabot> String
10:48:54 <marioxcc> athan: Ok.
10:48:55 <athan> derp
10:50:25 <marioxcc> What's the convention to name functions that return a boolean type?
10:50:48 <marioxcc> In Java it's isPROPERTY in Common Lisp it's PROPERTY-p
10:51:47 <athan> marioxcc: Just a type signature :P
10:52:02 <athan> sometimes we do `isFoo :: a -> Bool`
10:52:16 <haskellN00b> Hello all.  I have the code here (https://gist.github.com/7fc050fcf75190534f2f.git)  you might recognise that is compiling and working correctly.  Then I noticed I don't actually need the s variable, as it is always the same thing.  So I changed the code to this (https://gist.github.com/7db64a38b1baba5d1edb.git).  Now I'm getting "Could not deduce (a ~b)" for the function f in fmap... but this *shouldn't* be a ~ b.  The whole poin
10:52:50 <marioxcc> athan: Ok.
10:53:10 <quchen> You generally want to avoid boolean values in favour of custom data types. "File -> IO Bool" says nothing about what it does, "File -> IO Writable" describes things much better.
10:53:22 <marioxcc> Thanks for your help to all who answered.
10:54:01 <athan> haskellN00b: You could play with that as a context
10:54:12 <athan> so `foo :: (a ~ b) => a -> ...`
10:54:22 <athan> s/context/constraint
10:54:46 <marioxcc> Does GHC do an optimization so that the simplest recursive fatorial definition doesn't takes N stack frames?
10:55:59 <haskellN00b> athan:  Ok.  How can I do that though?  The problem is in the definition of fmap so I can't redefine fmap with constraints (same problem as Set monad)
10:56:18 <levi> marioxcc: GHC's usage of "stack frames" is not quite the same as a language like C, which makes that question tricky to answer.
10:56:24 <haskellN00b> I suppose I could make a new fmap that isn't in the type class and see what happens...
10:56:31 <athan> wait one sec :P
10:56:49 <marioxcc> levi: Ok.
10:57:03 <SrPx> Gay question but would it be possible to make this syntax correct: http://lpaste.net/118329 by considering an implicit "where", or is there an ambiguity?
10:57:13 <trunks2ace> ok so this isnt about haskell but how do I join a channel with a registered user using webchat? I have registered a user and want to join ##java
10:57:30 <marioxcc> levi: But will it use O(N) memory for the non-tail recursive implementation?.
10:57:39 <ReinH> SrPx: Please don't use "gay" as a derogatory term.
10:57:46 <athan> SrPx: Please no steriotypical offenses
10:58:16 <athan> haskellN00b: Why would you want the function to be a functor?
10:58:28 <jfischoff> ReinH, athan: Thank you for speaking up
10:58:28 <athan> oh wait sorry
10:58:33 <SrPx> What the heck, it is not derogatory in any way...
10:58:53 <hiptobecubic> SrPx, this isn't the place to argue it.
10:58:56 <jfischoff> Here SrPx I will explain in a PM
10:59:05 <athan> SrPx: Well, from your context, you used it in a way that shows you don't like whatever is "gay"
10:59:07 <SrPx> I grew in a culture where being gay is completely normal and a good thing. That didn't even cross my mind.
10:59:10 <trunks2ace> any1... ok so this isnt about haskell but how do I join a channel with a registered user using webchat? I have registered a user and want to join ##java
10:59:16 <athan> thanks jfischoff :)
10:59:27 <ReinH> SrPx: Then the modifier "gay" is meaningless and should be removed anyway
10:59:35 <ReinH> But honestly I don't believe you.
10:59:42 <pavonia> trunks2ace: Check out /nickserv help identify
10:59:49 <athan> SrPx: I grew up terrorized for seeming like it :\
11:00:01 <athan> SrPx: Have you been bullied before?
11:00:28 <athan> haskellN00b: This is a good one :)
11:00:32 <hiptobecubic> Southpark had an episode about this which was pretty great. But let's not spiral off into a discussion about language usage
11:00:35 <marioxcc> Where can I look up the order of infix operators?
11:00:38 <ReinH> hiptobecubic: agree
11:00:48 <trunks2ace> pavonia: I have logged in to my user but what is the syntax to join a new channel from there... as i have been using this page as of yet: https://webchat.freenode.net/
11:00:49 <athan> marioxcc: Source code / hackage :\
11:00:55 <athan> or `:i` I think
11:01:04 <ReinH> marioxcc: Each infix operator can be given a different fixity, so you will have to look at the documentation for each.
11:01:06 <levi> marioxcc: Memory usage depends largely on when lazy values are forced to be evaluated. It's tricky to give the memory usage of a function that's not written out in full.
11:01:20 <SrPx> athan: Hum no? ReinH it is not meaningless, it means "effeminate". If I said "girly" instead, it would be a problem, too? Or, if I said "manly" for the opposite, would it be a problem?
11:01:23 <ReinH> marioxcc: for arithmetic operations, you can expect PEMDAS to apply
11:01:39 <athan> SrPx: Why not "bad"?
11:01:42 <marioxcc> ReinH: Ok. Where can I look the standard language priorities?.
11:01:47 <ReinH> SrPx: No it doesn't. This isn't up for discussion. Do not do it again.
11:01:52 <marioxcc> For instance. $ and arithmetic operations.
11:01:56 <athan> we don't need personal modifiers to denote poor quality :P
11:02:04 <SrPx> Honestly, I've been in gay parades and have a ton of gay friends. I actually find it offending that you are putting such a weight inside a positive word.
11:02:06 <ReinH> marioxcc: there aren't any, each operation is specified  separately
11:02:08 <haskellN00b> athan: thanks
11:02:13 <haskellN00b> :/
11:02:19 <athan> haskellN00b: Hold on! Have hope! :P
11:02:22 <marioxcc> ReinH: Ok.
11:02:33 <ReinH> SrPx: And yes, "girly" or "manly" would also be a problem. Please stop.
11:02:44 <haskellN00b> athan: oh I'm sure it can be done, I just wonder how many pragmas I will need to fix it and why. :)
11:02:52 <athan> haskellN00b: So here is where the issue is
11:02:55 <SrPx> No, it would not. That is absurdly prejudiced from your side.
11:03:06 <ReinH> SrPx: Stop.
11:03:08 <hodapp> SrPx: You do not choose a word's connotation.
11:03:23 <hodapp> SrPx: You do, however, choose how you use it.
11:03:42 <athan> haskellN00b: you want the `SessionT f` functor to be parameterized over a variable `a` in it's definition on line 7 in your gist, right?
11:03:48 <jfischoff> This conversation needs to stop. it is not about Haskell and it is offense
11:03:55 <haskellN00b> SrPx: Are you trolling?  It's not acceptable to talk like that in this room.  Just stop, don't try to preach to us.  Just accept that we're not as "enlightened" as you or whatever and move on.
11:04:09 <athan> such that `SessionT m` is an instance of Functor, correct?
11:04:11 <johnw> haskellN00b++
11:04:12 <athan> check this out
11:04:12 <haskellN00b> athan: right
11:05:57 <athan> haskellN00b: wait...
11:05:59 <athan> ><
11:06:12 <athan> your ambiguous variable names are confusing me :P
11:06:29 <haskellN00b> yea, it was even worse from the code I, erm, was inspired by
11:06:29 <marioxcc> When declaring a function that clearly returns an integer that fits within Int or Int8, etc.. Should I declare it as f :: (Num a) -> a [...] or as f :: Int [...] ?
11:06:41 <marioxcc> I mean, what's the good practice in this case?.
11:06:56 <hodapp> hmm, what I've run into is that I keep using... ifte_ (condition) (true case) (false case) in Ivory.  But, right now I'm having to convert a switch/case to this, and so there is a lot of nesting inside of the false case (because it will just have another ifte_ call inside it).
11:06:58 <athan> haskellN00b: I have a feeling it's from the prefix of `SessionT` being outside it's return type, yet bound
11:07:02 <hiptobecubic> marioxcc, I'm not sure that's what you meant to type
11:07:03 <athan> erm... unified
11:07:07 <SrPx> Sure. As a clarification for anyone on the channel, gay or not - I have the uttermost respect for everyone's choice of sexual orientation and am actively in the fight against social exclusion. I've never intended to offend anyone - that thought didn't even cross my mind - and, if that was the case, I'm profoundly sorry and will do my best not to repeat this incident.
11:07:14 <haskellN00b> marioxcc: IMO say what you mean.  If it can only ever be an Int (or Int8 or whatever) and nothing else can ever make sense, I would say that
11:07:16 <athan> by prefix, I mean `r` in `r -> m a`
11:08:08 <marioxcc> haskellN00b: but then summing it results to a float, etc... will give type error.
11:08:13 <marioxcc> It will require a type conversion.
11:08:31 <haskellN00b> marioxcc: which is what you want.  If you want floats then use floats explicitly
11:08:35 <hodapp> and I can do:  ifte_ (cond1) (true case) $ ifte_ (cond2) (true case) $ ifte_ (cond3) ...
11:08:42 <athan> SrPx: (: stay safe!
11:08:43 <hodapp> it's a little ugly, but it eliminates a lot of parens.
11:08:49 <athan> type-safe convorsations!
11:09:14 <marioxcc> athan: Was that an answer to me?.
11:09:22 <hodapp> this seems like it's basically a continuation, but I'm not sure how I'd meaningfully shoehorn it into one
11:09:46 <athan> marioxcc: Oh, no for haskellN00b
11:10:21 <marioxcc> athan: Ok.
11:10:40 <haskellN00b> athan: I'm pursuing your original line of thought and pulling it out of the monad.  There is a post on stack overflow where someone had something like:            f :: a -> b          f x = x             which was throwing a type error but if he put the exact same thing in a monad he got the same error I got, it almost seems like it gets the error backwards
11:10:50 <athan> haskellN00b: So, you made your other implementation look like `SessionT . (first f <$> runSessionT m)`, right?
11:11:01 <haskellN00b> yes
11:11:23 <haskellN00b> I'm just trying to get the types right on my fmap' that doesn't live in Functor. :)
11:11:35 <athan> haskellN00b: Mess with MonadReaders - I've run into similar issues when overloading the `runReader` function :(
11:11:45 <haskellN00b> :)
11:11:45 <athan> haha
11:11:49 <athan> good luck!!
11:13:20 <haskellN00b> for completeness: here is the whole error I'm getting  (https://gist.github.com/f7868bdafc68aff7784e.git)
11:13:37 <SrPx> This is mostly a stylistic question and not prioritary, but would it be possible to make this syntax correct: http://lpaste.net/118329 by considering an implicit "where", or is there an ambiguity?
11:14:12 <ReinH> SrPx: Understood, it's just one of those things that has impact beyond what you may have intended. :/
11:14:47 <mauke> SrPx: where do you put the 'where'?
11:14:47 <ReinH> SrPx: I appreciate the clarification.
11:15:21 <mauke> foo a b = bar a + boo where b bar = ... is syntactically valid
11:16:42 <haskellN00b> athan: so I've made the new function:    fmapp f m = SessionT $ \s -> first f <$> runSessionT m s     with the simple signature     fmapp :: (a -> b) -> f a -> f b      (do I need more than that?)    and it seems to have the same error  (plus one complaining about not being able to work out that f is  SessionT m but I'm not sure how to make that constraint
11:16:44 <ozgura> does anyone know whether we are getting a binary release of GHC-7.8.4 for OS X or not?
11:17:21 <athan> haskellN00b: For some reason, the Functor isn't ubiquitously parameterized over a
11:17:28 <athan> not sure yet how to fix it :s
11:17:45 <marioxcc> Hi. Why does this code gives a syntax error?
11:17:45 <marioxcc> http://lpaste.net/118331
11:17:59 <athan> AHH
11:18:02 <SrPx> ReinH: yes. I do want to live in a world where prejudice is inexistent to the point that term won't have such a heavy impact - but, as you said, I don't chose it. I just hope I haven't actually offended anyone.
11:18:02 <haskellN00b> athan: but this is so terribly bizarre.  If I make SessionDriver a   into a type variable.... then everything works fine
11:18:21 <athan> haskellN00b: When you run the transformer, you loose the information that the prefix's `a` ~ the return values `a`
11:18:21 <ReinH> SrPx: Understood. I think we can leave it here. :)
11:18:30 <SrPx> Yes of course.
11:18:35 <ReinH> SrPx: <3
11:18:41 <athan> haskellN00b: Do you understand yet?
11:18:48 <haskellN00b> nope.... :)
11:19:03 <SrPx> ReinH: sz
11:19:05 <athan> SrPx: No no, I want to bring it up again and complain!
11:19:11 <ReinH> SrPx: no worries :)
11:19:15 <athan> SrPx: :P thanks for the care :)
11:19:23 <SrPx> athan: (=
11:19:24 <ahihi> marioxcc, there's a superfluous '=' at the end of line 2
11:19:39 <athan> haskellN00b: So, when you run the transformer and apply it's parameter, you _lose_ that parameter
11:19:52 <mauke> marioxcc: when asking for help it's good to include the actual error message
11:19:52 <marioxcc> ahihi: Ok, thanks.
11:20:07 <haskellN00b> athan: ok so I'm losing the a  but it's still there in   (a, ....)
11:20:13 <marioxcc> mauke: I assumed that it was something trivial, and that was indeed the case.
11:20:14 <J_Arcane> Is there a 'reverse map' function? ie. that can apply a list of functions to a given x?
11:20:16 <athan> then, if you try and create a new transformer, how it it supposed to infer that the parameter's nested `a` is equvalent to whatever value you're wrapping it with?
11:20:30 <athan> haskellN00b: Yes, exactly
11:20:36 <mauke> marioxcc: yes, and the error message tells you where and what the trivial error is
11:20:41 <mauke> or maybe not you, but us
11:20:42 <quchen> map ($ x) [f, g, h] -- J_Arcane
11:20:54 <athan> haskellN00b: This is where you have to force the types to unify from the top
11:21:02 <athan> it can be really difficult :)
11:21:30 <ReinH> :t \x -> map ($ x
11:21:31 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
11:21:32 <ReinH> :t \x -> map ($ x)
11:21:33 <lambdabot> a -> [a -> b] -> [b]
11:21:40 <marioxcc> mauke: I took a guess that it'd be unnecessary and I was right, but thanks for the recommendation.
11:21:41 <ReinH> :t sequence
11:21:42 <lambdabot> Monad m => [m a] -> m [a]
11:21:53 <haskellN00b> athan: I'm not quite getting why the compiler can't work out that the a's are the same, but if you are correct can you explain why the first gist works?  Shouldn't that be in at least as bad a position?
11:22:02 <ReinH> specialize m to ((->) r) and bob's your uncle.
11:22:30 <ReinH> Although map ($ x) might be more easily readable
11:23:31 <athan> haskellN00b: because the `s` terms are the same, I think
11:24:17 <haskellN00b> athan: very strange.  Do you know a way I can fix it (besides adding the s back in.... :)
11:25:15 <athan> haskellN00b: Using -XScopedTypeVariables maybe!
11:25:34 <Lutin`> So I'm trying to set up a friend for haskell development on Windows, anyone have a good experience with doing so?
11:26:04 <Lutin`> I'm tempted to go the mingw/msys route and convince him to switch to a Linux dev environment ;)
11:26:33 <haskellN00b> athan: nice idea but nope. :)
11:26:33 * hackagebot buildwrapper 0.9.0 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.9.0 (JeanPhilippeMoresmau)
11:26:35 * hackagebot scion-browser 0.4.3 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.4.3 (JeanPhilippeMoresmau)
11:27:25 <Lutin`> But that probably would be less friendly than he would like
11:27:57 <ReinH> Lutin`: I suggest setting up a linux virtualbox VM.
11:28:10 <Lutin`> Yeah that's how I do it
11:28:11 <ReinH> modern linux desktops really aren't that bad
11:28:29 <Lutin`> Oh I know :) I only run linux on all my comps
11:28:31 <ReinH> And if he's using it for Haskell he really doesn't need to worry about the rest of the OS
11:28:35 <ReinH> just the parts that let him use haskell
11:29:02 <ReinH> the only reason I wouldn't suggest a headless server VM is that then you have to use putty.
11:29:19 <ReinH> I have a NixOS VM on my windows machine that I really enjoy using.
11:29:27 <Lutin`> Ooh that's a good idea
11:29:31 <ReinH> but that's a whole nother learning curve that I wouldn't recommend
11:29:40 <Lutin`> at least a good idea for me haha
11:29:47 <ReinH> Lutin`: Yeah, I set up a minimal NixOS VM and added xmonad and I *love* it.
11:29:49 <Lutin`> I'll probably just put him on Ubuntu or Debian
11:29:50 <J_Arcane> Lutin`: I just use Haskell Platform and Emacs.
11:29:58 <athan> haskellN00b: Idk then :)
11:30:00 <haskellN00b> athan:  oh oh oh!
11:30:04 <athan> hmm!
11:30:07 <J_Arcane> If you want a quick-and-dirty Linux learner's environment though, there's Koding.
11:30:13 <ReinH> Lutin`: Ubuntu then probably if only for the larger community
11:30:14 <haskellN00b> you were right that it was an a mismatch, but not the one we thought
11:30:23 <athan> I use atom & haskell-ide
11:30:25 <Lutin`> ReinH: Yeah that's what I was thinking
11:30:40 <ReinH> J_Arcane: Koding is new to me. Cool.
11:30:44 <J_Arcane> Browser-based Linux dev environment. No install required.
11:30:48 <ReinH> athan: there's a "haskell-ide" for atom?
11:30:56 <haskellN00b> athan: the problem wasn't that I turned s into a concrete object, the problem was that *that* object also had an "a".  I've removed that and now it's all fixed
11:31:01 <levi> I have a Linux Terminal Server Project server running, and the client image serves up a cut-down Ubuntu with xmonad. Got a bunch of old thin clients from work surplus.
11:31:08 <ReinH> athan: I wrote a minimal ghc-mod integration for atom when it first came out but I just couldn't make myself like the editor enough to use it.
11:31:09 <J_Arcane> Though, I had difficulties with building a more up-to-date Cabal.
11:31:10 <athan> ReinH: It still needs some polish, but it's nice :)
11:31:11 <haskellN00b> concrete data thing, whatever
11:31:23 <athan> ReinH: It's very buggy :(
11:31:31 <ReinH> athan: that and it's no vim or emacs
11:31:43 <J_Arcane> ReinH: There's several Haskell modes for Atom no but I've not tried them, or indeed, Atom.
11:31:43 <athan> haskellN00b: Doh!
11:31:44 <Lutin`> J_Arcane: How's the haskell-mode and ghc-mod support with WinEmacs?
11:31:59 <athan> haskellN00b: Well at least there was adventure :)
11:32:00 <ReinH> Lutin`: dunno, probably terrible. ;)
11:32:01 <J_Arcane> Lutin`: I'm pretty happy with it, once I got the indentation settings right.
11:32:22 <haskellN00b> I'm using eclipsefp.  I don't like eclipse really, and eclipsefb is very... involved but once you get it rolling it lets me forget of a lot of incidental complexity and get back to the coding
11:32:23 <ReinH> I had enough problems with ghc-mod on *nix.
11:32:32 <Lutin`> ^^
11:32:34 <ReinH> Well, OS X so BSD really
11:32:36 <J_Arcane> Mind you, there are still kinks. In particular I run into a lot of random errors trying to build Cabal and its packages on Windows.
11:32:38 <ReinH> same difference
11:32:46 <haskellN00b> athan: yep, thanks for going along. :)
11:32:55 <athan> :D
11:33:09 <ReinH> I am currently finding it very hard to live without haskell-mode and structured-haskell-mode and ghci-ng integration in emacs.
11:33:18 <ReinH> and hindent integration as well
11:33:35 <haskellN00b> ReinH: what are you using?  Why not those things if you're used to them?
11:33:40 <ReinH> Hmm, I should get flycheck working.
11:33:41 <athan> J_Arcane: Koding may be my new ide! =o
11:33:50 <ReinH> haskellN00b: that is what I'm using.
11:34:01 <haskellN00b> ah i c
11:34:11 <Lutin`> See I really want to try all of those things
11:34:18 <gatlin> I'm reading this SO answer (http://stackoverflow.com/a/15419213) and I can't figure out which language extension allows `instance Blah { recordAccessor :: tyvar } where ...`
11:34:25 <Lutin`> but my fingers just want to hit vim motions and commands
11:34:29 <gatlin> can anyone point me in the right direction?
11:34:38 <Lutin`> and evil mode just feels wrong
11:34:48 <athan> gatlin: Woah!
11:34:54 <athan> gatlin: I wish I knew!
11:35:17 <ReinH> Lutin`: yeah, well I have used vim for over a decade. It took some time to switch but for haskell it was well worth it.
11:35:26 <ReinH> I'm starting to use emacs for more general stuff as well and really enjoying it.
11:35:29 <J_Arcane> athan: Be warned though, it's Debian/Ubuntu based, which means the Haskell packages are out of date; and the VM has pretty paltry memory. I couldn't actually do 'cabal update cabal' because it didn't have enough ram to build it.
11:35:38 <Lutin`> ReinH: using Emacs keybindings?
11:35:43 <ReinH> Lutin`: yep
11:35:46 <levi> ReinH: I could deal with the loss of all the other things you listed *aside* from flycheck working well. :)
11:36:03 <ReinH> levi: Well, I still get compilation from haskell-mode with C-c C-l
11:36:07 <ReinH> but flycheck is great
11:36:09 <levi> Instant type error feedback is wonderful.
11:36:11 <gatlin> athan: I could maybe guess at what it is doing and accomplish it some other way but the formal spec may contain things I can't simply deduce
11:36:31 <athan> J_Arcane: I just saw :\. But, I love the idea
11:36:38 <ReinH> Lutin`: I've never found vim bindings that don't have holes that make them unusable for me: I use a lot of the surface area of vim.
11:36:39 <athan> maybe.. I could... steal it! >:D
11:36:50 <ReinH> So when my muscle memory doesn't work, I can't really use them.
11:37:01 <ReinH> levi: yep.
11:37:14 <J_Arcane> athan: I think there's a few others like it too, Cloud9 is one I think. Koding had the best interface until recently though (the current one is new, and terrible.)
11:37:22 <Lutin`> ReinH: any tips?
11:37:27 <Lutin`> for learning emacs bindings
11:37:42 <Lutin`> and yeah I agree I use so many leader and remaps
11:37:46 <athan> Haha. Thanks J_Arcane.
11:37:55 <ReinH> Lutin`: Same as for vim, really. Go slow, try to force yourself to use the new bindings you do learn, and try to find better ways to perform common tasks.
11:38:11 <ReinH> Lutin`: Use org-mode to take notes as you learn bindings.
11:38:29 <mauke> I wish you luck :-)
11:38:39 <ReinH> Lutin`: not even custom maps. Standard ones. There's just a *lot* more to vim than hjkl.
11:38:40 <haskellN00b> gatlin: Are you sure that *is* valid?  I just tried it in eclipsefp and it didn't suggest anything.  Normally it suggests the pragma I need
11:38:46 <athan> eff yes! Cloud9 has GH integration!
11:38:50 <mauke> I tried to learn emacs once and it pissed me off beyond measure
11:38:58 <ReinH> e.g. if I can't use ex commands then it's a no go
11:39:01 <levi> org-mode is a crazy thing, but remarkably useful.
11:39:02 <Lutin`> ReinH: yeah I know
11:39:08 <ReinH> levi: indeed
11:39:22 <ReinH> levi: I use it pretty extensively now, but not as extensively as someone like johnw
11:39:22 <gatlin> haskellNOOb: No, I'm not. It apparently got a response from Gabriel Gonzalez without a mention of the syntax so it's either something incredibly obvious or incredibly obscure
11:39:45 <ReinH> levi: I use it to organize reading material and notes, shopping lists, lots of stuff. It's great.
11:39:53 <Lutin`> One of my professors showed me AUCTeX and that alone is making me want to switch
11:40:09 <ReinH> Lutin`: Yeah, AUCTeX is quite nice, although I don't write enough TeX to really make use of it.
11:40:32 <levi> ReinH: I use it periodically for various things. I've tried quite a lot of its features, but I'm not really "organized" enough to use any parts of it consistently. :)
11:40:35 <ReinH> Also there's now a stack overflow major mode so I really don't need to ever leave emacs any more
11:40:41 <Lutin`> Ah I take all my class notes using latex and all my class assignments
11:40:48 <haskellN00b> athan:  Ok, thanks a lot for your help.  I'm off to do some more exploring. :)
11:40:53 <Lutin`> and presentations
11:40:54 <ReinH> levi: forcing myself to use it consistently is what is making me more organized ;)
11:40:59 <Lutin`> etc..
11:41:46 <ReinH> levi: Every time I have an idea or a reminder or etc I C-c C-t (org-capture) and put it in my inbox. It's really been a great help.
11:41:52 <athan> haskellN00b: Bring a shovel!
11:41:56 <ReinH> Lutin`: nice
11:41:56 <athan> oop, too late :\
11:42:19 <Lutin`> LaTeX really makes me hate the equation editor in Word haha
11:42:33 <Lutin`> and powerpoint
11:42:34 <ReinH> Well, I already hate Word
11:43:30 <Lutin`> :O There's a LaTeX equation editor for LibreOffice
11:43:43 <Lutin`> Still wouldn't be enough...
11:44:30 <shock_one> Hi. Does this code reduce (f a x)?  foldl' f a (x:xs) = seq (f a x) (foldl' f (f a x) xs)
11:46:24 <Lutin`> That seq is unnecessary if you use foldl'
11:46:58 <Lutin`> foldl' is already strict in it's application of the function
11:47:23 <shock_one> I understand, I'm just trying to understand graph reduction, and my question is whether (f a x) in both cases will point to the same node.
11:47:25 <Lutin`> Oh..you're defining it >_>
11:47:44 <shock_one> Or do I have to use let.
11:47:51 <Lutin`> use let
11:48:12 <shock_one> So, your answer is that GHC doesn't reduce this graph?
11:48:23 <Lutin`> I'm unsure of how ghc would optimize it, but I see it as more readable
11:49:38 <shock_one> Is that the biggest problem? Aren't you concerned that I'm redefining a library function? No offence, but my goal is not to increase readability, but to understand how it works.
11:51:21 <S11001001> shock_one: I think the problem may have been that I, at least, read your first use of "reduce" as "reduce [to whnf]"
11:54:05 <Lutin`> shock_one: That should be picked up by CSE
11:54:13 <shock_one> S11001001: that's correct. It surely gets reduced, but the question is whether the second occurrence will point to the reduced node.
11:54:29 <Lutin`> common-sub-expression elimination
11:54:38 <shachaf> GHC doesn't in general do CSE.
11:54:48 <shachaf> Certainly I wouldn't expect it to in a case like shock_one's code.
11:55:02 <ReinH> shock_one: Relevant SO question: http://stackoverflow.com/questions/13382993/when-does-ghc-use-sharing
11:55:17 <shachaf> If you want sharing there you should use let.
11:55:30 <ReinH> Don's answer seems definitive.
11:55:32 <quchen> shachaf: Does it ever do CSE? I thought I remembered someone mentioning something like this here.
11:55:57 <shachaf> Yes, GHC does CSE in some cases.
11:57:45 <Lutin`> Ah okay that clears it up for me. Thanks ReinH, shachaf
11:58:28 <shock_one> So, instead of asking I tried, and it takes the same time for both let and non-let variants.
11:59:10 <shock_one> Or should I measure space?
11:59:24 <Lutin`> shock_one: You could use something like ghc-vis
12:00:10 <shock_one> Thank you, everybody.
12:00:38 <shachaf> You could look at the generated code.
12:00:50 <shachaf> ghc -ddump-simpl
12:01:48 <monochrom> in fact, ghc -O (or -O2, whichever one you actually use for real) -fforce-recomp -ddump-simpl -dsuppress-all -dsuppress-uniques -ddump-to-file :)
12:03:33 <bananagram> is there a System.File like System.Directory? for some reason I don't have it
12:03:52 <marioxcc> In the “where” of a function definition. Can a clause reference another clause?
12:04:03 <bananagram> can't find a fileExists :: FilePath -> IO Bool
12:04:09 <bergmark> marioxcc: yes
12:04:11 <shachaf> marioxcc: What happened when you tried it?
12:04:36 <marioxcc> Ok, thanks
12:05:26 <haskellN00b> And I'm back. :)
12:06:15 <athan> haskellN00b: Any scars?
12:06:23 <haskellN00b> haha, just fun
12:06:33 <haskellN00b> but now I've got the next problem:   https://gist.github.com/673e3eb15a567e792a08.git
12:07:02 <haskellN00b> not a problem, per se.  This function works fine, but I'm wondering: do I have to hardcode IO there?  The whole point of SessionT instead of Session was I was hoping I would not
12:07:27 <haskellN00b> but I tried:       IO m => ....   and the compiler literally spat in my face
12:07:45 <athan> haskellN00b: You'll learn to see the spit wads coming
12:08:16 <EvanR> haskellN00b: IO m isn't a constraint so it cant be on the left side of =>
12:08:25 <athan> haskellN00b: There are some things we can do to make this more general, but you will find that Haskell is very strict in how types are specified
12:08:26 <haskellN00b> athan: I prefer a big haskell loogi to C# just nodding it's head and giggling behind its hand, knowing I'm going to get an angry call in about 3 days or so
12:08:41 <athan> there still has to be a "path" for the unification to uniquely take place
12:08:45 <EvanR> Monad m for example would be a valid LHS of =>
12:08:52 <athan> hahaha
12:09:22 <athan> haskellN00b: I often let `ghci` do the most-general type inference for me
12:09:37 <EvanR> haskellN00b: if you paste compiler error messages that you dont understand, theres a change someone can help you read it. or it could just be incomprehensible
12:09:39 <haskellN00b> EvanR: I figured IO m wouldn't work, but is there something that can take its place?  MonadIO didn't seem to work either (which I kind of didn't expect to work either)
12:10:04 <EvanR> haskellN00b: MonadIO m => is at least well-formed
12:10:07 <athan> haskellN00b: What does `driverSave` look like?
12:10:38 <athan> if you can make `driverSave` more general, then you're good to go
12:10:47 <haskellN00b> athan, EvanR:  It would probably help to just tell you what I'm trying to do here.    My special   SessionT   class will certainly do IO.   What I want to do if I can is allow people to put a monad in between me and IO.  Otherwise I'm forced to keep SessionT at the lowest part of the stack where IO usually is
12:11:10 <S11001001> haskellN00b: MonadIO m => is well-formed.  But things that are "IO a" aren't automatically "MonadIO m => m a".  You have to use liftIO on those IOs to make them into ms.
12:11:17 <haskellN00b> athan: driverSave is currently just   driverSave :: IO ()
12:12:00 <S11001001> haskellN00b: then if you have instance MonadIO for SessionT, you can use it as the m for that function.
12:12:01 <athan> haskellN00b: There's where the bound be
12:12:21 <athan> arrrgg
12:12:40 <S11001001> haskellN00b: Remember that all this distributes, so if the only place that IO appears in your signature (I can't load your example for some reason) is at the end, you just have to call liftIO on *that*.
12:12:54 <EvanR> github is borking
12:13:00 <S11001001> haskellN00b: and of course you could also just leave the function like it is and call liftIO on its result to lift it into SessionT.
12:13:13 <EvanR> :t liftIO
12:13:13 <lambdabot> MonadIO m => IO a -> m a
12:15:03 <haskellN00b> S11001001:   what I'm trying to do here is just be nice.  SessionT is a transformer but it must have IO underneath it somewhere as it does not make sense without using IO.  Of course I know monad transformers can sit on top of it, but I wanted to allow a monad to sit between SessionT and IO so long as they let me get at IO as I need
12:15:36 <S11001001> haskellN00b: then indeed you can just call liftIO on the result of your function and it will become a MonadIO m =>
12:15:46 <S11001001> haskellN00b: I assume you have implemented MonadIO for SessionT
12:16:05 <clrnd> mmm, does IO a -> m a mean I can escape IO?
12:16:12 <S11001001> clrnd: no
12:16:16 <haskellN00b> S11001001: not yet but I can
12:16:19 <clrnd> then `m` is always IO
12:16:35 <S11001001> clrnd: no
12:16:45 <S11001001> clrnd: take a look at the available instances and try to come up with some 'm's that successfully implement MonadIO
12:16:56 <clrnd> okay
12:17:02 <S11001001> clrnd: other than IO, of course, which trivially implements MonadIO
12:17:21 <S11001001> clrnd: (though you'll need to keep that one in mind :)
12:18:39 <EvanR> not sure it would be more confusing or more convenient or both if all the standard IO actions were MonadIO m => m foo
12:18:52 <S11001001> haskellN00b: I suggest the same for you, take a look at how MaybeT, ExceptT, ReaderT, StateT, et al implement MonadIO; you'll use the same strategy
12:19:31 <haskellN00b> Oh wow, just throwing the liftIO in there fixed everything.  Perfect.  This is easier than I thought it would be when I worked out my strategy in my head. :)
12:19:55 <ReinH> Things in Haskell tend to be either much easier than expected or much more difficult...
12:20:01 <ReinH> That improves somewhat with experience.
12:20:23 <EvanR> yeah you can also stuff liftIO into your particular monads utility functions so you dont have to keep typing it in the "client code"
12:20:31 <sinelaw> good point
12:21:03 <clrnd> I see it now, it just wraps IO with lift right? in the end runX always is IO (if the transformer has IO)
12:21:45 <haskellN00b> yea, every so often I do a fairly involved haskell project and get into the flow.... then I end up on some work project in an unrelated language and get rusty again
12:21:50 <EvanR> or, it unwraps the transformers so you can use the IO action in the underlying IO environment
12:22:08 <S11001001> clrnd: yeah
12:22:42 <S11001001> clrnd: though StateT is more like s -> someMonadIO ..., but the principle still applies, there's no escaping IO
12:22:57 <clrnd> unsafePerf...etc
12:23:01 <clrnd> nice
12:23:13 <EvanR> nobody can escape IO
12:23:27 <EvanR> actually what does escape a monad even mean
12:23:46 <clrnd> :t fromJust
12:23:47 <lambdabot> Maybe a -> a
12:24:02 <EvanR> @src fromJust
12:24:03 <lambdabot> fromJust Nothing  = undefined
12:24:03 <lambdabot> fromJust (Just x) = x
12:24:22 <EvanR> function application being characterized as "escaping"
12:24:30 <clrnd> well it could at elast `error "bitch you fromJust"`
12:24:56 <gfixler> is it typical to install diagrams to a sandbox? (having trouble with it)
12:26:42 <bananagram> I can't find a function like fileExists :: FilePath -> IO Bool
12:26:50 <bananagram> does anyone know where it's defined?
12:26:59 <bananagram> why
12:27:01 <haskellN00b> I wonder if it is under consideration to just get rid of fromJust.  You can always just use the maybe function and then the Nothing case is handled
12:27:05 <haskellN00b> :t maybe
12:27:06 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:27:08 <EvanR> @hoogle fileExists
12:27:09 <lambdabot> No results found
12:27:19 <EvanR> @hoogle filePath -> IO Bool
12:27:20 <lambdabot> Did you mean: FilePath -> IO Bool
12:27:20 <lambdabot> Control.Concurrent.MVar tryPutMVar :: MVar a -> a -> IO Bool
12:27:20 <lambdabot> Graphics.Rendering.OpenGL.GL.ObjectName isObjectName :: ObjectName a => a -> IO Bool
12:27:34 <bananagram> @hoogle fileExist
12:27:34 <lambdabot> System.Posix.Files fileExist :: FilePath -> IO Bool
12:27:34 <lambdabot> System.Posix.Files.ByteString fileExist :: RawFilePath -> IO Bool
12:27:34 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
12:27:46 <bananagram> oh, onay
12:27:51 <bananagram> thanks
12:28:17 <EvanR> fileExist, vs doesFileExist, intuitive
12:28:51 <Denommus> fileExistP
12:29:37 <ReinH> A language like Haskell could allow identifiers to end with '?' *and* check at compile time that they return a Bool...
12:29:57 <EvanR> > let x? = 1 in x?
12:29:58 <lambdabot>  <hint>:1:8: parse error on input ‘=’
12:30:14 <ReinH> although it gets tricky with things like IO Bool, which are not boolean values.
12:30:25 <ReinH> but are used inside do notation as if they were predicates
12:30:30 <jfischoff> ?#
12:30:31 <lambdabot> Maybe you meant: v @ ? .
12:31:13 <shachaf> Bool is hardly a type to encourage use of.
12:31:38 <ReinH> shachaf: good point
12:31:42 <malllle> > let f = (id *** id) . (id &&& id) in f 1 -- to concat the resulting tuple?
12:31:43 <lambdabot>  (1,1)
12:31:50 <toors> has anyone had experience with a library that bounds RGB color to the gamut of a particular CMYK profile? Adobe demonstrates this in their toolset but all conversion algorithms I have found are naive and WAY out of gamut
12:32:17 <malllle> concat as in (1,1) -> [1,1]
12:33:38 <luite> haskellN00b: it's probably more important to improve error reporting for pattern match failures. use of fromJust can be discouraged, but it won't be possible to remove all partial functions. a major downside of a failure with fromJust is that the exception won't be helpful in figuring in out where it went wrong
12:35:03 <Denommus> malllle: hm, [fst foo, snd foo]?
12:35:09 <EvanR> cant remove all partial functions? i refudiate
12:36:34 <tasker> I've got [[Int]], where each "inner" list is of the same length. I would like to output a graph of these, with each point being represented by a colour. Which packages should I be looking at ?
12:37:06 <malllle> Denommus: yeah, ich took \a b -> [id a, id b] instead of *** now
12:37:09 <malllle> thx
12:43:07 <Denommus`> malllle: why id a, instead of just a?
12:43:11 <Denommus`> malllle: like, \a b -> [a, b]
12:46:13 <malllle> Denommus: i replaced the actual functions for the sake of brevity
12:53:02 <marioxcc> does the haskell standard library includes a function to compute the n-grams of a list?
12:53:26 <marioxcc> I searched with hoogle, but it didn't return anything related. Maybe it exits under a differnt name.
12:53:40 <marioxcc> Example: ngram 3 [1..5] --> [[1,2,3],[2,3,4],[3,4,5]]
12:53:50 <mauke> > tails [1..5]
12:53:51 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
12:54:06 <mauke> > (map (take 3) . tails) [1..5]
12:54:08 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5],[5],[]]
12:54:25 <mauke> well, almost
12:56:56 <marioxcc> mauke: Ok, thanks.
13:01:26 <osa1_> we need a service that provides haddock coverage badges like coveralls one
13:09:07 <benzrf> the Age Old Question:
13:09:57 <benzrf> how do you handle having a collection of some kind of entity where each entity has a position and each entity should be able to know and update its own position but at the same time entities should be able to be looked up by position
13:10:13 <benzrf> puzzling, indeed
13:10:45 <Cale> So like the spatial version of a priority search queue
13:11:53 <benzrf> i dunno
13:12:03 <benzrf> hold on let me back up & counter XY
13:12:32 <benzrf> i want to write a natural selection simulation thingy that involves "creatures" that move around on a grid
13:12:53 <benzrf> this is all well and good but i want creatures to be able to react to each other in a simple way
13:12:57 <SrPx> Does anyone know why "Linear" defines normalize as: `normalize v = if nearZero l || nearZero (1-l) then v else fmap (/sqrt l) v` ? Notice that it is truncating vectors "close to 0". I spent a few minutes debugging a problem that tracked down to that behavior. Why is that necessary?
13:13:41 <benzrf> if i stick them all in a Map (Int, Int) Creature, how do i let a creature move? should i have it return a movement it wants to make and then update externally?
13:14:17 <benzrf> also that's probably less than ideal since it wouldn't allow more than one creature per square
13:14:39 <benzrf> er, using a Map
13:17:45 <Denommus> benzrf: hello
13:18:30 <benzrf> hello Denommus
13:18:48 <benzrf> still a lisp fan?
13:21:00 <Denommus> benzrf: I'm mostly doing Haskell nowadays. Static typing makes a difference, though I miss s-expressions
13:22:37 <benzrf> i just dont understand it
13:22:45 <benzrf> i never liked them :-\
13:23:00 <benzrf> i can understand why they're a good thing, i just cant stand using them
13:23:05 <mauke> ))))))))-:
13:23:16 <ab9rf> i don't remember there being anything particularly special about them, but i haven't done lisp in ages
13:23:23 <benzrf> ab9rf: it's the unified syntax
13:23:51 <ReinH> SrPx: You should ask edwardk
13:24:02 <benzrf> the AST for normal code is the same as the values represented by value literals
13:24:11 <benzrf> or rather, normal code /is/ value literals
13:24:29 <bitemyapp> do typed holes not work as arguments to functions?
13:24:41 <mauke> funny things happen when the AST becomes an ASG
13:24:44 <ReinH> > fmap _foo [1,2,3]
13:24:45 <lambdabot>  Found hole ‘_foo’ with type: a0 -> b
13:24:45 <lambdabot>  Where: ‘a0’ is an ambiguous type variable
13:24:45 <lambdabot>         ‘b’ is a rigid type variable bound by
13:24:46 <ReinH> bitemyapp: Like this?
13:24:47 <ab9rf> typed holes?
13:24:53 <ReinH> I suppose not since that obviously works.
13:25:05 <bitemyapp> hrm. think I know what's going on.
13:25:15 <bitemyapp> yeah, got it.
13:25:19 <bitemyapp> function was only partially applied
13:25:19 <ReinH> bitemyapp: :)
13:25:21 <ReinH> you're welcome ;)
13:25:25 <bitemyapp> parseEither _a _b
13:25:28 <bitemyapp> parseEither _a
13:25:29 <bitemyapp> does not
13:25:31 <ReinH> ah
13:25:32 <bitemyapp> first works, second doesn't
13:25:39 <ReinH> that's surprising?
13:25:42 <bitemyapp> not to me
13:25:43 <ab9rf> heh
13:25:48 <bitemyapp> ReinH: thanks
13:26:00 <ReinH> bitemyapp: I wouldn't expect partial application to make a difference
13:26:16 <exio4> > fmap _foo
13:26:18 <lambdabot>  Found hole ‘_foo’ with type: a -> b
13:26:18 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
13:26:18 <lambdabot>             the inferred type of it :: f a -> f b at Top level
13:28:06 <BOODA> ela tooda te te too
13:28:18 <BOODA> teiengo la fas fre noke
13:28:33 <mauke> BOODA: u wot m8
13:28:34 <BOODA> le te lampo de el se te la coo kee kela poo na es le ca too
13:28:38 --- mode: ChanServ set +o mauke
13:28:39 --- kick: BOODA was kicked by mauke (BOODA)
13:28:40 <ab9rf> cat typing alert
13:28:42 <nitrix> Hi, can you specify in the function signature / declaration / or types, that the list argument must be specifically finite or infinite?
13:28:44 <benzrf> lol
13:28:51 <nitrix> Some modifier to [a] ?
13:28:56 <mauke> nitrix: no
13:28:56 <benzrf> nitrix: no
13:29:10 <mauke> halting problem alert
13:29:23 <nitrix> so, iterate/cycle and other prelude functions might never halt?
13:29:29 <nitrix> Or halt too early?
13:29:38 <Oded> Hello
13:29:43 <chaosmasttter> > toListOf both (1,2,3,4)
13:29:45 <lambdabot>  [3,4]
13:29:50 <ab9rf> nitrix: both iterate and cycle return infinite lists, iirc
13:29:54 <bitemyapp> ReinH: partial application in this case is a type error
13:30:00 <chaosmasttter> > toListOf each (1,2,3,4)
13:30:01 <lambdabot>  [1,2,3,4]
13:30:05 <bitemyapp> ReinH: because the result is getting "used" by other code, which short-circuits use of holes.
13:30:17 <Oded> > putStrLn "Hello"
13:30:19 <lambdabot>  <IO ()>
13:30:21 <Oded> lol
13:30:25 <Oded> :)
13:30:27 <EvanR> nitrix: you can use Stream a instead of [a] to advertise that this is infinite
13:30:39 --- mode: mauke set -o mauke
13:30:43 <nitrix> EvanR: I see. That sounds more appealing.
13:30:52 <EvanR> but theres no way to say "this will terminate" because bottom
13:31:15 <ab9rf> there's no guarantee that the argument to iterate or cycle terminates
13:31:38 * hackagebot aws-kinesis-client 0.2.0.0 - A producer & consumer client library for AWS Kinesis  http://hackage.haskell.org/package/aws-kinesis-client-0.2.0.0 (JonSterling)
13:31:39 <EvanR> there no guarantee of nothing
13:31:53 <ab9rf> taxes
13:31:59 <ReinH> bitemyapp: ah, makes sense
13:32:12 <Oded> I made a simple game in haskell. It has multiplayer with sockets, and when I run it on local machine or LAN it works, but when I forward the port and people try to connect it doesn't work. Why is that?
13:32:29 <EvanR> network issues
13:32:36 <ReinH> Oded: define "doesn't work".
13:32:40 <tommd> Oded: I'm sure you know there could be lots of reasons and they are likely related to network administration.
13:32:53 <ab9rf> Oded: likely there's something abot your networkenvironment that iesn't allowing outside users to connect.  this is not a #haskell issue.
13:33:01 <tommd> Oded: Do you have a more specific question or aspect we can help you explore?
13:33:02 <Denommus> Oded: try to use Hamachi, it emulates a LAN between computers in different networks
13:33:02 <EvanR> the utility ncat is good for debugging connection based programs
13:33:06 <EvanR> er netcat
13:33:18 <Denommus> but this is not a Haskell question, indeed
13:33:23 <EvanR> Hamachi has a bunch of caveats, leading to even more failure modes ;)
13:33:31 <EvanR> related to nat traversal
13:33:35 <ReinH> It might be a Haskell issue. We won't know until we know what the actual issue is. "Doesn't work" doesn't provide any information.
13:33:39 <ab9rf> EvanR: i hate nat traversal :)
13:34:27 <EvanR> well seven hate nine
13:34:48 <Denommus> ReinH: well, it works on local machine and LAN, and it doesn't when it's over another network. I doubt that it isn't a network problem
13:35:42 <ReinH> Denommus: That's true, but beyond that it isn't useful to speculate.
13:35:52 <ReinH> If they want to provide us with an actual problem description we might be able to help.
13:35:56 <EvanR> the listening socket could be restricted to local addresses
13:36:01 <ab9rf> i would definitely focus on networking environment rather than application-level coding, in terms of troubleshooting.  but that may just be because i'm a network engineer
13:36:02 <EvanR> rather than "any"
13:36:06 <ab9rf> EvanR: no way to do that in POSIX sockset
13:36:15 <EvanR> no?
13:36:33 <ab9rf> EvanR: no, you can either bind to "any" or to packets arriving on a specific interface
13:36:42 <Denommus> maybe they simply can't resolve the IP to the server
13:37:00 <ab9rf> there's no way to say "i want packets from any interface but only if they coimef rom this addressing subrange"
13:37:05 <EvanR> ok
13:37:29 <EvanR> the address you bind to is related to the OS somehow not the internet
13:37:41 <ab9rf> most computers only have one non-loopback interface, so if he can accept connections from other LAN hosts, that means he's probably not binding the local loopback :)
13:37:58 <EvanR> most computers have ipv6 setup now
13:38:10 <ReinH> this discussion amuses me greatly
13:38:14 <ab9rf> i have seen people bind the loopback interface, usually by mistake
13:38:42 <ab9rf> EvanR: ugh, don't make me think about how IPv6 makes writing networking code that much harder.
13:39:01 <EvanR> just dont use the old crusty api ;)
13:39:14 <ab9rf> EvanR: i used to write those crusty old apis :)
13:39:51 <EvanR> faq can haskell do internet
13:40:12 <benzrf> the faq command is broken =[
13:40:22 <benzrf> apparently @where faq is too long
13:40:51 <Oded> I tried to change port and still not working
13:41:03 <EvanR> what does not working mean
13:41:05 <Oded> but when I host another programs it works
13:41:06 <benzrf> question tho: what structure do i want for looking up what things are at a position and be able to easily update a thing's position
13:41:09 <benzrf> EvanR:
13:41:10 <Oded> It doesnt connect
13:41:10 <benzrf> @faq test
13:41:11 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
13:41:27 <ab9rf> Oded: much depends on how you're building the connection
13:41:36 <Lutin`> ReinH: So how do you have Haskell setup on your Nix install?
13:41:37 <EvanR> benzrf: Store p a ?
13:41:50 <benzrf> oh snap
13:41:52 <ab9rf> Oded: tcp, udp, client-iniaited, server-initated.... but all of this is beyond the scope of this channel :)
13:41:53 <Oded> is "bindSocket sock (SockAddrInet (PortNum 1337) (inet_addr "0.0.0.0")" okay?
13:41:55 <ReinH> Lutin`: a lot like https://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html
13:41:55 <EvanR> oh, update the position
13:41:56 <benzrf> i was thinking this might seem comonadic >.<
13:41:57 <Oded> tcp
13:42:03 <benzrf> EvanR: er, yes
13:42:15 <Oded> what's comonadic?
13:42:22 <benzrf> Oded: monad, but comonad instead of monad
13:42:27 <benzrf> *monadic
13:42:30 <mauke> Oded: no
13:42:32 <benzrf> of or relating to comonads
13:42:34 <ReinH> Oded: probably not related to your problem
13:42:37 <EvanR> benzrf: can two things be at the same position
13:42:40 <ab9rf> ferp
13:42:43 <benzrf> EvanR: ideally sure
13:42:45 <mauke> Oded: any use of PortNum is probably a mistake
13:42:54 <Denommus> benzrf: a mutable vector or array?
13:43:08 <EvanR> so, a MultiMap
13:43:13 <benzrf> Denommus: agh
13:43:13 <gcganley> chrisdone: hey is there any specific format on how to commit to haskell-mode? i just found a repeat import in hasekll-bot.el that i would like to fix
13:43:18 <Oded> :P
13:43:36 <EvanR> or ixset
13:43:37 <benzrf> EvanR: is that really updateable though
13:43:38 <Oded> mauke: why?
13:43:45 <EvanR> ixset is
13:43:50 <benzrf> ooh
13:43:53 <EvanR> dunno about performance
13:43:54 * benzrf examines
13:43:58 <EvanR> its just a bunch of Maps
13:44:12 <mauke> Oded: because it's an implementation detail of the PortNumber type
13:44:22 <mauke> is that thing even exported?
13:44:24 <Oded> So how do I bind to some port?
13:44:26 <gcganley> ReinH, EvarnR, benzrf, mauke: what are we discussing, just came in
13:44:34 <mauke> Oded: just remove PortNum
13:44:41 <Lutin`> ReinH: Do you have xmonad setup using `services.xserver.windowManager.xmonad.enable = true`?
13:44:53 <benzrf> gcganley: 04:37 < benzrf> question tho: what structure do i want for looking up what things are at a position and be able to easily  update a thing's position
13:45:00 <jedws> anyone here look after or know who looks after www.haskell.org ? slow to the point of unusable…
13:45:06 <ReinH> Lutin`: I think so. I'm not on that computer right now to check though.
13:45:14 <Lutin`> Ah alright, no problem
13:45:21 <geekosaur> jedws: #haskell-infrastructure
13:45:33 <jedws> geekosaur thx!
13:45:42 <Lutin`> Just messing around with it on a VM. Probably the most painless root-on-LVM install I've ever done...
13:46:05 <shock_one> Is it possible to set line buffering for ByteString.getContents?
13:46:27 <EvanR> ixset would be a set of (position, thing), where thing is unique. and the two indexes are position -> set of (position, thing) and thing -> one (position, thing)
13:46:33 <Oded> but the function requires PortNumer doesn it?
13:46:59 <Oded> counld not match "PortNumber" with "Int"
13:46:59 <Oded> could*
13:47:05 <mauke> Oded: 1337 is a PortNumber
13:47:05 <Oded> how do I cast an Int into port number?
13:47:11 <mauke> you don't
13:47:15 <mauke> why do you have an Int?
13:47:21 <Oded> I want to, I let the user choose the port
13:47:23 <EvanR> :t 1337 :: PortNumber
13:47:24 <lambdabot>     Not in scope: type constructor or class ‘PortNumber’
13:47:34 <Oded> import Network.Socket
13:47:35 <EvanR> mauke: i remember having to wrap this at one point, maybe its not a Num
13:47:40 <geekosaur> numeric literals get fromInteger-ed. guess what you do with Int-s?
13:47:50 <mauke> EvanR: it is
13:48:06 <EvanR> hrm. i dont add and multiply port numbers...
13:48:08 <Oded> Is PortNumber instance of Read class?
13:48:10 <mauke> Oded: you can use either fromIntegral or toEnum
13:48:16 <mauke> Oded: or just use PortNumber directly
13:48:37 <geekosaur> shock_one, you never get access to a Handle, so no.
13:48:41 <mauke> huh. apparently not
13:48:46 <mauke> just Show and Real, but not Read
13:48:51 <Oded> weird lol
13:48:52 <EvanR> Real??
13:50:28 <Oded> Thank you so much mauke
13:50:32 <Oded> Now its working
13:50:36 <geekosaur> shock_one, wait, actually getContents? you can set buffering on stdin before invoking it. although I wonder what you are doing in that case
13:50:41 <Oded> why is the documentation so shitty
13:51:08 <mauke> Oded: PortNumber is in network byte order internally
13:51:15 <Oded> Okay
13:51:29 <mauke> normally it automatically converts between Int and whatever, but the internal PortNum constructor bypasses that
13:51:29 <geekosaur> do you really mean line buffering or are you conflating line-oriented terminal I/O with line-oriented processing? setting the file buffering will not help with the latter, you must split to lines
13:51:46 <Oded> Why aren't there a normal documentation?
13:51:55 <Oded> I can't infer what function not to use
13:52:05 <mauke> http://hackage.haskell.org/package/network-2.6.0.2/docs/Network.html#t:PortNumber
13:52:15 <mauke> apparently PortNum doesn't exist in current versions of network
13:52:19 <EvanR> Oded: theres the network module, its simpler to use, sounds like its enough for what you want
13:52:35 <Oded> Network?
13:52:40 <Oded> or Network.Socket?
13:52:42 <mauke> oh, no
13:52:47 <EvanR> Network
13:52:49 <mauke> I'm misreading this
13:53:07 <mauke> yep, shitty docs
13:54:07 <Oded> Who writes those docs?
13:54:21 <geekosaur> the maintainer of the network package
13:54:41 <Oded> Really annoying, cuz Haskell is cool language with cool libraries it's just that the docs are not good..
13:54:42 <geekosaur> (I have had a few gripes about said documentation myself...)
13:55:01 <EvanR> Oded: well, youre using the low level socket library. its like, you need to know C almost to use it
13:55:09 <Oded> I know C
13:55:10 <EvanR> but the doc could be better
13:55:27 <mauke> knowing C doesn't help with this
13:55:37 <mauke> you have to read and understand the source, basically
13:55:37 <Oded> Perhaps writing a better documentation system will be good?
13:55:40 <geekosaur> shock_one, do you really mean terminal-style line-oriented I/O, or do you mean line-oriented processing in the program? no changes to the handle buffering mode will help with the latter, but using lines and unlines will
13:55:45 <Oded> I'm looking for a min-project ideas
13:56:00 <mauke> http://hackage.haskell.org/package/network-2.6.0.2/docs/src/Network-Socket-Types.html#PortNumber
13:56:05 <mauke> no, there's already a comment there
13:56:13 <mauke> the author was just being a dick, apparently
13:56:36 <ab9rf> heh
13:56:36 * geekosaur would like to note that knowing POSIX sockets is not going to help with the fact that nearly everyone trips over the ntohs() behavior of PortNum
13:56:37 <EvanR> yeah in this module https://hackage.haskell.org/package/network-2.6.0.2/docs/Network.html you have to wrap the port with PortNumber
13:56:48 <ab9rf> packages that are thin wrappers of an underlying library (or, in this case, system calls) are often fairly obtuse
13:57:04 <mauke> EvanR: more to the point, Network doesn't export PortNum
13:57:08 <mauke> but Network.Socket does
13:57:12 <Oded> Its idiotic I need to read the source code in order to use the module. It misses all the idea of "Interface"
13:57:28 <mauke> pfft, wait until you try to use errno
13:57:34 <EvanR> oh wow, PortNumber is the constructor to wrap a PortNumber ...
13:57:47 <mauke> EvanR: the fun never stops!
13:58:08 <Oded> :P
13:58:11 <ab9rf> Oded: posix sockets are no easier when you're doing them in C
13:58:25 <Oded> I know
13:58:30 <Oded> that's why I used SFML in C+++
13:58:31 <Oded> C++*
13:58:41 <EvanR> sfml has sockets ? :|
13:58:43 <Oded> OOP sockets are way more fun
13:58:48 <Oded> sort of yes
13:58:53 <EvanR> bluh
13:59:33 <EvanR> exception safety ftw
13:59:37 <Oded> I prefer OOP styled stuff in C++ than shitty procedural (200 functions to do something and a lot of things to read) API...
13:59:48 <EvanR> thats not oop vs procedural
13:59:54 <ab9rf> indeed.
14:00:07 <Oded> But now we are in Haskell, things are good here. Its just that some ppl here are lazy about documenting
14:00:15 <ab9rf> the socket api is complicated mainly because there are so many things that can go wrong :)
14:00:42 <ab9rf> also because sockets are ridiculously generic
14:00:42 <mauke> and because it's badly designed
14:00:44 <EvanR> websockets has a simpler api, except for the thing with maximum message size
14:01:05 <ReinH> network is not a shining example of a well written or documented Haskell library, it must be said.
14:01:17 <Oded> Okay
14:01:17 <ReinH> It is useful enough to write a lot of higher-level libraries on top though, so there is that.
14:01:52 <ab9rf> ReinH: i'm not really that bothered by iut, because it's a fairly thin LL binding that most people won't use unless they're already knowledgeable about POSIX sockeys
14:02:00 <Oded> Why isn't haskell so popular?
14:02:09 <geekosaur> having talked with network's maintainer, they would like a better interface than the high level Network module but Network.Socket is intended to be low level
14:02:16 <EvanR> ignorance, cowardice, fear
14:02:19 <geekosaur> and close to what linc gives you
14:02:23 <geekosaur> *libc
14:02:39 <ab9rf> Oded: because haskell fans have a tendency to lapse into incomprehensible masses of mathematical jargon that you have to be a grad student in mathematics to have a chance of understanding
14:02:49 <ReinH> network apparently has 664 reverse deps: http://packdeps.haskellers.com/reverse/network
14:02:49 <geekosaur> this is not uncommon, that there is an internal layer close to the FFI and a high level interface that is more Haskelly
14:03:24 <Oded> I love Math, but I could have learned Haskell without it
14:03:39 <EvanR> haskell isnt really math
14:03:42 <Oded> Im still learning actually
14:03:45 <ReinH> I suppose that number is on the transitive closure? It would be interesting to see how deps factor through as well.
14:03:54 * geekosaur would like to note that he's no great shakes at the kind of math "behind" Haskell
14:03:55 <doomlord_1> yes both c++ and haskell communities have preistly cult attitudes
14:04:09 <Oded> Is multiplayer Checkers a good idea for a project?
14:04:25 <ab9rf> EvanR: no, but that doesn't stop people from brining up category theory and endomorphisms and other such stuff without warning or provocation, when talking about haskell :)
14:04:27 <ReinH> EvanR: Haskell is definitely math, as are other programming languages. That doesn't mean you need to understand the math in order to use them.
14:04:28 <EvanR> one had a lot more corporate support in the 90s than the other
14:05:18 <ab9rf> Oded: it's not a bad learning experience.  don't expect to make a lot of money or gain a lot of reputation by writing a multiplayer checkers application.
14:05:23 <Oded> .
14:06:02 <EvanR> write a checkers server that automatically beats the human player using the solution to checkers
14:06:23 <ReinH> To quote the author of a book called "From Mathematics to Generic Programming", "The separation of computer science from mathematics greatly impoverishes both."
14:06:34 <Oded> Okay..
14:06:50 <ReinH> That author, btw, is Alexander Stepanov, the primary designer and implementer of the C++ standard template library.
14:06:52 <ab9rf> checkers is a fully solved game, so it's not that exciting
14:09:12 <Oded> I disconnect somehow
14:11:05 <Oded> So... How can I improve my Haskell abillities?
14:11:15 <benzrf> Oded: be patient
14:11:28 <benzrf> 05:03 < ReinH> To quote the author of a book called "From Mathematics to Generic Programming", "The separation of  computer science from mathematics greatly impoverishes both."
14:11:29 <EvanR> train in the hyperbolic type chamber for one hour
14:11:39 <benzrf> isnt such a separation an oxymoron
14:11:56 <benzrf> i thought cs was defined as "math that is affiliated with programming and/or computation"
14:12:32 <mauke> Oded: write all of the programs
14:13:01 <HeladoDeBrownie>    /away
14:13:05 <HeladoDeBrownie> woops
14:13:19 <ReinH> benzrf: There seems to be a growing anti-math movement in CS :/
14:13:33 <benzrf> lel
14:13:54 <benzrf> those dang ivory tower academics
14:14:11 <benzrf> ReinH: did you ever see that one HN thread w/ the guy who insisted that proving theorems is a waste of time
14:15:02 <Odd100> My internet do has suicidal tendencies..
14:15:32 <Odd100> Any ideas on how can I practice Haskell?
14:15:38 <EvanR> Acme.Dont.don't disconnect
14:16:18 <k00mi> benzrf: that depends on what part of computer science you look at
14:16:22 <Axman6> Odd100: what've you done so far?
14:16:24 <k00mi> is operating systems research math?
14:18:03 <Odd100> I'v done a 2 players game and.. that's it
14:18:09 <Odd100> Im really bad at ideas
14:18:25 <orcobudino> Hellooooooooooo!!!
14:18:26 <Odd100> The game has no graphics... just text based
14:18:40 <orcobudino> !list
14:18:40 <monochrom> orcobudino: http://okmij.org/ftp
14:18:51 <Odd100> I though of multiplayer Checkers to code maybe..
14:19:30 <EvanR> Odd100: now that the game works, maybe try changing the IO code so its less IO-like
14:20:20 <Odd100> I wanna do something more challanging , the game is boring..
14:20:34 <EvanR> mmo rpg then
14:20:52 <Odd100> lol
14:20:58 <EvanR> everybody loves a good mmo
14:21:07 <Odd100> You mean text based.. right?
14:21:17 <EvanR> ill accept that
14:21:33 <josephle> mmo rts -- now you're thinking about networks!
14:21:54 <Odd100> I need to think on a plot for the game
14:22:30 <Odd100> Isn't MMO really big for being the second thing I code in Haskell?
14:23:09 <EvanR> if you finish, i guarantee you you will know a lot more haskell
14:23:13 <josephle> ok ok, a smaller step -- multi-user dungeons!
14:23:45 <ReinH> Well, it's a smaller step, but still a pretty large one...
14:23:55 <ReinH> Maaaaybe start with a single user dungeon...
14:24:00 <Odd100> Mmm.. sounds nice
14:24:05 <EvanR> ok. shoot the wumpus
14:24:13 <EvanR> ok hangman
14:24:27 <EvanR> hello world
14:24:34 <ab9rf> oddly, the project that did most for my "haskell abilities" was writing a minecraft save file parser library :)
14:25:30 <Odd100> Well, I did not touch any File IO yet, so perhaps I'll go for the hangman first and then I'll learn about parsing..
14:25:40 <Odd100> Is parsing hard to learn?
14:26:05 <EvanR> in not haskell, yes
14:26:34 <ab9rf> Odd100: i found it fairly trivial, but i've written dozens of parsers in various languages over the years
14:26:42 <Odd100> I haven't
14:26:54 <Odd100> :P
14:27:30 <Zemyla> Is asTypeOf inlined out automatically?
14:27:41 <ab9rf> it's probably best to learn the art of crafting a parser in a language you already know.  trying to learn both at the same time may not be maximally efficient.
14:28:00 <Odd100> I'll start in stupid hangman and then I'll go for the MMORPG and if I'd like to learn parsing i'll add scripting language to my game or something
14:28:18 <EvanR> thats the spirit
14:28:42 <Odd100> Okay I got to go now, thanks :)
14:28:43 <Odd100> cya
14:28:44 <ab9rf> Odd100: the thing is, you'll end up using parsing for an MMO, since the network stack will probably use some sort of parser :)
14:28:45 <kadoban> You probably don't have to learn parsing to add a scripting language. There's nice languages to embed already, lua, python, others.
14:29:06 <Odd100> But I want to learn parsing though the MMO
14:29:18 <EvanR> "nice"
14:29:26 <Odd100> LOL
14:29:27 <ab9rf> Odd100: so use attoparsec to write the parser for the client-server packetizing protocol
14:29:31 <kadoban> Well, "nice enough"
14:29:36 <EvanR> embed haskell ;)
14:29:44 <ab9rf> "parsing" covers a lot more than programming languages
14:29:59 <Odd100> bye bye all
14:34:59 <marioxcc> Hi. Is there a function in the standard library of Haskell that takes a list and an integer N, and returns the list without the first N elements?
14:35:11 <shachaf> drop
14:35:21 <shachaf> @where hoogle is useful for answering these sorts of questions.
14:35:21 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
14:35:23 <Zekka> > drop 4 [1, 2, 3, 4, 5]
14:35:25 <lambdabot>  [5]
14:35:37 <marioxcc> Thanks
14:35:41 <shachaf> If you search for Int -> [a] -> [a] on Hoogle, drop is the first result.
14:35:46 <ab9rf> > drop 10 $ iterate (*2) 1
14:35:47 <lambdabot>  [1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,...
14:36:26 <tommd> > drop 18 "That is the wrong answer"
14:36:27 <lambdabot>  "answer"
14:36:29 <ab9rf> hoogle does solve a lot of my problems
14:36:33 <marioxcc> I heard that the haskell type system is Turing complete, what would that mean and is that correct?
14:36:41 * hackagebot GLUtil 0.8.3 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.8.3 (AnthonyCowley)
14:36:52 <marioxcc> I suppose it means that it can define a type composed of any set of objects which is computable, right?
14:37:03 <EvanR> @hoogle drop : (n : N) -> Vect m a -> Vect (m - n) a
14:37:03 <lambdabot> Parse error:
14:37:03 <lambdabot>   drop : (n : N) -> Vect m a -> Vect (m - n) a
14:37:03 <lambdabot>         ^
14:39:10 <EvanR> marioxcc: it means that you could write a type that causes ghc to hang or crash when type checking
14:39:15 <ab9rf> heh
14:39:17 <EvanR> which is not the default state of affairs at all
14:39:24 <nitrix> EvanR: Can I bother you with character encoding?
14:39:54 <EvanR> utf8
14:39:55 <ab9rf> indeed, i thought that in vanilla haskell, type checking was guaranteed to terminate, and thus not turing-equivalent
14:40:21 <marioxcc> EvanR: I know what Turing-completeness is.
14:41:11 <ab9rf> some extensions (undecidable instances, for example) break that, and i imagine some combination of them could introduce turing-completeness
14:41:15 <nitrix> What would be the default character encoding used for string? They are sequence of Char, and so, I assume a Char can be rather large?
14:41:29 <EvanR> sizeOf Char
14:41:31 <EvanR> 1
14:41:36 <marioxcc> ab9rf: Ok.
14:41:37 <nitrix> As with C ?
14:41:37 <Axman6> no...
14:41:40 <marioxcc> Thanks.
14:41:41 <EvanR> thats not right
14:41:46 <Axman6> > maxBound :: Char
14:41:47 <lambdabot>  '\1114111'
14:41:49 <EvanR> Char fits in an Int
14:42:11 <ab9rf> Char is a unicode character, iirc
14:42:18 <EvanR> nitrix: String = [Char] is unencoded, its a list of Chars
14:42:18 <ab9rf> not a UTF-8 octet
14:42:19 <nitrix> Good.
14:42:50 <EvanR> also Char may be one of the UTF-16 surrogates, which cant or shouldnt be encoded in any way
14:42:51 <nitrix> EvanR: Then, string literals uses what encoding?
14:42:52 <Axman6> http://blog.kfish.org/2007/10/survey-haskell-unicode-support.html may be helpful
14:43:05 <ab9rf> EvanR: i hate utf-16 surrogates
14:43:05 <mauke> nitrix: I'm pretty sure source code is UTF-8
14:43:07 <Axman6> though it's quite old
14:43:24 <ab9rf> nitrix: that's implementation dependent, iirc
14:43:35 <ab9rf> although ghc expects UTF-8
14:43:37 <EvanR> the encoding of your source file is your own business
14:44:03 <ab9rf> and the read implementation of String also expects UTF-8
14:44:13 <EvanR> :t read
14:44:14 <lambdabot> Read a => String -> a
14:44:29 <mauke> ab9rf: huh?
14:44:40 <EvanR> no encoding involved for String -> String
14:45:12 <ab9rf> yes there is
14:45:17 <ab9rf> sort of :)
14:45:18 <Axman6> no...
14:45:21 <ab9rf> > read "\"MY cat\"" :: String
14:45:23 <lambdabot>  "MY cat"
14:45:41 <ab9rf> it removes quotes, and it will convert escapes
14:45:48 <Axman6> by the time anything gets to read it's already been converted to a String; a list of characters
14:46:06 <Axman6> read isn't do that
14:46:07 <EvanR> yeah no unicode encoding
14:46:22 <Axman6> it's being done by GHC when parsing the string literal
14:46:39 <EvanR> the IsString literal ;)
14:46:42 <nitrix> Okay, so that's one point covered, Haskell doesn't have any encoding to its string literals; it's the implementation that is either capable or not to accept UTF-8 source and create/printed string as just sequence of characters (even though it may take multiple characters to be a single unicode codepoint).
14:46:46 <ab9rf> i don't know what text-mode IO does, but i assume it assumes UTF-8
14:46:49 <nitrix> Now, second question.
14:47:02 <ab9rf> there are libraries that do ByteString to String translation (and back again)
14:47:05 <EvanR> nitrix: printing involves encoding for the sake of the output system
14:47:19 <ab9rf> i *hate* text encoding
14:47:37 <nitrix> ab9rf: I know all that. You're way too ahead of yourself.
14:47:52 <EvanR> people have different locales like iso-whatever
14:47:53 <nitrix> Text encoding is very simple if you understand which route the communauty has chosen.
14:47:54 <mitchty> so.... why does ghc-mod, hindent, hlint, hoogle, and stylish-haskell all have cpphs binaries?
14:47:58 <ab9rf> the only time it takes multiple characters to be a single unicode codepoint is when you use a UTF-16 surrogate, which you shouldn't do
14:48:13 <nitrix> ab9rf: That'd be incorrect.
14:48:20 <johnw> huh?
14:48:36 <kadoban> ab9rf: ? That doesn't sound at all correct.
14:48:57 <EvanR> "nobody understands unicode" --feynman
14:49:03 <ab9rf> i welcome a counterexample
14:49:11 <nitrix> ab9rf: What you're describing is UTF-8, which _aims_ at using the smallest amount of characters possible for the english (ASCII) codepoints.
14:49:17 <johnw> ab9rf: what did you mean by character in what you said; bytes?
14:49:19 <Axman6> "The character type Char is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) characters (see http://www.unicode.org/ for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type Char."
14:49:22 <ab9rf> you are conflating 'character' and 'byte'
14:49:27 <ab9rf> or 'octet'
14:49:31 <Axman6> https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Char.html
14:49:44 <ab9rf> it may take multiple octets to reprepsent a codepoint
14:49:57 <ab9rf> but it takes exactly one character to represent a codepoint
14:50:07 <ab9rf> (except for UCS-2/UTF-16 surrogates)
14:50:12 <EvanR> in data.text, if you try to utf8 encode some string with utf-16 surrogates, you get ...
14:50:49 <tremon> ab9rf: why the exception? even a unicode character that requires a utf-16 surrogate still fits in 30 bits
14:50:52 <nitrix> Okay you guys are totally unhelpful. You don't even know what you're talking about.
14:50:58 <nitrix> I'll lookup the docs on my own, it's fine.
14:51:00 <nitrix> ffs.
14:51:10 <EvanR> uhg, Data.Text and utf-16... it cant even represent these points
14:51:17 <kadoban> nitrix: Didn't you already get your answer?
14:51:22 <ab9rf> tremon: UTF-16 surrogates are a way to represent codepoints that don't fit in a 16-bit encoding as two encoded characters
14:51:29 <mauke> nitrix: did you ask your second question?
14:51:40 <nitrix> mauke: I didn't.
14:51:42 <ab9rf> tremon: they are an abominatin and should not be used, but they're all over the place things to java
14:51:47 <tremon> ab9rf: yes, but are you implying that a haskell Char is a utf-16 codepoint?
14:51:58 <mauke> then I don't see how I could possibly help with that
14:51:59 <ab9rf> tremon: no, a haskel character is a unicode codepoint
14:52:12 <EvanR> > "\uD800"
14:52:13 <lambdabot>  <hint>:1:3:
14:52:13 <lambdabot>      lexical error in string/character literal at character 'u'
14:52:18 <ab9rf> tremon: unfortunately, the UTF-16 surrogates "look like" unicode codepoints, and in practice you hacve to expect to run into them
14:52:21 <tremon> ah ok. I was reading you as saying that a surrogate codepoint required 2 haskell chars
14:52:30 <ab9rf> tremon: sadly, they do
14:52:44 <EvanR> > "\U+D800"
14:52:45 <lambdabot>  <hint>:1:3:
14:52:45 <lambdabot>      lexical error in string/character literal at character 'U'
14:52:55 <mauke> tremon: the opposite, really. some haskell chars require 2 surrogate codepoints (when encoding as UTF-16)
14:53:03 <EvanR> > "\xD800"
14:53:04 <lambdabot>  "\55296"
14:53:09 <EvanR> ^
14:53:43 <ab9rf> "\xD800" isn't a valid unicode codepoint (it's half of a character)
14:53:58 <EvanR> its a valid codepoint, just dont use it
14:54:03 <ab9rf> you need the other half to actually get a character
14:54:08 <tremon> mauke: yes, that seemed quite logical to me. I would expect one haskell char to require one or more utf-16 chars. I was not expecting the other way around
14:54:27 <ab9rf> tremon: hysterical raisins
14:54:28 <EvanR> if you have the other half in your text, youre shit out of luck because you are thinking of your text as not being encoded
14:54:30 <mauke> where is rafbcity when I need it
14:55:08 <EvanR> tremon: i think we are talking about the code points from D800 to DFFF not outside-the-bmp characters
14:55:17 <ab9rf> the problem is that there's a lot of text out there that has UTF-16 codepoints in it (sometimes reencoded into UTF-8) and you have to be prepared to deal with them
14:55:18 <EvanR> which are valid haskell chars
14:55:30 <mauke> let's do something more productive, like argue what color yellow is
14:55:36 <ab9rf> er, the UTF-16 codepoints for the surrogates
14:55:42 <koala_man> what's a UTF-16 codepoint?
14:55:43 <ab9rf> these shouldn't happen, but they do
14:56:03 <nitrix> ab9rf keeps saying codepoint instead of character.
14:56:06 <nitrix> He's confused.
14:56:22 <ab9rf> no, i'm not, but you are :)
14:56:27 <mauke> I'm surprised no one's said "scalar value" yet
14:56:28 <nitrix> There's only Unicode codepoints. And then you have UTF-8, UTF-16 and other encodings.
14:56:32 <ab9rf> (and not about characters versus codepoints)
14:56:47 <EvanR> :|
14:56:49 <ab9rf> nitrix: the surrogate codepoints are codepoints that are not characters
14:57:03 <nitrix> And then, these encodings, would use one or more characters, depending on their widths and whatnot.
14:57:07 <mauke> does unicode define "character"?
14:57:16 <nitrix> mauke: It does define Char.
14:57:23 <mauke> nitrix: that would surprise me
14:57:23 <ab9rf> mauke: glyph is the term usually used, iirc
14:57:32 <nitrix> mauke: Well, be surprised, lmao.
14:57:42 <mauke> nitrix: chapter and verse?
14:57:57 <ab9rf> mauke: but glyph is a distinct concept
14:58:02 <EvanR> ill get it
14:58:04 <ab9rf> and there are lots of codepoints that are nonprinting
14:58:15 <nitrix> mauke: "The character type Char is an enumeration whose values represent Unicode characters."
14:58:25 <ab9rf> and many many many glyphjs can be produced by multiple combinations of codepoints
14:58:41 <mauke> nitrix: where in the unicode standard is that sentence?
14:59:11 <Maxdamantus> is á a char?
14:59:14 <nitrix> mauke: I read Haskell, not unicode.
14:59:15 <ab9rf> it's been maybe five or six years since i read the unicode standard documents :)
14:59:18 <Guest41781> if you havent had a compiler class. how har dis writing a haskell-> DSL for embedded systems? i am fairly goo at programming embedded systems but not expert. i am pretty decent at haskell but not for the theory. and would it be possible to have haskell without gc? or that just wouldnt be haskell because GC is to tied to to many features?
14:59:21 <nitrix> Maxdamantus: My mistake there.
14:59:49 <nitrix> mauke: ^
15:00:05 <ab9rf> Guest41781: haskell without garbage collection is not likely to work out well
15:00:18 <EvanR> "Characters are
15:00:19 <EvanR> the abstract representations of the smallest components of written language that have
15:00:19 <EvanR> semantic value. They represent primarily, but not exclusively, the letters, punctuation, and
15:00:19 <EvanR> other signs that constitute natural language text and technical notation."
15:00:24 <EvanR> uhg
15:00:29 <ab9rf> EvanR: heheh
15:00:46 <ab9rf> by that definition, only a tiny fraction of codepoints count as "characters"
15:00:47 <monochrom> the Haskell Report could also be wrong about Unicode, you know
15:00:56 <nitrix> Well, I'm out.
15:00:57 <Guest41781> ab9rf: a lot of GC and embeddd does not rhyme well
15:01:02 <nitrix> If you guys want to kreep bickering, have fun.
15:01:03 <platz> Guest41781: there is haskell that generates c code i.e. 'Ivory'
15:01:10 <EvanR> http://www.unicode.org/versions/Unicode7.0.0/ch02.pdf page 15
15:01:25 <mitchty> example: the snowman.. whatever glyph or char i guess http://www.fileformat.info/info/unicode/char/2603/index.htm
15:01:30 <mzabani> hi everyone! Could someone help me to try and get around a type synonym cycle? I'm new to Haskell and am having a hard time at trying to use Tuples to represent Binary Trees
15:01:31 <platz> Guest41781: but it's not for the feint of heart
15:01:36 <mauke> nitrix: well, you keep not asking your question
15:01:44 <nitrix> mauke: I said I wont.
15:02:16 <mauke> nitrix: circular reasoning?
15:02:20 <ab9rf> nitrix: in haskell, Char is a unicode codepoint.  there are pedantic issues related to how the UCS-16 surrogates are handled, which you can probably ignore,.
15:02:50 <mauke> ok, that's annoying
15:02:50 <nitrix> mauke: It's very linear. I temptatiely asked a first question. I'm unhappy with the answer, and so, I wont go for the second question.
15:03:05 <nitrix> ab9rf: It's not a unicode codepoint.
15:03:11 <benmachine> mzabani: if you want a recursive type, you probably want 'data' to make a new type, rather than using 'type' to make a synonym
15:03:18 <EvanR> ab9rf: youre right. unicode is actually inconsistent relative to their informal definitions, but .. like any model or language or interface we dream of some pure form residing invisible behind it ;)
15:03:45 <ab9rf> EvanR: awesome :)
15:04:02 <ab9rf> nitrix: if you know what a Char is, why are youa asking?
15:04:34 <EvanR> nitrix: you asked what String was with respect to encodings, i dont think i said anything wrong. the last thing you asked was about printing out, which involves encoding according to ghc's IO settings
15:04:35 <nitrix> Because I had a second question that I wont get too, because we cannot agree on the basics.
15:04:46 <nitrix> s/too/to/
15:05:04 <benmachine> mzabani: but if you provide more details I can help you more
15:05:08 <mzabani> benmachine yes I understand that :). I'm actually trying to represent a binary tree with tuples of the form (a, Maybe m, Maybe m), where a is a parent node followed by its left subtree and its right subtree. That would mean "m" is also of type (a, Maybe m, Maybe m)
15:05:30 <benmachine> mzabani: aha, right
15:05:37 <mzabani> I was thinking of a compiler verifiable alternative to parsing a textual representation :P
15:06:02 <Denommus> why is length in Data.Text O(n)?
15:06:11 <nitrix> ab9rf: Simple exercise, what is the smallest range possible for Char? How many values can exists within that range?
15:06:31 <Guest41781> I would like some simple audio project to start with, simpler than a cmoy. any suggestions?
15:06:31 <ab9rf> nitrix: that's been asked and answered, i'm fairly certain
15:06:38 <Guest41781> wrong channel
15:06:43 <nitrix> ab9rf: The exercise if for you to complete.
15:06:46 <nitrix> s/if/is
15:06:53 <benmachine> Denommus: because not all unicode thingies are two bytes long, so it depends what's inside the Text
15:07:08 <ab9rf> nitrix: you're neither my boss nor my professor, and so you cannot assign me exercises.
15:07:20 <benmachine> mzabani: so, you can't have a type variable equal to a type which involves the type variable, like a = [a], in Haskell that's not allowed
15:07:36 <mauke> ab9rf: yeah, but it determines whether to continue talking to you (and in what terms)
15:07:37 <tremon> ab9rf: apologies for using you as my unicode oracle, but are the surrogates even considered to be actual codepoints? I thought they existed as a "gap" in the code point map, but I can't find a definitive answer
15:07:38 <benmachine> (in OCaml with a special compiler switch, it's allowed, and madness swiftly follows)
15:07:39 <nitrix> ab9rf: When you don't know what you're talking about, don't pretend you do.
15:07:53 <ab9rf> > (maxBound,minBound) :: (Char,Char) -- nitrix
15:07:55 <benmachine> (as far as I know no-one uses that compiler switch)
15:07:55 <lambdabot>  ('\1114111','\NUL')
15:07:57 <mauke> tremon: AFAIK they're codepoints, but I'm still reading
15:08:10 <ab9rf> tremon: they're codepoints.
15:08:23 <shachaf> UTF-16 surrogates are "code units" but not "code points", as far as I know.
15:08:23 <ab9rf> tremon: unfortunately
15:08:35 <ab9rf> shachaf: ah, that might well be.
15:08:37 <shachaf> If you mean in the Unicode sense of the words.
15:08:51 <ab9rf> many many many Unicode implementations treat them as code points
15:08:52 <shachaf> They're valid values of type Char, which is why Char isn't quite a code point.
15:09:06 <shachaf> (But it's certainly not a UTF-16 code unit.)
15:09:22 <EvanR> Denommus: if you look at the implementation, youll see there some stream fusion machinery going on
15:09:43 <EvanR> maybe joining lots of Text occurs incrementally via some tricks
15:09:53 <mzabani> benmachine hmm so I'll have to call my functions to build my trees in my tests? Or is there anyway I can use common types to represent binary trees? I say this because using my tree building functions will be too verbose
15:10:11 <ab9rf> mauke: i'm not terribly concerned whether nitrix chooses to continue talking to me :)
15:10:16 <benmachine> mzabani: can you give me an example of this verbosity?
15:10:49 <benmachine> mzabani: my suggested datatype would be something like data Tree a = Branch a (Maybe (Tree a)) (Maybe (Tree a)) -- if you want to mirror what you said as closely as possible
15:10:50 <mauke> ab9rf: it's not just nitrix
15:11:00 <benmachine> notice that this tree cannot be empty
15:11:22 <EvanR> on page 30 it says "Surrogates and Noncharacters are assigned code points but are not assigned to abstract characters."
15:11:26 <EvanR> btw
15:11:47 <shachaf> It is possible that I'm wrong.
15:11:53 <tremon> to answer my own question, ch02 of the unicode standard lists surrogate characters as "designated code points" but "cannot be assigned to abstract character". So yes, it's a codepoint, and no, it's invalid to use it
15:11:57 <ab9rf> EvanR: page 30 of what?
15:11:57 <EvanR> Noncharacters include ffff and fffe
15:12:03 <EvanR> ab9rf: http://www.unicode.org/versions/Unicode7.0.0/ch02.pdf
15:12:08 <ab9rf> EvanR: thanks
15:12:09 <mzabani> yep! it would be something like addLeftChild "Apple" (singleton "Fruits) "Fruits" would mean (add a left child "apple" to the tree with the single node "Fruits", under the parent "Fruits"
15:12:17 <mzabani> to get a 2-node binary tree
15:12:24 <ab9rf> EvanR: fffe is the BOM, isn't it?
15:12:28 <EvanR> yes
15:12:37 <EvanR> and feff, also non character
15:12:49 <ab9rf> feff is the BOM when your byte order is wrong :)
15:12:50 <mzabani> not being able to represent an empty tree wouldn't really be a big deal here, but good point
15:12:58 <benmachine> mzabani: ah. why not just write, Branch "Fruits" (Just "Apple") Nothing?
15:13:22 <EvanR> ab9rf: im wrong. feff is a character. fffe is a non character
15:13:25 <mzabani> I would have to expose my type for that, wouldn't I?
15:13:34 <ab9rf> EvanR: what character is feff?
15:13:42 <EvanR> zero width no break space
15:14:01 <benmachine> well, if you don't want to do that, you can still expose a function branch so that branch "Fruits" (Just "Apple") Nothing amounts to the same thing
15:14:04 <ab9rf> EvanR: conventionally the BOM, because starting a document with a ZWNBRS is pointless
15:14:14 <mzabani> well you're right
15:14:18 <bam365> mzabani: is there any reason not to use the typical Haskell representation of a binary tree, eg data BTree a  = BEmpty | BNode a (BTree a) (BTree a) ?
15:14:28 <EvanR> its used for utf16
15:14:50 <ab9rf> EvanR: a UCS-2 encoded file will start with FEFF to allow a reader to divine the byte order of the file
15:14:55 <mzabani> bam365 that's precisely how I implemented it. I'm doing this for the purpose of learning haskell, this is not production code
15:15:06 <ab9rf> EvanR: if you read FFFE, you know that you need to swap bytes
15:15:06 <benmachine> bam365: I think it's often more useful to tell people how to get things they already want than to tell them to want different things :P
15:15:14 <mzabani> but I guess that one way or another I'll end up exposing something just like my data constructors
15:15:23 <EvanR> yes thats one of the most boring aspects of unicode
15:15:27 <EvanR> ever
15:15:36 <mzabani> or a slightly more succint version of them
15:15:42 <ab9rf> EvanR: i spent quite a while as a java programmer and had to learn all about this crap
15:15:42 <bam365> mzabani: so you're just experimenting with ways to try to make explicit tree construction less verbose?
15:15:47 <benmachine> mzabani: well, there are good reasons to hide your data constructors, but there are also bad ones
15:15:53 <ab9rf> since java's char type is explicitly UCS-2
15:15:56 <mzabani> bam365 exactly!
15:16:02 <mzabani> without parsing, though
15:16:18 <benmachine> mzabani: oh! I see what your strong comment was about now, sorry, totally didn't get it at the time :)
15:16:42 * hackagebot lambdacms-core 0.0.7.1 - Core package of a Content Management System (CMS) for Yesod.  http://hackage.haskell.org/package/lambdacms-core-0.0.7.1 (cies)
15:16:51 <mzabani> benmachine no problem! what good reasons would there be to hide data constructors?
15:16:56 <benmachine> I definitely recommend functions that add a root to some branches rather than ones that add branches to a root
15:17:18 <benmachine> mzabani: well, if you had some sort of internal invariant that you wanted to maintain, so you didn't want all possible trees to be constructible
15:17:22 <mauke> CESU-8, anyone?
15:17:25 <benmachine> e.g. balanced trees, ordered trees
15:17:33 <benmachine> that's one good reason
15:17:59 <mzabani> benmachine hmm right. I guess it is not feasible for the type system alone to guarantee such constraints
15:18:11 <benmachine> mzabani: not Haskell's, anyway :>
15:18:15 <ab9rf> mzabani: mainly what benmachine said.  in some cases you hide all constructors, when the type is used internally
15:18:48 <ab9rf> you might return values of that type but you do not want instances of that type constructed external to the library or module
15:18:50 <benmachine> mzabani: another case would be where you want to use some weird/complex internal representation, and the constructors aren't much conceptual use anyway
15:19:25 <benmachine> mzabani: you might think that you'd always want to hide the implementation so that you can change it without affecting your clients, but in practice that's not actually so useful
15:19:36 <benmachine> like, a binary tree is basically a binary tree, there are only so many ways to implement that :P
15:19:50 <ab9rf> this comes up with FFI interfaces all the time
15:19:55 <benmachine> you're basically saying "well, if I give my users less useful things, then there aren't so many things to break"
15:20:21 <EvanR> view patterns can let you pattern match meaningfully on something that is hiding its constructors for a good reason
15:20:23 <ab9rf> the low-level constructor will rpobably involve memory addresses or other resources that you want to control the acquisition of
15:20:24 <benmachine> pattern matching is convenient and powerful, and you can only do it if you expose the constructors
15:20:48 <EvanR> benmachine: unless view patterns, or something
15:21:00 <benmachine> EvanR: this is true, they're a teensy bit unwieldy though and make costs of pattern matching slightly less obvious
15:21:04 <mzabani> hmm now that you mention it, pattern matching really is a big part of writing haskell, and hiding my type will make my code harder to play with
15:21:23 <mzabani> and I never heard of view patterns
15:21:27 <mzabani> will have to take a look at it later
15:21:49 <EvanR> a simple tree type seems like should export the constructors
15:21:51 <mzabani> this is my first time here, so sorry to change the subject just a little bit, but I have a question I can't find an answer for
15:22:24 <mzabani> what is the complexity of building some of the collection types in Haskell lazily?
15:22:47 <EvanR> if you never use them structure, free!
15:22:51 <benmachine> hah
15:23:13 <benmachine> mzabani: which collection types did you have in mind? putting an element on the front of a list is O(1)
15:23:21 <mzabani> for instance, what is the complexity of adding elements to a Data.Set in Haskell. Is the structure really rebuilt for every single add operation or is there some compiler magic?
15:23:26 <benmachine> ah
15:23:47 <benmachine> in one sense, yes, new structure, but often it's possible to reuse old subtrees
15:24:16 <mzabani> benmachine oh lists are sweet and easier to grasp! I work quite a bit with IEnumerable<T> in C#, which is quite similar
15:24:21 <benmachine> you can think of it as: at each stage in the binary tree, I choose one of my branches to add the new thing to, and the other branch is untouched, so I don't have to do anything with it
15:24:49 <benmachine> so I only have to rebuild one of the branches, and doing that recursively I encounter the same thing, one of *its* branches will be untouched
15:25:01 <benmachine> by the time you get to the bottom of the tree you've only actually had to touch O(log n) nodes
15:25:09 <serika> hi! is there a nicer function that does  catMaybes .: map  for Maybe (and maybe is more general?)
15:25:16 <EvanR> clojure people call that strategy "persistence" and its used for all their standard structures
15:25:16 <serika> > catMaybes $ map (\x -> if even x then Just (div x 2) else Nothing) [10..20]
15:25:17 <lambdabot>  [5,6,7,8,9,10]
15:25:27 <benmachine> serika: without thinking about it too hard, I think you want mapMaybe from Data.Maybe
15:25:39 <serika> :t mapMaybe
15:25:40 <lambdabot> (a -> Maybe b) -> [a] -> [b]
15:25:46 <serika> yesss, thanks~
15:26:39 <mzabani> hmm and is there a reason why you were saying it is better to build a tree by adding roots to subtrees instead of subtrees to roots?
15:27:09 <benmachine> well, the root is always the outermost thing, right? so it's the thing you put on last
15:27:49 <benmachine> I guess it's the same as building a Haskell list by repeatedly consing elements on the front or repeatedly appending elements on the back
15:27:58 <mzabani> but is that purely personal preference or is there some advantage to this approach?
15:28:09 <EvanR> only "prepending" is faster
15:28:22 <benmachine> the former is easy, because that's just how the data structure works, whereas each time you want to append an element on the back you have to walk down the list to the end to find where to put it
15:28:23 <EvanR> O(1) rather than O(log n)
15:28:30 <Guest41781> SO if you want to combine Haskell and MCUs, then DSL is the way to go? Everyone seems to say so. Then Ivory is where I should go.
15:28:36 <benmachine> EvanR: huh? appending to a Haskell list is O(n)
15:28:44 <serika> (i feel like there should exist something like `Foldable t => (a -> t b) -> [a] -> [b]`, generalizing concatMap and mapMaybe)
15:28:51 <EvanR> benmachine: off the cuff tree complexity
15:29:13 <benmachine> EvanR: oh, I totally misunderstood what number you were quoting
15:30:01 <Guest41781> the examples look horrible actually.
15:30:52 <benmachine> :t \f -> foldMap (toList . (f :: a -> Maybe b))
15:30:53 <lambdabot>     Not in scope: ‘toList’
15:30:53 <lambdabot>     Perhaps you meant one of these:
15:30:53 <lambdabot>       ‘F.toList’ (imported from Data.Foldable),
15:30:59 <benmachine> :t \f -> foldMap (F.toList . (f :: a -> Maybe b))
15:31:00 <lambdabot>     Couldn't match expected type ‘a2 -> Maybe b’ with actual type ‘t’
15:31:00 <lambdabot>       because type variables ‘a2’, ‘b’ would escape their scope
15:31:00 <lambdabot>     These (rigid, skolem) type variables are bound by
15:31:22 <benmachine> sigh
15:31:26 * benmachine fiddles with ghci a bit
15:31:47 <mzabani> benmachine is there anywhere I can read about how lazy evaluation and purity affects complexity for these simple tasks? I feel like I have no clue how much things cost in Haskell
15:32:22 <benmachine> mzabani: I expect there is but I don't have any good recommendations, I've been out of the community for a while :)
15:33:01 <benmachine> mzabani: generally, applying a constructor is cheap, having to recurse through several constructors costs a bit more
15:33:30 <benmachine> mzabani: if you went ahead and wrote something like Data.Set with your binary trees, you might get a bit more of a feel for what's easy or hard, or people here can help you out
15:34:14 <EvanR> mzabani: the big question is usually how much memory are you using
15:34:28 <EvanR> no one knows ;)
15:34:33 <benmachine> eh, there are lots of big questions
15:34:36 <serika> is there a GHC extension that allows for things like  xs `zipWith (*)` ys  ? that'd be neat.
15:34:37 <benmachine> GHC's profiler can answer some of them
15:34:58 <benmachine> serika: no, I don't think so (it sounds hard to parse in general)
15:35:08 <benmachine> serika: however! there's a trick you can do, let me see if I can find it
15:35:18 <serika> i don't think ` is used anywhere else but that syntax
15:35:18 <ReinH> mzabani: Richard Bird's new book discusses this in some depth
15:35:20 <mzabani> lol, in C# I always think that whenever I get an IEnumerable<T>, I have no clue what the costs are of enumerating it. I usually don't worry too much about memory.
15:35:57 <mzabani> ReinH: is it suitable for starters like me?
15:35:58 <benmachine> serika: well, sure, but say you have a`b`c`d`e
15:35:59 <EvanR> mzabani: then you will find haskell very pleasant. unless you stack overflow, which usually means a problem in your algorithm
15:36:04 <serika> so it should be fine to parse as long as you don't allow `them `to` nest`
15:36:28 <ReinH> mzabani: it's an introductory book
15:36:34 <ab9rf> mzabani: one of the problems with interface types like IEnumerable is that there is no guarantee as to the cost of using any of the methods on the type.
15:36:37 <serika> that would be (a `b` c `d` e)
15:36:43 <benmachine> serika: https://www.haskell.org/haskellwiki/Infix_expressions I don't recommend actually using this, but you might find it cute
15:36:43 * hackagebot lambdacms-media 0.0.1 - Media CMS extension for Yesod apps  http://hackage.haskell.org/package/lambdacms-media-0.0.1 (cies)
15:36:59 <ab9rf> mzabani: unless the specification of the interface states one and all implementations comply with the specification (which the compiler cannot enforce)
15:37:04 <benmachine> serika: I basically think infix syntax is complicated enough as it is :)
15:37:21 <serika> haha :)
15:37:38 <EvanR> IGenericInterface { Any veryDescriptiveNameYouMustMatch(Any arg1, Any arg2); }
15:37:55 <EvanR> very generic
15:38:32 <mzabani> ab9rf: but how is that different from lists in Haskell? A list can be a very complex mix of several function calls and even inefficient algorithms
15:38:47 <EvanR> Interfaces often dont have any specification
15:38:47 <dgomez> EvanR: I don't understand what you're identifying
15:38:56 <ab9rf> mzabani: reasoning about computational complexity in haskell can be challenging :)
15:39:42 <mzabani> but it is not any different from IEnumerables in C#, is it? The issue about it being hard to argue about complexity is lazy evaluation's fault, is it not?
15:40:52 <EvanR> laziness spreads the work out, and lets you avoid doing some of it if that makes sense. in strict languages you always do all of it early and you can identify what is responsible for what, but a lot of is computed needlessly
15:41:16 <ab9rf> mzabani: the difference is that in haskell a list may contain unevaluated thunks
15:41:43 * hackagebot lambdacms-core 0.0.7.2 - Core CMS extension for Yesod apps  http://hackage.haskell.org/package/lambdacms-core-0.0.7.2 (cies)
15:42:22 <ab9rf> however, it's probably unfair to charge the list implementation for the cost of deferred lazy evaluation
15:42:47 <benmachine> serika: I found a new way to write your function, it's super general
15:42:48 <mzabani> ab9rf: oh, I see what you mean, laziness in Haskell is taken much more seriously, to the point where many things would have to be evaluated in C# that wouldn't in Haskell
15:42:54 <benmachine> :t fmap fmap fmap F.foldMap fmap F.toList
15:42:56 <lambdabot> (Foldable t1, Foldable t) => (a -> t1 a1) -> t a -> [a1]
15:43:05 <ab9rf> [a] has well-defined performance information
15:43:11 <serika> benmachine: <3
15:43:26 <benmachine> serika: <3
15:43:44 <benmachine> okay this PROBABLY signifies bedtime for me
15:43:47 <benmachine> or at least, no more haskell >_>
15:44:10 <mzabani> I still don't agree with that. Some instances of lists can even be infinite, to the point where evaluation would never end
15:44:14 <ab9rf> if you have a type class that represents an abstract collection (say, Collection a), and you have a function that operates on types that are instances of Collection a, you may not be able to reason about the overall performance because you don't know the computational complexity of instance being used
15:44:33 <EvanR> mzabani: if you are producing a list, you can choose to force all the computations if you think that would be beneficial. client code that accepts a list shouldnt be / cant be worrying about how the list was created.
15:44:41 <ab9rf> this is exactly the same as the IEnumerable problem in C++ or C#
15:44:54 <mzabani> yep, but that is my point
15:44:56 <EvanR> mzabani: and yeah, client code cant even know if a list is finite.
15:45:08 <ab9rf> but [a] isn't a typeclass, it's a type.
15:45:16 <mzabani> both IEnumerable and lists in Haskell do not enforce any performance constraints
15:45:38 <ab9rf> mzabani: the performance of [a] is predictable.
15:45:54 <EvanR> what does enforces performance constraints?
15:45:58 <ab9rf> (of operations on [a], that is)
15:46:15 <mzabani> I'm really not getting it
15:46:17 <mzabani> lol
15:46:17 <EvanR> anything can cause an infinite loop anywhere in most languages
15:46:25 <EvanR> no data types are going to stop them
15:46:27 <benmachine> well, if you have xs :: [a], and you pattern match on it, you might force it to be evaluated, and that could do anything
15:46:29 <ab9rf> Haskell native lists have a specified implementation from which you can predict complexity for the (fairly few) operations defined on them
15:46:53 <ab9rf> benmachine: yes, but that's just deferred complexity from whatever is in the liss
15:46:59 <EvanR> give a thunk, you cant predict if it will be fast, slow, or bottom
15:47:02 <EvanR> given*
15:47:08 <benmachine> so in that sense their performance is not specified... but that's more about whatever process you used to create it, than the thing in itself
15:47:23 <ReinH> mzabani: lists in Haskell do have well defined asymptotic behavior and it is possible to reason about the time complexity of many structures and algorithms.
15:47:27 <ab9rf> i don't think it's fair to charge an operation for the time required to evaluate unevaluated thunks stored within
15:47:31 <benmachine> wait I said I was going to bed
15:47:37 * benmachine resumes that mission
15:47:42 <mzabani> I would argue that lists in Haskell are more predictable than IEnumerables, but still not predictable at all, since the producer of the elements of the list can be of an arbitrary complexity
15:47:57 <EvanR> mzabani: youre talking about thunks though, not lists
15:48:20 <benmachine> mzabani: that hardly seems the list's fault
15:48:33 <mzabani> ah, I get it now, I need to fix my language
15:48:34 <ab9rf> mzabani: but in the IEnumerable case you're dealing with already evaluated values stored in a structure of unknown imeplementaiotn
15:48:37 <ReinH> One way to reason about time in Haskell is to use reduction steps as a proxy
15:48:48 <benmachine> that's like saying integers are weird because you might take ages to compute the length of the shortest path in a graph
15:48:55 <EvanR> ab9rf: or not, that interface has no specification
15:49:00 <ab9rf> mzabani: with haskell lists, you are dealing with possibly unevaluated thunks stored in a structure of known implemnentation
15:49:04 <EvanR> it could be launching missiles
15:49:20 <ab9rf> EvanR: true, it could send out carrier pigeons and wait for a reply
15:49:28 <EvanR> im sure it does
15:49:44 <mzabani> hahaha yes, you're right, I was really talking about lists and list producers interchangeably
15:50:02 <mzabani> and I understand your point now
15:50:05 <ab9rf> evaluating an element of a haskell list will not launch missiles.
15:50:07 <ReinH> ab9rf: That's true, but it doesn't affect our ability to reason about asymptotic complexity of functions that take (polymorphic) lists
15:50:23 <ab9rf> ReinH: i agree, although i think i'm failing to express myself well :)
15:50:32 <kgadek> hi. I'm looking for a "good" random gen library. Eg. mwc-random looks nice but uses PrimState and that's a no-go for me. Will play with genetic algos, so good quality and nice performance would be nice :) Any recommendations?
15:50:33 <ReinH> e.g. map will always be O(n)
15:51:03 <mzabani> though the fact that lists have well defined complexity for many operations doesn't help us much, does it? We are always dealing with produced lists, and so we still have to think about the complexity of producers
15:51:22 <ab9rf> mzabani: but that's the complexitry of the producer, not of the list operation itself
15:51:22 <ReinH> mzabani: sure, but we can reason about both.
15:51:34 <ReinH> We can't reason about "lists containing arbitrary unevaluated functions" in any context
15:51:37 <EvanR> mzabani: the point in time at which the work is done has moved around (or disappeared) under lazy evaluation
15:51:53 <EvanR> rather than got absolutely slower
15:52:00 <EvanR> or unknown
15:52:17 <mzabani> I understand that the separation really is helpful, and that is the main difference from Haskell Lists to IEnumerables in C#
15:52:26 <ab9rf> lazy evaluation tends to trade increased memory usage for the possobility of decreased computational time
15:52:29 <EvanR> the types are totally different too
15:53:10 <ReinH> I would suppose that the *main* difference between lists in Haskell and IEnumerable in C# is that the former is a data structure while the latter is an interface.
15:53:45 <ab9rf> mzabani: a haskell list is a concrete type with a specified implemenation.  a C# interface is an abstraction with no specific implementation, and the operations it defines could do anythring by any means whatsoever.
15:53:53 <EvanR> mzabani: i tried to look up IEnumerable. what does this allow you to do? iterate over a sequence of things?
15:54:16 <EvanR> i dont see a way to cons an element to the beginning of an IEnumerable
15:54:31 <mzabani> well, certainly, but there is no precise comparison of nearly any concept in Haskell to C#
15:54:39 <ab9rf> EvanR: i'm fairly certain that IEnumerable is access-only
15:54:48 <EvanR> ok so this is a weird comparison
15:54:52 <ReinH> mzabani: But I think you can do better than two categorically different entities...
15:54:58 <ab9rf> mzabani: interfaces are analogous to Haskell classes
15:55:08 <EvanR> list isnt a class
15:55:09 <ab9rf> although there are obviously differences
15:55:12 <mzabani> perhaps we should compare Ienumerable to functors, then?
15:55:21 <ab9rf> EvanR: no, a haskell list is a concrete type.
15:55:32 <ab9rf> EvanR: which is part of the problem, mzabani is comparing apples to oranges.
15:55:39 <EvanR> mzabani: ok but what are the methods for IEnumerable, from what i can see all it has it (something) GetEnumerable
15:55:40 <ab9rf> it's like comparing Char to Num
15:55:56 <EvanR> GetNumerator
15:55:57 <ab9rf> except that's not fair because Char is a Num instance
15:56:29 <EvanR> ok IEnumerator... it has Current and MoveNext
15:56:30 <mzabani> yep, GetEnumerator which returns a IEnumerator, which has MoveNext() and Current
15:56:33 <ab9rf> i think IEnumerable is probably most analogous to Traversable
15:56:48 <mzabani> that sounds like a good match, at least name-wise
15:56:49 <EvanR> Foldable?
15:56:57 <mzabani> it is like Java's Iterable
15:57:17 <mzabani> it is exactly like Java's Iterable and C++'s forward only iterators
15:57:20 <ab9rf> EvanR: Foldable may be too strong, but i'd have to look
15:57:38 <ReinH> There isn't a precise analog
15:57:48 <mzabani> although exactly may be too strong here
15:58:15 <EvanR> can we use a more interesting interface ;)
15:58:15 <ReinH> Trying to match typeclasses in Haskell to interfaces in C# isn't really a productive exercise...
15:58:23 <ab9rf> ReinH: agreed
15:58:24 <phooby> any suggestions about how to improve the intuition about where you require strictness? books? papers? exercises? general tips? :)
15:58:42 <ReinH> phooby: http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html
15:58:50 <ab9rf> hwoever, reading the hackage for Data.Traversable makes me think that Traversable is probably the closest analog
15:58:57 <mzabani> sorry guys, but it's been a good learning exercise for me so far
15:59:13 <phooby> reinh, wow, that was fast. thanks :)
15:59:16 <ReinH> phooby: :)
15:59:24 <ab9rf> mzabani: note that [] is a Traversable instance
15:59:34 <EvanR> ab9rf: traversible lets you modify a structure, foldable lets you reduce a structure completely
15:59:49 <ReinH> EvanR: traversable lets you do both
16:00:00 <ReinH> any traversable is also foldable
16:00:00 <EvanR> traversable ok, its a super class
16:00:44 <ab9rf> oh, right, foldable is weaker than traversable.
16:01:17 <mzabani> Traversable does look pretty similar
16:01:23 <EvanR> its not
16:01:26 <mzabani> guys, thank you for your help
16:01:44 * hackagebot vinyl 0.5.1 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.5.1 (AnthonyCowley)
16:01:45 <mzabani> hahaha really?
16:01:57 <EvanR> enumerable just is a for loop over a sequence
16:01:57 <platz> I don't see how IEnumerable captures accumulating applicative effects though like traverse does
16:01:58 <ab9rf> mzabani: for most situations you use IEnumerable in C# you'd probabl want a Foldable instance in Haskell, but even that is iffy
16:02:51 <dgomez> ab9rf: i'm sorry if I don't understand but what sorts of complications arise from that?
16:03:06 <ab9rf> dgomez: not sure i understand the question
16:03:13 <ab9rf> dgomez: actually, i am sure i don't understand it
16:03:46 <ab9rf> platz: i agree, Traversable is a stronger defintion than IEnumerable
16:03:56 <dgomez> ab9rf: comparing " IEnumerable in C# you'd probabl want a Foldable instance in Haskell, but even that is iffy" I don't understand what you are saying
16:04:07 <EvanR> like i was saying before, very much is possible using that interface, but none of it is described by the interface
16:04:09 <ab9rf> dgomez: don't worry about it :)
16:04:50 <ab9rf> dgomez: it probably doesn't make sense anywy
16:05:18 <dgomez> ab9rf: ok, i guess you're probably right.
16:05:21 <EvanR> the same way a goto is more powerful than a for loop, but if you told someone you were going to do a goto they wouldnt know shit about what that would mean in the bigger picture
16:05:28 <mzabani> oh, I see. The classes in Haskell we are comparing IEnumerable to are much stronger.
16:05:39 <ab9rf> mzabani: in general, yes.
16:05:41 <EvanR> mzabani: they say more, and can do less
16:06:22 <mzabani> I just opened Traversable in Hackage and realized how much more specific it is
16:06:44 * hackagebot vinyl-gl 0.3 - Utilities for working with OpenGL's GLSL shading language and vinyl records.  http://hackage.haskell.org/package/vinyl-gl-0.3 (AnthonyCowley)
16:06:46 <EvanR> :t T.sequenceA
16:06:47 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
16:07:07 <EvanR> :t foldMap
16:07:08 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
16:08:06 <mzabani> cool
16:08:13 <mzabani> thanks once again guys
16:08:27 <mzabani> I'm going back to haskell now, practice some things
16:11:44 * hackagebot vinyl-gl 0.3.0.1 - Utilities for working with OpenGL's GLSL shading language and vinyl records.  http://hackage.haskell.org/package/vinyl-gl-0.3.0.1 (AnthonyCowley)
16:17:44 <lpaste> topi pasted “ugly renderdata” at http://lpaste.net/118338
16:18:31 <topi> so I got this code, the output is correct. However the code looks almost like from imperative language and I was wondering whether you guys had any suggestions to make it more elegant
16:19:40 <topi> the difficulty comes from the fact that for each branch the angle is dependent on it's position on the data structure, hence the increment value
16:23:52 <jle`> topi: btw, `flip concatMap` is in Prelude
16:23:57 <jle`> in operator form, (>>=)
16:24:21 <zwer> it is more general, though
16:24:48 <jle`> you have a redundant do, but i think you already noticed that too
16:25:04 <topi> jle`: are you saying flip concatMap is equivalent to (>>=)
16:25:16 <jle`> i'm saying that you can use (>>=) to replace flip concatMap
16:25:26 <jle`> > [1,2,3] >>= (\x -> [x*2, x*3])
16:25:27 <lambdabot>  [2,3,4,6,6,9]
16:25:59 <matematikaadit> @@ @pretty @do [1,2,3] >>= (\x -> [x*2, x*3])
16:25:59 <lambdabot>  do a <- [1, 2, 3]
16:25:59 <lambdabot>     (\ x -> [x * 2, x * 3]) a
16:26:14 <Axman6> gross
16:26:17 <jle`> heh.
16:26:29 <matematikaadit> @@ @pretty @do [1,2,3] >>= \x -> [x*2, x*3]
16:26:29 <lambdabot>  do x <- [1, 2, 3]
16:26:29 <lambdabot>     [x * 2, x * 3]
16:26:39 <jle`> that one is nice :)
16:27:08 <jle`> also, a minor point, [blah] ++ ... is just blah : ..., but you might have been trying to mirror the syntax between the two branches
16:27:30 <topi> ah cool
16:28:05 <jle`> also i'm not sure why you bind `l`, and then later shadow it in a `where` declaration?
16:28:11 <matematikaadit> or better yet, why not set both blah : [], and blah : ...
16:28:36 <jle`> on lines 19 and 21
16:29:32 <jle`> hm
16:29:33 <topi> oops.. l = label in node and l = length in the former
16:29:43 <jle`> do you ever use the label in node?
16:29:58 <topi> not yet no
16:30:05 <Chathurga> Are 2 cases even needed?
16:30:17 <topi> http://i.imgur.com/ElJz3dM.png
16:30:30 <topi> this is how it's supposed to look like eventually
16:30:33 <topi> the render i mean
16:31:37 <felix___> http://i.imgur.com/ElJz3dM.png
16:32:21 <topi> Chathurga: what do you mean?
16:32:45 <jle`> you could probably get away with mapping over zip f [0..]
16:32:54 <jle`> to get a list of [(i, x)]
16:32:58 <jle`> (that's backwards)
16:33:21 <jle`> and so it'll be [] if f is empty, or [(1, x1), (2, x2), (3, x3)] ... etc.
16:34:47 <topi> yeah, that sounds pretty good
16:38:35 <topi> okay, cheers everybody, i'll get back into it
16:47:31 <dgomez> Hi, I'm still working on Diagrams today. I've made changes to the nasty code I had yesterday but I still don't have a clear idea if I am headed in the right direction with what I want to produce
16:48:13 <dgomez> I was wondering if someone would give it a quick overview just to see if it is even syntactically correct?
16:48:42 <mpickeri1g> what does the compiler say :) ?
16:50:12 <dgomez> mpickering: hs:38:2:
16:50:12 <dgomez>     parse error (possibly incorrect indentation or mismatched brackets)
16:50:41 <dgomez> mpickering: particularly where I have two functions where I'd like there to be mkStops and mkLinearGradient
16:52:08 <jle`> hard to say when we can't look at code :/
16:53:05 <dgomez> jee`: If I could message it privately to someone, I think its a bunch of bull**** and I'd like to know if I should redirect how I'm approaching it
16:54:03 <jle`> you can post it on lpaste :)
16:54:09 <jle`> @where lpaste
16:54:10 <lambdabot> http://lpaste.net/
16:54:34 <monochrom> is it imperative to message privately, as opposed to posting on a paste bin?
16:55:22 <Axman6> dgomez: sharing your code is the best way for people to give you hints on how you could improve
16:55:24 <dgomez> monochrom: no it isn't but honestly I don't want to post my shortcomings on such a big audience at this moment. But I could if none wants to receive any other way.
16:55:30 <dgomez> Axman6 ok
16:56:29 <AshyIsMe> if everyone would kindly print out and sign this NDA, i'll be happy to send through a copy of this code for some helpful reviewing... :P
16:56:57 <jle`> nobody is here to judge you :)
16:57:03 <jle`> :D
16:57:16 <MP2E> hah, that'd be amazing to see an NDA with every person in #haskell 's signature on it :V there'd probably be many pages of signatures
16:57:17 <jle`> we were all really really bad at one point
16:57:23 <dgomez> AshyIsMe: NDA isn't even the issue :p
16:57:24 <jle`> well i can't speak for everyone
16:57:26 <jle`> i can speak for myself tho
16:57:28 <lpaste> dgomez pasted “Diagram 2” at http://lpaste.net/118339
16:57:28 <jle`> haha
16:57:39 <dgomez> There it is...
16:58:08 <jle`> the error is on line 38?
16:58:31 <jle`> oh
16:58:31 <dgomez> jle` yes thats's the first error i get
16:58:36 <jle`> (--??) is not a comment
16:58:39 <jle`> it's actually an operator
16:59:03 <Axman6> > let a --??? b = a + b in 1 --?? 2
16:59:05 <lambdabot>  Not in scope: ‘--??’
16:59:05 <lambdabot>  Perhaps you meant ‘--???’ (line 1)
16:59:05 <jle`> i know right
16:59:06 <dgomez> jle`  sorry I just added that on lpaste as a comment.
16:59:11 <Axman6> > let a --??? b = a + b in 1 --??? 2
16:59:12 <lambdabot>  3
16:59:13 <dgomez> It wasn't there originally
16:59:16 <jle`> oh
16:59:19 <zq> what's the idiomatic way to create an extensible algebraic datatype?
16:59:37 <jle`> then i'm stumped
17:00:10 <jle`> well, "Diagram" can't be a type, i think...it's waiting for two arguments
17:00:27 <jle`> but i'm not sure why that ends up as a parse error
17:00:31 <dgomez> jee`  : yes it is. I just have no idea what arguments to pass
17:00:43 <osa1__> how can I compare two Int#s for equality and get a Bool answer?
17:00:46 <Axman6> yeah, the type stops :: Diagram is clearly wrong if lolly :: Diagram B R2  is correct
17:00:56 <josephle> zq: barring obscure pragmas that I don't know about, haskell doesn't have open datatypes
17:00:59 <t7> whats the name of a tree where siblings are ordered
17:01:20 <Axman6> t7: a trie maybe?
17:01:34 <AshyIsMe> dgomez: Diagram B R2  is probably what you want
17:01:44 <dgomez> Axman6: yes you're right, I was unsure if defining a type was correct
17:01:58 <AshyIsMe> B is short for "backend", all of the backends export it so you can swap backends just by changing the import at the top
17:02:12 <jle`> osa1__: does #== work
17:02:14 <dgomez> AshyIsMe: maybe but stops uses mkStops which isn't a Diagram type?
17:02:16 <Axman6> osa1__: ummm, one sec. there's something like toBool which lets you use the # functions to make more optimal (ie, caseless) binary expressions
17:02:23 <AshyIsMe> and R2 is the 2d drawing space, though i havent explored much further in to diagrams myself yet
17:02:34 <osa1__> jle`: I don't think there is such a function
17:02:42 <jle`> :'(
17:02:50 <osa1__> Axman6: where's that?
17:02:58 <Axman6> osa1__: trying to find it
17:03:05 <Axman6> it changed in a recent GHC
17:03:18 <topi> is there a page where operators such as (>>=) are collected?
17:03:31 <jle`> topi: do you mean commonly used operators?
17:03:39 <jle`> not sure what you mean by "such as (>>=)"
17:03:44 <dgomez> AshyIsMe: got it. I understand
17:03:58 <topi> jle`: suppose so
17:04:22 <Axman6> osa1__: https://ghc.haskell.org/trac/ghc/wiki/PrimBool explains it
17:04:23 <AshyIsMe> dgomez: ah mkStops returns a [GradientStop]: http://projects.haskell.org/diagrams/haddock/Diagrams-TwoD-Attributes.html
17:04:29 <AshyIsMe> search for "mkStops" there
17:04:43 <osa1__> Axman6: thanks
17:05:09 <AshyIsMe> dgomez: mkLinearGradient is on that page too, it returns a Texture
17:07:14 <osa1__> "The first argument of ($) takes one argument, but its type ‘String -> (String, [(Var, Term)])’ has only one" wat
17:07:15 <dgomez> AshyIsMe: meaning I would have to incorporate one of their constructors to better define what I want to do?
17:09:19 <samba1> is there an alternative pattern for (x =<<) <$> y to perform a monadic action one level deeper?
17:09:21 <Hijiri> are haskell papers required to be twocolumn ?
17:09:49 <samba1> so the final type is (a -> m b) -> m2 (m a) -> m2 (m b)
17:10:19 <jle`> Hijiri: it's just the accepted standard for academic journals in general...so academic papers tend to be formated that way
17:10:22 <Axman6> Hijiri: I think it's a requirement of whatever journal they get sent to, it does make them kuch more readable IMO
17:10:22 <jle`> why, i cannot say
17:10:40 <Hijiri> oh, I see
17:11:09 <jle`> if only `bind` was in base!! :'(
17:11:47 * hackagebot hans-pfq 0.1.0.0 - Driver for real ethernet devices for HaNS  http://hackage.haskell.org/package/hans-pfq-0.1.0.0 (tolysz)
17:11:51 <jle`> (fmap . bind) x y
17:12:31 <jle`> or `fmap (x =<<) y` i guess. operators are silly
17:13:32 <samba1> yes, that's shifting things around a little. but there is no established shorthand for this?
17:13:51 <enthropy> :t \f x -> lift . f =<< x
17:13:52 <lambdabot> (MonadTrans t, Monad (t m), Monad m) => (a -> m b) -> t m a -> t m b
17:13:53 <marioxcc> Hi. Is there a function in the standard library to compute an array diagonals? E.g: [[1,2,3],[4,5,6],[7,8,9]] --> [[1],[2,4],[3,5,7]...]?
17:14:10 <shachaf> Do you mean a list?
17:14:38 <marioxcc> I mean a matrix represented as nested lists.
17:15:25 <samba1> I see
17:15:53 <enthropy> depending on what m and m2 are, there might be some newtype 't' that you could apply to that m2 (m a) value, and then you could use lift
17:16:18 <AshyIsMe> dgomez: i think you can just drop off the type declarations and use stops and gradient as you want to
17:17:05 <AshyIsMe> im no diagrams expert though
17:17:39 <jle`> > transpose (zipWith (\i -> (replicate i 0 ++)) [0..] [[1,2,3],[4,5,6],[7,8,9]])
17:17:40 <lambdabot>  [[1,0,0],[2,4,0],[3,5,7],[6,8],[9]]
17:17:45 <dgomez> AshyIsMe: i think so too. I just put it there to see if anyone rerfered to it or had an explanation as to why it shouldn't be there
17:17:50 <jle`> not sure what to do with the 0's though at the end of the first half
17:36:33 <zwer> > map catMaybes $ transpose $ zipWith (\i xs -> replicate i Nothing ++ map Just xs) [0..] [[1,2,3],[4,5,6],[7,8,9]]
17:36:34 <lambdabot>  [[1],[2,4],[3,5,7],[6,8],[9]]
17:38:36 <EvanR> () is the zero arg tuple
17:40:35 <dgomez> I'll be back. gonna figure more of this out.
17:45:40 <marioxcc> Hi. Does haskell has continuations like scheme or some other provision to do the equivalent of alter control flow other than calling functions?
17:46:01 <marioxcc> E.g: conditions like Common Lisp or exceptions, which are a specific case of the former.
17:46:04 <lpaste> topi revised “ugly renderdata”: “prettier renderdata” at http://lpaste.net/118338
17:46:09 <EvanR> there is the continuation monad, but you dont need this to make new control flows
17:46:20 <EvanR> lazy evaluation can do this instead
17:46:26 <topi> heh, not sure if anymore comprehensible but at least more satisfying :)
17:46:49 <marioxcc> Please elaborate on how to use lazy evaluation as scheme continuations.
17:47:15 <EvanR> marioxcc: exceptions (non-IO) can also be implementing using normal lazy evaluation
17:47:33 <EvanR> ok did you want continuations, or a way to make different control flows?
17:47:40 <EvanR> they dont require each other
17:47:46 <marioxcc> I'm just curious.
17:47:47 <marioxcc> could you please elaborate?
17:47:52 <EvanR> both can be done with normal haskell code
17:48:07 <EvanR> for call/cc type stuff, look at the Cont monad
17:48:20 <shachaf> marioxcc: What did you read about the topic of continuations in Haskell so far?
17:48:32 <marioxcc> shachaf: Nothing.
17:48:42 <marioxcc> That's why I'm asking if they exist in the first place. :)
17:49:01 <marioxcc> Suggestions for a starting point would be appreciated.
17:49:16 <shachaf> Oh, well, any web search would find a bunch of information.
17:49:22 <shachaf> @google continuations in haskell
17:49:23 <lambdabot> https://www.haskell.org/haskellwiki/Continuation
17:49:26 <marioxcc> Ok.
17:49:46 <marioxcc> I thought you may have had an especially good suggestion.
17:51:00 <marioxcc> Thanks shachaf, EvanR
17:51:32 <marioxcc> and lambdabot
17:58:34 <toggler> Ivory is terrible
17:59:17 <benzrf> is there anything like ixset but less powerfully generic
17:59:38 * Clint squints.
18:00:13 <benzrf> basically i just want Map Thing1 (Set Thing2) except that i can pretend it's just a set with the keys as fields on the values
18:00:46 <benzrf> ixset seems fine, just slightly overpowered
18:01:35 <EvanR> theres another one with fancier types to get around the Typeable
18:01:49 <EvanR> ixset-typed ?
18:01:59 <marioxcc> Does it makes sense to write functinos in a tail-recursive manner in Haskell when a non-tail recursive form is simpler?.
18:02:17 <marioxcc> E.g: in order to avoid using O(N) storage space in the factorial function.
18:02:34 <EvanR> you have to relearn how to understand how much space something is taking up
18:02:39 <EvanR> which factorial are you looking at
18:02:57 <marioxcc> I'm talking about things like factorial n = n * (factorial (n - 1)) versus an implementation that uses a tail-recurive factorial function
18:03:35 <EvanR> so that takes up space because * is strict
18:03:40 <Lokathor> what is the use of having a main method of a type other than IO ()?
18:03:51 <Lokathor> er, main function, pardon my java
18:04:06 <benzrf> Lokathor: well, it could /theoretically/ be useful for things like recursing
18:04:14 <marioxcc> EvanR: Where can I start from?
18:04:16 <benzrf> but honestly that should probably be delegated out
18:04:36 <EvanR> marioxcc: you should try to evaluate an application of factorial by hand to see how it works
18:04:50 <EvanR> factorial 5
18:04:53 <enthropy> Lokathor: runghc will print out that value at the end (if it has a Show instance)
18:05:31 <Lokathor> now that i think about it, how does haskell do exit codes? C returns from main with a code, Java uses System.exit(code), etc
18:05:39 <EvanR> marioxcc: theres a lot of ways to define factorial, some avoid the inefficiency above, some dont, but first you need to know how its manifesting
18:05:42 <marioxcc> EvanR: I wouldn't see how much space it uses. I know how it would expand the stack in an imperative language.
18:05:58 <EvanR> yeah, its different in haskell
18:05:59 <enthropy> @index exitWith
18:05:59 <lambdabot> System.Exit
18:06:12 <Lokathor> > :t exitWith
18:06:13 <enthropy> same as java
18:06:14 <lambdabot>  <hint>:1:1: parse error on input ‘:’
18:06:16 <marioxcc> EvanR: So what should I do, and specifically, what's the case with factorial?
18:06:38 <EvanR> factorial 5, apply the definition of factorial to the argument, 5
18:06:39 <marioxcc> I assume that you know the classic tail recursive and non-tail recursive implementation.
18:06:55 <EvanR> i do but that mostly isnt going to help us here
18:07:07 <anon11> haskell
18:07:36 <marioxcc> What do you mean? I know what would happen if I evaluate it in GHCi for instance, but that doesn't tells me about the space usage. <- EvanR: factorial 5, apply the definition of factorial to the argument, 5
18:08:06 <EvanR> marioxcc: ill give you first step since its not clear from this starting point. step1 is 5 * factorial (5 - 1)
18:08:16 <EvanR> you gotta do it syntactically
18:08:35 <EvanR> the "tail call" here is the *
18:08:41 <EvanR> and you usually do that one next
18:09:11 <EvanR> but * is a primitive operation and needs both its arguments to be fully evaluated before it can be evaluated
18:09:27 <EvanR> so get to step 2
18:09:59 <marioxcc> EvanR: Ok, but based on that, how can I tell that Haskell will use O(N) or O(1) space?
18:10:24 <EvanR> you will get a better idea after going through all the steps
18:10:58 <EvanR> which thing is getting evaluated next
18:11:31 <marioxcc> EvanR: I know how to apply the substitution model to evaluate a procedure, but that doesn't answers my question.
18:11:41 <EvanR> you do?
18:12:05 <EvanR> its different from most lisps, and that has an effect on the answer to your question
18:12:19 <marioxcc> EvanR: Please elaborate.
18:12:21 <EvanR> and to whether something will infinite loop or not
18:12:36 <EvanR> step 2 is
18:12:41 <marioxcc> Well, I'm just learning Haskell.
18:12:57 <EvanR> 5 * ((5 - 1) * factorial ((5 - 1) - 1))
18:13:03 <marioxcc> Yes, right.
18:13:19 <EvanR> 5 * (4 * factorial ((5 - 1) - 1))
18:13:22 <SrPx> Suppose that I have a function such as: "foo a b = (expensiveComputation a) + b". Suppose that I define: "bar = foo 8". When I call "bar x", will "expensiveComputation a" be executed again?
18:14:03 <EvanR> actually i did it wrong, because in order to know if the factorial 0 = 1 case happens, it actually evaluates the argument
18:14:27 <EvanR> so this is bad starting example
18:14:33 <marioxcc> EvanR: Well, what's the point?
18:14:56 <EvanR> 5 * (4 * factorial (4 - 1))
18:15:10 <EvanR> 5 * (4 * (3 * factorial (3 - 1)))
18:15:12 <EvanR> ...
18:15:38 <EvanR> 5 * (4 * (3 * (2 * (1 * factorial (1 - 1)))))
18:16:23 <marioxcc> EvanR: I must insist, I know how function application is defined (For instance, as explained https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_%_sec_1.1.5).
18:16:24 <EvanR> so your intuition was accidentually right in this case, that it behaves a lot like lisp, and its using up something like a stack when it could be accumulating the answers along the wa
18:16:56 <EvanR> marioxcc: however, this is a special case, because multiplication on normal ints is a strict function
18:17:11 <marioxcc> EvanR: Ok.
18:17:21 <EvanR> most of the time it does not work like most of sicp
18:17:50 <EvanR> so heres another factorial
18:18:14 <EvanR> factorial n = foldl' (*) 1 [1..n]
18:18:25 <EvanR> @src foldl'
18:18:25 <lambdabot> foldl' f a []     = a
18:18:25 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:18:35 <EvanR> > [1..5]
18:18:36 <lambdabot>  [1,2,3,4,5]
18:19:05 <marioxcc> EvanR: Intuitively, I'd suppose that one takes O(1) space.
18:19:07 <marioxcc> Right?.
18:19:48 <lpaste> Zemyla pasted “Could Not Deduce (HasResolution b)” at http://lpaste.net/118342
18:19:55 <hiptobecubic> > let factorial = foldl' (*) x [y, z] in factorial
18:19:56 <lambdabot>  x * y * z
18:20:17 <hiptobecubic> > let factorial = foldl' f x [y, z] in factorial
18:20:18 <lambdabot>  f (f x y) z
18:21:14 <hiptobecubic> > let factorial = foldl' f x [y, z, x, y, z] in factorial
18:21:15 <lambdabot>  f (f (f (f (f x y) z) x) y) z
18:21:26 <lpaste> Zemyla revised “Could Not Deduce (HasResolution b)”: “No title” at http://lpaste.net/118342
18:21:42 <EvanR> marioxcc: it does, but because of a few conspiring factors. one, the seq is forcing the multiplication to happen even though its not needed to do the tail call
18:21:52 <EvanR> another is that ints dont take up that much space once computed
18:22:22 <marioxcc> EvanR: What's the “seq”?
18:22:24 <EvanR> sometimes the function to construct answers takes up less space than the answer
18:22:31 <marioxcc> Right.
18:22:42 <EvanR> check this function out, which would totally could have used
18:22:44 <EvanR> @src foldl
18:22:44 <lambdabot> foldl f z []     = z
18:22:44 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:22:55 <EvanR> so this is tail recursive
18:23:10 <EvanR> but if you tried to do factorial with it, it would blow your stack
18:23:32 <EvanR> see the expansion above
18:23:34 <marioxcc> Ok.
18:23:34 <AndreasL> Hey guys! I want to get into Haskell as a means to learn more about functional programming (of which I only have limited experience), but in order to do that I need a simple yet motivating project to work on. Does anyone have any cool ideas?
18:23:41 <EvanR> f (f (f (f (f x y) z) x) y) z
18:23:49 <hiptobecubic> I never understood how that was tail recursive
18:24:03 <AndreasL> to clarify: limited experience in functional programming, but a fair amount of experience in programming in general
18:24:08 <EvanR> it doesnt start doing any multiplications until the end of the list is reached
18:24:17 <marioxcc> I see.
18:24:26 <marioxcc> So it builds something like an extra stack.
18:24:39 <EvanR> well, from the programmers perspective this is the only stack
18:24:40 <marioxcc> Though the main stack wouldn't grow, because it's tail recursive.
18:24:55 <Zemyla> So what do I need to change to get the rule to compile and fire?
18:24:57 <EvanR> if your expression doesnt grow as you evaluate it, then its constant space
18:25:03 <marioxcc> Ok
18:25:23 <marioxcc> I have heard that it's hard to think about memory usage when using Haskell, what do you think?
18:25:36 <marioxcc> It seems like a matter of getting used to it, at least in this case.
18:25:47 <EvanR> yeah, but ive had practice, so this part is the easy stuff ;)
18:26:09 <marioxcc> AFK a moment.
18:26:52 <hiptobecubic> AndreasL, I wanted to write a little program that tracks keystrokes. Essentially just needs to record time pressed, time released, and key, and then you can write some interesting tools to tell you about that data.
18:27:50 <hiptobecubic> AndreasL, like which letters do you often have to bksp and correct? Which groups of letters do you type quickly vs slowly, etc
18:28:10 <AndreasL> hiptobecubic, oh, that's actually an interesting idea!
18:28:24 <EvanR> hiptobecubic: as i understand it, "tail call" in haskell means function application at the top-most expression of a body. to lazy evaluate this, you can "jump" directly to the body of that function and forget about the current context, since theres nothing there
18:28:49 <AndreasL> hiptobecubic, is that kind of data easily accessible with Haskell though?
18:28:58 <hiptobecubic> AndreasL, no idea.
18:29:14 <hiptobecubic> EvanR, but how is that the case with foldl?
18:29:17 <AndreasL> hiptobecubic, ok, I'll investigate then :) Just want to make sure I spend the time on learning the language and not some native API!
18:29:23 <AndreasL> hiptobecubic, thanks!
18:29:32 <EvanR> foldl f z (x:xs) = foldl f (f z x) xs
18:29:35 <marioxcc> I'm back.
18:29:46 <EvanR> foldls body starts with "foldl of..."
18:30:00 <Zemyla> So is there a name for the data structure that has a tree with one leaf, then a tree with two leaves. then a tree with four leaves, then a tree with eight. and so on to infinity?
18:30:12 <hiptobecubic> EvanR, what I mean is how can you forget about the xs while evaluating f z x
18:30:29 <EvanR> you dont forget, it goes with you
18:30:54 <EvanR> you arent evaluated (f z x) youre evaluating foldl f (f z x) xs
18:31:08 <hiptobecubic> right, but then you'll also have to bring x with you next time, and so on forever
18:31:25 <EvanR> which you do, immediately
18:31:36 <EvanR> nothing at all ever will happen on an infinite list
18:33:56 <EvanR> factorial n = foldl (*) 1 [1..n], so factorial 3 is
18:34:10 <EvanR> foldl (*) 1 (1:2:3:[])
18:34:56 <EvanR> foldl (*) (1 * 1) (2:3:[])
18:34:57 <marioxcc> EvanR: Let me see if I understand it: Despite that foldl is tail recursive, it uses O(N) space because it builds a thunk that only gets evaluated until the result of the fold is needed. However, foldl' would use O(1) space.
18:35:28 <EvanR> foldl (*) ((1 * 1) * 2) (3:[])
18:35:41 <EvanR> foldl (*) (((1 * 1) * 2) * 3) []
18:35:49 <EvanR> 6
18:35:59 <EvanR> in this case its building up a big multiplication
18:36:07 <EvanR> no stack
18:36:26 <marioxcc> No? What about laziness?
18:36:28 <Guest34150> Is there a way I can convert a template haskell Name to a string?
18:36:50 <EvanR> marioxcc: it worked exactly as planned, no weird * special cases this time
18:37:11 <Zemyla> marioxcc: The laziness is the fact that z isn't evaluated until the function returns.
18:37:20 <EvanR> of course it wastes a huge amount of space, so dont use foldl
18:37:28 <hiptobecubic> right ok
18:37:45 <hiptobecubic> is there any reason to use foldl then? ever, really?
18:37:51 <marioxcc> Zemyla: Ok.
18:37:58 <EvanR> the question comes up a lot and ive never heard of one
18:38:08 <hiptobecubic> good to know
18:38:23 <Zemyla> foldl' f z (x:xs) = let z' = f z x in z' `seq` foldl' f z' xs
18:38:25 <marioxcc> What to use then? foldl'?
18:38:35 <EvanR> for doing this kind of numeric accumulation yes
18:38:43 <marioxcc> Ok.
18:38:55 <EvanR> note that foldr isnt any better, but its the same problem as your original factorial
18:39:15 <EvanR> because of the strict *
18:39:20 <marioxcc> EvanR: Do you mean that it's not tail recursive?.
18:39:23 <EvanR> foldr works great on lazy combining function
18:39:45 <marioxcc> Can foldr be applied to an infinite list?
18:39:52 <EvanR> marioxcc: well, that combined with the strict * was the issue. but tail calling was basically irrelevant in both cases
18:40:02 <marioxcc> EvanR: Ok.
18:40:08 <EvanR> yes, foldr works on infinite lists, as long as the combining is lazy
18:40:30 <Zemyla> It becomes foldl' (*) 1 (1:2:3:[]) = (1*1) `seq` foldl' (*) (1*1) (2:3:[]).
18:40:41 <marioxcc> EvanR: how does that work? Doesn't it has to walk to the end of the list to begin folding?
18:40:53 <EvanR> marioxcc: foldl does
18:41:01 <EvanR> @src foldr
18:41:02 <lambdabot> foldr f z []     = z
18:41:02 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:41:11 <Zemyla> And then, it evaluates the `seq`, which makes it foldl' (*) 1 (2:3:[])
18:41:13 <EvanR> the first thing foldr does is call f, not itself
18:41:40 <shachaf> Zemyla: Writing (f x `seq` g (f x)) when you mean (let y = f x in y `seq` g y)) is really confusing.
18:41:44 <EvanR> Zemyla: yeah a good way to show that seq action is by using a let
18:42:00 <Guest34150> nameBase is what I was looking for, I think.
18:42:10 <Zemyla> Sorry. First time I've taught this.
18:42:51 <Zemyla> But yeah, foldr (:) [] ls is a list that is identical to ls.
18:44:00 <marioxcc> EvanR: But wouldn't foldr fail to give a result when evaluated on an infinite list?
18:44:15 <Axman6> no
18:44:21 <Axman6> well, depends on f
18:44:39 <Axman6> if f is strict in its second argufment then it can't return until it reaches the end of the list
18:44:48 <hiptobecubic> if f is lazy in the second arg then i think foldr can give you something
18:44:48 <marioxcc> I see.
18:44:49 <EvanR> marioxcc: imagine trying to take the first element of the result of the foldr
18:44:50 <hiptobecubic> ... right
18:45:14 <Axman6> tob?
18:45:16 <Axman6> whoops
18:45:32 <marioxcc> EvanR: I think I get it. It may not be necessary to process all elements of the folded list before giving the first element of a result.
18:45:40 <hiptobecubic> indeed
18:45:44 <marioxcc> I was thinking of arithmetic functions.
18:45:58 <Axman6> > foldr const undefined [1..]
18:45:58 <EvanR> arithmetic messes everything up!
18:45:59 <lambdabot>  1
18:46:02 <marioxcc> Do you guys think that Haskell is a good language to teach programming?
18:46:08 <EvanR> alternatively, arithmetic is the only reason anything ever happens ;)
18:46:09 <Axman6> sure
18:46:21 <Axman6> it's a great language to teach haskell programming in particular
18:46:27 <Axman6> as well as many other things
18:46:32 <marioxcc> haha Axman6
18:47:47 <Axman6> my experience in using it as a first year universary language is that it works well in letting you ignore some of the more hardware oriented topics like pointers, and focus on algorithms in a syntax that is somewhat similar (people who've programmed before struggle more than those who haven't but are comfortable with maths)
18:47:57 <marioxcc> EvanR: Is there a relation between that (That arithmetic makes think happen) and lambda calculus where functions just get substituted but never actually evaluated (it's not even defined)?
18:48:39 <marioxcc> Axman6: Right, I can see why it would be easier for people with experience with mathematics.
18:48:55 <EvanR> marioxcc: thats the point i was trying to make, with lazy evaluation you substitute whole expressions into the function, rather than evaluating them first.
18:49:09 <EvanR> this works great when the things you have dont evaluate ;)
18:49:19 <EvanR> > Just 5
18:49:20 <lambdabot>  Just 5
18:49:22 <Axman6> as long as people can understand basicv algebra and the idea of a function, they can learn haskell pretty easily
18:49:22 <EvanR> hehe
18:49:36 <marioxcc> EvanR: What's the Just 5 for?
18:49:48 <Zemyla> But yeah, is there a name for the kind of infinite tree I'm thinking of?
18:50:04 <benzrf> Zemyla: what kinda inf tr?
18:50:17 <EvanR> marioxcc: its a value. Just is a function. we think of Just 5 as being the Just applied to a 5, or a value in its own right
18:50:22 <EvanR> :t Just
18:50:23 <lambdabot> a -> Maybe a
18:50:29 <EvanR> :t Just 5
18:50:30 <lambdabot> Num a => Maybe a
18:50:50 <marioxcc> EvanR: I know how Maybe works, but what's the reason you mentioned “Just 5”?
18:51:16 <EvanR> metaphorically talking about "unevaluated or unevaluable objects"
18:51:16 <hiptobecubic> marioxcc, because "Just 5" isn't really evaluated
18:51:29 <EvanR> used in their own right
18:51:29 <marioxcc> hiptobecubic: Explain please.
18:51:30 <hiptobecubic> it's a function and its argument, but we don't see the "result" of that
18:51:35 <marioxcc> EvanR: Ok.
18:51:36 <Zemyla> Basically, it would be like a list with a one-leaf binary tree at the front, then a 2-leaf binary tree, then one with four leaves, then 8, and so on.
18:51:45 <hiptobecubic> > (+1) 2
18:51:46 <lambdabot>  3
18:51:53 <Drewbert> I just wrote my first template haskell function. :-]
18:52:02 <jle`> :-]
18:52:08 <hiptobecubic> So that was evaluated, it didn't just say "(+1) 2 == (+1) 2"
18:52:21 <Zemyla> data Branch a = Leaf a | TBranch (Branch a) (Branch a)
18:52:23 <EvanR> > Just (1 + 2)
18:52:25 <lambdabot>  Just 3
18:52:29 <Axman6> Zemyla: finder trees are an interesting take on that idea
18:52:38 <hiptobecubic> But "Just 5" doesn't really evaluate to anything else. It's just a function and an argument together that make a value
18:52:39 <Axman6> finger*
18:52:46 <marioxcc> EvanR, mhiptobecubic: Ok, but what if we think of Just 5 as being evaluated to an abstract object whose representation is “Just 5”?
18:52:48 <Zemyla> data Trunk a = Trunk Int (Branch a) (Trunk a).
18:53:00 <hiptobecubic> marioxcc, well sure, but you can say that about literally anything
18:53:17 <EvanR> marioxcc: it is. you also may have seen lambda x . x as an abstract object
18:53:22 <EvanR> thats all
18:53:23 <marioxcc> EvanR, hiptobecubic: That's right. Doesn't that breaks the argument that it's not evaluated?.
18:53:36 <Zemyla> If I stored, say, factorials or fibonaccis in that list, it should allow for log(n) lookup of the nth element.
18:53:55 <marioxcc> Oh, I see, so you mentioned it just as an abstract concept.
18:53:59 <EvanR> marioxcc: point is it doesnt matter, youll never know the difference. you also dont care about the underlying pointer swizzling
18:54:08 <marioxcc> EvanR: Ok.
18:54:30 <hiptobecubic> marioxcc, would you prefer "reduced"? The path you're taking leads to statements like you can evaluate source code by just claiming it has been evaluated and the representation of the result that you're choosing is the source code itself.
18:54:35 <EvanR> > (\x -> x)
18:54:36 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
18:54:36 <lambdabot>    arising from a use of ‘M439327970609851716315338.show_M4393279706098517163...
18:54:36 <lambdabot>  The type variable ‘t0’ is ambiguous
18:54:41 <hiptobecubic> Sure you can do that, but it's not fun or useful
18:54:48 <Zemyla> :t (\x -> x)
18:54:48 <lambdabot> t -> t
18:54:57 <EvanR> > (+1)
18:54:58 <lambdabot>  <Integer -> Integer>
18:55:02 <EvanR> pesky
18:55:07 <hiptobecubic> what!?
18:55:29 <EvanR> lambdabot can show some functions, apparently it relies on typable
18:55:36 <Zemyla> > id
18:55:37 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
18:55:37 <lambdabot>    arising from a use of ‘M427104886335819451515438.show_M4271048863358194515...
18:55:37 <lambdabot>  The type variable ‘a0’ is ambiguous
18:55:44 <Axman6> Zemyla: you might find this interesting: http://www.cs.ox.ac.uk/jeremy.gibbons/publications/rationals.pdf
18:55:47 <hiptobecubic> crazy
18:55:59 <hiptobecubic> > foldr (+) x
18:55:59 <EvanR> > (\(x, y) -> y + 1)
18:56:00 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
18:56:00 <lambdabot>                     Debug.SimpleReflect.Expr.Expr)
18:56:00 <lambdabot>    arising from a use of ‘M759920517908528928215457.show_M7599205179085289282...
18:56:01 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
18:56:02 <lambdabot>    arising from a use of ‘M821754581574536756815473.show_M8217545815745367568...
18:56:04 <lambdabot>  The type variable ‘t0’ is ambiguous
18:56:06 <marioxcc> EvanR: When you said “pesky”, did you mean what lambdabot does or something about Haskel?.
18:56:12 <EvanR> lambdabot
18:56:18 <hiptobecubic> > foldr (+) 3
18:56:20 <lambdabot>  <[Integer] -> Integer>
18:56:38 <Drewbert> Now I can prepend the data type name plus an "_" to my aeson objects, and I only have to write $(deriveJSONWrapper ''DataTypeName) and it will automatically call deriveJson with a TH generated fieldLabelModifier.
18:56:39 <EvanR> but also its kind of annoying that you get an error when the result is a function value
18:56:49 <hiptobecubic> > foldr (+)
18:56:50 <lambdabot>  <Integer -> [Integer] -> Integer>
18:56:58 <marioxcc> hiptobecubic: It's not that I prefer something in specific about a viewpoint, but I get what you mean when you said “reduced”.
18:57:01 <Axman6> Zemyla: http://en.wikipedia.org/wiki/Calkin–Wilf_tree for some more info
18:57:02 <hiptobecubic> i guess it uses defaults
18:57:04 <guhou> \f n -> last . (take n) . iterate f
18:57:09 <marioxcc> EvanR: Ok.
18:57:13 <guhou> > \f n -> last . (take n) . iterate f
18:57:14 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable c0)
18:57:14 <lambdabot>    arising from a use of ‘M681900512408036522015591.show_M6819005124080365220...
18:57:14 <lambdabot>  The type variable ‘c0’ is ambiguous
18:57:18 <EvanR> arrgggg
18:57:33 <Axman6> guhou: that's the same as iterate f !! n btw
18:57:43 <guhou> :t \f n -> last . (take n) . iterate f
18:57:44 <lambdabot> (c -> c) -> Int -> c -> c
18:58:15 <guhou> @Axman6 thanks I've been trying to work out a better way to write that
18:58:15 <lambdabot> Unknown command, try @list
18:58:18 <hiptobecubic> marioxcc, "reduced" isn't actually any better because you could just as easily say it was reduced to the abstract value and the representation of that is "Just 5" again. It's hard to pin donw.
18:58:24 <Axman6> :t \f n -> (!! n) . iterate f
18:58:24 <hiptobecubic> down*, rather
18:58:25 <lambdabot> (c -> c) -> Int -> c -> c
18:58:26 <EvanR> marioxcc: in other languages, an unreduced lambda expression would appear as-is on the console, no error
18:58:36 <Axman6> !! is safe to use here since iterate is infinite
18:58:56 <guhou> Axman6: I thought hoogle would've found that
18:59:11 <marioxcc> EvanR: I'm not aware of any language like that, could you please name one?
18:59:15 <Axman6> @hoogle [a] -> Int -> a
18:59:17 <lambdabot> Prelude (!!) :: [a] -> Int -> a
18:59:17 <lambdabot> Data.List (!!) :: [a] -> Int -> a
18:59:17 <lambdabot> Prelude drop :: Int -> [a] -> [a]
18:59:43 <guhou> @hoogle (a -> a) -> Int -> a -> a
18:59:43 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
18:59:43 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
18:59:43 <lambdabot> Data.IntMap.Strict adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
18:59:43 <Zemyla> :t unfoldr
18:59:44 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
18:59:48 <EvanR> marioxcc: im new to them, so i can only name idris and the toy languages in type theory papers
18:59:49 <marioxcc> hiptobecubic: I see. I think that lambda calculus actually use the term “reduction”
18:59:58 <marioxcc> EvanR: Ok.
19:00:16 <Drewbert> EvanR: I agree with your annoyance about unreduced lambdas failing at show.
19:00:35 <marioxcc> EvanR, hiptobecubic: Are you computer scientist or standard Haskell users?
19:00:37 <EvanR> hiptobecubic: marioxcc you can refer to Just 5 and \x -> x as being in "normal form"
19:00:51 <EvanR> not every expression has a normal form in haskell
19:01:00 <Iceland_jack> Or just call them values
19:01:01 <marioxcc> EvanR: Yes, I think that would be meaningful. What doesn't have a normal form?.
19:01:52 <EvanR> they are values, but in a more abstract setting you might not have values, just expression reducing
19:02:07 <EvanR> marioxcc: length [1..]
19:02:13 <benzrf> EvanR++
19:02:19 <marioxcc> EvanR: Like lambda calculus?
19:02:25 <hiptobecubic> marioxcc, pretty standard here. Certainly not a type-theory wizard like some people in here
19:02:35 <marioxcc> hiptobecubic: Ok.
19:03:11 <EvanR> length [1..] also doesnt have weak head normal form either
19:03:20 <EvanR> which is more relevant in haskell most of the time
19:03:26 <hiptobecubic> studied bio and later computational science (which is basically just numerical computing and simulation), no real comp sci in the traditional sense
19:03:52 <marioxcc> hiptobecubic: Ok, Is that biology?
19:04:03 <hiptobecubic> bio meaning biology, yes.
19:04:09 <marioxcc> Ok.
19:04:15 <hiptobecubic> (and ecosystem science and chemistry)
19:04:27 <marioxcc> EvanR: What do you mean by “weak head normal form”?.
19:04:29 * hiptobecubic was a busy undergrad back in the day
19:04:36 <marioxcc> hiptobecubic: Ok.
19:04:54 <Axman6> marioxcc: it means you know which constructor a value is, usually
19:05:35 <Axman6> so evaluating undefined :: [Int] would throw and exception, but evaluating undefined : undefined to WHNF would be fine, since you know the constructor is (:)
19:05:41 <EvanR> let ones = 1:ones in ones, if you evaluate this to a weak head normal form you get
19:05:41 <marioxcc> Axman6: Like “Just 6“ and “Point 1 3” (Provided we defined a type with “Point” constructor).
19:05:54 <EvanR> 1:(let ones = 1:ones in ones)
19:06:10 <Axman6> marioxcc: well, like knowing whether something of type Maybe Int is Just _ or Nothing
19:06:29 <Axman6> it might be Just undefined, but when evaluating to WHNF we only care about the constructor
19:06:31 <marioxcc> Axman6: Ok, I understand.
19:07:04 <EvanR> it lets you stop and do something else before evaluating a huge or infinite data structure
19:07:19 <marioxcc> EvanR: Ok.
19:08:26 <EvanR> if i had a ones, as above, and i did ones !! 5, and got 1, then you could think of (if i still had the original ones around) as being
19:08:35 <EvanR> 1:1:1:1:1:(let ones = 1:ones in ones)
19:08:59 <EvanR> which could be a source of memory leaks if you keep using ones farther out, but dont forget about the initial part
19:09:28 <marioxcc> EvanR: Ok.
19:10:26 <Axman6> that definition is clearly circular and uses constant space
19:10:41 <EvanR> oh, right
19:10:54 <EvanR> ghc optimizes it sometimes
19:11:05 <Axman6> list_t l; l-> head = 1; l->next = l;
19:11:27 <Axman6> no, the definition of is states that it is pointing to itself, it's not an optimisation
19:11:34 <marioxcc> EvanR, hiptobecubic, Axman6: I just learn some insightful and very interesting things from you. What does what we talked about pertains to (Which area of science)?
19:11:36 <Axman6> @src cycle
19:11:36 <lambdabot> cycle [] = undefined
19:11:36 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
19:11:54 <benzrf> marioxcc: no areas of science
19:11:56 <EvanR> 1:2:3:4:5:[6..]
19:11:57 <benzrf> marioxcc: some nice areas of math though B)
19:12:37 <EvanR> alright so while sometimes an infinite list looks like its taking up a lot of space if you view it, its not ;)
19:12:59 <Axman6> yes =)
19:13:04 <marioxcc> benzrf: So are you implying that mathematics is not a science? (I guess you equate it with what others would call experimental science)
19:13:15 <Axman6> [1..] will, when evaluated, take up a lot of space if references to it remain
19:13:28 <EvanR> math is occult knowledge, cleanse yourself at once
19:14:08 <benzrf> marioxcc: uhhhhh
19:14:10 <Axman6> marioxcc: in a way, no. science is about the study of the real world, maths is a study of an constructed idea
19:14:14 <benzrf> marioxcc: math is the opposite of experimental
19:14:27 <EvanR> constructed, or non-constructive, idea ;)
19:14:27 <benzrf> marioxcc: science is where you use induction and math is where you use deduction
19:14:30 <Axman6> which happens to be applicable to the real world and can be used to modle much of it
19:14:30 <benzrf> they are dual
19:17:09 <marioxcc> benzrf: I meant that you equate *science* with [...], not that you equate *mathematics*. I acknowledge that I didn't make it clear.
19:17:27 <benzrf> ah ok
19:18:04 <marioxcc> Axman6: Yes, right, but I'm used to call it science as well, and so I use “science” roughly in the sense of “discipline of knowledge”.
19:18:27 <marioxcc> Rather than “study of the physical environment and the systems based on it“.
19:18:30 <EvanR> computers can be used as telescopes into the mathematical universe
19:18:41 <Axman6> Let's not go around using definitions that could include the arts now! :P
19:18:50 <EvanR> reversing the usual quote about how computer science has nothing to do with computers ;)
19:19:52 <marioxcc> Axman6: I was careful enough to say “roughly“ rather than to pretend it was a flawless definition. :)
19:20:07 <marioxcc> EvanR: Hehe.
19:21:13 <marioxcc> EvanR, benzrf, Axman6: Are you mathematicians, computer scientists or related?. It's fine if you don't want to tell.
19:22:26 <Axman6> I'm a software engineer/developer/whatever
19:22:43 <marioxcc> Ok.
19:23:15 <EvanR> yeah that
19:23:27 <marioxcc> Ok.
19:23:30 <Axman6> and I happen to use Haskell for my work
19:23:30 <chu> You still at ANU Axman6?
19:23:36 <derson> anyone have a little time to help a beginner? i just want to make a function that takes two arguments, each of which are the results from their own function calls
19:23:38 <Axman6> Nope. NICTA
19:23:44 <chu> Oh even better.
19:23:53 <derson> eg: foo $ (bar x) (baz y)
19:24:00 <Axman6> I was considering going back to tutor 1100 this year, but that ship has probably sailed
19:24:07 <derson> except, that doesnt work, and im having troubloe understanding $ and . to figure out why
19:24:16 <guhou> :t first (+1)
19:24:16 <lambdabot> Num a => (a, d) -> (a, d)
19:24:18 <chu> Axman6: Who are you working with at NICTA?
19:24:30 <marioxcc> derson: $ is function call while . is function composition. I'm a beginner too.
19:24:31 <guhou> :t first (-1)
19:24:32 <lambdabot> (Arrow a, Num (a b c)) => a (b, d) (c, d)
19:24:54 <shachaf> chu: whoa, chu spaces
19:24:58 <guhou> :t first (- 1)
19:24:59 <lambdabot> (Arrow a, Num (a b c)) => a (b, d) (c, d)
19:25:16 <EvanR> @pl (\f g h x y -> f (g x) (h y))
19:25:17 <lambdabot> ((flip . ((.) .)) .) . (.)
19:25:17 <guhou> :t first (+ -1)
19:25:18 <lambdabot>     The operator ‘+’ [infixl 6] of a section
19:25:18 <lambdabot>         must have lower precedence than that of the operand,
19:25:18 <lambdabot>           namely prefix `-' [infixl 6]
19:25:21 <Axman6> none of the researchers, I'm on a project related to the national map
19:25:41 <derson> marioxc - that makes sense, im just not thinking of it correctly to get the syntax correct
19:25:43 <marioxcc> derson: I don't understand what's what you want to do, however. A function that gets 2 functions and their arguments, then applies those 2 functions, but what's the result?.
19:26:11 <Axman6> chu: probably better to take this convo somewhere else, like -blah
19:26:37 <guhou> @pl first (\x -> x - 1)
19:26:37 <lambdabot> first (subtract 1)
19:27:10 <marioxcc> derson: Do you know that Haskell functions are curried?.
19:27:24 <marioxcc> If not, maybe you should ask or read about that first. :)
19:27:36 <derson> yeah, i understand that concept, and am trying to take that into account, but am still wrapping my brain around it
19:27:50 <marioxcc> derson: Again, what do you want to do?
19:28:09 <marioxcc> Could please put an example of how you'd call the function you want to write and what it would return?.
19:29:00 <derson> in reaily: project euler #6. find the difference between the sum of squares and the square of sums, from 1 to some n. so i wrote simple getSumSquares and getSquareSums functions
19:29:34 <marioxcc> derson: What do they do?
19:29:42 <derson> getSumSquares 5 should yield 55; get SquareSums should yield 15
19:29:44 <EvanR> write the types ;)
19:29:53 <marioxcc> derson: Ok, so why don't you just call them?
19:30:30 <derson> getSquareSums n = sum $ map (^2) [1 .. n]; getSumSqaures n = (^2) $ sum [1 .. n]
19:30:55 <EvanR> f : Integer -> (Integer, Integer) ?
19:31:00 <EvanR> f :: Integer -> (Integer, Integer) ?
19:31:24 <derson> so, the function im having trouble is the obviously-overkill function to simply subtract one from the other. given n=5, I want
19:31:43 <derson> gah, sorry. i would just want 55 - 15, but obviously to change that for different n to test
19:32:00 <marioxcc> derson: Why don't you call those functions and compute the difference?
19:32:14 <marioxcc> Maybe you want to do something contrived that it's not necessary or useful in this case.
19:32:14 <EvanR> theres lpaste to share exists code
19:32:18 <derson> so, I figured getDiff n = (-) (getSumSquares n) (getSquareSums n)
19:32:40 <EvanR> > (-) 3 4
19:32:41 <lambdabot>  -1
19:32:52 <derson> what, wait
19:32:58 <EvanR> > 3 - 4
19:32:59 <lambdabot>  -1
19:33:15 <derson> i thought i tried that first and it didnt work, which is why i was so confused about $ and . because i thought the obvious thing didnt work
19:33:22 <marioxcc> derson: You don't have to do things in prefix notation always.
19:33:46 <marioxcc> in your getDiff, I think it's better to use infix notation.
19:33:56 <marioxcc> It would be a bit clearer.
19:34:06 <EvanR> > (-) 3 4
19:34:08 <lambdabot>  -1
19:34:11 <EvanR> > subtract 3 4
19:34:13 <lambdabot>  1
19:34:21 <derson> yeah, i just figured i was going to try to use it because i know that im struggling with prefix notation, currying, composition, etc
19:35:34 <derson> ok, that makes more sense now, i thought i had missed something major, but apparently i just dont know how to test properly :)
19:35:53 <marioxcc> derson: It's very curious. I was solving the Project Euler exercises in Haskell to learn it as well.
19:36:19 <derson> (also, for anyone listening super-closely, getSquareSums 5 yields 225, not 15 (since it's 15^2), so the result is 170)
19:36:56 <derson> yeah, and i realize i can do some of these things piecemeal, like the sum squares, etc in the REPL itself, and then just subtract them infix, like a normal person
19:37:17 <EvanR> lol
19:37:25 <derson> but like i said, im forcing myself to do them a little differently to make sure i understand how to do function declarations and etc, which obviously i still need to work on
19:37:40 <derson> alright, it's late, thanks for the help! ill hopefully be around more in the near future
19:37:57 <marioxcc> derson: Function declarations are easy, maybe you had a problem with function application.
19:38:08 <marioxcc> Which may be confusing if you don't know what . and $ do.
19:38:31 <derson> i did know what they do, and now it seems ive gotten fuzzy, so ill brush up on them
19:38:34 <derson> thanks again
19:38:35 <EvanR> > (+1) 5
19:38:37 <lambdabot>  6
19:38:40 <EvanR> > (+1) $ 5
19:38:41 <lambdabot>  6
19:38:44 <EvanR> > (+1) `id` 5
19:38:45 <lambdabot>  6
19:40:11 <marioxcc> Well, thanks to everybody who helped me.
19:41:54 * hackagebot kan-extensions 4.2.1 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-4.2.1 (EricMertens)
19:46:55 <deconfigured> Was there an addition to GHC that made the promoted value constructors synonamous with their values, in addition to prepending `'`, for instance `'[]` and `[]`
19:47:23 <deconfigured> ?
19:47:52 <johnw> are you thinking of DataKinds, deconfigured?
19:48:39 <deconfigured> johnw: Yes, I can see that with the trivial `data Nat = S Nat | Z`, that both `:k S` and `:k 'S` return the same thing
19:49:10 <shachaf> deconfigured: If it's unambiguous then the ' isn't required.
19:49:38 <Zemyla> What is ' for?
19:49:47 <deconfigured> shachaf: Ahh! Perfect :) Thank you!
19:50:05 <shachaf> Disambiguation.
19:50:15 <Zemyla> > '[]
19:50:17 <lambdabot>  Syntax error on '[]
19:50:17 <lambdabot>  Perhaps you intended to use TemplateHaskell
19:50:50 <shachaf> '[] isn't a value.
19:50:53 <shachaf> [] is a value.
19:51:21 <Zemyla> So what is '[]?
19:51:36 <deconfigured> Zemyla: The empty type of kind `[k]`
19:51:49 <shachaf> Someone already mentioned the search keyword to find out more about it, DataKinds.
19:52:48 <shachaf> [] is a thing on the value level which has a type. '[] is a thing on the type level which has a kind.
19:54:10 <Axman6> :t '[]
19:54:11 <lambdabot>     Syntax error on '[]
19:54:11 <lambdabot>     Perhaps you intended to use TemplateHaskell
19:54:11 <lambdabot>     In the Template Haskell quotation '[]
19:54:19 <Axman6> :(
19:55:42 <Axman6> :t '[Int]
19:55:43 <lambdabot> parse error on input ‘Int’
19:55:50 <Axman6> :k '[Int]
19:55:51 <lambdabot> [*]
19:57:19 <jasonkuhrt_> I'm trying out Haskell by creating my perosnal site with it, using hakyll,  are there any other static site generators that people swear by?
19:57:38 <deconfigured> When pattern matching on `Dict` from the constraints library, to "bring the constraint into scope", means that any bound type variables in the value constructor `Dict`'s type signature now have the constraint ..enacted... in the expression?
19:57:52 <deconfigured> jasonkuhrt_: Check out scotty
19:58:01 <deconfigured> there's a good tutorial on it, and how to make a blog :)
19:58:12 <shachaf> deconfigured: I'm not sure I understand what you mean, but it sounds like you're getting at the right idea.
19:58:41 <deconfigured> shachaf: Yeah I'm having a hard time too :S
19:58:47 <deconfigured> Thanks :)
19:58:58 <shachaf> Maybe a concrete example would be helpful.
19:59:12 <deconfigured> woo lambdabot now has `:k`?!?
19:59:54 <deconfigured> :k '['True] --Axman6 :)
19:59:55 <lambdabot> parse error on input ‘'’
19:59:59 <deconfigured> mer
20:00:03 <shachaf> lambdabot has had :k for many years.
20:00:05 <shachaf> deconfigured: Oh, you're athan?
20:00:06 <deconfigured> nevermind :(
20:00:09 <deconfigured> oh shoot
20:00:21 <deconfigured> yeah I guess I'm logged in somewhere else :s
20:00:41 <Axman6> jasonkuhrt_: it's the best known, I've been meaning to use it at some point
20:00:51 <shachaf> Is that a yes?
20:01:02 <Axman6> deconfigured: scotty isn't a static site generator though
20:01:03 <deconfigured> shachaf: Yes that's correct
20:01:14 <shachaf> OK.
20:01:18 <deconfigured> Axman6: Yeah I fudged
20:01:56 <jasonkuhrt_> hakyll allows me to try haskell without having to worry about deployment just yet
20:02:08 <jasonkuhrt_> generally a static site generator I mean
20:02:23 <deconfigured> jasonkuhrt_: Check out pandoc, too, it's pretty nifty
20:03:12 <Axman6> well, hakyll is basically a wrapper around pandoc
20:03:20 <Axman6> with some nice features
20:03:44 <jasonkuhrt_> ok
20:04:01 <Axman6> jasonkuhrt_: it's probably not the best way to get a taste of haskell though. it's definitely easier to use once you know how to use haskell
20:04:34 <jasonkuhrt_> Axman6: I already know a bit of Haskell, just more in theory than practice right now, I've been reading about it for a while
20:04:51 <Axman6> then perhaps you'll be fine then =)
20:05:42 <Welkin> I think a good first project is to write a scheme interpreter in Haskell
20:06:01 <Welkin> you don't need anything other than some standard libraries
20:06:20 <Welkin> well, you could do it without them and write your own libraries instead too
20:06:47 <jasonkuhrt_> I think I'm good with a web-based project thanks, its something I need to do anyways and I know the domain very well
20:07:04 <Welkin> yesod taught me a lot
20:07:06 <NemesisD> is there any support for using cabal without a cabal file? i pretty much just want to run some ghc commands but uuse the local sandbox
20:07:14 <Welkin> it was my first big web project in haskell
20:07:32 <Welkin> although it uses a lot of template haskell so it can be cryptic unless you read through the yesod book first
20:07:42 <jasonkuhrt_> ok
20:07:46 <jasonkuhrt_> I've heard that
20:08:15 <Axman6> yeah yesod can be pretty fun. there's lots of magic though
20:08:26 <Axman6> magic = TH in many cases
20:08:47 <Axman6> but it's magic that makes your life a lot easier... until it makes it really hard :P
20:08:53 <Welkin> NemesisD: use `cabal repl`
20:09:24 <NemesisD> Welkin: oh i think i found it. cabal exec is what i was looking for
20:09:31 <Welkin> once you learn yesod you can be very productive with out
20:09:36 <Welkin> with it*
20:11:18 <Welkin> Scotty is almost exactly the same as Sinatra (ruby), except that it is in Haskell
20:11:26 <Welkin> the api is identical
20:12:10 <NemesisD> there's also spock which is maybe more like padrino
20:13:27 <Pamelloes> If I have a module "MyModule" how would I then create the module "MyModule.Util"?
20:13:52 <NemesisD> Pamelloes: create a directory called MyModule and add Util.hs
20:14:03 <Pamelloes> NemesisD: Thanks :)
20:14:25 <NemesisD> np
20:18:22 <calvinx> @msg f1 x = x >>= g >>= h >>= i >>= return
20:18:22 <lambdabot> Not enough privileges
20:18:27 <calvinx> @undo f1 x = x >>= g >>= h >>= i >>= return
20:18:27 <lambdabot> f1 x = x >>= g >>= h >>= i >>= return;
20:19:37 <Axman6> @do f1 x = x >>= g >>= h >>= i >>= return
20:19:37 <lambdabot> f1 x = do { a <- do { a <- do { a <- do { a <- x; g a}; h a}; i a}; return a};
20:19:41 <Axman6> ouch
20:19:56 <calvinx> o, that was what I was trying to do :D
20:19:59 <calvinx> thanks!
20:20:02 <EvanR> not even wrong
20:21:01 <calvinx> isn’t `do` supposed to allow a nicer syntax? converting `f1 x = x >>= g >>= h >>= i >>= return` into do syntax looks aweful.
20:21:09 <calvinx> *awful
20:21:22 <Axman6> that conversion is horrible
20:21:46 <EvanR> lol
20:21:50 <calvinx> so what’s the cleaner way to write `f1 x = x >>= g >>= h >>= i >>= return` in do notation?
20:22:08 <benzrf> calvinx: i wouldnt
20:22:11 <benzrf> that looks nice to me
20:22:12 <Axman6> it's nicer to write f1 x = x >>= g >>= h >>= i because x >>= return === x is one of the monad laws
20:22:29 <Axman6> I feel that >=> is useful here
20:22:29 <calvinx> yes, it looks nice to me too
20:22:36 * HeladoDeBrownie would use (>=>) there
20:22:41 <calvinx> but I am just trying to understand `do`.
20:22:46 <calvinx> so how would I do it?
20:23:05 <EvanR> calvinx: http://lpaste.net/118344
20:23:14 <Axman6> @do x >>= g >>= h >>= i
20:23:14 <lambdabot> do { a <- do { a <- do { a <- x; g a}; h a}; i a}
20:23:20 <HeladoDeBrownie> calvinx, the translation box tells you everything on the surface you need to know about do notation https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
20:23:22 <Axman6> jesus lambdabot, what's wrong with you
20:23:27 <calvinx> Ah...
20:23:36 <shachaf> Axman6: What output do you want?
20:23:40 <calvinx> Thanks EvanR
20:23:49 <HeladoDeBrownie> calvinx, use those equalities, starting with the right side, to get back to do notation
20:23:51 <EvanR> calvinx: your milage may vary, sometimes you do want to use >>= for simple stuff, sometimes you want >=>, and many times you throw in some fmaps
20:24:06 <Welkin> :T (>=>)
20:24:08 <Welkin> :t (>=>)
20:24:09 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
20:24:13 <Axman6> do { x' <- x; y <- g x'; z <- h y; i z }
20:24:26 <calvinx> then the `do` notation is pretty much similar if I re-write it using `let`-`in` ?
20:25:00 <calvinx> okay, I haven’t learnt about `>=>` yet.
20:25:08 <Welkin> it is monadic composition
20:25:16 <Welkin> compose two monad functions
20:25:18 <EvanR> calvinx: i added >=> http://lpaste.net/118344 though i may have done it wrong
20:25:43 <calvinx> holy sh*t!
20:25:46 <HeladoDeBrownie> "kleisli arrow" is a good term to know. it's something of this form: (Monad m) => a -> m b
20:25:46 <calvinx> That’s nice!
20:26:00 <HeladoDeBrownie> then (>=>) composes kleisli arrows, that's it
20:26:02 <Axman6> @pl f x = x >>= g >>= h >>= i
20:26:02 <lambdabot> f = (i =<<) . (h =<<) . (g =<<)
20:26:05 <Axman6> bleh
20:26:12 <EvanR> pl is pointless!
20:26:23 <shachaf> The monad laws are advanced.
20:26:26 <Axman6> :t \g h i -> let f x = x >>= g >>= h >>= i in f
20:26:27 <lambdabot> Monad m => (a2 -> m a1) -> (a1 -> m a) -> (a -> m b) -> m a2 -> m b
20:26:36 <shachaf> I wouldn't expect @do to use them.
20:26:51 <Axman6> :t \g h i -> let f = g >=> h >=> i in f
20:26:52 <lambdabot> Monad m => (a -> m b) -> (b -> m b1) -> (b1 -> m c) -> a -> m c
20:27:31 <Axman6> yesh, so you want f = g >=> h >=> i
20:27:55 <Welkin> HeladoDeBrownie: why is it called a Kleisli arrow?
20:28:01 <benzrf> night
20:28:14 <calvinx> man, I need to disable some preference on my colloquy IRC client. It changes one of the >=> into a devil icon.
20:28:24 <calvinx> all of the `>=>` into devil icon
20:28:27 <calvinx> lol
20:28:29 <HeladoDeBrownie> Welkin, i don't know, let's find out
20:28:39 <calvinx> I don’t see a devil only when there are infix quotes around it.
20:28:43 <cosban> oh
20:28:59 <HeladoDeBrownie> Welkin, https://en.wikipedia.org/wiki/Kleisli_category "Kleisli categories are named for the mathematician Heinrich Kleisli."
20:29:02 <calvinx> anyway, tea, I get it.
20:29:06 <calvinx> *yea, I get it
20:29:14 <EvanR> thats pretty bad
20:29:17 <calvinx> thakns for the pointer… I did not know of the Kleisli arrow.
20:29:42 <EvanR> >=> is Kleisli composition of "arrows in the kleisli category"
20:29:51 <NemesisD> i generally don't care much for the monadic operations that go left to right
20:30:06 <Lokathor> how oddly similar to kallisti
20:30:14 <HeladoDeBrownie> i'm not quite sure what kleisli did to get these named after him, but maybe with a little more searching the web it can be found
20:30:15 <NemesisD> i can't remember the last time i used >>= instead of =<< and i don't think i've ever used >=> , only <=<
20:30:41 <EvanR> guess that makes sense
20:31:00 <EvanR> f = i <=< h <=< g
20:31:11 <EvanR> (i <=< h <=< g) x
20:31:21 <NemesisD> because if it were not monadic you'd write it i . h . g
20:31:33 <NemesisD> so <=< becomes composition in monad land
20:31:47 <EvanR> is it the same for =<= ?
20:33:02 <calvinx> monadic composition. cool.
20:33:05 <Zemyla> So why are integers not kinds, requiring the implementation of Peano numbers?
20:33:28 <Axman6> Not sure about Integer, but Int is I believe
20:33:54 <jle`> >>= looks better aesthetically with lambda syntax
20:34:02 <jle`> also >>= helps you reason about effects in non-commutative monads
20:34:21 <deconfigured> GHC.Prim.Nat I think is
20:34:22 <jle`> that being said i use =<< more often
20:34:34 <HeladoDeBrownie> easy to use let or where binding with them
20:34:35 <NemesisD> i don't think i've encountered =<=
20:34:46 <deconfigured> s/Prim/TypeLits
20:34:56 <jle`> =<= is comonadic composition, and it's pretty nifty
20:35:04 <jle`> it lets you compose (w a -> a)'s
20:35:12 <jle`> er, (w a -> b)'s
20:35:21 <jle`> in the same way that <=< lets you compose (a -> m b)'s
20:35:39 <NemesisD> nice
20:35:54 <jle`> for data structures where (w a -> b) has a meaningful composition, it's p powerful
20:35:58 <Welkin> inside of do-blocks I like to use =<< instead of >>=
20:36:11 <jle`> yeah, =<< works well with do-block synax's <-
20:36:18 <jle`> from a visual standpoint :)
20:36:19 <Axman6> :t (=<=)
20:36:20 <lambdabot>     Not in scope: ‘=<=’
20:36:20 <lambdabot>     Perhaps you meant one of these:
20:36:20 <lambdabot>       ‘=<<’ (imported from Control.Monad.Writer),
20:36:20 <NemesisD> i've yet to use comonads in anger
20:36:20 <EvanR> p p p puppy power!
20:36:46 <EvanR> :t Control.Comonad.(=<=)
20:36:47 <lambdabot> Not in scope: data constructor ‘Control.Comonad’
20:36:47 <lambdabot>     Not in scope: ‘=<=’
20:36:47 <lambdabot>     Perhaps you meant one of these:
20:36:48 <HeladoDeBrownie> dunno if it was said already but (=<<) is nice to think of as equivalent to ($)
20:36:57 * hackagebot lifted-async 0.6.0 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.6.0 (MitsutoshiAoe)
20:37:12 <HeladoDeBrownie> (=<<) is to ($) as (<=<) is to (.)
20:37:24 <Pamelloes> how do you define a function with guards in a let statement?
20:37:28 <Hijiri> :t Control.Comonad.=<=
20:37:29 <lambdabot> parse error on input ‘Control.Comonad.=<=’
20:37:45 <Welkin> Pamelloes: the same way you do it otherwise
20:37:59 <deconfigured> :t Control.Comonad.(=<=)
20:38:00 <lambdabot> Not in scope: data constructor ‘Control.Comonad’
20:38:00 <lambdabot>     Not in scope: ‘=<=’
20:38:00 <lambdabot>     Perhaps you meant one of these:
20:38:03 <deconfigured> :(
20:38:07 <Pamelloes> Alright, I'll try indenting further then...
20:38:09 <Welkin> someFunction a b | a < b = something
20:38:37 <jle`> :t (Control.Comonad.=<=)
20:38:38 <lambdabot> Control.Comonad.Comonad w => (w b -> c) -> (w a -> b) -> w a -> c
20:38:43 <jle`> close :)
20:38:45 <deconfigured> !!!
20:38:58 <Axman6> I never understood that syntax
20:39:11 <Axman6> bracketing the infix function makes much more sense to me
20:39:20 <jle`> it's cause C.$ is the operator
20:39:21 <deconfigured> Does this work for most popular modules jle`?
20:39:27 <jle`> deconfigured: only modules on lambdabot
20:39:37 <deconfigured> ahh :)
20:39:53 <jle`> :t (C..)
20:39:53 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
20:40:17 <jle`> :t \f g -> f C.. g
20:40:18 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
20:40:37 <deconfigured> How do people write `makeLenses` etc. as a function, but using quasiquotes?
20:41:23 <deconfigured> I'm trying to make one that takes a (particularly formed) data type, but don't really know where to start
20:41:28 <jle`> oh i found a pl bug
20:41:36 <jle`> @pl \f x -> f --?? x
20:41:36 <lambdabot> const
20:41:44 <jle`> it's reading it as \f x -> f
20:41:54 <jle`> but (--??) is a valid identifier for an operator in haskell
20:42:05 <jle`> > let (--??) = (+) in 4 --?? 7
20:42:06 <lambdabot>  11
20:42:38 <jle`> haskell is weird
20:42:48 <Axman6> yeah
20:42:54 <Pamelloes> Can someone look at my code indentation? I can't for the life of me get it to compile :/
20:43:00 <lpaste> Pamelloes pasted “Indenting” at http://lpaste.net/118346
20:43:02 <deconfigured> I'm an idiot, nevermind ><
20:43:02 * Axman6 defined operator/// for C++
20:43:34 <deconfigured> Pamelloes: No nested wheres!
20:43:38 <Axman6> Pamelloes: I think where is indented too much in the first function
20:43:40 <deconfigured> (at least I think)
20:43:47 <deconfigured> ...language extension?
20:43:56 <jle`> Pamelloes: where is a part of declaration syntax
20:43:58 <Welkin> Pamelloes: you are using a let statement in the wrong place
20:44:14 <Welkin> `where let`
20:44:23 <deconfigured> Pamelloes: Imagine let and where being the same thing
20:44:31 <deconfigured> ...kinda
20:44:33 <jle`> (let ... in ...) is an expression
20:44:45 <jle`> so you always need an in if you want to use it as an expression
20:44:46 <Pamelloes> huh... I didn't notice that. I was moving some code around and dragged the let with the function :/
20:44:52 <Axman6> yeahyeah where let makes no sense, without an in anyway
20:45:10 <jle`> `where` is a part of the syntax for declrations
20:45:16 <jle`> for example, `foo x = blah where ...`
20:45:28 <Pamelloes> Removed the let and it worked! Thanks for the second set of eyes y'all :)
20:45:42 <jle`> (let ... in ...) is an expression, and has the same place in teh grammar as 5, True, [2,3,4] etc.
20:45:43 <jle`> np :)
20:46:18 <Welkin> jle`: but everything in haskell is an expression!
20:46:28 <jle`> :O
20:46:34 <jle`> not really :O
20:46:52 <jle`> i think you're thinking of lisp?
20:47:00 <jle`> and then even then i don't really know >_>
20:47:10 <HeladoDeBrownie> is (define x 1) an expression?
20:47:56 <HeladoDeBrownie> define: not allowed in an expression context in: (define x 1)
20:48:01 <HeladoDeBrownie> guess that means no
20:48:26 <jle`> now i know
20:48:50 <jle`> the top level of haskell is actually a giant declaration tho
20:49:02 <jle`> no naked expressions anywur
20:50:08 <jle`> so i guess technically it can be justified that everything in haskell is (a part of) a declaration
20:52:08 <EvanR> > foldl succ 0 [0..100]
20:52:10 <lambdabot>  Occurs check: cannot construct the infinite type: b ~ a0 -> b
20:52:10 <lambdabot>  Expected type: b -> a0 -> b
20:52:10 <lambdabot>    Actual type: b -> b
20:52:42 <EvanR> > foldl (const succ) 0 [0..100]
20:52:43 <lambdabot>  101
20:52:48 <EvanR> > foldl (const succ) 0 [0..100000]
20:52:49 <lambdabot>  100001
20:52:53 <EvanR> > foldl (const succ) 0 [0..1000000000]
20:52:59 <lambdabot>  mueval: ExitFailure 1
20:53:02 <EvanR> > foldl' (const succ) 0 [0..1000000000]
20:53:03 <Axman6> need moar succ
20:53:06 <lambdabot>  mueval-core: Time limit exceeded
20:53:10 <EvanR> shrug
20:53:26 <jle`> > iterate succ 0 !! 1000000000
20:53:31 <lambdabot>  mueval: ExitFailure 1
20:53:37 <jle`> i really wish there was a strict (!!) or strict cons somewhere
20:55:36 <jle`> > let xs (x:_) !!*!! 0 = x; (x:xs) !!*!! n = seq x (xs !!*!! (n-1))
20:55:37 <lambdabot>  <hint>:1:5: Parse error in pattern: xs
20:55:45 <jle`> @let (x:_) !!*!! 0 = x; (x:xs) !!*!! n = seq x (xs !!*!! (n-1))
20:55:46 <lambdabot>  Defined.
20:55:53 <jle`> > iterate succ 0 !!*!! 1000000000
20:55:57 <lambdabot>  mueval-core: Time limit exceeded
20:56:07 <jle`> did i do something wrong i probably did huh
20:56:41 <Zemyla> Hmm. Why is there no wrapper around the SIMD operations in GHC.Prim?
20:57:35 <EvanR> getting the most performance out of !! as possible
20:57:39 <EvanR> maximum overdrive
20:57:45 <Zemyla> Being able to add or multiply four elements at a time could be rather useful.
21:10:02 <calvinx> is it possible to “override” an existing Monad instance declaration?
21:10:26 <HeladoDeBrownie> calvinx, create a newtype, define the new instance on that. otherwise, not really
21:10:34 <Axman6> you could do it with a newtype
21:10:41 <calvinx> ok. I see.
21:11:01 <Axman6> newtype MyM a = MyM (Foo a)
21:11:02 <EvanR> > (Sum 2) <> (Sum 2)
21:11:03 <lambdabot>  Sum {getSum = 4}
21:11:11 <EvanR> > (Product 2) <> (Product 2)
21:11:12 <lambdabot>  Product {getProduct = 4}
21:11:17 <EvanR> totally different instance ;)
21:11:18 <Axman6> > Sum 2 <> 3 <> 4
21:11:20 <lambdabot>  Sum {getSum = 9}
21:11:26 <Axman6> > Product 2 <> 3 <> 4
21:11:27 <lambdabot>  Product {getProduct = 24}
21:11:37 <Axman6> yay for Num instances
21:11:54 <EvanR> instance Num Bool where
21:11:58 <EvanR> instance Num () where
21:12:00 <monochrom> > Sum 2 + 4
21:12:01 <lambdabot>  Sum {getSum = 6}
21:12:12 <Axman6> > Sum 2 * 3
21:12:13 <lambdabot>  Sum {getSum = 6}
21:15:02 <jle`> > Product 4 + 3
21:15:03 <lambdabot>  Product {getProduct = 7}
21:15:30 <vanila> haha
21:15:31 <vanila> :t (+)
21:15:32 <lambdabot> Num a => a -> a -> a
21:15:38 <jle`> > mconcat [3,5,1,9] :: Sum Int
21:15:39 <lambdabot>  Sum {getSum = 18}
21:15:42 <jle`> > mconcat [3,5,1,9] :: Product Int
21:15:44 <lambdabot>  Product {getProduct = 135}
21:15:46 <jle`> oh neat
21:17:32 <calvinx> Axman6: `newtype MyM a = MyM (Foo a)` is generically okay but what if I want to override the built-in list monad?
21:17:39 <calvinx> Is it even possible?
21:17:45 <Axman6> sure
21:17:46 <Zemyla> EvanR: I want instance Num DoubleX4, for instance,
21:18:08 <Axman6> neytype MyList a = MyList [a]; instance Monad MyList where ...
21:18:29 <calvinx> I see.
21:18:36 <jle`> i don't think there's another legal monad instance for []
21:18:44 <jle`> (total)
21:18:48 <calvinx> That solves the “illegal binding” problem when I tried declaring []
21:18:50 <Axman6> there's the ZipList version
21:18:57 <Axman6> I think
21:18:58 <vanila> > Product 4 * 3
21:18:58 <Axman6> wait
21:18:59 <lambdabot>  Product {getProduct = 12}
21:19:09 <jle`> you can't really make ziplist into a monad
21:20:15 <jle`> but that's just a "for what it's worth" thing, if you wanted to learn how to make new side-by-side monad instances for various types, then that works :)
21:20:27 <jle`> i actually can't think of any type that has more than one unique monad instance though
21:20:33 <jle`> this is something that has been bothering me for a long time
21:21:03 <jle`> functor instances are proven unique...applicative instances are more often than not non-unique...
21:21:13 <jle`> but Monad?
21:21:32 <Welkin> binary tree?
21:21:39 <jle`> what are the two instances?
21:21:43 <Welkin> oh
21:21:50 <Welkin> I am thinking of foldMap
21:22:00 * hackagebot monoid-subclasses 0.4.0.1 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.4.0.1 (MarioBlazevic)
21:22:28 <deconfigured> Hmm... so data constructors can only have parameters of kind *?
21:22:30 <EvanR> jle`: well, so far ive only seen one possible instance of comonad per type
21:22:43 <jle`> deconfigured: no, we can have higher kinded types :)
21:22:47 <Welkin> deconfigured: no, they can be anything
21:22:55 <deconfigured> o_0
21:22:57 <jle`> data MyData f a = MyData f a
21:23:04 <jle`> @let MyData f a = MyData (f a)
21:23:05 <lambdabot>  .L.hs:162:1: Not in scope: data constructor ‘MyData’
21:23:05 <lambdabot>  
21:23:05 <lambdabot>  .L.hs:162:14: Not in scope: data constructor ‘MyData’
21:23:05 <jle`> sorry
21:23:11 <jle`> @data MyData f a = MyData (f a)
21:23:11 <lambdabot> Unknown command, try @list
21:23:15 <jle`> @let data MyData f a = MyData (f a)
21:23:16 <lambdabot>  Defined.
21:23:18 <deconfigured> http://lpaste.net/118347
21:23:18 <jle`> :k MyData
21:23:20 <lambdabot> (k -> *) -> k -> *
21:23:21 <deconfigured> ):
21:23:23 <EvanR> oh dang, what about (s, a)
21:23:25 <Welkin> data Reader a = Reader { runReader :: e -> a }
21:23:31 <EvanR> could be writer or "dummy state" ...
21:24:05 <deconfigured> I have a constraint that `a ~ 'Edge foo bar`
21:24:09 <EvanR> i mean, s -> (s, a) could ignore the directive to update
21:24:26 <EvanR> may that breaks the laws somehow
21:24:39 <jle`> hm
21:25:05 <bananagram> is there a difference between M.fold and M.foldr?
21:25:09 <deconfigured> if you need to see the code let me know :)
21:25:35 <Welkin> bananagram: check the source or docs
21:25:44 <bananagram> hm, k
21:26:13 <Welkin> M.fold is deprecated
21:26:16 <Welkin> replaced by foldr
21:26:20 <Welkin> http://hackage.haskell.org/package/containers-0.5.6.2/docs/Data-Map.html#v:fold
21:26:22 <Zemyla> bananagram: IIRC, fold is deprecated.
21:26:30 <Zemyla> Yep.
21:26:37 <jle`> EvanR: i'll explore that
21:26:53 <bananagram> okay
21:26:56 <jle`> hm
21:27:00 * hackagebot picoparsec 0.1 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/picoparsec-0.1 (MarioBlazevic)
21:27:09 <jle`> EvanR: i think it'll break f >>= return = f
21:27:19 <jle`> er
21:27:31 <deconfigured> Welkin / jle' : but not kinds promoted from DataKinds, right?
21:28:28 <jle`> or return x >>= f = f, depending on what you want
21:28:41 <jle`> deconfigured: what are you asking about?
21:28:50 <jle`> oh
21:28:54 <jle`> you said data constructors
21:29:07 <jle`> data constructors do not take things with kinds
21:29:07 <deconfigured> jle`: data constructor with somethin like SSucc or SZero
21:29:19 <jle`> oh, promoted constructors with DataKinds
21:29:20 <edwardk> EvanR: (Int -> a) could use many monoids, ((+),0), ((*),1), (max,minBound), etc. for example
21:29:21 <EvanR> jle`: yep
21:29:27 <deconfigured> erm...
21:29:29 <deconfigured> shoot
21:29:42 <edwardk> EvanR: so there can be several comonads for a given 'type' in that sense
21:30:06 <jle`> edwardk: nice
21:30:15 <deconfigured> jle`: So the error said that the data constructor expected a type, but the type variable has a kind that's not * or something
21:30:23 <EvanR> edwardk: ok, maybe i only noticed in data types that didnt have anything but "structure" ...
21:30:33 <vanila> hey edwardk, can i ask a random q about pypy?
21:31:13 <edwardk> jle`: we can also get comonads that differ based on the context you expose, e.g. you can have one that shows you the tree below you, or only gives you access to the part of the stream to the right or the left of you (these latter two are causal and anti-causal streams)
21:31:28 <jle`> actually i've....done that
21:31:31 <jle`> now that i think about it
21:31:42 <jle`> still perplexed about monads tho
21:31:52 <jle`> hm
21:31:59 <jle`> oh, i guess we could extend that to (Int,)
21:32:17 <edwardk> vanila: you can ask. i don't know too much about pypy except some vague recollections of the design though, so i may not be able to give a very coherent answer. ;)
21:32:19 <jle`> so (Int,) has more than one Monad instance
21:32:40 <jle`> this answer is not very satisfying to me as a human though, i wonder what i was really looking for in the first place
21:32:49 <edwardk> jle`: yeah, we, by convention, tend to pick "Monoid m => Monad ((,) m) or the like
21:33:18 <EvanR> if its "parametric", that might be the key to not having many options
21:33:19 <edwardk> but Int has several potential monoids you could use, so you'd have to pick one
21:34:02 <jle`> yeah so even something like
21:34:13 <vanila> well really what im curious about is whether futamura projections are worth looking into for a real compiler? [pypy seems to be more about tracing jit - to very good effect, im skeptical whether it's really a projection]
21:34:24 <deconfigured> what "sorts" of monads also give rise to comonads? just predicates?
21:34:24 <jle`> data Two a = One a | Two a
21:34:27 <jle`> would have two Monad instance
21:34:44 <edwardk> jle`: sure because that is isomorphic to (,) Bool
21:34:49 <jle`> yeah
21:35:01 <jle`> i'm just saying cause like, that's a "totally parameterized" type
21:35:18 <jle`> er, parametric?
21:35:23 <EvanR> i tried to implement comonad for One a | Two a, and i could only figure out one valid Comonad
21:35:25 <jle`> so it's slightly more satisfying than (Int,)
21:35:32 <edwardk> vanila: i'm rather dubious.
21:35:41 <jle`> EvanR: what is it?
21:35:59 <edwardk> EvanR: you can use (&&),True     or (||),False
21:36:01 <vanila> oh noo :D
21:36:27 <jle`> i finally found my first type with multiple unique Monad instances after all these years of searching
21:36:40 <EvanR> duplicate (One x) = One (One x)
21:36:47 <EvanR> duplicate (Two x) = Two (Two x)
21:37:04 <shachaf> edwardk: Are you sure you're not thinking of Monad?
21:37:27 <shachaf> Oh, maybe I stepped in in the middle of a conversation here.
21:37:30 <edwardk> shachaf: oh, sorry, i misread him. yeah that one is completely determined
21:37:35 <vanila> to the extent I understand the theory of it, I've been trying to think how you'd pull it off and really it just seems like loads of extra work and you can't target something really low level?
21:37:40 <shachaf> Oh, or not. :-)
21:37:47 <jle`> oh
21:38:04 <jle`> instance Comonad ((,)e) where
21:38:13 <edwardk> EvanR: the situation for (,) a  and (->) a   kinda flips when you go from looking for monads and comonads.
21:38:48 <jle`> instance Monoid m => Comonad ((->)m) where
21:38:49 <EvanR> so theres only one (r ->) monad?
21:38:53 <edwardk> instance Monoid e => Comonad ((->) e) matches up with instance Monoid e => Monad ((,) e)
21:38:55 <jle`> this is an interesting correspondence
21:39:01 <jle`> is there some duality here?
21:39:03 <edwardk> EvanR: correct
21:39:18 <edwardk> jle`: yes, but its a pain in the ass to fully realize
21:39:24 <jle`> darn
21:39:47 <jle`> i guess that's one revelation for the dy
21:39:50 <jle`> *day
21:40:27 <vanila> not sure what I should look into now instead
21:40:34 <edwardk> ultimately most of this comes from the fact that the (,) e -| (->) e adjunction is the only adjunction from hask <-> hask. everything other such adjunction looks like just a special case.
21:41:53 <jle`> i know another adjunction but i'm never telling anyone
21:42:36 <edwardk> vanila: IIRC luke palmer wrote some articles a few years back talking a great deal about full/complete laziness and futamura-style specialization, talking about how to remove the overhead of layers of interpreters
21:43:00 <edwardk> that is the closest i think you'll get and the technical problems with such full laziness designs i think kill any practical attempt at realizing the design
21:43:19 <vanila> ah thanks! I will look into that
21:43:49 <tommyd> hello haskellers
21:44:00 <s00pcan_> I'm no haskeller, I just use xmonad
21:44:16 <tommyd> i don't get what you mean XD
21:44:29 <jle`> i am haskeller
21:44:32 <tommyd> only 3 weeks into my haskell journey
21:44:34 <s00pcan_> well, I've written one config file in haskell.  That's about it
21:44:45 <edwardk> vanila: i personally think that it is a rat hole, but you're welcome to dive in and see if you can come up with some cheese ;)
21:44:47 <Cale> tommyd: Hello!
21:45:01 <s00pcan_> it's seen few changes since april 2012, but those that I have done have been well worth the time I put into it
21:45:05 <Cale> tommyd: Feel free to ask any questions you might have
21:45:14 <EvanR> haha rat hole vs rabbit hole
21:45:19 <jle`> or feel free to just talk about haskell :D
21:45:35 <tommyd> well, I love thinking about haskell, so I suppose I'll enjoy talking about it!
21:45:42 <vanila> hehe
21:45:44 <tommyd> no one at my university is currently studying it as well, that I know of
21:45:57 <vanila> its fun reading about and i'd love to see something work but yeah, I don't have too high hopes
21:46:13 <s00pcan_> wish I'd went to one of these real schools
21:46:25 <vanila> its very possible that there's some key insights I just overlooked or whatever
21:46:29 <edwardk> s00pcan_: fwiw- so do i =P
21:46:40 <tommyd> Cale: thanks!
21:47:02 <tommyd> do you want to see a function that blows my mind?
21:47:23 <edwardk> s00pcan_: haskell wasn't a topic even known to any of my professors back in college, at all. not even on the radar.
21:48:08 <edwardk> not 'hey i'm not too familiar with it', but just blank stares intermixed with people thinking I'd said "pascal" ;)
21:48:10 <Cale> Sure :)
21:48:46 <EvanR> pas'kal ?
21:49:05 <s00pcan_> chili and movie time for me
21:49:17 <EvanR> thanks, reminds me i need to make dinner
21:49:33 <s00pcan> EvanR: computers are way more interesting than food.  It's a daily problem for me
21:49:54 <EvanR> evolution is against us there
21:50:01 <EvanR> until you can download a sandwich
21:51:21 <Axman6> you wouldn't download a sandwich
21:51:28 <s00pcan> M-x sandwich
21:51:40 <HeladoDeBrownie> if you think i wouldn't download a sandwich you don't understand people
21:51:46 <tommyd> nthFib :: Int -> Integer
21:51:51 <tommyd> nthFib = (fibs !!) 	
21:51:53 <tommyd> where fibs = 0:1:(zipWith (+) fibs (tail fibs))
21:52:01 <tommyd> that function can calculate the 10000 fib number in like
21:52:04 <tommyd> less than a second
21:52:18 <s00pcan> a black and white movie set in the future?  I guess I'll roll with that
21:52:32 <tommyd> the naive recursive fib function takes like 5 mins to calculate ~35th fib number
21:52:50 <Axman6> HeladoDeBrownie: it was a anti-piracy referencer
21:52:52 <tommyd> and that one does the 10000th one in less than a second
21:52:54 <Axman6> -r
21:53:01 <Cale> Well, yeah, that's mostly the difference between an exponential and linear time algorithm
21:53:26 <matematikaadit> @letlpaste 116935
21:53:27 <lambdabot>  Defined.
21:53:34 <tommyd> yeah, but I never had seen a linear time fib function
21:53:37 <Axman6> naive fib is O(fib n), which is sort of exponential
21:53:48 <HeladoDeBrownie> Axman6, oh i know
21:53:49 <matematikaadit> > fib 10000
21:53:51 <lambdabot>  3364476487643178326662161200510754331030214846068006390656476997468008144216...
21:54:00 <tommyd> i was ignorant of such a solution until I started studying functional programming
21:54:10 <s00pcan> fib 10
21:54:17 <s00pcan> oh, I'm new here
21:54:18 <tommyd> and it excites me more than I want it to XD
21:54:30 <Cale> tommyd: Well, how would you do it by hand?
21:54:42 <Axman6> > let fib n = go n 0 1 where go 0 a _ = a; go n !a !b = go (n-1) b (a+b) in fib 100 -- essentially the same as the zipWith version
21:54:43 <tommyd> i know right? I feel stupid I hadn't thought of it
21:54:43 <lambdabot>  354224848179261915075
21:54:45 <s00pcan> generally I just switch to an active channel and then talk about whatever I want, then somehow make it to the topic
21:54:48 <Cale> The algorithm you'd use by hand is probably better than exponential :)
21:54:53 <kadoban> There is a sub-linear time algorithm for fibs as well, which is pretty neat.
21:55:17 <tommyd> a sub linear time...
21:55:18 <tommyd> like
21:55:20 <Cale> Of course, we're all being a bit lax about our notion of "time" here
21:55:21 <tommyd> constant... ?
21:55:26 <Axman6> yeah
21:55:33 <bitemyapp> jle`: wait what
21:55:36 <s00pcan> Cale: time?  Isn't it now?
21:55:39 <bitemyapp> jle`: what has two monads?
21:55:39 <kadoban> tommyd: Logarithmic
21:55:42 <tommyd> or just linear divided by a contant
21:55:46 <Axman6> it uses the golden ratio and exponentiation
21:55:48 <jle`> data Two a = One a | Two a
21:55:49 <tommyd> oh right...
21:55:52 <Cale> The space required for the integers involved grow linearly with n, so the complexity of addition gets hard to ignore :)
21:55:55 <bitemyapp> jle`: ...fuck.
21:55:59 <tommyd> I forgot about that step
21:56:02 <jle`> ikr
21:56:19 <bitemyapp> jle`: it makes perfect sense that it's a Monad, but...fuck.
21:56:27 <Axman6> it's not actually constant time though, since it needs high precision to produce correct results
21:56:32 <bitemyapp> jle`: two bits of structure, "f", a exists in both. Damn.
21:56:39 <jle`> yeah
21:56:48 <tommyd> jle`: what is that?
21:56:49 <bitemyapp> jle`: that is awesome.
21:56:54 <jle`> idk if it's cheating or not
21:56:57 <jle`> i'm going to say it counts
21:56:58 <kadoban> Axman6: No, that algorithm, the floating point exponentation one, is totally bogus. It's useless.
21:56:59 <bitemyapp> seems fair to me.
21:57:00 <jle`> maybe it's not really "unique"
21:57:03 <bitemyapp> it's not like it's an absurd type.
21:57:05 <kadoban> Axman6: There's a real one too.
21:57:11 <jle`> tommyd: a type with more than one unique Monad instance
21:57:13 <bitemyapp> jle`: what kind of type would have an ap and a return that were equal?
21:57:23 <s00pcan> so, any regulars in here? I don't know what's up yet
21:57:23 <Axman6> so you end up with something like O((n log n) (log n)) if you use things like Integer and Ratio
21:57:25 <jle`> i don't know
21:57:33 <jle`> i don't even know if it's possible
21:57:33 <Axman6> kadoban: oh?
21:58:03 <tommyd> i don't know what a Monad Instance is yet, I'm almost to that chapter!
21:58:10 <jle`> :D
21:58:15 <levi> s00pcan: Haskell is up. :)
21:58:18 <bitemyapp> jle`: it'd have to be function typed or something wouldn't it?
21:58:18 <kadoban> Axman6: I think I have a writeup of it bookmarked somewhere, sec. The floating point one is clearly bogus though, for any N big enough for it to actually be noticably faster, precision losses give you the wrong answer.
21:58:23 <Axman6> s00pcan: I don't understand the question, most of us are regulars here
21:58:29 <jle`> bitemyapp: i don't even know
21:58:46 <EvanR> bitemyapp: its just (Bool, a)
21:59:03 <EvanR> Writer Bool
21:59:49 <bitemyapp> EvanR: wait what
21:59:58 <EvanR> the One a | Two a
22:00:01 <jle`> yeah, that's the form i originally saw it in
22:00:08 <bitemyapp> EvanR: oh right.
22:00:13 <kadoban> Axman6: http://fedelebron.com/fast-modular-fibonacci   the one under "Using linear algebra" is the one I'm talking about specifically.
22:00:17 <bitemyapp> EvanR: yeah but One a | Two a is normal form.
22:00:23 <EvanR> and theres (apparently?) only two associative operations for Bool
22:00:26 <s00pcan> oh, I see, this movie is doing artsy-color usage
22:00:37 <jle`> well there are two Monoids
22:01:03 <Axman6> kadoban: oh, the matrix version? it's not practically sub linear afaict because the multiplications become n log n quickly
22:01:17 <jle`> i sort of still feel like it's cheating now tho
22:01:29 <jle`> because the two instances are 'isomorphic' over a swapped type
22:01:30 <jle`> idk
22:02:03 <EvanR> are the monoids for Int isomorphic too?
22:02:07 <Axman6> hmm, maybe it is
22:02:17 <jle`> they are for non-zero ints
22:02:20 <jle`> er, positive ints
22:02:52 <jle`> oh
22:02:52 <kadoban> Axman6: Hmm, I don't think that's quite correct, let's see...
22:03:00 <jle`> i'm thinking about Reals, sorry
22:03:32 <kadoban> Axman6: I mean it's definitely not just  O(lg n), but I think it's still sublinear
22:06:04 <calvinx> I don’t quite understand why my “custom list monad” doesn’t load correctly - http://lpaste.net/118352
22:06:05 <s00pcan> "the giver"  - this is similar to "divergent"
22:11:05 <jle`> calvinx: return (MyList x) = MyList [x]
22:11:12 <jle`> what is the type of return supposed to be?
22:11:54 <calvinx> according to the error message, `a -> MyList a`
22:11:58 <jle`> mhm
22:12:01 <jle`> :t return
22:12:02 <lambdabot> Monad m => a -> m a
22:12:02 * hackagebot options 1.2.1.1 - A powerful and easy-to-use command-line option parser.  http://hackage.haskell.org/package/options-1.2.1.1 (JohnMillikin)
22:12:34 <calvinx> ok, so line 4 should be `    return x = MyList x`
22:12:39 <jle`> almost
22:12:50 <calvinx> not correct?
22:12:56 <johnw> hmm.. I wonder how options will compare to optparse-applicative
22:13:29 <jle`> what is the type of MyList, the data constructor?
22:13:56 <calvinx> MyList :: [a] -> MyList a
22:14:05 <jle`> yes
22:14:14 <jle`> so return takes an `a`
22:14:19 <jle`> so you want to pass to MyList a ...?
22:16:43 <EvanR> somehow im not surprised "pushing let inside constructor" is confusing google
22:16:45 <calvinx> mmmm… lol. I don’t know what to pass to `MyList a`
22:16:59 <jle`> heh, i meant that as
22:17:05 <BigBoy> guys can u help me a bit?
22:17:08 <jle`> you want to pass to `MyList` a...?
22:17:16 <jle`> you want to pass it an [a]
22:17:19 <jle`> but x is `a`
22:17:26 <jle`> BigBoy: don't ask to ask, just ask :D
22:17:34 <BigBoy> does any1 here have the bootp tool from weird solutions
22:17:51 <BigBoy> im trying to find the tftp sever ip address of my isp
22:17:52 <calvinx> oic… so it’s `    return x = MyList [x]` ?
22:18:12 <jle`> calvinx: ask the compiler :)
22:18:14 <johnw> BigBoy: this channel is for discussions relating to the Haskell programming langauge
22:18:27 <BigBoy> ooopppss sorry
22:18:30 <BigBoy> wrong channel
22:18:34 <calvinx> yes indeed! line 4 error goes away
22:19:12 <calvinx> man, this is so confusing.
22:19:49 <calvinx> so for the bind function, it is still complaining about wrong match of types.
22:20:03 <jle`> are you sure you want to be pattern matching on a singleton list?
22:20:14 <jle`> MyList [x] ...
22:20:16 <calvinx> It is expecting `(>>=) :: MyList a -> (a -> MyList b) -> MyList b`
22:20:24 <jle`> is your monad only defined on lists with one element?
22:21:01 <calvinx> I intend for it act like the default list
22:21:06 <jle`> hm
22:21:19 <jle`> then i don't think you need to match on different sizes of lists
22:21:19 <calvinx> I am “rewriting” to understand why a list construct is a monad.
22:21:23 <jle`> you can just match on all lists
22:21:29 <jle`> MyList xs ...
22:21:51 <jle`> unless you wanted to really do it from "scratch"
22:21:57 <jle`> then you can match on MyList (x:xs) and MyList []
22:22:05 <jle`> but i don't think you'll gain much from matching on MyList [x]
22:22:53 <jle`> in any case if you match on MyList [x] then you'll have to also provide the cases for MyList [] and MyList (x:xs)
22:23:34 <calvinx> So I can’t simply use concatMap to emulate list map and concat behavior?
22:23:40 <jle`> you can
22:24:03 <jle`> but i'm saying, line 4 starts with `    (MyList [x]) >>=`
22:24:30 <jle`> but it'd be simpler if you just did `MyList xs >>= ...`
22:24:40 <calvinx> oic.
22:25:05 <calvinx> ok, assuming `MyList xs >>= ...`
22:25:12 <jle`> you know the difference between `foo xs = ...` and `foo [x] = ...`, right?
22:25:45 <calvinx> in pattern matching, `xs` refers to a series of char and `[x]` refers to just  1 char in a list
22:25:48 <jle`> yeah
22:25:54 <jle`> well
22:26:08 <jle`> [x] matches only the list with one single elemnt
22:26:28 <jle`> > let foo [x] = x + 1 in foo [1]
22:26:30 <lambdabot>  2
22:26:31 <jle`> > let foo [x] = x + 1 in foo [1,2,3]
22:26:32 <lambdabot>  *Exception: <interactive>:3:5-19: Non-exhaustive patterns in function foo
22:27:06 <calvinx> I see.
22:27:22 <calvinx> So I have to declare `xs` and not `x`.
22:28:03 <jle`> MyList xs >>= f = ???
22:28:09 <jle`> what type should ??? be?
22:28:11 <jle`> what type is f?
22:28:15 <jle`> what type is xs?
22:28:41 <calvinx> `f` should take the form ` (a -> MyList b)`
22:28:57 <calvinx> `???` should take the form ` MyList b`
22:29:32 <jle`> what about xs?
22:29:52 <calvinx> `MyList xs` should take the form `MyList a`
22:30:00 <jle`> yes, but what about xs?
22:30:02 <calvinx> that’s what `>>=` is expecting
22:30:04 <calvinx> o.
22:30:21 <calvinx> `xs` should be `a` ?
22:30:56 <calvinx> I mean
22:31:01 <calvinx> should be `[a]`
22:32:29 <calvinx> but how does knowing these type signatures help me?
22:32:57 <calvinx> does that mean I should declare `f` with a `where` ?
22:34:35 <EvanR> the types are the shapes of the holes of your "some assembly required" ikea application, the type signatures are the instructions that you are too manly enough to read ;)
22:34:52 <calvinx> hehe.
22:36:00 <EvanR> in many languages, those instructions dont exist
22:36:15 <EvanR> but the types are still there, giving you the middle finger at runtime
22:37:28 <calvinx> yup… but I don’t yet understand what the error is trying to convince me to do...
22:38:00 <EvanR> sometimes its hard to read the error messages
22:38:25 <calvinx> Using `    (MyList xs) >>= f = concatMap f (MyList xs)`, error says `Expected type: a -> [b0]   Actual type: a -> MyList b`
22:38:41 <calvinx> so what am I supposed to do to change `f` so that it accepts my type?
22:38:57 <EvanR> yeah, so you put a MyList b instead of a regular list, it should also tell you what expression thats happening in
22:39:15 <Zemyla> @src unsafePerformIO
22:39:16 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
22:39:34 <Zemyla> @hoogle unsafePerformIO
22:39:35 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
22:39:35 <lambdabot> Foreign unsafePerformIO :: IO a -> a
22:40:20 <calvinx> but how is a `MyList b` represented?
22:40:44 <EvanR> point is theres a contradiction, MyList vs [ ]
22:40:49 <Zemyla> :t print
22:40:50 <lambdabot> Show a => a -> IO ()
22:40:55 <EvanR> its should be one of the other, i dont know which
22:41:52 <EvanR> calvinx: whats the type of concatMap
22:42:13 <calvinx> o wow, I didn’t think about asking this question.
22:42:31 <calvinx> `concatMap :: (a -> [b]) -> [a] -> [b]`
22:42:41 <EvanR> it doesnt accept MyList
22:42:45 <EvanR> but it should be easy to fix
22:47:19 <calvinx> so I tried this `    (MyList xs) >>= f = MyList [concatMap f xs]` and it seems to get me closer.
22:47:47 <calvinx> it’s still complaining that my `f` is the wrong type.
22:47:53 <EvanR> visually it makes sense that MyList >>= f = MyList, if this is a monad
22:48:23 <calvinx> I see.
22:48:31 <calvinx> but `f` ? :(
22:48:36 <EvanR> but the result is a singleton list?
22:49:11 <Axman6> what are the []'s doing around the concatMap?
22:49:15 <EvanR> as far as f goes, it has type (a -> MyList b)
22:49:42 <calvinx> ok so there’s nothing wrong with my `f`
22:49:44 <Axman6> I often find that people new to Haskell have to add random []'s to expressions because lists have []'
22:49:46 <EvanR> the result of >>= shouldnt be a complex nesting of lists and mylists
22:49:51 <calvinx> I am still not getting the right hand side correct
22:50:30 <calvinx> Axman6: haha, yes, you can coerce something into a list in python with []
22:50:58 <Axman6> there's no such ting as coercion in haskell (we'll ignore unsafeCoerce)
22:51:02 <Axman6> thing*
22:51:17 <ThreeOfEight> well there is coerce
22:51:39 <EvanR> calvinx: MyList (concatMap f xs) ?
22:51:51 <EvanR> now whats the error
22:52:16 <calvinx> `Couldn't match type ‘MyList b’ with ‘[b]’`
22:52:27 <calvinx> `Expected type: a -> [b]`
22:52:34 <calvinx> `Actual type: a -> MyList`
22:52:36 <ThreeOfEight> and there is Data.Typeable.cast
22:52:48 <EvanR> calvinx: it should tell you exactly where
22:53:14 <calvinx> it’s marking the error at f
22:53:22 <EvanR> which f
22:53:32 <calvinx> the `f` on the right hand side....
22:54:37 <EvanR> so you might want to define a concatMap for MyLists
22:54:43 <Axman6> calvinx: what do you have on the right hand side
22:54:52 <calvinx> `    (MyList xs) >>= f = MyList (concatMap f xs)`
22:55:13 <Axman6> oh right, because f :: a -> MyList b not (a -> [b])
22:55:17 <calvinx> oic, so I need to declare a special function
22:55:24 <calvinx> with a `where` ?
22:55:51 <Axman6> well, a function of type MyList a -> [a] might help you
22:56:04 <Axman6> (which should be trivial to write)
22:56:23 <calvinx> o man I am beginning to learn to see the lego pieces.
22:56:38 <Hijiri> careful where you step, though
22:56:47 <calvinx> a -> MyList b -> [b] will be equals to a -> [b]
22:57:04 * hackagebot chell 0.4.0.1 - A simple and intuitive library for automated testing.  http://hackage.haskell.org/package/chell-0.4.0.1 (JohnMillikin)
22:57:18 <calvinx> so the `f` on the right hand side needs to be a function of type `MyList a -> [a]` as Axman6 said.
22:57:44 <Axman6> I'm not sure I said that, but a function with that type will be very useful to you
22:57:47 <Axman6> :t concatMap
22:57:48 <lambdabot> (a -> [b]) -> [a] -> [b]
22:58:10 <Axman6> remember that f has type a -> MyList b, but you need a -> [b] to be able to use concatMap
22:58:38 <Axman6> so if you have a -> MyList b and MyList a -> [a], can you make a -> [b]?
22:59:04 <calvinx> yes?
22:59:08 <Axman6> (the a's here are different a's, so maybe a -> MyList b and MyList b -> [b] will makr things clearer)
22:59:25 <calvinx> yes.
22:59:26 <EvanR> the type of >>=, specialized for you situation is: (>>=) :: MyList a -> (a -> MyList b) -> MyList b, thats the big picture
22:59:39 <EvanR> thats reminds you of your f's type
22:59:44 <EvanR> and what the result needs to be
23:00:39 <EvanR> :t flip concatMap
23:00:40 <lambdabot> [a] -> (a -> [b]) -> [b]
23:13:00 <calvinx> hmmm. still no idea. so what do I need to do to the `f` on the right hand side so it will accept `a -> MyList b`
23:13:30 <EvanR> the f is a a -> MyList b
23:14:13 <calvinx> yes, sorry. how do I make it accept `a -> [b]` I mean.
23:14:35 <EvanR> you can compose it with a MyList b -> [b] function
23:16:11 <Danavu> do you use vim? if so are there any plugins you use that you find handy for haskell?
23:16:35 <bernalex> Danavu: several
23:17:01 <Danavu> bernalex: mind sharing your vimrc?
23:17:33 <bernalex> Danavu: it's not that interesting. I use default settings for several of the plugins. check out ghcmod-vim, haskell-mode and vim2hs.
23:17:48 <bernalex> & neco-ghc
23:18:32 <Danavu> cool, thanks man
23:18:42 <Zemyla> Rrgh. I want to calculate the exponent of a Fixed value, but it's not being accurate at all.
23:19:21 <EvanR> exp and sqrt arent built in, unfortunately
23:19:30 <adas> i think haskell-mode is for emacs
23:19:30 <sgronblo> Danavu: https://github.com/begriffs/haskell-vim-now I just stumbled on to this
23:19:39 <bernalex> adas: it's for vim too
23:19:40 <EvanR> for Pico that would be pretty cool
23:19:49 <EvanR> Zemyla: taylor series?
23:19:52 <Zemyla> EvanR: That's why I'm writing functions to do so.
23:19:54 <Danavu> adas: https://github.com/lukerandall/haskellmode-vim
23:19:59 <sgronblo> i dont know if i would use this kind of "all in one" solution but i think it could be good for learning about plugins to add separately.
23:20:10 <EvanR> Zemyla: are you still sure you dont just want to stick with Doubles
23:20:19 <bernalex> ghc-mod is also originally for emacs, I think
23:20:58 <adas> cool. thanks
23:21:21 <bernalex> sgronblo: it's quite irritating IMO. there's *a lot* of plug-in bundles for haskell. seems 9/10 haskell plug-ins that are posted around are just bundles of other plug-ins with a default conf.
23:21:40 <bernalex> it's a bit amusing that haskell users seem so fond of something so incredibly anti-modular.
23:21:41 <Danavu> hmm sgronblo I already have an autocomplete engine and having another plugin that wants to do that would be.. irritating
23:22:04 * hackagebot dbus 0.10.9.1 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-0.10.9.1 (JohnMillikin)
23:22:11 <Danavu> especially if all it did was complete words in the buffer (which most autocomplete engines already do)
23:22:14 <bernalex> Danavu: check out hasktags for haskell ctags for vim.
23:22:24 <sgronblo> If I was working on something bigger I would try to see if I could haskforce working in Intellij nowadays
23:22:31 <calvinx> EvanR: `toList` has a type signature `t a -> [a]`
23:23:13 <EvanR> calvinx: yeah, that works if your type if Foldable
23:23:15 <EvanR> is
23:23:27 <Zemyla> The problem is that my function is accurate but slow on integer values, but when I multiply them by the exp of the fractional part, I lose precision.
23:23:59 <EvanR> calvinx: but your thing is so simple, you need to understand how to write the simple version before you can implement Foldable ;)
23:24:11 <calvinx> LOL
23:24:24 <EvanR> MyList b -> [b]
23:24:35 <calvinx> so there’s a straightforward solution that I cannot see… :/
23:24:43 <EvanR> to this sub problem yeah
23:24:56 <calvinx> I am still stuck at `    (MyList xs) >>= f = MyList (concatMap f xs)`….
23:25:37 <EvanR> you want to concatMap the f over the xs, but f returns the wrong type
23:25:46 <calvinx> yes
23:25:54 <EvanR> f :: a -> MyList b
23:25:57 <EvanR> you want h
23:26:01 <EvanR> h :: a -> [b]
23:26:03 <EvanR> you need g
23:26:16 <EvanR> h :: MyList b -> [b]
23:26:22 <EvanR> ...
23:26:26 <EvanR> g :: MyList b -> [b]
23:26:37 <EvanR> bad keystroke
23:26:43 <calvinx> yes
23:26:55 <EvanR> h = f . g
23:27:04 <Zemyla> EvanR: I can tell you right now that exp 100, to 9 decimal places, is 26,881,171,418,161,354,484,126,255,515,800,135,873,611,118.773 741 922.
23:27:06 <calvinx> so to achieve h, I need a g, and combine them like f . g
23:27:19 <EvanR> yeah
23:27:24 <Zemyla> O've verified this with Wolfram Alpha.
23:27:26 <EvanR> :t (.)
23:27:27 <lambdabot> (b -> c) -> (a -> b) -> a -> c
23:27:52 <EvanR> calvinx:  well g . f, i had it backwards.
23:28:10 <EvanR> write MyList b -> [b]
23:28:10 <calvinx> o, right. right.
23:28:19 <calvinx> so now we have `    (MyList xs) >>= f = MyList (concatMap f .g xs)`
23:28:24 <calvinx> and we have to declare g ?
23:28:40 <EvanR> concatMap (g . f) xs
23:29:20 <EvanR> just write g somewhere else in the file
23:29:25 <EvanR> including the type sig
23:29:44 <calvinx> my gosh, that worked...
23:30:00 <calvinx> http://lpaste.net/118355
23:30:25 <calvinx> I swear I have a splitting headache now. But I do understand how we arrived at this solution...
23:30:48 <EvanR> you reimplemented Monad for a newtype over lists as the same monad
23:31:03 <EvanR> definitely took the hard way on that one ;)
23:31:15 <calvinx> yes, I am re-implementing list
23:31:27 <calvinx> So as to understand how “bind” works in a Monad instance definition.
23:31:27 <EvanR> if you had some different behavior this would have been warranted
23:31:41 <EvanR> or, really reimplementing all the list operations would be another challenge
23:31:49 <EvanR> but using existing list stuff just made it confusing ;)
23:31:50 <calvinx> :(
23:32:05 <calvinx> very very educational from my point-of-view
23:32:25 <calvinx> I am beginning to appreciate the value of using type signatures to figure things out
23:32:37 <EvanR> well, after all that, do you know what >>= does?
23:32:56 <calvinx> haha. yea. it’s a kind of unwrapper
23:33:21 <calvinx> it magically causes “f” to be defined where f is the function that unwraps a monad.
23:33:22 <EvanR> no, the >>= you just implemented, what does it do when applied to stuff
23:33:46 <Zemyla> Actually, hmm.
23:34:17 <calvinx> it executes the concatMap functionality on my custom MyList monad?
23:34:39 <EvanR> yeah, just making sure you get how that works ;)
23:34:51 <calvinx> crazy stuff
23:34:54 <EvanR> > [1, 2, 3] >> id
23:34:55 <lambdabot>  Couldn't match expected type ‘[b]’ with actual type ‘a1 -> a1’
23:35:06 <EvanR> or that i do
23:35:07 <calvinx> mind melting abstraction
23:35:17 <EvanR> > [1, 2, 3] >> (:[])
23:35:18 <lambdabot>  Couldn't match expected type ‘[b]’ with actual type ‘a1 -> [a1]’
23:35:21 <EvanR> > [1, 2, 3] >>= (:[])
23:35:22 <lambdabot>  [1,2,3]
23:35:48 <EvanR> > [1, 2, 3] >>= (\x -> [x, x])
23:35:50 <lambdabot>  [1,1,2,2,3,3]
23:36:04 <EvanR> calvinx: concatMap isnt even very abstract, is what im getting at
23:36:58 <calvinx> yea, it’s not in the scheme of things
23:37:15 <EvanR> > [(True, 1), (False, 2), (True, 3)] >>= (\(x,y) -> if x then [y,y] else [])
23:37:16 <lambdabot>  [1,1,3,3]
23:37:39 <Danavu> tfw just realized haskell logo comes from >>=
23:37:48 <Danavu> my noob is showing..
23:37:51 <EvanR> calvinx: just trying to downplay "finally getting monads"
23:38:10 <calvinx> yes.
23:38:31 <calvinx> o damn, I didn’t know that either, Danavu.
23:38:42 <calvinx> >>=  haskell logo. nice.
23:38:52 <Danavu> I mean it totally looks like it, I'm assuming that's the case
23:38:58 <EvanR> λ=
23:38:59 <calvinx> Is it?
23:39:03 <calvinx> o.
23:39:07 <calvinx> hahaha. lambda =
23:39:08 <EvanR> >λ=
23:39:30 <EvanR> the logo is cool, but now everyone thinks haskell is about monads (the old logo was worse though
23:39:34 <Danavu> (i'm on day 2 of haskell-anything)
23:39:42 <calvinx> what does >λ= mean in plain english?
23:39:56 <EvanR> its "ascii" rendering of the haskell logo
23:40:17 <calvinx> what i mean is - is there a mathematical meaning to that series of characters?
23:40:20 <EvanR> you cant have letters in operators
23:40:24 <EvanR> no
23:40:32 <calvinx> ok.
23:40:43 <EvanR> λ is a variable
23:40:57 <calvinx> isn’t it lambda?
23:41:04 <EvanR> yeah
23:41:20 <EvanR> > let λ = 1 in λ + λ
23:41:21 <lambdabot>  2
23:41:44 <calvinx> :)
23:42:01 <matematikaadit> > (λx -> x + 1 ) 2
23:42:02 <lambdabot>  Pattern syntax in expression context: λx -> x + 1
23:42:08 <Zemyla> > let π = 3 in pi - π
23:42:09 <lambdabot>  0.14159265358979312
23:42:26 <Zemyla> > let Π = 3 in pi - Π
23:42:27 <lambdabot>  Not in scope: data constructor ‘Π’Not in scope: data constructor ‘Π’
23:42:43 <calvinx> nice lambdabot is a smart cookie.
23:42:45 <EvanR> > (pi :: CReal) - (realToFrac pi)
23:42:46 <lambdabot>  0.0000000000000001224646799147353177226066
23:42:52 <matematikaadit> @botsnack
23:42:52 <lambdabot> :)
23:45:22 <calvinx> so, a general question — is it common for seasoned haskell programmers to rely on monads for various computation when writing real world programs?
23:45:34 <EvanR> yeah
23:45:47 <calvinx> every monad has a specific computation “purpose'.
23:46:00 <calvinx> so, haskell programmers will construct their own monads for specific computation goals?
23:46:37 <EvanR> well for small stuff the standard ones are good
23:46:47 <calvinx> from standard libraries.
23:47:03 <calvinx> off your head, what are some useful ones from hackage?
23:47:08 <EvanR> > Right 3 >> Right True >> Left "wrongggg" >> Right ()
23:47:09 <lambdabot>  Left "wrongggg"
23:47:42 <calvinx> didn’t understand this. What’s with the Right and Left?
23:47:51 <EvanR> data Either a b = Left a | Right b
23:48:01 <EvanR> instance Monad (Either e) where
23:48:31 <EvanR>   return = Right
23:48:49 <EvanR>   (Left e) >>= _ = Left e
23:49:06 <EvanR>   (Right x) >>= f = f x
23:49:28 <EvanR> calvinx: this is a computation that may fail with an error of type e
23:49:53 <calvinx> ok, I see. but what’s the `>>` and why does it end with `()`
23:50:05 <EvanR> > Right 3 >> Right True >> Left "wrongggg" >> Right "riiighhttt"
23:50:06 <lambdabot>  Left "wrongggg"
23:50:16 <EvanR> () is irrelevant
23:50:24 <calvinx> shouldn’t it be `>>=` instead of `>>` ?
23:50:34 <EvanR> @src (>>)
23:50:35 <lambdabot> m >> k = m >>= \_ -> k
23:51:15 <calvinx> o, it’s a simpler form of `>>=`
23:51:16 <EvanR> >> is when you dont care about the output of the previous step
23:51:29 <calvinx> I see
23:51:29 <Javran> is there any document about how to create and config cabal benchmark targets?
23:51:41 <EvanR> in the case of Left "wrongg" there *is* no output
23:51:54 <EvanR> the computation aborts
23:52:06 <EvanR> otherwise i was just lazy
23:52:27 <calvinx> > Right 3 >> Right True >> Left "wrongggg" >> Right
23:52:28 <lambdabot>  Couldn't match expected type ‘Data.Either.Either
23:52:28 <lambdabot>                                  [GHC.Types.Char] b’
23:52:28 <lambdabot>              with actual type ‘b0 -> Data.Either.Either a1 b0’
23:52:41 <calvinx> o, we do need a `()` at the end
23:52:47 <calvinx> > Right 3 >> Right True >> Left "wrongggg" >> Right ()
23:52:48 <lambdabot>  Left "wrongggg"
23:52:49 <EvanR> you need Right something
23:52:57 <calvinx> Ah....
23:53:12 <EvanR> or return something
23:53:34 <calvinx> > Right 3 >> Right True >> Left "wrongggg" >> Right () >> return
23:53:35 <lambdabot>  Couldn't match expected type ‘Data.Either.Either
23:53:35 <lambdabot>                                  [GHC.Types.Char] b’
23:53:35 <lambdabot>              with actual type ‘a1 -> m0 a1’
23:53:44 <EvanR> :t return
23:53:44 <calvinx> > Right 3 >> Right True >> Left "wrongggg" >> return ()
23:53:45 <lambdabot> Monad m => a -> m a
23:53:46 <lambdabot>  Left "wrongggg"
23:53:55 <calvinx> > Right 3 >> Right True >> Left "wrongggg" >> Right () >> return ()
23:53:57 <lambdabot>  Left "wrongggg"
23:54:04 <EvanR> > Right 3 >> Right True >> Right "riiight" >> return ()
23:54:05 <lambdabot>  Right ()
23:54:43 <calvinx> I see, because of `return = Right`
23:55:09 <EvanR> @src ()
23:55:09 <lambdabot> data () = ()
23:55:42 <calvinx> actually, because of `(Right x) >>= f = f x`
23:56:02 <calvinx> `return = Right` is just the wrapper statement
23:56:07 <calvinx> *definition
23:56:27 <EvanR> remember, the last "statement" in your sequence there was really \_ -> return ()
23:56:57 <EvanR> so >>= and return both mattered
23:58:51 <jTT_> hey there, I am trying to find a method to decode a ByteString that is encoded in Big5. Does anyone know a way?
23:58:59 <EvanR> calvinx: (r -> a), (w,a), s -> (s,a), Maybe a, Either e a are the basic array of monads
