00:01:08 <solatis> no in in #haskell is stupid, for they either know what they don't know, or know what others don't know
00:01:15 <solatis> *noone
00:01:43 <funfunctor> man!!! I have {-# OPTIONS_HADDOCK hide, prune, ignore-exports #-} at the top of the respective files and haddock still says coverage is 0%
00:02:27 <Pamelloes> Is there a way to calculate the bit distance between two strings?
00:02:45 <shachaf> What's a bit distance between strings?
00:03:07 <EvanR> 0 if they are equal, 1 otherwise
00:03:13 <Pamelloes> shachaf: Hamming distance
00:03:28 <solatis> i thought -1, 0, or 1 /
00:03:29 <solatis> ?
00:03:47 <solatis> ah wait
00:03:52 <EvanR> FileNotFound, 0, or 1
00:03:57 <EvanR> a bit
00:04:23 <dmwit> ?djinn join :: (b -> m b) -> (m (m a) -> (m a -> m a) -> m a) -> m (m a) -> m a
00:04:24 <lambdabot> Cannot parse command
00:04:32 <dmwit> ?djinn (b -> m b) -> (m (m a) -> (m a -> m a) -> m a) -> m (m a) -> m a
00:04:33 <lambdabot> f _ a b = a b (\ c -> c)
00:04:50 <shachaf> That doesn't answer the question.
00:05:02 <shachaf> What's the bit distance between «á» and «á»?
00:05:39 <Pamelloes> Convert the characters to UTF-8 binary representation and then calculate the hamming distance between the two bit strings.
00:06:13 <funfunctor> key word of metric maybe useful to use here
00:06:23 <HeladoDeBrownie> does unicode already have a concept of separate characters?
00:06:37 <dmwit> I think shachaf is being unnecessarily snarky, since the answer is "no" basically any way you slice it.
00:06:43 <funfunctor> there are a few ways to define what metric is important to you, the Hamming metric is one such example of many
00:06:55 <EvanR> or "yes" any way you slice it
00:06:58 <shachaf> dmwit: I think the answer is yes given the additional information Pamelloes just provided.
00:07:27 <EvanR> hamming distance could be interpreted several ways
00:07:30 <dmwit> Well. Nothing convenient. Though of course it's a computable problem so there's a way.
00:07:37 <Pamelloes> Alright.
00:07:44 <Pamelloes> I guess I'll figure something out...
00:07:55 <shachaf> Pamelloes said "strings" before and "UTF-8 binary representation" now.
00:08:03 <funfunctor> you could consider the distance between two bit strings as when equal or not equal as the discrete metric
00:08:27 <EvanR> write a function to calculate the answer for a Word8, then sumMap that over the ByteString
00:08:33 <dmwit> What's the hamming distance between two bitstrings of different length?
00:08:38 * hackagebot wai-middleware-hmac-client 0.1.0.0 - Wai HMAC Authentication Middleware Client  http://hackage.haskell.org/package/wai-middleware-hmac-client-0.1.0.0 (ChristopherReichert)
00:08:38 * hackagebot xss-sanitize 0.3.5.5 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.5.5 (GregWeber)
00:08:58 <shachaf> I suppose that's another issue, yes.
00:09:02 <EvanR> two word8s, then sumzipwith
00:09:25 <shachaf> What is this for?
00:10:26 <funfunctor> the Damerau–Levenshtein metric is useful for spell checkers
00:10:42 <jle`> good ol levenshtein
00:10:43 <Pamelloes> shachaf: I have an output from a program. I'm trying to calculate its fitness for genetic algorithms by calculating a distance between the given output and the desired output.
00:10:51 <dmwit> Pamelloes: You might like http://hackage.haskell.org/package/Diff
00:11:05 <Pamelloes> dmwit: I'll look into it
00:11:19 <dmwit> No need to bother with UTF-8. Just compare the Strings directly.
00:12:33 <funfunctor> Pamelloes: do you want a measure/score of /how/ different the strings are? i.e. fitness
00:13:04 <Pamelloes> funfunctor: Yes. Preferably on a bitwise level in UTF-8
00:14:17 <dmwit> a priori that sounds like a strange constraint to put on your fitness function
00:14:20 <jle`> hm. why are you working on the string/text level then?  you can't just work directly with bits and bytestrings?
00:15:16 <funfunctor> Pamelloes: ok, fitness functions are a tentative topic but it maybe worth taking some time thinking about it a bit. For example Sørensen–Dice coefficient is useful to be less senstive to outliers
00:16:03 <funfunctor> there are all kinds of weird and wonderful ways to think about the fitness function
00:16:45 <Pamelloes> funfunctor: I know. I'm trying to throw together the bare minimum here to simply get my program up and running.
00:17:51 <funfunctor> Pamelloes: ok here is a basic one. Have your two strings in binary form, xor them and then sum of the resulting array of bits to give a score
00:18:13 <dmwit> That seems like a terrible metric.
00:18:19 <Pamelloes> funfunctor: Sounds good :)
00:18:25 <dmwit> One extra character stuck somewhere in the middle and you're screwed.
00:18:27 <funfunctor> dmwit: it is horrible
00:18:48 <dmwit> Also, it is basically what he originally asked for, so if you've got implementation hints I'm sure he's listening.
00:18:56 <funfunctor> dmwit: but its so basic that it should get someone started with something
00:19:00 <Pamelloes> dmwit: It's amazing how, as it gets later at night, your quality standards decrease....
00:19:32 <Pamelloes> At this point, I just want something runnable as a proof of concept to see if everything works.
00:19:43 <funfunctor> Pamelloes: no, time makes systems degrade <g>
00:22:33 <funfunctor> Pamelloes: for your bookmarks http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance
00:22:45 <Pamelloes> Thanks :)
00:22:52 <funfunctor> your welcome
00:23:17 <SharpGAF> Pamelloes: You could just use string length if you just want *something*
00:23:30 <SharpGAF> And it would be easy to verify that your fitness function was working, at least :)
00:24:01 <EvanR> length minus length?
00:24:22 <SharpGAF> EvanR: abs ?
00:24:25 <SharpGAF> Wait, that's silly.
00:24:31 <EvanR> wouldnt have the property that x - y == 0 implies x == y
00:24:47 <EvanR> yeah abs
00:43:34 * hackagebot machinecell 1.3.0 - Arrow based stream transducers  http://hackage.haskell.org/package/machinecell-1.3.0 (HidenoriAzuma)
01:07:50 <TenDecigrams> Hello there!
01:11:42 <Pamelloes> Should my program be using 20gb of ram and rising?
01:11:50 <Pamelloes> I think I might've screwed something up.....
01:18:36 * hackagebot pgdl 6.6 - pgdownloader  http://hackage.haskell.org/package/pgdl-6.6 (sifmelcara)
01:28:36 * hackagebot hledger-diff 0.2.0.2 - Compares the transactions in two ledger files.  http://hackage.haskell.org/package/hledger-diff-0.2.0.2 (gebner)
01:28:38 * hackagebot nagios-perfdata 0.2.2 - Parse Nagios performance data.  http://hackage.haskell.org/package/nagios-perfdata-0.2.2 (fractalcat)
01:35:16 <favetelinguis> What are these cabal messages saying me and what can i do to make them go away? http://lpaste.net/119171
01:37:24 <favetelinguis> the probelm is that i want to install Agda but the install cant find the correct version of alex even thogh i have installed it with cabal
01:37:33 <favetelinguis> my system is only reporting the old version
01:42:00 <hvr> favetelinguis: is the new alex in the PATH?
01:42:19 <favetelinguis>  i think i fixed it, i deleted the old symlink and reinstalled
01:42:40 <hvr> cabal with -v2 or -v3 should tell you which path to alex it used
01:47:15 <favetelinguis> hvr: yu mean just write cabal -v2? that is not a recognized command
01:47:18 <lpaste> chaosmasttter revised “transformFreeT”: “No title” at http://lpaste.net/119154
01:48:09 <favetelinguis> alex -v reports the correct version but cabal install finds the old version
02:00:50 <hvr> favetelinguis: rather something like "cabal install -v2"
02:03:21 <favetelinguis> hvr: no the new alex is not in the path, i thought cabal automatically put new installs in the path? how can i add the new alex to the path?
02:03:45 <dramforever> favetelinguis: are you using windows or linux?
02:03:52 <favetelinguis> osx
02:03:53 <dramforever> s/linux/unix-ish/
02:03:59 <dramforever> okay that's unix-ish
02:04:05 <temoto> I'm still enhancing quickcheck regex generator and I wonder if it's possible to stop QuickCheck.listOf upon meeting certain Gen a.
02:04:10 <temoto> So I have say f :: Gen a   f = Q.listOf1 "abc"    and it successfully generates random strings of these 3 chars, now I want to make sure that if c is present, there is no other character after it.
02:04:24 <temoto> But in reality it's not listOf1 "abc", it's listOf1 g  and g is very complicated. I think maybe some kind of monadic   fail   could help?
02:04:25 <dramforever> favetelinguis: type "echo $PATH" (without quotes) in the terminal
02:05:17 <favetelinguis> dramforever: http://lpaste.net/119174
02:05:56 <dramforever> favetelinguis: IIRC cabal installs binaries into ~/.cabal/bin
02:06:10 <dramforever> so you *prepend* it to your path. do you know how to do that?
02:06:30 <favetelinguis> dramforever: no sorry i do not
02:06:46 <hvr> favetelinguis: maybe this helps: http://stackoverflow.com/questions/22859015/path-is-not-registering-the-updated-cabal-version
02:07:08 <temoto> If it's not possible with some kind of monadic fail magic (which currently stops whole program for me), I'd like to attach some state to   QuickCheck.Gen a   in the most simple way.
02:07:41 <dramforever> temoto: iirc there's a (==>) in quickcheck
02:07:49 * hvr wonders why there isn't an easily found cabal-$PATH FAQ 
02:09:36 <dramforever> favetelinguis: sorry..seems that osx is different from linux
02:10:09 <dramforever> the stackoverflow one is correct
02:11:21 <temoto> dramforever, there is (==>) :: Testable prop => Bool -> prop -> Property
02:11:27 <temoto> Implication for properties: The resulting property holds if the first argument is False (in which case the test case is discarded), or if the given property holds.
02:11:39 <temoto> To be honest, I don't understand how to use it.
02:11:53 <dramforever> temoto: isValidTestSet ==> testCase
02:12:01 <saep> temoto: I would generate a list containing 'a' and 'b' and then draw a random float [0,1) and append a 'c' with some probabitly that is appropriate.
02:12:59 <dramforever> temoto: well...if saep's solution is okay that's definitely better
02:13:13 <temoto> saep that's why I mention that in reality it's not abc but really complex and I want to continue writing complex rules while allowing to stop at any point.
02:13:16 <dramforever> but when it gets complicated, you have to resort to ==>
02:13:38 * hackagebot c2hs 0.22.1 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.22.1 (IanRoss)
02:14:06 <dramforever> temoto: oh wait, so you know how to check if a test case is correct
02:14:13 <dramforever> but don't know how to generate it
02:14:18 <temoto> yes
02:14:57 <dramforever> temoto: how likely is a randomly generated test case to satisfy?
02:15:18 <temoto> Another way to say it, I was thinking is not Gen String, but instead   Gen (Either String String)    and then at certain point "output"     Right "c"     and some external processor takes values but only continues on Left x.
02:15:57 <temoto> ^ this all is string generator
02:16:42 <dramforever> wait a sec, Gen is a monad
02:16:57 <dramforever> so you can use StateT s Gen
02:17:09 <temoto> dramforever, to think of it, I can't provide any statistics on how likely it's satisfiable.
02:17:34 <dramforever> temoto: what if you use StateT FooState Gen?
02:17:39 <dramforever> do you know what I mean?
02:18:23 <temoto> dramforever, yeah StateT sounds great. Could you point to good example of using it for beginners?
02:19:04 <vanila> you should see the "Monad Transformers Step By Step" to  learn how t use monad transformers
02:19:13 <dramforever> temoto: ^
02:19:22 <temoto> I'm familiar with overall concept of state transformer but haven't really used it.
02:19:28 <temoto> Thanks.
02:22:16 <temoto> How does the Either idea sound?
02:22:28 <temoto> just curious
02:23:20 <EvanR> :t (:*:)
02:23:22 <lambdabot> Not in scope: data constructor ‘:*:’
02:23:25 <EvanR> :k (:*:)
02:23:26 <lambdabot>     Not in scope: type constructor or class ‘:*:’
02:23:27 <lambdabot>     Perhaps you meant ‘:~:’ (imported from Data.Typeable)
02:28:55 <favetelinguis> I dont get it, I do have the correct version of alex installed on the system but cabal only finds the old one. So i put the whole path to alex in my path and that resolved the problem, but now i need to do the same thing for cpphs, why is it not enogh to put Haskel/Library/bin on the path where the correct symlinks are located? Do i need to put every package on my path?
02:29:15 <favetelinguis> this is y path now when i got alex working http://lpaste.net/119175
02:29:43 <dramforever> favetelinguis: weird...Haskell/Library/bin should work
02:29:58 <dramforever> you sure binaries are not going there?
02:31:00 <favetelinguis> dramforever: what do you mean? im a noob
02:31:22 <dramforever> favetelinguis: do you see the binaries in Haskell/Library/bin?
02:33:39 <favetelinguis> no only symlinks pointing to the binaries
02:34:01 <dramforever> favetelinguis: that will work too
02:34:35 <dramforever> favetelinguis: wait..I think there's a problem:
02:34:50 <favetelinguis> dramforever: this is how i created the cpps symlink  ln -s /Users/henriklarsson/Library/Haskell/ghc-7.6.3/lib/cpphs-1.18.8/bin/cpphs cpphs
02:35:48 <dramforever> no...I think there should be a place where cabal automatically puts binaries into
02:36:13 <dramforever> how about searching for "alex" in Library/Haskell
02:37:08 <temoto> @src ErrorT
02:37:08 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
02:37:17 <temoto> @hoogle ErrorT
02:37:19 <lambdabot> Control.Monad.Error ErrorT :: m (Either e a) -> ErrorT e a
02:37:19 <lambdabot> Control.Monad.Trans.Error ErrorT :: m (Either e a) -> ErrorT e m a
02:37:19 <lambdabot> Control.Monad.Trans.Error newtype ErrorT e m a
02:37:34 <favetelinguis> dramforever: here is where alex is located /Users/henriklarsson/Library/Haskell/ghc-7.6.3/lib/alex-3.1.4/bin
02:38:29 <dramforever> favetelinguis: anywhere else? maybe searching for alex in your user dir?
02:38:35 <dramforever> I mean, /Users/henriklarsson/
02:39:21 <favetelinguis> dramforever: btw when i try cabal install -v2 v3 i get no cabal file found if that is an issue
02:39:41 <dramforever> favetelinguis: I don't know
03:22:19 <ocramz> hoi room
03:22:59 <ruuns> hi :)
03:24:55 <ocramz> hi @ruuns, what's up?
03:25:58 <ocramz> I'm reading ekmett's "conquering folds" tutorial: https://www.fpcomplete.com/user/edwardk/conquering-folds
03:56:05 <vektor> So.... apparently, the compiler ignores certain errors when others are present. For example, if there
03:56:29 <vektor> are syntax errors, no type checking will be done. Which of theses levels are there?
04:01:09 <quchen> When you can't lex the source, you cannot parse it. When you cannot parse the tokens, then you cannot build the syntax tree. When you don't have a syntax tree, you cannot typecheck it.
04:07:27 <tasker> I'm parsing some JSON, and a certain field may be present, or be the empty string. I'd like to parse this as Maybe TheField. Is there some easy way of doing so ?
04:08:26 <tasker> (Oh, I'm using Aeson)
04:09:06 <quchen> Yes.
04:09:20 <quchen> It's in the docs.
04:09:55 <quchen> (.:) allows you to create a "Parser a". What would the parser type of an optional field be?
04:10:43 <tasker> Maybe a, however, it isn't not present - it's the empty string.
04:10:49 <Lokathor> first thought: try it and see; second thought: maybe whatever type it needs to have to typecheck (like how read works)
04:11:41 <quchen> Parser is a Monad, i.e. you can do things like "parseMyStuff >>= \result -> if foo result then … else …"
04:12:12 <tasker> Ah, true. Ok I'll have a go.
04:13:03 <biglama> to use writeFile from Data.ByteString, I have to do a qualified import of Data.ByteString.Lazy
04:13:18 <biglama> importing Data.ByteString does not work, why ?
04:14:00 <dmwit> because Prelude.writeFile exists
04:15:11 <biglama> dmwit: yeah, but I don't understant why writeFile is in Data.ByteString.Lazy instead of Data.ByteString
04:15:59 <dmwit> It is in Data.ByteString.
04:19:01 <lpaste> biglama pasted “Importing writeFile” at http://lpaste.net/119176
04:19:29 <biglama> dmwit: can you explain why importing Data.ByteString gives this error message ?
04:21:17 <dmwit> Yes. There are two different kinds of ByteString, appropriate for different uses.
04:21:33 <dmwit> Both of their unqualified names are ByteString, but they are defined in different modules.
04:21:58 <dmwit> There are strict and lazy bytestrings, and almost all operations have strict and lazy variants.
04:22:16 <dmwit> writeFile is no exception; and here you are trying to use the strict writeFile with a lazy ByteString.
04:22:28 <biglama> i see, thanks !
04:28:04 <raek> is there some guide that explains how Gen, Protperty, Prop and Testable relate to each other in QuickCheck?
04:28:35 <raek> ...other than the type signatures in the API reference, and the source code :-)
04:37:41 <vektor> quchen: Thanks, I guess that'll do for now. I'll just have to keep my eyes open for errors that are neither of those.
05:03:54 <nadirs> Hello! If I need to write Arbitrary instances for my data types for testing purposes, is FlexibleInstances the only way to do it?
05:05:23 <saep> nadirs: Probably not. :-)
05:05:54 <nadirs> saep: ok. Is that considered an acceptable way?
05:06:15 <nadirs> I don't want to add a QuickCheck dependency on the main lib
05:06:56 <saep> Well, I only have warnings about orphaned instances if I don't declare them in the main lib.
05:08:09 <saep> Why do you need FlexibleInstances in the first place? And I cannot judge whether it is an acceptable way.
05:10:54 <benmachine> FlexibleInstances is usually OK
05:11:30 <benmachine> whether or not you need your Instances to be Flexible depends on the form of the type
05:12:03 <benmachine> a non-Flexible Instance is basically an instance for a type constructor applied to some type variables
05:12:11 <nadirs> The fact is I get a warning when I try to write an instance for a data type defined in another module
05:12:14 <benmachine> T a b c ....
05:12:50 <benmachine> nadirs: interesting. there are a few ways around this
05:13:06 <benmachine> but the simplest is to have ghc-options: -fno-warn-orphans on your testsuite :)
05:13:07 <nadirs> ok, I think I made a mistake, it's not requiring FlexibleInstances
05:13:22 <nadirs> benmachine: seems perfect
05:13:36 <nadirs> thank you
05:13:59 <benmachine> orphans are bad if you're defining a library, but if you're writing a test executable they aren't such a big deal
05:14:23 <benmachine> if you control the type you're declaraing the instance for, it's basically safe
05:15:59 <nadirs> and when I define both new type classes and instances that are meant to be in the library, orphaned instances should be avoided?
05:16:51 <nadirs> ok, so I should avoid it when there is a risk for other people to import the data type definition without its class instances
05:18:12 <nadirs> if I expose a module that imports both the data types and their instances, while hiding the fact they're separate, it's kind of safe
05:22:59 <_deepfire> hmm, a GenericPretty instance doesn't seem to be automatically derivable for HashMaps
05:23:19 <_deepfire> is there some simple recourse for it?
05:24:42 <_deepfire> this is a bit weird, since GenericPretty claims to be "just as show", and show prints HashMap values just fine
05:31:06 <AshyIsMe> ok, finally making the time to install nix
05:31:10 <AshyIsMe> the package manager
05:31:50 <_deepfire> AshyIsMe, not nixos proper yet? : -)
05:32:14 <AshyIsMe> not yet, probably never as a main os
05:32:15 <temoto> genIdentifier :: Gen String = do { f <- Q.elements letterChars; rest <- Q.listOf $ Q.elements allChars; return $ f : rest }     to remove do/return I'd have to use liftM2 (:)   or something similar?
05:32:24 <AshyIsMe> osx is too shiny
05:34:36 <temoto> oh god it atually worked
05:43:26 <temoto> @src unwords
05:43:27 <lambdabot> unwords [] = ""
05:43:27 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
05:43:45 <rcharles> @src concatMap
05:43:46 <lambdabot> concatMap f = foldr ((++) . f) []
05:47:40 <Lokathor> https://twitter.com/parametricity what an interesting twitter feed
05:50:08 <vanila> Lokathor, its bad
05:50:47 <Lokathor> well it feels more like a joke than a thing to be taken seriously
05:55:28 <MP2E> if it's a joke, i don't get the punchline :x
05:57:30 <Dodek> hmm, GeneralizedNewtypeDeriving doesn't seem to work with MonadBaseControl
05:58:04 <Dodek> ah, but there is default implementation
05:58:22 <funfunctor> Hi, so I am fairly sure this is a Haddock bug now.. Haddock is printing coverage information despite source being in other-modules and having a bunch of attributes to ignore them. What's the deal with that?
05:58:54 <funfunctor> oh hey vanila
05:59:01 <vanila> hey
05:59:17 <funfunctor> I just saw you pop up there and all
05:59:28 <funfunctor> hey do you happen to know much about Haddock?
05:59:34 <vanila> ive nver used haddock
06:01:45 <funfunctor> vanila: do you happen to know much about cabal being able to pass "OPTIONS_HADDOCK" rather than putting it in every file?
06:02:19 <vanila> sorry
06:03:31 <Taneb> Are unboxed vectors significantly quicker than boxed?
06:05:16 <quchen> Taneb: From what I've heard: yes.
06:05:47 <quchen> Taneb: If you're strict in the fields anyway, I can't think of a reason not to use unboxed vectors, so it's basically free performance.
06:06:20 <Taneb> quchen, the main reason I'm not right now is that I'm using a very do-notation style
06:06:38 <quchen> Use ST and you can use a *very* do-notation style :-þ
06:07:24 <statusfailed> Has anyone used this fancy schmancy new records library in anger? (http://nikita-volkov.github.io/record/)
06:09:39 <quchen> In anger?
06:09:56 <quchen> I don't use Haskell in anger. Sometimes I use it against it though.
06:11:49 <statusfailed> quchen: :-)
06:26:28 <HugoDaniel> can't upload to hackage
06:26:37 <HugoDaniel> is it down ?
06:29:00 * hackagebot iso639 0.1.0.3 - ISO-639-1 language codes  http://hackage.haskell.org/package/iso639-0.1.0.3 (HugoGomes)
06:34:00 * hackagebot hpc-coveralls 0.8.2 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.8.2 (killy971)
06:37:32 <funfunctor> how can I tell Haddock /not/ to hyperlink a type?
06:38:09 <funfunctor> I keep getting "Warning: LibBladeRF.LibBladeRF: could not find link destinations for: Bindings.LibBladeRF.Types.C'bladerf" rubbish
06:51:22 <lpaste> zimablue pasted “failing mean implementation” at http://lpaste.net/119183
06:52:05 <zimablue> whoops sorry didn't realise that would post to chat, please ignore
06:52:11 <zimablue> first time ^^
06:53:40 <Dodek> hey, i have newtype Foo a = Foo { unFoo :: ReaderT Env IO a }, and i'm trying to define instance MonadBaseControl IO for Foo
06:53:59 <Dodek> should be easy, since there's already instance for ReaderT Env IO
06:54:28 <Clint> just derive it automatically
06:54:28 <Dodek> but i'm having lots of trouble with using defaultLiftBaseWith and defaultRestoreM
06:54:34 <Dodek> Clint: won't work, sadly.
06:54:46 <jophish> I've written bindings for the Assimp library, and it would be cool to get them onto Hackage. There is already a package for these bindings but it's incomplete and hasn't been updated since it was uploaded 4 years ago
06:54:59 <Dodek> Main.hs:49:53:
06:54:59 <Dodek>     Can't make a derived instance of ‘MonadBaseControl IO Stateless’
06:54:59 <Dodek>       (even with cunning newtype deriving):
06:55:00 <Dodek>       the class has associated types
06:59:27 <jophish> In fact, it even fails to build on hackage
07:00:03 <boothead> is there any way to work with a type within a forall? I have some code that transforms a Fold (from Control.Foldl) to fold over internal FoldableWithIndex's, but I can't figure out how to specify that the seed value of the fold has tye f i x where x is the same as the the existential x from the original fold
07:01:35 <RaceCondition> how is data Obj = forall a. (Show a) => Obj a implemented at runtime? every Obj a value holds a vtable reference to the type class instance?
07:02:01 <sinelaw> unlikely
07:03:10 <RaceCondition> [Obj "hello", Obj 123, Obj True]  <-- how is that represented in memory then?
07:03:54 <mniip> "implemented at runtime"?
07:04:12 <Dodek> http://stackoverflow.com/questions/28137838/creating-monadbasecontrol-instance-for-newtype
07:05:23 <mniip> RaceCondition, that's not a valid type declaration
07:05:40 <mniip> oh wait
07:05:41 <mniip> it is
07:05:43 <RaceCondition> mniip: it runs just fine
07:06:12 <RaceCondition> http://lpaste.net/119185
07:08:21 <mniip> RaceCondition, https://ghc.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification
07:08:24 <mniip> that should explain it
07:11:51 <boothead> what are my options generalizing from a use of Map.empty if I want an empty FoldableWithIndex? Is there an equivalent?
07:13:27 <RaceCondition> mniip: ok, I'll try that
07:15:32 <biglama> just done my very real-world project in haskell (converting xml file to json file)
07:15:45 <biglama> starting out was hard but i'm beginning to grasp the power of haskell :)
07:16:47 <boothead> biglama, good work :-)
07:18:55 <biglama> i'm quite happy even though it was not very difficult :p
07:20:23 <funfunctor> good god, this is so annoying! How the hell do you tell haddock /not/ to hyperlink a type
07:24:32 <RaceCondition> mniip: I'm not sure the page answers the question how does GHC represent Obj at runtime
07:25:23 <arw> funfunctor: throw in some confusing unicode character that doesn't become visible but confuses haddock?
07:28:16 <mniip> ‮
07:28:18 <mniip> er
07:28:19 <profil> @pl \x -> [1+x]
07:28:19 <lambdabot> return . (1 +)
07:28:19 <mniip> U+202e
07:28:59 <mniip> profil, (:[]) . (1+) works too
07:28:59 <piyush-kurur> RaceCondition: I think any existentially quantified constructor should carry arround the corresponding dictionary
07:29:22 <RaceCondition> piyush-kurur: like a vtable?
07:29:27 <profil> @pl \x -> [Just x]
07:29:27 <lambdabot> return . Just
07:29:46 <piyush-kurur> In this case it looks like the Obj constructor expects the argument to be an instance of Show
07:30:05 <piyush-kurur> So it is able to use that dictionary to "show" the object.
07:30:29 <RaceCondition> by "dictionary" you mean a "vtable" to a type class instance?
07:30:58 <piyush-kurur> The technical word is dictionary
07:31:30 <RaceCondition> piyush-kurur: only using "vtable" to draw a parallel to the subtyped OO concept
07:31:37 <profil> mniip: nice, but which is more clear? I find "\x -> [Wrapper x]" to be more understandable than "(:[]) . Wrapper"
07:31:57 <mniip> that's a legit questoin
07:32:12 <mniip> I find the lambda more understandable than both
07:32:21 <profil> yeah, exactly :)
07:33:02 <mniip> and unless there's a type signature nearby, it would take me maybe a good minute to realize what the hell is return doing here
07:33:08 <hodapp> :t (:[])
07:33:09 <lambdabot> a -> [a]
07:33:28 <profil> mniip: its a global function (or what its called) so it has a type signature :)
07:33:48 <piyush-kurur> RaceCondition: I think it is similar but haskell types are slightly different from Objects
07:33:48 <profil> mniip: it even has a haddock description
07:34:04 <RaceCondition> piyush-kurur: I know
07:34:44 <hodapp> piyush-kurur: thank god for that.
07:35:06 <mniip> profil, I expect return around an IO monad
07:35:18 <mniip> or maybe some other monad
07:35:30 <mniip> but the list monad isn't something I'd think about in an instant
07:35:54 <piyush-kurur> The subtype analogy for example breaks down when you have say a multiparam type class
07:36:37 <piyush-kurur> by the way a single param type class does indeed look like a subtype
07:37:53 <piyush-kurur> When one says say Show a. one nice way of thinking of it is indeed to say that this type is generic but supports "show"-ing
07:39:14 <mniip> don't use type constraints in type declarations D:
07:42:35 <boothead> GAH - anyone know how i can bring back a minimised app in xmonad? I just pressed C-x C-z by mistake
07:47:29 <Dodek> hmm, when i use a lens in a Reader context, `view' uses MonadReader class from mtl library, while i want to use one from transformes
07:47:31 <MP2E> not sure boothead, might have to ask in #xmonad. xmonad-contrib has functions for minimizing/restoring windows but you'd have to have it bound to keys in your ~/.xmonad/xmonad.hs. Doesn't really help with this case
07:47:37 <Dodek> how does it work? how to do it?
07:59:07 <boothead> MP2E, thanks, ended up killing it - should really get in the habit of using emacsclient I guess :-)
08:10:09 <SrPx> Why GHC is giving me this error? Could not deduce (Unbox (UV.Vector (V3 Float))) -- I thought both V3 and UV.Vector had unbox instances.
08:10:21 <SrPx> (UV.Vector == Unboxed vector)
08:10:30 <SrPx> V3 is from linear. weird?
08:26:35 <SrPx> does UV.Vector not provide an unbox instance of itself??
08:35:24 <koomi> SrPx: no, unboxed vectors don't have a constant size
08:48:42 <lifter> When I do "cabal install --only-dependencies", it doesn't install the packages listed in the "build-depends" field of my "test-suite". Is there a way to get it to install those automatically?
08:49:15 <creichert> lifter: does --enable-tests work?
08:49:22 <hexagoxel> lifter: `cabal install --only-dependencies --enable-tests`
08:50:05 <lifter> Ah yes I see, adding "--enable-tests" seems to work. Thanks!
08:54:10 * hackagebot tar 0.4.1.0 - Reading, writing and manipulating ".tar" archive files.  http://hackage.haskell.org/package/tar-0.4.1.0 (DuncanCoutts)
08:55:28 <rvxi> hey
08:56:53 <rvxi> anyone using haskell for bayesian modeling?
08:58:00 <zimablue> no but that sounds interesting, what are you trying to do and do you have a good link to bayesian modelling?
08:58:30 <R0b0t1> rvxi: not to be that guy, but did you try google?
08:58:32 <rvxi> I do modeling with hierarchical bayesian models. Usually with R / JAGS / Stan
08:58:39 <hpc> there's a fair bit of bayes modules on hackage
08:58:40 <rvxi> yes
08:58:41 <hpc> http://hayoo.fh-wedel.de/?query=bayes
08:58:52 <R0b0t1> looked previously and there seemed to be quite a few people; you might also add the words "machine learning"
08:58:53 <rvxi> so far i've found two probabilistic programming libs
08:59:05 <rvxi> hakaru
08:59:10 * hackagebot htar 0.4.0.1 - Command-line tar archive utility.  http://hackage.haskell.org/package/htar-0.4.0.1 (DuncanCoutts)
08:59:13 * hackagebot bzlib 0.5.0.5 - Compression and decompression in the bzip2 format  http://hackage.haskell.org/package/bzlib-0.5.0.5 (DuncanCoutts)
09:00:12 <rvxi> and probability
09:00:50 <rvxi> was wondering if anyone used any of these libraries in practice
09:00:55 <hpc> there's also http://hackage.haskell.org/package/probable
09:04:04 <Dodek> hm there's no MonadExcept
09:04:06 <Dodek> class
09:04:58 <EvanR> class Monad m => MonadError e m | e -> m where ?
09:06:05 <Dodek> ah, but it's in mtl, and I'm using transformers
09:06:09 <lifter> In my cabal file, I added a "ghc-prof-options" field under both "executable" and "library"; now how do I tell cabal to build or run using those options so I can profile?
09:12:58 <R0b0t1> rvxi: I've not used them, no. And as far as most work that would make use of those libs goes, the vast majority of it is non-haskell.
09:14:06 <rvxi> r0b0t1: what do you mean the majority of probabilistic modeling is done in something other than haskell?
09:15:14 <forgottenone> i wonder when new list is created with a:xs or by inserting a new element is every node copied to new list or reused?
09:15:23 <R0b0t1> rvxi, well, there is R. and in the context I was looking this up previously (machine learning) C++ or python is rather common and this seems to be true for different but related applications as well.
09:16:41 <rvxi> r0b0t1: yeah i know. most of my current work is R/C++/python actually.
09:17:18 <R0b0t1> (not saying I think haskell is a poor fit, it's just underutilized. fwiw I think the design of probable is fine. all in all it just seems rather limited.)
09:18:12 <rvxi> that's good to know
09:19:24 <rvxi> i'm pretty familiar with other tools. i'm just interested in fp/haskell, seems like it has some potential advantages... particularly in developing/prototyping novel methodology.
09:19:43 * hackagebot htar 0.4.0.1 - Command-line tar archive utility.  http://hackage.haskell.org/package/htar-0.4.0.1 (DuncanCoutts)
09:19:43 * hackagebot bzlib 0.5.0.5 - Compression and decompression in the bzip2 format  http://hackage.haskell.org/package/bzlib-0.5.0.5 (DuncanCoutts)
09:20:53 <rvxi> for ex i'm interested in embedding ODEs in a probabilistic model, or trying to implement some approximate bayesian computation / variational bayes methods that are a bit nonstandard
09:21:10 <rvxi> netsplits today..
09:22:33 <lpaste> “_deepfire” pasted “what is wrong with my instance declaration?” at http://lpaste.net/119187
09:24:05 <_deepfire> or, rather, what do I do with the need to both have an argument for the type constructor being *-kinded  and have it constrained
09:24:36 <geekosaur> (Out a, b) looks suspicious to me...
09:24:45 <geekosaur> (Out a, Out b) seems more likely
09:24:52 <_deepfire> geekosaur, thank you!
09:25:03 <geekosaur> I am not even sure what the first one means in these days of type level programming
09:25:18 <geekosaur> (it was straight up an error before type level hackery, I think)
09:25:56 <_deepfire> 7.8 over here..
09:26:51 <_deepfire> I'm eagerly awaiting for data constructors to become liftable to types..
09:27:23 <geekosaur> yes, 7.8 already has some level of type level programming, and that leads to unexpected weirdness when you're not oing type level programming (like error messages involving Constraint instead of telling you you're trying to use a typeclass as a type or something)
09:27:23 <_deepfire> if I'm interpreting things correctly, that's what is supposed to come in 7.10..
09:27:50 <geekosaur> DataKinds is already in 7.8, no?
09:27:57 <geekosaur> I think it was even in 7.6
09:28:16 * _deepfire looks at DataKinds again, more closely..
09:28:25 <geekosaur> oh, wait, thinking of the wrong thing. yes, I think that needs 7.10 for the whole thing
09:28:33 <geekosaur> with some limited support in 7.8.4 maybe
09:29:02 <HeladoDeBrownie> geekosaur, they already have helpful messages like "did you mean this?", it could well show both of those things
09:32:22 <ezrios> I have a cabal library project that I developed locally
09:32:32 <ezrios> how can I reference this as a build dependency of another project?
09:32:59 <ezrios> can I just put it into my `otherproject.cabal` and `cabal install ~/Projects/library` ?
09:39:38 * hackagebot eventstore 0.6.0.0 - EventStore TCP Client  http://hackage.haskell.org/package/eventstore-0.6.0.0 (YorickLaupa)
09:44:38 * hackagebot distributed-process-p2p 0.1.3.1 - Peer-to-peer node discovery for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-p2p-0.1.3.1 (AlexanderBondarenko)
09:44:40 * hackagebot eventstore 0.6.0.1 - EventStore TCP Client  http://hackage.haskell.org/package/eventstore-0.6.0.1 (YorickLaupa)
09:53:58 <forgottenone>  are list nodes reused when we create a new list with cons operator or by inserting or copied in the memory?
09:54:38 * hackagebot descriptive 0.4.0 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.4.0 (ChrisDone)
09:56:18 <benzrf> forgottenone: implementation-dependent
09:56:24 <benzrf> forgottenone: but in ghc i believe they are reused
09:56:42 <_deepfire> got GenericPretty instances derived for my simple data constructors, but still have to provide manual implementation for the instance of HashMap
09:57:06 <forgottenone> benzrf i see thanks
09:58:38 <forgottenone> btw is there list like data structure takes constant time to add element to the end?
09:59:02 <Hi-Angel> Hello, I am new to haskell. Can anyone tell, what is the syntax like «defaults = defaultConfig { var1 = a, var2 = b, var3 = c}» ? It is from «XMonad WM» config, I couldn't find this syntax in tutorials ☹
09:59:08 <benzrf> forgottenone: i think Seq might do that
09:59:13 <benzrf> forgottenone: or at least logarithmic
09:59:27 <benzrf> Hi-Angel: that's record syntax
09:59:35 <geekosaur> Hi-Angel, record update syntax
09:59:36 <benzrf> er, record update syntax
09:59:37 <benmachine> it's record update syntax, in particular
09:59:39 * hackagebot structured-haskell-mode 1.0.11 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.11 (ChrisDone)
09:59:41 * hackagebot hindent 4.3.1 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.3.1 (ChrisDone)
09:59:43 * hackagebot hsdev 0.1.3.4 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  http://hackage.haskell.org/package/hsdev-0.1.3.4 (AlexandrRuchkin)
09:59:43 <benmachine> ok you two have this one covered :P
09:59:45 * hackagebot descriptive 0.4.1 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.4.1 (ChrisDone)
09:59:51 <Hi-Angel> Thank you very much!!
09:59:55 <forgottenone> benzrf is there something like circular linked list?
10:00:08 <benzrf> forgottenone: i dont think so
10:00:14 <benmachine> the trouble with circular linked lists is they tend to require mutation
10:00:20 <benzrf> forgottenone: i mean there is but you cant alter them
10:00:29 <benmachine> athough, you can make one with IORefs if you don't mind doing stuff in IO
10:00:35 <hyPiRion_> psh
10:00:44 <benzrf> @let circ = 1:2:3:4:circ
10:00:46 <lambdabot>  Defined.
10:00:49 <benzrf> ^circular linked list
10:00:55 <benzrf> good luck getting constant time end insertion though
10:00:58 <benmachine> :P
10:01:11 <benmachine> well, it's easy for me to get circ ++ [x] in constant time
10:01:16 <forgottenone> benmachine isn't ++ operator mutate last element?
10:01:16 <nkar> benmachine: your stepeval package is mentioned in a recent post of chrisdone.  still working on it?
10:01:58 <benmachine> nkar: no, I haven't worked on that in ages. it's a really cool idea but the current implementation has some critical bugs
10:02:14 <benmachine> nkar: it's a bit ambitious for me, I think, but I'd be really pleased if someone else could make something of it
10:02:25 <benmachine> forgottenone: no, ++ returns a new list
10:02:48 <nkar> benmachine: what kind of bugs?  and how much work would it be to fix?
10:02:48 <RyanGlScott> According to this presentation (http://johantibell.com/files/haskell-performance-patterns.html#%284%29), you should always unpack scalar fields. Dumb question: what exactly constitutes a scalar type in Haskell?
10:03:29 <benmachine> nkar: I think I wrote it before I really properly understood how to implement scoping, so there's some name capture bugs
10:03:36 <benmachine> nkar: I think exhibited as a failing test case
10:04:14 <benmachine> nkar: as for how much work it would be to fix, well, it was never finished, and if you fixed the bugs it still wouldn't be finished, I think there are some unresolved design questions
10:04:27 <benmachine> nkar: there's a lot of work left in the project as a whole
10:04:56 <nkar> benmachine: I'm not volunteering, btw. :)  just curious
10:05:05 <benmachine> I think one thing I was working on was a stepeval-like thing but not for Haskell, instead for some smaller, simpler language, like a simply-typed lambda calculus
10:05:50 <benmachine> one thing that would also make a project like stepeval more feasible would be if there was a good type inference/type checker engine for haskell-src-exts
10:06:00 <benmachine> some people were working on that, but I don't know how far they got
10:06:38 <SrPx> What is the best way to make a generic function that returns "many of something"? Returning a list is obviously not generic. Returning a generic vector is better since user can chose between unboxed/boxed vectors, but still not generic.
10:06:52 <SrPx> I guess I'd need (again?) a typeclass for sets... which don't exist, right? :(
10:07:02 <benmachine> SrPx: there's such a thing as too much genericity
10:07:15 <benzrf> benmachine: https://twitter.com/benzrf/status/559146502195785732
10:07:16 <benmachine> SrPx: if you generate a list, return a list, and leave it up to the caller to convert to whatever
10:07:26 <statusfailed> Is there a Haskell library like Idris' "Vec" ? i.e., one with static length checks
10:07:31 <MP2E> yeah, there's fromList and toList for just about everything that comprises of 'many of something'
10:07:53 <hiptobecubic> isn't that part of Foldable or something?
10:08:00 <SrPx> benmachine: really? You don't think it is bad to create a function that hardwiredly returns a list? So my user needs speed and boom, has to create his own lib using vectors instead.
10:08:01 <benmachine> toList is in Foldable
10:08:16 <benmachine> SrPx: well, that's why I say "if you create a list"
10:08:32 <benmachine> SrPx: there's no point in having a function that's just genericFromList . createist
10:08:35 <benmachine> er
10:08:39 <benmachine> genericFromList . createList
10:09:06 <benmachine> now, if you actually have the capability to do something clever with Vectors, then... I don't know what the answer is, I don't do that kind of thing
10:09:18 <benmachine> you have a problem that may be legitimately hard
10:09:24 <SrPx> okay I have a ray tracing operation that intersects 0~N points on the space. So you're telling me it should return a list?
10:09:43 <SrPx> (it should returns the intersected points)
10:10:20 <benmachine> I don't know enough about your problem domain, or tbh about high-performance Haskell, to tell you what to do
10:10:28 <benmachine> I'm just saying more generic isn't always better
10:10:45 <SrPx> okay, my bad ...
10:11:07 <SrPx> I'm just asking, I really don't know if returning a list is fine.
10:11:16 <benmachine> well, neither do I :)
10:11:34 <SrPx> maybe GHC knows how to optimize a "fromList" from a user of my lib so it doesn't actually create the list... then that would be fine
10:11:55 <benmachine> SrPx: sorry, rereading my initial advice it sounds waay more authoritative than was appropriate
10:11:59 <hexagoxel> lifter: iirc you just need to pass --enable-profiling to cabal configure/install; no ghc options (other than -rtsopts)
10:12:20 <SrPx> benmachine: sorry too (:
10:12:28 <hexagoxel> ezrios: are you using sandboxes?
10:13:20 * delpij waves
10:13:26 <lifter> hexagoxel: ok, thanks
10:17:09 <benmachine> RyanGlScott: I guess no-one answered your question; I think in this context it just means not a complex or compound type
10:17:52 <RyanGlScott> benmachine: For example, is Bool a scalar type? Internally, it's an ADT (False | True), but it's mapped to a C type as well.
10:18:14 <benmachine> RyanGlScott: hmm. I'm not sure, but I would guess that it is
10:18:55 <benmachine> RyanGlScott: I find the whole advice a *little* bit suspect, since unpacking your fields can introduce more unboxing/reboxing in some contexts
10:18:56 <SrPx> Is there any fast library that solves a symbolic equation in one variable? For example, `solve "t ^ 2 + 2 * t = 4" for t`
10:19:41 <benmachine> SrPx: numerically, or what?
10:19:56 <SrPx> symbolically, I want something like: "t = a * b" if necessary
10:20:34 <SrPx> i.e., "solve 2 * t - a = 0 for t → t = a / 2"
10:20:49 <SrPx> of course that is not decidable in general but I guess there are cases?
10:20:56 <arianvp___> Wow I think I fell in love
10:21:03 <arianvp___> The pipes documentation is so freakin good
10:21:13 <arianvp___> This is like a totally new level of good...
10:21:36 <SrPx> arianvp___: love that feeling :)
10:22:02 <arianvp___> Who writes these things?
10:22:16 <arianvp___> Gabriel himself?
10:22:21 <benmachine> probably?
10:22:34 <benmachine> he has a blog, as well
10:24:30 <_deepfire> is there a channel for Shake?
10:24:32 <mniip> SrPx, are you looking for a haskell solution?
10:24:40 <mniip> or just in general
10:38:22 <RyanGlScott> Is there a reason that reifying a data family's instances won't tell you what classes it derives? http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH.html#t:InstanceDec
10:44:49 <talw> I noticed the 'enumerator' package is considered deprecated, according to hackage.
10:44:57 <talw> But it doesn't specify in favor to what package is it deprecated
10:45:50 <talw> If anyone could enlighten me, I would be quite a happy man :)
10:46:00 <geekosaur> that's because there are several possibilities, none blessed as The One True Package
10:46:04 <nkar> pipes or conduit?
10:46:08 <benzrf> what is enumerator
10:46:22 <fresheyeball> hello out there, I need help understanding rank-n-types
10:46:28 <benzrf> fresheyeball: hey!
10:46:30 <talw> I see, so the options are either, pipes or conduit. I'm not yet familiar with them but I'll read
10:46:31 <fresheyeball> anyone willing to help me understand?
10:46:36 <benzrf> fresheyeball: certainly!
10:46:36 <fresheyeball> hey benzrf?!
10:46:40 <talw> Do they all play nice with Iteratees?
10:46:48 <nkar> no idea
10:46:49 <benzrf> talw: pipes is nice
10:46:54 <fresheyeball> so I have some code that looks like this:
10:47:06 <benzrf> > (\f -> (f 3, f "hi")) id
10:47:07 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
10:47:07 <lambdabot>    arising from the literal ‘3’
10:47:16 <benzrf> > (\f -> (f (3 :: Int), f "hi")) id
10:47:17 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
10:47:17 <lambdabot>              with actual type ‘[GHC.Types.Char]’
10:47:19 <fresheyeball> data JTree = JMap (StrMap JTree) | JList [JTree] | JLeaf (forall a. a)
10:47:31 <benzrf> fresheyeball: there is no value of type forall a. a
10:47:35 <benzrf> fresheyeball: except bottom
10:47:45 <fresheyeball> I don't understand
10:48:02 <fresheyeball> what I want is for JLeaf to accept any value regardless of type
10:48:09 <benzrf> fresheyeball: that's
10:48:11 <benzrf> forall a. JLeaf a
10:48:21 <fresheyeball> ok, let me try that
10:48:23 <fresheyeball> also why?
10:48:32 <benzrf> fresheyeball: it's the difference between these two types:
10:48:37 <benzrf> forall a. a -> JTree
10:48:41 <benzrf> (forall a. a） -> JTree
10:48:47 <benzrf> (forall a. a) -> JTree -- rather
10:49:11 <fresheyeball> ok so to be clear
10:49:28 <fresheyeball> I want JLeafs to hold values of different types within a single JTree
10:49:41 * hackagebot descriptive 0.4.2 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.4.2 (ChrisDone)
10:49:46 <benzrf> fresheyeball: yes, this will allow that
10:49:52 <benzrf> fresheyeball: however you will not be able to do anything with the values
10:50:20 <fresheyeball> I can't unwrap a JLeaf?
10:50:31 <benzrf> fresheyeball: you can, but
10:50:40 <benzrf> fresheyeball: applying JLeaf /throws away type information/
10:50:51 <fresheyeball> ok
10:51:04 <fresheyeball> so I was hoping to pattern match on JLeaf
10:51:05 <benzrf> fresheyeball: having a value of JTree that's a JLeaf tells you nothing at all about the value in the JLeaf
10:51:20 <benzrf> fresheyeball: so pretty much all you'll be able to do with the value you get out is apply id
10:51:38 <benzrf> :t Top
10:51:39 <lambdabot> a -> Top
10:51:46 <benzrf> data Top = forall a. Top a
10:51:53 <geekosaur> you can't pattern match to find a type
10:51:56 <benzrf> > case Top 3 of Top n -> n
10:51:57 <lambdabot>  Couldn't match expected type ‘t’ with actual type ‘a’
10:51:57 <lambdabot>    because type variable ‘a’ would escape its scope
10:51:58 <lambdabot>  This (rigid, skolem) type variable is bound by
10:52:12 <fresheyeball> ok
10:52:19 <benzrf> fresheyeball: have you considered a Tree of Eithers
10:53:22 <RyanGlScott> Aside: what does "skolem" mean?
10:53:29 <fresheyeball> ok
10:53:40 <augur> RyanGlScott: in this case it just means that its existentially quantified
10:53:44 <fresheyeball> so what I would really like is this
10:54:05 <fresheyeball> data JType = JString | JNumber | JDate | JNull
10:54:07 <fresheyeball> and
10:54:17 <RyanGlScott> augur: Does the word originate from Thoralf Skolem by any chance?
10:54:22 <benzrf> RyanGlScott: yes
10:54:35 <random_nick> Hello everybody
10:54:37 <fresheyeball> data JTree = JMap (StrMap JTree) | JList [JTree] | JLeaf JType
10:54:46 <random_nick> I'm making a new haskell/stackage setup
10:54:51 <fresheyeball> I think that would work for me perfect
10:54:57 <benzrf> fresheyeball: ok, do that :p
10:55:11 <benzrf> fresheyeball: i'd personally use JS rather than J
10:55:12 <random_nick> I'd like to know what's the safest GHC and stackage snapshot versions to use
10:55:14 <fresheyeball> except that I am using a library that has those types defined with newtype
10:55:21 <augur> RyanGlScott: i believe it does!
10:55:35 <fresheyeball> or type aliases
10:55:35 <fresheyeball> things like
10:55:43 <fresheyeball> type JString = String
10:55:46 <remy> Hi, I'm a newbie here, I wrote this program to count invariants in a large list of integers but it is very slow. http://lpaste.net/119190
10:56:10 <remy> any ideas on what I can do to speed it up?
10:56:49 <fresheyeball> does my stradegy with rank-n
10:56:57 <augur> RyanGlScott: the type Top has the constructor Top, right
10:56:58 <fresheyeball> mean that I can't do something like this?
10:57:24 <augur> RyanGlScott: and it looks like its a 1-arg constructor, because you write `Top a` but secretly it has an extra argument: the type of the value
10:57:26 <fresheyeball> foo :: JLeaf JNumber -> JNumber
10:57:30 <fresheyeball> ?
10:57:48 <augur> RyanGlScott: secretly the Top constructor takes a type (named `a`) and then a value (of type `a`)
10:57:50 <benzrf> fresheyeball: JLeaf is not a the type level
10:58:02 <remy> This is the output I got from the ghc profiler, it doesn't seem very helpful
10:58:04 <remy> http://lpaste.net/119192
10:58:05 <fresheyeball> I don't understand
10:59:07 <simon> remy, besides 'length xs' I can't see any other list abuse.
10:59:08 <RyanGlScott> Ah, I just discovered this humorous discussion about skolems years ago on #haskell: http://ircbrowse.net/browse/haskell?id=10634364&timestamp=1289931117
10:59:13 <SrPx> mniip: I was looking for a haskell solution but I'd be glad for a general one
10:59:49 <simon> remy, i.e. you presumably do calculate length xs a lot of times in various recursive calls when you could settle with doing it once.
10:59:53 <RyanGlScott> tl;dr don't let your skolems escape from the basement
10:59:54 <remy> simon: yeah, I was worried about that too, but the profiler didn't seem to think it was a problem
11:00:33 <mniip> SrPx, maxima is a library written in lisp
11:00:46 <remy> 98% of the time is spent in mergeAndCount.(...) which doesn't call `length`
11:00:49 <mniip> supports a ton of features
11:01:34 <random_nick> So yeah, the last Stackage LTS seems to be based on GHC7.8.4, is that setup any good?
11:02:10 <random_nick> Just trying to see what's the kind of setup everybody's converging to
11:02:51 <remy> I must be doing something wrong though, I wrote a naive ruby solution and it ran in a fraction of the time
11:04:32 <fresheyeball> ok so I have another idea
11:04:40 <athan> o/ fresheyeball
11:04:41 * hackagebot descriptive 0.4.3 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.4.3 (ChrisDone)
11:04:43 <fresheyeball> what about makeing JLeaf hold a tuple
11:05:01 <fresheyeball> where the left is the type and right is the value
11:05:41 <benzrf> fresheyeball: you need GADTs for that
11:05:49 <benzrf> no, er ,wait
11:05:57 <benzrf> yeah you need GADTs for that
11:06:06 <benzrf> fresheyeball: just use a sum type
11:06:28 <benzrf> data JType = JString String | JNumber Float | JDate Date {- or something -} | JNull
11:08:36 <Pamelloes> Is there any way to debug memory usage? My program sometimes goes from 10MB to 10GB in a matter of seconds and I have no idea why.
11:09:00 <SrPx> mniip: tanks! :)
11:09:11 <Welkin> Pamelloes: thunks
11:09:22 <luite> Pamelloes: yes heap profiling, you'll have to recompile the program, see the GHC manual
11:09:50 <Pamelloes> Welkin: I've heard that term thrown around a lot, but I have no idea what it means. Can you elaborate?
11:09:58 <Pamelloes> luite: Thanks, I'll look into it
11:10:02 <Welkin> an uncomputed value
11:10:47 <fresheyeball> yes
11:10:54 <Pamelloes> Welkin: o in snd $ (10^!0^100,22). (10^10^100) would be a thunk?
11:10:55 <Welkin> the difference between foldl and foldl' is that the first builds up computations, but doesn't execute them until it reaches the end of the list
11:11:16 <Welkin> the second is strict, so it computes each value immediately before proceding to the next one
11:12:16 <Welkin> because of laziness, values are only computed when they are needed
11:33:07 <dabukalam> .
11:41:47 <Pamelloes> -fprof-auto is incredibly useful. How have I never used it before?
11:44:36 <phaul> @Pamelloes : I found http://hackage.haskell.org/package/profiteur also neat (there are others), you might want to give it a go :)
11:44:36 <lambdabot> Unknown command, try @list
11:44:52 <phaul> ah
11:52:50 <dfeuer_> Ralf Hinze describes 2-3 search trees under the left spine view as the best known functional implementation of one-sided ordered sequences. I haven't been able to find one on Hackage. Can anyone help?
11:54:04 <Pamelloes> Is normal recursion slower than fold?
11:54:28 <dfeuer_> Pamelloes: sometimes, sort of.
11:54:57 <Pamelloes> I've been profiling my code, and I've concluded that 80% of the time is spent on this function ( http://lpaste.net/119198 )
11:55:19 <dfeuer_> Pamelloes: sometimes, using folds and things can let GHC avoid creating a list or vector. Sometimes not.
11:55:34 <Pamelloes> Hm
11:58:51 <dfeuer_> Pamelloes: how are you using the function?
11:59:09 <phaul> Pamelloes: what's your BitSeries data type? Maybe it's better to represent it with an unboxed UInt64? or a vector of it?
11:59:17 <Pamelloes> type BitSeries = [Bool]
11:59:58 <dfeuer_> Context!
12:00:33 <dfeuer_> Can't effectively optimize without more context.
12:01:11 <Pamelloes> dfeuer_: I have a parsec filter that produces a [Bool] based off of a BitSeries where true means keep and false means lose. Then f is supposed to get rid of the memebers of list that correspond to false
12:02:26 <dfeuer_> Yeah, that doesn't help any. I don't know if I'd know if I saw the code (I only have the vaguest of clues about parsing) but I definitely can't help without seeing it.
12:02:49 <zimablue> this is a rewrite of "filter" ?
12:02:58 <Pamelloes> dfeuer_: I'm creating a new paste with a larger context
12:03:49 <lpaste> Pamelloes pasted “Larger scope.” at http://lpaste.net/119201
12:04:17 <Pamelloes> There's the entire segment with the parsec falters and the functions that call it. The segment I highlighted earlier is in filter'
12:08:53 <dfeuer_> Pamelloes: that's a bit beyond me. The names are not too helpful, everything being some sort of "filter" and no comments. :-/
12:10:35 <dfeuer_> Also, Pamelloes, calling error because a parse failed is very strange/wrong.
12:10:50 <fresheyeball> @lp \ x a -> x ++ " (" ++ show a ++ ")"
12:10:53 <lambdabot> Maybe you meant: wn v slap rc pl let id help do bf @ ? .
12:10:58 <fresheyeball> crap
12:11:17 <fresheyeball> @pl \x a -> x ++ " (" ++ show a ++ ")"
12:11:18 <lambdabot> (. ((" (" ++) . (++ ")") . show)) . (++)
12:11:26 <lpaste> Remy pasted “Slow Inversions 2” at http://lpaste.net/119202
12:11:31 <fresheyeball> trippy
12:12:53 <Jello_Raptor> oh gods XD http://i.imgur.com/Rw8mmad.jpg
12:14:45 * hackagebot snaplet-purescript 0.2.0.0 - Automatic (re)compilation of purescript projects  http://hackage.haskell.org/package/snaplet-purescript-0.2.0.0 (AlfredoDiNapoli)
12:20:14 <Zemyla> Hmm, why is Fixed not an instance of Random?
12:23:21 <c_wraith> Zemyla: Random is kind of..  not a highly-respected abstraction.
12:23:32 <c_wraith> Zemyla: it's quite common for things to skip it.
12:23:34 <stool> Lists aren't pure, right?
12:23:59 <c_wraith> stool: they're pure by every definition of the term I know
12:24:01 <srhb> stool: In what sense?
12:24:07 <srhb> What c_wraith said.
12:24:38 <stool> I'm convinced of it myself, my friend's having some problems with it, just wanted to make sure.
12:25:10 <srhb> I guess that's a problem with the term purity rather than lists then/
12:25:11 <c_wraith> Zemyla: in the case of Fixed, the instance would need to go in the `random` package. I'm sure they'd accept a patch, but I doubt any of the maintainers feel a pressing need to add those instances without a patch.
12:26:04 <Zemyla> Why couldn't it just go in the Fixed - oh, wait, System.Random isn't in base. D:
12:26:48 <Zemyla> I also think part of it is that Data.Fixed is more a demonstration than something people are actually supposed to use.
12:29:52 <phaul> never used Data.Fixed before, but haskell aside, fixed point numbers are useful. Ie computer graphics uses them all the time
12:30:41 <athan> Hi everyone. What would be the best way to throw a 404 from within a route? I'm matching against "blog/:slug", and checking to see if the slug exists as a file name - if it does, continue rendering it as markdown; if not, 404. The issue is that `raise` just throws a 500, while my `notFound` handler is already pretty nice. Also `status notFoud404` causes the server to fail to send meaningful http :\
12:30:48 <Peaker> Years ago, I remember discovering System.Random was too lazy, and things would explode if you didn't manually force a lot of stuff
12:30:54 <Peaker> I wonder if that's fixed
12:30:54 <athan> Sorry, this is int he context of scotty ><
12:31:29 <AleksejsHome> is there math definition of infinite lists?
12:31:37 <Zemyla> phaul: They would probably be more useful if they were wrapping machine numbers instead of Integers.
12:31:43 <biglama> does someone know how to specify a version of cabal for travis ?
12:31:45 <c_wraith> Zemyla, phaul: If you want performant fixed-point, use https://hackage.haskell.org/package/fixed
12:32:17 <c_wraith> AleksejsHome: mathematically, an infinite list is a very simple example of codata
12:33:52 <c_wraith> AleksejsHome: mathematically, data is defined to be well-founded.  You always build up from the base cases.  codata does not have that requirement - you process it by tearing down from the top, instead of building up from the bottom.
12:34:37 <c_wraith> AleksejsHome: Haskell makes that slightly annoying to talk about, since the data keyword can be used to create things that are mathematically data, codata, or a mixture
12:34:42 <dmwit> A thing is in an inductive set if there's a finite reason for it to be. A thing is in a coinductive set unless there's a finite reason for it not to be.
12:36:26 <c_wraith> AleksejsHome: in fact, I should be a bit clearer - data is defined by the process of building it up from base cases. codata is defined by the process of tearing it down.
12:37:46 <shachaf> I think figuring out Mu and Nu is a good way to get some intuition for data/codata in Haskell.
12:38:07 <c_wraith> I still don't know Nu, really.
12:38:39 <lifter> I'm writing a game server. When someone logs in, I check their login name against a dictionary of English words. Presently I load the dictionary at server startup and keep it in memory (as a "Set"). Would it make more sense to load the dictionary anew every time a user logs in? Should I bother to profile both cases to see which is better?
12:38:40 <shachaf> data Nu f = forall x. Nu x (x -> f x)
12:38:55 <shachaf> Think of what the inhabitants of (Nu Maybe) are.
12:38:58 <AleksejsHome> c_wraith: the reason I ask is because I have an argument about if lists are pure. In my point of view, pure data are primitives, but lists are collection of data, hence lists are impure. But also, purity is such a hazy concept, and from one point of view, lists are pure, from the other they arent
12:39:18 <Welkin> what do you mean by pure?
12:39:25 <c_wraith> AleksejsHome: primitive and pure are totally unrelated
12:39:32 <Welkin> lists are nondeterministic, but what does that have to do with purity?
12:39:37 <Welkin> purity, to me, means immutability
12:39:43 <Welkin> all data in haskell is immutable
12:40:19 <c_wraith> Welkin: well, lists can *simulate* nondeterminism - but they are in fact totally deterministic
12:40:46 <c_wraith> Welkin: much the same way s -> (s, a) can simulate a mutable state, but involves no actual mutable values
12:41:04 <Welkin> okay
12:41:19 <dmwit> Let's talk about referential transparency, a thing with a concrete, technical definition, instead of "purity", which means different things to different people.
12:41:37 <dmwit> Lists are referentially transparent. Next!
12:45:33 <KorriX> Hi! Is there any IRC channel dedicated to category theory?
12:46:17 <ab9rf> is there any irc channel dedicated to any topic at all?
12:46:38 <Xe> KorriX: I don't think I know a better one than #haskell tbh
12:47:22 <dmwit> There is #math.
12:47:47 <KorriX> I've tried but nobody responds :)
12:47:48 <dmwit> If you want to talk about the abstract, there is probably better. If you want to talk about the bits of CT that are relevant to CS, here is probably a better bet.
12:48:42 <KorriX> So my question is - Is set theory a metatheory of category theory, vice versa or they are just isomorphic?
12:49:09 <stool> c_wraith, Coinduction in wikipedia?
12:49:20 <KorriX> I still have an intuition of category as a set of objects
12:49:54 <shachaf> The objects aren't even the important part of a category.
12:50:26 <dmwit> I think the relationship between set theory and category theory is even less complicated than that.
12:50:36 <dmwit> CT is supposed to be an alternative to set theory.
12:51:00 <dmwit> But sometimes set theory ideas are a handy tool to use when defining or reasoning about some categories.
12:51:08 <shachaf> An alternative?
12:51:23 <dmwit> I would say so.
12:51:41 <KorriX> dmwit: This is what I've "heard" - that CT can be used as a foundation of math instead of set theory
12:51:44 <dmwit> It's also a fantastic way to tie together lots of apparently distinct ideas in set theory.
12:52:09 <dmwit> But I think saying either one serves the other is a bit off.
12:52:21 <KorriX> But if category is loosely speaking just a set - then you'd still need to use set theory axioms
12:52:22 <dmwit> They're complementary.
12:52:38 <shachaf> Oh, sure.
12:52:45 <dmwit> Well, a category is not loosely speaking just a set.
12:52:49 <dmwit> So your conclusion doesn't follow.
12:53:01 <zimablue> I'm hacking my way through a group theory textbook partly just to have a basis for understanding cat theory
12:53:08 <zimablue> sadface
12:53:26 <dmwit> zimablue: Sounds like fun!
12:53:38 <KorriX> It's just my intuition - Cat = {{objects}, {morphisms}}
12:53:42 <dmwit> Nothing like a depth-first search on human knowledge to ruin a couple years of your life... ;-)
12:54:17 <dmwit> KorriX: I obviously can't reasonably dispute a claim you make about the state of your mind.
12:54:36 <dmwit> KorriX: But I think if you talk to a serious CT theoretician, their mind will be in a different state.
12:54:51 <MrFlibble> yeah, psychotic.
12:54:57 <zimablue> very shallow depth first search is the scary part - 200 pages and it's like trying to climb everest
12:55:03 <zimablue> then extrapolate...
12:55:41 <KorriX> dmwit: I'm just learning - could you please give me an example of category, whitch cannot be trivially represented as a some sort of set?
12:55:56 <shachaf> The category where the objects are sets are the arrows are functions between sets.
12:57:42 <KorriX> shachf: Ok. That's a good example, but does it is the only reason of using categories to avoid antinomies?
12:59:02 <shachaf> What?
12:59:48 <KorriX> Ok. We cannot have a set of all sets - this leads us to contradiction
12:59:53 <dmwit> Do you need a better reason?
13:00:21 <KorriX> Not a better - for me CT is fascinating
13:00:57 <KorriX> I'm just searching for examples where CT is more powerfull than set theory
13:01:38 <vanila> KorriX, it's not exactly more powerful, it's just a different language
13:01:58 <vanila> it gives you a different approach to the mathematics
13:02:01 <AleksejsHome> KorriX: I think that ST studies sets but CT mostly studies morphisms between not only sets
13:02:27 <KorriX> So CT is just like a "framework" for math
13:02:30 <vanila> yes
13:02:35 <dmwit> So, I think there are a lot of other good reasons to use categories.
13:02:37 <vanila> its also a theory itself
13:03:03 <KorriX> Now I think I got it
13:03:07 <dmwit> For one, as I said before, CT has the language needed to unify a lot of ideas that appear disparate in set theory.
13:03:14 <hodapp> The avoidance of inconsistency is itself a form of power...
13:03:23 <dmwit> For another, categories have a lot of structure up front that sets don't have.
13:03:44 <dmwit> Which gives you a lot of power in creating the language you use to describe them.
13:04:44 <dmwit> Especially as a basis for studying programming language semantics, the mapping from computation to CT structures is much more natural than the mapping to set theory structures.
13:05:46 <KorriX> dmwit: Could you expand this thought?
13:06:03 <dmwit> I could, but it would take at least two books.
13:06:20 <dmwit> Luckily, they're already written... =D
13:06:56 <KorriX> dmwit: Which ones did you recommend?
13:07:12 <dmwit> Types and Programming Languages gives the basics of PLs, and Advanced Topics in Types and Programming Languages starts to get into the CT
13:08:08 <dmwit> For the basics, there's Basic CT for Computer Scientists.
13:08:27 <KorriX> dmwit: cool. Thanks - I haven't read "Advanced Topics" one
13:08:48 <dmwit> There's also plenty of free CT resources online.
13:09:12 <shachaf> I like Leinster's recent book, _Basic Category Theory_.
13:09:17 <dmwit> Barendregt has some lecture notes that seemed pretty good.
13:09:17 <shachaf> Well, the parts of it that I've read.
13:10:19 <KorriX> dmwit, vanila, AleksejsHome, shachf: Thank you so much!
13:10:30 <dmwit> Probably if you hang around a few hours and ask again you'll get a completely different set of suggestions. =)
13:10:52 <sinelaw> KorriX, also, try #learnmath
13:11:16 <shachaf> People misspell my nick a lot so my IRC client matches anything that ends in "chaf".
13:11:16 <Peaker> tab-completions for cheap!
13:11:16 <shachaf> This is one of the first times it hasn't worked.
13:11:22 <sinelaw> seagull
13:11:24 <KorriX> shachaf: Sorry man :)
13:11:56 <KorriX> sinelaw: I'll read books first - and then ask questions
13:12:08 <sinelaw> KorriX, they are writing a book
13:12:16 <sinelaw> and they know about other books too
13:13:45 <KorriX> sinelaw: But as far as I can see it's an introduction to discrete math/algebra book
13:13:58 <rvxi> hey guys
13:14:13 <KorriX> rvxi: Hey :)
13:14:13 <rvxi> is there a way to run ihaskell with a cabal sandbox directory?
13:14:23 <sinelaw> KorriX, true. maybe they'll give you other suggestions.
13:14:28 <rvxi> hi korrix :)
13:14:59 <KorriX> sinelaw: I already have MacLane and Awodey on my reading list xD
13:15:05 <stool> sinelaw, Why would one prefer #learnmath over ##math?
13:15:19 <shachaf> stool: Are you ij?
13:15:43 <sinelaw> stool, for me, #learnmath people were a lot nicer. and there's less "solve my homework!" noise
13:15:54 <stool> shachaf, Yes.
13:16:59 <KorriX> I don't know if you have heard about Homotopy Type Theory - I'm just preparing myself to aproach the HoTT book
13:17:15 <sinelaw> ah
13:17:43 <KorriX> I got interested by foundations of math and their relationship to computer programming
13:18:01 <KorriX> It's all very thightly connected: That's one example: http://ncatlab.org/nlab/show/computational+trinitarianism
13:18:13 <shachaf> Well, if you're talking about foundations, that's a different story.
13:18:57 <shachaf> I guess you already were. But if that's your goal, the discussion would be a bit different.
13:20:51 <KorriX> Yes - forgive me, but English is not my native language so sometimes I'm trying to simplify my questions just to get an interesting "bits of knowledge"
13:28:52 <hexagoxel> rvxi: `cabal exec IHaskell` or smth. how do you run ihaskell right now?
13:32:37 <quchen> … is there a way I can hide the synopsis tab once I've opened it once? I can close it, but it'll pop open on every new page I open.
13:32:47 <quchen> Can't find a cookie that does it either :-s
13:33:01 <quchen> Haddock documentation, by the way.
13:33:29 <shachaf> It shouldn't?
13:33:59 <quchen> Yes, I'd like the synopsis tab to not be open by default on every page.
13:34:17 <shachaf> I'm saying: I don't think that's a thing that should be happening.
13:34:35 <quchen> Oh. Yes I agree with that.
13:48:52 <sbrg> so it seems I've gone and installed cabal-install-1.22 automatically through updates on arch linux, and ghc-mod doesn't support it unless you're using ghc 7.10. What is the simplest way for me to downgrade cabal-install here?
13:49:08 <sbrg> without breaking the universe
13:49:32 <indiagreen> sbrg: you can install an older version of a package from pacman cache
13:49:46 <indiagreen> or you probably can install cabal-install from Hackage and it won't break either
13:50:52 <sbrg> indiagreen: oh god, I *just* learned about the pacman cache and cleaned it. -_-
13:51:00 <sbrg> indiagreen: I guess I'll try cabal then
13:51:03 <indiagreen> for reference, installing an older version from cache would be “pacman -U /var/cache/pacman/pkg/cabal-install-...”— ouch
13:51:50 <sbrg> indiagreen: thanks!
13:52:44 <sbrg> indiagreen: that did it! I figured install cabal-install via cabal-install from hackage would break stuff.
13:52:48 <sbrg> guess not
13:52:50 <sbrg> excellent
13:53:06 <Zemyla> Why does decodeFloat not reduce its argument to lowest terms?
13:54:40 <hpc> :t decodeFloat
13:54:41 <lambdabot> RealFloat a => a -> (Integer, Int)
13:56:30 <Zemyla> @let divRadix rad p@(m, e) = let (d, r) = divMod m rad in if r == 0 then let e' = e+1 in e' `seq` divRadix rad (d, e') else p
13:56:34 <lambdabot>  Defined.
13:57:02 <Zemyla> @let decodeFloatD x = divRadix (floatRadix x) (decodeFloat x)
13:57:03 <lambdabot>  Defined.
13:57:15 <Zemyla> > decodeFloat (1.0::Double)
13:57:17 <lambdabot>  (4503599627370496,-52)
13:57:28 <Zemyla> > decodeFloatD (1.0::Double)
13:57:30 <lambdabot>  (1,0)
14:05:19 <benzrf> > decodeFloatD 3.45
14:05:20 <lambdabot>  (3884354678607053,-50)
14:05:24 <benzrf> o.O
14:05:34 <benzrf> > 3884354678607053 * 2^-50
14:05:35 <lambdabot>  Not in scope: ‘^-’
14:05:35 <lambdabot>  Perhaps you meant one of these:
14:05:35 <lambdabot>    ‘-’ (imported from Prelude), ‘^’ (imported from Prelude),
14:05:40 <benzrf> > 3884354678607053 * 2^(-50)f
14:05:42 <lambdabot>  Could not deduce (GHC.Real.Integral b0)
14:05:42 <lambdabot>    arising from a use of ‘GHC.Real.^’
14:05:42 <lambdabot>  from the context (GHC.Num.Num a)
14:05:43 <benzrf> > 3884354678607053 * 2^(-50)
14:05:45 <lambdabot>  *Exception: Negative exponent
14:05:51 <benzrf> blugh
14:05:56 <AleksejsHome> > 2**(-50)
14:05:58 <lambdabot>  8.881784197001252e-16
14:06:03 <exio4> > 3884354678607053 * (2**(-50))
14:06:04 <lambdabot>  3.45
14:06:08 <benzrf> whoa
14:10:52 * hackagebot bytestring-builder 0.10.4.1.1 - The new bytestring builder, packaged outside of GHC  http://hackage.haskell.org/package/bytestring-builder-0.10.4.1.1 (LeonSmith)
14:12:36 <IRWolfie-> What's the distinction between [IO ()] and IO ()?
14:13:41 <Peaker> IRWolfie-: one value is a list, each element in it is an IO action producing no information. The other is a single IO action producing no information
14:15:12 <IRWolfie-> I'm a newb as you might guess. I was doing IO in a list because it seemed the easiest way to iterate over a 2d array (this is the side effect).
14:15:15 <sx_> How do I refer to type variables, bound either by a (:: ...) or the type signature, within a definition? For some reason I always get the "Could not deduce (a1 ~ a) ...".
14:15:44 <hpc> IRWolfie-: look at sequence, mapM, and mapM_
14:15:53 <IRWolfie-> cool I'll have a check
14:15:53 <hpc> (and forM/forM_)
14:16:07 <mpickering> sx_: ScopedTypeVariables
14:18:08 <brushbox> Hi, folks. I’m getting an error trying to use the Text.Regex module on OS X, in ghci:
14:18:14 <brushbox> Loading package regex-compat-0.95.1 ... can't load .so/.DLL for: /Library/Haskell/ghc-7.8.3-x86_64/lib/regex-compat-0.95.1/libHSregex-compat-0.95.1-ghc7.8.3.dylib (dlopen(/Library/Haskell/ghc-7.8.3-x86_64/lib/regex-compat-0.95.1/libHSregex-compat-0.95.1-ghc7.8.3.dylib, 9): Library not loaded: @rpath/libHSmtl-2.1.3.1-ghc7.8.3.dylib
14:18:33 <sx_> mpickering: I enabled it, but it still does not work: http://codepad.org/dY2EtYyM
14:18:49 <mpickering> you need to explicitly quantify the variable names
14:19:00 <mpickering> f :: forall a . a -> a
14:19:23 <brushbox> I have no idea … I can see the file libHSmtl-2.1.3.1-ghc7.8.3.dylib in /Library/Haskell/ghc-7.8.3-x86_64/lib/mtl-2.1.3.1 …not sure what @rpath is.
14:19:27 <sx_> mpickering: Why is that? But thanks anyway.
14:19:41 <mpickering> don't actually know sorry
14:20:22 <sx_> mpickering: You still helped me a lot. :)
14:26:04 <quchen> sx_: I'm just guessing here, but I think the demand for explicit foralls is because of a certain ambiguity without it. Consider this example: http://lpaste.net/119208
14:26:20 <geekosaur> brushbox, it's OS X dyld magic. and suggests that something did not get built with the correct dyld lookup path
14:26:30 <quchen> By using "forall", you're explicitly saying "I want all that's following to work for all a". In a sense, you're opening a scope in which "a" is present.
14:27:15 <quchen> In the "bar" function, the definition inside the "where" has its own forall, opening its own scope in which "a" is valid. Alas, id compiles.
14:27:42 <quchen> So I think the explicit "forall" is demanded to make the programmer make scoping explicit.
14:27:46 <Peaker> when doing Higher Ranked type checking, even with e.g: PolymorphicComponents -- need to check two forall/Scheme types against each other, unlike unification, this is never symmetric. Does it require tracking variance everywhere to do properly?
14:28:14 <sx_> quchen: Thanks, that makes sense.
14:28:15 <brushbox> geekosaur: thanks. Not sure what to do abou it … but I’ll see if I can work out anything.
14:28:43 <quchen> sx_: Again, that was just how I rationalize it. I don't know the actual reason.
14:29:09 <geekosaur> there is probably some install_name_tool invocation that can fix it --- but really that should not be necessary, and I have no idea what went wrong that the compiled-in rpath doesn't work.
14:29:36 <sx_> quchen: I personally would expect "myId" to take over the type context of "foo", so it was always kind of strange to me.
14:30:09 <quchen> sx_: Right, the "a" in "myId"s type signature is the same as the "a" in "foo"s.
14:30:47 <sx_> quchen: Or at least should be, but I guess some folks see that in another way. :)
14:30:49 <quchen> However, myId is then applied to a tuple of (a,a), which means that for "myId" to typecheck, "a" has to unify with (a,a), which of course does not work.
14:34:32 <geekosaur> brushbox: if you want to help debug this, see http://stackoverflow.com/questions/12521802/print-rpath-of-executable-on-osx and look at the rpath entries in /Library/Haskell/ghc-7.8.3-x86_64/lib/regex-compat-0.95.1/libHSregex-compat-0.95.1-ghc7.8.3.dylib
14:34:59 <merijn> sx_: Yeah, it's a bit confusing, but the haskell report actually doesn't allow type scopes to extend beyond a single signature
14:35:20 <geekosaur> (this is presumably an OS X-specific bug in regex-compat)
14:35:30 <geekosaur> (although it may indicate a more general problem)
14:35:38 <merijn> sx_: Even for local functions, so you need the ScopedTypeVariables extension and have to explicitly bring the variable you want into scope to share it between local definitions
14:36:27 <merijn> sx_: I think it's a matter of "no one thought of it during the design and in practice it's not inconvenient enough to break the design"
14:36:58 <merijn> sx_: Also, USUALLY you don't have to share the scope
14:37:34 <sx_> merijn: Yes, that's exactly what I thought why it is that way. I tried to learn some new type level specific features of Haskell, but they seem very chunky at least sometimes.
14:37:41 <quchen> Is there an easy way (command-line flag even?) to display all language extensions?
14:37:54 <quchen> … supported by GHC, that is
14:38:10 <hpc> there isn't a good single list of them, but almost all of them are on the manpage
14:38:12 <luite> --supported-languages
14:38:21 <merijn> quchen: The docs have a list and 7.10 has had a major overhaul of documenting flags
14:38:33 <quchen> luite: Excellent, thanks!
14:38:46 <merijn> hpc: There was a massive refactor to fix and document that
14:38:51 <hpc> you can use ghc-man-completion to generate a bash completion script
14:39:09 <merijn> sx_: I'd actually say they're rather fine grained
14:39:25 <merijn> sx_: If they were chunky I wouldn't need 8-10 lines of extensions in my files :>
14:39:56 <sx_> merijn: Maybe I chose the wrong word, but they are everything but easy to work with.
14:40:20 <merijn> sx_: Really? Which ones are you referring too? Most are pretty straightforward
14:40:37 <sx_> merijn: And at some points I don't get the design decisions, so why for example I can't lift arbitrary expressions to type level (excluding IO).
14:40:45 <merijn> sx_: Ah!
14:40:58 <merijn> sx_: That's a fundamental problem with the underlying model/theory of haskell
14:41:32 <merijn> sx_: The beauty of System F_omega (which forms the basis of haskell) is that all types can be inferred, but it doesn't support true dependent typing
14:41:56 <merijn> sx_: Dependently typed theories are not completely inferrable, but they do allow arbitrary type level expressions
14:42:25 <benzrf> merijn: i thought hs was hindley milnner
14:42:37 <merijn> sx_: You may wanna look at Idris, it's goal is to be a practical (i.e. not just theorem prover) dependently typed language aimed at intermediate haskellers
14:42:47 <merijn> benzrf: Hindley Milner is an inference algorithm
14:42:52 <benzrf> merijn: what
14:43:01 <benzrf> https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_systemf
14:43:03 <benzrf> https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
14:43:56 <sx_> merijn: Does this mean, that some expressions do not have valid types then?
14:44:55 <merijn> sx_: By definition all possible haskell expressions have a valid type
14:44:55 <merijn> sx_: But youre types may not be able to express all constraints you want
14:44:55 <hpc> it means there are expressions with valid types, which can't be automatically determined
14:44:55 <merijn> benzrf: Terminology is wildly ambiguous >.>
14:45:07 <hpc> but if you give an explicit type, the compiler can say "that makes sense, i never would have guessed!"
14:45:08 <merijn> benzrf: Core is (almost entirely) System F_omega, if I recall correctly
14:45:43 <merijn> sx_: oh, you mean dependent types not being able to infer everything?
14:45:55 <benzrf> 05:42 < merijn> sx_: By definition all possible haskell expressions have a valid type
14:45:58 <benzrf> merijn: what?
14:46:09 <benzrf> :t \f -> f f
14:46:13 <lambdabot>     Occurs check: cannot construct the infinite type: t1 ~ t1 -> t
14:46:13 <lambdabot>     Relevant bindings include f :: t1 -> t (bound at <interactive>:1:2)
14:46:13 <lambdabot>     In the first argument of ‘f’, namely ‘f’
14:46:17 <hpc> benzrf: if an expression isn't well-typed, it's not haskell ;)
14:46:25 <benzrf> hpc: what a tautology
14:46:36 <merijn> sx_: It means that if you tell the compiler "this has type X" the compiler will be able to decide "yep" or "nope", but if you ask the compiler "what is the type of expression X?" it might not be able to decide because there infinitely many
14:46:44 <geekosaur> more to the point, if you got it to compile, it is well-typed
14:47:02 <merijn> benzrf: "by definition" is by definition a tautology :)
14:47:02 <meditans> lens question. I have a map from elements to sets. Why can't I do `theMap ^?! at theElem . _Just . to f`?
14:47:12 <sx_> merijn: Well, guess I could live with that. :)
14:47:18 <hpc> benzrf: more seriously, i think he meant "things a compiler would accept" as oppoed to "things that pass the parsing step only"
14:47:45 <hpc> (a common alternate meaning)
14:48:13 <merijn> sx_: Anyway, two recommendations: 1) if you're playing around with type level stuff in Haskell, then "Fun with Type Functions" is a great paper
14:48:17 <sx_> merijn: On the other hand it means the compiler could reject correct programs, which is not so good. :/
14:48:42 <merijn> sx_: 2) If you wanna do more complex stuff, this may be easier in Idris and given that "haskellers" are their explicit target audience you should feel reasonably at home
14:49:56 <merijn> benzrf: As for making sense of the System F_omega stuff, I recommend Barendregt's "Introduction to Generalised Type Systems" (aka the lambda cube paper) which divides type systems for LC into 3 possible axis and describes the different possible variations
14:50:10 <sx_> merijn: I will probably look into that. I've seen a talk on Idris on youtube, but wasn't that satisfied, also the swapped : and :: puzzled me. :)
14:50:13 <benzrf> hrg
14:50:54 <merijn> benzrf: Although you should probably be reasonably comfortable with simply typed LC and typing formula's to get that
14:51:05 <merijn> sx_: Actually, haskell has swapped : and :: :p
14:52:01 <merijn> sx_: Standard ML, ocaml, etc. all used : for type signatures and :: for list consing. The haskell committee decided "you probably cons more often than you write types, so let's switch to save characters" (and to be fair, : is much nicer in lists)
14:52:22 <merijn> But in Idris you write more type signatures, so they went back to the ML/Coq way of writing
14:52:27 <hpc> i like that (::) draw more attention to type signatures
14:52:34 <sx_> merijn: Which is probably wrong, i write more signatures than consing.
14:52:50 <hpc> how often do you go "oh, i really wish i had just one more column of text for this type signature"?
14:53:05 <hpc> the number of characters typed is a red herring
14:53:35 <merijn> hpc: Sure
14:54:00 <merijn> But with bleeding together of types and terms you write a lot more 'inline' types
14:55:31 <IRWolfie-> hpc: I checked out map, but now I'm left with a [IO [()]], which seems further away from my desired IO ().
14:55:40 <merijn> :t sequence_
14:55:41 <lambdabot> Monad m => [m a] -> m ()
14:55:43 <merijn> Also
14:55:45 <merijn> :t mapM_
14:55:46 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
14:55:56 <merijn> (see sequence and mapM if you wanna keep the results)
14:56:22 <hpc> also forM
14:56:47 <hpc> > forM ["/etc/shadow", "/etc/passwd"] (\f -> readFile f)
14:56:49 <lambdabot>  <IO [[Char]]>
14:57:17 <merijn> A list of [()] seems rather odd, though >.>
14:57:36 <merijn> eh, I guess the "list" in that sentence is redundant :p
14:58:43 <jle`> IRWolfie-: sequence_ :: [IO ()] -> IO ()
14:58:46 <sinelaw> merijn, it was [[Char]], so not
14:58:47 <sinelaw> :)
14:59:14 <jle`> the reuslting `IO ()` represents sequencing all of the original IO ()'s in order one after the other
14:59:30 <merijn> sinelaw: Not in IRWolfie-'s type
14:59:42 <sinelaw> ah ok
15:00:01 <jle`> [()] is haskell's Nat type of course
15:00:45 <jle`> ...and they said we didn't have a built in nat type
15:01:32 <merijn> We do...
15:01:34 <merijn> :k 1
15:01:36 <lambdabot> GHC.TypeLits.Nat
15:01:43 <quchen> Here comes [forall a. a] and spoils jle`'s party
15:01:53 <IRWolfie-> forM is not in prelude? It's a difficult thing to google for
15:02:03 <quchen> IRWolfie-: Control.Monad
15:02:06 <jle`> try hoogle :)
15:02:09 <jle`> @hoogle forM_
15:02:11 <merijn> IRWolfie-: Tip: abandon Google, switch to Hoogle
15:02:11 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
15:02:12 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
15:02:15 <merijn> @where hoogle
15:02:16 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
15:02:21 <merijn> IRWolfie-: Even lets you search by type
15:02:33 <merijn> @hoogle [IO ()] -> IO ()
15:02:35 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
15:02:35 <lambdabot> Test.QuickCheck.Test safely :: State -> IO () -> IO ()
15:02:35 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
15:02:38 <merijn> hmm
15:02:46 <merijn> Ok, that one wasn't too useful :p
15:02:49 <IRWolfie-> cool
15:02:50 <quchen> Hayoo really doesn't get the amount of recognition it deserves.
15:02:56 <merijn> @hoogle Monad m=> [m ()] -> m ()
15:02:57 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
15:02:57 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
15:02:57 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
15:03:19 <jle`> neil got there first
15:03:30 <merijn> IRWolfie-: It's also much more useful for finding operators :)
15:03:37 <merijn> jle`: Hayoo can't search by type
15:04:00 <quchen> http://hayoo.fh-wedel.de/?query=a%20-%3E%20b%20-%3E%20a
15:04:00 <jle`> @hoogle (<$>)
15:04:00 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
15:04:00 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
15:04:08 <quchen> merijn: Searched "const" by its type above
15:04:25 <merijn> quchen: ok, maybe hayoo added that, when I started it couldn't
15:04:48 <babilomax> hi, I'd like to download the sources of xmonad, apply a patch to it and then rebuild, can Ido it with cabal?
15:04:49 <ocramz> hej room!
15:05:05 <stool> babilomax, cabal get pkg and it'll download it in .
15:05:22 <stool> oh, nvm
15:05:38 <babilomax> stool: thanks, and then i just have to do make install in the source directory?
15:06:04 <stool> cabal build should work, I think
15:06:21 <stool> Or sometimes there's Setup.hs that can be run with runhaskell.
15:07:04 <dcoutts_> babilomax: yes, just run 'cabal install' in the dir, once you've applied the patch
15:07:28 <dcoutts_> stool: cabal will use that if necessary, you don't need to call it manually
15:09:41 <IRWolfie-> well it compiled with sequence_ anyway
15:10:26 <hexagoxel> babilomax: you also can download the darcs repository via `cabal get -s head xmonad`, if you want base your patch on current HEAD (or however the darcs term is for this)
15:10:36 <merijn> IRWolfie-: Anyway "sequence_ . map f" is basically "mapM_ f" :)
15:12:46 <benzrf> @src mapM_
15:12:47 <lambdabot> mapM_ f as = sequence_ (map f as)
15:12:53 <IRWolfie-> I dropped using mapM entirely. Did it on what I originally had of "[ blah | i<-[1..a], j<-[1..b]]" style.
15:12:54 <benzrf> not just basically
15:13:00 <jle`> yaay
15:13:43 <babilomax> stool, dcoutts_ hexagoxel: ok, thanks to all
15:13:55 <babilomax> I'll give it a try
15:15:04 <brushbox> geekosaur: thanks, for the pointer. I see this (amongst other things) when running otool: Load command 24
15:15:04 <brushbox>           cmd LC_RPATH
15:15:05 <brushbox>       cmdsize 80
15:15:06 <brushbox>          path /Users/mark/Projects/hp/build/package/mtl-2.1.3.1/build/dist/build (offset 12)
15:15:33 <brushbox> (btw, let me know if I should be using gists or pastie for multiline posts)
15:15:35 <geekosaur> ouch
15:15:44 <geekosaur> @paste is preferred, actually
15:15:45 <lambdabot> Haskell pastebin: http://lpaste.net/
15:15:58 <brushbox> That path has nothing to do with my system.
15:16:23 <geekosaur> but that sounds like a bug in building mtl (and maybe other packages) for the Platform package on OS X
15:16:49 <merijn> Yeah, especially considering the guy who builds the platform for OSX is called "mark" ;)
15:16:57 <geekosaur> I'd suggest subscribing to the libraries@haskell.org mailing list with this information
15:17:08 <merijn> Which version of the platform is this?
15:17:15 <geekosaur> s/list with/list and sending mail with/
15:17:21 <brushbox> Will do, thanks.
15:18:22 <brushbox> merijn: how do I tell? I installed this fairly recently (July). It is at least 2014.1 … not sure when .2 came out.
15:22:06 <merijn> That should be fine, I think
15:34:53 * hackagebot deepseq-bounded 0.6.0.0 - Bounded deepseq, including support for generic deriving  http://hackage.haskell.org/package/deepseq-bounded-0.6.0.0 (AndrewSeniuk)
15:34:55 * hackagebot seqaid 0.2.0.0 - Dynamic strictness control, including space leak repair  http://hackage.haskell.org/package/seqaid-0.2.0.0 (AndrewSeniuk)
15:34:57 * hackagebot leaky 0.2.0.0 - Robust space leak, and its strictification  http://hackage.haskell.org/package/leaky-0.2.0.0 (AndrewSeniuk)
15:36:55 <geekosaur> brushbox: if you want to get that working now, you can use install_name_tool to replace the incorrect rpath in the mtl dylib with the correct one. (something like: install_name_tool -change /Users/mark/Projects/hp/build/package/mtl-2.1.3.1/build/dist/build /Library/Haskell/ghc-7.8.3-x86_64/lib/mtl-2.1.3.1 /Library/Haskell/ghc-7.8.3-x86_64/lib/mtl-2.1.3.1/libHSmtl-2.1.3.1-ghc7.8.3.dylib)
15:38:24 <merijn> Although I'd be worried of this being signs of more fundamental brokenness somewhere
15:54:57 <Rotaerk> hmm is there something in the linear package for combining, say, two V1's into a V2
15:55:06 <Rotaerk> or a V1 and a V3 into a V4
15:56:21 <Welkin> like in GLSL?
15:56:59 <Rotaerk> yea
15:57:18 <Rotaerk> it provides a "lerp" function, but I only need to lerp one of the dimensions
15:57:25 <Welkin> I haven't used the linear package yet, so I can't say
15:57:26 <Rotaerk> and it doesn't work on scalars
15:57:39 <Rotaerk> but I can pack the scalar into a V1
15:58:02 <Welkin> you could always write your own function to unpack and repack them elements
15:58:12 <Welkin> the elements*
15:58:36 <Rotaerk> yea
15:58:45 <Welkin> there aren't too many cases to cover
16:04:44 <Rotaerk> Welkin, I guess that's what these R1-R4 lenses are for
16:05:38 <bramgg> Is it possible to do something like `a (<- b)` rather than `c <- b` on one line and `a c` below it?
16:06:06 <Rotaerk> well nm, they don't take V1's for the R1 class
16:06:09 <shachaf> a =<< b
16:06:18 <ab9rf> ^ beat me to it
16:06:19 <bramgg> thanks
16:07:47 <ab9rf> you can also do b >>= a
16:07:49 <ab9rf> if you prefer
16:07:53 <shachaf> Or something like join (a <$> b), which maybe extends better to functions with multiple arguments or something.
16:08:05 <jle`> =<< looks really nice with do notation syntax thogh
16:08:10 <jle`> x <- y =<< z
16:08:13 <jle`> kind of like a super arrow
16:08:43 <jle`> if only (<=<)'s association were different so that we could do things like
16:08:52 <jle`> x <- f <=< g <=< h =<< m
16:09:14 <geekosaur> merijn: I imagine it's just that OS X provides install_name_tool exactly for this reason; since it bakes pathnames into dylibs and executables referencing them, making a distributable package usually requires rewriting the paths from build to install paths
16:10:06 <geekosaur> specifically for this case there's some stuff you can do to rpaths to make them work relative to frameworks
16:10:29 <jle`> i guess you could just do x <- f =<< g =<< h =<< m, which already associates correctly
16:10:41 <jle`> but that's kind of awkward, like doing f $ g $ h $ x
16:10:59 <ocramz> a page of a library by ekmett is like a crash course in typeclasses : http://hackage.haskell.org/package/linear-1.16.1/docs/src/Linear-V3.html#V3
16:12:25 <timpani> Any reason why Maybe is not a MonadIO?
16:13:04 <gcganley> :t filter
16:13:05 <lambdabot> (a -> Bool) -> [a] -> [a]
16:13:24 <shachaf> Why would Maybe be MonadIO?
16:13:27 <Rotaerk> timpani, Maybe isn't capable of IO
16:13:33 <geekosaur> Maybe is not a monad transformer. did you mean MaybeT?
16:13:38 <gcganley> would the funtion 'until' be 'not filter
16:13:46 <Rotaerk> MonadIO m => MaybeT m  is a MonadIO
16:13:50 <gcganley> :t filterUntil
16:13:52 <lambdabot> Not in scope: ‘filterUntil’
16:14:18 <gcganley> @hoogle (a -> Bool) -> [a] -> [a]
16:14:20 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
16:14:20 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
16:14:20 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
16:14:33 <gcganley> :t until
16:14:35 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
16:14:46 <johnw> gcganley: what are you looking for?
16:15:08 <jle`> timpani: Maybe is not a MonadIO because you can't really represent arbitrary IO actions returning a as a `Maybe a`
16:15:15 <jle`> at least not in a meaningful way
16:15:24 <rcharles> does anyone have any good recommendations for learning category theory?
16:15:34 <jle`> can you try to encode/represent "getLine" as a `Maybe ()`?
16:15:35 * shachaf chooses to interpret Rotaerk as "MonadIO m => (MaybeT m. is a MonadIO)" so the statement makes sense.
16:15:38 <gcganley> johnw: im looking to test a list and keep all the element that mach a funciton (a -> Bool) until it fails and then drop the rest of the list
16:15:47 <timpani> I naively thought one could extract the 'a' out of 'IO a' and wrap it in a Just.
16:15:50 <timpani> No?
16:15:53 <gcganley> :t takeWhile
16:15:54 <lambdabot> (a -> Bool) -> [a] -> [a]
16:15:59 <jle`> timpani: there is no `a` in an `IO a`
16:16:01 <gcganley> maybe takeWhile...
16:16:04 <johnw> ye
16:16:05 <johnw> s
16:16:14 <Rotaerk> shachaf, lol
16:16:15 <ocramz> @src dropWhile
16:16:15 <lambdabot> Source not found. Wrong!  You cheating scum!
16:16:34 <jle`> @quote bin/ls
16:16:34 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
16:16:37 <ocramz> @src filter
16:16:37 <lambdabot> filter _ []     = []
16:16:38 <lambdabot> filter p (x:xs)
16:16:38 <lambdabot>     | p x       = x : filter p xs
16:16:38 <lambdabot>     | otherwise = filter p xs
16:16:47 <ocramz> ez
16:16:53 <gcganley> ocramz: it looks like takeWhile is what im looking for
16:17:05 <johnw> rcharles: Bartosz Milewski has started a series of articles you might lik
16:18:09 <ocramz> @src takeWhile
16:18:09 <lambdabot> takeWhile _ []                 = []
16:18:09 <lambdabot> takeWhile p (x:xs) | p x       = x : takeWhile p xs
16:18:09 <lambdabot>                    | otherwise = []
16:18:17 <rcharles> thanks, johnw
16:18:19 <shachaf> rcharles: I like Leinster's recent book, _Basic Category Theory_.
16:18:24 <ocramz> which is the dual of dropWhile
16:18:45 <gcganley> ocramz: yeah that was my exact source for the 'until' function i wrote
16:20:55 <ocramz> Rotaerk: I see your interest in linear, perhaps you have some experience with (preferably sparse) linear algebra libraries?
16:21:57 <Rotaerk> ocramz, not really; I just started using it to make interacting with gl easier for matrices
16:23:20 <rcharles> shachaf: i'll take a look. Has knowledge of category theory helped you in better understanding Haskell?
16:23:48 <johnw> it does make some of the literature more accessible
16:23:59 <johnw> but I wouldn't call it a requirement by any means
16:24:13 <johnw> I know plenty of successful Haskellers who could barely rub two morphisms together
16:24:51 <gcganley> rcharles: if i could interject reading some of the cat theory literature has helped me understand cat theory influenced things such as monads and arrows.
16:25:43 <rcharles> johnw: It's just my pattern of learning... I am better able to understand and in turn retain the concepts in haskell if by learning the theoretical underpinnings:)
16:26:01 <johnw> then I'd say you'll enjoy it
16:29:42 <rcharles> gcganley: can you list some of the literature that you found helpful?
16:32:55 <gcganley> rcharles: just random stuff from blogs. anything by edward kmett. I'll look in iBooks right now
16:33:21 <rcharles> gcganley: thank you.
16:34:09 <gcganley> rcharles: but its totally not needed to use the various typeclasses such as monad effectfully. I used monads way before i had even heard of cat theory and could use them quite comfertably. so the knowlage isnt required
16:36:29 <rcharles> gcganley: agreed. i too have a solid understanding of Monads, Fuctors, Monoids etc, but sometimes I find them hard to explain to others and sometimes even to myself on what exactly they are and why they are needed. To fill in these gaps I decided to jouney into Category theory
16:39:24 <gcganley> rcharles: hmm i never really took that approach. even though i know how they work i look at blogs for people just leaning what monads are and how to use them. sometimes i find some intuition that i never thought of. i stay on this channel quite a bit and the collective outpour of knowlage when trying to help begginers helps me also
16:39:43 <gcganley> rcharles: also the typeclassopedia is a hoot to read
16:41:25 <shachaf> "In subjects such as number theory and combinatorics, some questions are simple to state but extremely hard to answer. Basic category theory is not like that. To understand the question is very nearly to know the answer."
16:41:52 <gcganley> shachaf: who said that?
16:42:15 <gcganley> its very true in my mind
16:42:23 <shachaf> Tom Leinster
16:42:42 <gcganley> like to understand what the hell the (>>=) operator does is more than half the battle
16:42:55 <benzrf> gcganley: yes, it works much better if you try to understand join
16:43:00 <benzrf> join is far more intuitive
16:43:09 <gcganley> :t join
16:43:10 <lambdabot> Monad m => m (m a) -> m a
16:43:17 <benzrf> then you can just view (>>=) as fmap + join
16:43:39 <gcganley> benzrf: i never got started with join and fmap. i know you can define monad in terms of fmap, join, and return
16:43:44 <gcganley> but not much more than that
16:44:20 <gcganley> :t fmap join
16:44:21 <lambdabot> (Functor f, Monad m) => f (m (m a)) -> f (m a)
16:44:25 <gcganley> lol
16:44:35 <gcganley> :t join . join
16:44:37 <lambdabot> Monad m => m (m (m a)) -> m a
16:44:45 <benzrf> :t \x f -> join (fmap f x)
16:44:46 <lambdabot> (Functor m, Monad m) => m a1 -> (a1 -> m a) -> m a
16:45:27 <gcganley> :t (>>=)
16:45:28 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:45:33 <gcganley> huh, interesting
16:45:47 <gcganley> @pl \x f -> join (fmap f x)
16:45:47 <lambdabot> (join .) . flip fmap
16:46:14 <gcganley> i love how lambdabot mangles a function
16:46:14 <benzrf> gcganley: any implementation of bind necessarily contains a redefinition of fmap
16:46:37 <gcganley> benzrf: redefinition?
16:47:09 <gcganley> benzrf: you ccant just take Functor's fmap you have to create a Monad fmap?
16:47:32 <benzrf> gcganley: well
16:47:42 <benzrf> gcganley: basically
16:47:51 <gcganley> benzrf: why...
16:48:05 <benzrf> gcganley: if "join" were a monad class method, then you could define (>>=) as a normal external function
16:48:09 <benzrf> with
16:48:14 <benzrf> x >>= f = join (fmap f x)
16:48:22 <Rotaerk> someList >>= someFunc, basically fmaps someFunc across someList, producing a list of lists... and then join merges all the lists into one
16:48:25 <benzrf> so (>>=) is basically fmap for the type plus join for the type
16:48:35 <benzrf> therefore, its implementation must implement fmap and join
16:49:06 <benzrf> any implementation of (>>=) can be refactored into x >>= f = join (fmap f x) where join = ...; fmap = ...
16:49:13 <benzrf> where fmap is a valid functor instance
16:49:15 <monochrom> from (>>=) you can recover fmap
16:49:35 <benzrf> of course sometimes you can fuse away code when you write them in one definition
16:49:50 <benzrf> but at some level you have to think about both the fmap and the join functionalities
16:51:19 <monochrom> for the [] monad, x >>= f = concat (map f x), which is source code for what Rotaerk said
16:52:15 <monochrom> this equation is generalizable because you just s/concat/join/ and s/map/fmap/ for universal truth.
16:52:53 <CrazyM4n> Is there a dropIf kind of function?
16:53:00 <Welkin> dropWhile
16:53:04 <CrazyM4n> Like, it drops something from a list if it meets a predicate
16:53:05 <Welkin> oh
16:53:06 <Welkin> filter
16:53:11 <CrazyM4n> Thanks
16:53:18 <Welkin> filter (not predicate)
16:53:23 <CrazyM4n> Yeah, that's it
16:53:42 <Rotaerk> not . predicate *
16:55:49 <CrazyM4n> Ugh, I'm really drawing a blank. What's the function that checks if something exists in another list?
16:56:03 <shachaf> What would its type be?
16:56:09 <CrazyM4n> elem, never mind lol
16:57:24 <Welkin> CrazyM4n: you can always look on hackage
16:57:28 <mniip> CrazyM4n, you wouldn't beleive how comfortable is type-searching if you don'thave any idea on what the function could be named
16:57:38 <Welkin> http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-List.html
16:57:56 * glguy also knew the answer
16:58:16 <CrazyM4n> yeah, that's how I found it haha
16:58:36 <monochrom> types are the digital divide between those who are successful in haskell and those who are lost.
16:58:37 <CrazyM4n> I just haven't touched haskell in like a month and a half and it's not the easiest language to just start rolling stuff out in
16:58:42 <mniip> just slap '[a] -> a -> Bool' into hoogle and it works
16:58:53 <mniip> (even tho the arguments are reversed)
16:59:31 <mniip> CrazyM4n, practical problems are quite hard in haskell generally :P
16:59:40 <CrazyM4n> heh
17:03:50 <Cale> I don't think practical problems are any harder in Haskell than anything else.
17:04:00 <gcganley> :t all
17:04:01 <lambdabot> (a -> Bool) -> [a] -> Bool
17:04:15 <Rotaerk> you can practically code in haskell like you would in C if you wanted to
17:04:30 <Cale> It's just if you're a beginner, it takes some time to get to the point where you know enough of the language to do practical work. That's also pretty true if you start with any other language though.
17:05:27 <Cale> It's just that if you already know other imperative languages, you might be used to being able to pick up another one easily, because they're practically reskinnings of each other relative to Haskell.
17:06:14 <Welkin> It took me months to become comfortable in haskell
17:06:23 <MP2E> Also some practical tasks are actually easier in Haskell IMO
17:06:34 <MP2E> take parsing/lexing and interpreters for instance
17:06:43 <MP2E> i think that's much more managable in Haskell :P
17:06:46 <Cale> Yeah, it took me about 2 months to get to the point where I felt like I could do practical work, and about a year to be "comfortable"
17:06:58 <benzrf> haskell is downright delightful for many things
17:07:03 <Cale> But I feel like that's not an unreasonable amount of time for learning to program :)
17:07:09 <benzrf> but one thing it's just not good at is certain kinds of scripting tasks
17:07:13 <benzrf> or more generally
17:07:26 <Cale> benzrf: Like what sort?
17:07:29 <benzrf> programs that are mostly about certain effects with relatively little repetition or business logic
17:07:35 <Cale> I actually like using Haskell for shell-like tasks
17:07:46 <Welkin> translating imperative algorithms into haskell generally doesn't work
17:07:58 <benzrf> if you have a task with little room for abstraction that is primarily effectful, haskell doesnt give you much over something like ruby
17:08:08 <benzrf> imho
17:08:10 <Cale> Welkin: It can work if you know how to translate, but yeah, it's not terribly direct.
17:08:32 <glguy> Or it works if you don't try to translate it to a different algorithm but as a direct translation of the original algorithm
17:09:36 <Cale> Welkin: One extremely mechanical approach for translating imperative algorithms is to turn each point of control into a function, and the mutable variables in scope into function parameters
17:09:43 <CrazyM4n> I use haskell for completely different reasons for what I use, say, ruby for
17:10:03 <rvxi> would you guys recommend using/avoiding ihaskell?
17:10:04 <jle`> hasell is my most practical language
17:10:06 <Cale> and then have the functions apply each other to indicate control flow, with updated values of the parameters when mutable variables are updated
17:10:12 <Welkin> Cale: that's what I have been doing to slowly transform imperative algorithms into more functional ones
17:10:14 <dmwit> rvxi: yes
17:10:31 <exio> I'd say given enough Haskell, you start feeling unproductive in other languages ;P
17:10:40 <Cale> This will result in something which is quite messy, but once you're done, you can usually start to simplify it quite rapidly by making algebraic substitutions
17:10:57 <Cale> I've done that a bunch in order to understand weird C programs
17:11:05 <Welkin> for-loops become folds, while-loops become recursive calls, and I break out if-else blocks into locally defined functions in a where clause
17:11:23 <Cale> Yeah, that's a higher level approach than what I'm talking about :)
17:11:33 <Cale> Well, at least initially
17:11:54 <rvxi> dmwit: trying to get it up and running, running into linker errors with iconv so far
17:11:56 <Cale> Eventually with my approach, you might want to think about introducing folds and other higher order functions
17:12:07 <Cale> But you just start out with a bunch of mutual recursion
17:13:13 <CrazyM4n> For quick, use them once then throw them out scripts, I don't think haskell is a very good language
17:13:18 <Cale> But yeah, the idea that loops should somehow turn into (operations on) lists is pretty good.
17:13:27 <dmwit> rvxi: I'm sorry. I didn't see the "i" in "ihaskell" in your question, and thought you were about to start one of Those Conversations.
17:13:40 <rvxi> haha
17:13:56 <Cale> CrazyM4n: Such scripts have a tendency to turn into longer term things and maintaining them at that point becomes way more painful if they're written in bash or something.
17:15:01 <CrazyM4n> Cale: Ew, maintaining bash scripts is disgusting. I'm just saying that it's a little bit more involved to write haskell
17:15:35 <exio> I'd say the strong type system of haskell would have made most my mistakes with bash scripts a compile-time error
17:15:41 <Cale> Slightly, maybe. If something is a single short line in bash to run some other existing program, I probably won't make a Haskell script for it.
17:15:59 <rvxi> still learning the basics... the difference between what's valid in interactive mode vs. a source code file is a bit confusing. Is there some rationale for the distinction?
17:16:25 <Cale> btw, has everyone seen propellor?
17:16:29 <rvxi> why is "let" needed in interactive mode but not in a source file for =?
17:16:44 <Cale> http://hackage.haskell.org/package/propellor -- this is pretty cool :)
17:17:01 <Cale> https://propellor.branchable.com/ -- more info here
17:17:31 <dmwit> rvxi: ghci is like a big, open-ended do-block at the bottom of whatever module is loaded
17:19:43 <horny-sama> omfg, been learning haskell since jan 12 ish and assignment due on feb 6
17:19:51 <horny-sama> and I still feel like I don't know haskell :<
17:20:03 <dmwit> OMG, two whole weeks and you're not an expert yet?!?
17:20:11 <horny-sama> dmwit: lol
17:20:20 <CrazyM4n> gg monads too hard
17:20:31 <horny-sama> now I am starting to worry
17:20:35 <dmwit> http://norvig.com/21-days.html
17:20:45 <horny-sama> and the bad news is I seems to know the most haskell in my team
17:20:46 <horny-sama> :<
17:20:54 <ab9rf> it took me about six weeks to get to the point that i was comfortable with haskell
17:21:13 <Cale> I think it took me about 2 months of playing around with Haskell to feel like I could do useful stuff, and about a year to really be comfortable.
17:21:16 <ab9rf> and then about six weeks more to realize i didn't understand a damn thing
17:21:18 <horny-sama> but with the hw due soon
17:21:29 <horny-sama> me and my team are fuck
17:21:36 <CrazyM4n> I've "known" it for about a year, but still don't feel very comfortable with it
17:21:42 <exio> Cale: which background (in FP) you had before Haskell?
17:21:53 <ab9rf> horny-sama: nah, i doubt your assignment requires a deep understanding
17:22:06 <Cale> exio: Not much. I knew a dozen or two imperative languages, and I'd played around with Scheme a bit.
17:22:25 <ab9rf> haskell was my first experience with FP
17:22:48 <Cale> Well, the Scheme stuff was around the same time I was starting with Haskell too
17:22:55 <horny-sama> ab9rf: here is my assignment and I think it requires deep understanding http://kremer.cpsc.ucalgary.ca/courses/cpsc449/W2015/assnHaskell.html
17:23:04 <horny-sama> so far I am the only one contributing
17:23:06 <ab9rf> i don't know why people call scheme a 'functional language' but whatever
17:23:08 <horny-sama> like taking user input
17:24:06 <Cale> ab9rf: Well, it can support functional programming to some extent
17:24:10 <qz> Cale, how many of your shell-script like haskell programs have main wrapped in RWS? almost all, none, half?
17:24:16 <Cale> qz: none
17:24:28 <qz> damn, i must be doing something wrong
17:24:33 <horny-sama> tell me I don't have good reason to panic
17:24:34 <horny-sama> :<
17:24:39 <yohanobs> hi guys
17:24:42 <Cale> I don't think I've ever used RWS
17:24:46 <horny-sama> despite reading haskell and programming haskell everyday
17:24:55 <CrazyM4n> horny-sama: You were given http://kremer.cpsc.ucalgary.ca/courses/cpsc449/W2015/Othello.hs, which is a lot of the bulk of it imho
17:24:57 <Cale> (in a real program)
17:24:57 <yohanobs> i am noob here
17:25:06 <qz> what are you using for stuff like db connection that has to live thoughout whole program for example?
17:25:09 <Cale> yohanobs: Welcome! Let us know if you have any questions :)
17:25:12 <ab9rf> Cale: i suppose it's becuase my main use of scheme was as an imbedded scripting language
17:25:21 <horny-sama> CrazyM4n: but the flipping 45 degree part is killing us
17:25:44 <CrazyM4n> why is that?
17:25:51 <horny-sama> and we have no idea how to manipulate the list in a sense to flip it
17:25:59 <CrazyM4n> ohh
17:25:59 <Cale> qz: Mostly I'll just pass parameters directly -- if that becomes too onerous, I'll package all the configuration up into a record type
17:26:03 <horny-sama> CrazyM4n: we are given the flip 90
17:26:07 <horny-sama> but not 45
17:26:26 <qz> Cale: and that record type then goes where? in parameters still?
17:26:29 <Cale> yes
17:26:43 <Cale> (it just cuts the number of parameters down)
17:27:07 <horny-sama> CrazyM4n: https://github.com/LtGrimms/OthelloAssignment/blob/master/Othello.hs <---what we got so far
17:27:11 <horny-sama> btw mr-fool is me
17:27:15 <horny-sama> the only contributor atm
17:27:17 <Cale> IO already has a lot of facilities for state if you need it.
17:27:18 <ab9rf> wrapped in RWS?
17:27:41 <horny-sama> I need to take a shit back in 5-10 mins
17:27:43 <qz> Cale: what kind of? because managing global state is my biggest frustration with haskell so far
17:27:49 <ab9rf> i only "wrap" something in a monad if i need it
17:27:57 <Cale> Like, IORefs and such
17:28:08 <ab9rf> qz: dependency injection is your friend
17:28:36 <Cale> Isn't dependency injection just a fancy buzzword for function parameters?
17:28:40 <ab9rf> Cale: yes
17:29:06 <qz> DI is a buzzword for implicit parameters mostly =p
17:29:18 <ab9rf> well, more just for the idea that you should pass "global" state as a parameter instead of grabbing it from wherever
17:29:22 <qz> if i have to pass my environment everywhere by hand it becomes annoying pretty soon
17:29:23 <exio> is there anything that is actually _implicit_ in Haskell?
17:29:25 <Cale> I don't tend to care about having a few explicit parameters to deal with
17:29:34 <exio> even implicit parameters are explicit in the type?
17:29:35 <ab9rf> Cale: neither do i
17:29:36 <Cale> You can use implicit parameters if you really want them
17:29:56 <Cale> But I find it's something that people stress out about way more than it actually causes trouble
17:30:05 <ab9rf> qz: when you use a global environment, you're effectively passing it everywhere anyway.  why not just make it explicit?
17:30:11 <Cale> and the explicit parameters do have benefits as well
17:30:31 <Cale> I'd much rather be passing a parameter or two around than have to lift all my real IO actions explicitly
17:30:39 <Cale> At least in most cases
17:30:47 <ab9rf> makes unit testing simpler, too
17:30:57 <horny-sama> back
17:31:00 <horny-sama> any tips
17:31:08 <horny-sama> guys on the flipping 45 degrees part?
17:31:23 <mietek> ANN: Halcyon and Haskell on Heroku
17:31:24 <mietek> http://article.gmane.org/gmane.comp.lang.haskell.general/20499
17:31:25 <Cale> > transpose [[1,2,3],[4,5,6],[7,8,9]]
17:31:28 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
17:31:59 <qz> ab9rf: so you are passing that environment to all functions by hand too? coming from languages with global vars and stuff it seems weird to me..
17:32:07 <ab9rf> the 45-degree rotation requires reshaping the matrix
17:32:08 <Cale> horny-sama: ^^ is that what you mean by "flipping 45 degrees"?
17:32:19 <ab9rf> qz: yes, it does, and it's a bad habit that you should break :)
17:32:24 <Cale> 45 degree rotation?
17:32:28 <horny-sama> Cale: it is a board game so it is a 2d list
17:32:35 <ab9rf> qz: global dependency is bad in every language.  haskell just makes it more obvious how bad it is
17:32:59 <horny-sama> Cale: flip 45 degree rotation
17:33:04 <qz> ab9rf: well, it depends. for example its convenient to have global logger instead of carrying it around manually
17:33:06 <jle`> can you give us an example of an input and an output
17:33:10 <dmwit> Cale: That's 90 degrees
17:33:26 <Zemyla> Does the ReadS type have a wrapper that turns it into a monad?
17:33:38 <dmwit> Zemyla: There's ReadP
17:33:39 <qz> ab9rf: same goes for db connection, config file stuff.. etc
17:33:40 <Cale> dmwit: Uh, it's a reflection along a line which is angled (negative) 45 degrees...
17:33:45 <MP2E> qz: That's what our various datatypes + Monads are for :) If you want global immutable state use Reader, if you want a log that is appended to during execution you use Writer, and if you need global variables you use State
17:33:50 <Welkin> a transpose?
17:33:56 <Cale> I don't really understand what it means to rotate a list of lists by 45 degrees
17:34:03 <dmwit> Cale: You're right, of course. Either way it's not a 45 degree rotation. =)
17:34:05 <ab9rf> qz: Writer handles logging fairly simply.
17:34:09 <Welkin> I assume a transpose
17:34:10 <horny-sama> Cale, ab9rf: the tip that my prof given us http://www.fpaste.org/174531/22359471/
17:34:12 <jle`> dmwit: it's not a 90 degree rotation either ;D
17:34:24 <ab9rf> Cale: i'm not sure exactly what a 45 degree rotation is on a square matrix.
17:34:35 <jle`> reminds me of that mathematica joke...
17:34:36 <Cale> dmwit: Right, I'm trying to understand what it is that he's after, and I highly doubt that it's *actually* a 45 degree rotation
17:34:41 <dmwit> Cale: The setup is Othello; you want to find chips on a diagonal on the board.
17:34:57 <dmwit> Cale: So I would say whate he wants could reasonably be called a 45 degree rotation.
17:35:01 <Cale> oh, okay
17:35:04 <Cale> Maybe he does
17:35:09 <qz> MP2E: yeah, but then lifting... and i was just told that its better to pass those to each function manually
17:35:25 <kranius> @t (if')
17:35:26 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
17:35:31 <Cale> Yeah, all right, with that pasted comment it seems like that's really what you're after
17:35:34 <horny-sama> reading his haskell code is enough to give me headache
17:35:37 <kranius> @type (if')
17:35:38 <lambdabot>     Not in scope: ‘if'’
17:35:38 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
17:35:42 <jle`> where someone tried to rotate a matrix by doing Rotate[mat, 45]
17:35:57 <dmwit> jle`: and gets the word "mat" at an angle? =)
17:35:58 <jle`> thining that it would rotate a 2x2 matrix using the linear transformation
17:36:04 <jle`> dmwit: it printed out his matrix at an angle
17:36:07 <kranius> @pl filter' p = foldr (\x xs -> if p x then x : xs else xs) []
17:36:07 <jle`> haha
17:36:07 <lambdabot> filter' = flip foldr [] . flip flip id . (ap .) . (`ap` (:)) . (((.) . if') .)
17:36:12 <dmwit> jle`: even worse =D
17:36:14 <jle`> like, the actual picture of the matrix
17:36:15 <Cale> jle`: hehe, yes
17:36:28 <narciero> logout
17:36:28 <horny-sama> transpose is 90 degrees?
17:36:29 <kranius> what is the (if') from @pl ?
17:36:42 <jle`> kranius: it's a helper function
17:36:43 <shachaf> if' b x y = if b then x else y
17:37:10 <CrazyM4n> How can I put a let thingy inside a do block? The compiler doesn't seem to be having any of it
17:37:10 <Cale> horny-sama: no, transpose isn't a rotation (at least in 2D), it's a reflection along the diagonal
17:37:16 <jle`> there's a flipped version of it in Data.Bool if you want; bool y x b = if' b x y
17:37:22 <jle`> a weirdly flipped version
17:37:23 <Cale> horny-sama: It still might be useful to you
17:37:26 <jle`> maybe i should say permuted
17:37:40 <horny-sama> 2 weeks of haskell and he expect a group of 5 noobs to be able to finish the assignment
17:38:04 <Zemyla> Because it seems really simple. If r is a ReadS, then r >>= f = concatMap (uncurry f) . r
17:38:16 <kranius> jle`, shachaf thanks
17:38:16 <dmwit> jle`: It's not weird. It's the catamorphism.
17:38:47 <jle`> dmwit: heh, i meant that it was difficult to describe the manner of the flip with respect to if'.  but yea
17:38:49 <dmwit> horny-sama: Freaking out about it doesn't seem to be generating a lot of progress. Perhaps you could direct your energy to something more useful.
17:39:15 <jle`> @pl \y x b -> g b x y
17:39:15 <lambdabot> flip (flip . flip g)
17:39:22 <horny-sama> dmwit: the strategy part is equally bad
17:39:37 <dmwit> > do let {x=3}; 3 -- CrazyM4n
17:39:39 <lambdabot>  3
17:39:49 <abg> I'm trying to write an integration test with Hspec and QuickCheck. It's interacting with an external store, so I want it to use a different namespace for each test. Is there a way to require that QuickCheck generate a value that has not already been generated in the current session?
17:40:10 <dmwit> > do let x=3 in x -- Also fine
17:40:12 <lambdabot>  3
17:40:25 <Zemyla> And return = curry (:[]).
17:40:39 <haasn> > do 3
17:40:40 <lambdabot>  3
17:40:49 <dmwit> Though the latter requires an expression after the `in` and in particular if you want  more do-block needs an extra `do`.
17:40:53 <Zemyla> :t let x = x in x
17:40:54 <lambdabot> t
17:41:01 <CrazyM4n> wow. the compiler was just mad that I aligned the start of "let" and "in" instead of aligning the end
17:41:14 <CrazyM4n> okay compiler :(
17:41:34 <Cale> > transpose [drop n xs | (n,xs) <- zip [0..] [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]]
17:41:36 <lambdabot>  [[1,6,11,16],[2,7,12],[3,8],[4]]
17:41:48 <Cale> > transpose [drop n xs | (n,xs) <- zip [0..] (transpose [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]])]
17:41:50 <lambdabot>  [[1,6,11,16],[5,10,15],[9,14],[13]]
17:41:55 <dmwit> > do { let {x = 3}; in 5 } -- CrazyM4n, this is what the compiler thought of your code with let/in aligned, probably
17:41:57 <lambdabot>  <hint>:1:19: parse error on input ‘in’
17:42:16 <CrazyM4n> dmwit: That was exactly what it thought
17:42:47 <Cale> horny-sama: ^^ there are some of the diagonals for you
17:42:57 <kranius> is there a general term for map filter and folds ? they seem to express the same behavior
17:43:13 <Cale> kranius: Well, map and filter can be written in terms of foldr
17:43:18 <horny-sama> Cale: is transpose a build in library function?
17:43:24 <kranius> Cale: yeah I meant that
17:43:30 <Cale> kranius: But they're all examples of higher order functions on lists
17:43:34 <kranius> but
17:43:43 <Cale> horny-sama: Yes, it's in Data.List
17:44:17 <CrazyM4n> Cale: if I would have known about transpose about 2 months ago that would have saved me maybe 20 minutes
17:44:22 <dmwit> ?hoogle transpose
17:44:23 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
17:44:23 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
17:44:23 <lambdabot> Data.ByteString.Char8 transpose :: [ByteString] -> [ByteString]
17:44:44 <CrazyM4n> which sounds like not much in retrospect, but still :P
17:44:48 <Zemyla> Hell, it's even a MonadPlus.
17:45:31 <Cale> :t (\f -> foldr (\x xs -> f x : xs) [])
17:45:32 <lambdabot> (a -> a1) -> [a] -> [a1]
17:45:36 <Cale> ^^ map
17:45:55 <Cale> :t (\p -> foldr (\x xs -> if p x then x : xs else xs) [])
17:45:57 <lambdabot> (a -> Bool) -> [a] -> [a]
17:46:00 <Cale> ^^ filter
17:46:46 <Cale> So you could call map and filter "folds" in that sense
17:46:56 <Cale> Though that might be confusing out of context
17:47:27 <ab9rf> you can implement both using foldr, i would think
17:47:37 <MP2E> that's what cale just did
17:47:38 <MP2E> lol
17:47:41 <ab9rf> heh
17:47:46 <ab9rf> you are indeed right
17:47:53 <ab9rf> i was getting coffee, and thus missed that
17:47:57 <MP2E> hehe :>
17:48:18 <ab9rf> (i can blame ANYTHING on coffee)
17:48:26 <Cale> hehehe
17:48:40 <horny-sama> applying jobs is more depressing than trying to use gdb as a debugging tool
17:48:47 <Cale> Lack of coffee, needing to get coffee, too much coffee... there are so many ways to place the blame!
17:48:51 <shachaf> :t getZipList . traverse ZipList -- tranpose!
17:48:52 <lambdabot> Traversable t => t [b] -> [t b]
17:50:25 <dmwit> rotate{Clock,Counter} from http://kremer.cpsc.ucalgary.ca/courses/cpsc449/W2015/Othello.hs makes my heart hurt
17:50:57 <kranius> > foldr (:) [[1],[1,2]] []
17:50:57 <CrazyM4n> there's a reason he put reallyStupidStrategy right above it
17:50:59 <lambdabot>  [[1],[1,2]]
17:51:12 <horny-sama> shower time then more job application
17:51:19 <Zemyla> So the ReadS monad is actually just a nondeterministic state monad.
17:51:25 <Cale> dmwit: lol
17:51:31 <Cale> dmwit: I guess that's one way to do it
17:51:45 <Cale> dmwit: I suppose writing a 45 degree rotation like that wouldn't require too much thought
17:51:50 <dmwit> indeed
17:52:07 <kranius> > foldr (++) [[1],[1,2]] []
17:52:09 <lambdabot>  [[1],[1,2]]
17:52:11 <Cale> (though I already figured out how to do it above, modulo putting the pieces together)
17:52:23 <int-e> dmwit: oh... let me guess... it's efficient?!
17:52:53 <CrazyM4n> it's extendable!
17:52:54 <dmwit> int-e: My guess is it's readable for Haskell newcomers.
17:52:55 <Cale> kranius: The way to think about foldr f z is that it's going to replace each (:) in the list's construction with f, and the [] at the end (if any) with z
17:52:58 <int-e> > map reverse . transpose $ [[1,2],[3,4]]
17:53:00 <lambdabot>  [[3,1],[4,2]]
17:53:13 <int-e> > reverse . transpose $ [[1,2],[3,4]]
17:53:15 <lambdabot>  [[2,4],[1,3]]
17:53:23 <Cale> kranius: See the top left diagram here: http://cale.yi.org/share/Folds.png
17:53:26 <int-e> > transpose . reverse $ [[1,2],[3,4]]
17:53:27 <kranius> > foldr (++) [] [[1],[2,3]]
17:53:27 <lambdabot>  [[3,1],[4,2]]
17:53:29 <lambdabot>  [1,2,3]
17:53:39 <Zemyla> So how does the build function work?
17:53:49 <kranius> lol I misplaced the arguments
17:53:58 <CrazyM4n> I'm surprised "rotateCounter" wasn't just (rotateClock . rotateClock . rotateClock)
17:54:00 <int-e> dmwit: could be. I'd be worried I'd made a typo :)
17:54:40 <Cale> CrazyM4n: What about transpose . rotateClock . transpose?
17:54:56 <int-e> Cale: or reverse . rotateClock . reverse
17:55:10 <Cale> indeed :)
17:55:32 <CrazyM4n> why doesn't he just go the easy route and store a table with all the vectors of where the values should go
17:55:38 <int-e> funny how those two conjugates are the same.
17:55:41 <CrazyM4n> and move the elements based on those vectors
17:55:48 <CrazyM4n> that seems like the obvious route
17:58:37 <int-e> dmwit: actually the rotateC* functions are at least readable. 'replace' looks awful...
17:59:17 <dmwit> yikes
17:59:38 <CrazyM4n> int-e: They read like english, what are you talking about by unreadable?
17:59:53 <CrazyM4n>  /s
18:03:37 <int-e> so  replace [] 0 0 = [0]. Seems useful.
18:04:59 * hackagebot logsink 0.1.0 - A logging framework for Haskell  http://hackage.haskell.org/package/logsink-0.1.0 (jkarni)
18:10:15 <Zefphex> This tickles my fancy
18:23:36 <Welkin> > 3 > Infinity
18:23:37 <lambdabot>  Not in scope: data constructor ‘Infinity’
18:23:42 <Welkin> > 3 > (1/0)
18:23:44 <lambdabot>  False
18:23:53 <Welkin> > (1/0) == (1/0)
18:23:55 <lambdabot>  True
18:24:04 <Welkin> > (1/0) > 0
18:24:06 <lambdabot>  True
18:24:21 <Welkin> :t (1/0)
18:24:22 <lambdabot> Fractional a => a
18:24:28 <ab9rf> > (1/0) < 0
18:24:30 <lambdabot>  False
18:24:34 <Welkin> :t (1/0) :: Int
18:24:35 <lambdabot>     No instance for (Fractional Int) arising from a use of ‘/’
18:24:36 <lambdabot>     In the expression: (1 / 0) :: Int
18:24:36 <ab9rf> > (-1/0) < 0
18:24:38 <lambdabot>  True
18:24:47 <Welkin> :t (1 `div` 0) :: Int
18:24:48 <lambdabot> Int
18:24:56 <Welkin> :t (1 `div` 0) > 23532452356456345
18:24:57 <lambdabot> Bool
18:24:57 <ab9rf> > (-1/-0) < (1/0)
18:24:59 <lambdabot>  Not in scope: ‘/-’
18:24:59 <lambdabot>  Perhaps you meant one of these:
18:24:59 <lambdabot>    ‘-’ (imported from Prelude), ‘/’ (imported from Prelude),
18:25:03 <Welkin> > (1 `div` 0) > 23532452356456345
18:25:05 <ab9rf> feh
18:25:05 <lambdabot>  *Exception: divide by zero
18:25:10 <ab9rf> > ((-1)/(-0)) < (1/0)
18:25:11 <shachaf> Please use /msg lambdabot unless you have something to demonstrate to the channel.
18:25:12 <lambdabot>  False
18:25:19 <glguy> Please don't flood
18:25:36 <Welkin> okay
18:27:27 <Welkin> can Ratio represent arbitrary precision floating point values?
18:27:43 <Hijiri> how much math do I need to know for HoTT?
18:27:45 <Welkin> like a floating-point Integer
18:27:49 <Hijiri> I don't know what homotopy theory is
18:28:00 <ab9rf> Welkin: in the sense that floating point values are a subset of all rational numbers, yes
18:28:09 <ab9rf> Welkin: floating point can't represent irrationals exactly
18:31:27 <Lokathor> i've changed the settings in config/settings.yml, but yesod still always runs the server on port 3000 isntead of the port i've set (8008). Is this a property of the "yesod devel" command?
18:34:18 <Welkin> Lokathor: there are settings for "default", "development", "production", etc.
18:34:24 <Welkin> make sure you changed the right one
18:35:01 * hackagebot Unique 0.4 - It provides the functionality like unix "uniq" utility  http://hackage.haskell.org/package/Unique-0.4 (kapral)
18:35:19 <Lokathor> hmm, i'm setting _env:PORT:8008
18:35:36 <Welkin> ?
18:35:40 <Lokathor> though, stack exchange says i can just use "yesod devel -p 8008" to force the correct port, which works i guess
18:36:02 <Welkin> set it under "port: "
18:36:13 <RyanGlScott> I'm having trouble updating some type family-related code to GHC 7.10.
18:36:21 <Welkin> port, localhost, etc are all on diffrent lines
18:36:24 <Welkin> er
18:36:26 <RyanGlScott> This code: "class NullaryClass where data NullaryData" results in the following error on GHC 7.10-rc1:
18:36:28 <Welkin> port, host, etc.
18:36:33 <Lokathor> yeah, the line is:     port:   "_env:PORT"8008"
18:36:44 <Welkin> no
18:36:48 <Lokathor> er, yeah, the line is:     port:   "_env:PORT:8008"
18:36:52 <Welkin> just "port: 8008"
18:36:56 <RyanGlScott> The associated type 'NullaryData' mentions non of the type or kind variables of the class 'NullaryClass' In class declaration for 'NullaryClass'
18:37:17 <Welkin> without the quotes
18:37:20 <Lokathor> oh... well. Hmm, but that's how it was set by the yesod init.. oh well
18:38:46 <Lokathor> welkin, didn't seem to fix it
18:39:37 <RyanGlScott> Is this a bug, or a difference in how nullary type classes are represented in GHC 7.10?
18:42:01 <RyanGlScott> ...I'm going to assume bug. I'll file a Trac ticket.
18:42:24 <kranius> ask #ghc
18:42:46 <RyanGlScott> kranius: Good idea.
18:42:47 <Cale> RyanGlScott: Uhhh, is there even any point to allowing nullary classes?
18:43:17 <RyanGlScott> Cale: I dunno, but it's legal in GHC 7.8 and not in GHC 7.10, so something's up.
18:43:21 <Welkin> Lokathor: under default? development?
18:43:26 <shachaf> It's funny that "deriving instance Typeable (GHC.Prim.*)" gives you an error if you don't have NullaryTypeClasses on.
18:43:49 <Cale> That's actually an extension?
18:43:52 <shachaf> Same for "deriving instance Typeable BOX".
18:44:01 <Cale> It seems weird to me that it should even exist.
18:44:15 <shachaf> There are justifications for it but I'm not quite sure about them.
18:44:16 <Cale> Maybe classes with a single kind parameter would make sense
18:44:45 <shachaf> The trouble is that if you have a nullary class, either it has no instance or it has an orphan instance.
18:44:50 <RyanGlScott> Cale: Here's an article about it https://ocharles.org.uk/blog/posts/2014-12-10-nullary-type-classes.html
18:45:12 <RyanGlScott> Cale: Even ocharles is unsure of whether it's a good idea or not.
18:45:29 <lpaste> Lokathor pasted “yesod config” at http://lpaste.net/119213
18:45:32 <Cale> Oh, like that...
18:45:50 <Cale> Yeah, that's just awkward. Implicit parameters does the same thing better.
18:45:52 <Lokathor> welkin, it just looks like this, i don't know if that's anything correct or not http://lpaste.net/119213
18:46:04 <shachaf> I'm the one who implemented it and I'm not sure whether it's a good idea.
18:46:12 <shachaf> But it seems silly to disallow it.
18:46:25 <shachaf> The original patch to make it work consisted of deleting three lines of code.
18:46:36 <ab9rf> hehe
18:48:30 <anarcat> hi
18:48:38 <HeladoDeBrownie> shachaf, isn't the instance in "class Foo where { foo :: Integer } ; instance Foo where { foo = 10 }" not an orphan? or is this example incorrect?
18:48:45 <anarcat> when i use emacs' haskell-mode, whever i hit "enter", i get the haskell-mode-hook help
18:48:59 <shachaf> HeladoDeBrownie: Yes, I didn't write what I meant.
18:49:23 <shachaf> HeladoDeBrownie: Either it has an instance in the same module -- in which case it has a unique instance -- or any instances will be orphan.
18:49:34 <HeladoDeBrownie> ah, i see
18:49:57 <anarcat> anyone uses haskell-mode here?
18:49:59 <Zemyla> Also, why is there not at least a wrapper NumF a b = NumF (a->b) such that Num b => NumF a b?
18:50:59 <shachaf> http://hackage.haskell.org/package/NumInstances defines the instance directly, without a newtype.
18:51:24 <Zemyla> Because that would be a really simple thing to do. fromInteger n = NumF $ \_ -> fromInteger n. (NumF fa) + (NumF fb) = NumF $ \a -> (fa a) + (fb a).
18:51:52 <HeladoDeBrownie> shachaf, it occurs to me that something polymorphic over Constraint might have a use for it.
18:52:05 <shachaf> Like what?
18:52:19 <HeladoDeBrownie> i have no idea. i was only making the comparison to things like Void and Identity and came up with that.
18:52:33 <HeladoDeBrownie> so the next step would be figuring out why *that* would be useful, i guess. :P
18:53:52 <jmcarthur> Zemyla: yeah, the NumInstances instances are nice for some things, for sure. i personally like them. some people dislike them because they find it confusing or are afraid it might make some error messages too cryptic or are afraid it would make it easier for the type checker to accept some bugs
18:54:12 <jmcarthur> Zemyla: e.g.   5 6   is likely to be a bug
18:56:30 <Zemyla> jmcarthur: You can't do 5 6, because (a -> b) isn't a Num. Only the newtype wrapper is.
19:03:08 <exio> Zemyla: I'd go with a version a bit more general
19:05:59 <exio> Zemyla: http://lpaste.net/119214
19:18:00 <jmcarthur> Zemyla: the NumInstances package provides an orphan without the newtype wrapper
19:25:11 <dfeuer> @tell hvr Some of the prime sieve code in arithmoi is broken (segfaults). I'm thinking the easiest thing to do is to steal some obviously sane code from NumberSieves to replace it until/unless arithmoi gets a new maintainer.
19:25:11 <lambdabot> Consider it noted.
19:27:15 <dfeuer> @tell hvr Or of course the current maintainer wakes up.
19:27:16 <lambdabot> Consider it noted.
19:30:03 * hackagebot typeparams 0.0.6 - Lens-like interface for type level parameters; allows unboxed unboxed vectors and supercompilation  http://hackage.haskell.org/package/typeparams-0.0.6 (MikeIzbicki)
19:50:04 * hackagebot extensible 0.2.6 - Extensible, efficient, lens-friendly data types  http://hackage.haskell.org/package/extensible-0.2.6 (FumiakiKinoshita)
19:52:13 <Welkin> Lokathor: http://lpaste.net/119213
19:52:24 <Welkin> you have a strange looking settings.yml
19:52:48 <Lokathor> Welkin I just used yesod init and that's what it gave me
19:53:11 <Lokathor> however i will try your version of things
19:53:47 <Welkin> mine is what the scaffolding built
19:53:59 <Welkin> which version of yesod are you using?
19:55:15 <Welkin> I use that for a production site, so I know it works, and it is only a few months old (yesod 1.4)
19:55:22 <Welkin> I cannot imagine anything changed that quickly
19:58:25 <Lokathor> i installed yesod just the other day, version 1.4.3.4
19:58:27 <AshyIsMe> is anyone here using nix on osx? ive just installed it with the install script but don't have nix-env or any other commands on my path
19:58:34 <AshyIsMe> was wondering if there's something simple im missing
19:59:46 <lpaste> Lokathor pasted “No title” at http://lpaste.net/119218
20:00:00 <Lokathor> welkin, using your settings format gave me that error
20:00:20 <Welkin> what version of yesod?
20:00:32 <cosban> version 1.4.3.4, as said above
20:01:10 <Welkin> that version doesn't exist
20:01:17 <Lokathor> ...what?
20:01:33 <Welkin> oh
20:01:35 <Welkin> yesod-bin
20:01:52 <Lokathor> ah yes, sorry, yesod-bin is 1.4.3.4
20:02:32 <Lokathor> yesod itself doesn't seem to show up in ghc-pkg list
20:03:56 <Welkin> I'm using yesod-bin 1.4.0.5
20:04:08 <Welkin> that is odd that such a major change happened
20:04:26 <Welkin> yesod is the library
20:04:44 <Welkin> yesod-bin is just the executable that builds the scaffolding and runs the deve machine for you
20:04:56 <Lokathor> yeah but there's no "yesod" package in my ghc-pkg listing
20:05:02 <Lokathor> which seems strange to me
20:06:03 <Zemyla> Hmm, why does GHC use build/foldr instead of stream fusion?
20:08:48 <Welkin> Lokathor: try creating a new scaffolded site and play with the options to see if you can use the old config style
20:08:52 <Welkin> it makes more sense
20:09:03 <Welkin> that file you pasted looks like a mess
20:09:15 <Lokathor> you just mean use yesod init again to create a fresh site?
20:09:21 <Welkin> or use an older version of yesod-bin
20:09:58 <jmcarthur> Zemyla: stream fusion has some remaining problems. concatMap is tough to optimize well right now, for example
20:10:37 <Zemyla> Hmm.
20:11:11 <lpaste> Lokathor pasted “No title” at http://lpaste.net/119221
20:11:30 <Lokathor> yeah i just have what it's producing as a default config welkin :/
20:14:16 <Welkin> http://www.yesodweb.com/blog/2014/12/yesods-new-scaffolding
20:14:24 <Welkin> I guess he did make major changes
20:15:32 <Welkin> the old scaffolding config is nicer in my opinion
20:20:07 * hackagebot elevator 0.2 - Immediately lifts to a desired level  http://hackage.haskell.org/package/elevator-0.2 (FumiakiKinoshita)
20:22:06 <Welkin> I didn't realize you could use a Set or a Map as a proority queue
20:22:10 <Welkin> Set.minView
20:23:22 <Pamelloes> Is there a function along the lines of (a -> b -> Maybe c) -> [a] -> [b] -> [c]? Basically I want to be able to zipWith where if the function fails, that element is discarded from the result.
20:23:50 <EvanR> you can use catMaybes on the result
20:23:59 <Welkin> I was about to say that
20:24:17 <Welkin> it's a nice solution
20:24:19 <Pamelloes> catMaybes?
20:24:20 <EvanR> of a normal zipWith
20:24:24 <EvanR> :t catMaybes
20:24:25 <Welkin> :t catMaybes
20:24:26 <lambdabot> [Maybe a] -> [a]
20:24:27 <lambdabot> [Maybe a] -> [a]
20:24:28 <Welkin> haha
20:24:40 <Welkin> it throws away the Nothings and unpacks the Justs
20:24:49 <Pamelloes> huh, that looks nice. Where is that located?
20:25:01 <EvanR> @hoogle catMaybes
20:25:02 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
20:25:21 <Zemyla> :t catMaybes . zipWith
20:25:22 <lambdabot>     Couldn't match type ‘[a1] -> [b] -> [c]’ with ‘[Maybe a]’
20:25:23 <lambdabot>     Expected type: (a1 -> b -> c) -> [Maybe a]
20:25:23 <lambdabot>       Actual type: (a1 -> b -> c) -> [a1] -> [b] -> [c]
20:25:43 <EvanR> possessing the true name means possessing the true power
20:25:55 <Zemyla> :t \f a b -> catMaybes $ zipWith f a b
20:25:56 <lambdabot> (a1 -> b -> Maybe a) -> [a1] -> [b] -> [a]
20:26:18 <Welkin> rumpelstiltskin?
20:26:26 <EvanR> catMaybes
20:26:44 <EvanR> (or, searching for [Maybe a] -> [a] should work)
20:26:51 <augur> @seen applicative
20:26:51 <lambdabot> APP|iC4Ti\/E
20:26:55 <augur> :(
20:26:56 <benzrf> nice
20:26:57 <EvanR> lol
20:27:01 <benzrf> @leet test
20:27:01 <lambdabot> +Ez+
20:27:01 <augur> preflex: seen applicative
20:27:15 <augur> no preflex :(
20:27:41 <Welkin> @leet 31337
20:27:42 <lambdabot> 31337
20:27:51 <Welkin> did you add that benzrf ?
20:28:45 <benzrf> certainly not
20:28:51 <augur> well anyway: how do you compile (on Mac OS) a haskell program to be self contained, so it can run on systems without haskell installed
20:29:13 <Welkin> doesn't ghc statically link by default?
20:29:26 <kadoban> I thought so
20:29:53 <augur> i dont know. i did   ghc -static -optl-static -fforce-recomp --make -o prog.cgi prog.hs   and im getting a well-known error about lcrt0.o being missing
20:30:42 <augur> and i know jfischoff had this problem in 2012 and applicative said this is a problem with ghc not chasing dependencies or something, i dunno
20:30:49 <glguy> OS X doesn't do static lib c
20:31:00 <augur> glguy: ok so how can i make this work
20:31:18 <EvanR> you can tell on osx by using otool -L program
20:31:35 <augur> EvanR: i dont know what that means
20:31:46 <EvanR> if you want to know if ghc is statically linking what you want
20:32:08 <EvanR> libc is probably less of concern than something the target computer probably doesnt have
20:32:45 <augur> ok let me rephrase this question: what do i do to make it work
20:34:58 <isomorphic> Is anybody aware of a library like patsy (https://patsy.readthedocs.org/en/latest/overview.html) for Haskell?   To save clicking on the link, what I'm after is something that will parse an expression like "y ~ a:b + c + d - 1" to create a linear model.
20:35:29 <isomorphic> I figure it would be fun to write the parser, but it sounds a little bit like wheel reimplementation
20:35:54 <Welkin> isomorphic: you can write a parser in parsec very easily
20:36:32 <dfeuer> I have a weird question. Is there a library of unboxed list (or, better, infinite stream) types like the unboxed vector one? I mean a family of types that look like  data US = {-# UNPACK #-} !Int :> US
20:36:40 <isomorphic> Welkin:  :) I'm kind of wanting to
20:38:09 <EvanR> parsing that expression might be a one liner
20:38:21 <EvanR> with chainl1
20:40:28 <EvanR> dfeuer: a linked list of unboxed int like that might defeat the point of being unboxed a little
20:41:11 <dfeuer> EvanR, obviously, there will still be boxes. Just fewer of them. The Ints will be directly in the stream constructors rather than a pointer away.
20:41:29 <EvanR> yeah
20:42:12 <dfeuer> I imagine this will cut the size by a quarter, and probably otherwise make things happier.
20:42:36 <EvanR> shouldnt strictness annotation take care of that?
20:42:48 <dfeuer> Yes, with GHC version >= I don't remember.
20:42:55 <dfeuer> 7.8, I think.
20:43:05 <EvanR> well nevermind you have to make a custom type either way
20:43:24 <dfeuer> Def.
20:43:38 <EvanR> unbox all the things
20:43:41 <dfeuer> But I realized just now I don't actually need quite that much flexibility at the moment probably.
20:43:51 <dfeuer> I do need one for unboxed Word64.
20:44:07 <dfeuer> But other things have their own ... complications.
20:44:31 <dfeuer> EvanR, I'm attempting to improve the O'Neill prime sieve in the NumberSieves package.
20:45:30 <dfeuer> Unlike the sieve code in arithmoi (some of which segfaults!), it's utterly sane. I'd like to see if it's possible to make it competitive, speed-wise.
20:45:35 <Welkin> don's unboxed types negatively affect laziness?
20:45:38 <Welkin> don't*
20:46:09 <dfeuer> Welkin, yes, but there's no useful laziness in the Word64 values in this context.
20:46:25 <dfeuer> I need the "spine" to be lazy, but the values are very strict.
20:46:31 <EvanR> shouldnt be very much stream code to reproduce for your custom type
20:47:35 <dfeuer> EvanR, no, it's pretty straightforward. The problem is that along with the unboxed streams, there are also some other sorts of semi-unboxed streams with different cons-shapes... it's kind of icky that way.
20:47:53 <dfeuer> Oh wait, I see....
20:48:06 <dfeuer> Maybe.
20:51:09 <augur> seriously:  how do I compile to a self-contained binary from Mac OS X
20:51:32 <miklcct> Can't you use ghc for that?
20:51:41 <augur> no, GHC does not do this
20:52:22 <Pamelloes> anarcat: ghc will give you a self-contained binary. You need to use an external tool to package the binary in a .app
20:52:28 <Pamelloes> oops
20:52:31 <Pamelloes> augur: ^
20:52:48 <augur> Pamelloes: i dont need a .app
20:53:00 <augur> i need an actually self-contained binary which GHC does not create
20:53:59 <miklcct> What happens when you use GHC?
20:54:48 <augur> it builds a binary that dynamically links to a bunch of junk
20:55:30 <miklcct> how about passing -s to ghc?
20:55:36 <maurer> augur: I've succeeded in doing this multiple times, but each time it's different
20:55:36 <miklcct> sorry, should be -static
20:55:45 <augur> maurer: :)
20:55:53 <maurer> augur: like, every year or so the secret incantation changes :/
20:56:11 <maurer> miklcct: that only forces ghc libs to be linked statically
20:56:31 <augur> maurer: i have figured out how to pull a bunch of .a's into Xcode, but i dont know if that's enough
20:57:02 <maurer> augur: so, what I have done in the past is essentially to tell ghc to build it statically, tell it to build it as a library, and then have a stub that calls main in C
20:57:24 <maurer> augur: and call ld and list all the code etc
20:57:25 <augur> maurer: right, thats approximately one thing ive done before to build an Xcode framework
20:57:37 <maurer> Yeah, I have no idea how to use xcode for that
20:57:41 <maurer> I was just using makefiles
20:57:48 <augur> go through and manually find the .a's and bring them in to Xcode so that when it compiles, it has them all there
21:00:07 <Zemyla> Is there a way to have an array of unboxed newtypes?
21:45:43 <Pamelloes> When running monad transformers, do you go outside in, or inside out? My type errors are a mess so it's difficult to tell what's going on...
21:46:13 <shachaf> You should construct a simple case which isn't a mess to figure out the answer. :-)
21:46:59 <shachaf> Ah, "running", that explains what you mean by outside in and inside out.
21:47:16 <EvanR> is your monad transformer running?
21:47:34 <EvanR> then youd better catch it!
21:47:48 <shachaf> :t runStateT -- Look at the type of the "run" function.
21:47:49 <lambdabot> StateT s m a -> s -> m (a, s)
21:47:54 <Pamelloes> EvanR: He cut his 5k time down to under 25 minutes this week. He's no fast than me!
21:48:34 <Pamelloes> shachaf: Ah! so "outside in" it looks like
21:48:58 <Pamelloes> *now faster
21:55:11 * hackagebot countable 0.2 - Countable, Searchable, Finite, Empty classes  http://hackage.haskell.org/package/countable-0.2 (AshleyYakeley)
22:07:43 <Pamelloes> If I have a function (f m -> m (f m)), Is there a way I can turn it into (f (t m) -> t m (f (t m)))?
22:08:02 <Pamelloes> Basically replace all instances of m with t m?
22:08:35 <augur> is that even possible
22:08:48 <shachaf> That is a pretty odd type.
22:08:49 <Pamelloes> augur: I have no idea, that's why I'm asking
22:08:49 <AshyIsMe> hmm, seems that nix is installing ghc from source on osx rather than from a cached binary
22:08:56 <augur> Pamelloes: no i mean is that type possible
22:09:14 <shachaf> You should say more about your problem.
22:09:56 <Pamelloes> I have a type (State m). I have a function that takes an input (State m -> m (State m))
22:10:04 <haasn> The second type is just a less general version of the first time
22:10:11 <haasn> If you set m = t m
22:10:25 <augur> i guess it is, with  m :: * -> * and f :: (* -> *) -> *
22:10:33 <Pamelloes> I have a function defined for where m is "Catch". I want to turn it into a function where m is "WriterT String Catch"
22:10:39 <augur> yeah ok, so f is like Fix
22:11:01 <shachaf> (State m -> m (State m)) isn't a type that can happen.
22:11:21 <Pamelloes> shachaf: Then how has my code compiled?
22:11:31 <shachaf> I don't know. You haven't shown us your code.
22:12:03 <augur> Pamelloes: if f and m are universally quantified, then its always already that
22:12:46 <haasn> (State m -> m (State m)) contains at least two kind errors. Possibly more
22:12:46 <Pamelloes> shachaf: Actually my function's type is "Monad m => State m -> m State m"
22:12:57 <Pamelloes> *m (State m)
22:13:03 <shachaf> I don't think I believe you.
22:15:09 <shachaf> I mean: I don't think that code could possibly compile, with the usual meaning of "State".
22:15:28 <haasn> It could easily compile with a different definition of State
22:15:45 <lpaste> Pamelloes pasted “State m” at http://lpaste.net/119223
22:16:05 <shachaf> OK, you defined your own type called State.
22:16:18 <ReinH> lol
22:16:28 <Pamelloes> Is there a standard type called State?
22:16:32 <shachaf> There is.
22:16:39 <EvanR> @src State
22:16:40 <lambdabot> Source not found. The more you drive -- the dumber you get.
22:16:44 <Pamelloes> Oh. Sorry for the confusion that that must have caused :(
22:16:46 <matematikaadit> @hoogle State
22:16:47 <lambdabot> Control.Monad.State module Control.Monad.State
22:16:47 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
22:16:47 <lambdabot> Graphics.UI.GLUT.State module Graphics.UI.GLUT.State
22:16:52 <Hijiri> @mtl State
22:16:53 <lambdabot> Maybe you meant: url unmtl pl msg
22:16:54 <Pamelloes> I've never used that State.
22:16:57 <matematikaadit> Control.Monad.State
22:16:59 <Hijiri> @unmtl State
22:16:59 <lambdabot> Plugin `unmtl' failed with: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
22:17:09 <Hijiri> @unmtl State Banana
22:17:09 <lambdabot> Plugin `unmtl' failed with: `State Banana' is not applied to enough arguments, giving `/\A. Banana -> (A, Banana)'
22:17:12 <Hijiri> sorry
22:17:14 <shachaf> Hijiri: /msg, please.
22:17:30 <shachaf> You could also just type out the definition and not use lambdabot. It would be less work. :-)
22:17:34 <matematikaadit> @src State >>=
22:17:34 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
22:17:48 <matematikaadit> @src State return
22:17:48 <lambdabot> Source not found. That's something I cannot allow to happen.
22:19:54 <Fylwind> @src State
22:19:54 <lambdabot> Source not found.
22:20:03 <Fylwind> @src head
22:20:04 <lambdabot> head (x:_) = x
22:20:04 <lambdabot> head []    = undefined
22:20:35 <jle`> do you all know that you can pm lambdabot?
22:20:42 <solatis> people please, use lambdabot with care
22:20:51 <jle`> Fylwind, matematikaadit ?
22:20:52 <shachaf> Y'all: Please use lambdabot in /msg unless you're trying to demonstrate something to the channel. If you are trying to demonstrate something to the channel, please use /msg to make sure that you have the right command before using it in the channel.
22:20:57 --- mode: ChanServ set +q lambdabot!*@*
22:21:03 <shachaf> Testing in /msg is optional if you never make mistakes.
22:21:22 <shachaf> Hah, that works too.
22:21:39 <EvanR> yes please keep #haskell at a purely informative level of 100% or more at all times
22:22:12 <solatis> EvanR: well the lambdabot usage, yes
22:23:01 <Fylwind> I think if you ignore the monad transformer aspect, State would be defined as: newtype State s a = State { runState :: s -> (a, s) }
22:23:25 <Fylwind> jle`: sorry
22:24:01 <jle`> Fylwind: oh no need to be sorry. just wasn't sure if you were aware
23:02:21 <Lokathor> i installed the debian sid version of the haskell-platform, which is the 2013.2.0.0 version, and yet when i build my project with cabal it says "You are using a new version of LLVM that hasn't been tested yet!"
23:03:04 <Lokathor> I can probably ignore that right?
23:05:14 * hackagebot witness 0.3 - values that witness types  http://hackage.haskell.org/package/witness-0.3 (AshleyYakeley)
23:21:21 <forgottenone> i am trying to understand the code in The Genuine Sieve of Eratosthenes can someone explain  how this part of the code works and why we have to take first element before merging to produce union?http://pastebin.com/LAYjShn1
23:30:00 <Lilax> looks like the code to soul fusion
