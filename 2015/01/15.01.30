00:05:06 <jle`> anyone know any other endofunctors on Auto/mealy machines?
00:05:44 <SrPx> glguy: not sure I understand
00:06:05 <jle`> data Auto a b = Auto (a -> (b, Auto a b))
00:06:19 <jle`> or the equivalent `forall s. (a, s) -> (b, s)`
00:06:36 <jle`> the only non-trivial one i know is Maybe, or Either e
00:06:52 <shachaf> Why is that equivalent?
00:07:12 <jle`> the two data types are equal in power
00:07:16 <jle`> and expressiveness
00:07:30 <shachaf> I'm not sure you mean forall there.
00:07:30 <jle`> or well, answering the quesiton on one will answer questions on the other as well
00:08:07 <jle`> hm i probably mistyped, let me check what i've been using
00:08:54 <jle`> data Auto a b = forall s. Auto s ((a, s) -> (b, s))
00:09:20 <shachaf> OK, (exists s. (s, (a,s) -> (b,s)))
00:09:29 <jle`> ah thanks.
00:10:05 <shachaf> And what's an "endofunctor on that"?
00:10:22 <jle`> so `Auto` admits a Category instance
00:10:32 <jle`> (.) :: Auto b c -> Auto a b -> Auto a c
00:10:54 <jle`> which is a new Auto that runs the input through one and the other, and updates all of the resulting new states
00:11:11 <shachaf> Ah.
00:11:17 <jle`> id = Auto (\x -> (x, id))
00:11:35 <jle`> id = Auto () (\(x,_) -> (x,()))
00:12:09 <jle`> so the objects are the same ol' haskell types, and a morphism from a to b is Auto a b
00:12:38 <jle`> so an endofunctor f would be * -> *, and also have an fmap' that takes `Auto a b -> Auto (f a) (f b)`
00:13:08 <jle`> s.t. fmap' id = id; fmap' g . fmap' f = fmap' (g . f)
00:13:17 <jle`> um the only one i can think of is `Maybe`
00:15:35 <jle`> fmap (Auto f) = Auto $ \x -> case x of Nothing -> (Nothing, fmap a); Just x' -> let (y, a') = f x' in (Just y, fmap a')
00:15:50 <jle`> fmap there being fmap'
00:16:06 <jle`> um fmap a@(Auto f)
00:16:47 <jle`> i tried writing one for a generic `Alternative`, `Traversable`, etc., but i always come short
00:17:02 * hackagebot formatting 6.2.0 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-6.2.0 (ChrisDone)
00:17:18 <jle`> oh i guess `(,) w` would work.
00:17:20 <jle`> heh
00:49:27 <CindyLinz> @type Auto
00:49:28 <lambdabot> Not in scope: data constructor ‚ÄòAuto‚Äô
00:50:02 <jle`> CindyLinz: the definition was given a little bit above :)
01:02:13 <t4nk307> how to generalize intervals
01:02:33 <t4nk307> lets say a function receives a list of tuples of intervals (int,int)
01:02:43 <t4nk307> how to generalize the intervals
01:03:47 <mauke> generalize to what?
01:04:15 <CindyLinz> jle`: thx ^^|
01:06:13 <t4nk307> to a list of tuples
01:06:21 <t4nk307> that has the minimal set of intervals
01:06:29 <t4nk307> i/e drop the overlapping
01:06:44 <t4nk307> (1,2),(2,3),(3,4)
01:06:47 <t4nk307> (1,4)
01:08:29 <lyxia> I don't know what it's called but "generalize" doesn't sound like a good name for it.
01:09:14 <t4nk307> forget the word used
01:09:55 <t4nk307> you have intervals as a tuple of ints you need to simplify the overlapping
01:10:03 <t4nk307> ones
01:10:15 <t4nk307> think of them as ordered
01:10:21 <t4nk307> (a,b)
01:10:26 <t4nk307> a<=b
01:11:54 <lyxia> Sort the list then traverse it. What to do in the traversal is left up to you.
01:15:37 <jle`> @hackage interval
01:15:37 <lambdabot> http://hackage.haskell.org/package/interval
01:16:12 <jle`> forall problems there exists an edwardk such that the problem is solved with that package
01:16:29 <jle`> *an edwardk package
01:18:56 <t4nk307> thank you
01:19:50 <jle`> oops
01:19:52 <jle`> @hackage intervals
01:19:52 <lambdabot> http://hackage.haskell.org/package/intervals
01:41:03 <aspidites> did the options for hlint recently change?
01:41:32 <aspidites> i'm trying to get hints in vim, but I'm always getting "No suggestions" in scenarios where I used to have hlint gripe at me
01:41:38 <aspidites> (missing type signatures, for example)
01:44:32 <aspidites> hmm..maybe ghc-mod was doing that
02:07:07 * hackagebot casadi-bindings-internal 0.1.2.1 - low level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-internal-0.1.2.1 (GregHorn)
02:07:09 * hackagebot casadi-bindings-core 2.2.0.2 - autogenerated low level bindings to casadi  http://hackage.haskell.org/package/casadi-bindings-core-2.2.0.2 (GregHorn)
02:07:11 * hackagebot casadi-bindings 2.2.0.2 - mid-level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.2.0.2 (GregHorn)
02:14:49 <matematikaadit> I believe that Haskell is a better scripting language than Bash :D
02:16:29 <arw> anything is better than plain shellscript. it tells you a lot that perl is a superior alternative for anything longer than 3 lines of sh
02:16:36 <favetelinguis> ok call me retarded but what is going on in line 12 here http://lpaste.net/119588 Where is that tuple coming from? we pass 3 params g [] i??
02:17:40 <jle`> favetelinguis: yeah i don't know what's going on either
02:17:53 <favetelinguis> ok sorry never mind it is a typo in the book
02:17:55 <jle`> seems like a type error to me
02:17:58 <jle`> ah
02:18:09 <favetelinguis> it should be gt@...
02:18:19 <jtanguy> as Larry Wall said, It is easier to port a shell than a shell script
02:18:47 <jle`> favetelinguis: ah that makes sense
02:18:56 <jle`> you'd think they'd try to compile and run their examples...
02:19:08 <favetelinguis> no that book is full of errors
02:19:35 <matematikaadit> @hackage turtle
02:19:35 <lambdabot> http://hackage.haskell.org/package/turtle
02:20:14 <jle`> heh
02:20:27 <matematikaadit> wondering why it's named turtle, until someone mention that it's intended as a pun of turtle shell
02:20:35 <MP2E> been reading through turtle's documentation and yeah, it is pretty amazing
02:20:58 <jle`> every one of gabriel's announcements and new libraries seems to come from a completely new area/field/domain
02:21:04 <jle`> it's kind of crazy
02:21:34 <jle`> but i guess we can't really just call him "the pipes guy" anymore
02:22:56 <tasker> Which lens tutorial can people recommend ?
02:22:59 <sgronblo> gabriel is the pipes guy?
02:24:08 <snizzo> what's the signature of this function?
02:24:10 <snizzo> h = map (\f -> flip div 2 $ f show) . f
02:24:15 <snizzo> it doesn't compile
02:25:29 <sgronblo> if it doesnt compile, it doesnt have a correct signature?
02:25:52 <snizzo> i don't know what signature should I write
02:25:59 <enthropy> the last f is not the one brought into scope by the lambda
02:26:10 <hyPiRion> is there a generalised words function? like (a -> bool) -> [a] -> [[a]]
02:26:18 <enthropy> @hackage split
02:26:18 <lambdabot> http://hackage.haskell.org/package/split
02:26:40 <sgronblo> snizzo: missing top level type definitions should just be warnings in haskell
02:26:41 <hyPiRion> ah, so nothing in prelude I guess
02:26:45 <hyPiRion> no wonder
02:26:53 <hyPiRion> enthropy: thanks =)
02:26:57 <sgronblo> snizzo: if you can get it to work correctly you can ask ghci for the type too
02:27:29 <snizzo> sgronblo: that was my intention :) but doesn't get loaded
02:27:30 <enthropy> no problem
02:27:32 <matematikaadit_> @hoogle (a -> bool) -> [a] -> [[a]]
02:27:35 <lambdabot> Did you mean: (a -> Bool) -> [a] -> [[a]]
02:27:35 <lambdabot> GHC.Exts groupWith :: Ord b => (a -> b) -> [a] -> [[a]]
02:27:35 <lambdabot> GHC.Exts sortWith :: Ord b => (a -> b) -> [a] -> [a]
02:28:59 <saep> snizzo: The f inside the lambda must have a type like `(a -> String) -> Integer`. (a bit simplified)
02:29:22 <saep> I don't know how to turn a function to a number. ;)
02:29:23 <sgronblo> isnt the f also unavailable outside of the lambda?
02:29:33 <snizzo> saep: mmm I still don't get it... what should I write the function then?
02:29:43 <mniip> 'flip div 2' why not just '(`div` 2)'
02:29:46 <akegalj> hi, i was reading cloud haskell wiki and run into few typos. How can i register? If i figured it right i sould send email to nominolo@gmail.com ?
02:29:48 <sgronblo> we dont know what you are trying to accomplish
02:30:00 <saep> snizzo: What should `h` do?
02:31:02 <mniip> also yes, that one seems broken as hell
02:31:09 <mniip> what were you trying to do
02:31:33 <snizzo> saep: I don't know, it should be an exercise of finding the signature but it doesn't even load in ghci
02:32:37 <saep> The `f show` doesn't make any sense.
02:32:59 <saep> At least if show is the usual show. ;)
02:33:16 <mniip> well if 'f' is (Show a) => (a -> String) -> b
02:33:41 <mniip> but that sounds unlikely
02:33:57 <snizzo> of sorry, f could be of previous declaration this function:
02:34:07 <snizzo> f = map (curry fst)
02:34:50 <mniip> >curry fst
02:35:07 <mniip> curry fst const
02:35:10 <mniip> er
02:35:16 <mniip> 'curry fst' == 'const'
02:35:51 <mniip> snizzo, can you explain what are you trying to do?
02:36:09 <snizzo> mniip: just getting signature those functions have no utilizations
02:36:17 <mniip> oh phew
02:36:27 <snizzo> yeah :(
02:36:29 <mniip> well see
02:36:37 <mniip> > :t map (curry fst)
02:36:39 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
02:36:45 <mniip> :t map (curry fst)
02:36:46 <lambdabot> [c] -> [b -> c]
02:37:53 <mniip> the other one is [Integer] -> [Integer]
02:38:54 <mniip> snizzo, is this a homework? :)
02:39:05 <Javran> :t (>=>)
02:39:06 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:39:24 <snizzo> mniip: more less yes to get used to ghci and haskell
02:39:37 <mniip> well you can do it yourself in ghci
02:39:50 <snizzo> we were asked to find types but didn't compile so :t couldn't be used
02:39:58 <mniip> ah
02:40:09 <mniip> well then the point is to obtain the type analytically
02:40:23 <Javran> @djinn ((a -> m b) -> (b -> m c) -> (a -> m c)) -> ((a -> b) -> (b -> c) -> (a -> c))
02:40:23 <lambdabot> f _ a b c = b (a c)
02:40:40 <Javran> not interesting :(
02:42:51 <Javran> @djinn (a -> m b) -> (a -> b)
02:42:51 <lambdabot> -- f cannot be realized.
02:43:24 <Javran> @djinn (a -> m a) -> (m a -> m (m a)) -> (a -> m b) -> (a -> b)
02:43:24 <lambdabot> -- f cannot be realized.
02:43:36 <Cale> djinn doesn't know anything about m there
02:43:43 <Cale> In particular, it doesn't know that m is a monad
02:44:13 <Javran> wondering if it is smart enough to plug in Identity
02:44:53 <Cale> @djinn (Monad m) => (a -> m a) -> (m a -> m (m a)) -> (a -> m b) -> (a -> b)
02:44:53 <lambdabot> -- f cannot be realized.
02:44:56 <mniip> only a few m's allow (a -> m b) -> (a -> b)
02:45:07 <Cale> yeah, there's still quite an issue there
02:45:36 <Cale> @djinnn Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:45:36 <lambdabot> -- f cannot be realized.
02:45:43 <mniip> Maybe, (Either a), [], IO can't implement such a funcition
02:45:55 <Cale> Okay, I don't think this djinn knows about Monad either :)
02:46:19 <Cale> It's possible to add definitions of stuff like Monad when using the standalone djinn, I think
02:46:30 <Cale> Or maybe it didn't support constructor classes...
02:46:33 <Cale> I forget
02:48:26 <mniip> @pl \x y -> join . (liftM y) . x
02:48:26 <lambdabot> ((join .) .) . flip ((.) . fmap)
02:48:38 <mniip> :t ((join .) .) . flip ((.) . fmap)
02:48:39 <lambdabot> (Functor m, Monad m) => (a -> m a2) -> (a2 -> m a1) -> a -> m a1
02:48:48 <mniip> there's your thingy
02:49:03 <Javran> http://lpaste.net/119591 actuallly the question comes from here, there are some functions that I can plug Identity in to get its pure version
02:51:07 <Javran> is there a way to make type checker think "Identity a" and "a" are the same
02:51:49 <Cale> no
02:52:09 <Cale> They're different according to the type checker. Unifying them would produce all sorts of ambiguities
02:52:24 <Cale> You could treat any (>>=) as being the one for the Identity monad
02:53:44 <mniip> what would the type of 'join' be if Identity a and a are the same
02:55:17 <Javran> then id and join would be of the same type?
02:57:07 <mniip> pretty much
02:58:23 <Javran> it'll be great when there is a "Functor f => (a -> f b) -> a -> f (a,b)", the compiler somehow knows it can be converted into "(a -> b) -> a -> (a,b)" by plugging in Identity
02:58:50 <Javran> it's like trying to automate the proof I guess
02:59:31 <Cale> That kind of implicitness comes with a lot of downsides with respect to type inference
03:01:19 <mniip> Javran, (unIdentity .) . f . (Identity .)
03:01:23 <mniip> where f is your function
03:02:37 <Javran> :t (runIdentity .) . f? . (Identity .)
03:02:38 <lambdabot> parse error on input ‚Äò.‚Äô
03:02:51 <Javran> :t (runIdentity .) . ?f . (Identity .)
03:02:53 <lambdabot> (?f::(a1 -> Identity b) -> a -> Identity c) => (a1 -> b) -> a -> c
03:03:38 <mniip> yeah run*
03:03:43 <Javran> I see, one does need to write it explicitly
03:04:12 <Javran> or otherwise we can implement our own and compiler won't know which one to use.
03:07:10 * hackagebot dynobud 1.0.0.0 - your dynamic optimization buddy  http://hackage.haskell.org/package/dynobud-1.0.0.0 (GregHorn)
03:12:45 <Javran> @djinn (a -> f a) -> (f a -> a) -> (a -> f b) -> (a -> b)
03:12:45 <lambdabot> -- f cannot be realized.
03:13:05 <Javran> @djinn (forall a. a -> f a) -> (forall a . f a -> a) -> (a -> f b) -> (a -> b)
03:13:05 <lambdabot> Cannot parse command
03:14:31 <Javran> @hoogle Comonad m => m a -> a
03:14:34 <lambdabot> Warning: Unknown class Comonad
03:14:34 <lambdabot> Language.Haskell.TH.Syntax Q :: (forall m. Quasi m => m a) -> Q a
03:14:34 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
03:44:56 <tero-> I've put strictness annotations to data types and to all possible function calls I could imagine, but it is still not collecting the memory. what to do?
03:45:11 <tero-> profiling?
03:46:41 <mpickering> profiling is the first thing you do :P
03:46:56 <barrucadu> Yes, it's hard to know where strictness needs to be applied (or even if that's the right solution - the cause might just be unsuitable data structures) without
03:47:12 <pacak> tero-: There are places you can't imagine.
03:47:12 <tero-> mpickering: I was hoping to get lucky...
03:51:15 <tero-> can I easily get all the dependencies compiled with profiling enabled ?
03:52:28 <tero-> I guess I need a sandbox
03:56:07 <tero-> "cabal sandbox init && cabal install --only-dependencies --enable-library-profiling"  seems to do it
04:01:15 <tomphreek> trying to run an example from haskell.org and got: It is a member of the hidden package ‚Äòhaskell98-2.0.0.3‚Äô. Google search told me I need ghc-paths. Is that right?
04:03:16 <merijn> tomphreek: haskell98 is mostly obsoleted in newer GHC, which example are you trying to run?
04:03:36 <merijn> (the haskell98 package, I mean)
04:04:08 <merijn> tero-: If you haven't looked at it, Real World Haskell has a chapter on profiling haskell
04:04:16 <tomphreek> https://raw.githubusercontent.com/dag/all-about-monads/master/examples/example15.hs
04:04:25 <tomphreek> ok I think I need to change imports then
04:04:36 <tomphreek> I ll try to figure it out
04:04:37 <tero-> merijn: I remember reading it. Maybe time to read it again. :)
04:06:18 <tomphreek> yep, it was just a matter of changing inputs :)
04:06:23 <tomphreek> sorry imports
04:11:04 <tero-> does someone know the design decision¬†for lazy-by-default behavior? I'm thinking that many lives would be easier with strict-by-default policy
04:12:15 <hyPiRion> ,(map inc (range))
04:12:28 <hyPiRion> oh, wrong channel.
04:16:27 <hellofunk> yeah, hyPiRion. get your clojure out of this channel! :)
04:16:35 <tomphreek> :D
04:17:09 <hyPiRion> Well, the point was to show that some things isn't as easy to do in strict-by-default languages
04:18:21 <tomphreek> do any of you have K working from vim to look up Haskell docs? Alt-tabbing with browser is a bit tedious
04:20:06 <tomphreek> I have got hdevtools, ghc-mod and it gives me awesome autcompletion and type look up, but docs is still lacking
04:20:07 <pacak> tomphreek: xmonad + shortcuts (run or raise) for browser and terminal
04:20:56 <tomphreek> pacak: on tmux and no X server at the moment
04:21:44 <Peaker> tero-: lots of people think that.. until they try strict-by-default! :-)
04:21:57 <Peaker> tero-: there are points going for lazy and for eager
04:22:13 <Peaker> strict/non-strict, rather
04:22:16 <Peaker> tero-: It's nice to have some language going for non-strict
04:22:35 <Peaker> tero-: There's the "Mu" strict dialect of Haskell, and people are really surprised by things like "where" clauses evaluating before the bodies!
04:23:07 <Peaker> though I guess a strict Haskell ought to give a better ordering to variable setters that corresponds well to evaluation order
04:23:08 <hyPiRion> let .. in all the things
04:23:15 <Peaker> (i.e: forego "where" for "let", if strict)
04:23:25 <Peaker> (and we do the opposite for lazy, pretty much!)
04:27:16 <tero-> Peaker: okay. Maybe I should try those once
04:27:40 <tero-> -hc space usage profile gives only MAIN
04:27:53 <Peaker> tero-: did you enable -auto-all ?
04:28:00 <Peaker> and -caf-all ?
04:28:07 <Peaker> (otherwise, you only get module-level cost-centres reported)
04:29:59 <tero-> Peaker: ah, trying again now with those
04:39:50 <merijn> tero-: Actually, after lots of thinking I've decided that "lazy-by-default" is the only sane way to go
04:40:05 <merijn> tero-: Because selectively making things strict is substantially easier than selectively making things lazy
04:40:05 <Peaker> merijn: why?
04:40:15 <Peaker> I think maybe there shouldn't be a default! :)
04:40:41 <arw> Peaker: no default makes code slightly unreadable without sufficient context.
04:40:42 <merijn> Peaker: Because you can make an entire large composed computation strict by forcing it's result
04:40:43 <Peaker> And I do want to try out laziness in-the-types + polymorphic-laziness
04:40:59 <merijn> Making a large composition of strict values lazy requires changing every intermediate part
04:41:16 <merijn> Peaker: I'm planning to do laziness in types
04:41:17 <Peaker> merijn: only if the compiler is smart enough to specialize that computation to be strict in the first place
04:41:28 <Peaker> merijn: otherwise it's not really the same as being strict
04:41:31 <Peaker> (or rather, eager)
04:41:37 <tero-> merijn: ah, that's true
04:41:45 <merijn> Peaker: I'm making vague plans to do "strictness-polymorphic" typing
04:42:08 <merijn> Peaker: Actually, I don't have time to do it, so I'm trying to recruit master students to do my work for me in exchange for ECTS :p
04:42:19 <merijn> Anyone looking to earn university credits? :>
04:42:35 <Peaker> merijn: "Lazy" data constructor with Copointed instances would nicely allow:  ListT Identity = strict list,  ListT Lazy = lazy list, and stuff like that :)
04:43:12 <merijn> Peaker: The same line of research also covers "checked exceptions for a haskell like language, without them showing up in the functional type"
04:43:29 <merijn> I'm hoping to recruit a bachelor student during next week's compiler course to work on that
04:43:34 <Peaker> Copointed m => ListT m a   <-- a list polymorphic about its' spine laziness!
04:43:41 <Peaker> merijn: cool :)
04:44:12 <merijn> Peaker: Maybe that kinda thing can eventually go into GHC, although I have other GHC work I've decided to do before then
04:44:37 <Peaker> merijn: uninterruptible exception handling combinators? :)
04:44:52 <Peaker> (catch, finally, onException, bracket, etc?)
04:46:10 <Peaker> If IO type was changed to "IO t", with t informing about potential blocking and maybe even potential exceptions, that'd be an awesome (new language..) :)
04:46:18 <merijn> That's something else I'm thinking off, but is not wel formed enough to work as student project
04:46:39 <Peaker> that would really help the exception-handling safety bits: exception handlers could be typed as no-throw (which would require no-sync-exceptions & no-async-exceptions)
04:46:42 <merijn> Peaker: Actually, I *don't* want to contaminate the "functional" type with that info
04:46:47 <merijn> Lemme give a simple example
04:46:52 <Peaker> merijn: where is it placed instead?
04:46:52 <akegalj> hey, i'm using https://github.com/enomsg/vim-haskellConcealPlus, but cons is that as a result there will be bad alignment. (if i aligne it visualy, source code won't have the same visual appearance)  do any of you folks use these or similar addons?
04:47:29 <merijn> "(/) :: Int -> Int -> Int" <- don't want to put the "division by zero" here, because that means having to deal with exceptions everywhere, but also don't wanna let it go unnoticed
04:48:00 <merijn> Peaker: So I want a "parallel" (i.e. separate from the "functional correctness") typing layer that checks possible exceptions (and effects/non-termination?)
04:48:29 <merijn> Peaker: That would let you statically check possible exceptions, without them obscuring the types for functional correctness
04:48:42 <Peaker> merijn: well, where can you place the extra metadata?
04:48:55 <merijn> Peaker: Basically, my fundamental premise is that many (E)DSLs try to put too much orthogonal info into the same types
04:49:12 <merijn> Peaker: Multiple different types of types (syntax to be decided)
04:49:18 <chpatrick> merijn: liquid haskell?
04:49:25 <merijn> Where you can potentially leave, for example, exceptions out and infer them
04:49:35 <mroman> http://lpaste.net/119596
04:49:35 <merijn> chpatrick: Slightly different goal, they're far more ambitious
04:49:42 <mroman> hWaitForInput strangely always returns false
04:50:10 <Peaker> merijn: well, need something like lamdu to allow the programmer to interact with this so it's not too hidden away where it cannot be helped
04:50:26 <merijn> mroman: You have no input before the 3ms are up?
04:50:47 <merijn> Peaker: I'd just have multiple signatures, but yes, something like lamdu would help a lot
04:51:16 <merijn> Peaker: The idea being that you can just let exceptions, effects, etc. be inferred in almost all cases, but explicitly enforce, for example, lack of exceptions in cleanup handlers
04:51:31 <merijn> (by annotating those explicitly)
04:52:15 <Peaker> it requires very successful inference
04:52:25 <Peaker> with few manual cases
04:52:43 <merijn> This doesn't seem particularly hard to infer?
04:52:59 <Peaker> merijn: also, that information is interesting, so for same reason you want top-level types you'd want these types visible too?
04:53:00 <mroman> merijn: It run's in a loop
04:53:16 <mroman> so even if data is not there yet within 3ms it should be there some time later
04:53:19 <Peaker> merijn: also, if inference runs on wrong unannotated code, the errors suck!
04:53:27 <mroman> hm
04:53:32 <mroman> although hGetChar src might block
04:53:45 <merijn> Peaker: Why would the errors suck?
04:53:48 <indiagreen> hi. Would anybody be interested in writing something for /r/haskelltil?
04:53:48 <Peaker> merijn: error in "main": 'foo' may throw!  because 15 layers down, something in 'foo' throws
04:54:03 <merijn> Why would that necessarily happen?
04:54:05 <Peaker> merijn: but foo is the top-level representative and the demand for no-throw is at main
04:54:19 <merijn> There was a nice talk on the haskell implementors workshop on how to attribute type error better
04:54:25 <Peaker> merijn: same as the sucky type errors you get if you don't have any type decls to "contain" errors
04:54:40 <merijn> Peaker: Tracking the origin of the exceptions should be trivial
04:54:42 <mroman> ok
04:54:43 <mroman> seems to work
04:54:46 <mroman> but data is broken
04:54:48 <merijn> You can just annotate every exception with it's source
04:55:09 <chpatrick> :t \f -> foldr (\x a -> maybe [] (:a) (f x)) []
04:55:10 <lambdabot> (a -> Maybe t) -> [a] -> [t]
04:55:12 <Peaker> merijn: as soon as you have higher-order function combinators in there, it won't be so simple
04:55:20 <chpatrick> do you think there's a nicer way to capture this?
04:55:28 <chpatrick> it's like takeWhileJust
04:55:44 <Peaker> merijn: the exception thrower is "foo" but the *problem* is the way it was combined by various functions passing it around as an argument
04:56:00 <merijn> Peaker: I don't think this is as hard as you make it out
04:56:17 <Peaker> merijn: I have had a really bad taste of trying out full-inference without error containment :)
04:56:33 <merijn> To infer which exceptions can be thrown by a function you need to track the exceptions origins
04:56:54 <merijn> Anyway, we'll see
04:57:03 <merijn> That's what prototypes and students are for :)
04:57:12 <merijn> @hackage monad-loops --chpatrick
04:57:12 <lambdabot> http://hackage.haskell.org/package/monad-loops --chpatrick
04:57:15 * hackagebot HGraphStorage 0.0.3 - Graph database stored on disk  http://hackage.haskell.org/package/HGraphStorage-0.0.3 (JeanPhilippeMoresmau)
04:57:37 <mroman> merijn: It works now, but data get's corrupted :(
04:58:00 <chpatrick> merijn: sortof
04:58:40 <wakalabis> Hey, what‚Äôs up?
04:58:40 <merijn> mroman: You're writing Char's to the network, use ByteString
04:59:02 <mroman> It breaks with gzip encoded stuff
05:00:17 <ChristianS> mroman: hmm, ByteString shouldn't have a problem with whatever binary data you use it for
05:00:20 <chpatrick> @pl foldr (\x a -> maybe [] (:a) x) []
05:00:20 <lambdabot> foldr (flip (maybe [] . flip (:))) []
05:00:23 <chpatrick> eh
05:00:51 <wakalabis> I‚Äôve read a couple of articles on making an assembler using a MonadFix instance and recursive do. Preety cool, but how could we make and interpreter of the generated bytecodes?
05:01:19 <wakalabis> I know of a way of writing an interpreter but it is very imperative.
05:01:45 <mroman> ChristianS: I thought hSetBinaryMode would be enough
05:01:49 <mroman> but it's not :(
05:01:53 <chpatrick> wakalabis: I think interpreting an imperative bytecode is going to be imperative
05:02:14 <wakalabis> @chpatrick: hmm‚Ä¶
05:02:14 <lambdabot> Unknown command, try @list
05:02:45 <wakalabis> @chpatrick isn‚Äôt there a fancy functional way ? maybe using continuations?
05:02:45 <lambdabot> Unknown command, try @list
05:03:07 <chpatrick> well what do you want it to do though?
05:03:47 <wakalabis> @chpatrick Interpret a simple VM
05:03:47 <lambdabot> Unknown command, try @list
05:04:27 <wakalabis> @chpatrick I have a toy projet in mind: implement Tiny Basic using a tiny VM
05:04:27 <lambdabot> Unknown command, try @list
05:04:28 <mroman> it also breaks with bytestring
05:04:48 <wakalabis> @chpatrick http://en.wikipedia.org/wiki/Tiny_BASIC
05:04:48 <lambdabot> Unknown command, try @list
05:04:51 <chpatrick> wakalabis: if you put @ in the beginning lambdabot will think you're trying to use a command :)
05:04:52 <mroman> oh wait
05:05:07 <wakalabis> chpatrick: OK :)
05:05:18 <chpatrick> wakalabis: https://github.com/chpatrick/hchip
05:05:25 <bernalex> wakalabis: on IRC the norm is "nick:". most IRC clients will tab-complete this for you too.
05:05:28 <wakalabis> chpatrick: It is possible to implement tinybasic with only a few instructions
05:05:48 <aleator__> Any cabal gurus around? I have a program that uses GHC-api and needs to run in a cabal sandbox. I'd like to distribute it without having a full build env on the target machine. What is the best way to move cabal sandbox from one machine to another?
05:05:48 <chpatrick> I think I would just use some state monad to be honest
05:05:59 <chpatrick> so it would be pretty imperative
05:05:59 <wakalabis> chpatrick: thanks: I will have a look at hchip
05:06:34 <wakalabis> chpatrick: I was thinking of using an some monad transformes, StateST being one of them
05:06:53 <chpatrick> that's the idiomatic way I think
05:07:10 <chpatrick> make an environment where the VM's operations are available
05:07:15 <wakalabis> chpatrick: I mean StateT
05:07:50 <wakalabis> chpatrick: That‚Äôs the word I was looking for: idiomatic
05:11:04 <mroman> merijn: I'm using ByteString now but content is still broken
05:11:26 <mroman> oh wait
05:11:33 <mroman> you must not set hSetBinaryMode when using bytestring
05:11:33 <mroman> ok
05:14:36 <yogsototh> Hi! I'd like to kill my main process from a threadIO
05:14:42 <merijn> mroman: Oh, wait
05:14:46 <merijn> mroman: Are you on windows?
05:15:11 <merijn> yogsototh: Any reason why you can't use exit to exit the application?
05:15:37 <yogsototh> merijn: when I do an exitFailure in the thread
05:15:53 <tcpproxy> Neat.
05:15:57 <tcpproxy> It works :)
05:15:58 <yogsototh> My thread is closed but not the parent process
05:16:47 <merijn> yogsototh: "parent process": Are you talking about threads or about processes?
05:16:48 <yogsototh> So I used a threadFinaly in the parent catching
05:16:54 <tcpproxy> hm
05:17:19 <mroman> merijn: No. Linux
05:17:27 <merijn> exitFailure exits the entire process, so it can't only kill the thread...
05:17:28 <yogsototh> merijn: precisely I use a threadIO in my main function
05:17:29 <mroman> but by removing hSetBinaryMode and using Data.ByteString it works
05:17:49 <merijn> mroman: hSetBinaryMode should be a window only thing, afaik
05:17:56 <merijn> yogsototh: I have no idea what a threadIO is
05:18:36 <mroman> hSetBinaryMode sets char8 as encoding
05:18:40 <mroman> and newline mode
05:18:51 <merijn> char8 is not an encoding
05:19:02 <mroman> This has the same effect as calling hSetEncoding with char8, together with hSetNewlineMode with noNewlineTranslation.
05:19:03 <merijn> Also, of course it's not going to work if you use Char8
05:19:11 <yogsototh> merijn: Sorry I meant forkIO
05:19:26 <mroman> I should probably use chans instead of these hWaitForInput
05:19:40 <merijn> mroman: Of course it's not going to work
05:19:52 <yogsototh> merijn: I saw this in the doc: http://hackage.haskell.org/package/base-4.7.0.2/docs/System-Exit.html
05:19:58 <merijn> mroman: It literally says right there in the docs that char8 truncats all data
05:20:03 <yogsototh> Note: in GHC, exitWith should be called from the main program thread in order to exit the process. When called from another thread, exitWith will throw an ExitException as normal, but the exception will not cause the process itself to exit.
05:20:23 <merijn> yogsototh: heh, that's silly...
05:20:44 <yogsototh> merijn: this i why I try to catch the ExitException in my main function
05:20:44 <merijn> yogsototh: You're gonna need to use an MVar, Chan or async exceptions to signal termination then
05:21:06 <merijn> yogsototh: You can't, exceptiosn propagate up to the thread they run in and then get thrown into the void
05:21:18 <merijn> I think you can change the default handler, but that's not the right way to go
05:21:29 <yogsototh> merijn: yep, I hoped to find an easier solution.
05:21:36 <yogsototh> merijn: thanks
05:29:09 <lpaste> mroman pasted ‚ÄúTCP Relay‚Äù at http://lpaste.net/119604
05:29:28 <mroman> much better with chans I guess
05:32:16 * hackagebot rethinkdb-client-driver 0.0.12 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.12 (wereHamster)
05:33:35 <mroman> <interactive>: <socket: 25>: hPutBuf: resource vanished (Broken pipe)
05:33:35 <mroman> <interactive>: <socket: 27>: hPutBuf: resource vanished (Broken pipe)
05:33:37 <mroman> <interactive>: out of memory (requested 1048576 bytes)
05:33:41 <mroman> hu
05:36:46 <t4nk648> can you retrieve/review the set of reductions that take place step by step in the execution of your program?
05:36:53 <t4nk648> lets say in ghc
05:37:05 <mroman> it also uses a lot of cpu :(
05:37:17 <merijn> mroman: Yes, why are you turning off buffering?
05:37:26 <merijn> mroman: You're wasting lots of CPU spin looping for no reason
05:38:00 <merijn> Also, why only reading 128 bytes at a time
05:38:20 <merijn> For a relay you should use buffering and read like 4k blocks
05:43:37 <merijn> :t fromList
05:43:38 <lambdabot>     Not in scope: ‚ÄòfromList‚Äô
05:43:38 <lambdabot>     Perhaps you meant one of these:
05:43:38 <lambdabot>       ‚ÄòIM.fromList‚Äô (imported from Data.IntMap),
05:43:40 <danilo2> Hello! What is currently the fastest serialization in Haskell? binary?
05:43:58 <merijn> Where is the IsList class defined?
05:43:59 <merijn> danilo2: Yes
05:44:05 <danilo2> merijn: thanks!
05:47:15 <notdan> binary is faster than cereal?
05:47:31 <merijn> notdan: They're about identical in performance
05:47:49 <merijn> notdan: But cereal has mostly been obsoleted now that binary supports incremental deserialisation
05:48:01 <merijn> Which was the main reason to use cereal
05:48:24 <notdan> ah, I didn't know that
05:48:25 <notdan> thanks
05:48:37 <danilo2> I've got other small question regarding cabal - is it possible to produce executable with module NOT named Main ?
05:49:17 <notdan> Yes, sure
05:49:38 <notdan> just specify your file in `main-is' field
05:50:04 <notdan> https://github.com/lymar/hastache/blob/master/hastache.cabal#L27
05:50:29 <danilo2> notdan: nope, main-is points to a file, but if it is not named Main.hs I got error
05:50:54 <notdan> can you paste the error?
05:52:06 <danilo2> notdan: src/RQueue.hs:3:8:     File name does not match module name:     Saw: ‚ÄòMain‚Äô     Expected: ‚ÄòRQueue‚Äô
05:52:12 <based> hi
05:52:17 * hackagebot keyword-args 0.1.0.5 - Extract data from a keyword-args config file format  http://hackage.haskell.org/package/keyword-args-0.1.0.5 (jsl)
05:52:35 <danilo2> notdan: wait
05:52:37 <notdan> danilo2: hm, can you paste the .cabal file?
05:53:12 <danilo2> notdan: http://lpaste.net/119611
05:53:13 <notdan> is it because in RQueue.hs you actually have a line "module Main where.."?
05:53:26 <danilo2> notdan: this is the error - that one was pasted here by mistake
05:53:33 <based> can python be converted to hasskell
05:53:42 <notdan> Can I see the .cabal file?
05:53:54 <danilo2> notdan: my Rqueue.hs looks like this: http://lpaste.net/119612
05:53:57 <merijn> Is Void in base or not?
05:54:04 <merijn> Not yet, right?
05:55:00 <danilo2> notdan: ok, regarding this: http://stackoverflow.com/questions/12133320/cabal-output-is-redirected-but-not-generated we have to name the file Main.hs :(
05:55:56 <based> mrow
05:55:59 <merijn> Also, I don't suppose there's something like a "default" for associated types?
05:56:06 <notdan> danilo2: no, you have to have a module named Main
05:56:14 <notdan> I don't think you have to put it in a file called Main.hs
05:56:25 <danilo2> notdan: which has to be in file named the same
05:56:45 <notdan> idk, it works for me without a file named Main.hs
05:56:49 <ClaudiusMaximus> danilo2: Main is an exception to that rule
05:56:50 <merijn> No, your main file doesn't have to be called Main.hs
05:57:05 <danilo2> notdan: ugh
05:58:21 <danilo2> notdan, ClaudiusMaximus, merijn: oh, ok! I know why i got error when naming main file other than Main - it was caused by a build system I'm using here, that is generating the cabaldescription and it was putting the file as an exported module also, which caused error. Interesting
05:58:51 <danilo2> notdan, ClaudiusMaximus, merijn: thank you! :)
06:13:25 <askalski> hi, is there a way to use cabal with Frege? Like: to create a sandbox where I preinstall pandoc, and then comunicate with this sandbox from jvm?
06:17:50 <merijn> I don't think so
06:18:13 <merijn> afaik there aren't many people using Frege
06:19:24 <sdegutis> Which one, the .tex or the .verb, is the canonical source file for each chapter in the official Haskell tutorial at https://www.haskell.org/tutorial/?
06:20:46 <danilo2> Hello! Could anybody recommend any priority queue in haskell ? There are many implementations but maybe some are just better? :)
06:24:27 <mpickering> danilo2: I think the psqueues package is the best
06:24:50 <mpickering> not very well known but I trust the people behind it
06:26:37 <danilo2> mpickering: oh, it looks really good! Thank you, I'm going with it definitely!
06:26:49 <jvilla> Is there a reason for [] being the only instance of MonadZip in Control.Monad.Zip?
06:27:27 <danilo2> mpickering: I think hackage needs a "star-like" system - to be able to "star" packages to see which are nice and used. I know the reverse dpes, but this is not appropriate metrics
06:28:18 <merijn> danilo2: That sorta stuff is planned, but hackage needs more devs :)
06:28:24 <merijn> So feel free to contribute :)
06:29:32 <danilo2> merijn: ugh I wish to have more time, really. This night I slept 3 hours - I'm on a deadline now :/
06:29:56 <sdegutis> Anyone know?
06:30:29 <sdegutis> For each chapter there's a .tex and a .verb and they're nearly identical but not quite, and I can't figure out which one is the canonical source file for that chapter.
06:37:19 <sdegutis> That settles it. I'm just going to convert this tutorial to Markdown and be done with it.
06:38:13 <breadmonster> I was watching an OCaml video.
06:39:17 <breadmonster> Does Haskell have Phantom type?
06:39:22 <breadmonster> *types
06:39:28 <yoeight> yep
06:39:50 <yoeight> data Phantom e = Phantom
06:40:51 <node808> Wikipedia refers to haskel as a lazy functional language.  I like lazy so Im here
06:41:13 <notdan> Well, it's true
06:41:50 <notdan> let fibs = 0:1:(zipWith (+) fibs (tail fibs))
06:41:57 <node808> notdan so what is haskell used for exactly?
06:42:01 <notdan> > take 10 fibs
06:42:02 <lambdabot>  Not in scope: ‚Äòfibs‚Äô
06:42:10 <notdan> > let fibs = 0:1:(zipWith (+) fibs (tail fibs)) in take 5 fibs
06:42:12 <lambdabot>  [0,1,1,2,3]
06:42:21 <notdan> node808: it's a general purpose programming language
06:42:29 <node808> so like python or perl?
06:42:38 <notdan> Pretty much
06:42:44 <notdan> in terms of application areas
06:42:58 <itj> node808: you can use it for anything. But the langauge paradigm is completely different that Python or Perl.
06:43:28 <node808> i thought it might be something like pascal...more of an academic exercise than useful
06:43:59 <node808> itj can you explain what you mean by language paradigm
06:44:10 <barrucadu> Haskell is both an academic exercise *and* useful
06:44:23 <itj> Functional Programming vs Imperative Programming
06:44:44 <itj> although, I guess technically you could write imperative haskell code.
06:45:01 <simon> sort of, yes.
06:45:12 <node808> itj what is haskells selling point or claim to fame
06:45:36 <itj> there isn't any one thing
06:45:51 <simon> monadz!
06:45:59 <simon> it's got electrolytes!
06:46:07 <cko> = haskell beginner with question about functors and applicatives
06:46:18 <itj> simon, What programmers crave
06:46:34 <cko> for the (->) r type
06:47:08 <cko> so for the Maybe functor, if you do fmap (+3) Just 3 you get Just 6
06:47:20 <node808> are there any well known haskell based apps?
06:47:22 <yoeight> which criterias discriminate an imperative paradigm ?
06:47:34 <movsb> xmonad
06:47:39 <movsb> :P
06:47:43 <itj> node808: some of these questions are better for google
06:48:22 <node808> itj...true...my bad
06:48:23 <cko> it seems like you apply the (+3) inside the Just wrapper first
06:48:30 <cko> then re-wrap the Just onto that value
06:48:33 <itj> node808: no sweat, we all do it
06:48:39 <notdan> cko: that's exactly what happens
06:48:44 <cko> but if you fmap over two functions
06:48:57 <node808> itj yeah but not everyone is nice about it like you...lol
06:48:57 <cko> like (f . g) x
06:49:00 <cko> you apply g first then f
06:49:05 <cko> so it's the other way arround
06:49:06 <cko> around*
06:49:34 <cko> so it seems asymmetrical
06:49:35 <notdan> cko: hm, not really. there is a functor laws, which states specifically that fmap (f . g) = fmap f . gmap g
06:49:37 <notdan> *fmap
06:49:52 <itj> cko: You're not mapping with the '.' operator, you're composing
06:49:54 <notdan> so it doesn't matter how you do it
06:50:05 <itj> you're saying take the output of g and pipe to f
06:50:24 <cko> oh wait
06:50:31 <itj> that composition is equivalent to a single function
06:51:27 <obiwahn>                                  lambdabot> >1+1
06:51:30 <obiwahn>                                    mueval-core: GhcException "cannot satisfy -package lambdabot\n    (use -v for
06:51:34 <obiwahn> darn
06:51:59 <obiwahn> sorry for that many lines. any suggestion how to fix that error?
06:52:14 <obiwahn> http://ircbrowse.net/browse/haskell?events_per_page=35&events_page=9&q=david this is all i found:(
06:53:35 <clrnd> >1+1
06:53:41 <clrnd> > 1+1
06:53:42 <lambdabot>  2
06:53:56 <cko> fmap (*3) (+100) 1
06:54:02 <cko> > fmap (*3) (+100) 1
06:54:03 <lambdabot>  303
06:54:09 <cko> so in that case, i get 303
06:54:21 <cko> because you apply (+100) to 1, then apply (*3)
06:54:36 <exio4> are you trying to find an analogy for that functor?
06:54:50 <cko> yeah
06:54:56 <cko> i just see assymetry
06:55:03 <cko> asymmetry*
06:55:17 <cko> because the (+100) is the wrapper for 1, right?
06:55:27 <cko> just like in Just 1, the "Just" is the wrapper for 1
06:55:29 <tomphreek>  > :t fmap (*3)
06:55:45 <saep> :t fmap (*3)
06:55:46 <lambdabot> (Num b, Functor f) => f b -> f b
06:56:02 <nshepperd_> cko not quite. 1 is the input here
06:56:05 <jameseb> cko: no, (+100) is the what is being fmapped over
06:56:28 <cko> not the value "inside" the (+100) wrapper?
06:57:19 <nshepperd_> What is being "wrapped" if anything is the result (100 + x)
06:57:25 <cko> ohh.
06:57:41 <cko> oh.
06:57:47 <itj> cko: I think you're are misunderstanding the order of operations
06:57:51 <cko> yeah exactly
06:57:55 <cko> order of operations
06:58:30 <jameseb> cko: what you wrote brackets as (fmap (*3) (+100)) 1, I think
06:58:31 <itj> fmap (*3) $ (+100) 1 is equivelant
06:58:35 <nshepperd_> But it's better to think of the reader/function functor as producing a value, rather than containing one
06:58:35 <tomphreek> learn you a Haskell explains quite well how fmap is just .
06:58:38 <tomphreek> Imho
06:58:45 <notdan> The 'wrapper' intuition kinda fails a little bit in this scenario
06:58:51 <cko> ah okay
06:59:03 <cko> so the function functor "produces" a value
06:59:18 <cko> and a Maybe functor "contains" one
06:59:48 <cko> otherwise it seems like the order of operations is different
06:59:58 <cko> when you fmap functions over them
07:00:43 <cko> because, again, if you fmap (+3) Just 3 you get Just 6. you apply (+3) to the 3 then wrap with Just
07:01:09 <cko> but if you do fmap (*3) (+100) 1
07:01:19 <cko> you apply the +100 first
07:01:23 <cko> then the *3
07:01:37 <damianfral> I'm a bit late in this discussion, is this helpful?
07:01:37 <damianfral> instance Functor ((->) r) where
07:01:37 <damianfral>     fmap = (.)
07:01:45 <nshepperd_> You can even think of maybe as "producing" a value when you unwrap it
07:02:30 <itj> ((fmap (*3)) ((+100) 1))
07:02:54 <cko> yeah itj.
07:03:07 <cko> but for Maybe, you apply the (*3) first
07:03:17 <nshepperd_> In which case it's obvious that you have to unwrap it first before you can apply a function to the contents
07:03:17 <cko> like fmap (*3) Just 1
07:03:25 <cko> okay
07:03:31 <cko> so when you unwrap a function
07:03:40 <cko> you kind of apply the function first
07:03:56 <cko> when you unwrap a Maybe, it's just that value itself
07:05:48 <exio4> cko, I wouldn't try to find an "analogy" that fits all cases
07:05:59 <chpatrick> cko: you don't really unwrap
07:06:03 <nshepperd_> That's a way of intuitively understanding it, yeah
07:06:35 <tomphreek> damianfral: I presume it's not possible to jump to source code when it's compiled to make sure that fmap = (.). Did you just look it up?
07:06:36 <chpatrick> cko: think of it more as just a transformation on the inner type
07:07:12 <itj> cko, a Functor is just an "object" that can perform operations on itself. In a numbers case, it's pretty straight forward, but a Maybe is more abstract.
07:07:27 * tomphreek still working out how to programm something sabstantial in haskell
07:07:29 <jameseb> cko:  that's because what you've got there is actually 'fmap (*3) (Just 1)' but the other example was '(fmap (*3) (+100)) 1'
07:07:40 <chpatrick> what's cool is if you bracket fmap another way
07:07:50 <chpatrick> (a -> b) -> (f a -> f b)
07:07:55 <amyers> cko, fmap (*3) Just 1 is doing the exact same thing that (fmap (*3) (+100)) 1 is doing
07:08:02 <chpatrick> it turns regular functions into functions on f
07:08:10 <amyers> > fmap (*3) Just $ 3
07:08:11 <lambdabot>  No instance for (GHC.Show.Show a0)
07:08:12 <lambdabot>    arising from a use of ‚ÄòM506389567318584456027099.show_M5063895673185844560...
07:08:12 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
07:08:20 <amyers> > fmap (*3) Just $ 3 :: Maybe Int
07:08:22 <lambdabot>  No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
07:08:22 <lambdabot>    arising from a use of ‚ÄòGHC.Num.*‚Äô
07:08:34 <chpatrick> dollar's in the wrong place
07:09:34 <jameseb> cko: in fact, checking in ghci, 'fmap (*3) Just 1' errors
07:09:43 <amyers> Yeah, I see that now :p
07:09:52 <jameseb> > fmap (*3) Just 1
07:09:53 <lambdabot>  No instance for (GHC.Show.Show a0)
07:09:53 <lambdabot>    arising from a use of ‚ÄòM172153874290817768427136.show_M1721538742908177684...
07:09:53 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
07:09:59 <exio4> > fmap (*3) (Just 1)
07:10:00 <lambdabot>  Just 3
07:10:48 <cko> thanks james
07:10:51 <cko> and everyone
07:11:05 <cko> the parenthesis really helped
07:11:19 <cko> otherwise the "order of operations" seemed different
07:14:02 <chpatrick> if my understanding is correct the connection to category theory is that a Functor type maps from haskell types to another set of types, like from a to Maybe a, and fmap maps functions on haskell types to functions on the other set of types
07:14:07 <chpatrick> I don't really know CT though
07:17:07 <simon> itj, I wrote a revue sketch based on that scene in Idiocracy, but fixed for Haskell/monads. :D
07:17:29 <based> <simon>
07:17:46 <based> i wanna learn haskell, i do python, and  node.js
07:18:00 <based> will it be an easy move over?
07:18:27 <movsb> based: try it
07:19:03 <based> writing conversation ai commenting bots and nltk + rhyming dictionary rap bots in python
07:19:04 <itj> simon: link to it :)
07:19:07 <simon> based, since I don't know you, it is hard for me to say.
07:19:15 <based> i can show u what i do
07:19:47 <based> for example
07:19:52 <based> this is 1 of my bots http://www.reddit.com/user/lolhaibai
07:20:16 <based> to see its posting habbits snoopsnoo.com/u/lolhaibai
07:20:27 <based> it tries to fit in as a human it goes unnoticed much of the time
07:21:48 <based> this is 1 user catching on
07:21:53 <simon> itj, I'll translate it quickly.
07:21:54 <based> http://www.reddit.com/r/conspiracy/comments/2sr974/anyone_ever_seen_an_account_like_this_before/
07:27:49 <simon> itj, http://hastebin.com/fabosenapi.dos
07:28:12 <tomphreek> I have seen this on SE, but wasn't fully satisfied with the answer. What is up with the variable names in Haskell? nts      <- parseFromFile templateFile tmplFile. nts? not helpful
07:28:43 <simon> itj, I write a lot of sketches for the revue that promote functional programming, so I thought I'd write one that didn't by making Haskell programers seem like the dumbest people alive. :P
07:29:59 <based> what kind of language is haskell
07:30:07 <based> would you say its anything like python?
07:30:53 <tomphreek> based: list comprehension in python are basically the same as in haskell
07:31:04 <tomphreek> based: but the rest is totally different
07:31:22 <based> could this be done in haskell http://i.imgur.com/Pr6SbBu.png
07:31:53 <based> its a list issue that i need  actully
07:31:54 <tomphreek> based: just play around with small problems, project eulor is good or H-99
07:32:07 <based> subid = list(submissionid.distinct('submissionid'))
07:32:33 <based> how would this be done in haskell   distinct('submissionid'))
07:33:03 <itj> simon: That's pretty good :)
07:33:23 <tomphreek> based: I suspect your ques are too generic and probably won't be answered. But we will see.
07:33:38 <based> actully
07:33:47 <based> wellmongo uses _id
07:33:51 <based> with a unique verfiyer
07:34:11 <based> for submissions in new submissions if id is not in submissionids
07:35:37 <clrnd> simon, that was HILARIOUS
07:36:06 <simon> hehe, nice
07:36:35 <clrnd> that's my tagline right there: 'it has monads'
07:37:22 * hackagebot usb-hid 0.1.0.0 - Parser and request Library for USB HIDs  http://hackage.haskell.org/package/usb-hid-0.1.0.0 (TiPi)
07:41:12 * AshyIsMe sighs
07:41:13 <movsb> clrnd: channel topic
07:41:41 <AshyIsMe> cabal install cabal-install doesnt actually replace the cabal that's on my $PATH
07:41:44 <Lokathor> based, https://hackage.haskell.org/package/mongoDB will probably be what you're looking for
07:42:03 <AshyIsMe> i dont think it ever successfully has on my mac
07:42:21 <based> do they got praw in haskeell
07:42:24 <based> plz say yes lol
07:42:28 <Lokathor> ashyisme, i had the same problem last night. I ended up using the --global flag, and then uninstalling the version provided by my package manager
07:42:32 <based> or another reddit api
07:42:45 <stelleg> AshyIsMe: do you have ~/.cabal/bin in your PATH?
07:43:24 <Lokathor> based, i don't know what praw is, but you can connect to website and stuff so you could probably build an API to connect to reddit if you had to.
07:43:54 <AshyIsMe> Lokathor: oh wow i have ghc 7.4 installed through brew apparently... :O
07:44:09 <sveit> monochrom: did you get around to writing that imperative sieve?
07:44:35 <sveit> monochrom: nvm, got your link, thanks!
07:44:41 <AshyIsMe> stelleg: no but cabal isnt in that path
07:44:59 <AshyIsMe> i have ~/Library/Haskell/bin in my path
07:46:59 <based> Lokathor> http://praw.readthedocs.org/en/v2.1.20/
07:47:52 <AshyIsMe> this looks pretty damn awesome: http://www.haskellforall.com/2015/01/use-haskell-for-shell-scripting.html
07:47:52 <Lokathor> based, hmm, i think you'd need to build this thing yourself
07:48:04 <stelleg> AshyIsMe: is it in your PATH before the path that contains your existing cabal?
07:48:39 <based> actilly
07:48:42 <based> it wouldnt be to hard
07:48:49 <based> since reddit is litterly 1 big json object
07:49:02 <based> http://www.reddit.com/user/lolhaibai.json
07:49:08 <based> http://www.reddit.com/user/lolhaibai/comments.json
07:49:34 <based> http://www.reddit.com/r/conspiracy.json
07:49:44 <tomphreek> AshyIsMe: I was craving for some kind of lazily typed and statically typed shell upgrade on bash. Windows now have it with PowerShell
07:49:56 <tomphreek> Haskell is a good candidate
07:50:24 <mniip> haskell shell mmm
07:50:30 <hiptobecubic> there's shelly, no?
07:51:00 <hiptobecubic> Has anyone read through dons' slides from the google tech talk? http://code.haskell.org/~dons/talks/dons-google-2015-01-27.pdf
07:52:02 <hiptobecubic> I'm wondering about how he talks about phantom types. My impression is that GADTs were basically phantom types without the problem of being able to put any crazy old thing in the type variable. Why would one prefer phantom types over gadts?
07:52:05 <AshyIsMe> tomphreek: powershell is nowhere near as fun as haskell though :D
07:52:28 <AshyIsMe> stelleg: turns out im an idiot, cabal told me it couldnt create a symlink there because it already exists and isn't managed by cabal
07:52:54 <Lokathor> based, try looking here too then https://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html
07:56:56 <tomphreek> it seems that lazy piping requirement has to be dropped in order of the new shell to be backwards compatibile with existing unix tools. shame that, command | sort | head -n5 is such a common pattern
07:57:16 <bss> So, I'm on a Windows 7 machine.  I have the latest Haskell Platform and cygwin installed.  But, 'cabal install cabal-install' fails every time, from both bash and cmd.
07:57:28 <based> http://i.imgur.com/GP9trUj.gif
07:57:38 <bss> From bash, error is: "cabal.exe: does not exist"
07:57:51 <bss> From cmd, no error, but after the install I'm still using the old cabal.
08:07:23 * hackagebot uhc-light 1.1.8.5 - Part of UHC packaged as cabal/hackage installable library  http://hackage.haskell.org/package/uhc-light-1.1.8.5 (AtzeDijkstra)
08:08:23 <stelleg> AshyIsMe: glad you figured it out
08:08:52 <Saizan> bss: sounds like a $PATH issue to me
08:09:09 <bss> I got bash working, but I've still got the wrong cabal on my path, and I haven't been able to figure out where cabal is putting the new binary.
08:09:51 <tomphreek> :t mappend
08:09:52 <lambdabot> Monoid a => a -> a -> a
08:09:57 <bss> Saizan: I've not customized my $PATH.  It should work by default, yes?  Or, is it supposed to be broken by default and there's a documentation I can't find for how to fix my $PATH?
08:10:41 <Saizan> bss: the "Haskell Platform" might configure it, otherwise it's not going to work by default
08:11:25 <Saizan> bss: i don't know the paths on windows, if you can find the config file for cabal it should be there under install-dirs
08:12:23 * hackagebot th-desugar 1.5 - Functions to desugar Template Haskell  http://hackage.haskell.org/package/th-desugar-1.5 (RichardEisenberg)
08:37:25 * hackagebot postgresql-simple-sop 0.1.0.4 - Generic functions for postgresql-simple  http://hackage.haskell.org/package/postgresql-simple-sop-0.1.0.4 (glutamate)
08:44:57 <nkar> since when does ghci allow to define datatypes, newtypes, and type aliases?
08:45:03 <glguy> 7.6 afaik
08:47:25 * hackagebot postgresql-simple-sop 0.1.0.5 - Generic functions for postgresql-simple  http://hackage.haskell.org/package/postgresql-simple-sop-0.1.0.5 (glutamate)
08:51:59 <ahammel> Ever seen a cabal-install just fail with no error message?
08:52:31 <joseph__> no
08:52:40 <ahammel> then i envy you
08:54:09 <hodapp> http://www.haskellforall.com/2015/01/use-haskell-for-shell-scripting.html more shell scripting in Haskell?
08:54:15 <hodapp> what are you people trying to do, destroy Python's territory?
08:56:08 <ahammel> Only thing I can think is a warning that one particular package requires Cabal >= xxx, but that's for the Distribution.Simple package
08:56:22 <ahammel> and it's installed to a sandbox as part of the build chain anyway
08:56:29 <kranius> hodapp: writing all my clue code and little scripts in Haskell helped me a lot during my learning process
08:56:52 <hodapp> leave the Pythoners alone >:|
09:04:35 <ahammel> the damnable thing builds just fine on my machine, but as soon as I push it to the build server: *kaboom*
09:05:46 <koomi> ahammel: did you build with -v?
09:05:57 <kranius> hodapp: pythoners have python things to do, they won't even notice
09:06:15 <based> hi
09:06:21 <based> i luv pytho
09:06:50 <Ankhers> Is there an issue with the wiki.haskell.org cert?
09:07:18 <ahammel> rebiuliding with -v now
09:08:05 <geekosaur> "The identity of this website has been verified by GlobalSign Domain Validation CA - SHA256 - G2 but does not have public audit records."
09:10:38 <Ankhers> geekosaur: What browser?
09:12:07 <glguy> I get "Your connection to wiki.haskell.org is encrypted with obsolete cryptography. However, this page includes other resources which are not secure."
09:12:47 <johnw> geekosaur: I wonder what changed; can you bring this up in #haskell-infrastructure?
09:12:52 <glguy> and on my phone I get a red strikethrough on the https
09:13:31 <johnw> yes, I see verify error:num=19:self signed certificate in certificate chain
09:13:53 <geekosaur> Ankhers, Chrome, OS X
09:16:12 <geekosaur> also I think wiki is on a CDN now? (and, from where are you accessing it? it's becoming distressingly common for businesses to use snooping MITM boxes that negotiate encryption to the actual site themselves and to you with their own cert and some fakery)
09:23:48 <sdegutis> I began translating the official tutorial to a much easier format to read:  http://sdegutis.github.io/goodies.html
09:24:09 <sdegutis> As you can see, only half of one page is done, so there's a long way to go still.
09:24:43 <indiagreen> sdegutis: pandoc can convert TeX to Markdown
09:25:02 <sdegutis> indiagreen: it would miss things so I'd still have to go through it
09:25:16 <sdegutis> indiagreen: this way at least I only go through it once
09:25:21 <sdegutis> and it's really not that hard
09:25:28 <indiagreen> you only have to go thru it once either way
09:25:51 <sdegutis> there's more to it that I don't wanna get into
09:26:33 <indiagreen> ‚ÄúIdentifiers such as a above are called {\em type variables}‚Äù
09:26:46 <indiagreen> is it in the part you already went thru?
09:27:02 <sdegutis> yes
09:27:07 <sdegutis> downloading pandoc
09:27:23 <sdegutis> im in a really horrible mood right now fwiw so im angry at you even though you're right
09:27:50 <indiagreen> oh, well, I'm not offended because I'm in a bad mood as well
09:28:02 <sdegutis> :)
09:28:04 <ahammel> LET'S ALL BE ANGRY TOGETHER
09:28:43 --- mode: ChanServ set +o johnw
09:28:44 --- mode: johnw set +b *!40fb521e@gateway/web/freenode/ip.64.251.82.30
09:28:44 --- kick: ahammel was kicked by johnw (Kicked)
09:28:44 --- mode: johnw set -o johnw
09:29:08 <tomphreek> kicked? I thought it was funny :(
09:29:13 <indiagreen> and that's why you shouldn't get *too* angry
09:29:41 <geekosaur> ...that does seem a bit excessive
09:29:56 <indiagreen> maybe johnw was angry as well
09:30:04 <sdegutis> so yeah, pandoc does screw it up pretty badly
09:30:22 <sdegutis> the outputted markdown is not only awful but even missing data/text
09:30:28 <indiagreen> hm-m
09:30:32 <indiagreen> going to look at it
09:30:54 <athan> Is there a `urlEncode` for strict Text?
09:31:02 <athan> (or lazy, now that I think of it)
09:31:09 <sdegutis> indiagreen: dont worry about it, i wanna do this
09:34:41 <indiagreen> yeah, apparently so
09:34:47 <indiagreen> darn, I thought Pandoc was better at it
09:39:01 <PinballWZRD> hey guys if nothing else is being discussed currently, I've got a question regarding HTTP conduit
09:39:43 <koomi> PinballWZRD: you can always ask questions, no need to ask to ask
09:39:48 <PinballWZRD> lol cool,
09:39:51 <PinballWZRD> anyway
09:41:11 <PinballWZRD> I'm writing a little game script to interact with a JSON api, the problem I'm running into is keeping around the session cookies, This seems like a job for the State monad, but I am still pretty new to all of this, any thoughts?
09:41:23 <sdegutis> ahhh, there's one thing that's gonna be a bit tricky to translate from the original tutorial latex source
09:41:47 <sdegutis> most of it is already in markdown (even footnotes). what's *not* here is automatic page/section numbering and referencing
09:42:11 <sdegutis> I can convert it to manual referencing, but it's even more work to automatically number it.
09:42:30 <sdegutis> I think I'll just skip numbering sections and subsections and only refer to them by name.
09:43:22 <tomphreek> :t <?>
09:43:23 <lambdabot> parse error on input ‚Äò<?>‚Äô
09:43:35 <koomi> :t (<?>)
09:43:36 <lambdabot>     Not in scope: ‚Äò<?>‚Äô
09:43:36 <lambdabot>     Perhaps you meant one of these:
09:43:37 <lambdabot>       ‚Äò<*>‚Äô (imported from Control.Applicative),
09:44:08 <geekosaur> looks like Parsec or attoparsec?
09:44:36 <tomphreek> found it in hoogle
09:44:47 <tomphreek> Text.Parsec.Prim (<?>) :: (ParsecT s u m a) -> String -> (ParsecT s u m a)
09:45:32 <koomi> PinballWZRD: if you have to modify the cookie, then carrying it around in State is sensible, yes
09:46:02 <sdegutis> :t (<$>)
09:46:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:46:45 <PinballWZRD> koomi: If no mod is necessary would it better be carried in a Reader?
09:47:06 <koomi> exactly
09:47:26 <PinballWZRD> awesome, that was my initial guess
09:48:13 <trampel> 1000 pardons, newbie question:  "Not in scope: `nub'" while on debian with ghc libghc-utility-ht-dev installed; how does one discover what to import, or package to install to get "nub"??  thank you!
09:49:25 <koomi> trampel: you can search on hoogle or hayoo
09:50:00 <johnw> it appears I banned ahammel incorrectly, thinking he was a bot!
09:50:13 <geekosaur> although that won't help with knowing what vendor package it might be in (in this case it's not actually relevant though)
09:50:15 <trampel> hoogle (i think) says i've got it:  ... ata.List nub :: Eq a => [a] -> [a]   however import Data.List is not there
09:50:17 <Iceland_jack> trampel: "import Data.List"
09:50:31 <geekosaur> um
09:50:46 --- mode: ChanServ set +o shachaf
09:50:47 <geekosaur> Data.List is part of the ghc base package, it's hard to not have it installed and have a working ghc
09:50:52 --- mode: shachaf set -bo *!40fb521e@gateway/web/freenode/ip.64.251.82.30 shachaf
09:50:59 <trampel> oh crap... "import Data.List" now seems to work.  i'm sorry to trouble you all!
09:51:10 <Iceland_jack> trampel: No worries
09:53:49 <trampel> ok here's one that i don't think is all my imagination, a direct quote from "Learn You...":  "One big difference between the two types of folds is that right folds work on infinite lists, whereas left ones don't"
09:54:09 <trampel> so foldr can fetch the right side of [1..]  somehow?
09:54:29 <geekosaur> that is not quite true, but has the germ of a truth in it
09:54:37 <johnw> trampel: foldr receives a thunk to the evaluation of foldr on the remainder of the list
09:54:45 <geekosaur> foldr doesn't *have* to find the end of the list if it can produce a result before then
09:55:08 <geekosaur> laziness means it only goes forward in the list when something demands a value from it
09:55:26 <geekosaur> left folds can't generally produce a result until the whole list is traversed
09:56:07 <trampel> ok... i'm following this somewhat, but how does foldr even get one value to be lazy with given [1..] ?
09:57:07 <geekosaur> > take 3 [1..]
09:57:08 <zwer> > let (x:xs) = [2..0] in c
09:57:08 <lambdabot>  [1,2,3]
09:57:10 <lambdabot>  c
09:57:14 <kadoban> trampel: foldr f z xs  just replaces each (:) in xs with f, and the [] at the end of xs with z.   So foldr (:) []    is just 'id' (for lists). So since you can do 'take 5 [1..]', you could also 'take 5' on the result. The same also works on more interesting usages of foldr of course.
09:57:18 <glguy> foldr f z [1..] = f 1 (foldr f z [2..])
09:57:30 <zwer> > let (x:xs) = [0..] in x
09:57:32 <lambdabot>  0
09:57:51 <geekosaur> so [1..] can produce values as long as they are demanded, it does not *have* to be infinite. if the function you fold across it can *also* produce values incrementally as demanded, foldr does not &have* to traverse the whole list
09:58:38 <trampel> so foldr doesn't have to consider the right side of the list argument?
09:59:25 <kadoban> trampel: It can know the first part of the answer without knowing the /whole/ answer, is the important part.
09:59:40 <sdegutis> What ways would a tutorial to Haskell 98 be outdated compared to Haskell 2010?
09:59:58 <trampel> and that "first part" of an infinite list is the second member of that list?
10:00:30 <geekosaur> if you fold something strict (like (+) for most numeric types) then it will try to traverse the whole list. if you fold something that can produce an immediate result, and whatever is getting data from the fold is satisfied with that partial result (like the "take" I did earlier), then there's no reason it needs to walk the whole list, only the part necessary to satisfy the valler's needs
10:00:33 <monochrom> > foldr1 (||) (repeat True)
10:00:33 <geekosaur> *caller's
10:00:35 <lambdabot>  True
10:00:50 <monochrom> an infinite list and a foldr that finishes promptly
10:01:15 <geekosaur> again, this relies on laziness. if you do it with something strict it must traverse the whole list.
10:01:17 <monochrom> this destroys many wrong intuitions
10:02:54 <f-a> is there any caveat against using a m4 as a preprocessor in a haskell project (e.g. not available on some platforms, problems in uploading to hackage, etc.)
10:03:01 <trampel> it would seem (therefore) that laziness achieves a conclusion with infinite lists for special circumstances with foldr, which aren't possible for foldl?
10:03:49 <sdegutis> Is https://www.haskell.org/tutorial/ outdated and incorrect now?
10:03:52 <monochrom> yes
10:04:01 <sdegutis> In a severe way?
10:04:02 <monochrom> > foldl1 (||) (repeat True)
10:04:06 <lambdabot>  mueval-core: Time limit exceeded
10:04:09 <sdegutis> monochrom: were you answering me?
10:04:12 <monochrom> no
10:04:14 <trampel> yes like the case of the boolean set
10:04:15 <sdegutis> monochrom: phew
10:04:35 <ReinH> trampel: It has to do with the strictness of the operator
10:04:47 <ReinH> A strict (||) wouldn't work for foldr either
10:04:55 <trampel> so i'm ending up suspecting that this quote "One big difference between the two types of folds is that right folds work on infinite lists, whereas left ones don't" is a bit over generalized
10:05:16 <monochrom> yes
10:05:26 <monochrom> every rule of thumb is wrong
10:05:29 <trampel> thank you!  it was bugging me no end.
10:05:39 <ReinH> > foldr1 max (repeat True)
10:05:40 <lambdabot>  *Exception: stack overflow
10:05:44 <kyclark> re: http://lpaste.net/3756271727273836544
10:05:52 <kyclark> i'm getting "Kmer.hs:10:9: parse error on input ‚Äò|‚Äô"
10:05:53 <ReinH> (max is a strict (||) for Bool)
10:05:54 <geekosaur> sadly LYAH is full of questionable platitudes like that
10:05:57 <kyclark> but I can't see the problem
10:06:16 <thinkpad20> hey all, what's the extension that enables you to use the Symbol kind in a type class?
10:06:22 <trampel> (get it?  "no end"  [1..]  bwahahah... ahem)
10:06:23 <geekosaur> you must provide a pattern
10:06:41 <geekosaur> unless you were looking for the MultiWayIf extension, but you're using that incorrectly if so
10:07:12 <geekosaur> in fact you don't want to use | at all there since your first case is a pattern
10:07:20 <geekosaur> not a guard
10:07:29 * hackagebot debian-build 0.5.0.1 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.5.0.1 (KeiHibino)
10:07:36 <geekosaur> (and the second case you want _ instead of otherwise, sicne it is a pattern, not a guard)
10:08:08 <geekosaur> patterns are a description of what the data looks like. guards are "if" conditions
10:08:20 <geekosaur> (file:_) is a pattern describing a list with at least one element
10:08:21 <kyclark> OH!  of course
10:08:58 <kyclark> FIXED! http://lpaste.net/3756271727273836544
10:09:05 <kyclark> thanks, geekosaur
10:10:08 <sdegutis> Is https://www.haskell.org/tutorial/ outdated and incorrect now?
10:10:59 <thinkpad20> is it possible to have a type class where one of the parameters not of kind *?
10:11:06 <geekosaur> it is somewhat outdated, certainly, since it's haskell98. not sure it's incorrect
10:11:21 <geekosaur> :k MonadState
10:11:22 <lambdabot> * -> (* -> *) -> Constraint
10:11:31 <geekosaur> there's one
10:11:51 <sdegutis> geekosaur: are there any differences in Haskell 2010 that could make a Haskell 98 tutorial teach bad practices?
10:11:58 <alpounet> sdegutis: there is some nicer material out there, which doesn't mean this tutorial should be thrown out of the window. but it's not recommended much these days. i did use it a bit back when i started learning haskell
10:12:13 <geekosaur> sdegutis, the only thing that occurs to me offhand is removal of n+k patterns
10:12:21 <sdegutis> alpounet: nicer in what ways? I'm halfway through the first chapter and I'm loving this tutorial so far
10:12:27 <alpounet> and it doesn't cover recent things, or extensions that were made standard (or removed from it) in haskell2010
10:12:42 <benzrf> alpounet: there is really not much difference
10:12:43 <kyclark> q
10:12:51 <alpounet> sdegutis: to be honest, i'd just say that if it helps things click in your ahead, keep going with that one
10:13:02 <sdegutis> alpounet: well it's not just that I want to learn it
10:13:04 <sdegutis> I'm reformatting it too
10:13:09 <alpounet> yeah, saw that :)
10:13:13 <sdegutis> see http://sdegutis.github.io/goodies (it's a WIP)
10:13:33 <sdegutis> but if it's gonna be a huge waste of time, then i dunno if i should do it
10:13:40 <sdegutis> in terms of this tutorial being discouragd
10:13:47 <sdegutis> that said, i could update the tutorial as i go along
10:13:56 <Iceland_jack> It's discouraged?
10:13:59 <alpounet> sdegutis: it won't get recommended anywhere near as much as the more recent publications about learning haskell
10:14:01 <sdegutis> Iceland_jack: thats what im asking
10:14:04 <geekosaur> I think it's only discouraged in the sense that it's not as "gentle" as it claims to be
10:14:08 <reem> Where does cabal install executables?
10:14:17 <reem> (on OS X)
10:14:18 <Iceland_jack> It was written by Hudak..
10:14:19 <geekosaur> (I found it fairly gentle but I came into it with considerable experience)
10:14:26 <ReinH> reem: Probably ~/.cabal/bin
10:14:27 <alpounet> reem: by default, when not using a sandbox, it installs them in $HOME/.cabal/bin
10:14:38 <geekosaur> reem, depending on how you installed it ~/.cabal/bin or ~/Library/Haskell/bin
10:14:48 <reem> thanks everyone
10:15:43 <alpounet> sdegutis: if your worry is that it teaches wrong things, that's not the case. but it isn't used as much as it was several years ago, so the nicer formatting won't be as useful as you might be hoping
10:16:51 <geekosaur> depends. if this means people give it a bit more love then it can become useful again
10:17:13 <geekosaur> also LYAH arguably sucked a lot of air out of it without providing much of an improvement
10:17:13 <alpounet> Real World Haskell, Learn You A Haskell, the NICTA course, Brent Yorgey's lecture notes and maybe a few other things are the most used ressources for learning haskell this days
10:17:29 * hackagebot base58-bytestring 0.1.0 - Implementation of BASE58 transcoding for ByteStrings  http://hackage.haskell.org/package/base58-bytestring-0.1.0 (AlekseyUymanov)
10:17:30 <alpounet> these*
10:20:18 <sdegutis> alpounet: what geekosaur said
10:20:29 * mpickering thinks that the FP Complete IDE is really cool
10:20:33 <sdegutis> I read most of Learn You a Haskell and it was just such a waste of time for me
10:20:50 <sdegutis> this tutorial is great, but the awful formatting turned me away from it so i went to LyaH
10:20:56 <sdegutis> if the formatting was better, i think more people might try it
10:21:25 <ajcoppa> sdegutis: have you tried the guide recommended in #haskell-beginners? CIS194 followed by NICTA has been pretty successful for a lot of learners
10:22:04 <sdegutis> ajcoppa: i didnt see much of a reason to use that over this tutorial
10:22:28 <alpounet> sdegutis: i've done most of my initial learning with a mix of RWH and the tutorial you're learning with right now (because RWH wasn't out yet), and i'm doing just fine. there's no one true way to learn anything, haskell is no exception. i'd definitely not stop you from giving some love to the gentle intro, but i'm just warning you that this material isn't recommended much these days
10:23:09 <ajcoppa> one significant reason is that CIS194 and NICTA include exercises that help you verify your understanding of the material
10:23:26 <alpounet> and you're likely to get different opinions depending on who you ask
10:24:28 <ajcoppa> yep, of course feel free to use what you prefer. i see exercises as very important in making sure one's mental model matches reality
10:24:30 <Iceland_jack> I think it's a good idea to keep many different approaches to teaching Haskell nicely formatted and modern
10:25:37 <alpounet> +1 with Iceland_jack -- and these days there's just no way anyone will complain there's no ressource for learning haskell
10:26:11 <sdegutis> alpounet: but why isnt it much recommended? thats what im trying to find out
10:26:40 <geekosaur> sdegutis, I don't think that's a useful question, really. until recently LYAH was the only thing that had been recommended for several years
10:26:43 <alpounet> sdegutis: some people don't find it as gentle as they'd like it to be and need a more progressive material
10:26:53 <geekosaur> "fashion" is as likely to be the answer as anything else
10:26:53 <alpounet> but it's just fine for some other people
10:27:02 <sdegutis> geekosaur: well that's silly, LyaH is really not the best out there
10:27:09 <sdegutis> alpounet: ok
10:27:12 <alpounet> sdegutis: it's not the best *for you*
10:27:17 <alpounet> it worked like a charm for others
10:27:18 <geekosaur> and, well, there's never a single approach that works for everyone; the more different kinds of resources that are out there, the better
10:27:38 <sdegutis> alpounet: right, and thus *for at least some people*
10:27:48 <sdegutis> right, im with geekosaur
10:27:53 <alpounet> i'm too
10:27:58 <sdegutis> if i can help at least some people, then im all for it
10:27:59 <alpounet> that's my point
10:28:24 <sdegutis> ok
10:28:26 <geekosaur> and while we have the course notes and online courses, I know (not just know of) people who have trouble following such things unless in an actual classroom environment
10:28:49 <geekosaur> or who otherwise can't make good use of them without someone in the role of TA standing by
10:29:18 <geekosaur> so I think rehabilitating the Gentle Introduction is a good thing
10:29:31 <geekosaur> the more approaches we have available, the better
10:29:41 <sdegutis> sure
10:29:44 <alpounet> sdegutis: i've seen some people be completely lost with RWH whereas it worked like a charm for me. so yeah, no single ressource will make everyone agree, hence my suggestion for you to go ahead and clean up the gentle intro. just make an announcement somewhere when it's ready so that people know it's available in a nicer format
10:29:56 <sdegutis> ok
10:30:10 <sdegutis> thanks everyone for your encouragement despite my difficulty unerstanding basic things right now :)
10:30:24 <Iceland_jack> Good luck with the tutorial sdegutis
10:30:30 <sdegutis> thanks
10:31:02 <sdegutis> also,
10:31:34 <sdegutis> If anyone wants to help me out, one thing that would really help significantly is if they could skim through the Gentle Introduction for things that should be different to account for Haskell 2010 and let me know of them so I can add them in.
10:31:46 <sdegutis> Otherwise I can try to do it entirely on my own without help if need be.
10:31:50 <sdegutis> (while learning Haskell)
10:32:06 <Iceland_jack> sdegutis: You may be overestimating the changes from Haskell98 to Haskell 2010
10:32:24 <sdegutis> Iceland_jack: I'm assuming it's probably just the n+k thing, but there might be module names or whatever else that need to change
10:32:33 <geekosaur> as I said earlier, for H2010 it's just n+k patterns
10:32:50 <Iceland_jack> Those changes are pretty minimal, the real changes are in language extensions and various features of GHC
10:32:56 <geekosaur> I *think* the GI already focused on hierarchical modules, which were an extension to H98
10:33:05 <geekosaur> most of the big changes are not part of a standard yet
10:33:40 <geekosaur> and I am not sure I'd rush to make them; Applicatives, for example, will have a bit nicer story after ghc 7.10 is widespread
10:34:45 <sdegutis> oh ok
10:34:53 <sdegutis> great cool
10:34:56 <geekosaur> (right now you can say that *most* Monads are Applicatives; with 7.10 *all* are and must be)
10:35:05 <sdegutis> geekosaur: oh nice
10:35:32 <raek> sdegutis: there are of course things you may want to learn about that are not mentioned in the gentle introduction. it mostly considers language features.
10:35:35 <geekosaur> but this is the kind of thing that makes tutorials and such hard to keep up to date; RWH kinda got blindsided by a bunch of changes shortly after it was published
10:35:47 <raek> for example, what are libraries that everyone should know about
10:36:08 <raek> what type classes are commonly used
10:36:23 <raek> (for example Functor, Applicative, Monad, Foldable, Traversable)
10:36:58 <raek> was the monomorphism restriction removed in haskell 2010?
10:37:39 <sdegutis> raek: oh hmm
10:38:27 <tel> raek: I think it was just removed in GHCi in 7.8
10:38:43 <Iceland_jack> Yes I think so too
10:38:46 <tel> rather, undefaulted
10:40:25 <raek> this guide seems to cover many subjects too: http://www.stephendiehl.com/what/
10:40:38 <raek> most importantly, cabal
10:41:10 <tel> If you follow the standard practice of providing type signatures for all top-level definitions then the MR doesn't really bite. Most people do this in coding in files, so the major pain point is GHCi
10:43:26 <raek> sdegutis: I think the gentle guide is to Haskell what the clojure.org pages are to Clojure.
10:43:30 <raek> if that makes sense
10:43:40 <sdegutis> sure
10:43:48 <sdegutis> raek: wait do I know you from #clojure ?
10:43:57 <raek> yes
10:46:23 <f-a> mhh, ok, I rephrase, has anyone used {-# OPTIONS_GHC -F -pgmF m4 #-} succesfully?
10:46:36 <f-a> I am getting a m4: cannot open `/tmp/ghc8403_0/ghc8403_1.hspp': No such file or directory
10:48:29 <sdegutis> raek: oh hi
10:49:33 <sdegutis> raek: when'd you start learning haskell?
10:51:41 <meretrix> Is there any reason not to put my application's integration test in their own cabal package?
10:52:39 <raek> sdegutis: around 2012 I think.
10:52:42 <sdegutis> ok cool
10:56:45 <tomphreek> I am trying to implement any using foldr so that it works on infinite lists
10:57:10 <tomphreek> I am trying to implement any using foldr so that it works on infinite lists
10:57:34 <shachaf> foldr isn't the only way to write things that work for infinite lists, of course. You can also write it by hand.
10:57:52 <tomphreek> .
10:58:12 <tomphreek> sorry for spam, got confused by the scroll
10:58:38 <tomphreek> so let {f g _ True = True; f g x False = if (g x) then True else False;}
10:58:48 <breadmonster> Off topic but does anyone know the intricacies of GRUB around here?
10:59:03 <tomphreek> let test = f (\x -> x == 10)
10:59:17 <tomphreek> let test = f (\x -> x == 10)
10:59:24 <tomphreek> foldr test False [1..9]
10:59:35 <tomphreek> works. but doesn't work on infinite ones
11:00:49 <johnw> tomphreek: you'll need a short-circuiting operation in there somewhere, so that it stops looking further down the list
11:01:11 <geekosaur> the way you have it defined, it can shortcircuit on True but not False
11:01:26 <tomphreek> True was the shortcircuit I added
11:02:19 <geekosaur> something like this is true of the existing any and all, as well: any can shortcircuit on True, all can shortcircuit on False, but the other case for each requires it to keep trying the next thing in the list
11:03:24 <geekosaur> so, the False case for any can't work on infinite lists, because it can only return False if the entire list is False
11:03:28 <nnmap> What is the language that is similar to Haskell, but not lazy? I'm interested in learning a functional prog. language, but I'm afraid I don't have what it takes to understand lazy evaluation.
11:03:31 <tomphreek> I thinki I am gonna need to curry a tupple
11:03:37 <geekosaur> if it ever finds a True then it can return right away
11:04:00 <johnw> think on what this is doing: \y -> foldr (\x rest -> x == y || rest) False
11:04:01 <hellofunk> nnmap: well clojure is functional and the lazy part is not at the language level like haskell, but is just another function
11:04:03 <geekosaur> nnmap, depending on how you define similar, there are several possibilities
11:04:04 <chpatrick> ocaml?
11:04:32 <raek> nmap: ocaml? standard ml?
11:04:54 <quchen> Or maybe try Haskell and find out whether laziness is really as strange as you think.
11:05:28 <hellofunk> some of us have gone the other direction. interested in haskell specifically because of the laziness. (and because of the right folds :) )
11:07:45 <dfeuer> I have a question: If I define something like HList, but with HCons :: e -> {-# UNPACK #-} !(HList l) -> HList (e ': l), I believe that should be represented (almost?) exactly like a tuple. But is GHC smart enough to avoid walking the thing at runtime when indexing into it?
11:07:53 <geekosaur> tomphreek, and you can't rely on an infinite list being [1..] or [1, 1..] because then I can break your funntion by asking e.g. any (== 0) ([1..] ++ [0])
11:08:28 <geekosaur> (mind, *nothing* is goinvg to handle that case correctly!)
11:08:44 <sdegutis> raek: do you prefer Haskell over Clojure?
11:09:29 <dfeuer> geekosaur, I disagree with you.
11:09:32 <ElderFain> nnmap: you could try the guide in #haskell-beginners, its been pretty helpful for me
11:10:12 <dfeuer> geekosaur, [1..]++[0]=[1..]
11:10:15 <koomi> haskell and clojure are rather different IMO
11:10:29 <koomi> a ML-like language vs. a lisp
11:10:33 <geekosaur> dfeuer, oh, you can build something that solves that one analytically. but there are more examples where that one came from
11:10:55 <dfeuer> geekosaur, I may be missing some context.
11:11:12 <nnmap> Ocaml, that looks promising. As for lazyness, I tried to figure out it's implementation in several languages (over the years - assembler, Perl, Javascript, Lisp) - I just don't understand. I mean, I understand the concepts,  but for some reason I'm completely unable to follow even moderately complex code. What would make Haskell different? Too bad for me.
11:12:37 <tomphreek> geekosaur: I want myAny (== 10) [1..] to shortcircuit, but I failed. I didn't quite get whether you are saying it's possible with foldr or not
11:13:35 <tomphreek> recurrence would be easier, but still trying to get foldr to work
11:13:38 <geekosaur> tomphreek, that one should be possible, if yours fails then you are being too strict somewhere
11:13:56 <recurrence> agreed
11:17:55 <raek> sdegutis: currently I prefer Haskell. I find the types very helpful (especially sum types!).
11:18:16 <sdegutis> raek: heh that's the same way i feel
11:18:33 <raek> I guess I prefer no type system over a bad type system, but a good type system over no type system
11:19:35 <raek> a type system like Hindley-Milner is amazingly powerful for being so simple
11:21:59 <sdegutis> raek: im tweeting that
11:22:38 <raek> sdegutis: what's your twitter handle?
11:22:45 <sdegutis> https://twitter.com/_sdegutis/status/561242624422871040
11:23:20 <augustss> yo
11:23:32 <Hijiri> yoyo
11:25:34 <dmj`> sdegutis: you should join #ChicagoHaskell
11:25:42 <tomphreek> johnw: failed to understand why yours work mine doesn't :(
11:25:46 <sdegutis> dmj`: so nice
11:26:19 <tomphreek> as in I think I understand why mine doesn't work, cuz False doesn't short circuit
11:26:40 <tomphreek> but don't see the short-circuit in johnw's either :(
11:28:30 <tomphreek> I guess the idea is once rest is true (x==y) doesn't get evaluated anymore
11:30:05 <sdegutis> btw all you people who just started following -- you might not wanna, most of the stuff i tweet is probably just gonna really upset you (very catholic stuff)
11:30:13 <sdegutis> *started following me on twitter
11:31:12 <rasen1> Is CIS-194 2015 is better than 2013?
11:31:13 <tomphreek> ah ok got it, clever
11:31:29 <dfeuer> Oh wait, I see.... that's silly....
11:38:38 <sdegutis> I got used to Some/None from ML, so Just/Nothing still feels kinda weird
11:41:58 <doggggg> say you're like to construct a tuple from a list, it collects element i and j. How would you go about doing that with the helper function starting out as go 0 (,) list ? Clearly you would need to make a type class making it legal to put a tuple, x -> tuple and x -> y -> tuple in there but what would that look like?
11:42:28 <tel> OT, But does anyone know any good resources for tricks in building a stack in RISC? Or in particular LLVM.
11:43:09 <ahammel> So, my build gets to the same point every time and crashes with no error message
11:43:09 <monochrom> data Option a = None | Just a; type Maybe = Option
11:43:25 <ahammel> Unless I enable library stripping, in which case it complains about that at the same step and fails
11:43:26 <josephle> tel: if it's OT, ask it in #haskell-blah
11:43:36 <ahammel> yehaw
11:43:37 <tel> ah, always forget about that one
11:43:43 <josephle> tel: just so we don't distract from the ontopic #haskell discussion
11:45:14 <monochrom> I construct a tuple from a list this way: f (x:y:_) = Just (x,y); f _ = Nothing
11:46:13 <Iceland_jack> sdegutis: You can also do:
11:46:13 <Iceland_jack>     pattern None   = Nothing
11:46:13 <Iceland_jack>     pattern Some x = Just x
11:46:30 <Iceland_jack> enabling PatternSynonyms with GHC 7.8+
11:46:32 <sdegutis> Iceland_jack: i dunno what this "pattern" keyword is
11:46:36 <sdegutis> oh
11:46:56 <sdegutis> Iceland_jack: while that is cool, it seems worse because it makes my code non-idiomatic and confusing for others
11:47:20 <Iceland_jack> Yes, you know the option is there in any case :)
11:47:36 <Iceland_jack> It allows you to construct values:
11:47:37 <Iceland_jack>     ghci> Some 'a' :: Option Char
11:47:37 <Iceland_jack>     Just 'a'
11:47:37 <Iceland_jack>     
11:47:42 <monochrom> the option is there, indeed. option. :)
11:47:45 <Iceland_jack> ;)
11:47:56 * monochrom likes puns!
11:48:00 <Iceland_jack> As well as pattern matching on them:
11:48:00 <Iceland_jack>     foo None     = []
11:48:00 <Iceland_jack>     foo (Some x) = [x]
11:48:16 <Iceland_jack> Those were like punishment
11:48:17 * Iceland_jack exits
11:50:44 <sdegutis> I have a helper called userProfileLink which takes a User and creates a String based on a URL. But right now I have to import this function into every file where I want to use it. Is there any way around this?
11:53:31 <ahammel> oh, I'm running out of memory
11:53:39 <ahammel> https://github.com/haskell/cabal/issues/1522
11:53:45 <ahammel> well that was a fun three days
11:54:13 <sdegutis> ahammel: what's causing you to run out of memory?
11:55:35 <ahammel> not sure, possibly -j?
11:55:52 <ahammel> explains why it only happens on the build machine, anyway
11:56:12 <sdegutis> heh
12:01:15 * ahammel hates his life
12:06:49 <erikd> cmccann: the response i got was "Pretty recently, looks like just a bad IP." FFS!
12:06:58 <Tracy24>  Free Porn for Life!. Click Here! http://tny.de/patJ2
12:14:30 <sdegutis> Haskell has no 'apply' right?
12:15:07 <joelteon> what would that do
12:15:32 <Clint> file an application
12:15:41 <rasen1> Do you mean ap?
12:15:43 <rasen1> :t ap
12:15:44 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:15:49 <EvanR> do you mean $
12:15:51 <EvanR> :t ($)
12:15:52 <lambdabot> (a -> b) -> a -> b
12:15:54 <joelteon> do you mean id
12:16:08 <exio4> I think he wants a function like apply f [x,y,z] => f x y z
12:16:23 <sdegutis> Yes that.
12:16:33 <joelteon> sure; apply f [a,b,c] = f a b c
12:16:45 <sdegutis> For any number of elements?
12:16:50 <joelteon> sure, if the number is 3
12:16:56 <sdegutis> Oh duh of course this works, thanks to partial application.
12:17:21 <sdegutis> apply f (x:xs) = f x $ apply xs
12:17:27 <sdegutis> or something?
12:17:31 <exio4> try to get a type for that
12:17:36 <sdegutis> nevar!
12:17:45 <exio4> arity is a bit hairy in Haskell
12:18:02 <EvanR> HList apply
12:18:13 <geekosaur> and good luck coming up with an apply that works with Text.Printf.printf
12:18:25 <sdegutis> fwiw, i dont like apply
12:18:41 <geekosaur> (speaking of arity being hairy)
12:18:49 <EvanR> hairity
12:18:52 <geekosaur> that one shoots back
12:20:07 <chrisdotcode> If I was going to write a parser for binary file formats - what would I use? For text, I'd use parsec - but what's the binary/mixed content equivalent?
12:20:25 <rasen1> binary
12:20:30 <geekosaur> binary, maybe cereal
12:20:39 <geekosaur> some use attoparsec
12:21:15 <chrisdotcode> geekosaur, rasen1: what works best for mixed content?
12:21:23 <chrisdotcode> Or, rather, which one would you guys use if you had to?
12:21:56 <monochrom> any parser that takes bytestring input is a good parser for binary formats.
12:22:06 <Clint> attoparsec
12:22:26 <geekosaur> depends on what exactly I was trying to do. sometimes it would be easier to grab the binary parts as blobs in attoparsec and decode with binary, other times it might be easier to decode the binary stuff in attoparsec
12:22:33 <Ankhers> How would I go about installing haddocks for packages I get from hackage?
12:22:56 <geekosaur> of course, knowing when and how to use the available tools is another thing entirely...
12:28:38 <chrisdotcode> geekosaur: alright, so I'll start with attoparsec, and keep binary and cereal in mind. thanks :)
12:31:46 <erikd> @tell cmccann the response i got from reddit was "Pretty recently, looks like just a bad IP."
12:31:47 <lambdabot> Consider it noted.
12:40:09 <rasen1> Seems that cereal is more full-featured than binary
12:48:45 <glguy> The latest binary version should be about to do just about everything cereal could. What were you missing?
12:49:44 <koomi> Ankhers: put "documentation: True" in your .cabal/config
12:50:57 <rasen1> I don't miss anything. I was just curious what cereal is and took a short look
12:55:32 <bananagram> @let apply f (x:xs) = apply (f x) xs
12:55:34 <lambdabot>  .L.hs:172:27:
12:55:34 <lambdabot>      Occurs check: cannot construct the infinite type: t2 ~ t1 -> t2
12:55:34 <lambdabot>      Relevant bindings include
12:57:52 <Geraldus> hi friends!
12:57:56 <Geraldus> I've just updated to OS X 10.2.2 my dev laptop, and after reboot I've missed yesod-bin.
12:58:01 <Geraldus> Now when I try to install it I have following error: Loading package conduit-extra-1.1.6.2 ... linking ... done.
12:58:01 <Geraldus> Loading package project-template-0.1.4.2 ... <command line>: can't load .so/.DLL for: libHSproject-template-0.1.4.2.dylib (dlopen(libHSproject-template-0.1.4.2.dylib, 9): image not found)
12:58:15 <Geraldus> This is strange, because project-template itself installed (and easily could be reinstalled without any breakages)
12:58:23 <Geraldus> How can I resolve this issue?
13:12:41 <rasen1> Geraldus: Not the best way, but try force-reinstall everything
13:13:19 <Geraldus> rasen1: it's not big deal to me to remove ~/.ghc entirely
13:13:40 <Geraldus> actually, this was my solution #999 :D
13:14:39 <Geraldus> so... I suppose there no other options. Let me check few google links more
13:14:41 <rasen1> It's probably the fastest way because it saves time finding the reason
13:15:04 <EvanR> greatest strategy ever
13:15:36 <monochrom> Geraldus: it is because of http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#shared
13:16:36 <mmachenry> I have a list of 32 dependencies for my cabal project which is split up into a library and an executable. Mostly just for testing. Is there a way to avoid duplicating the 32 deps listed out twice in my cabal file?
13:17:10 <Geraldus> monochrom: Thank you a lot, actually, `cabal --version` shows me 1.16, but recently I had 1.22
13:17:11 <rasen1> Does application really uses these libraries?
13:17:19 <Geraldus> so I need to upgrade cabal first
13:18:22 <rasen1> mmachenry: Probably, application should depend only on the library and on couple more it imports explicitly
13:18:24 <monochrom> no, you need an orchestrated, synchronized world upgrade, not a lot of piecemeal individual upgrades.
13:19:25 <mmachenry> rasen1: No it only uses the library.
13:19:33 <mmachenry> So I should try that.
13:19:35 <monochrom> indeed, as shown, upgrading cabal is part of the problem, not part of the solution.
13:25:30 <Guest35918> Anyone feel like answering a newbie question?
13:25:41 <benzrf> Guest35918: sure
13:25:51 <awestroke> Guest35918: probably many, go ahead and ask the question directly
13:27:00 <meretrix> How can I write a function (match :: X -> X -> Bool) that uses pattern matching to return whether the two data constructors are the same?
13:27:09 <meretrix> without writing an Eq instance
13:27:33 <Guest35918> I'm trying to install a package in a cabal sandbox. I installed the package but when I try to run a script that imports the package or try to import it from ghci, it seems that the packages is not found. Is there a way to tell ghc where to look for packages?
13:27:55 <geekosaur> for ghci, you want cabal repl
13:27:55 <clrnd> Guest35918, did you include it in your project's cabal file
13:27:59 <clrnd> ?
13:28:16 <rasen1> I'm developing a BitTorrent library. There are HTTP and UDP trackers and I want to put their implementations in separate modules and add one more module as a facade to them. However, these two modules share representation of peer (which is just record with no associated functions/instances or something interesting). The only way to actually share it is to create fourth module with this single record, right?
13:28:21 <awestroke> meretrix: you can derive Eq
13:28:21 <clrnd> malllle, let f X X = True ?
13:28:29 <geekosaur> if "a script" is something you feed to runghc, try cabal exec runghc ...
13:28:36 <bramgg> Is it possible for System.Process's "readProcess" to always return the result of a command, even if it results in an error? (In that case I'd just like the error message returned as a String like anything else).
13:28:47 <Guest35918> I did try cabal repl as well and got the same message. I did not try to add it to a cabal file.
13:28:49 <EvanR> rasen1: thats a good way
13:29:13 <EvanR> put shared stuff in its own module
13:29:25 <levi> You can always 'cabal exec sh' and then your shell environment will have all the sandboxy goodness.
13:29:29 <rasen1> I there other ways? I don't like having module with 5 lines
13:29:36 <meretrix> awestroke: Yeah, I know but is it possible without doing that?
13:29:56 <EvanR> rasen1: copy the 5 lines into each module?
13:30:04 <rasen1> Ideally, I'd like to put shared data in facade module, but can't because of circular dependencies
13:30:11 <EvanR> yeah dont do that
13:30:24 <awestroke> bramgg: you can implement it yourself using sibling functions in System.Process
13:30:45 <EvanR> practically, some projects put all their bare types into one "5 line module"
13:30:46 <clrnd> meretrix, can't you just let f A A = True; f A B = False ?
13:30:53 <meretrix> Guest35918: you can also use someting like ghci -package-db=/path/to/sandbox/x86_64-linux-ghc-7.8.3-packages.conf.d/
13:31:09 <awestroke> clrnd: I think meretrix want's a fully general function
13:31:11 <meretrix> clrnd: Yes, but I want to make it configurable.
13:31:32 <EvanR> rasen1: you can also put things wherever you want, and use an hs-boot file
13:31:52 <rasen1> EvanR: What's it?
13:31:58 <EvanR> it lets you have circular dependencies
13:32:23 <bramgg> awestroke: thanks, do you know which functions I should use offhand?
13:32:28 <EvanR> having your modules be acyclic is a lot better though
13:34:09 <awestroke> bramgg: readProcessWithExitCode
13:35:02 <bramgg> awestroke: cheers
13:35:03 <Hijiri> meretrix: isn't your match basically just derived Eq?
13:35:30 <EvanR> Hijiri: sounds like homework
13:36:16 <rasen1> EvanR: .hs-boot is a kind of creating 5-line module, but later compile it together with corresponding module in single binary?
13:36:31 <Hijiri> oh, I guess X is a specific type?
13:36:36 <rasen1> EvanR: then, I like separate module better
13:36:37 <Hijiri> I thought it was just some arbitrary type
13:37:45 <Guest35918> OK, cabal exec worked. Now, what if I would like to run this script outside of my sandbox and without using cabal exec but just calling the script directly? Is there an easy way to do this? For example, I would like to put the file in my $HOME/bin dir and just call if using the script name.
13:38:11 <EvanR> rasen1: if you look at hackage youll see often a Types.hs which is basically just where they put all these shared types together
13:38:57 <monochrom> "cabal build", then dive deep into the "dist" directory, find the exe, copy it out.
13:39:20 <geekosaur> Guest35918, see what meretrix said to you (need a script wrapper probably), otherwise no. the point of sandboxes is they're confined to the sandbox, so you need to enter the sandbox to use it
13:39:40 <geekosaur> or compile it normally as monochrom suggested instead of runghc
13:40:49 <awestroke> meretrix: I think you could use templatehaskell to generate such a function
13:40:58 <meretrix> Hijiri: It is.  I don't want to derive Eq though because I only need this function for testing.
13:41:07 <meretrix> That's true.
13:44:50 <meretrix> Guest35918: Probably something like: ghc -package-db=/sandbox/dir -e 'haskell code'
13:44:55 <juanpablo___> meretrix: Standalone deriving? :)
13:46:23 <ochieY8u> hunter2
13:46:42 <EvanR> why did you type *******
13:46:49 <ochieY8u> :))
13:48:10 <meretrix> juanpablo___: Cool! Didn't know about that.
13:52:31 <athan> Hey guys, I may have something worthy of a publication, but am a noob at writing papers so I'm doing a blog post first. Should I be worried about theft? It's pretty good...
13:53:59 <monochrom> that is an XY problem. it is not theft, per se, that you should prevent. it is undeterred, untold, unknown theft that you should prevent.
13:54:42 <monochrom> namely, if you keep an article secret, and someone steals it, then you can do nothing, that's undeterred, unknown theft, and people will do it.
13:55:12 <athan> :) thank you monochrom
13:55:23 <athan> monochrom: Would you suggest I just throw the blog post out there?
13:55:30 <athan> Cause it's just too crazy to keep secret :)
13:55:41 <monochrom> but if you keep an article on a public blog, in fact go out of your way to make sure that everyone knows it, then when someone dares steal it, people will know, and that's how the thief is deterred.
13:55:53 <athan> :D
13:55:55 <athan> poifect
13:56:08 <monochrom> make an announcement of reddit
13:56:09 <athan> monochrom: It's a... (new?) different lambda calculus
13:56:14 <athan> It will be done!!
13:56:18 <monochrom> err, announcement on reddit
13:56:42 <EvanR> all new lambda calculus
13:57:09 <athan> Next to the milk isle
13:57:19 <johnw> tomphreek: it probably should have been rest || x == y
13:57:34 <johnw> oh wait, no
13:57:48 <johnw> it was right before
13:58:04 <johnw> once x==y is true, it stops the fold immediately with that result
13:58:10 <johnw> because rest is not evaluated
14:05:54 <Guest35918> So, I tried running cabal build from the sandbox but the dependencies (which were packages that were installed in the sandbox) were not found.
14:06:37 <kadoban> Guest35918: What exact error did you get? Do you have the dependencies recorded in the .cabal file?
14:07:22 <Guest35918> Here is the  error: cabal: At least the following dependencies are missing:                        ‚îÇcabal.config         cabal.sandbox.config m2d.hs
14:07:23 <Guest35918> Turtle -any
14:07:50 <Susie24>  High Quality photos and videos http://bit.ly/1y2SGSo
14:07:52 <Guest35918> I did include the dependencies in the .cabal file.
14:08:57 <rasen1> Guest35918: cabal install --dependencies-only
14:13:14 <monochrom> hahaha, augustss's message content is 10 times shorter than Standard Charter Bank's mandatory disclaimer
14:13:38 <Guest35918> cabal install --dependencies-only still fails to find the package.
14:14:28 <rasen1> Guest35918: package's name is turtle, not Turtle
14:20:04 <Guest35918> rasen1, thank you for catching that! I feel dumb now. :-/
14:33:39 <rasen1> Can I keep instances local to module?
14:36:04 <edwardk> rasen1: no
14:36:25 <edwardk> rasen1: turns out it actually isn't sound to be able to, you break a global property of instance resolution that way
14:38:20 <cmccann> new proposal: instance-local instances. the instance is only visible from within its own definition.
14:40:37 <mauke> prior art: C, types defined in the parameter list of a function declaration
14:41:18 <cmccann> truly C was a language ahead of its time
14:42:46 <sdegutis> So I heard today that IO monads are maybe not the best thing sometimes?
14:42:54 <sdegutis> I don't get it.
14:43:08 <rasen1> mauke: always wondered if there is useful application
14:43:12 <mauke> IO monads? I thought there was only one of them
14:43:17 <sdegutis> I mean using it.
14:43:51 <rasen1> sdegutis: for some purposes there are more specialized tools
14:43:58 <geekosaur> I think that is referring to the fact that there is little point in using the monadic interface when the applicative one is sufficient
14:44:04 <Tesseraction> work in a closed system, no input/output allowed, problem solved
14:44:13 <sdegutis> I forgot where I heard it, it was a few hours ago.
14:45:21 <sdegutis> Some article or blog or something said that the Haskell community figured out how to use the IO monad, but then later they realized sometimes [insert fancy sounding thing here] was often a better choice because lazy IO is often a bad idea.
14:45:23 <geekosaur> Monad is very powerful but sometimes you don't need that level of power; Applicative is lighter weight and sufficient for many (not all) uses
14:46:03 <geekosaur> oh. that doesn't argue against the IO Monad, it argues against the fact that the default IO interface is lazy and simple lazy I/O has some shortcomings
14:46:06 <monochrom> I think it's best to find the verbatim text and ask its author.
14:46:17 <tomphreek> johnw: so foldr (applied to [1..]) expands to f 1 $ f 2 $ f 3 ... f n $ foldr r False [n+1..]; does haskell then reduces it to (1==y) || (2==y) || (3==y) || (4==y) || ...?
14:46:28 <geekosaur> you still need the IO Monad to use other interfaces
14:46:53 <geekosaur> it's just that the default lazy IO interfaces put convenience over correctness in some cases
14:46:59 <monochrom> random hearsay is bad enough. random hearsay and asking random strangers is a whole new level.
14:47:47 <Sonarpulse> Is there any Type lambda these days?
14:48:08 <sdegutis> Found it -- http://www.reddit.com/r/haskell/comments/14nj0r/what_doesnt_haskell_do_well/c7epzfs
14:48:59 <monochrom> oh great, the author is not the original author either, just passing around more hearsay.
14:49:28 <sdegutis> "iteratee I/O and conduits"
14:50:46 <monochrom> this is a good time to recall the game of chain of people, where the ith person is to passing on a message to the i+1st person. the result is always that the nth person passes out a completely unrelated message to what the 1st person passes in.
14:51:07 <rasen1> I found the way to make module-local instance. Just wrap data in newtype
14:51:25 <fread2282> what's the Alternative guard called?
14:52:44 <sdegutis> Is it possible to tie a function to some value that your function receives so that you can call that function with its pre-applied argument without having to import the module where that function is defined?
14:53:06 <sdegutis> Ignore the "with its pre-applied argument" part.
14:53:15 <hjlkjkl> http://pastebin.com/UzD0VZEL
14:53:24 <hjlkjkl> can someone explain this error to me?
14:53:40 <rasen1> fread2282: I believe, there is no.
14:54:25 <rasen1> :t (^)
14:54:26 <lambdabot> (Num a, Integral b) => a -> b -> a
14:54:29 <mauke> hjlkjkl: what type is frequencies supposed to have?
14:54:39 <hjlkjkl> array of integer
14:54:43 <hjlkjkl> list
14:54:45 <hjlkjkl> sry
14:54:53 <athan> Is there anything in-between simply-typed lambda calculus and untyped?
14:55:05 <McManiaC> is  there a more efficient way to do something like (x^n `mod` y) where n is very big?
14:55:05 <benzrf> athan: very-simply-typed
14:55:12 <hjlkjkl> frequencies = [80, 5, 71, 2, 7, 33]
14:55:13 <athan> ?
14:55:15 <fread2282> is there a bool eliminator in base (Bool -> a -> a -> a)?
14:55:23 <mauke> hjlkjkl: then you need fromIntegral (sum frequencies) / fromIntegral (product frequencies)
14:55:23 <hpc> :t if'
14:55:24 <lambdabot>     Not in scope: ‚Äòif'‚Äô
14:55:24 <lambdabot>     Perhaps you meant ‚Äòf'‚Äô (imported from Debug.SimpleReflect)
14:55:32 <athan> benzrf: pshaw
14:55:34 <mauke> hjlkjkl: / doesn't work on integers
14:55:36 <benzrf> @google modulo of power
14:55:37 <lambdabot> http://en.wikipedia.org/wiki/Modular_exponentiation
14:55:37 <lambdabot> Title: Modular exponentiation - Wikipedia, the free encyclopedia
14:55:38 <hpc> fread2282: if' is usually that thing
14:55:40 <hjlkjkl> ah
14:55:44 <hjlkjkl> thank you mauke
14:55:44 <benzrf> hmmmmmmmmmmm
14:55:48 <hpc> fread2282: or (??) :: a -> a -> Bool -> a
14:55:53 <hjlkjkl> btw: why the hell not?
14:56:00 <chrisdotcode> How does one convert from Word8 to an Int? toInteger converts to integer, but I need an int, because I want to convert said into into an enum of a different type.
14:56:09 <hpc> chrisdotcode: fromIntegral
14:56:12 <rasen1> hjlkjkl: there is div for that
14:56:22 <hpc> chrisdotcode: or to/fromEnum
14:56:32 <hjlkjkl> ok i'll try that rasen1
14:56:41 <chrisdotcode> hpc: I'll try that, thank you
14:57:07 <chrisdotcode> hpc: it works, thanks :)
14:57:56 <sdegutis> Is it possible somehow receive function A as a parameter to function B so that you can call A from B without needing to import the module where A is defined?
14:58:19 <monochrom> yes
14:58:47 <sdegutis> Hmm, I'll still need to import the types of the arguments it takes though.
14:58:49 <sdegutis> Dang.
14:59:00 <sdegutis> Or is there a way around that?
14:59:30 <monochrom> I don't understand.
14:59:34 <rasen1> If it's possible, make function polymorphic
14:59:39 <sdegutis> I'm just trying to avoid importing a ton of what would be "helper methods" in another language.
14:59:59 <rasen1> import Module (Type1)
15:00:19 <sdegutis> I have a User type and a lot of helper functions for letting me present this User in some HTML.
15:00:33 <hjlkjkl> tried it with div but still getting similar error rasen1 mauke:http://pastebin.com/WLT0UTUN
15:00:35 <athan> I hear some people calling `foo x = bar x` ~ `foo = bar` "currying", but that's not right. Is there another word for this?
15:00:35 <EvanR> if youre trying to use a type, you have to import it
15:00:45 <athan> Or really, the word for what enables it?
15:00:45 <sdegutis> Right now I have to do `import UserHelpers(..)` everywhere I want to use them.
15:00:49 <sdegutis> I'm seeing if I can avoid this.
15:01:02 <mauke> hjlkjkl: put a type signature on frequencies
15:01:06 <EvanR> you have to import stuff you use
15:01:07 <mauke> hjlkjkl: something's forcing it to Double
15:01:11 <athan> (ie: if a system provided `x`, then you can simplify `foo x = bar x` to `foo = bar`)
15:01:15 <sdegutis> EvanR: fair enough
15:01:25 <tomphreek> johnw: oh just noticed your further commments. yeah, that's what I thought.
15:01:26 <EvanR> (except Prelude)
15:01:26 <rasen1> rasen1: import UserHelpers (User) is fine?
15:01:49 <monochrom> athan: it's eta reduction. or related to. eta reduction refers to "(\x -> f x) = f". so what happens here, you first consider "foo x = bar x" to be "foo = (\x -> bar x)", then eta.
15:02:04 <moghedrin> Alright, oh knowledgeable ones. Anybody have something slick for the type `(a -> a -> f a) -> f a -> f a -> f a`?
15:02:14 <athan> Derp!
15:02:16 <athan> sorry monochrom
15:02:21 <sdegutis> rasen1: no, I'll need to be able to call the user helper functions too
15:02:23 <EvanR> :t liftA2
15:02:24 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
15:02:47 <EvanR> hmm
15:03:02 <rasen1> sdegutis: then... import them
15:03:04 <sdegutis> ok thanks
15:03:23 <jle`> meretrix: do notation probably is the best way to do that
15:03:23 <hjlkjkl> frequencies :: [Double] << tried this mauke but it doesn't solve the problem
15:03:33 <EvanR> moghedrin: what is that supposed to do
15:03:41 <mauke> hjlkjkl: dude, you said it was integers
15:03:47 <athan> :t let f = undefined :: CoMonad f => a -> a -> f a in \x y -> x (extract y) f
15:03:48 <athan> ?
15:03:49 <lambdabot>     Not in scope: type constructor or class ‚ÄòCoMonad‚Äô
15:03:49 <lambdabot>     Perhaps you meant ‚ÄòMonad‚Äô (imported from Control.Monad.Writer)
15:03:49 <lambdabot> Not in scope: ‚Äòextract‚Äô
15:03:57 <mauke> hjlkjkl: why are you making it Doubles now?
15:04:10 <jle`> meretrix: you can liftA2 and join, but that combination is kind of esoteric enough that it might not really be worth giving a name to
15:04:18 <hjlkjkl> ah sorry misread your proposal
15:04:23 <jle`> meretrix: i like to think of this as a case that do notation was designed to help for :)
15:04:30 <mauke> hjlkjkl: and the one before that
15:04:36 <mauke> I never mentioned div
15:04:45 <moghedrin> EvanR: Basically grab two "random" strings and feed them through a "random" crossover function.
15:05:00 <jle`> oh that was meant for moghedrin , not meretrix
15:05:03 <jle`> sorry
15:05:07 <jle`> moghedrin: see my messages above :)
15:05:14 <rasen1> :t (**)
15:05:15 <lambdabot> Floating a => a -> a -> a
15:05:19 <moghedrin> jle`: do notation - poo ;P
15:05:30 <monochrom> "(a -> a -> f a) -> f a -> f a -> f a" seems like some kind of >>= for more parameters
15:05:33 <EvanR> ok, liftA followed by join ;)
15:06:05 <jle`> liftA2 & join works...like i said it's rare/speciic enough that it's probably not worth given its own name to
15:06:13 <rasen1> hjlkjkl: You could use ** instead of ^
15:06:19 <jle`> but honestly this is one of those cases where do notaton shines :)
15:06:24 <jle`> if you use http://hackage.haskell.org/package/monad-extras-0.5.9/docs/Control-Monad-Extra.html
15:06:56 <jle`> then your function is \f x -> nom f (return x) ;)
15:07:04 <jle`> \f -> nom f . return
15:07:09 <jle`> don't do that though :)
15:07:30 <hjlkjkl> i'll try it rasen1
15:07:36 <EvanR> :t nom
15:07:37 <lambdabot>     Not in scope: ‚Äònom‚Äô
15:07:38 <lambdabot>     Perhaps you meant one of these:
15:07:38 <lambdabot>       ‚Äònot‚Äô (imported from Data.Bool), ‚Äònon‚Äô (imported from Control.Lens)
15:07:48 <jle`> nom :: Monad m => (a -> b -> m c) -> a -> m b -> m c
15:07:56 <monochrom> that is, like, rare and near-extinction stuff
15:08:00 <moghedrin> Lolol `om` and `nom`. How great.
15:08:14 <moghedrin> I guess I'll go with do notation.
15:08:22 <monochrom> some libraries are meant to be endangered species.
15:09:43 <bananagram> @hoogle nom
15:09:43 <lambdabot> Language.Haskell.TH.Lib nominalR :: Role
15:09:44 <lambdabot> Language.Haskell.TH nominalR :: Role
15:09:44 <lambdabot> Control.Exception.Base noMethodBindingError :: Addr# -> a
15:09:51 <jle`> @hackage monad-extras
15:09:52 <lambdabot> http://hackage.haskell.org/package/monad-extras
15:10:20 <monochrom> you know, @hackage is kind of the id function. consider @hackage halting-solver
15:10:42 <exio4> @hackage php7
15:10:42 <lambdabot> http://hackage.haskell.org/package/php7
15:10:44 <jle`>  @hackage is ("http://hackage.haskell.org/package/"++)
15:10:57 <jle`> @. hackage hackage hello
15:10:57 <lambdabot> http://hackage.haskell.org/package/http://hackage.haskell.org/package/hello
15:11:26 <Craig123> does anyone have an example of   orP    ?
15:11:55 <hpc> @hackage acme-php -- exio4
15:11:55 <lambdabot> http://hackage.haskell.org/package/acme-php -- exio4
15:12:29 <exio4> hpc: Haskell2016's prelude
15:13:42 <hpc> if someone made a turbo haskell package, i would be so happy
15:13:56 <jle`> 7.12's prelude will have no monomorphic functions at all
15:14:43 <jle`> repeat :: Alternative f => a -> f a
15:14:59 <jle`> putStrLn :: IsString s => s -> IO ()
15:15:51 <exio4> (MonadIO m, IsString s, IsUnit u) => s -> m u
15:16:00 <jle`> (==) :: (Eq a, Boolean b) => a -> a -> b
15:16:04 <jle`> ah yes of course exio4
15:16:51 <jle`> snd :: Bifunctor f => f a b -> b
15:17:12 <hjlkjkl> rasen1: error is gone with ** thank you. how can i ask lambdabot to show me the code?
15:17:14 <jle`> unzip :: Traversable f => f (a, b) -> (f a, f b)
15:17:46 <jle`> ok i'm done this wasn't as fun as i thought it would be because most of prelude's functions are already polymorphic
15:24:56 <xenocons_> [ ("a",[1,2,3]), ("b",[4,5,6]) ...] where a and b are categories (in a linguistic sense), how could i group them so that -> [[ ("a",1),("b",4")],[ ("a",2), ("b",5)] , ... ] for an arbitrary number of categories? (i am not using haskell just wondering what the haskell solution is)
15:25:44 <jle`> that sounds like a fold/zip
15:26:26 <Tesseraction> with a map, right?
15:26:41 <xenocons_> hmmm yeah i was thinking folding over it annd zipping using an accumulator does make sense, but i couldnt actually realise my answer
15:26:44 <jle`> and a snap crackle pop
15:26:55 <Tesseraction> oh, I guess you could avoid a map
15:27:46 <exio4> tranpose . map (\(a,xs) -> map (a,) xs) -- something like this?
15:28:00 <rasen1> hjlkjkl: code of what?
15:28:04 <xenocons_> :t transpose
15:28:05 <lambdabot> [[a]] -> [[a]]
15:28:06 <exio4> @type tranpose . map (\(a,xs) -> map (a,) xs)
15:28:07 <lambdabot>     Not in scope: ‚Äòtranpose‚Äô
15:28:08 <lambdabot>     Perhaps you meant one of these:
15:28:08 <lambdabot>       ‚ÄòBSC.transpose‚Äô (imported from Data.ByteString.Char8),
15:28:13 <exio4> @type transpose . map (\(a,xs) -> map (a,) xs)
15:28:15 <lambdabot> [(t, [a])] -> [[(t, a)]]
15:28:16 <hjlkjkl> rasen1: code of **
15:28:25 <rasen1> @src (**) -- I guess it'll fail
15:28:25 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:28:28 <xenocons_> ok so transpose being a matrix like operation over a 2d list or something
15:28:44 <rasen1> It's built-in
15:28:50 <hjlkjkl> ok
15:28:51 <glguy> > (transpose . map sequenceA) [ ("a",[1,2,3]), ("b",[4,5,6]) ]
15:28:52 <lambdabot>  Not in scope: ‚ÄòsequenceA‚Äô
15:28:52 <lambdabot>  Perhaps you meant one of these:
15:28:52 <lambdabot>    ‚ÄòT.sequenceA‚Äô (imported from Data.Traversable),
15:28:57 <glguy> > (transpose . map T.sequenceA) [ ("a",[1,2,3]), ("b",[4,5,6]) ]
15:28:58 <lambdabot>  [[("a",1),("b",4)],[("a",2),("b",5)],[("a",3),("b",6)]]
15:29:13 <xenocons_> aha!
15:29:21 <xenocons_> whats the T.SequenceA ?
15:29:33 <benzrf> xenocons_: sequenceA from Data.Traversable
15:29:38 <xenocons_> ahh ok hmm
15:29:40 <benzrf> xenocons_: lambdabot has it imported qualified
15:29:44 <dmwit> Is there a way to ask cabal what value it has for a certain setting? Like, "cabal echo '$haddockdir'" or something?
15:29:58 <xenocons_> i see, most interesting
15:30:17 <xenocons_> bloody haskell is too elegant for its own good :)
15:30:44 <xenocons_> going to inspect Data.Traversable source
15:31:07 <glguy> dmwit: If you figure it out please tell me so that my GhcPkgUtils won't have to manually parse the config file
15:31:18 <dmwit> ...oh =(
15:33:00 <glguy> dmwit: (I'm not saying it's impossible, just that I'd be interested)
15:33:25 <dmwit> Understood. It's just if somebody has looked for this feature and not found it that reduces my confidence that it exists.
15:34:11 <benzrf> xenocons_: it's a typeclass
15:34:15 <benzrf> xenocons_: er, Traversable is
15:34:26 <benzrf> xenocons_: types that implement Traversable support sequenceA
15:34:28 <benzrf> :t T.sequenceA
15:34:29 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
15:34:47 <benzrf> xenocons_: basically if t is Traversable, you can turn a t of applicative values into an applicative of a t
15:34:54 <xenocons_> right
15:34:58 <benzrf> xenocons_: the prototypical example is list
15:35:08 <benzrf> but (,) a and Maybe also fit the bill
15:36:06 <benzrf> xenocons_: the basic idea is that you can decompose the structure and then liftA* each constructor back over its contents
15:36:35 <xenocons_> hmm
15:36:39 <benzrf> so you end up with all of the values in it sequenced end to end and then their results stuffed back into the original shape
15:36:44 <athan> monochrom: I feel weird saying "_I_ present the following idea...". Should I use "we", instead? Just to sound like a paper?
15:37:09 <dmwit> athan: Buck the trend. Say "You present the following idea...".
15:37:18 <athan> :)
15:37:20 <athan> sweet
15:37:27 <cmccann> second-person is totes underrated.
15:37:33 <xenocons_> benzrf: it makes sense i think
15:37:34 <cmccann> there should be more novels written in second-person.
15:39:45 <cmccann> athan: the benefit of using second person is that after a tricky bit you can say something like "you find this highly intuitive and understand completely" and the reader can't argue back
15:39:59 <athan> LOL
15:40:21 <athan> cmccann: but "we" isn't 3rd person :\
15:40:35 <athan> erm
15:40:36 <monochrom> athan: it's just a blog, "I" is good enough
15:40:44 <athan> coo :]
15:40:58 <monochrom> self-adventure stories use "you" all the time
15:41:05 <cmccann> athan: people refer to themselves in the third person all the time in some kinds of writing though
15:41:13 <athan> alright guys, cheq it: http://deconfigured.com/blog/atlc - monochrom, dmwit, benzrf, cmccann (?)
15:41:26 <athan> hmm
15:42:04 <cmccann> monochrom: also, interactive fiction and other stuff in the old text adventure game flavor
15:42:09 <cmccann> unless that's what you meant
15:42:45 <monochrom> yeah
15:44:05 <athan> there are probably so many spelling errors...
15:44:06 <athan> crap
15:44:20 <dicioccio1> playing with type operators, I'd like to build something like a+b+c to be "associative", or find a trick for (a+b)+c to be turned into a+(b+c))
15:50:48 <athan> I'm guessing no responses is a good sign? :D
15:50:59 <Hijiri> second person is like hypnosis?
15:51:30 <Hijiri> I guess hypnosis is a subset of second person
15:51:33 <cmccann> athan: it sounds interesting and I didn't notice any obvious mistakes :P
15:51:47 <athan> :) thanks cmccann
15:51:56 <amalloy> "you are really enjoying this book. you want to buy a hundred copies"?
15:52:05 <athan> ltext will be a general-purpose file compiler - basically turning files into higher order functions
15:52:11 <athan> lol
15:55:04 <EvanR> athan: did you publish your findings yet
15:55:21 <athan> EvanR: Dun 'blished: http://deconfigured.com/blog/atlc
15:55:28 <EvanR> blished
15:55:39 <athan> sorry - 'blish'd*
15:55:44 <EvanR> nice blag
15:55:50 <athan> ty :)
15:55:55 <athan> gonna make verbpress soon
15:56:00 <athan> super simple getting this running
16:04:52 <EvanR> athan: how did you make this image http://deconfigured.com/images/application.png ?
16:05:05 <athan> just inkscape :P
16:08:03 <Rachael24>  There is no such thing as Free Porn http://s0o.de/f4t4dss
16:08:26 --- mode: ChanServ set +o glguy
16:08:31 --- mode: glguy set +b *!*@79.141.163.10
16:08:34 --- kick: Rachael24 was kicked by glguy (Your behavior is not conducive to the desired environment.)
16:08:46 --- mode: glguy set -o glguy
16:08:53 <hiptobecubic> Seriously. No need to fill everyone's head with lies.
16:09:06 <MP2E> lol
16:15:26 <rcat> how can I load in GHCi as interpreted code a library used in my project?
16:15:51 <rcat> I was looking at add-source, but I still don't know how to load interpreted modules outside of my cabal project
16:17:44 * hackagebot processor-creative-kit 0.1.0.1 - a creation kit for instruction sets and cpu simulators and development tools  http://hackage.haskell.org/package/processor-creative-kit-0.1.0.1 (takenobut)
16:19:20 <hexagoxel> rcat: `ghc -i` ?
16:20:16 <hexagoxel> and i would guess that add-source indeed will not do interpreted
16:21:01 <rcat> not sure about that -i flag
16:21:58 <hexagoxel> what have you tried? what are the directories? do you use sandboxes?
16:22:19 <rasen1> Is there a pragma for records namespaces?
16:23:22 <rcat> hexagoxel: I'm working in a sandbox with my project, in there I did `cabal get aux-lib-Im-using'
16:23:50 --- mode: ChanServ set +o glguy
16:23:54 <rcat> hexagoxel: so, from ghci I'm able to load my project's code, but I can't get to load code from that `aux-lib'
16:23:54 --- mode: glguy set -bo *!*@79.141.163.10 glguy
16:24:27 <rcat> hexagoxel: just playing with :import, :load, :set to see if I can get to load as interpreted code that library outside of my project
16:25:54 <hexagoxel> rcat: just to clarify: it is important that the aux-lib is interpreted?
16:27:05 <rcat> hexagoxel: I want to debug that library, so, I'd like to load it under ghci
16:27:38 <rcat> hexagoxel: right now, I'm treating that code as a black-box but I need to track why an excepcion is happening
16:28:13 <adam_shimi> Hi everyone
16:28:14 <rcat> I'm compiling my libs with profile info, but I need to start looking deeper, so I guess I need to use interpreted code under ghci, right?
16:28:20 <benzrf> hi adam_shimi
16:30:00 <based> http://rap.hah.pw/notebooks/rapbot.ipynb
16:30:39 <benzrf> thank u based
16:30:49 <based> click play
16:30:57 <based> with amourt of bars
16:31:11 <based> freestyle(4)
16:31:48 <benzrf> this is a haskell channel
16:32:13 <hexagoxel> rcat: something like `cabal exec -- ghci -i. -idist/build/autogen -iaux-lib` might work. depends on what your src directory is, for both projects, i guess.
16:32:19 <based> python is cool as haskeell\
16:32:28 <jle`> benzrf: i see what you did there
16:32:36 <based> http://rap.hah.pw/notebooks/rapbot.ipynb#
16:32:41 <based> check out mu long rap
16:32:57 <benzrf> jle`: :-)
16:33:07 <adam_shimi> Does someone has a nice explanation of the reactimate function in Yampa?
16:33:18 <shachaf> based: Does this have to do with Haskell?
16:33:23 <adam_shimi> Because I'm a little lost here...
16:33:35 <jle`> adam_shimi: heh.  what is the type?
16:33:42 <jle`> adam_shimi: let me see if i can dust off my yampa knowledge
16:33:59 <based> http://gibiansky.github.io/IHaskell/demo.html
16:34:03 <benzrf>           
16:34:16 <jle`> fwiw yampa is somewhat of an old library...there are more modern alternatives available these days :)
16:34:38 <based> notebook is amzing
16:34:42 <adam_shimi> jle`: What for example?
16:34:58 <jle`> what do you mean?
16:34:59 <adam_shimi> I mostly want to do FRP, not necessarly use Yampa.
16:35:06 <jle`> what example?
16:35:13 <adam_shimi> What are the modern alternatives
16:35:16 <jle`> ah
16:35:22 <hexagoxel> rcat: otherwise there always is trace-debugging :p
16:35:25 <jle`> oh i totally misread that as "for what example"
16:35:30 <adam_shimi> ^^
16:35:38 <jle`> well the direct descendent of yampa is netwire
16:35:55 <jle`> but other modern approaches to FRP are the push/pull FRP style with sodium and reactive-banana
16:36:00 <jle`> it depends on your specific domain
16:36:39 <adam_shimi> You mean what I want to use it for?
16:36:49 <jle`> yeah
16:37:08 <jle`> it turns out that FRP is just a general way of rephrasing the problems and looking at a domain in a different way
16:37:16 <jle`> different implementations of it excell in different areas
16:37:28 <rcat> hexagoxel: :'-< yeah, Haskell debugging is something that is still painful
16:37:39 <exio4> that's why we want dependant types!
16:37:42 <benzrf> :t (:'-<)
16:37:44 <lambdabot> parse error on input ‚Äò-<‚Äô
16:37:45 <adam_shimi> Mostly I want to use FRP to make a game.
16:37:46 <benzrf> :t (:-<)
16:37:47 <lambdabot>     Not in scope: data constructor ‚Äò:-<‚Äô
16:37:48 <lambdabot>     Perhaps you meant ‚ÄòSeq.:<‚Äô (imported from Data.Sequence)
16:37:50 <benzrf> it's valid!
16:38:13 <jle`> adam_shimi: what kind of games?
16:38:20 <rcat> benzrf: LOL
16:38:45 <EvanR>  :t (:)-\-<)
16:38:47 <EvanR>  :t (:)-|-<)
16:38:49 <EvanR>  :t (:)-/-<)
16:39:37 <adam_shimi> Shoot them up
16:39:45 <tomphreek> why is Haskell painful to debug?
16:40:01 <hexagoxel> rcat: but it seems possible to get it to work, with some effort :)
16:40:12 <jle`> adam_shimi: then netwire is probably the best way for now.  but much of what you learn in yampa can be directly translated
16:40:53 <monochrom> is Haskell painful to debug? not to me.
16:41:01 <monochrom> why do people ask loaded questions?
16:41:22 <jle`> i don't really find haskell that painful to debug
16:41:28 <osa1> I have a `ByteString -> X` function, can I lift it to a Pipe ByteString X ?
16:41:30 <tomphreek> monochrom: according to rcat
16:41:34 <adam_shimi> jle`: so Yampa is more powerfull than netwire?
16:41:51 <osa1> basically I want to wire my ByteString -> X function to my producer with type IO ByteString
16:41:56 <jle`> adam_shimi: concepts you learn in yampa will help you learn netwire
16:42:03 <jle`> adam_shimi: but i don't think you can really compare "power"
16:42:21 <benzrf> :t (:>-\-<)
16:42:22 <lambdabot> Not in scope: data constructor ‚Äò:>-\-<‚Äô
16:42:26 <monochrom> then let rcat answer. why do people speak for other people?
16:43:45 <rcat> jle`: pure code, business logic, etc, is wonderful in haskell
16:44:01 <adam_shimi> Ok, thanks jle` :)
16:44:05 <rcat> jle`: system code, like sockets and logic around them, not that much
16:44:27 <jle`> adam_shimi: np :) also feel free to stop by #haskell-game
16:44:29 <jle`> :D
16:44:36 <jle`> when you have questions
16:44:57 <rcat> jle`: I'm trying to improve a Cassandra library (cql-io) and I need to know why something fails, and it not very pure code, so I need more insight into that code
16:46:12 <EvanR> on the other hand, what code around sockets is wonderful
16:46:43 <tomphreek> monochrom: don't see why the que should be restricted to rcat
16:47:42 <monochrom> I agree to disagree.
16:48:21 <jle`> @let data Smiley = (:-<) | (:->) | (:-#)
16:48:21 <lambdabot>  .L.hs:173:15: parse error on input ‚Äò:-<‚Äô
16:48:34 <jle`> aw how come it works on my ghci
16:50:24 <monochrom> in ghci, is it "let data ..." or does it simply begin with "data ..."?
16:50:42 <monochrom> ah, simply begin with "data ..."
16:50:43 <EvanR> didnt think you could do data in ghci
16:50:53 <jle`> you can as of 7.something
16:51:02 <EvanR> dizzamn
16:51:04 <jle`> 7.somethingfairlylow
16:51:07 <shachaf> I think lambdabot's @let does some extra validation.
16:51:15 <shachaf> Maybe with haskell-src-exts or something.
16:51:24 <shachaf> It could be that its parser isn't perfect.
16:52:11 <zwer> @let data Foo = Bar | Baz
16:52:13 <lambdabot>  Defined.
16:52:44 <geekosaur> lambdabot
16:52:51 <geekosaur> s @let doesn't mean the same as let in ghci
16:53:15 <geekosaur> it means "parse what follows to see if it's valid and if so add it to the imports used by @run"
16:54:05 <shachaf> Hmm, @let must be clever enough to detect "@let import" and put it at the beginning of the file.
16:54:17 <jle`> i thought it added it to L.hs and then test-imported it to see if it parses and loads ok without error
16:54:46 <geekosaur> that does eem to agree with the error messages
16:54:48 <jle`> hm i guess i see there are some pretty obvious counter-examples to show that that isn't what happens
16:54:51 <shachaf> As I recall it does more than just try to load it in GHC.
16:55:39 <jle`> my idea for another counter-example didn't work out, but the example i posted earlier seems to be one
16:55:45 <hpc> @let {-# LANGUAGE TemplateHaskell #-}
16:55:45 <lambdabot>  Parse failed: Parse error: EOF
16:55:49 <hpc> :(
16:56:07 <jle`> well...is there a version of ghc where such a data declaration is *not* allowed?
16:56:24 <geekosaur> 7.4 and earlier didn't allow it
16:56:37 <geekosaur> if you're still talking about ghci
16:56:40 <jle`> data Smiley = (:-<), i mean
16:57:01 <jle`> it works for me but i am limited to a 7.8 testing environment for now
16:57:44 <shachaf> It's allowed by the Haskell 98 Report.
16:57:58 <geekosaur> yes but you have to go back a ways to find a version where leading : wasn't taken to mean "constructor"
16:58:18 <shachaf> geekosaur: ?
16:58:36 <shachaf> How far back?
16:59:12 <geekosaur> I don't know offhand. when I got into haskell ghc 6.6 was current and IIRC it had it, but there was talk about how it was a ghc-ism generalizing (:)
16:59:34 <geekosaur> that said, it could well be that they were talking in terms of something like haskell 1.4...
16:59:51 <geekosaur> (I haven't been involved with haskell quite *that* long!)
17:00:33 <shachaf> Maybe you're thinking of TypeOperators?
17:00:47 <shachaf> Even the Haskell 1.4 report allows it.
17:00:58 <geekosaur> I don't think so? (:) as a type operator is very recent
17:01:26 <shachaf> I mean, type operators starting with :
17:01:38 <shachaf> The change to "any symbol can be a type operator" was fairly recent.
17:01:40 <geekosaur> the context was how an operator-like thing would be recognized as a constructor vs. a variable in patterns
17:01:42 <geekosaur> not types
17:02:05 <shachaf> Hmm, well, as far as I can tell it's been this way for quite a while.
17:12:46 * hackagebot estimator 1.1.0.0 - State-space estimation algorithms such as Kalman Filters  http://hackage.haskell.org/package/estimator-1.1.0.0 (JameySharp)
17:14:40 <tomphreek> I asked this earlier, but perhaps there's different audience tonight. Has anyone got haskell docs accessible from vim? Would be really nice.
17:15:53 <pingu> tomphreek: it would be, I don't see how though. haddock produces html.
17:19:08 <tomphreek> shame about that. I was offered xmonad and browser earlier. I ll add it to my try one day list.
17:19:18 <glguy> When you're using haskellmode-vim you can use the _? command to open haddock for the symbol under your cursor in a web browser
17:19:44 <geekosaur> there's no vim equivalent of e.g. w3m?
17:20:02 <tomphreek> w3m would be good
17:21:23 <pingu> It's a good argument for having haddock produce multiple outputs. Not a small undertaking, though.
17:21:27 <tomphreek> glguy: that's better than nothing, but most annoying bit is leaving vim/tmux. I consider it if there's no answer though.
17:21:31 <inconceivable> I really really wish windows had xmonad.
17:21:49 <geekosaur> convince microsoft to open up the shell api...
17:21:54 <benzrf> inconceivable: why would you wish that instead of using a decent OS
17:22:01 <glguy> ViM is an editor, so it's not just better than nothing, it's what you should expect ^_^
17:22:43 <tomphreek> but but vim shows documentation for python, c++ and javascript... so I got spoilt
17:23:35 <tomphreek> (in a split buffer)
17:23:59 <inconceivable> benzrf: I use arch linux on one computer and windows 7 on the other. I really like linux. My problem is that every time I want to use something that just normally works, I have to install something new, and it's still too complicated. However, that may just be a qualm with arch linux more than xmonad.
17:24:39 <inconceivable> benzrf: Windows just works for me normally, even if its window management is inefficient and the os has too much stuff or whatever.
17:25:40 <inconceivable> geekosaur: That would be nice. I did see one attempt to write a window manager for windows, written in AutoHotKey, called bug.n
17:25:57 <geekosaur> the canonical example was litestep
17:26:21 <geekosaur> they eventually gave up because microsoft kept removing or changing incompatibly the undocumented APIs they were using
17:26:35 <inconceivable> Sounds frustrating.
17:35:04 <ezrios> I have a cabal sandboxed project that I want to enable profiling for
17:35:22 <ezrios> but whenever I try to `cabal install` I just get a bunch of errors saying "Maybe you haven't installed the profiling libraries for xxx-0.1.2.3?"
17:35:47 <ezrios> so I added 'library-profiling: True' to my .cabal-sandbox/config and try to `cabal install` the offending packages
17:35:59 <ezrios> but whenever I `cabal install` in the project directory I just get the same error
17:36:02 <ezrios> what gives?
17:36:54 <Marlin> it seems that -W -Wall misses quite a few pattern matches.. why it catch this one? f xs = let [x,_] = xs in x
17:37:06 <Marlin> +non-exhaustive
17:37:36 <Marlin> also doesn't catch it within lambda
17:37:44 <Marlin> g = \[x,_] -> x
17:38:05 <shachaf> Do yyou mean to switch "miss" and "catch" in that question?
17:38:10 <geekosaur> there's no point in checking within lambdas because there's nothing you can do about them in that case, so it's assumed deliberate
17:38:25 <shachaf> GHC with -Wall won't warn about cases like lambda and let.
17:38:36 <Marlin> yes I meant catch
17:38:36 <shachaf> For the reason geekosaur said, more or less.
17:39:04 <Marlin> geekosaur well, you can fix the bug if it was not deliberate
17:39:50 <johnw> tomphreek: exactly :)
17:41:40 <jle`> can any Num instance be encoded in Integer ?
17:41:58 <jle`> wait no that was a weirdly phrased question
17:42:19 <johnw> given that anything which is Num presumably fits in your machine's memory, it could be encoded as a number that could be stored in an Integer
17:42:23 <geekosaur> the only answer I can think of for that question as asked involves Cantor diagonalization
17:42:34 <jle`> can you turn any function/value parametric on Num a into a function.value on Integer with a (Integer -> a) function at the end
17:42:35 <geekosaur> although given the limits of actual hardware, yeh
17:43:13 <johnw> :t fromIntegral
17:43:14 <lambdabot> (Num b, Integral a) => a -> b
17:43:25 <jle`> like ant function paremetric on all (Num a) can be turned into a function on Integer, and then using fromIntegral at the end
17:43:32 <geekosaur> if the only constraint is Num, I think so? although the path might be weird
17:43:40 <jle`> *any function
17:44:04 <jle`> is Integer is an initial object in that sense?
17:44:44 <shachaf> jle`: CReal is "bigger" than Integer.
17:44:59 <shachaf> Well, that's arguable.
17:45:51 <shachaf> Maybe I wouldn't put it that way.
17:46:02 <shachaf> I think you'll need to phrase your question differently if you're asking about initial objects.
17:46:37 <shachaf> I don't think Integer is universal in any particular sense.
17:46:42 <shachaf> (Other than as a group or something.)
17:46:58 <jle`> in the sense that it can encode all functions parametric on general Num?
17:47:14 <jle`> i'm nto sure waht word i am looking for really
17:48:02 <shachaf> OK, can you describe what concept you're looking for?
17:49:16 <shachaf> OK, maybe I see the concept you're getting at, not exactly related to what geekosaur was talking about.
17:49:57 <benzrf> :t do
17:49:58 <lambdabot> Empty 'do' block
17:50:26 <johnw> benzrf: do is syntax
17:50:58 <jle`> it's ok, i will try to reformulate at another time
17:51:00 <jle`> thanks though
17:51:29 <shachaf> I'm not quite sure what the question is but I think the answer is no.
17:56:35 <benzrf> johnw: i kno
17:57:52 <tomphreek> is there a reason we have different names for fmap and liftM or is just a historical accident?
17:58:03 <johnw> tomphreek: they have different constraints
17:58:10 <johnw> but very soon, the distinction will be moot
17:58:23 <johnw> sorry, wrong use of the word "moot"
17:59:09 <geekosaur> currently it is possible for a Monad to not be a Functor, even though that makes no sense, so liftM is needed
17:59:25 <trap_exit> anyone here managed to write a window s8 app in haskell ?
18:00:08 <LordBrain> I used to think liftM might have some documenting value, as in emphasizing the fact that you are working with a monad... but as i got more experienced, I have tended to just move toward fmap anyway.
18:00:27 <johnw> well, if you have a law-abiding liftM, you *have* a functor, you just don't have a Functor
18:00:35 <johnw> (pre 7.10)
18:00:44 <geekosaur> the fact that liftM could be written for any Monad was more or less proof that every Monad is actually a Functor
18:00:52 <geekosaur> but haskell can't conclude that itself
18:01:05 <shachaf> Functor is a pretty special class because Functor instances are unique.
18:01:20 <geekosaur> (in fact, written generically such that it automatically works for any Monad)
18:01:42 <johnw> shachaf: all liftM implementations for the different possible Monads of a type former would have to coincide, wouldn't they?
18:02:25 <shachaf> Yes, no matter which Monad instance you have, you'll get the same liftM
18:03:28 <LordBrain> liftM2 is useful tho, there isn't an fmap2 is there?
18:03:29 <jle`> that's pretty neat
18:03:39 <jle`> LordBrain: fmap2 is not possible with just Functor
18:03:48 <jle`> the minimum amount of "power" you need is Applicative
18:04:01 <shachaf> Applicative is the class that gives you fmapN for every N.
18:04:20 <tomphreek> shachaf: why is Functor unique...? :)
18:04:27 <jle`> Applicative lets you turn an `f a` and an `f b` into an `f (a, b)`.  from there you can fmap your two-arity function onto the tuple
18:04:36 <jle`> and repeat arbitrarily for as many arguments as you want
18:04:55 <shachaf> tomphreek: If you have a Functor F, and some other function foo :: (a -> b) -> F a -> F b, the free theorem for foo tells you that it's equal to fmap.
18:05:29 <shachaf> tomphreek: Er, a foo that obeys the fmap laws.
18:06:56 <jle`> LordBrain: in an alternative history in another universe, you could say that Applicative was "invented to solve the liftN problem"
18:07:02 <jle`> it's such a cute narrative, if only it were true
18:07:17 <tomphreek> shachaf: I don't know free theorem. Though I am a mathematician and will probably have just about enough context to comprehend it. What is a Googleable name?
18:07:48 * hackagebot base-prelude 0.1.15 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.15 (NikitaVolkov)
18:07:53 <shachaf> @google theorems for free
18:07:57 <lambdabot> http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
18:07:57 <lambdabot> Title: Theorems for free Philip Wadler University of Glasgow* June 1989 Abstract Fro...
18:08:02 <shachaf> That paper, probably.
18:08:12 <shachaf> @free foo :: (a -> b) -> F a -> F b
18:08:12 <lambdabot> g . h = k . f => $map_F g . foo h = foo k . $map_F f
18:09:49 <Eolus> fancy
18:10:02 <benzrf> johnw: whats the REAL naratttive
18:10:47 <jle`> i'm assuming you mean me?
18:10:57 <jle`> it's just kind of roundabout from what i understand
18:11:10 <jle`> there's that famous Applicatives paper that probably gives the best historical context
18:11:42 <benzrf> jle`: yes oups
18:13:02 <tomphreek> so we know that every Monad's liftM = same monad's viewed as a Functor fmap, that was the original que
18:16:19 <shelf> will fmap ever become map
18:17:24 <tomphreek> shelf: I presume f is for functor, so don't see the problem
18:17:25 <MP2E> I think so, yes. But it's a long road
18:18:06 <MP2E> I think I might have interpreted that wrong. I thought 'will map ever be obsoleted entirely by fmap?' :P
18:18:14 <shelf> the specialised map for lists seems kinda pointless to me
18:19:03 <tomphreek> I think it's better for newcommers :)
18:19:04 <LordBrain> there's also omap
18:19:08 <MP2E> It is. Funnily enough it was a decision, rather than a historical mistake. Prelude is made up of mostly monomorphic functions to be easier on beginners
18:19:13 <jle`> well we have a specialised fmap for functions
18:19:35 <jle`> we like to use (.) instead of (<$>) or `fmap`
18:19:38 <MP2E> Frankly, I think monomorphizing everything in Prelude is *more* confusing for beginners in the long run because then you have to explain why you shouldn't use most of Prelude in production code
18:19:43 <jle`> but that's maybe because of fixity advantages though
18:19:58 <LordBrain> i think we should actually aim for something even more general than fmap before we rename it to map
18:20:33 <LordBrain> as in, we might want to map between subcategories of hask
18:20:36 <MP2E> ah gotta go
18:27:00 <orzo> latest ghc generalized some prelude functions
18:27:05 <orzo> er, unreleased
18:27:54 <orzo> but it causes type inference failures on simple code involvoing string literals and OverloadedStrings
18:28:09 <orzo> type inference failures will be confusing for beginners
18:34:43 <BMeph_> GHC is powered by the tears of those who generate type inference failures.
19:08:17 <rasen> is there a fast way to convert Word32 to [Word8]?
19:09:16 <shachaf> "fast" and "[Word8]" in the same sentence?
19:09:38 <sdegutis> What is S in data SM a = SM (S -> (a,S)) ?
19:09:55 <rasen> by "fast" I mean "requires little code"
19:10:12 <cmccann> sdegutis: a type named S. probably defined somewhere else in whatever file you're looking at?
19:10:18 <sdegutis> oh ok
19:10:27 <sdegutis> cmccann: I'm on https://www.haskell.org/tutorial/monads.html
19:10:49 <sdegutis> Oh I see: "built around a state type S"
19:11:15 <cmccann> yeah, I think that's just a "this is some type, details irrelevant"
19:11:29 <cmccann> using a lowercase name would be confusing since it'd look like a type variable
19:12:04 <shachaf> Oh. I don't know. [fromIntegral (x `shiftR` n) | n <- [0,8,16,24]]?
19:12:34 <rasen> ok. I found there is inet_ntoa :: HostAddress -> IO String. But why it's IO?
19:13:04 <cmccann> rasen: well, what does it do?
19:13:07 <rasen> I believe ntoa just converts host address to ipv4 address string with dots
19:13:26 <rasen> from man: The inet_ntoa() function converts the Internet host address in, given in network byte order, to a string in IPv4 dotted-decimal notation. The string is returned in a statically allocated buffer, which subsequent calls will overwrite.
19:15:33 <cmccann> rasen: I guess just because it's an FFI call to the actual function
19:16:10 <rasen> Anyway, it's possible to do FFI without IO
19:16:50 <cmccann> yeah, I'm not sure why that's in IO
19:17:52 <rasen> > [fromIntegral (0x7f000001 `shiftR` n) | n <- [0,8,16,24]]
19:17:52 * hackagebot husk-scheme 3.19 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.19 (JustinEthier)
19:17:53 <lambdabot>  [2130706433,8323072,32512,127]
19:18:12 <rasen> > [fromIntegral (0x7f000001 `shiftR` n) | n <- [0,8,16,24]] :: [Word8]
19:18:16 <lambdabot>  [1,0,0,127]
19:31:47 <sdegutis> I don't understand how Lucid actually gives you an HTML value back, considering it returns a () unit of Html type.
19:31:54 <sdegutis> See?  http://chrisdone.com/posts/lucid2
19:32:30 <sdegutis> He does "page :: Html ()" so how is it actually giving a value to the place where the "page" expression is used?
19:32:45 <benzrf> wot
19:32:54 <benzrf> sdegutis: what do you mean a "unit of html type"?
19:33:31 <sdegutis> It evaluates to Html () which I think we read as a unit of the Html monad.
19:33:33 <cmccann> sdegutis: Html is being used as a monad
19:33:45 <sdegutis> So where is the actual HTML data stored in this monad?
19:34:00 <sdegutis> I assumed it should be within where () is.
19:34:07 <cmccann> the document being constructed is part of the monad context. you use something like renderText etc. to get the result
19:34:51 <cmccann> sdegutis: http://hackage.haskell.org/package/lucid-2.8.1/docs/Lucid.html#v:renderText
19:34:58 <sdegutis> When I think of monads, I think of [], because [Int] is really [] Int, where the context is "many of them" and the type is "Int".
19:35:22 <sdegutis> So if you do an operation on the underlying value of the [] monad, you're really doing it on all the "many values" it contains.
19:35:24 <cmccann> note that you get a Text value out no matter what type "Html" is applied to
19:35:39 <cmccann> sdegutis: think of Html as something more like the writer monad
19:35:41 <sdegutis> And likewise if you do an operation on Maybe, you're doing it to the type it "perhaps" contain, if anything.
19:35:47 <sdegutis> cmccann: I don't understand the writer monad.
19:36:02 <cmccann> sdegutis: so "Html ()" is something more like "(Text, ())"
19:36:15 <sdegutis> cmccann: that seems a waste of the place where () is -- why not have it be Html String ?
19:36:44 <cmccann> because you'd not really get any benefit of the monad that way
19:36:54 <sdegutis> Why not?
19:37:31 <sdegutis> I'm thinking this means I just don't understand how monads help us.
19:37:49 <cmccann> because if you're working with it directly you don't need to use any of the implicit context provided by the monad
19:38:40 <cmccann> also, the actual representation it stores is more complicated, probably for the sake of building documents efficiently
19:38:55 <sdegutis> If we're working with what directly? And what context?
19:39:01 <sdegutis> Oh I see.
19:39:13 <sdegutis> So the fact that it's a monad is kind of like how in Java we would have private instance variables.
19:39:27 <sdegutis> And this lets it implement it efficiently and hide these details from the user.
19:39:36 <sdegutis> Is that exactly correct?
19:40:43 <cmccann> sdegutis: "context" here just meaning "all the stuff in the monadic type other than the last type parameter".
19:41:50 <cmccann> and that's the gist of one reason to implement a monad like this, yes. the practical details are very different from private instance variables, though.
19:42:41 <cmccann> sdegutis: another reason to have it as a monad is because it's actually a monad transformer, which means you can layer it over another monad
19:43:09 <cmccann> to add e.g. error handling or IO to your HTML generating code
19:43:22 <sdegutis> cmccann: uhhh
19:43:29 <sdegutis> That sounds so confusing.
19:43:37 <sdegutis> Like, I can't wrap my head around what that could possibly mean.
19:44:02 <sdegutis> Anyone else having trouble with https://wiki.haskell.org/ right now?
19:44:08 <cmccann> it means "you can do useful shit with this in a flexible way". the implementation details will just give you a headache :P
19:44:25 <sdegutis> chrome says https://wiki.haskell.org 's certificate is invalid
19:44:38 <sdegutis> cmccann: cool, I'll believe you
19:44:58 <sdegutis> cmccann: but I just have a hard time understanding what's better about using monads for this than doing the same thing in other languages
19:46:31 <athan> sdegutis: It's like...
19:46:46 <athan> a way to make sure your code only does what it's supposed to
19:46:54 <athan> Nothing more
19:46:57 <cmccann> sdegutis: it's not necessarily "better" than how other languages would do it, at least as far as what you're doing goes
19:46:59 <athan> throughout an area of code
19:47:27 <athan> it's not quicker in terms of productivity (at first)
19:47:37 <athan> but soon enough you can write compilers yourself
19:47:39 <athan> (imo)
19:48:18 <cmccann> sdegutis: just that the monadic interface is a sensible way to make it pleasant to use in Haskell. the end result is mostly the same.
19:49:24 <cmccann> sdegutis: but once you get the hang of fancier stuff in Haskell you can get a lot of additional power out of it, because the monadic approach is a more flexible abstraction
19:49:42 <sdegutis> oooh
19:49:52 <sdegutis> so it's basically Java interfaces
19:49:59 <sdegutis> no wait
19:50:07 <sdegutis> okay I'll just take your word for it, but I just won't understand.
19:51:32 <cmccann> sdegutis: the idiomatic equivalent in a Java-like language would probably be some sort of "HTML builder" object that you call methods on and generally poke at, maybe combining it with other instances of the same HTML builder class, then call a "gimme the goods" method at the end
19:51:37 <cmccann> to get the completed document out
19:51:48 <sdegutis> Wait, Haskell didn't always have monads? And the IO was initially a GHC extension? And then it was realized how useful it is and it became bult-in?
19:52:34 <rasen> Not sure if it was GHC extension, but yes... Before that IO wasn't monadic
19:52:48 <sdegutis> wow
19:52:59 <bananagram> it was an embarassing time
19:53:49 <sdegutis> Okay this makes sense now... Haskell didn't have monads, and doing things purely was a huge pain, and it was discovered that monads were a really effective and composable solution for cleaning it up as well as making it easier to make your types abstract and extensible.
19:54:22 <rasen> exactly
19:54:29 <rasen> I like binary
19:54:29 <rasen> instance Binary Scrape where
19:54:29 <rasen>     get = Scrape <$> get <*> get <*> get
19:54:37 <cmccann> and now streaming IO is the new fad so we've all but come full circle :P
19:54:54 <sdegutis> So did I get that right?
19:55:08 <cmccann> (though in a much more sophisticated way than the oldskool request/response IO nonsense)
19:55:14 <sdegutis> ha
19:55:36 <sdegutis> I imagine monads are heavily used in Haskell HTTP routing libs, right?
19:55:51 <sdegutis> like Haskell's equivalent to Clojure's Ring
19:56:21 <sdegutis> re: https://github.com/ring-clojure/ring/wiki/Concepts
19:57:04 <sdegutis> ugh wiki.haskell.org has invalid certificate
19:57:08 <cmccann> sdegutis: from what I understand, monads are a useful way to formally describe IO and were used as such long before they existed in haskell. the discovery was more "hey, we can actually implement this directly, and works nicely"
19:57:30 <sdegutis> ooooh
19:58:45 <cmccann> note that even today very few languages are capable of expressing monads as a first-class concept in a useful way
19:59:12 <cmccann> and most if not all of the ones that can were heavily influenced by Haskell
19:59:58 <systemfault> Like Scala...
20:00:14 <cmccann> yeah, Scala and... uh. probably other languages.
20:00:59 <systemfault> I guess that the other academic haskell-style languages like epigram/agda/coq/idris/whatever all support monads?
20:01:40 <cmccann> I wouldn't call all of those "haskell-style"
20:02:42 <cmccann> but ML-family languages with fancy type systems probably can, though I'm not sure it'd be useful in all of them.
20:02:50 <rasen> I spent some time looking through scalaz, and now I thinks the worst scalaz problem is scala. Really the syntax is so ugly while overall design is quite fine
20:03:26 <cmccann> yeah, I can't deal with Scala syntax. every time I look at example code in Scala I feel horrified and slightly queasy.
20:03:39 <cmccann> and that's probably not really fair to the language but urgh
20:03:52 <rasen> Mostly because type inference is not quite good
20:04:07 <cmccann> that's probably part of it
20:04:27 <rasen> There is also funny thing that makes >>= unusable
20:04:42 <rasen> You can't mix >>= and >> because of different precedence
20:04:54 <cmccann> there's also the part where a lot of functional Scala seems to be "take typical terse and abstract Haskell-style code, then crud it up with pointless Java-style verbosity"
20:04:59 <cmccann> it's the worst of both worlds
20:05:45 <sdegutis> Wait wait wait wait
20:06:13 <sdegutis> Is the first example on http://chrisdone.com/posts/lucid2 actually capable of building the "page" value completely at compile-time?
20:06:30 <ab9rf> i looked at scala a while back.  didn't really see what it would do for me.
20:06:50 <cmccann> ab9rf: run on the JVM? I think that's the main thing it does for anybody.
20:06:59 <ab9rf> cmccann: why would i want that? :)
20:07:10 <ab9rf> cmccann: the JVM is heavier than your average school bus :)
20:07:27 <cmccann> sdegutis: I suppose it COULD, since it's just a top-level constant
20:07:49 <cmccann> sdegutis: but GHC doesn't pre-evaluate stuff like that as far as I know
20:07:59 <sdegutis> ok
20:08:05 <cmccann> ab9rf: then yes I think you can safely ignore Scala :P
20:08:13 <sdegutis> ab9rf: we're using Clojure at work so maybe Scala would be a good fit
20:08:25 <cmccann> honestly I find clojure more appealing than scala
20:08:40 <cmccann> not that I've used either to any significant degree
20:08:47 <ab9rf> cmccann: from what i've seen i'd tend to agree with you
20:08:47 <sdegutis> dynamic typing is just awful
20:09:00 <ab9rf> has anybody written a haskell compiler that targets the JVM?
20:09:07 <sdegutis> frege
20:09:14 <sdegutis> https://github.com/Frege/frege
20:09:18 <cmccann> that's not Haskell though
20:09:23 <sdegutis> close
20:09:26 <rasen> The only reason I know a bit of scala (and why I was looking at scalaz) is my friend's talks. We started learning functional languages at the same time
20:09:31 <dibblego> cmccann: no it isn't. Scalaz beats Haskell at some things.
20:10:00 <cmccann> dibblego: fair enough. like what?
20:10:11 <cmccann> last time I looked seriously at scala was years ago
20:10:39 <dibblego> the point of Scalaz really has nothing to do with Haskell, despite all the garbage on the internet ó it is to find the answer to the question ofm just how useful can Scala be in production code? Functional programming naturally comes of that
20:11:03 <rasen> scalaz is more correct from category theory point of view
20:11:19 <dibblego> cmccann: consider the existing proposals for Haskell, where you have resistance for ridiculius reasons ó we have no such problem ó consequently, the API advances beyond Haskell
20:11:42 <ab9rf> DO NOT MOVE MY CHEESE
20:12:13 <exio4> I think most of the problems with Scala aren't theorical, but from the side that you get the worst from two worlds
20:12:15 <sdegutis> i get that reference!
20:12:24 <dibblego> we don't say, for example, "make the type monomorphic, because think of the beginners!" ó most people who contribute to Scalaz actually teach beginners (for real) and so don't fall under this fallacy, resulting in having the best of both worlds (useful API as well as friendly to beginners)
20:13:11 <cmccann> dibblego: y'know, you should participate more in the discussions on the haskell libraries list. I'd enjoy seeing your diplomatic style in action there :P
20:13:35 <dibblego> cmccann: I do participate, just not on the mailing list ó I participate in other ways, which I think is more productive.
20:13:52 <cmccann> dibblego: but anyway ok, I can buy that. I fully admit that my distaste for scala's syntax is superficial and I know nothing about scalaz as it's used in practice.
20:14:17 <cmccann> most things are more productive than the libraries list, I suspect...
20:14:25 <dibblego> cmccann: there are many things to pick on scala for, and the syntax is way down the bottom of the list ó some of the decisions are outright stupid
20:15:34 <dibblego> scalaz exists because the core scala library and java library is not useful, and I had a production application to write, quickly
20:15:43 <dibblego> turns out, so did a lot of people
20:16:28 <cmccann> do you think scala is worth using for someone with no particular reason to target the JVM? e.g. as opposed to using Haskell or whatever else.
20:16:36 <dibblego> absolutely not
20:16:51 <cmccann> haha, ok
20:16:57 <dibblego> it has nothing redeemable, except the ability to work against hte JVM legacy
20:18:04 <dibblego> this point is well-accepted among those who use both successfully, but remains a point of contention anyway (because u r extweemist and all that)
20:18:30 <sdegutis> This line utterly confuses me:  runState stackManip [5,8,2,1]
20:18:33 <sdegutis> in http://learnyouahaskell.com/for-a-few-monads-more#state
20:18:37 <Zekka> dibblego: What's so bad about Scala? I periodically work on JVM projects and consider introducing it, but I'm not that tied to it
20:18:44 <sdegutis> Why is runState getting two arguments?
20:18:57 <Zekka> :t runState
20:18:57 <cmccann> sdegutis: why wouldn't it?
20:18:58 <lambdabot> State s a -> s -> (a, s)
20:19:06 <rasen> sdegutis: the first one is initial state
20:19:15 <Zekka> sdegutis: One's a stateful action, the other's the initial state
20:19:17 <sdegutis> runState takes a State as its only argument
20:19:24 <dibblego> Zekka: where to start? I wrote this 4 years ago http://tonymorris.github.io/blog/posts/what-kind-of-things-are-easy-in-haskell-and-hard-in-scala-and-vice-versa/index.html however, if I were to write it again today, it would be even worse
20:19:41 <Zekka> sdegutis: Yes, but results in a function that takes the starting state
20:19:44 <sdegutis> er sorry a Stack
20:19:46 <Zekka> dibblego: I'll read it and ask what you didn't cover
20:19:59 <Zekka> I know a guy who's into Idris and Scala of all things and I don't know why. He doesn't like Haskell
20:20:00 <sdegutis> I'm so confused.
20:20:16 <Zekka> sdegutis: Do you understand the type I just made lambdabot spit out?
20:20:21 <Zekka> If not we should probably start with that
20:20:22 <dibblego> Zekka: who?
20:20:27 <ab9rf> i ran into someone today who was insisting that functional programming has "bad I/O"
20:20:38 <Zekka> dibblego: I don't think he hangs out in this channel, he goes by "Agro" on other servers though
20:20:56 <dibblego> sdegutis: (State s a) is a wrapper of that function ó runState simply unwraps it
20:21:07 <sdegutis> Zekka: I see that it is a function that takes a State and returns a function that takes a thing and returns a tuple
20:21:13 <dibblego> ab9rf: this is a common beginner mistake, which is worht addressing
20:21:29 <Zekka> sdegutis: Yeah, so do you see why you can feed two things into it and get a result?
20:21:46 <sdegutis> Zekka: I think
20:21:54 <dibblego> sdegutis: data State s a = State (s -> (a, s)) -- all we are doing is unwrapping that function
20:22:00 <sdegutis> Oh I see.
20:22:21 <benzrf> newtype, more likee
20:22:27 <Zekka> So we need to pass the value in State to get a thing to unrap, and then we use the function we unwrapped to do its action
20:22:41 <benzrf> hos it goin Zekka
20:22:56 <sdegutis> Okay so runState takes a State and a Stack and returns a (Stack,Int)
20:23:04 <sdegutis> But it's getting a State and then a list!
20:23:10 <sdegutis> A list is not a stack.
20:23:17 <Zekka> benzrf: Not bad! I'm helping out a professor at my school with his Haskell class and working a little on an Eliza bot in my spare time
20:23:18 <benzrf> sdegutis: sure it is
20:23:23 <benzrf> Zekka: hella
20:23:40 <sdegutis> Oh snap.
20:23:43 <sdegutis> type Stack = [Int]
20:23:44 <dibblego> takes a State Stack Int and a Stack and returns a (Int, Stack)
20:23:44 <Zekka> sdegutis: It has O(1) cons and uncons! (call them push and pop if you want)
20:24:01 <sdegutis> T'was simply too many things to hold inside one brain simultaneously.
20:24:27 <dibblego> sdegutis: use :info at ghci to resolve this
20:24:39 <sdegutis> I was just reading http://learnyouahaskell.com/for-a-few-monads-more#state is all, not doing HGCI.
20:25:37 <Zekka> dibblego: Nice article by the way
20:26:32 <EvanR> a list is a stack. too bad i never see a use for stacks ;)
20:26:41 <sdegutis> for my next trick, I'm going to rewrite https://github.com/sdegutis/servum/blob/master/Main.hs to use Control.Monad.State/State
20:26:45 <EvanR> except tower of hanoi
20:26:54 <sdegutis> or something
20:26:56 <sdegutis> OH!
20:27:05 <sdegutis> This would be an excellent example of composing two unrelated monads, right??
20:27:08 <sdegutis> State and IO
20:27:14 <gcganley> does anyone have a 'haskell for all' article about Lens' ?
20:27:20 <sdegutis> for like, a "number incrementer" program, right?
20:27:22 <dibblego> sdegutis: I don't see where state could be used there
20:27:35 <Zekka> My impression of Scala was that it was very big and provided a ton of choice (look at the family of collections types!)
20:27:50 <Zekka> That's not necessarily good or bad but it makes it really hard to evaluate
20:27:57 <dibblego> gcganley: do you mean the Lens' type-alias or the lens package?
20:28:17 <dibblego> Zekka: the whole point of scala is to make it hard to evaluate. That is the primary goal.
20:28:36 <Zekka> and it seems like it means you get C++'s problem where the right featureset is smaller than the complete featureset
20:28:42 <Zekka> dibblego: Is that a pun?
20:28:50 <dibblego> No.
20:29:10 <gcganley> dibblego: no lol i didnt mean it like that i meant it like the ownership apostraphe
20:29:48 <gcganley> i hope one day i no longer have to appoligze for my spelling in this channel...
20:29:48 <dibblego> gcganley: here you are https://www.youtube.com/watch?v=efv0SQNde5Q
20:30:16 <sdegutis> is ghc-haskell's compiler written in haskell?
20:30:17 <dibblego> gcganley: here is another talk https://www.youtube.com/watch?v=d8dsu77tnFY
20:30:33 <Zekka> sdegutis: Mostly, I think
20:30:35 <sdegutis> is the runtime also written in haskell?
20:31:01 <Zekka> sdegutis: I haven't worked on GHC but IIRC the RTS is in C
20:31:04 <shachaf> No, the runtime is written in C and Cmm.
20:31:09 <sdegutis> nice
20:31:11 <sdegutis> <3 c
20:32:28 <sdegutis> is this a stuipd way to write this?  https://github.com/sdegutis/servum/blob/master/Main.hs
20:32:29 <Zekka> dibblego: How do you feel about metaprogramming or the type system in scala? The friend I mentioned said he liked its metaprogramming support better and (I'm assuming) its dependent type support better
20:32:47 <Zekka> I'm guessing on that last thing because his claim was that it was "more powerful" than Haskell's in the sense of Idris
20:32:47 <dibblego> Zekka: I think lol
20:33:01 <tommyd_> hey guys, can someone experienced answer a quick question of mine?
20:33:05 <dibblego> scala does not have dependent types, though there are a few individuals who like to pretend, which is hilarious
20:33:31 <Zekka> sdegutis: I don't ee anything wrong with it
20:33:41 <dibblego> and "metaprogramming support" is quite the joke ó many of us have tried to hack on that and we ended up just writing a parse tree in haskell
20:33:42 <Zekka> IIRC 'getNumber' is already provided
20:33:44 <Zekka> :t readLn
20:33:45 <lambdabot> Read a => IO a
20:33:55 <tommyd_> I'm running a simple server that's listening on port 4242. How do I connect to the server to interact with it as a client
20:34:12 <EvanR> you can use the program netcat
20:34:13 <Zekka> And you probably don't need to factor out so many miniature functions when they don't take parameters anyway
20:34:20 <EvanR> or telnet
20:34:26 <tommyd_> im on win8
20:34:30 <Zekka> dibblego: How do you feel about shapeless?
20:34:30 <tommyd_> does that matter"
20:34:37 <EvanR> ... ya got me
20:34:42 <Zekka> (I mean, I'm guessing the answer is that you don't like it, but I don't know very much about it)
20:34:58 <dibblego> Zekka: here is not a good place for me to answer that question
20:35:01 <tommyd_> I have a vm of unbuntu. If I use that can you help me?
20:35:23 <EvanR> yeah if you vm linux can connect over the network to your host machine, youre golden
20:35:23 <Zekka> dibblego: I can stop bugging you or bug you elsewhere if you'd like -- I don't know what the right place to discuss Scala in comparison to Haskell is
20:35:35 <dibblego> Zekka: we are in #scalaz
20:35:41 <tommyd_> cool, so what would be the command to connect to that server?
20:35:49 <EvanR> apt-get install nc
20:35:54 <EvanR> er, netcat
20:36:22 <tommyd_> I can write a function that listens for connections and then responds with "hi" or something, right? That's pretty simple
20:36:31 <EvanR> yeah
20:37:01 <tommyd_> I'm a noob when it comes to this. I just like solving programming challenges-- trying to create more relevant applications now. simple ones, but something that does more than solve a programming challenge
20:37:07 <EvanR> if had a server running, then nc hostname:port would be all you need to do to test
20:37:22 <EvanR> nc hostname port
20:37:37 <tommyd_> and if it's my same machine, would the hostname be 127.0.0.1?
20:37:44 <rasen> yes
20:38:03 <EvanR> yeah, but if its somewhere outside the vm...
20:38:08 <tommyd_> hmm
20:38:12 <tommyd_> so not the same IP then?
20:38:17 <EvanR> i doubt it
20:38:29 <tommyd_> so my vm gets it's own IP on my network??!
20:38:32 <tommyd_> wow
20:38:55 <EvanR> not sure, but your host machine is not going to be accessible at 127.0.0.1
20:38:59 <tommyd_> I guess so-- OS's have network daemons, so why wouldn't it search for a connection
20:39:44 <EvanR> might as well ship the whole operation to the linux vm ;)
20:40:06 <tommyd_> i will
20:48:00 <codygman> Can I eta reduce this?
20:48:02 <codygman> > liftA (liftA (+ 1)) (return . Just $ 1)
20:48:04 <lambdabot>  No instance for (GHC.Show.Show (f0 (Data.Maybe.Maybe b0)))
20:48:04 <lambdabot>    arising from a use of ‚ÄòM9250382542144194457112.show_M9250382542144194457112‚Äô
20:48:04 <lambdabot>  The type variables ‚Äòf0‚Äô, ‚Äòb0‚Äô are ambiguous
20:48:21 <shachaf> No, it has no lambdas.
20:48:44 <shachaf> (Putting "> " in front of an expression isn't really necessary when all that'll happen is lambdabot printing an error.)
20:49:07 <codygman> shachaf: That didn't happen in ghci locally.
20:49:43 <codygman> perhaps I should ask is there a better way to write/express: liftA (liftA (+ 1)) (return . Just $ 1 :: IO (Maybe Int))
20:49:49 <shachaf> True, ghci probably assumed the whole thing had type IO (Maybe Integer)
20:50:01 <codygman> shachaf: yep
20:50:11 <shachaf> Sure, "return (Just 2)"
20:50:33 <shachaf> (You can almost always improve a program by writing fmap instead of liftA.)
20:50:35 <rasen> :D
20:50:36 <codygman> shachaf: that code is a reduction of: liftA (liftA (\fp -> fp </> fromText "*")) (lookupEnv' "STEAMROOT")
20:50:47 <nshepperd> well, to start with you could use fmap instead of liftA...
20:51:16 <EvanR> didnt even know about liftA
20:51:19 <shachaf> I think fmap (fmap (</> fromText "*")) (lookupEnv' "STEAMROOT") is reasonable.
20:51:39 <shachaf> If you want, you can write it as (fmap . fmap) (</> fromText "*") (lookupEnv' "STEAMROOT") or something. Maybe use <$> if that's clearer for you.
20:51:51 <shachaf> Or over (mapped . mapped) ... if you happen to really like lens.
20:51:54 <codygman> shachaf: Yeah I like: fmap (\fp -> fp </> fromText "*") <$> (lookupEnv' "STEAMROOT")
20:53:00 <codygman> I was playing around with some code golfing: http://lpaste.net/119670
20:53:12 <codygman> oh didn't make my change :/
20:53:42 <shachaf> Oh, if you want to *golf* it, that's a different story.
20:53:45 <nshepperd> if you're doing a huge amount of (fmap . fmap) everywhere, you might want to consider using Data.Functor.Compose
20:54:06 <codygman> nshepperd: Thanks, I've never heard of it before.
20:54:11 <shachaf> What nshepperd says is also true. But I doubt that's the case for something that returns IO (Maybe ...)
20:54:22 <shachaf> You can also write your own function fmap¬≤ = fmap . fmap
20:54:31 <cmccann> call it ffmap
20:54:36 <cmccann> then fffmap can be fmap.fmap.fmap
20:54:42 <cmccann> it's self-documenting!
20:54:43 <codygman> shachaf: how about <2$>
20:54:50 <EvanR> <$2>
20:54:51 <shachaf> Not valid Haskell.
20:54:56 <codygman> cmccann: lol!
20:54:59 <cmccann> I've used <<$>> though
20:55:05 <shachaf> I didn't realize until just now that fmap¬≤ *was* valid Haskell.
20:55:12 <cmccann> shachaf: why wouldn't it be
20:55:16 <cmccann> it's alphanumeric
20:55:28 <nshepperd> you can't put numerals into an operator
20:55:32 <shachaf> cmccann: For some reason I thought it was a symbol rather than alphanumeric.
20:55:38 <codygman> shachaf: <$¬≤>
20:55:43 <codygman> lol
20:55:53 <shachaf> codygman Doesn't work -- see the discussion just above.
20:56:05 <cmccann> ¬≤ alone is a lexical error
20:56:13 <cmccann> because it's numeric, but not a valid literal
20:56:34 <EvanR> <<‚òØ>>
20:56:40 <EvanR> <<‚ò≠ >>
20:56:58 <codygman> EvanR: Thanks, <<‚òØ>> is clearly the best solution.
20:57:06 <EvanR> ‚òÜ
20:57:25 <cmccann> how about <‚òÉ>
20:57:46 <EvanR> <<pile-of-poo-emoji>>
20:57:48 <platz> emoji haskell
20:58:23 <EvanR> it would avoid success at all costs
20:58:29 <bananagram> :t fmap . fmap
20:58:30 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
20:59:04 <codygman> > let (‚òÜ) = (+ 1)
20:59:06 <lambdabot>  not an expression: ‚Äòlet (‚òÜ) = (+ 1)‚Äô
20:59:14 <codygman> > (‚òÜ) = (+ 1)
20:59:15 <lambdabot>  <hint>:1:5: parse error on input ‚Äò=‚Äô
20:59:18 <codygman> aww
20:59:20 <tommyd_> wow, lambdabot is awesome
20:59:24 <tommyd_> ghci in irc
20:59:29 <EvanR> codygman: unary operator?
20:59:30 <bananagram> @let (‚òÜ) = (+ 1)
20:59:32 <lambdabot>  Defined.
20:59:35 <cmccann> EvanR: http://www.fileformat.info/info/unicode/char/1F4A9/index.htm
20:59:35 <tommyd_> well, at least the type checker
20:59:42 <codygman> > ‚òÜ 1
20:59:44 <lambdabot>  <hint>:1:1: parse error on input ‚Äò‚òÜ‚Äô
20:59:49 <cmccann> based on the unicode category, I think "pile of poo" is a valid operator in Haskell
20:59:54 <codygman> I'm full of fail, someone else do it
21:00:14 <bananagram> > (‚òÜ) 2
21:00:15 <lambdabot>  3
21:00:16 <shachaf> Better to experiment with lambdabot in /msg unless you're showing something to the channel.
21:00:19 <bananagram> > 2 (‚òÜ)
21:00:20 <lambdabot>  Could not deduce (GHC.Num.Num ((a0 -> a0) -> t))
21:00:20 <lambdabot>    arising from the ambiguity check for ‚Äòe_12‚Äô
21:00:20 <lambdabot>  from the context (GHC.Num.Num ((a -> a) -> t), GHC.Num.Num a)
21:00:21 <bananagram> > 2 ‚òÜ
21:00:22 <lambdabot>  <hint>:1:4:
21:00:22 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
21:00:36 <codygman> bananagram: Nice :)
21:00:46 <shachaf> Really, this lambdabot addiction is ridiculous. People used to be able to communicate with each other by addressing each other, rather than addressing the bot in the presence of each other.
21:00:56 <bananagram> can infix functions even be used with only one argument?
21:00:57 <EvanR> > let (üí©) = (+) in 2 üí© 2
21:00:58 <lambdabot>  4
21:01:13 <bananagram> shachaf, they say speech is the lowest form of communication
21:01:23 <cmccann> > text "shachaf: I don't know what you're talking about"
21:01:24 <lambdabot>  shachaf: I don't know what you're talking about
21:01:36 <glguy> Yes, speech is too slow, I bet silence is fast
21:01:39 <EvanR> lambdabot: please tell shachaf that im listening
21:02:06 <EvanR> cmccann: yeah, pile of poo works, as above
21:02:20 <codygman> mapM_ silence everyone etc
21:02:21 <cmccann> EvanR: works with Haskell yes, with my IRC font not so much
21:02:22 <codygman> ha
21:02:30 <cmccann> but it's the thought that counts
21:04:36 <nshepperd> it seems like you can use an infix operator like (‚òÜ) in an operator section, like (1‚òÜ), but haskell assumes the result of a section to be a function, so you get a unification error
21:05:02 <shachaf> nshepperd: GHC has an extension to disable that.
21:05:09 <shachaf> PostfixOperators
21:05:09 <nshepperd> or rather ghc assumes that
21:05:30 <shachaf> The Report specifies that (x OP) means (\y -> (OP) x y)
21:05:31 <shachaf> (almost)
21:06:03 <cmccann> and we all know GHC always follows what the Report specifies
21:06:30 <nshepperd> ah, I didn't know if that was set by the actual hreport
21:27:50 <tommyd_> hey guys
21:28:05 <tommyd_> how can I pattern match in a function for an empty Data.Dlist Differnce list
21:28:24 <stelleg> anyone know if there is a reference for special unicode characters for haskell, e.g. the lambda symbol or the arrow symbol
21:28:36 <stelleg> they don't seem to be in the syntax spec
21:29:04 <tommyd_> dlist "empty" creates and empty difference list, but ghc doesn't like it
21:29:42 <tommyd_> i dont think I can pattern match on one
21:32:32 <glguy> tommyd_: No, you can't pattern match on a function
21:39:29 <nshepperd> tommyd_: convert it to an ordinary list: case toList dl of { ... }
21:39:42 <tommyd_> is that efficient?
21:39:48 <tommyd_> or is the conversion slow?
21:40:22 <dmwit> depends
21:40:52 <dmwit> doing the conversion once is fine
21:40:54 <glguy> If you're finding yourself needing to convert the DList to normal lists along the way you've got the wrong type
21:41:11 <dmwit> if you need sharing, dlist is not for you
21:42:07 <dmwit> though you can fake it with fromlist.tolist in dire situations
21:47:25 <nshepperd> as far as I know, the conversion is no slower than directly pattern matching would (hypothetically) be
21:48:43 <dmwit> the first match, yes
21:49:10 <dmwit> a second match has to recomputo the function
21:49:38 <athan> dmwit: http://deconfigured.com/blog/atlc2
21:49:50 <athan> dmwit: Am I on to anything? :\
21:49:57 <nshepperd> right, yes
21:51:49 <nshepperd> dlist is basically an unbalanced tree, where pattern matching the outer constructor involves walking the left edge of the tree
21:52:05 <nshepperd> whether that's fast depends how you've been using it
21:52:07 <nshepperd> I think
21:52:40 <pippijn> hi
21:52:56 <pippijn> is there an arbitrary precision xor?
21:53:35 <pippijn> there is Data.Bits.xor, but despite operating on Int, it only supports 64 bits (on my 64 bit machine)
21:54:05 <dmwit> athan: I'm not really in a goodset up to do careful reading right now, sorry.
21:54:23 <athan> dmwit: It's all good :) Thank you for trying!!
21:54:26 <dmwit> pippijn: xor on Integer
21:54:33 <kadoban> pippijn: Int /is/ 64 bits. Are you thinking of Integer, which is arbitrary precision?
21:54:39 <pippijn> oh. yes
21:54:42 <athan> :t `xor`
21:54:43 <lambdabot> parse error on input ‚Äò`‚Äô
21:54:49 <athan> derp
21:54:54 <athan> :t xor
21:54:55 <lambdabot> Bits a => a -> a -> a
21:54:59 <pippijn> excellent
21:55:04 <pippijn> on Integer it does the right thing
21:55:16 <kadoban> Cool
21:56:21 <dmwit> athan: ping me again tomorrow though
21:56:28 <athan> will do :)
21:56:31 <athan> thanks dmwit!!
22:30:17 <L8D> Where should my instance declarations for things like (ToJSON UUID) ?
22:30:21 <L8D> in my cabal project
22:30:32 <L8D> should they be some random module with the instance declarations?
22:30:37 <mzero> as in, it isn't your UUID type?
22:30:44 <mzero> and this is an orphan instance?
22:31:04 <L8D> I'm using the UUID from the 'uuid' hacke
22:31:07 <L8D> from Data.UUID
22:31:14 <L8D> should I roll my own?
22:31:32 <pacak> L8D: To avoid orphan instances - either next to typeclass declaration or datatype declaration.
22:31:34 <mzero> Then, if you have any other UUID utilities, then I'd go ahead and put it there, and silence the warnings with a pragma
22:31:46 <pacak> L8D: In your case that would be later.
22:32:00 <mzero> pacak: UUID is coming from some other package -
22:32:35 <mzero> L8D: If you are writing an application, the orphan instance thing isn't really a problem
22:32:36 <L8D> should I roll my own UUID type, because the uuid package has some really useful utilities
22:32:46 <mzero> no
22:32:49 <L8D> mzero: ok. where should I put this orhpan instance then?
22:32:52 <L8D> orphan*
22:33:00 <L8D> mzero: just some random utility module?
22:33:00 <mzero> are you writing a library or an application?
22:33:15 <L8D> mzero: app
22:33:25 <mzero> then yes, just some random utility module
22:33:27 <mzero> is fine
22:33:29 <L8D> ok
22:33:31 <L8D> thanks
22:33:35 <mzero> use a pragma to silence the warning
22:42:06 <codygman> Can anyone that uses shelly tell me what I'm doing wrong here? I'm trying to use the efficient method of piping with handles: shelly $ runHandle "echo" ["test"] (\h -> run "grep" ["test"])
22:42:46 <freebee> hello, im new on here and I was wondering if i could get some help on a homework assignment. I posted on stack overflow, but I couldn't really get anything out of it.
22:43:22 <freebee> i was wondering if someone with a stack account could maybe post some more hints.
22:44:01 <mzero> link?
22:44:19 <freebee> http://stackoverflow.com/questions/28245511/inserting-into-a-binsearchtree%27
22:44:37 <gazay> Hello! I‚Äôm trying to build https://github.com/neurocyte/android-haskell-activity inside https://github.com/sseefried/docker-build-ghc-android. I‚Äôve installed all dependencies (it was hard) and now I have error on Linker phase when trying to build android-haskell-activity: https://gist.github.com/gazay/17debe6495fd46e1cebd
22:45:37 <gazay> as I understand - problem is that ld have some environment predefined option -r which conflicts with -shared option. Anyone knows how I can override this default option?
22:46:02 <mzero> freebee: First, "result" isn't a particularly useful function
22:46:18 <freebee> i need to use it, though
22:46:22 <freebee> it's a requirement
22:46:42 <mzero> oh god, no - please don't tell me your prof. has that in the problem set...
22:46:50 <freebee> yup...
22:47:13 <freebee> look at how it's supposed to run. i need to use bstsize and result
22:47:15 <mzero> OY! we've GOT to develope an intro problem set for they folks
22:47:33 <mzero> okay
22:47:36 <mzero> well..... then
22:47:58 <mzero> first ... can you write      bstFind :: q -> BSearch q w -> Maybe w
22:48:04 <Guest59269> Hey, what's going on? Is anyone else experiencing problems with Haskell.org? It's currently displaying an invalid SSL certificate.
22:48:07 <mzero> as in, do you think you know how to do this?
22:48:17 <DerisiveLogic> No idea.
22:48:29 <freebee> not really. im new to haskell. i read the book, but i've only been doing this for 2 weeks.
22:48:35 <mzero> Guest59269: it is good for me
22:48:54 <mzero> Okay - well, you need to be able to think about how bstFind would work before you can make ins work
22:49:14 <freebee> is bstFind searching for a particular node?
22:49:17 <mzero> because, if you think about it, inserting into a BST is going to essentially have to find the place to do the insert, yes?
22:49:22 <mzero> freebee: yes
22:49:38 <mzero> see - the type signature can often basically tell you all there is to know about a function
22:50:21 <freebee> can you clarify what this means: insertTree :: (Ord key) => key -> x -> BST key x -> BST key x
22:50:29 <freebee> im a bit fuzzy
22:50:36 <mzero> Ah, good
22:50:54 <L8D> mzero: I can't find the pragma to disable orphan instance warnings
22:50:55 <mzero> well, in Haskell you can't actually modify the BST --- data is immutable!
22:52:01 <mzero> L8D: {-# OPTIONS_GHC -fno-warn-orphans #-}
22:52:28 <L8D> oh thanks
22:52:38 <mzero> freebee: so "inserting" is really "given a key and a value, and a BST.... return a new BST that is just like the old BST, but with the value at the key"
22:53:26 <freebee> makes sense
22:53:48 <mzero> but really, you should write yourself bstFind first....
22:53:49 <freebee> i am assuming i need to use recursion to solve this problem, but i am confused as to what my cases will be
22:54:01 <mzero> is it okay to start with bstFind?
22:54:09 <freebee> he said no to add other functions to be honest.
22:54:26 <freebee> only result and bstSize
22:54:37 <mzero> well, he's a clod and not a good teacher... but we'll ignore that - you can write this on your own
22:54:43 <mzero> get it to work, then just not turn it in
22:54:45 <mzero> :-)
22:55:19 <freebee> smh and it was my last problem, too lol.
22:55:26 <freebee> so close and yet so far
22:55:42 <mzero> so... let's just think about BSearch ... how many "cases" does it have?
22:56:05 <freebee> well, it should have 3
22:56:11 <augur> anyone know how to profile properly? +RTS -p is only showing me a module breakdown :(
22:56:13 <mzero> I see 2:  Empty and None ....
22:56:38 <freebee> Aren't empty and none the same thing?
22:56:49 <monochrom> what is None?
22:57:07 <mzero> err.. sorry...
22:57:17 <mzero> Empty and Node
22:57:33 <freebee> Empty means there aren't any nodes in the tree, right?
22:57:58 <mzero> augur: chapter 5 of the GHC manual is a good thing to read: https://www.haskell.org/platform/doc/2013.2.0.0/ghc-doc/users_guide/profiling.html
22:58:22 <mzero> but what you are looking for is   -fprof-auto
22:58:40 <augur> ahhhh ok thank you mzero :)
22:58:43 <mzero> right so.... the recursion for bstFind (or ins) is going to have two main cases
22:59:08 <mzero> so, freebee      bstFind key Empty =  .....
22:59:13 <mzero> that should be easy, yes?
22:59:51 <freebee> Empty?
23:00:20 <mzero> well, bstFind returns   Maybe w ....   returning Empty would be returning a BST, we wnat to return a Maybe w .... so  Nothing
23:00:27 <randomclown> is there anything like npm --save for cabal
23:00:30 <mzero> bstFind key Empty = Nothing
23:00:32 <randomclown> editing the .cabal file sucks
23:00:40 <freebee> ok
23:00:57 <mzero> read "finding key in the empty tree yeilds nothing"
23:01:24 <freebee> ok
23:01:39 <freebee> got it
23:01:42 <mzero> now think of the other case.....     just write it out.....    bstFind key (Node k w la lb)
23:02:02 <mzero> what could this = ?
23:02:32 <mzero> just say it aloud "if key equals k ...."
23:03:02 <freebee> like this?
23:03:02 <freebee> | k == w = Node k w la lb
23:03:23 <mzero> well... are yo uwriting bstFind --- that is finding a value at a key
23:03:30 <mzero> or are you writing ins  that is inserting?
23:03:47 <mzero> also, why are you comparing k, the key in the Node, with w, the value in the Node?
23:03:48 <freebee> yeah, my bad. i thought you were just renaming insert
23:03:53 <mzero> no no
23:04:28 <mzero> you should work thorugh how to do the recursion for finding the value at a key in a tree --- because that is a bit easier than insert and helps you see the recursive pattern
23:04:32 <mzero> then we can do insert
23:04:46 <freebee> i need to use insert, though.
23:05:10 <mzero> you need to write insert, correct?
23:05:10 <freebee> oh, nevermind. i thought you meant we wouldnt do insert
23:05:15 <freebee> yes
23:05:27 <mzero> right - no, we'll get to insert -- but you have to see find first
23:07:18 <freebee> im sorry i cant figure it out. i feel dumb :/
23:09:34 <lpaste> mzero pasted ‚ÄúbstFind‚Äù at http://lpaste.net/119680
23:09:54 <mzero> let's talk in code - look at that - that is what we have so far (plus a little bit)
23:10:29 <mzero> click edit on that and try to fill in the first set of ...
23:12:14 <mzero> sigh
23:12:28 <mzero> prof.s like that should be shot
23:12:36 <mzero> well, at least yelled at
23:15:09 <tempay> I'm not very comfortable with monad transformers yet.. if I want something that acts like Either a (Writer b c), do I use EitherT or WriterT?
23:17:00 <randomclown> I'd expect EitherT
23:18:02 <tempay> Yeah, that was my thought, but runEitherT is type "m (Either e a)" which doesn't seem right
23:18:24 <randomclown> what are you trying to achieve?
23:18:51 <randomclown> you want to lift and be able to access the writer right?
23:18:54 <Hijiri> Either a (Writer b c) sounds like EitherT
23:18:56 <Hijiri> no
23:18:58 <Hijiri> WriterT
23:19:16 <Hijiri> @unmtl WriterT (Either String) ()
23:19:16 <lambdabot> Plugin `unmtl' failed with: `WriterT (Either String) ()' is not applied to enough arguments, giving `/\A. () (A, (Either String))'
23:19:23 <tempay> Parsing something that might fail, so either i get the error message or the writer with the parse
23:19:26 <Hijiri> @unmtl WriterT String (Either String) ()
23:19:26 <lambdabot> (Either String) ((), String)
23:19:39 <shachaf> You're right: EitherT e m a = m (Either e a); WriterT w m a = m (w, a)
23:20:05 <shachaf> So it sounds like you want WriterT w (Either e) a
23:20:12 <tempay> right, thanks
23:20:22 <tempay> was just a little counter intuitive
23:21:17 <isBEKaml_> hi
23:21:29 <mzero> welcome
23:21:43 <isBEKaml_> I'm trying to install `turtle`. I do the cabal update and it now gives me this weird error
23:21:44 <randomclown> shachaf: is it me or can you stack either way
23:21:46 <isBEKaml_> https://gist.github.com/anonymous/38d270d2cbf04a7c41f9
23:22:21 <isBEKaml_> Even after doing a `cabal update` it still tells me that my package list is out of sync...
23:22:33 <mzero> strange....
23:22:47 <tempay> huh, so that doesn't hold quite the same information as Either a (Writer b c) right?
23:23:19 <shachaf> Why not?
23:23:20 <tempay> because with WriterT b (Either a) c, you can still get the written value if the either is Left
23:23:56 <tempay> or can't you? I guess I should play with it
23:24:08 <randomclown> No that only happens if you use EitherT on the outside
23:24:16 <glguy> Shachaf probably couldn't, at least
23:24:17 <mzero> do you want "either an error, or a written list of results"    =or=  "a written list of entries, each either a result or an error"  ?
23:24:35 <tempay> the former mzero
23:24:38 <randomclown> actually found a blog post
23:24:41 <randomclown> https://ro-che.info/articles/2012-01-02-composing-monads
23:24:44 <randomclown> about exactly this
23:25:04 <tempay> oh, sweet
23:25:05 <shachaf> glguy underestimates me again.
23:26:41 <tempay> thanks randomclown, that clears it up
23:26:46 <mzero> When thinking of monad composition, I think of       XxxT ... (YyyyT ...) a     as
23:27:02 <tempay> he says I should indeed use WriterT, and I won't still be able to get the log
23:27:10 <shachaf> mzero: I'm not sure that's an accurate description.
23:27:12 <mzero> "X operates oblivious to the fact that it is in an environment that does Y"
23:27:36 <mzero> shachaf:  I hadn't said it yet.
23:27:42 <mzero> how did you comment?
23:27:55 <shachaf> mzero: I'm talking about "a written list of entries"
23:28:11 <randomclown> when I wrote this monad transformer stack, only God and I knew what it did, now only God does.
23:28:18 <shachaf> The choice here is between Either e (w,a) and (w,Either e a)
23:28:25 <shachaf> The question is: When you look at do { tell [1]; left "oops"; tell [2] }, do you get a log of what happened before the failure? Or just a failure?
23:28:38 <mzero> shachaf: ah, yes, you are right
23:28:48 <isBEKaml> Anyone know about this problem? Is this a problem on the hackage server returning an outdated list? https://gist.github.com/anonymous/38d270d2cbf04a7c41f9
23:28:48 <mzero> OY - this is why I almost never ever use transformers
23:29:08 <mzero> for something like what randomclown is doing ... I just roll my own little monad
23:29:21 <randomclown> nah I use a global variable
23:29:21 <shachaf> Œª> runWriter . runEitherT $ do { tell [1]; left "oops"; tell [2] } -- (Left "oops",[1])
23:29:34 <tempay> that makes sense mzero, in this case the log writing is independent of failure
23:29:36 <shachaf> Œª> runWriterT $ do { tell [1]; lift $ Left "oops"; tell [2] } -- Left "oops"
23:29:42 <randomclown> isBEKaml: if it's windows I have no idea
23:30:01 <randomclown> did you update cabal first?
23:30:05 <isBEKaml> randomclown: yes, it's windows
23:30:19 <isBEKaml> randomclown: cabal is at v1.20
23:30:37 <randomclown> well the latest is 1.22.0 right
23:30:41 <randomclown> cabal install cabal-install
23:30:47 <randomclown> not that it matters
23:32:15 <isBEKaml> randomclown: I don't think it should matter. the issue is `cabal install` sees an outdated package list and asks me to do `cabal update`. When I do so, hackage server still sends me an outdated list and now I can't install a new package that was uploaded recently
23:32:37 <randomclown> install wireshark and see if you are in fact, getting an outdated package list
23:34:41 <mzero> isBEKaml: why not just delete the 00-index* files in the .cabal dir (or the windows equiv.) and thereby
23:34:50 <mzero> force a download on the next cabal update?
23:34:51 <randomclown> ayy that too
23:36:44 <isBEKaml> randomclown: here's the output from `cabal update -v3` (Not that it's useful)
23:36:53 <isBEKaml> https://gist.github.com/anonymous/f18bea12202c5ae4f38e
23:37:02 <randomclown> I think deleting the index files is probably more helpful
23:37:14 <isBEKaml> the weird part is this: Skipping download: Local and remote files match.
23:37:24 <isBEKaml> mzero: cool, I'm doing that
23:38:01 <isBEKaml> randomclown: yes, I'm running it now
23:39:54 <EvanR> i want to make bindings to a C lib, whats the latest greatest thing for that, or whats recommended
23:41:32 <mzero> FFI is your friend
23:41:51 <mzero> by hand? or did you want to do something automated?
23:41:53 <EvanR> right, but what of all these macros and template haskells and bindings-common
23:42:10 <mzero> dunno - never use 'em!
23:42:11 <EvanR> by hand is fine with me, unless its really dumb
23:42:26 <mzero> no, I see people do it all the time
23:43:06 <EvanR> whats an example bindings i can look at that doesnt use all these things
23:48:49 <mzero> EvanR: perhaps HSCurses
23:51:54 <EvanR> urg the cookbook mentions DLLs
23:52:14 <EvanR> will the bindings work on windows, who knows
23:52:29 * EvanR sheds a tear for windows users
