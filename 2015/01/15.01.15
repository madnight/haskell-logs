00:00:30 <glguy> Probably
00:00:46 <Lokathor> then i shal attempt it
00:01:11 <glguy> Github.com/glguy/GhcPkgUtils
00:01:31 <glguy> You can run it with the argument multiversion
00:01:39 <Lokathor> on this machine i'm using for the bot i installed ghc from the debian repo, installed hscurses globally, and then installed ircbot and all it depended on via user-level cabal install
00:02:08 <glguy> To see what is duplicated and then use its unregister command to recursively unregister things
00:02:33 <glguy> You should do all Debian repo or all hackage
00:02:43 <glguy> Mix and match doesn't go well
00:03:19 <Lokathor> true... i wasn't sure how to get ghc and cabal to begin with if not from the repo though
00:03:26 <glguy> You can do it if you understand exactly what you're doing but it's trickier
00:03:42 <Lokathor> after the initial repo install, all the rest was via cabal/hackage
00:04:06 <glguy> Getting just GHC from the repo isn't as bad
00:04:29 <Lokathor> so for your thing, do i run setup or make?
00:04:44 <LordBrain> ghc on wheezy is old tho
00:04:55 <glguy> It's cabal driven
00:05:17 <Lokathor> ghc on wheezy is so old that the cabal that goes with it doesn't support sandboxing
00:06:05 <kazagistar> damn thats old
00:06:29 <Lokathor> debian is serious about stability, they are always very slow to move forward with versions
00:07:11 <Lokathor> glguy: it says there's a dependency missing situation.
00:08:02 <Lokathor> I'm not sure what to do because cabal always manages to do it automatically if there's no C files missing
00:10:46 * hackagebot warp-tls 3.0.1.3 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-3.0.1.3 (MichaelSnoyman)
00:10:46 * hackagebot wai-app-static 3.0.0.6 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-3.0.0.6 (MichaelSnoyman)
00:30:39 <fread2282> how can I do a reverse traversal starting from a point of a graph (I'm using Data.Graph currently) such that the "children" of a node come before that node
00:32:22 <fread2282> view it as a tree from a point, give me the farthest out children first such that I get all the nodes a given node points to before that node
00:33:00 <fread2282> and error on cycles, but that's easy
00:34:13 <fread2282> or if there's an easier way to convert a where block to single lets
00:35:04 <ab9rf> isn't that just computing a spanning tree, then traversing it, using left-right-root order on the traverse?
00:35:18 <ab9rf> (or right-left-root, if you feel british)
00:35:30 <fread2282> yep
00:35:37 <ab9rf> there ya go :)
00:35:55 <ab9rf> problem reduced to previously solved problems :)
00:36:44 <fread2282> will that always start from my origin?
00:37:10 <ab9rf> some spanning tree algorithms allow you to specify a starting node, iirc
00:42:03 <vanila> "Let us assume the programming language market is effective and free. In this case, the best programming languages are the most popular ones: PHP, Javascript, Java, C#, C, C++ and so on."
00:42:36 <opqdonut> it's just a matter of the definition of "best"
00:49:18 <ab9rf> heh
00:58:05 <aloiscochard> I'm wondering, is it generally considered okay to use the extension `MultiParamTypeClasses` or should I favor type families?
00:58:22 <merijn> aloiscochard: I would say that those two share very little overlap
00:58:48 <aloiscochard> yeah indeed, I have really a use case for the former, but having used the later I can see where there is some little overlap
00:59:14 <merijn> It's more type families and fundeps that share a common usecase
00:59:17 <aloiscochard> merijn: I suppose my question is, is it considered harmful (MPTC)? because I heard bad things about fundep so I stayed away of it
00:59:26 <aloiscochard> oh right
00:59:27 <merijn> Personally I find type families easier to work with than fundeps
00:59:35 <merijn> But fundeps occasionally infer better
01:00:07 <aloiscochard> good to know, ty merijn
01:00:11 <merijn> So if you want use type inference, fundeps might be better. But if, like me, you don't care since you write type signatures anyway type families (or rather, associated types in this case) may be easier
01:00:58 <merijn> fundeps aren't bad, so I'm curious where you heard bad things about it
01:01:03 <aloiscochard> yeah, usually when I do this kind of things, I'm fine writing the type aescriptions
01:01:12 <aloiscochard> mmm... good question, let me try to find a ref if I can
01:01:34 <shachaf> merijn: Where do fundeps infer better?
01:01:51 <merijn> shachaf: I have no idea, I'm blindly repeating what carter told me at some point
01:02:11 <merijn> (When I asked him why he was using fundeps over typefamilies)
01:02:28 <shachaf> I think you should be able to emulate just about any use of fundeps these days?
01:02:38 <shachaf> I'd like to see some concrete cases.
01:02:47 <merijn> That's what *I* think, hence I always try type families first :)
01:02:54 <merijn> I find it much more intuitive to reason about
01:04:09 <shachaf> Is there a case where you tried type families first and failed?
01:04:27 <shachaf> (I think fundeps can certainly be clearer than type families in some cases.)
01:10:35 <dmwit> The typechecking-linear-types-in-GHC paper discusses a use of fundeps where type families don't cut it, I think.
01:10:55 <dmwit> "Typechecking Linear Data: Quantum Computation in Haskell", pdf here:
01:11:01 <dmwit> http://www.monoidal.net/papers/qhaskell.pdf
01:11:47 <dmwit> Though the discussion of why is quite short (just two sentences in section 9.3).
01:15:30 <merijn> shachaf: No, but tbh some of the stuff carter is doing is a lot more intricate than the most complex TF thing I've done. Additionally, I don't actually really use type inferencce all that much
01:16:00 <merijn> Because, frankly, I feel type inference just isn't that valuable
01:16:10 <sinelaw> *gasp*
01:16:33 * sinelaw pours a cold bucket of water over merijn 
01:16:36 <zwer> merijn top-evel type inference or in general?
01:16:53 <merijn> zwer: I've started annotating most of my local let/where definitions too
01:17:20 <merijn> zwer: Because I like being able to instantly glance at a value's type while coding
01:17:31 <merijn> And it's a good sanity check
01:17:52 <ab9rf> i often do the same
01:18:06 <merijn> I mean, I can understand why people want type inference in C++, having the ability to use "auto" over a 30 line type signature makes a lot of sense there
01:18:13 <ab9rf> if you don't annotate something and you're wrong abot it, sometimes the error you end up getting is incmprehensibly weird
01:18:17 <merijn> But most haskell types are so short that writing them isn't a hassle
01:18:29 <tasker> Could anyone point me towards an algorithm for finding all local maxima in a 1d array? I'm sure I could come up with something, but I've no doubt some good solutions already exist.
01:18:32 <merijn> And the ones that *aren't* so short, are the ones you really should write out anyway
01:18:47 <sinelaw> merijn, that's because text-based programming sucks. if your IDE would show your types as you go, you wouldn't need to annotate manually, and type inference will be useful
01:18:56 <merijn> sinelaw: Not really
01:18:58 <shachaf> I would suspect that there are a bunch of cases of type inference that you might not really think about until they were gone.
01:19:13 <merijn> shachaf: Sure, I'm not saying it should go completely
01:19:32 <merijn> Just that, given the choice between RankNTypes and inference I'd rather get the RankNTypes :)
01:19:45 <sinelaw> merijn, you said you like the ability to instantly glance at a value's type. the IDE can give you that feature
01:19:48 <Axman6> having an IDE do it for you requires some action from you, unless it'd going to show every single type; writing the types is 'glancable'
01:20:06 <merijn> sinelaw: Type inference is undecidable using RankNTypes
01:20:21 <sinelaw> merijn, I know, but you were complaining about something else
01:20:21 <merijn> sinelaw: Also, that doesn't provide the sanity checking
01:20:44 <ab9rf> it tells yuou what hte IDE thinks the type is, not what you think it is
01:20:47 <ab9rf> ;)
01:20:58 <Axman6> indeed
01:21:06 <Axman6> that is sometimes quite an important distinction
01:21:07 <merijn> shachaf: Anyway, I'm okay with "best effort" inference, I just don't feel total inference is necessary
01:22:25 <dmwit> tasker: zipWith3 (\x y z -> [y | x < y && z < y]) xs (drop 1 xs) (drop 2 xs)
01:23:09 <dmwit> tasker: With a bit of work you can probably make it twice as fast if it turns out to be a bottleneck.
01:35:51 <sgronblo> dmwit: is that basically a single element list comprehension in there?
01:37:01 <tasker> dmwit: Ah, thanks. I guess this won't be able to tell if either end are local maxes, though ?
01:37:22 <dmwit> tasker: correct
01:37:28 <dmwit> sgronblo: correct
01:37:39 <tasker> dmwit: I can add something to deal with that as necessary. Cheers!
01:40:39 <sgronblo> the ends would depend on your definition of local max wouldnt they?
01:41:34 <slomo> i have a question about the performance of (++) and thus concat :) intuitively it would have to copy its first argument to be able to append the second argument, but can that be prevented with lazyness and list fusion? e.g. if i have a completely unevaluated thunk like (1:2:3:[]) ++ (4:5:6:[]) and foldr (:) that, will it just linearly consume the elements until the (++), then evaluate (++) with an empty list as first argument (thus no list to copy), the
01:41:34 <slomo> n consume the remaining elements?
01:42:29 <shachaf> slomo: I'm not sure I follow your question.
01:42:41 <shachaf> What does foldr (:) have to do with it?
01:43:24 <slomo> shachaf: just an example, alternatively use sum or anything else that consumes the list
01:43:26 <Axman6> I would guess the answer is "no" though
01:43:43 <Axman6> foldr is a bit special when it comes to consuming a list
01:43:57 <Axman6> (or, possibly, the opposite of special)
01:44:21 <shachaf> OK, so you're just asking what will happen when you look at that list?
01:44:34 <slomo> yes
01:44:47 <shachaf> I'm not sure which question Axman6 is answering with "no", but it sounds like your description is accurate.
01:45:01 <opqdonut> slomo: see also difference lists, in case you aren't familiar with them yet
01:45:31 <shachaf> If you have xs = 1:2:[] and ys = 3:4:[], and zs = xs ++ ys, then zs = 1:2:ys
01:45:46 <shachaf> So the [3,4] will be shared and the 1:2: will be copied.
01:45:59 <shachaf> (Well, only the (:)s will be copied, not the actual Ints or whatever you have in the list.)
01:47:21 <slomo> what if i have xs=1:2:[], ys=3:4:[] and zs=5:6:[] and (xs ++ ys ++ zs)? will xs be copied twice (once for appending ys, once for append zs to (xs ++ ys))?
01:47:35 <ab9rf> why would it do that?
01:47:45 <shachaf> To be clear, ++ is infixr, so that's (xs ++ (ys ++ zs))
01:47:52 <opqdonut> slomo: it will get copied twice if you do ((xs ++ ys) ++ zs)
01:47:54 <dmwit> slomo: No, but in ((xs ++ ys) ++ zs) xs will indeed be copied twice.
01:48:02 <shachaf> If it was infixl, ((xs ++ ys) ++ zs), then it would behave as you described.
01:48:14 <slomo> ah, makes sense
01:48:15 <slomo> thanks
01:49:07 <slomo> opqdonut: i read about them some time ago, and they seem relevant to this question, yes. but i'm just curious how exactly it behaves on normal lists :)
01:49:13 <sgronblo> Wouldn't it be possible to add (++) (or something similar) as a new constructor for lists? So that instead of copying the (:)s you would get some tree like structure representing the concatenated list?
01:49:57 <Axman6> that's similar to a rope data structure, so sure it's possible
01:49:58 <shachaf> Yes, you can do that, but then it's not associative unless you hide the structure.
01:50:17 <shachaf> But even then your tree won't usually end up balanced unless you do clever things.
01:50:19 <LordBrain> @src (++)
01:50:19 <lambdabot> []     ++ ys = ys
01:50:19 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
01:50:19 <lambdabot> -- OR
01:50:19 <lambdabot> xs ++ ys = foldr (:) ys xs
01:51:00 <sgronblo> rope?
01:51:16 <Axman6> a fatter string =)
01:51:51 <shachaf> sgronblo: But there are lots of data structure that do things to be able to support different operations efficiently.
01:51:53 <sgronblo> oh
01:52:00 <ab9rf> the chief defect of henry king
01:52:07 <Axman6> usually a tree of strings (where strings are often contiguous chunks of memory rather than things like the haskell String)
01:52:13 <shachaf> Linked lists make some pretty specific choices for what should be easy and hard.
01:52:24 <sgronblo> shachaf: I know, I just didnt remember seeing this Rope/ConcatList anywhere before.
01:52:25 <Axman6> http://en.wikipedia.org/wiki/Rope_(data_structure)
01:53:52 <sgronblo> it seems the rope idea is not generic though
01:54:01 <sgronblo> leaves are strings
01:54:06 <Axman6> what do you mean?
01:54:18 <sgronblo> instead of Rope a
01:54:49 <Axman6> data Rope a = Node Int (Rope a) (Rope a) | Leaf (Vector a) | Empty
01:55:01 <Axman6> a "rope" of any type
01:55:23 <Axman6> that's just one possible implrementation
01:55:25 <ab9rf> yeah, nothing forces a rope to have character vectors at its leaves
01:55:50 <sgronblo> the wikipedia article and the name being some sort of pun on string seems to indicate thats what its "aimed" for
01:56:40 <Axman6> that's likely only because that's what they were initially intended for, but they are a pretty generic idea
01:57:17 <sgronblo> yeah i was just wondering if there was some other name for the generic version
01:57:44 <Axman6> probably =)
01:58:05 <therp> is there a way to import a module from a specfic package version? I have a dependency requiring StdGen from "random-1.0.1.1:System.Random" while my system default is random-1.1
01:58:24 <therp> import random-1.0.1.1:System.Random would be nice
01:58:47 <Axman6> import "random-1.1" is (I think) the syntax you're after =)
01:59:04 <Axman6> import "random-1.1" System.Random (obviously)
01:59:27 <Axman6> can't remember the name of the extension though
01:59:41 <therp> Axman6: thanks! that's "PackageImports"
01:59:52 <Axman6> yes, that's the one
02:01:37 <sgronblo> is this the same thing as we are talking about? https://hackage.haskell.org/package/rope it also seems to refer to bytestring?
02:02:31 <sgronblo> also i was wondering is it possible to use type families or something for a case where you would have a rope where you could define the whole contained type of the lists or just the element type of the elements.
02:05:04 <Axman6> sure. I think similar ideas are used for (one of?) the ListLike class
02:05:08 <Axman6> @hoogle ListLike
02:05:10 <lambdabot> package ListLike
02:05:11 <lambdabot> package listlike-instances
02:05:11 <lambdabot> package process-listlike
02:05:31 <aloiscochard> merijn: "shachaf> I think you should be able to emulate just about any use of fundeps" <-- I think that's why I had in mind to avoid it
02:05:35 <aloiscochard> not necessarly bad
02:05:37 <aloiscochard> per se
02:07:37 <merijn> sgronblo: Not quite sure exactly what you mean, but maybe this is relevant? Heterogeneous list: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
02:07:51 <merijn> sgronblo: You could make the type level encoding arbitrarily complex using type families
02:08:23 <merijn> sgronblo: So, I'm pretty sure you can make any arbitrary heterogeneous structure using type families
02:11:48 <tdammers> awwwwww yiss
02:11:52 <tdammers> stuff compiles
02:12:07 <tdammers> turns out ScopedTypeVariables is what I want
02:17:33 <steffen> is there a way to transform a monadic function a -> m b into one like this: Maybe a -> m (Maybe b) ?
02:18:03 <Axman6> is this a homework question? I've seen someone else asking the same question in the last week
02:18:11 <steffen> haha no it is not
02:18:30 <merijn> Axman6: To be fair, it is both a common thing to want and not immediately obvious to a beginner
02:18:32 <ab9rf> that's just mapM :)
02:18:40 <merijn> :t T.mapM
02:18:41 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
02:18:44 <Axman6> ok. well, try by writing a simpler version to begin with: (a -> b) -> Maybe a -> Maybe b
02:18:45 <merijn> actually
02:18:48 <merijn> It's forM
02:18:56 <merijn> :t T.forM
02:18:57 <lambdabot> (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
02:18:58 <ab9rf> fine, be picky :)
02:18:59 <steffen> xD Thanks a lot
02:19:04 <jle`> traverse works too
02:19:07 <vanila> :t mapM
02:19:08 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
02:19:09 <jle`> if your monad is Applicative
02:19:10 <ab9rf> @hoogle (a -> m b) -> (m1 a) -> (m (m1 b))
02:19:10 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
02:19:10 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
02:19:10 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
02:19:22 <vanila> isn't it fmapM?
02:19:36 <merijn> vanila: That doesn't exist
02:19:46 <merijn> You just need mapM/forM from Data.Traversable
02:19:50 <jle`> :t traverse :: Applicative f => (a -> f b) -> (Maybe a -> f (Maybe b))
02:19:51 <lambdabot> Applicative f => (a -> f b) -> Maybe a -> f (Maybe b)
02:20:25 <vanila> :t \m -> do r <- m ; fmap r
02:20:25 <lambdabot> Functor f => (f a -> a -> b) -> f a -> f b
02:20:36 <vanila> :t \f m -> do r <- m ; fmap f r
02:20:36 <lambdabot> (Functor m, Monad m) => (a -> b) -> m (m a) -> m b
02:21:43 <jle`> steffen: btw, the general pattern that helps me see it here is that when you try to fmap that onto Maybe, you get Maybe (m b)
02:21:44 <merijn> Actually, I take it back
02:21:52 <jle`> fmap your (a -> m b) into Maybe a, you get Maybe (m b)
02:21:54 <merijn> It's not mapM
02:22:11 <merijn> :t T.sequence
02:22:12 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
02:22:16 <jle`> and now you want Maybe (m b) -> m (Maybe b)
02:22:23 <merijn> It's "T.sequence . fmap f"
02:22:25 <jle`> and *that* is something distinctly Traverable
02:22:35 <shachaf> merijn: That's what mapM is.
02:22:40 <merijn> oh, wait
02:22:42 <merijn> I'm an idiot
02:22:42 <Axman6> :t traverse
02:22:43 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
02:22:44 <ab9rf> heh
02:22:46 <jle`> :t [\f -> T.sequence . map f, traverse]
02:22:47 <lambdabot> (Applicative m, Monad m) => [(a1 -> m a) -> [a1] -> m [a]]
02:22:53 <jle`> :t [\f -> T.sequence . map f, traverse, mapM]
02:22:54 <lambdabot> (Applicative m, Monad m) => [(a1 -> m a) -> [a1] -> m [a]]
02:23:06 <jle`> oh
02:23:07 <t4nk358> Hi I am unable to install the gtk2hs library with the instructions metinoed in the Hackage page. Please help
02:23:09 <jle`> :t [\f -> T.sequence . fmap f, traverse, mapM]
02:23:09 <lambdabot> (Applicative m, Monad m) => [(a1 -> m a) -> [a1] -> m [a]]
02:23:11 <jle`> there
02:23:17 <jle`> um you get the picture
02:23:29 <jle`> :t [\f -> T.sequence . fmap f, traverse, T.mapM]
02:23:30 <lambdabot> (Traversable t, Applicative m, Monad m) => [(a1 -> m a) -> t a1 -> m (t a)]
02:23:34 <shachaf> I often feel like this channel would be better without lambdabot.
02:23:46 <ab9rf> heh
02:24:01 <t4nk358> Hi I am unable to install the gtk2hs library with the instructions metinoed in the Hackage page. Please help
02:24:03 <shachaf> It would be painful while people learned to communicate by talking to each other rather than saying vaguely-related things to the robot, but they'd get used to it.
02:24:06 <steffen> Thank all you guys, Im palying with it
02:24:39 <jle`> steffen: so yeah, the general pattern is that when you have something like Maybe (m a) and you want to "pull out the m" and keep the context, and get m (Maybe a), that's a sure flag for Traversable
02:24:53 <jle`> for example, [m a] -> m [a]
02:25:04 <jle`> Map k (m a) -> m (Map k a)
02:25:14 <t4nk358> @ jle : I am unable to install the gtk2hs library with the instructions metinoed in the Hackage page. Please help
02:25:31 <steffen> jle`: Thanks
02:25:32 <ab9rf> please state the nature of the unable-to-install emergency
02:26:41 <Axman6> t4nk358: no one can help you if you don't say what's wrong. also just saying "Please help" is a surefire way to rub people the wrong way
02:26:42 <jle`> steffen: i think Map k (m a) -> m (Map k a) really illustrates best to me the power of Traversable...it sequences together every contained `m a`, and in the end returns a map of all of the results, still intact to their corresponding original key
02:26:55 <t4nk358> @ab9rf : lol , the error Configuring cairo-0.13.0.6...
02:26:55 <lambdabot> Unknown command, try @list
02:27:13 <t4nk358> gio-0.13.0.4 depends on glib-0.13.0.7 which failed to install.
02:27:18 <ab9rf> t4nk358: put the error message(s) intoa pastebin and give us the link
02:27:29 <Axman6> @where lpaste
02:27:29 <lambdabot> http://lpaste.net/
02:27:49 <jle`> steffen: another commonly related pattern is Maybe (m a) -> m ()
02:28:02 <jle`> Map k (m a) -> m ()
02:28:12 <jle`> that's Foldable
02:28:38 <t4nk358> <ab9rf> I cannot access paste bin from my office computer!. I shall paste the error here line by line
02:28:48 <ab9rf> t4nk358: please do not do that
02:28:59 <steffen> jle`: okay, I'll try to remember it :)
02:29:23 <jle`> [m a] -> m () .... sequence all of the contained `m a`'s together.  heh, sorry if this is going beyond the original question...just pointing out some general patterns that problems like these fall under and signs for which tool :)
02:29:29 <t4nk358> <ab9rf> How else can I get help on this?
02:29:45 <jle`> can you access lpaste?
02:29:57 <t4nk358> jle let me try
02:31:20 <t4nk358> jle`: I can access it
02:31:25 <vanila> :t \f x -> case x of Nothing -> return Nothing ; Just r -> fmap Just (f r)
02:31:26 <jle`> hooray
02:31:26 <lambdabot> (Functor m, Monad m) => (t -> m a) -> Maybe t -> m (Maybe a)
02:31:40 <t4nk358> Haha
02:31:45 <t4nk358> But how do I use it
02:31:47 <t4nk358> ?
02:32:06 <t4nk358> @Jle: How do I use it?
02:32:06 <lambdabot>  Parse failed: TemplateHaskell is not enabled
02:32:15 <Axman6> paste your code into it, submit it, and paste the url here
02:32:15 <jle`> there are some instructions on the page :) and then press the "public" button
02:32:19 <ab9rf> hah
02:32:35 <t4nk358> ok
02:32:52 <jle`> enter your error into the text box
02:33:13 <t4nk358> @ jle : http://lpaste.net/118480 woohoo
02:33:23 <jle`> oh don't ask me, i literally don't know anything about this
02:33:30 <jle`> oh and they're gone
02:33:51 <Axman6> -_-
02:34:08 <ab9rf> heh
02:34:11 <Axman6> well, it looks like they need to install glib
02:34:38 <ab9rf> yeah, they don't have the glib artifacts for msys installed
02:36:07 <abhi_> Hi please find my error here : http://lpaste.net/118481
02:36:21 <d3lxa_> anyone knows how to use Database.Datalog? I needs to create a DB of facts but I don't see how, these should be tuples or rows, anyidea?
02:36:21 <abhi_> Somebody pls help
02:36:51 <ab9rf> abhi_: you need to install glib (and probably also gtk, but we can't tell that from here)
02:37:32 <ab9rf> or there's a problem with your msys installation
02:37:34 <abhi_> @ab9rf : I did install each of the individual libraries even they fail :/
02:37:34 <lambdabot> Unknown command, try @list
02:37:51 <ab9rf> abhi_: this isn't twitter, please don't use @
02:37:57 <abhi_> Sure
02:37:59 <Axman6> abhi_: you need the C libraries for glib and gtk
02:38:21 <abhi_> Axman6_ COuld you please share the link
02:38:32 <ab9rf> i'm honestly not sure how you install glib for use with the msys instance that's imbedded within the haskell platform
02:38:38 <Axman6> what operating system are you using?
02:38:46 <ab9rf> Axman6: windows :)
02:38:48 <abhi_> windows 7
02:38:52 <Axman6> :(
02:39:01 <Axman6> I have no idea how or even if you can
02:39:02 <ab9rf> if it were linux this would be trivial
02:39:28 <ab9rf> Axman6: it's nontrivial, certainly not for the faint of heart.
02:39:42 <Axman6> nothing on windows is
02:39:54 <sopvop> Is it possible to compose pointfree function like [1,2,3,4,5] -> [(1,2), (3,4)] using only functions from base?
02:40:28 <ab9rf> the problem is that the haskell platform for windows ships with an embedded instance of the msys minimal build environment.  adding things to it is confusing/complicated
02:40:31 <abhi_> ab9rf_ Please help
02:40:50 <abhi_> How do I resolve it
02:40:50 <Axman6> :t zip `ap` drop 2
02:40:51 <lambdabot> [b] -> [(b, b)]
02:40:51 <ab9rf> abhi_: not within my competence.  i've tried to do this in the pst and had very poor luck
02:41:01 <Axman6> zip `ap` drop 2 $ [1..4]
02:41:02 <abhi_> :/
02:41:09 <Axman6> > zip `ap` drop 2 $ [1..4]
02:41:10 <lambdabot>  [(1,3),(2,4)]
02:41:18 <Axman6> huh, or not
02:41:46 <jle`> btw an operator form of `ap` already exists :)
02:42:16 <Saizan> > zip `ap` tail $ [1..5]
02:42:17 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
02:42:18 <Axman6> yeah, when ever I see that pattern I remember...
02:42:27 <Axman6> @quote zip.*ap.*tail
02:42:27 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
02:42:46 <abhi_> jle_ can you please help me with this http://lpaste.net/118481
02:42:57 <jle`> abhi_: sorry, i really don't know anything about it :(
02:43:04 <abhi_> :
02:43:06 <abhi_> (
02:43:38 <sopvop> Data.List needs something like `skip :: Int -> [a] -> [a]`
02:43:55 <alpounet> drop?
02:43:55 <ab9rf> sopvop: which does what?
02:43:56 <jle`> does it have chunksOf yet
02:44:03 <ab9rf> sopvop: every nth element?
02:44:06 <alpounet> ah
02:44:14 <sopvop> ab9rf: yes
02:44:29 <jle`> you can make one using zip and filter ;D
02:44:39 <sopvop> I did
02:44:46 <jle`> if this is the name of the game
02:44:53 <sopvop>  @pl splt xs = let nz = zip [1..] xs in zip (map snd . filter (odd.fst) nz)   (map snd . filter (even . fst) nz)
02:44:59 <sopvop> @pl splt xs = let nz = zip [1..] xs in zip (map snd . filter (odd.fst) nz)   (map snd . filter (even . fst) nz)
02:44:59 <lambdabot> splt = ap (zip . (map snd .) . filter (odd . fst)) ((map snd .) . filter (even . fst)) . fix . const . zip [1..]
02:45:35 <sopvop> :t ap (zip . (map snd .) . filter (odd . fst)) ((map snd .) . filter (even . fst)) . fix . const . zip [1..]
02:45:36 <lambdabot>     Couldn't match type ‘a0 -> [b0]’ with ‘[a]’
02:45:36 <lambdabot>     Expected type: (a0 -> [(a1, b0)]) -> [a]
02:45:36 <lambdabot>       Actual type: (a0 -> [(a1, b0)]) -> a0 -> [b0]
02:45:39 <sopvop> oh
02:45:47 <Axman6> abhi_: https://www.haskell.org/haskellwiki/Gtk2Hs/Installation
02:46:32 <abhi_> axman6_ I tried it from there
02:46:38 <abhi_> does not help
02:47:15 <jle`> > map snd . filter (odd . fst) . zip [1..] . (zip <*> tail) $ [1..11]
02:47:16 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
02:48:49 <ab9rf> > ((map head .) . chunksOf) 10 [0..]
02:48:50 <lambdabot>  [0,10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,21...
02:48:53 <sopvop> jle`: cool
02:55:48 * hackagebot idris 0.9.16 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.16 (EdwinBrady)
03:07:28 <torpet> why is foldl of type
03:07:30 <torpet> :t foldl
03:07:31 <lambdabot> (b -> a -> b) -> b -> [a] -> b
03:07:49 <torpet> and not of type (a -> a -> a) -> a -> [a] -> a
03:08:29 <notdan> torpet: because the first type signiture is more general
03:09:32 <Axman6> you can do more with the former than the latter
03:10:20 <Axman6> > foldl (\b a -> show a ++ b) "" [1..5]
03:10:21 <lambdabot>  "54321"
03:10:56 <Axman6> you couldn't do that if all the parameters had to be of the same type
03:11:47 <torpet> ahhh ok thank you
03:25:49 * hackagebot reverse-geocoding 0.1.0.0 - Simple reverse geocoding using OpenStreeMap  http://hackage.haskell.org/package/reverse-geocoding-0.1.0.0 (jcristovao)
03:40:31 <qz> hello... i need to keep a large set of md5 hashes in memory and be able to do fast lookups, what collection is best for that? i tried Data.Set, its kinda ok, but it consumes 3x more memory and inserts run twice as slow as dumb ruby implementation
03:41:51 <Axman6> how are your hashes represented? ByteStrings?
03:42:16 <qz> yeah, strict bytestrings
03:43:26 <Axman6> some form of trie might be useful; perhaps an IntSet (Set ByteString) where the Int key of the IntSet is the first say 24 bits of the hash
03:44:08 <Axman6> and the Sets hold the last <length MD5 - 3) bytes of the ByteString
03:44:57 <qz> Axman6: that could speed up lookups, but i'm not even at that point. reading/building set is slower and uses way more memory than reference ruby script i hacked up in 3 minutes :(
03:46:48 <Axman6> perhaps https://hackage.haskell.org/package/bytestring-trie ?
03:47:07 <Axman6> also, maybe unordered-containers
03:48:11 <Axman6> @hackage unordered-containers -- to ease finding it
03:48:11 <lambdabot> http://hackage.haskell.org/package/unordered-containers -- to ease finding it
03:55:44 <qz> Axman6: replaced Data.Set with Data.HashSet and now inserts run 10 times slower. i must be doing something wrong
03:56:08 <Axman6> that's from unordered-containers?
03:56:25 <Axman6> feel free to share your code btw =)
03:58:34 <qz> http://lpaste.net/118486
03:59:31 <qz> yeah, even lpaste complains about my code :p
04:00:39 <Axman6> are you sure it's the  Set that's the problem or is it the md5 code?
04:02:07 <qz> Axman6: well, i didnt change anything related to md5, but after switching to unordered-containers inserts run like 10 times slower
04:02:25 <Axman6> without profiling the code, it will be difficult to figure out where the bottlenecks are
04:02:41 <bambooo> I made a program through OpenGL bindings, and i have IORef Integers that are +1'd each frame, but it seemingly grows differently on Windows and Linux.
04:05:03 <pavonia> bambooo: Diffferent speed or different values?
04:05:18 <qz> Axman6: well, replacing HashSet with Set speeds it up, so it must be HashSet
04:05:51 * hackagebot reverse-geocoding 0.1.0.1 - Simple reverse geocoding using OpenStreeMap  http://hackage.haskell.org/package/reverse-geocoding-0.1.0.1 (jcristovao)
04:12:33 <bambooo> pavonia, not sure how would i check that, i just know that if i set a chaging IORef as square size, then the squares would grow with different speeds, depending on OS, or maybe it's because of different OpenGL version.
04:14:06 <pavonia> How do you set the interval between two frames?
04:18:00 <bambooo> I haven't set that, it's whatever the default is. I think this might be happening, because of differences in OpenGL versions interpreting DoubleBuffer... maybe
04:21:29 <dav1d> what's the difference between (\x y -> x + y) and (\x -> \y -> x + y)?
04:21:39 <Iceland_jack> none
04:21:43 <dav1d> ty
04:21:55 <Axman6> (in theory)
04:22:06 <Axman6> GHC might optimise them differently though
04:22:12 <Athas> Does it, though?
04:22:18 <Iceland_jack> (Yes, apart from some details that you probably don't care about now)
04:22:32 <Iceland_jack> Athas: Yes, it has to do with inlining
04:23:00 <Axman6> sometimes it's important to write functions as foo a b = \c -> ...
04:23:08 <Iceland_jack> Athas: GHC only inlines fully-applied functions
04:23:41 <jle`> dav1d: you could say that the former is syntactic sugar for the latter
04:23:43 <Iceland_jack> So semantically the two are the same:
04:23:43 <Iceland_jack>     foo a b c = ...
04:23:43 <Iceland_jack>     foo a b   = \c -> ...
04:24:03 <Iceland_jack> but it can matter in terms of optimisation
04:24:30 <dav1d> alright thanks
04:25:09 <Axman6> between a b c = a <= c && c <= b might be more efficient if you use between a b = \c -> .. for example
04:25:11 <Axman6> (I think)
04:25:19 <Axman6> uh, less efficient
04:25:31 <jle`> only one way to find out
04:25:48 <jle`> :D
04:25:54 <Axman6> (get someone else to) use criterion!
04:26:02 <Iceland_jack> CaaS
04:35:52 * hackagebot uuagc 0.9.52.1 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.52.1 (JeroenBransen)
04:40:52 * hackagebot containers 0.5.6.3 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.5.6.3 (MilanStraka)
04:45:17 <zzing> Its been about 2.5 years since I last tried doing haskell web development. I am curious if much has changed in that time.
04:45:36 <tdammers> zzing: stuff has matured
04:46:03 <zzing> tdammers, any particular way?
04:52:01 <tdammers> zzing: yesod has made leaps
04:52:11 <tdammers> zzing: not sure if scotty was around 2.5 years ago
04:52:16 <zzing> it was
04:52:19 <tdammers> ah
04:52:37 <tdammers> then I don't think things have changed radically
04:52:48 <zzing> The main three that I remember were happstack, snap, and yesod.  (and also the bots that are in those channels about to tell them about the mention)
04:54:03 <tdammers> happstack, haven't seen that mentioned a lot lately
04:54:45 <zzing> last release 6 months ago
04:55:08 <bernalex> how old is scotty? scotty is awesome at least
04:55:35 <bernalex> persistent is better. there's esqueleto and opaleye. there's rest-haskell or something (haven't used it myself). etc.
04:55:50 <MasseR> And the new servant
04:56:11 <zzing> scotty: Thu Jan 5 20:43:30 UTC 2012    uploaded to hackage
04:56:26 <zzing> What is awesome about scotty?
04:56:58 <bernalex> minimalistic, fast, just works. doesn't get in the way. has enough abstractions to get stuff done efficiently.
04:57:06 <frawgie_> it is fairly easy to get started imo, it is similar to e.g. Flask in Python.
04:57:09 <bernalex> perfect if you need/want to do most things yourself
04:57:20 <frawgie_> it is up to you to judge if the latter is good or not :)
04:57:22 <bernalex> or sinatra in Ruby, which is what it is based on.
04:57:40 <frawgie_> bernalex: thats right, since thats where flask got its inspiration too :)
04:58:06 <zzing> I like the idea of the minimal ones, I have used (briefly) spark in java; but now working primarily with spring boot. Nothing major mind you.
04:58:58 <zzing> How about apiary?
04:59:32 <tdammers> bernalex: I've come to the point where I consider both scotty and flask too heavyweight for my own work :x
04:59:55 <bernalex> tdammers: I don't think scotty is heavy if you only use the useful bits
05:00:16 <tdammers> oh, I didn't mean the performance or anything
05:00:41 <bernalex> me neither
05:00:45 <tdammers> more like how you can't have routes within routes
05:00:47 <bernalex> I'm an academic, what's a performance? ;-)
05:01:00 <tdammers> that is a needlessly restrictive design decision I'd say
05:01:38 <kakaeu> hey people, there is no mature & efficient scientific/numeric package for Haskell?
05:01:44 <RchrdB> bernalex: it's that thing where sometimes you just press the enter key and the answer appears, sometimes you go make coffee and then the answer is there, sometimes you have to go asking for funding to buy a very large computer. :)
05:02:09 <zzing> RchrdB, we just send it off to sharknet.
05:02:36 <RchrdB> What's sharknet?
05:02:51 <bernalex> RchrdB: oh you mean coffee breaks? that's a nice thing to have!
05:02:56 <zzing> academic network in canada for research
05:03:30 <bernalex> I'm an academic in a commercial company, myself
05:03:49 <zzing> bernalex, sounds interesting
05:04:06 <bernalex> zzing: bit fewer papers to write :-P
05:04:09 <zzing> There is this templating language that I have used in java called Thymeleaf that just uses XML for templating. I rather like it and would love to use it with haskell.
05:04:17 <zzing> bernalex, papers please.!
05:04:28 <zzing> Sometimes I love papers, othertimes I hate them.
05:04:37 <tdammers> kakaeu: Data.Scientific?
05:04:50 <zzing> The shit papers that come out are always useless but cannot always figure it out at a glance.
05:04:59 <tdammers> kakaeu: http://hackage.haskell.org/package/scientific
05:05:03 <bernalex> zzing: writing a "we have an idea, it's a good idea, fund us please" paper right now actually!
05:05:10 <bernalex> and by writing, you know I mean not writing
05:06:19 <zzing> What is your area of research?
05:07:08 <bernalex> zzing: the idea we are presenting right now is a programming language for educational purposes.
05:08:00 <kakaeu> tdammers: I should have clarified, I need linear algebra functions (and matrix data)
05:08:01 <zzing> bernalex, what is the novel part? I always like programming languages :-)
05:08:31 <bernalex> zzing: progressively unlock features of the programming languages as you master it; so no more pedagogically unsound weird typeclass errors for a user writing
05:08:32 <bernalex> > abs -3
05:08:35 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
05:08:35 <lambdabot>    arising from a use of ‘M34055093103958106147085.show_M34055093103958106147...
05:08:35 <lambdabot>  The type variable ‘a0’ is ambiguous
05:08:57 <bernalex> but error messages that take into account that the user hasn't even heard about that stuff yet.
05:09:17 <zzing> I like the error message part, but doesn't racket already do that progressive part?
05:09:35 <bernalex> zzing: I don't know! let's have a look
05:10:00 <zzing> bernalex, by progressive I mean it has a few different levels of the main language that add features.
05:11:08 <Athas> zzing: yes it does.  It's a great idea.
05:11:43 <bernalex> mozart does it a bit too
05:12:02 <zzing> I am doing my masters right now, and I might even have come up with an idea that I could work on in information retrieval. For better or worst, I am thinking about implementing the starting IR system in haskell.
05:12:05 <bernalex> going to read a bit about racket now. thanks a lot for mentioning it!
05:12:24 <bernalex> most of my master thesis coding was in haskell too :-]
05:12:32 <zzing> no problem :P
05:13:12 <frawgie_> bernalex: dont forget to try it too :) it is a joy to use
05:14:03 <tdammers> I found racket rather confusing, compared to other schemes
05:14:07 <zzing> I just have to remember to get my chops on haskell up to snuff
05:16:44 <ClaudiusMaximus> @check \a b -> (a / b) * b == a
05:16:46 <lambdabot>  *** Failed! Falsifiable (after 1 test):
05:16:46 <lambdabot>  0.0 0.0
05:17:02 <ClaudiusMaximus> @check \a b -> b == 0 || (a / b) * b == a
05:17:04 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 2057 shrinks):
05:17:04 <lambdabot>  3.147898160437784e-308 5.8800445326753e-309
05:18:26 <bernalex> zzing: do you know any resources that detail their unlocking system?
05:18:49 <zzing> bernalex, you select the language you want to you. It is all manual
05:19:27 <zzing> The idea is that their tutorials and other material utilize certain things, so the languages are restricted in some manner. When you master those, you move up to more complete featureset.
05:19:53 <pavonia> > let a = 3.147898160437784e-308; b = 5.8800445326753e-309 in (a / b) * b
05:19:54 <lambdabot>  3.1478981604377836e-308
05:20:57 <bernalex> zzing: do you know any resource that details this? the ones I've found so far are more explaining the language features, so they don't mention this.
05:21:07 <ClaudiusMaximus> @check \a b -> isDenormalized a || isDenormalized b || b == 0 || (a / b) * b == a
05:21:09 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 1045 shrinks):
05:21:09 <lambdabot>  2.225078022899611e-308 1.1234344389165252
05:21:17 <zzing> bernalex, its been a while. Let me check.
05:21:37 <fatlazycat> hi anyone have a emacs config setup to use haskell mode with nix shell, do you need to just set haskell-process-wrapper-function ?
05:21:38 <bernalex> I guess http://docs.racket-lang.org/reference/running-sa.html#%28part._configure-runtime%29 might be relevant
05:25:02 <zzing> bernalex, teachpacks might also be helpful in understanding everything. http://docs.racket-lang.org/teachpack/index.html?q=   Unfortunately, I don't really know an academically valid source for all this.
05:25:18 <bernalex> zzing: thanks!
05:26:56 <zzing> np
05:30:57 <flaggy> Hello, I'm struggling with using random throughout my haskell code. Do you know of good examples of random generators being used? I think I will end up passing the generator around as function parameters and returns.
05:32:20 <zomg> you can use a reader monad to carry it around without having to stick it in parameters all the time
05:34:06 <flaggy> It would have to be a state monad, no? I have to use a generator then substitute it with a new generator afterwards
05:35:25 <zomg> oh that's true, yeah
05:38:00 <flaggy> yeah, I have been struggling with the state monad a bit. I wanted to see examples of people implementing this sort of thing. However, I'll keep on looking for the most suitable way for my program
05:38:04 <flaggy> thanks
05:41:05 <clrnd> flaggy, http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
05:41:10 <clrnd> that's a nice example
05:50:56 * hackagebot libsystemd-journal 1.3.1 - Haskell bindings to libsystemd-journal  http://hackage.haskell.org/package/libsystemd-journal-1.3.1 (OliverCharles)
05:56:21 <torpet> could someone give me a short crashcourse on (x1:x2:xs)?
05:56:31 <torpet> why does it not match (2:1:[])?
05:56:48 <bernalex> it does
05:57:12 <bernalex> @let crashcourse (x1:x2:xs) = print $ x1 ++ x2 ++ xs
05:57:12 <lambdabot>  .L.hs:164:52:
05:57:13 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
05:57:13 <lambdabot>      Expected type: [a]
05:57:39 <bernalex> uh
05:57:44 <bernalex> @let crashcourse (x1:x2:xs) = print $ x1 : x2 : xs
05:57:46 <lambdabot>  Defined.
05:58:02 <bernalex> crashcourse $ 2 : 1 : []
05:58:02 <benzrf> torpet: how is it not matching?
05:58:08 <bernalex> > crashcourse $ 2 : 1 : []
05:58:09 <vanila> torpet, it should match
05:58:10 <lambdabot>  <IO ()>
05:58:11 <jrancher> [1..10]
05:58:20 <bernalex> oh yeah print doesn't work in lambdabot derp
05:58:22 <vanila> > let (x1:x2:xs) = (2:1:[]) in x1
05:58:23 <vanila> > let (x1:x2:xs) = (2:1:[]) in x2
05:58:24 <lambdabot>  2
05:58:24 <lambdabot>  can't find file: L.hs
05:58:24 <vanila> > let (x1:x2:xs) = (2:1:[]) in xs
05:58:25 <lambdabot>  []
05:58:26 <bernalex> @let crashcourse (x1:x2:xs) = show $ x1 : x2 : xs
05:58:27 <lambdabot>  .L.hs:165:32:
05:58:27 <lambdabot>      Couldn't match type ‘[Char]’ with ‘IO ()’
05:58:27 <lambdabot>      Expected type: IO ()
05:58:33 <bernalex> ok too tired
05:58:34 <bernalex> lol
05:58:40 <bernalex> it matches though, as vanila demonstrated
05:58:44 <torpet> oh i misread the guard ...
05:58:48 <torpet> sorry it does indeed match
05:59:30 <gregnwosu> flaggy: learn you a haskell has a good bit on state and random
06:00:17 <lewton> are there any haskell libs for byzantine fault tolerance? i'm coming not coming up with anything
06:00:46 <Axman6> like paxos or something?
06:01:15 <dgpratt> looking at the source for Alex, Main.hs has a reference to module 'Paths_alex', which is auto-generated during the build; does anyone here know how that module gets generated?
06:01:40 <simukis_> by cabal.
06:01:58 <lewton> Axman6 yeah
06:02:34 <Axman6> googling for haskell paxos seems to turn up quite a few results
06:02:36 <dgpratt> simukis_, is it a specific function of cabal? do you know where I might find some explanation of it?
06:02:53 <lewton> ah thanks, i was looking for "byzantine" or bft
06:06:24 <haasn> What's a good haskell library for numerical integration?
06:06:46 <haasn> http://hackage.haskell.org/package/numeric-tools seems to do it
06:09:06 <SrPx_> does anyone know what this means? http://lpaste.net/118489
06:10:32 <shachaf> $ ghc -ignore-dot-ghci -XSafe Unsafe.hs -e "uc 'a' :: Int"
06:10:32 <shachaf> 97
06:17:25 <haasn> Hmm. Is there an easier to use package for guessing the local minima of an analytic function than https://hackage.haskell.org/package/nonlinear-optimization-0.3.7/docs/Numeric-Optimization-Algorithms-HagerZhang05.html ?
06:17:53 <haasn> I'm thinking of something like :: Double -> (Double -> Double) -> Double
06:17:57 <haasn> Where one parameter is an initial guess
06:18:19 <mmaroti2> Is it possible to create a named function f :: a -> b which behaves like regular functions but shows its name with "show f"?
06:19:33 <vanila> no
06:20:44 <alpounet> haasn: newton's method, from 'ad'? http://hackage.haskell.org/package/ad-4.2.1.1/docs/Numeric-AD-Rank1-Newton.html
06:21:03 <mmaroti2> vanila: no to the named function question?
06:21:08 <vanila> yeah
06:23:53 <mmaroti2> That is bad, but I guess it can be boxed with a data type which supports Applicative?
06:24:19 <Iceland_jack> Why is that bad mmaroti2?
06:25:52 <vanila> yes thats a good idea
06:26:07 <vanila> data NamedFunction a b = NamedFunction String (a -> b)
06:26:17 <haasn> alpounet: Hmm, doesn't work; my function is :: Double -> Double
06:26:23 <vanila> apply (NamedFunction _ f) x = f x
06:26:29 <haasn> I'm using numerical integration from numeric-tools, which is monomorphic
06:26:53 <haasn> Unless ‘ad’ can do integration as well
06:26:59 <mmaroti2> data Named a where NamedDat :: (Show a) => a -> Named a; NamedFun :: String -> (a -> b) -> Named (a -> b);
06:27:07 <vanila> no
06:28:23 <mmaroti2> you have to implement named values within the same data type otherwise you cannot do <*> right?
06:28:36 <vanila> dont use <*>
06:28:45 <Iceland_jack>     type Named a = (String, a)
06:28:45 <Iceland_jack>     apply = snd
06:28:45 <Iceland_jack> :)
06:28:54 <alpounet> haasn: i'm pretty sure you can decorate your function to become Forward Double -> Forward Double
06:28:58 <alpounet> using 'auto' and the likes
06:29:57 <alpounet> Forward has Num, Floating, etc instances
06:30:26 <mmaroti2> I want to work with named values throughout...
06:30:35 <haasn> alpounet: This is my function: “let bt2020 v | v < 0.08145 = v/4.5 | otherwise = ((v+0.0993)/1.0993)**(1/0.45); approx g v = v ** g; delta g v = abs (bt2020 v - approx g v); f = quadBestEst . quadRomberg defQuad (0,1) . delta”
06:30:42 <haasn> Does it have Ord instances?
06:30:51 <vanila> mmaroti2, what do you think of NamedFunction & apply that I wrote above?
06:30:57 <haasn> And what do I do about http://hackage.haskell.org/package/numeric-tools-0.2.0.1/docs/Numeric-Tools-Integration.html#v:quadRomberg ?
06:31:22 <alpounet> haasn: yeah, given a type that has Num and Ord, Forward a has Ord. see http://hackage.haskell.org/package/ad-4.2.1.1/docs/Numeric-AD-Rank1-Forward.html#t:Forward -- the instance list
06:31:44 <alpounet> let me see quadRomberg
06:33:14 <alpounet> haasn: it's a shame this package only provides monomorphic functions, that may make your life harder indeed
06:33:42 <mmaroti2> Can you curry and uncurry your NamedFunction?
06:33:47 <vanila> no
06:34:07 <mmaroti2> I think it will not work for me, but I am trying to see exactly what I need...
06:34:20 <vanila> alright, good idea to think more about the problem!
06:34:37 <alpounet> haasn: funnily enough, edwardk's https://hackage.haskell.org/package/integration-0.2.0.1/docs/Numeric-Integration-TanhSinh.html only works on Double's too =)
06:35:17 <haasn> I guess it's time to implement newton's method myself
06:35:57 <alpounet> you can borrow ad's computation of derivatives i guess though
06:37:35 <haasn> Probably faster to just apply it by hand, I would have gotten the precision down to like 5 digits by now if I just did that instead of trying in vain to find a module that does it
06:40:06 <haasn> There, done already. The local minimum of my function is approximately 1.9610336
06:40:55 <mmaroti2> I think your solution will work
06:42:03 <haasn> I'm curious why not simple :: Double -> (Double -> Double) -> Double function exists to do the same thing that I just did
06:42:12 <haasn> Keep plugging in better and better guesses
06:42:19 <haasn> while making the delta smaller and smaller
06:45:43 <alpounet> haasn: well, if you can get the derivative, you get better guesses much faster
06:45:52 <justicef_> so, I've been working with Rust, and it's moved me slowly over to be interested in Haskell.
06:53:05 <jophish> Is there something like this existing already? (a -> Maybe b) -> [a] -> ([a], [(a, b)])
06:53:30 <jophish> If a function returns Nothing the value is put into the first element of the tuple, otherwise it and it's result are put into the second?
06:55:31 <ab9rf> jophish: tuples are not an either-or sort of thing
06:55:46 <qz> can anyone help me with this one? http://lpaste.net/118496 -- somehow inserting into set while printing progress is a magnitude slower than just inserting. why's that?
06:55:53 <c_wraith> ab9rf: no, the question makes sense.  I think you may have misread it
06:55:53 <jophish> ab9rf: yes, I know that
06:56:05 <ab9rf> @hoogle (a -> Maybe b) -> [a] -> ([a], [(a,b)])
06:56:07 <lambdabot> No results found
06:56:17 <jophish> yeah, hoogle was the first thing I tried
06:56:29 <ab9rf> @hoogle (a -> Maybe b) -> a -> (a,b)
06:56:29 <lambdabot> No results found
06:56:54 <ab9rf> c_wraith: i see what he's trying to do now
06:56:57 <c_wraith> jophish: (a -> Maybe a) -> a -> [Either a (a, b)] would be potentially more useful.  (it preserves ordering)
06:57:03 <ab9rf> c_wraith: it's a partiton of the list into two lists
06:57:26 <SrPx_> does anyone have an idea what this ghcjs error means http://lpaste.net/118492
06:57:43 <jophish> c_wraith: I think you're right
06:58:17 <c_wraith> jophish: and I don't think there's anything to do that offhand.
06:58:34 <jophish> cool beans
06:58:47 <ab9rf> noithing obvious
06:59:17 <jophish> The higher level goal is to have a bunch of functions which consume some elements of a list and can't process others
06:59:37 <ab9rf> you can always use partitionEithers to change [Either a (a,b)] into ([a],[(a,b)])
06:59:47 <jophish> yup :)
07:04:53 <Yuras> @hoodle m (Maybe a) -> m b -> (a -> m b) -> m b
07:04:54 <lambdabot> No results found
07:05:00 <Yuras> :(
07:09:09 <merijn> qz: IO is really slow compared to other things, so inserting one message every insert is really slow
07:09:45 <merijn> oh, every 1000, still...
07:10:08 <merijn> I'm not really surprised by that behaviour
07:10:42 <merijn> Also, you use a strict fold for the non-IO insert, but your IO version is non-strict
07:12:58 <clrnd> is there a strict foldM?
07:13:57 <tasker> Is it possible to get Data.Map to have multiple keys pointing to the same value? Or does it have to be identical copies of that value ?
07:14:58 <Guest91343> > let ea = Right 4 :: Either String Int
07:14:59 <lambdabot>  not an expression: ‘let ea = Right 4 :: Either String Int’
07:15:10 <merijn> tasker: "Map key (Set value)"? :)
07:15:25 <merijn> oh, wait
07:15:26 <Guest91343> > ea = Right 4 :: Either String Int
07:15:28 <lambdabot>  <hint>:1:4: parse error on input ‘=’
07:15:32 <merijn> You wanted the reverse
07:15:42 <tasker> merijn: Yeah :s
07:15:47 <merijn> Guest91343: That's not valid syntax for lambdabot, you can't do definitions like that
07:16:09 <Guest91343> Ah. anyways I am trying to `traverse` Either String Int
07:16:14 <merijn> tasker: I'm not sure what "multiple keys pointing to the same value" means? What's wrong with just inserting the same value multiple times?
07:16:25 <merijn> :t traverse
07:16:26 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:16:50 <tasker> merijn: I suppose nothing, however I'm going to have to update that value, and it would be nicer if I didn't have to insert it over and over again
07:16:57 <merijn> :t traverse Identity
07:16:58 <lambdabot> Traversable t => t b -> Identity (t b)
07:17:14 <merijn> :t traverse Identity `asAppliedTo` (undefined :: Either String Int)
07:17:15 <lambdabot> Either String Int -> Identity (Either String Int)
07:17:29 <geekosaur> referential transparency...
07:17:35 <merijn> tasker: Insert an MVar/IORef?
07:18:15 <merijn> tasker: You don't want them pointing to the same value, you're asking to point them at the same "memory", which is not a sensible concept in Haskell
07:18:23 <merijn> (Except, when done explicitly using MVar/IORef)
07:18:40 <tasker> Hm, okay.
07:18:53 <tasker> I've not really thought through what I want to do yet, just trying to see what the options are.
07:18:55 <merijn> tasker: Remember, the Map is immutable
07:18:56 <dfeuer> @def lightspeed = 299792458
07:18:58 <lambdabot>  Defined.
07:19:21 <merijn> tasker: Depending on your usecase, there's nothing wrong with a Map of IORef
07:19:23 <Guest91343> merijn: does that mean I can't do `traverse (x -> [x]) either1`
07:21:08 <merijn> Sure you can
07:21:20 <Guest91343> as either is a travesable
07:21:24 <merijn> :t traverse (:[]) `asAppliedTo` (undefined :: Either String Int)
07:21:25 <lambdabot> Either String Int -> [Either String Int]
07:21:42 <Guest91343> gah.
07:21:43 <merijn> :t traverse
07:21:43 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:22:00 <merijn> 'f' (the return of your function) only has to be an Applicative
07:22:04 <merijn> Which lists are
07:23:20 <therp> I am trying to mix random-1.0.1.1 into my program because a dependency of mine (AI.GeneticAlgorithm.Simple) is using that package. I have had no luck so far to make that work with runhaskell: http://pastebin.com/4B2hu9Bt
07:23:33 <Guest91343> merijn: yeah somehow I am getting an instance not found error
07:23:54 <Guest91343> for (Traversable (Either String))
07:24:11 <merijn> Oh!
07:24:21 <merijn> Do you have the instance imported? :p
07:25:06 <Guest91343> it should be in Data.Traversable I assume?
07:25:17 <therp> Axman6: Thanks for your help before. I seem to be missing some details on package exposure, though
07:25:32 <merijn> Guest91343: It's in Data.Either, afaict
07:26:04 <Guest91343> merijn: http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Data-Traversable.html
07:26:05 <merijn> If importing that doesn't work, I'd get suspicious
07:26:41 <merijn> Guest91343: Which version of GHC/base do you have?
07:27:00 <merijn> Although I can't imagine old versions missing that Traversable instance...
07:27:12 <Guest91343> merijn: 7.6.3
07:27:34 <Guest91343> I should upgrade it now :(
07:27:59 <merijn> oh wow
07:28:06 <merijn> 4.6 is actually missing Traversable for Either
07:28:33 <shachaf> Yep.
07:29:07 <Guest91343> merijn: interesting!
07:29:10 <shachaf> http://hackage.haskell.org/package/semigroupoids has that instance in a semi-canonical place if you want to import it from somewhere.
07:29:40 <merijn> Guest91343: If you get errors like this, your first suspicion should always be "go to docs for older version and check"
07:31:13 <Guest91343> merijn: hmmm, will do that
07:31:41 <merijn> Guest91343: Or browse your local docs, which will show whatever's actually on your system instead of the latest version
07:32:31 <lpaste> talw pasted “maybeFunctionMany” at http://lpaste.net/118503
07:32:52 <talw> Hi guys! I have a question about this function I made
07:33:04 <talw> Is it already implemented?
07:33:26 <talw> It takes a -> Maybe b
07:33:31 <talw> and returns [a] -> Maybe b
07:33:49 <talw> with the first Just value, or nothing if no value was turned into a just
07:35:22 <mauke|> > Just 1 `mplus` Just 2 `mplus` Nothing
07:35:24 <lambdabot>  Just 1
07:35:30 <merijn> Pffft
07:35:46 <merijn> :t const Nothing -- <- There, only valid function of that type
07:35:47 <lambdabot> b -> Maybe a
07:35:49 <mauke|> :t \f -> msum . map f
07:35:49 <lambdabot> MonadPlus m => (a1 -> m a) -> [a1] -> m a
07:35:59 <zhulikas> :t mplus
07:36:00 <lambdabot> MonadPlus m => m a -> m a -> m a
07:36:01 <merijn> oh, wait
07:36:10 <merijn> I'm looking at only part of the type
07:36:24 <merijn> :t \f -> listToMaybe . fmap f
07:36:25 <lambdabot> (a1 -> a) -> [a1] -> Maybe a
07:36:27 <mauke|> :t \f -> msum . fmap f
07:36:28 <lambdabot> MonadPlus m => (a1 -> m a) -> [a1] -> m a
07:36:47 <merijn> :t \f -> listToMaybe . catMaybes . fmap f
07:36:48 <lambdabot> (a1 -> Maybe a) -> [a1] -> Maybe a
07:36:56 <mauke|> merijn: the paste does it better
07:37:23 <mauke|> it fuses catMaybes . fmap f into mapMaybe f
07:37:53 <merijn> oh, right
07:37:54 <talw> Yes
07:38:08 <talw> If there are nothings in the beginning and after that a just, it still returns the just
07:38:15 <merijn> Pretty sure this is below the Fairbairn threshold
07:38:27 <Guest91343> merijn: don't have instance for library base 4.6.0
07:38:52 <Guest91343> merijn: thanks
07:39:05 <talw> I didn't know about the Fairbairn threshold
07:39:05 <mauke|> :t \f -> F.msum . fmap f
07:39:06 <lambdabot> (Foldable t, MonadPlus m, Functor t) => (a1 -> m a) -> t a1 -> m a
07:39:08 <talw> I'm reading it now
07:39:36 <merijn> talw: Basically, if something is below the Fairbairn threshold it is "easier to reinvent than remember the name of the function"
07:40:04 <merijn> i.e., it's much easier to write "listToMaybe . mapMaybe foo" than remember the name of a special function for it
07:40:13 <merijn> Hell, I don't even remember mapMaybe
07:40:20 <merijn> I usually just use catMaybe + map
07:41:10 <mauke|> :t fmap F.msum `fmap` fmap
07:41:15 <lambdabot> (Foldable t, MonadPlus m, Functor t) => (a1 -> m a) -> t a1 -> m a
07:41:25 <talw> Interesting, I see your point. Thanks!
07:41:45 <glguy> :t ala First foldMap
07:41:51 <lambdabot> Foldable t => t (Maybe b) -> Unwrapped (First b)
07:58:59 <dgpratt> I have a faint memory that I read somewhere that there were good reasons to ignore the suggestion from cabal to upgrade cabal-install
07:59:09 <dgpratt> is or was such advice ever valid?
08:01:06 <johnw> usually it's pretty safe
08:01:26 <dgpratt> I see, thanks johnw
08:01:42 <athan> dgpratt: Maybe if you're using an old GHC...?
08:01:48 <geekosaur> there have been times when upgrading cabal-install without upgrading the Cabal library was a bad idea. but that's pretty much always a bug
08:02:21 <dgpratt> sounds like I need to forget that advice
08:02:34 <geekosaur> (in fact the latest cabal has that kind of issue in some cases, and a point release should be upcoming shortly to fix it)
08:04:01 <geekosaur> the other possible reason to ignore it is if you intend to stick to what your system's package manager provides (say, to simplify management of a large number of systems)
08:04:43 <geekosaur> in which case, if you want an upgraded cabal-install then you probably want your sysadmin to provide a local system package repo with the update instead of doing it manually
08:06:43 <dgpratt> thanks for the explanation, geekosaur
08:14:20 <lachenmayer> is there any way to execute a sub-process from a certain working directory without changing the working directory for the entire haskell process?
08:15:38 <therp> lachenmayer: I am not sure how you spwan your sub-process but do the chdir after the fork?
08:15:44 <RchrdB> lachenmayer: yes. System.Process.CreateProcess has a (cwd :: Maybe FilePath) field, which is the working directory that the child is started in.
08:16:11 <lachenmayer> thanks a lot!
08:16:20 <lachenmayer> (surprisingly on-googleable...)
08:16:40 <RchrdB> therp: you don't want to use fork()/exec() directly in Haskell; fork interacts poorly with the current IO manager.
08:17:08 <therp> RchrdB: ok (no experience there)
08:17:08 <RchrdB> There's a binding for fork(2) in somewhere like System.Posix, but it comes with a bunch of dire warnings in the documentation.
08:17:15 <RchrdB> System.Process is okay. <3
08:19:20 <athan> Hey guys, is there a paper complementing GHC.TypeLits besides the SYB papers?
08:21:13 <Pamelloes> I'm having issues with pattern matching and flexible instances. Could someone look over the following code?
08:21:16 <lpaste> Pamelloes pasted “Parse Error” at http://lpaste.net/118506
08:21:33 <mauke|> remove parens
08:21:53 <Pamelloes> mauke| around ".&."?
08:21:53 <Cale> Yeah, if you write an operator infix, you don't want the parens
08:22:08 <mauke|> either (.&.) x y or x .&. y
08:22:18 <Cale> It's only if you want to write it prefix or as an argument to some other function that you need them
08:22:19 <mauke|> x (.&.) tries to call x, passing .&. as an argument
08:22:27 <Pamelloes> Ah ok
08:22:29 <Pamelloes> Thakns!
08:22:31 <Pamelloes> *Thanks
08:22:46 <mauke|> > [] (+)
08:22:47 <lambdabot>  Couldn't match expected type ‘(a0 -> a0 -> a0) -> t’
08:22:47 <lambdabot>              with actual type ‘[t0]’
08:23:00 <mauke|> > let [] (+) = () in ()
08:23:01 <lambdabot>  Constructor ‘[]’ should have no arguments, but has been given 1
08:25:37 <arthur_honeynet> Can anyone help with compiling llvm-general?
08:25:42 <arthur_honeynet> http://lpaste.net/111791
08:25:53 <arthur_honeynet> This paste isn't by me so at least someone else has had the exact same issue.
08:26:25 <arthur_honeynet> I'm using ghc 7.8.3 on a Mac. I've even recomplied 7.8.4 from source with llvm backend and still get the same error
08:26:39 <arthur_honeynet> (fwiw I'm wanting to work through http://www.stephendiehl.com/llvm/)
08:41:28 <SrPx_> does anyone know what this error means? http://lpaste.net/118509
08:42:22 <RchrdB> SrPx_: pkg-config is a tool for finding C libraries.
08:42:25 <geekosaur> SrPx: the haskell cairo package is a binding to the C cairo library, which needs to be installed
08:42:48 <SrPx_> I see ... I don't know much about pkg-config, what is the install command ?
08:43:14 <lpaste> NemesisD pasted “transformers compat” at http://lpaste.net/118510
08:43:15 <geekosaur> ... if you have pkg-config on your system then packages like cairo will register themselves with it.
08:43:19 <NemesisD> i'm getting weird dependency conflicts on a project involving transformers-compat. this is with ghc 7.8.4 and transformers 0.3.0.0 ^^
08:43:37 <arthur_honeynet> SrPx_ I think it's saying that you don't have the cairo library installed
08:43:38 <SrPx_> geekosaur: ah I have pkg-config ...
08:43:48 <arthur_honeynet> That's the system library not the haskell one.
08:43:50 <RchrdB> SrPx_: on Linux, you probably have pkg-config installed already and the file that pkg-config looks for to tell you how to link against cairo will be in a package called "cairo-devel" or something like that
08:43:57 <NemesisD> i just upgraded from ghc 7.6 and blew away the sandbox in this project, but i'm wondering if something else needs to be done?
08:44:00 <geekosaur> that's os x
08:44:01 <SrPx_> arthur_honeynet: yess I installed it with macports, though :( and installed pkg-config with nix
08:44:19 <geekosaur> SrPx_, what does "type pkg-config" return?
08:44:23 <NemesisD> the ~/.ghc dir seems to segregate by ghc version and there isnt' even one in there for 7.8.4 yet so i'm assuming i don't need to delete that
08:44:37 <SrPx_> pkg-config is hashed (/Users/apple1/.nix-profile/bin/pkg-config geekosaur
08:44:44 <geekosaur> um.
08:44:45 <arthur_honeynet> Did you have something configured to tell it to look in /opt ?
08:44:45 <RchrdB> uh
08:45:06 <geekosaur> so you installed cabal with macports but your pkg-config is not the one from macports, so it doesn't know to look in /opt/local
08:45:35 <RchrdB> SrPx_: you're mixing pkg-config from nixpkgs with cairo from macports? I would not expect that to work.
08:45:50 <SrPx_> geekosaur: makes sense... I couldn't install it with nix, though :( got a weird but. you recommend that I use a VM with another OS?
08:46:07 <Pamelloes> Is there an easy way to make (== False).(!!) work?
08:46:10 <geekosaur> it might work if $PKG_CONFIG_PATH is set appropriately... but if there's other libraries from nix then link errors are not unlikely
08:46:14 <SrPx_> RchrdB: I hoped it just needed the cairo bin :)
08:46:24 <SrPx_> I see
08:46:42 <mauke|> Pamelloes: ((== False) .) . (!!)
08:46:44 <RchrdB> SrPx_: alas, Cairo is a library not a program, so you need header files too.
08:46:51 <mauke|> also, (== False) better written as not
08:46:54 <geekosaur> cairo is not a "bin", it's a complex library. pkg-config is a tool to report complex rules for using various libraries
08:46:54 <SrPx_> uh huh, akes complete sense, thanks
08:46:58 <Pamelloes> mauke| Thanks :)
08:47:01 <arthur_honeynet> cabal install --extra-lib-dirs=/opt/local/lib
08:47:09 <arthur_honeynet> and then something similar to tell it where the headers are
08:47:19 <RchrdB> SrPx_: macports packages pkgconfig, though
08:47:24 <RchrdB> *pkg-config, I mean
08:47:29 <geekosaur> but it has to be able to find the pkg-config database, and your nix pkg-config won't look at the MacPorts pkg-config databases
08:47:32 <SrPx_> I seee I see, thanks. I'm kinda stuck though, since nix-env isn't managing to install cairo
08:47:41 <geekosaur> set $PKG_CONFIG_PATH to fix that
08:48:07 <geekosaur> or, hide nix's pkg-config from your $PATH while installing this so you get macports' pkg-config
08:48:11 <SrPx_> but you said it is likely that I will have linking errors, right
08:52:40 <SrPx_> geekosaur: what exactly should I set PKG_CONFIG_PATH to? Seems like cairo was installed on /opt/local http://lpaste.net/118511
08:54:11 <geekosaur> /opt/local/lib/pkgconfig:/opt/local/share/pkgconfig probably
08:56:24 <SrPx_> geekosaur: wel thanks
09:00:33 <Pamelloes> Is there a way to get some form of stack trace in Haskell?
09:00:58 <vanila> there isn't
09:01:06 <Pamelloes> Damn
09:01:23 <geekosaur> stack traces are less than helpful usually
09:02:13 <Pamelloes> In my case I have a function I'm testing that is throwing an error because it is being given an invalid input. A stack trace would let me see where the input was coming from :/
09:02:14 <geekosaur> the significant stack is the graph reduction / pattern matching stack; the call stack that you are used to from other languages is only relevant for FFI calls
09:02:57 <vanila> what kind of error?
09:03:27 <Pamelloes> vanila: User defined error for an empty array as a parameter.
09:03:35 <jchen114> Hullo?
09:03:40 <Pamelloes> Hi!
09:03:51 <jchen114> haskell help granted here?
09:03:59 <benzrf> jchen114: never
09:04:00 <geekosaur> Pamelloes, the caller is gone by the time your function inspects the value
09:04:03 <benzrf> jchen114: only sold
09:04:07 <benzrf> jchen114: cough up
09:04:13 <Pamelloes> hehe
09:04:22 <jchen114> what are payment types
09:04:36 <vanila> hmm
09:04:39 <muzzle> $
09:04:47 <benzrf> jchen114: i accept heartfelt thanks, personally :-)
09:04:51 <Pamelloes> We accept dogecoin.
09:04:53 <vanila> jchen114, where did you see it?
09:05:05 <jchen114> this place?
09:05:07 <mmaroti> Hi! Is Data.Typeable.cast calculated at compile time or at runtime (Dynamic is not used)? I assume, that the compiler knows the types already for the cast, so it emits a constant Nothing or Just v, no?
09:05:10 <jchen114> I just googled Haskell irc
09:05:13 <vanila> "payment types"
09:05:13 <geekosaur> lazy evaluation: a function call immediately returns an unevaluated thunk. when you inspect the value, the thunk is evaluated and you are left with its result, the thunk itself is gone
09:05:17 <vanila> I think that's a mistranslation
09:05:37 <geekosaur> so you kinda would have to attach the thing that generated a value to that value to be able to "stack trace"
09:05:45 <Pamelloes> Hm...
09:06:02 <Pamelloes> I guess I'll just go hunting for bugs the old fashioned way. With a flashlight and a net!
09:06:16 <Pamelloes> And a jar, I guess....
09:06:28 <vanila> haha
09:06:28 <vanila> ]
09:06:29 <vanila> good luck
09:06:33 <mauke|> mmaroti: if it can be calculated at compile time, you can just remove the 'cast'
09:07:07 <Pamelloes> jchen114: This is the place to get Haskell help. Everyone was just messing with uou.
09:07:08 <geekosaur> if you build with profiling then you can run with +RTS -xc and get a sort of minimal stack trace... but this is in my experience usually less than helpful
09:07:10 <mauke|> if the compiler knew the types to be the same, it wouldn't need 'cast' to accept the code
09:07:27 <vanila> I thought maybe it was a mistranslation of dependent types or something
09:07:34 <jchen114> I noes. I think the messing was good.
09:07:54 <Pamelloes> geekosaur: Alright, I might look into that.
09:09:29 <mmaroti> Ok, so the Typeable constraints are used only to derive some representation of the type, and if they are equal then it is cast?
09:16:51 <NemesisD> does transformers ship with ghc or something?
09:16:57 <NemesisD> i can't figure out why i'm on 0.3 and not 0.4
09:17:29 <glguy> transformers ships with GHC 7.8, at least
09:17:49 <NemesisD> 0.3.0.0 right?
09:17:50 <glguy> If you need types from transformers 0.4 and you're on GHC 7.8 you can get them from transformers-compat
09:18:46 <glguy> transformers-compat adapts itself to provide the types you're missing based on your transformers version
09:19:31 <horny-sama> I am just wondering when do you use Integer vs Int in haskell
09:19:39 <NemesisD> its giving me some trouble, when trying to resolve my dependencies with -v3 i'm seeing stuff like [167] rejecting: transformers-0.3.0.0/installed-645... (conflict: transformers-compat-0.3.3.4:three => transformers>=0.4.1 && <0.5)
09:20:01 <glguy> NemesisD: Try building wth  --constraint=transformers\ installed
09:20:08 <NemesisD> horny-sama: int is limited to a machine word (i believe?), integer is not, but has a performance penalty
09:20:46 <NemesisD> horny-sama: in ghci run maxBound :: Int
09:20:46 <horny-sama> NemesisD: according to my lecture slides Intger: arbitrary-precision integer numbers vs Int fixed-precision integer
09:21:14 <horny-sama> but my issue is precising? I thought that is a float or double thingie
09:21:39 <NemesisD> hmm yeah that goes against my understanding of precision
09:21:50 <horny-sama> me too
09:21:53 <quchen> Int is a finite subset of Integer. "Precision" doesn't really apply to either of them.
09:21:57 <NemesisD> i think of this this way: Int is bound, Integer is not
09:21:59 <horny-sama> then again, I am not an haskell expert
09:22:14 <Iceland_jack> horny-sama: http://en.wikipedia.org/wiki/Arbitrary-precision
09:22:21 <horny-sama> quchen: got it
09:22:46 <glguy> arbitrary precision doesn't just mean on the right-hand side of the decimal point
09:23:41 <Pamelloes> geekosaur: You weren't kidding, that stack trace is completely worthless :P
09:23:53 <horny-sama> Pamelloes: unless you are a machine
09:23:54 <horny-sama> :P
09:24:11 <Pamelloes> horny-sama: Nope. Not even then.
09:24:11 <quchen> > "horny-sama: Integer is the set {" ++ show (minBound::Int) ++ "..." ++ show (maxBound::Int) ++ "}. Integer is ℤ."
09:24:13 <lambdabot>  "horny-sama: Integer is the set {-9223372036854775808...9223372036854775807}...
09:24:51 <quchen> Eh, Int is the set.
09:24:52 <quchen> Silly me.
09:25:05 <NemesisD> ugh, the dependency solver takes several minutes to tell me it couldn't accept my dependencies D:
09:25:29 <glguy> What're you trying to install?
09:25:44 <NemesisD> i'm trying to upgrade a large project i'm working on to ghc 7.8
09:29:21 <dfeuer> Is there a reason lots of people use multiple LANGUAGE pragmas instead of just one with commas between the pieces?
09:29:53 <Cale> dfeuer: I don't think so
09:29:53 <glguy> separate lines make for nicer diffs?
09:30:12 <dfeuer> glguy, you can even do that with commas, just like module exports.
09:30:15 <ocharles_> Cale, dfeuer: better diffs, more readable
09:30:26 <NemesisD> dfeuer: easier to add/remove
09:30:28 <ocharles_> I wonder if I could be any more subjective :P
09:30:40 <NemesisD> plus stylish-haskell will sort them anyways
09:30:41 <geekosaur> separate lines make for easier addition/removal, yeh. because each line is self-contained
09:30:50 <dfeuer> Also, why would anyone remove anything except {Overlapping,Incoherent}Instances?
09:30:55 <ocharles_> I'm actually moving to using default-extensions these days though
09:31:03 <ocharles_> the majority are harmless enough to always have on
09:31:20 <NemesisD> dfeuer: i try to not have language pragmas i don't need anymore
09:34:22 <NemesisD> holy crap. cabal actually accepted the install plan
09:34:42 <NemesisD> all of this fuss was over a too-strict template-haskell upper bound
09:38:47 <torpet> could someone explain to me following foo?
09:38:57 <torpet> :t (\x y z a -> x(x(x(z(a)))))
09:38:58 <lambdabot> (t1 -> t1) -> t -> (t2 -> t1) -> t2 -> t1
09:39:11 <vanila> torpet, yes, what would you like to know about it?
09:39:20 <torpet> sorry, this one: :t (\x y z a -> x(z(z(z(a)))))
09:39:25 <torpet> :t (\x y z a -> x(z(z(z(a)))))
09:39:25 <lambdabot> (t2 -> t1) -> t -> (t2 -> t2) -> t2 -> t1
09:39:35 <torpet> where does the t come from?
09:39:43 <mauke|> y
09:39:46 <vanila> well the type inferencer has to make up variable names
09:39:52 <vanila> so it's just calling the types t,t1,t2
09:40:24 <vanila> see how y is not used in the expression?
09:40:32 <vanila> that means y could have any type at all, there's no way to pin it down
09:42:13 <JonReed> Does printing to terminal effect performance? E.g. will rsync perform signitifactly faster, if it won't sperifiy the -v (verbose option)?
09:42:25 <vanila> printing a lot of stuf wil slow things down
09:42:46 <vanila> rsync shouldn't be affected much since it doesn't print a lot, or quickly
09:42:46 <JonReed> vanila: Ok. Thanks.
09:43:53 <justicefries> is LYAH up to date?
09:46:50 <JonReed> justicefries: It's pretty up-to-date. Some minor things won't work though. E.g. in the state monad example in LYAH there was a "State $ \s -> (x,s)", but it only worked for me when I used without the capital letter like "state $ \s -> (x,s)"
09:47:51 <justicefries> ah. interesting.
09:47:52 <JonReed> justicefries: If you want a book that is relatively fresh out of the oven, then Concurrent and Parrallel Haskell is fairly new. But, obviously, it's more focused on concurrency.
09:48:14 <justicefries> I'm an Erlang programmer....that's actually pretty interesting sounding to me. :)
09:48:25 <justicefries> I was doing some Rust, and it got me wanting to try Haskell.
09:48:46 <torpet> vanila: so i could name it m as well? or any other thing?
09:49:01 <horny-sama> justicefries: erlang?
09:49:19 <vanila> yes absolutely
09:49:27 <Hijiri> justicefries: I would recommend https://github.com/bitemyapp/learnhaskell as a guide
09:49:37 <Cale> justicefries: People have been recommending this tutorial as well lately: http://www.seas.upenn.edu/~cis194/fall14/lectures.html
09:50:09 <justicefries> ooh I like these.
09:50:35 <justicefries> I was choosing Rust for game dev, but there's some things in Rust I just really don't like, but love the type system, so figured I'll see it to it's natural conclusion with Haskell for game dev.
09:51:05 <Hijiri> be warned that Haskell game dev is still frontier territory
09:51:18 <justicefries> fair. :)
09:51:23 <Cale> justicefries: You might also be interested in the #haskell-game channel
09:51:33 <Cale> oh, you're already there :)
09:51:57 <JonReed> I wonder what John Carmark's adventures with Haskell ended with (after his talk about how he's planning to use haskell for game dev)
09:53:19 <tommd> Cabal-hell, surely.
09:54:40 <glguy> * tommd was kicked from #haskell by glguy (Your behavior is not conducive to the desired environment)
09:54:47 <pmade> Anyone including the current git commit hash as a build number so it can be displayed via --version?  Any tips?
09:55:17 <tommd> :-(
09:57:01 <tommd> OK, more seriously. It is always neat to see a big name take up your niche, Haskell in this case, but I imagine most "big names" don't appreciate dealing with things that are unnecessarily frustrating.  In the end it because an issue of time consumed by uninteresting or unnecessarily complex issues caused by the environment.
09:58:32 <quchen> pmade: You can use TH to execute IO at compile-time. http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Syntax.html#v:runIO
09:59:20 <pmade> quchen: Cool, that looks like a workable solution.
09:59:29 <Hijiri> you could make TH DRM
09:59:39 <Hijiri> download the code that makes it compile
09:59:48 <EvanR-work> quchen: so this could be used as like a "type provider"
09:59:59 <benzrf> > (\f -> (f 3, f "foo") id
10:00:00 <lambdabot>  <hint>:1:25:
10:00:01 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:00:04 <benzrf> > (\f -> (f 3, f "foo")) id
10:00:05 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
10:00:05 <lambdabot>    arising from the literal ‘3’
10:00:09 <benzrf> mfw
10:00:23 <quchen> EvanR-work: runIO can be used like a lot of things. Including making your original program do pretty much whatever.
10:01:30 <mauke|> > let foo :: (forall a. a -> a) -> (Integer, String); foo f = (f 3, f "foo") in foo id
10:01:31 <lambdabot>  (3,"foo")
10:02:25 <EvanR-work> tommd: "big names dont appreciate dealing with things that are unnecessarily frustrating" like c++?
10:02:39 <EvanR-work> * in game industry
10:02:42 <exio4> is id the only 'non-bottom' function that can have that type?
10:03:00 <quchen> Yes.
10:03:11 <tommd> EvanR-work: I guess the sense I have received is one of impatience with tools.  Languages for some reason get a free pass - "We need it for performance" or what have you.
10:03:49 <EvanR-work> ah, then haskell is a good choice then ;)
10:04:02 <EvanR-work> you might get frustrated with it, and get performance
10:04:24 <tzaeru> to me, it sounds immersively risky to start doing a real-time, I/O and perf heavy application in with tools that make performance assumptions difficult :P
10:05:45 <bgamari> Anyone know how to compare multiple criterion benchmarks?
10:06:13 <bgamari> Unfortunately I can't link them all into the same executable
10:06:37 <Welkin> EvanR-work: most of the features of c++ are not used in game programming
10:06:42 <bgamari> Ideally I'd have a way to generate a report from multiple CSVs
10:06:49 <bgamari> carter perhaps?
10:06:50 <Welkin> it's really used like C with some convenient features
10:07:07 <Cale> bgamari: Compare in what sense?
10:07:12 <Welkin> no exceptions, no templates, etc.
10:07:28 <tzaeru> Welkin, I see STL, templates, classes, etc, used all the time..
10:07:54 <bgamari> Cale, Compare different runs of the same benchmarks
10:08:23 <bgamari> Cale, I have a change; I'd like to see how it is reflected in the benchmarks
10:08:31 <Cale> ah
10:08:41 <Cale> Just run the program again? :)
10:09:02 <bgamari> Cale, ideally I'd be able to generate a report showing both sets of results
10:09:14 <bgamari> I may just write a quick python hack
10:09:16 <Cale> I don't know if there are any tools for reading the output from Criterion
10:09:23 <bgamari> yeah, sad
10:09:30 <Cale> though, there might be a way to get Criterion to produce something more machine readable
10:09:44 <bgamari> It will produce CSV and  JUnit output if so asked
10:10:58 * hackagebot propellor 1.3.2 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-1.3.2 (JoeyHess)
10:19:13 <Scheriderm> hey guys, can someone tell me what's the current state of SDL 2  in Haskell??
10:19:44 <edermi> Hello. Is it possible to sort a text (sorting order: alphabet)? E.g. sort (Text.pack "cba") -> "abc" (of course, "abc" is supposed to be a text and not a string)
10:20:34 <bgamari> edermi, you want to sort the characters in a Text value?
10:21:17 <edermi> bgamari: yes!
10:22:04 <edermi> Data.Text does not provide a sort function and sort from Data.List behaves even strange on normal Strings, so I didn't test it with text
10:22:23 <bgamari> edermi, it's a bit of an odd requests
10:22:26 <bgamari> request*
10:22:37 <edermi> why?
10:22:43 <bgamari> edermi, one option would be to pack the characters into a Vector
10:23:15 <bgamari> edermi, well, what do you even want to sort? You could sort the codepoints
10:23:28 <bgamari> you could sort the characters
10:23:43 <bgamari> although the latter doesn't even really have any defined ordering as far as I know
10:23:53 <EvanR-work> there are many collations you could use
10:24:06 <EvanR-work> the alphabets are ordered differently in different locales
10:24:34 <Welkin> edermi: what do you mean "Data.List.sort behaves strangely on normal strings"?
10:24:46 <Welkin> what is strange?
10:24:57 <EvanR-work> > sort "what is strange?"
10:24:58 <lambdabot>  "  ?aaeghinrssttw"
10:25:18 <edermi> I have to write an anagram generator. I have a word to find anagrams of and a huge list of (english) words where I can pick of. I did already a lot of filtering, now I need to find a matching sublist to do what the second answer on stackoverflow says: http://stackoverflow.com/questions/55210/algorithm-to-generate-anagrams
10:25:19 <Welkin> oh
10:25:29 <Welkin> well, it depends on wat you expect
10:25:35 <Welkin> sorting a string doesn't make a whole lot of sense
10:25:57 <edermi> sort "cba"
10:26:02 <edermi> >sort "what is strange?"
10:26:07 <edermi> > sort "what is strange?"
10:26:08 <lambdabot>  "  ?aaeghinrssttw"
10:26:14 <edermi> > sort "cba"
10:26:15 <lambdabot>  "abc"
10:26:22 <edermi> dafuq?
10:26:23 <EvanR-work> seems legit
10:26:25 <glguy> edermi: You'll have to tell us what you expected to happen
10:26:31 <edermi> ghci doesn't do that?!
10:26:37 <Adeon> Scheriderm: it's quite good. there's the 'sdl2' package that has low-level bindings but I recommend using the latest source from github for that package, as it has higher level and more convenient bindings
10:26:50 <geekosaur> we have no idea what you are expecting...
10:26:59 <edermi> > sort "Hello"
10:27:00 <lambdabot>  "Hello"
10:27:09 <edermi> > sort "Helloa"
10:27:10 <lambdabot>  "Haello"
10:27:22 <edermi> ah it had to do with capital letters
10:27:24 <edermi> sorry
10:27:25 <Welkin> it sorts them in order of their numerical representation in ASCII/Unicode
10:27:36 <geekosaur> oh, you wanted case independent sort?
10:27:43 <Welkin> uppercase letters have a lower value than lowercase
10:28:08 <edermi> my input list is only lowercase but I tried interactively first and used capital letters too^^
10:28:20 <edermi> I'm really sorry
10:28:43 <edermi> well, does this work on text or do i have to unpack every string?
10:28:50 <Welkin> > ord 'A'
10:28:51 <lambdabot>  65
10:28:54 <Welkin> > ord 'a'
10:28:55 <lambdabot>  97
10:29:09 <EvanR-work> > sort "Haskell（ハスケル）は非正格な評価を特徴とする純粋関数型プログラミング言語である。"
10:29:10 <lambdabot>  "Haeklls\12290\12354\12377\12391\12392\12394\12399\12427\12427\12434\12464\1...
10:29:20 <EvanR-work> > text $ sort "Haskell（ハスケル）は非正格な評価を特徴とする純粋関数型プログラミング言語である。"
10:29:21 <lambdabot>  Haeklls。あすでとなはるるをググケスハプミラルロン価型徴数格正特粋純言評語関非（）
10:30:16 <edermi> yeah, I got it. thanks. How about sorting Text now. Unpacking it to string or is there a smart way to do this?
10:30:35 <Welkin> :t text
10:30:36 <lambdabot> String -> Doc
10:30:38 <EvanR-work> thats the easy way
10:30:57 <edermi> ok, so I guess I'm going to do that
10:31:01 <Welkin> :t sort
10:31:02 <lambdabot> Ord a => [a] -> [a]
10:31:06 <Welkin> sort is defined for lists
10:31:43 <edermi> I've read that text is somehow better/faster than string, can someone explain this to me? It's not relevant for my problem due to my filtering, but I'm interested in that
10:32:00 <sshine> edermi, arrays vs. linked lists
10:32:04 <Welkin> String is [Char]
10:32:22 <Welkin> but that allows all kinds of nice operations to be performed on it
10:32:28 <edermi> ah, and string's the linked list I guess
10:32:49 <EvanR-work> @src String
10:32:50 <lambdabot> type String = [Char]
10:33:00 <sshine> edermi, yep. that's a really inefficient way to store sequential data. but depending on what you do with it, it's very flexible also.
10:33:02 <Welkin> String is fine depending on your use case
10:33:17 <Welkin> I use String for huge text blobs just fine
10:33:20 <Adeon> text is internally utf-16 but that fact is not direclty exposed to you with the API
10:33:38 <edermi> Welkin: Yeah, performing ten words as string would not cost that much I guess
10:34:00 <EvanR-work> huge text blobs as a String will be the death of your program
10:34:05 <Adeon> hmm, wait, actually not sure what exactly the representation is
10:34:08 <sshine> Adeon, why would one want to choose utf-16 over utf-8? (as I understand, utf-8 is variable where utf-16 is always 2+ bytes per character?)
10:34:10 <EvanR-work> dont try this at home
10:34:11 <Adeon> it says packed utf-16
10:34:24 <Adeon> I don't know why, that's just how it is
10:34:31 <edermi> that's the reason why I'm using text for the dictionary, EvanR-work
10:34:32 <EvanR-work> Text is an efficient packed string type, doesnt matter the implementation ;)
10:34:33 <Adeon> but I'm sure someone thought about it and decided to go with utf-16
10:34:51 <ClaudiusMaximus> there were extensive benchmarks for multiple languages, iirc
10:35:00 <sshine> I'm just curious.
10:35:15 <sshine> ClaudiusMaximus, wrt. utf-8 / utf-16, or String/Text?
10:35:18 <EvanR-work> most utf16 data is 2 bytes per character
10:35:23 <EvanR-work> almost all*
10:35:24 <ClaudiusMaximus> sshine: utf-8/utf-16
10:35:58 * hackagebot kure 2.16.6 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.16.6 (NeilSculthorpe)
10:36:08 <sshine> is it because utf-16 is computationally efficient because you don't have to check on extension bytes all the time?
10:36:08 <edermi> are lists in haskell always linked lists?
10:36:12 <EvanR-work> yes
10:36:21 <EvanR-work> @src []
10:36:21 <lambdabot> data [] a = [] | a : [a]
10:36:39 <edermi> but not double-linked?
10:36:53 <ClaudiusMaximus> doubly-linked and immutability causes all kinds of pain
10:36:56 <Cale> edermi: Lists are exactly what the constructors tell you they are
10:37:00 <sshine> edermi, you can't really make double-linked lists easily with algebraci types, IIRC.
10:37:05 <sshine> algebraic*
10:37:14 <EvanR-work> @src DList
10:37:14 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:37:17 <Cale> There are other collection data structures
10:37:23 <Cale> Of course
10:37:29 <Cale> But lists are lists :)
10:37:38 <edermi> ok, thank you :)
10:39:00 <sshine> ClaudiusMaximus, what exactly? sounds GC-related...
10:42:51 <ClaudiusMaximus> sshine: for singly linked lists, "tail" can re-use the tail of the list, but for doubly linked lists, "tail" would have to modify the new list's head to have a null predecessor, and modify the next item to point to the new head, and modify the item after that too, -> no sharing
10:43:22 <ClaudiusMaximus> sshine: where "modify" means "allocate a new list node with the new stuff", because immutable
10:43:50 <EvanR-work> i read the performance relies heavily on the data being immutable
10:44:23 <EvanR-work> performance of the gc
10:48:13 <JonReed> What is the difference between Data.Map and Data.IntMap for a mere mortal like me? If I understand correctly Data.Map is a red black persistent binary tree. But what is Data.IntMap?
10:48:54 <EvanR-work> it says "The implementation is based on big-endian patricia trees."
10:48:55 <koala_man> JonReed: a trie
10:49:02 <muzzle> does anyone have an idea how i can get HUnit to output what TestCase it's currently running
10:49:19 <muzzle> and generally tell me more about what it's currently doing
10:51:16 <muzzle> ?
10:55:26 <Cale> JonReed: Data.Map is not a red-black tree actually, it's a different sort of balanced binary tree. The practical difference between Map and IntMap is that IntMap is generally somewhat faster for its special case.
11:05:22 <lpaste> Buck pasted “No title” at http://lpaste.net/118520
11:05:54 <Buck> I get a non exhaustive patterns error in that code, but I don't understand why. Where is my code not exhausting the patterns?
11:06:20 <EvanR-work> what if y > x
11:06:47 <geekosaur> look carefully at how you defined those nonequal cases, yeh
11:06:52 <Buck> dammit
11:07:03 <Buck> thank you :">
11:07:11 <ReinH> @google fast mergeable integer maps okasaki
11:07:13 <lambdabot> http://ittc.ku.edu/~andygill/papers/IntMap98.pdf
11:07:13 <lambdabot> Title: Fast Mergeable lnteger Maps*
11:07:16 <Buck> I could have stared at that for an hour and not seen it
11:07:22 <ReinH> JonReed: ^ might be of interest
11:07:35 <EvanR-work> you took care of x > y AND y < x, good effort
11:07:56 <Buck> yeah yeah >_>
11:08:18 <ReinH> Buck: you can pattern match on an Ordering instead
11:08:35 <ReinH> Easier to ensure that you handle all cases that way
11:08:36 <EvanR-work> boolean case analysis is really tricky
11:08:45 <Buck> do you have an example ReinH
11:08:51 <ReinH> EvanR-work: Not really. There are only two cases. *ducks*
11:09:02 <EvanR-work> for more complex conditions you have to fill out a huge truth table
11:09:07 <Buck> I could order it first, but I don't know about Orderings
11:09:25 <EvanR-work> :t compare
11:09:26 <lambdabot> Ord a => a -> a -> Ordering
11:09:30 <EvanR-work> @src Ordering
11:09:30 <lambdabot> data Ordering = LT | EQ | GT
11:10:04 <Buck> I'll look it up in the docs
11:10:05 <Buck> thank you
11:10:23 <ReinH> > case (compare 1 2) of LT -> "less than"; EQ -> "equal"; GT -> "greater than"
11:10:25 <lambdabot>  "less than"
11:11:12 <EvanR-work> > Data.Text.index (Data.Text.pack "abc") 1
11:11:13 <lambdabot>  Not in scope: ‘Data.Text.index’
11:11:13 <lambdabot>  Perhaps you meant ‘Data.Ix.index’ (imported from Data.Ix)Not in scope: ‘Data...
11:11:39 <EvanR-work> the Text docs are contradictory on the complexity of the index operation
11:11:43 <EvanR-work> O(n) vs O(1)
11:12:05 <ReinH> EvanR-work: Where?
11:12:26 <EvanR-work> looking at the implemenation of the stream index function, im wondering how it even gets the right character, especially in the case of "astral plane characters"
11:12:51 <EvanR-work> ReinH: the O(1) is in the Data.Text.Fusion doc for stream index, which is how index is implemented
11:13:12 <ReinH> EvanR-work: which index?
11:13:22 <EvanR-work> Data.Text.index
11:15:09 <nitrix> Hi, how do I implement `providerPut :: RawBlock -> MaybeT IO BlockId`, where B.writeFile that I'll use, returns an IO() ?
11:15:37 <nitrix> Do I just prefix it with MaybeT ?
11:15:42 <EvanR-work> i see, the stream operations is O(n)
11:16:03 <clrnd> nitrix, seems you need a MaybeT, why not use `return`?
11:16:37 <nitrix> The other concern is that, I'm using MaybeT because I want to have `Either BlockId` or `Nothing`.
11:16:47 <RustyShackleford> i probably need to read Learn You a Haskell five more times for it to all sink in
11:16:48 <nitrix> Whoops, `Just BlockId` or `Nothing`.
11:16:55 <RustyShackleford> but i'm wondering, what do you read next?
11:17:03 <tommd> nitrix: Are you asking for 'liftIO'?
11:17:07 <EvanR-work> RustyShackleford: cis194 lecture
11:17:07 <tommd> @hoogle liftIO
11:17:09 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
11:17:09 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
11:17:09 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
11:17:39 <luite> EvanR-work: see the Data.Text.Internal.Fusion.stream function, that decodes the UTF-16 array to a stream of codepoints
11:18:26 <clrnd> nitrix, yeah you will need runMaybeT and liftIO
11:18:52 <RustyShackleford> after like three days of reading, things are starting to make sense
11:19:33 <EvanR-work> luite: thanks, was looking at the wrong stream i guess
11:20:30 <EvanR-work> theres similar ones
11:21:28 <ReinH> nitrix: Why are you using MaybeT IO BlockId instead of IO (Maybe BlockId)?
11:22:36 <Denommus`> luite: hey. Is there a library similar to React that I can use in GHCJS? What I want is to be able to provide a newly formed view to the "engine", and it works the diffs itself to update what changed
11:22:36 <Denommus`> luite: or maybe React itself is easy to use in GHCJS?
11:22:42 <sx> I've seen something before, but I'm not quite sure whether it is possible: I want to abstract over some constants, but those constants are basically part of a static type, so is it possible to parametrize a type over values of another type? And how am I turning those type level values back into normal values?
11:22:43 <EvanR-work> luite: well i still dont understand where the O(n) comes from, the stream operation returns immediately just building a function next that takes an index. later it /seems/ like the index is passed directly to next, which seems like it will be off is preceded by astral chars?
11:23:00 <EvanR-work> is this magic stream stuff
11:23:09 <am_> Hello. Does anybody here know about CAFs (constant applicative forms) and how they are (or not) garbage collected? The program I wrote in my embededded DSL has a very large memory foot-print and I suspect that the whole thing is treated as a CAF
11:23:22 <ReinH> Denommus: There is https://hackage.haskell.org/package/react-haskell but it is intended for use with Haste
11:23:22 <EvanR-work> off if preceded*
11:23:49 <nitrix> ReinH: I would know how to use IO (Maybe BlockId), in fact, it was written this way before, but I'm trying to learn monad transformers, and I though that was a good application for it.
11:24:15 <nitrix> Denommus: Oh hi :3
11:24:20 <Denommus> ReinH: what about blaze-react?
11:25:16 <Denommus> nitrix: hello. How are you doing?
11:25:52 <ReinH> Denommus: Maybe. Haven't used either.
11:26:16 <RustyShackleford> does haskell have a killer app?
11:26:27 <Denommus> RustyShackleford: what do you mean by a killer app?
11:26:30 <EvanR-work> :t (<*>)
11:26:31 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:26:33 <RustyShackleford> i know xmonad is written in haskell. Anything else i might have heard of?
11:26:37 <Hijiri> Pandoc?
11:26:39 <Iceland_jack> Killer (<*>)...
11:26:42 <EvanR-work> lol
11:26:59 <EvanR-work> i got your killer ap right here
11:28:27 <luite> EvanR-work: to get the nth code point for index, it has to decode everything up to that point
11:28:42 <EvanR-work> that makes sense, in general. but where does it do that?
11:29:28 <bergey> Rustyshackleford: pandoc and git-annex are the big projects I know of, with many users who don't know or care about haskell.  (Both are great tools.)
11:30:13 <EvanR-work> i think i found it
11:30:23 <Denommus> git-annex is awesome, indeed
11:30:51 <luite> EvanR-work: in the function i just mentioned, specifically the 'next' function that produces each character. 'indexI n' is basically 'head (drop (n-1))' in stream speak
11:31:04 <RustyShackleford> just curious. Lack of a killer app is one thing people criticize Rust for
11:31:08 <luite> with some optimization using the size hint
11:31:26 <RustyShackleford> and i think it might be a decent way to guage how many people are using haskell
11:31:52 <platz> RustyShackleford: that's an odd comment about rust, considering rust is being created specifically for Servo
11:32:24 <EvanR-work> luite: i see, indexI is indeed O(n), like !! (only faster im sure), but seems weird for the function `stream' to be labeled O(n)
11:34:26 <athan> Can we have instance heads for type family instances?
11:34:28 <luite> EvanR-work: uh, same reason that 'x ++ y' for length x ~ n is usually called O(n)
11:34:41 <EvanR-work> ok
11:35:03 <benzrf> EvanR-work: stream?
11:35:49 <EvanR-work> talking about the fusion internals of Data.Text
11:36:04 <benzrf> what does stream do?
11:36:14 <EvanR-work> converts a Text into a stream of Chars
11:37:19 <luite> anyway i was porting that Data.Text fusion stuff to JS strings and i should get back to doing that, since i'd like to get it working today (and add it to ghcjs-base) :)
11:37:40 <EvanR-work> awesome
11:37:58 <nitrix> EvanR-work: Wouldn't you recommend `MaybeT IO BlockId` instead of `IO (Maybe BlockId)` ?
11:38:10 <EvanR-work> for what purpose?
11:38:56 <nitrix> An IO that may succeed/fail, but transformed into either a Just BlockId or Nothing.
11:39:22 <nitrix> I don't like the IOError system, I don't need to know why for that particuliar case. It just works or it doesn't.
11:39:31 <EvanR-work> it depends on the rest of your program whether its in IO or MaybeT
11:39:52 <nitrix> Surely the entire program cannot be in MaybeT :/
11:39:53 <EvanR-work> you cant compose a function IO (Maybe a) together
11:40:00 <EvanR-work> a bunch of*
11:40:06 <nitrix> Though, I do use IOs and Maybes a looot.
11:40:29 <nitrix> Mhhh..
11:40:48 <EvanR-work> MaybeT IO will let you cancel in a variety of contexts, without mucking about
11:43:12 <johnw> nitrix: if you do it systematically, then MaybeT IO, otherwise just IO Maybe
11:43:38 <johnw> if you have just one MaybeT IO out of a sea of other functions, then you have annoyingly use runMaybeT whenever you want to call it
11:43:46 <sx> How am I supposed to use number literals with the DataKinds extension?
11:44:07 <sx> or is my GHC version too old (7.6.3) ?
11:44:24 <johnw> import GHC.TypeLits
11:44:28 <johnw> it shouldn't be too old
11:44:50 <johnw> data Foo : :Nat -> * where Foo :: Nat (1 + 2)
11:44:54 <johnw> data Foo : :Nat -> * where Foo :: Foo (1 + 2)
11:44:58 <johnw> that should work in 7.6.3
11:45:23 <benzrf> whats with the : spacing :?
11:45:37 <johnw> nothing
11:45:52 <johnw> Just wasn't watching what I was typing carefully enough
11:46:05 <sx> johnw: Shouldn't I be able to use e.g. Int with it?
11:46:23 <johnw> no, Int is not what you want
11:46:41 <sx> johnw: Or can't I use that, because Int has no visible constructors?
11:46:44 <johnw> it doesn't use constructors to differentiate values, so pattern matching on it is not illuminating
11:47:01 <johnw> even if it had a visible constructor, it would be I# <some binary pattern>
11:47:16 <sx> johnw: That is very unsatisfying.
11:47:20 <johnw> why is that?
11:47:57 <athan> Can we have kind-polymorphic type families, with type variables in our instances?
11:48:05 <sx> johnw: Well I want to implement some type, which uses numeric constant in arithmetic operations. I wanted to implement this with the DataKinds extension.
11:48:15 <johnw> ok, you can still do that
11:48:25 <johnw> you use the kind Nat, rather than the type Int
11:48:41 <sx> johnw: What if the constants are floating point numbers?
11:48:48 <johnw> Int wouldn't work for that either
11:48:52 <EvanR-work> type level floats
11:49:24 <sx> EvanR-work: Well, but at the same time those constants should exist on the value level.
11:49:52 <sx> Such that you can work with them, like they were real values.
11:49:58 <johnw> I'm not sure that GHC will automatically turn 7.4 into a type-level float (not sure it even has any notion of type level floats)
11:50:17 <ReinH> johnw: o/
11:50:21 <johnw> but you can make a float encoding yourself, and use the singletons library to build the math you'll need to work with it
11:50:23 <johnw> ReinH: hello!
11:50:28 <EvanR-work> -XDependentTypes
11:51:04 <athan> !! EvanR-work what does this contraption do?!
11:51:06 <EvanR-work> but floats sounds insane to work with
11:51:15 <EvanR-work> athan: no idea i made it up
11:51:16 <athan> type level reals lol
11:51:21 <athan> oh dang it
11:51:32 <athan> I'm working on some type madness right now
11:51:38 <johnw> data TypeFloat :: Nat -> Nat -> * where F :: n -> m -> Float n m
11:52:01 <athan> wondering if we can have a type family like `type family (a :: k) (as :: [k]) :: Constraint`
11:52:04 <johnw> I wonder if DataKinds will promote that GADT, or if you have to write that using type families
11:52:12 <athan> (insert name `NotIn`)
11:52:20 <johnw> athan: why couldn't you?
11:52:29 <johnw> seems like a perfectly reasonable type family to me
11:52:33 <athan> johnw: Well, I think there's an issue with overlapping instances
11:52:37 <athan> well it's kind polymorphic
11:52:38 <athan> idk
11:52:41 <johnw> try it!
11:52:48 <athan> I'm getting an err :\
11:52:59 <johnw> that is not sufficient for me to help
11:53:02 <athan> it's an illegal test declaration
11:53:07 <johnw> still not
11:53:12 <kranius> hello, is there a way to 'chain' two or more elemIndex functions on different input lists, yielding Nothing if they all return Nothing or Just Int and discarding the rest of the functions ?
11:53:15 <ClaudiusMaximus> sx: could you use the reflection package to do what you want?
11:53:24 <EvanR-work> johnw: youre forgetting infinity and nan ;)
11:53:29 <athan> I'm trying to make my basis as `type instance NotIn x '[] = ()`
11:53:34 <johnw> kranius: yes, which one do you want to discard?
11:53:40 <athan> and that's where the error happens :P
11:53:50 <athan> maybe a forall....?
11:54:03 <johnw> athan: without a paste, none of this means much
11:54:07 <kranius> johnw: I want to keep the first one
11:54:09 <EvanR-work> kranius: yes, with Maybe's Monad instance
11:54:15 <ClaudiusMaximus> sx: http://hackage.haskell.org/package/reflection-1.5.1/docs/Data-Reflection.html
11:54:36 <johnw> kranius: then you'll want <|>
11:54:46 <johnw> kranius: elemIndex ... <|> elemIndex ...
11:54:51 <sx> ClaudiusMaximus: Not sure what it does, I just hoped that number literals could be used together with DataKinds in a more consistent way.
11:54:55 <johnw> returns the first Just to succeed, or Nothing if both fail
11:55:03 <ClaudiusMaximus> sx: https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
11:55:14 <kranius> johnw: sweet
11:55:53 <athan> johnw: I just don't want to use singletons and `Foo ~ 'True` everywhere :\
11:56:12 <athan> WAIT
11:56:14 <athan> IT WORKS
11:56:17 <athan> holy poo
11:57:19 <sx> ClaudiusMaximus: wow, that's some heavy stuff :)
11:57:43 <athan> johnw: How about this: `type instance (a =/= b ~ 'True) => NotIn a (b ': ts) = NotIn a ts`
11:57:53 <athan> can we not have instance heads for type families?
11:58:56 <fizruk> hey guys! what’s the nicest network/streaming library as of today? I would like to use it for a simple client-server game (something not harder than tic-tac-toe or checkers). I need client and server to exchanges serialized objects correctly, but using conduits/pipes seems to be an overkill (though I am not aware of an alternative). thanks in advance :)
11:59:36 <johnw> what if you did type instance (a ~ b) => NotIn a (b ': ts) = Void ; type instance NotIn a (b '; ts) = NotIn a ts
12:00:00 <Pamelloes> Does anyone know how fmap works in the context of the free monad?
12:00:06 <johnw> Pamelloes: yes, what is the question?
12:00:10 <athan> johnw: That might be an idea. Is Void a constraint?
12:00:17 <johnw> no, it's a type
12:00:19 <athan> I thought it was basically bottom
12:00:22 <athan> ahh okay hmm
12:00:30 <johnw> oh, you need this to identify a Constraint, right
12:00:32 <johnw> ok, n/m then
12:00:43 <sinelaw> can anyone recommend a static blog generator? besides hakyll
12:00:46 <athan> my type families are constraints yeah, so non-deducability is ideal instead of a refutation
12:00:55 <johnw> Pamelloes: fmap over any type will change the mapped 'a' to 'b', so Free f a because Free f b
12:00:57 <sinelaw> something more simple, with plain html input
12:01:06 <athan> johnw: I'm checking out edk's reflection lib right now, might be a solution :)
12:01:16 <Hijiri> Pamelloes: If its pure, it just applies the function, and if it's f Free ..., it fmaps the function into the f (Free f a)
12:01:19 <Pamelloes> johnw: That actually helps a lot
12:01:19 <johnw> fmap f (Pure a) = Pure (f a); fmap f (Free m) = Free (fmap f m)
12:01:32 <benzrf> johnw: wrong
12:01:36 <benzrf> johnw: fmap (fmap f) m
12:01:45 <johnw> ah, thank you
12:01:49 <benzrf> =p
12:01:55 <johnw> thanks for the correction
12:02:01 <benzrf> np :)
12:03:05 <Pamelloes> So a function a->b mapped over Free f a would result in Free f b?
12:03:14 <Pamelloes> Is there a way I could map over (f a)?
12:04:16 <benzrf> Pamelloes: yes, map a function that takes (f a)
12:04:20 <drewbert> Is it possible, using Template Haskell to represent in a type signature "a Name of a Type that is an instance of a given TypeClass"?
12:05:46 <drewbert> I've got some types that are instances of ToJSON and the compiler is complaining that the type variable is ambiguous.
12:06:12 <hub2> Hi, Could you tell me what "st" is in Parsec GenParser monad?
12:06:39 <fizruk> drewbert: something like reifyInstances might help?
12:07:28 <drewbert> I'll take a look at that, fizruk, thanks.  I'm new to haskell and super new to template haskell.
12:07:31 <Cale> hub2: Is it a type variable?
12:07:42 <fizruk> hub2: user state probably
12:07:59 <Cale> hub2: Parsec supports a user-specified state type just for convenience.
12:08:04 <fizruk> drewbert: you sure you need TH?
12:08:45 <geekosaur> also, sounds like parsec2...
12:10:03 <hub2> Thanks
12:12:00 <athan> There is talk about Rank-N types "protecting" types from unifying, or being "leaked"... is there a good way to get a feel for this?
12:12:12 <sx> I reformulated my problem a bit: http://codepad.org/jnbljAvL , shouldn't it be possible to use any value at the type level with the DataKinds extension?
12:14:43 <EvanR-work> sx: the extension says "any suitable datatype" so I'm guessing this means normal ADTs with constructors
12:14:57 <EvanR-work> not Float not unboxed ints and stuff
12:15:00 <nitrix> How can I have multiple IO () expressions inside my `MaybeT IO ()` without going crazy with do's everywhere?
12:15:08 <Pamelloes> I just changed a datatype and wound up with nearly 400 lines of errors....... there are times when I hate programming
12:15:12 <nitrix> Is there an idomatic way to do this?
12:15:31 <jle`> Pamelloes: this is actually one of the best things about haskell
12:15:39 <EvanR-work> you mean liftIO?
12:15:42 <jle`> Pamelloes: in other languages, those would be 400 hours of run-time debugging :P
12:16:00 * hackagebot hspec-server 0.4.0 - Test Framework for checking server's status  http://hackage.haskell.org/package/hspec-server-0.4.0 (junjihashimoto)
12:16:01 <sx> EvanR-work: That's very heavy limitation, makes it unusable with any record type containing such types.
12:16:28 <Pamelloes> jle`: Unfortunately only three of those errors were actual errors. The other 397 are now incorrectly typed unit tests.
12:16:48 <jle`> welp. unit tests >_>
12:16:52 <Pamelloes> I think it's time for me to brush up on my regex skills.
12:17:17 <sx> EvanR-work: I wanted to implement addition for elliptic curves, and there is no way to implement it type safe without this.
12:17:43 <sx> Or do a less generalized version, but that is hardly satisfying.
12:17:45 <EvanR-work> sx: you can still do it, you just have to implement arithmetic over whatever normal data type
12:18:11 <sx> EvenR-work: It depends on some constants, which are inherent to that type.
12:18:27 <EvanR-work> well you can convert the constants
12:18:42 <nitrix> EvanR-work: Appreciated for liftIO. I'm surprised though, I keep using the package `transformers`. I thought Haskell's prelude has monad transformers?
12:18:57 <EvanR-work> Prelude? not
12:18:59 <vanila> sx, why not do the adition inside a context that you introduce like:  withCurve c3565 (p1 + p2)
12:19:14 <vanila> there is no funny type stuff but it should still be safe
12:19:45 <sx> vanila: That would work, but still I can mix up values of different curves. So as I said, it's not type safe. :)
12:19:59 <tolland> I am new to haskell and cabal and I'm trying to install bytestring-builder, but I am getting an error about "package requires Cabal library version -any && >=1.8 "
12:20:05 <vanila> it wouldnt' be possible to mix them inside a context
12:20:30 <tolland> is that cabal library related to the underlying cabal package, or something that can be installed from cabal
12:20:32 <sx> vanila: Sure, but that is a boundary I put there, I can break it whenever I want.
12:21:01 <geekosaur> usually you shouldn
12:21:10 <geekosaur> t upgrade the Cabal library as it's used by ghc
12:21:33 <geekosaur> (that said it's relatively safe, usually; people have had TH break after Cabal upgrades)
12:22:19 <tolland> so that 1.8 is referring to the yum package in this case? cabal-install-1.16.0.2-34.fc20.x86_64
12:22:44 <eviltwin_b> no
12:23:13 <eviltwin_b> first: there are two ghc pakages, somewhat unforutnately named. the library is Cabal; the "cabal" executable is cabal-install
12:23:24 <eviltwin_b> (the library predates the cabal program by quite a long time)
12:23:53 <eviltwin_b> it's complaining about the library. you probably can't upgrade either usefully via OS packages
12:24:38 <vanila> sx, I don't think so actually
12:25:15 <tolland> the bytestring-builder info doesn't explicitly mention the "cabal library" as a dependency, only base, deepseq and bytestring, which apepar to be installed, its hard to understand where that dep arises (to a newb)
12:26:21 <sx> vanila: And why is that? The language just gives you the possibility to break it, because the types do not deny addition of points from 2 different curves, you can do it.
12:26:29 <geekosaur> cabal-version:       >=1.8
12:27:08 <sx> vanila: Of course, you can prevent users of your library from breaking it, but the more clean approach would be to completely encode such details in the type. That's at least my opinion.
12:27:17 <vanila> with withCurve gives you something else then you can't mix them
12:27:58 <geekosaur> tolland, it's done that way because the cabal library is what parses the package descriptions, so it needs to be able to check compatibility *before* it tries to parse something it can't understand
12:27:59 <sx> vanila: But only if you use withCurve as single entry point.
12:28:17 <EvanR-work> kernel of validity
12:28:25 <sx> vanila: So it's a decision you make, but you should be forced to make it by the language.
12:28:33 <vanila> I don't exactly see what you mean by single entry point?
12:28:41 <sx> vanila: withCurve
12:31:12 <nitrix> Is there a flipped version of `Functor f => (a -> b) -> f a -> f b`    (<$>)
12:31:23 <EvanR-work> <&> in lens
12:31:28 <Iceland_jack> :t (<&>)
12:31:29 <lambdabot> Functor f => f a -> (a -> b) -> f b
12:31:32 <nitrix> f a, then the function, then f b ?
12:31:34 <nitrix> Oh sweet.
12:31:54 <nitrix> EvanR-work: It seems more natural to me this way.
12:31:59 <nitrix> <$> feels inverted :/
12:32:10 <EvanR-work> or just (<&>) = flip (<$>) in your code
12:32:22 <EvanR-work> well, <&> is the one thats inverted ;)
12:32:45 <EvanR-work> we write function application prefix most of the time
12:33:52 <vanila> sx, here's what I mean http://lpaste.net/118524 - im not sure if I didn't explain it fully or im missing something since I haven't understood about entry point
12:36:00 * hackagebot hackage-db 1.22 - access Hackage's package database via Data.Map  http://hackage.haskell.org/package/hackage-db-1.22 (PeterSimons)
12:38:00 <sx> vanila: Yes, I understood that. But let's assume all values greater than the modulus are invalid. You could then add invalid values.
12:38:23 <sx> vanila: So why not encode the modulus in the type of Frozen.
12:38:34 <vanila> values greater than modulus just get reduced
12:39:04 <sx> vanila: It's true that this works for modulus, but it doesn't work for elliptic curves. Some values do not lie on the curve.
12:39:17 <vanila> ah, I see your point
12:40:02 <vanila> you can use Either String to get error messages if someone names a point outside the curve
12:40:15 <vanila> btw, must this be written in haskell?
12:40:27 <sx> vanila: Yes, but why dynamic, if you could sort it out static?
12:41:04 <sx> vanila: Well, I know I can do it in C++ with templates, but I love writing code in Haskell. ;)
12:41:25 <vanila> ok - if you are really interested in encoding this in the type system I would recommend programming it in Coq
12:41:38 <vanila> you would be able to implement elliptic curves as a type very cleanly
12:42:08 <sx> vanila: I will have a look at it, thank you.
12:42:13 <vanila> I do recommend against trying to shoehorn that sort of thing into haskell though, it gets complicated (that's why I think a region based approach solves it better in that setting)
12:43:01 <nitrix> Any recommendations to improve this function? https://coderpad.io/DFQE3Y69
12:43:11 <nitrix> It's my first time using monad transformers (MaybeT).
12:43:19 <sx> vanila: I was just curius why that limitation exists in the first place. It could be done.
12:49:58 <Pamelloes> If I have "import qualified Data.Map as M", can I then make it so I can use Data.Map.! without prefixing it with "D"?
12:50:23 <nitrix> You mean M, not D?
12:50:29 <Pamelloes> yeah
12:50:32 <Pamelloes> oops
12:50:58 <indiagreen> nitrix: you can add another import
12:50:59 <geekosaur> import Data.Map ((!))
12:51:16 <Pamelloes> Awesome! Thanks :)
12:57:57 <srhb> Pamelloes: Or if you're not bothered by conflicts, there's also the option of import Data.Map as M. This brings everything into scope qualified and unqualified.
12:58:35 <Pamelloes> srhb: What's the point of importing qualified and unqualified?
12:58:57 <srhb> Pamelloes: That line would allow me to use ! and M.map for example.
12:59:59 <Pamelloes> What about unqualified map, would that refer to Data.Map.map or Data.List.map?
13:00:17 <srhb> That's still ambiguous, as if you'd just done import Data.Map
13:00:33 <srhb> But the M allows us to disambiguate it. :)
13:01:27 <Pamelloes> hm.... I'll remember that the next time I use ghci but I don't think I'd want to use it in any production code.
13:01:55 <srhb> No, the other version is clearer. I just wanted to mention the possibility. :-)
13:19:17 <Gurkenglas> My program makes a stack overflow for most input matrices. (What could be the reason?) I wanted to use Debug.Trace to see where it goes wrong, but my functions are all "nicely" generalized and so there is no Show in the type signature. unsafeCoerce :: a -> Double got me different values on different runs, and they also don't make sense, so either those values thrown around back there aren't Doubles or unsafeCoerce doesn't work tha
13:20:19 <srhb> Gurkenglas: More information needed. Like, what is your program doing.
13:20:53 <srhb> (Also your message got cut off after "doesn't work tha"
13:21:00 <Gurkenglas> *t way
13:22:07 <srhb> Aha. :)
13:22:20 <Martin_F> Gurkenglas, it might be better to temporarily add a Show constraint while debugging, rather than getting unsafeCoerce involved
13:22:24 <Martin_F> Gurkenglas, it might be better to temporarily add a Show constraint while debugging, rather than getting unsafeCoerce involved
13:22:59 <Martin_F> Er. Damn you and your treachery, up-arrow key!
13:23:40 <Gurkenglas> Like, all the way up the call hierarchy?
13:25:58 <Martin_F> Hmm. Depending on its size, yeah, that could be a bit of a pain. I was just thinking it'd be more straightforward to reason about.
13:26:00 <Gurkenglas> (My program would take a lil while to explain, but its function shouldn't be too important. It implements http://en.wikipedia.org/wiki/Jacobi_method and some related stuff for a university course.
13:26:07 <Gurkenglas> *)
13:27:16 <Martin_F> Could the ghci debugger help?
13:28:06 <Gurkenglas> Also, I was getting rubbish results because I coerced to Double rather than [Double]. Is unsafeCoerce :: (a->a) reliably equal in the result to id?
13:28:26 <ReinH> Gurkenglas: No, unsafeCoerce is not reliable.
13:28:32 <ReinH> The "unsafe" part is a giveaway there ;)
13:28:55 <shachaf> Gurkenglas: unsafeCoerce :: a -> a should always be id
13:28:57 <ReinH> Gurkenglas: stack overflows in Haskell are usually caused by non-strict evaluation. The solution is usually to add strictness annotations, but without knowing more about the way your program evaluates, we can't suggest where to put them.
13:29:17 <peddie> Gurkenglas: can you work your way up the call hierarchy with a test case rather than running the whole thing and resorting to sketchy methods to inspect?
13:30:18 <benzrf> Gurkenglas: do you understand when/why stack overflows happen?
13:30:32 <peddie> (or at least comment out your signatures and allow GHC to infer the "Show" constraint, rather than using unsafeCoerce for this?)
13:30:42 <benzrf> ReinH: huh... isn't strictness /more/ likely to cause a stack overflow?
13:30:57 <Gurkenglas> ReinH, is unsafeCoerce not even reliable in the way shachaf confirmed?
13:31:33 <ReinH> Gurkenglas: If shachaf and I disagree, shachaf is usually right. I missed the (a -> a) part.
13:31:43 <Gurkenglas> benzrf, when thunk size diverges?
13:31:44 <ReinH> benzrf: why?
13:32:43 <Martin_F> Benzrf, it varies, really. The canonical example of when laziness is a problem is `foldl 1 (+) aVeryLongList`
13:33:05 <Iceland_jack> Gurkenglas: If you have 'Coercible a b => a -> b' then unsafeCoerce works because they're representationally equal
13:33:37 <benzrf> ReinH: well..
13:33:47 <benzrf> ReinH: the call stack gets used when something is forced, right?
13:33:59 <benzrf> doesn't strictness amount to forcing more than is necessary for evaluation?
13:34:16 <Gurkenglas> I was using unsafeCoerce because I "knew" that the value being passed around was a Double, but Debug.Trace didn't.
13:34:19 <Martin_F> ... as that traverses the whole list before forcing the accumulator, you get a very large thunk (x0 + x1 + x2 + ... + xN)
13:35:07 <dgpratt> so I had a yesod question and I found an answer right here http://stackoverflow.com/questions/18636714/yesod-site-links-to-localhost-css-files
13:35:20 <dgpratt> but now I have a question about the answer
13:35:21 <Martin_F> while foldl' would force the accumulator as it goes, so it'd always be just an Int (or whatever) - much smaller.
13:35:30 <benzrf> ah wait i see
13:35:48 <benzrf> the strictness /does/ cause the call stack to be used, but it's a temporary diversion
13:35:49 <dgpratt> why does yesod init create the setting when it seems to work better to leave it as the default
13:35:55 <benzrf> but
13:35:57 <dgpratt> ?
13:36:05 <ReinH> benzrf
13:36:06 <dgpratt> I always forget the ? !
13:36:14 <benzrf> ReinH: ?
13:36:17 <ReinH> Woops
13:37:49 <ReinH> benzrf: My answer is a bit of an oversimplification. Given Gurkenglas's use case I assumed that foldl-style recursion would be used.
13:38:07 <benzrf> ReinH: strict /recursion/ though would cause an overflow wouldnt it
13:38:15 <benzrf> just like it does in imperative languages
13:38:24 <ReinH> What do you mean by "strict recusion"?
13:38:35 <benzrf> hmm
13:39:16 <benzrf> @let f 0 = 0; f x = 1 + f (x - 1)
13:39:16 <lambdabot>  .L.hs:161:11:
13:39:17 <lambdabot>      Ambiguous occurrence ‘f’
13:39:17 <lambdabot>      It could refer to either ‘L.f’, defined at .L.hs:160:1
13:39:19 <benzrf> dang
13:39:20 <ReinH> foldl-style recursion doesn't accumulate stack frames for the recursion itself.
13:39:26 <benzrf> @let st 0 = 0; st x = 1 + st (x - 1)
13:39:28 <lambdabot>  Defined.
13:39:34 <benzrf> > st 1000000
13:39:37 <lambdabot>  mueval-core: Time limit exceeded
13:39:44 <benzrf> n-no stack overflow?
13:40:12 <ReinH> That's foldr-style recursion, and the default stack size in 7.8 is pretty large now iirc
13:40:34 <ReinH> So lambdabot probably times out first for many things
13:42:08 <ReinH> benzrf: A more accurate answer might be that non-strictness is important for productive recursion (foldr-style) while strictness is important for "tail-recursion" (foldl-style).
13:42:36 <ReinH> So getting back to Gurkenglas's question, without knowing how his code evaluates, it's difficult to predict why it is causing a stack overflow.
13:42:45 <ReinH> s/his/their
13:43:12 <benzrf> :)
13:43:19 <nitrix> Sorry, what exactly is an Applicative and why does it defines <$> if its signature is a Functor?
13:43:26 <benzrf> :t (<$>)
13:43:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:43:39 <Martin_F> ?src <$>
13:43:40 <lambdabot> f <$> a = fmap f a
13:43:41 <Iceland_jack> nitrix: It doesn't define (<$>)
13:43:41 <benzrf> nitrix: an Applicative is like a functor but with some extra methods that you cant do for functors in general
13:43:45 <ReinH> nitrix: An Applicative is a Functor that also has pure and (<*>). It defines (<$>) = fmap as a convenience for use with (<*>).
13:44:01 <benzrf> nitrix: Control.Applicative exports (<$>) because it's useful in concert with some other applicative features
13:44:04 <nitrix> And what is the purpose of pure ?
13:44:08 <ReinH> so you can say f <$> x <*> y instead of f `fmap` x <*> y
13:44:08 <Iceland_jack> nitrix: These are the only two things Applicative defines:
13:44:09 <Iceland_jack> @src Applicative
13:44:09 <lambdabot> class Functor f => Applicative f where
13:44:09 <lambdabot>     pure  :: a -> f a
13:44:09 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:44:24 <nitrix> Oh I see
13:44:40 <nitrix> Wait, isn't pure like `return` ?
13:44:42 <ReinH> f <$> x <*> y = pure f <*> x <*> y -- is also part of the reason pure exists
13:44:46 <Iceland_jack> nitrix: Yes.
13:44:47 <ReinH> nitrix: Yes.
13:44:55 <Iceland_jack>     pure :: a -> Maybe a
13:44:55 <Iceland_jack>     pure x = Just x
13:44:56 <nitrix> But but but, what's the purpose then.
13:45:05 <Iceland_jack> Historical reasons
13:45:24 <Iceland_jack> @src Maybe pure
13:45:24 <lambdabot> pure = return
13:45:26 <Iceland_jack> @src [] pure
13:45:26 <lambdabot> pure = return
13:45:32 <ReinH> nitrix: For historical reasons, Monads are not necessarily Applicative and so don't necessarily have pure = returns
13:45:34 <Iceland_jack> @src IO pure
13:45:35 <lambdabot> pure = return
13:45:43 <ReinH> But they do as of the...
13:45:45 <Iceland_jack> Oh lambdabot.
13:45:47 <ReinH> @google applicative monad proposal
13:45:48 <Martin_F> nitrix, "pure x" means "the value x in the Applicative, with no 'side-effects'."
13:45:48 <lambdabot> https://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
13:46:00 <nitrix> Mhhh...
13:46:06 <nitrix> So the IO monad would be Applicative then?
13:46:14 <nitrix> Not necessarily all monads?
13:46:17 <benzrf> nitrix: *IO is an Applicative
13:46:25 <benzrf> nitrix: "the IO monad" refers to IO's behavior as a monad
13:46:34 <ReinH> Morally, pure = return is expected to hold for every type that is both Applicative and Monad, and in 7.10 it will be required to hold.
13:46:35 <benzrf> nitrix: well, all monads are applicatives
13:46:37 <fizruk> nitrix: every monad is secretely an applicative
13:46:43 <Iceland_jack> That's quite pedantic
13:46:49 <benzrf> nitrix: you can define an applicative instance from the monad methods
13:46:49 <sivteck> a monad is an applicative is a functor
13:47:25 <ReinH> nitrix: pure = return and (<*>) = ap, but historically this wasn't guaranteed so we needed both.
13:47:33 <ReinH> (and fmap = liftM)
13:47:49 <nitrix> Does this means they'll eventually get rid of one of the other?
13:47:54 <nitrix> It find it very confusing for no reason.
13:48:08 <Gurkenglas> If anyone wants to, they can look at my failure here: https://www.fpcomplete.com/user/Gurkenglas/angemathe -> Aufgabe1_2
13:48:10 <Iceland_jack> They won't get rid of them because it would break a lot of code
13:48:30 <nitrix> I was explained Haskell's purpose wasn't stability.
13:48:34 <EvanR-work> some applicatives arent monads
13:48:36 <ReinH> nitrix: No. Every Monad is an Applicative, but the converse is not true.
13:48:48 <ReinH> Some Applicative instances lack join.
13:48:55 <Martin_F> nitrix, for example, in Maybe, the only possible 'side-effect' is failure (ie Nothing) - and Just x is a 'pure' value. So pure = Just.
13:49:00 <nitrix> ReinH: And every applicative is a functor, but the converse isn't true?
13:49:06 <ReinH> nitrix: Also true.
13:49:09 <sivteck> yes
13:49:30 <Chathurga> My rule is, use the version of the function that is most general
13:49:44 <nitrix> Why not just use Monads everywhere then.
13:49:54 <nitrix> If they offer all and beyond :/
13:49:58 <ReinH> nitrix: Because some things are not Monads.
13:49:58 <Iceland_jack> Some things aren't Monads
13:50:10 <Chathurga> Using Functor is more general than Monad, and it more clearly specifies what behaviors you're actually using
13:50:11 <Martin_F> Monads are less general than Applicatives
13:50:31 <sinelaw> is SDL  broken since 7.8?
13:50:54 <sinelaw> http://comments.gmane.org/gmane.comp.lang.haskell.beginners/13663
13:50:57 <nitrix> Mhh, well, I made little progress, but it's progress nontheless.
13:51:00 <nitrix> Thanks guys.
13:51:01 <Chathurga> I mean using fmap over liftM, using fmap more clearly communicates, to me, what you're trying to do
13:51:17 <Martin_F> In this context, "more general" means "has more possible instances"
13:51:31 <EvanR-work> is there an example of a Functor type that can't have an Applicative or Monad instance that satisfies the laws?
13:52:15 <Iceland_jack> nitrix: Const is one
13:52:18 <Chathurga> EvanR-work: Const is a Functor but not an Applicative
13:52:25 <tommd> sinelaw: Easy fix, but yes.
13:52:43 <sinelaw> ugh.
13:53:26 <sinelaw> easy fix != installable by a random user
13:53:38 <benmachine> nitrix: the less you ask of a type, the more types will be able to satisfy it, so the least powerful functions are also the most widely available
13:53:41 <Iceland_jack> Oops, that was meant for EvanR-work
13:53:42 <sinelaw> they can't just run 'cabal install' on my package.
13:53:53 <Iceland_jack> EvanR-work: Tuples are a more interesting example
13:53:53 <tommd> sinelaw: I wasn't claiming that being broken is ok.
13:54:13 <Martin_F> And each operation you know you can do on a type reduces the space of possibilities of what that type could be - so bigger typeclass => less general
13:54:15 <EvanR-work> tuples
13:54:17 <Iceland_jack> You can't construct:
13:54:17 <Iceland_jack>     pure :: a -> ((,) e) a
13:54:37 <EvanR-work> so Writer has a Monoid constraint because of this
13:54:43 <Iceland_jack>     pure :: a -> (e, a)
13:54:43 <Iceland_jack> Yes
13:55:01 <Iceland_jack> Because you can't get some "e" out of thin air
13:55:13 <EvanR-work> but fmap works
13:55:14 <Iceland_jack> but if it has a Monoid constraint then you can use "mempty"
13:55:16 <Iceland_jack> Yes
13:55:50 <EvanR-work> and if we used Monad "for everything" everything would have to be a monoid
13:55:51 <Martin_F> fmap f (e, x) = (e, f x)
13:56:14 <platz> I think there is confusion between "more general" and "more expressive"
13:56:47 <fizruk> perhaps now’s a better time to ask… what’s the nicest simple network/streaming library as of today? I would like to use it for a simple client-server game (something not harder than tic-tac-toe or checkers). I need client and server to exchanges serialized objects correctly, but using conduits/pipes seems to be an overkill (though I am not aware of an alternative). thanks in advance :)
13:57:02 <Martin_F> There is, it's not entirely intuitive that they're atonyms
13:57:32 <Chathurga> In this context I use the term general to mean the type requires less stipulations
13:57:52 <ReinH> nitrix: For example, id :: a -> a is very general. It works for all types. impossible :: a -> b is so specialized that it has no possible implementations whatsoever (ignoring unsafeCoerce, which cheats).
13:58:16 <nitrix> Yeah you cannot get anything to anything, right?
13:58:22 <ReinH> nitrix: Right.
13:58:24 <nitrix> *anything else
13:58:37 <shachaf> undefined and const undefined are also implementations in Haskell.
13:58:43 <nitrix> I'd need to learn Kinds again. Someone took the time before to wal kme through.
13:58:52 <ReinH> shachaf: Good point. Something something morally correct.
13:58:53 <nitrix> On my first day with Haskell, lol.
13:59:12 <ReinH> nitrix: I should say no implementations other than those involving bottom.
13:59:13 <benzrf> fizruk: well if you're asking about networking
13:59:19 <benmachine> shachaf: what about unsafeCoerce?
13:59:21 <benzrf> fizruk: you /could/ just use plain rcp
13:59:26 <benzrf> *tcp
13:59:27 <Chathurga> Does Haskell call them Kinds because it's another word for type?
13:59:35 <Narfinger> hiho, i have a function which is defined by \x -> (head $ filter (\y -> True)) x, disregard the filter condition for the moment: i am wondering if there is a better way than the extra lambda but the parenthesis are just weird for this
13:59:36 <shachaf> benmachine: unsafeCoerce was already mentioned
13:59:42 <benzrf> fizruk: if you want something higher level, i myself am i fan of ØMQ
13:59:50 <benmachine> shachaf: oh, sorry, not following everything
14:00:01 <benzrf> Narfinger: (head $ filter (\y -> True))
14:00:02 <shachaf> benmachine: (But it exists "less" than undefined, probably.)
14:00:05 <benzrf> Narfinger: wait, what
14:00:10 <benzrf> Narfinger: that's not well-typed
14:00:15 <benmachine> shachaf: :P interesting
14:00:17 <ReinH> benmachine: unsafeCoerce cheats by making use of the machine-level representation.
14:00:27 <Narfinger> the filter gets the input (x) but after filter has done its stuff i want the head of it
14:00:29 <ReinH> Maybe machine-level is the wrong term.
14:00:32 <shachaf> benmachine: If you're willing to accept unsafeCoerce as a distinct inhabitant of that type then you should also accept (unsafeCoerce 'a' :: a -> b).
14:01:02 <Narfinger> perhaps i am messing something up
14:01:05 <benmachine> shachaf: right, by bringing up unsafeCoerce my intention is to illustrate there are some things that are Haskell in a sense that we nevertheless sometimes want to ignore
14:01:18 <ReinH> :t  \x -> (head $ filter (\y -> True))
14:01:19 <lambdabot>     Couldn't match expected type ‘[a]’ with actual type ‘[a0] -> [a0]’
14:01:19 <lambdabot>     Probable cause: ‘filter’ is applied to too few arguments
14:01:19 <lambdabot>     In the second argument of ‘($)’, namely ‘filter (\ y -> True)’
14:01:35 <ReinH> :t  \x -> (head $ filter (\y -> True)) x
14:01:36 <lambdabot>     Couldn't match expected type ‘[t1 -> t]’
14:01:36 <lambdabot>                 with actual type ‘[a0] -> [a0]’
14:01:36 <lambdabot>     Relevant bindings include x :: t1 (bound at <interactive>:1:2)
14:01:41 <benmachine> I think we often want to ignore undefined and const undefined, especially the distinction between them, but it's certainly also true that sometimes we don't want to
14:01:43 <ReinH> Sorry.
14:01:48 <EvanR-work> theres so many "cheats" maybe we could take them all out back and build a whole language out of them, and leave Hask in peace ;)
14:02:08 <fizruk> benzrf: I want client/server to pass around objects of, say, data Cmd = CmdMove Position | CmdQuit | CmdNewGame PlayerColor OpponentType
14:02:10 <ReinH> benmachine: unsafeCoerce isn't a thing in *Haskell*, though. It's a thing in an implementation of Haskell.
14:02:11 <Narfinger> now i am confused why that is not typed...
14:02:49 <shachaf> benmachine: I just objected to "it has no possible implementations other than unsafeCoerce".
14:02:54 <benmachine> ReinH: do you say the same about GHC-specific language extensions? that would seem contrary to what people think of when they say Haskell
14:02:54 <benzrf> fizruk: ØMQ is quite nice
14:03:05 <benzrf> fizruk: if you feel like doing serialization and deserialization manually
14:03:06 <shachaf> But it's a silly argument.
14:03:07 <fizruk> benzrf: network-simple does not allow me to do that, I need something extra to recv Cmd instead of ByteString
14:03:13 <benmachine> shachaf: I see what you mean
14:03:21 <fizruk> benzrf: I’ll take a look
14:03:23 <Martin_F> Narfinger, f $ x = f x, so you're trying to take the head of (filter p) - which is a function, not a list
14:03:27 <benzrf> fizruk: oh, uh
14:03:32 <benzrf> fizruk: you still recv bytestring
14:03:36 <Narfinger> ok \x -> (head $ filter (\y -> True) x) has a type for me
14:03:39 <EvanR-work> fizruk: the Binary type class makes the serialization and deserialization easy
14:03:44 <benzrf> fizruk: ØMQ is language-agnostic and only transports blobs
14:04:06 <Narfinger> [a]-> a and now i wonder if there is a shorter way
14:04:16 <benzrf> Narfinger: /that/ works
14:04:30 <ReinH> benmachine: I think there is a difference between the two, but really I'm happy to take on unsafeCoerce as a special case, so it's not worth arguing over. :)
14:04:41 <Narfinger> yeah but is there a shorter or more haskell way?
14:04:48 <Martin_F> Narfinger - indeed. Now, to simplify it, note (f $ g x) = (f . g) x
14:05:21 <ReinH> well, you can easily get rid of the whole lambda.
14:05:27 <fizruk> EvanR-work: yeah, Binary, Serialize, ToJSON/FromJSON, these are not the problem, the receive part is: I want to receive a whole command (to to push byte leftovers back)
14:05:30 <Narfinger> ah
14:05:32 <Narfinger> thanks
14:05:53 <Martin_F> Narfinger, and (\x -> f x) = f
14:05:54 <benmachine> ReinH: I wasn't particularly trying to push an agenda or anything, mostly just thinking out loud
14:05:58 <EvanR-work> fizruk: well thats a very specific protocol...
14:06:05 <agocorona> It is very helpful at some moment in haskell programming to forget math and think that  programming  is nothing but to construct syntactically valid sequences of symbols.  At last. that is what Rienmann told about maths. The good thing is that we have a very good tool, the compiler, for this task
14:06:15 <Martin_F> (this second step is called "eta reduction")
14:06:32 <Narfinger> yeah that i know already
14:06:36 <EvanR-work> agocorona: and then after the syntax is well formed, it must type check ;)
14:06:55 <EvanR-work> then youre good
14:07:18 <ReinH> benmachine: I think the distinction is that unsafeCoerce is implementation-specific. It requires inspecting the actual in-memory representation. Most language extensions are just parts of the Haskell language that aren't yet but could be made official parts of the special.
14:07:46 <dzhus> fizruk: you'll still have to send bytestrings through socket; to read whole command simply encode packet length in its header
14:07:58 <ReinH> benmachine: And since the Haskell spec almost entirely avoids specifying operational semantics, I don't imagine unsafeCoerce *would* be added to the language per se.
14:08:11 <ReinH> s/special/spec
14:08:26 <EvanR-work> dzhus: this is taken care of by a standard Binary instance for Message
14:08:35 <EvanR-work> or Command
14:08:35 <benmachine> ReinH: I could imagine it being added to the spec with only partially-specified semantics
14:08:43 <zipper> How can I convert 8 bit ascii charachters to hex? Is there a library doing this?
14:08:59 <benmachine> ReinH: I mean, after all, with the FFI addendum I think unsafePerformIO is in the spec now, and you can write unsafeCoerce with it
14:09:16 <EvanR-work> zipper: theres no such thing as 8-bit ascii
14:09:19 <ReinH> benmachine: fair enough.
14:09:38 <shachaf> benmachine: Where is unsafePerformIO in Haskell 2010?
14:09:53 <EvanR-work> > printf "%02x" 129
14:09:55 <lambdabot>  No instance for (GHC.Show.Show a0)
14:09:55 <lambdabot>    arising from a use of ‘M466731312488127090816227.show_M4667313124881270908...
14:09:55 <lambdabot>  The type variable ‘a0’ is ambiguous
14:10:00 <carter> bgamari: csv from csvs?
14:10:00 <EvanR-work> > printf "%02x" 129 :: String
14:10:01 <lambdabot>  "81"
14:10:09 <fizruk> EvanR-work: I want to cat all the input ByteStrings and parse them into a list of commands, this can be done with conduits (and pipes?), but they seem to introduce some boilerplate code (which makes a simple communication ridiculously complex to a newcomer)
14:10:24 <zipper> EvanR-work: Wow okat just ascii to hex
14:10:28 <dzhus> EvanR-work: what package is Message/Command part of?
14:10:32 <Gurkenglas> Is there some way to get libraries like this one to work on fpcomplete? http://hackage.haskell.org/package/linearEqSolver-1.2/docs/Math-LinearEquationSolver.html
14:10:46 <zipper> EvanR-work: 8 bit ascii are the chars that go up to 255
14:10:46 <bgamari> carter, I ended up just hacking together a python script
14:10:51 <Gurkenglas> (I'm trying to substitute that broken part of my program for an external one.)
14:10:57 <carter> bgamari: challenge accepted
14:10:59 <EvanR-work> fizruk: if youre interested in dealing with errors correctly, then youll need something like that. a lazy input bytestring could otherwise be easily decoded into a lazy list of commands using Binary
14:11:06 <carter> its something i'll think about
14:11:10 <zipper> EvanR-work: What is there? Either ascii or not ascii?
14:11:11 <carter> still onboarding new gig
14:11:12 <Gurkenglas> (Umm, vice versa.)
14:11:18 <fizruk> EvanR-work: benzrf: I was thinking of just concatenating and parsing ByteString -> [Cmd] in a separate thread and another thread to readTChan commands
14:11:19 <EvanR-work> dzhus: hypothetical thing that fizruk will make
14:11:52 <EvanR-work> zipper: terminology issue, characters above 127 are definitely not ascii
14:12:03 <benmachine> shachaf: https://www.haskell.org/onlinereport/haskell2010/haskellch30.html
14:12:08 <EvanR-work> they arent even corresponding to most extended asciis
14:12:10 <fizruk> dzhus: just any serializable data type
14:12:12 <Gurkenglas> (...oh, that one needs external programs to interact with.)
14:12:26 <shachaf> benmachine: Yo49 commentsshare
14:12:31 <shachaf> Er.
14:12:41 <zipper> Is there something I can use to convert ascii chars to hex chars in haskell?
14:12:56 <shachaf> benmachine: You're not allowed to write unsafeCoerce with that. It's very restricted.
14:13:02 <EvanR-work> zipper: printf "%02x" (ord c)
14:13:04 <bgamari> carter, I want something like https://github.com/kolmodin/binary/pull/65
14:13:14 <bgamari> carter, (the table in the head)
14:13:30 <Martin_F> zipper, EvanR's being slightly pedantic, is all. I think what he's getting at is (by my guess) you want to convert a list
14:13:45 <AshyIsMe> is there sort function for sorting a list of tuples by the fst or snd of each one?
14:13:46 <geekosaur> :t showHex
14:13:46 <lambdabot> (Show a, Integral a) => a -> ShowS
14:13:51 <benmachine> shachaf: true, but it's an example of a function whose semantics are partially-specified
14:13:52 <Martin_F> ... of bytes (represented as a String) to hex
14:13:58 <EvanR-work> Martin_F: no i was just saying he needs to get his types straight
14:14:55 <shachaf> Sure. It's explicitly "undefined behaviour".
14:15:07 <Gurkenglas> Does some core library implement matrix inversion or the like? (I hope I got the common meaning of "core" right)
14:15:08 <zipper> EvanR-work: A string of ascii values to a string of hex values.
14:15:14 <EvanR-work> oh
14:15:18 <benmachine> shachaf: thus I argue unsafeCoerce would not be categorically unsuitable to being defined
14:15:26 <benmachine> er, that didn't grammar
14:15:28 <dzhus> EvanR-work: so there's no such thing as "standard" Binary instance that handle packet length
14:15:31 <EvanR-work> zipper: [Word8], [Char], ?
14:16:07 <Martin_F> EvanR, well, yes, I'm not disagreeing. "ASCII" meaning 8-bit isn't technically correct... It is often used colloquially though.
14:16:08 * hackagebot fb 1.0.8 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-1.0.8 (FelipeLessa)
14:16:08 <dzhus> fizruk: publisher TChan and reader thread is the standard pattern I think
14:16:16 <zipper> EvanR-work: I didn't quite get that.
14:16:17 <EvanR-work> dzhus: theres binary-derive
14:17:12 <EvanR-work> zipper: can write the type of the function you want?
14:17:42 <zipper> EvanR-work: No I can't. I know strings in haskell are UTF-8.
14:17:46 <Martin_F> EvanR, don't worry, I didn't mean anything negative by "pedantic" - it's a valuable trait in programmers. Sloppiness gets you PHP, and I doubt anyone here wants that ;)
14:17:51 <fizruk> dzhus: ok then :)
14:18:13 <benzrf> AshyIsMe: yes
14:18:17 <EvanR-work> zipper: so you want String -> String it sounds like
14:18:18 <benzrf> AshyIsMe: sort of
14:18:24 <benzrf> AshyIsMe: sortBy is what you wan
14:18:26 <zipper> EvanR-work: Yes
14:18:34 <Martin_F> > showHex 31
14:18:36 <lambdabot>  <[Char] -> [Char]>
14:18:48 <EvanR-work> zipper: in haskell String is an alias for [Char] (list of Char)
14:18:56 <ReinH> AshyIsMe: What do you mean by "fst or snd"? Do you want to sort by exactly one of those? Do you want to sort by fst and then by snd?
14:18:58 <Martin_F> > showHex 31 "" -- oh yeah, StringS
14:18:58 <zipper> EvanR-work: Yeah
14:18:59 <lambdabot>  "1f"
14:19:19 <zipper> :t showHex
14:19:19 <fizruk> :t sortBy (comparing fst)
14:19:20 <lambdabot> (Show a, Integral a) => a -> ShowS
14:19:20 <lambdabot> Ord a => [(a, b)] -> [(a, b)]
14:19:41 <Martin_F> ?src ShowS
14:19:41 <lambdabot> type ShowS = String -> String
14:20:25 <dzhus> fizruk: the only caveat I can think of is that you should use newBroadcastTChan instead of newTChan for your publisher chan
14:20:33 <zipper> > showHex 97 "a"
14:20:35 <lambdabot>  "61a"
14:20:39 <AshyIsMe> benzrf: yeah cheers, sortBy was what i wanted
14:20:43 <zipper> > showHex 97
14:20:44 <lambdabot>  <[Char] -> [Char]>
14:20:46 <EvanR-work> zipper: so you want to convert each Char in a list into a String of two characters, then join them all?
14:20:58 <benzrf> AshyIsMe: comparing is also useful:
14:21:01 <benzrf> :t comparing
14:21:02 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
14:21:07 <neuroserpens3> Please someone purify me. I programmed in php to solve a friend's issue.
14:21:08 <fizruk> dzhus: why?
14:21:08 * hackagebot reverse-geocoding 0.1.0.2 - Simple reverse geocoding using OpenStreeMap  http://hackage.haskell.org/package/reverse-geocoding-0.1.0.2 (jcristovao)
14:21:10 <zipper> EvanR-work: It's a crypto thing. I really want to xor them.
14:21:11 <neuroserpens3> ARGH I'M SO DIRTY
14:21:14 <neuroserpens3> I'M SO TAINTED
14:21:16 <zipper> Bit by bit
14:21:17 <Martin_F> zipper, ShowS is a performance thing - instead of generating a bunch of strings & concatenating them, you generate ShowSes & compose them, then pass "" to the result
14:21:43 <EvanR-work> zipper: so you want to convert each Char into a Word8, then xor them all?
14:21:44 <benzrf> neuroserpens3: implement a simply-typed lambda calculus type checker and/or inferrer in prolog to be cleansed
14:21:47 <zipper> Martin_F: :)
14:21:50 <AshyIsMe> sortBy (comparing snd) $ zip ['a'..'c'] [1..3]
14:21:52 <dzhus> fizruk: https://hackage.haskell.org/package/stm-2.4/docs/Control-Concurrent-STM-TChan.html#v:newBroadcastTChan
14:21:52 <benzrf> neuroserpens3: i just did it, it was fun :D
14:22:02 <AshyIsMe> benzrf: cheers
14:22:03 * hodapp throws neuroserpens3 into a very cold shower
14:22:08 <zipper> EvanR-work: I don't even see why we need to convert to hex for us to xor them.
14:22:08 <benzrf> AshyIsMe: :)
14:22:09 <neuroserpens3> benzrf: I don't know the first thing about prolog lmao
14:22:11 <EvanR-work> zipper: if you could write the type of your function, many of these questions would already be answered ;)
14:22:14 <benzrf> neuroserpens3: it's so cool
14:22:18 <hodapp> benzrf: SHIT! It's worse than we thought!
14:22:21 <neuroserpens3> hodapp: Thank you so much
14:22:24 <EvanR-work> zipper: we dont, that was the problem you asked for
14:22:30 <hodapp> benzrf: The PHP isn't supposed to act this quick!
14:22:44 <zipper> EvanR-work: The type is String to String
14:22:44 <neuroserpens3> Am I sick??? Is it serious???
14:22:52 <benzrf> neuroserpens3: you can ask it to find a value that satisfies your predicate
14:22:56 <zipper> but char has encoding of UTF 8
14:23:00 <zipper> EvanR-work: ^
14:23:01 <EvanR-work> zipper: xor doesnt have anything to do with Chars, Strings, or lists
14:23:06 <neuroserpens3> hodapp: What's my diagnostics?
14:23:09 <neuroserpens3> hodapp: will I live?
14:23:16 <EvanR-work> Char does not have an encoding of UTF8
14:23:41 <neuroserpens3> benzrf: Interesting
14:23:52 <Martin_F> Neuroserpens3, tell me about it, I hack at a PHP monstrosity full-time for my day job. :(
14:24:00 <neuroserpens3> Martin_F: lol fuck
14:24:13 <EvanR-work> PHP has functions now, at least
14:24:20 <neuroserpens3> Martin_F: You're a fucking hero. I couldn't take that.
14:24:25 <Martin_F> Language! This is a family-friendly channel
14:24:36 <hodapp> EvanR-work: now?
14:24:41 <neuroserpens3> lol ok sorry
14:24:49 <Martin_F> But I agree with the sentiment :)
14:25:00 <EvanR-work> hodapp: well i get the feeling people still must work with php < 5.3 in real life on a regular basis
14:25:10 <hodapp> there is always #haskell-blah which is more lax
14:25:23 <hodapp> EvanR-work: but, I mean, hasn't it always had functions?
14:25:27 <fizruk> dzhus: look reasonable, thanks for the hint!
14:25:28 <EvanR-work> not really
14:25:29 <neuroserpens3> hodapp: LoL I thought I was in blah
14:25:38 <benzrf> neuroserpens3: bbiab tho
14:25:49 <neuroserpens3> benzrf: wat?
14:25:52 <Martin_F> hodapp, yes, but not as first-class values
14:26:07 <EvanR-work> hodapp: in the same sense as C functions maybe, only without as much support as pointer to function gives you ;)
14:26:13 <zipper> EvanR-work: What are you trying to teach me?
14:26:31 <hodapp> EvanR-work: well, yeah, I meant functions-as-in-the-PHP-sense
14:26:31 <EvanR-work> zipper: to describe your problem
14:26:37 <hodapp> since we were talking PHP
14:27:05 <neuroserpens3> phpoop
14:27:11 <EvanR-work> anonymous first class functions now*
14:27:23 <EvanR-work> with closure sort of*
14:27:35 <hodapp> sort of?
14:27:40 <EvanR-work> funky syntax
14:27:47 <hodapp> are they still surrounded with all of the usual PHP warts?
14:28:41 <Martin_F> You have to explicitly say in the function expression which variables you want to capture from the enclosing scope. It's horrible syntax.
14:28:55 <Iceland_jack> Can you take the PHP talk elsewhere please
14:29:00 <zipper> Looking for a function that takes a Char and gives back an Int. In this case. I want to match letters (Chars) to their ascii values.
14:29:15 <EvanR-work> zipper: so that would be like String -> Int
14:29:25 <zipper> EvanR-work: Yes
14:29:40 <zipper> EvanR-work: No, Char -> Int
14:29:42 <fizruk> :t ord
14:29:44 <lambdabot> Char -> Int
14:29:46 <EvanR-work> to convert a Char to its numeric value, use ord
14:29:48 <fizruk> > ord ‘a’
14:29:48 <Iceland_jack> zipper: You're talking about a ByteString (array of bytes basically), not a String
14:29:49 <lambdabot>  <hint>:1:5: lexical error at character '\8216'
14:30:04 <fizruk> > ord 'a'
14:30:05 <lambdabot>  97
14:30:07 <zipper> >ord "a"
14:30:19 <zipper> Oh double quotes
14:30:22 <zipper> Thanks
14:30:24 <fizruk> > map ord "hello"
14:30:26 <lambdabot>  [104,101,108,108,111]
14:30:43 <EvanR-work> zipper: so, this is different from "convert a char number to hex" because its the exact opposite operation, converting a number to a string, not a char to a number
14:31:16 <homovitruvius> is it possible to use quickcheck to test more than the parserin a compiler? e.g. anything that requires declarations or matching of function call sites and function definitions or class definitions and their uses
14:31:18 <EvanR-work> the distinction is important for understanding what the computer is going to do
14:31:29 <zipper> EvanR-work: I had to break my problem into small parts.
14:31:54 <zipper> EvanR-work: Implement that then do something else. The way I was explaining was hard for you to get.
14:31:56 <aeiou__> Hi. I'd like to know how #haskell feels about extention languages. Like Lua/javascript and so.
14:32:02 <Iceland_jack> > BS.zipWith xor (BS.pack [10,20,30]) (BS.pack [2,3,4])
14:32:03 <lambdabot>  [8,23,26]
14:32:22 <zipper> Iceland_jack: Sweet
14:32:26 <zipper> :t xor
14:32:27 <lambdabot> Bits a => a -> a -> a
14:32:32 <hpc> i like javascript, it's a bunch of weirdness around a decent core functional language
14:32:33 <EvanR-work> > foldl' xor 0 [10,20,30,40]
14:32:34 <lambdabot>  40
14:32:37 <aeiou__> scheme is quite obvious, but is there somthing more haskell-alike?
14:32:42 <Iceland_jack>     BS.pack :: [Word8] -> ByteString
14:32:56 <zipper> > xor 1 1
14:32:57 <lambdabot>  0
14:33:00 <Martin_F> aeiou__, you can embed Haskell itself!
14:33:22 <EvanR-work> aeiou__: lua seems cool at first, until you have to program in it
14:33:31 <EvanR-work> its not very functional
14:33:32 <aeiou__> Marin_F I don't want to ship ghc
14:33:34 <Martin_F> ?google ghc as a library
14:33:35 <lambdabot> https://www.haskell.org/haskellwiki/GHC/As_a_library
14:33:40 <levi> I like lua even after programming in it.
14:33:41 <Iceland_jack> Word8 is the type of an unsigned byte (0-255):
14:33:41 <Iceland_jack> > (minBound, maxBound) :: (Word8, Word8)
14:33:42 <zipper> Wow and here I thought crypto in haskell would be a pain and was contemplating doing this in python.
14:33:43 <lambdabot>  (0,255)
14:34:14 <EvanR-work> zipper: there are plenty of crypto libraries available, if youre worried about keeping things secret
14:34:17 <Gokhan> hi
14:34:26 <zipper> Iceland_jack: Unsigned?
14:34:37 <EvanR-work> > minBound :: Int8
14:34:38 <lambdabot>  can't find file: L.hs
14:34:41 <Iceland_jack> Yes, a signed byt is Int8:
14:34:42 <Iceland_jack> > (minBound, maxBound) :: (Int8, Int8)
14:34:42 <zipper> EvanR-work: No I'm taking a crypto course so I have to implement these things.
14:34:43 <lambdabot>  (-128,127)
14:34:45 <Iceland_jack> *byte
14:34:52 <ReinH> zipper: I can confirm that Haskell is a pretty good choice for crypto.
14:34:55 <bsmt> matasano?
14:35:15 <zipper> Iceland_jack: Let me read about unsigned bytes.
14:35:16 <ReinH> zipper: Although tbqh we tend to use a lot of FFI to C data structures rather than pure Haskell implementations.
14:35:27 <zipper> ReinH: :(
14:35:29 <levi> I think lua in general is more 'functional' than python, and you can mold it to be more so. And it has way fewer warts than javascript. But you can use something like purescript via a javascript engine.
14:35:30 <shachaf> ReinH: Really? I'm suspicious of that claim.
14:35:34 <Martin_F> aeiou__, you might be able to do something with PureScript - that's a Haskell-like that compiles to Javascript
14:35:37 <aeiou__> hpc, yes, IMO JS is not as bad as its reputation. The core is imo evden quite nice. Just the types are not strict
14:35:39 <ReinH> shachaf: That's Vincent's general MO.
14:35:52 <ReinH> shachaf: Which claim in particular?
14:36:10 <zipper> ReinH: Why? Is it easier this way? Johan Tibell was complaining about the issue in the mailing list.
14:36:11 <EvanR-work> levi: its not very well optimized for using composition of functions, implementation wise or syntactically
14:36:13 <shachaf> Yes, and I'm suspicious of Vincent's code too.
14:36:26 <EvanR-work> it wants you do do iterators
14:36:32 <zipper> ReinH: Since I don't know C I didn't contribute since I don't touch the implementations of such libs.
14:36:40 <shachaf> (Nothing to do with him  specifically.)
14:36:44 <aeiou__> Martin_F, so typescript is souped up fay?
14:37:08 <ReinH> shachaf: Well, we're trusting enough to build a business on top of his crypto code, so I suppose we'll see how it works out...
14:37:28 <Martin_F> A similar project, sure. I couldn't say which is more powerful.
14:37:51 <aeiou__> fay doesn't have typeclasses
14:38:07 <aeiou__> and no updates since quite a while
14:38:23 <levi> EvanR-work: It's about as well-optimized for writing functional code as Javascript is. And maybe moreso with LuaJIT, aside from syntactic issues. See https://github.com/rtsisyk/luafun for example.
14:38:33 <bitemyapp> aeiou__: better off with GHCJS long term.
14:39:02 <ReinH> shachaf: To be fair, we did run into a nasty segfault recently because of our FFI. There is definitely a good reason to be suspicious.
14:39:07 <EvanR-work> levi: maybe with luaJIT
14:39:11 <levi> luajit was even used as the basis for a Haskell JIT, though I'm not sure it's going to be completed.
14:39:45 <Ralith> ghc already has an llvm backend, and llvm has a perfectly good JIT impl
14:40:02 <aeiou__> ok, but this got a bit out of hand, but actually I'm not looking for a language that compiles to javascript
14:40:41 <aeiou__> I'm looking for something that Franz Lisp : Chibi Scheme :: GHC : x
14:41:32 <Denommus> Ralith: how to use the LLVM backend? Does it need to be compiled with LLVM support, or is it a flag in the command?
14:41:43 <Martin_F> aeiou__, sure, I was just thinking you could bundle PureScript & a JS VM, as one possibility. Afraid I don't know of anything more direct myself, other than GHC.
14:41:57 <aeiou__> A small(ish) language, embeddable into Java would be a hughe plus, that a haskeller would like
14:42:31 <levi> aeiou__: There's Frege, though I don't know if it counts as 'smallish'.
14:42:41 <aeiou__> Martin_F, yes, there a penty of JS implementation around, so that a way.
14:43:40 <EvanR-work> aeiou__: also, haskell has a java bridge. you can write a haskell program that runs java code, independently
14:44:25 <newb321> Hi, how is the proper way to check if a string is a number?
14:44:42 <levi> There's also hslua, if you want to embed lua in a GHC-compiled application.
14:44:44 <aeiou__> EvanR-work, that nice, i didn't know that. But the app is written in java (and that will stay that way), and that app should execute some kind of user definded macro stuff
14:45:14 <EvanR-work> aeiou__: then perhaps the other way, have your java program execute haskell code
14:45:19 <monochrom> newb321: consider "readMaybe" in Text.Read
14:45:28 <Martin_F> ?type reads -- or this
14:45:29 <lambdabot> Read a => ReadS a
14:45:30 <ReinH> newb321: You might use readMaybe :: Int (or some other number type)
14:45:43 <newb321> thank you!
14:45:45 <monochrom> it's readMaybe :: Maybe Int
14:45:53 <ReinH> monochrom: *facepalm*
14:45:57 <monochrom> err, not even that
14:46:02 <monochrom> it's readMaybe :: String -> Maybe Int
14:46:12 <ReinH> indeed
14:46:13 <EvanR-work> unsafeReadMaybe :: String -> Int
14:46:35 <Martin_F> ?src readMaybe
14:46:35 <lambdabot> Source not found. Are you typing with your feet?
14:46:38 <ReinH> EvanR-work: a.k.a. read?
14:46:42 <monochrom> "read" is shorter than "unsafeReadMaybe"
14:46:43 <EvanR-work> yeah
14:46:50 <ReinH> I prefer your name though.
14:46:52 <EvanR-work> should be renamed ;)
14:47:12 <ReinH> lambdabot: there's no need to be rude
14:47:29 <ReinH> Lambdabot is snarky sometimes.
14:49:58 <Chathurga> Robots these days, no respect
14:52:23 <EvanR-work> i dont have to take this im going home
14:57:31 <Athas> Is there a printf for Data.Text?
14:57:49 <fresheyeball> anyone out there?
14:57:54 <EvanR-work> > printf "%02x" 34 :: Text
14:57:56 <lambdabot>  Not in scope: type constructor or class ‘Text’
14:58:00 <EvanR-work> > printf "%02x" 34 :: Data.Text
14:58:01 <lambdabot>  Not in scope: type constructor or class ‘Data.Text’
14:58:06 <EvanR-work> > printf "%02x" 34 :: Data.Text.Text
14:58:07 <lambdabot>  Not in scope: type constructor or class ‘Data.Text.Text’
14:58:08 <fresheyeball> :t floor (1 / 2)
14:58:09 <lambdabot> Integral b => b
14:58:23 <Iceland_jack> Athas: You'd use the "formatting" package
15:15:00 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
15:15:00 --- topic: set by geekosaur on [Sun Dec 21 13:35:50 2014]
15:15:00 --- names: list (clog callumacrae susmus Floyd_ adu srhb CosmicRay c74d xnyhps thomassgn dboik assia_t theorbtwo Edoxile otherchas mcbonz Fubar^ dawik horlicks_ s4msung slick lu324__ jedws theDon n1ftyn8 jack_rabbit tomku zol hpd ByronJohnson Kaini andbroby fiola morolin Guest26276 lahwran quaestor1 uwap noddy ChristianS betawaffle solirc Xack ubuntor Liskni_si blenny Erstarrung JPohlmann netj JZTech101 owa joeyh yusukesuzuki TallerGhostWalt Voldenet shelf lpsmith plhk)
15:15:00 --- names: list (ncocacola mozmoney Willis wizonesolutions Guest90609 ReinH Fuco chirpsal1 akurilin Tritlo araujo monsieurp arthur_honeynet PaulHarris juanpablo______ xplat Nimatek BlastHardcheese kalz sadgit qxjit kloeri heath stelleg ashbreeze TheMoonMaster nisstyre Javran ParahSailin myst|work zso npcomp Eagle_Erwin oleo yarou klassasin xinming dehflingus mrowe_ sprang chu gandr gx^ LordBrain Jonno_FTW agumonkey_ kranius kmicu albertid julienXX anastas PHO burp sorind)
15:15:00 --- names: list (kidnapped_robot Longlius unsymbol_ ninedotnine [swift] anry davesilva spion mach klugez benzrf MitchW_ thorkilnaur_ kazagistar edwardk hellschreiber cloudhead wjt__ spwhitt Nickeeh Von_Neumann bel3atar haroldwu yorick rs0 dyreshark tomprince_ moy solarus recurrence honza tremon mbrcknl drbean matematikaadit gniourf jang1 SaBer indiagreen_ fold matson plutoniix kalloc fandi_ glowcoil_ dabukalam grohne elij andreasrx cjay wayne kipras liuw fergusnoble ipuustin)
15:15:00 --- names: list (Hugglesworth henrikhodne ps-auxw ab9rf Walther connerb peddie pikhq comma8 ryanakca sunfun himikof werdna stephenmac7 charlie yac alevy ryan_t dpn` stuntaneous sohum melter milli` u-ou mrphy taksuyu cjwelborn zeph ircbrowse pmarreck SegFaultAX oberstein rjsalts avdi akahn shelling__ Taneb zpconn__________ ajcoppa hiratara cstrahan_ dgonyeo ixian keko_ darkowlzz|afk slasktask MiracleBlue_ acfoltzer rom1504 tridactyla pii Vbitz stask Thulsadum cschneid conehead)
15:15:00 --- names: list (integral joelteon korpse_ rossberg huonw tobiasgw joefiori___ joefiorini_ Boreeas namuromus mitchty rsynnest Heero ocharles_ gws Scorchin qwandor dario teeteewhy Ferroxide mirsal usr sea-gull BeardedCoder lacrosse__ cross pygospa tv1 joaopizani _zxq9_ caasihuang snowp tassmjau Eliel_ benbange1t timpani_ Tene dmbaturin_ Drezil_ kragniz Guest53394 PierreM vmesons Ralith Kneiva_ jlewis raek_ kav_ `0660 18VABY2O6 frontendloader xahry mattp_ adnap Nanar)
15:15:00 --- names: list (RevJohnnyHealey 18VABY2H1 CindyLinz pweaver_ zebr bananagram dsantiago shutdown_-h_now spaceshi1s noelm Tordek_ lamilami lieven heaumer GBrawl amiller_ eternaleye WraithM__ Wamanuz2 sviterok lucs_ Rembane itsmonkt1stic ousado_ boegel|work Soft- Awesomec Lokathor tromp Guest7972 escondida Dtgr_ r0ckn3ur0tik0 Svedrin s_e Noldorin digia dustinswan yrdz`` GHCI iElectric pi8029 David bvad albel727 perspectival C4Cypher wagle_ fikusz zhulikas_ honkfestival)
15:15:00 --- names: list (stbuehler stass therealklanni Paradisee pp^ pfoetche1 drewr tsani digitalmentat ToRA_ chridal Shandy xaimus frogpunc_ falafel thunderrd_ runde_ bens DarkFox VeXocide magicman Gx00- sinopeus gfixler_ joeytwiddle john_not_jenny M-ou-se_ ft rieper_ Jello_Raptor ehamberg_ haskoiner tuv tzaeru_ beu day adimit bdamos` dixie nik_89_ fyolnish mpickering tristero zalami topi jaboja1 notdan gdsx_ eamelink_ kosmikus_ ivoscc creichert chriswk_____ marcus-aurelius Sixmsj)
15:15:00 --- names: list (sm_ shmookey ruukasu capcar ryu91835 MK_FG hator bydo_ DigitalKiwi rahul_ photex DustyDin1o ezrios Natch_u mrb_bk TrafficMan japesinator sakirious n4x knyon Shozan dmilith ilmig_ pm5 bitraten Guest68844 ceii louisjb`` uber petterw lassulus defanor laurencer RGamma dschoepe kadoban _TAS vin-ivar MasseR zariuq Scheriderm _rgn Excureo brandonw_ felixsch _1126 djbeau2 avocado kstuart geekosaur stefan_1_ keltvek tono```` sinelaw chris2 Laquendi mav_ mystor obiwahn)
15:15:00 --- names: list (Belgarion00 cultofmetatron BillyIII_ xandaros kiniry1 Cale Ptival_ ]OLI[ rk[1] jmcarthur joehh2 paperManu thetallguy yam cleamoon_ shiyaz finnrobi Psiana OlegYch5 pantsman jophish_ aivuk JRoberts_ Luke SwashBuc1la mthvedt fr33domlover chasecal1 aartamonau brennie_ `micro_ amontez pharpend_ saep jefus_ cursivec_ zymurgy crazymykl Pucilowski Fusxfaranto keaml_ MagBo sw1nn_ Rutger`_ Darkflux madjesti` ephess aloiscochard Antoine60 Adios aftershave McManiaC)
15:15:00 --- names: list (andjjj23 Ysgard_ vgrbr Nivim barquentine1 alexbar__ haasn lu38wuqi___ crazydiamond magicflakes tych0 dropdrive MoALTz__ roconnor__ kirjs______ shachaf zaroth_ gbarboza Gothmog_ howard tg Preyer znutar eacameron1 paz__ canta zyla LQDHelium nmontecc fatlazyc_ Vq DanielDiaz1 nick1234abcd__ nulpunkt_ BMeph_ ggherdov j201 Atlanis tcmitche1l _spire shock_on_ thomie seangrov` sshine glguy_ dmj``` tommah etabot jlouis zq pharaun jstolare1 iulian_ juri__ andrewsw)
15:15:00 --- names: list (enomies_ sweenzor kshannon Chathurga Iceland_jack andrew__n efm_ noplamodo_ dibblego cosban- _ikke__ palatin mlen shiona jrslepak johtso jakesyl_insomnia yukko_ xorox90 hackedy NikolaiToryzin mtbottle LnL natte metaf5 heyj_ca awe_ pfurla periodic Starfire_ qrada_ cpa_ andreass_ mrd_ u___ host46_ saiam_ mgomes_ poucet_ lokydor_ numberte1 lyddonb bbastian- jrp6_ Lindrian_ d3lxa boris`` gridaphobe hegge_ qzzx stvc aristid___ t7 ChongLi episplit 21WAA0RHZ qr42_)
15:15:00 --- names: list (jix_ lusory_ josephle tomejagu1r_away torpet__ si14_ brolin_empey_ jessicah jakecraige_ lykkin AlainODea_ jlyndon_ MilkWhis1le tstc` thsig codyopel_ lvh_ chigley_ the_ktosiek martinga_ crufty_ Zemyla_ Guest13963 Igloo_ platz_ mariothe1ad Talryn_ qtplatyp1s m4farrel_ predator117 fling_ wormphle1m Freundlich Tehnix_ davl_ mgaare_ etrepum_ dougia cods_ aristid__ `DanZimm otulp lohkey_ kaol_ croyd_ apo Yawgmoth_ mpereira_ xivix_ Jaxan_ NightRa_ marr biscarch jcp)
15:15:00 --- names: list (idnar dkua_ sebbarn` saiko-chriskun jb55_ tromp_ gsingh93 absence kwantam obcode pyon j4cknewt agocorona RchrdB YaRly Thooms Garner angelicstrike hive-mind d_k dysinger tommd starless tilde killtheliterate yqt RaceCondition _ixti_ _jak tutukaka ystael Swizec psy_ chidy lambdahands mjboa milessabin Buck Iskarlar hexagoxel arjanb gusto nakal mceier silver dreixel flxx flux Chousuke erkin n0n3such zzing phaazon lambdabot ambimorph1 Jesin Mon_Ouie SrPx _5kg xeno)
15:15:00 --- names: list (amiri Stratege acln eyck heurist` myyst bru`` Sorella SoupE Enigmagic hrehf Reite mmaruseacph2 MrWoohoo petermw bgamari_ bgamari shanse cdk Nik05 krgn Dykam deavid brisbin vincom2 k00mi Nadrieril negatratoron petantik ansible kjanosz staffehn electrogeek Polarina monty hbar jrib Plasmastar m1dnight_ Guest69795 jameseb DrAwesomeClaws redtricycle mountaingoat __main__ jzelinskie ElderFain edk ForNeVeR hguux_ seancorfield k4r1m jroesch MMuse_______ mak` hvr)
15:15:00 --- names: list (isenmann ninzine mero hrnz gidogeek clauswitt troydm rufs janne Deewiant shapr vpm \Harbinger\ seabre majoh drone| ij ephemeron Ferdirand BrianHV mietek HylianSavior agrif LordDeath Blkt raid greymalkin dav1d alang lpaste cin fall_ SuperTux88 mitu gds wjlroe Cerise l3kn alem0lars jmct fnordbert alanz Haskellfant pwestlund_away drdo eXeC64 codehero spindas vobi anachron lericson SLi Paprikachu rhaps0dy cbaines tekacs asabil gregburd sclv emmanueloga helgar)
15:15:00 --- names: list (Spaceghost ttuegel jzl larrytheliquid_ pjdelport tazjin mankyKitty carter_cloud Biohazard benwf suvash_away psacrifice Danavu Spockz julmac heikkih Twey jrp6^2 aleator Saizan ibid ninegrid ndeine- opqdonut Sonderblade ens_ froztbyte hongminhee jackhill fall` td123 doctorin1 luigy zoglesby untwisted RageD gratimax dp_wiz jasu0 Draggor ThePhoeron schlumpi sbrg yeltzooo9 johnw cic koala_man ande FreakyPenguin kloplop321 tm512 Meeh drewdavis _br_ mads- dredozubov)
15:15:00 --- names: list (maurer XMunkki gargawel dmwit larsen Athas yumike taruti joshc osfameron robotbrain edran relrod sbauer322 bennyklotz rudi_s cdidd Zariel cryon mikeplus64 lifenoodles arun__ pieter__ HugoDaniel pyrtsa blindscreen_ leifw Lutin` seubert whaletechno ethercrow Ulrar bonobo_ mortberg devi _flow_ idoru vlopez marienz bergmark knyppeldynan ziman gnusosa Ornedan bartavelle nille friden Watcher7 zomg int-e fabjan_ statusfailed ernst @ChanServ dantoml clementd hape01)
15:15:00 --- names: list (bastian__ hmax dan64 moop hamishmack Draconx lnich michaelpj byorgey tero mechairoi pdxleif Maxdamantus goldfire pranz gienah Sornaensis seliopou brackets butyoudonot sleepynate indigo antoine`` nitrix marchdown hiredman naudiz brixen rofer babypie arch_ klarrt jonrh hyPiRion alekst_ tismith dlundy bjorkintosh earthy levi denimuser estulticia sdx23 beauby Elsi cursork Reiser jnoah)
15:15:45 <kadoban> Lokathor: ~/.cabal/ has your cabal config that you'll probably want to save
15:16:13 <Lokathor> well I only just setup cabal on this machine last friday, so there's not much to say
15:16:14 <Lokathor> save*
15:16:25 <kadoban> Ah
15:16:33 <Lokathor> I got a raspberry pi and have been tinkering with things
15:17:25 <Lokathor> alright and now a matter of style. In a java turn based game I had it setup with a series of "Screen" instances, the GUI would read a key, pass it to the active instance, and then it would interpret that key, change state if necessary, and return the next Screen to show and get input.
15:17:42 <Lokathor> does this sound like a sane way to also setup a Haskell program? or would something else be suggested?
15:18:44 <ReinH> Lokathor: seems reasonable.
15:19:35 <Lokathor> I was thinking that he main loop would center aound something like doKeypress :: Screen -> KeyPress -> IO Screen
15:19:36 <NemesisD> whats the difference between a standalone "instance Foo Bar" and "deriving instance Foo Bar"
15:20:35 <Lokathor> well a derived version is automatic
15:20:41 <Lokathor> the compiler makes it for you
15:21:05 <Lokathor> "instance" just means that someone made it ever, might be the compiler, might be a custom version by the coder
15:21:38 <glguy> The "instance" version means you're using the default implementation of all of the class methods
15:22:09 <Lokathor> oh? hmm
15:22:33 <Lokathor> don't classes generally have some minimal definition?
15:22:42 <glguy> some do
15:22:59 <pawiecki> Hello!
15:23:05 <Lokathor> hi there
15:23:16 <glguy> The ones that don't are often using the DefaultSignatures extension to implement the defaults with some extra assumptions
15:23:35 <Lokathor> ah ha, well I don't know much about language extensions at the moment
15:24:04 <pawiecki> so many people around here
15:27:25 <Lokathor> fun HSCurses note: the docs seem to imply that you should call "update" after "endWin", but do not do that.
15:28:09 <ReinH> Lokathor: Heh. I use either the ncurses library or vty, personally.
15:28:38 <Lokathor> you mean haskell's "ncurses"? or the C version?
15:28:53 <rom1504> oh wow 1442 on this channel oO
15:30:02 <ReinH> Lokathor: haskell's
15:30:07 <pawiecki> rom1504: how to check it?
15:30:16 <rom1504>  /names in irssi
15:31:03 <rom1504> but that depends on your irc client
15:31:06 <rom1504> depend
15:31:58 <Lokathor> hmm, ReinH it looks like just an alternate set of bindings to the same curses.h C library, right?
15:32:16 <pawiecki> depends actually sounds correct here
15:40:26 <aeiou__> Ok, no sane person would ever do anything with GHC core, especially interpret it, right?
15:41:22 <Lokathor> I don't think you'd generally interpret it, no
15:41:30 <karshan> Hmm, does anyone know why Control.Lens.TH.declareLenses increases compilation time like crazy ? I'm going from 1 second to 34 seconds
15:41:38 <karshan> granted it is an ec2 micro instance
15:41:40 <karshan> but still
15:42:53 <glguy> Does this help? declareLensesWith (set generateLazyPatterns False lensRules)
15:43:30 <fresheyeball> @pf \xs -> f xs == reverse (f xs)
15:43:30 <lambdabot> Maybe you meant: pl bf
15:43:37 <fresheyeball> @pl \xs -> f xs == reverse (f xs)
15:43:37 <lambdabot> liftM2 (==) f (reverse . f)
15:44:03 <fresheyeball> @hoogle liftM2
15:44:05 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:44:14 <glguy> Template Haskell can be a lot slower because it has to load a bunch of extra stuff at compile time, and then if you have a big record type it has to generate a lot of code
15:46:52 <jle`> there's a lot to @pl that i would patch :|  like liftA2 instead of liftM2.  i should probably get around to it
15:48:01 <lpaste> PrecisionGuy pasted “Error message I don't understand” at http://lpaste.net/118533
15:49:29 <PrecisionGuy> I'm getting "the type signature for 'mytok' lacks an accompanying binding" -- any ideas on this?
15:50:38 <glguy> You have to provide an implementation for mytok, you can't stop at the type signature
15:50:44 <glguy> so a line under that like:  mytok = []
15:50:53 <PrecisionGuy> ok thanks!
15:50:54 <karshan> glguy: where is generateLazyPatterns defined ? hoogle is failing me. also why does hoogle +lens declareLenses return no results!
15:51:57 <glguy> karshan: Oh, apparently I added that since the last release. Are you trying to generate lenses for a large record type?
15:52:03 <glguy> or just a small one and its running slowly?
15:52:14 <karshan> its a really small one, and its compiling slowly
15:52:30 <glguy> Then that's probably just template haskell being slow to load up
15:52:48 <glguy> but if you want to toss the code on lpaste.net I can look
15:54:31 <karshan> glguy: oops, I made a mistake. I compared the time of compiling with declareLenses to compiling without, but having an error :P. declareLenses does not make the compile any slower. language-java just takes ~34 seconds to compile on an ec2 micro instance
15:56:55 <dgpratt> does anyone know of a 'standard' blog publishing API implementation in Haskell?
15:57:11 <dgpratt> like metaweblog or atom publishing protocol?
15:57:59 <Schluri>         map (map ((\x->wortMorse l x).filter(and)))
15:57:59 <Schluri>         
15:57:59 <Schluri>             $map (wordsBy  (\x->not(and x) && length x >= (2*l)))$ wordsBy (\x->not(and x) && length x >= (l*5))--[[[Bool]]]         $group xs
15:59:31 <glguy> Schluri: Please use lpaste.net to paste code and then provide a link in channel
16:00:11 <Lokathor> if you use the lpaste link in the topic it'll put the link in the channel automatically
16:01:30 <jle`> PrecisionGuy: some people use `mytok = undefined` if they don't want to put an implementation yet :)
16:01:34 <jle`> in general
16:10:58 <Darwin226> Hey, is there a way to tell ghc to compile my project but just output the infered type data of everything?
16:11:10 <ClaudiusMaximus> dgpratt: maybe BlogLiterately contains one (or uses a library containing one)
16:11:48 <dgpratt> I'll check it out, thanks ClaudiusMaximus
16:11:57 <jle`> Darwin226: i'm not sure if this is what you want, but -Wall will give the type signatures of any unlabed top level declaraions i thin
16:12:28 <Darwin226> jle`: Nah. I want everything. Including local bindings
16:13:16 <geekosaur> -ddump-tc or -ddump-types ?
16:13:22 <geekosaur> I suspect the latter
16:20:17 <Darwin226> geekosaur: That's almost there, but it still doesn't give me the types of the local bindings
16:20:35 <Darwin226> geekosaur: ghc-mod can get those, so surely there's a way
16:21:57 <geekosaur> ghc-mod is using ghc-api to query specific types out of the intermediate compiled information. I don't know if there is a way to simply dump all of them, if -ddump-tc doesn't do it... but ghc internals and what's done at various dumpable states is still rather opaque to me
16:23:28 <Lokathor> you could... run a ghci script over it maybe?
16:23:50 <Darwin226> Lokathor: How would that go?
16:24:38 <zipper> What does this error mean since `cabal configure' isn't solving it:
16:24:43 <zipper> `cabal: You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.20.0.0, now Cabal-1.22.0.0).'
16:25:16 <zipper> As in how else can I run cabal configure?
16:25:39 <Lokathor> Darwin226: i'm not actually even sure you can do this, but ghci reads from stdin, so if you could read a file and find all the symbols you want types for, and then open ghci and load the file and dump all the right :t commands into the lines, it'd print the types to stdout, which you could pipe to a log maybe?
16:25:58 <dcoutts> zipper: did cabal clean help?
16:26:11 <dcoutts> zipper: or are you building Cabal itself?
16:26:38 <Darwin226> Lokathor: But as far as I know you can only :t the top-level bindings
16:26:45 <zipper> dcoutts: No I'm trying to run cabal repl
16:26:51 <zipper> Let me try cabal clean
16:27:48 <Lokathor> Dawrin226: I'm not sure what you mean. if you import a file you can :t on all the symbols it exports. what else are you looking for?
16:28:44 <zipper> After cleaning and trying to run cabal configure again it says the package has never been configured. It tries to configure it. After that it ends with `Preprocessing library...`
16:28:47 <zipper> dcoutts: ^
16:29:19 <zipper> Now all attempts at cabal repl say preprocessing library
16:29:52 <dcoutts> ziman: hrm, and I presume cabal build doesn't fare any better. Any insight from using cabal build -v3?
16:30:00 <dcoutts> oops, zipper
16:30:13 <dcoutts> [tab completion strikes again]
16:30:57 <zipper> dcoutts: Do I need to build just to use the repl?
16:31:06 <dcoutts> no
16:31:47 <zipper> dcoutts: Well I really don't have source files and the build seems to be complaining about that right now.
16:32:19 <zipper> dcoutts: Let me post a gist.
16:32:23 <dcoutts> ok
16:32:40 <zipper> dcoutts: https://gist.github.com/urbanslug/d0eb72939b386896e919
16:33:33 <dcoutts> zipper: is that cabal build?
16:33:52 <dcoutts> (the gist doesn't include the original command)
16:34:21 <dcoutts> zipper: and is the link successful or not? from the gist one might presume that it works fine
16:34:46 <karshan> Hmm, is there a way to use TemplateHaskell or Control.Lens.TH.declareLenses specifically and refer to data types that are defined later on in the file ?
16:36:25 * hackagebot reverse-geocoding 0.1.0.2 - Simple reverse geocoding using OpenStreeMap  http://hackage.haskell.org/package/reverse-geocoding-0.1.0.2 (jcristovao)
16:36:25 * hackagebot hsdev 0.1.3.2 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  http://hackage.haskell.org/package/hsdev-0.1.3.2 (AlexandrRuchkin)
16:36:35 <zipper> dcoutts: I did this thing that fixed it. I added an exposed module under exposed modules.
16:36:38 <dcoutts> karshan: no, a TH splice can only "see" things in imported modules, or things defined earlier in the file.
16:36:49 <zipper> dcoutts: Then cabal clean and cabal configure
16:36:55 <dcoutts> zipper: so it's working?
16:37:08 <zipper> dcoutts: and a random module that just prints hello world. Yes it is working,
16:37:13 <zipper> dcoutts: Thanks
16:37:36 <dcoutts> mm, unclear to me why it wasn't working before, or giving a sensible error message
16:49:37 <danilo2> Ugh! It is impossible to install lens on clean ghc installation right now, because we've got circualr dependencies :( lens fails when installing distributive, while installing only distributive just fails with circular deps problem :(
16:50:19 <Lokathor> hackage has some unification issues to work through for sure...
16:50:28 <EvanR> to install lens you must first install lens
16:51:00 <Lokathor> EvanR: earlier you said that you can mix java an haskell? How does that work? Does the java get compiled to native code as part of the compilation, or do you still need a JVM?
16:51:01 <Javran> is it possible for optparse-applicative to perform some other actions other than printing out the brief description when no argument is given?
16:51:03 <karshan> dcoutts: does that mean that I can't use templatehaskell to generate lenses for mutually recursive datatypes like AST's ?
16:51:14 <EvanR> Lokathor: yes you need a jvm
16:51:37 <danilo2> EvanR: lol :D
16:51:44 <EvanR> Lokathor: the java-bridge package automagically instantiates one, and only one, and communicates with it using JNI
16:51:47 <danilo2> anyway it seems that the newest containers are the problem :(
16:51:59 <Lokathor> EvanR: So you can make haskell generate/manipulate java objects and run java code that way?
16:52:04 <EvanR> yes
16:52:17 <Lokathor> ahhh, perhaps i could use swing that way... hmm
16:52:23 <EvanR> heh.
16:52:54 <EvanR> NullPointerExceptions in haskell ;)
16:52:55 <Lokathor> swing's biggest advantage is that i know how to tell people to install it on their system: "just run the java installer from the website"
16:53:17 <EvanR> swing isnt built in?
16:53:30 <Lokathor> well, swing is built into the java distribution that is
16:53:42 <Lokathor> unlike say, SDL, which sometimes a person has to go get a dll for
16:55:15 <LordBrain> it is possible to use a webkit window as your gui
16:55:28 <Lokathor> that's... the chrome renderer?
16:55:33 <LordBrain> yeah
16:56:04 <EvanR> that might come in handy
16:56:05 <LordBrain> there are examples in the ghcjs distor
16:56:15 <Lokathor> mmm... doThing :: JVM -> JObj -> JFunc -> Either NullPointerException JObj
16:56:17 <Lokathor> I can see it now
16:56:27 <danilo2> or no ... ehh, how can i process with such issue (cannot install lenses on clean system) ? HGow can i track what is making the problem with circular deps?
16:56:53 <EvanR> Lokathor: you can also use the versions that only return the result, or throw the exception
16:57:00 <EvanR> i.e. like java
16:57:10 <Axman6> danilo2: #haskell-lens might be a better place to ask
16:57:14 <Lokathor> LordBrain: so you compile haskell to javascript, and then it runs in the browser?
16:57:35 <danilo2> Axman6: no, it is not a lens problem. You cannot install distributive - which is something lens depend on
16:57:50 <EvanR> Lokathor: but if the type you are trying to get does not support Null-ness (Maybe etc) then even getting null will throw an exception (better than java)
16:57:54 <Axman6> there's a pretty good chance it was written by someone in there
16:57:58 <LordBrain> Lokathor, no, you can compile to native and use webkit
16:58:16 <LordBrain> Lokathor, unless you want to run it in the browser, both options are supported
16:58:55 <LordBrain> Lokathor, you can  actually make one code base that can compile to native or to js.
16:59:02 <Lokathor> Hmm, sounds exciting. I'll have to look into this I suppose. I saw GHCJS yesterday, but the readme didn't seem to indicate if it had a DOM and was intended for web pages or not
17:00:08 <Lokathor> oh no! it won't build on my raspberry pi >_>
17:11:26 * hackagebot base-prelude 0.1.12 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.12 (NikitaVolkov)
17:11:33 <Hijiri> Is there Traversal' s a -> Traversal' s a -> Traversal' s a that traverses what both the input traversals traverse?
17:26:02 <homovitruvius> trying to get emacs+haskell under windows (of which I know nothing) and get 'cabal.exe: dist\package.conf.inplace: permission denied' when switching to the inferior haskell process. Any idea?
17:28:40 <danilo2> Hello! Is there a way to ask hackage what time is it? It complains that my package has time in the future and I cannot upload it
17:28:56 <lpaste> jack_rabbit pasted “No title” at http://lpaste.net/118538
17:29:07 <danilo2> It provides me information what time my package was created but does not tells what time it thinks it is
17:29:12 <jack_rabbit> Newbie here. Could someone help me understand that error?
17:29:35 <kadoban> danilo2: Is your timezone and system time accurate? (Just guessing, I really know nothing)
17:29:47 <shachaf> jack_rabbit: Maybe you want to use mapM_ instead of map
17:29:57 <jack_rabbit> I'll take a look.
17:29:59 <danilo2> kadoban: yes and oh! It just worked - after about 10 minutes after creating
17:30:01 <arbelos> hmm.. HLint doesn't understand lambda-case expressions.
17:30:04 <shachaf> jack_rabbit: map :: (a -> b) -> [a] -> [b], so whatever arguments you give it, it'll return a list.
17:30:16 <kadoban> danilo2: Weird, well glad it worked :)
17:30:21 <shachaf> jack_rabbit: Whereas every line of main needs to be an IO action.
17:30:34 <danilo2> And another small question - I understand that the documentation on hackage will be generated in few minutes right? Right now all modules are "black" without documentation
17:30:43 <danilo2> kadoban: thank you :)
17:30:43 <jack_rabbit> shachaf, ahhhh, I forgot about that requirement.
17:32:40 <jack_rabbit> shachaf, exactly what I wanted. Thanks.
17:32:58 <shachaf> jack_rabbit: Also note forM_, which is just mapM_ flipped.
17:33:03 <shachaf> forM_ xs $ \x -> ...
17:33:31 <jack_rabbit> probably would make the code look better.
17:34:26 <shachaf> i,i jjbird
17:36:26 * hackagebot base-prelude 0.1.13 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.13 (NikitaVolkov)
17:41:26 * hackagebot logger 0.1.0.0 - Fast & extensible logging framework  http://hackage.haskell.org/package/logger-0.1.0.0 (danilo2)
17:43:16 <fizruk> danilo2: it can take a while, but yes. some packages (e.g. with unusual dependencies) won't build though, so those maintainers have to build docs locally and upload it manually
17:44:10 <danilo2> fizruk: the documentation just appeared! :) now I've published the package and it disappeared so I guess it will be rebuilded in a moment, thank you :)
17:56:27 * hackagebot connection 0.2.4 - Simple and easy network connections API  http://hackage.haskell.org/package/connection-0.2.4 (VincentHanquez)
18:11:27 * hackagebot ieee754 0.7.5 - Utilities for dealing with IEEE floating point numbers  http://hackage.haskell.org/package/ieee754-0.7.5 (PatrickPerry)
18:16:58 <danilo2> Hello! I just uploaded a fancy logging haskell framework. It is on hackage, but while docs are generated you can read about it here: https://github.com/wdanilo/haskell-logger :) I hope you will like it and it will be usefull! :)
18:34:55 <athan> With -XTypeOperators, do we get infix plain text, like `:foo:`?
18:35:40 <jack_rabbit> I'm trying to make my data structure an instance of the Functor typeclass, but in order to maintain consistency, I need the target type of fmap (the 'b' in '(a -> b)') to be an instance of Ord.
18:36:24 <jack_rabbit> so I can re-order elements in the structure.
18:36:33 <Axman6> it's not a Functor then
18:36:38 <jack_rabbit> gotcha.
18:36:58 <jack_rabbit> How do structures like data.Map do it, then? They must need to move stuff around...
18:38:24 <Axman6> Data.Map is fine, Data.Set is now (and hence it isn't a Functor
18:38:41 <jack_rabbit> ahhh, I see how that works.
18:39:02 <alpounet> jack_rabbit: Data.Map needs Ord on the key type, but doesn't constrain the value type at all
18:39:11 <jack_rabbit> Right, I see that now.
18:39:14 <Axman6> there is a way to make a wrapper of some kind around Set that makes it a Functor and a Monad, but it's kind of strange
18:46:20 <athan> Can we make type synonyms of arbitrary kinds?
18:46:28 <Axman6> > (2^64) `div` (40000000000 * 60 * 60 * 24 * 365)
18:46:30 <athan> s/of/with
18:46:30 <lambdabot>  14
18:46:57 <Axman6> > (2^64) / (40000000000 * 60 * 60 * 24 * 365)
18:46:59 <lambdabot>  14.6235604338768
18:48:16 <ReinH> athan: type Foo = Maybe
18:48:18 <alpounet> athan: well, the kind will just be the one of the thing they are a synonym of
18:49:03 <alpounet> I think
18:49:30 <pavonia> Wasn't there a restrictition that type synonym definitions need to be fully applied to type variables?
18:49:54 <athan> ReinH: For some reason the DataKind kind isn't inferring the right kind for my type, and I can't explicitly provide a kind signature for my type synonym
18:50:20 <qz_> is foldM always a magnitude slower than foldl', or i'm just using it wrong?
18:58:03 <athan> Is there a way to make parametric type family instances?
18:58:12 <athan> erm polymorphic?
19:00:00 <alpounet> athan: as in type family Foo f :: * -> * ?
19:04:54 <athan> alpounet: Right, but polymorphic instances, too
19:05:07 <athan> so something like `type instance Foo (Maybe a) = a` would work
19:05:14 <athan> (but doesn't :\)
19:06:44 <Cale> Uh, that doesn't work?
19:07:10 <Axman6> you sure?
19:07:21 <athan> Cale: they confict somehow
19:07:25 <Cale> type family Foo t :: *
19:07:26 <Cale> type instance Foo (Maybe a) = a
19:07:28 <Cale> works for me
19:07:29 <athan> oh shoot im an idiot
19:07:36 <athan> I'm depending on a constraint ><!!!
19:07:41 <athan> erm...
19:07:43 <athan> maybe?
19:08:20 <athan> Cale: Hermit showed me a really cool type inequality hack a while back
19:08:49 <athan> `type family a =/= b :: Bool; type instance a =/= a = 'False; type instance a =/= b = 'True`
19:08:57 <athan> Cale: This should work, correct?
19:09:05 <Cale> uhhh
19:09:11 <athan> because we pattern match on the unified case first?
19:10:16 <Cale> maybe if it were closed
19:10:47 <athan> Cale: I have parts in my types that behave differently when unified & not. Hmm, alright I'll see
19:11:19 <Cale> Yeah, if it's closed that works
19:11:24 <Cale> You'll get errors if not
19:11:36 <Cale> You can't write the type instances separately like that
19:11:52 <Cale> type family Neq s t :: Bool where
19:11:52 <Cale>   Neq a a = 'False
19:11:53 <Cale>   Neq a b = 'True
19:12:30 <athan> Cale: Holy frick you're an amazing person
19:12:32 <athan> thank you :)
19:15:32 <Lokathor> ugh, why does the java-bridge package require unix :/
19:15:42 <Cale> I wonder if that generates any false positives
19:16:21 <Cale> Like, what if the arguments to Neq there involve type family applications whose instances are supplied in future modules?
19:16:54 <Cale> Does it fail to reduce unless it can compare honest constructors?
19:21:15 <athan> Cale: Are type classes closed?
19:21:28 * hackagebot target 0.1.1.0 - Generate test-suites from refinement types.  http://hackage.haskell.org/package/target-0.1.1.0 (EricSeidel)
19:21:32 <Cale> No, not usually
19:21:42 <Cale> People have proposed extensions to allow them to be
19:22:02 <athan> hmm, alright :)
19:22:22 <athan> I just got this to compile if you wanna see: https://github.com/athanclark/dag
19:22:30 <athan> Cale ^
19:23:38 <Cale> What is this oleg shenanigans? :)
19:23:56 <athan> shoot overlapping instances :\
19:24:03 <athan> oleg?
19:26:01 <Cale> Oleg Kiselyov, he's the SI unit for type hackery
19:26:05 <athan> Woo!!!
19:26:11 <athan> :D!!
19:26:11 <Cale> http://okmij.org/ftp/Haskell/
19:26:29 <athan> Cale: Thank you :')
19:28:00 <Cale> http://okmij.org/ftp/Computation/lambda-calc.html#haskell-type-level :)
19:32:58 <athan> Weird... can type families form thunks, Cale?
19:33:12 <athan> type-level thunks?
19:36:11 <athan> or do closed type families make thunks..?!
19:36:13 <athan> wiah
19:36:18 <athan> woah* this is weird
19:36:23 <Cale> uh
19:36:34 <Cale> Type families don't exist at runtime
19:36:43 <Cale> So I don't even know what that question means :)
19:37:32 <athan> Cale: They're like type-level thunks: http://lpaste.net/118543
19:37:58 <athan> `DisallowedIn` should evaluate, then `Lookup` should, and then `Excluding` will behave fine
19:38:05 <athan> s/will/would
19:40:22 <Cale> Thunks are just the runtime data representation of expressions.
19:40:29 <Cale> So, I would just say type expressions
19:41:49 <athan> hmm
19:41:58 <athan> there's no `seq` for type expressions, is there?
19:42:30 <Lokathor> hscurses has no getstr analog
19:42:32 <Lokathor> how sad
19:46:22 <c_wraith> athan: in that sense, types are strict.  They're fully evaluated during type inference
19:46:28 * hackagebot sbv 3.5 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-3.5 (LeventErkok)
19:46:39 <c_wraith> athan: so there's nothing for a type-level seq to do
19:46:47 <athan> hmm
19:46:56 <athan> c_wraith: Did you see the lpaste error?
19:47:02 <athan> The structure of it is weird
19:47:15 <athan> I wouldn't expect the type family names to be type constructors
19:49:29 <athan> this just doesn't make sense to me hahaha
19:50:08 <athan> c_wraith: Are they evaluated from the bottom-up?
19:50:42 <c_wraith> athan: hmm.  Not sure about that - depends on how type inference proceeds, I guess.
19:51:02 <athan> holy beans
19:51:18 <athan> this has no connection to the value level though
19:51:21 <athan> fudge
19:51:28 * hackagebot atomic-primops 0.7 - A safe approach to CAS and other atomic ops in Haskell.  http://hackage.haskell.org/package/atomic-primops-0.7 (RyanNewton)
19:53:20 <Lokathor> So if I wanted to open a file handle, and then do a lot of things without passing that handle manually, I'm guessing I'd uh... extend the IO monad somehow? How would a person do that
19:53:54 <Clint> Reader monad?
19:54:05 <Clint> T
19:54:45 <Lokathor> mmm, where would a person read about monad transformers
19:54:47 <systemfault> Yeah, a ReaderT LeConfig IO ()
19:55:36 <systemfault> Lokathor: I wish I knew... I built up my intuition with them using time, blood, sweat and tears.
19:55:47 <Lokathor> ah, well then
19:56:24 <MP2E> real world haskell has one http://book.realworldhaskell.org/read/monad-transformers.html and so does wikibooks http://en.wikibooks.org/wiki/Haskell/Monad_transformers
19:56:33 <MP2E> but I agree, they aren't ideal
19:56:40 <MP2E> a decent introduction, but work with them will get you familiar :)
19:57:29 <MP2E> https://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot shows ReaderT being used too
19:57:36 <systemfault> For ReaderT, the "How to roll your own IRC bot" tutorial helped me
19:57:41 <systemfault> ^ :D
19:57:41 <MP2E> haha just posted that :>
19:57:43 <MP2E> i agree though
19:57:54 <MP2E> phenomenal help, actually that tutorial really helped monad transformers click with me
19:58:04 <MP2E> after putting copying the source, I tried adding StateT to it
19:58:34 <MP2E> (well I did add StateT to it, but after some effort and a few 'AH!' moments)
19:58:36 <systemfault> Hmm, I should try to do that too
19:59:05 <MP2E> -putting
20:03:52 <Lokathor> MP2E: I rolled my own IRC bot... but couldn't get past section 3 :(
20:04:32 <Lokathor> yesterday was not a grand day
20:04:41 <athan> You can't apply strictness to the _result_ of something, can you?
20:05:54 <nisstyre> "Since this is an intro course an easier programming language like C++ would've been more effective rather than Haskell which for some students found very difficult to understand" (anonymous student)
20:06:44 <MP2E> heh
20:07:09 <MP2E> You know, it's weird, of all the talk I hear about Haskell being incredibly difficult: I can't imagine doing some tasks in any other language
20:07:13 <MP2E> writing a compiler for instance
20:07:17 <MP2E> that just seems so insurmountable in C
20:07:22 <MP2E> and iv'e used it for years :V
20:07:24 <athan> Type :)
20:07:26 <athan> derp
20:07:32 <athan> forgot to delete ><
20:07:40 <Lokathor> the hardest part about haskell is getting it set up on windows :P
20:07:45 <Lokathor> and/or cabal hell
20:07:47 <athan> MP2E: Agree totally, it's amazing
20:07:48 <nisstyre> MP2E: it's not too bad if you do some up front work
20:08:18 <nisstyre> MP2E: writing a lexer that isn't very slow in C is hard-ish
20:08:32 <athan> Type inference for GADTs starts at the _outer_ constructors first, then inward, correct?
20:08:38 <lifter> If I continue to write to a TQueue that will never be read, does the TQueue fill up with those values and essentially take up memory unnecessarily?
20:09:30 <athan> lifter: You might be able to test in `ghci` or `cabal repl` in a sandbox, with `:set +s` (pretty sure)
20:09:36 <Lokathor> is there a way to have ghc compile a file and then immediately run it if the compile completes, but not if it fails?
20:09:37 <athan> it gives you basic memory usage
20:09:59 <athan> then you can just Ctrl-C it out in different intervals
20:10:00 <lifter> hmm interesting
20:10:04 <Lokathor> or would that be more in the domain of a shell script?
20:10:19 <athan> Lokathor: runhaskell
20:10:31 <athan> pretty sure
20:10:42 <Lokathor> not on my system :(
20:10:49 <athan> O
20:10:50 <lifter> try runghc
20:11:12 <lifter> tho this might not exactly be what you want as that doesn't execute a compiled executable
20:11:13 <athan> strange
20:11:18 <Lokathor> also no, ARM has much worse interactive style haskell than x86 does
20:11:36 <Lokathor> no ghci at all! gasp!
20:11:52 <athan> WTF
20:11:55 <athan> dood
20:12:07 <athan> you should use that for deployment, not development :\
20:12:17 <Lokathor> only linux box :P
20:12:19 <Welkin> I use runhaskell so often that sometimes I forget about cabal
20:12:26 <Lokathor> i've got ghci on my windows machine if i really need it
20:12:37 <athan> Why not a vm?
20:12:41 <Lokathor> i've been told that GHCi for ARM is in the experimental stages
20:12:53 <athan> actually you need 2G+ ram
20:13:10 <Lokathor> it's only a raspberry pi! 512MB of ram sir
20:13:14 <Welkin> development moves quickly, so it's just a matter of time before it gets working properly
20:13:31 <platz_> i heard jhc might be a better fit on memory constrainted systems due to its smaller runtime
20:13:45 <athan> O_O
20:13:51 <athan> you'll run into SO errors :\
20:13:57 <Lokathor> my windows machine could probably run a linux VM, but then i wouldn't be using my fun new raspberry pi
20:13:59 <athan> especially with pandoc or hakyll
20:14:01 <Welkin> as long as you can run your binaries on ARM, you can develop them on an x86 machine
20:14:17 <athan> I actually did this very thing Lokathor :P
20:14:27 <athan> dude do you need a comp?
20:14:39 <Welkin> why would you run linux in a vm?
20:14:46 <Lokathor> Welkin: actually i cannot since i can't get pdcurses to play nice with the MingW that the Haskell Platform comes with, so I can't get hscurses to install on windows right now
20:15:11 <Welkin> you get half of your machine, at most
20:15:17 <Lokathor> okay okay start over: I have a windows desktop, and a raspberry pi running debian, and from the windows desktop i am ssh'd into the pi via putty
20:15:36 <Welkin> so the host machine and the virtual machine are both crippled
20:16:12 <Lokathor> well, if you think that windows cripples a computer, then i suppose the answer to your question would be yes
20:16:28 * hackagebot hasql-postgres 0.10.2 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.10.2 (NikitaVolkov)
20:16:34 <Welkin> no, I mean that a virtual machine allocates resources, leving less for your host machine
20:16:47 <Welkin> so both of them have fewer resources
20:17:13 <Lokathor> anyway, I keep changing a file and running it again without recompiling it because i'm forgetful, and i was just wondering if i could make ghc recompile it and auto-run it if it recompiles properly
20:17:22 <Welkin> it's like two people trying to sit in the same chair
20:17:55 <Welkin> Lokathor: just write a shell script
20:18:02 <Lokathor> I figured
20:26:50 <Lokathor> so if i've discovered a potential bug of sorts in a wiki article on haskell.org.. should i put that in the discussion or what?
20:28:59 <Welkin> I believe there is somewhere to submit updates
20:29:52 <Lokathor> specifically, in the Roll Your Own IRC Bot page, there's a mild problem with how it joins a channel
20:30:08 <Lokathor> on some servers, you have to send your join command after they finish their MOTD
20:30:49 <Welkin> oh, that particular article has all kinds of problems
20:31:05 <Welkin> it also include `import Control.Arrow` without actually using anything from it
20:31:19 <Welkin> it is an old article that needs to be cleaned up
20:31:36 <Welkin> but I found it useful nonetheless
20:32:24 <dgomez> hey all, sorry I'm only a screwup. not sure what's wrong with me. I tried updating to cabal 1.22. attempted to update ghc via git but git kept giving me "illegal" errors which it has never done before. SO couldn't update ghc or cabal packge manager.
20:32:27 <lpaste> dgomez pasted “Diagram 11” at http://lpaste.net/118544
20:32:47 <dgomez> anyway i've been having trouble speaking my thought process here to anyone in person.
20:33:10 <dgomez> but trying to see if I what I'm thinking in terms of instances s correct. i don't see why...
20:33:38 <dgomez> I have to create types like circle which are already defined in some of the imported classes
20:34:10 <dgomez> and create instances of them referring to Diagram. I tried playing around with defaultMain from Yesod but it didn't help
20:35:01 <dgomez> the only reason I created instances was due to the (#) postfix function application
20:35:47 <dgomez> meaning I thought I could create a type lolly refer it to Diagram Typeclass and in the instance use type circle and apply the qualities I wanted the circle to have with (#)
20:36:03 <dgomez> greenbagels: hi
20:36:37 <dgomez> I know this probably doesn't make sense. once i get home and before bed I'm going to go over as much as LYAH for tomorrow...
20:36:58 <Welkin> dgomez: nothing in that file makes any sense to me
20:37:33 <dgomez> Welkin: ok, that's fairbut why?
20:37:34 <Welkin> there is no context for what those types/typeclasses are
20:38:14 <dgomez> Welkin: what do you mean by context? Aren't the type class I'm referring to the ones that have been imported?
20:38:33 <Welkin> I have never seen most of those imports before
20:38:49 <Welkin> I don't know what Diagrams is
20:38:57 <dgomez> Welkin: wellthey exist.
20:40:22 <Welkin> well, if you want help, you'll have to include that information
20:40:51 <dgomez> Welkin: what information? the links to those classes on Hackage?
20:41:44 <Welkin> what is the typeclass definition for Diagram? What is #?
20:44:35 <athan> Is there a Co-List, with a structure `List a = Snoc a (Maybe (List a))`?
20:45:01 <dgomez> (#) :: a -> (a -> b) -> b
20:45:10 <dgomez> Welkin: http://projects.haskell.org/diagrams/haddock/Diagrams-Util.html
20:45:31 <dgomez> But I'm not sure how to use lambdabot to demonstrate that type def
20:45:36 <Axman6> athan: yes, you just wrote it :P
20:45:53 <Welkin> dgomez: you never stated your issue either
20:45:58 <athan> Axman6: No....
20:46:02 <athan> shoot
20:46:09 <Axman6> yeah, I just saw it!
20:46:30 <johnw> athan: I don't think that would be the structure of a co-list
20:46:47 <athan> johnw: I don't think so either
20:46:50 <dgomez> Welkin: I didn't I just talked about why I decided to create instances and sort of why I thought to do that. I can't run it. bc of indentations errors I don't understand
20:47:05 <athan> but it still is isomorphic (I'm pretty sure) to a normal inductive list
20:47:17 <johnw> athan: in the literature, there is mention of a cofree comonoid
20:47:30 <athan> hmm
20:47:35 <athan> thank you :)
20:48:17 <dgomez> Welkin: not there there aren't any issues. for example circle in diagrams has type let me find it
20:48:21 <athan> johnw: I can't focus on literature at the moment, would you be willing to help me with vocabulary and historical correctness?
20:48:27 <johnw> heh, it was even mentioned in this channel, on 7/15/2013
20:48:29 <athan> It should just be this one line :P
20:48:32 <athan> very small
20:48:50 <Lokathor> given a function :: IO Maybe Char, how do i repeat it until Nothing and then make a string of the results?
20:48:53 <athan> wow
20:49:01 <athan> that's crazy hahaha
20:49:16 <Lokathor> oh
20:49:17 <Lokathor> whileJust
20:49:22 <Lokathor> okay cool
20:50:07 <athan> johnw: What do comonoids look like?
20:50:21 <johnw> athan: dmwit said way back then: "comempty _ = () and comappend a = (a, a)"
20:50:27 <johnw> i'm trying to think of how that would encode as an ADT
20:50:45 <johnw> you can see their discussion at http://ircbrowse.net/day/haskell/2013/07/15
20:51:12 <dgomez> square :: (TrailLike t, Transformable t, V t ~ R2) => Double -> t
20:51:21 <athan> johnw: Thank you :)
20:51:22 <dgomez> better example Welkin:
20:52:55 <dgomez> Welkin: however, ill be back on once i get home I want to check this but I'm going to miss my BUS
20:54:36 <Axman6> @hoogle whileJust
20:54:36 <lambdabot> No results found
20:57:12 <athan> johnw: contralist?
20:57:30 <johnw> i'm not sure what that would mean
20:57:52 <Lokathor> @src whileJust
20:57:52 <lambdabot> Source not found. Are you typing with your feet?
20:58:06 <Lokathor> yes, I am lambdabot, good catch
20:58:12 <athan> a cofree comonoid where Nothing is mempty and mappend is just nesting
20:58:13 <Javran> where can I find the implementation of  "Ord a => Ord (Maybe a)" ?
20:58:40 <johnw> athan: comempty has to be (), there is no other choice
20:58:58 <johnw> comonoids in Haskell are highly uninteresting
20:59:09 <athan> hmm :\
20:59:15 <Axman6> Probably in Data.Ord, but basically Just a > Nothing forall a, and it becomes Ord on a for the case of two Justs
20:59:16 <athan> why?
21:00:12 <Javran> Axman6: what about Nothing `compare` Nothing? False I guess?
21:00:13 <athan> wait, this has to be `stream` or something
21:00:20 <Axman6> EQ
21:00:27 <Axman6> > compare Nothing Nothing
21:00:28 <lambdabot>  EQ
21:00:40 <Axman6> > compare Nothing (Just undefined)
21:00:41 <fread2282> @tell jonsterling what are your ideas about reasoning about external code in dependent types?
21:00:41 <lambdabot> Consider it noted.
21:00:42 <lambdabot>  LT
21:00:46 <johnw> athan: http://stackoverflow.com/questions/15418075/the-reader-monad/15419213#15419213
21:00:49 <Javran> > Nothing < Nothing
21:00:50 <lambdabot>  False
21:01:12 <johnw> athan:  see where he says that the instance given is the only possible instance
21:01:30 <Javran> hmm interesting
21:01:53 <Axman6> > [(a,b,compare a b) | a <- [Nothing, Just ()], b <- [Nothing, Just ()]]
21:01:53 <Javran> but here (Nothing :: Maybe a), what exactly is that "a"
21:01:54 <lambdabot>  [(Nothing,Nothing,EQ),(Nothing,Just (),LT),(Just (),Nothing,GT),(Just (),Jus...
21:01:55 <johnw> fread2282:  what you mean by reasoning about external code?
21:02:19 <Axman6> Javran: it will default to ()
21:02:20 <Javran> > () `compare` ()
21:02:21 <lambdabot>  EQ
21:02:43 <Javran> Axman6: I see, thanks!
21:03:05 <fread2282> johnw: allowing you to use gmp nats in a dependently typed lang at the type level for example
21:03:18 <Lokathor> {-# SPECIALIZE whileJust  :: IO (Maybe a) -> (a -> IO b) -> IO [b] #-} what is this doing in a haskell file?
21:03:18 <bgamari> does cabal sandbox not cover packages like bytestring?
21:03:44 <bgamari> I'm still finding that cabal complains about reinstallations of bytestring even in a fresh sandbox
21:04:09 <RustyShackleford> is Learn You a Haskell good?
21:04:09 <fread2282> johnw: without special compiler support
21:04:20 <johnw> fread2282: has anyone done that?
21:04:24 <RustyShackleford> like, are there certain topics it doesn't cover?
21:04:39 <Axman6> Lokathor: makes a specialised instance of whileJust for IO. it's often used when you have functions which are generic, but you know there's types it will be commonly used for (Int is one very common example)
21:04:39 <fread2282> johnw: i don't know
21:05:01 <Axman6> RustyShackleford: there are many topics it doesn't cover, but that doesn't make it not good
21:05:09 <Lokathor> RustyShackleford: It's a good book. I went through it and learned a lot, particularly towards the end. However, I would say it's only a starting place
21:05:11 <bgamari> RustyShackleford, it is
21:05:38 <athan> man, that's crazy. I think this is still a monoid then johnw
21:05:43 <Lokathor> Axman6: So by making a specialized instance it compiles faster or something?
21:05:45 <athan> just a cofree monoid
21:05:47 <fread2282> Lokathor: SPECIALIZE gets ghc to generate a (potentially) more efficient version of the function for that type
21:05:53 <Lokathor> hmm
21:06:03 <Axman6> Lokathor: it (hopefully) produces faster code in the compiled binary
21:06:03 <bgamari> RustyShackleford, I found it quite good to get a start; that being said I really only started really learning after I started writing code
21:06:17 <Javran> > Just undefined > Nothing
21:06:19 <lambdabot>  True
21:06:28 <RustyShackleford> bgamari: well my problem was I didn't even know what to write
21:06:30 <fread2282> Lokathor: SPECIALIZE without INLINE iirc will make faster code, SPECIALIZE w/ INLINE will only make compiles faster
21:06:32 <johnw> fread2282: the idris project page says "Compiling Nat via GMP integers"
21:06:54 <RustyShackleford> things are definitely coming together, but I have to read LYAH again, but more thoroughly this time
21:06:57 <fread2282> johnw: yes, but it has special compiler support and uses peano nats at compile time
21:06:58 <Lokathor> in the file i'm looking at there's a few specialize lines above a super generic function, so i guess that explains things
21:06:59 <Javran> > Just (Just undefined) > Just Nothing
21:07:00 <johnw> athan: show me the instance, and proof of the laws, and I will believe you :)
21:07:00 <lambdabot>  True
21:07:31 <bgamari> RustyShackleford, IMHO a few quick reads will be more productive than one very slow, thorough read
21:07:36 <Javran> @hoogle a -> b -> b
21:07:37 <lambdabot> Prelude seq :: a -> b -> b
21:07:37 <lambdabot> GHC.Conc.Sync par :: a -> b -> b
21:07:37 <lambdabot> GHC.Conc par :: a -> b -> b
21:07:43 <Lokathor> RustyShackleford: I'd say that you need to just try doing things until you can't, and then re-read the book after having gotten stuck on several things
21:07:51 <bgamari> read, taking up what you can as you go along
21:08:01 <bgamari> try writing code as you learn
21:08:05 <bgamari> take up any project you can
21:08:34 <bgamari> some people like Project Euler problems, although I'm not convinced they are really the best thing to cement understanding of a new language
21:08:37 <johnw> fread2282:  in terms of doing it without any special compiler support, I have no ideas
21:08:54 <bgamari> if you have an existing piece of code in another language, you could try rewriting it
21:08:59 <Javran> > Just (undefined `asTypeOf` 1) > Nothing
21:09:00 <lambdabot>  True
21:09:03 <johnw> RustyShackleford: what kinds of things you want your computer to do for you?  Pick the easiest of those tasks and write that
21:09:33 <RustyShackleford> i don't have a pressing need for a project, so I'm just trying to write blackjack
21:09:38 <Axman6> > Just (undefined `asTypeOf` id) < Nothing
21:09:39 <lambdabot>  No instance for (GHC.Classes.Ord (a0 -> a0))
21:09:39 <lambdabot>    arising from a use of ‘GHC.Classes.<’
21:09:53 <RustyShackleford> mostly I wanted to learn a functional language
21:09:54 <johnw> my very first Haskell program was a universal un-archiver,  because I was tired of unzipping files and having a bunch of random files scattered around in my current directory
21:10:09 * athan brain... sum ~ ... product...
21:10:37 <Axman6> > compare () undefined
21:10:38 <lambdabot>  *Exception: Prelude.undefined
21:10:54 <Lokathor> Project Euler made me think more about math than about haskell when i tried it >_<
21:11:18 <Lokathor> also it made haskell look slow compared to javascript >_>
21:11:30 <Axman6> you were doing it wrong then =)
21:11:32 <MP2E> You were probably using the wrong data structures ;)
21:11:53 <Lokathor> I was ONLY trying to access the 10,000th element out of an infinite list of primes, honest coppa!
21:11:54 <MP2E> perhaps in addition to other things. death by a thousand papercuts :P
21:12:00 <MP2E> List
21:12:03 <MP2E> that's your problem ;)
21:12:18 <Lokathor> ha, and also i was computing primes super slow
21:12:21 <RustyShackleford> Lokathor: yeah project euler is definitely more about math
21:12:36 <RustyShackleford> the most efficient solution requires knowing the math "trick"
21:13:21 <RustyShackleford> anyway, what is the big deal about haskell being lazy?
21:13:36 <RustyShackleford> I've seen the pattern of lazy objects in python, and frankly I don't like it
21:13:40 <Lokathor> > take 5 (map (+8) [1..])
21:13:42 <lambdabot>  [9,10,11,12,13]
21:13:43 <Lokathor> woo
21:14:06 <RustyShackleford> can you get wierd errors that are difficult to debug because of laziness?
21:14:09 <EvanR> ive seen a lot of things i dont like in python
21:14:17 <Lokathor> lazy python objects, if they're anything like lazy java objects, are not the same concept exactly as haskell lazyness
21:14:48 <MP2E> not so much weird errors, but you can get strange memory usage RustyShackleford. For instance, try using 'foldl (+) 0 [1..100000000]' to see what i mean
21:14:50 <EvanR> RustyShackleford: well, you can avoid errors by writing code in a certain style, one that cant error. it really helps if IO is not involved
21:14:51 <Lokathor> I've never had a *weird* error because of lazyness, though I have had a stack overflow for using foldl wrong, but they warn you about that
21:14:55 <RustyShackleford> i take laziness to mean that something isn't evaluated until it's value is actually needed
21:15:10 <johnw> RustyShackleford: yep
21:15:13 <Lokathor> exactly
21:15:27 <RustyShackleford> so the reddit api is one python libary that used laziness
21:15:32 <MP2E> RustyShackleford: thankfully Haskell has strictness annotations, so you can make things strict that need to be, or that you know for a fact are always evaluated anyway
21:15:41 <johnw> RustyShackleford: other languages have some form of laziness
21:15:42 <EvanR> lazy in dynamic languages is horrendous because you *expect* to get runtime errors while youre developing your code, theres no static checking
21:15:43 <johnw> Python generators are lazy
21:15:50 <EvanR> sometimes not even misspelled variable checking
21:15:54 <johnw> but in Haskell, it's the default for nearly all evaluations
21:15:59 <RustyShackleford> you would create some object incorrectly. Then somewhere later in the program, you use the object, and thats when you realized things are f-ed up
21:16:05 <johnw> it makes all of our lists behave like generators
21:16:11 <MP2E> Ah
21:16:25 <EvanR> RustyShackleford: lazy IO is really a totally different beast, you indeed will get hard to debug errors, IO errors
21:16:45 <Lokathor> RustyShackleford: haskell lazy is more like java lazy initialization than like python. Things dont' get computed if they're not needed, but the type checker is with you all the way
21:16:49 <MP2E> RustyShackleford: we don't have this problem in Haskell because of the strong static type system + properties that being purely function give us
21:16:51 <fread2282> johnw: for gmp, giving a place to hook in a specific unifier/solver (that is, for ffi functions, you annotate them with "instead of using normal form for definitional equality, run this code") might work (just hook in a ring solver), and klee (llvm symbolic machine) exists for arbitrary c code (and you get proven save C code!, but it's slow and iirc undecidable), but I don't know how well that would work in practice
21:17:00 <RustyShackleford> Lokathor: where would I see lazinees in java?
21:17:05 <MP2E> purely functional *
21:17:19 <johnw> fread2282:  sound like a thesis in the making to me :-)
21:18:20 <Lokathor> RustyShackleford: Not sure of a good example off the top of my head... I've seen it before in some libraries.. obj = null; then later the getter says something like "if(obj==null){initObj();} return obj;", so it never initializes until you try that first .getObj() call
21:18:39 <EvanR> java, it burns
21:18:57 <athan> johnw: http://lpaste.net/118545
21:19:16 <athan> I'm a dummy one sec
21:19:33 <johnw> athan: your type just NonEmpty
21:19:35 <athan> http://lpaste.net/118545
21:19:36 <johnw> is just*
21:19:46 <RustyShackleford> Lokathor: oh okay, i've seen that. Singletons use that pattern
21:19:48 <athan> ?
21:20:15 <Lokathor> RustyShackleford: oh not singletons, they burn more than most java XD
21:20:18 <johnw> data NonEmpty a = a :| [a]
21:20:20 <EvanR> RustyShackleford: laziness makes a lot of simple patterns actually work, rather than infinite looop
21:20:31 <johnw> is isomorphic to data Foo a = a :| Maybe (Foo a)
21:21:16 <johnw> just as [a] is isomorphic to data Bar a = Maybe (a, Bar a)
21:21:36 <athan> ><
21:21:37 <Hijiri> RustyShackleford: If you've already gone through lyah, I'd recommend https://github.com/bitemyapp/learnhaskell instead of going through it again
21:21:41 <Lokathor> ghc is giving me a parse error because it doesn't like my indentation :(
21:21:41 <athan> thank you johnw
21:21:46 <johnw> so, no co-ness yet :)
21:21:58 <athan> hahaha
21:22:08 <johnw> but this kind of research is the right way to dig into this stuff!
21:22:17 <athan> :| is product?
21:22:28 <johnw> no, it's just a data constructor with an operator name
21:22:31 <athan> :)
21:22:38 <athan> ahh okay :)
21:22:42 <johnw> it's from http://hackage.haskell.org/package/semigroups-0.16.0.1/docs/Data-List-NonEmpty.html
21:22:44 <athan> Wooo!
21:22:48 <adas> > take 10 (let fib = 0:1:(zipWith (+) fib (tail fib) in fib)
21:22:49 <lambdabot>  <hint>:1:52: parse error on input ‘in’
21:23:09 <Lokathor> Hijiri: wow that seems to be quite a good resource
21:23:17 <adas> > take 10 (let fib = 0:1:(zipWith (+) fib (tail fib)) in fib)
21:23:18 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
21:23:19 <athan> So the way I see it, I can do reverse induction with a non-empty list
21:23:30 <athan> er shoot
21:23:34 <adas> is that idiomatic?
21:23:54 <athan> is induction always from the outside-in?
21:24:08 <athan> ...structural induction?
21:24:10 <johnw> you can define many induction principles
21:24:17 <johnw> it can go from end to beginning
21:24:19 <fread2282> johnw: heh :), i'm not at (or near) that point though, so i doubt it
21:26:25 <athan> johnw: Awesome :)
21:26:43 <johnw> athan: are you doing software foundations yet?
21:26:58 <athan> johnw: Soon!!
21:27:05 <athan> I'm thinking about it literally every day
21:27:09 <johnw> you would eat that stuff up, if you like thinking about this
21:28:29 <johnw> induction, by the way, is just Curry-Howard for "recursion"
21:28:39 <johnw> when you write an induction proof, you're writing a recursive function
21:28:53 <trap_exit> is there something like num-haskell, i.e. sorta like num-py, but based on haskell instead?
21:29:14 <johnw> http://blog.ezyang.com/2013/04/the-difference-between-recursion-induction/
21:29:40 <Axman6> trap_exit: not really, but you should talk to carter
21:30:04 <athan> johnw: I still need more knowledge as to when I _really_ inhabit a type, but I think I'm getting closer :)
21:30:22 <athan> johnw: I'll read that if you check out this weird code error really quick!
21:30:23 <johnw> when the type-checker says you do :)
21:30:25 <trap_exit> carter: some guy (or girl) named Axman6 said we should talk
21:30:25 <athan> It's strange
21:30:37 <trap_exit> actually, probably guy, since it's Axman6, nto Axwoman6
21:30:47 <athan> the types aren't evaluating in the right way
21:30:54 <johnw> huh?
21:31:24 * Axman6 identifies as doge-kin and is morally offended
21:31:44 <athan> its a perfect example of how I could re-design this code so the types are additively sound on the outer-most `cons` cells first, and not from the inner base case
21:31:47 <athan> one sec
21:33:35 <EvanR> athan: have you tried idris?
21:33:40 <athan> johnw: https://github.com/athanclark/dag
21:33:45 <EvanR> or agda
21:33:49 <athan> EvanR: I was using Agda for a little while
21:33:59 <athan> I'm doing crazyness right now though
21:34:05 <johnw> there are days when I wish record constructor syntax allowed <=> to mean what <*> means when you turn the record construction into a regular data constructor call
21:34:25 <johnw> Foo { fieldA <=> return 10; fieldB <=> return 20 } == Foo <$> 10 <*> 20
21:34:26 <athan> johnw: If you compile it in a sandbox, and hop in on `cabal repl`, `:set -XDataKinds` then try
21:34:29 <Axman6> I found idris really approachable
21:34:30 <EvanR> configurable notation would be really cool
21:34:31 <johnw> (with returns at the end)
21:34:48 <athan> `:t GCons (Edge :: EdgeValue Baz Bar) GNil`
21:34:53 <johnw> athan: I do not use cabal, and I'm in the middle of doing work
21:35:03 <athan> Oh shoot I'm sorry
21:35:05 <johnw> I can look at pasties, but getting into code is too much
21:35:07 <athan> thank you for your help!!
21:35:13 <athan> dang
21:35:15 <johnw> I love talking data type theory :)
21:35:21 <trap_exit> i want
21:35:22 <trap_exit> numhaskell
21:35:36 <johnw> I'm wrestling with the subtleties of Hoopl at the moment
21:35:40 <Axman6> trap_exit: what do you actually want to do?
21:36:02 <Axman6> trap_exit: vector and Repa can get you a lot of the way for linear algebra type things
21:36:07 <trap_exit> Axman6: I'd like something like Matlab / R/ Julia ... but code Haskell instead
21:36:08 <Axman6> and image processing
21:36:17 <athan> johnw: https://github.com/athanclark/dag/blob/master/src/Data/Graph/DAG.hs
21:36:24 <trap_exit> Axman6: yeah, but they seem to lack on the "interactive:" + "plot this data" aspect
21:36:27 <athan> Holy crap
21:36:31 <liyang> johnw: I'm sure you could achieve that update syntax with quasiquotes...
21:36:45 <EvanR> athan: im reading type theory and functional programming, it has exercises. also theres ##typetheory but so far its way out of my league
21:37:04 <johnw> liyang: possibly so, if weren't somewhat allergic to TH
21:37:30 <athan> EvanR: Same :P I can't wait to learn it
21:37:44 <johnw> athan: props for sorting your language extensions by length :)
21:38:11 <Lokathor> I have caused a loop that won't terminate but i'm not sure where
21:38:21 <johnw> Lokathor: you get <<loop>>?
21:38:37 <johnw> or hanging?
21:39:02 <athan> johnw: u_u
21:39:34 <Lokathor> well, using hscurses, it's supposed to read input until something other than a KeyChar appears, but if i press F1 (for example) it'll print the escape sequence for it without reading proeprly and breaking the loop :/
21:39:58 <athan> Lokathor: Are you using record overwriting syntax?
21:40:11 <athan> like `foo {field = "bar"}`?
21:40:16 <Lokathor> oh, no
21:40:26 <Lokathor> just normal monadic recursion
21:40:27 <athan> any recursive let statements?
21:40:42 <athan> Can I check it out?
21:40:48 <lpaste> Lokathor pasted “loop problem” at http://lpaste.net/118550
21:41:28 <Lokathor> my goal here is to read until a newline is typed, then stop. I think i made it too general
21:41:59 <johnw> I think getCh is always returning a KeyChar
21:42:01 <athan> hmm
21:42:03 <athan> idk
21:42:05 <johnw> since newline is also a KeyChar, isn't it?
21:42:38 <Lokathor> yeah, but F1 shouldn't be a KeyChar according to the docs...
21:42:45 <Lokathor> it should be a (KeyF Int)
21:42:47 <Hijiri> ncurses vs hscurses: why might I choose one over the other?
21:42:55 <Hijiri> ncurses seems to have been updated more recently
21:43:04 <Hijiri> (the haskell bindings package)
21:43:08 <johnw> how is "otherwise" working inside a case?
21:43:17 <johnw> that should just be an alias for True
21:43:39 <Lokathor> don't you put otherwise at the end of some cases to catch all other cases?
21:43:55 <johnw> no, you use "_"
21:44:04 <johnw> otherwise is for guards
21:44:07 <Lokathor> oh my
21:44:09 <MP2E> yes
21:44:14 <MP2E> that's why you're recursing infinitely
21:44:16 <Axman6> otherwise in a case statement defined a new variable
21:44:36 <MP2E> also note 'otherwise = true' :v
21:44:37 <Axman6> case foo of otherwise -> blah === case foo of x -> blah
21:45:02 <Axman6> remember, you can't use values to define patterns
21:45:13 <Lokathor> well, that's one thing fixed, but it still doesn't seem to work right
21:46:50 <pavonia> > case False of { x | x == otherwise -> x; otherwise -> otherwise }
21:46:51 <lambdabot>  False
21:48:27 <MP2E> o.O
21:48:41 <HeladoDeBrownie> pavonia, i think that second case is binding otherwise as a variable.
21:48:50 <Axman6> yes
21:48:53 <MP2E> me too, that's the only thing that makes sense to me
21:49:02 <HeladoDeBrownie> well, the first case is the one being taken
21:49:06 <HeladoDeBrownie> wait no
21:49:12 <HeladoDeBrownie> i was thinking otherwise = False
21:49:15 <HeladoDeBrownie> but it's True
21:49:21 <HeladoDeBrownie> so yeah, the second case is being taken
21:49:31 <HeladoDeBrownie> and it matches anything, and gives that same value
21:50:01 <HeladoDeBrownie> > case False of { x | x == otherwise -> "first case"; otherwise -> "second case" }
21:50:02 <lambdabot>  "second case"
21:50:05 <HeladoDeBrownie> > case True of { x | x == otherwise -> "first case"; otherwise -> "second case" }
21:50:07 <lambdabot>  "first case"
21:50:08 <HeladoDeBrownie> > case True of { x | x /= otherwise -> "first case"; otherwise -> "second case" }
21:50:10 <lambdabot>  "second case"
21:50:17 <HeladoDeBrownie> hrm, woops
21:50:45 <HeladoDeBrownie> i lost track of what i was trying to display :P
21:51:45 <HeladoDeBrownie> > > case False of { x | x == otherwise -> x; x | otherwise -> otherwise }
21:51:46 <lambdabot>  <hint>:1:1: parse error on input ‘>’
21:51:49 <HeladoDeBrownie> > case False of { x | x == otherwise -> x; x | otherwise -> otherwise }
21:51:50 <lambdabot>  True
21:51:59 <HeladoDeBrownie> that is what i meant to do
21:53:54 <monochrom> I wonder if you like this better: case False of { x | x == otherwise -> x | otherwise -> otherwise }
21:54:23 * HeladoDeBrownie forgot that was a thing
21:54:42 * HeladoDeBrownie doesn't do complicated things with case :P
21:57:42 <lpaste> Lokathor pasted “working getString” at http://lpaste.net/118557
21:57:49 <jonsterling> fread2282: it can be done using singleton types. term could be judgementally equal to reference impl, but extracted to some machine primitive
21:59:36 <johnw> jonsterling: that's similar to what I said about idris, isn't it?
22:07:29 <JogBogOpTop> What do you do when a getLine is being skipped in a do statement?
22:07:48 <Axman6> "being skipped"?
22:08:42 <Lokathor> like, is a linebreak sitting in stdin already?
22:09:35 <geekosaur> I'm betting they read a character, while in line mode
22:09:49 <JogBogOpTop> The function displays a passed in prompt, takes input through input <- getLine then prints out what was just collected. The result is it printing out "" and later when that input is used it throws an error
22:10:13 <geekosaur> (elsewhere)
22:10:45 <Lokathor> we might need to see the whole function in an lpaste
22:10:49 <Axman6> JogBogOpTop: you probably need to turn off line buffering
22:10:56 <Axman6> @hoogle setBuffering
22:10:56 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
22:10:56 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
22:11:24 <Axman6> hSetBuffering stdout NoBuffering -- that's probably the line you need at the beginning of main
22:11:37 <geekosaur> if this is what I think it is, buffering will not help --- it is the terminal driver that is in line mode
22:11:41 <u-ou> :t maybe
22:11:42 <lambdabot> b -> (a -> b) -> Maybe a -> b
22:12:34 <JogBogOpTop> I've tried import System.IO (hSetBuffering, stdin, BufferMode(NoBuffering))
22:12:51 <geekosaur> just the import?
22:12:58 <jonsterling> johnw: I have not been following, but it is very plausible! I'm sure Idris has tricks like that special cased in certain places. I'm interested in exposing it to user-level code using types though.
22:17:24 <JogBogOpTop> Sorry, I called hSetBuffering stdin NoBuffering right off the bat in main
22:18:24 <Axman6> try stdout
22:19:29 <JogBogOpTop> you mean hFlush stdout
22:19:30 <JogBogOpTop> ?
22:19:45 <Axman6> I mean set NoBuffering on stdout
22:20:24 <Axman6> perhaps I don't understand your problem, but if you're writing interactive programs, you usually want that
22:21:37 <JogBogOpTop> I've tried disabling it for both with no dice
22:26:29 * hackagebot scalpel 0.1.0 - A high level web scraping library for Haskell.  http://hackage.haskell.org/package/scalpel-0.1.0 (fimad)
22:27:17 <fread2282> jonsterling: makes sense, but with singletons doesn't the reference impl need to be used at compile time?
22:27:53 <jonsterling> I don't know what compile time means in this case. the two phases I am thinking about are "voters
22:27:55 <jonsterling> oops
22:28:01 <ReinH> jonsterling: o/
22:28:16 <jonsterling> ... are "conversion/type checking" and "extraction"
22:28:55 <jonsterling> the reference implementation is used in the judgemental equality, and the real deal is used in extraction.
22:30:38 <jonsterling> note, however, that using this trick means that you cannot normalize the proof term and then extract its realizer (since you will have lost track of the proper term due to eta expansion at singleton type). you will have to extract full proofs and then perhaps normalize the extract terms
22:31:56 <jonsterling> I have a working implementation of type theory with singleton types and observational equality, and I intend to implement a variant of this trick soon. / fread2282
22:32:16 <fread2282> jonsterling: nice
22:34:57 <fread2282> jonsterling: my concern is that the reference impl is slow
22:36:24 <fread2282> I guess binary numbers as the reference impl would be faster, but still
22:36:47 * fread2282 wants my compiler to be fast
22:36:59 <fread2282> *his
22:39:17 <fread2282> also, it sounds like it would complicate removing the phase distinction/allowing eval (or at least making it work without extra info and redundant work)
22:42:42 <u-ou> > toInteger (255 :: Word8)
22:42:44 <lambdabot>  255
23:03:02 <Negron-z> hello someone is here ?
23:03:53 <brbblnch> Hi.
23:09:49 <dgomez> Welkin: off to bed but hopefully I can discuss more about my usage of the shape types tomorrow
23:09:55 <dgomez> or ust anyone
23:09:59 <dgomez> just*
23:10:46 <dgomez> bye Negron-z and brbblnch stubborn_d0nkey greenbagels
23:19:10 <brbblnch> I thought about a markup language (for my own use). What would be the best thing to do to implement it? Should I write Lexer+Parser+[latex translator], or directly modify something like pandoc to read it?
23:21:23 <abg> Hey. I can't seem to create a new account on Hackage. I've tried twice now, and both times it said it sent me the activation email but it never arrived. Not in the junk folder either. Is there a trick I'm missing?
23:23:36 <Javran> is it possible for a cabal project to know the exact version of a dependency it is using?
23:25:00 <Javran> i tried "import Paths_{dependency project name} (version)" but that doesn't work
23:33:30 <Lokathor> opinions: is GHC 7.4 reasonably recent? or should I strive to get a newer version?
23:34:02 <shachaf> It's a bit old. 2012
23:34:08 <shachaf> It depends on what you want with it.
23:35:27 <Lokathor> nothing too fancy at the moment. As long as it's not clearly obsolited by some new development i'll stick with it i suppose
23:35:36 <abg> Javran: my understanding is that the Paths_$name is available to package $name only -- unless it exports it in exported-modules.
23:36:40 <Javran> abg: I guess so, is there some other way to know that if the lib itself doesn't provide it?
23:37:15 <glguy> Javran: If you want that information you can do what lens does with a Custom setup script
23:37:33 <abg> I'm not sure how you would get the exact dependency version. Depending on your use case, just the CPP extension and the MIN_VERSION_* macros may be enough.
23:37:35 <glguy> See: https://github.com/ekmett/lens/blob/master/Setup.lhs
23:37:59 <glguy> Typically you'd use the MIN_VERSION_ macros as just mentioned
23:39:03 <Javran> glguy: isn't MIN_VERSION means the minimum version number satisfying .cabal file?
23:40:02 <glguy> No, it is a test that returns TRUE when the version being used is the version specified when calling that macro or greater
23:41:04 <Javran> glguy: ah I see
23:42:10 <Javran> glguy: abg: I just took a look at cabal_macros.h, it's sufficient already, thanks!
23:43:25 <Sopoforic> I've recently installed the Haskell Platform on Windows, and now any programs I compile run twice in a row--once in a window, and then once in the console. Can anyone tell me what could cause this?
23:43:40 <abg> Oh I didn't realize cabal_macros.h included VERSION_$package defs.
23:44:10 <Javran> abg: yeah, I'll just use them
23:44:40 <Javran> btw how to use CPP extension?
23:46:48 <abg> Add {-# LANGUAGE CPP #-} to the top of the file in which you're using them
23:47:42 <abg> After that, any mention of VERSION_$packageName will be replaced with a string literal containing whatever version of $packageName you're building against.
23:47:45 <Javran> abg: I mean how to use the macro then
23:48:16 <abg> Oh, then just use "VERSION_aeson", as a constant somewhere. Like,
23:48:18 <belst> hey, anyone knows what flag i have to set to tell ghci to use already compiled modules instead of recompiling them?
23:48:29 <Javran> abg: I see, so it works exactly like how it works in c?
23:48:32 <abg> yes
23:49:06 <Javran> abg: hmm, that does require being a little careful, thanks!
23:49:14 <abg> Generally it is recommended to assign it to a new top-level definition. Like lensVersion = VERSION_lens so that your code isn't littered with macros.
23:49:42 <Javran> abg: got it
23:50:24 <abg> So, you could have one module Dependencies.hs or something where you define top-level strings for packages whose versions you care about. This could be using the extension. Other modules don't need to use the extension or care that you are using macros to get this information originally.
23:54:45 <Javran> abg: good idea!
