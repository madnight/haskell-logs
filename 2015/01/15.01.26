01:15:25 * hackagebot minioperational 0.4.9 - fast and simple operational monad  http://hackage.haskell.org/package/minioperational-0.4.9 (FumiakiKinoshita)
01:48:48 <FUZxxl> What do Haskell programmers think of APL programmers?
01:49:40 <sinelaw> some arbitrary broad generalization
01:50:14 <FUZxxl> witty retort to your arbitrary generalization that makes Haskell look bad
01:51:49 <vanila> Haskell programmers think APL is weird and outdated
01:52:27 <FUZxxl> There are APL dialects that do not look weird, like J, but your point stands.
01:53:01 <vanila> yeah J is good
01:53:16 <FUZxxl> except that Unix support is poor
01:53:24 <FUZxxl> but otherwise it's quite nice.
01:54:38 <hvr> there were custom APL-keyboards... Haskell hasn't reached that state yet
01:55:29 <FUZxxl> there still are
01:56:19 <hvr> yeah... otoh custom keyboards with `lens`-keys would be awesome =)
01:59:32 <sinelaw> FUZxxl, I was making an arbitrary broad generalization, not answering your question
02:01:05 <pantsman-> 123
02:01:11 <pantsman-> oops, wrong window
02:01:19 <sinelaw> but just as good
02:02:44 <vanila> hey sinelaw did you make that js typechcekr thing
02:03:00 <sinelaw> vanila, yes
02:03:21 <vanila> cool , is it open source/
02:04:24 <sinelaw> vanila, https://github.com/sinelaw/sjs
02:04:28 <vanila> ty!\
02:04:29 <sinelaw> (name is temporary)
03:05:30 * hackagebot tostring 0.2.1.1 - The ToString class  http://hackage.haskell.org/package/tostring-0.2.1.1 (ErikHesselink)
03:26:17 <davison> w/c
03:44:39 <xxprismxx> hello
03:44:45 <xxprismxx> ??
03:46:57 <xxprismxx> anyone here ?!?
03:50:08 <xxprismxx> helllllloo
03:54:13 <ironChicken> any suggestions what "inappropriate type" means in Setup.hs?
03:54:29 <ironChicken> the cabal build output looks like this: http://lpaste.net/119229
03:58:55 <arianvp___> Anybody here got experience with using pipes for FRP?
04:00:35 <merijn> I don't think pipes can really do FRP, unless it's significantly changed since last I looked
04:00:58 <merijn> Tekmo had an example of something "FRP-like" in pipes-concurrency, but that struck me as very fundamentally different from FRp
04:08:26 <indiagreen> can I see release notes for GHC 7.10 anywhere?
04:09:57 <indiagreen> nevermind, found them
04:10:32 * hackagebot uri-encode 1.5.0.4 - Unicode aware uri-encoding.  http://hackage.haskell.org/package/uri-encode-1.5.0.4 (ErikHesselink)
04:15:32 <ironChicken> so i thought i'd try running my Setup.hs in the ghci debugger
04:15:47 <ironChicken> when i :step main i ge _result :: IO () = _
04:15:56 <ironChicken> and that seems to be the end of it
04:18:08 <ironChicken> will i have any success in trying to setp through Distribution.Simple.Program.Ar?
04:18:19 <ironChicken> s/setp/step/
04:19:58 <ironChicken> or should i instead try and find a way to modify it and put dissecting putStrLns all over it?
04:20:42 <Haskellfant> if I implement a simple heterogenous typesafe list like http://lpaste.net/119230, how can I create a show instance for type HList xs if every type in xs is an instance of Show?
04:20:54 <Haskellfant> or is this not possible at all in haskell
04:23:32 <alpounet> Haskellfant: you have to do it with two instances
04:23:57 <alpounet> quite similar to how you'd write a function that takes a list argument by pattern matching
04:24:25 <alpounet> i.e one instance for the empty HList: instance Show (HList '[]) where ...
04:25:05 <alpounet> and another one: instance (Show t, Show (Hlist ts)) => Show (Hlist (t ': ts)) where ...
04:27:11 <Haskellfant> alpounet: thx! one flexibleinstance and one flexiblecontexts later it works :)
04:27:33 <ironChicken> any suggestions on ghci debugger and cabal-installed packages?
04:27:55 <ironChicken> or what would be a simple way to edit the source of a cabal installed package?
04:29:41 <merijn> Haskellfant, alpounet: Alternatively you could use TypeFamilies to produce a new constraint that includes every element in the list
04:29:48 <jameseb> ironChicken: `cabal unpack` to get the source perhaps?
04:30:22 <merijn> Haskellfant: If you start playing with this type level stuff I can highly recommend the "Fun with Type Functions" paper
04:31:19 <Haskellfant> merijn: I'll definitely read it (once I have time), is the typefamilies constraint stuff explained there? I'm not too familiar with type families so I'm not quite sure how that would look
04:32:31 <hexagoxel> ironChicken: yeah, `cabal get` (which is unpack) + `cabal sandbox add-source` (if you are using sandboxes, which i would recommend for this kind of thing)
04:32:38 <merijn> Haskellfant: Basically, there's another extension called "ConstraintKinds" which lets you treat typeclass constraint as just another kind returnable by type families
04:32:53 <merijn> Haskellfant: Check out this example: https://gist.github.com/merijn/6130082
04:33:41 <ironChicken> jameseb, hexagoxel: thanks. i'm just trying it now. i wasn't using sandboxes but you're right, i probably should
04:34:47 <Haskellfant> merijn: ah nice, thanks.
04:35:12 <merijn> Although I should probably change it to import from GHC.Exts, not Prim >.>
04:36:54 <ironChicken> in a cabal sandbox, do i get my own Cabal package?
04:37:50 <hexagoxel> ironChicken: you put the sandbox in the directory where the .cabal is
04:38:41 <forgottenone> is there a filter like function for maps only returns first one?
04:38:49 <ironChicken> hexagoxel: yes, but i'm trying to dissect some code from the Cabal package (because i can't work out how to use the ghci debugger, which would be preferable, i think)
04:39:27 <ironChicken> Cabal isn't a dependency of my package
04:39:34 <merijn> forgottenone: "the first one"?
04:39:47 <hexagoxel> oh wait, you mean "the" Cabal package?
04:39:52 <ironChicken> yes
04:40:11 <ironChicken> i'm probably very far down a rabbit hole
04:41:16 <forgottenone> merijin i mean  first element that satisfies condition
04:42:07 <merijn> forgottenone: Just combine map + filter?
04:42:08 <awson_> hi
04:42:26 <merijn> "filter myPredicate . map myFun" ?
04:42:53 <merijn> (or the other way around, whatever...)
04:42:59 <dcoutts_> awson_: I think you can list .cmm files in c-files:
04:43:09 <awson_> Does anybody know if cabal recognizes .cmm files?
04:43:13 <hexagoxel> ironChicken: how does the isntalled Cabal package affect anything if you do not depend on it? are you sure you need to modify Cabal?
04:43:20 <forgottenone> merjin sorry i meant Data.Map not map function
04:43:36 * dcoutts_ psychically predicts awson_'s Qs...
04:44:07 <merijn> forgottenone: convert Map using one of the functions and then take the first element of that?
04:44:50 <forgottenone> merjin actually that's what i am doing ,but somehow i think that it slows down the code
04:45:17 <ironChicken> hexagoxel: ideally no. i'm writing a Setup.hs which is failing with the message "inappropriate type". i'm trying to work out where that message is coming from. I can see the portion of Distribution.Simple.Program.Ar where it's stopping but I'd like to know exactly where. Ideally, I'd run Setup.hs in the ghci debugger but that didn't get me anywhere. So I thought I'd try dissecting Ar.hs with putStrLns and so that's where i am now
04:45:25 <ironChicken> as i said, rabbit hole
04:45:26 <merijn> forgottenone: I don't think it will, that should be a fairly cheap operation
04:45:37 <wz1000> If types don't exist at runtime, how does recursion of polymorphic functions work?
04:45:55 <merijn> forgottenone: Unless you're using a lazy Map and doing lots of inserts resulting in a big Map chunk to compute before returning the first element
04:46:10 <alpounet> awson_: re your #ghc question: https://github.com/ekmett/discrimination/blob/master/discrimination.cabal#L34
04:46:11 <forgottenone> merjin i see,then i should look other parts of my code
04:46:17 <merijn> wz1000: GHC checks the type match at compile time
04:46:18 <hexagoxel> ironChicken: then you'd need to compile the cabal-install package (yielding the `cabal` executable)
04:46:27 <hexagoxel> with the modified Cabal package, that is
04:46:50 <merijn> wz1000: In case of typeclasses GHC's translation of typeclasses results in dictionary passing (i.e. the relevant typeclass dictionary gets passed as extra argument at runtime)
04:47:05 <awson_> thanks!
04:47:15 <merijn> forgottenone: Have you started profiling it yet?
04:47:32 <JagaJaga> How to make a deforestation of (f = foldr (+) 0 . map (\x -> x * 10))?
04:47:41 <wz1000> merijn: Thanks. I heard of that in one of SPJ's videos, but completely forgot about it.
04:47:59 * hexagoxel wonders who invented the Cabal, cabal-install, cabal naming scheme
04:48:14 <merijn> wz1000: When GHC is unable to inline typeclass resolution it compiles down to something pretty much equivalent to:
04:48:23 <merijn> @google Gabriel Gonzalez scrap your typeclasses
04:48:37 <merijn> @botsnack ?
04:48:41 <hexagoxel> that stuff confuses everybody at least once, it seems
04:48:47 <merijn> No lambdabot? :(
04:48:52 <wz1000> merijn: so GHC avoids dictionary passing wherever possible?
04:48:58 <jtanguy> ironChicken: what is your Setup.hs ?
04:49:00 <wz1000> > 1 + 1
04:49:14 <merijn> wz1000: If GHC can statically figure out the typeclass lookup it will just inline the lookup directly
04:49:31 <forgottenone> merjin , actually i am still learning so i didn't think of profiling
04:49:34 <jmcarthur> wz1000: i wouldn't say "avoids." as far as i know it's more like "optimizes away."
04:49:35 <merijn> wz1000: i.e. "(5 + 5 :: Int)" <- no reason to dynamically lookup the implementation of (+)
04:49:50 <merijn> forgottenone: Real World Haskell has a chapter on profiling :)
04:51:04 <forgottenone> merjin: thanks :D i was considering to start real world haskell after finishing learn you haskell but still can't finish :D
04:52:43 <merijn> wz1000: Note that dictionary passing is merely an implementation detail of GHC and not necessarily the only way to implement it. Although I have no clue how you solve polymorphic recursion in those cases :)
04:53:45 <jtanguy> ironChicken: what is the build-type in your .cabal file ?
04:54:08 <ironChicken> jtanguy: it's here: http://lpaste.net/119231
04:54:14 <ironChicken> it's mostly stolen from the internet
04:54:28 <ironChicken> see line 46: mapM_ (createArLibArchive verbose local_bld_info bld_dir) [objs]
04:54:35 <wz1000> On an unrelated note, does a dynamic elisp like environment for haskell make sense? I would love something like that for things like xmonad, but I don't know how it fits in with static typing. It just seems weird.
04:54:50 <ironChicken> jtanguy: the build type is Custom
04:58:12 <ironChicken> hmm, so .cabal-sandbox doesn't contain any Haskell source files
04:59:55 <merijn> wz1000: There's no real theoretical issue, but there's some current pragmatic issues
05:00:26 <merijn> wz1000: It's possible to use GHC as a library, it's also possible to dynamically load (and recently unload!) libraries
05:00:27 <bitonic> with interruptible operations such as `takeMVar', can I assume that if they are interrupted the action will not be performed -- in this case the `MVar' will not be taken?
05:00:46 <merijn> wz1000: I believe dons wrote his thesis on plugins/dynamically loaded code in static languages?
05:00:53 <merijn> bitonic: Right
05:01:12 <bitonic> merijn: where are the docs on this?  `Control.Exception' talks about it but doesn't specify that
05:01:14 <merijn> bitonic: Either it will atomically take it OR it will be interrupted while waiting
05:01:31 <merijn> bitonic: Simon's book?
05:01:55 <bitonic> merijn: uhu, thanks.  damn async exceptions
05:02:51 <ironChicken> ah, ok. cabal sandbox unpack ... && cabal sandbox add-source ..
05:02:56 <ironChicken> nice
05:03:30 <hexagoxel> `cabal unpack`
05:04:30 <ironChicken> hexagoxel: thanks. typed it correctly at command line but not in irc client ;-)
05:04:35 <ocramz> hi there!
05:04:48 <merijn> bitonic: async exceptions are rather obscure and not well-understood mess
05:04:55 <bitonic> agreed
05:05:03 <ocramz> how do I get rid of an overlapping instance, arising from importing two libraries that offer similar functionality?
05:05:14 <ocramz> namely, Num (Vector Double)
05:06:04 <merijn> bitonic: This is not really a haskell issue as a "no one knows how to do these" issue, see the huge discussion/warring at: http://comments.gmane.org/gmane.comp.lang.haskell.libraries/23320
05:06:17 <merijn> ocramz: You can't
05:06:43 <merijn> ocramz: Instances have to be globally unique, if two libraries overlap you're boned
05:06:53 <merijn> This is why orphan instance are considered awful
05:06:53 <ocramz> merijn: blast and damnation
05:07:20 <ocramz> merijn: orphan instances?
05:07:24 <merijn> ocramz: Complain to whichever library has the orphan (or both if they're both orphans)
05:07:49 <merijn> ocramz: A typeclass instance is an "orphan" if it's not in either 1) the module defining the class or 2) the module defining the datatype
05:07:55 <wz1000> merijn: I just came across https://wiki.haskell.org/GHC/As_a_library#Running_interactive_statements. Could you use it to execute values in an arbritary monad, like GHCi executes values in the IO monad?
05:08:16 <merijn> wz1000: Sure
05:08:47 <merijn> ocramz: The logic being that if the instance is in one of those two, you can never clash (because either the package with the class is a dependency of the datatype or vice versa)
05:09:00 <ocramz> don't tell me I have to switch back to python for doing numerics. I'd rather stab myself in the 'nads
05:09:32 <merijn> ocramz: A more obscure way to encounter this problem may be: Both your packages are compiled against a different version of package C and they're just reexporting C's instance (which then collides with it's own new version)
05:09:52 <merijn> ocramz: Unrelatedly: #numerical-haskell :)
05:10:18 <ironChicken> cool. i now have my debugging output :-)
05:10:30 <ironChicken> shame it hasn't helped ye
05:10:31 <ironChicken> t
05:18:38 <Haskellfant> how can I give constraints in type families? I'm trying to follow merijns suggestion but all the examples I could find don't have normal type class constraints http://lpaste.net/119232
05:19:19 <merijn> You probably don't wanna go that way
05:19:55 <merijn> My example uses a closed type family (i.e. can't be extended) and it's return an empty constraint (the '()') but you can just write an existing constraint there
05:20:22 <merijn> You probably wants "type instance Showable (a ': as) = (Show a, Showable as)" or something along those lines
05:20:36 * hackagebot rest-client 0.4.0.4 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.4.0.4 (ErikHesselink)
05:20:38 * hackagebot rest-core 0.34.0.2 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.34.0.2 (ErikHesselink)
05:21:09 <merijn> And "type instance Showable '[] = ()" (empty constraint)
05:22:47 <Haskellfant> ah that makes sense, I missunderstood how constraintkinds work
05:25:36 * hackagebot rest-happstack 0.2.10.6 - Rest driver for Happstack.  http://hackage.haskell.org/package/rest-happstack-0.2.10.6 (ErikHesselink)
05:25:38 * hackagebot rest-snap 0.1.17.16 - Rest driver for Snap.  http://hackage.haskell.org/package/rest-snap-0.1.17.16 (ErikHesselink)
05:27:05 <Haskellfant> merijn: thx again, working perfectly now
05:27:45 <merijn> Haskellfant: Next up, even cooler tricks: https://gist.github.com/merijn/39dc86e345e87276c523 ;)
05:28:19 <Haskellfant> merijn: sadly it's back to java now …
05:29:42 <Haskellfant> merijn: ah that's nice!
05:29:56 <Haskellfant> I'll do this university stuff sometime … later
05:30:36 * hackagebot rest-wai 0.1.0.6 - Rest driver for WAI applications.  http://hackage.haskell.org/package/rest-wai-0.1.0.6 (ErikHesselink)
05:32:31 <jokester> a
05:40:52 <Haskellfant> merijn: isn't http://lpaste.net/119233 a bit nicer?
05:43:10 <merijn> Haskellfant: Yeah, this used to be an example for someone else where I showed how to make a list that had "max length smaller than 3" that I then generalised
05:43:25 <Haskellfant> :)
05:45:37 <AnonHax> Hello.
05:45:37 * hackagebot hpc-coveralls 0.8.3 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.8.3 (killy971)
05:46:10 <AnonHax> How is everyone today?
05:46:46 <AnonHax> Hello guys.
05:47:02 <AnonHax> I need help.
05:48:35 <vanila> whats up
05:49:13 <AnonHax> HELLOOOO GUYSSSSSSSSSSSSSS
05:49:35 <AnonHax> HEY VANILLA
05:49:42 <vanila> dude calm down people will get angry
05:49:48 <AnonHax> Sorry
05:49:53 <AnonHax> Caps had a spasm
05:49:53 <AnonHax> so
05:49:55 <AnonHax> how are you?
05:49:55 <AnonHax> :D
05:49:56 <vanila> lol
05:49:56 <AnonHax> jks
05:49:58 <AnonHax> um
05:50:01 <AnonHax> do you do haskell?
05:50:03 <vanila> yeah
05:50:12 <AnonHax> blah. I need help with a coderino.
05:50:15 <AnonHax> i love IRC
05:50:17 <AnonHax> and hacking
05:50:20 <AnonHax> hence my name
05:50:20 <vanila> why don't you paste it to lpaste?
05:50:28 <vanila> or what is the problem
05:50:32 <AnonHax> lpaste?
05:50:37 * hackagebot constrained-categories 0.1.0.0 - Constrained clones of the category-theory type classes, using ConstraintKinds.  http://hackage.haskell.org/package/constrained-categories-0.1.0.0 (leftaroundabout)
05:51:17 <indiagreen> AnonHax: yes, it's that site all cool hackers paste their codes to
05:51:29 <indiagreen> I heard there's a solution to P vs. NP problem somewhere there
05:51:31 <indiagreen> @where lpaste
05:51:38 <AnonHax> sweet
05:52:03 <vanila> :/
05:53:09 <jophish_> What data description language is currently in vogue? somehting like json or yaml
05:53:17 <jameseb> lambdabot doesn't seem to be working today...
05:53:45 <vanila> jophish_, s-expression
05:53:51 <indiagreen> hm, works as /query
05:53:54 <indiagreen> okay, again
05:53:57 <indiagreen> @where lpaste
05:54:10 <indiagreen> ...whatever
05:54:25 <jophish_> vanila:  :)
05:54:32 <jophish_> sorry (:))
05:57:55 <clrnd> :t (:)
05:58:08 <clrnd> lambdabot, hey
05:59:10 <wz1000> Hmm, it seems to be working when pm'd
05:59:48 <vanila> it works in other channels than #haskell
06:01:25 <clrnd> :(
06:02:08 <exio4> it's quieted
06:02:29 <exio4> * #haskell: lambdabot!*@* on Mon Jan 26 03:19:33 2015 by ChanServ!ChanServ@services.
06:03:16 <vanila> hmmm interesting :}
06:03:56 <nkar> terminology question: is it fine to use the term "invert" when talking about changing True to False with not?
06:04:01 <nkar> (or vice versa)
06:04:09 <vanila> yes
06:04:59 <arw> another possible synonym would be "negate"
06:06:23 --- mode: ChanServ set +o geekosaur
06:08:25 --- mode: geekosaur set -q lambdabot!*@*
06:08:40 <geekosaur> let's not abuse it this time, hm?
06:08:41 <hexagoxel> so, people cause lambdabot to spam, and chanserv automatically triggers the +q?
06:08:45 --- mode: geekosaur set -o geekosaur
06:09:04 <geekosaur> no, looks like someone asked chanserv to quiet it
06:09:44 <Denommus> Why would someone quiet lambdabot? 😢
06:09:44 <hexagoxel> huh. would be nice to know who and why..
06:10:07 <hexagoxel> > text "i am back!"
06:10:09 <lambdabot>  i am back!
06:12:40 <Denommus> :t text
06:12:42 <lambdabot> String -> Doc
06:13:38 <geekosaur> I have my guesses based on the log from last night
06:14:10 <geekosaur> but I "like" how I mention that it was being abused and the response is "why would someone quiet it" --- this nodes not well for it remaining unquieted
06:14:14 <geekosaur> *bodes
06:19:06 <hexagoxel> geekosaur: probably because "abuse" is pretty broad. you mean someone managed to make lambdabot send pm to other people or smth?
06:19:19 <merijn> hexagoxel: It can already do that
06:19:27 <merijn> hexagoxel: And has been able to for years
06:19:49 <geekosaur> people were repeatedly asked to move playing with the bot to pm, and refused
06:20:01 <hexagoxel> ah via tell..
06:20:50 <merijn> Couldn't those people have been quieted instead, then?
06:20:51 <geekosaur> there's also an admin command that can send to anyone/any channel, present so it can auth to nickserv during startup
06:21:04 <toblerone> Hi all, I'm interested in using the LLVM backend for GHC on OSX, despite having "llvm-gcc" already installed (via XCode I believe) do I still need to install LLVM? If so, which version does it expect?
06:22:07 <geekosaur> toblerone, llvm is much more than just the compilers that use it. because of the way ghc's llvm backend uses llvm, it needs the full llvm package ("developer toolkit" if you will)
06:22:27 <geekosaur> I believe currently you need llvm 3.4 because of bugs in 3.5
06:22:56 <toblerone> okay, thanks for the tip
06:23:22 <geekosaur> (patches have been submitted and accepted upstream but no release has them...)
06:23:46 <Profpatsch> :t (***)
06:23:48 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
06:25:39 * hackagebot machinecell 1.3.1 - Arrow based stream transducers  http://hackage.haskell.org/package/machinecell-1.3.1 (HidenoriAzuma)
06:36:50 <bennofs> Is there a library for writing Binary instances that allows me to write the get/put at the same time, thus making sure they will match? (like boomerang for binary)
06:38:55 <dfeuer> About how many Int operations can a modern CPU do per second?
06:41:38 <lericson> dfeuer: assuming a clock rate of 3 GHz and a 10-cycle pipeline, you would have instructions per second = cycles per second / cycles per instruction = 300 million per second in our case
06:41:45 <lericson> and that's just one core
06:42:00 <dfeuer> lericson, 300 million, or 300 billion?
06:42:07 <clrnd> assuming no CPU-level magic and no cache stuff I guess
06:42:20 <lericson> clrnd: exactly, assuming no forwarding or branch misprediction
06:42:35 <lericson> dfeuer: 300 million, 3 GHz is 3 billion cycles per second
06:43:06 <ironChicken> why do i get "* Missing C libraries: stdc++" from cabal build?
06:43:14 <dfeuer> lericson, wait, where's the 300 million come from?
06:43:16 <indiagreen> but doesn't the pipeline execute 1op/cycle once it's full
06:43:36 <RchrdB> indiagreen: no, more. :)
06:43:48 <dfeuer> Yeah, I'd expect that with all the parallelism, you'd get over 3 billion per second.
06:43:50 <lericson> dfeuer: 3 billion divided by ten :)
06:44:19 <lericson> it takes ten cycles for an instruction to execute
06:44:27 <lericson> roughly, very approximate numbers being thrown around here
06:44:50 <RchrdB> Depending on how shiny/expensive/power-hungry your CPU is, modern x86 CPUs can issue multiple instructions per cycle, provided that there aren't dependencies between the calculations being issued.
06:45:10 <lericson> ah yes, this property is called "superscalar" no?
06:45:17 <RchrdB> Yes.
06:45:57 <dfeuer> lericson, I'm just looking at some prime sieving code that's polymorphic in the integral type all the way down to the internals. I'm thinking that that's really silly, and it should just use Word64, which will take you over 133 years assuming one prime candidate (from a wheel) is checked every nanosecond.
06:46:07 <lericson> dfeuer: so not surprisingly i think we're homing in on the answer "it depends on the instructions and the processor" ;)
06:46:36 <dfeuer> I don't think it's likely that a non-parallel algorithm will be able to go even that fast, but I want to do a sanity check.
06:46:38 <geekosaur> and I am confused byt he assumption that a depth 10 pipeline means 10 cycles to execute one instruction. that's only in the case of a mis-predicted jump, no?
06:46:40 <indiagreen> dfeuer: I've done tests 4 years ago (so not “modern”) with Free Pascal (so not even Haskell) and I was getting about a billion/s, which I don't even know why I'm telling you
06:46:46 <geekosaur> (and not really correct even then)
06:47:29 <lericson> geekosaur: that's how i was taught to calculate it, runtime = instructions * cycles per instruction * seconds per cycle
06:47:31 <geekosaur> with modern cpus the answer is certainly fuzzy
06:47:53 <RchrdB> It's more complicated than that.
06:48:05 <merijn> indiagreen: Depends on if it's superscalar
06:48:17 <RchrdB> lericson: "roughly 10 cycles" is about the length of time it takes for the result of an register-only arithmetic instruction to *become available*, but that instruction may be executed in parallel with a lot of other instructions.
06:48:40 <lericson> RchrdB: you are of course referring to the case where there are no data dependencies?
06:48:59 <geekosaur> as stated earlier, yes
06:49:02 <RchrdB> Yes.
06:49:19 <merijn> indiagreen: Superscalar CPUs can execute more than 1 micro-op per cycle, assuming there's no contention for execution units/data dependency
06:49:19 <RchrdB> Modern big CPUs will also reorder instructions a lot.
06:49:43 <merijn> I suggest everyone stop speculating and whoever wants to know just buys a VTune license :p
06:49:57 <merijn> Assuming you have an Intel CPU, if not: You fool!
06:50:17 <RchrdB> merijn: that's not necessarily useful if you don't understand enough theory to read the output. >_>
06:50:26 <lericson> i recently had a course in this matter, it was funny how well they were able to tell you how a single-cycle processor works, then somewhat could tell you how a pipeline is implemented, but when it came to superscalar processors they just showed some very vague tree representation
06:50:39 <dfeuer> Still, I think no one will want to run this (mathematically) simple prime sieve (O'Neill & Smith) for over a year even assuming it can check a candidate every 10 picoseconds.
06:50:40 <merijn> RchrdB: VTune has pretty in-depth docs on what the metrics mean
06:50:47 <RchrdB> merijn: oh cool!
06:51:18 <geekosaur> lericson, some of that is because proprietary...
06:51:25 <merijn> I was really impressed by VTune :)
06:51:41 <merijn> I wasn't impressed by the performance of the VTune GUI, though >.>
06:52:13 <lericson> geekosaur: yeah right, that would mean whoever had the rights would be a de facto monopoly -- oh wait, that /is/ the case
06:53:39 <FMcC> has anyone seen the peertopeer.io haskell videos?
06:53:41 <geekosaur> (also vaguely related to this discussion and Haskell, I was moderately surprised when http://www.sciencedaily.com/releases/2015/01/150123081725.htm popped up in my reading list...)
06:54:18 <geekosaur> looks like a Haskell DSL generating VHDL?
06:54:44 <merijn> Oh, Twente, I know those guys :)
06:54:52 <lericson> genius idea
06:54:55 <merijn> geekosaur: They're more ambitious :)
06:55:14 <geekosaur> well, it's hard to intuit details from a breathless press release :p
06:55:25 <merijn> geekosaur: They want to essentially "compile math to VHDL" so the starting point is to compile a subset of haskell to VHDL
06:55:27 <RchrdB> geekosaur: AIUI, there are a lot of those, in all sorts of different languages (Scala and Haskell at least) and they're sort of a goldmine for writing academic papers that can demonstrate a practical productivity improvement because VHDL and Verilog are so painful to use for synthesis. :)
06:55:32 <merijn> Not just a mere DSL
06:55:53 <merijn> @hackage clash-ghc
06:55:53 <lambdabot> http://hackage.haskell.org/package/clash-ghc
06:56:05 <merijn> That's their stuff
06:56:20 <merijn> Conal Elliott is (was?) working on something similar, I think
06:56:33 <merijn> And of course Bluespec had a DSL for hardware generation written in haskell too
07:02:40 <sdegutis> Hi. I've just learned most of OCaml and am curious if Haskell is superior to it and why. Can anyone explain briefly?
07:04:17 <merijn> sdegutis: Sure, if you first define superior ;)
07:04:40 <osfameron> surely there are articles on this topic?
07:04:43 <flux> "compelling reasons for one to prefer one over another" :)
07:05:16 <sdegutis> Yeah like flux said.
07:05:17 <merijn> sdegutis: More practically speaking, some differences between OCaml and haskell are: Haskell is lazy, purely functional, has higher kinded types, typeclasses and more powerful type level programmability
07:05:54 <merijn> sdegutis: Haskell is lacking a higher-order module system
07:06:10 <merijn> Although some people are working on allowing a more "ocaml-like" module system
07:06:31 <sdegutis> ok
07:06:34 <merijn> Personally I find ocaml's syntax awfully ugly too, but that's a rather personal objection :)
07:06:44 <sdegutis> i rather like ocaml's syntax
07:07:05 <merijn> sdegutis: In short, if you know ocaml then picking up haskell will probably be rather simple, but haskell still has a bunch of innovations over ocaml that you can learn from
07:07:35 <merijn> @where gentle
07:07:35 <lambdabot> http://www.haskell.org/tutorial/
07:08:28 <merijn> sdegutis: If you would say your decently proficient in ocaml you can probably skip Learn You a Haskell (the usual recommendation) and try the "Gentle Introduction", which was aimed at people coming from ML
07:09:03 <sdegutis> merijn: thanks
07:09:23 <merijn> LYAH is good too, but may be boringly slow for people with ML experience
07:09:32 <sdegutis> it was
07:10:05 <merijn> Whereas the "Gentle Introduction" is usually described as
07:10:11 <merijn> @quote Brend gentle
07:10:12 <ironChicken> in my cabal file i have "extra-libraries: stdc++" because i have some hsc code which needs to link to a c++ library. when i run cabal build, first time it complains "* Missing C libraries: stdc++" before it's started building. then if i run build again, it continues to the gcc compilation phase and then complains "fatal error: vector: No such file or directory #include <vector>". if i run the compilation command which hs2hsc generated
07:10:12 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
07:10:12 <ironChicken> manually with g++ rather than gcc it compiles fine; similarly, if i add -lstdc++ to the gcc command it also compiles.
07:10:26 <sdegutis> lol
07:11:01 <merijn> ironChicken: I'm pretty sure that .hsc is not capable of doing with C++
07:11:23 <merijn> ironChicken: There's no C++ FFI and none of the tooling is C++ aware
07:11:36 <sdegutis> Does Haskell have anything like OCaml's pattern matching (and so-called "destructuring") in let bindings and function argument bindings?
07:11:48 <ironChicken> i know that. but my thing definitely compiles if the lstdc++ option is added to gcc
07:11:51 <benzrf> sdegutis: yes
07:11:56 <ironChicken> is there a way to get cabal to do that?
07:12:17 <benzrf> sdegutis:
07:12:19 <benzrf> > let fib 1 = 1; fib 2 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 10
07:12:21 <lambdabot>  55
07:12:54 <merijn> sdegutis: Yeah, it's nearly the same, the only restriction is that there's no way to have multiple alternatives use the same right hand, so you need an explicit right hand side for every pattern in case matches
07:13:02 <sdegutis> a
07:13:03 <sdegutis> aw
07:13:19 <merijn> But that's easily solved with a let and then giving a name to the right hand side and reuse that
07:13:30 <benzrf> merijn: you mean a where?
07:13:34 <ironChicken> i saw "ld-options: lstdc++" on the web, but that doesn't seem to work here
07:13:37 <benzrf> merijn: p sure lets cant span branches
07:13:40 <sdegutis> Is using C source code from Haskell really great and easy?
07:13:46 <benzrf> sdegutis: LOL NO
07:14:01 <sdegutis> It's super easy in Swift but a huge pain in OCaml (I still can't get it working).
07:14:07 <ironChicken> and why does "extra-libraries: stdc++" result in "* Missing C libraries: stdc++"?
07:14:24 <benzrf> sdegutis: you must manually write bindings afaik
07:15:06 <merijn> sdegutis: "It depends"
07:15:20 <merijn> sdegutis: If you don't have to update structs from the haskell side it's easy-peasy
07:15:27 <sdegutis> I never do.
07:15:40 <sdegutis> I want to bind Lua functions which are basically just type conversions.
07:15:45 <merijn> sdegutis: If you wanna mutate C structs from within haskell it's kinda annoying because you have to write Storable instances for marshalling
07:16:09 <sdegutis> Literally I just want to call a C function and convert the resulting int to a Haskell int.
07:16:18 <merijn> sdegutis: Trivial
07:16:21 <sdegutis> Also can I give a Haskell function to C?
07:16:27 <sdegutis> (as a C function pointer)
07:16:40 <merijn> I have a minimal example of calling haskell functions from C here: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
07:16:48 <sdegutis> Specifically I need to create a function that takes a (lua_State) pointer and returns an int.
07:17:03 <sdegutis> I get the pointer from somewhere else, so I don't have to create it.
07:17:37 <merijn> sdegutis: Function pointers is a bit more, but even that's pretty easy, I have it muffled away in some code here: https://github.com/merijn/SNet2.0/blob/master/SNet/Interfaces/C.hs#L22-L23
07:17:49 <sdegutis> merijn: awesome
07:18:03 <merijn> sdegutis: Line 52 is basically wrapping a haskell function into a function pointer using the "magic" import on line 22-23
07:18:37 <sdegutis> How do you do this in Haskell?  let () = let person = match Array.to_list Sys.argv with | [ _ ; x ] -> x | _ -> "you" in Printf.printf "sup, %s\n" person
07:18:40 <ironChicken> i even tried adding "extra-lib-dirs: /usr/lib/x86_64-linux-gnu" which is definitely not a good solution, and has the added bonus of not making any difference
07:19:59 <sdegutis> Also what is the most frustrating thing about Haskell to you?
07:20:34 <merijn> sdegutis: The simple answer is: You can't do that the same as in ocaml, ocaml doesn't restrict functions to be pure in terms of IO, I think you're better of reading the Input/Output chapter of the tutorial to cover that
07:21:05 <sdegutis> ok
07:21:30 <merijn> sdegutis: I would say: The Num hierarchy is not very satisfying, the lack of proper dependent types can be limiting and async exceptions are an utter hassle (although that may be an issue of async exceptions and not haskell, I've not really found many other languages with async exceptions)
07:22:18 <geekosaur> async exceptions are an utter hassle. kernel and real-time developers can probably tell you more than you want to know about it
07:23:10 <Fuuzetsu> @pl f x = g <$> h x
07:23:11 <lambdabot> f = (g <$>) . h
07:23:19 <Fuuzetsu> oh, fmap g . h
07:23:24 <merijn> geekosaur: I used to do lots of distributed systems, tell me about it ;)
07:23:32 <int-e> ironChicken: extra-libraries: stdc++  works for me. that's using gcc 4.9.2, gnu ld, and g++ is installed as well...
07:24:07 <merijn> Oh, actually!
07:24:27 <int-e> ironChicken: in particular,  gcc <some C file> -lstdc++  doesn't complain for me
07:24:37 <merijn> You know what's another huge pet peeve? The inability to have partial functions for overloaded literals with compile time checks that they never fail!
07:25:03 <merijn> That's so annoying I just might desperately try and add it myself. Using TH everywhere for that is miserable >.>
07:27:47 <ironChicken> int-e: so yeah, i have extra-libraries: stdc++ but the gcc command it produces doesn't include -lstdc++, the hs2hsc command has --lflag=-lstdc++
07:28:56 <int-e> ironChicken: oh and I'm producing a library, I've not tried producing an executable directly that way.
07:29:51 <ironChicken> hmm, i'm producing a library too
07:30:42 * hackagebot ieee754 0.7.6 - Utilities for dealing with IEEE floating point numbers  http://hackage.haskell.org/package/ieee754-0.7.6 (PatrickPerry)
07:33:25 <rhllor> on youtube I saw a video  of an interview with simon peyton jones and erik meijer. They said that, compared to other languages, haskell was useless. What do they mean?
07:33:45 <Fuuzetsu> maybe this will clarify it for you https://www.youtube.com/watch?v=iSmkqocn0oQ
07:35:50 <Fuuzetsu> they comment section is quite a sight as usual
07:35:52 <Fuuzetsu> the*
07:36:48 <clrnd> very, indeed, I saw that exact video recently but somehow missed the comments
07:37:56 <clrnd> well people build giantic web apps in PHP, haskell is not so bad in comparison
07:38:10 <int-e> ironChicken: Ok, -lstdc++ is only included in the final linking commands for me, and I didn't use hsc2hs.
07:41:19 <Rc43> Hello.
07:41:41 <Rc43> Is it possible to fuse type class usage while compiling haskell and return haskell code again?
07:41:52 <Fuuzetsu> do you perhaps want TemplateHaskell?
07:42:09 <Rc43> Fuuzetsu, mm, not sure
07:42:24 <Rc43> Fuuzetsu, I want something simple and more-or-less production-ready
07:42:24 <merijn> Rc43: What does "fuse type class usage" mean?
07:42:33 <Fuuzetsu> It sure sounds like it. Maybe if you say what you actually want to do then we'll be able to help better.
07:42:55 <indiagreen> Rc43: do you have a Haskell compiler which doesn't implement typeclasses or something?
07:43:18 <toblerone> Hi I'm doing some image related stuff using vectors and i was wondering whether this was an efficient way of modifying the vector. I'm aware of things like Repa, but I'd rather not use it for this if I can avoid it. http://lpaste.net/119242 The performance in this example isn't as great as I'd like it
07:43:21 <Rc43> merijn, take haskell code and return haskell code without type classes, if we have type class [X] with method [f] then all [f]s should be replaced with their instantiated versions in the result.
07:43:39 <Rc43> indiagreen, yep, I am looking at Fay for compiling javascript
07:44:15 <merijn> Rc43: Actually, GHC already does that when the type class is statically known
07:44:23 <merijn> indiagreen: Have you looked at ghcjs?
07:44:38 <merijn> eh
07:44:44 <merijn> s/indiagreen/Rc43
07:45:21 <lericson> so if you're making a perceptron of sorts, and it has two inputs: an age, and say color. you train this perceptron to give a positive response to new blue things, and to old red things. also, a negative response is trained for blue old things and new red things.
07:45:55 <lericson> it would seem to me that if you input age a time interval, you would get a zero value for new things and it would be hard to weigh in a zero input
07:46:05 <lericson> is this perhaps what the bias mechanism allows us to do?
07:46:28 <lericson> i have been reading this http://natureofcode.com/book/chapter-10-neural-networks/
07:46:32 <lericson> excellent stuff
07:47:41 <Rc43> merijn, didn't looked yet. Aren't typeclasses always statically known?
07:48:08 <int-e> ironChicken: I see here, https://www.haskell.org/pipermail/glasgow-haskell-users/2012-February/021919.html the suggestion to pass -c g++ to hsc2hs, to allow it to parse C++ header files. Is that what you need?
07:48:27 <Rc43> merijn, and is it possible to return haskell code again after typeclasses elimination?
07:48:54 <indiagreen> Rc43: it may be possible to write a GHC plugin which does it
07:49:10 <Rc43> indiagree, hmm, indeed
07:49:18 <Fuuzetsu> Rc43: why do you need such a thing?
07:49:20 <int-e> ironChicken: (g++ also knows how to link to libstdc++, so that could solve your problem)
07:49:26 <merijn> Rc43: No
07:49:39 <merijn> Rc43: (By that I mean typeclasses aren't always statically known)
07:49:39 <Rc43> Fuuzetsu, want to use Fay and type classes at the same time
07:50:11 <merijn> Rc43: i.e. "5 + 5 :: Int" here the instance is statically known, but if you have polymorphic recursion or similar it may not be
07:50:21 <Fuuzetsu> oh, missed that part; GHCJS is the cool thing to use nowadays
07:50:26 <Rc43> merijn, indeed!
07:50:47 <indiagreen> Rc43: if the type isn't known, you'll have to do dictionary passing
07:50:49 <Rc43> Fuuzetsu, what are cons of it?
07:50:50 <merijn> For example, think of parsing some data (unknown what type) from a file and then wanting to apply a typeclass function to it (assuming the parsed data is an instance)
07:51:04 <merijn> Rc43: Ask luite :)
07:51:07 <Fuuzetsu> ^
07:51:16 <Rc43> Fuuzetsu, i.e. pros
07:51:27 <merijn> Rc43: It supports all features GHC supports, including threading, STM and all extensions
07:51:51 <merijn> Rc43: So, basically, ghcjs can compile all bits of hackage that don't require FFI/C libraries
07:52:10 <merijn> Plus it has a javascript FFI and tools, for obvious reasons
07:52:25 <Rc43> merijn, it's pretty cool then
07:52:31 <merijn> It is! :)
07:52:41 <Rc43> merijn, but why there are other haskell->js tools then?
07:52:53 <merijn> Rc43: Anyway, luite is around here often and he's one of the main people working on it
07:52:53 <Rc43> merijn, or it is pretty fresh?
07:53:15 <merijn> Rc43: A lot of them started sooner and ghc only had the necessary patches since 7.8
07:53:29 <indiagreen> ghcjs supports more than most people probably need, and the price is having to include a huge runtime, IIRC
07:53:52 <merijn> Rc43: Actually, it might still have some issues with Template Haskell, but he's working on allowing you to run Template Haskell via node.js, I though
07:53:55 <Rc43> indiagreen, oh, huge runtime...
07:54:12 <indiagreen> by runtime I mean “a 400kB chunk of Javascript”
07:54:32 <ab9rf> ugh, node.js
07:56:34 <Rc43> indiagreen, so every user will download and run 400kb of javascript, right? Can it be shared or something to avoid huge latency? (I'm not pro in web development)
07:57:01 <merijn> ab9rf: Small price to be able to compile Template Haskell libraries (like lens) to the web
07:57:12 <ab9rf> i suppose so :)
07:58:26 <indiagreen> Rc43: I don't know, sorry
08:07:58 <sgronblo> How do I map read to an IO String to make it read to an IO Int?
08:08:21 <sgronblo> I'm sure I have to provide a type hint somewhere, but where exactly?
08:09:03 <sgronblo> Like (i :: Int) <- map read getLine
08:09:08 <sgronblo> Which didnt seem to work
08:09:19 <merijn> fmap :)
08:09:24 <merijn> map only works on lists
08:09:39 <merijn> Or "i <- fmap read getLine :: IO Int"
08:09:44 <chpatrick> <$> if you want to be cool
08:09:54 <benzrf> f <$> x = fmap f x
08:10:05 <chpatrick> yeah :)
08:10:23 <sgronblo> merijn: darn
08:10:47 <sgronblo> I always go with the map when I return to Haskell after a while
08:10:57 <merijn> :)
08:11:12 <Fuuzetsu> sometimes I use f <$> x for regular map and I always imagine someone shouting at me for that
08:11:14 <Fuuzetsu> but I do it anyway
08:11:25 <merijn> Fuuzetsu: Daredevil!
08:12:15 <chpatrick> anyone else really want a standard infix flip fmap?
08:12:31 <chpatrick> so you can do someStuff <$$> \val -> ...
08:14:55 <benzrf> :t (<&>)
08:14:56 <lambdabot> Functor f => f a -> (a -> b) -> f b
08:15:11 <chpatrick> derp
08:15:13 <chpatrick> where does that live?
08:15:34 <sgronblo> merijn: So I would have to type the whole RHS as IO Int?
08:15:49 <sgronblo> I thought I would like to just provide a type hint for the value inside the IO to be cool
08:16:35 <chpatrick> sgronblo: what do you mean by provide a type hint?
08:17:05 <chpatrick> benzrf: ah lens
08:18:54 <nomeata> Hi. A program of mine is going to contain a statc value of type "Data.Vector.Unboxed.Vector Word16", defined with "fromList [..]". Is there a way to have the compiler include the data as actual static data?
08:18:57 <merijn> sgronblo: You could do it on the left too, maybe? But I prefer on the right
08:19:38 <merijn> nomeata: It might do the same sort of rewriting tricks as text applies to fromString, but I'm not sure
08:20:01 <merijn> I'm not aware of anyway to do that, though
08:22:42 <chpatrick> nomeata: if it's really important you might be able to make a primitive vector from a bytearray literal?
08:22:53 <chpatrick> could be completely wrong here and it'd be a really evil hack in any case
08:23:06 <Javran> does pandoc support console ansi input?
08:26:39 <indiagreen> Javran: what do you mean? If “can you pipe text to Pandoc”, then yes, it operates like this by default
08:29:21 <Javran> indiagreen: I meant colorized ansi texts
08:31:05 <Javran> I did something like "ghc-core simple.hs | pandoc -o simple.pdf", it took forever.
08:32:33 <ezrios> is it possible to extend the "thread killed" timeout in happstack?
08:32:45 <ezrios> I have a long-running thread that may not send a response to the client for 60s+
08:34:34 <indiagreen> Javran: it's not because of colorising
08:34:43 <indiagreen> it's because of nested square brackets
08:35:08 <indiagreen> ...and nested brackets are because of colorising, right
08:36:25 <indiagreen> then I guess it doesn't support colors and you should instruct ghc-core to output non-colorised code
08:36:58 <indiagreen> you wouldn't have gotten colors in PDF output anyway simply because Pandoc's AST doesn't have a way to represent them apart from HTML
08:37:41 <Javran> indiagreen: reading ghc-core and I guess they only support outputing to console / pager
08:38:02 <koomi> there is a ghc-core-html
08:38:35 <indiagreen> koomi: thanks, cool
08:38:38 <indiagreen> didn't know that
08:38:49 <Javran> koomi: ah, thanks for the information, looks like what I want
08:40:45 * hackagebot buildwrapper 0.9.1 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.9.1 (JeanPhilippeMoresmau)
08:41:26 <dsfox1> Can anyone tell me how to obtain the Kind of a Type using template haskell?
08:43:56 <dsfox1> or does that even make sense?
08:52:32 <Fuuzetsu> how can I turn off -Wall after I :set it?
08:52:36 <Fuuzetsu> dsfox1: pretty sure you can
08:54:23 <jonkri> Has anyone here had any problems with GHC programs not terminating in situations where things like cronjobs or flock is used?
08:54:30 <dsfox1> Fuuzetsu: I've learned this much: in ghci it is :k
08:55:25 <Fuuzetsu> SigT Type Kind
08:59:47 <hexagoxel> Fuuzetsu: :set -w
08:59:54 <Fuuzetsu> awesome
09:00:44 <hexagoxel> (corresponding to ghc flags, see man-page)
09:01:42 <dsfox1> Fuuzetsu: I guess if I fully expand the Type the information I need is in the resulting type's shape
09:08:07 <fresheyeball> @pl \x -> trace $ "\n" ++ x ++ "\n"
09:08:07 <lambdabot> trace . ('\n' :) . (++ "\n")
09:08:13 <__jim__> is there a list of criterion command line options available somewhere?
09:09:53 <Fuuzetsu> --help perhaps
09:10:23 <Fuuzetsu> yep, that seems to be it
09:11:02 <__jim__> oh, ok, I had tried that but for some reason it did not immediately display anything
09:11:06 <__jim__> thanks!
09:17:26 <Black0range> Hello ladies! I'm currently making a web server for Haskell... When sending a HTTP response to the client using chunked encoding. Are there any way to send an error message that something got wrong? or should i just kill the connection? This is really more of a HTTP question but #HTTP is kinda dead soo...
09:17:55 <Black0range> and yes there are other http servers out there. But it more of a hobby project
09:21:21 <dsfox1> BlackOrange: You could try #happs
09:23:50 <Black0range> Will do! :)
09:23:54 <Black0range> and thanks
09:24:57 <clrnd> Black0range, HTTP has error codes, aren't those for that?
09:25:34 <Black0range> Yes you're true. But when you've started sending chunked data the header/ response-line is allready sent :/
09:26:00 <clrnd> oh chunked sorry, didn't pay attention
09:28:10 <rhllor> what kinds of programming languages are out there? and by that I mean what kind of families do they fall into.
09:29:01 <rhllor> as far as I'm conerned, there is only c like languages, scripting languages, lisp and whatever pascal was trying to do
09:29:04 <matematikaadit> I just found that Haskell is a better scripting language than Bash
09:29:31 <reem> rhllor: That's kind of a narrow view of an extremely broad and diverse topic
09:29:41 <chpatrick> rhllor: I would kinda lump most imperative things under algol-like I guess
09:29:46 <chpatrick> semantically they're not that varied
09:29:57 <vanila> rhllor, the main paradigms are: procedural, functional, and logic programming
09:30:02 <rhllor> reem: I'm talking about semantics mainly
09:30:23 <nejakemeno> one simple question - is it possible to make a function having a type variable (let's say 'a') as return type returning some constant (let's say 2)?
09:30:46 <hodapp> :t 2
09:30:47 <lambdabot> Num a => a
09:30:49 <chpatrick> nejakemeno: for any a, no constraints
09:30:51 <chpatrick> ?
09:30:53 <geekosaur> nejakemeno, that's not a simple question.
09:30:53 <nejakemeno> that is myfunc :: a and the implementation would be myfunc =2
09:30:58 <chpatrick> no
09:31:09 <chpatrick> that means you don't know anything about a
09:31:21 <nejakemeno> yes I thought so
09:31:37 <nejakemeno> and would it be possible with some extensions?
09:31:48 <nejakemeno> (like rankNtypes or something?)
09:31:59 <chpatrick> not if it's just a
09:32:03 <hodapp> :t (\_ -> 2)
09:32:04 <lambdabot> Num a => t -> a
09:32:25 <glguy> nejakemeno: What are you trying to do?
09:32:26 <rhllor> the best you can say is the type of the constant you are returning
09:32:27 <chpatrick> there's still a Num constraint there
09:32:38 <hodapp> oh, needs to be without a constraint?
09:32:41 <chpatrick> I think so
09:32:55 <hexagoxel> how do i import the constructor(s) of an associated data type?
09:32:59 <clrnd> Black0range, I found interest in your question and digged up a little, would this be useful? http://www.jmarshall.com/easy/http/#http1.1c2
09:33:01 <chpatrick> nejakemeno: the one trick you could do is returning myFunc :: Foo a
09:33:03 <chpatrick> where
09:33:14 <clrnd> you can add headers as footers it seems, so you could for instance use a custom header for the error
09:33:19 <chpatrick> data Foo a where
09:33:19 <chpatrick>   Number :: Int -> Foo Int
09:33:22 <chpatrick> oh wait no
09:33:24 <chpatrick> I'm full of it :)
09:33:28 <chpatrick> disregard that
09:33:30 <nejakemeno> glguy: long story short - i wanted a function that returns a list [] or an element, but you can reduce the problem to the one i mentionied
09:33:41 <geekosaur> also, wanting to do that is usually a sign of not thinking in a Haskell way. there *are* ways to emulate type systems that work that way but they're not particularly simple and they'll still involve constraints
09:33:45 <Black0range> clrnd: yes that is true for contolled environment. but how about web-server?
09:34:35 <nejakemeno> geekosaur: thank for pointing that out, it felt like not haskelly but i was wondering if i didnt miss something
09:34:40 <geekosaur> nejakemeno, data MyValue a = AList [a] | AThing a; myfun :: MyValue Int; myfun = AThing 2
09:34:55 <geekosaur> probably needs a lot of fleshing out for your specific use case, which we don't know
09:34:59 <clrnd> Black0range, you mean a browser? mmm won't the Http library take care of that?
09:35:11 <glguy> nejakemeno: When you define a function "f :: Something -> a" You're offering to let the caller of that function pick any type. You don't get to pick it when you're writing f
09:35:38 <chpatrick> it means the function has to work for any a, not that it works for some a
09:35:38 <Black0range> clrd: yes sure. But there would just be an ugly "oops the server died" message. Not saying anything about the error per se
09:35:56 <geekosaur> something like Aeson uses a more complicated version of that, JsonValue with a constructor for each JSON-representable type
09:36:06 <nejakemeno> geekosaur: i see, I ll try it out and it feels more type-haskell-y like, thanks
09:36:15 <geekosaur> ten you can pattern match the constructor to get at the matching value type
09:37:10 <nejakemeno> glguy yeah that's what i though, I read something about forall, some i thought iam just being stupid not knowing how to apply forall properly, but as i ssupected and geekosaur confirmed its not in the spirit of haskell
09:37:43 <geekosaur> existentials look superficially like they can do it, but trying to use them that way gets you into trouble pretty quickly
09:38:18 <nejakemeno> haha, alhtough i dont have any experience with existensials i feel the same way
09:38:18 <geekosaur> @google existential anti-pattern
09:38:19 <lambdabot> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
09:40:17 <nejakemeno> geekosaur i bookmarked it and Ill read it on my way to work tommorow
09:40:21 <nejakemeno> thanks for the tip
09:41:44 <hexagoxel> https://wiki.haskell.org/GHC/Type_families mentions import/export, but nothing seems to work.
09:43:56 <hexagoxel> uh.. what? it works _only if i have an export list_?
09:44:32 * hexagoxel exits the stage in the direction of the ghc bug tracker
09:51:28 <nomeata> merijn: Vecor doesn’t do such things these days. chpatrick: There is surprising little documentation on bytearray literals. It might work, but would require some annoying preprocessing.
09:53:40 * hexagoxel comes back, looking somewhat annoyed
09:54:09 <monochrom> @botsnack
09:54:09 <lambdabot> :)
09:54:17 <dfeuer> Am I correct in thinking that indexing into a global vector is better than using a circular stream for dealing with prime wheels?
09:54:29 <hexagoxel> the ghc bug tracker search can not express `description contains foo && description contains bar` ? despite having a nice big "and" button that suggests it would do just that?
09:55:00 <glguy> hexagoxel: Time to file another ticket
09:55:07 <hexagoxel> at the tracker-tracker!
09:55:10 <Fuuzetsu> speak up in #ghc
09:55:57 <hodapp> huh, sort of wish I knew why my entire Cabal sandbox just seemingly exploded and demanded to be redone with a newer version of Cabal
09:56:16 <Black0range> cabal install cabal-install
09:56:19 <Black0range> ;)
09:56:31 <hodapp> Black0range: that doesn't magically fix the sandbox
09:56:40 <monochrom> I think that was the problem cause, not the solution
09:57:01 <hodapp> I never ran that command, hence confusion
09:57:28 <Black0range> if it doesn't work with force, apply more force. if it still doesn't work it's already broken
09:59:14 <hexagoxel> hodapp: but.. you updated ghc? platform? are using some advanced stackage/nixos/.. stuff?
09:59:54 <dfeuer> Oooooooh. I just had what I believe to be a very good idea :-)
10:00:07 <hodapp> hexagoxel: no, just having to run inside a sandbox.
10:00:11 <hodapp> which a lot of tools seem to have.
10:08:53 * hodapp grumbles, nukes sandbox, rebuilds everything
10:10:01 <SrPx> Hello! Does anyone know how to get hte inverse of a vector on Linear? :)
10:10:36 <StoneToad> when you say inverse, you mean the negation of?
10:14:45 <chpatrick> nomeata: I think the best you could do is a Storable vector, since that's what you get from a bytearray literal
10:14:50 <chpatrick> nometa
10:14:53 <joness> what is the other possible Monad instance for list? I have heard that there could be two
10:15:02 <chpatrick> nomeata: or rather you get an Addr# which you can use to make a storable vector
10:15:34 <nomeata> chpatrick: that’s a good idea. And I believe bytestring is setup to efficiently compile large string literals passed to BC.pack.
10:16:10 <chpatrick> nomeata: I read something about how there's a RULES to make Text literals efficient by not converting to String first
10:16:30 <chpatrick> nomeata: http://www.serpentine.com/blog/2012/09/12/the-case-of-the-mysterious-explosion-in-space/
10:16:52 <hodapp> "dist/dist-sandbox-19154eb0/package.conf.inplace: inappropriate type"
10:16:56 <hodapp> I... don't know what that means
10:17:01 <hodapp> but it's failing a build
10:17:43 <chpatrick> nomeata: I was thinking that it would be possible to make a quasiquoter that produces a string primitive literal and passes it into the primitive vector constructor
10:18:07 <joness> `do x <- [1,2,3]; y <- [10,20,30]'    could monad instance for list be defined so that this would evaluate to [1,10,2,20,3,30]? while still following all the Monad laws
10:18:21 <mauke> joness: that's a syntax error
10:18:33 <joness> yeah didn't finish the expression
10:19:18 <chpatrick> joness: is there a valid return for that?
10:19:29 <chpatrick> jonass: in the identity for >>= sense
10:19:30 <joness> `do x <- [1,2,3]; y <- [10,20,30]; return (x,y)'  could this have been [(1,10),(2,20),(3,30)] ?
10:19:34 <nomeata> chpatrick: but that might not improve compile time; depending on what the data is before it reaches TH
10:19:52 <mauke> joness: I don't think so
10:20:27 <chpatrick> nomeata: I was thinking it could be like [vector|1, 2, 3, 4, 5, 0xdeadbeef|] :: S.Vector Word32
10:20:58 <mauke> > (,) <$> ZipList [1,2,3] <*> ZipList [10,20,30]
10:21:00 <lambdabot>  ZipList {getZipList = [(1,10),(2,20),(3,30)]}
10:21:22 <mauke> but I can't think of a way to define a join that doesn't violate a law
10:22:17 <nomeata> chpatrick: ah, right, a quasiquoter gets just a string. yes, that should work.
10:22:19 <joness> > liftA2  (,) (ZipList [1,2,3]) (ZipList [10,20,30])
10:22:21 <lambdabot>  ZipList {getZipList = [(1,10),(2,20),(3,30)]}
10:22:25 <joness> > liftM2  (,) (ZipList [1,2,3]) (ZipList [10,20,30])
10:22:27 <lambdabot>  Could not deduce (GHC.Base.Monad Control.Applicative.ZipList)
10:22:27 <lambdabot>    arising from a use of ‘Control.Monad.liftM2’
10:22:27 <lambdabot>  from the context (GHC.Num.Num a2, GHC.Num.Num a1)
10:22:42 <chpatrick> and it would become newForeignPtr_ (Ptr "# S.unsafeFromForeignPtr
10:22:45 <chpatrick> whoops
10:23:33 <chpatrick> and it would become unsafeDupablePerformIO (newForeignPtr_ (Ptr #"\x01\x00\x00\x00..."#) >>= S.unsafeFromForeignPtr)
10:23:46 <chpatrick> or whatever the syntax is for string primitive literals
10:24:04 <chpatrick> this is total black magic though :)
10:27:25 <Haskellfant> I'm trying to write an index function for a heterogeneous list, but ghc fails with a unification error. it looks correct to me, so I guess I might need to provide a bit more info to ghc, but I'm not sure what and how http://lpaste.net/119247
10:28:35 <joness> I don't get why join for ZipList can't also be concat?
10:28:43 <joness> > concat [[1,2,3],[4,5,6]]
10:28:44 <lambdabot>  [1,2,3,4,5,6]
10:29:26 <tnks> Would a ZipList still be a zip list if it had a join?
10:29:55 <tnks> joness: ^
10:30:03 <mauke> joness: breaks return x >>= f = f x
10:35:25 <mauke> Haskellfant: I'm having the same problem as ghc :-)
10:35:39 <mauke> I don't see why x should :: NatIndex xs n
10:36:20 <Haskellfant> mauke: NatIndex returns the type of the nth element in the list which should bexactly what index returns
10:37:26 <Haskellfant> so for IZero it returns the first element, and NatIndex should return the first type
10:37:28 <Haskellfant> and so on
10:37:53 <mauke> what is Index's argument for?
10:38:17 <Haskellfant> Index is used to make sure that you stay within the boundaries
10:38:47 <joness> > fmap (*10) (ZipList [1..5])
10:38:48 <lambdabot>  ZipList {getZipList = [10,20,30,40,50]}
10:39:21 <Haskellfant> a type of Index 3 can only contain IZero, ISucc IZero, ISucc (ISucc IZero) and ISucc (ISucc (ISucc IZero)
10:40:44 <Haskellfant> mauke: Index n is a type inhabited by the first n numbers
10:42:22 <mauke> this makes no sense
10:42:37 <mauke> your index is a value
10:42:45 <mauke> and you're trying to index into a type list
10:43:42 <Haskellfant> mauke: in the type signature Index n is a type, right?
10:44:09 <mauke> yes
10:44:26 <Haskellfant> so why does it not make sense to index with that n?
10:44:51 <mauke> you're not doing that
10:44:56 <Black0range> Are there any way to directly make constant characters to "word8" directly?
10:45:21 <mauke> at the value level you're recursing on IZero/ISucc, while at the type level you're recursing on Zero/Succ
10:45:31 <Black0range> instead of for example $ B.breakByte (BI.c2w '?') strPathFull
10:45:32 <mauke> the two don't necessarily line up
10:45:41 <mauke> particularly since IZero is everywhere
10:46:01 <Haskellfant> mauke: ah that makes sense
10:46:41 <nomeata> chpatrick: this is what I came up with now: https://github.com/entropia/tip-toi-reveng/blob/master/src/KnownCodes.hs
10:47:29 <nomeata> hmm. do I have to worry about endianness now? :-(
10:47:57 <mauke> index (Cons 'a' (Cons 42 Nil) :: HList (Succ (Succ Zero)) '[Char, Integer]) (IZero :: Succ Zero) :: NatIndex '[Char, Integer] (Succ Zero)
10:48:08 <mauke> I think that would result in 'a' :: Integer if it compiled
10:51:23 <kraai> How should I check that an error returned by Network.connectTo is ECONNREFUSED?
10:51:35 <jonkri> I have put "ghc-options: -rtsopts -with-rtsopts=-1" in my Cabal file, but when I run the binary I get an error saying "Most RTS options are disabled. Link with -rtsopts to enable them.". Why is this? I have touched all my source files to make sure that everything is rebuilt.
10:51:48 <jonkri> GHC 7.4.1.
10:51:50 <SrPx> "Not in scope: "foo"" - but foo is declared below on the file... why?
10:52:29 <dimsuz> hi! I'm learning 'liftM2' and trying to think could I achieve this "liftM (map (+1)) $ liftM2 (++) (Just [1]) (Just [3])" in a single liftM2? something like "liftM2 ((map (+1)) . (++)) ..."
10:52:30 <mauke> SrPx: show your file
10:52:36 <dimsuz> cant wrap my head around this
10:52:44 <tommd> jonkri: "-rtsopts=all" ?
10:52:59 <jonkri> Not "-with-rtsopts=-1", "-with-rtsopts=-IO". :>
10:53:02 <glguy> kraai: Catch the IOException and see that it is "NoSuchThing"
10:53:07 <jonkri> tommd: I'll try - thanks!
10:53:29 <mauke> dimsuz: liftM2 (\xs ys -> map (+ 1) (xs ++ ys)) ?
10:53:38 <SrPx> mauke: http://lpaste.net/119252
10:54:01 <glguy> kraai: The only way I know to figure that out is to open http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Foreign-C-Error.html#eOK and search for "errno == eCONNREFUSED"
10:54:24 <mauke> kraai: there's also getErrno
10:54:37 <dimsuz> mauke: oh, indeed. somehow I started with a thought that this can be done by composition
10:54:56 <glguy> If you're going to use getErrno you probably don't want to use the high-level connectTo method
10:55:05 <glguy> There's no promise that getErrno will have your errno at that point
10:55:18 <mauke> dimsuz: it can, but it's ugly: ((map (+ 1)) .) . (++)
10:55:34 <lpaste> mpickering pasted “Singletons confusion” at http://lpaste.net/119253
10:55:47 <mpickering> ^ what causes that error?
10:56:33 <dimsuz> mauke: god. i'm too inexperienced for that, need to figure out the types :)
10:57:31 <mauke> SrPx: that doesn't look obviously wrong
10:57:31 <kraai> glguy: Thanks!
10:57:40 <jonkri> tommd: I added that option but the result is the same. :(
10:57:58 <mauke> SrPx: is that the whole error?
10:58:00 <joness> my brain is cooking.. i wrote Functor, Applicative and Monad instances ZipList, but I ended up with just a regular list monad instance. thise excercise was suppose to show me why ZipList can't be monad, but I am no smarter then before i wrote this. http://lpaste.net/119254
10:58:04 <SrPx> mauke: I see, weird right? Thanks though.
10:58:08 <SrPx> hmm a second mauke
10:58:15 <SrPx> Yes it is...
10:58:43 <SrPx> it works if I place "main" below "hitAABB". ..
10:59:11 <mauke> joness: your 'pure' is wrong
10:59:35 <joness> > pure 1 :: ZipList Int
10:59:37 <lambdabot>  ZipList {getZipList = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
10:59:40 <Black0range> is it possible to pattern match on ByteStrings in the same way that you pattern match on Strings?
10:59:45 <joness> wtf lol
11:00:01 <joness> why?
11:00:08 <clrnd> > pure 1 :: [Int]
11:00:10 <lambdabot>  [1]
11:00:33 <mauke> > pure (* 2) <*> [10,11,12]
11:00:35 <lambdabot>  [20,22,24]
11:00:37 <mauke> > pure (* 2) <*> ZipList [10,11,12]
11:00:39 <lambdabot>  ZipList {getZipList = [20,22,24]}
11:00:54 <mauke> ^ this doesn't work if pure gives you a singleton ZipList
11:01:42 <joness> ghci> pure (*2) <*> ZipList [10,11,12]
11:01:44 <joness> ZipList {getZipList = [20]}
11:01:54 <joness> I get that.. which is what I expected, because that is how zip works
11:01:57 <mauke> right, your version truncates the result
11:01:58 <joness> does it violate some law?
11:02:18 <joness> oh, the id law
11:02:31 <joness> > pure id <<*> ZipList [10,11,12]
11:02:32 <lambdabot>  Not in scope: ‘<<*>’
11:02:33 <lambdabot>  Perhaps you meant one of these:
11:02:33 <lambdabot>    ‘<*>’ (imported from Control.Applicative),
11:02:36 <joness> > pure id <*> ZipList [10,11,12]
11:02:38 <lambdabot>  ZipList {getZipList = [10,11,12]}
11:03:13 <shachaf> Haskellfant: I think your issue is that you don't actually know which type you want to return.
11:03:26 <Haskellfant> shachaf: got it working http://lpaste.net/119247
11:03:56 <joness> I get that. and I updated pure definition.
11:04:07 <joness> pure x = ZipList (repeat x)
11:04:17 <Haskellfant> I kinda prefered the Index type to the LessThan stuff, but I'm too stupid to use that (if it's possible at all)
11:04:31 <joness> still not sure about Monad instance, and why I ended up with regular instance for List
11:04:36 <Haskellfant> shachaf: for finding out which type I want I have NatIndex
11:04:51 <shachaf> Haskellfant: OK, sure, the difference is that here you pass the index as a type.
11:05:23 <joness> I did not have "aha! that is why we can't have Monad instance for ZipList" moment, which is what I hoped for
11:05:30 <shachaf> By the way, it seems a bit odd to have both the length and the list of types in an HList's type.
11:05:51 <Haskellfant> yeah that's not very useful :)
11:06:09 <vin-ivar> hey hey
11:06:14 <vin-ivar> the new CIS 194
11:06:25 <vin-ivar> we can't submit if we aren't actually studying at UPenn? :(
11:06:52 <joness> oh, right
11:06:59 <joness> do x <- ZipList [1,2,3]; y <- ZipList [10,20,30]; return (x,y)
11:07:08 <joness> gives me an infinite list of (1,10)
11:07:11 <joness> :) fun
11:07:28 <mauke> > let join' (ZipList xs) = ZipList (concatMap getZipList xs); singleton' x = ZipList [x] in  singleton' 42
11:07:30 <lambdabot>  ZipList {getZipList = [42]}
11:07:57 <mauke> > let join' (ZipList xs) = ZipList (concatMap getZipList xs); singleton' x = ZipList [x] in  join' (fmap singleton' (pure 42))
11:07:58 <lambdabot>  ZipList {getZipList = [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42...
11:08:09 <mauke> these should be equal according to monad laws
11:08:29 <joness> I see
11:08:55 <Haskellfant> shachaf: thank for the suggestion looks way nicer now
11:09:00 <mauke> (this is f x = return x >>= f)
11:09:41 <shachaf> Haskellfant: I was going to mention that your Index type would probably be more natural as Fin, where Fin n has [0..n-1] as inhabitants.
11:09:45 <shachaf> But it looks like you're not using it anymore.
11:10:24 <Haskellfant> yeah I'm not sure how I would use that for indexing
11:10:35 <Haskellfant> and that's the only reason I had that in
11:13:11 <joness> is there a module that tests whether Funtor, Applicative and Monad instances follow their laws?
11:15:10 <Denommus> joness: I don't think so
11:16:47 <rhllor> is there anyone here who uses haskell professionally. I already know about you, bitemyapp. I just want to know how common haskell is in the professional world
11:17:12 <c_wraith> it's not common, but it exists.
11:17:13 <c_wraith> It's just rarely public.
11:17:31 <joehillen> I wrote a webapp for my job once
11:17:38 <c_wraith> And for reference, I have used it professionally - at a company about 4 blocks away from another company that used it professionally.
11:17:44 <rhllor> I understand that haskell isn't really meant to be industrial, but more of a philosophical idea of what programming should be, right?
11:18:10 <joehillen> "I understand that haskell isn't really meant to be industrial" what makes you say that?
11:18:30 <joehillen> haskell is meant to be a general purpose language
11:18:34 <kadoban> rhllor: That doesn't sound correct, no. It's certainly useful for general programming.
11:18:36 <joness> rhllor that is a common misunderstanding
11:18:47 <Adeon> I don't know what it means to be but you can totally use it for industrial
11:19:17 <joehillen> rhllor: it doesn't get much more industrial than this https://github.com/facebook/Haxl
11:19:33 <rhllor> I'm not saying it isn't a general purpose, but I mean that it wasn't really the intention, or main drive behind it's design
11:19:49 <clrnd> nor behind PHP I guess
11:19:55 <c_wraith> @quote Jafet research.language
11:19:55 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
11:20:04 <c_wraith> rhllor: that quote's pretty accurate
11:20:05 <joehillen> lol
11:20:36 <clrnd> nice
11:21:17 <monochrom> it is usually irrelevant what "it is meant to be". what it has become is more relevant.
11:21:45 <rhllor> I'm sorry if I offended anyone, but I never meant to say haskell has no purpose, I just meant that I personally feel like it's more of a language to explore language design
11:21:49 <monochrom> for example what cabal-install has become has deviated much from what it was meant to be.
11:21:50 <kadoban> What it was meant to be is probably interesting to a historian, but little else.
11:22:13 <c_wraith> Haskell was designed as a research language.  It turns out it worked, and research has resulted in something quite practical.
11:22:17 <kadoban> rhllor: What you're asking doesn't seem particularly offensive. People here are pretty easy-going anyway.
11:22:26 <joehillen> rhllor: incorrect, haskell is not purely a research language, it is _designed_ to be general purpose
11:22:31 <monochrom> for another example, voice message recorders for home phones was not meant to be call screeners, but obvious has become.
11:22:42 <rhllor> I misspoke when I said, 'meant to be'
11:22:53 <rhllor> that was just the first thing I thought
11:23:21 <joehillen> there are a lot a research related features that they don't want to merge because it will break existing apps and libraries. that is the opposite of a research language
11:23:29 <monochrom> there is also a big difference between being offended and pointing out irrelevancies.
11:23:30 <rhllor> I understand the difference between 'was' and 'is' perfectly fine, please stop showing more example
11:24:00 <rhllor> okay then, I'm obviously not good with vocabulary
11:24:19 <kadoban> rhllor: Well, I'm not sure what kind of responses you're looking for then?
11:25:53 * hackagebot ircbot 0.6.2 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.6.2 (JeremyShaw)
11:26:55 <darthdeus_> in the endless debate of yesod vs snap vs happstack vs others, has there been anything new in the past 6 months? :)
11:27:10 <darthdeus_> as in, which framework is the "go to" one these days?
11:27:16 <joehillen> I prefer microframeworks
11:27:23 <joehillen> highly recommend spock
11:27:33 <darthdeus_> joehillen: aren't happstack & snap microframeworks?
11:28:08 <joehillen> darthdeus_: I'm pretty sure they aren't
11:28:13 <simon> joehillen, is spock bigger or smaller than scotty?
11:28:17 <darthdeus_> hmm, spock looks new
11:28:25 <sssilver> Hey guys, I came here to tell you that Haskell is unlike anything I've ever experienced in my career of more than 10 years
11:28:29 <sssilver> It's true
11:28:33 <joehillen> spock is like scotty but with type-safe routes
11:28:34 <simon> darthdeus_, they're not really that micro.
11:28:41 <darthdeus_> joehillen: how does it handle code reloading in development?
11:28:49 <darthdeus_> doesn't seem to be mentioned on the site
11:28:49 <S11001001> sssilver: fair
11:28:51 <hodapp> sssilver: what career would that be?
11:29:05 <sssilver> hodapp: programming computers
11:29:09 <joehillen> darthdeus_: idk, I have emacs recompile and relaunch for me
11:29:33 <darthdeus_> joehillen: hmm interesting, do you have your emacs config up somewhere? :)
11:29:38 <sssilver> hodapp: http://xkcd.com/722/
11:29:52 <SrPx> Hello. I have noticed the Linear package has a "cross" product defined for the type V3, which is different from what it does for the cross product, which is from a typeclass, Metric...
11:30:20 <SrPx> If I want to use a ndimensional cross, do I have to define my own typeclass?
11:32:34 <ReinH> SrPx: I don't see a cross product for the Metric typeclass.
11:32:41 <Adeon> I'm not sure if the meaning of cross product for dimensions greater than 3 is unambiguously defined
11:33:17 <peddie> it is for 7 dimensions :P  I think that's it
11:33:47 <SrPx> I thought it was...
11:33:47 <ReinH> You can generalize the cross product to n dimensions
11:33:54 <ReinH> but the cross product is for 3 dimensional vectors
11:34:08 <ReinH> And apparently there is one for 7 http://en.wikipedia.org/wiki/Seven-dimensional_cross_product
11:34:31 <SrPx> What I want, specifically, is a generalization of the cross products that make this function work for V2 too: http://lpaste.net/119261 is there such a thing?
11:34:54 <SrPx> Since it would be nice to have my hitQuad work for both 2D and 3D games
11:35:22 <SrPx> hitPlane is already generic since: hitPlane :: (Metric f, Num (f t), Fractional t) => Ray f t -> Plane f t -> f t
11:35:53 * hackagebot cabal-test-bin 0.1.0 - A program for finding temporary build file during cabal-test.  http://hackage.haskell.org/package/cabal-test-bin-0.1.0 (junjihashimoto)
11:35:59 <SrPx> Which, for 2D, seems to decay to a line-line intersection, which is interesting
11:37:32 <SrPx> This is kinda awkward, though, since you create a "Ray" and a "Plane" in 2D to use that function. Which is nonsense. Because Ray and Plane are actually isomorphic. Hmm
11:38:04 <amyers> Is anyone here familiar with attoparsec?
11:38:25 <ReinH> SrPx: Don't you want the cross product of the 3d vectors formed by setting z to 0 for each 2d vector?
11:38:28 <SrPx> Maybe I should remove the Plane type and just use the Ray type for planes in 3D? Hmm no that is stupid, maybe I can just "type Plane2D = Ray V2 a"
11:38:44 <ReinH> although tbqh I'm not quite sure what that would give you
11:39:04 <kadoban> amyers: General IRC protocol is to just assume someone is and ask your followup.
11:39:39 <amyers> kadoban, it's a bit longish so I thought I would ask first but here goes
11:40:04 <SrPx> ReinH: hmm I'm not sure, now that I think about it, the cross product on 2D should need only 1 argument...
11:40:07 <amyers> I'm parsing a protocol which has option*0xff (oxff is the terminator for the option block)
11:40:15 <ReinH> SrPx: What would a 2D cross product do?
11:40:34 <amyers> an option is (Option <$> byte <*> word16 <*> word16)
11:40:45 <amyers> so I can handle the terminator in two ways
11:41:04 <SrPx> ReinH: that is, it'd be the determinant of the 2x2 matrix | i j | x y | and would return the vector that is orthogonal to (x,y)
11:41:07 <ReinH> SrPx: Are you working in a 2d space? Then why do you need a normal?
11:41:14 <SrPx> at least, that is what I think would make the code work for 2D
11:41:21 <amyers> I can do option = (Option <$> notWord8 0xff <*> word16 <*> word16) and then many1 option <* word8 0xff
11:41:35 <SrPx> so I don't need: cross :: f a → f a → f a ... I need: cross :: [f a] → f a
11:41:36 <SrPx> interesting
11:41:55 <SrPx> does that make sense or is my math off?
11:42:03 <ReinH> I don't understand what you're doing.
11:42:19 <amyers> or, option is as above without the notWord8 and options = (word8 0xff *> return []) <|> ((:) <$> option <*> options)
11:42:45 <amyers> I'm not sure which I consider better, and I'm wondering if there's a canonical way of handling this sort of thing
11:43:17 <amyers> the second is uglier
11:43:25 <nkar> hodapp: try nix, and you'll never have to rebuild your sandbox again
11:43:35 <SrPx> See, look at my code for "hitQuad". It has the line: "planeNormal = cross (b - a) (d - a)". It would work for 2D, if instead I had: "lineNormal = cross (b - a)". Notice that "cross" for 2d requires one less argument. Similarly, for 4D, you can get the normal of 3 lines by using a 4d matrix multiplication
11:43:37 <ReinH> amyers: do you want manyTill?
11:43:48 <amyers> but it's appealing, to me, to put the terminator check outside
11:44:09 <SrPx> I guess I know what to do now, though... I'll ask on #math if they know a name for this
11:45:03 <amyers> ReinH, maybe I need to reread that.  On my first read I thought it didn't do what I wanted
11:45:09 <amyers> ReinH, but now I think it might
11:45:54 * hackagebot cabal-test-bin 0.1.1 - A program for finding temporary build file during cabal-test.  http://hackage.haskell.org/package/cabal-test-bin-0.1.1 (junjihashimoto)
11:45:56 * hackagebot hpqtypes 1.3.1 - Haskell bindings to libpqtypes  http://hackage.haskell.org/package/hpqtypes-1.3.1 (arybczak)
11:46:19 <ReinH> SrPx: I'm not sure what you're doing, but the generalization of a cross product to higher dimensions is a wedge product http://en.wikipedia.org/wiki/Exterior_algebra
11:46:37 <amyers> ReinH, Yep, that was it, thanks!  Not sure what I was thinking when I looked at it :p
11:46:41 <ReinH> amyers: np :)
11:47:06 <ReinH> I can't make sense of a 2-dimensional cross product though
11:47:30 <dsfox1> well I don't know what happened to my pass phrase
11:49:32 <jle`> SrPx: there isn't really a meaningful 2d cross product like you describe
11:49:34 <SrPx> ReinH: I see, maybe my hitQuad implementation is not "natural" then?
11:50:06 <SrPx> I wonder if there is such an implementation that works for any dimensions... since for the rest of the functions it seems to work
11:50:08 <ReinH> Oh, yeah, I can actually. It's the same thing applied to 2 dimensions. x×y = x₁y₂ - x₂y₁.
11:50:57 <jle`> SrPx: what are you looking for, exactly?
11:51:19 <ReinH> jle`: There is, actually, it just doesn't do what I think SrPx wants to do.
11:51:35 <jle`> yes, that's what i mean
11:51:53 <ReinH> Then again I'm really not sure what SrPx is trying to do, so maybe we should figure that out first.
11:51:57 <jle`> yeah, heh
11:52:46 <SrPx> I explained :( I'm trying to make my functions generic by using Linear's typeclasses instead of V3. I noticed most of them generalize without changes, except those using cross products. See: http://lpaste.net/119263
11:52:54 <ReinH> if you're trying to find a normal, that means you want the usual (3D) cross product, so I'm not sure why you are using 2D vectors.
11:53:08 <ReinH> SrPx: Well yes, cross product isn't generalizable in that way.
11:53:09 <ReinH> That's why it is written for V3.
11:53:24 <ReinH> The usual definition of cross product is on 3D vectors.
11:53:38 <jle`> you're trying to find the normal to what, a vector?
11:53:48 <SrPx> yea I'm just wondering if "hitQuad" could be written in a way that works for 2D and 3D. this is not important, though, nevermind that... just curiosity
11:54:27 <ReinH> SrPx: Well you're trying to find the surface normal. That implies you are working in 3D.
11:54:37 <ReinH> So I don't see how it generalizes to 2D at all.
11:56:06 <SrPx> ReinH: yes not this code, ok. But finding the intersection between a line and a quad makes sense in 2D too
11:56:15 <SrPx> Ah.
11:56:39 <ReinH> No more sense than between a ray and a line segment.
11:56:40 <SrPx> Hmm no, maybe not... I see
11:58:17 <ReinH> Well, no, ofc you can, but not in the same way you do in 3D.
11:58:42 <jle`> if yo want to generalize then if you can extend the quadrilateral infinitely in z and find the intersection of that with your line on z=0
11:59:03 <jle`> i'm not sure if that's a useful way to go about it tho
11:59:49 <SrPx> I see it now, my bad
11:59:51 <SrPx> :)
11:59:56 <toblerone> Whats the fastest way to modify a subset of indices in a Vector? For instance, I have a (Vector Word8) representing an RGBA image, and for each pixel I want to apply a function (RGBA -> RGBA). I came up with this: http://lpaste.net/119242 but I'm surprised by the performance
12:00:10 <toblerone> is there a better way?
12:00:52 <ReinH> toblerone: That sounds like what REPA is designed for btw
12:00:54 * hackagebot cabal-test-bin 0.1.2 - A program for finding temporary build file during cabal-test.  http://hackage.haskell.org/package/cabal-test-bin-0.1.2 (junjihashimoto)
12:01:10 <ReinH> But anyway Vector has an indexed map iirc
12:01:13 <toblerone> yeah, I know of repa, but I was hoping not to pull it in for this project
12:01:20 <ReinH> imap, yeah
12:01:50 <toblerone> also, the imap function is pretty awkward in this case as it would supply each channel in turn and not the RGBA data
12:02:35 <toblerone> I could store each pixel as a Word32, but I'd rather not at the moment
12:02:44 <ReinH> Maybe switch to a vector-of-structures rather than structure-of-vectors?
12:02:53 <toblerone> ?
12:03:01 <ReinH> Presumably you have a vector for each channel?
12:03:10 <JordiGH> Is there a built-in in-place partial of arrays? e.g. quickselect?
12:03:43 <ReinH> JordiGH: what would it do?
12:03:46 <toblerone> no, I have each pixel laid out contiguously in the vector. So, [0..3] would be the r,g,b,a channels of the first pixel
12:04:09 <jle`> JordiGH: you mean, return a new array that refers to a contiguous subset of the old array?
12:04:13 <jle`> by index?
12:04:15 <JordiGH> ReinH: https://en.wikipedia.org/wiki/Selection_algorithm
12:05:04 <JordiGH> jle`: No, modify the existing array in-place, without allocating any more memory, in such a way that the nth entry is in the right spot, and everything to the left of the nth entry is larger and everything to the right of the nth entry is smaller. Basically, a truncated quickselect.
12:05:23 <jle`> what is the "right spot"?
12:05:37 <JordiGH> The nth entry contains the element of rank n.
12:05:41 <jle`> ah
12:06:01 <ReinH> JordiGH: Doesn't sound like something you'd want to do in Haskell.
12:06:14 <JordiGH> :-/
12:06:37 <JordiGH> So I wrote the algorithm in Python... http://inversethought.com/hg/medcouple/file/default/medcouple.py
12:06:38 <jle`> i don't quite completely agree
12:06:52 <JordiGH> I was able to translate it almost literally into C++ http://inversethought.com/hg/medcouple/file/default/jmedcouple.c++
12:07:11 <JordiGH> And now I'm wondering about how to do it in Haskell. The C++ version is *fast*.
12:07:29 <JordiGH> I also need to figure out how to do something like for loops in Haskell... there is some indexing tricks here that are kinda hard to do with TCO.
12:07:42 <jle`> you can do most array operations with the array api
12:07:52 <JordiGH> I'd have to implement my own quickselect?
12:08:03 <jle`> http://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array-MArray.html
12:08:12 <jle`> you might also want to look into `vector` too
12:08:30 <JordiGH> I definitely don't want plain lists, because I don't want O(n) indexing!
12:08:39 <jle`> you also don't want plain lists because they aren't arrays :P
12:08:43 <JordiGH> MArray might work...
12:09:00 <JordiGH> But I guess I'll have to implement partial sorting myself.
12:09:16 <jle`> it wouldn't be fair to compare an algorithm on arrays to an algorithm on streams, heh
12:09:23 <ReinH> JordiGH: Richard Bird's Pearls of Functional Algorithm Design has a selection algorithm in it.
12:09:43 <ReinH> My point was not that Haskell can't do this sort of algorithm well, it's that if you approach it in the same way that you would in C you are likely to get poor results.
12:10:57 <ReinH> JordiGH: things like "for looks in Haskell" smell like trying to use the wrong tool for the job.
12:11:02 <ReinH> *for loops
12:11:15 <JordiGH> ReinH: Meh, it's usually just translating them into TCO.
12:11:25 <Hijiri> or maps?
12:11:26 <Hijiri> or  folds
12:11:29 <Hijiri> etc
12:11:50 <JordiGH> A fold in this case might work, since I need to keep track of what's the count so far.
12:12:12 <ReinH> JordiGH: I completely disagree.
12:12:19 <ReinH> It's not "just translating them into TCO" at all.
12:12:21 <JordiGH> These two loops are the most loopy part: http://inversethought.com/hg/medcouple/file/default/medcouple.py#l149
12:12:49 <ReinH> It's often finding a completely different method that doesn't rely on mutability.
12:13:19 <JordiGH> This method was difficult enough to understand. I can't imagine doing a different one without mutability.
12:13:36 <JordiGH> You just keep the "state" in the running tally in a fold, that can work.
12:13:41 <JordiGH> Or you pass it around as an extra argument in TCO.
12:14:01 * ReinH sighs
12:14:06 <jle`> are you just doing things to compare? or is there a real bigger thing you are trying to do?
12:14:09 <ReinH> I wish people would stop saying "TCO" like it's some sort of magic trick.
12:14:27 <JordiGH> jle`: Mostly as an exercise.
12:14:30 <jle`> ah
12:14:50 <vanila> JordiGH, I think you're talking about CPS? not TCO
12:14:51 <JordiGH> ReinH: I already solved a very difficult problem writing down this in Python and C++. I don't want to create an even more difficult problem writing down this algorithm in Haskell.
12:15:04 <JordiGH> vanila: I'm talking about writing tail-recursive functions?
12:15:07 <Hijiri> haskell has no TCO
12:15:11 <ReinH> JordiGH: Well then why are you trying to do it in Haskell if you don't want to do it in Haskell?
12:15:12 <Hijiri> because no optimization is necessary
12:15:24 <ReinH> Hijiri: thank you
12:15:34 <JordiGH> ReinH: I want to write it in Haskell, I just don't want to create a completely new puzzle when doing so.
12:15:47 <vanila> oh ok
12:16:01 <ReinH> Well, then don't complain about the performance of your transliterated C algorithm.
12:16:34 <ReinH> FWIW vector-algorithms already has a selection algorithm
12:16:44 <JordiGH> Ah, nice.
12:16:47 <ReinH> and a partial sort algorithm
12:16:48 <JordiGH> That's the biggest bottleneck.
12:17:02 <JordiGH> Partial sort and selection are essentially the same function.
12:17:41 <ReinH> pretty close, but different enough that you don't really get much code reuse
12:17:59 <JordiGH> Eh?
12:18:10 <JordiGH> You do one you get the other one for free.
12:18:39 <ReinH> Well no, not "for free".
12:18:54 <ReinH> you can select faster than you can sort
12:18:57 <JordiGH> Yes for free. Unless there's some magical selection algorithm I don't know about that doesn't require partial sorting.
12:19:09 <JordiGH> How do you select without partial sorting?
12:19:20 <ReinH> Well, you could look at the implementation.
12:19:37 <Welkin> do a linear search
12:19:40 <Welkin> no sorting required
12:19:47 <ReinH> Right.
12:19:48 <JordiGH> Welkin: How do you select in O(log n) time without partial sorting?
12:20:00 <JordiGH> Is vector-algorithm really that stupid? It does an O(n) selection?
12:20:02 <athan> Hey guys, I have a question, more about application design than technical haskell. I constantly find myself at a battle - do I prolong IO until the edge of my exhibited use case, or do I pre-populate my application and organize everything into a unified, pure monad? This is on the same spectrum of MVC, I think, but more... precise
12:20:21 <athan> Just wondering if anyone wants to talk about the idea
12:20:34 <Welkin> what is vector-algorithm?
12:20:47 <ReinH> Not sure what you're talking about. quickselect is O(n²)
12:20:53 <JordiGH> wat
12:20:59 <JordiGH> ReinH: Oh, you mean in the worst case.
12:21:01 <JordiGH> Amortised time.
12:21:06 <ReinH> I'm not aware of any selection algorithms that are O(log n)
12:21:31 <ReinH> Right. Expected linear time, worst case O(n²).
12:22:25 <kadoban> ReinH: There's at least worst-case linear (introselect, probably others)
12:22:41 <ReinH> Yes, there are other algorithms
12:22:48 <JordiGH> Oops, right, O(n), I feel dumb.
12:22:51 <ReinH> I'm just pointing out that I've never seen an O(log n) algorithm.
12:22:59 <ReinH> I don't think it's possible.
12:23:00 <kadoban> Yes, I think that's not possible
12:23:00 <JordiGH> I misremembered.
12:23:37 <kadoban> (at least in the comparison model, not sure in others)
12:23:42 <JordiGH> Yeah, it's kind of obvious you need at least O(n) comparisons. Even if you're lucky and magically guess the median at the first try, you still have to compare it with everything else to make sure it really is the median.
12:24:12 <JordiGH> I was thinking of how many times quickselect or introselect has to partition.
12:24:21 <JordiGH> Well, quickselect.
12:24:28 <kadoban> Right, gotcha
12:24:41 <ReinH> Selection performs n actions log n times, giving n + n/2 + n/4 + ... = 2n = O(n)
12:25:01 <ReinH> That's the theoretical bound afaik.
12:25:32 <sdegutis> Hi. I just learned a lot of OCaml and I am seriously considering learning Haskell instead. But I don't know what the crap a monad is and it sounds scary.
12:25:46 <HeladoDeBrownie> sdegutis, not relevant for starting haskell. you'll do fine
12:25:47 <ReinH> sdegutis: Don't worry about it.
12:25:53 <mmachenry> sdegutis: Just ignore them
12:25:59 <kadoban> sdegutis: Ignore it, it's not as important as all of the fuss makes it sound.
12:26:06 <HeladoDeBrownie> @where fugue
12:26:07 <lambdabot> I know nothing about fugue.
12:26:10 <ReinH> sdegutis: You with things like Maybe or Either or State. You don't work with "a monad".
12:26:12 <HeladoDeBrownie> @quote fugue
12:26:13 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
12:26:21 <ReinH> HeladoDeBrownie: :)
12:26:27 <ReinH> *work with
12:26:58 <jle`> sdegutis: it's not important
12:27:01 <ReinH> (Unless you're writing something that is specifically designed to generalize to all Monad instances, at which point presumably you know enough to do so)
12:27:17 <JordiGH> sdegutis: It's best to pretend monads don't exist: http://blog.jle.im/entry/io-monad-considered-harmful
12:27:28 <JordiGH> At least at first.
12:27:30 <HeladoDeBrownie> @where learnhaskell
12:27:31 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:27:36 <sdegutis> ha
12:27:36 <HeladoDeBrownie> sdegutis, take a look at that ^
12:27:38 <jle`> wait that's actually not what the post is about but ok >_>
12:27:49 <sdegutis> About 17 immediate responses all saying the same thing.
12:27:55 <ReinH> sdegutis: Have we mentioned that you shouldn't worry about monads? I'm not sure if that's clear yet.
12:27:56 <HeladoDeBrownie> sdegutis, feel free to ask any questions you have in here
12:27:58 <sdegutis> If this isn't being reassured, I don't know what is.
12:28:15 <sdegutis> Also, you Haskellers aren't the total pricks everyone says you afre.
12:28:18 <sdegutis> *are
12:28:21 <ReinH> sdegutis: Well give us some time eh
12:28:24 <sdegutis> s/afre/are/
12:28:33 <sdegutis> JordiGH: also where do I know you from?
12:28:52 <Hijiri> JordiGH seemed familiar to me too
12:28:52 <JordiGH> sdegutis: I'm all over the freeternets.
12:28:57 <Hijiri> but maybe that was just in here?
12:29:01 <Hijiri> Or maybe #tox, or something
12:29:06 <JordiGH> IRC, HN, lobste.rs
12:29:12 <ReinH> sdegutis: People that make newbies feel bad for not knowing things aren't "Haskellers". Maybe "jerks".
12:29:13 <sdegutis> JordiGH: im thinking either #Python or #ruby or ##linux
12:29:21 <JordiGH> I suppose I should branch out into Twitter some day.
12:29:26 <sdegutis> ReinH: :)
12:29:32 <tasker> Is there some none infix fractional division ?
12:29:41 <JordiGH> sdegutis: #python and ##linux are places I visit, the latter very infrequently, though.
12:29:43 <tasker> or do I just have to write a wrapper ?
12:29:45 <jle`> :t (/)
12:29:46 <lambdabot> Fractional a => a -> a -> a
12:29:48 <sdegutis> oh then #python
12:29:51 <HeladoDeBrownie> tasker, well, you can make it non-infix by surrounding it in parens. (/)
12:29:58 <ReinH> tasker: (/) is non-infix / ;)
12:30:03 <darthdeus_> I hope there were 17 responses all saying that there is one web framework that is better than the others :(
12:30:05 <jle`> > (/) 5 4
12:30:07 <lambdabot>  1.25
12:30:08 <sdegutis> The one thing is that I vastly like OCaml's syntax.
12:30:14 <darthdeus_> spent another 2 hours looking at all of them, still dont like any :p
12:30:32 <tasker> ReinH, HeladoDeBrownie : Good knowledge, cheers :D
12:30:32 <HeladoDeBrownie> sdegutis, you'll certainly find syntactic similarities, but also some completely different things
12:30:32 <jle`> darthdeus_: none are better than all of the others :)
12:30:32 <ReinH> darthdeus_: All web frameworks are better than all others according to group consensus. ;)
12:30:51 <darthdeus_> jle`: having to many choices is always not better than having few though :D
12:30:59 <darthdeus_> ReinH: yeah that's the problem ...
12:31:04 <darthdeus_> like it's impossible to pick one and be happy
12:31:09 <darthdeus_> i suck at making choices in life
12:31:12 <darthdeus_> especially important ones like this
12:31:13 <ReinH> Well, I think it implies that there are a lot of reasonable choices.
12:31:20 <ReinH> So at that point just pick one.
12:31:35 <darthdeus_> but which one?
12:31:36 <darthdeus_> :P
12:31:37 <ReinH> darthdeus_: I will say that we've had a lot of success with Scotty, and that Spock looks interesting as well.
12:31:54 <hiptobecubic> spock is based on scotty isn't it?
12:32:12 <ReinH> But I don't think it matters too much. Maybe try Scotty, Snap and Yesod on something simple and see which one you prefer.
12:32:14 <jle`> sdegutis: haskell and ocaml's syntax are of similar spirit.  there are some particular design philosophy decisions, like making the "type-level" syntax match the "value-level" syntax more --- [a], instead of List a, (a,b), instead of a*b, etc.
12:32:29 <jle`> sdegutis: but for the most part the syntax won't be the "main difference"
12:32:51 <darthdeus_> already tried yesod and it feels it won't fit the app i'm planning to build, ... though it has great support for forms, which scotty and spock don't really care about it seems
12:32:55 <HeladoDeBrownie> i actually think ocaml gets certain things "more right", like using : for type annotations instead of ::, but overall i like haskell's
12:33:12 <jle`> yeah, the syntax isn't really the important part of the difference, i feel :)
12:33:29 <ReinH> HeladoDeBrownie: Idris as well, but then you get :: for list concatenation, so...
12:33:33 <darthdeus_> ReinH: i wish there was like "scotty/spock + forms"
12:33:46 <HeladoDeBrownie> ReinH, looking at how often i cons versus how often i notate types, i wouldn't mind :)
12:33:51 <ReinH> darthdeus_: you can plug something like formlets in pretty easily though?
12:34:08 <ReinH> HeladoDeBrownie: Then again, you could use (:) for both as they're in disjoint scopes...
12:34:17 <darthdeus_> ReinH: well yeah, that's another issue ... there are 50 ways of doing forms as well
12:34:37 <ReinH> darthdeus_: Yeah, hackage is tough that way.
12:35:00 <sdegutis> Thanks everyone. I am encouraged to try reading Gentle Haskell.
12:35:01 <ReinH> darthdeus_: I wish there were any sort of quality signal for packages. Sometimes I just go look at their github to see how many issues/stars/forks they have
12:35:20 <ReinH> sdegutis: that's pretty old and... not very gently, FYI.
12:35:23 <ReinH> *gentle
12:35:44 <darthdeus_> ReinH: yes! exactly ... bu thten there's the question like "spock has only 3 issues, is that a good thing or a bad thing?"
12:35:47 <ReinH> sdegutis: If you're interested in a book that will teach you Haskell and probably also improve your overall FP understanding, look at Richard Bird's Thinking Functionally with Haskell.
12:35:50 <darthdeus_> but then*
12:35:57 * hackagebot keyword-args 0.1.0.0 - Extract data from a keyword-args config file format  http://hackage.haskell.org/package/keyword-args-0.1.0.0 (jsl)
12:36:04 <ReinH> darthdeus_: Well, I look more at closed issues :)
12:36:13 <ReinH> You can determine close rate, response time, etc
12:36:22 <jle`> sdegutis: there was a guide posted earlier :)
12:36:30 <darthdeus_> hmm, good idea
12:36:31 <ReinH> Actually it would be cool if someone write a tool that would analyze github issues and give statistics like that...
12:36:32 <sdegutis> ReinH: I am very familiar with FP, having learned Clojure very well and OCaml mostly well, so I only need to learn the Haskell specifics, not to learn FP
12:36:34 <jle`> @where learnhaskell
12:36:34 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:36:45 <ReinH> sdegutis: Sure, although I thought I was pretty familiar too before I read Bird :)
12:36:50 <sdegutis> okay
12:37:04 <sdegutis> is it free online?
12:37:07 <ReinH> sdegutis: Not suggesting that you're an FP newb, but rather that Bird's book is really some next-level stuff.
12:37:07 <jle`> Haskell is just a nice language that happens to coincidentally be FP, from what I've learned, heh
12:37:14 <ReinH> sdegutis: No but the kindle version is relatively inexpensive.
12:37:17 <sdegutis> ok
12:38:09 <Hijiri> I'm guessing this isn't the place to make a stallmanite soapbox?
12:38:30 <ReinH> Hijiri: about what?
12:38:42 <Hijiri> kindle
12:39:55 <ReinH> Well, if there was a DRM-free open access version I would have recommended that.
12:39:57 <S11001001> Hijiri: I think you can expect that most understand the problem, and have made their own compromises.
12:40:06 <S11001001> Hijiri: and I say that as a card-carrying FSF member.
12:40:57 * hackagebot keyword-args 0.1.0.1 - Extract data from a keyword-args config file format  http://hackage.haskell.org/package/keyword-args-0.1.0.1 (jsl)
12:41:34 <hoppla> Hi, I've got a question concerning Haskell and GnuPlot. How can i prevent Gnuplot from connecting points to lines? I'm using Graphics.Gnuplot.Simple and the plotFuncs function. What parameter do I have to pass and how do I pass it?
12:46:47 <tapuu> Is there a 'free' version of Data.Functor.Bind?
12:46:55 <tapuu> Like a free monad
12:46:56 <hoppla> assuming this function ((2.71052+1.5-0.5*abs(x)-1.35526*sqrt(4-(abs(x)-1)^2))*sqrt(abs(abs(x)-1)/(abs(x)-1))+0.9), gnuplot is drawing a line over the intervall where the function isn't defined. how do I turn this off with Graphics.Gnuplot.Simple?
12:47:39 <int-e> hoppla: PlotType controls the style... so I guess plotFuncs can't control this. Perhaps LineStyle can fake the effect you want.
12:48:21 <hoppla> int-e: Thanks, I'm going to try it
12:49:07 <ReinH> tapuu: A imagine this would be the free monad without the Return constructor.
12:49:39 <tapuu> ReinH: thats the kind of thing I want, I want to know if its the same thing as the type-level fixed point combinator
12:49:49 <jle`> what about Fix ?
12:50:30 <tapuu> jle`: I want to find out about the relationship between Fix and monads without identity, if there is one
12:54:29 <a3gis> Hello! I have a program-structure kind of question for whom would be kind enough to answer. I am building a first order logic derivation engine. Basically I want to represent a derivation { lines :: [Line], goals :: [Goal], scope :: Map String LineIndex }. The actual properties of a derivation are not very important. What I want to do is apply some rules to a derivation. For example, the rule "Existential instantiation" would be a function taking a lin
12:54:29 <a3gis> e number and a variable as argument; it would look up the line in the derivation (potentially throwing an error, so the output would be Either String Line...), check if the variable is already in scope; if yes, error, if no, it would insert a new line in the derivation and insert the variable in scope
12:54:30 <ReinH> Hmm.
12:54:58 <a3gis> again, this aprticular example is not very important; the problem is that I have this derivation object on which I want to chain a bunch of actions
12:55:06 <a3gis> and I'm not sure about the best way to handle this
12:55:25 <a3gis> to not get into a mess with a one-liner of function applications, passing the new derivation as parameter each time
12:55:43 <Hijiri> You could use State, or StateT
12:56:14 <Hijiri> (also as a side note, if you want indexing by integers you probably want to use something like an IntMap rather than lists)
12:57:06 <BobtheBuilding> hello everyone
12:57:08 <ReinH> Hijiri: I'm not so sure. The example would involve modifying the entire map to insert a line.
12:57:25 <Hijiri> Oh, I guess so
12:57:51 <BobtheBuilding> I am new to Haskell and functional programming in general (I have experience in OOP). What are some good resources to get started with learning Haskell?
12:57:58 <Hijiri> @where learnhaskell
12:57:59 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:58:04 <ReinH> Hijiri: I would hazard a guess that a3gis isn't trying to derive Principia Mathematica, so probably won't have 10,000 line derivations... ;)
12:58:30 <BobtheBuilding> thanks
12:58:32 <BobtheBuilding> !
12:58:57 <tapuu> I'm surprised there isnt more stuff about monads without identity
12:59:02 <ocramz> hej there
12:59:05 <a3gis> ReinH: haha yep, it's for small derivation system for students to play with
12:59:10 <ReinH> tapuu: well they aren't nearly as useful.
12:59:16 <a3gis> I don't think any will go above 50 lines
12:59:38 <tapuu> hmmm
13:00:10 <jle`> tapuu: also most of the monad laws are stated in terms of an identity
13:00:49 <jle`> hm
13:00:50 <ReinH> tapuu: They show up more often with comonadic structures, and people currently use comonads far less often than monads.
13:00:58 * hackagebot record 0.2.0 - First class records implemented with quasi-quotation  http://hackage.haskell.org/package/record-0.2.0 (NikitaVolkov)
13:01:00 <geekosaur> Gödel might have something to say about trying to derive Principia Mathematica >.>
13:01:23 <ReinH> e.g. comonads often have some sort of zip function (<*>) but not pure.
13:01:46 <a3gis> ReinH: what is the intuitive definition of a comonad? I understand monads as computational contexts / lax propositions
13:01:49 <tapuu> that's interesting
13:02:06 <hoppla> int-e: I guess LineStyle does not fake the behaviour I want... How can i change PlotType?
13:02:35 <edwardk> stuff you can redecorate by looking around you from all the points within it, and reassemble the new decorations without changing the shape
13:02:52 <raek> I've heard that comonads can be thought of as cellular automata
13:02:59 <jle`> did edwardk set up a ping alert on comonads now too
13:03:01 <ReinH> raek: The other way around :)
13:03:15 <ReinH> edwardk: so monad : substitution :: comonad : decoration?
13:03:20 <edwardk> raek: that is sort of the go to example, the store comonad is a comonad and can be used for cellular automata
13:03:24 <edwardk> ReinH: yes =P
13:03:28 <a3gis> edwardk: that means literally nothing to me
13:03:30 <a3gis> :(
13:03:30 <ReinH> edwardk: huh. Cool.
13:03:44 <jle`> a3gis: best way is just to work with a few in practice :)
13:03:45 <raek> :-)
13:03:51 <ReinH> a3gis: One common example of a comonad is a sort of pointed environment.
13:03:52 <jle`> a3gis: there really isn't a short-cut to what you are looking for
13:03:54 <edwardk> ReinH: http://www.ioc.ee/~tarmo/papers/sfp01-book.pdf <- =P
13:04:09 <edwardk> a3gis: consider (>>=) for a second
13:04:12 <edwardk> :t (>>=)
13:04:13 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:04:15 <a3gis> jle`: I'm more looking for a theoreticla justification than practical application
13:04:38 <sdegutis> Has anyone written a 2-page introduction to the most commonly used parts of Haskell?
13:04:49 <jle`> if you think of monads as things that let you chain (a -> m b)'s, then comonads are things that let you chain (w a -> b)'s
13:04:58 <a3gis> sdegutis: http://www.stephendiehl.com/what/ ?
13:05:00 <ReinH> Wait, holy shit. I accidentally opened that PDF in emacs and... it... worked... and now I'm reading a PDF in emacs.
13:05:00 <sdegutis> I mean, with the target audience of someone who is proficient at many programming languages.
13:05:01 <timpani> I realize that the 's' in 'StateT s m a' is usually a functional data structure, but would there be anything freakishly wrong with making it a database connection (in which case 'm' would be IO)?
13:05:05 <ReinH> emacs can do that?!
13:05:09 <edwardk> you can take a 'whole', and part of the whole, grow that part into a new 'whole' then some how graft all of those together, m >>= f    does substitution giving m (m b) followed by renormalization yielding m b via join.
13:05:12 <jle`> or if monads let you turn a (a -> m b) into a (m a -> m b), then comonads let you turn a (w a -> b) into a (w a -> w b)
13:05:13 <ReinH> edwardk: Oh, yeah, there it is.
13:05:29 <edwardk> now a comonad on the other hand has a different way to extend the thing
13:05:35 <tapuu> timpani: whats the point of using state then, just use reader
13:06:25 <edwardk> w a -> (w a -> b) -> w b         you have a whole comonad, and you get lots of different 'views of of it, from the perspective of different a's, remember, given w a you can extract :: w a -> a, so each 'w a' you call the function with focuses on a different 'a'
13:06:30 <int-e> hoppla: it's part of the PlotStyle, and the plotFuncs function doesn't take one, I'm afraid. I'd try my luck with plotPathsStyle.
13:06:38 <edwardk> and you need to give me a 'b' that you want to put in that place
13:06:50 <edwardk> then extend is responsible for stitching up all those 'b's into a 'w b'
13:07:37 <a3gis> edwardk: ok; maybe I should say what my current state of monad understanding is. The clearest explanation I have seen so far (to me) was in a lecture was pfenning, where he was talking about lax judgment, which is a "weak truth". He went on describing the inference rules involving lax propositions, which are exactly the monad operations. (A -> A lax, A x, A -> B lax, B lax)
13:08:06 <edwardk> we could have a non-empty stream comonad such that your extended function is called with each of the non-empty tails of the stream, and the result is assembled into a stream
13:08:22 <a3gis> mmh ok
13:08:51 <a3gis> is there a logic approach like I just described for comonads? (if I made sense at all)
13:09:16 <hoppla> int-e: So I have to evaluate my functions by hand?
13:09:21 <tapuu> I just googled lax judgement and all I saw was stuff about lacrosse and league of legends
13:09:51 <a3gis> tapuu: might be in that paper: https://www.cs.cmu.edu/~fp/papers/mscs00.pdf
13:09:57 <edwardk> a3gis: well, if you want to take a logic based view of monads and comonads, you can compare modalities for possibility and necessity, to see comonads and monads in action.
13:09:58 <a3gis> let me find the lecture tho
13:10:13 <a3gis> tapuu: https://www.youtube.com/watch?v=JzIAEv8fN88
13:10:15 <timpani> tapuu: isn't the Reader monad supposed to represent only immutable state?
13:10:19 <tapuu> thanks a3gis
13:10:23 <timpani> (represent -> involve)
13:10:35 <edwardk> a3gis: return :: a -> Possibly a;  (>>=) :: if possibly a and (a entails possibly b) then possibly b
13:10:36 <tapuu> timpani: your database connection is mutable?
13:10:55 <edwardk> extract :: Necessarily a -> a
13:11:13 <int-e> hoppla: As far as I can see. (These two functions, plotFunc and plotFuncs, are the only ones taking a -> a paramters)
13:11:14 <edwardk> etc
13:11:20 <timpani> tapuu: no, of course not. But how would you accommodate the IO monad. Isn't StateT most natural?
13:11:33 <geekosaur> ReaderT
13:11:39 <edwardk> a3gis: the (!) modality in linear logic is also a comonad
13:11:50 <tapuu> timpani: a ReaderT DatabaseConnection IO will do everything you need
13:11:52 <edwardk> there are lots of modalities in logic that act as monads or comonads.
13:11:54 <hoppla> int-e: OK. Is there a smart way to do this or just a list comprehension?
13:11:58 <a3gis> edwardk: erm I'll need some time to wrap my head around this
13:12:02 <a3gis> thanks for the explanation :)
13:12:20 <timpani> geekosaur: yes, that's right. But again: would there be anything glaringly wrong with using StateT?
13:12:41 <int-e> hoppla: but I only looked at the Graphics.Gnuplot.Simple module. I don't know the library.
13:12:47 <tapuu> timpani: its wrong to use stateT for immutable data
13:12:55 <tapuu> I think
13:12:55 <geekosaur> depends on what you consider glaring. using StateT implies that it will be mutated, using it for something that is not being mutated is a smell
13:13:00 <edwardk> a3gis: basically i'd consider the logic-based viewpoint that you have as 'part of the story', just like how folks who say 'monads are for IO' or 'monads are containers' are seeing part of the story. they've latched onto one case.
13:13:25 <timpani> tapuu, geekosaur: I thought so...thanks.
13:13:28 <hoppla> int-e: ok, I may take a look at Graphics.Gnuplot.Advanced
13:13:38 <edwardk> monads aren't "about" state, (State s) just happens to be a monad. ;)
13:13:50 <geekosaur> StateT alerts me to watch out for something that will change the state
13:14:09 <a3gis> edwardk: is the category-theory description closer to what they truly are?
13:14:29 <tapuu> wat
13:14:33 <geekosaur> ReaderT tells me that you're carring something around but don't expect to change it; things like database connections make sense
13:14:43 <IRWolfie-> server down or netsplit I guess
13:14:44 <geekosaur> that is probably a server going splat
13:15:35 <tapuu> So, I'm looking at recursion-schemes
13:15:50 <tapuu> I've got a data structure defined in terms of fix, and all I want to do is change stuff at the leaves
13:15:56 <tapuu> what am I supposed to use for that
13:18:34 <filius> Hi guys, I'm working on a data analysis task, where I need to compare all entries[Strings] pairwise in a very large list, and accumulating pairs along the way. But I got out of memory errors. is there some way to stream my data (sort of)so I don't need to load the entire list into my memory at once? I don't mind the program to run a bit longer.
13:19:03 <Welkin> @src Eq String
13:19:03 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
13:19:08 <jle`> timpani: that's like saying, "should i write all my (a -> b) functions as (a -> (b, a)) instead?"
13:19:17 <Welkin> why can I not view the source for Data.Eq on hackage?
13:19:24 <jle`> length' xs = (length xs, xs)
13:19:37 <Welkin> I find that sometimes there is no source available
13:19:43 <nkar> Welkin: because that's not the real source
13:19:51 <Welkin> where is it?
13:19:54 <Black0range> hey guys what does this error mean? http://lpaste.net/119269
13:20:15 <int-e> hoppla: it's basically a list comprehension.  Graphics.Gnuplot.Plot.TwoDimensional  has a 'functions' (which plotFuncs uses) that takes a style argument (waaah, it's a lemming library, all those T's are quite impossible to follow despite haddock's hyperlinks...)
13:20:17 <nkar> Welkin: ah, I was referring to the @src command, not the hackage issue
13:20:31 <pharpend> Black0range: GHC isn't able to infer the type from your expression
13:20:32 <mauke> Black0range: is this older code?
13:20:40 <Black0range> no this is new code
13:20:47 <nkar> Welkin: you need an instance for [a]
13:20:52 <Welkin> http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Eq.html <-- zero links to source
13:20:58 * hackagebot keyword-args 0.1.0.2 - Extract data from a keyword-args config file format  http://hackage.haskell.org/package/keyword-args-0.1.0.2 (jsl)
13:21:04 <mauke> Black0range: ok, then the problem is that ghc doesn't know what type of exception you want to catch
13:21:14 <Black0range> I dont care?
13:21:32 <mauke> you must care
13:21:34 <geekosaur> Black0range, exceptions are kinda special; they're typeclasses and you can catch specific exceptions by specifying the type. but if you want to catch any exception you need to use a polymorphic wrapper.
13:21:43 <Black0range> :(
13:21:46 <nkar> Welkin: String is just an alias for [Char], so you need to find the list instance
13:21:47 <geekosaur> in this case, you tell it to expect the type SomeException
13:21:50 <Black0range> so if i wanna catch all exceptions?
13:21:59 <mauke> I'd recommend against catching all exceptions
13:22:07 <nkar> Welkin: that's my understanding
13:22:20 <mauke> but you'd do (\SomeException{} -> ...)
13:22:20 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/Control-Exception.html read this
13:22:23 <jle`> if you're juts trying to get it to compile, you should add a type annotation somewhere saying that you want :: SomeException
13:22:25 <Black0range> mauke: it's for a web server that is where the controll is let over to the developer
13:22:26 <hoppla> int-e: How can I find out all possible values for the T argument? I can guess Type.lines, Type.lines and Type.listLines from the example, but are there others?
13:22:54 <Arahael> Davideddu: As a python user, though, I find the notion that accessing one property instead of another one - ie, via the alias, to be confusing - to me it only makes sense in kv files.
13:22:58 <Arahael> Darn, wrong window.
13:23:08 <int-e> hoppla: Graphics.Gnuplot.Graph.TwoDimensional - points may be what you want
13:23:24 <mauke> Black0range: do you really want to catch exit(), assertion failures, and infinite loops?
13:23:26 <geekosaur> but really you should figure out what kind of exception(s) you need to catch and catch only those by specifying their types. because it's rarely correct to catch *all* exceptions, because some of them are not things you want (e.g. some are used to communicate between threads)
13:23:54 <hoppla> int-e: Cool, thanks a lot for your help!
13:24:02 <Welkin> sometimes it is impossible to find the source for simple things like `instance Eq String`
13:24:15 <Welkin> does anyone know where I can actually view the source for the Eq instances?
13:24:18 <mauke> that's because String is not a separate type
13:24:27 <Welkin> mauke: same for [a]
13:24:34 <mauke> [] is built into the compiler
13:24:36 <Welkin> I cannot find any instances of Eq
13:24:41 <Black0range> mauke: sir you've got a point :)
13:24:45 <SrPx> Does anyone know of a *rasterization* library in Haskell that allows me to render lines and triangles to a bitmap, using a depth buffer and gradient colors? For example: "drawLine :: Bitmap → Line → Color {-Initial-} → Color {-Final-} → Number {-Initial depth-} → Number {-Final depth-} → IO (Bitmap)" ?
13:24:59 <int-e> Welkin: they're usually derived.
13:25:20 <SrPx> That is, the same as you'd do with GL, except rasterized. Alternatively, does anyone know a simple wrapper for GL that does that?
13:25:26 <Welkin> what I really want to know is how Eq is defined for [a]
13:25:29 <SrPx> (except on the CPU*)
13:25:34 <SrPx> using mutable vectors ...
13:25:40 <Welkin> does it produce false on the first bad occurence?
13:25:51 <jle`> let's test :D
13:25:51 <Welkin> or does it continue on through to the end of the list before producing a result?
13:26:01 <jle`> > [1,2,undefined] == [100,2,3]
13:26:03 <lambdabot>  False
13:26:24 <jle`> looks like it is suficiently lazy
13:26:29 <jle`> > [1..] == [1,2,10]
13:26:32 <lambdabot>  False
13:27:30 <int-e> Welkin: but for example, http://hackage.haskell.org/package/containers-0.5.6.3/docs/src/Data-Map-Base.html  defines its own Eq instance.
13:28:07 <mauke> [] == [] = True; (x : xs) == (y : ys) = x == y && xs == ys; _ == _ = False
13:28:09 <jle`> > [1..] == ([1,2,11,29] ++ repeat undefined)
13:28:11 <lambdabot>  False
13:28:43 <ocramz> > [1..] == [1..]
13:28:46 <Welkin> okay
13:28:47 <Welkin> thanks
13:28:47 <lambdabot>  mueval-core: Time limit exceeded
13:28:53 <ocramz> oops :D
13:29:49 <ocramz> [1..] == [2..]
13:29:56 <ocramz> > [1..] == [2..]
13:29:58 <lambdabot>  False
13:30:09 <ocramz> ha
13:30:47 <ocramz> left to right, outermost to innermost
13:31:01 <int-e> mauke: but for ghc, the Eq instance is defined in GHC.Classes. (funny, I expected a standalone derived instance)
13:32:11 <Welkin> where is GHC.Classes?
13:32:47 <int-e> in the base package.
13:33:11 <Welkin> I didn't see it on hackage
13:33:11 <int-e> actually, no. it's in ghc-prim.
13:33:24 <int-e> but either way, it comes with the compiler.
13:33:25 <Welkin> the link is empty
13:33:31 <Welkin> "page not found"
13:34:06 <int-e> Welkin: https://github.com/ghc/ghc/blob/master/libraries/ghc-prim/GHC/Classes.hs
13:34:24 <Welkin> why are there so many problems like this on hackage?
13:34:33 <Welkin> stuff has missing source (or even docs) all the time
13:34:50 <IRWolfie-> Doesn't it have a model where anyone can just dump stuff on it?
13:35:05 <Welkin> IRWolfie-: well, I am talking about core packages, like base
13:35:22 <mauke> this is compiler internals
13:35:51 <geekosaur> Welkin: the infrastructure had to be moved in a hurry some time back and they're still trying to sort out all the problems that came up
13:36:04 <geekosaur> #haskell-infrastructure
13:36:37 <int-e> Hmm. GHC.Classes has a {-# OPTIONS_HADDOCK hide #-} but is still listed on the index. A bit odd.
13:37:01 <int-e> But then, the haddocks were probably uploaded separately.
13:39:45 <Welkin> > 1 == 2 && undefined
13:39:47 <lambdabot>  False
13:40:45 <ocramz> > undefined && 1 == 2
13:40:47 <lambdabot>  *Exception: Prelude.undefined
13:41:27 <ocramz> the asymmetry is due to the execution order
13:42:05 <sdegutis> I'm writing a Lua wrapper for Haskell for the sake of learning Haskell (thus I won't use or look at an existing one) and I am soliciting feedback about my tentative design of the function that lets you write a function in Haskell to be given to Lua and called from Lua but executed in Haskell.
13:42:22 <ocramz> the time arrow
13:42:25 <HeladoDeBrownie> ocramz, it's actually because (&&) is strict in its first argument but not in its second if the first is False
13:42:29 <horny-sama> need some help into turning this ins a program transpose [drop n xs | (n,xs) <- zip [0..]  [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]]
13:42:52 <ocramz> yes, that's a better wording
13:43:25 <sdegutis> I currently plan to use a sum type to represent all kinds of Lua values, and a list of this type to represent arguments given from Lua to the Haskell function, so that they could be extracted by pattern matching within the function definition's parameter list itself.
13:43:41 <sdegutis> is this a reasonable approach, I dare thusly ask uponeth thouest?
13:43:47 <sdegutis> orsomehintg
13:43:49 <HeladoDeBrownie> sdegutis, that sounds right, after all, lua is un(i)typed
13:44:06 <geekosaur> recent lua is growing something resembling types, actually
13:44:18 <sdegutis> geekosaur: no.
13:44:38 <sdegutis> When I did this in OCaml, the problem was that the compiler would warn, saying that this was not an exhaustive pattern and it might thus fail at runtime.
13:45:10 <sdegutis> That is, if my function's signature was such that it took a list of LuaType, but my function signature specifically took [(String s), (Integer i)], then other list combinations were not accounted for.
13:45:41 <ocramz> @src (&&)
13:45:42 <lambdabot> True  && x = x
13:45:42 <lambdabot> False && _ = False
13:45:49 <HeladoDeBrownie> sdegutis, although actually the "function called from lua" is more likely to be an IO value
13:45:51 <sdegutis> Will Haskell warn of the same thing? Or how does Haskell handle this?
13:46:23 <sdegutis> HeladoDeBrownie: I don't see why you say that when my function takes a list of lua values and returns a list of lua values
13:46:35 <hoppla> is there a map function that returns something like [(a, f(a))] with f as function applied to [a]?
13:46:43 <HeladoDeBrownie> sdegutis, yes, haskell is similar in that regard. it's best to provide a value for every case, even if that value is bottom (lack of useful value) with an appropriate error message; although i would really try to come up with useful values
13:46:45 <barrucadu> sdegutis: Yes, Haskell warns about incomplete pattern matches
13:47:08 <EvanR> hoppla: zipWith
13:47:10 <Welkin> hoppla: you can write your own function and map it over your list
13:47:15 <HeladoDeBrownie> sdegutis, well, it seemed like you were talking in terms of lua functions, and lua functions are actually procedures akin to haskell IO
13:47:16 <sdegutis> HeladoDeBrownie, barrucadu: how would you design such a function to avoid warnings?
13:47:25 <hoppla> zipWith sounds good
13:47:29 <hoppla> thanks
13:47:29 <HeladoDeBrownie> sdegutis, handle every case appropriately. depends on what your function does
13:47:55 <sdegutis> HeladoDeBrownie: by Lua function I simply mean a pure Haskell function that can be called from Lua via my Lua-Haskell bridging code of my own choosing
13:48:22 <HeladoDeBrownie> sdegutis, the action of calling some haskell code from lua will end up being an IO value, most likely.
13:48:34 <HeladoDeBrownie> sdegutis, even if that IO value is a straightforward lifting of a pure function
13:48:39 <sdegutis> :)
13:48:50 <sdegutis> Now I am beyond confused, for lifting and IO are beyond my knowledge of Haskell.
13:49:33 <HeladoDeBrownie> sdegutis, "lifting" is just an informal term in this context, basically "turn into". an IO value is a value representing a procedure that could be executed by the runtime system
13:50:15 <HeladoDeBrownie> sdegutis, as a sort of intuition, comparing haskell to most other languages, you could say that most languages "live in IO" whereas haskell separates IO from pure computation
13:50:23 <sdegutis> HeladoDeBrownie: oh ok
13:50:30 <sdegutis> then yes
13:50:47 <HeladoDeBrownie> so the equivalent of calling a function in lua would, in haskell, be an IO value
13:51:46 <sdegutis> I am learning Haskell via http://cheatsheet.codeslower.com/CheatSheet.pdf btw
13:52:18 <HeladoDeBrownie> that seems to be more of a reference than a learning source, have you checked out the others previously mentioned?
13:52:32 <HeladoDeBrownie> for one thing, doing exercises is very useful
13:52:34 <sdegutis> yes but they are all slow
13:52:52 <HeladoDeBrownie> okay, that gives me an idea
13:52:59 <HeladoDeBrownie> https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
13:53:02 <HeladoDeBrownie> try your hand at these
13:53:09 <HeladoDeBrownie> if you run into problems, do some reading or ask in here
13:53:13 <IRWolfie-> I don't think I've ever actually learnt a programming language by trying exercises
13:53:36 <HeladoDeBrownie> IRWolfie-, it may have worked for you, but i'm sure many here can attest to the usefulness of doing exercises for them, i among them
13:53:55 <EvanR> exercises might get you from "being able to do stuff" to "knowing what youre doing"
13:53:58 <Welkin> sdegutis: the UPenn course is good
13:54:01 <sdegutis> HeladoDeBrownie: y u gotta b talkin all fancy btw
13:54:07 <HeladoDeBrownie> sdegutis, fancy?
13:54:13 <sdegutis> jk
13:54:19 <sdegutis> re: "i among them"
13:54:21 <sdegutis> etc
13:54:27 <HeladoDeBrownie> it's just the way it occurred to me to say that
13:54:43 <Welkin> sdegutis: there are people from all over the world in here
13:54:46 <sdegutis> i was jokin bout how i dun the same type earlier
13:54:49 <Welkin> they may not speak the same was you do
13:54:57 <Welkin> way*
13:54:57 <sdegutis> Welkin++
13:55:20 <bgamari> hvr, https://github.com/hvr/packunused/pull/10 is done I believe
13:55:22 <monochrom> I learned every programming language (and everything) by trying exercises, among other things.
13:55:39 <Welkin> well, if you have ever programmed, you have done exercises
13:55:44 <Welkin> the act of programming is an exercise
13:55:52 <monochrom> I can't imagine what "learning" would mean without validation
13:56:33 <Welkin> monochrom: memorization of facts and figures, but no idea how to actually implement anything
13:56:44 <monochrom> even memorization has to be validated
13:56:51 <juanpablo_> Hello. Is there a way to get two conduits to consume from a source at the same time? Right now one of my conduits empties the pipe and the other one gets nothing...
13:57:13 <Welkin> juanpablo_: arrows?
13:57:17 <juanpablo_> wait, no two conduits, but two sinks. Which I guess are the same thing with the newer versions of Conduits
13:57:32 <juanpablo_> Welkin: can I use arrows with conduit?
13:57:54 <Welkin> wouldn't you just be feeding the same input into two separate functions?
13:58:07 <IRWolfie-> by excercises I meant those of someone else's creation
13:58:12 <Welkin> I'm not familiar enough with conduit, only having used it once
13:58:19 <juanpablo_> Welkin: yes, at the same time, from the same stream. That's what I'm aiming for
13:58:50 <sdegutis> Finally, "otherwise" used in a language!
13:58:55 <zachk> I'm having problems installing sdl2-image, should I paste the error to a pastebin? using cabal...
13:58:56 <sdegutis> I think that may be the tipping point for me.
13:59:02 <sdegutis> I think I officially like Haskell a lot now.
13:59:16 <geekosaur> @paste -- zachk
13:59:17 <lambdabot> Haskell pastebin: http://lpaste.net/
13:59:39 <Welkin> otherwise is a synonym for True
13:59:46 <Welkin> I believe
13:59:49 <benmachine> it is indeed
13:59:50 <HeladoDeBrownie> otherwise :: Bool ; otherwise = True
13:59:54 <geekosaur> (but, most of the time the problem with things like sdl2 is you're missing the developer headers/libraries. it's not like we reimplement sdl2 in haskell; we link to the existing libs)
14:00:06 <HeladoDeBrownie> (it's a synonym in the same sense that any variable is a synonym for its value :)
14:00:36 <benmachine> HeladoDeBrownie: it's arguable that otherwise is particularly a synonym since its definition is already in normal form
14:00:57 <sdegutis> Welkin: yes but it's not "else"! :)
14:01:00 * hackagebot geodetics 0.0.3 - Terrestrial coordinate systems and geodetic calculations.  http://hackage.haskell.org/package/geodetics-0.0.3 (PaulJohnson)
14:01:02 * hackagebot setdown 0.1.0.0 - Treating files as sets to perform rapid set manipulation.  http://hackage.haskell.org/package/setdown-0.1.0.0 (RobertMassaioli)
14:01:33 <HeladoDeBrownie> benmachine, i suppose i wanted to emphasize it's just a regular old binding, not special syntax. maybe i should have said that directly.
14:02:11 <benmachine> HeladoDeBrownie: I'm not criticising, just thinking out loud :)
14:02:27 <HeladoDeBrownie> oh i understand, i was too
14:03:22 <benmachine> juanpablo_: I guess passthroughSink could do what you wanted?
14:03:37 <juanpablo_> benmachine: I'll give that a look :)
14:03:45 <benmachine> juanpablo_: no promises, that's just what looks promising when I read the docs
14:04:49 <zachk> http://lpaste.net/119274 is my cabal error messages, I tried extra-include-dirs and extra-lib-dirs to what I believe to be the correct directories, but I still get the same error messages :(
14:05:50 <jonkri> I run both a acid-state server and the acid-state (remote) client with +RTS -IO (as recommended on the acid-state web site for CPU usage problems), and run closeAcidState at the end of the client execution.
14:05:56 <jonkri> However, the server process still goes up to about 100% CPU after about 1,500-2,000 client executions. I'm using acid-state 0.10.
14:06:00 <jonkri> Does anyone have any idea of what might be causing this? Thanks. :)
14:11:46 <zachk> any idea after that paste? whats the haskell game dev channel#?
14:13:41 <benzrf> zachk: haskell-game iirc
14:14:20 <sdegutis> How's the Haskell web app ecosystem?
14:14:29 <chpatrick1> https://gist.github.com/chpatrick/863a02927dc79b0b316d
14:14:33 <chpatrick1> someone was asking for this earlier
14:14:37 <chpatrick1> do you think it's useful?
14:14:42 <geekosaur> zachk: do you actually have the development library installed? (libsdl2.so.SOMETHING is not it; that's the runtime shared object. libsdl2.so with no version suffix will be.)
14:17:19 <chpatrick1> also, is there anything like Lift for types?
14:17:27 <bitemyapp> chpatrick1: Lift?
14:17:33 <chpatrick1> liftType :: proxy a -> Q Type
14:17:38 <chpatrick1> Lift from TH
14:17:40 <bitemyapp> ahhh
14:17:42 <sdegutis> Anyone?
14:17:46 <Welkin> sdegutis: https://wiki.haskell.org/Web/Frameworks
14:17:50 <sdegutis> Nice.
14:17:52 <sdegutis> Welkin++
14:18:08 <Welkin> scotty and spock are nice micro frameworks
14:18:21 <Welkin> yesod is a good batteries-included framework
14:18:29 <zachk> yes, I have libSDL2.so in my //usr/local/lib directory
14:18:50 <Welkin> some people prefer snap (which is older than the rest)
14:19:02 <Welkin> yesod, scotty, and spock all run on Warp, a very fast http server
14:19:44 <benzrf> as far as i have seen it, yesod is a world you live in
14:19:45 <benzrf> like rails
14:20:04 <benzrf> yesod says which dirs you have and yesod says where your code goes
14:20:24 <geekosaur> then I don't know. I've had issues with the haskell sdl bindings' configure script doing odd things, it is quite possible it is ignoring extra include and lib paths :/
14:20:27 <benzrf> a Framework
14:22:10 <zachk> I've had nothing but issues with the sdl haskell bindings, would I better off switching to the more mature SDL version 1.x bindings? ... should I try adding the extra include dirs and extra lib dirs to the file.cabal or would that amount to the same thing?
14:22:54 <Welkin> zachk: SDL 1.x is obsolete
14:23:02 <Welkin> sdl 2.x is far better
14:23:08 <EvanR> 1.x man
14:23:20 <EvanR> 1.2 is one thing, but 1.1
14:23:58 <Welkin> zachk: is this for the raw sdl2 bindings on hackage?
14:26:51 <EvanR> 1.1 is an ancient version from 2000, and 2.0 was at one point known as 1.3 ;)
14:27:31 <zachk> this is for sdl2-image bindings, I have the sdl2 bindings working, though the nex version 1.2.0.0. and 1.3.0.0 broke some simple image viewer code I have.
14:27:42 <zachk> they seem to be missing some flags in the namespace
14:28:16 <EvanR> you dont really need sdlImage
14:28:16 <zachk> the latest iirc is 2.0.3
14:28:30 <EvanR> there are good haskell libraries for that
14:29:08 <arianvp___> Are there any good guides on haskell profiling etc?
14:29:09 <Welkin> zachk: you could also just use opengl for the rendering instead
14:29:12 <arianvp___> and debugging
14:29:36 <EvanR> sdl and opengl are orthogonal though, you cant set up a window with just opengl
14:30:04 <Welkin> yes, you use sdl for input and window/context creation (and perhaps audio), then opengl for rendering
14:30:20 <sdegutis> Is it better to write 4 `elem` [3,4,5,6]   or elem 4 [3,4,5,6]   ?
14:30:30 <Welkin> sdegutis: the first is preferrable for me
14:30:33 <shachaf> Whatever is clearer.
14:30:40 <shachaf> I'd probably lean toward the infix version.
14:30:46 <Welkin> if it is a binary function, I prefer to make it infix
14:30:56 <sdegutis> I just have something against back-ticks.
14:30:56 <EvanR> heh
14:30:59 <Welkin> it reads more like natural language
14:31:24 <EvanR> :t (4 `elem`)
14:31:26 <lambdabot> (Num a, Eq a) => [a] -> Bool
14:31:36 <shachaf> Well, there are some functions that I'd only use infix, like `isInfixOf`
14:31:43 <monochrom> hehe
14:31:52 <sdegutis> :|
14:32:00 * monochrom loves puns!
14:32:20 <shachaf> I'd also use `isPrefixOf` infix.
14:32:47 <arianvp___> No need for backticks
14:33:00 <arianvp___> > let a ∈ b = a `elem` b in  4 ∈ [1,2,3]
14:33:01 <lambdabot>  False
14:33:08 <arianvp___> :)
14:33:21 <EvanR> +1
14:33:35 <Welkin> now you just need a way to type the combinator
14:34:26 <EvanR> option J in mac is ∆, theres probably a way to change those kind of keys
14:34:41 <HeladoDeBrownie> ambiguity error at "type"; missing referent error at "the combinator"
14:34:57 <Welkin> the alt keybindings for mac make no sense
14:35:26 <Welkin> I would expect option D to be uppercase delta
14:35:27 <arianvp___> I used to have Emacs set up to detect LaTEX input
14:35:28 <EvanR> µ ≤ ≥ ÷
14:35:29 <monochrom> what symbol would you use for `isInfixOf`?
14:35:30 <arianvp___> \in => ∈
14:37:39 <quchen> If we've learned one thing from APL it's that requiring special keyboards to use something is an excellent idea.
14:38:34 <simukis_> quchen: compose key.
14:38:38 <HeladoDeBrownie> i would probably buy a haskell keyboard just for the novelty
14:38:39 <EvanR> http://en.wikipedia.org/wiki/Space-cadet_keyboard#mediaviewer/File:Space-cadet.jpg
14:38:56 <EvanR> roman numerals
14:40:29 <arianvp___> I like how this old keyboar has a "like" button
14:42:36 <HeladoDeBrownie> i like how it has at least five bits of modifier combinations
14:43:31 <HeladoDeBrownie> er, four
14:44:03 <HeladoDeBrownie> no i was right the first time, i just made two errors that canceled each other out :P
14:44:07 <EvanR> hyper, super, meta, ctrl, greek, alt mode, caps lock
14:44:13 <HeladoDeBrownie> don't forget shift
14:44:16 <EvanR> shift
14:44:19 <jle`> lol
14:44:30 <jle`> the like button is probably the most important part
14:44:35 <HeladoDeBrownie> i didn't know what greek was for, and i don't generally think of caps as a modifier, but that works
14:44:50 <jle`> i wouldn't mind the greek button for haskell
14:45:02 <EvanR> s/caps/shift/
14:45:13 <SrPx> is there such a function on prelude? "crop n m value = min m $ max n $ value" ?
14:45:26 <quchen> Oh wow,  traverse f >=> traverse g ≡ traverse (f >=> g).  It looked right, I tried it without thinking, it typechecked, it worked. Eureka!
14:45:26 <EvanR> greek probably types greek equivalent of roman letters
14:45:29 <jle`> vi(m) needs three keys at least to enter a greek letter unless it's macroed or something
14:45:48 <jle`> SrPx: ah the infamous sun lawsuit function :P
14:46:02 <HeladoDeBrownie> wat?
14:46:02 * hackagebot lucid 2.7.0 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-2.7.0 (ChrisDone)
14:46:04 * hackagebot drifter 0.1.0.0 - Simple schema management for arbitrary databases.  http://hackage.haskell.org/package/drifter-0.1.0.0 (andrewrademacher)
14:46:25 <SrPx> jle`: huh?
14:46:28 <jle`> oh it was oracle
14:46:44 <jle`> oracle v google
14:47:02 <jle`> oracle sued google over stealing their \n m -> min n . max n
14:47:09 <quchen> ?
14:47:29 <SrPx> jle`: what is wrong with people
14:47:37 <jle`> they say they stole their implementation
14:47:40 <EvanR> i call prior art
14:47:52 <quchen> jle`: Reference?
14:47:53 <EvanR> op amps
14:48:47 <geekosaur> old nouveau riche vs. new nouveau riche, isn't it cute
14:48:55 <jle`> http://www.i-programmer.info/news/193-android/4224-oracle-v-google-judge-is-a-programmer.html
14:49:18 <jle`> oh i guess it's slightly different
14:49:41 <sdegutis> How is it that the 'read' function doesn't return an optional? What if the thing fails?
14:50:05 <sdegutis> Dang, it uses exceptions.
14:50:28 <HeladoDeBrownie> sdegutis, yeah, it's kinda janky. try readMaybe
14:50:31 <HeladoDeBrownie> @type readMaybe
14:50:32 <lambdabot> Not in scope: ‘readMaybe’
14:50:34 <sdegutis> cool
14:50:46 <HeladoDeBrownie> @hoogle readMaybe
14:50:47 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
14:50:48 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
14:50:50 <HeladoDeBrownie> grr
14:50:58 <EvanR> read always works*
14:51:14 <jle`> sgronblo: it's in Text.Read in base
14:51:17 <EvanR> * when used on something that was Shown **
14:51:17 <sdegutis> It looks like Maybe/Just/Nothing is like OCaml's Option/Some/None
14:51:25 <sdegutis> What's with the weird names?
14:51:25 <jle`> sgronblo: mhm
14:51:26 <HeladoDeBrownie> sdegutis, yep
14:51:35 <jle`> * sdegutis
14:51:40 <sdegutis> right
14:51:56 <jle`> sdegutis: there are a bunch of partial functions in Prelude that are really sort of questionable
14:52:04 <HeladoDeBrownie> sdegutis, i don't see them as any weirder than ocaml's. gotta call them something, english names aren't always exactly perfect for these concepts
14:52:13 <sdegutis> ok then
14:52:27 <jle`> for a language where you have the potential to have the compiler catch things like partial functions, and for how much we warn users about them, Prelude has an embarassingly large amount
14:52:29 <EvanR> Maybe = + 1
14:52:48 <jle`> you mean (+1) ;D
14:53:01 <EvanR> yes in category haskell
14:53:08 <jle`> i mean, with section syntax
14:53:11 <jle`> that or (+) 1
14:53:33 <EvanR> yes
14:53:48 <liyang> What would you call Nothing and Just though?
14:54:10 <EvanR> Nothing is... 1 ;)
14:54:14 <liyang> I used to typeset them as ∘ and ∙.
14:54:21 <liyang> EvanR: not 0?
14:54:29 <EvanR> or *
14:54:31 <EvanR> or
14:55:00 <HeladoDeBrownie> Maybe a = a + 1. a + 0 would be effectively the same as a. (0 is Void)
14:55:01 <EvanR> or ()
14:55:16 <liyang> (Using "" for Just is straying into whiteboard Haskell territory...)
14:55:17 <HeladoDeBrownie> type algebra!
14:55:37 <jle`> a+0 is a because 0 is the additive identity
14:56:00 <sdegutis> Is HSpec frowned upon?
14:56:02 * hackagebot lucid 2.8.0 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-2.8.0 (ChrisDone)
14:56:04 <Bynbo7> Personally I find Some and None much better names for the constructors of a list than a Maybe/Option type
14:56:19 <glguy> I always found "Some" to be a weird name for "One"
14:56:25 <HeladoDeBrownie> data MaybeVoid a = JustVoid Void | Just a -- MaybeVoid = 0 + a
14:56:32 <Bynbo7> exactly
14:56:33 <sdegutis> glguy: its more like "something" vs "nothing"
14:56:42 <HeladoDeBrownie> the only way you can construct JustVoid is if you use bottom
14:56:54 <EvanR> Only
14:57:07 <Axman6> but "here are some things" makes much morew sense than "here is some thing"
14:57:28 <SrPx> hmms
14:57:42 <HeladoDeBrownie> sounds perfectly fine to me, maybe it's a dialectal difference
14:58:11 <HeladoDeBrownie> hmm, although i sorta think it might be something else
14:58:11 <Axman6> well, usually you's say "here is a thing", or "here is just one thing"
14:58:25 <EvanR> data Maybe a = Nothing | NotNothing a
14:58:43 <HeladoDeBrownie> sure, i guess it's a matter of what english sentence structure you're trying to approximate. "a value of this type is either nothing or some [whatever]"
14:58:45 <monochrom> consider the English sentence "the haskell concurrency book is written by some Marlow"
14:59:05 <Axman6> EvanR: that's something, I guess :P
14:59:06 <HeladoDeBrownie> monochrom, you might say it that way if you didn't know which Marlow was meant
14:59:45 <HeladoDeBrownie> similar to how i've heard people in here refer to "one of the Simons" when they didn't remember which of the Simons in question did a thing
15:00:18 <monochrom> I suggest this best of both worlds: data Option a = Nothing | Just a | NotJustButAlso a a
15:00:33 <HeladoDeBrownie> BuyOneGetOneFree a a
15:00:53 <HeladoDeBrownie> OrderInTheNextFifteenMinutesAndGet… i don't know where i'm going with this anymore
15:00:53 <EvanR> None | One a
15:00:59 <EvanR> None | One a | Two a a
15:01:02 <jle`> how about data Maybe a = Maybe [a], and have smart constructors/deconstructors to only allow one or zero elements
15:01:03 * hackagebot lucid 2.8.1 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-2.8.1 (ChrisDone)
15:01:10 <jle`> but then what do we name the smart constructors...
15:01:21 <monochrom> OrderInTheNextFifteenMinutesAndGet (Int -> a) :)
15:01:22 <mrlami> so i want to be smart like you haskell folks but i'll need a lot of help as I'm coming from OOP
15:01:26 <HeladoDeBrownie> jle`, doesn't that lose you important reasoning power?
15:01:36 <jle`> HeladoDeBrownie: not with smart constructors :D
15:01:52 <jle`> mrlami: we are normal people :D
15:01:56 <mrlami> any ideas on how to go (e.g. read this article first, then learn basic constructs from here, then build something)
15:01:59 <jle`> mrlami: not necessarily smarter than any :D
15:02:04 <monochrom> people coming from OOP are smart, too. since OOP is not exactly easy.
15:02:06 <jle`> @where learnhaskell
15:02:06 <lambdabot> https://github.com/bitemyapp/learnhaskell
15:02:13 <jle`> OOP require smuch more intelligence than haskell does
15:02:15 <jle`> trust me on this one
15:02:17 <AleksejsHome> @where lyah
15:02:17 <lambdabot> http://www.learnyouahaskell.com/
15:02:32 <jle`> try writing something in OOP and then maintaining it and then leaving it for a few months and coming back
15:02:43 <jle`> haskell is nice because it allows you to be stupid
15:02:49 <jle`> and it'll take care of it all for you
15:02:49 <HeladoDeBrownie> i think my dissatisfaction with lyah has reached the tipping point and now i just recommend learnhaskell every time
15:03:31 <zachk> any ideas to what I should try on getting sdl2-image working?
15:04:18 <tasker> What are my options for long running, infrequent tasks? E.g. a webscraper that should scrape a page every 10 minutes.
15:04:29 <Welkin> jle`: using OOP puts your intelligence into question
15:04:58 <Welkin> many people who thought it would be useful later realized it was totally useless
15:05:19 <Welkin> even Bjarne Stroustrup
15:05:25 <mrlami> jle` which might be why it'll be harder to pick up haskell.  Anyways it's my project for the weekend to dive headin
15:05:29 <jle`> yes but doing a very hard and difficult thing very well is always something impressive
15:05:30 <kadoban> tasker: Sounds like a good use for cron or something similar.
15:05:31 <mrlami> or headon
15:05:31 <HeladoDeBrownie> Welkin, there may be some sort of popularity bias involved. either way, i don't think it's wise to disparage the users of a paradigm, even if flaws can be demonstrated in the paradigm itself.
15:05:41 <monochrom> I like putting my intelligence into question. what doesn't kill me makes me stronger.
15:05:53 <tasker> kadoban: I suppose that is true. Was just wondering if there were some haskell-based solution.
15:06:03 * hackagebot readable 0.3.0.1 - Reading from Text and ByteString  http://hackage.haskell.org/package/readable-0.3.0.1 (DougBeardsley)
15:06:09 <jle`> i'm still impressed with blind folded rubiks cube solves
15:06:57 <benmachine> I'm still impressed with rubik's cube solves :(
15:07:09 <HeladoDeBrownie> i can solve a 2×2×2
15:07:09 <EvanR> its just a finite group!
15:07:21 <jle`> to me the experience feels like the similar thing where you dream a dream where you fully live out ten years in one night
15:07:27 <jle`> and wake up and find out that only one night had passed
15:07:28 <HeladoDeBrownie> i've also discovered that knowing what a group is doesn't help much with solving group-based puzzles
15:07:33 <monochrom> I am impressed with rubik's cube solver machines
15:07:47 <Axman6> made form lego
15:07:47 <hpc> i am groot
15:08:03 <monochrom> and a Turing machine built from Lego bricks and whiteboard markers
15:08:21 <jle`> how about a turing machine built from organic molecules
15:08:23 <monochrom> and yeah, a rubik's cube solver machine built from Lego bricks
15:08:27 <HeladoDeBrownie> imagine an infinite-dimensional rubik's cube…
15:09:07 <monochrom> I am impressed by my article pipe-dreaming on a G-machine built from organic molecules.
15:09:44 <geekosaur> examining the STG with an STM?
15:09:47 <monochrom> the most impressive sentence is "to add more memory, just buy and pour one more can of Campbell's soup"
15:10:24 <mrlami> HeladoDeBrownie is this what you are recommending? https://github.com/bitemyapp/learnhaskell
15:10:27 <jle`> sounds like it doesn't scale very well
15:10:37 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/22537/
15:10:45 <HeladoDeBrownie> mrlami, yeah, i would've linked it but it had just been linked
15:11:49 <jle`> monochrom: nice
15:11:56 <monochrom> :)
15:12:14 <HeladoDeBrownie> i was trying to remember where i'd read that, i had no recollection it was you who had written it
15:12:24 <sw17ch> In a cabal file, is there a good way to say with the data-dir directive “use *all* the files found in this directory” rather than having to state the directort then also state each individual file in data-files?
15:12:41 <mrlami> HeladoDeBrownie it recommends lyah as well.  It should be a fun weekend
15:12:47 <sw17ch> i have close to 70 files and it’s getting really cumbersome
15:12:54 <sw17ch> 70 non-haskell files
15:12:59 <jle`> mrlami: where do you live where weekend is coming up soon
15:13:01 <HeladoDeBrownie> mrlami, it recommends it only in a specific case, and the author recommends lyah in general only grudgingly.
15:13:03 <jle`> and how can i move there
15:13:16 <dcoutts_> sw17ch: you can use a limited form of wildcards
15:13:24 <sw17ch> dcoutts_: can i?
15:13:25 <HeladoDeBrownie> mrlami, the phrase "pedagogically unsound" has been used to accurately describe lyah
15:13:36 <dcoutts_> sw17ch: e.g. data/*.png
15:13:50 <jle`> watching lyah's ongoing fall from grace has been interesting
15:13:59 <sw17ch> dcoutts_: that’s certainly helpful. is that in the data-files: or data-dir line?
15:14:12 <dcoutts_> sw17ch: data files
15:14:24 <dcoutts_> sw17ch: the data-dir is the root of the data files
15:14:28 <geekosaur> people finally noticed that people going through lyah didn't seem to be understanding haskell as a result
15:14:35 <EvanR> the maintainer of lyah last seen boarding a plane to thailand with a suitcase full of cash
15:14:44 <geekosaur> I'd noticed that myself, and I think grumped in here about it at one point
15:14:47 <mrlami> HeladoDeBrownie should i run away from fpcomplete.com/school/starting-with-haskell/haskell-fast-hard
15:15:02 <geekosaur> having read through one section that someone was confused by, and realized it was superficial at best
15:15:02 <jle`> maintainer of lyah actually vanished shortly after it was published i believe
15:15:03 <mrlami> and http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html
15:15:18 <jle`> so maybe they knew the future
15:15:24 <mrlami> jle` wow... should i stay of lyah then
15:15:35 <mrlami> nothing worse that starting out confused
15:15:38 <chirpsalot> The wikibook is really good.
15:15:49 <jle`> well...i can't say too much bad about it because it was *my* personal journey to haskell
15:16:01 <jle`> it was my first text and i came out of it without too much confusion
15:16:10 <mrlami> haha
15:16:12 <jle`> but there are some serious issues with it i believe
15:16:26 <sw17ch> dcoutts_: “wildcareds are only allowed in place of the file name, not the directory name or file extension” :(
15:16:26 <jle`> there is a guide on that webpage that has been linked that has a good explanation on everything and why :)
15:16:28 <HeladoDeBrownie> mrlami, i only have strong opinions about lyah, and know somewhat less about the other introductory materials. (i myself used lyah for my introduction)
15:17:07 <HeladoDeBrownie> but as far as i've checked, the learnhaskell recommendations are sound
15:17:09 <jle`> lyah has been the go-to first book for an entire generaiton of haskell users
15:17:19 <jle`> so i wonder what this new generation/era will look like
15:17:20 <dcoutts_> sw17ch: I did say a limited form of wildcards
15:17:37 <sw17ch> dcoutts_: you did :) that’s rather limited.
15:17:40 <chirpsalot> I think LYAH does a good job of getting people excited, at least.
15:17:45 <jle`> we soon approach a post-lyah world
15:17:56 * geekosaur started via the Gentle Introduction... but had already some experience with FP and in particular had previously learned to read SML out of necessity
15:17:57 <sw17ch> dcoutts_: oh, it insists on a file extension… i just can’t do *
15:18:03 <sw17ch> so *.c works
15:18:05 <HeladoDeBrownie> jle`, i'm excited to see what it will be like. what about the world post-do-i-need-to-know-monads?
15:18:09 <sw17ch> even with a directory prefix
15:18:16 <HeladoDeBrownie> jle`, … and will we ever see such a world? :P
15:18:25 <jle`> i hope so :|
15:18:32 <dcoutts_> sw17ch: sure, *.c is fine.
15:18:43 <monochrom> we are about to enter do-I-need-to-know-Applicative
15:19:06 <jle`> heh
15:20:43 <IP92> which one would you suggest more for a beginner, learn you a haskell real good or real world haskell?
15:20:44 <sw17ch> dcoutts_: thanks for the help!
15:20:53 <dcoutts_> np
15:20:55 <sw17ch> dcoutts_: that saved me about 90 lines
15:21:02 <dcoutts_> sw17ch: great
15:21:15 <zachk> ip92: do you know other programming languages? real world haskell generally assumes that iirc
15:21:22 <Welkin> I started with LYAH as well
15:21:36 <IP92> zachk: I know python, java and some C
15:21:42 <Welkin> it certainly has problems, but it made haskell easier to get into
15:22:17 <IP92> do either of them have exercises for every topic or something of the sort?
15:24:21 <Welkin> LYAH has a few trivial exercises that it walks you through
15:24:29 <Welkin> the UPenn course is great for exercises
15:24:29 <levi> This course material includes some fun exercises: http://www.seas.upenn.edu/~cis194/spring13/index.html
15:24:56 <levi> That's the UPenn course.
15:25:11 <Welkin> I also used project euler for haskell exercises
15:30:33 <awestroke> https://imgur.com/a/tiW5S - if anyone hadn't seen it yet
15:31:30 <monochrom> :)
16:03:04 <arianvp___> So I want to port a major java codebase to haskell. It's a server for a large MMO.  What libraries should I look at?  STM is defenitely one im gonna use
16:03:30 <marrrk> Hello! What editor do you use?
16:03:31 <arianvp___> Was looking at pipes. but wondering how useful that is in a very stateful context..
16:04:09 <mmachenry> arianvp___: You might consider writing your TCP communication using Conduit with the conduit-network library and forking off concurrent processes with the async library.
16:04:25 <HeladoDeBrownie> arianvp___: concurrent, async, network, pipes-concurrency possibly
16:04:35 <mmachenry> marrrk: Everyone here uses yi, no exceptions. It's the Haskell channel :)
16:04:40 <Cale> arianvp___: pipes is specifically designed for things like I/O, and is abstracted over a choice of monad
16:04:55 <HeladoDeBrownie> s/concurrent/concurrency/
16:04:59 <Cale> marrrk: I use vim or gobby or gedit
16:05:06 <mmachenry> Actually I'd love to hear discussion about using Conduit vs Pipes for network IO.
16:05:11 * HeladoDeBrownie has no experience with mmos but imagines they're much like other network applications
16:05:27 <marrrk> I will look at yi, I would like something with VIM keybindings.
16:05:28 <Cale> marrrk: I've used emacs as well in the past. I don't really care what editor I'm using so long as it can convert tabs to spaces for me automatically
16:05:33 <mmachenry> I recently started using Conduit but I didn't really compare the to fully. I just saw a talk by Michael Snoyman.
16:05:38 <Cale> and it does a little bit of syntax highlighting
16:05:46 <mmachenry> marrrk: I was kidding.
16:05:52 <marrrk> What about IDE?
16:05:58 <arianvp___> I see. I'm really interested in this project.  The old codebase is heavily object oriented and very stateful.
16:05:59 <mmachenry> marrrk: Have you tried VIM? That has VIM keybindings.
16:06:05 * hackagebot seqid 0.2.0 - Sequence ID production and consumption  http://hackage.haskell.org/package/seqid-0.2.0 (LukeHoersten)
16:06:07 * hackagebot seqid-streams 0.2.0 - Sequence ID IO-Streams  http://hackage.haskell.org/package/seqid-streams-0.2.0 (LukeHoersten)
16:06:10 <Cale> My IDE is keeping an editor window open alongside a terminal window with ghci open in it
16:06:37 <Cale> Maybe a third terminal for dealing with darcs/git
16:06:41 <Cale> :)
16:06:58 <marrrk> Cale: For a beginner like me to quickly "debug" what is happening are there some tricks? I have seen "trace" somewhere.
16:07:07 <arianvp___> I use guake terminal to simply have a quake-style terminal when I need it + a fullscreen vim
16:07:20 <Cale> Yeah, there's Debug.Trace.trace
16:07:25 <Cale> :t Debug.Trace.trace
16:07:26 <lambdabot> String -> a -> a
16:07:30 <arianvp___> in the guake terminal I have a tab for  git, a tab for ghci and a tab for other stuff
16:07:36 <amyers> Is there an efficient way of getting a substring from a ByteString at a specific index + length?
16:07:40 <arianvp___> that's basically my IDE setup
16:07:57 <Cale> When the trace expression is evaluated, it causes the given string to be printed to the terminal.
16:08:10 <marrrk> I would love to have some help for automatically importing things like Debug.Trace.trace, so I don't need to remember the namespace (is that what it's called?).
16:08:18 <amyers> Hoogle isn't turning up anything
16:08:23 <Cale> @hoogle trace
16:08:24 <lambdabot> Debug.Trace trace :: String -> a -> a
16:08:24 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
16:08:24 <lambdabot> package trace-call
16:08:46 <Cale> amyers: um, you can use drop and take, no?
16:08:58 <arianvp___> HeladoDeBrownie: async seems nice
16:09:08 <amyers> Cale, Yeah, I wasn't sure if that would give me linear time cost.  Can I rely on that fusing away?
16:09:10 <marrrk> Cale: How do you hoogle outside of this irc?
16:09:15 <mmachenry> arianvp___: You probably should use async.
16:09:27 <arianvp___> Are there any big server projects I can look at? warp caught my eye
16:09:30 <Cale> amyers: It'll definitely give you linear time cost
16:09:42 <mmachenry> marrrk: https://www.haskell.org/hoogle/
16:09:43 <arianvp___> but also some other stuff with more state involved. dunno. an FTP implemntation or something?
16:09:46 <Cale> amyers: But that's the fastest possible cost for such an operation
16:10:17 <arianvp___> @hackage ftphs
16:10:18 <lambdabot> http://hackage.haskell.org/package/ftphs
16:10:44 <amyers> Cale, Why is that?  Couldn't it just copy the relevant bytes out of the middle with random access?
16:10:51 <Cale> oh, no, actually, if they're strict bytestrings, it's O(1)
16:11:03 <amyers> Cale, Ah, yes they're strict
16:11:19 <Cale> If it copies the bytes, it's O(n)
16:11:37 <HeladoDeBrownie> arianvp___, if nothing else i think you'll like race_ from it
16:11:42 <amyers> Cale, not O(k) where k is the size of the substring?
16:11:47 <Cale> But strict bytestrings include a pointer to the start and a length as part of their internal data
16:12:20 <Cale> So, it can just construct a new bytestring with a pointer to the same chunk of memory but with different start index and length
16:12:37 <Cale> drop  :: Int -> ByteString -> ByteString
16:12:37 <Cale> drop n ps@(PS x s l)
16:12:37 <Cale>     | n <= 0    = ps
16:12:37 <Cale>     | n >= l    = empty
16:12:38 <Cale>     | otherwise = PS x (s+n) (l-n)
16:12:58 <amyers> Cale, okay, that's pretty much what I was expecting/looking for.  I wasn't sure if I could rely on take/drop giving me O(1) time
16:13:10 <arianvp___> oh sweet
16:13:13 <amyers> Cale, ah, that makes perfect sense, dur :p
16:13:26 <amyers> Cale, Thanks!
16:13:40 <Cale> With lazy bytestrings, a bit more work is required, because they're a linked list of strict bytestring chunks
16:13:43 <mmachenry> arianvp___: http://chimera.labs.oreilly.com/books/1230000000929
16:13:54 <mmachenry> Worth reading for what you're doing.
16:14:19 <toblerone> Anyone have any luck getting the LLVM backend working on OSX?
16:14:33 <Cale> So, it'll be O(c) where c is the total number of chunks between the start of the original bytestring and the end of the requested region.
16:14:52 <arianvp___> I guess so! nice.
16:15:21 <timpani> I vaguely remember being able to do something like "type (Monad m) => G m = ...", but ghci is not having it. Am I misremembering? Is there a pragma to allow this?
16:15:34 <EvanR> convenient how you can change the units at will with big-O hand waving ;)
16:15:51 <tapuu> timpani: I think that is impredicativetypes
16:16:07 <shachaf> timpani: No, that was never allowed.
16:16:19 <shachaf> timpani: It used to be allowed with data/newtype, but it was taken out because it was useless.
16:16:20 <tapuu> okay maybe not
16:16:47 <timpani> thanks all the same...
16:18:46 <toblerone> Just to clarify, to use the LLVM backend GHC looks for "opt" and "llc" somewhere on in the path, correct?
16:20:36 <tasker> Is there any way to get around having to expose all modules if you want to use an executable in the same cabal file ?
16:20:53 <tasker> Ohh, or can I just put them in other modules ?
16:21:02 <HeladoDeBrownie> tasker, i didn't catch your meaning.
16:21:59 <tasker> HeladoDeBrownie: Say I have a library in a cabal file. I want to make an executable using some part of this lib. I expose the only module that I want people to use - but then there are errors about "Undefined symbols for architecture x86_64" when I cabal build.
16:22:38 <rasen> other modules should do the work
16:22:42 <rasen> I believe
16:23:41 <tasker> rasen: Can confirm that this is the case :)
16:24:57 <Cale> arianvp___: btw, which MMO? :D
16:25:11 <arianvp___> Cale: Haha can't tell. sorry
16:25:34 <Cale> arianvp___: Hopefully someday then. It's always interesting to hear about new commercial users of Haskell.
16:26:34 <arianvp___> At this phace it's obviously still totally R&D
16:27:11 <lw> Hey guys, shoild I start with "learn you a haskell" for, well, learning haskell?
16:27:17 <lw> I mean, is it a good book?
16:27:21 <arianvp___> lw: I started with it. I found it enjoyable
16:27:37 <arianvp___> It's well-written
16:27:47 <HeladoDeBrownie> lw, i would recommend checking out the following:
16:27:49 <HeladoDeBrownie> @where learnhaskell
16:27:49 <lambdabot> https://github.com/bitemyapp/learnhaskell
16:27:55 <arianvp___> There are a few little things that aren't up to date
16:28:45 <lw> thanks! Gonna start reading it then.
16:29:16 <HeladoDeBrownie> with respect, i think that understates the problems with it. fortunately, if you do find issues with it, there are other resources
16:29:39 <rasen> lw: Check out this SO answer http://stackoverflow.com/a/1016986/2538771
16:34:15 <Cale> I don't know how I feel about RWH now. It filled a hole in the space of books at the time, but I feel like a lot of what it covers is doomed to be outdated quickly. Then again, I haven't gone back over it recently to see by how much :)
16:34:57 <HeladoDeBrownie> i wonder how hard it would be to write modern replacements for the seemingly outdated learning materials
16:35:07 <geekosaur> rwh at least has a wiki that tries to fill in the updates
16:35:21 <HeladoDeBrownie> i would contribute to the effort if i could convince myself that my contributions were worth something
16:35:33 <geekosaur> although it doesn't help that the authors seem to have backed away :(
16:35:35 <HeladoDeBrownie> but it's hard to know when something is effective or not
16:35:42 <Cale> It's somewhat amazing that "All About Monads" is still a thing. That's one of the older tutorials out there, and probably could be improved upon a lot.
16:35:47 <rasen> Cale: Personally, I started with LYAHFGG but after a while I got stuck and quit for a year or two. Continued to learn Haskell with Real World Haskell and it was fine. Anyway, it gives enough info so that you can learn what's new by yourself
16:36:05 <Cale> Cool
16:37:48 <bshelden> The only thing I'd worry about is it's not exactly obvious what's outdated.
16:38:09 <bshelden> A resource "Modern Haskell for RWH Veterans" would be useful.
16:39:20 <EvanR> or refrugees
16:39:29 <EvanR> refudiated
16:39:32 <rasen> bshelden: It's true. 10 minutes ago I didn't know RWH is outdated :)
16:39:43 <HeladoDeBrownie> i seemed to recall learning useful, up-to-date things from rwh, but it's possible i was confusing it with parallel & concurrent
16:40:47 <jle`> <3 parallel & concurrent haskell
16:40:50 <jle`> it was my second haskell text
16:41:05 <jle`> and it taught me a lot about approaching problems in a haskelly way
16:41:24 <arianvp___> jle`: Yeh I'm totally gonna start reading it
16:41:28 <rasen> Reading it now. Really nice book
16:41:34 <arianvp___> Though I might skip to the concurrency chapter
16:41:37 <arianvp___> are they disjoint?
16:41:39 <Cale> Also, the space of libraries is so broad now, that it's getting hard to say what "modern haskell" looks like. There are things like lenses and pipes which if you lean hard on them can make your code look really different.
16:41:59 <jle`> arianvp___: what i learned from it wasn't necessarly about parallel and concurrency
16:42:05 <jle`> arianvp___: just the problem solving approaches in general
16:42:10 <jle`> pallelism and cocurrency
16:42:23 <rasen> arianvp___: yep. you can start from concurrency right away
16:42:27 <jle`> i think you wouldn't be too lost by jumping to the concurrency part
16:42:54 <Cale> arianvp___: Are you talking about Simon Marlow's book?
16:43:31 <arianvp___> Cale: yes
16:43:50 <Cale> arianvp___: There's some stuff in the early parts of that book which actually are beneficial just for understanding how to write efficient single threaded non-parallel haskell code
16:44:04 <Cale> But yeah, you can basically start with concurrency :)
16:44:23 <jle`> the entire book is beneficial, but if you start at concurrency you won't be lost because of some prerequesite knowledge only explained in the parallelism part
16:44:39 <rasen> arianvp___: The only thing, it's better to read parallel part before chapter 13
16:45:40 <arianvp___> It seems to cover some topics in which I currently lack knowledge.   Stuff like exception handling and debugging and tuning
16:45:42 <arianvp___> nice
16:45:43 <Cale> At some point I should really try using distributed-process for something. Maybe I need to make some kind of multiplayer game just to have an excuse :)
16:45:53 <arianvp___> :D
16:46:26 <arianvp___> https://ghc.haskell.org/trac/ghc/blog/simonpj/StaticPointers
16:46:27 <HeladoDeBrownie> i'm wrestling with mental disorders while trying to make progress on my multiplayer game. it makes it way harder than it needs to be
16:46:30 <augur> anyone intimately familiar with compilers, linking, cabal-y stuff, etc. willing to chat a little bit?
16:46:33 <thetallguy> Does anyone know a method for statically ensuring two or more types are not equal in Haskell?
16:46:45 <augur> not problem solve, just chat. im curious about how certain things work
16:46:52 <arianvp___> This seems awesome as well
16:47:03 <EvanR> HeladoDeBrownie: haskell does that to people
16:47:11 <HeladoDeBrownie> EvanR, nah, it's not the haskell :P
16:47:24 <HeladoDeBrownie> haskell is great and makes it easier as far as i can tell
16:47:36 <EvanR> haskell therapy
16:47:50 <rasen> augur: I'm experienced with compilers/linking/other stuff but in general, not Haskell specific
16:47:57 <arianvp___> Haskell is good therapy for me. Makes me think hard
16:48:17 <monochrom> Cale: the game of "byzantine generals" is very distributed and very byzantine :)
16:48:50 <augur> rasen: well you might know, or you might not. lets give it a go!
16:49:13 <Cale> monochrom: heh
16:49:33 <augur> it seems like compiling packages in haskell (and maybe other languages?) is really obnoxiously problematic because of version conflicts
16:49:48 <arianvp___> augur: I'd benefit of such a discussion.  I know how to set up basic cabal projects. but I hit my head hard with advanced stuff
16:49:50 <augur> its not clear to me what it means to say that you've compiled a package "against" another package
16:50:47 <augur> like, if package-1 depends on package-2, and you upgrade from package-2-v-1 to package-2-v-2 why does package-1 have to recompile against the new version
16:50:55 <bitemyapp> augur: Cabal bothers to enforce package range compatibility, including for transitive dependencies.
16:50:56 <augur> this seems highly anti-modular
16:51:02 <bitemyapp> augur: the problem is not solved in other communities, it is avoided.
16:51:14 <Cale> augur: Part of the problem in Haskell's case is that it's impossible to have more than one version of any given package-version combination installed at once. So if you need the same package-version, but compiled against different dependencies, then when the new one built against that different dependency set is installed, existing things depending on that package end up breaking.
16:51:18 <bitemyapp> augur: modularity is not the top priority of Haskell's design (cf. separate compilation vs. whole-program)
16:51:26 <augur> Cale: right i get this but hold on
16:51:36 <augur> Cale: what is this "compile against" business
16:51:51 <monochrom> code optimization conflicts with separability
16:52:03 <Cale> augur: Well, maybe the implementations of data types have changed, for example.
16:52:23 <augur> Cale: i see, so this goes back to haskell not having proper modules with interfaces
16:52:41 <bitemyapp> augur: not really, no.
16:52:46 <Cale> augur: Let's suppose we have packages A, B, and C with B depending on A, and C depending on both B and A.
16:52:54 <monochrom> this conflict is less bad for low-level languages (where you don't use any abstraction anyway), and is very prominent for high-level languages (where you use crazy abstractions that run slow if you gen code naively)
16:53:08 <bitemyapp> augur: we don't get to have a polymorphic numeric tower and good performance at the same time without using typeclasses and whole program optimization. Adding modules to Haskell doesn't change this.
16:53:10 <Cale> augur: Suppose that we have some data type A.T
16:53:10 <augur> Cale: sure, im reading the old sandbox intro
16:53:17 <bitemyapp> augur: it doesn't change the performance story for a lot of related problems either.
16:53:29 <EvanR> uhg "numeric tower"
16:53:31 <augur> Cale: ok
16:53:43 <bitemyapp> EvanR: if you want me to use different terminology
16:53:52 <EvanR> no, i get it
16:53:57 <monochrom> numeric garden :)
16:54:08 <bitemyapp> EvanR: tell me what you prefer. "ugh" serves no purpose but your desire to express disgust.
16:54:10 <EvanR> numeric zoo, numeric circus
16:54:29 <bitemyapp> EvanR: this is making it less likely I'll take your next request seriously.
16:54:36 <EvanR> request?
16:54:40 <bitemyapp> suggestion
16:54:41 <bitemyapp> whatever
16:54:46 <Cale> ... just trying to think if I have the right example here :)
16:54:54 <augur> Cale: no worries :p
16:55:17 <bitemyapp> augur: being able to make Cale pause to think is an accomplishment.
16:55:19 <Cale> Let's suppose that B doesn't rely in any fashion on the internal specification of that type A.T, *but* that type's constructors are exposed so that things might depend on it. So B will still compile, even if A.T's implementation changes
16:55:49 <augur> bitemyapp: i work hard on being profoundly stupifying :)
16:55:57 <bitemyapp> augur: stupefying
16:56:01 <augur> that too
16:56:10 <bitemyapp> only that.
16:56:17 <Cale> I'm trying to think of a reasonable way in which things get broken
16:56:21 <monochrom> wait, there is such a word?
16:56:32 <Cale> monochrom: Stupefying is a word
16:57:03 <bitemyapp> monochrom: stupefying is a word, what augur wrote is not.
16:57:04 <augur> Cale: right so the issue is that different packages might depend on the implementation details of other packages
16:57:11 <arianvp___> So. reading the first chapter of Concurrent haskell. concurrency is already a better love story in haskell than in java
16:57:13 <monochrom> haha, now I'm stupefied too :)
16:57:20 <bitemyapp> augur: which is necessary in many cases, particularly performance sensitive ones.
16:57:25 <augur> monochrom: bitemyapp is correct, and in a way that doesnt matter ;)
16:57:47 <augur> bitemyapp: mm.. ok
16:57:50 <bitemyapp> augur: modularity uber alles does not work everywhere for all cases.
16:58:03 <Cale> augur: Yeah, and which exact details they rely on and don't will affect whether it's okay to use them together.
16:58:07 <rasen> augur: Basically, building against some library means making your compiled module be consistent with that other module's interface (data structures, functions). If that interface changes somehow, you'll run in strange problems until you rebuild your module against that newer library.
16:58:13 <bitemyapp> augur: if you don't believe me, write something with inlinable typeclass instances and then rewrite it with record of functions. Bench it.
16:58:28 <augur> so what im thinking of Cale, bitemyapp, is: with proper elims in a dependent lang, and good support for them ala Epigram, you can code with "constructors" that dont exist
16:58:37 <bitemyapp> augur:
16:58:51 <bitemyapp> augur: we're not writing in an dependently typed language with eliminators.
16:58:54 <augur> in fact, the whole basis of modularity is an existential type exposing some "constructors" and an associated induction principle
16:59:03 <augur> bitemyapp: yes i know, but we should be ;)
16:59:07 <bitemyapp> augur: not really no.
16:59:09 <augur> but i think haskell doesnt need to be for this
16:59:32 <augur> maybe it does, i dont know, im just trying to pin down the issue, and then connect it up with other solutions
16:59:33 <EvanR> arianvp___: well, ignoring performance, theres some interesting semantic subtleties in java and in haskell. like cooperation vs async exceptions
16:59:36 <Cale> Well, I think I agree that we should be, but I'm not sure if I really understand how this solves the problem
17:00:11 <augur> Cale: well you creat a massive abstraction barrier where you can change your implementations and no one needs to be the wiser
17:00:11 <monochrom> perhaps it makes the problem even harder
17:00:35 <Cale> augur: Well, you can do that anyway, if you're careful.
17:00:42 <geekosaur> abstraction barriers like that have runtime costs
17:00:50 <Cale> augur: I'm not sure if it's productive to enforce it?
17:01:01 <augur> Cale: because your programs dont rely on the implementations per se, but rather on the interfaces. you still pattern match, etc etc as if you have a particular implementation, but no actual implementation
17:01:12 <Cale> Maybe it would solve some big problems, but it would create a lot of small ones :)
17:01:28 <rasen> The problem is, interfaces change over time.
17:01:30 <augur> geekosaur: well they dont have to tho maybe? what im thinking is, the barriers exist for the programmer, not the compiler
17:01:50 <bitemyapp> augur: that doesn't solve all performance problems.
17:02:02 <geekosaur> augur: if you figure out a way to do that withut runtime cost, let us know
17:02:02 <bitemyapp> augur: separate compilation means not being able to inline and further optimize code.
17:02:10 <EvanR> rasen: you could pick interfaces that are so simple they basically cant change
17:02:11 <bitemyapp> augur: it doesn't matter you eliminated some unnecessary constructors.
17:02:11 <augur> oh no im not thinking about separate compilation here
17:02:30 <augur> im saying use this to enforce separate programming, but then do unified compilation
17:02:31 <Cale> Oh yeah, part of the issue here is that when linking modules together, there's inlining that takes place at that level.
17:02:54 <geekosaur> the call site must make a call compatible with some interface. if the interface changes, how do you propose to have the generated code adjust itself?
17:03:14 <geekosaur> the issue is not with what the programmer is doing
17:03:24 <augur> geekosaur: but it is
17:03:28 <geekosaur> no
17:03:29 <augur> thats the whole point
17:03:31 <geekosaur> no
17:03:33 <augur> yes
17:03:35 <augur> look
17:03:46 <augur> the person who wrote module A wrote it depending on implementation details of module B
17:03:56 <monochrom> naw, no one does that
17:04:01 <_1_alexfootball> hello
17:04:05 <augur> well cale seems to think otherwise
17:04:08 <HeladoDeBrownie> _1_alexfootball, hey
17:04:08 <geekosaur> I don't know what point you think you are chasing, but the problem with module linking betrween different versions is that module interfaces change in ways that affect generated code
17:04:13 <rasen> augur: actually, that's mostly compiler's problem. Compiler makes it really dependent on module B implemantation
17:04:13 <monochrom> the compiler who compiled module A compiled it depending on compiled code of B
17:04:17 <Cale> augur: Er, what?
17:04:21 <_1_alexfootball> what's up
17:04:22 <geekosaur> hiding this from the programmer is simple. hiding it from already generated code is not
17:04:24 <Cale> augur: My dependencies went the other way :)
17:04:40 <augur> Cale: whatever, point is that one module needs to know the implementation of another :P
17:05:22 <monochrom> I think this is a good time to conclude "we agree to disagree" and adjourn the discussion.
17:05:43 <HeladoDeBrownie> _1_alexfootball, haskell is up! need some help with something?
17:05:50 <Cale> augur: Well, the already compiled code is what it is... not being able to depend on certain things regarding the layout of structures in memory is going to come along with some pretty serious costs.
17:06:29 <augur> Cale: im not sure i understand
17:06:42 <bitemyapp> augur: do you understand why npm is able to do what it does?
17:06:46 <rasen> augur: Do you now C or C++?
17:06:53 <bitemyapp> augur: once you answer that question for yourself, you'll be able to understand the implications of what Cale just said.
17:06:55 <augur> rasen: not if i dont have to :)
17:07:02 <_1_alexfootball> Ok what
17:07:07 <monochrom> no, even C and C++ is not enough. you have to know assembly. bloody machine code.
17:07:16 <bitemyapp> augur: it is much easier to understand why npm can get away with some stuff we cannot than it is to understand struct memory layout.
17:07:30 <augur> bitemyapp: i dont know what you're on about
17:07:38 <bitemyapp> augur: I'm trying to help you understand what Cale said.
17:08:08 <augur> bitemyapp: i appreciate the effort but its not helping
17:08:13 <bitemyapp> augur: okay, I'll give you the short of it: if you try to use code compiled for an incompatible datatype representation, your program go boom-boom segfault
17:08:17 <rasen> augur: there is webpage that describe the same problem in the context of C++ https://techbase.kde.org/Policies/Binary_Compatibility_Issues_With_C++
17:08:20 <monochrom> is "www.npmjs.com" the website I should look for npm?
17:08:27 <bitemyapp> augur: boom-boom segfault ~ bottom for your purposes
17:08:35 <bitemyapp> augur: you don't want surprise-bottom boom-boom in your Haskell codey-codes right?
17:08:52 <geekosaur> augur: I compile against a module which has a data value with something at offset 4. the next version of that module moves it to offset 8. the programmer does not ever see this in Haskell. the generated code *knows* the offset is 4. how does it adapt to it moving to offset 8 with zero runtime cost?
17:09:07 <HeladoDeBrownie> _1_alexfootball, hrm? i mean, you're free to idle here, but usually people who greet have a question or something
17:09:42 <shachaf> bitemyapp: You're being very patronizing and unpleasant here.
17:09:46 <geekosaur> this is why focusing on the programmer is pointless, the question is with the existing compiled code
17:10:10 <augur> coming from shachaf, who has me on ignore and hates my guts, that saying something
17:10:28 <bitemyapp> augur: I was already going for a simple explanation (npm) that didn't require understanding of the machine model.
17:10:32 <geekosaur> bitemyapp, augur does not understand some details of where programs meet hardware. that does not make them a 3 year old
17:10:33 <bitemyapp> augur: do you know any JS?
17:10:45 <bitemyapp> geekosaur: look at the convo.
17:10:52 <geekosaur> I have been
17:10:55 <bitemyapp> geekosaur: I was politely proffering an explanation that didn't require hardware/asm knowledge
17:11:13 <geekosaur> "boom-boom codey-codes"?
17:11:14 <augur> Cale: so i guess im not sure why this matters. i mean, if you have Av1 and Bv1 with A depending on B, where Av1 works really nicely with Bv1's implementation, ...
17:11:16 <bitemyapp> that was blithely handwaved without so much as an attempt at engaging with it.
17:11:20 <bitemyapp> geekosaur: "npm"
17:11:32 <monochrom> no, I think they're referring to "boom-boom" and "codey-codes"
17:11:38 <augur> Cale: and then you make Bv2 with a different implementation that makes Av1 slow, i get that this can happen
17:11:41 <shachaf> I've looked at the conversation and your behavior is unacceptable.
17:11:46 <geekosaur> bitemyapp, the fact that you said those things is significant
17:11:55 <shachaf> If the explanation isn't working out for you, you're free to stop the conversation.
17:11:59 <geekosaur> don't treat people like idiots in channel
17:12:10 <bitemyapp> augur: I apologize for the condescension.
17:12:19 <EvanR> yes please treat people like idiots in pm
17:12:20 <rasen> augur: It doesn't make Av1 slow. It makes it now working
17:12:31 <geekosaur> it's more that nobody has control over that situation
17:12:32 <bitemyapp> augur: I mentioned npm because they can get away with essentially vendoring the code on a per-library-version basis
17:12:36 <monochrom> ahem, EvanR.
17:12:44 <augur> rasen: it ought not to given proper abstraction barriers tho, this is what im saying
17:12:46 <bitemyapp> augur: but this only works because the object representation will never change (JS objects)
17:12:56 <shachaf> For what it's worth I think this discussion has outlived #haskell in the first place. It could be better in #haskell-overflow or #haskell-unpleasantness or something.
17:12:58 <augur> i mean, if you change the interface, sure
17:13:07 <bitemyapp> shachaf: you've made snide comments in the past and refused to reply when I asked you to clarify.
17:13:12 <geekosaur> I can't stop someone from being insulting in private, but I can at least attempt to keep public discourse at a somewhat higher level
17:13:44 <solatis> how is haskell development under windows? i never tried it, but i'm considering switching my desktop from linux to windows
17:13:47 <rasen> augur: yeah. But building abstraction barrier will imply building it for compiling (disabling inlining/other cool stuff) and will make application reallo slower
17:13:59 <solatis> since the heavy involvement of MS in haskell development, i expect it to be pretty mature ?
17:14:11 <shachaf> bitemyapp: OK? You're free to take that up with me at one point, but that's not relevant here.
17:14:18 <EvanR> you can always run linux in a vm when windows doesnt cut it
17:14:33 <solatis> i know, but i have a 2GB laptop here
17:14:38 <solatis> so i rather do without a vm
17:14:42 <augur> rasen: im not sure why that implication would hold, but perhaps perhaps
17:14:56 <EvanR> yeah thats a limiting factor
17:15:05 <monochrom> no, GHC and many libs on linux are more complete than on Windows
17:15:07 <EvanR> i have always used a very small linux backup on windows for that reason
17:15:23 <monochrom> MSR is fairly independent from MS
17:15:50 <sm> solatis: quite a few packages depend on c libs which are hard to build on windows or require a posix layer which will add complications of its own. You'll find it doable but harder than on linux
17:15:52 <monochrom> to make things more independent, GHC is getting more and more volunteers from outside MSR
17:16:08 <solatis> ok, i see
17:16:08 * hackagebot manifolds 0.1.0.0 - Working with manifolds in a direct, embedding-free way.  http://hackage.haskell.org/package/manifolds-0.1.0.0 (leftaroundabout)
17:16:10 * hackagebot dynamic-plot 0.1.0.0 - Interactive diagram windows  http://hackage.haskell.org/package/dynamic-plot-0.1.0.0 (leftaroundabout)
17:16:22 <solatis> thanks, i know enough for now i think :)
17:18:06 <solatis> hmm i could always just use a dual boot... hmm
17:18:31 <Welkin> a vm on a personal machine makes no sense
17:18:55 <geekosaur> wrong. sometimes you want to test your code in a different environment
17:19:05 <solatis> i need to be able to deploy on windows and linux
17:19:11 <bshelden> Welkin: I dual boot at home.  Win/Linux testing
17:19:14 <systemfault> Welkin: Tell that to the million of frontend programmers.
17:19:18 <Welkin> dual booting is different
17:19:19 * geekosaur 's personal machine has VMs with older OS X versions, several linux distributions, and win7
17:19:32 <bshelden> Erm, brain fart
17:19:35 <bshelden> I VM at home
17:19:37 <bshelden> Win host, Linux guest
17:19:46 <solatis> Welkin: vm on personal machine is awesome if you want to test on multiple environments
17:19:47 <monochrom> I dual boot and furthermore I have a vm. bite me.
17:19:48 <bshelden> I used to dual boot.  The VM solution is saner.
17:19:52 <geekosaur> and a bunch of others (solaris11, smartos, freebsd 10, ...)
17:20:04 <augur> Cale: perhaps there is a wikibook example that shows a common situation where these implementation-dependence issues arise?
17:20:05 <geekosaur> and yes, I use all of those at times
17:20:07 <Welkin> it cuts your resources down
17:20:26 <monochrom> yes. so?
17:20:31 <bshelden> Well yes, I do share my ram across both OSs.  This was not unexpected.
17:20:55 <monochrom> basically everything you do in this physical universe cuts your resources down.
17:21:08 <monochrom> <--- king of tautologies!
17:21:18 <Welkin> why use half a computer when you could use a whole one?
17:21:30 <bshelden> Because I want two computers and have one piece of hardware.
17:21:38 <geekosaur> ^
17:21:40 <monochrom> that is my personal choice and I won't rationalize it to you
17:21:41 <EvanR> so you can drag and drop between two desktops
17:22:02 <jonsterling> Just another day in #haskell apparently...
17:22:05 <augur> monochrom: the king of tautologies is the king of tautologies!
17:22:08 * sm wonders why everyone is so wrong on the internet today
17:22:12 <augur> jonsterling: :)
17:22:12 <monochrom> just as your questions are arguments cut down your resources for no gain and you still do it and you don't have to explain to me why you care
17:22:31 <bshelden> "people are wrong on the internet" <-- may as well be a tautology...
17:22:35 <geekosaur> so my alternatives are (a) vmware (b) virtual machines in the cloud, same thing but ongoing costs and slower access (c) buy a bunch of hardware that only gets used intermittently
17:22:35 <Welkin> I don't care
17:22:47 <Welkin> I do not understand why you are so worked up about this
17:23:02 <EvanR> dont let everyones wrongness get to you
17:23:04 <augur> jonsterling: you might know! what is a canonical example of implementation dependency being useful but also hairy, and why wouldnt proper modularity ala ML fix these issues
17:23:08 <EvanR> or you may find yourself being wrong!
17:23:11 <bshelden> You said it made no sense.  We explained how it makes sense.  Not sure what you expected.
17:23:16 <geekosaur> so I have an overpowered desktop which gets used for VMs, and can also be used for other things as needed. since I'm a bit of a power user, the "excess" capacity isn't really all that excess :)
17:23:39 <Welkin> it almost seems like a vim vs emacs debate
17:23:45 <monochrom> oh, I never really argued that it makes sense. I only argued for "bite me".
17:24:02 <augur> jonsterling: it seems like you can maintain interface backwards compatibility easily enough (provided you can define custom views that case expressions use)
17:24:17 <jonsterling> augur: I have no idea when implementation dependency could ever be useful, and proper modularity a la ML *does* fix all these issues. But it is a lot more complicated to do in the presence of dependent types (i.e. you can do it with no problem in extensional type theory, but there's stuff to figure out for ITT)
17:24:28 <geekosaur> augur: sometimes.
17:24:36 <augur> geekosaur: sometimes not tho?
17:24:57 <geekosaur> erlang is pretty good at this but it does it in part by using a virtual machine architecture (think JVM / CLR)
17:24:57 <jonsterling> It seems utterly inconceivable to me that there is a single person who could think that code-on-code dependency is ever a good idea, but perhaps if there were to be such a person, I might find them in #haskell
17:25:25 <geekosaur> there are cases in Haskell where you can't do it just by custom views. think the mtl1 to mtl2 change
17:26:14 <augur> geekosaur: i do not know how mtl1 and mtl2 are were implemented
17:26:20 <augur> are/were
17:26:29 <geekosaur> where all the flat monads (State, etc.) went away in favor of StateT Identity. you can "hide" that from code linking against it, in one direction at some significant cost, in the other at an even higher cost
17:26:46 <geekosaur> then it's time to find out and recognize what interface changes *mean* in Haskell
17:26:48 <pand3m1c> So, any anyone try lifting maybe over IO actions?
17:27:13 <jonsterling> Also, whilst I'm complaining, please don't justify or criticize issues of *language semantics* by appealing to a machine model. That's so 40 years ago.
17:27:52 <jonsterling> "I haven't yet read up on how to implement the compiler for this" !== "This is not a good idea"
17:27:57 <augur> geekosaur: i dont quite see how thats true. i mean, the old flat State interface still exists, right, it was just wrapped up to use StateT Identity instead
17:28:10 <geekosaur> it does not exist
17:28:14 <augur> geekosaur: no?
17:28:26 <hpc> most of the api is transparent
17:28:29 <geekosaur> State went from being a type to being a type synonym. This broke code
17:28:31 <hpc> except for State which is now state
17:28:40 <monochrom> jonsterling: I don't think anyone here has done that recently. is that true?
17:28:54 <augur> geekosaur: well ok but the interface is still the same barring that, iinm
17:29:01 <geekosaur> and just swapping State -> state is not sufficient because you could pattern match on State and you cannot on state
17:29:04 <jonsterling> geekosaur: The fact that state changing from a type into a type synonym broke code is an indictment of *other* design mistakes in Haskell.
17:29:07 <hpc> oh, true
17:29:16 <augur> State :: * -> * -> *    runState :: State s a -> s -> (a,s)   etc   right
17:29:46 <augur> the core type signatures + semantic equations that define State didnt change
17:30:08 <geekosaur> but the implementation did
17:30:14 <augur> yes i get that
17:30:20 <hpc> changing from a type to a type alias is a semantic change
17:30:23 <geekosaur> you like to think implementation changes are perfectly invisible unless someone made a mistake
17:30:46 <geekosaur> unfortunately, in the real world, it is only invisible at high levels of abstraction
17:30:48 <hpc> type aliases don't exist in the language semantics
17:30:53 <hpc> they're as good as CPP macros
17:31:12 <HeladoDeBrownie> re: state vs State, first-class patterns sure would be neat… actually, isn't there an extension for that?
17:31:16 <augur> hpc: this really shouldnt matter tho here
17:31:18 <tommd> But without any '#' so they don't look special!
17:31:23 <geekosaur> and, while you can generate code that operates at those high levels of abstraction, you pay a performance penalty
17:31:34 <augur> oh yes who mentioned State -> state
17:31:36 <geekosaur> which can be extremely significant
17:31:46 <rasen> HeladoDeBrownie: {#- LANGUAGE PatternSynonyms #-} ?
17:31:48 <jonsterling> augur: I think the issue is that there really is no such thing as a usable abstraction barrier in Haskell; there are things that look like abstraction barriers, but they really aren't. So a seemingly kosher change like that can break stuff, because Haskell's all about composing big mountains of interdependent ***code*** together, as opposed to functional
17:31:48 <jonsterling> programming, which is about composing separate, abstracted *functions* together.
17:31:48 <hpc> augur: my point is that it's not an implementation detail leaked through
17:31:56 <hpc> but a very important case to make visible
17:32:08 <geekosaur> so, if you're happy for stuff to run extremely slowly to get perfect compatibility, you can hide these chanegs
17:32:13 <Zemyla> Hmm. Is there a coeither comonad?
17:32:23 <HeladoDeBrownie> rasen, i think that's what i was thinking of, does that let you define patterns that are interchangeable with the likes of data constructor patterns?
17:32:24 <augur> jonsterling: well what im asking about tho is why we cant just put IN a usable abstraction barrier
17:32:31 <geekosaur> if you need your code to run in time to get payroll out the door on time, you may not be able to afford that level of abstraction
17:32:38 <rasen> HeladoDeBrownie: yep
17:32:52 <augur> geekosaur: well, thats fine and all, but thats also tangential
17:32:57 <jonsterling> augur: Ideas like that tend to be called "unhaskelly" (i.e. they don't follow the Haskell pattern of hacking it up wrong instead of following existing research)
17:32:58 <geekosaur> ...
17:33:08 <augur> geekosaur: i mean look, as it is, you have to upgrade from Av1 to Av2 if A depends on B and B changes, right
17:33:11 <geekosaur> you keep coming up with this notion that the central issue is tangential
17:33:12 <jonsterling> Also, it's kind of preposterous to say that abstraction barriers lead to slow code. ML does just fine.
17:33:15 <benmachine> Zemyla: instance Comonad ((,) e) where extract (_, a) = a; extend f (e,a) = (e, f (e, a)) -- I guess
17:33:20 <HeladoDeBrownie> that sounds like a solution to the state api breakage then. i suppose it might not have been around then, or they might have considered use of the extension an unacceptable cost
17:33:29 <geekosaur> and any attempt to convince you otherwise just causes you to re-assert that it is tangential
17:33:42 <augur> geekosaur: can you just
17:33:53 <geekosaur> what, forget everything I know about the real world?
17:33:57 <rasen> HeladoDeBrownie: It's relatively new
17:34:02 <augur> indulge me a moment with that quesiton, geekosaur
17:34:34 <augur> geekosaur: as it stands in haskell right now, we have code on code dependency for performance reasons
17:34:39 <geekosaur> people have been indulging you, and explaining the problems. and being told that's tangential
17:34:51 <augur> geekosaur: so Av1 depends on Bv1
17:35:11 <rasen> HeladoDeBrownie: Pattern synonyms appeared in GHC 7.8
17:35:18 <augur> geekosaur: and when you upgrade from Bv1 to Bv2 you need to upgrade or recompile Av1 because of the dependency issue, right
17:35:18 <HeladoDeBrownie> ah, yeah, that is new
17:35:28 <jonsterling> geekosaur: I've been watching this conversation, and that's not what it looks like at all. It looks like a bunch of Haskell people tossing the "real world" in augur's face, when systems that actually have abstraction unlike haskell do not have any of the problems that are cited here.
17:35:42 <geekosaur> jonsterling, but they do
17:35:53 <jonsterling> preposterous
17:35:57 <jonsterling> sorry, I have to go.
17:36:03 * jonsterling not sorry
17:36:09 <MP2E> heh
17:36:11 <Arahael> jonsterling: Would these real-world applications use weaker type systems?
17:36:18 <geekosaur> they sweep it under the rug in other ways, by taking performance hits (Erlang BEAM, C++ virtual tables, JVM abstraction, etc.)
17:36:41 <jonsterling> S t a n d a r d M L        O C A M L
17:37:01 <Arahael> jonsterling: They don't have typeclasses, yet, do they?
17:37:21 <jonsterling> Arahael: This is precisely why abstraction is still possible in ML
17:37:22 <geekosaur> C doesn't sweep it under the table, and it doesn't try to deal with it, and the result was core dumps until people started using things like libtool that enforce module versioning
17:37:55 <Arahael> jonsterling: Fair point.
17:37:56 <jonsterling> Arahael: (Well, not precisely, in that there are a lot of other reasons abstraction is possible. but Haskell doesn't support functional programming in the same way, and part of the problem is type classes; other problems abound though)
17:38:17 <geekosaur> yes, I am aware of SML. I am also aware of the things it doesn't let me do easily.
17:38:26 <geekosaur> if I wanted that level of annoyance I'd code in C or assembler
17:38:29 <jonsterling> geekosaur: Lol
17:38:47 <jonsterling> OK, I'm going to buy a bottle of wine. Maybe this conversation will look less laughable when I have had some of it. Cheers.
17:38:57 <Arahael> jonsterling: I guess your point is that rather than saying that "It is how it is because of real-world practicalities", we should be saying: "IT is how it is, because we haven't worked out how to do X in a performant and safe fashion yet"
17:39:13 <Arahael> jonsterling: But that would be a harder claim. :)
17:39:54 <_1_alexfootball> hello
17:40:01 <augur> jonsterling: i too shall buy a bottle of wine, that sounds rational at this point
17:40:06 <augur> but i will not be returning to this convo
17:40:16 <HeladoDeBrownie> _1_alexfootball, hi again
17:40:22 <jonsterling> Arahael: Sort of. I mean, “Haskell folks haven't worked out how to do X in a performant and safe fashion yet”, since ML folks haven't really had super serious issues with this stuff so far. Problems in Haskell tend to arise because of other problems in Haskell, so it's kind of a trap to figure out where they come from in a more precise way than "lol
17:40:22 <jonsterling> haskell/SPJ/ignoring every other person's research"
17:40:26 <geekosaur> is there some purpose to this bot?
17:40:27 <mmachenry> If anyone is going to get wine, can you get me some? It's not legal to drive where I am right now.
17:40:38 <geekosaur> HeladoDeBrownie, it's a bot, try /whois
17:41:00 <benmachine> jonsterling: there is never a good reason to be laughing at other people in technical discussions, no matter how wrong you think they are
17:41:26 <HeladoDeBrownie> geekosaur, well, that explains why my earlier conversation with _1_alexfootball left me confused :P
17:41:29 <benmachine> jonsterling: you (and not only you) are being pretty hostile here and it's not welcome
17:41:37 <MP2E> I don't see how any of this is constructive anyway, it's just a bunch of hostile assertions
17:41:42 <MP2E> and then backing off with 'okay leaving now'
17:41:44 <MP2E> but then not really
17:41:51 <mmachenry> jonsterling: I agree with benmachine. Perhaps if you didn't come here with an attitude problem you'd learn things and people would learn from you.
17:42:04 <jonsterling> benmachine: Sorry, I shouldn't laugh at anyone. Honestly, I shouldn't even be in this channel, it's pretty distressing. I'll just say, my hostility to the Haskell community is a reaction to its hostility to pretty much everything except stuff that it reinvented by accident.
17:42:09 <MP2E> If there were actually any points being made maybe I'd care about what you were saying
17:42:29 <MP2E> as it stands, this is getting irritating quickly.
17:42:34 <Arahael> jonsterling: Ok I'm getting out of this.
17:42:58 <EvanR> jonsterling: do you have a link to resources explaining all of this
17:42:58 <Arahael> I'm not even a Haskell expert, but I've read enough of the papers that Haskell has produced to really appreciate it.
17:43:12 <augur> MP2E: <3 ill buy you some wine too
17:43:17 <EvanR> id be interested in reading it rather than watching basically maury
17:44:00 <jonsterling> EvanR: Sorry, I don't really have an archive of "Things haskell got wrong"; and when I try to explain it here, it makes everyone uncomfortable. Feel free to email me with specific questions.
17:44:32 <EvanR> why is there no archive?
17:45:07 <jonsterling> Sorry to anyone I offended; I saw what looked like a train wreck to me of people being abusive (in typical #haskell style) to a friend of mine, and I probably got carried away. Good night.
17:45:35 <benmachine> jonsterling: I'm sorry if I'm targeting you when other people were being abusive as well, you just happened to be at the bottom of the window when I looked
17:46:34 <jonsterling> benmachine: Honestly, my perspective was that I was defending people from abuse—maybe that's not how it looked from other folks' perspective though.
17:46:54 <_1_alexfootball> hello everyone
17:47:12 <augur> lmfao
17:47:14 <augur> @where ops
17:47:15 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
17:47:30 <josephle> is that to get rid of the bot?
17:47:34 * geekosaur is pretty much done with that bot, yeh
17:47:34 <augur> yes
17:47:39 <monochrom> oh, ok
17:47:48 <augur> kill this ridiculous bot please
17:47:52 --- mode: ChanServ set +o geekosaur
17:48:00 --- mode: geekosaur set +b *!*@125.14.31.96.cable.dyn.premieronline.net
17:48:00 --- kick: _1_alexfootball was kicked by geekosaur (_1_alexfootball)
17:48:04 <monochrom> :)
17:48:09 <EvanR> field goal
17:48:19 <geekosaur> might change that ban, come to think of it
17:49:13 <benmachine> uhm, what was that for?
17:49:27 <geekosaur> then again not, no good matchers for it
17:49:48 <bitemyapp> geekosaur: maybe they'd be too lazy to change the nick?
17:50:12 <josephle> benmachine: _1_alexfootball is a bot that just keeps saying greetings
17:50:24 --- mode: geekosaur set -b *!*@125.14.31.96.cable.dyn.premieronline.net
17:50:37 --- mode: geekosaur set +b _1_alexfootball!*@125.14.31.96.cable.dyn.premieronline.net
17:50:41 <benmachine> they've said eight things in my entire scrollback (about an hour or so)
17:50:56 <geekosaur> yes but it already pulled one person into a confusing conversation
17:51:07 <Hijiri> much better spam track record than lambdabot
17:51:10 * HeladoDeBrownie raises their hand :)
17:51:33 <geekosaur> really, test your bots elsewhere (except, java bot?!)
17:51:38 --- mode: geekosaur set -o geekosaur
17:51:50 * benmachine shrug
17:51:53 <monochrom> I don't know about other ops. but I ban based on popular demand, not on traffic amount
17:52:01 <dfeuer> Does anyone know of an implementation of the one-sided 2-3 finger search trees Ralf Hinze describes in "Numerical Representations as Higher Order Nested Datatypes"?
17:52:24 <benmachine> well, I'mma go to bed, long overdue
17:52:24 <joness> besides ZipList what other Applicative instances are there that can't have a Monad instance?
17:52:30 <dfeuer> He uses some wonky pattern synonym sort of notation that I don't know, and spreads definitions out all over the article.
17:52:56 <dfeuer> I'd love to just have teh codez.
18:00:49 <solatis> hmm does stackage guarantee builds on windows also ?
18:04:10 <__jim__> Are there any decent os agnostic sound libraries in haskell?
18:04:11 <__jim__> I'm looking to capture and play audio
18:04:20 <halvorg> how does ordering on tuples work?
18:04:45 <Zemyla> halvorg: Lexicographically.
18:04:58 <halvorg> I see, thanks
18:06:30 <Zemyla> Hmm. There doesn't seem to be a dual functor for the continuation functor, Cont r a = (a -> r) -> r, the way (,) and (->) are duals.
18:07:33 <osa1_> is there a way to make this working http://lpaste.net/119281 do I need to generate the Decl manually?
18:08:24 <Cale> __jim__: Unfortunately a lot of the best audio stuff is maintained by Henning Thielemann, which due to his stupid conventions (he names every type T and every class C) makes it almost unusable in practice.
18:08:41 <__jim__> Ouch
18:09:16 <Cale> But I dunno, it depends on what you need. There's a usable binding to OpenAL
18:09:17 <glguy> osa1_: You don't splice things with backticks in quasiquoters
18:09:18 <glguy>     let name = varP (mkName "myDeclaration")
18:09:18 <glguy>     [d| $name = 1 |]
18:09:19 <kini> what? as in parameters or actual exported names?
18:09:26 <__jim__> Ill take a look just in case i guess
18:09:26 <glguy> osa1_: That might be what you're after
18:09:38 <geekosaur> exported names
18:09:48 <Cale> The 'synthesizer' package is what I was thinking of with regard to Henning's work
18:09:49 <kini> scary...
18:10:03 <osa1_> glguy: right, thanks.
18:10:19 <benzrf> christ what happened here earlier
18:10:21 <__jim__> Simple audio capture and playback is all i need now. Nothing sophisticated
18:10:27 <Cale> http://hackage.haskell.org/package/synthesizer-core -- there's so much cool stuff here, and then you look at it and you discover that the documentation is practically unreadable
18:10:31 <Cale> http://hackage.haskell.org/package/synthesizer-core-0.7.0.2/docs/Synthesizer-Causal-Oscillator.html
18:10:36 <__jim__> Lol
18:10:37 <Cale> look at that shit, lol
18:10:43 <__jim__> Ty btw
18:10:44 <benzrf> lotta salt in my backlog
18:11:08 <geekosaur> most of that discussion needs to be sowed with salt...
18:11:18 <kini> rofl I like how the typeclass "C" is linked to file:///tmp/synthesizer-core-0.7.0.2/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.6.3/numeric-prelude-0.4.1/html/Algebra-RealRing.html#t:C
18:11:19 <Cale> salt?
18:11:36 <byorgey> Zemyla: no, but  (-> r)  is self-adjoint
18:11:59 <shachaf> Zemyla: How are (,) and (->) duals?
18:12:03 <byorgey> and it gives rise to Cont, just like (,a) and (a->) give rise to the State monad
18:12:06 <shachaf> (I'd like to know an answer to this.)
18:12:14 <Cale> Oh yeah, his algebra packages would also be awesome if only he used sensible conventions
18:12:16 <geekosaur> kini: I think that was a bug in the script to roll your own docs because hackage has been having issues
18:12:26 <benzrf> Cale: apparently "salty" is picking up steam as a term for being bitter and abrasive so i figured i'd better hop on that bandwagon
18:12:43 <byorgey> I assumed (perhaps incorrectly) that Zemyla is referring to the fact that (,a) and (a->) are adjoint
18:12:48 <kini> that's not really what salty means -- http://www.urbandictionary.com/define.php?term=salty
18:12:52 <geekosaur> well, salty used to be a reference to (sailors) swearing
18:13:10 <kini> it's specifically being used as a term for being bitter and abrasive because you're sulking due to being made a fool of in some way
18:13:11 <__jim__> Wow that wasn't readable
18:13:32 <Cale> In this case, salty is a term from fighting games, referring to a player's tears :)
18:13:34 <kini> I've heard it conjectured that it derives from the saltiness of one's tears of rage left dried upon your face
18:13:39 <kini> yeah, there we go :)
18:13:39 <Cale> yes
18:13:46 <shachaf> One relationship between (e,) and (e->) is that Co (e,) = (e ->), and Co (e ->) = (e,)
18:13:55 <Hijiri> salty is how I feel after losing badly in soku
18:13:56 <shachaf> Where newtype Co w a = Co { forall r. w (a -> r) -> r }
18:13:58 <kini> Cale always knows what's up :)
18:14:04 <shachaf> ANd also Co (Store e) = State e
18:14:21 <Cale> There are also packages like Haskore which Henning Thielemann has pretty much ruined since he took over maintaining them.
18:14:22 <sdegutis> You there.
18:14:23 <Hijiri> ie whenever I go on #hisouten
18:14:26 <kini> geekosaur: hah, I see (re: script)
18:14:29 <sdegutis> Why does LyaH put Num in length' :: (Num b) => [a] -> b   ?
18:14:38 <Cale> Which makes me especially sad because Haskore was originally how I got introduced to Haskell.
18:15:10 <Hijiri> Is Thielmann the one-letter data constructors/types person?
18:15:11 <Cale> We need to make like a big coordinated project out of fixing Henning's packages at some point
18:15:12 <byorgey> sdegutis: it says that length' can return a value of any type b, as long as that type is an instance of Num
18:15:14 <kini> if it's done, stick a fork in it!
18:15:15 <Hijiri> or is that someone else
18:15:16 <Cale> Hijiri: yes
18:15:32 <Hijiri> oh, ok
18:15:39 <Cale> He writes so much good code, but due to that convention, it's all practically unusable
18:15:58 <EvanR> i tried to generate html from my source file using haddock, but it has omitted the qualification to the types in my signatures, and has no links to the haddocks for my deps, or anything really. how do i get links?
18:16:33 <sdegutis> byorgey: is that necessary to specify?
18:16:38 <shachaf> byorgey: I feel like there's something to this "duality" but I don't know exactly what.
18:16:58 <shachaf> byorgey: There are also a lot of places where you dualize things and you go from functions to tuples or vice versa (and similarly forall <-> exists).
18:17:00 <kini> sdegutis: if you didn't specify Num b, then you would be saying that length' could take a list of any type and produce a value of any other type
18:17:09 <sdegutis> kini: oh nice
18:17:21 <sdegutis> fwiw, I can't stand the writing style of the Real World Haskell book -- Learn you a Haskell is so much easier to read and sounds much less pretentious
18:17:22 <kini> (and that's not possible... for certain values of "possible")
18:17:48 <Cale> At one point I started to write a source to source translator to fix his code, but it's tricky to handle imports, because it's theoretically possible to import multiple modules under the same qualifier, so you have to be really careful there.
18:18:07 <sdegutis> kini: so the reason I haven't seen something like this until now is that in all the rest of the examples here, the return type was related to another argument which it could then be inferred by
18:18:09 <Hijiri> sdegutis: have you taken a look at bitemyapp's guide (and therefore cis194 too)
18:18:25 <EvanR> ah i guess i should use cabal
18:18:31 <Cale> But maybe that would be an option still even if it's not the 30 minute job I thought it was going to be :P)
18:18:31 <sdegutis> Hijiri: briefly but I was told cis194 is geared towards people with little/no FP experience
18:18:35 <Hijiri> oh, right
18:18:35 <monochrom> Cale: have you tried this simple translation? Data.Bytestring.T -> DataBytestringT
18:18:48 <Hijiri> I've heard lyah would be good for people familiar with MLs
18:18:50 <sdegutis> Hijiri: but im getting along just fine skimming LyaH -- im on chapter 3 already
18:18:56 <Hijiri> I wasn't, so I don't really have any experience
18:19:29 <kini> sdegutis: you can intuitively think of a typeclass constraint as basically a group of extra parameters to a function -- remember that every typeclass comes with a list of class functions which must be implemented for any type which is in that typeclass
18:19:48 <sdegutis> kini: im familiar with Swift type constraints so i think it should come easy
18:19:57 <Cale> monochrom: I haven't... but the problem is more that for instance, you can have  import qualified Algebra.FloatingPoint as FloatingPoint, and then where things get used, you have FloatingPoint.C or something
18:20:03 <kini> sdegutis: in particular, any instance of the Num typeclass for a type "a" must come with a function fromInteger :: Integer -> a
18:20:23 <sdegutis> kini: yeah that sounds like Swift protocols
18:20:27 <kini> sdegutis: so you could look at (Num b) => [a] -> b as something like "... -> (Integer -> b) -> [a] -> b"
18:20:36 <kini> sdegutis: and now look, the return type of the function is somehow related to the parameters again, just as you'd expect
18:20:42 <monochrom> I see
18:20:43 <Cale> monochrom: I guess you could assume that the import qualification is a bijection since it's Henning
18:20:56 <Cale> (but in general, it needn't be)
18:21:39 <monochrom> no, I wouldn't rely on that. I would FloatingPoint.C -> AlgebraFloatingPointC. in other words, I would have to be aware of the import lines.
18:22:17 <Cale> Well, there's also the possibility of doing something semi-automatic
18:22:17 <gregnwosu> is *> from parsec or applicative?
18:22:31 <Cale> Where you run one tool, and it collects up all the .T and .C names
18:22:35 <monochrom> applicative
18:22:56 <gcganley> gregnwosu: applicative
18:22:58 <Cale> and then you augment the file that it generates with new names, and then it translates future modules with that mapping
18:23:21 <gcganley> gregnwosu: maybe parsec gives a specific instance
18:23:38 <gregnwosu> thanks
18:25:31 <Zemyla> shachaf: So what is Co (Cont r)?
18:26:02 <shachaf> Zemyla: Some type, but the interesting thing about Co is that there's an instance Comonad w => Monad (Co w)
18:26:09 <gcganley> :k Co
18:26:10 <lambdabot> Not in scope: type constructor or class ‘Co’
18:26:30 <gcganley> :k WriterT
18:26:31 <lambdabot> * -> (* -> *) -> * -> *
18:28:15 <Cale> augur: Anyway, I don't know what that was all about after I had to leave for a bit... lol
18:28:33 <Cale> Some crazy shit went down :D
18:29:12 <zwer> :t filter
18:29:13 <lambdabot> (a -> Bool) -> [a] -> [a]
18:29:25 <Cale> But yeah, I think there's probably a way *in principle* to solve these problems with binary interfaces changing
18:29:50 <Cale> But I'm not certain it would be without giving up on some of the optimisations which are currently being done at link time.
18:30:06 <Cale> I don't really know for sure.
18:30:59 <sdegutis> Haskell is whitespace-sensitive so it's basically just like Python, right?
18:31:02 <sdegutis> jk!
18:31:16 <sdegutis> That was a pretty funny joke I have to admit. And unique, too. Brand-new.
18:31:19 <Welkin> you cna override the whitespace using {}
18:31:22 <Welkin> can*
18:31:25 <Cale> sdegutis: The manner in which it's whitespace sensitive is a bit different from Python.
18:31:28 <joness> just checked.. #haskell surpassed python as the largest programming channel on freenode. :)
18:31:34 <Cale> oh, cool :)
18:31:54 <Welkin> #python is not what I would call a high-quality channel
18:32:00 <Cale> I remember when I first joined this channel it was like 26 people or something.
18:32:18 <joness> Cale how long ago was that?
18:32:30 <Cale> Sometime in 2001 or 2002
18:32:33 <Cale> ?
18:32:37 <Welkin> Cale's name is all over the haskell wiki
18:32:39 <Cale> I forget exactly
18:32:40 <__jim__> cale: my irc client crapped out, could you resend me those links?
18:32:59 <__jim__> some android app..
18:33:00 <Cale> http://hackage.haskell.org/package/OpenAL
18:33:03 <Cale> http://hackage.haskell.org/package/synthesizer-core
18:33:06 <platz> I wonder what the participation distribution looks like here.  It has to be a power-law distribution I think, I just wonder how long the tail really is
18:33:12 <__jim__> thanks!
18:33:28 <drazak> Cale: yeah I had no idea this channel at 1500 people
18:34:09 <sdegutis> Cale: are you the resident haskell expert?
18:34:23 <Cale> One of them, I guess
18:34:24 <Welkin> sdegutis: he is one of many
18:34:26 <HeladoDeBrownie> Cale is a being from primordial times, or possibly from beyond time itself
18:34:36 <sdegutis> Cale: pop-quiz, shortest applicative monad that prints hello world -- go!
18:34:42 <drazak> Cale: I wonder how many exercises in awodey can be reformulated into haskel stuff
18:34:45 <Welkin> if you spend enough time here, you will see the same people always answering questions
18:35:16 <HeladoDeBrownie> sdegutis, that question is ill-formed
18:35:32 <Welkin> putStrLn "Hello, World!"
18:35:32 <HeladoDeBrownie> (actually i don't know what you meant by it at all)
18:35:40 <sdegutis> HeladoDeBrownie: yeah i dont know haskell
18:35:48 <sdegutis> anyway how do you get sublime text to indent haskell properly?
18:35:48 <Cale> sdegutis: Monads are types... types exist only at compile time and aren't around to print things :)
18:35:52 <HeladoDeBrownie> sdegutis, oh well, you'll get there
18:36:05 <sdegutis> Cale: well played sir or madam
18:36:13 <Welkin> madam Cale
18:36:40 <sdegutis> ok indentation ST2?
18:36:42 <sdegutis> St3?
18:37:06 <Welkin> sdegutis: use whatever haskell-mode does automatically
18:37:15 <platz> When I think of people who work on core libraries, compilers, etc..  it bums me out that it seems like there are only a few people in the world that can solve those problems.. so many programmers in the world but there's some great filter involved for much important work
18:37:26 <sdegutis> Welkin: its not indenting for me
18:37:32 <sharky-> what is the recommended way of starting in haskell? I come from OOP languages mostly
18:37:32 <Cale> drazak: Not a whole lot... translating abstract category theory into Haskell is also stomping on it with a very heavy foot, even if the end result is often useful. :)
18:37:41 <sdegutis> Welkin: im using guards though
18:37:43 <sdegutis> maybe thats why
18:37:52 <Welkin> sharky-: the UPenn course
18:37:55 <Welkin> @learnhaskell
18:37:55 <lambdabot> Unknown command, try @list
18:37:55 <drazak> Cale: yeah I figured
18:37:59 <Welkin> @where learnhaskell
18:38:00 <lambdabot> https://github.com/bitemyapp/learnhaskell
18:38:04 <Cale> sharky-: Well... there are some good tutorials out there. A lot of people these days seem to be recommending the CIS 194 course
18:38:05 <Welkin> sharky-: go there
18:38:17 <Cale> http://www.seas.upenn.edu/~cis194/fall14/lectures.html
18:38:20 <stanlee> be aware that there are also several versions of cis194
18:38:32 <Cale> yeah, there's a newer one which is still running it seems
18:38:33 <Welkin> spring 13, not fall 14
18:38:40 <sharky-> thanks I will check those links
18:38:41 <Cale> oh?
18:38:42 <stanlee> yep
18:38:50 <drazak> Cale: I kind of want to put effort towards actually learning category theory
18:38:50 <Cale> Is the Spring 13 one better? :)
18:39:16 <stanlee> i think the exercises are the same, the content is a bit different, different style of writing
18:39:22 <Cale> drazak: It's worth the trouble if you're motivated, I think.
18:39:33 <drazak> but I have an urge to finish rudin then tackle spivak's calculus on manifolds
18:39:45 <drazak> which is exactly the opposite type of math from category theory
18:39:58 <Welkin> sometimes it's fun to think about category theory and other abstract math, but most of the time I just want to write a program that does something
18:40:08 <Cale> yeah... it's a bit sad that CT hasn't worked its way deeper into analysis yet
18:40:08 <shachaf> Category theory is the dual of category theory. That's one of the main ideas of category theory.
18:40:14 <Welkin> it's nice that you don't need to know anything about category theory (or type theory) to use haskell
18:40:14 <Cale> There's definitely potential there
18:40:30 <Cale> It's just not as obvious how to apply things as it is with most algebraic topics.
18:40:32 <drazak> Cale: it's super deep in topology which is the basis for most analysis
18:40:37 <Cale> Well, yes
18:40:45 <drazak> but almost always we are doing covering space things to get that
18:41:03 <EvanR> Welkin: its nice that by learning haskell youll be inexorably drawn to learn about category theory (or type theory)
18:41:20 <Welkin> EvanR: that is the only reason I became interested in abstract algebra
18:41:29 <Welkin> otherwise it would have no relevence to me
18:41:41 <solatis> i think i'm just going to bite the bullet and try to write my haskell code for both windows and linux compatibility
18:41:42 <EvanR> or you just didnt know it yet!
18:41:57 <Cale> But when I say analysis here I mean like the theory of Banach spaces, measure theory, and, well, all the stuff which begins to involve lots of inequalities :D
18:42:02 <drazak> yeah
18:42:22 <tel-> I wonder if the probability stuff would help get closer to analysis
18:42:40 <Cale> I'd also really like to see a meaningful categorification of the theory of matroids.
18:42:56 <__jim__> what is a matroid?
18:43:12 <Cale> Matroids are an abstraction of the idea of linear independence
18:43:24 <Cale> If you know about vector spaces and linearly independent sets of vectors
18:43:56 <__jim__> hm, i never thought about that in other contexts
18:44:07 <drazak> Cale: I heard about matroids a few weeks ago!
18:44:10 <__jim__> that would be pretty interesting to see
18:44:16 <drazak> I heard they have something to do with topology as well
18:44:36 <Cale> A matroid consists of a set E (the ground set), and a family of subsets I of E (called independent sets) which satsify properties similar to the properties that linearly independent sets of vectors have
18:44:58 <Cale> In particular, 1) the empty set is independent
18:45:09 <Cale> 2) Every subset of an independent set is independent
18:45:43 <Cale> 3) If A and B are two independent sets and A has more elements than B, then there exists an element in A which when added to B gives a larger independent set than B.
18:46:31 <EvanR> and A and B still subsets of that E
18:46:31 <__jim__> for 3) is the independent set created also independent from A?
18:46:36 <Cale> yes
18:46:46 <__jim__> hm
18:46:50 <Cale> Er
18:46:55 <Cale> That was to EvanR
18:47:05 <__jim__> lol
18:47:09 <Cale> "Independence" here just means that the set is an element of this family I
18:47:15 <__jim__> I didn't see the username change
18:47:24 <__jim__> ah
18:47:36 <Cale> So, it's not independent from some other set, it's just independent or not
18:48:14 <drazak> Cale: I'm still meaning to read that graph theory book you mentioned
18:48:15 <__jim__> I see, I guess I was relating it more closely to linear indepence than needed
18:48:18 <drazak> algebraic graph theory or whatever
18:48:37 <Cale> Well, it's actually the same in linear algebra -- sets of vectors are either linearly independent, or they aren't.
18:49:02 <__jim__> it's been awhile since I've had a linear algebra class I guess..
18:49:03 <Cale> But I guess you could ask whether the union of two sets of vectors is still linearly independent
18:49:18 <drazak> well there is uh, maximially dependant or something (if any one of the vectors is removed it's an independent set)
18:49:19 <Cale> in which case, the answer here is likely no
18:49:32 <Cale> oh, yeah
18:49:39 <Cale> that's a relevant concept
18:50:00 <Cale> That is called a circuit in this context, because of a completely different way of picturing these things
18:50:03 <drazak> I can't remember if it's called maximally dependent, but that name sounds as good as any
18:50:24 <Cale> A minimal dependent set rather
18:50:32 <drazak> yeah
18:50:40 <Cale> in that any of its subsets are independent
18:50:43 <__jim__> so, what all could you do with this (I guess from a CS view)?
18:50:46 <Cale> (proper subsets)
18:50:52 <drazak> humn
18:51:18 <__jim__> it seems like it could be useful, but I don't know a lot (read 'anything') about type/category theory
18:51:27 <drazak> I suspect if a matrix is not of full rank, that it can also have this minimal dependence property as well, and that would be one which takes the maximum number of row operations possible to get to rref
18:51:58 <Cale> Well, a matroid together with a function from the elements of the matroid to nonnegative real numbers is sort of a generic context on which you can define a greedy algorithm
18:52:08 <Cale> (though there is a slightly more generic one)
18:52:12 <drazak> this was just a side note
18:52:28 <drazak> it's been a week and my linear algebra class hasn't mentioned 'vector space' yet
18:52:55 <Cale> i.e. an algorithm to find a maximum weight basis (maximal independent set)
18:52:59 <__jim__> drazak: they're probably laying some ground work
18:53:00 <drazak> right
18:53:08 <maximilian> any recommended books/resources on going from lin. algebra/group theory to category theory?
18:53:18 <drazak> maximilian: there's always aluffi
18:54:22 <maximilian> drazak: looks interesting, thanks!
18:54:58 <drazak> __jim__: dunno, I think we are going to spend a lot of time doing mundane things
18:55:05 <Cale> maximilian: Well, if you're interested in an introduction to category theory, I always recommend Awodey's book
18:55:16 <Cale> maximilian: But it doesn't actually rely on all that much other algebra
18:55:27 <Cale> (and develops most of what it needs internally)
18:55:29 <__jim__> drazak: that's what happened in my class ..
18:55:42 <carter> someone mentioend linear algebra!
18:56:00 <maximilian> Cale: thanks!
18:56:42 <Cale> If you're interested in an intro to group theory and ring theory and such, definitely have a look at the book by Dummit and Foote, as well as Michael Artin's book.
18:56:50 <drazak> I second Artin's book
18:56:52 <drazak> it's quite good
18:57:00 <drazak> the second edition seems hard to find online though
18:57:37 <Cale> I'll PM you some links :)
18:59:04 <maximilian> drazak: You're right. Seems hard to find...
18:59:16 <Cale> For linear algebra... there are three books which I think are worth mentioning. Hoffman and Kunze is a classic -- it's slightly less modern, but for a beginner's text, includes quite a wide range of topics, and does a good job of them.
18:59:49 <__jim__> how much would be missing from a classical linear algebra book vs a modern one?
19:00:02 <drazak> well linear algebra hasn't changed much in 50 years
19:00:07 <Cale> Well, I don't think anything is missing, it's just the development is rearranged...
19:00:13 <__jim__> fair enough
19:00:28 <drazak> if you want an abstract approach by an analyst I suggest Halmos, but you won't learn much pratical (IE. how to computer) from it
19:00:44 <Cale> More modern books will tend to place abstract vector spaces and linear transformations ahead of the concrete development of matrices
19:01:12 <carter> otoh, a computational approach to linear algebra might be a great way to help get a handle
19:01:18 <Cale> Friedberg, Insel and Spence is somewhat more modern, and somewhat easier than H&K. It has less "bonus" material, but it's reasonably good.
19:01:23 <carter> ironically, those tend to be regarded as mroe advanced books
19:01:51 <Cale> and then there's a book by Steven Roman, called Advanced Linear Algebra
19:01:57 <drazak> yeah
19:02:04 <Cale> which is really more for people who think they already know everything about linear algebra
19:02:10 <drazak> also Sheldon Axler's Linear Algebra Done Right
19:02:21 <Cale> But it does everything in an uncompromisingly "right" way
19:02:28 <Cale> At least, most everything
19:03:03 <Cale> (I think it could still do a better job about the basis theorem... people have no love for transfinite induction...)
19:03:10 <drazak> and if you need to know 15 different ways to decompse a linear map into parts iwth different nice properites, you get Greub or Bourbaki
19:03:29 <drazak> Cale: I have math professors who don't know what injective and surjective are, they only know 1-to-1 and onto :/
19:03:47 <maximilian> ouch
19:04:13 <tel-> I like how all of the reviews of Axler stress that the book is "determinant free"
19:04:36 <drazak> tel-: well it's a linear algebra book, not a multi-linear algebra book
19:04:55 <drazak> a determinant is a multilinear product
19:05:13 <drazak> there are many classical presentations which only mention it in contexts of spectral theory
19:05:40 <dfeuer> Dummit and Foote is kind of unbearable, I think. But algebra's not inherently my thing.
19:05:46 <sdegutis> I'm just starting chapter 5 (recursion) in YyaH and I have to wonder, are all these functions I've been defining so far global?
19:05:53 <sdegutis> LyaH i meant
19:06:25 <dfeuer> I would, however, like to learn enough algebra to get into algebraic topology.
19:06:44 <dfeuer> And also enough to get a clue about category theory. :-/
19:07:11 <tel-> drazak: the emphasis is just amusing to me. Reading the reviews more thoroughly I understand why they mention it so often, but determinants certainly played a big role when I first learned it all
19:07:45 <drazak> tel-: well they aren't all that important
19:07:48 <maximilian> sdegutis: You can put them into modules.
19:08:00 <drazak> tel-: in classical linear algebra anyway, heh
19:08:01 <sdegutis> Are all my functions in my TryingHaskell.hs global? Or are they in some implicit module?
19:08:08 <sdegutis> maximilian: oh
19:08:18 <tel-> drazak: I'm not arguing, heh
19:08:34 <tel-> just not the way I was originally taught
19:09:01 <dfeuer> Since Cale is here and knows everything, I'll ask him what he thinks about the idea of replacing the binary heaps in https://hackage.haskell.org/package/NumberSieves-0.1.2/docs/src/Math-Sieve-ONeill.html with 2-3 search trees under the left spine view as described in http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.46.571&rep=rep1&type=pdf
19:09:05 <drazak> they ARE an important ideas
19:10:36 <SrPx> why the Num class needs signum and abs, if abs is just `abs x = x * (signum x) ??
19:10:43 <sdegutis> I just wrote my first official line of Haskell!
19:10:46 <sdegutis> let f = (+) 1
19:10:48 <drazak> its a useful abstraction
19:11:15 <geekosaur> SrPx: because there may be faster implementations of abs for some types
19:11:16 <sdegutis> My second and third lines were f 2 and f 10
19:11:16 <maximilian> sdegutis: I assume that is GHCi?
19:11:22 <sdegutis> maximilian: how'd you know?
19:11:27 <geekosaur> for example, masking a bit off
19:11:34 <maximilian> sdegutis: you dont need the let normally.
19:11:43 <geekosaur> instead of doing a multiplication
19:11:48 <sdegutis> maximilian: oh right
19:11:51 <SrPx> geekosaur: but why is it the *minimal* implementation?
19:11:52 <sdegutis> thanks friend
19:12:17 <dfeuer> SrPx, signum has to somehow manufacture its peculiar 1 or -1 values. Not so natural for CPUs.
19:12:25 <SrPx> I thought the minimal was for the necessary, and the rest for optimizations
19:12:28 <EvanR> SrPx: is that a law of the Num class?
19:12:31 <geekosaur> hm
19:12:38 <geekosaur> that I do not know
19:12:43 <dfeuer> SrPx, I believe those both have defaults.
19:12:54 <SrPx> hmm
19:13:15 <maximilian> sdegutis: no problem
19:13:23 <SrPx> ah is that is the case then there is a documentation error
19:13:26 <SrPx> http://hackage.haskell.org/package/base-4.7.0.2/docs/Prelude.html#t:Num :)
19:13:27 <geekosaur> but, it's well known that Num is not especially well designed. in this case it may be that a more minimal one can be specified but not proven
19:13:44 <sharky-> is it true that haskell has no loops like other languages ?
19:13:55 <geekosaur> or it may be that it just hasn't been thought about
19:13:59 <geekosaur> sharky-, yes and no
19:14:06 <geekosaur> it doesn't have them *like* other languages
19:14:08 <dfeuer> sharky-, no, it is not true. It has loops like ML and Scheme and LISP.
19:14:16 <geekosaur> it has them in other ways; for example a list is a loop
19:14:38 <sdegutis> im eager to write a hello world already
19:14:41 <sdegutis> what chapter is that on in LyaH?
19:14:44 <dfeuer> And Idris, and .....
19:14:55 <dfeuer> sdegutis, Hello World is really boring....
19:15:07 <sdegutis> dfeuer: i meant i want to actually write code outside of gchi
19:15:11 <EvanR> > print "Hello World"
19:15:13 <lambdabot>  <IO ()>
19:15:14 <sdegutis> dfeuer: but i cant because theres no main function yet
19:15:23 <augur> Cale: so it might be useful to see a kind of minimal example of where this is tricky
19:15:24 <sdegutis> dfeuer: and i havent learned how to define one yet
19:15:25 <joness> there is main action
19:15:31 <erikd> main = print "Hello world"
19:15:35 <joness> main = putStrLn "hi"
19:15:37 <dfeuer> sdegutis,      main = putStrLn "Hello World."
19:15:43 <sdegutis> joness wins
19:15:51 <dfeuer> But this is very boring....
19:15:56 <joness> yay@
19:15:59 <EvanR> write a factorial function instead, or a fibonacci sequence
19:16:03 <sdegutis> Are Haskell programs slow to compile?
19:16:07 <dfeuer> Yes.
19:16:11 <sdegutis> really?
19:16:13 <dfeuer> Often.
19:16:16 <sdegutis> how slow?
19:16:24 <dfeuer> Depends!
19:16:24 <sdegutis> my Clojure program is wayyyy slow to compile
19:16:30 <sdegutis> its about 8k lines of clojure
19:16:32 <erikd> sdegutis: about the same as C++ line fot line
19:16:35 <dfeuer> Some are fast to compile; some will take a while.
19:16:47 <sdegutis> and my clojure app takes *minutes* to compile
19:16:51 <sdegutis> does haskell apps?
19:17:01 <maximilian> in what way?
19:17:07 <dfeuer> Compiling Data.Sequence takes a minute or so, I think. Compiling GHC takes a loooong time.
19:17:14 <sdegutis> ok
19:17:49 <sdegutis> im considering writing a web app in haskell its a simple shopping cart website, and i want to gauge how long it should take to compile every time i make a change
19:18:06 <dfeuer> Compiling GHC in a web browser using GHCJS or Haste will take longer :-P
19:18:21 <sdegutis> nooo not haskell -> JS, just plain haskell with http handler
19:18:32 <carter> how many LOC?
19:18:41 <carter> how many modules?
19:18:41 <dfeuer> sdegutis, I meant compiling it *in* the web browser, which is a very strange thing to do.
19:18:42 <geekosaur> different language compilers take different amounts of time to do different things. clojure is looking for ways to work around JVM limitations; C++ is expanding and then resolving layers on layers of templates; Haskell is typechecking and then translating a description of an abstract graph reduction to code that can run on a real machine
19:18:43 <sdegutis> about 8k in clojure, so i imagine probably 6k in haskell
19:18:48 <sdegutis> dfeuer: no thats weird
19:18:56 <sdegutis> carter: about 20 small-ish modules
19:18:58 <joness> sdegutis you don't have to recompile on every change. you can use ghci during development
19:19:05 <joness> that is what i do anyway
19:19:10 <sdegutis> joness: we tried that route with clojure and its ugh just such a pain
19:19:13 <dfeuer> geekosaur, type checking is *usually* fast. Optimization time *usually* dominates.
19:19:19 <carter> assuming you're not doing anything crazy, probably 5-20 seconds on  build
19:19:25 <dfeuer> But there are exceptions.
19:19:28 <sdegutis> carter: aesome thanks
19:19:32 <joness> sdegutis what was the issue? I don't know clojure
19:19:35 <carter> sdegutis: basically, just do stuff
19:19:36 <sdegutis> carter: *æwsome
19:19:40 <carter> instead of armchair asking :)
19:19:46 <dfeuer> sdegutis, compiling without optimization is *usually* fast.
19:19:50 <carter> sdegutis: measuring is faster than asking for the types of questions you're asking :)
19:20:00 <sdegutis> joness: namespaces that had errors were getting unloaded and then not re-loaded again once they were fixed until i restarted the whole thing
19:20:08 <erikd> sdegutis: a simple yesod webapp takes < a minute to compile on a decent machine. my 50k loc web app with a couple of helper programs takes about 5 min
19:20:12 <sdegutis> carter: lol sure but a ball park helps
19:20:16 <carter> nope
19:20:21 <carter> sdegutis: get off IRC and ship :)
19:20:22 <carter> sorry
19:20:29 <sdegutis> yeah huh called it no callbacks
19:20:41 <sdegutis> (times infinity)
19:20:54 <dfeuer> sdegutis, listen to carter. His advice is almost always sensible.
19:21:05 <sdegutis> yes i know that
19:21:07 <carter> dfeuer: thankee
19:21:11 <sdegutis> im well aware
19:21:14 <carter> sdegutis: you're like a miniature SrPx
19:21:28 <sdegutis> i am 6'4"
19:21:32 <joness> sdegutis ghci will give you a fresh start every time you reload your code. so there are no issues like that
19:21:39 <sdegutis> joness: thats fair then
19:21:42 <sdegutis> ill probably go that route
19:21:58 <sdegutis> is this chapter largely self-explanatory?  http://learnyouahaskell.com/higher-order-functions
19:22:06 * dfeuer scared Cale away.
19:22:07 <carter> sdegutis: try it and find out
19:22:13 <carter> and also use the learn haskell metaresource
19:22:15 <SrPx> sdegutis: you have the right concerns sdegutis go on!! :)
19:22:18 <carter> and bank the keeboard :)
19:22:22 <carter> *bang
19:22:25 <sdegutis> carter: that defeats the point of trying to save time
19:22:28 <geekosaur> lyah is supposed to be self-explanatory. at least some parts of it seem to be bad at it, though
19:22:42 <dfeuer> KEYBOARD
19:22:50 <sdegutis> i just dont know how far to skip ahead
19:22:51 <carter> dfeuer: high five!
19:23:01 <sdegutis> i get that it auto-curries functions, no need to read a whole chapter that just explains that
19:23:05 <carter> dfeuer: coding your way through the snow storm
19:23:09 <carter> ?
19:23:09 <dfeuer> carter will help me find the package I want!
19:23:26 <dfeuer> carter, I'm trying to learn how to use databases, but keep getting distracted by data structures.
19:23:42 <carter> dfeuer: oh, mess with sqlite-simple and direct-sqlite in ghci
19:24:04 <carter> dfeuer: actually, that'd be a really neat project, making some wrappings around those tow libs so they're liek a sqlite-console when in ghci
19:24:42 <dfeuer> carter, I shaved ~20% off the time of Math.Sieves.ONeill by specializing to Word, unboxing some things, strictifying some things, and replacing lists with infinite streams. But I would like to do better. I suspect there is much room to improve the priority queue.
19:24:55 <carter> hrmm
19:25:01 <carter> dfeuer: is word big enoug?
19:25:08 <dfeuer> carter, I have only the *barest* clue of what SQL is about thus far.
19:25:15 <dfeuer> carter, for 32-bit, no.
19:25:23 <carter> ?
19:25:25 <sdegutis> why is a space not necessary here divideByTen = (/10)
19:25:30 <dfeuer> For 64-bit, for this algorithm, yes.
19:25:35 <geekosaur> most people don't have a clue what SQL is about...
19:25:47 <geekosaur> (often because SQL itself doesn't seem to be quite sure...)
19:25:57 <carter> sdegutis: because the language grammar says so
19:26:04 <sdegutis> is it allowed?
19:26:11 <zwer> yes
19:26:11 <carter> https://www.haskell.org/onlinereport/haskell2010/
19:26:13 <sdegutis> yay
19:26:15 <dfeuer> carter, for 32-bit, 30<=finiteBits (0::Word) <= 32, which is not very much.
19:26:22 * SrPx grabs popcorn
19:26:53 <sdegutis> what's the best database to use with haskell?
19:26:53 <carter> dfeuer: whats the use case
19:26:57 <sdegutis> like for a web app
19:27:00 <sdegutis> i assume datomic?
19:27:02 <carter> sdegutis: depends on the workload
19:27:04 <dfeuer> This sieve, however, will take a *long* time to go over 64 bit Word--at an optimistic 1ns per number off the wheel, it will take over a year.
19:27:08 <carter> sdegutis: now you're just being a troll
19:27:15 <sdegutis> no cuz datomic is functional
19:27:22 <sdegutis> but yes, the datomic part was about 40% a joke
19:27:36 <zwer> sdegutis by the way, unlike in ocaml, both (\10) work (10\), and do different things
19:27:37 <carter> sdegutis: humor goes on #haskell-blah
19:27:38 <erikd> sdegutis: Persistent which has sqlite, mysql, postgres etc backends
19:27:39 <sdegutis> datomic has an api that is best used within clojure and is ugly elsewhere, so i assume not datomic
19:28:00 <dfeuer> carter, I don't actually know what this is for. One possible thing is to try to do something about the utter shit one in arithmoi.
19:28:04 <sdegutis> erikd: awesome
19:28:11 <zwer> both (/10) and (10/, even
19:28:14 <sdegutis> zwer: whoa
19:28:28 <zwer> > (/10) 20
19:28:29 <lambdabot>  2.0
19:28:31 <sdegutis> zwer: i dont know what (/10) does -- is that just the same as (/) 10 ?
19:28:33 <zwer> > (10/) 20
19:28:35 <lambdabot>  0.5
19:28:45 <carter> dfeuer: once i'm done with dealing with new job lawyers id love to help clean up arithmoi
19:28:49 <dfeuer> carter, really, I don't know what people need prime numbers for, but they've spent a good bit of time trying to make these things reasonably fast.
19:28:50 <geekosaur> (/10) is flip (/) 10
19:28:58 <carter> dfeuer: crypto and pretty things
19:29:03 <geekosaur> basically it's partial application of an operator
19:29:06 <carter> a littla of column a and column b
19:29:08 <sdegutis> wow cool
19:29:21 <zwer> sdegutis, (/10) is the same as (\x -> x/10) and (10/) is the same as (\x -> 10/x)
19:29:30 <geekosaur> we're applying the *second* parameter, because operator syntax lets us do that succintly whereas we'd need flip to do it with a prefix function
19:29:50 <dfeuer> carter, some of the Sieve of Eratosthenes code in arithmoi currently segfaults, and I think it highly unlikely that anyone is smart enough to be able to untangle it enough to debug. It will have to be rewritten from scratch one way or another.
19:29:54 <carter> ewww
19:29:56 <carter> yeah
19:29:58 <carter> agreed
19:30:00 <sdegutis> zwer: i have absolutely no idea what (\x -> x/10) is unless its just syntax for an anonymous function that takes x and returns x / 10
19:30:11 <geekosaur> that is indeed what it is
19:30:18 <sdegutis> well then there you go
19:30:23 <sdegutis> thanks geekosaur
19:30:32 <sdegutis> i havent gotten to the chapter that explains how to make anon fns yet
19:30:49 <mietek> sdegutis: compiling a change to your web app should take 30-40 seconds.
19:30:53 <mietek> https://halcyon.sh/tutorial/#make-a-change
19:31:00 <sdegutis> mietek: wow that is loooong
19:31:13 <sdegutis> mietek: but i assume there are tricks to optimize this, e.g. maybe using ghci during development
19:31:49 <mietek> Yes, it depends on a lot of factors.
19:32:41 <mietek> And it also depends on what exactly you mean by "compiling".
19:32:59 <mietek> Anyway, if you want to build web apps in Haskell, perhaps you should join #haskell-deployment.
19:34:18 <mietek> Here’s a few "Hello, world!" apps to get you started, each using a different Haskell web framework: https://halcyon.sh/shootout/
19:37:46 <joness> after initial load reloading the code in ghci takes two seconds for a 5K program
19:38:39 <joness> first load takes 15 or so seconds, mostly for loading all the modules that the program uses
19:39:17 <osa1_> hm can I generate type signatures for functions using TH?
19:39:51 <osa1_> looks like FunD doesn't allow this
19:40:16 <glguy> osa1_: sigD
19:40:37 <osa1_> thanks
19:41:08 <glguy> observe that the top-level splices expect a "DecsQ" aka Q [Dec]
19:41:34 <glguy> So you get to return multiple Dec s, you can have the sigD come just before the funD
19:42:08 <osa1_> cool, thanks
19:51:17 * hackagebot cabal-test-bin 0.1.3 - A program for finding temporary build file during cabal-test.  http://hackage.haskell.org/package/cabal-test-bin-0.1.3 (junjihashimoto)
19:53:06 <sdegutis> Why should we use fmap instead of map?
19:53:25 <johnw> sdegutis: when you don't know if it will be a list
19:53:32 <johnw> or if fmap is the only mapping operation for that type
19:53:38 <sdegutis> oh because this guy says so http://www.stephendiehl.com/what/#prelude
19:53:39 <johnw> fmap works great on Maybe's, for example
19:54:08 <Cale> It would be nice if map were simply Functor's method like it was in Haskell 1.4
19:54:32 <Cale> There are some cases where having it be specialised to lists helps with ambiguity, but I really don't think it's that often
19:54:47 <johnw> agree
19:54:53 <SrPx> Are there instances for: 1. can be indexed (i.e., [1,2,3] !! 0 == 1), and 2. can be indexed impurely (i.e., unsafeRead)
19:55:01 <dfeuer> There is another reason, but it's icky.
19:55:35 * Cale looks over the stuff he missed...
19:56:03 <sdegutis> Do any of you's work with Haskell full-time for a living?
19:56:07 <dfeuer> The other reason: fmap doesn't turn into map immediately. The first round of rules actually get to go first, turning map into a build/foldr form. This can change optimization.
19:56:11 <carter> some folks here do yes
19:56:12 <Cale> dfeuer: I have no idea man :D
19:56:20 <Cale> (about the 2-3 trees thing)
19:56:51 <Cale> dfeuer: Most of the time, if something works and it's remotely efficient to use stock stuff from containers, I'm happy.
19:57:00 <geekosaur> I don't; I work with C and a little Perl during the day. Hacking on xmonad and hanging around in here helps balance out the annoyance of dealing with C
19:57:47 <Cale> drazak: Yeah, it's a bit concerning for someone not to be familiar with surjective/injective, even if technically it's not a huge deal if you use other terms for them.
19:58:10 <drazak> Cale: she thought it was an older term :/
19:58:42 <Cale> sdegutis: My last few jobs have all been Haskell jobs
19:59:00 <sdegutis> is there a good job market for haskellians?
19:59:02 <Cale> I should really look for another one soon... I'll probably have to move to Boston or something
19:59:11 <sdegutis> Cale: why?
19:59:16 <sdegutis> Cale: why not work remote?
19:59:24 <carter> because the market is smaller
19:59:40 <carter> a lot of orgs, whaever the reason, like people in person
19:59:41 <Cale> Well, working remotely would be ideal, I suppose.
20:00:04 <Cale> But yeah, it's way easier to get things if you can show up in person.
20:00:05 <sdegutis> do it
20:00:29 <drazak> Cale: definitely if you have to work with specialists
20:00:43 <Cale> and there are sizeable Haskell communities in Boston and a few other places such that I'd consider moving just to be more involved I suppose.
20:00:44 <dfeuer> It's also easier to work with people face to face.
20:01:04 <carter> communication etc
20:01:04 <drazak> Cale: for some reason I thought you had an SO
20:01:07 <Cale> But I'm terrible about such things
20:01:15 <Cale> nope, not atm :)
20:01:17 <dfeuer> Cale, that could be tricksy for you, no? Canadians get the same crap treatment the U.S. gives everyone who comes across the border.
20:01:32 <Cale> dfeuer: Yeah, possibly.
20:01:35 <Cale> I don't know
20:01:41 <Cale> We do have agreements though
20:01:51 <dfeuer> Cale, definitely. My brother's GF is Canadian, and it's *painful*.
20:01:52 <carter> its simpler probably
20:01:55 <Cale> Like, there's a tax treaty
20:02:06 <drazak> need to get a work visa I guess
20:02:11 <drazak> or take osme classes at MIT
20:02:17 <Cale> So I can just pay my Canadian taxes even if my employer is in the US
20:02:28 <dfeuer> Ah, well that's nice.
20:02:42 <dfeuer> But I can pretty much promise some level of suffering.
20:06:30 <drazak> are you gonna be affected by the noreaster cale?
20:06:56 <johnw> i'm in boston right now, and the snow outside my window isn't too bad right now
20:06:58 <Cale> We have snow, but it's normal amounts of snow
20:07:02 <johnw> s/right now//
20:07:17 <johnw> visibility out of my window is still several hundred fee
20:07:18 <johnw> t
20:07:23 <Cale> Though for some reason, everyone is staying in anyway, lol
20:07:27 <johnw> forecast said it would be 2 feet by now
20:07:27 <drazak> I'm from buffalo (and there now) so I kinda have the whole Bain style snow thing
20:07:42 <Cale> I just went up to the store to get some things and it was dead outside, even though the weather wasn't all that bad
20:07:42 <johnw> what is Bain snow?  it wears a mask?
20:07:43 <drazak> if we are getting less than a foot and a half it's not really a thing
20:08:37 <drazak> johnw: nah, "Oh, you think darkness is your ally. But you merely adopted the dark; I was born in it, moulded by it. I didn't see the light until I was already a man, by then it was nothing to me but BLINDING! " with s/dark/snow/g for the most part
20:09:31 <drazak> and s/light/warmth/ etc
20:10:28 <dfeuer> Cale, containers has very few data structures, which strikes me as rather strange. I'd like it to be split in three and then turn into a meta-package dragging in a wider variety.
20:10:41 <dfeuer> It has no priority queues, for example.
20:10:48 <dfeuer> At all.
20:10:51 <Cale> dfeuer: Yeah, and really Data.Map and Data.Set are the only two I care about :P
20:11:18 * hackagebot paypal-adaptive-hoops 0.5.3.0 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.5.3.0 (fanjam)
20:11:47 <Cale> dfeuer: I guess Data.Sequence is nice in theory, but in cases where I've tried to put it to use, the difference was less than worth the trouble.
20:11:58 <dfeuer> Cale, I find it rather astonishing that there are at least two packages on Hackage that offer priority queues implemented on Data.Map. LAZY.
20:12:17 <Cale> Though I really like Data.FingerTree as a way of getting asymptotically good structures of more exotic sorts.
20:12:35 <Cale> Data.Map is really good though!
20:12:41 <dfeuer> Cale, difference from lists? It probably depends on how much splitting and merging you're doing, with what sort of persistence and all.
20:13:30 <Cale> Yeah, the problem is that it has some pretty hefty constant factors even if the asymptotics look good
20:14:45 <Cale> I'm sure there are cases where it's applicable, it's just been less useful to me personally than I'd have hoped
20:15:28 <dfeuer> Cale, that makes sense. But that's one reason to include other sorts of sequences, like output-restricted deques, random-access lists, etc., etc.
20:15:40 <dfeuer> Better constant factors for less flexibility.
20:16:34 <dfeuer> There are some really careful implementations of some things on Hackage, but finding the *right ones* can be a challenge.
20:16:46 <dfeuer> Also floating around GitHub, which is impossible.
20:17:36 <EvanR> is there a channel for vim haskell plugins
20:18:34 <EvanR> i installed haskellmode vimball and its eating the bottom 3 lines of my display (replaced with blankness) for no reason
20:19:16 <carter> EvanR: pester the author?
20:23:14 <Zemyla> I think I came up with the stupidest, most pointless sort function in Haskell ever.
20:23:38 <benzrf> Zemyla: go on
20:23:45 <Zemyla> @pl fix $ \f l -> maybe [] (\_ -> let m = foldl1 min l in m : (f $ filter (/= m) l)) $ foldr (\x _ -> Just x) Nothing l
20:23:46 <lambdabot> fix ((`ap` foldr (const . Just) Nothing) . ((maybe [] . const) .) . (`ap` foldl1 min) . (ap (:) .) . (. flip (filter . (/=))) . (.))
20:24:21 <mmachenry> What is the @pl feature of lambda bot?
20:24:31 <mmachenry> Right this in point-free style?
20:24:40 <Zemyla> It removes all the lambdas in code.
20:24:43 <mmachenry> Write
20:24:59 <EvanR> its one way to write it in point free style, usually a very terrible way
20:28:24 <Zemyla> EvanR: Are there better ways?
20:28:27 <shelf> @pl \b a -> a ++ b
20:28:27 <lambdabot> flip (++)
20:28:30 <shelf> oh that is fun
20:29:14 <EvanR> Zemyla: i dont know
20:29:24 <geekosaur> there are. some @pl just doesn't know about (for example it doesn't know Applicatives at all), some just require more clever transformations than @pl is really capable of
20:30:28 <geekosaur> as someone remarked earlier, optimization is generally the slowest part of ghc compilation --- and pointfree is in some sense a form of optimization (and ghc indeed does some amount of it when optimizing)
20:31:16 <geekosaur> but you don't want the bot to spend possibly several minutes applying algorithms that can come up with the best pointfree rewrite, like you'd be willing to put up with from a compiler
20:31:44 <geekosaur> and the result might still look terrible (this is why we hide them in the compiler... so we can write readable code and it can optimize it into gobbledygook)
20:38:04 <kranius> @undo do { foo <- bar; baz foo}
20:38:04 <lambdabot> bar >>= \ foo -> baz foo
20:38:32 <Iceland_jack>     bar >>= \foo -> baz foo
20:38:32 <Iceland_jack>     ==
20:38:32 <Iceland_jack>     bar >>= baz
20:39:08 <fikse> is it a bad idea to store and retrieve data in mongodb, why should one use a sql store instead?
20:39:08 <geekosaur> @. pl undo do { foo <- bar; baz foo}
20:39:09 <lambdabot> baz =<< bar
20:40:26 <geekosaur> fikse, mongodb is problematic because it is neither significantly faster nor more reliable than an SQL data store, and it limits how you can process that data once it's in the database.
20:40:48 <geekosaur> and getting its reliability up eats up the few performance advantages it offers
20:41:18 <geekosaur> that said, it can (but only "can", not necessarily "does") offer a simpler interface
20:41:25 <EvanR> after just finishing a stint using a no-sql-database-of-the-week i am very suspicious now, less support, less community, less structure, less between the (model-less, raw) storage and the application
20:41:27 <fikse> maybe i should have been more general, i'm really comparing postgresql and rethinkdb
20:41:30 <gonzaw> Hi. I've asked this before, wonder if someone else can get some input on this
20:41:41 <gonzaw> I've recently started reading about dynamic programming using recursion schemes
20:41:44 <gonzaw> specially this paper
20:41:44 <gonzaw> http://kodu.ut.ee/~eugene/kabanov-vene-mpc-06.pdf
20:41:50 <EvanR> im not going with postgres for basically anything real
20:41:53 <EvanR> im now*
20:42:08 <gonzaw> I wonder how to actually implement those examples in haskell
20:42:20 <geekosaur> rethinkdb I am not familiar with; I was speaking specificaly about mongodb, which is well known to have a number of flaws
20:42:55 <gonzaw> The paper is titled "Recursion Schemes for Dynamic Programming"
20:43:16 <geekosaur> for me, the biggest issue with nosql is that it's great for getting high volume data in and out, but lousy for doing anything useful with that data. that said, I used to be a traditional DBA and that colors my experience a bit
20:43:17 <bitemyapp> geekosaur: I can't speak to how robust it is, but as a client implementor, RethinkDB is much better designed.
20:43:17 <gonzaw> My main questions are
20:43:22 <kranius> @type (=<<)
20:43:24 <lambdabot> Monad m => (a -> m b) -> m a -> m b
20:44:08 <geekosaur> (although the database I had the most experience with didn't acquire a generally useful SQL interface until fairly late in its history)
20:44:15 <gonzaw> 1)How do you implement a dynamorphism? I've read that its type is "dyna :: Functor f => (f (Cofree f c) -> c) -> (a -> f a) -> a -> c", but dunno how it would be implemented efficiently
20:44:29 <EvanR> how well it can move raw key-values-or-whatever around, it has to be easy to use from a client perspective, and easy to get support on when things go WTF
20:44:42 <EvanR> and easy to model your domain
20:45:07 <gonzaw> 2)Are there more examples that allow you to grok dynamorphisms easily? Like taking the examples from the paper (it's harder to grok them using categorical notation)
20:45:45 <EvanR> a cleaner implementation plus a nice video doesnt really cut it
20:46:02 <gonzaw> 3)Can this be done efficiently? If I try to implement edit distance using arrays and memoization on one hand, and recursion schemes on the other, can the implementation using dynamorphisms be as fast as the 1st one?
20:48:49 <benzrf> what does Cofree look like
20:49:18 <bitemyapp> benzrf: black usually. Sometimes it's steaming hot.
20:49:38 <geekosaur> >.>
20:50:03 <benzrf> bitemyapp: thats my joke, shoosh
20:50:43 <pavonia> I prefer my Cofree with some syntactic sugar
20:51:27 <gonzaw> I swear to god I initially thought it was indeed "Coffee"
20:51:28 <benzrf> ba d u m pish
20:51:34 <benzrf> gonzaw: i keep doing that :c
20:51:41 <bitemyapp> gonzaw: that's what makes this so much fun.
20:52:10 <gonzaw> Then I saw a bunch of blogs about how "Cofree comonads are dual to Free monads" and didn't understand shit
20:52:15 <gonzaw> then came the "oh...." moment
20:53:41 <benzrf> data Cofree f a where Extract :: f a -> Cofree f a; Duplicate :: f a -> Cofree f (f a) -- ????
20:53:48 <carter> bitemyapp: /me mumbles something about joins being nice
20:54:23 <gonzaw> I wonder what the Tea monad tastes like
20:54:44 <EvanR> like a burrito
20:55:06 <gonzaw> Goes well with some Cookie functors too
20:55:17 <HeladoDeBrownie> i notice cabal likes to use four places for version numbers w.x.y.z. what is each for? major/minor/?/?
20:55:47 <bitemyapp> HeladoDeBrownie: https://wiki.haskell.org/Package_versioning_policy
20:55:55 <HeladoDeBrownie> i was really surprised because i encountered a library that has an api change on the third one
20:56:05 <HeladoDeBrownie> bitemyapp, thanks
20:56:33 <carter> major.major.minor.patch
20:56:37 <bitemyapp> HeladoDeBrownie: np
20:56:46 <carter> minor can add, but cant remove
20:57:02 <carter> roughly: if you improve a package qualified, a minor version bump cant break anything
20:57:04 <HeladoDeBrownie> got it, yeah, that's what happened
20:57:25 <HeladoDeBrownie> i was looking at docs for a slightly later version than i had and it noted something was deprecated but the thing it suggested instead i couldn't use because it's not in the version i have
20:58:46 <SrPx> When you have a container that can hold a container (example: my octree is parameterized on V2, V3, etc). What is the best way to do it? "data Container f a = Foo f a; Foo (V3 1 2 3) :: Foo V3 Float" or "data Container f a = Foo (f a) a;  Foo (V3 1 2 3) :: Foo (V3 Float) Float"
20:59:11 <SrPx> err, Container should be Foo here, since that is the name of the type. But you get it
21:00:17 <carter> both are valid styles
21:01:23 <pavonia> If you have "Foo (f a) a" you need an extra argument of type a
21:08:08 <SrPx> Eh, I'm getting trouble converting to the second one, though...
21:08:20 <SrPx> Is this wrong? getContainer :: (Foldable (f a), Functor (f a), Num a, Ord a, RealFrac a) => SpaceTree (f a) b -> f a -> V.Vector (Element (f a) b)
21:08:28 <SrPx> Expecting one more argument to ‘f a’     Expected a type, but ‘f a’ has kind ‘* -> *’
21:10:04 <pavonia> The second parameter has to be a type
21:10:26 <SrPx> uh?
21:10:56 <carter> value types have kind *
21:11:01 <pavonia> "f a" is not a type but a type constructor
21:11:08 <carter> functors have kind * -> *
21:11:19 <carter> because you apply a functor to a type, to get a type
21:12:11 <SrPx> why is "f a" not a type? "f" here is V3, "a" here is Double, for example, right? so "f a" = "V3 Double" which is a type
21:12:15 <SrPx> no?
21:12:48 <pavonia> What is V3 here?
21:13:24 <glguy> SrPx: Perhaps you could put some code on lpaste to help people see what you're asking about
21:13:32 <SrPx> btw disregard the last one, I've pasted my types: http://lpaste.net/119284
21:13:43 <SrPx> glguy: (=
21:13:44 <glguy> and then define what you mean by "best" What are you optimizing for? Flexibility? Generality? Speed?
21:14:10 <pavonia> "f a" cannot be a type and a Functor at the same time
21:14:48 <SrPx> glguy: don't mind that, I want the second option since that is how my other lib is. I used different styles and didn't notice. I'm just having trouble converting it.
21:15:02 <SrPx> pavonia: ahh I see
21:15:51 <SrPx> No, wait, I don't? [Int] is a functor, no?
21:16:06 <pavonia> No
21:16:19 <SrPx> ah no of course... but then... hmm
21:16:35 <SrPx> ah fixed it
21:16:39 <SrPx> obvious now, my bad and thanks
21:16:40 <SrPx> :)
21:42:18 <fread2282> are there any resources/a commonly accepted way to represent primitive ops in the ASTs of functional languages?
21:46:32 <kranius> fread2282: what do you mean ?
21:46:36 <fread2282> jus embedding BindIO/PureIO/FFI as AST constructors would work, but not really: 1. I don't want to force IO mond for FFI, 2. there are other "primitive" things such as Type (do you encode it as Type (levelexpr) or Type :@ levelexpr in the AST?), 3.. imo the `data IO a = IO args (resp -> a)` is more natural, but then also where do you put sequencing?
21:47:45 <tel-> fread2282: reminds me a bit of http://comonad.com/reader/2011/free-monads-for-less-3/
21:47:48 <fread2282> kranius: do you special case for IO in your AST? if so, how? if not, what about Type, lmax, lsucc, etc
21:48:43 <jonsterling> fread2282: I would just give each primitive thing it's own op code.
21:49:31 <tel-> jonsterling: assuming you know them all ahead of time, otherwise you probably want a 'call' op
21:50:33 <SrPx> Okay I get how to make it work now, but are you guys sure that something like: "tree :: SpaceTree V3 Double Int" is a linguistic way to state "tree is a spacetree of 3D vectors of double, holding int values"? I'm suspicious since I've never seem that pattern.
21:50:37 <jonsterling> tel-: Yeah, you might have to resort to that, particularly if you are trying to do ffi.
21:51:16 <fread2282> how do you encode it? `FFI [Expr] Expr -- args, callback` ?
21:51:57 <fread2282> and how do you make it play nice w/ lazy evaluation?
21:54:26 <tel-> fread2282: Start with something like FFI Name [Expr] (Expr -> Expr)?
21:54:54 <kranius> reminds me of this, http://www.haskellforall.com/2012/07/free-monad-transformers.html
21:55:23 <fread2282> tel-: if HOAS, sure
21:56:20 <tel-> fread2282: You need to be able to refer to the return of the FFI call in a subsequent Expr somehow. Choose your own binding mechanism.
21:57:28 <ReinH> jonsterling: o/
22:00:12 <jonsterling> ReinH: Heh... Come join me in my new kingdom, #haskell-unpleasantness
22:01:18 <platz> beetlejuice beetlejuice beetlejuice!
22:06:00 <minsheng> Hello everyone! I am new to Haskell world. I hope to write one piece of code to produce both html forms and validation codes. I intend to run my code within two monads:  one is a state monad to produce a HTML form; the other is an EitherT to verify posts from clients. I am currently making the state monad part.  However, I got an error. It seems that runState rejects my code. My code is here: http://lpaste.net/119287
22:06:11 <minsheng> I would like to know if this approach (running the same code within different moands) is feasible and, if so, how to make runState run my computations?
22:14:26 <monochrom> minsheng: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/85652/focus=85653 is somewhat related
22:15:18 <minsheng> thanks
22:23:59 <Zemyla> Well, that's a bug.
22:24:03 <Zemyla> :t \x -> (x \\) . (x \\)
22:24:05 <lambdabot> Eq a => [a] -> [a] -> [a]
22:24:08 <Zemyla> @pl \x -> (x \\) . (x \\)
22:24:09 <lambdabot> (line 1, column 10):
22:24:09 <lambdabot> unexpected "\\"
22:24:09 <lambdabot> expecting variable, "(", operator or ")"
22:24:30 <Zemyla> Lambdabot doesn't recognize the function in pl.
22:25:21 <glguy> bummer, we'll have to disable ?pl
22:26:25 <horny-sama> https://github.com/mr-fool/haskell/blob/master/temperature/temperature.hs <--- need some help :<
22:27:13 <glguy> Do you understand what's going on there?
22:27:51 <horny-sama> glguy: more or less
22:28:07 <horny-sama> if I understand what's going on there then the error probably won't occur in the first place
22:28:31 <glguy> The "Fractional" constraint comes from the 1.8 literal
22:28:44 <genisage> :t (* 1.8)
22:28:45 <lambdabot> Fractional a => a -> a
22:28:57 <fread2282> horny-sama: Rational is the arbitrary-precision builtin fraction type, represented as a fraction of Integers. it looks like you want some type of fractions (Int is only whole numbers), and Rational is a good default
22:28:59 <glguy> and Int isn't Fractional (because it only does whole numbers)
22:29:46 <fread2282> horny-sama: note that (show someRational) gives you a ratio and not a decimal
22:29:58 <horny-sama> glguy: changing     let celsius = read temperature :: Double does not help either
22:29:59 <horny-sama> :<
22:30:35 <fread2282> horny-sama: what error does Double give?
22:30:54 <glguy> horny-sama: Save the file
22:31:00 <horny-sama> cels2fahr celsius = celsius * 1.8 +32 <----works perfectly in ghci
22:31:32 <Axman6> it shouldn't...
22:31:40 <Axman6> that's an infinitely recursive function
22:31:46 <Axman6> > let x = x + 1 in x
22:31:50 <lambdabot>  mueval-core: Time limit exceeded
22:31:57 <Axman6> oh, I missed the first bit >_<
22:31:59 <horny-sama> glguy, fread2282 updated https://github.com/mr-fool/haskell/blob/master/temperature/temperature.hs
22:32:03 * Axman6 is wrong and will be quiet again
22:32:16 <glguy> horny-sama: You changed two things, the :: Double
22:32:29 <glguy> but then you moved cels2fahr celsius to its own line
22:32:34 <glguy> and stopped showing it and printing it
22:32:55 <horny-sama> glguy: cels2fahr celsius is calling it
22:33:34 <glguy> You can't execute a Double
22:33:49 <horny-sama> updated
22:33:54 <horny-sama> and it seems to work
22:35:32 <horny-sama> hopefully doing small haskell exercise will help me get better
22:37:59 <glguy> seems likely :)
22:40:33 <horny-sama> glguy: after all those haskell practice, I still have my doubt in my haskell skill
22:43:05 <glguy> Well, you're still learning. You should have doubts about your skills, they aren't strong yet, but that's OK because its how learning works :)
22:43:45 <horny-sama> glguy: I am freaking out on my assignment
22:44:06 <horny-sama> apparently I know the most haskell in my team which is still inadequate for my assignment :<
22:44:21 <bitemyapp> horny-sama: what school, if you don't mind my asking?
22:44:30 <horny-sama> bitemyapp: make a guess first
22:44:31 <horny-sama> :P
22:44:40 <bitemyapp> horny-sama: UNSW
22:44:44 <horny-sama> na
22:44:57 <horny-sama> bitemyapp: want a second guess before I reveal it?
22:45:03 <bitemyapp> horny-sama: pls no. Go ahead.
22:45:12 <horny-sama> bitemyapp: university of calgary
22:45:26 <horny-sama> pretty much every cad uni requires you to learn haskell nowadays
22:45:32 <benzrf> cad?
22:45:34 <bitemyapp> o really?
22:45:41 <horny-sama> benzrf: cad = canada
22:45:47 <bitemyapp> very interesting
22:45:48 * bitemyapp jots notes
22:45:51 <bitemyapp> horny-sama: thank you!
22:46:00 <horny-sama> bitemyapp: yes university of british columbia is required too
22:46:09 <horny-sama> bitemyapp: why?
22:46:28 <bitemyapp> horny-sama: I'm working on a book for learning Haskell.
22:47:14 <bitemyapp> horny-sama: I want to confer with TAs/profs about making the book suitable for university courses that require learning Haskell.
22:47:20 <horny-sama> bitemyapp: https://github.com/kqr/kqr.github.com/tree/master/_posts has the best guide I have read so far
22:47:41 <horny-sama> bitemyapp: personally, I don't think haskell will take off within 5 yrs
22:48:06 <bitemyapp> horny-sama: there are enough libraries that it's already quite nice for my purposes.
22:48:21 <horny-sama> bitemyapp: as in industrial use
22:48:31 <bitemyapp> horny-sama: I use it for industrial purposes.
22:48:49 <horny-sama> bitemyapp: may I ask like what?
22:48:51 <bitemyapp> I know most programmers want their node.js whizbang whatevers, but I don't really need world domination for Haskell to be useful to me. It's useful to me now.
22:48:53 <glguy> Yeah, it's already got industrial use. Won't have to wait 5 years
22:49:04 <bitemyapp> horny-sama: web backends. Haskell is more popular in industry than you may realize.
22:50:00 <horny-sama> bitemyapp: I thought web backends = C world
22:50:01 <horny-sama> lol
22:50:36 <horny-sama> or c++
22:50:36 <bitemyapp> horny-sama: are Ruby/Python/PHP/Java/Scala/Erlang in the C world in your mind?
22:50:49 <horny-sama> bitemyapp: no
22:50:59 <bitemyapp> well those are used for a lot of the same tasks.
22:51:14 <bitemyapp> C/C++ are only really needed if you're doing embedded/hard real-time stuff.
22:51:34 <horny-sama> bitemyapp: for me, I need to bush up on my C skill coz I have a c interview on friday
22:52:54 <bitemyapp> horny-sama: remember: main is usually a function.
22:53:15 <bitemyapp> horny-sama: try to memorize the hundreds of possibilities for undefined behaviors in the standard :)
22:53:46 <horny-sama> bitemyapp: personally, I don't really have a prefer language
22:53:54 <horny-sama> I use what I am told
22:53:55 <horny-sama> period
22:54:42 <bitemyapp> horny-sama: engineering is traditionally a professional field
22:54:59 <horny-sama> bitemyapp: not an engineer
22:55:01 <bitemyapp> horny-sama: if we think software is engineering or otherwise a profession, we should take responsibility for the tools and methods used in our work.
22:55:02 <horny-sama> a computer scientist
22:55:08 <bitemyapp> horny-sama: all the same - profession.
22:56:34 <horny-sama> bitemyapp: fyi, you should read the java license part on usage. It is pretty interesting ""You acknowledge that Software is not designed, licensed or intended for use in the design, construction, operation or maintenance of any nuclear facility."
22:57:07 <horny-sama> http://www.oracle.com/technetwork/java/javase/downloads/jre-6u21-license-159054.txt <----full license agreement
22:57:48 <horny-sama> wonder if you can use haskell for nuclear facility :P
22:59:22 <R0b0t1> horny-sama: get used to people not bothering to read the book
22:59:26 <sgronblo> usually a function?
22:59:56 <horny-sama> R0b0t1: you think haskell has the same restriction on nuclear facility
22:59:57 <horny-sama> lol
23:00:44 <glguy> sgronblo: I'm guessing it's a reference to https://www.reddit.com/r/programming/comments/2tt72b/main_is_usually_a_function_so_then_when_is_it_not/
23:00:45 <minsheng2> Strangely disconnected. Hope I didn't miss anything.
23:01:08 <horny-sama> minsheng2: you missed the licensing talk
23:01:14 <R0b0t1> doubtful, the java terms are probably due to something like ITAR/nuclear antiproliferation/etc. Like how you can't use iTunes to build ICBMs. (kind of offtopic though)
23:01:37 <fread2282> sgronblo: tl;dr: can be arbitrary bytes, will just copy them to the executable
23:01:38 <horny-sama> R0b0t1: itunes is not a language
23:01:39 <horny-sama> :P
23:01:52 <R0b0t1> if much of the haskell codebase was made by people in the US it might have similar issues to PGP/OpenBSD/that other one.
23:02:06 <horny-sama> R0b0t1: like what?
23:02:09 <R0b0t1> or rather the people who wrote it would have issues
23:02:45 <R0b0t1> the government puts you in jail for "helping terrorists." anyway, like I said, kind of offtopic.
23:02:55 <horny-sama> C is designed by an American in america
23:02:58 <horny-sama> okay
23:02:58 <minsheng2> horny-sama: no, I meant any replies to my question posted under nickname minsheng (it reported "invalid session" and I got disconnected)
23:03:06 <horny-sama> we should stop
23:03:14 <horny-sama> minsheng2: ooo
23:03:19 <horny-sama> you did not miss anything then
23:04:31 <minsheng2> Thanks. I really have no idea of solving this. When I changed the signature to State [String] (String, (String, String)) it worked. However, I intended to run this in different monads.
23:05:23 <fread2282> the free monads for less article doesn't really relate to my question, & ermine seems to go with the "magic name" approach
23:06:44 <fread2282> or rather it does, but still
23:08:59 <cosban> I'm actually in an irc room with the guy that did it
23:09:03 <cosban> tinder is down as well
23:09:07 <cosban> and hipchat
23:13:51 <zomg> someone suspected it was a problem with amazon but our aws instances are still reachable
23:20:21 <SrPx> Uhm thoughts? http://lpaste.net/119288
23:21:36 <johnw> the unfoldable thing has been attempted before
23:21:42 <johnw> I think it was called Buildable
23:26:06 <minsheng2> I removed the type signature and it works. I don't know why…
23:28:24 <monochrom> then you can ask ghci for the inferred type, and compare with your conceived type
23:32:00 <SrPx> hmm i see johnw thanks
23:41:28 * hackagebot deepseq-bounded 0.6.0.1 - Bounded deepseq, including support for generic deriving  http://hackage.haskell.org/package/deepseq-bounded-0.6.0.1 (AndrewSeniuk)
