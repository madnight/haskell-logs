00:18:41 <ddellacosta> ugh, mapping C concepts to Haskell is making my brain hurt.  If I have a C function that takes a char*, and I know from an example that it's an array of int values, does it make sense to construct that using a Data.Vector.Storable and pass in a Ptr to the head of the Vector?
00:19:12 <ddellacosta> (doing FFI here)
00:22:06 <Taneb> ddellacosta, could you use Data.Vector.Storable.unsafeWith?
00:22:46 <ddellacosta> Taneb: I think so?  Was just looking at unsafeToForeignPtr, but maybe that's more appropriate?
00:23:12 <ddellacosta> not entirely clear on the distinction btw. ForeignPtr and Ptr here
00:24:43 <ddellacosta> ugh, this is where my Haskell knowledge breaks down as well: how do I get an IOVector?
00:36:31 <zwer> no idea.. but if you're appending all the elements at once then you can get away with using a list too. prepend them (with a (:)) and then reverse the result
00:38:37 <zwer> (you don't need Seq, that is)
00:39:20 <ddellacosta> zwer: hmm...I think the point I'm stuck at is in actually passing in the right arg to the C fn.  I've got the Vector constructed just fine
00:39:36 <ddellacosta> zwer: and isn't reverse O(n)?
00:41:03 <zwer> yes, but you do it once
00:41:15 <zwer> and prepending is O(1)
00:41:52 <ddellacosta> zwer: right, but isn't it still going to be faster to create a Sequence and put it into a Vector?
00:42:54 <ddellacosta> I suppose I could also build my list in reverse so I don't have to append
00:43:23 <Ralith> they will only differ by a constant factor
00:43:24 <ddellacosta> just curious if I need to if using a Sequence and doing toList then fromList (into Vector) is fast enough
00:43:31 <zwer> I don't know. but this is an improvement over O(log n) per single append that you asked for earlier.
00:43:38 <Ralith> in lieu of profiling, when two approaches differ by a constant factor, do the easiest one to impleemnt
00:44:39 <ddellacosta> adding an element to a Sequence is O(1)
00:44:55 <ddellacosta> Ralith, I'm confused what you mean here in terms of a constant factor
00:46:42 <mason-_> how to get a pointer value (or some other id) of a function?
00:46:51 <ddellacosta> anyways, I just would like to know what the cost is for toList then fromList
00:46:57 <kadoban> ddellacosta: He means, adding n things to a list is O(n), then reversing them is also O(n), for a total of O(n). Using a Seq is also O(n).  O(n) and O(n) only differ by a constant factor, asymptotically.
00:47:32 <haasn> mason-_: You may be interested in http://hackage.haskell.org/package/base-4.7.0.2/docs/Foreign-StablePtr.html
00:47:40 <haasn> But you should probably describe your use case
00:48:30 <ddellacosta> kadoban: what is the O(n) for using a seq--just stating that the add operations are the same?  I see what you/Ralith meant now though, thanks
00:49:03 <kadoban> ddellacosta: Adding n elements to a Seq is O(n).
00:49:13 <ddellacosta> kadoban: right, that's what I thought you meant, got it
00:49:35 <ddellacosta> anyways, at this point I'm overthinking it...haha
00:49:58 <ddellacosta> it's fast enough for now.  Just have to figure out how to freaking use the unsafeWith fn
00:53:14 <mason-_> haasn: thanks that will do
01:07:15 <ddellacosta> so, trying to wrap my head around what IOVector actually is: the implication is essentially that it is coming in from the C function?
01:07:23 <ddellacosta> but otherwise it's just a Mutable Vector?
01:10:54 <solatis> hmmm i have to build some wire protocol that serializes/deserializes a struct with some ByteStrings, but i will have to be able to send more than 1 of those structs over the wire
01:11:11 <solatis> as in, i need to know how many bytes to read / write for each 'chunk'
01:11:31 <solatis> are there any good haskell libraries for this? i was almost thinking about serializing an infinite list, but that would involve lazy i/o..
01:12:08 <ChristianS> solatis: something like cereal maybw?
01:12:31 <solatis> yeah but serial expects to decode a bytestring that exactly matches the encoded struct
01:12:44 <solatis> as in, this is data going over a socket, and can be received in chunks
01:13:03 <pingu> solatis: so what's the structure?
01:13:11 <pingu> youave one message spanning multiple messages?
01:13:50 <solatis> a structure consisting of 3 ByteStrings
01:14:11 <lpaste> solatis pasted ‚ÄúNo title‚Äù at http://lpaste.net/117614
01:14:12 <pingu> solatis: if it's one message and you have to sort of, keep feeding it with more input, I'd suggest pipes with one of the binary parsing libraries
01:14:24 <pingu> that sounds more rigid, though, you probably don't need to go that far
01:14:36 <solatis> hmmm
01:14:44 <pingu> solatis: and what do you want the wire format to look like?
01:14:48 <pingu> three packets of one bytestring each?
01:15:05 <pingu> with/without a length prefix?
01:15:29 <solatis> i just want a high level api that reads the 'next' structure from a socket/bytestring, and returns the remainder, basically
01:15:57 <pingu> binary will do that for you
01:15:58 <solatis> maybe pipes is the best solution here
01:16:02 <solatis> ok let me see
01:16:36 <solatis> ah!
01:16:37 <pingu> solatis: you're looking for runGetIncremental
01:16:46 <solatis> this indeed looks like what i want!
01:16:58 <solatis> thanks
01:17:05 <pingu> no problem
01:17:28 <pingu> (that's all the pipes library wraps, as far as I recall)
01:18:34 <quchen2> Is MaurÌcio C Antunes on IRC?
01:18:56 <quchen2> I've got a question about Bindings-DSL, how to translate a tagged union in particular.
01:19:25 <solatis> pingu: yeah this looks better fit for my purpose than ceral
01:19:29 <solatis> *cereal
01:24:33 <osa1_> so let's say I have a IO HugeStructure value and I forced it in IO monad by printing HugeStructure or something like that. not the HugeStructure thunk inside this IO action is updated with evaluated form, right?
01:24:51 <osa1_> I mean the IO action is not something that generates HugeStructure
01:24:58 <osa1_> it's like `return MyHugeStructure`
01:25:35 <osa1_> s/not/now
01:28:11 <quchen2> johnw: ping
01:33:00 <solatis> ok, i'm about to enter the world of lazy I/O, and i need to verify my assumptions
01:33:03 <solatis> https://hackage.haskell.org/package/network-2.6.0.2/docs/Network-Socket-ByteString-Lazy.html#g:2
01:33:26 <solatis> the getContents functions says it receives a lazy bytestring, and "data is received on demand"
01:33:46 <solatis> when i look at the implementation at https://hackage.haskell.org/package/network-2.6.0.2/docs/src/Network-Socket-ByteString-Lazy.html#getContents , i indeed see "unsafeInterleaveIO"
01:34:26 <solatis> so, if I feed that to Data.Binary.decode, will the function block until enough data has been received by the socket ?
01:47:16 <Cale> solatis: Yeah, the string you get from getContents doesn't end until the socket is closed, effectively.
01:48:35 <Cale> solatis: Using lazy I/O with sockets is usually quite awkward, because handles/sockets/etc. which are passed to getContents style functions are not meant to be manually closed. When they're a very limited resource like sockets, that can be annoying.
01:49:02 <Cale> But if it's like a one time connection or something, then it might be convenient.
01:54:55 <solatis> Cale: it is a one-time connection
01:55:29 <solatis> and I've got all the sockets wrapped in a ResourceT
01:55:55 <solatis> and the decodeOrFail function is quite convenient, which gives a ByteString with the remainders back
02:01:47 <seanparsons> I'm seeing this bizarro error from template haskell: https://www.irccloud.com/pastebin/OvcP8YNe from this code: https://github.com/seanparsons/rwst-wiring/blob/master/src/Control/Monad/Wiring.hs#L14
02:01:54 <seanparsons> It's got me totally baffled.
02:08:28 <Cale> (VarT wirableName)
02:08:35 <Cale> hmm
02:09:11 <Cale> Oh, also, what? An instance for 1-tuples?
02:09:27 <Cale> 1-tuples aren't really a thing, I'm not sure if that'll work
02:09:40 <seanparsons> Cale: Well that's just the first one that is failing, it's the same if I start at 2.
02:09:45 <Cale> (but if that's the issue, then the error message is weird)
02:09:47 <Cale> yeah
02:10:19 * hackagebot stackage 0.4.0 - "Stable Hackage," tools for creating a vetted set of packages from Hackage.  http://hackage.haskell.org/package/stackage-0.4.0 (MichaelSnoyman)
02:10:32 <seanparsons> https://www.irccloud.com/pastebin/Efvqihvr
02:10:57 <Cale> You probably want ConT and not VarT there
02:11:36 <Cale> Because "Wirable" is indeed not a good name for a type variable
02:11:59 <seanparsons> Cale: Aha, that seems to have gotten me something different!
02:14:21 <seanparsons> Cale: That seems to have been it, cheers for that, just gotta solve some other issue now.
02:28:18 <batchm> I am playing around with FFI and tried to foreign import stdout, but I can't get it to work
02:28:24 <batchm> foreign import ccall "&stdout" stdout :: Ptr CFile
02:29:07 <batchm> I am getting this error when I try to inspect stdout in ghci. During interactive linking, GHCi couldn't find the following symbol: stdout
02:29:40 <hpd> I have another ffi thing: GHC-7.8.3 throws 'parse error on input ‚Äò"‚Äô' at me for this small example that I copied from the manual. Am I missing something or can I report a bug
02:29:49 <hpd> https://wwwcip.cs.fau.de/~lu03pevi/interruptible.hs
02:44:10 <quchen2> hpd: Enable the FFI language extension?
02:44:37 <quchen2> Without FFI, this looks like you have a type variable starting with "
02:45:02 <quchen2> Eh, a value-type-devlaration. Or something along those lines.
02:45:06 <srhb_> {-# LANGUAGE ForeignFunctionInterface #-}
02:45:08 <srhb_> For the record.
02:45:33 <hpd> that should be enabled by default
02:45:39 <hpd> and doesn't change anything
02:46:46 <hpd> (it parses if I replace "interruptible" by "safe")
02:47:41 <srhb_> hpd: Oh right, you need InterruptibleFFI too
02:49:15 <hpd> srhb_: uh, thanks, that's it. I've missed that
02:49:35 <srhb_> There's still a bug in the manual though
02:49:42 <srhb_> It's missing the Haskell name for the function.
02:50:20 * hackagebot cabal-test-compat 0.2.0.0 - Compatibility interface of cabal test-suite.  http://hackage.haskell.org/package/cabal-test-compat-0.2.0.0 (KeiHibino)
02:50:22 * hackagebot fmlist 0.9 - FoldMap lists  http://hackage.haskell.org/package/fmlist-0.9 (SjoerdVisscher)
02:50:35 <hpd> srhb_: yeah. I'll report it
02:50:41 <srhb_> hpd: Thanks!
02:54:41 <quxbam> how can i implement [a -> m a] -> a -> m a
02:54:50 <quxbam> with foldl1 (<=<) xs ?
02:56:13 <Cale> :t foldl1 (<=<)
02:56:14 <lambdabot> Monad m => [c -> m c] -> c -> m c
02:56:26 <Cale> :t foldr (<=<) return
02:56:27 <lambdabot> Monad m => [b -> m b] -> b -> m b
02:56:50 <quxbam> whats here the difference between c and b?
02:56:54 <Cale> nothing
02:57:00 <quxbam> ok
02:58:16 <matematikaadit> :t foldl (.) id
02:58:16 <lambdabot> [c -> c] -> c -> c
02:58:31 <matematikaadit> :t foldl1 (.)
02:58:32 <lambdabot> [c -> c] -> c -> c
02:58:36 <Cale> You generally ought to prefer foldr (.) id to using foldl for that
02:58:53 <quxbam> why?
02:58:55 <Cale> Because it can get to work sooner, and doesn't necessarily have to traverse the entire list
02:59:13 <Cale> @src foldr
02:59:13 <lambdabot> foldr f z []     = z
02:59:13 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:59:20 <quxbam> ahh
03:00:26 <Cale> foldr (.) id [f,g,h] x -> (f . foldr (.) id [g,h]) x -> (\v -> f (foldr (.) id [g,h] v)) x -> f (foldr (.) id [g,h] x)
03:00:31 <Cale> and then f gets to evaluate
03:00:48 <Cale> and maybe produce part of the result without necessarily needing the fold over the rest of the list
03:01:38 <quxbam> and does it make a difference if it is clear, that all the list must be evaluated?
03:02:08 <Cale> If it's absolutely certain that the whole list will need to be evaluated, then maybe foldl' would be better
03:02:23 <matematikaadit> > foldr (.) id [f,g,h]
03:02:24 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
03:02:25 <lambdabot>    arising from a use of ‚ÄòM209029767102093082822658.show_M2090297671020930828...
03:02:25 <lambdabot>  The type variable ‚Äòb0‚Äô is ambiguous
03:02:32 <matematikaadit> > foldr (.) id [f,g,h] :: Expr
03:02:33 <Cale> Though foldl' in a case like this won't let you do much of the evaluation early
03:02:33 <lambdabot>  Couldn't match type ‚Äòa0 -> b0‚Äô with ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
03:02:33 <lambdabot>  Expected type: (b0 -> c0)
03:02:33 <lambdabot>                 -> Debug.SimpleReflect.Expr.Expr -> Debug.SimpleReflect.Expr....
03:02:55 <Cale> since you'll just be evaluating the composites, and not the final function applications
03:03:22 <quxbam> ok
03:03:58 <quxbam> now i understand
03:05:20 * hackagebot text-ldap 0.1.1.5 - Parser and Printer for LDAP text data stream  http://hackage.haskell.org/package/text-ldap-0.1.1.5 (KeiHibino)
03:05:29 <quxbam> thanks
03:06:58 <batchm> why doesn't this work?  foreign import ccall "stdout" stdout :: Ptr CFile
03:07:17 <batchm> During interactive linking, GHCi couldn't find the following symbol: stdout
03:08:00 <batchm> wait, ccall is a calling convention
03:08:10 <batchm> how am I supposed to import a global variable?
03:08:43 <Cale> Also, stdout isn't a pointer, is it?
03:09:04 <Cale> Isn't it an Fd?
03:09:14 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/unix-2.7.0.1/System-Posix-IO.html#v:stdOutput
03:10:05 <Cale> Oh, right, it is extern FILE * in C, hmm
03:10:18 <batchm> yes, posix stdout is FD, C stdout is FILE *
03:11:43 <srhb_> But the issue here is just that it's not finding stdout, you may have to specify the header file
03:12:21 <srhb_> Other than that, if it were a pointer, it would look like foreign import ccall "headerfile.h name" name :: Ptr CSomething
03:12:35 <srhb_> Or something like that. :)
03:12:43 <batchm> it is a linking error though
03:12:56 <batchm> but just to make sure, foreign import ccall "stdout.h stdout" c_stdout :: Ptr CFile did not change anything
03:13:00 <Cale> Oh, also the C spec says that they're macros
03:13:07 <Cale> though on my system, they're trivial macros
03:13:10 <srhb_> Ah, then you need capi or something.
03:14:00 <Cale> extern struct _IO_FILE *stdout;		/* Standard output stream.  */
03:14:03 <Cale> #define stdout stdout
03:14:55 <batchm> ight.. it hask I will check capi out
03:15:06 <Cale> Wait, stdout.h?
03:15:18 <Cale> Shouldn't that be stdio.h?
03:15:23 <batchm> yes :)
03:15:53 <batchm> same thing. I will look at capi
03:16:22 <batchm> and isn't that an awkward #define ..
03:19:17 <Cale> batchm: Yeah, it's just forced conformance, I guess.
03:19:19 <batchm> foreign import capi "stdio.h stdout" c_stdout :: Ptr CFile
03:19:31 <batchm> During interactive linking, GHCi couldn't find the following symbol: ghc_wrapper_d5EP_stdout
03:19:46 <batchm> Cale yes looks like it
03:25:44 <matematikaadit> > mapM_ print $ reduce (foldl (+) 0 [1..5])
03:25:45 <lambdabot>  Couldn't match expected type ‚Äò[a0]‚Äô
03:25:45 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
03:26:26 <matematikaadit> > mapM_ print $ reduction (foldl (+) 0 [1..5])
03:26:27 <lambdabot>  <IO ()>
03:26:36 <matematikaadit> > reduction (foldl (+) 0 [1..5])
03:26:37 <lambdabot>  [0 + 1 + 2 + 3 + 4 + 5,1 + 2 + 3 + 4 + 5,3 + 3 + 4 + 5,6 + 4 + 5,10 + 5,15]
03:30:18 <bennofs> :t reduction
03:30:19 <lambdabot> Expr -> [Expr]
03:31:16 <a1tern> Hi all. I have list of functions fun1 $ fun2 $ fun3 applied to a variable var. How could I extract this list of function fun1 $ fun2 $ fun3 into standalone function fun = (fun1 $fun2 $ fun3) that can be appllied to a var as follows: fun var?
03:36:02 <alpounet> a1tern: use . instead of $. it's the function composition operator
03:49:43 <effse> Hi! Can someone help me with what I assume is a rather easy problem?
03:50:36 <bennofs> effse: without knowing your problem, we won't know if we can help you :)
03:52:23 <effse> bennofs: haha! Of course. I'm new to haskell, and trying to create a recursive data type representing algebraic expressions. The problem is that i duplicate lots of code, and I don't know how to make it more general
03:53:03 <bennofs> effse: do you have an example of the code you'd like to improve? (use http://lpaste.net to paste it)
03:54:22 <effse> bennofs: Here is the example: http://lpaste.net/117619
03:55:11 <bennofs> hmm, what do you mean with duplicating lots of code? The only thing that's duplicated there is Expr, no?
03:55:22 * hackagebot relational-query 0.3.0.1 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.3.0.1 (KeiHibino)
03:56:44 <effse> bennofs: Well, is there any way to make it more general? So that 'Add Expr Expr' and 'Mul Expr Expr' can look like "operator expr expr'. If you understand
03:58:27 <bennofs> effse: ah. Well, you could do data Operator = Plus | Minus | ... and then data Expr = Binary Operator Expr Expr | ... , or you could represent an operator as a Char, but these possibilities are all not really better.
03:58:54 <bennofs> (With the Char variant, the problem is that you can have "invalid" expressions, which might not be what you want)
04:00:05 <bennofs> ok, I have to go now, good luck ;)
04:00:12 <effse> bennofs: I see! Thank you for the help anyway! :)
04:02:31 <haasn> I'm trying to find an article that I remember reading, it was about teaching programming and iirc it studied how well non-programmers reacted to basic imperative concepts, and how they reacted to basic functional concepts. The result they got is that the test sample shows two distinct humps in the distribution, seemingly dividing the subjects into ‚Äúpeople who intuitively understand programming‚Äù and
04:02:33 <haasn> ‚Äúpeople who don't‚Äù. Anybody remember what I might be thinking of?
04:21:40 <tasker> what are my options for creating a simple gui that runs in both osx and windows ?
04:22:00 <tasker> literally just needs to specify an input / output file
04:22:04 <tasker> and then have a run button
04:22:11 <deni> why does installing ghc-mod fail if happy isn't installed? for some reason I need to install happy manually first...and then the ghc-mod installation goes fine.
04:22:42 <tasker> deni: I think ghc-mod uses the parsers generated from happy ?
04:22:57 <deni> tasker: why can't the dependencies solve that then?
04:23:06 <tasker> deni: pretty sure it uses the happy executable
04:23:07 <tasker> not as a library
04:23:24 <tasker> (I could be wrong)
04:23:26 <deni> tasker: it does yes. it uses the executable....
04:23:35 <deni> tasker: cabal can't handle that?
04:24:07 <tasker> deni: presumably not :P
04:26:08 <deni> tasker: any idea why this is? ie. can it be fixed?
04:26:27 <tasker> deni: sadly not :( I am far from an expert when talking about cabal
04:26:38 <tasker> (sadly not to knowing why it is, i mean)
04:27:12 <Adeon> cabal uses ghc package caches to check what libraries are installed
04:27:15 <Adeon> but those caches don't track executables
04:27:22 <Adeon> so cabal doesn't know the executable is installed
04:28:25 <Adeon> ...or something like that, I don't remember how exactly it works in detail
04:29:17 <jrc12> when using pandoc to parse an html file to the Markup type from Text.Blaze, using - writeHtml def {writerHtml5 = True } . readHtml def $ htmlInp, it loses all the header information
04:29:25 <deni> Adeon: seems fixable though
04:31:21 <deni> Adeon: was wondering about the rationale though. ie. why is it designed this way
04:33:06 <Adeon> I may be wrong...my understanding is that cabal does not want to be the package manager and so it delegates tasks to other parts
04:33:26 <Adeon> so it lets ghc keep track of libraries
04:34:23 <jrc12> writeHtml def {writerHtml5 = True } . readHtml def $ ht
04:34:38 <batchm> still can't get this to work..I would be interested to know if it works for someone else: http://lpaste.net/117620
04:34:39 <Adeon> cabal supports other compilers as well that may have their own way of managing libraries
04:35:23 * hackagebot http-client 0.4.6.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.6.2 (MichaelSnoyman)
04:35:26 <deni> Adeon: i see
04:50:39 <jrc12> H:i Html
04:51:26 <jrc12> how would you parse an html to Text.Blaze.Html?
04:51:32 <jrc12> html file*
04:55:24 * hackagebot HaXml 1.25.2 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.25.2 (MalcolmWallace)
05:20:25 * hackagebot egison 3.5.3 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.5.3 (SatoshiEgi)
05:28:53 <tasker> If I have some packages installed "normally", and then try to use a cabal sandbox, will the sandbox ignore the already installed packages ?
05:31:01 <awesomo4000> is there a module that allows very simple execution of outside processes, capturing all output, in a safe way ?
05:42:38 <geekosaur> awesomo4000, perhaps you want http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/process-1.1.0.2/System-Process.html#v:readProcess ?
05:42:44 <Kaidelong> so how much work would this be
05:43:13 <Kaidelong> implement an ML like DSL in Haskell with strict evaluation
05:43:14 <Kaidelong> reimplement some basic data structures to use it
05:43:21 <geekosaur> tasker, if they're in the user library list (second one in ghc-pkg) then they will be ignored
05:43:26 <Kaidelong> use -XRebindableSyntax to make it pretty
05:43:30 <geekosaur> the global library cannot be ignored
05:43:36 <Kaidelong> and then demonstrate that () -> t and t are *not* the same
05:43:58 <Kaidelong> and that the distinction between "lifted" and "unlifted" things can be recovered in Haskell
05:44:50 <Kaidelong> it doesn't even really exist in ML because functions are still partial and fix can be implemented, so you can trivially construct partial values anyway, it's just a kind of semantic blackmail where it blows up if you ever try to do that
05:45:15 <Kaidelong> but this means that when Haskell programs use the same semantics, the same argument applies
05:46:04 <Kaidelong> however the type checker in F# doesn't bat an eye if you try something like building an infinite list
05:46:49 <Kaidelong> so I don't even think it's right to complain Haskell has fewer types. It has different semantics, that's all
05:50:22 <Kaidelong> alright so how would MLfn look like?
05:51:06 <Kaidelong> type MLfn t u = MLval t -> MLval u?
05:52:32 <Kaidelong> mmm, since t and u have to be able to be fully evaluated, I would be dealing with an indexed monad, but rebindable syntax is allowed here, so that's okay
05:52:55 <Kaidelong> @hoogle deepSeq
05:52:57 <lambdabot> Control.DeepSeq module Control.DeepSeq
05:52:57 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
05:52:57 <lambdabot> package deepseq
05:53:58 <Kaidelong> we end up with newtype MLVal t = IO t?
05:54:10 <Kaidelong> and then with rebindable syntax we define
06:00:27 * hackagebot haskell-updater 1.2.7 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.7 (SergeiTrofimovich)
06:01:17 <tasker> If I develop e.g. a simple threepenny-gui application, is there some easy way to cross-compile to windows? Or do I have to get a windows box and compile it on there ?
06:03:24 <McManiaC> is there something like `case string of ('c':rest) -> ... "" -> ...` for Text ?
06:05:47 <geekosaur> tasker, cross-compilation isn't really a thing. I suggest virtualbox.
06:06:19 <tasker> I've not used haskell on windows yet, but need to run this program on win7. How painful is installing everything ?
06:07:41 <mauke> McManiaC: T.uncons?
06:08:44 <McManiaC> mauke: right, thanks
06:08:44 <awesomo4000> https://www.haskell.org/platform/windows.html
06:47:18 <Guest68865> hi, is there anyone here experienced with sublimehaskell?
07:00:30 * hackagebot matchers 0.22.0.0 - Text matchers  http://hackage.haskell.org/package/matchers-0.22.0.0 (OmariNorman)
07:01:59 <wz1000> I'm pretty sure that Monad m => m () forms a monoid over mappend a b = join $ liftM (const b) a
07:03:07 <wz1000> @let a <+> b = join $ liftM (const b) a
07:03:09 <lambdabot>  Defined.
07:03:23 <wz1000> @let empty = return ()
07:03:24 <lambdabot>  Defined.
07:03:35 <awesomo4000> what's that <+> b notation mean
07:03:42 <wz1000> > [(),(),()] <+> [(),()]
07:03:44 <lambdabot>  Ambiguous occurrence ‚Äò<+>‚Äô
07:03:44 <lambdabot>  It could refer to either ‚ÄòL.<+>‚Äô, defined at L.hs:162:3
07:03:44 <lambdabot>                        or ‚ÄòControl.Arrow.<+>‚Äô,
07:03:47 <brainacid> hi all
07:03:52 <wz1000> @let a <++> b = join $ liftM (const b) a
07:03:53 <lambdabot>  Defined.
07:04:01 <wz1000> > [(),(),()] <++> [(),()]
07:04:02 <lambdabot>  [(),(),(),(),(),()]
07:04:12 <wz1000> > [(),(),()] <++> empty
07:04:13 <lambdabot>  Ambiguous occurrence ‚Äòempty‚Äô
07:04:14 <lambdabot>  It could refer to either ‚ÄòL.empty‚Äô, defined at L.hs:154:1
07:04:14 <lambdabot>                        or ‚ÄòControl.Applicative.empty‚Äô,
07:04:31 <wz1000> @let monempty = return ()
07:04:32 <lambdabot>  Defined.
07:04:41 <wz1000> > [(),(),()] <++> monempty
07:04:43 <lambdabot>  [(),(),()]
07:05:08 <wz1000> > putStr "Hello" <++> putStrLn "World"
07:05:09 <lambdabot>  <IO ()>
07:05:36 <wz1000> Just () <+> Nothing
07:05:44 <wz1000> > Just () <+> Nothing
07:05:46 <lambdabot>  Ambiguous occurrence ‚Äò<+>‚Äô
07:05:46 <lambdabot>  It could refer to either ‚ÄòL.<+>‚Äô, defined at L.hs:164:3
07:05:46 <lambdabot>                        or ‚ÄòControl.Arrow.<+>‚Äô,
07:05:48 <wz1000> > Just () <++> Nothing
07:05:50 <lambdabot>  Nothing
07:06:10 <wz1000> > Just () <++> Just ()
07:06:11 <lambdabot>  Just ()
07:09:38 <wz1000> > length $ replicate 15 () <++> replicate 3 ()
07:09:39 <lambdabot>  45
07:11:55 <wz1000> Its a kind of weaker mplus applicable for all monads.
07:17:54 <wz1000> awesomo4000: Im defining a function called (<+>) with two parameters, a and b
07:27:15 <awesomo4000> wow. i didn't know realize you could define an infix operator that way. (thanks tutorials)
07:30:04 <hexagoxel> it is not even restricted to operators/symbols:
07:30:10 <hexagoxel> > let a `f` b = a+b in f 40 2
07:30:11 <lambdabot>  42
07:35:17 <lisbeth> what do you call this notation? zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
07:35:31 <lisbeth> is it just called datatypes?
07:35:49 <matematikaadit> type signatures
07:35:57 <hexagoxel> type signature (?)
07:36:07 <Chousuke> a type signature?
07:36:15 <lisbeth> thank you
07:38:34 <lisbeth> so apparently this: (/12)
07:38:50 <lisbeth> has a type signature of: Fractional a => a -> a
07:39:10 <lisbeth> does the "a =>" signify that a piece is missing to fix the function?
07:39:16 <lisbeth> as in it needs an a
07:39:29 <awesomo4000> it means it needs an a, with a type class constraint of "Fractional"
07:39:42 <lisbeth> oh I see
07:39:53 <awesomo4000> so a has to be have whatever functions required to be a Fractional
07:40:06 <lisbeth> what happened if I wrote a haskell script that omitted the "fractional a =>"
07:40:18 <awesomo4000> then it could be any type of a
07:40:26 <lisbeth> Thanks.
07:40:33 <exio4> "for all types that satisfy Fractional, the type of this is a -> a"
07:40:37 <exio4> lisbeth, it wouldn't compile
07:40:44 <exio4> @type (/12) :: a -> a
07:40:45 <lambdabot>     No instance for (Fractional a1) arising from a use of ‚Äò/‚Äô
07:40:45 <lambdabot>     Possible fix:
07:40:45 <lambdabot>       add (Fractional a1) to the context of
07:40:52 <exio4> @type (/)
07:40:53 <lambdabot> Fractional a => a -> a -> a
07:41:09 <exio4> "/" adds the constraint, and you need to satisfy it to be able to use it
07:41:20 <lisbeth> can I use the notation: a1 -> a2 -> a3 ?
07:41:41 <mauke> sure
07:41:52 <mauke> that's equivalent to a -> b -> c
07:41:52 <lisbeth> are those syntactically the same
07:41:56 <mauke> or foo -> bar -> baz
07:41:57 <lisbeth> oh I see
07:42:03 <awesomo4000> is there a ghci command to show what a type class constraint requires
07:42:43 <awesomo4000> lieke (Eq, Ord) , etc
07:42:48 <wz1000> :t
07:42:55 <wz1000> :t (/)
07:42:56 <lambdabot> Fractional a => a -> a -> a
07:43:09 <wz1000> :t (==)
07:43:10 <lambdabot> Eq a => a -> a -> Bool
07:44:00 <lisbeth> why does the notation: a -> b -> c  become necessary?
07:44:05 <hexagoxel> awesomo4000: there is `:i Eq`
07:44:10 <lisbeth> rather than a - > a -> a ->
07:44:36 <mauke> :t \x y -> "hello"
07:44:37 <lambdabot> t -> t1 -> [Char]
07:44:44 <bennofs> lisbeth: a -> a -> a is a function that takes two arguments of the same type and returns a value also of that type
07:44:47 <mauke> x and y can have different arbitrary types
07:45:00 <mauke> because I'm not doing anything with the incoming values
07:45:20 <bennofs> lambdabot: a -> b -> c is a function that takes two arguments which can have different types and the return value can also be of a different type
07:46:13 <Peaker> bennofs: I'm sure lambdabot knows that :)
07:46:22 <awesomo4000> :i Fractional
07:46:23 <bennofs> Peaker: oh :)
07:46:27 <ddellacosta> think s/he meant lisbeth
07:46:35 <Peaker> ddellacosta: I know that too :)
07:46:46 <awesomo4000> :info Fractional
07:46:48 <ddellacosta> d'oh
07:46:50 <ddellacosta> ;-)
07:46:54 <lisbeth> Thanks. That helps me understand this chapter in Learn You a Haskell alot better.
07:47:42 <hexagoxel> awesomo4000: well lambdabot/=ghci
07:47:57 <awesomo4000> so i see
07:50:33 <flaggy> It's sort of Odd that tuple Eq instances stop at 15
07:52:46 <carter> flaggy: if you wanna kick it up to 40, i promise it'll get merged in
07:52:47 <carter> :)
07:53:30 <carter> not sure if anyone has needed that big a tupled
07:53:51 <carter> machine generated code tends to use (,) or its own custom typees, and people tend to not use more than ten
07:54:58 <ddellacosta> folks, I'm trying to port some example code for libao, and I'm having trouble getting it to function.  My code compiles but it doesn't output anything.  I suspect this part is suspect: https://gist.github.com/ddellacosta/af47e178810538e107ad
07:55:08 <ddellacosta> and this is the original C code: https://xiph.org/ao/doc/ao_example.c
07:55:26 <ddellacosta> am I doing anything obviously wrong?
07:55:40 <flaggy> hehe yeah, practically 15 is probably enough. But it looks arbitrary. Couldn't it be done to any tuple size with template haskell?
07:56:02 <carter> not in GHC proper
07:56:33 <Clint> ddellacosta: yes, the guards in fillSampleVector' don't make any sense
07:56:49 <flaggy> hm, it is not possible to use templatehaskell on ghc implementation? Why not?
07:56:50 <mauke> ddellacosta: no main?
07:57:03 <ddellacosta> Clint: why not?
07:57:03 <carter> flaggy: stage1 ghc currently cant use TH
07:57:11 <carter> that will likely change soon
07:57:12 <carter> buttt
07:57:16 <ddellacosta> mauke: I've got a main, just curious about this chunk of code specifically
07:57:18 <carter> its a constraint for own
07:57:25 <flaggy> hm
07:57:28 <ddellacosta> mauke: in terms of how it compares to the for loop in the C code
07:57:37 <ddellacosta> just not sure I'm constructing the sample properly
07:57:38 <Clint> ddellacosta: what is | n == rate = xs supposed to do?
07:57:54 <ddellacosta> Clint: return xs once n is equal to rate
07:58:01 <mauke> ddellacosta: but main is what runs
07:58:01 <Guest78612> in c yep
07:58:08 <Clint> oh, i misread
07:58:10 <mauke> ddellacosta: so if your program has no output, it's main's fault
07:58:25 <carter> flaggy: luite  worked out a really awesome design that will make its way into ghc at some point
07:58:49 <Guest78612> haha the make it fails
07:59:09 <Guest78612> make it fails do I can be system
07:59:35 <mauke> Guest78612: how would you pass the turing test?
07:59:47 <carter> mauke: clever markov chain
07:59:49 <ddellacosta> mauke: I'm confused...this is wrapping C code (FFI), so I would assume that it wouldn't have anything to do with it
08:00:38 <Guest78612> mauke; 0x00
08:00:41 <mauke> ddellacosta: I'm confused. if your main looks like 'main = return ()', it doesn't matter what the rest of your program does
08:01:11 <mauke> Guest78612: fail
08:01:43 <ddellacosta> mauke: I was trying to avoid getting too deep into it--since I'm most unsure about all the array construction stuff I wanted to see if I could folks to see if that made sense
08:01:58 <ddellacosta> mauke: but main most assuredly doesn't look like return ()
08:02:21 <ddellacosta> mauke: more to the point, I've tried running it a number of ways
08:02:23 <Guest78612> knowing you are not smart is good; plus tou are not tought
08:02:41 --- mode: ChanServ set +o mauke
08:02:41 --- kick: Guest78612 was kicked by mauke (failed the turing test)
08:02:49 <ddellacosta> haha
08:04:41 --- mode: mauke set -o mauke
08:05:29 <untseac> hey
08:25:14 <wz1000> Is (forall a. a) -> Int a valid type signature?
08:25:42 <Guest78612> may work
08:25:51 <exio4> @type const 1 :: (forall a. a) -> Int
08:25:52 <lambdabot>     Cannot instantiate unification variable ‚Äòb0‚Äô
08:25:52 <lambdabot>     with a type involving foralls: forall a. a
08:25:52 <lambdabot>       Perhaps you want ImpredicativeTypes
08:26:04 <geekosaur> it's valid but the function can't do much
08:26:22 <carter> :t (undefined :: forall a . a)
08:26:23 <lambdabot> a
08:26:28 <carter> hahhhhhh
08:27:03 <wz1000> geekosaur: I was just thinking. If that is valid, can't you use _|_ as a substitute for ()?
08:27:23 <wz1000> Since _|_ is the only thing having that signature
08:27:28 <Guest78612> thats just pointers
08:28:15 <Guest78612> you can
08:28:44 <wz1000> And there is no point to inspecting the value of () anyway
08:29:07 <Guest78612> Depends the arch but no
08:30:17 <Guest78612>  haha you think there is cpntrols on low level :)
08:34:35 <Guest78612> 4
08:36:03 <ab9rf> there are four lights
08:41:44 <panther__> hey
08:41:55 <panther__> i am a haskell newbie
08:42:04 <panther__> and I have a question about modules
08:42:33 <Haskellfant> then just ask your question
08:42:54 <panther__> i decided to rewrite the functor, applicative, monoid, and monad instances
08:43:17 <panther__> So i created a directory Instances
08:43:34 <panther__> and I started by writing Instances.Functor
08:43:45 <panther__> Then I did Instances.Applicative
08:44:12 <panther__> so I needed to import Instances.Functor for Applicative
08:44:41 <panther__> i said 'import qualified Instances.Functor as F'
08:45:48 <panther__> but ghc yelled at me and told me it couldn't find the module Instances.Functor
08:46:04 <panther__> i will put my code on pastebin
08:47:37 <panther__> http://pastebin.com/937k4K9r
08:48:31 <panther__> http://pastebin.com/kQD7EauZ
08:48:33 <panther__> there
08:48:53 <panther__> So what do you think is the problem?
08:49:03 <Haskellfant> how exactly are you compiling?
08:49:07 <panther__> ghc -v
08:49:16 <panther__> ghc -v Applicative.js
08:49:19 <panther__> ghc -v Applicative.hs sorry
08:49:21 <Haskellfant> .js? :)
08:49:24 <panther__> nono
08:49:29 <panther__> that's just a type
08:49:31 <panther__> that's just a typo
08:49:32 <Haskellfant> ofc
08:49:43 <quantum-mechanic> you typo'd typo
08:49:46 <panther__> I am terrible at typing :)
08:49:46 <shachaf> panther__: You need to be in the top-level directory, not inside Instances/
08:49:53 <panther__> oh!
08:50:10 <Haskellfant> otherwise it tries to find something in Instances/Instances/
08:50:20 <shachaf> It would be much easier to follow your question if you didn't split it over so many lines, by the way. :-)
08:50:31 <ab9rf> heh
08:52:38 <panther__> i actually use ghci not ghc
08:52:38 <Haskellfant> shachaf: but think about the 80 column limit! (sorry)
08:52:51 <panther__> i was just stuck so i used ghc
08:53:04 <dario> Haskellfant: wouldn't that be something your irc client should take care of? :)
08:53:17 <Haskellfant> dario: ofc, it's not like I was being serious
08:54:28 <panther__> Thank you!
09:05:21 <panther__> um.. i am back again
09:05:56 <panther__> i am trying to implement (<$>), which is just fmap.... but i am doing so in Applicative.hs
09:06:37 <panther__> (<$>) :: (Applicative f) => (a->b) -> f a -> f b (<$>) = fmap
09:07:07 <panther__> there is a hidden newline character between "f b" and "(<$>)"
09:08:32 <hiptobecubic> don't forget fixity
09:09:47 <panther__> Do I need fixity for (<$>)? Isn't that just for ($)?
09:10:26 <hiptobecubic> all operators have some fixity. otherwise you wouldn't know the order in which they are applied
09:10:35 * hackagebot c2hs 0.21.1 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.21.1 (IanRoss)
09:10:54 <panther__> Instances/Applicative.hs:34:9:
09:10:54 <panther__>     Could not deduce (Functor f) arising from a use of `fmap'
09:10:54 <panther__>     from the context (Applicative f)
09:10:54 <panther__>       bound by the type signature for
09:10:54 <panther__>                  <$> :: Applicative f => (a -> b) -> f a -> f b
09:10:55 <panther__>       at Instances/Applicative.hs:33:10-48
09:10:57 <panther__>     Possible fix:
09:10:59 <panther__>       add (Functor f) to the context of
09:11:01 <panther__>         the type signature for
09:11:03 <panther__>           <$> :: Applicative f => (a -> b) -> f a -> f b
09:11:05 <hiptobecubic> panther__, don't paste in here. Use lpaste.net
09:11:05 <panther__>     In the expression: fmap
09:11:07 <panther__>     In an equation for `<$>': <$> = fmap
09:11:09 <panther__> Failed, modules loaded: Instances.Functor.
09:11:11 <panther__> that's what ghci said
09:11:13 <panther__> sorry
09:11:35 <dmj`> panther__: lpaste.net
09:12:48 <panther__> http://lpaste.net/117643
09:13:05 <panther__> Should (Applicative f) be (Functor f)?
09:13:08 <thebnq> the code would be helpful too :)
09:13:12 <panther__> ok
09:14:01 <panther__> http://lpaste.net/117644
09:14:05 <panther__> there
09:17:03 <panther__> i guess it is ok if i say Functor f
09:17:11 <panther__> instead of Applicative f
09:17:18 <iElectric> could someone give me some hints with handling the IO? I have following code and errors: http://paste.ofcode.org/eP6rY7WAkYUAzGfeMaVvdK
09:17:20 <thebnq> i guess it should be Functor, yes
09:17:43 <panther__> but that's weird because in my class definition I said (F.Functor f) => Applicative f
09:19:19 <iElectric> I'm still slowly crawling through types and monads
09:19:47 <delrik> Hi does anyone know of a tutorial that gives a good thorough walk through of haskell's type system?
09:20:46 <thebnq> panther__: yea weird, it worked for me, but i did replace your Functor with the base Functor
09:21:06 <panther__> ok, thanks
09:21:06 <iElectric> ocharles: do you maybe have a few mins? :)
09:21:08 <agibiansky> iElectric: The first error comes because `map` is a pure function
09:21:19 <ocharles> iElectric: sure, what's up?
09:21:28 <iElectric> ocharles: http://paste.ofcode.org/eP6rY7WAkYUAzGfeMaVvdK
09:21:33 <iElectric> agibiansky: so I should use mapM?
09:21:54 <agibiansky> It looks like you do want `map` there ‚Äì since you're not doing any IO for each element
09:21:59 <agibiansky> So you probably want to map and then return the result
09:22:05 <agibiansky> return $ map constructEvent events_raw
09:22:27 <ocharles> yep, that seems like the main problem
09:22:30 <iElectric> ahhhh
09:22:30 <agibiansky> You can think of mapM as an effectful for loop, where each iteration does some IO or whatnot ‚Äì here it looks like constructEvent is indeed pure
09:22:31 <thebnq> panther__: oh ofcourse!! you probably need F.fmap
09:22:39 <iElectric> I was not using function application correctly
09:23:05 <iElectric> thanks!
09:23:10 <agibiansky> np, good luck
09:27:06 <panther__> oh!!
09:27:41 <augustss> howdy
09:28:07 <panther__> Alright cool
09:28:10 <panther__> thanks
09:28:53 <thebnq> :) might be helpful to not import prelude's Functor
09:30:57 <vanila> hi augustss
09:39:03 <srhb_> delrik: Do you mean as a "user" of the type system, ie. a Haskell programmer, or how GHC works out types etc?
09:43:43 <augustss> It's so quiet...
09:44:25 <agibiansky> Almost... too quiet.
09:45:06 <KrzyStar> Fufu
09:46:34 <KrzyStar> Is there a nice, clean way of serializing a big 'data' value to bytestring?
09:47:11 <agibiansky> https://hackage.haskell.org/package/cereal ‚Äì does this do what you want, KrzyStar?
09:47:13 <KrzyStar> I did deserialization with Data.Binary.Get in a nice, applicative style, but I'm not sure how to do this other way round
09:47:31 <ReinH> KrzyStar: Put
09:47:48 <agibiansky> You should be able to make an instance of Serialize for your data structure using DeriveGeneric, and then use `encode` from Data.Serialize
09:47:59 <carter> augustss: WELCOME
09:48:06 <augustss> ty
09:48:24 <ReinH> augustss: Hi
09:48:42 <carter> augustss: i hear london had snow?
09:49:13 <KrzyStar> agibiansky: thanks, I'll try this out :)
09:50:33 <augustss> carter: I'm in Sweden right now.  We had snow here.
09:50:40 <carter> ahhh
09:55:17 <agibiansky> carter: kronos is ready, as promised :P hopefully won't crash miserably for most people, could only test on 3 different macs...
09:55:37 * hackagebot storablevector 0.2.10 - Fast, packed, strict storable arrays with a list interface like ByteString  http://hackage.haskell.org/package/storablevector-0.2.10 (HenningThielemann)
09:55:41 <drdo> So my program takes a long time to finish yet stays at 0.1% CPU the whole time. Any tips on finding what might be happening?
09:55:51 <agibiansky> drdo: How much memory does it use?
09:55:55 <drdo> agibiansky: very little
09:56:29 <agibiansky> So it's definitely not swapping or anything? Hmm. Does it do a lot of IO? Maybe some sort of blocking on network or some such?
09:56:40 <drdo> It is doing IO
09:56:47 <drdo> talking to another process (z3)
09:56:59 <carter> agibiansky: DLING NOW
09:57:03 <drdo> but that seems to be going fast
09:57:08 <carter> agibiansky: DL failed
09:57:15 <agibiansky> carter: Eh?
09:57:15 <carter> agibiansky: you should share me a torrent link
09:57:22 <agibiansky> Why failed?
09:57:28 <carter> network error
09:57:34 <carter> agibiansky: its aws, you can generate a torrent
09:57:50 <agibiansky> It's S3, I thought AWS isn't allowed to fail... oh, really? cool. let me go google how to do that
09:58:47 <agibiansky> carter: https://s3-us-west-1.amazonaws.com/europanotebook/Kronos-Haskell.zip?torrent
09:59:17 <lisbeth> the function filter is literally the coolest thing I've ever seen in programming
09:59:21 <lisbeth> thanks for being awesome you guys
09:59:42 <carter> agibiansky: the first time you ?torrent a link, it takes a while to torrent ify it
10:00:23 <agibiansky> carter: Well, I assume so ‚Äì since no one is uploading besides (I presume) some S3 uploader? I'm trying to torrent it but so far not going anywhere...
10:00:46 <carter> agibiansky: it first has to compute teh torrent chunks
10:00:50 <carter> the first request triggers it
10:00:54 <agibiansky> Ohh
10:00:55 <agibiansky> Ok
10:02:49 <carter> agibiansky: that /Applications/ only thing is a bit of a hack, but OK :)
10:03:23 <agibiansky> carter: Yeah... but allows you to deal with absolute paths rather than relative ones. maybe someday it can be fixed :)
10:03:29 <carter> hehe
10:03:35 <carter> agibiansky: how do you install new packages
10:03:41 <carter> or is this more pedagoy / trying out for now
10:03:47 <agibiansky> Via a dialog that shells out to cabal
10:04:10 <carter> wheres the dialog
10:04:20 <sdzivanovich> agibiansky you use a frontend for cabal?
10:04:33 <agibiansky> carter: Uh, File -> Install Package
10:04:59 <agibiansky> sdzivanovich: Oh, no, this is for installing new packages into the haskell notebook app
10:05:05 <carter> agibiansky: cute
10:05:21 <carter> agibiansky: you probably want to allow some ghc-pkg (un)register/remove commands too
10:05:24 <carter> via check boxes or wahtever
10:05:28 <carter> but thats a yak for another day
10:05:29 <carter> GOOD JOB
10:05:37 <carter> agibiansky: shall I tweet a link
10:05:38 <carter> ?
10:05:48 <agibiansky> carter: Yeah ‚Äì in particular updating right now is basically unusable
10:05:49 <agibiansky> Yeah, sure
10:05:54 <sdzivanovich> agibiansky: ooooh gotcha that's what i get for dropping in mid-convo
10:06:05 <agibiansky> haha :)
10:06:17 <deech> I'm trying to figure out how to constraint a type family instance. I used to have a class instance like: `instance (C a) => Blah (a -> IO ()) where ...` and now with type families I have `instance B where type BType = a -> IO ()`. However this is rejected ...
10:06:35 <deech> How do I get that constraint on the associated type?
10:07:36 <augustss> I have wondered that too.
10:08:10 <untseac> Are there any evident caveats in haskell? I want to invest time with haskell but I like to know what I'm getting into.
10:09:00 <dmj`> untseac: what is an evident caveat
10:09:01 <augustss> Haskell is an evil alian scheme to suck up valuable brain power from earthlings.
10:09:29 <agibiansky> untseac: imho the two main caveats that are worth knowing are a) It's somewhat hard to learn, in comparison to other programming languages and b) there are still some areas where library support is lacking, though for the most part that is not an issue and isg etting better every day
10:09:44 <agibiansky> It's a worthwhile investment though :)
10:09:50 <untseac> dmj`, something that is known to be a disadvantage compared to other languages.
10:10:24 <deech> haskell.org is super-slow, at least in the Midwest.
10:11:03 <dmj`> deech: I can attest, where in the midwest are you
10:11:21 <deech> St. Louis
10:11:21 <arjanb> yeah haskell.org has been very slow for like 2 weeks, but only the wiki part
10:11:23 <dmj`> untseac: learn it, it's the future
10:11:29 <untseac> agibiansky, thanks. those two don't sound like big problems to me (personally I'm finding easy to learn but I learned scala first). Maybe I can help in the library department :)
10:11:46 <untseac> dmj`, yes I agree, it is the future
10:12:20 <augustss> deech: haskell.org is in Texas, that should be close enough.
10:13:06 <shachaf> augustss: Fancy seeing you here.
10:14:29 <augustss> I drop by now and then.
10:15:45 <mason-_> did anyone try to write haskell programs for VoCore? Is haskell even usable on such systems with limited resource?
10:17:30 <SrPx> Is there a "jsfiddle" like site for Haskell? One I can paste some code in and send for a friend to run it?
10:18:11 <augustss> mason-_: Hugs would run on VoCore.
10:19:15 <ij> SrPx, https://eval.in/
10:19:18 <bennofs> SrPx: you can use https://www.fpcomplete.com/school for that (create a new "tutorial")
10:19:33 <geekosaur> SrPx: idene.com, fpcomplete's thing, I think there's another somewhere
10:19:58 <geekosaur> codepad.org
10:20:11 <geekosaur> ideone.com I meant earlier
10:20:14 <mason-__> augustss: but not ghc/i?
10:20:34 <SrPx> great guys, thank you
10:20:45 <SrPx> also, idene.com ? are you sure ?
10:20:57 <SrPx> woops ok
10:21:11 <systemfault> Perhaps he meant ideone.com
10:22:59 <augustss> mason-__: ghc has outgrown 32M, I believe.
10:24:02 <mason-__> what about cross-compiling?
10:24:34 <augustss> That should be possible.
10:24:56 <vanila> How hard would it be to write a haskell compiler from scratch?
10:25:07 <vanila> I mean, I want to do this
10:26:01 <augustss> Writing a mediocre compiler for Haskell-98 isn't very hard, it's just an awful lot of work.
10:26:18 * SharpGAF1 was starting to as an exercise
10:26:19 <flaggy> I don't know how experienced and dedicated you are, but I think for me it would take more than a year
10:26:22 <SharpGAF1> Don't know how far I'll get.
10:26:43 <flaggy> the type inferrer alone is a lot of work
10:26:44 <systemfault> When you think about it... ghc was started in 1992.
10:26:46 <hpc> writing a better compiler would be something like 80 years of intense work
10:26:47 <systemfault> There's just 23 years of work in it.
10:26:53 <hpc> (by yourself)
10:27:03 <vanila> SharpGAF, you got a blog or something I can follow?
10:27:22 <SharpGAF> vanila: Nah, it's just a personal project to try and understand Haskell better (and compilers in general)
10:27:23 <geekosaur> ask john meacham?
10:27:25 <vanila> augustss, could I do a cut down version that's not fully compliant, so have a lot of work?
10:27:30 <flaggy> I wasn't thinking better, I think it would take me a couple years to get to the mediocre state :P
10:27:41 <vanila> SharpGAF, aw, woul dhave been good cause im learning that too
10:27:41 <augustss> I recommend using something like haskell-src-exts unless you are fascinated by parsing.
10:28:10 <hpc> vanila: you can spin up a simple ML-like really damn quick
10:28:30 <flaggy> I recommend writing a compiler for a simpler language
10:28:36 <SharpGAF> Yeah, I was really going for an ML-ish language first
10:28:38 <vanila> should I use push/enter or eval/apply?
10:28:58 <vanila> I really wanna se other peoples compiler projects so i can learn from that
10:28:58 <augustss> If you skip the module system and just focus on expressions you can do something a lot quicker.
10:29:03 <SharpGAF> Especially if you strip out a lot of the primitives it doesn't take that long
10:29:05 <SharpGAF> And modules, yeah
10:29:33 <augustss> vanila: push/enter vs eval/apply is far too early to worry about now.
10:29:47 <augustss> It's a minor thing.
10:29:48 <flaggy> I once wrote a type inferrer for a simple lambda calculus based language. There were not many types possible, but I had fun
10:29:57 <vanila> cool :)
10:29:59 <vanila> thanks augustss
10:30:15 <vanila> I wonder if anyone wants to collab on a haskell compiler?
10:30:21 <flaggy> I think I'd be worrying about the wrong things if I used a more complex language
10:30:27 <vanila> that might not work well i dunno, haha
10:30:39 <vanila> just for leraning
10:30:54 <augustss> It's a good way to learn.
10:31:02 <hpc> vanila: to learn by writing, or learn by reading?
10:31:25 <hpc> i can see value in writing a compiler that does things in easier ways and then documents them through the roof
10:31:54 <vanila> yeah nice idea
10:32:05 <SharpGAF> vanila: If you just want to learn how to write a compiler, I strongly recommend http://www.cs.princeton.edu/~appel/modern/ml/
10:32:28 <augustss> You can write a self-compiling compiler for a subset of Haskell in about 1000 lines.
10:32:47 <vanila> augustss, woah!!
10:33:22 <augustss> I have one.  It has no type checker. :)
10:33:35 <augustss> It bootstraps in about 1s.
10:34:03 <vanila> that sounds awesome! Will you write a post or release code about it or something?
10:34:11 <SharpGAF> augustss: You can write a self-hosting compiler for a subset of C in 600 lines :P  http://homepage.ntlworld.com/edmund.grimley-evans/cc500/
10:34:14 <vanila> is that LLVM?
10:34:19 <SharpGAF> (Less impressive I suppose).
10:34:48 <augustss> SharpGAF: You can write a self-host compiler for a subset of C in 3217 bytes.
10:35:04 <vanila> haha damn, this is getting insane
10:35:20 <SharpGAF> Haha.
10:35:34 <augustss> I won IOCCC with that entry many years ago.
10:35:41 <SharpGAF> Neat.
10:36:01 <shachaf> augustss: You can do it in less, depending on which subsets qualify.
10:36:32 <flaggy> I bet you can write a self-hosting compiler for perl in one line :P
10:36:35 <augustss> http://www.ioccc.org/years.html#1996_august
10:36:38 <SharpGAF> shachaf: Well, if you make your subset small enough you can specify a version of C whose only valid output is the self hosting compiler, I guess
10:36:46 <shachaf> Yes.
10:36:54 <hpc> flaggy: eval @_; # ;)
10:37:08 <flaggy> :P
10:37:14 <hpc> (bootstrapping process may be very difficult)
10:37:24 <vanila> What the HelllllllLL??????
10:37:34 <vanila> { ;		;
10:37:35 <vanila> ;	1 {
10:37:35 <vanila> 	{	!
10:37:38 <SharpGAF> Related: https://github.com/dwaite/urb
10:38:05 <augustss> vanila: Are you looking at the initial comment in my code?
10:38:16 <vanila> oh its a comment!
10:38:20 <vanila> I thought that was part of the code
10:38:46 <augustss> It's an essential comment.
10:38:55 <augustss> It contains the bytecode for the compiler.
10:39:02 <SharpGAF> vanila: Are you familiar with the premise of IOCCC?
10:39:24 <vanila> XD
10:39:27 <vanila> i cant believe this
10:39:35 <vanila> how does this program exist
10:41:12 <flaggy> I like how even augustss name is sort of an obfuscation. It leads you to think that the new entries will be other months
10:42:49 <vanila> wow it's self decompressing
10:45:01 <vanila> I dont know what to think now lol
10:45:39 * hackagebot hspec-expectations-lens 0.4.0 - Hspec expectations for the lens stuff  http://hackage.haskell.org/package/hspec-expectations-lens-0.4.0 (MatveyAksenov)
10:45:48 <augustss> Take it as an example of how not to write code.
10:46:08 <hpc> or practice for how others write code
10:50:14 <augustss> My other two IOCCC entries are actually FP related.  Both are encodings of a lazy functional program in C.
10:54:58 <tromp_> This year has a winner like that as well. Factorial using Y for recursion in fully conformant C
10:55:13 <vanila> I couldnt see the 2014 code?
10:55:20 <tromp_> Not released yet
10:55:44 <tromp_> It was by my tetris co-author; he showed me the source already
10:59:37 <DrSkyLizard> Are there any examples/projects using machine learning or data mining techniques/algorithms implemented in Haskell ?
11:01:00 <josephle> DrSkyLizard: https://github.com/mikeizbicki/HLearn
11:01:09 <josephle> but I'm not sure if it's still in active development
11:01:15 <dmj`> anyone here use circleci for their haskell projects?
11:01:17 <carter> josephle: it is, but its not meant for serious use
11:01:32 <josephle> carter: good to know!
11:01:36 <carter> its an on going research program to discover better abstractions for machine learning
11:01:45 <carter> so its more about supporting mike izbicki's explorations
11:01:47 <carter> than helping you
11:01:49 <carter> :)
11:02:05 <carter> i've some stuff lying around, but its not yet ready for public consumption
11:02:13 <carter> theres also a bunch of neat random stuff on hackage
11:03:53 <xificurC> a compiler has at least - lexical analysis, parsing, optimization, code generation. Which phases does Parsec cover?
11:03:57 <josephle> isn't there also that relatively new book "Haskell Data Analysis Cookbook"?
11:04:01 <josephle> dunno if it's any good
11:04:02 <xificurC> I'm having trouble seeing the correlation
11:04:11 <vanila> parsec is just turning a stream of text into syntax
11:04:18 <vanila> its only the very start bit of a compiler
11:04:23 <DrSkyLizard> josephle: yeah, I've heard of that one, will check it out
11:04:59 <DrSkyLizard> I want to start doing a machine learning project with Haskell, just wanted to see what libs/tools I already have as my foundation
11:05:10 <xificurC> vanila: I see parsec as lexical analysis + parsing
11:05:18 <xificurC> but I don't know if I'm correct
11:05:22 <vanila> yes youre right
11:06:06 <xificurC> vanila: so if I read about lex and yacc somewhere, parsec is something that combines the two
11:06:18 <vanila> well I think lex and yacc are a different approach to this
11:06:32 <drdo> I tried to figure out how to use parsec for slighly complicated grammars, then i just ended up using alex/happy
11:06:34 <vanila> lex and yacc are like the old school parser generator system from Knuths LR idea
11:06:39 <xificurC> vanila: yes, but with the same output, no?
11:06:43 <vanila> and parsec is based on functioanl programming and higher order functions
11:07:11 <vanila> yeah absolutely, they are used for the same purpose
11:07:19 <hnoob> I've been learning a bunch of haskell this year, its complicated and difficult at times.  I've been doing some c++ contract work this week, and going back to C++ is an eye opener.
11:07:31 <hnoob> C++ is THE DEVIL'S OWN LANGUAGE
11:07:39 <vanila> haha
11:07:46 <xificurC> vanila: thanks for the clarification
11:07:52 <shachaf> hnoob: Please, no language bashing in here.
11:08:39 <augustss> shachaf: Speaking the truth is no longer allowed? ;)
11:08:50 <hnoob> sorry just expressing my frustration!
11:08:52 <xificurC> shachaf: one could take his comment as a compliment
11:10:16 <vanila> its all good hnoob :)
11:10:39 * hackagebot ACME 0.0.0.0 - Essential features  http://hackage.haskell.org/package/ACME-0.0.0.0 (JamesCandy)
11:10:59 <hnoob> I knew you guys would understand : )
11:18:40 <ab9rf> i just got twitchy thinking about the idea of implementing a C++ parser in parsec
11:19:02 <ab9rf> although really it doesn't matter what parsing library or parser generator you use, C++ is hard to parse
11:19:16 <johnw> ab9rf: I support you could do it with ParsecT
11:19:18 <johnw> suppose
11:19:58 <johnw> C++ parsing is highly context dependent, so you'd need to carry around knowledge of the current scope and all previous declarations
11:20:27 <HeladoDeBrownie> note that even Parsec (as opposed to ParsecT) allows for user state
11:20:42 <ab9rf> HeladoDeBrownie: allows, but doesn't necessarily make fun :)
11:20:44 <HeladoDeBrownie> however for the preprocessor you may need to use IO
11:21:00 <ab9rf> may?  kinda hard to do #include without it
11:21:18 <HeladoDeBrownie> it's hard for me to speak in absolutes when i've considered the problem for mere seconds :)
11:21:46 <ab9rf> you could use a prepreprocessor to identify all possible #includes and prestage their content, then you wouldn't need IO :)
11:23:29 <RedNifre> I did it! I reached my first cabal hell! Progress! :)
11:23:42 <ab9rf> eheh
11:24:16 <monochrom> ParsecT String MyState IO C_plus_plus_program
11:24:38 <RedNifre> So I can't run caball update because it runs "out of memory" and I can't install something because it needs something else which I could get with "force reinstalls" which would break packages I haven't heard of... can you recommend a tutorial that explains all this to me? I feel a bit lost here.
11:25:14 <ab9rf> RedNifre: i've blown away my haskell installation two or three times to "resolve" cabal hell
11:25:17 <monochrom> cabal update out of memory is a bit rare. how much memory could you afford?
11:25:28 <ab9rf> how much page file do you have?
11:25:58 <jesyspa> C++ parsing involves performing arbitrary computations, so I'm not quite sure ParsecT would be enough.
11:26:01 <monochrom> ghc and later the linker are the ones that usually use much memory. especially the linker.
11:26:09 <RedNifre> My haskell machine is an OpenBSD box with only 1GB RAM of which 890M are free.
11:26:22 <HeladoDeBrownie> jesyspa, oh, you're referring to templates?
11:26:26 <monochrom> that should be enough for cabal update
11:26:30 <jesyspa> HeladoDeBrownie: Yeah.
11:26:41 <monochrom> also most big linking jobs
11:26:45 <HeladoDeBrownie> i think you could still do that with ParsecT over IO but i may be mistaken
11:27:07 <monochrom> in ParsecT you can still do arbitrary computation
11:27:15 <koala_man> RedNifre: 1GB is not enough for haskell. how about adding some swap
11:27:23 <jesyspa> Ah, hm, okay.
11:27:38 <RedNifre> Ah, good to know. Hm, that's unfortunate.
11:27:43 <monochrom> you have all of Haskell at your disposal. plus, you can use System.Process to out-source some jobs if you want.
11:28:33 <monochrom> compiler :: Parsec ByteString MyState IO C_plus_plus_program
11:29:46 <RedNifre> The idea was to do Haskell dev on my tiny server (mosh, tmux, vim) so I could do it from anywhere... but I guess I didn't really use that feature anyway... guess I'll move it over to my desktop machine. Hm...
11:30:14 <brainacid> hey all
11:30:21 <hnoob> 1gb not enough?  Maybe not for building GHC but I use haskell on the raspberry pi and its mostly ok
11:30:44 <brainacid> wondering if there is any recommended math reading for learning haskell-thought ???
11:30:56 <RedNifre> I'm a bit unfamiliar with compiled languages... if I want to run a binary on my OpenBSD server I still have to compile it on OpenBSD 32bit, right? It wouldn't work if I created the binary on my 64bit Ubuntu machine, correct?
11:31:04 <brainacid> im a hobby programmer
11:31:08 <burp_> haskell-src-exts package will require quite some memory
11:31:12 <brainacid> no experience
11:31:23 <burp_> for compilation/linking
11:31:30 <drdo> RedNifre: correct (although it is possible to compile binaries for one machine on another)
11:31:33 <koala_man> RedNifre: openbsd has a linux emulation layer
11:31:42 <hnoob> I think building cabal is another big memory hog IIRC
11:31:54 <vanila> brainacid, I don't think math will help you do haskell, but the other way around
11:32:08 <vanila> Although you could pick math you like and try using haskell to explore it
11:32:19 <HeladoDeBrownie> brainacid, learning math may not be the best method of getting better at haskell. usually i see something like the other way around: people incidentally learn some math through haskell
11:32:25 <hnoob> RedNifre:  its possible to cross compile, ie build for 32 bit on a 64 bit machine.
11:32:26 <brainacid> vanila, ok thanks
11:32:36 <dmj`> vanila: well put
11:32:47 <hnoob> but in general yes you should build on the machine you want to run on if you can
11:32:52 <brainacid> ok so i will continue reading and learning haskell
11:32:54 <HeladoDeBrownie> brainacid, if you are interested, there tend to be seen many links between category theory and haskell, so you might try asking ##categorytheory for their recommendations for someone who knows some haskell
11:32:55 <brainacid> thanks
11:33:09 <RedNifre> Is that easy? Is it easier than creating a 32bit OpenBSD virtual box and compile from there?
11:33:27 <hnoob> I dunno I've never actually done it!  : )
11:33:42 <HeladoDeBrownie> brainacid, category theory is quite abstract, and won't necessarily make you a better haskell programmer. be prepared to put in some mental effort learning it if that is what you decide to do.
11:33:43 <hnoob> I've gone the virtualbox route
11:33:56 <RedNifre> virtualbox it is then.
11:34:18 <brainacid> HeladoDeBrownie, ok ... thanks... i got several books on haskell so I will continue with them
11:34:30 <RedNifre> Regarding cabal... what exactly would I have to delete to do a full reset and what would be the downsides?
11:34:51 <hnoob> delete ~/.cabal directory
11:35:00 <hnoob> also maybe ~/,ghc I think
11:35:06 <HeladoDeBrownie> not just that. hold on, i have a bookmark for this
11:35:37 <RedNifre> ...and then I would just cabal install my own project and it would magically install everything it needs, right?
11:35:46 <hnoob> downsides, you have to reinstall all the libs
11:35:47 <HeladoDeBrownie> hmm, this might help http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
11:36:09 <hnoob> if you have newer cabal you could try "cabal sandbox init" to get much the same effect
11:36:18 <hnoob> ie an empty sandbox
11:36:20 <HeladoDeBrownie> though i guess that's not quite what you asked... i thought there was something on resetting everything there
11:36:54 <hnoob> sandboxes are cool because you can have a separate sandbox for each project
11:37:12 <HeladoDeBrownie> RedNifre, found it http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
11:37:19 <hnoob> they are uncool because you have to recompile 100 libraries for every sandbox.  well, maybe not 100 but still
11:37:31 <HeladoDeBrownie> page search for "erasing all user packages"
11:37:51 <HeladoDeBrownie> RedNifre, i also suggest reading the entire rest of that article
11:37:56 <HeladoDeBrownie> before doing anything else
11:38:36 <RedNifre> Sandboxes are only available in cabal 1.18, right? I'm stuck on 1.16 because both cabal update and cabal install cabal-install run out of memory.
11:38:52 <drdo> i love when i do a reinstall and the packages are still broken
11:38:56 <HeladoDeBrownie> RedNifre, you're going to need to solve that out of memory problem
11:38:56 <drdo> What can i do in this case?
11:39:24 <HeladoDeBrownie> RedNifre, probably best if you did it from your desktop like you mentioned. what os do you run there?
11:40:04 <RedNifre> Ubuntu 64bit
11:40:12 <HeladoDeBrownie> great
11:41:02 <HeladoDeBrownie> what i usually end up doing is install ghc from binaries (get it here https://www.haskell.org/ghc/), installing the cabal-install package, and updating to latest caball-install using `cabal install cabal-install` and ensuring $HOME/.cabal/bin is in my PATH
11:41:04 <RedNifre> The idea behind having it on my tiny server was "use on any computer" and "have my dev environment separate from my main computer so I don't have to reconfigure everything when I get a new computer or have to reinstall the OS".
11:41:26 <RedNifre> How do your dev setups look like? Might it be a good idea to set everything up in a VM?
11:41:26 <HeladoDeBrownie> RedNifre, i understand, but if you don't have enough memory then you'll have some possibly non-trivial problems. can you add more memory?
11:42:18 <hnoob> cool idea... unfortunately small computers and haskell are uncomfortable together.  building GHC and cabal are resource intensive tasks
11:43:06 <hnoob> I built ghc for the raspberry pi one time, ended up doing it in QEMU with a huge swap.   took 4 days to compile
11:43:14 <zomg> you can compile on another machine too
11:43:29 <zomg> low power VPS, compiled on my desktop using a VM with a compatible linux in it :)
11:43:34 <HeladoDeBrownie> make sure they're the same architecture, and for good measure same username would be good
11:43:54 <HeladoDeBrownie> (many of the installed files have hardcoded absolute directories mentioned in them)
11:44:09 <zomg> the binaries will work if you compile with static linking
11:44:24 <RedNifre> Yeah, I guess developing in a powerful VM that mimics your server is the best option.
11:45:15 <hnoob> all that said, aside form GHC and Cabal I've been mostly fine with haskell on the PI.  I just go with the version that's there and don't worry about it.
11:47:26 <hnoob> arch has more up to date compilers, might be worth considering
11:48:00 <hnoob> the only time ghci has ever worked for me on ARM was with arch.
11:49:27 <HeladoDeBrownie> is arch usually hard to setup? i do recall having significant difficulty setting up a DE on my laptop, at least, but the story may be different here
11:49:43 <vanila> arch is not hard to set up I think the instructions are good
11:49:57 <vanila> you have to do more stuff manually than debian or fedora or something, but much less than gentoo
11:50:19 * HeladoDeBrownie makes a note never to try installing gentoo on a laptop
11:50:50 <hpc> arch has a fairly aggressive update policy that can easily put you in a state where you can't update without breaking your system
11:51:26 <barrucadu> That's often said, but in practice I don't think I've seen that be the case for many years
11:51:29 <RedNifre> is there a recommended OS for haskell?
11:51:43 <HeladoDeBrownie> RedNifre, usually something gnu/linux-based
11:51:43 <vanila> no it should work on any OS
11:51:59 <HeladoDeBrownie> it should and does but the setup may be harder on some
11:52:14 <HeladoDeBrownie> well, not *any*, but many
11:53:17 <HeladoDeBrownie> although for all i know many *nixes are fine, including os x
11:53:42 <HeladoDeBrownie> i guess what i'm saying is i don't envy the one who wants to set up a haskell dev environment on windows
11:53:58 <RedNifre> so, how much RAM should I give my haskell dev machine?
11:55:20 <barrucadu> iirc, text needs 1GB to compile, so at least that
11:55:41 <barrucadu> But 2GB would probably be more comfortable if you can spare it
11:55:50 <koala_man> RedNifre: with 2GB it should only fail for larger files
11:56:07 <HeladoDeBrownie> i think the server i've compiled some things on has had 1gb, but my laptop which i usually use has 4
11:56:23 <koala_man> 2GB + swap is fine
11:56:47 <koala_man> for the time being
11:58:25 <RedNifre> okay, any idea how much disk space I might need?
11:59:05 <HeladoDeBrownie> i know ghc takes multiple gigs
11:59:41 <HeladoDeBrownie> oh, 1gb, never mind
12:00:28 <HeladoDeBrownie> i think that might be the largest single thing you'll need
12:01:07 <HeladoDeBrownie> if you install ghc from sources at some point you'll have about 2gb taken up by ghc and the install files
12:01:12 <HeladoDeBrownie> er, binaries
12:01:17 <HeladoDeBrownie> installing ghc from sources is probably a bad idea
12:01:22 <HeladoDeBrownie> unless you're developing it
12:01:26 <johnw> RedNifre: I'd be happy with 500gb of disk, 4gb of RAM, and running NixOS, if it were only for Haskell development
12:02:11 <johnw> the rest of the money going into best single-core performance, since you'll spend a fair bit of time waiting on GHC to recompile your changes
12:02:24 <RedNifre> 500 gb for development? I would have guessed 25GB would be enough. Just checked, on my tiny server I seem to only use about 800MB
12:02:36 <johnw> it's Nix though, it keeps past generations so that you can always rollback
12:03:06 <johnw> and allows you to easily have multiple versions/configurations of GHC installed
12:03:24 <johnw> oh, this is for a server, not for development?
12:03:38 <RedNifre> no, for development.
12:03:51 <HeladoDeBrownie> you basically want to ssh in to it to develop haskell, right?
12:04:11 <RedNifre> no, it's a vm on my main machine.
12:04:22 <HeladoDeBrownie> ah, okay, wasn't sure if you'd decided to go that route
12:04:35 <desophos> RedNifre: may i make some recommendations? i just set up a new dev VM
12:04:41 <RedNifre> yes, please.
12:05:11 <RedNifre> I'm still very new to haskell, compiled languages, VMs and servers, I just started about 2 months ago and I'm still pretty clueless.
12:05:40 <desophos> RedNifre: if you aren't set on an OS, i'd recommend a minimal install of ubuntu; you can use the net installer, which lets you refuse to install anything but the ubuntu core
12:05:41 <desophos> https://help.ubuntu.com/community/Installation/MinimalCD
12:05:42 * hackagebot atomic-primops 0.6.1.1 - A safe approach to CAS and other atomic ops in Haskell.  http://hackage.haskell.org/package/atomic-primops-0.6.1.1 (RyanNewton)
12:05:54 <desophos> and then install things on top of that
12:06:10 <desophos> fluxbox is a nice window manager
12:06:47 <desophos> personally i'm too much of a noob not to work in a graphical environment
12:07:37 <HeladoDeBrownie> the popular vision of an elite programmer as someone who uses a solely textual environment doesn't seem that honest to me
12:08:39 <HeladoDeBrownie> i think that a good programmer is someone who uses the available tools well, rather than someone who can get away with using as little as possible
12:09:30 <geekosaur> agreed
12:09:34 <RedNifre> Well, I like binge learning, so I learned Haskell, BSD, vim+tmux+mosh simultaneously. I like how distraction free text only development is but I sure miss IDE features (IntelliJ for haskell would be excellent)
12:09:38 <vanila> does edsko from well-typed hang out here?
12:09:58 <vanila> i just wanted to say that blog post with SMT for optimizing was really awesome
12:10:17 <kadoban> RedNifre: You've researched the good vim plugins? They mostly do what I'd expect from an IDE, at least the parts I care about, like autocomplete and such.
12:11:12 <RedNifre> regarding ubuntu on the server: I chose OpenBSD because of the "secure by default" slogan. I'm not a security expert, so running my own server is a bit intimidating for me... It's great that I don't have to worry about things like shell shock thanks to OpenBSD.
12:11:48 <RedNifre> kadoban a bit, but I haven't set up vim perfectly yet... if that is even possible in a lifetime.
12:12:09 <kadoban> Yeah, me either. I've gotten mine nice enough that I don't care to spend extra energy improving it at least.
12:12:19 <hpc> RedNifre: there's still a fair bit to worry about
12:12:38 <hpc> the bsd family was not unaffected by the explosion of ssl vulnerabilities, for instance
12:12:51 <hpc> (but that hit literally everyone)
12:12:53 <kadoban> RedNifre: No off-the-shelf OS is really going to save you completely from 0-days like shellshock, unfortunately.
12:13:37 <vanila> not even mirage ?
12:14:07 <kadoban> All you can really do is try to follow some basic security precautions, and keep your software up-to-date as much as you can.
12:14:09 <kadoban> mirage?
12:14:22 <RedNifre> yeah, but Ubuntu is just too surprising... did you know that if you have multiple users on Ubuntu, every user can read every other user's home directory? They say this is for convenience, but I prefer security when it comes to servers.
12:14:31 <vanila> its an OS kernel written in mostly ocaml
12:14:37 <kadoban> Ah
12:15:17 <kadoban> RedNifre: Yeah, always thought that was a mistake
12:15:42 * hackagebot regex-applicative 0.3.1 - Regex-based parsing with applicative interface  http://hackage.haskell.org/package/regex-applicative-0.3.1 (RomanCheplyaka)
12:16:21 <geekosaur> it's actually a fairly old behavior...
12:17:27 <geekosaur> Back In The Day that was normal and encouraged. of course that day was in the 80s
12:17:41 <desophos> RedNifre: are you going to use OpenBSD for your dev machine too?
12:18:20 <geekosaur> back when we used telnet and the r-commands (security, wat?)
12:19:09 <vanila> lol i just read this total troll post http://coderinaworldofcode.blogspot.co.uk/2014/09/how-i-fixed-shellshock-on-my-openbsd-box.html
12:19:13 <vanila> very funny
12:19:32 <vanila> is anyone using 64 bit openbsd?
12:19:45 <vanila> how is the situation getting functional language compilers working on that
12:20:44 <kadoban> I thought GHC already supported the bsds. I know my web host is on freebsd and they've have GHC for a long long time at least.
12:21:13 <vanila> what I really want it SML actually but..
12:21:59 <lf94> AFAIK, ghc is available on openbsd, but why not just do some research instead?
12:23:06 <vanila> lf94, I don't think you know what you're talking about
12:23:48 <RedNifre> desophos Yes, I'm quite happy with OpenBSD as my server OS (Not that I can compare it to much else) so I want to create a VM that mimics my server and do haskell development there.
12:24:58 <desophos> RedNifre: hm alright, can't help you then, sorry :) i've only used ubuntu and variants
12:26:03 <johnw> RedNifre: I do a similar thing, but for other OSes
12:26:09 <RedNifre> Well, I'll just mimic the server, but with more memory. Since cabal's "out of memory" errors were the only problems I had with haskell on OpenBSD, I'm optimistic that it will Just Work(tm).
12:30:45 <RedNifre> johnw which OSes do you use?
12:30:56 <johnw> OS X and NixOS
12:31:03 <johnw>  oh, and one CentOS box
12:37:19 <monochrom> RedNifre: my test seems to say that "cabal update" uses 350MB memory. linux x86-64.
12:39:31 <RedNifre> I haven't done any haskell dev in over a month, maybe it's been too long since I last ran cabal update so it needs too much memory now?
12:39:46 <monochrom> no, it does not depend on that
12:39:59 <RedNifre> It's weird, I think I have a 2GB swap file so memory shouldn't really be an issue.
12:40:09 <monochrom> every "cabal update" starts from scratch
12:40:19 <Aruro> > sin pi
12:40:20 <lambdabot>  1.2246467991473532e-16
12:41:06 <monochrom> my cabal-install version is 1.20.*
12:41:18 <goldenwest> I have a data type that is constructed using a Regex datatype
12:41:31 <goldenwest> there's no instance of Show and so when I try to derive show for my instance it fails
12:41:37 <goldenwest> how can I fix this?
12:42:15 <vanila> maybe you could use standalone deriving , im not sure
12:42:25 <monochrom> but I don't think older versions use more memory. just more time. (there was a time it used an embarrasingly quadratic algorithm. of the kind "keep appending an item to the end of the list")
12:42:55 <monochrom> (yes, of the newbie kind! :) )
12:43:05 <goldenwest> vanila: not sure what you mean
12:43:11 <vanila> it makes show instances
12:43:31 <goldenwest> vanila: you mean "deriving Show"?
12:43:37 <vanila> no
12:43:42 <vanila> standalone deriving
12:44:40 <monochrom> (it was pretty hilarious when the finder announced "hi I just found a simple change that speeds up cabal update a thousand times")
12:45:05 <goldenwest> vanila: so just the word "deriving"
12:45:44 * hackagebot webdriver 0.6.0.4 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.6.0.4 (AdamCurtis)
12:46:44 <Aruro> it is possible to see list of functions in package using hoogle command line?
12:47:46 <monochrom> no, hoogle seems to just do the other direction
12:48:03 <monochrom> oh! but I have a cunning plan.
12:48:40 <monochrom> enumerate all possible function names. for each name, ask hoogle for package. collect all those names that hit the package you desire.
12:48:58 <vanila> enumerate all possible function names <- this coudl be slow
12:49:08 <monochrom> (this is definitely inspired by: I will be TAing a computability course in a few weeks)
12:49:27 <monochrom> :)
12:49:58 <Aruro> like when i do hoogle self
12:50:14 <Aruro> it tells me there is package with that name
12:50:29 <Aruro> but reasonably now i want to see list of its functions :)
12:50:56 <monochrom> I guess you have to hop over to hackage for further stuff in that package
12:51:06 <Aruro> ok
12:51:52 <monochrom> (\p -> "http://hackage.haskell.org/package/" ++ p) is how to construct the right url
12:53:21 <Aruro> you mean to include it in ghci?
12:53:51 <Aruro> ok just package
12:53:58 <Aruro> i want to see it in ghci
12:54:00 <monochrom> no, I mean you can do it yourself. but you can program something to do it, too.
12:54:22 <Aruro> yes maybe i should do that :)
12:55:00 <Aruro> on a side note, is there a way to reverse ghci direction of output? to print stuff below
12:55:03 <agibiansky> monochrom: this isn't exactly what you want but I do this sometimes ‚Äì if you import a module, you can then autocomplete functions in it. e.g. type "Prelude." and then press tab to get all functions exported by prelude
12:55:08 <Aruro> not above cursor line
12:55:17 <seanparsons> edwardk: Is there a video of the talk you did a couple of weeks before Christmas?
12:55:44 * hackagebot abt 0.1.0.2 - Abstract binding trees for Haskell  http://hackage.haskell.org/package/abt-0.1.0.2 (JonSterling)
12:56:49 <Aruro> nyc haskell meetup has tons of nice videos
12:57:02 <Aruro> did not watch any yet but all seem very nice
12:58:07 <Taneb> I really want to go to a Haskell meetup but I don't know of any around here
12:59:04 <lf94> I want watch a formal lecture on Haskell
13:00:37 <monochrom> try to get into Oxford. they have very formal lectures on Haskell. :)
13:00:44 * hackagebot abt 0.1.0.2.1 - Abstract binding trees for Haskell  http://hackage.haskell.org/package/abt-0.1.0.2.1 (JonSterling)
13:01:28 <barrucadu> Taneb: You could try and get something going yourself!
13:01:59 <Taneb> barrucadu, bah, that requires effooooort
13:02:55 <barrucadu> Yeah, hence why I said "you" rather than "we"
13:03:05 <monochrom> finding a stable venue is the biggest problem.
13:04:27 <Welkin> why do you want lectures?
13:04:36 <monochrom> what happened with the Toronto case is this: the founder was a paid member of the local maker club; the membership fee entitled him (every member) to book the place for meetings.
13:04:44 <Welkin> if you want to meet with other people to talk about haskell, just host a party/conference
13:05:09 <Welkin> you can do it from your home even
13:05:46 <monochrom> he later left us for another city. but the successor is also a paid member of the local programmer-innovator club; the membership fee again entitles him to host meetings.
13:06:10 <monochrom> at the end you see that you have to at least pay money. there is no free Haskell meetup.
13:06:29 <Taneb> That feels quite unstable
13:06:29 <EvanR-work> ill bring the cheetos and mountain dew
13:07:25 <Aruro> [a,b] <- getArgs will crash the program if there is only one argument
13:07:32 <Welkin> of course
13:07:41 <Aruro> is it possible for compiler to see it?
13:07:43 <Welkin> you always run that risk when pattern matching directly like that
13:07:53 <drdo> Aruro: hmm?
13:07:58 <Welkin> instead, don't pattern match on it like that
13:08:40 <Aruro> well , but compiler did not warn me of that high risk, my question is it possible for compiler to prevent me doing that?
13:08:58 <monochrom> I tell you what is really stable. everyone does nothing to cause a meetup to happen. neither money nor legwork. that is provably the most stable equilibrium point.
13:09:02 <drdo> Aruro: I'm fairly sure ghc will warn of that if you compile with -Wall
13:09:04 <Welkin> args <- getArgs; case args of a:b:[] -> Just (a,b); _ -> Nothing
13:09:29 <Aruro> ty welkin that workaround i know
13:09:44 <Aruro> i want ghc to warn me of stuff like that
13:10:06 <Aruro> common motto of haskell - if it compiles it probably will work
13:10:12 <Aruro> and here is example of that being not true
13:10:19 <Welkin> Aruro: unless you do unsafe things
13:10:21 <drdo> Aruro: GHC warns you
13:10:28 <drdo> Just compile with -Wall
13:10:34 <EvanR-work> not everything will be warned
13:10:44 <EvanR-work> theres plenty of bad things you can do and it will just compile
13:10:45 * hackagebot monad-coroutine 0.9 - Coroutine monad transformer for suspending and resuming monadic computations  http://hackage.haskell.org/package/monad-coroutine-0.9 (MarioBlazevic)
13:10:48 <Aruro> what does wall option means drdo?
13:10:49 <EvanR-work> foo x y = undefined
13:10:51 <Welkin> using head, tail or !! is unsafe
13:10:55 <Welkin> along with many other functions
13:10:56 <drdo> Aruro: all warnings
13:11:02 <Aruro> ok
13:11:02 <EvanR-work> foo x y = foo x y
13:11:04 <Aruro> let me test it
13:12:05 <Enzoray> > init [1,2,3,4]
13:12:07 <lambdabot>  [1,2,3]
13:12:13 <Aruro> ok i tested
13:12:34 <Aruro> -Wall does not warn me about [a,b] <- IO String problem
13:12:48 <Aruro> which as i see if fairly known
13:12:49 <drdo> weird
13:12:52 <drdo> i thought it would
13:12:55 <Aruro> is*
13:12:58 <Aruro> no
13:13:01 <drdo> It usually warns about non-exhaustive patterns
13:13:11 <Aruro> it warned me i did not put type signature on main
13:13:19 <Aruro> then i put and got no warnings
13:14:11 <Aruro> actually isnt getArgs type actually [IO String] ?
13:14:20 <drdo> no it's IO [String]
13:14:28 <Aruro> :t getArgs
13:14:29 <lambdabot> Not in scope: ‚ÄògetArgs‚Äô
13:14:30 <Welkin> :t getArgs
13:14:31 <lambdabot> Not in scope: ‚ÄògetArgs‚Äô
13:14:45 <geekosaur> :t System.Environment.getArgs
13:14:45 <Welkin> :t System.IO.getArgs
13:14:46 <lambdabot> IO [String]
13:14:46 <lambdabot> Not in scope: ‚ÄòSystem.IO.getArgs‚Äô
13:14:51 <Aruro> yes
13:14:55 <Welkin> ah, Environment
13:15:47 <Aruro> so ghc can not figure [x,y] <- getArgs case?
13:16:05 <Aruro> cause it has no idea about list length?
13:16:16 <Welkin> what?
13:16:17 <Taneb> It doesn't know the listlength until runtime
13:16:43 <geekosaur> arguably it should complain about incomplete patterns. *but* that particular use case never allows you to complete patterns
13:16:43 <EvanR-work> would be nice if [x,y] <- foo counts as an non-exhaustive pattern match
13:16:48 <geekosaur> so I think it just lets it go
13:16:53 <glguy> Aruro: do notation is defined to translate pattern matches into a case where the fallthrough cases is a call to "fail"
13:16:59 <glguy> there's no warning because it's working as intended
13:17:11 <EvanR-work> :t fail
13:17:12 <lambdabot> Monad m => String -> m a
13:17:21 <Taneb> fail is pretty ugh
13:17:23 <Welkin> I read about fail and how it should be replaced by mzero
13:17:27 <Aruro> from Taneb answer it is clear that ghc can catch this error
13:17:28 <glguy> There's some discussion started a few years ago on this topic https://ghc.haskell.org/trac/ghc/ticket/5813
13:17:32 <shachaf> let [x,y] = ... in ... is also working as intended, with no fail excuse
13:17:42 <Aruro> list on the left has fixed size on compile time
13:17:45 <Aruro> pattern list
13:17:53 <Taneb> Aruro, what? No, I was saying GHC can't
13:17:53 <Aruro> while other side does not
13:18:14 <Aruro> yes, but i mean from your answer it follows it is possible
13:18:21 <Aruro> that is what im saying
13:18:28 <Taneb> Yes, but strictly speaking it's against the Haskell langauge
13:18:32 <Taneb> Because of fail
13:18:44 <Aruro> why?
13:19:02 <Aruro> fail has similar properties?
13:19:49 <geekosaur> not because of fail /per se/. because the Haskell standard defines a desugaring for pattern matches in "do" which always adds a ``_ -> fail "..."
13:20:03 <Taneb> A failing pattern match in do notation goes straight into the "fail" function
13:20:11 <Welkin> just don't pattern match on results directly
13:20:17 <Aruro> so you mean its my fault i did not use fail?
13:20:23 <geekosaur> so, as far as a standard-conformant compiler is concerned, it always matches
13:20:26 <geekosaur> ...
13:20:28 <Taneb> Aruro, no
13:20:36 <Taneb> It's GHC's fault that you actually did use fail
13:20:46 <Taneb> Without you realising
13:20:52 <Aruro> oh its already there
13:21:01 <Aruro> can i take control of it?
13:21:10 <Aruro> explicitly?
13:21:12 <geekosaur> don't use a pattern match there
13:21:17 <Aruro> oh
13:21:23 <Aruro> if it works its possible
13:21:24 <geekosaur> say `x <- ... ` and then pattern match it yourself
13:21:27 <Welkin> Aruro: yes, you can not use a pattern match directly on the result
13:21:35 <Enzoray> Why doesn't this work?
13:21:45 <geekosaur> because if you use a refutable pattern then the compiler *must* insert a default match that invokes fail
13:21:49 <Enzoray> @ipaste
13:21:49 <lambdabot> Haskell pastebin: http://lpaste.net/
13:21:51 <Welkin> Aruro: if you think about it, that pattern match doesn't make sense because it is incomplete
13:21:56 <Welkin> it will fail on an empty list
13:22:17 <Welkin> whther or not the compiler warns you of this is pretty irrelevant
13:22:18 <EvanR-work> > Nothing >>= \(Just x) -> Nothing
13:22:19 <lambdabot>  Nothing
13:22:32 <Enzoray> http://lpaste.net/117647
13:22:36 <Aruro> i think it is relevant if it is possible
13:22:43 <Aruro> thus i could learn with comiler
13:22:54 <Aruro> in this case he ignored this simple case
13:22:57 <Welkin> yes, and generally the ocmpiler does warn you
13:23:00 <Welkin> but not in this case
13:23:00 <Aruro> or used fault
13:23:00 <tommd> Enzoray: Two reasons
13:23:21 <tommd> Enzoray: a == x   -- here 'a' is a variable and you want a character, I believe.
13:23:30 <tommd> Oops, no no. I glanced too fast. sorry
13:23:32 <geekosaur> nope
13:23:40 <geekosaur> Enzoray, consider what happens when you hit the end of the list
13:23:41 <tommd> So the other one is that error you call on the empty list.
13:23:47 <geekosaur> in your recursive case
13:24:27 <Enzoray> Oh.
13:24:27 <tommd> How many times does 5 appear in the list [ ] ?
13:24:40 <Enzoray> I did it! Changed error to 0.
13:24:46 <Enzoray> tommd, 0.
13:24:46 <tommd> Or 404, if you prefer.
13:24:58 <Enzoray> tommd, hehe... :D
13:25:07 <Aruro> can i forbid refutable patterns?
13:25:28 <tommd> Aruro: Verbally? Yes.  Make GHC enforce this rule? No.
13:25:30 <geekosaur> sometimes, when we want the normal case to do something special, we split it into a top level that throws the error and move the recursion to a sub-function
13:26:27 <geekosaur> e.g.: occurs _ [] = error "lol 404"; occurs a xs = occurs' a xs where occurs' _ [] = 0; occurs' a (x:xs) = ...
13:26:28 <EvanR-work> Aruro: id you did that, you wouldnt be able to do total case analysis normally. like case x of Nothing -> ...; Just y -> ...
13:27:43 <Aruro> so [a,b]<-getArgs bug related at the end to case parsing?
13:27:52 <Enzoray> geekosaur, I see.
13:28:23 <Enzoray> My problem was that I considered to the empty list being an error, instead of it's actual value, 0.
13:28:38 <Enzoray> Because, an empty list is not an error.
13:28:44 <geekosaur> (sadly you can't collapse that to "occurs = occurs' where" because ghc requires arity to match
13:28:45 <vanila> that doesn't make sense at all
13:28:45 <geekosaur> )
13:29:04 <vanila> doesn't that mean it returns the list length when ever the thing you are looking for isn't in the ist
13:29:08 <vanila> list*
13:29:20 <geekosaur> huh?
13:29:34 <vanila> @Enzoray
13:29:34 <lambdabot> Unknown command, try @list
13:29:34 <Enzoray> vanila, what are you implying?
13:29:51 <Aruro> so basically you can not pattern match against IO smth ?
13:29:57 <vanila> im really tired of all the childish meme speak in here
13:30:01 <hexagoxel> Aruro: i would argue that the core problem is that the Monad IO instance defines fail in terms of error. or the design that forces such a definition.
13:30:04 <Aruro> why not to forbid such construction on compiler level?
13:30:26 <geekosaur> Aruro: because for some monads the fail behavor is very useful. notably the list monad
13:30:43 <hexagoxel> not the refutable pattern
13:30:47 <Bor0> with aeson, how can I parse a structure like {"1":"asdf","2":"asdf","4":"asdf"}? I don't have an idea what the data structure would look like
13:30:54 <Bor0> s/parse/decode/
13:31:44 <Enzoray> 2. Accountants are always interested in finding numbers that contain the digit '7'. Implement a function
13:31:44 <Enzoray> hasSeven :: [Integer] -> [Integer]
13:31:44 <Enzoray> that given a list of numbers, returns exactly those numbers that contain the digit '7'.
13:32:00 <Aruro> it would be nice to have extensible list of errors like that
13:32:22 <Aruro> or trigger compiler errors based on user patterns
13:33:12 <Aruro> like adding a rule to compiler saying -- warn of [a] <- IO a
13:33:36 <Aruro> [a] <- IO [a]
13:33:39 <vanila> Aruro, I think that it's to do with monad fail (which is really really bad)
13:33:49 <vanila> hopefully it will get removed and we can get sensible errors
13:34:00 <benzrf> well
13:34:09 <benzrf> i am a fan of the fail instance for Maybe
13:34:19 <geekosaur> byebye nondeterminism monad
13:34:34 <geekosaur> there are better ways to do this than a blunt trauma
13:34:51 <vanila> i don't agree
13:35:27 <geekosaur> ok, your haskell lacks the list, Maybe, and Either monads. next?
13:35:38 <vanila> geekosaur, are you talking to me?
13:35:45 <geekosaur> in fct I uspect yyour haskell contains only the IO monad
13:35:51 <geekosaur> yes, I am talking to you
13:35:59 <vanila> that doesn't make any sense at all
13:36:17 <ReinH> geekosaur: eh?
13:36:23 <vanila> I think you either misunderstand me or are just being silly for fun
13:36:57 <ReinH> monads do not need fail
13:37:10 <geekosaur> maybe I misunderstand you, but what I am hearing is that pattern matches in do that would lead to "fail" being invoked should be banned. have you ever looked at the nondeterminism monad, aka the list monad?
13:37:43 <vanila> you're being really patronizing and rude
13:38:05 <geekosaur> I am trying to understand why you want to remove something useful
13:38:24 <geekosaur> arguably that's what led here in the first place...
13:38:32 <ReinH> pattern matching in do notation is not an essential part of the monad interface
13:38:44 <ReinH> do notation could easily be specialized to MonadFail
13:39:06 <ReinH> or could cause a runtime error in Monad and use fail in MonadFail
13:39:34 <EvanR-work> the list monad is the only justification
13:39:41 <ReinH> But saying that monads other than IO woud not exist without fail is just ridiculous, sorry
13:39:46 <EvanR-work> how often is list monad even used for anything
13:40:08 <geekosaur> someone else mentioned using Maybe that way as well...
13:40:19 <geekosaur> but since everyone knows I am dead wrong, I must have imagined it
13:40:42 <geekosaur> seriously, I am not hearing an alternative formulation, I am being told that this is an evil behavior with zero justification
13:41:04 <vanila> I thinnk you should express yoursel more clearly and not e.g. assume people have no clue about very basic things like 'what list monad is' just because they have a different viewpoint than you
13:41:04 <ReinH> The justification is that there exist valid monad instances except for `fail'.
13:41:13 <drdo> fail is a hack
13:41:54 <geekosaur> vanila, I am missing some expression from you as well, since you seem to think this is not a problem but haven't said why, just informed me that I'm horribly wrong
13:42:06 <vanila> im not discussing this!
13:42:11 <geekosaur> unfortunately that's something of a pattern from you
13:42:20 <vanila> you turned it into a confrontation from the very beginning
13:42:21 <hexagoxel> ad hominem!
13:42:23 <geekosaur> you're not so giid at explaining yourself either, it seems
13:42:27 <vanila> there is no way I can have a reasonable discussion without you about this now
13:42:27 <hexagoxel> moaaar ad hominem!
13:42:32 <vanila> you are just attacking me now
13:42:36 <geekosaur> ...
13:42:39 <vanila> this is really weak, please improve!
13:42:39 <ReinH> geekosaur: what? The only thing she said to you was "I don't agree".
13:42:51 <ReinH> How is this "informing me that I'm horribly wrong"?
13:42:53 <ReinH> Jesus
13:43:19 <johnw> I have a feeling this discussion has left the realm of being productive
13:43:21 <vanila> I don't have any hard feelings but I don't think we can discuss this so ill let another topic come up
13:43:34 <disgrntld> hey gang, does it make sense to compute the sieve of eratosthenes like http://dpaste.com/2KBM0CG ? I'm just starting to scratch the surface of memoization and I'd like to precompute a bunch of primes, but for some reason this runs out of memory around sieves of size 1000000
13:44:20 <Chousuke> length ys?
13:44:20 <vanila> disgrntld, you aren't memoing anything here afaict
13:44:31 <vanila> disgrntld, you would need a top level list of all the primes :: [Int] or so
13:45:01 <ReinH> vanila: (which you can get by cleverly tying the knot ;)
13:45:05 <homovitruvius> is there a library for integral datatypes for 4-value logic and arithmetic (like in Verilog and VHDL, where a bit can be 0,1, high-impedence or unknown)?
13:45:05 <Chousuke> disgrntld: "length ys > 0" traverses the entire list.
13:45:10 <disgrntld> vanila: I'm eventually going to bind sieveOfEratosthenes 1000000 to a name to use in a larger program
13:45:15 <disgrntld> would that work?
13:45:31 <vanila> disgrntld, sort of - should I show a simpler example of memoing? You can base this prime seive stuff on it
13:46:33 <ReinH> disgrntld: wait, does this terminate at all?
13:46:35 <disgrntld> vanila: I would love that, thanks! also Chousuke: noted, lemme try to think through a solution that doesn't use that
13:46:44 <disgrntld> yea, seems to for smaller numbers
13:47:00 <Chousuke> disgrntld: in generall, check "is list empty?" instead of "does list have length of 0"
13:47:09 <disgrntld> gotcha
13:47:25 <Chousuke> first is O(1), the other is O(n), and n may be infinite, so :P
13:47:36 <vanila> disgrntld, http://lpaste.net/117648
13:47:50 <vanila> this turns the normal recursive def of fibs (which is O(fib(n))) into a linear time version
13:48:08 <disgrntld> whoa
13:48:20 <ReinH> disgrntld: Ah, it terminates because you do a dropWhile that never terminates but is productive, so the head can provide a value without evaluating the entire list
13:48:21 <vanila> so if you do something like primes = 2 : 3 : 5 : sieve [7,9]
13:48:30 <ReinH> At least as far as I can tell
13:48:35 <vanila> I meant sieve [7,9..]
13:48:44 <vanila> with some extra parameters probably
13:48:53 <vanila> then you can make us of the primes list while it's being computed, and speed things up a lot
13:49:02 <EvanR-work> how is a dropwhile that never terminates productive
13:49:11 <disgrntld> how did y'all learn how to do this?
13:49:51 <disgrntld> I realize that's a pretty general question, but I just haven't ran across any resources that explain memoization
13:50:04 <ReinH> EvanR-work: because dropWhile is productive
13:50:06 <ReinH> > take 1 . dropWhile (const False) $ [1..]
13:50:06 <Chousuke> mental gymnastics :P
13:50:07 <lambdabot>  [1]
13:50:31 <disgrntld> anyway, I have a lot to pour over
13:50:34 <Chousuke> disgrntld: memoization is just a generic term for "store the value of a computation somewhere so that it can be reused"
13:50:46 * hackagebot ACME 0.0.0.1 - Essential features  http://hackage.haskell.org/package/ACME-0.0.0.1 (JamesCandy)
13:50:50 <Rembane> What does productive mean in this context?
13:50:52 <disgrntld> but it's very different from imperative, dynamic programming style
13:50:53 <ReinH> @src dropWhile
13:50:53 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:51:03 <Chousuke> disgrntld: with haskell, you can do it implicitly because laziness allows definitions that look circular.
13:51:44 <disgrntld> ok, well I'm going to go play with this stuff, thanks everyone!
13:52:02 <ReinH> Rembane: there are actually two things: productivity and guarded recursion
13:52:32 <Rembane> ReinH: That sounds dagnerous
13:52:53 <ReinH> Rembane: consider foldl and foldr:
13:52:55 <ReinH> @src foldl
13:52:55 <lambdabot> foldl f z []     = z
13:52:55 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:52:57 <ReinH> @src foldr
13:52:57 <lambdabot> foldr f z []     = z
13:52:57 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:53:37 <ReinH> now if we use the foldr list identity: foldr () []
13:53:40 <ReinH> er
13:53:44 <ReinH> foldr (:) []
13:53:55 <ReinH> say, foldr (:) [] [1..]
13:54:21 <ReinH> we have: foldr (:) [] [1..] = 1 : foldr (:) [] [2..]
13:54:37 <ReinH> which means that the recursion is "guarded" behind a data constructor, the (:)
13:54:55 <ReinH> So we can pattern match on that data constructor before evaluating the recursive part
13:55:33 <ReinH> > case foldr (:) [] [1..] of (x:_) -> x
13:55:34 <lambdabot>  1
13:56:08 <Rembane> That's quite nifty
13:56:26 <ReinH> with foldl, if we try to do a similar thing, the outermost expression is foldl, so we don't immediately have access to a data constructor to pattern match on
13:56:54 <Aruro> is it possible to install @src command without lambda bot?
13:57:26 <Bor0> with aeson, how can I decode a structure like {"1":"asdf","2":"asdf","4":"asdf"}? I don't have an idea what the ADT would look like
13:57:45 <ReinH> Although I should point out that dropWhile is only productive if it fails to drop at least one element
13:57:59 <ReinH> e.g. dropWhile (const True) = _|_
13:58:06 <johnw> Bor0: it's going to read in as a Map, I believe
13:58:50 <ReinH> Aruro: no
13:59:18 <Rembane> ReinH: Cool. Thank you for the explanation.
13:59:41 <ReinH> Rembane: np
14:00:07 <ReinH> (as in, if at some point it stops dropping elements)
14:00:09 <Bor0> johnw, can you show a short demo?
14:00:18 <johnw> I don't have one handy, no
14:01:29 <Enzoray> hasSeven :: [Integer] -> [Integer], given a list xs, it should return each element with 7 included
14:01:34 <Enzoray> Any hints? :S
14:01:43 <Rembane> ReinH: So if it drops elements forever it won't be constructive?
14:01:59 <ReinH> Rembane: right, which is of course impossible to determine.
14:02:03 <ReinH> (generally speaking)
14:02:12 <ReinH> (*productive)
14:02:18 <Sorella> Bor0: oh, sorry, I've misinformed you. But you should be able to do: `decode json :: Maybe (Map String String)` (see: https://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html#g:3). Working with mixed types is a little more tricky
14:02:54 <ReinH> return type ad-hoc polymorphism can be a bit difficult to work with...
14:03:33 <Rembane> ReinH: INdeed.
14:03:50 <kraljev10> (\y -> if x == y then Just "" else Nothing)
14:04:01 <kraljev10> how would this be simplified?
14:04:16 <ReinH> kraljev10: what is x?
14:04:32 <johnw> \y -> mfilter (const (x == y)) (Just "")
14:04:34 <Sorella> Bor0: so, `maybeItemList :: String -> Maybe (Map String String); toListOfItems s = decode s`
14:04:38 <kraljev10> x and y are Int, but does it matter?
14:04:43 <ReinH> johnw: that isn't exactly simpler
14:04:48 <ReinH> kraljev10: well, in your expression, x is undefined.
14:05:00 <kraljev10> oh, it comes from outer scope
14:05:01 <johnw> it's inexactly simpler
14:05:08 <ReinH> I think yours is pretty simple.
14:05:20 <ReinH> johnw: heh :)
14:05:35 <Bor0> thanks Sorella! Map approach worked
14:05:35 <ReinH> I think == is a bit easier to digest than mfilter...
14:05:42 <kraljev10> I wish Maybe had a conditional constructor
14:05:59 <Sorella> kraljev10: maybe?
14:06:00 <kraljev10> maybeTrue(x == y, "")
14:06:09 <ReinH> kraljev10: write one then
14:06:18 <kraljev10> maybeTrue (x==y) ""
14:06:44 <exio4> that sounds like guard
14:06:53 <johnw> guard (x == y) >> return "" :: Maybe String
14:07:00 <exio4> :)
14:07:04 <ReinH> not bad
14:07:11 <johnw> "" <$ guard (x == y)
14:07:13 <ReinH> I still prefer if/then/else
14:07:21 <kraljev10> yes, it's shorter, but not simpler :D
14:07:31 <kraljev10> great idea :)
14:08:48 <kraljev10> (\t -> Just [t]) vs. Just . (:[])
14:08:50 <kraljev10> what do you prefer?
14:09:06 <ReinH> kraljev10: I dislike (:[]) generally
14:09:09 <Welkin> the first is more explicit
14:09:10 <johnw> depends on who's looking over my shoulder ;)
14:09:16 <kraljev10> :)
14:09:23 <ReinH> Or you could go for the completely inscrutable return . return
14:09:30 <johnw> ooh, nice!
14:09:31 <johnw> pure . pure
14:09:35 <Welkin> don't try to be clever with your programs
14:09:35 <kraljev10> :D
14:09:39 <exio4> or why not, return . pure!
14:09:45 <Welkin> make sure it is readable
14:09:56 <ReinH> nah clever is more fun
14:09:59 * HeladoDeBrownie gags a bit at (return . pure)
14:10:05 <ReinH> I just make sure only *other* people will be reading it
14:10:06 <Rembane> Write-only is only fun once.
14:10:13 <ReinH> Rembane: exactly my point
14:10:20 <kraljev10> naah, its more fun when you read it
14:10:32 <monochrom> I would toss two coins to choose between { pure.pure, pure.return, return.pure, return.return }
14:10:40 <ReinH> hahaha
14:10:47 <Rembane> "This is my pure return generator..."
14:10:49 <kraljev10> or better, when you are forced to read it
14:10:56 <HeladoDeBrownie> don't forget to liberally mix fmap with liftA and liftM
14:10:57 <ReinH> Rembane: there are many like it, but this one is mine
14:11:18 <HeladoDeBrownie> @type fmap . liftM . liftA
14:11:19 <lambdabot> (Applicative f1, Functor f, Monad m) => (a -> b) -> f (m (f1 a)) -> f (m (f1 b))
14:11:20 <johnw> :t liftA
14:11:21 <lambdabot> Applicative f => (a -> b) -> f a -> f b
14:11:25 <monochrom> I would need a die for {fmap, liftA, liftM}.
14:11:28 <johnw> i didn't even know there was a liftA, since Functor is a superclass
14:11:43 <ReinH> monochrom: nah, flip three coins
14:11:56 <HeladoDeBrownie> three coins gives you 2^3, not 2*3
14:12:02 <quchen> johnw: fmap = liftA is probably the main reason
14:12:04 <johnw> flip three coins and discard the one that is the most random
14:12:16 <ReinH> HeladoDeBrownie: I didn't specify how to flip the three coins :p
14:12:27 <Enzoray> Could anyone help me out with a excersice i have regarding finding a cetain elem√´nt?
14:12:46 <monochrom> liftA is there because they want to extrapolate from liftA2, liftA3, and liftA4.
14:12:56 <Welkin> does the round edge of the coin count as an infinite number of states?
14:13:01 <quchen> ReinH: Related and interesting: You can bend a coin pretty hard before it's super biased. https://izbicki.me/blog/how-to-create-an-unfair-coin-and-prove-it-with-math.html
14:13:03 <johnw> soon I will never type liftM again, yay
14:13:09 <ReinH> quchen: huh
14:13:09 <Welkin> for a sufficienty think coin...
14:13:13 <Welkin> thick*
14:13:19 <exio4> or implementing fmap with applicative?
14:13:34 <HeladoDeBrownie> Enzoray, post the question / relevant code and someone who can and is disposed to help may
14:13:38 <monochrom> yes Welkin, but in practice pretty hard to make use of.
14:13:49 * HeladoDeBrownie pronounces "elem√´nt" aloud a few times and giggles
14:13:52 <ReinH> HeladoDeBrownie: for example, for rolling a random number 1..11, you can roll a 12-sided die and reroll until you don't get a 12. Presumably something similar works here.
14:14:11 <HeladoDeBrownie> ReinH, fair enough.
14:14:25 <monochrom> quchen: I am the one fond of decision by coins
14:14:31 <ReinH> HeladoDeBrownie: so in fact you could flip 2 coins with results enumerated 1..4 and do the same thing
14:14:42 <Welkin> why use coins when you can use a d20?
14:14:51 <HeladoDeBrownie> Welkin, not all of us have our dice bags handy
14:14:52 <monochrom> I don't have a d20
14:15:10 <Enzoray> hasSeven :: [Integer] -> [Integer]
14:15:10 <Enzoray> It's supposed to return all the elements which includes the integer '7'.
14:15:19 <ReinH> HeladoDeBrownie: (but you are of course correct)
14:15:20 <monochrom> but I sometimes have a d60. it is a clock. I look at "which second is now".
14:15:31 <HeladoDeBrownie> Enzoray, what do you mean by "include"?
14:15:44 <ReinH> monochrom: by that token, I also have a d12... but I can't use it very often...
14:15:58 <Welkin> > show 7
14:15:59 <lambdabot>  "7"
14:16:11 <Enzoray> HasSeven [1,2,7,72,77] > returns [7,72,77]
14:16:19 <Welkin> it needs to be a Char though
14:16:20 <ReinH> Enzoray: ah
14:16:31 <ReinH> Enzoray: what have you tried so far?
14:16:33 <HeladoDeBrownie> Enzoray, so, you mean you want to filter for all the integers whose base 10 representation includes a 7 digit?
14:17:04 <Enzoray> I want to return every element that has the digit 7 included.
14:17:07 <HeladoDeBrownie> yeah the next question i was going to ask is what ReinH just did
14:17:16 <Enzoray> hasSeven :: [Integer] -> [Integer]
14:17:16 <Enzoray> hasSeven (x:xs)
14:17:16 <Enzoray> 		| any (== 7) = hasSeven xs + x
14:17:16 <Enzoray> 		| otherwise = hasSeven xs
14:17:43 <ReinH> Enzoray: Well, you can't add to a list with +
14:18:06 <ReinH> and any takes a list, not an Integer
14:18:24 <ReinH> but you are heading in the right direction
14:18:33 <monochrom> let us make it more interesting. find those numbers that satisfy: decimal notation contains '7', or a multiple of 7, or both.
14:19:07 <ReinH> Enzoray: can you break this problem down into two smaller problems?
14:19:37 <ReinH> Or, for that matter, n smaller problems where n > 1?
14:19:41 <shachaf> I think #haskell-overflow may be a good place to move this discussion to.
14:19:48 <Enzoray> ReinH, I was thinking something like. elem 7 list, if true return element, else check the next elemetn
14:19:49 <ReinH> shachaf: seems good
14:19:59 <ReinH> Enzoray: join us in #haskell-overflow
14:20:16 <Enzoray> I didn't know such chanell existed.
14:20:34 <johnw> there are several #haskell-* channels, actually
14:20:41 <monochrom> this is inspired by a group game. a group of people sit around a circle. they take turn to enumerate the natural numbers. when it's your turn to announce a number: if it satisfies that condition, stay silent, else speak aloud that number.
14:20:56 <monochrom> disaster is expected to happen when the group hits 70 :)
14:21:36 <HeladoDeBrownie> monochrom, how about base-10 contains 7 digit XOR multiple of 7? i'd expect more people to slip up :P
14:22:14 <monochrom> well, I think the goal is hilarity.
14:22:46 <monochrom> it is more hilarious to have silent for many consecutive persons and people become out of sync
14:22:58 <HeladoDeBrownie> ah, i see
14:36:27 <quchen> johnw: I saw you're the maintainer of bindings-dsl. I've got a question about unions: as far as I understand, a union is treated like an enum by the library. How do I create a proper C'tagged_t in this small example? I should only have to specify either the "str" or the "d", no? http://lpaste.net/117652
14:40:09 <iElectric> if I have a return type of IO (IO [Event])
14:40:21 <iElectric> how do I Show the event?
14:40:43 <monochrom> join your_stuff >>= print
14:40:46 <HeladoDeBrownie> iElectric, join x >>= print
14:40:49 <HeladoDeBrownie> where x is‚Ä¶ yeah
14:41:41 <iElectric> thanks
14:41:45 <monochrom> in do-notation, you have two choices. one choice is { tmp <- your_stuff; tmp2 <- tmp; print tmp2 }
14:43:14 <iElectric> monochrom: second option?
14:43:22 <iElectric> is the join?
14:43:35 <monochrom> { tmp2 <- join your_stuff; print tmp2 }
15:03:40 <pcjtv> anderson: I like cheese as well =)
15:06:31 <johnw> quchen: i
15:06:32 <johnw> hi
15:06:39 <quchen> Ah hello
15:07:08 <johnw> quchen: I'd do this: put your C code into a .h file, and then run c2hsc on it
15:07:17 <johnw> it should generate just what you need
15:07:44 <quchen> johnw: That sounds like a workaround ..?
15:07:55 <johnw> think of it as a way of seeing what you'd normally have to write
15:08:11 <johnw> since the behavior of bindings-dsl is pretty much encoded in that utility
15:08:25 <ReinH> quchen: I
15:08:57 <RedNifre> How "cross platform" are statically linked haskell binaries? Will a binary compiled on linux work on every linux? Will one compiled on PCBSD work on OpenBSD? Where's the barrier exactly?
15:09:01 <quchen> Hmm I wonder what c2hsc would do to my header file. (It's quite long.)
15:09:34 <johnw> try it!
15:09:43 <seanparsons> RedNifre: They're not cross platform at all.
15:10:26 <quchen> johnw: So what would your current approach to writing bindings for a C lib be? c2hsc and that's it?
15:10:44 <johnw> c2hsc, and then manual fixups of what it generates
15:11:31 <quchen> Hmm okay. I'd be really surprised if that worked to be honest, but you've got a lot more experience in that are.
15:11:50 <johnw> it works better than you might expect; macros are its real weak spot
15:11:54 <quchen> My experience with the FFI was a tangled mess of marshalling and hacking ;-)
15:12:06 <johnw> this only seeks to bootstrap your hacking
15:12:11 <johnw> it's not a "point and click" solution
15:12:15 <johnw> nor do I think it ever can be
15:12:15 <koala_man> RedNifre: a statically linked linux binary will run on every linux of the same arch (but maybe not on kernels that are way older than the one it was compiled for)
15:13:05 <quchen> johnw: On the other hand, when I use bindings-dsl, I get a somewhat nicely written source file (full of macros) that I feel is easier to maintain (and adapt to newer versions of the .h)
15:13:32 <quchen> With c2hs and manual hacking I would probably have to redo the entire thing for each new version?
15:14:03 <johnw> c2hsc, not c2hs
15:14:05 <RedNifre> koala_man what does "same arch" mean?
15:14:12 <johnw> so, what I do is this
15:14:17 <johnw> let c2hsc create the first version of the .hcs file
15:14:19 <johnw> .hsc file
15:14:22 <johnw> keep that under version control
15:14:26 <koala_man> RedNifre: i386 vs x86_64 vs sparc64 vs arm
15:14:38 <johnw> when a new version of your library is released, regenerate the .hsc files and examine the diff
15:14:48 <johnw> only carry over the changes you want, fixing them to your standards
15:15:04 <johnw> it's far less work than manually maintaining a huge number of .hsc files
15:15:09 <johnw> especially if the library changes a lot
15:15:10 <iElectric> monochrom: still around?
15:15:22 <iElectric> I'm actually running a map on a function with IO (IO [Event]) signature
15:15:26 <iElectric> well, mapM
15:15:41 <quchen> johnw: That's really valuable advice. It also means I spent a lot of time on something I'll most likely have to discard ;-(
15:16:34 <johnw> my experience maintaining hlibgit2 is that it takes about a day of work for me to upgrade to a new version, since they like to make lots of changes.  But it's just that one day.
15:16:50 <johnw> without hlibgit2, it may have been too daunting to carry on
15:16:54 <johnw> I mean, without c2hsc
15:17:40 <monochrom> @type mapM
15:17:41 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:17:45 <iElectric> monochrom: yay got it
15:18:17 <iElectric> binding another time inside the function resolved the double IO
15:19:53 <quchen> johnw: I guess adapting existing bindings to c2hsc-generated Haskell is a little tedious but not really hard then
15:20:19 <johnw> shouldn't be so bad, no
15:20:39 <quchen> I'll report back when I tried c2hsc. Thanks again! Gotta go to sleep now :-)
15:20:47 <johnw> thanks, sleep well!
15:24:47 <Enzoray> @ipaste
15:24:47 <lambdabot> Haskell pastebin: http://lpaste.net/
15:25:14 <Enzoray> http://lpaste.net/117656
15:25:29 <Enzoray> How do I think creating this function? :S
15:27:32 <monochrom> 0. do you know how to complete this? "showExpr (Num x) = ..."
15:27:33 <sedcf> can you figure out how to show a num
15:27:35 <Welkin> Enzoray: use pattern matching
15:27:48 <sedcf> ?
15:28:06 <monochrom> 1. do you know how to complete this? "showExpr (Add d e) = ...". here you may use recursion
15:28:07 <Enzoray> sedcf; showExpr (Num x) = x
15:28:14 <Welkin> showExpr (Num n) = show n
15:28:19 <monochrom> 2. similarly "showExpr (Mul d e) = ..."
15:28:30 <Enzoray> Let me give it a shotl
15:28:42 <Welkin> n is an Int, so you must call `show` to get a String
15:30:00 <Enzoray> data Expr
15:30:01 <Enzoray> = Num Int
15:30:02 <Enzoray> | Add Expr Expr
15:30:03 <Enzoray> | Mul Expr Expr
15:30:05 <Enzoray> showExpr :: Expr -> String
15:30:06 <Enzoray> showExpr (Add a b) = showExpr a (+) showExpr b
15:30:07 <Enzoray> showExpr (Mul a b) = showExpr a (*) showExpr b
15:30:08 <Enzoray> showExpr (Num x) = show x
15:30:19 <Welkin> not quite
15:30:24 <Welkin> (+) is a function
15:30:31 <Welkin> you want a String representation of +
15:30:38 <Welkin> meaning "+"
15:30:44 <Enzoray> ++ "+"
15:30:46 <Welkin> remember, the result must be a String
15:30:49 <Enzoray> or something.
15:31:00 <monochrom> do you know how to concatenate two strings?
15:31:18 <Enzoray> Like... "lol" ++ "wow" = "lolwow"?
15:31:22 <monochrom> yes
15:31:48 <monochrom> "3" ++ "*" ++ "4" = ?
15:31:50 <Welkin> you also forgot the parens
15:32:04 <Welkin> (4+(3+7))
15:32:27 <monochrom> I forgot the parens, too. but it's easy to fix.
15:38:50 <Enzoray> showExpr :: Expr -> String
15:38:50 <Enzoray> showExpr (Add a b) = (showExpr a ++ "+" ++ showExpr b)
15:38:50 <Enzoray> showExpr (Mul a b) = (showExpr a ++ "*" ++ showExpr b)
15:38:50 <Enzoray> showExpr (Num x) = show x
15:39:17 <Enzoray> Would you consider that right?
15:39:37 <monochrom> yes. except for parentheses.
15:39:51 <monochrom> but why don't you test it? you'll immediate see what's right and what's still missing.
15:40:23 <Welkin> Enzoray: ghc guides you along
15:40:32 <Welkin> all you need to do is read the error messages and warnings
15:40:41 <Enzoray> I hate the ghc. :S
15:40:41 <Welkin> otherwise, you can loo at your output to see what is wrong
15:40:53 <Welkin> there is nothing to hate
15:40:56 <Welkin> it helps you
15:41:06 <Welkin> without it you have to guess and hope it is correct
15:41:07 <monochrom> you can use hugs.
15:41:12 <Enzoray> ghc only tells me if it's right or wrong in my eyes. :D
15:41:24 <Welkin> Enzoray: it tells you exactly why it is wrong
15:41:56 <Welkin> Enzoray: like I said earlier, to write haskell, you need to understand the Types
15:42:09 <Welkin> when writing any function, you must know what the types are
15:42:15 <Welkin> so you write the type declaration first
15:42:45 <Welkin> then construct a pipeline of types that fits the description given in the declaration
15:43:38 <Enzoray> It's compiling.
15:44:02 <Welkin> yes, but it still has a problem
15:44:10 <Welkin> the output will not be entirely correct
15:44:26 <Enzoray> Why can't you use "copy" in ghc?
15:44:34 <Welkin> what is copy?
15:44:37 <sedcf> i like that, 'the ghc', from now on that's how I'm going to refer to my compiler
15:44:48 <monochrom> ghc is a compiler. what is "copy" for a compiler?
15:45:23 <Enzoray> Well, it's running in Windows (shots fired).. so it should obey Windows rules.
15:45:52 <monochrom> ok, this is clearly a monologue.
15:46:07 <Enzoray> Welkin, CTRL + C/CTRL + V
15:46:19 <Welkin> that has nothing to do with ghc
15:46:23 <Welkin> that hasto do with your shell
15:46:45 <dmj`> use a posix compliant shell
15:46:50 <dmj`> mingw or cygwin
15:47:17 <Enzoray> mingw sounds like some nice chinese takeout.. great now I'm hungry.
15:47:25 <Enzoray> I'll google that.
15:48:16 <monochrom> and cygwin sounds like a Tchaikovsky ballet, sure.
15:49:56 <Enzoray> Okay, back to the issue.
15:50:07 <Enzoray> It gave me no parentese.
15:50:16 <Welkin> look at your source
15:50:31 <Welkin> you never added them
15:50:43 <Enzoray> What is it to add? :S
15:50:46 <Welkin> ( is not the same as "("
15:51:26 <monochrom> do you know the difference between "("++"3"++"*"++"4"++")" and ("3"++"*"++"4")?
15:51:31 <Enzoray> showExpr (Add a b) = "(" ++ (showExpr a ++ "+" ++ showExpr b) ++ ")"
15:51:31 <Enzoray> showExpr (Mul a b) = "(" ++ (showExpr a ++ "*" ++ showExpr b) ++ ")"
15:51:39 <Enzoray> Yes, I do.
15:51:52 <monochrom> then you're done.
15:52:32 <Enzoray> Hmm thanks m8.
15:53:48 <Welkin> you don't need those extra parens
15:54:05 <Welkin> around the showExpr a ++ ...
15:54:08 <RedNifre> I lost track, what is the problem again?
15:54:21 <monochrom> it was http://lpaste.net/117656
15:55:11 <Welkin> Enzoray: even better, you can use concat instead of littering your code with ++
15:55:32 <Enzoray> Welkin, it's not about the looks, it's all about "it's wurking"
15:55:43 <Enzoray> Welkin, atleast atm. :P
15:55:47 <Welkin> concat ["(", showExpr a, "+", showExpr b, ")"]
15:56:49 <Welkin> Enzoray: do you understand *why* is works though?
15:56:57 <RedNifre> I think the ++ version looks better than the concat version, but that might be personal taste... why concat?
15:57:05 <Welkin> you seem to be looking for a solution without attempting to understand
15:57:31 <Enzoray> Welkin, I know what ++ solution does, not how the concat works.
15:57:42 <Welkin> Enzoray: I meant for the code you wrote
15:58:15 <Enzoray> What are you saying..? :S
15:58:18 <RedNifre> I don't understand the placement of the brackets next to showExpr a and showExpr b. Why are they placed like this?
15:58:40 <monochrom> historical reasons
15:58:47 <RedNifre> :)
15:58:51 <Enzoray> monochrom gets it. :D
15:59:08 <Enzoray> Don't get me started on the $...
16:00:15 <Welkin> $ is just function application
16:00:49 <Enzoray> length $ reverse x == length (reverse x)
16:00:51 <Enzoray> I know.
16:01:00 <Enzoray> I just hate the $, it's fake. :P
16:01:13 <Welkin> zipWith ($) [(+1), (*3), negate] [1..3]
16:01:15 <Welkin> > zipWith ($) [(+1), (*3), negate] [1..3]
16:01:17 <lambdabot>  [2,6,-3]
16:01:36 <iElectric> is there a function that executes mapM in parallel?
16:02:02 <Welkin> iElectric: look into PArallel and Concurrent Haskell by Simon Marlow
16:02:11 <Yawar> hi all
16:02:17 <Feuerbach> iElectric: for arbitrary monad? no.
16:02:34 <Yawar> can anyone advise me on my in-place quicksort, http://codereview.stackexchange.com/questions/75530/haskell-in-place-quicksort-ord-a-a-io-a
16:02:55 <Yawar> want to know if any way to improve readability/idiom/succinctness/etc.
16:03:27 <Welkin> mergesort is the most idiomatic (and best) sorting method in haskell
16:03:52 <Feuerbach> Yawar: use mutable vectors/arrays instead of iorefs
16:03:56 <Welkin> I don't know why you would want to use an in-place quicksort
16:04:11 <Yawar> Welkin: learning exercise
16:04:25 <Yawar> trying to translate arbitrary C code into haskell
16:04:49 <Feuerbach> Yawar: also, use ST instead of IO
16:05:00 <Welkin> those often do not have a one to one correspondence
16:05:27 <Yawar> Feuerbach: i wanted to have type [a] -> m [a]
16:05:33 <Yawar> to make it as simple as possible to use
16:05:48 <Yawar> and decided on IO for the moment
16:06:03 <Feuerbach> Yawar: you can convert to/from lists in the beginning and in the end
16:06:03 <Yawar> will also try ST
16:06:15 <Feuerbach> so there's no contradiction
16:06:35 <Yawar> i know; wanted to abstract all that away from the user so there's no mental overhead using it
16:07:20 <Feuerbach> well, you failed to hide IO :) ST would've helped you
16:07:21 <Yawar> wait, are you saying _internally_ convert list to mutable vector/array?
16:07:26 <Feuerbach> yes
16:09:10 <Yawar> hmm ... what is the benefit ... performance?
16:09:12 <exio4> you could then use runST, and have a function with the type [a] -> [a]
16:09:40 <Yawar> exio4: ah! ok. that's much better
16:09:42 <exio4> ST is contained "mutable data", IO is a lot of stuff plus mutable data
16:09:49 <exio4> you can "escape" ST
16:10:01 <Yawar> ok i will go over it again
16:10:13 <Feuerbach> Yawar: performance, memory usage. all those things that make you want do in-place sorting in the first place
16:10:36 <Feuerbach> every IORef is a heap object (memory) and an indirection (performance)
16:11:55 <daishi> is there a strict scanl1'?
16:12:17 <daishi> i see forum discussions from about 2 years ago but no strict scanl1
16:12:26 <Yawar> Feuerbach: so e.g. Data.Vector.Mutable, MVector?
16:12:43 <Feuerbach> Yawar: yeah, something along those lines
16:13:20 <daishi> @hackage data-stream-infinite
16:13:20 <lambdabot> http://hackage.haskell.org/package/data-stream-infinite
16:14:26 <daishi> @hackage wait-does-this-not-actually-search
16:14:26 <lambdabot> http://hackage.haskell.org/package/wait-does-this-not-actually-search
16:15:46 <Yawar> Feuerbach: ah, ok. thanks. i'll take a look at it after dinner.
16:20:01 <zachk> has anyone ever gotten sdl working with mingw?
16:20:51 * hackagebot jwt 0.5.1 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.5.1 (StefanSaasen)
16:21:29 <oconnore> hi, how do I call GHC.Prim operations? The documentation says to use GHC.Exts instead, but that doesn't export any of the functions
16:22:09 <oconnore> and then even when I import GHC.Prim, I get an error calling any of the # operations
16:22:58 <thoughtpolice> GHC.Exts re-exports the GHC.Prim module. you probably want GHC.Exts in almost all cases
16:23:22 <thoughtpolice> you also need the -XMagicHash extension for GHC to recognize identifiers with '#' as part of their name
16:23:49 <oconnore> thoughtpolice: ah
16:23:51 <oconnore> thank you
16:25:52 * hackagebot eventstore 0.3.1.0 - EventStore Haskell TCP Client  http://hackage.haskell.org/package/eventstore-0.3.1.0 (YorickLaupa)
16:25:54 * hackagebot MuCheck 0.2.1.0 - Automated Mutation Testing  http://hackage.haskell.org/package/MuCheck-0.2.1.0 (RahulGopinath)
16:25:56 * hackagebot MuCheck-QuickCheck 0.2.1.0 - Automated Mutation Testing for QuickCheck tests  http://hackage.haskell.org/package/MuCheck-QuickCheck-0.2.1.0 (RahulGopinath)
16:25:58 * hackagebot MuCheck-SmallCheck 0.2.1.0 - Automated Mutation Testing for SmallCheck tests  http://hackage.haskell.org/package/MuCheck-SmallCheck-0.2.1.0 (RahulGopinath)
16:26:00 * hackagebot MuCheck-HUnit 0.2.1.0 - Automated Mutation Testing for HUnit tests  http://hackage.haskell.org/package/MuCheck-HUnit-0.2.1.0 (RahulGopinath)
16:26:03 <oconnore> thoughtpolice: hmm, not# doesn't work on the re-exported "Word", and I can't define a Word# due to a kind incompatibility between # and *
16:27:35 <luite> oconnore: you have to get the primitive Word# value out of the W# constructor
16:28:46 <luite> oconnore: myNot :: Word -> Word, myNot (W# w) = W# (not# w)
16:29:01 <thoughtpolice> oconnore: you can't use not# on a Word, you have to deconstruct it in a pattern match, e.g. 'let !(W# w) = 1234 :: Word in not# w'
16:29:41 <thoughtpolice> note that example won't work in GHCi, because GHCi does not support binding variables of an unlifted type. but you can get around that by defining 'myNot' like luite did
16:31:02 * hackagebot MuCheck-Hspec 0.2.1.0 - Automated Mutation Testing for Hspec tests  http://hackage.haskell.org/package/MuCheck-Hspec-0.2.1.0 (RahulGopinath)
16:31:54 <thoughtpolice> oh, well, actually that example will fail in GHCi, but for an unrelated reason to variable binding restrictions. the restriction on unlifted variable bindings in GHCi is actually just if you define it of the form 'let (W# w) = ...', not if you use 'let (W# = w) in ...' (because the former binds it to a top-level name, while the latter simply binds the term for the scope of the 'in' block)
16:37:06 <oconnore> thoughtpolice luite - I got it working. Thank you.
17:02:38 <yac> anyone familiar with Shelly? It appears that find can fail on Permission Error, I'd like to skip the dirs with permission errors and continue with next ones as /usr/bin/find does
17:06:38 <_1_kemrak> hi
17:13:43 <Enzoray> Could anyone help me how to use standard high-order function and writing simple IO functions?
17:15:52 <HeladoDeBrownie> Enzoray, what are you stuck on specifically?
17:16:21 <Enzoray> Trying to "read" definitions of standard functions and writing IO in general
17:16:33 <HeladoDeBrownie> Enzoray, okay, what's an example you don't understand?
17:17:54 <Enzoray> unixHead :: FilePath -> IO ()
17:17:54 <Enzoray> that given a file name, prints out the first 10 lines in that file.
17:18:43 <HeladoDeBrownie> so that line there is just declaring the type of the unixHead binding. its definition presumably comes later in the same file
17:19:13 <HeladoDeBrownie> with infix type constructors, like (->), you can write them prefix as well as infix, and prefix it'd look like: (->) FilePath (IO ())
17:19:23 <HeladoDeBrownie> so basically that is the application of (->) to FilePath and then to IO ()
17:19:36 <HeladoDeBrownie> er, or did i misunderstand what's confusing you?
17:19:51 <HeladoDeBrownie> well anyway so the thing on the left, FilePath in this case, is the input, it's what you apply the function to.
17:20:14 <HeladoDeBrownie> so you need a vale of type FilePath to apply unixHead to. unixHead (x :: FilePath) results in a value of type IO ()
17:21:23 <HeladoDeBrownie> (they asked me to wait a moment in a PM, may resume after)
17:33:11 <Enzoray> duplicateFile :: FilePath -> IO ()
17:33:11 <Enzoray> duplicateFile file =
17:33:11 <Enzoray> do s <- readFile file
17:33:11 <Enzoray> writeFile (file ++ "(copy)") s
17:33:28 <Enzoray> What does the 's' contribute to the code?
17:33:32 <Enzoray> What is it? :S
17:33:38 <HeladoDeBrownie> that looks improperly indented, i'll assume the original was properly indented
17:33:43 <HeladoDeBrownie> the s is part of some syntactic sugar
17:33:50 <HeladoDeBrownie> but essentially
17:34:04 <shachaf> The proper indentation for IRC is the whole thing on one line, separated by semicolons, or an hpaste.org link.
17:34:05 <HeladoDeBrownie> one sec, can you tell me what the type of readFile is?
17:34:18 <c_wraith> Enzoray: in general, please use lpaste.net
17:34:33 <c_wraith> shachaf: lpaste.net now.  hpaste is dead. :)
17:34:37 <HeladoDeBrownie> we'll use readFile :: FilePath -> IO String
17:34:44 <Enzoray> Filepath -> io stirng
17:35:02 <shachaf> c_wraith: http://hpaste.org/ works fine and is the official #haskell place to paste code.
17:35:14 <HeladoDeBrownie> so, "s <- readFile file" creates an s that is available within the remainder of the do block and whose type is String. it is the result, if there was one, of the IO String produced using readFile.
17:35:21 <shachaf> Well, I suppose someone's changed the topic.
17:35:24 <HeladoDeBrownie> (if there wasn't one, we don't proceed)
17:35:49 <HeladoDeBrownie> in the particular case of readFile, s will be the contents of the file read.
17:35:55 <HeladoDeBrownie> Enzoray, make sense?
17:35:59 <c_wraith> shachaf: it's a bit shady to direct people to a url that immediately redirects them to a new domain.  Pretty sure that's why.
17:36:17 <Enzoray> Yes.
17:36:22 <HeladoDeBrownie> Enzoray, are you interested in the desugaring?
17:36:34 <shachaf> It's a bit shady to rename hpaste.org to lpaste.net, too. But only a bit, in both cases.
17:36:51 <Enzoray> I prefer keeping my coding sugarcoated as sht. :P
17:37:11 <HeladoDeBrownie> Enzoray, i'll take that as a no then. did i completely answer your question, or was there more to it?
17:38:08 <Enzoray> I don't understand how s == String
17:38:16 <HeladoDeBrownie> s does not equal String. its type is String.
17:38:38 <HeladoDeBrownie> and that's because readFile file :: IO String, and you used the <- syntax with it.
17:39:16 <Enzoray> oh, i'm a fkn retard atm. :P
17:39:24 <HeladoDeBrownie> so, in general, when you have x :: IO a, for any a, then "x' <- x" creates an x' whose type is that a.
17:39:30 <HeladoDeBrownie> Enzoray, please avoid using that sort of language here.
17:39:39 <Enzoray> sorry. :(
17:40:32 <Enzoray> I see now. I just- couldn't see what I've written apparently.
17:40:48 <HeladoDeBrownie> are you running into errors with something you wrote?
17:41:00 <Enzoray> Not really, except for that one part.
17:41:02 <HeladoDeBrownie> or did you just have trouble understanding something that works properly?
17:41:07 <Enzoray> What about if I said do
17:41:08 <Enzoray> and
17:41:20 <Enzoray> s <- readFile file
17:41:25 <Enzoray> below, would it matter?
17:41:33 <Enzoray> That is my main concern I guess.
17:41:38 <HeladoDeBrownie> i'm not sure what you mean.
17:42:12 <HeladoDeBrownie> maybe you can write something out in a paste?
17:42:15 <Enzoray> yeah
17:42:18 <Enzoray> i call upon!
17:42:21 <Enzoray> @ipaste
17:42:21 <lambdabot> Haskell pastebin: http://lpaste.net/
17:42:23 <HeladoDeBrownie> from my guess as to what your question is about, that will help
17:43:14 <Enzoray> http://lpaste.net/117659
17:43:31 <HeladoDeBrownie> both of those look fine to me at a glance
17:43:39 <HeladoDeBrownie> and equivalent
17:43:41 <Enzoray> Do you see what I changed?
17:43:47 <Enzoray> That is my concern.
17:44:00 <Enzoray> Basically, what I want to learn is.. the simple commands regarding IO
17:44:04 <Enzoray> How they are used, and when.
17:44:13 <HeladoDeBrownie> there are a lot of them
17:44:13 <Enzoray> And some high order Standard-haskell function
17:44:16 <HeladoDeBrownie> it depends on what you want to do
17:44:19 <Enzoray> Because I can't seem to read them on my own.
17:44:46 <Welkin> "commands"?
17:44:52 <HeladoDeBrownie> IO is basically an open world of actions that can be performed on the computer the program runs on
17:44:52 <Enzoray> Sorry, functions
17:45:00 <Welkin> they are just functions that work in an IO context
17:45:05 <HeladoDeBrownie> "procedures" might be a better word than "functions"
17:45:12 <HeladoDeBrownie> or you can say "IO values"
17:45:20 <Iceland_jack> "actions"
17:45:24 <Welkin> there is nothing special about them
17:45:27 <HeladoDeBrownie> or‚Ä¶ hrm. i guess you want to include functions producing IO values
17:45:41 <Welkin> lik I said before, learn the type system
17:45:45 <HeladoDeBrownie> well, either way, don't say "functions", because that means something different
17:45:47 <Welkin> do you know what a Functor is?
17:45:58 <Enzoray> Welkin, I might know the "Type" system, even if I don't know the word for it.
17:46:11 <Enzoray> The correct term.
17:47:08 <Enzoray> Anyway, care to demonstrate for me Brownie?
17:47:15 <HeladoDeBrownie> demonstrate what?
17:47:19 <Enzoray> brownie = my little pony?
17:47:39 <HeladoDeBrownie> "brownie" as in "brownie", things you eat. the full nick means "brownie ice cream".
17:48:05 <Enzoray> Spanish.
17:48:07 <HeladoDeBrownie> yep
17:48:13 <HeladoDeBrownie> what was it you wanted me to demonstrate?
17:48:23 <Enzoray> Basically, what I want to learn is.. the simple commands regarding IO
17:48:27 <Enzoray> And some high order Standard-haskell function
17:48:38 <HeladoDeBrownie> what do you want to know how to do with IO?
17:48:48 <Enzoray> putStr :: String -> IO ()
17:48:48 <Enzoray> getLine :: IO String
17:48:48 <Enzoray> readFile :: FilePath -> IO String
17:48:48 <Enzoray> writeFile :: FilePath -> String -> IO ()
17:48:53 <Enzoray> What do they do?
17:48:53 <HeladoDeBrownie> read/write sockets? read/write files? spawn threads?
17:49:03 <Enzoray> And some classics like filter, map etc.
17:49:06 <Enzoray> For the lists.
17:49:40 <HeladoDeBrownie> readFile and writeFile seem self-explanatory to me, maybe you can be more specific. putStr writes the given String to stdio, while getLine reads a String that was terminated with a new line from stdin
17:50:02 <HeladoDeBrownie> i think your questioning might be a bit broad. if you could zoom in on specific examples that would help me figure out how to help you better
17:50:24 <HeladoDeBrownie> e.g., tell me what you want to do with something, and i might be able to tell you about that.
17:51:32 <Enzoray> I don't want to do anything with.. anything I guess.
17:51:41 <Enzoray> I just want to have a glance of what they are good fore.
17:51:54 <Enzoray> Like, ex. when to use filter
17:52:19 <Enzoray> Okay, I'll set you up with an exercise of mine.
17:52:27 <HeladoDeBrownie> you use filter when you have a simple rule for whether to keep or throw out a given value, and want to keep or throw out the appropriate values from a whole list.
17:52:35 <HeladoDeBrownie> s/simple //
17:52:43 <HeladoDeBrownie> (it can be quite complex, but it can only look at one element at a time)
17:52:45 <Enzoray> Yeah, you're right. That didn't help. :P
17:52:55 <HeladoDeBrownie> that's because filter has quite general applications :)
17:53:16 <solatis> > filter (== 2) [1,2,3,4]
17:53:18 <lambdabot>  [2]
17:53:27 <solatis> > filter (/= 2) [1,2,3,4]
17:53:28 <lambdabot>  [1,3,4]
17:53:29 <Enzoray> So, filter f xs
17:53:31 <Enzoray> right?
17:53:50 <HeladoDeBrownie> well, i don't know whether that's right or wrong if i don't know the types involved, but writing that *can* be correct
17:54:59 <solatis> generally it's a good idea to re-use existing algorithms
17:55:18 <solatis> or at least, i try to formulate my code in such a way that i can re-use existing algorithms
17:55:19 <Enzoray> Integer or stringl
17:55:54 <HeladoDeBrownie> Enzoray, as long as the types can unify with the type of filter, you're good to go.
17:55:57 <HeladoDeBrownie> @type filter
17:55:58 <lambdabot> (a -> Bool) -> [a] -> [a]
17:56:08 <Enzoray> I see.
17:56:15 <HeladoDeBrownie> so, for example, pick a ~ Integer. then filter :: (Integer -> Bool) -> [Integer] -> [Integer]
17:56:25 <Bor0> Enigmagic, grab a book, preferably LYAH. try to re-implement most of the basic functions. also play around with lamda calculus. that helped me at least.
17:56:47 <Bor0> er, Enzoray even
17:56:58 <benzrf> Bor0: lyah is pedagogically unsound :(
17:57:03 <Enzoray> Bor0, what?
17:57:05 <Iceland_jack> benzrf: Cut that out
17:57:10 <benzrf> Iceland_jack: pfft
17:57:14 <shachaf> This might again be more appropriate for #haskell-overflow.
17:57:15 <benzrf> if i say it enough times it will become a meme
17:57:42 <Enzoray> tbh, I've learned more by actually attempting to do this by my own.
17:57:48 <HeladoDeBrownie> Enzoray, okay, at shachaf's suggestion let's go over to #haskell-overflow to continue.
17:57:54 <HeladoDeBrownie> Enzoray, yes, that is a very good idea.
17:58:03 <solatis> Enzoray: i am also a person who "learns by example" and just likes to dive into the deep
17:58:07 <Enzoray> With looooaaaaads of help from you, lol :D
17:58:32 <solatis> i cannot learn from something abstract, i need to solve a problem and figure out the best solution how to do so along the way
17:58:53 <Enzoray> solatis, sounds like me aswell. :P
17:58:54 <shachaf> I think you'll continue to learn more by attempting to do it on your own rather than asking #haskell about every small detail.
17:59:10 <HeladoDeBrownie> i'm not sure i know of anyone who isn't like that, but it could just be me assuming people are more like me than they really are
17:59:24 <Enzoray> shacraf, I see. But I've actually recieved loads of help from here which has lead to that I can quite understand haskell now.
17:59:45 <Enzoray> Even though, the help should have emerged from #haskell-overflow ;)
17:59:59 <solatis> Enzoray: or #haskell-beginners is more appropriate perhaps
18:00:22 <shachaf> Help from here certainly isn't bad. It's part of the reason the channel exists.
18:00:39 <solatis> Enzoray: and i can recommend to just search github
18:00:48 <HeladoDeBrownie> we usually only know partway through when a discussion  have been more appropriate to take up in another channel
18:00:51 <HeladoDeBrownie> +might
18:00:53 <solatis> if you're stuck with "how the hell does this library work?", just search github
18:01:07 <Enzoray> solatis, yeah perhaps. But.. haskell-beginners is so dead.. :S
18:01:22 <solatis> Enzoray: there are quite a lot of people there
18:01:30 <HeladoDeBrownie> i'm in -overflow and -beginners now, feel free to hit me in either one to resume
18:40:54 <Yawar> Enzoray: i'm looking at your paste (http://lpaste.net/117659). just wanted to let you know that there's _no meaningful difference_ at all between the two definitions of duplicateFile that you have in there. there's only a _cosmetic_ difference: they're indented slightly differently
18:41:19 <Enzoray> Yawar, didn't I post that thing hours ago? :D
18:41:41 <Yawar> because of haskell's indentation (or 'layout') rules, you can indent the same code in different ways
18:42:12 <Yawar> yeah, but i have to have my dinner before i answer your questions :-)
19:14:18 <d34df00d> Hi!
19:14:58 <d34df00d> I'm getting a somewhat confusing error `Error in array index` when trying to run my program.
19:15:10 <d34df00d> It works fine on small test input data, but fails with this error on large inputs.
19:15:25 <d34df00d> I've found something relevant like https://www.haskell.org/pipermail/haskell-cafe/2009-June/063456.html, but still not sure what to do and how to debug the error.
19:15:57 <d34df00d> Things are more complicated by the fact that I cannot run my program under ghci and do usual stuff like :trace and so on, because it eats too much memory on those datasets under ghci.
19:16:00 <d34df00d> So, what should I do?
19:16:04 <solatis> i would suggest compiling your program with profiling support, and run +RTS -xc
19:16:28 <d34df00d> solarus: cool, thanks, let me try‚Ä¶
19:16:44 <solatis> cabal configure --enable-library-profiling --enable-executable-profiling
19:16:46 <solatis> fwiw :)
19:17:02 <solatis> +RTS -xc prints a stack trace for every exception that occurs
19:17:12 <solatis> which seems like what you want
19:18:51 <d34df00d> solatis: hm, I managed to get a stacktrace with usual ghci on a spare machine with 32 GiB of RAM, but it's not very clear to me.
19:19:07 <d34df00d> That's the ghci output:
19:19:11 <d34df00d> https://bpaste.net/show/26b1c8955674
19:19:20 <d34df00d> Here's process:
19:19:23 <d34df00d> https://bpaste.net/show/a35cbb833e6c
19:22:35 <d34df00d> Hm, using +RTS -xc is also not really telling me anything:
19:22:46 <d34df00d> https://bpaste.net/show/3e19c69af714
19:23:09 <solatis> ah wait
19:23:24 <solatis>  -auto-all -caf-all
19:23:28 <solatis> pass that to your ghc flags
19:24:11 <solatis> and well, looks like you need to show us some source code to figure out the problem
19:24:39 <d34df00d> Oh, ok, that's way better, but I still don't get the real source of the problem:
19:24:43 <d34df00d> https://bpaste.net/show/5dc844578a48
19:24:54 <drdo> Is an author of Hsmtlib here by any chance?
19:25:11 <drdo> (or a successful user)
19:25:16 <d34df00d> solarus: sure! This is `process` function:
19:25:19 <d34df00d> https://bpaste.net/show/e7b210d53e62
19:25:35 <d34df00d> Here is the DivideConquer module:
19:25:37 <d34df00d> https://bpaste.net/show/999610ada3d1
19:26:08 <d34df00d> And ParseScoringMatrix (also mentioned in the stacktrack):
19:26:10 <d34df00d> https://bpaste.net/show/37dadbc2921c
19:31:16 <matematikaadit> > maxBound :: Int
19:31:17 <lambdabot>  9223372036854775807
19:31:31 <matematikaadit> > (maxBound :: Int) + 1
19:31:32 <lambdabot>  -9223372036854775808
19:35:00 <carter> thats a fun one
19:36:25 <johnw> what, that maxBound + 1 == minBound?
19:36:42 <benzrf> > maxBound + 1 == minBound?
19:36:44 <lambdabot>  <hint>:1:26:
19:36:44 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:36:45 <benzrf> > maxBound + 1 == minBound
19:36:46 <lambdabot>  No instance for (GHC.Enum.Bounded a0)
19:36:46 <lambdabot>    arising from a use of ‚ÄòGHC.Enum.maxBound‚Äô
19:36:46 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
19:36:50 <benzrf> > maxBound + 1 == (minBound :: Int)
19:36:51 <lambdabot>  True
19:37:05 <johnw> essentially 0x7ffff + 1 = 0x8000
19:37:16 <johnw> (of course, add more fs and 0s)
19:37:33 <johnw> by adding one, you add the bit that indicates negativity
19:38:00 <shachaf> johnw is describing how two's complement works
19:38:16 <shachaf> The Haskell Report doesn't specify that Int works that way, but that's how GHC (and probably most everything else) implements it.
19:41:29 <liyang> > succ maxBound :: Int
19:41:30 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
19:41:52 <liyang> (FYI, difference between (+) 1 and succ.)
19:42:26 <Welkin> > 1 + maxBound :: Int
19:42:28 <lambdabot>  -9223372036854775808
19:42:53 <Welkin> > (1 + maxBound :: Int) == (minBound :: Int)
19:42:54 <lambdabot>  True
19:44:03 <matematikaadit> d34df00d: maybe there are formatting error in the parseMatrix input
19:50:56 <d34df00d> matematikaadit: yeah, you were right.
19:51:03 <d34df00d> Input had \r on its end.
19:51:23 <solatis> d34df00d: sorry i was afk
19:51:27 <solatis> you solved your problem ?
19:51:40 <d34df00d> solatis: yes. Thanks btw, now I know about that marvellous -xc!
19:51:48 <solatis> yw
19:51:57 <solatis> +RTS has lots of goodies
19:54:35 <benzrf> :t succ
19:54:36 <lambdabot> Enum a => a -> a
19:54:53 <benzrf> > succ (succ (maxBound - 1))
19:54:54 <lambdabot>  No instance for (GHC.Show.Show a0)
19:54:54 <lambdabot>    arising from a use of ‚ÄòM51755248177097094895917.show_M51755248177097094895...
19:54:54 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
19:55:01 <benzrf> > succ (succ ((maxBound :: Int) - 1))
19:55:02 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
19:55:06 <benzrf> pff
20:00:27 <Welkin> > succ "benzrf"
20:00:28 <lambdabot>  No instance for (GHC.Enum.Enum [GHC.Types.Char])
20:00:28 <lambdabot>    arising from a use of ‚ÄòGHC.Enum.succ‚Äô
20:00:44 <Welkin> > succ Infinity
20:00:46 <lambdabot>  Not in scope: data constructor ‚ÄòInfinity‚Äô
20:00:54 <Welkin> > succ (1/0)
20:00:55 <lambdabot>  Infinity
20:01:38 <Welkin> > pred (1/0)
20:01:39 <lambdabot>  Infinity
20:01:43 <Welkin> lies!
20:01:58 <Welkin> > succ (-1/0)
20:01:59 <lambdabot>  -Infinity
20:08:03 <dfeuer> Welkin, floating point isn't numbers.
20:08:19 <dfeuer> carter may claim otherwise, but he's a known dissembler.
20:08:32 <carter> haha
20:08:50 <johnw> also known to be a disassembler at times
20:09:13 <carter> ootool -vt all the things
20:09:21 <dfeuer> ootool?
20:09:29 <dfeuer> @google ootool
20:09:31 <lambdabot> http://oo.en.alibaba.com/
20:09:31 <lambdabot> Title: Wuyi O O Tool Co., Ltd. - Garden Tools (Chain Saw,Brush Cutter
20:09:37 <dfeuer> o.O
20:09:53 <Welkin> dissenter?
20:10:08 <dfeuer> ?
20:10:17 <Welkin> alibaba, haha
20:10:29 <Welkin> @google functool
20:10:30 <lambdabot> https://docs.python.org/2/library/functools.html
20:10:36 <Welkin> @google funtool
20:10:36 <lambdabot> https://www.cfa.harvard.edu/~john/funtools/
20:10:41 <Welkin> @google futool
20:10:42 <lambdabot> http://www.freefutool.it/
20:10:42 <lambdabot> Title: Free FuTool
20:11:20 <dfeuer> ???
20:11:40 <dfeuer> carter, what is an ootool?
20:11:52 <carter> otool -vt
20:11:53 <carter> typo
20:12:06 <dfeuer> @google otool
20:12:07 <lambdabot> http://www.manpagez.com/man/1/otool/
20:12:07 <lambdabot> Title: man page otool section 1
20:12:18 <carter> its a disassmbler
20:12:21 <dfeuer> Ahhhh.
20:12:37 <dfeuer> What do you call the Haskell decompiler?
20:12:54 <Welkin> ghd?
20:13:02 <dfeuer> Welkin++
20:13:03 <agibiansky> carter?
20:13:07 <dfeuer> That would be a good name for it.
20:13:08 <carter> agibiansky: sup
20:13:18 <dfeuer> I'm sure carter has one on GitHub somewhere.
20:13:20 <agibiansky> carter: I was accusing you of being a Haskell decompiler.
20:13:49 <carter> agibiansky: you're giving me more credit or insight that i possibly could have
20:13:57 <agibiansky> shhh
20:13:59 <carter> ok
20:14:05 <agibiansky> :D
20:14:07 <carter> agibiansky: have you ever used the Hopper app?
20:14:19 <carter> it does an ok job a doing dissably of large binaries on mac
20:14:35 <agibiansky> Huh, cool
20:14:39 <carter> @google hopper app
20:14:40 <lambdabot> http://www.hopperapp.com/
20:14:40 <lambdabot> Title: Hopper
20:14:40 <agibiansky> I've never done anything with disassembly
20:14:45 <carter> agibiansky: its easy
20:14:47 <agibiansky> Features look cool though
20:14:48 <carter> you just look it up
20:14:56 <carter> *llook stuff up
20:14:56 <agibiansky> I've never really needed to (I think)
20:16:00 <carter> agibiansky: says the person who spent the past week dealing with linkers
20:17:01 <agibiansky> carter: Fair enough. I think more like I've never used one so don't reach for one when it might be useful; so probably I should play around with one so that next time I need it I know I need it...
20:17:42 <Welkin> disassembly is great for reverse engineering or cracking software
20:17:54 <Welkin> there are lots of cool tricks you can use
20:17:56 <agibiansky> Hmm, makes sense
20:18:01 <Welkin> simple things like looking for a comparision to zero
20:18:15 <Welkin> then you can jump over that code block
20:18:32 <agibiansky> I've had to do reverse engineering, but it was protocols and file formats where I didn't have access to the original binaries, so never used it there either. That makes sense why it'd be useful though :)
20:20:36 <carter> agibiansky: its also good for checking inner loops in haskell
20:20:57 <carter> anything that takes < 1¬µs according to criterion is worth eyeballing the assembly
20:21:01 <carter> to audit
20:21:13 <agibiansky> carter: Is there no -S flag to GHC?
20:21:18 <agibiansky> Or something equivalent
20:21:21 <carter> there is an -S flag
20:21:24 <carter> so that works too
20:21:26 <carter> but sometimes you forget
20:21:34 <agibiansky> ah, ok
20:21:34 <carter> or whaever
20:21:34 <johnw> carter: do you use Hopper with Haskell executables?
20:21:38 <carter> johnw: yes
20:21:51 <carter> i think it works better with final executables, and not .o / .dyns
20:22:10 <johnw> cool, thanks for pointing it out
20:22:12 <agibiansky> What are .hi and .dyn_hi files, anyway?
20:22:19 <carter> its the interface file
20:22:27 <carter> it has the types and the inlinings and stuff
20:22:47 <agibiansky> How does it store inlinings? Does it have "inlineable" code blocks or something?
20:23:10 <zq> i have a haskell enhancement idea
20:23:17 <carter> agibiansky: as core
20:23:26 <carter> agibiansky: you can actually open a .hi with a text editor
20:23:38 <agibiansky> carter: Oh, makes sense, so then other optimizations can happen later
20:23:39 <johnw> carter: I bet it would go nicely with http://www.sweetscape.com/010editor/mac_osx.html
20:23:39 <zq> c `f a b` d being syntax for f a b c d
20:24:03 <vanila> zq, why not use <| and |> or something
20:24:03 <carter> agibiansky: woops, .hi files are binary format
20:24:07 <vanila> so that it can be nested
20:24:10 <carter> theres some ghc flag to dumb readable stuff
20:24:21 <Welkin> zq: f a b $ c d
20:24:27 <carter> johnw: maybe, errr
20:24:31 <Welkin> er
20:24:36 <Welkin> zq: (f a b) c d
20:24:40 <carter> johnw: but only for PIE code that still has symbols right?
20:24:49 <johnw> dunno, haven't tried it yet
20:24:53 <vanila> middle c (f a b) d
20:24:56 <carter> johnw: i'm saying, editing the binary
20:24:58 <benzrf> middle c
20:24:59 <johnw> but they are both very cool looking low level editors
20:25:01 <vanila> with middle x f y = x `f` y
20:25:07 <geekosaur> --show-iface
20:25:18 <carter> geekosaur: thanks
20:25:22 <carter> you are an asset!
20:25:25 <zq> Welkin: i don't get your point
20:25:33 <geekosaur> need it just enough to vaguely recall it
20:25:40 <Welkin> carter: is that really a complement? Telling someone they are a resource?
20:25:45 <Welkin> is carter not a human being?
20:25:49 <Welkin> er
20:25:50 <Welkin> geekosaur:
20:25:50 <carter> :P
20:25:59 <carter> Welkin: :P
20:26:08 <Welkin> compliment*
20:26:09 <zq> benzrf, vanila: sure you can do c `middle` d where middle = f a b but holy crap keystrokes
20:26:15 <carter> why can't i thank someone for being a font of usefulness
20:26:56 <zq> remember guys, you heard it from me first
20:27:49 <carter> >  (+) `  id . map ` [1,2]
20:27:51 <lambdabot>  <hint>:1:11: parse error on input ‚Äò.‚Äô
20:27:58 <carter> >  (+) ` id . map` [1,2]
20:28:00 <lambdabot>  <hint>:1:10: parse error on input ‚Äò.‚Äô
20:28:09 <benzrf> what's the gramarm
20:28:12 <vanila> zq, this idea has been said many times in the past
20:28:44 <Welkin> let f = id . map in (+) `f` [1,2]
20:28:49 <Welkin> > let f = id . map in (+) `f` [1,2]
20:28:50 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>]
20:29:25 <Welkin> since when can lambdabot print functions?
20:29:38 <Welkin> > foldr (+)
20:29:39 <lambdabot>  <Integer -> [Integer] -> Integer>
20:29:42 <Welkin> wow
20:29:56 <Welkin> ghc cannot do this
20:30:11 <Yawar> > foldr
20:30:13 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
20:30:13 <lambdabot>    arising from a use of ‚ÄòM34718069261900257386691.show_M34718069261900257386...
20:30:13 <lambdabot>  The type variable ‚Äòb0‚Äô is ambiguous
20:30:22 <Yawar> > :t foldr
20:30:24 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
20:30:32 <Yawar> @type foldr
20:30:33 <lambdabot> (a -> b -> b) -> b -> [a] -> b
20:31:04 <Welkin> Yawar: by using (+) I defined a and b
20:31:14 <dfeuer> carter, why are you wanting to inspect anything taking less than a microsecond?
20:31:33 <carter> dfeuer: because those are easier to microoptiize
20:31:40 <carter> a LOT of code can happen in a micro second
20:32:00 <dfeuer> A lot of *bad* code can happen in more than that.
20:32:07 <carter> a modern cpu can (with optimal code) handle like 5-12 instructions per cycle
20:32:25 <carter> and like 3 thousand cycles in a micro second
20:32:32 <dfeuer> Which is why you're adding inline asm to Haskull.
20:32:40 <carter> possibly
20:32:44 <dfeuer> Actually, you should call it "Haskull".
20:32:45 <carter> i at least worked out a candidate design
20:32:47 <Welkin> Grace Hopper used a thick piece of trans-atlantic cable to demonstrate her point that a nanosecond is worth saving when building systems
20:33:10 <Yawar> Welkin: hmm, lambdabot seems to be a bit wrong here. foldr (+) :: Num b => b -> [b] -> b
20:33:15 <Welkin> she used the length of the wire to illustrate how far an electron travels in a nanosecond
20:33:17 <dfeuer> Welkin, how did he use that to demonstrate that?
20:33:29 <Welkin> dfeuer: she
20:33:34 <dfeuer> That's what I meant.
20:33:38 <carter> light travels like 3 inches in a nano second
20:33:39 <dfeuer> Mistyped.
20:33:42 <zq> uh what
20:33:48 <zq> you know
20:33:53 <zq> electrons don't travel
20:33:58 <dfeuer> Welkin, I am aware that Admiral Hopper was a woman.
20:34:03 <zq> er, it's the electron potential that travels at c
20:34:05 <Welkin> zq: don't be pedantic
20:34:09 <zq> e-s are p slow
20:34:21 <dfeuer> Electrons *do* travel. But in wires they do it slowly.
20:34:42 <zq> in everywhere they do it slowly
20:34:42 <vanila> how does the potential move faster than the electrons themselves?
20:34:49 <zq> hopping atoms is no easy feat
20:35:00 <Welkin> vanila: transfe of energy
20:35:01 <johnw> this really isn't about Haskell anymore
20:35:02 <dfeuer> zq, slower than light, yes, but in a vacuum they can be accelerated quite quick.
20:35:09 <kadoban> Light actually travels just about a foot in a nanosecond. Sometimes it's jokingly referred to as a light-foot.
20:35:12 <Yawar> folks, we are going off topic here
20:35:20 <carter> tothe #haskell-blah
20:36:25 <zq> dfeuer: in that process of acceleration, they're no longer hopping attoms
20:36:43 <negatratoron> the potential just tell you the volume where the electrons are moving
20:36:53 <Enzoray> carter, that's shachaf's job. He's been telling me that everytime I get off-topic.. hehe. :D
20:37:10 <negatratoron> ##physics is rolling in their graves
20:37:22 <matematikaadit> Yawar: what's wrong with lamdabot?
20:37:28 <shachaf> #haskell-overflow isn't for off-topic, it's for long conversations
20:37:41 <Yawar> @type foldr (+)
20:37:42 <lambdabot> Num b => b -> [b] -> b
20:37:48 <Enzoray> shachaf, it's a joke. xD
20:37:58 <Yawar> > foldr (+)
20:37:59 <lambdabot>  <Integer -> [Integer] -> Integer>
20:38:17 <Yawar> matematikaadit: conflicting answers as to the type of foldr (+)
20:38:18 <matematikaadit> Yawar: I didn't see anything wrong
20:38:24 <Hermit> > id
20:38:26 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
20:38:26 <lambdabot>    arising from a use of ‚ÄòM16815914518676790986849.show_M16815914518676790986...
20:38:26 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
20:38:34 <Hermit> holly...
20:38:50 <Hermit> since when...
20:39:05 <Hermit> > foldl1 (+)
20:39:06 <lambdabot>  <[Integer] -> Integer>
20:39:10 <Hermit> hmm
20:39:10 <matematikaadit> :t (+)
20:39:11 <lambdabot> Num a => a -> a -> a
20:39:16 <matematikaadit> :t foldr
20:39:17 <lambdabot> (a -> b -> b) -> b -> [a] -> b
20:39:27 <Hermit> since when lambdabot has that notation for function types?
20:39:35 <Welkin> > foldr (+) :: Double
20:39:36 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Double‚Äô
20:39:37 <lambdabot>              with actual type ‚Äòb0 -> [b0] -> b0‚Äô
20:39:40 <Welkin> > foldr (+) :: Int
20:39:41 <Hermit> or did I miss it the entire time?
20:39:42 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Int‚Äô
20:39:42 <lambdabot>              with actual type ‚Äòb0 -> [b0] -> b0‚Äô
20:39:44 <Welkin> er
20:39:48 <matematikaadit> Yawar: now, put the type of (+) as the first argument of foldr, and you get that result
20:39:49 <dfeuer> Hermit, what notation?
20:39:52 <Welkin> :t (+) :: Int
20:39:53 <lambdabot>     Couldn't match expected type ‚ÄòInt‚Äô
20:39:53 <lambdabot>                 with actual type ‚Äòa0 -> a0 -> a0‚Äô
20:39:53 <lambdabot>     Probable cause: ‚Äò(+)‚Äô is applied to too few arguments
20:40:03 <Welkin> :t (+) :: Int -> Int -> Int
20:40:04 <lambdabot> Int -> Int -> Int
20:40:10 <Hermit> dfeuer: <[Integer] -> Integer>   <-- that format for functions
20:40:15 <Welkin> > foldr ((+) :: Int -> Int -> Int)
20:40:16 <lambdabot>  <Int -> [Int] -> Int>
20:40:39 <Yawar> :t foldr ((+) :: Int -> Int -> Int)
20:40:40 <lambdabot> Int -> [Int] -> Int
20:40:53 <Yawar> :t foldr ((+) :: Integer -> Integer -> Integer)
20:40:54 <lambdabot> Integer -> [Integer] -> Integer
20:41:10 <Yawar> :t foldr ((+) :: Integral a => a -> a -> a)
20:41:11 <lambdabot> Integral b => b -> [b] -> b
20:41:16 <Hermit> > (+) :: Int -> Int -> Int
20:41:18 <lambdabot>  <Int -> Int -> Int>
20:42:02 <Yawar> it seems like lambdabot automatically restricts to Integer when printing out a function 'object'
20:42:17 <Yawar> (in the angle brackets)
20:42:31 <dfeuer> > "ketones" <> ((,)<$>"potatoes"<*>"huh")
20:42:33 <lambdabot>  Couldn't match type ‚Äò(GHC.Types.Char, GHC.Types.Char)‚Äô
20:42:33 <lambdabot>                with ‚ÄòGHC.Types.Char‚Äô
20:42:33 <lambdabot>  Expected type: GHC.Types.Char -> GHC.Types.Char -> GHC.Types.Char
20:42:45 <kadoban> It probably has to do with defaulting
20:42:46 <Yawar> but doesn't when printing out the type of the function from the :t pragma
20:42:57 <dfeuer> > \ ((,)<$>"potatoes"<*>"huh")
20:42:58 <lambdabot>  <hint>:1:4: Parse error in pattern: (,) <$> "potatoes"
20:43:02 <dfeuer> > ((,)<$>"potatoes"<*>"huh")
20:43:04 <lambdabot>  [('p','h'),('p','u'),('p','h'),('o','h'),('o','u'),('o','h'),('t','h'),('t',...
20:43:35 <dfeuer> > (zipWith "ketones" "black") <> ((,)<$>"potatoes"<*>"huh")
20:43:36 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Char -> b -> c‚Äô
20:43:36 <lambdabot>              with actual type ‚Äò[GHC.Types.Char]‚ÄôCouldn't match expected type ...
20:43:36 <lambdabot>              with actual type ‚Äò[(GHC.Types.Char, GHC.Types.Char)]‚Äô
20:43:37 <matematikaadit> > ( show . typeOf ) (+)
20:43:39 <lambdabot>  "Integer -> Integer -> Integer"
20:44:02 <matematikaadit> > typeOf (+)
20:44:03 <lambdabot>  Integer -> Integer -> Integer
20:44:34 <dfeuer> :t ((,)<$>"potatoes"<*>"huh")
20:44:35 <lambdabot> [(Char, Char)]
20:44:47 <dfeuer> :t (zipWith "ketones" black")
20:44:48 <lambdabot>     lexical error in string/character literal at end of input
20:44:52 <dfeuer> :t (zipWith "ketones" "black")
20:44:53 <lambdabot>     Couldn't match expected type ‚ÄòChar -> b -> c‚Äô
20:44:53 <lambdabot>                 with actual type ‚Äò[Char]‚Äô
20:44:53 <lambdabot>     In the first argument of ‚ÄòzipWith‚Äô, namely ‚Äò"ketones"‚Äô
20:44:59 <dfeuer> :t (zip "ketones" "black")
20:45:00 <lambdabot> [(Char, Char)]
20:45:08 <dfeuer> > (zip "ketones" "black") <> ((,)<$>"potatoes"<*>"huh")
20:45:09 <lambdabot>  [('k','b'),('e','l'),('t','a'),('o','c'),('n','k'),('p','h'),('p','u'),('p',...
20:45:13 <dfeuer> THERE we go.
20:45:24 <matematikaadit> Yawar: it's related to the Show instance of (a -> b).
20:45:34 <Welkin> what doe ketones have to do with anything?
20:45:37 <matematikaadit> in lambdabot
20:46:23 <Yawar> ah, i see. that makes sense
20:46:55 <Yawar> so that implementation doesn't follow ':t'
20:49:08 <matematikaadit> :t typeOf
20:49:09 <lambdabot> Typeable a => a -> TypeRep
20:51:36 <matematikaadit> @let instance Show (Int -> Int -> Int) where show _ = "<Integer Operator>"
20:51:38 <lambdabot>  Defined.
20:52:24 <matematikaadit> > (+) :: Int -> Int -> Int
20:52:25 <lambdabot>  Overlapping instances for GHC.Show.Show
20:52:25 <lambdabot>                              (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int)
20:52:25 <lambdabot>    arising from a use of ‚ÄòM40915403842745277577274.show_M40915403842745277577...
21:05:06 <eyebloom> is it possible to put a typeclass constraint on a type family within a typeclass?
21:06:06 <shachaf> As in class K (F a) => Foo a where type F a?
21:06:37 <eyebloom> Yes I think so.
21:06:44 <shachaf> Yes, GHC can do that.
21:08:09 <eyebloom> Fantastic
21:08:59 <eyebloom> I feel I am finally getting the hang of type families.
21:19:09 <Enzoray> How you you indent IO property?
21:19:20 <Enzoray> properly
21:19:58 <pavonio> Indent IO?
21:20:14 <pavonio> Do you mean do-blocks?
21:20:28 <Enzoray> yeah, nvm. I figured it out
21:20:31 <Enzoray> tab, right?
21:20:37 <Enzoray> after do, ofc.
21:20:46 <Enzoray> function = do
21:20:49 <Enzoray> this
21:21:05 <Enzoray> tab being, this.
21:21:10 <pavonio> You indent the lines following the do with spaces
21:21:23 <Enzoray> I did it with tab, it worked.
21:21:26 <Enzoray> Does it matter?
21:21:39 <pavonio> It's recommended to use spaces instead of tabs because tab size is fixed to 8 spaces in GHC, IIRC
21:22:05 <ReinH> @google haskell indentation
21:22:06 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Indentation
21:22:06 <lambdabot> Title: Haskell/Indentation - Wikibooks, open books for an open world
21:22:16 <Enzoray> Any tips for.. being less sleepy? :P
21:24:43 <spearman> has anyone ever had the problem with Haskell mode in emacs where save-buffer saves the file twice? it always reports (No changes need to be saved)
21:26:00 <ReinH> spearman: Nope, but #haskell-emacs exists fwiw
21:26:25 <spearman> ReinH: ah, thanks
21:29:12 <Myrl> No haskell-vim? :<
21:29:18 <Myrl> #haskell-vim*
21:29:53 <eyebloom> Hmmm‚Ä¶ I‚Äôm defining an instance of a typeclass that includes associated type families. If I define this instance in the module where the typeclass is defined it compiles. If I move it to another module (literally copy and pasted) I get a type error where it doesn‚Äôt seem to recognize the type families‚Ä¶
21:37:07 <eyebloom> Ah, putting it in a sandbox file, and it compiles.
21:54:24 <chrisnc> does anyone know why 'fromInteger' is part of 'Num', rather than part of 'Integral'?
21:56:18 <vanila> :t fromInteger
21:56:19 <lambdabot> Num a => Integer -> a
21:56:25 <vanila> see how the a changes, but Integer doesn't
21:56:32 <vanila> it means you can do it for any num type
21:56:40 <vanila> so Double itself would have to implement it
21:56:46 <vanila> and Float, and Rational etc.
21:57:26 <ReinH> > fromInteger 2 :: Double
21:57:28 <lambdabot>  2.0
21:57:56 <chrisnc> I think Haskell could have just as easily made it so literals like '2' can't be converted to Double like that
21:58:17 <ReinH> Could have, but didn't.
21:58:22 <chrisnc> hence my question
21:58:23 <chrisnc> why?
21:58:41 <Myrl> > fromInteger 2 :: Integer
21:58:42 <lambdabot>  2
21:58:44 <Myrl> Lol.
21:59:13 <ReinH> chrisnc: I guess you'd have to ask the haskell committee
21:59:29 <chrisnc> right. but didn't they write reports and commentary and stuff?
21:59:31 <vanila> chrisnc, sometimes we want to be able to turn integers into doubles
21:59:38 <vanila> and the name for the thing to do that is fromIntegral
21:59:47 <chrisnc> I know about fromIntegral
21:59:50 <Myrl> vanila: I'm new to Haskell, what would have been a better way to do it?
21:59:52 <chrisnc> I'm asking about fromInteger
21:59:58 <vanila> Myrl, This way is fine
22:00:01 <chrisnc> specifically the thing that turns integer literals into actual types
22:00:43 <chrisnc> the reason I'm asking is because people new to haskell tend to get tripped up when the go to ghci and type something like:
22:00:46 <chrisnc> 1 + 1.0
22:00:49 <vanila> chrisnc, Oh I guess I misinterpreted your question. Do you mean you'd rather haskell went with ocaml convention were 3,4,5, are integers andyou have to write 3.0 etc to get floats/doubles?
22:00:49 <chrisnc> and get 2.0
22:00:58 <chrisnc> I suppose so, yeah
22:01:04 <vanila> oh right
22:01:33 <vanila> I think thats just a language design choice, it could go either way
22:01:48 <Myrl> chrisnc: Are you saying that the better way would have been to error?
22:01:59 <Myrl> Because of type failure?
22:02:00 <vanila> I think that making literals more polymorphic is not likely to cause errors though
22:02:10 <chrisnc> sure, but it causes confusion
22:02:13 <vanila> it just saves typing .0 sometimes
22:02:36 <chrisnc> if ':t 1' gave 'Integral a => a'
22:02:44 <chrisnc> then 1 + 1.0 would be an error, yes
22:02:48 <Myrl> True.
22:03:06 <chrisnc> so I was wondering if there were resources documenting this decision
22:03:37 <chrisnc> because I've seen two experienced people (but not experienced with Haskell) make incorrect statements about it based on this misunderstanding
22:03:57 <chrisnc> which they gained by typing statements like that into GHCi and making assumptions about how numeric literals work
22:04:14 <vanila> what was typed into ghci?
22:04:18 <chrisnc> 1 + 1.0
22:04:21 <vanila> and what wrong assumption was made from it
22:04:29 <chrisnc> that Haskell coerces numeric types
22:04:57 <vanila> well show them x + y with x :: Integer, and y :: Double
22:05:07 <vanila> and then they will learn that its just literals for which this happens
22:05:11 <chrisnc> yes, it's easy to explain to people after
22:05:19 <chrisnc> but that doesn't make it less confusing
22:05:51 <vanila> I think this is just learning, not like some really confusing trouble
22:06:29 <chrisnc> it's often not necessarily Haskell learners making the mistake, but Haskell commentators :)
22:06:54 <vanila> who?
22:06:54 <chrisnc> and even for learners I think the benefit is dubious
22:07:29 <chrisnc> e.g.: https://codewords.hackerschool.com/issues/one/when-is-equality-transitive-and-other-floating-point-curiosities
22:07:37 <Myrl> chrisnc: Hmmm... the only time which I can find that to be a problem is when people think that stuff like this will work: `let (x, y) = (1 :: Integer , 2.0 :: Double) in x + y'
22:08:27 <chrisnc> I think it's weird because it's one very common place where you have to use type annotations in the REPL to get sensible results
22:08:32 <Myrl> Since that won't have the same behavior as simply `1 + 2.0'
22:08:50 <chrisnc> you're telling me things I know. :)
22:09:28 <chrisnc> I'm speaking from the perspective of someone who doesn't know about polymorphic literals (which very few languages have), and once to compare Haskell to $favorite_lang or whatever
22:09:29 <Myrl> chrisnc: I know.
22:09:31 <vanila> is == on float transitive in haskell?
22:09:49 <Myrl> chrisnc: I just have a thing for completely saying my point.
22:11:17 <chrisnc> I'm not 100% sure. but his example does not say anything about that question at all
22:11:22 <chrisnc> because he doesn't understand the types he's using
22:11:31 <chrisnc> he's not even using the same (==) in the three examples
22:11:38 <chrisnc> because the expressions have different types
22:13:45 <carter> chrisnc: are we talking about dan luu's blog post?
22:13:50 <chrisnc> yes
22:13:57 <carter> i asked him to fix it
22:14:00 <chrisnc> heh
22:14:02 <carter> but he doesn't have edit acls
22:14:09 <chrisnc> womp womp...
22:14:10 <carter> on the hacker school blog
22:14:16 <carter> i've a friend starting hacker school monday
22:14:31 <carter> i can ask him to pester folks
22:14:37 <chrisnc> are you cartazio, by chance?
22:14:45 <carter> google seems to think so
22:15:24 <chrisnc> I'm the one who did that convex programming thingy last spring
22:15:40 <chrisnc> in bos's class
22:15:45 <carter> chrisnc: hehe
22:16:05 <carter> chrisnc: is remarks about haskell in his article are ass crackers false
22:16:12 <chrisnc> haven't really touched it since then, but using Haskell for other things now
22:16:21 <carter> and make anyone reading the artcile who knows haskell totally miss whatever point he actually was trying to make
22:16:24 <carter> chrisnc: oh? where at?
22:16:35 <vanila> is (==) :: Float -> Float -> Float transitive?
22:16:40 <carter> yes
22:16:45 <carter> except with Nans
22:16:48 <carter> because Nans aren't numbers
22:16:57 <carter> they're efficient excpetions :)
22:17:00 <carter> for debugging math
22:17:31 <chrisnc> if only they came with backtraces... guess that's why they're efficient
22:17:36 <carter> yup
22:17:45 <carter> because the cpu doesn't have to branch on nan
22:18:09 <carter> talking about == on nan is like talking  about == on (error "you done wrong")
22:19:31 <chrisnc> so is it accurate to say that, excluding NaN, (==) being true on floats is an exact bit-for-bit match?
22:19:41 <carter> yes
22:19:43 <chrisnc> this matches my intuitions, but I haven't dug into the 754 spec
22:19:45 <chrisnc> okay, cool
22:19:50 <carter> except  0 == -0
22:19:54 <carter> which differ by a bit
22:20:12 <carter> and i forget how it works for denormalized floats
22:20:14 <EvanR> except except except
22:20:16 <chrisnc> hehehe
22:20:21 <EvanR> i.e. no
22:20:23 <chrisnc> yeah...
22:20:48 <carter> it IS useful to distinguish ¬±0 though
22:20:50 <carter> 'cause of limits
22:20:59 <carter> and then identify them as being equal otherwise
22:23:32 <chrisnc> the worst part about everything written about floating point is how often the meme "not exact" is repeated
22:23:46 <chrisnc> as though there's no rhyme or reason and you can't really trust it
22:23:54 <chrisnc> there are rules, they're just complicated
22:24:08 <chrisnc> but for the most part, sensible
22:24:22 <EvanR> yes "not exact" is a little weird
22:24:33 <chrisnc> like, it's still running on a computer...
22:24:56 <chrisnc> maybe it's just the best word we have to match our intuitions
22:25:00 <vanila> i think float is too complex to treat in the same way as other number types
22:26:34 <EvanR> already bored with exact reals. waiting for exact surreals
22:26:38 <chrisnc> anyway. if '1' had type Integral a => a then that blog post would have had one less section maybe
22:27:03 <Welkin> :t 1
22:27:04 <lambdabot> Num a => a
22:27:08 <chrisnc> we know...
22:27:33 <Welkin> :t 1.0
22:27:34 <lambdabot> Fractional a => a
22:27:47 <Welkin> :t (1/0)
22:27:48 <lambdabot> Fractional a => a
22:27:50 <EvanR> > 1 :+ 0 `div` 2
22:27:51 <lambdabot>  1 :+ 0
22:28:04 <Welkin> :t (:+)
22:28:05 <lambdabot> a -> a -> Complex a
22:28:19 <EvanR> > 1.3 :+ 0 `div` 2
22:28:20 <lambdabot>  No instance for (GHC.Show.Show a0)
22:28:21 <lambdabot>    arising from a use of ‚ÄòM77626110803431477459014.show_M77626110803431477459...
22:28:21 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
22:28:29 <Welkin> is there anything of type Integral a => a ?
22:28:48 <chrisnc> hoogle says no
22:28:49 <Welkin> well, besides giving a an expicit type
22:29:04 <Welkin> :t (+)
22:29:05 <lambdabot> Num a => a -> a -> a
22:29:06 <vanila> :t \x -> const x (fromIntegral x)
22:29:07 <lambdabot> Integral a => a -> a
22:29:11 <Welkin> :t (/)
22:29:12 <lambdabot> Fractional a => a -> a -> a
22:29:14 <EvanR> :t 2 `div` 1
22:29:15 <lambdabot> Integral a => a
22:29:15 <vanila> :t fix (\x -> const x (fromIntegral x))
22:29:16 <Welkin> :t (div)
22:29:16 <lambdabot> Integral a => a
22:29:17 <lambdabot> Integral a => a -> a -> a
22:29:37 <chrisnc> doing it that way is maybe not the best because Integral is used exclusively for integer division and remainders
22:29:58 <Welkin> :t rem
22:29:59 <lambdabot> Integral a => a -> a -> a
22:30:02 <Welkin> :t mod
22:30:03 <lambdabot> Integral a => a -> a -> a
22:30:06 <chrisnc> :i Integral
22:30:10 <chrisnc> damn...
22:30:14 <joneshf-laptop> i'm trying to understand how to arrive at the number of inhabitants given a type
22:30:22 <Welkin> > rem == mod
22:30:23 <lambdabot>  No instance for (GHC.Real.Integral a0)
22:30:24 <lambdabot>    arising from a use of ‚ÄòGHC.Real.rem‚Äô
22:30:24 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
22:30:32 <Welkin> > rem 4 3
22:30:33 <chrisnc> :info Integral
22:30:34 <lambdabot>  1
22:30:35 <shachaf> joneshf-laptop: The real number or the "no-bottoms" number?
22:30:37 <joneshf-laptop> i get the mapping from sum, product and exponent types to algebraic things
22:30:37 <Welkin> > mod 4 3
22:30:39 <lambdabot>  1
22:30:47 <joneshf-laptop> shachaf, the no-bottoms
22:30:53 <chrisnc> no ":info" for lambdabot? bummer
22:31:10 <joneshf-laptop> my problem comes when the type is polymorphic
22:31:37 <chrisnc> then the set can be extended by anyone else's code, no?
22:31:48 <EvanR> a polymorphic type is a family of types that are parametrized
22:31:49 <joneshf-laptop> it seems you can use the CH iso to state whether the type has 0 inhabitants or at least one
22:32:05 <joneshf-laptop> but what do you assume from there?
22:32:42 <joneshf-laptop> e.g. `a -> a` has only one inhabitant right?
22:32:45 <chrisnc> joneshf: would an instance of your question be "how many inhabitants are there in the type 'Num a => a'?"
22:33:02 <EvanR> id for Int, id for Bool etc
22:33:06 <joneshf-laptop> chrisnc, no, not constrints yet
22:33:41 <joneshf-laptop> EvanR, aren't these all the same function?
22:33:44 <chrisnc> it's the same id though. I think that'd count as just 1
22:33:50 <EvanR> well
22:34:01 <EvanR> > (id :: Int -> Int) True
22:34:02 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Int‚Äô
22:34:03 <lambdabot>              with actual type ‚ÄòGHC.Types.Bool‚Äô
22:34:24 <joneshf-laptop> right, but the type was
22:34:31 <joneshf-laptop> > (id :: a -> a) True
22:34:32 <lambdabot>  True
22:34:44 <EvanR> a = Bool in this case
22:35:00 <chrisnc> that doesn't mean id takes on a different value
22:35:03 <joneshf-laptop> if it's specialized to a type then the number of inhabitants changes
22:35:08 <joneshf-laptop> right?
22:35:11 <EvanR> id must be specialized before you can use it
22:35:30 <joneshf-laptop> but not before i can implement it
22:35:57 <chrisnc> I thought that only applied to functions that rely on a typeclass?
22:36:12 <chrisnc> the implementation of id does not depend at all on the type of the arg, no?
22:36:24 <joneshf-laptop> right
22:36:47 <chrisnc> while a function with a class constraint does need info about the type for the implementation
22:37:04 <joneshf-laptop> but if you have `Int -> Int` then there are (2^32)^(2^32) inhabitants or whatever
22:37:16 <EvanR> right, nevermind
22:37:35 <EvanR> (though only one satisfies id)
22:37:42 <joneshf-laptop> yeah
22:37:48 <gamegoblin> Is there a function like safeSucc that is Succ a => a -> Maybe a
22:37:56 <gamegoblin> that won‚Äôt exception if a == maxbound
22:37:59 <EvanR> interesting to consider that that function "is the same function" as the corresponding one for Bool
22:38:40 <EvanR> like two arrows between two different types are the same arrow
22:39:03 <joneshf-laptop> so, when attempting to count the number of inhabitants, what do you do here? there should be a^a inhabitants, but a^a == 1 only if a = 1
22:39:09 <EvanR> gamegoblin: theres safe-enum package
22:39:41 <joneshf-laptop> so, do you just assume that if a type is inhabited all of the polymorphic variables have exactly 1 inhabitant?
22:39:49 <chrisnc> I think the fact that (a -> a) has only one inhabitant is independent of the a^a rule
22:39:56 <joneshf-laptop> oh?
22:40:28 <chrisnc> when I first learned that fact, the way I justified it to myself is that because it's a pure function (and we assume we want it to be total)
22:40:37 <EvanR> still trying to understand in what sense the infinite instances of a -> a are all the same
22:40:39 <chrisnc> the only way to produce an a to return is to give the one passed to you
22:40:42 <joneshf-laptop> do these rules only work for fully specialized types?
22:41:27 <chrisnc> and because you know knowthing else about the argument 'a', all you can do is name it. you can't apply any other functions to it, because you don't know any other functions that would work
22:41:31 <chrisnc> this is all very informal of course
22:41:38 <joneshf-laptop> right
22:41:41 <matematikaadit> :t id `as
22:41:42 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
22:41:51 <matematikaadit> :t id `asAppliedTo` True
22:41:52 <lambdabot> Bool -> Bool
22:42:34 <EvanR> > let f = id in (f True, f 1)
22:42:36 <lambdabot>  (True,1)
22:42:43 <EvanR> hmm.
22:42:51 <chrisnc> I think there's a different kind of arithmetic you do for function types which are fully parametric
22:43:15 <chrisnc> i.e., how many types are there for 'a -> a -> (a,a)'
22:43:26 <chrisnc> should be e.g.*
22:43:34 <joneshf-laptop> yeah, tht's where this kind of breaks down
22:43:51 <EvanR> its a different notion of identification of inhabitants
22:43:51 <chrisnc> now you've got two a's to work with, and two places to put them, but still no operations on the 'a's
22:43:55 <joneshf-laptop> by the rules presented it'd be 1
22:43:57 <joneshf-laptop> but that's not true
22:44:03 <chrisnc> what rules...?
22:44:09 <chrisnc> it's definitely not 1
22:44:59 <chrisnc> should be... 4... no?
22:45:00 <HeladoDeBrownie> a -> a -> (a,a) = ((a * a) ^ a) ^ a
22:45:11 <HeladoDeBrownie> right?
22:45:16 <joneshf-laptop> chrisnc, |(a, b)| = |a| * |b|, |Either a b| = |a| + |b|, |a -> b| = |b|^|a|
22:45:29 <EvanR> the formula works for any given type
22:45:39 <chrisnc> f x y = (x,x), (x,y), (y,x), (y,y)
22:45:43 <EvanR> but the answer isnt to sum over all infinity of the choices for a
22:45:45 <chrisnc> what other impl's could there be?
22:45:57 <HeladoDeBrownie> oh woops
22:45:59 <shachaf> chrisnc: Those are all (modulo _|_).
22:46:08 <chrisnc> I'm assuming totality, as before
22:46:18 <joneshf-laptop> right, there are no other choices
22:46:32 <shachaf> I mean, those are all there are, yes.
22:46:58 <joneshf-laptop> so there's gotta be some other cardinality rules like you stated chrisnc
22:47:34 <shachaf> It is more complicated with polymorphism. Especially higher-rank.
22:48:01 <joneshf-laptop> part of my problem is i can't figure out what words to use to do research on the ideas
22:48:34 <chrisnc> it's un-googleable :) I seem to have that problem as well when learning FP
22:48:51 <shachaf> http://math.ucr.edu/home/baez/week240.html might be relevant
22:51:23 <chrisnc> interesting
22:52:23 <EvanR> :t const id
22:52:23 <lambdabot> b -> a -> a
22:52:40 <EvanR> so theres no a -> a -> a ?
22:53:00 <chrisnc> :t asTypeOf
22:53:01 <lambdabot> a -> a -> a
22:53:11 <EvanR> @src asTypeOf
22:53:12 <lambdabot> asTypeOf = const
22:53:31 <chrisnc> sneaky, right?
22:53:35 <EvanR> ok
22:58:31 <mikeplus64> hm, why do we need KnownNat/Symbol? there should be an instance KnownNat (n :: Nat) for any n. in fact, if you add your own, without even defining natVal, it works fine, with natVal :: proxy (n :: Nat) -> Integer, no KnownNat required
22:59:22 <mikeplus64> er, without even defining natSing (not that you can without the internals anyway)
23:07:14 <joneshf-laptop> EvanR, there's `a -> a -> a`, but there's no `(a -> a) -> a`
23:08:08 <joneshf-laptop> shachaf, hat was a good read thanks
23:08:15 <joneshf-laptop> i'm still confused though
23:08:59 <tac_> :t fix
23:09:00 <lambdabot> (a -> a) -> a
23:09:05 <tac_> *gasp!*
23:09:23 * joneshf-laptop dies
23:11:08 <joneshf-laptop> but, is that right?
23:11:10 <joneshf-laptop> because
23:11:12 <joneshf-laptop> > fix id
23:11:16 <lambdabot>  mueval-core: Time limit exceeded
23:11:43 <pavonio> > fix (1 :)
23:11:45 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:12:19 <EvanR> id is strict so fix id is bottom
23:12:42 <tac_> You know what they say. It's it has no well-defined fixedpoints, don't fix it.
23:13:07 <joneshf-laptop> well, i know now apparently
23:13:09 <joneshf-laptop> :)
23:17:23 <chrisnc> is id necessarily strict...?
23:17:41 <agibiansky> What does it mean for a function to be strict?
23:18:06 <EvanR> f _|_ = _|_
23:18:26 <agibiansky> Ok, so that's the only criterion
23:18:36 <agibiansky> Then id has to be strict
23:18:55 <EvanR> it could be more complex with multiargument functions
23:18:57 <agibiansky> Which is weird to think because it doesn't _do_ anything with its argument, but it fits the definition of f _|_ is bottom
23:19:16 <EvanR> it also explains why fix id is bottom
23:19:47 <agibiansky> EvanR: Can we say that a function is strict if f _|_ = _|_ or if f _|_ is a strict function?
23:20:20 <EvanR> f isnt strict then right
23:20:30 <EvanR> but if you think of it as a 2 arg function then maybe
23:20:40 <agibiansky> That would be how I would define "a function is strict if feeding _|_ to it as an any argument yields _|_"
23:20:50 <agibiansky> Yeah, then f itself isn't strict
23:21:02 <chrisnc> there's a notion of being strict in a particular argument
23:21:09 * hackagebot copilot-c99 2.1.2 - A compiler for Copilot targeting C99.  http://hackage.haskell.org/package/copilot-c99-2.1.2 (LeePike)
23:21:11 * hackagebot copilot-cbmc 2.1.2 - Copilot interface to a C model-checker.  http://hackage.haskell.org/package/copilot-cbmc-2.1.2 (LeePike)
23:21:13 * hackagebot copilot-core 2.1.2 - An intermediate representation for Copilot.  http://hackage.haskell.org/package/copilot-core-2.1.2 (LeePike)
23:21:29 <agibiansky> Yeah, that makes more sense ‚Äì and a strict function without specifying is just assumed to be strict in first argument
23:22:08 <chrisnc> is that what people assume?
23:22:20 <EvanR> i assume all functions have one argument ;)
23:22:26 <chrisnc> touche
23:22:47 <agibiansky> Fair enough :P
23:23:09 <agibiansky> Though there's definitely the occasional function that is very rarely used partially applied
23:23:31 <EvanR> with two args, you could have a situation where "its strict depending on the first/second arguments value"
23:23:50 <EvanR> which isnt very strong
23:23:50 <agibiansky> EvanR: How?
23:24:14 <EvanR> f x y = if x then id else const
23:24:23 <EvanR> er, ex the y
23:24:28 <EvanR> or apply the y
23:24:32 <agibiansky> I wouldn't say that's strict ‚Äì I would just say that's occasionally bottom for certain combinations of x and y
23:24:38 <EvanR> or fix it because its malformed...
23:24:45 <EvanR> f x y = if x then id else const y
23:24:47 <agibiansky> Meh, but I guess this is all sorta just definitions
23:25:13 <EvanR> hmm thats strict in the second arg no matter what
23:25:21 <EvanR> oh, or not
23:25:35 <EvanR> or yes
23:25:42 <enthropy> class Id a where id :: a -> a; instance Id () where id _ = ()
23:26:09 * hackagebot copilot-language 2.1.2 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-language-2.1.2 (LeePike)
23:26:11 * hackagebot copilot-sbv 2.1.2 - A compiler for CoPilot targeting SBV.  http://hackage.haskell.org/package/copilot-sbv-2.1.2 (LeePike)
23:26:13 * hackagebot copilot 2.1.2 - A stream DSL for writing embedded C programs.  http://hackage.haskell.org/package/copilot-2.1.2 (LeePike)
23:26:35 <RedNifre> I have a syntax question: What is the prettiest way to write fmap (+1) <$> [ Just 4 ] ?
23:26:49 <Welkin> (fmap . fmap)
23:27:17 <RedNifre> > (fmap . fmap) (+1) [ Just 4 ]
23:27:19 <lambdabot>  [Just 5]
23:27:34 <RedNifre> > fmap . fmap (+1) [ Just 4 ]
23:27:36 <lambdabot>  Couldn't match expected type ‚Äòa -> a1 -> b‚Äô
23:27:36 <lambdabot>              with actual type ‚Äò[Data.Maybe.Maybe a0]‚Äô
23:27:57 <Welkin> > fmap . fmap $ (+1) [Just 4]
23:27:59 <lambdabot>  Couldn't match expected type ‚Äòa -> b‚Äô
23:27:59 <lambdabot>              with actual type ‚Äò[Data.Maybe.Maybe a0]‚Äô
23:28:17 <Welkin> yeah, just use parens
23:28:31 <EvanR> > fmap . fmap (+1) $ [Just 4]
23:28:32 <lambdabot>  Couldn't match type ‚Äò[Data.Maybe.Maybe a0]‚Äô with ‚Äòa -> b‚Äô
23:28:32 <lambdabot>  Expected type: [Data.Maybe.Maybe a0] -> a -> b
23:28:32 <lambdabot>    Actual type: [Data.Maybe.Maybe a0] -> [Data.Maybe.Maybe a0]
23:28:33 <HeladoDeBrownie> [Just 4] = return (return 4) -- :o)
23:28:38 <RedNifre> Oh. So the dot has an even lower binding than $ ?
23:28:50 <Welkin> $ is lowest precedence
23:28:51 <chrisnc> . has very high precedence
23:29:03 <chrisnc> 9 in fact
23:29:10 <chrisnc> $ is 0
23:29:15 <Welkin> anyway, $ is right association
23:29:29 <RedNifre> Then how is ( fmap . fmap ) (+1... different from fmap . fmap $ (+1) ...?
23:29:36 <Welkin> fmap . fmap $ (+1) [Just 4] == fmap . fmap ((+1) [Just 4])
23:29:49 <RedNifre> ah
23:29:59 <HeladoDeBrownie> Welkin, not quite, that includes the application of (+1) to [Just 4]
23:30:18 <HeladoDeBrownie> which isn't what was wanted
23:30:23 <chrisnc> you have to remember that bare function application is higher precedence than any operator
23:30:27 <RedNifre> ...and fmap . fmap $ (+1) $ [ Just 4 ] doesn't work because $ is right-to-left...
23:30:29 <Welkin> that is what I am explaining
23:30:39 <RedNifre> For maximum confusion, is there a $ that is left-to-right?
23:30:41 <HeladoDeBrownie> Welkin, my mistake, i misread the right side
23:30:54 <liyang> (And record update is higher than function application. :)
23:31:03 <chrisnc> there's (&) from lens
23:31:07 <chrisnc> which is infixl 1
23:31:15 <HeladoDeBrownie> it's also flip ($)
23:31:16 <chrisnc> and args are flipped
23:31:32 <Welkin> using parens when necessary is fine
23:31:34 <EvanR> parentheses for the win
23:31:37 <RedNifre> @let & = flip ($)
23:31:38 <lambdabot>  Parse failed: Parse error: &
23:31:46 <Welkin> it's better to keep it simple rather than use some obscure notation
23:31:49 <matt80> hello everyone
23:31:52 <RedNifre> How can & be in lense if it's a parser error?
23:31:55 <matt80> I'm brand new here
23:32:02 <chrisnc> ((+ 1) <$>) <$> [Just 1]
23:32:05 <HeladoDeBrownie> RedNifre, it's not a parser error
23:32:05 <matematikaadit> @let (&) = flip ($)
23:32:05 <chrisnc> wee
23:32:07 <lambdabot>  Defined.
23:32:09 <HeladoDeBrownie> RedNifre, what did you try?
23:32:22 <HeladoDeBrownie> matt80, welcome. feel free to ask any questions you may have
23:32:26 <RedNifre> Welkin I agree, I'm just asking because I'm curious.
23:32:39 <EvanR> no end to the blogs describing negatively "haskell programmers penchant for obscure operator notation that looks worse than perl"
23:32:41 <matt80> thank you Helado
23:32:50 <RedNifre> I tried @let & = flip ($) but i guess it needs more brackets
23:32:56 <RedNifre> @let (&) = flip ($)
23:32:57 <lambdabot>  .L.hs:175:1:
23:32:57 <lambdabot>      Multiple declarations of ‚Äò&‚Äô
23:32:57 <lambdabot>      Declared at: .L.hs:174:1
23:33:02 <matt80> I'm also brand new to haskell
23:33:05 <HeladoDeBrownie> RedNifre, yeah, it's the parens
23:33:18 <matematikaadit> @undefine
23:33:18 <lambdabot> Undefined.
23:33:25 <EvanR> > let (&) = flip ($) in 5 & id
23:33:26 <lambdabot>  5
23:33:31 <RedNifre> Huh? Where is .L.hs:174:1? :)
23:33:41 <HeladoDeBrownie> RedNifre, in lambdabot's mind
23:33:50 <matt80> anyway just dropped in to say hi. I'll be back
23:34:01 <matematikaadit> > let x & f = f x in 5 & id
23:34:03 <lambdabot>  5
23:34:03 <RedNifre> Hi and see you later
23:34:41 <EvanR> i need to learn lenses
23:34:43 <RedNifre> > let (&) = flip ($) in fmap & fmap (+1) & [ Just 4 ]
23:34:44 <lambdabot>  Couldn't match expected type ‚Äò((a0 -> b0) -> f0 a0 -> f0 b0) -> c‚Äô
23:34:44 <lambdabot>              with actual type ‚Äò[Data.Maybe.Maybe a1]‚Äô
23:35:10 <RedNifre> ah, it's still right-to-left I guess?
23:35:38 <RedNifre> > let a & b = b  $ a in fmap & fmap (+1) & [ Just 4 ]
23:35:39 <lambdabot>  Couldn't match expected type ‚Äò((a0 -> b0) -> f0 a0 -> f0 b0) -> t‚Äô
23:35:39 <lambdabot>              with actual type ‚Äò[Data.Maybe.Maybe a1]‚Äô
23:36:21 <HeladoDeBrownie> try not to spam the channel with lambdabot experimentation
23:37:13 <RedNifre> I'm not spamming, I'm asking about syntax. In this case, why exactly doesn't it work like that? Is & evaluated right-to-left? Why?
23:37:32 <RedNifre> But I'll  remember to test ghci first next time. Sorry.
23:37:48 <HeladoDeBrownie> lambdabot can be used in pm too
23:37:58 <HeladoDeBrownie> anyway i'm not sure what the default associativity is, i'll try looking it up
23:38:07 <chrisnc> & is infixl 1
23:38:17 <Welkin> > fmap . fmap & (+1) [Just 4]
23:38:18 <lambdabot>  Couldn't match expected type ‚Äò((a0 -> b0)
23:38:19 <lambdabot>                                 -> f0 (f1 a0) -> f0 (f1 b0))
23:38:19 <lambdabot>                                -> b‚Äô
23:38:23 <chrisnc> so left associative
23:38:37 <chrisnc> the thing you're applying it to has to be all the way on the left, basically
23:38:46 <chrisnc> > [Just 4] & fmap (fmap (+ 1))
23:38:47 <lambdabot>  [Just 5]
23:38:50 <chrisnc> bingo
23:39:10 <Welkin> ah yes
23:39:31 <chrisnc> but you should really just stuck with "fmap (fmap (+ 1)) [Just 4]"
23:39:35 <HeladoDeBrownie> chrisnc, yeah but when RedNifre was defining it in a let expression it used the default precedence and associativity
23:39:35 <chrisnc> no need for fancy operators
23:39:45 <HeladoDeBrownie> what would that be?
23:40:07 <chrisnc> good point. not sure
23:40:25 <chrisnc> I think it's lower than (.) by default
23:40:38 <chrisnc> and he was only using one of them, so left vs. right wouldn't have mattered
23:40:47 <chrisnc> he was just putting the args on the wrong side
23:41:14 <HeladoDeBrownie> surely it matters here? fmap & fmap (+1) & [ Just 4 ]
23:41:39 <RedNifre> Right, I didn't mean to flip $, I actually meant to make it evaluate left-to-right
23:41:56 <RedNifre> Does "infixl" mean "beginning left" or "evaluate leftwards"?
23:42:01 <matematikaadit> RedNifre: fmap & fmap (+1) & [ Just 4 ] == [ Just 1 ] $ fmap (+1) $ fmap
23:42:05 <chrisnc> infixl means "left associative"
23:42:22 <matematikaadit> RedNifre: which is invalid
23:42:33 <chrisnc> so x & f & g is the same as (x & f) & g
23:42:55 <chrisnc> :t (&)
23:42:56 <lambdabot> a -> (a -> b) -> b
23:43:04 <chrisnc> but that's the main reason you were having trouble
23:43:09 <chrisnc> function goes on the left for (&)
23:43:13 <chrisnc> er... right
23:43:14 <chrisnc> derp
23:43:28 <RedNifre> > let (&) = ($) in fmap & fmap (+1) & [ Just 4 ]
23:43:29 <lambdabot>  [Just 5]
23:43:40 <RedNifre> Okay, I got it.
23:43:58 <chrisnc> yeah. just use $, or better, just use parens
23:44:37 <chrisnc> imo, $ is overkill for tiny expressions
23:46:20 <RedNifre> I think my missunderstanding was that I understood "$ saves brackets" as " a $ b $ c is equal to (a) (b) (c)" while it is actually equal to (a (b c))...
23:46:31 <matematikaadit> people just like to put more ($) to their code. Probably they think that it made them rich
23:48:18 <matematikaadit> though, I love Elm that use |> and <| operator that mimics unix pipe
23:48:46 <chrisnc> a $ b $ c is equal to a (b (c)), because of the associativity of ($)
23:49:18 <chrisnc> whoops you basically said that
23:49:40 <chrisnc> $ is nice because it lets you forget about closing parens in long expressions
23:50:24 <chrisnc> but if you're only using one of them it typically doesn't save any characters
23:51:12 <chrisnc> > (length "foo $ bar x y", length "foo (bar x y)")
23:51:13 <lambdabot>  (13,13)
23:52:00 <chrisnc> > (length "foo $ bar $ baz x y", length "foo (bar (baz x y))")
23:52:01 <lambdabot>  (19,19)
23:52:39 <chrisnc> if you want to do something like "forever $ do ..." it can make it look a lot cleaner
23:57:31 <lpaste> RedNifre pasted ‚Äúchaining functions‚Äù at http://lpaste.net/117673
23:57:43 <RedNifre> Why does this not work?
23:59:04 <shachaf> Try writing a type signature.
