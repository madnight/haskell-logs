00:03:01 <glguy> You need more type signatures... The data family constructors are specific to an instance
00:04:06 <shachaf> I guess that's true.
00:06:14 <DerisiveLogic> Anyone up for pair-programming?
00:09:33 * hackagebot jwt 0.4.3 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.4.3 (StefanSaasen)
00:09:33 * hackagebot xmonad-entryhelper 0.1.0.0 - XMonad config entry point wrapper  http://hackage.haskell.org/package/xmonad-entryhelper-0.1.0.0 (javran)
00:12:10 <Javran> did I just see hackagebot announcing the same package twice?
00:13:03 <shachaf> I didn't.
00:14:36 <Javran> hmm, you can search "xmonad", it happened about an hour ago.
00:15:18 <shachaf> Ah. Yes.
00:23:04 <HeladoDeBrownie> i saw that only once
00:23:23 <HeladoDeBrownie> perhaps some sort of irc network error?
01:35:33 <jonazzzzzzz> can anyone explain me what: f 'par' (e 'pseq' (e+f)) does where f = fib and e = sumEuler
01:35:50 <jonazzzzzzz> i know it sparks f, but what does that mean?
01:37:23 <vanila> it does them in parallel
01:37:37 <vanila> it should speed up the calculation, hopefully
01:39:35 <jonazzzzzzz> yeah but can you give some more detail whats going on in that expression?
01:41:48 <vanila> its running them parallel
01:44:27 * hackagebot ghc-generic-instances 0.1.0.0 - Derived instances of GHC.Generic of the GHC AST  http://hackage.haskell.org/package/ghc-generic-instances-0.1.0.0 (AlanZimmerman)
02:12:20 <trap_exit> is there something better than pure emacs for haskell dev ?
02:15:27 <augur> trap_exit: i use textmate
02:15:40 <augur> ive heard the haskell mode stuff for aquamacs is good, but ive never installed it
02:17:18 <trap_exit> aquamacs soudns osx-isy
02:17:19 <trap_exit> i'm on windows
02:17:26 <trap_exit> but I failed to mention that I am on windows
02:25:46 <ellipsis_> I'm trying to build something with persistent but I don't think the quasiquoter is working
02:26:12 <ellipsis_> building gives me a 'possibly incorrect indentation' error
02:39:27 * hackagebot quoridor-hs 0.1.1.0 - A Quoridor implementation in Haskell  http://hackage.haskell.org/package/quoridor-hs-0.1.1.0 (talw)
03:01:56 <int-e> > 1
03:02:02 <lambdabot>  1
03:24:28 * hackagebot leveldb-haskell 0.6.1 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.6.1 (KimAltintop)
03:41:16 <Beardful> How can i remame False to F ? Might it be like data F = False ?
03:41:33 <Iceland_jack>     pattern F = False
03:41:56 <Iceland_jack> Add {-# LANGUAGE PatternSynonyms #-} to your file
03:52:05 <Beardful> Iceland_jack: That works, thanks!
03:59:27 * hackagebot cpphs 1.18.7 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.18.7 (MalcolmWallace)
04:19:10 <Total_1mmersion> Is there any reason to use let over case? I think (let foo = bar in baz) be replaced by (case bar of foo -> baz)
04:24:28 * hackagebot hi 1.1.0.3 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-1.1.0.3 (DaisukeFujimura)
04:58:13 <Beardful> Are all haskell libraries cross-platform ? i.e. will System.Random work in Windows as well as linux ?
04:58:18 <Beardful> Linux*
04:58:39 <alpounet> the ones you get with ghc should work flawlessly on windows, linux & osx
04:58:57 <alpounet> the ones from hackage... well, it depends :)
04:59:46 <Beardful> When you say with ghc, is that like cabal ? Or is ghc a package manager itself ?
05:01:17 <alpounet> Beardful: ghc is the main haskell compiler
05:02:24 <Beardful> Right, i thought you meant something else. ;D
05:09:29 * hackagebot imports 0.1.0.0 - Generate code for importing directories automatically  http://hackage.haskell.org/package/imports-0.1.0.0 (CindyLinz)
06:11:56 <arianvp___> Is there a language extension that supports "fall through" cases?
06:12:07 <arianvp___> I got a lot of case matches that evaluate the same function
06:12:33 <arianvp___> a -> f a ; b -> f b ; c -> f c  can I shorten this to    a,b,c -> f _?
06:14:18 <ClaudiusMaximus> arianvp___: perhaps something like this but it's not exactly concise or pretty.. case x of y | case y of { a -> True ; b -> True ; c -> True ; _ -> False } -> f y
06:15:34 <arianvp___> ClaudiusMaximus: This is the pattern: http://lpaste.net/7311670952260009984
06:17:01 <ClaudiusMaximus> arianvp___: case op of _ | op `elem` ["+", ...] -> when ...
06:17:17 <arianvp___> oh yeh
06:17:21 <arianvp___> thx
06:22:41 <byorgey> edwardk: does 'linear' have a way to take an affine combination of two elements of an affine space?  I couldn't find one
06:39:30 * hackagebot imports 0.1.1.0 - Generate code for importing directories automatically  http://hackage.haskell.org/package/imports-0.1.1.0 (CindyLinz)
06:44:30 * hackagebot imports 0.1.2.0 - Generate code for importing directories automatically  http://hackage.haskell.org/package/imports-0.1.2.0 (CindyLinz)
06:44:45 <iElectric> how can I run $ runhaskell src/Main.hs
06:44:55 <iElectric> so that module imports would respect src/ as root?
06:48:52 <Gothmog_> iElectric: I guess runhaskell src/Main.hs -- -isrc
06:49:36 <ClaudiusMaximus> probably runhaskell -isrc src/Main.hs (going from runhaskell --help)
06:50:32 <lpaste> farnoy pasted “conduit skipping problem” at http://lpaste.net/118624
06:50:59 <farnoy> Hi, could you help me with Conduit? It seems to be skipping some values in the stream
06:51:18 <iElectric> Gothmog_: I also use "reserve" binary, is there something like bash env variables for search paths?
06:52:54 <iElectric> got it
06:52:59 <iElectric> echo ":set -isrc" >> .ghci
06:54:30 * hackagebot strive 0.6.2 - A Haskell client for the Strava V3 API.  http://hackage.haskell.org/package/strive-0.6.2 (fozworth)
07:00:08 <luite> what's the way to deal with precomposed characters and combining diacritics with Data.Text? is there a composed form for every character that should be expressible?
07:07:32 <Mihaibuc> http://Earn4Share.com/?id=70135
07:07:57 --- mode: ChanServ set +o geekosaur
07:08:06 --- mode: geekosaur set +b *!*@5-12-173-236.residential.rdsnet.ro
07:08:06 --- kick: Mihaibuc was kicked by geekosaur (Mihaibuc)
07:08:15 --- mode: geekosaur set -o geekosaur
07:10:23 <spearman> anyone here currently using hscurses?
07:12:20 <johnw> luite: good question
07:15:52 <spearman> well, it seems i can install hscurses by running `cabal install` from the cloned repository...but that installs globally? how can i install to a local project sandbox?
07:16:17 <spearman> i tried installing from hackage (cabal install hscurses) but ran into errors
07:20:14 <statusfailed> Is it more correct to say Haskell is "turing equivalent" rather than "turing complete"?
07:20:28 <statusfailed> (or any relevant programmin language for that matter)
07:20:54 <vanila> statusfailed, both of those mean the same thing
07:21:12 <statusfailed> vanila: I thought they were slightly different?
07:21:31 <johnw> I'd never heard of turning equivalent
07:21:37 <vanila> they're the same
07:21:42 <statusfailed> I'm reading this for context: http://en.wikipedia.org/wiki/Turing_completeness#Formal_definitions
07:22:09 <vanila> ohh
07:22:17 <vanila> yeah i was wrong
07:22:28 <statusfailed> vanila: can you explain how? I don't really understand :D
07:22:40 <vanila> a super turing device (none exist in the universe) could be turing complete, but not turing equivlent -- since its more powerful
07:23:08 <vanila> the thing is turing equivalent is (seemed to be) the strongest kind of computation you can do in this universe
07:23:21 <spearman> is the problem a turing machine assumes unlimited resources?
07:24:06 <statusfailed> spearman: I don't think so? I'm trying to understand how "turing equivalence" differs from "turing completeness"
07:24:14 <vanila> its more that with the laws of physics and machine you could build seems to be turing equivalent as best
07:24:31 <vanila> so there doesn't seem to be any way to do super-turing computation
07:24:48 <vanila> like string theory hasn't given us a way to tell if an arbitrary program halts
07:25:04 <spearman> statusfailed: a problem could be "turing computable" but require some huge amount of memory
07:25:33 <statusfailed> oh wait; turing equivalent could possibly be a _smaller_ set than turing complete
07:25:38 <statusfailed> but the church-turing thesis is "they are equal"
07:25:39 <statusfailed> ?
07:25:40 <vanila> yeah
07:25:46 <vanila> thats exactly right
07:25:52 <statusfailed> noice, thanks :-)
07:30:15 <luite> johnw: :) i'm porting it to JS which turned out to be a bit more work than i had hoped...
07:30:38 <jtanguy> spearman: concerning your sandbox problem, if you really need the cloned source, you can add it as a source depdency to your project
07:31:14 <spearman> jtanguy: thanks, i'll look into that
07:32:12 <johnw> luite: yeah, as many things are...
07:33:04 <jtanguy> spearman: did you `cabal sandbox init` in your project ? any cabal install after that should use the sandbox, not the global db
07:34:13 <spearman> well if i clone hscurses into a subdirectory, does it look for the sandbox in the parent directory?
07:37:57 <spearman> either i `cabal install` from /myproject/hscurses/ it gets installed globally, or `cabal install` from /myproject/ installs from hackage (which fails with a compile error)
07:39:05 <luite> johnw: yeah, i spent way too many hours programming in the past months :/ but i'm forcing myself to go on vacation soon so i can at least see mountains out of the window while working on haskell code ;)
07:39:08 <hexagoxel> spearman: sounds like a usecase of cabal sandbox add-source
07:39:50 <d12frosted> Hey, does anyone know anything about optparse-applicative destiny?
07:39:53 <jtanguy> if the install from hackage fails, you need an add-source
07:40:25 <jtanguy> you clone hscurses into any folder (say /hscurses/) for instance
07:40:40 <spearman> hexagoxel: that worked perfectly! thanks
07:41:32 <johnw> luite: haha, to me, vacation is writing the code I want to write; but seeing mountains at the same time would be cool
07:42:20 <jtanguy> i don't think cabal looks into parent folders for a sandbox, so that's why your clone of hscurses gets installed globally
07:43:16 <hexagoxel> where "globally" = user-globally
07:43:35 <hexagoxel> but correct otherwise
07:44:07 <spearman> yeah, makes sense
07:44:09 <SrPx> "deepseq" is not forcing the evaluation of "k" in `do { x <- return (deepseq k "test"); print "ok" }` . Probably because "deepseq k 0" is never needed. How do I force it?
07:44:10 <jtanguy> yes
07:44:16 <SrPx> deepset k "test" *
07:44:20 <hexagoxel> you can add `require-sandbox: true` to ~/.cabal/config to prevent accidental non-sandbox installs
07:44:59 <spearman> does it hurt to have globally installed packages? i suppose if things get broken at some point i can just wipe them
07:45:11 <spearman> sometimes it is convenient to just use a package without creating a new sandbox
07:46:39 <CindyLinz> SrPx: do { x <- return (deepseq k "test"); seq x (print "ok") }
07:47:16 <SrPx> CindyLinz: yea but the point is that I want to avoid "print" inside a benchmark :( but I guess I know... let me see
07:49:19 <CindyLinz> SrPx: ^^
07:49:30 <SrPx> :) ty
07:51:43 <luite> johnw: oh i've given up on that dream long ago :p  majority of code in my own projects is stuff that i don't really want to write, but no one else is going to step up to do it
07:52:51 <hexagoxel> spearman: and when you wipe, suddenly all non-sandbox packages stop working. it is just like using a global variable, instead of directory-local state :D
07:54:04 <hexagoxel> spearman: and i'd argue that sandbox installs are more deterministic in what versions exactly get chosen, while user-global stuff depends on your long-term order of installs
08:11:21 <elzair> I have a question about System.Process.createProcess
08:12:08 <elzair> I am trying to create a function that can execute both a ShellCommand and a RawCommand and return StdOut, StdErr, and the ExitCode in a tuple.
08:12:21 <elzair> The current code is at https://gist.github.com/Elzair/3aa4477c83640d688f43
08:12:47 <elzair> However, using pattern matching means most of the code is duplicated.
08:12:54 <elzair> Is there a better way to do this?
08:14:21 <Black0range> How do I make string constants ByteString by default?
08:14:25 <CindyLinz> elzair: create a function for the common part
08:14:30 * hackagebot descriptive 0.0.0 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.0.0 (ChrisDone)
08:14:44 <hexagoxel> elzair: sure, just postpone the pattern matching
08:14:50 <koomi> elzair: you can make a helper function of type CmdSpec -> CreateProcess
08:16:01 <hexagoxel> elzair: http://lpaste.net/118625
08:17:08 <CindyLinz> elzair: https://gist.github.com/Elzair/3aa4477c83640d688f43#comment-1374721
08:17:21 <hexagoxel> and sure, after this transformation, feel free to put some part into a separate local/global variable
08:17:27 <elzair> Thanks!
08:24:30 * hackagebot structured-haskell-mode 1.0.6 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.6 (ChrisDone)
08:52:17 <Black0range> How do you convert an integer to a Bytestring?
08:53:12 <hpc> what kind of conversion?
08:53:45 <Black0range> 1337 -> "1337"
08:54:14 <hpc> use show
08:54:21 <hpc> and then decide how you want to pack the string
08:55:26 <hpc> https://www.haskell.org/hoogle/?hoogle=pack
08:57:05 <Black0range> hmm are there any way to overload show?
09:06:10 <statusfailed> Is it possible to limit the execution time/memory constraints of a haskell expression while remaining "pure"? (i.e., not using IO)
09:06:37 <statusfailed> I'm guessing real-world-time constraints mean no because that would be not referentially transparent
09:07:02 <statusfailed> but what about a notion of say "number of instructions executed"
09:08:07 <glguy> You can do a pure step limited computation by wiring it using an explicit step type at least.
09:08:46 <statusfailed> glguy: I guess that's kind of requiring you to embed an entire language though right?
09:08:53 <statusfailed> otherwise "compute next step" could be bottom
09:09:25 <glguy> It's up to you to make valid steps, yes
09:10:03 <ski> you can say `data Termination a = Terminate a | Step (Termination a)', and make it into an applicative functor, monad
09:10:37 <SrPx> Is there any way to define a binary cartesian product on lists such that `[1,2] * [3,4] * [5,6] == [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]" ? Obviously not, but what is the right approach to this intuition ?
09:10:56 <ski> if you prefer, you could attach a rational or floating-point number to each step, representing a "cost"
09:11:32 <SrPx> In other words, I want a brief way to express: [f x y z  x <- a, y <- b, z <- c] in general
09:11:54 <ski> > let (<*>) = liftA2 (,) in [1,2] <*> [3,4] <*> [5,6]
09:11:56 <lambdabot>  [((1,3),5),((1,3),6),((1,4),5),((1,4),6),((2,3),5),((2,3),6),((2,4),5),((2,4...
09:12:20 <ski> > T.sequenceA [[1,2],[3,4],[5,6]]
09:12:21 <lambdabot>  [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
09:12:40 <ski> > (,,) <$> [1,2] <*> [3,4] <*> [5,6]
09:12:42 <lambdabot>  [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
09:12:46 <statusfailed> ski: Makes sense, but I think you still have the problem of generating the steps in the first place
09:12:47 <ski> SrPx : the last one ?
09:13:20 <ski> `T.sequenceA' is like `sequence', only works for any applicative functor, not just monads, also works for any traversable data structure, not just lists)
09:14:17 <ski> (and `liftA2' is the applicative functor version of (the monadic) `liftM2')
09:14:18 <SrPx> ski: yea the last one, thanks :) Now, what is again that language pragma to express `f <$> x <*> y` ? I
09:14:23 <SrPx> like [[f x y]]
09:14:48 <SrPx> ski: an interesting, sounds awesome ... let me test it with V3
09:15:35 <ski> @hackage applicative-quoters  SrPx,this ?
09:15:35 <lambdabot> http://hackage.haskell.org/package/applicative-quoters  SrPx,this ?
09:15:51 <SrPx> thank you!!
09:16:16 <ski> (see the `Idiom' part. "idiom" is another name for "applicative functor")
09:17:08 <ski> (or rather .. it's the original name :)
09:17:10 <SrPx> is it a bad practice to use it?
09:17:16 <ski> use what ?
09:17:26 <ski> the name or the package ?
09:17:51 <SrPx> the package
09:17:53 <SrPx> lol
09:17:59 <ski> not that i know
09:18:11 <ski> (as long as you're ok with using TH)
09:18:17 <sshine> hi. if I'm writing a Generator for some datatype, I might want to do state-based generation. e.g. I might generate tv characters where some are dads to characters that already exist within some environment, and some might be truly random.
09:18:35 <sshine> question is: can I write a Gen MyType that uses a Reader/State?
09:18:59 <ski> personally i'm more fond of the name "idiom" .. however, sometimes that can be confusing to use, without qualification that we need a specific technical thing, rather than an "idiom" in the general sense
09:19:17 <sshine> ahhh. GeneratorT :)
09:19:18 <ski> (and similarly for the derived term "idiomatic". cf. "monadic")
09:19:39 <monochrom> "idiomatic haskell" would take it to a whole new level :)
09:19:50 <SrPx> yes, it would be hard to google information about something called idiom
09:20:09 <sshine> no, wait... Control.Monad.GeneratorT looks like it's for generating lists specifically.
09:20:17 <monochrom> then again, "applicative haskell" could also simply mean "using haskell to write real-life applications"
09:21:06 <monochrom> someone should write a book called "applicative haskell" just to confuse everyone :)
09:21:17 <SrPx> uh to be honest I think a better syntax would be something lie that ( 'V2 [1,2] [3,4] → [(1,2) (3,4)] ) is there any lib for this?
09:21:39 <SrPx> I mean [V2 1 2, V2 3 4]
09:21:53 <SrPx> eh... with.. the cartesian, which I didn't take. Lol sorry.
09:21:56 <monochrom> no
09:21:59 <SrPx> you get what I mean though
09:24:30 * hackagebot descriptive 0.0.1 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.0.1 (ChrisDone)
09:25:48 <sshine> do people use QuickCheck's Gen class for non-testing purposes or is there something similar elsewhere?
09:32:37 <ski> SrPx : imho, it would not be better
09:33:20 <SrPx> hm why not ? Just a token that lifts a function to the right number of arguments instead of liftAN... why'd you prefer the later ?
09:41:24 <ski> SrPx : how should the language know when to perform such lifting and when not to ?
09:42:24 <SrPx> ski: I don't get it... it is a prefix operator... it does when it is there
09:42:32 <SrPx> just a shortcut for liftAN
09:42:55 <ski> (also i didn't say that i prefer `liftA',`liftA2',&c. ..., using `(<*>)',`pure' and `(<$>)' can also be fine (though i'd prefer a little renaming))
09:43:21 <ski> SrPx : how should it know when to perform that shortcut insertion, and when not ?
09:50:03 <SrPx> ski: I don't get what you mean :( it just converts every instance of `lift f x y z` into `liftA3 f x y z` ... is that impossible?
09:50:29 <enthropy> you can write a liftAN function
09:50:44 <SrPx> I mean I know if is impossible to actually implement a "lift" function which is polymorphic on the number of arguments of f... but I thought the compiler could just count it
09:50:50 <glguy> SrPx: It wouldn't know if it should lift for 3 or maybe 4 arguments
09:50:51 <SrPx> enthropy: hm?
09:51:12 <mauke> SrPx: syntactically?
09:51:38 <Hijiri> can you do what printf does?
09:51:53 <mauke> hmm. how many lifts would ((lift f x) y) z do?
09:52:07 <mauke> also let g = lift f x in g y
09:52:28 <SrPx> depends on the type of f... if it is "a → a → a → a" then 3 ? I don't know, if it is impossible disregard, I don't know much about the type system workings
09:52:47 <mauke> so not syntactically
09:52:53 <SrPx> nah
09:52:56 <Hijiri> printf does polyvariadic function by abusing typeclasses
09:53:45 <mauke> > liftA length show 666
09:53:46 <lambdabot>  3
09:54:17 <Hijiri> > printf "kkkkkk %d" 6
09:54:18 <lambdabot>  No instance for (GHC.Show.Show a0)
09:54:18 <lambdabot>    arising from a use of ‘M69815790084363448925141.show_M69815790084363448925...
09:54:18 <lambdabot>  The type variable ‘a0’ is ambiguous
09:54:58 <Hijiri> > printf "kkkkkk %d" 6 :: String
09:55:00 <lambdabot>  "kkkkkk 6"
09:55:19 <Hijiri> > printf "kkkkkk %d %d %s" 6 7 "banana"
09:55:21 <lambdabot>  No instance for (GHC.Show.Show a0)
09:55:21 <lambdabot>    arising from a use of ‘M601463232277316342025179.show_M6014632322773163420...
09:55:21 <lambdabot>  The type variable ‘a0’ is ambiguous
09:55:24 <Hijiri> > printf "kkkkkk %d %d %s" 6 7 "banana" :: String
09:55:26 <lambdabot>  "kkkkkk 6 7 banana"
09:55:44 * SrPx is confused
09:56:00 <glguy> Oh... good... lambdabot is back
09:56:02 <Hijiri> http://hackage.haskell.org/package/base-4.7.0.2/docs/Text-Printf.html#v:printf
09:56:29 <SrPx> how can it do it
09:56:40 <Hijiri> the output is constrained with a typeclass, and
09:57:12 <mauke> the type of printf in this expression is nailed down by context
09:57:17 <Hijiri> String is a member, but also functions that take an argument and give another thing in the typeclass
09:57:20 <mauke> this lets it select the right typeclass instance
09:57:29 <mauke> which in term drives the parsing of the format string
09:57:37 <mauke> it's somewhat backwards
09:57:37 <Hijiri> if you have more arguments it has to choose the function instance
09:59:43 <SrPx> How can you have instances for different function lengths
10:00:16 <mauke> a -> b -> c -> d is a -> (b -> (c -> d))
10:00:28 <glguy> SrPx: http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Text-Printf.html#printf
10:00:42 <mauke> you have an instance for A -> X where X can be another function type
10:00:52 <glguy> You can look at the source and see exactly how you can do it
10:02:38 <monochrom> why are people so fascinated with varargs?
10:04:43 <systemfault> Who is?
10:05:05 <monochrom> SrPx is
10:05:51 <ski> SrPx : oh, you didn't say you wanted a `lift' word in there. well, `lift f x y z' is (under normal syntax rules in Haskell) the same as `(lift f x y) z' (e.g.) -- so should it be `liftA3 f x y z' or `liftA2 f x y z' (or `liftA f x y z' or `pure f x y z' or `\w -> liftA4 f x y z w' or ...) then ?
10:07:29 <ski> (or are you saying you want to introduce a special case that doesn't fit the current rules ?)
10:08:07 <Hijiri> @let class Bob a where { john :: Int -> Int -> a }
10:08:09 <lambdabot>  Defined.
10:08:29 <Hijiri> @let instance Bob Int where { john = (+) }
10:08:30 <lambdabot>  Defined.
10:08:35 <hpc> > john 4 5
10:08:36 <lambdabot>  No instance for (GHC.Show.Show a0)
10:08:37 <lambdabot>    arising from a use of ‘M870676307815156981125399.show_M8706763078151569811...
10:08:37 <lambdabot>  The type variable ‘a0’ is ambiguous
10:08:44 <hpc> > john 4 5 :: Int
10:08:45 <lambdabot>  9
10:08:48 <hpc> !!
10:08:53 <Hijiri> @let instance Bob r => Bob (Int -> r) where { john x y z = john (x + y) z }
10:08:54 <lambdabot>  Defined.
10:09:02 <Hijiri> @let add = john 0
10:09:04 <lambdabot>  Defined.
10:09:14 <Hijiri> > add (5 :: Int) (6 :: Int) :: Int
10:09:16 <lambdabot>  11
10:09:27 <Hijiri> > add (5 :: Int) (6 :: Int) (100 :: Int) :: Int
10:09:28 <lambdabot>  111
10:09:37 <SrPx> monochrom: I don't like varargs ... for lift specifically I think it would be great...
10:09:42 <SrPx> ski: a sec
10:10:38 <monochrom> lift is even worse. where "lift a b c d" does not always mean "lift a b c d". it only means, telepathically, what the author hides in his/her mind. this is disastrous.
10:11:08 <monochrom> why are people fascinated with "guess what I mean"?
10:11:29 <Hijiri> @let add' = john 0 0
10:11:30 <lambdabot>  Defined.
10:11:36 <Hijiri> > add'
10:11:37 <lambdabot>  No instance for (GHC.Show.Show a0)
10:11:38 <lambdabot>    arising from a use of ‘M185721697429185629425530.show_M1857216974291856294...
10:11:38 <lambdabot>  The type variable ‘a0’ is ambiguous
10:11:46 <Hijiri> ok I'll stop spamming
10:11:49 <ski> type add'
10:11:51 <ski> @type add'
10:11:52 <lambdabot> Bob a => a
10:12:06 <ski> > add' :: Int
10:12:08 <lambdabot>  0
10:12:41 <Hijiri> now it's like the lisp (+)
10:12:45 <ski> (fwiw, i'm with monochrom here)
10:12:49 <Hijiri> (at least I think, I've never coded in lisp)
10:13:13 <ski> `+' in the lisps aren't curried :)
10:13:43 <hpc> lisp's (+) would be more like sum :: HList -> HList
10:14:31 * hackagebot structured-haskell-mode 1.0.7 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.7 (ChrisDone)
10:17:49 <SrPx> monochrom: I don't understand your point. The rule is precise, you are calling a lift function according to the arity of the first argument...
10:17:52 <kranius> :t <|>
10:17:53 <lambdabot> parse error on input ‘<|>’
10:17:54 <SrPx> There is no gueswork here...
10:18:56 <marchelzo_> Is it bad if compare x y == EQ, but x /= y?
10:19:14 <hpc> very bad
10:19:42 <EvanR> for that, use the EqJustKidding class
10:19:43 <monochrom> you probably haven't known that "arity", while unambiguous and well-defined for many languages, is a pretty slippery slope in haskell.
10:20:20 <monochrom> for example, id could have type ()->(), which has "arity" 1.
10:20:39 <monochrom> and it could also have type (()->()) -> () -> (), which has "arity" 2
10:20:55 <monochrom> and it could also have type (()->()->()) -> () -> () -> (), which has "arity" 3
10:21:09 <monochrom> it goes on and on
10:21:09 <EvanR> so id is a vararg!
10:21:52 <monochrom> @quote monochrom 17-ary
10:21:52 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
10:22:17 <monochrom> this scheme of "lift" is full of guesswork.
10:25:33 <ski> SrPx : "arity" is not well-defined
10:25:33 <Hijiri> > backwards 'y' 'y' 'a' :: String
10:25:33 <lambdabot>  Ambiguous occurrence ‘backwards’
10:25:33 <lambdabot>  It could refer to either ‘L.backwards’, defined at L.hs:179:1
10:25:33 <lambdabot>                        or ‘Control.Lens.Fold.backwards’,
10:25:33 <ski> .. alternatively, you can say that the arity is always `1' (satisfied ?)
10:25:33 <Hijiri> > L.backwards 'y' 'y' 'a' :: String
10:25:33 <lambdabot>  "ayy"
10:25:36 <monochrom> yeah, it's why I put "arity" in quotes. formally, haskell arity can only be 0 or 1.
10:25:52 <monochrom> and if haskell arity can only be 0 or 1, the utility of "lift" vanishes.
10:26:53 <SrPx> monochrom: I still don't understand, sorry. How could "id" have type (()→())→()→() ?
10:26:58 <SrPx> ah
10:27:01 <SrPx> hmmm...
10:27:13 <monochrom> "arity" in quotes can understandably be understood as "let's intuitively borrow that notion from other languages". and it's a slippery slope.
10:27:26 <ski> > id (id :: () -> ()) ()
10:27:26 <monochrom> it slips all the way down to infinity.
10:27:27 <lambdabot>  ()
10:27:29 <exio4> just like id is ($)
10:27:50 <ski> @type id `asTypeIn` \thisId -> thisId (id :: () -> ()) ()
10:27:51 <lambdabot> (() -> ()) -> () -> ()
10:27:53 <SrPx> ski: I guess he means
10:27:59 <SrPx> yes this
10:28:11 <ski> that's the type of `thisId' (being equal to `id', in `thisId (id :: () -> ()) ()')
10:28:35 <enthropy> http://lpaste.net/118630 seems reasonable enough that you can say the arity of (+) is >=2
10:29:15 <ski> SrPx : similarly, `foldr' "usually" has arity three, but can have higher arity as well .. same goes for any function whose result type is a type variable
10:30:13 <ski> > foldr (\c f s -> f (c : c : s)) (\s -> "!" ++ s ++ "!") "abcd" ""  -- four arguments
10:30:15 <lambdabot>  "!ddccbbaa!"
10:30:44 <ski> (that's an instance of "leaned so much right they came back left")
10:31:29 <aristid> is there a good general bidirectional parsing and generation framework?
10:31:41 <aristid> like jsongrammar but not just json
10:37:25 <chinaxing> ?wiki Monad
10:37:26 <lambdabot> http://www.haskell.org/haskellwiki/Monad
10:37:39 <chinaxing> give a few examples
10:38:53 <chinaxing> who is here ?
10:39:44 <kranius> Maybe User
10:41:30 <aristid> Maybe, [], IO would be very common instances of Monad.
10:43:39 <trap_exit> is there anyway to make the Parsec 'state' be RWS rather than just a state?
10:43:50 <trap_exit> i.e. I want RWS + Parsec, but I don't think any of the monad transformers do what I want
10:44:18 <mpickering> trap_exit: No
10:44:31 * hackagebot cron 0.2.5 - Cron datatypes and Attoparsec parser  http://hackage.haskell.org/package/cron-0.2.5 (MichaelXavier)
10:44:44 <trap_exit> :-(
10:44:58 <mpickering> It might not do what you want anyway - the internal parsec state is reset on backtracking
10:45:32 <mpickering> why can you not use RWST ... .. ... (Parsec .. .. ..) ?
10:49:59 <lori123456> hello everybody
10:51:29 <lori123456> ?
10:52:45 <EvanR> hello sailor
10:53:07 <Hijiri> there is also PrsecT
10:53:11 <Hijiri> ParsecT*
10:54:17 <Lorihaskell> I got pinged!
10:56:20 <Pamelloes> If I have a type MyType that needs a special compare definition for  [MyType], how do I distinguish between Ord [MyType] and Ord [a]?
10:58:11 <EvanR> Pamelloes: you can use a newtype to define MyType instead of type (type synonym)
10:58:25 <EvanR> newtypes can be equipped with alternative instances
10:58:58 <EvanR> that is, newtype for list of MyType
10:59:12 <EvanR> or you could not use Ord
11:01:18 <Pamelloes> EvanR: So I would say newtype MyTypeList = [MyType] and then define instance Ord MyTypeList instead of instance Ord [MyType]?
11:02:15 <EvanR> yes but the syntax is newtype MyTypeList = MyTypeList [MyType]
11:02:42 <Pamelloes> Alright.
11:02:46 <EvanR> > [1, 2, 3] < [1, 3, 3]
11:02:48 <lambdabot>  True
11:02:51 <EvanR> > [1, 2, 3] < [1, 1, 3]
11:02:52 <lambdabot>  False
11:03:24 <EvanR> so you can wrap it to get new Ord behavior, and unwrap it to use the list operations on it
11:09:31 * hackagebot descriptive 0.0.2 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.0.2 (ChrisDone)
11:09:33 * hackagebot structured-haskell-mode 1.0.8 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.8 (ChrisDone)
11:09:35 * hackagebot hindent 4.2.0 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.2.0 (ChrisDone)
11:14:32 * hackagebot cayley-client 0.1.1.0 - An Haskell client for Cayley graph database  http://hackage.haskell.org/package/cayley-client-0.1.1.0 (MichelBoucey)
11:14:34 * hackagebot postgrest 0.2.5.0 - REST API for any Postgres database  http://hackage.haskell.org/package/postgrest-0.2.5.0 (begriffs)
11:16:12 <crundar> This is probably easy, I just don't know the answer.
11:16:47 <crundar> $ cabal install cabal-install, and it's sayin some packages are likely to be broken by reinstalls. I just told it to go through anyway
11:17:04 <crundar> what's the preferred way to keep everything up to date and unbroken?
11:17:32 <crundar> Other question, if I have in fact broken a bunch of packages, how do I go about identifying what I broke and fixing it.
11:19:32 * hackagebot kafka-client 0.7.0.0 - Low-level Haskell client library for Apache Kafka 0.7.  http://hackage.haskell.org/package/kafka-client-0.7.0.0 (abhinav)
11:22:41 <glguy> Crundar: it's safer to unregister a package that would have been broken first and then reinstall it after you've upgraded its dependencies
11:24:24 <EvanR> im trying to understand the taxonomy when using DataKinds. this allows definition of new kinds at the same level as * ? So when the doc says Nat :: BOX, and that BOX is a sort, what does :: mean?
11:24:44 <glguy> Has kind
11:24:57 <glguy> Has sort has type
11:25:15 <EvanR> * :: BOX ?
11:25:17 <glguy> It's just context specific
11:25:19 <SrPx> crundar: easy... heh... I personally suggest using stackage. This thing of cabal problem is the worst thing about the language IMO (gotta run after saying that, see you)
11:25:25 <EvanR> is there a way to ask what the sort of something is
11:26:06 <EvanR> SrPx: you better run!
11:26:24 * SrPx is to far and can't hear you
11:26:53 <glguy> Crundar: I use a utility I called GhcPkgUtils to identify when multiple versions of a package have been installed, to recursively unregister old versions and to detect old versions
11:26:55 <Pamelloes> If I have (newtype TypeB = TypeB TypeA), is there a function equivalent to unbox:: (TypeB TypeA) -> TypeA?
11:27:31 <mauke> TypeB TypeA is a kind error
11:27:59 <glguy> Define your new type using record notation to get such a function
11:28:00 <mauke> consider the following: newtype TypeB = BoxB{ unboxB :: TypeA }
11:28:43 <Pamelloes> OK
11:28:44 <crundar> glguy: Well, whereas I /should/ have asked before executing the command, what I /actually/ did was asking while I was waiting for cabal to update.
11:29:06 <crundar> It ended up with two warnings, but cabal didn't say anything errorful.
11:29:13 <Pamelloes> crundar: Don't worry if worst comes to worst, you can always reinstall your operating system :P
11:29:34 <Pamelloes> Unless you're on Windows or OS X in which case that isn't recommended.
11:30:08 <glguy> I believe ghc-pkg check.  Will tell you which are broken
11:30:18 <crundar> Pamelloes: http://www.priceisrightlosinghorn.com/
11:30:22 <crundar> yeah OS X
11:30:25 <EvanR> it seems like theres two languages going on here, one a subset of the other. regular haskell, and regular haskell plus all the common extensions. since the latter extensions seem to all feed on each other, seems like a whole language to itself
11:31:02 <EvanR> gadt syntax / gadts, type families, polykind, data kinds, rankN
11:31:34 <Pamelloes> I tend to avoid extensions for that exact reason...
11:31:46 <Pamelloes> (read: I'm lazy)
11:31:55 <EvanR> and the latter seems to have a lot less introductory material
11:32:03 <EvanR> just the ghc docs, and blogs that use them like its normal ;)
11:36:41 <EvanR> would you say that Constraint :: BOX
11:39:32 * hackagebot Chart 1.3.3 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-1.3.3 (TimDocker)
11:39:35 * hackagebot Chart-cairo 1.3.3 - Cairo backend for Charts.  http://hackage.haskell.org/package/Chart-cairo-1.3.3 (TimDocker)
11:39:37 * hackagebot Chart-gtk 1.3.3 - Utility functions for using the chart library with GTK  http://hackage.haskell.org/package/Chart-gtk-1.3.3 (TimDocker)
11:39:39 * hackagebot Chart-diagrams 1.3.3 - Diagrams backend for Charts.  http://hackage.haskell.org/package/Chart-diagrams-1.3.3 (TimDocker)
11:41:36 <benzrf> EvanR: sure
11:41:43 <benzrf> they're all :: BOX =)
11:41:56 <EvanR> all kinds :: BOX
11:44:33 * hackagebot Chart-simple 1.3.3 - A wrapper for the chart library to assist with basic plots (Deprecated - use the Easy module instead)  http://hackage.haskell.org/package/Chart-simple-1.3.3 (TimDocker)
11:45:07 <ski> because `->' in e.g. `Functor :: (* -> *) -> Constraint' is not a separate first-class thing, you can't say `(->) :: BOX -> BOX -> BOX' for it
11:46:56 <EvanR> so Functor, by itself, would be a Constraint / kind constructor and :: BOX too
11:47:14 <sshine> I have: [ "foo " + x | x <- f ] ++ [ "bar " + x + "." | x <- f ]; how can I do this neater?
11:47:44 <Cale> I assume those +'s are really ++'s?
11:47:50 <sshine> whoops, yes.
11:48:29 <EvanR> so essentially BOX is really boring and could be ignored completely
11:48:29 <Cale> [pre ++ x ++ post | (pre,post) <- [("foo ",""), ("bar ",".")], x <- f]
11:48:30 <systemfault> I'm still pretty new to haskell and was wondering... Haskell has the concept of "kinds", is it possible to "work" with kinds the same way you can work with "types"?
11:48:38 <sshine> Cale, thanks!
11:48:53 <Cale> That's actually longer :P
11:49:04 <Cale> But perhaps easier to organise in other respects
11:49:12 <EvanR> systemfault: yes, thats what i was just looking into. using DataKinds, PolyKinds, GADT syntax, and ConstraintKinds gives you a lot of room to work with
11:49:31 <Cale> systemfault: Kind of :)
11:49:31 <sshine> yes. :)
11:49:43 <systemfault> EvanR: For a beginner, what should I look at first? (From your list)
11:49:51 <EvanR> GADT syntax
11:50:01 <EvanR> im a beginner though
11:50:16 <Cale> GADTs are probably the most bang for your buck amongst those features.
11:50:43 <Cale> Though they don't have that much to do with kinds
11:51:25 <Cale> ConstraintKinds (which is weirdly named, given that it only adds a single kind called Constraint) is pretty useful.
11:51:50 <Cale> It lets you parameterise a data type or a type class by some class constraints.
11:52:09 <koomi> IMO, as a haskell beginner, you shouldn't worry about those things until your confident with haskell without extensions
11:52:32 <halvorg> Hey, I have an array of type Array (Int, Int) SomeType, but (getBounds array) has type (Int, Int) and not ((Int, Int), (Int, Int)).
11:52:35 <halvorg> is this normal?
11:52:36 <Cale> Yeah, all these things are not such a big deal to pick up later on, and don't see a *huge* amount of use.
11:53:02 <Cale> :t getBounds
11:53:03 <lambdabot> Not in scope: ‘getBounds’
11:53:08 <Cale> :t bounds
11:53:09 <lambdabot> Ix i => Array i e -> (i, i)
11:53:09 <EvanR> it seems like all big-name packages use type families in some way
11:53:33 <halvorg> http://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array-MArray-Safe.html#v:getBounds
11:54:04 <Cale> ah, okay
11:54:38 <Cale> Well, if getBounds arr :: m (Int, Int), then arr :: a Int e
11:54:39 <benzrf> EvanR: pipes uses haskell2010 afaik!
11:54:50 <Cale> So, perhaps you're mistaken about the type of your array?
11:55:04 <EvanR> benzrf: what does that imply? i havent look at haskell 2010 yet
11:55:06 <koomi> EvanR: that depends on what you see as "big-name packages", most of the packages I know that deal with problems of practical programming don't really use any advanced type-level stuff
11:55:13 <benzrf> EvanR: i mean it just uses stuff in the standard
11:55:21 <benzrf> oh nvm :|
11:55:53 <EvanR> koomi: well they use extensions
11:55:53 <benzrf>     FlexibleInstances
11:55:54 <benzrf>   , MultiParamTypeClasses
11:55:54 <benzrf>   , RankNTypes
11:55:54 <benzrf>   , UndecidableInstances
11:56:01 <benzrf> oops sry
11:56:02 <halvorg> Hm Cale, seems only ghci gave the error. it works when i do cabal build.
11:56:07 <koomi> EvanR: what packages do you have in mind?
11:56:11 <Cale> halvorg: odd
11:57:52 <EvanR> koomi: all the ones at the top of this list https://hackage.haskell.org/packages/top
11:58:36 <Cale> Type/data families actually have some really cool practical uses for large scale programming. In the game we were working on, there was a bunch of code that got shared between the editor and live game, but various data structures would be different, and using type families was a convenient way to make the distinction between environments like that.
11:58:37 <EvanR> not much is pure haskll98 these days
11:58:56 <Cale> (and allow polymorphism over them whenever possible)
11:59:16 <SrPx> So, if I want to draw a circle on point x,y of a REPA unboxed array, is the *only* way to do it to cast a "map" and check, for every point, if it is inside the circle???
11:59:46 <Cale> SrPx: There are probably more efficient rasterisation algorithms than that.
12:00:22 <SrPx> I'd like to restrict the checks to a rectangle area, but I couldn't find a way to do so using REPA's API
12:00:24 <koomi> EvanR: with the exception of lens none of those packages require the user to have knowledge of fancy extensions
12:00:40 <EvanR> no i was just saying they were implemented using them
12:01:09 <Cale> e.g. For any given row, you should only need to compute where the first and last pixel in the circle are, and the pixels in between them are automatically inside, because circles are convex.
12:01:28 <Cale> I don't know REPA all that well though.
12:02:03 <SrPx> yea the problem is that there is no such a thing as a "set a single point" ... I've tried to do that a few days ago too and I gave up
12:02:22 <EvanR> Cale: how did that work? you have a type family for each data structure, and two instances for each family "Live" and "Editor" ?
12:02:31 <Cale> EvanR: yeah
12:02:43 <koomi> EvanR: I don't think many of those use TypeFamilies etc. in their implementation either
12:02:53 <koomi> anyway, I'm not trying to say those extensions are useless
12:02:54 <Cale> EvanR: and then sometimes classes for defining operations which would need different implementations in each environment
12:03:09 <koomi> just that beginners should focus on the basics of the language first
12:03:52 <EvanR> yes haskell0 <: haskell1
12:03:59 <Cale> koomi: Absolutely :)
12:04:06 <EvanR> where haskell1 is "ghc"
12:04:14 <EvanR> but it kind of leaks
12:04:45 <Cale> I think if a beginner is trying to use some library and they bump into some of these features, it doesn't hurt to learn them as required though.
12:05:03 <mgaut72> @pl \f a -> f a -> return a
12:05:03 <lambdabot> (line 1, column 15):
12:05:03 <lambdabot> unexpected '>'
12:05:03 <lambdabot> expecting operator
12:05:19 <mgaut72> @pl \f a -> f a >> return a
12:05:19 <lambdabot> (`ap` return) . ((>>) .)
12:05:20 <Cale> Also, I've occasionally run into beginners for whom GADT syntax was more intuitive
12:05:40 <EvanR> rank N seems like something that helps understand how polymorphism works in the first place
12:07:44 <Cale> The Haskell 98 syntax for declaring data types is only intuitive for people who've used BNF/context free grammars.
12:08:39 <EvanR> yeah that syntax could be thought of as a short hand for GADT syntax
12:08:44 <EvanR> and teach GADT syntax first
12:10:22 <EvanR> are implicit parameter constraints basically for saving typing on passing params?
12:10:35 <Cale> yeah, pretty much
12:10:54 <Cale> I've rarely found any occasion to use that feature
12:10:54 <EvanR> hmmm
12:11:11 <EvanR> seems spiritually opposed to haskell very explicit style
12:11:17 <Cale> Though, perhaps in some cases it would have been good really.
12:12:14 <Cale> Yeah, it's not as bad as you might think, because they really are part of the type of anything which depends on them, so at least at the type level it's clear what things depend on.
12:12:18 <exio4> it sounds like some non-intrusive(?) "Reader" monad there
12:12:32 <EvanR> i was thinking of something like reader
12:12:57 <Cale> Linear implicit parameters were worse (effectively an implicit State monad), but nobody used them and they got removed.
12:13:27 <breadmonster> Cale: Do you have a good introduction to monad transformers?
12:14:05 <Cale> breadmonster: Well, I could introduce you to monad transformers myself. I don't know if there's what I'd consider a good intro written down anywhere.
12:14:24 <Cale> (but I'm not the best person to ask, it's been a while since I read any introductory materials)
12:14:26 <breadmonster> Cale: alright tomorrow then, it's nearly two in the morning here.
12:14:27 <breadmonster> Thanks though!
12:14:33 * hackagebot hindent 4.2.1 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.2.1 (ChrisDone)
12:14:38 <Cale> Maybe CIS 194 has something?
12:15:03 <Hijiri> CIS 194 doesn't go over monad transformers irc
12:15:29 <Cale> Yeah, just looking and it doesn't seem to
12:17:10 <Cale> I think a really nice way to introduce monad transformers is to write a parsing monad: newtype Parser a = P { runParser :: String -> [(String, a)] }, and notice that the implementations of return and (>>=) didn't use anything specific to the list monad, or String, and extract the definition of StateT from that.
12:19:19 <Lokathor> so if i have a game that's going to use a lot of random numbers, but the game is already also using IO a lot to redraw each turn... should I just use randomRIO? Or is there some advantage to using a State value and then carefully passing it around? or maybe keeping it in a IORef when not in use?
12:19:43 <Cale> Lokathor: If you're in IO and you need random numbers, don't feel too bad about just using randomRIO
12:20:20 <Cale> But one thing to consider is whether more of the game's mechanics can be separated from the I/O code.
12:20:36 <Cale> and when you do that, you may want to switch to passing around the RNG state along with other game state
12:20:49 <Lokathor> hmmmm
12:21:21 <Lokathor> I would say that, ideally, 100% of the mechanics can be separated from IO, since it's turn based
12:21:26 <Cale> Yeah
12:22:23 <ReinH> Cale: That introduces monad *transformers*?
12:22:31 <Cale> ReinH: Well, StateT :)
12:22:49 <ReinH> Ah, [] -> Monad m
12:22:56 <Cale> ReinH: Parser is secretly StateT String []
12:22:58 <ReinH> so StateT
12:23:00 <ReinH> yeah that
12:23:05 <ReinH> got it
12:23:17 <ReinH> Cale: has that been written up anywhere?
12:23:21 <ReinH> It's nice.
12:23:25 <Cale> uhhh... there might be IRC logs
12:23:28 <ReinH> heh
12:23:34 <ReinH> I might give that a go.
12:23:34 <EvanR> #haskell university ;)
12:23:48 <Cale> I'm sure I've done it in #haskell-overflow at least a couple times
12:23:59 <Cale> (probably more than that)
12:24:25 <ReinH> So start with the Seussian definition of a Parser and extract StateT
12:24:26 <ReinH> Cool.
12:24:30 <Cale> indeed
12:24:55 <Cale> Yeah, you can probably find the occurrences of this lecture by searching for "a parser for things"
12:25:01 <ReinH> heh :)
12:25:06 <ReinH> I'll look around.
12:30:33 <halvorg> msum $ mapM is concatMap for monads?
12:31:21 <trap_exit> sup seahawks fans; is there a nicer way to write "fmap f1 $ fmap f2 g" ?
12:31:34 <lifter> After programming in Haskell for about 2 years now, I only just now learned about unfolds. Do you find these have many practical applications? Do they show up much in code?
12:31:36 <trap_exit> i feel like "fmap $ fmap" can be shortened
12:31:37 <trap_exit> this being haskell and all
12:31:53 <int-e> halvorg: (=<<) is concatMap
12:32:38 <Cale> trap_exit: fmap f . fmap g = fmap (f . g)
12:32:47 <trap_exit> hmm
12:32:50 <trap_exit> I like
12:32:52 <trap_exit> Cale: thanks
12:32:58 <lifter> trap_exit: Same can be said of map
12:33:10 <lifter> fmap for list is map anyway
12:34:45 <trap_exit> useful but irrelevant
12:34:50 <trap_exit> go hawks
12:38:18 <EvanR> :t unfoldr
12:38:20 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:38:54 <lifter> EvanR: Are you familiar w/ unfoldr?
12:38:58 <EvanR> yeah
12:39:03 <lifter> do u use it much?
12:39:42 <EvanR> no but it seems like what youd used to create an arbitrary lazy list
12:39:53 <EvanR> from a seed
12:40:19 <lifter> yeah, I imagine it could have lots of applications, I'm curious if it is actually used much tho
12:40:40 <lifter> kind of wondering if I should take a look at my code for places where it would be nice to use
12:40:54 <EvanR> the thing with lazy lists is they are good if you just want to consume or transform it
12:41:08 <EvanR> but not if you want to save and restore to disk or send over the network
12:41:15 <EvanR> or have it interact with IO
12:41:52 <lifter> yeah, my project has lots of IntMaps that contain lots of lists and it does do a lot of network IO
12:42:10 <lifter> my IntMaps defs are full of bangs
12:42:14 <EvanR> so the obvious RNG application of unfoldr becomes a little less useful if you want the RNG to survive an application reboot
12:42:59 <lifter> RNG = random # gen?
12:43:10 <EvanR> random number generator
12:43:18 <lifter> ok
12:43:42 <SrPx> hey guys some genius at SO actually managed to impement it, monochrom, ski ... http://lpaste.net/118634 is it so bad if I actually use that? I really like it...
12:43:43 <Cale> unfoldr's interface is often a little awkward compared to just using iterate/takeWhile/map
12:44:10 <Cale> Of course, if you happen to already have something which produces Maybe values like it requires, it's perfect
12:44:34 <lifter> Cale: I see, good point
12:44:54 <EvanR> :t iterate
12:44:55 <lambdabot> (a -> a) -> a -> [a]
12:45:26 <lifter> I don't know that function either
12:45:54 <EvanR> its the more basic version of unfoldr
12:46:19 <lifter> just looked it up, interesting
12:46:21 <EvanR> @src unfoldr
12:46:21 <lambdabot> unfoldr f b = case f b of
12:46:21 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
12:46:21 <lambdabot>    Nothing        -> []
12:46:56 <homovitruvius> has the source code for the Real World Haskell _site_ been published somewhere? alternatively, does somebody knows what framework it is based on? I'd like to publish a few tutorials and I'd like to have users commenting on each paragraph
12:46:59 <lifter> why not b' instead of new_b ?
12:47:38 <EvanR> blame the guy who write @src
12:47:47 <lifter> ok :)
12:48:33 <luisgabriel> hi there, I'm doing some experiments with the GHC time profiler and I need to add a new field to the Cost Centre structures. my current code is not working and as I have no experience with the GHC internals, I'm having trouble to find the problem. the patch on GHC as well as the stack traces can be found here: https://gist.github.com/luisgabriel/39d51cf4d661c7e62e22  any help would be very nice ;)
12:53:12 <arjanb> luisgabriel: #ghc might be better place for such questions
12:53:31 <luisgabriel> arjanb: thanks
12:55:46 <trap_exit> f :: m a ;;;;; g :: a -> m b -> m b ..... is there an easy way to construct a "m b -> m b" ?
12:56:02 <trap_exit> inquiring minds want to know
12:56:16 <geekosaur> huh?
12:56:29 <geekosaur> (ignoring id :: m b -> m b)
12:56:32 <trap_exit> f :: m a ;;;;; g :: a -> m b -> m b ..... is there an easy way to construct a "m b -> m b" ?
12:56:42 <geekosaur> yes, it's no clearer on the second repetition
12:56:59 <trap_exit> magic p = do a <- f; ans <- g a p; return ans
12:57:08 <trap_exit> magic p = do a <- f; ans <- g a p; return ans <-- is there a short3er way to write this?
12:57:19 <trap_exit> f :: m a ;;;;; g :: a -> m b -> m b ..... is there an easy way to construct a "m b -> m b" ? /// third time is the charm
12:58:38 <monochrom> @type \f g p -> do { a<-f; ans <- g a p; return ans }
12:58:38 <lambdabot> Monad m => m t -> (t -> t1 -> m b) -> t1 -> m b
12:58:47 <EvanR> @undo do {a <- f; ans <- g a p; return ans;}
12:58:48 <lambdabot> f >>= \ a -> g a p >>= \ ans -> return ans
12:59:01 <benzrf> ....
12:59:04 <benzrf> just g a p
12:59:16 <benzrf> (>>= flip g p)
12:59:23 <monochrom> @type \f g p -> do { a<-f; g a p }
12:59:24 <lambdabot> Monad m => m t -> (t -> t1 -> m b) -> t1 -> m b
12:59:34 <ReinH> Cale: damn, I can't find any #haskell-overflow logs.
12:59:44 <EvanR> (flip g p) <=< f
12:59:48 <monochrom> that still does not have the desired type
12:59:59 <EvanR> flip g p <=< f
12:59:59 <benzrf> EvanR: f is not a fungshun
13:00:03 <Cale> ReinH: hm. I can probably dig one up for you, just a sec, asking a question in #nvidia
13:00:07 <EvanR> oops
13:00:31 <monochrom> which means you now have to make a choice. either "magic p = do a <- f; ans <- g a p; return ans <-- is there a short3er way to write this?", or "f :: m a ;;;;; g :: a -> m b -> m b ..... is there an easy way to construct a "m b -> m b" ?". they are different. you cannot have both.
13:01:08 <monochrom> inquiring minds do not ask two different questions and call them equivalent.
13:01:11 <geekosaur> yes, that's what has been throwing me
13:02:08 * monochrom really doesn't like people who invoke "inquiring minds". from experience they all turn out to be misguided or not ready for the answers.
13:02:33 * monochrom 's antidote to "inquiring minds want to know" is "if you have to ask, you are not ready to know"
13:02:49 * geekosaur just deliberately conflates that with the tagline of the national enquirer >.>
13:03:54 <EvanR> dang i just want an svg viewer that i can trigger a refresh of the file with a signal
13:04:05 <EvanR> so complete my ad-hoc svg haskell ide
13:04:42 <mzabani> Hi everyone, I've been trying to make my binary tree implementation an instance of Arbitrary for testing with quickcheck, but I'm having some difficulty with a "Expected a type, but ‘Arbitrary (BT.Bintree a)’ has kind ‘Constraint’" error. Any kind soul willing to help a haskell noob?
13:05:46 <geekosaur> http://superuser.com/questions/174522/command-line-svg-and-image-file-viewer-in-linux ?
13:05:50 <geekosaur> (EvanR)
13:05:56 <benzrf> mzabani: you're putting "Arbitrary (BT.Bintree a)" in the wrong place
13:06:01 <geekosaur> oh, refresh on signal, not auto refresh
13:06:12 <benzrf> mzabani: what's your instance head
13:06:20 <EvanR> geekosaur: right.. im on osx
13:06:29 <geekosaur> oh, yes, that matters
13:06:36 <shachaf> mzabani: You'll have better luck if you post your full code and full error message.
13:06:46 <shachaf> mzabani: This way you're just asking people to guess what's wrong.
13:06:53 <geekosaur> on the other hand you can probably wrap any viewer in a shell script that uses "trap" to act on a signal...
13:07:09 <EvanR> if i have to kill and restart a viewer, itll mess up my focus
13:07:12 <mzabani> oh yes, I'll paste it, just give me a sec
13:07:24 <EvanR> im trying to trigger a chrome tab to refresh now
13:08:28 <lpaste> mzabani pasted “Binary Tree instance of Arbitrary” at http://lpaste.net/118637
13:09:32 <mzabani> the binary tree implementation is not showing, but I don't think it's important. If you'd like to see it please do tell me
13:09:33 * hackagebot table-tennis 0.1.0.0 - A table tennis game tracking engine  http://hackage.haskell.org/package/table-tennis-0.1.0.0 (thelollies)
13:10:29 <ReinH> Cale: No problem, take your time.
13:10:36 <lpaste> mzabani pasted “Error message” at http://lpaste.net/118638
13:11:07 <mzabani> and that is the compilation error message
13:11:33 <monochrom> oh I guess I was wrong. "Monad m => m t -> (t -> t1 -> m b) -> t1 -> m b" can be specialized, by t1 = m b, to "Monad m => m t -> (t -> mb -> m b) -> mb -> m b". so the two questions were equivalent.
13:13:13 <mzabani> if anyone could shed a light, I'd be tremendously thankful
13:14:33 * hackagebot table-tennis 0.1.0.1 - A table tennis game tracking engine  http://hackage.haskell.org/package/table-tennis-0.1.0.1 (thelollies)
13:14:35 * hackagebot table-tennis 0.1.0.2 - A table tennis game tracking engine  http://hackage.haskell.org/package/table-tennis-0.1.0.2 (thelollies)
13:14:55 <geekosaur> mzabani, you're trying to use Arbitrary as a type
13:17:19 <mzabani> oh gosh, at arbImpl?
13:17:22 <geekosaur> perhaps you wanted Arbitrary (BT.BinTree a) to be Gen (BT.BinTree a)
13:18:22 <mzabani> do you mean at the Instance declaration?
13:18:38 <geekosaur> the type of arbImpl
13:18:56 <mzabani> oh, ok, yes, you're right, it should return Gen (BT.Bintree a)
13:19:18 <mzabani> but the compiler still gives me an error after that
13:19:38 <nitrix> Hi, little question. I realised I have many `newtype` in my programs and I often need to unwrap the value unsing some runType, is this idiomatic of Haskell?
13:19:43 <mzabani> I tried commenting out the type of arbImpl so that it would be inferred, but it also gives me an error
13:20:02 <geekosaur> yes, I dont expect that is sufficient, at a guess since Gen is a monad you need to `return` the result
13:20:08 <geekosaur> to lift it into the Gen monad
13:20:37 <geekosaur> mm, type is actually still wrong after that since it's a list not a BinTree like you declared
13:20:49 <benzrf> nitrix: it can be
13:21:15 <mzabani> geekosaur: I can't see that, where is it?
13:21:17 * geekosaur not QuickCheck expert, just knows the types here are obviously wrong...
13:21:33 <EvanR> making it so you have to wrap and unwrap can keep you from using the wrong thing in the wrong place, if it other wise would have type checked
13:21:40 <geekosaur> oh, I missed call to elements, just saw the list passed to it
13:21:52 <EvanR> but if thats not the case you can make your operations work on the newtype instead
13:22:08 <nitrix> EvanR: Yeah, as annoying as it is, it ensures it's actually a BlockId, and not just some String.
13:22:11 <EvanR> or dont use a newtype
13:22:28 <nitrix> EvanR: I see, nah this is exactly what I want then.
13:22:50 <nitrix> Second question, is there a convention for two records that'd have similar members?
13:22:54 <geekosaur> looking also at original code I am back to pasisng through `return` assuming `elements` takes a list and produces a BinTree
13:23:11 <geekosaur> return $ elements $ ...
13:23:28 <mzabani> elements :: [a] -> Gen a
13:23:34 <nitrix> EvanR: data Resource = Resource { providerId :: ProviderId, blockId :: BlockId }
13:23:50 <mzabani> does it need a return as well?
13:23:59 <nitrix> EvanR: And then, what if I have another record with a blockId? Any convention or suggestions/tips?
13:24:09 <geekosaur> elements doesn't need the return. no, but I'm not sure you're providing it the right thing
13:24:10 <EvanR> put it in another module
13:24:25 <nitrix> That's already the case.
13:24:29 <EvanR> then no problem?
13:24:31 <nitrix> EvanR: Oh, and import it qualified?
13:24:36 <EvanR> thats the only way
13:25:00 <nitrix> Interesting.
13:25:09 <nitrix> EvanR: Very appreciated.
13:25:14 <mzabani> geekosaur: both BT.addLeftChild and BT.addRightChild are (Eq a) => a -> Bintree a -> a -> Bintree a
13:25:22 <EvanR> some libraries avoid using the same name for different fields in different records
13:25:31 <EvanR> then you dont have to qualify
13:25:38 <mzabani> so I think the list passed to elements should be a list of Bintree a
13:25:59 <geekosaur> so, wjat is the error message if you use Gen instead of Arbitrary in the signature for arbImpl?
13:26:15 <nitrix> EvanR: How would you name the variations, in their case?
13:26:24 <mzabani> let me paste it, hold on
13:26:29 <EvanR> resource'blockId foo'blockId maybe
13:26:39 <geekosaur> (actually I am now suspecting you wanted the Arbitrary (BT.BinTree a) in the context along with Arbitrary a and Eq a, and not the result type)
13:26:44 <lpaste> mzabani pasted “Error message 2” at http://lpaste.net/118640
13:27:17 <mzabani> geekosaur: I'm very new to Haskell, so feel free to assume I might be making some very stupid mistakes here :)
13:27:32 <eriksensei> nitrix: you might consider using lens http://stackoverflow.com/questions/17478599/name-conflicts-in-haskell-records
13:27:37 <geekosaur> oh, that error message implies you have a tree of trees of a where you just want a tree of a
13:28:01 <mzabani> but I've been looking for that and I just can't find it
13:28:30 <mzabani> unless "v" is getting bound to Bintree a
13:28:58 <geekosaur> line 20 does say v :: BT.Bintree t0
13:29:19 <mzabani> gosh.. but why?
13:30:37 <geekosaur> what is the type of addLeftChild?
13:31:09 <mzabani> both BT.addLeftChild and BT.addRightChild are (Eq a) => a -> Bintree a -> a -> Bintree a
13:34:36 <geekosaur> hm actually both tree and v have an extra Bintree
13:35:09 <mzabani> I've been trying to use (arbitrary :: Gen a) instead of just arbitrary but it's not working too well..
13:36:08 <geekosaur> not without scoped type variables extension it won't...
13:36:52 * geekosaur is not seeing it either, but is rather short on sleep and not braining well :(
13:37:53 <mzabani> geekosaur: I had no clue that was an extension! and don't worry about it, you're helping me a lot already
13:38:24 <mzabani> is it possible that ghc does not infer types correctly even if it is possible to do so?
13:39:11 <geekosaur> it is possible, and even likely, that a non-obvious type error in a distant place will cause type inference to produce surprises
13:39:51 <geekosaur> but I am not seeing off the top of my head where, if at all, this is happening
13:40:51 <mzabani> hmm, I'll try to write these lambdas as functions with type definitions
13:40:52 <geekosaur> suually it turns out that ghc is cleverer than you are and saw something that you did not think of...
13:41:23 <mzabani> you're right, and if that's the case, these separate functions might be of great help
13:41:30 <geekosaur> (this is part of why we dislike creating Num instances for random types, because it's just inviting ghc to apply it during defaulting in ways you never considered...)
13:41:38 <geekosaur> (as an example)
13:42:00 <chaosmasttter> mzabani: can you paste the Bintree module?
13:42:14 <mzabani> chaosmasttter:sure!
13:42:46 <lpaste> mzabani pasted “Bintree Module” at http://lpaste.net/118641
13:42:54 <mzabani> there it is
13:50:12 <chaosmasttter> mzabani: your error comes from a mistake in nodesWithout(Right/Left)Child
13:50:22 <mzabani> hmm really?
13:50:39 <mzabani> what is it?
13:51:37 <mzabani> oh gosh.. I see it
13:51:47 <mzabani> it's in the call to canHave(Left/Right)Child
13:52:35 <mzabani> it compiled!
13:52:46 <mzabani> geekosaur and chaosmasttter, thanks a lot
13:52:58 <mzabani> I guess I'll write type annotations more often lol
13:53:10 <geekosaur> always a wise idea :p
13:53:18 <chaosmasttter> you should defenitly do that
13:53:49 <mzabani> and type inference can really take the error far away from the source, can't it?
13:57:29 <chaosmasttter> it will take it as far as it can :p
13:59:33 * hackagebot table-tennis 0.1.0.3 - A table tennis game tracking engine  http://hackage.haskell.org/package/table-tennis-0.1.0.3 (thelollies)
14:02:47 <k3DW> Could someone tell me what's wrong with my code here? http://lpaste.net/5976107217521213440
14:03:18 <trap_exit> EvanR: tell me more about this haskell svg ide of yours
14:03:24 <k3DW> I'm getting an error that I don't understand
14:03:29 <k3DW> svg ide?
14:04:20 <EvanR> trap_exit: uh, the file monitor waits until i hit :w on the source file, recompiles the program, runs the program to regenerate an svg, then runs an apple script to refresh the current tab of chrome
14:04:44 <EvanR> IDE
14:04:47 <k3DW> Oh that wasn't directed at me :P
14:04:58 <J_Arcane> k3DW: Well, I'm not much of a math wonk, but that seems like an awfully overdeveloped way to do that to me; is there a reason you're doing it with math instead of just converting the digits to a list?
14:05:16 <k3DW> To be honest, I didn't even know it was possible
14:05:31 <k3DW> I'm new to this language, but I know how to do things with math
14:06:02 <EvanR> trap_exit: actually, if i modify it slightly, i can make it refresh the other chrome window with ghc errors, if any
14:06:12 <J_Arcane> > (\x -> read x :: Integer) . reverse $ show 1234
14:06:14 <lambdabot>  4321
14:06:18 <trap_exit> evanR: can yhou put a youtube vide of this?
14:06:21 <Cale> k3DW: What's going on?
14:06:25 <EvanR> i was thinking about it, if it works out
14:06:42 <Cale> k3DW: You didn't post the error. I guess I can run your code...
14:06:55 <bergey> k3dw: Can you paste the error also?
14:07:15 <bergey> (Oh, Cale beat me to asking.)
14:07:33 <Lokathor> "do return" is the same as "return", right?
14:07:42 <Cale> Lokathor: do { x } = x
14:07:56 <Lokathor> okay i thought so
14:08:37 <k3DW> Oh sure, I'll post the error
14:08:58 <dmwit> > (read . reverse . show :: Integer -> Integer) 123
14:08:59 <lambdabot>  321
14:09:25 <dmwit> Not really relevant to your question, but that's probably the idiomatic way to do this.
14:09:27 <k3DW> Oh wow, so there's a much better way to do it xD
14:09:39 <k3DW> I guess I won't post the error then
14:09:43 <dmwit> no no
14:09:43 <J_Arcane> :)
14:09:45 <k3DW> What does the dot do?
14:09:52 <dmwit> I think it's totally worth figuring out what's wrong with your current approach.
14:09:53 <J_Arcane> It's the compose operator.
14:10:01 <dmwit> Learning exercises are the way to learn.
14:10:06 <dmwit> ?src (.)
14:10:06 <lambdabot> (f . g) x = f (g x)
14:10:10 <lpaste> k3DW pasted “Reversal of an Integer Error” at http://lpaste.net/3405507623724777472
14:10:14 <dmwit> Function composition, just like in math.
14:10:25 <k3DW> ooh
14:10:35 <J_Arcane> Also, don't sell yourself short: I literally don't even know how to do that mathematically; from some perspectives doing it with a list is kinda cheating. ;)
14:10:36 <k3DW> Error: http://lpaste.net/3405507623724777472
14:11:01 <k3DW> I do know how to do it mathematically, but Haskell isn't cooperating ;)
14:11:11 <k3DW> Plus I just don't know how to use the language too well yet
14:11:26 <k3DW> So what do the "read" and "show" functions do?
14:11:31 <dmwit> > show 123
14:11:32 <lambdabot>  "123"
14:11:39 <dmwit> > ['1', '2', '3']
14:11:40 <lambdabot>  "123"
14:11:41 <k3DW> oh, it converts to a string?
14:11:57 <exio> @type show
14:11:58 <lambdabot> Show a => a -> String
14:12:12 <reem> > (read "123" :: Integer) + 17
14:12:14 <lambdabot>  140
14:12:20 <k3DW> Wait, you can post code into this chat?
14:12:23 <reem> and read does the opposite
14:12:36 <dmwit> k3DW: One line at a time.
14:12:42 <dmwit> k3DW: So not suitable for something like your paste.
14:13:36 <k3DW> Ahh ok
14:14:01 <dmwit> k3DW: (^^) doesn't really work for integers.
14:14:23 <dmwit> And when I change it to (^), it says you're trying to use a negative exponent, which probably is a bug (?).
14:14:38 <k3DW> No, I am using a negative exponent
14:14:43 <k3DW> That's why I'm using ^^
14:15:04 <k3DW> I promise you it mathematically works ;)
14:15:20 <dmwit> Okay. Well, as far as I know, there aren't any types that instantiate both Integral (which you demand by using quot) and Fractional (which you demand by using (^^)).
14:15:39 <k3DW> Hmm I see
14:15:44 <dmwit> However, you could use the fractional version of quot, perhaps, and a suitable Fractional instance.
14:15:47 <dmwit> :t fmod
14:15:48 <lambdabot>     Not in scope: ‘fmod’
14:15:48 <lambdabot>     Perhaps you meant ‘mod’ (imported from Prelude)
14:16:12 <k3DW> I think I can just use what you posted above with the 3 functions separated by dots
14:16:19 <k3DW> But let me ask a question about it
14:16:31 <dmwit> :t mod'
14:16:32 <lambdabot> Real a => a -> a -> a
14:17:07 <k3DW> When you do this: (read . reverse . show :: Integer -> Integer), does the :: apply for all 3 functions before it? Or just to *show*?
14:17:23 <dmwit> It parses as ((f . g . h) :: t)
14:17:28 <alpounet> all 3
14:17:35 <k3DW> Oh ok, cool
14:18:00 <dmwit> In a future GHC, I would write (read @Integer . reverse . show @Integer) instead. =)
14:18:41 <k3DW> And why is it important to specify that it's an Integer? I know that it's important since my code gives me a "Prelude.read: no parse" without it
14:18:52 <k3DW> But why?
14:19:01 <dmwit> Well, read is return-type polymorphic.
14:19:10 <dmwit> It has many implementations for many different types.
14:19:12 <dmwit> > read "()" :: ()
14:19:13 <lambdabot>  ()
14:19:17 <dmwit> > read "123.456" :: Double
14:19:18 <lambdabot>  123.456
14:19:25 <dmwit> > read "Left 32" :: Either Integer String
14:19:26 <lambdabot>  Left 32
14:19:28 <dmwit> and so on
14:19:38 <dmwit> So you have to tell it which type it's trying to parse a value for.
14:19:45 <dmwit> > read "()" :: Integer -- obviously doesn't work
14:19:46 <lambdabot>  *Exception: Prelude.read: no parse
14:19:48 <k3DW> Ahh ok
14:19:52 <Hijiri> > _1 (\n -> [n..n*n]) (5,6,7)
14:19:54 <lambdabot>  [(5,6,7),(6,6,7),(7,6,7),(8,6,7),(9,6,7),(10,6,7),(11,6,7),(12,6,7),(13,6,7)...
14:19:56 <dmwit> > read "123" :: () -- and this one, which is what happened to you
14:19:57 <lambdabot>  *Exception: Prelude.read: no parse
14:20:49 <k3DW> That's what I love about this language: I just spent an hour creating a convoluted mathematical expression for something that can be implemented in 1 line
14:20:54 <pyon> Is there any function for testing whether two lists are a permutation of one another, when their common element type is only bounded by Eq (not Ord)?
14:20:54 <k3DW> Very elegant language
14:21:41 <dmwit> pyon: Yes, there's a Hackage package for that, one moment.
14:21:48 <dmwit> well, and
14:21:50 <dmwit> :t (\\)
14:21:51 <lambdabot> Eq a => [a] -> [a] -> [a]
14:22:01 <dmwit> which is notionally bag subtraction
14:22:20 <pyon> dmwit: Ah, makes sense, a quotient set! Thanks! :-)
14:23:00 <EvanR> > [1, 1, 1, 2, 2, 3] \\ [1, 2, 3]
14:23:02 <lambdabot>  [1,1,2]
14:23:05 <dmwit> Oops, the Hackage package I was thinking of requires Ord, too. Sorry.
14:23:07 <halvorg> Hm, how do I get one element from a set?
14:23:14 <halvorg> doesnt have to be head, any element will do
14:23:15 <pyon> EvanR: Okay, a quotient multiset!
14:23:21 <dmwit> halvorg: toList
14:23:22 <EvanR> bag
14:23:28 <pyon> Ah!
14:23:46 <dmwit> pyon: Dunno why you say "quotient" there.
14:23:53 <halvorg> dmwit: that'll convert the whole set to a list just so I can get an element ye?
14:24:04 <dmwit> halvorg: Yep. But laziness, so no big deal.
14:24:11 <halvorg> or does haskell understand that it doesnt have to convert it all?
14:24:13 <halvorg> cool , thanks
14:24:14 <pyon> dmwit: Oh, difference was it, then?
14:24:25 * pyon keeps messing up terms, should probably say nothing.
14:24:48 <dmwit> pyon: It's list difference. Which is closely related to set/bag difference, but not identical, because there's this extra structure you can observe.
14:24:55 <dmwit> ?src (\\)
14:24:55 <lambdabot> (\\) = foldl (flip delete)
14:25:01 <dmwit> ?src deleteBy
14:25:01 <lambdabot> deleteBy eq x []     = []
14:25:01 <lambdabot> deleteBy eq x (y:ys) = if x `eq` y then ys else y : deleteBy eq x ys
14:28:35 <dmwit> ?quickCheck let eqEq xs ys = null (xs \\ ys) && null (ys \\ xs) in \xs ys -> eqEq xs ys == (sort xs == sort ys) :: [Word8] -> [Word8] -> Bool
14:28:36 <lambdabot> Unknown command, try @list
14:28:42 <dmwit> ?check let eqEq xs ys = null (xs \\ ys) && null (ys \\ xs) in \xs ys -> eqEq xs ys == (sort xs == sort ys) :: [Word8] -> [Word8] -> Bool
14:28:44 <lambdabot>  Couldn't match expected type ‘[GHC.Word.Word8]
14:28:44 <lambdabot>  -> [GHC.Word.Word8] -> GHC.Types.Bool’ with actual type ‘GHC.Types.Bool’
14:29:13 <dmwit> oh, right
14:29:26 <dmwit> ?check let eqEq xs ys = null (xs \\ ys) && null (ys \\ xs) in \xs ys -> eqEq (xs :: [Word8]) ys == (sort xs == sort ys)
14:29:27 <lambdabot>  +++ OK, passed 100 tests.
14:29:41 <dmwit> pyon: There you go. =)
14:29:48 <Hijiri> ?check (== (5 :: Int))
14:29:49 <lambdabot>  *** Failed! Falsifiable (after 1 test):
14:29:50 <lambdabot>  0
14:30:06 <Hijiri> ?check (/= (10001 :: Int))
14:30:07 <lambdabot>  +++ OK, passed 100 tests.
14:30:20 <dmwit> Yep, a shortcoming of random testing. Gotta have enough random tests. =)
14:30:41 <dmwit> ?smallcheck (/= (10001 :: Word16))
14:30:42 <lambdabot> Unknown command, try @list
14:30:52 <dmwit> Oh, is smallcheck not in there any more?
14:31:46 <tasker> Have people used docker with haskell much? Could anyone point me towards some workflows using it?
14:32:20 <dmwit> Googling "docker haskell" seems to turn up a lot of promising hits.
14:32:26 <dmwit> Do you have a more specific question...?
14:32:53 <tasker> The stuff i have found seems to be more focused on deployment of e.g. snap
14:33:07 <tasker> I'm interested in doing more interactive development on a remote server
14:33:12 <tasker> er. if that makes sense
14:38:04 <wolftune> I had a funny GHC error http://dpaste.com/1FHSC97
14:38:15 <wolftune> anyone help me make sense of this?
14:38:57 <Cale> wolftune: I'll have a look
14:39:02 <dmwit> Looks pretty readable to me. File a bug and do something else. =P
14:39:20 <Cale> heh
14:40:20 <Cale> wolftune: What program are you trying to build, and which platform is this?
14:40:39 <Cale> oh, linux 64 :)
14:41:08 <wolftune> Cale: yes, and it's a test-version of a Yesod site
14:41:43 <Cale> Are you using -split-objs ? Maybe try without?
14:41:46 <wolftune> one that builds before but now trying to build with nix package manager (testing someone else's refactoring)
14:42:03 <wolftune> Cale: the command I ran was cabal configure -f dev --enable-tests && cabal build -j5
14:43:12 <Cale> What does the .cabal file look like?
14:43:39 <ReinH> Cale: well, the exposition is pretty easy, so I'm not sure you need to worry :)
14:44:21 <Cale> ReinH: Oh, right, I can look for that for you now if you like, but yeah, it's pretty much what you'd expect. Sometimes I explain State just before Parser
14:44:40 <ReinH> Yeah, I'm going to target this at "people who have used monads". :)
14:44:53 <ReinH> So I can just say "Oh look, that's the State monad"
14:45:22 <ReinH> The hard part is the writing, not the understanding ;)
14:49:21 <wolftune> Cale: what do you want to know about the .cabal file?
14:50:03 <Cale> wolftune: specifically whether the string -split-objs occurs anywhere in it
14:50:11 <wolftune> ah
14:50:35 <EvanR> hmm. what is diagrams font support
14:51:05 <wolftune> Cale: nope
14:52:34 <seagreen> I'm looking for `Vector (a -> Bool) -> a -> Bool`. Anyone got suggestions on how to attack this?
14:53:00 <indiagreen> what exact behavior do you want?
14:53:01 <tapuu> that looks like <*>
14:53:16 <tapuu> no wait
14:53:38 <seagreen> I'm looking to check if any of the `(a -> b)`s come out true.
14:53:47 <indiagreen> ah, so “or” for vectors
14:54:03 <indiagreen> well, not exactly
14:54:08 <indiagreen> but you can do it with a fold
14:54:23 <Cale> or :: Vector Bool -> Bool
14:54:29 <Cale> any :: (a -> Bool) -> Vector a -> Bool
14:54:36 <bergey> EvanR: It's pretty dependent on the particular Backend.
14:54:37 <seagreen> Sweet, thanks!
14:54:39 <Cale> any ($ x)
14:55:34 <bergey> Some output formats (PNG) pick from fonts when you write the image, some (SVG, HTML Canvas) load fonts at view time.
14:55:44 <tapuu> I remember seeing a project which was a sort of wrapper around cabal written in bash, but I can't find it anymore
14:56:07 <bergey> Backends also differ in their ability to find out the text size for positioning.
14:56:15 <tapuu> does anyone know what I'm talking about?
14:56:15 <bergey> What are you trying to do?
14:56:39 <Cale> :t Data.Vector.any
14:56:39 <Cale> (is this in scope?)
14:56:40 <Cale> ... am I still connected to the IRC server?
14:56:40 <lambdabot> (a -> Bool) -> Data.Vector.Vector a -> Bool
14:57:35 <EvanR> bergey: looks like cairo should work best
14:58:11 <bergey> cairo has the most complete text support.  The downside is the added difficulty of installing it, if you're not on Linux.
14:58:14 <Cale> Wow, I have an 80 second ping time.
14:58:33 <EvanR> brew install cairo
14:58:37 <EvanR> ERROR: already installed
14:58:38 <EvanR> k
14:59:29 <ReinH> Cale: "Our goal is to show that Parser' is secretly a monad transformer… in disguise."
14:59:34 * hackagebot interchangeable 0.0.0.1 - A type class for interchangeable data.  http://hackage.haskell.org/package/interchangeable-0.0.0.1 (arowM)
15:00:25 <bergey> EvanR: OK, then, great.
15:02:05 <tapuu> why is the haskell wiki so slow?
15:02:53 <Cale> ReinH: There's also an admirable goal in there of understanding the implementation of a parser library. It's almost more like StateT falls out as a nice side product of that.
15:03:04 <dmwit> tapuu: http://www.reddit.com/r/haskell/comments/2siokx/haskellorg_takes_forever_to_load_anybody_else/cnq0493
15:03:12 <Cale> Because once you've written down how Parser works, it's almost zero work to extract StateT
15:03:25 <Cale> You don't even have to change the implementation of return and (>>=)
15:03:31 <Cale> Just the definition of the type :)
15:04:01 <Cale> Of course, you also need to implement get and put, which is something.
15:04:15 <Cale> (they're somewhat unnatural operations from the Parser side of things)
15:04:34 * hackagebot pretty 1.1.2.1 - Pretty-printing library  http://hackage.haskell.org/package/pretty-1.1.2.1 (DavidTerei)
15:04:36 * hackagebot cartel 0.12.0.0 - Specify Cabal files in Haskell  http://hackage.haskell.org/package/cartel-0.12.0.0 (OmariNorman)
15:05:01 <tapuu> dmwit: ah, thanks
15:06:37 <tapuu> the new haskell site looks amazing
15:09:45 <mhl> I have some problem with updgrading cabal-install. My current cabal version is 1.16.0.2, and I want to update to 1.22.0. However when I do cabal install cabal-install, I'm left with old 1.16.0.2 version.
15:09:56 <Cale> tapuu: wait, what?
15:10:15 <mpickering> mhl, I imagine ~/.cabal/bin isn't in your path
15:10:24 <mpickering> what does "which cabal" give you?
15:10:33 <alpounet> mhl: probably because the newer one got installed somewhere that's not in your PATH env variable, or somewhere that comes after where the older one is
15:11:00 <mhl> ah, ok
15:11:21 <mpickering> tapuu: halycon?
15:11:43 <geekosaur> or because the shell cached the location of the old one; "hash -r" resets the cache
15:11:51 <mhl> Now I see, that never cabal is installed in ~/.cabal/bin. My old cabal path is still /usr/bin/cabal
15:12:09 <mhl> newer*
15:12:11 <mpickering> I had that problem as well when I first installed cabal
15:12:42 <alpounet> Cale: I suppose tapuu is talking about https://new-www.haskell.org/
15:14:36 <tapuu> mpickering: yes, that was it, thanks!
15:14:58 <tapuu> Cale: what alpounet said
15:16:50 <horny-sama> anyone here familiar with the ide leksah?
15:17:13 <EvanR> heh. the FSNotify example does not function on osx... it fails with the errors message select: invalid argument :(
15:17:28 <EvanR> tried various filepaths variations
15:19:34 * hackagebot interchangeable 0.0.1.0 - A type class for interchangeable data.  http://hackage.haskell.org/package/interchangeable-0.0.1.0 (arowM)
15:20:05 <Cale> tapuu: It's doing a little better than it was before, they've at least gotten rid of most of the marketing-speak. I'm still not 100% sold on the layout, and there's a lot less content there than on the old version.
15:22:32 <ReinH> Cale: yeah, but Stephen Diehl is already handling that admirably. I just wanted to write a quick note about Parser and StateT :)
15:23:00 <EvanR> seems to be caused by this bug in ghc https://ghc.haskell.org/trac/ghc/ticket/6019
15:23:41 <EvanR> except it was supposedly closed two years ago
15:23:52 <horny-sama> any good book for learning haskell?
15:24:04 <horny-sama> from basic ide setup to programming in haskell?
15:25:54 <EvanR> changing the threadDelay maxBound to something less fixed it, but then i find that the events arent being mapped sanely..
15:27:48 <Axman6> horny-sama: a decent programmer's text editor is all you really need (Sublime Text, Emacs, Vim, Notepad++ even)
15:28:06 <horny-sama> Axman6: what the fuck do you debug then?
15:28:18 <Axman6> ghci...
15:29:05 <Axman6> you can use ghci embedded in most editors
15:29:24 <Axman6> personally I prefer to debug my code, not my IDE
15:29:43 <indiagreen> ghci, QuickCheck, and, well inserting “trace” in places, not without that
15:29:53 <dfeuer> Why does an unboxed Vector Bool only store one Bool per Word8?
15:29:54 <Axman6> then to start learning see https://github.com/bitemyapp/learnhaskell
15:30:06 <Zekka> horny-sama: FYI, traditional step-by-step debugging is possible in Haskell but AFAIK it's a pretty hard strategy to use well
15:30:25 <Zekka> Haskell's nonstrictness means that seeing your code step-by-step is not very helpful
15:30:36 <EvanR> the easiest way to debug is to not (be able to) write bugs in the first place
15:30:41 <EvanR> ideally
15:30:45 <Zekka> I usually screw around with the repl and make sure I've noted cases where my types are potentially hiding bugs
15:30:48 <dfeuer> Couldn't it do bitty stuff and pack in 8 Bools per Word8 (or, more sanely, 32/64 per word)?
15:30:49 <horny-sama> EvanR: lol
15:31:01 <Zekka> i.e. when a list can never be empty but I'm not using a nonemptylist type
15:31:32 <EvanR> picking the right data types can really help
15:31:40 <horny-sama> as in book recommendation not lecture slides
15:31:41 <dfeuer> DATA TYPES.
15:31:45 <horny-sama> hate lecture slides
15:31:57 <Axman6> dfeuer: it could but that adds computational overhead
15:33:24 <Axman6> horny-sama: just start with https://github.com/bitemyapp/learnhaskell
15:33:49 <Axman6> and head to #haskell-beginners to ask questions
15:33:53 <dfeuer> Axman6, yes, but so does using Word8 instead of Word32. Doesn't improved cache performance cover it? Would it help to stripe things so adjacent Bools are in different words?
15:35:17 <Axman6> aliasing issues are less of a problem because the data is usually immutable
15:35:33 <dfeuer> Axman6, well, it's mutable in the code I happen to be looking at :P
15:36:36 <Axman6> one Bool per word 8 is a compromise between computational complexity and size I guess
15:36:40 <dfeuer> And if you're dealing with immutable code, it takes a maximum of one shift and one mask to extract a bit, and that does not seem like much compared to the advantage of packing 8 times as much into each word, but maybe I'm missing something.
15:36:42 <benzrf> horny-sama: do not fall for the traps laid for you by well-meaning recommendations of things besides https://github.com/bitemyapp/learnhaskell
15:36:48 <benzrf> horny-sama: https://github.com/bitemyapp/learnhaskell is the Way and the Light!!!!
15:37:17 <dfeuer> benzrf, Learn You A Haskell is pretty good too, IMO....
15:37:42 <Axman6> lyah is suggested by bitemyapp's guide
15:37:52 <benzrf> Axman6: only suplementally
15:38:08 <benzrf> dfeuer: you are what i am warning of :p
15:38:19 <dfeuer> benzrf, your warning is absurd.
15:38:26 <horny-sama> http://learnyouahaskell.com/chapters <---this seems like a good srouce
15:38:34 <benzrf> horny-sama: you fell in the trapppppppp
15:38:43 <dfeuer> It's a good trap though.
15:38:45 <horny-sama> Secondary material, references
15:38:46 <benzrf> it's not
15:38:49 <benzrf> hold up
15:38:50 <horny-sama> that's listed there
15:39:02 <dfeuer> You fall in, learn stuff, then climb back out again, ready for other stuff.
15:39:07 <dfeuer> I guess that's not much of a trap.
15:39:08 <Axman6> lyah isn't terrible, many people are very happy with iut
15:39:14 <Axman6> it*
15:39:16 <benzrf> mfw i have to explain this every day
15:39:27 <horny-sama> Axman6: then what do you recommend?
15:39:38 <dfeuer> benzrf, maybe you should write an essay on why learnhaskell is better than LYAH.
15:39:46 <Axman6> following bitemyapp's guide
15:39:50 <dfeuer> Post it on Reddit and the Haskell Wiki.
15:40:04 <Axman6> like ive now said three times =)
15:40:12 <benzrf> horny-sama, dfeuer, Axman6: have you ever acquired a complex board game or computer game, and read the explanation of the rules?
15:40:22 <dfeuer> Yes.
15:40:27 <Axman6> yep
15:40:29 <horny-sama> board game is so yesterday
15:40:34 <dfeuer> o.O
15:40:34 * horny-sama plays his checkers
15:40:36 <benzrf> horny-sama, dfeuer, Axman6: and none of them were incomprehensible, but you did not grasp the motivation of them all?
15:40:40 <ReinH> whatever, board games are awesome
15:40:41 <benzrf> or how they tie together?
15:40:49 <benzrf> or see the big picture of the game?
15:40:57 <benzrf> and have to keep scrambling around remembering little bits separately?
15:40:59 <benzrf> until you play it 20 times?
15:41:26 <dfeuer> benzrf, ah, yes, it is true that some things are covered less well than others. But the explanation of zippers really worked for me,
15:41:27 <Axman6> the fun of the game is figuring that out yourself, the same as programming
15:41:32 <benzrf> dfeuer: yes, zippers is fine
15:41:47 <benzrf> Axman6: yes, but LYAH does not /help you do it/
15:41:55 <benzrf> Axman6: or rather, it doesnt account for it
15:42:10 <benzrf> Axman6: CIS194 gives you exercises specifically designed to help you figure this stuff out
15:42:25 <EvanR> bluh, threadDelay maxBound basically is broken in ghc 7.8
15:42:34 <Axman6> many people have successfully used lyah to begin learning haskell and happily moved on to other resources
15:42:41 <benzrf> Axman6: yes, *I* did
15:43:03 <benzrf> Axman6: i still think it's a pretty subpar way to do it
15:43:18 <dfeuer> Speaking of figuring things out. Someone told me the other day that the magic trick implementing simply typed lambda calculus with GADTs doesn't work for anything with polymorphism. Is that really true? I was thinking about attempting to do it with (vanilla) System F.
15:43:20 <zwer> EvanR broken in what way?
15:43:21 <benzrf> it took me much longer to put all the pieces together than if i'd had something that helped guide me to do so
15:43:23 <horny-sama> I think I will skip the introduction of the book as usual!
15:43:29 <Axman6> which is why bitemyapp's guide isn't just "Read YAH; now you know Haskell"
15:43:35 <Axman6> LYAH*
15:43:38 <benzrf> Axman6: yes
15:43:39 <EvanR> zwer: https://ghc.haskell.org/trac/ghc/ticket/7325
15:44:15 <benzrf> Axman6: it's "do CIS194, using LYAH as a supplement to taste; when finished, complete the NICTA course; now you know enough haskell to get started working with things"
15:44:33 <Axman6> right
15:44:38 <dfeuer> *sigh*. I guess I'll have to do CIS194 now :-)
15:44:42 <horny-sama> I am learning haskell for skool
15:44:57 <horny-sama> I am planning to use haskell for my naughty cortana project :P
15:45:00 <zwer> EvanR thanks.
15:45:10 <dfeuer> It seems like most people learning Haskell for school have far less fun than I would imagine.
15:45:28 <dfeuer> I learned Scheme, SML, and (blech) pre-Generics Java for school.
15:46:58 <EvanR> zwer: forever $ threadDelay (2 ^ 20) is a work around
15:48:19 <horny-sama> LYAH is only 176 pages long, I think I finish it after dinner
15:48:20 <horny-sama> :P
15:48:21 <Axman6> EvanR: are you using that to stop main exiting?
15:48:29 <EvanR> yes
15:48:35 <Axman6> horny-sama: if you read it that quickly you will learn nothing
15:48:50 <horny-sama> Axman6: should I miss the book introduction?
15:48:59 <Axman6> probably not
15:49:03 <horny-sama> Axman6: I mean I have prior programming experience
15:49:06 <horny-sama> *skip
15:49:21 <Axman6> that won't help you with learning haskell
15:49:46 <horny-sama> Axman6: true haskell does not have loops :<
15:50:09 <Axman6> in fact, it's usually easier for people with little to no experience with programming to learning haskell because their brains aren't broken by thinking they know "how to program"
15:50:35 <EvanR> horny-sama: i wish it didnt
15:50:40 <EvanR> > let x = x in x
15:50:43 <Zekka> :t forM
15:50:44 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
15:50:44 <lambdabot>  mueval-core: Time limit exceeded
15:50:47 <Zekka> loops
15:50:54 <horny-sama> EvanR: why not?
15:50:55 <Axman6> writing Haskell is a completely different way of thinking to most other languages
15:51:02 <horny-sama> Axman6: true
15:51:12 <EvanR> horny-sama: because when your program freezes up and you get no indication of why, that sucks
15:51:12 <Zekka> (read above type as 'it's foreach with side effects')
15:51:14 <indiagreen> dfeuer: just a datapoint: I started learning Haskell by reading docs/src/* (and enjoying the process), but I wouldn't have enjoyed learning it at school
15:51:19 <horny-sama> I am starting from ground zero again :<
15:51:42 <dfeuer> indiagreen, *nod*
15:51:51 <simukis_> horny-sama: hey, your nick makes my day every day I see it! props!
15:52:05 <horny-sama> simukis_: you have seen me before?
15:52:28 <simukis_> horny-sama: I think I’ve seen you on #haskell multiple times already.
15:52:48 <horny-sama> simukis_: lol
15:52:59 <horny-sama> but I am not supposed to exist
15:53:03 <horny-sama> according to the gov :P
15:53:05 <horny-sama> j/k
15:53:29 <Zekka> horny-sama: Want to see a for loop?
15:53:48 <Axman6> np
15:53:50 <Axman6> no*
15:54:08 <horny-sama> Zekka: na, just goto statement
15:54:13 <horny-sama> to keep it looping
15:55:05 <Axman6> horny-sama: by the way, not reading CIS 194 because it's in the form of lecture slides is like not reading something because you don't like times new roman; it's completely illogical
15:56:05 <horny-sama> Axman6: I am not a fan of reading lecture slides
15:56:09 <Axman6> the fact it has homework problems makes it a vastly better resource than many. you can discuss your solutions with others in here of #haskell-beginners
15:56:11 <horny-sama> I prefer bookzzzz
15:56:30 <horny-sama> I am the guy who did not use k&r to learn C
15:56:31 <horny-sama> so...
15:56:35 <horny-sama> I am different
15:56:45 <indiagreen> were those lecture slides supposed to be accompanied by an actual lecture? if so, then it's not obviously illogical not to read something which you know to be incomplete
15:56:46 <Axman6> I'm not a fan of reading menus folded into thirds, but if I want to order food, I need to read the place's menu
15:57:06 <Axman6> I've never read K&R either, but I learned C just fine
15:57:14 <Axman6> at university in fact, using lectures D:
15:57:18 <fizruk> Axman6: like not reading SPJ's slides because of Comic Sans ;-P
15:57:27 <horny-sama> I never learn anything from lecture slides
15:57:38 <horny-sama> I just read the textbook or bookzzz
15:57:48 <Axman6> fizruk: exactly. his work always clear and usually pretty amazing
15:58:05 <Axman6> lecture slides are just books with different formatting...
15:58:25 <indiagreen> ...they aren't
15:59:19 <indiagreen> it's like saying that everyone who likes books should like audiobooks
15:59:36 <Axman6> it
15:59:45 <Axman6> it's the content that matters, not the medium
15:59:50 * fizruk thinks of LYAH audiobook...
16:03:19 <indiagreen> if you can't stand some particular medium enough, you should choose a different medium – even with worse content – instead of trying to painfully go thru it anyway. I agree that ideally medium *shouldn't* matter, but “shouldn't” ≠ “doesn't”
16:03:30 <Axman6> "Here, have this free Porche!" "I don't drive red cars, you can keep it"
16:03:36 <fizruk> Axman6: medium matters a lot. consider interactive ones (e.g. like tutorials/posts on fpcomplete)
16:05:20 <Axman6> but discounting one of the best resources available for learning a topic because of its medium is just madness imo.
16:05:36 <indiagreen> Axman6: if you gave me a free laptop running Windows (and said that I would have to use it), I wouldn't take it. Even if it “one of the best laptops”.
16:06:12 <indiagreen> and an OS is only a medium for using programs and doing work, right?
16:06:17 <Axman6> so you wouldn't find a solution to the problem then? you wouldn't install a VM and run your OS of choice?
16:06:32 <Axman6> that's not a very pragmatic attitude
16:06:44 <fizruk> Axman6: absense of a good medium questions your desire to actually learn that topic
16:06:52 <indiagreen> tha-at's stretching the analogy
16:07:01 <glguy> Everyone's pretty bored today, eh?
16:07:27 <MP2E> haha :) bored enough to paint bikesheds
16:07:35 <MP2E> or rather argue about the color *
16:07:40 <Axman6> sure, but adults usually have the ability to work with something that is less than ideal if the outcome is what's necessary
16:08:49 <indiagreen> adults also know that they aren't perfect rational agents and that such stupid things as choice of the medium can influence their mood and desire to learn
16:09:20 <fizruk> Axman6: sure, but I guess whoever started this was talking about learning haskell for fun (correct me, if I'm wrong)
16:09:33 <Rotaerk> is there a way to cause a GHC compiled executable not to automatically open a console window? e.g. for a graphical application
16:09:47 <indiagreen> Rotaerk: yes, there's some flag, hang on
16:10:07 <Rotaerk> was looking through the GHC flags and nothing jumped out at me
16:10:14 <indiagreen> -optl-mwindows
16:10:15 <Axman6> is that something that happens on windows? o.O
16:10:29 <MP2E> yeah
16:10:47 <MP2E> in C/C++ compilers you can set -mwindows to tell windows you don't want a console
16:10:57 <MP2E> I think there's a reverse too in case you want to specify that console is what you want
16:11:00 <MP2E> -wconsole perhaps?
16:11:06 <Rotaerk> indiagreen: thanks; where'd you find that? I don't see that in this flags list
16:11:19 <indiagreen> googled “ghc no console window”
16:11:27 <zwer> `editbin /subsystem:windows' works too
16:11:58 <zwer> (editbin ships with windows)
16:12:08 <Rotaerk> hrm, guess I picked the wrong keywords
16:12:35 <Welkin> you searched with google instead of bing
16:12:57 <Welkin> use yandex
16:13:14 <indiagreen> Yandex kinda sucks for programming-stuff
16:13:15 <MP2E> lol
16:13:39 <Welkin> supposedly, yahoo uses bing
16:13:41 <zwer> (no, sorry, it ships with VS)
16:15:33 <joness> is haskell community more tolerant to non-exhaustive pattern matches than ocaml community? if yes, why?
16:16:02 <SrPx> Please, nobody has a way to draw a circle in a 1024x1024 REPA image without mapping over every pixel of it? That is making things unbearably slow...
16:16:29 <SrPx> I just need to restrict it to testing a specific rectangle, not the whole image
16:17:14 <SrPx> that is, 1024x1024 image, 32x32 bounding box for the circle... no need to check if the other 1047552 pixels are inside the circle :(
16:17:22 <joness> (in ocaml compiler warns about non-exhaustive by default, in ghc you need a special flag to get the warning)
16:17:28 <joness> +pattern matches
16:19:23 <dfeuer> joness, you know how it goes. Haskell programmers are a bunch of slobs. We don't even care if our programs run.
16:19:34 <indiagreen> lies
16:19:39 <indiagreen> I run my programs occasionally
16:19:43 <indiagreen> just for the thrill
16:20:00 <dfeuer> joness, not only that, but GHC won't even warn about incomplete pattern matches in lambdas.
16:20:31 <pavonia> SrPx: Can't you randomly access your pixels or what is the problem with it?
16:20:56 <SrPx> pavonia: I couldn't find a way to set individual pixels on REPA, I guess there is none
16:21:20 <pavonia> What package is that?
16:21:27 <SrPx> regular parallel arrays
16:21:48 <SrPx> I could use unboxed mutable vectors but writing every function in term of ST is awful
16:23:16 <pavonia> I don't quite understand. Do you use immutable arrays?
16:25:29 <pavonia> Oh, I think I see the problem
16:30:55 <elben> Hi, I’m working with Aeson and trying to transform an Object’s values (e.g. any String “x” to String “y”). I know object is a HashMap, and I’m trying to use the functor instance. First of all, I don’t get what it means when I see the defintion “instance Functor (HashMap k)…” (where is the v?). Second, I’m trying to transform the value (example: http://lpaste.net/7936858671177269248), but not sure where I’m going wrong
16:32:02 <indiagreen> elben: “HashMap k” is a partially applied type; the same way there's no “a” in “instance Functor Maybe”
16:33:22 <indiagreen> then, your fmap-ed function takes 2 arguments, but it doesn't coincide with the type of fmap
16:33:24 <indiagreen> :t fmap
16:33:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:34:28 <indiagreen> finally, HashMap isn't a Value – you've unwrapped it from Object, but haven't wrapped back
16:35:23 <elben> Ah, got it
16:38:57 <elben> I wasn’t careful enough. Is it odd to unwrap then wrap values all the time? I’ve updated the code: http://lpaste.net/7936858671177269248
16:40:43 <Lokathor> pattern matching doesn't seem to be working for me >_>
16:41:19 <indiagreen> elben: do you want to change all values inside an object, no matter how deep? or only 1st-level?
16:41:46 <elben> indiagreen: all the way down. updated again with full implementation http://lpaste.net/7936858671177269248,
16:42:18 <indiagreen> well, your implementation is what I would've written
16:42:21 <elben> It seems that there should be a cleaner way, combining Array and Object implementation
16:42:40 <indiagreen> you *can* use generics to accomplish this, but it seems like it's too much
16:42:55 <indiagreen> look at uniplate library
16:43:05 <Lokathor> when I use show on a bytestring, it keeps " around the resulting string it seems...
16:44:03 <elben> indiagreen: OK, thanks. I’m satisfied with this, for now.
16:44:34 * hackagebot descriptive 0.1.0 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.1.0 (ChrisDone)
16:45:40 <geekosaur> Lokathor, yes, if you don't want that, don't use show
16:46:01 <geekosaur> show produces things that look vaguely like Haskell source, it is not a general pretty printer
16:46:02 <Lokathor> geekosaur: how else does one convert their ByteString into a String?
16:46:15 <Lokathor> do I use show and then strip them off manually?
16:46:24 <indiagreen> if it's UTF8-encoded, there's a function somewhere
16:46:29 <indiagreen> @hoogle decodeUtf8
16:46:30 <lambdabot> Data.Text.Encoding decodeUtf8 :: ByteString -> Text
16:46:30 <lambdabot> Data.Text.Lazy.Encoding decodeUtf8 :: ByteString -> Text
16:46:30 <lambdabot> Data.Text.Encoding decodeUtf8' :: ByteString -> Either UnicodeException Text
16:46:36 <indiagreen> hm
16:46:45 <geekosaur> no, since it does other translations as well. read . show could work but is bad. Char8.unpack perhaps
16:46:52 <reem> @hoogle ByteString -> String
16:46:53 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
16:46:53 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
16:46:53 <lambdabot> Data.ByteString.Char8 head :: ByteString -> Char
16:47:09 <indiagreen> http://hackage.haskell.org/package/utf8-string
16:47:37 <Lokathor> oh oh! I was looking at the Data.ByteString docs, not the Data.ByteString.Char8 docs
16:47:38 <Lokathor> oy
16:47:56 <geekosaur> Char8 is generally evil but works reliably for this specific case
16:48:15 <geekosaur> (since a ByteString can always be converted into a String; the reverse is not guaranteed)
16:48:27 <Lokathor> well the simpleirc package works with ByteString.Char8, so that's what i'm stuck with
16:49:24 <alpounet> Lokathor: you should decode to Text
16:49:34 * hackagebot descriptive 0.1.1 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.1.1 (ChrisDone)
16:49:43 <alpounet> see Data.Text.Encoding
16:50:13 <SrPx> I've compiled accelerate-examples, but it seems like there is no option to run it with cuda, regardless of having already installed it no problems on my machine. Why? http://lpaste.net/118653
16:51:07 <alpounet> Lokathor: Data.Text.Encoding.Error.lenientDecode as argument to Data.Text.Lazy.Encoding.decodeUtf8With works well for me
16:51:08 <chrisdone> Lokathor: you should be informed about the encoding decision. IRC does not specify an encoding, which is why the simpleirc correctly provides ByteString as the type
16:51:25 <Lokathor> alpounet: What's the advantage of Text over String?
16:51:44 <alpounet> it's faster and uses less memory
16:51:48 <chrisdone> so if you join a Hungarian channel and try to decode it as UTF-8 you will get encoding errors. if you then send that back it'll be garbled
16:52:05 <alpounet> String is really just for convenience
16:52:16 <Lokathor> mmmm
16:52:16 <alpounet> and works fine for short strings
16:52:28 <chrisdone> String is an unfortunate historical embarassment
16:52:43 <alpounet> yeah, this. couldn't have said it better
16:54:12 <Lokathor> Well, what I need in the end is, read lines of text said in channel, look for text in [ ], parse the section inside of [ ], spit back the entire phrase with the parsed sections replaced with the appropriate new text
16:54:33 <kazagistar> Its not even shorter then [Char]...
16:54:36 <chrisdone> if you're parsing then you might as well decode into a Text
16:54:55 <chrisdone> if someone wants to send a different encoding to your bot you can tell them off
16:55:49 <Lokathor> so Parsec works with Text... can't the decoder thing figure out the encoding on its own or something when decoding ByteString into a Text?
16:57:18 * chrisdone shrugs
16:57:59 <ReinH> figuring out what encoding a stream of bits is in is not at all an easy task
16:58:15 * Lokathor grumbles
16:58:38 <chrisdone> that's IRC for you
16:58:57 <Lokathor> I didn't even want to use IRC for this part of the project to begin with >_<
16:59:35 <alpounet> are you likely to encounter non-unicode text?
16:59:36 <chrisdone> alpounet's suggestion of lenient decoding is pretty good
17:00:02 <reem> What's the representation of Text?
17:00:04 <fread2282> is there a video of Type checking in the presence of meta-variables (reprise)?
17:01:24 <alpounet> reem: it uses a ByteArray# internally
17:01:34 <chrisdone> internally it's a vector of Word16's
17:02:12 <Lokathor> alpounet: I mostly need to process things in the ASCII range... in terms of how that'll get sent to me, i guess that's based on the clients who send text tothe channel?
17:02:24 <alpounet> yeah
17:02:46 <reem> alpounet: Does that mean it makes a full copy on modifications?
17:02:49 <EvanR> mostly?
17:02:57 <chrisdone> i thought most people were on UTF-8 until i wrote an IRC server that assumes UTF-8 Text and a hungarian friend connected with X-Chat and it caused decoding errors
17:03:05 <EvanR> reem: there are not modifications, its immutable
17:03:26 <reem> EvanR: There's no Text -> Char -> Text?
17:03:33 <alpounet> that's a new one
17:03:34 <EvanR> you can unpack and repack if you want
17:03:40 <EvanR> but not with that type
17:03:42 <alpounet> you don't modify the argument
17:03:45 <chrisdone> seems that his desktop came pre-configured to use that charset rather than unicode
17:04:41 <EvanR> reem: the library has a bunch of optimized operations for manipulating the text. changing one letter at some index is probably not a common requirement
17:04:56 <EvanR> luckily
17:04:59 <reem> EvanR: What about pushing a character to the end?
17:05:11 <EvanR> :t snoc
17:05:12 <lambdabot> Snoc s s a a => s -> a -> s
17:05:39 <EvanR> would you really do that, by itself?
17:06:14 <alpounet> :t Data.Text.snoc
17:06:14 <lambdabot> Data.Text.Internal.Text -> Char -> Data.Text.Internal.Text
17:06:16 <chrisdone> reem: it's like JavaScript strings
17:06:19 <reem> I'm not sure. I've always heard Text is better than String, I'm just wondering how it accomplishes that while being immutable
17:06:20 <chrisdone> immutable
17:06:38 <reem> chrisdone: I see, so if I want to build up a string piece by piece I should use a different type?
17:06:38 <EvanR> mutable would make matters worse
17:06:45 <chrisdone> unlike String it's a packed representation. the lazy form is chunked, the strict form is one array
17:07:12 <chrisdone> reem: there're functions for building a Text piece-by-piece that're optimized not to create a bunch of intermediate values
17:07:14 <ReinH> reem: look at Data.Text.Lazy.Builder for that
17:07:29 <EvanR> also all the text operations are fusioned
17:07:41 <alpounet> reem: String is a list of chars, and doesn't really do fusion. text is a super-optimized library that uses a much more efficient representation based on arrays (and offset/length it carries around, to avoid creating whole new arrays when you just what to reference the first 5 letters of an existing Text value, as a new one)
17:07:43 <chrisdone> reem: but if you're doing a lot of appending there's a Builder type or the Sequence type from Data.Sequence
17:08:00 <edwardk> byorgey: if not, i'd happily take a patch to add a combinator
17:08:20 <reem> Interesting.
17:09:35 * hackagebot cufft 0.1.2.0 - Haskell bindings for the CUFFT library  http://hackage.haskell.org/package/cufft-0.1.2.0 (RobEverest)
17:09:51 <chrisdone> but the packed representation gives better memory locality, better chance that your operations will take place in the cache rather than reaching to mainline memory for every single step like you would with a list
17:10:11 <reem> Oh ya, that makes total sense.
17:11:01 <reem> It's clear that String is not an efficient representation, I'm mostly trying to wrap my head around how you write array-based structures in Haskell
17:11:04 <Lokathor> alright, the bot now does the gymnastics involved to get a Char8 ByteString, decode it to Text, process it into an IO (Maybe Text), and then either give the result in the channel or tell you it had a problem
17:11:07 <Lokathor> woo
17:11:17 <reem> since arrays don't exactly support functional updates/sharing common subsections
17:11:20 <chrisdone> reem: typically one reaches for Vector
17:11:38 <EvanR> reem: well, they do support sharing. thats one point of being immutable
17:12:14 <alpounet> reem: GHC provides primitive array types that people use to build higher level array libraries, like vector.
17:12:24 <chrisdone> see http://hackage.haskell.org/package/vector-0.8/docs/Data-Vector.html#v:slice
17:12:51 <reem> How does the GC handle subslices?
17:12:52 <chrisdone> slice :: :: Int -> Int -> Vector a -> Vector a: O(1) Yield a slice of the vector without copying it.
17:13:31 <chrisdone> i'd assume it's a stable pointer. i've never looked
17:13:39 <EvanR> the vector will only be collected if there are no references to it
17:13:45 <Lokathor> happily, pattern matching against strings in the source still works. Thanks language extensions!
17:14:04 <EvanR> so if you are only left with a tiny slice of a huge array, you can use the copy operation to persuade the large vector to be collected
17:14:14 <reem> EvanR: Right, but how does the GC know that the sub-slices of the Vector actually aren't "real" Vectors and shouldn't be deallocated directly, but instead point into the larger Vector
17:14:27 <reem> I guess I should just read more about/of Vector
17:14:45 <alpounet> reem: because the "primitive array" the Vector holds is the same for the small slice and the big vector
17:15:01 <alpounet> they just have different offset/length values
17:15:14 <reem> Oh so the Vector holds a pointer and an offset, not just a pointer (and capacity/length)
17:15:23 <reem> That makes sense
17:15:35 <EvanR> its genius!
17:15:35 <chrisdone> here it is:
17:15:36 <chrisdone> basicUnsafeSlice j n (Vector i _ arr) = Vector (i+j) n arr
17:15:41 <fread2282> could someone explain why pretending things are fine in `λ g . g 0 : (( x : F ?) → F ( ¬ x )) → Nat` `F false = Nat` `F true = bool` doesn't work? shouldn't we check the term vs the type and see it's wrong no matter what we do to the type?
17:15:55 <chrisdone> reem: i assume that's self-explanatory
17:16:13 <reem> chrisdone: Yes :)
17:16:53 <reem> I'm coming at this from a rust perspective, where slices store a bumped pointer but don't own the memory so it's fine.
17:17:15 <EvanR> they dont own the memory?
17:17:16 <reem> But this is a good solution, since we have immutability!
17:17:56 <fread2282> (from Type checking in the presence of metavariables)
17:18:01 <reem> EvanR: When slices drop they don't deallocate any memory.
17:18:21 <reem> EvanR: I don't want to drag this too off-topic :)
17:18:24 <EvanR> oh, so slices are distinct from some other array type
17:18:57 <reem> yes
17:19:18 <reem> As opposed to Vectors just being slices with 0 offset
17:19:19 <chrisdone> i gotta look into Rust at some point
17:19:28 <chrisdone> it'll probably offset (tee hee!) my interest in ATS slightly
17:20:35 <chrisdone> ReinH: i packaged that mother http://hackage.haskell.org/package/descriptive
17:21:14 <chrisdone> still experimental, but i'm already using the command line parser on two projects =p
17:22:54 <chrisdone> bitemyapp: did you ever figure out a good thing for combining README with test suite?
17:23:11 <chrisdone> i just ported the README to this test suite https://github.com/chrisdone/descriptive/blob/master/src/test/Main.hs but my README is still gonna bitrot
17:23:16 <ReinH> chrisdone: woo
17:23:55 <johnw> chrisdone: have you seen https://hackage.haskell.org/package/invertible-syntax?
17:24:28 <trap_exit> am I doing something retartedly wron g.... or is debugging parsec worse than coding in ocaml ?
17:25:22 <johnw> spelling it retartedly is a bit ironic :)
17:26:39 <chrisdone> johnw: i think that's orthogonal, none of this work is related to pretty printing a data structure, but rather describing what the parser accepts
17:26:51 <EvanR> how can i know which exception is being thrown by callCommand so i can catch it (with try)
17:27:14 <chrisdone> from what i understand of bidirectional parser-printers, you can only print a value, you can't just describe what the parser accepts
17:27:37 <fizruk> EvanR: look at the sources?
17:27:44 <EvanR> is that the only way ...
17:27:51 <fizruk> documentation?
17:28:09 <johnw> ah, fair enough
17:28:18 <EvanR> so i guess i cant "catch anything, then print the type of e"
17:28:28 <johnw> EvanR: sure you can
17:28:29 <fizruk> EvanR: there is no trace of it in the type signature
17:28:31 <johnw> use Typeable
17:28:40 <EvanR> the top level handler doesnt even say what exception it is
17:28:44 <EvanR> ah
17:28:46 <johnw> I guess it only works for Typeable exceptions though :(
17:29:13 <EvanR> arent all exceptions typable?
17:29:19 <johnw> I think now they may be
17:29:21 <chrisdone> johnw: think of commandline parsers; they can print --help screens for themselves
17:29:53 <EvanR> answers my question
17:29:59 <chrisdone> (and form parsers generate an HTML page representing themselves)
17:31:34 <chrisdone> i like this one https://github.com/chrisdone/descriptive#self-documenting-json-parser
17:31:47 <chrisdone> because the Description value you get back from `describe' could be used to generate pretty API docs
17:32:34 <chrisdone> kinda like silk's restapi stuff, but it's just one of many "self-describing" consumers
17:36:13 <EvanR> i thought this would be easy at first...
17:36:39 <EvanR> Left (e :: SomeException) -> print e does not give an indication of exception type
17:36:53 <EvanR> Left (e :: SomeException) -> print (typeRep e) gives ambiguous type error
17:37:14 <reem> Is there reflection of any kind in Haskell?
17:37:26 <chrisdone> the Typeable/Data stuff can be considered reflection
17:39:03 <EvanR> source says OtherError ... mkay
17:39:56 <joness> are non-exhaustive pattern matches considered idiomatic in haskell?
17:40:39 <vermeille> AFAIK, not at all
17:40:43 <MP2E> no
17:40:49 <EvanR> now to find out where OtherError is so that i can catch it...
17:40:49 <fread2282> aer there easily-accessible resources on doing more complex (e.g. metavariables) for dependent types?
17:40:54 <joness> then why doesn't ghc warn about them by default, like ocaml compiler does?
17:41:28 <chrisdone> dunno. history i presume
17:41:50 <shachaf> There's no easy command line flag to get the right set of warnings in GHC, unfortunately.
17:41:54 <joness> and even with -fwarn-incomplete-patterns I am not getting warnings everywhere :(
17:41:56 <shachaf> -Wall turns on too much
17:42:05 <fread2282> typecheching, that is
17:42:49 <chrisdone> there was a blog post by jane street like "if haskell is so smart, how come it doesn't have inexhaustive pattern match errors?"
17:42:56 <MP2E> heh
17:43:05 <vermeille> -Wall just turns on all important warning. If they are warnings, this is for a reason. And you can still deactivate some of them individually (the warning about shadowing is particularly annoying)
17:43:10 <joness> foo = do (x:_) <- getLine; return x
17:43:23 <joness> no warning with -fwarn-incomplete-patterns . why?
17:43:35 <chrisdone> that's called an irrefutable pattern match
17:43:37 <MP2E> because there's no pattern matching going on there
17:43:50 <chrisdone> i always forget whether there was a warning type made for those
17:43:54 <ReinH> MP2E: there isn't?
17:44:08 <shachaf> @undo do { (x:_) <- getLine; return x }
17:44:08 <lambdabot> getLine >>= \ a -> case a of { (x : _) -> return x; _ -> fail ""}
17:44:13 <reem> Doesn't match []
17:44:20 <MP2E> hm.
17:44:28 <shachaf> That's the definition of pattern matching with do syntax in the Report.
17:46:40 <glguy> do notation patterns aren't irrefutable , that's to do with non-strict matching
17:46:46 <bitemyapp> chrisdone: buhhhh. You could make it a README.lhs and symlink it into the src.
17:47:06 <bitemyapp> chrisdone: but that's not something I do, I'm shifting over to doctested haddocks rather than trying to make README part of the build.
17:49:09 <chrisdone> glguy: hm my understanding of "irrefutable patterns" is a pattern which is not part of a case analysis, regardless of what it semantically boils down to underneath
17:49:20 <chrisdone> bitemyapp: so the README contains no code?
17:49:35 <bitemyapp> chrisdone: it contains code awaiting the guillotine once I port it over to the types module.
17:49:45 <bitemyapp> chrisdone: the test-run with the client module was successful.
17:49:50 <glguy> chrisdone: Do notations patterns are part of case analysis
17:50:11 <chrisdone> glguy: but not expressible as a case by the user. like a toplevel (Just x) = Nothing
17:50:39 <chrisdone> even that compiles to x = fix (\_ -> case Nothing of ~a -> a) or w/e
17:51:07 <chrisdone> bitemyapp: can i see example project?
17:51:35 <towynlin> I'm sure I'm missing something simple here. If I have a ByteString and want to pull out a substring as Word16... how can I? I'm not finding any way to get from Word8 to Word16.
17:52:25 <shachaf> @ask haasn What happened with that one-page Haskell report thing you did?
17:52:25 <lambdabot> Consider it noted.
17:52:50 <pavonia> towynlin: You want to read pairs of Word8s?
17:52:59 <haasn> shachaf: It's still on my server somewhere. I think. I'm currently busy trying to fix X.org, unfortunately
17:53:16 <ClaudiusMaximus> towynlin: pull out two Word8, convert each to Word16 with fromIntegral, combine with (* 256) and +  (or bitops if you prefer)
17:53:21 <shachaf> haasn: Since you figured out how to do it, you should propose it to be official.
17:53:31 <shachaf> haasn: It's much more usable than lots of tiny HTML pages.
17:53:56 <towynlin> Ah! ClaudiusMaximus Thank you! fromIntegral is the key
17:54:21 <chrisdone> shachaf: haasn: that would be handy
17:54:47 <johnw> chrisdone: shachaf: haasn: yes, it would be
17:55:08 <bitemyapp> chrisdone: https://github.com/bitemyapp/bloodhound god help you if you try to get doctest working without following an example project.
17:55:16 <bitemyapp> chrisdone: http://hackage.haskell.org/package/bloodhound-0.5.0.1/docs/Database-Bloodhound-Client.html
17:58:15 <glguy> It is sometimes helpful to distinguish two kinds of patterns. Matching an irrefutable pattern is non-strict: the pattern matches even if the value to be matched is ⊥. Matching a refutable pattern is strict: if the value to be matched is ⊥ the match diverges. The irrefutable patterns are as follows: a variable, a wildcard, N apat where N is a constructor defined by newtype and apat is irrefutable (see Section 4.2.3), var@apat where apat is irrefutable,
17:58:15 <glguy>  or of the form ~apat (whether or not apat is irrefutable). All other patterns are refutable.
17:58:22 <glguy> There we go, no one has to paraphrase it now
17:59:00 <chrisdone> thanks, i was looking for that. i can't access haskell.org from my isp so i was going through the rigroll of setting up a tunnel etc
17:59:30 <reem> Your ISP blocks haskell.org??
17:59:54 <chrisdone> it just can't route the ip
18:01:27 <SrPx> I've compiled the examples on accelerate-cuda, but none of them has CUDA enabled. Any idea why? I have CUDA installed already...
18:03:48 <joness> f = (\0 -> 1)  -- no warning here either, even with -fwarn-incomplete-patterns
18:04:25 <joness> I think we need -freally-warn-about-incomplete-patterns
18:04:32 <chrisdone> glguy: oh, obviously do isn't irrefutable because it's strict =)
18:05:37 <chrisdone> comparatively let (x:) = … is, because pattern bindings are lazy
18:06:04 <shachaf> let !(x:_) = ... isn't, though
18:06:55 <chrisdone> sure
18:09:35 * hackagebot repline 0.1.3.0 - Haskeline wrapper for GHCi-like REPL interfaces.  http://hackage.haskell.org/package/repline-0.1.3.0 (sdiehl)
18:09:55 <EvanR> ok i made a video of my awesome "svg ide"
18:10:03 <EvanR> * not that awesome
18:12:05 <EvanR> trap_exit: https://www.youtube.com/watch?v=ho5mW0yS0CU&feature=youtu.be
18:12:23 <trap_exit> EvanR: watching it now
18:13:03 <trap_exit> EvanR: that is pretty cute
18:13:05 <trap_exit> EvanR: is it just live.js ?
18:13:17 <trap_exit> well, it's like you output a svg file, and rowser is running live.js, which updates?
18:13:23 <trap_exit> trying to figure out how you're doing it
18:13:27 <EvanR> hahaha
18:13:41 <trap_exit> EvanR: ??
18:13:59 <EvanR> ill paste the code
18:14:34 <trap_exit> parsec error handling is like dogshit
18:15:19 <EvanR> trap_exit: http://lpaste.net/118654
18:16:41 <EvanR> recompiling is still slow.. but it would be some much slower
18:17:18 <trap_exit> ah, osascript
18:17:18 <trap_exit> cute
18:17:38 <trap_exit> EvanR: make it an interactive svg prompt, like gnuplot :-)
18:18:28 <EvanR> i havent used that, any ideas how?
18:19:10 <trap_exit> so you have this nice DSL for writing svg
18:19:16 <trap_exit> but every time you modify it, it requires recompiling
18:19:28 <trap_exit> so instead, it'd be nice if ... you could just read from stdin (like ghci or something)
18:19:33 <trap_exit> and play with the svg there
18:19:42 <trap_exit> so when yo uupdate the svg, it re0-runs osascript, but doees not rerun ghc
18:19:47 <Welkin> live code editing
18:20:04 <EvanR> well ghci isnt the easier thing to modify your code in
18:20:07 <EvanR> easiest
18:21:12 <trap_exit> well, not literarlly modify GHCI
18:21:15 <trap_exit> I mean, just read from stdin
18:21:23 <trap_exit> actually, you can do one better
18:21:26 <trap_exit> use happstack
18:21:40 <trap_exit> read from a textbox, send ot the server, the server renders to a svg, sends it back to the client
18:21:41 <trap_exit> it'll be bgetter than ghci
18:21:46 <trap_exit> and isntead of modifying ghci, you get to learn happstack too
18:21:52 <trap_exit> i'm full of bvrilliant ideas
18:23:44 <EvanR> so send the code to a program which.. compiles it.. and sends back the svg
18:24:07 <trap_exit> there is no compilation
18:24:09 <trap_exit> it's _interpreted_
18:24:20 <trap_exit> ghc is NOT called on every "svg upd]ate"
18:24:56 <EvanR> getting from freeform text to a statically typed diagrams program might be hard
18:25:09 <EvanR> dynamically
18:25:52 <EvanR> but could be possible
18:26:11 <EvanR> actually the diagrams website already has this
18:26:23 <EvanR> http://projects.haskell.org/diagrams/
18:26:39 <EvanR> http://paste.hskll.org/get/1981
18:33:37 <EvanR> does anyone know why my svg is getting cut off at the edges?
18:34:24 <gcganley> EvanR: the image format?
18:35:07 <EvanR> ok. this random github README says to add padding to the final product
18:35:37 <AshyIsMe> EvanR: i found the same thing with diagrams, if you make say a simple circle the top and left edges get cut off by a couple pixels
18:35:44 <AshyIsMe> you just have to pad it a little bit
18:36:21 <EvanR> yeah, works. im still learning the language
18:36:45 <gfixler> byorgey talks about that in one of his diagrams talks
18:36:58 <gfixler> strokes don't contribute to dimensions
18:37:14 <gcganley> EvanR: how is diagrams? I have to do a senior project that involves alot of line graphs and I thought of diagrams. I just dont know how hard it will be
18:37:24 <gfixler> gcganley: it's pretty easy
18:37:29 <EvanR> so far its pretty awesome
18:38:25 <gfixler> http://vimeo.com/84104226
18:38:35 <gcganley> doesnt it use monoids for composition?
18:38:35 <gfixler> gcganley: 2-part video - good stuff
18:38:50 <gfixler> gcganley: maybe under the hood
18:39:00 <gfixler> for the user you have |||, ===, and `atop`
18:39:09 <gfixler> dia1 ||| dia 2
18:39:14 <gfixler> that puts them side-by-side
18:39:18 <gfixler> dia1 === dia2
18:39:22 <gfixler> that puts dia1 above dia2
18:39:28 <gcganley> gfixler: uhhh right now i dont have a mouse so im just gonna save that to a txt file
18:39:37 <EvanR> theres a lot of monoids involved
18:39:59 <gcganley> thos look like arrow operations
18:40:02 <gfixler> there's a lot of other things, too
18:40:05 <gcganley> :t (|||)
18:40:06 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
18:40:09 <gfixler> they spent a couple of years on some problems
18:40:13 <gcganley> :t (===)
18:40:14 <lambdabot> (Show a, Eq a) => a -> a -> Property
18:40:40 <gfixler> it's big on composition
18:40:45 <gcganley> gfixler: wasnt it byorgey that designed it
18:40:53 <gfixler> yes
18:40:59 <gfixler> though he's had a good bit of help since it started
18:41:15 <gfixler> it's mainly his, though
18:41:38 <gfixler> what I want, though, is really fast diagrams
18:41:40 <gcganley> has he updated the typeclassopedia recently?
18:41:44 <gfixler> right now people tend to render to SVG
18:41:53 <gfixler> but there's a few seconds lag usually between saving the file and it updating
18:42:00 <gfixler> I'd like to work interactively
18:42:03 <EvanR> yeah, did you see my video
18:42:18 <gfixler> EvanR: me?
18:42:26 <EvanR> yeah i rigged it to auto update the viewer
18:42:30 <gfixler> no
18:42:35 <EvanR> but its still pretty slow
18:42:39 <gcganley> gfixler: hmmm :/ yeah that is weird, have they done ThreadScope analyisis to figure out the bottlenecks?
18:42:45 <gfixler> there's a -l (loop) flag for diagrams
18:42:54 <gfixler> gcganley: no idea
18:43:08 <gfixler> things like an html5 frontend have been mentioned
18:43:14 <gfixler> I would presume realtime if that were the case
18:43:18 <gcganley> gfixler: it would be nice to have it open in the browser and it auto update, they have that for clojurescript i know because i used to use it a ton
18:43:26 <gfixler> I would guess it's the svg renderer that's the slowdown
18:43:27 <gfixler> hopefully
18:43:39 <gfixler> gcganley: he does that in the video I link
18:43:39 <EvanR> for me, all the time went to recompiling my program
18:43:47 <gfixler> and a guy at a recent meetup I went to also did it
18:43:53 <gfixler> not in a browser, but in an svg viewer
18:44:15 <gfixler> one that updates on changes
18:44:18 <gcganley> gfixler: oh ok, is the svg rederer in C or haskell
18:44:19 <gfixler> that could have been it, too, now that I think about it
18:44:28 <gfixler> it may have simply been the lag needed to recognize the file changing
18:44:40 <gfixler> gcganley: not sure
18:44:41 <EvanR> https://www.youtube.com/watch?v=ho5mW0yS0CU&feature=youtu.be
18:44:55 <EvanR> gfixler: refreshing is fast for me, but recompiling is slow
18:45:00 <gfixler> I bet the lag was a mix of svg rendering and the viewer occasionally checking for file changes
18:45:20 <EvanR> i have file system notification events, instant
18:45:21 <gcganley> god i wish i wasnt doing this over ssh...
18:45:40 <gfixler> EvanR: ah, compiling
18:45:48 <gfixler> that's probably the *real* slowdown
18:46:18 <gfixler> what do we do?
18:46:24 <EvanR> make it compile faster
18:46:26 <EvanR> haha
18:46:26 <gfixler> we'd need a running diagrams interpreter
18:46:34 <EvanR> how does the diagrams website work?
18:46:45 * gfixler shrugs
18:47:12 <gfixler> EvanR: your @ symbols look like scared smileys
18:47:47 <gcganley> gfixler: is there a git repo anywhere that i could lookat? i cant google right now
18:47:54 <gcganley> actually...
18:48:04 <gcganley> @google haskell diagrams git
18:48:05 <lambdabot> https://hackage.haskell.org/package/diagrams
18:48:17 <gcganley> @google haskell diagrams github
18:48:17 <lambdabot> https://github.com/diagrams
18:50:41 <joness> :t (.).(.)
18:50:42 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
18:50:59 <joness> :t (.)((.).())
18:51:00 <lambdabot>     Couldn't match expected type ‘b -> b1 -> c’ with actual type ‘()’
18:51:00 <lambdabot>     In the second argument of ‘(.)’, namely ‘()’
18:51:00 <lambdabot>     In the first argument of ‘(.)’, namely ‘((.) . ())’
18:51:08 <joness> :t (.)((.)(.))
18:51:08 <lambdabot> (a -> a1 -> b -> c) -> a -> a1 -> (a2 -> b) -> a2 -> c
18:51:15 <joness> why the difference in type?
18:51:41 <joness> (.).(.) vs (.)((.)(.))
18:53:01 <dmwit> Why should (.)(.)(.) and (.)((.)(.)) have the same type?
18:53:11 <dmwit> (Note my suggestive respelling of your two terms.)
18:54:13 <Hafydd> There are a lot of breasts in this channel.
18:54:23 <dmwit> Perhaps ((.)(.))(.) vs (.)((.)(.)) is even more suggestive.
18:54:47 <dmwit> Or, you know, (f f) f vs f (f f) if all the parentheses are confusing you as much as they're confusing me.
18:55:28 <shachaf> fmap^6 = fmap^10
18:57:26 <joness> dmwit i don't get why the grouping matters, when all three functions are the same
18:57:54 <dmwit> There are more than three functions here.
18:58:09 <dmwit> (.) is a function. It occurs three times. But (.) (.) is also a function, and it is not the same function as (.).
18:58:33 <dmwit> Let's name f = (.) and g = (.) (.); then you're asking why f g and g f have different types.
18:58:38 <dmwit> Which seems totally reasonable to me.
19:00:40 <Lutin`> So I've got a 4 hour plane ride tomorrow, anyone have any good project ideas I could work on without internet?
19:01:09 <Lutin`> Since paying for inflight internet is stupid..
19:01:11 <dmwit> Add compositing to xmonad.
19:01:25 <dmwit> Make 2D portal using Hipmunk+cairo.
19:02:08 <dmwit> Port xmonad to work in the console (e.g. like tmux or screen).
19:03:08 <gfixler> I want compositing in xmonad
19:03:34 <fryguybob> EvanR: What about the diagrams website are you wondering about?
19:03:43 <dmwit> Make a new shell that doesn't suck.
19:03:46 <EvanR> "try in your browser"
19:03:51 <Welkin> Lutin`: write a game using sdl
19:04:00 <dmwit> Like, with a good story for quoting and I/O control and stuff.
19:04:21 <dmwit> Code editor with good proportional-font support.
19:04:39 <zinfandel> Hi. I have a cabal package with multiple executables. How can I build and install only specific executable?
19:05:03 <dmwit> zinfandel: You can have flags with clauses like if(flag_for_this_executable) buildable: False
19:05:07 <dmwit> in your .cabal file
19:05:41 <zinfandel> dmwit: Oh, I see. Will try that.
19:05:43 <fryguybob> EvanR: https://github.com/co-dan/interactive-diagrams/
19:06:16 <zinfandel> dmwit: Just thought there might be a way without changing .cabal
19:06:46 <dmwit> I don't think there's a way.
19:14:36 * hackagebot rainbow 0.20.0.6 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.20.0.6 (OmariNorman)
19:33:04 <cdk> with the ConstraintKinds language extension, `()` can be used as the trivially satisfied Constraint. Is there an unsatisfiable Constraint as well? I've resorted to using a private typeclass with no instances, which I don't export, but this feels like a bit of a hack
19:34:00 <shachaf> cdk: I tried using equality of two different types, (S ~ T), but I think there were issues with that.
19:34:36 <EvanR> there is such a thing as private type class?
19:35:05 <shachaf> Unexported.
19:35:12 <homovitruvius> what is a good way for splitting a ByteString at every occurrence of multiline text matching a regexp?
19:42:31 <gcganley> @google haskell parsec tutorial
19:42:31 <lambdabot> https://www.haskell.org/haskellwiki/Parsec
19:43:33 <pavonia> cdk: Why do you need that?
19:45:49 <shachaf> Presumably for similar reasons to the reasons people want Void.
19:46:34 <pavonia> I don't know why people want Void either
19:47:52 <EvanR> there are some monad actions that produce no result, but thanks to bottom we can get around that
19:47:58 <glguy> A Void is handy to have, once you have one you're free to do whatever
19:51:33 <pavonia> Maybe I'm misunderstanding, but if you have a constraint of a function that cannot ever be satisfied, you would never be able to use that function, no?
19:55:27 <enthropy> could be for something like http://hackage.haskell.org/package/HList-0.3.4.1/docs/Data-HList-Record.html#t:ExtraField
19:58:49 <gcganley>  enthropy: I've heard of Hlist on the Haskell Cast, im about to start googling it but i was just curious what it is
19:59:33 <EvanR> Hetero List
19:59:55 <gcganley> really, what does that type look like
20:00:05 <EvanR> frightening
20:00:18 <gcganley> i would expect so
20:00:32 <gcganley> EvanR: as bad as a Lens type?
20:00:37 <enthropy> blame haddock
20:01:04 <EvanR> the type of a list of things that are different types involves a list of the types
20:01:28 <EvanR> so its type safe
20:03:02 <gcganley> EvanR: so im guessing there is no such thing as a infinte HList?
20:03:54 <EvanR> i dont think theres any infinite types in haskell
20:04:27 <EvanR> that you can do anything with
20:04:59 <EvanR> newtype T = T (() -> T)
20:05:17 <enthropy> gcganley: the length is encoded in the type, and type information can flow "backwards", so you pretty much get the same "separation of concerns" you have with laziness and ordinary lists
20:06:03 <EvanR> enthropy: so for all HLists, they have a finite size
20:06:33 <enthropy> we could probably define  hRepeat e = hReplicate Proxy e
20:07:08 <enthropy> EvanR: yes
20:07:09 <EvanR> id expect any sort of general recursion to require an extension that makes type checking possibly not terminate in some way
20:07:09 <Pamelloes> Are there any good ways to create a list with modified behaviors that is interoperable with normal lists?
20:07:39 <enthropy> there is -XUndecidableInstances being used
20:07:40 <EvanR> just use normal lists and write your modified behaviors as extra functions on lists
20:08:31 <Pamelloes> EvanR: I basically want to override "!!" for some cases and/or modify list construction. Any way to do that?
20:08:38 <EvanR> why?
20:08:57 <cdk> pavonia: I have `type family Elem (a :: *) (xs :: [*]) :: Constraint`, in the case where `a` is not in `xs` I need to provide an unsatisfiable constraint.
20:10:38 <benzrf> cdk: (() ~ Void)
20:12:07 <cdk> benzrf: I'd rather avoid a dependency on the void package for this simple use case
20:12:29 <cdk> but I can see how that would work
20:12:49 <EvanR> any two different types right
20:12:57 <Pamelloes> EvanR: I have a function that processes a list by checking, for example, if the next four elements match a specific pattern and then remove them if they match. If the list is shorter than four elements a default value is needed. Ideally I would accomplish this as (list++repeat default) but I need to be able to remove the repeating default at the end so I need to store extra information in order to keep track of what elements have been added as
20:12:57 <Pamelloes>  defaults and what were originally there.
20:13:38 <ReinH> shachaf: is there a category of constriants? Some sort of poset category?
20:13:43 <EvanR> Pamelloes: doesnt sound like you need to modify lists in any way to do all that
20:13:58 <ReinH> Or do you just have some sort of lattice-like structure?
20:16:20 <shachaf> Sure.
20:16:23 <benzrf> ReinH: subsumption forms a poset dont it
20:16:32 <shachaf> @google what constraints entail
20:16:34 <lambdabot> http://comonad.com/reader/2011/what-constraints-entail-part-2/
20:16:34 <lambdabot> Title: The Comonad.Reader » What Constraints Entail: Part 2
20:16:48 <shachaf> Well, part 1 of that, probably.
20:16:55 <enthropy> cdk: you want something like "error"? https://www.haskell.org/pipermail/glasgow-haskell-users/2014-January/024526.html
20:17:00 * shachaf typing in phone
20:17:10 <Pamelloes> EvanR: Well for possible values I have data Values = .... | Default, where it is understood that the value Default will occur repeated indefinitely at the end of the list. However, to enforce this is getting kind of complicated (hence overriding list functions).
20:17:10 <shachaf> on
20:17:37 <vanila> How do I get lambdabot ?
20:17:40 <Pamelloes> In typing this out, it seems that this is probably not the best solution, but at I'm at a loss as to what a better solution would be.
20:18:02 <gcganley> vanila: you should just be able to `cabal install lambdabot`
20:18:17 <Pamelloes> gcganley: Wait, really?
20:18:51 <gcganley> Pamelloes: uhhh yes i belive so. i once fucked around with integrating it with emacs
20:19:06 <vanila> thanks
20:19:12 <Pamelloes> Huh, I need to look into that when I have an hour or three.
20:19:33 * dmwit has cabal install'd \bot
20:19:35 <EvanR> Pamelloes: sounds like youre parsing
20:19:50 <Pamelloes> yeah
20:20:10 <EvanR> so maybe use parsec
20:20:22 <Pamelloes> mm?
20:20:23 <gcganley> Pamelloes: look at the libraries that lambdabot uses. they may be more useful than using lambdabot
20:21:08 <dmwit> whatcha parsin'
20:21:51 <Pamelloes> dmwit: me?
20:21:57 <vanila> I got (invalid byte sequence) error :(
20:22:04 <dmwit> Pamelloes: Yeah!
20:22:07 <gcganley> vanila: from lambdabot?
20:22:22 <vanila> well from cabal install
20:22:37 <Pamelloes> dmwit: I'm working on my own programming language of sorts, so I'm working on parsing the grammar.
20:22:46 <gcganley> vanila: what do you want to do?
20:22:56 <dmwit> If you're parsing a PL using take and drop, you're doing it wrong.
20:23:03 <vanila> test some stuff on lambdabot
20:23:05 <EvanR> Pamelloes: you should learn parser combinators immediately ;)
20:23:06 <dmwit> Custom recursion is also right out.
20:23:14 <trap_exit> in parsec, should "try BLAH <|> return ()" ever fail?
20:23:18 <trap_exit> I bevelie no, but it's failing in my example
20:23:20 <trap_exit> so I'm like WTF
20:23:54 <dmwit> trap_exit: minimal reproducing example?
20:23:58 <gcganley> vanila: look at some of the libraries that lambdabot USES, not just use lambdabot. or look through the source code and not just live in the `main`
20:24:16 <gcganley> vanila: look for the functions used in `main`
20:24:20 <trap_exit> dmwit: none yet, but logically, "try BLAH" ,-- consumes no input when fails, so why does it not hit "retrn ()" ?
20:24:25 <Pamelloes> Well, it's an assembly-esque language so custom recursion has actually worked quite well so far. I'm looking into parsec right now.
20:24:36 * hackagebot hdocs 0.4.1.2 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.4.1.2 (AlexandrRuchkin)
20:24:38 * hackagebot cartel 0.12.0.2 - Specify Cabal files in Haskell  http://hackage.haskell.org/package/cartel-0.12.0.2 (OmariNorman)
20:24:40 <dmwit> trap_exit: Give us a minimal reproducing example.
20:24:58 <gcganley> Pamelloes: do you have a repo anywhere?
20:25:38 <Pamelloes> gcganley: https://github.com/Pamelloes/AA
20:26:40 <dmwit> trap_exit: I'm having a hard time putting my thoughts into words. But...
20:26:53 <dmwit> trap_exit: If the program isn't doing what you think it ought to be doing, this means you are wrong about something.
20:26:55 <trap_exit> dmwit: but you want a minimal reproducitable example? :-)
20:27:03 <dmwit> trap_exit: So asking, "why doesn't the program hit return ()" is a bad question.
20:27:11 <dmwit> trap_exit: Because you're wrong about something, and you don't know what you're wrong about.
20:27:20 <trap_exit> dmwit: yeah, unfortunately, I have a crappy setup atm, and need to distangle my code before I can get a minimal example
20:27:25 <dmwit> trap_exit: And asking a question like that is making a lot of assumptions about exactly what you're wrong about, see?
20:27:28 <trap_exit> dmwit: but I agree, it's my fault
20:28:03 <dmwit> trap_exit: But I can't tell you what question you *should* be asking because I have none of the information you have.
20:28:20 <trap_exit> dmwit: what you intend to say is: "trap_exit: you think error is at X, but it's probably at Y; and we cna't help you find Y if we don't see a minimal example"
20:28:21 <gcganley> Pamelloes: was not expecting python! lol
20:28:30 <trap_exit> we agree
20:28:42 * dmwit nods
20:29:13 <Pamelloes> gcganley: The compiler is in python. I threw it together in 30 seconds several months ago because I hadn't started learning Haskell yet. All of the real code is in Haskell.
20:29:43 <gcganley> Pamelloes: found it
20:30:01 <gcganley> Pamelloes: ive never used Data.Data, whats the use case?
20:30:52 <vanila> mueval: mueval-core: runProcess: runInteractiveProcess: exec: does not exist (No such file or directory)
20:30:54 <Pamelloes> gcganley: It lets you parse based off of constructor. I used it in Evaluate for figuring out how to convert some stuff.
20:30:59 <vanila> does anyone know how to fix that? running mueval
20:31:24 <Pamelloes> vanila: What OS are you on?
20:31:37 <vanila> GNU linux
20:31:57 <Pamelloes> Oh, then no idea. If you were on Windows that would be the problem. :P
20:32:11 <gcganley> Pamelloes: you may be interested in plate in Lens... It gives you some nice utility for working with immediate subexpressions and tree rewrites
20:33:15 <gcganley> ill try and get a link one sec
20:33:20 <vanila> th..thanks...
20:33:32 <Pamelloes> gcganley: I was looking into that at one point but it was kind of complicated. The only tree I use though is to create the AST, and that doesn't get changed after it is created,
20:34:06 <gcganley> Pamelloes: are you using GADT's?
20:35:08 <EvanR> Pamelloes: good, thats normal ;)
20:35:29 <Pamelloes> If I am I'm doing it unknowningly. I've read the intro material on them but haven't quite figured out what GADTs are yet.
20:35:58 <johnw> a GADT is an ADT that can fix type variables at a certain type for a given constructor
20:35:59 <EvanR> gadts??
20:36:11 <EvanR> i thought you were still on the parsing stage
20:37:11 <Pamelloes> EvanR: Well, I made my own parser and nearly completed my project. However, it is quite complicated and I'm in the process of redesigning the parser to work better.
20:38:24 <gcganley> Pamelloes: i've found that using GADT's really useful for designing grammers and the (small) languages ive made
20:39:11 <Pamelloes> gcganley: I might look into it. My current grammar is made via the free monad, but I might look into them.
20:39:45 <gcganley> Pamelloes: ive never used nor seen a free monad. only heard of them
20:40:09 <Pamelloes> gcganley: The grammar is defined in Statement if you want to take a look :P
20:40:29 <johnw> I used free monads a few days ago to make a little DSL for writing tests
20:41:04 <Pamelloes> free monads are really useful for making recursive trees.
20:41:55 <gcganley> Pamelloes: it looks a bit like Fix
20:42:12 <Pamelloes> gcganley: It is Fix but with a default value.
20:42:16 <johnw> Free is a specialization of Fix
20:42:18 <gcganley> but with the Pure N mixed in there
20:42:30 <johnw> type Free f a = Fix (Compose (Either a) f)
20:42:45 <gcganley> johnw: interesting
20:43:12 <johnw> it's something like a "tree of contexts (f), plus a value (a)"
20:44:08 <Pamelloes> So in my case literal values are handled as Pure (value) and operations performed on them are Pure (operation input1 input2 ... inputn)
20:45:34 <johnw> Pamelloes: I would have thought operations would be Free (Oper (Pure input1) (Pure input2)), for something like data Oper r = Plus r r
20:45:43 <johnw> s/Oper/Plus, in the first instance
20:46:52 <johnw> so that Pure carries the terms, and Free carries the "structure"
20:46:54 <Pamelloes> johnw: I defined all of my operators as one datatype "data Stmt next = Plus next next | Minus next next | ..." So then the type of the overall AST is Free Stmt LiteralValue
20:47:04 <johnw> right
20:47:11 <johnw> so a Plus expression would encode as I mentioned
20:47:32 <Pamelloes> Oh, I misread what you said.
20:47:39 <johnw> gcganley: https://www.fpcomplete.com/user/jwiegley/free-monad-notes
20:47:44 <gcganley> Pamelloes: why is your code so well commented?
20:48:03 <Pamelloes> gcganley: I'm not sure if that's sarcasm...
20:48:19 <gcganley> no its totally realy question
20:48:54 <gcganley> I dont write comments for pet projects at all. only when i write stuff for my classmates
20:49:05 <gcganley> s/realy/real
20:49:19 <Pamelloes> gcganley: I've learned the hard way that uncommented code always comes back to bite you.
20:49:59 <Pamelloes> Also, a programming language is meant to be used by other people so good commenting is important.
20:50:42 <Pamelloes> I actually spent several months writing out a specification for the language so that I knew what I was doing and had most of the major design flaws worked out before I started writing code.
20:51:18 <Pamelloes> EvanR: Does parsec work on types other than Char?
20:51:54 <gcganley> Pamelloes: I just write a ton of notes int Notes and then hack out what i said in Notes. Its really bad but im not the best programmmer and no one wil be reading my code anyrtime soon lol
20:51:57 <EvanR> the default is [Char] but i think it can parse sequences of other things
20:52:25 <gcganley> Pamelloes: atto uses bytestrings i belive
20:52:27 <Fylwind> Pamelloes: it does but there's less support (you have to write some primitive parsers)
20:52:52 <EvanR> Pamelloes: you probably have [Char] anyway, since its a programming language?
20:53:28 <Pamelloes> EvanR: I actually have [Bool]. The language is a quasi-assembly thing and is specified on a bit-by-bit basis.
20:53:43 <EvanR> oO
20:53:54 <Pamelloes> Still, Bool is simple enough that parsing probably won't be too difficult.
20:54:00 <EvanR> programmers will write programs as [Bool]s ?
20:54:34 <vanila> cool!
20:54:40 <Pamelloes> EvanR: Well, no. It's an assembly language so there are mnemonics and a compiler. But a compiled program will consist of [Bool]
20:54:47 <vanila> I've been playing with a language like that a bit
20:54:57 <vanila> binary lambda calculus..
20:55:07 <gcganley> EvanR: C++ uses bit vectors to represent Bool vectors
20:55:12 <johnw> [Bool] sounds like having a conversation with a taciturn adult
20:55:15 <gcganley> if i remember corectly
20:55:22 <EvanR> gcganley: uhg
20:55:31 <johnw> C++ optimizes for certain sizes of bool vector
20:55:43 <johnw> so that it uses plain integers for small vectors
20:56:03 <johnw> aka, like having numerically-addressed bitfields
20:56:04 <gcganley> I used to program C++ all the time but i always thought it was strange that it had that behaviour
20:56:29 <Pamelloes> Hm, parsec looks like it will make my parsing code a lot simpler :)
20:57:04 <EvanR> ... why am i installing basically all of linux right now on osx to get diagrams cairo backend to work
20:57:06 <gcganley> Pamelloes: did you try looking at parsing libraries before writing your own?
20:57:13 <EvanR> despite the fact that i already had cairo (for mac) installed
20:57:16 <Pamelloes> gcganley: Nope :P
20:57:30 <Pamelloes> EvanR: Macports?
20:57:33 <EvanR> homebrew
20:57:36 <Pamelloes> Oh.
20:58:06 <EvanR> "gobject" oO
20:58:10 <gcganley> Pamelloes: yeah i would subscribe some parsec and GADT's
20:58:48 <Pamelloes> gcganley: Yeah, all of my parsing code should simplify immensely once I integrate parsec. And it'll mean I should be able to get rid of a bunch of annoying unit tests.
20:59:23 <geekosaur> becausue homebrew learned the hard way that using random installed libraries is a recipe for undebuggable errors
20:59:37 <geekosaur> yes, everyone wants that to work. good luck with that
20:59:46 <gcganley> Pamelloes: would you like someone to help contribute? it may take a bit for me to understand the codebase but i've written parsers and used parsec before
21:00:49 <EvanR> heh im just trying to put text on the diagram
21:01:03 <Pamelloes> gcganley: Sure, I'd be happy to have another person working on it :) Be warned I'm not that reliable but I'd appreciate any PR.
21:01:52 <Pamelloes> gcganley: Though the vast majority of the code base is probably about to be rewritten
21:02:42 <gcganley> Pamelloes: we could do with a rewrite of Statement.hs to use GADT's
21:03:25 <EvanR> the thing is that cairo has a quartz backend, it seems like this route is using the X backend
21:03:44 <Pamelloes> gcganley: I can't promise I'd be willing to use that but I would be curious to see what that would look like.
21:04:33 <gcganley> I'll work on it, I have a week or so free to write as much code. ill most likely fork it to https://github.com/gcganley/AA
21:05:06 <Pamelloes> Go for it! I'ld love to see what you do :)
21:06:21 <johnw> gcganley: if you're eager to work on a parser, I have another one you could try with
21:06:39 <johnw> I'd like a little GADTification (I started on a branch, but ran into some snags)
21:07:53 <gcganley> johnw: sure, I'd be down
21:07:58 <johnw> https://github.com/jwiegley/hnix
21:10:05 <hypoon> Hello all. I have a file that contains a small amount of information, which may be edited between program runs, but will not be edited while my haskell code is running. I would like to avoid re-reading the file hundreds of thousands of times. I know one way to do this would be to read the file once and pass its contents around all over my program, but that's rather messy. How would you guys work around this situation?
21:10:40 <EvanR> read it once and pass its contents around all over your program
21:10:46 <johnw> I'd pass the contents around using ReaderT
21:11:05 <johnw> something like: type App a = ReaderT SomeStructure IO a
21:11:09 <johnw> and then use App instead of IO
21:11:31 <johnw> I think every application I've written follows this pattern
21:12:30 <hypoon> johnw: I'm not familiar with ReaderT
21:12:59 <hypoon> johnw: (I'm looking into it now)
21:13:31 <johnw> ReaderT abstracts the pattern of "pass this read-only information around everywhere"
21:14:33 <systemfault> The FP version of OOP's dependency injection :P
21:15:14 <gcganley> johnw: wouldnt you just use Either for https://github.com/jwiegley/hnix/blob/master/Nix/Parser/Library.hs#L107-L108
21:15:49 <EvanR> i never understood what dependency injection was
21:15:52 <hypoon> johnw: really! That seems to be almost exactly what I want. I'm cautious though, because I really don't want to be adding another parameter to all of my existing functions... that just doesn't seem like it would be the elegant way to do things.
21:16:23 <EvanR> you dont pass it explicitly
21:16:32 <EvanR> its only indicated in the type signatures
21:16:37 <johnw> you call "ask" when you want to obtain the data
21:16:44 <johnw> you don't have to pass it around manually
21:17:21 <johnw> gcganley: sure, we could have type Result a = Either Doc a
21:19:16 <hypoon> I have several functions which would be pure if I hardcoded the datatable into my code. Before I spend a lot of time figuring out ReaderT, will I have to go back and update all of those functions? That's exactly what I'm trying to avoid.
21:19:34 <johnw> if they are pure, you can use Reader instead of ReaderT
21:21:14 <Pamelloes> Eek, parsec doesn't seem to support non-strings out of the box and I have no idea how to make them work :/
21:21:30 <Pamelloes> Anyone farmiliar with the internals of parsec?
21:21:30 <hypoon> Imagine you have lots of interdependent pure functions, and you basically want to change a hardcoded value of 72.4 to an average of the list of floats in a file. That's basically what I'm trying to do.
21:22:36 <EvanR> you can pass that value in as a parameter
21:22:37 <bms1> Pamelloes: Yes, it actually does support very general input types
21:22:45 <EvanR> sometimes the Reader gets in the way
21:23:06 <bms1> For example, you can use a list of terms of some type (other than Char)
21:23:08 <EvanR> the "unpure" code can then ask for it and pass it in
21:23:36 <EvanR> adding a new parameter to replace a hardcoded value is easy, no brainer
21:23:51 <bms1> see https://hackage.haskell.org/package/parsec-3.1.8/docs/Text-Parsec-Prim.html
21:24:00 <EvanR> and haskell tells you where you now have to fix the call-sites
21:24:01 <Pamelloes> Thanks, I'll take a look
21:24:01 <bms1> functions `token` and `tokenPrim`
21:24:11 <vanila> Pamelloes, a little
21:24:21 <vanila> at least the first version of parsec... they made it much more complex today
21:24:43 <hypoon> suppose function blah needs the average of the floats in the file. Then I'd need to add the parameter not just to function blah, but also to all the functions that call blah, and all the functions that call them, etc....
21:24:55 <EvanR> no
21:25:09 <Pamelloes> vanila: I'm taking a look at the link bms provided so I should be fine for a little while ;)
21:25:09 <EvanR> at some point theres the Reader
21:25:20 <EvanR> or ReaderT
21:26:27 <hypoon> EvanR: Ok, I didn't realize you were still suggesting I use the Reader.
21:26:47 <EvanR> in the pure functions youre talking about you can easily add another parameter
21:27:27 <EvanR> or turn them into Readers if they are deeply nested
21:28:17 <hypoon> EvanR: using Reader will involve changing the type signature of all of my functions, and that's just as bad as adding another parameter. It just seems inelegant.
21:28:42 <EvanR> changing fundamental operation of your whole program without changing any type signatures...
21:28:55 <EvanR> thats dangerous
21:29:18 <johnw> having the signatures of your functions match their semantics is true elegance
21:29:38 <johnw> if they are making use of some kind of "environmental" data, the signature should reflect it
21:30:16 <EvanR> it doesnt even sound like environmental data its literally one of the inputs to the calculation
21:30:17 <Pamelloes> ^
21:30:34 <Pamelloes> (to the comment about elegance)
21:30:35 <Iceland_jack> hypoon: It also pulls its weight more when you combine it with other monads
21:31:04 <hypoon> It's not really environmental data. It's physical constants. These numbers won't change except as research scientists make more exact measurements.
21:31:16 <Pamelloes> bms1: What's the difference between token and tokenprim?
21:31:22 <johnw> oh, in that case make them constants
21:31:29 <johnw> measure :: Int; measure = 72.4
21:31:45 <hypoon> right, but there's lots of them.
21:31:55 <johnw> put them in a Map
21:32:51 <EvanR> well, then maybe it counts as source code and can be unsafePerformIO globalled into a top-level value
21:33:00 <johnw> or
21:33:01 <bms1> Pamelloes: `token` is defined in terms of `tokenPrim`. The only difference is in the function to compute the token's position.
21:33:03 <johnw> use Template Haskell
21:33:03 <EvanR> but ReaderT makes more sense
21:33:10 <hypoon> There's lots, but not THAT many. Hundreds, not thousands. I've got them in a list that I'm filtering.
21:33:14 <johnw> so that you can generate the definitions from the contents of a file at compile-time
21:33:58 <bms1> Pamelloes: You can probably start with token, as you don't need to even worry about computing token positions when you're just getting started
21:34:39 <hypoon> johnw: I don't need Template Haskell, I can format the data as a Haskell source file. That's no big deal at all.
21:34:53 <Pamelloes> bms1: So I understand what a token pretty-printing function is. I'm confused as to what a SourcePos is.
21:35:28 <bms1> It just gives the file name, line number, and column number of where a token is. It might not even be relevant to you
21:35:33 <bms1> It's for error-reporting
21:35:45 <hypoon> EvanR: honestly, unsafePerformIO has been in the back of my head this whole time. I don't understand exactly how it works, though. I don't understand when the operation gets performed (is it during compilation? is it cached between executions?)
21:36:03 <EvanR> its happens whenever
21:36:11 <EvanR> perhaps multiple times
21:36:19 <johnw> it's unsafe
21:36:27 <bms1> EvanR: No, it shouldn't happen multiple times
21:36:34 <EvanR> if you dont inline it
21:37:33 <hypoon> Will haskell read the file during compilation and just store the result?
21:37:38 <EvanR> no
21:38:13 <hypoon> I guess that should be: will *GHC* read the file during compilation and store the result...?
21:38:28 <johnw> only if you were to use template haskell
21:38:30 <hypoon> EvanR: ok, that's what I was assuming
21:38:47 <Pamelloes> bms1: ok. So if I were to parse on bools, would my token be something like "btoken x = token (show) (undefined) (\y -> if x==y then Just y else Nothing)"?
21:38:55 <bms1> hypoon: No. There's some article by ezyang that does a good job explaining Haskell's runtime that might help you understand what goes on
21:39:49 <bms1> hypoon: http://blog.ezyang.com/2011/04/the-haskell-heap/
21:40:35 <hypoon> I know haskell can/will cache the result of a pure function. Does that cache start empty each time the program runs?
21:41:38 <EvanR> you might want to write a generator for these ~100 constants yourself, converting them from your csv file into a haskell file
21:41:39 <bms1> Pamelloes: Yep, that's basically what I end up writing for all my non-String parsers! (Note what you wrote works for anything in Eq and Show)Except don't use undefined; give some constant SourcePos
21:41:51 <EvanR> if you want to avoid template haskell
21:42:04 <EvanR> then you can at least see the code
21:42:18 <EvanR> data deriving works like that
21:42:27 <bms1> (If you use undefined, a bad parse could make the runtime explode)
21:42:28 <EvanR> i mean, binary deriving
21:42:40 <ReinH> shachaf: thanks for the reference!
21:42:58 <Pamelloes> bms1: Alright. Do you have an example for how to use this new token function?
21:43:42 <bms1> No, but with btoken, you're already there
21:44:08 <hypoon> EvanR: All I'd do is insert a line at the top: "[", a line at the bottom: "]", and wrap all the lines in parentheses. Why do anything more? But I'm not so worried about that. Why is unsafePerformIO a bad idea?
21:44:12 <Pamelloes> Right, but what's the use case for btoken? In the examples of using parsec I was reading, token wasn't used directly :P
21:44:27 <EvanR> hypoon: im telling you, youll regret it ! ;)
21:44:39 <EvanR> what you just explained makes way more sense to me
21:44:58 <bms1> Pamellos: Suppose you want to parse a True followed by any number of Falses
21:45:10 <bms1> btoken True >> many (btoken False)
21:45:24 <bms1> And when you run the parser, you just feed it your list of Bools
21:45:31 <johnw> I think it better to not even bring up unsafePerformIO most of the time
21:45:49 <Pamelloes> bms1: Alright, I think I get it.
21:46:41 <glguy> hypoon: GHC doesn't cache pure function results
21:47:35 <aisqwe> real world haskell introduces Monads merely as a programming design, what are some mathematical properties of Monads without knowing category theory but good math knowledge?
21:48:11 <EvanR> the monad laws
21:48:13 <johnw> aisqwe: they have a monoidal structure in a certain category
21:48:38 <Pamelloes> What does "not in scope: data constructor ..." mean?
21:49:01 <Pamelloes> I've made sure to import the package containing the data constructor which was my first guess but that didn't fix it.
21:49:06 <hypoon> glguy: Am I thinking about it the wrong way, or am I completely off-base? I thought that was part of the point. Since a function is pure, the same parameters are guaranteed to produce the same results, which is only useful if you intend to take advantage of that as a shortcut.
21:49:12 <glguy> It means you misspelled the name of your data constructor or didn't import it
21:49:31 <johnw> hypoon: what you're talking about is something we call "memoization"
21:49:47 <glguy> hypoon: It's useful because we can reason about the function locally, not because it's automatically memoized
21:50:22 <Pamelloes> glguy: bu... I'm looking at the source and it says I've imported the right package and I don't have a type D:
21:50:26 <Pamelloes> *typo
21:50:59 <glguy> Well, GHC probably isn't screwing with you :-D so you've probably done something else slightly wrong
21:51:34 <glguy> You'll have to look more closely or paste the code on lpaste.net if you want help
21:51:41 <hypoon> johnw: I've used unsafePerformIO regarding passing arrays around in pure FFI functions, that's the only reason it came to mind for me.
21:52:09 <glguy> Which package and data constructor ?
21:52:24 <hypoon> johnw, glguy: what are the potential pitfalls of unsafePerformIO in my situation?
21:52:30 <johnw> it was designed for use with FFI
21:52:36 <glguy> hypoon: I don't know what your situation is...
21:52:51 <hypoon> Pamelloes: "I don't have a typo" <-- famous last words...
21:53:01 <horny-sama> anyone here familiar with haskell?
21:53:02 <horny-sama> lol
21:53:10 <horny-sama> what does the symbol /= means
21:53:13 <horny-sama> I mean operator
21:53:14 <glguy> Not equal to
21:53:16 <Pamelloes> horny-sama: unequal to
21:53:26 <Iceland_jack> > 5 /= 4200
21:53:28 <lambdabot>  True
21:53:34 <horny-sama> glguy, Pamelloes: isn't that !=?
21:53:36 <Pamelloes> Looks like it wasn't a type per se, just that the data constructor I was using isn't exported :/
21:53:43 <Pamelloes> horny-sama: Not in haskell :P
21:53:47 <glguy> ≠
21:53:53 <horny-sama> ok
21:53:55 <glguy> ASCII version of that
21:54:20 <Pamelloes> ≠≈=
21:54:24 <Pamelloes> :D
21:54:27 <horny-sama> I wish haskell can follow some convention
21:54:29 <horny-sama> lol
21:54:36 <hypoon> glguy: Basically I have lots of physical constants that I want to store outside of my program, and I'm desperately trying to avoid changing the signatures of a whole bunch of functions just to avoid hardcoding a table of numbers.
21:54:37 <johnw> horny-sama: why do you think it doesn't?
21:54:49 <horny-sama>  using /= instead of !=
21:54:54 <horny-sama> like most languages
21:54:58 <johnw> /= is closer to the math convention
21:55:25 <horny-sama> johnw: but that is computer programming not math
21:55:52 <johnw> Haskell wasn't developed just to write computer programs
21:55:59 <emilypi> can i ask a really stupid question?
21:56:05 <Iceland_jack> Go ahead
21:56:15 <glguy> You're going to have a bad time if you're getting hung up on != vs /=   ^_^
21:56:27 <Pamelloes> hehe
21:56:27 <glguy> There are bigger differences to come
21:56:30 <horny-sama> johnw: what else can you use a programming language for other than write computer programs?
21:56:48 <hypoon> horny-sama: I don't remember what language uses it, but it's one that I use a lot... some language uses "<>" for "not equal to".
21:56:50 <johnw> horny-sama: to explore ideas; to construct proofs; to prove that a design is sound
21:56:52 <emilypi> yay! Okay, i'm new to haskell and type signatures mystify me. Can someone explain to me like i'm 5 how to read something like foldL :: b -> (a -> b -> b) -> List a -> b ?
21:57:06 <hypoon> horny-sama: (which I always thought was kinda funny)
21:57:08 <johnw> Haskell was originally a research vehicle into lazy, functional programming
21:57:09 <Iceland_jack> emilypi: Do you understand signatures like (a -> a)?
21:57:11 <BMeph> emilypi: We have a saying here: "Don't ask to ask, just ask." :)
21:57:19 <johnw> hypoon: Pascal does
21:57:23 <emilypi> Iceland_jack, barely.
21:57:24 <bms1> hypoon: How many physical contents? Why do you want them outside your program?
21:57:27 <emilypi> i'm not willing to really say i do
21:57:33 <bms1> *constants
21:57:38 <horny-sama> hypoon: I have never seen a language that does not use != other than haskell
21:57:39 <EvanR> speaking of unsafePerformIO ... the main point of the package svgfonts (to use svg fonts with diagrams), openFont :: FilePath -> FontData, i noticed has no IO in the type :S
21:57:40 <horny-sama> :P
21:57:41 <Iceland_jack> emilypi: How about (Int -> Int)
21:57:51 <Iceland_jack> or (Bool -> Bool)
21:57:55 <EvanR> perhaps not surprisingly i get an error some time after calling it to read the file
21:57:56 <emilypi> take an int, do some stuff, return an int
21:57:58 <bms1> hypoon: Template haskell seems like it might be appropriate for what you want to do
21:58:00 <Cale> horny-sama: Ada also uses /=
21:58:00 <horny-sama> johnw: construct proofs sound like a math guy job
21:58:01 <horny-sama> :P
21:58:10 <Cale> There are a few others as well
21:58:15 <hypoon> johnw: it wasn't Pascal, I've never been fond of Pascal >.<
21:58:24 <emilypi> Iceland_jack, so yes
21:58:35 <Iceland_jack> emilypi: Right, so (Bool -> Bool) is a function that accepts a single Boolean value and gives you a Boolean value, a function like "not":
21:58:35 <Iceland_jack>     not :: Bool -> Bool
21:58:48 <johnw> horny-sama: believe it or not, in a language like Haskell you are constructing proofs all the time; only you call it "writing code". :)
21:58:51 <Iceland_jack> emilypi: but consider functions like 'length'
21:58:55 <Cale> horny-sama: Proofs and programs are secretly the same thing
21:58:57 <emilypi> right. or (add 2) :: Int -> Int: a -> a + 2
21:59:04 <Iceland_jack> yes
21:59:10 <johnw> how do you prove that a function with a certain type is possible?  you write one
21:59:23 <Iceland_jack> emilypi: 'length' takes a list and tells you how long it is
21:59:23 <Iceland_jack>     
21:59:25 <Iceland_jack> > length [1,2,3,4]
21:59:26 <lambdabot>  can't find file: L.hs
21:59:27 <glguy> (and then run it and show that you got an answer)
21:59:30 <Iceland_jack> > length [1,2,3,4]
21:59:31 <lambdabot>  4
21:59:32 <horny-sama> I have a feeling that the creator of haskell is a math guy
21:59:35 <Cale> Of course, Haskell's logic is inconsistent, so just knowing that a proof exists in the case of Haskell's logic is not interesting.
21:59:35 <Iceland_jack> > length "hello"
21:59:36 <lambdabot>  5
21:59:37 <emilypi> right. So length :: List a -> int
21:59:41 <Iceland_jack> Exactly
21:59:45 <Cale> But we care about the distinctions between proofs
21:59:46 <johnw> glguy: in terms of proof, you don't need to execute it
22:00:03 <glguy> johnw: You do with Haskell, it needs to terminate
22:00:10 <Cale> So, it's not so terrible that the logic is inconsistent
22:00:18 <emilypi> Iceland_jack, so then the grouping (a -> b -> ) would be a function which takes a tuple <a, b> -> b?
22:00:20 <johnw> glguy: termination is no proof that it always terminates :)
22:00:21 <nshepperd> hypoon: the biggest danger with unsafePerformIO there is probably that if your config file is unreadable or missing your program will throw an exception when it goes to use one of those constants
22:00:26 <Cale> (Turing completeness ensures inconsistency)
22:00:33 <emilypi> sorry (a -> b -> b)
22:00:38 <Iceland_jack> emilypi: Rather than creating multiple functions with 'concrete' (monomorphic) types:
22:00:38 <Iceland_jack>     lengthStr :: [Char] -> Int
22:00:38 <Iceland_jack>     lengthInt :: [Int]  -> Int
22:00:38 <Iceland_jack>     ...
22:00:41 <Iceland_jack> we create a general (polymorphic) one that accepts lists of any type:
22:00:44 <Iceland_jack>     length :: [a] -> Int
22:00:51 <vanila> whats the point of calling them proofs
22:00:57 <emilypi> kk
22:00:59 <horny-sama> should I do :set prompt "ghci> " for my ghci?
22:00:59 <Iceland_jack> emilypi: Yes effectively, except Haskell doesn't normally use tuples for that
22:01:01 <nshepperd> hypoon: (instead of at the start of the program)
22:01:17 <glguy> johnw: No, but if it does terminate you can tell that the whole program isn't bottom, which helps when using it as a proof
22:01:23 <vanila> it seems like stretching this analogy really thin
22:01:23 <horny-sama> anyone?
22:01:28 <Cale> vanila: Well, in languages with slightly fancier type systems than Haskell, they really do start to count as honest mathematical proofs.
22:01:31 <Iceland_jack> emilypi: So a simple function like 'id' has type 'a -> a' because it doesn't do *anything* so it should work for every type:
22:01:31 <Iceland_jack>     id :: a -> a
22:01:31 <Iceland_jack>     id x = x
22:01:42 <Cale> vanila: e.g. Coq, Agda, Idris
22:01:44 * emilypi nods
22:02:03 <horny-sama> should I do :set prompt "ghci> " for my ghci?
22:02:04 <johnw> vanila is active on the Coq channel, so he knows this
22:02:09 <EvanR> yes in haskell bottom ruins the whole show
22:02:15 <Cale> vanila: Haskell has been headed in this direction for quite some time.
22:02:29 <Iceland_jack> emilypi: And operators that concatenate lists don't care at all what the lists contain:
22:02:29 <Iceland_jack>     (++) :: [a] -> [a] -> [a]
22:02:33 <Cale> It's just approaching it with a somewhat different philosophy
22:02:35 <horny-sama> anyone here familiar with ghci?
22:02:42 <glguy> horny-sama: Don't ask to ask
22:02:45 <Cale> horny-sama: Nearly everyone here :)
22:02:51 <EvanR> your proofs have to be completely in the type level
22:02:57 <horny-sama> should I set :set prompt "ghci> " for my ghci?
22:03:07 <horny-sama> so it will run on ghci instead of prelude
22:03:07 <Cale> horny-sama: That's entirely personal preference
22:03:09 <Iceland_jack> emilypi: But here is a somewhat tricky part, functions can take functions as arguments
22:03:10 <hrumph> hi
22:03:14 <BMeph> horny-sama: MU!
22:03:17 <hypoon> bms1: I can trivially arrange the data in a module file that Haskell can compile in... it just feels wrong. The data is the radii, masses, neutron and xray scattering lengths, etc... for different elements and isotopes.
22:03:22 <Cale> I don't tend to set my GHCi prompt
22:03:25 <emilypi> Iceland_jack, okay, so the full thing b -> (a -> b -> b) -> List a -> b which look something like (B b, f:AxB -> B, List A) and return B?
22:03:28 <Cale> Some people like to set it to something short
22:03:29 <horny-sama> Cale: what's the difference?
22:03:31 <emilypi> *would look
22:03:33 <EvanR> hypoon: you should probably organize it then
22:03:34 <Pamelloes> horny-sama: set prompt doesn't actually change anything, but if you're importing lots of packages it can be very useful.
22:03:41 <Pamelloes> s/packages/modules
22:03:42 <Iceland_jack> emilypi: Yes
22:03:50 <horny-sama> Pamelloes: ?
22:03:53 <Cale> horny-sama: It just changes what's displayed for a prompt
22:03:59 <horny-sama> ooo
22:04:02 <Iceland_jack> emilypi: A simpler type would be to look at 'map':
22:04:02 <Iceland_jack> > map not [True, True, False]
22:04:02 <emilypi> awesome!
22:04:03 <lambdabot>  [False,False,True]
22:04:06 <Iceland_jack> @ty map
22:04:07 <horny-sama> Cale: I should change it to icbm
22:04:07 <lambdabot> (a -> b) -> [a] -> [b]
22:04:24 <Iceland_jack> @src map
22:04:25 <lambdabot> map _ []     = []
22:04:25 <lambdabot> map f (x:xs) = f x : map f xs
22:04:49 <emilypi> Iceland_jack, awesome thank you. I just wanted to make sure i was reading this ADT stuff correctly.
22:04:52 <horny-sama> I changed it to miku
22:04:56 <Iceland_jack> Here 'f :: a -> b' and the patterns []/(x:xs) on the right hand side have types [a]
22:05:04 <Iceland_jack> *left-hand side
22:05:06 <bms1> hypoon: Does it feel wrong because it can be more condensely stored in a table of text or something like that? Sounds like template haskell is exactly what you want for this. Essentially, use template haskell to load the table from a file and generate the code that you say you "could" trivially arrange
22:05:17 <Iceland_jack> and the lists on the right-hand side []/(f x : map f xs) have type [b]
22:05:22 <Iceland_jack> No problem emilypi, hope it helped
22:05:31 <emilypi> you did a ton thank you <3
22:06:06 <emilypi> now i have to go implement a generic tree fold in java8 :)
22:06:10 * emilypi suicides
22:06:14 <Iceland_jack> Yikes!
22:06:41 <Iceland_jack> The types of folds are tricky
22:07:05 <johnw> Iceland_jack: why is that?
22:07:06 <emilypi> we have the type sig foldB :: (a -> b) -> (b -> b -> b) -> Btree a -> b
22:07:10 <emilypi> so i guess i have to suss that out
22:07:22 <Iceland_jack> johnw: It's a big step when you're introduced to them
22:07:25 <Iceland_jack> emilypi: But if you look carefully, the functions match the types of the list constructors
22:07:35 <Iceland_jack> @ty foldr
22:07:36 <lambdabot> (a -> b -> b) -> b -> [a] -> b
22:07:39 <johnw> Iceland_jack: heh, wait until you have to write a dependently-typed fold, where the accumulator changes type with each iteration
22:07:55 <Pamelloes> bms1: How can I implement parsec's tokens. Can it be done in terms of token, or do I have to write an entirely new function?
22:07:58 <Iceland_jack> Yes there are more complicated concepts
22:08:19 <Iceland_jack>     (a -> b -> b) corresponds to (:) :: a -> [a] -> [a]
22:08:19 <Iceland_jack>     b             corresponds to []  :: [a]
22:08:44 <emilypi> so i'm going to need (f:a -> b, g:bxb -> b, Tree a) -> b
22:09:08 <Iceland_jack> emilypi: Where 'f' corresponds to the tip of the tree and 'g' to a branch, yes
22:09:10 <hypoon> bms1, EvanR: I think the only reason I'm hesitant to do so is in case there becomes a need to add new entries to the table (isotopes, most likely, because we've pretty much stopped discovering new useful elements). Actually, even just ions can have significantly different atomic radii from the neutral elements. Such additions will be very infrequent, but would require recompiling the code.
22:09:34 <Iceland_jack> You seem to get it
22:09:47 <emilypi> Iceland_jack, it's getting there bit by bit
22:09:49 <emilypi> thank you
22:10:17 <horny-sama> there is something that I don't understand. You do :1 yourCode to load it to ghci but how does ghci know where the code is located ?
22:10:22 <EvanR> hypoon: yeah youd need to recompile. a slightly saner version of this is that it counts as input data which is read in when the program starts, and then you only need to restart the program when the data changes.
22:10:28 <bms1> Pamelloes: I'm not entirely sure what tokens does, nor why you feel you need to implement it?
22:10:43 <EvanR> hypoon: the ReaderT. This is the most common way and most straight forward
22:11:07 <EvanR> the idea that "this is input data, and it might change" proves that this is what you should do
22:11:29 <glguy> horny-sama: You load modules with :l (el), and it knows because the module name corresponds to the filename
22:11:37 <Pamelloes> bms1: Well I want to implement a function that matches a [Bool], and string which matches [Char] is implemented in terms of "tokens" so I was thinking of doing the same thing. Do you have an alternate method?
22:12:03 <bms1> Pamelloes: Oh. Yeah I would just write this:
22:12:15 <horny-sama> glguy: as in the location
22:12:22 <hypoon> EvanR: Honestly, I see no reason I'll ever need to change it. I'm trying to look out for future users years from now.
22:12:36 <horny-sama> how can it locate my code where I can't specify the directory?
22:12:50 <glguy> horny-sama: The module My.Module will be located at My/Module.hs  based on the current directory
22:12:51 <bms1> manyTokenB :: [Bool] -> Parser [Bool]; manyTokenB xs = mapM btoken xs
22:13:03 <EvanR> hypoon: .. you have to pick one or the other
22:13:27 <Pamelloes> :t mapM
22:13:28 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
22:13:29 <EvanR> hypoon: take for example the Time library. it has support for converting between TAI and UTC given a table of leap seconds. its not using unsafePerformIO
22:13:34 <horny-sama> glguy: I try to cd in my directory when I am in ghci but no goal
22:13:38 <EvanR> this is a very sane choice
22:13:46 <horny-sama> so I need to cd in dir before entering ghci mode?
22:14:17 <Iceland_jack> horny-sama: you can use the :cd command
22:14:36 <Iceland_jack> ':cd' must be a built-in in interactive shells
22:14:58 <Iceland_jack> as opposed to a process you spawn
22:15:36 <horny-sama> Iceland_jack: how can I check which dir I am currently in
22:15:38 <horny-sama> :pwd?
22:15:48 <Iceland_jack> :! pwd
22:15:57 <spearman> what do you do when a dependency fails to compile when installing a package with cabal install? (i'm trying to cabal install hoogle, but i get an error in compiling Recipe.Cabal)
22:16:01 <horny-sama> Iceland_jack: thx
22:16:05 <hypoon> EvanR: Is it using IO, or do they release a new version any time the table of leap seconds changes?
22:16:08 <spearman> is this 'dependency hell'?
22:16:30 <hypoon> EvanR: or do you have to provide it the table of leap seconds?
22:16:34 <horny-sama> thx but weird why not :pwd instead of :! pwd
22:16:35 <horny-sama> lol
22:16:35 <EvanR> hypoon: its not IO, its pure code. its up to the application to decide how they want to provide the data, if at all
22:17:37 <Pamelloes> spearman: I would suggest uninstall all modules, make sure cabal-install is fully updated, enter a sandbox, and reinstall.
22:17:52 <Pamelloes> spearman: Not sure what your problem is, but that solves almost all of them :P
22:18:26 <Pamelloes> Of course that might be (almost certainly is) complete overkill so procede with caution
22:18:34 <Pamelloes> *precede
22:18:39 <glguy> spearman: Don't uninstall all your packages just yet
22:18:52 <glguy> spearman: Recipe.Cabal is a module in the hoogle package, doesn't appear to have anything to do with dependencies
22:19:03 <trap_exit> I don't like the behaviour of "_". INstead, I'd like to write: """   error $ "IMPLEMENT ME " ++ __FILE__ ++ ":" __LINE__  """ <--- how do I get __FILE__ and __LINE__ ?
22:19:14 <glguy> spearman: You should paste the full error you're getting to lpaste.net if you need help resolving it
22:19:15 <trap_exit> when developing, I like runtime rather than compile time errors for code that has NOT yet been written
22:19:25 <spearman> glguy ok, i'm updating cabal now
22:19:51 <EvanR> trap_exit: really?
22:19:56 <trap_exit> EvanR: YES]
22:20:09 <trap_exit> EvanR: any other questions?
22:20:12 <Pamelloes> trap_exit: If you don't have a fall through method e.g. skip "_" you will get a runtime error. Alternately you can do "_ = undefined" or "_ = error "my error message!""
22:20:21 <Pamelloes> *fall through pattern
22:20:34 <Pamelloes> my nouns get all mixed up when I'm tired :(
22:20:35 <glguy> trap_exit: You can use template haskell to get access to the current source location: location :: Q Loc
22:21:12 <glguy> after you defined something called "unimplemented" you could have    something x = $(unimplemented)
22:23:04 <PrecisionGuy> Hi All ... how to get the parameter of a type?
22:23:06 <PrecisionGuy> for exampe
22:23:10 <PrecisionGuy> example:
22:23:21 <PrecisionGuy> data Token :: Integer
22:23:22 <enthropy> trap_exit: -fdefer-type-errors is somewhat related (but there's no -fdefer-scope-errors / -fdefer-parse-errors etc.)
22:23:45 <PrecisionGuy> how do you grab the integer value of a Token type variable?
22:23:46 <spearman> updated cabal but still get the error http://lpaste.net/118655 I'm still on GHC 7.8.3 if that makes a difference
22:24:13 <enthropy> PrecisionGuy: you actually have data Token = Token Integer?
22:24:46 <PrecisionGuy> https://gist.github.com/anonymous/0bee371c8b913054a24d
22:24:47 <lpaste> glguy pasted “unimplemented th” at http://lpaste.net/118656
22:24:57 <glguy> trap_exit: ^
22:25:09 <PrecisionGuy> When I have a NumTok how to get the Integer value
22:25:17 <trap_exit> glguy: noted, thanks!
22:25:24 <hypoon> I guess I'll just compile my data in as a separate module like I've been doing. I was just hoping to get away from that, but it'll do. glguy has a good point regarding the program misbehaving if someone borks the file and I use unsafePerformIO...
22:25:32 <PrecisionGuy> without show/read futzing back and forth?
22:25:34 <hypoon> Thanks for the advice, all!
22:25:38 <glguy> good luck
22:25:40 <enthropy> pattern match
22:25:54 <trap_exit> glguy: saved to study later (in middle of coding right now), looks like a template haskell example of how to wrtie __FILE__ and __LINE__ in TH
22:25:56 <trap_exit> which is exactly what I want
22:26:58 <enthropy> http://hackage.haskell.org/package/pseudomacros-0.0.1/docs/PseudoMacros.html
22:27:06 <gfixler> EvanR: looks like diagrams /is/ based around monoids (follow-up to earlier conversation)
22:27:29 <EvanR> it makes sense to me a lot of things are monoids
22:27:29 <hrumph> i have a quetsion. It says in the documents "In many situations, the liftM operations can be replaced by uses of ap, which promotes function application." (i.e. return f `ap` x1 `ap` ... `ap` xn) but in what cases can i *not* use app?
22:27:32 <EvanR> not just diagrams
22:27:43 <gfixler> Almost everything is based around the concept of monoids - http://projects.haskell.org/diagrams/doc/quickstart.html
22:27:47 <gfixler> that's a quote
22:28:18 <gfixler> EvanR: agreed
22:28:54 <hrumph> i.e. in one cases is chaining ap going to give me a different result from using liftMn?
22:28:59 <hrumph> i mean in what cases
22:29:19 <gfixler> EvanR: and in the same section (Philosophy): " One consequence is that diagrams is optimized for simplicity and flexibility rather than for speed; if you are looking to do real-time graphics generation you will probably be best served by looking elsewhere!"
22:29:23 <gfixler> :(
22:29:25 <hrumph> it seems to me that if the monad laws are being rigorously observed everything should be good but is this not so?
22:30:35 <EvanR> gfixler: also "Flexibility, power, simplicity: in general, you can have any two of these but not all three. Diagrams chooses flexibility and power, at the expense of simplicity."
22:31:05 <glguy> hrumph: They're interchangable, the liftM_ functions are superior for partial application, in particular, and are a more direct expression of intent in many cases than rebuilding them with ap
22:31:16 <EvanR> monoidally combining these two statements, we are only left with flexibility
22:31:35 <PrecisionGuy> entrhopy: do I set up a constructor or something? then can use the constructor params like t.i for a Token type's integer param?
22:32:19 <enthropy> PrecisionGuy: unNumTok (NumTok n) = n -- for example
22:32:47 <enthropy> but unless you add some more equations (what number do you get when you're given an Open?)
22:32:56 <enthropy> you can get runtime errors
22:33:05 <hrumph> glguy, well normally when we define an applicative based on a monad we made <*> will be defined just as ap so there's when we do liftM stuff ins't it neater to treat our monad as an applicative at that point and use fmap and <*> ?
22:33:24 <hrumph> glguy, because we'er not using the monad-ness of the monad
22:33:33 <glguy> hrumph: If you're concerned about Applicative/Monad, there are liftA_ functions for you
22:33:58 <PrecisionGuy> 'open' has a "brace" type associated () [] {}
22:34:49 <PrecisionGuy> I wind up with a Token t that could have any of them; pattern matching gets me to the right code but then I need the integer val
22:35:56 <spearman> if i want to upgrade (installed from binaries) 7.8.3 -> 7.8.4, do i need any cleaning up of 7.8.3 before i run make install on 7.8.4?
22:35:59 <Cale> hrumph: In all cases where the Monad instance obeys the laws, there's no difference in terms of the end result. There may be a small performance difference between the two.
22:36:29 <hrumph> Cale, i prefer to view monads as applicatives when i'm not using the power of the monad
22:36:44 <hrumph> but the liftA functions aren't something i had been introduced to till now
22:37:16 <Cale> Oh, also, there's nothing which really guarantees that the Applicative instance coincides with the Monad one, though I guess that's sort of changing.
22:37:28 <hrumph> they may be  more readable in many cases than <$> and <*>
22:37:43 <hrumph> Cale, yeah but i'm told that it really *should*
22:37:48 <Cale> It's possible to have a type which is a Monad and also has an Applicative instance which doesn't correspond to any Monad instance.
22:38:06 <hrumph> Cale, if it doesn't then your code shold be rejected by other haskellers sort of thing
22:38:09 <Cale> and there are even cases where it's maybe not a terrible thing to take advantage of that
22:38:43 <hrumph> cale i think in that case you should define a new type so as not to confuse people
22:39:14 <hrumph> (IMO)
22:40:50 <enthropy> PrecisionGuy: I don't get it. When you pattern match on the NumTok constructor, that Integer is right there for you to bind to a name you like
22:42:10 <enthropy> that's done by the function I wrote for you (n is the Integer in there)
22:44:00 <PrecisionGuy> OK thanks let me try it
22:45:05 <PrecisionGuy> *splut* got it thanks enthropy
22:45:37 <PrecisionGuy> was using (NumTok _) not realizing I could plunk an n in there to use
22:46:06 <PrecisionGuy> Lots of imperative cruft to get out of my brain to get this going ... thanks much
23:04:33 <Pamelloes> Why does the expression "... >> return $ ..." not compile while "... >> return (...)" does? Shouldn't they be the same?
23:05:20 <Iceland_jack>     (... >> return) (...)
23:05:21 <Iceland_jack> versus
23:05:21 <Iceland_jack>     (...) >> (return (...))
23:05:50 <Iceland_jack>     infixr 0 $
23:05:50 <Iceland_jack>     infixl 1 >>
23:05:50 <Iceland_jack> means that (>>) has higher precedence than ($)
23:06:01 <Iceland_jack> You can find those by running ':info $' and ':info >>'
23:07:04 <Pamelloes> Alright, that makes a lot of sense. Is there an easy way to eliminate those parentheses, or should I just accept their existance?
23:07:38 <Iceland_jack> You can use (<$) but it looks fine as is
23:07:56 <glguy> Or use do-notation
23:08:14 <Iceland_jack> Or that:
23:08:15 <Iceland_jack>     do ...
23:08:15 <Iceland_jack>        return $ ...
23:08:25 <Pamelloes> Yeah. I'll stick to parentheses.
23:08:47 <Pamelloes> Interestingly enough I'm using that line inside do notation.
23:11:03 <vanila>     Could not find module `Control.Monad.State'
23:11:11 <vanila> who took the state monad!
23:11:27 <Pamelloes> Are you using cabal?
23:14:19 <qubitcoder> Hi everyone. I'm experimenting with the Hacker News API for Haskell ('hackernews' package). When I run the 'main' function from within 'cabal repl', everything works fine--the network request returns the expected result. But when I run the program using 'cabal run'--or 'cabal build'--the code fails with a connection error. Has anyone encountered something similar? For instance, the simple example on the GitHub page runs fine
23:14:19 <qubitcoder> inside the REPL, but otherwise returns 'Left ConnectionError'. (https://github.com/dmjio/hackernews). I'm guessing that something isn't being linked? Thanks for any pointers :-)
23:21:27 <glguy> qubitcoder: Are you doing this on Windows?
23:27:03 <qubitcoder> glguy, I'm running Ubuntu Server 14.10
23:29:18 <qubitcoder> glguy, To clarify, I"m running Ubuntu inside a virtual machine atop OS X. I change the VMWare network setting from NAT to bridged, but still had the same issue.
23:29:19 <glguy> qubitcoder: Try compiling with the threaded runtime
23:29:27 <glguy> ghc-options: -threaded
23:29:33 <glguy> and that should get things going for you
23:32:18 <qubitcoder> glguy, Marvelous! That did it. Thanks :)
23:52:24 <shachaf> roconnor: Do you remember talking about holesOf ( http://hackage.haskell.org/package/lens-4.7/docs/Control-Lens-Traversal.html#v:holesOf ) long ago?
23:52:38 <shachaf> (This is maybe more of a #-lens question but you're not in there.)
