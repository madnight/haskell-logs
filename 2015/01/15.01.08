00:00:08 <Hijiri> oh, the class is only winter
00:00:10 <Hijiri> damn
00:00:17 <tolt> I'm excited for a beginning haskell book that goes further. I think it's a great idea.
00:00:48 <tolt> that said, I'm not the target. I only write haskell at work.
00:00:57 <Navarth> I am trying to understand the purpose of get and put in the state monad. So, if I have s <- get in a do block, what exactly is happening here? Is s assigned to the function inside State?
00:01:38 <bitemyapp> tolt: hrm, okay. Well thanks for asking about it.
00:02:15 <tolt> Yeah. Sorry I can't be of more help. I'll still read it! Can't read enough.
00:02:34 <bitemyapp> tolt: awesome. :)
00:06:07 <tolt> If someone sent me a private message they should resend it. The client on my phone closed.
00:10:31 <KoreaPanda> hi
00:11:27 <tzaeru> ungh.. the constant bashing of other languages (or the reader on occasion) and paradigmas in learning material referenced to by haskell.org is getting really under my skin.
00:11:31 <DblZ> I have zero motivation to learn haskell really xD
00:11:45 <tzaeru> it'd be understandable as an ironic joke if it happened like a few times. but it happens pretty often.
00:11:48 <shachaf> tzaeru: That sounds like a problem. :-(
00:11:56 <shachaf> Any specific places? If it's on the wiki you can fix it.
00:12:24 <tzaeru> it's mostly in external material.
00:12:35 <shachaf> Where?
00:14:41 <shachaf> I think there's entirely too much of "I like my thing and your thing isn't my thing therefore it's bad" attitude in some places.
00:15:02 <shachaf> (Which is distinct but sometimes looks similar to pointing out legitimate issues in other things and how your thing fixes them.)
00:15:33 <tdammers> shachaf: it's called "Not Invented Here". A well-understood yet ubiquitous antipattern.
00:15:54 <tzaeru> it can sound a bit nitpicky when I mention only one document, but most recently I opened CIS 194: Introduction to Haskell, which is actually a pretty nice introduction
00:16:06 <KoreaPanda> how is it different monad & monoid??
00:16:08 <tzaeru> but it also has multiple instances of lines like ""Haskell" > "C++""
00:16:10 <shachaf> tdammers: That's not what I'm talking about.
00:16:14 <vanila> KoreaPanda, monoid is a lot simpler
00:16:21 <KoreaPanda> for ex?
00:16:53 <vanila> tzaeru, I think it's a blub problem
00:17:31 <tzaeru> and there are constant references how other languages don't have good enough this and that, and so on. it wouldn't really be an issue if the tone was bringing up the good sides of Haskell.
00:17:46 <vanila> tzaeru, one person find themself most productive with langauge X so they tell everyone its the best language
00:18:02 <tzaeru> but equally often the tone is bringing up bad sides -- or sides the writer doesn't like -- of other, specific languages :P
00:18:05 <tdammers> shachaf: re-read scrollback, you're right. Still kind of related though, although on a different level.
00:18:33 <tzaeru> vanila, sure, that's natural. but IMO it's over-pronounced in documents referenced to by official language site.
00:18:37 <KoreaPanda> i'm messy because different monad and monoid..
00:18:44 <kosmikus> shachaf: if you're referring to me in any way, then I'm sorry
00:19:00 <shachaf> kosmikus: ?
00:19:08 <shachaf> kosmikus: No, the thing tzaeru talked about.
00:19:27 <kosmikus> shachaf: ok then
00:19:58 <KoreaPanda> I'm confused these words.. monoid & monad & applicative functor...
00:20:04 <vanila> KoreaPanda, well a monoid has a unit e and an associative operation *, i.e.   (x * y) * z = x * (y * z)
00:20:13 <vanila> and the unit is like: e * x = e,  x * e = x
00:20:13 <tzaeru> I don't quite recall any C# document that went on its way to make point of how Java in specific has worse OOP implementation than C# :P
00:20:17 <vanila> does that help at all?
00:20:27 <kosmikus> tzaeru: it's tricky to "objectively" compare language features. i.e., sometimes, it helps to relate features in different languages.
00:20:35 <kosmikus> tzaeru: "better" / "worse" is usually not a good classification, agreed.
00:20:38 <KoreaPanda> vanila , thanks!
00:20:50 <tzaeru> sure, you do need to do such comparisons, particularly when reaching out to people who already have the context.
00:20:53 * hackagebot authenticate-oauth 1.5.0.2 - Library to authenticate with OAuth for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.5.0.2 (MichaelSnoyman)
00:20:59 <vanila> a good example is monoid with e = [], and * = ++
00:21:11 <vanila> > "ex" ++ ("am" ++ "ple")
00:21:12 <lambdabot>  "example"
00:21:16 <vanila> > ("ex" ++ "am") ++ "ple"
00:21:17 <lambdabot>  "example"
00:21:30 <vanila> > "foo" ++ []
00:21:32 <lambdabot>  "foo"
00:21:51 <rom1504> > [] ++ "foo"
00:21:52 <lambdabot>  "foo"
00:22:01 <vanila> another nice one is functions,  e = id, and  * = .  composition
00:22:56 <KoreaPanda> vanila, oh thanks ~ I understand your words
00:23:46 <tzaeru> one of the good things in LYAH is actually that it doesn't keep drawing comparisons to other *specific and named* languages all the time :P
00:23:47 <rom1504> (it's e * x = x ofc, not e * x = e as written above)
00:23:55 <tzaeru> even though I otherwise don't fancy its style too much
00:25:08 <kosmikus> tzaeru: yes, I think it's usually better to explain and show the features of Haskell, without in any way trying to bash other languages
00:25:18 <kosmikus> tzaeru: I usually just point out "differences" or "common misconceptions"
00:25:33 <kosmikus> tzaeru: and I also don't hesitate to say if I dislike a particular feature in Haskell
00:26:27 <KoreaPanda> have a nice dinner everyone!!
00:27:14 <tzaeru> kosmikus, yeah. it'd also be pretty OK to name specific language features and neutrally make point that the feature is attempted to be implemented better in Haskell through the change of paradigm..
00:28:57 <tzaeru> there's rarely a need to actually name the language that is being compared to, as most compared features are pretty similarily implemented in the major OOP languages.
00:29:24 <tzaeru> and if there is, usually leaving out adjectives like "awkward" or "annoying" is good from a pedagogical standpoint ^^
00:32:30 <kosmikus> tzaeru: agreed on all points
00:36:48 <d3lxa_> question: how can I import toList from here https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Exts.html#v:toList this won't work "import GHC.Exts (toList)" why?
00:38:27 <shachaf> d3lxa_: Perhaps because it's a method; try import GHC.Exts (IsList(toList))
00:38:52 <d3lxa_> shachaf: Main.hs:15:18: Module `GHC.Exts' does not export `IsList(toList)'
00:39:41 <phoenix1995> I hear Haskell is for geniuses, by geniuses. I am not high IQ, can I also learn it?
00:39:57 <ab9rf> no, you need an IQ of at least 185 to comprehend haskell
00:40:00 <shachaf> d3lxa_: Are you sure you have the right version?
00:40:43 <d3lxa_> shachaf: what do you mean?
00:40:43 <phoenix1995> ab9rf: Thanks for help. One of my friend who is becoming fail in exam tried to learn it and said it was only for good mind people.
00:41:05 <ab9rf> phoenix1995: that answer is, of course, nonsense
00:41:14 <shachaf> d3lxa_: Are you using a recent enough ghc/base that GHC.Exts exports toList at all?
00:41:19 <ab9rf> i only have an IQ of 163 and i still manage
00:41:24 <d3lxa_> shachaf: 7.6 is not recent enough?
00:41:34 <Freundlich> I'm trying to install idris and I get errors because Control.Monad.Error is deprecated.
00:42:24 <shachaf> d3lxa_: Probably recent enough. What's your full code and full error?
00:42:54 <d3lxa_> shachaf: that's the full error
00:43:18 <d3lxa_> shachaf: I guess I'm better of using toList from the vector package, because that's what I wanted to do but too lazy to depend explicitely on it
00:43:58 <shachaf> What's your full code?
00:44:40 <Freundlich> So, is ghc-7.8 not supported by Idris? Should I disable -Werror (if so, how do I do it)?
00:45:55 <d3lxa_> shachaf: the full code is a bit lengthy, interesting bit: http://sprunge.us/DbSV
00:47:07 <shachaf> d3lxa_: If you make a file with "module Foo where import GHC.Exts (IsList(toList))", same error?
00:47:39 <aphorisme> edwardk, are you there?
00:48:07 <d3lxa_> shachaf: yes
00:48:52 <d3lxa_> I'm sure GHC.Exts shouldn't be used directly but I don't remember how it is done usually
00:49:29 <shachaf> d3lxa_: Oh, it's indeed the version thing.
00:50:56 <d3lxa_> shachaf: seems ‚â• 708, here https://hackage.haskell.org/package/dlist-0.7.1/docs/src/Data-DList.html see import GHC.Exts
00:51:33 <shachaf> Right, 708 is GHC 7.8.
00:52:00 <d3lxa_> shachaf: should I use toList from vector then?
00:52:49 <shachaf> That's a reasonable option.
00:52:58 <d3lxa_> urgh, explicit dependency :(
00:53:23 <d3lxa_> is there a way to know when a method is first available in a package? or better auto-detect the lowest compatible version?
00:55:01 <tdammers> d3lxa_: I think people are working on that, but haven't seen anything production-ready
00:55:30 <d3lxa_> tdammers: ok and for now? the wordaround? :D
00:55:35 <d3lxa_> *workaround
00:57:29 <tdammers> d3lxa_: well, you can find a version that works, and then hope the author uses correct versioning
00:58:06 <d3lxa_> there is no way to know when a method and its signature was first introduced?
01:01:57 <tdammers> not that I know of
01:02:11 <tdammers> you could probably crawl hackage and check
01:06:36 <d3lxa_> this tool should already exist‚Ä¶ I'm skeptic it doesn't
01:06:46 <tdammers> it might, actually
01:08:08 <mpickering> how would you use it?
01:08:30 <d3lxa_> query Data.Vector.toList
01:10:28 <mpickering> what would you do with that information?
01:10:46 <d3lxa_> put it into my cabal dep
01:11:08 <mpickering> a function can have the same name and type signature but different semantics
01:11:37 <d3lxa_> in my case, that's hardly possible
01:11:44 <d3lxa_> considering vector is a sane package‚Ä¶
01:13:36 <calvinx> I thought I understood ‚Äú$‚Äù but I cannot explain to myself what is the difference between ‚Äú$‚Äù and ‚Äú.‚Äù   Reference - http://lpaste.net/118052 Why does both give the same results
01:13:37 <calvinx> ?
01:14:28 <tdammers> :t (.)
01:14:29 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:14:32 <tdammers> :t ($)
01:14:33 <lambdabot> (a -> b) -> a -> b
01:14:49 <tdammers> calvinx: ^ does that make sense to you?
01:15:22 <calvinx> I understand ‚Äú:t ($)‚Äù but I don‚Äôt understand the former
01:15:33 <tdammers> (.) is function composition
01:15:37 <tdammers> do you know what that is?
01:16:03 <calvinx> f . g . h = f ( g ( h ) ) ?
01:16:26 <d3lxa_> ^ reverse the nesting
01:16:28 <sivteck> (f . g) h = f ( g ( h ) )
01:16:32 <tdammers> (f . g) x = f(g x)
01:16:39 <tdammers> so yes, that.
01:16:55 <calvinx> magic.
01:17:09 <calvinx> It‚Äôs hard to imagine two functions ‚Äúcomposing‚Äù together.
01:17:15 <tdammers> function composition combines two functions such that the output of the right-hand operator becomes the input to the left-hand one
01:17:28 <bollu> calvinx: think of it as joining pipes ;)
01:17:28 <tdammers> are you familiar with javascript?
01:17:51 <calvinx> rudimentary javascript.
01:18:05 <d3lxa_> h $ g $ f $ x = h . g . f $ x  << did I got this right?
01:18:06 <calvinx> pipes make a good analogy.
01:18:25 <tdammers> function compose(f, g) = { return function(x) { f(g(x)); } }
01:18:28 <tzaeru> mh, I'm trying to make a simple image-modification (initially as simple as just make a picture darker) using Juicy.Pixels, but few parts are still a bit cryptic to me and don't translate well :P (and I guess it's possible I've misunderstood something very rudimentary, too)
01:19:34 <calvinx> I see.
01:19:53 <calvinx> So (f . g) x = f(g x)
01:20:10 <tdammers> yes
01:20:24 <calvinx> And so this ‚Äúh $ g $ f $ x = h . g . f $ x‚Äù appears correct?
01:20:49 <tdammers> $ is a pretty useless operator by itself, all it does is change precedence
01:21:37 <bollu> calvinx: yes, because h $ g $ f $ x = h(g(f(x)) = h((g . f)(x)) = (h . (g . f))(x) = (h . g . f)(x)
01:21:44 <calvinx> which is important‚Ä¶. ?  For instance, `filter id $ zipWith (/=) "GGACG" "GGTCG‚Äù` won‚Äôt work with the $
01:22:06 <calvinx> because I needed zipWith to execute first
01:22:11 <calvinx> before using filter to apply id later
01:22:53 <calvinx> *won‚Äôt work WITHOUT the $, I meant.
01:23:42 <calvinx> This makes things super clear - `h $ g $ f $ x = h(g(f(x)) = h((g . f)(x)) = (h . (g . f))(x) = (h . g . f)(x)` thanks for the example!
01:23:50 <merijn> FYI
01:23:59 <merijn> repeated $ is recommended against
01:24:07 <merijn> Prefer repeated use of . with a final $
01:24:15 <calvinx> AH....
01:24:19 <calvinx> that‚Äôs a good tip.
01:24:31 <calvinx> Can I also ask why repeated $ is recommended against?
01:24:36 <merijn> Why? Because it's always safe to pull use of . out into a local definition, this doesn't apply to $
01:25:00 <calvinx> So stylistically http://lpaste.net/118052, I should always choose to write the former than the latter.
01:25:21 <merijn> calvinx: Right
01:25:53 <calvinx> merijn: makes sense re pulling . out into local definition.
01:26:00 <calvinx> thanks a lot guys. appreciate the clarification.
01:26:14 <merijn> For example, suppose you have "f . g . h . i . j $ x" you can take any arbitrary part of the pipeline and make it a local definition, for example "let foo = g . h . i in f . foo . j $ x"
01:26:27 <merijn> due to the associativity of $, that doesn't apply to repeated use of $
01:26:37 <calvinx> I see.
01:26:45 <zipper> How do people upgrade their packages in haskell?
01:27:08 <tdammers> zipper: cabal sandbox all the things
01:27:22 <zipper> tdammers: then when one wants to upgrade?
01:27:25 <tdammers> zipper: then once inside the sandbox, live dangerously
01:27:26 <merijn> calvinx: Which is important if, like me, you first write *really* long complex lines and then slowly refactor by moving parts into local definitions :)
01:27:35 <zipper> delete sandbox and install dependencies?
01:27:49 <tdammers> zipper: force upgrades, do stuff, and if things break, delete sandbox and recreate
01:27:50 <calvinx> merijn: I do it the other way around. I break down a problem into smaller functions and gradually compose them
01:27:51 <zipper> I mean delete packages in sandbox
01:27:59 <calvinx> So I seldom write long complex lines.
01:28:16 <tdammers> zipper: nah, I tend to just throw away the entire sandbox when in-place upgrading doesn't work
01:28:25 <calvinx> I form a long complex line through iterative composition.
01:28:35 <merijn> calvinx: That's the preferred way, but I've started replacing shell scripting with just small haskell scripts and those tend to start out like ugly messes, like shell scripts tend to ;)
01:28:45 <gamegoblin> @pl \a b c -> f $ g a b c
01:28:45 <lambdabot> ((f .) .) . g
01:29:48 <zipper> What about my ~/.ghc/ It has *7.8.3 and *7.8.4 some packages seem to be in the previous one and that seems to be causing issues. In this case ghc-mod
01:29:58 <calvinx> that‚Äôs nice. ‚Äú@pl‚Äù is a good trick
01:30:07 <zipper> What is ~/.ghc for?
01:30:29 <calvinx> it contains ghci.conf which allows you to customize your ghci if you like
01:30:56 * hackagebot hit 0.6.3 - Git operations in haskell  http://hackage.haskell.org/package/hit-0.6.3 (VincentHanquez)
01:31:46 <zipper> Yeah I've also seen that it has a lot of confs for a lot of packages.
01:32:11 <calvinx> I spent one whole day yesterday configuring my vim and ghci for haskell. It‚Äôs definitely paying off, especially the invaluable hasktags and neocomplete (autocomplete)
01:34:10 <merijn> zipper: .ghc is where ghc tracks which libraries are installed
01:34:21 <merijn> cabal does not, in fact, track installed libraries
01:37:14 <n00b___> in hsndfile there's a function like this: hGetContents :: (Sample e, Buffer a e) => Handle -> IO (Info, Maybe (a e))
01:37:20 <tasker> Is there any reason you wouldn't use an Unboxed vector, if you just wanted it to hold doubles ?
01:37:30 <n00b___> in a d block, i'm trying to call this function like this: x <- hGetContents h
01:37:35 <n00b___> (where h is some Handle)
01:38:08 <n00b___> but i don't understand the error i get: "No instance for (Buffer a0 e0) arising from a use of `hGetContents'"
01:40:21 <n00b___> it's as if i have to supply the type parameters for the return value somehow
01:40:21 <n00b___> s/d block/do block/
01:44:40 <pavonia> n00b___: It doesn't know what instance for Buffer to choose because the types a and e are unknown/too general
01:44:41 <steffen> Short Question: Will such sideeffecting code be "executed", even if I
01:44:41 <steffen> don't use the resultvalue: '_ <- makeRequest'?
01:45:42 <matematikaadit> steffen: yes.
01:45:56 * hackagebot stackage 0.5.0 - "Stable Hackage," tools for creating a vetted set of packages from Hackage.  http://hackage.haskell.org/package/stackage-0.5.0 (MichaelSnoyman)
01:46:08 <steffen> matematikaadit: Thanks :)
01:46:09 <pavonia> Not if it's a lazy action
01:46:50 <zipper> Well my emacs haskell set up was fine until a few days ago. Now it gives a compiler related error saying it can't find a file I know exists /usr/lib/ghc-7.8.3/settings
01:47:09 <zipper> Thing is there is an upgrade and now my system is on ghc-7.8.4
01:47:23 <zipper> I think a lot of parts still are looking for ghc-7.8.3
01:47:37 <zipper> How do you people handle such issues.
01:48:30 <tdammers> zipper: I install ghc and haskell-platform from debian, then upgrade cabal-install globally, and pretty much everything else happens in sandboxes
01:49:11 <zipper> tdammers: Does cabal upgrade make packages look for the new version of ghc?
01:49:25 <zipper> Because my emacs haskell packages are in a sandbox
01:49:33 <zipper> I'm feeling clever about that now.
01:51:11 <n00b___`> pavonia: yes, that makes sense. but i don't understand how to give it some type parameters
01:51:48 <zipper> tdammers: cabal tells me to use cabal install. "The 'cabal upgrade' command has been removed because people found it confusing and it often led to broken packages."
01:51:55 <zipper> You probably need to know about that.
01:52:01 <tdammers> zipper: don't know, really... I've never used multiple ghc versions alongside on the same system
01:52:22 <tdammers> zipper: oh, yeah, and indeed, cabal upgrade is not really a thing anymore
01:52:46 <n00b___> pavonia: yes, that makes sense. but i don't understand how to give it some type parameters for its return value
01:53:03 <dcoutts_> zipper, tdammers: if you know what you're doing, you can still ask cabal to try upgrading dependencies.
01:53:07 <tdammers> zipper: I thought you meant "change the version requirements for the dependencies in your .cabal file and then run cabal install again", or "cabal install specific newer version"
01:54:01 <tdammers> dcoutts_: sure, but so far, I haven't found it to be worth the hassle figuring our dependency conflicts when I can just recreate the sandbox and have cabal do its thing
01:54:45 <pavonia> n00b___: The easiest would be to use the result value in such a way that GHC can figure out the types
01:55:30 <pavonia> n00b___: Or you could give an type annotation to the pattern which needs an extension enabled, I think
02:02:07 <zipper> tdammers: It's not my wish to use multiple ghc versions.
02:02:32 <zipper> tdammers: Just that the previous ghc version created some dirs and some packages depended on it directly
02:02:38 <zipper> tdammers: I just found out.
02:02:39 <merijn> zipper: What's "ghc --version" print?
02:02:46 <merijn> zipper: That's not what's happening at all
02:02:57 <merijn> zipper: GHC uses a per-version package database
02:03:10 <zipper> merijn: 7.8.4
02:03:10 <merijn> zipper: i.e. you're new 7.8.4 should just not have anything installed
02:03:17 <merijn> *your
02:04:16 <zipper> merijn: Well 7.8.4 isn't very new it seems. I'm on archlinux
02:04:17 <merijn> Which tools are you using with emacs? ghc-mod?
02:04:30 <zipper> It seems that I've been having it for a while. Yes Ghc-mod
02:04:31 <merijn> 7.8.4 was released a week ago, at most
02:05:02 <merijn> ghc-mod uses the GHC API, afaik. Which means that ghc-mod build using 7.8.3 will try to compile all source files you edit using ghc 7.8.3
02:05:25 <merijn> Try rebuilding ghc-mod using 7.8.4 and using that version
02:05:57 * hackagebot hspec-server 0.3.2 - Test Framework for checking server's status  http://hackage.haskell.org/package/hspec-server-0.3.2 (junjihashimoto)
02:07:52 <zipper> merijn: I'm still upgrading with `cabal install ghc-mod`
02:08:43 <zipper> merijn: So what do you do instead of manually rebuilding all your packages with newer versions of ghci
02:11:39 <merijn> I tend to upgrade like 2-3 times a year max, so I just nuke everything and start from scratch
02:12:31 <zipper> Also about rebuilding, all I have is the binary for ghc mod and a few .hi files in `.cabal-sandbox/lib/x86_64-linux-ghc-7.8.3/ghc-mod-5.1.1.0/
02:12:32 <zipper> merijn: Don't I need source to rebuild? ^
02:14:31 <merijn> "cabal install ghc-mod"?
02:14:48 <Itkovian> zipper the source will de downloaded for you?
02:15:36 <dgomez> hi, long day, finished coursework but before bed I really wanted this bit of code from earlier to execute
02:15:44 <dgomez> tried modifying w/wout Main, but I still get the same parsing error on line 10 (incorrect ident/mismatched brackets) isn't it all in the appropriate scope as is? plus I'm pretty sure it still might not even make sense...
02:15:57 <lpaste> dgomez pasted ‚Äúwhy won't it parse?‚Äù at http://lpaste.net/118054
02:16:47 <merijn> dgomez: You have a do block at the top level of an instance declaration, that doesn't make sense
02:16:50 <geekosaur> why would that parse?
02:17:06 <tdammers> instance Something where do ... -- is not valid Haskell, that's why
02:17:07 <merijn> Also, your instance declaration only mentions a type...
02:17:09 <dgomez> geekosaur: tell me why it wouldn't...
02:17:15 <merijn> tdammers: Is too
02:17:19 <geekosaur> that, and it has a type signature in an odd place and a == which perhaps wants to be a = and ...
02:17:26 <merijn> tdammers: NullaryTypeclass \o/
02:17:46 <infinity0> some cryptographic libraries allow for forward secrecy by doing controlled deletion of secrets. is there a way to do this operation in haskell?
02:17:56 <infinity0> and/or another fp lang
02:17:58 <merijn> dgomez: Because it looks like your code was generated by a markov process over haskell source
02:18:31 <tdammers> my guess was generous amounts of alcohol
02:18:36 <tdammers> but markov works too
02:18:40 <zipper> merijn: Yes I call that upgrading not rebuilding :)
02:18:40 <dgomez> merijn: why doesn't a do block at the top level of an instance make sense?
02:18:42 <tdammers> (sorry if that came over offensive)
02:18:43 <merijn> infinity0: I've had this discussion with people, and honestly, I would barely know how to do that in C, in haskell it'd be...ugly
02:18:59 <merijn> dgomez: Because instance declarations can only have declarations
02:19:05 <tdammers> dgomez: instances are generally of the pattern 'instance Typeclass Type where method = methodDefinition
02:19:13 <infinity0> merijn: well in C, as a best-effort basis you could overwrite the memory multiple times like what shred does with disk
02:19:39 <infinity0> if you're ultra-safe you could use a TPM like pond does, for i'd be happy with the former for haskell
02:19:41 <merijn> infinity0: You'd *also* have to ensure said memory wouldn't be swapped to disk, etc.
02:19:44 <tdammers> infinity0: controlled deletion is only possible when you have full control over the recipient's system anyway
02:20:03 <infinity0> ah sure. some systems let you mark memory as non-swappable.
02:20:05 <tdammers> infinity0: or when the recipient cooperates
02:20:17 <infinity0> tdammers: yes, well we assume that for these libraries
02:20:40 <infinity0> for that to work, the local side must "do its part"
02:20:45 <merijn> infinity0: Right, but in general this is a *hard* problem, doing this in haskell will, at the very least, involve FFI calls to the OS to do stuff like marking pages as unswappable, etc.
02:20:57 * hackagebot relational-query 0.4.0.0 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.4.0.0 (KeiHibino)
02:21:22 <tdammers> infinity0: but in that case, just giving the recipient the tools to securely wipe the message and request them to actually use them is probably about as good as it gets, right?
02:21:32 <tdammers> infinity0: everything else is just convenience
02:21:37 <infinity0> tdammers: you need to do it locally too, and that's what i'm asking here
02:21:46 <infinity0> "asking the recipient" is pointless if you don't also do it locally
02:21:50 <tdammers> oh, ofc
02:22:15 <tdammers> I assumed that deleting your local copy was a given
02:22:26 <infinity0> merijn: ok so i guess there needs to be a FFI library for this. another side of my question is what should the API look like on the haskell side?
02:22:47 <merijn> infinity0: It'll probably be an IO based ByteString/Storable API
02:22:59 <geekosaur> dgomez, an instance is not a random chunk of code that executes at some random time. an instance is a set of bindings which are stored in a dictionary indexed by type when a typeclass is resolved (and you ae missing the typeclass in your instance declaration)
02:23:01 <tdammers> I guess the actual juice of the problem boils down to "avoid persistence at all levels"
02:23:06 <geekosaur> this code makes no sense
02:23:15 <merijn> You'd have to mmap + pin memory, do direct IO operations to read/write and eventually wipe
02:23:47 <lpaste> dgomez revised ‚Äúwhy won't it parse?‚Äù: ‚Äú2‚Äù at http://lpaste.net/118054
02:23:50 <merijn> infinity0: If you wanna ensure wiping you'd want to use some sort of bracket construction (but see the long, LONG discussion on async exceptions if you plan to mix those two)
02:24:11 <dgomez> well this only gave me an error stating that the method isn't visible?
02:24:29 <dgomez> tdammers: does that follow the instance pattern better?
02:24:44 <merijn> dgomez: I don't think anyone here has the time to walk you through "semi-supervised" learning of haskell syntax. I recommend picking up a book
02:25:13 <infinity0> merijn: what is a bracket construction?
02:25:49 <zipper> Well that ghc-mod error is gone. I got ` cannot satisfy -package-id doctest-0.9.11.1-...` This however is specific to this package/sandbox in other packages I am getting similar errors but for different packages
02:26:07 <tdammers> dgomez: yes, but it still won't work
02:26:11 <dgomez> merijn: i meanÖi picked it up :p
02:26:18 <zipper> cannot satisfy -package-id -<package name and version>
02:26:31 <tdammers> dgomez: or actually, you're still saying "StillHere is an instance"
02:26:31 <zipper> This issue is not being solved by a reinstall
02:26:33 <merijn> infinity0: I meant Control.Exception.bracket
02:26:33 <zipper> SMH
02:26:42 <zipper> I think I'll delete the sandbox and restart
02:26:44 <infinity0> ah ok thanks
02:26:48 <tdammers> which doesn't make sense, because you need to say "StillHere is an instance of SomeTypeclass"
02:27:08 <infinity0> merijn: another problem my friend had is that, he previously was able to write the protocol in terms of pure functions, with a "state" object as input
02:27:27 <infinity0> and it doesn't seem very easy to keep these functions pure, when we need to do this deletion business. any ideas on that?
02:27:37 <tdammers> dgomez: I really really wonder how you got this point in the first place... I suggest you take an existing "Hello world" program that compiles and works and everything, and then build from there
02:28:27 <merijn> infinity0: I would straight up say that "purity" and "memory deletion" like this are fundamentally incompatible
02:28:28 <dgomez> geekosaur: not sure how you would know but I was aware I was missing a type class; but Im not sure what type class to point to?
02:28:55 <merijn> infinity0: Unless you had something like linear types and compiler support for wiping memory
02:29:09 <infinity0> hmm, that seems intuitive to me too. i had hoped there might be a way around this
02:29:10 <dgomez> tdammers: who r u? :p
02:29:13 <infinity0> oh, what are linear types?
02:29:21 <merijn> infinity0: Because overwriting/deleting memory is essentially that, mutation
02:29:57 <dgomez> tdammers: if you feel the need to complain -- i must be doing something right
02:29:59 <merijn> infinity0: linear types are types that can do things like enforce lifetimes/single use/deletion, but haskell doesn't have them :)
02:30:24 <merijn> In fact, I'm not sure I know of any mainstream language that does (for a broad definition that would call haskell mainstream)
02:30:34 <tdammers> dgomez: I don't mean to insult you, or complain. I just observe that you have trouble getting basic Haskell syntax right, and I suggested that you start with the basics
02:30:34 <merijn> Clean has uniqueness types, which are somewhat related
02:30:41 <infinity0> i see thanks, i'll look into it
02:30:53 <infinity0> one option is maybe we can rearchitect the code so the main protocol functions take e.g. (main input, object_to_be_mutated) and return (output, mutations_to_execute)
02:31:06 <infinity0> and some surrounding context actually executes the mutations
02:31:29 <infinity0> that is sort of pure, right? ¬¨.¬¨
02:31:47 <merijn> infinity0: Well, alternatively you could use a "withSecret :: (Secret -> Output) -> IO Output" function that hides the allocation/deletion from the pure function
02:32:19 <merijn> Which is a very bracket-like "alloc-use-free" kind of pattern
02:32:36 <merijn> Although you have to enforce that Output can't leak the Secret
02:33:06 <dgomez> tdammers: i understand
02:33:26 <maukem> inb4 ST
02:33:29 <infinity0> merijn: cool, thanks for the info and suggestions. i'll talk it over some more with my friend (who is actually writing the code)
02:34:18 <merijn> maukem: I don't think ST is powerful enough for wiping memory locations?
02:34:28 <tdammers> dgomez: are you using any introductory Haskell learning resources?
02:35:18 <tdammers> merijn: maukem: if I had to build something like that in Haskell, I'd probably write an FFI module around a C library that guarantees memory wipes
02:35:23 <tdammers> it'd still be hard
02:35:58 * hackagebot show-type 0.1 - convert types into string values in haskell  http://hackage.haskell.org/package/show-type-0.1 (Kinokkory)
02:37:09 <maukem> merijn: nah, but it avoids leaking STRefs
02:37:20 <zipper> Anyone familiar with such errors "BUG<command line>cannot satisfy -package-id ..."
02:37:57 <merijn> zipper: This is in an existing cabal sandbox?
02:37:59 <balor> I have data I'd like to draw as a node-link diagram i.e. a graph.  Should I create a Data.Graph or a Data.Graph.Inductive.Graph (using FGL) or something else?
02:38:07 <merijn> Have you tried running "cabal clean" before building?
02:38:55 <zipper> merijn: No I haven't I am getting this error from within emacs from ghc-mod
02:39:07 <zipper> merijn: It is in a sandbox
02:39:29 <zipper> merijn: Different sandboxes have similar errors referring to different package names.
02:39:32 <n00b___> pavonia: yes, that makes sense. but i don't understand how to specify the type parameters for the return value
02:40:12 <zipper> merijn: I haven't tried building.
02:40:40 <merijn> tbh, I don't know how ghc-mod interacts with sandbox
02:40:41 <pavonia> n00b___: What do you want to do with the result? Based on that you need to know what return types you want
02:42:46 <merijn> n00b___: Just add an annotation?
02:42:55 <merijn> > read "True" :: Bool
02:42:56 <lambdabot>  True
02:44:12 <zipper> merijn: Ok I ran cabal clean then cabal configure and now it says there is a "GMEIO exception" error with my /dist/setup-config: error is: hGetContents invalid argument (invalid byte sequence)
02:45:02 <dgomez> geekosaur: i hope i didn't offend you, to rephrase what I mean to emphasis is i didn't understand the significance of neglecting to put a type class
02:45:40 <zipper> merijn:  sorry --> it's `GMEIOException`
02:45:43 <dgomez> tdammers: yes I am, but its obvious its me not structuring my learning appropriately
02:45:58 * hackagebot htoml 0.1.0.2 - Parser for TOML files  http://hackage.haskell.org/package/htoml-0.1.0.2 (cies)
02:46:39 <pavonia> n00b___: Looks like you have to use an extra package to even get some instances of that Buffer class, e.g. hsndfile-vector
02:46:49 <n00b___> pavonia: ah ok, so maybe the type inference system could solve this if it can work out what i'm doing with the return vale. at the moment i'm just trying to work out how hsndfile works by trying out the functions in a do block
02:47:29 <n00b___> pavonia: thanks. i noticed that library but wasn't sure if i needed it. i'll have a look
02:50:11 <volvo_cap> Hello! Is it okay to ask any haskell-related questions in this channel?
02:50:34 <pavonia> Of course
02:50:44 <volvo_cap> ok. nice! Then I have a question :)
02:50:53 <BillyRhinos> Hi all, I am trying to setup a Stackage LTS installation on a fresh Windows Server 2008R2 install. I tried to install the minimum GHC installer from here https://github.com/snoyberg/minghc#readme, but cabal update keeps crashing (segfault). Anyone had success with this or have any ideas?
02:52:52 <volvo_cap> (+3) has type (+3)::Num a=> a -> a. But then I wonder why  f = (3.0+) . (uncurry  $ flip (/)) has type f::Fractional c => (c, c) -> c and not Fractional c => (c -> c) -> (c, c) -> c
02:52:56 <tdammers> dgomez: yes, that's what I was trying to say. Write something simple before attempting to understand and use typeclasses and such.
02:54:30 <merijn> volvo_cap: Where would the extra function argument go?
02:54:48 <merijn> volvo_cap: I don't understand why you'd expect "c -> c" there?
02:55:01 <volvo_cap> hm, because (+3) has type a->a
02:55:22 <geekosaur> but it is not being applied to something external
02:55:33 <merijn> :t (.)
02:55:34 <geekosaur> it is applied to the result of uncurry $ flip (/)
02:55:34 <lambdabot> (b -> c) -> (a -> b) -> a -> c
02:55:51 <merijn> volvo_cap: "(3.0+)" is just one argument to .
02:56:04 <merijn> :t (.) `asAppliedTo` (3.0+)
02:56:05 <lambdabot> Fractional c => (c -> c) -> (a -> c) -> a -> c
02:56:16 <merijn> :t (.) (3.0+)
02:56:17 <lambdabot> Fractional c => (a -> c) -> a -> c
02:56:28 <merijn> :t uncurry (flip (/))
02:56:29 <lambdabot> Fractional c => (c, c) -> c
02:57:06 <merijn> The '(c, c)' from "uncurry (flip (/))" takes the place of 'a' in "(.) (3.0+) :: Fractional c => (a -> c) -> a -> c"
02:58:06 <merijn> "(3.0+) . uncurry (flip (/)) $ x" == "3.0 + uncurry (flip (/)) x"
02:58:15 <zipper> I want to remove dist/ from my cabal prject. I Should I not? my dist/setup-config file has an error.
02:59:03 <merijn> zipper: dist is completely auto-generated
02:59:11 <pavonia> Removing dist should be safe
02:59:17 <merijn> zipper: The worst thing that can happen by nuking "dist" is needing to reconfigure/rebuild stuff
02:59:39 <zipper> merijn: Thanks
03:00:13 <calvinx> http://lpaste.net/118056 line 4 is obviously wrong and what I am trying to do is to check if the given `carType` to the function `availableModel` is indeed an accepted type in my custom type `Car`. How do I go about doing that?
03:01:15 <maukem> calvinx: you don't
03:01:32 <geekosaur> calvinx, if you get as far as being able to run that code, then the carType is valid
03:01:37 <maukem> this is something the compiler checks for you
03:01:54 <maukem> you don't (and can't) write type checks by hand
03:02:07 <merijn> maukem: You forgot "shouldn't have to" :)
03:02:13 <calvinx> haha . ok.
03:02:46 <maukem> well, you could, kind of
03:02:59 <maukem> carType `elem` [minBound .. maxBound]
03:03:09 <calvinx> AH. sweet.
03:03:21 <maukem> but that's either always true or your instances are wrong
03:03:35 <zipper> merijn: Could my setup-config be looking at files outside the sandbox? It still tells me that my setup-config has an invalid byte sequence
03:03:36 <merijn> calvinx: Basically, only "Toyota" and "Honda" are values of type Car and your function only takes values of type Car, therefore it can only ever get Toyota or Honda
03:03:41 <dgomez> geekosaur: but I'm starting to refresh on it, the point of type classes is for certain operations to be available for values of chosen types
03:03:45 <merijn> calvinx: Anything else would be a type error
03:03:56 <maukem> merijn: (except as currently written it takes String)
03:04:03 <merijn> zipper: Could be a problem with your environment specifying the wrong encoding
03:04:05 <calvinx> what if some where else in my code calls `availableModel Ferrari` ?
03:04:12 <maukem> > Ferrari
03:04:13 <lambdabot>  Not in scope: data constructor ‚ÄòFerrari‚Äô
03:04:15 <merijn> Oh, true
03:04:16 <maukem> calvinx: ^ that
03:04:17 <geekosaur> calvinx, compile time type error
03:04:18 <volvo_cap> Thank you! I almost get it i guess
03:04:18 <calvinx> how to I handle such acception?
03:04:23 <calvinx> *exception
03:04:37 <geekosaur> Ferrari *does not exist* and cannot be specified
03:04:42 <maukem> calvinx: the compiler will complain about Ferrari being undefined
03:05:17 <calvinx> ok. so this is something I shouldn‚Äôt write code for and the compiler will tell me if I am writing some silly unknown type declaration somewhere else
03:05:51 <geekosaur> if you mean you are doing a `read` to turn a String into a Car, then you want something like Text.Read.readMaybe
03:06:07 <SoupE> is there a way to measure module compilation times for a cabal project?
03:06:16 <calvinx> AH!
03:06:17 <geekosaur> which produces a Maybe Car in this case, either something like Just Toyota or Nothing
03:06:20 <zipper> merijn: Where is my environment set? I don't see anything regarding environment in my ~/.cabal/config
03:06:24 <calvinx> that was what I was looking for.
03:06:47 <calvinx> Text.Read.readMaybe
03:07:07 <geekosaur> zipper: environment is an OS thing. on unixlikes try the "env" command, or "set" on Windows
03:07:43 <geekosaur> in this particular case "locale" on unixlikes might also be helpful
03:12:08 <zipper> geekosaur: Anything unusual here? Everything seems to be utf8 http://ix.io/fET
03:12:33 <zipper> Also an almost similar error that didn't get solved it seems http://ubuntuforums.org/showthread.php?t=1686666
03:15:26 <spyzer> hey guys I am new to haskell and was looking into tail recursion. According to this post haskell shouldn't need tail recursion http://stackoverflow.com/a/13052612. But I have created this code for finding maximum in  a list and it does benefit from tail recursion. https://gist.github.com/sharma-abhishek-it/141d4a711cb464555b8a
03:15:36 <spyzer> I have used -O2 to compile both scripts
03:15:49 <spyzer> Tail recursion takes 2s while normal takes 10s
03:16:11 <spyzer> So is that post missing something or am I missing something?
03:17:52 <tdammers> spyzer: you are missing the strictness aspect of it
03:17:56 <maukem> both of those look bad
03:18:01 <zipper> Well this is unusual. I deleted my /dist and then went on without running cabal clean or cabal configure
03:18:20 <zipper> Opened the source in emacs and everything is now working
03:18:30 <njbartlett> Could anybody tell me why a cabal sandbox install can still fail with ‚Äúpackages are likely to be broken by the reinstalls‚Äù. Isn‚Äôt the whole point of sandboxing to avoid this error??
03:18:43 <spyzer> tdammers: Strictness aspect, please a little bit more clarification will help
03:18:49 <zipper> ALso a new dist/ has been genetated with a setup-config
03:18:57 <zipper> and it's having no issue
03:18:59 <spyzer> maukem: so how can it be improved?
03:19:18 <tdammers> spyzer: maxm is lazy
03:19:29 <maukem> spyzer: I'd try main = print (foldl1' max [1..100000000])
03:19:37 <tdammers> it doesn't return a value, it creates a thunk
03:20:22 <spyzer> maukem: ahh that I know about folding from other languages it is just that I am follfowing learnyouahaskell.com and have not yet reached that part besides i thought it will be fun to test tail recursion
03:20:37 <tdammers> maxm' (x:xs) = let y = maxm xs in y `seq` max x y
03:20:43 <tdammers> sorry
03:20:48 <tdammers> maxm' (x:xs) = let y = maxm' xs in y `seq` max x y
03:20:59 <tdammers> something like that
03:21:33 <dgomez> calvinx: could you tell me what line 3 of your example says?
03:21:41 <maukem> maxm (x : xs) = max_r x xs where max_r c [] = c; max_r c (x : xs) = let c' = max c x in c' `seq` max_r c xs
03:22:29 <maukem> I can't quite explain what I'm doing but the point is not tail recursion, it's streaming
03:23:05 <zipper> spyzer: I think what tdammers is saying is your way of doing it was strict. So it was generating the result of the answer as it went by instead of waiting until all is done for it to generate the result.
03:23:08 <maukem> your first solution needs to keep x around until it has computed maxm xs
03:23:16 <zipper> tdammers: am I right up there?
03:23:18 <zipper> spyzer: ^
03:23:28 <matematikaadit> > [1..] >>= flip replicateM [0,1
03:23:29 <lambdabot>  <hint>:1:31:
03:23:30 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
03:23:38 <matematikaadit> > [1..] >>= flip replicateM [0,1]
03:23:39 <lambdabot>  [[0],[1],[0,0],[0,1],[1,0],[1,1],[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,...
03:23:44 <tdammers> zipper: I didn't even read the second solution deeply, just observed that the first one is slow because of excessive laziness
03:23:59 <spyzer> zipper: hmm I think I am getting this concept about laziness let me re-read the code again
03:24:07 <maukem> the second solution is effectively foldl
03:24:15 <maukem> plus some weird stuff with head/tail
03:24:20 <zipper> spyzer: You can't see laziness in the code per se.
03:24:35 <maukem> it tries to keep a current max while walking down the list
03:24:38 <maukem> but it's still lazy
03:24:51 <maukem> so it's still building a nested thunk
03:25:09 <zipper> spyzer: Use `seq` in your slow function and see it it makes it run faster. seq in the non recurring part.
03:25:21 <zipper> spyzer: That might've been confusing
03:25:28 <tdammers> zipper: :D
03:25:45 <tdammers> spyzer: do you understand what seq does?
03:25:55 <zipper> spyzer: Anyway I don't think you can look at the code and just see what is lazy without knowing how various things are done/evaluated.
03:26:00 * hackagebot relational-record 0.1.1.0 - Meta package of Relational Record  http://hackage.haskell.org/package/relational-record-0.1.1.0 (KeiHibino)
03:26:03 <spyzer> tdammers: I was just going to look into that
03:26:04 <maukem> my suggested rewrite does two things: it forces c/compared, and it replaces head/tail by pattern matching
03:26:34 <tdammers> spyzer: a `seq` b -- means: "the value of b, such that when the expression is evaluated, both a and b will be evaluated"
03:26:59 <zipper> Anyway I'm a total n00b I just listen to the haskell cast a lot and have read RWH chapters. I still haven't done anything worth anything. :-(
03:27:08 <zipper> Quite honestly feel like giving up
03:27:34 <tdammers> spyzer: so: y `seq` max x y -- means "the value of max x y such that when it is evaluated, y is also evaluated"
03:27:57 <spyzer> tdammers: so are you saying that too much laziness in my first solution caused the bad turn around time and using seq will cause that laziness to go away?
03:28:24 <tdammers> spyzer: the laziness makes it such that every step of the iteration wraps the previous step in a thunk
03:28:51 <tdammers> when your function returns, you have a huge thunk, nested 100000 levels deep (or however many iterations you have)
03:28:53 <spyzer> tdammers: so in the second version the thunk won't grow is that what you are saying
03:28:57 <tdammers> yes
03:29:05 <spyzer> ahh i see
03:29:31 <spyzer> so the one maxm_tail i have written that also has a nested thunk?
03:29:32 <tdammers> in the second version, the 'y' value is evaluated before returning a thunk, so the nesting depth is kept constant
03:29:43 <zipper> spyzer: He is saying that :) IMO
03:29:46 <zipper> spyzer: Which other lang have you written/
03:29:48 <zipper> *?
03:30:35 <spyzer> zipper: first time in a pure functional programming language. Few months back started scala and seem that they were deriving a lot from haskell so i thought it better to learn haskell first
03:30:40 <tdammers> yes, the second version still builds up thunks
03:31:15 <spyzer> tdammers: and the one with seq that one as well?
03:31:27 <tdammers> not if you use seq right
03:31:37 <spyzer> lets call the seq one as the third version to avoid confusion
03:31:42 <tdammers> but really, it's much easier to implement this using foldl'
03:31:52 <spyzer> to second version(which I wrote) builds up thunks
03:32:05 <spyzer> and third version which you wrote should not
03:32:07 <tdammers> you could add strictness with seq to either one
03:32:18 <spyzer> tdammers: ahh i see
03:32:49 <maukem> @src foldl'
03:32:49 <lambdabot> foldl' f a []     = a
03:32:49 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
03:32:58 <maukem> @src foldl
03:32:58 <lambdabot> foldl f z []     = z
03:32:58 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:33:14 <tdammers> ^ probably the clearest possible demonstration of `seq`
03:33:44 <calvinx> dgomez: line 3? `availableModel carType`  ?
03:34:47 <spyzer> tdammers: the 3rd version takes same time 2s as the 2nd version so that means 2nd is strict does it?
03:35:27 <spyzer> maukem: wow !
03:36:00 * hackagebot cabal2nix 1.73 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.73 (PeterSimons)
03:36:32 <maukem> ah, maybe ghc is being clever
03:37:18 <nyuszika7h> how could I get ["111","2","33","4","3"] from "11123343"?
03:37:56 <opqdonut> > group "11123343"
03:37:58 <lambdabot>  ["111","2","33","4","3"]
03:38:20 <nyuszika7h> oh nice
03:38:34 <nyuszika7h> @hoogle group
03:38:34 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
03:38:34 <lambdabot> Data.ByteString.Lazy group :: ByteString -> [ByteString]
03:38:34 <lambdabot> Data.ByteString.Lazy.Char8 group :: ByteString -> [ByteString]
03:38:39 <nyuszika7h> ah, Data.List
03:39:06 <rhaps0dy_> Hello guys
03:39:24 <rhaps0dy_> any easy way to print a value that fails pattern matching?
03:39:27 <rhaps0dy_> for debugging
03:41:22 <Taneb> rhaps0dy_, add a patten x -> error $ show x
03:41:39 <rhaps0dy_> ooh.
03:41:42 <rhaps0dy_> thank you :)
03:45:08 <chpatrick> type Wat f t a = t (Wat' f t) a
03:45:08 <chpatrick> data Wat' f t a = PureWat a | FreeWat (f (t (Wat' f t) a))
03:45:11 <chpatrick> is there a name for this?
03:45:20 <chpatrick> or can you somehow build it out of Free/FreeT?
03:46:38 <dgomez> calvinx: yes, mmm if this sounds like a way to define what?
03:50:10 <merijn> maukem: I remember this -cafe posting I can't find where someone wanted to make a point about "this clean code is way slower than this ugly code" and GHC ended up optimising it to the exact same Core :>
04:13:45 <supki> chpatrick: I think it's  Free (Compose f t) a
04:14:02 <supki> Compose is from transformers
04:16:02 * hackagebot show-type 0.1.1 - convert types into string values in haskell  http://hackage.haskell.org/package/show-type-0.1.1 (Kinokkory)
04:21:02 * hackagebot Deadpan-DDP 0.7.0.0 - Write clients for Meteor's DDP Protocol  http://hackage.haskell.org/package/Deadpan-DDP-0.7.0.0 (LyndonMaydwell)
04:47:00 <nyuszika7h> this may be trivial but I can't figure it out. if I have the following function, how do I make a function that returns an infinite list (which I can use 'take' on), feeding back the return value of the function as the argument in each iteration?
04:47:02 <nyuszika7h> lookAndSay n = read (concat $ map (\g -> show (length g) ++ [g !! 0]) (group $ show n)) :: Integer
04:48:07 <nyuszika7h> take 5 $ lasRecur 1  should return [11,21,1211,111221,312211]
04:48:25 <vanila> > let rle = map (head &&& length) . group in rle "111221"
04:48:27 <lambdabot>  [('1',3),('2',2),('1',1)]
04:49:27 <vanila> > let rle = map (length &&& head) . group ; fmt (n,c) = show n ++ [c] ; next = fmt . rle in next "111221"
04:49:28 <lambdabot>  Couldn't match type ‚Äò[(GHC.Types.Int, c')]‚Äô
04:49:28 <lambdabot>                with ‚Äò(a0, GHC.Types.Char)‚Äô
04:49:28 <lambdabot>  Expected type: [c'] -> (a0, GHC.Types.Char)
04:50:24 <vanila> > let rle = map (length &&& head) . group ; fmt (n,c) = show n ++ [c] ; next = concatMap fmt . rle in concat $ iterate next "1"
04:50:25 <lambdabot>  "111211211111221312211131122211113213211311312111312211321131112311311221111...
04:56:17 <nyuszika7h> vanila: that gives the desired output without "concat $", thanks
04:56:27 <nyuszika7h> (just curious, what does "rle" stand for?)
04:56:51 <Kneiva> really leet example
04:57:02 <alpounet> nyuszika7h: http://en.wikipedia.org/wiki/Run-length_encoding
04:57:06 <rhaps0dy_> LOL kneiva
04:57:32 <nyuszika7h> alpounet: thanks, will check it out later, last lesson is starting now at school
05:00:13 <rtpg> hey guys, using emacs + ghc-mod, but couldn't figure out a good way to jump to the definition of a datatype/function. Does anyone have a recommended tool for this?
05:01:34 <danilo2_> Hello! Does anybody know how can I access an element of an array using lens? I want to get Maybe a (Nothing if the element is out of bounds)
05:03:00 <notdan> danilo2_: maybe `at'?
05:03:59 <danilo2_> notdan: no, at does not work with lists :(
05:04:08 <Taneb> :t firstOf (ix 0)
05:04:09 <lambdabot> (Ixed s, Num (Index s)) => s -> Maybe (IxValue s)
05:04:38 <notdan> Hm, so are you trying to access an array or a list?
05:05:18 <notdan> > [1,2,3,4] ^? ix 1
05:05:20 <lambdabot>  Just 2
05:05:23 <notdan> > [1,2,3,4] ^? ix 50
05:05:25 <lambdabot>  Nothing
05:05:27 <danilo2_> Taneb: oh, it works!
05:05:37 <Taneb> :)
05:05:58 <danilo2_> Taneb, notdan : thank you so much! :)
05:07:06 <notdan> > array (0, 10) [0..10]
05:07:07 <lambdabot>  No instance for (GHC.Arr.Ix i0)
05:07:07 <lambdabot>    arising from a use of ‚ÄòM56249224355472503161635.show_M56249224355472503161...
05:07:07 <lambdabot>  The type variable ‚Äòi0‚Äô is ambiguous
05:07:10 <clrnd> guys someone make scotty handle OPTIONS requests
05:08:57 <matematikaadit> > listArray (0, 10) [0..10]
05:08:58 <lambdabot>  array (0,10) [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(1...
05:09:09 <matematikaadit> > listArray (0, 10) [0..10] ^? ix 10
05:09:11 <lambdabot>  Just 10
05:21:03 <eXeC64> From a lambda calculus / theoretical side of things, is there any benefit to learning lisp/scheme in addition to haskell?
05:21:05 * hackagebot compare-type 0.1 - compare types of any kinds in haskell  http://hackage.haskell.org/package/compare-type-0.1 (Kinokkory)
05:21:23 <eXeC64> The goal being learning, not producing a program.
05:21:31 <maukem> probably not
05:21:49 <vanila> yes
05:21:56 <maukem> scheme provides a very direct embedding of LC, but that's pretty much it
05:22:24 <Cale> Well, there's definitely some learning value to be had there, but if you're just interested in getting coverage of mathematical topics, I think you can do everything you'd need from Haskell.
05:23:24 <eXeC64> Well, I feel like I'd like to learn more about lambda calculus, but after Œ±-equivalence and Œ≤-reduction, there doesn't seem to be much else to the foundations of it.
05:23:38 <eXeC64> Just application to build logic from those core pieces
05:23:44 <vanila> have you studied the church rosser theorem?
05:23:58 <eXeC64> church numerals, or is that more general?
05:24:12 <eXeC64> I've read a bit about them
05:29:12 <merijn> eXeC64: There's LOTS of stuff building on lambda calculus
05:29:29 <merijn> There's like a trillion variants, most of the interesting either covers encodings or type systems
05:29:59 <merijn> Simply type lambda calculus, System F, dependently typed LC, Calculus of Constructions, etc.
05:43:10 <eXeC64> The only downside to haskell is it's destroyed my love of python. I just can't abide the python type system anymore.
05:43:33 <volvo_cap> Why does f = (:)(:), have type f :: [a->[a]->[a]] -> [a->[a]->[a]] and not f:: ( a->[a]->[a] ) -> [a->[a]->[a]] -> [a->[a]->[a]]
05:44:29 <merijn> volvo_cap: 'f' is defined as a partially applied (:), your type is an unapplied (:)
05:44:42 <merijn> :t (:) `asAppliedTo` (:)
05:44:43 <lambdabot> (a -> [a] -> [a]) -> [a -> [a] -> [a]] -> [a -> [a] -> [a]]
05:44:48 <merijn> That's your type
05:44:54 <merijn> But that's not what you wrote
05:45:02 <merijn> You wrote "f = (:) (:)"
05:45:06 <merijn> :t (:) (:)
05:45:07 <lambdabot> [a -> [a] -> [a]] -> [a -> [a] -> [a]]
05:45:25 <volvo_cap> is `asAppliedTo` some function i dont know about?
05:45:54 <merijn> It's just to show "what a type would look like" when you want to apply a function to some value
05:45:59 <merijn> :t (:)
05:45:59 <lambdabot> a -> [a] -> [a]
05:46:06 * hackagebot sloane 2.0.2 - A command line interface to Sloane's On-Line Encyclopedia  of Integer Sequences  http://hackage.haskell.org/package/sloane-2.0.2 (AndersClaesson)
05:46:19 <merijn> asAppliedTo is "filling in" the 'a' with the "a -> [a] -> [a]" type of (:)
05:46:38 <merijn> eXeC64: Before you know it you even do your shell scripting in haskell :)
05:47:01 <eXeC64> merijn: Yikes.
05:47:08 <merijn> eXeC64: As for learning more cool stuff, here's two good books that should be accessible with beginner haskell experience
05:47:11 <merijn> @where tapl
05:47:12 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
05:47:14 <merijn> @where sf
05:47:14 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sj√∂berg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
05:47:14 <lambdabot> assistant."
05:47:28 <merijn> eXeC64: The first is about implementing type checkers/inference and associated type theory
05:47:35 <eXeC64> Actually, to be fair, I do use a haskell script to transform some my film-watching records.
05:47:38 <merijn> eXeC64: The second on proving properties about programs :)
05:48:03 <merijn> Coq proofs also make a decent math video game :p
05:48:18 <volvo_cap> merijn, what do you mean by saying " :t (:) `asAppliedTo` (:) , That's your type, But that's not what you wrote
05:48:55 <volvo_cap> is (:) `asAppliedTo` (:) not the same as (:)(:)?
05:49:01 <volvo_cap> what are the difference?
05:49:03 <merijn> No
05:49:32 <merijn> "(:) `asAppliedTo` (:)" is "the type of (:) AS IF I was going to pass (:) as first argument"
05:49:49 <merijn> "(:) (:)" is "the function (:) applied to (:)"
05:50:02 <merijn> :t (:)
05:50:03 <lambdabot> a -> [a] -> [a]
05:50:09 <merijn> :t (:) `asAppliedTo` (:)
05:50:10 <lambdabot> (a -> [a] -> [a]) -> [a -> [a] -> [a]] -> [a -> [a] -> [a]]
05:50:13 <merijn> :t (:) (:)
05:50:14 <lambdabot> [a -> [a] -> [a]] -> [a -> [a] -> [a]]
05:50:21 <merijn> volvo_cap: Count the number of arguments for each of those signatures
05:50:45 <merijn> Also, compare the last two
05:51:09 <volvo_cap> okay! I thought (:) (:) meant (:) `asAppliedTo (:) was the same.
05:51:22 <volvo_cap> I will study your example for some minutes and see if i get it
05:52:02 <volvo_cap> but asAppliedTo is not a built in haskell function but something you only use for explaning-purposes?
05:52:46 <volvo_cap> or no, but in which package can i find it?
05:52:55 <merijn> volvo_cap: asAppliedTo is "just" a normal haskell function, albeit with a funny type signature
05:53:09 <merijn> I think asAppliedTo is part of lambdabot
05:53:24 <volvo_cap> okay
05:53:56 <volvo_cap> but i still dont get it. I see that the number of arguments for (:)(:) is 1
05:54:33 <zwer> :t (+) `asAppliedTo` (1 :: Int)
05:54:34 <lambdabot> Int -> Int -> Int
05:55:12 <zwer> :t (+) (1 :: Int)
05:55:13 <lambdabot> Int -> Int
05:55:17 <maukem> (:) takes 2 arguments, thus '(:) anything' takes 1 argument
05:55:55 <volvo_cap> ahh, that makes sense =)  I think your example made me understand, thanks maukem!
05:57:08 <volvo_cap> do u guys know some good resources too use when trying to learn understanding the type system of haskell?
05:57:32 <maukem> personally, no. I cheated by already knowing ocaml
05:57:47 <volvo_cap> haha okay. what is ocaml?
05:57:48 <merijn> Lots of practice, grabbing a pen and paper and doing manual rewriting of types and carefully studying situations like these
05:57:55 <volvo_cap> or, well i can just google it:) nvm
05:58:01 <maukem> another programming language, in the ML family
05:58:17 <volvo_cap> k=)
05:58:39 <zwer> :t asAppliedTo
05:58:40 <lambdabot> (a -> b) -> a -> a -> b
05:59:11 <maukem> asAppliedTo :: (a -> b) -> a -> (a -> b); asAppliedTo = const
05:59:37 <maukem> asTypeOf :: a -> a -> a; asTypeOf = const
05:59:45 <Cale> volvo_cap: Well, what exactly do you want to know? All Haskell tutorials which are any good should teach you the basics.
06:00:17 <Cale> For the various extensions and such, there are separate tutorials and papers about them, as well as the GHC user guide.
06:01:02 <volvo_cap> yes, ofc. I don't know exactly. I guess I just have to keep practicing
06:01:13 <darkroom> does anyone have a good image processing libary?
06:01:21 <Cale> Feel free to ask any questions as they come up here
06:02:12 <Cale> volvo_cap: I've heard that http://www.seas.upenn.edu/~cis194/fall14/lectures.html is a good resource, though I've yet to read through it myself (I learned Haskell a long time ago)
06:02:41 <volvo_cap> Ahh okay! I will have a look at it!
06:05:47 <merijn> Cale: Like when dinosaurs roamed the earth? ;)
06:06:03 <Cale> darkroom: There's a lot of stuff on Hackage... is there anything in particular you're looking to do? I don't know if there's one image *processing* library which really stands out. Diagrams is a really cool library, but it's specifically for generation of 2D images.
06:06:32 <Cale> merijn: :)
06:08:17 <Cale> darkroom: JuicyPixels is good, but it's mostly codecs.
06:17:34 <lain1> Hi. After updating cabal using pacman flycheck is not able to find some modules in my cabal sandbox. However cabal build still works. Anyone have ideas what could be wrong?
06:27:05 <darkroom> so I was searching for a good image libary and all of them have nice boxed images the problem is I need a method of turning the image into something like an array does anyone know of a libary like that?
06:28:51 <remdezx> Hi! `within (ix 1) $ zipper ([1,2,3] :: [Int])` gives `m (Zipper Top Int [Int] :>> Int)`, how can I get `m (Zipper Top Int [Int] :>> A Int)`, where data A t = A t?
06:29:57 <remdezx> I tried `within (ix 1 . to A) $ zipper ([1,2,3])` but it gives error "Could not deduce (Contravariant (Bazaar (Indexed Int) (A Int) (A Int)))"
06:31:51 <tdammers> darkroom: haven't had much luck with that myself either
06:32:14 <tdammers> darkroom: currently considering writing the image processing part in C or C++ or something like that, and interfacing with pipes
06:33:07 <tdammers> darkroom: I've found a few wrapper for C image processing libraries, but they seem notoriously thread-unsafe, which is kind of a problem when you need them inside a Warp request handler
06:34:19 <pharpend> Hmm, so I have missingH installed with cabal
06:34:29 <darkroom> tdammers: Hum i might have to pic a libary and try to unbox it
06:34:37 <pharpend> yet, when I try to compile a file importing Data.List.Utils, I get that the module is not found
06:36:08 <darkroom> tdammers: can you link them to me I literally just need a way to convert between a PNG to a matrix
06:36:28 <darkroom> tdammers: I dont even need to go from a matrix to a PNG
06:36:54 <tdammers> darkroom: I pretty much walked this list: http://hackage.haskell.org/packages/search?terms=png
06:37:33 <tdammers> hmm, actually, some of these look like I haven't seen them before
06:37:49 <tdammers> anyhow, juicy pixels did not do the trick for me
06:38:27 <darkroom> tdammers: juicy pixels can convert to a byte string
06:38:33 <darkroom> tdammers: I can work with that!
06:39:13 <tdammers> I think it gives you just the raw compressed image data though... not sure actually
06:39:29 <darkroom> tdammers: yea i just checked the source :( its compressed
06:50:29 <lain1> Well, I don't know what it was but cloning into a different directory worked. Must have been something left around that was causing problems. O well, works for me now
06:50:52 <darkroom> tdammers: I figured it out one libary can give you a storeable array then you can use getAccos to get a list of indices
06:51:08 * hackagebot typedquery 0.1.0.1 - Parser for SQL augmented with types  http://hackage.haskell.org/package/typedquery-0.1.0.1 (tolysz)
06:55:40 <remdezx> Hi lens hackers! Can somebody help me with lens and zippers? ;) http://stackoverflow.com/questions/27842805/stepping-into-zipper-with-to-lens
06:55:57 <benzrf> remdezx: to isnt a lens
06:56:05 <benzrf> remdezx: it only makes a getter, it's not magic :p
06:57:55 <remdezx> benzrf: ok, so are there any other ways to wrap itno into A?
07:01:03 <Cale> remdezx: Make a proper lens for A, either using the 'lens' function or deriving one using TH.
07:01:27 <dfeuer> carter, here are some nice alternative Show instances for HList. They take a bit of weirdness to avoid overlapping instances: http://lpaste.net/118070
07:01:55 <dfeuer> Maaaaaagc.
07:02:38 <Chathurga_> Oh my
07:03:57 <dfeuer> Cale, what do you think of http://lpaste.net/118070 compared to the official Show instances for HList?
07:04:42 <Cale> I don't know what the official ones do
07:04:45 <Cale> I don't really use HList
07:04:57 <dfeuer> Cale, they do the same thing, but in a different way.
07:05:19 <dfeuer> Cale, the official ones are here: https://hackage.haskell.org/package/HList-0.3.4.1/docs/src/Data-HList-HList.html
07:05:20 <Cale> Then the difference doesn't matter to me? :)
07:05:30 <remdezx> Cale: Thanks! You mean something more compilcated than `makeLenses'' A`, right?
07:05:43 <Cale> remdezx: No, that's pretty much exactly what I mean
07:05:46 <dfeuer> Me thinks mine is prettier, but it is longer.
07:06:32 <remdezx> Cale: but it didn't work...
07:07:45 <Cale> remdezx: Maybe I don't understand what you're trying to do. You should be able to compose the lens you get into the field of the A structure with other lenses
07:08:44 <remdezx> Cale: No, I'm trying to construct A here, not to go inside...
07:10:17 <Cale> remdezx: Oh, just use the constructor A?
07:16:03 <remdezx> Cale: right!
07:16:38 <pharpend> Why is it that Do-sugar doesn't understand that I might be working with more than one monad
07:17:12 <merijn> pharpend: define "working with more than one monad"
07:17:20 <merijn> That doesn't sound like a sensible statement
07:17:28 <pharpend> http://lpaste.net/118073
07:17:43 <pharpend> I have getFnom, which is a -> Maybe b
07:18:02 <pharpend> but in general oh oops
07:18:18 <pharpend> <- i was using, wrong I was
07:18:29 <merijn> :)
07:18:43 <merijn> Also
07:18:54 <merijn> You probably want "map getFnom" + catMaybes
07:18:57 <merijn> :t catMaybes
07:18:58 <lambdabot> [Maybe a] -> [a]
07:19:36 <pharpend> Yes, that's a lot better
07:30:55 <eXeC64> I quite like mapMaybe
07:30:58 <eXeC64> :t mapMaybe
07:30:59 <lambdabot> (a -> Maybe b) -> [a] -> [b]
07:32:19 <eXeC64> It's possibly closer to what you want
07:36:23 <t4nk688> hello!
07:37:19 <clrnd> hi
07:50:50 <volvo_cap> trying to grasp how to use the two functions curry and uncurry but I do not completely understand it. How can i rewrite this function in point-free style with help of curry and uncurry?
07:50:54 <volvo_cap> g x y = (5 + x) / y
07:51:11 * hackagebot ekg-rrd 0.2.1.65 - Passes ekg statistics to rrdtool  http://hackage.haskell.org/package/ekg-rrd-0.2.1.65 (dcturner)
07:55:14 <opqdonut> volvo_cap: curry and uncurry don't really help you there
07:55:39 <opqdonut> they merely transform between g x y and g (x,y)
07:55:52 <opqdonut> @pl \x y -> (5 + x) / y
07:55:53 <lambdabot> (/) . (5 +)
07:56:00 <opqdonut> that's the point-free formulation
07:56:02 <jackhill> Hi, how can I find the type of something like <+> in ghci? Currently it's not parsing
07:56:05 <jackhill> :t <+>
07:56:06 <lambdabot> parse error on input ‚Äò<+>‚Äô
07:56:09 <opqdonut> :t (+)
07:56:10 <lambdabot> Num a => a -> a -> a
07:56:11 <maukem> :t (<+>)
07:56:12 <lambdabot>     Ambiguous occurrence ‚Äò<+>‚Äô
07:56:12 <lambdabot>     It could refer to either ‚ÄòControl.Arrow.<+>‚Äô,
07:56:12 <lambdabot>                              imported from ‚ÄòControl.Arrow‚Äô at /home/lambda/.lambdabot/State/L.hs:42:1-20
07:56:22 <dfeuer> Pareeeeeentheses.
07:56:29 <jackhill> maukem, dfeuer thanks!
07:56:37 <maukem> :t takes an arbitrary expression
07:56:37 <lambdabot>     Not in scope: ‚Äòtakes‚Äô
07:56:37 <lambdabot>     Perhaps you meant one of these:
07:56:37 <lambdabot>       ‚Äòtake‚Äô (imported from Data.List),
07:56:48 <volvo_cap> lolol, ofc. Thanks!
07:59:37 <dfeuer> Why aren't there HList instances for Read?
08:01:56 <mseeks> when should you prefer liftM and ap to fmap/<$>/liftA and <*>?
08:03:27 <dfeuer> What's the currenly-preferred way to make instances of Read? I see that GHC does a lot of stuff with ReadPrec and ReadP, but I haven't a clue what I'm doing.
08:05:06 <dfeuer> mseeks, you should prefer liftM and ap if you need to be compatible with older versions of the libraries and you may not have Functor and/or Applicative instances available.
08:05:50 <mseeks> dfeuer: makes sense
08:06:32 <Peaker> or if you just want to have a (Monad m =>) constraint and not (Monad m, Applicative m) =>   constraint
08:06:35 <Peaker> (new GHC will finally solve that)
08:07:55 <erisco> dfeuer, what is it
08:08:16 <dfeuer> erisco, what's the currently-preferred way to make instances of Read?
08:08:28 <dfeuer> I see GHC does a lot of stuff with ReadPrec and ReadP.
08:08:29 <xplat> 'deriving (Read)'
08:08:45 <erisco> that is not my kind of parsing question... no idea :P
08:10:28 <mseeks> Peaker: when it is true that functors/applicatives/monads are supersets, will there still be any reason to use liftM/ap over <$>/<*>?
08:10:51 <dfeuer> xplat, that doesn't seem to work for weird types like HList.
08:10:52 <Peaker> mseeks, probably when you want to derive your Functor/Applicative instance after you've written a Monad instance :)
08:11:16 <mseeks> Peaker: ohh, good point
08:11:39 <xplat> dfeuer: probably look at what Data.Map does then?
08:13:05 <dfeuer> xplat, not so helpful; containers builds those instances on top of the Prelude ones.
08:13:12 <dfeuer> er ...
08:13:16 <dfeuer> GHC ones, I mean.
08:13:27 <dfeuer> And Prelude ones for non-GHC.
08:17:01 <chpatrick> foo :: (a -> m b) -> t m a -> t m b
08:17:06 <chpatrick> is there a typeclass for this?
08:18:20 <maukem> :t (=<<) . (lift .)
08:18:20 <lambdabot> (MonadTrans t, Monad (t m), Monad m) => (a -> m b) -> t m a -> t m b
08:18:34 <chpatrick> http://hackage.haskell.org/package/bound-1.0.4/docs/Bound.html#v:-62--62--62--61-
08:18:35 <ironChicken> how can i convert a Vector to an Array?
08:18:39 <chpatrick> of course, ekmett :)
08:21:25 <mseeks> is there anything like https://gowalker.org/ for haskell/haddock?
08:31:16 <J_Arcane> can you use guards in lambda definitions?
08:32:37 <pharpend> I'm very impressed with myself
08:32:50 <pharpend> typically, for crappy little scripts, I use Ruby
08:33:06 <pharpend> but I decided to write this last one in Haskell
08:33:15 <HugoDaniel> cool how did that go ?
08:33:19 <pharpend> and it worked perfectly and didn't destroy my files
08:33:21 <pharpend> it was odd
08:33:55 <pharpend> I sometimes forget that Haskell is still really good for little crappy scripts
08:34:01 <mseeks> J_Arcane: guard is MonadPlus m => Bool -> m ()
08:34:29 <J_Arcane> I intend to do a little Haskell scripting soon. I want to add a Haskell port of my resume generator to the repo.
08:34:29 <mseeks> so you could use it with monadic binds in a lambda like any other monadic function
08:34:51 <mpickering> I think he means using |
08:34:59 <Chathurga_> J_Arcane: You can kinda of with case
08:35:05 <mpickering> Maybe something like the MultiWayIf extension J_Arcane?
08:35:44 <Chathurga_> case x of _ | False -> 0 | True -> 1
08:35:45 <J_Arcane> mpickering: Yes, that's what I meant. Was trying to think of ways to reduce the Ackermann function.
08:35:52 <mseeks> oh I see, sorry
08:37:08 <mpickering> I think MultiWayIf might be what you want
08:46:02 <athan> Hey guys, I'm trying to wrap my head around composing environments for an application for a bit, and would like some ideas if anyone has any. Basically, I like to use reader monads as a way to give my application read-only settings. However, I often find myself splitting up the index type, or wanting to use multiple readers in my application. Basically, what I'm looking for is something like  (&&&), but for the index of monad readers
08:46:02 <athan> (at least I think I am)
08:46:46 <athan> What I'm thinking of doing, is separating my application so one reader controls one separate section of the application, and the other controls another separate section, where their reader index types are different.
08:48:10 <athan> Then, in my `main` function, I could roughly `(&&&)` them together and do the splitting from the top
08:51:14 * hackagebot haste-compiler 0.4.4 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.4.4 (AntonEkblad)
08:52:50 <athan> ...maybe something that looks like `MonadReader a (R a), MonadReader b (R b), MonadReader (a,b) (R (a,b)) => R a -> R b -> R (a, b)`?
09:18:21 <tolt> Is there a good mailbox type library?
09:18:33 <tolt> or a recommended one?
09:19:09 <clrnd> hey, how can I tell scotty where to listen?
09:19:50 <tolt> Do you mean port or the addresses?
09:20:13 <clrnd> address
09:20:31 <tolt> are you running main = scotty 3000 $ do ?
09:20:47 <clrnd> yes tolt
09:20:53 <tolt> 3000 is the port
09:20:55 <clrnd> on a different port, but yeah
09:20:56 <tolt> just change the port
09:21:05 <tolt> Oh. wow
09:21:06 <tolt> I'm sorry.
09:21:07 <clrnd> I want to change the address
09:21:12 <tolt> Yeah. I was an idiot :(
09:21:14 <clrnd> jaja no problem
09:22:18 <tolt> You'll want to run scottyOpts
09:22:48 <clrnd> yeah Im not totally sure how to use that, wai says that's deprecated too
09:23:00 <mseeks> is there something online that generates haddock documentation like gowalker?
09:24:12 <tolt>  you can run main = scottyOpts (  setHost "*" defaultSettings) $ etc
09:24:59 <tolt> yeah. The depricated warning iis on the accessors for settings
09:25:25 <clrnd> tolt, oh, thank you!
09:25:38 <tolt> clrnd: Yeah! Sorry I was an idiot again.
09:26:03 <clrnd> not at all!
09:27:03 <tolt> clrnd: look here for the host isString instances http://hackage.haskell.org/package/streaming-commons-0.1.8/docs/Data-Streaming-Network.html#t:HostPreference
09:27:25 <clrnd> tolt, yay perfect
09:39:13 <augustss> Hej!
09:39:48 <shachaf> hej augustss
09:40:24 --- mode: ChanServ set +o shachaf
09:40:31 --- mode: shachaf set +b *!*tumaru@*.Red-81-37-44.dynamicIP.rima-tde.net
09:40:32 --- kick: tumaru was kicked by shachaf (tumaru)
09:40:36 --- mode: shachaf set -o shachaf
09:51:16 * hackagebot mutable-containers 0.2.0.1 - Abstactions and concrete implementations of mutable containers  http://hackage.haskell.org/package/mutable-containers-0.2.0.1 (MichaelSnoyman)
09:51:18 * hackagebot effect-handlers 0.1.0.0 - A library for writing extensible algebraic effects and handlers. Similar to extensible-effects but with deep handlers.  http://hackage.haskell.org/package/effect-handlers-0.1.0.0 (edofic)
09:52:45 <circ-user-v8z6i> hi guys: How do I write (f#): type foo<'T> = { x : 'T; y : 'T;  } in haskell? A record with elements of the same generic types
09:53:19 <shachaf> Perhaps you want: data Foo a = Foo { x :: a, y :: a }
09:53:21 <exio4> @let data Foo a = Foo { x :: a, y :: a }
09:53:23 <lambdabot>  Defined.
09:53:27 <exio4> something like this would work ^
09:53:36 <tolt> Does anyone have a suggestion for a "mailbox" type library?
09:53:39 <circ-user-v8z6i> thanks! That looks exactly like it!
09:53:51 <johnw> tolt: you mean, read and maintain mail files?
09:53:58 <shachaf> You don't *actually* have to talk to lambdabot to write Haskell code in this channel. :-)
09:54:06 <tolt> johnw: a chan like data structure I guess?
09:54:10 <johnw> ahh
09:54:12 <johnw> message passing
09:54:16 <tolt> johnw: something like pipes-concurrency
09:54:25 <shachaf> circ-user-v8z6i: Note that x and y will be "global" identifiers here, which means e.g. that you can only use them for one data type in a module.
09:54:26 <johnw> there are lots of options, TBQueue is one
09:54:32 <shachaf> I think it might be different in F#
09:55:45 <EvanR> tolt: whats wrong with chan? or *-chan
09:57:00 <tolt> I was hoping for something that has the monad/functor instances like pipes-concurrency has but with a single data structure instead of an input/ouput
09:57:42 <circ-user-v8z6i> one way to do stuff is actor model with message passing. Erlang style. But there are voices out there which claim to know "better" solutions which turn that deterministic in some sense.
09:58:31 <Denommus> hi
09:59:23 <EvanR> tolt: theres cloud haskell ...
09:59:45 <circ-user-v8z6i> what does he want to do? experiment a little or get something done?
10:00:00 <EvanR> ill tell you
10:00:05 <platz> I'm not sure determinism in a fully distributed setting is the true goal there
10:00:49 <platz> seems like probability and adaptation must be part of that picture to truly be antifragile
10:00:53 <tolt> cloud haskell is a bit extreme. It's a ghcjs projec too so that won't really work.
10:00:54 <Denommus> I wonder if using reactive-banana to generate a Html (with blaze-html) as a behavior will make the whole Html be re-rendered every time, or if reactive-banana is able to handle the diffs
10:00:55 <circ-user-v8z6i> I think the curse of "the cloud" is the "eventually consistent" which is a restating of "never consistent when you need it"
10:01:18 <EvanR> ghcjs ?
10:01:31 <johnw> compiles Haskell code to Javascript
10:01:36 <tolt> https://github.com/ghcjs/ghcjs
10:01:45 <johnw> and provides a runtime to support most of what Haskell can do (including STM, etc)
10:01:47 <EvanR> whats that got to do with cloud haskell
10:01:57 <quchen> circ-user-v8z6i: If you need consistency and you're using an inconsistent DB, your system design is probably broken.
10:03:02 <EvanR> i hate it when my gmail is eventually consistent
10:03:18 <mettekou> Does anyone know the idiomatic way to replace Gtk2Hs `Widget`s at run-time? I need to destroy a `Table` and replace it or destroy some of its associated `Button`s and replace them. The documentation doesn't seem to mention that scenario, so I assume I have to use `IORef`s?
10:03:20 <EvanR> (with somebody telling me they sent me something important)
10:03:33 <circ-user-v8z6i> I ... dont need anything lol - but...the point was: Don'T fall into the cloud-by-default trap. If you have other use cases, you probably want to tackle your distributed system with other mechanics as those typically used in cloud computing.
10:03:44 <quchen> EvanR: Via Email, ignorant of GPG. Every. Damn. Day.
10:04:02 <tolt> EvanR: Cloud haskell is a distributed system framework. I just want a mailbox like data type.
10:04:09 <tolt> data structure*?
10:04:24 <EvanR> a bounded chan then
10:04:28 <circ-user-v8z6i> who is your application talking to EvanR?
10:05:53 <circ-user-v8z6i> hm... back later....
10:13:25 <Forgetaboutit> hey folks, I have a question regarding RWS: I have two functions, which are mutually recursive;  but both of them also depend on the result `(a, _, _)' of runRWS to terminate the recursion.  I picked RWS because I need logging, configuration and state in between.  I have no idea how to write the recursive call since I can't access the contents of the writer `w' in the monad.  Any ideas?
10:13:52 <johnw> if you need to access 'w', you'll need to make it a state value
10:14:41 <Forgetaboutit> johnw: that's what I feared ...
10:14:51 <johnw> look at the type of any writer:
10:14:53 <johnw> @until Writer w a
10:14:54 <lambdabot> Maybe you meant: unpl unmtl
10:14:57 <johnw> @unmtl Writer w a
10:14:58 <lambdabot> (a, w)
10:15:04 <johnw> as opposed to state:
10:15:07 <johnw> @unmtl State s a
10:15:07 <lambdabot> s -> (a, s)
10:15:29 <dfeuer> Ping carter.
10:15:34 <johnw> since the 'w' is only a "return value", it can only be produced
10:15:58 <johnw> (i mean, really it's just a value, period, and the monad is an action to create that value)
10:16:03 <Forgetaboutit> johnw: I could also make `a' a tuple
10:17:10 <Forgetaboutit> johnw: Or could I also use a proper monad transformer stack with WriterT at the top?
10:17:19 <johnw> sure
10:17:28 <johnw> or just make your state a tuple in your RWS monad
10:17:32 <Forgetaboutit> johnw: It'd be nice to preserve WriterT for clarity
10:17:38 <johnw> RWS r () (w, t) a
10:18:02 <Forgetaboutit> johnw: I'm going to try that -- thank you!
10:21:50 <WraithM> Is the history from a "cabal repl" session in a sandbox stored anywhere? If so, where?
10:22:38 <WraithM> I don't see it in my ~/.ghc/ghci_history
10:23:54 <WraithM> I've also tried grepping around in .cabal-sandbox and I didn't really find anything.
10:25:19 <carter> johnw: whats your personal pipes vs conduit vs machines take?
10:25:59 <johnw> I prefer pipes now
10:30:29 <Lindrian> I'm learning haskell, the beginners channel seems a bit dead. Could someone briefly refresh my memory on the following behavior:
10:30:30 <Lindrian> let x = [1,2,3]; y = [1,2,3] in do { a <- x; b <- y; return (a*b) }
10:30:36 <EvanR> if an IO exception happens in some pipe component, that crashes the entire thing?
10:31:05 <shachaf> This channel is fine for beginner questions.
10:31:13 <mmachenry> Lindrian: That's using list as a monad and you're effectively doing a list comprehension.
10:31:28 <EvanR> well, its a concatMap
10:31:41 <johnw> EvanR: unless you use pipes-safe
10:32:44 <shachaf> Lindrian: (But it's recommended to actually ask a question. :-) )
10:32:45 <Lindrian> mmachenry: i see. Is that defined somewhere that I can look?
10:33:18 <Lindrian> I'm sorry I wont waste your time, I'm talking to a few in beginners channel now.
10:34:42 <mmachenry> Lindrian: Yeah, there's some stuff on what list does when used as a monad. In short it models non-deterministic behavior well. Also >>= is concatMap and it works just like list comprehension. Check out the Typeclassopdia
10:35:03 <mmachenry> Lindrian: Also this: http://en.wikibooks.org/wiki/Haskell/Understanding_monads/List
10:35:06 <circ-user-v8z6i> ...and I thought this /is/ the beginners channel :)
10:35:22 <mmachenry> Lindrian: You're not wasting anyone's time. These are totally reasonable questions.
10:35:50 <EvanR> in the pipes-safe doc it mentions "premature termination" what does that mean
10:36:02 <t-l-o> Hi all, I have a problem with the following line of code... it works, but if I add the type signature (zeros :: Int -> Int), I get wrong results (for example for zeros 30 should be 7, but it then gives 0): zeros n = length (takeWhile (== '0') (reverse $ show $ product [1..n]))
10:36:04 <edwardk> Zemyla: i used to write C++ too ;)
10:36:05 <johnw> termination before reaching the end of the source
10:36:17 <EvanR> besides by throwing an exception?
10:36:37 <johnw> yes, a Producer can exit at any time
10:36:47 <johnw> and ordinarily Pipes and Consumers will receive no notice of the fact
10:37:08 <EvanR> oh, are they concurrent
10:37:15 <johnw> no
10:37:17 <Zemyla> edwardk: Hey. When did I talk about C++?
10:37:38 <johnw> Producers and Consumers are like functions that keep calling each other (hey I need a value, hey here's a value, hey I need a value, etc)
10:37:46 <johnw> if one side stops calling the other, that's the end of it
10:38:01 <EvanR> and the top level runEffect just hangs?
10:38:19 <johnw> no, it simple ends
10:38:21 <johnw> simply
10:38:29 <johnw> that's why both Producers and Consumers have a final value type
10:38:34 <edwardk> malc_ passed along "Zemyla: I imagine if [Edward Kmett] had found C++, he would be writing template definitions that would make the faces of the Boost team melt off."
10:38:36 <johnw> Producer a m r
10:38:39 <edwardk> so i figured i'd reply ;)
10:39:04 <johnw> haha
10:39:08 <edwardk> by noting that I wrote C++ for a long time before I switched to Haskell. Haskell just made it really really easy to write all the template stuff that was a pain in the ass in C++ ;)
10:39:48 <circ-user-v8z6i> shh - c++ secret: once you try to get too fancy with c++ templates it ends in reading the standard and finding that passage which says this won't work due to the fact then then C-code construct xy would break.
10:41:47 <edwardk> circ-user-v8z6i: the real secret is finding the right subset of functionality that lets you just work in a Turing complete tarpit and then figure out how to get the data out of that subset into whatever it was you wanted to actually write.
10:42:05 <circ-user-v8z6i> sorry to bother you guys... how would I write let foo = Array2D.init 100 100 (fun x y -> x + y ) in haskkel?
10:42:11 <edwardk> knowledge of the full language standard is just sort of assumed ;)
10:42:31 <edwardk> and if you are missing any parts of it, johnw can answer them
10:42:31 <Forgetaboutit> WraithM: Apparently, it doesn't have a separate history as `cabal repl' outside a sandbox also remembers my commands from inside a sandbox.
10:42:40 <circ-user-v8z6i> well I stopped being a c++ guy once c++11 came and I had a look at how std::function is implemented. I vomited for a few days and started looking for a new language.
10:42:51 <edwardk> circ-user-v8z6i: a common reaction
10:43:21 <edwardk> i got out a few years earlier, so that helped cushion the blow
10:43:49 <WraithM> Forgetaboutit: Ah, so maybe it gets written to .ghc/ghci_history when I quit the session or something.
10:43:52 <circ-user-v8z6i> I did mostly embedded programming...so conservative, ROM economic c++ was my thing.
10:44:00 <circ-user-v8z6i> I never liked generic programming
10:45:08 <edwardk> in that setting i can understand why
10:45:09 <Forgetaboutit> WraithM: Exactly
10:45:11 <WraithM> Forgetaboutit: Thanks
10:45:27 <EvanR> circ-user-v8z6i: yes you can do essentially that array initialization
10:45:45 <Forgetaboutit> WraithM: You're welcome, I was just interested and goofed around a bit :)
10:45:59 <circ-user-v8z6i> how is it translating to haskell? I found there are IArray and MArray things about in Data.Array but could not find any 2d stuff
10:46:14 <EvanR> circ-user-v8z6i: a 2d array is an array with an index like (Int,Int)
10:47:08 <EvanR> the simplest way to initialize an array is to have a list of index-value pairs
10:47:09 <circ-user-v8z6i> so a 2 darray would be something like foo :: Int -> Array Int Int Int?
10:47:20 <EvanR> Array (Int,Int) Int
10:47:27 <circ-user-v8z6i> ah okay as a tuple
10:48:36 <circ-user-v8z6i> cant I calculate the values during the init-phase of the array directly (with a lambda?)
10:49:30 <EvanR> yeah
10:49:34 <EvanR> :t accumArray
10:49:35 <lambdabot> Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
10:49:42 <carter> johnw: what prompted the shift?
10:50:18 <EvanR> that gives you more than you need, an accumulating parameter. you just want to map indexes to their sum so listArray is better
10:50:22 <EvanR> :t listArray
10:50:23 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
10:50:33 <circ-user-v8z6i> omg that lambdabot post would surely be useful...if only I could decrypt it :)
10:51:05 <EvanR> alternatively you might want a Data.Map (Int,Int) Int instead, since it can be updated
10:51:13 <EvanR> among other nice utility functions
10:51:25 <circ-user-v8z6i> I dont want to update the array - it is the result of the computation
10:51:34 <EvanR> :t range
10:51:35 <lambdabot> Ix a => (a, a) -> [a]
10:51:37 <ThreeOfEight> circ-user-v8z6i: you give it the index range and the list of values
10:51:47 <EvanR> :t range (0,0) (100,100)
10:51:48 <lambdabot>     Couldn't match expected type ‚Äò(t0, t1) -> t‚Äô
10:51:48 <lambdabot>                 with actual type ‚Äò[a0]‚Äô
10:51:48 <lambdabot>     The function ‚Äòrange‚Äô is applied to two arguments,
10:51:57 <ThreeOfEight> :t listArray (1,10) [i^2 | i <- [1..10]]
10:51:57 <EvanR> :t range ((0,0), (100,100))
10:51:58 <lambdabot> (Ix i, Num e, Num i, Enum e) => Array i e
10:51:58 <lambdabot> (Ix t1, Ix t, Num t1, Num t) => [(t, t1)]
10:52:15 <ThreeOfEight> :t listArray (1::Int,10) [i^2 | i <- [1..10::Int]]
10:52:16 <lambdabot> Array Int Int
10:52:27 <ThreeOfEight> this gives you an array with indices from 1 to 10
10:52:28 <circ-user-v8z6i> so how would I write a lazy list which  has /(i,i),i) elements?
10:52:32 <ruuns> Hey, i have small, general question about Haskell's exceptions system. Is it trusty, when i have to work with pointers to use kinds of memory functions alloca $\ptr -> blabla ? (In C++ there is always debate about it because it forces you to use RAII) If not, how can i apply some kind of safe RAII in Haskell?
10:52:38 <ThreeOfEight> containing the square numbers from 1^2 to 10^2
10:52:50 <ThreeOfEight> what do you mean by that?
10:53:15 <EvanR> alloca is RAII
10:53:43 <lisbeth> is it safe to nest do clauses?
10:53:50 <ab9rf> lisbeth: yes
10:54:07 <ruuns> it catches internally the exception? great :) thx
10:54:23 <lisbeth> thanks
10:54:39 <carter> ruuns: foreignPointers have finalizers
10:54:47 <clrnd> lisbeth, look at scotty, it's API encourages that
10:54:52 <EvanR> ruuns: see the description of alloca in the haddock
10:54:56 <circ-user-v8z6i> in c++ the story is: If you do malloc() in a constructor and it throws, then exit() is called and your application is toast. This is why you should NOT use RAII if the constructor code cannot always succeed. 2 phase init is what you need then.
10:55:45 <EvanR> malloc throwing?
10:55:59 <ab9rf> i hate malloc
10:56:01 <ruuns> he means new :P
10:56:02 <EvanR> is that  a thing
10:56:06 <ab9rf> malloc is evil incarnate
10:56:08 <circ-user-v8z6i> an exception in a constructor (new() is also malloc... lol)... and exit
10:56:19 * hackagebot formatting 6.1.1 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-6.1.1 (ChrisDone)
10:56:23 <lisbeth> clrnd scotty?
10:56:37 <clrnd> @hoogle Web.Scotty
10:56:38 <lambdabot> package scotty
10:56:38 <lambdabot> package scotty-blaze
10:56:38 <lambdabot> package scotty-fay
10:57:16 <EvanR> circ-user-v8z6i: im sure you can catch exceptions in c++... not that it means theres anything youd necessarily be able to do
10:57:31 <ruuns> thx carter, Evanr, i will look for this :]
10:57:44 <clrnd> hey what about GHCJS? does it support all of Haskell? what about FFI?
10:58:02 <circ-user-v8z6i> yes but then you are left over with a partially initilaized object and you still have a problem. This is why best practice is: Once you CAN fail move it to some Init() function and keep the simple stuff to the constructor.
10:58:03 <Zemyla> Also, last night, I finally figured out why "a monad is a monoid in the category of endofunctors". :D
10:58:16 <khyperia> nice, Zemyla!
10:58:19 <EvanR> congratz
10:58:38 <shachaf> Why is a monad a monoid in the category of endofunctors?
10:58:49 <augustss> Why not?
10:58:57 <shachaf> And: Why is Alternative also a monoid in the category of endofunctors?
10:58:58 <circ-user-v8z6i> Zemyla: 25 years on the job (and successful) and I never needed category theory or monads ;)
10:59:30 <EvanR> categories (and semigroupoids) are everywhere ;)
11:00:06 <circ-user-v8z6i> Gamma rays are everywhere, too but this does not mean that I have to litter my brain about them :)
11:00:13 <augustss> circ-user-v8z6i: Maybe you just didn't know you needed them.
11:00:43 <circ-user-v8z6i> Now I start to see what it is all about I know that many do not know that not knowing is not a deficit ;)
11:01:07 <shachaf> Anyway monads are just free monad monad monad algebras.
11:01:16 <EvanR> any time you have components that are mixed and matched, but cant necessarily fit into just *any* place, you should think about what your category is
11:01:30 <clrnd> my monad is bigger than yours
11:01:51 <augustss> My monad has wheels.
11:02:29 <circ-user-v8z6i> it is about constructivism and having a model of reality. Monads are just one (fashionable) way of modeling things.
11:02:50 <EvanR> monads :(
11:03:22 <circ-user-v8z6i> want to hear my definition of monads? :)
11:03:26 <shachaf> I guess another meaning of "monoid in the category of endofunctors" would be using (:+:), but it ends up being boring.
11:03:29 <EvanR> circ-user-v8z6i: the thing about models of reality, is the less that needs to be in your model the better, you really want the interface in your model, rather than the reality
11:03:40 <shachaf> Any other monoidal structures on the category of Hask endofunctors other than the obvious three?
11:04:10 <johnw> let's rename Monad to HotelCalifornia
11:04:24 <circ-user-v8z6i> you name it EvanR: Monads are for the poor guys who did not embrace the power of a SET of Functions, also known as Interface yet.
11:04:48 <EvanR> not just any functions though
11:04:59 <EvanR> i.e. Object fooName(Object, Object, Object)
11:05:03 <johnw> shachaf: I guess I don't know the obvious three; is there an article on that?
11:05:04 <EvanR> thats not a very good interface
11:05:04 <circ-user-v8z6i> right - not just any function. A well designed interface.
11:05:07 <shachaf> hilarious. because you can never leave a monad!!
11:05:20 <augustss> Three objects walked into a bar...
11:05:31 <circ-user-v8z6i> which is expressive, minimal, not littered with ugly types taken from all over the world...
11:06:19 * hackagebot hledger-interest 1.4.4 - computes interest for a given account  http://hackage.haskell.org/package/hledger-interest-1.4.4 (PeterSimons)
11:06:38 <EvanR> circ-user-v8z6i: thats another thing, typing shouldnt be nominal i.e. AbstractBuilderFactory, it should be structural. things with the same essence and different names are compatible
11:07:03 <EvanR> i currently have 10 different byte stream classes here, and they all do the same thing
11:07:09 <augustss> EvanR: Except when you don't want that.
11:07:30 <EvanR> augustss: yeah, you can wrap it in another guise
11:07:43 <circ-user-v8z6i> Exactly the interface (name, type, uuid,...) is a contract and anyone who can handle that can handle the object/code/library/whatever behind it. And it can be named. You can compose, you can do anything. Without any bit of category theory.
11:08:02 <lisbeth> can I have a conditional definition of a function using if then else?
11:08:04 <EvanR> uuid is just an artificial grist though, its not guaranteeing anything to the client
11:08:20 <EvanR> and you usually cant compose them
11:08:32 <lisbeth> actually nevermind I just realized you can
11:08:35 <circ-user-v8z6i> it could also be called the "internally and well hidden type class identifier"
11:08:42 <Zemyla> Also, I figured out while laying in bed under what circumstances ((->) e) is a comonad.
11:08:58 <EvanR> despite decades of outputting loads of class libraries, they still cant be composed
11:09:13 <EvanR> resulting in more adapters
11:09:13 <circ-user-v8z6i> what? of course you can!
11:09:15 <Zemyla> It's exactly the same as the circumstances under which ((,) e) is a monad.
11:09:16 <shachaf> The same circumstances under which ((,) e) is a monad.
11:09:18 <shachaf> Yes.
11:09:25 <Zemyla> e is a Monoid.
11:09:47 <shachaf> Moreover, you don't notice this in Haskell, but (e ->) is a monad under the same circumstances under which (e,) is a comonad.
11:09:53 <shachaf> I.e., when e is a comonoid.
11:10:07 <circ-user-v8z6i> I did years of COM programming. You can aggregate them, subclass from them... you can use them as facades, you can even use them in pure functional context, giving your function some functions to call. A list of functions if you like.
11:10:10 <Zemyla> extract f = f mempty, and duplicate f = \a b -> f (mappend a b).
11:10:18 <shachaf> (But every type in Haskell is a comonoid in the same trivial way.)
11:11:25 <shachaf> return :: a -> e -> a discards an e; join :: (e -> e -> a) -> e -> a duplicates an e
11:11:40 <EvanR> circ-user-v8z6i: did these apis include signatures of the form void foo() ?
11:11:52 <shachaf> extract :: (e,a) -> a discards an e; duplicate :: (e,a) -> (e,(e,a)) duplicates an e
11:11:54 <EvanR> if so, under what circumstances can that be composed
11:11:59 <circ-user-v8z6i> the who point about monads as means of composition are a bit beyond me anyway. It is all "tactical coding" related. But not architectural. The times where people write 1M lines monolithic applications are long over.
11:12:08 <EvanR> forget monads
11:13:07 <Zemyla> Also, the Maybe Monad is basically just the ((,) All).
11:13:17 <circ-user-v8z6i> lets take for example the classic interface: IRestfulHttp { get, put, update, delete ... }
11:13:19 <EvanR> to answer the question if i can compose this thing, im reading the 300 page specification that is sometimes not even followed. instead of reading the type signature
11:13:28 <Zemyla> *((,) All) Monad.
11:13:30 <circ-user-v8z6i> replace such an Interface with a monad ;)
11:13:43 <shachaf> Zemyla: Not particularly.
11:13:57 <EvanR> that http is a good example of an interface requiring you to read the http spec to understand the "supposed" guarantees its making
11:14:00 <shachaf> There's no equivalent of Nothing.
11:14:13 <EvanR> its like Object put(Object)
11:14:28 <circ-user-v8z6i> you never can use anything without "reading the spec". No matter how the notation is.
11:14:39 <Zemyla> Nothing is basically (False, _) with a tacit agreement to never access the value when it's false.
11:15:02 <Hijiri> b-but tthat's not even isomorphic
11:15:33 <EvanR> examples of things you can use without needing a spec are: natural numbers, the unit type, a pair of types (A,B) for some A and B, the disjoint union of two types Either A or B, we arent given these in java
11:15:44 <Hijiri> Either () a is, though
11:16:14 <EvanR> also records of types (with field names)
11:16:19 <Zemyla> I'm trying to figure out what Comaybe is.
11:16:23 <circ-user-v8z6i> I veto on that. Natural numbers (in comuters) either blow your memory or they have a limited range. is it a 16 or 32 bit type you talk about? :)
11:16:46 <Welkin> > 1/0
11:16:48 <lambdabot>  Infinity
11:16:59 <EvanR> > product [1..100]
11:17:00 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
11:17:04 <EvanR> memory not blown
11:17:20 <circ-user-v8z6i> add a few 0 in the right place and blow it will
11:17:37 <EvanR> and then theres the big one, functions from A to B (regular functions, not procedures with side effects) all these dont require a spec to understand
11:17:41 <Hijiri> > product [1..10000]
11:17:42 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
11:17:44 <johnw> shachaf: what are the three monoidal structures in the category of endofunctors?
11:17:46 <EvanR> > product [1..100000]
11:17:50 <lambdabot>  mueval-core: Time limit exceeded
11:17:56 <EvanR> time blown up
11:18:19 <EvanR> the memory a number uses is proportional to log n
11:18:22 <Zemyla> You blew up time? Oh no, Lavos is coming!
11:18:25 <circ-user-v8z6i> but for those - formerly called reentrant functions (in the embedded world, since like 35 years), you need no functional language. All you need is...write them.
11:18:27 <brainacid> cant get arch installed
11:18:33 <brainacid> have done arch install before
11:18:35 <ReinH> circ-user-v8z6i: that is the worst definition of Monad I have ever heard.
11:18:45 <ReinH> Are you trying to troll us?
11:18:47 <brainacid> installing on chromebook c710
11:19:03 <brainacid> firmware reflahed and write-protection is disabled
11:19:06 <circ-user-v8z6i> and for those impure functions which actually meddle with world state, the same applies. if you wrap some IO {} tag around them or not is just....arbitrary.
11:19:36 <brainacid> shit
11:19:40 <brainacid> wrong channel
11:19:41 <brainacid> forgive me
11:19:52 <Hijiri> there's a difference between types and tags
11:19:58 <Hijiri> maybe not in javascript
11:20:35 <ReinH> I'm going with troll.
11:21:03 <EvanR> i doubt anyone remembers COM programming fondly
11:21:22 <circ-user-v8z6i> there is a thing called side effect. And we all agree that it exists. Sometimes it is also the MAIN effect. We also can agree on that, me thinks. Then, usually code is executed in the context of a function. So there is no need to introduce complex concepts like monads to express the trivial fact that some functions are "handle with care" and some are not.
11:21:42 <ReinH> circ-user-v8z6i: you aren't saying anything interesting or useful.
11:21:54 <Zemyla> Sweet Jesus, word salad.
11:21:59 <mando> Hey can anyone recomend a good free learning option for haskell?
11:22:07 <mando> I am very new to it
11:22:09 <Hijiri> mando: https://github.com/bitemyapp/learnhaskell
11:22:16 <mando> thx
11:22:24 <circ-user-v8z6i> I make my point. all our models on how we see what we do are constructed models. Monads are not "enforced by nature". They are just yet another model.
11:23:21 <ReinH> circ-user-v8z6i: Again, not interesting or useful.
11:24:00 <ReinH> Of course it's a model. There's nothing wrong with that. But clearly you aren't here for discussion. You are just here to spout your nonsense and get a reaction.
11:24:23 <gershlose> monad is an extremely natural model
11:24:53 <augustss> Why can't people stop talking about monads!
11:24:59 <augustss> ?!?
11:25:10 <EvanR> the interblag demands it
11:25:37 <augustss> It's like some people think that's what FP is all about.
11:25:40 <circ-user-v8z6i> I doubt you were here from the start. It was about the power of the concept of a SET of functions, widely known as Interface. And whether or not you can do function (feature) composition with it. Also, the topic was about whether or not all that functional Monad style composition topis is but tactical but not archittectural relevant.
11:26:07 <ReinH> circ-user-v8z6i: nothing you're saying makes sense. Please stop.
11:26:20 * hackagebot align-text 0.1.0.0 - A simple unix filter to align text on specified substrings  http://hackage.haskell.org/package/align-text-0.1.0.0 (DanielChoi)
11:26:21 <circ-user-v8z6i> omg is he a fanatic? Then indeed I should stop.
11:26:25 * mada chuckles
11:26:30 <augustss> I don't see what monads have to do with composing interfaces at all.
11:26:47 <ReinH> This is a waste of time.
11:27:33 <gershlose> what are the laws the Interface class obeys
11:27:41 <mada> I strongly believe there *is* such a thing as a "you need to read this and that before we can have a sensible discussion"
11:27:43 <ReinH> Let's not feed the troll please.
11:27:45 <circ-user-v8z6i> You do not usually compose functions or interfaces. You "integrate" functionality, features - however you call it. So, using a set of interfaces, such as web services, you can compose them to yield new functionality. Monads combine a few local in process functions. Nothing more. Nothing less.
11:28:06 <ReinH> This is all just word salad. It's not worth engaging with.
11:28:08 <mada> Otherwise people just say words.
11:28:26 <ReinH> People who don't understand monads should not attempt to explain to people who do understand monads what monads are.
11:28:45 <EvanR> circ-user-v8z6i: check out this version of "interface" its similar to what you say. http://ojs.academypublisher.com/index.php/jsw/article/view/jsw070511361148 but with the difference that your code is well typed, to the point where it cant infinite loop
11:28:48 <augustss> circ-user-v8z6i: what you said makes no sense to me.
11:28:51 <rhaps0dy> augustss: but people like to eat burritos
11:29:04 <EvanR> gershlose: ^
11:29:04 <circ-user-v8z6i> talking to you is pointless reinh. You are a one topic pony: "I know monads and I am proud of it"
11:29:24 <augustss> I had a great burrito yesterday.  I never thought of monads while eating it.
11:29:31 <ReinH> augustss: your loss, I guess.
11:29:37 <rhaps0dy> but monads are like burritos augustss :)
11:29:44 <ReinH> circ-user-v8z6i: And yours is "I don't know monads and I am proud of it".
11:29:44 <lachenmayer> more interestingly, is there a special trick to get ghci to work within a cabal sandbox?
11:29:46 <rhaps0dy> hue hue hue
11:29:59 <lachenmayer> the code compiles with "vanilla" ghc, but ghci complains about missing modules
11:29:59 <augustss> rhaps0dy: burritos are a lot tastier
11:30:00 <rhaps0dy> lachenmayer: it doesn't work?
11:30:08 <rhaps0dy> unfortunately I haven't used a cabal sandbox ever
11:30:11 <johnw> augustss: lol
11:30:15 <rhaps0dy> augustss: I guess. I have never eaten a burrito :(
11:30:21 <circ-user-v8z6i> Actually i know what they are. But I DARE to point out that this for sure is not the end of the line. In 20 years noone will really find them worth creating a language around.
11:30:21 <johnw> I just ate a burrito, during a monad discussion, and never thought to link the two
11:30:24 <lachenmayer> actually, not even. hmmmm.
11:30:32 <ReinH> circ-user-v8z6i: Nothing you've said about monads has been accurate.
11:30:37 <shachaf> circ-user-v8z6i: OK, this isn't OK for this channel at this point. Please stop.
11:30:40 <ReinH> Little of it has even been sensical.
11:30:47 <ReinH> So please just stop.
11:31:16 <rhaps0dy> johnw, augustss: https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
11:31:17 <shachaf> This goes for several other people. rhaps0dy et al., please keep this channel a pleasant place.
11:31:20 * hackagebot HStringTemplate 0.8 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.8 (SterlingClover)
11:31:39 <rhaps0dy> shachaf: s-sorry
11:31:44 <circ-user-v8z6i> I said they are like eels in a tub of oil. One of my objections is that they not easily pinned down. If you discuss them in the context of side effects, people blame you for not mentioning that they are " a much larger abstraction for ANYTHING". But we all know wat an "all-theory" is, right?
11:31:54 <Zemyla> :t (coerce (+))::(Sum Int)
11:31:55 <lambdabot>     Couldn't match expected type ‚ÄòSum a0‚Äô
11:31:55 <lambdabot>                 with actual type ‚Äòa1 -> a1 -> a1‚Äô
11:31:55 <lambdabot>     Probable cause: ‚Äò(+)‚Äô is applied to too few arguments
11:32:20 <Zemyla> :t (coerce (+))::((Sum Int)->(Sum Int)->(Sum Int))
11:32:21 <lambdabot>     No instance for (Contravariant ((->) (Sum Int)))
11:32:21 <lambdabot>       arising from a use of ‚Äòcoerce‚Äô
11:32:21 <lambdabot>     In the expression:
11:32:30 <dmj`> Still don't get the monad burrito analogy, I never unwrap my burrito while eating it
11:32:45 <augustss> Monads are like eels in a tub of oil.  I like that.  I'll start using it.  It makes no sense, of course.
11:32:53 <johnw> hahaha
11:33:05 <EvanR> sounds also tasty
11:33:11 <lachenmayer> dmj`: the monad is the tin foil around the burrito? ;)
11:33:13 <augustss> Smoked eels
11:33:13 <ReinH> Again with the word salad.
11:33:15 <circ-user-v8z6i> makes more sense than saying " a programmable comma" or "a burrito" to me :)
11:33:15 <johnw> dmj`: I've never gotten it either
11:33:24 <rhaps0dy> lachenmayer: nono the tortilla
11:33:27 <rhaps0dy> oh
11:33:35 * rhaps0dy blushes
11:33:38 * EvanR goes to lunch
11:33:50 <rhaps0dy> bon appetit
11:33:53 <circ-user-v8z6i> ReinH - at one point you should ask yourself if , if you fail to understand something it is the ones saying it or you hearing is is to blame.
11:34:06 <clrnd> the programmable comma makes a lot of sense to me, because of do-notation ofc
11:34:20 <Zemyla> My favorite analogy is "Imagine the entire universe was burrito filling. Comonads are the pockets of non-burrito space lined with a tortilla wrap that you might find yourself living in."
11:34:21 <mada> The most ironic reply so far.
11:34:24 <augustss> programmable semicolon
11:34:42 <shachaf> circ-user-v8z6i: This is an official warning. You're being hostile and unpleasant. Please stop.
11:34:51 <lachenmayer> the programmable semicolon thing does not help with understanding monads, but once you do, it's a pretty neat way of thinking about it imho
11:35:06 <clrnd> yes!
11:35:06 <circ-user-v8z6i> You see Zemyla - and noone brings in the most important thing of all: The huge glass of cool beer next to that burrito plate.
11:35:13 <clrnd> now I program all my semicolons
11:35:31 <jfischoff> the programmable semi colon is interesting after you have walked through do notation desugaring IMO
11:35:32 <augustss> All your semicolon are belong to use.
11:36:37 <cite-reader> "Programmable semicolons" was the intuition that made me realize Amazon's Flow frameworkd for Java was basically a hell of a lot of ceremony to put the code in a different monad, with a little sticky note that says "Please don't use IO."
11:36:46 <ReinH> circ-user-v8z6i: I do ask myself that, and since other people agree with me I am satisfied that I am not the one with the problem. But thanks for the suggestion.
11:37:09 <circ-user-v8z6i> And even though I found like 20 articles on the net. Noone ever managed to classify the use cases. So there is some "context, state" hidden in the monad in a chain of functions executed (in sequence). Use case a: "those functions needd to interact with the state"  B: The return value of the functions interacts with the state. c: No interaction at all.
11:37:27 <ReinH> circ-user-v8z6i: Have you read Wadler's original monads for functional programming paper?
11:37:59 <circ-user-v8z6i> ReinH I am not really in the mood to compare e-dicks. So stop your rant, please.
11:38:19 <lachenmayer> ok PSA, this has been messing with my head for the past ~3 hours: invoking ghc/ghci in a cabal sandbox does not actually look for the packages inside the sandbox, to run ghci in a sandbox use `cabal repl`
11:38:19 --- mode: ChanServ set +o edwardk
11:38:20 <ReinH> circ-user-v8z6i: What? I am offering you a resource. No need to be a jerk.
11:38:24 --- kick: circ-user-v8z6i was kicked by edwardk (circ-user-v8z6i)
11:38:24 --- mode: edwardk set +b circ-user-v8z6i!*@*
11:38:26 <augustss> circ-user-v8z6i: But that's a good paper.
11:38:37 <edwardk> next
11:38:41 --- mode: edwardk set -o edwardk
11:38:42 <jfischoff> thanks edwardk
11:38:44 <bshelden> Morning, edwardk
11:38:47 <edwardk> morning
11:40:30 <augustss> edwardk: Monads are like eels in a tub of oil.
11:40:32 <mada> This place is untrollable.
11:41:01 <edwardk> augustss: that is a slippery thought to hold on to.
11:41:08 <hiptobecubic> augustss, that is a great line. New favorite analogy I think.
11:41:10 <ReinH> augustss: I actually like that one.
11:41:22 <ReinH> augustss: Slippery and dead?
11:41:28 <augustss> I'm not sure how.
11:42:10 <edwardk> ReinH: i suppose its a lot easier to cook the whole tub than to try to catch the individual eels at that point, but then you could just wait for them to suffocate.
11:42:11 <augustss> I've never written a monad tutorial.
11:42:31 <ReinH> Delicious eel confit?
11:42:33 <augustss> Perhaps the time has come.
11:42:33 <johnw> augustss: I would love to see a monad tutorial presentation from you at HIW
11:42:39 <ReinH> HIW?
11:42:40 <bshelden> ahh, #haskell.  Don't ever change...
11:42:41 <edwardk> monads are 2 or 3 operations and 3 laws, if you have them and can pass the laws you're in the club. done, nuff said. =)
11:42:44 <johnw> Haskell Implementors Workshop
11:42:50 <ReinH> oh at ICFP?
11:42:53 <johnw> yeah
11:43:02 <johnw> augustss gave a hilarious presentation at the last one
11:43:06 <ReinH> Oh I'm actually going to this one yay!
11:43:09 <johnw> one of the funniest of the conference
11:43:21 <augustss> I only had 5 minutes.
11:43:35 <johnw> "Unlike some other solution you've seen today, mine is fully baked; you just can't have the cookie."
11:43:36 <xplat> what kiwhat kind of oil?  olive oil?  motor oil?
11:43:52 <johnw> augustss: quality, not quantity :)
11:43:59 <hiptobecubic> xplat, fish oil, of course
11:45:08 <Welkin> there is a cookie shop at my university called Baked
11:45:16 <xplat> ah, so the omega-3 fatty acids represent associativity of bind
11:45:19 <Welkin> the employees all wear tie-dye shirts
11:45:34 <Welkin> and everything has a marijuana theme
11:45:56 <Welkin> they are open late for high/drunk people to buy expensive cookies
11:45:57 <johnw> it's hard to suggest that Haskell related jokes may not belong on #haskell, but perhaps at this point the humor could move to -blah so we can resume with the technical questions?  :)
11:46:28 <augustss> johnw: What's your question?
11:46:46 <xplat> i have a technical question, but i'm not sure who can answer it besides luite
11:46:55 <johnw> shachaf suggested there were three different monoids in the category of endofunctors; was he meaning (->) (+) and (,)?
11:47:25 <koala_man> Welkin: the girl scouts are clearly doing it wrong
11:47:28 <johnw> I have a feeling i'm thinking at the wrong level
11:48:03 <xplat> johnw: when did shachaf suggest that?
11:48:25 <johnw> 13:00 <shachaf> Any other monoidal structures on the category of Hask endofunctors other than the obvious three?
11:48:50 <erisco> edwardk, how relevant is this today? https://www.fpcomplete.com/user/edwardk/phoas I had not heard of this until now but it is pertinent to me
11:48:53 <johnw> oh, he did say monoidal structures
11:49:22 <erisco> edwardk, about HOAS specifically
11:49:33 <edwardk> erisco: well, it is a sane way to implement name capture with hoas-like syntax. if i'm going to offer hoas-like binding in haskell i tend to prefer the approach i just blogged about though
11:49:43 <edwardk> http://comonad.com/reader/2014/fast-circular-substitution/
11:49:56 <edwardk> ^- that approach is a bit easier to work with than the one in the phoas-for-free article
11:49:57 <erisco> thanks
11:50:04 <edwardk> and has the benefit of giving you a monad for substitution
11:50:15 <edwardk> and letting you use traverse to get your free variables like bound
11:50:22 <ReinH> circular substitution is so clever
11:50:40 <edwardk> Set.fromList . Foldable.toList is a very nice way to extract free variables
11:50:56 <edwardk> or foldMap singleton
11:51:22 <benzrf> hey edwardk since you're online
11:51:26 <xplat> johnw: not sure which 3 he means.  i can think of composition, pointwise product, Day convoluted product, pointwise coproduct, Day convoluted coproduct
11:51:32 <xplat> which is 5
11:51:41 <johnw> oh, cool
11:51:44 <bshelden> Can anybody suggest a resource for learning how to implement type inference for a haskell-lite type system?
11:51:49 <johnw> thanks, xplat!
11:51:51 <edwardk> the main thing the phoas-for-free article gave was a way to see that phoas was just a regular free monad in disguise where folks had been conflating the positive and negative positions
11:51:59 <benzrf> edwardk: how do you feel about optics that have undefined behavior when given operating functions that don't satisfy untypecheckable invariants
11:52:09 <benzrf> edwardk: i know that you have a couple in lens already
11:52:17 <edwardk> benzrf: i'm generally uncomfortable with them, but they are occasionally quite useful
11:52:30 <johnw> bshelden: at some point in the future, this will: http://dev.stephendiehl.com/fun/
11:52:31 <augustss> bshelden: http://web.cecs.pdx.edu/~mpj/thih/thih.pdf
11:52:38 <edwardk> i try very hard to avoid them but then sometimes give in and write them anyways because i'm a bad bad man.
11:52:39 <benzrf> edwardk: so why not some kind of zipped traversal thing that relies on the operation to keep its pairs and eithers straight
11:53:16 <edwardk> i don't quite understand what you mean, one that takes two traversals of the same length?
11:53:24 <bshelden> danke
11:53:29 <benzrf> no, more like
11:53:31 <edwardk> i try to keep the invariants that i rely on 'local'.
11:53:39 <benzrf> edwardk: how so
11:54:02 <edwardk> i mean keeping them to where they don't require global reasoning about the program, so that you can reason about the correctness of a chunk of code locally to that chunk as much as possible
11:54:10 <benzrf> oh thats fine
11:54:14 <Zemyla> @quote church
11:54:15 <lambdabot> sorear says: I find it very amusing how Church's abstract nonsense turned out to make for better programming than Turing's real-world metaphors.
11:54:15 <benzrf> this satisfies that :)
11:54:22 <benzrf> edwardk: do you remember how i was asking about rank 2 traversals and showed some example code?
11:54:30 <benzrf> edwardk: i was using forall to encode the invariant at the type level?
11:54:32 <edwardk> e.g. 'monadic lenses' that can reference through an IORef are bad, because they require you to know a global invariant, that its not possible to get to the same reference through itself
11:54:46 <edwardk> benzrf: i confess i've kinda blotted it out
11:54:50 <benzrf> :p
11:54:56 <benzrf> the basic idea was
11:55:11 <edwardk> benzrf: but the main concern i have with rank-2 traversals in lens-as-it-exists is that you can't make them nicely compose
11:55:15 <benzrf> yeah
11:55:17 <edwardk> with hask you can get nice rank-2 traversals
11:55:23 <edwardk> but hask isn't lens
11:55:28 <benzrf> you told me this last time
11:55:39 <benzrf>   data Side = L | R | B
11:55:53 <edwardk> ultimately the whole point of lens is it provides a compositional vocabulary of lens-likes and a compositional vocabulary of what you can do with them
11:56:16 <bshelden> johnw: ooo, the Hindley-Milner Inference chapter is up.
11:56:23 <edwardk> and if it doesn't fall into that framework it is many things, its just not something that goes in 'lens ;)
11:56:32 <johnw> bshelden: oh, cool!
11:56:42 <edwardk> kind of like how query isn't a monad. its lots of neat things. its just not that.
11:56:42 <benzrf>   data ZipElement l r s where First :: l -> ZipElement l r L; Both :: l -> r -> ZipElement l r B; Second :: r -> ZipElement l r R
11:56:49 <benzrf> edwardk: that type ^
11:56:52 <benzrf> edwardk: then a function like
11:57:07 <benzrf> forall i. ZipElement a b i -> ZipElement x y i
11:57:15 <edwardk> yeah that works fine in something like hask
11:57:22 <xplat> a stratified category of lenses and a bunch of monotone endofunctors
11:57:23 <benzrf> is safe to zip with and operate on the tail
11:57:36 <edwardk> and its kinda the point of things like multiplate / jmacro's multicompos
11:57:59 <shachaf> xplat: Oh, Day convolution.
11:58:07 <benzrf> edwardk: anyway if you drop the type guarantee and make the onus on the programmer to return the same bits as went in
11:58:17 <benzrf> edwardk: you can still use functions like that in a Lens
11:58:21 <benzrf> er, Traversal really
11:58:32 <edwardk> sure, we have a couple of them already, partsOf, etc.
11:58:37 <benzrf> :t partsOf
11:58:38 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
11:58:42 <edwardk> unsafePartsOf requires you to not change the length of the list
11:58:42 <benzrf> ah that's what it was called
11:58:50 <benzrf> edwardk: and partsOf...?
11:59:03 <edwardk> > [(1,2),(3,4)]^.partsOf (traverse.both)
11:59:05 <lambdabot>  [1,2,3,4]
11:59:09 <edwardk> > [(1,2),(3,4)]^.unsafePartsOf (traverse.both)
11:59:10 <lambdabot>  [1,2,3,4]
11:59:17 <Zemyla> Also, WTF, so anime. https://33.media.tumblr.com/0d8975c1965711e3b654e3b7ff293c42/tumblr_nhpuanSQlR1tkwztbo1_1280.png
11:59:20 <benzrf> > over (partsOf traverse) tail [1, 2, 3]
11:59:21 <lambdabot>  [2,3,3]
11:59:22 <edwardk> the difference is that unsafePartsOf lets you change a to b
11:59:27 <edwardk> :t unsafePartsOf
11:59:27 <lambdabot> Functor f => Traversing (->) f s t a b -> LensLike f s t [a] [b]
11:59:28 <benzrf> ooh
11:59:31 <shachaf> If you're just viewing partsOf, you can use toListOf. :-)
12:00:05 <edwardk> partsOf is a bit more friendly. if you don't give back enough elements to replace everything it just replaces the ones you gave
12:00:09 <benzrf> > over (partsOf traverse) (map show . tail) [1, 2, 3]
12:00:10 <lambdabot>  No instance for (GHC.Num.Num GHC.Base.String)
12:00:10 <lambdabot>    arising from the literal ‚Äò1‚Äô
12:00:18 <edwardk> > [(1,2),(3,4)] & partsOf (traverse.both) .~ [5,6,7]
12:00:19 <lambdabot>  [(5,6),(7,4)]
12:00:24 <benzrf> > over (unsafePartsOf traverse) (map show . tail) [1, 2, 3]
12:00:24 <edwardk> > [(1,2),(3,4)] & unsafePartsOf (traverse.both) .~ [5,6,7]
12:00:25 <lambdabot>  can't find file: L.hs
12:00:25 <lambdabot>  ["2","3","*Exception: unsafePartsOf': not enough elements were supplied
12:00:35 <edwardk> > [(1,2),(3,4)] & unsafePartsOf (traverse.both) .~ "hello"
12:00:36 <lambdabot>  [('h','e'),('l','l')]
12:00:38 <benzrf> cool
12:01:03 <benzrf> edwardk: i'd expect this kind of traversal to just truncate if it suddenly gets back the wrong type
12:01:10 <edwardk> partsOf doesn't drop bottoms in your code, unsafePartsOf does
12:01:23 <benzrf> well i guess zipping traversals themselves wouldn't let that work
12:01:23 <edwardk> it's a question of style, which you prefer, power or safety
12:01:31 <erisco> oh I like this paper http://www.cse.chalmers.se/~emax/documents/axelsson2013using.pdf such clarity
12:01:50 <edwardk> in a better world, i'd use an indexed traversal where you got back a vector of length n, where n is the type level index you have to preserve
12:01:57 <Zemyla> Why are they called bottoms? It sounds weird.
12:01:58 <clrnd> Zemyla, that was painful
12:02:00 <edwardk> er an indexed lens
12:02:14 <erisco> also I like that as soon as "hey, that will lead to quadratic complexity" they immediately follow up with "so about the quadratic complexity problem"
12:02:25 <erisco> nice to be on the same wavelength :)
12:02:37 <edwardk> Zemyla: it has to do with viewing terms as living in a partial ordering. where 'bottom' is the bottom of the ordering, below everything else.
12:03:03 <edwardk> so you have something like, 1,2,3,4,5  all sitting at one level, and a bottom _|_ node below them that is 'less than' all of them in the ordering of definedness.
12:03:20 <edwardk> errors, non-termination, etc. are all a form of this 'lesser' defined form.
12:03:28 <edwardk> of this lesser defined thing
12:04:03 <anastas> fg
12:04:03 <benzrf> Zemyla: it's cause if you squint ‚ä• kinda looks like a bottom
12:04:20 <xplat> domain theorists are not known for their glutes of steel
12:04:30 <edwardk> then we can talk about how (a,b) can have a definedness ordering it can be a _|_ itself, it could be (_|_, b)   or (a, _|_) etc.  and we can talk about the fact that _|_ is less defined than (_|_, a), etc.
12:04:33 <xplat> their bottoms are completely lacking in definition
12:04:42 <johnw> Zemyla: in a lattice, there are elements which are conceptually at the "top" and "bottom"
12:04:54 <benzrf> xplat: aaaaaaaayyyyyy
12:04:59 <Zemyla> So what is top?
12:05:02 <shachaf> There is no top.
12:05:07 <edwardk> if we work in this formalism then the fact that some things 'don't compute' fits into our model of computation.
12:05:11 <johnw> Zemyla: inhabitants of a type form a lattice according to definedness, so bottom is the least defined value of that type.  There is no top in this context
12:05:21 <shachaf> There's no lattice of terms (usually).
12:05:24 <johnw> so it's a semi-lattice
12:05:35 <xplat> shachaf: in unit there's a top
12:05:46 <shachaf> xplat: Hence "(usually)".
12:05:50 <xplat> shachaf: also in void there's a top, but it's bottom
12:05:51 <shachaf> xplat: Just () has a top too.
12:06:00 <shachaf> Er, Maybe ()
12:06:02 <edwardk> Zemyla: we're looking for the notion of a 'complete partial order' or CPO here
12:06:04 <shachaf> Where the top is Just ().
12:06:35 <shachaf> partsOf has the disadvantage of flattening your traversal
12:06:52 <edwardk> Zemyla: so we can always talk about _|_ being the least such element, but 1, 2, 3, etc. are all 'equally well defined' none are more defined than the others.
12:06:53 <xplat> shachaf: not sure what you mean by that
12:07:14 <shachaf> xplat: By which one?
12:07:35 <xplat> shachaf: partsOf flattening your traversal
12:07:46 <edwardk>  Zemyla the idea is that what we can do is work with this notion of a partial order, and then say that all functions are monotone with respect to this order. that prevents you from determining if the argument is undefined and acting differently
12:07:50 <shachaf> xplat: Well, you're looking at it as a list, so it has to be from left to right.
12:08:06 <shachaf> Depending on the manipulation that you want to do, that could be bad or no problem.
12:08:16 <shachaf> I don't remember whether we still have the magma version.
12:08:18 <edwardk> with that in hand you get a nice notion of computation you can reason about
12:08:40 <xplat> shachaf: er, it's always like that?  the magma thing is lawless...
12:09:14 <shachaf> xplat: OK, you could have an FMList version too.
12:09:14 <Zemyla> Yeah, there's a reason monoids are used for folds.
12:09:37 <mpickering> When is the right time to use Data.ByteString.Char8?
12:09:41 <shachaf> (I mean the "free pointed magma" version of partsOf that gives you a tree rather than a list.)
12:09:48 <shachaf> mpickering: Rarely.
12:10:26 <Zemyla> Though fold1 could theoretically use a semigroup instead of a monoid.
12:10:35 <edwardk> ultimately it comes down to how your functions are allowed to deal with _|_. e.g. consider monotone functions from Bool -> Bool.    in this world Bool has True, False, and _|_ as inhabitants with _|_ < True and _|_ < False. monotonicity says a lot about what such functions there are. (I'm going to ignore seq because it complicates things a bit)
12:11:13 <edwardk> mpickering: some time around 1980
12:12:11 <shachaf> Hah, edwardk++
12:12:23 <xplat> shachaf: that's less 'partsOf flattens your traversal' and more 'magmaPartsOf actually takes something other than a traversal, and treating those things as traversals flattens them'
12:12:47 <shachaf> @remember edwardk <mpickering> When is the right time to use Data.ByteString.Char8? <edwardk> mpickering: some time around 1980
12:12:48 <lambdabot> Okay.
12:12:56 <clrnd> succ edwardk
12:13:14 <mpickering> seriously though, what should you do instead? decodeUtf8?
12:14:07 <shachaf> xplat: What do you mean? They both deal with traversals.
12:14:21 <shachaf> One of them pretends the structure of a traversal is flat, which isn't really true in Haskell.
12:14:30 <sclv> bshelden: here's a nice lightweight toy language with type inference written by someone i know -- https://github.com/texodus/forml
12:14:38 <shachaf> The other one exposes the structure of a traversal completely, which is law-violating.
12:14:59 <sclv> bshelden: and this is the famous paper on typing haskell in haskell including typeclasses: http://web.cecs.pdx.edu/~mpj/thih/
12:15:07 <sclv> i think there are some updates to it and various implementations floating around
12:15:09 <xplat> shachaf: a traversal isn't required to take an Applicative that doesn't follow the associative and unit laws
12:15:15 <bshelden> Yeah, got that one on my reading list
12:15:18 <bshelden> The language looks nifty
12:15:25 <bshelden> I think I have some homework to read at this point
12:15:35 <bshelden> Hoping to come out the other end with a better grasp on type theory
12:15:45 <sclv> here's a talk he gave on the basic basics of forml https://vimeo.com/64593770
12:15:47 <shachaf> xplat: If I said FMList instead of Magma, would you feel differently about it?
12:16:07 <xplat> shachaf: no
12:16:17 <shachaf> I'm not saying that Magma is the right solution, just that it's not so great to use [].
12:21:22 * hackagebot happstack-authenticate 0.10.16 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.10.16 (JeremyShaw)
12:22:32 <xplat> since Agda can express the laws in its types, it calls an Applicative with no laws a RawApplicative.
12:23:01 <ReinH> Or Rawpplicative, as I like to call it.
12:24:53 <tolt> ReinH: Do you have any suggestions for a mailbox like data structure? I'm using pipes concurrent right now but I'd like something that keeps it as one type.
12:25:02 <zxd> hi
12:25:05 <tolt> instead of  (Input a, Output a)
12:25:14 <zxd> getting haskell for centos 6   how help ?
12:25:20 <ReinH> tolt: ... that is one type ;)
12:25:25 <zxd> it says in the website "Source Distribution:¬†Build the platform on your system. Requires a pre-existing, working haskell system.
12:25:25 <zxd> "
12:25:36 <tolt> I know. But I really like the monad/applicative instance on input
12:25:36 <zxd> but I dont have a working haskell system
12:26:01 <zxd> ah I see a link there
12:26:05 <zxd> justhub
12:26:49 <xplat> shachaf: forall f. RawApplicative f => (a -> f b) -> (s -> f t) is something we could call a ChunkyTraversal, and it more or less lives between Lens and Traversal in the hierarchy.
12:27:21 <shachaf> Does RawApplicative obey the functor laws?
12:27:35 <shachaf> Agda is different, anyway, because it doesn't allow for infinite traversals.
12:27:47 <shachaf> At least I assume it doesn't, the way we do them.
12:28:11 <shachaf> In which case a list-based partsOf is at most inefficient.
12:28:15 <tolt> Ahh! Never mind ReinH. This model works!
12:28:17 <xplat> shachaf: ChunkyTraversal is the proper type for toFMListOf and fmPartsOf
12:28:42 <shachaf> Why? FMList doesn't break the Monoid laws.
12:30:18 <xplat> FMList does break the Monoid laws insofar as functions out of it don't have to respect its Eq instance
12:30:39 <shachaf> Why?
12:31:23 * hackagebot matrix 0.3.4.1 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.3.4.1 (DanielDiaz)
12:31:36 <shachaf> The only way distinguish (x) and (x <> mempty) is to use an invalid Monoid instance of your own.
12:31:56 <xplat> shachaf: or 'show' ... ?
12:32:14 <shachaf> show?
12:32:22 <edwardk> if your show can distinguish them you gave an evil monoid
12:32:24 <shachaf> Œª> FM.fromList [1,2,3]
12:32:24 <shachaf> fromList [1,2,3]
12:32:41 <tasker> If I have  -fprof-auto in my ghc options, does this reduce performance in any way?
12:33:05 <xplat> ah, i might misunderstand something about FMList, where is the source?
12:33:13 <shachaf> http://hackage.haskell.org/package/fmlist-0.9/docs/src/Data-FMList.html
12:34:10 <tommd> tasker: Yes!
12:34:37 <tommd> profiling impacts the very properties you are probably hoping to measure and thus is much less useful than most people expect.
12:34:50 <tasker> tommd: I assumed this was the case! Is there a convenient way to have this turn on in a .cabal file if you want to do profiling? And not otherwise?
12:35:05 <tasker> tommd: Surely it accuratley shows cost centres, though ?
12:35:19 <tommd> Sure, cabal has flags you can use and pass on the command line via -fSOMEFLAG
12:35:37 <tommd> tasker: Number of entrires, sure.  Allocations and times? No.
12:35:53 <tasker> tommd: Well, number of entries is good enough for me :)
12:36:08 <tasker> Surely profiling and benchmarking are different things, anyway.
12:48:28 <platz> why is fmlist better than a church list?  church lists seem more general forall r. (a -> r -> r) -> r -> r  vs  forall m . Monoid m => (a -> m) -> m }
12:49:03 <shachaf> Look at the documentation at the top of that module.
12:49:44 <ReinH> platz: Isn't it the other way around? m ~ Endo gives you church lists?
12:50:08 <ReinH> so church lists are a specialization of fmlists
12:50:27 <ReinH> Then again, I guess you can encode any monoid in Endo
12:50:45 <ReinH> so they are equivalent?
12:51:13 <platz> well the church list doesn't have a monoid constraint for one
12:51:38 <ReinH> platz: right, because it is specialized to a particular monoid instance already
12:51:49 <ReinH> I don't need a Monad constraint on IO ()
12:52:26 <ReinH> but IO () is not more general than Monad m => m ()
12:52:42 <ReinH> or is that Monad m *> m ()
12:52:50 <platz> ah, i might have the terminonology backwards
12:53:24 <xplat> shachaf: ah, this FMList is different from what i thought.  it has the same finite, fully-defined values as [], assuming you only pass it Monoids and not RawMonoids
12:53:42 <shachaf> xplat: Right.
12:55:57 <xplat> shachaf: then i guess you can get one out of a Traversal.  it postpones, in Haskell, the choice between Traversal and ChunkyTraversal until you actually use the FMList...
12:56:18 <tasker> Is it necessary to explicitly use Data.Vector.Fusion.Stream to get stream fusion? Or does it "just happen" with Data.Vector ?
12:56:23 * hackagebot koofr-client 1.0.0.1 - Client to Koofr API  http://hackage.haskell.org/package/koofr-client-1.0.0.1 (edofic)
12:56:37 <shachaf> xplat: In the case of infinite traversals, even without explicit law violations FMList has more information.
12:58:17 <xplat> shachaf: yeah, i'm not sure what's going on with infinite traversals here.
12:58:41 <shachaf> roconnor will tell you that they don't exist.
12:59:16 <shachaf> But fortunately termination in the infinite case corresponds to asymptotic efficiency in the finite case.
12:59:21 <shachaf> So I care about them even if they don't exist.
13:04:46 <xplat> shachaf: some FMLists are weird.  for example, ‚Äòweird = mempty <> weird‚Äô.
13:05:38 <xplat> ‚Äòweird‚Äô is infinite and empty.
13:05:44 <shachaf> Is that weirder that x = [] ++ x?
13:06:05 <xplat> it's weirder in that it's a fully defined value
13:06:24 * hackagebot effect-handlers 0.1.0.1 - A library for writing extensible algebraic effects and handlers. Similar to extensible-effects but with deep handlers.  http://hackage.haskell.org/package/effect-handlers-0.1.0.1 (edofic)
13:07:30 <zerokarmaleft> > floor $ 2/0
13:07:31 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
13:07:47 <ReinH> xplat: what makes one fully defined and not the other?
13:08:00 <zerokarmaleft> can someone explain the behavior there?
13:08:21 <HeladoDeBrownie> > 2 / 0 :: Double
13:08:22 <lambdabot>  Infinity
13:08:42 <HeladoDeBrownie> it's take the floor of infinity
13:08:51 <HeladoDeBrownie> (which honestly should probably be an error)
13:08:53 <ReinH> HeladoDeBrownie: I suppose the question is why that number is the floor of infinity
13:08:57 <xplat> ReinH: just regular Haskell semantics.
13:09:11 <HeladoDeBrownie> i wonder how floor is implemented
13:09:13 <HeladoDeBrownie> @src floor
13:09:13 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:09:30 <HeladoDeBrownie> @src Double floor
13:09:30 <lambdabot> Source not found. Are you typing with your feet?
13:09:32 <xplat> HeladoDeBrownie: it's the largest (representable) whole number below Infinity?
13:09:33 <ReinH> xplat: Ok, could you be a bit more specific though? I'm not following yet. :(
13:09:45 <ReinH> Something something IEEE 754
13:09:48 <xplat> i guess Infinity is not integral.
13:10:25 <Zemyla> Hmm. foldMapBinS :: (Foldable f, Monoid m, Ord cm) => Maybe (m -> cm) -> (a -> m) -> f a -> m.
13:10:26 <ReinH> xplat: as in, what makes x = [] ++ x not fully defined?
13:10:36 <xplat> > ceil $ 2 / 0
13:10:37 <lambdabot>  Not in scope: ‚Äòceil‚Äô
13:10:41 <burp_> > 1/0 :: Integer
13:10:42 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
13:10:42 <lambdabot>    arising from a use of ‚ÄòGHC.Real./‚Äô
13:11:07 <athan> Do `forall` statements get created _before_ constraint defintions? Something like `foo :: forall x. (Bar x, Eq x) => x -> ...`?
13:11:08 <HeladoDeBrownie> http://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-Float.html#instance%20RealFrac%20Double
13:11:27 <HeladoDeBrownie> i have no idea *why* it's implemented that way, but hopefully that gives some insight into why that value is given
13:11:37 <HeladoDeBrownie> i'd say it really ought to be an error
13:11:47 <zerokarmaleft> interestingly, properFraction $ 2/0 returns (ginormous approx of infinity, 0.0)
13:12:04 <burp_> is it the largest Double?
13:12:11 <burp_> > floor (1/0 :: Double) :: Integer
13:12:13 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
13:13:09 <hiptobecubic> hah
13:14:03 <hiptobecubic> Would be more satisfying to have a bunch of 9's, but I suppose it's as good as any other infinitely repeating number
13:14:32 <zerokarmaleft> hiptobecubic: it's not infinitely repeating
13:14:50 <zerokarmaleft> it's a few lines, but it is bounded
13:14:56 <burp_> > length $ show (floor (1/0 :: Double) :: Integer)
13:14:57 <lambdabot>  309
13:15:10 <burp_> it's just the "largest double"
13:17:19 <burp_> grep /usr/include for DBL or DBL_MAX and you'll find it ;)
13:17:38 <zerokarmaleft> burp_: ah, the length made it clearer
13:18:39 <xplat> ReinH: x = [] ++ x reduces to x = x, which least-fixpoints to x = _|_
13:19:43 <burp_> but I don't understand why "floor (1/0) :: Int" is 0
13:20:22 <xplat> burp_: the least 64 bits of that ginormous integer are 0
13:20:31 <burp_> xplat: ahh
13:20:56 <xplat> > floor $ -2 / 0
13:20:57 <lambdabot>  -179769313486231590772930519078902473361797697894230657273430081157732675805...
13:21:05 <HeladoDeBrownie> burp_, also, considering that number is larger than the guaranteed result of Int, the result is implementation-defined.
13:21:19 <xplat> > floor $ -2 / 0 :: Int
13:21:20 <lambdabot>  0
13:21:26 <xplat> hrm.
13:21:33 <zerokarmaleft> lol, interesting
13:21:46 <HeladoDeBrownie> guaranteed size*
13:23:45 <Welkin> > (-2 / 0) :: Int
13:23:46 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
13:23:46 <lambdabot>    arising from a use of ‚ÄòGHC.Real./‚Äô
13:23:48 <ReinH> xplat: Ah ofc course, thanks
13:24:15 <ReinH> of course course.
13:24:16 <athan> Is it possible to "demote" types, and show that it's equivalent to the original?
13:24:34 <Welkin> > fromIntegral (-2 / 0)
13:24:35 <lambdabot>  Could not deduce (GHC.Real.Integral a0)
13:24:35 <lambdabot>    arising from a use of ‚ÄòGHC.Real.fromIntegral‚Äô
13:24:35 <lambdabot>  from the context (GHC.Num.Num b)
13:24:36 <Welkin> er
13:24:45 <Welkin> > fromFractional (-2 / 0) :: Int
13:24:46 <lambdabot>  Not in scope: ‚ÄòfromFractional‚Äô
13:24:47 <lambdabot>  Perhaps you meant ‚ÄòfromRational‚Äô (imported from Prelude)
13:24:54 <HeladoDeBrownie> athan, what does "demote" mean?
13:24:55 <Welkin> > fromRational (-2 / 0) :: Int
13:24:56 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
13:24:57 <lambdabot>    arising from a use of ‚ÄòGHC.Real.fromRational‚Äô
13:25:16 <Welkin> > floor (-2 / 0) :: Integer
13:25:18 <lambdabot>  -179769313486231590772930519078902473361797697894230657273430081157732675805...
13:25:28 <johnw> athan: you can always write "to/from" functions
13:25:31 <Welkin> should be -Infinity
13:25:56 <athan> johnw: That's what I was thinking :)
13:26:09 <athan> DeladoDeBrownie: DataKinds :)
13:26:28 <HeladoDeBrownie> i'm next to a brownie?
13:28:25 <HeladoDeBrownie> actually no that'd be i'm on the brownie's side, as in i am for the brownie
13:36:25 * hackagebot rest-core 0.34.0.1 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.34.0.1 (ErikHesselink)
13:37:08 <ReinH> hah
13:37:38 <benzrf> :k Free
13:37:39 <lambdabot>     Not in scope: type constructor or class ‚ÄòFree‚Äô
13:37:39 <lambdabot>     Perhaps you meant ‚ÄòTree‚Äô (imported from Data.Tree)
13:37:50 <benzrf> are free monads availabld in lambdabot
13:38:48 <johnw> :k Control.Monad.Free.Free
13:38:49 <lambdabot> (* -> *) -> * -> *
13:40:45 <benzrf> johnw: aha
13:40:50 <benzrf> @let import Control.Monad.Free
13:40:50 <lambdabot>  .L.hs:159:17:
13:40:51 <lambdabot>      Ambiguous occurrence ‚ÄòPure‚Äô
13:40:51 <lambdabot>      It could refer to either ‚ÄòL.Pure‚Äô, defined at .L.hs:155:9
13:40:55 <benzrf> aw.
13:40:57 <benzrf> @undef
13:40:57 <lambdabot> Undefined.
13:41:08 <johnw> just use qualified names
13:41:18 <benzrf> nah im switchin to pm
13:41:26 * hackagebot rest-gen 0.16.1.7 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.16.1.7 (ErikHesselink)
13:41:31 <benzrf> oh i cant import it anyway. nuts
13:41:32 <ReinH> benzrf: it's the same lambdabot in pm though
13:41:39 <benzrf> @let import Control.Monad.Free -- look at this crud
13:41:40 <lambdabot>  <no location info>:
13:41:40 <lambdabot>      The package (profunctors-4.0.3) is required to be trusted but it isn't!
13:41:55 <benzrf> ReinH: oh i assumed he was recommending it on grounds of it generating less spam
13:42:08 * benzrf resorts to actually opening a ghci
13:42:25 <ReinH> That's what I mean. If you define a bunch of stuff in pm it's still polluting the global namespace...
13:42:36 <benzrf> ah
13:42:58 <ReinH> At one point someone came in here and said "please stop undefining things in lambdabot, I am trying to use it in pm." That did not go very well for them...
13:44:43 <ReinH> benzrf: opening a ghci? Like some sort of barbarian?
13:44:48 <johnw> i always wonder why people prefer lambdabot to ghci
13:46:26 * hackagebot rest-stringmap 0.2.0.3 - Maps with stringy keys that can be transcoded to JSON and XML.  http://hackage.haskell.org/package/rest-stringmap-0.2.0.3 (ErikHesselink)
13:47:28 <benzrf> ReinH: they couldve been trapped on a comp w/o ghc
13:47:41 <benzrf> johnw: pure laziness
13:47:52 <pantsman-> johnw, some of the features are quite hard to compile, if possible at all, on some environments
13:47:54 <benzrf> johnw: the kind that makes you ask questions in irc instead of googling
13:48:01 <johnw> well, at least it wasn't some kind of laziness in IO
13:48:09 <ezrios> How can I specify options to GHC in a sandboxed Cabal project?
13:48:23 <ezrios> reason being, I want to get a backtrace after a Prelude ErrorCall
13:48:25 <ezrios> https://www.haskell.org/haskellwiki/FAQ#How_can_I_get_a_stack_backtrace_when_my_program_throws_an_exception.3F
13:48:38 <ReinH> benzrf: lambdabot is a communal resource. It's like leaving your toys all over the place and then complaining when someone else cleans them up. ;)
13:48:41 <pantsman-> I've used djinn and pl and hoogle on lambdabot because I gave up trying to compile them myself
13:48:49 <benzrf> mfw i accidentally type bash commands in ghci
13:49:30 <tolt> benzrf: or typing in haskell in bash
13:49:56 <benzrf> 04:46 < ReinH> At one point someone came in here and said "please stop undefining things in lambdabot, I am trying to use  it in pm." That did not go very well for them...
13:50:08 <benzrf> that one sure :p
13:50:55 <hexagoxel> ezrios: when you are developing a cabal package, or otherwise?
13:51:19 <Zemyla> :t foldMap
13:51:20 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
13:54:06 <johnw> pantsman-: Ah, I use a local lambdabot for those things :)
13:54:36 <ezrios> hexagoxel: I think it's a cabal package.
13:54:45 <Zemyla> Also, why is there no symmetric difference function in Data.Set?
13:54:45 <ezrios> it was created with cabal init
13:56:46 <hexagoxel> ezrios: then you can add e.g. `ghc-options: -fforce-recomp -prof -auto-all` to "Executable" section in .cabal file
13:56:49 <Zemyla> Symmetric difference should be a primitive, because it would be much faster than union (difference a b) (difference b a).
14:00:05 <Zemyla> Also, symmetric difference is a monoid.
14:00:40 <tangentstorm> is there a way to get something like lambdabot in ghci?
14:00:53 <tangentstorm> for like @src, @hoogle, etc?
14:01:32 <hexagoxel> yes; if haskellwiki was not so damn slow i could link you to it..
14:02:04 <ReinH> hexagoxel: you can link to the cached version from google
14:02:30 <hexagoxel> tangentstorm: https://www.haskell.org/haskellwiki/Ghci#Customized_GHCi_interactive_environments
14:02:36 <ReinH> Zemyla: sounds like another good pull request to em
14:02:38 <ReinH> *me
14:03:20 <ReinH> hexagoxel, tangentstorm: http://webcache.googleusercontent.com/search?q=cache:F8OIXRm5DFQJ:https://www.haskell.org/haskellwiki/GHC/GHCi&hl=en&gl=us&strip=1
14:03:24 <tangentstorm> wow that is slow. thanks though. :)
14:03:26 <tangentstorm> ah
14:04:34 <Zemyla> I could write symmetric difference for maps, because they have a mergeWith function.
14:05:28 <Zemyla> :t const $ const $ const Nothing
14:05:29 <lambdabot> b -> b1 -> b2 -> Maybe a
14:05:44 <Zemyla> :t mergeWithKey
14:05:44 <lambdabot>     Not in scope: ‚ÄòmergeWithKey‚Äô
14:05:45 <lambdabot>     Perhaps you meant one of these:
14:05:45 <lambdabot>       ‚ÄòIM.mergeWithKey‚Äô (imported from Data.IntMap),
14:06:13 <Zemyla> :t Data.Map.mergeWithKey (const $ const $ const Nothing) id id
14:06:14 <lambdabot> Ord k => M.Map k c -> M.Map k c -> M.Map k c
14:07:33 <tangentstorm> very cool. thanks, hexagoxel / ReinH !
14:08:04 <Denommus> hm
14:08:09 <Denommus> damn
14:08:41 <Zemyla> > Data.Map.mergeWithKey (const $ const $ const Nothing) id id (Data.Map.fromList [(2*k+1, 1) | k <- [0..8]]) (Data.Map.fromList [k*k | k <- [1..4]])
14:08:42 <lambdabot>  Not in scope: ‚ÄòData.Map.mergeWithKey‚ÄôNot in scope: ‚ÄòData.Map.fromList‚ÄôNot in...
14:09:06 <Denommus> in reactive-banana, can I have a behavior for a IO action?
14:09:12 <Zemyla> > Data.Map.Strict.mergeWithKey (const $ const $ const Nothing) id id (Data.Map.Strict.fromList [(2*k+1, 1) | k <- [0..8]]) (Data.Map.Strict.fromList [k*k | k <- [1..4]])
14:09:13 <lambdabot>  Not in scope: ‚ÄòData.Map.Strict.mergeWithKey‚ÄôNot in scope: ‚ÄòData.Map.Strict.f...
14:09:42 <Hijiri> Denommus: you can have a behavior for any value
14:09:53 <Hijiri> that can be constructed
14:10:01 <Denommus> Hijiri: and can I execute the IO action inside that behavior?
14:10:03 <Hijiri> maybe for ones that can't be too, but I don't know
14:10:08 <Hijiri> oh, I don't know about that one
14:10:23 <Denommus> reactimate only works over events
14:10:31 <Denommus> I think I'm being too far fetched in what I want
14:10:49 <Hijiri> I think there is a guts module for making behaviors by polling IO
14:10:56 <Hijiri> and other stuff for library writers
14:10:56 <Athas> Anyone here experienced with Data.Type.Natural?  I cannot figure out how to compare to Nats.  If I use %:==, I get back a value whose type I cannot figure out what to do with.
14:10:58 <Denommus> I wanted my interface itself to be a Behavior
14:11:08 <Zemyla> :t ap seq
14:11:08 <lambdabot> (a -> b) -> a -> b
14:11:31 <Thulsadum> Kinda subjective question: if you had to reduce your haskell books library to one book, which would it be?
14:11:32 <Denommus> a bit more context: I'm trying to create a single-page application in GHCJS
14:12:09 <Denommus> and I was expecting to do something like React, where the page is like a time-varying value
14:12:20 <Denommus> can that be achieved?
14:14:46 <sveit> after reading https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ and http://stackoverflow.com/questions/12286315/when-to-use-a-type-class-when-to-use-a-type deriding overuse of typeclasses, I have refactored my code to instead use a type containing the three functions I originally defined in my typeclass. Thing is, I would really like to be able to inline those functions, and with the typeclass I
14:14:46 <sveit> could do this; is it possible to do the same with the type?
14:15:29 <sveit> Specifically, I am wondering about the accuracy of this comment: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/#comment-1012
14:16:40 <c_wraith> sveit: they should be inlinable at approximately the same time - when the values to inline are known at compile time.
14:17:00 <Denommus> maybe I could use React itself, and only use blaze-html as means of passing the string to React
14:17:22 <c_wraith> sveit: some clever use of pragmas might be necessary, though
14:17:57 <sveit> c_wraith: that's a large part of my concern; it's clear where to put the {-# INLINE f #-} in the case of a typeclass
14:18:10 <sveit> not so much for instances of a type
14:18:24 <sveit> also, would you say that the advice in those articles is sound?
14:19:09 <c_wraith> sveit: telling a class to inline a function is only half the battle - you also need to tell it to inline the instance.  The former does nothing without the latter.
14:23:01 <sveit> c_wraith: sure, but still that seems simpler than doing something similar for an instance of a type
14:23:18 <c_wraith> sveit: in the end, it's pretty much the same.  With modern GHC, anyway.
14:25:38 <sveit> c_wraith: really? so suppose I have something like (oversimplified), newtype T a b = T (a -> b); t :: T Int Int; t = T f where f a b = a * b + sin b, how/where would I put the pragma to tell GHC to inline f?
14:26:38 <sveit> in case its important in my actual use case it's a "data", not a "newtype", since there are actually several functions
14:26:41 <shachaf> Inline f into what?
14:26:42 <c_wraith> sveit: in that case, just mark t as INLINEABLE.
14:27:18 <shachaf> I don't think you particularly need any pragma there by default.
14:27:19 <c_wraith> sveit: But it's more important to mark whatever you pass t into as INLINEABLE
14:27:51 <c_wraith> sveit: you might also need to fuss with argument counts, but I really feel like that's a GHC bug when it's true.
14:28:50 <SrPx> Is there any BVH parser in Haskell?
14:29:06 <SrPx> Or parser for a similar format with widely available animations
14:30:01 <sveit> c_wraith: what is the difference between marking something INLINEABLE and INLINE? also, will this work with a non-newtype?\
14:30:14 <sveit> shachaf: why would I not need a pragma?
14:31:22 <shachaf> Why would you need one? Is it the case that GHC isn't inlining it automatically, and also that it should be inlined?
14:31:35 <shachaf> Maybe I stepped in in the middle of a conversation here.
14:31:57 <shachaf> But I think "put INLINE on everything" is a regrettable trend.
14:32:20 <sveit> shachaf: to be honest I was taking "advice" from the source of Data.Vector
14:33:15 <johnw> put INLINE on everything is in fact a very bad idea
14:33:18 <sveit> and since I would like what I am writing to run quickly (numeric-related), i figured it was a good place to look
14:33:27 <johnw> I tripled the speed of our assembler at work by removing every INLINE pragma in our code
14:33:46 <sveit> johnw: but it should be beneficial for short functions, no?
14:33:53 <johnw> if that's true, let GHC decide
14:34:04 <johnw> even INLINEABLE can hurt performance
14:34:21 <johnw> so as with many optimization-related things, wait until you encounter a real problem, and make your change based on analysis of whether it actually helps
14:34:50 <platz> this reminds me of query hints in sql server.  in almost all cases trying to override the query optimizer with hints produces slower queries
14:35:20 <platz> but the optimizer has been tuned for many years
14:35:54 <johnw> one thing that I find really can help is SPECIALIZE, if you have Monad-generic functions that you mostly use in IO, for example
14:36:00 <glguy> If it's beneficial then GHC will do it on its own for the most part. Some libraries spray inline pragmas because they're doing something in particular where inlining is important for the code to be fast, like rule-driven fusion, or where it's important to know what instance something is using at the call site
14:37:04 <darkroom> this is gonna be an odd question but does anyone have a very low quality PNG like 100x100 pixels?
14:38:17 <Peaker> johnw, I doubled the speed of my parsec parser by adding INLINE pragmas to all definitions :P
14:41:23 <johnw> haha
14:41:33 <johnw> so, the rule is that there's no hard and fast rule
14:41:53 <johnw> trying it out and measuring is fine; doing it because other libraries do it, not so much
14:44:21 <sveit> thanks for all the quick help!
14:46:01 <sveit> i was wondering if someone had a second opinion on my other question, whether the articles https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ and http://stackoverflow.com/questions/12286315/when-to-use-a-type-class-when-to-use-a-type were "accurate" or at least widely accepted as patterns by others? (they are rather short, and basically make the point that certain kinds of typeclasses can and should
14:46:01 <sveit> be replaced by types)
14:51:18 <johnw> typeclasses are easy to overuse
14:53:07 <platz> my favorite answer: in general, you use a class when you want a different type for  each different behavior, and there's only one sane behavior choice for  each type.
14:53:42 <quchen> platz: A lot of people would also argue that a typeclass should also come with laws.
14:55:10 <platz> Sure, but I don't know the theory behind that so that it should hold for all usages
14:55:22 <johnw> I think most of the times I chose to use a typeclass, it was a mistake; but they're fantastic if you're writing a library and you want to codify some algebraic structure, because it allows users to code their algorithms to that structure without thinking about (or being able to think about) the implementation
14:56:16 <johnw> (s)
14:56:39 <platz> record-of-functions is more powerful/flexible, but more 'opaque' as a design choice because i think it signals less
14:57:11 <platz> http://blog.higher-order.com/blog/2014/12/21/maximally-powerful/
14:57:16 <Peaker> I use type-classes to make the API vocabulary smaller
14:57:28 <wyager> Also, if you implement it in terms of a typeclass, the render function has access to w's fields, whereas the data-with-function approach doesn't provide access to w's fields.
14:57:32 <Peaker> and when I think there must be laws, though I've not take the time to formulate them :)
14:57:45 <jfischoff> there are other issues with record-of-functions. You have to tread the record manaully and users are free to muck with the record in incorrect ways
14:58:33 <Peaker> I have a bunch of concrete types, and I want to avoid having: updateFoo, updateBar, updateBaz, just have a type-class with "update"
14:58:47 <Peaker> (the meaning of "update" is basically the same, traversal of whatever is inside to update it)
14:58:51 <jfischoff> seems perfectly reasonable to me
14:59:00 <jfischoff> ad-hoc polymorphism
14:59:14 <Peaker> I used to avoid classes and have large APIs
14:59:21 <Peaker> but then I saw in others' code how much nicer small APIs were
14:59:43 <Peaker> Most of the changes in my coding style/concepts come from envying others' code :)
14:59:59 <jfischoff> The problem I had with type classes when I started using Haskell was I did not understand how they worked
15:00:23 <Iceland_jack> Peaker: Imitation is the sincerest form of flattery :)
15:00:24 <jfischoff> I would design a type class and then make instances that made no sense/lead to overlap/ etc
15:00:52 <Peaker> The problem I have with type-classes is that there are often many overlapping ways to achieve the same thing
15:02:18 <kuribas> Type classes aren't really necessary, are they?  You could always pass methods to the functions.
15:02:22 <platz> thats the 'there should only one sane behavior choice for  each type' part
15:02:49 <platz> otherwise trouble
15:03:17 <Peaker> platz, I mean there are multiple ways to formulate it into a class. If you have a signature: Foo -> Bar Baz ; the class could possibly use 1 of 4 type tokens appearing here as the discriminator, and sometimes it's not clear which is the right one to use
15:03:47 <platz> Peaker: ah, I hadn't considered that part of it - interesting
15:03:51 <Peaker> Actually more, all type subexprs are possible
15:04:02 <Peaker> I had: liftVar :: TypeVar Type -> Type
15:04:35 <Peaker> should this be generalized to have: "TypeVar Type" be a member of the class, with a type-family projecting "Type" from it?  Or should "Type" be the member? etc?
15:07:56 <seanparsons> I was pondering how partial application could (if it doesn't already) make possible a potentially hugely beneficial optimisation: https://gist.github.com/seanparsons/2c8a7ecd3b84e3019bd3
15:08:02 <seanparsons> Anyone got any thoughts?
15:09:19 <wyager> seanparsons: Doesn't it do this already?
15:09:44 <wyager> Pretty sure if you partially apply a function and use it a bunch of times, the partially applied part gets maximally evaluated
15:10:00 <wyager> the first time around, and then that result gets re-used
15:10:55 <seanparsons> wyager: I don't know, I wondered if there was an issue with it being not so much a memory leak but more like it would hold onto the memory in a way which would be hard to diagnose.
15:11:11 <wyager> Yeah, Haskell definitely does that sometimes :)
15:13:18 <seanparsons> I feel like I should actually investigate it with a benchmark and see what I can see.
15:13:45 <jfischoff> you could also dump the STG
15:13:58 <jfischoff> hard to read but will answer the question
15:14:07 <seanparsons> That's also a good call.
15:14:34 <jfischoff> With something this simple you might be able to make out what is happening ‚Ä¶ worth a shot
15:22:41 <m1dnight_> Could somebody have a look at my (small) function? Im unexperienced in haskell but I think this can be done in a more idiomatic way? http://lpaste.net/118090
15:22:49 <m1dnight_> The case in particular is bugging me
15:23:39 <m1dnight_> However, because of the errors im displaying it might be impossible, so that's why I ask
15:24:14 <wyager> Personally, here's what I'd do:
15:24:21 <wyager> 1. Replace "let" with "where"
15:25:06 <wyager> 2. do something like `case (t1Kind, t2Kind) of; (ArrowKind k1 k2, Star) -> ...; _ -> ;`
15:25:17 <wyager> that is, replace the case and the if with a single case expression
15:25:18 <Iceland_jack> You can also use guards with cases
15:25:40 <jfischoff> m1dnight_: ah crap I edited it, I meant to annotate it
15:25:51 <jfischoff> I didn‚Äôt know I could do that
15:26:04 <m1dnight_> Haha, neither did I. But I get your point
15:26:25 <m1dnight_> oh now I see
15:26:31 <m1dnight_> also inline the calls, that's actually obvious
15:26:58 <jfischoff> I added Iceland_jack‚Äôs suggestion
15:27:10 <jfischoff> err ‚Ä¶ let fix that
15:27:12 <m1dnight_> aha, the guards
15:27:37 <jfischoff> http://lpaste.net/118090#a118092
15:27:43 <arjanb> you also could use the view patterns extension
15:27:56 <m1dnight_> Let me google that, hold on
15:28:38 <Iceland_jack>  
15:28:38 <Iceland_jack> m1dnight_:
15:28:38 <Iceland_jack>     calcKind (OpApp (calcKind -> ArrowKind k1 k2) (calcKind -> Star)) = k2
15:28:41 <Iceland_jack> is another way
15:28:41 <wyager> m1dnight_: Again, replace the case and if with a single case expression on a tuple
15:29:28 <m1dnight_> Iceland_jack: but then I don't get the clear error messages, which is something I'd like very much
15:29:32 <m1dnight_> I had thought of that though
15:29:56 <m1dnight_> wyager: that might even be shorter yes
15:30:01 <m1dnight_> i'm going to try em all and see what I like :D
15:30:07 <m1dnight_> i like the feedback, thanks a lot guys :)
15:30:42 <wyager> http://lpaste.net/118094
15:30:47 <Iceland_jack> m1dnight_: (I'm guessing the first "case calcKind t2 of" should be t1?)
15:31:19 <m1dnight_> ah yes, that is correct Iceland_jack
15:31:27 <Iceland_jack> If it weren't recursive you'd 100% use PatternSynonyms:
15:31:28 <Iceland_jack>     calcKind (OpApp (k1 :-> k2) Star) = k2
15:31:28 <Iceland_jack>     calcKind _                        = ...
15:31:28 <Iceland_jack>     
15:31:31 * hackagebot purescript 0.6.3 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.3 (PhilFreeman)
15:33:40 <Iceland_jack> (something like that)
15:43:37 <Zemyla> :t Data.Map.foldlWithKey'
15:43:38 <lambdabot> (a -> k -> b -> a) -> a -> M.Map k b -> a
15:46:46 <Denommus> luite: ping
15:59:15 <xpilot> hello
15:59:18 <Zemyla> xpilot: Wait, did you ever play XPilot?
15:59:24 <xpilot> of course!
15:59:37 <xpilot> I was actually just playing earlier today
15:59:42 <xpilot> by myself :(
15:59:59 <Zemyla> Hell yes. I loved that game so much that I was one of the developers back in the day.
16:00:09 <xpilot> haha wow
16:00:10 <Zemyla> :t ap
16:00:10 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:00:28 <xpilot> how far back in the day?
16:00:42 <shachaf> But did you love it so much that you named yourself after it?
16:00:43 <Zemyla> I think through about 2006.
16:00:54 <dfeuer> I seem vaguely to remember having spent some time playing that.
16:00:58 <xpilot> I started playing around 2005
16:01:21 <mpickering> @hoogle (b -> Maybe (a,b)) -> b -> ([a], b)
16:01:24 <lambdabot> No results found
16:01:25 <xpilot> that was around the time ng came out
16:01:37 <mpickering> ^ that function must exist?
16:01:45 <xpilot> mpickering: you can use hoogle from the command line :)
16:02:29 <xpilot> mpickering do you mean b -> (Either a b) ?
16:02:37 <monochrom> it can certainly be written, but I don't think any common library has a reason to have it.
16:03:10 <prophile> mpickering: looks a lot like unfoldr
16:03:20 <Iceland_jack> :t unfoldr
16:03:21 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
16:03:25 <monochrom> in the same sense that there is no reason any library should have "every function writable in 140 bytes"
16:03:27 <Zemyla> xpilot: Yeah, I remember NG. I found the code base hard to understand.
16:03:33 <prophile> you might find it as a special case of one of the functions in the recursion-schemes library
16:03:59 <Iceland_jack> > unfoldr (\b -> do guard (b < 10); return (show b, b + 1)) 0
16:04:01 <lambdabot>  ["0","1","2","3","4","5","6","7","8","9"]
16:04:27 <xpilot> Zemyla: I started programming around then 2006, my hobby was to make xpilot clones
16:04:30 <prophile> it looks a bit like gapo
16:04:55 <Zemyla> xpilot: The biggest thing I remember doing was adding a lag meter to the client.
16:05:14 <prophile> *gana
16:05:19 <xpilot> Zemyla: I even made compatible java client that I actually used because of a bug (on windows, I think)
16:06:07 <xpilot> Zemyla: I've been thinking of making a haskell version now that I use haskell, but I haven't found any physics engines that support wrapping
16:06:22 <Zemyla> I wish there were an XPilot client for the Android.
16:06:42 <Zemyla> xpilot: Then write your own. That's what the XPilot team did.
16:06:55 <xpilot> Zemyla: they came out with an iphone one, but personally I don't think it's great without a keyboard and mouse
16:07:46 <xpilot> Zemyla: but writing physics engines is pretty hard :( I tried for a while to write a decent one but gave up once I found Box2D
16:09:20 <Camellia23>   http://j.mp/Rh9YfS
16:10:33 <xpilot> Zemyla: what kinds of maps did you play?
16:10:52 <Zemyla> New Dark Hell and Blood's Music.
16:11:23 <xpilot> Zemyla: I was just practicing on Blood's Music :)
16:11:44 <xpilot> Zemyla: ever heard of Nuke Dark Hell?
16:13:40 <xpilot> Zemyla: it's too bad everyone quit :( by 2010 the servers were almost always empty
16:14:00 <Pamelloes> Is there a way to create a list of datatype constructors?
16:14:08 <shachaf> What would that be?
16:15:17 <xpilot> ah now I remember why I was here: how do I tell cabal to build my program with -prof so I can profile it?
16:15:24 <dmj`> :t [Just, Just]
16:15:24 <lambdabot> [a -> Maybe a]
16:15:33 <joneshf-laptop> does cabal support watching directories for changes and recompiling, or do I need to hookup some linux stuff?
16:15:35 <geekosaur> --enable-{executable,library}-profiling ?
16:15:38 <Iceland_jack> Pamelloes: http://chrisdone.com/posts/data-typeable check this out
16:15:58 <Iceland_jack> Pamelloes: Look at "Use-case 2: Inspecting a data type" that gets exactly what you ask
16:16:04 <Iceland_jack> Œª> :t dataTypeConstrs
16:16:04 <Iceland_jack> dataTypeConstrs :: DataType -> [Constr]
16:16:04 <Iceland_jack> Œª> dataTypeConstrs (dataTypeOf (Nothing :: Maybe ()))
16:16:05 <Iceland_jack> [Nothing,Just]
16:16:14 <Pamelloes> Thanks! I'll look into it
16:17:18 <xpilot> geekosaur: already have those enabled in my cabal.config
16:18:16 <geekosaur> joneshf-laptop, that doesn't strike me as something that should be built into cabal, rather there should be some framework which can watch for changes and invoke some toolchain in response
16:23:01 <hexagoxel_> joneshf-laptop: i think you need linux stuff (such as some inotify stuff). cabal does partial recompilation, but not actual triggered builds.
16:23:54 <joneshf-laptop> geekosaur, hexagoxel_, thanks
16:24:27 <Haskellfant> while inotifywait -e close_write *.hs; do cabal build; done
16:24:30 <Haskellfant> ore something like that
16:26:09 <Haskellfant> s/ore/or/
16:27:07 <mpickering> joneshf-laptop: Maybe checkout ghcid?
16:32:33 <ReinH> joneshf-laptop: things like https://hackage.haskell.org/package/twitch exist as well
16:33:05 <joneshf-laptop> Haskellfant, mpickering ReinH also thanks :)
16:38:01 <Zemyla> :t min
16:38:02 <lambdabot> Ord a => a -> a -> a
16:38:33 <lachenmayer> What's the best way to resolve cabal version conflicts? Is there any way I can bend dependencies in place, like editing a dependency file?
16:39:24 <ReinH> lachenmayer: Your project's cabal file?
16:40:18 <e11> hey heyy
16:40:21 <lachenmayer> ReinH: I'm trying to include a package which has conflicting dependency constraints as another required package
16:40:40 <lachenmayer> I just found out about `cabal unpack`, so I guess I'll try that
16:41:06 <e11> question for you gents: 'liftIO not in scope' <-- where is liftIO, and generally, how can I figure out what package(module?) any given function is in? for future reference
16:41:21 <Bynbo7> @hoogle liftIO
16:41:22 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
16:41:22 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
16:41:22 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
16:41:30 <Axman6> hmm
16:41:40 <ReinH> e11: Control.Monad.IO.Class
16:41:44 <e11> e.g. import Control.Monad.IO.Class ?
16:41:48 <e11> you guys rock!! thank you
16:41:49 <ReinH> yes
16:42:00 <ReinH> and hoogle/hayoo are good answers to your second question
16:42:10 <Axman6> surely it should be exported by any module that also implements MonadIO no?
16:42:19 <ReinH> Axman6: often not
16:42:22 <e11> hoogle didnt list Control.Monad.IO.Class .. interestingly
16:42:43 <e11> @hoogle <function name> works in ghci eh, sweeet
16:42:43 <lambdabot> Parse error:
16:42:43 <lambdabot>   <function name> works in ghci eh, sweeet
16:42:43 <lambdabot>                                   ^
16:42:44 <ReinH> e11: it does for me
16:43:08 <ReinH> e11: @hoogle works with lambdabot
16:43:29 <e11> both those things are prefixed with network CGI
16:43:29 <ReinH> However, you can get it to work with ghci http://webcache.googleusercontent.com/search?q=cache:TgYTMqaEBwUJ:https://www.haskell.org/haskellwiki/Hoogle&hl=en&gl=us&strip=1
16:43:41 <ReinH> @hoogle liftIO
16:43:41 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
16:43:41 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
16:43:41 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
16:43:43 <ReinH> There are three things
16:44:06 <ReinH> and at https://www.haskell.org/hoogle/?hoogle=liftIO it lists both modules for the first entry
16:44:22 <ReinH> it groups the entries by type
16:45:31 <e11> what would you call Control.Monad.IO.Class? Is that a module, library, or what?
16:45:53 <Axman6> module
16:45:56 <ReinH> module
16:46:00 <e11> ahh ok
16:46:04 <Axman6> @hoogle Control.Monad.IO.Class
16:46:04 <lambdabot> Control.Monad.IO.Class module Control.Monad.IO.Class
16:46:04 <lambdabot> package ClassLaws
16:46:04 <lambdabot> package ClassyPrelude
16:46:17 <Axman6> bleh, which library is it? mtl?
16:46:24 <Axman6> /transformers?
16:46:34 <e11> thanks ReinH and Ax!
16:46:47 <ReinH> the transformers
16:46:52 <ReinH> woops
16:47:03 <Axman6> monads in disguise
16:48:55 <Pamelloes> What does "forall a" mean?
16:49:30 <shachaf> It means "for all a".
16:49:36 <adu> Pamelloes: do you know about math?
16:49:56 <Pamelloes> Through MV Calc, why?
16:50:40 <adu> Pamelloes: http://en.wikibooks.org/wiki/Mathematical_Proof/Introduction/Notation#For_All
16:51:41 <Pamelloes> Oh. I get it.
16:52:03 <adu> Pamelloes: but in Haskell, it's more of a variable binding, as in "a is what we're calling the variable that can be anything"
16:52:42 <adu> but it has almost the same meaning in math and Haskell
16:52:48 <Pamelloes> Why would you need "forall a" instead of "a"
16:52:52 <EvanR> a > 0
16:52:56 <EvanR> a is a free variable
16:53:09 <EvanR> forall a . a > 0, this is now a false statement
16:53:13 <adu> Pamelloes: mostly for types
16:53:58 <Pamelloes> EvanR: So is the second one saying "for every a greater than 0" or am I missing something?
16:53:59 <EvanR> a by itself is ambiguous
16:54:18 <adu> Pamelloes: for example, the identity function
16:54:23 <adu> id x = x
16:54:38 <adu> id :: forall a . a -> a
16:55:05 <Pamelloes> So why is it
16:55:14 <Pamelloes> fforall a .a -> a and not just a -> a?
16:55:49 <adu> Pamelloes: without the forall, we don't know anything about a, it should be String, or Int, or Float
16:56:26 <pavonia> Aren't these two equivalent?
16:57:12 <pavonia> :t (undefined :: forall a . a -> a) == (undefined :: a -> a)
16:57:13 <lambdabot>     No instance for (Eq (a0 -> a0)) arising from a use of ‚Äò==‚Äô
16:57:13 <lambdabot>     In the expression:
16:57:13 <lambdabot>       (undefined :: forall a. a -> a) == (undefined :: a -> a)
16:57:37 <EvanR> a -> a could mean that a is a specific type that is yet unknown, but forall a . a -> a explicitly binds a so that we know we can substitute whatever a we want
16:57:51 <sebastianrkg> I'm wondering if anyone has a preference for a Haskell Amazon S3 wrapper? I've identified hS3, was, and amazon-s3 as potential options.
16:57:57 <sebastianrkg> *aws
16:58:31 <adu> Pamelloes: I think (a -> a) implies (forall a . a -> a) in that specific example, but I think there are other examples that you need "forall" for
16:58:48 <Pamelloes> Ok.
16:58:50 <benzrf> ok guys lissen up
16:58:55 <benzrf> the type "a -> a" means /nothing/
16:59:02 <benzrf> just like the expression "x + y" means nothing
16:59:16 <benzrf> it just so happens that in haskell, "a -> a" is silently expanded to "forall a. a -> a"
16:59:20 <benzrf> that's all!
16:59:53 <benzrf> well to be precise, the foralls are added at the beginning of a particular type
16:59:54 <benzrf> so,
16:59:59 <adu> isn't "forall" a GHC extension?
17:00:14 <benzrf> (a -> a) -> a -- this is "forall a. (a -> a) -> a", not "(forall a. a -> a) -> forall a. a"
17:00:23 <benzrf> adu: yes, you cannot use it by default
17:00:29 <benzrf> adu: but theory-wise
17:00:43 <benzrf> adu: coq, for example, does not silently quantify free type variables
17:00:45 <lpaste> e11 pasted ‚Äúwhy is indentation wrong‚Äù at http://lpaste.net/118098
17:01:24 <e11> question about this paste: http://lpaste.net/118098
17:01:24 <adu> who is e11?
17:01:32 <EvanR> you cant reliably alpha convert free variables without a context, i think
17:01:36 * hackagebot matrices 0.3.0 - native matrix based on vector  http://hackage.haskell.org/package/matrices-0.3.0 (kaizhang)
17:01:38 <geekosaur> looks like you're trying to compile stuff intended for ghci (interactive)
17:01:39 <adu> e11: show needs to be indented
17:01:58 <e11> why should show be indented?
17:02:10 <pavonia> e11: You can't state expressions on top-level like that
17:02:11 <adu> e11: actually, what do you mean by show there?
17:02:13 <geekosaur> lines 1-4 are ok for compilation. the rest... expects to be used in ghci and cannot be used that way in a compiled unit
17:02:21 <e11> ohhh
17:02:25 <adu> e11: show has to be in a function, and it's not
17:02:35 <adu> e11: did you mean to add a main function?
17:02:46 <geekosaur> (to compile: drop the "let" on lines 6 and 7 and define a function containing the "show" or just make line 10 go away)
17:02:52 <e11> there is no global level expression evaluation? everything has to be wrapped in 'main = '?
17:02:58 <ski> EvanR : you'd have to convert the context as well, yes
17:03:08 <e11> ahhh im starting to get it i think
17:03:16 <adu> e11: right, the only thing that can be at the top level is declarations
17:03:22 <geekosaur> e11, in a compiled program, you have an entry point called "main". just as in C or C++ or Java
17:03:35 <e11> aha. duh. and wonderful, makes sense
17:04:06 <e11> and where is 'let' appropriate? only within ghci?
17:04:14 <ski> benzrf : it just so happens that `foo :: a -> a' is expanded to `foo :: forall a. a -> a' (`bar :: (a -> a) -> Bool' isn't expanded to `bar :: (forall a. a -> a) -> Bool')
17:04:25 <adu> e11: let works like that within "do", which is usually what people use for main
17:04:35 <Iceland_jack> e11: No, you can write:
17:04:36 <Iceland_jack>     main = let message = "hello, world!"
17:04:36 <Iceland_jack>             in putStrLn message
17:04:38 <geekosaur> it's also used within do blocks, or in expression form (let <bindings> in <expr>) can be used inside any expression
17:04:50 <Iceland_jack> e11: or
17:04:50 <Iceland_jack>     main = do
17:04:50 <Iceland_jack>       let message = "hello, world!"
17:04:50 <Iceland_jack>       putStrLn message
17:05:04 <geekosaur> but top level of a compilation unit is bindings, class / instance declarations, etc., not expressions
17:05:07 <Iceland_jack> > let x = 6 in x + x
17:05:08 <e11> what is special about the do block, how does it change expression evaluation or program context
17:05:09 <lambdabot>  12
17:05:28 <adu> e11: if you're used to experimenting with ghci, then just think of all of those lines within a "do" and it makes sense
17:05:31 <geekosaur> a do block is syntactic sugar for expressions involving >>= and >>
17:05:32 <ski> you can use `let' in expressions, in list comprehension qualifiers, and in `do'-commands. `let' in the interactor is similar to the latter
17:05:49 <e11> ok..
17:05:55 <geekosaur> it turns into an expression, and as such cannot be used at top level in a compiled file
17:05:59 <e11> what are expressions involving >>= and >> ?
17:06:09 <benzrf> e11: normal ones
17:06:12 <Hijiri> what are expressions involving +?
17:06:14 <benzrf> e11: do you mean what do those operators do?
17:06:19 <e11> yes, sorry
17:06:28 <adu> e11: >> and >>= are the expressions that "do" blocks expand to
17:06:30 <Iceland_jack> ..not very helpful
17:06:35 <geekosaur> I mentioned those specifically because "do" blocks turn into uses of those operators
17:06:53 <geekosaur> @undo do a; b <- c; d b
17:06:53 <lambdabot> a >> c >>= \ b -> d b
17:07:03 <e11> ok, "do" is syntactic sugar around >> and >>= operators.. interesting..
17:07:12 <e11> are "do" blocks also related to IO? arent they used for IO?
17:07:32 <adu> e11: yes, "do" blocks work with all Monads, and IO is a Monad
17:07:33 <sebastianrkg> they are related to Monads, of which IO is an instance
17:07:35 <geekosaur> since "do" is often used with IO, it makes things in do blocks look more like procedural languages although they're really just expressions like any other
17:08:05 <e11> is this stuff in the do block somehow specially segregated as 'impure' from the rest of the program?
17:08:14 <adu> e11: no, it's still pure
17:08:20 <Hijiri> no, it just gets desugared to uses of >>= and >>
17:08:31 <Hijiri> it would be as if you used the equivalent expression
17:08:41 <Axman6> > do { x <- [1..5]; y <- [10,20..50]; return (x,y) }
17:08:42 <lambdabot>  [(1,10),(1,20),(1,30),(1,40),(1,50),(2,10),(2,20),(2,30),(2,40),(2,50),(3,10...
17:08:46 <adu> e11: but you can do things that from the outside world appear to be impure
17:08:54 <e11> can anyone give me an example of >>= or >> being used and what they do?
17:08:59 <geekosaur> also, as for that error complaining about indentation: sadly, ghc is not very good about explaining some kinds of errors. it's much better with type errors, but syntax errors are generally reported like that and you get to guess what the error is >.>
17:09:02 <EvanR> > putStrLn x
17:09:03 <lambdabot>  Couldn't match type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
17:09:03 <lambdabot>                with ‚Äò[GHC.Types.Char]‚Äô
17:09:03 <lambdabot>  Expected type: GHC.Base.String
17:09:24 <bshelden> > (Just 5) >>= (\x -> x + 1)
17:09:25 <lambdabot>  No instance for (GHC.Show.Show b0)
17:09:25 <lambdabot>    arising from a use of ‚ÄòM541107726840190784013080.show_M5411077268401907840...
17:09:25 <lambdabot>  The type variable ‚Äòb0‚Äô is ambiguous
17:09:25 <adu> ,t putStrLn
17:09:33 <adu> :t putStrLn
17:09:33 <lambdabot> String -> IO ()
17:09:33 <e11> thanks geekosaur, yeah that syntax thing could use some work
17:09:48 <bshelden> O.o  It can't show that?
17:09:55 <adu> :t (putStrLn "hello")
17:09:56 <lambdabot> IO ()
17:10:04 <Hijiri> bshelden: no num instance specified
17:10:14 <Hijiri> > Just 5 >>= (\x -> x + 1) :: Maybe Int
17:10:15 <lambdabot>  No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
17:10:15 <lambdabot>    arising from the literal ‚Äò5‚Äô
17:10:19 <Hijiri> w-what
17:10:21 <Iceland_jack> Just 5 >>= (\x -> return (x + 1))
17:10:22 <EvanR> oO
17:10:26 <Iceland_jack> > Just 5 >>= (\x -> return (x + 1))
17:10:27 <Hijiri> oh
17:10:28 <lambdabot>  Just 6
17:10:28 <geekosaur> that looks right to me
17:10:30 <adu> e11: so are you familiar with other languages?
17:10:35 <Hijiri> I just noticed that there was no Just :P
17:10:35 <bshelden> Iceland_jack: Derp.  Thank you
17:10:37 <geekosaur> (the error that is)
17:10:48 <e11> im familiar with python/javascript and some c/assembly
17:11:00 <adu> e11: are you familiar with bash?
17:11:01 <bshelden> e11: See Iceland_jack's correction to mine.  >>= use.
17:11:03 <e11> yeah
17:11:05 <EvanR> four vastly different things ;0
17:11:11 <bshelden> There's no real magic here.  It's just an operator.
17:11:17 <adu> e11: ok, >>= is like a bash pipe, and >> is like C ";"
17:11:28 <e11> ok
17:12:06 <e11> pipe something to a new function and terminate a statement, then
17:12:14 <e11> >>= and >>
17:12:26 <EvanR> more informative are the types of the operators
17:12:44 <EvanR> :t (>>)
17:12:44 <lambdabot> Monad m => m a -> m b -> m b
17:12:48 <adu> :t (>>=)
17:12:49 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:14:00 <e11> ok. I can't in good conscience ask you guys what monads are when I should 'read the docs' -- but is there a six second definition of monads out there?
17:14:10 <danilo2> Hello! :) Is there in Haskell any generic mechanism to create a parser out of a datatype which will parse one of its constructors?
17:14:21 <e11> :) sorry i asked anyway
17:14:22 <Axman6> @src Monad
17:14:22 <lambdabot> class  Monad m  where
17:14:22 <lambdabot>     (>>=)  :: forall a b. m a -> (a -> m b) -> m b
17:14:22 <lambdabot>     (>>)   :: forall a b. m a -> m b -> m b
17:14:22 <lambdabot>     return :: a -> m a
17:14:22 <lambdabot>     fail   :: String -> m a
17:14:27 <adu> danilo2: read/show?
17:14:27 <EvanR> plus some laws
17:14:29 <Axman6> there, the definition of Monad
17:14:34 <geekosaur> danilo2, you could say that's what deriving (Read) does
17:14:53 <e11> ok that works for now
17:14:55 <adu> e11: don't ask what a monad is, use Haskell for a year, then if you still have to ask, then ask
17:15:06 <e11> yeah i thought it was a bit amibitious
17:15:12 <EvanR> Axman6: interesting return and fail dont have foralls...
17:15:22 <danilo2> adu, geekosaur: something like Read but wiser. By parser I mean somethin in a parser monad - whatever this parser is - parsec / trifecta - anything that has instances of CharParsing (from parsers) or whatever
17:15:29 <bshelden> That works pretty much forever, e11.  Monads are that typeclass (and a couple rules about how to implement them).  Just so happens that many types fit.
17:15:38 <geekosaur> Monads are a bit overrated by most non-Haskellers; they're pretty much defined by two operations (bind and return, in Haskell) and capture a common abstraction that people tend to miss like missing the forest for the trees
17:15:42 <adu> e11: just think of a Monad as https://en.wikipedia.org/wiki/MacGuffin
17:15:47 <khyperia> EvanR, @src pulls from random hardcoded source, not ghc
17:15:48 <ski> EvanR : .. they should have, as much as the other methods
17:15:59 <EvanR> e11: its a type class, check out some instances of that class to see what the ydo
17:16:16 <Axman6> e11: have you programmed with any other languages before?
17:16:37 <e11> yeah I program with python and javascript for example
17:17:26 <khyperia> I explained monads earlier today, heh, I'm at a conference right now and there was a haskell gathering, explained it to a few newcomers (or at least attempted to)
17:18:13 <danilo2> adu, geekosaur: having such "deriving (Parser)" functionality we can get a parser, that can just output interesting errors, like "unexpected character ..., expecting letter" etc. Read just fails without any hint
17:18:17 <ski> ooc, what kind of conference ?
17:18:22 <bshelden> I still think monads steal the spotlight.  Applicatives are the cool concepts.
17:18:44 <EvanR> no Category is the cool one
17:19:06 <adu> danilo2: you don't need parsec tho, just "read"
17:19:06 <khyperia> ski, general programming conference, http://www.codemash.org/ there's a few Elixir/etc sessions, but there's a huge C#/.net crowd
17:19:18 <EvanR> typeclass pokedex
17:19:30 <danilo2> adu: How do you know I do not need it? :D
17:19:41 <geekosaur> danilo2, the problem with that is that you'd have to pick a parser, or build extensible knowledge of different parsers into the compiler
17:19:51 <e11> thanks for the MacGuffin reference, whoever said it, its kinda meta or zen but its a cool metaphor to start to grasp this concept
17:20:17 <bshelden> Categiry is indeed a cool concept.  I'm still a bit unclear on how it renders in haskell, but currently neck deep studying something else.
17:20:31 <geekosaur> (note, there is actually work on that second one, but it's not ready yet. in theory a parser with ghc 7.12 (or whenever it lands) support could ship with a plugin that can derive parsers for data types
17:20:35 <bshelden> Category is even cooler *sighs*
17:20:37 <adu> danilo2: because the description of your problem is the definition of "read"
17:20:39 <e11> what are you studying bshelden?
17:20:52 <danilo2> geekosaur: Hmm, I was thinking if is it possible to create this functionality using haskell's Generics - if we learn haskell to create small parsers out of any possible datatype, providing informations about Ints, Chars etc, maybe we can genralize it further this way?
17:20:53 <bshelden> e11: Hindley-Milner Inference.
17:21:03 <e11> ah, thats a type system, yeah?
17:21:03 <bshelden> I'm trying to write myself a type inferencer in an effort to understand them better.
17:21:14 <geekosaur> generics can't help you at this level
17:21:27 <adu> e11: I believe the first person to use the term "McGuffin" in that sense was Alfred Hitchcock
17:21:29 <geekosaur> the part they might help you with is the part that's already solved (Read)
17:21:34 <danilo2> adu: no, I was talking about parser in the meaning of a monadic parser combinator. Sorry for being unclear.
17:21:40 <e11> ahh Hitchcock!
17:21:50 <bshelden> The actual use case is implementing a haskell-lite language with a type system up to higher kinds.  Probably beyond me.  I should learn quite a bit on the road.
17:22:16 <Axman6> e11: this might help you get an intuition for how simple the idea of a monad is: http://codon.com/refactoring-ruby-with-monads (it's not a particularly accutate definition, but it shows how generic the idea is)
17:22:19 <e11> yeah, wow, thats quite meta. Is normal procedural/imperative programming (fuzzy on the difference) become boring to you guys, because you just grok it all?
17:22:23 <adu> e11: what's in the case? is it diamonds? is it a soul? is it a human heart? it's a Monad!
17:22:40 <e11> could a Monad be all those things?
17:22:43 <bshelden> imperative programming is a fact of life.  Mutation?  I find that too difficult to cope with. (not kidding)
17:22:53 <EvanR> normal imperative programming is about to make me quit my career in software
17:22:55 <e11> haha, I hear you
17:23:06 <e11> (bshelden I mean)
17:23:11 <bshelden> I fled to pure functional style because things stay so much more predictable
17:23:17 <e11> interesting
17:23:32 <e11> easier to reason about? man our web application at work has variables mutation all over the place, its nuts, but still ok
17:23:35 <adu> bshelden: I tend to use functional style in procedural languages too
17:23:37 <bshelden> The often used trope is "pure functional code is easier to reason about".  Well, it's true
17:23:56 <EvanR> e11: youre lucky, a web app framework usually reduces vastly the amount of that kind of stuff you *have* to deal with
17:24:09 <bshelden> When I look at a function.  I don't have to care what setting the missile launcher is set to.  I only care what came in, and what I return.
17:24:24 <e11> yeah, im definitely happy we didnt hand-roll a complete app
17:24:33 * hodapp . o O ( why is missile launching the standard example of IO in Haskell-land? )
17:24:39 <e11> so do you guys get paid to write haskell?
17:24:53 <bshelden> hodapp: implication of destruction when allowing uncontrolled effects
17:24:58 <adu> e11: no, I get paid to write Python
17:25:01 <bshelden> I write Scala professionally
17:25:05 <hodapp> Hello wo*BOOOOOOOM*
17:25:13 <e11> *hi five* me too :)
17:25:25 <EvanR> hodapp: to hyperbolically demonstrate the critical nature of side effects because unsafeSendEmail doesnt hit close enough to home
17:25:27 <e11> does scala scratch the itch for functional bshelden?
17:25:35 <ski> khyperia : ok
17:25:37 <hodapp> e11: I get paid to solve problems. Sometimes I find ways that Haskell makes that easier.
17:25:41 * hodapp <- EE
17:25:47 <bshelden> Well, it's the best I've seen for JVM code.
17:25:50 <e11> ah
17:26:01 <hodapp> Scala is... meh.
17:26:05 <bshelden> Though I've heard a ghost of a whisper that someone's working on a PureScript compiler to JVM code.  Will keep an eye on that.
17:26:08 <bshelden> hodapp: Agreed
17:26:25 <e11> you prefer Haskell over Scala, guys?
17:26:28 <bshelden> Yes
17:26:29 <hodapp> yeah.
17:26:31 <EvanR> yes
17:26:32 <Hijiri> wasn't there a haskell-esque JVM languae?
17:26:35 <Hijiri> sounded like fridge
17:26:36 <adu> I've never used Scala
17:26:38 <EvanR> Frege
17:26:39 <bshelden> frege or something close to that.
17:26:42 <hodapp> I just found Scala to be very messy and halfway-there.
17:26:43 <ski> bshelden : hm .. ooc, did you see the Schwartzbach intro to HM yet ?
17:26:52 <adu> I prefer Haskell over everything except Rust
17:26:54 <bshelden> ski: I have not.
17:27:18 <bshelden> I've still yet to find my "perfect language".  But haskell is a language I'm comfortable working with.
17:27:21 <vanila> jhaha
17:27:30 <vanila> frege is one of the most important logicians in history
17:27:33 <vanila> "sounded like fridge"
17:27:43 <hodapp> vanila: your name just sounds like vanilla :|
17:28:11 <bshelden> e11: Of course asking that question here had a somewhat predictable response.  I suspect you'd get a similar answer the other way over in #scala.
17:28:25 <EvanR> Frege and languages like it are interested because they take the liberty of refactoring the haskell standard library and extensions
17:28:35 <EvanR> like "if haskell could be redesigned today"
17:28:45 <bshelden> Frege and PureScript both have my attention for reasons like that
17:29:06 * bshelden coughs in the general direction of all the partial functions in prelude
17:29:17 <ski> bshelden : "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> -- it's quite basic, so perhaps not what you're looking for. i usually suggest it to people new to type systems
17:29:57 <bshelden> ski: On the contrary, that looks like a better place to start for me before I head back into HM
17:29:57 <EvanR> though none of the are ghc so...
17:30:25 <ski> bshelden : also, TaPL !
17:31:02 <hodapp> I need to read that book.
17:31:14 <hodapp> but HoTT will ship soon and I need to read that too.
17:31:21 * bshelden fails at book abbreviations
17:32:43 <ski> @where TaPL
17:32:43 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
17:32:44 <hodapp> bshelden: Homotopy Type Theory
17:32:59 <ski> @where HoTT
17:32:59 <lambdabot> http://homotopytypetheory.org/book/
17:33:02 <hodapp> bshelden: TaPL is the same author as Software Foundations which I'm quite a fan of
17:33:08 <bshelden> phew
17:33:11 <hodapp> whoa, I just found someone in #haskell who hasn't heard of HoTT!
17:33:15 * hodapp does an obscene victory dance
17:33:15 <bshelden> I think I may have enough homework for a week or four now :P
17:33:51 * ski suggested HoTT to be ordered to the local math library .. still waiting for it, though
17:34:31 <hodapp> ski: it's $21.83 from Lul
17:34:33 <hodapp> ...Lulu
17:41:09 <e11> http://lpaste.net/118099
17:41:21 <e11> ok so a do block is IO, has to return a type IO t0 = IO something, yeah?
17:41:43 <e11> IO t0  means IO [any kinda thing]   yeah?
17:41:56 <bshelden> a do block's type depends entirely on the context you use.  Not specific to IO
17:42:15 <e11> where is the context of the do block set?
17:42:31 <bshelden> By the things you put it in.
17:42:45 <bshelden> do println "Hi" :: IO ()
17:42:51 <e11> it doesnt receive arguments, are you referring to the last line return statement convention thing?
17:42:54 <bshelden> do (Just 5) :: Maybe Int
17:42:56 <e11> last line = return statement
17:43:06 <bshelden> @t return
17:43:06 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
17:43:11 <EvanR> all the lines in a do block need to have the same monad
17:43:12 <bshelden> @type return
17:43:13 <lambdabot> Monad m => a -> m a
17:43:15 <bshelden> There
17:43:36 <bshelden> Return is just a function on the monad typeclass.  Takes some value 'a' and returns it in the context.  On it's own it doesn't imply any context.
17:44:07 <bshelden> Imporant: 'return' in haskell has little to nothing to do with 'return' in other languages.
17:44:18 <e11> wow, thats pretty zen.. ok I'm going to read up on monads then. seems like I cant get around it, even just trying to write a simple project euler thing.
17:44:27 <bshelden> I'm of the opinion that the name is poor.  I tend to use 'point' in Scala.
17:44:35 <e11> which name is poor?
17:44:50 <Hijiri> return
17:44:50 <EvanR> you dont need to understand monads to print out the answer to your problem
17:44:53 <bshelden> I'd suggest you don't (read up on monads).  You'll find a billion 'answers' each worse thyan the last.
17:44:58 <e11> haha, ok
17:45:00 <EvanR> just use print
17:45:01 <EvanR> :t print
17:45:02 <lambdabot> Show a => a -> IO ()
17:45:14 <e11> oh, hahaha, dont have to read up on monads then!
17:45:24 <tac> return is a stupid name for it
17:45:31 <tac> @type pure
17:45:32 <lambdabot> Applicative f => a -> f a
17:45:38 <Hijiri> :t unit
17:45:39 <lambdabot>     Not in scope: ‚Äòunit‚Äô
17:45:39 <lambdabot>     Perhaps you meant one of these:
17:45:39 <lambdabot>       ‚Äòinit‚Äô (imported from Data.List),
17:45:39 <tac> That is the same function in Applicative
17:45:46 <bshelden> They'll come naturally as you get a bit more familiar with how haskell types flow.  When we say it's just bind and return with a couple rules, we're not kidding.  It's a super simple pattern.
17:45:57 <bshelden> But there's this mythology about them that drives poeple to confusion
17:46:28 <bshelden> So I don't suggest you leave them alone because they're "advanced" or "complex".  Just because they'll come naturally as you learn with no need to focus on them.
17:46:29 <Hijiri> I wonder at what point the mythology behind monads will be explained sufficiently, and then the mythology around monads will become a mythology itself
17:46:29 <e11> i like how you guys have this relaxed stance on monads, pretty cool, yeah I have the feeling I know the phenomenon you mention from other knowledge domains, where there are some magic concepts that attract undue attention and controversy and become sticking points in people's understanding.
17:46:31 <Iceland_jack> bshelden: They're also confusing them with impurity and a myriad of other things
17:47:06 <bshelden> Hijiri: I think we're entering that meta-mythology with the recent wave of "don't write monad blog posts" blog posts.
17:47:09 <Iceland_jack> e11: It's just quite common that people try to learn Haskell with the objective to "get" Monads
17:47:49 <e11> yes, ok, well I will take care not to bend myself out of shape trying to understand them then
17:47:53 <Iceland_jack> So they both put them on a pedestal and try to learn them before learning enough Haskell
17:47:58 <EvanR> blog post: What are Functors really?
17:48:24 <Iceland_jack> That's a very good stance e11, type classes and Functors would actually be a really good place to start
17:48:34 <EvanR> would actually be a better blog post
17:48:41 <EvanR> lots of examples
17:48:43 <e11> yes, thanks Icelandjack
17:49:13 <EvanR> i remember reading a monad blog post and being annoyed that the two examples were State and Random
17:49:21 <EvanR> which are basically the same thing
17:49:24 <josephle> EvanR: functors are a magic trick. You start with chicken burrito and then suddenly the burrito is full of carnitas instead
17:49:36 <EvanR> lol
17:50:01 <bshelden> I tend to teach them via Identity, Maybe, then Reader.  So far so good.  But I also don't go there before typeclasses in general, and for that I use Semigroup.
17:50:50 <bshelden> e11: Let me make that a specific suggestion: Learn how Semigroup, then Monoid work.  They're nice and simple concepts and don't distract too much when learning typeclasses.
17:51:02 <e11> ok, semigroup.
17:51:20 <EvanR> > [1,2,3] <> [4, 5, 6]
17:51:21 <lambdabot>  [1,2,3,4,5,6]
17:51:50 <Iceland_jack> > getSum (5 <> 10)
17:51:51 <lambdabot>  15
17:51:56 <Iceland_jack> > getProduct (5 <> 10)
17:51:57 <Welkin> what is an example of a semigroup?
17:51:58 <lambdabot>  50
17:52:01 <bshelden> Semigrop abstracts "add" or "append".  Monoid adds a nothing you can "add" or an empty thing to "append".
17:52:07 <Welkin> it seems everthing that would be a semigroup is a monoid
17:52:08 <bshelden> Welkin: Int, +
17:52:09 <EvanR> lists, Sums, and Products
17:52:18 <Welkin> + is a monoid
17:52:22 <Welkin> not strictly a semigroup
17:52:24 <e11> can you point to a good tutorial bshelden?
17:52:31 <bshelden> Welkin: file diffs
17:52:31 <Welkin> er
17:52:35 <Welkin> 0 and +
17:52:35 <ReinH> Welkin: every monoid is also a semigroup. The reverese is not true.
17:52:40 <Welkin> yes
17:52:46 <Welkin> but what is a semigroup that is not a monoid?
17:52:49 <bshelden> Erm, no, wrong example.  File diffs are my example of monoids that aren't communicative
17:52:50 <EvanR> non empty lists
17:52:52 <bshelden> Sorry
17:53:12 <ReinH> the integers with max or min
17:53:29 <josephle> floating point over addition?
17:53:41 <EvanR> it has an identity
17:53:42 <ReinH> josephle: floating point addition isn't associative
17:53:45 <josephle> ah
17:53:46 <josephle> whoops
17:53:50 <josephle> wrong thing to drop
17:54:22 <ReinH> Every semigroup can be *made* a monoid by adjoining an extra element and defining it to be the identity element
17:54:32 <ReinH> So you can say instance Semigroup a => Monoid (Maybe a)
17:54:53 <josephle> semigroups have no identity, not no associativity...my bad
17:55:13 <bshelden> Dropping assoc and you get.. a magma?  I don't know the rest of the ring well
17:55:23 <ReinH> where mempty is Nothing and mappend is the underlying mappend for a lifted in the obvious way
17:55:35 <ReinH> bshelden: a magma is a set with a binary operation and no laws
17:55:44 <bshelden> I thought magmas were still closed
17:55:49 <josephle> bshelden: wikipedia tells me it's a Loop
17:55:57 <ReinH> That's implied by the definition of operation
17:55:59 <EvanR> implied by the operation being "on" the set
17:56:10 <bshelden> Haskell can capture that law in the type system :P
17:56:19 <ReinH> indeed
17:56:29 <EvanR> type theory heals all wounds ;)
17:56:36 <bshelden> e11: Not really, actually.  I just did a little googling and played with a code editor
17:56:51 <Hijiri> semigroup tutorial?
17:57:10 <bshelden> The context here is I was suggesting semigroup as a good first typeclass to learn when the point is to learn typeclasses.
17:57:17 <bshelden> Since it's dead simple
17:57:25 <ReinH> semigroup doesn't have enough structure to be interesting, though. Monoid is a good sweet spot.
17:57:26 <Hijiri> there is the typeclassopedia, which covers monoid
17:57:27 <EvanR> associativity isnt necessarily a given
17:57:29 <Hijiri> I don't know about semigroup
17:57:46 <EvanR> typeclassopedia now has semigroups
17:58:03 <Hijiri> @where typeclassopedia
17:58:03 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
17:58:04 <bshelden> I mean, semigroup comes down to "has a plus operation of some sort".  The interesting bit is the typeclass concept itself.  Here's a function that some types can implement.
17:58:35 <bshelden> Then you move to monoid and see how things relate.  What types fall out, that kind of thing.
17:59:01 <EvanR> functor is vastly more likely to come up
17:59:21 <bshelden> Oh yes, but it's interesting in and of itself, and a more complex kind of typeclass (it takes type constructors, not types)
17:59:35 <bshelden> So I don't tend to go there until after Monoid
18:00:00 <ReinH> If you're going to start with semigroup, you can fix the current situation by making instance Semigroup a => Monoid a where mempty
18:00:10 <ReinH> at least for pedagogy
18:00:17 <shachaf> What?
18:00:34 <EvanR> but, the instances for basic types of monoid need wrappers Sum and Product ...
18:00:45 <EvanR> otherwise you still need to deal with lists products and maybes
18:00:50 <ReinH> shachaf: making Semigroup a "superclass" of Monoid, like Functor will be to Monad
18:01:01 <bshelden> Now here's a place I'm currently not as happy with Haskell.  I soured on inheritance that way entirely.  I'm currently favouring a different way to encode them.
18:01:40 <bshelden> in scala I'd use trait Semigroup[A] { def mappend: A => A => A }; trait Monoid[A] { def isSemigroup: Semigroup[A]; def mzero: A }
18:01:41 <Axman6> ReinH: Applicative you mean?
18:01:47 <ReinH> Axman6: sure.
18:01:58 <ReinH> Axman6: but it's a transitive superclass of Monad as well :p
18:02:03 <Axman6> (which implies that Functor will be a superclass too)
18:02:04 <Axman6> right
18:02:14 <joneshf-laptop> are you supposed to write your arbitrary instances for quickcheck in the file where the data type is defined?
18:02:21 <joneshf-laptop> as otherwise isn't it an orphan?
18:02:32 <bshelden> Of course Scala's encoding of typeclasses have their own issues.  Implicit resolution nightmares.  Orphan typeclasses.  Lots of nasty there as well.
18:02:34 <Axman6> does Monoid e => (,) e have an applicative instance?
18:02:36 <EvanR> bshelden: uhm.. isSemigroup?
18:02:41 <ReinH> joneshf-laptop: I don't think it matters too much if you have orphans in a test module
18:03:07 <Axman6> > (++) <$> (Sum 1, "Hello") <*> (Sum 2, ", World!")
18:03:08 <lambdabot>  (Sum {getSum = 3},"Hello, World!")
18:03:10 <bshelden> EvanR: Your monoid instance implementation would be composed of its fields, and an instance of the 'subtypeclass'
18:03:13 <Axman6> yes
18:03:21 <EvanR> bshelden: but.. why
18:03:24 <ReinH> Axman6: Yes, Writer is an Applicative
18:03:44 <bshelden> I don't like inheritance magic.  My personal style is to favour explicit composition.
18:03:55 <EvanR> bshelden: this is actually not inheritance magic in haskell
18:03:58 <joneshf-laptop> ReinH, hmm, why is that?
18:03:59 <Axman6> oh right, it's just writer, hadn't realised that
18:03:59 <bshelden> There's a reason I'm phrasing this in subjective terms.
18:04:10 <EvanR> bshelden: composition implies that all values are implemented as objects
18:04:14 <ReinH> joneshf-laptop: because it's just a test module. It doesn't impact the library itself.
18:04:35 <EvanR> bshelden: would prefer to loose the way stuff is implemented and only concentrate on the interface
18:04:48 * bshelden nods
18:05:23 <EvanR> the constraint in the class only says that any type implementing Monoid also implements Semigroup
18:06:53 <bshelden> Yeah, I remain not persuaded, but this is a subjective thing, and totally moot.  I write typeclasses in haskell in the normal way.
18:07:02 <hdevalence> /part
18:07:02 <hdevalence>  
18:07:31 <EvanR> "composition instead of inheritance" is only relevant if you have fields or properties, which may not make sense for all types
18:08:13 <ReinH> composition is just multiple inheritance + indirection ;)
18:08:58 <EvanR> Endo, functions from a to a, implements monoid, but it cant storage anything for semigroups
18:09:01 <pingu> anyone used the tls related haskell packages and managed to load an RSA pubkey?
18:09:18 <pingu> the DER loading stuff doesn't seem to... work
18:09:26 <EvanR> and objects that are functions sounds pretty wasteful and counter intuitive
18:10:03 <bshelden> I'll keep pondering
18:10:12 <bshelden> I'll face this soon enough when I get that far in my little pet language
18:10:42 <bshelden> But typeclasses aren't the first thing I'm designing in.  I still have to get at least to the power of the simply typed Œª-calc
18:11:41 <pfurla> is there a way to quick check source code without a cabal build?
18:12:05 <vanila> bshelden, sounds cool! istherea blog or github or something I can follow?
18:12:05 <ReinH> I suppose you could use runghc
18:12:24 <EvanR> bshelden: are you implementing this in scala?
18:12:29 <bshelden> vanila: Not really, no.  This is more of a learning excercise.  I'm learning type theory a bit better.
18:12:58 <pfurla> ReinH: do you mean me?
18:13:01 <bshelden> EvanR: Likely so.  I don't think I want to deal with bridging haskell and minecraft forge. (The actual target is a computer modded into that game0
18:13:05 <ReinH> pfurla: yeah
18:13:34 <bshelden> Not off the table though.  Just.. JNI isn't fun.
18:13:37 <pfurla> ReinH: here's the deal, I have one source file, which I am playing with in repl, you know, :load xxx.hs
18:13:40 <vanila> wait minecraft?
18:13:42 <vanila> what
18:13:49 <EvanR> bshelden: hahahaha. minecraft. i did successfully boot up the haskell java bridge, call some methods, and get a null pointer exception
18:13:59 <pfurla> Reinh: but I got a point where having some checks would be really nice
18:14:11 <bshelden> Pretty much.  Leaving the JVM by anything other than a socket is ... painful.
18:14:13 <ReinH> pfurla: well, you can run quickcheck in ghci
18:14:29 <EvanR> bshelden: it takes care of the jni for you
18:14:50 <bshelden> vanila: There's a minecraft mod that adds computers.  Said mod has hooks to let you swap out the archetecture (I hate Lua).  I'm writing a haskell-lite language to replace it.
18:15:03 <vanila> what the heck! Awesome :)
18:15:03 <bshelden> EvanR: Tempting then.
18:15:20 <pfurla> ReinH: in other but i'd loose the nice -- | <quickcheck> in sources wouldn't I?
18:15:22 <vanila> what do these computers do inside the game?
18:15:39 <ReinH> pfurla: well, you can do both?
18:15:48 <ReinH> I'm not sure what you're trying to do
18:15:50 <bshelden> That's hard to answer quickly, and a full discussion there is probably better off in -blah
18:15:54 <pfurla> ReinH: that's what I am asking :)
18:17:05 <pfurla> ReinH: no cabal or other complicated configuration. -- | <somequickcheck on xxx>; xxx = ...;
18:17:26 <pfurla> ReinH: it's ok if I have to trigger the QC execution in the repl
18:17:29 <pfurla> ghci
18:18:35 <ReinH> pfurla: I don't think you can trigger doctests without a compile
18:18:53 <ReinH> I mean, it's theoretically possible, but I doubt anyone has put any work into doing so
18:18:58 <pfurla> yeah, that was feeling, surely would be nice
18:19:05 <pfurla> agree
18:22:13 <Hijiri> vanila: They can emit redstone signals, display things on a screen, and network with other computers, and also some other things
18:22:29 <vanila> I see! How cool
18:22:31 <Hijiri> also some mods you can connect to and have custom things
18:22:44 <Hijiri> like if you use wires from one mod, you used to be able to get ethernet
18:22:54 <Hijiri> I think the computers mod comes with its own cable now
18:26:18 <bshelden> It does.  The one I refer to (OpenComputers) actually has quite a bit.  Network cards, wireless cards.  p2p linked cards.  An actual proper into-the-world TCP card.
18:26:26 <bshelden> Fourth wall?!?
18:26:32 <bshelden> Time to jet
18:27:31 <vanila> good luck getting haskell on it!
18:27:40 <vanila> or at least a typed language like that, nice idea
18:29:03 <bshelden> Thanks to EvanR's suggestion, I maybe be able to host the vm in haskell.  That'd be lovely.  I don't want to write this thing in Scala if I can avoid it.
19:16:41 * hackagebot cab 0.2.15 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.2.15 (KazuYamamoto)
19:22:44 <Information115> Does anyone know anything about Ubuntu 14.04 LTS?
19:23:16 <johnw> are you asking in relation to Haskell?
19:24:17 <zzing> Is there a zip function that would be able to take an infinite list for the first parameter, and pair them up with items in the second? I essentially want to pair up an index with each item in a list
19:24:24 <johnw> yes
19:24:29 <johnw> it's called the zip function :)
19:24:37 <johnw> > zip [1..] ["a", "b", "c"]
19:24:39 <lambdabot>  [(1,"a"),(2,"b"),(3,"c")]
19:24:45 <zzing> awesome :P
19:24:45 <Iceland_jack> zzing: zipWith (,) [1..]
19:24:55 <Iceland_jack> If you hate clarity
19:25:00 * Iceland_jack runs away to bed
19:25:01 <johnw> zipWith (,) = zip, no?
19:25:11 <Iceland_jack> Yes
19:49:42 <blahmah> are parsec and attoparsec performant enough for use in parsing general-purpose programming languages like haskell?
19:50:00 * Clint squints.
19:50:52 <vanila> I'd like an answer to that too - would be nice if someone replaced GHCs frontend with parsec and benchmarked
19:51:58 <johnw> blahmah:  what kind of performance do you need?   are you parsing hundreds of megabytes of source code?
19:52:56 <blahmah> johnw: potentially, are there any frontends using parsec or attoparsec currently?
19:53:23 <johnw> I'm not sure what haskell-src-exts uses
19:53:25 <johnw> and there's the GHCA PI
19:53:36 <johnw> but I don't know about a parsec parser for Haskell source code
20:00:49 <ab9rf> iirc you need a preprocessor to parse haskell with parsec, to handle indentation
20:01:32 <ab9rf> blahmah: honestly when you're writing a compiler for a general language, the performance of the parser is not a serious concern
20:02:04 <blahmah> yeah it is...
20:02:45 <blahmah> a lot of frontends used hand-coded parsers in assembly to save a few ticks per character
20:03:02 <ab9rf> blahmah: i highly doubt that
20:03:11 <ReinH> "A lot of"?
20:03:18 <blahmah> gcc
20:03:18 <ReinH> Perhaps you could name a couple?
20:03:30 <cjheath> blahmeh: That was definitely true in the 1970‚Äôs. Not so sure abt now
20:03:39 <Iceland_jack> Languages like C/C++ translation units can require header files that are enormous
20:03:53 <Iceland_jack> that's why people precompiled them
20:03:58 <ab9rf> Iceland_jack: fair point, STL is a behemoth
20:04:08 <ab9rf> and the insanity that is C++ template metaprogramming
20:04:22 <cjheath> precompilation is not the same thing as hand-codingin assembly though
20:04:41 <blahmah> hes talking about precompiled headers
20:05:18 <cjheath> blahmeh: Where‚Äôs the ‚Äúhand coded in assembly‚Äù parser in gcc?
20:05:31 <ab9rf> i want to see this handcoded in assembly parser
20:05:40 <blahmah> I'm actually reading a fairly recent book on compilers atm and the authors state that most of the industrial grade compilers use hand-coded parsers
20:05:43 <ab9rf> in a compiler that is portable across dozens of architectures
20:06:04 <cjheath> The authors are wrong, outright.
20:06:05 <johnw> blahmah: as someone who works on several compilers in industry, I can tell you that that statement is not factual
20:06:10 <vanila> blahmah, I'm studying compilers - any favorite books you'd recommend?
20:06:16 <ab9rf> blahmah: what book is this?
20:06:24 <blahmah> im reading this book: http://www.amazon.ca/Engineering-Compiler-Keith-Cooper/dp/012088478X
20:06:25 <johnw> and I'm friends with people who work on nearly every major C++ compiler that exists
20:06:27 <ab9rf> blahmah: page number?
20:06:33 <ReinH> GCC's parser is written in C though?
20:06:39 <ab9rf> ReinH: i believe so.
20:06:45 <ReinH> I mean, I'm looking at it right now
20:06:46 <Iceland_jack> What about optimized parser tables, do they count?
20:06:47 <blahmah> uh, in the beginning somewhere, dont remember
20:06:48 <ReinH> https://github.com/gcc-mirror/gcc/blob/master/gcc/c/c-parser.c
20:06:50 <vanila> haskell-src-exts is written with happy not parsec
20:06:52 <ab9rf> ReinH: it's "portable C code" so i doubt it's got any assembly in it
20:06:53 <ReinH> So I guess that wasn't really a question.
20:07:02 <vanila> someone needs to make a parsec GHC frontend and benchmark it
20:07:04 <ab9rf> ReinH: if it does, it's going to be #ifdef'd
20:07:14 <vanila> no amount of speculation is going to get answers
20:07:17 <johnw> Iceland_jack: I could see writing the table walking loop in assembly, it's such a tiny piece of code
20:07:18 <ReinH> ab9rf: Well, the file contains zero ifdefs
20:07:22 <blahmah> what?
20:07:29 <blahmah> gcc has a lof of assembly in it...
20:07:38 <ab9rf> blahmah: sure, but i doubt much of it is in the parser
20:07:42 <blahmah> not relativelly to c, but a decent amount
20:07:51 <ReinH> AFAI am aware, the GCC parser has never been written in assembly
20:07:59 <ReinH> it went from yacc to a hand-written parser in C
20:08:10 <ab9rf> ReinH: i used to be friends with jim blandy when he was involved in gcc and gdb
20:08:16 <ab9rf> ReinH: and i can't see him even tolerating that
20:08:18 <vanila> I think most compilers use LR(1)/LL-whatever parser genreators
20:08:23 <ReinH> you can still find the original patches where it was added easily
20:08:23 <cjheath> the assembly is only in the code generator, I‚Äôm wiling to bet. And none of it is run during compilation
20:08:42 <ReinH> Ah. Here. https://gcc.gnu.org/ml/gcc-patches/2004-10/msg01969.html
20:08:44 <ab9rf> ReinH: admittedly that was now something like 20 years ago
20:08:53 <blahmah> ReinH: hand written parser in C is basically the same as written in asm (performance-wise)
20:08:54 <Iceland_jack> http://stackoverflow.com/questions/6319086/are-gcc-and-clang-parsers-really-handwritten relevant question
20:09:13 * cjheath skipped most of his compiler-writing classes because he was busy porting the Ritchie C compiler
20:09:14 <Iceland_jack> According to the top answer both GCC and Clang have hand-written parsers
20:09:28 <ab9rf> Iceland_jack: "hand written" in assembly, or in C?
20:09:31 <ReinH> blahmah: Sure, and apparently it was only about 1.5% faster than the original parser anyway
20:09:34 <johnw> so, back to Haskell
20:09:35 <vanila> "Writing a C parser is quicker than reading, analysing and replying to hundreds of list messages discussing how to implement OpenMP and what should or should not be replaced to do so, so I just wrote one over the past week"
20:09:38 <johnw> the speed of Parsec should be just fine
20:09:39 <ab9rf> Iceland_jack: i've written "hand-written" parsers in C
20:09:40 <vanila> wow!
20:09:46 <Iceland_jack> THe GCC is in C anyway
20:09:50 <blahmah> ReinH: 1.5% for what source length?
20:10:06 <blahmah> I highly doubt its linear growth
20:10:07 <cjheath> ab9rf: so have I
20:10:15 <vanila> I would have expected the yacc generated parser to be faster than hand written
20:10:22 <vanila> how come the C one is faster?
20:10:37 <ReinH> blahmah: Not sure. Here's my source http://gcc.gnu.org/wiki/New_C_Parser
20:10:42 <blahmah> because generated parsers can usually be optimized by hand
20:10:55 <ab9rf> i think this is someone confusing "hand written" and "with assembly"
20:10:58 <vanila> why aren't they optimized by the tools?
20:11:06 <blahmah> because its hard
20:11:12 <vanila> alright
20:11:18 <ab9rf> i have no doubt that most C compilers are handcrafted or at least handtweaked, instead of being stock output of a LALR or GLR generator
20:11:31 <ab9rf> but that doesn't mean inserting asm pragmas
20:11:38 <blahmah> yeah I'm probably wrong about the assembly part
20:11:43 * hackagebot test-framework 0.8.1.1 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.8.1.1 (BryanOSullivan)
20:11:52 <blahmah> my main point is that they are hand crafted to save performance
20:12:10 <cjheath> I wonder how many kilojoules the hand-written parser has saved
20:12:10 <vanila> yeah thats interesting
20:12:12 <ab9rf> C++ is not in LALR(n) for any n, so you can't use e.g. yacc to write a C++ compiler without some ugly shenanigans
20:12:14 <ReinH> We should take this to #haskell-blah
20:12:21 <ab9rf> blahmah: no, they're handcrafted to make them work at all
20:12:35 <vanila> blahmah, despite this I still think someone really needs to do an actual test with a parsec frontend for GHC
20:12:42 <johnw> yes, to -blah with you!
20:12:53 <ab9rf> i'm sure i've seen a parsec parser for haskell
20:12:53 <vanila> we're actually having a conversion guys :/
20:12:57 <ab9rf> although i forget where
20:13:16 <ReinH> vanila: I'm not trying to stop it, I'm just trying to move it to an appropriate venue
20:13:24 <ReinH> since it's off topic here
20:13:31 <vanila> :/
20:13:34 <johnw> thanks, ReinH
20:15:30 <vanila> i cant be bothred arguing but the question is on topic here
20:15:38 <vanila> so its annoying you pushing it out
20:15:53 <vanila> he's trying to build a haskell program and asking about things relevant to its design
20:16:08 <johnw> the parsec bit, great; the general argument about compilers, that's what ReinH meant
20:20:50 <ReinH> Right. I'd like to focus on the parsec bit and move the general discussion about the history of parsers to -blah
20:21:10 <Axman6> :t traverse return
20:21:11 <lambdabot> (Traversable t, Applicative f, Monad f) => t b -> f (t b)
20:21:11 <ab9rf> and splat, there goes all discussion
20:26:23 <zzing> I am attempting to write some code that is using a Maybe [a]  inside of the IO monad, and I am having a little bit of trouble with figuring out how to output this. Could I get some input? (error included at bottom: http://lpaste.net/118103 )
20:27:43 <zzing> I was almost wondering if I need some kind of transformer, but it seems a little far for this.
20:28:30 <glguy> zzing: consider
20:28:31 <glguy> :t \x -> putStrLn <$> x
20:28:32 <lambdabot> Functor f => f String -> f (IO ())
20:29:09 <Iceland_jack> zzing: I think you want:
20:29:09 <Iceland_jack>     System.IO.putStrLn =<< ((L.unlines . L.map show) <$> indexes)
20:29:51 <zzing> Iceland_jack, that changes nothing unfortunately
20:29:59 <glguy> or maybe: let str = L.unlines . L.map show <$> indexes; putStrLn str
20:30:04 <glguy> No, =<< or <$> needed
20:30:10 <zzing> glguy, could you be a little bit clearer, I am not sure what you are saying :-(
20:31:15 <zzing> glguy, that gets rid of that error, now just one left
20:31:15 <glguy> You're writing    fmap putStrLn (_ :: Maybe _), so you're going to get back something with type   Maybe _
20:31:36 <zzing> I was expecting the Maybe
20:31:45 <glguy> All of the lines in your do block need to have type   IO _
20:32:12 <zzing> That is why I thought the putStrLn would be enough being that it returns  IO ()
20:32:38 <glguy> Right, putStrLn :: String -> IO (),   but   fmap putStrLn :: Maybe String -> Maybe (IO ())
20:33:32 <SrPx> If I have 2 Ints, x and y, and I want one float equal to x/y, is the right way to do it: `fromIntegral x / fromIntegral y` ?
20:34:12 <zzing> traverse appears to be what I want
20:34:42 <zzing> I just updated the post with compiling code
20:34:56 <Axman6> :t traverse `asAppliedTo` (Just [1,2,3])
20:34:57 <lambdabot>     Couldn't match expected type ‚Äòa -> f b‚Äô
20:34:57 <lambdabot>                 with actual type ‚ÄòMaybe [t0]‚Äô
20:34:57 <lambdabot>     Possible cause: ‚ÄòJust‚Äô is applied to too many arguments
20:35:06 <Axman6> :t traverse return `asAppliedTo` (Just [1,2,3])
20:35:06 <lambdabot> (Applicative f, Num t, Monad f) => Maybe [t] -> f (Maybe [t])
20:35:13 <Iceland_jack> SrPx: Depends, do you want truncated integer division?
20:35:21 <Iceland_jack> > 42 `div` 13
20:35:23 <lambdabot>  3
20:35:40 <Iceland_jack> > fromIntegral (42 :: Int) `div` fromIntegral (13 :: Int)
20:35:41 <Axman6> @hoogle t (f a) -> f (t a)
20:35:42 <lambdabot>  3
20:35:43 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
20:35:43 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
20:35:43 <lambdabot> Test.QuickCheck.Gen promote :: Monad m => m (Gen a) -> Gen (m a)
20:35:45 <Iceland_jack> > fromIntegral (42 :: Int) / fromIntegral (13 :: Int)
20:35:47 <lambdabot>  3.230769230769231
20:35:48 <platz> @src asAppliedTo
20:35:48 <lambdabot> Source not found. I've seen penguins that can type better than that.
20:36:01 <zzing> hmm, this actually worked
20:36:22 <SrPx> Iceland_jack: nah floating point ^^
20:36:40 <Axman6> I thin asAppliedTo is just const; asAppliedTo :: (a -> b) -> a -> (a -> b)
20:36:41 <Iceland_jack> Okay then fractional division (/) is your thing :)
20:36:44 <zzing> Can anyone offer suggestions for improvement of code?  http://lpaste.net/118103     This is the first part of making an index from an example in an information retrival textbook.
20:36:46 <Axman6> :T asAppliedTo
20:36:49 <Axman6> :t asAppliedTo
20:36:50 <lambdabot> (a -> b) -> a -> a -> b
20:37:40 <Iceland_jack> zzing: You don't want 'traverse System.IO.putStrLn str'
20:38:01 <Iceland_jack> zzing: Rather write 'traverse_ putStrLn str' or 'mapM_ putStrLn str'
20:38:06 <glguy> He does because it's aMaybe String
20:38:19 <glguy> :t for_ `asAppliedTo` putStrLn
20:38:20 <lambdabot>     Could not deduce (Foldable ((->) String))
20:38:20 <lambdabot>       arising from a use of ‚Äòfor_‚Äô
20:38:20 <lambdabot>     from the context (Applicative f)
20:38:27 <glguy> Oops :)
20:38:30 <zzing> :t traverse_
20:38:30 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
20:38:47 <Iceland_jack> They're avoiding the return value of the 'traverse' though
20:38:51 <Iceland_jack> *ignoring
20:39:31 <glguy> Yeah, I just thought that was going a different direction
20:40:04 <platz> Axman6: i think it's just undefined
20:40:22 <Axman6> it could also be that too
20:40:41 <zzing> Is there a way to deal with the Nothing value specially (for example printing out usage info) without making the code look 'ugly'?  I like how it doesn't have to have any indentations right now
20:40:43 <Axman6> but const works for when you want to use it too
20:41:07 <Iceland_jack> zzing: you can use "maybe" or "fromJust"
20:41:16 <Iceland_jack> Do you not want to use a case expression?
20:42:28 <zzing> It might be best to use a case expression, I was just hoping it would be a nice and clean way. Not liking to indent code too much in haskell.
20:43:44 <Iceland_jack> Yeah I gotcha, often times you can either use the MaybeT monad transformer (that can be used to mix Maybe and IO) or you can split the case expression functionality into different functions
20:45:44 <zzing> What is a good place to read up on MaybeT? I would love a short intuitive explanation that works near bed time :-)
20:46:25 <Iceland_jack> oh dear, let me see if... hm
20:46:36 <Iceland_jack> Begin by 'import Control.Monad.State'
20:46:57 <peddie> zzing: https://en.wikibooks.org/wiki/Haskell/Monad_transformers discusses MaybeT in detail
20:47:03 <Iceland_jack> no eugh, ignore me!
20:56:24 <jle`> zzing: a lot of times the Functor/Monad/Applicative instances are useful enough to get rid of your Maybe boilerplate
20:56:34 <jle`> if you post a specific example we can see what we can eliminate :)
20:56:55 <jle`> ideally you'd only have to use one case/`maybe` for your entire thing
20:57:20 <jle`> most common Maybe usage patterns already have nice abstractions :)
20:57:33 <zzing> jle`, the example I put up at http://lpaste.net/118103  has a deficiency where it doesn't tell you usage if you don't put anything or put too much
21:01:46 * hackagebot text-icu 0.7.0.1 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.7.0.1 (BryanOSullivan)
21:26:02 <abg> joeyh: I want to submit a quick patch for shell-monad. What's the best way to do this?
21:26:47 * hackagebot hoauth2 0.4.4 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.4.4 (HaishengWu)
22:09:58 <Javran> is there a document about what kind of definitions will be available in Paths_$module provided by cabal?
22:15:55 <bwiklund> disclaimer: i am not asking for homework review or anything, just a developer with no haskell friends looking for feedback
22:16:29 <bwiklund> would anyone do me the honor of looking at a tiny project i've made and pointing out any glaring haskell mistakes?
22:16:32 <bwiklund> https://github.com/bwiklund/bad-haskell-server
22:16:50 <bwiklund> it's a tiny and very incomplete webserver built from sockets up, so i don't really care about compliance to specs there
22:16:59 <bwiklund> more about whether or not i'm writing good and idiomatic haskell
22:28:03 <Thete> Why is lambdabot in #MacOSX?
22:30:12 <int-e> Thete: all I can say is that it's been there for a while
22:30:25 <Thete> I was just curious
22:30:37 <Thete> there a command to get lambdabot to join other channels?
22:31:18 <int-e> Thete: you can ask me
22:31:20 <Axman6> because I wanted her there
22:31:33 <Thete> Ahh :)
22:31:46 <Axman6> that's pretty much the entire reason
22:31:53 <Thete> That's a good reason
22:32:11 <Axman6> having @google is pretty handy a lot of the time =)
22:34:24 <johnw> int-e: can you add lambdabot to #ledger?
22:36:41 <Lokathor> any idea why an OpenGL/GLUT program would run itself twice in a row? It works normally for me, but on a friend's machine it runs, then he closes it, and it runs itself a second time
22:37:35 <Lokathor> i compiled it with the -optl-mwindows flag, if that affects things, but without that flag it was giving him an error and also running twice
22:40:34 <x77686d> haskell.org has seemed glacial to me the last couple of days.  Is anybody else seeing the same?
22:40:45 <johnw> yes, it's known about
22:40:54 <johnw> they are working on it
22:41:01 <x77686d> thx
22:43:51 <bwiklund> i'm seeing .org being slow as well
22:43:54 <bwiklund> for a week or more
22:44:09 <bwiklund> oh nm already confirmed
22:45:44 <Javran_Eval> @hoogle MonadIO m => m a -> IO a
22:45:46 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar get :: HasGetter g => g a -> IO a
22:45:46 <lambdabot> Control.Concurrent.Chan readChan :: Chan a -> IO a
22:45:46 <lambdabot> Control.Exception.Base block :: IO a -> IO a
22:46:52 * hackagebot hi 1.1.0.0 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-1.1.0.0 (DaisukeFujimura)
22:47:16 <Javran_Eval> so if i have a MonadIO how to make it type check with "main"?
22:47:38 <johnw> from main you can just call it
22:48:23 <Javran_Eval> johnw: i see
22:49:05 <Axman6> it should provide some function with a type FooT IO a -> IO a of some kind. which MonadIO monad are you talking about?
22:49:39 <Javran_Eval> now it make sense that you cant get rid of MonadIO by turning it into IO
22:50:30 <Javran_Eval> Axman6: XMonad
22:51:53 <ski> johnw was presumably thinking of one polymorphic over `MonadIO's
22:52:49 <HeladoDeBrownie> instance MonadIO IO where liftIO = id
22:53:05 <johnw> yep
23:15:25 <SoupEvil> is there a way to measure compile times for modules in a cabal project?
23:16:14 <adu> SoupEvil: time?
23:17:40 <SoupEvil> i need the the compile time for each module not the total compile time
23:18:29 <SoupEvil> or some other measurements, like "spending x seconds in TH total" or something else
23:22:32 <SoupEvil> my project starts to be really slow to compile, and i want to investigate why und where. without to much "trial, wait 3 min, error"
23:24:24 <SoupEvil> maybe there is a hidden cabal flag to measure the individual module compile times, or to measure the stages or both or other helpful things
23:36:24 <joneshf-laptop> what options are there for viewing data as plots? e.g. box, scatter, line, etc?
23:37:52 <vanila> youcould call out to gnuplug
23:37:54 <vanila> gnuplot
23:40:42 <joneshf-laptop> hmm, is there anything octave/R like, where you just dump the data into a function and with minimal fuss you get out a plot?
23:42:27 <spyzer> hey everyone, I am getting compiler error on this, what is wrong?
23:42:27 <spyzer> m_sort (x:y:[])   | x > y     = y:x   | otherwise = x:y
23:42:45 <spyzer> ther were on separate lines
23:42:52 <vanila> you need :[] on your results
23:43:02 <spyzer> ah i see
23:43:06 <ThreeOfEight> joneshf-laptop: there is this https://hackage.haskell.org/package/plot-0.2.3.3/docs/Graphics-Rendering-Plot.html
23:43:15 <Hijiri> Is thielemann the person who is famous for one-letter data types meant to be used qualified? Or was that someone else?
23:44:10 <ThreeOfEight> also, http://hackage.haskell.org/package/Chart and http://hackage.haskell.org/package/haskell-plot
23:44:36 <ThreeOfEight> I have never used any of them myself though.
