00:00:06 <glguy> But your update function doesn't return a list
00:01:18 <glguy> Maybe you meant to write f b : c
00:01:27 * hackagebot vector-th-unbox 0.2.1.1 - Deriver for Data.Vector.Unboxed using Template Haskell  http://hackage.haskell.org/package/vector-th-unbox-0.2.1.1 (LiyangHu)
00:01:34 <glguy> And in the other case.  b:c
00:02:48 <favetelinguis> aa yes that is correct thanks
00:05:16 <glguy> :t over.ix :: Int->(a->a)-> [a] -> [a]
00:05:17 <lambdabot> Int -> (a -> a) -> [a] -> [a]
00:21:28 * hackagebot vector-th-unbox 0.2.1.2 - Deriver for Data.Vector.Unboxed using Template Haskell  http://hackage.haskell.org/package/vector-th-unbox-0.2.1.2 (LiyangHu)
00:36:15 <Nervkind> hey, for an exercise i have the definition of a function: buildSplit n as = ( build ( take n as ) , drop n as ) but i don't really understand it. what does the "," do there?  i kinda get what should be done, but don't understand exactly why that works?
00:36:33 <barrucadu> (a, b) is a tuple
00:37:03 <barrucadu> So it's constructing a 2-element tuple where the first element is "build (take n as)" and the second is "drop n as"
00:37:33 <Kneiva> :t (,)
00:37:34 <lambdabot> a -> b -> (a, b)
00:38:08 <Nervkind> thank you guys!
00:38:13 <Haskellfant> > (take 4 [1..10], drop 4 [1..10])
00:38:15 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
00:46:29 * hackagebot streaming-commons 0.1.9 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.9 (MichaelSnoyman)
00:51:29 * hackagebot codex 0.2.1.4 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.2.1.4 (aloiscochard)
01:08:08 <ashnur> ok, so this is not haskell, but everyone else is sleeping now, and I can't find the answer just by googling. please feel free to ignore me :). I am trying to use FP in javascript, and all is fine up until the point when I have to write something into a database. I do not know what the function which takes 3 arguments, the db handle and the key(string) to write to and a value to write(js object) should return? the api is async, so I obviously return a Future, but
01:08:08 <ashnur> what should that Future resolve to in case there were no errors?
01:23:51 <zomg> ashnur: perhaps the value? It might be convenient if you chain the function with something else which then would require the value to do something
01:24:08 <zomg> That, or nothing I think
01:24:12 <ashnur> i recognize you from somewhere :)
01:24:24 <ashnur> you mean, just a Future of `undefined`?
01:24:28 <RustyShackleford> do the haskell tools work well on windows?
01:24:59 <LordBrain> id be surprised if they don't
01:25:02 <Bor0> RustyShackleford, if by tools you mean libraries, most of them yes in my experience. I've had problems with HDBC-mysql tho
01:25:04 <LordBrain> but i run linux
01:25:54 <Axman6> ghc and the haskell platform are supposed to work on windows just fine
01:25:55 <RustyShackleford> some languages don't play very nice with windows. There are a few python libraries I've tried to use that don't like windows so much
01:26:05 <RustyShackleford> so thats why i ask
01:26:08 <LordBrain> obviously someone is a windows fan, because otherwise how did we end up with ucs16 as the default format for Data.Text
01:26:39 <Axman6> because it's a really convenient representation...
01:27:10 <LordBrain> uh, not going to start that war
01:27:15 <Axman6> ai, it gives you O(1) indexing of any character
01:27:21 <LordBrain> no it doesnt
01:27:26 <Axman6> ie* ai? no idea how I did that
01:28:15 <LordBrain> we'll just agree to mutually think the other is stupid
01:28:28 <LordBrain> safe us all the bickering
01:29:21 <LordBrain> if you wanted that characteristic, you would need to go to 32bit unicode
01:29:38 <Chathurga> I thought you saved the bickering
01:29:42 <LordBrain> i tried
01:30:02 <LordBrain> i'll try harder now that i have had the last word
01:30:23 <Chathurga> :D
01:30:30 <LordBrain> :)
01:31:24 <Axman6> I'm unsure where you're getting the idea that Text is ucs16. the docs afaict doesn't say that. they say that "A Text value is a sequence of Unicode scalar values, as defined in §3.9, definition D76 of the Unicode 5.2 standard. As such, a Text cannot contain values in the range U+D800 to U+DFFF inclusive."
01:31:36 <Axman6> you may be right, but it's not clear you are
01:33:11 <srpx> Hello, what is the best approach to create a site in Haskell today? I've been learning a lot. It is a simple project I could do in JavaScript in a few hours, but I am really determined to drop it from my life (:
01:33:40 <LordBrain> wait
01:34:02 <shachaf> There's no such thing as UCS16.
01:34:13 <LordBrain> they hcanged the name, give me a break
01:34:45 <LordBrain> nevertheless the word was not used for anything else, so my meaning shouldnt be unclear.
01:34:53 <LordBrain> anyway, re the javascript
01:35:10 <shachaf> There are UCS-2 and UTF-16 and they're different things.
01:35:45 <Axman6> srpx: depending on the the project, yesod is a good kitchen sink included framework, scotty is a quite lightweight framework. it'd help if you told us more of what you're after
01:35:45 <LordBrain> oh
01:35:56 <LordBrain> been a while since i looked, maybe thats so, what is the difference?
01:36:10 <srpx> Axman6: woops, thank you. I mean the client alone, though. Not the server :)
01:36:37 <srpx> Axman6: I'm after to replace JS in DOM manipulation/scripting on the client
01:36:51 <LordBrain> i suppose, i mean "16 bit unicode", not really caring which form of it, if there are as you say multiple forms.
01:37:41 <LordBrain> however, i think the most sensible default actually would have been utf-8
01:37:51 <Axman6> srpx: ah, not sure about that then. there's plenty of choice, but I haven't used any of them
01:38:15 <Axman6> utf-8 is only good for transmitting text, not for manipulating it
01:38:42 <Axman6> it makes many operations which should be O(1) O(n) which is a pain
01:38:47 <srpx> ah I see
01:39:23 <LordBrain> but, ucs2 does the same Axman6, and without the advantages of utf-8
01:40:15 <mauke> Axman6: like what?
01:41:49 <Axman6> well, indexing the n'th character, for one
01:42:26 <mauke> UCS-2 can't do that either
01:42:30 <Axman6> this isn't something I'd claim to be an expert on though
01:42:46 <mauke> (because UCS-2 simply can't represent some characters)
01:43:14 <Axman6> "If you think of a Text value as an array of Char values (which it is not), you run the risk of writing inefficient code." guess I was wrong
01:43:30 <ab9rf> heh
01:43:46 <ab9rf> we're back on unicode again, i see
01:43:50 <merijn> Text is a linked list of densely encoded binary blobs of unicode in some encoding you shouldn't care about
01:44:30 <mauke> Text is in UTF-16, which is variable-width, not unlike UTF-8
01:44:36 <LordBrain> also, its impossible to get a false match in searches in utf8, even if your search algorithm assumes 8 bit characters, i have doubts that the 16 bit unicodes are well designed enough to have that kind of property. But even if they do, whats the point.
01:44:56 <merijn> LordBrain: Also, back to the original point
01:45:02 <merijn> The reason why Text is not utf-8 is simple
01:45:11 <LordBrain> someone else made it
01:45:13 <merijn> Someone DID implement utf8 based Text. It was slower
01:45:21 <ab9rf> i would imagine
01:45:27 <merijn> Thus the library stuck with utf16
01:45:39 <LordBrain> why slower?
01:45:44 <merijn> Additionally, utf16 makes interoperation with C libraries (see text-icu) easier
01:45:47 <merijn> LordBrain: Who knows
01:45:55 <Axman6> (bos)
01:45:56 <merijn> LordBrain: Benchmarks showed it was slower by 10-20%
01:45:58 <Axman6> >_>
01:45:59 <LordBrain> so it could simply have needed some more optimizing, nothing to do with the format
01:45:59 <ab9rf> fewer decision points, i imagine
01:46:11 <mauke> IIRC someone improved performance later, but by then there was no point in switching over
01:46:26 <ab9rf> length is much more complicated in utf-8 than utf-16
01:46:31 * hackagebot warp 3.0.5.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.5.2 (MichaelSnoyman)
01:46:35 <mauke> ab9rf: why?
01:46:52 <ab9rf> mauke: because in utf-8, a single character is anywhere from 1 to 4 bytes
01:46:53 <merijn> Axman6: btw, indexing the n'th character isn't even possible in utf32, iirc
01:47:04 <mauke> ab9rf: and in UTF-16 it's 2 or 4 bytes
01:47:07 <ab9rf> in utf-16, it's either 1 or 2 words
01:47:09 <merijn> Axman6: Because you have combining codepoints where multiple codepoints form a single character
01:47:16 <mauke> ab9rf: how is that simpler?
01:47:20 <LordBrain> good point meretrix about nth character
01:47:25 <Axman6> right. indexing the nth codepoint I guess
01:47:29 <LordBrain> that's true, we have all these decorators and such
01:47:30 <ab9rf> mauke: you can get length by taking the buffer length, then scanniung it for surrogates and subtracting one fore very two surrogates found
01:47:39 <merijn> Axman6: Which is a thoroughly useless thing to do :)
01:47:43 <ab9rf> mauke: the latter is much faster than trying to compute the number of utf-8 characters
01:47:46 <mauke> ab9rf: or I could just store the length directly
01:47:46 <Axman6> yes =)
01:47:51 <ab9rf> mauke: yes, true
01:48:02 <mauke> ab9rf: assuming by "length" you mean "numbers of codepoints", which is not useful
01:48:06 <mauke> or
01:48:14 <mauke> s/not useful/not always useful/
01:48:27 <ab9rf> mauke: indexing by the nth codepoint is probablyu easier in -16 than -8
01:48:29 <LordBrain> no, ideally it would be number of characters
01:48:51 <ab9rf> mauke: although obviously not as easy as in -32
01:48:51 <ab9rf> where it's trivial
01:49:03 <mauke> the other "lengths" people care about are number of grapheme clusters and width when displayed on screen
01:49:18 <LordBrain> meaning the codepoints which add decorations to previous or next characters should be subsumed.
01:49:42 <ab9rf> LordBrain: codepoints vs. glyphs?
01:49:48 <ab9rf> LordBrain: and now you get into the whole "canonical representation" mess
01:49:58 <ChristianS> ab9rf: i doubt that either utf-8 or utf-16 offers any inherent performance benefit in the general case
01:50:16 <ChristianS> utf-8 well generally need less memory (for western languages), but that alone is not a very compelling reason to switch
01:50:29 <ab9rf> ChristianS: it's goiing to be on the margins, but the reported difference in performnance is cosistent with it being on the margins
01:50:43 <ab9rf> hell, it might just be because the utf-16 implementation didn't do as many split reads
01:50:59 <LordBrain> well what happens when microsoft switches?
01:51:05 <mauke> haha
01:51:14 <mauke> hell freezes over
01:51:18 <ab9rf> LordBrain: microsoft uses about twenty five different encodings
01:51:28 <LordBrain> it uses ucs2 in system calls
01:51:41 <mauke> I thought it used UTF-16
01:51:42 <merijn> Pretty sure it uses utf16
01:51:50 <ab9rf> LordBrain: and recent versions of SQL and Exchange are UTF-8
01:51:52 <merijn> The filesystem is utf16 too
01:51:55 <LordBrain> oh well utf16 then
01:52:04 <LordBrain> i meant windows
01:52:08 <LordBrain> but thats a good point
01:52:21 <LordBrain> it shows that microsoft is already partly abandoning that format
01:52:44 <mauke> who mentioned interoperability with C libraries like icu?
01:52:58 <mauke> because I've never used a C library that works with UTF-16
01:53:15 <mauke> it was all "don't care" or UTF-8
01:53:22 <LordBrain> c libraries written for windows might have chosen utf16 for compatibility with the system calls used on windows, but obviously utf-8 is dominant on most platforms
01:53:57 <Axman6> the text library mentions that you should use the text-icu package for many tasks
01:55:10 <ab9rf> well, in SQL either UTF-8 or UTF-16, depending on whether you use char/varchar or nchar/nvarchar
01:55:10 <ab9rf> and of course this can be changed on a database-by-database basis with adminisrative configurations
01:55:22 <LordBrain> i bet most of the text library's users, if they were forced to code from scratch, would have chosen utf-8 over utf 16.
01:56:44 <ab9rf> also, NTFS is UTF-16, but of course FAT is "oem codepage" :)
01:56:56 <mauke> so far I've managed to avoid Text on the basis of UTF-16 being an abomination
01:57:08 <merijn> mauke: You'd rather use String? >.>
01:57:27 <mauke> ByteString.Char8
01:57:32 <kqr> this is probably a silly question but how does ghcjs work? I mean in the sense of where does its ghc part end and where does the js part begin? does it compile ghc core to js or some other intermediary representation?
01:57:41 <kqr> just asking out of curiosity
01:57:53 <LordBrain> yes mauke that's what all the utf-16 opposition does, but that is not really ideal, that we have an entirely different interface to program to.
01:57:58 <merijn> mauke: ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ
01:58:21 <merijn> kqr: ping luite and ask him? He's usually around
01:58:28 <mauke> merijn: it's nicer than using C :-)
01:58:51 <mauke> (if I want a language with great unicode support, I use Perl)
01:59:08 <merijn> mauke: tbh, text's unicode support is pretty impressive
01:59:08 <LordBrain> its flexible i find kqr, you can compile to native code, or to js, i do not know if the native code uses js implementation internally, probably does.
01:59:59 <kqr> luite, hey! out of curiosity, what's the idea behind how ghcjs works? does it consume ghc core and compile that to javascript or where does it "take over" from GHC?
02:00:09 <kqr> merijn, good suggestion
02:00:25 <kqr> LordBrain, interesting. i've never used it (mainly because of a lack of reason to), just heard good things about it
02:00:28 <Chathurga> My guess would be it comes in in the same place the C code gen comes in?
02:00:37 <merijn> Chathurga: Which C code gen?
02:00:48 <merijn> Chathurga: GHC hasn't shipped with C code generation for ages
02:00:51 <ab9rf> i have been knoiwn to use bytestrings
02:00:51 <ab9rf> i've not had any complaints with text's unicode support
02:00:58 <Chathurga> Oh damn, didn't know that
02:01:07 <merijn> Chathurga: The C backend is completely bitrotted and only kept for potential future ports to different architectures
02:01:11 <Chathurga> I thought some parts still were
02:01:13 <Chathurga> Ah
02:01:22 <shachaf> kqr: ghcjs generated from Core last I heard.
02:01:32 * hackagebot streaming-commons 0.1.9.1 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.9.1 (MichaelSnoyman)
02:01:49 <merijn> Chathurga: You might be confusing things with Cmm (a variant of C--) which is almost entirely, but not completely, unlike C :)
02:02:19 <LordBrain> text is a fine library, thats not the point, the issue is the proliferation of an inferior format in favor of one that is superior. a lot of programmers don't really like that kind of behavior, even if they put up with it for pragmatic or technical reasons.
02:02:25 <merijn> Cmm basically was designed as portable ASM before LLVM was started and fills the role of LLVM ASM in the llvm backend
02:02:31 <Axman6> the runtime system is (mostly) written in C, but that's a rather small thing to port (though not trivial)
02:02:51 <merijn> LordBrain: How is it superior if it's not faster?
02:03:09 <ab9rf> heh
02:03:26 <ab9rf> never let pragmatic concerns get in the way of a solid ideological rant :)
02:03:42 <Chathurga> Ah, I think Axman6's point is what I was confused with
02:04:14 <mauke> merijn: speed isn't everything
02:04:18 <kqr> shachaf, that's what I suspected, thanks :)
02:04:21 <merijn> mauke: Sure
02:05:01 <merijn> mauke: But I haven't seen any argument against text's use of utf16 other than "I prefer working with uf8", but that's completely irrelevant as text's internals are opaque and you never deal with utf16
02:05:27 <mauke> merijn: re: text's unicode support, it doesn't seem to have much of it, except for case conversion
02:05:45 <merijn> mauke: Most of the locale specific stuff is in text-icu
02:06:01 <mauke> and broken justify/center functions
02:06:08 <jonazzzzz> can anyone tell me the steps how this is executed: (++) <$> Just "Test" <*> Just "ok", i know <$> and <*> are left associative and same priority
02:06:12 <LordBrain> well first of all, i do not accept that it is not faster, if utf-8 is objectively slower, that needs to be proven with more than the anecdotal evidence that someone did a utf-8 version of the library that was slower. Secondly, utf8 has a lot of very nice properties, it can encode every character, and old search functions written for 8 bit ascii never fail.. a pretty decent achievement.
02:06:34 <mauke> LordBrain: all UTFs can encode every characters
02:06:40 <mauke> that's not a big thing
02:06:45 <mauke> s/s$//
02:06:51 <merijn> LordBrain: utf16 can also encode every character
02:07:09 <merijn> LordBrain: You can't call C functions on Text anyway, so support for 8bit ascii is irrelevant
02:07:10 <LordBrain> so
02:07:22 <mauke> jonazzzzz: (<*>) ((<$>) (++) (Just "Test")) (Just "ok")
02:07:47 <merijn> LordBrain: And the work on utf8 was overseen by some of the haskell performance wizards, so if they can't make it fast, I don't think it's worth more effort
02:07:52 <ab9rf> as far as i am concerned, whether one uses UTF-8 or UTF-16 depends on which has better performance.
02:07:52 <LordBrain> i don't know what you mean by that merijn
02:08:05 <merijn> LordBrain: What I mean by what?
02:08:13 <merijn> Not being able to call C functions on Text?
02:08:28 <jonazzzzz> what is the  (<*>) equivalent in with these types, can't figure it out
02:08:32 <mauke> merijn: AFAIK they did make it fast
02:08:35 <merijn> Text is not a supported FFI format, therefore it can't be passed to FFI functions and thus not to any C functions
02:08:41 <jonazzzzz> Its applicatve Maybe?
02:08:41 <ab9rf> jonazzzzz: <*> equivalent?
02:08:55 <merijn> mauke: But not sufficiently faster than utf16 to be worth the interoperability hassle with text-icu
02:09:00 <mauke> jonazzzzz: Just f <*> Just x = Just (f x); _ <*> _ = Nothing
02:09:04 <merijn> jonazzzzz: You might like lambdabot's asAppliedTo
02:09:18 <LordBrain> but taht is a draw back of using utf-16, if htey used utf-8 they could have supported that as well as bytestring.char8.
02:09:18 <merijn> :t (<*>) `asApliedTo` Nothing
02:09:19 <lambdabot>     Not in scope: ‘asApliedTo’
02:09:19 <lambdabot>     Perhaps you meant ‘asAppliedTo’ (line 154)
02:09:34 <jonazzzzz> yes but ((<$>) (++) (Just "Test"))is not wrapped in Just ?
02:09:37 <merijn> :t (<*>) `asAppliedTo` Nothing
02:09:38 <lambdabot> Maybe (a -> b) -> Maybe a -> Maybe b
02:09:47 <mauke> jonazzzzz: yes, it is
02:10:03 <merijn> LordBrain: No, becayse you can't pass ByteString to C functions either
02:10:11 <merijn> LordBrain: You need to convert to "Ptr CChar"
02:10:18 <Axman6> > (++) <$> Just "Hello" <*> Just ", world"
02:10:19 <lambdabot>  Just "Hello, world"
02:10:28 <LordBrain> well your conversion isnt o(n) tho
02:10:31 <merijn> LordBrain: Neither ByteString nor Text are contiguous in memory
02:10:36 <mauke> merijn: unsafeUseAsCCString
02:10:53 <merijn> mauke: Right, which should fail if your string is more than one chunk, no?
02:10:54 <LordBrain> there are low level bytestring functions which let you get at contiguous chunks
02:11:01 <mauke> http://hackage.haskell.org/package/bytestring-0.10.4.1/docs/Data-ByteString-Unsafe.html#g:3
02:11:07 <mauke> merijn: there's only one "chunk"
02:11:17 <ab9rf> there are often c library functions that operate on wide characters
02:11:18 <jonazzzzz> hmm ok i get it, but what i don't get is how u rewrite it to  (<*>) ((<$>) (++) (Just "Test")) (Just "ok")
02:11:24 <LordBrain> if its strict, there is only one chunk, so that is contiguous
02:11:25 <ab9rf> which usually ends up being UTF-16
02:11:35 <merijn> mauke: Lazy definitely has multiple chunks, afaik so does strict
02:11:47 <ab9rf> strict doesn't mean one chunk
02:11:51 <mauke> merijn: then what's the point of "strict"? :-)
02:12:00 <LordBrain> look under the hood
02:12:02 <merijn> mauke: The chunks always exist, instead of being thunks
02:12:04 <mauke> jonazzzzz: x + y = (+) x y
02:12:14 <mauke> merijn: yeah, what's the point of that?
02:12:18 <merijn> mauke: Otherwise concat would be O(n)
02:12:23 <merijn> mauke: Cheap concat/split
02:12:47 <mauke> concat is O(n)
02:12:54 <merijn> afaik strict bytestring is a Seq of chunks
02:13:04 <mauke> a ByteString is literally a pointer and 2 ints
02:13:21 <eXeC64> merijn: Since you'd probably know this: Is all strictness implemented with 'seq'?
02:13:50 <mauke> eXeC64: no
02:13:56 <LordBrain> i don't think he meant the same 'seq' as you are referring to eXeC64
02:13:58 <eXeC64> What other methods are there?
02:14:06 <merijn> eXeC64: There's bangs (strictness annotation) and bang patterns too
02:14:06 <mauke> eXeC64: 'null' is strict without using seq
02:14:11 <eXeC64> LordBrain: I know, it was just a question related to strictness
02:14:18 <LordBrain> ok
02:14:29 <merijn> eXeC64: Although all of those can be rewritten to 'seq', pattern matches are also "strict" in that they force thunks
02:14:30 <eXeC64> merijn: I assumed bangs were syntactic sugar for seq
02:14:50 <merijn> eXeC64: Mostly they are, I think
02:15:07 <LordBrain> there's # for unboxed things too
02:15:45 <merijn> That's just a naming convention
02:15:53 <merijn> The # itself doesn't actually do anything
02:16:04 <merijn> It's just convention to name all unboxed types/values with #
02:16:11 <eXeC64> @doc null
02:16:11 <lambdabot> null not available
02:16:15 <eXeC64> :t null
02:16:16 <lambdabot> [a] -> Bool
02:16:33 * hackagebot HaskellNet 0.4.1 - Client support for POP3, SMTP, and IMAP  http://hackage.haskell.org/package/HaskellNet-0.4.1 (lemol)
02:16:39 <eXeC64> > null [1,2,3]
02:16:40 <lambdabot>  False
02:16:42 <eXeC64> > null []
02:16:43 <mauke> > null undefined
02:16:44 <lambdabot>  can't find file: L.hs
02:16:44 <lambdabot>  True
02:16:46 <mauke> > null undefined
02:16:48 <lambdabot>  *Exception: Prelude.undefined
02:16:52 <merijn> mauke: ok, you appear to be right about strict ByteString
02:16:56 <mauke> null _|_ = _|_
02:16:58 <merijn> mauke: But then, I hardly use strict
02:17:02 <eXeC64> > null []
02:17:03 <lambdabot>  True
02:17:17 <LordBrain> what about things like (# 3, 4 #), perhaps that is only in core
02:17:24 <merijn> unboxed tuple
02:17:36 <merijn> You can write those if you enable a few extensions
02:17:53 <merijn> But you can't pass those as values
02:18:04 <merijn> Since they represent return values in registers
02:18:58 <jonazzzzz> ok, but why does let x = fmap (++) ["hello"], and x <*> ["world"] produce helloworld and not worldhello?, so fmap (++) ["hello"] gives "hello"++ instead of ++"hello"?
02:19:31 <merijn> jonazzzzz: "(++) x" is "\x y -> x ++ y"
02:19:46 <merijn> or rather, I guess "(++) == "\x y -> x ++ y"
02:20:02 <jonazzzzz> oh ok haha ^^
02:20:03 <opqdonut> ((++) "hello") "world"
02:20:03 <jonazzzzz> thanks
02:20:07 <opqdonut> > ((++) "hello") "world"
02:20:08 <lambdabot>  "helloworld"
02:20:13 <merijn> "hello"++ is *not* the same as ("hello"++)
02:20:39 <merijn> The latter is section syntax, which is explicitly different from just prefix application of operators
02:21:36 <jonazzzzz> ok ty :D
02:21:37 <LordBrain> merijn, um... could you better quallify that, by the meaning of different or same here
02:22:04 <barrucadu> :t ("hello"++)
02:22:05 <lambdabot> [Char] -> [Char]
02:23:26 <LordBrain> "hello" ++ x will certainly evaluate to the same value as does ("hello" ++) x
02:23:37 <LordBrain> hence the request for clarification
02:25:15 <LordBrain> an optimizing compiler could choose to turn one into the other or vice versa, as far as i can see.
02:28:07 <LordBrain> how much do we consider what is done as part of what is coded, we're in a high level language, so i think the end result is what matters, although, perhaps we should allow users more flexibility on how high or low level they want their haskell to be.
02:30:49 <merijn> LordBrain: Right, but without 'x' the latter is a parse error
02:30:57 <merijn> eh
02:30:59 <merijn> the former
02:31:17 <LordBrain> in practice, i think programmers do want the freedom to get lowlevel, as in, do exactly what i say even if you think it is stupid! but its ambiguous in haskell because i think we choose ways of writing things for the sake of readability even when we know they rely on optimizations to be performant, and so what is "what i say" ?
02:31:46 <LordBrain> for example, stream fusion
02:31:54 <merijn> LordBrain: Anyone who thinks that's not the case in "lower" language is talking nonsense too
02:32:01 <merijn> "C is high level ASM" <- lol
02:32:08 <LordBrain> well, there is asm itself
02:32:14 <merijn> Hell, even writing ASM you have *no* clue what the CPU is doing
02:32:31 <LordBrain> hmmmm, interesting point
02:32:46 <merijn> Once you VTune your code you realise none of the stuff you though of is a problem
02:32:48 <hyPiRion> Haskell is high level ASM too, for some definition of "high level". =)
02:32:56 <merijn> "branches are expensive!"
02:33:08 <merijn> Turns out, branches are basically free, as long as you make the predictable
02:33:12 <LordBrain> nevertheless, you still may want control over how deep you go down that rabbit hole, as in, how many different compilers are you trusting etc...
02:33:41 <merijn> LordBrain: I have a fun anecdote for you
02:33:53 <merijn> LordBrain: Also, note the comments about what icc was doing at the bottom: https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array
02:34:04 <merijn> LordBrain: Then tell me you still know what your compiler is doing :p
02:34:47 <LordBrain> there are means of disabling branch prediction and caching and so forth, i think... tho i have not done assembly on that order in quite some time.
02:35:05 <merijn> Why would you ever wanna disable those?
02:35:21 <merijn> You'll know what your code is doing, but your code it'd be slow as hell, so you still lose :)
02:35:35 <LordBrain> um, right, its a trade-off
02:36:37 <LordBrain> i read a paper recently where they disabled those because they were trying to measure the effect of their software architectural decisions, and having the cpu be more predictable was a benefit.
02:37:21 <hyPiRion> I'd guess you could argue it's important for some real time systems?
02:37:56 <LordBrain> yeah, even if just to meet gaurantee requrierments required by law etc,
02:39:39 <LordBrain> anyway, in then end "because someone wants to do it" is actually a good enough reason.
02:40:00 <LordBrain> unless there is some drawback to counter act it
02:41:33 <LordBrain> having a language that is capable of scaling that way is nice. on hackage there is a 6502 assembler monad, it actually would be nice to have something like that for all the assembly languages.
02:42:36 <LordBrain> in fact, i think,  we should be able to get low level to the point where c is completely unnecessary, even when boot strapping a new platform.
02:43:45 <LordBrain> maybe its not in hackage actually, but on github
02:45:04 <LordBrain> something i ate is not sitting well in my digestive system
02:46:34 <LordBrain> technically, llvm provides an alternative means than c to bootstrap a new platform already
02:46:34 * hackagebot digestive-functors-aeson 1.1.13 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.13 (OliverCharles)
02:47:07 <Peaker> haha, I was just considering suggesting digestive-functors as a solution to LordBrain's digestive problems
02:47:21 <Peaker> I guess ocharles_ was ahead of me
02:47:34 <ocharles_> Peaker: :D
02:50:54 <jle`> ha
02:51:09 <jle`> i should consider uploading packages to hackage for punchlines >_>
02:51:12 <jle`> s/should/should not
02:53:12 <KoreaPanda> hello, everyone
02:53:19 <KoreaPanda> i'm ask something
02:53:26 <KoreaPanda> nono i ask something
02:54:11 <KoreaPanda> insert :: (a -> a -> Bool) -> a -> [a] -> [a]
02:54:12 <KoreaPanda> insert pred x [] = [x]
02:54:12 <KoreaPanda> insert pred x (y:ys)
02:54:12 <KoreaPanda>     | pred x y = (x:y:ys)
02:54:12 <KoreaPanda>     | otherwise = y:(insert pred x ys)
02:54:35 <Axman6> please don't paste more than a line or two of code into the channel, use lpaste:
02:54:39 <Axman6> @where lpaste
02:54:39 <lambdabot> http://lpaste.net/
02:55:00 <KoreaPanda> oh thanks
02:55:02 <mauke> and there's a good reason for that!
02:55:19 <mauke> because while we're talking, the code keeps scrolling off the screen
02:55:55 <mauke> (not to mention it's harder to copy/paste code from the channel)
02:55:58 <KoreaPanda> i'm sorry about that..
02:56:08 <Axman6> KoreaPanda: what is your question?
02:56:36 <Axman6> KoreaPanda: People sometimes paste a lot more code than that and it is very annoying =)
02:57:08 <KoreaPanda> pred x y = (x:y:ys) << what means this para?
02:57:41 <mauke> which part is unclear?
02:58:01 <Axman6> | foo = ... mean: if the expression foo is True, then the function should return the value in ...
02:58:12 <mauke> ^ this is called "guards"
02:58:45 <Axman6> > let f x | even x = "Even" | odd x = "Odd" | otherwise = "I have no idea what's happening" in map f [1..5]
02:58:46 <lambdabot>  ["Odd","Even","Odd","Even","Odd"]
02:59:07 <mauke> 'a | b = c | otherwise = d' is like 'a = if b then c else d'
02:59:17 <KoreaPanda> hmm...
02:59:22 <mauke> and yes, that looks very confusing without formatting
02:59:29 <Axman6> yeah
02:59:36 <Renegade-x> Who like this game? https://www.youtube.com/watch?v=kS-6em18g90
02:59:59 --- mode: ChanServ set +o mauke
02:59:59 --- kick: Renegade-x was kicked by mauke (what?)
03:00:08 <jle`> KoreaPanda: (:) is cons
03:00:14 <Axman6> mauke: heh
03:00:20 <jle`> :t (:)
03:00:21 <lambdabot> a -> [a] -> [a]
03:00:24 <jle`> > 1 : [2,3,4]
03:00:25 <lambdabot>  [1,2,3,4]
03:00:31 <mauke> > 4 : [1, 1, 1]
03:00:32 <lambdabot>  [4,1,1,1]
03:02:00 --- mode: mauke set -o mauke
03:02:47 <KoreaPanda> pred x y (x:y:ys) << what pred's role?? i have knowned pred play precede num..
03:03:00 <mauke> pred is a function parameter
03:03:12 <mauke> looks like it stands for "predicate"
03:03:19 <mauke> it's defined in the line above
03:03:30 <Axman6> in this case, "pres" is short for "predicate", a function which returns a Bool
03:03:49 <mauke> you could rename it to "f" or whatever
03:07:32 <vlatkoB> Would there be a speed gain if pattern matching (in function) is ordered by mostly used constructor? f MostUsed =..., then f LeastUsed = ...
03:08:04 <Axman6> I've wondered the same thing but haven't found an answer
03:08:49 <Axman6> KoreaPanda: is it clearer now? We can help more if you would like
03:09:34 <tdammers> vlatkoB: don't know, but my gut feeling says "yes"
03:09:48 <tdammers> vlatkoB: considering that the compiler cannot naively reorder patterns
03:11:35 * hackagebot uuagc 0.9.52 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.52 (JeroenBransen)
03:13:33 <eXeC64> How does pattern matching actually work, implementation wise?
03:14:06 <Axman6> one way is using pointer tagging
03:15:26 <MP2E> eXeC64: it's simply syntax sugar for case statements. There's an example here http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html
03:15:29 <Axman6> since objects are always word aligned, the bottom 3 or 4 bits of the pointer can be used for recording info like which constructor is being pointed to. the header of the object being pointed to also records it but having it in the pointer avoids needing to load the header to check
03:16:34 <eXeC64> Axman6: Hmm, neat.
03:16:42 <eXeC64> MP2E: Thanks for the link, I'll have a read.
03:17:18 <MP2E> pointer tagging is definitely the correct answer as well, just on a lower level :P
03:17:58 <KoreaPanda> Axman6 , thank you.. but 'pred' pattern matching is Enum a => a -> a & Meaning is the predecessor of a value.
03:18:56 <KoreaPanda> that 'pred' mean 'predicate'?
03:19:13 <Axman6> in that function, pred means predicate
03:19:24 <Axman6> it's a function that you give to insert
03:19:38 <KoreaPanda> hmm.... i'm so confused..
03:20:04 <Axman6> insert pred x (y:ys) <- arguments to insert are pres, x and a list (called y:ys here)
03:20:10 <Axman6> pred*
03:20:33 <Axman6> KoreaPanda: do you understand the type of insert? insert :: (a -> a -> Bool) -> a -> [a] -> [a]
03:21:34 <KoreaPanda> Axman6, I understand that. Thanks!
03:22:37 <Axman6> KoreaPanda: just to be clear, pred is a function with type (a -> a -> Bool)
03:23:20 <KoreaPanda> pred are two performence?
03:23:27 <KoreaPanda> one is the predecessor of a value.
03:23:42 <KoreaPanda> the other is a -> a -> Bool?
03:23:53 <KoreaPanda> isn't that?
03:24:14 <KoreaPanda> i can't speak english well... sorry..
03:24:19 <Guest35841> anybody could please explain difference between mapM and traverse in Data.Traversable apart from one has monad and other has applicative type constraint?
03:25:15 <Axman6> KoreaPanda: no, the function pred in insert is different to the usual pred which has type Enum a => a -> a
03:26:42 <KoreaPanda> Axman6, hmm.. then that pred is new defined function?
03:26:56 <Axman6> > let insert p x [] = [x]; insert p x (y:ys) | p x y = y:x:ys | otherwise = y : insert p x ys in insert (<) 5 [1..10]
03:26:57 <lambdabot>  [1,2,3,4,5,6,5,7,8,9,10]
03:27:15 <KoreaPanda> ok, and?
03:27:21 <Axman6> lambdabot?
03:28:43 <Axman6> > 1+1
03:28:45 <lambdabot>  2
03:29:05 <Hijiri> Guest35841: traverse works on any Traversable, while mapM only works on lists
03:29:12 <KoreaPanda> aha...
03:29:26 <Axman6> -_-
03:29:27 <Guest35841> @type T.mapM
03:29:28 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
03:29:31 <Hijiri> oh
03:29:33 <Hijiri> didn't see that
03:29:38 <Hijiri> I don't think there is a difference
03:29:55 <Hijiri> provided the things with Monad implement Applicative properly
03:29:57 <Guest35841> it works on any travesavble, the only difference I see is the type of effect
03:30:12 <Guest35841> one is monadic other is applicative
03:30:26 <Hijiri> If something is a Monad, it's Applicative instance should match
03:30:38 <Hijiri> so if mapM and traverse behave differently that's a bug
03:30:45 <Hijiri> with the typeclass instances
03:30:50 <Axman6> I can't tell if irc is working for me... is anyone able to read this?
03:30:53 <Hijiri> yes
03:31:04 <Hijiri> ^ Axman6
03:31:07 <mauke> Axman6: no
03:31:24 <Guest35841> So for some historical reasons not every monad is applicative
03:31:48 <KoreaPanda> Axman6, ok i can read your chat
03:31:55 <Hijiri> yes, but they will be starting GHC 7.10
03:31:58 <MP2E> but GHC 7.10 fixes that, Monad will require the thing to be an Applicative first
03:32:31 <Guest35841> yup, but Data.Traversable is quiet old
03:32:33 <Guest35841> :)
03:32:58 <MP2E> it'll still be a compiler error
03:33:03 <MP2E> compile-time error *
03:33:14 <Guest35841> is it warning or error?
03:33:20 <MP2E> error, it's a warning in GHC 7.8
03:33:24 <Hijiri> it's already a warning
03:33:44 <Guest35841> I am asking that because I wanted to implement traverse in a impure languge.
03:33:56 <Guest35841> without higher kinds
03:34:52 <Axman6> Hijiri: woah, super weird, nothing was getting back to me, had to reconnect to freenode
03:35:18 <Hijiri> and then you got the messages all at once?
03:35:39 <Axman6> yeah, after reconnecting
03:35:53 <KoreaPanda> kkkkkkk
03:36:07 <Axman6> I'm guessing the server was lagging behind the rest of the network, because irssi wasn't showing any lag
03:36:26 <Axman6> KoreaPanda: Do you understand the definition of map?
03:36:28 <Axman6> @src map
03:36:28 <lambdabot> map _ []     = []
03:36:28 <lambdabot> map f (x:xs) = f x : map f xs
03:36:59 <KoreaPanda> yes i do
03:37:34 <Axman6> KoreaPanda: so you understand that f is a function (any function!) that is passed to map?
03:37:56 <Axman6> because pred is also a function that you pass to insert
03:38:08 <LordBrain> well, the type of the input has to match the type of x, so not exactly any function
03:38:17 <LordBrain> but i guess i'm being a pedant
03:38:23 <Axman6> with map, f has type a -> b, with insert, pred has type a -> a -> Bool
03:39:32 <notdan> Does anyone know the best way to do pipes branching in pipes-4?
03:39:40 <notdan> Ultimately, I wanted to do something like: http://pastebin.com/XXxRz8zw
03:39:56 <Axman6> so you can use things like (<), (<=), (/=), or more interesting things like: longer a b = length a < length b (now you can use: `insert longer "Hello" ["hi", "hell", "good day"]` to get ["hi", "hell", "hello", "good day"])
03:40:19 <KoreaPanda> Axman6, oh! okok thank you very much
03:40:32 <KoreaPanda> Axman6, you are very kind! thanks!
03:40:49 <KoreaPanda> Axman6, I really understand that.
03:40:59 <Axman6> KoreaPanda: it is confusing that the name pred is being used when pred already exists in the Prelude, so I understand your confusion =)
03:46:45 <alpounet> notdan: one way would be with pipes-concurrency
03:47:21 <alpounet> notdan: it also depends on how you want your items to be dispatched to p1 >-> p2 and p3
03:47:36 <notdan> Hm, but there is only one source and one sink.. maybe I should try it
03:47:54 <notdan> alpounet: it should be an AND dispatch, .i.e. values should go to the both pipes
03:48:06 <notdan> and, let's say, for example, the second pipe can get a priority
03:51:00 <alpounet> notdan: you probably should ask on the pipes maailing list but i'd probably just go with pipes-concurrency (and have done so before)
03:51:00 <aloiscochard> hey folks, I'm having an issue putting one of my app in stackage, if anyone have an idea that would be great:
03:51:01 <aloiscochard> https://github.com/fpco/stackage/pull/404#issuecomment-69904866
03:51:17 <notdan> alpounet: thanks, I'll w=check it out
04:51:39 * hackagebot lambdacms-core 0.0.7.3 - Core CMS extension for Yesod apps  http://hackage.haskell.org/package/lambdacms-core-0.0.7.3 (cies)
04:56:39 * hackagebot lambdacms-media 0.0.2 - Media CMS extension for Yesod apps  http://hackage.haskell.org/package/lambdacms-media-0.0.2 (cies)
05:02:47 <dropp> hey hey
05:02:56 <rnat> is haskell-src-exts broken?
05:04:30 <vanila> Can I derive an XML show ??
05:04:36 <vanila> I need my ADT to print out XML
05:05:10 <tdammers> vanila: why would you want to use show for that?
05:05:21 <bergmark> vanila: yes, using for example hxt
05:05:24 <tdammers> vanila: why not toXML or sth?
05:05:31 <vanila> cheers bergmark!
05:07:21 <bergmark> vanila: or i should've said, regular-xmlpickler
05:07:33 <vanila> oh perfect !
05:13:04 <vanila> so how do I acutally use this? :S
05:13:12 <vanila> for some reasong im scrolling through http://dreixel.net/research/pdf/ladgrtr.pdf
05:13:45 <vanila> I suppose I somehow invoke this ? http://hackage.haskell.org/package/regular-0.3.4.4/docs/Generics-Regular-TH.html
05:13:53 <vanila> and it creats a regular instance so that the XML thing can do stuff
05:14:49 <vanila> any example code
05:17:27 <Ferdirand> Hello #haskell, what is the default fixity of `` ?
05:17:41 <Ferdirand> :info gives fixity for some symbols, i see, but not others
05:18:16 <opqdonut> it doesn't really matter since you can't have an expression inside ``, right?
05:18:26 <Ferdirand> well i mean
05:18:32 <Ferdirand> x `f` y `g` z
05:18:43 <opqdonut> oh
05:18:48 <Ferdirand> or is that invalid ?
05:18:51 <bitonic> Ferdirand: it depends on the function.  you can specify fixities for individual functions
05:18:58 <opqdonut> yeah, you can define it per function
05:19:03 <Ferdirand> yes, i saw that
05:19:04 <bitonic> e.g. `:info elem' gives me `infix 4 `elem`'
05:19:09 <Ferdirand> just wondering what happens if i don't
05:19:12 <bitonic> `:info id' doesn't
05:19:18 <bitonic> I think it's just the default fixity
05:19:23 <opqdonut> but default is infixl 9
05:19:24 <bitonic> infixl 9, iirc?
05:19:27 <opqdonut> yeah
05:19:29 <Ferdirand> yeah, in hindsight that was a stupid question
05:19:33 <Ferdirand> sorry :)
05:19:59 <Ferdirand> but wait
05:20:00 <bitonic> not stupid at all
05:20:06 <vanila> deriveRegular ''Code "Code" -- somethingh like this? it's giving me multiple declarations of Code error though
05:20:59 <Ferdirand> ah duh i understand why i was confused now
05:21:09 <Ferdirand> 9 is the highest precedence
05:21:58 <bergmark> vanila: https://gist.github.com/bergmark/008cc596458503849c6c
05:21:59 <opqdonut> yes, binds tightest
05:22:03 <bitonic> Ferdirand: remember that fixities are just like types, they can be attached to any bound name
05:22:19 <bitonic> I think fixities are actually a pretty tricky corner of Haskell, so I don't think it's a stupid question ehe
05:22:22 <Ferdirand> you mean you can have local fixities ?
05:22:29 <bitonic> Ferdirand: yes
05:22:34 <Ferdirand> awesome :o
05:22:43 <bitonic> `let elem x y = ... in foo `elem` bar'
05:22:53 <bitonic> I believe the fixity of `elem` inside will be `infixl 9'
05:23:11 <bitonic> even if the top-level `elem' has fixity `infix 4'
05:23:21 <bitonic> you cannot change that though
05:23:36 <Ferdirand> well that's less awesome than expected
05:23:40 <bitonic> ehe.
05:23:50 <bitonic> what you can nest is really arbitrary in haskell
05:23:56 <bitonic> why can't I have data-types in `where' clauses?
05:24:20 <bitonic> languages like Rust and Agda are starting to change that
05:24:29 <vanila> thanks a lot bergmark, I got it working based on that
05:24:39 <tdammers> bitonic: because Haskell is old :D
05:24:46 <bitonic> yeah.  Haskell is old.
05:24:58 <tdammers> another thing I would love having is scoped instances
05:25:06 <SparkySparkyBoom>  
05:25:10 <bitonic> oh yeah
05:25:10 <SparkySparkyBoom> hi
05:25:11 <tdammers> foo = bar where instance Foo Bar where ...
05:25:18 <tdammers> that'd be so cool
05:25:19 <bitonic> that is thorny in general
05:25:29 <tdammers> especially for typeclasses like ToJSON
05:25:35 <bitonic> I'd like a clear separation between canonical structures and coherent type-classes
05:25:57 <tdammers> alternatively, let's throw out everything we have and use lisp :P
05:25:57 <SparkySparkyBoom> how would i do IO (IO a) -> a
05:26:05 <tdammers> SparkySparkyBoom: uh, just like that?
05:26:10 <SparkySparkyBoom> not unsafe
05:26:16 <bitonic> SparkySparkyBoom: you can't
05:26:24 <tdammers> ah, no
05:26:28 <bitonic> `IO (IO a) -> IO a' is easy though
05:26:30 <tdammers> you can have IO (IO a) -> IO a
05:26:36 <SparkySparkyBoom> bitonic: that's what i mean
05:26:41 * hackagebot transformers-abort 0.5.0.1 - A better error monad transformer  http://hackage.haskell.org/package/transformers-abort-0.5.0.1 (MikhailVorozhtsov)
05:26:46 <bitonic> SparkySparkyBoom: hint: use >>=
05:26:51 <SparkySparkyBoom> ah
05:26:56 <SparkySparkyBoom> instead of the do notation
05:26:57 <bitonic> don't look too far in `base' otherwise you'll find the function
05:27:00 <SparkySparkyBoom> thank you
05:27:05 <bitonic> you can also use `do'#
05:27:14 <pantsman> :t join
05:27:15 <lambdabot> Monad m => m (m a) -> m a
05:27:18 <tdammers> aww
05:27:39 <tdammers> my : key was itching already
05:27:48 <bitonic> pantsman: you ruined it!  ehe
05:28:06 <pantsman> sorry! :(
05:30:49 <pantsman> note, I rarely find the need to use join; most times it can be refactored to include a >>= somewhere instead of a fmap
05:31:50 <dav1d> I dont understand this function http://vp.dav1d.de/4XjTD?hs ? any help? why is (p [1,3]) not 7? p [3] + 1 + p[3] -> (p [] + 3 + p[]) + 1 (p [] + 3 + p []) -> (0 + 3 + 0) + 1 + (0 + 3 +0) = 7, but haskell says result is 3
05:33:58 <pantsman> dav1d: p [1,3] = p [3] = p [] + 3 + p [] = 0 + 3 + 0 = 3
05:34:21 <dav1d> pantsman: why is p[1,3] = p[3] ?
05:34:30 <pantsman> from the 1st clause
05:34:33 <dav1d> ohhhhh
05:34:36 <dav1d> the first one matches?
05:34:50 <bitonic> yeah, with l = []
05:35:02 <dav1d> and one element lists are matched by the second?
05:35:04 <pantsman> yes, also, the 3rd one will never match, because the 2nd one will also match [e] as (e:[])
05:35:30 <pantsman> (which is what you just asked, I was already typing that :P)
05:35:38 <dav1d> damn it, tricky, thanks!
05:35:56 <Reite> Is there any other library than haxml for converting XSD-definitions to haskell types?
05:36:23 <dav1d> pantsman: the [2, 1, 3]thing, the 2nd is called right?
05:36:34 <dav1d> becase a <= b doesnt match?
05:36:36 <bitonic> Reite: you want to write the XML in the haskell source?
05:36:41 * hackagebot arbtt 0.9 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.9 (JoachimBreitner)
05:36:53 <pantsman> dav1d: yes
05:37:36 <dav1d> thanks, awesome
05:39:10 <Reite> bitonic: Im not sure what you mean? HaXml has a tool for converting .XSD definitions to haskell datatypes, but it doesnt support restrictions on simpleTypes, so it doesnt work for me, Im looking for an alternative.
05:39:31 <bitonic> Reite: sorry, I read hxl.  disregard my message :)
05:39:46 <Reite> Allright, np :)
05:43:49 <vanila> so I have a "pickler" I think? How do I get the actual XML
05:44:11 <vanila> im lost..
05:47:12 <luite> kqr: it uses STG rather than Core, which is very similar to Core after it has been run through the coreprep pass, but the AST nodes are annotated with contexts (free variables) and escape analysis has been done, some Let nodes have been replaced by LetNoEscape
05:47:17 <bergmark> vanila: http://hackage.haskell.org/package/hxt-pickle-utils-0.1.0.2/docs/Text-Xml-Pickle.html
05:47:25 <vanila> thank you
05:48:29 <cybercap> Hello! If I was about to create a data structure for a circular list holding integer values, where it is possible to go from the current node in the list to the previous node and from the current node to the next node in the list. Would this data structure work? data CL = Empty | Node Int CL CL? At first I thought it would suffice but I dont get how I would be able to insert a single value in the l
05:48:29 <cybercap> ist... I ended up using a haskell list instead to represent the circular list but I still wonder if it would be possible to use the data structure I described
05:48:56 <cybercap> ...insert a single value in the list... I ended up using a haskell list instead to represent the circular list but I still wonder if it would be possible to use the data structure I described
05:49:31 <cybercap> Sorry for the long message and the duplicated part
05:49:54 <Axman6> cybercap: this is the classic "tying the knot" example. one sec
05:49:59 <luite> kqr: coreprep is a core to core transformation at the end of the core pipeline to bring the core to A-normal form, after that everything that needs to allocate is a let binding (or some primop that does it internally), all arguments are trivial (literals or identifiers), all primops and data constructors applications are fully saturated
05:51:06 <Axman6> cybercap: https://www.haskell.org/haskellwiki/Tying_the_Knot
05:51:30 <cybercap> Thanks! I will look into it!
05:52:18 <Axman6> cybercap: be warned though, if you want to change any of the elements in the list, it will be an O(n) operation
05:55:51 <cybercap> Axman6: Okay, it was as easy as that. I ended up using this structure instead data CL = Empty | List Int [Int]
05:56:09 <cybercap> where the Int arg held the position in the list
05:57:55 <Axman6> where's the fun in that =)
05:58:27 <cybercap> haha. True. But it solved the assignment :)
06:00:44 <Axman6> but did you learn anything?
06:01:06 <cybercap> no, but now I did:)
06:06:15 <dgpratt> regarding this http://www.yesodweb.com/page/quickstart is there a good reason why the build tools are not installed in the sandbox?
06:06:57 <bergmark> dgpratt: you can do that, but then you need to add it to PATH while working in that sandbox
06:07:10 <dgpratt> bergmark, that makes sense, thanks
06:08:19 <dgpratt> given how many packages yesod pulls in, that seems like a minor inconvenience to try to head off major package conflicts later on
06:09:55 <tdammers> heh, the sheer amount of stuff yesod pulls in is one of the reasons I'm not using it :P
06:12:20 <kqr> luite, ah, that makes some sense. thanks. I had forgot about STG entirely
06:13:44 <dgpratt> fpcomplete has been talking about lts haskelll lately and I haven't quite figured out what it is -- is it just a blessed set of packages/versions that are still hosted on hackage?
06:13:53 <dgpratt> *haskell :)
06:14:14 <merijn> cybercap: You might wanna read up on zippers?
06:14:31 <merijn> cybercap: Indexing a list is really inefficient
06:15:24 <bergmark> dgpratt: it's basically just a file with constraints for the major version of packages, and only bugfix releases can be included in new realeses of that LTS, so as a user you won't receive any api breaking changes until you upgrade to the next lts
06:15:57 <cybercap> merijn: Are you talking about my list structure? But yes, I guess I should read a bit more about zippers.
06:16:11 <dgpratt> I see, thanks again bergmark
06:25:52 <Ferdirand> Okay, so i've broken my teeth trying to write a modular arithmetic integer lib which would carry the modulus along with the type system
06:26:02 <Ferdirand> so i'm trying a totally different approach: reader monad !
06:28:20 <Ferdirand> but now that it works, i'm wondering: what was the rationale (pun not intended) for not having a default fromRational x = numerator x / denominator x ?
06:28:34 <Ferdirand> also, what do the default implementations of (/) and recip do ?
06:28:42 <dgpratt> I saw something come up on...reddit(?) the other day about an experimental GHC installer for...Windows(?), but I can't seem to find it, does anyone know what I'm talking about?
06:29:14 <bergmark> dgpratt: https://github.com/fpco/minghc
06:30:01 <dgpratt> bergmark, you seem to have all the answers to my questions today :D
06:30:33 <dgpratt> maybe I should consult you on this C# code change I'm working on for work ;-)
06:31:19 <bergmark> the only thing i know about C# is that they prefix interfaces with `I' because that's nice?
06:31:29 <dgpratt> I suppose I should probably uninstall the HP before trying this...
06:32:08 <dgpratt> bergmark, don't tell anyone, but lately I've been experimenting with omitting the I in my own interface names
06:38:52 <J_Arcane> dgpratt: do you have any recommendations you might make for tutorials on getting oneself more acquainted with .NET? I've dabbled a little in F# but kinda felt lost past the shallow end, because I've no experience with the rest of the ecosystem.
06:42:06 <clrnd> I've done some F#, it's very nice, an slightly better ocaml (in my limited experience with both)
06:42:50 <dgpratt> J_Arcane, I'm sorry to say that I learned .NET a long time ago and there are probably much better resources available today -- if you still have questions, PM me -- I don't think folks here would appreciate us carrying on a discussion on .NET :)
06:43:08 <J_Arcane> Fair enough.
06:45:15 <Martlin> hello
06:45:27 <Martlin> @hoogle trace
06:45:29 <lambdabot> Debug.Trace trace :: String -> a -> a
06:45:29 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
06:45:29 <lambdabot> package trace-call
06:46:43 <Martlin> when using traceShow for debugging purposes sometimes I have to temporarily add Show constraint (sometimes to many functions in the call chain) just so I can print it. is there a way to make this work without adding those constraints in the code?
06:47:28 <merijn> Martlin: No, because polymorphic values can't be printed
06:47:53 <Martlin> ghci could add those constraints automatically for debugging purposes
06:48:01 <merijn> Martlin: You *have* to ensure that either the value is printable, or that it is monomorphic (which is the same thing, really)
06:48:06 <Martlin> I mean theoretically, right?
06:48:23 <merijn> Martlin: I'm not sure that adding the right constraints is decidable
06:48:59 <Martlin> why not? *is there a traceShow call?  add Show constraint*
06:50:03 <merijn> Martlin: That constraint has to propagate to all code that calls that function
06:52:21 <Martlin> so we are stuck with manually adding Show constraints if we want to use traceShow for debugging purposes, and nothing can (or could in future) be done to fix this
06:52:28 <Martlin> ?
06:53:31 <bitonic> Martlin: leave the Show constraint in
06:53:51 <bitonic> if it's your own code
06:54:00 <bitonic> if it's some library code, yeah you're in trouble
06:54:52 <bitonic> Martlin: if you really need to switch in and out, use ConstraintKinds to create a constraint synonym
06:56:14 <bitonic> actually, that makes me wonder: how do I type out the empty constraint?
06:56:35 <bitonic> something of kind Constraint which constraints nothing
06:56:57 <bitonic> the equivalent of () in  `() => a -> a'
06:56:59 <Martlin> bitonic that is not really a solution.. i dont know in advance what code and functions will need debugging. so i still have to manually add Show instance down the call chain (and it could be a long one)
06:58:27 <bitonic> Martlin: if you don't have a Show constraint, you cannot use `show'.  you should either put `Show' everywhere preventively, or use a constraint synonym that you change when you need to debug
07:00:00 <Martlin> bitonic you suggest I add Show constraint, or constraint synonym, to every single function that I write in haskell?
07:00:27 <bitonic> Martlin: to every polymorphic argument that you want to debug, yes
07:00:40 <Martlin> I don't know in advance what functions I want to debug
07:01:16 <bitonic> usually if you're writing some project you can identify pretty quickly where you can place the right constraints
07:01:47 <bitonic> in any case, the Haskell compiler just cannot print meaningful stuff given some polymorphic argument
07:01:56 <bitonic> when you compile the code, the types are gone
07:02:20 <bitonic> what you can do
07:02:25 <bitonic> is to print debug output only for one type
07:02:39 <bitonic> but you need Typeable for that, so it's not really that much better
07:03:01 <bitonic> if you know that you're testing with one type only, you can use `unsafeCoerce'
07:04:14 <Martlin> does ghc have a decent debugger?
07:04:32 <Profpatsch> Does foldr1 (&&) short-ciruit?
07:04:54 <Profpatsch> I would look it up if && had source code.
07:05:11 <bitonic> Profpatsch: && has source code
07:05:14 <Profpatsch> Or better: how to find out if it does?
07:05:18 <bernalex> @src (&&)
07:05:18 <lambdabot> True  && x = x
07:05:18 <lambdabot> False && _ = False
07:05:31 <bitonic> that's not the source code you're going to be running
07:05:41 <Lokathor> are cabal installed packages installed per user?
07:05:43 <bitonic> but yeah, && short-circuits
07:05:57 <Profpatsch> bitonic: Huh, where does that come from?
07:06:10 <Profpatsch> It’s definitely not defined in Prelude.
07:06:20 <bernalex> && is in prelude
07:06:38 <bernalex> not defined there, but re-exported there
07:07:14 <Profpatsch> bernalex: From where?
07:07:15 <bernalex> you might want to see GHC/Base.lhs
07:07:18 <bernalex> Data.Bool
07:07:37 <bergey> Lokathor: yes, by default.  If you're in a sandbox, they're installed per-sandbox.  There is a --global option, which I have never wanted.
07:07:53 <Lokathor> ...why have you never wanted it?
07:07:53 <bernalex> Data.Bool re-exports it from GHC.Base.
07:08:11 <luite> kqr: ghcjs actually ignored the LetNoEscape allocations until a few monts ago, replacing them with regular let (which makes heap objects rather than stack allocation), but since allocation is a lot more more expensive in JS than in the GHC RTS it's quite useful to use the escape analysis results. so i finally spent a few weeks figuring out how to implement it properly :)
07:08:33 <Martlin> bitonic sorry but I don't find your suggestions to improve anything. print debugging sucks by itrself, and haskell makes it that much more annoying. and, if what i've read so far is true, that ghc does not have a decent debugger, debugging in haskell is in really sad state
07:08:54 <Lokathor> It seems like it'd be simplest to cabal install packages as root, and then have them available to all users. Like you do with a normal package insstall
07:09:13 <clrnd> Debug.Trace ...
07:09:57 <Martlin> clrnd that does not work without adding Show constraints everywhere just for debugging purposes..
07:10:29 <bitonic> Profpatsch: actually, I'm not so sure it does have a source readily available.  (&&) is specified by the standard though, so it's kind of special
07:10:35 <kqr> luite, I want you to know that I only understand like 70% of what you are saying but it's cool as all heck
07:11:06 <bitonic> Martlin: printing out polymorphic values is hard because the types are erased at run time.  so you need a pointer to some bit of code that knows how to print them, at least if you implement Haskell the way GHC does
07:12:04 <bitonic> so for example if some polymorphic `a' is instantiated to `Maybe Int', it's going to be represented by a word representing the constructor, and then a pointer pointing to another word if the constructor is `Just'
07:12:05 <bergey> Lokathor: Problems arise when different packages want different versions of the same package, in particular with diamond dependency graphs.  What I generally want is sandboxed installs, so each project I work on can have suitable versions, and not be affected by other projects.
07:12:24 <bitonic> Martlin: but you can't really print the value meaningfully if you're given some blob of memory
07:12:33 <bitonic> how would you debug a `void *' in C?
07:12:55 <bitonic> so I think this is only partly a tooling problem
07:13:13 <Martlin> bitonic I understand why it happens. .but the end result is still the same..I can't just add traceShow in a function for debugging purposes. I have to modify function signatures, potentially a lot of them
07:13:22 <bergey> Global installs would move in the opposite direction.  My builds could (if my dev machine actually had other users) be broken by someone else's builds, and the solution would require me to delete the *global* package set, breaking everyone else's builds in turn.
07:13:31 <bitonic> Martlin: so what would be your proposed solution to the problem?
07:13:45 <Martlin> C usually ships with a good debugger. does ghc?
07:14:31 <bitonic> Martlin: the debugger is a separate issue.  I was referring to the printing out values
07:14:32 <Lokathor> Sounds like the various library groups should work more closely amongest each other to avoid that kind of thing
07:14:36 <clrnd> Martlin, C runtime is extremely simple
07:14:49 <Martlin> bitonic, debugging is not a separate issue from debugging
07:14:51 <clrnd> afaik ghci has a debugger
07:14:59 <clrnd> never used it though
07:15:13 <clrnd> https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/ghci-debugger.html
07:15:17 <luite> kqr: the GHC RTS can store dynamically allocated objects (thunks, data, closures) quite efficiently thanks to static types, JS engines have a few words overhead for every object. ghcjs stores all haskell data (except primitives, which are directly stored as booleans, numbers etc) in plain JS objects
07:15:39 <bitonic> Martlin: sure, but since you were complaining about traceShow I wanted to know if you had something better in mind
07:16:15 <bitonic> and yeah GHCi does have a debugger, but it might be a bit unfamiliar
07:16:58 <Martlin> bitonic you are asking me to solve the issue with debugging in haskell in real time now, when the entire community including ghc cxreators apparently hasn't solved it yet?
07:17:07 <Martlin> haven't*
07:17:16 <bitonic> Martlin: I was asking about a very specific issue
07:17:22 <bitonic> I debug Haskell all the time
07:17:52 <bergey> Lokathor: I see it as inevitible.  I use code written by volunteers, code written by academics and essentially unmaintained after release, and code actively maintained and frequently updated.  My code is used by people who want the latest versions at all times, and others who want the 2-year-old versions that ship with their linux distro's stable release, or have other reasons to stick to older versions.  I don't know how to curate
07:17:52 <bergey> collection of versions that works for all of these.
07:18:01 <bergey> I'd rather have good tooling for testing with multiple versions.
07:18:26 <Martlin> I am sure you do. but according to your suggestions (add custom constraint or Show constraint preventively everywhere, use unsafeCoerce) it just seems you just live with the pain
07:19:10 <bitonic> Martlin: yeah, it is sometimes painful to debug polymorphic code
07:19:13 <Martlin> print debugging is horrible enough, but in haskell I have to modify function signatures to do it
07:19:20 <Martlin> making it even more horrible
07:19:27 <theGeorgianGuy> Hello, I came across the  =<< operator in the harduino button example. I"m having trouble Googling for the operator as Google is filtering it out. Does anyone know it's name so I can google it?
07:19:32 <theGeorgianGuy> Here's the example: https://hackage.haskell.org/package/hArduino-0.9/docs/src/System-Hardware-Arduino-SamplePrograms-Button.html#button
07:19:36 <bitonic> Martlin: right my argument is that this is nothing about Haskell
07:19:42 <clrnd> Martlin, what about the ghci debugger?
07:19:44 <bitonic> (print debugging being painful)
07:19:54 <bitonic> it's just that Haskell has a lot of polymorphism
07:20:13 <bitonic> Haskell libraries rather than Haskell itself
07:20:39 <Martlin> clrnd from what I've read (granted, many of that is a bit dated) ghc does not really have a decent, working debugger. is that true or not?
07:20:47 <Lokathor> bergey: I shall take that under advisement, and install hscurses globally this time anyway.
07:21:28 <clrnd> Martlin, I don't know what you imply with 'decent' but GHCi has one
07:21:46 * hackagebot snaplet-purescript 0.1.0.0 - Automatic (re)compilation of purescript projects  http://hackage.haskell.org/package/snaplet-purescript-0.1.0.0 (AlfredoDiNapoli)
07:22:07 <bitonic> Martlin: I think it's decent, but I find that I rarely use it.  it's definitely a different experience than, say, C and gdb.  the main hurdle is that you might want to print stuff that is not evaluated yet
07:22:16 <bergey> Lokathor: Sure.  I was explaining why I do what I do, not really trying to persuade you, or imply it's the only way.
07:22:26 <Lokathor> it seems like lazyness would make debugging haskell really weird compared to C/++/Java code, so people complaining about GHCI might be talking abotu that.
07:23:15 <merijn> Lokathor: It is
07:23:22 <Lokathor> bergey: and yet I am suddenly persuaded, after I considered the case of Java and Maven essentially doing the same sort of thing with project-level installs of extra libraries.
07:23:25 <merijn> @quote stream.of.concious
07:23:25 <lambdabot> No quotes match. Maybe you made a typo?
07:23:27 <merijn> hmm
07:23:48 <bitonic> @quote stream.of.conscious
07:23:48 <lambdabot> cmccann says: you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
07:24:13 <Martlin> ^_^
07:24:32 <bitonic> Martlin: btw, I agree with you that debugging with languages without type-erasure is *much* nicer
07:24:43 <bitonic> since you print out things nicely
07:24:53 <Martlin> is type-erasure not an implementation detail?
07:25:09 <merijn> theGeorgianGuy: Use Hoogle
07:25:16 <merijn> @hoogle =<<
07:25:18 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
07:25:18 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
07:25:21 <merijn> @where hoogle
07:25:22 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
07:25:25 <Lokathor> in java it's specified as part of the language because the language and the implementation are so closely intertwined
07:25:29 <bitonic> Martlin: well, type-erasure has also big advantages.  you could implement Haskell retaining enough information to print out anythiing the heap meaningfully
07:25:39 <bitonic> Martlin: and in fact that seems to be the case in GHCi, given the debugger
07:25:55 <theGeorgianGuy> merijn: thanks a lot, it didn't cross my mind for some reason
07:26:17 <merijn> theGeorgianGuy: =<< is really just the >>= from Monad, but with the argument order reversed
07:26:20 <bitonic> Martlin: but usually if you can erase types and remain safe implementors choose to do so when compiling because you get rid of all the overhead that comes with it
07:26:48 <bitonic> Martlin: to be fair this is not really the issue here, because GHCi could do all of that but lazyness gets in the way
07:26:50 <Martlin> bitonic what is stopping them from not doing type erasure when compiling with debug flag?
07:26:52 <theGeorgianGuy> merijn: yeah, I just checked it. pretty clear now
07:27:16 <theGeorgianGuy> merijn: thanks a bunch
07:27:40 <bitonic> Martlin: well, I'm not sure there is a big interest in this feature, which would probably be a pain to maintain
07:28:00 <Martlin> there is no interest in improving debugging in haskell?
07:28:05 <bitonic> again the right place to do such a thing is probably in GHCi, which has its own interpreter
07:28:47 <Lokathor> During a cabal build I sometimes get "WARNING: unrecognized options: --with-gcc
07:28:48 <Lokathor> ", and yet the whole thing goes smoothly and insalls. What gives?
07:28:57 <bitonic> Martlin: I don't know how long you're programmed in Haskell, but I don't find myself wanting better debugging facilities *that* often.  it's also habit.  I mean if I'm working with Erlang or some lisp it's much nicer, but still
07:29:18 <Martlin> my point is, it is not type erasure that is preventing ghc from not having a decent debugger.. that is just implementation details. is seems that the attitude of many haskell users is "we don't need a debugger most of them time (or at all?), so why bother improving it"
07:29:53 <bitonic> Martlin: adding debugging facilities to the RTS is probably not that high priority.  but I can't really speak for the GHC people
07:30:03 <bitonic> actually
07:30:08 <bitonic> they did just add DWARF support
07:30:19 <Martlin> and while it is true that you need debugger a lot less in haskell than most other languages, this doesn't help you much when you actually do need it
07:30:21 <zzing> When you have a type such as  T with kind *, and another type S with kind *, when you add in dependent typing, such as forall x : Nat. S => T    what kind is S?
07:30:29 <bitonic> so it's not like they don't care, it's just that implementing what you want is not  as simple as you make it sound
07:30:55 <hvr> Martlin: I'm not sure you ever *need* a source-level debugger
07:31:05 <adamse> Martlin: what is wrong with the GHCi debugger?
07:31:32 <hvr> Martlin: a debugger such as GDB is just a convenience
07:31:54 <Martlin> adamse I have never used it, but from what I've read (including just now, in this channel) it is not very usable.
07:32:07 <vanila> zzing, well you alrady said S has kind *, so it should stil have kind *
07:33:02 <adamse> Martlin: I'm not an experienced user of debuggers in other languages but I've used the ghci debugger to some success
07:33:20 <bitonic> Martlin: the main problem with that is the debugger, as some mentioned, is that  you can't inspect unevaluated thunks.  at least when I tried it.
07:33:29 <adamse> it allows me to set breakpoints and inspect runtime values, pretty much what I do when debugging
07:33:46 <zzing> vanila, sorry I should have used something else in my last example the S was not the same.  To make sure there is no confusion, if I had a Vect a n  where a is a standard type, and n is a natural number denoting the size of the Vect, would Vect be * -> *     i.e. the number doesn't actually change the kind?
07:34:24 <bennofs> Martlin: combined with emacs haskell-mode, it seems to be pretty decent: https://www.youtube.com/watch?v=WAtEmoVN30E (never used it myself though)
07:34:28 <Martlin> adamse I will give it a try. can I run it within emacs, or in terminal?
07:34:42 <Martlin> bennofs ok.. thanks for the link
07:34:51 <adamse> Martlin: haskell-mode has some support
07:34:59 <adamse> otherwise just load your program in ghci
07:35:30 <bitonic> if you're using cabal, you can issue `cabal repl'
07:35:40 <vanila> zzing, Vect :: Nat -> *
07:35:44 <adamse> Martlin:
07:35:44 <adamse> http://lpaste.net/5601304663052779520
07:35:49 <adamse> sry: https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/ghci-debugger.html
07:35:53 <vanila> zzing, that allows Vect 3 :: *
07:36:12 <vanila> sorry
07:36:18 <vanila> Vect :: * -> Nat -> *
07:36:26 <vanila> so that you can have  Vect Bool 3 :: *, for example
07:36:40 <vanila> i missed that 'a' parameter first time
07:38:41 <zzing> vanila, my original example was not well stated :-(. ok, that seems to make sense. Although I have never seen regular text characters used in place of * for kinds.
07:57:50 <Neut> yo.  is there a recommended haskell plugin for intellij? i've tried the official one and haskforce, and neither seems to have support for running haskell tests or applications out of the box.
07:58:15 <tasker> I have an array that I have generated, and would like to save it as an image. What is the easiest way to do so? I was looking at the repa-io, repa-devil packages, but they seem to require Array F blah blah, rather than Array U or something.
08:01:09 <_um_> Is there an efficient way of adding dependencies to a cabal project?
08:01:28 <alpounet> tasker: have you checked out juicypixels?
08:01:36 <tasker> alpounet: Just looking now.
08:02:06 <_um_> Every time I want to import a new module I have to Import it into a file, then edit my .cabal to add the (different name) for the package, then quit cabal repl and run `cabal configure` and reload the file.
08:02:17 <_um_> I'm sure there's a more sane way of importing, right?
08:02:33 <tasker> _um_: One of the emacs haskell related packages does this. I think it's haskell-mode
08:02:45 <_um_> I'm using haskell mode.
08:02:56 <tasker> alpounet: Looks like I can use generateImage to convert my Array into the Image type. Cheers!
08:02:58 <_um_> But I haven't been able to get it to work with cabal-repl...
08:03:04 <tasker> _um_: It works based on the ghci type thing
08:03:18 <_um_> tasker: is that the best solution available? An emacs package?
08:03:23 <dgpratt> I'm getting an error trying to build the network package on Windows via MINGW
08:03:27 <lpaste> dgpratt pasted “network build error” at http://lpaste.net/118421
08:03:28 <tasker> _um_: No clue, but it's the only one I know of!
08:04:19 <dgpratt> seems the relevant bit is "./configure: line 4864: test: too many arguments", any ideas?
08:04:21 <_um_> tasker: You're saying that haskell-mode interactive-mode works best using ghci as the interactive type instead of cabal-repl?
08:05:03 <tasker> _um_: Actually it is cabal-repl I think. Sorry, it was ages ago that I used this so I'm not too clear on the details.
08:05:20 <tasker> https://github.com/haskell/haskell-mode/wiki/Haskell-Interactive-Mode-Compiling
08:05:25 <tasker> _um_: ^
08:05:40 <_um_> tasker: thanks! Do you just not mess with cabal stuff, then? Or you do it by hand?
08:06:22 <tasker> _um_: Basically I just don't change my imports that much. Maybe I add one every now and then in a project, so it doesn't tend to be a huge issue for me.
08:06:46 <tasker> er, not imports, package dependencies
08:07:10 <_um_> tasker: I'd love to learn how to manage that trick.
08:07:33 <_um_> tasker: I guess you just have your stock packages installed in ghc, not fussing with sanboxes and such?
08:08:21 <tasker> _um_: No, I do use sandboxes. I guess I mean that there is a bit of work at the beginning, adding packages etc, but after that it isn't really frequent enough to bother me.
08:08:43 <tasker> I can see if I were starting many new projects it might be more annoying.
08:09:13 <merijn> dgpratt: All I can say is "network is notoriously hard to build on windows, it's one of the packages that causes the platform to be strongly recommended"
08:09:30 <_um_> tasker: I see. So you just get used to it. It's my first time trying to set up a proper project, and it is very annoying. But I guess it's just learning pains. Thanks for the tips and for sharing your experience.
08:10:07 <merijn> _um_: FYI, if you run "cabal init" after already having code in the directory it will prefill the dependencies you have so far
08:10:22 <dgpratt> merijn, yes, I was aware of that -- I had a reason to try it with the nascent Minimum GHC Installer, so I did
08:10:27 <tasker> _um_: I presume you used cabal-init etc ?
08:10:30 <merijn> _um_: You can even move the cabal file temporarily, run "cabal init" and copy the dependency list to the old file
08:10:34 <_um_> merijn tasker I did.
08:11:03 <_um_> merijn: But if you're trying to work in a sandbox, which you're supposed to, you then you already need to have the cabal project running, right?
08:11:20 <merijn> Pffft "supposed to"
08:11:33 <_um_> I mean, I'd be happy not fussing with cabal until I need to package the code.
08:11:35 <merijn> Personally I don't start a sandbox until I run into a dependency issue
08:11:43 <_um_> Oh jeez.
08:12:08 <merijn> i.e. "I need something incompatible with what I already have installed system wide"
08:12:19 <_um_> It really is a sort of stop-gap hack then...
08:12:30 <merijn> What is?
08:12:35 <_um_> cabal sandboxes.
08:12:49 <merijn> I wouldn't call them a stop-gap hack
08:13:01 <_um_> If you put off using them only until you're running into conflicts, and just to get around them, at which point everything becomes more inconvient?
08:13:24 <merijn> But the goal is to be able to have a project separate from your system wide libraries
08:13:40 <merijn> But nowadays everyone seems to avoid installing libraries outside of sandboxes at any cost
08:14:03 <merijn> They're also good for depending on unreleased versions of packages.
08:14:27 <merijn> I.e. when hacking pandoc I'll have the pandoc dependencies to edit check out and a pandoc sandbox pointed at those checkouts.
08:14:31 <Martlin> if i want to force evaluation of first argument should I use seq or pseq?  seq a b or pseq a b
08:14:54 <merijn> _um_: But I mostly work on fairly selfcontained code and dependencies are not much of a problem then, unlike for huge projects like Yesod, etc.
08:14:58 <tdammers> merijn: that's because there is a brute-force but guaranteed-to-be-predictable approach to fixing dependency issues that only sandboxes provide, and a tedious precision-work approach with potentially fruitless outcome that can be had with or without sandboxes
08:15:26 <_um_> merijn: makes sense...
08:15:30 <Martlin> (a could be error)
08:15:34 <merijn> tdammers: Like I said, the likelihood of those issues depends on your dependency footprint
08:16:06 <merijn> Yesod with 100s is far more likely to have issues than something with a transitive dependency list of like 20 packages
08:16:52 <_um_> merijn: I've picked up the message that I *should* be using sandboxes for managing all dependencies. But I would definitely prefer to put it off. Maybe I'll nuke the sandbox and see how far I can get before running into dependency issues.
08:18:55 <merijn> _um_: Well, especially when hacking your own projects all dependencies tend to default to whatever you currently have installed, so conflicts are much less likely
08:20:00 <_um_> merijn: make sense. I ran into a potential conflict some time ago, and just from reading around the web I've got the fear of cabal hell put in me, and then everything I read is like "sandbox sandbox sandbox" so I went that way.
08:20:59 <merijn> _um_: What people call "cabal hell" nowadays often boils down to "I want to use two packages with conflicting dependencies and cabal won't let me!"
08:21:05 <_um_> Right.
08:21:20 <_um_> marens: So not that terrifying?
08:21:41 <merijn> _um_: Unless you have to the very newest version of some package for an API change/bugfix you could just stick to the platform versions of whatever
08:21:48 <_um_> That's good t know :)
08:22:05 <merijn> _um_: Nothing gets broken, it's just stuff refusing to build/find an install plan
08:22:39 <merijn> Now, SOLVING that problem can be annoying, as it usually means tracking down which packages are causing the dependency tracker to fail
08:24:12 <merijn> _um_: See also: http://www.well-typed.com/blog/99/
08:25:14 <_um_> Well, and there we go. The package I want to install *will* break dependencies so I have to rebuild the sandbox after all... I guess there's no avoid the fuss at this point :(
08:27:45 <_um_> that post on cabal hell is helpful, thanks merijn.
08:28:58 <_um_> Does/has anyone here use nix instead of cabal? Is it smooth enough and pleasant enough that it would be worth setting that up (I've already fiddled with a nix a little bit, so I wouldn't be totally starting from scratch).
08:32:30 <alpounet> yeah, it's very nice once you know the basics
08:32:33 <bergey> I use Nix.  It's very flexible, but I wouldn't say it "just works".  Mostly, we're lacking in documentation & porcelain.
08:32:42 <alpounet> it takes a bit of time to get used to it
08:32:55 <alpounet> but definitely worth the ride
08:33:08 <dcoutts> merijn, _um_, part 2 on nix is coming up btw, finally.
08:33:13 <alpounet> (but only if you're willing to spend some time learning your way around it)
08:33:45 <malllle> if i have: data F String = F String [String], what would be an efficient way to map over [F String] replace every String with an unique Int and get something like: (Map String Int, [F Int]) as the result?
08:34:41 <_um_> alpounet, bergey: cool. I think I'll try it out then.  I played with the expression language a bit, and actually found it kind of beautiful in its own right. I'm okay with spending time to learn something, especially if its a well thought out, rational system. I am aware that Nix is still developing rapidly though..  I'll keep those caveats in mind :)
08:35:41 <tasker> What's my best bet for converting from Double to Word8 ?
08:35:46 <_um_> dcoutts: Oh, great. You're referring to the post on cabal hell? I'll keep my out for part 2. Finding the right up very illuminating. Thanks.
08:36:35 <dcoutts> _um_: yeah, I meant to write the second instalment soon after, but, well getting round to it finally
08:36:41 <alpounet> _um_: right, you seem to be ready to appreciate the joys of nix. some people just want something they can run quickly without having to learn something entirely new, and that's understandable, but in these cases i tend not to recommend nix :)
08:36:49 * hackagebot true-name 0.0.0.1 - Template Haskell hack to violate another module's abstractions  http://hackage.haskell.org/package/true-name-0.0.0.1 (LiyangHu)
08:38:08 <_um_> alpounet: that makes sense. And I do appreciate the caution. Especially since I'm partially motivated by frustration with cabal. It's good to be reminded that it's not like it would be an escape to something that takes *less* effort. I'm imagining: more effort but with the promise of a rationalized work flow on the other end.
08:38:40 <alpounet> _um_: exactly. although to be honest with cabal2nix it's really not so bad
08:39:05 <alpounet> but when you want to customize things a bit you definitely have to know a couple of things about the nix expression language
08:39:56 <merijn> tasker: With which semantics?
08:40:20 <merijn> tasker: round, floor and truncate can all return any Integral, afaik
08:40:25 <merijn> :t round
08:40:26 <lambdabot> (RealFrac a, Integral b) => a -> b
08:40:29 <_um_> alpounet: the expression language is downright neat. I really like that they have function currying is just apparent in the function-literals, but in such a way that the functions still read perfectly.
08:40:35 <merijn> > round 2.5 :: Int8
08:40:37 <lambdabot>  2
08:40:38 <tasker> merijn: Cool, round will most likely work.
08:40:50 <fr33domlover> hello
08:41:01 <merijn> tasker: Note, round uses banker's rounding, which may or may not be what you learned in school ;p
08:41:15 <fr33domlover> what is the common way a parser can generate friendly sense-making errors?
08:41:20 <tasker> merijn: hah, okay :p
08:41:33 <fr33domlover> does it help to define nonterminals just to catch common errors?
08:41:47 <merijn> > (round 2.5, round 3.5) :: (Int, Int)
08:41:48 <lambdabot>  (2,4)
08:42:03 <alpounet> _um_: yeah, it's actually fun to write nix exprs, and the benefits are just too good to ignore =)
08:42:22 <merijn> fr33domlover: This may be interesting to you: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
08:43:41 <mmachenry> Does anyone know how to fix exit failure 1 when upgrading cabal-install? http://lpaste.net/118422
08:43:46 <fr33domlover> merijn, thanks. I was actually targeting Happy, which seems to catch more things before runtime (I'm writing a parser for a standalone data language, not a DSL)
08:44:30 <int-index> What transformers does GHC 7.10 with?
08:44:43 <int-index> *ship with
08:44:51 <merijn> undefined ;)
08:45:05 <merijn> 7.10 doesn't ship yet :p
08:45:20 <merijn> Although the more useful answer of what it will ship with I don't know
08:46:49 * hackagebot boxes 0.1.4 - 2D text pretty-printing library  http://hackage.haskell.org/package/boxes-0.1.4 (dfeuer)
08:48:43 <fr33domlover> hmmm reading merijn's link... which would be better for a data language like XML or JSON or Turtle or SQL - a parser combinator like parsec, or the traditional happy?
08:48:54 <fr33domlover> I wonder which I should use / try first
08:49:18 <fr33domlover> efficiency isn't very critical because files won't be read much in real-time
08:49:35 <fr33domlover> while friendly errors may be important
08:53:07 <merijn> fr33domlover: Personally I find parser combinators much easier to use than parser generators
08:53:48 <fr33domlover> merijn, me too, but I'm trying to plan ahead and make a good decision for long-term if possible :-)
08:55:26 <arbelos> In which version of GHC was lambda case syntax introduced?
08:55:36 <johnw> 7.6
08:56:00 <arbelos> ok great. thanks
08:57:03 <arbelos> but "typed holes" is much later, isn't it?
08:58:02 <bergmark> arbelos: that's 7.8 iirc
08:59:17 <arbelos> yes.. 7.8.1 according to the wiki (appeared to be down first, but it was just my connection)
09:00:22 <merijn> typed holes are 7.8
09:00:40 <merijn> Now with added awesome in 7.10 :p
09:01:50 * hackagebot th-desugar 1.4.2.1 - Functions to desugar Template Haskell  http://hackage.haskell.org/package/th-desugar-1.4.2.1 (RichardEisenberg)
09:04:07 <arbelos> so i guess i should stop implementing functions as "undefined" then to get the types in order
09:05:07 <adamse> merijn: what is the new awesome additions to typed holes in 7.10?
09:07:07 <merijn> adamse: The ability to turn them from errors into warnings so you can execute code with holes in it
09:07:28 <merijn> There was already -fdefer-type-errors, but that turns ALL errors into warnings.
09:07:56 <adamse> merijn: ah, yes, thanks
09:08:47 <merijn> Now you can treat holes separately. Plus, if you use Syntastic it used to highlight all holes as errors/warnings in your code, so the warning produced when converting from error to warning is silenceable too
09:09:05 <merijn> I don't know if this effects other error highlighting tools too, but it might if they just parse GHC output
09:09:35 <StoneToad> the hole warning thing is especially nice if you're using the type unification trick
09:09:54 <merijn> Which trick is that?
09:10:07 <StoneToad> https://ro-che.info/articles/2014-03-13-type-of-local-function
09:10:20 <StoneToad> key part:  let leave = branch testName False `asTypeOf` _
09:10:27 <StoneToad> _ has the same type as leave
09:10:37 <StoneToad> or _leave if you want to know which hole it is
09:12:21 <merijn> Ah, yeah
09:26:58 <codygman> In Shelly how could I replicate 'echo "test" | grep "test"' (piping basically)? I don't see any functions for it.
09:28:40 <ChristianS> codygman: Shelly.Pipe module?
09:29:27 <codygman> ChristianS: I didn't see anything like Text -> Sh Text in there
09:36:27 <ReinH> codygman: (-|-)
09:39:36 <codygman> ReinH: -|- ... wow.. That function could also express my mood after overlooking that
09:39:46 <ReinH> codygman: ?
09:40:07 <codygman> ReinH: It looks like a smiley that is annoyed sort of, lol
09:41:24 <codygman> but thank you
09:43:38 <GBrawl> what's the easiest way to go from [a] [b] to [[a],[b]]?
09:44:05 <EvanR-work> put the x=[a] and y=[b] in [x,y]
09:44:26 <GBrawl> thx
09:44:31 <mpickering> Well the lists have the have the same type
09:44:33 <EvanR-work> or, thats not a correct type notation
09:44:46 <GBrawl> yeah they have the same type so it's alright
09:45:38 <mpickering> So it's actually f :: [a] -> [a] -> [[a]] you want?
09:45:48 <mpickering> f x y = [x,y]
09:46:08 <GBrawl> yeah that's what I wanted
09:46:14 <mpickering> Doesn't sound like something you would want to do too often tho..
09:46:29 <EvanR-work> yeah
09:46:41 <GBrawl> I need to split an array by an array
09:46:44 <GBrawl> so for example
09:47:12 <GBrawl> split [1,2] [0,1,2,3,4] - > [[0], [3,4]]
09:47:14 <GBrawl> that's why
09:47:17 <EvanR-work> if you split something in two, you usually get a pair (tuple) not a list
09:47:20 <GBrawl> for those who were interested :D
09:47:24 <EvanR-work> :t breakAt
09:47:25 <lambdabot>     Not in scope: ‘breakAt’
09:47:25 <lambdabot>     Perhaps you meant one of these:
09:47:25 <lambdabot>       ‘break’ (imported from Data.List),
09:47:26 <EvanR-work> :t break
09:47:27 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
09:48:22 <EvanR-work> i found this post pertaining to the history of the IO model, and how to think of it (not necessarily in terms of monads, so good for an introduction i think) http://r6.ca/blog/20110520T220201Z.html
09:48:42 <EvanR-work> "I/O is not a monad"
09:50:50 <blAckEnEd> hello. I'm trying to use the language-python library to parse some Python files, but it does not seem to support unicode characters in string literals.
09:51:18 <blAckEnEd> I downloaded the source and I see that it's using alex to generate the lexer. the definition for cahacters in string literals is: $short_str_char = [^ \n \r ' \" \\]
09:52:04 <blAckEnEd> that looks about right, but when I try to parse let source = "u'£'" it returns a parse error
09:52:24 <blAckEnEd> does anyone have experience with either language-python or unicode support in alex?
09:59:20 <EvanR-work> an imperative program could be modeled as data Program i r = Stop | Go i (\r -> Program i r), so running a program is just a (possibly infinite) series of effects and queries. and this has nothing to do with monads ;)
10:00:00 <EvanR-work> and haskell IO is a DSL for building these
10:01:12 <EvanR-work> no \
10:05:26 <RustyShackleford> do we have a concept of methods with haskell?
10:06:16 <RustyShackleford> can a type have methods (member functions, whatever you call them)? or do you just make functions which take whichever type as a parameter
10:06:54 <EvanR-work> its common to call the elements of a type class methods
10:07:01 <EvanR-work> but also you can just put functions in a record
10:08:06 <EvanR-work> and because of lazy evaluation, you might not have any need to pass in a "this" value
10:09:00 <RustyShackleford> EvanR-work: so what should I search for in google?
10:09:16 <EvanR-work> about what topic
10:09:55 <vanila> typeclasses
10:10:23 <EvanR-work> also haskell records
10:10:24 <chpatrick> RustyShackleford: not really, just write functions
10:10:41 <kadoban> RustyShackleford: If you're asking if typeclasses are like inheritence in C/C++/Java, very not.
10:10:58 <chpatrick> RustyShackleford: the right way to think about typeclasses is that they associate values (which might be functions) with types
10:11:21 <chpatrick> if you try to do OOP style member functions with typeclasses it will just be a mess
10:11:34 <codygman> My shelly code ran out of memory. I tried to use the more memory effecient version with handles but can't seem to figure it out: http://lpaste.net/118423
10:11:40 <kadoban> RustyShackleford: They're more like a badass version of templates in C++, generics in Java.
10:11:44 <c_wraith> I think of typeclasses as predicates on types.  "a is a type that satisfies the F constraint"
10:12:15 <chpatrick> c_wraith: that's more general than typeclasses though
10:12:30 <chpatrick> Foo a ~ Int is a predicate too
10:12:35 <EvanR-work> kadoban: wouldnt those be more like parametric polymorphism
10:12:43 <chpatrick> typeclasses are a predicate saying "this type has these associated values"
10:12:49 <c_wraith> chpatrick: yes, but ~ is the only special constraint like that.
10:13:04 <c_wraith> chpatrick: and there's no requirement that there be associated values.  Or even types.
10:13:08 <EvanR-work> well a type class could have nothing in it
10:13:09 <chpatrick> c_wraith: ok sure
10:13:16 <EvanR-work> but the constraint is still there
10:13:25 <kadoban> EvanR-work: Yeah, it's not exact at all, but it's closer IIUC.
10:13:26 <c_wraith> There are 0-parameter type classes!
10:13:27 <chpatrick> but any Constraint is a predicate
10:13:50 <chpatrick> the special thing about typeclasses is the values
10:14:14 <EvanR-work> different empty type classes arent the same though
10:14:28 <chpatrick> I mean in what they can do
10:14:48 <chpatrick> what distinguishes them from other types of constraints, not what distinguishes them for each other
10:15:01 <RustyShackleford> this type system is complicated haha
10:15:22 <EvanR-work> kadoban: yeah one is about dynamic dispatch (the hugest deal in oop) and the other is generic programming
10:15:34 <RustyShackleford> lets say we make a type like: data Boolean = True | False
10:15:38 <RustyShackleford> is that a typeclass?
10:15:42 <chpatrick> that's a data type
10:15:54 <chpatrick> that's just regular old data
10:16:22 <chpatrick> a typeclass is a specification saying if a type a is a member if class c then it has to have these things
10:16:30 <chpatrick> and there can be multiple instances
10:16:55 <chpatrick> for example a type is an instance of Show if it has a function show :: a -> String
10:17:03 <chpatrick> where Show is the a typeclass
10:17:14 <mmachenry> RustyShackleford: Functor is a very clear, and simple example of a type class as well.
10:17:28 <mmachenry> Anything that is a Functor has to implement fmap.
10:17:49 <mmachenry> And can now be passed to any function that requires that the type be a Functor.
10:18:31 <EvanR-work> RustyShackleford: Bool is a type, and Monoid is a type class, which Bool can be made an instance of by implementing the interface
10:18:41 <EvanR-work> > True <> False
10:18:42 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Bool)
10:18:42 <lambdabot>    arising from a use of ‘Data.Monoid.<>’
10:18:51 <RustyShackleford> so typeclasses are the things you derive from?
10:19:02 <RustyShackleford> Show, Enum, and so on
10:19:22 <EvanR-work> haskell can automatically implement some of the type classes for you
10:19:23 <chpatrick> RustyShackleford: you don't derive from them, you implement them
10:19:36 <EvanR-work> thats deriving
10:21:04 <EvanR-work> > Any False <> False
10:21:05 <lambdabot>  Couldn't match expected type ‘Data.Monoid.Any’
10:21:05 <lambdabot>              with actual type ‘GHC.Types.Bool’
10:21:19 <chpatrick> the difference from OOP interfaces is that you can make a type an instance of a class whenever you like, in whatever code
10:21:32 <chpatrick> you don't have to declare them with your datatype
10:21:59 <EvanR-work> thats not a requirement in oop either
10:22:07 <chpatrick> ok, Java :)
10:22:25 <chpatrick> also in say Java you can only have members which are of the type MyType -> Params -> Result
10:22:30 <RustyShackleford> so back to my original question, methods
10:22:36 <c_wraith> chpatrick: oh right.  The other main viewpoint I use is that type classes are functions from types to values.  Which is the same thing as you're saying, but it has connotations I find more useful.
10:22:37 <RustyShackleford> how do you define a method?
10:22:39 <chpatrick> in Haskell you can have whatever value as long as it contains MyType somewhere
10:23:06 <EvanR-work> RustyShackleford: what do you want a method to be?
10:23:12 <EvanR-work> an operation on your data type?
10:24:03 <RustyShackleford> EvanR-work: yeah basically
10:24:09 <EvanR-work> then you can just write a function
10:24:30 <RustyShackleford> what about a toString() sort of method?
10:24:44 <EvanR-work> showMyType :: MyType -> String
10:24:49 <RustyShackleford> same deal? just make a function that takes my data type as a parameter, then return a string?
10:24:58 <chpatrick> yep
10:25:20 <chpatrick> you only need typeclasses if you want some function that works on different types
10:25:41 <EvanR-work> even then, you dont need typeclasses, there are other mechanisms
10:25:57 <chpatrick> depending on the case :)
10:26:09 <chpatrick> GameObject probably shouldn't be a typeclass
10:26:49 <RustyShackleford> i rather dislike how many ways there are to accomplish a given task
10:27:09 <RustyShackleford> there are like three syntaxes for defining a function
10:27:12 <EvanR-work> well it takes practice to know which way is the nicest way
10:27:24 <EvanR-work> you have to unlearn a lot
10:27:52 <hodapp> Possibly silly question: is there a polymorphic 'do nothing' value in a monad?
10:27:56 <chpatrick> return ()
10:28:04 <chpatrick> oh polymorphic
10:28:05 <chpatrick> sorry
10:28:05 <EvanR-work> :t return ()
10:28:06 <lambdabot> Monad m => m ()
10:28:09 <EvanR-work> its polymorphic ;)
10:28:19 <chpatrick> do you mean ma ?
10:28:26 <hodapp> good, that's what I needed I think
10:28:35 <EvanR-work> :t return undefined
10:28:36 <lambdabot> Monad m => m a
10:29:11 <chpatrick> depends on the Monad too
10:29:14 <chpatrick> :t Nothing
10:29:15 <lambdabot> Maybe a
10:29:37 <EvanR-work> return foo is always a "do nothing value" in any monad
10:29:57 <chpatrick> yeah but if it's return undefined you might crash
10:30:01 <EvanR-work> Nothing in maybe monad, that does something ;)
10:30:23 <chpatrick> yeah that's true
10:30:29 <S11001001> Why is the fundep not satisfied by induction on line 17 of this code? (ghc 7.8.4) https://bitbucket.org/S11001001/chsurch/src/784cb52ce00c31f7d152704387c6193f4ccb4971/src/Chsurch/MonadCatch.hs?at=default
10:30:59 <c_wraith> I'd call "return foo" a neutral element of whatever type.  It has no special meaning.
10:32:14 <c_wraith> S11001001: it's because MonadCatch is an MPTC.  without UndecideableInstances, *every* parameter of an MPTC must satisfy the coverage condition, and the e parameter doesn't
10:33:01 <c_wraith> S11001001: same thing going on with the m -> n dependency, I suppose.  It just reported that one instead of e
10:33:15 <c_wraith> S11001001: it's just the coverage condition.  Enable UndecideableInstances, turn it off.
10:35:20 <S11001001> c_wraith: Hum.  Ok, thanks
10:38:03 <ansible> trying to write a little parser...  I want to do something like sepBy, which matches a thing and then skips another thing.
10:38:25 <ansible> but in my case I want to match a thing, and then skip anything that's not that thing, if that makes any sense.
10:39:04 <ansible> so its text-I-care-about separated by I-don't-care-what
10:39:58 <EvanR-work> ansible: maybe the separator can be a parser for anything that doesnt start text-I-care-about
10:40:36 <ansible> yeah, that makes sense... I'll give that a try
10:41:00 <EvanR-work> that might not work
10:41:38 <osa1> is there a way to specify the sandbox location while running "cabal exec"?
10:42:08 <dcoutts_> osa1: yes, it's a global flag
10:42:21 <osa1> how do I set it?
10:42:22 <dcoutts_> see cabal --help
10:42:26 <osa1> ok, thanks
10:42:47 <dcoutts_> so it should be cabal --sandbox-config-file= exec ...
10:43:02 <dcoutts_> cabal [global flags] cmd [cmd flags]
10:43:39 <ansible> I think I want to match text-I-care-about and get a result of either sucess or fail, where on fail it skips whatever it read to determine failure.
10:44:29 <ansible> attoparsec always rewinds on failure, so hmmm
10:46:27 <EvanR-work> ansible: whats an example of the language
10:47:36 <ansible> just trying to pull hrefs out of an html document, so:   href="linktext", and the part I want is linktext.
10:47:48 <ansible> idea is to get an array of linktext back from the parse
10:48:05 <EvanR-work> ok start with a parser for that one element
10:48:43 <EvanR-work> literally href, =, ", then a parser for anything thats not ", then literally "
10:48:52 <EvanR-work> which produces just the part between the " "
10:49:20 <EvanR-work> once you have that, you can get many hrefs back by using sepBy whitespace
10:49:54 <EvanR-work> (href, not being the only attribute, you probably want to make this part more liberal)
10:51:31 <EvanR-work> sorry. just the hrefs... you can sepBy a parser that is "not href="
10:53:00 <ansible> ok that sounds like it will work.  I have a parseHref ftn that gets the link text correctly
10:53:15 <dgpratt> woot!
10:54:02 <dgpratt> managed to figure out the issue preventing me from building the network package on this Windows box :)
10:54:32 <dgpratt> (I had some other grep on the PATH)
10:54:42 <ansible> the not "href" part is not immediately apparent but I expect that's possible
10:57:13 <ReinH> There are various html libraries that would do this
11:00:48 <ansible> thx, I'm trying to figure out this parsing thing as an exercise...
11:01:56 * hackagebot UISF 0.3.0.1 - Library for Arrowized Graphical User Interfaces.  http://hackage.haskell.org/package/UISF-0.3.0.1 (dwincort)
11:06:56 * hackagebot iso3166-country-codes 0.20140203.7 - A datatype for ISO 3166 country codes  http://hackage.haskell.org/package/iso3166-country-codes-0.20140203.7 (JonFairbairn)
11:18:15 <horny-sama> Any good tips on adjusting to haskell. (Coming from C and js)
11:19:00 <johnw> horny-sama: be patient with yourself
11:19:20 <johnw> it will all become clear with time and practice
11:19:21 <horny-sama> johnw: coz it is just weird that haskell has no loop
11:19:30 <horny-sama> and you have to do recurvsion for everything
11:19:38 <johnw> actually, recursion becomes less and less common
11:19:42 <johnw> it's more common to use a fold
11:19:55 <johnw> most loops are folds in disguise
11:20:08 <wayne> or maps
11:20:13 <horny-sama> johnw: fold?
11:20:21 <johnw> :t foldr
11:20:22 <lambdabot> (a -> b -> b) -> b -> [a] -> b
11:20:31 <johnw> foldr mutates a value over a list
11:20:40 <wayne> johnw: i don't think that would help if horny-sama isn't yet familiar with notation
11:20:48 <johnw> ah yes, you are right
11:20:55 <horny-sama> wayne: I am just learning the notations atm
11:20:57 <johnw> a fold takes a list, and reduces it to a value
11:20:59 <horny-sama> for this semester
11:21:10 <horny-sama> It seems like haskell is designed primarily for ai stuff
11:21:12 <johnw> (where that value could be another list, if you wanted)
11:21:16 <wayne> horny-sama: you should learn what map, reduce, fold are
11:21:23 <johnw> haskell isn't designed for any particular application
11:21:35 <wayne> horny-sama: then you should learn what static typing is
11:22:12 <Iceland_jack> horny-sama: No that is incorrect
11:22:29 <horny-sama> wayne: I am just learning how to write an expression in haskell
11:22:50 <horny-sama> feel like I am starting from ground zero for haskell despite my prior programming experience
11:23:03 <wayne> horny-sama: there are some concepts that will definitely help you understand and write haskell code
11:23:17 <wayne> horny-sama: you would do well to understand them first
11:23:36 <horny-sama> wayne: I mean haskell does not have variables
11:23:41 <chirpsalot> wayne: maps are folds in disguise :P
11:23:45 <horny-sama> it is like named expressions?
11:24:03 <chirpsalot> horny-sama: you call them variables in math too, and they aren't mutable.
11:24:05 <Iceland_jack> Haskell does have variables, it doesn't have mutable references
11:24:40 <chirpsalot> horny-sama: they're "variable" in the sense that you could have different things bound to the name.
11:24:40 <horny-sama> Iceland_jack: gosh seems like this will be a hellish semester for me
11:24:44 <horny-sama> prolog and haskell
11:24:46 <EvanR-work> map filter and reduce are all available in javascript too. you don't need loops to do these things in js
11:24:58 <chirpsalot> horny-sama: sounds like a wonderful semester <3
11:25:04 <horny-sama> it is so different from anything I know
11:25:08 <Iceland_jack> horny-sama: Not really :-) you're focusing too much on how Haskell is different from C
11:25:21 <horny-sama> Iceland_jack: :P
11:25:21 <chirpsalot> horny-sama: it'll be enlightening if you let it be. Is this for a class?
11:25:24 <Iceland_jack> That will make it seem more complicated
11:25:29 <horny-sama> chirpsalot: yes
11:25:43 <Iceland_jack> horny-sama: Here is a function that adds 3 to its argument:
11:25:44 <Iceland_jack>     foo :: Int -> Int
11:25:44 <Iceland_jack>     foo x = 3 + x
11:25:44 <chirpsalot> Classes are kind of rough because they go at a pace that most likely won't suit you and they gloss over things.
11:25:59 <Iceland_jack> Start simple
11:26:06 <chirpsalot> horny-sama: my tip for you would be to use Haskell, outside of the class.
11:26:23 <horny-sama> chirpsalot: okay
11:26:37 <horny-sama> Iceland_jack: what does your function do
11:26:49 <horny-sama> it maps an integer to another integer
11:26:51 <horny-sama> then I am lose
11:26:53 <chirpsalot> Like if you need to write a simple program try to do it in Haskell. It'll be rough the first few times, but soon enough you'll be a pro :).
11:27:16 <Iceland_jack> horny-sama:
11:27:16 <Iceland_jack>     ghci> foo 10
11:27:16 <Iceland_jack>     13
11:27:19 <chirpsalot> horny-sama: it takes an integer as an input (x is the argument), and then adds 3 to that argument, giving you another integer.
11:27:23 <horny-sama> chirpsalot: I have installed haskell platiform on my fedora
11:27:33 <horny-sama> but now I could not quite figure out how to fire up the ide
11:27:36 <horny-sama> and compile it
11:27:56 <hexagoxel> int foo(x: int) { return 3 + x; }
11:28:16 <chirpsalot> hexagoxel: haha, what language is that ;)?
11:28:45 <horny-sama> is there any ide for it?
11:29:14 <chirpsalot> horny-sama: there are haskell modes for emacs and vim. Not sure about anything elese.
11:29:17 <chirpsalot> else*
11:29:35 <horny-sama> chirpsalot: how do you compile it?
11:29:47 <Iceland_jack> horny-sama: 'ghc file.hs'
11:29:50 <chirpsalot> horny-sama: you will use ghc, which is the compiler.
11:29:52 <hexagoxel> chirpsalot: something close to c, i hope
11:30:06 <chirpsalot> horny-sama: ghci is the interpreter, which you can play around with.
11:30:23 <horny-sama> chirpsalot: that reminds me of python
11:30:43 <chirpsalot> hexagoxel: haha, you're just a LITTLE off with the type signature :). int foo(int x) { return 3 + x; }
11:30:44 <clrnd> python 3.5 lol
11:30:53 <hexagoxel> hehe
11:30:56 <chirpsalot> clrnd: I always joke that Python 4 is going to be Haskell.
11:31:05 <chirpsalot> I have python4 aliased to ghci on my computer.
11:31:11 <clrnd> chirpsalot, jajajaja
11:31:50 <horny-sama> chirpsalot: naughty boy?
11:32:04 <chirpsalot> horny-sama: no, I'm just from the future :).
11:32:17 <horny-sama> how come when I fire up ghci in my terminal, it is stated as Prelude>  instead of haskell
11:32:28 <horny-sama> chirpsalot: de morgan?
11:32:30 <chirpsalot> horny-sama: that means that it has the prelude loaded.
11:32:38 <chirpsalot> Which is the kind of "default" library.
11:32:43 <starless> chirpsalot: Python is good and could be great with type annotations and pattern matching!
11:32:44 <bennofs> horny-sama: the part before > lists the loaded modules. try 'import Data.List' and see what happens
11:32:59 <Martlin> Prelude gets imported by default
11:33:02 <chirpsalot> starless: it sort of has pattern matching on tuples, but it's really inconsistent.
11:33:04 <horny-sama> Prelude Data.List>
11:33:34 <bennofs> horny-sama: btw, you can change that if you want to using `:set prompt ...`
11:33:42 <starless> chirpsalot: does it? .-.
11:33:51 <starless> chirpsalot: just checking the arity doesn't count...
11:33:59 <horny-sama> I want to change ghci into fire_icbm
11:34:01 <horny-sama> lol
11:34:02 <horny-sama> :P
11:34:36 <chirpsalot> starless: haha. It also doesn't work consistently across lambdas or something. Can't remember what it was.
11:34:43 <chirpsalot> It USED to in Python 2, though.
11:34:55 <chirpsalot> starless: you can do (a, b) = f() in Python, though.
11:35:26 <starless> chirpsalot: which is nice, but not nearly as nice as bona fide pattern-matchin'
11:35:41 <horny-sama> so there is no ide for haskell
11:35:47 <horny-sama> if so how do you debug
11:35:57 <horny-sama> I really hate debugging using gdb
11:36:07 <geekosaur> there are IDEs, they just don't get used much.
11:36:16 <horny-sama> geekosaur: are they any good?
11:36:22 <horny-sama> any good ide recommendation
11:36:23 <horny-sama> ?
11:36:24 <chirpsalot> horny-sama: well, you probably won't be debugging using gdb.
11:36:26 <geekosaur> as for core dump debuggers, they are less than helpful with graph reduction evaluation
11:36:32 <geekosaur> ghci is our debugger
11:36:35 <chirpsalot> https://www.haskell.org/haskellwiki/IDEs
11:37:03 <horny-sama> geekosaur: so ghci will show which line is causing the problem?
11:37:07 <horny-sama> like eclipse?
11:37:18 <geekosaur> it's not that simple
11:37:42 <geekosaur> the "line that is causing the problem" is likely, via lazy evaluation, to be quite different from the line that the problem was discovered on
11:38:17 <horny-sama> geekosaur: then how can you debug?
11:38:36 <starless> is Lamdu usable yet?
11:38:51 <starless> horny-sama: also, GDB is not a bad tool, in my opinion. sure you're used to it?
11:39:05 <bennofs> starless: It can't even run code yet IIRC
11:39:21 <starless> bennofs: maybe not for Haskell, then
11:39:23 <horny-sama> starless: gdb is an user-unfriendly tool, but it is pretty powerful
11:43:10 <horny-sama> installing  Leksah
11:43:14 <horny-sama> hopefully it is good
11:43:18 <codygman> Is there something that lifts any error to a "Left String"? For instance getDirectoryContents "non-existent" would return Left "non-existent: getDirectoryContents does not exist ...".
11:46:48 <johnw> codygman: something involving 'try'?
11:54:35 <supki> :t Lens.trying (_IOException.to show)
11:54:36 <lambdabot> Control.Monad.Catch.MonadCatch m => m r -> m (Either String r)
11:58:53 <ReinH> supki: Lens never ceases to amaze me...
11:59:58 <edwardk> :t trying (to show)
11:59:59 <lambdabot>     Ambiguous occurrence ‘trying’
11:59:59 <lambdabot>     It could refer to either ‘Lens.trying’,
11:59:59 <lambdabot>                              imported from ‘Control.Exception.Lens’ at /home/lambda/.lambdabot/State/L.hs:47:1-37
12:00:05 <edwardk> :t Lens.trying (to show)
12:00:05 <lambdabot> Control.Monad.Catch.MonadCatch m => m r -> m (Either String r)
12:00:17 <edwardk> if you want to not limit yourself to IOExceptions
12:02:48 <athan> Does `:set -XDataKinds` have no effect while in a ghci session?
12:03:04 <athan> If so, is there a way to pass the option through `cabal repl`?
12:05:24 <bennofs> athan: seems to work for me: :set -XDataKinds; data T = T; :k 'T   ---> 'T :: T
12:05:50 <bennofs> athan: I don't think that GHCi options affect loading files though
12:06:35 <codygman> johnw: Yeah, I guess that shoulda been obvious. I'll 'try' (har har) it
12:06:51 <athan> oh shoot, I'm a dummy, I keep getting caught testing lists. Thanks bennofs :)
12:08:47 <johnw> codygman: it won't automatically turn the exception into a string, but that should be kind of obvious
12:10:46 <mpickering> :k (,)
12:10:47 <lambdabot> * -> * -> *
12:11:29 <ReinH> edwardk: that's pretty awesome.
12:11:41 <ReinH> I need to check out all the lens extras
12:13:05 <codygman> johnw: Right, this worked for the specific (but not general) case: try (getDirectoryContents "/nope") :: IO (Either SomeException [FilePath])
12:13:11 <AndreasL> Hey guys. I know very little about Haskell, but I am planning to start learning it. I was thinking maybe it would be fun to make some web applications in Haskell, as there are actually a few small tools that I'd like to build that would make sense as a web app. What are your opinions of Haskell for (simple) web development?
12:13:42 <codygman> edwardk: Thanks, just saw that!
12:13:56 <kadoban> AndreasL: I really like Hakyll for web dev, but it's less for web apps and more for just static sites.
12:16:52 <AndreasL> kadoban, I see. So what exactly is the role of Haskell in that case?
12:17:16 <kadoban> AndreasL: It's a static site compiler, the DSL you use is in haskell.
12:17:41 <mpickering> There are several frameworks you can tree AndreasL
12:17:55 <phaul> AndreasL: I like snap. There is yesod, which is great and gets you really far really quickly, but somehow after half a year you start regretting not going with snap.
12:18:02 <mpickering> Maybe look at Scotty and Snap for simple solutions
12:18:08 <mpickering> or Servant if you just want to build an API
12:18:44 <ReinH> AndreasL: I'd suggest starting with Scotty
12:18:46 <tremon> mpickering: since I'm at the start of that half year, what's the main benefit of snap over yesod?
12:19:14 <mpickering> I dunno ask phaul :)
12:19:18 <ReinH> AndreasL: It'll be familiar if you've used things like sinatra in Ruby
12:19:29 <tremon> mpickering: sorry
12:19:41 <phaul> :) too much template haskell in yesod
12:20:39 <phaul> yesod is good to get things rolling really quick.
12:23:12 <AndreasL> Forgive my ignorance, if it's a static site generator, would you actually use Haskell for anything if you're not participating in the development of the static site generator?
12:24:04 <wayne> AndreasL: if you are just serving html pages, you don't need to write any programs at all
12:25:11 <kadoban> AndreasL: Yes.
12:25:20 <kadoban> wayne: You don't have to, but it saves a lot of work if you do.
12:25:58 <tremon> phaul: what's the problem with TH? Other than me always losing my way between the various config/model/code files, it hasn't gotten in my way yet. Is it about content getting compiled into the binary?
12:26:36 <wayne> kadoban: how does it save you any work? i said serving html pages, not generating them
12:27:22 <kadoban> wayne: I have no idea if you're talking about the same thing I am. If not, then I don't know what you're saying.
12:27:39 <wayne> haha agreed on that
12:30:12 <AndreasL> kadoban, what exactly are you talking about? I'm slightly confused now
12:31:50 <wayne> AndreasL: if all you want to do is serve static html pages and nothing else, then you can use an existing web server and not write any code at all
12:32:19 <AndreasL> wayne, well, my initial question was whether or not web development is a suitable fashion to get into Haskell :)
12:32:37 <AndreasL> I'm just looking for interesting projects to motivate learning
12:32:48 <Denommus> AndreasL: web development is nice in Haskell
12:32:53 <AndreasL> and I have some need for a few simple web utilities, so I was asking if it made sense to create these utilities in Haskell
12:33:34 <AndreasL> Denommus, I'm getting confused now. What kind of web development is nice? So far I've heard that it is not so suited for dynamic web pages, but rather static sites... But then what exactly would I use Haskell for if I'm developing a web app?
12:33:40 <Denommus> AndreasL: you could try your hand at front-end development with GHCJS or Haste
12:34:02 <AndreasL> Denommus, interesting...
12:34:27 <Denommus> AndreasL: I find it is quite the contrary, I love it for dynamic web pages. Haste even has a framework where the interaction between front-end and backend is seamless
12:34:51 <Denommus> AndreasL: and I love FRP as an approach for GUI development (which includes front-end)
12:35:17 * hodapp tries to figure out how to implement a for-loop with GHC.TypeLits.Nat...
12:35:47 <AndreasL> Denommus, oh, that is interesting
12:37:01 <Denommus> hodapp: mapM_ (\i -> <something>) [0..<max>]
12:37:10 <kadoban> AndreasL wayne: All I mentioned is that Hakyll is a nice tool, which you can check into if you're interested or not. I most certainly didn't say that Haskell isn't good for dynamic web apps or anything of the sort.
12:37:13 <Denommus> hodapp: there, a for loop from 0 to <max>
12:38:08 <Denommus> AndreasL: I don't know exactly which library or framework to use for backend dev, though. Maybe Happstack
12:38:23 <benzrf> Denommus: even better:
12:38:28 <AndreasL> kadoban, sorry, I did not mean to inaccurately paraphrase you. I see now that I misread your initial response. Read 'Haskell' and not 'Hakyll'. Apologies!
12:38:29 <benzrf> :t forM_ [0..x]
12:38:31 <lambdabot> Monad m => (Expr -> m b) -> m ()
12:38:49 <kadoban> AndreasL: Ahh, I see. Not your fault, I seem to have confused other people as well :)
12:40:32 <EvanR-work> forM_ [0..n] $ \i -> putStrLn "you can write C in any language"
12:40:50 <Denommus> forM_ isn't on Prelude :P
12:41:41 <Denommus> > forM_ [0..10] (const . putStr) "you can write C in any language"
12:41:42 <lambdabot>  No instance for (GHC.Enum.Enum GHC.Base.String)
12:41:42 <lambdabot>    arising from the arithmetic sequence ‘0 .. 10’No instance for (GHC.Num.Num...
12:41:42 <lambdabot>    arising from the literal ‘0’
12:42:40 <Denommus> hurr
12:42:41 <Denommus> > forM_ [0..10] $ const . putStr $ "you can write C in any language"
12:42:43 <lambdabot>  <IO ()>
12:42:57 <Denommus> ah, lambdabot doesn't execute IO? Cool.
12:43:16 <kadoban> Yeah, it doesn't.
12:43:22 <sinelaw> No, it doesn't.
12:43:37 <orangecircle> I'm having trouble understanding how StaticArrow from the 'arrows' package allows you to add static information to an arrow. Can anyone shed some light on this?
12:44:14 <orangecircle> it appears to just wrap an arrow in an applicative, but I don't understand why that is helpful
12:45:16 <Denommus> hm, `forM_ [0..10] . const . putStrLn $ "you can write C in any language"` is probably prettier
12:47:36 <EvanR-work> Denommus: well, you need the i in order to do stuff with your for loop, thats why i used a lambda
12:48:07 <EvanR-work> i just didnt use the i
12:48:50 <Denommus> EvanR-work: I'm comparing it to my previous iteration, not yours :-)
12:49:50 <hodapp> @let type SomeNat = 4 :: GHC.TypeLits.Nat
12:49:51 <lambdabot>  Parse failed: Parse error: ::
12:49:58 <hodapp> @let type SomeNat = (4 :: GHC.TypeLits.Nat)
12:49:58 <lambdabot>  .L.hs:154:22:
12:49:59 <lambdabot>      Not in scope: type constructor or class ‘GHC.TypeLits.Nat’
12:50:42 <hodapp> @import GHC.TypeLits
12:50:43 <lambdabot> Unknown command, try @list
12:50:45 <Denommus> orangecircle: isn't it like the State Monad?
12:51:43 <dgpratt> how can I "blow away" the non-global cabal package store (on Windows)?
12:52:10 <hodapp> Denommus: I don't see what your suggestion to me had to do with GHC.TypeLits.Nat
12:52:13 <dgpratt> delete contents of "AppData\Roaming\cabal" ?
12:54:14 <Denommus> hodapp: it doesn't anything to do with it, if you're just playing around I'm sorry :-)
12:54:33 <dgpratt> maybe if someone knew how to delete all the non-global installed packages on linux, I could translate
12:55:00 <orangecircle> Denommus: could you expand on that point a bit please?
12:55:18 <hodapp> Denommus: oh, just curious why you directed it at me
12:56:10 <geekosaur> dgpratt, ~/.ghc on linux (and I suspect the cabal dir is wrong on Windows; it would remove the package contents but leave the package entries, breaking things worse)
12:56:16 <geekosaur> @where sicp
12:56:16 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
12:56:28 <geekosaur> the last link there. read
12:56:34 <dgpratt> thanks geekosaur
12:57:01 <dgpratt> I was really confused why you were looking for SICP
12:57:17 <geekosaur> it's kinda a haskell community joke...
12:57:26 * hodapp slow claps
12:57:47 * dgpratt is happy to be in on the joke
12:58:19 <dgpratt> totes diggin this minimal ghc install thang
12:59:09 <dgpratt> it's cool to be able to build the 'network' package on Windows without involving goat sacrifice
13:03:03 <tolt> Is there a package that allows you to parse a haskell expression into template haskell?
13:05:14 <EvanR-work> does this type have any non bottom inhabitants newtype Hmm = Hmm (() -> Hmm)
13:07:12 <monochrom> oh, I used to joke about it and the US economy back in the financial disaster of 2012. newtype US_Economy = Hmm (Money -> US_Economy)
13:07:22 <monochrom> 2012? 2011? I forgot
13:07:33 <EvanR-work> 2008?
13:07:45 <monochrom> yeah, 2008
13:08:43 <EvanR-work> so i guess no, but i cant seem to prove it
13:08:47 <monochrom> anyway, I was also reading TaPL at that time and learning about equi-recursive types, with the funny example of T = X -> T, which I immediately related to the financial disaster
13:09:11 <EvanR-work> ill check tapl again
13:09:24 <mauke> Hmm (fix (\f () -> Hmm f))
13:10:37 <Iceland_jack> @let newtype Hmm = Hmm (() -> Hmm)
13:10:38 <lambdabot>  Defined.
13:10:41 <Iceland_jack> :t fix (Hmm . const)
13:10:42 <lambdabot> Hmm
13:11:18 <EvanR-work> foo :: Money -> USEconomy
13:11:24 <EvanR-work> foo money = Hmm foo
13:11:33 <EvanR-work> foo money
13:11:51 <EvanR-work> nevermind, i guess this counts?
13:12:12 <EvanR-work> its not bottom?
13:12:45 <quchen> monochrom: Is that joke explainable in the scope of IRC?
13:14:49 <benzrf> quchen: no, it has free variables
13:14:55 <benzrf> which are bound in an outer scope
13:15:21 <quchen> … continue
13:15:43 <quchen> "Reader r" has free variables too, yet it doesn't make me think of the US economy :-þ
13:16:06 <EvanR-work> @src Reader
13:16:06 <lambdabot> Source not found. You type like i drive.
13:16:16 <quchen> Reader = (->)
13:16:20 <EvanR-work> type Reader r = (->) r
13:16:23 <EvanR-work> not recursive
13:17:23 <quchen> Recursive+free variables still don't ring a bell. (It's not going to be funny anymore once it does do, but now I at least want to know what I've missed.)
13:18:00 <benzrf> quchen: i was punning on "Is that joke explainable in the scope of IRC?"
13:18:04 <benzrf> quchen: nothing to do with its content :p
13:18:19 <quchen> Oh.
13:18:19 <d34df00d> Hi!
13:18:22 <benzrf> quchen: the joke being, the explanation refers to things outside of IRC, so it has free variables
13:18:32 <benzrf> ...bound in an outer scope :)
13:18:33 <d34df00d> I am observing quite interesting behavior of ghc.
13:18:35 <benzrf> hello d34df00d
13:18:46 <d34df00d> Given this program: http://melpon.org/wandbox/permlink/5qhCQGXrDh2C44gt (sorry, could not reproduce with anything smaller).
13:19:00 <d34df00d> Compiled with -O0 it runs around 50 ms on a test dataset.
13:19:12 <d34df00d> Compiled with -O2 it runs three orders of magnitude slower, around 75 seconds.
13:19:26 <benzrf> o:
13:20:01 <d34df00d> I've played around a little bit and noticed that either NOINLINE for `filterTopics` or using bang patterns on `cnts` and `topics` fixes the issue, and optimized build becomes, well, optimized and running for around 30 ms.
13:20:15 <d34df00d> Is it an issue in my code, or should I report a bug?
13:20:18 <d34df00d> ghc 7.8.3.
13:20:23 <hodapp> :i sing
13:20:38 <hodapp> :t sing
13:20:39 <lambdabot>     Not in scope: ‘sing’
13:20:39 <lambdabot>     Perhaps you meant one of these:
13:20:39 <lambdabot>       ‘sin’ (imported from Prelude), ‘sinh’ (imported from Prelude)
13:21:20 <quchen> hodapp: Sing? http://hackage.haskell.org/package/singletons-1.0/docs/Data-Singletons-Prelude-Bool.html#t:Sing
13:22:19 <hodapp> quchen: it was formerly in GHC.TypeLits and I'm trying to see how to replace the functionality
13:22:58 <EvanR-work> Iceland_jack: does that count as an "infinite type"
13:23:31 <Iceland_jack> The type itself is recursive, but Haskell doresn't allow direct recursion for types
13:23:37 <quchen> d34df00d: Did you profile it to find out what the critical section is?
13:23:59 <d34df00d> quchen: hm, haven't tried yet.
13:24:08 <d34df00d> What profiling options would you suggest?
13:24:12 <Darwin226> Hey guys. Can someone tell me if there's a typesystem that's fully inferable, but still allows basic overloading? Like, not needing separate functions for checking equality for each possible type.
13:24:27 <mpickering> hodapp: What are you trying to do?
13:25:14 <Iceland_jack> Darwin226: Do you mean like the one used by Haskell?
13:25:14 <Iceland_jack>     (==) :: Int    -> Int    -> Int
13:25:14 <Iceland_jack>     (==) :: String -> String -> String
13:25:20 <quchen> d34df00d: The usual ones, -prof -auto-all, then run with +RTS -P
13:25:51 <EvanR-work> :t a == b
13:25:52 <lambdabot> Bool
13:25:54 <tommd> Unless you are profiling to obtain computation  time information.
13:26:14 <mpickering> hodapp: TypeLits changed significantly from 7.6 to 7.8 iirc
13:26:14 <Darwin226> Iceland_jack: Well, Haskell has typeclasses for overloading and IIRC this prevents total type inference.
13:26:23 <d34df00d> quchen: ok, will do. Tomorrow, unfortunately — that's some code from my job :)
13:26:25 <mpickering> there is probably an easier way to do what you want now
13:26:43 <Darwin226> Iceland_jack: I was hoping to get away with something simpler than typeclasses that still allows for some wiggle room for those things.
13:26:58 <Iceland_jack> Darwin226: Mututally recursive bindings do prevent inferring the principal types but that is a very minor issue
13:28:04 <Darwin226> Iceland_jack: I'm trying to think of an example of how they do. Wouldn't it just get infered to 'a' if nothing more explicit was given?
13:28:38 <EvanR-work> theres also type directed disambiguation, which would let you name all your functions the same thing, but you wont be able to write a polymorphic function that uses it
13:29:13 <EvanR-work> because such a function doesnt exist for every type
13:29:33 <EvanR-work> hence constraints
13:29:41 <homovitruvius> is there documentation to get emacs and haskell working under windows (with all the goodies, flymake/flycheck, hslint, autocompletion, unicode characters  etc)? I have no idea how to start with Windows, but I'd like to do some haskell hacking while on business trip
13:29:47 <Darwin226> EvanR-work: I see. That might be enough though... Can you think of any other case except for equality checking that seems like it would really suck without overloading?
13:29:56 <EvanR-work> uh yeah
13:30:13 <EvanR-work> in fact equality checking seems like a minor thing to want to do most of the time
13:30:27 <Darwin226> EvanR-work: Oh. Right. Functors and everything... Damn
13:32:04 * hackagebot random-fu 0.2.6.2 - Random number generation  http://hackage.haskell.org/package/random-fu-0.2.6.2 (DominicSteinitz)
13:32:10 <Darwin226> EvanR-work: Well I guess I could just bite the bullet and implement typeclasses. It does seem like it makes writing a typechecker exponentially harder...
13:32:25 <EvanR-work> Darwin226: btw, you know type classes are just syntactic sugar for passing the instance around
13:32:45 <Darwin226> EvanR-work: Does that simplify things?
13:32:58 <EvanR-work> you wouldnt have to implement type classes
13:33:57 <Darwin226> EvanR-work: Passing around some object for every overloaded function would get old real fast I think
13:34:12 <EvanR-work> it would be a record of functions/values
13:35:24 <Darwin226> EvanR-work: Wouldn't it mean that my equality checks would look like '2 ==<Number> 2' or something similar?
13:35:50 <Darwin226> EvanR-work: Because that doesn't seem better than having a separate function for each type.
13:37:04 * hackagebot simple-smt 0.5.1 - A simple way to interact with an SMT solver process.  http://hackage.haskell.org/package/simple-smt-0.5.1 (IavorDiatchki)
13:37:29 <EvanR-work> Darwin226: yeah, unless theres some syntax sugar around it
13:38:14 <Darwin226> EvanR-work: Meh. I'm a big boy. I can handle typeclasses. Thanks for the input
13:38:29 <EvanR-work> it wouldnt be Number it would be an argument name
13:38:32 <EvanR-work> but yeah
13:40:08 <EvanR-work> Darwin226: keep the polymorphic case in mind, 2 == 2 is one thing, but x == y in a function with constraint Eq a is another
13:46:48 <Peaker> Hey, the leveldb-haskell package seems to put all its functions in ResourceT. Does that mean that I must put my entire application in ResourceT IO to use leveldb's current bindings? Or communicate with a thread that wraps leveldb?
13:52:02 <c_wraith> Peaker: it looks like you have the option to use anything that you can lift ResourceT IO into..  But other than that, yeah.  You need to at least support that functionality, or run a helper thread.
13:52:44 <Peaker> c_wraith: that's a shitty API :-(
13:53:08 <srhb> Why?
13:53:28 <c_wraith> If you believe you need prompt finalization (I'm not sure this actually needs it), you can't really do better.
13:55:04 <c_wraith> But some people are convinced you always need an option for prompt finalization.
13:55:05 <glguy> Peaker: What's an example of a function you wanted to use that uses ResourceT?
13:55:28 <c_wraith> glguy: https://hackage.haskell.org/package/leveldb-haskell-0.6/docs/Database-LevelDB-MonadResource.html  everything that uses MonadResource?
13:55:38 <c_wraith> glguy: which appears to be most of the api
13:56:35 <glguy> thanks (I don't know the package, so rather than dig through modules I asked)
13:56:56 <c_wraith> Peaker: oh, hey.  You don't have to use that module.  All the functionality appears to be in modules that don't use ResourceT
13:57:09 <Peaker> glguy: open, get, set, etc
13:57:16 <c_wraith> Peaker: check out https://hackage.haskell.org/package/leveldb-haskell-0.6/docs/Database-LevelDB-Base.html
13:57:16 <Peaker> c_wraith: ah, thanks, I'll check it out!
13:57:40 <Peaker> srhb: because that means I need to change my entire application's tpes to fit within the constraints of one of the dozens of libs I use
14:04:10 <karshan> hey, has there been any work done on generating (using templatehaskell I guess) Lens(es) for data types that aren't recodrds ?
14:05:30 <c_wraith> karshan: things like naming get hard...
14:06:17 <jle`> for pure product types i guess you could go with _1 _2 _3 and give them Field1 Field2 Field3 instances etc.
14:06:24 <glguy> You can use http://hackage.haskell.org/package/lens-4.7/docs/Control-Lens-TH.html#g:2
14:06:26 <jle`> not sure what you would do when sums come along though
14:06:38 <glguy> to make lenses for a data type  and not have it be a record
14:07:08 <jle`> oh that's neat
14:07:22 <glguy> You can use generics to make lenses as seen on line 93 here http://lpaste.net/116920#line93
14:07:25 <glguy> for non-records
14:18:08 <karshan> yea thats an interesting question, what should you do with sums. One thought I had is to not generate lenses for those, and use (a ^.. template)
14:18:34 <glguy> You generate Prisms for sums
14:18:46 <karshan> so what is the accepted way to pass a type as a paramater to a function like that. Is it possible to avoid using (undefined :: Type)
14:18:53 <karshan> oh Prisms right
14:19:33 <mauke> Proxy
14:20:36 <SrPx> I don't understand dlists. If the tutorial is correct, then appending 6 dlists, for example, will be equivalent to "([1,2] ++) . ([3,4] ++) . ([5,6] ++) . (...) . []". Of course the "append" function itself is O(1) because it is not doing anything, but when you actually construct the lists you are paying for N transversals at once. No?
14:20:54 <SrPx> $ [] *
14:22:40 <mgsloan> SrPx: It'll be like ( ((1:) . (2:)) . ((3:) . (4:)) ... )
14:22:40 <quchen> SrPx: Yes, concatenating DLists (and forcing their list results) is O(n) in the end. That's better than ordinary lists, which are concatenated in quadratic time in the worst case.
14:23:09 <SrPx> quchen: if it is O(n) in the end, okay, I thought it is O(n*a) in the end.
14:23:10 <quchen> DList on the other hand is always linear, at the cost of having a little indirection.
14:23:15 <mgsloan> Yeah, you'll still pay O(n), but you won't retraverse items
14:23:23 <SrPx> mgsloan: so that means "fromList" is not O(1) right?
14:23:29 <mauke> SrPx: it's O(n) in the total number of elements
14:23:57 <SrPx> I see, makes perfect sense now. Thanks.
14:24:09 <mgsloan> SrPx: Right, (fromList xs) is going be as expensive as (xs ++)
14:29:51 <SrPx> Hmm can I ask about stackage here? I've followed the Quick start on http://www.stackage.org/ - if I understand correctly, it asks for me to cd to ~/.cabal and use those 3 commands. I get this: http://lpaste.net/118442 - any idea?
14:30:39 <geekosaur> that "cabal install" at the end seems wrong
14:30:53 <SrPx> Ah I guess it means per project.
14:31:09 <SrPx> There is also this: http://www.stackage.org/snapshot/nightly-2015-01-14/cabal.config?global=true - not very clear, though. Just adding those lines to cabal.config broke stuff
14:31:10 <geekosaur> yes, that would make more sense
14:31:14 <kadoban> SrPx: If you look on line 12, you're not actually overwriting cabal.config, so the file you're downloading is probably not having any effect.
14:31:41 <kadoban> SrPx: I have no idea if you're supposed to overwrite, but you're not, so the new file is a no-op.
14:31:58 <SrPx> kadoban: it doesn't seem like that is what I should do, though - I renamed as to make that file my cabal.config and cabal broke
14:32:50 <kadoban> SrPx: Well, it seems to say you should put them in you cabal.config at least
14:33:16 <kadoban> SrPx: I suspect there's more to do though.
14:33:52 <SrPx> I can't even install anything with cabal after I installed cabal 1.23.0.0 and ghc 7.10 ... http://lpaste.net/118443 weird
14:34:02 <kadoban> SrPx: (note the comment at the top re: remote-repo lines for instance.
14:34:05 <kadoban> )
14:34:14 <SrPx> yep done that too :(
14:34:48 <kadoban> SrPx: You probably have to start from scratch with stackage, I think? Like clear out your installed packages to have it make much sense?
14:34:49 <luite> SrPx: you shouldn't install cabal 1.23 unles you want to do cabal dev, use the 1.22 branch
14:35:16 <SrPx> aw. okay.
14:35:25 <SrPx> there I go
14:35:27 <SrPx> thanks
14:35:34 <kadoban> I'm going to shut up now though, because I only did that stuff once and I didn't end up using stackage, because it didn't have a package I use.
14:36:00 <Guest69927> idk how I would get anything done without template haskell
14:36:57 <SrPx> kadoban: you can still use it though, can't you? It allows installing outsider packages
14:37:06 * hackagebot CCA 0.1.5.1 - preprocessor and library for Causal Commutative Arrows (CCA)  http://hackage.haskell.org/package/CCA-0.1.5.1 (PaulLiu)
14:37:53 <kadoban> SrPx: I think so, yeah, but...I wasn't sure what exactly I was gaining if I was doing that, so I didn't bother.
14:38:05 <luite> SrPx: that older linear being installed also looks suspicious, if you use an unreleased compiler, expect only the latest version of packages to work (if any version at all). try adding a constraint to see what's holding it back
14:38:13 <SrPx> I see! But you have no problems installing things with cabal?
14:41:35 <`^_^v> i asked this yesterday but left before i could see the answer -- is IO the only well known monad that can't be implemented in regular haskell?
14:42:28 <quchen> Some people would argue that IO *is* implementable in regular Haskell.
14:42:28 <geekosaur> STM needs some primitives as well, I believe?
14:42:39 <quchen> FWIW, STM and ST come to mind as similar constructs.
14:43:53 <`^_^v> how could you implement it, quchen?
14:44:51 <quchen> *I* could not, but the general idea is that you can write a DSL that has a 1:1 mapping to IO and that's fully pure. (Including exceptions, threading and so on.)
14:45:21 <Bor0> speaking of isomorphism, not sure if I understand this correctly. f (Just x) = x and g x = Just x. does this mean that f is isomorphic to g?
14:45:42 <c_wraith> Bor0: no, they go opposite directions.  Check their types
14:46:01 <c_wraith> @type let f (Just x) = x in f
14:46:02 <lambdabot> Maybe t -> t
14:46:18 <c_wraith> @type let g x = Just x in g
14:46:19 <lambdabot> a -> Maybe a
14:46:58 <c_wraith> Bor0: they are inverses of each other, though
14:47:27 <Bor0> wikipedia says that isomorphism is a homomorphism that admits an inverse. in that case, what does isomorphism mean?
14:47:28 <c_wraith> Bor0: though f isn't total - it'll crash on some input.  Just not on anything that was an output of g
14:49:14 <c_wraith> Bor0: an isomorphism is (in this case) a function that preserves all input structure.  You *could* argue that f and g are each isomorphism..  Though you have to be very careful about what sets you're talking about as the domains and codomains
14:50:06 <starless> Is pattern matching directly on parameters vs. case expressions discouraged? If not, was it ever?
14:50:27 <quchen> The objects in question are "a" and "Maybe a". You're asking whether the arrows "f :: a -> Maybe a" and "g :: Maybe a -> a" are isomorphic, which isn't the right thing to ask here. Objects are isomorphic if there's a pair of arrows between them, call them "ff" and "gg" such that "ff.gg = id_A" and "gg.ff = id_B".
14:50:30 <c_wraith> starless: some people hate it.  It's not a common opinion, though.
14:50:45 <starless> c_wraith: any insight as to why?
14:51:33 <Javran> I used "-auto-all -caf-all -prof" to compile a program, and ran it with "+RTS -s -p", turns out it took 55.3% GC time, wondering what I can do to make it faster
14:51:43 <quchen> An isomorphism would be "`a` and `Identity a` are isomorphic via the arrows `Identity` and `runIdentity`", for example.
14:51:53 <c_wraith> starless: dislike of the repetition of the function name, belief that the pattern-matching rules for multiple arguments are less clear than a case on each argument
14:52:00 <quchen> You cannot have an isomorphism between `a` and `Maybe a` because you'd have no place to map the Nothing to.
14:52:06 * hackagebot simple-smt 0.5.2 - A simple way to interact with an SMT solver process.  http://hackage.haskell.org/package/simple-smt-0.5.2 (IavorDiatchki)
14:52:07 <Javran> http://lpaste.net/3400038476794560512 here is my program
14:52:18 <c_wraith> quchen: you can have an argument between a and Maybe a \ Nothing, though
14:52:31 <c_wraith> quchen: err, isomorphism
14:52:40 <quchen> c_wraith: Sure, that'd be "a ≅ Identity a` though
14:52:59 <quchen> (I should really decide on a standard quote character at some point.)
14:53:13 <c_wraith> Or at least stay consistent within a single line. :P
14:53:23 <quchen> FREEDOM!
14:53:31 <Bor0> so we can say that 'x' and 'Maybe x' are isomorphic via f and g?
14:53:35 <starless> c_wraith: The purported reduction in clarity is because pattern matching can hide parameter names, yes?
14:54:07 <c_wraith> starless: I thought it had more to do with understanding order of evaluation of complex pattern matches, which can matter for strictness properties
14:54:33 <quchen> Bor0: No, they are not isomorphic. You cannot have an isomorphism between "a" and "Maybe a", because that would require a function "foo :: Maybe a -> a", which does not exist (... because of "what is `foo Nothing`").
14:54:57 <Bor0> quchen, oh. I understand. so it doesn't work just for this specific case because foo isn't total?
14:55:13 <Bor0> i.e. foo isn't total for foo (Just x) = x
14:55:17 <c_wraith> Bor0: your two functions are inverses, but not between 'x' and 'Maybe x'.  They're between 'x' and 'Maybe x - Nothing'
14:55:39 <quchen> Bor0: We like to pretend there is no ⊥ a lot of times, i.e. consider only "total Haskell".
14:55:47 <deech> Hi all, I have a cabal file with multiple Executable components. How do I build just one of them? `cabal build <executable-name>` did not work.
14:56:01 <quchen> Either () a  is isomorphic to  Maybe a  as well, but only if you ignore ⊥.
14:56:03 <Bor0> c_wraith, I see. in the case they were inverses between 'x' and 'Maybe x', is it okay to say that they are isomorphic?
14:56:18 <starless> c_wraith: Thanks for your help so far. Do you mind giving me an example of what you just stated?
14:56:24 <Bor0> c_wraith, by "in the case" I mean "if we assume that"
14:56:26 <quchen> Bor0: Like I said, `a` is isomorphic to `Identity a`.
14:56:43 <quchen> And `Identity a` is `Maybe a` without `Nothing`.
14:56:44 <c_wraith> Bor0: no, that still sounds weird.  The functions are not isomorphic to anything - they're the witnesses of the isomorphism between the sets of values
14:56:45 <dcoutts_> deech: with new enough cabal, that works, cabal build <component>
14:57:32 <Lokathor> so a monad type is always a polymorphic type, right?
14:57:46 <Bor0> c_wraith, so isomorphism is on type level, not on function level? or does that question make no sense at all
14:57:58 <c_wraith> starless: well, there was recently a proposed change to zipWith that broke lots of code that depended on the exact pattern-matching order, and the author of the proposal didn't realize that people depended on that order.
14:58:19 <deech> dcoutts_: I have 1.20, and `cabal build --help` seems to indicate it is possible but `cabal build <executable-name>` gives `Unrecognized flags`.
14:58:57 <c_wraith> starless: the current code is (like) zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys ; zipWith _ _ _ = []
14:59:17 <c_wraith> starless: and it's a common idiom to do things like zipWith (+) xs (tail xs)
14:59:35 <Lokathor> OMG
14:59:38 <quchen> ?quote zip`ap`tail
14:59:38 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
14:59:43 <Lokathor> c_wraith, that would have helped me days ago
15:00:04 <johnw> Lokathor: any Monad is always a type former, is another way to put it
15:01:16 <c_wraith> starless: now consider what happens with (\xs -> zipWith (+) xs (tail xs)) []
15:01:35 <Lokathor> sum (zipWith distBetween pointsList (tail pointsList)) is exactly what i was trying to say in a thing i was doing
15:01:58 <Lokathor> instead i got lost trying to do an insane foldr
15:02:06 <c_wraith> starless: because pattern-matching is done right-to-left, the pattern match fails before it attempts to evaluate (tail [])
15:02:07 * hackagebot cabal-debian 4.20.1 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.20.1 (DavidFox)
15:02:24 <c_wraith> starless: which is good, because it prevents crashing with that common idiom
15:03:02 <c_wraith> starless: But it depends on the pattern match happening in the correct order - and the ordering is semi-hidden in the implicit ordering for multiple pattern-matches in a single equation
15:03:27 <c_wraith> starless: some people really dislike that, and would rather the ordering of the pattern matches be made more explicit with nested cases.
15:04:18 <starless> c_wraith: That makes sense. Thank you very much.
15:05:32 <DanielDiaz> if I upload a package accidentally to Hackage, is it possible to delete it?
15:05:52 <johnw> sadly, no
15:05:57 <c_wraith> Lokathor: to follow up on johnw's comment: a type that is an instance of Monad must always accept a type argument.  To be technical, the type must have the kind (* -> *)
15:05:57 <johnw> you can mark it as deprecated, though
15:07:01 <DanielDiaz> johnw: that got me upset
15:07:06 <DanielDiaz> : (
15:07:07 * hackagebot binary-store 0.1.0.1 - Format to store data using the binary transform.  http://hackage.haskell.org/package/binary-store-0.1.0.1 (DanielDiaz)
15:07:08 <c_wraith> Lokathor: learning about the kind system can really help make things like that easier to understand.  Do you have any experience with it?
15:07:21 <DanielDiaz> it even gets announced : (
15:09:40 <johnw> DanielDiaz: monad-bool is forever my shame on Hackage :)
15:10:06 <Lokathor> c_wraith: I read the section about kinds in Learn You A Haskell, but it seemed a little bit more arcane than the level I was working with at the time
15:10:11 <ReinH> bergmark: ping
15:10:52 <c_wraith> Lokathor: it's a bit abstract, but it's not all that complex.  (Unless you start turning on extensions)  * is the kind of all types that can have values.
15:11:04 <c_wraith> Lokathor: so..  5 :: Int :: *
15:11:13 <c_wraith> Lokathor: Just 5 :: Maybe Int :: *
15:11:50 <c_wraith> Lokathor: there are no values of the type 'Maybe' alone, though - because it's the wrong kind.  It has the kind (* -> *).
15:12:37 <Lokathor> Yeah, I understood that much. Like many things in haskell though, I wasn't seeing where I'd apply that knowledge in a situation while writing a program
15:13:06 <c_wraith> Lokathor: well, you can derive information from kinds.  like, "class Monad m where return :: a -> m a"
15:13:50 <c_wraith> Lokathor: you know that the arguments of (->) must have the kind *.  After all, functions take values and return values.
15:13:55 <Javran> is a haskell program taking 55% GC time normal?
15:14:15 <Bor0> like you get information for a function from its type, you can get information about a type from its kind :)
15:14:16 <benzrf> Javran: i hope not
15:14:28 <Lokathor> 56% GC time doesn't sound normal in any language unless you're trying to average more memory than your system supports
15:14:28 <c_wraith> Lokathor: so from that, you know that the type a must have kind *.  Furthermore, you know that the type m is applied to a type variable with kind * and that application results in a type with kind *
15:14:51 <c_wraith> Lokathor: From that, you can get that m must have the kind * -> *
15:15:20 <Javran> benzrf: I try to optimize it, but so far I have no clue about how these graphs can help
15:15:22 <Lokathor> I suppose I mostly follow that.
15:15:25 <c_wraith> Lokathor: and yes, that does imply a degree of polymorphism - but it's polymorphic in a very specific way - it takes a type argument that can be anything
15:15:58 <Lokathor> dare i ask: are there other types of polymorphism?
15:16:17 <Javran> benzrf: this one for example http://i.imgur.com/f8A9yJu.png
15:18:33 <EvanR-work> Lokathor: there are polymorphic functions whose arguments cant be just *anything*
15:18:43 <EvanR-work> :t (+)
15:18:44 <lambdabot> Num a => a -> a -> a
15:19:05 <Lokathor> ahhh, so the less general forms count as seprate forms. alright then.
15:19:13 <Javran>  http://lpaste.net/3400038476794560512 this is my program, I have no clue about what's going wrong but suspect map insertion is too lazy.
15:20:41 <EvanR-work> Lokathor: in the kind (* -> *) -> *, the argument cant be just anything either
15:20:51 <c_wraith> Lokathor: you can also look at specific kinds, and know that you can't put certain types in.  So you know something about the shape of the polymorphism.  Monad is an example of this - you know that the type variable m must have the kind * -> *, so you know you can't put a type variable with the kind * in m's place
15:21:59 <Lokathor> or a * -> * -> * I suppose
15:22:00 <Peaker> haddock forcing us all to use arrows-in-left style is annoying! :(
15:22:45 <c_wraith> Lokathor: not unless it's partially applied, anyway.
15:22:54 <c_wraith> Lokathor: for instance, Either has the kind * -> * -> *
15:23:12 <Lokathor> but Either () a is like Maybe a, that got mentioned above
15:23:18 <c_wraith> Lokathor: so the Monad instance for Either starts out instance Monad (Either a) where...
15:23:41 <c_wraith> Lokathor: notice that the type variable a appears there to get the type's kind to match
15:24:24 <Lokathor> yeah, so type variables in instances count as part of the overall type
15:24:51 <Lokathor> like how [] is polymorphic, but [a] counts as a concrete type?
15:25:51 <Lokathor> EvanR-work: I'm having a hard time thinking of what the declaration of something with a kind of (* -> *) -> * would look like
15:26:11 <c_wraith> Lokathor: newtype Foo m = Foo (m Int)
15:26:50 <Lokathor> so... you could make a Foo IO and it'd be constructed as a Foo (IO Int)?
15:27:19 <c_wraith> yes
15:27:41 <c_wraith> though that description is a bit hand-wavey. :)
15:28:21 <mmachenry> Does anyone know why I am getting an "unknown config option" error when updating to the new cabal-1.22 from 1.20? http://lpaste.net/118444
15:29:21 <Lokathor> I don't entirely mind hand-wavey with haskell :3 it seems that, unlike with other languages, it's often enough for the compiler to accept the program you write, and it'll probably end up correct right away
15:29:30 <geekosaur> I think that's a known bug, reported yesterday and fixed in head
15:29:33 <Lokathor> instead of having to test it as throughly after compilation
15:29:46 <tommd> Javran: It's your modify line.  Try unfolding it manually and you will see 95% utilization. For example, (\(m,bi) -> let mp = M.insert n l m in let p = update bi in mp `seq` p `seq` (m,p))
15:29:47 <c_wraith> Lokathor: a less-handwavey description would be something like  "Foo (return 5 :: IO Int) :: Foo IO"  It's short and technical, but it's also precise. :)
15:30:17 <geekosaur> new Cabal uses just --enable=profiling, cabal-install needed to check Cabal library versions to determine which ones to use
15:31:23 <Lokathor> oh speaking of cabal stuff, I sometimes get warning about "unknown option --with-gcc" from cabal packages. They seem to build anyway, so should i be worried about that or not?
15:31:38 <mmachenry> geekosaur: Will that be pushed to Hackage soon?
15:31:46 <geekosaur> mmachenry, I don't know
15:31:46 <mislav>  /exit
15:32:00 <c_wraith> Lokathor: the thing is, the precision is meaningless without the underlying handwavey bit to get you starting to think the right thing.  So handwavey has its place.
15:32:30 <geekosaur> don't really want to ping dc*utts but suspect he's the one who can answer :/
15:32:53 <Lokathor> ah, yes, I've read that about how humans work. We psychologically build abstractions out of many concrete examples, not the other way around.
15:35:13 <c_wraith> geekosaur: great.  Now I need to add all sorts of wildcards for censored variants of my nick. :P
15:35:30 <geekosaur> :p
15:35:34 <c_wraith> (not that anyone talks about me when I'm gone)
15:36:47 <Lokathor> c_wraith: I'll be sure to wait until I think you're gone and then compliment your excellent haskell-explaining skills by name
15:37:53 <Javran> tommd: thanks, that helps reducing GC time to 36.9%! how did you figure that out?
15:38:19 <mpickering> How can I debug happy type errors?
15:38:42 <host46> hi guys, quick one, I'm getting linking error when declaring an empty instance (of class with a single method with default implementation), so the instance it's supponse to take that default method
15:38:46 <host46> dist/build/libHSbtcwatch-0.1.0.0.a(Vircurex.o):(.data+0x480): undefined reference to `btcwatchzm0zi1zi0zi0_NetworkziBitcoinziFeedziProviderziInternal_DZCProvider_static_info'
15:38:58 <Guest69927> There's a problem with quotation mark escaping in the documentation on: https://hackage.haskell.org/package/HUnit-1.2.5.2/docs/Test-HUnit.html
15:39:12 <host46> my empty instance is simply this: instance P.Provider Provider
15:39:23 <c_wraith> Guest69927: best to report that as an HUnit bug.  Not sure any of its maintainers are here
15:39:29 <host46> how is it possible that ghc type checks, but the linked fails?
15:39:40 <host46> *linker
15:39:50 <c_wraith> host46: is that an older version of GHC?
15:40:00 <Guest69927> c_wraith: Thanks, I'll look for where I can do that.
15:40:18 <host46> c_wraith: GHCi, version 7.8.4
15:40:59 <c_wraith> Guest69927: http://sourceforge.net/p/hunit/bugs/ seems to be the official place
15:42:12 <c_wraith> host46: so no.  Not an issue with an older version of GHC.  I'm not sure, then.  Did you try a cabal clean?
15:42:42 <host46> c_wraith: yup, I'm using cabal sandboxes, so I tried with a clean environment
15:42:58 <host46> c_wraith: but I'm not doing anything wrong right?
15:43:33 <host46> c_wraith: I guess I should try to minimize the case and submit a bug report, this seems like a bug, isn't?
15:43:40 <c_wraith> host46: No, that looks like some sort of environment bug.  I have no ideas about the details.
15:44:57 <host46> c_wraith: ok, thats helpful, thanks for the tip ;)
15:45:08 <Javran> tommd: oops, the result should be (mp,p) not (m,p), after I correct this one the GC time is still around 50%
15:51:26 <SrPx> Does anyone know why gloss is failing to compile? http://lpaste.net/118445
15:53:12 <phaazon> has someone seen edwardk around?
15:53:19 <benzrf> phaazon: i saw hi m
15:53:38 <phaazon> I pushed a PR into his either repo, on github
15:53:39 <benzrf> in the lens channel in my scrollback logs
15:53:40 <host46> c_wraith: about reseting the environment, I removed ~/.ghc ~/.cabal and it still doesn't link, anything else I can wipe out?
15:58:34 <dgpratt> I'm getting a bizarre error trying to cabal install language-javascript (on Windows)
15:58:39 <lpaste> dgpratt pasted “language-javascript install error” at http://lpaste.net/118446
15:59:23 <dgpratt> I say bizarre because I don't know where it's coming up with that path -- "IEUser" means nothing to me
15:59:31 <dgpratt> any ideas?
16:03:54 <mmaroti> can I store a dictionary for (Show a) together with a value of type a so that I can use the value later where the show dictionary is needed?
16:06:16 <tommd> mmaroti: Hopefully you can simply store the function and not the dictionary, `(show, a) :: (a -> String, a)`.  If not then consider the `constraint` package for use with monomorphic types: `(Dict :: Dict (Show A), A)`.
16:06:44 <mmaroti> I cannot store the show function
16:07:43 <mmaroti> is this valid: "data Showable a where Showable :: Show a => a -> Showable a"?
16:08:01 <jle`> mmaroti: you can make your own dictionary type or tuple
16:08:13 <jle`> an :i Show on ghci will show what you need
16:08:29 <mmaroti> But I cannot, because I want to pass the value further to functions that expect showable values
16:09:00 <pavonia> dgpratt: Is there such a user profile IEUser on your system?
16:09:12 <jle`> mmaroti: would it work to have a Show instance for that?
16:09:13 <dgpratt> pavonia, no
16:09:40 <mmaroti> The above GADTs declaration seems to work, but it is very strange
16:09:57 <jle`> what kind of usage do you want?
16:10:24 <pavonia> dgpratt: Can you try to build with -v3 enabled? Maybe that gives more information
16:11:20 <dgpratt> pavonia, I will try that at some point, thanks for the suggestion
16:11:58 <dgpratt> I am wondering if this represents a bug in the minimal ghc installer
16:12:09 * hackagebot stripe 0.8.3 - A Haskell implementation of the Stripe API.  http://hackage.haskell.org/package/stripe-0.8.3 (LukeHoersten)
16:13:01 <dgpratt> I wonder if the version of alex and/or happy included in that installer were perhaps configured/built under a profile with that name
16:13:59 <pawiecki> hello!
16:17:09 * hackagebot ghc-syb-utils 0.2.3 - Scrap Your Boilerplate utilities for the GHC API.  http://hackage.haskell.org/package/ghc-syb-utils-0.2.3 (ThomasSchilling)
16:18:49 <dmj`> pawiecki: hi
16:23:34 <SrPx> Does anyone know why gloss is failing to compile? http://lpaste.net/118445
16:26:14 <SrPx> Is there any way to force cabal to ignore if a package lists "base == 4.7.*", but you actually have "base 4.8.x" ?
16:26:42 <SrPx> I'm trying to install gloss from source and it fails because of that, but seems like it is warmless... I could at least try
16:26:50 <dcoutts> yes, --allow-newer=base
16:27:19 <dcoutts> SrPx: ^^
16:27:59 <SrPx> dcoutts: thank you! Now upload the tarball of ghcjs!!
16:28:00 <SrPx> jk :P
16:29:25 <luite> i'd be somewhat surprised if dcoutts uploaded the first ghcjs release to hackage :)
16:29:34 <dcoutts> so would I ;-)
16:29:48 * dcoutts did what!!?!
16:30:33 <SrPx> hmm... seems like Repa breaks with the new base due to an ambiguous occurrence of ‘traverse’. Didn't even know prelude had traverse now. Well
16:30:52 <SrPx> I'm certain people have base 48 and repa installed on their machines so what am I missing on the party ? :(
16:31:49 <dgpratt> confirmed, the path containing "IEUser" is embedded in this version of happy/alex
16:32:10 * hackagebot simple-smt 0.5.3 - A simple way to interact with an SMT solver process.  http://hackage.haskell.org/package/simple-smt-0.5.3 (IavorDiatchki)
16:32:42 <dgpratt> I tried to cabal install alex and then happy in a sandbox, but...they seem to reference each other?
16:32:54 <dgpratt> bit of the proverbial catch-22
16:33:04 <mpickering> dgpratt: cabal install alex happy
16:33:09 <yulate> Hi, I got this to compile (finally) and its output was only a yellow circle :/  If the other shape names are defined types according to the Diagrams.TwoD (and .Transform .TrailLike) classes then how do I initiate(?) these shapes to show? Since they are already types, right?
16:33:17 <lpaste> dgomez pasted “Diagram 10” at http://lpaste.net/118447
16:33:39 <Lokathor> my cabal (1.14) doesn't have sandbox >_>
16:33:42 <dgpratt> mpereira, good suggestion, thanks :)
16:33:51 <yulate> Does the method main :: IO () affect this since the default is cove?
16:35:34 <dmj`> how do I dump generated FromJSON instances from GHC.Generics ?
16:37:33 * SrPx is so confused right now
16:38:33 <glguy> dmj`: GHC.Generics doesn't generate code, it is code
16:38:37 <glguy> you just look at the instances
16:39:00 <SrPx> Listen
16:39:02 <glguy> If you want to see what the core looks like you can do it the same way as any other function with flags like: -ddump-simpl or using the ghc-core tool
16:39:26 <SrPx> can I downgrade to base 4.7?
16:39:50 <glguy> base 4.7 comes with GHC 7.8
16:39:56 <SrPx> seems like REPA isn't updated for base 4.8 yet
16:40:08 <SrPx> glguy: can I have ghc 7.10 and base 4.7?
16:40:22 <glguy> 7.10 isn't even out yet
16:40:40 <glguy> also, no, you can't
16:41:39 <SrPx> well I will downgrade to 7.8.4 then :(
16:41:41 <SrPx> thank you
16:42:01 <glguy> That's a good idea. 7.10 is in prerelease for testing, It's not meant for general use
16:42:46 <SrPx> someone suggested me to update to 7.10 before installing ghcjs but well
16:43:11 <geekosaur> ghcjs is also prerelease for testing, I believe
16:43:25 <geekosaur> if you're not set up to deal with problems, you probably don't want to mess with it
16:43:27 <lpaste> Hermit pasted “Transformers refactoring” at http://lpaste.net/118448
16:43:45 <Hermit> I need some help with transformers. I'm messing with conduits and found a refactor unexpectedly difficult to get right. Maybe I'm missing something
16:43:51 <Hermit> Just pasted the link
16:43:51 <geekosaur> actually I don't think ghcjs is even that far along...
16:45:49 <gfixler> is there a way to paginate :browse in ghci?
16:47:10 * hackagebot bitstream 0.2.0.4 - Fast, packed, strict and lazy bit streams with stream fusion  http://hackage.haskell.org/package/bitstream-0.2.0.4 (MasatakeDaimon)
16:47:16 <zwer> yulate yes.. do `defaultMain larry' or `defaultMain lolly' to draw different things
16:48:49 <Apocalisp> Are there any interesting anamorphisms from a comonad into a cofree comonad?
16:49:23 <mpickering> Is there any good way to debug a happy parser?
16:49:54 <Apocalisp> edwardk ^^
16:50:07 <dmj`> glguy: how do I just look at the body of "instance FromJSON MyADT" ? I don't want to look at core, I'd like to look at haskell
16:50:14 <dmj`> glguy: if possible
16:50:57 <geekosaur> it doesn't work that way
16:51:18 <geekosaur> there is a generic FromJSON instance which uses generic traversals
16:51:21 <glguy> dmj`: You're using the default implementations, so look at http://hackage.haskell.org/package/aeson-0.8.0.2/docs/src/Data-Aeson-Types-Class.html#FromJSON
16:51:46 <geekosaur> if you don't understand how generics works, then the instance won't make much sense to you
16:51:57 <glguy> So the body of your FromJSON.parseJSON method is parseJSON = genericParseJSON defaultOptions
16:52:11 <Hermit> Cale: are you around?
16:52:17 <luite> for the record. using ghc 7.10 makes it easier to install ghcjs (which also doesn't have a stable release yet) since 7.10 comes with a Cabal library that supports GHCJS, it avoids the situation with multiple incompatible Cabal versions. but don't install 7.10 for general use yet, unless you intend to fix lots of packages yourself (and report problems)!
16:52:37 <jle`> thanks luite
16:53:45 <luite> also Cabal 1.22 is still a tad flaky, patch release should come soon
16:54:34 <bergey> xb
16:55:03 <jle`> ghcjs has always been my primary motivation for upgrading
16:55:17 <Hermit> sclv
16:55:49 <sclv> ?
16:58:12 <Lokathor> while trying to update cabal, given a fresh install of the Haskell Platform, it tells me that it can't "cabal install cabal-install" because it can't find Network.TCP or Sytem.Random
16:58:15 <dmj`> guess I'll go read up on generics, or just keep eliminating fields until my parser workds
16:58:27 <Hermit> sclv: need some help here, can I bother you a bit?
16:58:45 <Lokathor> if I had the Haskell Platform installed before, could old data from that be messing up my new install?
16:58:46 <Hermit> sclv: http://lpaste.net/118448
16:59:15 <sclv> i'm absolutely the wrong person to ask about that paste :-(
16:59:22 <sclv> not really that familiar with conduit stuff
17:00:19 <athan> In the category of constraints, what is the terminal object?
17:00:34 <Hermit> no problem
17:01:38 <yulate> zwer: sorry in a conference call, but I will play around with that. thank you
17:01:48 <athan> (isn't edwardk's constraint's `bottom` in the category of entailment of constraints?)
17:02:14 <jle`> dimap's arguments are backwards :'(
17:02:34 <johnw> Hermit: what is the question?
17:02:34 <sclv> athan: i'd think that the terminal object would be the empty set
17:02:40 <sclv> and that there would be no initial object
17:03:01 <Hermit> johnw: http://lpaste.net/118448  It's a transformers refactor problem that's driving me nuts
17:03:14 <glguy> jle`: backwards relative to what?
17:03:18 <johnw> Hermit: how so?
17:03:20 <jle`> function composition
17:03:22 <johnw> can you show me the error?
17:03:26 <athan> sclv: Nuh uh! () => everyhting!
17:03:27 <jle`> h . g . f
17:03:30 <jle`> is dimap f h g
17:03:33 <Hermit> johnw: stuff like this: (MonadState
17:03:35 <athan> erm () => forall a. a
17:03:35 <Hermit>                        (ResumableSource (StateT s Data.Functor.Identity.Identity) a)
17:03:37 <Hermit>                        (StateT s Data.Functor.Identity.Identity))
17:03:37 <jle`> how whack is that
17:03:46 <Hermit> johnw: described the objective in the paste
17:03:46 <johnw> Hermit: can you use lpaste to show me the full error?
17:03:47 <sclv> ok, then i'm backwards :-)
17:03:56 <athan> :P
17:04:00 <athan> I think it's a refutation
17:04:05 <jle`> \g -> h . g . f
17:04:06 <athan> like Bar ~ Baz
17:04:12 <jle`> is (dimap f h)
17:04:15 <athan> is one example
17:04:17 <jle`> you would expect it to be dimap h f
17:04:19 <athan> on non-deducability
17:04:33 <Hermit> johnw: ok, hang on a second.
17:04:52 <athan> or*
17:05:32 <jle`> in addition, (. f) is lmap, and (h .) is rmap
17:05:39 <mpickering> what does "token" mean in the happy debugging output?
17:05:41 <jle`> everything is all wrong
17:05:44 <jle`> :'(
17:05:53 <jle`> (h .) puts h on the left
17:05:55 <jle`> and is rmap
17:06:00 <jle`> (. f) puts f on the right
17:06:08 <jle`> and is called lmap
17:06:59 <jle`> nobody mind me, i complain about this here every few weeks
17:07:01 <jle`> :)
17:07:15 <lpaste> Hermit annotated “Transformers refactoring” with “Transformers refactoring (annotation)” at http://lpaste.net/118448#a118449
17:07:21 <Hermit> johnw: there
17:07:34 <sclv> athan: no i was right!
17:07:41 <sclv> look at "top" and the haddock: "These are the terminal arrows of the category, and () is the terminal object."
17:07:43 <sclv> :-P
17:08:12 <sclv> the initial object is bottom
17:08:16 <johnw> so, you want a Sink over a transformer over a monad *and* a transformer that are able to act as State for a ResumableSource?
17:08:20 <athan> !!!
17:08:21 <athan> crap
17:08:22 <sclv> which really shouldn't be there :-)
17:08:27 <athan> I need to go back to gradeschool
17:08:42 <sclv> nah, you're correct in the opposite category :-P
17:08:43 <johnw> I have a feeling this is not possible
17:08:58 <SrPx> http://lpaste.net/118450 does anyone know what this error means?
17:09:15 <johnw> would 't m' and 'm' refer to different ResumableSources?
17:09:16 <athan> haha
17:10:12 <johnw> also, you'll need to pass a stateful action to run, which CL.take is not
17:10:18 <johnw> *and* you'll need to runState
17:10:23 <johnw> if I'm reading this right
17:11:44 <jroesch> .L
17:12:04 <jroesch> ohps my bad :) hit the keyboard
17:12:09 <geekosaur> SrPx: looks to me like you have packages from a different ghc install sitting in the package database and confusing cabal
17:12:12 <Hermit> johnw: I'm dizzy at this point, been at it for the past 3 days. Maybe I'm just unaware of transformers subtleties or this is just not possible. I figured something may be out of hand when tried to declare a StateT signature, it ended up in an infinite type
17:12:14 <zq> ugh, i just love it when research papers are riddled with errors
17:12:34 <SrPx> geekosaur: makes sense, how can I completely clean every package installed?
17:12:42 <Hermit> hmm
17:12:44 <huonw> Is the low-level layout of `data` guaranteed in the standard (or in GHC, I suppose) in anyway? (particularly, `data`s containing only unboxed types)
17:12:47 * Hermit goes at it again
17:12:52 <johnw> Hermit: yeah, I think that doing this would turn you inside out
17:12:55 <SrPx> I had ghc 7.10, installed a few packages, downgraded to 7.8 but didn't reinstall cabal clean
17:13:18 <geekosaur> um. remove ghc completely, remove /usr/lib/ghc and ~/.ghc (assuming unix, dunno the correct locations for windows), reinstall ghc
17:13:46 <geekosaur> you can't truly "remove every package installed" because some of them are part of, and come with, ghc
17:14:09 <johnw> i mean, you have a monad 'm', able to represent a State, whose state is a transformer action over that same monad, which you wish to 'get' and then bind in the context of that base monad 'm'.
17:14:24 <johnw> The easiest way to find out if this is even possible to *greatly* simply this
17:14:25 <geekosaur> and I am worried because it's talking about reinstalling base which is (among other things) the ghc runtime and cannot be removed or reinstalled or replaced without breaking ghc completely
17:14:41 <luite> C:\Users\username\AppData\Roaming\ghc typically
17:14:42 <johnw> try doing this same thing using IO, StateT and IdentityT
17:14:52 <johnw> so, no MonadState, no abstraction over any 'm', and without conduits
17:15:11 <Hermit> johnw: you were right about the two resumable sources, I fucked up and forgot a "lift" there, the signature is simpler now, but still troublesome
17:15:13 <geekosaur> come to think of it the unix directory probably depends on the ghc version
17:15:25 <johnw> i mean, how would I even write such a type...
17:15:33 <geekosaur> if you had a 7.8 and then installed 7.10 and then reinstalled 7.8 the original 7.8 install's packages could be confusing things badly
17:15:34 <marchelzo_> In State s a, is "fst `liftM` get" the same as "use _1"? It's not working for me.
17:16:07 <johnw> StateT (IO a) IO a
17:16:12 <johnw> I think that's what you are using, effectively
17:16:19 <johnw> actually, that should work fine
17:16:33 <johnw> you're storing an action that you want to "inject" anywhere within the parent action
17:16:47 <johnw> also, you wouldn't use "lift get" in your example
17:16:53 <johnw> lift is for use with Transformers, not with MonadState
17:17:08 <johnw> you've already said MonadState ... (t m)
17:17:11 <johnw> so just 'get' should work
17:17:46 <johnw> (for example, you have 'lift get', but only 'put')
17:17:48 <johnw> anyway
17:18:30 <johnw> oh, wait, I'm starting to think I see what you're doing
17:18:34 <johnw> let me try my hand at it
17:21:34 <johnw> Hermit: this typechecks: https://gist.github.com/930324975df5f26aab88
17:22:34 <lpaste> Lokathor pasted “cabal install problem” at http://lpaste.net/118451
17:23:21 <Lokathor> so i uninstalled haskell platform, cleared out the old files from appdata, installed it again, updated cabal, and then try to update to the newest cabal-install and it gives me that error
17:24:02 <sclv> athan: read "entails" as "means it is necessarily the case that"
17:25:04 <sclv> and from that we can see right away () "means it is necessarily the case that" nothing but (), and furthermore that from any other constraint it is "necessarily the case that" (), and finally since the category of constraints is "thin" we don't have to worry about unique arrows...
17:25:42 <kuribas> Is it possible to store and use a pure haskell data in c?
17:26:00 <Hermit> johnw: omg, you made it
17:26:13 <Hermit> johnw: how... why is the lift in the conduit
17:26:17 * Hermit tries to understand
17:26:24 <kuribas> For example: "data MyData = ..."  Then store a MyData variable in a c variable and call haskell functions.
17:26:28 <athan> sclv: Ahh man, I'm an idiot ><
17:26:34 <luite> kuribas: you can refer to your haskell data through stable pointers
17:27:03 <kuribas> luite: ok, thanks
17:29:27 <johnw> Hermit: because $$++ needs to act on 'm' and not StateT
17:29:33 <johnw> since the ResumableSource is over m, and not StateT
17:29:46 <Hermit> I get it now
17:29:53 <Hermit> truly, why didn't I see it before!
17:30:04 <johnw> transformers can be a nest of vipers
17:30:07 <Hermit> it was so simple, right before my eyes
17:30:13 <johnw> I've spent untold hours wrestling with them
17:32:22 <SrPx> How do I completely purge everything haskell-related from osx ? So I can reinstall clean?
17:33:13 <johnw> how did you install haskell?
17:33:15 <Hermit> johnw: thanks for going through the trouble to actually solve this issue
17:33:26 <johnw> Hermit: no problem, I'm glad it was as thorny as I had first thought
17:33:29 <Hermit> you opened my eyes
17:33:30 <johnw> s/was/wasn't
17:33:47 * Hermit bows
17:34:43 <geekosaur> SrPx: the platform installer comes with an uninstall-hs script that can find and optionally remove (read the docs) all global files for all ghc versions. then you want to remove ~/.ghc, ~/Library/Haskell, and possibly ~/.cabal but saving ~/.cabal/config and putting it back after
17:35:32 <geekosaur> if you have ghc installations from other sources (notably macports or homebrew) then uninstall-hs will try to remove them as well, but it's better to use the respective package manager to remove those.
17:36:19 <Lokathor> on windows it seems to be somewhat tricky to purge the haskell platform as well, the normal uninstaller leaves behind a bunch of cabal files and things
17:36:45 <Lokathor> which seems to perhaps be the source of why ghc-pkg is confused, which is i think why i can't "cabal install cabal-install"
17:37:02 <geekosaur> note that an official ghc install tarball will conflict with and possibly terminally confuse a homebrew installation since both want to use /usr/local
17:37:18 <geekosaur> (homebrew ghc installation that is)
17:38:01 <kuribas> Is it possible to write haskell programs for raspberry pi?
17:38:11 <SrPx> I actually only had the installation from compiling the binaries
17:38:14 <inkstone> test
17:38:17 <AndreasL> So I'm about to start with Haskell, and I'm looking for some recommendations on editors/IDEs. Anyone?
17:38:25 <johnw> kuribas: I believe shapr has had GHC even running on a Pi
17:38:31 <SrPx> well I removed everything that had "cabal" or "ghc" on my whole system... hope it does it geekosaur :)
17:38:38 <Lokathor> yes, you can run GHC on a raspberry pi, but no ghci
17:39:32 <kuribas> ok, nice
17:39:52 <kuribas> What would be easier, cross compiling on the pc, or compiling on the pi?
17:40:28 <Lokathor> compiling on the pi has been fine, though the fact that the pi is only 700MHz is quickly obvious when you watch the dependencies compile one at a time slowly
17:41:51 <EvanR> in general any recursively defined object (f defined as the solution to R f = f (R f)) has at least one non terminating reduction sequence. in some cases all sequences are non terminating.
17:42:03 <EvanR> haskells reduction strategy always finds the terminating sequence if it exists
17:42:23 <EvanR> so im really lucky when my program does freeze!
17:42:48 <Lokathor> mmm, that implies that there are alternate reduction strategies that won't manage to find the terminating sequence?
17:42:55 <EvanR> right
17:43:26 <kuribas> Lokathor: that's fine, I don't have any dependencies for my project.
17:43:42 <kuribas> Lokathor: well, maybe only Bytestring.
17:43:49 <Lokathor> is the strategy something other than "referentail transparancy"? because that seems like the obvious pick, so it seems like you'd be going out of your way to find a worse result
17:44:04 <SrPx> Lokathor: what? Why not ghci?
17:44:07 <EvanR> its talking about eager evaluation vs lazy
17:44:17 <Lokathor> EvanR: ahhh, hmm
17:45:02 <Lokathor> kuribas: It's not a huge issue, but installing hscurses does take a minute or two, rather than the few seconds that it does on a more "Standard" desktop
17:45:30 <Lokathor> SrPx: Apparently you can't get ghci on an ARM processor for some reason or another, so since rpi is ARM, no ghci on rpi
17:45:39 <SrPx> hmm I see
17:45:52 <Lokathor> though a few have said that experimental ghci on ARM is being worked on, and will be out in a version or two
17:47:14 <EvanR> Lokathor: in fact... if R f literally = f (R g), then eager evaluation always finds the one guaranteed non terminating sequence ;)
17:47:23 <EvanR> f (R f) *
17:48:03 <Lokathor> there has been a dryer going on behind me for like 2 hours now, so I will have to trust your word on that one
17:48:06 <EvanR> f (f (f (f (f (...
17:49:57 <Lokathor> hmm
17:50:07 <Lokathor> I see then
17:50:49 <EvanR> (function R(f){ return R(f); })(3);
17:51:21 <EvanR> ah messed up
17:51:49 <EvanR> (function R(f){ return f(R(f)); })(function(){});
17:52:31 <EvanR> but there are fixed point functions that work in an eager setting
17:53:30 <Lokathor> what is the normal GHC_PACKAGE_PATH variable on windows?
17:55:15 <chug> #ghcjs
17:55:28 <AshyIsMe> AndreasL: i think most haskellers use vim or emacs
17:56:02 <AshyIsMe> AndreasL: though if you arent familiar with either one of those then there's also Leksah: http://leksah.org/
17:56:41 <AndreasL> AshyIsMe, Leksah looks cool upon first glance. Will check it out, thanks!
17:57:23 <AshyIsMe> AndreasL: no worries, one day you should commit to mastering vim or emacs. but not at the same time as you're learning haskell
17:57:39 <Lokathor> notepad++ is also alright
17:58:02 <EvanR> haha
17:58:22 <EvanR> does that really work for haskell?
17:58:37 <EvanR> source highlighting at least?
17:59:01 <AndreasL> AshyIsMe, excuse my ignorance, but are those using vim using it in terminal?
17:59:21 <FireFly> Plenty do, but not everyone
18:00:32 <AshyIsMe> AndreasL: i do yes
18:00:40 <Lokathor> EvanR: Yeah, it comes with a highlighting, and you can set indentation to always copy the last line, so it ends up doing the basics just fine. Won't look up a function for you or anything though
18:00:47 <AndreasL> Well, I find that the time I spend coding isn't actually spent writing
18:00:58 <AshyIsMe> in tmux or gnu screen (which basically gives you tabs and sessions within your terminal)
18:02:30 <AshyIsMe> AndreasL: vim is worth learning at least to the journeyman level just for the power you realize is possible
18:02:39 <AshyIsMe> if it turns out to not be that useful to you in practise that's fine
18:03:03 <AshyIsMe> but haskell is enough for now most likely
18:03:17 <AndreasL> AshyIsMe, I see. Thanks for your input!
18:03:27 <aaronweiss74> AndreasL: I use MacVim.
18:03:41 <aaronweiss74> Mostly because there's no way to get mouse support on the native OS X Terminal.
18:05:57 <AshyIsMe> aaronweiss74: that doesnt sound like efficient homerow usage...
18:06:20 <aaronweiss74> I don't use vim for the purpose of doing everything via keyboard.
18:06:50 <Lokathor> yeah the mouse is a good thing
18:06:52 <AshyIsMe> fair enough
18:06:53 <aaronweiss74> I use it because the only other text editor that doesn't offend my eyes is an embedded web browser and therefore can't handle a file with more than 500 lines without vomiting.
18:07:11 <aaronweiss74> (Atom)
18:07:12 <AshyIsMe> there's not a lot that the mouse is more efficient for in vim though
18:07:24 <aaronweiss74> I'm not looking for typing efficiency.
18:07:26 <aaronweiss74> I'm like the anti-vim user.
18:07:36 <AshyIsMe> fair enough
18:07:51 <omosoj> i am learning a haskell for greater good right now
18:07:59 <aaronweiss74> I don't use any of the fancy things vim can do at all because I just don't think about editing tasks like that.
18:08:07 <Lokathor> ^
18:08:14 <aaronweiss74> I just enter insert mode and type.
18:08:27 <aaronweiss74> I use the substitution feature sometimes.
18:09:12 <AshyIsMe> fair enough
18:09:21 <AshyIsMe> not everyone nerds out on editor features i guess
18:10:19 <aaronweiss74> I've tried a few times to find uses for things like block editing.
18:11:24 <AshyIsMe> i only use that for block commenting when nerd-commenter fails to recognize the buffer type or im on a fresh vm that i havent pulled down my vimrc to yet
18:12:06 <AshyIsMe> it's worth learning to use the jumplist and similar features though so you  don't have to reach for the mouse as much
18:14:49 <AndreasL> Hmm, so there are quite a number of recommended tutorials for getting started with Haskell. Any particular recommendations from you guys?
18:15:41 <AndreasL> "Learn You a Haskell for Great Good!" sounds inviting
18:16:38 <EvanR> aaronweiss74: there are things i found really useful after having to use vim to write clojure code, like structural editing parenthetical expressions
18:16:48 <EvanR> worth it
18:16:49 <bergey> AndreasL: https://github.com/bitemyapp/learnhaskell
18:16:56 <aaronweiss74> AndreasL: LYAH is great.
18:17:06 <bergey> Which includes a link to the UPenn course notes.
18:17:09 <EvanR> deleting whole lines, words, expressions
18:17:19 <AndreasL> aaronweiss74, cool, I just started reading it
18:18:29 <aaronweiss74> AndreasL: Real World Haskell is generally a good follow-up.
18:18:50 <AndreasL> aaronweiss74, thanks for the recommendation!
18:19:04 <AshyIsMe> EvanR: text objects are really nice, i'd love semantic aware ones for code though
18:19:10 <AshyIsMe> like what paredit is for lisp in emacs
18:19:17 <aaronweiss74> EvanR: I suppose I can see that. I know a lot of people swear by some of the features I consider out there.
18:19:45 <EvanR> if vim allowed me to point and click to move the cursor, i probably would still be doing it
18:19:50 <EvanR> thank god
18:20:00 <aaronweiss74> That's what I do. :D
18:20:26 <aaronweiss74> Scrolling is so much faster that way.
18:20:30 <AshyIsMe> man, you should commit to working through vimtutor at least once
18:20:42 <EvanR> scroll wheel hurts my hand
18:20:45 <AshyIsMe> it should only take about half an hour or so
18:20:53 <benzrf> AshyIsMe: lyah is not great
18:20:58 <benzrf> * aaronweiss74
18:21:05 <benzrf> aaronweiss74: lyah has some major issues
18:21:15 <aaronweiss74> I've seen a lot of people recommend it here.
18:21:21 <AshyIsMe> it's good enough for a first intro to haskell though
18:21:23 <benzrf> never said it wasnt popular
18:21:27 <benzrf> AshyIsMe: no, it's not
18:21:32 <aaronweiss74> Major issues doesn't mean it's not a good introduction.
18:21:42 <aaronweiss74> What do you recommend then?
18:21:46 <AshyIsMe> benzrf: what's some of the issues?
18:21:49 <benzrf> aaronweiss74: they do if the issues are about its suitability as an intro
18:21:51 <benzrf> aaronweiss74: CIS194
18:21:52 <AshyIsMe> (genuinely curious)
18:21:54 <EvanR> i like looking at the goofy pictures
18:21:55 <benzrf> AshyIsMe: https://github.com/bitemyapp/learnhaskell
18:21:58 <benzrf> * aaronweiss74
18:22:12 <benzrf> AshyIsMe: oh boy i get to use my analogy
18:22:33 <aaronweiss74> EvanR: two-finger scrolling :D
18:22:49 <aaronweiss74> Yeah, I want to hear what issues you had with it.
18:23:07 <benzrf> AshyIsMe: every played a complicated game (board game or computer game, whatever) and read the rulebook and all of it is well-stated and clear but you have no idea how to actually play the game and you don't get why this rule works this way and how it all holds together as a game?
18:23:12 <EvanR> aaronweiss74: yurg, page up, page down, ctrl u, ctrl d
18:23:49 <aaronweiss74> EvanR: I don't have paeg up/page down
18:23:59 <EvanR> fn V ^
18:24:42 <AshyIsMe> benzrf: yeah..
18:25:44 <AshyIsMe> aaronweiss74: ctrl+u and ctrl+d for up and down half a page in vim
18:25:57 <benzrf> AshyIsMe: haskell is the game
18:26:00 <benzrf> lyah is the rule book
18:26:08 <AshyIsMe> but really you should be searching for exactly what you want and then Ctrl-o to get back to where you were etc
18:26:13 <aaronweiss74> AshyIsMe: I could not use emacs because I cannot stand scrolling that isn't smooth.
18:26:44 <AshyIsMe> benzrf: ah yeap, you don't finish it knowing how to actually write a useful program
18:26:51 <Welkin> smooth scrolling has no purpose in a text editor
18:26:53 <AshyIsMe> you've just learned the syntax rules of haskell basically
18:27:00 <Welkin> you want to scroll by pages
18:27:04 <aaronweiss74> I don't.
18:27:32 <EvanR> enough about editors
18:27:49 <aaronweiss74> benzrf: Looking at CIS 194, I suppose I see what you mean.
18:27:58 <benzrf> cis194 has exercises
18:28:02 <benzrf> and the exercises are really, really good
18:28:33 <benzrf> if you read lyah you will be able to recognize what is legal haskell
18:28:42 <benzrf> if you do cis194 you will understand haskell
18:28:47 <Welkin> yes, benzrf finally exercised for the first time since he learned how to walk
18:28:48 <benzrf> or at least, part of it
18:29:35 <aaronweiss74> benzrf: You've more or less described the realm I've fallen into for quite some time now.
18:33:19 <ReinH> \times
18:33:21 <ReinH> woops
18:33:26 <aaronweiss74> benzrf: It sounds like your big concern then is just that LYAH just doesn't have exercises.
18:35:16 <seancorfield> fwiw I thought LYAH was great... it has a decent amount of REPL session listings and I played along in the REPL, typing in each bit of code and then experimenting on my own to make sure I actually understood it
18:43:31 <benzrf> aaronweiss74: not really
18:43:34 <benzrf> aaronweiss74: there's a little more to it than that
18:44:03 <benzrf> aaronweiss74: it...
18:44:30 <benzrf> aaronweiss74: the explanations in it are written in the style of somebody who thinks "ok how much do they know at this stage, alright ill explain it in terms of these things theyve already learned"
18:44:47 <benzrf> aaronweiss74: rather than in the style of somebody who's trying to get inside the head of the reader and work out how to put it so that it clicks
18:45:47 <benzrf> some explanations help you understand and some are just definitions that don't turn into anything else in your head but a flat definition
18:46:11 <benzrf> in that sense, lyah suffers from some of the same issues as k-12 math class
18:47:07 <aaronweiss74> That's an interesting point.
18:49:04 <aaronweiss74> benzrf: I definitely feel like there's a greater focus on ideas from what I've read here so far versus LYAH which seemed to be more about mechanics.
18:52:47 <benzrf> aaronweiss74: lyah fails to take into account the mental state of the reader beyond what definitions they've seen so far
18:53:42 <benzrf> aaronweiss74: if i meet somebody who doesn't know about negative numbers i can tell them about how the operations on them are defined all i like
18:53:49 <benzrf> and maybe they'll be able to do the calculations
18:54:06 <benzrf> but you need something more than mechanical definitions to get the concept to click
18:54:20 <benzrf> the idea of a negative number /makes sense/ to you
18:54:53 <benzrf> so if you aren't able to see how it doesn't make sense to your student
18:55:04 <benzrf> you will tell them "this is how they add and this is how they multiply
18:55:04 <benzrf> "
18:55:10 <benzrf> and it will make sense to you
18:55:15 <benzrf> and they will not be able to think about them easily
18:55:19 <benzrf> because it seems arbitrary
18:57:07 <EvanR> benzrf: so when someone barges in and demands to know what monads are, dont just pull up a dump of the monad laws?
18:57:10 <Guest58644> What does a tilde character before pattern mean?  Like here http://hackage.haskell.org/package/OpenGL-2.9.2.0/docs/src/Graphics-Rendering-OpenGL-GL-Tensor.html#Vertex1
18:57:17 <Guest58644> sizeOf    ~(Vertex1 s) = sizeOf s
18:57:21 <EvanR> lazy pattern
18:57:35 <benzrf> EvanR: clearly
18:58:15 <benzrf> EvanR: the correct answer is to tell them that there is no explanation that will work for them until they understand functors
18:58:22 <EvanR> Guest58644: that case of sizeOf will always match, and the argument will not be evaluated until absolutely necessary
18:58:32 <benzrf> at which point they will say "well ok give me one that wont work for me" and leave satisfied knowing that a monad is the io type
18:58:40 <benzrf> *a value of the IO type
18:58:52 <benzrf> i should know, i was one of those people
18:59:17 <EvanR> leave satisfied knowing that a monad is a value of the IO type?
19:00:25 <benzrf> EvanR: sarcasm
19:00:29 <EvanR> oh
19:01:02 <benzrf> EvanR: people who come in here and ask about monads without learning any haskell inevitably seek any explanation at all until they get one so shitty that they end up thinking something like that
19:01:06 <EvanR> benzrf: i brought this up being it seems to be difficult to do what youre saying when they want a monad tutorial
19:01:28 <Welkin> there is only one monad tutorial
19:01:30 <benzrf> just refuse to talk about monads to people who don't understand functors
19:01:38 <Welkin> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
19:01:45 <benzrf> Welkin: nah, dude
19:01:46 <Welkin> that's all you need
19:01:48 <EvanR> first law of monads: dont talk about monads
19:01:50 <benzrf> that focuses too much on bind imo
19:01:51 <EvanR> second law of monads
19:01:55 <benzrf> join is the 1 true way
19:02:20 <Welkin> no one uses join
19:02:26 <benzrf> Welkin: true
19:02:34 <benzrf> Welkin: that doesnt make it not the key to understanding
19:02:38 <EvanR> duplicate is the shit tho
19:03:04 <EvanR> if you could define the monad in terms of join, it might be nicer
19:03:20 <benzrf> Welkin: as gfixler (sort of) observed, trying to explain bind without join is like trying to explain git pull without git merge
19:03:43 <benzrf> Welkin: pull makes sense when you see it as fetch and merge combined
19:03:59 <benzrf> pull does not make sense when you try to understand it as a fundamental operation
19:04:14 <EvanR> fmap is really easy, bind is not so easy. but bind is fmap plus join
19:04:23 <benzrf> EvanR: fmap is not that easy
19:04:28 <benzrf> really it's quite hard
19:04:32 <EvanR> huh
19:04:34 <benzrf> well...
19:04:45 <EvanR> you cant screw up the definition pratically
19:04:56 <benzrf> understanding that if a type has a functor instance, you can use fmap on it and it will operate on that type in a way that makes sense for that type
19:04:59 <benzrf> is easy.
19:05:17 <benzrf> getting a good grasp of what fmap means in general and what all of the instances have in common
19:05:20 <benzrf> is difficult.
19:05:35 <torpet> why do i have to reverse the final result? http://stackoverflow.com/a/1959734/4087140
19:06:47 <EvanR> benzrf: well map is easy. and after they learn admittedly a lot to get to the Functor class, it should be easy as its own sake
19:07:02 <torpet> oh nevermind i got confused by my own stupidity lol
19:07:10 <benzrf> EvanR: each Functor instance is easy. Functor as a whole is quite hard
19:07:32 <EvanR> you mean, category theory?
19:07:36 <benzrf> EvanR: if you give me a type constructor and say "whats the functor instance", it's easy to learn how to do that
19:07:50 <benzrf> EvanR: it is much harder to learn how to respond to "what is a functor"
19:08:02 <benzrf> with or without category theory
19:08:03 <EvanR> oh. good think nobody asks that ;)
19:08:16 <EvanR> "what is a functor REALLY"
19:09:04 <EvanR> benzrf: so how do you respond?
19:09:27 <benzrf> maybe i mentioned that it's very hard
19:09:39 <benzrf> :|
19:09:39 <EvanR> just checking
19:09:42 <benzrf> what i like to say is
19:10:09 <benzrf> a functor is a mapping from "regular haskell functions" to "analogous" "f-functions"
19:10:23 <benzrf> where f is the instantiating constructor
19:10:25 <systemfault> A functor is something you can map over :P (My own definition :( )
19:10:48 <benzrf> depending on what you mean by "map", that could mean the same thing as mine
19:10:58 <EvanR> systemfaults is a good practical definition, whats the goal, to help people program, or to elevate them to a higher state of consciousness
19:11:39 <EvanR> the latter a lot of people vehemently reject for no good reason ;)
19:12:30 <systemfault> Else, you're stuck with burrito/container-like-ish definitions that aren't right... IMHO
19:16:10 <mseeks> I'm writing a simple REST client, and I'm trying to figure out how to structure certain parts of the code
19:17:15 <mseeks> for example, I have to construct a URL that's differs depending on the request, and then append URL options (in this case, an auth token)
19:18:11 <mseeks> I'm thinking of having a monad `Reader Config (IO a)` where Config contains stuff like auth tokens
19:19:03 <marchelzo_> I'm getting a #include error when trying to cabal install something from hackage. Is there any that I can do?
19:19:07 <mseeks> never mind, I think I figured it out
19:19:17 <EvanR> first you should make a function that takes what you need to construct the url, and constructs it
19:19:23 <EvanR> then worry about how to story auth tokens
19:21:11 <mseeks> yeah I know, I was just trying to figure out how to separate the code cleanly
19:26:31 <Welkin> mseeks: there is another approach
19:26:49 <Welkin> mseeks: just do the first thing that comes into your mind and get it working
19:26:54 <Welkin> then clean it up afterward
19:27:33 <Welkin> it's hard to design the structure of your program before writing it
19:27:58 <EvanR> it takes practice
19:28:31 <systemfault> I wonder how possible it is with a FP language... I found that to be nearly impossible to do with a OOP language.
19:28:52 <Welkin> if it's something you have done many times already, of course the way to structure it seems obvious
19:29:07 <Welkin> oop doesn't let you design anything
19:29:17 <Welkin> it forces you to use the same template for every problem
19:29:25 <Welkin> round pegs, square hole
19:29:40 <EvanR> yes it forces you to put round pegs in square holes
19:30:02 <EvanR> and then construct an adapter factory to deal with the result
19:30:11 <EvanR> which itself doesnt fully work
19:30:32 <mseeks> Welkin: makes sense; I find myself overengineering everything
19:30:56 <sshine> systemfault, how possible what is with an FP language?
19:31:07 <mseeks> knowing how monad transformers and everything work makes me try to use it everywhere
19:31:21 <tempay> is there something like mod for fractional numbers?
19:31:25 <systemfault> sshine: To design before writing.
19:31:29 <Welkin> :t rem
19:31:30 <lambdabot> Integral a => a -> a -> a
19:31:34 <Welkin> :t mod
19:31:35 <lambdabot> Integral a => a -> a -> a
19:31:43 <tempay> yeah :/
19:31:44 <sshine> mseeks, I was going to suggest a ReaderT Config IO a
19:32:37 <Lokathor> man you guys are kinda hard on OOP... :P
19:32:42 <EvanR> > (15 % 8) `mod` 2
19:32:43 <lambdabot>  No instance for (GHC.Show.Show a0)
19:32:43 <lambdabot>    arising from a use of ‘M33713669834309475730777.show_M33713669834309475730...
19:32:43 <lambdabot>  The type variable ‘a0’ is ambiguous
19:32:46 <mseeks> sshine: yeah, i was planning on doing MaybeT (ReaderT Config IO) a
19:32:58 <mseeks> but then I decided just to get something working first before  building all this structure
19:33:01 <EvanR> > (15 % 8) `mod` (2 % 1)
19:33:02 <lambdabot>  No instance for (GHC.Show.Show a0)
19:33:02 <lambdabot>    arising from a use of ‘M579900352811687236130791.show_M5799003528116872361...
19:33:02 <lambdabot>  The type variable ‘a0’ is ambiguous
19:33:24 <mseeks> ^ what was taht
19:33:31 <EvanR> :(
19:33:33 <mseeks> :t mod
19:33:34 <lambdabot> Integral a => a -> a -> a
19:33:39 <mseeks> :t (%)
19:33:40 <lambdabot> Integral a => a -> a -> Ratio a
19:34:49 <EvanR> nevermind
19:35:28 <tempay> :t mod'
19:35:29 <lambdabot> Real a => a -> a -> a
19:35:40 <Welkin> tempay: http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Fixed.html#v:mod-39-
19:35:42 <tempay> found it on Hoogle in Data.Fixed
19:35:43 <Welkin> yeah
19:35:53 <tempay> read my mind :) thanks folks
19:39:07 <EvanR> > (15 % 3) `mod'` (2 % 1)
19:39:09 <lambdabot>  1 % 1
19:39:34 <EvanR> > (16 % 3) `mod'` (2 % 1)
19:39:35 <lambdabot>  4 % 3
19:42:04 <codygman> I've read that functors "do less" and their use is encouraged over monads when possible (in the typeclassopedia). Is there some invariant that my first line of code using the functor instance provides over using the monad instance? If there is no benefit of using the functor instance because it does less in this example, can anyone provide an example where using functor instance over monad instance is more robust? code:
19:42:05 <codygman> http://lpaste.net/118461
19:43:06 <EvanR> you are using the join operation either way
19:43:31 <EvanR> join + fmap is =<< so use =<<
19:43:32 <codygman> EvanR: Good point
19:43:53 <codygman> lol, I feel silly
19:53:42 <nshepperd> codygman: if you have some value containing a (Monad m) constraint, in which only functor properties are used, you can change it to (Functor m) and get more polymorphism for free
19:53:55 <nshepperd> I think that's the main thing
19:55:47 <Lokathor> does cabal have a "dry run" type feature where it'll tell me specifically what it's gonna do before starting in on it all?
19:56:07 <Enigmagic> --dry-run might work..
19:56:34 <Lokathor> couldn't remeber if that was cabal or apt-get >_<
19:56:46 <Enigmagic> :)
19:57:57 <Lokathor> ohhhh boy this is gonna take a while
19:58:19 <Lokathor> but the good news is that my windows box managed to install cabal properly!
20:06:11 <codygman> nshepperd: Thanks!
20:09:34 <codygman> So Scala calls (>>=) flatmap. (>>=) = join . fmap. join is kind of flattening (less destructive?), and map is well map. Why didn't we just name join flatten? and bind flatmap? I'm guessing there's some intuition behind the word join? Am I on to something?
20:11:32 <benzrf> codygman: idk
20:11:39 <benzrf> [A
20:11:44 <benzrf> codygman: in math it's called μ
20:12:13 <benzrf> join seems more generic than flatten i guess
20:12:40 <nshepperd> 'flatmap' doesn't really seem appropriate to IO
20:14:05 <codygman> nshepperd: Could you expand on that? I don't know much about Scala, just pieces.
20:14:47 <codygman> benzrf: Thanks for that, I didn't know that it was μ in math! Is there a simple way it's used in math I could make sense of (math is a weak spot).
20:15:26 <nshepperd> codygman: I don't know scala either, I'm just thinking that composing IO actions seems more like 'sequencing' than 'flattening'
20:15:47 <codygman> nshepperd: I agree
20:16:06 <codygman> So does that mean μTorrent is a joke I don't quite get yet?
20:16:08 <SrPx> Does anyone know why there is no 7.8.4 ghc download link on ghc's site, for osx?
20:16:14 <kazagistar> nshepperd: so instead of picking from two different words, we use the word (>>=)
20:16:15 <benzrf> codygman: well
20:16:30 <benzrf> codygman: in math a monad is defined as a triple of 3 things and μ is the typical name to refer to one of them
20:16:35 <benzrf> codygman: the one that join is based on
20:17:13 <nshepperd> kazagistar: so various smartasses like to say
20:17:38 <zwer> `join :: IO (IO a) -> IO a' could have been called flatten as well as far as I'm concerned
20:17:44 <Lokathor> μTorrent is just "microtorrent" because it started out as a small alternate to the main bittorrent
20:17:57 <codygman> SrPx: Looks like no one has updated it in a while: https://github.com/ghcformacosx/ghc-dot-app
20:18:56 <Lokathor> so, the MingW that comes with the Haskell Platform, is it intended that you be able to use that as a normal mingw install?
20:19:03 <Lokathor> or should I install mingw separately?
20:19:42 <codygman> zwer: only for "IO (IO a) -> IO a" but not "M (M a) -> M a"? Then it would have to be defined twice though or through a typeclass right?
20:20:14 <SrPx> Hmm so I should just continue using 7.8.3?
20:20:16 <nshepperd> 'Monad' seems to me a good name for monads, because a name that lacks preexisting meaning for most people avoids introducing wrong analogies ('Burrito'?)
20:20:24 <SrPx> on this case, anyone knows what this error means when installing ghcjs? http://lpaste.net/118466
20:20:25 <nshepperd> maybe 'bind' is the same way
20:20:32 <ReinH> codygman: join is concat for lists and (>>=) is concatMap.
20:20:35 <SrPx> when running ghcjs-boot actually
20:20:50 <codygman> ReinH: Oh, duh. Thanks again Rein.
20:21:16 <Lokathor> nshepperd: I'd say that "bind" has plenty of connotations to it. Most of which are useful when thinking about monads
20:21:53 <codygman> SrPx: I think you need cabal-install 1.20.0.4. So `cabal update; cabal install cabal-install` to update
20:22:46 <SrPx> When I run it, it says : Configuring cabal-install-1.22.0.0... any idea why?
20:23:09 <codygman> SrPx: Did you update with the code snippet I gave you?
20:23:42 <SrPx> yes, vh:cabal apple1$ cabal update; cabal install cabal-install
20:24:23 <codygman> SrPx: Just to erase all ambiguity can you paste the full thing on lpaste?
20:24:39 <codygman> If it's what you describe we may need it for a bug report anyway.
20:25:03 <Pamelloes> Is it possible to make an array of a datatype a member of a typeclass?
20:25:17 <SrPx> codygman: sure, http://lpaste.net/118467
20:25:53 <EvanR> bind doesnt make too much sense to me as a name for >>=
20:26:03 <SrPx> so, I have the repo here compiled already, will just install it :)
20:26:06 <EvanR> which is fine because i dont call it that
20:26:13 <codygman> SrPx: you said you are on ghc 7.8.3?
20:26:30 <Lokathor> EvanR: What do you call it?
20:26:30 <SrPx> yes, The Glorious Glasgow Haskell Compilation System, version 7.8.3
20:26:46 <EvanR> dont try to pronounce haskell code ;)
20:27:00 <Lokathor> Pamelloes: Do you mean like declaring that a [Int] should act like a number in some way?
20:27:34 <EvanR> theres a lot of operators in haskell, it gets exhausting tying to say them
20:27:56 <Lokathor> EvanR: if I can't read a line of code out loud I usually can't reason about it one bit. The ones that don't have names I just have to make up names until I can say the whole line
20:28:03 <Pamelloes> Lokathor: I have a type MyType and I want to make [MyType] an instance of Ord.
20:28:35 <nshepperd> Pamelloes: with {-# LANGUAGE FlexibleInstances #-} you can do that
20:28:37 <Lokathor> Pamelloes: is MyType already an Ord? I think that a list of an Ord is also orderable..
20:28:40 <EvanR> Lokathor: well, i guess its like not being able to read a book without saying the words, one by one
20:28:46 <EvanR> its slow
20:28:47 <codygman> SrPx: Either because you are on Mac 1.22.0.0 is the newest cabal-install you can have or more likely because you are on ghc 7.8.3. I just tried on a macbook and got the same thing (also installed from ghcformacosx).
20:28:54 <SrPx> f space less than dollar space greater than space x space less than asterisk greater than space y space less than asterisk greater than space z
20:29:01 <Pamelloes> Lokathor: MyType is a... strange type that doesn't make sense as an Ord while an array of MyTypes does.
20:29:11 <SrPx> codygman: wow you did that fast
20:29:37 <SrPx> I'm almost installing linux for the sake of avoiding that... you guys don't like apple do you? :)
20:29:43 <nshepperd> Pamelloes: instance Ord [MyType] where { ... }
20:29:59 <Pamelloes> nshepperd: Awesome :)
20:30:06 <EvanR> haskell is working great on my mac laptop
20:30:48 <Pamelloes> On an unrelated note, I'm always hesitant to turn on language extensions because I don't really understand them. Are they something worth looking into?
20:31:13 <Pamelloes> Or should I stick to avoiding them?
20:31:14 <codygman> SrPx: Regarding 7.8.4: http://www.reddit.com/r/haskell/comments/2q6oln/announce_ghc_version_784/cn4cui5 I haven't been able to find the download link referenced there though.
20:31:18 <tommd> Pamelloes: yes, most of Haskells growth over the past 10 years is in LANGUAGE pragma and many are worth while.
20:31:23 <EvanR> Pamelloes: some of them are really cool
20:31:27 <Lokathor> I don't normally say it out loud, but I need to be able to or I can't get a good grasp of code. I can say words in my head much faster than words out loud anyway
20:31:38 <tommd> Pamelloes: For the most common example (probably) MultiParamTypeClasses.
20:31:41 <codygman> SrPx: I like Mac but dislike apple, they are very good computers. I prefer linux though :)
20:31:52 <codygman> gnight all
20:31:57 <Pamelloes> night
20:32:30 <SrPx> good night, thanks :) codygman
20:32:39 <Pamelloes> Alright, I will look into extensions the next time I have time to kill....
20:32:48 <SrPx> I'm afraid it will drain my battery and be too slow due to linux not going very well on macs :(
20:33:23 <Pamelloes> SrPx: I wouldn't agree with that, I've run countless distros on my iMac with no real trouble.
20:33:36 <Pamelloes> Well, except when I tried to install Xen. That was a nightmare. hehe
20:34:11 <Lokathor> SrPx: If you mean "f <$> x <*> y <*> z", I'd probably pronounce it something like "f over x applicate y applicate z"
20:34:33 <SrPx> Pamelloes: no real trouble for real? I imagine 816816 places where things could go wrong. Wifi not working, chrome scrolling slowly, issues with webgl, incapacity of toggling gpu usage
20:34:56 <EvanR> f <$> x <*> y <*> z can be thought as [[f x y z]], an applicative style "application", would you pronounce f x y z ?
20:34:57 <SrPx> Lokathor: so (f/x)(y,z) ?
20:35:22 <SrPx> ((f / x) y z) *
20:35:52 <Pamelloes> SrPx: Oh well..... No trouble with the operating system itself. I tend to avoid GUIs on linux and have an ethernet connecting and usb peripherals so I didn't run into any of those issues.
20:35:57 <SrPx> I guess you just say: f x y z, lifted :)
20:36:00 <Lokathor> hey you can't say everything easily :P "f divided by x applied to y comma z"
20:36:02 <Pamelloes> SrPx: But yeah, all the things you mentioned would be problematic.
20:36:38 <SrPx> Pamelloes: I see, that is the point... this is my for everything computer... I actually even run windows here to play some games with friends eventually... hardly I'd have something like parallels on linux
20:36:52 <EvanR> id hate to have to say out java or C code ;)
20:36:53 <SrPx> I feel bullied by haskellers though, nobody loves osx :(
20:37:30 <SrPx> I used to be very upset about it... now I just reserve a day or 2 when I have to install new stuff using cabal &tc
20:37:32 <Pamelloes> I've actually been surprised by how many OS X users are in this channel.
20:37:34 <Lokathor> EvanR: yeah I'd say the letters/symbols. Usually I don't use just letters for variables after all
20:38:06 <Pamelloes> EvanR: The key to pronouncing code is skipping most of the symbols and knowing what you mean.
20:38:13 <Lokathor> EvanR: speaking java out loud is easy :P Just don't say any '.' and other garbage
20:38:18 <Lokathor> yeah waht Pamelloes said
20:38:41 <Lokathor> "Public static void main string args" -> public static void main(String... args){
20:38:42 <EvanR> wait until you write code with voice recognition
20:38:46 <Pamelloes> public static void main (String[] argv) -> public static void main string array args
20:38:47 <EvanR> itll come out all wrong!
20:39:07 <Lokathor> Jarvis will never be IronMan's IDE, how sad
20:39:11 <Pamelloes> Lokathor: Wow, we literally just wrote the exact same example.
20:39:25 <EvanR> its a java reflex
20:39:43 <SrPx> template <class T> int(int&(*x))(cons **int, const &T(*int));
20:39:53 <johnw> this is all better suited to #haskell-blah
20:39:59 <johnw> it is getting off-topic for here
20:40:08 <Pamelloes> Alright.
20:40:20 <EvanR> f (x:xs) = x
20:40:35 <Pamelloes> EvanR: head?
20:41:06 <johnw> @src head
20:41:06 <lambdabot> head (x:_) = x
20:41:06 <lambdabot> head []    = undefined
20:41:43 <Pamelloes> johnw: Is there a way to access @src outside of this chat? It seems like something that would come in handy
20:41:54 <johnw> you can say: /msg lambdabot @src ...
20:42:06 <johnw> or do you mean, outside of IRC?
20:42:27 <Pamelloes> Ideally outside of IRC, but PM'ing lamdabot is a good idea
20:42:36 <johnw> you basically search this file: https://www.haskell.org/onlinereport/standard-prelude.html
20:42:43 <johnw> since that's where @src is getting its data from more or less
20:43:04 <Pamelloes> Alright
20:43:09 <johnw> those are the mainly unoptimized Haskell 98 definitions
20:43:33 <Lokathor> I assume that GHC will occasionally use better definitons?
20:43:44 <johnw> yes, often they are more complex and better performing
20:43:54 <kazagistar> Pamelloes: hackage has source links for most things
20:44:04 <johnw> I use the Source links on Hackage for 'base' mainly
20:48:19 <mseeks> anyone know why I'm getting expected: String, actual: text-1.1.0.0:Data.Text.Internal.Text with OverloadedStrings on?
20:49:11 <pingu> mseeks: OverloadedStrings will only change the type of literals for you
20:49:14 <kadoban> mseeks: You know the automatic conversion thing only goes from string literals to others, not the other way, right?
20:49:15 <pingu> sounds like you have a Text value
20:49:49 <mseeks> no, the expected is Text and actual is String
20:50:16 <mseeks> here's the actual error: `Couldn't match type ‘[Char]’
20:50:16 <mseeks>                   with ‘text-1.1.0.0:Data.Text.Internal.Text’
20:50:16 <mseeks>     Expected type: text-1.1.0.0:Data.Text.Internal.Text
20:50:16 <mseeks>       Actual type: String`
20:50:23 <mseeks> so I do have a String
20:50:43 <kadoban> mseeks: Well, that's not automatic either, unless it's a string literal.
20:51:24 <mseeks> kadoban: oh I see; why not though?
20:51:48 <EvanR> no implicit conversions allowed
20:51:50 <EvanR> bad, evil
20:51:53 <kadoban> mseeks: Because that's not what OverloadedStrings does. Haskell doesn't have type coersion.
20:52:11 <mseeks> ok, that makes much more sense now
20:52:15 <EvanR> you can easily convert between String and Text
20:52:16 <kadoban> mseeks: All that extension does is let you use string literals kinda like how numeric literals work.
20:52:23 <mseeks> I see
20:55:16 <SrPx> uh guys I guess this is a stupid question but how do I install cabal 1.22.0.4? I cloned the repo. switching to branch 1.22 it installs 1.22.0.0 ... master installs 1.23.0.0 :(
20:55:37 <Romefeller> anyone knows how to do type-level programming? Im stuck at this: soma (undefined::Suc Um) (undefined::Suc Um)
20:55:37 <Romefeller>   :: Soma (Suc Um) (Suc Um) c => c. I have data Zero, data Suc n and type Um = Suc Zero. I defined an instance instance Soma (Suc Zero) (Suc Zero) (Suc (Suc Zero)) where soma = undefined
20:55:57 <Romefeller> Type-checker cant do recursive call
20:56:43 <Romefeller> Um is One in english
20:57:25 <systemfault> Um is One in what language?
20:57:37 <Romefeller> Portuguese
20:58:55 <systemfault> Ah!
20:59:18 <Denommus> hi
21:00:31 <SrPx> cabal 1.22.0.4 doesn't exist
21:00:36 <SrPx> I was lied to D:
21:00:45 <SrPx> whyd you do that to me
21:00:52 <johnw> I hope you didn't pay a lot for it
21:01:09 <SrPx> I just checked the commit where they updated from 1.22.0.0 to 1.23.0.0
21:01:12 <SrPx> gaaaah
21:01:26 <Lokathor> Denommus: hi
21:01:58 <SrPx> meanwhile ghc 7.8.4 is still compiling since 2 hours ago and it is just waiting the right moment to tell me it will not work
21:02:02 <SrPx> everyone lies to me :(
21:02:21 <mseeks> if I have a stack `newtype Q a = MaybeT m a`, is there a way to do something like liftMaybe :: Maybe a -> Q a?
21:02:32 <Pamelloes> SrPx: Yeah, compiling big projects is scary.
21:02:46 <mseeks> in place of `maybe mzero (fromJust x)` or something
21:03:06 <SrPx> Pamelloes: right!
21:03:07 <mseeks> I guess this is dependent on MaybeT being on the top layer
21:04:01 <SrPx> and I never understood why installers love so much to print stuff like that on the console: http://imgur.com/5SfpXtD
21:04:15 <SrPx> I always wondered if this is for the cool effect "look im a hacker", or if to look like it is doing something
21:04:34 <Lokathor> well you can pipe that into a log if you want
21:04:43 <Lokathor> for debug purposes later
21:04:59 <SrPx> I wouldn't love to have those lines on my log
21:05:08 <SrPx> but dunno, maybe some ultra robot understands it :P
21:05:21 <lpaste> guhou pasted “Removals” at http://lpaste.net/118469
21:05:26 <Lokathor> unlikely that you'd look at them directly, more likely you'd search for some value you expect to find somewhere
21:06:00 <EvanR> mseeks: implement MonadTrans for Q
21:06:09 <EvanR> it lets you do this lifting
21:06:42 <EvanR> and since its a newtype, it should be easy, just based on the type that it basically is, MaybeT m a
21:07:10 <guhou> I wrote these recursive functions, I'm curious if there's a clearner way to write them, as maps or folds
21:07:23 * hackagebot newtype-deriving 0.1.0 - Instance derivers for newtype wrappers  http://hackage.haskell.org/package/newtype-deriving-0.1.0 (NikitaVolkov)
21:07:35 <Lokathor> so I guess I'll try my question again: is the MingW installed with the haskell platform supposed to be a normal mingw install that you can use? or should you install an actual copy elsewhere? If you should install a separate copy elsewhere, how do you keep your PATH sane?
21:07:48 <EvanR> mseeks: also if you use type instead of newtype, all the old operations and instances work
21:07:55 <mseeks> EvanR: could I write something that lets me write `lift maybeVal` in a `do` block, or would I specifically have to write `liftMaybe`?
21:08:08 <EvanR> :t lift
21:08:09 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
21:08:29 <EvanR> @src MonadTrans
21:08:30 <lambdabot> Source not found. Are you on drugs?
21:08:50 <Lokathor> guhou: You can probably write them as a fold or a map. Where's your examples?
21:09:07 <EvanR> mseeks: right. lift (action in other monad)
21:10:18 <mseeks> EvanR: so something like, `lift (Just x) = Q $ MaybeT (return Just x); lift Nothing = Q $ MaybeT (return Nothing)`?
21:11:17 <EvanR> mseeks: MaybeT is an instance of MonadTrans, so use lift again in the definition (in order to get the underlying action to execute)
21:11:51 <EvanR> also consider MonadIO so you can use liftIO
21:12:01 <EvanR> or run MonadIO actions directly
21:12:17 <mseeks> EvanR: not sure I understand what you mean by using lift in the definition
21:12:23 * hackagebot newtype-deriving 0.1.1 - Instance derivers for newtype wrappers  http://hackage.haskell.org/package/newtype-deriving-0.1.1 (NikitaVolkov)
21:12:38 <EvanR> mseeks: whats the type of x in lift (Just x) = ?
21:13:05 <mseeks> just the content of the monad, right? the `a` in `Q a`
21:14:32 <EvanR> the `m a' in MaybeT m a ?
21:14:40 <lpaste> guhou revised “Removals”: “No title” at http://lpaste.net/118469
21:15:40 <guhou> Lokathor: I've added examples into the lpaste. The output order is not important
21:15:40 <mseeks> EvanR: what do you mean?
21:16:26 <EvanR> mseeks: its not just an a, thres an underlying monadic action in the MaybeT
21:16:58 <mseeks> EvanR: I didn't think x would be a monad though
21:17:03 <EvanR> also, newtype Q a = Q (MaybeT m a) doesnt work, because m is not in scope
21:17:17 <mseeks> EvanR: where m is some monad, just for illustration
21:17:26 <Lokathor> guhou: You're already using map though
21:17:26 <EvanR> right, you are ignoring that monad
21:17:56 <mseeks> here's what i had in mind: inside a do block in Q, I have a (Maybe String) value, and I want to "lift" it to return `Q String`
21:18:09 <kazagistar> > filterM (const [True, False]) ["abc"]
21:18:10 <lambdabot>  [["abc"],[]]
21:18:14 <johnw> mseeks: that wont' work
21:18:20 <kazagistar> oh wait
21:18:22 <kazagistar> derp
21:18:30 <kazagistar> > filterM (const [True, False]) "abc"
21:18:31 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
21:18:42 <johnw> you can go from Q (Maybe String) to Maybe (Q String).  But to deconstruct the Maybe, you'll need to use case or the 'maybe' function.
21:18:45 <kazagistar> guhou: ^^^ :P
21:19:06 <mseeks> johnw: Q contains a MaybeT though
21:19:16 <johnw> oh, I see
21:19:22 <johnw> show me the definition of Q?
21:19:37 <mseeks> something like MaybeT m a, with m some monad
21:19:59 <EvanR> newtype Q m a = Q (MaybeT m a)
21:20:00 <johnw> to go from Maybe String to MaybeT m String, you need to use: MaybeT $ return x
21:20:02 <mseeks> I feel like as long as it contains MaybeT anywhere in the stack it should be ok, though
21:20:41 <johnw> I have _often_ wanted a liftMaybe
21:20:44 <mseeks> oh, I see
21:20:49 <johnw> of type Maybe a -> MaybeT m a
21:20:54 <mseeks> but that wouldn't work unless you have Q's data constructor
21:21:07 <johnw> you don't need the data constructor to use return
21:21:19 <mseeks> right but you have to wrap the MaybeT if Q is a newtype
21:21:31 <johnw> oh yeah, it has no reason to be thuogh
21:21:34 <mseeks> I guess you can do return $ MaybeT (return x)
21:21:38 <johnw> unless you want Q to have its own unique instances
21:22:02 <mseeks> isn't there a reasonable extension of liftMaybe to any transformer stack including a Maybe or MaybeT?
21:22:10 <glguy> return $ MaybeT (return x)  :: Q n (MaybeT m a)
21:22:44 <mseeks> glguy: yeah, you're right
21:22:45 <glguy> With some Monad constraints
21:22:50 <mseeks> so that doesn't work
21:23:04 <mseeks> I guess it doesn't ever make sense to have two returns in a single expression
21:23:07 <EvanR> class MonadMaybe
21:23:17 <johnw> sure it can make sense
21:23:23 <johnw> return (return 10) :: [Maybe Int]
21:23:25 <glguy> You can't use the MaybeT aspect of Q without access to the constructor or some other magic maybe oriented operation
21:23:52 <mseeks> yeah, that was the feeling I had
21:24:29 <mseeks> given lift :: m a -> t m a and the desired result is Q a I don't think lift would work
21:24:47 <guhou> kazagistar: And adding in a StateT should get me the count back as well?
21:25:00 <EvanR> mseeks: well the ms dont match up
21:25:25 <guhou> :t StateT
21:25:26 <lambdabot> (s -> m (a, s)) -> StateT s m a
21:25:30 <mseeks> EvanR: there's no `t` in `Q a`
21:25:41 <EvanR> mseeks: i added m i Q m a because otherwise your newtype wont compile
21:25:49 <EvanR> which is the m in MaybeT m a
21:26:09 <jle`> Maybe to MaybeT
21:26:19 <glguy> Q is the 't' in lift's  t m a
21:26:19 <mseeks> EvanR: I originally meant m as a standin for something else; in my actual code `m` is replaced by `ReaderT ...` and some stuff
21:26:33 <jle`> :t maybe mzero return
21:26:34 <lambdabot> MonadPlus m => Maybe a -> m a
21:26:57 <jle`> :t maybe mzero return :: Monad m => Maybe a -> MaybeT m a
21:26:58 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
21:26:58 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
21:27:04 <EvanR> mseeks: thats fine, im just saying newtype Q a = Q (MaybeT m a) is illegal
21:27:13 <mseeks> EvanR: you're right, sorry that wasn't clear
21:27:21 <jle`> oh someone already said that
21:28:10 <mseeks> johnw: I guess people use MonadError where you might want MonadMaybe
21:28:37 <hakujin> :info mzero
21:29:13 <mseeks> would it be useful to have a MonadMaybe and liftMaybe?
21:29:32 <johnw> Maybe is not a terribly useful type to convey errors
21:29:41 <athan> ...so Data.Typable gives us heterogeneous pattern matching with `cast`?
21:31:07 <EvanR> Typable gives runtime type tags associated with your values
21:31:26 <EvanR> er, that you can associate with values, if you want
21:34:01 <athan> EvanR: Ahh okay, that makes sense
21:34:38 <EvanR> Data.Dynamic bundles them together to give a dynamically typed value
21:39:06 <Javran> why does "-outputdir" argument generates Main.o and Main.hi whatever source file name is?
21:40:02 <mseeks> inside a MonadPlus, how would you treat an IO value such that you fail with mzero in the underlying MonadPlus if an IO exception occurs, otherwise apply liftIO?
21:40:15 <mseeks> here's a small paste: http://lpaste.net/118472
21:40:37 <mseeks> the relevant line is l:11, `r <- liftIO $ getWith opts url `E.catch` const mzero`
21:40:44 <mseeks> it doesn't work because mzero doesn't have type IO a
21:47:24 * hackagebot learning-hmm 0.3.1.0 - Yet another library for hidden Markov models  http://hackage.haskell.org/package/learning-hmm-0.3.1.0 (mnacamura)
21:56:07 <neionz> what does lazy evaluation have to do with termination?
21:56:20 <neionz> nvm
21:56:27 <neionz> or, what does it have to do with it?
22:01:39 <mseeks> where is the HttpException type constructor exported from
22:01:40 <mseeks> ?
22:02:02 <neionz> wow, http+haskell. Why?
22:02:35 <mseeks> ?
22:03:17 <sshine> neionz: web services, web crawlers, web proxies... well, web anything.
22:05:11 <neionz> why in haskell?
22:05:54 <Ralith> because otherwise you'd have to use something else
22:05:57 <Ralith> and that would suck
22:07:06 <neionz> Ralith: do you know c/c++ some server sided scripting language, linux or java?
22:07:07 <jle`> or maybe because haskell is well-suited for web programming :)
22:07:15 <neionz> btw, is this code making any sense? http://pastebin.com/sgshFS9d
22:07:18 <jle`> or interfacing with the web
22:07:44 <mseeks> neionz: no, what are you trying to do?
22:08:10 <glguy> neionz: You need to indent lines 2,3,4 if you want them to be on separate lines like that
22:08:41 <glguy> Haskell is a general purpose programming language, so you'll find people using it to solve a lot of problems
22:08:44 <neionz> mseeks: I'm trying to understand what that means, some old note I had
22:09:31 <neionz> glguy: you don't implement high loaded services with it though
22:09:35 <mseeks> neionz: would make more sense as `data F x = F Int [x] deriving (Eq, Show)
22:09:37 <glguy> Data Foo x = F Int [x] deriving (Show, Eq) -- This defines a new type constructor, a new data constructor, and some instances (Show and Eq)
22:09:57 <glguy> neionz: You'll want to learn more about it before you'll be ready to make those kinds of judgements
22:10:14 <platz> C++. a server sided "scripting" language
22:10:37 <neionz> mseeks: all you did was to add `  (and fixing the indent). Does it make sense now? What sense does it make?
22:11:26 <neionz> glguy: I'm speaking from experience in competitive programming. The guys who used haskell couldn't solve a certain problem faster than 2s, while it was solved in 0.3s in c
22:11:36 <neionz> glguy: they tried and they knew what they were doing.
22:11:59 <neionz> glguy: we had a very long discussion about it afterwards. These guys are pro haskell programmers.
22:12:24 <mseeks> neionz: what's your point
22:12:31 <neionz> mseeks: why did you add the `?
22:12:36 <neionz> `
22:12:48 <mseeks> i forgot to close the `
22:12:52 <EvanR> competitive programming, at the highest levels
22:12:56 <glguy> neionz: Cool, it sounds like your mind's all made up. That'll save everyone some time :)
22:13:44 <neionz> mseeks: what for?
22:15:45 <mseeks> usually enclose in `` to indicate code
22:16:16 <neionz> mseeks: why did you do that?
22:17:07 --- mode: ChanServ set +q *!*@*/lolwhat
22:17:27 <nshepperd> you can always write your inner loop in C and call it from the haskell ffi
22:17:49 <EvanR> well, you could write your inner loop in haskell too
22:17:51 <nshepperd> eg. hmatrix is basically just a wrapper around BLAS/lapack
22:52:27 * hackagebot wai 3.0.2.2 - Web Application Interface.  http://hackage.haskell.org/package/wai-3.0.2.2 (MichaelSnoyman)
22:57:27 * hackagebot warp-tls 3.0.1.3 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-3.0.1.3 (MichaelSnoyman)
23:12:47 <Lokathor> i tried to setup a basic haskell IRC bot, but it couldn't join a channel on the IRC server in question. though it could do so on freenode, so i think the IRC server is at fault
23:19:19 <AshyIsMe> Lokathor: are you looking at the lambdabot code? it could be helpful
23:19:32 <AshyIsMe> though if it works on freenode it does sound like the other network is at fault
23:20:10 <Lokathor> I tried the "roll  your own IRC bot" code, which just uses some web handles. There's a ircbot package on hackage i'll try next, maybe it's smarter about special cases i don't know about
23:27:04 <Lokathor> wow this ircbot package is far more complicated than i expected >_<
23:28:38 <AshyIsMe> unfortunately haskell code has been like that so far for me too
23:28:50 <AshyIsMe> it's not like python where you can just grab a library and read through the code with ease
23:28:56 <Lokathor> https://hackage.haskell.org/package/ircbot-0.6.1/docs/Network-IRC-Bot-BotMonad.html#t:BotPartT
23:29:01 <Lokathor> I need to make a list of these
23:29:08 <Lokathor> and i need to include some specific ones
23:29:19 <Lokathor> I'm not sure how I make the first one, much less any specific ones
23:30:46 <AshyIsMe> did you look at the demo sample?  http://hub.darcs.net/stepcut/ircbot/browse/demo.hs
23:32:52 <Lokathor> oh a demo
23:33:25 <barrucadu> Lokathor: What was the problem with joining a channel on the non-freenode network? Did you get an error message from the server printed out?
23:33:28 <Lokathor> I had found the parts on my own, but i was wonderinf where I'd get a TVar (Set ByteString), among other things
23:33:57 <CoconutCrab> my experience with haskell is after reading the wikibook, start to write some pet program, open the Parsec document and have my brain exploded at the type signature of ParsecT..
23:34:22 <banister> CoconutCrabs eat cats
23:34:24 <Axman6> ignore ParsecT and just use Parsec
23:34:41 <Lokathor> barrucadu: There didn't appear to be any errors that I could see.
23:34:44 <Lokathor> 1 moment
23:35:00 * CoconutCrab nibbles his cat's ear
23:35:04 <Axman6> the transformers is just there so it can be used with different base types (String, Text, ByteString etc.) and give you some jund of state if you need it
23:35:16 <barrucadu> TVars come from STM (https://hackage.haskell.org/package/stm), Parallel and Concurrent Programming in Haskell gives a good intro: http://chimera.labs.oreilly.com/books/1230000000929/index.html
23:35:39 <lpaste> Lokathor pasted “bot-output” at http://lpaste.net/118476
23:36:02 <CoconutCrab> Axman6: I mean, there seems to be some kind of 'enlightment' gap for understanding haskell
23:36:11 <Lokathor> and then it just sits there, sending out the occasional PONG in reply to a PING
23:36:14 <CoconutCrab> so, back to reading more, typeclassopedia etc..
23:36:34 <barrucadu> Odd, everything looks ok
23:36:42 <sgronblo> I agree with the observation about ease of use of Python
23:36:47 <Lokathor> whereas, the same bot, if configured to connect to freenode, will join a channel successfully
23:37:03 <Axman6> CoconutCrab: once you get the basic concept of monad transformers (which is easier to grok than coming to terms with monads themselves), the parsec transformer won't be that difficult to grasp
23:37:05 <sgronblo> Many times you just pip install something check some simple examples and boom problem solved, get shit done!
23:37:44 <Lokathor> Axman6 Oddly, I never had a huge difficulty with the Monad stuff compared to some other haskell concepts
23:37:51 <Lokathor> like weird Kind gymnastics
23:37:56 * CoconutCrab crawls back to his hole and continue mediating
23:38:19 <quchen2> CoconutCrab: "ParsecT s u m a is a parser with stream type s, user state type u, underlying monad m and return type a. Parsec is strict in the user state." -- in other words, the "s" parameter is your input, the "a" is what you're parsing it to. "m" is for monad transformers (which you can ignore when first reading about Parsec), and "u" is ignorable too I guess.
23:39:39 <Axman6> everything but a is ignorable is you use the Parsec type =)
23:39:59 <CoconutCrab> I mean, coming from Maybe/List (which has 1 type variable and fairly simple) -> state monad (the construction is a function, what?) -> parsec (4 type vars...)
23:40:13 <Axman6> iirc, there's a type Parsec a = ParsecT Char () Identity a defined somewhere
23:40:14 <CoconutCrab> it makes sense after you put the pieces into place
23:40:15 <quchen2> Only two type vars if you ignore two! :-)
23:40:29 <CoconutCrab> but at first it was (and still is) quite daunting
23:40:41 <Lokathor> AshyIsMe: The demo won't compile!
23:40:50 <Axman6> that's why you ask questions =)
23:41:10 <Axman6> Lokathor: what sort of weird Kind gymnastics?
23:41:13 <Lokathor> GHC tells me Couldn't match expected type `network-2.5.0.0:Network.PortID' with actual type `PortID'
23:41:27 <quchen2> No sandbox is my guess
23:41:34 <zwer> CoconutCrab you can stick to `Parser' for most things. parseInt :: Parser Int
23:42:10 <Lokathor> well i installed the ircbot package just moments ago, so it should have pulled in all the other dependencies properly
23:42:17 <CoconutCrab> zwer: that is just an example of how shallow my understanding for haskell :)
23:42:51 <CoconutCrab> of*
23:43:05 <Lokathor> Axman6 i dont' even recall the exact example, but something about a Foo f = Int (f IO) or something
23:43:34 <Axman6> that looks very broken =)
23:43:51 <Lokathor> well i'm sure i'm remebering it wrong
23:44:21 <Lokathor> i have just not had a single programming success of any kind today and my brain is starting to fail
23:44:40 <ab9rf> 30 centiliters of whiskey, stat
23:45:06 <Lokathor> i mean, i couldn't even dupliate an older success i'd done before
23:45:11 <Axman6> Make it Laphroaig, this sounds like a doosy!
23:45:18 <Lokathor> i used to have hscurses on this machine, couldn't get it running a second time
23:46:02 <AshyIsMe> Lokathor: wow that's not good
23:46:12 <ab9rf> i never managed to get hscurses to work
23:47:03 <AshyIsMe> Lokathor: we all have those days sometimes
23:47:14 <ab9rf> i did contemplate reimplementing it in pure haskell
23:47:24 <ab9rf> instead of as a binding to the C library :)
23:47:55 <ab9rf> but then i got bored and forgot all about it
23:48:15 <ab9rf> actually, i think the kids got home from school
23:48:39 <Lokathor> if you can get a pure-haskell output system that works across both linux and windows i'll put a picture frame of you above my computer
23:48:50 <ab9rf> haha
23:49:05 <Lokathor> curses-style or SDL-style or just about anything above the terminal level really
23:49:23 <ab9rf> Lokathor: could probably pull that off with opengl, but it would suck CPU
23:49:36 <ab9rf> i have managed to get the opengl bindings to work, after a fashion
23:50:02 <Lokathor> building OGL or SDL on windows at all is a pain, then getting it to work with haskell is also a pain. no support for windows development most of the time it seems
23:50:30 <ab9rf> Lokathor: the windows environment is not very much like the linux environment
23:50:38 <Lokathor> sadly so
23:50:56 <Lokathor> I also had SDL working the other day... but my happy setup was smashed when cabal fraked out with some sort of path issue or something, and refused to install any further packages ever
23:51:10 <ab9rf> if i had more horsepower i'd probably look iunto what would be required to get ghc to compile in MSVC
23:51:44 <kazagistar> Lokathor: would a local web server count as a pure haskell output system?
23:51:46 <ab9rf> the dependence that haskell platform has on msys/cygwin is a real pain
23:52:29 * hackagebot wai-app-static 3.0.0.6 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-3.0.0.6 (MichaelSnoyman)
23:52:47 <Lokathor> kazagistar: ha, well maybe, but not likely :P i mean I personally can tolerate mostly command line stuff, but my goal is to be able to build a program that i could potentially send to someone else
23:53:07 <Lokathor> in java, i can just write something in swing and make a jar and send it and i'm done
23:53:10 <kazagistar> throw up a server on loopback, boot up default browser pointing at it
23:53:18 <Lokathor> in any other language it quickly becomes difficult
23:53:25 <Lokathor> loopback server might work >_<
23:54:14 <kazagistar> then you have a totally standardized UI platform that works across every system
23:54:41 <Lokathor> well if i could get SDL working again then that would be fine enough, but that's more of a weekend project
23:54:56 <Lokathor> i thought that setting up an ircbot example would be an easy time, but it's been 10 hours
23:55:26 <kazagistar> time estimates >_>
23:56:33 <Lokathor> so then, when ghc tells me Couldn't match expected type 'network-2.5.0.0:Network.PortID' with actual type 'PortID'
23:56:40 <Lokathor> that's a package version issue?
23:57:17 <glguy> Sounds like you've installed two versions of network
23:58:22 <glguy> And then tried to use them both at the same time, inadvertently
23:58:33 <Lokathor> hmm
23:59:31 <glguy> I have a tool on my github to help detect that and recursively unregister packages to get back to a single version of things
23:59:46 <glguy> Or you can use ghc-pkg command manually
23:59:53 <Lokathor> does it run on ARM based linux?
