01:46:28 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
01:46:28 --- topic: set by geekosaur on [Sun Dec 21 13:35:50 2014]
01:56:30 <stephangorgen> :Q
01:59:35 <quchen2> chpatrick: Hardly more readable :-\
01:59:43 <quchen2> And orphan instance
02:00:21 <quchen2> I thought maybe there was something with a nifty Writer or something I could use for this. Anyway, thanks.
02:28:48 * hackagebot smtlib2 0.2 - A type-safe interface to communicate with an SMT solver.  http://hackage.haskell.org/package/smtlib2-0.2 (HenningGuenther)
02:53:49 <sinelaw> so, what's NaN in haskell?
02:53:52 <sinelaw> :t (0/0)
02:53:54 <lambdabot> Fractional a => a
02:53:55 <sinelaw> > 0/0
02:53:56 <lambdabot>  NaN
02:54:09 <sinelaw> :t 0
02:54:10 <lambdabot> Num a => a
02:55:15 <merijn> 0/0 is not guaranteed to be NaN
02:55:24 <merijn> > 0/0 :: Ratio
02:55:26 <lambdabot>  Expecting one more argument to ‚ÄòGHC.Real.Ratio‚Äô
02:55:26 <lambdabot>  Expected a type, but ‚ÄòGHC.Real.Ratio‚Äô has kind ‚Äò* -> *‚Äô
02:55:28 <merijn> > 0/0 :: Ratio Int
02:55:30 <lambdabot>  *Exception: Ratio has zero denominator
02:55:46 <sinelaw> merijn, why does it choose NaN above?
02:55:50 <merijn> Only Double has NaN and that's solely for IEEE754 correctness
02:56:03 <merijn> sinelaw: Because the default type for Fractional is Double :)
02:56:06 <sinelaw> merijn, that's what I expect - is it choosing Double as the default Fractional?
02:56:28 <rasen> Yes
02:56:49 <sinelaw> ok
02:57:00 <rasen> When it's ambiguous what Num type is for it chooses Integer or Double.
02:57:05 <rasen> By default
02:57:11 <merijn> > 2/8 + 4/8 :: Ratio Int
02:57:12 <sinelaw> this is since 7.8, right?
02:57:12 <lambdabot>  3 % 4
02:57:17 <merijn> sinelaw: Now, since forever
02:57:20 <merijn> *No
02:57:24 <sinelaw> hmm
02:57:41 <merijn> This is why you compile with -Wall to get defaulting warnings :p
02:58:30 <sinelaw> right. was confused by lambdabot's lack of warnings. ghci -Wall says it:
02:58:36 <sinelaw> > 0/0
02:58:36 <sinelaw> <interactive>:2:1: Warning:
02:58:36 <sinelaw>     Defaulting the following constraint(s) to type ëDoubleí
02:58:36 <sinelaw> ....
02:58:38 <lambdabot>  NaN
03:19:57 <zq> git coffee
03:20:11 <aeht132> hullo
03:21:51 <aeht132> is there a way to import a hidden module?
03:22:32 <rasen> I think no. That's exactly the reason why it's hidden
03:22:34 <MP2E> no, that's why it is hidden :)
03:23:10 <gds> aeht132: Depending on what you're doing, you might want to add the package that module lives in to your cabal file.
03:23:48 <aeht132> why, hidden pieces of code are exactly there to be tinkered with
03:24:20 <aeht132> gds: thanks
03:24:31 <gds> np
03:26:00 <Athas> Is there a tool that can give me a list of all names that are exported from my modules, yet not used anywhere?
03:26:27 <aeht132> gds: you mean in the build-depends field?
03:29:16 <zq> Athas: cabal checks for you usually
03:29:22 <zq> Athas: cabal build, i mean
03:29:38 <bitonic> zq: no it doesn't
03:31:14 <gds> aeht132: Yeah, the build-depends field.
03:32:31 <aeht132> gds: well, the package with the hidden module is already in there
03:32:38 <bitonic> Athas: anyway, not that I know of.  it'd be useful.
03:32:47 <gds> huh
03:32:48 <bitonic> especially for cabal projects with executable targets
03:33:01 <Athas> bitonic: indeed.  I might take a swing at this; can't be too hard.
03:33:48 <gds> aeht132: what action on your part is it that causes the error message? Are you running cabal build?
03:34:19 <aeht132> no i'm importing from the repl
03:34:23 <aeht132> from cabal repl
03:34:28 * gds nods
03:35:13 <aeht132> *HBI> import Numeric.Sparse  <no location info>:     Could not find module ‚ÄòNumeric.Sparse‚Äô     it is a hidden module in the package ‚Äòhmatrix-0.16.1.3‚Äô
03:35:44 <gds> What happens if you put the import in a file?
03:35:57 <zq> bitonic: has this behavior changed recently? there used to be "defined but not used" warnings when i ran cabal build
03:36:02 * gds hasn't played with importing like that in the repl.
03:36:09 <aeht132> gds: which is a shame because this is a really cool feature
03:36:11 <bitonic> zq: those warnings are per-module
03:36:24 <bitonic> exported functions are not considered "unused" (rightly so)
03:36:51 <aeht132> gds: I mean the sparse solver, not you not playing with manual imports :D
03:36:52 <jle`> wait, is Prelude.foldr really becoming the Data.Foldable one?
03:37:19 <bitonic> jle`: yep!  rejoice!
03:37:37 <jle`> :O
03:38:14 <zq> anyway, these messages are emitted by ghc's -Wall
03:38:21 <zq> cabal emits nothing on its own
03:38:48 <bitonic> yeah, they're the standard "unused definition" messages.  there is no cross-module analysis
03:38:51 <zq> and ghc compiles each module independently
03:38:56 <gds> aeht132: have you done cabal install --only-dependancies yet?
03:39:11 <zq> so it'd be pretty awkward for cabal to start filling in
03:39:27 <aeht132> gds: all the deps are in place already
03:39:31 <arianvp___> Hey guys I cant get cabal-install to work on nix
03:39:31 <bitonic> I don't think it'd be bad for cabal to offer such tools
03:39:59 <arianvp___> I get a build error
03:40:01 <arianvp___> https://gist.github.com/arianvp/7c78f94251bfa335afa5
03:40:41 <gds> aeht132: Ok, I just did an experiment on my machine...
03:40:52 <gds> I created a new project in an empty tmp dir with cabal init
03:41:10 <gds> I ran cabal repl and did import Test.Quickcheck
03:41:18 <rasen> gds: Show your .cabal file
03:41:19 <gds> and got the error message (hidden package)
03:41:29 <gds> I added Quickcheck to my cabal file...
03:41:44 <gds> and when I did the import in the cabal repl, it imported fine.
03:41:45 <rasen> gds: probably you should add network-uri to dependencies.
03:41:58 <gds> rasen: Sorry -- I'm not the one with the problem :)
03:42:08 <gds> I'm trying to reproduce aeht132's problem.
03:42:16 <gds> I was just describing how I failed to do so :)
03:42:26 <rasen> Ohm... I was messaging to arianvp___
03:42:35 <gds> (in the hope that'd be useful)
03:42:37 <arianvp___> cabal file?
03:42:49 <arianvp___> I'm tring to do  "nix-env -i cabal-install"
03:42:53 <aeht132> gds: thanks a lot, I'll try it
03:42:57 <arianvp___> the system package manager is giving this error. not cabal
03:43:25 <arianvp___> Soo the answer would be. it's cabal-install's cabal file. which I have no control over
03:45:24 <alnix> hello, i want to install ghc-mod via cabal but i have this error: http://lpaste.net/119299
03:46:33 <rasen> arianvp___: I see there is flag network-uri in cabal-install package. Not sure, but it could be related
03:47:37 <makalu> I have a cabal sandbox. If I start cabal repl I can import the modules installed in the sandbox. If I use inferior-haskell in Emacs with "cabal repl" it will not find the modules. How could I debug this?
03:48:09 <gregnwosu> makalu: they should be there
03:48:19 <Haskellfant> haskell/cabal usually does incremental builds, right?
03:48:22 <gregnwosu> you may need to cabal install --only-dependencies
03:48:28 <Haskellfant> e.g. only recompiles the files that I changed
03:48:37 <gregnwosu> that should install the dependencies into your sandbox
03:49:00 <arianvp___> rasen: Apparently haskellPackages is deprecrated. had to switch to haskellngPackages. Stuff works now
03:49:02 <arianvp___> thanks anyway :)
03:49:18 <rasen> arianvp___: no problem
03:49:19 <gregnwosu> hi what is the name for '<*'
03:49:33 <gregnwosu> i want to know if they have the same operation in Scala
03:50:46 <rasen> gregnwosu: I see there is <* operator in Apply (scalaz)
03:50:53 <ClaudiusMaximus> makalu: maybe it starts cabal repl in the wrong working directory
03:51:30 <gregnwosu> thanks rasen , I wonder if it will work with Parboiled, in the same way going to hack some parsers today
03:52:02 <gregnwosu> rasen: dont see any reason why not? incidently how did you find that operator?
03:52:24 <gregnwosu> when i tried a hoogle search for ''<*' it got very confused
03:52:28 <rasen> gregnwosu: Just google out "scalaz applicative"
03:52:38 <chpatrick> gregnwosu: it's from Control.Applicative
03:52:42 <makalu> ClaudiusMaximus: if I import getCurrentDirectory and use it in the opened cabal repl buffer I get the correct directory
03:53:23 <chpatrick> it means chain two applicatives and give me the "result" from the left one
03:55:54 <jle`> lie how (x >> y) sequences the two things together and the final result of the whole thing is the result of y
03:56:02 <jle`> > Just 4 >> Just 8
03:56:04 <lambdabot>  Just 8
03:56:26 <chpatrick> there's also *> which is exactly the same as >>
03:56:27 <jle`> (x >> y) is (x *> y).  so (x <* y) sequences the two things together and teh finalr esult of thee whole thing is the reuslt of x
03:56:39 <jle`> > Just 4 *> Just 8
03:56:41 <lambdabot>  Just 8
03:56:53 <athan> > Just 4 <* Just 8
03:56:53 <jle`> > Just 4 <* Just 8
03:56:55 <lambdabot>  Just 4
03:56:55 <lambdabot>  can't find file: L.hs
03:56:58 <athan> :P
03:57:01 <jle`> > Just 10 <* Nothing
03:57:03 <lambdabot>  Nothing
03:57:19 <chpatrick> wait what happened there
03:57:28 <chpatrick> with lambdabot
03:57:35 <jle`> IO error
03:57:41 <jle`> it happens every once in a while
03:57:51 <chpatrick> hmm
03:58:05 <jle`> L.hs is the file containing lambdabot-specific commands
03:58:10 <jle`> and user-defined commands
03:58:17 <jle`> sometimes there is an IO error reading it for some reason
03:58:31 <chpatrick> maybe it's a concurrency thing because there were two commands in a short time?
03:58:42 <Zemyla> Is a Haskell programmer someone who can't tell the difference between a nut and a coconut?
03:58:50 <athan> does `<*` create a "dependence" on the rhs?
03:58:56 <chpatrick> it wrote both into the file, deleted it after running the first one, then the second one failed?
03:59:01 <makalu> oh it seems haskell mode does not respect haskell-program-name. I entered something non-existant and it still opened a repl.
03:59:03 <athan> as the implementation of the instance?
03:59:20 <chpatrick> it has to be the same as lhs?
03:59:37 <jle`> athan: it goes through "both effects" but remembers the first result
03:59:44 <arianvp___> Anybody got ghc-mod to work with cabal1.22 and ghc-8.7.4?
03:59:56 <jle`> athan: for monads, x <* y = do { x' <- x; y; return x' }
03:59:58 <athan> jle`: And the effect overwrites?
04:00:12 <athan> > Just 4 <* Nothing
04:00:13 <jle`> the effect still happens, but the "return value" is swapped out
04:00:13 <lambdabot>  Nothing
04:00:17 <athan> hmm
04:00:23 <athan> Alright :)
04:00:23 <jle`> > do { x <- Just 4; Nothing; return x }
04:00:24 <lambdabot>  Nothing
04:00:24 <chpatrick> @t \f f' -> fmap const f <*> f'
04:00:25 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
04:00:33 <chpatrick> :t \f f' -> fmap const f <*> f'
04:00:33 <athan> hmm!
04:00:33 <jle`> i found a better example
04:00:34 <lambdabot> Applicative f => f b -> f a -> f b
04:00:37 <athan> oh wow
04:00:39 <athan> okay I see
04:00:50 <jle`> > ("hello", 4) *> ("world", 8)
04:00:52 <lambdabot>  ("helloworld",8)
04:00:57 <jle`> the "effect" here is the accumulator, the first field
04:01:10 <jle`> with every sequencing, the new thing is "tacked on"
04:01:16 <jle`> but guess what happens when we do:
04:01:24 <jle`> > ("hello", 4) <* ("world", 8)
04:01:26 <lambdabot>  ("helloworld",4)
04:01:45 <jle`> the effect (appending "world" to "hello") is the same in the end, but the result of the first is returned instead
04:02:04 <jle`> the effects are carried out in their entirety like normal
04:02:18 <arianvp___> Monoid m => (m,a)  is an instance of monad since when? :O
04:02:26 <arianvp___> wait is that just Writer?
04:02:26 <merijn> arianvp___: Since a long time? :>
04:02:33 <merijn> arianvp___: Yes
04:02:34 <jle`> it's Writer, but i don't think it's in base
04:02:42 <merijn> jle`: I think it was added
04:02:47 <jle`> really?! :O :O
04:02:49 <arianvp___> I thought only the newtype versions were instanced monad
04:03:03 <jle`> arianvp___: well, (->) r has been a monad for a long time
04:03:04 <arianvp___> Is state also instanced unwrapped?
04:03:09 <arianvp___> yeh I know that
04:03:14 <jle`> State can't be instanced unwrapped
04:03:23 <jle`> the kinds don't really work out
04:03:34 <jle`> or well you can't really express it in haskell
04:03:52 * hackagebot Hs2lib 0.6.3 - A Library and Preprocessor that makes it easier to create shared libs from Haskell programs.  http://hackage.haskell.org/package/Hs2lib-0.6.3 (TamarChristina)
04:03:57 <jle`> instance Monad ((->) s . (,s)) where ...
04:04:28 <jle`> merijn: where is it added in? 7.10 ?
04:05:12 <merijn> jle`: I just looked and maybe it's not there :\
04:05:23 <merijn> jle`: File a Trac ticket! ;)
04:05:34 <merijn> Should be fairly uncontroversial, I think
04:05:45 <jle`> i mentioned this earlier and someone told me that there was some controvery around it
04:06:02 <merijn> Proposals go to libraries@ ;)
04:06:02 <jle`> maybe i misunderstood what they were trying to say
04:06:11 <jle`> the Applicative instance is already in there so ...
04:06:41 <merijn> I also wish there would be an "instance (Monoid a, Monad m) => Monoid (m a)"
04:07:11 <merijn> But people complain it overlaps too much :\
04:08:05 <jle`> you mean the instance (Monoid a, Applicative f) => Monoid (f a) ?
04:08:20 <aeht132> is there a way to share a sandbox between projects? softlinking cabal.sandbox.config in the project directory doesn't seem to work.. am I missing something?
04:08:31 <jle`> mappend = liftA2 mappend; mempty = pure mempty?
04:09:10 <jle`> one problem would be that the monoid instance for [a] is now completely different :P
04:09:20 <merijn> aeht132: Step one: consult "cabal sandbox --help" Step two: Realise there is an "add-source" command
04:09:32 <jle`> and [a]'s current monoid instance is a someone distinguished/privileged one
04:09:33 <jle`> so :/
04:09:53 <merijn> jle`: Yeah, which is why it doesn't exist
04:09:55 <Peaker> jle`: there needs to be a newtype somewhere in base
04:09:59 <Peaker> ApplicativeMonoid
04:10:04 <jle`> ApplicativeNum too
04:10:11 <jle`> and ApplicativeFractional ...
04:10:12 <merijn> I guess I should at least campaign for "Monoid a => Monoid (IO a)"
04:10:25 <aeht132> merijn: ah, the good old rtfm. that's what irc is for
04:10:33 <aeht132> merijn: thanks
04:10:36 <Peaker> https://github.com/Peaker/lamdu/blob/master/bottlelib/Data/Monoid/Applicative.hs#L6-L12
04:11:04 <jle`> what about instance Monoid (IO a) where it returns the first non-erroring value :P
04:11:11 <jle`> aka the MonadPlus instance
04:11:44 <Peaker> I guess Applicative can lift pretty much any class :)
04:11:51 <jle`> not quite :O
04:11:57 <Peaker> which can't it?
04:12:03 <jle`> oh
04:12:06 <jle`> i remember thinking about this
04:12:48 <jle`> only classes where all of the members have final results of the type i think.
04:12:52 <jle`> (did i think this through?)
04:14:15 <jle`> i could be wrong
04:14:29 <jle`> i'm trying to imagine how Eq would look
04:15:04 <jle`> instance (Applicative f, Eq a) => Eq (f a) where x == y = ...?
04:15:07 <Peaker> jle`: you're right :)
04:15:10 <jle`> woo hoo
04:15:24 <jle`> to be fair if i'm right at 4:15am it's probably more luck than anything
04:15:47 <Peaker> yeah, you can only lift classes where the result (I guess all covariant stuff) is also a value/wrapped, OR ones where you don't have to "look inside" the value to generate the result
04:16:12 <aeht132> merijn: however, I think what you suggest covers a different case: I have an executable-type sandbox, that should have access to a library-type sandbox (the former doesn't produce a cabal.sandbox.config )
04:16:22 <jle`> i should be off now :) night all
04:16:37 <Peaker> but indeed an ApplicativeMonoid newtype makes no sense -- an ApplicativeWrapper newtype that has instances for Num*, Monoid, ... makes more sense
04:16:41 <Peaker> jle`: night!
04:17:15 <Haskellfant> does cabal configure break incremental builds?
04:17:19 <merijn> aeht132: I don't know what "executable-type" vs "library-type" sandbox means, there's only one type of sandbox, afaik?
04:17:24 <merijn> Haskellfant: Yes
04:17:25 <Peaker> conal had some generalization of Eq/Booleans that made it psosible, I think
04:17:31 <merijn> Haskellfant: Because flags may have changed
04:17:40 <aeht132> merijn: during cabal init you get this choice
04:17:45 <Haskellfant> merijn: ah ok, then I need to get nix to somehow not reconfigure everytime
04:18:05 <Haskellfant> it takes 10minutes to see if my changes to Cabal work correctly in cabal-install :)
04:20:33 <Haskellfant> so currently 'cabal repl' closes immediately if there are no exposed-modules. I personally would prefer if it did open nonetheless. The other possibilty would be to at least add an error message there. Any opinions?
04:23:51 <Haskellfant> maybe open the repl but print a verbose message?
04:23:53 <hexagoxel> Haskellfant: i am pretty sure there is an open issue about this; i noticed the same thing a few days back
04:24:16 <Haskellfant> hexagoxel: I know https://github.com/haskell/cabal/issues/1986 I'm trying to fix it
04:24:34 <Haskellfant> but I'm not sure if that's expected behaviour and just the error message is missing or if the repl should open always
04:24:49 <Haskellfant> personally I prefer the second choice but I might be missing something
04:26:20 <hexagoxel> Haskellfant: makes sense, given that the repl opens if there is no .cabal package
04:26:31 <Haskellfant> hexagoxel: alright I'll submit a PR
04:28:01 <hexagoxel> aeht132: you found `cabal sandbox init --sandbox=foo` ?
04:28:48 <hexagoxel> and you are right in add-source having a different purpose
04:28:53 * hackagebot grid 7.6.10 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.6.10 (AmyDeBuitleir)
04:33:02 <aeht132> hexagoxel
04:34:26 <hexagoxel> meow
04:36:54 <ClaudiusMaximus> so, installed ghc-7.10.1~rc2, installed cabal-install, now i get this from cabal install: cabal: Distribution/Client/Config.hs:(246,37)-(299,9): Missing field in record construction configProf
04:37:09 <ClaudiusMaximus> cabal-install version 1.22.0.0
04:37:09 <ClaudiusMaximus> using version 1.22.1.0 of the Cabal library
04:38:25 <dcoutts> ClaudiusMaximus: make sure it's been reported, either with ghc or cabal
04:38:52 <ClaudiusMaximus> dcoutts: got a link to issue tracker?  gotta go out in 5mins...
04:38:54 * hackagebot laika 0.1.1 - Minimalistic type-checked compile-time template engine  http://hackage.haskell.org/package/laika-0.1.1 (NikitaVolkov)
04:39:36 <aeht132> hexagoxel: thanks for the tip, but it behaves in a weird way: it actually creates a sandbox in the dir specified by --sandbox=foo, rather than jsut using the preexisting one
04:40:08 <dcoutts> ClaudiusMaximus: github cabal
04:40:20 <ClaudiusMaximus> dcoutts: oh.  i don't have a github account
04:41:56 <favetelinguis> Just starting my masterthesis and am thinking about using some haskell, the use case i have is that i have two xml files that i need to traverse and from them generate some arbitrary code in some arbitrary language of my coise. What sort of tools would be a good fit for this? Template haskell? And is it feasable to do this for someone on the level of understanding whenre i know how folding workds and how the do notation is related
04:42:29 <ClaudiusMaximus> dcoutts: anyway, i had cabal-install 1.20, then installed ghc 7.10, then cabal didn't work (wrong inplace package db conf format), then i upgraded cabal with -w ghc-7.8.2, then i reinstalled cabal with ghc 7.10, and now the breakage
04:42:55 <frawgie> favetelinguis: from experience i would first look at the xml content to determine if haskell is a good choice
04:43:20 <frawgie> favetelinguis: e.g. it might not be (imo) if it uses omg's mof
04:44:03 <merijn> favetelinguis: xml-conduit is pretty easy
04:44:43 <merijn> Well, for some value of easy :)
04:44:51 <hexagoxel> aeht132: well yeah but if you refer to the same sandbox location from two different directories, both will use the same sandbox. this is my interpretation of "sharing".
04:44:58 <favetelinguis> frawgie, the xml file is generated by the company from a uml class diagram, however the contetnt of the xml file is decided by the company in a dtd spec applied in a model to model transfere
04:45:45 <barrucadu> favetelinguis: Isn't UML typically more suited to OOP code?
04:45:50 <ClaudiusMaximus> dcoutts: i get the error from running 'cabal install' inside a directory with cabal sandbox init, for this project with the base deps bumped to <4.9 : https://gitorious.org/mandelbrot/mandelbrot-symbolics  - before the error it prints Resolving dependencies...
04:45:55 * ClaudiusMaximus off
04:47:49 <quazimodo> ClaudiusMaximus: i thought you were circus maximus
04:48:05 <favetelinguis> im not generating code, im generating configurations i the form of cli commands
04:49:06 <frawgie> favetelinguis: if you can find a good way to model the problem in Haskell, sure go ahead :) just remember to share your thesis with us! : )
04:53:19 <tzaeru> so I just wrote a long database backup copy thingy that gets evaluated by something else.
04:53:22 <tzaeru> basically it's like
04:53:27 <tzaeru> aaand wrong channel!
04:53:40 <Xe> damnit
04:53:44 <Xe> now I'm curious
04:54:13 <tzaeru> (anyway, the command would have looked like "copy_command += "copy('"; copy_command += database_name + "', '") etc
04:54:52 <tzaeru> though the context that the right channel would have given, is that we poke fun at stupid things we see in co-employer's code there D: and I just wrote a ridiculously stupid thing.
05:00:07 <hexagoxel> ClaudiusMaximus: btw you do not really need version constraints in the executable if it depends on the library in the same package.
05:02:05 <sdegutis> Does Haskell have a standard function or operator defined as fn x f = f x ?
05:02:26 <barrucadu> @src ($)
05:02:26 <lambdabot> f $ x = f x
05:02:31 <Iceland_jack> sdegutis: (&) (reverse function application) will get added in 7.10 to Data.Function
05:02:32 <barrucadu> Oh, the other way around
05:02:56 <aeht132> > :t flip ($)
05:02:58 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
05:03:08 <barrucadu> :t flip ($)
05:03:09 <lambdabot> b -> (b -> c) -> c
05:03:26 <aeht132> yep :)
05:04:18 <aeht132> hexagoxel: what I'd love to have is a directory with just the .hs sources, whereas the sandbox with all the libraries should be elsewhere. This is because I have to build on different boxes with different OSs
05:04:20 <nkar> hvr: I'm trying packunushed inside nix-shell.  it fails with "user error (Saved package config file seems to be corrupt.  Try re-running the configure command)".  any ideas?
05:04:33 <aeht132> hexagoxel: is this possible, you think?
05:05:03 <sdegutis> Iceland_jack: in the meantime, is it identical to define it myself as (&) x f = f x ?
05:05:29 <Iceland_jack> sure, or just 'x & f = f x' or '(&) = flip ($)' with the appropriate fixity declaration
05:05:44 <Iceland_jack>     infixl 1 &
05:06:30 <sdegutis> oh ok
05:06:47 <sdegutis> does anyone use that?
05:07:11 <sdegutis> Having used Clojure's ->> often, it being identical to the proposed & operator, I think I'd use it often.
05:07:56 <hexagoxel> aeht132: would using `hs-source-dirs: src` in the package not be sufficient? then you could share the src directory between systems.
05:08:32 <Iceland_jack> sdegutis: It's used in the lens package
05:08:53 <sdegutis> Great, I'll define and use it.
05:08:56 <sdegutis> Thanks :)
05:09:13 <sdegutis> I like LyaH the best out of all the books, and I'm on the chapter about Modules already.
05:10:14 <merijn> The modules chapter is more of a reference, FYI
05:10:22 <sdegutis> ok thx, noted
05:11:03 <Iceland_jack> sdegutis: https://hackage.haskell.org/package/lens-4.7/docs/Control-Lens-Lens.html#v:-38-
05:11:05 <hexagoxel> aeht132: and with a proper repository approach, this should be no problem at all, as you .gitignore the sandbox-related stuff. no propaganda intended :D
05:13:38 <lpaste> pyed pasted ‚ÄúheadOr‚Äù at http://lpaste.net/119300
05:14:35 <aeht132> hexagoxel: yes, this should be the way, thanks
05:14:36 <pyed> can someone please answer that ? [Warning] newbie question
05:15:18 <barrucadu> @src foldr
05:15:18 <lambdabot> foldr f z []     = z
05:15:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:15:51 <barrucadu> So in the empty list case you have `foldr const a []`, which is `a`
05:15:52 <gcganley> pyed: just joined, whats the question
05:16:09 <nkar> pyed: try to evaluate it step-by-step yourself
05:16:21 <nkar> using the definition above
05:16:53 <pyed> aha, so 'const' won't get even applied
05:16:56 <pyed> thanks
05:17:16 <pyed> I should've checked foldr definition first
05:17:59 <aeht132> @src const
05:17:59 <lambdabot> const x _ = x
05:18:22 <aeht132> it's actually the opposite: const always returns the first argument
05:19:35 <mniip> pyed, that definition is sure elegant but hella inefficient
05:20:01 <mniip> as such it doesn't seem like it would work on infinite lists
05:20:09 <pyed> no it works
05:20:14 <pyed> try
05:20:16 <mniip> oh right
05:20:42 <pyed> I think it's very cleaver definition
05:20:43 <merijn> mniip: And it's efficient too :)
05:21:21 <pyed> it's not mine for sure, it's from: https://github.com/tonymorris/course
05:21:40 <mniip> yeah
05:28:56 * hackagebot casadi-bindings-core 2.2.0.1 - autogenerated low level bindings to casadi  http://hackage.haskell.org/package/casadi-bindings-core-2.2.0.1 (GregHorn)
05:28:58 * hackagebot casadi-bindings 2.2.0.1 - mid-level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.2.0.1 (GregHorn)
05:35:27 <nkar> I'm getting an error when running packunused, which comes from somewhere else.  is there a way to find out which dependency causes this other than check all of them manually?
05:38:56 * hackagebot language-lua 0.6.2 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.6.2 (OmerAgacan)
05:43:04 <danilo2> Hello! :) Is it somehow (with a magic wand!) in Haskell to define instances that are matched for some Nat kinded parameter only when Nat > 0 ? I mean, the following code gives me fundeps conflict and I can resolve it by generating many such instances: http://lpaste.net/119303
05:46:02 <bennofs> danilo2: maybe it works if you do (..., AppDefaults n ...) => AppDefaults (n + 1) ... ?
05:46:13 <bennofs> (instead of n-1, n)
05:48:35 <danilo2> bennofs: Nope, becasue the fundep is between the Nat and tuple, I mean n -> () and n -> (a,as) (where -> means fundep)
05:48:57 * hackagebot c-storable-deriving 0.1.1 - Generate C-like storable instances from datatypes  http://hackage.haskell.org/package/c-storable-deriving-0.1.1 (MatthewMaurer)
05:49:19 <danilo2> bennofs: additional it would not make any sense - I want to apply all args unless n goes to 0
05:54:12 <danilo2> bennofs: Ok! I resolved it, simply by putting (sig~(a,s)) to the context!
05:54:12 <danilo2> :D
05:54:28 <phischu> where is the best place to ask a question about a possible regression in cpphs?
05:55:32 <athan> danilo2: Are you encoding small steps in type class instances? o_0
05:55:58 <xxprismxx> hello
05:56:07 <danilo2> athan: I do not know what are small steps, but I'm creating something like "type level" function application
05:56:22 <danilo2> athan: it is needed for some hacky internal library and it works like a charm now
05:56:29 <athan> danilo2: Oh!! I was thinking about steps for compiler semantics
05:56:32 <Iceland_jack> danilo2: Have you looked at the 'singletons' library?
05:56:36 <athan> dude check this out, you might enjoy it:
05:56:38 <Iceland_jack> It does that
05:57:01 <athan> danilo2: https://github.com/athanclark/dag/blob/master/src/Data/Graph/DAG/Edge.hs
05:57:09 <xxprismxx> i33t here ?
05:57:13 <athan> Also check out Data.Graph.DAG.Edge.Utils :)
05:57:40 <athan> wait... danilo2: type-level higher-order application?! :O
05:57:51 <danilo2> Iceland_jack: nope, but I'm reading about it right now. Is there any sensible documenatation appart from the paper?
05:58:48 <Iceland_jack> Depends what you call sensible.. maybe not a lot, there is a talk (video) on how singletons work by Richard Eisenberg
05:59:13 <Iceland_jack> danilo2: But mostly you just define your functions as normal Haskell functions within a Template Haskell splice
05:59:15 <danilo2> athan: just a function application, that supports polymorphic values. I mean, it allows to create currying with functions that you get as result from functional dependencies operations
05:59:27 <athan> :O!!!
05:59:42 <xxprismxx> what are we chatting about??
05:59:56 <athan> danilo2: Do you have an open repo? :)
06:00:07 <athan> xxprismxx: Haskelly stuff :D
06:00:33 <danilo2> Iceland_jack: hmm, I have to see ti. thank you! :)
06:01:07 <Iceland_jack> danilo2: Something like:
06:01:07 <Iceland_jack>     $(promoteOnly [d
06:01:07 <Iceland_jack>       length :: [a] -> Nat
06:01:07 <Iceland_jack>       length []     = 0
06:01:10 <Iceland_jack>       length (_:xs) = 1 + length xs
06:01:13 <Iceland_jack>     |])
06:01:17 <Iceland_jack> should do it
06:01:27 <Denommus> Iceland_jack: use a paste site
06:01:27 <Iceland_jack> from my limited Singletons usage
06:01:32 <Iceland_jack> Sure
06:01:44 <danilo2> athan: nope, this is internal project and it is used as a part of a compiler for a language we are creating here. The language will be opensourced in some time but for now unfortuantelly not. But If you've got some free time and tyou are interested in such hacking, we can talk on pw - if you will be interested on what we are doing here and would like to help, I will give you access to it
06:02:01 <Denommus> More than two lines is already flooding
06:02:04 <athan> We could give a command to lambdabot to create pastes like this! lol
06:02:24 <Iceland_jack> It depends on the lines, but in this case I agree
06:02:27 <Denommus> athan: heh
06:02:33 <danilo2> Iceland_jack: hmm itneresting, anyway I've solved it very simply, here is the code: http://lpaste.net/119304
06:02:43 <xxprismxx> this is hurting my head XD
06:02:44 <athan> danilo2: Definitely :) it sounds right up my alley
06:03:20 <athan> xxprismxx: You'll grow to enjoy it :)
06:03:23 <athan> O_O
06:03:26 <xRayzorFangz> hay
06:03:32 <xxprismxx> ok athan
06:03:35 <Xe> xRayzorFangz: it happens
06:03:36 <Xe> er
06:03:44 <xxprismxx> what is it about athan
06:03:52 <xRayzorFangz> what happens xe?
06:03:57 <Xe> xxprismxx: after a while you get used to your brain being broken and then you get better
06:04:21 <xxprismxx> having a gilrfriend dont help XD Xe
06:04:33 <athan> xxprismxx: she heard that
06:04:37 <xxprismxx> ik
06:04:41 <xRayzorFangz> i might get a gf soon
06:04:49 <danilo2> athan: Ok, so write your mail address as pm here to me and I will write to you in evening / tommorow morning because I've got to go for a emeeting now, ok ?
06:04:52 <arianvp___> why are case pattern matches strict?
06:04:58 <arianvp___> is there any good reason for it to be?
06:05:03 <athan> sure thing danilo2 :)
06:05:10 <arianvp___> why is  let (a:xs) = ys more lazy then it's case equivalent?
06:05:11 <danilo2> athan: I'll write some information about what we are doing and if you like it, we can further collaborate :)
06:05:24 <athan> danilo2: I can't wait :D
06:05:56 <xxprismxx> rayzorfangz u go broo
06:06:07 <Saizan> arianvp___: it's so the semantics won't change as much when you have another clause in the case
06:06:27 <xRayzorFangz> xDD thanks prism
06:06:32 <arianvp___> Saizan: Could you give an example?
06:07:07 <xxprismxx> np bro...your probs a sexy beast anyway XD
06:07:15 <Saizan> arianvp___: case ... of (a:xs) -> ..; [] -> ...; has to be strict to decide which branch to pick
06:07:16 <xRayzorFangz> xD
06:07:19 <xxprismxx> if not chat to evie the artifical intelligence XD
06:07:48 <athan> Saizan: WHNF-strict!
06:08:01 <athan> :)
06:08:19 <xRayzorFangz> lol
06:08:24 <arianvp___> Basically what I'm struggling to understand is this:
06:08:27 <arianvp___> http://chimera.labs.oreilly.com/books/1230000000929/ch10.html#sec_stm-tqueue
06:08:35 <arianvp___> "There is one subtlety here: we must be careful that the reverse is done lazily, which is why we use a let rather than case here"
06:08:58 * hackagebot securemem 0.1.6 - abstraction to an auto scrubbing and const time eq, memory chunk.  http://hackage.haskell.org/package/securemem-0.1.6 (VincentHanquez)
06:10:22 <Saizan> arianvp___: have you seen "irrefutable patterns" ?
06:10:23 <fryguybob> arianvp___: You can think of let as allocation and case as evaluation.
06:11:05 <Saizan> > let (x:xs) = undefined in ()
06:11:06 <lambdabot>  ()
06:11:18 <Saizan> > case undefined of ~(x:xs) -> ()
06:11:20 <lambdabot>  ()
06:11:51 <arianvp___> > case undefined of (x:xs) -> ()
06:11:53 <lambdabot>  *Exception: Prelude.undefined
06:12:04 <arianvp___> let !(x:xs) = undefined in ()
06:12:16 <arianvp___> > let !(x:xs) = undefined in ()
06:12:17 <lambdabot>  *Exception: Prelude.undefined
06:12:22 <arianvp___> ah
06:12:40 <arianvp___> but what happens if I write something "impossible"
06:12:56 <Saizan> such as?
06:13:02 <arianvp___> > case undefined of {~(x:xs) -> (); [] -> () }
06:13:03 <lambdabot>  ()
06:13:21 <arianvp___> it never goes to the [] case? or?
06:13:25 <Saizan> right
06:13:38 <rasen> > case undefined of {~(x:xs) -> 1; [] -> 2 }
06:13:40 <lambdabot>  1
06:13:48 <nshepperd_> that's basically why case is "strict", I think
06:13:51 <fryguybob> arianvp___: And this is why case is like evaluation, there usually a decision to make
06:13:56 <rasen> > case [] of {~(x:xs) -> 1; [] -> 2 }
06:13:57 <Saizan> > case [] of {~(x:xs) -> 1; [] -> 2 }
06:13:57 <lambdabot>  1
06:13:58 <lambdabot>  1
06:13:59 <arianvp___> case [] of {~(x:xs) -> 1; [] -> 2}
06:14:05 <arianvp___> ahhh
06:14:10 <arianvp___> okay I understand
06:14:15 <arianvp___> that was the behaviour I was expecting
06:14:36 <Saizan> > case [] of ~(x:xs) -> x
06:14:38 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Irrefutable pattern failed for patte...
06:14:41 <nshepperd_> if you intend to choose between two constructors, obviously you must evaluate whatever is the condition before you can return a constructor
06:17:19 <arianvp___> This is haskell summed up for me. lazy evaluation is nice when you dont have to think about it
06:17:31 <arianvp___> but when suddenly there is a piece of your code that breaks because something is too strict or too lazy
06:17:40 <arianvp___> you suddenly have to think really hard to debug it
06:18:13 <tdammers> nah, you just pepper your code with random `seq` and $! and stuff :P
06:18:32 <arianvp___> ugh
06:18:49 <arianvp___> There must be someone writing good blog posts about profiling
06:18:52 <arianvp___> havent found him yet
06:19:08 <tdammers> anyway, debugging and profiling is not haskell's strong suit
06:19:10 <barrucadu> tdammers: Don't forget `deepseq` and $!! sometimes :D
06:19:18 <tdammers> yeah
06:19:22 <arianvp___> tdammers: Indeed. and that's a pitty
06:19:26 <arianvp___> (I think)
06:19:45 <tdammers> it is, but then, you tend to do so little debugging and profiling that most of the time it doesn't really matter much
06:19:48 <arianvp___> I wish exceptions would have stack traces for one
06:19:53 <fryguybob> arianvp___: In the case of the example in Simon's book, you get the right result either way, but you loose opportunities for better performance.
06:20:17 <arianvp___> Well I can give a real world example where I would've loved some form of stack tracing or debugging
06:20:35 <tdammers> fryguybob: except that in practical situations, "too lazy" amounts to "suck up all the system RAM and have the system come to a grinding halt"
06:20:37 <arianvp___> I was writing a compiler which supported "use before definition" using  a fixpoint
06:20:45 <lionrouge> hi !
06:20:56 <arianvp___> but somehow somewhere down the line I evaluated the fixpoint's lazy argument by case matching on it
06:21:05 <lionrouge> tell me please what are the best cross-platform Haskell GUI libs
06:21:06 <arianvp___> and the whole thing broke and my compiler just reported <<loop>>
06:21:31 <arianvp___> I didnt debug it I just rewrote the whole damn code generator
06:21:43 <arianvp___> was frustrating
06:21:56 <fryguybob> tdammers: Certainly, but not in the example from Simon's book, it is about delaying in time to complete the transaction sooner.
06:22:06 <spion> @hoogle (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
06:22:08 <lambdabot> No results found
06:23:14 <rasen> @djinn (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
06:23:14 <lambdabot> f a b c d = a (b d) (c d)
06:23:29 <Cale> arianvp___: Often you can get a really good handle on that sort of thing using the profiler, and then Debug.Trace.trace
06:23:58 <arianvp___> Cale: Which brings me back to my original point. Any good blog posts about using the profiler
06:23:58 * hackagebot unsafeperformst 0.9.2 - Like unsafeperformIO, but for the ST monad.  http://hackage.haskell.org/package/unsafeperformst-0.9.2 (AtzeVanDerPloeg)
06:24:00 <arianvp___> :)
06:24:01 <spion> that looks like a useful function
06:24:19 <Cale> arianvp___: If you compile for profiling and run with +RTS -xc you'll get a cost centre stack trace at the point of an exception
06:24:26 <Cale> It's often not as useful as you'd think
06:24:43 <Cale> I recommend the GHC User's Guide on this
06:25:15 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
06:25:33 <rasen> spion: It reminds me arrows
06:26:25 <spion> Cale, I meant that combinator :P e.g. filter $ f (&&) ((== val) . someprop) ((== other) . otherprop)
06:27:38 <rasen> @src (&&&)
06:27:38 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
06:27:45 <Cale> spion: what/
06:27:45 <Cale> ?
06:27:45 <Cale> Oh, I wasn't responding to you :)
06:27:49 <Cale> I was saying that the cost centre trace that you get with the -xc option when an exception occurs is often not as useful as one might like it to be
06:27:50 <Cale> But since there is no call stack, it's not like there's much of a better option to be had.
06:28:25 <danilo2> Hello! I'm getting in haskell an error "Could not deduce (((k - 1) - ArgsKind as) ~ (k - (1 + ArgsKind as)))", where this are Nat-level operations. Is there a way in Haskell to tell him that this is true?
06:28:47 <spion> Cale, whoops :P
06:29:26 <Cale> danilo2: Maybe there's a way to say "trust me"
06:30:02 <tomphreek> this isn't a troll question, it's a genuine curiousity: do we have emprical evidence that programs in Haskell (or FP in general) have fewer bugs than programs writting in imperative languages?
06:30:20 <tdammers> tomphreek: no
06:30:24 <Cale> tomphreek: There are a handful of really small studies
06:30:27 <danilo2> Cale: exactly! I'm thinking about something like that
06:30:30 <merijn> tomphreek: Maybe not haskell, but I was talking to some PL people doing research into this
06:30:37 <tdammers> tomphreek: I don't think there is useful evidence regarding bug frequency at all
06:30:40 <Cale> tomphreek: But nothing really great quite yet
06:30:58 <Cale> It's kind of hard to do a study like that in a reasonably controlled way
06:31:11 <merijn> They did find empirical evidence that types are more productive (not necessarily less bugs, but faster at accomplishing tasks), but not haskell specific
06:31:11 <tdammers> there's probably a lot of research in that direction, but it's really hard getting something that resembles rigor with this kind of thing
06:31:17 <Cale> and in a way where the results would have any sort of statistical significance
06:32:40 <rasen> There are studies saying all languages have almost same bug density (number of bugs per line of code). We could combine it with knowledge that usually implementation of something in FP is usually takes less lines. Just thinking
06:33:08 <Cale> tomphreek: I'm not even entirely sure that FP vs. not FP is really about bug frequency? Maybe it has some impact.
06:33:26 <Cale> It's really the type system that we tend to think catches lots of bugs
06:33:37 <Cale> rather than just the fact that we're programming in a functional style
06:33:54 <Cale> The reusability of higher order functions might contribute a bit to getting things right though.
06:34:34 <tdammers> counting defects is problematic in itself
06:34:40 <Cale> Indeed!
06:35:18 <tdammers> then, comparing radically different languages implies that you either compare radically different approaches for a given problem, or the same approach implemented in two languages where one is radically more suitable than the other
06:35:21 <tomphreek> OK. Shame about that.
06:35:30 <tdammers> and then there's the scope problem
06:35:54 <merijn> Anecdotally I have a metric ass-ton of evidence, though :>
06:36:03 <tdammers> a typical study has to restrict itself to a fairly small project, or compare different projects, which introduces another variable
06:36:03 <Cale> Oh, also any instance in which one does certain kinds of nice embedded domain specific language to model one's problems, I can imagine it's possible that kind of approach helps to lower the incidence of bugs. But yeah, these things are really difficult to collect hard data on.
06:36:52 <tdammers> it's hard enough to design an experiments that compares relatively trivial projects, but what we really want to know is how different languages fare on large-scale things
06:37:15 <tomphreek> tdammers: lots of things are hard to measure, but even approximate measure is a start. it's not about being totally right, just a little bit less wrong.
06:37:29 <hodapp> I am only aware of a handful of studies that actually try to measure defect rate
06:37:36 <tomphreek> it's about being a little bit less wrong*
06:37:40 <tdammers> yeah
06:37:48 <JagaJaga> Hi! Can you help me to encode by church? data Tree a b c = Frog c | Pip (Tree a b c). frog  is smth like = \a b c -> (\ d e -> d c). What about Pip? I can't get how to write it...
06:37:53 <hodapp> Les Hatton did research on this I think
06:38:21 <hodapp> he wrote one paper, "Does OO Sync With How We Think?" that compared some large object-oriented vs. procedural code where he had detailed information on the entire codebase over many years
06:38:33 <tdammers> my point is, though, that there are so many problems with researching "influence of programming paradigm on software quality" that practical conclusions are going to be very questionable at best
06:38:56 <sdegutis> Does Haskell have an equivalent operator (even if only rough) to Clojure's -> macro?
06:38:59 * hackagebot lucid-svg 0.2.0.2 - DSL for SVG using lucid for HTML  http://hackage.haskell.org/package/lucid-svg-0.2.0.2 (jeffreyrosenbluth)
06:39:02 <sdegutis> Thanks in advance, regards.
06:39:22 <merijn> sdegutis: You're gonna have to tell us what Clojure's -> macro is...
06:40:02 <Iceland_jack> sdegutis: ($) or (&) (as earlier) or just parentheses
06:41:12 <sdegutis> It turns (-> foo bar (quux fluzzle)) into (quux (bar foo) fluzzle), which would in Haskell be quux (bar foo) fluzzle
06:43:17 <Cale> JagaJaga: The idea is that a value like  Pip (Pip (Frog x)) becomes under Church encoding (\frog pip -> pip (pip (frog x)))
06:43:59 * hackagebot securemem 0.1.7 - abstraction to an auto scrubbing and const time eq, memory chunk.  http://hackage.haskell.org/package/securemem-0.1.7 (VincentHanquez)
06:44:17 <leday> hi all
06:44:21 <rasen> sdegutis: Can't even imagine type signature without flattening all parens
06:44:42 <Cale> JagaJaga: So to define the functions which act as your constructors, you'll want something like Frog = (\x -> (\frog pip -> frog x)), and Pip = (\t -> (\frog pip -> pip t))
06:45:25 <Cale> JagaJaga: That example type is a little weird, because it has two phantom type parameters (a and b)
06:45:39 <nkar> is there a way to call unexported functions from a package module with ghci, like it's possible if you load a file with :l?
06:45:50 <Cale> JagaJaga: So the Church encoding doesn't involve that type information in any way
06:46:09 <leday> nkar: I don't think so
06:46:21 <geekosaur> only if it's interpreted, I think
06:46:32 <nkar> what do you mean?
06:46:39 <geekosaur> compiled modules, the only visible names are the exported ones and this can't be changed without recompiling
06:46:48 <geekosaur> (or interpreting, which recompiles it to bytecode within ghci)
06:46:50 <sdegutis> I have no problem not having -> if it's impossible in a decent type system.
06:47:03 <sdegutis> ->> would be & so that's good enough for me.
06:47:09 <Cale> JagaJaga: For another example, you could imagine we have a type like  data Nature a = Rock a | Stream a (Nature a) | Bush a (Nature a) (Nature a)
06:47:09 <nkar> geekosaur: how can I recompile to allow for that, then?
06:47:31 <sdegutis> And we can make anonymous functions to make the remaining argument not be the last one.
06:48:25 <leday> nkar: grab source, put appropriate function in export group, recompile, perhaps using a new package name in the cabal
06:48:32 <nkar> geekosaur: for the record, the module I'm interested in is Distribution.Simple.Configure and the function is parseHeader.
06:48:49 <Cale> JagaJaga: and then we could define Church encoded constructors like  Rock = (\x -> (\rock stream bush -> rock x)), Stream = (\x n -> (\rock stream bush -> stream x n)) and Bush = (\x n1 n2 -> (\rock stream bush -> bush x n1 n2))
06:48:55 <geekosaur> that one would be difficult, since Cabal is a library wired into the compiler
06:49:00 <nkar> leday: ugh, okay :(
06:49:08 <Cale> JagaJaga: Does that make sense?
06:49:08 <leday> :<
06:49:10 <geekosaur> but you cab get the source to the Cabal library and load it
06:49:22 <sdegutis> If Haskell's truly stateless as they say, does this mean that live code-reload during application development is completely reliable and without flaws?
06:49:31 <nkar> yeah, I know.  still there ought to be a better way
06:49:55 <leday> nkar: occupational hazard of library builders explicitly choosing what the interface is, i suppose ;p
06:50:12 <Cale> sdegutis: ... live code reload?
06:50:15 <geekosaur> sdegutis, no. different kinds of state, plus live code reload may need to deal with things like interface changes
06:50:15 <leday> my personal preference is to go export /all the things/
06:50:39 <Cale> sdegutis: Using what mechanism? Also, Haskell is not completely stateless. Only expression evaluation is pure. Execution of IO actions isn't.
06:50:44 <geekosaur> haskell does not have global state and forces you to encapsulate local state somehow; this does not mean "stateless"
06:51:02 <nkar> leday: well, sometime you want to expose only smart constructors, for instance
06:51:04 <nkar> s*
06:51:07 <xRayzorFangz> uummm
06:51:14 <sdegutis> Then let me ask another question altogether, if I may so do.
06:51:18 <leday> anyone who's unwrapped an IO computation can attest to their *very* statelike nature
06:51:31 <Cale> unwrapped?
06:51:49 <leday> IO a = StateRW a ...
06:51:54 <sdegutis> How do you typically develop a Haskell web application such that the time between you making a change and seeing the change is shortest?
06:51:57 <Cale> uhhhh
06:52:16 <sdegutis> Thanks in advance, regards.
06:52:19 <Cale> sdegutis: hm
06:52:29 <Cale> sdegutis: That's not something I've ever worried about optimising
06:52:57 <sdegutis> So you just reload your entire web app when you make a change, and often just sit there waiting for it to compile while you sword-fight someone?
06:53:01 <Cale> sdegutis: It's always seemed more important that the code which got deployed would actually work ;)
06:53:07 <sdegutis> s/reload/recompile and relaunch/
06:53:09 <leday> sdegutis: effectively yes
06:53:21 <sdegutis> Oh.
06:53:40 <leday> +1 for xkcd
06:54:02 <merijn> Cabal is pretty good at incremental compilation and if you compile without optimisation it doesn't take that long
06:54:03 <Cale> sdegutis: Well, you can test things in GHCi. Also, depending on the size of the application, compile times might not be so bad? You might also just run the entire thing interpreted if you're really worried about startup time.
06:54:55 <sdegutis> Cale: wait, you can do that?
06:55:05 <sdegutis> merijn: sounds awesome
06:55:18 <Cale> Yeah, runhaskell/ghci
06:55:29 <sdegutis> I think I'm sold on Haskell so far, although I'm only on chapter 5 or 6 in Learn Haskell Greatly Goodly.
06:55:42 <sdegutis> Oh no, chapter 7.
06:55:49 <leday> next step is to renounce everything else
06:56:19 <tdammers> leday: that's just a formality at some point in the near future
06:56:30 <leday> :)
06:56:38 <merijn> sdegutis: By default cabal only recompiles changed files and since haskell actually has a module system (unlike C/C++) that's much faster than with those languages
06:56:40 <sdegutis> leday: I admit that I do find Haskell superior to all other languages.
06:57:01 <sdegutis> leday: that said, I'll probably still use Swift to write OS X apps until I can figure out how to do ObjC interop in Haskell.
06:57:05 <merijn> It can still be a little slow, but hell, it's better than the 10-15 minute compile time I had with C++ >.>
06:57:11 <leday> I was given the runaround with Java/C++ and then forcefed Haskell for two years at university
06:57:14 <leday> Needless to say, I'm here
06:57:21 <leday> Eight years on
06:57:34 <leday> sdegutis: fair enough ;)
06:57:45 <dcoutts_> sdegutis: there's a new approach to objC interop in Haskell involving quoting (embedding) whole bits of objC code within a haskell module
06:58:20 <dcoutts_> sdegutis: means you can bind your higher level application actions, rather than individually having to bind loads of objC APIs
06:58:26 <tdammers> compiling haskell projects feels slow to me, but that's because the sheer size and complextity I can manage on my own is probably several orders of magnitude higher with haskell
06:58:59 <dcoutts_> tdammers: we default to compiling with -O and that makes it a lot slower, and means more recompilation
06:59:01 <Cale> sdegutis: as for your question about -> I'm not sure if I understand from your example how that permutation of arguments (which seems random to me) generalises to other cases
06:59:07 <Marlin> tdammers compared to what other language?
06:59:40 <tdammers> dcoutts_: yeah, but even then - most of my C or C++ stuff has very few dependencies, and the scope is relatively limited
06:59:48 <tdammers> so I get overall build times of 1 second or less
07:00:03 <Cale> sdegutis: But there's nothing (short of using a macro) that will tear apart a subexpression like (quux fluzzle), which is supposed to be substitutable for the value that it evaluates to.
07:00:10 <JagaJaga> Cale: thank you! Your example was pretty explainable.
07:00:13 <tdammers> meanwhile, I write Haskell web applications that touch several relatively disjoint areas, and do a whole lot of stuff that's not directly obvious
07:00:23 <tdammers> two dozen or more dependencies
07:00:33 <dcoutts_> tdammers: that's quite impressive. If all interfaces are declared up front like that in C/C++ then you can get very good build times
07:00:49 <merijn> dcoutts_: Depends on the amount of template/inlining >.>
07:00:54 <dcoutts_> right
07:00:55 <tdammers> dcoutts_: nah, it's not impressive at all. They're just really tiny projects
07:00:56 <merijn> dcoutts_: Because it can also SUCK :p
07:00:59 <arianvp___> anyone here got experience with pipes-network?\
07:01:11 <dcoutts_> tdammers: ah ok
07:01:44 <tdammers> https://bitbucket.org/tdammers/playlence/src this is about as complex as it gets :D
07:04:26 <sdegutis> Cale: thats fine; when in Clojure we need to mix -> and ->>, since we can't, we just use one and make anonymous functions
07:05:11 <sdegutis> Cale: like (-> foo (bar) (baz quux) (fn [x] (fluzzle quizzle x)))
07:05:24 <sdegutis> The same thing could be done in Haskell (let me try, it'll be practice for me):
07:06:03 <sdegutis> foo & bar & \x baz x quux & fluzzle quizzle
07:06:08 <sdegutis> I think that's right.
07:06:19 <Marlin> i believe you need parens around lambda
07:06:22 <Marlin> or maybe not?
07:06:28 <sdegutis> Only one way to find out.
07:06:32 * sdegutis loads up GHCi
07:06:38 <juanpablo_> Anyone knows why conduit uses Void here instead of ()? https://hackage.haskell.org/package/conduit-1.1.0/docs/Data-Conduit.html#t:Sink
07:06:44 <sdegutis> Also that's not true, there are more ways to find out. This is just one.
07:06:52 <rasen> forgot about ->
07:06:53 <Cale> I have no idea what's going on there :D
07:07:03 <Marlin> > 1 & (+10) & \x -> x * 2 & show
07:07:05 <lambdabot>  "22"
07:07:19 <hamid> :t (&)
07:07:20 <lambdabot> a -> (a -> b) -> b
07:07:25 <Marlin> flipped ($)
07:07:30 <sdegutis> Anyway it would turn into this Clojure/Haskell code:  (fluzzle quizzle (baz (bar foo) quux))
07:07:36 <Cale> juanpablo_: Because it's too afraid to use a type variable?
07:07:39 <sdegutis> That's both valid Clojure and valid Haskell.
07:07:56 <juanpablo_> Cale: Snoyman too afraid? haha
07:08:27 <Cale> juanpablo_: I think the idea is that because it doesn't produce output at all, it's not even going to produce for you an empty tuple.
07:08:37 <merijn> juanpablo_: Easy, to show that it can't return
07:08:59 <merijn> juanpablo_: Void cannot have any real value, therefore any monadic operation of type "m Void" can never return
07:09:12 <juanpablo_> Snoyman is a very smart dude and doesn't afraid of anything
07:09:16 <merijn> It's essentially promising to be an infinite loop
07:09:22 <juanpablo_> merijn: thanks! that makes sense
07:09:51 <dizzeehaskell> Void's typically an empty datatype, correct?
07:09:55 <merijn> juanpablo_: As opposed to "m ()" which might finish at some point
07:09:59 <Cale> A better way to make that promise imo is just to make the result type be arbitrary, which similarly indicates that it's not going to produce a result.
07:10:03 <dizzeehaskell> I'm having a short circuit in my brain
07:10:03 <merijn> dizzeehaskell: Correct, "data Void"
07:10:03 <juanpablo_> jvilla: ^^^^^
07:10:04 <Iceland_jack> dizzeehaskell: Yes:
07:10:04 <Iceland_jack>     data Void
07:10:10 <dizzeehaskell> i thought as much
07:10:12 <sdegutis> Cale: does that make more sense now?
07:10:14 <arianvp___> is Void in base already?
07:10:19 <Marlin> :i Void
07:10:22 <sdegutis> (after my latest explanation)
07:10:25 <rasen> Guys, I'm kind of becoming addicted to this chat. Can't work. This C is sooo boring
07:10:32 <dizzeehaskell> heh
07:10:37 <sdegutis> rasen: quit IRC
07:10:40 <juanpablo_> rasen: my work involves writing Haskell. Yay!
07:10:40 <arianvp___> rasen: Writing refactoring reports for a C++ codebase!
07:10:42 <sdegutis> rasen: type /quit
07:10:44 <arianvp___> at least. I'm supposed to
07:10:52 <juanpablo_> rasen: however it doesn't involve reading #haskell
07:10:53 <arianvp___> juanpablo_:  I dont like you :(
07:10:54 <Cale> sdegutis: It still seems kind of random to me
07:10:56 <arianvp___> I mean I like your job
07:10:58 <sdegutis> How do you all feel about Frege?
07:11:01 <dizzeehaskell> juanpablo_: writing Haskell in #haskell doesn't count :p
07:11:13 <Cale> sdegutis: The logician, or something named after him?
07:11:24 <arianvp___> We're converting a legacy codebase to  "C++11"
07:11:26 <sdegutis> https://github.com/Frege/frege
07:11:30 <dizzeehaskell> click
07:11:33 <sdegutis> arianvp___: that sounds terrifying
07:11:36 <arianvp___> A lot of different collegues have a different take on what "C++11" is though
07:11:42 <arianvp___> ugh
07:12:04 <dizzeehaskell> the only thing i'm getting from that is 'lazy Scala'
07:12:07 <arianvp___> sdegutis: It's do-able. It's under 200k LOC
07:12:29 <Cale> sdegutis: Oh, that's an interesting project, I didn't even know it existed :)
07:12:51 <sdegutis> Welp.
07:13:09 <dizzeehaskell> Don't get me wrong, there's nothing wrong with Scala or the JVM
07:13:11 <dizzeehaskell> Interesting though
07:13:16 <dizzeehaskell> I hadn't seen this before now either
07:13:17 <sdegutis> Nothing wrong with Scala?
07:13:18 <Cale> It sounds like a good idea to me though
07:13:20 <sdegutis> Gaurds!
07:13:22 <dizzeehaskell> Hahahah
07:13:41 <sdegutis> That said, I don't have any problem with Scala. I only hear that people hate it, and I don't even know if they're trustworthy to begin with.
07:14:15 <Cale> dizzeehaskell: I don't know, most of the Scala users I've heard from seem pretty fed up with a lot of things about it.
07:14:41 <Cale> and I know at least some of those people are trustworthy :)
07:15:00 <mniip> is there any builtin to convert degrees to radians, or maybe degree-based trigonometry functions?
07:15:08 <mniip> hoogling doesn't help
07:15:12 <dizzeehaskell> The last conversation I had around Scala was involving some hedge fund devs, and it seemed like they were just doing it because the higher ups wanted them to
07:15:15 <arianvp___> Yeh scala is something else I'm looking at.  as R&D we're porting a java game server to haskell at the moment. We hope to develop some nice new ideas doing it.     But switching the production server code to scala might actually be a realistic project.
07:16:06 <Cale> It certainly seems like an attractive option relative to Java, at least looking at the feature list.
07:16:08 <StoneToad> mniip: there's a builtin pi constant you can use
07:16:22 <Cale> Whether you can actually make those features work in a coherent way together is something I'm less sure about :)
07:16:32 <arianvp___> certainly. Especially because we can integrate it with existing tooling.
07:16:47 <arianvp___> (hopefully)
07:17:44 <dizzeehaskell> mniip: doesn't look like it, but Rosetta Code's got the fairly obvious implementations
07:17:45 <Peaker> Most of Scala's faults AFAICS are due to: A) its form of subtyping (little benefit, huge harm)  B) Exposed mutable object identities/eq/hashes making pure values an almost impossibility and destroying parametericity
07:17:52 <tdammers> mniip: matter of dividing or multiplying by 180/pi
07:17:55 <dizzeehaskell> Floating's got what you'd need but I'm not sure there's existing library stuff
07:18:03 <dizzeehaskell> You'd think there would be
07:18:06 <dizzeehaskell> \o/
07:18:12 <merijn> Peaker: Also implicit everything everywhere
07:18:17 <Cale> Peaker: Oh, so it's only the obvious stuff?
07:18:22 <dizzeehaskell> heh
07:18:33 <Peaker> Cale: Note, my opinion is based on superficial use of Scala :)
07:18:37 <merijn> Cale: Well, performance sucks too in many cases
07:18:39 <Peaker> I'm not a Scala expert
07:18:43 <Peaker> merijn: that sounds like a strength too, though
07:18:44 <merijn> It doesn't map well to the JVM
07:18:46 <tdammers> only sane thing to do is to use radians for everything internally and convert to/from the desired format at the outmost integration points
07:18:52 <Peaker> merijn: (the implicit stuff)
07:19:00 <merijn> Peaker: It sounds like a strength INITIALLY
07:19:07 <tdammers> would be a bit overkill to bake these two functions into a library methinks
07:19:21 <Peaker> tdammers: I think a better option is to use a newtype for Angle that hides whether its radians or degrees, and has smart constructors from both, and eliminators for both
07:19:22 <merijn> Peaker: My twitter feed is full of people going "jesus, it's impossible to know what's going on...can has haskell?"
07:19:23 <dizzeehaskell> *surely* one must exist
07:19:30 <tdammers> Peaker: I was about to get into this
07:19:38 <Peaker> merijn: IDE cannot tell you what implicits are taking place?
07:20:01 <dizzeehaskell> mniip: I might put one together for you if I can't find one, I'm at a lack of things to occupy me at present ;)
07:20:02 <nkar> sdegutis: re developing web apps: try yesod-dev
07:20:06 <tdammers> that, or just a newtype Degrees
07:20:11 <mniip> nah I"m ok
07:20:16 <dizzeehaskell> Thought as much :p
07:20:16 <tdammers> considering how radians are sort of unitless
07:20:17 <mniip> dSin x = cos $ x / 180.0 * pi
07:20:19 <mniip> all it takes
07:20:25 <dizzeehaskell> aye
07:20:25 <nkar> sdegutis: it reruns the server when you make a change
07:20:39 <tdammers> mniip: no need to put .0 there :D
07:20:48 <Peaker> tdammers: IMO that's less elegant.. making arbitrary thing special, and giving second class citizen to other forms
07:21:04 <tdammers> Peaker: it's not exactly arbitrary is it?
07:21:13 <Peaker> mniip: sin vs. cos??
07:21:27 <mniip> oy
07:21:27 <mniip> lol
07:21:33 <mniip> sin* lol
07:21:36 <dizzeehaskell> rekt
07:21:36 <Peaker> shows how boilerplate is dangerous! :)
07:21:38 <dizzeehaskell> haha
07:21:49 <dizzeehaskell> didn't even see that
07:21:56 <Peaker> tdammers: why choose newtype Degrees and not newtype Radians?
07:22:01 <flux> there's not much you can do with degrees except arithmetics with other degrees, and passing to trig funcs
07:22:09 <flux> but radians are useful as ratios
07:22:37 <flux> ie. the reason why they are 'unitless'
07:22:43 <Peaker> Is there also a 0..1 (full circle) convention for angles?
07:22:59 <arianvp___> radians?
07:23:05 <arianvp___> gradients*
07:23:22 <Cale> gradients go from 0 to 400 iirc
07:23:37 <tdammers> Peaker: because radians are unitless, degrees are not
07:23:40 <tdammers> sorta kinda
07:24:03 <tdammers> radians are defines in terms of distance along unit circle circumference
07:24:16 <tdammers> or, alternatively, distance along arbitrary circle divided by radius
07:24:22 <tdammers> but that's the same thing
07:24:23 <arianvp___> radians is the best \m/
07:24:29 <tdammers> either way, the units cancel out
07:24:43 <Cale> Well, degrees are also unitless? But radians are a nice convention because they correspond with arc lengths along a unit circle
07:24:45 <tdammers> (rad is sometimes declared as "m/m"
07:24:50 <Peaker> tdammers: so "unitless" means it gets the elevated privelege as a newtype, and everyone else converts? I think it's much nicer to have: newtype Angle, Mass, Distance, etc. rather than hard-coding a unit into the type
07:24:53 <Peaker> the type doesn't care
07:25:04 <tdammers> well yeah
07:25:28 <tdammers> if you newtype everything, newtyping radians is only consistent
07:25:40 <tdammers> but I was assuming that you don't newtype any of the SI dimensions
07:26:02 <tdammers> and actually, radians are even less unitful than mass or distance
07:26:34 <tdammers> one radian is always one unit of length along an arc with a radius of one unit of length, no matter what that unit is
07:27:16 <Peaker> I don't need a newtype for radians, because if someone can be "aware" of that newtype, they may as well be aware of Angle and work with that. When you interact with third-parties or arithmetic, you convert to radians very locally, and then a newtype isn't very helpful
07:32:31 <S11001001> Cale Peaker merijn: edwardk on Scala http://www.reddit.com/r/haskell/comments/1pjjy5/odersky_the_trouble_with_types_strange_loop_2013/cd3bgcu
07:34:12 <osa1_> I wish typed holes would compile like undefined.
07:34:25 <Cale> S11001001: yeah, I've heard Edward say at least some of that stuff before -- interesting to see it all in one place :)
07:34:36 <osa1_> I can't experiment in REPL using typed holes because they fail at compile time and don't let REPL load
07:34:47 <osa1_> load the module and imported modules*
07:35:04 <arianvp___> osa1_: -fdefer-type-errors
07:35:08 <arianvp___> you're welcome :)
07:35:23 <arianvp___> though that defers _ALL_ type errors which might not be what you want
07:35:31 <arianvp___> but it's sufficient to mess with type holes in REPL
07:35:54 <osa1_> arianvp___: you're a hero
07:36:08 <osa1_> arianvp___: yeah it's still not exactly what I want
07:36:11 <a3gis> hello! is there a lens operator to do something like: "map (view _lens1) . (view _lens0)"
07:36:12 <a3gis> ?
07:37:04 <osa1_> really why would typed holes fail to compile... IMO they should behave indentical with undefined, except compiler should print the type.
07:37:40 <dizzeehaskell> good question
07:37:48 <S11001001> a3gis: _lens1.mapped._lens0
07:37:58 <arianvp___> osa1_ that's what -fdefer-type-errors does
07:38:03 <arianvp___> it treats type-errors as undefined
07:38:06 <Cale> osa1_: I guess the assumption is that you would never want to ship code with typed holes in it
07:38:15 <S11001001> a3gis: or lifted, if you have Monad instead of Functor, at least until GHC 7.10 makes all this unnecessary, and these hacks will instantly disappear!
07:38:20 <Cale> osa1_: Whereas you *might* want to ship code which has an undefined in it.
07:38:35 <a3gis> S11001001: well i'm doing this in purescript
07:38:39 <a3gis> https://github.com/purescript-contrib/purescript-lens/tree/master/src/Optic
07:38:51 <a3gis> could you point me to the right function? it's pretty cryptic to me
07:39:05 <arianvp___> a3gis: mapped :: forall f a b. (Functor f) => Setter (f a) (f b) a b
07:39:09 <arianvp___> it's defined in purescript as well
07:39:13 <a3gis> isn't this a setter htough?
07:39:25 <S11001001> a3gis: yeah, once you use map you aren't lensy
07:39:32 <a3gis> oh
07:39:32 <a3gis> ok
07:39:42 <a3gis> make sense actually
07:40:22 <a3gis> and what is the basic lens composition operator? e.g. (view _A) . (view B)
07:40:31 <S11001001> a3gis: .
07:40:36 <a3gis> oh
07:40:37 <a3gis> ==>
07:40:57 <S11001001> a3gis: view _A . view B = view (B . _A)
07:41:02 <S11001001> a3gis: or whatever . is called in purescript
07:41:13 <S11001001> a3gis: ask in #haskell, get a haskell answer :)
07:41:23 <arianvp___> isnt it called >> in ps?
07:41:27 <arianvp___> or <<
07:41:51 <tomphreek> to answer my own question with regards to emperical evidence of # of bugs in Haskell compared to other languages, there's one study that touches the subject
07:41:54 <tomphreek> A Comparative Study of Programming Languages
07:42:00 <tomphreek> by A Comparative Study of Programming Languages
07:42:07 <tomphreek> http://arxiv.org/pdf/1409.0252.pdf
07:42:44 <a3gis> arianvp___: yep <<< and >>>
07:42:59 <arianvp___> a3gis: well then you use those to compose lenses :)
07:43:11 <sdegutis> nkar: thx
07:44:02 * hackagebot lucid-svg 0.2.1 - DSL for SVG using lucid for HTML  http://hackage.haskell.org/package/lucid-svg-0.2.1 (jeffreyrosenbluth)
07:44:03 <benzrf> a3gis: the lens compo operator is just normal composition
07:44:04 * hackagebot reverse-geocoding 0.1.1.0 - Simple reverse geocoding using OpenStreeMap  http://hackage.haskell.org/package/reverse-geocoding-0.1.1.0 (jcristovao)
07:44:23 <benzrf> a3gis: the lens compo operator is just normal composition
07:44:24 <benzrf> oops
07:44:28 <hodapp> S11001001: looks like a neat talk, judging by comments at least.
07:44:30 <a3gis> benzrf: right, I assume lenses are treated as functions underneath?
07:44:34 <benzrf> a3gis: at least, it is for van laarhoven style lenses
07:44:44 <benzrf> a3gis: you can implement lenses as pairs of getters and setters fwiw
07:45:04 <benzrf> a3gis: the lens package's approach uses van laarhoven lenses tho
07:45:47 <Peaker> tomphreek's paper says "Thanks to its simple static type system, Go is the least failure-prone language in our study"
07:45:57 <hodapp> Peaker: study?
07:46:10 <osa1_> is there a way to make TH point the error on generated splice? I'm using -ddump-splices but it's still impossible to find the error because error message just points to the $(...) instead of expanded code.
07:46:22 <sdegutis> I am liking Haskell more and more the more I read LyaH.
07:46:30 <sdegutis> This is such a well written book, compared to Real World Haskell.
07:46:36 * hodapp hides
07:46:38 <Peaker> http://arxiv.org/pdf/1409.0252.pdf
07:46:44 <hodapp> Peaker: thanks!
07:46:47 * hodapp hides again
07:46:56 <sdegutis> Good writing style makes all the difference, such that it's easier to read a book that's written more for beginners if it's done well than a book right at your level that's hard to read.
07:47:31 <benzrf> sdegutis: i feel like that would work better with s/beginners/experts
07:47:40 <benzrf> sdegutis: i mean being for beginners usually makes it easier to read anyway doesnt it
07:47:49 <sdegutis> benzrf: no, I mean the writing style itself.
07:48:29 <sdegutis> benzrf: In other words, I'm not a beginner, but I'm finding it easier to read a book geared toward beginners than one geared toward my own level, simply because the wording and phrasing is easier and quicker to read, and nicer overall.
07:48:42 <benzrf> sdegutis: oh i see what you mean
07:49:20 <merijn> sdegutis: RWH is more of a "practical reference" IMO
07:49:37 <merijn> sdegutis: I would say that the "expert" intro to Haskell would be the Gentle Introduction
07:50:15 <sdegutis> For example of his writing style being easy to read: "Pretty cool, huh? Yeah, I know it's not but bear with me. A little pitfall to watch out for here is negating numbers. If we want to have a negative number, it's always best to surround it with parentheses." (LyaH)
07:50:38 <sdegutis> merijn: I couldn't stomach Gentle Introduction because of the wording.
07:51:18 <sdegutis> Where is the + function defined?
07:51:20 <sdegutis> Prelude?
07:51:28 <Cale> Yeah, it's a method of the Num type class
07:51:54 <zwer> you can type :i (+) in ghci
07:52:01 <merijn> The Num class is defined in Prelude and the usual instances like Int are too, but there may be instances of (+) defined outside the Prelude
07:52:35 <dizzeehaskell> But you'll run into those because GHC will generally go "S'cuse me, guv? Did you mean one of these? *presents five alternatives to (+)*"
07:52:44 <Marlin> :t (+)
07:52:45 <lambdabot> Num a => a -> a -> a
07:53:05 <sdegutis> I like currying too.
07:53:15 <sdegutis> It's like Clojure's partial function but automatic and beautiful.
07:53:19 <S11001001> sdegutis: there are also a couple beginner channels, though beginner questions are welcome here too, whichever you like: #haskell-beginners and #nothaskell
07:53:31 <sdegutis> I'll be quiet then.
07:53:33 <dizzeehaskell> Currying is the one thing that I absolutely *could not* get to grips with when I started Haskell
07:53:51 <dizzeehaskell> sdegutis: don't be
07:54:04 <a3gis> S11001001: mmh it doesn't seem to do what I want. I have "(view (_goals <<< mapped <<< _lineIndex) d)". d is a record, with a "goals :: [Goal]: field, which is accessed via the lens _goals. Goal is also a record with a lineIndex :: Int field. I want to get a [Int] out of that
07:54:07 <sdegutis> I like this little side-note within LyaH: "Yo! Make sure you really understand how curried functions and partial application work because they're really important!"
07:54:13 <sdegutis> Very good book. I'd buy it.
07:54:35 <n4x> it needs exercises
07:54:39 <sdegutis> nah
07:54:39 <merijn> sdegutis: Typeclasses and type signatures too, people tend to underestimate how critical they are to progressing :)
07:54:44 <n4x> so you can feel confident on what you are reading
07:54:44 <dizzeehaskell> I got in trouble for recommending LyaH to some of my students, because my supervisor wrote Programming in Haskell ;_:
07:54:46 <dizzeehaskell> Tribalism is real
07:54:52 <tdammers> currying is one of the things that only really started making sense once I learned haskell
07:54:57 <sdegutis> merijn: I'll keep that in mind, that's my next chapter. Thanks.
07:55:08 <sdegutis> dizzeehaskell: ugh
07:55:14 <hodapp> tdammers: and I find Haskell's notation to be a big boon to that too
07:55:23 <dizzeehaskell> To be fair, the course we teach at Nottingham is specifically tuned to his book :p
07:55:31 <tdammers> hodapp: absolutely
07:55:49 <sdegutis> tdammers, dizzeehaskell: I don't remember how hard it was for me to learn how (partial ...) worked in Clojure, but I know that I automatically understood currying in Haskell because of it.
07:55:59 <Marlin> > map (2^) [0..]
07:56:00 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
07:56:16 <dizzeehaskell> :D
07:56:33 <tdammers> sdegutis: for me, haskell made the whole curring thing click, and suddenly similar stuff in, say, javascript or python became a no-brainer
07:56:35 <merijn> dizzeehaskell: Isn't Bird at Nottingham? :p
07:56:36 <dizzeehaskell> I remember sitting in an undergraduate computing lab and finally 'getting' that I could write something like (\x y -> ...)
07:56:39 <dizzeehaskell> Blew my mind
07:56:45 <dizzeehaskell> He's at Oxford
07:56:55 <merijn> Ah
07:56:56 <dizzeehaskell> Nottingham is Hutton, Altenkirch, Capretta and Nilsson
07:57:01 <merijn> Oh, right
07:57:03 <dizzeehaskell> We're a small clique
07:57:15 <merijn> I like Hutton's paper on folds :)
07:57:28 <dizzeehaskell> Bananas?
07:57:49 <dizzeehaskell> My PhD is basically a 200 page 'look at how you can fold this', it's cited *everywhere*
07:58:00 <dizzeehaskell> We just spent four years coming up with awful puns
07:58:53 <merijn> dizzeehaskell: No the universality and expressiveness of fold one
07:58:56 <dizzeehaskell> ah yes
07:59:14 <tdammers> dizzeehaskell: you have a PhD in origami?
07:59:20 <dizzeehaskell> god i wish
07:59:22 <tdammers> (sorry, I had to)
07:59:23 <hodapp> tdammers: *slow clap*
07:59:25 <lpsmith> The system, is down.
07:59:34 <dizzeehaskell> I actually wanted to call my framework Crane
07:59:37 <dizzeehaskell> for exactly that reason
07:59:40 <dizzeehaskell> Hutton said no
07:59:45 <tdammers> dayum
08:00:00 <tdammers> also, dat lifting reference
08:00:03 <dizzeehaskell> :3
08:01:42 <codygman> Wouldn't it be more useful to get [Left a]?
08:01:44 <codygman> > liftA2 (,) (Left "error one") (Left "error two")
08:01:46 <lambdabot>  Left "error one"
08:01:54 <a3gis> I basically want to compose two lens to get an element out of an array-like structure. _A gets an array, _B get a property of an element. map (view _B) . (view _A) does the job but I am sure there is a neater way, without repeating "view"
08:04:44 <c_wraith> a3gis: compose the lenses, usually.  veiw (_A . _B)
08:04:54 <c_wraith> a3gis: (yes, in some sense, the composition is backwards)
08:05:00 <c_wraith> *view
08:07:03 <a3gis> well that would work if _A was extract a single Goal, but it's extract a list of goals. Basically I have a structure of the type { someProp: [a, b, c] }. _A gets someProp out of the whole object, _B gets "x" out of a, b and c. I want [a.x, b.x, c.x] out
08:07:21 <a3gis> What you said assumes that _B works on [a, b, c]
08:07:27 <a3gis> not individual items
08:07:28 <a3gis> no?
08:07:33 <a3gis> c_wraith: ^
08:09:00 <c_wraith> a3gis: oh, I misread what you had there.  I think that you really want a traversal instead of a lens for _A.  Then you can use it to work over all the elements with ^.. instead of ^>
08:09:03 <c_wraith> err, instead of ^.
08:09:22 <a3gis> how does that work? I am completely new to lenses
08:09:56 <c_wraith> a3gis: a traversal is kind of like a multi-target lens.
08:11:33 <c_wraith> a3gis: It would allow you to work on all the elements "at once", for some sense of "at once"
08:12:17 <c_wraith> a3gis: but the main idea is that instead of having a lens to extract a list of values, you'd have a traversal over all the values
08:12:31 <a3gis> ok, makes sense
08:12:43 <a3gis> and there is no lib function to build such a traversal out of a given lens?
08:12:50 <c_wraith> I'm not sure. :)
08:13:55 <a3gis> e.g. if I had Foo [[(1, 2)], [(3, 4), (5, 6)]] and wants to get [2, 4, 6] out
08:14:05 <a3gis> alright, I'll try to look it up :)
08:16:03 <c_wraith> > [(1,2), (3,4), (5,6)] ^.. each . _1 -- a3gis
08:16:05 <lambdabot>  [1,3,5]
08:17:08 <a3gis> oh sweet
08:17:09 <a3gis> thanks
08:17:55 <exio4> @type each
08:17:57 <lambdabot> (Each s t a b, Applicative f) => (a -> f b) -> s -> f t
08:18:03 <c_wraith> a3gis: note that it's using ^.. instead of view.  That's the operator that selects all targets of a traversal and returns them all.
08:18:28 <a3gis> and how would you compose that with some lens _A that gets the list out of a bigger object?
08:18:54 <a3gis> e.g. \d -> (view _A d) ^.. each . _1
08:19:33 <c_wraith> a3gis: I'm guessing something like \d -> d ^.. _A . each . _1
08:20:05 <frerich2> Hi! It seems to me that when defining functions which take a value of some type 'a' (or 't a'), then take some more values (of arbitrary types) and eventually produce a "new" value of type 'a' (or 't a'), then it's a good idea to write the signatures so that instead of having 'a -> .. -> a' you have '.. -> a -> a'. It really lends itself to currying. I bet many people found this already, I wonder whether there's
08:20:05 <frerich2>  some document talking about examples (and counter-examples) of this?
08:20:45 <c_wraith> a3gis: ah, ^.. is the infix form of toListOf
08:21:42 <Cale> frerich: Whenever you can create functions of type a -> a in general, it's a nice thing because they all compose with one another. (If you want to be fancy, you can refer to this as the endomorphism monoid on a)
08:22:40 <a3gis> c_wraith: purescript doesn't seem to have it https://github.com/purescript-contrib/purescript-lens/tree/master/src/Optic
08:23:00 <c_wraith> a3gis: ah.  I know nothing of purescript's lenses.
08:23:02 <Cale> frerich: Another rule of thumb (which sometimes contradicts that one), is that the arguments to a function should be in increasing expected rate of change -- so the things which are more like constants go first to aid with currying.
08:24:23 <uberwach> hey, I want to write a function that reads space seperated values from the stdin. I wrote the following (which works fine enough), but I feel that it can be rewritten with better notation:
08:24:25 <uberwach> parseList = fmap (fmap read) (fmap (splitOn " ") getLine)
08:24:55 <uberwach> any ideas? Type is (Read a) => IO [a]
08:25:16 <tdammers> fmap read . unlines <$> getLine
08:25:19 <tdammers> something like that?
08:25:21 <tdammers> no wait
08:25:23 <tdammers> unwords
08:25:28 <chrisdone> quchen2: so i heard you like monoids so i put a monoid in your holey monoid so you can monoid while you monoid https://gist.github.com/chrisdone/c4a029b2da5028f3ffc7/0a6d5ef56af04ece89ca196c6dc0a96ebdd70cad#file-zexample-hs
08:25:40 <quchen2> Oh boy
08:25:46 <benzrf> tdammers: spoilers!
08:25:48 <frerich> Cale: Hmm, yes, I guess that's kind of a no-brainer. It's still came as a bit of a surprise to see how in cases where everything *seems* to be equally likely to change, the "(a -> a) is nice" remark is important. For some reason (spoiled by OOP?) a function which generated computed e.g. a new 'Generation' based on a previous 'Generation' always looked like 'evolution :: Generation -> SomeStuff -> Generation' but
08:25:49 <frerich>  I noticed that it's actually more convenient to have 'evolution :: SomeStuff -> Generation -> Generation'. I.e. what turned out to be practical in the end diverged from my intuition. :-}
08:25:49 <uberwach> tdammers, yeah I looked for a notation with Control.Applicative. Going to try that out, thx in advance
08:25:57 <quchen2> chrisdone: Don't you remember what happened last time
08:26:00 <tdammers> alternatively, `liftM` does the trick
08:26:02 <chrisdone> quchen2: discovered it after dabbling from Nikita's question https://github.com/chrisdone/formatting/issues/13#issuecomment-71671137
08:26:06 <tdammers> same thing, different flavor
08:26:10 <quchen2> I spent a weekend on your stupid holey monoids! Let me alone! ;-(
08:26:22 <uberwach> I lift the [String] -> [a] to IO via liftM?
08:26:26 <chrisdone> :D
08:26:29 <benzrf> uberwach: fmap f (fmap g x) = (fmap f . fmap g) x = (fmap (f . g)) x
08:26:37 <benzrf> uberwach: no, just fmap
08:27:28 <Peaker> tdammers: words, not unwords
08:27:36 <tdammers> Peaker: crap, yeah
08:27:51 <Peaker> and may as well use map and not fmap in that context?
08:27:58 <tdammers> "spotting and fixing bugs is left as an exercise to the student"
08:28:07 <frerich> tdammers: You missed a chance for a "words don't come easy to me" pun!
08:28:11 <quchen2> chrisdone: Your Xzibit line was pretty much on the spot
08:28:27 <quchen2> So we put a monoid into a category which we call holey monoid, and we make that into a monoid so we can monoid with it.
08:28:51 <quchen2> I don't know what the benefit is, but I'll have a look at it later. May god have mercy with me
08:29:20 <chrisdone> quchen2: it's a PITA to write format (year % month % day) thedate thedate thedate
08:29:26 <tdammers> frerich: finding puns is also left as an exercise to the student
08:29:31 <chrisdone> quchen2: instead you can write format (year <> month <> day) thedate
08:29:44 <quchen2> Ah, I see
08:29:48 <chrisdone> it composes n combinators to accept the same argument =D
08:29:52 <quchen2> So it's similar to the (a -> b) monoid
08:30:04 <quchen2> Just lifted to holiness
08:30:06 <chrisdone> right
08:31:16 <quchen2> Pretty awesome.
08:32:36 <javjarfer> Hi there! anyone knowns an extension that let me do something like "data variable = variable { dValue :: (Eq a) -> a -> Maybe Double }"
08:33:20 <quchen2> GADTs
08:33:30 <javjarfer> Sorry, here is the right "data variable = variable { dValue :: (Eq a) => a -> Maybe Double }"
08:33:48 <quchen2> Types and constructor names have to be capitalized
08:33:48 <c_wraith> -XExistentialQuantification
08:33:55 <Peaker> javjarfer: that lets you have lower-case data type name, lower-case data constructor names, and passing class constraints as ordinary parameters? :)
08:33:59 <c_wraith> so long as you throw in a forall
08:34:28 <c_wraith> Actually, that's not existential - that's -XPolymorphicComponents
08:34:33 <c_wraith> I always misread those
08:34:45 <Peaker> javjarfer: what do you want that type to mean? it's not clear
08:35:31 <Peaker> javjarfer: if the "a" is polymorphic, then it is impossible to give a value inside variable because you won't be able to compare with an unknown type. If it is existential, then you cannot usefully use this value, because you cannot give such an "a" value
08:36:01 <Peaker> javjarfer: where does "a" type variable come from?
08:36:06 <javjarfer> sorry about capitalization is was a mistake
08:36:10 <c_wraith> I said you could write it, not that it would be useable. :)
08:37:24 <JagaJaga> Guys, what is :< here? data Tree e a = a :< Trunk e (Tree e a)
08:37:25 <JagaJaga> data Trunk e x = Leaf e | Bin x x
08:37:32 <javjarfer> Peaker: ahh okay, that means that even if i could declare it i could never use it?
08:38:17 <dizzeehaskell> JagaJaga: it just looks like a constructor
08:38:23 <Peaker> javjarfer: yeah -- you want the caller to be able to give an arbitrary type, and the callee to be able to compare it with an arbitrary, different type.. but Eq can't do that
08:38:31 <dizzeehaskell> like : for lists
08:38:39 <JagaJaga> dizzeehaskell: that's what I've thought. Thx
08:38:49 <Peaker> javjarfer: if you use: (Typeable a, Eq a) => ..   then you can probably do it, but it's a bit ugly
08:39:01 <Peaker> javjarfer: do you really have a use case where your variables are tagged by different/unknown types?
08:39:36 <arianvp___> Does pipes have something like "await until starved?"
08:39:48 <arianvp___> Like. Read from the OS buffer until it blocks andd then stop?
08:40:02 <sdegutis> Is `if` a special built-in syntax or is it a regular function?
08:40:10 <dizzeehaskell> syntax
08:40:19 <c_wraith> totally unnecessary syntax. :(
08:40:26 <johnw`> sdegutis: it's syntax because of the handling of "then" and "else"
08:40:30 <sdegutis> Oh right.
08:40:39 <sdegutis> But you could totally make a function that does this:
08:40:46 <javjarfer> Peaker: i was involved in creating a type that involves some king of type deduction, but i didn't want polymorphic types, so i wanted to enclose the polymorphism in a function using ad-hoc polymorphism
08:40:57 <sdegutis> oh no wait you can't
08:40:58 <dizzeehaskell> if' :: Bool -> a -> a -> a
08:41:00 <dizzeehaskell> that would work
08:41:04 <dizzeehaskell> something typed like that
08:41:10 <dizzeehaskell> just so long as you distinguish the if :p
08:41:12 <sdegutis> But how would you implement it?
08:41:17 <javjarfer> Peaker: some kind**
08:41:18 <c_wraith> sometimes you also have bool :: a -> a -> Bool -> a
08:41:19 <sdegutis> I was about to use if :D
08:41:20 <johnw`> sdegutis: laziness allows you to
08:41:23 <c_wraith> sdegutis: pattern-match
08:41:26 <sdegutis> Oh right.
08:41:31 <dizzeehaskell> if True x _ = x
08:41:36 <johnw`> if' True b _ = b ; if' False _ c = c
08:42:04 <sdegutis> Nice.
08:42:16 <dizzeehaskell> since you don't have to fully evaluate the branch that isn't taken
08:42:20 <dizzeehaskell> hail laziness
08:42:32 <Peaker> javjarfer: why don't you want polymorphic types?
08:43:00 <Peaker> javjarfer: if your variables are tagged by a String, or by a Guid, or what not, why not parameterize things over which type of tag it is?
08:43:03 <johnw`> laziness replaces macros with functions
08:43:29 <javjarfer> Peaker: Because i wanted to focus myself in standard Haskell, avoiding any extension
08:43:47 <Peaker> javjarfer: but passing type parameters is basic Haskell?
08:44:13 <Peaker> javjarfer: data Variable v = Variable { dValue :: v -> Maybe Double }
08:45:02 <javjarfer> no... i mean, if you have a second i think i could explain it better to you
08:45:12 <javjarfer> Peaker: no... i mean, if you have a second i think i could explain it better to you
08:45:28 <fatlazycat> anyone setup a haskell env with a nix expression ?
08:52:48 <sdegutis> If module names are based on capitalized directory names, how does this account for case-insensitive file systems?
08:53:08 <hpc> by capitalizing filenames correctly
08:53:24 <sdegutis> oh
08:53:29 <sdegutis> ok
08:54:32 <hpc> the general assumption with filesystems is to avoid both edge cases
08:54:39 <hpc> referencing a file with the wrong case
08:54:47 <hpc> and having two identical filenames of different case
08:55:05 <hpc> then you never need to care
09:05:18 <benzrf> sdegutis: case-insensitive filesystems arent relevant to real-world programming
09:05:19 <benzrf> sdegutis: i wouldnt worry about it
09:05:19 <benzrf> ;)
09:06:23 <hodapp> ghc: panic! (the 'impossible' happened), Cant do annotations without GHCi
09:06:25 <hodapp> well that's a new one!
09:06:35 <osfameron> benzrf: this is what git's developers thought, until last month...
09:06:41 <hodapp> I guess my "can my Chromebook with a Linux chroot compile a real package?" test has failed, sort of
09:09:06 * hackagebot Strafunski-StrategyLib 5.0.0.6 - Library for strategic programming  http://hackage.haskell.org/package/Strafunski-StrategyLib-5.0.0.6 (JamesKoppel)
09:09:14 <chrisdone> somewhere the guy who decided FAT12 was going to be insensitive is sitting drinking a cup of tea happily and still thinks he was right
09:10:13 <alpounet> not sure he drinks tea =)
09:11:15 <chrisdone> then one day http://i3.kym-cdn.com/entries/icons/original/000/011/656/sophiscated_cat.PNG
09:11:30 <sdegutis> ok
09:13:33 <Hijiri> test
09:18:59 <ClaudiusMaximus> dcoutts: back home again, i filed https://github.com/haskell/cabal/issues/2389
09:20:52 <f_x>   
09:21:27 <hodapp> hmmm, wonder if I can find some magical version of optparse-applicative that does not require ghci
09:21:33 <hodapp> since I'm on ARM and have no ghci that I'm aware of!
09:23:14 <fenak> Hi everyone, I'm trying to get my head around Haskell and FP, but I don't get in what I could/would do with it (I've been developing for web and backend systems with Ruby/Java). Any tips?
09:23:38 <chrisdone> this never gets old http://this-plt-life.tumblr.com/post/36425238138/when-i-finally-grokked-delimited-continuations
09:24:00 <chrisdone> fenak: *why* are you trying to get your head around Haskell and FP? start from there =)
09:24:26 <kadoban> fenak: You can use it for just about anything, so that's a question that's a bit hard to answer.
09:25:16 <shelf> fenak: it can be quite nice for web backends! there are a few frameworks
09:25:28 <chrisdone> fenak: what is it that interests you in the first place?
09:25:59 <merijn> chrisdone: Bragging right? ;)
09:29:44 <ReinH> hodapp: how does it require ghci?
09:30:58 <hodapp> ReinH: I have no idea. http://lpaste.net/2658979377819156480 is what I'm looking at.
09:31:35 <Peaker> 7.6.3 is kinda old?
09:32:04 <hodapp> Peaker: perhaps that's the issue. DAMN YOU ARM UBUUUUNTUUUUU
09:32:14 <merijn> Doesn't it use Template Haskell?
09:32:22 <merijn> I don't think GHC supports TH on ARM yet?
09:32:47 * hodapp flips to a notebook page that says something about ARM and GHC on top
09:32:53 * hodapp is heard to be loudly scribbling something out
09:33:12 <ReinH> hodapp: Huh, supposedly that (or something similar) was fixed in 7.4.2 https://ghc.haskell.org/trac/ghc/ticket/9683
09:33:20 <fenak> chrisdone: I just fell in love with the idea.. about purity, and haskell syntax, and I've been restudying Calculus and Math and it just clicks..
09:33:25 <hodapp> as usual, Haskell is probably not the problem!
09:35:31 <fenak> chrisdone: when I was learning ruby a long time ago, I fell in love with the syntax, and I've been working with it (not only Rails, but Ruby) since then. but I'd already had a firm understanding in OOP and its applications..
09:35:43 <sdegutis> !seen BONUS
09:35:59 <merijn> sdegutis: He hasn't been around in a long time
09:36:01 <sdegutis> Wow, that bot works better than I thought.
09:36:16 <sdegutis> Wish it was more specific though.
09:36:21 <geekosaur> BONUS vanished shortly after the book was public
09:36:24 <merijn> Also, there's no !seen command in lambdabot :p
09:36:25 <geekosaur> er published
09:36:33 <Peaker> fenak: Ruby syntax has a different meaning if you have: "f (x, y)" and "f(x, y)" right? :(
09:36:40 <kadoban> fenak: Cool. Well, I mean as you get to know it better you'll figure out how to use it for useful stuff. How are you learning? Have you checked out https://github.com/bitemyapp/learnhaskell ?
09:36:46 <sdegutis> Does he makes a living on the book?
09:37:03 <merijn> sdegutis: Naah, last I heard he started a new job for some big company after finishing the book
09:37:10 <sdegutis> ohok
09:38:28 <benzrf> Peaker: well the latter is an error
09:38:39 <benzrf> Peaker: perhaps you are thinking of f[x, y] and f [x, y]
09:38:58 <hodapp> https://launchpad.net/ubuntu/trusty/armhf/ghc booo, old GHC
09:39:56 <fenak> Peaker: I think I don't understand your queston..
09:40:00 <ReinH> benzrf: no, the first is an error
09:40:10 <ReinH> f(x,y
09:40:14 <ReinH> f(x,y) is correct
09:40:16 <benzrf> Peaker: er, yes
09:40:18 <benzrf> * ReinH
09:40:19 <sdegutis> What is your least favorite aspect of Haskell in practice and then in theory?
09:40:22 <benzrf> ReinH: i had them  backward in my head
09:40:41 <fenak> kadoban: I'll check it out... I've been reading parts of LYHGG and Real World Haskell
09:40:59 <benzrf> fenak: oh hell
09:41:11 <kadoban> fenak: Ah. Yeah that's how I learned to, but it took forever. I'd do the recommended course from that link instead, it's quite nice.
09:41:21 <kadoban> s/to/too/
09:41:52 <ReinH> Peaker: Well, one is a syntax error, so I suppose that is a different meaning.
09:43:00 <fenak> kadoban: I'll check it out.. It feels weird to not figure out something for put my hands on and learn by coding..
09:43:24 <fenak> kadoban: A little bit close with me studying japanese.. lol
09:43:55 <kadoban> fenak: Yeah, haskell tends to be hard to do that coming from the standard set of languages most people know.
09:44:21 <kadoban> s#haskell#haskell/japanese# also works probably
09:45:21 <sdegutis> Does the latest GHC support Haskell 2010 either be default or at least optionally?
09:45:30 <sdegutis> I'd love to have n+k patterns banned.
09:45:37 <monochrom> by default
09:45:43 <sdegutis> Nice.
09:45:56 <sdegutis> Thanks monochrom.
09:47:25 <ReinH> They aren't banned, they require an extension.
09:47:32 <sdegutis> aw
09:47:40 <ReinH> No one is forcing you to use them.
09:47:45 <sdegutis> yay
09:50:30 <monochrom> that is just a different meaning of "ban'
09:50:47 <dizzeehaskell> 'discourage'
09:51:01 <dizzeehaskell> a la north korea
09:51:43 <monochrom> indeed, on IRC, if I do "+b *!*@xxx.com", one could say: they aren't banned, they require an exemption, "+e goodguy!gooduser@xxx.com"
09:52:07 <sdegutis> lol
09:54:46 <SrPx> I'm out of inspiration, how do I take a value that could be both "V3" or "V2" (from Linear) and transform it into "V3 0 1 2" or "V2 0 1"?
09:55:25 <SrPx> That is, "toIndexes :: (Foldable f, Num a) => f a ‚Üí f a; toIndexes vector = ????" ... this is killing me
09:55:53 <SrPx> functorWithIndex seems not to do what I want, regardless of V2 and V3 having an instance... anything else?
09:57:36 <danilo2> hello! :) Can we limit some parametrized haskell types to some predefined types, like data Foo m a = Foo (m a) so m would be only A or B ?
09:58:04 <danilo2> ughm maybe not types, data types
09:58:31 <Welkin> make a typeclass and make A and B instances of that typeclass
09:58:38 <Welkin> then put a typeclass restriction on the function
09:59:08 * hackagebot lucid-svg 0.3 - DSL for SVG using lucid for HTML  http://hackage.haskell.org/package/lucid-svg-0.3 (jeffreyrosenbluth)
09:59:15 <danilo2> Welkin: I dont have typeclass here- just datatype. I know I can hide its constructor and make typeclass to construct it, but is it the only solution?
10:00:00 <Peaker> ReinH: is it detected at run-time?
10:00:23 <Peaker> benzrf: my coworkers had spent hours debugging the difference between "f <expr>" and "f<expr>" (I don't remember what <expr> is)
10:00:32 <ReinH> Peaker: syntax errors are detected at parse time.
10:00:35 <benzrf> Peaker: lol
10:00:41 <benzrf> ReinH: f[x] vs f [x]
10:00:52 <stelleg> anyone able to build hoogle database right now? getting error about hackage docs not being available
10:00:53 <ReinH> benzrf: perhaps.
10:01:04 <sdegutis> Do you find yourself using $ very often, or extremely often?
10:01:13 <ReinH> sdegutis: relatively infrequently.
10:01:31 <benzrf> :t (3$)
10:01:32 <lambdabot> Num (a -> b) => a -> b
10:01:42 <benzrf> 3 dollar!
10:07:05 <monochrom> $ can't buy you love, but it can buy you function application
10:07:33 <dizzeehaskell> ...that's going on my gravestone
10:07:58 <dizzeehaskell> sdegutis: I use $ literally *all the time*
10:08:00 <dizzeehaskell> It's a matter of taste
10:09:22 <benzrf> @remember monochrom $ can't buy you love, but it can buy you function application
10:09:23 <lambdabot> I will never forget.
10:10:27 <clrnd> sdegutis, I use it like this: some . functions with . arguments but $ last
10:10:34 <sdegutis> nice
10:10:55 <clrnd> instead of a $ lot $ of $ dollars
10:13:17 <rasen> clrnd: This way it's easier to make it point-free later
10:15:14 <rasen> With all these compositions and application I got used to read code right to left.
10:15:48 <c_wraith> in haskell, it's still left-to-right.
10:16:16 <c_wraith> (f . g) runs f before g.  That matters because haskell is non-strict
10:16:19 <SrPx> Nobody? :(
10:16:48 <SrPx> I don't get it, things like "fmapWithIndex (\ i x -> i) (V3 4 5 6)" simply don't work... weird
10:18:09 <quchen> Oh wow that BBP mail got me unprepared
10:19:14 <quchen> The libraries committee has been cooking something up quietly for quite some time now, the result sounds pretty neat
10:23:01 <merijn> Wut
10:23:22 <merijn> BBP has been argued about for months on libraries@ and now everyone goes "huh, where'd that come from?"
10:23:40 <ReinH> SrPx: what does "don't work" mean?
10:24:30 <quchen> merijn: It was argued and argued again. Then it got very silent because no consensus was reached, and the libraries committee was formed.
10:25:05 <ReinH> quchen: BBP?
10:25:11 <SrPx> ReinH: the error is: http://lpaste.net/119329 - I'm still trying to figure out what that "E V3" means ... I have tried extracting V3 from it to no success
10:25:29 <arjanb> not many people read the libraries list (actively)...
10:25:33 <quchen> ReinH: Burning Bridges Proposal, aka "make Prelude cool again"
10:25:35 <sdegutis> Which gitignore should we use for a typical Haskell program, Haskell.gitignore or Cabal.gitignore?
10:25:53 <ReinH> Oh ofc
10:25:57 <quchen> ReinH: https://www.haskell.org/pipermail/libraries/2015-January/024777.html
10:26:05 <sdegutis> I assume this:  https://github.com/github/gitignore/blob/master/Haskell.gitignore
10:26:28 <SrPx> I have managed to solve myproblem with ST but, really?http://lpaste.net/119330
10:26:59 <kadoban> sdegutis: Yeah, that looks right I think
10:27:05 <quchen> merijn: What surprises me the most is that this is supposed to ship with 7.10.
10:27:13 <ReinH> SrPx: what do you expect to happen?
10:27:26 <quchen> This either means everything breaks, or there will be huge delays. I can't imagine neither happening.
10:28:07 <merijn> quchen: Yeah, any changes now will hugely delay 7.10 :\
10:28:27 <SrPx> ReinH: I just want to transform a vector into a ascending sequence of indexes so that is what I expect
10:28:38 <ReinH> SrPx: https://www.gitignore.io/api/haskell
10:28:50 <ReinH> SrPx: Well, that isn't what it does. Maybe you should have checked before you used it and got surprised by the result.
10:28:56 <ReinH> er, sdegutis https://www.gitignore.io/api/haskell
10:29:04 <sdegutis> nice
10:29:15 <SrPx> ReinH: Hm I tried to? Except there is no description on the package, only the code?
10:30:24 <ReinH> SrPx: Vectors are indexed by "basis element" http://hackage.haskell.org/package/linear-1.16.1/docs/Linear-Vector.html#t:E
10:31:31 <SrPx> ah I finally get it. nevermind ... I was reading that page for several minutes before asking but it didn't click
10:31:55 <ReinH> linear doesn't have a lot of documentation
10:32:21 <hodapp> quasiquotation plus no documentation whatsoever is really getting me down here...
10:32:30 <ReinH> Most of it is stuck in edwardk's head
10:32:36 <SrPx> true... i should've figured that from the types
10:32:39 <hodapp> because I can't just poke around and ask what something's type is
10:33:03 <hodapp> I just have to throw text in a file aimlessly and see whether the quasiquoter takes it or not, and get meaningless gibberish errors when it doesn't
10:33:37 <SrPx> anyway, if anyone has an idea, then, on how to transform a V3 _ _ _ into V3 0 1 2, better than this: http://lpaste.net/119331 please let me know :)
10:34:39 <ReinH> Uh, f V3 _ _ _ = V3 0 1 2 ?
10:35:14 <SrPx> ReinH: the problem is that toIndexes could receive a V4 too ...
10:35:28 <SrPx> so I can't hardcode for V3 on its implementation :(
10:35:32 <ReinH> Then use a typeclass
10:35:57 <clrnd> yeah, how traverse does
10:36:07 <SrPx> yes that's the point, I'm not sure which typeclass solves my need of converting any structure to a list of indexes :(
10:36:20 <ReinH> the one called HastoIndexes that you create
10:36:51 <SrPx> ReinH: ... but then I will have to create an instance for every other data structure on prelude, etc
10:36:58 <SrPx> I was looking for something that exists
10:37:17 <ReinH> Why do you need it to exist for *every structure in the prelude*?
10:37:18 <SrPx> well I guess I will just use that code
10:37:45 <ReinH> Why don't you just need it to exist for the ones you are going to use it on
10:37:58 <clrnd> that code won't work for many types also... I guess
10:38:09 <clrnd> structures*
10:39:05 <SrPx> ReinH: because my container is supposed to accept any structure on prelude since I could potentially want to use any structure on prelude with my container
10:39:11 <enthropy> lens probably has such a class
10:39:19 <ReinH> What container?
10:39:25 <ReinH> Why does your container need to do this?
10:39:49 <ReinH> enthropy: it has indexed things, but the index isn't necessarily of the right type.
10:40:42 <codygman> Is there an inbuilt/existing way I could get a list of all results from something like this (so I could display all errors for instance): Left "error one" <*> Left "error two" <*> Right "Correct value"
10:40:46 <zachk> I'm working with sdl2 in haskell and a need function :: a -> Ptr a , how do I do that in haskell?
10:41:08 <SrPx> an hyperoctree / space partitioning tree, it is supposed to accept both lists such as [1,0,0] and vectors such as V3 1 0 0 as keys
10:41:39 <quchen> zachk: Without IO?
10:42:06 <zachk> oh it could use IO (I guess) ... not a problem
10:42:08 <SrPx> I don't want to restrict it to linear's V2 V3 etc since I could potentially someday create a project using other vector library (or even lists, tuples, whatever) and then my tree class would be useless
10:42:19 <ReinH> SrPx: Why would it need that function?
10:42:44 <ReinH> That doesn't seem like it would have any use on vectors
10:42:57 <meditans> what resources do you recommend for learning how to profile, besides the chapter in RWH and the info on the wiki?
10:43:07 <ReinH> I thought the whole point was to make it polymorphic in its leaves.
10:43:33 <mmachenry> meditans: Simon Marlow's book has info on profiling as well.
10:43:39 <ReinH> meditans: the ghc user guide has some good stuff, and dons has some good stack overflow answers
10:43:54 <SrPx> ReinH: to convert between spatial positions and linear indexes (for vector access)... ex: V3 0.7 0.6 0.2 lies at index 5... and back
10:44:28 <ReinH> SrPx: That's not the job of a octree. That's the job of a user of an octree.
10:44:45 <ReinH> An octree is just a particular tree structure.
10:45:05 <SrPx> No, that's absurd. The user of an octree must provide the spatial position, such as "insert object at V3 3 4 5"
10:45:08 <ReinH> It doesn't by itself denote anything about spatial positioning
10:45:15 <enthropy> @msg lambdabot @unmtl WriterT msg Either ()
10:45:15 <lambdabot> Not enough privileges
10:45:22 <enthropy> @unmtl WriterT msg Either ()
10:45:22 <lambdabot> Either ((), msg)
10:45:40 <ReinH> SrPx: Octree V3 might be about spatial positioning.
10:45:45 <ReinH> Octree a definitely isn't
10:46:37 <SrPx> ReinH: well that is how every octree I've used works, including the one at hackage... that's how I expect mine to work... https://hackage.haskell.org/package/Octree-0.2.2/docs/Data-Octree.html
10:46:39 <raek> is there a word for typeclasses like Applicative, Monad, Arrow? i'm particularly thinking about their way of hiding "boring boilerplate code"...
10:46:56 <SrPx> nvm though
10:47:10 <ReinH> Yes, an octree containing 3-dimentional points should probably have some utilities for treating it like a space partitioning tree
10:47:16 <ReinH> an Octree a cannot do so at all
10:47:28 <ReinH> It's just a particularly shaped generic tree
10:47:56 <ReinH> if you want to make it fully general, you lose the ability to say specific things about it
10:48:41 <SrPx> it doesn't contain 3 dimentional points, it uses them for indexing, it contains whatever you want it to...
10:49:10 * hackagebot ChasingBottoms 1.3.0.11 - For testing partial and infinite values.  http://hackage.haskell.org/package/ChasingBottoms-1.3.0.11 (NilsAndersDanielsson)
10:49:11 <SrPx> or I'm not sure what you are talking about tbh
10:49:34 <zachk> oh the new function from Foreign.Marshall is :: a -> IO (Ptr a) :D
10:50:35 <ReinH> SrPx: So your Octree is indexed by V3?
10:51:10 <SrPx> ReinH: or by V2, V4, whatever
10:51:38 <ReinH> Ok, then my point still stands. The more fully general you make the "whatever", the less speific things you can say about it.
10:52:14 <ReinH> I don't know why you wouldn't index it by V3, though. Indexing by V2 doesn't give you a 3D space partition and V4 just gives you extra information you will throw away.
10:52:19 <SrPx> I know, I just don't see why you are saying this
10:52:29 <meditans> mmachenry: Parallel and concurrent programming?
10:52:34 <SrPx> ReinH: it gives a 2d space partition
10:52:51 <ReinH> But you want a quadtree for that
10:52:55 <ReinH> and a 16-tree for 4d
10:52:57 <sdegutis> What can I do to create a type named String so that it won't clash with the existing String type in my code?
10:52:58 <SrPx> yes, it becomes a quadtree...
10:53:06 <SrPx> and yes it becomes a 16-tree for 4d
10:53:14 <meditans> ReinH: thanks, I glanced at the bit into ghc manual, now I'm getting the overflow stuff
10:53:18 <ReinH> SrPx: How?
10:53:51 <SrPx> ReinH: it uses vectors to hold pointers to children so if you are using V2 for indexing it creates vectors with 4 elements... and so on
10:53:53 <SrPx> how how?
10:55:46 <raek> sdegutis: import Prelude hiding (String)
10:55:49 <ReinH> So you can still create a typeclass of the types you can reasonably use as an index. Surely that isn't "every container-like type in the prelude".
10:56:21 <Luke> someone requested I use transformers-compat for transformer dependency problems. anyone know the correct best practice here?
10:56:21 <raek> import qualified Prelude as P
10:56:28 <SrPx> perhaps, I might think about that as a refactoring now that I think about it, honestly...
10:56:38 <raek> (in case you want to use the one from the Prelude later on)
10:56:47 <SrPx> but I still think it is maybe a good idea if I can do it just in terms of common typeclasses so I avoid extra work
10:57:34 <ReinH> I don't think t here's a common typeclass for "things that can be used as an 2^n-ary tree index" ;)
10:57:58 <SrPx> actually that's foldable
10:58:15 <ReinH> I don't think so?
10:58:34 <SrPx> the problem is that I'd need the inverse of foldable for some specific aabb box positioning :( unfortunately there is no "unfoldable" typeclass
10:58:40 <SrPx> ReinH: why don't you.
10:59:19 <ReinH> because Foldable doesn't make sense, so I guess the question is why *do* you?
10:59:25 <enthropy> codygman: runWriter . runError has the right type for that, but it seems it doesn't keep collecting errors
10:59:26 <osa1__> can I generate a whole module using TH? like with module name, exports list, list of imports, and then declarations etc.
11:00:15 <enthropy> probably because to write the Monad instance (>>=) needs to get a value that might not be there
11:00:20 <ReinH> SrPx: Unless your plan is to treat all index types as if they were lists
11:00:24 <SrPx> ReinH: of course it does, foldable gives exactly what you need, which is converting a vector of n scalar spatial coordinates into a single value (its index on the vector)
11:00:48 <sdegutis> raek: But I'd still like to use Prelude.String throughout the file where I define my own String.
11:00:50 <ReinH> SrPx: How?
11:01:04 <sdegutis> Oh I know, I can import qualified Prelude as P and do P.String
11:02:36 <SrPx> ReinH: ...? First element is the first coordinate, second element is the second coordiante... so on
11:03:00 <ReinH> SrPx: How does Foldable let you do that?
11:03:03 <arianvp___> can I unpack type synyms in ghci?
11:03:18 <ReinH> SrPx: Just by treating it as a list?
11:03:23 <johnw> debugging which hunk is segfaulting feels like debugging in reverse...
11:04:04 <raek> sdegutis: you can also write "import qualified Prelude" if you prefer that. then you can access the type like "Prelude.String"
11:04:12 <SrPx> ReinH: what do you mean by just treating it like a list?
11:04:27 <ReinH> SrPx: Any foldable can be converted into a list. I'm wondering if that's how you're indexing it.
11:04:29 <sdegutis> raek: right that's what I said ;)
11:05:33 <nkar> hvr: nevermind the packunused issue: I was using packunused-0.1.1.3, which uses pre-1.22.0.0 Cabal, so it failed to parse setup-config generated by ghc-7.8.4.  after switching to 0.1.1.4 the problem went away
11:05:35 <gcganley> @hoogle (a -> b) -> (b -> c) -> a -> c
11:05:37 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
11:05:38 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
11:05:38 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> (a -> c)
11:05:41 <SrPx> ReinH: ... no, I'm just using the order the elements are feed to foldr ...
11:05:42 <codygman> enthropy: Ohhh, thanks for that anyway. Its interesting.
11:06:37 <dfeuer> Ugh. I'm starting the horrible job of implementing a fancy data structure, but I want it specialized so it can hold unboxed Word values. Is there a way to write the code so the same source can be used to produce other specialized versions?
11:06:42 <SrPx> I'm not sure why are you questioning this design, is foldr not supposed to give a meaning to the order?
11:07:20 <ReinH> SrPx: I'm questioning it because it doesn't make sense to me, but at this point I'm not sure that it needs to.
11:07:34 <nkar> dfeuer: there's a pragma for that, which was mentioned in dolio's talk
11:07:36 <nkar> iirc
11:07:41 <nkar> but I cannot remember which one
11:07:46 <nkar> let me try to find it
11:07:46 <NightRa> How can I wait for a key press in the console? (without typing it and not needing to press eneter)
11:07:51 <SrPx> ... well thank you. Sorry if my library doesn't make sense to you...
11:07:58 <SrPx> what the...
11:08:20 <dfeuer> Thanks, nkar.
11:08:58 <dfeuer> It's actually even more annoying than that‚ÄîI want to specialize it for key-value pairs, where the key is a Word.
11:09:06 <rasen> NightRa: Not sure. But there should be ncurses bindings
11:09:13 <dfeuer> But whatever.
11:09:54 <NightRa> rasen: Does it support Windows?
11:10:00 <nkar> dfeuer: I guess I'm thinking of SPECIALZIE
11:10:07 <nkar> but maybe it does something else
11:10:23 <dfeuer> nkar, yeah, that's something else.
11:11:08 <dfeuer> I think I'm probably thinking of some stuff with Generics or possibly even Template Haskell, neither of which I know anything about.
11:12:42 <ReinH> NightRa: Looks like you're running into a long-standing GHC bug https://ghc.haskell.org/trac/ghc/ticket/2189
11:13:03 <ReinH> NightRa: But I think you can use haskeline.
11:15:02 <NightRa> I want to make an interactive user interface in the terminal which reacts to the arrow keys
11:15:28 <wayne> NightRa: you'll want some bindings for curses then
11:16:02 <NightRa> hcurses or ncurses or anything else?
11:19:11 * hackagebot seqid 0.3.0 - Sequence ID production and consumption  http://hackage.haskell.org/package/seqid-0.3.0 (LukeHoersten)
11:19:13 * hackagebot seqid-streams 0.3.0 - Sequence ID IO-Streams  http://hackage.haskell.org/package/seqid-streams-0.3.0 (LukeHoersten)
11:19:53 <Black0range> Where can i read about haskells pre processor?
11:20:16 <ClaudiusMaximus> @hackage vty -- NightRa, not tried it myself but heard good things
11:20:16 <lambdabot> http://hackage.haskell.org/package/vty -- NightRa, not tried it myself but heard good things
11:20:38 <lpsmith> Black0range, this one?   https://gcc.gnu.org/onlinedocs/cpp/
11:21:17 <NightRa> ClaudiusMaximus: Thank you!
11:21:43 <NightRa> ClaudiusMaximus: cygwin only :(
11:22:38 <ReinH> NightRa: Are you specifically looking for a curses-like?
11:22:55 <ReinH> Ah. I've used ncurses and vty.
11:23:07 <NightRa> ReinH: Absolutely no. Anything for console graphics supporting windows
11:23:31 <ReinH> NightRa: windows support is going to be hit or miss, unfortunately.
11:24:14 <Black0range> lpsmith: so it's exactly the same? how come this doesn't work? http://lpaste.net/119341
11:26:20 <NightRa> I've started to use System.Console.Ansi, and only missing capturing key presses for the time being
11:26:56 <lpsmith> Black0range, because you have a syntax error in the haskell code?   Removing the $ signs worked for me...
11:28:27 <Black0range> Hmm weird... all i got was "test.hs:11:8: Empty 'do' block"
11:28:37 <lpsmith> right
11:28:42 <lpsmith> delete the dollar sign
11:28:51 <Black0range> did it and it worked! thanks mate
11:28:58 <lpsmith> you are welcome =)
11:29:49 <Black0range> do you perhaps happen to know if there is a way to define macro names from gsc arguments?
11:30:38 <Black0range> ghc*
11:31:02 <lpsmith> Black0range, in any case,  which CPP GHC uses depends on which one is on your system,  so if it's GNU CPP, then yes it's exactly the same
11:31:37 <lpsmith> Black0range, I don't know too much about that,  I usually let Cabal do that for me.  I'm sure there's some GHC flags you can set though
11:32:16 <dcoutts_> Black0range: yes that's possible I think, check the gcc docs on the preprocessor
11:32:22 <devJunk> i hear this channel is rad
11:32:38 <clrnd> it's the best channel
11:32:42 <dcoutts_> @yarr!
11:32:43 <lambdabot> Aye
11:32:47 <lpsmith> Black0range, e.g.  "snap init" generates a .cabal file with an optional   "cpp-options: -DDEVELOPMENT"
11:33:37 <Black0range> devJunk: But don't you dare anything about non functional languages! (these guys doesn't like that very much)
11:33:55 <dcoutts_> Black0range: like the C pre-processor? :-)
11:34:15 <Black0range> dcoutts_: shh it's a grey area
11:34:20 <lpsmith> dcoutts_, does GHC ever use a non-GNU CPP on other platforms?
11:34:25 <dcoutts_> :-)
11:34:33 <lpsmith> Or does it depend specifically on GNU CPP?
11:34:34 <dcoutts_> lpaste: yes, it uses llvm on osx
11:34:37 <dcoutts_> oops
11:34:40 <dcoutts_> lpsmith: ^^
11:34:41 <lpsmith> :)
11:34:48 <benzrf> llvm hsa its own cpp?
11:34:49 <devJunk> Black0range: I'll just stand in the corner and watch for now
11:34:50 <dcoutts_> sorry :-) tab completion strikes again
11:35:04 <kadoban> Black0range: Actually, people here are pretty chill about other languages/technologies/frameworks/whatever.
11:35:18 <dcoutts_> benzrf: well, the C compiler that's part of the llvm ecosystem
11:35:49 <benzrf> dcoutts_: cpp = c preprocessor
11:36:11 <dcoutts_> I know, and the C compiler comes with a C pre-processor
11:36:49 <dcoutts_> lpsmith: a bunch of ghc things broke when osx moved away from gnu gcc's cpp
11:37:10 <dcoutts_> ghc uses cpp in -traditional mode, which has no real definition
11:37:23 <carter> devJunk: you mean lang
11:37:26 <lpsmith> lol, that doesn't suprise me,  it's easy to unintentionally introduce those sorts of dependencies
11:37:31 <carter> dcoutts_: you mean clang
11:37:33 <carter> not llvm
11:37:37 <Black0range> lpsmith: sadly i dont know too muhc about how cabal works :/
11:37:41 <dcoutts_> carter: I do
11:38:02 <dcoutts_> couldn't remember the name ottomh
11:38:07 <carter> clang
11:38:29 <devJunk> i mean no thing
11:39:38 <carter> darn autocomplet
11:42:47 <lpsmith> Black0range, well, I probably ought to know more about Cabal than I do,  but I've managed to get by pretty well by emulating others,  and reading the docs/sources as I need to learn more.
11:43:05 <sdegutis> Do you often find yourself creating a custom sum type solely for one function to represent the various return values it might have?
11:43:31 <clrnd> sdegutis, mmm not really
11:43:46 <lpsmith> sdegutis, depends on what you mean by "often"... I'm not sure I'd call it often,  but it's not uncommon either.
11:43:47 <clrnd> yes for a module or package
11:43:57 <clrnd> for a single funciton I'd use Either
11:44:13 <chpatrick> sdegutis: if it really doesn't fit something that exists
11:44:44 <chpatrick> datatypes are cheap but if you make something new then it won't work with the standard tools
11:44:56 <sdegutis> For example my login function returns data LoginResult = Success user | Error failureString | BadPassword | UnconfirmedAccount
11:45:05 <sdegutis> where failureString is kind of like a 500 error
11:45:24 <lpsmith> sdegutis, that sounds reasonable
11:45:34 <clrnd> well that sounds okay, login could be more than a single function in the future
11:45:36 <sdegutis> That way I can handle the different results easily with pattern matching.
11:45:54 <sdegutis> clrnd: But semantically it should be a single function since it's a single user-operation.
11:45:55 <lpsmith> Possibly more idiomatic would be type LoginResult = Either LoginError User
11:46:11 <sdegutis> lpsmith: that sounds reasonable, if LoginError were another sum type
11:46:19 <sdegutis> lpsmith: I like your style buddy
11:46:21 <lpsmith> data LoginError = Error failureString | BadPassword | UnconfirmedAccount
11:49:04 <sdegutis> Haskell is by far my favorite language so far.
11:52:18 <Black0range> Are there some paper anywhere that lists the performance sinkholes of haskell?
11:52:34 <Black0range> or a "dont do this" list
11:52:44 <sdegutis> It seems silly that Eq requires you to implement both == and /= when it could derive /= for you.
11:53:01 <tommd> sdegutis: Eq lets you define whichever one you want
11:53:11 <sdegutis> oh cool, you only need to define just one?
11:53:12 <lpsmith> sdegutis, I'm pretty sure you can define either one, or both
11:53:15 <sdegutis> Niiice.
11:53:19 <tommd> sdegutis: Yes.
11:53:22 <phaul> I'm forming some analogy in my head about referential transparency vs the compositionality in STM in the sense that referential tranparency gives you correctness guaranties in a large system, given that the building blocks are correct.. Have you guys thought about it this way?
11:53:40 <sdegutis> This language, ugh! It just keeps getting better!
11:53:45 <phaul> sdegutis: minimal complete definition
11:54:59 <phaul> STM being software transactional memory..
12:05:30 <phaul> ^^ might be far fetched, but in my head it all boils down to "compositionality"
12:07:51 <Peaker> I don't like the way STM re-checks all inputs every time, potentially unnecessarily.. It's not declarative enough. Perhaps STM should have an Applicative interface too or something in between Applicative and Monad to allow even more efficiency
12:08:17 <twotwofive> Whats a good library/framework for writing a Rest server?
12:09:14 * hackagebot cartel 0.14.0.0 - Specify Cabal files in Haskell  http://hackage.haskell.org/package/cartel-0.14.0.0 (OmariNorman)
12:09:17 <Javran> @djinn (b -> Maybe (a,b)) -> b -> [(a,b)]
12:09:17 <lambdabot> Error: Undefined type []
12:09:28 <twotwofive> basically all i need is a nice way to define routes, json serialization/deserialization, ability to work with lower level http like headers and potentially authorization
12:09:33 <phaul> twotwofive: silk guys sis something in that area didn't they?... letme find it..
12:09:50 <quchen> Javran: Djinn doesn't support recursive types I think.
12:09:52 <twotwofive> phaul: doesnt silk use snap?
12:10:11 <Javran> quchen: I see
12:10:28 <twotwofive> i dont need a lot of features something very basic but elegant
12:10:44 <Javran> just wondering if there's a unfoldr that keeps seeds
12:10:56 <phaul> ah, I see, I belive it's snap but not sure
12:11:34 <chrisdone> twotwofive: yesod
12:11:54 <twotwofive> thats kinda heavy
12:12:06 <twotwofive> it has a lot of extra stuff which i dont need like file serving and templating
12:12:13 * chrisdone shrugs
12:12:28 <twotwofive> i basically just need a wreq for the server side
12:12:38 <chrisdone> yesod gives you that
12:13:06 <twotwofive> yesod gives you much more than that
12:13:32 <twotwofive> not saying its bad, but im looking for something as simple as possible
12:14:17 <NightRa> So don't I have hope of capturing a key press in the console on windows?
12:14:27 <lpaste> chrisdone pasted ‚Äúrest server with json‚Äù at http://lpaste.net/119345
12:14:44 <chrisdone> twotwofive: do you know of something simpler than that?
12:15:35 <twotwofive> chrisdone: yes but not for haskell im a haskell noob
12:16:21 <Scheriderm> try netwire.input  with GLFW
12:16:43 <twotwofive> chrisdone: thats not really a rest api either
12:17:06 <chrisdone> twotwofive: what is a "rest api" to you?
12:18:57 <clrnd> twotwofive, what about scotty?
12:19:21 <Peaker> GLFW-b is still the way to go right? I haven't examined GLFW in ages
12:19:42 <genisage> Can anybody tell me if there's a name for the sort of list builder that goes something like (\f z -> f 1 $ f 2 $ f 3 z) (:) []? I was trying to review it and I can't figure out what to google.
12:20:22 <clrnd> genisage, fold
12:20:49 <chrisdone> twotwofive: see here https://www.fpcomplete.com/user/chrisdone/yesod-examples
12:21:00 <Peaker> genisage: the lambda is a Church-encoded list, also equivalent to a foldr applied just to the list
12:21:07 <Black0range> hmm are there any point of having a recv/write timout and a keep alive on unix sockets at the same time?
12:21:11 <chrisdone> twotwofive: click the play button at the top right of the code sample and it runs the server
12:21:15 <quchen> Javran: You can write your unfoldr in terms of normal unfoldr. http://lpaste.net/119346
12:21:29 <quchen> Javran: Just pass the seed on as part of the result value.
12:21:36 <Peaker> Black0range: do you control the keepalive behavior/timeouts?
12:21:37 <genisage> clrnd: Peaker thanks.
12:22:15 <Black0range> Peaker: not really
12:23:02 <Black0range> Peaker: or what do you mean by "control" in this context?
12:23:22 <twotwofive> chrisdone: i dont need templating, i need only json content, routes that adhere to general rest best practises
12:23:48 <Peaker> Black0range: setting the keepalive socket options and behavior -- I think you get deterministic behavior/control of what happens if you use manual keepalives/timeouts. You get not-fully-specified (and not portable?) behavior if you try to use underlying socket keepalive
12:23:51 <twotwofive> chrisdone: what you suggested is definetelly good enough but I'm just gona look around for other libraries to see whats available
12:24:15 * hackagebot morfette 0.4.3 - A tool for supervised learning of morphology  http://hackage.haskell.org/package/morfette-0.4.3 (GrzegorzChrupala)
12:24:39 <Black0range> Peaker: i'm writing a tcp server. Wouldn't be very nice to not have one :/
12:24:55 <ReinH> twotwofive: You can get a RESTish JSON API with Yesod relatively easily
12:25:07 <Peaker> Black0range: I'd implement application-level keepalives
12:25:14 <chrisdone> "what you suggested is fine but i'm rejecting it arbitrarily"
12:25:28 * chrisdone shrugs
12:25:30 <chrisdone> good luck
12:25:33 <twotwofive> not rejecting it - just seeing if anything else is available
12:25:48 <twotwofive> its not the only library that can do this
12:25:51 <ReinH> twotwofive: There are some other things like servant and rest
12:26:22 <Black0range> Black0range: wouldn't that require a asynchronous thread?
12:26:30 <Black0range> Peaker: ^
12:27:02 <dosenfrucht> Hello there. Is someone familiar with the IndentParser package? I'm trying to implement a parser for a functional language with the offside rule but there are very few examples
12:27:20 <twotwofive> ReinH: servant seems good
12:29:32 <twotwofive> servant actually seems exactly what im looking for
12:31:15 <twotwofive> thanks ReinH
12:31:30 <Distrox> @say hello
12:31:30 <Distrox1> hello
12:31:30 <lambdabot> Maybe you meant: src slap faq
12:32:14 <fryguybob> dosenfrucht: Perhaps this is useful to you: http://dev.stephendiehl.com/fun/008_extended_parser.html#indentation
12:33:01 <ReinH> twotwofive: I found servant difficult to work with because it forces you into an IO context, but YMMV.
12:33:24 <ReinH> I really wish these sorts of things would use the MonadIO typeclass.
12:33:42 <twotwofive> ah
12:33:59 <twotwofive> ReinH: is rest better in that respect?
12:34:09 <ReinH> I'm not sure but I doubt it
12:34:11 <dosenfrucht> fryguybob: Thanks, i'll take a look at it
12:34:17 <twotwofive> ok
12:34:42 <ReinH> If you want to maintain a connection pool or use ResourceT or something similar, you have to thread things through manually as arguments by constantly wrapping and unwrapping the monad transformer or in an IORef or similar. It's a pain.
12:37:56 <ReinH> twotwofive: Then again, this might not be a problem for you, depending on what you're doing
12:38:27 <twotwofive> ReinH: yeah, I guess I will see when I hit the problem
12:39:08 <ReinH> servant doesn't have any non-trivial examples that I could find, so it was kind of hard to see how I might use it to ship something non-trivial. Yesod certainly doesn't have that problem.
12:39:35 <LAC1213> hey guys
12:39:37 <twotwofive> hmm okay
12:39:40 <sinelaw> is there a partial version of zip?
12:39:44 <sinelaw> am I wrong for wanting one?
12:39:51 <sinelaw> hey LAC1213
12:39:56 <ReinH> sinelaw: partial in what way?
12:40:08 <sinelaw> ReinH, fail if not the same length
12:40:18 <ReinH> When would that be preferable to the current behavior?
12:40:32 <sinelaw> ReinH, when I want that as an assertion
12:40:39 <sinelaw> actually
12:40:48 <sinelaw> that's not very good
12:40:49 <ReinH> Write your own zipMaybe :: [a] -> [b] -> Maybe (a,b) ?
12:40:56 <chpatrick> should be simple
12:40:58 <sinelaw> yeah, was just realizing that
12:41:17 <ReinH> bottom isn't a good way to enforce invariants...
12:41:40 <sinelaw> ReinH, right. Switching back and forth from JS to Haskell does this to me
12:41:49 <Peaker> Black0range: it might
12:41:51 <sinelaw> :P
12:41:55 <ReinH> sinelaw: :p
12:42:06 <ReinH> sinelaw: languages with nulls poison you ;)
12:42:20 <sinelaw> in JS bottom IS better than the default behavior
12:42:31 <Peaker> Nothing > bottom > random truncation behavior    in many scenarios
12:42:32 <sinelaw> which is "coerce to whatever, har har"
12:42:34 <chrisdone> "baby got back" is a bad language policy
12:42:36 <ReinH> The only bottom in JS is non-termination.
12:42:59 <sinelaw> ReinH, there is TypeError
12:43:19 <Peaker> sinelaw: in Haskell, bottom is better than arbitrary wrong behavior too
12:43:39 <sinelaw> yeah. default zip is almost never what I need, come to think of it
12:43:43 <ReinH> exceptions in JS are just a different form of flow control :p
12:43:48 <Peaker> truncating zip is sometimes useful
12:43:49 <sinelaw> if they aren't the same length, just ignore the excess! FTW
12:43:50 <jle`> i use default zip all the time ;_;
12:43:59 <chpatrick> likewise
12:43:59 <jle`> > zip [1..] "hello"
12:44:00 <sinelaw> Peaker, sometimes, but for me at least, not often
12:44:01 <lambdabot>  [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
12:44:04 <chrisdone> i think exceptions in JS are different to exceptions in haskell
12:44:16 <ReinH> I use zipWith more often, but definitely that behavior is useful
12:44:25 <ReinH> chrisdone: see above ;)
12:44:25 <chrisdone> exceptions aren't observeable during evaluation of haskell
12:44:27 <jle`> most of the time when i use zip, one of the lists are infinite
12:44:31 <Peaker> sinelaw: https://github.com/Peaker/lamdu/blob/wip_integration/bottlelib/Data/List/Utils.hs#L43
12:44:55 <chrisdone> ReinH: i was agreeing with you
12:44:57 <sinelaw> chrisdone, btw, what did you have in mind when you made that linear types comment on reddit?
12:44:59 <ReinH> chrisdone: ah :)
12:45:36 <sinelaw> I guess I'm biased because the code I'm working on is obsessed with matching things exactly (unification)
12:45:41 <sinelaw> so default zip isn't useful
12:46:15 <ReinH> sinelaw: have you seen the paper on writing a type inferrer in Haskell? It's pretty good.
12:46:16 <chrisdone> sinelaw: don't remember; i didn't exactly understand the problem with mutation as far as your type system goes
12:46:28 <sinelaw> ReinH, algorithm W?
12:46:38 <ReinH> Well, now that I mention it I can't find it.
12:46:50 <sinelaw> http://www.grabmueller.de/martin/www/pub/AlgorithmW.pdf?
12:47:30 <chrisdone> sinelaw: iirc you said in ML you can mutate bindings but not slots of objects, so your type system can express that, but JS can mutate slots of objects
12:47:34 <sinelaw> chrisdone, that stuff is so paged out for me. let me refetch
12:47:36 <ReinH> sinelaw: Typing Haskell in Haskell
12:47:44 <chrisdone> so do you want to support mutating objects or not?
12:47:55 <ReinH> sinelaw: ah! http://web.cecs.pdx.edu/~mpj/thih/TypingHaskellInHaskell.html
12:48:12 <chrisdone> ReinH: github version: https://gist.github.com/chrisdone/0075a16b32bfd4f62b7b
12:48:18 <ReinH> chrisdone: oh yeah :)
12:48:24 <sinelaw> chrisdone, in ML variable bindings are immutable, but a variable can be bound to a Ref which is internally a  record  with a  mutable field
12:48:28 <chrisdone> it's just the same but with syntax highlighting =p
12:48:32 <ReinH> chrisdone: <3
12:48:57 <chrisdone> ah
12:48:57 <sinelaw> ReinH, chrisdone, thanks for the links
12:49:01 <chrisdone> so like IORefs?
12:49:09 <sinelaw> chrisdone, yes
12:49:44 <chrisdone> that sounds the same as JS? all prototypical objects are mutable?
12:49:46 <sinelaw> chrisdone but unlike Haskell, the types don't tell you
12:49:53 <chrisdone> ah
12:49:57 <sinelaw> e.g
12:50:01 <chrisdone> http://1.bp.blogspot.com/-F3ZJmd3DN3Q/T_wxPdpW8zI/AAAAAAAABDc/6vr-pYoYLPE/s320/fexpr.gif
12:50:15 <chrisdone> ^ wanted to use that reaction gif for a while
12:50:35 <sinelaw> lol
12:51:52 <chrisdone> relatedly, i modelled out JavaScript as if everything was monadic and it worked out as a type system for JS, but as a result had no distinction of purity/impurity, so it didn't seem interesting in sharing
12:52:39 <biglama> hi guys
12:53:04 <biglama> from what I've read from the wiki, haskell looks nice for multi-treads parallelism
12:53:06 <vanila> How could I get formal semantics for a subset of javascript?
12:53:07 <chrisdone> f(x,y) -> join (f <$> x <*> y), var x = 1;  -> x <- return 1, etc
12:53:26 <hpc> chrisdone: even without purity, being able to override semicolon would be nice
12:53:32 <biglama> what about distributing computing √† la MPI ? I've only seen hMPI and haskell-MPI, which do not look actively maintained
12:53:42 <biglama> distributed*
12:55:09 <carter> biglama: theres a lot of differnt approaches
12:55:15 <carter> depends on the chunkiness of the workload
12:55:27 <chrisdone> hpc: personally i meant just type-checking javascript by translating it to haskell and running ghc on it
12:55:56 <sinelaw> chrisdone, I was thinking of doing that actually too; for some reason didn't go that way. trying to remember why
12:55:57 <hpc> ah
12:56:06 <ClaudiusMaximus> say i have many C99 functions like   complex double f(complex double z) { return z; }   -- how do i bind to it from Haskell using FFI?  seems there is no Foreign.C.Types(CComplex), and i really wouldn't want to write C wrappers that take pairs of doubles (or pointers to double for the return value)..
12:57:16 <biglama> carter: do you have some practical examples ? Some paper or a conf ?
12:57:25 <carter> biglama: examples of what
12:57:32 <carter> ClaudiusMaximus: sadly struct support in the FFI insn't fully merged into 7.10
12:57:40 <carter> but CMM has support for dealing with structs
12:57:48 <carter> you may have to do that pointer thing in the mean time :)
12:58:30 <biglama> carter: you speak of different approaches for distributed computing with haskell. Do you have more information about that ?
12:58:40 <carter> i meant diferent approaches period
12:58:46 <carter> doesnt matte ron the language
12:58:48 <carter> thats just a details
12:59:16 <sinelaw> chrisdone, do you have that anywhere? or is it gone
13:00:05 <chrisdone> sinelaw: i lost my text file with my ideas in it :(
13:00:08 <biglama> carter: I was wondering if haskell was used in real-world applications for distributed computing
13:00:22 <sinelaw> :[
13:00:45 <sinelaw> Peaker, thanks
13:01:11 <sinelaw> Peaker, the default zip/zipWith should be like that
13:01:17 <sinelaw> IMO
13:01:31 <ClaudiusMaximus> carter: thanks for the info
13:01:49 <carter> ClaudiusMaximus: honestly if you want somethign workign today, do the pointery approach
13:01:51 <ClaudiusMaximus> carter: i might just re-implement in Haskell, most of the functions are small
13:02:59 <ClaudiusMaximus> carter: also the project is a subproject of a larger exercise, and comparing different implementations might be useful
13:03:00 <carter> biglama: sure
13:03:16 <ClaudiusMaximus> dinner time, bbl
13:03:17 <carter> i mean, trivially any web api
13:03:38 <sinelaw> chrisdone, I guess that's related to linear types - because in the Haskell translation every var will have to be assigned only once
13:03:44 <Peaker> sinelaw: but then it'd be hard to get truncating zip
13:03:55 <chrisdone> sinelaw: it seems like modelling all vars with IORefs and function application with monad/applicative style would "just work". but i get the impression you want to distinguish between pure and impure code
13:04:38 <sinelaw> chrisdone, you'd have to do something like single-static-assignment analysis, or translate into code that forces the types to unify (e.g. shoving into an array)
13:04:40 <sinelaw> *list
13:04:43 <biglama> carter: I was thinking of computer cluster, for HPC specifically
13:04:50 <chrisdone> well with monadic style re-assigning a var would be writeIORef, no?
13:04:51 <sinelaw> Peaker, you could have one like that too
13:05:07 <sinelaw> chrisdone, with IORefs yeah
13:05:10 <carter> biglama: ask me in a few months
13:05:16 <carter> i'm sure people are doing that today though
13:05:20 <carter> i'm just not exposed to it
13:05:24 <carter> biglama: what workloads specifically
13:05:26 <Peaker> chrisdone: you know how unsafePerformIO gives you unsafeCoerce?
13:05:44 <chrisdone> Peaker: via FFI?
13:05:49 <Peaker> nope, via IORefs
13:06:00 <chrisdone> oh yeah
13:06:17 <Peaker> newIORef Nothing gives you a polymorphic IORef: forall a. IORef (Maybe a)
13:06:35 <Peaker> you can write Just 5, read a Maybe String out of it
13:07:09 <Peaker> without unsafePerformIO, the >>='s force the type of the IORef to be monomorphic
13:07:16 <chrisdone> sure
13:07:20 <Peaker> so this is why impure languages need a "value restriction"
13:07:25 <fiola> This might be a good time to check if any core Haskell code is still linked to gethostbyname() or gethostbyname2() on GNU platforms, and if so then switch to getaddrinfo() instead --- http://news.slashdot.org/story/15/01/27/1925208/serious-network-function-vulnerability-found-in-glibc
13:07:32 <biglama> carter: here's my only reference at this point : https://wiki.haskell.org/GHC/CloudAndHPCHaskell
13:07:33 <Peaker> (mutable cells must be monomorphized)
13:07:37 <chrisdone> in this case unsafePerformIO doesn't enter the picture
13:07:47 <carter> biglama: CH aint for HPC
13:07:57 <biglama> carter: I was thinking of very extensive computations, around 100 000 hours of CPU time
13:08:01 <carter> umm
13:08:11 <biglama> carter: what will happen in a few months ? :)
13:08:12 <carter> what sychrnoization primitives do you need
13:08:13 <Peaker> another way to think about it is:  A polymorphic value is actually a function from a type.  Polymorphic mutable cells are functions that generate different mutable cells. But you want 1 mutable cell!
13:08:19 <carter> biglama: you're being vague about your workload
13:08:28 <carter> wrt what notino of messaging / concurrency
13:08:33 * chrisdone is confused why he's being told this
13:08:33 <carter> biglama: i think ttuegel  might be able to help you
13:08:39 <vanila> fiola++
13:08:46 <Peaker> chrisdone: oh, you asked sinelaw above
13:08:59 <sinelaw> Peaker, never mind, I'm also listening :)
13:09:00 <Peaker> chrisdone> sinelaw: don't remember; i didn't exactly understand the problem with mutation as far as your type system goes
13:09:05 <biglama> carter: basically, I was wondering if it was possible to replace fortran and MPI by haskell with a MPI-like library
13:09:17 <carter> like an MPI binding?
13:09:18 <carter> idk
13:09:26 <carter> i've not been focusing n that stuff
13:09:26 <biglama> yeah
13:09:31 <Peaker> chrisdone: so that's the problem with mutation and type systems like that :)
13:09:48 <biglama> carter: it's a vague question because I'm just being curious about it :)
13:09:58 <biglama> carter: really ? tell me more
13:10:00 <carter> i'm bad at asnwering vague questions
13:10:07 <chrisdone> type systems like what? ML's?
13:10:11 <carter> i think i refuse to, to manage my time :)
13:10:14 <Peaker> Yeah, HM-style type systems
13:10:26 <biglama> carter: sorry, misread your last sentence :(
13:10:28 <Peaker> which sinelaw implemented for JS
13:10:37 * chrisdone trying to trace back what i asked about in relation to this
13:11:02 <chrisdone> okies
13:11:23 <sinelaw> anyhow, chrisdone I think the monadic binding approach could also work
13:11:39 <chrisdone> sinelaw: anyhoo i was curious whether you want to model JS as a generally imperative language or want some way to say "this code is pure and that's a different type"?
13:11:41 <sinelaw> may be a bit more limiting because you don't have full control of the type checker
13:12:13 <sinelaw> chrisdone, no I didn't distinguish between pure and non-pure, as of yet
13:12:48 <sinelaw> that's an interesting idea to look into
13:12:53 <chrisdone> so is it all pure atm?
13:12:59 <chrisdone> or all impure
13:13:18 <sinelaw> chrisdone, it ignores side effects like ML does
13:13:23 <sinelaw> so you could say it's all impure
13:13:26 <sinelaw> potentially
13:13:33 <chrisdone> ah ok
13:13:43 <sinelaw> actually that's not so true
13:14:07 <sinelaw> because it uses mutation to decide whether it can do generalization (infer polymorphic types)
13:14:14 <Peaker> sinelaw: that's impure still
13:14:22 <Peaker> sinelaw: ML does that too
13:14:24 <sinelaw> Peaker, yeah, but it does glean some info
13:14:29 <sinelaw> not just assume all is impure
13:16:19 <sinelaw> chrisdone, I'm not sure how to model row-type polymorphism in the translation-to-monadic-bind approach
13:16:42 <Peaker> sinelaw: how do the two relate?
13:16:44 <sinelaw> or anonymous objects in general
13:16:50 <fatlazycat> hi, have a very basic haskell project via a nix exp - have used cabal2nix to generate a default.nix and a generic shell.nix yet when I add new packages to the cabal file, regenerate the default.nix the cabal configure inside nix-shell fails to find the packages
13:17:28 <sinelaw> Peaker, chrisdone suggested translating all JS into haskell using monadic binds for ; and  IORefs for mutability
13:17:48 <sinelaw> for type checking, not for running
13:17:56 <Peaker> I understand
13:18:06 <Peaker> I still don't see why rows are a problem with that approach?
13:18:23 <Peaker> btw, it's not really ; which is bind, but all function applications are =<<
13:19:07 <chrisdone> well the way i modelled it was var x = ‚Ä¶  becomes x <- ‚Ä¶ >>= newIORef; and f(x,y) becomes join (f <$> x <*> y)
13:19:12 <chrisdone> or something like that
13:19:17 * hackagebot setdown 0.1.0.1 - Treating files as sets to perform rapid set manipulation.  http://hackage.haskell.org/package/setdown-0.1.0.1 (RobertMassaioli)
13:19:37 <Peaker>  (a->b) is actually (a->IO b)    y = f x   is actually y <- f x      f (g x)  is   f =<< g x
13:20:07 <Peaker> chrisdone: and then you let GHC type-check it?
13:20:17 <chrisdone> something like that
13:20:24 <Peaker> chrisdone: sounds interesting even without the purity distinction!
13:20:25 <benzrf> Peaker: no, f (g x) is f =<< g =<< x
13:20:26 <benzrf> :)
13:20:38 <Peaker> benzrf: why?
13:20:43 <benzrf> er, wait
13:20:47 <benzrf> crap >.<
13:20:52 <benzrf> never mind
13:20:53 <sinelaw> I agree - purity/impurity distinction doesn't seem like a deal breaker
13:21:15 <chrisdone> well, if you were going to run it, the applicative way *seems* more sensible
13:21:36 <chrisdone> iirc, my idea was that every binding would always be f a
13:21:37 <sinelaw> Peaker, so what is: \x -> x.length ?
13:21:46 <Peaker> chrisdone: or maybe use "do" notation with the fancy "Applicative Do" extension :)
13:22:03 <Peaker> sinelaw: function (x) { return x.length; } ?
13:22:07 <sinelaw> yes
13:22:15 <sinelaw> was using shorter notation :)
13:22:15 <Peaker> sinelaw: does "x.length" invoke a function or just return an attribute?
13:22:21 <benzrf> Peaker: depends
13:22:39 <benzrf> Peaker: js supports getters w/ attr notation these days
13:22:44 <sinelaw> Peaker, return an attribute
13:22:56 <Peaker> benzrf: well, it's sinelaw's subset-JS :)
13:23:06 <sinelaw> benzrf, that's fancy futuristic stuff :) j/k, but one problem at a time
13:23:20 <Peaker> sinelaw: then the only place that can have IO effects is the function(x)?
13:23:39 <Peaker> \x -> x.length    is simply    \x -> x.length   :)
13:23:40 <sinelaw> Peaker, you mean reading the attribute?
13:23:57 <sinelaw> Peaker, what's the type?
13:24:00 <chrisdone> wish i had my notes still
13:24:21 <sinelaw> :(
13:24:31 <chrisdone> the problem you have if you want to model it as if you can run it is all arguments to every function should be f a
13:24:33 <Peaker> sinelaw: { length : a, ..more } -> IO a
13:24:35 <athan> Anyone here mess around with propellor? Can't figure out how to connect with a `.pem` :\
13:24:44 <sinelaw> Peaker, haskell doesn't have that
13:25:01 <Peaker> sinelaw: I thought you were asking about monadic-bind modeling, not converting to Haskell?
13:25:14 <sinelaw> Peaker, ok. so yeah, it could work.
13:25:15 <Peaker> sinelaw: though Haskell has it with ugly quasiquoters :)
13:25:25 <Peaker> (well, pretty as they can be, probably)
13:25:26 <sinelaw> the [r| stuff?
13:25:50 <sinelaw> sounds tricky for correct row type variable behavior
13:26:05 <timpani> New to caball. When I try to cabal install my package, I get "cabal: dist/dist-sandbox-37d9d1d3/build/X/X", where X is my package name. Any ideas?
13:26:34 <Peaker> sinelaw: it is probably correct?
13:26:35 <sinelaw> Peaker, anyhow chrisdone's original suggestion was to translate to haskell and typecheck with GHC. scared me a bit because it's so much easier than what I've been doing.
13:26:42 <chrisdone> lol
13:27:01 <Peaker> sinelaw: well, it's the kind of "let's reduce this problem to an already solved <enormous problem here>" :)
13:27:05 <sinelaw> I've been playing with that idea but hadn't fully explored it
13:27:15 <kadoban> timpani: What do you mean you "get" that? Is that an error? Is something apparently wrong with what it did? What? What were you expecting it to do instead?
13:27:29 <sinelaw> but I can't see how row type polyrmophism is dealt with unless you say there's some freaky way to do it in haskell too
13:27:30 <Peaker> having your own type engine is much nicer both pedagogically and you can tailor it to specific needs
13:27:39 <timpani> Correction: cabal says "cabal: dist/dist-sandbox-37d9d1d3/build/X/X: does not exist". (However, dist/dist-sandbox-37d9d1d3/build/X/X-tmp does exist.)
13:27:39 <sinelaw> Peaker, yeah that's a bonus
13:27:44 <timpani> kadoban: ^^
13:27:55 <Peaker> sinelaw: the r| stuff is row type polymorphism
13:28:28 <sinelaw> Peaker, I remember when reading that stuff that there are a few distinctions
13:28:31 <chrisdone> does record require declaring things up front?
13:29:02 <chrisdone> hm, i suppose it doesn't
13:29:06 <sinelaw> I forgot though
13:29:08 <Peaker> instead of {a:b,c:d,..e}  it is:  (HasField r "a" b, HasField r "c" d) => r
13:29:14 <sinelaw> Peaker, another problem is methods
13:29:24 <sinelaw> all that equi-recursive funk
13:29:27 <Peaker> and the QQ stuff is just making the syntax for the above nicer
13:29:36 <Peaker> at least, that's my understanding (I've not looked closely)
13:29:54 <chrisdone> pretty much Hugs's TRex records
13:29:55 <sinelaw> should be => r e
13:30:33 <Peaker> sinelaw: "r" represents the same information as "e" pretty much.. I guess there are things you might be able to do with "e" and not "r", but I think "record" might actually be more sophisticated because it can do them
13:31:55 <sinelaw> Peaker, I wonder if maybe you can do recursive record types?
13:32:12 <sinelaw> HasField r "a" r
13:32:24 <Peaker> sinelaw: btw, equirecursive stuff is what you can do and GHC can't :)
13:32:37 <sinelaw> Peaker, I'd be happy to get rid of that garbage
13:32:50 <Peaker> but you want an equirecursive language?
13:33:17 <sinelaw> what I want is methods in anonymous record types
13:33:25 <chrisdone> i think f(x,g(y,z)) becomes join (f <$> pure x <*> join (g <$> pure y <*> pure z)) or in idiom brackets (| f x (join (| g y z |)) |)
13:33:26 <sinelaw> "want"
13:33:27 <sinelaw> need
13:33:34 <chrisdone> good olde idiom brackets
13:33:51 <EvanR> @src asAppliedTo
13:33:51 <lambdabot> Source not found. Do you think like you type?
13:34:03 <chrisdone> sinelaw: Peaker: did you see Frank? *gushes*
13:34:05 <EvanR> how can i get asAppliedTo in my ghci
13:34:11 <exio4> const :: (a -> b) -> a -> (a -> b)?
13:34:14 <exio4> @type asAppliedto
13:34:15 <lambdabot>     Not in scope: ‚ÄòasAppliedto‚Äô
13:34:15 <lambdabot>     Perhaps you meant ‚ÄòasAppliedTo‚Äô (line 184)
13:34:17 * hackagebot amqp 0.11 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.11 (HolgerReinhardt)
13:34:19 <exio4> @type asAppliedTo
13:34:20 <lambdabot> (a -> b) -> a -> a -> b
13:34:22 <sinelaw> chrisdone Frank?
13:34:24 <EvanR> ok
13:34:52 <chrisdone> conor mcbride's language where everything is implicitly monadic (pretty much)
13:34:55 <hexagoxel> timpani: yeah that seems wrong. what cabal version(s)? have you tried to clean? what is the full output with -v?
13:35:19 <chrisdone> http://homepages.inf.ed.ac.uk/slindley/papers/frankly-draft-march2014.pdf
13:35:48 <chrisdone> ‚ÄúSequencing Computations We write let x = e in e‚Ä≤ as syntactic sugar for bind e {x ‚Ü¶ e‚Ä≤}‚Äù
13:36:03 <sinelaw> "Shall we be pure or impure?
13:36:03 <sinelaw> Frank
13:36:03 <sinelaw> is a strongly typed functional programming language an-
13:36:03 <sinelaw> swering this question ëYes.í"
13:36:20 <chrisdone> but bind's type is:
13:36:20 <chrisdone> bind : X -> {X -> Y} -> Y
13:36:20 <chrisdone> bind x f = f x
13:36:24 <vanila> You checked out eff?
13:36:44 <vanila> http://math.andrej.com/eff/ good stuff in this same space
13:36:50 <timpani> hexagoxel: thanks for answering. cabal-install is 1.18.0.5, and cabal library version is 1.18.1.3. Btw, I'm doing everything in a sandbox. I'll look up how to clean and then I'll rerun with -v.
13:36:57 <sinelaw> yeah I've seen eff
13:37:05 <chrisdone> yeah this stuff is super promising
13:37:15 <vanila> ah better link http://www.eff-lang.org/
13:37:16 <chrisdone> monads are awesome but one does tend to pay a syntactic price for their use
13:37:26 <chrisdone> among other prices
13:37:37 <vanila> its also interesting because you don't have to buid monad stacks
13:37:52 <vanila> you just compose effects how you like
13:37:53 <chrisdone> right
13:38:04 <chrisdone> that's one of the prices of monads for me
13:38:18 <Peaker> sinelaw: you don't need the implicit equirecursive "this" too?
13:38:22 <chrisdone> this is just like "write your normal code and the context will be explicit"
13:38:23 <Peaker> sinelaw: besides row types?
13:38:40 <chrisdone> he's implemented `this' awareness
13:38:44 <sinelaw> Peaker, you can do it at translation time
13:39:03 <Peaker> sinelaw: converting equirecursive to isorecursive sounds like it should be as hard as implementing equirecursive directly
13:39:27 <sinelaw> conor's Frank manual is very amusing
13:39:50 <jml> in Cabal, I'm trying to have a thin executable on top of a library. I'd like the executable to just depend on the library. However, when I build, I'm getting errors as if cabal expects me to have listed all of the library's dependencies.
13:39:59 <sinelaw> "Unfortunately, Frank is written making heavy use of the Strathclyde Haskell Enhancement, so you may find that cabal infects your computer with it, whether you like it or not"
13:40:28 <jml> the cabal doc example (https://www.haskell.org/cabal/users-guide/developing-packages.html#configurations) conveniently has both depend on base & nothing else
13:40:38 <sinelaw> Peaker, you still haven't convinced my that it's necessarily equirecursive
13:41:06 <sdegutis> In my non-Haskell lib, I was using a destructor/finalize method to get rid of a resource automatically when the variable went out of scope. Can this be emulated somehow in Haskell?
13:41:26 <sinelaw> I'm pretty sure it is, but maybe there's a way to encode it as an iso-recursive problem
13:41:39 <sdegutis> I know it's not a good practice in general, but in that language (Swift), deinit happens immediately when the variable is done with, thanks to ARC.
13:41:43 <sinelaw> sdegutis, take a look at ResourceT package
13:41:47 <sdegutis> sinelaw: hmmmmmmm... what?
13:41:51 <sdegutis> sinelaw: ok thanks
13:42:35 <vanila> why did apple have to invent swift, why couldn't they just implement an existing language?
13:42:50 <chrisdone> because the writers were very smart people with who better
13:42:52 <EvanR> NIH
13:43:10 <sdegutis> vanila: vendor lock-in
13:43:23 <sdegutis> It's a legitimate business practice when money is your main goal.
13:43:31 <sinelaw> also, because they can
13:43:42 <sdegutis> That's not a reason though.
13:43:43 <EvanR> sdegutis: unless people are too smart to fall for it, ... which they arent
13:43:44 <vanila> vendor lock in is evil!
13:43:50 <chrisdone> it is partly a reason
13:44:01 <vanila> thanks for the insights!
13:44:04 <sdegutis> EvanR: it's the most pain-free path to writing an iOS app sooooo
13:44:12 <EvanR> it is?
13:44:17 <sdegutis> vanila: I dunno about evil, but definitely inconvenient
13:44:18 * hackagebot stratum-tool 0.0.4 - Client for Stratum protocol  http://hackage.haskell.org/package/stratum-tool-0.0.4 (JoelLehtonen)
13:44:19 <sinelaw> would have been much nicer if they decided to contribute to Rust instead
13:44:23 <sdegutis> EvanR: Swift? Yeah sure.
13:44:31 <sdegutis> Dang look what I started.
13:44:36 <sdegutis> Hey guys Haskell is awesome.
13:44:37 * sinelaw ducks
13:44:42 <chrisdone> i think the reason microsoft are open sourcing the .NET platform and compiler now is "because they can't" get away with bullying people with their vendor lock-in platform
13:44:52 <vanila> rust seems kind of a trainwreck though...
13:44:57 <chrisdone> not because somehow all the managers did a 180¬∞ on how they perceive business
13:45:18 <sdegutis> chrisdone: nah that's just a technique for making vendor lockin seem like its not vendor lockin
13:45:41 <sinelaw> chrisdone, not sure what's going on inside, but I'm guessing that also developer culture has somehow moved up to higher ranks too
13:45:43 <sdegutis> chrisdone: but anyone who uses .NET and C# is still really tied to MS for all practical purposes
13:46:10 <_2_Sydandnikki> Hey what's up
13:46:34 <EvanR> the bot getem
13:46:42 <_2_Sydandnikki> hi
13:46:56 <sinelaw> chrisdone so in summary, i'm not sure how row-type polymorphism and methods (recursive implicit row types) would be implemented in the translate-to-haskell approach
13:47:12 <chrisdone> right. so when you've gone from 90% market share to 20% market share and you're not the big boys on the block anymore there're products that you can't bully people with and they become less important, and someone decides "might as well open source it and foster good will"
13:47:21 <Black0range> How to do i set the setSocketOption: RecvTimeOut in haskell?!
13:47:28 <chrisdone> comparatively, Apple will not be open sourcing anything for years to come because they're the new big boys
13:47:57 <sdegutis> Besides, Swift is Good Enough‚Ñ¢.
13:48:14 <koala_man> what do you think about swift?
13:48:17 <sdegutis> The majority of programmers writing iOS apps don't care about code quality, they just wanna get the thing written.
13:48:36 <sdegutis> I think it's nice, much nicer than ObjC, and I'd use it if I had to write an iOS app. But it's vastly inferior to Haskell.
13:48:44 <Peaker> sinelaw: if only "this" is ever recursive, then maybe you can make it isorecursive by de-sugaring "this" to unpack a "this newtype"
13:48:44 <sdegutis> I've used it already to write a window manager for OS X.
13:48:47 <EvanR> Black0range: if you really want to timeout on recv, use System.Timeout
13:48:48 <chrisdone> sinelaw: me neither
13:48:51 <sinelaw> but it may be interesting to change the type checker to internally use the monadic binding stuff instead of dealing with mutability directly as it does now
13:49:02 <_2_Sydandnikki> how are you
13:49:14 <sinelaw> Peaker, that's what I'm thinking too. not sure it would work
13:49:16 <EvanR> Black0range: but if you were to service a socket using a dedicated forkIO thread, you usually dont have to do that
13:49:18 <sinelaw> _2_Sydandnikki, hello.
13:49:25 <timpani> hexagoxel (or anyone else): cabal install does compile my Main.hs to Main.hi and Main.o, which reside in dist/dist-sandbox-BLAH/X/X-tmp (X is the package name), but not executable is there, and besides, cabal is looking for it in X/X rather than X/X-tmp. Any help would be appreciated by this cabal newbie...
13:50:03 <sinelaw> timpani, paste your cabal on lpaste?
13:50:20 <_2_Sydandnikki> sinelaw how r u
13:50:32 <sinelaw> _2_Sydandnikki, hungry
13:50:46 <lifter> timpani: what OS?
13:50:50 <_2_Sydandnikki> sinelaw haha nice
13:50:56 <hexagoxel> jml: and you have googled for keywords such as "cabal library executable build-depends" ? :)
13:51:20 <osa1> is there a way to figure version number a lib when all I have is this file: libHScrite_3YOMXXEfTps0ddIAUWSJlp-ghc7.11.20150122.so ?
13:51:27 <timpani> lifter: Yosemite (Mac OS 10.10.1)
13:51:39 <osa1> I also have .hi files
13:52:19 <benmachine> osa1: try ghc --show-iface blah.hi
13:52:28 <benmachine> I don't know whether or not that will work
13:52:33 <benmachine> but you'll get /something/ interesting
13:53:25 <Black0range> EvanR: what do you mean by "not have to do that" ?
13:53:45 <lifter> timpani: try "which executableName", is it anywhere in your path?
13:53:55 <qnikst> is it possible to set -XSafe for a module if -XTrustworthy is set as default-extension?
13:54:04 <EvanR> Black0range: for many cases where youd need non blocking or timingout sockets in other languages you can use haskells green thread runtime and concurrency to do it easier
13:55:23 <EvanR> Black0range: alternatively there might be a socket option for that in the low level socket module in the network package
13:55:49 <Black0range> EvanR: tried the low level socket module but i keep getting a "test: setSocketOption: invalid argument (Invalid argument)"
13:55:58 <EvanR> lpaste your code
13:56:29 <EvanR> and coming back full circle, you can time out almost any IO action you want with System.Timeout
13:56:38 <timpani> lifter: the executable is not on my path. But should we really expect that in a sandbox?
13:57:11 <Black0range> EvanR: uhm the actuall row of code is: setSocketOption sock RecvTimeOut (readTimeout settings)
13:57:21 <dmj`> d
13:57:22 <Black0range> (readTimeout settings) :: Int
13:57:39 <lifter> timpani: perhaps not, but you did "cabal install"; personally I do "cabal build" when I want to build an executable, in which case the executable can be found under the "dist" directory somewhere
13:57:39 <EvanR> Black0range: so sock may not be a valid socket
13:58:04 <Black0range> EvanR: i am sure it is a valid socket.. Everything works fine execpt when i attempt to do this
13:58:31 <EvanR> Black0range: well, try this
13:58:37 <EvanR> :t System.Timeout.timeout
13:58:38 <lambdabot> Int -> IO a -> IO (Maybe a)
13:59:59 <jml> hexagoxel: you raise an excellent point
14:00:42 <Black0range> EvanR: I dont think that solves my problem :/ this is all for a httpserver The timout could occur almost everywhere. So the timout need to be updated as soon as i get more data. Or write more data.
14:00:51 <EvanR> what?
14:01:13 <EvanR> you should use forkIO threads probably
14:01:31 <lifter> FWIW, STM is beauty
14:02:09 <sinelaw> Peaker, allowing arbitrary object properties to be generalized leads to mutability bugs
14:02:12 <EvanR> Black0range: if by timeout you mean, interrupts some reader or writer, then thats not a timeout
14:02:46 <Black0range> Hmm what is that then?
14:02:58 <EvanR> in haskell its an async exception
14:04:21 <EvanR> make a thread for the socket you are recving on, and something else can throw an exception at it to stop it
14:05:00 <EvanR> but if you want to stop it, closing the socket is probably a better bet
14:05:25 <Black0range> What i want to achieve is "if nothing has happend of x seconds kill the socket"
14:05:36 <EvanR> then use System.Timeout.timeout?
14:05:41 <Black0range> "if something happend wait another x secons to see if something happend"
14:06:27 <EvanR> wrap each recv in a timeout
14:06:52 <Black0range> Also i need to be able to update the timeout at will :/
14:07:04 <Black0range> without breaking everything
14:07:07 <EvanR> how would you have done that with a socket option?
14:07:29 <timpani> lifter: I ran 'cabal clean' then 'cabal build', but the executable is still not in the dist directory, unfortunately.
14:07:30 <juanpablo_> Anyone knows if there's a way to get a conduit to consume all available values in the stream?
14:07:38 <juanpablo_> jvilla: ^^^
14:07:55 <Black0range>   EvanR : setSocketOption sock SendTimeOut newValueHere
14:08:02 <juanpablo_> Just that one conduit, the next conduit should keep going as normal
14:08:05 <EvanR> you think that just works ?
14:08:58 <EvanR> Black0range: it really sounds like you want just a concurrent program that is doing things concurrently, not a arbitrarily updating timeout on a socket
14:09:24 <EvanR> threads in haskell are not crazy like pthreads
14:10:44 <Peaker> EvanR: "crazy" in what sense?
14:10:50 <Peaker> sinelaw: not sure why this relates to rows vs explicit records?
14:11:20 <Peaker> Black0range: I have a vague recollection of that doing nothing if some global option is set in some way
14:11:23 <Peaker> Black0range: (system-wide)
14:11:38 <Peaker> Black0range: or perhaps having the globally-allowed timeout range in the range of many hours or such
14:11:59 <_2_cool> hello
14:13:11 <EvanR> its possible to set up an updatable alarm thread which emits a timeout signal, and can be poked to reset, but you might as well rethink all of it if you now have threads
14:13:54 <Black0range> i do have threads...
14:13:55 <EvanR> cuz that sounds complicated
14:14:02 <_2_cool> dude SHUT UP
14:14:22 <vanila> @here ops
14:14:22 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:14:24 <Black0range> https://github.com/black0range/Schmutt
14:14:35 --- mode: ChanServ set +o johnw
14:14:36 --- mode: johnw set +b *!~34110025@104.240.236.254
14:14:36 --- kick: _2_cool was kicked by johnw (Kicked)
14:14:36 --- mode: johnw set -o johnw
14:14:39 <Black0range> theres my little hobby project
14:14:42 <vanila> thank you johnw
14:14:44 <ReinH> vanila: beat me to it
14:15:26 <geekosaur> it's that bot again...
14:16:01 <vanila> era you sure its a bot?
14:16:43 <lifter> timpani: that's odd, did you paste your cabal file?
14:16:45 <EvanR> earlier it was _2_Sydandnikki
14:16:46 <geekosaur> vanila: yesterday it was going by _1_alexfootball
14:17:03 <vanila> hmm
14:17:06 <vanila> so weird!
14:17:16 <geekosaur> * [_2_cool] (~34110025@104.240.236.254): PircBot 1.5.0 Java IRC Bot - www.jibble.org
14:17:39 <shapr> geekosaur: that explains something
14:19:10 <sinelaw> Peaker, i was talking about the discussion we had about how to implement poylrmorphic row fields
14:19:31 <timpani> lifter: thanks, but I found the problem: cabal wants my Main module to sit at the root of my src dir (which makes me wonder why it asks for 'main-is' in the first place).
14:19:33 <Peaker> sinelaw: ah, too big a context switch :)
14:20:07 <Black0range> There threaly has to be an error in Network.Sockets... It's not supposed to work in this way
14:20:17 <Black0range> realy* not threaly
14:22:12 <hexagoxel> timpani: i think if you main-is Foo.Bar, you can (and have to) put it in Foo/Bar.hs
14:22:30 <mpickering> does s -> (s, m a) form a monad?
14:23:13 <johnw> sure
14:23:38 <vanila> @unmtl StateT s m a
14:23:38 <lambdabot> s -> m (a, s)
14:23:39 <johnw> oh, wait, let me think more
14:23:48 <geekosaur> it's a State monad with an a that happens to be monadic
14:23:49 <vanila> hm it's different to StateT
14:23:51 <lifter> timpani: Glad you found the issue.
14:23:53 <geekosaur> I think
14:23:57 <geekosaur> hm, no, backwards
14:24:32 <Peaker> no, it doesn't form a monad
14:24:48 <benzrf> Peaker: no?
14:25:22 <geekosaur> the tuple's the wrong way around to be State
14:25:32 <benzrf> s -> (m (s -> (m a, s)), s) -> s -> (m a, s)
14:25:42 <Peaker> It's   State s (m a)   equivalent to  (State s `TypeCompose` m) a,  and type-composing monads often doesn't form monads, that's why StateT cannot reuse State
14:26:11 <benzrf> i think that works tho
14:26:17 <Peaker> s -> (s, m a)   <-- this does not allow the "m" effects to determine the new state
14:26:33 <benzrf> Peaker: but does that prevent it from being a monad
14:26:39 <sinelaw> it can still be a monad
14:26:45 <sinelaw> just not a composition
14:27:30 <benzrf> :t \f s -> let (m, s') = f s; m' = fmap ($s') m in m'
14:27:31 <lambdabot> Functor f => (t -> (f (a -> b), a)) -> t -> f b
14:27:50 <benzrf> hmm
14:27:53 <benzrf> oh wait i see
14:27:57 <benzrf> Peaker: yes you are right >.<
14:28:07 <Black0range> EvanR: oh there is a package named  network-socket-options that fixes the problem
14:28:14 <benzrf> Peaker: i am lain low
14:31:40 <Peaker> sinelaw: you can't get the "a" out of the "m"
14:31:56 <Peaker> sinelaw: you'd want to bind it with the "m" from the right-hand arg to bind
14:32:45 <Peaker> hmm.. sec, let me sharpen my reasoning here :)
14:33:17 <sinelaw> Peaker, can't you consider "m a" to be an opaque value?
14:33:27 <sinelaw> s -> (s, b)
14:33:36 <sinelaw> is that a monad parameterized on b?
14:33:39 <Peaker> no, (>>=) :: (s -> (s, m a)) -> (*a* -> ...) -> ...
14:34:46 <sinelaw> m' s b = (s -> (s, b))
14:34:57 <Peaker> I guess the question isn't well formed. Type constructors can be monads, but we were given a specific type: (s -> (s, m a)) so naturally I concluded the "a" would be a type-var in the resulting type and the only possible one to make us a type-constructor
14:35:00 <sinelaw> so: m' s is a monad, we can pick b = (m a)
14:35:37 <sinelaw> Peaker, ok then
14:35:46 <sinelaw> It's not a monad on a
14:35:51 <sinelaw> but it IS a monad on m a
14:36:32 <johnw> well, I can prove that s -> (s, m a) is a Functor easily enough, if m is a Functor
14:36:39 <sinelaw> "BUT IS IT A MONAD?!"
14:36:41 <johnw> i'm pretty sure that if m is a Monad, it is also a monad
14:36:55 <johnw> and a Monad on the a
14:37:00 <johnw> StateLike s m a
14:37:32 <sinelaw> johnw, (>>=) = ?
14:37:40 <johnw> one sec
14:37:46 <Peaker> johnw: it is a Functor and Applicative because those compose.. so  State s `TypeCompose` AnyApplicative is an applicative
14:38:04 <vanila> that's a nice proof Peaker
14:38:16 <Peaker> Monads, however, do not compose.. So it shouldn't be a monad (I think)
14:38:25 <sinelaw> it still could
14:38:29 <johnw> some Monads do compose
14:38:40 <Peaker> johnw: the existence of StateT strongly suggests State doesn't :)
14:38:49 <Peaker> (as more than a wrapper around State, at least)
14:39:11 <sinelaw> circumstantial evidence ;)
14:39:18 <EvanR> so the question is, can you write a valid monad instance for that type
14:39:44 <johnw> I'm getting there
14:40:34 <sinelaw> @djinn (s -> (s, m a)) -> (a -> (s -> (s, m b))) -> (s -> (s, m b))
14:40:37 <genisage> are we allowed to use bottom as s to get an m a out of (\s -> (s, m a))?
14:40:53 <sinelaw> wtf
14:40:54 <sinelaw> @djinn (s -> (s, m a)) -> (a -> (s -> (s, m b))) -> (s -> (s, m b))
14:41:14 <sinelaw> weird.
14:41:16 <sinelaw> @djinn (s -> (s, m a)) -> (a -> (s -> (s, m b))) -> (s -> (s, m b))
14:41:16 <sinelaw> <lambdabot> -- f cannot be realized.
14:41:26 <sinelaw> worked in a pm
14:41:38 <lambdabot> -- f cannot be realized.
14:41:38 <lambdabot> -- f cannot be realized.
14:41:38 <vanila> djinn cannot do monads
14:41:38 <vanila> try Maybe instead of m?
14:41:38 <lambdabot> -- f cannot be realized.
14:41:47 <bananagram> you might have to add a constraint to m
14:41:54 <Peaker> it *might* be a Monad, it *definitely* isn't both Monad and MonadTrans
14:41:54 <prophile> lambdabot is just slow apparently
14:41:58 <sinelaw> oh right
14:42:09 <sinelaw> it doesn't know what it can do with m
14:42:10 <vanila> @djinn a -> m a
14:42:10 <lambdabot> -- f cannot be realized.
14:42:30 <sinelaw> @djinn (s -> (s, Maybe a)) -> (a -> (s -> (s, Maybe b))) -> (s -> (s, Maybe b))
14:42:30 <lambdabot> f a b c =
14:42:31 <lambdabot>     case a c of
14:42:31 <lambdabot>     (d, e) -> case e of
14:42:31 <lambdabot>               Nothing -> (d, Nothing)
14:42:31 <lambdabot>               Just f -> b f d
14:43:09 <johnw> no, it cannot be a Monad
14:43:26 <SrPx> is there any function such that "func 3 f x = f (f (f x)))" and so on?
14:43:31 <SrPx> on prelude*
14:43:44 <johnw> given StateLike s m (StateLike s m a), you can get to m (StateLike s m a), but once you use fmap to "collapse" the StateLike inside, you can't get the "next" state out in order to merge it with the first collapse
14:43:53 <mpickering> the problem is that you can't get the next state out of the m
14:43:55 <genisage> SrPx: you can use iterate and (!!)
14:43:56 <mpickering> ^
14:43:59 <Peaker> yep, not a Monad, same conclusion here, trying to implement it
14:44:22 <johnw> it's also an Applicative, which works because the state "stays inside"
14:44:23 <rasen> @hoogle Int -> (a -> a) -> a -> a
14:44:24 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
14:44:24 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
14:44:25 <lambdabot> Data.IntMap.Strict adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
14:44:30 <SrPx> genisage: just for the records, is that optimized not to create the list?
14:44:36 <mpickering> I'm trying to rewrite some code with return . return everywhere btw
14:44:36 <kranius> @type iterate
14:44:37 <lambdabot> (a -> a) -> a -> [a]
14:44:52 <Peaker> you depend on the prev s AND "m" effect to compute the "a". Then when you have an "a", you can get an "s" but you're inside an "m" context, but the "s" must somehow be elavated outside that context (impossible!)
14:45:18 <genisage> SrPx: I expect so, but I'm not sure
14:45:25 <Peaker> johnw: it's an Applicative because all applicative-compositions are
14:45:32 <mpickering> Peaker: But for some types, such as Maybe, it does work
14:45:51 <johnw> if you know the concrete type, sure
14:45:54 <Peaker> johnw: as we talked yesterday, any class that returns stuff "wrapped" can be lifted inside an Applicative, and that includes Applicative itself! :)
14:45:56 <johnw> and it has an "extractor"
14:46:07 <Peaker> johnw: even on abstract types
14:46:07 <osa1> any ideas what does that mean: "ghc-pkg: cannot create: dist/dist-sandbox-fb92fbbb/package.conf.inplace already exists"
14:46:14 <osa1> this is happening when I run cabal install
14:46:22 <glguy> Srpx, it creates a list and consumes it, but it briefly exists
14:46:25 <johnw> I was referring to mpickering
14:47:36 <Peaker> johnw: http://hackage.haskell.org/package/TypeCompose-0.9.10/docs/src/Control-Compose.html#line-330
14:47:40 <Peaker> ah
14:47:51 <johnw> Peaker: I've proven that they compose before ;)
14:48:08 <mpickering> hmm
14:49:07 <mpickering> I think for my problem I need to use the reverse state monad
14:49:13 <mpickering> this should be interesting
14:50:10 <SrPx> okay it is the same thing http://lpaste.net/119351
14:50:11 <SrPx> ty
14:50:36 <SrPx> woops
14:50:40 <johnw> mpickering: join x = \st -> let (st', x') = x in (?, x' >>= \y -> let (st'', y') = y st' in y') -- st'' can't get back out to go into the ?
14:53:49 <rasen> SrPx: you're benchmarking the same function twice (in case you didn't notice)
14:58:12 <hexagoxel> osa1: it means cabal is buggy. and a simple clean fixes it
14:58:33 <osa1> clean doesn't fix it in my case. I saw the bug report and I was wondering if the patch passes the tests
14:58:46 <osa1> because I'll manually merge it and use new version if it's working
14:58:56 <SrPx> rasen: yea I noticed :P but the results are indeed the same, I updated the paste
15:00:19 <hexagoxel> osa1: so your _real_ question is if the bug is fixed at head? :S
15:01:58 <osa1> hexagoxel: it's not since the patch in the issue report is not merged, I'm just wondering if the patch works because I'm going to apply that myself and build cabal. it's a bit urgent.
15:02:03 <osa1> I can deterministically get same error
15:02:06 <osa1> clean etc. doesn't fix in my case
15:04:21 * hackagebot clafer 0.3.8 - clafer compiles Clafer models to other formats, such as Alloy, XML, HTML, Dot.  http://hackage.haskell.org/package/clafer-0.3.8 (mantkiew)
15:04:24 * hackagebot claferIG 0.3.8 - claferIG is an interactive tool that generates instances of Clafer models.  http://hackage.haskell.org/package/claferIG-0.3.8 (mantkiew)
15:04:25 * hackagebot claferwiki 0.3.8 - A wiki-based IDE for literate modeling with Clafer  http://hackage.haskell.org/package/claferwiki-0.3.8 (mantkiew)
15:06:07 <rasen> hackagebot announces new packages?
15:06:18 <geekosaur> and updates, yes
15:26:43 <Welkin> this is funny
15:27:09 <Welkin> my O(n^2) algorithm runs twice as fast as my O(n) one
15:27:34 <Welkin> it seems like hashmaps/hashsets are slow
15:27:44 <Welkin> perhaps the hashing function itself is slowing it down
15:28:16 <rasen> How big n is?
15:28:35 <Welkin> 1 million
15:29:51 <Welkin> yes, the binary tree version of Set and Map perform better than the Hash variants
15:29:52 <MrFlibble> hashing is O(1) if you are doing it right
15:30:02 <Welkin> MrFlibble: I am not doing the hashing
15:30:07 <Welkin> I am using Data.HashSet
15:30:24 <EvanR> calculating the hash of a string is O(1) ?
15:30:25 <Welkin> Data.Set is performing faster than Data.HashSet
15:30:44 <Welkin> and not using either is even faster
15:31:08 <Welkin> my example is removing duplicates from a string
15:31:12 <MrFlibble> no, looking up a value in a hash table is O(1) on average
15:31:22 <MrFlibble> binary tree (set) is O(lg N)
15:31:26 <EvanR> on a finitely sized hash table
15:31:30 <Welkin> a naive n^2 solution is faster than using either Set or HashSet
15:32:13 <EvanR> are you sure you dont have all those backwards?
15:32:41 <Welkin> I just tested them in ghci
15:33:15 <EvanR> whats the naive n^2 algorithm
15:34:04 <Welkin> take the head of the list and compare to the rest
15:34:20 <EvanR> of 1 million things?
15:34:23 * hackagebot descriptive 0.5.0 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.5.0 (ChrisDone)
15:34:24 <Welkin> yes
15:34:31 <EvanR> oO
15:34:42 <Welkin> 1 million Char
15:35:09 <chrisdone> ReinH: ^ switched to StateT. consumer's now monadic :3
15:35:20 <athan> :O
15:35:22 <c_wraith> Welkin: if you're using nub, it's actually O(length of string * number of distinct characters)
15:35:37 <Welkin> naive solution takes 0.36 secs; Set version takes 0.47 secs; HashSet version takes 0.51 secs
15:35:48 <EvanR> yeah i was wondering if you write it yourself or used nub
15:35:58 <c_wraith> Welkin: it's often assumed that number of distinct characters is related to length - but if the string has length 1 million, that's no longer true.
15:36:07 <chrisdone> athan: ( Õ°¬∞ Õú ñ Õ°¬∞)
15:36:13 <Welkin> c_wraith: I wrote my own version of nub
15:36:29 <c_wraith> Welkin: if it's using the same algorith, it has the same properties
15:36:48 <EvanR> @src nub
15:36:48 <lambdabot> nub = nubBy (==)
15:37:06 <c_wraith> @src nubBy
15:37:06 <lambdabot> nubBy eq []     = []
15:37:06 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
15:37:38 <c_wraith> The important part is that it filters the rest of the list on each unique element.
15:37:39 <EvanR> hows that faster than n^2? lazyness?
15:37:44 <chrisdone> O(n¬≤)?
15:38:04 <Welkin> okay
15:38:07 <c_wraith> EvanR: it only recurses on the result of the filtering.
15:38:15 <EvanR> oh
15:38:25 <Welkin> it is significantly slower with 10,000 unique elements for a list of 1 million
15:38:38 <EvanR> that is really cool
15:38:38 <Welkin> that makes sense
15:38:46 <chrisdone> for the 10000th step it'll have to do 10000 comparisons
15:39:04 <chrisdone> 10k nested calls to `filter'
15:39:13 <Welkin> the accumulator can not be large than 10,000 in this case
15:39:23 * hackagebot structured-haskell-mode 1.0.12 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.12 (ChrisDone)
15:39:25 * hackagebot lucid-svg 0.4 - DSL for SVG using lucid for HTML  http://hackage.haskell.org/package/lucid-svg-0.4 (jeffreyrosenbluth)
15:39:32 <Welkin> for ascii, it would be 256
15:39:55 <Welkin> okay
15:40:04 <Welkin> new results for 10,000 uniques, 1 million total
15:40:07 <EvanR> normal stuff is accidentally high performance ;)
15:40:11 <Welkin> 79 secs for nub
15:40:17 <Welkin> 5 secs for Set
15:40:37 <Welkin> 5 secs for HashSet
15:40:44 <haasn> naive list functions tend to outperform the constant overhead of Set etc. massively at small-ish sizes
15:40:46 <haasn> But they don't scale
15:40:58 <haasn> (That's what you get for abstracting time complexity)
15:41:00 <Welkin> it seems like for proactical usage, Set is as fast as HashSet, and in some cases faster
15:41:09 <chrisdone> a Judy array might be faster
15:41:25 <chrisdone> if your key is convertible to a Word without collisions
15:41:26 <EvanR> Set is easier to type
15:41:31 <chrisdone> http://hackage.haskell.org/package/judy-0.2.3/docs/Data-Judy.html
15:42:02 <c_wraith> chrisdone: for a set.. there is no key. :)
15:42:16 <chrisdone> well, the element itself is the key
15:42:17 <c_wraith> chrisdone: err, value.  ok, I see the problem
15:42:34 <c_wraith> chrisdone: I got ahead of myself, since Judy's keys also have to be Word-sized
15:42:45 <c_wraith> err, vals.  I'm not doing too well here.
15:42:52 <Welkin> are there any cases where a HashSet or HashMap would be used instead of Set or Map?
15:42:55 <chrisdone> just throwing it out there, as an impure imperative structure. one's going for peak performance
15:43:05 <chrisdone> (if one's*)
15:43:05 <Welkin> besides the obvious requirement of being Hashable vs Ord
15:43:22 <chrisdone> oh there's also the hashtables package too
15:43:22 <MrFlibble> use set if you want order
15:43:28 <chrisdone> which has the cuckoo algorithm among others
15:43:41 <chrisdone> http://hackage.haskell.org/package/hashtables-1.2.0.2/docs/Data-HashTable-ST-Cuckoo.html
15:44:08 <chrisdone> again, just throwing it out there, if you're interesting in comparing
15:44:14 <Welkin> Judy arrays sounds interesting, thanks
15:44:22 <Peaker> I wrote a small hash table in C with Haskell bindings and it outperformed everything else by far
15:44:23 * hackagebot hindent 4.3.2 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.3.2 (ChrisDone)
15:44:28 <chrisdone> i'd love for someone to write a small online book comparing all the haskell data structures
15:44:28 <Welkin> as does HashTable
15:44:56 <chrisdone> Peaker: what was your algorithm?
15:45:17 <Peaker> chrisdone: I think it was specific for (Int->)
15:45:28 <Peaker> and my hash function was something silly like (%size) iirc
15:45:45 <Peaker> and I benchmarked it against IntMap, Judy, and hashtables
15:45:55 <Peaker> and/or unordered-containers, I don't recall
15:46:14 <MrFlibble> Haskell is slooooow
15:46:17 <Peaker> it was a response to jdh trolling about how Haskell sucks at (Int->) mappings
15:46:23 <Welkin> as I recall, the cuckoo hasing method has poor cache performance
15:46:28 <Peaker> he was right, but he exaggerated his claim to the point of lying
15:46:40 <Peaker> and then I sent a patch to GHC, and after that, Haskell beat his F# one :)
15:46:51 <c_wraith> Peaker: that sounds like it would work best on random data..  not particularly collision-resistant
15:47:05 <Peaker> chrisdone: https://github.com/Peaker/small_hash/blob/master/small_hash.c is the hash table
15:47:20 <Peaker> c_wraith: yeah, but the hash function is an easy-to-change detail
15:47:34 <chrisdone> i suppose that makes sense
15:47:57 <chrisdone> the hashtable cuckoo one is implemented in haskell itself which presumably has overhead compared to c
15:48:00 <EvanR> wouldnt the hash function make a difference to the constant factor
15:48:12 <Peaker> EvanR: for simple Int keys? Probably not much
15:48:34 <EvanR> well mod vs a hash function.. like using a few instructions
15:48:41 <Peaker> modulu takes lower bits. you just need to also take the few higher bits not taken into account
15:49:01 <EvanR> some xN difference
15:49:21 <Peaker> possible xoring the low part and high part before modulu should be enough (assuming half the bits are used)?
15:49:23 * hackagebot deepseq-bounded 0.6.0.2 - Bounded deepseq, including support for generic deriving  http://hackage.haskell.org/package/deepseq-bounded-0.6.0.2 (AndrewSeniuk)
15:50:42 <Fuuzetsu> is there something like fromMaybe but for Either (fromLeft and fromRight)?
15:50:53 <EvanR> :t either
15:50:54 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
15:51:25 <Fuuzetsu> right, looking for a thing which doesn't require me to const the default
15:51:36 <Fuuzetsu> if there isn't one then that's fine, I'll just use either
15:52:13 <EvanR> there should be
15:52:39 <c_wraith> :t either . const
15:52:40 <lambdabot> c -> (b -> c) -> Either a b -> c
15:54:08 <chrisdone> Fuuzetsu: in the either package there is
15:54:17 <chrisdone> http://hackage.haskell.org/package/either-4.3.3/docs/Data-Either-Combinators.html#v:fromLeft
15:55:05 <athan> Something weird keeps happening with my warp web server & upstart - for some reason it's resetting the connection for some routes (I think it depends on the response body size), but only if upstart started the process, and not if I did from a shell or something. ?:|
15:56:55 <johnw> athan: you need more data, I'd say
15:57:13 <athan> :c
15:57:25 <athan> johnw: I dunno how to catch it
15:57:37 <johnw> yeah, sounds like a toughie
15:57:44 <athan> hrm
15:57:50 <athan> To wireshark!
15:57:58 <johnw> and strace
15:58:36 <chrisdone> igor, pull the first lever!
15:58:54 <athan> johnw: Well, the executable isn't failing
15:59:03 <athan> it's even showing 200 responses in the logs :\
15:59:09 <Welkin> facebook, google, and the NSA took all your data
15:59:12 <Welkin> go get it back from them!
15:59:18 <athan> >:C
15:59:32 * athan pulls up pants
16:00:43 <EvanR> trying to do all this with your pants down might have contributed to the problem
16:03:24 <chrisdone> johnw: figured out a type with StateT that works nicely https://github.com/chrisdone/descriptive#wrapping
16:05:58 <chrisdone> there's something magical about rank-n types
16:06:03 <chrisdone> i couldn't live without them
16:06:53 <asmyers> Is there a way to get at the underlying input while inside an attoparsec parser?
16:07:15 <asmyers> e.g. get access to the ByteString that is being parsed?
16:07:19 <EvanR> you can get rest of input
16:07:55 <EvanR> takeByteString
16:08:19 <asmyers> EvanR, That consumes the input though.  I can thread the input into the parser manually
16:08:45 <asmyers> I have a protocol that gives me offsets so it would be convenient to be able to read from the offset immediately
16:09:26 <EvanR> the input bytestring could be simply a Reader as part of your parser
16:10:38 <asmyers> EvanR, true, I'll do that.  I thought attoparsec might have some method of accessing it already.  Thanks
16:11:21 <sgronblo> > round 2.5
16:11:22 <lambdabot>  2
16:11:34 <sgronblo> uh how do i get the normal shop rounding?
16:11:34 <Welkin> :t round
16:11:35 <lambdabot> (RealFrac a, Integral b) => a -> b
16:11:38 <gcganley> im trying to use Either to represent possible errors but its increasing in complexity to a point where *I* cant even reason about it
16:11:54 <EvanR> sgronblo: which one is that
16:12:03 <Welkin> sgronblo: you could add 0.5 before calling round (which seems to be truncate)
16:12:13 <Welkin> :t truncate
16:12:14 <lambdabot> (RealFrac a, Integral b) => a -> b
16:12:17 <EvanR> no its bankers rounding
16:12:20 <Welkin> > truncate 2.5
16:12:21 <EvanR> > round 3.5
16:12:21 <lambdabot>  2
16:12:22 <lambdabot>  4
16:12:27 <sgronblo> > round 2.6
16:12:28 <lambdabot>  3
16:12:32 <sgronblo> its not truncate no
16:12:40 <sgronblo> might be what EvanR said
16:12:40 <Welkin> > round 2.5
16:12:41 <lambdabot>  2
16:12:48 <Welkin> > round 2.51
16:12:50 <lambdabot>  3
16:12:52 <Welkin> hm
16:12:54 <EvanR> bankers rounding avoids a bias
16:13:03 <Welkin> it should round up on >= .5
16:13:15 <EvanR> well, thats one of four rounding modes in floating point
16:13:24 <EvanR> at least
16:13:24 <Welkin> > round 3.5
16:13:26 <lambdabot>  4
16:13:31 <Welkin> that seems wrong
16:13:39 <Welkin> why does 2.5 become 2, but 3.5 becomes 4?
16:13:44 <Welkin> it is inconsistent
16:13:46 <sgronblo> 2 is even
16:13:51 <sgronblo> 3 odd
16:13:53 <EvanR> the rule is down on even, up on odd
16:13:57 <sgronblo> thats the banking thing
16:13:59 <EvanR> if you get a half
16:14:02 <sgronblo> i wanted the normal one
16:14:02 <Welkin> that is unconventional...
16:14:19 <sgronblo> yeah its not how "normal" people do it
16:14:21 <EvanR> not sure what the big deal is ;)
16:14:24 <Welkin> perhaps someone should look at fixing that for `round`
16:14:27 <EvanR> neither one is right
16:14:35 <sgronblo> Welkin: its not broken
16:14:45 <EvanR> Welkin: its the default rounding mode for floats
16:14:46 <sgronblo> its just different ways to map Float to Int
16:14:50 <Welkin> I know it isn't broken
16:14:51 <athan> Hmm! The broken http responses aren't going through `lo` at least!
16:14:54 <sgronblo> but i want that normal rounding mode
16:14:56 <Welkin> but it is not what is commonly expected
16:15:08 <sgronblo> what if you are a banker?
16:15:47 <EvanR> floating point behavior in general is largely not commonly expected
16:15:53 <Welkin> anyway
16:16:02 <Welkin> you can use truncate to implement round
16:16:09 <sgronblo> well i was surprised to see this was the default too
16:16:16 <Welkin> > truncate . (+0.5) $ 2.5
16:16:17 <lambdabot>  3
16:16:22 <chrisdone> if you're a banker you'll be banking, telling people they owe you money, that kind of thing. not writing software
16:16:42 <Welkin> @let round' = truncate . (+0.5)
16:16:45 <lambdabot>  Defined.
16:16:48 <chrisdone> quants are okay with doubles
16:16:53 <Welkin> > round' 2.5
16:16:55 <lambdabot>  3
16:17:19 <EvanR> sgronblo: you can modify your floating point environment, or use another function
16:17:30 <EvanR> i dont think truncate will easily implement this rounding mode
16:17:51 <Welkin> > round' (-2.5)
16:17:53 <lambdabot>  -2
16:17:58 <EvanR> > round' 3.5
16:17:59 <lambdabot>  4
16:18:10 <Welkin> > round' 2.4
16:18:12 <lambdabot>  2
16:18:21 <Welkin> it always round toward zero
16:18:42 <Welkin> er
16:18:43 <EvanR> uhg, everything is rounding
16:18:55 <EvanR> adding one is rounding to the next +1
16:19:13 <bramgg> How can I do something like `func "a" (=<< foo "bar") "b"`?
16:19:37 <bramgg> Where I get the same result as if (=<< foo "bar") was replaced with `a` and above it was `a <- foo "bar"`
16:19:40 <EvanR> http://stackoverflow.com/questions/10738569/round-to-nearest-integer
16:19:53 <chrisdone> bramgg: give a type
16:20:53 <bramgg> chrisdone: ($Type =<< foo "bar") said the data constructor wasn't in scope?
16:21:06 <bramgg> clearly I'm doing something wrong
16:21:20 <t4nk193> I'm a haskell noob struggling through 99 haskell problems at the moment
16:21:27 <t4nk193> can anyone tell me why this isn't typechecking?
16:21:33 <t4nk193> isPalindrome :: (Eq a) => [a] -> Bool isPalindrome [] = True isPalindrome [x] = True isPalindrome (x:y:[]) = x == y isPalindrome (x:xs:y:[]) = (x == y) && (isPalindrome xs) isPalindrome _ = False
16:21:51 <t4nk193> it's the (isPalindrome xs) part
16:21:51 <chrisdone> bramgg: i mean state the type of the function you want?
16:22:00 <shachaf> t4nk193: You should go to hpaste.org and paste your full code and full error message.
16:22:27 <chrisdone> bramgg: that'll be clearer to understand than an informal description
16:22:27 <Welkin> @let round' = truncate . (\x -> if x < 0 then x - 0.5 else x + 0.5)
16:22:28 <lambdabot>  .L.hs:185:1:
16:22:28 <lambdabot>      Multiple declarations of ‚Äòround'‚Äô
16:22:28 <lambdabot>      Declared at: .L.hs:184:1
16:22:34 <geekosaur> t4nk193, because (x:xs:y:[]) your xs is an item, not a list
16:22:35 <Welkin> @undefine
16:22:35 <lambdabot> Undefined.
16:22:37 <Welkin> @let round' = truncate . (\x -> if x < 0 then x - 0.5 else x + 0.5)
16:22:38 <lambdabot>  Defined.
16:22:46 <Welkin> > round (-2.5)
16:22:48 <lambdabot>  -2
16:23:01 <sgronblo> http://stackoverflow.com/questions/10738569/round-to-nearest-integer this is sad, when somebody almost asks the question you want, but doesnt get the right answer you want.
16:23:19 <chrisdone> shachaf: hey check this out https://gist.github.com/chrisdone/c4a029b2da5028f3ffc7/revisions
16:23:19 <Welkin> > round' (-2.5)
16:23:21 <lambdabot>  -3
16:23:21 <Welkin> wrong round
16:24:01 <Welkin> sgronblo: round' does what you want and works for negative values
16:24:02 <EvanR> always rounding toward positive infinity on ties (one of the possible rounding modes which youre free to activate) has gotta be the most counter intuitive
16:24:06 <chrisdone> shachaf: motivating use-case was for the formatting package to be able to write: format (year % "/" <> month <> "/" % dayOfMonth) now ‚Üí "2015/01/27"
16:24:15 <t4nk193> http://lpaste.net/119356
16:24:20 <t4nk193> how do I get the error message?
16:24:24 <t4nk193> from my console or hpaste?
16:25:12 <t4nk193> Could not deduce (a ~ [a0])     from the context (Eq a)       bound by the type signature for isPalindrome :: Eq a => [a] -> Bool       at hask.hs:25:17-37       ‚Äòa‚Äô is a rigid type variable bound by           the type signature for isPalindrome :: Eq a => [a] -> Bool           at hask.hs:25:17     Relevant bindings include       y :: a (bound at hask.hs:29:20)       xs :: a (bound at hask.hs:29:17)       x :: a (bound at hask.
16:25:41 <t4nk193> oh I see, include them both
16:25:42 <glguy> t4nk193: (x:xs:y:[])   this pattern matches a 3 element list calling the first element 'x', the second 'xs', and the third 'y'
16:25:43 <t4nk193> http://lpaste.net/119357
16:26:00 <t4nk193> oh duh, thanks
16:26:01 <shachaf> chrisdone: I post one little comment to Reddit and it follows me around for years.
16:26:04 <t4nk193> k I'll have to rethink it
16:26:20 <chrisdone> shachaf: =p
16:27:08 <Welkin> @let isPalindrome xs = xs == (reverse xs)
16:27:10 <lambdabot>  Defined.
16:27:16 <Welkin> > isPalindrome "racecar"
16:27:18 <lambdabot>  True
16:27:33 <bramgg> http://lpaste.net/119358
16:27:36 <bramgg> chrisdone: ^
16:28:31 <bramgg> whoops just fixed a type (forgot an end ")
16:28:39 <bramgg> *typo man i suck
16:28:45 <shachaf> chrisdone: Hmm, does this version do the "dlisty" thing?
16:28:50 <shachaf> I guess it doesn't really matter.
16:28:50 <t4nk193> yeah you can always do it clever @Welkin :)
16:29:05 <t4nk193> I'm trying to learn the syntax of Haskell
16:29:15 * shachaf wonders whether using (Prelude..) for composition is a good idea or just confusing in a context like this.
16:29:25 * hackagebot formatting 6.1.2 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-6.1.2 (ChrisDone)
16:29:49 <t4nk193> thanks again for the help @glguy
16:30:15 <chrisdone> shachaf: i liked that version. i think i had trouble getting an IsString instance for it in the end
16:30:18 <Welkin> t4nk193: read the source for foldr and foldl
16:30:30 <Welkin> I found it very helpful when first learning haskell
16:30:49 <EvanR> > isPalindrome "Tacocat"
16:30:49 <shachaf> Ah, IsString is an issue.
16:30:51 <lambdabot>  False
16:31:10 <Welkin> reading the source for mu=odules in base is a good exercise
16:31:13 <Welkin> modules*
16:31:28 <shachaf> chrisdone: Now you need to implement a copy-on-write version of this thing.
16:31:28 <benzrf> > isPalindrome "tacocat"
16:31:30 <lambdabot>  True
16:31:45 <EvanR> tacocat both is, and is not a palindrome
16:31:57 <EvanR> smoke that aristotle
16:32:13 <Welkin> aristotle was mostly an idiot
16:32:17 <benzrf> Welkin: nonsense
16:32:21 <benzrf> aristotle was p cool
16:32:28 <benzrf> he also had some fricking dumb ideas
16:32:33 <benzrf> but like
16:32:37 <johnw> way off topic
16:32:51 <Welkin> "Things in motion slow down and stop because they become tired"
16:33:07 <benzrf> Welkin: consider the period he worked in
16:33:12 <EvanR> -blah is where you discuss philosophy and religion
16:34:21 <chrisdone> shachaf: how would that work?
16:35:03 <kranius> what about this Prelude breakage ? I've been reading the reddit comments and the thread on the mailing list.
16:35:10 <shachaf> chrisdone: I don't know, but you can call it HoleyCow.
16:35:27 <chrisdone> haha
16:40:33 <glguy> kranius: What about it?
16:44:22 <madmax9168> Could someone give me an opinion on a problem I'm having with types?
16:44:42 <chrisdone> go!
16:44:43 <geekosaur> best to asl the actual question instead of asking to ask...
16:45:03 <madmax9168> So, I have this code: --magnitude :: (Num a, Floating b) => (Vector a) -> b
16:45:03 <madmax9168> magnitude (Vector (x, y, z)) = (sqrt (x^2 + y^2 + z^2))
16:45:03 <madmax9168> magnitude (Vector2D (x, y)) = (sqrt (x^2 + y^2))
16:45:09 <Zemyla> Hmm. Maybe is basically forall b. (a -> m b) -> mb -> mb?
16:45:46 <EvanR> :k Maybe
16:45:47 <lambdabot> * -> *
16:45:52 <madmax9168> And this doesn't work, saying "could not deduce (a~b)". Does anyone know what's going wrong here?
16:46:27 <zachk> does anyone else get this error for cabal install c2hs-0.20.1: Couldn't match expected type ‚ÄòBool‚Äô with actual type ‚ÄòInt#‚Äô
16:46:44 <glguy> madmax9168 consider the type of (+) :: Num a => a -> a -> a
16:46:47 <zachk> and how do I work around that, its 522 lines into the source code
16:46:49 <glguy> The result is the same as the arguments
16:46:59 <zachk> hey athan
16:47:02 <benzrf> madmax9168: fyi (a ~ b) means "a is the same type as b"
16:47:05 <glguy> madmax9168: so you don't to get change its type like you're trying to do with the   a -> b
16:47:09 <benzrf> madmax9168: for example:
16:47:17 <benzrf> @let notId :: a -> b; notId x = x
16:47:18 <lambdabot>  .L.hs:157:11:
16:47:18 <lambdabot>      Couldn't match expected type ‚Äòb‚Äô with actual type ‚Äòa‚Äô
16:47:18 <lambdabot>        ‚Äòa‚Äô is a rigid type variable bound by
16:47:30 <benzrf> equivalent to "could not deduce (a ~ b)"
16:48:35 <athan> zachk: Ello :)
16:48:46 <madmax9168> hmmmm...so could I use some function to convert a (Floating b) to a (Num whatever)?
16:49:13 <EvanR> :t floor
16:49:14 <lambdabot> (RealFrac a, Integral b) => a -> b
16:49:26 * hackagebot leaky 0.2.0.1 - Robust space leak, and its strictification  http://hackage.haskell.org/package/leaky-0.2.0.1 (AndrewSeniuk)
16:50:10 <Fuuzetsu> madmax9168: all Floating are required to be Fractional which are required to be Num
16:50:19 <Fuuzetsu> so no conversion of any sort is needed
16:50:37 <madmax9168> Fuuzetsu: Derp. I should've realized that. Thanks
16:55:45 <EvanR> looking at these dependencies is surprising, Num requires Eq, not Ord, but requires Show. Integral requires Enum
16:56:18 <shachaf> Num has neither Eq nor Show superclasses (though it used to).
16:56:27 <shachaf> Requiring Ord would be silly.
16:56:42 * EvanR looks for a more up to date thing
16:57:17 <EvanR> https://www.haskell.org/onlinereport/haskell2010/haskellch6.html
16:58:07 <toblerone> Hi i'm trying to use GHC's profiling mechanism and I'm getting seemingly contradictory messages. If I don't compile with the "-prof" flag when I execute the program with "+RTS -p" I get an error message saying that I must use "-prof". When I compile with "-prof" i get a warning saying I should use the "configure flag" --enable-executable-profiling
16:58:07 <toblerone> which it doesn't recognize as a valid flag
16:58:33 <Fuuzetsu> --enable-executable profiling is a cabal thing
16:58:35 <Fuuzetsu> -prof is a GHC thing
16:58:58 <gcganley> is there any way to flip function composition but still have (.) and ($) compose nicely. doing things like (flip ($)) doesnt do too well
16:59:01 <toblerone> okay, which cabal field would I place that in then?
16:59:38 <Fuuzetsu> normally you'd run cabal configure --enable-executable-profiling by hand I think
16:59:38 <EvanR> gcganley: well theres & which is flip ($)
16:59:45 <Fuuzetsu> import Lens‚Ä¶
16:59:45 <toblerone> ah
16:59:46 <roboguy_> :t (>>>)
16:59:47 <toblerone> ok
16:59:47 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
16:59:53 <roboguy_> ^ gcganley
17:00:45 <sdegutis> Is it possible to take a group of functions that take a bunch of arguments and transform it into a group of functions that have the first argument applied with a specific value?
17:01:09 <sdegutis> I know this can be done individually, but is there any mechanism to make this easier when done with a group of related functions?
17:01:19 <EvanR> map ($) ?
17:01:54 <sdegutis> For reference, I plan to use this to do some awful stuff, like make "methods" on a given instance object (a virtual machine).
17:02:20 <hpc> :t map ($)
17:02:21 <lambdabot> [a -> b] -> [a -> b]
17:02:42 <hpc> i think you mean cale-flip
17:02:45 <c_wraith> yep.  looks just like map id
17:02:55 <sdegutis> :t map ($ 4)
17:02:56 <lambdabot> Num a => [a -> b] -> [b]
17:02:58 <EvanR> :t map ($ this)
17:02:59 <lambdabot> Not in scope: ‚Äòthis‚Äô
17:03:02 <EvanR> :t map ($ t)
17:03:03 <lambdabot> [Expr -> b] -> [b]
17:03:11 <c_wraith> ls
17:03:14 <hpc> :t \fs x -> fmap ($ x) fs
17:03:15 <lambdabot> Functor f => f (a -> b) -> a -> f b
17:03:16 <c_wraith> damn it.  sorry.
17:03:39 <hpc> :t zipWith ($) -- also
17:03:40 <lambdabot> [b -> c] -> [b] -> [c]
17:03:47 <sdegutis> I think I have an idea for my first typeclass!
17:04:32 <gcganley> :t flip ($)
17:04:33 <lambdabot> b -> (b -> c) -> c
17:04:40 <gcganley> :t ($)
17:04:41 <lambdabot> (a -> b) -> a -> b
17:04:44 <EvanR> sdegutis: you could have invented oop in haskell
17:04:44 <sdegutis> I plan to make a typeclass and then make Num and String both conform, and then I'll be able to do [3, "foo"] :: MyTypeclass
17:04:53 <bernalex> gcganley: flip $ is &
17:05:01 <bernalex> :t (&)
17:05:02 <roboguy_> sdegutis: it'll be hard to get those back out
17:05:02 <lambdabot> a -> (a -> b) -> b
17:06:04 <sdegutis> roboguy_: No, my typeclass will have an IO function that they operate on, and I'll call it on them
17:06:05 <EvanR> data PHP = Number Double | String Text
17:06:08 <Fuuzetsu> sdegutis: that's one of the ways for hetero lists though not really nice one
17:06:12 <EvanR> well String ByteString
17:06:34 <sdegutis> Fuuzetsu: I don't generally like heterogeneous lists, but in this case I want to return values from a Lua function and thus this works
17:06:50 <Fuuzetsu> well, :: MyTypeclass is not something you can write
17:06:52 <EvanR> sdegutis: you could just make a LuaValue data type
17:06:57 <sdegutis> data LuaReturnValue = Nothing | Value a | Values [a]
17:06:58 <Fuuzetsu> [MyTypeclass] rather
17:07:15 <gcganley> :t (&)
17:07:16 <lambdabot> a -> (a -> b) -> b
17:07:21 <gcganley> :t ($)
17:07:22 <lambdabot> (a -> b) -> a -> b
17:07:36 <gcganley> :t flip ($)
17:07:38 <lambdabot> b -> (b -> c) -> c
17:07:39 <sdegutis> Okay maybe I don't know enough Haskell yet to design this.
17:08:07 <roboguy_> sdegutis: I would just make a type thats something like data LuaValue = Number Int | String String | ...
17:08:08 <Fuuzetsu> I suggest you make LuaValue data type or something
17:08:11 <EvanR> sdegutis: you could make (possibly crashing, possibly Nothinging) conversion instances for various types to from this class
17:08:30 <EvanR> i mean, from and from LuaValue
17:08:39 <EvanR> to and from *leaves*
17:12:28 <gcganley> :info (&)
17:13:41 <roboguy_> gcganley: it's in lens
17:14:26 * hackagebot descriptive 0.6.0 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.6.0 (ChrisDone)
17:14:31 <johnw> I'm finding Free ((,) f) () to be a very convenient way to make lists use do-notation in tests...
17:14:33 <gcganley> roboguy_: thank you
17:14:35 <glguy> In GHC 7.10.1 & will be in Data.Function in base
17:14:37 <johnw> example: https://gist.github.com/a2d7d18d195fd4f496e4
17:14:44 <gcganley> glguy: nice!
17:15:08 <roboguy_> gcganley: FPComplete's Hoogle is handy for looking up stuff like that (the regular hoogle doesn't index as much) https://www.fpcomplete.com/hoogle?q=%26&env=ghc-7.8-stable-14.09
17:18:23 <timpani> After following the directions at https://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites for creating a cabal test suite of type detailed-0.9, 'cabal test' complains "Module ‚ÄòDistribution.Simple.Test‚Äô does not export ‚ÄòstubMain‚Äô". Browsing online has turned up surprisingly little. Anyone know what's going on?
17:19:27 * hackagebot hindent 4.3.3 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.3.3 (ChrisDone)
17:19:29 * hackagebot structured-haskell-mode 1.0.13 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.13 (ChrisDone)
17:22:26 <gcganley> :t (.)
17:22:27 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:22:30 <gcganley> :t flip (.)
17:22:31 <lambdabot> (a -> b) -> (b -> c) -> a -> c
17:24:27 * hackagebot smtp-mail-ng 0.1.0.0 - An SMTP client EDSL  http://hackage.haskell.org/package/smtp-mail-ng-0.1.0.0 (alexvieth)
17:25:16 <fread2282> why pipes as opposed to just (Monad m => a -> m b)?
17:25:24 <benzrf> fread2282: what do you mean?
17:25:28 <cdk> does anyone know why was Data.Coerce.coerce de-poly-kinded in GHC 7.10?
17:25:56 <vanila> cdk, I think it could be unsafe
17:26:23 <fread2282> benzrf: run (and bind) the (a -> m b) for each value/iteration
17:26:32 <cdk> vanila: do you know of an example? I figured it would be something like that, but I want to know why specifically
17:27:29 <benzrf> fread2282: that's not what pipes does
17:28:05 <fread2282> benzrf: what does it do then? isn't it just effectful streaming loops?
17:28:14 <benzrf> fread2282: basically?
17:28:24 <benzrf> fread2282: the point is that it lets you decouple components
17:28:34 <benzrf> fread2282: in your model, how would you write stdinLn?
17:28:51 <benzrf> (that's the Producer that yields lines of stdin)
17:29:48 <fread2282> benzrf: (const getLine :: () -> IO String)?
17:29:58 <benzrf> fread2282: ok but that just does it once
17:30:13 <benzrf> fread2282: that's not a source that yields as you request
17:30:18 <benzrf> fread2282: or rather
17:30:25 <benzrf> fread2282: how would you pipe that into a consumer
17:30:28 <ouchthats> @pl \f -> g . (h f)
17:30:28 <lambdabot> (g .) . h
17:30:36 <benzrf> ouchthats: p gross
17:31:19 <ouchthats> p gross?
17:31:42 <benzrf> pretty gross
17:32:40 <ouchthats> fair enough
17:33:06 <gcganley> ouchthats: sometimes its better to have the pointed version
17:35:44 <fread2282> benzrf: what consumer?
17:38:27 <benzrf> fread2282: any consumer
17:38:31 <benzrf> fread2282: well
17:38:35 <benzrf> fread2282: how do you represent a consumer
17:39:02 <benzrf> let's say, one that eats 3 inputs & printes them concatted & repeats
17:40:33 <fread2282> if you can combine mtl stacks with type families, this will work, if not, then idk if it will. (>->) :: (a -> t1 m b) -> (b -> t2 m c) -> a -> (Combine t1 t2) m c
17:40:44 <fread2282> t1 and t2 are transformers
17:41:12 <benzrf> im not sure what this accomplishes?
17:41:22 <benzrf> fread2282: how do you represent the consumer i just described as an a -> m b
17:42:27 <hcore> ghci insists that the value of c in this is an array of something and not a single Int and i'm not sure why
17:42:28 <hcore> http://lpaste.net/119363
17:42:57 <fread2282> so now you need a "get 3 and concat" pipe. :: String -> StateT [String] m String
17:42:58 <hcore> it's intended to return a tuple where a is the number and c is the count of numbers
17:43:19 <fread2282> then you need an IdentityT-lifted getLine and print
17:43:42 <fread2282> wait no that won't work
17:43:46 <geekosaur> hcore: other way around. it's a list comprehension; you need to feed <- a list, but you are giving it a numbet
17:43:48 <geekosaur> *number
17:44:17 <geekosaur> (read "x <-" as "taking x from all elements of")
17:44:28 <hcore> ohhhh
17:44:29 <fread2282> concatBy3 :: String -> StateT [String] (MaybeT m) String
17:44:31 <geekosaur> or "each element of"
17:44:44 <shachaf> Alternatively, x is all the elements at once. :-)
17:44:49 <benzrf> fread2282: huh?
17:44:59 <benzrf> fread2282: what is this
17:45:19 <benzrf> fread2282: what is the Maybe for
17:45:40 <fread2282> benzrf: when we don't have 3, we don't want to yield anything
17:45:58 <hcore> > let uniquevalues n = [(a,c) | a <-(nub n), let c = (length $ filter (==a) n)]
17:45:59 <lambdabot>  not an expression: ‚Äòlet uniquevalues n = [(a,c) | a <-(nub n), let c = (leng...
17:46:05 <hcore> whatever
17:46:07 <hcore> it works!
17:46:10 <hcore> thanks geekosaur
17:46:28 <benzrf> wait
17:46:36 <benzrf> fread2282: what would the implementation look like, idgi
17:50:01 <fread2282> benzrf: (\newelem -> lift get >>= \a -> if length a >= 2 then return (a !! 0) ++ (a !! 1) ++ newelem else lift (put newelem) >> return Nothing)
17:50:56 <fread2282> for concatBy3
17:50:57 <roboguy_> :t (\newelem -> lift get >>= \a -> if length a >= 2 then return (a !! 0) ++ (a !! 1) ++ newelem else lift (put newelem) >> return Nothing)
17:50:58 <lambdabot>     Couldn't match type ‚Äòt m‚Äô with ‚Äò[]‚Äô
17:50:59 <lambdabot>     Expected type: t m (Maybe a)
17:50:59 <lambdabot>       Actual type: [Maybe a]
17:51:30 <fread2282> needs more parens
17:51:46 <fread2282> :t (\newelem -> lift get >>= \a -> if length a >= 2 then return ((a !! 0) ++ (a !! 1) ++ newelem) else lift (put newelem) >> return Nothing)
17:51:47 <lambdabot>     Couldn't match expected type ‚Äò[a]‚Äô with actual type ‚ÄòMaybe a0‚Äô
17:51:47 <lambdabot>     Relevant bindings include
17:51:47 <lambdabot>       a :: [[a]] (bound at <interactive>:1:28)
17:52:34 <fread2282> :t (\newelem -> lift get >>= \a -> if length a >= 2 then return ((a !! 0) ++ (a !! 1) ++ newelem) else lift (put newelem) >> fail "MaybeT!")
17:52:35 <lambdabot>     No instance for (MonadTrans t) arising from a use of ‚Äòlift‚Äô
17:52:35 <lambdabot>     Possible fix:
17:52:35 <lambdabot>       add (MonadTrans t) to the context of
17:53:05 <_2_Sydandnikki> Hey everyone
17:53:12 <EvanR> -_-
17:53:16 --- mode: ChanServ set +o shachaf
17:53:29 --- kick: _2_Sydandnikki was kicked by shachaf (_2_Sydandnikki)
17:53:45 --- mode: shachaf set +bb _1_*!*@* _2_*!*@*
17:53:48 --- mode: shachaf set -o shachaf
17:56:50 <benzrf> fread2282: how simple
17:57:15 <benzrf> ok, sohum
17:57:17 <benzrf> *so
17:57:33 <benzrf> fread2282: how is this connected to the upstream component
17:57:55 <indiagreen> since I've got nothing to do and am currently sitting and adding definitions to lambdabot's @src: anybody has any requests?
17:58:07 <fread2282> benzrf: (>->) :: (a -> t1 m b) -> (b -> t2 m c) -> a -> (Combine t1 t2) m c
17:58:17 <benzrf> (fyi the code in pipes is `forever $ (concat <$> replicateM 3 await) >>= yield')
17:58:35 <benzrf> fread2282: so what if i want to attach a third component
17:58:38 <benzrf> fread2282: i need another state layer?
17:58:46 <fread2282> but then you need a typelcass for default monad trans values, and running it gets messy
17:58:55 <fread2282> *typeclass
17:59:03 <fread2282> benzrf: yep
17:59:07 <benzrf> ew
17:59:12 <athan> @src callCC
17:59:12 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
17:59:15 <athan> indiagreen^ :)
17:59:16 <halvorg> is there a ST mutable map type? like for array
17:59:20 <benzrf> i gotta say i think i prefer pipes
17:59:35 <indiagreen> @src Cont callCC
17:59:35 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
17:59:39 <fread2282> yep, now I see wht pipes :)
17:59:42 <athan> oop
17:59:42 <fread2282> *why
18:00:34 <roboguy_> fread2282, benzrf: I'd probably write it like this: http://lpaste.net/119365
18:08:00 <halvorg> hm, aren't data constructors exported if I export the type?
18:08:11 <shachaf> Not unless you export the constructors.
18:08:16 <shachaf> That way you can make opaque types.
18:10:25 <geekosaur> note that you can use Type(..) to export all constructors
18:10:45 <halvorg> ah, thats how
18:10:47 <halvorg> thanks
18:24:56 <Lokathor> hsOpenSSL seems to have a lot about how to connect to an SSL server, but less about being a server that's supporting SSL. Am I just looking in the wrong places?
18:26:54 <solirc> Lokathor: I would delegate SSL termination to e.g. nginx
18:28:02 <solirc> ngixn is probably also better in dealing with missbehaving clients, enforcing resource restrictions, etc.
18:28:24 <Lokathor> well, i've got a program that uses web sockets, and is basically a chat server, and the chat messages are update messages about data shared between the clients
18:28:46 <solirc> Lokathor: But if you really want to do SSL termination in your application, you could look at https://github.com/zalora/sproxy
18:28:55 <Lokathor> i just need to make the websocket connection (ws:) into a ssl enabled web socket (wss:)
18:30:02 <solirc> Lokathor: I would assume you could still tunnel it through nginx, not sure
18:30:44 <Lokathor> okay, i'll talk to the network guy about that
18:31:02 <Lokathor> he's got a slight strange proxy setup as is, so he can probably layer it in there maybe
18:34:13 <dfeuer> Oh .... hm .... yuck. I'm going to have to completely rewrite this code just to use a different sort of priority queue :-/
18:35:24 <dfeuer> And also rewrite much of, say, Wasserman's priority queue in order to use it with the hacked up code.
18:35:41 <dfeuer> Unboxing is pain.
18:43:36 <dfeuer> carter, I'm planning to adapt http://hackage.haskell.org/package/queuelike-1.0.9/docs/src/Data-MQueue-Heap.html to use unboxed arrays of (Word, Word, Word). This should be pretty easy, but also rather stupid. Is there a way to make such things happen generically, so I could use the same source (not binary) for Int, Char, (Int,Word), etc.?
18:44:17 <dfeuer> [I guess Vectors actually, since STUArrays don't seem to have the magic for tuples]
18:44:28 <carter> dfeuer: you might like something i wrote a while ago
18:44:40 <carter> https://github.com/wellposed/numerical/blob/master/src/Numerical/Data/Vector/Pair.hs
18:45:14 <carter> not sure what your goal is
18:45:14 <dfeuer> carter, what does that do?
18:45:27 <carter> it lets me build a tuple of arrays, and treat it like an array of tuples
18:45:32 <carter> and easily go back and forth
18:45:56 <dfeuer> I'm still playing with that O'Neill sieve. I want to see what happens if I switch from a functional priority queue to a mutable-array based one with lazy ST.
18:47:01 <dfeuer> carter, doesn't the vector package come with just about all of that out of the box? I don't think I need anything too fancy that way.
18:47:09 <carter> i guess
18:47:13 <dfeuer> I don't mean with whatever you're doing.
18:47:18 <dfeuer> Because I don't know what you're doing.
18:47:22 <carter> zip and unzip in unboxed vector shoudl world
18:47:24 <carter> *work
18:47:42 <dfeuer> I also don't think I actually need that anyway.
18:56:54 <jle`> is there a newtype wrapper around the ((/=), False) monoid instance for Bool?
18:57:29 <jle`> in some ways it's an even more interesting monoid because it's the only one that has an inverse! :O
18:57:43 <jle`> but i guess if we're doing groups then we can shove it into a Num instance
18:57:45 <shachaf> I don't think there's one in base.
18:58:04 <jle`> instance Num Bool where (+) = (/=); (*) = (&&)
18:58:08 <joness> > mempty :: Bool
18:58:10 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Bool)
18:58:10 <lambdabot>    arising from a use of ‚ÄòData.Monoid.mempty‚Äô
18:58:13 <jle`> negate = not
18:58:46 <jle`> i guess in common cases where you use the monoid instance of Bool you really only want the non-group monoid
18:58:59 <jle`> s/the/a
18:59:05 <joness> there are two monoids for Bool aren't there?
18:59:12 <joness> possible ones
19:00:08 <jle`> if you count the isomorphic ones as separate, there are at least four
19:00:21 <jle`> (automorphic?)
19:00:38 <joness> True identity with && mappend. and False identity with || mappend. ?
19:00:52 <jle`> there's False identity with (/=) mappend
19:01:05 <shachaf> Commonly known as xor
19:01:48 <jle`> and then true identity with "nxor"
19:02:04 <roboguy_> jle`: that's also 'implies', isn't it?
19:02:35 <jle`> nxor is (==) heh
19:02:43 <roboguy_> oh, no never mind
19:03:59 <dfeuer> carter, what I was really wondering was how, if at all, I could write Haskell code corresponding somewhat to C++ template code, with fake polymorphism over unboxed types.
19:04:28 <dfeuer> Actually, not exactly unboxed, but just unpacked. Still, monomorphic.
19:04:36 <carter> Vector.Primitive?
19:04:54 <Rotaerk> isn't that what template haskell is for?
19:04:55 <carter> i mean, unboxed IS that too
19:05:04 <carter> dfeuer: how is unboxed vectors not what you want
19:05:20 <dfeuer> carter, yes, I do want unboxed vectors.
19:05:28 <carter> why not use them
19:05:58 <dfeuer> Sorry, carter, I'm mixing up in my head two things I was thinking about today.
19:06:09 <shachaf> There are only four.
19:06:38 <dfeuer> carter, I was previously thinking about tree-based structures with nodes holding unpacked primitive things.
19:07:01 <carter> a tree of vectors?
19:07:06 <dfeuer> No.
19:07:30 <carter> data fams?
19:07:49 <dfeuer> Carter, think of something vaguely like Tree = Tip | Bin !Int Tree Tree
19:07:57 <dfeuer> And writing a bunch of functions to do things with that,
19:08:01 <carter> except
19:08:04 <carter> ??
19:08:11 <dfeuer> and then realizing you want one for another type as well.
19:08:21 <dfeuer> And you don't want to have to copy and paste and search/replace.
19:08:42 <carter> sounds like you want a data family and a type class
19:09:53 <dfeuer> Like data family Tree a :: *;  data instance Tree Int = TipInt | BinInt !Int (Tree Int) (Tree Int) ?
19:10:01 <dfeuer> It all seems rather awkward.
19:12:36 <dfeuer> carter, I actually started writing some code like that, but if you're going to do that, you might want to try to reduce code size by, say, using the same representation for IntN and WordN (regardless of sign stuff and regardless of N)
19:12:54 <dfeuer> And then the type family stuff to attempt that went over my head.
19:13:04 <carter> then dont do the latter bit yet
19:13:10 <carter> do the former only and see what happens
19:13:18 <carter> dfeuer: or stop over abstracting and write the simple csae first?
19:13:24 <dfeuer> :-)
19:14:32 <dfeuer> carter, I only need it for one type. But looking around at various packages in the process of seeing what's available for my purpose got me thinking about how hard it is to make good libraries for stuff that should be unboxed.
19:14:32 * hackagebot linearscan 0.2.0.0 - Linear scan register allocator, formally verified in Coq  http://hackage.haskell.org/package/linearscan-0.2.0.0 (JohnWiegley)
19:14:47 <dfeuer> And mutable arrays should *almost always* be unboxed.
19:15:11 <dfeuer> Because GC of boxed mutable arrays is just baaaad.
19:15:43 <Welkin> you can only have unboxed primitive, right?
19:16:14 <johnw> you can unbox collections of primitives too
19:16:15 <dfeuer> Welkin: yes, but.
19:16:25 <johnw> they simply lay out contiguously
19:16:40 <johnw> (for example, a record with unboxed fields)
19:17:01 <carter> SOA format though
19:17:15 <carter> unles you're using storable
19:17:17 <dfeuer> You can also {-# UNPACK #-} things, which gives a very nice interface.
19:17:18 <johnw> what's that?
19:19:16 <dfeuer> carter, I wonder if there'd be a way to make a strong version of UNPACK that would work the sort of magic I'm talking about. If GHC could infer a monomorphic type, it would unpack it, and otherwise it would just give an error.
19:19:41 <carter> dfeuer: then it becomes a data fam
19:19:49 <Rotaerk> hmm what would you call:  \x -> concat . replicate x
19:19:51 <carter> and any code using that poly thing needs a magic class
19:19:52 <Rotaerk> I'm thinking "relist"
19:19:55 <dfeuer> carter, but all the construcors have the same names.
19:19:57 <carter> :t concat . replicate
19:19:58 <lambdabot>     Couldn't match type ‚Äòa0 -> [a0]‚Äô with ‚Äò[[a]]‚Äô
19:19:58 <lambdabot>     Expected type: Int -> [[a]]
19:19:58 <lambdabot>       Actual type: Int -> a0 -> [a0]
19:20:12 <Rotaerk> :t \x -> concat . replicate x
19:20:13 <lambdabot> Int -> [a] -> [a]
19:20:34 <dfeuer> But yes, carter, that's basically what I'm thinking of. An automatically extended data family with polymorphic constructor names. Too crazy, maybe?
19:20:45 <carter> its been discuseed
19:20:48 <carter> its tricky
19:20:49 <dfeuer> o.O
19:20:54 <dfeuer> I can imagine, yeah.
19:21:33 <dfeuer> Heck, if you could give it a fallback to a polymorphic thing, that would be something else....
19:23:19 <carter> dfeuer: you could do a phd on it
19:23:37 <dfeuer> Uhhhhhh.
19:23:44 <dfeuer> Sounds hard.
19:28:52 <jle`> hi all
19:29:04 <jle`> what sort of `cat`, `f` would be need in order to be able to do something like:
19:29:17 <jle`> fmap' :: cat a b -> cat (f a) (f b)
19:29:24 <jle`> er, for Category cat
19:29:44 <johnw> it'll work for (->)...
19:29:55 <jle`> can we generalize it?
19:29:56 <shachaf> cat needs to be a category, f needs to be a functor
19:30:07 <carter> jle`: doesn't array assume you can lift  ->  into arr/
19:30:07 <shachaf> (Endofunctor in particular.)
19:30:10 <jle`> you can do it with any Category cat and any Functor f ?
19:30:24 <drazak> is an endofunctor like an endomorphism?
19:30:26 <shachaf> No, it needs to be an endofunctor in your category.
19:30:31 <jle`> i see
19:30:44 <Axman6> oh my
19:30:47 <shachaf> Haskell's Functor is a special case where cat = (->)
19:30:51 <jle`> so you can't really do it with `Functor` alone...Functor only represents functors in (->)
19:30:53 <jle`> i see
19:31:19 <jle`> so I guess the only polymorphic-ish solution would be a new Functor typeclass (or more paramerized typelcass) for every Category
19:31:52 <shachaf> You don't need one for every Category.
19:32:06 <jle`> instance Functor cat f | f -> cat where
19:32:13 <jle`> *class Functor
19:32:24 <shachaf> You might as well make it for functors in general, not just endofunctors.
19:32:30 <jle`> i see
19:32:45 <shachaf> E.g. http://hackage.haskell.org/package/data-category-0.6.1/docs/Data-Category-Functor.html
19:32:57 <shachaf> E.g. http://hackage.haskell.org/package/categories-1.0.7/docs/Control-Categorical-Functor.html
19:33:14 <shachaf> E.g. https://github.com/ekmett/hask/blob/master/wip/Univariant.hs#L59
19:33:17 <jle`> but the shape of these per-category Functors has to be determined by the category itself
19:33:23 <jle`> ah thanks
19:33:35 <shachaf> What's a shape?
19:34:24 <jle`> a non-technical term...but writing an instnace for say, Maybe in (->) will look very different than Maybe in another Category
19:34:41 <jle`> there isn't too much you could "generalize"
19:34:51 <shachaf> I don't know what Maybe in another category is.
19:35:00 <jle`> the Functor for Maybe in another Category
19:35:23 <jle`> instance Functor Maybe (->) (->) where ...
19:35:35 <jle`> as opposed to instance Functor Maybe anothercat anotherothercat where ...
19:35:48 <shachaf> What's anothercat?
19:35:58 <jle`> another Category instance besides (->)
19:36:13 <shachaf> I'm not sure what you're getting at.
19:36:33 <shachaf> What other category are you thinking of where Maybe is a functor?
19:36:42 <jle`> you'd have to write every instance for every combination somewhat separately...there isn't a way to generalize a once-writteen instance to work for several different combinations
19:37:25 <jle`> yo might be able to write one for Monad m => instance Functor Maybe (Kleisli m) (Kleisli m)
19:37:32 <jle`> if not for general Monad m then maybe for certan specific ones
19:38:35 <benzrf> jle`: for Traversable m
19:38:39 <benzrf> you dont even need Monad
19:38:48 <jle`> yeah i just realized it, heh
19:38:54 <benzrf> er, wait
19:39:03 <benzrf> would the traversable laws entail the functor laws
19:39:13 <jle`> you only need to be able to do (a -> f b) -> (Maybe a -> f (Maybe b))
19:39:24 <jle`> which i think you can do for all Traversable f
19:39:54 <jle`> oh, wait.  Applicative f
19:40:02 <jle`> Maybe is the traversable here
19:41:48 <jle`> ...that's actually the type signature of traverse
19:42:25 <shachaf> I'm not sure that it makes much sense to talk about Kleisli categories of things that aren't monads.
19:42:50 <jle`> then we'll require two constraints :)
19:42:51 <shachaf> Since they aren't even categories. :-)
19:43:21 <shachaf> I'm still not entirely sure what you're getting at.
19:43:25 <jle`> oh wait, no, we just need the Monad m constraint
19:44:01 <jle`> um, the original point was that for every combination of categories, you'll need to re-write it for that combination
19:44:08 <jle`> you can't expect one instance to cover all combinations
19:44:14 <shachaf> It's a different functor.
19:44:24 <jle`> oh, duh
19:44:29 <shachaf> It happens to have the same object mapping in your Kleisli case.
19:44:29 <jle`> :)
19:44:48 <shachaf> Usually I wouldn't even expect that.
19:44:56 <shachaf> So reusing the type for it seems a bit odd.
19:45:02 <jle`> thanks all :)
19:45:28 <daniel-s> Is lambda calculus used outside of funtional programming and theory of computer science?
19:48:11 <roboguy_> daniel-s: I believe it's used to study natural languages in the field of linguistics
19:48:17 <roboguy_> sometimes, anyway
19:48:24 <daniel-s> Really?
19:48:33 <roboguy_> daniel-s: yeah http://en.wikipedia.org/wiki/Continuation-passing_style#Use_in_other_fields
19:48:59 <roboguy_> the paper referenced in the first paragraph looks like it uses lambda calculus
19:49:03 <shachaf> Maybe you can say that things that use lambda calculus are functional programming and theory of computer science.
19:49:15 <shachaf> That's probably not really true. But close enough.
19:49:20 <daniel-s> How would undecidability work? I mean, in natural language we just call that ambiguity.
19:50:08 <roboguy_> daniel-s: probably represented as a nondeterministic computation in some way or another. You use a church encoded list (or whichever encoding you prefer)
19:50:39 <roboguy_> we used a linked list to represent ambiguity when we did (very) basic natural language processing in one of my classes
19:53:31 <HeladoDeBrownie> i think augur or someone does linguistics-related work involving typed functional programming
19:53:37 <HeladoDeBrownie> woops, i was scrolled up a bit
19:53:53 <augur> why yes i do :)
19:54:07 <augur> HeladoDeBrownie: who was asking!
19:54:45 <HeladoDeBrownie> oh, i wasn't scrolled up that far. what roboguy_ said reminded me
19:56:08 <roboguy_> I don't know much about linguistics, but that sounds really cool
19:57:14 <Rotaerk> I'm curious... does "expression" ever evaluate in:  case expression of { _ -> 5 }
19:57:22 <roboguy_> augur: are continuations usually involved?
19:57:33 <augur> roboguy_: they can be if you want them to be!
19:57:38 <roboguy_> haha nic
19:57:40 <roboguy_> *nice
19:57:50 <shachaf> In Haskell that's the same as 5
19:57:51 <augur> roboguy_: so most/all languages have quantifiers and similar meanings, right
19:58:02 <augur> roboguy_: things like every, all, some, none, few, many, etc.
19:58:03 <shachaf> If you're reading Core, the similar-looking case construct will force expression.
19:58:17 <augur> btw roboguy_ lets do this in -blah
19:58:22 <johnw> roboguy_: Chung Chieh-Shan did his research study on continuations in linguistics
19:58:31 <Rotaerk> shachaf, "Core"?
19:58:31 <roboguy_> augur: works for me
19:59:05 <roboguy_> Rotaerk: Core is an intermediate language GHC compiles to
19:59:11 <Rotaerk> oh
19:59:14 <shachaf> GHC's intermediate language.
19:59:21 <shachaf> If you were reading Core you'd probably know it. :-)
19:59:28 <Rotaerk> heh
20:02:21 <athan> johnw: It was a lambda symbol in my markdown -_-
20:02:21 <roboguy_> Core's an interesting thing. I debugged a very unexpected (for me anyway) inefficiency earlier today looking at it
20:02:56 <athan> idk why it works from the console, though
20:03:15 <roboguy_> apparently if you have something like "case x of { 0 -> ...; 1 -> ...; 2 -> ...; 3 -> ...; ... etc ... }" it doesn't get compiled to very efficient code, which surprised me
20:04:53 <Rotaerk> roboguy_, is there a way to get something analogous to a switch statement in performance, for that?
20:06:03 <roboguy_> Rotaerk: not as far as I'm aware. I ended up using guards, which are not quite as nice looking unfortunately. I only had nine cases though, so it wasn't too terrible
20:06:38 <roboguy_> you might be able to manually unbox them and use a case statement that way to get some gain, hmm
20:14:35 * hackagebot aws-general 0.2.0 - Bindings for Amazon Web Services (AWS) General Reference  http://hackage.haskell.org/package/aws-general-0.2.0 (larsk)
20:22:11 <trap_exit> is there a latex slides package which does not take a quadcore machine to compile?
20:22:18 <trap_exit> wron gchannel
20:45:42 <SrPx> is there any obvious short way to express: "do { val <- boxedVal; case val of { }}" ?
20:46:26 <augur> is it possible to like
20:46:35 <augur> have an ST var thing
20:46:50 <augur> where the referred-to value is only some member of a class?
20:47:20 <SrPx> some member of a class?
20:48:22 <augur> like ST (Foo a => a)
20:48:52 <augur> but not quite
20:48:55 <augur> Foo a => ST a   ?
20:49:17 <augur> can you do that?   x :: Foo a => St a
20:49:38 <pavonia> Yes
20:50:14 <pavonia> > Just 123 >>= \case of { 123 -> return "foo" }
20:50:15 <lambdabot>  <hint>:1:15: parse error on input ‚Äòcase‚Äô
20:51:23 <pavonia> Wasn't there an extension for that?
20:51:58 <ReinH> SrPx: boxedVal >>= \case with the LambdaCase extension
20:51:58 <pavonia> > Just 123 >>= \case { 123 -> return "foo" }
20:52:00 <lambdabot>  <hint>:1:15: parse error on input ‚Äòcase‚Äô
20:52:03 <augur> but neither of those is quite right i think
20:52:13 <augur> St (exists a. Foo a => a)
20:52:16 <ReinH> pavonia: which lambdabot apparently doesn't have turned on
20:52:27 <pavonia> Looks like
20:52:27 <ReinH> well, it's \case -> anyway
20:52:48 <shachaf> No, \case -> is a syntax error.
20:52:52 <shachaf> It' s the second thing pavonia wrote.
20:53:05 <ReinH> Wait. No it isn't. Yeah.
20:53:56 <SrPx> (?)
20:54:24 <SrPx> got it
20:54:50 <SrPx> just (foo >= \case { 123 ‚Üí ... }) indeed
20:54:55 <SrPx> >>=
20:57:43 <SrPx> in Haskell, the more I write the less code I have
20:59:15 <SrPx> cut file size in half because I noticed a huge structure was completely irrelevant since most of its functionality could be replicated by simpler/existing functions ... that feels counterproductive
21:00:19 <SrPx> I wonder if eventually I will be left with 10 lines of code and then suddenly realize even those were already there, I just didn't know about it
21:01:11 <SrPx> so I will essentially close my file and declare: job done, 0 locs... on to next task
21:03:30 <kadoban> SrPx: "Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away."
21:03:49 <shachaf> i,i nothing is perfect
21:05:32 <ReinH> kadoban: -- Abraham Lincoln
21:06:27 <kadoban> ReinH: Heh, -- Some French Dude  IIRC
21:06:46 <SrPx> I'm the only one concerned that godel's nick is incomplete
21:07:26 <kadoban> Hah
21:07:34 <godel> SrPx: ?
21:08:03 <SrPx> godel: just being stupid nevermind
21:08:26 <geekosaur> √∂
21:08:43 <geekosaur> (irc nicks generally can't have those characters in them...
21:08:45 <geekosaur> )
21:10:38 <pavonia> (Could be rewritten as "goedel" if you really want)
21:17:31 <Zemyla> Well, hmm. After a little bit of theory work with pen and paper, lenses aren't functors. :V
21:17:50 <Zemyla> They'd have to be ExpFunctors.
21:19:20 <Zemyla> And while they are categories, they aren't arrows.
21:19:45 <Zemyla> For much the same reason they aren't functors, in fact.
21:24:48 <ab9rf> geekosaur: actually they can.  the reason why irc nicks can have []{}\| in them is because Way Back When, you used those characters to get umlauts :)
21:27:10 <Zemyla> I'm now trying to figure out if State s a :: s -> (s, a) is an arrow.
21:28:59 <Zemyla> Crud, I don't think it is/
21:29:40 <jle`> Zemyla: what kind of arrow? a haskell Arrow?
21:29:48 <Zemyla> Yeah.
21:30:40 <Hijiri> (s, a) -> (s, b) would be an arrow just because of kleisli
21:32:51 <Zemyla> f :: (a -> (a, b)) >>> g :: (b -> (b, c)) -> (a -> (a, c)) has to call (f a) = (a', b), and then (g b) = (b', c), and then it has to throw away b' because there's no place for it and return (a', c).
21:33:33 <Zemyla> But that means (arr id) >>> g does not return the same thing as g.
21:34:06 <Zemyla> It returns (b, c) instead of (b', c).
21:39:39 * hackagebot aws-kinesis 0.1.3 - Bindings for Amazon Kinesis  http://hackage.haskell.org/package/aws-kinesis-0.1.3 (larsk)
21:51:36 <SrPx> http://lpaste.net/119373 why this
21:52:40 <Eolus> my eyessss
21:53:23 <ab9rf> that looks like monomorphism restriction, but i'm not sure
21:53:35 <glguy> https://wiki.haskell.org/Monomorphism_restriction
21:53:37 <SrPx> Eolus: ?
21:53:37 <heatsink> SrPx: The monomorphism restriction requires GHC to choose a type
21:54:24 <heatsink> But why is add polymorphic when it doesn't have a type signature?
21:54:26 <dfeuer> SrPx, try   zero p = foldl' (\ _ _ -> 0) 0 p
21:55:05 <dfeuer> Or use NoMonomorphismRestriction.
21:55:17 <dfeuer> Or just write a type signature. Type signatures are *good*.
21:56:12 <ab9rf> there's an explanation of why in the monomorphism article on the wiki.  i'll let you read it instead of trying to explain it and failing and forcing shachaf to correct me :)
21:57:25 <Eolus> Sorry, those extra s's are cuz of lag
21:58:34 <SrPx> Thanks people, I get it (well not really, but I see it is complicated). dfeuer certainly, I was just wondering
21:59:54 <dfeuer> SrPx, there is reasons for monomorphism restriction, and there is reasons against it, and most of these reasons stop being issues at all if you just give everything at the top level a type signature.
22:00:04 <dfeuer> Which is generally considered good practice anyway.
22:01:13 <glguy> The short version is that something that looks like it's not a function shouldn't behave like its a function
22:01:25 <glguy> soif you see: x = ...
22:01:31 <glguy> then you should think that it gets evaluated once
22:01:36 <glguy> rather than at every use-site
22:01:42 <glguy> but if you see f x = ...
22:01:54 <glguy> You should expect it to recompute things at each use site
22:02:34 <mniip> 'x =' takes no arguments so there's only one result to memoize
22:02:40 <mniip> 'f x =' otoh
22:02:47 <glguy> Typeclass constraints, however, can make thinks that don't look like functions behave like them
22:03:24 <dfeuer> Witch oil comes dawn two "polymorphic values are all really functions, because they take type arguments".
22:04:49 <mniip> or you can pretend everything polymorphic has the resolved types of the polymorphic arguments appended to its name
22:04:50 <dfeuer> (except _|_, I guess)
22:05:21 <dfeuer> mniip, but that only works if GHC specializes them, right?
22:05:57 <mniip> it works in kind of the same way as your explanation
22:06:24 <dfeuer> Loose approximations of reality! High-five!
22:06:35 <mniip> just that 'pi_Float' and 'pi_Double' are different values
22:06:49 <mniip> as opposed to 'pi' being a function taking Float or Double
22:07:29 <dfeuer> mniip, except that pi_Float and pi_Double are values that could be saved across calls, whereas pi is a function whose return values won't be.
22:08:02 <mniip> the type argument you pass to 'pi' is defined at compile time so it's as good as differntly named values
22:08:07 <SrPx> dfeuer: I see, thanks!
22:08:11 <mniip> also what
22:08:20 <mniip> implying memoization
22:08:43 <dfeuer> Wait, what? The type is not necessarily known at compile time!
22:10:22 <bitemyapp> dfeuer: I know, it sucks.
22:11:11 <mniip> dfeuer, example?
22:11:17 <mniip> without ExistentialQuantification
22:11:22 <bitemyapp> dfeuer: sorry, I was replying to your SO comment.
22:11:48 <dfeuer> bitemyapp, uh .... which one?
22:12:07 <dfeuer> Oh, this SQL thingum.
22:12:52 <glguy> mniip: When you compile a library function you might not know what type it will be used at
22:13:35 <glguy> but any operations required for that type will be passed in as parameters, so its OK
22:13:49 <dfeuer> glguy, the type also may actually not be fixed, although in that context you're screwed for memoization anyway.
22:14:11 <dfeuer> [if you have polymorphic recursion going on]
22:18:23 <mniip> polymorphic recursion isn't something that I can imagine at 5 am
22:18:35 <mniip> cya
22:18:40 <jle`> night mniip
22:20:27 <Axman6> > let showthing a = shows a (showthing (a,a)) in showthing 1
22:20:28 <lambdabot>  Occurs check: cannot construct the infinite type: t ~ (t, t2)
22:20:29 <lambdabot>  Relevant bindings include
22:20:29 <lambdabot>    a :: (t, t2) (bound at <interactive>:1:15)
22:21:06 <Axman6> > let  showthing :: Show a => a -> String; showthing a = shows a (showthing (a,a)) in showthing 1
22:21:08 <lambdabot>  "1(1,1)((1,1),(1,1))(((1,1),(1,1)),((1,1),(1,1)))((((1,1),(1,1)),((1,1),(1,1...
22:21:29 <dfeuer> There ya go, mniip.
22:21:37 <dfeuer> Axman6 demonstrated it.
22:21:50 <Axman6> (the result string is not important)
22:22:26 <Axman6> Finger trees use some form of polymoprphic recursion too
22:22:43 <Zemyla> Hmm. How exactly do rank-N types work in compilation? :O
22:22:57 <MP2E> similar to magnets! [/badjoke]
22:23:08 <dfeuer> Magnets?
22:23:43 <MP2E> there's a meme based off a song that goes 'fucking magnets, how do they work?' :P
22:23:45 <kadoban> dfeuer: It's a meme referencing a retarded ICP song I believe.
22:23:51 <opqdonut> Zemyla: they're a feature of the type system, they disappear on compilation
22:23:58 <MP2E> Ah
22:24:14 <opqdonut> Zemyla: basically rank n types let you type more programs that would've worked just fine in untyped lambda calculus
22:25:40 <mniip> fancy words
22:25:41 <mniip> zzz
22:26:14 <opqdonut> Zemyla: if you're interested in how the type checking/inference works, the ghc user guide has some pointers
22:26:29 <opqdonut> ( https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/other-type-extensions.html )
22:29:15 <dfeuer> Rank n types also let you limit what sorts of things can be passed in. ST uses this For Great Justice.
22:51:48 <bitemyapp> dfeuer: yeah I don't know what to do.
22:52:38 <dfeuer> And I don't know where, and I don't know where.
22:52:50 <dfeuer> bitemyapp, about databases? Write your own framework maybe?
22:53:20 <bitemyapp> dfeuer: I'm not sure if there's a good way to represent SQL queries <--> Models faithfully in the type system.
22:53:44 <bitemyapp> dfeuer: I also haven't been able to find any research on it that looked useful
22:53:55 * dfeuer knows so little about it that it's not even funny.
23:07:34 <Lokathor> good news: hscurses seems to resize the window automatically if the terminal size changes without me having to do that. bad news: it includes features to detect KeyResize events and change the size, without mentioning that normally it's automatic anyway, which makes it seem spooky
23:09:42 * hackagebot Strafunski-StrategyLib 5.0.0.7 - Library for strategic programming  http://hackage.haskell.org/package/Strafunski-StrategyLib-5.0.0.7 (JamesKoppel)
23:57:04 <atec> just started learning haskell about 10 minutes ago, messing around in ghci. Quick question if anyone is on here. if I have c = [1,2,3,[4,5,6]], why can't I prepend and element like this 0:c
23:57:23 <atec> an*
23:58:41 <shachaf> [1,2,3,[4,5,6]] is probably not what you think it is.
23:58:51 <shachaf> Every element of a list in Haskell has to be of the same type.
23:59:49 <shachaf> (The answer to "why can't I ...?" is usually "I don't know, why don't you tell us?". E.g. with your complete code and error message, so people don't have to guess what you're doing.)
