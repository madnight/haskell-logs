00:00:03 <EvanR> jTT_: check iconv
00:00:17 <jTT_> cheers!
00:00:33 <calvinx> commonly used I suppose?
00:01:18 <Zemyla> EvanR: Woo, I now have a working accurate exponentiation function for Fixed.
00:02:15 <EvanR> calvinx: like i said, works for small stuff. but people sometimes want a "master monad" to write their entire application in, sort of like you were working in a classic imperative environment or something
00:02:39 <EvanR> and the single behaviors of those monads isnt enough
00:02:48 <EvanR> not to mention they are non-IO
00:03:06 <Zemyla> That's what monad transformers are for.
00:03:28 <EvanR> monad transformers exist
00:03:38 <Zemyla> You use monad transformers to Voltron together all your monads and get SUPERMONAD.
00:04:09 <EvanR> complete with the obligatory violence
00:10:33 * hackagebot chell 0.4.0.1 - A simple and intuitive library for automated testing.  http://hackage.haskell.org/package/chell-0.4.0.1 (JohnMillikin)
00:10:33 * hackagebot dbus 0.10.9.1 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-0.10.9.1 (JohnMillikin)
00:13:10 <karshan> > :t ($)
00:13:11 <lambdabot>  <hint>:1:1: parse error on input ‘:’
00:13:16 <karshan> > ($)
00:13:18 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
00:13:18 <lambdabot>    arising from a use of ‘M474629423290442523821511.show_M4746294232904425238...
00:13:18 <lambdabot>  The type variable ‘b0’ is ambiguous
00:13:29 <EvanR> :t ($)
00:13:30 <lambdabot> (a -> b) -> a -> b
00:13:38 <karshan> :t (flip . flip) id
00:13:39 <lambdabot> (a -> c) -> a -> c
00:13:45 <karshan> :)
00:14:08 <EvanR> > f `id` x
00:14:09 <lambdabot>  No instance for (GHC.Show.Show a0)
00:14:10 <lambdabot>    arising from a use of ‘M50296234526998117621550.show_M50296234526998117621...
00:14:10 <lambdabot>  The type variable ‘a0’ is ambiguous
00:14:14 <EvanR> FFFFUUUUU
00:14:26 <karshan> I just realized this after using pointfree on something random. flip id == flip ($)
00:14:38 <EvanR> also id = ($)
00:14:39 <karshan> :t flip ($)
00:14:40 <lambdabot> b -> (b -> c) -> c
00:14:45 <karshan> lulz
00:14:49 <karshan> oh I'm so stupid
00:14:59 <matematikaadit> :t id `asTypeOf` ($)
00:15:00 <lambdabot> (a -> b) -> a -> b
00:15:08 <karshan> :t asTypeOf
00:15:09 <lambdabot> a -> a -> a
00:15:19 <karshan> @src asTypeOf
00:15:19 <lambdabot> asTypeOf = const
00:15:28 <karshan> ah wonderful
00:15:31 <EvanR> its trolling you
00:15:47 <matematikaadit> asAppliedTo also const
00:16:00 <matematikaadit> :t id `asAppliedTo` Nothing
00:16:01 <lambdabot> Maybe a -> Maybe a
00:16:27 <EvanR> :t id `asAppliedTo` undefined
00:16:28 <lambdabot> b -> b
00:17:00 <matematikaadit> :t asAppliedTo
00:17:00 <Zemyla> :t asAppliedTo
00:17:00 <karshan> so what do you think is better. filter (and . flip map [all (`elem` chars) . drop 4, ("stx=" ==) . take 4] . flip id) . map (take 56) . tails
00:17:01 <lambdabot> (a -> b) -> a -> a -> b
00:17:01 <lambdabot> (a -> b) -> a -> a -> b
00:17:08 <karshan> or /stx=[a-f0-9]{56}/g
00:17:24 <EvanR> dont use regex, and dont do whatever that was above
00:17:30 <karshan> :(
00:17:32 <Zemyla> :t flip asAppliedTo
00:17:33 <lambdabot> b -> (b -> b1) -> b -> b1
00:17:33 <calvinx> LOL. monad transformers. my gawd. I have a splitting headache as-is.
00:17:34 <matematikaadit> karshan: parser combinator
00:17:55 <karshan> matematikaadit: you are right
00:18:03 <karshan> time to learn parsec
00:18:18 <EvanR> string "stx=" >> replicateM 56 hex
00:18:43 <matematikaadit> string "stx=" ...
00:18:46 <matematikaadit> ah, EvanR beat me
00:19:00 <EvanR> calvinx: theres another awesome monad, parsers ;)
00:19:14 <calvinx> Parsec?
00:19:15 <karshan> EvanR: that is awesome, I love it.
00:19:33 <karshan> so much better than regex
00:19:33 <tdammers> how about ParsecT... that's even a monad transformer
00:20:04 <calvinx> Isn’t the parser monad using pattern matching under the hood as well? How’s that different from regex?
00:20:09 <EvanR> ParsecT is like the dragon zord that comes out of no where yet is totally compatible with the existing megazord
00:20:27 <calvinx> LOL.
00:20:30 <karshan> is it possible to combine 3 monads ? e.g. State Maybe IO
00:20:39 <karshan> does it make sense ?
00:20:42 <tdammers> karshan: yes, almost
00:20:45 <EvanR> they stack to whatever godawful depth ;)
00:20:48 <tdammers> StateT s MaybeT IO
00:21:06 <tdammers> or, alternatively, MaybeT StateT s IO
00:21:19 <matematikaadit> @bf +++++[>+++++[>+++>+++<<-]<-]>>+.>++++.<.
00:21:19 <lambdabot>   LOL
00:21:21 <karshan> hmm, are they isomorphic ?
00:21:39 <tdammers> no. stacking order matters.
00:22:17 <karshan> yea that makes sense, I will play with that tomorrow
00:22:31 <tdammers> although as long as you only ever use the monad stack as a whole, the only practical difference is how many calls to lift you have to use
00:22:53 <tdammers> and the order in which you have to compose your runSomething functions to "unpack" the monad
00:23:10 <ab9rf> you can combine monads bascially indefinitely, althgough it gets thoroughly confusing afdter a while
00:23:13 <ab9rf> \
00:23:16 <ab9rf> erk
00:23:46 <EvanR> all youll ever need is ReaderT IO!
00:24:16 <EvanR> for "globals" and missile launching
00:24:25 <ab9rf> heh
00:24:36 <EvanR> and throwing exceptions
00:24:40 <ab9rf> ew
00:25:27 * hackagebot extensible 0.2.2 - Poly-kinded, extensible ADTs  http://hackage.haskell.org/package/extensible-0.2.2 (FumiakiKinoshita)
00:26:31 <Zemyla> Is it bad if I trace execution of recursive functions with unsafePerformIO $ print x?
00:26:41 <EvanR> Debug.Trace.trace
00:26:45 <Zemyla> Is there something I should use instead?
00:26:47 <karshan> Zemyla: why not Debug.trace
00:26:47 <tdammers> type IGiveUp = RWST a b c IO
00:27:02 <Zemyla> Because I didn't know about it.
00:27:36 <ab9rf> the kitchen sink monad
00:27:38 <calvinx> going to grab a bite and taking a break from the brain melting Monad lession by EvanR just now. Thanks so much EvanR. Catch you later.
00:27:39 <EvanR> RWST a b c (ParsecT s MaybeT)
00:27:44 <calvinx> *lesson
00:27:47 <EvanR> ErrorT
00:27:55 <EvanR> ListT
00:27:57 <ab9rf> not to be conbfused with the kitchen source monad
00:28:08 <EvanR> ContT
00:28:13 <EvanR> IO
00:28:19 <tdammers> PHPT IO
00:28:35 <EvanR> PHP would be a bad ass monad
00:28:45 <ab9rf> "ass monad"
00:28:50 <EvanR> looool
00:28:52 <barrucadu> Or an ass-bad monad
00:28:52 <karshan> oh by the way guys. Codec.Crypto.AES which is in haskell platform, has a function crypt that takes lazy bytestrings and does AES. it fails if you give it a lazy bytestring that hasn't been forced
00:29:01 <ab9rf> karshan: oops
00:29:14 <tdammers> oy
00:29:40 <Zemyla> karshan: How does it do that?
00:30:38 <karshan> Zemyla: I think the problem is here: crypt (BL.toChunks -> chunks) = snd <$> listen (mapM_ crypt chunks)
00:31:02 <karshan> or atleast I don't understand that pattern matching
00:33:06 <lieven> looks like the view pattern extension
00:33:47 <gamegoblin> Is there a datastructure I can construct at runtime that would be as fast as making a function with special cases for all possible inputs? e.g. if my function maps the numbers 1 to 100 to some function of that number, it’s easy to write a script to generate 100 lines of code like f 1 = 1337; f 2 = 31415; f 3 = 911; etc. Is there a datastructure I can create at runtime that can dispatch as quickly as this giant pattern matching function?
00:33:57 <gamegoblin> I’m sure Data.Map is significantly slower
00:34:02 <karshan> lieven: yup it says it uses that extension in the cabal file
00:34:11 <gamegoblin> I suspect the giant pattern matching function compiles to a branch table, though I’m not sure
00:34:27 <EvanR> gamegoblin: use IntMap, i dont know how fast a 100 case function would be
00:34:53 <shachaf> You could find out easily enough.
00:35:07 <shachaf> And you could measure Map and IntMap and so on.
00:35:28 <EvanR> and spawn a thread for each number
00:37:55 <karshan> EvanR: so is this acceptable: rights . map ((parse $ string "stx=" >> replicateM 56 hexDigit) "") . tails
00:38:21 <EvanR> tails?
00:38:57 <karshan> hehe, I'm running the parser starting from every character in the search space string
00:38:58 <Zemyla> He wants to try it for each start.
00:39:21 <karshan> I want all strings that match /stx=[a-f0-9]{56}/
00:40:08 <EvanR> that will reparse over the chunk that you already found ~56 times
00:40:17 <EvanR> and not find anything
00:40:21 <gamegoblin> If my integer keys were all from 0..n, would a vector not be more efficient than an intmap?
00:40:30 <karshan> hmm, it does work for me. but I realize it is inefficient
00:41:42 <EvanR> karshan: so, you can use that parser in a bigger parser that repeatedly tries to match this in the stream and gives the list of matches
00:42:20 <karshan> EvanR: yea that sounds like exactly what I want to do. But I've never used parsec before, so I'm unsure of how to do that
00:42:46 <EvanR> are they next to each other?
00:43:07 <EvanR> theres combinators like many and sepBy to do this
00:43:10 <karshan> nope
00:43:18 <karshan> I could use "try"
00:43:37 <karshan> actually no thats not what I want
00:44:15 <EvanR> you want to skip to the first s, this requires no lookahead, then sepBy a parser for whatever could separate them
00:45:45 <karshan> EvanR: alright, that makes sense.
00:45:45 <EvanR> use the sep parser for the skip
01:01:59 <lpaste> asdfdf pasted “errors with TLS?” at http://lpaste.net/118358
01:03:55 <asdfdf> Hi guys. I am having an issue with conduit-http and TLS. I keep getting a FailedConnectionException with code that seems pretty much copy and paste from some tutorials. All I'm trying to do is load up https://google.com. Here is my code. http://lpaste.net/118358 The specific exception is just FailedConnectionException. I was wondering if there was a good way to debug this? Running tls-simpleclient installed in the same cabal sandbox agianst google.co
01:03:56 <asdfdf> m seems to work just fine.
01:13:09 <sgronblo> Does anybody happen to be in Tokyo?
01:15:18 <shachaf> About 10 million people. But maybe try #haskell.jp
01:16:19 <shachaf> Maybe #tsurucapital would know too.
01:17:20 <Freundlich> sgronblo: Why do you ask?
01:22:00 <sgronblo> Freundlich: just wondering if anyone is interested in joining our haskell meetup
01:27:43 <muzzle> hi, i have a problem in one of my cabal projects. During linking a test suite cabal tells me Undefined symbols for architecture x86_64:
01:27:43 <muzzle>   "_interlangzmtestzm0zi1zi0zi0_ParseziMJLex_alexScanTokens_closure", referenced from:
01:27:54 <muzzle> has anyone got an idea how i can fix this
01:31:22 <calvinx> you might have a private module that wasn’t included in your `exposed-module` section in your cabal file?
01:34:05 <calvinx> There’s something similar here - https://github.com/haskell/cabal/issues/1759 - so I reckon it is likely that something is missing from your cabal file.
01:38:58 <bergmark> muzzle: sometimes i've also noticed that cabal gets confused and tries to find the symbol from a previously installed version of the package
01:45:14 <muzzle> i didn't install it
01:45:20 <muzzle> it's a project of my own
01:45:24 <muzzle> i just want to build it
01:45:40 <muzzle> i included all modules as exposed
01:45:48 <muzzle> in the library portion of the .cabal file
01:46:31 <muzzle> and the strangest thing is, that the executable includes the problematic symbol too, and it links just fine
01:48:01 <tdammers> question here; is it possible to completely static-link a Haskell program, including stuff like libgmp?
01:48:22 <tdammers> (debian or similar, in case it matters)
02:09:28 <ab9rf> tdammers: probably, you'd have to pass the appropriate ld flag through
02:09:37 <tdammers> ah, hmm
02:09:46 <ab9rf> -Bstatic, iirc
02:10:19 <tdammers> 'cause with the thing I'm building, I want to be able to tell people to just download the appropriate binary and throw it on their server, and it should work without any system-level library dependencies
02:10:25 <ab9rf> ghc has -static, which does the same thing, i believe
02:10:43 <matematikaadit> tdammers: ghc -static -optc-static -optl-static -optl-pthread
02:11:17 <ab9rf> -static is just the ghc libs, i think
02:12:03 <tdammers> matematikaadit: looks impressive, so I'm assuming it'll work :D
02:12:35 <ab9rf> -optl forces an option through to the loader
02:13:10 <ab9rf> -optc is for the C compiler, in the event ghc uses it
02:13:13 <matematikaadit> -optc will pass the option to the compiler, -optl to the linker
02:13:16 <merijn> GHC does static by default for haskell libraries, although that still leaves you with C libraries missing
02:13:56 <tdammers> merijn: yes, I know. It's the C libraries that I'm worried about.
02:14:18 <matematikaadit> well, you could always checking it with ldd [your_binnary]
02:14:20 <ab9rf> tdammers: the -optl-static should force the loader to create a fully static final
02:14:20 <merijn> tdammers: I think by default GHC only depends on libc and libgmp
02:14:21 <tdammers> merijn: one of the use cases is going to involve running on a managed web server, without needing root privileges, ever
02:14:41 <ab9rf> you can often relink a dynamic executable to resolve its dynamic references, too
02:14:47 <ab9rf> although it's been ages since i did that
02:14:48 <tdammers> merijn: libc I can live with as a dependency, but I can't rely on libgmp being installed
02:15:07 <ab9rf> (ld -o prog.static -static prog)
02:16:53 <ab9rf> tdammers: you can force just libgmp to be linked in using ldfu but i don't remember how to do that anymore
02:17:12 <ab9rf> probably by explicitly listing its .a file
02:17:30 <tdammers> ab9rf: at some point it's probably going to be more than just libgmp, so the "static link everything" approach is fine
02:17:49 <ab9rf> libc is smallish by comparison anyhow
02:17:57 <tdammers> yup
02:18:14 <tdammers> also, so many flavors of it around that I might as well link to a known fixed point
02:18:34 <ab9rf> i remember at one point i had a system that was actively using five different libc flavors
02:19:51 <ab9rf> i spent a couple of weeks hunting down each one of the ones still using libc4 and rebuilding the affected app from source to get rid of the dependency :)
02:28:03 <tdammers> oh joy
02:28:25 <tdammers> so anyway, if I run readelf -h on my binary, and it doesn't list any dependencies, then I'm good, right?
02:28:50 <tdammers> s/-h/-l/
02:31:35 <tdammers> ah, no, seems like I need readelf -d -t
02:34:43 <merijn> tdammers: Run "ldd"
02:35:02 <merijn> No clue what readelf does (beyond, presumably, reading ELF files...)
02:35:06 <tdammers> "not a dynamic executable" :D
02:35:21 <tdammers> readelf reads ELF files and dumps all sorts of information in textual format
02:35:46 <Zemyla> Nifty, I now have an instance of pi for Fixed.
02:36:13 <matematikaadit> or use: $ file bin
02:36:51 <tdammers> looks good
02:36:56 <tdammers> says "statically linked"
02:37:15 <merijn> If ldd doesn't print any libraries, you're done
02:37:20 <tdammers> hum, apparently my stripped binary is 16 MiB
02:37:42 <tdammers> tad bit more than a typical PHP script :D
02:38:11 <merijn> tdammers: Actually, you can shrink it by having GHC built a seperate object file per function
02:38:30 <merijn> That way you only end up linking and including functions you actually use, instead of entire libraries
02:39:06 <merijn> tdammers: Look into -split-objs
02:39:23 <tdammers> since I'm fiddling with ghc-options anyway, yeah, will do
02:40:05 <merijn> Also, people should stop complaining about big binary sizes, disk space is cheap :p
02:40:23 <tdammers> disk space is cheap, but downloads aren't instant
02:41:12 <merijn> True, but still, 16mb is nothing
02:41:15 <tzaeru> people should stop complaining about code speed. CPUs are cheap! people should stop complaining about code readability. we're living longer than before, so we've plenty of time to read it!
02:41:17 <tdammers> besides, I'm not really complaining
02:41:25 <merijn> Unless you live in the US, in which case "haha, your internet sucks"
02:41:31 <tdammers> but if I can get the size down, all the better
02:41:54 <merijn> tzaeru: Having spent 4.5 months doing HPC coding I can say "CPUs are super fast and whatever you think is slow is wrong"
02:41:59 <merijn> Also
02:42:06 <merijn> "arrays are the universal data structure"
02:42:33 <tzaeru> :-P it's a beautiful thought.
02:42:45 <tdammers> point in case: raw cpu speed is rarely the bottleneck these days
02:43:18 <tdammers> remember when we used to optimize our code based on CPU clock ticks?
02:43:34 <tzaeru> well, it rarely ends up as the bottleneck, but we very rarely write the heavy stuff ourselves.
02:43:49 <tzaeru> if we did, then we would have to do at least basic optimization with our data structure choices and so on
02:44:22 <tdammers> data structure choices are still very relevant
02:44:55 <merijn> tzaeru: Hence my remark
02:45:03 <merijn> "arrays are the unviersal data structure"
02:45:15 <merijn> All these fancy "efficient" data structures are way too slow
02:45:24 <Zemyla> tdammers: The constant term on big-O functions rarely matters, but the growth rate certainly does.
02:45:41 <tzaeru> merijn, is that somekinda joke that I don't get? :/
02:45:43 <bloxxxx> can anyone help me with the following: implementing type classes, in my slides there is: no need to tag runtime value (a la OOP), because we have static typing (values are not typed)?
02:45:56 <solatis> merijn: that sounds almost like php
02:45:56 <merijn> tzaeru: No, it's true. "I need a collection where I can iterate over elements in sorted order" 'oh, you need a min priority heap'
02:46:06 <solatis> but rather, "map is the universal data structure"
02:46:25 <merijn> tzaeru: Except that, replacing my min priority heap with "array + sort, then iterate" was about 2 orders of magnitude faster
02:46:26 <tdammers> except that in PHP, the universal data structure sucks big time
02:46:56 <tdammers> merijn: I think the issue there is that "premature optimization is the root of all evil" (or, if you prefer, "if in doubt, use brute force")
02:47:08 <solatis> tdammers: urgh please stop that quote
02:47:08 <merijn> bloxxxx: The reason you don't need type tagging is because there is no instance-of/type casing
02:47:14 <tzaeru> merijn, well, I'll wait for the raycaster or collision detection system or so on that relies on flat, one-dimensional array for its data structure :P
02:47:15 <tdammers> mwahaha
02:47:21 <solatis> it's a pet peeve of mine, but that is *not* what he said dammit
02:47:22 <merijn> bloxxxx: Therefore control flow can NEVER depend on the type of a value
02:47:32 <tdammers> I know
02:47:42 <merijn> tdammers: The heap was actually much easier to implement
02:47:54 <tdammers> and it's abused as an excuse to write shitty code that performs badly all the time
02:48:20 <tdammers> merijn: it was? huh.
02:48:21 <merijn> tzaeru: collission detection is hardly HPC, though :p
02:48:33 <solatis> tdammers: exactly, i'm looking at you, ruby on rails developers
02:48:36 <merijn> tdammers: C++ STL all up in this thing :>
02:48:46 <tdammers> merijn: ah, right :D
02:49:15 <tzaeru> didn't the original paper that the quote is from go to define that "premature optimization" mostly means stuff like switching in binary operations and fiddling with specific data types and all around switching readability to arcane? :P
02:49:23 * solatis is waiting for haskell to magically transform code to make use of a GPU and beat every other language in every performance benchmark
02:49:27 <tdammers> merijn: "use an STL container and its built-in functionality" vs. "use an STL container and a bunch of custom iteration code"
02:49:42 <merijn> bloxxxx: As for typeclasses, the dictionary of arguments just gets translated into an explicitly passed argument to a function. Unless the type is statically known, in which case GHC can simply inline the typeclass function
02:50:02 <tzaeru> solatis, utilizing the GPU wouldn't help in beating *every* performance benchmark.
02:50:09 <bloxxxx> merijn ok thanks i get it :)
02:50:37 <solatis> tzaeru: i know, i was just talking crap in the same line of 'arrays are the universal data structure' and 'premature optimization is the root of all evil'
02:50:40 <merijn> bloxxxx: This is a good example of how GHC implements typeclasses (note, this is not the only way to do it, but one of the easier ones)
02:50:50 <tzaeru> solatis, oh ^^
02:50:52 <merijn> @google gabriel gonzalez scrap your typeclasses
02:50:53 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
02:50:54 <lambdabot> Title: Haskell for all: Scrap your type classes
02:51:08 <tdammers> btw, doing the -split-objs thing doesn't seem to change a thing in my case
02:51:11 <tzaeru> it'd be pretty funny to secretly generate parallized code for the GPU in some benchmarks tho >:D
02:51:23 <tzaeru> "check this! ruby is 100x faster than c, haha!"
02:51:25 <merijn> bloxxxx: GHC does basically that, except it implicitly handles all the dictionary passing for you :)
02:51:58 <merijn> I would argue that using the GPU won't help in beating *most* performance benchmarks
02:52:22 <merijn> tdammers: Might need to use it transitively on all your dependencies :>
02:52:28 <merijn> tdammers: Dunno if cabal supports that
02:52:35 <merijn> It very well might
02:52:58 <solatis> well, it's pretty funny how the bitcoin community has been able to make the GPU do "normal" calculations earlier deemed as impossible
02:53:27 <tzaeru> the "premature optimization is the root of all evil" is pretty close to correct in itself, though. it does have that "premature" in it.
02:53:40 <solatis> specifically, scrypt
02:53:52 <solatis> that was always thought to be impossible to implement in a GPU
02:54:05 <merijn> solatis: scrypt isn't impossible to implement on the GPU
02:54:24 <solatis> people always considered scrypt to be a 'GPU-safe' hashing algo
02:54:28 <merijn> solatis: The goal of scrypt is: unlike bcrypt the workfactor increases computation *and* memory use
02:54:38 <solatis> yeah i know about scrypt
02:54:49 <merijn> That means that cracking in parallel on a GPU is pretty inefficient for high workfactors
02:54:56 <solatis> but it had been designed with the purpose of being unable to do in RISC and GPU
02:55:08 <merijn> Everything is RISC these days
02:55:12 <tdammers> merijn: nice link :D looks a lot like something I've been doing a lot lately, but he's taking it a bit further and thinking it through more
02:55:12 <Myrl> Unable to do in RISC?
02:55:29 <solatis> http://www.tarsnap.com/scrypt.html
02:55:42 <merijn> I don't think a single non-RISC architecture is around these days
02:55:50 <tdammers> merijn: and the strip thing; executable size isn't important enough for me to dig any further so I'll just leave it at this for now
02:55:51 <solatis> "The scrypt key derivation function was originally developed for use in the Tarsnap online backup system and is designed to be far more secure against hardware brute-force attacks than alternative functions such as PBKDF2 or bcrypt."
02:55:52 <Myrl> merijn: x86
02:55:57 <merijn> Myrl: RISC inside
02:56:04 <merijn> Myrl: Just had a verbose wrapper around it
02:56:08 <Myrl> merijn: I know, but the exposed interface is still CISC.
02:57:19 <ab9rf> yeah, ther's no way that x86 is a "risc" architecture, even if the underlying microcode is
02:58:00 <merijn> The point is, "not possible to do in RISC" is silly, because even CISC architectures are RISC inside
02:58:05 <ab9rf> it's not quite as crazily cisc as VAX-11 or MC68K, but it's not RISC
02:58:33 <ab9rf> merijn: "not possible to do in RISC"?  what, is someone alleging that RISC architectures aren't turing-equivalent now?
02:59:15 <solatis> haha
02:59:22 <Myrl> ab9rf: hahaha
02:59:28 <tdammers> there are varying degrees of "possible"
02:59:45 <solatis> well, the point being that there is no "cheap brute-force risc alternative"
02:59:54 <tdammers> (or rather, different kinds of "impossible")
03:00:10 <solatis> there is a very, very cheap risc alternative compared to cpu for sha256, for example
03:00:15 <solatis> which is trillions of times faster
03:00:41 <tdammers> and, indeed, the question when it comes to crypto things, is not "is this possible", but "is it possible to do this faster than brute-force"
03:00:42 <tzaeru> isn't scrypt kinda poorly parallizable bu the task of generating a ton of hashes with it is rather parallizable :P
03:00:45 <solatis> but because of memory constraints, you still have to spend a lot of money on a RISC-alternative for scrypt
03:01:06 <tzaeru> I think simply moving trivial scrypt algorithm for CPU to GPU already made generation much, much faster, so that part wasn't very arcane at all..
03:01:16 <tdammers> tzaeru: the task of generating a ton of hashes is always inherently parallelizable
03:01:24 <merijn> ab9rf: eh
03:01:25 <solatis> tzaeru: i'm not sure, but i thought one input depended on the output of another
03:01:37 <tzaeru> not in the actual generation of the hashes, I don't think?
03:01:39 <merijn> ab9rf: considering there's no such thing as turing complete hardware, that'd be accurate
03:01:42 <solatis> with sha256, that is not the case
03:01:49 <merijn> In fact, it's impossible for hardware to be turing complete
03:01:50 <tdammers> tzaeru: not the generation of an individual hash
03:02:01 <ab9rf> if the idea is to have an algorithm that is difficult to compute efficiently on commonly-available architectures, that's probably pointless in anything other than the short term
03:02:10 <ab9rf> merijn: yes, indeed.
03:02:23 <tdammers> tzaeru: but if you are generating millions of hashes, the entire thing is inherently parallelizable
03:02:27 <merijn> But, it's lunch time, so no time for this discussion :)
03:02:34 <tzaeru> tdammers, I thought that that to generation of one hash, it doesn't matter at all what the previous generation gave
03:02:52 <merijn> tdammers: Except when every hash computation takes a prohibitive amount of memory, preventing you from running more than a few in parallel :)
03:02:57 <merijn> Which is the point of scrypt
03:03:00 <tdammers> yes
03:03:06 <ab9rf> if you have a task that requires doing the same thing a bunch of independently different ways, then you can parallelize that, regardless of what "that" is
03:03:19 <tzaeru> that is.. you can generate all the hashes you want to at the same time and hope you got lucky! :P
03:03:34 <tdammers> but you can still make hash generation faster by throwing more hardware at it, in a linear fashion
03:03:39 <ab9rf> how much memory are we talking about?
03:03:45 <ab9rf> memory is buttcheap these days
03:03:49 <tdammers> tzaeru: yes, that's what brute-forcing entails
03:03:51 <tzaeru> a single hash generation runs in a single invocation, right?
03:05:51 <tzaeru> well, anyway -- I was actually recently testing some audio analysis algorithms on the GPU and even when I did an obnoxious amount of unique texture lookups in a single invocation (talking past ten thousand), it was still a few times faster than on the CPU when the amount of parallel invocations was high and would been done without parallezation on the CPU.
03:06:09 <tzaeru> in that respect, GPUs from past few years have been gotten pretty damn far ^_
03:06:13 <tzaeru> *^_^
03:06:25 <ab9rf> so there are ASICs implementing scrypt now, regardless :)
03:06:52 <tzaeru> yeah.
03:06:56 <bloxxxx> but i don't get, they say static typing (i.e. values are not typed), in static typing each value DOES have a type as opposed to dynamic typing? what am i missing here :/
03:07:02 <tzaeru> I don't really personally understand the whole point of the mining part in bitcoins
03:07:07 <ab9rf> tzaeru: greed
03:07:48 <tzaeru> myeah. bitcoin people also overpronounce the status of currency in fair (or unfair) and just (or, unjust) economy.
03:08:14 <tzaeru> it doesn't really matter how the currency works, if a small group owns the vast majority of it, they control markets anyway :P
03:08:16 <ab9rf> tzaeru: bitcoin brings out the worst in some people.  it's a bit unsettling to watch.
03:08:23 <tzaeru> and through that, control prices more or less.
03:08:35 <ab9rf> anyhow, off topic
03:08:37 <RchrdB> bloxxxx: you don't necessarily have to have the types of the values represented in any concrete form at runtime.
03:09:18 <ab9rf> bloxxxx: in static typing the runtime doesn't track the types of values because it already knows what they are
03:09:33 <RchrdB> *doesn't necessarily track the types of values
03:09:41 <bloxxxx> oh i see
03:09:43 <RchrdB> it could track the types of values even though it doesn't necessarily need to
03:09:45 <bloxxxx> thanks haha :D
03:10:13 <ab9rf> well, yeah, it might (either for debugging purposes, or because the value is an instance of an ADT or something similar)
03:10:47 <ab9rf> in a dynamic language, you can ask it to add an apple to an airplane, and get some meaningless result
03:11:05 <ab9rf> in a statically-typed language, an effort to add a fruit to a vehicle would simply fail to typecheck
03:11:35 <ab9rf> and the code would never be compiled in the first place
03:16:35 <Voldenet> dynamically-typed language are harder to debug
03:16:40 <Myrl> Voldenet: ++
03:16:54 <Voldenet> It makes people hate the language usually
03:17:02 <Voldenet> it's nice when you think about boilerplates etc. but
03:17:08 <ab9rf> especially when there are implicit conversions that do weird things
03:17:16 <Voldenet> Yeah
03:17:20 <Voldenet> PHP
03:17:22 <Voldenet> We all love it.
03:17:24 <Voldenet> Or JS
03:17:26 <Voldenet> []+{}?
03:17:36 <ab9rf> i'm not sure which is worse, although it's probablyh PHP
03:17:47 <Voldenet> PHP is saner
03:17:55 <ab9rf> no, it really isn't
03:17:56 <Voldenet> it will not tell you that
03:18:01 <Voldenet> []+{} = string
03:18:06 <Myrl> lol
03:18:08 <Voldenet> or {}+[] = Not a number
03:18:09 <ab9rf> some of the bizarre things it does with string to integer conversions are wild
03:18:58 <ab9rf> honestly, i think something like {}+[] should launch a missile at the developer's principal residence
03:19:08 <Voldenet> :D
03:19:11 <Chathurga> PHP is certainly less sane than javascript
03:19:25 <Voldenet> but well PHP is classic
03:19:31 <Voldenet> of "all the things I hate"
03:19:59 <Voldenet> [x] No convention in even basic methods naming
03:20:16 <Voldenet> [x] User-defined wild globals can be enabled with configs
03:20:22 <Myrl> Voldenet: strlen as hash function? :D
03:20:37 <Voldenet> Hey, whatever works! :D
03:20:47 <Voldenet> It worked in tests
03:20:56 <Myrl> lol
03:20:59 <Voldenet> I added "banana" and "apple" and they didn't collide
03:21:07 <Voldenet> I _DID_ TESTS, IT CAN'T BE BROKEN
03:21:13 <Myrl> totally safe
03:21:48 <Voldenet> but seriously, dynamic types are bad, I always hate working with them
03:22:04 <Myrl> I agree with Voldenet.
03:22:17 <ab9rf> i dislike the unpredictability that they represent
03:22:24 <Voldenet> ^ this
03:22:38 <Myrl> First, you have a string
03:22:40 <ab9rf> "This code works as long as both arguments are integers.  But if one is a string, hell, I dunno."
03:22:41 <Voldenet> This is /usually/ a number, but can be an array or an object
03:22:57 <Myrl> Next thing you know, you have a tuple fo an arry of integers encoded as strings
03:22:58 <Chathurga> I don't understand why someone would want them anymore, I can't even think of a reason
03:22:59 <rom1504> it's too easy to say dynamic types are bad on #haskell, try the same on #php :p
03:23:07 <Chathurga> And I cut my teeth on JS and PHP
03:23:09 <Voldenet> }:->
03:23:13 <Myrl> rom1504: Exactly what I'm going to do.
03:23:19 <Voldenet> lemme join #php
03:23:25 <ab9rf> also, there are the evil people who write code that uses the type of an argument or variable as an "extra variable"
03:23:47 <Chathurga> All of PHPs sorts sort in place
03:23:53 <agocorona> Hi: a question: there is a common designation for  applicative, alternative and monadic computation?   categorical computation or something like that?
03:24:05 <ab9rf> rom1504: oh, i tend to get things thrown at me by PHP programmers because i say things like that
03:25:01 <rom1504> :)))
03:25:06 <Myrl> rom1504: They didn't react. :D
03:25:08 <ab9rf> not that i'm not guilty of abuse: i've written Ruby code that has giant conditionals that are all "instanceof" tests
03:25:18 <Myrl> rom1504: this is so sad. ;-;
03:25:47 <ab9rf> Chathurga: php in-place sort is nothing compared to the absolute insanity of how PHP iterators work
03:30:35 * hackagebot dynamic-graph 0.1.0.5 - Draw and update graphs in real time with OpenGL  http://hackage.haskell.org/package/dynamic-graph-0.1.0.5 (adamwalker)
03:31:42 <Myrl> Voldenet: It's not as exciting as I expected it to me. :<
03:32:00 <Voldenet> mfw I joined #php to help random people :|
03:32:07 <Voldenet> Way to waste time.
03:32:42 <Chathurga> Voldenet: You're essentially the red cross now
03:32:58 <Myrl> Chathurga: The red cross would take people away from PHP
03:33:13 <bergmark> next you can go to a church and present the word of mormon
03:33:20 <MP2E> hahah
03:33:33 <Myrl> bergmark: That escalated quickly.
03:33:37 <Voldenet> bergmark: I'm an atheist, is that an issue?
03:33:46 <Voldenet> Actually it's not.
03:33:54 <Voldenet> Time to become a priest.
03:34:00 <Myrl> Of course.
03:34:24 <Myrl> The highest aspiration of an atheist is to be a priest
03:37:01 <agocorona> I´m a Haskell evangelist
03:37:20 <therp> with the fixed point nirvana?
03:37:44 <Myrl> agocorona: Oh please baptize me
03:38:18 <therp> My attitude to religious discussions is more like (const undefined)
03:38:19 <MP2E> fixed point nirvana haha
03:38:23 <agocorona> for the power of the monadic combinators I wish you a happy new year
03:42:28 <agocorona> A question: there is a common designation for  applicative, alternative and monadic computation?   categorial computation or something like that?
03:54:59 * pothepanda finds inner peace
04:05:20 <merijn> @quote theomorphism
04:05:20 <lambdabot> Cale says: desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal object in the category of religions and theomorphisms.
04:05:44 <merijn> agocorona: Not really
04:07:34 <merijn> agocorona: What's the context?
04:08:59 <agocorona> there are many cases where monadic, applicative and alternative combinators are used in the same expression
04:10:19 <agocorona> I´m writing an article for OOP people.  which shows how a computation of this kind with certain effects is better than OOP (composable etc)
04:10:31 <merijn> Yeah, but then you'd just usually refer to the specific type you're dealing with
04:10:42 <agocorona> I would not call it functional programming since they imagine pure functions
04:10:52 <merijn> They are pure functions
04:10:54 <agocorona> neither monadic
04:11:10 <merijn> I never liked the term "monadic"/"monadic function"
04:11:15 <merijn> It doesn't make a lot of sense
04:11:21 <agocorona> they are pure but not in the sense that they imagine
04:11:23 <bernalex> I don't understand that either
04:11:24 <merijn> Things are functions, or they're not
04:11:32 <merijn> agocorona: They *are* pure in the sense that they imagine
04:11:53 <merijn> I think the confusion is not "monadic code", but the notion as "IO as a first class value"
04:12:11 <merijn> You could have a purely functional language with first class IO without monads easily enough
04:12:59 <Myrl> Hmmm...
04:13:43 <Myrl> I heard that the IO monad keeps Haskell "pure" how does it?
04:13:51 <agocorona> I would prefer to call it categorial computation
04:14:42 <merijn> Myrl: IO keeps haskell pure
04:14:51 <merijn> Myrl: The fact that IO is a monad is orthogonal
04:15:23 <hyPiRion> heh. Taken out of context, that statement would probably sound bizarre.
04:15:25 <Myrl> orthogonal?
04:15:43 <merijn> Myrl: The trick to keep haskell pure is, "IO" values are first class representations of an IO action. But there is no built-in way to RUN actions in haskell
04:15:48 <agocorona> category theory is perfect for impure code too.
04:15:55 <merijn> Myrl: unrelated, separate, etc.
04:16:04 <Myrl> merijn: I see.
04:16:17 <merijn> Myrl: What is a pure function? "A function that always produces the same result when it gets the same input"
04:16:23 <agocorona> really I don´t care about how pure and first class and beatiful haskell manage IO as first class and so on
04:16:54 <merijn> Myrl: So, if we have "putStrLn :: String -> IO ()", when is putStrLn pure? If giving it the same string it always returns the "same" IO action
04:16:54 <agocorona> in this article that does not matter
04:17:10 <Myrl> merijn: uhuh
04:17:13 <merijn> Myrl: The IO action in this case being "printing the String to stdout"
04:17:26 <tzaeru> I kinda fail to understand what is so awesome in "pure" anyway. side-effects are not the typical reason for bugs in the code I work with. instead, it's almost always simply not doing something that should have been done or returning a wrong kinda value.
04:17:34 <tzaeru> it's a nice idea, though
04:17:58 <tzaeru> just not perhaps quite so groundbreaking to be held to as a mandatory requirement
04:18:05 <merijn> Myrl: Note that the action doesn't *do* anything. So it's a pure function that just returns "an IO action for printing a String"
04:18:13 <eXeC64> Myrl: It's worth noting that "IO a" is actually a function: "world -> (a, world)"
04:18:31 <merijn> eXeC64: It is not. It is a bad abstraction. And that's terrible advice
04:18:36 <hpc> eXeC64: it's only defined that way in GHC internals
04:18:45 <agocorona> monad applicative and alternative can be implemented in any impure language
04:18:46 <eXeC64> merijn: Oh, my bad. It helped me to grok it.
04:18:48 <hpc> eXeC64: and even then ghc implements it differently, because it can apparently
04:18:56 <agocorona> well not any
04:18:57 <merijn> tzaeru: You've never had a bug due to unanticipated mutation of a global variable?
04:19:07 <merijn> eXeC64: Oh? Then how do you explain concurrency in that model? :)
04:19:18 <eXeC64> merijn: I've yet to do concurrency in Haskell ;)
04:19:29 <merijn> eXeC64: You should, it's much easier than other languages!
04:19:40 <eXeC64> merijn: Easier than in go?
04:19:46 <eXeC64> Because I love concurrency in go
04:19:48 <merijn> eXeC64: Yeah
04:19:58 <merijn> eXeC64: We have proper channels and lightweight threads too
04:20:00 <hyPiRion> I don't think easier is the right word. Simpler, perhaps.
04:20:02 <eXeC64> Nice
04:20:05 <merijn> See forkIO and Control.Concurrent.Chan
04:20:18 <morfeen> Is Haskell any good for writing web apps?
04:20:19 <hpc> it's definitely easier to do hard things
04:20:20 <eXeC64> merijn: I looked at the types, but I've yet to try using them
04:20:52 <merijn> Myrl: Anyway, to finish the story. So we have pure functions that are returning first class IO actions. So we have a pure program combining first class IO actions into bigger IO actions.
04:21:00 <hpc> morfeen: quite good
04:21:06 <merijn> Myrl: Like "andThen :: IO a -> (a -> IO b) -> IO b"
04:21:27 <morfeen> hpc: any web apps you know written in Haskell?
04:21:52 <Myrl> merijn: I see
04:22:03 <merijn> Myrl: So how do you RUN your IO actions? Well, you may have noticed that "main :: IO ()", main is one big IO action, that is build by using pure functions to construct it from smaller IO actions
04:22:03 <hpc> i used to know a few
04:22:10 <hpc> the only one i remember off the top of my head is hackage
04:22:19 <merijn> Myrl: The runtime takes this one big IO action and starts running it's effects
04:22:48 <merijn> Myrl: But since the language doesn't expose that functionality (well, unless you start messing about with unsafeX), you can't break purity that way
04:23:12 <merijn> morfeen: lpaste, ircbrowse, all yesod projects
04:23:19 <merijn> tryhaskell is haskell, I think
04:23:36 <merijn> lpaste and ircbrowse are open sourc etoo
04:24:08 <tdammers> tzaeru: purity and static type checks make for extremely maintainable code
04:24:24 <merijn> Myrl: Now, someone noticed that "hey, this "andThen :: IO a -> (a -> IO b) -> IO b" function follows the monad laws! We can make it a monad!" (and a functor, and an applicative, etc.)
04:24:42 <merijn> Myrl: But even if monads didn't exist, you could still have a purely functional language using IO
04:25:09 <merijn> Myrl: Also, for the first few years (maybe even decade?) of haskell's existence, monads weren't used, because no one knew about them
04:25:22 <tdammers> tzaeru: if you have a function f :: Foo -> Bar, then you know exactly what inputs it accepts, what outputs it can produce, that the same input will always produce the same output, and that it will not influence the behavior of anything else in your code that doesn't reference it
04:25:26 <merijn> Similarly, Applicatives weren't conceived until like 2004
04:25:31 <tdammers> tzaeru: those are pretty strong guarantees
04:26:08 <eXeC64> It's amazing to me how young so much of functional programming is
04:26:22 <merijn> People always seem to think that Haskell was built on monads/applicatives, while in reality they were invented later. They were just such "obviously great" ideas their adoption was rather faster and total
04:26:27 <merijn> eXeC64: Haskell is older than Java
04:26:40 <MP2E> yeah functional programming is not really 'young'
04:26:46 <eXeC64> merijn: Not the language or idea, but the key concepts
04:26:53 <eXeC64> like applicatives
04:27:00 <eXeC64> Or using monads for IO
04:27:21 <merijn> eXeC64: You can do other things, Clean uses uniqueness types
04:27:33 <merijn> Which are types that guarantee a value can only be used once
04:27:33 <tdammers> eXeC64: it's not even really "using monads for IO". It's "using pure values to represent IO actions, and observing that composing those actions follows the monad pattern"
04:28:04 <merijn> eXeC64: I think it's a matter of FP starting to deliver on the promises OO made (i.e. truly reusable code)
04:28:27 <tdammers> indeed. the actual core concepts are quite a bit older than 2004
04:28:28 <merijn> Look at libraries like transformers, free, comonads, bifunctors. That sorta reuse you can't get in most conventional OO languages
04:29:01 <merijn> The true core concepts of FP are what led us to be able to discover and use things like monads/applicative/etc
04:29:09 <merijn> Hell, lenses and iteratees
04:30:09 <merijn> Something, something codensity transform :>
04:30:36 <eXeC64> The re-use is really really nice
04:30:39 <favetelinguis> just like map is an abstraction of a common recursion pattern is there an abstracion for the type of recursion pattern that shows up when recursion over tree structures. For example in this code http://lpaste.net/118368 printTree and bagToList has the same type of recursion, is there a standard implementation for abstracting this pattern?
04:30:56 <eXeC64> I was writing python at work today and thinking, "This should be a foldl"
04:31:10 <tdammers> Python has reduce(), right?
04:31:23 <tdammers> favetelinguis: functor
04:31:24 <hpc> not by default, anymore
04:31:32 <eXeC64> Yeah, but if I start writing in that sort of style it'll confuse the others
04:31:42 <tdammers> yeah well, itertools, but that's pretty much standard anyway
04:31:48 <merijn> favetelinguis: Foldable and Traversable
04:32:00 <hpc> they've been trying to get rid of map/reduce/filter for a while, but the backlash is always enormous
04:32:01 <merijn> :t F.fold
04:32:02 <lambdabot> (Monoid m, Foldable t) => t m -> m
04:32:03 <eXeC64> I've seen 10 levels of nested if statements here
04:32:08 <merijn> eh
04:32:19 <merijn> :t F.foldl
04:32:20 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
04:32:51 <merijn> favetelinguis: Mentally replace 't' with your Tree type. You'll find them + laws in Data.Foldable and Data.Traversable
04:32:54 <eXeC64> I saw a cute use of map the other day. Someone was mapping a typecast and operation over a list to change a list's type and tweak the values slightly
04:32:57 <tdammers> hpc: why would you want to get rid of them? if anything, I'd want to use them more, instead of writing godawful destructive loops everywhere
04:33:01 <eXeC64> in python that is
04:33:14 <hpc> tdammers: the language is run by dunces ;)
04:33:26 <merijn> tdammers: to be fair, python's list comprehensions are pretty much already maps
04:33:31 <favetelinguis> merijn: aa ok i have heard about that nice to know thanks
04:33:39 <merijn> And with their function notation map is often more confusing than a list comprehension
04:33:52 <Myrl> A "cute" use of map? .-.
04:34:04 <hpc> their philosophy is that there's only one way to do things
04:34:16 <hpc> and thanks to the nature of programming, you pretty much just have to guess what way that is
04:34:44 <merijn> I think python makes a lot of mistakes, but I do think the Zen of python contains a lot of wisdom
04:35:05 <tdammers> the zen of python contains a lot of wisdom that python itself violates all over the place
04:36:44 <merijn> Sure
04:36:59 <merijn> To be fair, Guido didn't know a lot about language design when he started :p
04:37:08 <tdammers> I sense a familiar pattern there
04:37:24 <tdammers> something about languages whose names start with a "P"
04:37:27 <merijn> The irony of popular languages, the creators don't learn enough language design until after their language is popular and they can't fix their mistakes :p
04:37:38 <tdammers> yep
04:38:05 <tdammers> and meanwhile, those with a lot of knowledge about language design take too much background information for granted and fail to build something that a clueless beginner can stomach
04:38:10 <tdammers> so their languages never take off
04:39:14 <merijn> tbh, while there's a bunch of warts, I think the Haskell Report is a work of art as far as "nice and consistent language design" goes
04:39:24 <merijn> I've heard Scheme RSR6 was also pretty good
04:39:36 <tdammers> yes
04:39:56 <tdammers> but compared to any of the P languages, neither of these has truly taken the masses by storm
04:42:03 <J_Arcane> I find the whole 'THere is only one way to do something' philosophy of modern Python rather weird; it's almost diametrically opposed to the culture of early Python devs, and I don't understand what happened while I was gone.
04:47:46 <Taneb> Is there anyone here in the York area? We're starting up a Haskell meetup group.
04:47:54 <clrnd> we have way more python rants in here than for any other language, that's interesting
04:48:01 <Taneb> http://www.meetup.com/York-Haskell
04:48:14 <agocorona> but in Python the path is clear for doing anything but in Haskell the beginner get lost
04:49:21 <HugoDaniel> je suis charlie666 http://boingboing.net/2015/01/13/what-david-cameron-just-propos.html
04:49:27 <HugoDaniel> oops wrong #, sorry
04:49:53 <kgadek> hi. if anyone likes type riddles - https://gist.github.com/6a919ececea371de5552 how to make it work? :D
04:50:38 * hackagebot possible 0.1.0.5 - Three valued Data.Maybe  http://hackage.haskell.org/package/possible-0.1.0.5 (tolysz)
04:51:46 <pantsman> o_O Nothing, Just, FileNotFound?
04:52:36 <Taneb> pantsman, I think it's a joke about PHP
04:53:28 <pantsman> Taneb: I was pondering: hackagebot possible 0.1.0.5 - Three valued Data.Maybe
04:55:05 <Taneb> pantsman, oh, haha, I guess it's useful for HTTP GET parameters, where ?x is different from ?x= (I think) is different from ? (no x parameter)
04:56:33 <ab9rf> seems like a lot of effort for nested maybe
04:56:38 <ab9rf> Maybe (Maybe a)
04:56:54 <Taneb> I guess
04:57:01 <ab9rf> Nothing <-> MissingData
04:57:09 <ab9rf> Just Nothing <-> HaveNull
04:57:19 <ab9rf> Just Just x <-> HaveData x
04:57:26 <ab9rf> Just (Just x) rather
04:58:07 <Taneb> ab9rf, yes, that'd be a simpler solution
04:58:19 <Taneb> Personally I'd create a custom datatype for the specific use-case
04:58:31 <ab9rf> Taneb: i don't object to a custom datatype
04:58:40 <ab9rf> Taneb: although i'm not sure i agree with the semantics here
04:58:54 <lieven> or Either ND a where data ND = MissingData|HaveNull
04:59:10 <ab9rf> HaveNull seems to take precedence over MissingData
04:59:12 <kgadek> re "if anyone likes type riddles - https://gist.github.com/6a919ececea371de5552 how to make it work? :D" -- is it possible at all in Haskell type system?
04:59:43 <ab9rf> and i would think that MissingData should be the top instance, not HaveNull
04:59:46 <kgadek> it appears this should work -- return the type with a dictionary with pointer to method "how to print this"
05:00:08 <ab9rf> also fail _ is defined as HaveNull and that seems wrong to me
05:00:46 <ab9rf> certainly for the HTTP use case that Taneb mentioned
05:04:19 <pantsman> I don't understand the proposed Aeson use case. Aeson's Value already has a Null constructor.
05:04:29 <pantsman> So you can have Just Null
05:05:02 <pantsman> you don't want to distinguish between HaveNull and HaveData Null
05:05:34 <merijn> pantsman: The difference is "something failed to parse" vs "parsed successfully as 'null' data"
05:06:23 <ab9rf> merijn: which is why i think MissingData should be the 'top' instance, and not HaveNull
05:07:21 <pantsman> merijn: I don't see any claim that "failed to parse" is the meaning of any of the states.
05:07:28 <pantsman> I would want a parse error, not a Nothing or HaveNull.
05:07:40 <merijn> kgadek: How would that work?
05:07:50 <merijn> kgadek: The return type is 'c1'
05:08:08 <merijn> kgadek: But you're returning "getX a' and 'getX b' which have types 'a' and 'b' respectively
05:09:00 <merijn> Wait
05:09:04 <merijn> it double doesn't make sense
05:09:08 <_d0t> hey guys. Where is instance Num a => Num (Maybe a) declared? Can't find it.
05:09:19 <merijn> _d0t: That doesn't exist
05:09:36 <_d0t> merijn: I remember seeing it somewhere.
05:09:41 <merijn> kgadek: You're calling getX on values of type 'a' and 'b', which aren't instances of HasX
05:09:57 <merijn> _d0t: Oh *someone* probably implemented it at some point
05:10:04 <merijn> _d0t: But it's not in any of the standard libraries
05:10:11 <_d0t> merijn: nah, I mean in the standard library.
05:21:39 <arianvp___> Unrecognized field
05:21:41 <arianvp___> data-dir
05:21:47 <arianvp___> anybody know what this means if cabal says this?
05:23:56 <Saizan> arianvp___: i'd guess there's a "data-dir: ..." line in the .cabal file and it's not a valid field
05:32:12 <tzaeru> merijn, I've very, very rarely had bugs that were caused due to a global (or really even class variable) being set to something that I did not expect during runtime
05:33:20 <tzaeru> or well -- it's somewhat common to run to something that was supposed to be initialized but wasn't.
05:33:24 <tzaeru> that's a decently common case.
05:41:34 <aisqwe> where can i find a list of all primitve functions? like seq
05:42:01 <merijn> aisqwe: You mean primitives builtin to GHC?
05:42:09 <aisqwe> merijn: yes
05:42:23 <merijn> aisqwe: I'm not sure if it's exhaustive, but the documentation of GHC.Prim is a good start
05:42:25 <aisqwe> primitive functions that are implemented in the ghc compiler.
05:42:40 <merijn> It's not on hackage, but should be in the local docs of your machine
05:44:36 <arianvp___> Hey anybody using synstasic here?
05:44:38 <arianvp___> it displays all errors on one line. anyone know how to fix this?
05:46:46 <aisqwe> merijn: can you give me a link to the ghc.prim doc, i cant seem to find it.
05:47:46 <merijn> Oh, I guess they are online: https://downloads.haskell.org/~ghc/7.0.3/docs/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html
05:48:05 <aisqwe> merijn: thanks
05:54:52 <kgadek> merijn: both a and b are instances of HasX
05:55:41 <merijn> kgadek: But how can the return type ever be 'c1'?
05:56:23 <kgadek> merijn: this is a pinpoint of the problem. I can't express that c1 equals either a1 or b1 depending on the control flow of the function
05:57:28 <ab9rf> you can't have a function that has conditional type
05:58:47 <merijn> ab9rf: Well, you can
05:58:50 <merijn> Just not this way :p
05:58:57 <ab9rf> ok, yeah
05:59:37 <merijn> But I don't have time to go into that now. The trick is GADTs plus a type family whose type depends on the input GADT
06:00:02 <ab9rf> i've seen that mentioned somewhere recently
06:00:07 <ab9rf> probaly someone's blog
06:04:31 <arianvp___> Is there a difference between sequence and sequenceA ?
06:05:00 <cwraith> arianvp___: there is if you have a type that's an Applicative but not a Monad
06:05:16 <merijn> arianvp___: Applicative is not a superclass of Monad until 7.10 comes out
06:05:26 <arianvp___> but sequence = fmap id
06:05:30 <matematikaadit> I <*> Applicative
06:05:33 <arianvp___> oh wait
06:05:36 <arianvp___> no it isnt :P
06:05:41 * hackagebot htsn-import 0.2.1 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.2.1 (MichaelOrlitzky)
06:05:45 <arianvp___> it's mapM id*
06:05:59 <arianvp___> okay but from 7.10 it's the same right?
06:11:22 <fizbin> I have a tricky concurrency design question. Anyone feel up to handling haskell concurrency, or is it too early in the morning?
06:11:41 <RchrdB> It's too early in the afternoon but please ask anyway. :3
06:13:08 <aisqwe> what is a good example of using newtype in realworld applications?
06:13:42 <fizbin> Specifically, I have several threads that want to convert an "a" into a "b" using an "a -> IO b". For various reasons, I don't want to run more than one of the "a -> IO b" at once. Furthermore, several threads will have identical (as in ==) "a"s, and if they do then the "b"s they'd compute would be identical anyway.
06:14:28 <cwraith> fizbin: so have one thread provide an a->b conversion service that other threads can call into?
06:15:40 <fizbin> cwraith: Possible, but the tricky bit then is that if four or five threads ask at once, and three of them have identical "a" values, I'd like those three to get answered at once.
06:15:53 <Chathurga> aisqwe: Get a little more type safety out of something, let's say you want Ints that are even only, you could newtype Even = Even Int, don't export the constructor and provide a method like toEven :: Int -> Maybe Even
06:15:59 <fizbin> Because "b" are rather large in memory, I don't want to keep a "b" cache around.
06:16:08 <fizbin> "a"s are not so large in memory.
06:16:12 <Chathurga> By runtime the wrapper will get optimized away and it'll be just like using an Int
06:16:58 <c_wraith> fizbin: Does the IO op take a significant amount of time?
06:17:24 <fizbin> c_wraith: Occasionally. (On the order of tens of seconds)
06:17:33 <c_wraith> fizbin: If so, you can cache just for the duration of the call and expect some rewards.
06:18:04 <c_wraith> fizbin: if that doesn't work, you might want to use an LRU cache or something
06:18:59 <c_wraith> or some other sort of size-bounded cache
06:19:07 <c_wraith> LRU isn't always the best policy
06:19:49 <c_wraith> fizbin: but it's simple to try just checking if your request is a duplicate of one currently in-flight.
06:19:54 <fizbin> What I currently have is a simple one-at-a-time semaphore, but obviously that results in lots of recomputing when I get a dozen identical incoming requests. What I want is something in haskell that's like the com.google.common.cache.LoadingCache interface in the guava library.
06:22:35 <c_wraith> fizbin: Map a [MVar b], and update it on each incoming request?  You'd never need to cache a b value, and you'd get nice batching of concurrent requests
06:23:09 <c_wraith> fizbin: (assuming you use writing to an MVar to signal to the requesting threads that a value is available to them)
06:24:40 <fizbin> c_wraith: And you're still then imagining a single separate worker thread, rather than the incoming request threads doing the work.
06:24:47 <c_wraith> fizbin: yes
06:24:55 <fizbin> Which maybe is something I should switch to.
06:25:06 <fizbin> Though I'm a bit paranoid about my worker thread dying.
06:25:20 <fizbin> With my request threads, if one dies I lose the request.
06:25:32 <fizbin> No big deal. But if the worker thread dies...
06:26:07 <c_wraith> right...  Map a [MVar (Either SomeException b)]  :P
06:30:26 <merijn> Maybe you can do this using WeakRefs
06:30:42 <merijn> Since they can have indices that are separate from the value inside
06:31:01 <merijn> So you could maybe have 'a' indices to WeakRef (IO b)
06:31:14 <merijn> This would also avoid having to trim the Map
06:31:24 <merijn> OTOH it may end up recomputing more
06:32:03 <merijn> Anyone know a quick easy way to generate a bunch of random numbers in a specific range?
06:32:18 <c_wraith> randomRs?
06:32:31 <merijn> c_wraith: I meant one-off as dummy data :p
06:32:46 <merijn> c_wraith: But I missed -blah and hit #haskell :x
06:32:49 <c_wraith> randomRIOs! :P
06:35:14 <frawgie_> oh the joy when you are trying to explain a piece of code you didnt touch for over a month or how it works
06:38:13 <Myrl> frawgie_: It'll self-document you say
06:38:19 <Myrl> frawgie_: It'll be fine you say
06:38:23 <Myrl> :P
06:38:29 <frawgie_> Myrl: more self-confusing :)
06:40:00 <geekosaur> not that that's really any different for haskell than any other language
06:40:42 * hackagebot align-text 0.1.0.1 - A simple unix filter to align text on specified substrings  http://hackage.haskell.org/package/align-text-0.1.0.1 (DanielChoi)
06:42:29 <c_wraith> I seem to have forgotten how to provide imports to a ghc one-liner.  I could have sworn it was ghc -e 'import foo' -e 'do something with foo'
06:48:23 <weasel__> Does anyone have time to answer a quick type question
06:48:34 <vanila> yeah
06:48:43 <weasel__> I have a type Mv
06:48:59 <weasel__> which is a geometric algebra multivector
06:49:46 <weasel__> because of how geometric algebra works, I want to have a function s :: Versor -> Point -> Point
06:49:55 <weasel__> where Versor and Point are type aliases of Mv
06:50:28 <weasel__> but I would like the same function to also work for Versor -> a -> a for any type alias of Mv I define, because it's always the same computation
06:51:06 <vanila> when you say type alias are you doing it with  type Foo = Mv ? or newtype?
06:51:30 <vanila> Versor -> Mv -> Mv will work with Point and any other alias defined with 'type'
06:51:35 <wto> weasel__: Why don't you just write s :: Versor -> Mv -> Mv, then?
06:51:45 <wto> ah yes, what vanila said.
06:51:59 <weasel__> because I don't want to have s :: Versor -> Point -> Plane
06:52:14 <wto> weasel__: but if Point and Plane are just Mv, does it really matter?
06:52:40 <slomo_> if it does matter, the answer is probably that you should use newtypes instead of type aliases
06:52:42 <weasel__> wto: yes, because they have different algebraic properties
06:53:14 <wto> Then what slomo_ says is probably the reasonable approach.
06:54:15 <weasel__> okay. will s :: Versor -> Mv -> Mv applied to a Versor and a Point type as Point or as Mv?
06:54:22 <weasel__> if Point is a newtype
06:54:33 <wto> weasel__: as Mv.
06:54:35 <vanila> What I think you might want to do is create an indexed data type
06:54:46 <vanila> then you have  Mv Point, Mv Plane, Mv Versor etc.
06:54:58 <vanila> now you can type s :: Mv a -> Mv b -> Mv b
06:55:11 <weasel__> vanila: Mv is `type Mv = [Blade]`
06:55:14 <slomo_> also how Point and Vector work in the linear package might be good to look at
06:55:20 <vanila> im suggesting something differnt than that
06:56:14 <rom1504> c_wraith: ghc -e ":m + Data.List.Utils" -e 'putStrLn (replace "e" "a" "hello, world")'
06:56:28 <weasel__> vanila: If I take that route it won't really be a geometric algebra library then
06:56:51 <vanila> ok
06:56:56 <rom1504> weasel__: well import works too actually...
06:57:07 <rom1504> * c_wraith
06:58:29 <weasel__> slomo_: I will take a look
07:02:30 <idnar> is there a better way to write this: (\did -> d & datasetId ?~ did) <$> blub (where datasetId is a lens, and blub is IO String)
07:03:14 <idnar> I think you can write the lambda as (d &) . (datasetId ?~) instead, but that doesn't really help
07:05:11 <vanila> what does it do
07:05:37 <indiagreen> isn't there <&> specifically for this purpose
07:05:43 * hackagebot hoogle 4.2.37 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.37 (NeilMitchell)
07:06:01 <athan> :t (Data.Lens.<&>)
07:06:02 <lambdabot> Not in scope: ‘Data.Lens.<&>’
07:06:04 <idnar> there is <&>, but I'm not sure how to use it here
07:06:14 <athan> erm
07:06:16 <Taneb> :t (Control.Lens.<&>)
07:06:17 <lambdabot> Functor f => f a -> (a -> b) -> f b
07:06:19 <Taneb> :)
07:06:22 <athan> ><
07:06:26 * athan is ashamed
07:06:35 <indiagreen> hm, okay, probably you can't use it here
07:06:36 <athan> They're kinda the same...!
07:07:00 <athan> so it's flipped contramap?
07:07:28 <idnar> <&> is flip <$>
07:07:57 <idnar> (<&>) is flip (<$>) I mean
07:08:02 <idnar> like (&) is flip ($)
07:08:14 <lpaste> yaxu pasted “playing with hint” at http://lpaste.net/118375
07:08:33 <lpaste> weasel__ pasted “Surely there is a better way” at http://lpaste.net/118376
07:08:43 <yaxu> Hi all, I'm trying to make something that works a bit like ghci, but getting a strange problem where I can't use `<-`
07:08:57 <`^_^v> is IO the only well known monad that cant be implemented in pure haskell (no pun intended)
07:09:07 <weasel__> I got it working, but it's very ugly. Is there some wizardry that will help?
07:09:14 <yaxu> If I interpret "d1 <- dirtStream" with hint, I get "<interactive>:2:4: parse error on input `<-'"
07:09:45 <yaxu> (code pasted above)
07:11:57 <athan> idnar: My brain is not working properly yet >< sorry
07:12:15 <zwer_s> `^_^v ST
07:12:31 <idnar> athan: I could do with some more coffee at the moment, myself :)
07:12:32 <athan> `^_^v: I think you actually can implement it in pure haskell
07:12:54 <athan> erm, my mistake, it's a mirror of ST
07:20:05 <bananagram> I keep forgetting that >> has a lower priority than $ and getting weird errors
07:20:52 <tdammers> yep
07:20:57 <tdammers> #justhaskellthings
07:22:06 <venuc> can someone please tell me why this does not work? Prelude> length . Data.List.nub [1..4]
07:22:19 <venuc> where am I getting this function composition wrong?
07:22:25 <tdammers> venuc: you aren't
07:22:34 <tdammers> venuc: you are getting fixity / precedence wrong
07:22:48 <tdammers> venuc: function application binds tighter than any operator, including .
07:23:12 <tdammers> so what you wrote is length . (nub [1..4]), not (length . nub) [1..4]
07:23:25 <tdammers> a common idiom is foo . bar . baz $ quux
07:23:28 <tdammers> i.e., in your case:
07:23:34 <tdammers> length . nub $ [1..4]
07:23:56 <glguy> Nooo not more ...$
07:24:02 <Myrl> glguy: lol
07:24:29 <venuc> thanks a ton !
07:28:13 <Guest79778> if mapM is there what value does traverse add in Data.Travesable apart from it is constrained on Applicative and former is on Monad.
07:28:34 <Guest79778> @type traverse
07:28:36 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:28:41 <Guest79778> @type mapM
07:28:42 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
07:29:05 <glguy> mapM originally worked on list, and the are more applicative things than monad things
07:29:05 <Guest79778> > import Data.Travesable
07:29:06 <lambdabot>  <hint>:1:1: parse error on input ‘import’
07:29:38 <Guest79778> not the mapM from prelude, the one from Data.Traversable
07:30:13 <barrucadu> To provide slightly clearer type errors when things go wrong, perhaps?
07:30:20 <glguy> Then it's just that strictly more things have applicative instances
07:30:34 <pantsman> Guest42764: historically, not every Monad is Applicative, so you may have a Monad that you want to traverse with, and not an Applicative
07:31:26 <glguy> That's fixed in the upcoming base-4.8
07:31:56 <pantsman> once it's fixed, there shouldn't be a need for mapM
07:32:21 <hodapp> what is the fix?
07:33:13 <glguy> class Applicative f => Monad f
07:33:30 <Guest79778> pantsman: So is the implementations of both are same?
07:33:35 <Guest79778> are*
07:35:44 <hodapp> glguy: but, base-4.8 does this?
07:35:58 <pantsman> Guest79778: mapM is defined using traverse, it just uses the ap from the Monad instead of <*>
07:37:54 <pantsman> (by using the WrappedMonad wrapper from Control.Applicative)
07:38:19 <pantsman> instance Monad m => Applicative (WrappedMonad m)
07:38:38 <Guest79778> pantsman: Ah, thanks
07:45:39 <hodapp> http://blog.ezyang.com/2014/03/haskell-for-coq-programmers/ says * in Haskell is impredicative... despite using both Haskell and Coq I don't really know what he means
07:45:45 * hackagebot Euterpea 1.0.0 - Library for computer music research and education  http://hackage.haskell.org/package/Euterpea-1.0.0 (MarkSantolucito)
07:47:27 <vanila> hodapp, it means that * can hold stuff that contains * inside it
07:48:00 <vanila> e.g. in system F you can encode natural numbers like type Nat :: * = forall N :: *, (N -> N) -> N -> N
07:48:24 <vanila> its impredicative since we're defining N in terms of all sets, but it is a set itself
07:48:40 <vanila> after the russel thing people were worried that impredicative definitions like this might be inconsistent
07:52:17 <hodapp> vanila: do you have a closer-to-Haskell example?
07:53:21 <vanila> data F :: * where J :: (n :: *) -> F
07:53:30 <vanila> Inductive F : Set := J : forall (N : Set), F.
07:53:49 <hodapp> sir that does not look like Haskell >_>
07:57:14 <Myrl> :t inc
07:57:15 <lambdabot>     Not in scope: ‘inc’
07:57:15 <lambdabot>     Perhaps you meant one of these:
07:57:15 <lambdabot>       ‘inv’ (line 159), ‘int’ (imported from Text.PrettyPrint.HughesPJ)
08:08:45 <Saizan> hodapp: technically all that it means is that "forall a. .." has kind *
08:22:37 <J_Arcane> Ugh. Leksah on Windows is apparently still broken and unusable. :/
08:24:59 <hamishmack> J_Arcane: in what way?
08:25:24 <J_Arcane> As in literally, the console window is a stream of errors and it crashed within 10 minutes of opening it.
08:26:50 <hamishmack> Could you add an issue to github?
08:30:46 * hackagebot git-annex 5.20150113 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20150113 (JoeyHess)
08:31:09 <tuv> how can i get 'interact' to print the last line? it prints all lines except the last
08:31:41 <srhb> tuv: Are you using ctrl+c instead of ctrl+d to stop an interactive process?
08:31:58 <srhb> tuv: Otherwise, buffering perhaps?
08:32:23 <tuv> srhb: ah.. right. ctrl+D does show the last line. but how do i get it to show on its own?
08:32:54 <srhb> tuv: My guess is, if you pipe in the input like echo "foo\nbar" | yourProgram -- it works as expected
08:32:59 <RustyShackleford> haskell is super wierd
08:33:20 <RustyShackleford> hah I want to start writing some code, but I have no idea what to type
08:33:23 <srhb> tuv: Otherwise, try disabling linebuffering.
08:33:33 <srhb> RustyShackleford: Do you want some pointers to resources? What did you read already?
08:34:51 <tuv> srhb: piping input works too. but there must be a way to flush all output without disabling buffering, isn't thre?
08:34:59 <RustyShackleford> srhb: i'm reading through Learn you a Haskell
08:35:05 <srhb> tuv: hFlush stdin/stdout
08:35:12 <tuv> srhb: didn't help
08:35:16 <srhb> RustyShackleford: Ah, that's a good starting point. :)
08:35:22 <srhb> tuv: Paste your code and explain what you're doing.
08:35:27 <tuv> tried it already: do interact f; hFlush stdout
08:35:33 <RustyShackleford> i'm just venting i guess. Although I wouldn't mind suggestions for a toy project
08:35:40 <srhb> tuv: Right, but the problem is you're flushing after interact is done
08:35:43 <srhb> ie. after stdin was closed
08:35:45 <RustyShackleford> i'm thinking something like blackjack
08:35:48 <srhb> That doesn't help you BEFORE it's closed
08:36:26 <srhb> RustyShackleford: Sounds like a plan. :) But there's no sense in getting mad about not knowing how to code before you've actually learned it. Haskell is very different from a lot of other languages, it's to be expected :)
08:38:08 <lpaste> tuv pasted “flush” at http://lpaste.net/118382
08:38:21 <tuv> srhb: ^^^
08:38:31 <tuv> just a toy test
08:39:54 <RustyShackleford> would you call haskell a lisp?
08:40:04 <srhb> RustyShackleford: No?
08:40:15 <vanila> its nost lisp
08:40:40 <Iceland_jack> RustyShackleford: No
08:41:10 <RustyShackleford> i'm not sure why i've heard/read that before
08:41:19 <srhb> Me neither. :)
08:41:26 <srhb> Aside from the functional approach they have very little in common.
08:41:34 <hyPiRion> RustyShackleford: Both are considered functional languages by many, I think. Perhaps that's why?
08:41:54 <srhb> tuv: And explain a simple test case, what you see and what you expected?
08:43:31 <tuv> runhaskell act.hs "aaaa bbb cccc dddd" -> I get the a's, b's, and c's, but not the d's until I hit ctrl+D. I expect the d's to show up on their own
08:44:00 <tuv> act.hs contains the pasted code
08:44:01 <srhb> tuv: disable linebuffering on stdout then
08:44:18 <srhb> Before running interact
08:44:42 <srhb> The reason the others are printed is because there are \ns between them all, but not after dddd
08:44:58 <tuv> srhb: yes there is
08:45:04 <srhb> There is?
08:45:49 <tuv> f f "aaaa bbbb cccc dddd"
08:45:49 <tuv> "aaaa\nbbbb\ncccc\ndddd\n"
08:45:54 <srhb> Oh right
08:45:59 <srhb> The (++ "\n")
08:46:03 <tuv> yes
08:47:31 <srhb> tuv: Then I'm not sure what's wrong, sorry. On my system I get what you expected anyway.
08:49:32 <tuv> :/
08:52:17 <srhb> tuv: Oh hang on.. Are we pretending interact is acting linewise?
08:52:22 <srhb> Because it isn't.
08:53:08 <tuv> well.. if it's working as expected for you, why wouldn't it do the same for me?!
08:53:21 <srhb> Well while I see the ddds there's no newline after them
08:53:25 <srhb> So not quite as I expect
08:53:49 <tuv> in ghci, calling the f function does result in the expected output
08:54:14 <tuv> f "aaaa bbbb cccc dddd"
08:54:14 <tuv> "aaaa\nbbbb\ncccc\ndddd\n"
08:55:04 <srhb> tuv: f = unlines . map (intercalate "\n" . words) . lines
08:55:07 <srhb> How about that?
08:55:40 <srhb> I think the reason you're being surprised is because you're expecting f to work on lines, but it isn't
08:56:09 <srhb> It's working on the entire content of stdin. So the (++ "\n") is only applied after stdin is closed (ctrl+d)
08:56:43 <srhb> by smacking your old function inside unlines . map f . lines -- you should get what you thought you were asking for before
08:57:37 <NemesisD> is there a way to get the splices for a particular file in a project? I want to see the safecopy that gets derived
08:59:07 <srhb> NemesisD: Hmm, I think you can only dump them all.
08:59:42 <ironChicken> you know how Python has the Python.h API and libraries can be written in C using it? is there anything equivalent for GHC? or is it just writing a generic C library and then adding FFI bindings?
09:00:06 <tuv> srhb: ah.. this works: f = unlines . map (intercalate "\n" . words) . lines
09:00:25 <srhb> tuv: Yes. :) So now "f" gets applied to each line rather than to the whole stdin stream
09:01:04 <tuv> but why did stdin stop before the last part every time?
09:01:16 <tuv> (until ctrl+D is hit)
09:01:41 <srhb> tuv: It didn't, but the final "\n" had not been appended yet
09:01:48 <srhb> Because stdin isn't done until ctrl+d
09:02:08 <srhb> And (++ "\n") was applied to the end of what we got from stdin (which we hadn't gotten yet!)
09:02:17 <tuv> right
09:03:10 <tuv> so in most cases i'd probably want to use unlines . <something> . lines with interact?
09:03:50 <NemesisD> srhb: do you know how one would dump them within a cabal project?
09:04:17 <srhb> tuv: interactByLine f = unlines . map f . lines -- yes
09:04:39 <srhb> er... interact used on that
09:04:40 <srhb> :D
09:06:10 <srhb> NemesisD: Change the ghc command to include --ddump-splices ?
09:07:01 <RustyShackleford> do heskell strings support unicode?
09:07:07 <HugoDaniel> yes
09:07:11 <HugoDaniel> its *haskell :)
09:07:23 <srhb> NemesisD: You could even use a OPTIONS_GHC pragma in that particular file
09:07:28 <HugoDaniel> RustyShackleford: also see the text package
09:07:32 <srhb> Though I think ddump-splices might go to stderr
09:07:33 <CindyLinz> [Char] and Data.Text.Text
09:08:24 <RustyShackleford> so then Char can also be a unicode character?
09:08:37 <srhb> :t '☭'
09:08:38 <lambdabot> Char
09:08:42 <srhb> Appears so!
09:08:47 <dgonyeo> I'm trying to cross compile ghc 7.8.4 on my x86_64 machine for my ras pi, and after setting things up according to a blog post I found I get an error about the Stage 0 compiler being affected by by #9439
09:08:58 <dgonyeo> but when I find the bug online it's marked as fixed
09:09:10 <dgonyeo> https://ghc.haskell.org/trac/ghc/ticket/9439
09:09:16 <dgonyeo> is it just not into stable ghc yet?
09:09:42 <dgonyeo> s/by by/by bug/
09:10:31 <tremon> dgonyeo: it says "version 7.8.2"
09:10:55 <tremon> oh, and "milestone 7.8.4", which I assume means that's where it's fixed
09:11:02 <clrnd> ghc --version ?
09:11:28 <dgonyeo> I have 7.8.4 on the machine I'm trying to build arm ghc on
09:11:40 <geekosaur> the last entry is relevant insofar as it's post 7.8.4
09:12:00 <tremon> ah, didn't know the release date of 7.8.4
09:12:31 <dgonyeo> wait, so did the fix get merged in to ghc?
09:12:44 <dgonyeo> the last comment on the page said it wasn't
09:13:36 <clrnd> then fix is not merged
09:13:50 <dgonyeo> think it might be in 7.10.1 RC 1?
09:14:10 <dgonyeo> guess I'll just go try to build that
09:14:26 <geekosaur> that came out at the same time as 7.8.4, iirc? so no
09:14:37 <dgonyeo> ah
09:14:40 <dgonyeo> damn
09:14:41 <geekosaur> (within a day, at least)
09:17:15 <merijn> RustyShackleford: Char can be any unicode codepoint
09:18:02 <merijn> Actually all haskell source is unicode
09:18:23 <merijn> > let (☭) = (+) in 3 ☭ 3 -- not sure if this is the right character type
09:18:25 <lambdabot>  6
09:18:48 <phooby> xD
09:18:59 <merijn> Snowman can be an operator too!
09:20:45 <J_Arcane> Great. Now I want to invent that as an actual operator. XD
09:21:05 <srhb> Also known as the "to each according to need, from each according to ability" operator.
09:21:15 <J_Arcane> :D
09:21:37 <merijn> For more details, consult the the Haskell Report 2010 on which characters are allowed where, it covers which unicode character classes are allowed
09:21:38 <phooby> shouldn't that be defined as a synonym for (==) ?
09:22:05 <merijn> > generalCategory '☭'
09:22:07 <lambdabot>  OtherSymbol
09:22:14 <J_Arcane> I was thinking it needed to be some kind of distributive property ...
09:22:19 <phooby> :p
09:22:31 <srhb> Or property distributor. Haw-haw.
09:22:43 <merijn> Other things people tend to gloss over
09:23:00 <merijn> > let can'tHappen = error "whoops!" in can'tHappen -- this is a valid variable name
09:23:01 <lambdabot>  *Exception: whoops!
09:23:27 <srhb> > generalCategory '\''
09:23:29 <lambdabot>  OtherPunctuation
09:23:47 <srhb> Well that's weird.
09:24:19 <srhb> Well, so it's just not defined from the categories.
09:25:49 * hackagebot inserts 0.1.2 - Stupid simple bytestring templates.  http://hackage.haskell.org/package/inserts-0.1.2 (JosephAbrahamson)
09:25:51 * hackagebot mutable-containers 0.2.1.1 - Abstactions and concrete implementations of mutable containers  http://hackage.haskell.org/package/mutable-containers-0.2.1.1 (MichaelSnoyman)
09:26:15 <J_Arcane> > let ☭ n = map (+n) in ☭ 10 [1..10]
09:26:17 <lambdabot>  <hint>:1:5: parse error on input ‘☭’
09:26:17 <merijn> ' is explicitly mentioned in the grammar
09:26:33 <J_Arcane> Bummer.
09:26:36 <merijn> srhb: So ' is special cased as part of variable names
09:26:41 <srhb> Indeed.
09:26:45 <merijn> J_Arcane: Requires parens
09:27:01 <merijn> Although unary operators are confusing anyway
09:27:16 <merijn> > let (☭) n = map (+n) in ☭ 10 [1..10]
09:27:17 <lambdabot>  <hint>:1:25: parse error on input ‘☭’
09:27:26 <merijn> > let (☭) n = map (+n) in (☭) 10 [1..10]
09:27:27 <lambdabot>  [11,12,13,14,15,16,17,18,19,20]
09:27:36 <merijn> Probably better would be
09:27:38 <benzrf> > let x ☭ xs = map (+x) xs in 10 ☭ [1..10]
09:27:39 <lambdabot>  [11,12,13,14,15,16,17,18,19,20]
09:27:50 <merijn> > let n ☭ xs = map (+n) xs in 10 ☭ [1..10]
09:27:51 <lambdabot>  [11,12,13,14,15,16,17,18,19,20]
09:27:55 <merijn> aww, too slow
09:27:58 <J_Arcane> Yeah. That's what I wanted anyway. :D
09:28:07 <J_Arcane> Wasn't sure if you could do that in a let.
09:28:12 <merijn> J_Arcane: Sure
09:28:19 <benzrf> J_Arcane: the top-level is basically let-wrapped
09:28:29 <merijn> J_Arcane: function/variable definitions are the same in let, where and top-level
09:28:32 <benzrf> J_Arcane: you can do, like
09:28:36 <benzrf> let x :: Int
09:28:38 <benzrf>     x = 3
09:28:39 <hodapp> Is there a sane way in Haskell to do something over every data constructor of an ADT?
09:28:56 <J_Arcane> benzrf: Well, that makes the :set +m option make more sense then.
09:29:00 <merijn> The main difference is that you can't have class/instance/data declarations in let/where
09:29:15 <benzrf> hodapp: explain
09:29:21 <merijn> hodapp: Generic?
09:31:55 <hodapp> benzrf: e.g. I have: data Something = Foo | Bar | Baz  (no arguments on any constructor), and I'd like to do something like fn Foo, fn Bar, fn Baz, without having to repeat everything (the number of constructors might be much larger and is liable to change)
09:32:14 <benzrf> oh
09:32:22 <benzrf> template haskell or Generic probly yeah
09:32:43 <mauke> [minBound .. maxBound]
09:33:08 <hodapp> mauke: considering I already require Enum for this, perhaps that's the quickest way.
09:35:10 <StoneToad> hodapp: in your specific example, you could derive an Enum instance, and use fromEnum to convert it ot an Int
09:35:31 <hodapp> StoneToad: actually, [minBound .. maxBound] :: [Something] appears to do it
09:35:45 <hodapp> as minBound & maxBound are just polymorphic constants (is that the right term?)
09:36:04 <J_Arcane> > let x ☭ xs = map (+lavg) xs where lavg = x `div` (length xs) in 10 ☭ [1..10] -- better version
09:36:05 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
09:36:14 <StoneToad> hodapp:  we both know what you're saying so it's all good right? :D
09:36:27 * StoneToad has no idea what to call them either
09:37:29 <hodapp> > type Something = Foo | Bar | Baz
09:37:30 <lambdabot>  <hint>:1:1: parse error on input ‘type’
09:37:46 <hodapp> > data Something = Foo | Bar | Baz deriving (Show, Enum, Bounded)
09:37:48 <lambdabot>  <hint>:1:1: parse error on input ‘data’
09:37:59 <Iceland_jack> @let data Something = Foo | Bar | Baz deriving (Show, Enum, Bounded)
09:38:00 <lambdabot>  Defined.
09:38:04 <hodapp> oh, let...
09:38:06 <Iceland_jack> > [Foo, Bar, Baz]
09:38:07 <hodapp> hmmm
09:38:07 <lambdabot>  [Foo,Bar,Baz]
09:38:18 <hodapp> > [minBound .. maxBound] :: [Something]
09:38:20 <lambdabot>  [Foo,Bar,Baz]
09:38:26 <hodapp> didn't realize one could use '
09:38:31 <hodapp> ...'let' for that
10:04:20 <pranz> > [minBound..]
10:04:21 <lambdabot>  [()]
10:04:58 <DeadEyes> Christ
10:05:12 <gigabytes> hi all
10:05:15 <gigabytes> little survey
10:05:22 <gigabytes> what do you use to code in haskell on OS X?
10:05:34 <gigabytes> I mean, editor, tools, environment..
10:05:46 <glguy> MacVim, Terminal.app
10:05:47 <DeadEyes> trying to find a decent irc client for iPhone. They're all terrible.
10:05:50 * hackagebot hoogle-index 0.4.0 - Easily generate Hoogle indices for installed packages  http://hackage.haskell.org/package/hoogle-index-0.4.0 (BenGamari)
10:05:52 * hackagebot b-tree 0.1.1 - Immutable disk-based B* trees  http://hackage.haskell.org/package/b-tree-0.1.1 (BenGamari)
10:05:54 * hackagebot mutable-containers 0.2.1.2 - Abstactions and concrete implementations of mutable containers  http://hackage.haskell.org/package/mutable-containers-0.2.1.2 (MichaelSnoyman)
10:06:24 <DeadEyes> sup
10:07:12 <ski> gigabytes : `emacs -n' inside GNU Screen
10:07:18 <svteoi> can i program games with haskel
10:07:42 <J_Arcane> gigabytes: FPComplete, or Emacs+Haskell Platform.
10:08:01 <J_Arcane> OR WinGHCi when I just want to poke at something small.
10:08:48 <gigabytes> ski: why GNU screen?
10:09:13 <ski> so that i can access it from anywhere with net access ?
10:09:25 <glguy> Normal screen is too boring
10:11:10 <clrnd> gigabytes, Vim
10:11:40 <clrnd> svteoi, yes, ofc
10:11:55 <clrnd> I use screen, tmux is just too bloated
10:12:02 <svteoi> I see1
10:12:03 <svteoi> !
10:12:49 <Fuco> too bloated yet has better startup time :D
10:13:44 <clrnd> Fuco, I use screen mainly because my fingers already know it, otehrwise it'd be too much of a hassle
10:15:09 <Fuco> that would make sense if the bindings were different :P
10:15:29 <vanila> tmux is bloated?
10:15:30 <phooby> i'm loving tmux with keybindings optimized for vim-esque navigation
10:15:34 <clrnd> I'm pretty sure they are different
10:15:50 <clrnd> tmux doesn't even use C-a IIRC
10:16:10 <phooby> but you can remap it easily
10:16:16 <clrnd> I'd love it if someone configured it for me and taught me the keys :P
10:16:16 <ski> easy, just change Screen to use `^B'
10:16:37 <vanila> do you mean the source code is large? or it has too many useless features or?
10:16:41 <clrnd> I try not to configure things anymore....
10:16:53 <phooby> clrnd: why not configure it for yourself once and use the same bindings everywhere? that's what i've done for vim, tmux and pretty much my whole environment
10:17:02 <phooby> then just use some system to manage your dotfiles
10:17:02 <koala_man> or does it do 25k allocs per keypress
10:17:44 <clrnd> phooby, oh yeah dotfiles are not the problem
10:17:53 <vanila> oh well :S
10:17:55 <phooby> couple of hours spent now will equal lot of joy for years later
10:18:00 <clrnd> the problem is reading the docs, I;ve already read screen's thosuands of times
10:18:08 <clrnd> and getting used to it
10:18:10 <phooby> heh ok :)
10:18:12 <clrnd> that's not true
10:18:33 <phooby> not true?
10:18:36 <clrnd> in the end I just want to use the terminal
10:18:39 <vanila> i guess its just a buzzword
10:19:46 <s00pcan> "tmux is bloated" ...what
10:19:55 <s00pcan> that doesn't even make sense
10:20:04 <clrnd> vanila, compared to screen?
10:20:08 <clrnd> yeah it does
10:20:19 <saep> I would miss vertical splits if I had to use screen. I find them very important on those wide-screens.
10:20:20 <clrnd> screen can't even split horizontally
10:20:24 <clrnd> vertically*
10:20:24 <vanila> well it doesn't mean anything
10:20:25 <phooby> saep: indeed
10:20:29 <phooby> !
10:20:50 <dgonyeo> screen can do vertical splits in more recent versionas
10:20:55 <koala_man> what? what's the difference between a vertical split and Ctrl-A | ?
10:20:56 <dgonyeo> C-a |
10:20:58 <clrnd> I'm not saying it's better guys don't get upset, it's just what I've used and I appreciate it's minimalistic approach, most functionalities I elarned by trying
10:21:21 <s00pcan> tmux is part of my daily life now
10:21:26 <phooby> with tmux i'm having hoogle in one window, cabal repl in another (with vim keybindings) and vim on the third and it just rocks. would be a pain without vertical splits
10:21:36 <clrnd> but somehow with tmux I had to read the reference 5 times in a row, and said 'well this is enough'
10:22:03 <tremon> phooby: you mean as in ^A S?
10:22:10 <clrnd> how do I even reatach? I accidentally detached it
10:22:16 <s00pcan> tmux a
10:22:26 <vanila> you still haven't explained what you mean by bloated
10:22:27 <clrnd> and tmux --help is so unhelpful
10:22:39 <s00pcan> because man tmux, tmux lscm
10:22:44 <phooby> sorry, meant panel :)
10:23:12 <clrnd> vanila, compared to screen it is
10:23:12 <s00pcan> honestly it's --help should also output lscm
10:23:24 <vanila> you *still* haven't explained what you mean by bloated
10:23:43 <s00pcan> to quote the movie I watched last night... "precision of language!"
10:24:12 <ski> koala_man : `^A|' splits horizontally
10:24:28 <ski> (and `^AS' vertically)
10:24:47 <s00pcan> splits aren't even the most interesting feature
10:24:48 <clrnd> ok it is not bloated, you win, it's better in every sense
10:24:55 <phooby> tremon, vertical split :)
10:25:09 <ski> saep : both splits are in recentish (some years) Screen
10:25:11 <vanila> do you mean the source code is large? or it has too many useless features or?
10:25:19 <koala_man> what about diagonal splits?
10:25:23 <s00pcan> I've browsed the code, it's good stuff
10:25:26 <clrnd> I meant compared to screen, my impresiosn was it was more complciated
10:25:44 <clrnd> screen can't get simpler, it can't
10:25:57 <phooby> s00pcan, very useful feature though
10:26:02 <s00pcan> when I read bloated I think "pulls in two thousand libraries as dependencies". tmux just needs curses and libevent
10:26:18 <koala_man> clrnd: have you tried making it start up in the background with all your windows in place? I'm pretty sure it can
10:26:18 <clrnd> english is not my main language, I could have missused the word
10:26:28 <s00pcan> but I'm guessing clrnd meant it's overwhelming that there are many commands
10:26:37 <phooby> clrnd, np :)
10:26:55 <geekosaur> bloat can be defined in many ways..
10:27:01 <glguy> the merits of tmux and screen are better for #haskell-blah
10:27:25 <clrnd> we should make our own
10:27:28 <clrnd> hscreen
10:27:47 <hodapp> schreen
10:27:51 <hodapp> haskreen
10:27:57 <hodapp> haskreenyl
10:28:13 <kadoban> Starting to sound like something from Star Control 2
10:28:14 <s00pcan> it's basically child processes stored in a red-black tree
10:28:16 <hodapp> tmuskell
10:28:31 <s00pcan> then curses to display
10:28:46 <clrnd> we won the tiling wm war, pretty sure we can take this one too
10:29:26 <hodapp> the tiling WM war was more of a tiling WM picnic table I think
10:29:47 <s00pcan> hodapp: I'm reminded that people picniced at the first battles of the US civil war
10:30:07 <s00pcan> so, it can be both!
10:30:51 <hodapp> but it's called the Civil War, not the Civil Picnic
10:31:08 <s00pcan> well, bullets are more annoying than ants
10:31:13 <hodapp> and it didn't really take place at a picnic table
10:32:17 <geekosaur> wasn't even a squabble; tiling wms are so niche that even the ones that directly "compete" with each other barely notice each other...
10:32:42 <s00pcan> I use xmonad, so you won in this house
10:32:49 <platz> clrnd: i3 is pretty good too.  Can you hierarchically nest arbitrary splits in xmonad, or are you forced to use predefined layouts?
10:34:04 <hodapp> geekosaur: oh, they notice each other, they just try to eat their potato salad quietly and not say anything while GNOME and KDE are playing football against each other and throwing food.
10:34:08 <platz> looks like there is a SubLayouts contrib package
10:34:12 <clrnd> platz, well I'm not into that kind of perfection, I preffer it simple
10:34:33 <s00pcan> I mostly just use fullscreens, since I have... 4
10:34:38 <clrnd> me too :P
10:34:40 <s00pcan> no need to split usually
10:34:50 <geekosaur> platz, yu can nest layouts in various ways, and it's always possible to design new layouts
10:34:55 <platz> i'm not really into perfection, just didn't like default 'layouts' most tiling wm's stick you with
10:35:01 <clrnd> I love xmonad's handling of several screens
10:35:03 <geekosaur> (xmonad is not so much a window manager as a window manager construction kit.)
10:35:06 <clrnd> that's just ... pornographic
10:35:18 <s00pcan> I've got mod4 qwer as monitor selection keys
10:35:41 <clrnd> I have 2 so I have a toggle botton, mod-a
10:35:52 * hackagebot process-extras 0.3.0 - Process extras  http://hackage.haskell.org/package/process-extras-0.3.0 (DavidFox)
10:35:56 <clrnd> button*
10:37:00 <NemesisD> has anyone actually used the migration feature of safecopy?
10:41:35 <Jet-com> https://jet.com/#/ji/cm32c
10:43:17 --- mode: ChanServ set +o johnw
10:43:17 --- mode: johnw set +b *!aa85c8f0@gateway/web/freenode/ip.170.133.200.240
10:43:17 --- kick: Jet-com was kicked by johnw (Kicked)
10:43:17 --- mode: johnw set -o johnw
10:56:37 <halvorg> Hi, I'm working with ST arrays here, but I'm struggling give a helper function a type...
10:56:53 <halvorg> im trying to pass the ST array to a helper function g, but the compiler cannot infer the type
10:57:00 <halvorg> https://gist.github.com/halvorgb/503e24035cf16ca1442a
10:57:31 <halvorg> "s is applied to too many arguments..."
10:58:34 <glguy> halvorg: s Int ---> ST s Int
10:58:52 <AureliusO> I was wondering if anyone could give me a hand with a c2hs error. Where would be a good place to ask?
10:59:22 <bgamari> AureliusO, sure
11:00:59 <halvorg> thanks glguy :)
11:01:09 <AureliusO> bgamari, thanks! I am using the libraries shipped with the most recent Haskell Platform on windows, but I am getting "The symbol `__attribute__' does not fit here." for stddef.h
11:01:58 <ski> halvorg : you don't need the brackets around the call to `MA.STArray', either
11:04:01 <muzzle> hi, i have a problem in a cabal project of mine: The project (a small compiler) consists of an executable a test-suite and a library section. However when i want to build it, i get the following error message
11:04:02 <muzzle> Undefined symbols for architecture x86_64:
11:04:02 <muzzle>   "_interlangzmtestzm0zi1zi0zi1_ParseziMJLex_alexScanTokens_closure", referenced from:
11:04:02 <muzzle>       _Sm0N_srt in libinterlang-test.a(InterlangTest.o)
11:04:02 <muzzle>   "_interlangzmtestzm0zi1zi0zi1_ParseziMJLex_alexScanTokens_info", referenced from:
11:04:02 <muzzle>       _cmy8_info in libinterlang-test.a(InterlangTest.o)
11:04:03 <muzzle>       _cmAk_info in libinterlang-test.a(InterlangTest.o)
11:04:03 <muzzle>   "_interlangzmtestzm0zi1zi0zi1_ParseziMJParse_happyNewToken_closure", referenced from:
11:04:04 <muzzle>       _Sm0N_srt in libinterlang-test.a(InterlangTest.o)
11:04:04 <muzzle>   "_interlangzmtestzm0zi1zi0zi1_ParseziMJParse_happyNewToken_info", referenced from:
11:04:05 <muzzle>       _cmya_info in libinterlang-test.a(InterlangTest.o)
11:04:05 <muzzle>       _cmAm_info in libinterlang-test.a(InterlangTest.o)
11:04:06 <muzzle>   "_interlangzmtestzm0zi1zi0zi1_ParseziMJParse_notHappyAtAll_closure", referenced from:
11:04:06 <muzzle>       _cmya_info in libinterlang-test.a(InterlangTest.o)
11:04:07 <muzzle>       _cmAm_info in libinterlang-test.a(InterlangTest.o)
11:04:07 <muzzle>       _Sm0N_srt in libinterlang-test.a(InterlangTest.o)
11:04:20 <EvanR-work> use a paste
11:04:26 <EvanR-work> @lpaste
11:04:26 <lambdabot> Haskell pastebin: http://lpaste.net/
11:05:22 <muzzle> sorry bout that
11:05:24 <muzzle> http://pastebin.com/vnTBPY41
11:06:58 <muzzle> and that would be my .cabal file: http://pastebin.com/gNJNZMCB
11:07:19 <muzzle> do you have any ideas ?
11:11:07 <EvanR-work> muzzle: linker error? you dont have the library or dont have the right version of the library
11:11:29 <EvanR-work> or it wasnt provided during link time
11:11:32 <muzzle> i have the library
11:11:40 <muzzle> its an alex parser in the project
11:11:48 <muzzle> alex/happy
11:11:57 <muzzle> both modules are in the project
11:12:07 <muzzle> and exposed in the library section of the .cabal file
11:12:44 <muzzle> the executable builds just fine
11:12:55 <EvanR-work> oh, that happens when you run it?
11:12:59 <muzzle> its only now that i added a test suite that the build fails when creating the test suite
11:15:15 <tdammers> muzzle: how could a build possibly fail while creating a test suite when there is no test suite to create?
11:18:05 <muzzle> what do you mean exactly ?
11:18:11 <homovitruvius> not haskell per se, but what emacs users here use to quickly switch to "related" buffers? say you're editing parsec files and want to quickly switch to AST definitions or tests
11:18:37 <muzzle> when i want to run the test, i do it like this: cabal clean; cabal configure --enable-tests; cabal test
11:23:37 <muzzle> do you know any resources that could help me ? (aside from cabal user guide) ?
11:23:45 <J_Arcane>  https://www.fpcomplete.com/blog/2015/01/hiring-software-engineer?preview=true
11:25:04 <dcoutts_> muzzle: what's the question exactly?
11:27:27 <muzzle> how can i get my test suite to run with out this error: http://pastebin.com/vnTBPY41
11:27:43 <muzzle> when i load the test module in cabal repl it runs just fine
11:28:29 <dcoutts_> muzzle: can you post your .cabal file somewhere
11:28:45 <dcoutts_> and be specific about what commands you ran
11:30:03 <michaelt> dcoutts_: he posted his cabal file http://pastebin.com/gNJNZMCB
11:30:10 <dcoutts_> oh ta
11:30:33 <AureliusO> Hello, any chance someone could help me with a gtk2hsc2hs problem?
11:31:08 <muzzle> dcoutts_: cabal clean; cabal configure --enable-tests; cabal test
11:31:13 <muzzle> are the commands i used
11:34:43 <dcoutts_> muzzle: not totally sure what's going on yet, but you're not going to have much luck with the detailed-0.9 test type. I'd stick to the normal exitcode-stdio-1.0 one for now
11:36:19 <dcoutts_> muzzle: your test/ dir doesn't contain much other than InterlangTest.hs right?
11:37:07 <muzzle> dcoutts_:nothing else
11:37:30 <dcoutts_> for some reason it's expecting to find these things from your lexer and parser in the libinterlang-test library, rather than from the MiniJavaCompiler library where they are really
11:37:33 <dcoutts_> not sure why that is
11:38:13 <dcoutts_> muzzle: but using the normal "type: exitcode-stdio-1.0" will probably not have this problem
11:38:23 <dcoutts_> as it works in a rather different way in terms of linking
11:40:05 <muzzle> dcoutts_: thx
11:40:09 <muzzle> i'll try that
11:59:48 <jonazzzzzz> can anyone tell me how i know in which steps this gets executed?: (+) <$> (+3) <*> (*100) $ 5
12:01:10 <ski> what it computes to, or how ?
12:01:30 <jonazzzzzz> how
12:01:44 <ski>      (+) <$> (+3) <*> (*100) $ 5
12:01:46 <jonazzzzzz> like in what steps and how do i know which step is executed first
12:02:00 <ski>   =  ((+) <$> (+3) <*> (*100)) 5
12:02:15 <jonazzzzzz> yes
12:02:20 <ski>   =  ((+) <$> (+3)) 5 ((*100) 5)
12:03:00 <jonazzzzzz> hmm why is <*> first and not <$>
12:03:00 <ski>   =  (+) ((+3) 5) ((*100) 5)
12:03:11 <ski>   =  (+) (5 + 3) ((*100) 5)
12:03:19 <ski>   =  (+) 8 ((*100) 5)
12:03:26 <ski>   =  (+) 8 (5 * 100)
12:03:32 <ski>   =  (+) 8 500
12:03:43 <ski>   =  508
12:04:17 <ski> jonazzzzzz : because `a <$> b <*> c' means `(a <$> b) <*> c'
12:04:34 <ski> (hm, i could have infixed the main `+' here, but forgot about it)
12:04:47 <jonazzzzzz> and how u know that? its something with associativity?
12:04:55 <michaelt> jonazzzzzz: infixl 4 <$> <*>
12:05:40 <ski> (there should be a `,' inbetween the two operators there)
12:05:57 <jonazzzzzz> ok i see it with the :i command
12:06:04 <ski> so, they have the same precedence level, and so we need to look at the associativities to determine
12:06:12 <jonazzzzzz> so they both equal
12:06:14 <jonazzzzzz> oh ok
12:06:18 <michaelt> yeah, i was summarizing :i (<$>) etc from ghci
12:06:23 <ski> since both are left-associative, it's the left one which wins the tug-of-war
12:07:52 <jonazzzzzz> i see thanks guys
12:08:10 <danilo2> Hello! I'm writing a logging library and I want to run logger on one thread and be able to gather logs from different threads. I was thinking about using pipes-concurrency for that - logger will just wait for messages and there will be many producers. Do you think this is the best solution or should I use something other than pipes here? :)
12:09:22 <ski> jonazzzzzz : .. and in an application `f x', `f' is evaluated first, to determine the function which will then say how (if) to evaluate `x'
12:09:31 <mpickering> This exact problem is explored in Simon Marlow's book danilo2
12:09:56 <danilo2> mpickering: oh interesting, thank you!: )
12:10:57 <danilo2> mpickering: Would you be so nice and point me what chapter (if you know / remember it of course)
12:11:29 <mpickering> let me find my copy..
12:15:11 <mpickering> danilo2: p. 130 chapter 7
12:15:37 <mpickering> I don't know hoe pipes-concurrency works
12:16:17 <jonazzzzzz> ski
12:16:21 <danilo2> mpickering: thank you so much!
12:16:25 <jonazzzzzz> i still don't understand how u go from this to this:
12:16:26 <jonazzzzzz> =  ((+) <$> (+3) <*> (*100)) 5
12:16:26 <jonazzzzzz>   =  ((+) <$> (+3)) 5 ((*100) 5)
12:17:01 <michaelt> http://chimera.labs.oreilly.com/books/1230000000929/ch07.html#sec_conc-logger danilo2
12:18:04 <ski> @src (->) (<*>)
12:18:04 <lambdabot> (<*>) f g x = f x (g x)
12:18:07 <ski> jonazzzzzz ^
12:18:53 <danilo2> mpickering, michaelt: oh I could found that by myself I was looking for all the chapters and havent (somehow) found the word "logging". I'm sorry for taking your times :( Anyway I see they use mvars there, do you think using pipes-concurerent will be better approach? I do not see any workd about pipes in the whole book as far as I see,
12:20:00 <mpickering> I've never used pipes-concurrent
12:20:38 <mpickering> It looks like a logger is one of the examples though
12:22:19 <danilo2> mpickering: You are right. I was asking about pipes concurrent because they just provide much nicer interface. Thank you for your help! :)
12:22:29 <jonazzzzzz> ski thanks i get it now :)
12:27:13 <mmaroti> Hi Guys! I have a question: I have a type class (class Graph a where; size :: a -> Integer; edge :: a -> Integer -> Integer -> Bool) with functions that is completely enough to generically implement Show. However, when I try to write "instance Graph a => Show a where" then I get an error about flexible instances. Is it possible to implement Show in a polymorphic way for any data type that implements Graph?
12:30:04 <EvanR-work> mmaroti: you might need overlapping instances too
12:30:21 <shachaf> mmaroti: No.
12:30:35 <lyxia> this looks like an odd way of implementing graphs btw
12:31:12 <shachaf> mmaroti: The way instance resolution works ignores any constraints on the instance declaration. So it's like you're just declaring "instance Show a".
12:31:57 <EvanR-work> mmaroti: (Integer, Integer -> Integer -> Bool) will accomplish what you want
12:32:33 <mmaroti> Too bad. I could implement a default showGraph :: method in the Graph typeclass, right, but cannot connect it with Show a?
12:32:36 <EvanR-work> you still cant implement show for that, but you can use a newtype
12:32:44 <benmachine> mmaroti: you don't need to put it in the typeclass
12:33:02 <EvanR-work> your graph is a data structure, not a type class
12:33:04 <benmachine> you can just write a normal function called showGraph
12:33:18 <edermi> hello. what's the easiest way to find out, how often an element x is in a list xs? e.g. how often is 1 in [0,1,1,0,0,1,1]
12:33:45 <EvanR-work> length . filter (== 1)
12:34:19 <edermi> EvanR-work: Thanks, I had the filter idea too. Seems quite easy
12:34:22 <mmaroti> Ok, I can write a showGraph function, no problem there.
12:34:54 <EvanR-work> if data MyGraph = MyGraph Integer (Integer -> Integer -> Bool), you can also implement Show for it
12:35:21 <EvanR-work> (using showGraph)
12:35:51 <ski> mmaroti : why do you want to make a `Show' instance ?
12:37:48 <mmaroti> I want to create data types for the product of graphs, for induced subgraphs, etc. So there will be several data types all implementing the graph type class
12:38:10 <EvanR-work> all of them can be mapped to MyGraph
12:38:40 <EvanR-work> which is one way to think of subtypes, and you sound like youre thinking of subtypes
12:38:56 <mmaroti> You are right.
12:39:37 <ski> subtypes ?
12:40:09 <mmaroti> Ok, I like the graph data structure containing the size and edge function. Nice
12:40:27 <mmaroti> Thanks!
12:40:43 <EvanR-work> product of graphs, induced subgraph, supposedly can all be used wherever MyGraph is used
12:41:36 <ski> graph equality should be isomorphism, right ?
12:41:51 <EvanR-work> graph equality?
12:43:27 <EvanR-work> i guess its simpler if a product of graphs was a graph, and a subgraph was also a graph, all the same type
12:43:57 <yaxu> Does anyone know whether it's possible to evaluate statements rather than expressions using Language.Haskell.Interpreter, like ghci does?
12:44:32 <yaxu> i.e. so I can evaluate the string "foo <- bar"
12:44:59 <mmaroti> Equality would be same size same edges
12:45:51 <EvanR-work> im wondering how you would use that graph type at all, with the bool function there
12:45:58 * hackagebot funcmp 1.8 - Functional MetaPost  http://hackage.haskell.org/package/funcmp-1.8 (PeterSimons)
12:46:00 * hackagebot haste-compiler 0.4.4.1 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.4.4.1 (AntonEkblad)
12:46:24 <EvanR-work> implicit universe of all vertices to check against?
12:46:39 <ski> presumably `[0 .. size graph - 1]'
12:46:57 <EvanR-work> could be
12:47:18 <EvanR-work> size is one kind of number, vertex id is another
12:47:24 <EvanR-work> just a name
12:49:06 <mmaroti> that is the plan, but now with your solution it is not clear
12:49:26 <mmaroti> In the product of graphs the elements should be tuples not integers
12:49:51 <EvanR-work> that was your original inteface, not mine
12:50:10 <mmaroti> so I need an elem type, maybe an enum?
12:51:26 <mmaroti> So for products I want to use tuples for the elements, so the "data Graph = Graph Int (Int -> Int -> Bool)" is not so good.
12:51:57 <EvanR-work> in general the vertexes comes from any set
12:52:21 <EvanR-work> data Graph a = Graph Int (a -> a -> Bool)
12:52:54 * ski . o O ( `class Graph g where data Node g :: *; data Edge g :: Node g -> Node g -> *; ...' hmm )
12:53:03 <mmachenry> My sysadmin is getting ExitFailure 127 (C library missing) when trying to build the unix package. When I built this on the same machine it built fine. What aspects of his environment can I check for differences to debug this? http://lpaste.net/118389
12:54:26 <EvanR-work> Graph Integer is what you originally suggested
12:54:43 <geekosaur> mmachenry, the build failure for unix is somewhere previous to that
12:55:31 <mmaroti> I still need to enumerate all elements and I need show for the element type
12:55:37 <mmachenry> geekosaur: Ah sorry, getting the whole thing now.
12:55:45 <EvanR-work> mmaroti: you were using the size to do that?
12:56:21 <mmaroti> So maybe "data (Show a, Eq a, Enum a) => Data a = Integer (a -> a -> Bool)"
12:56:40 <mmaroti> Yes, I want the size for getting the bounds
12:56:42 <EvanR-work> before worrying about Show you need to figure out what youre doing
12:57:06 <ski> mmaroti : it's probably not a good idea to put the constraints there
12:57:12 <shachaf> Don't put constraints after the word "data". It's invalid Haskell 2010 (the feature got taken out because it was useless).
12:57:23 <mmaroti> want to work with graphs
12:57:45 <EvanR-work> you can use Bounded, Enum, or a new operation for the set of all vertices
12:58:56 <EvanR-work> of course, it might be silly to include a list or set of vertices, some of which arent in the graph
12:59:27 <EvanR-work> if they arent there you know the test is False
12:59:55 <mmaroti> It looks like I need to encode everything with functions within the data type (like enumerate all elements, etc)
13:00:12 <mmaroti> this does not look so good anymore
13:00:20 <Peaker> shachaf: what was the useless feature? require constraints when building the data, but not get them back when pattern matching?
13:00:29 <Peaker> (or even requiring them again when pattern matching?)
13:01:02 <ski> the latter
13:01:08 <mmachenry> geekosaur: I think that's his full output from the rerun.
13:01:18 <Peaker> ah, what a mishap :)
13:01:19 <EvanR-work> mmaroti: isnt a graph a list of edges?
13:01:19 <shachaf> Yes.
13:01:23 <mmachenry> But there's more input if you delete .cabal-sandbox and retry from the top
13:01:38 <ski> and you didn't even get the constraints into the kind :(
13:01:46 <shachaf> Of course, an "existential" constraint is probably not a good idea for that sort of situation either.
13:01:51 <geekosaur> that can't be right because the first line is the last of 8 lines from another package build
13:01:59 <geekosaur> (at least 8 lines from...)
13:02:08 <shachaf> ski: Is there a name for an "existential" constraint other than *> ?
13:02:18 <mmachenry> Oh… right. Well I'm about to get more full output.
13:02:22 <ski> i don't know
13:02:27 <ski> maybe we could invent one
13:02:31 <shachaf> GHC just includes it under ExistentialQuantification, but it should really have a separate name.
13:02:44 <shachaf> The dual of a constraint.
13:02:45 * ski thinks `ExistentialQuantification' should be renamed
13:02:46 <mmaroti> Yup, "data (Show a, Enum a) => Graph a = Graph Integer (a -> a -> Bool)" gives Illegal datatype context (use -XDatatypeContexts)
13:03:01 <EvanR-work> you dont need that constraint there anyway
13:03:12 <ski> (.. perhaps to `ExistentialComponents' or `ExistentialConstructor' or something)
13:03:22 <c_wraith> DatatypeContexts are deprecated because they don't help much of anything
13:03:34 <mmaroti> So I need to use constraints on the function declarations, like show graph?
13:03:37 <RustyShackleford> how would you code a deck of cards?
13:04:02 <ski> mmaroti : that's often nice
13:04:11 <EvanR-work> mmaroti: showGraph, yeah.
13:04:18 <RustyShackleford> a playing card has two qualities: rank (A, K, 8 for example) and suit
13:04:19 <Peaker> c_wraith: it's like a function that has only arguments, but not results
13:04:46 <shachaf> ski: Tell me if you come up with a good name.
13:04:47 <ski> RustyShackleford : a pair of a color and a value ?
13:04:55 <ski> shachaf : if i recall :)
13:04:58 <RustyShackleford> suit and a value, but yet
13:05:03 <EvanR-work> you cant expect to show a graph without being able to go through all the vertices, but that doesnt mean you cant define a graph that cant enumerate the vertices (in your version)
13:05:08 <ski> ok
13:05:10 <RustyShackleford> so do I define a type for it? Or just use tuples perhaps?
13:05:13 <c_wraith> Peaker: hmm..  I suppose that's a decent analogy - it translates (in core) to requiring an unused argument.
13:05:19 * ski thought they could be called "colors" as well
13:05:35 <RustyShackleford> oh idk. Maybe in different regions
13:05:41 <ski> RustyShackleford : a separate type could possibly be nice
13:05:57 <benmachine> separate types are often a godo idea
13:05:58 <benmachine> good
13:06:07 <RustyShackleford> anyway,  I'm trying to learn all the different features of haskell, so I'd like to define a type
13:06:31 <EvanR-work> depending on rules, PlayingCards could have different Ords but... in many games its a PartialOrd ... wheres the class for that
13:06:33 <benmachine> you'd only really use tuples if you wanted to reuse code written about tuples, I can't think of anything that would be super useful for that here
13:07:01 <benmachine> EvanR-work: don't use a class, then
13:07:25 <EvanR-work> ah
13:07:45 <EvanR-work> Card -> Card -> Maybe Ordering
13:07:55 <RustyShackleford> Do I want something like: data Suit = "Diamonds" | "Hearts" | "Spades" | "Clubs"?
13:08:19 <EvanR-work> no quotes
13:08:37 <RustyShackleford> i'm also wondering, if I did that, can I iterate over those four possible values?
13:08:45 <EvanR-work> deriving (Enum)
13:08:50 <RustyShackleford> EvanR-work: oh I didn't know I could do that
13:09:33 <pranz> RustyShackleford: you put that right after your declaration
13:09:33 <RustyShackleford> EvanR-work: so the deriving (Enum) is required if I remove those quotes?
13:09:43 <EvanR-work> no
13:09:50 <EvanR-work> but removing quotes is required
13:10:41 <RustyShackleford> alright then
13:11:43 <mmaroti> EvanR-work: this does not compile: "showFirstElem :: (Show a, Enum a) => (Graph a) -> String; showFirstElem (Graph size edge) = show (toEnum 0)" because of
13:11:55 <mmaroti> vould not deduce (Enum a0) arising from a use of `toEnum'
13:12:06 <mmaroti> vould=could
13:13:00 <RustyShackleford> this language is quite alot to process at once
13:13:15 <EvanR-work> mmaroti: well, you dont need the graph in that case
13:13:22 <benmachine> mmaroti: the problem there is that toEnum 0 could be all sorts of things, and the fact that you pass it to 'show' doesn't tell you which one
13:13:39 <RustyShackleford> i've been programming for like 6 years and i haven't seen a bunch of these concepts before
13:13:53 <EvanR-work> showFirst :: (Show a, Enum a) => a -> String
13:13:56 <tdammers> oh crap, ambiguous type variable m2
13:13:58 <EvanR-work> RustyShackleford: its about time ;)
13:14:21 <RustyShackleford> would I do the same thing as Suit for representing a card's rank?
13:14:37 <mmaroti> Ok, I wanted to list all elements of the graph, but got bogged down with the first :)
13:14:42 <RustyShackleford> data Rank = Two | Three | ... | King | Ace
13:14:54 <mmaroti> do the showLastElem
13:15:13 <benmachine> mmaroti: it's easier if you write getFirstElem :: (Enum a) => Graph a -> a, then worry about showFirstElem afterwards
13:15:43 <EvanR-work> RustyShackleford: you can
13:16:40 <ski> RustyShackleford : variant / sum / disjoint/discriminated/tagged union / variant record types / algebraic datatypes are great
13:17:21 <RustyShackleford> ski: ah. I know some of those words
13:17:50 <ski> .. especially with pattern-matching on them
13:17:58 <lpaste> tdammers pasted “How do I get this to compile?” at http://lpaste.net/118391
13:18:14 <tdammers> ^ thoughts?
13:19:23 <StoneToad> tdammers: what's the error?
13:19:43 <tdammers> StoneToad: wait, forget that, it does compile
13:19:44 <tdammers> derp
13:20:10 <EvanR-work> in that case, use the identity morphism on your code
13:20:48 <benzrf> EvanR-work: but that does nothing!
13:20:57 <benzrf> oh wait shit
13:21:04 <benzrf> tfw i fail to look at context
13:21:08 <EvanR-work> lol
13:21:13 <StoneToad> tdammers: btw isnt' that the ONLY instance of ToFoobar that's possible to write?
13:21:34 <sclv> @remember tpolecat any lecture by conal elliott has that flavor. he is the bob ross of functional programming.
13:21:35 <lambdabot> Nice!
13:21:35 <StoneToad> well, I guess you could write a float isntance if you rounded/truncated/whatver to int...
13:22:10 <benmachine> StoneToad: you can write an instance for whatever you want
13:22:11 <srhb> sclv: I think you meant @tell?
13:22:41 <tdammers> StoneToad: yeah, well, not the point
13:22:50 <srhb> Or maybe I'm misremembering lambdabot commands.
13:23:00 <benmachine> srhb: remember sotres it in the quote database
13:23:09 <srhb> That's what I thought.
13:23:12 <benmachine> tell is for when you want to send a message to a person once
13:23:20 <srhb> It looked like a @tell to me. :)
13:23:34 <tdammers> I'm getting an error on a real codebase, tried boiling it down to a digestible paste
13:23:36 <benmachine> the syntax is the same so you've only got context to go on
13:23:38 <tdammers> obviously that didn't work
13:23:38 <mmachenry> geekosaur: Here's the full output from my error. http://lpaste.net/118389 Important to remember that I ran the same "cabal install —only-dependencies" as he did on the same server and it worked.
13:23:43 <tdammers>     Could not deduce (ToGVal m2 v) arising from a use of `toGVal'
13:23:46 <tdammers>     from the context (ToGVal m v)
13:23:48 <tdammers> this is the actual error
13:23:50 <mmachenry> Looking for ideas of what to check in his env that's different from mine.
13:24:07 <benzrf> sclv your falsely crediting tpolecat w/ that quote when im p sure it came from elsewhere o_o
13:24:13 <benzrf> unless im wrong of c
13:24:20 <StoneToad> tdammers: do you have only one instance in the actual code base?
13:24:29 <tdammers> no, I have several
13:24:47 <StoneToad> try adding a 2nd instance to your paste code and see if you can reproduce the error
13:24:58 <StoneToad> flexible instances can cause real headaches when things go wrong
13:25:08 <tdammers> edited paste
13:25:15 <tdammers> still compiles fine though
13:26:21 <geekosaur> mmachenry, so far I don't even see it compiling the unix package... but I am already suspicious as I see it building bytestring. are you overriding bootlibs?
13:26:45 <geekosaur> you should not install new versions of any package that comes with ghc. that usually includes unix (or win32 on Windows)
13:26:48 <mmachenry> Overriding bootlibs? I don't know what that means but I guess not.
13:26:54 <benmachine> tdammers: sometimes you can get errors like that because of ambiguous types... you could try spraying annotations over your code if you can't make a smaller failing example
13:27:02 <geekosaur> I just told you what that means
13:27:03 <benmachine> bit of a crude debugging method, but sometimes it works :)
13:27:06 --- mode: ChanServ set +o geekosaur
13:27:25 --- mode: geekosaur set +b *!*@80.30.148.106
13:27:25 --- kick: tumaru was kicked by geekosaur (tumaru)
13:27:28 <tdammers> benmachine: tried that, maybe I need to spray more >:->
13:27:32 <geekosaur> spamming in pm
13:27:35 --- mode: geekosaur set -o geekosaur
13:27:59 <EvanR-work> :t (>:->)
13:28:00 <lambdabot> Not in scope: ‘>:->’
13:28:03 <bezirg> hello, I understand that the network package calls some C through the FFI. Is this thread-safe? in other words, can I make multiple TCP requests each done by a different forkIO - thread? Do I also need to turn on the -threaded RTS or can I run it with the simpler RTS?
13:28:06 <mmachenry> geekosaur: Well, I have a line that my project depends on unix in the .cabal file.
13:28:34 <benmachine> tdammers: I can actually also imagine how this could be caused by bad annotations, though >_> like, if you're using "m" in a type signature and you're meaning to refer to this other m but GHC doesn't realise that
13:28:35 <EvanR-work> bezirg: on the same socket?
13:28:39 <geekosaur> mrrr, lines 368-369, not helpful at all...
13:28:44 <mmachenry> I'm building a user-land application. So I'm not trying to do anything tricky. Is the solution to remove unix = 2.7.0.1 from my program.cabal file?
13:28:50 <bezirg> EvanR-work: I use a different socket for each thread
13:28:56 <geekosaur> probably need to manually attempt to install it with -v3 so we get full output from cabal
13:29:00 <bezirg> EvanR-work: for each request I mean
13:29:04 <nitrix> Is there such thing as a EitherT monad transformer?
13:29:07 <EvanR-work> bezirg: nothing bad will happen, you dont even need -threaded
13:29:07 <tdammers> benmachine: yes, that's pretty much what this boils down to
13:29:16 <nitrix> For this return type:  IO (Either Errno ByteString)
13:29:22 <geekosaur> mmachenry, if your program actually requires that exact version of unix then you should really use a different ghc version that ships with it
13:29:23 <tdammers> benmachine: I'm just stumped at how to convince the compiler that they're supposed to be the same m
13:29:37 <levi> nitrix: There is an EitherT monad transformer.
13:29:39 <benmachine> tdammers: ah. well, there's only so much I can help you without code to look at, but ScopedTypeVariables might be able to rescue you
13:29:50 <benmachine> tdammers: alternatively, you can use silly tricks
13:30:03 <geekosaur> but if you enjoy living dangerously, you can try to make it work. but as I said will need output from 'cabal install -v3 unix' in the sandbox
13:30:24 <lpaste> tdammers pasted “OK, I give up, here's the whole thing” at http://lpaste.net/2812786846793203712
13:30:59 <nitrix> levi: Is there a real benefit to monad transformers? MaybeT IO String instead of IO (Maybe String), other than convenience saying in the same monadic context?
13:31:01 <tdammers> compiler complains about line 223/224, among others
13:31:12 <bezirg> EvanR-work: thank you
13:31:15 <EvanR-work> MaybeT IO String is different from IO (Maybe String)
13:31:52 <EvanR-work> :t runMaybeT
13:31:53 <lambdabot> Not in scope: ‘runMaybeT’
13:31:56 <Peaker> nitrix: (>>=) has the meaning you want, and you can use all the monadic combinators with *that* meaning
13:32:18 <Peaker> nitrix: and you can compose many transformers, of course
13:32:20 <NemesisD> any haskell-mode users here? i've been having some trouble with haskell-process. once a file typechecks, it will refuse to load it again and the repl will freeze
13:32:27 <glguy> You need -threaded when using sockets on windows according to the docs
13:32:29 <jle`> nitrix: it's sort of a similar deal like with newtype wrappers over different Monad instances
13:32:33 <geekosaur> mmachenry, the problem comes in when you try to combine your stuff built against that version of unix, with some other package built against the one that came with ghc
13:32:43 <EvanR-work> urg
13:32:43 <geekosaur> this leads to type errors
13:32:56 <jle`> (>>=) and return, monad combinators,  (<*>), fmap, etc. have an alternative meaning
13:32:56 <benmachine> tdammers: are you able to determine whether or not 'asText . toGVal' causes an error by itself?
13:33:27 <jle`> *newtype wrapper over different Monoid instances
13:34:29 <EvanR-work> MaybeT IO String can cancel early, IO (Maybe String) cant (well it can, with exceptions)
13:34:33 <benmachine> tdammers: okay, so, asText :: GVal m -> Text, right? and toGVal :: (ToGVal m a) => a -> GVal m? so asText . toGVal :: (ToGVa m a) => a -> Text, and it can't work out what m is supposed to be there
13:34:35 <jle`> EvanR-work: MaybeT IO String is actually just a newtype wrapper over IO (Maybe String)
13:34:43 <jle`> so they're the same type
13:34:48 <jle`> they just have different Monad instances
13:34:50 <benmachine> tdammers: does that sound like the problem to you?
13:34:54 <tdammers> yeah
13:34:58 <tdammers> hmm
13:35:32 <EvanR-work> jle`: ok, they behave differently
13:35:53 <benmachine> tdammers: oh good, we ended up on the same side :P
13:36:48 <tdammers> I think the point is it can't work out that it doesn't matter which m you pick, because asText never needs it
13:37:10 <benmachine> tdammers: well, it *does* matter what m you pick, because that determines what instance you get, right?
13:37:31 <benmachine> tdammers: like, toGVal might do different things depending on what m is
13:38:17 <benmachine> if you had instance ToGVal IO Bool but also ToGVal Identity Bool
13:38:22 <benmachine> then you'd be in trouble
13:38:43 <EvanR-work> @src Identity
13:38:43 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
13:39:03 <tdammers> ah yes
13:39:04 <bsmt> yeah really
13:39:15 <tdammers> well, in practice it won't, but there is no way the compiler can know that
13:40:04 <EvanR-work> noooo
13:40:37 <tdammers> benmachine: not necessarily, but potentially
13:41:02 * hackagebot DRBG 0.5.4 - Deterministic random bit generator (aka RNG, PRNG) based  HMACs, Hashes, and Ciphers.  http://hackage.haskell.org/package/DRBG-0.5.4 (ThomasDuBuisson)
13:41:07 <tdammers> hmm crap
13:41:49 <jle`> goodbye net
13:41:50 <jle`> you have split
13:41:50 <jle`> that was a rather tidy netsplit
13:47:00 <benmachine> tdammers: http://lpaste.net/2812786846793203712#a5585825944515379200 does this help
13:47:27 <tdammers> lemme check
13:47:39 <benmachine> tdammers: warning: not even type checked, you may need to fix minor screwups :)
13:47:45 <sssilver|> Hey guys, I've heard something about how Haskell programs can be mathematically proven to contain no bugs/adhere to the specification. Where can I read more about this?
13:48:16 <tdammers> benmachine: that's fine, I get the idea
13:48:28 <benzrf> sssilver|: software foundations probably?
13:48:37 <benzrf> hey johnw u online?
13:48:40 <johnw> hi
13:48:58 <johnw> sssilver|: You might be thinking about parametricity
13:49:00 <tdammers> think I tried something similar without success, but maybe there's a subtle detail I missed
13:49:00 <benzrf> johnw: sssilver| is interested in proven progrms
13:49:11 <benmachine> tdammers: this particular case lent itself very well to that sort of refactoring, other times you might not be so lucky but there's still things you can do
13:49:18 <kadoban> sssilver|: Agda or Coq are more likely to be what you're looking for there, from what little I know.
13:49:29 <johnw> on the spectrum, you can go from:
13:49:31 <benzrf> kadoban: well, they can be used to prove the behavior
13:49:38 <benzrf> kadoban: they arent so practical for writing programs
13:49:44 <benzrf> er, there's extraction i guess
13:49:49 <jle`> sssilver|: parametricity and equational reasoning maybe?
13:49:51 <johnw> plain Haskell with parametric polymorphism; GADTs and DataKinds; Singletons; Hasochism; Liquid Haskell; Coq with extraction to Haskell
13:50:12 <benzrf> hasochism lol
13:50:29 <simukis_> freenode dying
13:50:31 <johnw> I mean by that "as dependently typed as Haskell can presently get, no matter the pain"
13:50:49 <benzrf> doesnt haskell just straight up not have pi types
13:50:50 <benzrf> how can you work around that?
13:51:01 <benmachine> simukis_: they did warn they were about to do maintenance
13:51:09 <johnw> there is a kind of subset of them
13:51:09 <benzrf> i guess you could define all your types as GADTs so that values are available at the type level?
13:51:19 <johnw> like, forall (n : Nat). Vector n a
13:51:28 <johnw> they are just restricted to types which represent as singletons
13:51:36 <johnw> so, not true pi-types
13:51:44 <Pamelloes> Wooooo netsplit! :D
13:52:39 <Pamelloes> I never understood what "*.net *.splt" meant though
13:52:54 <jle`> what am i thinking about when i'm thinking about a mapping from Bool to Bool that turns True to False, False to True, and And to Or?
13:53:06 <jle`> is it a monoid homomorphism?
13:53:06 <johnw> sssilver|: does that help at all?
13:53:17 <jle`> Pamelloes: i think it's just like freenode's way of telling us what's up
13:53:24 <sssilver|> johnw: yeah, I think coq and Curry–Howard correspondence are what I was looking for
13:53:28 <sssilver|> thanks!
13:54:14 <jle`> if i flip true/false and and/or, then the monoid on ((||), False) and the monoid ((&&), True) are preserved
13:54:18 <Pamelloes> jle`: I've seen it on other servers, though.... I was under the impression that there were other types of netsplit but I've never seen anything but '*.net *.splt'
13:55:08 <glguy> The old behavior is that the split message would tell you which link in the network went down, but now the topology is private
13:55:09 <lispy> http://www.reddit.com/r/haskell/comments/2sbsga/a_simple_example_of_calling_rust_from_haskell/
13:55:35 <glguy> clients still expect a certain message format, so they put *.net *.split there instead
13:55:45 <Pamelloes> Ah ok
13:55:51 <Pamelloes> That makes a lot of sense
13:56:02 * hackagebot simple-smt 0.5.0 - A simple way to interact with an SMT solver process.  http://hackage.haskell.org/package/simple-smt-0.5.0 (IavorDiatchki)
13:56:11 <johnw> sssilver|: ah, in that case join us in #coq :)
13:58:11 --- mode: wilhelm.freenode.net set +o ChanServ
13:58:45 <Welkin> DDoS?
13:58:59 <benzrf> netspliIIIIIIIIITTTTT
13:58:59 <benzrf> tdammers: benmachine cannot hear you
13:58:59 <tdammers> benzrf: yeah, I noticed
14:00:19 <glguy> Everything is fine, nothing is ruined. Freenode's just doing maintenance.
14:00:26 <benmachine> tdammers: I can now! but am also doing some paperwork
14:06:02 * hackagebot yesod-markdown 0.9.3.1 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.9.3.1 (PatrickBrisbin)
14:11:02 * hackagebot vector-space-points 0.2.1 - A type for points, as distinct from vectors.  http://hackage.haskell.org/package/vector-space-points-0.2.1 (bergey)
14:11:05 * hackagebot diagrams-core 1.2.0.5 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.2.0.5 (bergey)
14:16:03 * hackagebot diagrams-lib 1.2.0.8 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.2.0.8 (bergey)
14:16:05 * hackagebot force-layout 0.3.0.9 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.3.0.9 (bergey)
14:17:07 <karshan> Hey, is the owner of DRBG in the channel ?
14:18:16 <Pamelloes> How do I differentiate (-) meaning negation and meaning subtraction?
14:19:08 <shapr> > -1
14:19:10 <lambdabot>  -1
14:19:14 <shapr> > (-1)
14:19:14 <Pamelloes> I want to use partially applied subtraction (-1)::Num -> Num, but it's being interpreted as (-1) :: Num
14:19:15 <lambdabot>  -1
14:19:21 <kadoban> :t subtract
14:19:22 <lambdabot> Num a => a -> a -> a
14:19:26 <ski> Pamelloes : `subtract 1'
14:19:31 <shapr> > :t (-) 1
14:19:33 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:19:35 <shapr> :-P
14:19:38 <ski> or `flip (-) 1'
14:20:16 <ski> > map (subtract 1) [2,3,5,7]
14:20:18 <lambdabot>  [1,2,4,6]
14:21:03 * hackagebot diagrams-contrib 1.1.2.5 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1.2.5 (bergey)
14:21:18 <Pamelloes> Thanks :)
14:21:26 <ski> np
14:23:45 <tony> Hello.
14:23:55 <ski> ello
14:25:07 <marioxcc> Hi.
14:25:32 <marioxcc> Is there a function in the standard library that builds an array for a list (Or a nested list for multidimensional arrays)?.
14:25:47 <marioxcc> Nevermind, I found it.
14:29:02 <tony> Just wanted to let you know that I've written some Sublime Text snippets for Hspec. Nothing fancy, but I think this might be of some use to someone.
14:29:14 <tony> Here they are: https://github.com/ayakovlenko/hspec-sublime-snippets
14:29:19 <ski> marioxcc : `array' or `listArray'
14:31:03 * hackagebot diagrams-svg 1.1.0.4 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.1.0.4 (bergey)
14:31:05 * hackagebot diagrams-cairo 1.2.0.6 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.2.0.6 (bergey)
14:31:06 <marioxcc> ski: Right, thanks.
14:32:25 <marioxcc> ski: What should I use to constructor the array bounds?
14:34:37 <marioxcc> ski: I see, a tuple works.
14:35:39 <Pamelloes> Is there an easy function that recursively applies a function to a value until a condition is met?
14:35:50 <benmachine> :t until
14:35:51 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
14:36:08 <Pamelloes> Awesome! Thanks :)
14:36:09 <benmachine> also consider: iterate
14:36:48 <benmachine> I guess until p f x = (head . dropWhile (not . p) . iterate f) x
14:36:51 <benmachine> or something like that
14:38:21 <ski> > let ix = (0,5) in array ix [(i,i * (i + 1) `div` 2) | i <- range ix]
14:38:23 <lambdabot>  array (0,5) [(0,0),(1,1),(2,3),(3,6),(4,10),(5,15)]
14:38:55 <ski> > let ix = ((2,2),(4,4)) in array ix [((i,j),i ^ j) | (i,j) <- range ix]
14:38:57 <lambdabot>  array ((2,2),(4,4)) [((2,2),4),((2,3),8),((2,4),16),((3,2),9),((3,3),27),((3...
14:39:15 <ski> > let ix = ((2,2),(4,4)) in listArray ix [i ^ j | (i,j) <- range ix]
14:39:17 <lambdabot>  array ((2,2),(4,4)) [((2,2),4),((2,3),8),((2,4),16),((3,2),9),((3,3),27),((3...
14:39:26 <ski> marioxcc ^
14:40:29 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = arrayList ix [f i | i <- range ix]
14:40:30 <lambdabot>  .L.hs:232:17: Not in scope: ‘arrayList’
14:40:39 <phaazon> @hoogle (MonadError e m) => Either e a -> m a
14:40:41 <lambdabot> Data.Either rights :: [Either a b] -> [b]
14:40:41 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
14:40:41 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
14:40:49 <phaazon> hm, such a function would be very great
14:40:57 <phaazon> sounds it doesn’t exist
14:40:58 <marioxcc> ski: Ok, thanks.
14:41:01 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = listArray ix [f i | i <- range ix]
14:41:03 <lambdabot>  Defined.
14:41:04 * hackagebot diagrams-postscript 1.1.0.4 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.1.0.4 (bergey)
14:41:05 <phaazon> a generalized hoist
14:41:06 * hackagebot diagrams-rasterific 0.1.0.6 - Rasterific backend for diagrams.  http://hackage.haskell.org/package/diagrams-rasterific-0.1.0.6 (bergey)
14:41:44 <ski> > tabilate ((2,2),(4,4)) $ \(i,j) -> i ^ j  -- marioxcc, i often find `tabulate' a nice way to construct arrays
14:41:45 <lambdabot>  Not in scope: ‘tabilate’
14:41:45 <lambdabot>  Perhaps you meant ‘tabulate’ (line 232)
14:41:50 <ski> > tabulate ((2,2),(4,4)) $ \(i,j) -> i ^ j
14:41:52 <lambdabot>  array ((2,2),(4,4)) [((2,2),4),((2,3),8),((2,4),16),((3,2),9),((3,3),27),((3...
14:42:36 <marioxcc> ski: I see, thanks.
14:42:41 <phaazon> @let eitherToError :: (MonadError e m) => Either e a -> m a; eitherToError = either throwError return
14:42:43 <lambdabot>  Defined.
14:46:04 * hackagebot diagrams-canvas 0.3.0.3 - HTML5 canvas backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-canvas-0.3.0.3 (bergey)
14:46:06 * hackagebot diagrams-builder 0.6.0.3 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.6.0.3 (bergey)
14:49:49 <danilo2> Hello! Does anybody knows if pipes-concurrent work simmilar performance to Control.Concurrent.Chan ? Do they have any pros/cons when compared to Chan for simple operations like jut simple producer consumer list?
14:51:04 * hackagebot diagrams-haddock 0.2.2.13 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.2.13 (bergey)
14:52:11 <mpickering> danilo2: Sounds like you need to do some profiling :P
14:52:39 <danilo2> mpickering: yeah - I was just wondering if somebody did it already :)
14:53:00 <mpickering> if you don't want to do the profiling then I suggest you ask on the pipes mailing list
14:53:36 <danilo2> mpickering: I will, but asking there is a good idea also, thanks :)
14:54:42 <tnks> I'm catching up with all the approaches out there.  If I have a large record in Haskell, what's the best way to avoid defects with respect to position-based desugaring?
14:54:43 <marioxcc> In a bidimensional array, what's the width and height (by convention)?
14:54:46 <tnks> lenses?
14:55:35 <glguy> tnks: You can just use records for that, you don't need lenses
14:56:08 <ski> marioxcc : if you think of the `Show' instance as enumerating row by row, then you have `(columnIndex,rowIndex)'
14:56:35 <phaazon> edwardk, I pushed a PR to your either package, on github
14:56:39 <ski> (i suppose that really is the `Ix' instance on pairs/tuples)
14:56:54 <phaazon> I’m very suprised such a function doesn’t exist yet
14:56:59 <ski> (and related to the `Ord' instance on them
14:57:01 <ski> )
14:57:02 <danilo2> mpickering: I think I found the answer. pipes-concurrent use stm under the hood, while Chan bases on simple Mvar list. So for very simple list handling, Mvars will be always a little bit faster
14:57:44 <EvanR> danilo2: Chan is beating something in speed?
14:59:03 <danilo2> EvanR: I don't know yet. I was just asking what to use - pipes-concurrent or chan when I want to implement a very simple queue and I've found out that Chan bases on MVars while pipes on STM. In so simple examples STM could be slower, right
14:59:06 <danilo2> ?
14:59:39 <EvanR> danilo2: this random PNG is suggestive https://hackage.haskell.org/package/unagi-chan
15:00:40 <tnks> glguy: is record wildcard + puns considered in poor taste for some reason?
15:00:56 <tnks> I'm remembering some arguments, but having a hard time finding them in retrospect.
15:01:34 <danilo2> EvanR: ugh. But why? Why Chan performs so bad if it is just an wrapper over MVar? whats happening here?
15:01:53 <glguy> tnks: It just depends who you ask. There isn't universal agreement about it.
15:02:05 <EvanR> danilo2: the bad is specifically for multiple writers
15:02:17 <EvanR> TQueue scales better
15:02:24 <tnks> glguy: I'm open to making up my own mind. . . but what arguments to opponents have?  As in, what breaks?
15:02:33 <tnks> (so I can make a decision more objecively)
15:03:23 <glguy> it shadows the record selectors, so you need to know all the names that the wildcard implicitly defines so you know which ones are shadowed
15:03:46 <glguy> and it requires you to memorize the record selectors for the records so that you'll know where names are defined when looking at a function that uses them
15:03:49 <EvanR> danilo2: i dont know whats going on here, but ive heard that MVars perform better with high contention where as STM performs better with low contention
15:04:02 <glguy> In my experience they make it faster to write code the first time and slower to read it the second
15:04:03 <EvanR> which is the opposite of that graphic
15:05:25 <danilo2> EvanR: hmm, thats very interesting. So is there anything better than these unagi-chan's to create quques ? I'm thinking aobut creating a logger queue - differnet threads can write to this queue. I know I can do this using simple mvars but I want to choose the most performant solution
15:05:46 <EvanR> use the simplest one then profile
15:09:01 <danilo2> EvanR: Ok, I will do this way :)
15:11:27 <tnks> glguy: interesting. . . the shadowing seems like an implementation artifact.
15:11:33 <tnks> was the shadowing necessary?
15:11:50 <nitrix> Hi, if I have a type Ledger that is an alias for [Resource], I'll be able to fmap over the elements, right? But then, if I have a newtype Ledger, I'd need to unwrap it before I can use the list inside. What if I want the type to remain abstract, would I need to implement a Functor Ledger instance?
15:11:58 <nitrix> Do I understand functors correctly?
15:12:19 <tnks> I understand if there's nothing I can do about it, because it's implemented how it is and I just have to deal wit hit.
15:12:35 <mpickering> sounds about right nitrix
15:12:47 <mpickering> you can derive the functor instance using the DeriveFunctor extension
15:13:14 <mpickering> tnks: How would you implement it differently?
15:13:38 <paf31> @pl \a b c d -> a (b c d)
15:13:38 <lambdabot> (.) . (.)
15:13:52 <mpickering> the only difference I see is that instead of writing "accessor object" you just write "accessor"
15:14:43 <paf31> @pl \a b c d e -> a (b c d e)
15:14:43 <lambdabot> (.) . (.) . (.)
15:15:51 <tnks> mpickering: am I understanding that the selectors captured by a record wildcard end up shadowing names in the expression?
15:16:13 <tnks> because all I'd wish is that they didn't, and only explicitly mentioned selectors are pulled into scope.
15:16:30 <tnks> or am I misunderstanding the complaint with record wildcards?
15:18:48 <phaazon> hey, is there something special to do to enable ghc to output warnings defined through pragmas?
15:18:55 <phaazon> like {-# WARNING #-}
15:19:24 <mpickering> I don't know the precise implementation of NamedFieldPuns but I imagine it only shadows specific accessors you mention?
15:19:28 <mpickering> You can try it out I guess
15:19:31 <quchen> phaazon: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html#warning-deprecated-pragma
15:20:03 <phaazon> ah
15:20:09 <phaazon> it’s because I use it in the defining module
15:20:16 <phaazon> that’s not really what I want
15:20:22 <mpickering> I think the complaint is that the shadowing changes the type so if you see "accessor" in two different places in your program, it could mean different things
15:20:29 <phaazon> I’d like to be able to generate a compiler warning or message each time
15:21:10 <quchen> phaazon: TH might be able to do something like this
15:21:18 <phaazon> ok, thank you
15:22:23 <phaazon> it should be a pragma! :)
15:22:50 <quchen> reportError looks promising, http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Syntax.html#v:reportError
15:23:20 <phaazon> hm
15:23:20 <phaazon> yeah
15:23:36 <phaazon> I guess I’ll go for TODO in comments in the first place, actually
15:34:16 <joneshf-laptop> can you forget a let binding in ghci without destroying other things?
15:34:43 <mpickering> you can just shadow it if you like
15:34:58 <joneshf-laptop> well, it already shadowed another thing
15:35:16 <joneshf-laptop> i want to unshadow the latest thing
15:35:41 <joneshf-laptop> it's fine if that'snot a thing
15:36:58 <hpc> unfortunately, not a thing
15:37:34 <hpc> i try and avoid doing complicated things in ghci
15:38:00 <hpc> (ie, much more than just running an action defined in a file)
15:39:26 <eyebloom> Is there a type level function that could take types (a,b) and (c,d) and make type (a,b,c,d)?
15:39:48 <hpc> don't think so
15:40:07 <hpc> unless you count ((a,b),(c,d)) :P
15:42:17 <eyebloom> Hmmm…
15:52:01 <kgadek> hi. could anybody recommend me a good random package? good quality of pseudorandom is a priority. It seems that System.Random is horribly slow, 2 orders of magnitude slower than eg. mwc-random.
15:52:45 <kgadek> as for the latter: I'm not lightly willing to use ST/IO in my code as having those in monad stack usually disables some optimizations…
15:53:13 <EvanR> high performance, high quality, and pure
15:53:28 <kgadek> no
15:53:32 <kgadek> or… well
15:53:38 <kgadek> not necessarily pure
15:53:44 <kgadek> in a sense that
15:53:59 <kgadek> if I could initialize that once
15:54:07 <kgadek> and pass the state in StateT
15:54:11 <kgadek> that would be nice
15:54:30 <kgadek> (that's what MonadRandom does for System.Random)
16:06:05 <ReinH> kgadek: perhaps http://hackage.haskell.org/package/cprng-aes
16:10:56 <gregnwosu> two questions , firstly can anyone interpret this as a Date? I got it in some response json, Date(1421199192412)
16:11:24 <Bynbo7> is it a unix epoch time?
16:11:27 <gregnwosu> secondly can anyone compare httpclients wreq with http conduit?
16:11:56 <gregnwosu> ah that would make sense
16:13:52 <Axman6> gregnwosu: hmm, that may be wrong: http://www.wolframalpha.com/input/?i=1421199192412+epoch+time+as+date
16:14:59 <Axman6> gregnwosu: http://www.wolframalpha.com/input/?i=1421199192412+nanoseconds+from+1%2F1%2F1970 perhaps
16:15:17 <kgadek> ReinH: thanks! I'm testing that right now
16:16:08 * hackagebot lifted-async 0.6.0.1 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.6.0.1 (MitsutoshiAoe)
16:19:07 <hrumph> i can't use haskell at work now
16:19:28 <hrumph> becaus its not officially supported or some such nonsense
16:19:38 <hrumph> i have to start using stuff like php and java
16:19:43 <hrumph> its a nightmare
16:19:50 <EvanR> :(
16:20:06 <hrumph> i was using haskell for months
16:20:17 <hrumph> i even made a website in the yesod framework
16:20:20 <Axman6> "PHP and Java are not officially supported by me"
16:20:43 * EvanR gives hrumph a haskell certification
16:20:55 <EvanR> its dangerous take this
16:21:01 <hrumph> i work at a uni and they only will allow certain code on their official servers
16:21:08 * hackagebot rss 3000.2.0.4 - A library for generating RSS 2.0 feeds.  http://hackage.haskell.org/package/rss-3000.2.0.4 (BasVanDijk)
16:22:05 <hrumph> its all about security or something but haskell is guaranteed 10x more secure from the outset
16:22:07 <kgadek> hrumph: wait until they'll need to convert markdown to html and install parsec… with GHC and all along
16:22:20 <kgadek> *pandoc
16:22:53 <hrumph> the only way haskell could have bad security bugs would be bugs hiddent somewhere deep in the compiler
16:22:56 <hrumph> its not a big worry
16:22:59 <geekosaur> it's a university, they'll set some undergrads loose to write it in php
16:23:01 <gregnwosu> well theres is a haskell like language that runs on the jvm
16:23:12 <gregnwosu> cant remember what its called
16:23:19 <Axman6> Frege
16:23:23 <gregnwosu> thanks
16:23:24 <Axman6> and possibly others
16:23:26 <gregnwosu> lol
16:23:27 <Axman6> also Scala
16:23:33 <hrumph> gregburd, i doubt i would be allowed to use it :(
16:23:35 <Axman6> sorry, "Scala :("
16:23:48 <EvanR> hrumph: well, i would be suspicious of somebody telling me to rewrite a bunch of stuff in haskell because it was secure by default
16:24:01 <gregnwosu> define secure
16:24:11 <hrumph> EvanR, well it *is* secure by default (sorta)
16:24:15 <EvanR> >_>
16:24:28 <Axman6> it should be secure by default*
16:24:33 <Axman6> but, mistakes happen
16:24:51 <gregnwosu> as in it cant be hacked? cracked? or its less likely to die at runtime?
16:24:53 <EvanR> theres probably a better way to characterise what you mean
16:25:26 <kadoban> Haskell sidesteps some of the security bugs common in C and C++, other than that I doubt you can really rely on Haskell to secure your code for you.
16:25:50 <kgadek> btw: was there any security issue in GHC in like… ever?
16:25:52 <hrumph> gregnwosu, there really no opportunity for bugger overuns for one thing. the strong typing also is another factor which would make things like sql injections much harder to pull off
16:25:53 <gregnwosu> it all depends on what he means by secure
16:26:04 <gregnwosu> bugger overuns lol
16:26:06 <kadoban> You still have to be aware of what you're doing, follow good practices, etc. It's probably easier to write secure code in Haskell than in some other languages, but beyond that...
16:26:08 <geekosaur> type safety can help a lot... if everything has appropriate newtypes etc. to protect you from mixing things that shouldn't be mixed.
16:26:10 <Iceland_jack> If you write incorrect code in Haskell it will become correct by virtue of non-strictness.
16:26:10 <hrumph> *buffer*
16:26:12 <EvanR> but at the same time your superiors saying "its not secure" is also a lame ass statement
16:26:22 <EvanR> computers arent secure, people arent secure
16:26:38 <beanmachine> kgadek: it depends what you mean -- for a while the unrestricted inclusion of RTS options in compiled programs was considered a potential security problem
16:26:45 <hrumph> EvanR, they didn't say its not secure....its just not something they will *declare* secure since its not on their list
16:26:59 <geekosaur> but php is *guffaw*
16:27:02 <EvanR> theyre probably idiots
16:27:03 <Axman6> @quote zip ap tail
16:27:03 <lambdabot> No quotes for this person. And you call yourself a Rocket Surgeon!
16:27:11 <Axman6> @quote ap tail
16:27:11 <lambdabot> No quotes for this person. Listen, broccoli brains, I don't have time to listen to this trash.
16:27:14 <beanmachine> kgadek: I'd hope that a compiler would be pretty limited in the amount of damage it could do even in the worst case :)
16:27:14 <Axman6> bleh
16:27:25 <geekosaur> @quote zip.*ap.*tail
16:27:25 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
16:27:39 <Axman6> thanks =)
16:28:08 <kgadek> beanmachine: hm yeah… however: if we assume a generated binary, suid on that and passing some RTS options
16:28:12 <Peaker> did --enable-{executable,library}-profiling become --enable-profiling?
16:28:21 <kgadek> one could do a kind of DoS on the system
16:28:23 <geekosaur> Peaker, yes
16:28:32 <pavonia> :t  zip`ap`tail
16:28:33 <lambdabot> [b] -> [(b, b)]
16:28:38 <beanmachine> kgadek: I think some RTS options would write to a specified file, I think that was the concern
16:28:41 <beanmachine> I forget exactly
16:28:57 <geekosaur> several profiling options can do that, certainly
16:29:07 <beanmachine> https://ghc.haskell.org/trac/ghc/ticket/3910
16:29:44 <danilo2> EvanR: I've made some tests (using Chan's vs pipes vs mvars vs Unagi-Chan's) and the resutls are suprising: http://stackoverflow.com/questions/27933941/haskell-fast-concurrent-queue
16:29:50 <gregnwosu> so people wreq or http.conduit, whats the verdict?
16:30:09 <gregnwosu> im looking for completely biased unfounded opinion
16:30:15 <johnw> wreq :)
16:30:18 <EvanR> danilo2: mvar based queue?
16:30:42 <gregnwosu> johnw:  any reason why?
16:30:51 <johnw> completely unfounded opinions
16:31:04 <gregnwosu> i knew you'd pick up on that , fair nugg
16:31:09 <EvanR> danilo2: is this a bounded queue of capacity 1?
16:31:09 <gregnwosu> *nuff
16:31:24 <Axman6> waddup nugga
16:31:26 <phaazon> is there any people that might accept my PR on the either package here?
16:31:32 <johnw> i've used http-conduit (and now http-client), and it was easy enough
16:31:38 <johnw> the ResumableSource stuff was weird, but that's gone now
16:31:41 <danilo2> EvanR: yep, so maybe the name "queue" is not appropriate here
16:31:45 <johnw> I haven't tried wreq yet, but it sounds very interesting
16:32:00 <EvanR> danilo2: well it also explains why its faster, especially for one reader/writer
16:32:09 <Axman6> anyone know if there's been any work ona HTTP/2.0 in haskell yet?
16:32:10 <gregnwosu> thanks, think ill go with wreq, then.....
16:32:27 <phaazon> for interested people: https://github.com/ekmett/either/pull/31
16:32:35 <phaazon> I hope edwardk will merge it
16:32:49 <phaazon> because I find it very useful, being someone using typeclasses constraint a lot
16:32:52 <Peaker> what's a nice way to get GHC to dump a stack trace?
16:32:56 <phaazon> :t generalizeEither
16:32:57 <lambdabot> MonadError e m => Either e a -> m a
16:32:57 <EvanR> danilo2: are you trying to out-do unagi chan before continuing with your project? ;)
16:33:21 <phaazon> (if you have better ideas for the name of the function, let me know! :) )
16:33:46 <phaazon> maybe genHoistEither
16:33:48 <phaazon> I don’t know
16:34:04 <alpounet> gregnwosu: i've been using wreq quite intensively, works like a charm
16:34:06 <danilo2> EvanR: but there are 20 producers and one consumer. Weve got the same behaviour with 100 producers. The pipes one takes about 60 seconds to complete, while rest performs in 1-4 seconds. What do you mean by "out-do" ?
16:34:13 <kgadek> beanmachine: nice to know, thanks for the link
16:34:50 <johnw> danilo2: Have you tested for the possibility of a latency problem in the pipes code?
16:35:15 <johnw>   For example, is there perhaps a buffer which is not being completely filled?
16:35:32 <gregnwosu> alpounet: lovely, always good to go with a recommendation the wreq tutorial that im looking at looks pretty nice too! :)
16:36:04 <danilo2> johnw: no, I just run the tests provided in the link. To be honest I do not know how to test it right now. I do not know about any buffer there
16:36:09 * hackagebot bus-pirate 0.6.2 - Haskell interface to the Bus Pirate binary interface  http://hackage.haskell.org/package/bus-pirate-0.6.2 (BenGamari)
16:36:44 <alpounet> gregnwosu: feel free to ask around if you have questions :) and to ping me specifically if it's during the day (central european time) -- although to be honest it's pretty damn easy to use
16:37:26 <johnw> danilo2: When a streaming solution is that much worse, sometimes it can be because the buffering is just not matching up with the quantity or frequency of the input -- that is, assuming that any kind of buffering is taking place at all.   I'm pretty sure that Gabriel would be quite interested in these results.
16:38:09 <alpounet> yep
16:38:16 <alpounet> i'll mention this SO thread to him on twitter
16:38:41 <danilo2> johnw, alpounet: thank you! I'll be thankfull for pinging him
16:38:45 <phaazon> hey alpounet, have you checked out my latest screenshot from my engine? :)
16:38:51 <phaazon> it’s almost usable for anyone
16:39:02 <phaazon> I’ll write a long entry blog about it :)
16:39:23 <alpounet> phaazon: yeah, saw it :) how's the shader dsl coming along?
16:39:36 <phaazon> put apart for the moment
16:39:39 <alpounet> danilo2: https://twitter.com/alpmestan/status/555161249445871618
16:39:40 <phaazon> ash, yeah
16:39:48 <phaazon> I’ll finish it later on
16:40:03 <phaazon> I’m too busy implementing PCSS, bokeh and lens flares :)
16:40:06 <alpounet> danilo2: you can expect an answer quite soon I suppose =)
16:40:48 <danilo2> alpounet: great! thank you very much! :)
16:41:09 * hackagebot hindent 4.1.1 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.1.1 (ChrisDone)
16:41:46 <alpounet> danilo2: yw :) i'm also using pipes-concurrency so that's relevant to me too, although i haven't noticed any such lag in my programs
16:42:11 <alpounet> phaazon: be sure to drop the link to your post on #haskell-game
16:42:11 <tempay> is there an equivalent of "comparing" for Eq?
16:42:21 <phaazon> sure alpounet
16:42:25 <geekosaur> :t on
16:42:26 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
16:42:28 <gregnwosu> thanks alpounet
16:42:31 <phaazon> I always notice reddit about my blog articles
16:42:35 <phaazon> there’s a few ones now
16:42:38 <Axman6> (==) `on` f
16:42:38 <geekosaur> (Data.Function)
16:42:39 <tempay> thanks geekosaur
16:42:43 <phaazon> I’ve been active on the blog around november :P
16:42:52 <geekosaur> comparing predated on by a few months
16:43:03 <Axman6> the 'equating' function has been discussed before, but I don't think anyone's actually proposed it
16:43:14 <danilo2> alpounet: I dint felt any lag also - you know, few seconds when passing 40k messages is not "felt" normal way. But when I'm designing the logging library I will release in a day or two on hackage, I want everything to work as good as possible
16:43:22 <phaazon> I might write a paper about my engine though, because it’s starting to become ultra haskellish, and I like that
16:43:22 <tempay> on is what i was thinking of, very useful
16:43:27 <tempay> just forgot the function
16:43:42 <geekosaur> my recollection is comparing was proposed and implemented, then someone realized that there was a general pattern there and proposed on
16:44:41 <alpounet> danilo2: yeah, the only annoying thing is the occasional "stuck waiting for an MVar" bug
16:44:45 <BMeph> alpounet: In the spirit of punning, they call that function, "equating". :)
16:45:15 <danilo2> alpounet: ouch, which bug?
16:45:38 <BMeph> Axman6: I thought it was in Data.Eq already - you mean it isn't?
16:45:53 <Axman6> I didn;t think it was, maybe it is?
16:45:56 <Axman6> @hoogle equating
16:45:57 <lambdabot> No results found
16:46:33 <alpounet> danilo2: i think it's that one: https://github.com/Gabriel439/Haskell-Pipes-Concurrency-Library/issues/27 haven't seen it happen in a while though, i probably unvoluntarily did something that works around the bug
16:46:53 <geekosaur> I see it in a couple of libraries and one new alternative prelude
16:46:55 <benmachine> BMeph: you have inspired me to realise that 'equating' makes no grammatical sense whatsoever, I still like it though
16:47:06 <geekosaur> Cabal library is the most notable since everyone has it...
16:47:14 <benmachine> it's actually almost exactly the wrong name
16:47:14 <alpounet> also, i've moved some of the "async message passing" to postgresql's listen/notify, since my data has to go in the db too before being picked up by worker threads anyway
16:47:16 <geekosaur> (Distribution.Simple.Utils)
16:47:46 <benmachine> 'equating fst' equates everything other than the fst :P
16:47:51 <hrumph> sorry had to go afk. i don't think they said that php was secure....its just they only review stuff for security written in some very standard langs (php and java and almost nothing else)
16:48:04 <danilo2> alpounet: oh interesting, I didnt noticed it before, thanks for pointing this out!
17:07:24 <Lokathor> so, in non-haskell languages there's often something like a "with" construct, or a "try-finally" construct, where you declare a resource you'll have to close later, run code, and then the system ensures that you close the resource as you exit the block even if there's an error. Does haskell have something like that? Or does the high composability of haskell make that sort of thing less necesary and you roll your own?
17:07:48 <geekosaur> :t bracket
17:07:49 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
17:08:05 <Axman6> see also Control.Exception
17:08:06 <benzrf> @src bracket
17:08:07 <lambdabot> bracket before after thing = block $ do
17:08:07 <lambdabot>     a <- before
17:08:07 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
17:08:07 <lambdabot>     after a
17:08:07 <lambdabot>     return r
17:08:15 <benzrf> o.O
17:08:20 <benzrf> :t block
17:08:21 <lambdabot> Not in scope: ‘block’
17:08:25 <benzrf> what is block?
17:08:32 <Lokathor> and what's unblock
17:08:36 <benzrf> that
17:08:40 <EvanR> those are for async exceptions
17:08:45 <Lokathor> oh
17:08:49 <Axman6> any not particularly easy to grok
17:08:58 <geekosaur> block and unblock async exceptions so they don't "leak"
17:09:06 <geekosaur> or prevent proper cleanup
17:09:08 <hpc> Lokathor: uncoincidentally, bracket is used in the definitions of many standard with-functions
17:09:11 <hpc> :t withFile
17:09:12 <lambdabot>     Not in scope: ‘withFile’
17:09:12 <lambdabot>     Perhaps you meant one of these:
17:09:12 <lambdabot>       ‘writeFile’ (imported from Prelude),
17:09:16 <hpc> @hoogle withFile
17:09:17 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
17:09:17 <lambdabot> System.Posix.ByteString.FilePath withFilePath :: RawFilePath -> (CString -> IO a) -> IO a
17:09:29 <hpc> there's one for virtually everything
17:09:46 <Lokathor> i thought i'd heard about that sort of thing, but wasn't sure
17:10:17 <dgomez> Would it be possible to implement :t bracket type in mine. I'm still trying to make this work: Scope need to be heavily improved and (==) operator is just helping to find other errors.
17:11:10 * hackagebot language-openscad 0.1.6 - A simple parser for OpenSCAD  http://hackage.haskell.org/package/language-openscad-0.1.6 (BenGamari)
17:11:25 <lpaste> dgomez revised “Diagram review ”: “Diagram 5” at http://lpaste.net/5601304663052779520
17:12:09 <Lokathor> is the :t functonality easily available outside of ghci? like could you have a program that reads a file and shows a list of functions inside and prints the type of each one?
17:12:35 <geekosaur> not sure about "easily". all of it is available via the ghc-api
17:12:43 <geekosaur> might want to look at ghc-mod though
17:13:05 <Lokathor> ah, well now that i think about it if the lambdabot can do it, clearly it's possible
17:16:03 <dgomez> any advice for why the (#) won't compile? Error is  Not in scope: type constructor or class `#'
17:16:11 * hackagebot linux-evdev 0.3.1 - Bindings to Linux evdev input device interface.  http://hackage.haskell.org/package/linux-evdev-0.3.1 (BenGamari)
17:16:13 * hackagebot linear-opengl 0.2.0.5 - Isomorphisms between linear and OpenGL types  http://hackage.haskell.org/package/linear-opengl-0.2.0.5 (BenGamari)
17:17:42 <dgomez> Are hackagebots messages directed at my question?
17:17:51 <Iceland_jack> No
17:17:52 <geekosaur> no
17:18:03 <dgomez> ok
17:20:54 <dgomez> Did I not ask an appropriatete or thoughtful question?
17:21:11 * hackagebot optimization 0.1.6 - Numerical optimization  http://hackage.haskell.org/package/optimization-0.1.6 (BenGamari)
17:21:13 * hackagebot pandoc-lens 0.3.1 - Lenses for Pandoc documents  http://hackage.haskell.org/package/pandoc-lens-0.3.1 (BenGamari)
17:21:53 <bitemyapp> dgomez: maybe
17:22:49 <shachaf> dgomez: You should be patient and also accept that people might not answer your question.
17:22:54 * geekosaur simply has no idea
17:23:03 <shachaf> Another thing you should do is include your full code and full error message.
17:23:19 <shachaf> I've never used diagrams, but it looks like (#) is exported from Diagrams.Util.
17:23:31 <geekosaur> I assume it's intended from what hayoo tells me is the one in Diagrams.Util from diagrams-lib, assuming this relates to your earlier paste
17:23:34 <dgomez> shachaf: I'm not demanding anyone answer, I just want to make sure I learn how to voice my uncertainties correctly
17:23:42 <shachaf> So if I was guessing, I'd guess that you're not telling us everything.
17:23:47 <Profpatsch> I’m trying to create a generator for quickcheck with a bit of Text.
17:23:49 <Profpatsch> instance Arbitrary T.Text where
17:23:51 <Profpatsch>   arbitrary = growingElements $ oneof [Char, elements (openingParens ++ closingParens)]
17:23:53 <shachaf> For instance, maybe you're running the commented-out code in ghci without importing everything.
17:23:55 <geekosaur> but I am not familiar with, so
17:24:07 <Profpatsch> It can’t access the Char constructor.
17:24:10 <shachaf> Or who knows what else. Full code (as you're running it) and full error message are required.
17:24:16 <Profpatsch> Any other way to get a Char generater?
17:24:59 <geekosaur> arbitrary :: Char ?
17:25:20 <Profpatsch> lel.
17:25:24 <Profpatsch> Thet’s so obvious.
17:25:28 <Profpatsch> *That
17:25:46 <Iceland_jack> Profpatsch: You can use something like 'choose'
17:25:47 <dgomez> shachaf: I understand the problem you're saying. I am providing the full code exactly as I am running it on lpaste. the only error I received during that run was the one I printed out. But I know there are others definitely.
17:25:54 <lpaste> thetallguy pasted “Can gname be made to type check?” at http://lpaste.net/118398
17:26:08 <Iceland_jack> @ty choose ('a', 'z') -- Generator for characters a-z.
17:26:09 <lambdabot> Gen Char
17:26:11 * hackagebot stemmer 0.5.1 - Haskell bindings to the Snowball stemming library.  http://hackage.haskell.org/package/stemmer-0.5.1 (BenGamari)
17:26:13 * hackagebot svm-light-utils 0.1.1 - Parsers and formatters for the SVMlight input file format  http://hackage.haskell.org/package/svm-light-utils-0.1.1 (BenGamari)
17:26:15 <dgomez> also I ran it with the -fglasgow-ext flag and received something completely different
17:26:46 <dgomez> ghc -v -o -fglasgow-exts test Diagrams.hs
17:26:49 <shachaf> dgomez: A GHC error message has a line number and yours down't.
17:27:17 <shachaf> And you're not providing the full code. Who knows what you're doing with that commented-out code?
17:28:11 <dgomez> shachaf: i am. that code is just that -- commented out. it is never run. I'll delete it next time.
17:28:12 <thetallguy> Anyone care to try their hand at http://lpaste.net/118398 ?
17:28:17 <dgomez> DiagramsTutorial.hs:40:33:
17:28:18 <dgomez>     Not in scope: type constructor or class `#'
17:28:40 <shachaf> Line 40 is "mock :: Diagram B R2". It doesn't have 33 columns.
17:29:09 <shachaf> dgomez: Oh, well, you can't just have Haskell code in the middle of a file like that.
17:30:00 <geekosaur> type constructor???
17:30:47 <lpaste> dgomez revised “Diagram review ”: “6” at http://lpaste.net/5601304663052779520
17:30:59 <dgomez> an exact replica of what I am running
17:31:10 <dgomez> geekosaur: that was my confusion.
17:31:11 * hackagebot wkt 0.2.4 - Parsec parsers and types for geographic data in well-known text (WKT) format.  http://hackage.haskell.org/package/wkt-0.2.4 (BenGamari)
17:31:19 <geekosaur> indentation is all over the place, I am not surprised it's misparsing. also you have some == where you seem to intend =
17:32:08 <dgomez> geekosaur: I have found that using == it parses through and provides additional errors than just getting stuck and returning one Error in `=
17:32:16 <geekosaur> lines 31-38 are nonsensical as is. may be badly misindented + change == on 31, 33, 36 to =
17:32:29 <geekosaur> dgomez, you also confused the heck out of ghc
17:32:30 <dgomez> geekosaur: my scope is also bad yes. its been the slow accumulation of my scope errors
17:32:46 <geekosaur> it's no wonder it thinks you are working in types instead of values
17:33:39 <geekosaur> you got perhaps longer error messages. but they're not the real errors, they are things you managed to confuse ghc into thinking are something else
17:34:50 <dgomez> geekosaur: understood. I'll realign my code; and change the == to =. I''l try to figure out what happens after.
17:50:03 <osa1> which languages were in use in 1960s?
17:50:36 <lpaste> dgomez revised “Diagram review ”: “7” at http://lpaste.net/5601304663052779520
17:51:00 <dgomez> I've added the only error received thus far at the bottom.  I hope this help clarify?
17:51:30 <dmj`> osa1: lisp 1.5
17:51:49 <osa1> dmj`: other than lisp?
17:52:19 <pavonia> dgomez: "combine == ..." is an expression, but only declarations are allowed at top-level
17:52:55 <kadoban> osa1: Fortran, Algol, Lisp, probably others. I have no idea the relative popularity at that time.
17:53:41 <kadoban> COBOL is that old I guess
17:54:21 <osa1> so I was just reading "Recursive Functions of Symbolic Expressions and Their Computations by Machine" by McCarthy and I'm amazed by the fact that it described function call stacks without actually using those words. I was wondering if this paper also introduced call stacks.
17:54:31 <lpaste> dgomez revised “Diagram review ”: “7” at http://lpaste.net/5601304663052779520
17:54:40 <dmj`> osa1: algol
17:55:01 <osa1> dmj`: algol had call stacks?
17:55:03 <dgomez> pavonia: I'm sorry I think I understand the distinction. However, I've changed it.
17:55:59 <dmj`> osa1: it was used in the 60s, unsure about call stacks
17:57:55 <pavonia> dgomez: Btw, it's recommended to not use tabs in Haskell code as the tab width in GHC may differ from the one in your editor which may cause problems in more complex layouts
17:58:09 <Profpatsch> Can someone help me with this Arbitrary declaration?
17:58:11 <Profpatsch> https://bigmac.caelum.uberspace.de/paste/qc_text.hs.html
17:58:32 <Profpatsch> (the parens are Overloaded as Text instead of String)
17:59:13 <kadoban> Good gahd that's a lot of parens.
17:59:14 <Profpatsch> My problem is that somehow the encoding goes wrong:
17:59:17 <Profpatsch> > generate (arbitrary :: Gen T.Text)
17:59:19 <lambdabot>  Not in scope: type constructor or class ‘T.Text’
17:59:20 <Profpatsch> "m\12296ju{\12299hh{'\10217\12305o\10100gz\10092h\10627"
17:59:54 <Profpatsch> Something is being escaped somewhere.
18:00:02 <Profpatsch> kadoban: True. :)
18:00:37 <geekosaur> Profpatsch, are you sure you aren't just seeing the Show instance applied to the result?
18:00:44 <shachaf> Profpatsch: What's wrong?
18:00:54 <shachaf> \12296 is 〈
18:01:00 <geekosaur> if this is in ghci, try using putStrLn directly instead of relying on the default Show indstance
18:01:31 <Profpatsch> You mean ghci disregards the OverloadedStrings defined in the file?
18:01:41 <geekosaur> what?
18:02:08 <geekosaur> no. ghci uses the Show instance to display values. the Show instance for Text, like the Show instance for String, escapes characters
18:02:19 <Profpatsch> I see.
18:02:38 <geekosaur> if you want to see the actual value then putStrLn it instead of relying on the Show instance
18:03:27 <Profpatsch> verboseCheck does Show, too.
18:04:27 <Profpatsch> Can I tell it to use putStrLn somehow?
18:05:19 <Iceland_jack> Profpatsch: Write your own Show instance
18:05:33 <Iceland_jack> a bespoke one that outputs the value directly
18:06:33 <Profpatsch> Iceland_jack: I just tried that and get a Duplicate Instance Declarations error.
18:06:47 <Iceland_jack> Are you doing "deriving (..., Show, ...)"?
18:07:10 <Profpatsch> I tried instance Show T.Text where
18:07:12 <Profpatsch>   show = putStrLn
18:07:17 <Profpatsch> Something like that.
18:07:33 <Iceland_jack> From Data.Text.IO?
18:07:50 <Iceland_jack> (no wait... never mind that)
18:08:59 <Iceland_jack> Profpatsch: This is how you'd do that for Strings:
18:08:59 <Iceland_jack>     newtype Str = MkStr String
18:08:59 <Iceland_jack>     instance Show Str where
18:09:02 <Iceland_jack>       show (MkStr str) =  str
18:09:08 <Iceland_jack> ghci> MkStr "hello"
18:09:08 <Iceland_jack> hello
18:09:11 <Iceland_jack> ghci> "hello"
18:09:14 <Iceland_jack> "hello"
18:09:15 <Iceland_jack> Now you just need to do the same for Text :)
18:09:21 <ski> Profpatsch : "Can I tell it to use putStrLn somehow?" tried using `putStrLn' ?
18:09:44 <Iceland_jack> ski: As I understand Profpatsch wants VerboseCheck to print it in a particular way
18:09:57 <ski> `VerboseCheck' ?
18:10:08 <Profpatsch> Yeah, I want UTF-8 to be readable, not escaped.
18:10:12 <Profpatsch> ski: QuickCheck
18:10:15 <geekosaur> QuickCheck verbose output
18:10:18 <Iceland_jack> *verboseCheck function from QuickCheck
18:10:19 <ski> ok
18:10:34 <geekosaur> which as far as I can tell is always going to use a Show instance
18:10:39 <Iceland_jack> Yes
18:10:52 <geekosaur> (and must since it is building a string from parts)
18:11:04 <ski> well, i'd make an alternative instance which still escaped control characters, and surrounded with double quotes, but which didn't escape the unicode
18:11:08 <Iceland_jack> Although I seem to recall you being able to supply your own either printing function or show function
18:11:26 <Iceland_jack> but maybe that was just an unofficial addition, I can't remember
18:11:59 <ski> (and i'd make it an instance of `IsString', to justify this heterodox `Show' instance (since you're not outputting `MkStr', are you ?))
18:12:36 <Iceland_jack> If that is a concern
18:13:11 <Profpatsch> ski: How would I do that?
18:14:20 <ski> Profpatsch : output a starting double quote, walk though the list of chars, escaping those that need to be escaped ?
18:14:28 <ski> there's some subtle points
18:14:39 <ski> > ['\SO','H']
18:14:40 <lambdabot>  "\SO\&H"
18:14:54 <ski> > length "\SO\&H"
18:14:56 <lambdabot>  2
18:14:57 <ski> > length "\SOH"
18:14:58 <lambdabot>  1
18:15:09 <Profpatsch> There’s Blind: http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/Test-QuickCheck.html#t:Blind
18:15:25 <ski> `\&' here is used to end the previous escape sequence
18:16:11 <dgomez> pavonia: thank you for that reminder, I had completely forgotten about indentation differences. I've changed it. It's made a huge difference. I know have multiple errors regarding the matching of types I used which I think will give me better direction
18:16:29 <ski> > "\10000"
18:16:31 <dgomez> pavonia: I hope to get to it after my commute home.
18:16:31 <lambdabot>  "\10000"
18:16:34 <ski> > "\1000\&0"
18:16:36 <lambdabot>  "\1000\&0"
18:17:12 <ski> (there's ppossibly some unprintable unicode which you still need to escape `)
18:17:21 <ski> (s/`/?/)
18:18:26 <Profpatsch> ski: Well, that’s quite some work.
18:20:50 <ski> Profpatsch : see `showLitChar' and `showLitString' at <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.7.0.2/src/GHC-Show.html#showLitChar>
18:24:41 <ski> so it's the first case in `showLitChar' that needs to be modified/expanded
18:29:28 <ski> > filter (not . isPrint) ['\256' ..]
18:29:30 <lambdabot>  "\888\889\895\896\897\898\899\907\909\930\1320\1321\1322\1323\1324\1325\1326...
18:39:37 <EvanR> > text $ filter isPrint ['\256' ..]
18:39:38 <lambdabot>  ĀāĂăĄąĆćĈĉĊċČčĎďĐđĒēĔĕĖėĘęĚěĜĝĞğĠġĢģĤĥĦħĨĩĪīĬĭĮįİıĲĳĴĵĶķĸĹĺĻļĽľĿŀŁłŃńŅņŇňŉŊŋ...
18:42:42 <Hijiri> > text $ filter isPrint ['\x1f00'..]
18:42:43 <lambdabot>  ἀἁἂἃἄἅἆἇἈἉἊἋἌἍἎἏἐἑἒἓἔἕἘἙἚἛἜἝἠἡἢἣἤἥἦἧἨἩἪἫἬἭἮἯἰἱἲἳἴἵἶἷἸἹἺἻἼἽἾἿὀὁὂὃὄὅὈὉὊὋὌὍὐὑὒὓ...
18:42:51 <Hijiri> wait, that's not what I wanted
18:42:58 <Hijiri> oh, I think I forgot a 0 somewhere
18:43:57 <EvanR> > text $ filter isPrint ['\x10000' ..]
18:43:58 <lambdabot>  𐀀𐀁𐀂𐀃𐀄𐀅𐀆𐀇𐀈𐀉𐀊𐀋𐀍𐀎𐀏𐀐𐀑𐀒𐀓𐀔𐀕𐀖𐀗𐀘𐀙𐀚𐀛𐀜𐀝𐀞𐀟𐀠𐀡𐀢𐀣𐀤𐀥𐀦𐀨𐀩𐀪𐀫𐀬𐀭𐀮𐀯𐀰𐀱𐀲𐀳𐀴𐀵𐀶𐀷𐀸𐀹𐀺𐀼𐀽𐀿𐁀𐁁𐁂𐁃𐁄𐁅𐁆𐁇𐁈𐁉𐁊𐁋𐁌𐁍𐁐𐁑...
18:44:18 <EvanR> > text $ filter isPrint ['\x10fff0' ..]
18:44:19 <lambdabot>  Terminated
18:45:19 <Hijiri> those print as boxes for me
18:45:22 <Hijiri> I was looking for
18:45:26 <ski> @let import GHC.Show
18:45:27 <lambdabot>  Defined.
18:45:42 <Hijiri> > text $ filter isPrint ['\x1f000']
18:45:43 <lambdabot>  🀀
18:45:48 <Hijiri> and after that, I think
18:45:55 <Hijiri> but they don't print properly in my terminal
18:46:11 <EvanR> > isPrint '\x10fff0'
18:46:12 <lambdabot>  False
18:46:15 * hackagebot postgresql-typed 0.3.1 - A PostgreSQL access library with compile-time SQL type inference  http://hackage.haskell.org/package/postgresql-typed-0.3.1 (DylanSimon)
18:46:26 <EvanR> > ['\x10fff0' ..]
18:46:27 <lambdabot>  "\1114096\1114097\1114098\1114099\1114100\1114101\1114102\1114103\1114104\11...
18:47:04 <EvanR> > text $ filter isPrint ['\x10fff0' ..]
18:47:05 <lambdabot>  Terminated
18:47:51 <EvanR> > text ""
18:47:52 <lambdabot>  Terminated
18:48:31 <EvanR> that would be embarrassing to appear in an email ;)
18:50:46 <ski> oh
18:52:25 <marchelzo_> Does anyone know if there are SDL2_ttf bindings to go along with the sdl2 package?
18:52:39 <EvanR> someone is working on that
18:53:01 <benzrf> > [0..] >>= flip replicateM ['a'..'z']
18:53:02 <lambdabot>  can't find file: L.hs
18:53:04 <benzrf> > [0..] >>= flip replicateM ['a'..'z']
18:53:05 <lambdabot>  ["","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r",...
18:53:09 <benzrf> > [3..] >>= flip replicateM ['a'..'z']
18:53:10 <lambdabot>  ["aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj","aak","aal","aa...
18:53:12 <benzrf> cool
18:53:28 <ski> @let import GHC.Show
18:53:30 <lambdabot>  Defined.
18:53:36 <ski> @let myShowLitChar :: Char -> ShowS; myShowLitChar c s | c > '\DEL' && isPrint c = showChar c s | otherwise = showLitChar c s
18:53:37 <lambdabot>  Defined.
18:53:41 <ski> @let myShowLitString :: String -> ShowS; myShowLitString [] s = s; myShowLitString ('"' : cs) s = showString "\\\"" (myShowLitString cs s); myShowLitString (c : cs) s = myShowLitChar c (myShowLitString cs s)
18:53:42 <lambdabot>  Defined.
18:53:44 <EvanR> benzrf: doing the same thing repeatedly expecting different results indicates insanity!
18:53:53 <benzrf> pfft
18:53:55 <ski> @let newtype UnicodishString = MkUS {unUS :: String} deriving (Eq,Ord)
18:53:56 <lambdabot>  Defined.
18:54:03 <ski> @let import Data.String
18:54:04 <lambdabot>  Defined.
18:54:11 <ski> @let instance IsString UnicodishString where fromString = MkUS
18:54:12 <lambdabot>  Defined.
18:54:13 <jle`> can you really just @let import
18:54:22 <ski> @let instance Show UnicodishString where showsPrec _ (MkUS s) = showChar '"' . myShowLitString s . showChar '"'
18:54:23 <lambdabot>  Defined.
18:54:41 <jle`> @import System.IO.Unsafe
18:54:41 <lambdabot> Unknown command, try @list
18:54:46 <jle`> @let import System.IO.Unsafe
18:54:46 <lambdabot>  .L.hs:125:1:
18:54:46 <lambdabot>      System.IO.Unsafe: Can't be safely imported!
18:54:46 <lambdabot>      The module itself isn't safe.
18:54:52 <jle`> i see
18:55:08 <EvanR> obv
18:55:15 <jle`> are you suuure it's not safe?
18:55:16 <ski> for completeness, one should also define `Read'
18:55:22 <ski> > MkUS "\256\257\12296\127\128\140\888"
18:55:23 <lambdabot>  "Āā〈\DEL\128\140\888"
18:55:29 <ski> Profpatsch ^
18:56:02 <EvanR> > '\256'
18:56:03 <lambdabot>  '\256'
18:56:12 <ski> > MkUS "m\12296ju{\12299hh{'\10217\12305o\10100gz\10092h\10627"
18:56:13 <lambdabot>  "m〈ju{》hh{'⟩】o❴gz❬h⦃"
18:56:19 <EvanR> > ['\256']
18:56:20 <lambdabot>  "\256"
18:56:31 <ski> Profpatsch : more readable ^ ?
19:02:33 <ski> > (reads :: ReadS String) "\"Āā〈\""
19:02:34 <lambdabot>  [("\256\257\12296","")]
19:02:53 <ski> hmm .. perhaps nothing need to be done in the `Read' case
19:03:06 <ski> @let instance Read UnicodeString where readsPrec _ s0 = [(MkUS s,s1) | (s,s1) <- reads s0]
19:03:06 <lambdabot>  .L.hs:169:15:
19:03:06 <lambdabot>      Not in scope: type constructor or class ‘UnicodeString’
19:03:06 <lambdabot>      Perhaps you meant ‘UnicodishString’ (line 159)
19:03:32 <ski> @let instance Read UnicodishString where readsPrec _ s0 = [(MkUS s,s1) | (s,s1) <- reads s0]
19:03:34 <lambdabot>  Defined.
19:03:54 <ski> > (reads :: ReadS UnicodishString) "\"Āā〈\""
19:03:56 <lambdabot>  [("Āā〈","")]
19:04:24 <ski> > case (reads :: ReadS UnicodishString) "\"Āā〈\"" of [(MkUS s,"")] -> s
19:04:26 <lambdabot>  "\256\257\12296"
19:04:54 <ski> > "Āā〈" :: UnicodishString  -- no `OverloadedStrings' enabled in lambdabot
19:04:55 <lambdabot>  Couldn't match expected type ‘L.UnicodishString’
19:04:55 <lambdabot>              with actual type ‘[GHC.Types.Char]’
19:05:55 <ski> Profpatsch : ^ seemed not to be that much work ..
19:17:51 <_um> Hi, #haskell.
19:18:08 <_um> I'm wrestling in a cabal sandbox.
19:18:44 <_um> I installed a package, it reported itself being installed, I can see where it's installed, but I can't seem to import it...
19:19:14 <_um> I imagine there is some good documentation on how to do this correctly, but I don't find the most obvious cabal sanbox docs to be any help so far...
19:19:20 <_um> Any tips?
19:19:49 <lucs> _um: What kind of error are you getting?
19:20:02 <wolf_mozart> so R is for statistical programming, matlab is for mathematical simulation, C++ is for application development, Java is for cross platform application development, what is Haskell for?
19:20:04 <_um> Just "Could not find module ‘Web.Twitter.Conduit’"
19:20:53 <lucs> _um: expressing it as a (accidental) Maybe is cure ;)
19:21:08 <lucs> *cute
19:21:59 <_um> lucs: When I was trying to run in ghci via Emacs' shell I also got "It is not a module in the current program, or in any known package."
19:22:13 <_um> lucs: sorry, I don't follow. ..
19:22:18 <_um> Oh, I get it.
19:22:20 <kadoban> wolf_mozart: It's a general purpose programming language. It's not really for any specific domain.
19:22:27 <lucs> _um: Yeah, sorry :)
19:22:52 <_um> lucs: I wish I'd kept my mouth shut to claim the undeserved clever ;)
19:23:10 <wolf_mozart> ok
19:23:35 <lucs> _um: Actually, I'm pretty much a beginner, so I don't really know why you're having that problem, but hopefully someone here will have an idea.
19:24:14 <_um> wolf_mozart: I find haskell is very good for making me think long and deep about my programs, motivating me to learn some maths and logic, and good for writing clean, declarative code.
19:24:55 <_um> lucs: Hopefully! Thanks :) I'm loving working with Haskell, but I do seem to end up running my against an eco-system-related wall every couple days...
19:25:18 <_um> Maybe I should just try installing the package outside of the sandbox...
19:25:36 <wolf_mozart> so it's a language that aims at readebility?
19:25:41 <lucs> _um: How are you invoking the program?
19:26:30 <_um> lucs: I've trie runhaskell, loading in ghci, loading in cabal repl, and running it through Emacs' haskell-mode interactive-haskell
19:26:35 <_um> *tried.
19:26:44 <EvanR> wolf_mozart: it should be obvious there are no bugs, rather than no obvious bugs ;)
19:26:45 <wolf_mozart> or, does the program work more effeciently, faster, takes less memory etc? it's geared towards performance?
19:27:05 <wolf_mozart> i see
19:27:12 <wolf_mozart> not a bad  goal
19:27:16 <_um> wolf_mozart: I'm not sure "readable" is the right word, because people often expect "readable" to be immediately clear without any study or much background knowledge.
19:27:28 <kadoban> wolf_mozart: It's a high level programming language. It's a purely functional language with non-strict semantics. It's pretty different than most languages you're likely to know. It has very useful and powerful abstractions that will expand your mind as a programmer and allow you to express yourself nicely.
19:27:29 <lucs> _um: Something like this worked for me:
19:27:36 <lucs> runghc -package-db=.../.cabal-sandbox/i386-linux-ghc-7.8.3-packages.conf.d myprog.hs
19:27:48 <EvanR> _um: taking up less space definitely helps readability
19:28:06 <ansible> its a language that's designed to catch a lot of errors at compile time, thanks to type checking.
19:28:21 <adu> ASTs are so complicated
19:28:35 <adu> language-c makes it look so easy
19:28:36 <_um> EvanR: True, but if you aren't already familiar with folds, flips, composition, functors, the bevy of operators then all that brevity is just cryptic.
19:29:14 <_um> lucs: I'll give that a shot.
19:29:27 <EvanR> _um: yeah, but if you are unfamiliar with C constructs, having it be 5 screens worth of code doesnt help you ;)
19:29:27 <ski> _um : "in Haskell, the type system has the expressive power of sentential logic, but dependent languages have a type system that approaches (or is equal to) the expressiveness of predicate calculus" -- more or less, yes
19:30:14 <adu> EvanR: are you talking to me?
19:30:24 <EvanR> no
19:30:33 <ski> _um : in popular extensions, Haskell has propositional (and propositional combinator) quantifications, which is more than usual sentential logic (but doesn't about to the usual predicate logic)
19:31:11 <ski> (s/about/amount/)
19:31:30 <_um> ski: Wah! Thanks for digging that unanswered question up! That was from several days back. Much appreciated.
19:32:01 <_um> ski: Ah yes! I'm really looking forward to exploring those extensions. I can't remember which to look for.
19:33:02 <_um> lucs: that works! thanks. But does that mean I just cant use a repl so long as I'm using the sandbox?
19:33:09 <_um> lucs: or how does that work out?
19:33:31 <barrucadu> _um: You can use `cabal repl` in a sandbox to get a ghci with the right package directory
19:34:04 <_um> barrucadu: I'm getting the same error in cabal repl.
19:34:29 <_um> Maybe I need to do something after installing the package while in the sandbox to get it included?
19:35:36 <barrucadu> Are you building a project with cabal? ie, you have a foo.cabal file?
19:35:44 <_um> barrucadu: yep.
19:35:47 <lucs> _um: Glad it worked, but the details as to why kind of escape me, so I'm listening to the others as well! :)
19:35:49 <barrucadu> If so, you can only import modules (both in the repl and your code) which are in the build-depends
19:36:02 <barrucadu> Sorry, whose providing packges are in the build-depends
19:36:39 <_um> okay! That's good to know! I don't know why I missed that in the various documentation and tutorials I was looking through.
19:37:32 <_um> So each time I add a new package to my project I need to add it to the list following "build-depends:" in the project.cabal file?
19:38:45 <barrucadu> Yes. You can also add upper and lower bounds on the version of the package, Cabal then uses that to install a set of dependencies where everything has consistent versions
19:38:55 <dfeuer> Is there a way to add a Test-Suite section for cabal without breaking compatibility with pre-1.9.2 cabal?
19:39:50 <_um> barrucadu: thanks! Hopefully that will sort me out.
19:41:33 <_um> barrucadu: Do you happen to know where the documentation on that process is? I'm looking through the Cabal User's Guide and I can't see where it speicifeis.
19:46:09 <EvanR> ski: sentential logic and propositional logic refer to the same thing?
19:47:12 <_um> EvanR: I understand them to do so.
19:47:31 <barrucadu> _um: I'm not sure, although the error message complains about you trying to import something not specified in the build-depends.
19:48:01 <barrucadu> "Could not find module ... It is a member of the hidden package ... Perhaps you need to add ... to the build-depends in your .cabal file."
19:48:31 <barrucadu> I msotly learned how .cabal files worked by having `cabal init` include the optional documentation for each field
19:48:56 <dfeuer> Oh wait ... cabal 1.10 came out in 2010. I don't really want to think about trying to support anything earlier than that.
19:49:33 <ski> EvanR : i think they usually do
19:50:06 <ski> _um : yw
19:50:15 <_um> barrucadu: I'm not getting the same message. But that is helpful information. -- Ach. I haven't even found any documentation on adding dependencies to the .cabal file...
19:50:22 <lucs> "yw"?
19:51:09 <_um> ski: Could you remind me of the name of the extension to the type system you were talking about?
19:53:23 <ski> _um : i think some languages (DML ? maybe also ATS ?) that are sometimes classified as dependent, or at least approaching it, are sometimes not considered (full) dependent languages
19:53:24 <_um> How am i supposed to figure out what name I'm supposed to use for the package listed in the "Build-Depends:" field?
19:54:12 <kadoban> _um: They're the package names off hackage, aren't they?
19:55:20 <EvanR> ski: what are the criteria for being dependent?
19:56:04 <ski> _um : `ExplicitForAll',`PolyMorphicComponents',`Rank2Types',`RankNTypes',`ImpredicativeTypes',`ExistentialQuantification',`LiberalTypeSynonyms' are all relevant
19:56:56 <_um> kadoban: so would that be "Web.Twitter.Conduit" or "twitter-conduit"?
19:57:22 <kadoban> _um: The second I believe
19:57:27 <ski> EvanR : one weak attempt could be to say that there should be some kind of "indices" that can be parameters of type functions, and that can to some extent be computed with
19:57:56 <_um> okay, thanks kadoban. I feel pretty dense about this. Not sure why I'm stumbling over every step. The help is much appreciated.
19:58:22 <_um> ski: Thanks! Those are going straight into my "to investigate" file.
19:58:27 <kadoban> _um: You're certainly welcome for any help I can provide.
19:59:50 <dfeuer> ski, ExplicitForAll is something I don't see the use for. Use ScopedTypeVariables.
20:00:00 <ski> EvanR : like GADTs, or stuff like `Foo :: Bool -> *' .. but preferably one should be able to do some more nontrivial computation in these indices (like e.g. addition and multiplication of naturals on the type level -- though type familys can probably do it) -- iiuc, DML only has natural number indices, and a primitive implementation of a few arithmetic ops on them. i think it uses them to keep track of array length and such
20:00:34 <ski> dfeuer : well .. i'd prefer to use the old `PatternSignatures' :)
20:01:09 <dfeuer> ski, why? You don't think ScopedTypeVariables is pretty sweet?
20:03:24 <ski> dfeuer : i have two complaints. (a) it's backwards. saying `foo :: forall a. ..a..' suggests that `a' is *bound* at that point, and this one would not expect it to also be in scope in a defining equation then. it would be better if (with the extension enabled) it was brought into scope in the defining equations when one do *not* use a toplevel `forall'
20:04:35 <ski> dfeuer : (b) a type signature doesn't have to be placed adjacent to the defining equations. it can even be shared across several identifiers. this can perhaps make it less obvious in some cases that there's a type variable in scope, and where it comes from
20:04:46 <ski> (a) is a stronger complaint than (b)
20:04:47 <dfeuer> ski, I don't see how (a) makes sense.
20:05:19 <dfeuer> (b) seems a reasonable complaint, but I would argue that such code is badly organized.
20:05:26 <ski> if i write `(forall a. a -> a) -> Maybe a', then the last `a' can't be the same as the ones in the former part, since those are bound by `forall a.' in that local scope
20:05:29 <ski> similarly, if i write
20:05:35 <ski>   foo :: forall a. ..a..
20:05:56 <ski> then i'd expect this `a' to *only* be in scope in `..a..' -- not anywhere else
20:06:00 <ski> however, if i wrote
20:06:03 <ski>   foo :: ..a..
20:06:35 <dfeuer> ski, I suspect the real problem is not the direction of the forallism, but rather the fact that the word forall is used for it at all.
20:06:36 <ski> then i could imagine `a' being implicitly quantified around *both* the type signature and the defining equations, and so i could understand if it was in scope in the latter as well
20:06:57 <ski> no, `forall' is the right word
20:07:06 <ski> if we could write
20:07:08 <ski>   forall a.
20:07:13 <ski>     foo :: ..a..
20:07:17 <dfeuer> No, forall is the right word to express a certain concept that is in fact going on here,
20:07:18 <ski>     foo = ..a..
20:07:23 <ski> then that would be fine
20:07:23 <dfeuer> but that already goes on implicitly.
20:07:45 <dfeuer> The real concept is somewhat let-like.
20:08:09 <dfeuer> But it is what it is and it seems sufficiently intuitive to me personally.....
20:08:27 <ski> anyway, you got more or less the same functionality that `ScopedTypeVariables' give you, by `PatternSignatures'
20:08:38 <ski> you could write e.g.
20:08:48 <ski>   foo xs :: [a] = ...
20:08:50 <ski>     where
20:08:54 <ski>     bar :: ..a..
20:08:59 <ski>     bar = ..xs..
20:09:21 <ski> where `bar' can't be polymorphic in `a', since it references the nonlocal `xs' of some type involving `a'
20:09:57 <ski> (or `foo (xs :: [(Int,a)]) = ...', if you prefer, that would also work)
20:10:07 <dfeuer> I don't know enough about the theory to be able to debate on that level, but it seems pleasant from a user perspective.
20:12:32 <ski> EvanR : however, in the strong sense, i think one must be able to express not only stuff like `reverseVector :: Vec a n -> Vec a n' and `appendVector :: Vec a m -> Vec a n -> Vec a (m + n)', but also, crucially, stuff like `repeatVector :: (n ::) Nat -> a -> Vec a n', where a value *crosses* the border from the "run-time value" world to the "compile-time type" world
20:12:36 <dfeuer> Does Haskell 98 allow hiding of non-existent identifiers in imports?
20:12:57 <dfeuer> Is   import Prelude hiding (fakefunction)    valid Haskell 98?
20:14:01 <ski> EvanR : where this signature for `repeatVector' here means that it takes a `Nat' and an `a' (for any type `a'). and if we call the run-time input `Nat' `n', then the compile-time output has type `Vec a n'
20:14:13 <ski> EvanR : here `Vec :: * -> Nat -> *', in case you wonder
20:14:42 <ski> dfeuer : dunno, but i would suppose not
20:15:18 <dfeuer> ski, yeah, you're right.
20:15:31 <dfeuer> " It is an error to hide an entity that is not, in fact, exported by the imported module."
20:15:50 <EvanR> ski: repeatVector makes sense, but im trying to imagine what the weaker version would be. im not familiar with haskell type level stuff
20:16:14 <EvanR> if its not compile-time then what good is it
20:16:33 <dfeuer> That seems a mistake, but that's how it is. A mistake repeated in Haskell 2010.
20:17:56 <dfeuer> The only effect of that decision is a bad one: CPP (a non-standard feature) ends up being needed just to hide imports when something gets added in another module.
20:17:58 <EvanR> ski: oh, in appendVector the nats involved are compile-time *only*, and not provided at runtime from any computation
20:19:30 <ski> EvanR : `repeatVector' enables the type of a value in a running program to depend on run-time input. how long the vector is might be determined only when the program is running
20:20:32 <ski> EvanR : with just stuff like `reverseVector',`repeatVector', the only source where the numbers `m',`n' can eventually come from are literals in the source (either explicit, or inferred by type inference)
20:21:38 <EvanR> ski: so they are just like typical polymorphic types
20:21:49 <EvanR> with fancy constructor +
20:22:14 <ski> dfeuer : how would you know to hide it prematurely, if it hasn't been added yet ?
20:22:53 <ski> EvanR : yes, though `+' here wouldn't be a constructor
20:23:10 <ski> EvanR : we want `(1 + 1) + 1' to unify with `1 + (1 + 1)'
20:23:23 <dfeuer> ski, you wouldn't. But sometimes you're updating a package that has to be able to work with both new and old dependencies.
20:23:35 <EvanR> how would appendVector work in haskell
20:23:45 <ski> and we want at least one of `0 + n', and `n + 0' (for a locally unknown `n') to unify with `n'
20:23:55 <ski> dfeuer : ok
20:24:03 <kadoban> dfeuer: That does seem like a mistake. Should be a warning (since it's probably a typo), but not an error.
20:24:11 <ski> EvanR : type families
20:24:50 <dfeuer> kadoban, no, it shouldn't be a warning either, because if it's a typo you'll just get a name clash somewhere else and fix it.
20:25:01 <ski> EvanR : one could also express addition by type classes (iow predicates), but that's indirect, you need a constraint added to the signature, so it's no longer quite the same (but still interesting)
20:26:06 <dfeuer> kadoban, actually there's one situation where a typo there could cause a problem, but it's a weird corner case.
20:26:33 <dfeuer> Specifically, if the module imports something, defines something else with the same name, doesn't use the thing it defines, and doesn't have an explicit export listt.
20:26:56 <dfeuer> But if you don't have an explicit export list, you probably deserve to have problems :-P
20:27:30 <kadoban> Yeah, I was trying to find some way not having an explicit export list would make sense and cause a problem, but...yeah probably not.
20:27:41 <ski> kadoban : i think an implementation shouldn't try to be "helpful" by fixing typos and such, removing errors. it could be useful to have such speculation in case of parse error e.g., to attempt to be able to go on analyzing the rest of the source, but i think the implementation should normally refuse to compile it anyway
20:28:13 <EvanR> type family a :+: b
20:28:15 <ski> kadoban : there could be an option to allow it to compile, but then it must be a warning (possibly also the compiled program should emit the warning)
20:29:13 <kadoban> ski: Well, I had my mind changed about it being a warning, but now I think it should just work...heh.
20:29:31 <ski> kadoban : also see "Deferring type errors to runtime" <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/defer-type-errors.html>
20:30:12 <Hijiri> Is there an "insert unsafeCoerce everywhere that is badly-typed" directive?
20:30:14 <ski> kadoban : anyway, i think it's a real mistake to let the programmer think that they don't need to fix the problem, since the compiler was able (this time !) to guess what they meant
20:30:44 <EvanR> ski: so is it possible to use the fact that n :+: 0 if the type instance says 0 :+: n
20:30:47 <kadoban> ski: Huh, that's pretty bizarre. I've always used blah = undefined for that problem the link seems to address.
20:30:49 <ski> (that will only encourage the accumulation of such cruft)
20:31:18 <ski> EvanR : the fact that .. what ?
20:31:55 <EvanR> you said "one of"
20:32:22 <ski> kadoban : for the specific case that dfeuer is talking about, possibly there's a convincing argument for doing it the other way. i was talking about in general
20:32:57 <ski> EvanR : you seemed to be missing a verb in the sentence in question. i didn't understand it
20:33:11 <amar_> can somebody explain difference between mapM and traverse on Data.Travesable. apart form one is on Applicative and other is on Monad
20:33:20 <EvanR> if i write a n + 0 type, but then the "client code" has a thing of type 0 + n ...
20:33:20 <ski> @type mapM
20:33:21 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
20:33:26 <ski> @type T.traverse
20:33:28 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
20:33:30 <EvanR> "we want them to unify"
20:33:40 <kadoban> ski: Yeah, I get you.
20:34:12 <EvanR> but i dont see how it could
20:34:16 <ski> amar_ : the latter is more general (doesn't work only on lists). also see
20:34:23 <ski> @type T.mapM
20:34:24 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
20:35:02 <ski> EvanR : "we want them to unify" -- perhaps .. in many common cases it's enough if we can get one of them to unify with `n'
20:36:11 <glguy> Evanr: they'll never unify, you now have to prove that they are equal
20:36:22 <EvanR> thats what i mean
20:36:29 <EvanR> ive had it, downloading coq
20:36:33 <ski> EvanR : e.g. `type instance Zero :+: n = n; type instance Succ m :+: n = Succ (m :+: n)' is the obvious structurally recursive definition of addition, and here we only get on one side (the other would have to be proved)
20:36:45 <ski> EvanR : Agda is also nice :)
20:36:57 <EvanR> im scared of unicode
20:37:01 <ski> glguy : maybe they unify in DML, i'm not sure
20:37:13 <ski> (with special-cased unification for type-level naturals)
20:37:33 <ski> Epigram ? make Idris ?
20:37:38 <ski> s/make/maybe/
20:37:43 <EvanR> how would you prove them equal in haskell
20:37:48 <EvanR> what would a proof mean
20:38:15 <dfeuer> ski, I just don't think hiding something nonexistent should be considered a mistake at all.
20:38:33 <ski>   data (:=:) :: a -> a -> *
20:38:35 <ski>     where
20:38:41 <EvanR> oh geez ocaml compiler..
20:38:42 <ski>     Refl :: x :=: x
20:39:34 <ski>   plusZero :: IsNat n -> n :=: (n :+: Zero)
20:39:44 <Iceland_`> Well almost
20:39:50 <ski>   plusZero  IsZero    = Refl
20:39:58 <Iceland_`> wrong window
20:40:25 <EvanR> whats that, a GADT
20:40:27 <ski>   plusZero (IsSucc n) = case plusZero n of Refl -> Refl
20:40:39 <ski>   data Nat = Zero | Succ Nat
20:40:48 <ski>   data IsNat :: Nat -> *
20:40:49 <ski>     where
20:40:56 <dfeuer> ski, kadoban, also, GHC ignores that line in the standard, and doesn't complain about hiding nonexistent things.
20:41:07 <ski>     IsZero ::            IsZero  Zero
20:41:26 <ski>   IsSucc :: IsNat n -> IsNat (Succ n)
20:41:39 <ski> (should say `IsNat' in the type sig. for `IsZero')
20:42:52 <ski> EvanR : there. this is GADT syntax, yes. but also using `KindSignatures', `DataKinds', and perhaps also `PolyKinds' (i don't recall)
20:43:37 <Hijiri> is this an example of a singleton?
20:44:26 <ski> EvanR : `IsNat' is one way to "reflect" back the `n' in the type into something concrete we can pattern-match on -- you may say `plusZero :: IsNat n -> ..n..' is a way to *simulate* (at least to some extent) `plusZero :: (n ::) -> ..n..' in Haskell
20:44:33 <RustyShackleford> Am I correct that you use "data" to define a new type, and "type" to create a synonym?
20:44:42 <RustyShackleford> or are there other uses for these keywords?
20:44:49 <ski> Hijiri : for each `n', `IsZero n' is a singleton type, yes, has a single (total) value
20:44:56 <ski> er, `IsNat n'
20:45:09 <Hijiri> RustyShackleford: type can make synonyms for other things too, like constraints, with the right extensions enabled
20:45:14 <ski> dfeuer : ok, interesting
20:45:23 <Hijiri> but I think that is overall correct
20:45:47 <ski> dfeuer : .. i wonder how much would change here if we had module signatures (like in the MLs .. and i suppose also Scheme48)
20:45:49 <Hijiri> you can also use newtype to make a wrapper type
20:46:16 <ski> RustyShackleford : yes
20:46:37 <ski> RustyShackleford : the other way to make a new type is `newtype'. both it and `data' create new (named) types
20:46:40 <dfeuer> ski, all Haskell would change. Some people tried to hack together Haskell + ML modules - type classes. I don't think they got anything anyone will ever actually want to program in, though.
20:46:58 <ski> RustyShackleford : they are the only way to introduce recursion (cyclicity) in types
20:47:19 <ski> RustyShackleford : you can't have a recursive/cyclic `type' synonym
20:47:45 <ski> dfeuer : too bad :/
20:48:17 <ski> (though we'd naturally want to be able to combine them with type classes .. possibly either that is the problem .. or inertia)
20:50:50 <dfeuer> I'm not sure, ski. That paper was really about addressing the problem of not being able to have module-local class instances.
20:51:18 <int21h> This is homework assignment question: given a few helper functions to parse string into tokens, how do I start process of parsing the string? Function signature is tokenize :: String -> [Token]
20:51:20 <dfeuer> They basically said "well, if you use ML-style functors instead of classes, you get more local stuff"
20:51:37 <dfeuer> But they also had to give up the power of MPTC and pretend that that didn't matter.
20:51:39 <ski> i wonder how they did this in Mercury
20:52:01 <ski> istr they can hide instances in a module
20:52:17 <ski> dfeuer :/
20:52:30 <dfeuer> int21h, uhhhhhh..... yeah, that's not much to go on. Would need to see both the details of the helper functions and what you've tried so far and exactly where you're getting stuck.
20:53:10 <dfeuer> ski, hiding instances in Haskell as things are now is a total no-go, because incoherent instances are just evil.
20:53:20 <ski> yes
20:53:20 <dfeuer> (and they would be happening)
20:53:26 <ski> yes
20:54:05 <ski> a type is meant to uniquelt determine at most one instance
20:54:45 <ski> (this also has strange consequences for type equality, which i'm not sure if i like .. perhaps one could clean this up somehow by e.g. bringing categories into it ?)
20:55:51 <int21h> @dfeuer I am very new to Haskell, so I am stuck before I wrote a single line of code
20:55:51 <lambdabot> Unknown command, try @list
20:56:04 <int21h> I can paste code into pastebin...
20:56:31 <int21h> Or into http://lpaste.net/new/haskell
20:56:48 <int21h> dfeuer I am very new to Haskell, so I am stuck before I wrote a single line of code
20:56:54 <RustyShackleford> ski: sorry I was afk, but thanks for the answer
20:57:38 <lpaste> int21h pasted “homework” at http://lpaste.net/8303680923006664704
20:57:59 <ski> RustyShackleford : no worry
20:58:04 <lpaste> int21h revised “homework”: “No title” at http://lpaste.net/8303680923006664704
20:58:04 <Zemyla> :t undefined :: (((Ord a) => Set a -> b) -> ([a] -> b) -> f a -> b)
20:58:05 <lambdabot>     Not in scope: type constructor or class ‘Set’
20:58:05 <lambdabot>     Perhaps you meant one of these:
20:58:05 <lambdabot>       ‘S.Set’ (imported from Data.Set),
20:58:14 <Zemyla> :t undefined :: (((Ord a) => S.Set a -> b) -> ([a] -> b) -> f a -> b)
20:58:15 <lambdabot> (Ord a => S.Set a -> b) -> ([a] -> b) -> f a -> b
20:59:05 <lpaste> int21h revised “homework”: “No title” at http://lpaste.net/8303680923006664704
21:00:43 <Guest14716> @ski yeah I was comparing T.mapM and traverse
21:00:44 <lambdabot> Maybe you meant: wiki src ask
21:04:02 <ski> int21h : just call `parseToken' repeatedly, until no more `
21:04:03 <ski> ?
21:04:37 <dfeuer> ski, can you explain, in layman's terms, what the consequences are for type equality?
21:06:06 <ski> dfeuer : well, if we have `newtype Abstract = Hide Representation', then we can in some sense think of `Abstract' and `Representation' as being the same type
21:06:37 <int21h> ski - can you elaborate, if you don't mind?
21:06:57 <dfeuer> ski, yes, they're Coercible.
21:07:17 <ski> dfeuer : now, calling `Hide', and using pattern-matching to remove it is `O(0)'
21:07:34 <ski> dfeuer : however, e.g. `map Hide' is still not `O(0)'
21:07:39 <dfeuer> True.
21:07:58 <ski> dfeuer : or e.g. if we have `Map (String,Tree Abstract)', but want to treat it as `Map (String,Tree Representation)', it would be nice if we could do that, without taking the trouble and time to traverse this structure to all occurances
21:08:31 <dfeuer> Ah, so the problem, perhaps, is that the system allows types to be "very isomorphic" without being equal.
21:08:42 <dfeuer> And there's a workaround with Coercible, but it's not ideal.
21:08:56 <dfeuer> If you solve that problem, well, I'll buy you a beer :-)
21:09:01 <ski> or, in some cases the type might be abstract, and we don't know whether it's a covariant or contravariant (or neither or both) functor in the interesting position
21:09:43 <ski> dfeuer : in generall, we'd like `contextHide :: ..Representation.. -> ..Abstract..', and vice versa
21:10:04 <ski> dfeuer : more concretely, we'd like `contextHide :: k Representation -> k Abstract', for all `k'
21:10:30 <dfeuer> ski, you just went over my head.
21:11:09 <ski> (this is called "leibniz equality". two things are equal if and only if for every predicate (here `k'), it because the same for them. iow if there is no predicate which can distinguish them, then they are effectively equal)
21:11:50 <dfeuer> But the trouble (as I recall) is, roughly speaking, that one or both of them may be free in k.
21:11:54 <ski> if we want `[Representation] -> [Abstract]', then this is sugar for `[] Representation -> [] Abstract', so we can just let `k' be `[]', and we could convert
21:12:11 <ski> or, in the `Map (String,Tree Abstract)', we can define
21:12:35 <ski>   newtype TemporaryType a = MkTemp {unTemp :: Map (String,Tree a)}
21:13:20 <ski> then, we can by setting `k' to `TemporaryType' get `contextHide :: TemporaryType Representation -> TemporaryType Abstract'
21:13:47 <ski> and then by using the constructor and destructor in composition (wrapping and unwrapping at the ends), we get
21:14:15 <ski>   unTemp . contextHide . MkTemp :: Map (String,Tree Representation) -> Map (String,Tree Abstract)
21:14:25 <ski> dfeuer : makes sense ?
21:14:57 <ski> dfeuer : in the above case, none are free in `k', since `contextHide :: k Representation -> k Abstract' is short for `contextHide :: forall k. k Representation -> k Abstract'
21:15:06 <dfeuer> Er .... not exactly, as yet.
21:16:02 <ski> ignoring where `k' is in scope in definitions, it's basically the same (assuming this signature isn't inside some other declaration where `k' is already in scope, such as a type class, or inside a `let' or `where')
21:16:21 * hackagebot monoid-subclasses 0.4.0.2 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.4.0.2 (MarioBlazevic)
21:16:58 <ski> anyway, `contextHide :: ..Representation.. -> ..Abstract..' was meant to suggest that we can replace `Representation' by `Abstract' inside any (perhaps complicated) type expression
21:17:15 <dfeuer> ski, but when your Map newtype is on the keys, suddenly you have problems.
21:17:31 <ski> in actuality, what we could do is ``contextHide :: k Representation -> k Abstract', and then we have to (sometimes) define such temporary types as `TemporaryType' above, but then it works out
21:17:48 <ski> dfeuer : yes :)
21:18:48 <ski> so, because we treat `Abstract' as a *new* type, distinct from `Representation', we were able to add distinct instances for the same class to it
21:19:10 <dfeuer> I still don't understand what that temporary type is about.
21:19:14 <ski> but now, with this, this barrier to realizing the types are equal is broken, and so confusion ensues
21:19:26 <ski> so, these two features are incompatible
21:19:47 <dfeuer> But the problem is that newtypes are (almost) useless if they can't have their own class instances.
21:19:57 <dfeuer> They remain good for abstraction, but nothing else.
21:20:05 <dfeuer> I guess that's not really useless.
21:20:50 <ski> so .. what i was wondering was : could it be possible to have a somewhat different design, that didn't rely on `newtype's being treated as distinct types, but where you could still (a) be able to attach different instances to basically the same underlying representation, when that's what you want; but still also (b) retain that each type should have at most one instance ?
21:21:12 <dfeuer> Hmmmm?
21:21:33 <dfeuer> That sounds like you want to have your fish and eat it too.
21:21:56 <ski> from what i'm thinking, maybe the problem is that we're treating `Sum Integer' and `Product Integer' as *merely* types (say objects in the category `Set', or if you want to call it `Hask')
21:22:18 <ski> (in Haskell written as `Sum Integer,Product Integer :: *')
21:23:03 <dfeuer> What do you want to treat them as? And is there any chance I'd be able to understand it?
21:23:17 <ski> perhaps we should have new *kinds* for these, to say that these aren't just concrete types (types of kind `*'), they are concrete types with, say, a monoid instance ?
21:23:58 <dfeuer> Uhhhhh.... what?
21:24:03 <ski> so that, if we say just `Integer', we mean the concrete type (of kind `*')
21:24:30 <ski> but where `Sum Integer' and `Product Integer' could have kind `Mon', or something like that
21:24:51 <ski> .. these are all just vague ideas in my head, so far. i don't know if it will work out at all
21:25:25 <barrucadu> So, sort of lifting class membership tot he kind level?
21:25:29 <barrucadu> *to the
21:25:39 <ski> but in math, sometimes when we say ⌜ℤ⌝, we mean just the type of integers
21:25:44 <dfeuer> I don't either. They sound to me like maybe they could go somewhere, but probably not in Haskell.
21:25:50 <dfeuer> In math, we are VERY sloppy.
21:26:15 <ski> and sometimes we mean the integers equipped with the usual additive monoid (or even group) structure : `0',`+' (and `negate')
21:26:25 <HeladoDeBrownie> i think it'd be nice to have first-class instances (instances are just values of some specific type), while still allowing the implicitness. i'm led to believe agda has something like this, where we can tell the language we want an arbitrary value to be supplied if possible.
21:26:37 <dfeuer> And sometimes we mean the Integers equipped with the multiplicative monoid structure.
21:26:42 <ski> yes. i'm pondering if there's a nice way here to make more precise what goes on in math
21:26:52 <ski> yes
21:26:55 <dfeuer> No, because mathematicians are slobs :-P
21:27:11 <ski> no, i don't necessarily mean for the mathematicians to use :)
21:27:23 <EvanR> i like the idea of using newtype wrappers to configure what you mean when just a type is not enough
21:27:23 <ski> i meant for use to steal (the idea) and refine it and use
21:27:31 <EvanR> or when its ambiguous
21:27:46 <ski> so, if we used different symbols for these two monoid or group structures on ⌜ℤ⌝, we'd be fine
21:27:52 <EvanR> and being a new type seems like thats just what that is?
21:27:56 <dfeuer> Newtypes for this math stuff is *painful*
21:28:18 <dfeuer> So if ski finds a better way, we will all buy hir a beer.
21:28:25 <fread2282> ski: why not just do what agda does (but w/ uniqueness check if you want)
21:28:42 <ski> EvanR : .. perhaps it shouldn't be making a new (mundane) concrete type, though
21:28:48 * ski doesn't drink beer :)
21:29:06 <EvanR> ski: whats the difference
21:29:11 <dfeuer> Other options include cider, hot chocolate, and smoked salmon.
21:29:25 <ski> fread2282 : i don't know too well what you're referring to .. but i'm pretty sure it doesn't do what i'd like to do, if it was possible
21:30:34 <ski> EvanR : even though the *concrete types* (of kind `*'/`Hask'/`Set') used to represent the carrier of the additive and the multiplicative structure on ⌜ℤ⌝ is the same
21:31:11 <ski> (or would be, if `newtype' "from `*' to `*'" yields equal types)
21:31:25 <EvanR> ski: whats a type... an abstract domain and some arrows that map to and from it, perhaps both
21:31:52 <EvanR> Product Integer has a forgetful functor back to Integer
21:31:53 <ski> EvanR : that doesn't mean two corresponding "refinements" of it in another category would need to be equal .. we need to factor in / take care of the extra structure in the type in some way, imo
21:32:09 <ski> EvanR : yes
21:32:09 <fread2282> ski: agda has instances as normal records (but sugar should be equivalent if you want) and instances are just values, you pass then explicitly with {{the_instance}}, e.g. show {{my_pprinter}} a, but you can also register them with `instance` on a top-level definition and when a function takes an instance and you don't specify one it will do search/resolution
21:32:51 <EvanR> ski: extra structure?
21:33:19 <ski> fread2282 : one thing which i pondered a little, and which i think would be nice is if implicit arguments in Agda were necessarily unique (at least in each use of an operation accepting such)
21:34:48 <ski> EvanR : a monoid is a triple of a carrier type/set, and two operations involving it (and satisfying some laws, you could see these as extra parts of the structure tuple) -- those operations (and laws) are the extra structure
21:34:53 <ski> EvanR : so, we could say
21:36:21 <HeladoDeBrownie> ski, did you mean monad? afaik the usual (set-theoretic) definition of monoid involves a set, an operation, and a distinguished element, not two operations. what is the other formulation, if you did mean monoid?
21:36:26 <fread2282> ski: but then don't we need newtypes or such?
21:36:27 <ski>   f : ⟨ℤ,0,+,negate⟩ → ⟨ℤ,0,+,negate⟩
21:36:30 <EvanR> (Set seems like a weird category to compare with haskell types ... newtype U = U ((U -> Bool) -> Bool)
21:36:59 <ski> to say that ⌜f⌝ is a map not between types, but between groups
21:37:22 <dfeuer> HeladoDeBrownie, no, ski meant monoid.
21:37:30 <HeladoDeBrownie> hmm, although that'd be wrong of monad, never mind.
21:37:36 <srhb> What's the two operations then?
21:37:58 <ski> (iow, the element-mapping part of ⌜f⌝ "respects" the group operations. the extra parts of ⌜f⌝, apart from the element-mapping, would be proofs that it respects that stufF)
21:37:59 * srhb also remembers it as just one binary operation
21:38:15 <dfeuer> Well, that was sort of a mistake.
21:38:22 <dfeuer> There's only one element.
21:38:23 <ski> HeladoDeBrownie : i was talking a little bit both about monoids, and groups
21:38:25 <dfeuer> one operation
21:38:29 <HeladoDeBrownie> ah
21:38:37 <dfeuer> Well, groups be weird too.
21:38:44 <dfeuer> That's the thing about the math people being sloppy.
21:39:07 <dfeuer> Because the math people can just say that there exists an inverse, and then prove it's unique,
21:39:11 <ski> fread2282 : i see as the "proper" use of `newtype' to enable recursive types, with an explicit mediating wrapping/unwrapping isomorphism
21:39:26 <dfeuer> but we need to actually have a negation operation to match the laws.
21:39:51 <EvanR> for monoid, you can think of the two operations as unit and append, like in F-algebras
21:39:54 <lpaste> int21h revised “homework”: “No title” at http://lpaste.net/8303680923006664704
21:39:55 <dfeuer> Mathematically, the set, the sole operation, and the laws determine the group, but in Haskell we can't do that.
21:40:14 <EvanR> group would have three
21:40:19 <dfeuer> And also for monoids. In math, the set and the operation determine the monoid, and the distinguished element falls out of them.
21:40:20 <EvanR> and then theres laws
21:40:48 <ski> fread2282 : in something like HoTT, one should be able to prove that both sides (abstract, and representation) are in fact *equal* (interchangable) -- this requires keeping track of "paths" (conversions, for types) and how to "distribute there" correctly, when doing such "equals for equals substitution" -- also remembering that something can be equal to itself in more than one way :)
21:41:34 <ski> srhb : there are different formulations. here the two operations for monoid was the binary operation, and the nullary one. for groups, also the unary inversion one
21:41:47 <srhb> ski: I see.
21:42:00 <EvanR> a nullary operation is basically a constant
21:42:21 <srhb> I've never seen that formulation. Funny.
21:42:26 <ski> srhb : in one common formulation, one would put the nullary one in a law, existentially quantifying it. but seen type theoretically, it's basically the same thing anyway
21:42:36 <srhb> Okay.
21:42:52 <ski> it's more or less the difference between
21:42:58 <ski>   aAndB :: (A,B)
21:42:59 <ski> and
21:43:01 <ski>   a :: A
21:43:03 <fread2282> ski: do you create and apply functors from Hask to Mon automatically (do normal haskell functions work on Product Int)?
21:43:03 <ski>   b :: B
21:43:38 <fread2282> but Monoid behaves different (then the normal instance)?
21:44:42 <ski> dfeuer : "but in Haskell we can't do that" -- yes, and that's in some sense the root of the problem
21:45:08 <ski> (if you consider it a problem. you could also say "don't do that then" to allowing conversion between `Abstract' and `Representation' in any context)
21:45:29 <dfeuer> Well, but we have practical reasons to *want* to do that :)
21:45:44 <fread2282> s/functors/the functor/
21:45:48 <EvanR> being able to determine that types are really super equal would be good for optimizations, i guess?
21:46:07 <ski> srhb : this formulation fits the framework of "universal algebra" much better (and one can see `F'-algebras in category theory as a generalization of the idea of universal algebra)
21:46:58 <ski> in universal algebra, one specifies an algebra signature by a bunch of giving "carrier" names, that will later be interpreted as types/sets
21:47:06 <shachaf> ski: An F-algebra gives you the operations, but not the laws, does it?
21:47:31 <EvanR> the laws can be formulated as diagrams
21:48:09 <ski> and by giving a bunch of operations, which all "return" into one or another carrier (or given "constant" set), and which takes some finite number of arguments, among the carriers (and given constant sets)
21:48:52 <ski> and finally, we have equational laws (no quantifiers, no logical connectives) that express a bunch of relationships between potential implementations of the operations
21:49:00 <ski> shachaf : yes, that's a good point
21:49:08 <ski> `F'-algebras are anarchic
21:49:40 <ski> fread2282 : "do you create and apply functors from Hask to Mon automatically (do normal haskell functions work on Product Int)?" -- good question. i don't know
21:50:30 <ski> dfeuer : yea .. the `O(0)' thing, at least. perhaps others as well
21:51:25 <fread2282> ski: I think that would indeed be a cool way to work with typeclasses, but do functions on Int work on Product Int? I think if so we would need more quantifiers
21:51:26 <EvanR> the universal algebra and F-algebra stuff i see always refers to the equational laws
21:51:56 <ski> i've had this idea about being able to contextually allow one type (or kind) to be treated as a subtype (or subkind) of another. but i don't know if it can work out
21:52:06 <fread2282> and if not, that would be ar annoying as newtypes IMO
21:52:14 <fread2282> s/ar/as/
21:52:46 <ski> fread2282 : we would need some way of "transporting" stuff across the levels, and to combine different of them together, and so on. how much of this can be implicit in syntax, i'm not sure
21:53:26 <EvanR> generalized newtype deriving?
21:53:40 <ski> EvanR : universal algebra has laws. i don't know whether anyone ever extended `F'-algebras to cover laws
21:54:21 <ski> EvanR : well, i meant either for bringing a function on `Integer' to the level of `Product Integer' .. or the other way around
21:54:59 <EvanR> ski: for a given universal algebra with equaltional laws, you just have the corresponding F-algebra "that satisfies some axioms" which, being equational, are just some extra commutative diagrams, it seems like?
21:56:16 <EvanR> the "signature"
21:56:19 <ski> i'd like to see it
21:57:06 <ski> as it is, with anarchic `F'-algebras, you express all of the signature of the operations by using `+' and `*' in the definition of `F'
21:57:20 <EvanR> http://en.wikipedia.org/wiki/F-algebra this page shows the corresponding F-algebra for groups
21:57:32 <EvanR> by removing quantifiers
21:58:47 <EvanR> F(G) = 1 + G + G x G
21:59:35 <ski> that only expresses the signatures of the ops, though
21:59:57 <ski> (also, i'm not sure how to handle multiple carriers here)
22:01:05 <EvanR> ok it just expresses the laws for the sake of it
22:01:43 <ski> it says "an F-algebra is an object A of C together with a C-morphism F(A) → A" in the definition .. i don't see how the laws enter in there
22:02:41 <EvanR> youre right the text is confusing
22:03:33 <_um> Thanks all. Good night.
22:03:37 <ski> either there is some way to make them also part of the functor `F'
22:03:44 <ski> or that line needs to be revised
22:05:04 <EvanR> on the subject of newtypes, two reasons NOT to automatically have all the operations available i can think of are 1) when i have two or more things of the same kind and i want to keep them straight, like arguments or state vars and 2) when not exporting access to the internal structure
22:05:41 <EvanR> the more things that are allowed, or possible, the fewer things the compiler can complain about when you accidentally do them
22:05:51 <ski> "Rings, domains and fields are also F-algebras" .. i don't see how they can say that for fields
22:05:54 <RustyShackleford> any idea how xmonad is implemented?
22:06:02 <RustyShackleford> they must be using some kind of gui toolkit
22:06:19 <vanila> it uses the X protocol
22:06:36 <ski> EvanR : yes
22:06:51 <vanila> X is the GUI system which displays all the graphics
22:06:54 <EvanR> what about fields can be equational
22:07:00 <ski> though there are different reasons for "not exporting access to the internal structure"
22:07:10 <EvanR> cant*
22:07:42 <xpika> can anyone show me an example of Monad transformers that does not use IO ?
22:07:48 <ski> one is simply to keep the representation secret, or to be able to replace it without causing trouble
22:08:22 <srhb> xpika: Reader Writer State is a classic.
22:08:33 <ski> another is to prohibit unauthorized access, to be able to ensure certain invariants, and the like
22:08:57 <ski> a common case here is to encode a subtype or a factor/quotient type
22:09:09 <ruuns> Hi :3
22:09:14 <Hijiri> hi
22:09:19 <ski> hi
22:09:45 <calvinx> how’s haskell land doing today :-)
22:09:57 <ski> EvanR : "fields can't be equational" -- where did that come from ?
22:10:14 <xpika> something like this : evalState (modify (+1) >> runMaybeT (lift (modify id) >> (Just 2))) >>= return)
22:10:19 <EvanR> that was partially misunderstood and misspoken
22:10:32 <xpika> state mixed with maybe
22:10:36 <EvanR> what aspect of fields make them not an F-algebra
22:10:41 <ski> oh, now i understand
22:10:46 <RustyShackleford> XMonad is really not that much code at all
22:10:56 <ski> EvanR : well, you can't divide by zero
22:10:58 <RustyShackleford> it's rather impressive how small the codebase is
22:11:00 <EvanR> ok
22:11:11 <ski> EvanR : how do you express the type of the division operation ?
22:11:42 <EvanR> with a proposition?
22:11:49 <ski> EvanR : or the limited applicability of the cancellation law for multiplication ?
22:12:05 <ski> universal algebra is a kind of connective-free logic
22:12:32 <ski> it has terms, variables, constant symbols, and function symbols
22:12:32 <EvanR> interesting
22:12:41 <ski> and equality judgements
22:13:10 <EvanR> is "a logic" a thing below algebras ;)
22:13:15 <ski> so, it's a bit like predicate logic, minus the connectices (plus having equality judgements)
22:13:55 <ski> EvanR : not sure what you mean ..
22:14:37 <EvanR> nevermind, universal algebra is one thing, a particular algebra is another
22:15:02 <ski> yes, universal algebra is comparable to propositional/sentential logic, and to predicate logic
22:15:23 <Zemyla> Hmm, so next, I need to write log for Fixed.
22:15:49 <ski> while a specific algebraic signature in the former is then comparable to a "language" of propositional variables, or a language/signature of predicate and function symbols
22:16:03 <ski> (correspondingwise)
22:16:44 <Zemyla> I have a working exp, which unfortunately but necessarily does all its operations on rational numbers before casting back to Fixef.
22:16:45 <ski> and then a specific algebra is a model for the signature, like a specific interpretation/situation/context is a model for the language or signature
22:17:37 <EvanR> Zemyla: exp seems like it makes less sense on rationals than it does on fixed
22:17:48 <ski> (in predicate logic you also talk about a "theory", which is a signature, extended with "axioms" (compare with the laws), which are "taken for granted" -- so it's like they are eternal assumptions, and your models only concern stuff that satisfy them)
22:18:30 <Zemyla> EvanR: Yes, but you need absolute tons of precision.
22:19:08 <EvanR> theres CReal
22:19:48 <EvanR> when you do a transcendental operation on a rational, the precision is up to some arbitrary amount
22:20:14 <Zemyla> Isn't CReal just a floating-point data type that can be passed to C functions?
22:20:23 <EvanR> no
22:20:32 <EvanR> computable real
22:21:06 <Zemyla> And fortunately, Fixed specifies the amount of precision.
22:21:24 <EvanR> > exp (314 % 100)
22:21:26 <lambdabot>  No instance for (GHC.Show.Show a0)
22:21:26 <lambdabot>    arising from a use of ‘M31229309456952158010950.show_M31229309456952158010...
22:21:26 <lambdabot>  The type variable ‘a0’ is ambiguous
22:21:38 <EvanR> > exp (314 % 100) :: Rational
22:21:39 <ski> > showFracAtBase 10 intToDigit (pi :: CReal) ""  -- this is strange, is it a bug ?
22:21:40 <lambdabot>  No instance for (GHC.Float.Floating GHC.Real.Rational)
22:21:40 <lambdabot>    arising from a use of ‘GHC.Float.exp’
22:21:40 <lambdabot>  can't find file: L.hs
22:21:54 <ski> er, wrong one
22:22:03 <ski> > properFraction (pi * 1000 :: CReal)  -- this one
22:22:05 <lambdabot>  (3142,-0.4073464102067615373566167204971158028306)
22:22:11 <EvanR> Zemyla: nevermind i thought rational had Floating instance
22:22:29 <ski> why is the fractional remainder *negative* !?
22:22:46 <Zemyla> That's why it's so hard to add to Fixed.
22:23:05 <EvanR> yeah Fixed isnt really Floating
22:23:17 <EvanR> by name or by function
22:23:26 <ski> is `Fixed' a modulo system ?
22:23:35 <Zemyla> There's no reason it can't be, though.
22:23:51 <EvanR> ski: decimal fixed points
22:23:53 <Zemyla> ski: No, it uses Integers.
22:24:10 <ski> ok
22:24:33 <ski> (so not `Int8' or `Int16' or something like)
22:24:50 <EvanR> no
22:25:00 <ski> fine
22:25:03 <EvanR> > pi :: Centi
22:25:04 <lambdabot>  No instance for (GHC.Float.Floating Data.Fixed.Centi)
22:25:04 <lambdabot>    arising from a use of ‘GHC.Float.pi’
22:25:12 <EvanR> > 3.14159 :: Centi
22:25:13 <lambdabot>  3.14
22:25:25 <ski> one could wonder if `log' in e.g. `Int8' should be discrete logarithm (modulo `256')
22:26:12 <ski> hm, well .. that wouldn't work, since the domain and codomain type shouldn't really be the same type in these cases
22:26:23 * hackagebot stackage 0.5.2 - "Stable Hackage," tools for creating a vetted set of packages from Hackage.  http://hackage.haskell.org/package/stackage-0.5.2 (MichaelSnoyman)
22:26:32 <EvanR> > sqrt (realToFrac (2 :: Pico))
22:26:33 <lambdabot>  1.4142135623730951
22:26:48 <EvanR> > realToFrac (sqrt (realToFrac (2 :: Pico))) :: Pico
22:26:49 <lambdabot>  1.414213562373
22:27:56 <EvanR> > realToFrac (log (realToFrac (2 :: Pico))) :: Pico
22:27:57 <lambdabot>  0.693147180559
22:28:10 <EvanR> > realToFrac (exp (realToFrac (2 :: Pico))) :: Pico
22:28:12 <lambdabot>  7.389056098930
22:28:17 <EvanR> > realToFrac (sin (realToFrac (2 :: Pico))) :: Pico
22:28:18 <lambdabot>  0.909297426825
22:28:19 <srhb> xpika: \x -> flip evalStateT x $ do { n <- get; x <- lift (maybeSqrt n); return (x+2) } -- super contrived.
22:29:22 <Zemyla> I also created an EDouble e type, which is HasResolution if e is, and whose resolution is e.resolution ^2.
22:29:48 <EvanR> ski: i read this pdf .. pi sigma, bare bones language for dependent types .. the implementation seems out of date, but im struggling to understand where it fits in
22:30:59 <EvanR> theres a lot missing relative to real languages, data declarations, pattern matching, termination checking
22:31:22 <EvanR> but the simplicity is appealing
22:31:45 <peddie> EvanR: isn't that meant to be a core-equivalent language?
22:31:54 <EvanR> it seems that way
22:31:55 <ski>   log_g : ℤ ∕ (ϕ p · ℤ) → ℤ ∕ (ϕ (ϕ p) · ℤ)
22:32:00 <ski> or something like that, iirc
22:32:19 <ski> EvanR : hm, which is that ?
22:32:39 <EvanR> ΠΣ: Dependent Types without the Sugar
22:32:50 <Zemyla> But yeah, I have a Taylor series for exp(x), which I apply to x / ceiling (abs x) and then repeatedly exponentiate.
22:33:02 <ski> EvanR : author ?
22:33:03 <ski> (s)
22:33:14 <EvanR> T Altenkirch
22:33:21 <EvanR> et al
22:33:26 <peddie> ski: http://www.andres-loeh.de/PiSigma/PiSigma.pdf
22:33:28 <ski> Thorsten
22:33:59 <EvanR> do i have to move to england to go to a university that cares about this stuff
22:34:23 <srhb> Not necessarily England... :-)
22:34:34 <ski> "ΠΣ: Dependent Types without the Sugar" by Thorsten Altenkirch,Nils Anders Danielsson,Andres Löh,Nicolas Oury in 2010-06-20 at <http://www.andres-loeh.de/PiSigma/>, ty
22:34:41 <Zemyla> Actually, I should divide x by 2^(ceiling (log_2 (abs x))), then I only have to square it n times.
22:36:05 <Zemyla> And ceiling (log_2 x) can be easily calculated in integer arithmetic.
22:36:15 <EvanR> i didnt know about that page
22:36:17 <ski> peddie,EvanR : nice, ty :)
22:36:17 <EvanR> ah
22:36:52 <ski> EvanR : try Sweden ?
22:37:21 <EvanR> ski: hmmmmm
22:37:32 <srhb> Gothenburg specifically, iirc
22:37:47 <Zemyla> This reduces the number of times I have to multiply huge rationals, and also results in smaller numbers passed to the Taylor series.
22:39:07 <EvanR> > let n = 2 :: Centi in realToFrac (log (realtoFrac n :: CReal)) :: Pico
22:39:08 <lambdabot>  Not in scope: ‘realtoFrac’
22:39:08 <lambdabot>  Perhaps you meant ‘realToFrac’ (imported from Prelude)
22:39:14 <EvanR> > let n = 2 :: Centi in realToFrac (log (realToFrac n :: CReal)) :: Pico
22:39:15 <lambdabot>  *Exception: CReal.toRational
22:39:29 <EvanR> > let n = 2 :: Centi in realToFrac (log ((realToFrac n) :: CReal)) :: Pico
22:39:30 <lambdabot>  *Exception: CReal.toRational
22:39:49 <EvanR> Centi -> CReal? :(
22:40:36 <ski> > approxRational ((1 + sqrt 5) / 2 :: CReal) (1/5)
22:40:37 <lambdabot>  *Exception: CReal.toRational
22:40:40 <ski> bah :)
22:40:55 <EvanR> oh its implemented, as error
22:40:59 <EvanR> wtf
22:41:07 <ski> i would'e thought that `approxRational' could be more possible to implement, for `CReal'
22:41:18 <ski> `toRational' is no wonder, though
22:41:40 <ski> srhb : yup :)
22:41:53 <srhb> ?
22:41:56 <srhb> Oh
22:42:04 <srhb> Got it :-)
22:42:13 <EvanR> do i have to speak swedish to go there
22:42:22 <ski> also, i think there's type theorists at Copenhagen
22:42:29 <srhb> There are a few, yes.
22:42:30 <ski> Danvy ?
22:43:08 <ski> dunny if Karoline Malmkjær stayed there, but i think she was there earlier
22:43:23 <starless> EvanR: Swedish not hard for a native English speaker, just so you know.
22:43:31 <EvanR> hahaha
22:44:01 <starless> :) I'm serious (and American, if that speaks for my affinity for foreign languages.)
22:44:36 <ski> EvanR : "oh its implemented, as error", specifically which one is ?
22:45:03 <EvanR> toRational
22:45:08 <ski> right
22:45:15 <ski> (which was to be expected)
22:45:15 <shachaf> class Real a where { toRational :: a -> Rational } is such a great class
22:45:31 <EvanR> why both implementing the Real class
22:45:35 <EvanR> bother
22:45:44 <ski> hm, point
22:45:57 <EvanR> also "Real" wth
22:46:11 <ski> perhaps they wanted `RealFrac' ?
22:46:16 <ski> (which is a subclass)
22:46:45 <EvanR> > toRational pi
22:46:46 <lambdabot>  884279719003555 % 281474976710656
22:47:03 <EvanR> > toRational pi :: Ratio Integer
22:47:05 <lambdabot>  884279719003555 % 281474976710656
22:47:15 <EvanR> > toRational pi :: Ratio Ordinal
22:47:17 <lambdabot>  Not in scope: type constructor or class ‘Ordinal’
22:52:51 <ski> > showFracAtBase (2^4) intToDigit pi ""
22:52:53 <lambdabot>  "3.243f6a8885a3"
22:53:07 <ski> > showFloatAtBasePowerOf2 4 intToDigit pi ""
22:53:09 <lambdabot>  "3.243f6a8885a30"
22:56:24 * hackagebot http2 0.7.0 - HTTP/2.0 library including frames and HPACK  http://hackage.haskell.org/package/http2-0.7.0 (KazuYamamoto)
22:56:26 * hackagebot shakespeare 2.0.3 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-2.0.3 (MichaelSnoyman)
22:58:06 <Zemyla> "Real" is a class for numbers which the rationals are dense in.
22:59:09 <EvanR> so from a "Real" you can get a rational arbitrarily close to it?
22:59:47 <EvanR> > toRational (pi :: CReal)
22:59:49 <lambdabot>  *Exception: CReal.toRational
23:17:12 <Zemyla> EvanR: Yeah. That's why they're Ord, because the number line provides an ordering.
23:18:15 <EvanR> > toRational (3 :+ 0)
23:18:17 <lambdabot>  No instance for (GHC.Real.Real (Data.Complex.Complex a0))
23:18:17 <lambdabot>    arising from a use of ‘GHC.Real.toRational’No instance for (GHC.Num.Num a0...
23:18:17 <lambdabot>  The type variable ‘a0’ is ambiguous
23:18:45 <EvanR> > toRational (3 :+ 0 :: Complex Double)
23:18:46 <lambdabot>  No instance for (GHC.Real.Real
23:18:46 <lambdabot>                     (Data.Complex.Complex GHC.Types.Double))
23:18:46 <lambdabot>    arising from a use of ‘GHC.Real.toRational’
23:18:47 <Zemyla> Complex numbers aren't real.
23:19:02 <EvanR> just checking
23:19:27 <shachaf> You can check in /msg lambdabot, you know.
23:19:39 <shachaf> (You should only use lambdabot in the channel when you're demonstrating something.)
23:20:06 <Zemyla> Though they should, in my opinion, have an Ord instance, just so they can be placed in Sets and Maps.
23:20:28 <EvanR> lexico ordering?
23:20:34 <Zemyla> Yeah.
23:20:50 <EvanR> might be a hackage package
23:21:43 <Zemyla> Is there an implicit variable that can provide faux Ord instances to Set and Map?
23:32:51 <Zemyla> How many monads have to explicitly define (>>)?
23:32:58 <adas> is it wrong to think of something like "pi :: Double; pi = 3.14" as a function that takes nothing and returns a double?
23:33:10 <shachaf> adas: Yes.
23:33:27 <shachaf> @google everything is a function in haskell
23:33:29 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
23:33:29 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
23:33:31 <adas> so what is 'pi'? just a value with a type?
23:33:43 <kadoban> adas: Yes.
23:33:48 <shachaf> Yes, it's a value.
23:34:06 <EvanR> its a constant value (one for each instance of Floating)
23:34:25 <shachaf> EvanR: You're not helping.
23:34:31 <Zemyla> adas: A function that takes nothing and returns Double would be () -> Double.
23:34:50 <mietek> Why isn’t LineBuffering the default for stdout?
23:35:11 <adas> thanks for the clarification
23:35:40 <shachaf> mietek: It is.
23:36:26 * hackagebot lzma-conduit 1.1.3 - Conduit interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-conduit-1.1.3 (NathanHowell)
23:37:30 <mietek> shachaf: why would Text.putStrLn require a hFlush, then?
23:38:25 <shachaf> Maybe more context is required for your question.
23:38:57 <erikd> mietek: you need hFlush if you want to output a string that does not end in a newline
23:39:49 <mietek> shachaf, erikd: https://github.com/mietek/halcyon-tutorial/blob/master/Main.hs#L34
23:40:12 <mietek> When this program is run in a regular shell, it works as expected
23:40:17 <mietek> And output appears when expected
23:40:40 <mietek> When this exact program, renamed, is run on Heroku (https://github.com/mietek/haskell-on-heroku-tutorial/blob/master/Main.hs#L34)
23:40:55 <mietek> Output does not appear unless I add a hFlush after the T.putStrLn
23:41:19 <EvanR> i noticed that on heroku
23:41:33 <EvanR> their output is extra buffered
23:41:46 <mietek> Well, hm.
23:42:21 <shachaf> mietek: What's the buffering mode on Heroku?
23:42:27 <shachaf> (hGetBuffering stdout >>= print)
23:43:10 <shachaf> Maybe Text's putStrLn doesn't respect buffering.
23:43:32 <shachaf> But it looks like it should.
23:44:35 <Zemyla> @src Text
23:44:35 <lambdabot> Source not found. Take a stress pill and think things over.
23:44:53 <glguy> Line buffering is default on a terminal on stdout but not in general
23:45:03 <Zemyla> Why don't any of these thibgs support Seq Char?
23:45:45 <shachaf> Seq Char isn't particularly suitable for many things.
23:46:17 <mietek> glguy: ah!
23:46:34 <mietek> glguy: so, one just needs to hSetBuffering to be sure, then?
23:46:46 <mietek> shachaf: checking.
23:46:54 <shachaf> mietek: OK, glguy's answer was better than mine. :-)
23:47:11 <EvanR> its a good idea to leave their buffering the way it is for production
23:47:25 <EvanR> but it makes debugging logs a bitch
23:47:42 <mietek> EvanR: it’s not their buffering — it’s my app’s buffering
23:48:09 <EvanR> yeah, the default stdout buffering mode
23:48:26 <glguy> Boo!
23:48:31 <mietek> EvanR: why would you say it’s a good idea to leave it not working for production?
23:48:55 <glguy> ==shachaf
23:49:23 <EvanR> its block buffering, if youre webserver is generating a lot of logs itll hurt performance to be line buffered
23:49:27 <EvanR> your*
23:49:46 <EvanR> the logs appear but delayed
23:50:12 <mietek> EvanR: OK, fair enough. I would say, if your app (it’s not necessarily a third-party webserver!) is generating lots of logs, then that should be fixed.
23:50:30 <mietek> As Heroku itself should make most webserver logs redundant
23:50:33 <mietek> shachaf: BlockBuffering Nothing
23:51:13 <mietek> EvanR: BTW, what are you doing with Haskell on Heroku?
23:51:48 <EvanR> this experience was from ruby on heroku
23:51:52 <mietek> Aha.
23:52:07 <EvanR> but im interested in haskell on heroku
23:52:13 <mietek> Excellent!
23:52:15 * mietek rubs hands
23:52:21 <EvanR> heh
23:52:47 <mietek> So, I have this thing which I was really hoping to have properly announced and released by now
23:52:49 <EvanR> (which could be the missing killer app! not f-ing haskell on a horse)
23:53:02 <mietek> The main part of it is called Halcyon
23:53:12 <Zemyla> Haskell on a horse?
23:53:37 <mietek> And I use it as the main part of Haskell on Heroku.
23:53:37 <EvanR> i saw your website, fancy
23:53:37 <Zemyla> Like Isaiah Mustafa getting into it?
23:53:40 <mietek> Thanks!
23:53:52 <mietek> I’m looking for comments on https://halcyon.sh/tutorial/ which I’m currently trying to finish.
23:54:02 <mietek> The corresponding tutorial for Heroku is coming soon.
23:54:19 <mietek> Join us in #haskell-deployment if you’re into this sort of thing.
23:54:52 <Zemyla> What is Heroku?
23:58:01 <favetelinguis> why do i get this type error? http://lpaste.net/118409
23:59:51 <glguy> Because you called folder with that [] argument
