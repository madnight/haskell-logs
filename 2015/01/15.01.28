00:01:43 <atec> thanks shachaf - my code isn't far from what I posted. it's just this
00:01:46 <kadoban> atec: For weird insane reasons that you should ignore for a long time, that list isn't what you probably think it is. haskell lists aren't heterogenous, all of the list elements have to be the same.
00:01:58 <atec> let c = [1,2,3,[4,5,6]]
00:02:02 <atec> then 0:c
00:02:07 <shachaf> atec: And your full error message? :-)
00:02:11 <shachaf> You can use hpaste.org.
00:02:17 <atec>  No instance for (Num [t0]) arising from a use of ëití
00:02:18 <atec>     In a stmt of an interactive GHCi command: print it
00:02:28 <atec> I am guessing that 1 2 and 3 are in fact lists themselves?
00:02:29 <shachaf> If you're typing those things in ghci, I would bet that c gives you the same error message as 0:c
00:02:38 <shachaf> So the problem isn't where you think it is at all.
00:02:41 <HeladoDeBrownie> it doesn't, actually; ghci lets you write polymorphic definitions like that
00:02:44 <atec> ah
00:02:54 <HeladoDeBrownie> but the problem arises when you actually try to *use* c
00:03:08 <shachaf> Yes, in order to treat [1,2,3,[4,5,6]] as a list where all the elements are of the same type, 1, 2, 3 must be lists themselves.
00:03:31 <shachaf> This is in theory possible, but in practice it's probably a bad idea and certainly there's no meaning to it by default.
00:03:37 <shachaf> So you get an error.
00:03:55 <gds> Doesn't the error message say that ghc is confused that it can't figure out how to treat [4,5,6] as a number (like the 1, 2 and 3 it's already seen) ?
00:04:01 <shachaf> Here the error is "I can't figure out what type you want the elements of this list to be!". GHC puts it a little bit confusingly.
00:04:58 <HeladoDeBrownie> normally you'd have got a more informative error message saying that, but numeric literals are special
00:05:00 <shachaf> It's a bunch of different features coming together that happen to cause this confusion.
00:05:18 <shachaf> E.g. with let c = ['a','b','c',['d','e','f']] you'd get an error straight away.
00:05:40 <Zemyla> Hmm. With DataKinds, is a type on Integer promoted to a kind on Nat?
00:06:21 <shachaf> Zemyla: I would hope not.
00:06:36 <atec> I think I see now, was confused because ghci didn't complain right away
00:06:48 <HeladoDeBrownie> atec, yeah, that's a good way to put it
00:07:13 <atec> thanks very much
00:10:39 <t4nk486> hello
00:11:15 <t4nk486> i don't know what this is or if I'm even talking to anyone...
00:11:21 <mauke> this is an irc channel
00:11:25 <mauke> hi :-)
00:11:40 <t4nk486> is this where we talk about haskell?
00:11:43 <mauke> yes
00:11:57 <mauke> are you connecting from some web page?
00:12:19 <t4nk486> where can i go to read up on the rules. Not gonna lie, i was just trying to see if I can get some clarification/help for a haskell homework question.
00:12:38 <mauke> I don't know if we have official rules
00:12:42 <mauke> basically, "don't be a dick"
00:13:01 <mauke> also, general irc stuff like "use a paste site instead of pasting into the channel"
00:13:22 <Ralith> it's generally seen as poor form to ask for outright answers to homework questions
00:13:25 <mauke> and "don't ask to ask; just ask"
00:14:02 <mauke> asking for hints is fine, though, especially if you're up front about it being a homework problem
00:14:36 <t4nk486> i mean, it's not assigned yet, so i just came here because I wanted to see what resources I could make available for myself. thank you guys, for clarifying the details.
00:15:20 <mauke> > 2 + 2
00:15:22 <lambdabot>  4
00:15:25 <mauke> magic
00:17:26 <gds> If you want extra stuff to read, there are books and tutorials a lot of folk find helpful. Like "Learn You a Haskell"
00:17:30 <gds> @where lyah
00:17:30 <lambdabot> http://www.learnyouahaskell.com/
00:18:53 <tdammers> t4nk486: #haskell is probably the friendliest channel on all of freenode ;)
00:20:11 <tdammers> lol wut? "The package list from haskell.org is 15.0 days old"
00:20:24 <tdammers> when did fractional days happen?
00:21:19 <sivteck> cabal 1.22? I get "Warning: The package list for 'hackage.haskell.org' is 21 days old."
00:21:27 <sivteck> for cabal 1.20
00:21:50 <gds> I guess that might be helpful if you want to update >=twice in a day...
00:34:46 * hackagebot mandrill 0.2.0.0 - Library for interfacing with the Mandrill JSON API  http://hackage.haskell.org/package/mandrill-0.2.0.0 (AlfredoDiNapoli)
00:37:59 <Thunderfire> Hello
00:38:38 <mauke> o/
00:43:04 <mauke> > iterate (concatMap (liftA2 (printf "%d%c") length head) . group) "1"
00:43:05 <lambdabot>  ["1","11","21","1211","111221","312211","13112221","1113213211","31131211131...
00:52:52 <Zemyla> :t group
00:52:53 <lambdabot> Eq a => [a] -> [[a]]
00:53:21 <Zemyla> :t liftA2 (printf "%d%c") length head
00:53:22 <lambdabot> (PrintfArg b, PrintfType c) => [b] -> c
00:53:47 <Zemyla> :t (liftA2 (printf "%d%c") length head) . group
00:53:48 <lambdabot> (IsChar a, PrintfType c, Eq a) => [a] -> c
00:55:51 <shachaf> printf :: Int -> Char -> String in this case, of course.
00:58:28 <xxprismxx> su
00:58:38 <mauke> :t iterate (concatMap (liftA2 ?printf_fmt length head) . group)
00:58:39 <lambdabot> (?printf_fmt::Int -> b -> [b], Eq b) => [b] -> [[b]]
00:58:53 <mauke> :t iterate (concatMap (liftA2 ?printf_fmt length head) . group) "1"
00:58:54 <lambdabot> (?printf_fmt::Int -> Char -> [Char]) => [[Char]]
01:14:38 <Lokathor> ghc doesn't seem to be searching in the sandbox files for the module it needs
01:14:44 <Lokathor> how odd
01:16:11 <kadoban> Lokathor: Are you talking about cabal sandbox? GHC doesn't know about sandboxes by default. Use cabal features instead of running GHC manually, or there's some switches you can use to tell GHC where to search if you really want to.
01:16:27 <Lokathor> ah, right, right
01:16:38 <Lokathor> should not try demo code the last thing i do before going to bed >_<
01:46:28 <Zemyla> Okay, there should be an instance (Applicative f, Monoid a) => Monoid (SomeNewType f a), where mempty = pure mempty and mappend = liftA2 mappend.
01:47:06 <merijn> Zemyla: The complaint about that instance is that if overlaps with too many
01:47:19 <merijn> i.e. it overlaps with "Monoid [a]
01:47:39 <mauke> SomeNewType
01:47:47 <merijn> oh, I can't read :)
01:48:20 <merijn> I'd support "newtype ApplicativeMonoid f a = AppMonoid (f a)", submit a proposal to libraries@ ;)
01:48:32 <shachaf> Yes, that newtype would be nice to have.
01:49:25 <shachaf> You get unusual Monoid instances for natural numbers represented as [()] -- multiplication with the usual Applicative instance, and minimum with ZipList.
01:52:14 <tdammers> the beauty being that they're unusual, but nonetheless hold up otherwise
01:54:47 <merijn> I <3 the fact that attoparsec took the time to add a Monoid instance for Parser
01:55:28 <Zemyla> Also, you can get maximum on [()] if mempty = [] and mappend [] lb = lb, mappend la [] = la.
01:58:22 <shachaf> Certainly you can make a maximum monoid for naturals, but that's not very interesting.
01:58:39 <merijn> I'm gonna be rich once I figure out how to use many different Monoid instances per type without needing newtypes... :p
01:58:46 <shachaf> If nothing else the ZipList behavior works for things other than ()
01:59:29 <shachaf> Also, you can't make a minimum monoid for naturals. But fortunately [()] is actually the conaturals, with an infinity.
02:00:35 <Zemyla> merijn: Why wouldn't Parser be a Monoid? It's a MonadPlus and an Alternative.
02:01:21 <jtanguy> merijn: there's named instances in idris, maybe we can do something in haskell (might require an extension)
02:01:50 <merijn> Zemyla: I said it *is* and that I was happy that instance was present :)
02:02:40 <merijn> jtanguy: The thing is, that I'm not sure about how to use an explicit monoid instances without using the ease of reasoning about code. But then again, I haven't really tried Idris yet, so who knows...
02:03:15 <merijn> To bad Idris is strict :(
02:07:18 <Zemyla> Hold on, is ApplicativeMonoid ((,) e) a the same as the Monoid instance on (e, a)? It has to be.
02:07:27 <jtanguy> as expected, lens has a way to do that
02:09:06 <merijn> Zemyla: Yes, because 'e' has to be a Monoid for ((,) e) to be Applicative
02:10:57 <jtanguy> > ala Sum foldMap [1..5]
02:10:58 <lambdabot>  15
02:11:02 <jtanguy> > ala Product foldMap [1..5]
02:11:04 <lambdabot>  120
02:12:15 <lachenmayer> :t ala
02:12:16 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
02:12:51 <jtanguy> lens types
02:14:36 <lachenmayer> nice!
02:14:43 <lachenmayer> and where do the names for the instances come from?
02:15:08 <merijn> Sum and Product are newtypes in Data.Monoid
02:15:40 <Zemyla> :t ala
02:15:41 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
02:15:53 <Zemyla> @hoogle Rewrapped
02:15:57 <lambdabot> No results found
02:15:58 <merijn> Zemyla: It's from lens
02:16:10 <merijn> Like everything with a type that intimidating is :p
02:16:23 <lachenmayer> ahh, of course
02:18:12 <Zemyla> > (coerce (fold (coerce [1..5] :: [Product]))) :: Int
02:18:14 <lambdabot>  Expecting one more argument to ‚ÄòData.Monoid.Product‚Äô
02:18:14 <lambdabot>  Expected kind ‚Äò*‚Äô, but ‚ÄòData.Monoid.Product‚Äô has kind ‚Äò* -> *‚Äô
02:18:24 <Zemyla> > (coerce (fold (coerce [1..5] :: [Product Int]))) :: Int
02:18:25 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Int‚Äô
02:18:25 <lambdabot>              with actual type ‚ÄòData.Monoid.Product b0‚Äô
02:18:46 <merijn> I don't think you mean fold
02:18:57 <merijn> :t F.mconcat
02:18:58 <lambdabot>     Not in scope: ‚ÄòF.mconcat‚Äô
02:18:59 <lambdabot>     Perhaps you meant ‚ÄòF.concat‚Äô (imported from Data.Foldable)
02:19:02 <merijn> :t F.concat
02:19:03 <lambdabot> Foldable t => t [a] -> [a]
02:19:11 <merijn> hmm, not what I meant
02:19:15 <merijn> :t F.sum
02:19:17 <lambdabot> (Foldable t, Num a) => t a -> a
02:19:19 <merijn> :t F.msum
02:19:20 <lambdabot> (Foldable t, MonadPlus m) => t (m a) -> m a
02:19:25 <shachaf> I think you're looking for fold.
02:19:26 <merijn> ok, I give up
02:19:49 <merijn> oh, F.fold is mconcat?
02:20:17 <shachaf> In the case of lists, yes.
02:20:30 <merijn> Right, I fail, apparently :)
02:20:52 <merijn> > coerce (F.fold (coerce [1..5] :: [Product Int])) :: Int
02:20:53 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Int‚Äô
02:20:53 <lambdabot>              with actual type ‚ÄòData.Monoid.Product b0‚Äô
02:21:17 <merijn> :t coerce
02:21:18 <lambdabot> (Contravariant f, Functor f) => f a -> f b
02:21:30 <merijn> That doesn't look like the right coerce
02:21:45 <shachaf> That is lens's coerce, not GHC's coerce.
02:21:49 <merijn> I figured
02:22:06 <shachaf> It is contramap (const ()) . fmap (const ())
02:22:57 <shachaf> Not a very general-purpose function. It only works with phantom types.
02:24:52 <lachenmayer> this works at home, ha > coerce (fold (coerce ([1..5] :: [Int]) :: [Product Int])) :: Int
02:25:23 <merijn> lachenmayer: That means you have 1) imported the fold from Foldable and 2) don't have lenses coerce imported
02:25:52 <lachenmayer> yep, in ghci :m + Data.Monoid Data.Coerce Data.Foldable
02:26:22 <lachenmayer> though for this to work i specifically had to cast [1..5] :: [Int]
02:26:56 <shachaf> :: isn't casting. Maybe the word is "annotate".
02:30:29 <lachenmayer> shachaf: surely this is casting though? > [1..5] :: [Double]
02:30:54 <shachaf> Not casting, at least in any usual sense of the word.
02:31:22 <shachaf> Why would :: [Double] be any more casting than :: [Int]?
02:31:27 <tdammers> it's not casting, it just tells the compiler which type to use
02:31:39 <shachaf> The type of [1..5] is neither [Double] nor [Int] (or, if you prefer, it's both).
02:32:08 <tdammers> I think it's more correct to say that [1..5], without a type annotation, is polymorphic
02:32:20 <jtanguy> :t [1..5]
02:32:21 <lambdabot> (Num t, Enum t) => [t]
02:32:38 <tdammers> it can assume any of a range of types, depending on what the compiler infers based on the rest of the code
02:33:30 <tdammers> by annotating, you merely force it to a particular type instead of leaving it to type inference
02:35:35 <lachenmayer> sure
02:35:54 <genisage> Does anybody know if there's a function `f :: Monoid a,b => (Maybe a -> b) -> Maybe a -> Maybe a -> b` that behaves like so: f g Nothing b = g b; f g a Nothing = g a; f g a b = g a <> g b
02:36:00 <dizzeehaskell> *blink*
02:36:06 * dizzeehaskell reads
02:37:04 <Zemyla> genisage: The `on` function should do that.
02:37:08 <Zemyla> :t on
02:37:09 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
02:37:18 <Zemyla> :t on mappend
02:37:19 <lambdabot> Monoid c => (a -> c) -> a -> a -> c
02:38:12 <genisage> Zemyla: is that from Data.Monoid?
02:38:20 <Zemyla> @src on
02:38:20 <lambdabot> (*) `on` f = \x y -> f x * f y
02:38:28 <predator217> on is in Data.Function
02:39:03 <n4x> I'd go with (\f -> mappend `on (maybe mempty f))
02:39:06 <n4x> @type (\f -> mappend `on (maybe mempty f))
02:39:07 <lambdabot> parse error on input ‚Äò(‚Äô
02:39:15 <n4x> @type (\f -> mappend `on` (maybe mempty f))
02:39:16 <lambdabot> Monoid c => (a -> c) -> Maybe a -> Maybe a -> c
02:39:47 <genisage> Cool. Thanks all.
02:40:26 <Zemyla> :t (on mappend) . (maybe mempty)
02:40:27 <lambdabot> Monoid c => (a -> c) -> Maybe a -> Maybe a -> c
02:40:52 <Zemyla> genisage: There's the simplest definition.
02:41:06 <n4x> controversial
02:41:23 <Zemyla> Shortest, then.
02:41:54 <genisage> (on (<>)) . (maybe mempty)
02:43:33 <jtanguy> it may be easier just to reorder the arguments to match the type of (on mappend)
02:44:26 <merijn> :t fromMaybe
02:44:27 <lambdabot> a -> Maybe a -> a
02:44:38 <merijn> :t mappend `on` fromMaybe mempty
02:44:39 <lambdabot> Monoid c => Maybe c -> Maybe c -> c
02:44:49 <merijn> oh, right
02:45:00 <merijn> :t mappend `on` fromMaybe mempty . (undefined :: Maybe a -> b)
02:45:01 <lambdabot> Monoid c => Maybe a -> Maybe a -> c
02:45:12 <merijn> Which I guess is
02:45:27 <merijn> oh, no I'm overcomplicating things
02:45:54 <merijn> It's just "on mappend" without anything else
02:46:12 <Zemyla> But yeah, IO (Monoid a) should be a monoid.
02:46:41 <merijn> Zemyla: Agreed, Tekmo already proposed that on the list and it was approved, but he hasn't contributed a patch yet
02:47:06 <merijn> Highly relevant tweet from this morning: https://twitter.com/GabrielG439/status/560213019443994624
02:47:14 <Zemyla> And would anything break if (r -> (Monoid a)) were a Monoid?
02:47:31 <merijn> Eh, it is
02:47:58 <merijn> btw, you mean "Monoid a => r -> a"
02:48:11 <merijn> But anyway, we do have "instance Monoid a => Monoid (r -> a)"
03:09:02 <steffen`> Where can I get a strict Set?
03:09:55 <Taneb> steffen`, Data.Set
03:10:52 <steffen`> Thanks :)
03:12:53 <NotImplemented> Hi, how can I contribute to leksah?
03:14:26 <hamishmack> NotImplemented: I think a good place to start is to find some smallish feature you would like to see added
03:14:53 * hackagebot deepseq-bounded 0.6.0.3 - Bounded deepseq, including support for generic deriving  http://hackage.haskell.org/package/deepseq-bounded-0.6.0.3 (AndrewSeniuk)
03:14:55 * hackagebot seqaid 0.2.1.0 - Dynamic strictness control, including space leak repair  http://hackage.haskell.org/package/seqaid-0.2.1.0 (AndrewSeniuk)
03:14:57 * hackagebot leaky 0.2.1.0 - Robust space leak, and its strictification  http://hackage.haskell.org/package/leaky-0.2.1.0 (AndrewSeniuk)
03:14:58 <hamishmack> Then have a go at adding it.  Let us know if you get stuck
03:15:31 <NotImplemented> Can I try opened issues on github?
03:15:47 <hamishmack> Sure
03:15:53 <hamishmack> What OS do you use?
03:16:18 <NotImplemented> windows
03:16:46 <hamishmack> Building leksah on windows can be difficult
03:17:10 <hamishmack> So the first step might be just trying to guild the github version from source
03:17:45 <hamishmack> The leksah binaries should include most (if not all) the Gtk libraries and header files you need
03:19:11 <hamishmack> first step is to cabal install gtk2hs-buildtools and check it winds up in your PATH
03:19:54 * hackagebot pgdl 6.7 - pgdownloader  http://hackage.haskell.org/package/pgdl-6.7 (sifmelcara)
03:39:02 <favetelinguis> Im lame when it comes to algorithms so i would appriciate if someone could point me in the right direction to what type of algorithms are designed to solve the following problem. I have a set S of items from wich i can to draw an arbitrary number of items withour deleting the ones i draw, each item i draw will create a list. The problem is that depending on which item i have drawn (represented by the items that is in the list) the
03:40:19 <indiagreen> favetelinguis: (if you're not aware of it, your message got cut off at ‚Äúin the list) the‚Äù)
03:42:30 <favetelinguis> dam :) there is the end " there are depedencies on which items are allowed to be drawned from the set."
04:04:56 * hackagebot descriptive 0.7.0 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.7.0 (ChrisDone)
04:14:56 * hackagebot hindent 4.3.4 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.3.4 (ChrisDone)
04:14:58 * hackagebot structured-haskell-mode 1.0.14 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.14 (ChrisDone)
04:52:33 <exio4> is there a way to reuse list syntax with a custom data structure?
04:53:42 <koomi> exio4: ghc >= 7.8 has the OverloadedLists extension
04:54:10 <exio4> thanks, will check
04:54:39 <kgadek> (pasting in name of @danilo2 , re-post from #ghc ): Hello all! I've got a totally mindblowing error in GHC here. So if I declare a function in a concrete module and this function has good signature and works just as simple pattern match and has a name used nowhere else and I export it from the module then I got ton of unrelated errors from other modules. If I do NOT export this function, no modules give errors. I tried
04:54:39 <kgadek>  changing name of that function and using type holes to inspect the types
04:55:57 <Yuras> kgadek: @lpaste it
04:57:21 <kgadek> Yuras: that's a long long list completely unrelated to the fact that some module declared some random function. We checked twice: no collision there, just a simple polymorphic function that returns a part of an ADT.
04:57:47 <kgadek> *no name collision
04:59:10 <Yuras> kgadek: lpaste.net has enough space, don't worry :)
04:59:49 <Yuras> it is hard to help without anything
05:01:40 <nshepperd_> also lpaste your code, or a portion of your code that reproduces the error
05:01:59 <nshepperd_> that's basically our catchphrase here, I think
05:16:57 <danilo2> Yuras: hmm, here is the error kgadek was talking about, but it is completely unreleated to the decared function and is from other module: http://lpaste.net/119386
05:18:23 <danilo2> Yuras: and foo is declared as _foo (Label l (Lambda i o b)) = undefined in module "Luna.Syntax.Expr"
05:18:45 <danilo2> as you see, it is compeltely unrelated
05:20:30 <mpickering> maybe try clearing dist/
05:20:37 <mpickering> if this is with cabal repl
05:21:34 <danilo2> mpickering: nope, it is with just cabal with cleaned dist
05:21:49 <Yuras> danilo2: all this warnings appear only with new function?
05:21:56 <danilo2> mpickering: when I delete the function everything compiles, when I do not export it, it compiles too
05:22:24 <danilo2> Yuras: warnings not - there are some untyped functions there, but errors yes
05:22:46 <danilo2> Yuras: We are working very hardly on these files now, so we've got some warnings about untyped top-level functions
05:23:04 <danilo2> but most of them are parser functions and sometimes there is even a convention not to type parser combinators
05:23:12 <danilo2> as far as i know
05:23:48 <Yuras> it seems to be the first error: src/Luna/Parser/Term.hs:143:19: No instance for (Luna.Data.Namespace.NamespaceMonad m)
05:24:50 <Yuras> is Luna.Data.Namespace module imported in src/Luna/Parser/Term.hs?
05:25:06 <danilo2> Yuras: no, becasue this is simmilar to "no instance for Monad m" - and without the function these errors does not appear and everything just compiles ...
05:26:02 <danilo2> Yuras: yes, it is imported there
05:27:00 <Yuras> if it is imported, then ghc should not fully qualified it in error message
05:27:37 <Yuras> probably you have some other NamespaceMonad in scope
05:28:04 <Yuras> or you depend on multiple versions of the same error
05:28:36 <Yuras> btw, any TemplateHaskell involved here?
05:28:39 <danilo2> Yuras: right, oh wait , it is not imported, a submodule is imported there, sorry
05:28:56 <danilo2> Yuras: nope, no TH here appart of many lenses
05:31:55 <danilo2> Yuras: but there are some undecidable instances in one place, but again compeltely unrelated
05:32:31 <Yuras> undecidable instances are always related :)
05:32:59 <danilo2> Yuras: yes I know, but this function does not use them
05:33:55 <iLike> A somewhat unrelated question, but does somebody know what follow sets are (in terms of grammars)?
05:34:41 <mauke> I think it's the possible symbols that can follow the current input according to the grammar
05:35:42 <Yuras> danilo2: I assume the binding (at src/Luna/Parser/Term.hs:143:19) doesn't have explicit type. try to add it
05:36:14 <danilo2> Yuras: ok, brb
05:36:27 <iLike> mauke, http://lpaste.net/2032499517990895616
05:39:45 <mauke> iLike: same reason as S, I guess
05:40:53 <iLike> mauke, but B only results in a terminal, the follow set should be empty? There's no way an 'a' could follow from B, right?
05:41:03 <mauke> sample input: cbab
05:42:41 <mauke> B is used in S is used in A is used in S
05:42:59 <iLike> mauke, ahh, tanks, now it clicks. It's not about things directly follow from the production itself, but from the starting production
05:44:42 <danilo2> Yuras: strange, ghc gives me a type, that GHC thinks is wrong
05:44:47 <danilo2> *ghci
05:44:52 <danilo2> Yuras: brb
05:49:32 <sdegutis> For those of you who do TDD and/or BDD, do you use Hspec or something else?
05:50:20 <Fuuzetsu> hspec
05:50:28 <Fuuzetsu> don't exactly do TDD though
05:50:36 <Fuuzetsu> unless the T stands for ‚ÄòTypes‚Äô ;)
05:50:40 <Fuuzetsu> Type*
05:51:14 <merijn> Fuuzetsu: HDD - Hole Driven Development :)
05:51:23 <Fuuzetsu> yep, big fan
05:51:33 <sdegutis> I usually write tests that test side-effects, so in Haskell I'll probably be writing mostly tests on IO functions.
05:51:39 <merijn> Fuuzetsu: -fdefer-typed-holes -fno-warn-typed-holes ;)
05:51:49 <sdegutis> Although it'll be fun to write some unit tests with quickCheck or whatever it's called, too.
05:52:03 <merijn> sdegutis: *IO actions
05:52:07 <sdegutis> Thanks merijn.
05:52:24 <merijn> sdegutis: "getLine :: IO String" <- not a function, since it doesn't take input :)
05:52:40 <merijn> It usually helps to keep that distinction clear
05:53:13 <Fuuzetsu> sdegutis: you can (and should) put QC in hshpec
05:53:15 <Fuuzetsu> hspec*
05:53:39 <sdegutis> Fuuzetsu: right
05:54:04 <Itkovian> dcoutts: re the abolishing cabal hell post, has anyone considered looking at what environment modules provide and more specifically, it's modern implementation, such as lmod (https://github.com/TACC/Lmod)
05:54:09 <sdegutis> I just learned what Fuctors and Applicative Functors are -- they sounded a lot scarier and harder than they actually are.
05:54:29 <merijn> Itkovian: Are you aware of ezyang's backpack work?
05:54:31 <Fuuzetsu> Itkovian: which post, wasn't here earlier?
05:54:44 <Fuuzetsu> merijn: not quite sure what backpack solves in regards to cabal hell
05:54:49 <Itkovian> merijn nope.
05:54:51 <Itkovian> Fuuzetsu http://www.well-typed.com/blog/2015/01/how-we-might-abolish-cabal-hell-part-2/
05:54:54 <merijn> sdegutis: A lot of terminology sounds scarier than it is
05:55:00 <sdegutis> :)
05:55:00 <Itkovian> at least I assume that duncan is dcoutts
05:55:11 <merijn> Fuuzetsu: The ability to have dependencies on different versions of the same library
05:55:40 <merijn> Or rather, have dependencies that depend on different versions of the same library
05:56:04 <merijn> Itkovian: See the posts here: http://blog.ezyang.com/category/haskell/backpack/
05:56:23 <Itkovian> merijn if this interests you, maybe also take a look at spack (out of llnl) https://github.com/scalability-llnl/spack
05:56:37 <Itkovian> thx merijn
05:56:38 <Fuuzetsu> afk
05:56:45 <Fuuzetsu> and I use nix for cabal hell ;)
05:57:22 <merijn> sdegutis: For example, Monads are just Applicative Functors that (depending on your view) can be "collapsed" or have effects depend on previous effects
05:58:42 <merijn> sdegutis: These two properties being described by the functions: "join :: Monad m => m (m a) -> m a" (collapsing multiple layers) and "(>>=) :: Monad m => m a -> (a -> m b) -> m b" (basing decisions on previous effects)
06:00:30 <merijn> sdegutis: Compare that with Applicative's "(<*>) :: Applicative f => f (a -> b) -> f a -> f b", here you see that the "effects" of 'f' are predetermined (you get two values that are already 'f'), whereas with >>= you "get an 'a' and return an arbitrary 'm' value", where you can have an arbitrarily complex haskell function decide "which" 'm b' to return
06:01:43 <sdegutis> merijn: I'm still reading the section on Monoids so I'm not quite there yet ;)
06:02:09 <merijn> @quote monoids
06:02:09 <lambdabot> beaky says: i love monoids / they are so easy
06:02:15 <elzair> I have an architecture question.
06:03:06 <elzair> I am trying to execute a list of commands; however, I want to break the sequence if one command returns a Left.
06:03:12 <elzair> What is the best way to do this?
06:03:47 <elzair> If it helps, here is the code for the makeCommands: https://gitlab.com/elzair/hannah/blob/master/lib/Task.hs
06:04:10 <elzair> Here is the code for the execute command: https://gitlab.com/elzair/hannah/blob/master/lib/Command.hs
06:05:27 <merijn> elzair: Have you looked at:
06:05:30 <merijn> @hackage monad-loops
06:05:31 <lambdabot> http://hackage.haskell.org/package/monad-loops
06:10:38 <sdegutis> It seems like mappend should have been named mcombine.
06:12:51 <merijn> Or just use the infix version :)
06:13:02 <merijn> :t (<>)
06:13:03 <lambdabot> Monoid m => m -> m -> m
06:13:38 <kstt> bgamari : ping
06:20:01 * hackagebot aeson-utils 0.3 - Utilities for working with Aeson.  http://hackage.haskell.org/package/aeson-utils-0.3 (AdamBergmark)
06:25:02 * hackagebot json-schema 0.7.3.1 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.7.3.1 (AdamBergmark)
06:27:11 <sdegutis> I'm really glad Haskell doesn't have variadic parameters or named parameters.
06:27:34 <wayne> sdegutis: why
06:27:51 <lpaste> Libby pasted ‚ÄúCabal test problems‚Äù at http://lpaste.net/119390
06:28:17 <sdegutis> Well previously I always insisted those be in a language I use. But in practice, my programs never use them. And their absence makes the language so much cleaner.
06:28:31 <sdegutis> (And easier to check types.)
06:28:31 <horrorcheck> hi, I'm having trouble with cabal test, when I run it is seems to be running the main program, not my tests?
06:28:45 <horrorcheck> That's my paste just a few lines up
06:29:22 <merijn> sdegutis: You can kinda fake it in horrible ways, but yeah
06:29:27 <sdegutis> :)
06:29:39 <sdegutis> It's fine to just create records if named things are *necessary*.
06:29:50 <merijn> See https://stackoverflow.com/questions/7828072/how-does-haskell-printf-work
06:29:55 <sdegutis> Their names can be bound via pattern matching, so it's really not costly to write.
06:29:55 <ski> light-weight record types would be handy ..
06:30:04 <sdegutis> ski: how is the existing not light-weight?
06:30:12 <ski> you have to declare them
06:30:31 <ski> (you don't have to declare tuple types, e.g.)
06:30:35 <merijn> Extensible records + rowtyping would be nice
06:31:02 <ski> for one-off record types, having to declare is too heavy
06:31:14 <sdegutis> ski: meh
06:31:19 <ski> (same goes for the case of variant types)
06:31:33 <tdammers> scoped data declarations would be nice
06:31:39 <kstt> ski: what type would an anonymous record have ?
06:31:45 <sdegutis> I haven't written any Haskell yet so I don't know if it's an annoying problem.
06:31:46 <tdammers> (cue someone to tell me the ghc extension that does that)
06:31:47 <ski> tdammers : yes, i've wanted that several types
06:32:05 <ski> kstt : like in Hugs TREX, or some other extensible record system, e.g.
06:32:28 <merijn> sdegutis: It's not that bad
06:32:30 <tdammers> I'm starting to think Haskell could benefit from more competing compiler implementations
06:32:34 <ski> kstt : in TREX `(x = 2,y = 3) :: (x :: Int,y :: Int)', e.g.
06:32:41 <kstt> ski: sorry, I don't know them.
06:32:45 <sdegutis> Yeah I doubt it would be.
06:32:49 <merijn> tdammers: I was talking about this with some of the Utrecht guys at NL-FP
06:32:53 <sdegutis> For instance, I'd just write a LoginParams record.
06:33:02 <kstt> Ok ski. Would that imply subtyping ?
06:33:09 <sdegutis> Can you use record syntax inline in an ADT?
06:33:15 <tdammers> merijn: cool... think I really should mingle a bit more in the local FP community
06:33:16 <ski> kstt : not necessarily. see row types
06:33:27 <merijn> tdammers: They don't have the manpower, I heard that a major refactor of their attribute grammars should soon make it easier to implement a lot of the more complex typing extensions GHC has
06:33:36 <tommyd> Hi everyone
06:33:43 <sdegutis> So that you can have either email & password, or openid-provider & openid-claimed-id & email?
06:33:44 <ski> sdegutis : that's the only place you can use it
06:33:45 <kstt> That's interesting, thank you ski.
06:33:46 <tdammers> merijn: the utrecht compiler that is, I assume?
06:33:48 <sdegutis> ski: oh right
06:33:54 <sdegutis> so nice.
06:34:02 <merijn> tdammers: But then someone still needs to do that and they don't have money to hire anyone to hack on UHC just for "engineering"
06:34:05 <merijn> tdammers: Yeah
06:34:10 <merijn> tdammers: There's also Mu
06:34:35 <merijn> tdammers: I've asked Lennart whether they'd consider open sourcing it, but last I heard he would like to, but the lawyers say "absolutely not"
06:34:41 <tdammers> merijn: yeah, hmm, I think there are plenty of academic implementations, what we're lacking is the manpower and grind work to pull them to the "industry strength" level
06:35:02 * hackagebot rest-core 0.34.0.3 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.34.0.3 (AdamBergmark)
06:35:04 * hackagebot rest-client 0.4.0.5 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.4.0.5 (AdamBergmark)
06:35:08 <tdammers> pfff... without open-sourcing it, it's not gonna happen, if you ask me
06:35:14 <ski> merijn : Lennart ?
06:35:22 <merijn> ski: augustss?
06:35:30 <ski> oh
06:35:39 <tdammers> developing a proprietary compiler to the kind of quality that GHC has would take googlean amounts of cash IMO
06:35:51 <ski> is `Mu' an implementation by augustss ?
06:36:08 <alpounet> yeah
06:36:17 <merijn> ski: Mu is the Standard Chartered proprietary strict Haskell compiler by Lennart (amongst others)
06:36:30 <alpounet> well, maybe other standard chartered guys work on it now, but Lennart started it.
06:36:37 <ski> ok
06:36:39 <merijn> tdammers: The main reason the lawyers say no is apparently, "what if someone uses it, something goes wrong and they sue us?"
06:36:45 <tdammers> oh boy
06:36:52 <merijn> That's what you get from lawyers at banks...
06:37:21 <tdammers> isn't that *exactly* what the "provided as-is, use at your own risk" clauses in every open source license ever are for?
06:37:21 <alpounet> I kind of hope https://github.com/Lemmih/lhc will be ready for real world usage some day
06:37:30 <merijn> tdammers: Yes
06:37:37 <tdammers> but oh well, lawyers gonna lawy
06:37:48 <Clint> you gotta ask the lawyers the right question
06:37:53 <Clint> and the right question is never "can we do this"
06:37:55 <tdammers> and besides, what if someone uses the proprietary compiler
06:38:40 <sdegutis> Are there any immutable databases in Haskell where a pure, in-memory variant exists for integration testing? i.e. operations return a new database
06:38:56 <sdegutis> Or at least are there such wrappers for interfaces to an external database (e.g. Postgres, MongoDB)?
06:39:15 <hvr> Clint: "can we do this" = "can you come up with a reason why we shouldn't"? :)
06:39:16 <tdammers> sdegutis: not that I know of... a typical approach is to use sqlite with an in-memory database
06:39:25 <tdammers> (passing ":memory:" as the filename)
06:39:33 <merijn> sdegutis: No, last year at NL-FP I heard about someone working on that, but I don't think that really exists yet?
06:39:38 <sdegutis> tdammers: but then that ties your production database to SQLite, no?
06:39:48 <sdegutis> merijn: aw
06:39:55 <tdammers> sdegutis: well, you have to use *something*
06:39:57 <merijn> sdegutis: Sure, but it'll be hard to have a good database without picking a specific one :p
06:40:10 <sdegutis> I've been doing this exact thing with Datomic for our Clojure web app, and it's spoiled me. But it's only for JVM.
06:40:13 <merijn> acid-state is a really nice "not-a-database" :)
06:40:26 <merijn> Yeah, datomic seems nice :)
06:40:43 <tdammers> that said, for my current side project, I first designed a backend-agnostic interface for "content queries" that abstracts over all sorts of storage strategies
06:40:51 <merijn> But you could easilly build something like datomic on top of a traditional database, no?
06:40:51 <tdammers> and then you hook that up with a storage provider
06:40:58 <sdegutis> tdammers: did you provide an in-memory implementation?
06:40:58 <tdammers> one of those is just an in-memory hash map
06:41:02 <tdammers> so yeah
06:41:06 <sdegutis> merijn: that's what Datomic is.
06:41:21 <sdegutis> tdammers: that sounds sweet -- did you open sauce it?
06:41:24 <tdammers> or rather, the in-memory storage provider has optional file-based persistence (dump everything into one large JSON file)
06:41:24 <merijn> sdegutis: ok, then it's basically: "No one bothered to write it yet"
06:41:30 <sdegutis> merijn: lol ok
06:41:35 <tdammers> not yet, but probably will at some point
06:42:28 <sdegutis> What kind of performance does a typical Haskell app have, in terms of other languages? C? Java? C++? Ruby?
06:42:38 <sdegutis> (Speed, not memory.)
06:43:34 <tdammers> if you do it right, you can play in the "pretty damn close to C" league
06:43:35 <sdegutis> Sorry, that's weirdly worded.
06:43:48 <sdegutis> tdammers: wow -- but does that require a lot of non-idiomatic hackery?
06:43:49 <tdammers> hard to compare though
06:43:49 <speak> sdegutis: You can't define speed for a language in a broad sense, you must ask for specific use cases
06:44:02 <tdammers> it *really* depends on the use case
06:44:16 <sdegutis> Well do you happen to have an example off-hand?
06:44:24 <sdegutis> (of a specific case)
06:44:34 <merijn> sdegutis: Yes, although that did require a bunch of hackery
06:44:36 <speak> sdegutis: But wait, what are you thinking of coding in the first place? You must have some reason to ask?
06:44:48 <merijn> sdegutis: http://www.serpentine.com/blog/2014/05/31/attoparsec/
06:44:56 <sdegutis> speak: I write lots of different things, so any use-case would be relevant.
06:45:01 <tdammers> anecdotically, the aforementioned side project of mine can serve a complete HTML page over HTTP, with templates and data retrieval and all, in under 2 milliseconds
06:45:15 <sdegutis> speak: web apps, desktop apps, command line utilities, back-end services, etc
06:45:16 <tdammers> and I haven't even started optimizing things yet
06:45:33 <merijn> sdegutis: A 65 line naive haskell HTTP parser using attoparsec outperforms Ryan Dahl's handwritten 2400 line C monstrosity ;)
06:45:37 <sdegutis> tdammers: nice
06:45:38 <speak> sdegutis: Yeah that's just it, for most of that stuff, the speed of the language is nearly irrelevant
06:45:49 <sdegutis> merijn: wow
06:46:03 <tdammers> of course, most of that performance is due to the way I set things up, rather than some magical property of the language
06:46:07 <sdegutis> speak: sure, but a nice ballpark doesn't hurt
06:46:07 <merijn> sdegutis: I would estimate haskell around "Java/C# with outliers towards C levels" depending on how genious you are at optimising
06:46:22 <speak> sdegutis: Then the answer to your question would be "fast enough"
06:46:23 <sdegutis> tdammers: in what way did you set it up specifically?
06:46:32 <merijn> sdegutis: The more important thing is the ability to have ridiculously optimised libraries like attoparsec that provide a high level interface
06:46:34 <sdegutis> merijn: that's totally reasonable
06:46:35 <tdammers> I'm using an STM-based in-memory database
06:46:48 <tdammers> that's blazing fast simply because it's all in RAM, no disk I/O involved
06:46:54 <tdammers> then, I use precompiled templates
06:46:55 <sdegutis> speak: well that's better than many languages for often that's not true, i.e. Ruby
06:47:04 <tdammers> as in, the templates are compiled to machine code and linked into the binary
06:47:05 <merijn> sdegutis: i.e. attoparsec is absurdly optimised by bos, but that means that the rest of us have a superfast high level parsing library :)
06:47:15 <tdammers> so no disk I/O for that, either
06:47:16 <merijn> So we don't have too ;)
06:47:22 <speak> sdegutis: I'm not too familiar with Ruby, but could it not even in Ruby's case be more of a problem with the framework ecosystem?
06:47:29 <sdegutis> merijn: so awesome
06:47:33 <sdegutis> tdammers: ah neat
06:47:47 <tdammers> of course I could do the same in C++, but it would be several orders of magnitude more difficult
06:47:57 <tdammers> and I'd produce a dozen or so bugs per day
06:47:58 <sdegutis> speak: there are *many* reasons Ruby is slow -- in fact, they act as a Product type
06:48:01 <merijn> sdegutis: I recommend checking out that blogpost, especially comparing the Haskell source vs C :)
06:48:13 <sdegutis> speak: i.e. combining them all explains why Ruby is *so* slow
06:48:30 <tdammers> so it's not really that Haskell is faster; the competitive advantage for me is that it makes all these nice fast strategies easier by giving me powerful abstractions
06:48:41 <merijn> speak: The design of Ruby the language makes optimising it a nightmare, so part of it is definitely the language
06:48:52 <sdegutis> So, would you all say that Haskell allows you to be very productive while fast in writing code?
06:49:13 <merijn> sdegutis: Once you get over the initial (admittedly a bit large) hump, yes
06:49:16 <speak> Ah right, gotcha sdegutis & merijn
06:49:22 <tdammers> pretty much, yes. although there are a few nasty edge cases that can ruin performance, occasionally
06:49:33 <speak> merijn: "Bit large" is putting it lightly!!
06:49:39 * speak is still in the root of the mountain
06:49:44 <speak> *base
06:49:47 <merijn> sdegutis: Getting productive in haskell took MUCH longer than, say python, but now I would say I'm A LOT more productive than I ever was
06:50:00 <sdegutis> Is interpreting a Haskell program (during development) significantly faster than compiling it into a binary (which I hear can take up to a minute in the app I'm going to write)?
06:50:03 <merijn> Well, maybe only a little, because I waste too much time fiddling with fancy typing :p
06:50:32 <sdegutis> Thanks for all your answers to my stupid questions everyone.
06:50:40 <tdammers> thing is, python, ruby, e.a., optimize for the first few weeks of the learning curve
06:50:42 <merijn> sdegutis: The solution is to use -O0 (unoptimised) for compiling during testing/development and only use -O2 for performance testing
06:50:42 <sdegutis> I hope I asked them well and didn't annoy :)
06:50:48 <tdammers> haskell optimizes for the years after that :D
06:50:53 <sdegutis> merijn: ah
06:51:04 <sdegutis> tdammers: excellent analogy
06:51:14 <merijn> sdegutis: cabal (which you should really use to build anything bigger than a single module, and possibly even then ;)) does incremental compilation
06:51:21 <merijn> sdegutis: So only changed modules get recompiled
06:51:32 <sdegutis> merijn: oh niiiice
06:51:38 <sdegutis> I heard that phrase but didn't know what it meant until now.
06:51:43 <sdegutis> You all are the best community, I tell you.
06:51:44 <merijn> Unlike C/C++, where the lack of module system makes that impossible
06:52:04 <sdegutis> Not the arrogant pricks many people I know made you out to be last year.
06:52:17 <merijn> #haskell is love :)
06:52:32 <merijn> Tell them to visit ##c ##c++ and look who's the arrogant pricks then >.>
06:52:41 <sdegutis> merijn: re: the module thing, that's one thing I liked about Swift, but it didn't quite get fully right.
06:52:42 <merijn> Actually, don't. You might get PTSD from those two
06:52:52 <tdammers> try ##php and tell them how PHP doesn't support strings or arrays
06:53:20 <speak> sdegutis: A lot of people will call multiple help channels I frequent arrogant pricks, but so often I see newbies coming in with a very aggressive arrogant attitude, and when the community doesn't cater to that, they will quit in an angry manner and go rant somewhere about it
06:53:21 <sdegutis> Well regardless of other communities, you guys are nice is all I'm saying :)
06:53:30 <merijn> tdammers: ##php is just people who are clueless. ##c and ##c++ is people who ARE knowledgeable, but like a possessive dragon would rather maul you than share/explain :)
06:53:46 <speak> Haha
06:55:04 <tdammers> merijn: point in case.
06:55:20 <clrnd> I'm an arrogant prick, don't talk for all of uss dog
06:55:26 <sdegutis> Is there a way to write this without the outside parens?  map ((3>) . length) $ ["a", "ab", "abc", "abcd"]
06:56:10 <merijn> sdegutis: split it out into a let/where
06:56:23 <sdegutis> Aw, I was hoping for some clever trick like there usually is.
06:56:29 <sdegutis> Oh well, not that bad overall.
06:56:37 <merijn> Anything else will probably just make it worse :)
06:56:49 <merijn> sdegutis: Actually
06:56:50 <speak> clrnd: Oops sorry, well to be fair I am as well
06:56:53 <sdegutis> Without (3>) it's actually not that bad.
06:56:54 <alpounet> sdegutis: you can get rid of $ though
06:56:56 <merijn> sdegutis: Your $ is redundant
06:57:17 <sdegutis> True.
06:57:22 <bergmark> >  (3>) . length <$> ["a", "ab", "abc", "abcd"]
06:57:24 <lambdabot>  [True,True,False,False]
06:57:26 <sdegutis> Okay, gonna finish reading about Monoids now.
06:57:31 <sdegutis> bergmark: woo!
06:57:44 <ski> > [3 > length xs | xs <- ["a","ab","abc","abcd"]]  -- only square brackets
06:57:46 <lambdabot>  [True,True,False,False]
06:57:52 <clrnd> >  (3>) . length <$> Just "lalala"
06:57:53 <lambdabot>  Just False
06:58:53 <merijn> > do x <- ["a","ab","abc","abcd"]; return $ 3 > length x -- look ma, no parens!
06:58:55 <lambdabot>  [True,True,False,False]
06:58:58 <ab9rf> heh
06:59:15 <bramgg> Is it possible to run haskell code in string format with runhaskell?
06:59:20 <ski> @google baker look ma no garbage
06:59:21 <lambdabot> http://www.cs.utexas.edu/~hunt/research/hash-cons/hash-cons-papers/BakerLinearLisp.ps
06:59:23 <bramgg> (rather than passing along a file location)
06:59:37 <clrnd> bramgg, cat file.hs | runhaskell
06:59:51 <alpounet> bramgg: ghc has a -e option to evaluate expressions directly from the command line, fwiw
06:59:53 <bramgg> time to learn linux
06:59:55 <bramgg> thanks guys
06:59:58 * merijn awards clrnd the "Useless Use of Cat"-award
07:00:11 <alpounet> e.g, ghc -e '1+1'
07:00:22 <alpounet> i'll let you guess the result
07:00:23 <alpounet> =)
07:01:02 <bramgg> alpounet: Come on, I'm new here!
07:01:24 <ski> bramgg : welcome
07:01:34 <bramgg> alpounet: can that method be used to run full programs?
07:01:44 <geekosaur> that'd be runghc
07:01:54 <geekosaur> (aka runhaskell)
07:02:01 <bramgg> okay, thanks all
07:02:04 <alpounet> yeah, runhaskell is better for that
07:02:17 <iLike> merijn, can I PM you with a quick question (not relating to haskell)?
07:02:18 <alpounet> -e is fine for when you want to evaluate a tiny expression that fits in one line
07:03:12 <clrnd> is there any FP style shell? one with lambdas for example
07:03:50 <ski> scsh, perhaps
07:04:35 <alpounet> clrnd: there's https://github.com/chrisdone/hell but not sure how polished it is
07:05:12 <clrnd> alpounet, I tried hell it didn't work, and when I fixed I didn't like it :P
07:05:25 <alpounet> hah
07:05:44 <bgamari> kstt, pong
07:06:09 <clrnd> scsh looks promising, but I was looking for something just like BASH but with lambdas and high order functions
07:06:19 <alpounet> clrnd: well, i think there's room for improvement there indeed, maybe you should toy around with an impl of your own that has what you want :)
07:06:30 <tdammers> bash has higher-order functions, in a crude way
07:07:06 <merijn> iLike: Sure?
07:11:32 <sdegutis> I can almost imagine an immutable database written in pure Haskell, where a all operations on the database are pure and return a new database, and where you can "apply" a database to disk via an IO action which just reads the database from disk and creates a "diff action" from it using the one you have now (creating this could also be pure), and applies that diff action to disk. Does this sound feasible?
07:12:34 <geekosaur> feasible to implement, not very usable though
07:16:27 <sdegutis> Why not geekosaur?
07:17:13 <geekosaur> well, I suppose it depends on what you want to use it for. that design is not going to work very well for large amounts of data or high data volume
07:17:17 <sdegutis> I guess applying actions in-memory without applying them to disk might be troublesome if the application to disk fails.
07:17:26 <sdegutis> geekosaur: ahh good point
07:17:29 <sdegutis> Thanks.
07:17:39 <geekosaur> unless you can size main memory to match the database... good luck with that 100TB data store
07:25:04 * hackagebot heist 0.14.1 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.14.1 (DougBeardsley)
07:28:56 <grohne> is there a way to discover (hackage library defined) types that are instances of two given type classes simultaneously?
07:32:02 <tomphreek> fmap (liftA (*2)) $ sequence [Just 1, Just 3]
07:32:10 <tomphreek> is there a better way?
07:32:43 <merijn> I don't think sequence is what you want? Do you want to throw away the entire list if there's a Nothing?
07:32:50 <bramgg> What's up with modules making me use Text instead of String?
07:33:05 <merijn> bramgg: Text has mad performance, String does not
07:33:36 <bramgg> merijn: if that's the case why doesn't String just sort of become Text?
07:33:48 <merijn> bramgg: String is literally a linked list of Char. It may (depending on architecture) up to 20 bytes per Char.
07:33:57 <merijn> bramgg: Because String is good at some things that Text is not
07:34:07 <bramgg> hm, thanks
07:34:16 <tomphreek> merijn: Indeed, want to keep Nothing
07:34:24 <merijn> bramgg: If you're dealing with text files, large amounts of plain text, etc. you probably wanna use Text
07:34:56 <merijn> bramgg: Text uses like 2-3 bytes per codepoint (plus some overhead per block of several kb)
07:35:48 <zwer_h> tomphreek not sure if that counts as better, but that liftA could have just been map
07:36:01 <bramgg> merijn: but if I have to convert my would-be strings to texts in my code where does the performance buff come in?
07:37:00 <merijn> bramgg: String is mostly used for short values and quick pattern-matching manipulation, if you're reading from a file you would usually just read ByteString/Text directly
07:37:31 <bramgg> ah okay, thanks
07:38:02 <zwer> > map (*2) <$> sequence [Just 1, Just 3]
07:38:03 <lambdabot>  Just [2,6]
07:38:12 <merijn> bramgg: For example, both the text/bytestring libraries have their own readFile functions that return the appropriate datatype instead of String
07:39:16 <merijn> bramgg: The basic logic is: ByteString for binary data/blobs/network/etc., Text for textual data/performance sensitive stuff, String for things that are rarely used/not performance critical/use pattern matching/etc.
07:39:34 <elzair> Hey, I was still having some problems executing a list of commands.
07:39:49 <elzair> Here is a gist of the current code: https://gist.github.com/Elzair/3aa4477c83640d688f43
07:39:58 <bramgg> merijn: thanks, that all cleared up a lot of confusion
07:40:00 <elzair> Specifically, the runCommands function
07:40:24 <merijn> bramgg: Yeah, the naming of ByteString is a bit of an unfortunate incident that tends to confuse people too
07:40:43 <merijn> bramgg: It should really just be "Bytes", but changing it now would break EVERYTHING that uses them
07:40:51 <merijn> So that's never happening
07:40:58 <merijn> Blame history >.>
07:43:25 <elzair> I assume I need to lift the results into the IO monad or something like that.
07:46:08 <tomphreek> zwer, merijn wonderful. thanks
07:47:35 <elzair> Should I use ioEitherToEitherT from transformers-convert?
07:47:57 <merijn> I don't think you need that...
07:48:04 <merijn> :t ExceptT
07:48:05 <lambdabot> Not in scope: data constructor ‚ÄòExceptT‚Äô
07:48:08 <merijn> hmm
07:48:20 <merijn> oh, that's new in transformers, I guess
07:48:45 <merijn> :t ErrorT
07:48:46 <lambdabot> m (Either e a) -> ErrorT e m a
07:48:56 <merijn> Doesn't that already do what you want?
07:49:21 <merijn> :t ErrorT `asAppliedTo` (undefined :: IO (Either String Bool))
07:49:22 <lambdabot> IO (Either String Bool) -> ErrorT String IO Bool
07:49:46 <elzair> The error I am getting is "Expected Type: EitherT a m [Either String b0] Actual Type: IO [Either String ()]"
07:49:59 <elzair> This is for the forM
08:00:06 * hackagebot handsy 0.0.5 - A DSL to describe common shell operations and interpeters for running them locally and remotely.  http://hackage.haskell.org/package/handsy-0.0.5 (utdemir)
08:07:51 <simon> msum :: MonadPlus m => [m a] -> m a, since the list could be empty, but is there a built-in that works for regular monads?
08:08:44 <bitemyapp> simon: regular monads?
08:08:59 <indiagreen> do you mean sequence?
08:09:01 <indiagreen> :t sequence
08:09:02 <lambdabot> Monad m => [m a] -> m [a]
08:09:08 <bitemyapp> indiagreen: or join, maybe.
08:09:24 <indiagreen> it returns a list, but, well, what else can you do for arbitrary monads
08:09:24 <bitemyapp> I wanted to pin down what type they wanted.
08:10:06 * hackagebot stm-containers 0.2.8 - Containers for STM  http://hackage.haskell.org/package/stm-containers-0.2.8 (NikitaVolkov)
08:14:46 <indiagreen> bitemyapp: since you've got much more experience with <teaching> and stuff than me, a question: should I attempt to teach people who ask for functions on #haskell how to use Hoogle instead, or am I just suffering from the ‚Äúhoogle is the best way for me so it should be inherently the best way for everyone else too‚Äù typical mind fallacy?
08:16:24 <bitemyapp> indiagreen: give Neil time to release the new hoogle, then promote it more prolifically.
08:16:44 <bitemyapp> indiagreen: the current Hoogle doesn't cast a wide enough net and people will get confused when they can't find what they want, the new Hoogle should fix that.
08:17:09 <bitemyapp> indiagreen: Hoogle's type-similarity algo has confused some people. I think awareness of Hoogle is good, just they shouldn't expect it to be perfect.
08:21:16 * geekosaur finds (a full) hoogle good for some things, hayoo for others. maybe we need a hogpile... >.>
08:22:08 <indiagreen> bitemyapp: okay, thanks, good point about the new hoogle and confusion. Another question while I'm at it: is it a good idea to create a locally available tool like lambdabot's @src which would give both ‚Äúteaching‚Äù and actual (explained when needed) definitions of functions, along with comments like ‚ÄúGHC's version differs from the one in Haskell Report‚Äù, etc.?
08:24:37 <bitemyapp> indiagreen: it'd be a lot of thankless work. I don't know.
08:26:16 <platz> maybe I should try to make a lambdabot docker image
08:27:06 <bitemyapp> platz: lambdabot *is* pretty hard to install at the moment.
08:27:18 <platz> seems like a use case docker might actually be useful for
08:27:29 <zwer> what will new hoogle do that the current one doesn't?
08:27:31 <platz> keeping it up to date would be another matter
08:27:40 <zwer> will it be able to compose functions to get the desired one?
08:28:08 <zwer> (that would be neat)
08:28:35 <merijn> zwer: It will index more of hackage
08:28:52 <chpatrick> zwer: that sounds pretty NP-complete
08:29:20 <tommd> merijn: But that's more of a deployment issue.
08:30:14 <platz> there is https://registry.hub.docker.com/u/wting/lambdabot/ but totally void of documentation
08:30:25 <merijn> tommd: Not just
08:30:56 <tommd> merijn: Could you explain?  You could index all of Hackage with hoogle 4.
08:31:46 <tommd> zwer: http://neilmitchell.blogspot.com/2015/01/hoogle-5-is-coming.html  -- in case you hadn't seen it, I'm figuring you have and hence the question.
08:32:14 <vektor> so... in haskell, in a do block for a IO Something function, how can I execute a IO () function? just calling it type errors because IO() doesn't match IO Something.
08:32:53 <tommd> vektor:  operOfTypeIOUnit >> operOfTYpeIOSomething
08:33:08 <tommd> Your do block must return at `Something` at the end and not a `()`.
08:33:09 <Hijiri> also it's important to note that "IO a" isn't a function type
08:33:20 <Hijiri> all functions have a type of form "a -> b"
08:34:11 <vektor> sounds like it'd work.
08:34:29 <merijn> vektor: Can you show a minimal example?
08:35:16 <zwer> tommah thanks, I havent actually. I heard about "new hoogle" in here a couple of minutes ago
08:35:39 <Welkin> Hijiri: is it even useful to make the dinstinction between a function and a computation then?
08:35:49 <Welkin> why not just refer to everything as a computation?
08:36:00 <Hijiri> because then you can't talk about the differences
08:36:03 <merijn> Welkin: It is, because that's fundamentally what makes haskell pure
08:36:22 <merijn> Welkin: The inability to execute actions from within haskell
08:36:47 <Welkin> a -> b is a computation that takes a computation
08:36:54 <Welkin> IO a is a computation
08:36:54 <merijn> No
08:37:14 <merijn> "a -> b" is a function that, when applied to a value, evaluates to another value
08:37:23 <merijn> This is observable inside haskell
08:37:25 <vanila> a -> b is the type of a function
08:37:54 <vektor> merijn: I need to call writeFile in a do notational block in a IO Something function.
08:37:56 <merijn> "IO a" is an action, that when executed produces an 'a', executing actions can't be done inside haskell
08:37:57 <Welkin> then what is the difference between a function and a computation?
08:38:18 <merijn> Welkin: Fuctions have inputs and the resulting evaluation depends *only* on that input
08:38:30 <Hijiri> maybe it's better to talk about the difference between IO type and functions
08:38:34 <merijn> Welkin: actions/computation/whatever don't have inputs and their results are unpredictable
08:38:35 <Hijiri> because computation is pretty general
08:38:40 <Hijiri> and could probably describe anything
08:38:44 <Welkin> what about a -> b vs just a
08:38:59 <merijn> 'a' is a value
08:39:28 <Welkin> how is the result unpredictable?
08:39:53 <Welkin> someValue :: Int; somValue = 5
08:39:53 <merijn> Welkin: What would you predict the result from?
08:40:04 <merijn> That's not an IO action, though
08:40:06 <Welkin> by executing the computation
08:40:12 <Hijiri> I think Welkin is using "computation" in some kind of nebulous non specific way
08:40:27 <Hijiri> everything you do on the computer is a computation
08:40:32 <vektor> merijn: So I obviously don't care about the return type of that call, but haskell does.
08:40:36 <Hijiri> so everything is computations
08:40:40 <Hijiri> is that a good answer?
08:40:50 <merijn> Welkin: In haskell there is a clear distinction between "evaluation" (i.e. reducing haskell terms) and "execution" (i.e. executing IO actions)
08:41:05 <barrucadu> vektor: do ...; my thing :: IO (); ...
08:41:19 <merijn> vektor: I can't say without seeing code
08:43:17 <Welkin> so is IO the only unpredictable computation in haskell?
08:43:43 <merijn> Barring use of unsafeX, yes
08:45:08 * hackagebot tasty-program 1.0.2 - Use tasty framework to test whether a program executes correctly  http://hackage.haskell.org/package/tasty-program-1.0.2 (JanStolarek)
08:45:12 <Welkin> is there something special about IO that doesn't apply to other typeclasses?
08:45:21 <vektor> something like this: http://lpaste.net/119409
08:45:54 <Welkin> er, other monads
08:46:13 <Hijiri> special in what way?
08:46:26 <Hijiri> the other monads have their own differences
08:46:39 <geekosaur> only insofar as a decision was made to sequester all the weird non-local stuff in IO
08:46:45 <Hijiri> I think conal said it's impossible to prove correctness of the IO monad because you can't prove that two programs are the same
08:46:52 <geekosaur> you could conceivably split it up, but why?
08:46:55 <Hijiri> or something like that, I might be wording it wrong
08:47:18 <Welkin> with regard to IO being unpure
08:47:36 <joness> IO is not unpurr
08:47:40 <joness> unpure
08:48:17 <merijn> IO is pure, that's why we jump through the hoops
08:48:34 <sandhu> Test
08:48:35 <merijn> IO could work the exact same way as it does now without Monads
08:48:39 <Welkin> how is it pure?
08:49:01 <merijn> Welkin: Because it's not a function, functions always return the same output when given the same input
08:49:01 <Welkin> getLine produces different results every time
08:49:07 <ski> no
08:49:16 <joness> is "print 10 strings" unpure just because you can write a runtime that parses that string and prints 10 strings?
08:49:32 <merijn> Welkin: "getLine" is a value, specifically, it's "an IO action that says how to read a line from stdin"
08:49:40 <ski> `let act = getLine in do x <- act; y <- act; foo x y' is equal to `do x <- getLine; y <- getLine; foo x y'
08:49:51 <merijn> Welkin: It is always the SAME IO action, because the instructions to read a line are always the same
08:50:15 <ski> you can "replace equals for equals", regardless whether the expression has a type involving `IO' or not
08:50:20 <merijn> Welkin: To actually *read* a line you would have to execute it. But there's no way in haskell to execute IO actions
08:50:38 <Welkin> where do the IO actions get executed?
08:50:45 <Hijiri> it's pure the same way a ruby script sitting on your harddrive is pure
08:50:45 <merijn> Welkin: Haskell is a pure language for composing small IO actions into bigger IO actions. The end result is one big IO action called "main"
08:50:54 <ski> `main' is executed when the program starts
08:50:55 <Hijiri> it doesn't do anything until someting picks it up and executes it
08:50:57 <merijn> Welkin: The haskell runtime system then executes it
08:51:22 <merijn> Meaning the runtime isn't pure, but that's ok. The *language* is and that's what makes it easy to reason about the code
08:51:28 <geekosaur> Welkin, you can think of it as the function main generates a chain of I/O actions, which are passed back to something that runs them
08:51:55 <Welkin> okay, that makes more sense
08:51:56 <geekosaur> and the key to Haskell purity is that you can't get at that thing that runs them; only manipulate instructions to it
08:53:28 <ski> (imho, "pure" applies to languages, not to implementations)
08:53:59 <merijn> ski++
08:54:39 <Welkin> well, a computer fundamentally mutates state
08:54:56 <Welkin> so the implementation can never be pure
08:55:08 * hackagebot tasty-hunit 0.9.1 - HUnit support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hunit-0.9.1 (RomanCheplyaka)
08:55:10 * hackagebot grid 7.7.0 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.7.0 (AmyDeBuitleir)
08:55:14 <ski> the implementation may use mutation, that's different
08:55:17 <geekosaur> and, while for various practical reasons IO is not generally implemented this way, there's no particular reason that we couldn't define IO as an ordinary type whose constructors represent various I/O actions. so getLine :: IO String would actually refer to a data constructor representing the action
08:55:57 <ski> what matters about "purity" is reasoning power of the language : like what refactoring laws hold, how you can deduce properties of your program, &c.
08:55:57 <elzair> Isn't a "variable" simplfy a function that takes no arguments and returns a result?
08:56:04 <elzair> *simply
08:56:05 <Welkin> I guess it's helpful to think about them as two separate worlds, one pure, one unpure
08:56:25 <ski> elzair : no, a variable is a name for something (e.g. a value)
08:56:27 <Welkin> with the runtime as the link between them
08:56:44 <joness> Welkin it is a fun excercise to write your own IO-like type that can only print to stdout and read from stdin. you can then write a monad instance for it, to demonstrate that when you use a do block or >>= youre just build a new datastructure out of existing ones
08:56:56 <elzair> I guess it would not be in mathematics. I was not sure how Haskell handled it.
08:57:07 <ski> you can only talk about "unpure" if you talk about a specific language -- and possibly it has to in some sense be expression-oriented
08:57:09 <elzair> So "let x = 2" creates a variable x of value 2
08:57:54 <Hijiri> names of things in haskell represent the thing itself, not the computations needed to produce them
08:57:58 <Hijiri> so I wouldn't call that a function
08:58:18 <ski> .. anyway, i must run, can't stay and try to explain atm :(
08:58:34 <Hijiri> unless the name was bound to something that was a function
08:58:50 <elzair> Hmm, how many namespaces does Haskell have?
08:59:00 <Welkin> here is another way to think about it
08:59:01 <Hijiri> haskell namespacing is based on modules
08:59:03 <sdegutis> Is Haskell almost always the final destination of nomadic polyglots?
08:59:15 <Welkin> (->) is the constructor for a function
08:59:21 <Hijiri> you can import a module so that everything is in the top namespace, or with a qualified name
08:59:26 <zaphix> Anyone using persistent-postgresql know how to declare a column of postgres 'serial' type? I can't seem to figure out how it's done (if it's even possible to do so)
08:59:33 <sdegutis> I learned a ton of languages and ended up here, although I can't be sure I won't move on to a better language after Haskell, if one exists.
08:59:47 <Hijiri> you can import something with a shorter namespace too, ie import qualified Data.List as L
08:59:52 <vanila> nope, haskell is the best :D
08:59:55 <Hijiri> and then you would get L.split, L.etc
09:00:09 * hackagebot som 7.5.0 - Self-Organising Maps.  http://hackage.haskell.org/package/som-7.5.0 (AmyDeBuitleir)
09:00:27 <Welkin> is this a reasonable approach?
09:00:39 <sdegutis> vanila: lol
09:00:44 <Hijiri> (->) is a type contructor, if that's what you mean
09:00:48 <Welkin> yes
09:01:01 <sdegutis> Do people ever leave Haskell and come back to tell you they found an even better language?
09:01:24 <indiagreen> sdegutis: some of them even create their own better languages
09:01:24 <chpatrick1> sdegutis: dependent typing people :P
09:01:29 <indiagreen> yep, them
09:01:34 <sdegutis> Oh.
09:01:46 <Welkin> sdegutis: there are several morep owerful languages than haskell, but none that have the support and mass of practical libraries of haskell
09:01:47 <sdegutis> Have any such languages begun to seriously take off?
09:01:52 <chpatrick1> not yet
09:01:57 <elzair> Can you make a Turing complete language with dependent types?
09:02:06 <josephle> why not?
09:02:07 <sdegutis> Then Haskell it is. Thanks.
09:02:14 <vanila> elzair, you could but the type system might suffer
09:02:57 <koomi> most dependently-typed languages are turing complete
09:03:01 <indiagreen> Idris, Qi, Omega, Shen, Agda are all examples of languages which can be said to be more powerful or conceptually better than Haskell, but the thing is that at this point it's not about just being more powerful anymore
09:03:54 <indiagreen> it's about finding the balance between being powerful and having e.g. sane error messages, type inference, and some nice abstractions which you probably can lose if you have too much power
09:04:17 <elzair> Agreed
09:04:21 <joness> agda and idris are not turing complete, correct?
09:04:23 <vanila> koomi, usually a deptype language wants 'strong normalization' where every program terminates
09:04:29 <vanila> in that case they aren't turing complete
09:04:43 <koomi> indiagreen: and then there is the question if all that is actually usefull for solving problems of practical programming
09:04:56 <koomi> joness: both are
09:05:05 <sdegutis> Wait a minute, someone told me (fn x f = f x) didn't exist and was coming soon as &, but it's (-:) in LyaH -- what gives?
09:05:22 <dredozub-> joness: why do you think they aren't?
09:05:23 <elzair> Doesn't turing incompleteness cause parsing issues?
09:05:24 <indiagreen> sdegutis: it's just a operator which LYAH defined
09:05:24 <koomi> vanila: a non-turing complete language is total
09:05:28 <sdegutis> Oh.
09:05:29 <koomi> err, can be
09:05:31 <Welkin> sdegutis: the author in LYAH defined that himself
09:05:35 <sdegutis> Dang.
09:05:37 <Welkin> you can define your own as well
09:05:40 <sdegutis> Sure, sure.
09:05:44 <sdegutis> What's the most common name for it?
09:05:54 <Welkin> &
09:06:01 <sdegutis> To mirror $ ?
09:06:04 <indiagreen> you should use (&) because it's going to be the official name anyway
09:06:06 <Welkin> that is what is used in lens
09:06:09 <sdegutis> Deal.
09:06:20 <koomi> vanila: https://github.com/wouter-swierstra/Brainfuck
09:06:21 <joness> dredozub they are total.. they dont allow unrestricted recursion
09:06:34 <koomi> joness: idris is not even total
09:06:45 <joness> agda?
09:07:00 <koomi> it has an optional totality checker that last I checked was broken
09:07:02 <koomi> agda is total
09:07:16 <vanila> koomi, yeah I think you are confused
09:08:15 <koomi> vanila: what I wanted to say earlier was: a turing-complete language can be total
09:08:24 <vanila> it cannot
09:08:37 <koomi> it can, I just showed you a link to a brainfuck interpreter in agda
09:08:54 <vanila> that give a coinductive stream of execution
09:09:57 <koomi> yes, so?
09:10:13 <koomi> it's a simulation of a turing-complete language in a total language
09:10:23 <vanila> yes
09:10:34 <vanila> you can model turing complete languages inside a dependently typed language
09:10:38 <vanila> but it is not itself turing complete
09:12:14 <elzair> mind = blown
09:12:26 <chpatrick> how can you have a total simulation of something which you can't prove is total?
09:12:31 <koomi> if a language can simulate a turing-complete language, it's turing-complete
09:12:34 <barrucadu> koomi: All Agda programs halt, right?
09:12:38 <koomi> no
09:12:45 <vanila> a total language cannot be turing complete because all functions halt - but remember that the halting problem is undecidable
09:12:53 <koomi> barrucadu: that would be a thoroughly useless language
09:12:59 <indiagreen> chpatrick: easy, if you execute by steps and promise to stop after N steps
09:13:05 <koomi> totality does not mean termination
09:13:21 <vanila> koomi, you cannot actually write an interpreter for a turing complete language in a total language like this. You can write a 'single step' function and run it 'n' times, or produce a coinductive execution trace - but that is not the same thing
09:14:00 <koomi> it is not hard to write a non-halting function in agda at all
09:14:19 <vanila> the class of functions N -> N that you can implement in Coq or agda or similar is smaller than the class of functions you can implement in haskell
09:14:30 <tasker> What are my options for sorting Vector Int  ?
09:15:34 <MagneticDuck> I can't find any documentation on that Paths_hoogle thing mentioned http://neilmitchell.blogspot.pt/2008/02/adding-data-files-using-cabal.html here
09:15:49 <koomi> vanila: https://lists.chalmers.se/pipermail/agda/2011/003293.html
09:15:52 <elzair> indiagreen: how is Shen more powerful than Haskell?
09:15:57 <koomi> here you have it from conor mcbride
09:16:13 <alpounet> tasker: the vector-algorithms package
09:16:16 <indiagreen> elzair: I think it has a more powerful type system, tho I might be wrong
09:16:25 <vanila> koomi, That doesn't address any of the points I made
09:16:38 <alpounet> MagneticDuck: https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code ?
09:16:52 <elzair> indiagreen: I have heard that too.
09:17:02 <elzair> I wonder if anyone can elaborate?
09:17:08 <koomi> vanila: that brainfuck simulation gives an *unbounded* number of steps, that is exactly the purpose of a coinduction
09:17:32 <koomi> vanila: if I feed it a brainfuck programm that does not halt, neither will the simulation
09:17:51 <barrucadu> It will, because it's coinductive. It will only evaluate as much as you need
09:18:17 <MagneticDuck> alpounet: cool, it's that
09:18:20 <tasker> alpounet: Cheers.
09:18:27 <vanila> koomi, it is equivalent to saying 'compute n steps' of this interpreter, where each step is a total function
09:18:50 <vanila> koomi, to be turing complete you need to be able to do something like mu-minimization to get the final answer (or infinite loop if there isn't one)
09:18:54 <mmachenry> I'm confused about why this program doesn't run out of memory. http://lpaste.net/119414 Is GHC being smart and evaluating thunks instead of being lazy?
09:19:28 <mmachenry> When I run that and watch the top command, memory for that process grows and shrinks within a reasonably small bound.
09:19:41 <elzair> I found a good discussion of Idris vis a vis totality and Turing completeness at http://cs.stackexchange.com/questions/19577/what-can-idris-not-do-by-giving-up-turing-completeness
09:20:10 * hackagebot io-streams 1.2.1.2 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.2.1.2 (GregoryCollins)
09:20:16 <MagneticDuck> alpounet: darn, but now ghc-mod is confused :(
09:20:18 <MagneticDuck> oh well
09:21:05 <alpounet> mmachenry: that's because the 0's from 'repeat 0' are produced as f needs them. f 'drives the evaluation' so to speak
09:21:11 <vanila> koomi, did you get what I was saying about the functions N -> N you can implement in Coq/Agda2 vs haskell?
09:21:36 <koomi> vanila: I don't think it is true
09:21:39 <josephle> vanila: can't you represent the naturals as a stream and therefore get totality that way?
09:21:41 <vanila> it is true
09:22:10 <alpounet> mmachenry: f (repeat 0) 0  ==> f (0:repeat 0) 0  ==> f (repeat 0) (0+0)  ==> f (0:repeat 0) (0+0)  ==> f (repeat 0) (0+0+0) and so on
09:22:11 <josephle> then you can do an unbounded search over the stream of naturals
09:22:13 <superlinux-hp> hi. Has any of you tried "raskell", an app on iPad?  it's hugs98 on iPad + an editor too
09:22:34 <alpounet> mmachenry: f only needs to evaluate the list one element at the time, so they are produced as f needs them
09:23:07 <vanila> koomi, Every function f : N -> N that you implement in Coq or agda has to be constructed in such a way that its termination is justified by the proof system (calculus of constructions)
09:23:08 <mmachenry> alpounet: Yes I know about that. But why doesn't 0+0+0+0+0+‚Ä¶ grow as unevaluated thunks?
09:23:13 <alpounet> MagneticDuck: argh, i'm not using it these days but what's the problem you get? maybe we can find a solution
09:23:44 <vanila> koomi, a proof system cannot prove everything that is true because of incompleteness, but there is no such limitation when you write a function in haskell since it's turing complete
09:23:47 <MagneticDuck> I'll just make a seperate module that exports all that stuff
09:23:58 <MagneticDuck> ghc-mod will give me errors there but hopefully they'll be isolated
09:24:37 <vanila> That's why there will always be functions N -> N that you can write in haskell but not in a total language like Coq or agda
09:26:10 <MagneticDuck> vanila: !!
09:26:29 <MagneticDuck> ... huh.
09:26:44 <MagneticDuck> so what happens when you try to treat Haskell as a formal system?
09:26:53 <MagneticDuck> what doesn't add up?
09:27:07 * MagneticDuck might not understand something
09:27:21 <vanila> I don't know what you mean MagneticDuck
09:27:32 <joness> indiagreen isn't Qi dynamically typed? with optional type annotations
09:27:59 <joness> not sure how it belongs in a group with Agda and Idris and friends
09:28:01 <MagneticDuck> vanila: you can treat Agda as a formal system; why can't you do the same for haskell?
09:28:06 <MagneticDuck> .. and isn't Agda turing complete?
09:28:20 <coltfred> What's the recommended package for shell scripting tasks in Haskell? I see Shelly, shell-conduit and numerous others. Recommendations?
09:28:43 <MagneticDuck> vanila: I think I need to understand agda x(
09:28:50 <vanila> MagneticDuck, of if you try to use haskell as a proof system then you can prove 'false' in it, so it is inconsistent
09:28:56 <vanila> the hope is that coq and agda are consistent
09:29:06 <MagneticDuck> .. that's only a hope?
09:29:17 <vanila> it is difficult be sure of things like that
09:29:18 <MagneticDuck> they can't be shown equilivant to systems widely used in mathematics?
09:29:22 <vanila> yes
09:29:25 <MagneticDuck> okay =P
09:29:35 <MagneticDuck> yeah, I'm familiar with the godel proofs
09:30:58 <MagneticDuck> huh, I was not aware that haskell is an "inconsistent system"
09:31:16 <MagneticDuck> I probably just need to think about that
09:31:27 <vanila> :t fix id
09:31:28 <lambdabot> a
09:31:31 <vanila> this is a proof of 'anything'
09:31:34 <vanila> including false
09:31:47 <vanila> basically the fact that you can write a function that doesn't terminate lets you prove anything
09:31:48 <ChristianS> i i have several executable's in the same cabal file. is it possible to define their dependencies without having to repeat version numbers?
09:31:57 <koomi> vanila: I don't know what else to say but what I have already said: a function in agda does not have to halt, it only has to be productive
09:32:15 <vanila> koomi, A function must halt, a coinductive data must be productive
09:32:51 <HeladoDeBrownie> koomi, i'm confused how that works, especially since i thought agda evaluation was strict?
09:32:56 <indiagreen> joness: actually it wasn't supposed to be a group of dependently-typed languages, just languages which are more powerful in some way. Qi was included instead of Lisp/Racket.
09:33:09 <nocturne777> I have been using scala for sometime on the side, but I've started to read some material on haskell recently, and I see that haskell on the surface seems more simple and elegant
09:33:56 <MagneticDuck> vanila: ah.
09:34:23 <nocturne777> are most people choosing scala over haskell mostly because it just runs on JVM?
09:35:10 * hackagebot tasty-silver 3.0 - Golden tests support for tasty. Fork of tasty-golden.  http://hackage.haskell.org/package/tasty-silver-3.0 (PhilippHausmann)
09:35:27 <tommd> nocturne777: I'm not sure about the premise, but that is why I've seen people choose scala.
09:35:29 <koomi> HeladoDeBrownie: coinduction is the keyword
09:35:34 <joness> indiagreen ok.. so it is completelyu subjective, then. you might as well throw in python in there
09:35:42 <ChristianS> nocturne777: haskell *is* more simple and elegant from what i can tell.
09:35:54 <darthdeus_> is there an emacs mode for heist templates?
09:36:47 <nocturne777> scala folks  are actually trying to copy haskell
09:36:50 <indiagreen> joness: how do you want it to be not subjective when you can implement an Agda interpreter in Haskell and thus ‚Äúprove‚Äù that Haskell is just as powerful as Agda?
09:36:53 <HeladoDeBrownie> koomi, i've read a bit on it before; actually, what vanila said makes it make more sense to me again. still, i really ought to do something in agda at some point.
09:37:03 <Bor0> since we're already in the "proof discussion" :) in the case of p -> q AND p, why are we free to conclude that q? but in the case of p -> q, we ASSUME p and then prove q. why need we not prove q in the former case?
09:37:04 <nocturne777> by creating libraries like scalaz and whatnot
09:37:34 <indiagreen> The only non-subjective notion of power I know is Turing-completeness, and it's not very useful for comparison.
09:37:34 <vanila> Bor0, lookat it this way,  (p -> q, p) -> q
09:37:36 <joness> indiagreen that proves no such thing.
09:37:42 <nocturne777> I hear that module system in scala is better, however.
09:37:49 <vanila> Bor0, easy to implement  proof (f,x) = f x
09:37:57 <gcganley> nocturne777: ive never used scala but it seems like monad transformers arent as mature
09:38:01 <vanila> this proves that you can deduce q from p -> q AND p
09:38:02 <HeladoDeBrownie> Bor0, modus ponens
09:38:35 <hexagoxel> ChristianS: see http://stackoverflow.com/questions/10163604/how-to-reduce-duplication-in-the-build-depends-fields-of-a-cabal-file
09:38:36 <joness> if turing-completeness is your criteria (which is a pretty useless criteria when discussing language power, imo) then haskell is more powerful than agda because haskell is turing complete and agda isn't
09:38:56 <indiagreen> which is why turing-completeness isn't my criterion
09:39:01 <nocturne777> what's the performance of GHC like these days?
09:39:06 <ChristianS> hexagoxel: checking it, thanks
09:39:09 <hexagoxel> ChristianS: it is kinda old, but the first answer is still correct afaik
09:39:22 <Fuuzetsu> psht just turn on termination checker ;^)
09:39:22 <platz> nocturne777: odersky (scala creator) doesn't consider scalaz idiomatic scala style.  OO is as inherent to it as FP in it's design's intentions.
09:39:25 <gcganley> nocturne777: w/ multiple cores its actually pretty good
09:39:25 <Fuuzetsu> turn off*
09:39:30 <S11001001> nocturne777: as a longtime user of haskell and scala, and a regular contributor to scalaz, I can say that haskell is *much* simpler.  And, since you brought it up, its compiler is much faster.
09:39:40 <S11001001> nocturne777: And I couldn't care less what Odersky wants.
09:39:42 <nocturne777> are there people here who choose frege because it runs on JVM?
09:39:58 <indiagreen> joness: I'm sorry if I accidentally made an impression that I meant the power of type system when I said ‚Äúpowerful‚Äù
09:40:10 * hackagebot tasty-silver 3.0.0.1 - Golden tests support for tasty. Fork of tasty-golden.  http://hackage.haskell.org/package/tasty-silver-3.0.0.1 (PhilippHausmann)
09:40:26 <joness> indiagreen. that is ok, you are forgiven :)
09:41:02 <nocturne777> S11001001: traits are nice in the scala land as they give you nice composibility if used right
09:41:08 <koomi> vanila: I am not actually sure anymore, it is certainly possible I am confused, so I will read some more
09:41:22 <S11001001> nocturne777: no one likes cakes anymore but djspiewak
09:41:23 <vanila> ok, thanks for the interesting discussion!
09:41:34 * S11001001 stops talking about scala, sorry
09:41:57 <HeladoDeBrownie> indiagreen, i would be more interested in the reverse, a haskell compiler written in agda, especially given that agda is supposed to be "less powerful" in some sense (due to lack of turing completeness)
09:42:00 <nocturne777> S11001001: is it possible to achieve the same kind of composibility in haskell?
09:42:10 <nocturne777> S11001001: what would be the alternative, typeclasses?
09:42:53 <gcganley> I've heard of agda A LOT but i still dont understand why its turing-incomplete. could someone explain it quickly? in the meantime I'll google it
09:43:25 <HeladoDeBrownie> gcganley, guaranteed termination. lack of any guarantees about termination is a theorem of turing systems and is known as the halting problem
09:44:08 <gcganley> HeladoDeBrownie: Googleing i see that all functions are total. How do they guarentee completeness?
09:44:21 <gcganley> s/completeness/totality
09:44:24 <athan> um.. so... the `old-locale` package hints at a new-locale package... where is it? .-.
09:45:14 <HeladoDeBrownie> gcganley, i don't know the whole story, but it includes things like requiring all cases to be present for a pattern match, and lack of any fix : (a ‚Üí a) ‚Üí a
09:45:34 <HeladoDeBrownie> (which is not provable in intuitionistic logic, much less classical logic)
09:45:53 <zwer> what happens if you do the equivalent of `f x = f x' in agda? compile error?
09:46:11 <gcganley> HeladoDeBrownie: I'm not well versed in any form of formal logic
09:46:15 <gcganley> lol
09:46:15 <koomi> zwer: yes, the totality checker will scream at you
09:47:02 <gcganley> koomi: what is agda written in? does it take after haskell where it has a tiny C core and a huge Agda library system
09:47:27 <HeladoDeBrownie> gcganley, intuitionistic logic sees statements as sets of proofs. which means that to show that something is true you must construct a proof of it. this applies well to programming languages, where the types are propositions and values are proofs.
09:47:34 <HeladoDeBrownie> s/statements/propositions/
09:48:33 <koomi> gcganley: the compiler is written in haskell and it usually compiles to haskell
09:48:48 <koomi> the library ecosystem is not huge by any stretch of the word
09:49:11 <gcganley> koomi: im guessing no I/O, no network lol
09:49:31 <koomi> you can use haskell functions easily
09:49:45 <koomi> there is also a javascript backend
09:49:45 <gcganley> koomi: is there a FFI to haskell?
09:49:49 <koomi> yes
09:49:57 <koomi> since it compiles to haskell that's pretty easy
09:50:00 <gcganley> koomi: really! thats really interesting
09:50:49 <gcganley> koomi: could you do the reverse? could you call agda functions from haskell?
09:51:06 <HeladoDeBrownie> compiling to haskell would be the equivalent of that, basically
09:51:10 <geekosaur> since agda compiles to haskell that's a bit of a n-brainer
09:51:30 <f_x> i can't tell if that's a discret math joke or not
09:51:44 <geekosaur> typo. no-brainer
09:51:57 * geekosaur can't type to save his life...
09:52:00 <f_x> too bad, it owuld have been a good joke :P
09:52:07 <f_x> you can see i can't type either
09:52:59 <HeladoDeBrownie> compiling one language to another is sort of a function from programs in the former language to programs in the latter. which means you want every program in the first language to have an equivalent program in the latter. the reverse is not necessarily true; just because you can compile agda to haskell doesn't mean you can compile haskell to agda (although i'm not sure whether this is the case)
09:53:09 <nocturne777> at this point I have feeling that everything I can do in scala, I can easily do in haskell as well
09:53:10 <gcganley> is there a mailing list or rss stream that sends only updates on features and releases of GHC?
09:53:20 <HeladoDeBrownie> however we find that for most languages used for programming, they are in some sense of equivalent power, and can be compiled to each other
09:53:33 <nocturne777> I am going to follow my instincts and explore the language more
09:53:42 <geekosaur> haskell types allow things you can't give a proper type in agda, as I understand it
09:54:34 <mniip> compilation is almost always a non-bijective function though
09:55:04 <HeladoDeBrownie> mniip, ah you mean like you can't take the resulting source and turn it back to the original
09:55:08 <mniip> yeah
09:55:29 <HeladoDeBrownie> what if we viewed it as a function over something other than the sources, but rather the semantics?
09:55:48 <HeladoDeBrownie> s/but rather/like/
09:55:56 <geekosaur> when you compile agda to haskell you lose type information
09:56:01 <geekosaur> because haskell can't represent it
09:56:10 <HeladoDeBrownie> good point
09:56:49 <gcganley> i just think the interaction between the two would be tough because there is some information that cant be represented or is lost
09:59:07 <vanila> koomi, I just brought this up aith a friend and I realize why we disagreed: We can say that agda is not TC in sense of it's pure functions N -> N (which is what I had in mind), but it actually *is* in the looser sense with the IO monad allowing you to go right to the end of a codata stream (which I think you were talking about)
09:59:49 <vanila> so it's more subtle than normal languages which are obvious TC - what exactly is meant can flip whether it is or isnt
10:00:31 <Saizan> (not necessarily the IO monad though)
10:00:42 <hodapp> end of a codata stream?
10:08:33 <sdegutis> What kind of applications do you use Haskell for?
10:08:58 <unknownloner> audio synthesis
10:11:04 <clrnd> web stuff
10:13:03 <tomphreek> clrnd: do you use websockets?
10:13:35 <clrnd> tomphreek, never did in haskell, though I did with Tornado
10:13:37 <sdegutis> clrnd: what stack tools do you use?
10:13:42 <sdegutis> (in haskell)
10:13:53 <sdegutis> (and with haskell)
10:14:19 <clrnd> sdegutis, like scotty? what do you mean?
10:14:53 <clrnd> we haven't done a full stack web app in haskellyet, they are mostly microservices and testing utils
10:14:59 <sdegutis> ok
10:17:12 <carlosaguilar> hi there
10:17:28 <nocturne777> what's an equilavent library to spray in haskell?
10:17:56 <athan> huh... is there a proper year parser? `parseCalendarTime` from MissingH seems to mess up when the year >= 2001 with "%D" :\
10:17:57 <nocturne777> looking for a rest library that lets me do reactive programming easily
10:18:28 <Welkin> how do you use quickcheck to test functions like reverse?
10:18:40 <athan> Welkin: ===
10:18:54 <athan> Welkin: https://github.com/athanclark/hi-quickcheck-lib ;)
10:18:59 <Welkin> for the arbitray case
10:19:03 <athan> oh
10:19:05 <Welkin> for a string of abitrary length
10:19:06 <athan> ==>
10:19:25 <Welkin> no
10:19:30 <Welkin> I mean how do you write it
10:19:30 <Welkin> ?
10:19:32 <athan> hmm
10:19:34 <athan> one sec
10:19:43 <athan> so the integer has to be >= 0
10:19:57 <athan> so `(num >= 0) ==>` is necessary
10:20:34 <athan> Then, if you have an instance of I think `Arbitrary` for your parametric type (so it's in a context)
10:20:44 <athan> you should be good to generate random elements
10:20:57 <athan> then, you can just replicate the random generation `num` times
10:21:23 <athan> THEN test things like `reverse . reverse = id`, etc
10:21:48 <athan> I hope that helps Welkin
10:22:02 <Welkin> what about testing a function that produces the first non-duplicate element of a list?
10:22:23 <athan> Welkin: That feels idempotent
10:22:28 <Welkin> or something else that is not as simple as just calling the function twice (such as with reverse . reverse == id)
10:22:29 <athan> so you could use that
10:22:39 <athan> Welkin
10:22:41 <athan> sorry
10:22:51 <athan> well each test has different properties, right?
10:23:06 <athan> I feel like the equivalences must be found before they're declared :P
10:23:13 <athan> (algebraically)
10:23:20 <Welkin> well the specific case is easy
10:23:26 <athan> like idempotency, interchange, things like this
10:23:29 <Welkin> I am having trouble with the arbitrary case
10:23:39 <athan> hmm
10:23:50 <athan> If you can make functions instances of `Arbirary`, that may help :\
10:23:51 <athan> idk
10:23:59 <athan> sorry :c
10:24:04 <Welkin> also, I actually using hspec
10:24:14 <Welkin> not quickcheck directly
10:25:59 <athan> Welkin: that `hi` template actually binds them :)
10:26:16 <athan> (with `property`)
10:26:27 <Welkin> yes, I'm using `property`
10:43:33 <pyed> newbie here, how come this is true: const id 1 2 == seq 1 2
10:43:55 <pyed> I don't understand why feeding 'const' an 'id' works
10:44:19 <shachaf> Well, seq is pretty confusing here. seq 1 2 is just 2.
10:44:31 <shachaf> So you're wondering why const id x y = y?
10:44:42 <pyed> yes it's the opposite of const
10:44:44 <pyed> yes
10:45:04 <pyed> why id is making this effect to const ?
10:45:06 <shiona> Is there a way to pattern match both first and last element of a Sequence?
10:45:22 <vanila> const id 1 2 = (const id 1) 2 = id 2 ) 2
10:45:23 <shachaf> pyed: Well, const a b = a
10:45:23 <vanila> const id 1 2 = (const id 1) 2 = id 2 = 2
10:45:44 <shachaf> pyed: So const id 1 = id, so const id 1 2 = id 2 = 2
10:45:46 <elzair> What is the best way to do string formatting in Haskell?
10:46:29 <pyed> Aha, I see
10:46:35 <elzair> Currently, I am concatenating a list of Text items. However, this is very ugly.
10:46:41 <pyed> thanks vanila, shachaf
10:47:46 <elzair> Here is an example:
10:47:49 <elzair> makeHostCommands repo HostInfo{hostName = name, runOptions = Nothing} = map DT.concat ([["scp ", pathRoot, "local-images/", DT.replace "/" "_" repo, ".tar hannahci@", name, ":/home/hannahci/remote-images/", DT.replace "/" "_" repo, ".tar"], ["ssh hannahci@", name, " docker load -i /home/hannahci/remote-images/", DT.replace "/" "_" repo, ".tar"], ["ssh hannahci@", name, " docker kill ", repo], ["ssh hannahci@", name, " docker run -d
10:47:49 <elzair> --name ", repo, " ", repo]])
10:48:26 <indiagreen> elzair: there's formatting package for it
10:48:30 <indiagreen> @hackage formatting
10:48:30 <lambdabot> http://hackage.haskell.org/package/formatting
10:49:44 <indiagreen> but if you have that many different variables, it will probably be confusing
10:49:55 <kranius> is there a cleaner way to set user-wide flags for ghc than a shell alias ?
10:50:30 <elzair> indiagreen: Thanks, I will check it out.
10:51:48 <indiagreen> elzair: if you want it to do things like ¬´DT.replace "/" "_" repo¬ª as well, you might want to write your own formatter for repo names or something, and then you'd be able to reuse it
10:52:08 <elzair> Gotcha.
10:52:09 <sdegutis> The overloaded-strings extension seems incredibly useful and handy. Is there any reason not to use it?
10:52:45 <elzair> Would TemplateHaskell be the correct approach?
10:53:52 <ChristianS> sdegutis: no (it's the one extension i always use)
10:54:10 <elzair> indiagreen: Did you mean writing a formatter like these: hackage.haskell.org/package/formatting-6.1.2/docs/src/Formatting-Formatters.html
10:54:17 <indiagreen> yes
10:54:32 <elzair> Okay.
10:54:54 <tommd> sdegutis: You can get ambiguity with that extension, which will matter in some cases.  The solution is just to use explicit type signatures, but that gets syntactically ugly.
10:55:29 <sdegutis> Oh.
10:59:43 <rasen> tommd: seems that ExtendedDefaultRules pragma would be handy
11:00:14 * hackagebot sdf2p1-parser 0.1 - A parser for SDF version 2.1 using Parsec  http://hackage.haskell.org/package/sdf2p1-parser-0.1 (kojung)
11:06:03 <sdegutis> It seems like Haskell would be well-suited to HTML template processing with embedded-Haskell, by converting a template into a Haskell file that has Strings sprinkled around, because of HTML being really just a tree. Is there an excellent library for this?
11:07:33 <ChristianS> sdegutis: I'd say that mixing code and data like that is somewhat doubtful and can end in a maintenance nightmare
11:07:41 <sdegutis> Ah.
11:07:53 <sdegutis> Maybe you're right.
11:08:15 <sdegutis> I've been using to Hiccup in Clojure which lets you represent an HTML tree in pure Clojure data.
11:09:05 <clrnd> sdegutis, http://chrisdone.com/posts/lucid
11:11:41 <sdegutis> Oh that looks so nice!
11:11:50 <levi> sdegutis: See http://www.happstack.com/docs/crashcourse/index.html#using-hsxhsp as well
11:12:15 <levi> If you like the idea of more literal HTML, anyway.
11:13:22 <levi> Also http://www.yesodweb.com/book/shakespearean-templates
11:13:42 <levi> There are many ways to skin this cat; many have been implemented already at least once. :)
11:15:04 <sdegutis> table_ (tr_ (td_ (p_ "Hello, World!")))   -- soooo niiiiice
11:15:44 <Welkin> hamlet is also very nice
11:15:53 <Welkin> part of the shakespearean templating languages
11:16:08 <Welkin> http://hackage.haskell.org/package/shakespeare
11:16:11 <sdegutis> I wonder why he chose _ instead of ' for the name suffixes.
11:16:21 <sdegutis> Maybe ' was taken for things like div
11:16:47 <jtanguy> i think it's because of the choices made by blaze
11:17:02 <indiagreen> elzair: alternatively, yes, you can use TH (e.g. look at the interpolate package). There's also text-format if you want something even simpler than printf which works for Text as well. It all really depends on how many strings you have and how different your usecases are ‚Äì if it's all like you've shown, you're probably better off with TH interpolation and writing a bunch of functions like ¬´underscore = DT.replace "/" "_"¬ª
11:17:16 <sdegutis> Oh I see:  "I‚Äôm not into operators like ($) and swung indentation like that, but I followed the same format."
11:17:41 <jtanguy> the other html dsl is blaze-html, which didn't ass suffixes to every combinator
11:18:01 <jtanguy> so there were a few collisions, for which he put an underscore
11:18:44 <sdegutis> Right.
11:18:57 <sdegutis> I was just reading http://chrisdone.com/posts/lucid which explains this.
11:18:58 <jtanguy> forget what i-ve just said
11:19:00 <sdegutis> Very good blog post.
11:19:13 <jtanguy> blaze was meant to be imported qualified
11:19:44 <jtanguy> there's no suffix in blaze
11:20:39 * jtanguy should read the docs more often
11:22:10 <jtanguy> there are major changes to lucid2, which makes it even nicer imo: http://chrisdone.com./posts/lucid2
11:23:51 <sdegutis> Wish these blog posts were dated.
11:23:58 <sdegutis> That's an important thing every blogger should do.
11:24:24 <jtanguy> they are
11:24:44 <jtanguy> well the last updated date seems to be
11:24:45 <sdegutis> Oh I see, in the Copyright thing.
11:24:46 <jtanguy> in the footer
11:24:54 <sdegutis> Nice.
11:25:15 * hackagebot lucid-svg 0.4.0.1 - DSL for SVG using lucid for HTML  http://hackage.haskell.org/package/lucid-svg-0.4.0.1 (jeffreyrosenbluth)
11:25:21 <sdegutis> Html is a typeclass in here?
11:25:49 <jtanguy> yes
11:25:53 <sdegutis> Aww, he took away the $
11:25:57 <sdegutis> But I think it can still be used.
11:26:15 <jtanguy> it's even defined as a monad transformer
11:29:36 <sdegutis> I think this is the same as his first example:  https://gist.github.com/sdegutis/f936eb78c6ce87da8743
11:30:15 * hackagebot pipes-binary 0.4.0.4 - Encode and decode binary streams using the pipes and binary libraries.  http://hackage.haskell.org/package/pipes-binary-0.4.0.4 (RenzoCarbonara)
11:30:46 <osa1> this might look good in base: maybeM = maybe (return ())
11:33:49 <supki> :t Data.Foldable.mapM_ `asTypeOf` maybe (return ())
11:33:50 <lambdabot> Monad m => (a -> m ()) -> Maybe a -> m ()
11:35:15 * hackagebot HGraphStorage 0.0.1 - Graph database stored on disk  http://hackage.haskell.org/package/HGraphStorage-0.0.1 (JeanPhilippeMoresmau)
11:40:57 <seanparsons> I could well be tired here, but it looks like GHC is complaining about an ambiguity introduced by a module that I never imported, which as far as I can tell shouldn't be ambiguous anyway as it refers to a different type: https://github.com/seanparsons/rwst-wiring/commit/d132c5d71186dfca4583b71119e73b5b6fd59e82#commitcomment-9485206
11:46:52 <juanpablo_> what does ~ mean in a type constraint?
11:47:02 <glguy> "equal"
11:47:04 <kadoban> juanpablo_: It's like equality I believe.
11:47:15 <juanpablo_> Like these types should unify or something?
11:48:41 <n4x> juanpablo_: yes
11:48:46 <kadoban> juanpablo_: Yes, although I'm not sure that's technically what that term means or not.
11:49:18 <n4x> @type head :: (a ~ [Int]) => a -> Int
11:49:19 <lambdabot> [Int] -> Int
11:49:30 <n4x> @type head :: (f ~ []) => f a -> a
11:49:31 <lambdabot> [a] -> a
11:50:42 <sdegutis> The main parts of a web app are the router, route handlers, database access, generating HTML, and generating CSS, all of which Haskell is perfectly capable of doing, and most of which it already has excellent libraries for.
11:52:42 <xplat> Haskell is also capable of generating js; either by compiling Haskell or by using DSLs like e.g. jmacro.  or you can just include static js scripts as usual.
11:53:23 <sdegutis> Awesome.
11:53:33 <sdegutis> So it sounds like the Haskell web ecosystem is ready to get popular.
11:53:46 <tdammers> my $0.02: haskell is a dream platform for web programming
11:54:17 <tdammers> for so many reasons, really...
11:55:11 <tdammers> let's see. one, default laziness and explicit effects + http and the request/response paradigm is a match made in heaven
11:55:46 <sdegutis> tdammers: totally
11:55:49 <tdammers> two, web is full of protocols and textual formats that require parsing and structured handling - http, html, DOM, xml, css, etc. etc.
11:56:08 <tdammers> and haskell happens to be a rock star at parsing
11:56:22 <tdammers> and at dsl's
11:57:01 <sdegutis> The two biggest problems I've seen so far with Haskell adoption where I used to work (a decent sized web app consulting firm) is that (1) things like monoidal applicative functors sound terrifying and scare everyone away and (2) it has a steeper learning curve than, say, Ruby or Clojure
11:57:05 <tdammers> three, web things tend to be "somewhat structured" - too security sensitive to throw everything wide open entirely, but not structured enough to make things entirely rigid
11:57:31 <tdammers> so you need something that defaults to strict types, but has a type system flexible enough to introduce islands of looser typing
11:57:35 <tdammers> Haskell fits that bill.
11:58:04 <sdegutis> :)
11:58:25 <tdammers> re learning curve; Haskell doesn't have a steep learning curve, it just refuses to sacrifice performance at the top end (power users) to make the first two weeks of learning "easier"
11:58:30 <bernalex> is there som pragma that lets you write
11:58:31 <seubert> is yesod still the de facto library for web apps, sdegutis ?
11:58:40 <bernalex> f (n+1) = n
11:58:41 <sdegutis> seubert: I don't know Haskell sorry.
11:58:42 <bernalex> ?
11:58:43 <tdammers> yesod is many libraries
11:58:55 <bernalex> I saw an old wiki example kind of like that. looked weird.
11:58:56 <seubert> oh
11:59:01 <tdammers> and there are alternatives for most of them
11:59:05 <seubert> i see
11:59:07 <seubert> thanks
11:59:14 <tdammers> full-blown yesod is nice, but it's a rather heavyweight stack
11:59:15 <n4x> tdammers: but you need to learn something new, and learning new stuff is hard
11:59:23 <monochrom> ironically, a higher-level language has a steeper learning curve.
11:59:27 <barrucadu> bernalex: n+k patterns were dropped, iirc
11:59:53 <bernalex> barrucadu: this is what I seem to recall
11:59:58 <tdammers> n4x: that's not really the problem; people actively refuse to learn new things not because it's hard, because, uhm, haven't really figured that one out, but somehow it seems to scare them
12:00:25 <kadoban> I believe you can use n+k patterns via an extension now‚Ä¶but I've never personally found a real use for them. They seem pretty gross.
12:00:27 <tdammers> that attitude that I share with a few people, where I say "oh look, this looks interesting, let's see if I can wrap my brain around that concept"
12:00:34 <tdammers> apparently, that's a rare feat
12:00:47 <fryguybob> bernalex: NPlusKPatterns
12:00:50 <unknownloner> they hear stuff like "you cant change variables" and then decide they'll never understand what that actually mwans
12:00:51 <tdammers> being able to enjoy learning for its own sake
12:01:01 <n4x> tdammers: are you telling people don't like programming? :<
12:01:14 <unknownloner> means*
12:01:19 <n4x> er> are you telling me people don't like programming?
12:01:31 <n4x> mostly because that is what makes programming amazing
12:01:36 <bernalex> fryguybob: oh, thanks!
12:01:39 <tdammers> n4x: I'm saying that a frighteningly large number of programmers don't particularly enjoy programming, they enjoy the results of it
12:01:52 <tdammers> they program to "get things done", or to produce something that looks nice or does something impressive
12:02:34 <tdammers> unknownloner: I like to confuse "pragmatic" programmers by telling them that constants are also variables
12:02:54 <jtanguy> bernalex: try using ViewPatterns instead. Reasons here https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/pattern-and-guard-extensions
12:03:07 <unknownloner> haha
12:03:12 <bernalex> jtanguy: yeah I know about those. thanks though. :-]
12:06:20 <unknownloner> so theres no way to make ([Double] -> [Double]) a monoid without using newtype right? but is there any really advantage to doing that instead of just defininf my own functions that do the same thing but dont actually make it a monoid? I guess im asking if making something a monoid actually has any good advantages on its own
12:06:29 <unknownloner> real*
12:07:13 <tdammers> the advantage of making it a monoid instance is that everything that works on other monoids will automatically work on your monoid, too
12:08:17 <unknownloner> right, but I'm not really sure what else would work on just kinda monoids in general. Do you know anything specific?
12:08:21 <jtanguy> unknownloner: your type looks like the Endo monoid
12:08:23 <jtanguy> :t Endo
12:08:24 <lambdabot> (a -> a) -> Endo a
12:08:25 <clrnd> unknownloner, to be a monoid or not to be
12:08:39 <unknownloner> hmm interesting
12:08:43 <unknownloner> what does Endo mean
12:09:05 <jtanguy> it stands for Endomorphism
12:09:25 <monochrom> even with t->t with unknown t, there are already two monoids. with concretely [Double]->[Double], there are more. if we don't require everyone to newtype his/her idea of monoid, there will be too many conflicts.
12:10:12 <unknownloner> well yeah
12:10:31 <unknownloner> for context the input is time values and the output is sound samples
12:10:59 <jtanguy> Haa that's different then
12:11:23 <unknownloner> and so combining two is just adding the output of one to the output of the other
12:11:49 <jtanguy> is it  ([Time] -> [Sample]) ?
12:12:11 <unknownloner> I havent defined Time or Sample but it could be yeah
12:12:55 <unknownloner> type Time = Double
12:13:00 <unknownloner> same with Sample
12:16:02 <jtanguy> monochrom: i don't see the other possible monoid for (t -> t)
12:17:06 <monochrom> "x <> y = x . y" vs "x <> y = y . x"
12:17:36 <jtanguy> haa indeed
12:17:44 <shachaf> That's why we use categories.
12:19:06 <benzrf> which does Endo use
12:19:37 <unknownloner> I guess I just want to be able to type <> to combine my stuff and I can do that without Monoid, but then it conflicts which is kinda annoying
12:19:49 <kadoban> x <> y = if heads then x . y else y . x
12:20:58 <kadoban> unknownloner: I would think that that's probably not a good idea for readability if nothing else. <> is pretty well known to be Monoid and if yours isn't‚Ä¶that'd be confusing.
12:21:07 <unknownloner> exactly
12:21:43 <unknownloner> any other good symbols to represent '+' since + is taken
12:23:07 <jle`> -|-
12:23:10 <jle`> heh
12:23:25 <kadoban> `not<>`
12:23:28 <unknownloner> haha
12:24:12 <kadoban> But uhm, yeah I'm not sure.
12:24:23 <monochrom> you can use <<>> for yours
12:24:31 <unknownloner> oh god
12:24:44 <monochrom> or <^> or <!>
12:24:45 <geekosaur> some things use <+>
12:24:46 <xplat> what about a unicode diamond?
12:24:59 <kadoban> snowman
12:25:08 <unknownloner> Im okay with <+>
12:25:16 <xplat> <<<+>>>
12:25:35 <unknownloner> ‚Ä¢ or ‚ô•
12:25:51 <unknownloner> maybe ¬±
12:26:02 <pingu> It's generally pretty safe to just double your brackets.
12:26:21 <geekosaur> ‚äï ‚äû
12:26:24 <unknownloner> I dont really like how <<>> looks though
12:26:49 <xplat> i like the idea of a heart to combine things lol
12:27:00 <mauke> :-<
12:27:03 <jtanguy> .<>.
12:27:06 <jle`> <+<+>+>
12:27:15 <jtanguy> yay ! programming with smileys
12:27:17 <xplat> :+:
12:27:31 <unknownloner> ‚Üê for do notation
12:27:32 <unknownloner> bam
12:27:34 <xplat> wait, that's uppoercase
12:27:46 <xplat> ^+^
12:27:48 <clrnd> laFunci√≥n
12:27:58 <xplat> `plus`
12:28:24 <unknownloner> `combineSamplesTogether`
12:28:31 <geekosaur> v a b = ...; `v`
12:28:35 <unknownloner> woo verbosity
12:28:52 <elzair> indiagreen: You have been a big help. I started using the formatting code. However, most of my text is strict and it wants lazy.
12:29:03 <kadoban> `combineTwoSamplesTogetherLikeAMonoidButNot`
12:29:09 <elzair> I tried using the stext formatter, but it does not work.
12:29:18 <jle`> kadoban: way too meaningful
12:29:22 <xplat> `mix`
12:29:23 <kadoban> :)
12:29:30 <jle`> <+*<<*<*>>>$<$%+%<%>#>#<>@><>
12:29:40 <jle`> oh no @ allowed
12:29:46 <kadoban> jle`: That's probably taken in lens :-/
12:29:58 <xplat> just use three operators, `rip`, `mix`, and `burn`
12:29:58 <jle`> yeah that's the thing you have to watch out for :/
12:30:14 <rhllor> how do you repeat a range like ['a' .. 'z']
12:30:19 <jle`> just do everything in ski
12:30:25 <jle`> rhllor: you can use cycle?
12:30:25 <Black0range> How does haskell get the length of a ByteString?
12:30:32 <jle`> > cycle ['a'..'z']
12:30:32 <xplat> > cycle ['a'..'z']
12:30:34 <lambdabot>  can't find file: L.hs
12:30:34 <lambdabot>  "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvw...
12:30:39 <clrnd> Black0range, that's up to bytestring
12:30:41 <rhllor> sweet thanks
12:30:54 <kadoban> Black0range: You mean what function do you use to do it, or how is it implemented, or?
12:31:05 <clrnd> Black0range, https://hackage.haskell.org/package/bytestring-0.9.2.1/docs/src/Data-ByteString.html#length
12:31:06 <Black0range> kadoban: yes how it's impelmented
12:31:13 <benzrf> jle`: @ is allowed
12:31:45 <xplat> it's O(1) for strict bytestring, O(n) for lazy (but a lower coefficient than lists)
12:31:48 <clrnd> it seems the BS has length in the type, how can it stream then? mmm
12:32:00 <mauke> clrnd: it can't
12:32:07 <Black0range> clrnd: ah sweet! :) No need to keep a length reference then
12:32:19 <clrnd> here its for lazy https://hackage.haskell.org/package/bytestring-0.9.2.1/docs/src/Data-ByteString-Lazy.html#length
12:32:27 <clrnd> exactly like xplat said
12:33:05 <jtanguy> ndmitchell compiled a list of all operators on hackage once: https://gist.github.com/ndmitchell/aa1e0944379a7429cedb#file-gistfile1-txt
12:33:44 <f_x> "tickle"? o.O
12:35:10 <clrnd> never heard of plumbers LOL it's hilarious
12:37:27 <joness> do we have reverse <$> operator? foo >>= bar $> baz, instead of baz <$> (foo >>= bar)
12:37:31 <joness> flip <$>
12:37:34 <clrnd> <$$>
12:37:37 <clrnd> :t <$$>
12:37:38 <lambdabot> parse error on input ‚Äò<$$>‚Äô
12:37:42 <clrnd> :t (<$$>)
12:37:43 <lambdabot>     Not in scope: ‚Äò<$$>‚Äô
12:37:43 <lambdabot>     Perhaps you meant ‚Äò<$>‚Äô (imported from Control.Applicative)
12:37:55 <Black0range> if i make a (IO [Bytestring]) will the list be lazy?
12:38:10 <joness> $> and $< would have been better names
12:38:22 <joness> or <$
12:38:32 <clrnd> I got mixed up with <**>
12:38:32 <Black0range> where each element of the list is is  transfered from a IO Bytestring
12:38:33 <clrnd> :t (<**>)
12:38:35 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
12:38:46 <joness> :t flip (<$>
12:38:47 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
12:38:48 <joness> :t flip (<$>)
12:38:49 <lambdabot> Functor f => f a -> (a -> b) -> f b
12:38:56 <mauke> Black0range: depends on how you make it
12:38:58 <monochrom> clrnd: the Strict one is not streamed, it is one single buffer. the Lazy one is a list of Strict ones, it is streamed in the sense of one buffer at a time for many buffers.
12:39:01 <mauke> Black0range: in general, no
12:39:37 <clrnd> monochrom, I didn't know, thanks for clearing that up
12:39:52 <Black0range> mauke: how do i make it lazy?
12:39:54 <joness> so it does not exist? does it exist in some third party library like lens so that I at least use consistent naming convention
12:40:06 <Black0range> mauke: each chunk requires a read operation from a socket
12:40:11 <clrnd> Black0range, import Data.Bytestring.Lazy
12:40:12 <Welkin> Black0range: Data.ByteString.Lazy
12:40:16 <mauke> Black0range: lazy IO is evil
12:40:30 <mauke> clrnd, Welkin: what
12:40:32 <joness> lazy IO can be cool
12:41:12 <joness> Black0range I just blindly put unsafeInterleaveIO if I want to make some IO lazy.. so far it worked fine
12:41:13 <Black0range> Welkin: clrnd: but isn't a lazy bytestring technically still just a [Bytestring] ?
12:41:14 <clrnd> oh he meant the list, the list is always lazy ...
12:41:17 <monochrom> http://www.vex.net/~trebla/photo/unorganized/dragon.jpg
12:41:29 <Welkin> Black0range: they have different constructors/types
12:42:03 <dieselpowa> Hey guys, any of you do any web development using haskell?
12:42:11 <Welkin> ByteString from the Lazy module is not the same as ByteString from the strict (default) module
12:42:24 * mauke sighs
12:42:27 <Black0range> dieselpowa : I'm currently creating a simple http server :P
12:42:50 <Black0range> Welkin: so are there any way to create a Lazy Bytestring from a Socket?
12:43:05 <Welkin> try conduit
12:43:20 <Welkin> http://hackage.haskell.org/package/conduit
12:43:23 <monochrom> mauke: allow me to cheer you up with http://lpaste.net/77374 :)
12:44:50 <Welkin> why are you against lazy IO?
12:45:07 <Black0range> Welkin: it can create some nasty situations
12:45:09 <joness> it can have surprising results
12:45:35 <Welkin> anyway, Black0range, take a look at conduit or pipes
12:45:50 <Black0range> https://wiki.haskell.org/Conduit ?
12:46:09 <joness> `readFile path >>= writeFile path' won't work, for example
12:46:42 <Welkin> Black0range: http://hackage.haskell.org/package/conduit
12:47:15 <joness> since readFile reads lazily file handle will still remain open after readFile returns. and depending on your OS you may get a "file in use" error
12:48:50 <benzrf> pipes is the cool
12:48:56 <benzrf> Black0range: pipes is nice and good
12:49:18 <Black0range> How about using UnsafeLeaveIO in a really really controlled environment?
12:49:28 <IRWolfie-> I have a function which is the current bottleneck for my calculations. It is a short function that maps from Int -> Double, and takes only integers which are members of the set [1..ns]. but the function is not called in sequence. In C I would generally just precompute an array with the possible values of the function, what approach should I take in Haskell?
12:50:24 * hackagebot ghc-exactprint 0.1.0.1 - ExactPrint for GHC  http://hackage.haskell.org/package/ghc-exactprint-0.1.0.1 (AlanZimmerman)
12:52:09 <clrnd> IRWolfie-, can you paste us some code?
12:52:40 <IRWolfie-> Sorry, sure:  knots i | i < kmax = 0 | i > ns = rmax | otherwise =(fromIntegral (i-kmax)) / (fromIntegral (ns-kmax+1))*rmax
12:53:33 <dmwit> IRWolfie-: Same approach should work in Haskell.
12:53:44 <dmwit> IRWolfie-: Precomput an Array.
12:53:59 <dmwit> s/comput/compute/
12:54:16 <IRWolfie-> https://wiki.haskell.org/Arrays <-- This I guess?
12:55:01 <dmwit> Well. That covers a bunch of different types of arrays. But yes.
12:55:24 * hackagebot hoogle 4.2.38 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.38 (NeilMitchell)
12:55:53 <IRWolfie-> Aha unboxed arrays seems to be what I want
12:56:04 <ab9rf> why unboxed?
12:56:09 <dmwit> Why not unboxed?
12:56:43 <IRWolfie-> unboxed seems to give the best performance? My code spends 70% of the time in this little function
12:56:57 <ab9rf> IRWolfie-: that's because it's computing those values over and over again
12:57:00 <edwardk> joness: (<&>) is in lens
12:57:17 <ab9rf> if you compute them once it'll spend essentially no time at all in that function :)
12:57:19 <Black0range> Be the way could someone kind soul explain the MaybeT to me? :)
12:57:23 <IRWolfie-> yeah I know that's why I want to do it
12:57:28 <dmwit> Again, why not unboxed? That seems like a fine choice to me.
12:57:36 <ab9rf> how large is ns?
12:57:41 <dmwit> ?unmtl MaybeT m a
12:57:41 <lambdabot> m (Maybe a)
12:57:45 <IRWolfie-> ~1000,5000
12:57:53 <dmwit> Black0range: What do you need explained, in particular?
12:58:08 <Black0range> the m part in m (Maybe a)
12:58:11 <ab9rf> how certain are you that every value of i wiull be used?
12:58:14 <Black0range> and what does it do exactly?
12:58:15 <IRWolfie-> 100% sure
12:58:28 <IRWolfie-> In C I precompute
12:58:42 <sdegutis> One feeling I can't shake is that learning the advanced features of Haskell (applicative functors, monads, etc) actually requires the learner to be a little smarter than other languages require.
12:59:24 <ab9rf> sdegutis: there is probably truth to that
12:59:29 <dmwit> Black0range: The m is a type variable. It can range over any type of kind (* -> *), but will almost always be instantiated at some instance of Monad.
12:59:40 <sdegutis> I've found it kind of hard to hold a lot of these concepts in my head all at once.
12:59:56 <ab9rf> sdegutis: try holding one of them at first, then once you've managed that, add another
13:00:00 <clrnd> sdegutis, monad is not exactly ... advanced haskell
13:00:08 <dmwit> Black0range: MaybeT m is a monad that behaves a bit like m, except that it has a short-circuiting way of indicating early failure.
13:00:09 <sdegutis> The examples and analogies in LyaH don't actually make it much easier, most of the time -- I usually skim down to the part where he shows how they're used and why we need them, and then it starts to make sense.
13:00:09 <tdammers> sdegutis: not exactly; doing the same stuff *correctly* and actually understanding what you are doing requires at least as much intelligence in other languages
13:00:13 <sdegutis> clrnd: :'(
13:00:23 <jtanguy> IRWolfie-: maybe the memoize package might help?
13:00:25 <tdammers> sdegutis: the difference is that in other languages, you can usually get away with doing it a bit wrong
13:00:33 <ab9rf> or indeed a lot wrong
13:00:36 <tdammers> sdegutis: or even extremely wrong, in some cases
13:00:38 <sdegutis> tdammers: hmm maybe
13:00:42 <Black0range> dmwit: what kind of failure?
13:00:43 <ab9rf> beware of burritos
13:01:02 <dmwit> Black0range: What are my choices for "kinds of failure"?
13:01:29 <Black0range> dmwit: say i use this MaybeT to read a file and get some kind of IOerror?
13:01:57 <dmwit> Black0range: If you would like to catch IO exceptions and turn them into MaybeT-style failures, you can do that.
13:02:15 <IRWolfie-> I'll have a look
13:02:18 <dmwit> Black0range: Of course, IO exceptions do not magically become MaybeT-style failures on their own.
13:02:48 <Black0range> dmwit: ah so is it a kind of box that allow us to do dangerous stuff in a "good" manner?
13:03:00 <dmwit> That question is too vague to answer.
13:03:38 <ab9rf> maybe is just a box that lets you go from "a value of some type" to "possibly a value of some time"
13:03:41 <ab9rf> er, type
13:03:43 <Black0range> dmwit: Uhm maybe; if you would be so kind. You could show me a tiny example?
13:03:56 <ab9rf> Maybe doesn't care why you want to represent that concept
13:04:06 <dmwit> ?where AAM
13:04:06 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
13:05:27 <Black0range> dmwit: oh i haven't seen this thank you! :)
13:06:08 <dmwit> Black0range: http://stackoverflow.com/q/28124844/791604
13:06:47 <dmwit> Turns out All About Monads doesn't include any MaybeT examples, sorry.
13:08:43 <Black0range> so this sum in the answer it returns Just IO Int or Nothing?
13:09:23 <indiagreen> could anyone check how fast ¬´ghc -e '2+2'¬ª is? 0.5s on my laptop, and I'm not sure whether I should expect it or not
13:09:45 <Black0range> 4
13:10:04 <dmwit> indiagreen: 0.13s here
13:10:20 <dmwit> Black0range: Just is a term-level thing, and IO Int is a type-level thing. So that question is a bit ill-formed.
13:10:38 <dmwit> Black0range: But: a value of type MaybeT IO a is approximately the same as a value of type IO (Maybe a)
13:10:54 <dmwit> Black0range: That is what the first command I sent to lambdabot said (which I will repeat momentarily).
13:10:58 <dmwit> ?unmtl MaybeT m a
13:10:58 <lambdabot> m (Maybe a)
13:11:02 <dmwit> ?unmtl MaybeT IO a
13:11:03 <lambdabot> IO (Maybe a)
13:11:24 <dmwit> indiagreen: I don't think anybody has bothered trying to make ghc -e fast.
13:11:35 <tasker> Is there a standard function to split a list into a list of lists of a certain size?
13:11:43 <dmwit> ?hackage split
13:11:43 <lambdabot> http://hackage.haskell.org/package/split
13:12:00 <dmwit> Or parsec. ;-)
13:12:22 <tasker> dmwit: Awesome.
13:12:57 <ab9rf> i really wouldn't expect ghc -e to be speedy
13:12:58 <supki> indiagreen: do you have a sizeable ~/.ghci?
13:13:14 <Black0range> dmwit: so what would a msum of [IO Just 1, Nothing] become?
13:13:18 <supki> indiagreen: ghc -e attemps to read it unless you pass -ignore-dot-ghci
13:13:36 <dmwit> Black0range: Again: that is not a thing, because IO is a type-level thing and Just/Nothing are term-level things.
13:13:44 <dmwit> Black0range: They can't mix in that way.
13:14:15 <Black0range> but thats what the guy does in the answer?
13:14:32 <dmwit> Black0range: However: msum [MaybeT (Just (return 1)), MaybeT Nothing] is the same as MaybeT (Just (return 1)), and MaybeT (Just (return 1)) >> MaybeT Nothing is the same as MaybeT Nothing.
13:14:38 <indiagreen> supki: I don't have ~/.ghci at all, but I tried with ‚Äú-ignore-dot-ghci‚Äù anyway and nothing changed
13:15:22 <dmwit> Black0range: I don't see him doing that.
13:15:36 <dmwit> Black0range: I don't see any lists that contain the text "IO" inside their brackets.
13:15:36 <Black0range> http://stackoverflow.com/questions/28124844/refactoring-staircasing-with-case-of-maybe-values-in-io-code ?
13:15:52 <Black0range> i was just a bit lazy :)
13:16:14 <sdegutis> ba dum tsh!
13:17:18 <dmwit> Is there not a replicateA somewhere?
13:17:54 <prophile> http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Sequence.html#v:replicateA
13:18:07 <dmwit> I can use Hoogle, too.
13:18:19 <prophile> ask a silly question...
13:18:27 <dmwit> Look at that awful type! I don't want to use Seq!
13:18:50 <shachaf> There's always sequenceA . replicate n
13:18:50 <prophile> so shove it through a toList
13:18:56 <prophile> ^ or that :)
13:20:03 <shachaf> Certainly using Data.Sequence to replicateA to get a list isn't what you want.
13:20:25 * hackagebot reverse-geocoding 0.1.1.1 - Simple reverse geocoding using OpenStreeMap  http://hackage.haskell.org/package/reverse-geocoding-0.1.1.1 (jcristovao)
13:20:38 <dmwit> Thanks.
13:21:10 <dmwit> \n -> match (many (replicateA n anySym)) :: Int -> [a] -> Maybe [[a]] -- beautiful
13:21:24 <sdegutis> replicateA = sequenceA . replicate
13:21:32 <dmwit> \n -> match . many . sequenceA $ replicate n anySym
13:21:40 <sdegutis> Aside from omitting a type signature, did I just create replicateA correctly?
13:21:46 <dmwit> yes
13:21:51 <sdegutis> Awesome, I'm a Haskell pro now.
13:21:51 <dmwit> Thanks to you, too. =)
13:22:04 <sdegutis> I almost added an 'n' parameter until I remembered we don't need it :D
13:22:20 <dmwit> Actually, you probably need replicateA = (sequenceA .) . replicate
13:22:38 <sdegutis> Hmm maybe. I don't know what any of those functions are or do.
13:22:48 <dmwit> :t (sequenceA .) . replicate
13:22:49 <lambdabot>     Not in scope: ‚ÄòsequenceA‚Äô
13:22:49 <lambdabot>     Perhaps you meant one of these:
13:22:50 <lambdabot>       ‚ÄòT.sequenceA‚Äô (imported from Data.Traversable),
13:22:52 <sdegutis> I should probably be in #haskell-beginners lol
13:22:55 <dmwit> :t (T.sequenceA .) . replicate
13:22:56 <lambdabot> Applicative f => Int -> f a -> f [a]
13:23:10 <shachaf> This channel is fine for beginners.
13:23:10 * sdegutis departs
13:23:26 <sdegutis> shachaf: then why is there #haskell-beginners? :P
13:23:37 <shachaf> Someone made it.
13:24:01 <sdegutis> lol ok then
13:24:22 <josephle> it's there when you get tired of crazy type signatures being interspersed with beginner questions and vice-versa :P
13:24:39 <Black0range> dmwit: thanks for the explanation btw
13:25:32 <cmccann> shachaf: ok but which channel is for questions that can be answered with bad puns
13:26:44 <shachaf> whoa, long time no cmccann
13:27:19 <shachaf> cmccann: I wouldn't know. All my puns are fun.
13:27:41 <cmccann> shachaf: only if you rot13 them
13:29:44 <shiona> Can I define instance (Enum a, Monoid m) => Enum (m a)
13:29:51 <cmccann> also yeah I have a bad habit of getting too busy IRL and then forgetting to get back on IRC and stuff. I have a very short attention span.
13:30:30 <shiona> I'm trying to, but I'm starting to feel I'm missing something obvious why it can't work
13:31:07 <cmccann> shiona: Monoid instances are not type constructors
13:31:24 <shiona> cmccann: An excellent point
13:31:27 <cmccann> did you mean Monad? or Monoid (m a)?
13:32:00 <troydm> wait, why isn't Monoid a type constructor instance?
13:32:04 <cmccann> in any case it's not obvious to me what you expect that instance to be doing, but fixing the kind mismatch would be a good start
13:32:22 <shiona> I mean I wrote instance Enum a => Enum (Sum a), but I was thinking I could maybe make it more abstract
13:32:47 <tomphreek> do you guys use lukerandall/haskellmode-vim? is it any good?
13:33:06 <shiona> (I did that so I could have 'getSum $ mconcat [1..100]'
13:33:07 <Hijiri> troydm: Monoid constraint is defined to apply to concrete types, not type constructors
13:33:19 <Hijiri> ie, Monoid instances must be kind *
13:33:26 <cmccann> shiona: if you want to generalize that, then I think Monoid (m a) is the constraint you want. but I don't think you'll get anywhere with that.
13:34:26 <cmccann> in particular I don't think that gives you any way to use the Enum a constraint, so you're effectively trying to write an Enum instance for an arbitrary Monoid instance
13:35:11 <shiona> as long as it holds an enum of some sort
13:36:17 <shiona> but I don't have the syntax to write it
13:37:09 <cmccann> shiona: it sounds like what you want is to lift existing Enum instances to newtype wrappers around those types
13:37:30 <cmccann> I don't think your approach is going to work in a satisfying way, if at all
13:37:41 <shiona> :/
13:37:57 <shiona> is there any sensible way of doing this?
13:39:04 <sdegutis> What's the best Haskell -> JavaScript thing at the moment?
13:39:20 <cmccann> shiona: the sensible way is probably generalized newtype deriving, at the definition of the newtype
13:39:43 <shiona> ouch. Ok, I'm not going there
13:39:55 <cmccann> I think you can do that as a standalone (orphan) instance as well but please don't do that in library code
13:40:16 <luite> sdegutis: ooh pick me pick me
13:40:24 <sdegutis> okay I pick luite
13:40:25 <shiona> It's unfortunate. It seems so obvious I thought it would be easy to write
13:41:02 <athan> Is there some homomorphic mapping / isomorphism between conjunction and `&&&` in the arrow category?
13:41:11 <Zemyla> Huh, the four basic Brainfuck manipulations (+, -, <, >) form a monoid.
13:41:16 <nshepperd_> (Enum a, Pointed m) => Enum (m a)
13:41:21 <athan> erm, is `&&&` ~ ^?
13:41:32 <athan> (or is it V... :\)
13:41:33 <Zemyla> Actually, it's a group, since every manipulation has an inverse.
13:41:41 <cmccann> shiona: it is easy to write... if you're the one defining the newtype :P
13:41:42 <koala_man> Zemyla: what's the identity element?
13:41:44 <sdegutis> Someone mentioned one earlier, right?
13:41:52 <sdegutis> Some Haskell to JavaScript compiler (and maybe runtime)?
13:41:52 <Zemyla> +-.
13:41:58 <athan> nshepperd: Was that for me?
13:42:01 <athan> :D
13:42:01 <jle`> another reddit post of mine got caught in the reddit spam filter ;_; not sure how that happens
13:42:08 <jle`> sdegutis: it depends on your domain
13:42:10 <luite> sdegutis: hehe i can't promise an unbiased answer since i'm the main author of ghcjs :)
13:42:13 <jle`> sdegutis: or what you are looing for
13:42:13 <nshepperd_> hehm
13:42:26 <quchen> jle`: "Maybe is not a Functor"? :-√æ
13:42:32 <jle`> :P
13:42:36 <koala_man> Zemyla: that's two elements that cancel each other out
13:42:36 <athan> jle`: What are you hosting with?
13:42:41 <jle`> heroku
13:42:55 <jle`> but all of my posts have been good up until the one last week
13:43:11 <nshepperd_> shiona: see above. but any such general instance will certainly conflict if the newtype definer derived Enum properly as they should have
13:43:13 <Zemyla> I actually meant that combinations of those four elements form a monoid.
13:43:35 <athan> :\
13:43:52 <jle`> shiona: what d you want to do?
13:44:09 <jle`> what Enum instance are you writing?
13:44:22 <shiona> just a second, I'll write something to a paste
13:44:48 <jle`> there are some "* -> * monoids" in base
13:44:56 <nshepperd_> jle`: they wanted Enum instances for newtype wrappers like Sum
13:45:10 <nshepperd_> which don't have derived instances for some reason
13:45:11 <jle`> types f such that `f a` have a binary operator that is monoidal
13:45:21 <jle`> what Enum instance?
13:45:24 <IRWolfie-> (Huh, it seems it's running quicker all by itself without the optimisation today. I must have accidentally left a profiling option in after all.)
13:45:26 * hackagebot yesod-auth-bcrypt 0.2.0 - BCrypt salted and hashed passwords in a database as auth for yesod  http://hackage.haskell.org/package/yesod-auth-bcrypt-0.2.0 (TobyGoodwin)
13:45:35 <jle`> just enum-ming the wrapped type?
13:45:40 <nshepperd_> yeah
13:45:46 <jle`> {-# LANGUAGE GeneralizedNewtypeDeriving #-} doesn't help?
13:46:07 <cmccann> jle`: for existing newtypes
13:46:11 <jle`> ah
13:46:12 <shiona> jle`: http://pastebin.com/k4HGWa8U
13:46:16 <cmccann> like (Enum a) => Enum (Sum a)
13:46:22 <jle`> if only Sum etc. were Applicative
13:46:32 <cmccann> except without having to write it out manually for every such type
13:46:55 <jle`> shiona: yeah, your problem is that Sum is not a monoid
13:47:08 <jle`> Num a => Sum a is a monoid
13:47:26 <shachaf> That sentence makes sense if you parse it as "Num a => (Sum a is a monoid)"
13:47:43 <shachaf> It makes a bit of sense as "(Num a *> Sum a) is a monoid", too.
13:47:58 <jle`> :)
13:48:39 <nshepperd_> the real problem is perhaps that lifting Enum has nothing to do with being a monoid
13:48:52 <jle`> yeah, i'm not sure why monoid is coming up into the picture at all
13:49:11 <IRWolfie-> Cheers I got a 40% improvement using arrays
13:49:15 <jle`> yay
13:49:18 <jle`> :D
13:49:27 <shiona> I'll give it some more thought tomorrow
13:49:32 <shiona> I think I'll need to get some sleep too
13:50:02 <jle`> you probably could use this http://hackage.haskell.org/package/newtype
13:50:30 <ReinH> jle`: That's in lens now
13:50:40 <ReinH> > ala Sum foldMap [1,2,3]
13:50:43 <lambdabot>  6
13:50:46 <ReinH> :t ala
13:50:47 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
13:51:03 <ReinH> well, it's been in lens for some time
13:51:11 <IRWolfie-> I'm a little confused as to what I actually need to do to convert from IArray to UArray. Examples seem to be generally non-existent when it comes to Haskell :|
13:51:13 <zipper> Why do yesod functions lack type signatures? Isn't this bad practice and making it hard for people to get what's going on? Harder to test etc Going by https://www.fpcomplete.com/blog/2012/10/yesod-tutorial-1-my-first-web-site
13:51:34 <jle`> instance (Newtype n o, Enum o) => Enum n where fromEnum = fromEnum . unpack; toEnum = pack . toEnum
13:51:36 <jle`> ^ shiona
13:51:42 <jle`> and i guess it's in lens now too apparently
13:51:54 <edwardk> the lens version is kinda fancy
13:51:58 <voisdl> Hi, im tring to install servant-server using cabal and getting the following error: http://lpaste.net/119437
13:52:05 <edwardk> it can deal with type-changing 'ala'
13:52:19 <jle`> why such fance
13:52:36 <nomeata> Hi. What would be the most efficient way to fill a Data.Vector vector with repeating short patterns (say, a 3 byte pattern into a 100MB vector)?
13:52:38 <edwardk> note lambdabot is running an old lens, as well
13:52:56 <jle`> quchen: i liked your point on the BBP thread the mailing list
13:53:01 <jle`> quchen: about bumping the major version number
13:53:15 <quchen> jle`: Oh, someone read it after all!
13:53:24 <quchen> I didn't see any responses
13:53:26 <jle`> for changes this drastic it hardly makes any sense to be 7.10
13:53:40 <jle`> 8.0 would be a nice semantic indicator
13:53:44 <jle`> that things are literally completely different
13:53:50 <voisdl> what should I do about this error: http://lpaste.net/119437 ?
13:53:51 <jle`> it's literally a new language
13:53:54 <cmccann> I thought the first two numbers were both major.
13:54:17 <quchen> The first one is majorer.
13:54:20 <jle`> augustss's post mentions, "we are basically redefining the language"
13:54:32 <quchen> jle`: While we're at it we might as well bump base to version 8 too, because this 4.x is nonsense
13:55:04 <Black0range> hmm in haskells network sockets are there a way to tell haskell that "it must recieve x bytes of data" ?
13:55:13 * edwardk bows out, because i'm not going to add a fourth venue to debate on today.
13:55:18 <jle`> lol
13:55:23 <quchen> edwardk: :-)
13:55:28 <jle`> this debate is engulfing every front
13:55:49 <edwardk> jle`: well, its mostly the same voices.
13:55:52 <quchen> edwardk: I'm not suggesting it seriously. Also, thanks for the BBP and that the committee made it happen.
13:56:05 <jle`> i'm pretty happy about BBP
13:56:15 <jle`> but i guess that is me debating it isn't it
13:56:18 <jle`> oops
13:56:18 <edwardk> quchen: we'll see how much of me makes it out of this meat grinder intact.
13:56:47 <jle`> i think most of the objects might go away if we just say "don't worry guys, it's 8.0.  new language, and all."
13:56:53 <jle`> objections
13:56:53 <edwardk> jle`: there are _lots_ of folks who have opinions about how it could have been slightly differently on almost every front.
13:56:59 <voisdl> im trying to install a package using cabal on ubuntu and getting an error about base version
13:57:02 <cmccann> I'm thinking of proposing a GHC feature that causes code more than six months old to always fail to compile. that way we can make changes more easily going forward because old code will already be as broken as it can be.
13:57:02 <voisdl> what do?
13:57:03 <quchen> edwardk: Let's hope the middle ground won't be pulling Foldable/Traversable out of Prelude, and making Applicative not a superclass of Monad. That's the attitude I'm reading in the mailing list somehow
13:57:22 <geekosaur> I have not seen anyone suggest the latter
13:57:22 <Black0range> voisdl: update haskell
13:57:27 <voisdl> how
13:57:31 <jle`> i have a lot of minor opinions about how i would tweak things too from the proposal.  it's not perfect but i'm happy that there's something and i would support it to the end
13:57:39 <hexagoxel> voisdl: it appears servant-server wants ghc version >= 7.8
13:58:00 <geekosaur> in fact the only thing I can see being mistaken for it was the observation that AMP was observed to cause more breakage despite being much better advertised beforehand
13:58:22 <Welkin> is there an easy way to detect cycles in a circular linked list in haskell?
13:58:33 <Welkin> tying the knot seems to make this impossible
13:58:40 <geekosaur> (*my* only complaint, as I noted in the thread, is that I would have liked to have heard more about BBP up front, as we did with AMP)
13:58:49 <Black0range> Welkin count the nr of elements before knot! :D
13:58:52 <hiptobecubic> it does seem pretty strange that a deep change that breaks a shit ton of code is not worth a major bump.
13:58:58 <quchen> geekosaur: We did, multiple times. It was a bikeshed fest.
13:59:01 <edwardk> the main thing we can do is try very hard to consider competing viewpoints. my viewpoint on an 8.0 bump is that the change here is actually quite minor. more code compiles on almost all fronts, very very few programs break. it breaks far less code than AMP.
13:59:02 <hiptobecubic> what *would* be a major bump?
13:59:04 <geekosaur> referential transparency argues against, I believe
13:59:17 <geekosaur> (re spotting cycles)
13:59:18 <edwardk> hiptobecubic: where is this 'shit ton of code'?
13:59:22 <voisdl> hexagoxel: is there an easy way to update my ghc on ubunut? The latest in the ubuntu repo is 7.6
13:59:29 <quchen> edwardk: Really? I'm surprised to hear that. I would have expected it to be as breaking as the AMP.
13:59:40 <cmccann> Welkin: get the last element of the list. if this never finishes, the list had a cycle :P
13:59:46 <edwardk> hiptobecubic: mostly what we've seen is a ton of breakage due to AMP, a few things breaking due to new symbols and a vanishingly small chunk of code breaking because of inference not fixing []
13:59:47 <hiptobecubic> i don't mean BBP alone, but everything that is 7.10, no? Everyone is whining constantly about breaking old code.
13:59:48 <geekosaur> quchen, I have seen a small handful of dicsussions on BBP, much much more about AMP
13:59:58 <Hijiri> voisdl: ghc distribution on the site, with the generic binary installation
14:00:01 <quchen> voisdl: Download the binary GHC distribution, and install it manually. It's fairly easy
14:00:07 <Clint> voisdl: or switch to debian experimental
14:00:11 <hiptobecubic> errr whatever version we're one
14:00:13 <jle`> i can see it not being too brekaing, but i mean, we're basically redefining the language here
14:00:14 <hiptobecubic> on*
14:00:27 <voisdl> ok ill ill try the binary distribution
14:00:33 <quchen> voisdl: You can have two GHCs alongside just fine, you won't even lose your Debian one
14:00:36 <geekosaur> and most of the BBP stuff was about relatively minor implementation details, up until about the past week
14:00:37 <jle`> just think about it as a PS2 being able to play PS1 games; but it's still a big difference
14:00:37 <Cale> Welkin: Cyclic structures are indistinguishable from infinite ones. You can tag the elements with IDs of some sort to try to understand where you've been in the graph.
14:01:02 <quchen> geekosaur: What is a "major" detail that got revealed last week?
14:01:11 <quchen> Apart from that it happened, that is
14:01:24 <jle`> i didn't mean to start this, i'm sorry everyone
14:01:40 <cmccann> I still want to know why this BBP is such a crisis when I distinctly remember huge discussions leading to broad agreement that it was a good idea YEARS ago
14:01:44 <edwardk> hiptobecubic: i'd just like to point out that at this point more of stackage builds with 7.10 than did at a comparable point in 7.8.
14:02:02 <cmccann> discussions that included at least one person who's now acting like he's never heard of this before
14:02:05 <geekosaur> hm? aside from the earliest discussion, very little has been mentioned about the amount of code affected since then. "out of sight, out of mind"
14:02:11 <geekosaur> communication is a thing
14:02:13 <ReinH> edwardk: this isn't the time for a reasonable perspective, Ed.
14:02:26 <ReinH> I spent all night sharpening my pitchfork
14:02:28 <jle`> my agreement with a major version bump is sort of a resolution to the meta-problem of having people be okay with the solution
14:02:56 <edwardk> hiptobecubic: So for all the flash and noise to come out of Neil on the topic, it has been mostly the same folks crying doom in each thread since he started. If it was actually turning out to be a huge pain point in practice, wouldn't we be seeing a ton more people flocking to the 'FTP is too big' banner?
14:02:58 <quchen> ReinH: And now for news out of the "I know how beginners think" corner ‚Ä¶
14:03:01 <geekosaur> (that said, I feel like we've been saturated with AMP reminders and yet that apparently caught a lot of folks off guard)
14:03:05 <voisdl> is it better to install ghc and cabal or haskell platform?
14:03:13 <cmccann> I also don't understand why many people seem to be arguing for an alternative approach that's more work, breaks more code, and takes longer. as far as I can tell.
14:03:22 <edwardk> cmccann: that is my concern as well
14:03:36 <edwardk> we generalized the types in Data.List because while ugly it broke the least code
14:03:40 <dizzeehaskell> voisdl: Haskell Platform IMHO
14:03:41 <edwardk> we could just as easily have removed them
14:03:50 <dizzeehaskell> just because everything's standardised per release
14:03:53 <edwardk> and honestly, it may be a better move, and would probably be the better move in the long run
14:04:01 <ReinH> voisdl: ghc and cabal
14:04:08 <ReinH> voisdl: Most Haskellers I know don't use the platform.
14:04:18 <edwardk> because just because someone imports Data.List unqualified to get 'sort' it shouldn't cause them to break foldr, etc.
14:04:20 <Welkin> I use the platform
14:04:22 <quchen> geekosaur: I'm stunned by how you can be surprised by the AMP. Either you updated to 7.8 and got the warnings, or you're lagging so far behind that you will not update to 7.10 right away anyway.
14:04:26 <dizzeehaskell> huh, and here i don't know anyone who DOESN'T
14:04:29 <voisdl> okay, im getting conflicting information - what do? ReinH dizzeehaskell
14:04:31 <dizzeehaskell> different circles i guess
14:04:31 <geekosaur> any more the platform is the unsupported stepchild, stackage is the only supported path :(
14:04:49 <nkar> does cabal install determine all the constraints right after it's executed, or does it calculate them on the go?
14:04:51 <Adeon> I use the platform on windows
14:04:53 <edwardk> ReinH: i actually use the platform wherever possible
14:04:54 <geekosaur> the platform was *supposed* to be the standard batteries included starting place, but it is now worthless
14:04:54 <quchen> geekosaur: GHC is a compiler, not a Steam game. You have the option to upgrade. Your old compiler still works if you do not upgrade.
14:04:57 <geekosaur> all hail stackage
14:05:17 <quchen> That's a good thing if you ask me.
14:05:34 <edwardk> i try to ensure all of my code builds clean on the last 2-3 haskell platforms whereever possible, on stackage and with any reasonable configuration in between that doesn't depend on a clearly broken version of a package
14:05:34 <quchen> Stackage is kind of the next Platform.
14:05:35 <geekosaur> quchen, I have no idea
14:05:56 <edwardk> stackage has been a huge boon for ensuring that much of hackage builds together especially between platforms
14:06:03 <edwardk> where previously shipping a platform had been a monolithic task
14:06:21 <geekosaur> I have tried to install too many things recently that flatly refused to deal with a platform install of any vintage I could get my hands on
14:06:43 <voisdl> -_-
14:06:44 <voisdl> what do?
14:06:45 <quchen> edwardk: Right, Stackage is pretty much the "builds" seal of quality generator. When you build with Stackage, it's likely to work, end.
14:06:48 <dizzeehaskell> ghc/cabal is probably the more 'minimal' option
14:06:52 <dizzeehaskell> when in doubt, go for that
14:07:01 <dizzeehaskell> i plump for the platform but YMMV
14:07:05 <ReinH> voisdl: Well, if you want a large collection of packages, most of which you won't use, some of which conflict with latest packages on hackage, go with the platform.
14:07:12 <dizzeehaskell> Heh
14:07:23 <ReinH> voisdl: If you don't mind spending a little more time installing things but ending up with a more reasonable system, go with ghc and cabal
14:07:30 <voisdl> the ghc website says they recommend installing the platform
14:07:45 <cmccann> anyway, I can't help but feel that 90% of the concerns about BBP are people who weren't paying attention to discussion about changing the core libraries wondering why they don't know about the core libraries changing
14:07:45 <dizzeehaskell> their reason probably being down to the familiarity of the user
14:07:56 <EvanR> ReinH: instructions for how to go about that other path would be good
14:07:59 <Welkin> what is BBP?
14:08:03 <voisdl> okay i will do ghc + cabal
14:08:07 <Clint> Welkin: https://ghc.haskell.org/trac/ghc/blog/weekly20140930
14:08:17 <quchen> Welkin: AMP+FTP, basically
14:08:26 <ReinH> EvanR: instructions? I mean, it just involves running cabal install repeatedly.
14:08:26 <EvanR> ReinH: on OSX
14:08:28 <quchen> Welkin: In other words, large Prelude changes
14:08:32 <bshelden> The platform will give you an environment that's reasonably complete, and works together, but runs into some serious issue when you need stuff that requires packages that conflict, or need newer versions, etc than what the platform provides.
14:08:43 <ReinH> EvanR: on OS X I use https://ghcformacosx.github.io/
14:08:45 <dizzeehaskell> ^ that's fair
14:08:47 <edwardk> Welkin: basically we're bringing Foldable and Traversable into the Prelude to replace a bunch of monomorphic combinators as part of 7.10
14:09:02 <ReinH> bshelden: pretty much
14:09:06 <edwardk> welkin: that is "BBP" or as it is some times referred to as "FTP" the Foldable/Traversable Proposal.
14:09:06 <Welkin> is it really that significant?
14:09:09 <phaazon> hey
14:09:18 <phaazon> http://lpaste.net/6478769170275106816
14:09:23 <Welkin> you can just import the modules directly
14:09:28 <phaazon> doesn‚Äôt it sound‚Ä¶ like allocating A LOT?
14:09:29 <Welkin> does anyone really rely on prelude?
14:09:33 <edwardk> Welkin: well, from what i can tell most folks don't think its a big deal, but there is a very very vocal minority opposition
14:09:38 <glguy> Welkin: It's significant because it changes the prelude and the prelude doesn't typically change much, and everyone imports the prelude
14:09:57 <edwardk> the fact that the Prelude has historically not changed much at all is the source of a lot of the consternation
14:09:59 <EvanR> ReinH: ok but if a mac user goes to try this they will get several huge sign posts saying "use the platform"
14:10:03 <edwardk> and that is a legitimate concern
14:10:04 <EvanR> is what im saying
14:10:07 <bshelden> ghc+cabal leads to a bit more work (since you need to nab packages directly) but lets you more easily have exactly what you need for the project at hand without worry about conflicting with things that happen to be 'in the environment'.
14:10:18 <cmccann> the fact that the Prelude hasn't ever changed much is also the source of a lot of the desire for change
14:10:27 <edwardk> cmccann: exactly
14:10:29 <dizzeehaskell> edwardk: it's got to endure some change at some point, though
14:10:35 <edwardk> it is the source of the passion on both sides of this debate
14:10:42 <dizzeehaskell> exactly
14:10:44 <cmccann> it's something of a philosophical divide in the community, I guess.
14:10:46 <edwardk> dizzeehaskell: depends on who you ask ;)
14:10:49 <dizzeehaskell> heh ;p
14:11:06 <bshelden> dizzeehaskell: To play the other side.  Have a look at what happened when python changed.
14:11:15 <ReinH> bshelden: it also lets you start out on stackage immediately if you want
14:11:17 <dizzeehaskell> touche
14:11:24 <tasker> If I've got an Aeson Value, how can I convert that to a type ?
14:11:25 <hiptobecubic> yeah but people were *using* python :)
14:11:25 <bshelden> Oranges to tangerines, I admit, but yeah.  There's a mess for you.
14:11:25 <glguy> Fortunately this change is largely backward compatible
14:11:31 <edwardk> So what happened was there was a big thread on this topic, it was clear that the vast majority of opinion was in favor of the change, so we formed a committee to figure out how to deal with that and a bunch of other cross-package maintenance concerns
14:11:50 <bshelden> ReinH: I need to discover this "Stackage" thing.
14:11:58 <johnw`> ardk
14:11:59 <hexagoxel> a little bit more work? you pretty much need to learn sandbox usage to get the same stuff yuo get with platform
14:12:02 <ReinH> bshelden: I hear good things about it
14:12:04 <ReinH> johnw`: o/
14:12:07 <Welkin> bshelden: it changed too late, which was a mistake
14:12:09 <edwardk> and we spent 6 months sitting on our hands waiting for 7.8 to ship, then started work on implementing AMP in 7.10, and once we had AMP we started on the foldable/traversable changes.
14:12:44 <johnw`> hello!
14:12:48 <johnw`> I'm sporting the backtick today
14:12:48 <dizzeehaskell> ahoy
14:12:52 <edwardk> but by the time we'd cleared all the pre-requisites to start work it was a year later, and folks who had missed the previous polling and discussion on the topic felt like it came out of nowhere
14:12:53 <dizzeehaskell> looks fetching
14:12:57 <EvanR> tasker: to convert a Value to a value of some other type, you can use the FromJSON class
14:13:01 <ReinH> johnw`: John prime?
14:13:03 <ReinH> Not quite.
14:13:12 <quchen`> Solidarity!
14:13:13 <johnw`> i'm indivisible
14:13:20 <dizzeehaskell`> #jesuisbacktick
14:13:31 <edwardk> when you factor in the fact that ghc is changing faster _across the board_ due to having so many new hands on deck keeping up with what is going on in GHC is quite a complicated endeavor
14:13:44 <EvanR> tasker: or you could avoid the Value entirely and decode directly to that other type from the ByteString
14:14:04 <edwardk> so in that sense i fully agree we need to be more proactive in communication
14:14:05 <Welkin> edwardk: how often do extensions get integrated as defaults in ghc?
14:14:05 <monochrom> John Tick
14:14:19 <cmccann> edwardk: I dunno, some folks who participated in the previous discussion seemed to feel it came out of nowhere as well :P
14:14:21 <Welkin> ex: OverloadedStrings, ViewPatterns
14:14:22 <dizzeehaskell`> Welkin: it's quite rare I think
14:14:29 <edwardk> welkin: almost never, but note: nothing here was a language extension, just a library change
14:15:02 <edwardk> cmccann: fair. my main strengths are in juggling competing concerns, not so much in communication ;)
14:15:13 <quchen`> edwardk: I don't think it's that simple. Changing Prelude is pretty much a forced language change, but we don't go the extension way here.
14:15:19 <tasker> EvanR: I suspect I'm doing something in a bad way. I'm playing around with wreq, and get a json response that looks like {'something' : [dataICareAbout] }. I was using r ^.. responseBody . key "something, but this results in a Value. I suppose I really should actually learn how lenses work :s
14:15:27 * hackagebot floating-bits 0.2.0.0 - Conversions between floating and integral values.  http://hackage.haskell.org/package/floating-bits-0.2.0.0 (JonasScholl)
14:15:29 <dizzeehaskell`> 'forced' is a strong word for it
14:15:55 <dizzeehaskell`> [it might be obvious where I stand on it]
14:15:59 * nomeata keep starting to write suggestions on the BBP issue and then not sending then, as I‚Äôm sure they have been suggested and considered before.
14:16:05 <EvanR> tasker: lookat the function fromJSON
14:16:08 <ReinH> tasker: the FromJSON typeclass will allow you to annotate it with the return type you want
14:16:14 <Axman6> tasker: a\pretty much all Aeson lenses will give you back Values
14:16:22 <edwardk> quchen`: It is a language change. It was also very very popular when put forth. If we actually had a haskell-prime committee that was active to negotiate with then it might have been a much more 'standards-oriented' process
14:16:49 <quchen`> edwardk: Right. I recently asked what happened to Haskell' and just got a "it's dead" back.
14:16:58 <dolio> I thought everyone agreed that all change had to occur before 1998.
14:17:04 <dizzeehaskell`> ha
14:17:07 <cmccann> nomeata: bringing up new ideas that haven't already been discussed isn't really the purpose of the current discussion. this is a dead-horse-beating party.
14:17:08 <EvanR> history ended in 2005
14:17:28 <monochrom> you need Haskell`
14:17:43 <tasker> ReinH: I have tried this, but it doesn't appear to work. Presumably I'm doing something wrong. Could you point me to some example code?
14:17:44 <quchen`> We should fork to make the GloriousGHC ;-)
14:17:46 <edwardk> quchen`: I hunted down a few members of the committee and the folks I'd spoken to had said they left it open for another year with an eye towards disbanding it, a year or two back, couple of years back, but it seems that even the act of gathering to disband it has fallen apart =P
14:18:01 <tasker> EvanR: Yeah, I have.. again, probably doing something wrong. I'll have a mess around :)
14:18:03 <Axman6> muzzle: a.k.a, Haskell-parse-error?
14:18:06 <Axman6> uh, monochrom
14:18:10 <Axman6> sorry muzzle
14:18:14 <edwardk> quchen`: i don't have a better answer for you than that about what happened
14:18:22 <monochrom> Haskell Backtick
14:18:29 <quchen`> edwardk: So it's a matter of "people lost interest" then?
14:18:35 <EvanR> tasker: yeah, fromJSON does that conversion you want, of course noting that it may fail
14:18:46 <monochrom> since ` is a popular replacement of ' these days. just look at everyone's nick.
14:18:46 <Axman6> "We need to be looking FORWARD!~" I propose Haskell forwardtick!"
14:18:49 <voisdl> is haskell 'too large' to be properly maintained?
14:18:51 <nomeata> cmccann: that‚Äôs what I‚Äôm saying by saying that I‚Äôm not saying what I‚Äôm considering.
14:19:01 <quchen`> Axman6: Not ASCII :-\
14:19:02 <tasker> Hm, so it seems that fromJSON gives me a Result a. Is there some way to get Maybe a instead ?
14:19:02 <Axman6> hmm, there were more symbols in that then there should've been
14:19:06 <cmccann> quchen`: perhaps you should form a Haskell'' committee to discuss changes to the Haskell' committee
14:19:08 <EvanR> tasker: yeah
14:19:22 <dizzeehaskell`> I'm just reading 'Haskell derivative'
14:19:34 <tasker> Could you use the attoparsec stuff directly ?
14:19:44 <quchen`> cmccann: But who's going to orchestrate that committee? We should form a Haskell-œâ committee to solve all our committee problems.
14:20:04 <Axman6> tasker: there's almost certainly a prism for working with Result
14:20:04 <dizzeehaskell`> with infinitely many members?
14:20:05 <monochrom> what is "Result a"? it probably does the same thing as "Maybe a"
14:20:09 <cmccann> quchen`: that sounds like an excellent idea
14:20:19 <EvanR> data Result a = Ok a | Error String
14:20:27 <edwardk> I think haskell-prime is a fairly thankless task, even by way of comparison to dealing with core-libraries-committee issues. You have to figure out how to write up standards around extensions and incorporate things into the language, but then the big stuff that everyone beats up on haskell-prime for is stuff like MPTCs and fundeps and type families and the
14:20:27 <edwardk> like and it is near impossible to write a standard for that stuff that doesn't come off implementation-dependent, because implementations don't agree on corners
14:20:33 <edwardk> and all of it is changing so fast
14:20:37 <Axman6> there's probably an _Ok prism then
14:20:37 <hiptobecubic> I guess I don't understand what a major bump *would* be for, then.
14:20:40 <edwardk> so it is hard to figure out the role of haskell-prime
14:20:48 <tasker> Axman6: I have no doubt. This is really leading me to believe it is time to learn lens :p
14:20:52 <EvanR> (Success rather than Ok but same sh**)
14:20:53 <Axman6> yes
14:21:03 <dizzeehaskell`> monochrom: Result a is the same as Either a String, so it's Maybe but with an error message instead of a dead-end nothing
14:21:26 <tasker> dizzeehaskell`: Yeah, I see that. I would prefer to not write some manual conversion code though :p
14:21:35 * Axman6 thinks it's closer to Either String a but whatevs
14:21:55 <dizzeehaskell`> urgh, tomato tomatoe
14:22:02 <dizzeehaskell`> i actually deleted that way and retyped
14:22:03 <dizzeehaskell`> ;_:
14:22:45 <jfischoff> The frustrating thing about many discussions in the communtiy, is everyone has the energy to shoot things down, very few are putting in the work to move things forward. I guilty of the shooting down aspect myself.
14:23:13 <cmccann> jfischoff: I'm more a "shoot down other people shooting things down" kind of person
14:23:19 <Welkin> democracy is hard
14:23:26 <cmccann> complaining is fun, but complaining about complaining is where it's really at
14:23:35 <jfischoff> Welkin: I don‚Äôt want democracy really here
14:23:52 <monochrom> what you need is another Peter Naur
14:23:52 <jfischoff> or a direct democracy having seen what that is like on a project
14:23:57 <jroesch___> jfischoff: +1
14:23:57 <dizzeehaskell`> Democracy on the internet results in Youtube comments
14:24:00 <Axman6> cmccann: I do wish people wouldn't do that
14:24:01 <Axman6> =)
14:24:20 * EvanR complains about Axman6 complaining about cmccann complaining about people complaining
14:24:30 <cmccann> Axman6: going for "meta-level shooting down" I see, very good, well played
14:24:47 <voisdl> why do so many code examples exclude the imports??
14:24:57 <dizzeehaskell`> œâ-complaining
14:25:03 <monochrom> because authors are lazy
14:25:13 <voisdl> omgz
14:25:20 <NemesisD> at the risk of sounding stupid. do correctly written smart constructors get people most of what they need from dependent types, minus some runtime cost and error case handling?
14:25:24 <jfischoff> voisdl: doesn‚Äôt look pretty
14:25:30 <Axman6> voisdl: which examples are you looking at?
14:25:31 <dizzeehaskell`> NemesisD: pretty much
14:25:40 <voisdl> im looking at servant examples
14:25:43 <EvanR> NemesisD: no >_>
14:25:48 <dizzeehaskell`> i await correction
14:25:52 <dizzeehaskell`> from someone with more DTP than me
14:25:58 <dizzeehaskell`> there it is
14:26:07 <NemesisD> go on...
14:26:16 <jroesch> NemesisD: you can get pretty far with type families and GADTs
14:26:22 <IRWolfie-> I changed "import Data.Array" to "import Data.Array.Unboxed" and added "knots_array :: UArray Int Double" as a type signature for the function: knots_array = array (0, ns+kmax) [(i, knot i) | i <- [0..(ns+kmax)]] . It compiles but now I'm getting the linker error of undefined reference to `arrayzm0zi5zi0zi0_DataziArrayziBase_UArray_con_info'. Anyone any ideas on how to proceed or what I'm doing wrong?
14:26:26 <voisdl> Axman6: http://haskell-servant.github.io/getting-started/#%281%29
14:26:45 <Welkin> voisdl: you can always search hoogle or hayoo for the functions to find them
14:26:53 <jroesch> NemesisD: also DataKinds
14:26:53 <IRWolfie-> (I'm linking with C through FFI)
14:26:56 <dizzeehaskell`> IRWolfie-: that's Core code
14:26:56 <dizzeehaskell`> Erm
14:26:57 <EvanR> NemesisD: smart constructors only enforce things that could be determined at runtime
14:27:01 <Axman6> oh, I have that page open already on my other laptop, heh
14:27:07 <Welkin> hayoo covers many more packages, so I recommend that first
14:27:19 <IRWolfie-> I must be doing something pretty badly wrong to get that :P
14:27:23 <voisdl> yeah Welkin thats what im doing
14:27:25 <voisdl> so annoying though
14:27:26 <NemesisD> EvanR: could you give me an example of something that this wouldn't work for?
14:27:27 <dizzeehaskell`> Hahah
14:27:30 <dizzeehaskell`> I was going to say
14:27:32 <EvanR> NemesisD: "handling error cases" is what dependent types or haskell type level junk could let you just not deal with
14:27:43 <dizzeehaskell`> When GHC mentions z-encoding stuff, something's gone wonky
14:27:47 <Axman6> voisdl: also I'm sure that if you look at the index for the package the talk is about you'll be abl to find any functions you're looking for
14:27:48 * dizzeehaskell` reads
14:28:06 <EvanR> NemesisD: well, if you have a list that cant more than 5 things long right. so your smart constructor Nothings or crashes if you try
14:28:21 <EvanR> that kind of sucks
14:28:43 <dizzeehaskell`> EvanR: I didn't think about length, thanks for correcting me :p
14:28:43 <cmccann> NemesisD: pretty sure that every practical purpose people want dependent types for can be gotten some other way, with varying degrees of ugliness, verbosity, and isolated unsafeness.
14:29:17 <dolio> Smart constructors don't get values into your types.
14:29:23 <dolio> Neither does anything else in GHC.
14:29:56 <Welkin> in regard to my earlier question about detecting cycles, how can this be done easily in haskell?
14:30:06 <Welkin> > cycle [1,2,3]
14:30:08 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
14:30:16 <dizzeehaskell`> IRWolfie-: the problem seems to be that Array_con_info from Array.Unboxed isn't present, either in the library itself
14:30:19 <EvanR> thats the same as the halting problem
14:30:22 <dizzeehaskell`> Or...idk :/
14:30:25 <cmccann> Welkin: in a pure function? it can't.
14:30:25 <Welkin> the cycle begins at the second 1
14:30:29 <Axman6> Welkin: it can't
14:30:29 <dizzeehaskell`> Try look for it
14:30:34 <dolio> Use a representation that lets you represent cycles explicitly.
14:30:50 <ReinH> Welkin: generally speaking? you can't.
14:30:59 <Axman6> because cycle [1,2,3] ++ [4] is not a cyclic
14:30:59 <EvanR> youll never know if an arbitrary list repeats
14:31:02 <Axman6> for example
14:31:15 <ReinH> eXeC64: well, it's bottom.
14:31:19 <ReinH> er Axman6 ^
14:31:20 <monochrom> Welkin: https://ro-che.info/ccc/9
14:31:54 <dolio> It's not bottom.
14:31:56 <Axman6> it is possible using unsafe magic to test whether two objects point to the same location in memory, can't remember the package, but that's basically the only way to do it
14:32:08 <Welkin> in a language like C this is pretty simple
14:32:16 <chirpsalot> dolio: the entire thing evaluates to bottom, no?
14:32:18 <Welkin> you can compare the pointers
14:32:22 <ClaudiusMaximus> Welkin: do you mean detecting cycles in something like   iterate (f :: Int -> Int) x0  then that is possible, but you have to be careful with pre-periodic stuff
14:32:34 <EvanR> chirpsalot: whnf here
14:32:48 <dolio> cycle [1,2,3] ++ [4] evaluates to something indistinguishable from cycle [1,2,3].
14:32:56 <cmccann> Welkin: inspired by the linked comic, see also http://www.reddit.com/r/haskell/comments/c4hnr/zhuangzi_butterfly_and_referential_transparency/c0q356m
14:33:01 <dolio> Except by dark magic.
14:33:17 <EvanR> 1:([2,3] ++ cyle [1,2,3]) ++ [4]
14:33:48 <ClaudiusMaximus> cycle [1,1,1]
14:35:04 <Axman6> Welkin: you can of course represend C style pointers using IORefs and testy them for equality, but that will be very tedious to work with for anything else
14:35:24 <EvanR> theres also StableNames
14:35:25 <Axman6> represent*
14:35:29 <EvanR> also requires IO
14:35:29 <voisdl> > cycle [i | i <- [1..]]
14:35:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:35:47 <voisdl> wowzerz
14:35:47 <EvanR> > cycle [1..]
14:35:49 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:36:05 <voisdl> oh
14:36:05 <AleksejsHome> > [1..]
14:36:06 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:36:21 <IRWolfie-> dizzeehaskell`: You mentioned "the library". Is there something I'm meant to be linking against specifically when I use IArray and UArray?
14:36:25 <EvanR> > text "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,..."
14:36:27 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:37:00 <voisdl> > cycle [i | i <- take 5 [1..]]
14:37:01 <lambdabot>  [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3...
14:37:14 <dolio> I think that's enough of that.
14:37:19 <Axman6> you really don't need the list comprehension there
14:37:24 <voisdl> ok
14:37:26 <dizzeehaskell`> Not to my mind, IRWolfie-, but I have to admit that I just Repa for array computation
14:37:58 <ab9rf> i'm not sure why you'd want to detect a cycle in a list
14:38:18 <ab9rf> if you are interested in detecting cycles, use a different data structure
14:38:33 <dizzeehaskell`> IRWolfie-: the only mention I can see of Update_con_info is here: https://ghc.haskell.org/trac/ghc/attachment/ticket/5924/Update.cmm
14:38:34 <tomphreek> finally got round setting up some proper haskell dev env. And immediately a problem: haskell-src-exts-1.16.0.1 failed to install
14:38:49 <dizzeehaskell`> i.e. actual mucking around with pointers
14:38:52 <IRWolfie-> Right, I guess my best bet is to have a look at Repa
14:38:57 <dizzeehaskell`> :)
14:39:08 <dizzeehaskell`> You won't regret it
14:39:12 <dizzeehaskell`> Repa is love, Repa is life
14:39:16 <tomphreek> Linux localhost 3.16.5-x86_64-linode46 #1 SMP Mon Oct 13 09:42:16 EDT 2014 x86_64 GNU/Linux
14:39:39 <dizzeehaskell`> [that reads much funnier when you know that Repa is Russian for turnip :/]
14:39:44 <ab9rf> heh
14:39:48 <voisdl> what do? - http://lpaste.net/119438
14:39:48 <cmccann> speaking of data structures, is there an existing polygon mesh data structure anywhere on hackage or the like? i.e. one suitable for both modifying the mesh itself and for extracting data to render with openGL.
14:39:51 <Fuuzetsu> I wish =<< didn't exist
14:40:00 <Welkin> ab9rf: it's just an exercise
14:40:00 <Fuuzetsu> somehow it just feels strange and confuses me
14:40:10 <AleksejsHome> Fuuzetsu: why?
14:40:24 <IRWolfie-> I'm hoping to get the performance of my code somewhere similar to C, maye 5 or 6 times slower, is that overly optimistic?
14:40:27 <dizzeehaskell`> Fuuzetsu: the only time I ever see that is someone trying to do bitshift left assignments in Python :p
14:40:45 <Fuuzetsu> >>= for king
14:40:52 <Welkin> =<< works nicely in do-blocks because it resembles composition
14:40:56 <cmccann> pf, I like =<<. it has the sensible argument order.
14:41:04 <dizzeehaskell`> you savages
14:41:11 <ab9rf> what's wrong with =<< ?
14:41:12 <dolio> 5 or 6 times is probably not unreasonable.
14:41:13 <Fuuzetsu> down with sensible argument order
14:41:18 <cmccann> but I also like my =<* operator and everyone looks at me weird for that.
14:41:22 <ReinH> IRWolfie-: Haskell can definitely achieve that sort of performence.
14:41:25 <Fuuzetsu> :t (=<*)
14:41:26 <lambdabot>     Not in scope: ‚Äò=<*‚Äô
14:41:26 <lambdabot>     Perhaps you meant one of these:
14:41:27 <lambdabot>       ‚Äò=<<‚Äô (imported from Control.Monad.Writer),
14:41:27 <ReinH> or performance if you're into spelling
14:41:38 <cmccann> Fuuzetsu: note the keyword "my" there :P
14:41:42 <ab9rf> perkymanc
14:41:52 <Fuuzetsu> they would, any sane person would make *>= instead
14:41:56 <tasker> IRWolfie: I've just started playing around doing some scientific computing in haskell. Depending on the application, it can be pretty fast.
14:41:58 <voisdl> http://lpaste.net/119439 ?????
14:42:03 <dizzeehaskell`> IRWolfie-: also look at Nikola and Accelerate for array stuff
14:42:09 <tasker> I've found that stuff like graphing is a pain in the ass though, and you often have to write stuff yourself
14:42:22 <cmccann> Fuuzetsu: not really, since I use it with <$> and <*>
14:42:22 <IRWolfie-> It's certainly handy for protyping even if it is slower
14:42:24 <dizzeehaskell`> I spent three months at Intel Labs doing nothing but poring over array libraries
14:42:27 <tasker> Also the linear algebra stuff on offer seems much slower than numpy/whatever
14:42:38 <rasen> voisdl: echo $PATH ?
14:42:52 <ReinH> tasker: slower than numpy? That seems... odd.
14:42:55 <IRWolfie-> Cool, Ive bookmarked those as well
14:42:56 <voisdl> rasen: got it fixed after lougout/login
14:42:57 <cmccann> Fuuzetsu: the type is "Monad m => m (a -> m b) -> m a -> m b" which I hope is self-explanatory
14:43:14 <Welkin> numpy has been around a lot longer and has a lot more people working on it
14:43:17 <tasker> ReinH: I've not done much proper LA stuff yet, but my brief test found it to be kinda slow.
14:43:24 <ReinH> tasker: which LA libraries?
14:43:29 <tasker> hmatrix
14:43:29 <ReinH> Welkin: But still. Python.
14:43:30 <Fuuzetsu> cmccann: simple, it just drops parens ;P
14:43:32 <voisdl> http://lpaste.net/119438 ????
14:43:38 <tasker> numpy is all in c afaik
14:43:41 <ClaudiusMaximus> > let periods xs = let (m, zs) = head [ (n, ys) | n <- [1..], let ys = take n xs, ys /= nub ys ] ; Just pp = last zs `elemIndex` zs ; p = m - pp - 1 in (pp, p) in periods ("abcd" ++ cycle "efg") -- Welkin
14:43:43 <lambdabot>  (4,3)
14:43:46 <tasker> called from python ofc
14:43:55 <ab9rf> it's thinnish python wrappers around a c library
14:43:59 <cmccann> Fuuzetsu: yes, exactly, you solved the mystery
14:44:00 <tasker> (clearly, all of python is in c.. but you know what i mean)
14:44:17 <IRWolfie-> hmatrix is a bit bare in terms of the lapack routines it wraps though?
14:44:28 <rasen> voisdl: echo $LIBRARY_PATH ?
14:44:41 <voisdl> rasen: empty
14:45:10 <ReinH> tasker: Ah, right. Then surely a Haskell equivalent would be at least as fast.
14:45:11 <tasker> IRWolfie-: Seems so.. but what are the alternatives ?
14:45:21 <tasker> ReinH: Oh, yeah of course. It just doesn't exist :p
14:45:23 <Welkin> ClaudiusMaximus: mind commenting that and putting it on lpaste?
14:45:25 <ReinH> tasker: indeed
14:45:33 <xenocons_> general question (not haskell related really), if you have a document with nodes, and you wish to write a type that models the extraction of the nodes, what would a nice way to model 'optional' composition, for example a node may be a child of another node, so the relationship between parent and child needs to be contained in the model
14:45:40 <xenocons_> (perhaps a question for elsewhere)
14:46:06 <ReinH> xenocons_: with an ADT
14:46:30 <xenocons_> ReinH: thats what i have currently, using a tuple like format bool * (f -> a)
14:46:32 <EvanR> ro-che.info is hilarious
14:46:33 <hexagoxel> voisdl: `hash -r`, try again?
14:46:36 <ab9rf> xenocons_: that's sounds like a fairly typical tree or forest model, ADTs work for that typically
14:46:47 <xenocons_> hmm ok
14:46:53 <xenocons_> sounds like im following the right approach
14:46:56 <voisdl> guys does cabal ever install ghc?
14:47:02 <IRWolfie-> No alternatives I could find from search, I gave up and just called haskell from C which called the right routines. (I'm a newb)
14:47:22 <voisdl> hexagoxel: same problem
14:47:41 <hexagoxel> voisdl: nope; ghc build is a bit too complex for cabal :)
14:47:44 <dizzeehaskell`> EvanR: https://ro-che.info/ccc/22 makes me giggle like a child every single time
14:47:46 <ab9rf> heh
14:47:56 <ClaudiusMaximus> Welkin: sorry, that's left as an exercise - got other things to do (also it will give weird results for things like "hello" ++ cycle " world!", and crashes for some finite lists)
14:49:24 <ReinH> Welkin: Note that that doesn't detect cycles. At best, you can detect a repetition.
14:49:30 <IRWolfie-> I kind of had assumed that full lapack or equivalent would be available since Haskell has been around 25 years. Maybe I'll give it a go in the future when I don't suck at Haskell.
14:49:56 <dizzeehaskell> IRWolfie-: I'm at a lack of things to do recently, I might have a peek into it ;p
14:50:35 <dizzeehaskell> also: that's definitely a Shrek moment there: Haskell's 25?
14:51:09 <IRWolfie-> :P
14:51:17 <jle`> IRWolfie-: if you want to contribute, i know some people who are working together on doing such that :)
14:51:24 <jle`> it's still in development
14:51:27 <voisdl> are haskell packages on ubuntu just blatantly useless?
14:51:40 <rasen> voisdl: ghc-package list | grep transformers-compat
14:51:50 <dizzeehaskell> jle`: who? I'm interested in helping out
14:52:14 <Clint> voisdl: only if you think you need bleeding-edge
14:52:18 <jle`> dizzeehaskell: ask around at #numerical-haskell
14:52:22 <jle`> :)
14:52:23 <IRWolfie-> I'm still probably at the "unreformed C programmer" level so I wouldn't be much of a help yet and busy on the current project.
14:52:42 <voisdl> rasen I dont have the 'ghc-package' command
14:52:51 <glguy> ghc-pkg
14:52:57 <tomphreek> how much ram do you recommend for comfortable haskell development (the program itself won't be ram intensive). just compiling and using cabal to install common packages?
14:53:01 <rasen> ghc-pkg*
14:53:19 <voisdl> rasen:  transformers-compat-0.3.3.4
14:53:39 <koala_man> tomphreek: at least 2GB
14:53:56 <Welkin> tomphreek: I have never has any issues with 4 GB on my system
14:54:00 <Welkin> had*
14:54:15 <rasen> tomphreek: 6 Gb is just fine
14:54:26 <Welkin> I did have issues when I tried to compile yesod on a EC2 micro instance with 512 MB RAM
14:54:29 <koala_man> I have issues with 1.7GB on my system. it's mostly fine, but larger projects start swapping and going really slowly
14:54:30 <Welkin> it broke
14:54:32 <tomphreek> I guess my 1gb linode isn't good enough and 2gb won't fix the issue
14:54:45 <tomphreek> I ll resort to local development
14:54:46 <kadoban> I have 4GB and have had only sporadic problems, mostly only when running ~4 jobs at once that all happened to be pretty RAM intensive compilations.
14:55:25 <ReinH> compilation can take a lot of memory
14:55:37 <ReinH> I've had things top out at 2GB or more
14:55:59 <voisdl> tomphreek: swapfile
14:56:03 <nerium> Is ''++" lazy?
14:56:12 <rasen> nerium: yep
14:56:15 <jle`> @src (++)
14:56:15 <lambdabot> []     ++ ys = ys
14:56:15 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:56:16 <lambdabot> -- OR
14:56:16 <lambdabot> xs ++ ys = foldr (:) ys xs
14:56:20 <jle`> nerium: in what way do you mean?
14:56:29 <Welkin> > take 5 $ "hello" ++ undefined
14:56:31 <lambdabot>  "hello"
14:56:33 <osa1> do I need to add anything other than LANGUAGE CPP to be able to use __GLASGOW_HASKELL__ macro?
14:56:36 <Welkin> I love that trick
14:56:43 <EvanR> > [1,2,3] ++ undefined
14:56:45 <lambdabot>  [1,2,3*Exception: Prelude.undefined
14:56:50 <voisdl> rasen: any other suggestions for the distributive issue?
14:57:01 <nerium> jle`: If I have to infinity long list and do ++ on them, does it terminate?
14:57:06 <tomphreek> voisdl: surely swapping will slow it down considerably?
14:57:13 <jle`> nerium: it depends on what youe ventually evaluate
14:57:20 <dizzeehaskell> *if* you do
14:57:23 <voisdl> tomphreek: it might but it only swaps when it needs to
14:57:32 <jle`> > take 10 $ ([1,2,3] ++ repeat 10)
14:57:34 <lambdabot>  [1,2,3,10,10,10,10,10,10,10]
14:58:00 <cmccann> > take 10 (repeat 10 ++ [1, 2, 3])
14:58:02 <tomphreek> hence the que, how often will it need to?
14:58:02 <lambdabot>  [10,10,10,10,10,10,10,10,10,10]
14:58:23 <ReinH> tomphreek: depends, probably more often than you would like.
14:58:25 <EvanR> > undefined ++ [1,2,3]
14:58:26 <lambdabot>  *Exception: Prelude.undefined
14:58:38 <EvanR> :t (undefined ++)
14:58:39 <lambdabot> [a] -> [a]
14:58:41 <tomphreek> I am considering upping the linode to 2gb and adding ~1-2gb swap. But if it's not enough I won't bother and just do it on the laptop (not preferrable)
14:59:33 <ReinH> tomphreek: have you thought about using fpcomplete?
14:59:33 <voisdl> i use a vps with an ssd with 512mb memory + 2gb swap file and my builds seem to be fairly fast
14:59:40 <cmccann> tomphreek: 1GB might be fine if you're not running anything else and aren't compiling anything really big
15:00:09 <c_wraith> a couple packages, like hxt, require something like 700 megs to link.  They're *painful* to compile with only 512
15:00:11 <monochrom> two infinite lists ++'ed together terminates as much as one single infinite list
15:00:19 <rasen> voisdl: thinking...
15:00:25 <voisdl> 'cabal update' was getting out of memory errors for me without swap
15:00:26 <JagaJaga> There is no guarantee about the order of actions?
15:00:45 <jle`> what actions?
15:00:45 <c_wraith> JagaJaga: depends.  There are guarantees on the order of execution of IO actions.
15:00:51 <EvanR> it has a length of 2 times bottom
15:01:04 <JagaJaga> c_wraith: thx.
15:01:26 <c_wraith> JagaJaga: of course, any uses of unsafeInterleaveIO mess with that.  And several prelude functions use it
15:02:24 <jle`> so, semantically, yes. but there are backdoors to break the contract
15:02:53 <JagaJaga> c_wraith: are talking about that? https://wiki.haskell.org/Evaluation_order_and_state_tokens
15:03:03 <Black0range> Hey guys i just made this little Number to hex converter... are there any way to make it simpler? http://lpaste.net/119441
15:03:05 <voisdl> rasen: someone on the webz suggested to update all cabal packages gona try that now
15:03:39 <voisdl> rasen: something about older packages that were installed with older versio nof cabal
15:03:41 <rasen> voisdl: if that doesn't help, run cabal install -v3 distributive
15:03:47 <voisdl> okay
15:04:05 <tomphreek> ReinH: I use vim for most stuff out of habbit really
15:04:15 <jle`> :t toHexDigit
15:04:16 <henesy> noob here, what is the significance of <- versus =?
15:04:16 <lambdabot>     Not in scope: ‚ÄòtoHexDigit‚Äô
15:04:16 <lambdabot>     Perhaps you meant ‚ÄòisHexDigit‚Äô (imported from Data.Char)
15:04:17 <tomphreek> ReinH: haven't heard of fpcomplete
15:04:32 <Cale> henesy: = defines things to be equal
15:04:48 <Cale> henesy: inside a do-block, v <- x means "execute the action x and call its result v"
15:05:13 <Cale> henesy: Whereas if you wrote  let v = x  it would mean "define v to be the same action as x"
15:05:31 <jle`> henesy: if you are familiar with types, then if, for example, x is of type `IO a`, then v <- x will make `v` be of type `a` (in a do block)
15:05:35 <Cale> henesy: If for example, x :: IO String, and you write v <- x, then v :: String, because it's the result of the IO action
15:05:38 <jle`> oh
15:05:43 <Zemyla> I think I came up with code to make Ratio Integer an instance of Random.
15:06:12 <c_wraith> JagaJaga: that's rather low-level details about GHC's IO implementation..  It's only important if you're doing hacky things that violate the normal way of using IO.
15:06:14 <Pamelloes> Given a list [x1,x2,x3,x4....] and a function f::a->a->a, is there a simple way to make the list [f x1 x2,f x1 x3, f x2 x3, f x1 x4, f x2 x4, f x3 x4, f x1 x5....]?
15:06:30 <ReinH> Pamelloes: zipWith f xs (tail xs)
15:06:52 <Welkin> https://ro-che.info/ccc/25
15:06:53 <Black0range> c_wraith: we should teach him to do unsafeIO :D :D :D
15:07:01 <Cale> ReinH: I think he wants liftM2 f xs xs
15:07:01 <Welkin> who writes this comic?
15:07:18 <ReinH> Cale: Oh I think I misread, yeah
15:07:19 <JagaJaga> c_wraith: so, there is only one guarantee about IO actions?
15:07:23 <Cale> ... though he appears to want it in a different order
15:07:34 <Welkin> oh, I see an authors link
15:07:36 <ReinH> Pamelloes: What ordering is that?
15:07:55 <Cale> Pamelloes: If you're familiar with list comprehensions and haven't explored the fact that list is a monad yet, then [f x y | x <- xs, y <- xs] might also serve you well
15:07:57 <henesy> Cal jle` , thanks, that makes sense. So <- sets something to the output of a function and then = makes a copy of the function more or less?
15:08:14 <ReinH> Cale: I'm not sure. I don't see a f x1 x1 in there
15:08:15 <c_wraith> JagaJaga: the guarantee you should depend on is that in (a >>= b), the action a is performed before b. (and likewise for (a >> b))
15:08:16 <jle`> well, usually they are "values"
15:08:27 <jle`> in general, they are values
15:08:28 <Cale> henesy: Well, in the case with IO, the IO String value isn't a function.
15:08:29 <ReinH> Cale: So I guess first question is "How do you produce that ordering?"
15:08:34 <Cale> henesy: It's an action
15:08:45 <JagaJaga> c_wraith: thank you.
15:08:51 <Cale> henesy: But if you replace "function" with "action" in what you said, then yes.
15:08:52 <Pamelloes> ReinH: An arbitrary one I made up?
15:09:06 <ReinH> Pamelloes: How can we tell you how to apply f to an arbitrary ordering? What's the goal?
15:09:19 <Welkin> x <- y is just syntactic sugar for y >>= (\x -> ...)
15:09:19 <henesy> Cale: trying to get around the learning curve, thank you. That makes sense
15:09:56 <c_wraith> JagaJaga: just be careful of "lazy IO" getting involved.. Things like interact, getContents, hGetContents, readFile, etc..
15:10:00 <Welkin> henesy: practice translating between do-notation and explicit bind
15:10:10 <Pamelloes> ReinH: I want to get all of the combinations of the first n elements in the list. Where n=[1,2..]. Then I want to combine each of these lists togehter
15:10:29 * hackagebot keyword-args 0.1.0.3 - Extract data from a keyword-args config file format  http://hackage.haskell.org/package/keyword-args-0.1.0.3 (jsl)
15:10:35 <ReinH> Pamelloes: what happened to f x1 x1?
15:10:35 <c_wraith> JagaJaga: "lazy IO" uses unsafeInterleaveIO to break that rule in sometimes-unpredictable ways.
15:10:38 <AleksejsHome> Pamelloes: Data.List.permutations
15:11:15 <Cale> ReinH: oh, he doesn't want f x1 x1
15:11:20 <Cale> In that case...
15:11:29 <Pamelloes> ReinH: a property of f is f x x = x, so I omitted repeats like that
15:11:35 <Cale> [f x y | (x:ys) <- tails xs, y <- ys]
15:11:59 <Cale> > [(x,y) | (x,ys) <- tails [1..5], y <- ys]
15:12:01 <lambdabot>  Couldn't match expected type ‚Äò[a0]‚Äô with actual type ‚Äò(t, [t1])‚Äô
15:12:04 <Cale> errr
15:12:08 <Cale> > [(x,y) | (x:ys) <- tails [1..5], y <- ys]
15:12:09 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
15:12:24 <Cale> Pamelloes: Does that look right?
15:12:29 <rasen> no
15:12:34 <Cale> Or do you want a more diagonal ordering?
15:12:56 <rasen> [f x1 x2,f x1 x3, f x2 x3, f x1 x4, f x2 x4, f x3 x4, f x1 x5....]
15:13:00 <cmccann> Cale: I'm guessing Pamelloes wants an ordering that will work "nicely" on infinite lists
15:13:07 <Pamelloes> cmccann: mhm
15:13:15 <cmccann> Cale: i.e. that every combination of the first N elements will be reached in a finite time
15:13:19 <Cale> rasen: But that ordering seems randomly selected.
15:13:31 <Cale> Pamelloes: ah, okay
15:13:39 <Cale> In that case, you have to be more clever
15:13:59 <Pamelloes> That's why I came here,,, I'm not very good with infinite lists :/
15:14:12 <Cale> One easier way to manage is to define an interleave operation like:
15:14:43 <Cale> @let [] /\/ ys = ys; xs /\/ [] = xs; (x:xs) /\/ (y:ys) = x : y : (xs /\/ ys)
15:14:46 <lambdabot>  Defined.
15:15:15 <jle`> ah yes the ol' (/\/)
15:15:39 <Pamelloes> Interesting.
15:15:45 <benzrf> :t (concat .) . zipWith (\a b -> [a, b])
15:15:45 <Cale> @let pairs [] = []; pairs (x:xs) = map (\y -> (x,y)) xs /\/ pairs xs
15:15:46 <lambdabot> [a] -> [a] -> [a]
15:15:46 <lambdabot>  Defined.
15:15:49 <benzrf> :^)
15:15:52 <Cale> > pairs [0..]
15:15:54 <lambdabot>  *Exception: stack overflow
15:15:57 <shiona> > take 10 $ [(x, n-x) | n <- [2..], x <- [1..n-1]]
15:15:58 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1)]
15:15:58 <Cale> oops! :)
15:16:08 <benzrf> @let shittyInterleave = (concat .) . zipWith (\a b -> [a, b])
15:16:09 <lambdabot>  Defined.
15:16:09 <Cale> oh, of course
15:16:27 <benzrf> > shittyInterleave [1, 2, 3] [4, 5, 6]
15:16:29 <lambdabot>  [1,4,2,5,3,6]
15:16:31 <Pamelloes> I have to go. :( Thanks for the input!
15:16:49 <Cale> My interleave was too strict
15:17:39 <ReinH> > [(x,y) | y <- [1..5], x <- [1..pred y]]
15:17:40 <lambdabot>  [(1,2),(1,3),(2,3),(1,4),(2,4),(3,4),(1,5),(2,5),(3,5),(4,5)]
15:17:43 <ReinH> Pamelloes: Is that what you want?
15:17:54 <lucs> 142857
15:18:12 <ReinH> :(
15:18:19 <jle`> hey what's up with the new @check behavior on lambdabot
15:18:25 <Cale> @undefine
15:18:26 <lambdabot> Undefined.
15:18:36 <jle`> > transpose [[1,2,3],[4,5,6]]
15:18:37 <lambdabot>  [[1,4],[2,5],[3,6]]
15:18:57 <Cale> jle`: wait, new @check behaviour?
15:19:27 <jle`> @check \x y -> (not x && not y) == not (x || y)
15:19:28 <lambdabot>  +++ OK, passed 100 tests.
15:19:29 <ReinH> Cale: mine works though right?
15:19:33 <jle`> oh it's different on /q
15:19:56 <jle`> oh wait. that one is the smae too
15:19:57 <voisdl> what is the difference in  'newtype Asdf a b = Asdf (a, b)' and 'newtype Asdf = Asdf (a, b)' ?
15:20:11 <shachaf> voisdl: The second one is an error.
15:20:13 <jle`> @check \xs -> let bft = concat . transpose in (bft . bft) xs == (bft . fmap bft) xs
15:20:17 <lambdabot>  (0 tests) (1 test) (2 tests) (3 tests) (4 tests) (5 tests) (6 tests) (7 test...
15:20:18 <lambdabot>  (82 tests)mueval-core: Time expired
15:20:25 <Cale> ReinH: Which one?
15:20:30 <voisdl> shachaf: I need to have actual types instead of a and b ?
15:20:30 <ReinH> > [(x,y) | y <- [1..5], x <- [1..pred y]]
15:20:31 <lambdabot>  [(1,2),(1,3),(2,3),(1,4),(2,4),(3,4),(1,5),(2,5),(3,5),(4,5)]
15:20:42 <shachaf> voisdl: Well, *someone* has to decide what a and b are.
15:20:44 <Cale> try it on an infinite list?
15:20:59 <voisdl> shachaf: it cant be decided later (where its used) ?
15:21:03 <Cale> > [(x,y) | y <- [1..], x <- [1..pred y]]
15:21:05 <lambdabot>  [(1,2),(1,3),(2,3),(1,4),(2,4),(3,4),(1,5),(2,5),(3,5),(4,5),(1,6),(2,6),(3,...
15:21:09 <ReinH> Cale: should be fine
15:21:09 <Cale> seems to work
15:21:15 <Cale> right
15:21:18 <ReinH> yep
15:21:21 <Cale> (x:xs) /\/ ys = x : (ys /\/ xs)
15:21:25 <Cale> is the interleave I wanted :)
15:21:28 <ReinH> nice
15:21:32 <voisdl> > newtype Asdf = Asdf (a, b)
15:21:34 <lambdabot>  <hint>:1:1: parse error on input ‚Äònewtype‚Äô
15:21:42 <Cale> > let (x:xs) /\/ ys = x : (ys /\/ xs); pairs [] = []; pairs (x:xs) = map (\y -> (x,y)) xs /\/ pairs xs in pairs [0..]
15:21:44 <lambdabot>  [(0,1),(1,2),(0,2),(2,3),(0,3),(1,3),(0,4),(3,4),(0,5),(1,4),(0,6),(2,4),(0,...
15:21:46 <voisdl> oh
15:22:21 <Cale> It's quite a different search order though :)
15:22:46 <Cale> (every other element has 0 as the first component, and then every other of the elements remaining has 1, and so on)
15:23:27 <voisdl> shachaf: you need to declare the a and b in the signature so you can pattern match it later?
15:23:50 <shachaf> voisdl: I'm not sure what behavior you're expecting for the unparameterized version.
15:24:03 <Cale> > let [] /\/ ys = ys; (x:xs) /\/ ys = x : (ys /\/ xs); pairs [] = []; pairs (x:xs) = map (\y -> (x,y)) xs /\/ pairs xs in pairs [1..5]
15:24:04 <lambdabot>  [(1,2),(2,3),(1,3),(3,4),(1,4),(2,4),(1,5),(4,5),(2,5),(3,5)]
15:24:43 <ReinH> Cale: Ah, that's the Omega ordering or w/e?
15:24:44 <voisdl> shachaf: I expect to use it as foo :: Asdf (Int, Int) -> Blah
15:24:57 <rasen> Are Haskell arrows same as  functors in C++?
15:25:13 <Cale> I'm not sure if this ordering has a name? It ought to.
15:25:16 <voisdl> shachaf: same as you use the first versrion but you declare the type by using the constructor pattern
15:25:22 <ReinH> Cale: I mean the one you can get using the Omega monad https://hackage.haskell.org/package/control-monad-omega
15:25:30 * hackagebot smtp-mail-ng 0.1.0.1 - An SMTP client EDSL  http://hackage.haskell.org/package/smtp-mail-ng-0.1.0.1 (alexvieth)
15:25:48 <ReinH> e.g., , runOmega $ liftM2 (,) (each [0..]) (each [0..])
15:27:40 <Zemyla> So if Random Random Ratio were instantiated, would people want (Integral a) => Random (Ratio a)?
15:29:52 <Zemyla> Probably not. Does anyone use non-Integer Rationals?
15:30:58 <glguy> It would probably be hard to come up with a general purpose Random instance for Rational
15:31:51 <Zemyla> I think I just did.
15:31:55 <glguy> You'd want arguments for both the range as well as the granularity
15:32:02 <glguy> which won't fit in the type class
15:32:08 <voisdl> does the fpcomplete ide include package management and stuff (what haskell platform does) ?
15:34:05 <Zemyla> glguy: Well, the default granularity would be gran ra rb = let m = lcm (denominator ra) (denominator rb) in dm * ceiling (toRational (range g) / dm).
15:34:24 <stool> > fold [1,2] :: Int
15:34:25 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Int)
15:34:25 <lambdabot>    arising from a use of ‚ÄòData.Foldable.fold‚Äô
15:34:30 <stool> Why not?
15:34:32 <Zemyla> That way, it's at least as granular as the original generator.
15:34:45 <dutchie> http://lpaste.net/92656 < seeing this error that apparently one other person on the internet has seen: https://stackoverflow.com/questions/18913727/cabal-error-for-llvm-general
15:34:51 <glguy> stool: Because of what you pasted
15:35:02 <dutchie> any suggestions? the definition of findJustBy looks sane to me
15:35:55 <dutchie> though i'm running arch with cabal 1.22
15:36:26 <rasen> stool: there are two Monoid instances for Int
15:36:28 <stool> Oh, right.
15:36:30 <stool> Yah.
15:36:32 <chpatrick1> stool: you probably want some Monoid wrapper like Sum
15:36:42 <rasen> > fold [Sum 2, Sum 3]
15:36:44 <dutchie> the llvm-general Setup.hs is too terrifying to contemplate
15:36:44 <lambdabot>  Sum {getSum = 5}
15:36:51 <stool> rasen, Thanks.
15:37:25 <glguy> > ala Sum foldMap [2,3,4] -- if you're feeling adventurous
15:37:27 <lambdabot>  9
15:37:43 <stool> wow
15:37:52 <glguy> (or just sum)
15:38:01 <rasen> There is also Product
15:38:22 <rasen> > fold [Product 2, Product 3]
15:38:24 <lambdabot>  Product {getProduct = 6}
15:39:46 <rasen> :t ala
15:39:47 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
15:42:31 <simon> woohoo, I used Rank2Types for something constructive for the first time!
15:44:46 <oio> whats your editor of preference
15:44:48 <oio> ?
15:44:53 <Zemyla> glguy: I feel that you should provide a sensible default for Random Rationalmand provide a separate faculty for specified granularity.
15:44:54 <Xe> I like vim
15:45:16 <rasen> oio: Vim
15:45:27 <Axman6> I quite like Sublime because I can use it anywhere if I need to
15:45:29 <Xe> rasen: I like you
15:45:37 <glguy> rasen: ala Sum :: ((a -> Sum a) -> e -> Sum b) -> e -> b -- slightly less terrifying when the type families go away
15:45:41 <Zemyla> Xe: I like vim too.
15:46:39 <Zemyla> Also, I figured out how to have random numbers of specific granularity in the Random class.
15:47:24 <Zemyla> data Granular a = Granular { deGran :: a, granu :: Integer }
15:47:54 <oio> vim... mmm interesting
15:48:31 <rasen> So what's up with arrows? Are they same as C++ functors?
15:49:35 <rasen> when arr is operator()
15:49:40 <Axman6> I would be surpriaed if the answer is yes
15:50:20 <Axman6> surprised even
15:50:58 <Welkin> arrows are abstractions of functions
15:51:49 <rasen> C++ functors too. They are also called function objects
15:51:54 <Welkin> the arrow a b c is (->) b c
15:51:54 <Axman6> Perhaps Kleisli IO a b would be similar to C++ functors
15:52:56 <benzrf> rasen: arrows are...
15:52:58 <benzrf> rasen: well
15:53:00 <benzrf> nobody uses them
15:53:02 <benzrf> they gross
15:53:07 <benzrf> or so i am told
15:53:28 <Axman6> I always found them too confusing to be useful
15:53:39 <benzrf> Arrow is a subclass of Category
15:53:51 <Welkin> I had to learn arrows to use netwire
15:53:56 <benzrf> that adds a functor from Hask to the category... and also some kind of paralell thing?
15:54:02 <benzrf> *parallel
15:54:14 <rasen> Axman6: But if we can have pure-functional functors
15:54:14 <benzrf> i think they were invented as a generalization of kleisli categories
15:55:40 <rasen> oops... confused what arr means. arr is not operator()
15:56:18 <EvanR> did they add whitespace overflowing in c++ yet
15:56:21 <EvanR> overloading*
15:56:39 <rasen> Maybe in C++20?
15:56:58 <EvanR> ah right http://www.stroustrup.com/whitespace98.pdf
15:58:04 <josephle> rasen: I'd think std::function is more like arr
15:58:12 <josephle> since it abstracts all "callable" objects
15:58:42 <rasen> And arr is constructor?
15:58:55 <EvanR> :t arr
15:58:56 <lambdabot> Arrow a => (b -> c) -> a b c
15:59:09 <nshepperd_> C++ function objects are most similar to regular haskell closures, I think
15:59:45 <rasen> EvanR: lol. Haven't seen that proposal before
15:59:49 <josephle> erm, std::function is more like arrows
15:59:50 <nshepperd_> in that the main reason for "function objects" is to let you capture a context
16:00:22 <josephle> but c++ also has closures, which allow you to capture a context
16:00:23 <Axman6> EvanR: looks like a great proposal to remove syntax to make things more confusing
16:00:43 <nshepperd_> as opposed to a function pointer, which requires you to pass void* pointers and all that junk
16:01:11 <nshepperd_> josephle: yes, doesn't that output a "function object"?
16:01:19 <josephle> heh, it does :P
16:03:44 <josephle> anyway, std::function accepts function pointers, lambdas, functors, and other things that implement operator()
16:04:04 <josephle> that's my argument for claiming it is similar to arrow
16:05:24 <rasen> I agree. std::function is much better candidate than function objects
16:05:37 <juanpablo__> Is there a way I can fold a stream of [[a]] to a stream of [a] in conduit?
16:05:44 <rasen> Despite fact, it's function object)
16:05:51 <juanpablo__> A conduit I mean, not a sink
16:05:52 <nshepperd_> the purpose of arrows is mainly composition of them
16:07:08 <rasen> nshepperd_: it's doable with a bit of templates
16:08:38 <nshepperd_> whereas the main point of c++ function objects is just letting you have 'functions' with associated data...
16:10:30 <nshepperd_> the only arrow combinator useful for that is 'arr' and that only works if the "associated data" has some default value you can set it to
16:11:39 <rasen> Didn't get it. arr is for lifting function to arrow. That's what std::function constructor does
16:11:45 <nshepperd_> the equivalent in haskell is probably just an ordinary data type holding a function together with a value
16:12:29 <rasen> what value?
16:13:58 <nshepperd_> whatever you need, if you need any inspectable value
16:14:46 <nshepperd_> if you don't need to inspect anything, and just need to be able to call it, an ordinary haskell function will do
16:14:55 <rasen> I believe partial application is better choose
16:16:31 <rasen> In that way, partial application brings associated data and arr lifts new function to arrow
16:17:08 <Ankhers> Would anyone mind letting me know how I would be able to accomplish the following in haskell, http://lpaste.net/119451 (bad pseudo code)? I'm not looking for actual code, just what I should be looking up.
16:17:17 <nshepperd_> there's no need to lift anything to arrows
16:17:30 <rasen> But arr is just for that
16:18:01 <rasen> Ankhers: you're looking for forkIO?
16:18:03 <rasen> :t forkIO
16:18:05 <lambdabot> Not in scope: ‚ÄòforkIO‚Äô
16:18:32 <Ankhers> rasen: Sorry, I should have been more specific. How would I be able to use something like `myGlobalVar`.
16:19:06 <Ankhers> In this case, it obviously mutates, and updates itself every n seconds.
16:19:39 <rasen> you could do myGlobalVar = unsafePerformIO $ newTVarIO defaultValue
16:19:51 <nshepperd_> Ankhers: I think the search terms are maybe MVar or TVar
16:19:55 <rasen> or encapsulate all state and pass it explicitly
16:20:05 <Ankhers> I would prefer to stay away from unsafePerformIO.
16:20:18 <Ankhers> nshepperd_: Thanks, I will look into that.
16:20:30 <rasen> Then, encapsulate all state and pass it explicitly
16:25:17 <SrPx> What is a lazy way to return the first "Just" element of a list :: [Maybe a]?
16:25:38 <SrPx> I was doing it with foldr, but I guess it is not lazy that wa
16:26:57 <SrPx> ah actually seems like it is lazy o.O but... hmmmmm
16:27:18 <benzrf> :t ala First foldMap
16:27:19 <lambdabot> Foldable t => t (Maybe b) -> Unwrapped (First b)
16:27:31 <ClaudiusMaximus> > listToMaybe . catMaybes $ [Nothing, Nothing, Just 3, Nothing, Just 4, Nothing]
16:27:33 <lambdabot>  Just 3
16:27:44 <benzrf> > ala First foldMap [Nothing, Just 3, Just 4]
16:27:45 <lambdabot>  Just 3
16:28:12 <glguy> > preview (folded.folded)  [Nothing, Just 3, Just 4]
16:28:12 <c_wraith> > ala First foldMap $ Nothing : Just 3 : undefined
16:28:14 <lambdabot>  can't find file: L.hs
16:28:14 <lambdabot>  Just 3
16:28:19 <Ankhers> :t catMaybes
16:28:20 <lambdabot> [Maybe a] -> [a]
16:28:22 <c_wraith> concurrency issues!
16:28:23 <benzrf> :t folded
16:28:24 <lambdabot> (Contravariant f1, Indexable Int p, Foldable f, Applicative f1) => p a (f1 a) -> f a -> f1 (f a)
16:28:26 <c_wraith> > ala First foldMap $ Nothing : Just 3 : undefined
16:28:27 <lambdabot>  Just 3
16:29:56 <benzrf> oh i see
16:30:09 <benzrf> > [1, 2, 3]^.folded
16:30:11 <lambdabot>  No instance for (GHC.Show.Show a0)
16:30:11 <lambdabot>    arising from a use of ‚ÄòM32764206939569080022710.show_M32764206939569080022...
16:30:11 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
16:30:16 <benzrf> oh poo
16:30:32 * hackagebot snaplet-redis 0.1.4.2 - Redis support for Snap Framework  http://hackage.haskell.org/package/snaplet-redis-0.1.4.2 (DmitryDzhus)
16:30:43 <benzrf> > [1, 2, 3]^?folded
16:30:44 <lambdabot>  Just 1
16:30:49 <benzrf> wait
16:30:54 <benzrf> oooooh i see
16:31:11 <benzrf> 'traverse' for Foldables
16:31:16 <benzrf> :t traversed
16:31:17 <lambdabot> (Indexable Int p, Traversable f, Applicative f1) => p a (f1 b) -> f a -> f1 (f b)
16:31:29 <SrPx> listToMaybe, interesting. Thanks!
16:31:57 <SrPx> much better than (foldr (\ a b -> case a of { Nothing -> b; Just a -> Just a })
16:33:35 <tel-> You can just use msum, right?
16:33:38 <rasen> (\ a b -> case a of { Nothing -> b; Just a -> Just a }) == mplus
16:33:42 <tel-> > msum [Nothing, Just 3, Just 4]
16:33:43 <lambdabot>  Just 3
16:34:07 <rasen> > msum [Nothing, Just 3, undefined]
16:34:08 <lambdabot>  Just 3
16:34:55 <tel-> It's identical to the foldr, it's (foldr mplus mempty)
16:35:26 <tel-> er, mzero
16:35:38 <tel-> msum = foldr mplus mzero
16:39:02 <horny-sama> with my haskell hw due soon, I am freaking my ass out
16:39:16 <joness> edwardk cool thanks
16:52:31 <horny-sama> right now, my team is so disoriented
16:52:36 <horny-sama> I am pretty sure I am screw
16:56:43 <chirpsalot> horny-sama: it's probably fine :).
16:56:53 <chirpsalot> Just don't panic and it will be all good.
16:58:18 <horny-sama> chirpsalot: I need to come up with a playing strategy for https://github.com/LtGrimms/OthelloAssignment/blob/master/Othello.hs and right now I am clueless
16:58:31 <rasen> Just realized what hw means. Thought of hardware first
16:58:57 <horny-sama> rasen: seriously?
16:59:00 <horny-sama> hardware?
17:00:28 <horny-sama> is there a way to ensure getArgs is treating the input as string?
17:00:30 <rasen> Yep. I work with embedded c. that's why
17:00:32 <nerium> How do I convert float to int?
17:00:39 <horny-sama> I try argument <- getArgs :: String
17:00:45 <nerium> I tried using 'round' but that only returns a RealFrac
17:00:54 <horny-sama> rasen: I have a c interview like on friday
17:00:57 <horny-sama> and I am screw
17:01:02 <horny-sama> have not use c for ages
17:01:19 <rasen> horny-sama: getArgs is IO [String]
17:01:32 <horny-sama> rasen: cool
17:01:39 <rasen> you could do [argument] <- getArgs
17:02:18 <cmccann> nerium: no it doesn't
17:02:21 <cmccann> :t round
17:02:22 <lambdabot> (RealFrac a, Integral b) => a -> b
17:02:42 <cmccann> it takes a RealFrac argument, the result is Integral
17:02:52 <horny-sama> rasen: benefit to it?
17:02:59 <joness> > concat <$> getArgs
17:03:01 <lambdabot>  Not in scope: ‚ÄògetArgs‚Äô
17:03:23 <joness> unwords is probably better instead of concat
17:03:28 <joness> than*
17:03:51 <Hafydd> horny-sama: have you considered the obvious choice of a min-max adverserial search with alpha-beta pruning?
17:03:52 <cmccann> horny-sama: what string do you expect getArgs to give you?
17:04:00 <horny-sama> Hafydd: ?
17:04:07 <Hafydd> What?
17:04:14 <Welkin> getArgs :: IO [String]
17:04:16 <horny-sama> cmccann: I don't know
17:04:17 <Welkin> :t getArgs
17:04:18 <lambdabot> Not in scope: ‚ÄògetArgs‚Äô
17:04:31 <horny-sama> Hafydd: "min-max adverserial search with alpha-beta pruning"
17:04:38 <cmccann> horny-sama: then perhaps you should decide what you want the code to do first, and worry about how to write it afterwards
17:04:42 <Welkin> it gives you a list of the command line arguments as strings
17:04:48 <Welkin> but wrapped in IO
17:04:50 <Hafydd> horny-sama: yes. There is a lot of literature on those things if you don't know what they are.
17:05:07 <nerium> cmccann: Sorry, I'm getting integral
17:05:28 <horny-sama> cmccann: that's not my part
17:05:28 <horny-sama> my part is to come up with a strategy
17:05:28 <horny-sama> rest of it is m-okay
17:05:28 <horny-sama> :P
17:05:29 <Hafydd> *adversarial
17:06:24 <cmccann> horny-sama: then why are you worrying about what getArgs is doing at all?
17:06:32 <horny-sama> Hafydd: http://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning ?
17:07:03 <nerium> So how do I convert an Integer to Int?
17:07:19 <rasen> nerium: fromIntegral
17:07:20 <joness> :t fromIntegral
17:07:21 <lambdabot> (Num b, Integral a) => a -> b
17:07:46 <horny-sama> Hafydd: but my prof said no tree
17:07:48 <horny-sama> only list
17:07:57 <horny-sama> so your way won't work
17:08:01 <Hafydd> horny-sama: what?
17:08:12 <Hafydd> What does "no tree, only list" mean?
17:08:24 <ReinH> Well, game trees are trees.
17:08:32 <horny-sama> Hafydd: Alpha‚Äìbeta_pruning is a tree algorithm
17:08:33 <cmccann> nerium: if you're using round, you can get an Int from that by itself
17:08:42 <horny-sama> ReinH: we don't have tree in my game
17:09:00 <ReinH> What?
17:09:07 <ReinH> horny-sama: can people/actors make decisions in your game?
17:09:17 <horny-sama> ReinH: no
17:09:18 <nerium> cmccann: This is what I*m trying to do https://gist.github.com/oleander/2d7e18dce5fd0caa7025
17:09:22 <ReinH> horny-sama: then what sort of game is it?
17:09:27 <horny-sama> just a computer strategy palying against another
17:09:31 <horny-sama> ReinH: a simulator
17:09:37 <horny-sama> it is not a "game"
17:09:40 <ReinH> horny-sama: how do they play against each other?
17:09:56 <horny-sama> ReinH: you select two strategy and it plays against itself
17:09:59 <horny-sama> :P
17:10:01 <ReinH> what
17:10:04 <ReinH> then what is your task?
17:10:07 <cmccann> nerium: does it not work if you remove the fromIntegral?
17:10:34 <horny-sama> ReinH: create three strategy
17:10:35 <Hafydd> horny-sama: it's possible to implement the minimax algorithm without storing data in an explicit tree structure, if that's what you're worried about.
17:10:35 <cmccann> nerium: also, you're trying to round something that's already an Int
17:10:54 <ReinH> horny-sama: And your strategies... do they have to make moves?
17:10:55 <nerium> cmccann: Aha, is it
17:10:56 <nerium> I'll try
17:10:56 <horny-sama> Hafydd: yes, it is possible but is it easy?
17:11:02 <horny-sama> ReinH: yes
17:11:10 <Hafydd> horny-sama: it's reasonably easy.
17:11:10 <ReinH> horny-sama: and for each move, is there only ever exactly one choice?
17:11:16 <cmccann> nerium: dist is an Int, and * expects both arguments to be the same type
17:11:25 <augur> is there a good tutorial for how to set up a Proper Haskell Project?
17:11:30 <horny-sama> ReinH: probably
17:11:37 <cmccann> nerium: so you're getting errors because sin and cos don't work on Int
17:11:44 <augur> like, the sort of project that could be put on hackage?
17:11:52 <ReinH> horny-sama: Then how can you make three different strategies?
17:12:01 <ReinH> There is only one strategy: make the only move available.
17:12:05 <nerium> cmccann: how do I convert one of the args to float?
17:12:07 <horny-sama> ReinH: good question but with no answer
17:12:09 <ReinH> But I suspect that isn't actually true.
17:12:30 <cmccann> nerium: fromIntegral, actually :)
17:12:42 <horny-sama> ReinH: basically my prof told us to come up with three different strategy and go fuck ourselves
17:12:43 <horny-sama> :P
17:13:00 <cmccann> nerium: "round $ fromIntegral dist * sin (fromIntegral angle)"
17:13:09 <ReinH> horny-sama: I can't actually believe that this game is trivial in that way.
17:13:17 <ReinH> No professor would be that stupid,
17:13:35 <ReinH> horny-sama: what sort of moves can your strategy make while playing this game?
17:13:45 <nerium> cmccann: That worked, thanks!
17:14:00 <horny-sama> ReinH: two weeks of haskell learning what do you want
17:14:05 <rasen> ReinH: professors can be even worse
17:14:27 <joness> is your game rock-paper-scissors? :P
17:14:41 <horny-sama> ReinH: http://kremer.cpsc.ucalgary.ca/courses/cpsc449/W2015/assnHaskell.html <---see for yourself
17:15:02 <ReinH> horny-sama: what the hell
17:15:05 <ReinH> It's the board game othello
17:15:21 <ReinH> horny-sama: Why lie to people when you are asking them for help?
17:15:39 <ReinH> Or do you actually somehow believe that an othello player only has one choice of move on every turn?
17:15:51 <horny-sama> ReinH: honestly yes
17:15:55 <ReinH> horny-sama: what
17:16:08 <ReinH> That's ridiculous.
17:16:15 <Hijiri> Playing othello is like carving out a beautiful monochrome painting, you are just bringing it out of the canvas
17:16:33 <ReinH> horny-sama: You can obviously choose at least one place to play your piece on most turns.
17:16:39 <ReinH> er, more than one place
17:16:41 <cmccann> horny-sama: you realize there's a link to an online version of othello right on that page, which starts with having multiple moves available to the user
17:17:12 <ReinH> I'm starting to think that horny-sama is an elaborate troll. Inappropriate sexual humor, things like this. I don't like it.
17:17:41 <horny-sama> cmccann: that's a demo
17:17:51 * ReinH facepalms
17:18:09 <horny-sama> cmccann: what is the key word that you search for?
17:18:31 <ReinH> And yes. Games have game trees.
17:18:32 <cmccann> horny-sama: if you can't understand the assignment itself this is the wrong place to ask for help
17:18:40 <ReinH> That is sort of a defining characteristic.
17:19:07 <ReinH> Indeed.
17:19:19 <cmccann> horny-sama: feel free to come back if you have questions about Haskell after you've figured out what you're actually supposed to be doing
17:19:26 <horny-sama> cmccann: http://www.web-games-online.com/reversi/ <---you mean this thing
17:19:29 <nerium> What's the name of the "sin" function that takes grades instead of radius?
17:19:53 <horny-sama> cmccann: I figure out I need to create a strategy
17:20:19 <nerium> Sorry, not grades. degres
17:20:35 * hackagebot jose-jwt 0.3 - JSON Object Signing and Encryption Library  http://hackage.haskell.org/package/jose-jwt-0.3 (LukeTaylor)
17:20:49 <danielszmulewicz> Hi, I was wondering if I can make ghci display parens when asking for type signatures. Or is this anathema?
17:21:10 <cmccann> nerium: it's named "sin, after you convert the input to radians"
17:21:40 <nerium> cmccann: Hehe, thanks
17:21:41 <joness> > (+)
17:21:43 <lambdabot>  <Integer -> Integer -> Integer>
17:22:12 <joness> I would like if ghci did this when the result was a function, instead of throwing a scary error
17:22:29 <joness> can it be done?
17:22:43 <cmccann> joness: if you want to check the type of something, use :t
17:22:49 <nerium> cmccann: Should it be possible to just import Data.Angle?
17:22:52 <nerium> using import Data.Angle
17:22:59 <joness> cmccann I know that
17:24:01 <joness> the error doesn't scare me personally, but it might be scary to someone new to haskell. anyway, is there a way to override this behavior?
17:24:04 <cmccann> nerium: I'm not sure where that module is coming from, I don't think it's standard?
17:24:44 <nerium> cmccann: I guess this is from an external package https://hackage.haskell.org/package/AC-Angle-1.0/docs/Data-Angle.html
17:25:35 * hackagebot gl 0.7.1 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.7.1 (EdwardKmett)
17:25:42 * SrPx wishes we had some kind of "auto-import" for haskell plugin on vim :( 
17:25:57 <SrPx> so much time spent
17:26:55 <cmccann> nerium: using that package just to convert degrees to radians seems like overkill...
17:27:54 <cmccann> joness: you mean the error about not having a Show instance? the way to override that should be self-explanatory.
17:29:06 <joness> cmccann not sure if it is self-epxlanatory how to pull out type signature as a string from a function.. but please do tell how
17:30:32 <cmccann> joness: it isn't, in general. lambdabot handles some cases, but not all.
17:30:38 <joness> I thought I would have to hook into ghci's output. geeration somehow. but if it can be done within haskell then all the better
17:30:58 <cmccann> anyway, a Show instance for functions isn't something that you'd really want in general
17:31:03 <joness> cmccann hmm. so that was false advertisement :(
17:31:27 <shachaf> I do think that GHCi's error when you type something that isn't Show isn't very friendly.
17:31:29 <danielszmulewicz> When ghc tells me f :: a -> b -> c, I would appreciate to visualize this as f :: a -> (b -> c). I believe it becomes second nature after a while, but for noobs like me it would be helpful.
17:32:00 <cmccann> joness: well, note that the type lambdabot showed you for (+) isn't even completely correct
17:32:00 <shachaf> It's not an arbitrary no instance error, it's a specific one. It would be nice if it just printed the type.
17:32:07 <shachaf> (The real type, not the one you can get with Typeable.)
17:32:09 <cmccann> > (+)
17:32:11 <lambdabot>  <Integer -> Integer -> Integer>
17:32:12 <cmccann> :t (+)
17:32:13 <lambdabot> Num a => a -> a -> a
17:33:37 <cmccann> shachaf: that would entail modifying GHCi itself though :[
17:33:43 <shachaf> cmccann: Yep.
17:33:59 <shachaf> But it would be a much nicer experience to be able to just type an expression and get whatever information you can about it.
17:34:05 <cmccann> that is true
17:34:28 <cmccann> joness: there's your answer, I guess. feel like modifying GHCi and submitting a patch to GHC's maintainers? :P
17:34:44 <shachaf> I think a Trac ticket requesting this wouldn't be unreasonable.
17:35:27 <cmccann> I volunteer shachaf to implement the functionality
17:35:34 <joness> that i can do
17:36:35 <shachaf> You don't need to volunteer me, cmccann has already done it.
17:37:59 <cmccann> ok I retract my statement, and volunteer joness to volunteer shachaf to implement the functionality
17:38:39 <shachaf> I covolunteer cmccann to do it.
17:39:19 <cmccann> I can't do it because you already put me in charge of not doing all the things you don't do. like, last year or something.
17:40:08 <shachaf> Presumably when I covolunteering you that's the same as you volunteering me. But I feel like I'm taking initiative.
17:40:13 <shachaf> Anyway it must've been at least two years ago.
17:40:16 <cmccann> but since I'm taking care of all the things you aren't doing you should have plenty of time for doing other things
17:40:33 <cmccann> yeah probably
17:40:53 <cmccann> back when elliott was around :[
17:41:00 <shachaf> You're taking care of not doing all the thing I wouldn't be doing otherwise. So I'm too busy doing them to do your thing.
17:41:04 <shachaf> But this isn't really the channel for that.
17:48:09 <Zemyla> Oh, you know how I wanted an instance (Monoid a, Applicative m) => Monoid (SomeNewtype m a)?
17:48:40 <Zemyla> Why not just have it be WrappedMonad?
17:49:13 <Zemyla> Or, like, WrappedApplicative.
17:54:43 <enthropy> hi there. Do people know of this approach for defunctionalization: http://lpaste.net/119460 ?
17:55:12 <zipper> Which package provides Data.Default.Util ?
17:57:02 <mniip> is there something to apply a function to a TVar?
17:57:25 <mniip> oh
17:57:28 <mniip> modifyTVar
17:58:32 <mniip> now question, how good is modyfying complex TVar performance-wise
17:58:44 <mniip> modifying a*
18:00:31 <cmccann> mniip: I don't think updating the TVar will necessarily force any of the value it holds to be evaluated
18:00:36 * hackagebot text-show 0.6 - Efficient conversion of values into Text  http://hackage.haskell.org/package/text-show-0.6 (ryanglscott)
18:00:49 <mniip> cmccann, no I mean like if I have a list in there
18:01:04 <mniip> and then `modifyTVar a (0:)`
18:01:07 <rasen> There is strict modifyTVar'
18:01:12 <cmccann> mniip: so it should be the same performance as modifying any other TVar
18:01:38 <mniip> will it not copy the entire list?
18:01:41 <cwl> I have ToJSON instance for ByteString in File1.hs, and want to use this instance in File2.hs. What should I do?
18:01:42 <cmccann> mniip: right, and unless you do something to force the result the application of (0:) to the current value will be a thunk
18:02:03 <ReinH> cwl: import File1
18:02:04 <cmccann> mniip: that's unrelated to TVars, but in that case no
18:02:10 <cwl> File2.hs have some type containing ByteString
18:02:18 <ReinH> cwl: although a ToJSON instance for ByteString seems like a bad idea
18:02:20 <mniip> ok
18:02:34 <rasen> mniip: (:) doesn't copy list
18:02:45 <mniip> I know
18:02:51 <mniip> but does modifyTVar
18:02:55 <mniip> that's the question
18:03:06 <cmccann> mniip: the TVar doesn't care what's in it
18:03:08 <nshepperd_> TVar itself only contains a pointer to the contents
18:03:22 <ReinH> Oh, there isn't a built-in instance for ByteString
18:03:27 <cwl> ReinH, better to manually convert it to Text first?
18:03:37 <ReinH> cwl: What's the issue with importing File1?
18:05:24 <cwl> ReinH: File2 seems more low level. File1.hs is src/Database/PostgreSQL/Simple/Types.hs, File2.hs is src/Database/PostgreSQL/Simple/TypeInfo/Types.hs
18:06:37 <cwl> Should I make this instance in another file, File3.hs? Both File1.hs and File2.hs import this File3.hs
18:08:25 <joness> will (<&>) be part of the new ghc as well, or just (&)?
18:08:39 <ReinH> cwl: That seems reasonable.
18:09:30 <ReinH> cwl: You could use this http://jaspervdj.be/posts/2015-01-20-haskell-design-patterns-extended-modules.html
18:09:44 <cwl> ReinH, where should I put file3.hs? src/Data/ByteString.hs?
18:12:17 <ReinH> cwl: Well, it's an extension to aeson, isn't it?
18:12:27 <cwl> ReinH, yes
18:12:39 <ReinH> cwl: Then you might consider the naming pattern from that post
18:12:58 <joness> > let (<&>) = flip (<$>) in getLine <&> map toUpper <&> words <&> unlines >>= putStrLn
18:12:59 <lambdabot>  <IO ()>
18:13:20 <cwl> ReinH: how about src/Data/Aeson/ByteString.hs ?
18:13:28 <joness> <&> is neat, we need it in Data.Function/Control.Applicative :). it already exists in lens
18:13:32 <ReinH> cwl: How about what the post recommends?
18:14:23 <cwl> ReiH: sorry, which post?
18:14:36 <cwl> ha
18:14:39 <cwl> aha
18:14:51 <cwl> ReiH: I see
18:15:02 <cwl> ReiH: Thank you
18:15:08 <ReinH> cwl: np
18:15:37 * hackagebot monoid-subclasses 0.4.0.3 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.4.0.3 (MarioBlazevic)
18:20:37 * hackagebot text-show-instances 0.2 - Additional instances for text-show  http://hackage.haskell.org/package/text-show-instances-0.2 (ryanglscott)
18:33:13 <edwardk> joness: part of why it hasn't been proposed is that even (&) was quite controversial, there is a very vocal crowd against it, and (<&>) doesn't have the 'obvious' fixity, because of lessons we learned when trying to use it in lens
18:33:41 <edwardk> joness: so rather than have it bikeshedded to a form with a less useful fixity and break all the code that was written with it, we decided to just leave it alone
18:33:44 <joness> edwardk I see
18:34:36 <benzrf> why would anybody be against (&) ;-;
18:34:39 <edwardk> joness: just figured i'd give the full rundown before someone ran off and tried to helpfully standardize it ;)
18:35:04 <edwardk> benzrf: lots of 'its not haskelly arguments compounded with alternative names, compounded with alternate fixities, compounded with whatever..
18:35:26 <benzrf> how silly
18:35:34 <edwardk> *shrugs*
18:35:51 <edwardk> in the end it went to the core libraries minus me and passed through
18:36:05 <edwardk> after folks kept trying to bring it up in libraries@ proposals
18:36:14 <Cale> benzrf: Because it uses up namespace on something which we already have a name for
18:36:17 <edwardk> yitz proposed it the first time around and we backed off it unilaterally
18:36:38 <pacak> benzrf: When I play around with new libraries I tend to have ghci session running and using :t a lot. It's impossible to use (&) in this kind of workflow.
18:36:41 <edwardk> flip ($) is very concise ;)
18:37:07 <joness> edwardk would you use a different fixity for <&> if you were to implement it today? if so which one?
18:37:09 <edwardk> anyways, there were somewhat legitimate concerns about it
18:37:20 <edwardk> joness: i would use the fixity for <&> that we have in lens
18:37:21 <Cale> If you need it as an argument to some other higher order function, I don't see the problem with just using flip id or flip ($)
18:37:37 <Cale> And if you're actually writing things infix, just use $ normally?
18:37:47 <edwardk> it enables you to substitute it for >>= which is a far more common substitution and (<&>) doesn't fit into a <$> <*> etc chain so matching those fixities is suboptimal
18:38:35 <edwardk> cale is one of those who was down on the addition of (&), but he's kinda mellow =)
18:38:44 <ReinH> Cale: It looks better with lens setter operators, I suppsoe.
18:38:48 <Cale> I guess I don't understand why people would want the arguments to be in the other order?
18:38:58 <Cale> I would encourage people not to write things like that
18:39:00 <bjkodpf> how can I search hoogle for a particular package?
18:39:04 <Cale> because it's in the opposite order from composition
18:39:25 <bjkodpf> that is search for a function but only in one package
18:39:28 <ReinH> Cale: but that's how the setter operators are designed
18:39:31 <Cale> Obviously it ultimately doesn't matter which order we choose, but it seems best if we stick to one
18:39:43 * edwardk ducks out, because a style war has no winners
18:39:56 <Cale> and since function application's convention is "f x" and not "x f", then that's what we should try to stick to
18:39:58 <joness> Cale it is sometimes nicer to read long chain of function applications from left to right. same with (<&>), it plays nice with >>=
18:40:20 <bjkodpf> is there an alternative of hoogle for 3rd party libraries?
18:40:25 <adu> edwardk: we should paint the shed blue!
18:40:27 <ReinH> I don't particularly like >>= either
18:40:29 <Cale> (=<<) is a thing
18:40:38 * hackagebot record 0.2.1 - First class records implemented with quasi-quotation  http://hackage.haskell.org/package/record-0.2.1 (NikitaVolkov)
18:41:06 <rasen> I like both >>= and =<<
18:41:42 <nkar> do I need to rm -rf ~/.cabal/packages/* if I already removed the packages in ~/.ghc/x86_64-linux-7.8.4/package.conf.d?
18:41:55 <bjkodpf> hey rasen im that guy that had the cabal issues earlier - reinstalling all packages with --reinstall --force-reinstalls fixed the issues
18:42:26 <rasen> bjkodpf: glad to hear
18:42:46 <bjkodpf> someone mentioned a hoogle like site for 3rd party libraries
18:42:54 <bjkodpf> does anyone know of such a thing?
18:43:07 <shachaf> bjkodpf: Maybe you mean Hayoo?
18:43:09 <nkar> fpcomplete.com/hoogle?
18:43:12 <bjkodpf> ah yes that was it
18:43:14 <bjkodpf> hayoo
18:44:29 <bjkodpf> is there a way to specify package when you search using hoogle or hayoo?
18:45:18 <bjkodpf> oh yeah, found it on hayoo - 'package: asdf'
18:45:54 <shachaf> "+pkgname foo" on Hoogle.
18:46:04 <shachaf> The Hoogle manual talks about more things you can do.
18:46:30 <bjkodpf> ah okay, thanks
18:48:23 <dmwit> nkar: No, that's just the source that was used to build stuff.
18:50:13 <agibiansky> Does anyone have suggestions for easy-to-start-using GUI libraries? (web gui ok)
18:50:24 <bjkodpf> hmm i have servant package installed and im importing Servant.API but runhaskell is telling me it cannot find the module Servant.API
18:50:25 <agibiansky> There's a ton out there but not sure which one is easiest to start using
18:50:38 * hackagebot markup-preview 0.2.2.0 - A simple markup document preview (markdown, textile, reStructuredText)  http://hackage.haskell.org/package/markup-preview-0.2.2.0 (MariusGhita)
18:52:24 <lpaste> zilinc pasted ‚Äúderiving Show‚Äù at http://lpaste.net/119465
18:53:01 <zilinc> got some problem with deriving Show.. could anyone help?
18:53:17 <zilinc> the problem is that I have existential types..
18:53:24 <ReinH> zilinc: you should include the error
18:53:40 <rasen> agibiansky: wxHaskell is not the hard one
18:53:42 <joness> I believe you can't derive Show for existential type. you have to write the instance manually
18:53:59 <bjkodpf> what would cause an installed module to not be found by ghc?
18:54:08 <zilinc> the error is that the functor is wrong because it doesn't derive the result type to be an instance of Show
18:54:45 <Cale> bjkodpf: Maybe it's in a package which is hidden, or you're compiling with Cabal and you didn't specify the package as a dependency?
18:54:59 <rasen> bjkodpf: it depends on how it can't find package
18:55:12 <bjkodpf> Cale: im using ghc, cabal says the package is installed
18:55:16 <zilinc> ReinH: I updated. sorry
18:55:39 <bjkodpf> im not sure what a hidden package is or 'how' it cant find it
18:55:51 <nkar> dmwit: okay, I also removed some things in ~/.cabal/bin
18:56:00 <zilinc> joness: I works, if I don't define it as an instance of functor
18:56:04 <rasen> "how" means what error do you get
18:56:15 <zilinc> joness:s/I/It
18:56:35 <bjkodpf> rasen: 'Could not find module 'Servant.API''
18:57:21 <rasen> Does `ghc-pkg list` shows necessary package?
18:57:28 <shachaf> zilinc: I don't think the problem is with Show.
18:57:49 <bjkodpf> rasen: yes the packages are there
18:58:05 <shachaf> It looks like your thing doesn't work for any a, only 'a's such that Show (e t (Suc Zero) a)
18:58:18 <zilinc> shachaf: well, I've got several issues at the same time..
18:58:57 <zilinc> shachaf: One is that embedding Show constraint in the datatype definition is hacky (I believe)
18:59:22 <zilinc> shachaf: So I'm thinking if it's possible to lift it out to somewhere else
18:59:32 <rasen> bjkodpf: does it show 'It is a member of the hidden ...' after 'Could not find module 'Servant.API
18:59:43 <bjkodpf> rasen: no
18:59:49 <shachaf> zilinc: Yes, sounds good.
19:00:23 <Zemyla> :t \a -> iso (+ a) (subtract a)
19:00:24 <lambdabot> (Profunctor p, Num t, Functor f) => t -> p t (f t) -> p t (f t)
19:00:38 <zilinc> shachaf: cannot find a way though :( because of the existential t.
19:01:33 <bjkodpf> rasen: if i do ghc -v i get a bunch of package info and then this at the end: http://lpaste.net/119467
19:01:42 <rasen> Hate ^W closing tab(
19:01:55 <rasen> bjkodpf: Can you import module from ghci?
19:02:12 <bjkodpf> rasen: nope
19:02:26 <zilinc> shachaf: and if I have the current definition of `Definition', then I cannot make it a functor, because in my case the type of fmap has to be `Show b => (a -> b) -> f a -> f b'
19:04:11 <lpaste> zilinc revised ‚Äúderiving Show‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/119465
19:07:11 <rasen> bjkodpf: give output of ghc -v4
19:08:20 <zilinc> not sure how ghc works internally but it would be good if it could defer the check to call site that the resulting type from `fmap' can be `Show'ed, though I'm not sure if there're any theoretical problems
19:10:50 <rasen> bjkodpf: I'll be there in 15 minutes
19:10:55 <bjkodpf> ok
19:12:56 <bjkodpf> rasen: http://lpaste.net/119470
19:14:46 <Zemyla> Hmm. Is [r] just Cont (Endo r), since it becomes (a -> r -> r) -> r -> r?
19:15:23 <shachaf> You're probably missing a forall there.
19:15:31 <shachaf> (And I guess you mean [], not [r].)
19:15:34 <rasen> bjkodpf: I mean compile that module again with -v4
19:17:40 <cmccann> Zemyla: dunno if I'd say it's "just" that, but you can certainly encode lists that way
19:17:44 <bjkodpf> rasen: http://lpaste.net/119472
19:18:19 <shachaf> I mean, your type is missing a forall, not just that you forgot to type it.
19:18:26 <shachaf> Maybe Codensity Endo or something is more along the lines you want.
19:18:43 <Zemyla> I just elided the forall.
19:19:12 <shachaf> Well, what you're saying is that (forall r. Cont (Endo r) a) ~~ [a]
19:19:27 <shachaf> Which is a pretty different thing to be saying that that (Cont (Endo r) a) ~~ [a] with r free.
19:19:42 <shachaf> The whole point of Cont is that r isn't foralled.
19:20:44 <bjkodpf> rasen: actuall i see in that output its telling me that a bunch packages are unusable because of missing recursive dependencies -_-
19:20:57 <Zemyla> Ah, okay.
19:21:13 <cmccann> Zemyla: also, if you really want to be confusing, use ContT r Endo
19:21:18 <shachaf> newtype Codensity m a = Codensity (forall r. (a -> m r) -> m r), by the way.
19:21:30 <rasen> bjkodpf: including servant
19:21:40 <bjkodpf> rasen: yeah :S do you know an easy fix?
19:21:55 <shachaf> m is suggestively named but doesn't actually have to be a monad.
19:21:57 <bjkodpf> i tried reinstalling those packages it depends on but same errors
19:22:58 <rasen> bjkodpf: http://stackoverflow.com/a/9727036/2538771
19:24:22 <chada> is it possible to have an unboxed vector of a tuple to boxed values?
19:24:41 <chada> something like:
19:24:48 <chada> Unboxed.Vector (Int, MyRecord)
19:25:12 <bjkodpf> rasen: that doesn't seem to work for me, people are also suggesting starting fresh -_-
19:31:19 <rasen> Seems reasonable
19:33:10 <Zemyla> Hmm, so looking at the types, and playing with Djinn, Codensity Endo is actually the list monad.
19:33:44 <Zemyla> And Codensity (Const r) should be Cont.
19:34:05 <enthropy> chada: http://hackage.haskell.org/package/vector-th-unbox might do it
19:35:19 <chada> enthropy, hm, it looks like that requires the element to have an Unbox instance
19:35:45 <enthropy> yes so now you just have to figure out the Unbox MyRecord instance
19:36:03 <chada> it's just a normal data record with some Texts and lists and stuff
19:36:59 <chada> it looks like there's an Unbox instance for (a, b) if both are also Unboxable types
19:40:41 * hackagebot hspec-core 2.1.3 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-core-2.1.3 (SoenkeHahn)
19:40:43 * hackagebot hspec-discover 2.1.3 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-2.1.3 (SoenkeHahn)
19:45:14 <Buttons840> I ran accross the <- operator in a guard recently and realized there's more to it than I realized -- is it an operator? where can I learn more about it?
19:45:42 * hackagebot hspec 2.1.3 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-2.1.3 (SoenkeHahn)
19:45:45 <mniip> <- is a syntax construct
19:46:32 <Buttons840> and the fact that it's used in guards, list comprehensions and do notation is just because the syntax was designed consistently?
19:46:46 <Buttons840> are there other places it is used?
19:47:13 <mniip> https://wiki.haskell.org/Keywords#.3C-
19:48:01 <rasen> list comprehension is a syntax sugar for do notation, but in guards the meaning of <- is a bit different
19:48:08 <cmccann> Buttons840: lambdas also
19:48:39 <rasen> cmccann: lamdas?
19:48:41 <zwer> lambdas use -> ?
19:49:02 <cmccann> er, right
19:49:09 <cmccann> whatever, they're both arrows :P
19:49:27 <cmccann> who cares which way they point
19:50:23 <rasen> compiler
19:51:52 <ab9rf> arrows point hither and yon
19:52:27 <ab9rf> bah
19:52:37 <ab9rf> i had something i wanted to ask about in here but i can't remember what it was now
19:53:24 <ab9rf> it had something to do with an ADT for a variant type where one of the variant was "homogenous list of elements of one of several types"
19:53:38 <ab9rf> i should just go play with it and see if i can make it work
19:58:35 <Zemyla> So what is the Density Comonad for?
19:59:09 <ab9rf> confusing people, i think
19:59:43 <Zemyla> It just seems like a weird foralled version of the Store monad.
20:00:35 <ab9rf> i think it likely only makes sense if you've read and understood some 1974 paper by a guy named Dubuc that i've never heard of :)
20:03:53 <sdegutis> When is GHC 7.10 expected to be released?
20:03:57 <ab9rf> there's an article on ekmett's github page that suggests that the density comonad could be used for optimization purposes, although he doesn't detail how.
20:13:14 <glguy> Codensity may or may not be practical, but it probably exists because it "should"
20:13:43 <glguy> After defining it we can start the process of wondering if it's useful in programming
20:14:53 <Pamelloes> So I have a function f :: [Bool -> (Int,Bool)]. I want to turn it into f'::Bool -> [(Int,Bool)]. However, unlike sequence, I want the bool of the first index to be used as the input for the second index. So some sort of sequence iterate hybrid. I'm not quite sure how to accomplish this, any ideas?
20:15:43 <rasen> [Bool -> (Int,Bool)] is not a function
20:15:57 <ab9rf> yeah, it's a list of functions
20:16:16 <Axman6> Pamelloes: that's pretty easy to write with explicit recursion and probably the clearest way
20:16:54 <Pamelloes> Axman6: That's how I'm doing it right now, but oftentimes there's an even simpler method. Maybe not this time.
20:17:13 <Axman6> :t foldM
20:17:14 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
20:17:27 <enthropy> > scanl f z [a,b,c]
20:17:28 <lambdabot>  [z,f z a,f (f z a) b,f (f (f z a) b) c]
20:17:52 <nshepperd_> The codensity monad is cool. I don't know about the density comonad...
20:18:25 <glguy> :t runState . traverse state
20:18:26 <lambdabot> Traversable t => t (s -> (b, s)) -> s -> (t b, s)
20:19:07 <glguy> :t runState . mapM state -- for lists directly
20:19:08 <lambdabot> [s -> (b, s)] -> s -> ([b], s)
20:19:36 <benzrf> > ala StateT traverse
20:19:38 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable s'0)
20:19:38 <lambdabot>    arising from a use of ‚ÄòM668125936841711756526881.show_M6681259368417117565...
20:19:38 <lambdabot>  The type variable ‚Äòs'0‚Äô is ambiguous
20:19:41 <benzrf> :t ala StateT traverse
20:19:42 <lambdabot> (Traversable t, Functor m', Monad m') => t (s' -> m' (a', s')) -> Unwrapped (StateT s' m' (t a'))
20:19:43 <sdegutis> I just learned what do does. So cool.
20:20:00 <ab9rf> do is sugary
20:20:37 <Hijiri> @unekmett CoDensity
20:20:37 <lambdabot> Unknown command, try @list
20:20:44 <glguy> Benzrf: if there was a _State already I'd have gone that route ^_^
20:20:44 * hackagebot descriptive 0.8.0 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.8.0 (ChrisDone)
20:21:23 <buckmaster> does anyone have experience using sqlite with persistent?
20:22:03 <Pamelloes> enthropy: That was exactly what I was looking for! Thanks!
20:22:18 <bananagram> :t ala
20:22:19 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
20:22:47 <sdegutis> I like do.
20:22:58 <enthropy> Pamelloes: I'd go with glguy's solution
20:23:27 <buckmaster> sdel: do is awesome
20:23:38 <Pamelloes> enthropy: Oh, I didn't see that. Thanks for pointing it out
20:23:48 <buckmaster> whoops, they left T_T
20:24:37 <mniip> oh hi sdegutis o/ oh wait they left
20:26:50 <Buttons840> so a `seq` b evaluates to b, but forces a to be evaluated before b?
20:27:03 <benzrf> Buttons840: no
20:27:16 <benzrf> Buttons840: a `seq` b evaluates to b if a is not bottom
20:27:16 <Buttons840> .
20:27:24 <benzrf> Buttons840: if a is bottom, then a `seq` b evaluates to bottom
20:27:37 <benzrf> Buttons840: i think ghc usually forces a to be evaled first
20:27:40 <benzrf> Buttons840: but the spec doesnt require it
20:27:56 <rasen> What spec requires?
20:28:00 <mniip> 'Evaluates its first argument to head normal form, and then returns its second argument as the result. '
20:29:22 <Buttons840> what is the purpose of the second argument? is it just because an expression needs to evaluate to at least something?
20:29:46 <Buttons840> why not "seq a" instead of "seq a b"
20:29:57 <mniip> and what would be the value of "seq a"
20:29:58 <EvanR> "seq a" would just be a
20:30:01 <zwer> Buttons840 a `seq` a would be useless. it would be "evaluate a when a is evaluated"
20:30:14 <mniip> yeah that
20:30:32 <bramgg> I want to concatenate two Texts in the same way you concatnate two Strings with ++, what can I do?
20:30:44 * hackagebot hindent 4.3.5 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.3.5 (ChrisDone)
20:30:46 * hackagebot structured-haskell-mode 1.0.15 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.15 (ChrisDone)
20:30:47 <shachaf> Buttons840: The definition of seq is just that seq _|_ y = _|_; seq x y = y
20:30:48 <bramgg> I read somewhere to use <> in the place of ++, but then I get a "Not in scope" error
20:30:50 <shachaf> Nothing about order.
20:30:52 <nshepperd_> bramgg: Data.Monoid.<>
20:30:55 <Buttons840> zwer: thus, a `seq` b would be "evaluate a when be is evaluated"
20:31:02 <Buttons840> b*
20:31:07 <bramgg> nshepperd_: ah didn't realize I had to import it from there, thanks
20:31:50 <nshepperd_> you want to use pseq instead of seq if the order of evaluation really matters
20:32:59 <shachaf> Buttons840: No, it's more like "a is evaluated when (a `seq` b) is evaluated"
20:33:43 <joness> > undefined `seq` 10
20:33:45 <lambdabot>  *Exception: Prelude.undefined
20:33:52 <Buttons840> why wouldn't the type of "seq a" just be a ?
20:33:55 <EvanR> (a `seq` b) makes sense when you realize that (a @@@ b) where @@@ is any operation, means a or b may not be evaluated
20:34:03 <EvanR> normally
20:34:08 <EvanR> seq is special
20:36:02 <Buttons840> aren't there lots of "non-special" functions that evaluate all their arguments?
20:36:37 <EvanR> Buttons840: thing is, you cant write seq in its general form
20:36:42 <EvanR> its built in
20:37:04 <EvanR> for specific a and b you can make a @@@ that evaluates both arguments, but if a and b are "anything" you cant do it
20:37:05 <Buttons840> i know it has special support from the compiler
20:37:56 <EvanR> and for some specific a or b, you still cant do it
20:37:58 <EvanR> so you need seq
20:38:38 <enthropy> class Seq a where seq :: a -> b -> b; instance Seq [x] where seq (_ : _) b = b; seq [] b = b -- for example
20:38:43 <Buttons840> when you say "anything" you mean a type with no typeclass constraint?
20:38:58 <enthropy> I don't see any need to dispatch on the 'b'
20:39:29 <Buttons840> in other words, your saying that I can't write any f :: a -> a -> a that evaluates both arguments?
20:39:44 <EvanR> @diff a -> a -> a
20:39:44 <lambdabot> unexpected "a": expecting number, "d" or "("
20:39:48 <EvanR> @djinn a -> a -> a
20:39:48 <lambdabot> f _ a = a
20:40:01 <joness> seq is a -> b -> b.. but yes
20:40:16 <EvanR> Buttons840: try it
20:40:18 <chada> Buttons840, if you need to evaluate a, you'd evaluate a :)
20:40:36 <chada> that is, a seq :: a -> a doesn't really do anything for you
20:41:00 <shachaf> It's called id.
20:41:27 <joness> > id id id id ":)"
20:41:28 <lambdabot>  ":)"
20:41:29 <Buttons840> shachaf: seq = id -- you've done it
20:41:48 <EvanR> Buttons840: seq doesnt take one argument...
20:42:02 <EvanR> Buttons840: but try to write the a -> a -> a function
20:42:02 * Buttons840 fails haskell humor
20:42:04 <joness> we were talking about imaginaroy useless seq
20:42:16 <shachaf> @quote Jafet unsafeCoerce
20:42:16 <lambdabot> Jafet says: unsafeCoerce takes any argument. AND IT WINS THAT ARGUMENT.
20:42:33 <Buttons840> EvanR: yes, it's interesting, because there's no typeclass constraint, I basically can't do any operation on the arguments except return one or the other
20:42:42 <EvanR> right
20:42:52 <EvanR> the other one wont get evaluated
20:43:06 <Buttons840> EvanR: right, this is making more sense now
20:43:06 <EvanR> you could use seq though ;)
20:44:01 <Buttons840> so seq could...  almost as well have the type a -> a -> a, but for the sake of convinience it's type is a -> b -> b
20:44:15 <EvanR> a -> a -> a is a special case of a -> b -> b
20:44:42 <Buttons840> right, a -> b -> b being more general and thus perferable
20:44:51 <EvanR> useful in more situations
20:46:18 <Buttons840> thanks EvanR and others, this really helped my understanding of seq and lazy evaluation in general
20:47:56 <benzrf> lol @ quote
20:48:28 <Zemyla> EvanR: There are two functions that are type forall a. a -> a -> a.
20:48:41 <bramgg> Is it possible to concatenate a String and a Text into a Text?
20:48:43 <Zemyla> const and const id.
20:48:44 <EvanR> Zemyla: yeah Buttons840 came up with both
20:49:03 <bramgg> (in one line like <>/++)
20:49:29 <Zemyla> if' True = const; if' False = const id
20:49:50 <shachaf> bramgg: pack s <> t
20:50:19 <bramgg> cheers
20:51:15 <nshepperd_> bramgg: you can use -XOverloadedStrings so that string literals in your program can be used directly as Text, also
20:52:56 <texasmynsted> Is this a fine place to ask a hackage, pandoc, hakyll, cabal question?
20:53:10 <shelf> fire away
20:53:21 <shachaf> There's #hackage and I think #pandoc.
20:53:28 <shachaf> Depending on your question.
20:53:47 <shelf> #pandoc is not too active
20:54:22 <texasmynsted> I am trying to upgrade my hakyll and cabal is complaining that pandoc is the wrong version.   That is fine as I would also like to upgrade my pandoc.  I check the version of pandoc and it says that it is compiled with texmath 0.8, highlighting-kate 0.5.9.  Sounds correct.
20:54:23 <bramgg> nshepperd_: that's actually my problem.. my stirng literals seem to be evaluating as strings, even with XOS http://lpaste.net/119485
20:55:17 <shelf> texasmynsted: is this in a sandbox?
20:55:39 <rasen> What's the ~ in type signatures?
20:55:51 <nshepperd_> bramgg: is that because readProcess takes string arguments and returns string output, rather than Text?
20:55:59 <tac_> rasen: probably type coercions
20:55:59 <texasmynsted> but when I look on hackage I see nothing about those as a compile flag‚Ä¶ the pandoc site has something about pandoc-citeproc, which looks like a separate lib
20:56:05 <Cale> rasen: A constraint of the form (a ~ b) means that a and b are the same type
20:56:23 <Cale> rasen: This is mostly useful when type families (type level functions) are involved
20:56:23 <texasmynsted> I use pandoc outside of haskell projects
20:56:25 <bramgg> nshepperd_: *facepalm* that would most likely be the problem..
20:56:31 <texasmynsted> so I want it updated globally
20:56:31 <nshepperd_> bramgg: :)
20:56:36 <tac_> they are "represented the same", right Cale?
20:56:43 <shelf> I build my hakyll / pandoc binaries in sandboxes and copy them into ~/bin/ to avoid dealing with this kind of thing
20:56:52 <tac_> I guess making the distinction is splittiing hairs though
20:56:52 <texasmynsted> hhm
20:56:55 <Cale> tac_: Not just that they're represented the same, but that they unify
20:56:55 <shelf> but that might not be the most helpful suggestion, sorry!
20:57:10 <Cale> tac_: newtypes are not ~ to their base types
20:57:12 <rasen> tac_, Cale, thanks
20:59:55 <Rotaerk> hmm, are there any mature unit-of-measure packages
21:00:12 <Rotaerk> the ones I've run across seem kind of experimental
21:00:31 <texasmynsted> feels like there should be a pandoc channel
21:00:54 <texasmynsted> really a channel for each of the many libs in hackage
21:01:17 <shelf> #pandoc is populated. try there, although they've been pretty slow in the past
21:04:38 <texasmynsted> yeah, looks like everybody sleeping there
21:09:02 <texasmynsted> Ok, so I "cabal install pandoc pandoc-citeproc"
21:09:40 <texasmynsted> and I get a message from cabal that says that "pandoc-1.13.1" will likely be broken by my install.
21:10:00 <texasmynsted> WAT?  Does pandoc not simply get upgraded?
21:11:10 <rasen> Probably, there is system-wide pandoc and you're installing thing for current user only
21:11:56 <rasen> It can't update system-wide pandoc without root privileges
21:13:32 <texasmynsted> which pandoc says ~/Library/Haskell/bin/pandoc  That is where cabal puts pandoc iirc
21:13:44 <texasmynsted> hmm
21:13:45 <texasmynsted> could be
21:14:55 <texasmynsted> I do not see one
21:18:02 <texasmynsted> is a force install really that bad?
21:18:07 <nshepperd_> when I install things user-wide, what I do is have a text file ~/.cpkg containing a list of haskell packages I use
21:18:36 <texasmynsted> hmm
21:18:45 <nshepperd_> and then whenever I get a version conflict of any kind, I delete the entire ~/.ghc and cabal install $(cat ~/.cpkg) from scratch
21:18:45 <texasmynsted> Is that a manual thing or something that cabal reads?
21:19:11 <texasmynsted> o_P
21:19:20 <glguy> You don't have to do anything that drastic
21:19:44 <texasmynsted> that was a emoti-click-o
21:19:48 <texasmynsted> o_O
21:20:13 <texasmynsted> what do you think, safe to force install?
21:20:16 * dcoutts_ never deletes ~/.ghc
21:20:21 * dcoutts_ just bends cabal to his will
21:20:25 <glguy> I uninstall the outdated packages
21:20:31 <glguy> and then install the new stuff
21:20:37 <glguy> https://github.com/glguy/GhcPkgUtils helps me find outdated stuff and unregister stuff
21:21:11 <Pamelloes> My only package in ~/.ghc is cabal-install.
21:21:16 <Pamelloes> I use sandboxes.
21:22:11 <nshepperd_> texasmynsted: force install usually doesn't work. ime
21:22:18 <glguy> I can't stand recompiling everything per sandbox so unless there's an actual conflict I just manage my user packages
21:22:54 <nshepperd_> or it 'works' but you get weird diamond dependency problems when you go to build your own projects
21:23:50 <dcoutts_> nshepperd_: I was talking about that stuff today http://www.well-typed.com/blog/104/
21:24:17 <Pamelloes> I like the freedom of sandboxes. Things "just work" in most sandboxes, and when they get screwed up I can delete everything and restart (or whatever) without screwing up any other projects.
21:25:05 <mjrosenb> Loading package SDL-ttf-0.6.2 ... <command line>: can't load .so/.DLL for: /home/mjrosenb/.cabal/lib/x86_64-linux-ghc-7.8.4/SDL-ttf-0.6.2/libHSSDL-ttf-0.6.2-ghc7.8.4.so (/home/mjrosenb/.cabal/lib/x86_64-linux-ghc-7.8.4/SDL-ttf-0.6.2/libHSSDL-ttf-0.6.2-ghc7.8.4.so: undefined symbol: TTF_CloseFont)
21:25:10 <mjrosenb> ugh.
21:25:15 <Axman6> glguy: something nix like/based should make that less painful. isn't there currently a discussion on reddit about doing exactly that?
21:25:17 <Pamelloes> Of course to be able to use a package-manager would be nice, but cabal is what cabal is.
21:25:18 <mjrosenb> that is /not/ a good way to start this project.
21:25:22 <joness> can you combine the two concepts? only use sandbox and avoid global modules only when you encounter some conflict
21:25:39 <joness> can you combine the two concepts? use sandbox and avoid global modules only when you encounter some conflict
21:25:42 <glguy> Axman6: I don't know know
21:26:08 <dcoutts_> Axman6: yes, discussion around the blog post I wrote on the topic
21:26:09 * mjrosenb would love it if every package manager had something like hackports.
21:26:12 <texasmynsted> sandboxes sound fine for projects, but I need/want to use pandoc from the command line outside a particular project
21:26:31 <Axman6> dcoutts_: ah, good, I haven't had time to read it but the title sounds like a promising start =)
21:26:55 <dcoutts_> :-)
21:27:01 * dcoutts_ calls it a night
21:27:11 <Axman6> g'night!
21:27:15 <Pamelloes> joness: I believe (but can't guarantee) that a sandbox replaces the user- and system-wide collection of installed packages so you can install globally and still use sandboxes for troublesome packages
21:27:23 <dcoutts_> ta, g'night
21:27:57 <glguy> Sandboxes don't hide global packages AFAIK
21:28:30 <Pamelloes> Oh, well that's annoying.
21:28:58 <glguy> It's a good thing. Otherwise you wouldn't have base or anything GHC api depends on
21:29:18 <joness> those modules could be exceptions
21:29:23 <Pamelloes> Hm, well I guess that's kind of obvious.
21:29:49 <glguy> It's just not a good idea to hide global packages. It does hide user packages
21:30:28 <joness> when you do "cabal install somemodule" where do the packages get installed? to global or user packages
21:30:36 <Pamelloes> User.
21:30:45 <Pamelloes> Actually, don't quote me. I was wrong last time.
21:31:30 <Pamelloes> (that's why I like sandboxes. I have no idea what I'm doing so they prevent me from screwing up more than one project at a time)
21:32:50 <glguy> cabal install installs to "user" by default
21:35:23 <mjrosenb> hrmm, the examples for grapefruit seem to use proc () -> ...
21:35:32 <mjrosenb> which ghc complains about
21:35:35 <bitemyapp> jonsterling: a moment?
21:35:46 <mjrosenb> do I need to do anything to get that to work?
21:35:46 <bitemyapp> jonsterling: I can explain the CH thing
21:35:53 <bitemyapp> jonsterling: at least from one perspective.
21:37:59 <texasmynsted> ok, trying a forced install
21:39:23 <mniip> @src sum
21:39:23 <lambdabot> sum = foldl (+) 0
21:39:36 <mniip> ugh, the other one
21:40:24 <rasen> Is there strict version of sum in libraries?
21:40:27 <mniip> anyway, wouldn't the non-foldl definition of sum benefit from strict application to the sum
21:40:35 <EvanR> that sum should work
21:40:44 <EvanR> > sum [1..10000]
21:40:46 <lambdabot>  50005000
21:40:49 <EvanR> > sum [1..100000]
21:40:50 <lambdabot>  5000050000
21:40:53 <EvanR> > sum [1..10000000]
21:41:07 <lambdabot>  mueval: signalProcess: permission denied (Operation not permitted)
21:41:07 <lambdabot>  mueval-core: Time limit exceeded
21:41:08 <EvanR> when compiled with -O2 ;)
21:41:16 <mniip> on my machine sum eats memory because all the list elements are turned into thunks
21:41:36 <EvanR> theres a strictness analysis optimization
21:41:48 <mniip> however if I replace "sum' (x:xs) a = sum' xs (a+x)" with "sum' (x:xs) a = sum' xs $! (a+x)"
21:41:56 <mniip> it becomes strict and it works wonders
21:42:07 <rasen> I usually do sum' = foldl' (+) 0
21:42:10 <mniip> well, strict to an extent
21:42:10 <EvanR> yeah it would be nice if the programmer didnt have to stoop to such a level
21:42:52 <mniip> "foldl (+) 0 [1..10000000]" eats memory too
21:43:09 * EvanR checks
21:43:49 <rasen> let sum' = foldl' (+) 0 in sum' [1..10000000]
21:43:58 <rasen> > let sum' = foldl' (+) 0 in sum' [1..10000000]
21:44:00 <lambdabot>  50000005000000
21:44:07 <EvanR> mniip: when i compile that particular expression with -O2 it works quickly
21:44:11 <mniip> ah foldl'
21:44:13 <EvanR> or when i use sum
21:44:27 <EvanR> and i used a bigger number of zeros
21:44:27 <mniip> that does evaluate the application before tail-recursing
21:44:36 <EvanR> yes
21:45:10 <lf94> Is there a better way to do this? https://github.com/lf94/g_challenges/blob/master/02/temperature_converter.hs
21:45:18 <glguy> rasen: What type were you summing?
21:46:03 <rasen> glguy: [1..10000000] defaults to [Integer]
21:46:39 <mniip> lf94, there is
21:46:50 <EvanR> so sum' is arguably not necessary
21:47:07 <lf94> mniip: that would be? X)
21:47:12 <mniip> get some base temperature unit, and create converters both to that unit, and from that unit
21:47:17 <lf94> I'm trying to improve my Haskell
21:47:27 <rasen> EvanR: probably you've wrote code in the way that fusion is possible
21:47:31 <mniip> like 'celsuisToKelvin = toKelvin . fromCelsius'
21:47:45 <lf94> mniip: ahhh
21:47:46 <lf94> Nice
21:47:51 <mniip> except you don't actually define such a function, and derive the 'to' and 'from' parts from the Char's
21:48:02 <EvanR> rasen: it not fusion, its automatically adding strictness to improve performance
21:48:02 <lf94> I gotchya
21:48:06 <mniip> so like (case ...) . (case ...)
21:48:48 <EvanR> rasen: if the compiler can tell that a) the value will definitely be needed and b) it wont change the semantics of evaluating strict functions in presence of bottom, it can/should add strictness for you
21:49:31 <EvanR> maybe it shouldnt sometimes
21:49:33 <lf94> mniip: what would the from functions even look like though?
21:49:53 <rasen> EvanR: cool
21:50:32 <adas> the ppt on using haskell for large systems by don stewart was great
21:50:35 <lf94> fromCelcius...would take a number and return a number
21:50:42 <lf94> and it would do nothing with that number?
21:50:47 * hackagebot dbus 0.10.9.2 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-0.10.9.2 (JohnMillikin)
21:50:53 <lf94> or it would determine what to do with said number
21:51:00 <lf94> to get it to celcius
21:51:06 <mniip> lf94, well say your base unit is kelvin
21:51:30 <mniip> toFahrenheit x = x * 9 / 5 - 459.67
21:51:44 <mniip> fromFahrenheit x = (x + 459.67) * 5 / 9
21:51:58 <mniip> similarly, fromKelvin = toKelvin = id
21:52:01 <lf94> that is only for celcius
21:52:08 <lf94> @ toFahrenheit
21:52:29 <mniip> uh
21:52:39 <mniip> that converts fahrenheit to your internal units (kelvin)
21:52:45 <lf94> oh whoops
21:52:51 <lf94> bad, 1am, sorry :)
21:52:56 <Fylwind> how does one define instances for a type family that's MyKind -> MyKind?
21:55:49 <mniip> hmm
21:56:13 <mniip> so I'm back to like problem 1... passing unknown types between modules unaware of each other...
21:57:51 <mniip> existential quantification, or unsafeCoerce and Any
21:58:03 <mniip> there has to be a better way
21:59:25 <EvanR> mniip: and record containing only the interface, the operations possible to do on the hidden value of unknown type, is another way
21:59:33 <EvanR> equivalent to using existentials
21:59:53 <EvanR> you need an interface of some sort, so thats doing it directly
22:00:32 <mniip> if you've ever programmed in C, you probably know how some functions allow passing a 'user data' value
22:00:47 <Fylwind> @mniip: you could use Dynamic
22:00:47 <lambdabot> Unknown command, try @list
22:00:49 <mniip> some APIs even
22:01:23 <mniip> which is basically a void* pointer so you can allocate memory for any kind of structure you want and pass that, assuming the other side is aware of the structure
22:01:28 <Fylwind> (never mind about my question, I seem to have found a solution albeit I don't know how it works: type family MyFamily (arg :: MyKind) :: MyKind where
22:01:31 <Fylwind> )
22:02:58 <EvanR> mniip: yeah, a void pointer. this is pretty bad, but still possible in haskell
22:03:12 <EvanR> youll realize that using unsafeCoerce for this doesnt even gain you anything
22:03:40 <mniip> I would assume 'Any' to be the closest equivalent of a void* in haskell
22:03:46 <enthropy> Data.Dynamic
22:03:55 <mniip> yeah looking ata Dynamic
22:03:58 <EvanR> you dont just "use" a void pointer, you pass it to certain operations that are labeled as accepting it, and it doesnt take just any void pointer, its a special void pointer
22:04:05 <enthropy> I think you should value having some runtime check
22:04:21 <EvanR> Dynamic is not what youre talking about
22:05:16 <mauke> C only needs the void *user data hack because it can't build functions at runtime
22:05:23 <mniip> ^
22:05:44 <mniip> partial application is not the solution here, sadly
22:05:48 * hackagebot cabal-test-quickcheck 0.1.3 - QuickCheck for Cabal  http://hackage.haskell.org/package/cabal-test-quickcheck-0.1.3 (TimothyJones)
22:06:14 <EvanR> mniip: is your function polymorphic? or you just dont want to export one correct type for some reason
22:06:14 <mauke> why not?
22:07:13 <abg> What do people think of copying conf files from package DBs around to mix arbitrary sandboxes together so that packages from all mixed sandboxes are available in the same place? You could make a sandbox in one place with, say, lens installed, and mix it into project sandboxes to avoid rebuilding it.
22:08:27 <EvanR> mniip: if its the kind of void* userdata which is opaque to the library, it does nothing but provide it back to you as-is later, then this is the usually polymorphic data type. like [a] or Maybe a
22:08:38 <EvanR> usual*
22:09:26 <EvanR> if the library will make use of it somehow, it must be provided with some interface to it. a third possibility is that *you* dont know what type it is, but the library isnt going to tell you
22:10:29 <mniip> ugh
22:10:30 <EvanR> but you will have some interface to work with it, provided by the library
22:10:45 <mniip> I should write this stuff down
22:10:59 <mniip> this system is so messed up I have to rethink everything from scratch every time
22:14:04 <Fylwind> abg: this sounds like an ad hoc version of nix :)
22:14:12 <abg> Fylwind: It is indeed
22:14:22 <abg> I experimented with it and I actually got it working
22:14:30 <Fylwind> I wish it was available with Cabal out of the box though
22:15:17 <abg> Actually, I figured mixing sandboxes for two different projects is more trouble than it's worth. So what if we differentiated between project sandboxes and sandboxes which are simply sources of commonly used package sets.
22:16:20 <abg> Like with virtualenvwrapper in Python, a global list of sandboxes (virtualenvs in venvwrapper's case) would be available. You could mix any of those into your project sandbox.
22:16:22 <mniip> oh I know just what I need
22:16:26 <Lokathor> I have a Data.Text, I need a Data.ByteString.Lazy, I can't seem to see how I make one into the other
22:16:46 <mniip> TVar (Map String Dynamic)
22:16:47 <mauke> presumably by calling some encode function
22:16:56 * mniip notes
22:17:12 <Fylwind> abg: how do you take into account of diamond dependencies?
22:17:16 <mauke> Lokathor: what encoding do you need?
22:17:45 <Lokathor> mauke: i tried using encodeUtf8, but it gave me a strange error about my ByteString types not matching up
22:18:03 <abg> Fylwind: Well, I mean, I can't solve everything :)
22:18:10 <mauke> Lokathor: which encodeUtf8, and what was the error message?
22:18:14 <EvanR> mniip: with that, youll have a set of values of basically a very large sum type. each "option" will need to be available in the place its used, and youll have to deal with the case that conversion from Dynamic to a normal type will fail
22:19:01 <EvanR> its not like void* but more like a huge tagged union
22:19:06 <mniip> EvanR, such a case would be pretty much impossible so I'm fine with a pattern match failure
22:19:40 <lpaste> Lokathor pasted ‚ÄúByteString problem‚Äù at http://lpaste.net/119487
22:19:44 <abg> More seriously, as a first step, all I'm trying to do is avoid recompiling large package sets. Maybe I can augment it later to keep track of dependency versions. Right now, it's just relying on the fact that Cabal provides some level of consistency OOTB.
22:20:15 <EvanR> mniip: its probably worth thinking about a better way to model your system
22:20:17 <abg> Lokathor: Assuming you're working with Utf8, Data.Text.Encoding.encodeUtf8 to get a strict ByteString and Data.ByteString.Lazy.fromStrict to get a lazy bytestring from that.
22:20:31 <Lokathor> ah-ha
22:20:49 <Lokathor> honestly i hardly care about the encoding, i can make the client change something later if i have to
22:21:14 <mniip> EvanR, there's not any actual system written yet, I'm merely theoreticising
22:21:19 <mauke> yeah, it's complaining that you're giving it a strict bytestring but it's taking a B.Bytestring where B = Data.ByteString.Lazy
22:21:30 <mniip> but I've taken a lot of appreaches to this and not found a better model so far
22:21:46 <Lokathor> oh that works, how wonderful, it works now mauke
22:22:14 <EvanR> mniip: Map String Dynamic or Map Text Dynamic is basically modeling PHP's global namespace
22:23:02 <EvanR> mniip: so what are you trying to model?
22:23:30 <mniip> it didn't sound that bad until you put the word PHP in
22:24:17 <EvanR> we have types for a reason ;)
22:24:52 <mniip> there's dynamic code loading involved, are you still interested?
22:25:06 <EvanR> what kind of code
22:26:05 <sgronblo> yeah i was always thinking that dynamically typed languages is all about having everything be a Map Any Any where you need to cast everything to the right type before attempting using it
22:26:27 <mniip> EvanR, haskell presumably
22:27:28 <EvanR> mniip: then you really shouldnt need dynamic heh
22:27:39 <mniip> but I do
22:28:02 <EvanR> what, arbitrary haskell? without types?
22:28:23 <mniip> no, more like plugin loading
22:28:24 <abg> Fylwind: https://github.com/abhinav/haskell-sandman working prototype in case you're interested
22:28:41 <EvanR> mniip: no defined interface to the plugins?
22:28:49 <mniip> there is one
22:28:55 <EvanR> thats good
22:29:08 <EvanR> whats the issue
22:29:23 <mniip> the need for dynamic types comes from unability for a plugin to have a state
22:29:40 <EvanR> ok, so like, a persistent database?
22:29:51 <mniip> no, more like a variable or something
22:30:09 <mniip> even if I create an IORef/MVar/TVar, where do I hold the reference
22:30:56 <EvanR> ok, so you want to transfer to state to the host program, reload the plugin, and pass that state back to the plugin to restore the state?
22:31:05 <EvanR> the state*
22:31:06 <mniip> um no?
22:31:14 <EvanR> ok that was just a guess
22:31:23 <mniip> reloading would presumably reset the state
22:31:27 <EvanR> does the host program need to know anything about the state at all?
22:31:45 <mniip> no, but other plugins might want to know
22:31:57 <EvanR> via a defined interface?
22:32:16 <mniip> well either the host program has to define one, or the stateful plugin
22:33:04 <EvanR> so the plugin A will want to know about plugin B's state type
22:33:12 <EvanR> to be able to use it directly
22:33:24 <mniip> yes
22:33:33 <mniip> B can export this kind of data
22:34:17 <mniip> hmm
22:34:17 <EvanR> yeah so if i have Plugin A, and code for Plugin B uses A, no problem?
22:34:27 <EvanR> the a in Plugin a is the state type
22:34:40 <mniip> huh
22:34:48 <mniip> come again?
22:35:22 <mniip> C has static variables, they do the job pretty much perfectly
22:35:29 <EvanR> pluginA has state type A, so in the code for pluginB, i use A, expect A
22:35:38 <EvanR> well C has no type system
22:35:40 <mniip> but then again the closest haskell analogue is 'unsafePeformIO newIORef' which is ugh
22:36:28 <mniip> EvanR, B is aware of A's state type, yes
22:36:32 <EvanR> ok good
22:36:57 <mniip> if A doesn't export the fact that it has a state, it's not expected that other plugins would peek into it
22:37:19 <mniip> but oh well, everything is possible with GHC hacks
22:37:22 <EvanR> i was suggesting parameterizing the interface to a plugin with its state type
22:37:59 <mniip> you mean like PluginA.getState ?
22:38:36 <EvanR> something like that, Plugin A would have a "method" which gives you an A
22:38:47 <EvanR> more generally if you have Plugin a, theres a method to get an a
22:38:59 <EvanR> thats if you want to expose the raw state
22:39:01 <mniip> PluginA.getState :: IO PluginA.AState
22:39:02 <EvanR> which is what State does
22:39:03 <mniip> right?
22:39:29 <EvanR> IO is probably involved, but im thinking thats not the full type
22:39:41 <mniip> yeah that isn't the problem
22:39:47 <mniip> the problem is
22:39:48 <EvanR> it depends on how your plugin interface i was talking about earlier is supposed to work
22:39:57 <mniip> where would getState get the state from
22:40:11 <EvanR> operationally, from the plugin
22:40:16 <mniip> but how
22:40:22 <EvanR> the point though is that we want the types to work too
22:40:39 <mniip> I can't have plugin-local variables
22:40:43 <EvanR> programs compile and the types are gone and you can explain how anything works in terms of passing values around
22:40:56 <EvanR> but we want the types to work
22:40:57 <mniip> getState can only be deriving its result from its arguments
22:40:59 <mniip> but there are none
22:41:05 <EvanR> you didnt add arguments
22:41:13 <mniip> what would the arguments be?
22:41:15 <EvanR> but even so, IO lets you get around that
22:41:31 <mniip> IO doesn't let me declare static variables does it
22:41:36 <EvanR> IO whatever is a very powerful thing
22:42:02 <EvanR> well i dont fully understand how your plugins work yet, how they are supposed to reload
22:42:28 <mniip> forget about reloading
22:42:33 <mniip> (did I even ever mention reloading?)
22:42:44 <EvanR> ok, loading
22:43:08 <EvanR> they have some initialization code that sets up their state?
22:43:26 <mniip> possibly
22:43:39 <EvanR> ill just assume thats part of the interface
22:43:45 <mniip> yeah
22:44:00 <EvanR> so part of Plugin a interface would be IO a
22:44:13 <mniip> what
22:44:14 <EvanR> unless the initialization has some standard inputs
22:44:56 <mniip> you make it sound like a is a type variable
22:45:01 <EvanR> it is
22:45:14 <mniip> not in 'Plugin a' though o-O
22:45:29 <EvanR> dont you want to keep the type straight
22:46:13 <EvanR> to know what kind of state we will be extracting from a plugin (still assuming we want to do that) we need to know what the state is
22:46:27 <EvanR> so its right there in the type of the plugin
22:46:32 <mniip> that's pretty oxymoronic
22:46:55 <EvanR> well its more like an obvious statement
22:47:09 <mniip> hold on
22:47:13 <mniip> I'm missing something
22:47:22 <mniip> how did we arrive at a type called 'Plugin'
22:48:02 <EvanR> im trying to piece together your plugins interface, which is standard across plugins, i called it a datatype Plugin a
22:48:57 <EvanR> your code for a particular plugin would involve Plugin A for some concrete A
22:50:27 <mniip> what
22:50:29 <EvanR> initializing that plugin would produce a value of type A
22:51:06 <mniip> I don't think we're on the same wavelength
22:51:28 <EvanR> what else can a plugin do?
22:51:53 <frawgie> Haskell is so powerful it even got an event horizon. Once you learn enough you can never go back to another language. >_<
22:52:14 <EvanR> frawgie: but you can continue deeper!
22:52:28 <frawgie> EvanR: forever :)
22:52:35 <EvanR> well not forever
22:52:42 <EvanR> dependening
22:52:48 <mniip> EvanR, a plugin is a loadable piece of code
22:53:13 <EvanR> mniip: yeah you said there was a definite interface to this thing, i was asking what else the host should expect to be able to do with the plugin to get a better idea of what it is
22:53:32 <mniip> by interface I of course meant functions
22:53:33 <mniip> ?
22:53:55 <EvanR> an arbitrary number of functions with arbitrary input types and output types?
22:54:02 <mniip> ugh
22:54:26 <mniip> you keep interpreting the "plugin" thing as a value
22:54:53 <EvanR> im interpreting it as an object satisfying some interface
22:55:08 <EvanR> and once we figure out what it is we can encode it in functional language
23:00:00 <mniip> well it's not an object
23:00:45 <EvanR> if you load the same plugin multiple times, does it not have multiple independent states? and identities?
23:01:12 <EvanR> at least it would have some identity to stop you from loading *it* multiple times, if thats not the case
23:01:25 <mniip> I'm afraid you cannot load the same plugin multiple times
23:01:48 <EvanR> good, more info ;)
23:02:18 <EvanR> i supposed they dont all have the same interface
23:02:38 <EvanR> usually plugins have to have this in some way so the host knows what it can do with the plugin once its loaded
23:02:59 <mniip> the plugins have an api though :|
23:03:15 <EvanR> its common across plugins?
23:04:20 <mniip> yes!
23:04:27 <EvanR> ok!
23:04:52 <EvanR> you can encode that interface as a data type
23:05:10 <mniip> no you cannot
23:05:24 <EvanR> would you mind explainin the api?
23:06:12 <mniip> well, in general, there has to be some function that initializes a plugin, after it's loaded, and some function that finalizes it before it's unloaded
23:06:26 <EvanR> thats it?
23:06:32 <mniip> both of type `IO ()` I guess
23:06:45 <EvanR> right, so neither of those would be functions then, which simplifies it
23:07:39 <EvanR> so, it might be that (IO (), IO ()) is the interface to all your plugins. you can totally get a lot done with just this, though theres no way to access the hidden internal state
23:08:12 <mniip> every plugin can have additional functions but that depends on the plugin in question
23:08:17 <EvanR> loading a plugin would effectively give you a value type (IO (), IO ())
23:08:27 <mniip> um
23:08:36 <EvanR> mniip: ahhh. thats what i figured, the api is not common across plugins
23:08:43 <mniip> but it is common
23:08:48 <EvanR> sorry for misunderstanding, twice
23:08:57 <mniip> the initialization and finalization routines are standartized
23:09:24 <mniip> also uh, loading a plugin would give me a module object, if anything
23:09:37 <EvanR> module object?
23:10:50 * hackagebot language-javascript 0.5.13.1 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.13.1 (AlanZimmerman)
23:11:17 <mniip> what the hell is wrong with hackage, why is there no 'ghc' package
23:11:40 <EvanR> you can looking package `base' for stuff that comes with ghc
23:13:17 <mniip> well, I'm being linked to ghc/HscTypes while actually it's ghc-api/HscTypes
23:13:23 <mniip> so yeah
23:13:48 <mniip> the closest to an 'object' a plugin is, is HscTypes.ModIface
23:13:49 <EvanR> http://hackage.haskell.org/package/plugins-1.5.1.4/docs/System-Plugins-Load.html ?
23:15:00 <mniip> System.Plugins.Load is one of the dynamic loading implementations I consider
23:16:14 <mniip> but that's completely out of this question
23:16:38 <EvanR> by providing a typed interface to your plugins, you avoid having to deal with using strings and weird stuff like dynamic in client code, when you seem to already know what the plugins will have available. if you dont believe thats true then ok
23:16:41 <Lokathor> so i have a thing where i need to modify a nested variable at an arbitrary level of nesting in a value that doesn't have a fixed schema.
23:16:48 <Lokathor> it seems i've painted myself into a corner on this one
23:17:20 <EvanR> Lokathor: XML? ;)
23:18:15 <Lokathor> the value is on disk as JSON, and being held in memory by the server, and the client is using it as JSON, and the client sends updates about which JSON value by chaining strings and numbers like a java package
23:18:36 <Lokathor> so then i need to modify the version in memory, and also announce the change to other clients
23:19:07 <Lokathor> i think that i could probably just enforce a fixed schema of some sort on the system, and then i could probably use a lens or something
23:19:11 <EvanR> you can take a "path" to the thing to update (dealing with "misses" accordingly), and do it.
23:19:39 <Lokathor> yeah that's what i have right now, but i tried to do too much at once and i messed up somewhere in my chain
23:19:49 <Lokathor> I'll have to try again tomorrow
23:19:52 <EvanR> yeah sounds error prone
23:20:14 <EvanR> deeply nested stuff like that can often be refactored into a database
23:20:27 <Lokathor> also a good plan, yes
23:20:45 <Lokathor> i must look into many things
23:22:55 <mniip> EvanR, your suggestion does add some information now
23:24:16 <mniip> maybe I should split things that require a state from things that don't?
23:24:40 <mniip> but yeah that still doesn't solve the original issue
23:24:49 <mniip> the type of the state depends on the plugin
23:24:56 <EvanR> a stateful api contains as a subset things that dont need state
23:25:07 <EvanR> you shouldnt need two apis
23:26:18 <Lokathor> question of style: if large portions of a game are doing dice rolls, should you try and cart around a State holding a StdGen, or should you just let all those parts be in IO and use randomRIO?
23:26:20 <mniip> no I mean like split a stateless 'doFooOperation' from stateful 'handleFooRequests'
23:26:31 <mniip> but yeah, nothing to do with the original issue
23:26:41 <Lokathor> put another way: how hard should one try to stay out of IO?
23:27:32 <mniip> but yeah, I've got Dynamic, and your suggestions not to use it don't make a slightest sense
23:27:42 <dhinojosa> How do you pronounce 'frege' the haskell language on the JVM?
23:27:45 <mniip> but I'm really really really open for suggestions
23:27:49 <EvanR> if you are generating random numbers in otherwise IO code, and you dont care about saving, restoring RNG state, and you dont care about the details of the generation, just use randomRIO?
23:28:14 <EvanR> if any of the above arent true you need to use a real RNG ;)
23:29:25 <Lokathor> doesn't randomRIO maintain a single state across the lifetime of the program?
23:29:45 <EvanR> the generator state is in a hidden IORef
23:29:59 <Lokathor> well that much seems fine
23:30:11 <EvanR> it totally works
23:30:15 <EvanR> you just need IO to use it
23:30:24 <Lokathor> the part about not being able to save/restore the RNG state for later does seem like a drawback now that you bring it up
23:31:21 <EvanR> continually rebooting a generator while using it does hurt the randomness
23:31:21 <Lokathor> i guess that's another thing i'll have to keep in the World data
23:31:46 <EvanR> if you dont continually reboot it, not really a problem
23:32:19 <Lokathor> well, keeping the RNG state across saves/loads seems important enough to bother with
23:34:03 <mniip> [10:27:57] <EvanR> the generator state is in a hidden IORef
23:34:42 <EvanR> Lokathor: actually you can save and restore the global generator
23:34:55 <Lokathor> oh?
23:34:59 <EvanR> yeah its in there
23:35:08 <EvanR> :t setStdGen
23:35:09 <lambdabot> StdGen -> IO ()
23:35:27 <Lokathor> ah ha
23:35:28 <mniip> so apparently `unsafePerformIO` is an acceptable way of emulating static variables?
23:35:47 <Lokathor> mniip like java static?
23:35:55 <EvanR> mniip: not by itself. if you want global vars, look at the globals package
23:36:01 <mniip> http://hackage.haskell.org/package/random-1.1/docs/src/System-Random.html#theStdGen
23:37:37 <mniip> "The TemplateHaskell extension must be enabled."
23:37:38 <mniip> :(
23:37:45 <EvanR> try safe-globals
23:38:28 <mniip> that's what I'm looking at
23:38:31 <EvanR> (of course globals still arent necessary, but possibly convenient)
23:38:43 <mniip> http://hackage.haskell.org/package/safe-globals-0.1.1/docs/Data-Global.html
23:42:04 <EvanR> mniip: in haskell, its more idiomatic to explicit execute initialization code rather than have it be invisibly happening behind the scenes
23:42:16 <EvanR> explicitly*
23:43:09 <EvanR> and to at some point provide the state or context necessary for code to work, rather than code mysteriously have that state already, from who knows where
23:45:52 <mniip> I'm fine with explicitly initializing state, but I need a variable to initialize it with
23:45:58 <mniip> s/with/in/
23:46:29 <mniip> er
23:46:31 <mniip> I'm fine with explicitly initializing state, but I need a variable to initialize it in
23:47:02 <EvanR> creating a TVar or IORef is something you can just do during initialization
23:47:09 <EvanR> thats kind of part of the point of initializing
23:47:19 <mniip> TVar is not like a static variable
23:47:35 <EvanR> why does it need to be like java static ?
23:47:45 <mniip> because I can't pass the goddamn reference
23:47:51 <EvanR> why not?
23:48:08 <mniip> because the type depends on the plugin
23:48:28 <EvanR> i tried to explain ways it could work
23:48:34 <EvanR> you have asserted they are wrong
23:48:40 <EvanR> so im done
23:49:53 <mniip> I've only asserted that it wouldn't work
23:50:16 <mniip> because you keep drawing weird assumptions like that a plugin is a datatype or something
23:52:01 <glguy> That's a pretty standard way to handle them, so that's no surprise
23:58:06 <ab9rf> java static variables are global state.  global state bad.  do not do!
23:58:19 <ab9rf> :)
23:59:40 <matematikaadit> hello, is it just me or the source of Data.Stream in hackages (http://hackage.haskell.org/package/Stream-0.4.7.1/docs/src/Data-Stream.html) was linked to an chinese site (http://www.duba.com/)?
