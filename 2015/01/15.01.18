00:04:31 <trap_exit> how does fay and haste compare?
00:31:44 <ddellacosta> hello, it's the guy who's been asking about the same thing for two weeks.  So, if I have some C code that does bit shifting operations on a C int then stuffs it into a char array, implicitly only taking the first 8 bits, that is not at all what I'm going to get when I bit shift a CInt then coerce to a CChar in Haskell, right?
00:32:26 <ddellacosta> I need to figure out how to explicitly "chop off" those first 8 bits from the CInt I've done the bit operation on and *then* coerce that into a CChar, correct?
00:32:53 <vanila> ddellacosta, do you need to port this C code to haskell?
00:33:24 <ddellacosta> vanila, yeah, that's what I'm doing
00:33:33 <vanila> can I see the code?
00:34:01 <ddellacosta> vanila: https://xiph.org/ao/doc/ao_example.c  <- see the for loop that is stuffing values into the buffer.
00:34:59 <shachaf> > fromIntegral (0x41 :: CInt) :: CChar
00:35:00 <lambdabot>  Not in scope: type constructor or class ‘CChar’
00:35:00 <lambdabot>  Perhaps you meant ‘Char’ (imported from Data.Char)Not in scope: type constru...
00:35:00 <lambdabot>  Perhaps you meant one of these:
00:35:02 <ddellacosta> vanila: what I'd like to do ideally is find a more idiomatically Haskell-like way to construct the same array
00:35:09 <shachaf> Bah, I thought it was imported.
00:35:21 <vanila> I think that would just be   shiftR sample 8 .&. 0xFF
00:35:52 <vanila> from Data.Bits
00:35:54 <ddellacosta> vanila, shachaf: this is what I current have (which gives me garbage values): https://gist.github.com/ddellacosta/83697720f2cc88752797
00:35:55 <shachaf> Anyway, it looks like e.g. (fromIntegral (0x41 :: CInt) :: CChar) == (fromIntegral (0xff41 :: CInt) :: CChar)
00:36:16 <shachaf> But you might want to explicitly and it to make sure you only keep the lowest byte.
00:36:42 <ddellacosta> *currently
00:36:46 <vanila> I think I would need to test the code locally to figure it out
00:36:50 <vanila> is it easy to do that?
00:37:26 <ddellacosta> vanila: I mean, that gist is self-contained I think, other than the Foreign imports
00:37:43 <ddellacosta> which I think are just Foreign.Types.  Oh, and Data.Bits too
00:37:59 <ddellacosta> can't believe how long I've been stuck on this one thing
00:38:14 <ddellacosta> at this point I just really want to understand it
00:38:31 <vanila> how do you test it
00:38:50 <vanila> oh just pick two random floats
00:38:55 <vanila> and compare the result against the equivalent C
00:39:15 <ddellacosta> oh, you can do for example fillSampleVector 44000
00:39:21 <ddellacosta> yeah
00:42:05 <vanila> canyou paste the imports?
00:43:38 <ddellacosta> vanila: don't think you need all of these, but just in case I forgot something I added them all: https://gist.github.com/ddellacosta/83697720f2cc88752797
00:44:06 <vanila> this seems to create an infinit sequence
00:44:18 <vanila> oh no its just huge
00:47:09 <vanila> http://lpaste.net/118659
00:47:28 <vanila> these both print the same thing, so the bitshifting stuff is correct [on this one input]
00:48:28 <ddellacosta> vanila: you aren't generating a sample in the C version though
00:48:42 <ddellacosta> er, calling the sample fn.
00:48:55 <ddellacosta> oh, I see that you've swapped that out, okay
00:49:05 <vanila> i cut everything out the test case except the bit shifting coercestuff you were asking about originally
00:49:16 <ddellacosta> hmm
00:49:31 <vanila> I think that this confirms that part of your haskell code is correct
00:49:32 <ddellacosta> vanila: and how are you comparing them?
00:49:39 <vanila> run them both, and they print the same thing
00:51:53 <ddellacosta> okay, thanks for trying that out vanila!
00:52:01 <ddellacosta> I have to see what I can glean from that
00:52:48 <vanila> so I guess this program generates a sine wave
00:52:49 <vanila> and plays it
00:52:56 <vanila> do you have a way to send Seq to ogg to play it?
00:53:03 <vanila> or are you just comparing the numbers
00:53:37 <ddellacosta> vanila: no, I'm just wrapping http://xiph.org/ao/
00:54:05 <ddellacosta> vanila: I've already got everything else working--I can play the sample with my Haskell FFI wrapper code when I produce the sample using the C fn (which I've made a wrapper for)
00:54:25 <vanila> ok, cool!
00:54:28 <ddellacosta> vanila: but my goal is to make something higher-level in Haskell so that I can create sounds using some kind of DSL
00:54:44 <vanila> well this for loop
00:54:47 <ddellacosta> vanila: this was all just a way for me to wrap my head around how samples work actually
00:54:56 <vanila> you could do it using map (\i -> ...) [0 .. "format.rate"]
00:55:20 <vanila> and inside you do  let sample = <that function of i> in emit four samples
00:55:43 <ddellacosta> yeah, that may be cleaner
00:55:44 <mm_> Is there a way to provide a general type-family instance that could work with any type?
00:56:19 <vanila> is your ogg interface on github or something? I could try if you like
00:56:47 <ddellacosta> vanila: not quite yet, but thank you!
00:57:01 <ddellacosta> (and doesn't handle ogg, to be clear)
00:57:12 <trap_exit> is it possible to use a ghc flag to diable things like "let (Just x) = y" where x :: Int, and y :: Maybe Int ?
00:57:15 <ddellacosta> but as soon as I get this working I'll update it
00:57:18 <trap_exit> I want to eliminate possible sources of runtime errors
00:57:37 <vanila> oh i forgot what ao stood for
00:57:38 <ddellacosta> vanila: I'll ping you when I do get it up, if you're still interested. :-)
01:00:06 <ddellacosta> vanila: I see a problem now with the code--the C code assigns in intervals a CInt wide (32 bits).  But when you dump out to test it dumps out only the first four chars
01:00:38 <ddellacosta> in fact, I suspect this has something to do with why my generated char array doesn't work the same
01:03:33 <glguy> Trap_exit: does -fwarn-incomplete-uni-patterns catch that?
01:03:51 <trap_exit> glguy: dunno, gonna try it now
01:04:21 <trap_exit> nope
01:04:27 <trap_exit> I think it's called a 'irrefutable pattern'
01:10:00 <glguy> I think it is supposed to, might be a bug
01:10:51 <glguy> Does it work if you move that into a where clause with the same flag?
01:39:48 <d3lxa> I need to process every node in an AST (SQL in my case) from X to State MyState X, my code is bloated because I need to write everycase recursively, I've heard of thing like uniplate, would it help me to shrink my code consicely my safety?
01:40:12 <d3lxa> *consicely with type-safety
01:47:46 <vanila> its hard to say without seeing the code d3lxa
01:54:38 * hackagebot interchangeable 0.1.0.0 - A type class for interchangeable data.  http://hackage.haskell.org/package/interchangeable-0.1.0.0 (arowM)
01:55:16 <d3lxa> vanila: here https://github.com/axel-angel/haxquery/blob/master/Main.hs#L143
01:55:48 <d3lxa> where the AST is defined here https://hackage.haskell.org/package/simple-sql-parser-0.4.0/docs/Language-SQL-SimpleSQL-Syntax.html#t:QueryExpr
01:55:58 <phaazon> hi
01:57:38 <vanila> oh damn
01:57:54 <vanila> this library looks dangerously vulnerable to sql injection
01:58:20 <vanila>  let q = "INSERT INTO "++ tname ++" ("++ colsstr ++") VALUES ("++ vstr ++")"
01:58:25 <vanila> using strings like this is super dangerous
01:58:44 <d3lxa> vanila: not when y ou know that tname, colsstr and vstr are all program generated, no user input from this
01:59:11 <vanila> :(
02:00:55 <d3lxa> the whole conv mess is here just to convert Name from the whole tree…
02:04:59 <d3lxa> vanila: why the sad face?
02:06:18 <vanila> because i didnt manage to get the danger across
02:06:31 <vinit-ivar> okay, I don't understand IO :'(
02:06:51 <vinit-ivar> if IO () is being executed, isn't it impure?
02:07:18 <vanila> vinit-ivar, you can think of IO a as instructions
02:07:28 <vanila> when you have main :: IO a it will run those instructions
02:07:56 <d3lxa> vanila: don't worry, for any piece of code it's far from being trivial, in fact it's unprovable for most cases or we would have auto-checking program that works 100% of the time :p
02:08:24 <vanila> yeah thats true :)
02:08:25 <glguy> The point is that the functions are pure, the things of type a->b
02:08:58 <vinit-ivar> but the instructions are still writing to the screen, so aren't *they* impure?
02:09:02 <glguy> IO has a separate type
02:09:41 <d3lxa> vinit-ivar: you can consider IO () as a way to encode side-effects for later execution, it's only executed when everything as been read and the value inside the IO here () is needed, that would certaintely be at the end
02:11:21 <vanila> vinit-ivar, the instructions are just data
02:12:01 <vanila> something else,  not haskell runs them
02:12:15 <d3lxa> the runtime, right?
02:12:26 <glguy> Haskell programs do stuff, it's just that evaluation of values and applying arguments to functions doesn't
02:12:27 <vanila> yeah]
02:13:24 <d3lxa> maybe that can be sumarized as this (1) read program, no execution, gather all IO actions without executing them (2) execute them
02:13:24 <vinit-ivar> i see
02:13:47 <vinit-ivar> gah, this is a bit complicated
02:13:49 <vanila> that's roughly right, but (1) and (2) actually mix up together
02:14:10 <d3lxa> yeah it depends on the laziness of the values of your IO ()
02:14:23 <d3lxa> but as it's IO () then () is never needed in the program, it's empty right?
02:14:36 <vanila> vinit-ivar, what is not clear?
02:14:59 <d3lxa> yeah it's kind of fancy for basic stuff :)
02:15:08 <ab9rf> don'
02:15:21 <ab9rf> don't let yourself get too bogged down in the abstraction
02:15:56 <vinit-ivar> I'm not entirely sure what isn't clear, I just can't seem to picture the whole thing clearly
02:16:09 <ab9rf> all IO does is provide sequencing
02:16:16 <ab9rf> this happens, then that happens
02:16:17 <vinit-ivar> form a mental image of the whole pipeline, I mean
02:16:20 <vinit-ivar> I see
02:16:33 <vinit-ivar> so the actual getting/putting data is not done by haskell?
02:16:41 <ab9rf> what is haskell? :)
02:16:47 <d3lxa> you are not helping :D
02:16:52 <vinit-ivar> T_T
02:17:14 <vinit-ivar> hang on
02:17:16 <ab9rf> it's done by the implementation of the various IO functions, which are probably not written in pure haskell
02:17:18 <vanila> in haskell you write some code that describes a process - then when you run it those instructions guide the runtime
02:17:20 <d3lxa> vinit-ivar: maybe you can see haskell the language as the assembler ASM and the runtime that reads IO as the process that reads the ASM
02:17:33 <d3lxa> *processor that reads the ASM
02:18:32 <d3lxa> when you write IO actions it's kind of like writing ASM, then executing them is kind of like a processer reading your ASM, right?
02:18:49 <d3lxa> *processor (urgh, cannot write this one right…)
02:18:54 <ab9rf> with respect to the main routine in a haskell program, which is of type IO, the execution of the IO actions in that function's value is indeed the responsibility of the runtime wrapper
02:19:10 <ab9rf> er, type IO ()
02:19:16 <ab9rf> something ate my parens
02:19:46 <glguy> for example, putStrLn is a function that takes a String and returns a thing that prints that string to the screen if you execute it. This is different than something like printf in C where that procedure actual writes to the screen when called.
02:20:14 <vinit-ivar> okay, but the actual *execution* of that thing is not implemented in pure Haskell?
02:20:21 <d3lxa> you can consider putStrLn like the assembler code for haskell that when runs print it :D
02:20:23 <vanila> thats right
02:20:24 <glguy> The function part in Haskell is just separate
02:20:49 <ab9rf> vinit-ivar: it might or might not be, but whether it is or not isn't something you need to worry about
02:20:56 <ab9rf> vinit-ivar: it's "magic"
02:21:06 <d3lxa> not helping… again :D "black magic" ahah
02:21:31 <vinit-ivar> haha
02:21:38 <vinit-ivar> but my point is
02:21:40 <ab9rf> it's probably written in C, but that's just because most everything these days is written in C
02:22:01 <vanila> main = do r <- getLine ; print (f r) <-- in this code the runtime will see the instruction to get a line and read one in, then it will see a print instruction and pass the result and execution back into haskell which will compute f r and print that result
02:22:06 <vinit-ivar> if there's any impure haskell/C in it, then how can IO be *entirely* pure? at the end of the day it *is* writing to the screen
02:22:15 <glguy> You compile your while program. The compiler knows how evaluation and execution and primitives work
02:22:26 <glguy> Whole program*
02:22:38 <vanila> its pure because its just instructions - descriptions of actions rather than actions themselves
02:22:43 <ab9rf> vinit-ivar: how is printing to the screen not pure?
02:22:59 <glguy> Haskell programs aren't pure, Haskell Functions are
02:23:12 <ab9rf> ^ what he said
02:23:19 <vinit-ivar> isn't that the defintion? a function may only compute its output
02:23:21 <vinit-ivar> oh shit
02:23:23 <d3lxa> let him breath :D
02:23:24 <vinit-ivar> epiphany
02:23:27 <vinit-ivar> :D
02:23:54 <vinit-ivar> so what you're saying is, the function
02:23:56 <vinit-ivar> say putStrLn
02:24:04 <ab9rf> :t putStrLn
02:24:05 <lambdabot> String -> IO ()
02:24:13 <vinit-ivar> *itself* does not write to the screen, it just returns an object of type IO ()
02:24:20 <vinit-ivar> which is then executed (magically) deep down?
02:24:26 <vanila> yeah but its not magic
02:24:29 <ab9rf> vinit-ivar: putStrLn takes a String and returns an IO action that "contains" "nothing"
02:24:38 <vanila> its like reading a recipe, you see the words and do them
02:24:45 <vanila> the haskell runtime will see IO actions and do them
02:25:02 <d3lxa> spoiler: the recipe is hidden in the monad IO
02:25:09 <ab9rf> if that action is executed (which is not guaranteed, of course), then it'll be executed by the runtime
02:25:15 <vinit-ivar> vanila - but doesn't the haskell runtime also use pure functions to do so? or is it C?
02:25:19 <ab9rf> you can create IO actions that are never executed
02:25:24 <vinit-ivar> noo no monads yet d3lxa :D
02:25:26 <vanila> no its written in C or assembly or something
02:25:33 <ab9rf> vinit-ivar: IO is a monad :)
02:25:47 <ab9rf> vinit-ivar: the runtime is not pure
02:25:53 <Soft-> I was playing around with some type classes but I can't seem to make this type check http://dpaste.com/3CM3MC7 http://dpaste.com/1C943RY
02:26:00 <d3lxa> that just means here you can hide "things" in IO without disrupting your return type here () which is nothing, weird huh?
02:26:07 <vinit-ivar> okay, I think I get it now :D
02:26:10 <vinit-ivar> kinda
02:26:18 <glguy> It's executed only if you sequence that operation into your main, but your e getting it
02:26:31 <ab9rf> vinit-ivar: but the runtime never reaches down into your haskell functions, it's always out beyond the curtain
02:26:49 <geekosaur> think of your program as lazily producing IO actions in ther "main" function and the runtime quasi-lazily consuming and executing them
02:27:13 <geekosaur> if your IO action can make its way back to main then it will be executed
02:27:31 <vinit-ivar> so, the execution of the IO actions itself is not pure, but functions like putStrLn are pure *because* they just return IO actions?
02:27:39 <ab9rf> vinit-ivar: exactly
02:27:53 <d3lxa> :)
02:28:21 <vinit-ivar> brilliant :D
02:28:23 <vinit-ivar> thanks, you lot :)
02:28:32 <d3lxa> haskell happened again :D
02:29:00 <ab9rf> wait till you understand that you can do the same thing with monads that aren't IO :)
02:29:25 <d3lxa> question, can I use uniplate to convert recursively all Name in this AST https://hackage.haskell.org/package/simple-sql-parser-0.4.0/docs/Language-SQL-SimpleSQL-Syntax.html#t:QueryExpr ? what should I use otherwise?
02:30:13 <vinit-ivar> i'm sure I'll be back asking for help when I reach that point, ab9rf :P
02:30:25 <glguy> Syb is probably the easiest way to manipulate all the Name values there
02:31:06 <Soft-> Hmm the error seemso go away if I explicitly use Float in the definitions instead of Floating constraint
02:31:19 <glguy> If you're going to write very little code, at least
02:31:24 <d3lxa> glguy: scrap your boilerplate?
02:31:29 <glguy> Yeah
02:31:43 <d3lxa> glguy: I thought uniplate was an implementation of this, isn't it then(
02:31:52 <HugoDaniel> wait until you start running away from io by fearing that the allmighty monomorphic gods send you and your descendants to hell for all your unholy/unpure wrongdoings
02:32:18 <d3lxa> glguy: my plate-boiler'ed code is here https://github.com/axel-angel/haxquery/blob/master/Main.hs#L143 and I wanna remove all these bloat
02:32:49 <geekosaur> Soft-: by using type variables a and b you are asserting that they can be different, but then using them in operatiosn that require them to be the same
02:33:03 <geekosaur> (nearestNeighbors)
02:33:28 <geekosaur> I think.
02:33:34 <glguy> You might be able to do it with uniplate's biplate stuff
02:33:53 * geekosaur is only awake because sinus havoc, is not at all braining well...
02:33:58 <d3lxa> glguy: I'm scared, I already need biplate, really?
02:34:36 <glguy> transformBi :: Biplate from to => (to -> to) -> from -> from
02:34:38 <geekosaur> but the error you are getting is at least compatible with that thesis...
02:34:52 <HugoDaniel> wait until all your code disapears in a Generic big line of deriving overengineered classes
02:36:18 <BubbleGum> Hello. Is it possible today use ghc (and haskell platform) with cygwin instead mingw?
02:36:24 <geekosaur> or turns into a lens
02:36:37 <HugoDaniel> ahah yes
02:36:38 <ab9rf> BubbleGum: good luck with that, i tried and failed.
02:36:55 <d3lxa> HugoDaniel: I'm barely trying to understand how it really works and how to use it… so not yet
02:37:13 <Fylwind> BubbleGum: https://ghc.haskell.org/trac/ghc/wiki/Building/Windows/Cygwin may be useful ...
02:37:15 <HugoDaniel> wait until your vim config file is so big that just by starting vim you will get half a dozen ghc type mismatching errors
02:37:19 <BubbleGum> ab9rf: I failed also.
02:37:41 <d3lxa> glguy: I love the right part of this function signature, now I have to work out the Biplate typeclass
02:38:30 <d3lxa> glguy: oh wait, I need this instead: (Biplate from to, Monad m) => (to -> to) -> from -> m from
02:39:12 <glguy> :t template
02:39:13 <lambdabot> (Applicative f, Typeable a, Data s) => (a -> f a) -> s -> f s
02:39:23 <d3lxa> :t transformBiM
02:39:24 <lambdabot>     Not in scope: ‘transformBiM’
02:39:24 <lambdabot>     Perhaps you meant one of these:
02:39:24 <lambdabot>       ‘transformM’ (imported from Control.Lens),
02:39:33 <d3lxa> glguy: I found this transformBiM
02:39:59 <d3lxa> precisely the signature I want then
02:40:02 <glguy> Template is the relevant function if you were using lens
02:45:58 <d3lxa> glguy: I'm not, but why should I use them in my case? uniplate will give me the instance I'm directly concerned, no need to dive into it with lens
02:50:21 <u-ou> could somebody pls demonstrate a simple practical example of local using do syntax?
02:50:26 <glguy> Lens is a general framework for structuring data manipulation in a composable and reusable way
02:51:39 <vanila> u-ou, local ?
02:51:40 <d3lxa> glguy: how is that "universe" in uniplate filter its returning type magically? does it uses Typeable to check every node?
02:51:45 <Axman6> :t local
02:51:46 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
02:51:53 <geekosaur> presumably from Reader
02:51:55 <glguy> Covers what uniplate does and a lot more. No need to rush to use it though
02:52:53 <fizruk> u-ou: think of letting subroutine to a part of a config (that is relevant to that particular subroutine), for instance
02:53:00 <geekosaur> u-ou, most of the examples I'm aware of involve using it in a compiler to compile a block with its own set of local variables in the Reader context
02:53:12 <d3lxa> glguy: so what you are saying is that lens can replace functionnality-wise uniplate?
02:53:24 <glguy> The biplate stuff is typeable and Data based
02:53:25 <geekosaur> although I have used it to run GUI actions with local temporary overrides to settings
02:53:31 <Axman6> u-ou: do you unerstand how the reader monad works?
02:53:36 <shachaf> A big chunk of uniplate is a special case of lens.
02:53:47 <shachaf> And lens has a .Plated module to replace it almost directly.
02:53:49 <u-ou> Axman6: I think so
02:53:57 <d3lxa> shachaf: oh… nice to know
02:53:58 <indiagreen> u-ou: here's a slightly impractical example, but still: a “quicksort”: http://lpaste.net/118661
02:54:11 <glguy> Yeah, lens is more general than uniplate
02:54:12 <shachaf> (And lens has some tricks that can improve performance, too.)
02:54:30 <shachaf> i,i a big chunk of Prelude is a special case of lens
02:54:34 <Axman6> u-ou: well, local lets you run a sub computation with a different conext.
02:54:44 <ab9rf> heh
02:54:49 <u-ou> mmmm
02:55:11 <ab9rf> is there anyhting that is not a special case of lens? :)
02:55:14 <d3lxa> uniplate is magic, this is magic: (Data a, Typeable a) => Uniplate a
02:56:15 <Axman6> so, say you were running with the reader value of 1, and you used local (+1) $ do foo; bar; baz, then foo, bar and baz would see see the value 2, but anything after the call to local would see 1 again
02:57:24 <u-ou> yeah, I understood how it works, I just wondered when you'd want to do that. but then hearing somebody else explain how it works kinda shows that.
02:57:56 <glguy> Ab9rf: the network library is not, for sure
03:00:12 <ab9rf> glguy: heh
03:00:30 <Axman6> u-ou: one place where it's quite nice is for things like compilers where you need to do something within a certain context, say binding a free variable to a value for only the specific subsomputation you're evaluating
03:01:07 <Axman6> (well, evaluation more than compilers)
03:03:30 <u-ou> makes sense =)
03:04:44 <chaosmasttter> o-ou: i used it in a logger which worked on a tree and need the depth of the tree
03:19:48 <breadmonster> I'd like to write a C compiler in Haskell. Any tips?
03:20:38 <Cale> http://hackage.haskell.org/package/language-c might be useful
03:22:22 <vanila> what are you compiling it to?
03:22:51 <breadmonster> Cale: Yeah, I saw that, but that really does most of the work for me.
03:23:07 <Cale> Well, it does the parsing
03:23:24 <breadmonster> vanila: I was originally thinking of compiling to C.
03:23:28 <vanila> C to C?
03:23:30 <vanila> lol
03:23:34 <breadmonster> ...it's a learning experience.
03:23:35 <breadmonster> :P
03:23:42 <breadmonster> But maybe LLVM?
03:24:35 <breadmonster> Or is that a bit much?
03:25:09 <Axman6> it's certainly possible, but probably not trivial to do
03:25:46 <vanila> most people haven't written a C compiler
03:25:50 <breadmonster> Axman6: Argh, I can't find a suitable project that can sustain my interest, I'm really not into web programming.
03:26:05 <breadmonster> vanila: Yeah, that's also why it's exciting, I actually pick up some theory.
03:26:08 <Axman6> I'd start with building each stage in the compilation process; lexer, then parser (or, possibly pre-processor) then start thinking about how to compile it
03:26:39 <breadmonster> Axman6: what I was thinking was build the parser, and then see if I can dump the AST to a text file.
03:26:40 <vanila> I think you can do it if you work really hard
03:26:50 <breadmonster> Then figure out what to do with that.
03:26:54 <vanila> LLVM isn't too interesting to me but if you use that it makes this a lot easier
03:26:59 <AshyIsMe> breadmonster: feel like adding syntastic and fugitive to Yi?
03:27:02 <AshyIsMe> :P
03:27:22 <breadmonster> AshyIsMe: I really, really wish I could say yes, but I have no idea what that is.
03:27:47 <breadmonster> Also, just for kicks: janestreet.com/puzzles/archive/
03:27:58 <AshyIsMe> yi is an editor written entirely in haskell that supports emacs and vim style usage
03:28:00 <breadmonster> I mean this: http://jakepoz.com/soviet_debugging.html
03:28:14 <breadmonster> And what's syntastic and fugitive?
03:30:56 <AshyIsMe> vim plugins, syntastic highlights lines with compiler errors while you're editing and fugitive is a git interface
03:31:11 <breadmonster> Hmm, fugitive seems a lot easier to implement :
03:31:26 <AshyIsMe> they're both really nice if you're a vim user, otherwise prepare to go down the rabbit hole...
03:32:09 <breadmonster> AshyIsMe: I'm a Sublime Text user...
03:33:18 <AshyIsMe> learning vim is a project in its own right so you're probably better off finding a haskell project...
03:33:30 <breadmonster> Yeah, fair enough.
03:33:39 <breadmonster> Is there a MLton for Haskell?
03:33:57 <vanila> what do you mean
03:36:43 <Reite> How can I get cabal to tell me about files I forgot to list in exposed-modules or other-modules?
03:37:00 <breadmonster> vanila: A whole program optimizing compiler.
03:37:19 <vanila> ah there was one a long time ago
03:37:27 <breadmonster> vanila: what happened to it?
03:37:36 <vanila> nothing
03:37:55 <vanila> and haskell keeps breaking all the code people wrote, so it will probably be imposible to build it today
03:38:07 <breadmonster> Because of different versions, you mean?
03:38:11 <vanila> yeah
04:01:09 <ChristianS> vanila: when does haskell break code?
04:01:41 <vanila> when they change the std lib and language all the time
04:02:51 <ChristianS> vanila: in backward-incompatible ways, you mean. can't say i notice very much of that.
04:05:55 <vanila> youre lucky
04:29:38 * hackagebot repl-toolkit 0.3.0.0 - Toolkit for quickly whipping up command-line interfaces.  http://hackage.haskell.org/package/repl-toolkit-0.3.0.0 (jtapolczai)
04:30:46 <Black0range> hey guys, i'm trying to run cabal install cabal-install. It says that it updated successfully but the version doesn't change. Anyone have had any similar problems?
04:31:35 <indiagreen> Black0range: perhaps ~/.cabal/bin (or its Windows equivalent) is not in your PATH?
04:33:09 <shiona> I had this problem when my from-platfrom-repo installed cabal was in $PATH before .cabal/bin
04:34:45 <Black0range> hmm where should the exact location of cabal/bin be?
04:34:48 <Black0range> (osx)
04:41:31 <mpickering> ~/.cabal/bin
04:44:42 <tpsinnem> anyone here using the applicative-quoters package? i know it's unmaintained but might it have been able to not bit-rot yet?
04:50:03 <RaceCondition> what is the most common IDE/editor used by Haskellers?
04:50:36 <d1ngell_> RaceCondition: usually Leksah
04:50:50 <RaceCondition> d1ngell_: ok, that's what I thought, and after that? Emacs?
04:52:13 <d1ngell_> RaceCondition: after that I guess it varies a lot. But I've seen many people using KDevelop and Emacs
04:52:17 <Geraldus_> d1ngell_: I've used emacs a bit, majorly vim and sublime
04:52:42 <RaceCondition> does Leksah have an external/public API which could be called from, say, Emacs?
04:52:55 <RaceCondition> so as to not have to use its GUI
04:53:15 <Geraldus_> d1ngell_: this is good article for vim lovers http://www.stephendiehl.com/posts/vim_haskell.html
04:53:27 <RaceCondition> as an Emacs user on OS X, it's quite terrible to use a GTK based GUI with no Emacs editing power
04:54:58 <d1ngell_> RaceCondition: I don't think it does have such API
04:55:14 <d1ngell_> RaceCondition: however, I believe in your case you'd do fine with Emacs
04:55:20 <Geraldus_> RaceCondition: ask hamishmack on #leksah
04:55:41 <d1ngell_> Geraldus_: interesting article
04:56:24 <RaceCondition> d1ngell_: "in my case" meaning what?
04:56:26 <hamishmack> RaceCondition: What sort of thing would you want Leksah api to do?
04:56:47 <Geraldus_> glad if it's also helpful. In my opinion Vim is much haskell friendly rather that sublime text now, though I'm writing code in sublime
04:56:48 <RaceCondition> hamishmack: I just mean the overall power it most likely provides over whatever Emacs uses 
04:56:50 <d1ngell_> RaceCondition: you have previous experience with Emacs
04:57:12 <RaceCondition> d1ngell_: yeah, but if Leksah's IDE powers are much stronger, I'd be losing out
04:58:30 <hamishmack> RaceCondition: You should try out Leksah and the haskell emacs things (like ghc-mod)
05:03:04 <hamishmack> RaceCondition: One thing Leksah does support is automatically reloading modified open files.  This can make it easier to modify files outside of Leksah in another editor.
05:03:45 <RaceCondition> hamishmack: yes, that's a very viable workflow; I've used it for Scala with Emacs+Ensime and IntelliJ where Ensime lacks
05:03:46 <d1ngell_> RaceCondition: It's not that Leksah is much stronger. It's just been made specifically with Haskell programming in mind, whereas in Emacs you'll pretty much have all the power of Leksah, or at least all the power you actually need to have, by installing haskell-mode.
05:04:12 <RaceCondition> d1ngell_: ok, so things like haskell-mode + ghc-mod give me the same IDE power as Leksah, more or less?
05:05:09 <d1ngell_> RaceCondition: Yes. I'm guessing you really don't want to bring all functionality from Leksah to Emacs, as that'd probably be defeating the purpose of actually using another editor.
05:05:29 <d1ngell_> RaceCondition: that's why you've haskell-mode and ghc
05:05:50 <Averell> does leksah do something like structured-haskell-mode?
05:05:58 <RaceCondition> does Leksah have a better momentum though than ghc-mod?
05:06:08 <RaceCondition> in terms of IDE powers
05:06:21 <RaceCondition> refactoring, autocomplete, etc
05:07:41 <hamishmack> Averell: No stuctured haskell in Leksah yet.  Hopefully it will make its way in via yi integration at some point
05:08:48 <d1ngell_> hamishmack: That's actually a pro for Emacs over Leksah right now
05:09:06 <d1ngell_> hamishmack: But indeed, hope it makes its way.
05:11:26 <tpsinnem> anyone here using the applicative-quoters package? i know it's unmaintained but might it have been able to not bit-rot yet?
05:15:10 <d1ngell_> RaceCondition: I'm pretty sure ghc-mod provides you with these tools on Emacs. You probably won't be missing anything so important by using it over Leksah currently.
05:16:25 <RaceCondition> d1ngell_: ok, that's very good to know :)
05:18:39 <bmuk> Hey everyone; I've just finished working on a simple CRUD "database" in C# that works with pipe delimited value files with some friends for a school project. To expose them to the power of haskell, I was going to rewrite it more succinctly. However, I'm not sure the best way to go about making the CRUD functionality. My gut instinct is to make a data Table a = { Headers :: [a], Rows :: [[a]] } and define the CRUD operations as functions which operate on Tables.
05:19:03 <bmuk> C# code for reference here (https://github.com/bmuk/PipeDB)
05:19:37 <davidxyz> $src ($)
05:19:49 <reem> ?src ($)
05:19:49 <lambdabot> f $ x = f x
05:20:14 <Geraldus_> ? (->r)
05:20:22 <Geraldus_> ? ((->)r)
05:20:57 <davidxyz> $src zipWith
05:22:05 <Geraldus_> ?src (->r)
05:22:05 <lambdabot> Source not found. My pet ferret can type better than you!
05:22:13 <Geraldus_> ?src ((->)r)
05:22:13 <lambdabot> Source not found. Whoa.
05:22:33 <Geraldus_> ?src zipWith
05:22:33 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
05:22:33 <lambdabot> zipWith _ _      _      = []
05:23:48 <davidxyz> am i using the lambdabot correctly? i just tried 2 tests, and got 2 responses... were they from lambdabot, or did someone else (reem, Geraldus_) repeat my tests to get them to work? thanks!
05:24:57 <reem> davidxyz: ?src is the correct thing to use
05:25:01 <reem> $src doesn't work
05:25:15 <davidxyz> woops, thanks
05:25:22 <davidxyz> ?src ($)
05:25:23 <lambdabot> f $ x = f x
05:25:26 <davidxyz> wow cool
05:25:44 <davidxyz> ?src map
05:25:44 <lambdabot> map _ []     = []
05:25:44 <lambdabot> map f (x:xs) = f x : map f xs
05:26:06 <Geraldus_> :)
05:26:40 <davidxyz> i'm kinda bleary-eyed, was up all night studying yesod
05:27:34 <davidxyz> > map (+1) [1..10]
05:27:35 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
05:30:59 <davidxyz> Wow! I just discovered this weird trick in ghci. If I hit 'tab', it shows *all* the function names currently defined.
05:31:56 <davidxyz> http://en.wikibooks.org/wiki/Haskell/Using_GHCi_effectively#Tab_completion
05:33:28 <ClaudiusMaximus> davidxyz: yep, i like :browse too (shows a module contents with type signatures)
05:34:27 <davidxyz> ClaudiusMaximum: cool
05:34:36 <davidxyz> ClaudiusMaximus: cool
05:34:39 * hackagebot interchangeable 0.2.0.0 - A type class for interchangeable data.  http://hackage.haskell.org/package/interchangeable-0.2.0.0 (arowM)
05:34:41 * hackagebot leksah-server 0.14.3.1 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.14.3.1 (HamishMackenzie)
05:35:04 <ClaudiusMaximus> davidxyz: tab completion works in some (most?) irc clients too
05:35:07 <Geraldus_> Haskell is amazing from any side :)
05:41:08 <bjorkintosh> bmuk, why not expose them to FP gently via F#?
05:42:51 <bmuk> bjorkintosh: That is an option I have been looking at; I have never personally used F#, though. How foreign is it (from haskell)?
05:43:24 <bjorkintosh> It's cousins with Ocaml if that helps :)
05:43:33 <bmuk> I'm still interested (just for my own knowledge) in the best (or at least better) way to solve my problem
05:44:12 <bjorkintosh> well, it works directly on .net so they never have to see anything scary.
05:44:23 <bjorkintosh> it'll all look very familiar until it's too late.
05:44:27 <bmuk> I watched a talk on it last night and not putting types on their own line looked like it would really discourage writing them
05:44:39 * hackagebot leksah 0.14.4.0 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.14.4.0 (HamishMackenzie)
05:45:29 <bmuk> it looked like (maybe there are multiple ways) you had to say 'let (fib :: Int) (n :: Int) = ...'
05:47:16 <bmuk> Regardless, I want to plan out how to write this in a functional way :P it should translate to f#
05:48:32 <bjorkintosh> bmuk you're not familiar with the MLs?
05:48:57 <bmuk> bjorkintosh: no, but I can read them (at least a tell myself I can)
05:49:41 <bjorkintosh> worth learning in addition to haskell.
05:51:35 <bmuk> bjorkintosh: I'll definitely check them out. F# is on my list, because this was my first C# (windows, even) project, and .NET is pretty nice. They were showing me C# through this project, but I think I went rogue with spaghetti code because I didn't really use OOP.
05:52:21 <bjorkintosh> ah.
05:52:30 <bmuk> if you look at https://github.com/bmuk/PipeDB under Application, Shell.cs, Table.cs, Parser.cs, and Menu.cs were my biggest contributions.
05:53:39 <bmuk> I think I had the same problem that I had when getting back into python after haskell in that I reach for functional constructs and the language doesn't *really* support them. So the code ends up unintelligible to anyone else.
05:53:58 <bmuk> Do you think the ADT with helper functions is the way to go ?
05:55:30 <kqr> hey awesome people! when cabal tries to install streaming-commons-0.1.9.1 it fails because it can't find Data.ByteString.Builder.Extra... where do I go from there?
05:56:39 <bjorkintosh> bmuk in writing FP instead of OOP in a language which mainly supports OOP?
05:57:22 <bmuk> sorry, I meant for translating this to F# or haskell
05:59:18 <bjorkintosh> translate the problem, not the code :)
05:59:39 * hackagebot blaze-markup 0.6.3.0 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.6.3.0 (JasperVanDerJeugt)
06:01:12 <Saizan> kqr: well, that module comes from bytestring-builder
06:02:30 <bmuk> bjorkintosh: :) that's what I need help with lol
06:02:41 <kqr> Saizan, hm... was it somewhat recently split out of bytestring?
06:02:49 <Saizan> kqr: there are two versions of that, try --constraint="bytestring-builder == 0.10.4.0.1"
06:03:12 <kqr> Saizan, because I have a successful installation of the same project on another machine and it seems as though bytestring-builder is not installed on that
06:03:20 <kqr> Saizan, though it did have an older version of bytestring instead
06:03:26 <kqr> Saizan, so i'm trying with that right now
06:03:56 <Saizan> kqr: older versions of streaming-commons didn't depend on that package
06:04:29 <kqr> oh that might be it, then
06:04:41 <kqr> I've pinned streaming-commons to the same version as on the working install as well
06:06:10 <Saizan> mh, looks like for bytestring-builder the problem might be the flags, rather than the version
06:07:55 <Npmvio> ciao
06:07:57 <Npmvio> !list
06:07:58 <monochrom> Npmvio: http://lpaste.net/browse
06:11:23 <davidxyz> :quit
06:11:28 <davidxyz> :exit
06:11:52 <indiagreen> davidxyz: do you mean “/quit”?
06:12:11 <efilum> hello
06:12:24 <davidxyz> indiagreen: yes, i think so - thanks!
06:24:39 * hackagebot calculator 0.1.4.0 - A calculator that operates on string inputs  http://hackage.haskell.org/package/calculator-0.1.4.0 (sumitsahrawat)
06:26:44 <statusfailed> Facebook used to have some challenges for programmers, a bit like hackerrank- does anyone know if they still exist?
06:27:07 <statusfailed> There was one called something like "dinosaur island" that I'm specifically trying to recall
06:32:16 <jophish> chrisdone: hindent is pretty awesome. Thanks!
06:34:39 * hackagebot jsaddle 0.2.0.3 - High level interface for webkit-javascriptcore  http://hackage.haskell.org/package/jsaddle-0.2.0.3 (HamishMackenzie)
06:39:25 <marchelzo_> How could I get this to work without an infinite loop? http://lpaste.net/4463219160897290240
06:39:50 <marchelzo_> I'm trying to do what is described here: http://en.wikipedia.org/wiki/Regular_number#Algorithms
06:42:18 <indiagreen> marchelzo_: “forever” doesn't do what you think it does
06:42:20 <exio4> 'forever g x = forever g (g x)' this doesn't look like it would terminate
06:42:33 <marchelzo_> well yeah
06:42:37 <marchelzo_> that's my question
06:42:54 <indiagreen> ah, you've defined your own forever, sorry, haven't noticed
06:43:21 <marchelzo_> yeah sorry I couldn't think of a better name, and I wasn't using the monad one
06:43:59 <ClaudiusMaximus> marchelzo_: merge :: Ord a => [[a]] -> [a]   might me easier to implement using   merge2 :: Ord a => [a] -> [a] -> [a]  instead of trying to do it all at once
06:44:52 <ajcoppa> statusfailed: those puzzles have been gone for a few years now. if you google around, you can find some of the problem specifications
06:45:04 <ajcoppa> i remembered them and went on a similar kick about a year ago
06:45:51 <marchelzo_> ClaudiusMaximus: merge seems to be working fine
06:48:30 <ClaudiusMaximus> marchelzo_: the main point of the article (though not shown exxplicitly) seems to be that you can define recursive infinite values in haskell thanks to lazy evaluation:  hs = 1 : merge [ map (2*) hs, ... ]
06:49:20 <marchelzo_> yeah I knew what it was saying, but for some reason I just couldn't think of how to do it.
06:49:25 <marchelzo_> You're exactly right though
06:49:26 <marchelzo_> thanks
06:51:21 <d3lxa> what's the diff between 'descend' and 'transform' in uniplate? I don't understand the doc, thanks
07:12:38 <bjorkintosh> has anyone installed hoogle via cabal lately?
07:23:04 <indiagreen> bjorkintosh: I have, about 10min ago
07:24:09 <bjorkintosh> no errors?
07:24:20 <indiagreen> no errors
07:24:22 <bjorkintosh> streaming-commons is giving me a headache.
07:24:32 <bjorkintosh> it fails to install
07:24:51 <indiagreen> well, I already had it installed
07:24:53 <indiagreen> 0.14
07:24:57 <indiagreen> *0.1.4
07:25:45 <indiagreen> however, I have just managed to install the latest streaming-commons without errors as well
07:26:16 <Dodek> hey, i'm writing an RPC library over zeromq. what would be the best package category? Network.*?
07:29:39 * hackagebot leksah-server 0.14.3.2 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.14.3.2 (HamishMackenzie)
07:32:26 <YaRly> How do you make ghci not show the result of a function? (e.g. not print out a long list)
07:35:13 <ClaudiusMaximus> YaRly: let dummyVariable = ...   ;   dummyVariable <- ...    depending on whether the function is pure or an IO action
07:35:37 <YaRly> yea...just figured that out... thank you
07:38:52 <kaiko> How can I compile ghc with -fPIC option?
07:39:37 <reem> Does anyone know a good guide to cabal sandboxing?
07:56:32 <LnL> Can I ask a question about the haste-compiler here?
08:05:00 <benzrf> LnL: probably
08:05:10 <benzrf> LnL: theres less chance of it getting answered, ofc
08:05:19 <benzrf> LnL: i think there might be a haste channel but im not sure
08:05:36 <LnL> Yeah but it seems a little deserted
08:06:00 <Dodek> hm, is Chris Kuklewicz hanging around here by any chance?
08:06:19 <LnL> so I was wondering if it's possible to inline a foreing javascript function
08:07:12 <LnL> both imports and the ffi function require a wrapper
08:09:40 * hackagebot twitter-types 0.6.1 - Twitter JSON parser and types  http://hackage.haskell.org/package/twitter-types-0.6.1 (TakahiroHimura)
08:10:38 <nadirs> Hello, is there an existing function that works like `(\xs ys -> union (xs \\ ys) (ys \\ xs))`?
08:10:59 <nadirs> i.e. it takes the difference list of both arguments?
08:11:11 <nadirs> s/takes/returns/
08:12:02 <tpsinnem> anyone here using the applicative-quoters package? i know it's unmaintained but might it have been able to not bit-rot yet?
08:14:13 <mpickering> I think it probably has bitrotted
08:14:57 <mpickering> actually no.. looks like it still builds
08:15:07 <mpickering> http://hydra.nixos.org/build/18780514
08:24:40 * hackagebot strive 0.7.0 - A Haskell client for the Strava V3 API.  http://hackage.haskell.org/package/strive-0.7.0 (fozworth)
08:29:56 <mhl> Hi, I'm trying to install ghc-mod. Cabal tries to install ghc-mod-0.3.0, but it fails with error: Not in scope: data constructor `ExplicitForall'. How can I install newer version of ghc-mod? Cabal shows me that default version for download is 5.2.1.2.
08:34:40 * hackagebot descriptive 0.2.0 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.2.0 (ChrisDone)
08:43:04 <favetelinguis> trying to implement foldable for a rosetree from the example in Haskell Data Analysis Cookbook but im not rly understanding every part, here is my implementation http://lpaste.net/118684 For example i think there is an error in his implementation, where does he get the Null value from? http://lpaste.net/118684
08:44:05 <favetelinguis> Also, how can he use functions from monoid when he has made no instance of this tree in Monoid?
08:51:41 <benmachine> favetelinguis: if you've copied the example correctly I agree that it's wrong
08:52:34 <benmachine> favetelinguis: as for the monoid stuff, that's because the result of foldMap is a monoid
08:52:54 <mr-> favetelinguis: Null does not make sense her, that's true. You may add it as a contructor for the Rosetree, though.
08:53:08 <benmachine> favetelinguis: in this case, foldMap :: (Monoid m) => (a -> m) -> Tree a -> m, which means you can use monoid stuff to make the result
08:53:12 <mr-> s/her/here/
08:54:33 <favetelinguis> so just removing the Null case would valid solution?
08:55:39 <mr-> Looks good to me
09:12:46 <vanila> is anyone familiar with SECD machine?
09:12:48 <vanila> or other abstract machines
09:13:39 <stephen_> Anyone using haskell for embedded stuff? I'm familiar with Galois' Copilot and Ivory projects: any other projects of note that I should check out?
09:13:46 <sm> hmm, no ghc 7.8.4 binary for mac osx
09:15:48 <johnw> sm: huh?
09:16:36 <johnw> ah, you are right :(
09:16:55 <sm> yeah the mac osx section got dropped from GHC 7.8.4's download page, perhaps because ghcformacosx.com now exists (and that doesn't have 7.8.4 yet)
09:17:27 <indiagreen> it's also down for me
09:18:47 <sm> indiagreen: http://ghcformacosx.github.io/ , I meant
09:19:08 <indiagreen> aha, thanks
09:21:46 <SrPx> "Did you mean: std vector unboxed haskell" No. I mean stvector. Shut off.
09:23:46 <sm> oh, but brew has ghc 7.8.4. Hats off to brew ...
09:25:23 <sm> but, isn't that the one carter is always going on about..
09:25:54 <johnw> um, and Nix has had it for a while...
09:26:52 <glguy> I've just built 7.8.4 from source on my os x machines... But I think the only reason the binary is missing is that the person who build for that platform hasn't, it's not a change in policy
09:28:49 <tpsinnem> mpickering: oh, neat. thanks for the info!
09:29:18 <SrPx> Is there any example on using Data.Vector.Unboxed.Mutable ? I always forget how to create them. The whole ST type thing...
09:39:41 * hackagebot strive 0.7.1 - A Haskell client for the Strava V3 API.  http://hackage.haskell.org/package/strive-0.7.1 (fozworth)
09:40:20 <johnw> SrPx: if you come up with one, please blog it for the rest of us :)
09:41:32 <SrPx> I'd not blog about something I don't understand (i.e., the role of the ST on the type and the whole variable scape thing)... but I'm really thinking in contributing in other ways :)
09:41:53 <johnw> i mean, if you get it working
09:41:57 <johnw> I can help you understand ST itself
09:42:23 <SrPx> yea but I'd be able to explain why it works :(
09:42:38 <johnw> even just code samples would be nice
09:42:40 <SrPx> Ah I kinda understand ST, I don't get that "s" variable there...
09:42:47 <johnw> the skolem
09:42:52 <SrPx> johnw: uhm okay then :) suggest a blogging platform?
09:42:57 <johnw> I use Hakyll
09:43:09 <johnw> here's what the skolem "s" is doing:
09:43:31 <SrPx> beware I read a few times already and didn't get it
09:44:05 <johnw> because "s" is never specialized (i.e., it's always a "forall s"), a unique type is generated for every ST block that is executed
09:44:40 <johnw> basically this means that the type of an STRef created by one ST block can never unify at the type level with an STRef created by another ST block
09:44:41 * hackagebot Foster 1.0.2 - Utilities to generate and solve puzzles  http://hackage.haskell.org/package/Foster-1.0.2 (Jefffrey)
09:45:16 <johnw> that way, you can never find yourself executing one block, and dereferencing an STRef from a block which isn't currently executing (and would thus be dangling)
09:45:44 <johnw> it makes for type-assured, self-contained universes of mutable variables
09:46:07 <johnw> the "s" is literally just like a UUID associated to a value so that two values never compare the same
09:46:16 <johnw> except in this case, it's happening at the type level
09:48:48 <johnw> I'll make you a simpler example
09:49:44 <Layd_23> hi you come please wswswsbukolayscsosm Sign in please
09:49:53 --- mode: ChanServ set +o johnw
09:49:53 --- mode: ChanServ set +o geekosaur
09:49:59 --- mode: ChanServ set +o johnw
09:49:59 <SrPx> johnw: a unique type is generated for every ST block that is executed? ST block, you mean a "do { ... } :: ST s a" ? So you mean that two different blocks (ie, x = do { } :: ST s Int, y = do { } :: ST s Int) have different types... is that it?
09:50:02 --- mode: ChanServ set +o johnw
09:50:03 --- mode: johnw set +b *!*@78.185.8.19
09:50:06 --- kick: Layd_23 was kicked by johnw (Kicked)
09:50:10 --- mode: geekosaur set -o geekosaur
09:50:13 --- mode: johnw set -o johnw
09:50:14 <SrPx> johnw: sorry if this is completely far from what you said ;x
09:50:15 <geekosaur> ok, that was confusing...
09:50:18 <SrPx> I'm trying
09:50:21 <johnw> the two blocks don't have different types
09:50:39 <johnw> geekosaur: which was confusing?
09:50:46 <johnw> one sec, working on a simpler example
09:51:01 <geekosaur> my client says you opped yourself 3 times...
09:51:06 <johnw> yeah, it's a timing thing
09:52:07 <SrPx> okay no prob... please don't worry too much, though, part of the reason I don't get it yet is that I'm leaving a "now it is time to actually learn the type system" for after I'm able to do at least some simple things :)
09:54:23 <johnw> SrPx: try this: if you use newSTRef within one ST block to create an STRef, the 's' within its type will be unique to that ST block
09:54:41 <johnw> the STRef produced is "locked down", because the 's' is tied to its parent
09:54:58 <geekosaur> SrPx: the type of s makes it impossible for (a) it to match any other type (b) any value to be provided for it. so the only way to match it is to "inherit" it by being part of a chain of >> or >>= inside a particular runST
09:55:05 <johnw> if you should try to dereference it within another ST block, for which a different 's' has been generated, you will get a type unification error
09:55:16 <geekosaur> the compiler won't let values whose types include that s "escape" because it can't assign a type to them
09:55:36 <tpsinnem> SrPx: have you looked at the original 'lazy functional state threads' paper?
09:55:51 <tpsinnem> i recall it explains things quite nicely
09:56:03 <geekosaur> so, it becomes a way to tag values as "internal" to a given runST invocation, theough their types
09:57:57 <int-e> This is very, very subtle. Internally, runST will always use the same type for 's', but this is invisible to the caller thanks to the rank-2 type, and cannot be exploited to use references from one ST computation in another.
09:59:33 <geekosaur> also, a possible prerequisite for figuring this out is the notion of phantom types: a type which is not actually present in a value but only in its type, allowing values to be "tagged"
10:00:34 <geekosaur> ST takes that a step further by making it impossible to mix tags, making the values tagged with it completely private
10:00:53 <johnw> SrPx: https://gist.github.com/7b80f976172bdcced50d
10:00:59 <SrPx> A "ST block", you mean, is just a value of type ST s a, right?
10:01:06 <johnw> line 25 gives an error saying that the skolem s would "escape its bounds"
10:02:07 <johnw> err, 24 now
10:02:18 <jophish> Yo yo yo
10:02:35 <jophish> Is there a way to keep all the source after running cabal install?
10:02:39 <johnw> this prevents "x" from being read in the second block
10:02:52 <johnw> because we cannot get a handle to something "owned" by the block, so to speak
10:02:58 <johnw> sorry I'm not being precise enough
10:03:47 <alpounet> jophish: you can do 'cabal unpack' for example to get the sources, then you can cabal install manually
10:04:14 <jophish> that's not quite what I'm looking for. Essentially I have a sandbox and would like to generate tags for all the libraries used in the sandbox
10:04:46 <jophish> Cabal unpack might work if I could get a list of all installed packages in a sandbox
10:06:42 <geekosaur> cabal sandbox hc-pkg list?
10:06:48 <geekosaur> um
10:06:52 <geekosaur> cabal sandbox hc-pkg list --user
10:07:24 <geekosaur> might need a -- in there to keep the cabal command from eating --user so it gets passed on
10:07:42 <jophish> cool beans, I'll give that a try
10:07:49 <jophish> brb, getting tofu from shop
10:09:00 <SrPx> johnw: uh even line 25 alone already triggers the error
10:10:07 <johnw> SrPx: yeah, flaw in my understanding
10:10:15 <johnw> you actually can't even get the STRef out of its parent block
10:10:25 <SrPx> ah my bad, I'm trying to understand
10:11:00 <SrPx> is it possible to encode this minimal example without newtype/monad instance/runIdentity?
10:11:19 <johnw> imagine we had put in a type signature:
10:11:27 <johnw> let x :: Handle s = runFoo $ makeHandle 100
10:11:43 <johnw> but which 's' is that?
10:12:01 <johnw> in fact, it's an invalid type
10:12:19 <johnw> there is no type you can give to x that will unify with what is return from that runFoo
10:12:34 <johnw> SrPx: let me try to pare it down more
10:13:35 <SrPx> *brian melting* uh... you want ot create a Handle outside the type Foo.. that is not possible because the "s" there can't be anything, since there is no "s" actually used by the actual value of Handle?
10:13:39 <SrPx> brain
10:14:01 <johnw> SrPx: gist updated
10:14:14 <johnw> we can delete readHandle too
10:14:22 <SrPx> can you create a Handle outside Foo??
10:14:35 <SrPx> not getting one out... just creating a Handle outside it
10:14:36 <johnw> yes, you could
10:14:39 <SrPx> how
10:14:53 <johnw> Handle 10 :: Handle Int
10:15:05 <johnw> gist updated
10:15:22 <gcganley> Pamelloes: im just reformatting some of your documentation to fit on 80 width screens
10:16:14 <SrPx> ah okay interesting, so you can do "let x = Handle 10 :: Handle Bool; print $ getHandle x"... okay, so far so good
10:16:29 <SrPx> "s" has nothing to do with the type that handle holds, ok
10:17:21 <SrPx> Okay
10:19:01 <SrPx> Okay I get it, so the "s" used by Handle when you create it inside "Foo" is the same "s" that is "created" by the "forall s. Foo s a" ... which is nothing (?), a variable, dunno, just something that doesn't make sense outside the binder
10:19:07 <SrPx> is that it?
10:19:17 <johnw> exactly
10:19:21 <johnw> it's called a skolem
10:20:00 <johnw> so, outside of Foo, we can make Handles by tagged them with any type we choose, and anyone can use them.  But inside a Foo, we can make Handles that can only be used from within that very same runFoo.
10:20:27 <johnw> we could make global handles inside of Foo too, if we wanted too
10:20:44 <johnw> but the power is the ability to use makeHandle to make "Foo-block scoped" Handles
10:21:18 <johnw> and not just scoped inside any Foo, either, but each Foo block which is executed has its own Handles
10:21:26 <SrPx> Is it impossible to write a different "runFoo" that extracts the value created by "makeHandle"?
10:21:43 <int-e> And you can put everything in a separate module that doesn't export the Handle constructor; then one can restrict creation of Handles to makeHandle (running inside some Foo)
10:21:56 <johnw> you can return the Handle created from outside of its Foo block
10:22:04 <johnw> so even if you could write such a runFoo, you wouldn't be able to pass it anything
10:22:09 <int-e> SrPx: you can get the handle out using an existential type. It won't help you using it from another Foo block.
10:22:30 <johnw> s/you can/you can't
10:22:32 <johnw> right
10:22:44 <johnw> using makeHandle traps its Handle within the Foo it was executed within
10:22:59 <johnw> using Handle 100 :: Handle a, for some specific a, makes a free Handle
10:23:05 <int-e> (in GADT syntax: data HandleBox where HandleBox :: Handle s -> HandleBox; the HandleBox can escape the Foo context)
10:23:19 <johnw> (but still can't be used)
10:23:52 <int-e> (but when trying to use the handle in another (or even the same...) context, the compiler will complain that the 's' inside the GADT is different from that in the other context.)
10:24:27 <johnw> the GADT really means: data HandleBox where HandleBox :: forall s. Handle s -> HandleBox
10:24:40 <johnw> since that forall s can unify with anything, it allows the Handle to be embedded in the HandleBox
10:24:41 * hackagebot ForkableT 0.1.0.2 - Forkable monad transformers  http://hackage.haskell.org/package/ForkableT-0.1.0.2 (AndrasSlemmer)
10:25:05 <johnw> but when you try to pull it out, you won't be able to indicate its type
10:25:21 <SrPx> makeHandle isn't making a Handle then, it is making a "Foo" with a "Handle" inside so that the resulting type is "forall s . Foo s (Handle s)" ... is that all correct? We could rename "Foo" to "Scope", does this make sense?
10:25:54 <int-e> @type readFile
10:25:55 <lambdabot> FilePath -> IO String
10:25:59 <johnw> it's making an action for some future forall s. Foo s that can produce a Handle in that forall s. Foo s
10:26:08 <johnw> yeah, Scope is a better name
10:26:34 <johnw> gist updated
10:26:38 <johnw> now we're calling them Scope and Var
10:27:00 <johnw> makeVar is something like alloca now
10:27:12 <johnw> it makes an ephemeral variable that cannot be referenced outside its Scope
10:27:22 <SrPx> Okay I really get how it works now... but then, how can we get anything outside it at all? ST can do it, right.
10:27:40 <johnw> runFoo can return non-Handles just fine
10:27:45 <johnw> anything which is not tagged with 's' can escape
10:28:06 <johnw> so you can use your Vars in an algorithm that produces some other type of value
10:28:34 <johnw> ST is a lot like a locally scoped IO whose only capability is to operate on IORefs
10:28:41 <BMeph_> johnw: Do you know, is the phantom type, 's', related to the generative types that Dr. Harper goes on about all the time?
10:28:57 <johnw> BMeph_: I don't know; Dr. Harper is still a mystery in my life
10:29:12 <int-e> SrPx: There's nothing to compose different Scope-d computations yet. It should really be an Applicative Functor, Monad or perhaps Arrow...
10:29:37 <johnw> yeah, as a Monad, binding two Scope s actions together gives you a composite Scope s
10:29:51 <int-e> SrPx: so that one can have several variables in a scope, manipulate them, and finally extract a result (say, using getVar) from the whole computation.
10:29:53 <johnw> allowing you build up an algorithm within a single Scope
10:30:19 <johnw> runST $ do x <- newSTRef ; writeSTRef x 100 ; readSTRef x
10:30:22 <BMeph_> Anyone else here acquainted enough with SML to answer that?
10:30:22 <johnw> result = 100
10:31:24 <SrPx> HMm but how IO locks its values without a skolem
10:31:35 <johnw> it doesn't, they are program global
10:31:36 <n4x> you can't escape IO
10:31:48 <johnw> yeah, they can only be used within IO
10:31:49 <SrPx> Ah!
10:32:09 <SrPx> So I can create an IORef and access it from another IORef created elsewhere completely unrelated
10:32:32 <EvanR> IORef (IORef X)
10:32:41 <int-e> SrPx: yes. you can pass them from one thread to the next and they'll still work, and there's nothing in the type system to prevent that.
10:33:27 <SrPx> uhmmm
10:33:28 <johnw> yep
10:33:40 <johnw> ST is _much_ easier to reason about
10:33:53 <johnw> it's really State with an unlimited number of stateful types
10:34:14 <SrPx> okay I guess I do get it now ... but I'm feeling guilty for borrowing your time like that (if I'm not already in such an enormous debt with this channel) ... thank you johnw
10:34:28 <johnw> it's a Sunday, and chatting about Haskell is my chosen hobby for a fun day
10:34:43 <SrPx> lets see if I can create my array with this new knowledge
10:34:50 <SrPx> :P
10:35:06 <johnw> there's still getting a firm grip on what skolems are, but I'll leave that your future examinations of the type system
10:35:20 <johnw> at least now we see clearly one use of them
10:39:07 <EvanR> where does cabal put the downloaded packages (osx)
10:43:18 <johnw> almost everything should appear under ~/.cabal unless you are using sandboxing
10:43:45 <systemfault> Can someone tell what's the practical difference between <something> and <something>T (Reader and ReaderT)
10:44:08 <johnw> the latter is a transformer
10:44:13 <johnw> State: s -> (a, s)
10:44:17 <johnw> StateT: s -> m (a, s)
10:44:35 <johnw> even transformer allows that 'm' to appear in the underlying type
10:44:38 <johnw> every*
10:45:01 <johnw> Reader: e -> a  ReaderT: e -> m a
10:45:02 <johnw> etc.
10:45:05 <systemfault> Ah ok, so transformers are more general
10:45:07 <SrPx> okay got it, ST s (MVector (ST s Int) Int)
10:45:09 <johnw> yes
10:45:13 <johnw> Reader is really ReaderT Identity
10:45:19 <johnw> err, ReaderT e Identity a
10:45:33 <johnw> SrPx: yay!
10:45:49 <SrPx> but I don't get the type. Why 2 "ST"? The thing that is changing is the MVector, so it is inside ST. Okay, I get. Now, inside MVector itself we have another (ST s Int)...
10:46:02 <johnw> that's a vector of ST actions
10:46:06 <SrPx> Couldn't it be just "ST s (MVector Int)" ?
10:46:16 <johnw> it could
10:46:19 <johnw> well
10:46:25 <johnw> ST s (MVector Int Int)
10:46:41 <johnw> if MVector were a Traversable, you could just use sequenceA to get to that type
10:46:44 <athan> So, all open type families causes substitutions on it's left hand side before matching, because all open family equations are "compatible", meaning their substitutions are disjoint, both in the left and right hand sides?
10:47:18 <SrPx> uh what... but "Int" is not an instance of PrimMonad
10:47:22 <johnw> ah, I see
10:47:27 <SrPx> what is the first and what is the second Int
10:47:32 <SrPx> johnw: no, but it compiles
10:47:33 <johnw> so it wants a vector of actions
10:48:02 <SrPx> new :: (PrimMonad m, Unbox a) => Int -> m (MVector (PrimState m) a) -- but "new 100 :: MVector Int INt" compiles oO
10:48:15 <johnw> hmm
10:49:03 <SeanJT> Hey uys
10:49:50 <johnw> SrPx: freezing will get read of those inner ST's
10:49:56 <johnw> freeze :: (Unbox a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)
10:51:33 <trap_exit> where can i read up about smart constructors and view patterns? I want to have some REct x1 x2 y1 y2, where x1 <= x2, y1 <= y2 ... by constructor ... and yet, still be ble to pattern amtch on it]
10:51:38 <trap_exit> how od I do this black magic ?
10:52:12 <athan> woo!
10:52:59 <mpickering> trap_exit: You can export a unidirectional pattern synonym ie .. pattern MyRect x1 x2 y1 y2 <- Rect x1 x2 y1 y2
10:53:08 <mpickering> and export "pattern MyRect"
10:53:10 <trap_exit> mpickering: can you point me at docs ?
10:53:20 <trap_exit> mpickering: I am having problem with the google on finding shit to read
10:53:26 <SeanJT> Lol  black magic xD
10:53:52 <johnw> SeanJT: hey
10:54:31 <mpickering> https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/syntax-extns.html 7.3.8
10:56:02 <SeanJT> Whats up
10:56:05 <SrPx> johnw: hmmmmmm
10:56:42 <trap_exit> mpickering: err, I think the relevant section is 7.3.7
10:56:46 <trap_exit> I don't get what 7.3.8 is doing yet
10:57:23 <MagneticDuck> er, how do I use resource files in a cabal project?
10:57:41 <johnw> MagneticDuck: they can be installed into the ~/.cabal/share directory
10:57:55 <trap_exit> mpickering: hmm, 7.3.8 is relevant too
10:57:56 <trap_exit> thanks!
10:57:59 <johnw>  I forget what the option setting you have to use is though
10:58:38 <MagneticDuck>  / what methods I can use to reliably get to those files?
10:59:11 <athan> guys, I got a type-safe inductive list of edges such that there are no cycles. :)
11:00:49 <johnw> MagneticDuck: I'm not sure, I haven't done it before
11:02:20 <Cahu> Hello! I'm trying to rewrite a simple game I wrote in C++ in Haskell to teach myself the language. I have a collection of shaders that I know work on the C++ version but, for some reason, none of them will compile using the latest OpenGL module for haskell, any idea ?
11:02:23 <therp> within an expression -- let's say "id True", id :: a -> a gets instanciated to Bool -> Bool. is there a way to see this instantiation, whether by provocing a type system error or otherwise?
11:02:30 <Cahu> what I  get from shaderInfoLog is the empty string
11:02:56 <johnw> therp: ghc-mod will let you ask for the type at that expression
11:03:59 <therp> johnw: tempting. is there a way without emacs? I am using hsenv, and I haven't set up the emacs integration yet.
11:04:07 <SeanJT> Hey Cahu, trying to learn both c++ and haskell here for game creation, hopefully this place will help us boh
11:04:16 <johnw> I don't know how to do it with ghci
11:04:40 <Cahu> Hi SeanJT
11:05:04 <therp> johnw: thanks, I'll give that a try then
11:05:49 <SeanJT> Hello
11:06:59 <johnw> therp: with ghc-mod, I would position my cursor on the "i" of "id True", and then press control-C control-T
11:07:19 <johnw> and then do it a second time so that it would it would expand out to include the argument
11:10:15 <Cahu> code for this problem with shaders: http://lpaste.net/4017028911324987392
11:13:13 <SrPx> johnw: where did you find that freeze? I can't find it even on hoogle
11:13:22 <johnw> Data.Vector.Unboxed
11:13:58 <johnw> I always expect it to be documented in the Mutable module, but it's not
11:14:23 <SrPx> nvm remembered
11:14:28 <SrPx> yes, why not
11:15:35 <SeanJT> Cahu also try that in #programming channel and fish for an answer there too
11:17:19 <SrPx> ah btw, nevermind before, it is actually "ST s (MVector s Int)" - which makes total sense under your explanation. "Scope s (Var s)"
11:17:20 <SrPx> :)
11:18:35 <HaudRex> Is it possible to construct a uniqueness proof in Haskell?
11:18:35 <SrPx> there is a difference between PrimMonad and PrimState thus my confusion. PrimState is the stoken type. All makes complete sense. Yay
11:18:50 <vanila> HaudRex, no
11:18:58 <SrPx> skolem
11:19:02 <HaudRex> I need dependent types, yeah?
11:19:29 <vanila> yeah
11:19:37 <HaudRex> ok, thanks :)
11:22:09 <davd> type-level ($) ?
11:24:42 * hackagebot tls 1.2.16 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.16 (VincentHanquez)
11:26:01 --- mode: holmes.freenode.net set +o ChanServ
11:28:57 <sx> What's the problem with this code? http://codepad.org/fs0QUYby
11:29:04 <davd> why does haskell make a distinction between type- and value-level syntax/semantics? could we have a unified approach?
11:29:16 <sx> davd: This!
11:30:53 <sx> davd: It would mean the compiler had to run expressions at compile time. So I guess it could run forever or at least very long, even though that is something I would neglect.
11:31:05 <SrPx> Is there any way to write this? `(do { x <- mvec; UV.freeze x })` - I expected <$> to work here, but it doesn't...
11:31:57 <davd> SrPx: mvec >>= UV.freeze ?
11:32:00 <SrPx> sx: it already can if you force the type system enough ...
11:32:02 <pavonia> sx: The n in Sing n is different from the one in the instance header, I think
11:32:15 <SrPx> davd: ah obvious, thanks!
11:32:24 <sx> pavonia: Even though I have ScopedTypeVariables enabled?
11:32:40 <davd> SrPx: remember that <$> is for lifting pure functions to some context :)
11:32:47 <SrPx> can't use applicative because of different types or am I misunderstanding what they do
11:33:10 <sx> pavonia: Maybe I need to use instance method signatures..
11:33:27 <SrPx> davd: yea that is what I thought - freeze is pure, but I had a value inside a monad... so...
11:33:33 <pavonia> sx: IIRC, scoped variables only work with explicit foralls
11:33:54 <pavonia> But I see no way to use that in an instance
11:35:54 <davd> SrPx: based on what I see over at hackage; freeze is monadic (over some PrimMonad).
11:36:15 <davd> it also makes sense in this context since a pure freeze would require some wizardry
11:36:55 <sx> pavonia: So is there any way I can refer to that n which is of kind Nat?
11:37:28 <pavonia> Perhaps there is but I don't know how, sorry
11:41:03 <pavonia> sx: Maybe if you add a helper function :: Num (FiniteField (n :: Nat)) => Sing n and use that in the defintion
11:41:06 <athan> What would be a good notion of a type-safe symbol in haskell?
11:41:30 <athan> I just need some flat symbols (to be used as keys for a type-level map)... is there a way to enforce flattness of an ADT?
11:41:36 <sx> pavonia: I try that, thank you.
11:41:50 <pavonia> Needs another argument, I guess
11:42:18 <mpickering> What do you mean my flatness athan
11:43:56 <athan> mpickering: A *-kinded ADT `Foo` where all data constructors have a type `:: Foo`
11:45:36 <mpickering> like... data Foo = A | B | C?
11:45:42 <mpickering> what am I missing
11:45:55 <athan> Yep!
11:46:23 <athan> mpickering: I saw in GHC.TypeLits something that smelled like a symbol, but idk if it's very user-level
11:46:48 <akv_> GHC.TypeLits symbol is very much usable
11:46:54 <mpickering> yes you can use type level strings from GHC.TypeLits as well
11:47:06 <davd> is the type-level an approximation of the value-value in order to achieve termination in the compiler-phase?
11:48:44 <benzrf> :k "Foo"
11:48:45 <lambdabot> GHC.TypeLits.Symbol
11:48:49 <benzrf> :k 'x'
11:48:50 <lambdabot> parse error on input ‘'’
11:48:55 <benzrf> welp
11:49:10 <Cale> davd: and to support inference
11:49:18 <benzrf> :t () :: ("Foo" ~ "Foo") => ()
11:49:19 <lambdabot> ()
11:49:24 <benzrf> :t () :: ("Foo" ~ "Bar") => ()
11:49:25 <lambdabot>     Couldn't match expected type ‘"Bar"’ with actual type ‘"Foo"’
11:49:25 <lambdabot>     In the expression: () :: "Foo" ~ "Bar" => ()
11:49:25 <lambdabot>     Couldn't match type ‘"Foo"’ with ‘"Bar"’
11:49:27 <benzrf> nice
11:52:43 <athan> oh wow holy crap, thanks guys O_O
11:53:31 <athan> oh wait... davd - I think you're right, it needs to be a finite set of symbols
11:53:44 <athan> ...maybe
12:04:29 <jophish> Is there a vim plugin to bring up documentation on a selected symbol?
12:06:26 <fread2282> why is `λ g . g 0 : (( x : F ?) → F (not x)) → Nat` where `F false = Nat` `F true = Bool` a problem? can't we reduce the type to `((x : F true) → F (not x)) → Nat` and then type error when checking the body?
12:06:47 <cbaines> Hey, ghc is telling me: Constructor `Data.Aeson.Object' should have 1 argument, but has been given none
12:06:56 <cbaines> But I don't understand/believe it...?
12:07:10 <indiagreen> cbaines: show us your code
12:08:05 <indiagreen> @where lpaste
12:08:07 <lambdabot> http://lpaste.net/
12:08:54 <fread2282> I'm confused why we would let the body of a function influence it's type when the type's fully specified
12:09:41 <cbaines> indiagreen, http://lpaste.net/3682299840542277632
12:10:14 <indiagreen> cbaines: you want to use Object as a pattern
12:10:29 <tasker> Is Data.Vector strict ?
12:10:32 <indiagreen> since Object is a constructor with 1 argument, you should write “Object _”
12:10:47 <tasker> I've noticed I can't use strictness annotations (e.g. Vector (!Int))
12:10:53 <tasker> And wondered why this is
12:11:06 <indiagreen> the same way e.g. (:) is a constructor with 2 arguments, so when you want to check that the list is non-empty, you write “(_:_)”
12:11:15 <glguy> You only use the ! for strictness when defining the fields of a new data constructor
12:11:18 <akv_> tasker: you can only use those in data definition
12:11:29 <tasker> Ah.
12:11:40 <indiagreen> and in the same fashion you can say “Just updatedv -> ...” but not “Just -> ...”
12:11:50 <tasker> Is there some way to force the Vector to be strict ?
12:16:11 <cbaines> indiagreen, That's helped. Thanks :)
12:16:55 <int-e> fread2282: are you reading a paper? if so which one?
12:18:12 <fread2282> int-e: Type checking in the presence of metavariables
12:19:42 * hackagebot simple 0.10.1 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.10.1 (AmitLevy)
12:23:38 <Pamelloes> Is there a way to get all of the processed input when using parsec?
12:29:29 <BMeph_> Pamelloes: Yes. Next question? ;þ
12:29:43 <benzrf> þorn
12:30:38 <Pamelloes> BMeph: Hm...... How would one accomplish said feat, since the possibility of its accomplishment has been self evidently established?
12:31:05 * Pamelloes ♥ circumlocutions.
12:32:19 <Pamelloes> benzrf: I prefer ashes over thorns myself, but what can you do...
12:32:30 <benzrf> :æ
12:32:39 <benzrf> Pamelloes: burn the thorns, of course
12:32:45 <benzrf> there will be ashes left over
12:33:23 <Pamelloes> Hm, what an interesting concept. That never occurred to me.
12:33:34 <BMeph> Pamelloes: I'd have to look thro' the docs, but I'm pretty sure "there's a function for that...". ;)
12:33:50 <BMeph> benzrf: Hard-core þorn? ;)
12:34:05 <int-e> fread2282: I think their point is that there is an order of applying common type checking rules which goes wrong. You seem to be pointing out that there's another order that gets it right. That's fine, but does it work in general, and if so, what's the strategy for applying the rules and why does it work?
12:34:48 <Pamelloes> BMeph: a visual double entendre. That's a new one :)
12:35:30 <BMeph> Pamelloes: Thank you very much, I'll be here all week! Try the veal! ;)
12:35:43 <Pamelloes> mmmmm
12:35:58 * Pamelloes ♥ veal.
12:36:00 <emilypi> What are some good papers for someone getting started with denotational semantics
12:36:05 <jonazzzz> which one is the efficient and applicable in most cases? or in which would one work? http://lpaste.net/3383986736605429760
12:36:19 <vanila> emilypi, well I think you would read Dana Scotts construction of D
12:36:27 <athan> What's a good proxy type for singletons?
12:36:38 <emilypi> vanila, for a beginner?
12:36:53 <cbaines> GHC says: Couldn't match type `HashMap.HashMap Text Value' with `Value'  Expected type: Maybe Value  Actual type: Maybe Data.Aeson.Object (line 7 http://lpaste.net/4186986896146038784)
12:37:00 <vanila> why do you want to learn denotation semantics?
12:37:27 <cbaines> But Data.Aeson.Object is one constructor for Value...?
12:37:42 <emilypi> to understand things better?
12:37:45 <emilypi> that's a really broad question :P
12:37:53 <sx> jonazzzz: depends on what you want, both are lazy, so I don't see any real difference, both build up thunks.
12:37:53 <indiagreen> cbaines: you can't use “HashMap.mapWithKey” on “base”
12:38:02 <platz_> I'm still not even sure what deno semantics are after some cursory investigation
12:38:24 <platz_> i've heard there are at least two different interpretations what the phrase means
12:38:28 <indiagreen> “base” is a Value, which can be or can be not an Object
12:38:32 <int-e> jonazzzz: both are liable to produce large thunks; the usualy suggestion is to use a strict left fold (foldl'). However, with lazy natural numbers, the foldr version may be preferable.
12:39:03 <emilypi> vanila, i'm a mathematician and I'm learning FP for funsies so that's my reasoning
12:39:07 <dawik> maybe give them some coffee they wont be as lazy
12:39:11 <emilypi> well, mather in training
12:39:16 <emilypi> not quite a tician yet
12:39:22 <jonazzzz> ok thanks and why you prefer foldr for naturals?
12:39:41 <vanila> well this is a hard paper but it's seminal
12:39:52 <emilypi> ooo
12:40:01 <indiagreen> cbaines: so, you should probably just change the type of diffJSONObject to “HashMap -> HashMap -> HashMap”
12:40:28 <emilypi> kk vanila thanks i'll look it up
12:40:42 <BMeph> emilypi: So, you're "tician green," since it isn't ripe enough to be red yet/ ;)
12:40:47 <int-e> fread2282: (note that the point of describing type inference and checking in terms of inference rules is that one doesn't want to worry about the strategy (what to apply when) when discussing soundness (and, ideally, completeness too) of those inference rules. from that perspective, the example is fine and convincing just as stated in the paper.)
12:40:48 <cbaines> indiagreen, Is the type of base Data.Aeson.Object though?
12:40:57 <BMeph> ?
12:41:00 <jonazzzz> http://lpaste.net/965452474263535616 is it true that the last one is the most effcient?
12:41:12 <emilypi> BMeph, i lol'd
12:42:33 <indiagreen> cbaines: the type of base is what you make it. With your current type signature, it's Obje— ouch, hang on
12:42:36 <int-e> jonazzzz: *lazy* natural numbers, data Nat = Zero | Succ Nat. If (+) is implemented nicely, the foldr version can produce Succ (Succ ...) after consuming just two elements of the given list. The foldl version *has* to consume the whole list before it can produce a result.
12:42:37 <platz> emilypi: can't comment on the ability to learn from these resources, but here fwiw  http://people.cis.ksu.edu/~schmidt/text/densem.html http://conal.net/talks/lambdajam-2014.pdf
12:42:39 <indiagreen> Object isn't even a type, hey
12:42:52 <indiagreen> sorry, got confused
12:42:55 <sx> jonazzzz: Appending to lists at the back is in O(n), therefore your reverse will be in O(n^2), whereas the other one is in O(n) because of O(1) list front append.
12:42:56 <emilypi> >lambdajam
12:43:04 <emilypi> i am so into that.
12:43:06 <emilypi> :P
12:43:09 <indiagreen> Object is a constructor, the same way “Just” isn't a type but “Maybe” is
12:43:15 <jonazzzz> ok thanks int-e and sx
12:43:34 <sx> jonazzzz: But your last question has nothing to do with foldr or foldl.
12:44:10 <indiagreen> cbaines: sorry, gtg
12:44:11 <platz> hopefully they'll do it again this year
12:44:27 <cbaines> indiagreen, np, thanks for your help :)
12:44:32 <jonazzzz> (y)
12:45:09 <SrPx> is there any 2D counterpart to unboxed mutable vectors? That is, unboxed mutable 2d matrices ?
12:48:09 <athan> Do type variables in both Data Constructors and the Type Constructor definition ever unify in a (G)ADT?
12:50:46 <HeladoDeBrownie> athan, i'm not quite sure if this is what you're asking, but for example, in: data Maybe a = Nothing | Just a -- the a is the same variable on both sides
12:51:45 <athan> HeladoDeBrownie: Something like this :) I'm trying to carry-over some instances through some complicated constraints in the GADT's data constructor context. Thank you :)
12:52:28 <HeladoDeBrownie> that wasn't a gadt, i thought you were asking for either/or. if i recall though gadts behave similarly
12:53:48 <HeladoDeBrownie> (hmm, actually i guess that does count as a gadt? but it's also an adt)
12:54:42 * hackagebot Foster 1.1.0 - Utilities to generate and solve puzzles  http://hackage.haskell.org/package/Foster-1.1.0 (Jefffrey)
13:00:34 <Pamelloes> What infix is (<-)?
13:00:49 <geekosaur> it kinda isn't, since it's syntax.
13:01:13 <geekosaur> so it lies completely outside the realm of precedence
13:03:07 <tapuu> Does anyone here know about a polymorphically kinded type-level fixed point combinator, i.e. with kind forall k. (k -> k) -> k
13:03:38 <Pamelloes> geekosaur: So, relative to "$", it will be after?
13:04:07 <tapuu> I want to calculate the fixed point of a type I have that is ((* -> *) -> (* -> *))
13:04:33 <tapuu> I can write a version of Fix that works for that kind but I wonder if theres a generic way to do it
13:04:51 <geekosaur> if you must pretend that it is a normal operator then you may be able to pretend that it has lower precedence than any operator
13:04:54 <geekosaur> "may"
13:05:09 <sabreman> Doing the following: odd . (1+)
13:05:20 <sabreman> results in nothing because you can't combine a function and the (1+) thing
13:05:22 <sabreman> right?
13:05:32 <sabreman> You'd need to replace the . with a $ to make it valid
13:06:01 <geekosaur> huh
13:06:02 <geekosaur> ?
13:06:07 <geekosaur> :t odd . (1+)
13:06:08 <lambdabot> Integral b => b -> Bool
13:06:17 <geekosaur> :t odd $ (1+)
13:06:18 <lambdabot>     No instance for (Integral (a0 -> a0)) arising from a use of ‘odd’
13:06:18 <lambdabot>     In the expression: odd
13:06:18 <lambdabot>     In the expression: odd $ (1 +)
13:06:37 <geekosaur> you may have things backwards; I cannot tell
13:06:43 <tapuu> :t odd . (1 +)
13:06:44 <lambdabot> Integral b => b -> Bool
13:07:19 <sabreman> hmm
13:07:37 <sabreman> running
13:07:43 <sabreman> odd . (1+) 1 results in an error
13:07:50 <geekosaur> because you need parentheses
13:07:55 <sabreman> running odd $ (1+) 1 results in true
13:08:19 <tapuu> > (odd . (1+)) 1
13:08:20 <lambdabot>  False
13:08:27 <sabreman> OH
13:08:34 <sabreman> lol wow,
13:08:35 <tapuu> it applies (1 +) to 1 first
13:08:40 <sabreman> I feel really stupid, thanks guys
13:08:43 <tapuu> without the parens
13:08:59 <sabreman> (hopefully one day, I'll be less of a scrub)
13:09:16 <Hafydd> Put that in the testimonials for #haskell: "I feel really stupid, thanks guys" - sabreman
13:09:42 * hackagebot Foster 1.1.1 - Utilities to generate and solve puzzles  http://hackage.haskell.org/package/Foster-1.1.1 (Jefffrey)
13:14:42 * hackagebot record 0.1.0 - First class records implemented with quasi-quotation  http://hackage.haskell.org/package/record-0.1.0 (NikitaVolkov)
13:19:26 <athan> The reflection library ties in nicely with DataKinds, correct?
13:19:42 * hackagebot aws 0.11.1 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.11.1 (AristidBreitkreuz)
13:23:52 <jonazzzz> can anybody tell me how i figure out the sequence/mapM/liftM of Maybe or List etc?
13:24:02 <jonazzzz> the implementation of them
13:24:20 <vanila> its just one implemntation which is generic
13:24:25 <vanila> in terms of >>= and return
13:24:36 <vanila> so ti takes on different meanings when you pick the monad
13:24:41 <simon> jonazzzz, only >>= and return are specific to specific monads.
13:25:28 <jonazzzz> oh right! stupid me
13:25:31 <jonazzzz> :D
13:27:30 <tapuu> are sequence and sequenceA supposed to be the same for monads that have a correct instance of applicative?
13:27:33 <fread2282> why is `λ g . g 0 : (( x : F ?) → F (not x)) → Nat` where `F false = Nat` `F true = Bool` a problem from Type checking in the presence of metavariables?
13:29:58 <karshan> hello, I was wondering how I could easily export all the prisms created by Control.Lens.TH.declarePrisms in a file
13:31:53 <Cale> karshan: Maybe just export everything from the module?
13:32:47 <Cale> karshan: Putting them into their own module which omits the export list and then re-exporting that module from somewhere else is always an option.
13:34:55 <mp> hi, if I build cross compiler for arm, then even if I specify -fasm, it will still use -fllvm, because there's no native code gen backend for arm?
13:36:34 <Pamelloes> Thoughts as to which form is more readable? etest s = ((.) $ (TestLabel s) . TestCase) . (assertEqual ""); or etest s a b = TestLabel s $ TestCase $ assertEqual "" a b;
13:36:36 <Cale> fread2282: What's that question mark?
13:37:21 <Cale> Pamelloes: I prefer  etest s a b = TestLabel s . TestCase $ assertEqual "" a b
13:37:50 <Pamelloes> Cale: That's what I'm leaning toward.
13:38:06 <Cale> (I don't like abusing the associativity of ($))
13:38:49 <Pamelloes> haha. I was screwing around with pl and found that that form was the most clear.
13:38:54 <fread2282> Cale: Cale I don't really understand the problem. shouldn't the typechecker first see that `F ? = Bool` and then type error when trying to check 0 : Bool?
13:39:15 <Cale> fread2282: My question is about syntax
13:39:24 <fread2282> Cale: metavariable
13:39:48 <Cale> fread2282: So the compiler is expected to infer the expression which goes in place of ? to make the term typecheck?
13:39:54 <karshan> Cale: lol I didn't realize that module Blah where, will cause everything to be exported
13:40:06 <fread2282> Cale: yep
13:40:49 <Cale> fread2282: So we know that F ? = Nat (supposing that we know that 0 :: Nat)
13:40:56 <Cale> fread2282: and we do what?
13:41:31 <Cale> Try all Bool arguments to F? That'll work here, but what if F :: Nat -> Type?
13:41:33 <fread2282> Cale: F ? = Bool because F (not x)
13:42:06 <fread2282> Cale: then the expression is ill-typed, at least AFAICT
13:42:07 <karshan> Cale: wait it doesn't
13:42:11 <Cale> er, I disagree?
13:42:23 <Cale> We apply g to 0
13:42:30 <Cale> g :: ( x : F ?) → F (not x)
13:42:40 <Cale> So x :: Nat
13:42:43 <Cale> So F ? = Nat
13:42:47 <benmachine> Cale: right, but you can see that the first argument has 'not' applied to it later on
13:42:57 <Cale> oh, okay
13:43:05 <fread2282> Cale: but we apply not to x, so x : Bool
13:43:28 <Cale> Okay, then this isn't a problem?
13:44:29 <fread2282> Cale: http://www.cse.chalmers.se/~ulfn/papers/meta-variables.pdf and http://mazzo.li/dump/talk-aimxx.pdf say it is, and I'm trying to figure out what they mean
13:45:50 <Cale> fread2282: Oh, it's pointing out the fact that you end up with ill-typed terms in your constraints
13:46:25 <Cale> fread2282: So the type checker can't even rely on the fact that the equalities of types that it's generated are themselves equalities of well-typed expressions
13:47:05 <Cale> You get F (not 0) = Nat
13:48:07 <fread2282> Cale: specifically, in the slide "Why can't we just pretend things are fine?". why not? don't we still have to check the type vs the body?
13:48:47 <sabreman> MAn, haskell is so cool
13:48:55 <sabreman> everything new i impliment blows my mind
13:49:07 <sabreman> "Hmm, can I do that? Holy fuck i can!"
13:49:26 <Cale> fread2282: In the paper shortly after: "With dependent types, verifying convertibility between two terms relies on normalising these terms, which is only safe if these terms are well typed."
13:49:26 <sabreman> I just made an insertion sort that looks soooooo simple
13:49:32 <IRWolfie-> sabreman: yeah, I just managed to learn enough haskell to implement something that took me several weeks in C
13:49:37 <IRWolfie-> :>
13:49:38 <carter> sm: so you're thinking etrepum forgot to include profiling in ghc for os x?
13:50:04 <Cale> fread2282: So if you end up with ill-typed terms in your constraints, you may attempt to normalise an ill-typed term in the typechecker.
13:50:25 <fread2282> Cale: so if we check at every point we're fine?
13:51:51 <Cale> fread2282: I dunno, I haven't read the rest of the paper
13:52:04 <Cale> fread2282: Presumably they come up with some sort of solution
13:52:50 <fread2282> well I think I got it, thanks Cale
13:54:55 <Cale> fread2282: Part of the problem is that it might be hard to tell that a term is ill-typed without doing some normalisation.
13:55:36 <osa1> anyone had this problem with ghc-mod: "dist/setup-config: hGetContents: invalid argument (invalid byte sequence)" ? this is happening when I run ghc-mod. (or `runGhcModT defaultOptions (...)` in GHCi)
13:57:53 <SrPx> If I am inside the directory Foo/Bar, how do I import something from Foo/Bar/Boo ? import Boo.Something ? Sounds a little wrong :/
13:58:38 <osa1> SrPx: import Foo.Bar.Boo
13:58:50 <SrPx> it doesn't work :(
13:58:59 <osa1> how is it failing?
13:59:03 <bergmark> with ghci -i../../
13:59:05 <bergmark> ghci*
13:59:06 <bergmark> ghc*
13:59:20 <Cale> osa1: There's some discussion of that error here: https://github.com/ghcjs/ghcjs/issues/271
13:59:33 <geekosaur> if you are in Foo/Bar then import Boo (Something)
14:00:14 <osa1> oh right, I updated Cabal recently
14:00:17 <osa1> Cale: thanks
14:01:56 <osa1> oh wait, is it even possible to compile ghc-mod with my Cabal version
14:04:38 <etrepum> carter: I used the official binary GHC build, so any build settings it uses are from that.
14:04:47 * hackagebot aws 0.11.2 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.11.2 (AristidBreitkreuz)
14:09:13 <IRWolfie-> what's the standard/most common way to solve eigenproblems in haskell?
14:09:47 * hackagebot atlassian-connect-descriptor 0.3.0.1 - Code that helps you create a valid Atlassian Connect Descriptor.  http://hackage.haskell.org/package/atlassian-connect-descriptor-0.3.0.1 (RobertMassaioli)
14:10:21 <peddie> IRWolfie-: check out hmatrix
14:10:29 <peddie> @hackage hmatrix
14:10:29 <lambdabot> http://hackage.haskell.org/package/hmatrix
14:11:09 <IRWolfie-> cool cheers
14:11:47 <osa1> does ghc package depend on Cabal?
14:12:10 <osa1> I think there's no way to fix my problem with ghc-mod without updateing the GHC if that's the case
14:12:30 <Darwin226> Hey guys. If my function takes a monadic action as a parameter but only cares about it's effects, should the functions accept 'm ()' or 'm a'?
14:12:39 <Darwin226> What makes more sense?
14:14:41 <benzrf> Darwin226: m a
14:14:42 <osa1> yup, it looks like GHC uses Cabal
14:14:53 <benzrf> Darwin226: so you can use it with actions of any type
14:15:14 <osa1> any ideas which version of Cabal is 7.8.4 pre-built binaries linked with?
14:15:16 <benzrf> Darwin226: otherwise you'd have to explicitly set their outputs first
14:15:21 <Darwin226> benzrf: I mean, the question boils down to: should the user do the void, or should i
14:15:31 <benzrf> Darwin226: do either of you have to
14:15:46 <benzrf> why not just do ur thing w/o any voiding
14:16:35 <Darwin226> benzrf: You're right
14:16:42 <benzrf> as usual B)
14:17:04 <hexagoxel> osa1: `ghc-pkg list --global Cabal`
14:17:22 <osa1> hexagoxel: that doesn't show which version of Cabal GHC is linked with
14:18:11 <osa1> libHSCabal-1.18.1.5-ghc7.8.4.so
14:18:43 <osa1> so I think even GHC 7.8.4 doesn't cut it if I want to compile ghc-mod with Cabal 1.22
14:27:09 <ezrios> how does one get a stack trace when an exception is thrown in Haskell?
14:27:19 <ezrios> The wiki suggests loch but it does not even seem to build
14:28:09 <Axman6> generally, you don't, stack traces in Haskell are quite different to in other languages; the only stsck is a stack of evaluations, not a stack of calls
14:28:43 <benzrf> ezrios: don't throw exceptions
14:28:44 <ezrios> okay, how does one obtain this stack of evaluations
14:28:51 <benzrf> ezrios: if your code is throwing exceptions your code is bad and wrong
14:28:55 <ezrios> benzrf: I'm getting (!!) out of range
14:28:59 <benzrf> ezrios: don't use (!!)
14:29:06 <ezrios> use what instead then?
14:29:11 <benzrf> if you're using (!!) you're almost certianly doing something wrong
14:29:13 <Axman6> preferably don't use (!!) or other unsafe functions from the prelude
14:29:26 <ClaudiusMaximus> @hackage safe
14:29:27 <lambdabot> http://hackage.haskell.org/package/safe
14:29:28 <Axman6> (like head, tail, etc)
14:29:35 <kranius> how does one learn that such functions, mentionned in many tutorials are not safe
14:29:38 <ezrios> ClaudiusMaximus: thanks
14:29:47 <ezrios> gah this bug is going to take a lot of digging ._.
14:29:48 <benzrf> kranius: talking to people who know haskell :b
14:29:55 <kranius> the hard way ;D
14:29:59 <benzrf> ezrios: this is your own fault for using (!!) >:{
14:30:09 <benzrf> ezrios: random access is unidiomatic!
14:30:10 <ezrios> what tools can I use to at least diagnose the issue
14:31:01 <kranius> I wish I had people around me who knew haskell
14:31:02 <ezrios> or maybe I should just change my datatypes since the size of my list is static anyway ._.
14:31:07 <hexagoxel> benzrf: great work at helping out the beginners
14:31:15 <benzrf> hexagoxel: s-sorry
14:31:28 <hexagoxel> ezrios: how many time do you use (!!) in your code?
14:31:38 <ezrios> hexagoxel: two functions
14:31:44 <ezrios> one of them is blowing up
14:32:01 <ezrios> honestly I will probably just have to muck around with my datatypes, I'm working on a chess AI
14:32:11 <ezrios> so really it's already known the board is 8x8
14:32:14 <kranius> I mean, (!!) is the only way I've been introduced to until now
14:33:43 <ezrios> basically I represent a chess board as a [[Square]]
14:33:48 <hexagoxel> ezrios: the classic "debugging" tools are trace and hood.
14:33:57 <platz> is there anything that describes the basic tradeoffs (the most obvious props which you consider when selecting one or the other) between initial and final encodings?
14:34:00 <HaudRex> What exactly is the relationship between "free" and "initial" (and cofree and terminal)?
14:34:05 <ezrios> and I have a function squareAt that takes a Coordinate data type (i.e. Coordinate 'e' 5) and gives you the square at that location
14:34:14 <ezrios> I am using (!!) to navigate the list
14:34:32 <ReinH> ezrios: well stop doing that then
14:34:38 <ezrios> ReinH: yes
14:34:52 <ezrios> what is the proper way of doing this
14:35:08 <ezrios> records?
14:35:09 <platz> initial seems it can be "free to interpret" in any way
14:35:11 <ReinH> You could use an array.
14:35:13 <ezrios> one record entry per file?
14:35:48 <ezrios> ReinH: the issue is I am getting (!!) out of bounds
14:35:54 <ReinH> You could use vectors and represent your board as a bitboard
14:35:55 <ezrios> does using an array somehow correct this issue? I am not seeing how
14:35:59 <platz> final seems to be more "extensible"?
14:36:01 <ReinH> ezrios: arrays have bounds
14:36:03 <ezrios> ReinH: I could but I have no interest in doing so atm.
14:36:26 <joness> is there a function in prelude that can print integers in octal, hexadecimal and binary base?
14:36:33 <ezrios> ReinH: so what happens if I have an array with 10 entries and try to access the 42'nd
14:36:37 <ezrios> does this die at compile time?
14:36:43 <joness> or in any module that ships with haskell platform
14:36:44 <indiagreen> joness: not in Prelude, but I think it's in Numeric
14:36:50 <tromp> :t showIntAtBase
14:36:51 <lambdabot> (Show a, Integral a) => a -> (Int -> Char) -> a -> ShowS
14:37:11 <hexagoxel> ezrios: a first step could be to `import Debug.Trace` and then wrap the second parameter of the (!!) in `traceShowId`
14:37:18 <indiagreen> > showHex 255 ""
14:37:20 <lambdabot>  "ff"
14:37:29 <ClaudiusMaximus> > showIntAtBase 3 ("012"!!) 55 ""
14:37:31 <lambdabot>  "2001"
14:37:35 <ReinH> ezrios: No, but you can check bounds before you access.
14:37:49 <ReinH> ezrios: Although given you know the size of your board, I don't see why you aren't doing that yourself already.
14:38:15 <indiagreen> joness: so, there's showHex, showInt, and showOct, but you can also use showIntAtBase for maximum generality
14:38:17 <joness> > showIntAtBase 2 ("01"!!) 3
14:38:19 <lambdabot>  <[Char] -> [Char]>
14:38:24 <ezrios> I guess the main issue is that some invariants are not being maintained
14:38:28 <joness> > showIntAtBase 2 ("01"!!) 3 ""
14:38:29 <lambdabot>  "11"
14:38:34 <ezrios> presumably my move generation functions are returning moves that are out of bounds when they should not be
14:38:38 <joness> indiagreen yeah i see
14:38:41 <ReinH> Sounds like it.
14:38:59 <ezrios> hexagoxel: The issue is that the function that uses (!!) has several clients
14:39:01 <joness> weird that they did not define showBin though
14:39:06 <ezrios> and I am not sure which one is feeding the function bad data
14:39:21 <ezrios> so I wanted to get some sort of call/eval stack so I could narrow down the faulty code
14:39:31 <ReinH> ezrios: It would be cheap and easy to wrap that function in one that does some basic arithmetic to check bounds.
14:39:38 <indiagreen> joness: agreed, you could make a library proposal
14:40:18 <ReinH> Although tbqh, you might just represent the board as a Map. Boards are sparse. You aren't making any use of the array- or matrix-like structure of a grid of squares.
14:40:25 <hexagoxel> benzrf: btw i can understand your attitude, but we must not discourage the beginners when so many tutorials are lacking still :)
14:40:31 <ReinH> You still can't get around needing bounds checks
14:40:59 <ezrios> ReinH: so what's the proper response when an index is out of bounds? Should I just wrap the result of the call in a Maybe?
14:41:04 <ReinH> So this isn't so much a data structure problem as a bug in your code...
14:41:31 <joness> is this expected? I must be misunderstanding the last argument
14:41:31 <ezrios> yes, it's a bug
14:41:36 <ezrios> I hvae no idea how to diagnose it though
14:41:38 <joness> > showHex 10 "0x"
14:41:39 <lambdabot>  "a0x"
14:41:57 <ezrios> I can't get a call or evaluation stack
14:41:59 <indiagreen> joness: the last argument is a string to prepend the result to
14:42:05 <ezrios> so I don't know where the bad arguments are coming from
14:42:06 <geekosaur> it is expected, yes. you'll want to look at ShowS, and difference lists in general
14:42:09 <Axman6> appended*
14:42:10 <hexagoxel> ezrios: how large is the code? can you post it?
14:42:11 <indiagreen> ShowS is a kind of “String builder”
14:42:32 <indiagreen> it's done for performance
14:42:34 <ReinH> ezrios: Then you don't understand how your code is functioning, so you might want to break it apart and try to understand each piece
14:42:39 <ezrios> hexagoxel: it's some 2600 lines
14:42:46 <hexagoxel> uuhhh
14:42:54 <ezrios> well
14:42:57 <ezrios> wait that includes some garbage
14:42:59 <ReinH> How did you write 2600 lines of a chess engine without solving an out of bounds error?
14:43:03 <ReinH> o_O
14:43:09 <ezrios> no, I screwed up the line count
14:43:14 <ReinH> Seems like that's one of the first things you'd want to get right.
14:43:23 <ezrios> 636 lines.
14:44:01 <ReinH> You might want to use Debug.Trace to insert some debug information into the things that are making use of the access function.
14:45:00 <ezrios> ReinH: didn't think of that actually... was putting traces in the access function itself
14:45:04 <ezrios> probably a good first move
14:46:28 <joness> wat
14:49:26 <trap_exit> seahawks game so painful; teach me some thing new about haskell to cheer me up
14:51:22 <fread2282> is there a more general fold for my type that will give me Traversable, Monad, etc with little code (like 1 line)?
14:53:02 <Welkin> fread2282: foldMap
14:53:10 <Welkin> implement a Foldable instance
14:53:40 <fread2282> Welkin: then?
14:55:35 <Welkin> then what?
14:55:44 <Welkin> you have a fold for your type
14:55:54 <ezrios> aha
14:55:56 <ezrios> think I found it
14:56:16 <fread2282> Welkin: well how to I get (>>=) and traverse?
14:56:56 <EvanR> >>= comes from the Monad class and traverse comes from the Traversable class
14:58:00 <fread2282> yeah well I want one function that I can then define (>>=) and traverse in terms of
14:58:48 <EvanR> sequenceA maybe
15:00:37 <ReinH> fread2282: Traversable gives you Foldable and Functor. Nothing gives you both Traversable and Monad.
15:00:46 <benzrf> ReinH: i beg to differ
15:00:56 <benzrf> 1 sec
15:00:57 <benzrf> :t traverse
15:00:58 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:01:01 <ReinH> benzrf: of course you do
15:01:01 <benzrf> :t (>>=)
15:01:01 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:01:25 <benzrf> (forall a b. (a -> f b) -> t a -> f (t b), forall a b. f a -> (a -> f b) -> f b)
15:01:29 <benzrf> ( ͡° ͜ʖ ͡°)
15:01:40 <ReinH> eh?
15:01:51 <benzrf> ReinH: that'd be a class method giving both
15:02:01 <ReinH> Does that exist?
15:02:07 <benzrf> ah you meant something in base
15:02:10 <benzrf> n-never mind
15:02:12 <ReinH> I mean something that exists.
15:02:40 <Welkin> a "class method"?
15:02:56 <Welkin> benzrf: have you been writing java?
15:03:33 <EvanR> haha
15:04:10 <vanila> "compiler tech is our best system for modelling algebraic structures and transformations between algebras." what does this mean?
15:04:22 <dmilith> OOP thinking on Haskell channel. Brave!
15:04:28 <ReinH> vanila: Dunno, sounds debatable at best.
15:04:30 <Cale> classes have methods in Haskell
15:04:46 <vanila> yeah i cant figure out what its supposed to even mean just sounds like buzzwords :S
15:04:59 <ReinH> vanila: A bit word salady, yeah
15:05:07 <Cale> At least, that's what the standard uses to refer to the terms declared in a class declaration.
15:05:15 <Welkin> Cale: they are type classes that define functions
15:05:17 <haasn> Calling class members “methods” is even worse abuse of existing terminology than “return”
15:05:24 <EvanR> on one hand its cool to usurp existing terminology used in oop to confuse them, but then newcomers try to apply what they know to haskell and get messed up
15:05:40 <ReinH> Cale: No doubt designed to confuse things even further for programmers from OO langauges ;)
15:05:47 <benzrf> haasn: it's standard
15:05:57 <Cale> I dunno, it seems not entirely inappropriate
15:06:10 <EvanR> seems like the same mechanism as oop
15:06:22 <haasn> My only gripe with the term “method” is that it implies they can only be functions
15:06:50 <haasn> Although “mempty :: String” is a perfectly fine class method. I would have preferred “member” personally, I think
15:07:16 <EvanR> haasn: didnt you know, everything is a function
15:07:30 <Cale> But "member" seems like it would refer to the types which belong to the class.
15:07:44 <Cale> Like, a member of a set is another word for an element of it
15:08:53 <Cale> There's no chance of having that particular confusion with the word "method"
15:10:24 <SrPx> osa1, geekosaur I'm on Haskell/Data/matrix.hs. There is Haskell/Data/Matrix/mutable.hs. I am trying to import it with "import Matrix.Mutable" but I get `File name does not match module name: Saw: ‘Data.Matrix.Mutable’,Expected: ‘Matrix.Mutable’`
15:10:33 <SrPx> Which is quite obvious, but then what do I do?
15:11:07 <SrPx> If I remove the "Data.~" it will not work when I import from above... is there a way to point that "Haskell" is the root directory?
15:11:13 <geekosaur> use -i.. so your imports are relative to the directory your module name expects
15:11:33 <bmuk> Hey everyone; I'm having some trouble with emacs integration. When I try to compile from inside emacs, it tells me cabal isn't found - but cabal is on my PATH and I even manually added the path to emacs. Still no luck.
15:11:34 <geekosaur> then you can import it by the name it advertises, Data.Matrix.Mutable
15:12:11 <SrPx> geekosaur: on ghc, as a compile flag? What would not work on my VIM (I mapped a key to "ghc file") ... is this the only way?
15:12:16 <SrPx> That*
15:12:27 <fread2282> SrPx: cabal repl/build?
15:12:42 <SrPx> vish
15:12:50 <geekosaur> that or using a cabal sandbox configuration. unless you have a plan to teach ghc mind-reading
15:13:44 <SrPx> hmm...
15:14:48 * hackagebot floating-bits 0.1.0.0 - Conversions between floating and integral values.  http://hackage.haskell.org/package/floating-bits-0.1.0.0 (JonasScholl)
15:16:22 <__hao> @bmuk oh, that’s weird. are you using haskell-mode? are you using anything besides haskell-mode?
15:16:22 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
15:16:38 <SrPx> `-i ~/Haskell` doesn't work, should it?
15:16:43 <bmuk> __hao: I'm using spacemacs, so evil, et.al.
15:17:10 <__hao> uh, hrm, never heard of it
15:17:12 <geekosaur> no, it shouldn't. -i$HOME/Haskell would (note lack of space)
15:17:26 <horny-sama> I have a question about the expression doubleSmallNumber' x= (if x > 100 then x else x*2) +1 when will the expression will be +1
15:17:26 <__hao> does spacemacs come with haskell-mode? is it a vanilla spacemacs install?
15:17:33 <geekosaur> ...ands no, ~ will not work with that form because ~ is a shell construct, not an OS construct, and is only expanded at the beginning of a shell word
15:17:34 <SrPx> ah my bad, thank you geekosaur ...
15:18:02 <bmuk> __hao: It's like prelude but it makes evil integrate with everything
15:18:31 <__hao> bmuk: makes sense. what does your modeline say when you open a haskell file?
15:19:01 <geekosaur> horny-sama, I'm trying to understand your question, or maybe how you are reading it
15:19:07 <__hao> mine’s, for example, “Haskell Ind FlyC:6/0 company” because i’m using haskell-mode and three other minor modes on top
15:19:18 <geekosaur> it adds 1 to the result of the expression (if x > 100 then x else x*2)
15:19:27 <geekosaur> the + 1 is outside of the conditional
15:19:44 <horny-sama> geekosaur: if x > 100 then x+1 else x*2+1?
15:19:55 <geekosaur> yes
15:20:22 <horny-sama> geekosaur: ooo
15:20:24 <horny-sama> got it
15:56:51 <SrPx> Just dropping this here: Is there any way to extend Data.Vector to accept 2D indices, without having to almost rewrite the whole library? ( http://stackoverflow.com/questions/28016209/is-there-any-way-to-extend-data-vector-to-accept-2d-indices-without-having-to-a ) Any input appreciated :)
15:57:48 <athan> I wish type families made lambdas :(
16:00:40 <dcoutts_> SrPx: you can use repa or the ordinary array library
16:00:47 <fread2282> SrPx: Vector (Vector a)?
16:01:31 <Pamelloes> Not in scope data constructor IO....
16:01:32 <SrPx> dcoutts_: noo it won't work :( I was using REPA. Had to drop it because it doesn't have an operation to set single pixels (which I need)
16:01:44 <Pamelloes> What'd I screw up?
16:02:05 <SrPx> Pamelloes: code?
16:02:33 <geekosaur> you used a type constructor where you needed a data constructor (also, that will never work...)
16:02:34 <dcoutts_> SrPx: well, it does but it's not an efficient thing to do because it's only immutable arrays.
16:02:48 <Pamelloes> SrPx: case (...) of; Left _ -> IO (); Right a -> assertFailure ...
16:02:56 <dcoutts_> SrPx: if you need convenient 2d mutable arrays then there's always the ordinary array library
16:03:17 <geekosaur> return ()
16:03:19 <geekosaur> probably
16:03:33 <Pamelloes> geekosaur: mmm, probably it.
16:04:55 <Pamelloes> Yep, that fixed it
16:06:26 <fread2282> SrPx: Vector (Vector a) is super simple and works without bounds and also vector is newer and does more performance optimizations than array
16:10:13 <SrPx> fread2282: I'm semi content with that answer (and dcoutts_ !), both will work. but now I need to know how to do that kind of extension for the sake of mind peace (what if I needed a more complex transformation?)
16:10:29 <SrPx> say, an array with polar coordinates access
16:10:58 <SrPx> fread2282: also, for curiosity sake, is Vector (Vector a) totally unboxed?
16:11:12 <SrPx> that sounds witchcrafty
16:11:22 <SrPx> like, linear on memory
16:11:28 <lifter> Does it make any sense to have a lazy IntMap whose values are a record data type, whose definition contains strictness bangs in all its fields/records?
16:14:17 <dcoutts_> SrPx: are you using Data.Vector or Data.Vector.Unboxed?
16:14:28 <dcoutts_> lifter: maybe, depends what you're trying to do
16:14:35 <SrPx> unboxed
16:14:59 <pingu> SrPx: I don't htink that'd work then?
16:15:01 <dcoutts_> SrPx: the Unbox instance will explain how it's laid out in memory
16:15:05 <pingu> As in, it wouldn't typecheck
16:15:15 <pingu> because I can't find an instance... might be missing it
16:15:24 <dcoutts_> right, or there'll be no instance, and it will not type check
16:15:28 <lifter> dcoutts_: Well, I'm writing a multi-player text adventure game (MUD), and all of the objects in the game world are elements of IntMaps.
16:15:40 <fread2282> SrPx: looks like it's not :(
16:15:41 <SrPx> dcoutts_: uh huh, that's neat
16:15:50 <SrPx> fread2282: uh?
16:16:17 <lifter> dcoutts_: Presently the IntMaps in question are lazy, with bang patterns in all their fields.
16:16:25 <fread2282> SrPx: not fully unboxed (the outer one would have to be non-unboxed)
16:17:16 * fread2282 thinks there should be a Unbox a => Unbox (Unboxed.Array a) instance
16:18:17 * SrPx is confused
16:18:49 <pingu> fread2282: problem is that it's not exactly trivial to resize
16:19:04 <pingu> if you want to keep it in one contiguous allocation.
16:19:18 <SrPx> what do you mean? "Vector (Vector Int)" typechecks for unboxed
16:19:22 <SrPx> it'sn ot what
16:19:35 <pingu> SrPx: so look at the instance
16:19:38 <pingu> and we can see what it does
16:20:23 <fread2282> SrPx: you need the outer one to be boxed to be able to do anything on it
16:20:51 <pingu> SrPx: right, you certainly can write it as a type. that doesn't mean you can inhabit the type
16:21:00 <SrPx> ah... okay :( makes sense
16:21:04 <SrPx> so, array
16:21:05 <pingu> I can't find the magic instance you're looking for.
16:22:11 <SrPx> anyway
16:22:45 <SrPx> this particular example could be solved if we had a generic typeclass "vector" instead of a solid type, and a way to inherit that typeclass overwriting some functions (read/write)
16:22:54 <fread2282> pingu: obviously it would only be for immutable vectors
16:23:32 <SrPx> or if instead of typeclasses we used a dictionary that mapped function names (read, write) to the proper operations... this way we'd just make a new dictionary with the proper functions
16:23:33 <pingu> fread2282: sure, that'd be easy
16:23:39 <SrPx> dunno
16:23:44 <SrPx> that's what I can think of at least
16:23:51 <pingu> but I think a boxed "thing" needs to be fixed length?
16:24:12 <pingu> I think you would confuse things if you tried to write that peek/poke instance.
16:24:18 <pingu> Maybe. Not sure.
16:26:16 <dcoutts_> lifter: so if you have an intmap of records all with strict fields, it's of course sill possible to put in unevaluated records
16:26:36 <dcoutts_> lifter: whether that's a good thing or not depends on the details of your application
16:26:56 <lifter> dcoutts_: I see
16:27:13 <phaazon> hm
16:27:24 <phaazon> is there a way to enable profiling in a .cabal?
16:27:34 <phaazon> or do I have to enable it on the command line interface?
16:28:04 <lifter> phaazon: Maybe in the "ghc-options" field?
16:28:07 <dcoutts_> phaazon: cabal can compile libs in profiling mode
16:28:19 <dcoutts_> if you mean for profiling an app, then you need all the libs in prof mode
16:28:32 <pingu> phaazon: you can, but you shouldn't.
16:28:35 <dcoutts_> and then you need to configure with --enable-executable-profiling
16:28:42 <pingu> you should be using --enable-executable and --enable-library... things
16:29:04 <dcoutts_> phaazon: but you'll also want to use some choice of cost centres
16:29:24 <dcoutts_> and for that you can use --ghc-options on the command line
16:29:29 <pingu> or:
16:29:30 <pingu>     ghc-prof-options:  -fprof-auto
16:29:38 <pingu> in your .cabal
16:31:52 <phaazon> hm
16:31:53 <phaazon> ok
16:31:56 <phaazon> so I can delete the sandbox
16:32:11 <phaazon> and recompile it with --enable-library-profiling --enable-executable-profiling, right?
16:38:23 <phaazon> god I love the multithreaded building of dependencies <3
16:42:55 <EponymicCycloid> How do I avoid constantly writing "try x <|> try y <|> z" when using parsec?
16:43:17 <EponymicCycloid> It seems like the alternative operator should not cause the whole expression to fail if the first alternative does
16:43:37 <glguy> You should write your parser so that it only matches that first token if it's the right parser
16:43:57 <alpounet> http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/ covers this topic a bit
16:44:09 <kadoban> EponymicCycloid: You only have to do that if x or y can consume some input and then fail, you know that right?
16:44:20 <EponymicCycloid> You're saying that I should keep track of the first set of every expression in my language? That's absurd, that's what grammar tools are for
16:44:54 <EponymicCycloid> That's a lot of rote mechanical work
16:45:02 <EponymicCycloid> Things like Yacc or Happy take care of that for you
16:45:39 <EponymicCycloid> Does parsec actually do any transformation to fast parser algorithms for CF grammars?
16:48:15 <Buttons840> I want something like f "3, 5" == ["3", "5"] -- how can I do this with a regex?
16:48:52 <EponymicCycloid> Buttons840: Regex is probably the wrong tool for this
16:49:43 <Buttons840> EponymicCycloid: overkill or underengineered?
16:50:07 <kadoban> Buttons840: Maybe look at Data.List.Split.splitOn or something similar. It's in the split package on hackage IIRC.
16:50:35 <EponymicCycloid> Buttons840: Just the wrong area. You're not matching a pattern, you're re-formatting some data. At the very least, you need a mealy machine.
16:50:40 <Buttons840> stepping back, my goal is to build an (Int, Int) from stdin
16:51:15 <EponymicCycloid> You should just write a function :: String -> [Int]
16:52:06 <EponymicCycloid> f [] = []; f list@(x:xs) = if numeral x then (make an integer) : (the rest of the string) else f xs
16:52:06 <Buttons840> [Int] is not the same as (Int, Int) -- I need a (Int, Int) from user input
16:52:33 <EponymicCycloid> OK, then split at the comma and try to read the things on either side as integers
16:52:50 <kadoban> @let readTuple = read :: (String -> (Int, Int))
16:52:51 <lambdabot>  Defined.
16:52:57 <kadoban> > readTuple "(1, 5)"
16:52:58 <lambdabot>  (1,5)
16:53:30 <kadoban> Buttons840: ^ that's an option, but not a particularly...sturdy one. It works for simple usages though.
16:53:32 <Buttons840> I would rather not type the tuples
16:54:00 <EponymicCycloid> If you don't want to type the tuples, how do you expect to know what you're reading?
16:54:11 <kadoban> Buttons840: ? You have a String and need a tuple, correct? If you're taking it from user input, there's ways to do that part.
16:54:23 <Buttons840> i mean the parens -- I knew I could read "(1, 5)" :: (Int, Int)
16:54:45 <EponymicCycloid> You can do "(" ++ input ++ ")" and read that
16:54:49 <glguy> > (\x0 -> do (n0,x1) <- reads x0; (",",x2) <- lex x1; (n1,x3) <- reads x2; ("","") <- lex x3; return (n0::Int,n1::Int)) "3,  5  "
16:54:53 <lambdabot>  [(3,5)]
16:54:55 <Buttons840> EponymicCycloid: touche ;)
16:56:00 <EponymicCycloid> > read . (\x -> "(" ++ x ++ ")") $ "5, 6" :: (Int, Int)
16:56:01 <lambdabot>  (5,6)
16:56:40 <Buttons840> EponymicCycloid: seems hacky, but it works
16:57:23 <EponymicCycloid> Buttons840: The "correct" approach would be to write a parser from the ground up. This is simple enough that you don't need the help of a library
16:57:27 <kadoban> Buttons840: There's other options if you want better error handling/reporting and/or better performance, but..."read" is usually okay for a first step.
16:57:44 <glguy> The code I wrote is how you'd use the Read class functions to write that parser
17:00:15 <Buttons840> I see a few cases: 1) i need simple input that happens to match haskell syntax 2) i need simple input that doesn't match haskell syntax 3) I need complex input   -- it seemed regex fit somewhere in the middle (case 2)
17:01:58 <EponymicCycloid> I mean, regex can let you pull out parts of strings, but it's really not the best tool for that
17:02:00 <kadoban> Buttons840: There's not that many problems that have regex as the best solution, IMO.
17:03:00 <Axman6> usually, particularly in Haskell, if you think "Hmm, a regex would be great for this", a parser will be even better and you'll be able to understand it a week later
17:03:20 <petantik> that's the joke.
17:03:23 <Axman6> they're simpler and clearer
17:05:00 <Buttons840> maybe proper parsers aren't as difficult as I would expect?  i picture them being complicated and overkill for reading two numbers, Epony's suggestion falls appar over simple things like having the numbers seperate by ; instead of ,
17:05:27 <geekosaur> proper parsers are often complicated and difficult in other languages, in Haskell they're pretty much *natural*
17:05:36 <phaazon> dammit
17:05:45 <phaazon> I can’t build my program with profiling on Windows :(
17:05:51 <phaazon> is that a known issue?
17:05:53 <kadoban> Buttons840: Parsec type parsers are pretty simple to write once you get used to them, and they read nice.
17:06:07 <phaazon> c:/program files/haskell platform/2014.2.0.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.6.3/../../../../x86_64-w64-mingw3
17:06:07 <phaazon> collect2: ld returned 1 exit status
17:06:33 <BMeph> phaazon: Yes, it is, but people keep using Windows regardless. ;)
17:06:47 <phaazon> we can’t use profiling on windows?
17:06:51 <Buttons840> this is probably our disconnect then, parsers aren't as complicated as I thought -- in other languages I'd use regexes as a simple parser, but sounds like that wont be necissary in haskell
17:06:53 <kadoban> phaazon: No specific knowledge about that, but maybe search for a log with more info or a switch to give more debug output.
17:07:08 <geekosaur> (I think the only non-functional languages where parsers are pretty natural are snobol and icon... in both of which they're embedded in the language itself.)
17:07:11 <Buttons840> thanks for the help all
17:07:32 <geekosaur> (also, "natural" in scare quotes for snobol, which is punch-card fortran trying to become perl)
17:07:41 <phaazon> omg.
17:07:48 <phaazon> the verbose log is…
17:07:50 <phaazon> pretty long :D
17:07:57 <phaazon> and the call to the linker is ridiculous :D
17:08:37 <kadoban> phaazon: Haha, they usually are. Is there at least a more informative error?
17:08:43 <phaazon> not really…
17:09:04 <kadoban> Anything more than "it failed" would really be more informative it seems...
17:09:33 <phaazon> kadoban, http://lpaste.net/8711939490299510784
17:09:36 <phaazon> that… thing…
17:09:37 <phaazon> :D
17:10:11 <phaazon> c:/program files/haskell platform/2014.2.0.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.6.3/../../../../x86_64-w64-mingw32/bin/ld.exe: cannot find -lHSrts_debug_p
17:10:12 <kadoban> phaazon: "ld.exe: cannot find -lHSrts_debug_p" is /much/ more informative. At least that's googleable
17:10:24 <phaazon> I think I know
17:10:33 <phaazon> I might miss the profiling version of base
17:11:55 <alpounet> of the rts, yeah
17:11:55 <sadgit> Hey. Any Japanese speakers want to do me a quick favour?
17:12:38 <phaazon> alpounet, any idea how to install that on windows?
17:12:50 <phaazon> cabal install base --enable-library-profiling --reinstall?
17:12:53 <alpounet> nah
17:12:54 <phaazon> sounds bazooka
17:13:02 <alpounet> it's not about base here
17:13:04 <alpounet> it's about GHC itself
17:13:12 <geekosaur> base can't be buult, it's hardwired into ghc
17:13:22 <phaazon> hm
17:13:23 <alpounet> the runtime system, to be precise
17:13:38 <phaazon> so I guess I need to find the prof version of ghc
17:16:54 <phaazon> and I have no idea where :(
17:17:05 <phaazon> alpounet, do you know who may know that?
17:17:32 <alpounet> i have no clue
17:17:45 <alpounet> phaazon: try sending an email to haskell-cafe?
17:17:49 <alpounet> someone there will know i think
17:18:23 <phaazon> haskell-cafe?
17:18:27 <phaazon> what is that?
17:18:59 <u-ou> an internet cafe whose computers have ghc installed
17:19:55 <hexagoxel_> phaazon: https://www.haskell.org/haskellwiki/Mailing_lists
17:20:04 <uxizde> :Q
17:20:35 <hexagoxel_> (and yes, haskell.org has loadtimes up to 30s atm)
17:24:44 <BobtheBuilding> that is one really slow site
17:26:34 <phaazon> thanks
17:39:48 * hackagebot Foster 1.1.2 - Utilities to generate and solve puzzles  http://hackage.haskell.org/package/Foster-1.1.2 (Jefffrey)
17:46:15 <Rotaerk2> so far I've only used GLUT to initialize the context... the GLUT package is dependent on the OpenGLRaw package, but I'm electing to try the "gl" package... what should I use for creating the window and GL context with that?
17:47:48 <Pamelloes> How do you specify a function's type when defining it in a let statement?
17:47:59 <dedgrant_> Anyone know how I must install alex and happy in order to satisfy building of gtk2hs-buildtools in a sandbox? (my workaround is to rebuild these in the sandbox as well.) :/ Seems to be unaware of the dist artifacts outside of the sandbox
17:48:51 <geekosaur> Pamelloes, same way you do at the top level. let uses layout
17:49:37 <Pamelloes> geekosaur: at the top level I use two lines. Is let myfunc :: Int -> String; a valid statement?
17:49:41 <Rotaerk2> actually, maybe i can just use the GLUT package with the gl package, even if it will bring in the OpenGLRaw
17:50:04 <lpaste> geekosaur pasted “let uses layout” at http://lpaste.net/14776495679471616
17:50:21 <Pamelloes> Ooooohhhhh
17:50:24 <Pamelloes> Thanks :)
17:50:56 <Rotaerk2> edwardk: could you explain, or point me to an explanation, of why the gl package exists?  Its purpose seems to be equivalent to that of OpenGLRaw, and they're both actively maintained
17:52:42 <grq> exit
17:52:44 <grq> quit
17:53:40 <alpounet> Rotaerk2: https://www.youtube.com/watch?v=yFXzuCFeRGM&feature=youtu.be&t=1h34m55s tells the story
17:59:27 <Rotaerk2> alpounet: thanks; I don't hear any mention of GL so far; are you referring to the discussion of hiding the guts of the library?
18:00:39 <Rotaerk2> ah k, there we go
18:00:41 <Rotaerk2> nevermind!
18:10:48 <cwl> How can I get the result row name of a sql query using postgresql-simple ？
18:12:04 <cwl> I want to show the rows in an html table. And set thead with the column name.
18:12:42 <cwl> How can I get the result column name of a sql query using postgresql-simple?
18:13:34 <alpounet> cwl: postgresql-simple doesn't let you do that, you probably want to take a look at the "raw" postgresql bindings, postgresql-libpq
18:14:35 <cwl> alpounet, Thanks.
18:15:14 <alpounet> cwl: in fact, i've seen postgresql-libpq be used *exactly* for exactly what you're about to do =)
18:16:31 <cwl> I want to build something like a postgresql web client. Now how can I query the db with unknown result type, and send result as json to the client?
18:17:03 <cwl> The query function has type query :: (ToRow q, FromRow r) => Connection -> Query -> q -> IO [r]
18:17:56 <alpounet> cwl: yeah but you don't get to access "meta data" (like column names" this way, you really want the low-level libpq bindings I mentionned above, i've seen it used exactly for a kind of webclient for pg :)
18:18:21 <alpounet> cwl: here https://github.com/zalora/redsift
18:18:46 <alpounet> cwl: of interest to you: https://github.com/zalora/redsift/blob/master/Redsift/DB.hs#L55
18:19:46 <cwl> alpounet, that is exactly what I need, thanks. :-)
18:22:25 <athan> Woohoo! DAG is... published!
18:23:31 <athan> I still need to make special instances for Applicative etc (like ZipList), and do better reflection, but it's still pretty cool if anyone wants to see it
18:23:43 <athan> It's got type computation out the wazoo
18:24:40 <benzrf> what is redsift
18:24:49 * hackagebot dag 0.0.1 - Basic type-safe directed acyclic graphs.  http://hackage.haskell.org/package/dag-0.0.1 (athanclark)
18:25:46 <platz> is there anything that describes the basic tradeoffs (the most obvious props which you consider when selecting one or the other) between initial and final encodings? would it be semi-accurate to say initial can be transformed easily and final can be extended more easily?
18:27:40 <platz> seeing as free monads (initial) and final tagless are duals
18:28:05 <athan> benzrf: Redhats heroku
18:28:09 <mpickering> they are both initial encodings really
18:28:27 <mpickering> search for "oleg typed tagless final interpreters"
18:28:30 <mpickering> I found that a nice read
18:28:47 <platz> final tagless is initial?  I thought final meant final
18:29:30 <benzrf> athan: i thought that was openshift
18:29:32 <mpickering> see: Folding Domain-Specific Languages:
18:29:38 <athan> oh wait you're right
18:29:52 <mpickering> by Wu and Gibbons as well
18:29:56 <mpickering> that might be what you're looking for
18:30:08 <Pamelloes> Can someone look at this: I have no idea why I'm getting the compile error "parse error on input 'return'"
18:30:11 <lpaste> Pamelloes pasted “Parse error on return” at http://lpaste.net/118719
18:30:34 <athan> supermassive PostreSQL?
18:30:47 <geekosaur> pamellos, this is the flip side of "let uses layout"
18:30:55 <geekosaur> you used braces for your do, you must use braces for your let
18:31:05 <mlamari> Is there a haskell mechanic to take a class (Foo a b) and reverse the params?  E.g. if I have :  instance SomeClass (Foo a) where. . . .  is there a way to get the lambda equiv of (\a b -> Foo b a) to swap in there?
18:31:16 <geekosaur> because layout won't work if you explicitly disabled it by using braces...
18:31:16 <Pamelloes> geekosaur: thanks
18:32:03 <Pamelloes> geekosaur: where do braces go in let?
18:32:23 <lpaste> geekosaur annotated “Parse error on return” with “Parse error on return (annotation)” at http://lpaste.net/118719#a118720
18:33:10 <Pamelloes> Thanks!
18:33:32 <platz> "Carette et al. say
18:33:32 <platz> only that they use the term ‘final’ “because we represent each object
18:33:32 <platz> term not by its abstract syntax but by its denotation in a semantic
18:33:33 <platz> algebra”, and they are not concerned with final coalgebras."
18:33:40 <platz> well that's confusing
18:37:56 <Pamelloes> Is there a version of replicateM that uses Integer instead of Int?
18:45:24 <pavonia> Pamelloes: Do you just want to pass it an Integer value or do you actually need more iterations than Int can provide?
18:46:12 <Pamelloes> pavonia: Well, I need to pass it an Integer value. I solved this by implementing my own replicateM based off of genericReplicate instead of replicate.
18:46:27 <geekosaur> fromIntegral...
18:46:41 <Pamelloes> geekosaur: But what if I'm given 2e123
18:46:46 <Pamelloes> Then what?
18:46:56 <geekosaur> then it's not an Integer either
18:47:21 <Pamelloes> Touché... I meant the 2e123's integral equivalent.
18:47:49 <pavonia> > 2^123
18:47:50 <lambdabot>  10633823966279326983230456482242756608
18:48:52 <benzrf> > 10^100
18:48:54 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
18:48:57 <Pamelloes> > 2*(10^123)
18:48:57 <benzrf> hmmm
18:48:58 <lambdabot>  2000000000000000000000000000000000000000000000000000000000000000000000000000...
18:49:06 <Pamelloes> hahaha
18:49:21 <Pamelloes> > 10^(10^100)
18:49:24 <gcganley> Pamelloes: Ive been working on some of your documentation
18:49:43 <Pamelloes> specification/specification?
18:49:44 <gcganley> so it fits on 80 width editor
18:50:10 <gcganley> and yes
18:50:49 <Pamelloes> Cool! I'd been meaning to do that but just never got around to it. Should be a 1 or 2 character vim command iirc.
18:52:12 <gcganley> Pamelloes: I use emacs. Is this the point where we have a religious debate?
18:52:53 <Pamelloes> gcganley: I've never used emacs, so I can't engage in said debate. Besides I've got better things to debate.
18:53:14 <Pamelloes> [GNU/]Linux for instance... hehe
18:54:26 <gcganley> Pamelloes: I only say GNU/Linux to be ironic. And I actually went from vim to emacs and use both. I only use vim when working over ssh and emacs for desktop use
19:00:07 <Pamelloes> gcganley: Fair enough.
19:00:42 <Pamelloes> Is there a parsec function that always returns false for use as a 0 value in foldr?
19:02:04 <kadoban> Pamelloes: I don't understand what you mean. What would the type be?
19:02:18 <Pamelloes> Parsec u m a
19:02:21 <gcganley> Pamelloes: I once wrote a parser that always failed for FP101x but not for parsec
19:02:53 <Pamelloes> I have [Parsec u m a] that I would like to fold over, but I'm not sure what to use as the initial value.
19:03:09 <gcganley> and i would look if the Parsec monad forms a monoid
19:03:22 <benzrf> Pamelloes: what sort of fold.
19:03:31 <Pamelloes> foldr (<|>)
19:03:38 <Pamelloes> It looks like I can just use foldr1
19:03:39 <benzrf> hmmmmm
19:03:47 <benzrf> Pamelloes: b-but that's PARTIAL
19:03:50 <benzrf> :t empty
19:03:51 <lambdabot> Alternative f => f a
19:04:12 <benzrf> @hoogle Alternative f => [f a] -> f a
19:04:13 <gcganley> run from the partial functions!
19:04:16 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
19:04:16 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
19:04:16 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
19:04:22 <benzrf> aha there we go
19:04:26 <benzrf> Pamelloes: asum
19:04:30 <benzrf> :t asum
19:04:31 <lambdabot>     Not in scope: ‘asum’
19:04:31 <lambdabot>     Perhaps you meant one of these:
19:04:31 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
19:04:33 <benzrf> :t F.asum
19:04:34 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
19:04:58 <Pamelloes> I'm not using applicative's <|>, I'm using parsec's <|> ;)
19:05:04 <benzrf> mfw
19:05:11 <gcganley> Pamelloes: why?
19:05:49 <lpaste> cdk pasted “'HList' of kind '[*] -> *' is not promotable error” at http://lpaste.net/118722
19:06:05 <Pamelloes> gcganley: Text.Parsec.Prim.<|> tries to match the first argument and then matches the second if the first fails without consuming input. It allows branching.
19:06:28 <benzrf> Pamelloes: does its Alternative instance do something diferent
19:06:33 <cdk> does anyone know why I get the 'kind not promotable error' in http://lpaste.net/118722 ?
19:06:52 <gcganley> Pamelloes: thats the same thing as Alternative/MonadPlus
19:06:52 <Pamelloes> benzrf: I don't know what that means :(
19:07:07 <benzrf> Pamelloes:
19:07:10 <benzrf> :t (<|>)
19:07:10 <lambdabot> Alternative f => f a -> f a -> f a
19:07:13 <EvanR> benzrf: i agree on the laziness is good thing, and if there was some totality guarantees in haskell it would be even nicer
19:08:10 <thang1> cdk: Your family All is going from (p :: * -> Constraint) (xs :: [*]) :: Constraint where...
19:08:30 <thang1> But the All' one has (xs :: HList [*]) instead
19:08:46 <Pamelloes> Huh. Turns out Text.Parsec.Prim exports Alternative's <|>
19:09:04 <gcganley> Pamelloes: thought so
19:10:03 <thang1> So, cdk, which version of GHC are you using?
19:10:16 <cdk> thang1: that's intentional, yes. I want to use my own HList kind, because the real type is a bit more complicated.
19:10:21 <gcganley> Pamelloes: are you using applicatives or monads?
19:10:35 <cdk> thang1: i'm using 7.8.2
19:10:42 <thang1> ooooh, that'll explain it I think
19:10:53 <Pamelloes> gcganley: Monads I think.....
19:11:00 <thang1> in ghc 7.8.2 not all data types are promotable
19:11:08 <thang1> https://www.haskell.org/haskellwiki/GHC/Kinds
19:11:15 <gcganley> Pamelloes: what book/blog are you learning from
19:11:25 <cdk> thang1: Is it fixed in 7.10?
19:11:32 <thang1> Not 100% sure how up to date that is, but you might need something like -XDataKinds
19:11:35 <thang1> https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/promotion.html
19:11:54 <cdk> thang1: I'm using DataKinds already
19:11:56 <thang1> cdk: It should be. I remember reddit going all hype-train over that
19:12:07 <Pamelloes> gcganley: None? I read learn you a haskell a month or two ago and have been learning by doing ever since :P
19:12:25 <thang1> Oh, the code snippet you shared didn't have DataKinds in it
19:12:29 <thang1> that's why I thought you weren't using it
19:12:39 <gcganley> Pamelloes: have you seen the typeclassopedia?
19:12:54 <Pamelloes> Nope
19:12:56 <thang1> You have TypeFamilies, KindSignatures, GADTs, ConstraintKinds but no XDataKinds
19:13:07 <cdk> sorry, I edited it to add DataKinds and TypeOperators
19:13:35 <thang1> cdk: that's so cool how I can just refresh the page and see that change... Anyway
19:13:36 <gcganley> Pamelloes: oh dude read that right now. It helped me sooo much for understanding typeclasses. and read Real World Haskell if you want 700 pages of the stuff
19:13:52 <thang1> Pamelloes: https://www.haskell.org/haskellwiki/Typeclassopedia
19:14:11 <thang1> I suggest downloading that and wrapping it into a pdf or something and studying it well. It's invaluable
19:14:26 <gcganley> @google typeclassopedia pdf
19:14:27 <lambdabot> https://www.haskell.org/wikiupload/e/e9/Typeclassopedia.pdf
19:14:27 <Pamelloes> Hehe, I will look into it
19:14:30 <gcganley> there
19:14:34 <thang1> gcganley: I wouldn't suggest real world haskell anymore. It's quite outdated and several sections talk specifically about (now) obsolete packages
19:14:40 <ezrios> How does one specify the number of tests to run for a QuickCheck property when using HSpec?
19:14:55 <ezrios> I know quickCheckWith stdArgs { maxSuccess = foo } works in vanilla QuickCheck
19:15:15 <ezrios> but I cannot use quickCheckWith as it is an IO action and not a property, while HSpec requires the latter
19:15:17 <SrPx> Just for curiosity (as always), is there any other view on the whole "functor - applicative - monad" model, or is it "the only way"?
19:15:20 <thang1> Back to cdk: In 7.8.3 you have to jump through a lot of hoops to approximate most of DataKinds
19:15:30 <gcganley> thang1: it is outdated but there is a lot you can gleen from it
19:16:08 <thang1> gcganley: is there anything in there that you can't gain from the CIS 192 Haskell class? (https://www.seas.upenn.edu/~cis194/)
19:16:25 <cdk> thang1: I just tried compiling with GHC 7.11, I get the same compiler error.
19:16:35 <Pamelloes> So I'm reading the introduction to Typeclassopedia, and it mentioned "fmap fmap fmap". I think my head just exploded D:
19:16:47 <gcganley> :t fmap fmap fmap
19:16:48 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
19:16:48 <thang1> cdk: Weird...
19:17:25 <Pamelloes> Wait... that's all it does?
19:17:27 <gcganley> :t zip . (<*>)
19:17:28 <lambdabot>     Couldn't match type ‘f a1 -> f b1’ with ‘[a]’
19:17:28 <lambdabot>     Expected type: f (a1 -> b1) -> [a]
19:17:28 <lambdabot>       Actual type: f (a1 -> b1) -> f a1 -> f b1
19:17:38 <Rotaerk2> anyone have experience with GLFW or GLFW-b?
19:17:41 <Rotaerk2> know which is ... better?
19:17:47 <EvanR> glfw-b
19:17:57 <Axman6> well, one is missing b
19:18:01 <Axman6> >_>
19:18:01 <gcganley> Pamelloes: have you never tried using type classes in aggression?
19:18:06 <Rotaerk2> b for better, I suppose
19:18:37 <MP2E> lol
19:19:24 <EvanR> Rotaerk2: also theres #haskell-game
19:19:37 <thang1> Pamelloes: You know what fmap does, right?
19:19:42 <Rotaerk2> oo, didn't know about that.  thanks
19:20:01 <Pamelloes> thang1: Yep :)
19:20:11 <gcganley> thang1: he uses it in his code so i hope he does lol
19:20:43 <Pamelloes> gcganley: Seeing as I don't know what that means, I'm going to say no
19:22:21 <gcganley> agression as in using typeclasses a lot. the (<|>) lies in the typeclass Alternative. It has two functions. (<|>) and empty.
19:22:41 <gcganley> :t many
19:22:42 <lambdabot> Alternative f => f a -> f [a]
19:22:55 <thang1> gcganley: ah okay. I just never really found chaining fmap as surprising so I was wondering why Pamelloes was all "mind blown" about it :p
19:22:57 <gcganley> there is your many you probebly use a lot in parsec code
19:23:22 <gcganley> thang1: its because
19:23:25 <gcganley> crap
19:23:28 <thang1> lol
19:23:46 <EvanR> fmap f . fmap g . fmap h == fmap (f . g . h)
19:23:50 <gcganley> thang1: its because "someone used fmap fmap fmap and my head exploded" was in the first page of the typeclassodia
19:23:56 <EvanR> no need to chain fmaps ;)
19:24:20 <thang1> Oh, I feel stupid now...
19:24:24 <gcganley> thang1: LOL
19:24:41 <gcganley> thang1: i re-read it constantly so i would know
19:24:49 * hackagebot cudd 0.1.0.1 - Bindings to the CUDD binary decision diagrams library  http://hackage.haskell.org/package/cudd-0.1.0.1 (adamwalker)
19:25:18 <thang1> I really need to sit through and read it hardcore sometime but between physics, engineering and calc 4 I have no time for anything. I also need to learn objective-C first because I'm gonna use it for a project with my professor and I promised him I'd start learning it... This summer...
19:26:13 <Axman6> can't use swift?
19:26:36 <Pamelloes> EvanR: That would be why I've never chained fmap! It all makes sense now :D
19:26:37 <thang1> He likes xcode 5 more than xcode 6, swift still has some issues, the project already started with objective-C and there's TONS of objective-C legacy code around
19:26:50 <gcganley> does swift have any functional programming elements in it
19:26:53 <Axman6> but you can call all Objective-C with Swift
19:26:59 <Axman6> gcganley: many
19:27:02 <thang1> Even if swift is way nicer than objective C in many respects, it's still more than worth it to learn obj-c
19:27:09 <thang1> Axman6: You can call Swift in Obj-C code as well
19:27:22 <Pamelloes> Obj-c is quite easy to learn once you get over the [] syntax
19:27:23 <thang1> they made it as interchangeable as possible, which was a really smart move on their part
19:27:29 <Axman6> it's a pretty cool language for something that has to maintain strong compatibility with such a horrible language as Obj-C
19:27:39 <gcganley> Axman6: i was curious about writing something like map or fmap in swift
19:27:50 <thang1> Pamelloes: I hated the [] syntax. That and prefixing every fucking thing with NS and other crap because of no namespaces
19:27:54 <EvanR> gcganley: not really. but they do have something like algebraic data types, and a nil that acts kind of like the Maybe monad
19:28:07 <Axman6> See Swiftz, it's like Scalaz for swift, started by a guy I work with
19:28:21 <gcganley> where do you work?
19:28:28 <Axman6> NICTA
19:28:29 <thang1> EvanR: I think there's also something like 'map' built into the language too?
19:28:43 <EvanR> well, map doesnt make you a functional language
19:28:59 <EvanR> its nice but not nearly enough
19:29:04 <gcganley> Axman6: did you get to see edwardk's presentation when he went to australia
19:29:16 <thang1> NICTA: "Australian's info and communications tech resarch center". Or, national insurance criem training academy :p
19:29:28 <Axman6> I did, had a quick chat with him
19:29:44 <Axman6> thang1: I don't get the joke?
19:29:49 * hackagebot samtools-conduit 0.1.0.1 - Conduit interface to SAM/BAM format files through samtools  http://hackage.haskell.org/package/samtools-conduit-0.1.0.1 (NicholasIngolia)
19:30:01 <thang1> Axman6: wasn't really a joke. I was just amused that the first option was a tech research center and the second was a crime training academy
19:30:24 <Axman6> oh, right
19:30:26 <thang1> kinda like when I googled 'cda' and got coeur d'alene (the acronym I was looking for) but also unrelated stuff like california dential association
19:31:07 <Axman6> I'm surprised NICTA has other uses, it's prtetty long as far as acronyms go
19:31:34 <gcganley> Axman6: what do you guys use at NICTA
19:31:59 <thang1> Back to cdk: Did you ever fix your problem? I noticed in your code that you have HList defined as [*] -> * and that All' had HList [*] so maybe there's a layer one too deep of [*] in there somewhere?
19:32:06 <Axman6> lots of stuff. anything my team writes will be in Haskell, there's plenty of java, and lots of researchers using whatever they want
19:32:18 <gcganley> Im hoping lisp to perpectuate the misconception that every AI team uses Lisp
19:32:32 <gcganley> s/perpectuate/perpetuate
19:32:46 <chu> Patrick Haslam does Lisp, but I don't think he's associated with NICTA, he's just at ANU.
19:32:47 <thang1> gcganley: sounds like you had a lisp when you were typing...
19:33:15 <Axman6> not sure we do much AI here
19:33:24 <Axman6> well, we have a machine learning group I guess
19:33:39 <gcganley> Axman6: thats what i saw
19:33:41 <thang1> That's pretty much AI to me, really. Or a form of it
19:34:36 <gcganley> machine learning weirds me out. not because im afraid of the Terminator (I for one accept out robot overloards) but more on an implemantation side
19:34:41 <gcganley> appologies for spelling
19:34:50 <gcganley> as I spell that wrong
19:35:15 <thang1> What about implementation weirds you out?
19:36:30 <gcganley> thang1: Any sufficiently advanced technology is indistinguishable from magic.
19:37:03 <roconnor> shachaf: I have a blog post where I mention holesOf
19:37:42 <ReinH> roconnor: o/
19:37:44 <roconnor> shachaf: http://r6.ca/blog/20121209T182914Z.html
19:37:48 <roconnor> Hi ReinH
19:37:56 <gcganley> hello rein
19:38:00 <ReinH> gcganley: hi
19:38:08 <Welkin> AI has a funny history
19:38:44 <thang1> What I find funny about AI is the fact that the AI in shows like star trek and whatever are actually dumber than a lot of the AI we're capable of now
19:38:49 <Welkin> a professor at my university who studied at MIT and worked in the AI lab, and now does AI work at my university, gets quite upset when people call machine learning "AI"
19:38:51 <thang1> But it's no longer true "AI" to us anymore
19:39:30 <gcganley> you guys want to hear the corniest Lisp joke I know?
19:39:42 <EvanR> NIL
19:39:48 <Welkin> he writes everything in lisp, too
19:40:14 <Welkin> common lisp...
19:40:47 <gcganley> split-p soup?
19:40:56 <AshyIsMe> gcganley: haha
19:41:00 <kadoban> thang1: They are? What sci-fi AI is worse than what we can currently do?
19:41:09 <gcganley> Im so sorry
19:41:52 <thang1> lol that's beautiful
19:42:15 <gcganley> all credit goes to Bill Hosper
19:42:53 <thang1> kadoban: I wasn't thinking of Data. I was thinking of the computer systems in use by the Federation in Star Trek. Voice controlled stuff people called AI back in the day, etc
19:43:10 <Welkin> http://stackoverflow.hewgill.com/questions/175/12.html
19:43:13 <thang1> Forgot that Data was an android
19:43:17 <gcganley> ReinH: you refrence Richard Bird a lot. is his work still relevent?
19:43:19 <Welkin> tons of computer jokes
19:43:47 <kadoban> thang1: Our current voice controll is really pretty crap though, isn't it? It's been a while since I've watched much star trek, but I remember the computer voice control being pretty advanced.
19:43:55 <Welkin> I personally like HAL 9000
19:44:33 <EvanR> yes when bugs cause your computer to become murderous
19:44:52 <EvanR> he must have been designed in the futuristic version of C++
19:44:53 <gcganley> I still havent watched that movie :/
19:44:59 <gcganley> EvanR: LOL
19:45:45 <Welkin> you must see 2001: A Space Odyssey
19:45:47 <Jamin488> blackhat best movie confirmed?
19:45:58 <Welkin> it's wonderful
19:46:25 <Welkin> Interstellar borrowed from it heavily
19:46:51 <kadoban> 2001 was a great book. I couldn't stay awake through the movie...
19:46:54 <thang1> kadoban: The voice control in our phones is comparible to the voice control in star trek a lot of the time, but if you take specialized software and systems that are much more powerful, etc. we can get voice recognition that's almost perfect and turn that into data lookup quite well
19:47:02 <horny-sama> I don't know why http://www.fpaste.org/171251/63906214/ is casuing a syntax issue when it is the same as http://zvon.org/other/haskell/Outputprelude/elem_f.html
19:47:02 <gcganley> Welkin: i havent even watched Jurrasic park or an Indiana Jones movie
19:47:03 <AshyIsMe> kadoban: the google now voice control on the new android phones is pretty sweet
19:47:03 <trap_exit> this soudns sorta retarded, but I'm serious as I'm trying to embed a language within haskell
19:47:09 <thang1> The hard part for us is condensing that into something that runs on a phone, not making a "perfect" voice control
19:47:11 <trap_exit> is there a wy to overload ' '? as in "f a" = call f, with firsg arg = a
19:47:21 <AshyIsMe> i use it all the time "ok google, remind me in 2 hours to reboot the server.." etc
19:47:24 <horny-sama> ooo the quotation mark vs `
19:47:26 <horny-sama> got it
19:47:27 <trap_exit> I want a way to overload the ' ' (i.e. with typeclasses, I can ove3rload +-*/)
19:47:38 <trap_exit> but now, I want to overlad the "apply; this function with this arg" , i.e. ' '
19:47:39 <EvanR> trap_exit: how is that retarded
19:47:45 <AshyIsMe> or texting while driving "ok google, send a txt to X person, im 5 minutes away"
19:47:53 <horny-sama> I guess I have bad eyes
19:47:54 <horny-sama> lol
19:48:00 <trap_exit> EvanR: you go into a channl, and say, I want to redefikne what ' ' does -- how is that not retarded? :-)
19:48:13 <gcganley> Pamelloes: still reading the typeclassopedia? lol
19:48:18 <trap_exit> EvanR: the only possible redeeming value of my request is that I want to build a EDSL
19:48:26 <Welkin> horny-sama: must be all that porn
19:48:27 <EvanR> trap_exit: oh, well the nature of function application lets you get away with a lot without "overloading" it
19:48:31 <trap_exit> otherwise, my request is full retard
19:48:41 <horny-sama> Welkin: lol
19:48:48 <kadoban> thang1: Hmm, interesting. I've seen what's on phones, but largely I'm not impressed. It seems unreliable enough that I barely use it, heh. Maybe it's my specific accent, AshyIsMe
19:48:48 <Pamelloes> gcganley: I printed it out. I intend to read it in more depth at a later point tonight/tomorrow morning
19:49:22 <gcganley> Pamelloes: Cup of coffee and ghci-ng is my suggestion for reading any haskell book
19:49:36 <gcganley> wow my grammer is off tonight
19:49:50 <Pamelloes> gcganley: Good suggestion. I will take that into consideration :)
19:50:03 <AshyIsMe> so when people are worried about templatehaskell not being portable, do they mean to the non-existant haskell compilers that are not ghc?
19:50:10 <gcganley> Pamelloes: or cocain, whatever floats your boat
19:50:30 <gcganley> AshyIsMe: they mean its not on ARM
19:50:30 <roconnor> AshyIsMe: last time I tried to build GHC on an ARM, template haskell didn't work for it.
19:50:32 <Pamelloes> ^.^
19:50:35 <pavonia> trap_exit: I don't think there's a way to hijack the syntax other than using quasiquotes
19:50:46 <trap_exit> AshyIsMe: what about uses of hugs, YHC, and UHC ?
19:50:50 <AshyIsMe> ah ok
19:51:12 <EvanR> trap_exit: are there any?
19:51:16 <AshyIsMe> trap_exit: aren't they all way out of date in terms of supporting recent versions of hackage libs?
19:51:32 <EvanR> i dont think you can get hugs working anymore
19:51:35 <trap_exit> i dunno
19:51:41 <trap_exit> never used them myself
19:51:50 <horny-sama> i feel like haskell is math proof 101
19:52:04 <EvanR> math proof. math cant damage it
19:52:14 <juri_> wait until idris.
19:52:16 <AshyIsMe> kadoban: it could be your accent, although i have a heavy aussie accent and it seems to work surprisingly reliably with that
19:52:33 <geekosaur> EvanR, jhc
19:52:54 <geekosaur> uhc is also still actively maintained, apparently. the others are dead
19:53:14 <AshyIsMe> i wouldnt expect it to recognize "gday google, chuck a u-ey up ahead aye" though haha
19:53:35 <kadoban> AshyIsMe: I have a pretty generic random-mix of USA accents. It could be that I'm just less...patient with voice control. I expect it to work crap, so if it fails I give up and never use it again, heh...
19:53:47 <thang1> Google now actually does recognize all that if your language is set to english (australian)
19:53:59 <AshyIsMe> thang1: ah nice, i just havent tried
19:54:02 <thang1> Pretty sure there's an australian option in there... I know there's a UK one, which works much better for aussies
19:54:47 <AshyIsMe> ah my nexus 5 only has english (uk) as the closest
19:54:50 <AshyIsMe> no aussie one
19:54:53 <thang1> I'm also fairly impatient with voice control sometimes. What annoys me the most about it is sometimes having to phrase things a certain way
19:55:09 <shachaf> roconnor: Oh, now I remember.
19:55:13 <AshyIsMe> kadoban: i would expect google now to handle american accents pretty well
19:55:15 <thang1> Like, why the hell can't "football games" pull up the same google now card as "nfl schedule" or whatever, etc
19:55:31 <gcganley> AshyIsMe: they wont allow you to set it to aussie do to the excess of the word "cunt" when refering to the person speaking
19:55:41 <AshyIsMe> kadoban: next time your in a phone shop pick up a nexus 6 and say "ok google, hello" and it will explain all the commands it supports
19:55:56 <shachaf> (But my phone isn't the best place to go into details.)
19:56:21 <thang1> gcganley: why would that have anything to do with it? lol
19:56:30 <AshyIsMe> gcganley: ah yeap, bloody google, what poofters aye
19:56:38 <shachaf> glguy is
19:56:41 <shachaf> working on the new holesOf variation
19:56:51 <glguy> (and needs help)
19:57:27 <gcganley> AshyIsMe: Also google would just assume your name is bruce
19:57:51 <gcganley> glguy: (with what)
19:58:14 <thang1> Oooh, just looked it up. Pretty sure you have to download an offline voice pack to get australian voice recognition
19:58:16 <AshyIsMe> i'd love an aussie accent for the navigation
19:58:35 <gcganley> "Just take a left there bruce"
19:58:35 <glguy> gcganley: Working on eliminating the Magmas from this http://lpaste.net/118728
19:58:40 <AshyIsMe> "chuck a u-ey in 50 metres mate"
19:59:12 <AshyIsMe> "wrong way wanker, i'll find another route"
19:59:14 <thang1> Totally read that in my steve erwin voice
19:59:24 <gcganley> im pretty sure u-ey is used everywhere
19:59:37 <gcganley> especially "chuch a u-ey"
19:59:48 <gcganley> s/chuch/chuck
20:00:17 <thang1> I've never had google tell me to chuck a u-ey
20:01:54 <AshyIsMe> gcganley: it's a very aussie thing
20:01:59 <kadoban> gcganley: Hmm, probably not. I'd never use either "u-ey" or "chuck a u-ey". I could understand, with a bit of thought, what they mean though.
20:02:04 <Welkin> http://pauillac.inria.fr/~xleroy/stuff/california-prog.html
20:02:05 <AshyIsMe> maybe british possibly too, but i dont think so
20:02:09 <AshyIsMe> same with "this arvo"
20:02:28 <AshyIsMe> always cracks me up when americans have no idea what im talking about
20:02:31 <gcganley> AshyIsMe, kadoban: we use it all the time in Boston
20:02:35 <geekosaur> "chuck a u-ey" *sounds* aussie to me
20:02:47 <AshyIsMe> gcganley: ah true, nice
20:03:04 <gcganley> *noice ftfy
20:03:10 <AshyIsMe> boston is heavily irish descended right?
20:03:16 <AshyIsMe> maybe that has something to do with it
20:03:36 <AshyIsMe> always shorten words and make them end with ee or oh sounds
20:03:46 <EvanR> blah
20:03:57 <gcganley> AshyIsMe: My moms side is named costello and dads side is ganley. lots of scot-irish folk from the potatoe famine
20:03:58 <EvanR> haskell-blah ;)
20:04:18 <gcganley> i cant spell for shit tonight
20:04:36 <thang1> lol
20:04:40 <thang1> too many drinks in ya?
20:04:50 <gcganley> thang1: I'm 17...
20:04:56 <EvanR> > 's':'h':'i':'t':[]
20:04:58 <lambdabot>  "shit"
20:05:02 <EvanR> there you go
20:05:03 <gcganley> EvanR: lol
20:05:31 <EvanR> ('4':)
20:05:35 <thang1> gcganley: never stopped a lot of people I know, before :p
20:05:59 <thang1> I waited until the ripe old age of 19 before having me a sip of alcohol
20:08:29 <AshyIsMe> gcganley: ah yeap, my last name is ash and i have red hair so im probably fairly irish
20:09:56 <gcganley> AshyIsMe: Except most of the Irish in Australia were there for jail time not potato famines
20:10:11 <horny-sama> https://github.com/mr-fool/haskell/blob/master/rightTriangle/rightTriangle.hs <--need some help in debugging
20:10:26 <horny-sama> and is there anyway to break the statement into two lines
20:10:33 <gcganley> horny-sama: oh my what are you trying to do here
20:10:55 <horny-sama> gcganley: create program to check if the input is a right triangle
20:11:05 <EvanR> horny-sama: let x = y isnt a valid top level declaration
20:11:12 <EvanR> get rid of the let
20:11:12 <gcganley> yeah ^
20:11:25 <gcganley> its just rightTrianges = ...
20:11:32 <gcganley> no let
20:11:32 <horny-sama> EvanR: when do you use let
20:11:33 <AshyIsMe> gcganley: yeah true
20:11:34 <horny-sama> anyways
20:11:48 <EvanR> horny-sama: the basic way is as an expression, of the form...  let x = y in z
20:11:57 <EvanR> > let x = 1 in x
20:11:58 <lambdabot>  1
20:12:26 <roconnor> shachaf: is it notches?
20:12:36 <EvanR> > let x = 1 in x + 1
20:12:37 <lambdabot>  2
20:13:14 <horny-sama> let rightTrianges = [ (a,b,c) | c <- [1..], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2] works
20:13:55 <gcganley> horny-sama: in ghci or ghc?
20:14:03 <horny-sama> gcganley: ghc
20:14:07 <horny-sama> I mean ghci
20:14:11 <gcganley> thats why
20:14:12 <shachaf> roconnor: It's lens issue 252
20:14:32 <shachaf> Being discussed in #-lens currently.
20:14:35 <gcganley> you can use top-level let bindings in ghci due to the fact that your basically living in a monad
20:15:23 <EvanR> horny-sama: ghci is special, it lets you do let x = 1 by itself, or x <- launchMissiles by itself. imagine ghci as being an implicit do-notation block
20:15:49 <horny-sama> ok
20:15:59 <dfeuer> What the ever loving fuck.
20:15:59 <Welkin> gcganley: it's like the matrix
20:16:04 <kadoban> I've never found ghci to be anywhere near as useful as everyone else seems to think it is...just me? When I was new it was just confusing, and then...never found an actual use for it.
20:16:08 <dfeuer> oh wait, duh.
20:16:12 <horny-sama> any debugging tips for haskell coz the feedback is not that informative
20:16:25 <gcganley> Welkin: if the matrix where written in do-notatoin
20:16:30 <gcganley> WOW im going to bed
20:16:31 <Welkin> horny-sama: just compile and read the warnings and errors
20:16:32 <EvanR> The Monad
20:16:35 <Welkin> they are very clear
20:16:52 <dfeuer> Nope, that ain't it.
20:16:55 <horny-sama> Welkin: no debugger for haskell?
20:17:01 <horny-sama> like gdb?
20:17:12 <gcganley> horny-sama: there is a debugger in ghci that no one that i know of uses often
20:17:18 <dfeuer> I'm getting segmentation faults and I really really don't know why.
20:17:35 <gcganley> night
20:17:36 <dfeuer> I've wrapped every vector access with an assertion, and I'm compiled with -fno-ignore-asserts.
20:17:53 <Welkin> horny-sama: you don't need a debugger for basic things the compiler tells you
20:18:01 <Welkin> I've never needed one
20:18:32 <Welkin> there was only one time I couldn't figure out what the issue was, and it ended up being the monomorphism restriction, which had an easy fix
20:18:37 <dfeuer> Every vector access other than mapM and mapi, anyway.
20:18:37 <Welkin> that was using lens, though
20:18:45 <horny-sama> Welkin: but what about big programs
20:19:00 <dfeuer> This is pretty much driving me nuts.
20:19:58 <Pamelloes> dfeuer: It could always be worse. At least this isn't your kernel and you have to restart your entire computer to perform a single test :P
20:20:13 <hakujin> is there a breakpoint where a hashmap lookup performs faster than pattern matching for a large number of patterns?
20:20:40 <hakujin> (how does pattern matching work behind the scenes)
20:20:43 <R0b0t1`> horny-sama: develop in units
20:21:00 <Welkin> hakujin: it's probably the other way around, meaning the hashmap performs slower for larger numbers of lookups vs just using patterns
20:21:03 <EvanR> horny-sama: debugging a large program when have nothing but "exception: foo" is pretty hard. its very important to write code youre pretty sure cant fail
20:21:10 <Welkin> because of cache locality
20:21:15 <horny-sama> this should normally be a 15mins programming exercise and with haskell it is taking me forever to write a program to check if it is a right triangle or not
20:21:36 <Welkin> horny-sama: take it slow and think about the types
20:21:38 <EvanR> well you need practice obviously
20:21:51 <Welkin> horny-sama: in haskell you must know the types first, then write the functions to fit those types
20:22:07 <hakujin> Welkin: how does pattern matching work? it's better than O(n), right?
20:22:09 <Welkin> think about it in terms of transforming the data
20:22:18 * dfeuer is beginning to wonder if maybe the bug is in Someone Else's Code (TM)
20:22:25 <Welkin> what is the pipeline it needs to go through
20:22:45 <horny-sama> EvanR: I was not expecting that my prior programming experience not helping me at all
20:22:50 <Welkin> hakujin: pattern matching is turned into case expressions
20:22:53 <dfeuer> *if* that is so, the most likely candidate is arithmoi.
20:22:55 <EvanR> horny-sama: pretty much
20:22:58 <Welkin> I don't know what happens beyond that in ghc
20:23:39 <EvanR> hakujin: for a given case expression, there arent very many cases usually, so calling it O(anything) doesnt matter. but the program will try each case, one after the other, until one matches
20:23:41 <R0b0t1`> horny-sama: you have probably done all of this before, it just was represented a different way.
20:23:50 <hakujin> Welkin: I mean case expressions when I say pattern matching, not destructuring
20:23:57 <horny-sama> R0b0t1`: I did not know you are in freenode as well
20:24:09 <AshyIsMe> dfeuer: ive been explicitly installing an older version of arithmoi to use with diagrams because the latest one fails with "make sure you have installed LLVM"
20:24:44 <AshyIsMe> although that's probably pretty silly of me
20:25:10 <hakujin> the answer here is just to benchmark, but I'm curious about the why
20:25:36 <HeladoDeBrownie> horny-sama, haskell encourages you to approach problems a bit differently from how you would in most other languages. as such, there is a somewhat larger initial learning curve. patience is helpful.
20:25:37 <Welkin> hakujin: why what?
20:25:41 <dfeuer> AshyIsMe, my problem is not related to that; I was using the primeSieve and primeList functions together and getting segfaults. I can't (yet) guarantee that it wasn't my fault, but I've put in enough assertions that I'm pretty sure it wasn't.
20:25:47 <R0b0t1`> horny-sama: ... I sent you here for a reason, obviously.
20:25:58 <horny-sama> R0b0t1`: lol
20:27:50 <thang1> hakujin: Not sure how this answers your question. But for data structures, it's fairly well regarded that hash lookup tables are always faster for lists of less than ~20 items. As the list of items gets larger, some lookup algorithms get close enough to hash lookup times that you can use them without huge performance hits
20:28:27 <EvanR> hakujin: think of case expressions as the primitive operation at the lowest level, like youd think of a conditional jump instruction
20:28:28 <thang1> But hash lookup, with an appropriate algorithm, is always faster because you keep the entire hash table in memory for the duration of its use, vs looking up the memory in a linked list or whatever
20:29:08 <EvanR> thang1: i dont think this stuff matters for case expressions
20:29:19 <EvanR> its not a hash table or a linked list
20:29:37 <horny-sama> I guess I need to get used to reading haskell error
20:29:42 <thang1> EvanR: Yeah, I realized that a little too late :p
20:31:04 <horny-sama> https://github.com/mr-fool/haskell/blob/master/rightTriangle/rightTriangle.hs <--- I don't know why line 15 is causing the error
20:31:15 <horny-sama> is it because I am breaking it into two lines?
20:31:34 <Welkin> you cannot define a function in them iddle of a function like that
20:31:41 <Welkin> it must either be a top-level function
20:31:50 <Welkin> or put into a where clause or let expression
20:32:18 <horny-sama> Welkin: okay
20:32:25 <Welkin> well, inside of a do-block, you can use let f = ...
20:32:29 <Welkin> leaving off the "in"
20:33:38 <Welkin> line 16 doesn't make any sense to me
20:34:45 <horny-sama> Welkin: https://github.com/mr-fool/haskell/blob/master/rightTriangle/rightTriangle.hs <--- still no goal :<
20:35:41 <pavonia> let starts another layout block
20:36:05 <horny-sama> ?
20:36:08 <Welkin> you didn't change anything
20:36:20 <Welkin> "checking" needs to be put into a let expression
20:36:30 <Welkin> let checking a b c = ...
20:36:44 <Welkin> same with the type declaration for checking
20:37:03 <Welkin> the problem you are having is that you don't understand do-notation
20:37:04 <pavonia> Or indent it further so that is becomes part of the previous let block
20:37:08 <shachaf> cdk: Did you figure out your HList question from before?
20:37:13 <Welkin> it is just syntactic sugar for bind
20:37:19 <shachaf> cdk: I saw your stackoverflow post and it looks a bit confusing.
20:37:37 <R0b0t1`> horny-sama: https://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot and https://www.haskell.org/wikiupload/c/c6/ICMI45-paper-en.pdf and http://web.cecs.pdx.edu/~mpj/thih/TypingHaskellInHaskell.html
20:37:37 <R0b0t1`> you should probably go see the tutorials as well
20:37:54 <Welkin> horny-sama: I'd advise that you read about how do-notation works -- it is nothing like imperative programming
20:37:54 <Pamelloes> What a weird occurence. My unit tests failed alerting me to a bug instead of to a mistyped unit test.
20:37:59 <horny-sama> Welkin: when do you use let statement
20:38:14 <Pamelloes> It's always nice when something actually serves its intended purpose :D
20:38:29 <EvanR> Pamelloes: yeah thats happened maybe twice to me
20:38:36 <horny-sama> R0b0t1`: I am reading learnyouahaskell and practicing in the same time
20:39:06 <Welkin> horny-sama: if you want to define something in a do-block, it must be in a let expression
20:39:25 <Pamelloes> EvanR: The only reason why it happened is because I wrote the tests for a previous version and just performed some major refactors. So I wound up with already working tests before I had working code.
20:39:40 <dfeuer> Yeeeeeeah, I'm increasingly confident that this is an arithmoi bug.
20:39:42 <dfeuer> GRRR
20:39:42 <pavonia> horny-sama: let introduces local bindings
20:39:54 <Welkin> your "checking" function also makes no sense
20:40:04 <Pamelloes> I guess that's why you're supposed to write tests before you write teh code being tested. But that's no fun :D
20:40:07 <Welkin> how can (a,b,c) == True ?
20:40:16 <monochrom> if you want to define anything, it must be top-level or "where" or "let". if it relies on something available only in a do-block, then it's a "let", no choice.
20:40:20 <horny-sama> okay
20:40:28 <Pamelloes> Welkin: C++?
20:40:38 <dfeuer> Haaaaahaahahaha
20:40:51 <dfeuer> Or (essentially) in most Lisp variants.
20:40:55 <Welkin> also, your type declaration for `checking` is wrong
20:41:05 <EvanR> Pamelloes: write the types before the code ;)
20:41:08 <horny-sama> Welkin: is there a way that I can push my user input into rightTriangle to test if the condition is true or not
20:41:15 <Welkin> you defined it as `checking a b c = ...` yet your declaration is :: Int -> String
20:41:51 <horny-sama> Welkin: if the condition is met print a string so it is Int -> String?
20:42:26 <Axman6> What does Int have to do with what you said?
20:42:39 <thang1> Write the types before the code, write the tests before the code, run the debugger before you write the code. Hell, ship it to production before you write the code :p
20:42:50 <horny-sama> Axman6: I want the input to be only Int?
20:42:55 <EvanR> thang1: i agree
20:43:02 <EvanR> saves a lot of work
20:43:03 <Axman6> horny-sama: only a single Int?
20:43:11 <Welkin> horny-sama: but you defined it as taking 3 arguments: a, b, and c
20:43:12 <monochrom> "if the condition is met" --- a condition is a Bool, not an Int. "print a string" --- outputting a string is an action of type IO(), not String.
20:43:36 <thang1> EvanR: If it was possible to write the program without actually writing the code, most people would probably do that. It'd be funny if, in 20 years, compilers had optimized to such an extent that we basically just did that
20:43:42 <horny-sama> Axman6: multiple Int
20:43:59 <thang1> "we define this function to do these things... this way... so that the program does this... COMPILER! DO THE THING"
20:44:16 <kadoban> thang1: That's kinda what Haskell is :)
20:44:23 <Welkin> horny-sama: if a, b, and c have type Int, and the output of the function is a String, then the type is :: Int -> Int -> Int -> String
20:44:26 <horny-sama> Axman6: https://github.com/mr-fool/haskell/blob/master/rightTriangle/rightTriangle.hs#L15 something like this?
20:44:36 <monochrom> it is already possible to write the program without actually writing the code. today. just hire me to actually write the code. :)
20:44:41 <horny-sama> Welkin: okay
20:44:43 <Axman6> but the type Int -> String only takes a single Int
20:45:09 <EvanR> thang1: check out this video, where near the end, he has the vim plugin write most of the code him by filling in the only thing that makes sense for the types https://www.youtube.com/watch?v=uFwh3Uv8Nrw
20:45:19 <Axman6> Welkin: probably better to not say "output" but returns String
20:45:19 <EvanR> code for* him
20:45:37 <horny-sama> EvanR: ai ?
20:45:49 <Axman6> EvanR: djinn or something more magic?
20:46:08 <EvanR> he says "agda does this better"
20:46:25 <EvanR> i dont actually know how it works
20:46:36 <horny-sama> then the issue is how to I check condition in my case?
20:47:00 <pavonia> horny-sama: What is the type of rightTriangle supposed to be?
20:47:01 <Axman6> well, you can use if then else for one
20:47:14 <horny-sama> pavonia: int?
20:47:16 <R0b0t1`> horny-sama: https://en.wikipedia.org/wiki/Currying, and not AI, type inference.
20:47:16 <Welkin> horny-sama: not quite
20:47:24 <Welkin> let rightTriangle = ...
20:47:37 <EvanR> i think the feature he uses is called proof search
20:47:38 <Welkin>     checking :: Int -> Int -> Int -> String
20:47:42 <Welkin>     checking a b c = ...
20:47:48 <Welkin> formatted like that
20:47:50 <pavonia> horny-sama: Why do you use list comprehensions then?
20:47:54 <Welkin> with that many spaces
20:48:02 <gamegoblin> will ghc compile x `div` 8 (or some other power of 2) to a bitshift?
20:48:43 <Welkin> gamegoblin: just use the bitshift operator
20:48:51 <horny-sama> Welkin: I thought you need let checking inside a do block
20:48:56 <Axman6> depending on the types, LLVM will probably do the right thing
20:49:00 <gamegoblin> Welkin: wanted to make my code clearer if I knew GHC would do it behind the scenes
20:49:08 <gamegoblin> Axman6: I figured LLVM would do it, didn’t know about GHC itself
20:49:19 <horny-sama> pavonia: coz I got a textbook example of > let triangles = [(a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10], a^2 + b^2 == c^2]
20:49:26 <Axman6> don't start writing shifts unless you know it's slower to use div
20:49:33 <EvanR> even if there werent any optimizations you should write your code clearer by default, unless you know its..
20:49:42 <horny-sama> now I am trying to improve it by taking user input to see if it is a right triangle or not
20:49:57 <pavonia> horny-sama: But that's not an Int, that an (infinte) list of 3-tuples
20:49:59 <shachaf> gamegoblin: The best way to be sure is to look at the generated code.
20:50:34 <pavonia> Well, rightTriangles is an infinite list
20:50:36 <shachaf> gamegoblin: I think you'll have better luck with quot than with div.
20:50:46 <horny-sama> pavonia: can't you plug in the Int input into the tuple?
20:51:12 <pavonia> I don't understand that question
20:52:12 <monochrom> I can't plug my shaver into my shampoo, or an Int into a tuple. because "wrong type" in both cases. "wrong type" is also known as "illogical".
20:52:21 <horny-sama> pavonia: in my case my tuples are into the format of (Int, Int, Int)
20:52:40 <horny-sama> and my user input is in a, b,c which are all Int
20:52:44 <pavonia> As far as I undestand you don't need any lists or tuples, but you only need to check the condition a^2 + b^2 == c^2 for your input values
20:52:45 <EvanR> :t \x -> (x,x,x)
20:52:46 <lambdabot> t -> (t, t, t)
20:52:50 <shachaf> gamegoblin: Unfortunately it looks like the code is slightly more complicated than a plain right shift.
20:53:04 <horny-sama> pavonia: that's what I am trying to do
20:53:06 <gamegoblin> shachaf: going to use shiftR then
20:53:15 <gamegoblin> shachaf: thanks for inspecting
20:53:21 <kadoban> horny-sama: What purpose does the list serve though?
20:53:25 <Welkin> horny-sama: this all comes back to the types. You must understand the types before you can write the program, otherwise you may as well sleep on your keyboard and hope that when you wake up the program has been written
20:53:27 <shachaf> gamegoblin: You should look at what happens with your actual code.
20:53:32 <pavonia> horny-sama: So just use "if a^2 + b^2 == c^2 then ... else ..."
20:53:40 <horny-sama> pavonia: but I want to ensure that a,b,c also follows the following conditions  c <- [1..] && b <- [1..c] && a <- [1..b]
20:54:03 <EvanR> Welkin: frightening how much production code has been written in the last few decades that way ;)
20:54:41 <pavonia> horny-sama: You need to express that in terms or <, <=, or >, >=
20:54:45 <horny-sama> does haskell enforce tabs like python
20:55:06 <pavonia> Then <- is not allowed in expressions
20:55:08 <Welkin> whitespace matters
20:55:09 <pavonia> *That
20:55:10 <R0b0t1`> yes, in certain structures
20:55:26 <kadoban> horny-sama: Have you done any of the haskell learning materials by any chance? They really help quite a bit
20:55:28 <monochrom> romantic people say: "it's better to have loved and broken up than to not have loved". they also say, when programming: "it's better to have run the program and crashed on a runtime type error than to not have run the program due to static type error".
20:55:45 <Pamelloes> Welkin: Wait, you mean falling asleep on your keyboard /isn't/ the most efficient way to generate production code? Personal experience begs to differ.
20:55:45 <horny-sama> kadoban: reading learnyouahaskell
20:55:53 <kadoban> Ah
20:55:56 <benzrf> horny-sama nooooo
20:56:12 <horny-sama> so haskell is like pythons when whitespaces matter
20:56:21 <monochrom> :)
20:56:37 <monochrom> python is more romantic than haskell
20:56:37 <kadoban> horny-sama: Yes
20:56:46 <EvanR> horny-sama: tabs are used to group syntax objects
20:56:50 <monochrom> and haskell is more romantic than agda
20:56:53 <R0b0t1`> horny-sama: https://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot and https://www.haskell.org/wikiupload/c/c6/ICMI45-paper-en.pdf
20:57:40 <kadoban> R0b0t1`: Are those really supposed to be appropriate learning materials?
20:58:16 <R0b0t1`> it depends.
20:58:53 <Axman6> horny-sama: pyhton uses whitespace like Haskell does, Haskell is quite a bit older than PYthon ;)
20:59:14 <horny-sama> Axman6: that is one of the things that I hate about python
20:59:15 <horny-sama> lol
20:59:34 <Axman6> it's great, makes for much cleaner and (imo) clearer code
20:59:50 <monochrom> use both whitespace and explicit {;}
20:59:58 <kadoban> horny-sama: Well, it's optional in haskell. If you really want you can use explicit {;} in haskell, but...nobody will have fun reading it.
21:00:05 <EvanR> horny-sama: you are free to write any of it instead using {, }, and ;. like C
21:00:18 <horny-sama> EvanR: cool
21:00:29 <EvanR> and when you format it to be at all readable, youll see they arent necessary
21:00:33 <R0b0t1`> kadoban: I do not like to assume, but he seems to be following along with snippets that kind of work. A more complete example that is slightly more confusing would have him slow down.
21:01:24 <R0b0t1`> but he started asking the right questions anyway, so :)
21:01:41 <kadoban> R0b0t1`: Confusing the crap out of someone seems like a bad way to teach them though.
21:02:25 <horny-sama> https://github.com/mr-fool/haskell/blob/master/rightTriangle/rightTriangle.hs <--- help?
21:02:48 <R0b0t1`> well, poor choice of words. offer an example which has more structure to explore and shows how the syntactical pieces fit together.
21:03:27 <pavonia> horny-sama: Remove the braces
21:03:56 <pavonia> Also, the type signature belongs to the let block
21:03:56 <horny-sama> pavonia: why? <EvanR> horny-sama: you are free to write any of it instead using {, }, and ;. like C
21:04:04 <Welkin> horny-sama: also, `checking` does not produce a String
21:04:13 <Welkin> it produces IO String
21:04:18 <Welkin> er
21:04:19 <horny-sama> Welkin: it returns a string?
21:04:23 <Welkin> it produces IO ()
21:04:34 <Welkin> :t putStrLn
21:04:35 <lambdabot> String -> IO ()
21:05:03 <horny-sama> checking :: Int -> Int -> Int -> I) () ?
21:05:07 <Rotaerk2> http://lpaste.net/118732   is there some way I can format this, maybe with the help of operators, to eliminate the ( )'s around the then and else cases
21:05:10 <Welkin> change putStrLn "my return string"
21:05:17 <pavonia> horny-sama: But you can't use braces where you did, just like you can't use braces within C's "e ? x : y" syntax (AfAIK)
21:05:20 <Welkin> to just "my return string"
21:05:44 <Welkin> then use putStrLn further down in the do-block on the return value of `checking`
21:06:11 <pavonia> Rotaerk2: You can use $ for the last pair
21:06:43 <Rotaerk2> pavonia: yea, still stuck with the first pair though
21:06:53 <horny-sama> in C I usually do void functionName(arg) { all the good shit}
21:07:07 <Welkin> () is like void
21:07:13 <Welkin> main :: IO ()
21:07:15 <adamse> Rotaerk2: easier to just embrace the ()'s, I've found that it leads to easier to edit code
21:07:20 <Welkin> main is a "void" function
21:07:26 <Rotaerk2> adamse: hmm, k
21:07:49 <EvanR> horny-sama: you mean void functionName(ArgType arg){ all the good shit }
21:08:01 <EvanR> in which case the haskell equivalent is ArgType -> IO ()
21:08:02 <Welkin> horny-sama: the way to program in haskell is to use pure functions whenever possible and keep side effects collected together (such as in main)
21:08:14 <horny-sama> EvanR: yes
21:08:26 <pavonia> Rotaerk2: Btw, in this specific example you don't need the first do
21:08:35 <horny-sama> Welkin: if I can't program in haskell then I am feeling the side effect :P
21:08:57 <Welkin> IO is a side effect
21:08:58 <Rotaerk2> pavonia, yea I just put it in there to try to get a more general formatting solution, for when I can't eliminate the do
21:09:13 <Rotaerk2> (in this case, I probably will, and then make it one line
21:09:54 <horny-sama> Welkin: the side effect I am feeling right now is I can't even write a simple program in haskell
21:10:37 <pavonia> For larger code blocks I'd probably move the do blocks to local variables to make it more readable
21:10:40 <Welkin> Rotaerk2: you can use a let expression to make it cleaner: ifM (pred) actionIfTrue actionifFalse
21:10:59 <lpaste> monochrom annotated “No title” with “I have a cunning plan” at http://lpaste.net/118732#a118733
21:11:04 <Rotaerk2> touche
21:11:08 <monochrom> Rotaerk2: I have a cunning plan. http://lpaste.net/118732#a118733
21:11:31 <Rotaerk2> haha
21:11:36 <Rotaerk2> so just go down to the basics
21:11:38 <glguy> monochrom: that looks too normal
21:11:46 <Welkin> horny-sama: that is because you are running around blind without thinking
21:11:54 <Rotaerk2> tempting
21:12:15 <Welkin> horny-sama: please read at least the first few chapters of LYAH
21:12:30 <horny-sama> I just finished chapter 2 of it
21:12:35 <horny-sama> and I still would not program :<
21:12:42 <Welkin> another good resource: https://github.com/bitemyapp/learnhaskell#yorgey-course---do-this-first-this-is-the-primary-way-i-recommend-being-introduced-to-haskell
21:13:28 <horny-sama> I guess I will read more before attempting this
21:13:31 <horny-sama> this is sucking
21:13:32 <R0b0t1`> horny-sama: what does "data Triangle = Triangle Int Int Int" mean?
21:13:35 <Welkin> horny-sama: it can take a while to learn the basics of haskell depending on what kind of programming you have done in the past -- especially if you need to break bad habits picked up from other languages
21:14:04 <horny-sama> R0b0t1`: no fucking clue
21:14:10 <Welkin> horny-sama: haskell is easiest to approach through the lens of math
21:14:12 <R0b0t1`> k you read but did not understand those pages
21:14:25 <Pamelloes> Welkin: Bad habits = using another porgramming language :P
21:14:29 <horny-sama> R0b0t1`: have not teach that in chapter 2
21:14:39 <horny-sama> Welkin: not into math
21:14:47 <Pamelloes> R0b0t1`: iirc that's chapter 6ish ;)
21:14:50 <Welkin> horny-sama: http://learnyouahaskell.com/types-and-typeclasses
21:14:55 <Rotaerk2> you can easily learn bad habits with haskell; just do everything in a do-block
21:14:58 <Welkin> if you don't know Types, you cannot do anything with haskell
21:15:00 <horny-sama> Welkin: that's chapter 3
21:15:05 <horny-sama> I am gonna read it
21:15:05 <R0b0t1`> oh oops
21:15:08 <Welkin> horny-sama: yes, it is the chapter on types
21:16:09 <Pamelloes> Rotaerk2: Well, there are times when a do block can be a lot easier to read then the alternative :P
21:16:17 <Pamelloes> *than
21:16:22 <Rotaerk2> I mean *everything*
21:16:29 <Pamelloes> Oh.
21:16:33 <Pamelloes> *everything*
21:16:37 <Rotaerk2> like... add x y = do return (x + y)
21:16:45 <Pamelloes> hahahahahahahahahahahahaha
21:16:48 <Axman6> no return
21:16:50 <Pamelloes> I'm too tired
21:16:52 <Axman6> just do
21:17:00 <Axman6> that's even more fun, because it confuses people more
21:17:01 <Welkin> Rotaerk2: well, when using parsec or opengl, most of the functions are giant do-blocks
21:17:07 <Pamelloes> Axman6: Is that even valid?
21:17:17 <Axman6> > let f a b = do if a > b then a else b in f 3 4
21:17:19 <lambdabot>  4
21:17:22 <srhb> Welkin: Most people write applicative style parsers when they can get away with it these days.
21:17:31 <Axman6> yes, because the desugaring happens before type checking
21:17:44 <Pamelloes> huh
21:18:01 <MP2E> yes, I know I use applicative parsers wherever i can
21:18:06 <MP2E> they just look so clean :)
21:18:09 <Axman6> and the rule for do <expr> is do <expr> -> <expr>
21:18:18 <Rotaerk2> if you do everything in an IO do-block, then it's basically like writing a "function" in procedural languages
21:18:29 <Rotaerk2> so you can pretend you're C# in haskell !1
21:20:06 <Pamelloes> Can you use applicative parsers in parsec and if so will switching to that change the types?
21:20:40 <srhb> All monads are also applicative, so no.
21:20:56 <kadoban> Pamelloes: You can use parsec in applicative style, sure. We saw earlier that you already were, didn't we? :)
21:21:20 <Pamelloes> kadoban: I don't think so.... Most of my parsec code is a bunch of annoying do blocks.
21:22:11 <Pamelloes> srhb: So switching means I won't have to change types? :D
21:22:13 <Welkin> srhb: only in ghc 7.10+
21:22:23 <kadoban> Pamelloes: I meant the <|> stuff, I guess that's Alternative not Applicative, but they're related.
21:22:33 <srhb> Welkin: No, they just make it a requirement there.
21:22:34 <Pamelloes> Ahhh
21:22:48 <MP2E> I actually meant applicative, but alternative is neat too, yes.
21:23:07 <Pamelloes> Well, if switching to Applicative style doesn't involve rewriting my unit tests, I'm all for it :D
21:23:20 <Pamelloes> stupid unit tests
21:24:10 <gfixler> people unit test haskell?
21:24:15 <gfixler> where can I learn more?
21:24:39 <Welkin> http://hackage.haskell.org/package/HUnit
21:24:42 <Pamelloes> Yeah......
21:24:42 <peddie> gfixler: https://github.com/kazu-yamamoto/unit-test-example/blob/master/markdown/en/tutorial.md
21:25:03 <Pamelloes> I hate my unit tests so much, but I would never get rid of them. My and my unit tests have an interesting relationship.
21:25:28 <gfixler> I really liked my Python unit tests - I went from a few bugs per week, to none for 2 years
21:25:33 <kadoban> Pamelloes: I can't seem to find the tutorial/blog-post I was thinking of about Parsec using Applicative...sorry.
21:26:10 <thang1> EvanR: Sorry I took forever to reply, that looks really fascinating
21:26:24 <EvanR> yer damn right ;)
21:26:28 <Pamelloes> kadoban: It doesn't really matter, I'm still working on transitioning to parsec so another rewrite is not going to be happening within a couple of days.
21:26:35 <kadoban> Pamelloes: I found this, but it's pretty short: http://kwangyulseo.com/2014/01/16/applicative-parsing/comment-page-1/
21:28:21 <gfixler> thanks Welkin and peddie
21:29:06 <jle`> where does the Flipped Applicative data type live?
21:29:50 <benzrf> jle`: whats a fliped aplicative
21:30:09 <benzrf> oh wait do you mean like
21:30:22 <benzrf> @let newtype Flip f a = Flip {unFlip :: f a}
21:30:25 <lambdabot>  Defined.
21:30:46 <benzrf> @let instance Functor f => Functor (Flip f) where fmap f (Flip x) = Flip (fmap f x)
21:30:47 <lambdabot>  Defined.
21:31:15 <thang1> EvanR: Actually, I can't find the specific spot where he lets the vim plugin write the program
21:31:30 <benzrf> @let instance Applicative f => Applicative (Flip f) where (Flip f) <*> (Flip x) = Flip (liftA2 (flip (<*>)) x f)
21:31:31 <lambdabot>  .L.hs:164:59:
21:31:31 <lambdabot>      Could not deduce (a ~ (a -> a0))
21:31:31 <lambdabot>      from the context (Functor (Flip f), Applicative f)
21:31:36 <benzrf> oh dang
21:31:47 <benzrf> @let instance Applicative f => Applicative (Flip f) where (Flip f) <*> (Flip x) = Flip (liftA2 (flip ($)) x f)
21:31:48 <lambdabot>  .L.hs:163:10: Warning:
21:31:48 <lambdabot>      No explicit implementation for
21:31:48 <lambdabot>        ‘pure’
21:31:59 <benzrf> @let instance Applicative f => Applicative (Flip f) where (Flip f) <*> (Flip x) = Flip (liftA2 (flip ($)) x f); pure = Flip . pure
21:32:00 <lambdabot>  Defined.
21:32:05 <EvanR> thang1: actually its not at the end. ill give you the time
21:32:12 <benzrf> jle`: that's in a library somewhere?
21:32:13 <Welkin> thang1: there was a video where the creator of idris showed an editor that wrote his program after he declared the type, leaving blank spaces for him to fill in additional information
21:32:47 <gfixler> @let (╯°□°）╯ = flip
21:32:47 <lambdabot>  Parse failed: Parse error: =
21:32:47 <EvanR> thang1: 24:14 is where it starts
21:32:49 <thang1> Welkin: Now that's cool. I don't think Haskell is that smart, though? Haskell's types seem limited, somewhat
21:32:56 <EvanR> Welkin: yeah im directing him to the juicy part
21:33:10 <kadoban> gfixler: Lol
21:33:13 <srhb> thang1: Compared to? :P
21:33:32 <EvanR> Welkin: well of a different video, the one with raichoo
21:34:33 <monochrom> gamegoblin, shachaf: x `div` 8 is compiled to a call to a procedure for div. this is probably because "what if x is negative" is a complicated story. but you should consider quot. x `quot` 8 is compiled to asm code for shift-right(x + (shift-right(x, 63) `bitwise-and` 7), 3). the extra expression is again because "what if x is negative", but in this case presumably simple enough to handle in situ.
21:34:51 * hackagebot wai-app-file-cgi 3.0.4 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-3.0.4 (KazuYamamoto)
21:35:01 <shachaf> monochrom: That's the code I saw.
21:35:21 <Welkin> EvanR: raichoo?
21:35:52 <Welkin> this guy? https://raichoo.github.io/
21:35:55 <EvanR> Welkin: https://www.youtube.com/watch?v=L8ktb0-GR0M
21:36:38 <monochrom> if x is Word instead of Int, things may be nicer.
21:36:59 <jle`> benzrf: yes i mean that
21:37:08 <thang1> EvanR: Ahh, saw the magic. That was definitely really cool :p
21:37:13 <jle`> benzrf: i remember seeing it somewhere
21:37:57 <rtpg> does anyone know the name of the paper that deduces definitions of functions from the types
21:38:03 <EvanR> thang1: later, after he adds tree shape, and fills out a few proofs of the tree structure
21:38:15 <mjrosenb> is there something like when/unless, but where the condition is *also* in the monad?
21:38:25 <mjrosenb> I guess this makes the most sense for IO
21:38:31 <thang1> srhb: You can define types in Idris that are more complicated than those in Haskell. Pretty sure haskell doesn't have dependent types?
21:38:32 <mjrosenb> and basically no sense otherwise.
21:39:00 <Welkin> isn't there a ghc extension for dependent types?
21:39:04 <srhb> thang1: I missed the rest of the conversation, so I just thought it was "compared to everything" statement. Yes, Idris has a much more powerful type system
21:39:16 <shachaf> mjrosenb: It makes sense for other monads too.
21:39:23 <EvanR> though, that doesnt necessarily mean the types are more complicated
21:39:30 <shachaf> mjrosenb: I've seen it under the name "whenM".
21:39:36 <pavonia> mjrosenb: There's the cond package
21:40:11 <Cale> Welkin: Not quite
21:40:33 <Cale> Welkin: If you put together all the GHC extensions, they sort of head in that direction.
21:40:34 <mjrosenb> shachaf: which monads? certainly not List or Maybe
21:40:38 <mjrosenb> maybe a parser?
21:40:57 <Cale> Welkin: But it's not really the same experience as using a dependently typed language
21:41:24 <Cale> You can sort of approximate some dependently typed programming though
21:42:11 <Lokathor> I'm gonna watch this raichoo video
21:42:17 <shachaf> mjrosenb: State?
21:42:33 <lpsmith> cwl, alpounet,  actually you *can* get the column name in postgresql-simple;  the trick is to define a FromField instance that does something with it,  using the "name" operator:  http://hackage.haskell.org/package/postgresql-simple-0.4.9.0/docs/Database-PostgreSQL-Simple-FromField.html#v:name
21:42:53 <thang1> It does mean that the types can carry more information in them, I think. Or that you can express things in the type structure that's not possible with Haskell
21:43:22 <thang1> (sorry that reply was slow. It was in reply to EvanR's statement)
21:43:46 <lpsmith> so basically, you are going to have something like    data FieldName a = FieldName (Maybe ByteString) a
21:44:11 <EvanR> im trying to use GADTs but i cant seem to find what extension i need to enable
21:44:19 <mjrosenb> shachaf: makes sense.
21:44:42 <lpsmith> Then   instance FromField a => FromField (FieldName a) where  fromField field mv = FieldName <$> name field <*> fromField field mv
21:45:09 <hao> rtpg: I don’t know much about papers, but what you’re describing sounds like what Idris and Coq does, since you can sometimes prove theorems (= inhabit types) without giving the proofs (= functions)
21:45:49 <benzrf> things that are fun and cool:
21:45:50 <rtpg> hmm, I was thinking of a specific paper
21:45:54 <benzrf> - the reverse state monad!!
21:46:26 <rtpg> for example, it starts off with finding that the only function that can inhabit (forall a. a->a) is id
21:47:18 <pingu> rtpg: theorems for free?
21:47:37 <pingu> otherwise actualy deducing definitions may have something to do with djinn
21:48:46 <benzrf> @let newtype RState s a = RState {runRState :: s -> (a, s)}
21:48:48 <lambdabot>  Defined.
21:48:54 <rtpg> I think I was thinking of theorems for free yea
21:48:56 <benzrf> @let deriving instance Functor (RState s)
21:48:57 <lambdabot>  Defined.
21:49:42 <thang1> pingu: Here's an example. With dependent types you could define a data type RInt :: Int -> * where   \n   RZ :: RInt 0    \n    RS  :: RInt n -> RInt (1 + n)
21:50:15 <thang1> So it allows types to call functions. But on the flip side, you can define a provably-correct form of addition of natural numbers just through types
21:50:31 <austingp_> a
21:50:55 <Lokathor> first Idris thought, "why are cons and has-type backwards?"
21:51:10 <EvanR> its backwards in haskell only ;)
21:52:00 <Lokathor> :P
21:52:23 <Welkin> I remember hearing (from one of the creators of haskell in a video) that it was because they thought they would be consing lists together more often than writing types
21:52:37 <EvanR> which is patently false ;)
21:52:43 <Welkin> but looking back, it should have been the other way around
21:53:01 <Welkin> :: for cons is a bit ugly though
21:53:11 <EvanR> otoh :: for types is a bit ugly
21:53:13 <Lokathor> yeah, i think that pattern matching would be worse with ::
21:53:14 <mjrosenb> Welkin: it works for sml.
21:54:00 <Lokathor> you usually only declare a type once per function, so having the bigger punctuation blob seems appropriate to that
21:54:04 <benzrf> whoah, what happened
21:54:12 <Welkin> idris confuses me because of the swapping of : and ::
21:54:23 <Welkin> I'll get used to it eventually though, especially if I want to use idris
21:54:40 <EvanR> Lokathor: well, with GADTs you put a lot of type sigs
21:54:58 <Welkin> (x :: xs) makes me think "x has type xs", before I realize xs cannot be a type
21:55:04 <Lokathor> mmmm, i'm still struggling with basic monad applications :P
21:55:25 <Welkin> and that it is aactually a pattern match
21:55:29 <Lokathor> i'm 12 minutes into this video, and the thing i'm seeing the most is that they're declaring types more often... no polymorphic types in Idris?
21:55:41 <benzrf> Lokathor: what
21:55:49 <MP2E> there are definitely polymorphic types in Idris >_>
21:55:53 <EvanR> you dont use forall to do polymorphism
21:56:01 <EvanR> you parameterize your function by a type
21:56:02 <Welkin> Lokathor: in his example for id : a -> a
21:56:09 <shachaf> Polymorphism wasn't yet discovered back when Idris was made.
21:56:12 <shachaf> It's like System F.
21:56:29 <MP2E> huh, i didn't know that
21:56:47 <Lokathor> his example for id says: id' : (a : Type) -> a ->   and then the definition is   id' t x = x
21:56:59 <EvanR> system F and dependent types are two branches in the lambda cube
21:57:04 <shachaf> The previous two statement was false.
21:57:15 <MP2E> oh ic
21:57:43 <benzrf> @let instance Applicative (RState s) where pure = RState . (,); RState sf <*> RState sx = RState go where go s = let (f, s'') = sf s'; (a, s') = sx s; in (f a, s'')
21:57:44 <lambdabot>  Defined.
21:57:48 <sm> evening all
21:58:21 <Welkin> benzrf: you've golfed enough holes tonight
21:58:27 <EvanR> Lokathor: you can think of forall a . a -> a being the same way in haskell, to use id you must provide some value (a type) for the a
21:58:36 <johnw> sm: heya!
21:58:49 <Lokathor> true, i guess i forget about the forall bits
21:58:58 <sm> hey there johnw
21:59:25 <EvanR> Lokathor: buts its all done behind the scenes, not under your control really
21:59:59 <Lokathor> i guess i prefer that as the default if it's possible to get the control back later
22:00:03 <Lokathor> "sensible defaults"
22:00:12 <EvanR> thats why idris has implicit parameters
22:00:18 <sm> is there a cross-platform way to get terminal width ? not necessarily requiring bash ?
22:00:25 <benzrf> @let instance Monad (RState s) where return = pure; RState sx >>= f = RState go where go s = let (a, s'') = sx s'; (b, s') = runRState (f a) s; in (b, s'')
22:00:27 <lambdabot>  Defined.
22:00:28 <Welkin> Lokathor: http://youtu.be/L8ktb0-GR0M?t=18m32s
22:00:38 <Lokathor> i'm gettin there
22:00:38 <benzrf> put THAT in yr pipe + smoke
22:00:40 <Welkin> Lokathor: he explains it right there
22:00:41 <Lokathor> i'm only at 15m
22:00:56 <Welkin> id' : a -> a
22:04:10 <sm> damn, got to go
22:04:25 <johnw> bye sm!
22:04:34 <Lokathor> okay i see now Welkin, but he wrote it differently that time
22:05:02 <johnw> EvanR: 23:54 you dont use forall to do polymorphism
22:05:09 <johnw> can you explain what you mean by that?
22:05:25 <EvanR> johnw: in idris, theres no forall keyword
22:05:50 <johnw> so universal quantification is always inferred for newly introduced type variables?
22:06:09 <benzrf> EvanR: really?
22:06:11 <EvanR> johnw: no, not universal
22:06:19 <benzrf> ah wait i see
22:06:24 <benzrf> johnw: it's just pi types
22:06:36 <benzrf> johnw: you take a type as a normal argument
22:06:38 <EvanR> sometimes it infers that the variable : Type
22:06:46 <benzrf> johnw: so id looks like
22:06:46 <johnw> benzrf: ah, thank you
22:06:51 <johnw> no, I get it now
22:06:52 <benzrf> (a : Type) -> a -> a
22:06:55 <benzrf> kk
22:07:02 <johnw> thanks!
22:07:05 <benzrf> np
22:07:12 <benzrf> johnw: of course that's what forall is in the first place...
22:07:19 <EvanR> when Type = * yes
22:07:23 <johnw> I'm used to Coq using "forall" as a syntactic way of saying "Here be variables"
22:07:28 <benzrf> johnw: oh sorry i forgot for a second there that you're a coq user :p
22:07:50 <Lokathor> so right now, these are all type declarations, and each function body is a proof of a declaration?
22:07:57 <EvanR> but the implicit variables might be type Nat or whatever
22:08:06 <EvanR> you dont normally have to spell it out
22:09:09 <johnw> Lokathor: providing an inhabitant of a type (e.g., a function body) witnesses the proof that such a type is inhabited (i.e., the declaration can be implemented)
22:09:48 <Lokathor> okay
22:09:52 <Lokathor> uhm
22:10:00 <johnw> depending on the type system you choose, your types can say interesting things
22:10:09 <Lokathor> hmm
22:10:16 <Lokathor> maybe he gets to this
22:10:24 <EvanR> and it doesnt have to be a function
22:11:51 <Lokathor> ah, of course, can't be a real language without both a vim mode and an emacs mode :3
22:12:00 <ab9rf> hehe
22:12:12 <ab9rf> emacs absorbs all
22:12:37 <benzrf> it hasnt absorbed vim yet
22:12:48 <johnw> benzrf: see "evil" mode :)
22:12:57 <benzrf> as if thats absorption
22:13:01 <horny-sama> thx guys
22:13:05 <horny-sama> I am heading to bed
22:13:07 <johnw> depends on what kind of vim user you are
22:13:11 <horny-sama> I guess I can't rush haskell
22:13:14 <johnw> anyway, avoiding the editor debate...
22:13:22 <johnw> horny-sama: no, you really can't
22:13:24 <Lokathor> oh this is cool
22:13:25 <Lokathor> okay
22:13:40 <horny-sama> prior programming experience does not really help much in terms of learning haskell
22:13:40 <johnw> horny-sama: you aren't learning a language, you're developing an awareness of new abstractions
22:13:48 <johnw> that takes time, and there is *no* shortcut
22:14:02 <horny-sama> johnw: but haskell is a programming language?
22:14:06 <johnw> it is
22:14:12 <johnw> but it's not just about making the computer do stuff
22:14:14 <horny-sama> so if I am learning haskell, I am learning a new language
22:14:23 <Lokathor> but Haskell is not a language that's like most other languages
22:14:29 <benzrf> horny-sama: yes, but you're learning considerably more than that
22:14:30 <johnw> it's about using types to express concepts
22:14:38 <horny-sama> isn't the purpose of programming is to make the computer do stuff
22:14:46 <Lokathor> c -> python -> java is all trivial cause they're all about the same abstraction level
22:15:03 <EvanR> haskell is one of the only on-the-market programming languages where "learning a language" is actually more than just figuring out the syntax
22:15:04 <johnw> horny-sama: that really depends on who you ask :)
22:15:28 <johnw> believe it or not, there are real life programming languages, many of whose programs are never executed
22:15:44 <johnw> the fact that they compile is all the information the author was looking for
22:15:58 <horny-sama> My current haskell learning experience = learning asm
22:16:01 <EvanR> compile to what ;)
22:16:08 <johnw> I mean, type check
22:16:11 <EvanR> hehe
22:16:17 <Lokathor> With haskell I mostly get told by the compiler that I did it wrong, and then I think about how to design things more accurately, or possibly better entirely.
22:16:20 <Welkin> assembly has no types
22:16:43 <EvanR> it probably should though
22:16:50 <Lokathor> probably yes
22:17:08 <horny-sama> asm is evil just like dr .evil
22:17:10 <johnw> http://www.cs.cornell.edu/talc/
22:17:14 <johnw> ^-- typed assembly language
22:17:19 <horny-sama> anyways I got to sleep
22:18:14 <Welkin> doesn't that go against the use case for assembly?
22:18:23 <EvanR> i bet it helps the use case
22:18:23 <Welkin> it is just a mapping of keywords to machine code
22:18:59 <EvanR> the more information you have about the program the more the assembler / compiler can do
22:19:12 <Welkin> and each architecture has its own instruction set
22:19:14 <platz> in that case then the program is already written (the compiler), you're just trying to find the right input so that it doesn't abnormally terminate
22:20:05 <Lokathor> Idris looks cool... but will it let me serve up data automatically over a socket? that's the task i've been stuck with lately
22:20:20 <Welkin> Lokathor: can it wash my cat and feed my socks?
22:20:34 <johnw> Lokathor: I would think Idris could do that
22:20:38 <EvanR> it has IO but its still a research curiosity
22:20:45 <johnw> it's aimed at effective systems programming
22:20:49 <EvanR> the whole project
22:20:49 <johnw> I don't know if it has a sockets library yet though
22:20:58 <EvanR> theres a network lib
22:22:58 <Axman6> johnw: LLVM is another example of typed ASM btw
22:23:14 <johnw> ah, true
22:24:56 <Lokathor> Welkin: it will wash your cat if your cat type checks properly
22:26:15 <Axman6> Welkin: you should take a closer look at LLVM to see how a slightly above assembly level language can make very good use of types
22:27:55 <Lokathor> in his tree example
22:28:08 <Lokathor> did the types determine if an element was in the tree?
22:28:20 <Lokathor> or would the execution do that?
22:28:26 <Lokathor> or are the types the executions..?
22:29:06 <EvanR> he wrote a type that said something is in the tree, and another that said nothing is in an empty tree
22:29:13 <EvanR> those are just propositions
22:29:52 <EvanR> you also write a type that said give a tree and a thing, its decidable whether or not its in the tree
22:29:59 <EvanR> he wrote*
22:30:14 <EvanR> the proof of that stands as an algorithm for getting the evidence
22:30:25 <EvanR> or evidence that its not there
22:30:41 <Lokathor> so the type system is also doing some of the execution?
22:30:54 <EvanR> not in that last case
22:31:09 <EvanR> unless you use that search function in a type
22:31:19 <EvanR> which he didnt
22:31:53 <Lokathor> so it *all* of his stuff doing stuff as types? Which part is the part that's executing something?
22:32:40 <EvanR> he didnt write any programs to use his code, but he could have use the search function to look for a thing in a tree at runtime
22:33:18 <EvanR> and the code he wrote that uses the fact that it is in there (which we dont know until runtime, generally) can be statically checked and can be sure its there
22:34:11 <amukiza> hi there. I need some help understanding this simple solution to problem. Problem  35 of haskell 99 questions. http://bit.ly/1KUFCHZ , the second last solution. Why do we Cons, the first prime with prime factors of (div n prime) ?
22:34:45 <Lokathor> EvanR: so we're staticly checking that we could check for if an element is in a tree at any time if we needed to?
22:35:58 <EvanR> Lokathor: and that its either really there, or it isnt
22:36:54 <Lokathor> as opposed to.. a system were we say we could check for an element but we *actually don't* know how to do that if asked to?
22:37:47 <Lokathor> I think i'm suffering from Blub paradox
22:38:05 <EvanR> the difference between that and the elem function for Data.Map, which returns a Bool, is that the algorithm produces proof one way or the other
22:38:56 <Lokathor> so.. Data.Map.elem might just always secretly return True or False and not tell us, but with Idris we can have a proof that it's doing the correct thing?
22:39:39 <johnw> not really, Lokathor
22:39:42 <EvanR> im not sure what the answer is as far as correctness goes
22:39:43 <johnw> bool is not an informative type
22:40:10 <shachaf> Lokathor: Bool isn't a very useful type and True and False aren't very useful values.
22:40:10 <johnw> you can prove that if you put in a given key, that asking for that key always return true
22:40:14 <EvanR> but the client code gets significant information that youd need if it really was in the tree, like where it is
22:40:48 <Lokathor> and it gets the location information as part of the type of the tree in question?
22:40:49 <shachaf> @google boolean blindness
22:40:49 <lambdabot> https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
22:41:00 <shachaf> elem can return a better type than Bool
22:41:53 <johnw> If you think about it, Bool is the same thing as a bit, and is equally as meaningful as just 0s and 1s.  You need to know the context to interpret the value, for it to have meaning.
22:43:08 <Lokathor> isn't the context the function that you called that got you that value?
22:43:38 <johnw> if you've proven things about that function, it can be
22:44:14 <johnw> but you'd need to carry that context around with the value
22:44:31 <johnw> this is better done by a type which conveys the meaning you intend
22:44:56 <Lokathor> so normally you'd do that by knowing how the function is supposed to work while you write the part that calls the function
22:45:02 <shachaf> You should read the article I linked to above.
22:45:06 <shachaf> It has an example.
22:45:12 <johnw> yes, that article is extremely valuable
22:45:18 <Lokathor> i'm trying to read it
22:45:45 <Lokathor> it's a little esoteric
22:45:52 <johnw> it may require a few reads
22:46:00 <shachaf> The article is good but it assumes that you either already know what it's talking about or that the ideas are floating around in your mind already.
22:46:30 <shachaf> Something more detailed could be written about the topic.
22:46:50 <EvanR> this is not really related to the discussion, but i stopped putting Bool in my SQL schemas, instead using strings such as "online" "offline" ;)
22:47:05 <Lokathor> a lot of these mathy articles assume that a person has a strong math background :/
22:47:45 <johnw> Lokathor: have you ever had the experience of talking to a person, asking several questions, and they just answer, "Yes", without saying exactly which of your questions they're saying yes to?  And then you feel forced to ask, "Yes what?"
22:48:16 <shachaf> I don't think that article assumes a strong math background.
22:48:19 <Lokathor> I have, but that's never struck me as a type system issue
22:48:28 <johnw> it's boolean blindness
22:48:39 <johnw> the answer carries no information beyond a single bit
22:49:01 <shachaf> It assumes a bit of an English background -- if you're not familiar with the word "provenance" you might assume it's related to the word "prove".
22:49:19 <Lokathor> never seen the word before in my life honestly
22:49:32 <johnw> provenance is the origin of something
22:50:13 <Lokathor> perhaps by "mathy" i did mean "technical in a way that reminds one of math but is not strictly speaking limited to mathematics"
22:50:35 <Lokathor> academic, is probably the word i wanted
22:51:33 <Lokathor> johnw: I've had the problem of boolean blindness in conversations, but only because conversations aren't sticking values strictly with requests; I've never had a boolean blindness problem when writing a program
22:51:47 <johnw> well, you've just not been aware of it then :)
22:51:49 <EvanR> i think using a lot of bools has direct practical problems in traditional programming settings
22:51:57 <EvanR> have you ever debugged a complex if statement condition
22:52:06 <EvanR> you get mixed up easily
22:52:23 <Lokathor> had to do that just the other day, had to split parts out and assign it to well named vars to make it make more sense
22:52:32 <johnw> or how about functions that return Nothing if they fail, and you compose several such functions together...
22:53:27 <EvanR> in haskell it appears in the form of ADT values such as A 3 True "yeah"
22:53:43 <EvanR> by itself it might not be obvious what the True is for
22:53:48 <EvanR> or if it matters
22:53:52 <johnw> in languages where you use types to build proofs, boolean blindless is immediately apparent
22:54:04 <Lokathor> I haven't really chained Maybe together much... though not knowing where your Nothing came from is a problem, yes.
22:54:44 <johnw> i.e., handing me a boolean value as an argument to my proof is like handing me nothing at all
22:55:26 <Lokathor> I suppose it comes down to never having worked with a type proof before
22:55:36 <johnw> in Haskell, you'll be doing it more and more
22:55:45 <johnw> or you can
22:55:52 <johnw> if you'd like your types to be more meaningful
22:56:17 <Lokathor> I'm mostly comfortable just having my IO monadic and not much more, at the moment
22:56:24 <johnw> I hear you
22:56:31 <johnw> it's a spectrum, which is cool
22:56:41 <johnw> it means that are always new directions to grow into when you're ready
22:57:28 <Lokathor> you know i wanted to do Precise Permissive FOV in haskell one of these days, learned yesterday that a fork of Lambdahack already had a complete implementation
22:57:30 <johnw> I certainly find that to be true, all the time
22:57:50 <kazagistar> "Number blindness" seems just as important in programming contexts... ie, you might have a number, but the programming language is unable to verify things like if it is a valid index and have to add overflow checks, or that it is the the index of the smallest item in the collection, or a number of other facts
22:58:03 <johnw> kazagistar: yes!
22:58:11 <EvanR> yeah keys, keys to what
22:58:15 <Lokathor> ahhhh, wait wait this did happen to me
22:58:16 <EvanR> to anything?
22:58:22 <johnw> kazagistar: in fact, every program is itself just a number :)
22:58:58 <johnw> Lokathor: oh?
22:58:59 <Lokathor> i was wondering if it'd be "normal" or "advisable" to have, for example in a game, a whole ton of typedef statements to make Int have a lot of subtypes for different ways the rules make numbers interact
22:59:36 <Lokathor> or Double or whatever, depending on the number of course
22:59:45 <johnw> I also use newtypes to enrich basic value types
22:59:46 <EvanR> in your haskell program you might have collections with keys to them, as the collection changes your keys become invalid. it probably happens that keys "should" never be used, though you cant prove that to a Data.Map and have ot handle Nothings anyway (with an error)
23:00:09 <EvanR> invalid keys should never be used*
23:00:26 <Lokathor> you mean you should never try to get an element based on a key that's not there?
23:00:51 <EvanR> it may be true in your mind that you will never use a key to something thats not there
23:00:53 <dramforever> Lokathor: I don't think that's customary
23:01:11 <EvanR> but you cant represent that with normal types
23:01:15 <Lokathor> dramforever: I figured it might end up seeming like overkill
23:01:39 <dramforever> In haskell we might do this
23:02:26 <dramforever> moveThing :: Thing -> Position -> Size -> IO ()
23:02:45 <dramforever> where Position and Size are just fancy names for (Int, Int)
23:02:55 <Lokathor> oh, yes, that's about what I was thinking
23:04:40 <dramforever> often name + type = all you need to know how to use a function
23:05:19 <Lokathor> "Although the notation invites confusion, the expression e=e’ is not a proposition stating that e and e’ are equal!"
23:05:31 <Lokathor> I've always thought this
23:05:51 <Lokathor> Are people confused over this?
23:05:55 <EvanR> e = e?
23:06:16 <Lokathor> no, the part about how it's not a proposal, it's a function call that you're evaluating
23:06:20 <AshyIsMe> it's a unicode '
23:06:26 <AshyIsMe> e = e'
23:06:40 <Lokathor> oh, yeah, sorry, the article isn't in ASCII i guess
23:07:19 <AshyIsMe> don't apologize, you did EvanR a favour, now he knows he needs to fix his irc client :P
23:07:30 <EvanR> i see the '
23:07:51 <tempay> I have a literal memory management headache, I'm hoping you guys have seen something like this before
23:07:51 <EvanR> i failed to parse all the quotes
23:07:59 <dfeuer> Ayep, the problem is *definitely* in arithmoi. Time to file a boog report.
23:08:19 <EvanR> arithmoi wouldnt build for me the other day
23:08:23 <EvanR> on osx
23:08:24 <kazagistar> if your "Position" is a type, it also makes it easier to change the representation across your program, a bonus benefit of making types match semantics, rather then underlying structure
23:08:40 <tempay> I'm doing some parsing with Attoparsec. I'm reading in a file as a lazy bytestring, and then I'm parsing it in successive chunks starting at the beginning. Each time I parse a chunk, I eat up part of the string, and I return the remaining part to parse the next chunk. My problem is that the part I parse never gets garbage collected, and the file is too big to sit in memory
23:08:50 <kazagistar> the disadvantage being some reuse might be lost, so you sometimes have to be careful about that
23:09:05 <tempay> I haven't had to deal with this before, are there some tricks? Short of cutting up the file in preprocessing
23:09:29 <dramforever> tempay: what do you mean by "and I return the remaining part to  parse the next chunk
23:09:32 <dramforever> "
23:10:08 <tempay> The function I do the parsing in returns a pair: the parsed structure and the part of the input that wasn't used
23:10:38 <dramforever> tempay: I don't think you need to do that
23:10:55 <dramforever> iirc there's a type called Result or something similar
23:11:18 <tempay> You're right, I could just pass in the whole input and have it try to parse all the chunks in a list
23:11:25 <dramforever> hmmm
23:11:28 <tempay> But that has the same issue, nothing gets collected
23:11:30 <dramforever> nope that's not what I mean
23:11:57 <dramforever> tempay: hackage.haskell.org/package/attoparsec-0.12.1.2/docs/Data-Attoparsec-ByteString.html#t:IResult
23:12:04 <dramforever> tempay: http://hackage.haskell.org/package/attoparsec-0.12.1.2/docs/Data-Attoparsec-ByteString.html#t:IResult
23:13:25 <tempay> Ah, yeah the Partial constructor might be more efficient
23:13:29 <tempay> I'll try that
23:13:30 <dramforever> no
23:13:34 <dramforever> that's not what I mean
23:13:42 <tempay> Which are you looking at?
23:13:47 <dramforever> tempay: if parse returned (Done remainingInput result) then you can use the result and parse again with remainingInput
23:14:21 <tempay> Yep, that's the current setup
23:14:52 * hackagebot basic-prelude 0.3.11 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.11 (MichaelSnoyman)
23:15:13 <kazagistar> tempay: to make it simpler and reduce confusion, can you post your driver code?
23:16:00 <dramforever> tempay: Ha! you must be using this: http://hackage.haskell.org/package/attoparsec-0.12.1.2/docs/Data-Attoparsec-ByteString-Lazy.html#t:IResult
23:16:40 <tempay> kazagistar: honestly in it's current state I'm not sure it'll reduce confusion.. I've been hacking at it for a while
23:17:05 <tempay> I am, yeah
23:18:12 <kazagistar> tempay: if your problem is holding on to previous chunks, maybe you are using too much backtracking/alternative?
23:19:41 <tempay> kazagistar: Yeah, I looked at the a bit - but the part of the string that should be collected has already returned from the parser
23:20:09 <tempay> kazagistar: I would have to be backtracking to before the parse even starts
23:20:31 <tempay> dramforever: is that not the right package?
23:21:25 <dramforever> tempay: ?
23:22:20 <tempay> dramforever: There's nothing wrong with Data.Attoparsec.ByteString.Lazy, right?
23:22:26 <dramforever> nothing wrong
23:23:38 <Kaidelong> http://nikita-volkov.github.io/record/ <- does this use of type level strings mean that Haskell has accidentally reimplemented OCaml style structural subtyping?
23:24:21 <tempay> are there general ways of forcing the garbage collector to clean something? I'm out of ideas, it seems like this should be a common issue
23:24:44 <kadoban> tempay: Can you boil what you're doing down to a testcase or something?
23:24:47 <dramforever> tempay: can you post the code?
23:25:02 <tempay> Okay, I'll go clean it up
23:25:55 <AshyIsMe> Kaidelong: i actually didnt realise the record types were so restricted by default
23:26:19 <AshyIsMe> the namespacing problem is horrible
23:26:38 <Kaidelong> Haskell's record and module systems are objectively pretty awful
23:27:13 <Kaidelong> its implementation of typeclasses also perhaps counts but they work well if you use them only for very abstract things with obvious implementations (like Functor)
23:28:01 <kazagistar> tempay: AttoParsec transcribes input to internal buffers. The only way any text would be stored in memory is if there was still some alternative branch that could backtrack all the way to that text, afaik
23:28:02 <dramforever> I agree. we can't even do instance Monad m => Functor f
23:28:07 <dfeuer> EvanR, you're the second person to mention build problems with arithmoi to me today. But this is not a build problem; it's a segfault.
23:28:17 <EvanR> oh
23:28:35 <dramforever> kazagistar: I think tempay already finished parsing
23:28:58 <dramforever> tempay has already got a (Done remaining result) back
23:29:45 <kazagistar> dramforever: could it be that the resulting data structure still has an lazy unevaluated reference to the buffer?
23:29:51 <dfeuer> EvanR, since I was screwing around with vectors, I thought for the longest time that it must be my fault, but eventually I narrowed it all the way down to arithmoi+hspec, and I'm confident it's not hspec.
23:30:25 <dramforever> kazagistar: maybe. tempay, that's why we need your code
23:30:28 <kazagistar> dramforever: like, maybe doing a deepseq or something could be a hack solution?
23:31:05 <dramforever> tempay: Why do you think that the string is still in memory?
23:32:23 <dramforever> tempay: like kazagistar said, maybe it's a thunk
23:32:32 <Kaidelong> is there any particular reason Haskell didn't adopt OCaml's structural subtyping?
23:32:47 <tempay> dramforever: I'm honestly not coming up with anything better than slow garbage collection, but I'm not familiar with this stuff
23:33:06 <tempay> dramforever: I don't see any remaining references
23:33:12 <tempay> dramforever: working on posting code
23:33:32 <dramforever> tempay: how about a heap profile?
23:33:49 <dramforever> I think real world haskell has a chapter about this
23:33:49 <srhb> "slow garbage collection" is very unlikely.
23:34:51 <tempay> much more likely is that I screwed up somewhere
23:34:57 <Lokathor> I thought that Monads were like a superset of Functors?
23:35:10 <dramforever> Lokathor: subset
23:35:26 <Lokathor> er, right, functors plus extra
23:35:42 <Lokathor> so can't you do Monad m => Functor f?
23:37:07 <dramforever> <interactive>:4:21:
23:37:08 <dramforever>     Illegal instance declaration for `Functor m'
23:37:08 <dramforever>       (All instance types must be of the form (T a1 ... an)
23:37:08 <dramforever>        where a1 ... an are *distinct type variables*,
23:37:08 <dramforever>        and each type variable appears at most once in the instance head.
23:37:10 <dramforever>        Use -XFlexibleInstances if you want to disable this.)
23:37:13 <dramforever>     In the instance declaration for `Functor m'
23:37:19 <dramforever> That came from instance Monad m => Functor m where fmap = liftM
23:37:36 <EvanR> Lokathor: you could implement fmap using the monad operations (if the monad operations werent implemented with fmap on its own type)
23:37:44 <EvanR> already
23:38:36 <Lokathor> oh, so it becomes a circular definition?
23:38:42 <dramforever> EvanR: we have to manually write instance Functor MyMonad where fmap = liftM
23:38:50 <dramforever> for every monad we define
23:39:18 <srhb> Which we can't, come 7.10
23:39:25 <srhb> (Or at least I assume so)
23:40:13 <shachaf> Sure we can.
23:40:17 <dramforever> sure we can
23:40:50 <shachaf> dramforever: (Please don't paste more than a couple of lines into this channel. Use hpaste.org.)
23:41:04 <dramforever> shachaf: sorry I'll do that next time
23:42:13 <srhb> How does that work then? I define a monad instance "first" and use its method in the related Applicative and Functor instances?
23:42:27 <shachaf> There's no order in Haskell.
23:42:36 <dramforever> srhb: it's okay
23:42:36 <srhb> I know.
23:42:47 <shachaf> It's the same as fmapDefault and foldMapDefault in Data.Traversable
23:42:49 <srhb> By first I mean I'm reusing methods from Monad.
23:42:51 <shachaf> And liftA in Control.Applicative
23:43:12 <inerkick> Hi, i'm trying to configure eclipse for Haskell. I am getting this error while installing kindly help http://lpaste.net/118741
23:43:37 <dramforever> instance Monad M where blahblah \n instance Functor M where fmap = liftM \n instance Applicative M where pure = return; (<*>) = ap
23:43:38 <srhb> inerkick: No error there.
23:43:44 <srhb> inerkick: --force-reinstalls if you want to.
23:43:54 <shachaf> srhb: Er, are you sure?
23:44:19 <srhb> That they want to? No. :P
23:44:23 <inerkick> meaning srhb . It gives option to automatically install when I open Eclipse. How to force install these
23:44:57 <srhb> inerkick: It looks like it's just the output of a cabal install foo command
23:45:16 <inerkick> ok. so what you suggest srhb
23:45:24 <dramforever> srhb: which eclipse runs
23:45:33 <Cale> I'm not sure what it is that Eclipse is trying to accomplish with whatever install it's doing, so it's hard to say what to recommend.
23:45:47 <dramforever> I mean, eclipse ran it and gave this output
23:45:49 <tempay> Okay, sorry this is not good code
23:45:50 <tempay> http://lpaste.net/118742
23:45:58 <srhb> You can try modyfying that command (or manually installing the packages it's trying to install) but beware of some of those version changes
23:46:01 <srhb> Particularly the one for text
23:46:29 <inerkick> how to force install those srhb
23:46:38 <srhb> cabal install polyparse, ...
23:47:51 <dramforever> tempay: maybe it's building up a huge Right value?
23:48:20 <inerkick> ok srhb
23:48:34 <dramforever> It's hard to tell if there will be an upcoming Left, so the program kept reading
23:48:36 <tempay> It's definitely possibly that the messages are actually too large, but I don't think it's dropping the input either
23:49:12 <inerkick> it says "requested packages are already installed:"
23:49:22 <dramforever> tempay: your program reads everything into memory, and then starts "save done"
23:49:41 <tempay> is there a way to make that lazy?
23:50:13 <dramforever> tempay: how important is the Either?
23:50:36 <dramforever> if we need error handling then we must put the intermediate results somewhere
23:52:19 <tempay> I see, I could just keep errors on a single parse basis and deal with them then
23:52:20 <dramforever> tempay: let me guess. your program is doing file -> bytestring -> [Message] -> ....
23:52:31 <tempay> and then write out messages as soon as I get them
23:52:50 <tempay> yeah, didn't occur to me to write them as I read them for some reason
23:53:40 <tempay> It's still surprising to me that the messages would be cause all of my memory issues, they're much smaller than the file
23:53:50 <dramforever> tempay: if you use Either your program will be stuck at the "-> [Message] ->" part, building up a whole list
23:54:01 <tempay> right
23:54:08 <dramforever> tempay: so heap profiling, maybe
23:54:32 <tempay> thanks dram
23:55:18 <dramforever> tempay: http://book.realworldhaskell.org/read/profiling-and-optimization.html section "Space Profiling"
23:55:56 <dramforever> look at the graph to see what is actually causing the leak
23:56:14 <dramforever> by leak I mean memory hog
23:57:24 <kazagistar> yeah, I remember early on in haskelling I had a nice exponential blowup memory problem, wish I had tried the profiling then
23:57:47 <ab9rf> usually when i've had things go memory-wild, it's been because i'm a moron
23:58:12 <dramforever> sadly I've got one before. the graph is just one big black box of words
23:58:20 <dramforever> Which means bytestrings
23:58:39 <dramforever> which is trival to notice
