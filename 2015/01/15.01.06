00:00:14 <dgomez> ReinH: sorry its a bit hard to follow along, I lose track of our earlier conversation.  f (g a ) -> a
00:00:16 <dgomez> ?
00:00:23 <ReinH> dgomez: don't worry about that
00:00:29 <ReinH> just worry about defining eps :: (e, e -> a) -> a
00:00:47 <ReinH> if I give you a value and a function for computing a result from a value, what can you do with them?
00:01:33 <dgomez> you can use the function on that value?
00:01:37 <ReinH> right, so write that :)
00:01:53 <ReinH> the argument to eps is a tuple, so you can pattern match
00:03:49 <ReinH> dgomez: how do you pattern match on a tuple?
00:03:52 <dgomez> ReinH not sure what pattern matching is all about yet.
00:04:09 <ReinH> You pattern match on constructors
00:04:16 <ReinH> a 2-tuples is constructed like (a,b)
00:04:19 <ReinH> so that's how you pattern match it
00:04:34 <ReinH> > let f (a,b) = a in f (1,2)
00:04:36 <lambdabot>  1
00:05:03 <ReinH> you can use the same thing to write eta
00:05:08 <ReinH> er eps
00:05:10 <ReinH> not eta
00:05:20 <crobbins> :t uncurry ($) . swap
00:05:20 <lambdabot> (b, b -> c) -> c
00:05:23 <ReinH> greek is... greek to me
00:05:37 <ReinH> crobbins: if you want to test your own answer, you can /msg lambdabot
00:06:13 <ReinH> otherwise please don't give people answers when the goal is for them to find their own
00:06:30 <crobbins> oops, sorry
00:06:30 <dgomez> ReinH: f (a) =
00:06:48 <dgomez> ReinH: sorry
00:06:48 <ReinH> dgomez: is (a) a tuple?
00:06:54 <dgomez> no
00:07:13 <ReinH> alright, try again :)
00:07:35 <breadmonster> ReinH, how does GHC store thunks?
00:07:46 <ReinH> breadmonster: in a heap
00:08:05 <breadmonster> Yeah, sure, but what's their representation?
00:08:18 <ReinH> breadmonster: http://web.mit.edu/~ezyang/Public/jfp-ghc-rts.pdf
00:08:25 <breadmonster> I have a spare PC, and I'm thinking of writing a library to pass on computations to it.
00:09:29 <calvinx> Is there a cabal command that allows me to automatically add an installed package name to the `build-depends` section in the .cabal file?
00:09:50 <ReinH> calvinx: haskell-mode does that for me in emacs, otherwise not afaik
00:10:10 <ReinH> dgomez: How about f (a,b) =
00:10:10 <calvinx> o nice. letâ€™s see if haskell mode does that in vim too.
00:10:15 <crobbins> calvinx: what you can try is copy your existing cabal file to a backup then try `cabal init`
00:10:19 <ReinH> calvinx: I don't think so :(
00:10:52 <calvinx> crobbins: so `cabal init` will attempt to find the dependencies?
00:10:56 <ReinH> dgomez: or in this case, eps (a,b) =
00:10:59 <crobbins> calvinx: i think so
00:11:03 <crobbins> iirc
00:11:27 <crobbins> in fact, i think it might not even blow away your current cabal file, but not sure on that.  make a copy just to be sure
00:11:39 <breadmonster> ReinH, whose paper is that?
00:11:50 <ReinH> breadmonster: ezyang's
00:12:07 <dgomez> ReinH eps (a, b) =      (e-> a)not sure I am following this as logically as I should be.
00:12:28 <ReinH> breadmonster: with at least some notes by SimonM
00:12:36 <ReinH> dgomez: well, recall that eps :: (e, e -> a) -> a
00:12:47 <ReinH> so if eps (a,b) = undefined then what are a and b?
00:12:54 <ReinH> more to the point, what are the types of a and b?
00:13:08 <breadmonster> ReinH, THE Simon Marlow?
00:13:14 <ReinH> breadmonster: yeah
00:13:14 <dgomez> ReinH: (e, e -> a) are the types.../
00:13:16 <dgomez> ?
00:13:58 <breadmonster> ReinH, Okay, cool, and where do I find Haskell source?
00:14:02 <ReinH> dgomez: hmm, let's change it to avoid mixing up types and values
00:14:03 <breadmonster> Or rather, GHC source?
00:14:03 <crobbins> dgomez: while you are right, i think ReinH is just trying to make sure that you get what the type of a and b are separately
00:14:13 <ReinH> breadmonster: https://github.com/ghc/ghc
00:14:25 <crobbins> maybe call the variables (x,y) instead of (a,b)
00:14:25 <ReinH> dgomez: let's change our names to avoid confusion
00:14:35 <dgomez> crobbins: i see, I have no problem with that. :)  thanks
00:14:40 <ReinH> eps (x,f) = ??? (since x is a value and f is a function)
00:14:40 <dgomez> ReinH: ok
00:15:00 <ReinH> and x :: e, f :: e -> a
00:15:29 <ReinH> you have an x and an f, what can you do with them?
00:16:11 <dgomez> ((e -> a)) a ?
00:16:21 <ReinH> dgomez: at the value level
00:16:30 <ReinH> you have a function f that takes an e, and you have an x of type e
00:17:32 <dgomez> ReinH: value level,  e -> e a ?
00:17:41 <ReinH> value level means f and x, not e and a
00:17:56 <ReinH> we're writing a definition here: eta (x,f) = ???
00:18:30 <ReinH> what do you do with functions?
00:18:59 <dgomez> pass a value x which is type e  ---> f (e)  ?
00:19:38 <ReinH> if the value is x, why would you say f e?
00:19:41 <zipper> is monad a subclass of applicative yet?
00:19:49 <ReinH> zipper: in 7.10
00:19:59 <ReinH> which has a release candidate
00:20:02 <dgomez> ReinH: nerves mostly: soo f(x)?
00:20:08 <ReinH> dgomez: in haskell?
00:20:27 <ReinH> application is f x
00:20:33 <vanila> breadmonster, what do you want to do
00:20:37 <ReinH> so eps (x,f) = f x
00:21:01 <breadmonster> vanila, Well, I'd like to write a library so that I can send computations over my local network to my other PC.
00:21:09 <ReinH> so that's a definition of eps
00:21:29 <zipper> ReinH: Oh I have 7.8. What do you mean by release candidate?
00:21:34 <Axman6> breadmonster: have you seen cloud haskell, and the new static pointers in GHC?
00:21:44 <breadmonster> Axman6, Nope, will have a look.
00:21:56 <ReinH> So now do the same thing for eta and see if the law shachaf mentioned before hods
00:22:05 <breadmonster> Axman6, Though tbh, I'd like to just do this as a first project, to get to grips with Haskell.
00:22:17 <ReinH> zipper: http://permalink.gmane.org/gmane.comp.lang.haskell.ghc.devel/7529
00:22:26 <vanila> breadmonster, well why odt you just send a .hs file and compile it on the other computer?
00:22:30 <ReinH> *holds
00:22:35 <dgomez> ReinH: mmm I'm sorry t took me long to get there.
00:22:40 <ReinH> dgomez: no worries
00:22:47 <dgomez> ReinH: what was eta's type?
00:23:04 <Axman6> breadmonster: fair enough. you won't be able to send code over the network, but you can run a client and server program which call each other
00:23:07 <ReinH> dgomez: that's for you to figure out :)
00:23:23 <breadmonster> vanila, That's no fun.
00:23:33 <Axman6> and horrible =)
00:23:34 <ReinH> eta :: (Functor f, Functor g) => a -> g (f a)
00:23:38 <ReinH> specialized to the same f and g as eps
00:23:43 <breadmonster> vanila, Basically, I want the second computer to run stuff in parallel with the first.
00:23:48 <dgomez> ReinH: oh i see. so I'm looking up the def from earlier which was what type of expression then?
00:23:52 <breadmonster> Axman6, Why can't I send code over the network?
00:24:11 <ReinH> You need to figure out the type of eta specialized to f ~ (,) e and g ~ (->) e
00:24:21 <ReinH> and then define a function of that type
00:24:26 <Axman6> breadmonster: we don't have any way to serialise haskell code to send it over the network. static pointers allow you to do something equivalent to that though
00:24:49 <ReinH> and then show that fmap eps . eta = id, and eps . fmap eta = id
00:24:56 <breadmonster> Axman6, well, code is saved as thunks, right?
00:25:04 <Axman6> breadmonster: thing about how you would serialise say the const function
00:25:15 <Axman6> thunks are something you don't have any access to
00:25:17 <zipper> ReinH: Thanks
00:25:20 <ReinH> zipper: np
00:25:32 <Axman6> they're a compiler detail
00:25:49 <breadmonster> Axman6, No, but if I can figure out how GHC serialises them, then you can send them over the internet.
00:26:08 <Axman6> ghc serialised code by producing executables :P
00:26:37 <ReinH> breadmonster: you would need to send over the entire contents of the heap so that the pointers match
00:26:52 <Axman6> thunks aren't some kind of AST that describe how to produce a value, they're basically pointers to code* which will produce the value when jumped to
00:27:03 <Axman6> (* grossly simplified)
00:27:11 <dgomez> ReinH: got it. let me try again.
00:27:16 <ReinH> Which is exactly why https://phabricator.haskell.org/rGHCfc45f32491313d2a44e72d8d59cdf95b1660189d is being added
00:27:19 <ReinH> breadmonster: ^
00:27:44 <ReinH> static forms that produce a static pointer that can be shared across machines
00:29:32 <ReinH> breadmonster: so if you're interested in serializing such things, you should start with the new static pointers stuff and the work currently using them
00:29:40 <breadmonster> Hmm, okay.
00:30:46 <ReinH> breadmonster: more motivation for static pointers can be found in the paper that ticket references, http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf
00:31:00 <Axman6> breadmonster: you can do something similar by defining some form of RPC using serialisable sum types
00:31:00 <breadmonster> ReinH, oh okay.
00:31:41 <breadmonster> Axman6 ReinH: thanks guys. I just wanted my first full blown project in GHC to be something that'll teach me a lot.
00:32:05 <breadmonster> And be useful at the same time :P
00:32:11 <Axman6> so: data RPCCalls = Put Int ByteString | Get Int | GetKeys | Delete Int
00:32:13 <Axman6> or something
00:32:19 <Axman6> there's lots of things you can do
00:32:56 <ReinH> breadmonster: you should talk to carter, he has a lot of good ideas for contributing to ghc
00:33:15 <breadmonster> carter,  May I PM?
00:33:27 <breadmonster> Axman6, Any ideas? Haskell is my first programming language.
00:33:38 <breadmonster> So this is a little ambitious lol
00:33:44 <ReinH> (he might not be awake)
00:34:10 <breadmonster> ReinH, can't get the SPJ paper you sent, MSFT research website is down for maintenance.
00:34:38 <dgomez> ReinH: this may be incorrect, but I think eta :: a -> (e -> a) and a function eta (x g) = g x if x has a type e ???
00:34:43 <Axman6> ReinH: that sounds unlikely, carter doesn't sleep
00:36:36 <ReinH> breadmonster: er, I literally pulled it up right before I pasted the link
00:36:41 <breadmonster> Interesting.
00:36:49 <breadmonster> Okay, it's working now.
00:37:01 <breadmonster> I got a down for maintenance error twice though.
00:37:20 <ReinH> dgomez: what happened to f?
00:37:23 <ReinH> there's no tuple tere
00:38:07 <Axman6> needs more tuple
00:38:14 <ReinH> breadmonster: huh
00:38:54 <breadmonster> Okay, so I can't write my own distributed computing library.
00:38:55 <dgomez> so eta :: a -> (e, e ->a) ??
00:38:57 <breadmonster> Shucks.
00:39:17 <vanila> you can do it
00:39:20 <dgomez> ReinH: so eta :: a -> (e, e ->a) ?? that includes f i believe
00:41:39 <ReinH> dgomez: that's a -> f (g a), not a -> g (f a)
00:41:52 <ReinH> work it out step by step
00:43:04 <dgomez> ReinH: ok ill try again. i wrote that out as g (f a ) in my calc. let me revise :)
00:43:44 <Axman6> breadmonster: well, you can using cloud haskell (there's still plenty of work you'd have to do to make something useful), and you'll learn a lot about plenty of things. it'll be a fun project
00:44:25 <Axman6> breadmonster: something that will probably never be easily possible with Haskell is being able to send arbitrary code to other machines to be run though
00:44:47 <breadmonster> Axman6, Once static pointers are implemented too?
00:45:16 <ReinH> right, the machines have to actually share the code pointed to
00:45:18 <Axman6> static pointers will allow you to run the same executable on multiple machine, and then you'll be able to run any function that that program has access to
00:48:40 <zipper> Hey I get this error on .hs files `BUG GMEString "usr/lib/ghc-7.8.4 /settings: openfile: does not exist (no such file or directory)"`
00:48:49 <zipper> but the said file does exist
00:49:14 <zipper> I get it in emacs by uh haskell-mode I think
00:53:14 <breadmonster> btw, why does GHC use Happy and not Parsec?
00:54:25 <dgomez> ReinH: eta :: a -> e -> (e,a) ?? if that's correct then let me define the function…. just want youth know I'm still here
00:54:50 <ReinH> yep, but not for much longer tonight
00:54:59 <ReinH> (I won't be)
00:55:09 <ReinH> that's correct though
00:56:08 <Axman6> breadmonster: probably because parsec has too many dependencies; compilers which bootstrap themselves can't rely on too many other libraries because some of the features needed to make the compiler might not be available to the compiler when they're needed
00:56:10 <Fuuzetsu> :t flip (,)
00:56:11 <lambdabot> b -> a -> (a, b)
00:56:16 <dgomez> ReinH: ok, let me define the function. sorry about my pace. but let me just say thank you for all your help tonight.
00:56:23 <ReinH> no worries :)
00:56:27 <zipper> Why would I get this error from emacs haskell-mode `BUG GMEString "usr/lib/ghc-7.8.4 /settings: openfile: does not exist (no such file or directory)"` if I know for sure that the file exists?
00:56:31 <Fuuzetsu> @djinn a -> e -> (e,a)
00:56:31 <lambdabot> f a b = (b, a)
00:56:34 <Fuuzetsu> lame
00:56:43 <Fuuzetsu> @. @pl @djinn a -> e -> (e,a)
00:56:43 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
00:56:52 <ReinH> @. pl djinn a -> e -> (e,a)
00:56:53 <lambdabot> f = flip (,)
00:57:43 <zipper>  /msg Fuuzetsu Hey, it's the haddock guy that was emailing you. I can't remember where I found that link to the haddock mailing list
00:57:53 <zipper> SMH
00:57:57 <zipper> Fuuzetsu: PM
00:58:36 <zipper> Tries to PM. Posts in channel
01:00:23 <dgomez> ReinH: eta (f a) = f a?? i think so. if you have to go pls do so. I understand a lot more
01:00:37 <solatis> zipper: looks like there is a leading / missing ?
01:00:46 * hackagebot sql-words 0.1.1.0 - Simple idea SQL keywords data constructor into OverloadedString  http://hackage.haskell.org/package/sql-words-0.1.1.0 (KeiHibino)
01:00:50 <ReinH> dgomez: You can't pattern match on (f a)
01:00:58 <ReinH> you have two arguments
01:01:05 <ReinH> so eta a b = ...
01:02:05 <zipper> `BUG GMEString "usr/lib/ghc-7.8.4 /settings: openfile: does not exist (no such file or directory)"`
01:02:07 <dgomez> eta a b = b a ??
01:02:23 <zipper> Anyone know anything about that? BUG GMEString error?
01:03:20 <ReinH> dgomez: you need to give a tuple
01:05:53 <dgomez> ReinH: sh*t well my thinking eta (a b) = b (e,a) but thats bc I see a as f
01:06:05 <dgomez> ReinH: I'm a bit scatterbrained at this point.
01:08:57 <thereisnoquarter> anybody here familiar with CIS194 to learn haskell?
01:09:39 <merijn> thereisnoquarter: I've heard it's good and the slides looked decent
01:09:58 <Axman6> probably plenty of people. #haskell-beginners will be full of such people too
01:10:17 <thereisnoquarter> hm, maybe i should ask there then
01:10:39 <thereisnoquarter> i was going to ask if 1) there is a place where we can look at solutions to see if there's a better way to do it, and 2) i feel like I am brute forcing the shit out of the problem i'm working on right now
01:10:44 <Axman6> if it's too quiet in there you can also ask here
01:11:25 <thereisnoquarter> i dont see a very 'haskellian' way to do this so i feel like i am trying to force an imperative solution into haskell
01:11:57 <zipper> thereisnoquarter: Hey
01:12:11 <zipper> thereisnoquarter: You mean cs194 by upenn?
01:12:14 <thereisnoquarter> yeah
01:12:23 <Axman6> feel free to share your code. we'll help you work your way to a better solution (hopefully!)
01:12:34 <zipper> thereisnoquarter: I have done it though horribly and in a hurry. Let me get you a link. Not totally completed too :(
01:13:08 <ReinH> dgomez: eta takes two values
01:13:11 <thereisnoquarter> @Axman6 cool, let me finish writing up this function and ill send it over
01:13:11 <lambdabot> Unknown command, try @list
01:13:15 <thereisnoquarter> @list
01:13:15 <lambdabot> What module?  Try @listmodules for some ideas.
01:13:20 <thereisnoquarter> @listmodules
01:13:20 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
01:13:33 <Axman6> @where lpaste
01:13:33 <lambdabot> http://lpaste.net/
01:13:38 <Axman6> put it there
01:13:41 <zipper> thereisnoquarter: https://github.com/urbanslug/cs194
01:13:46 <thereisnoquarter> cool
01:13:48 <thereisnoquarter> and thanks zipper
01:13:52 <thereisnoquarter> btw, how do i send a private message?
01:14:08 <thereisnoquarter> or is zipper just typing my name first and everyone can see it? (irc noob too)
01:14:19 <ddellacosta_> thereisnoquarter: yep.
01:14:20 <Axman6> the latter
01:14:28 <zipper> thereisnoquarter: This isn't a pm I am just typing your name
01:14:31 <thereisnoquarter> cool
01:14:51 <Axman6> thereisnoquarter: you can probably type zip<tab> to have names autocompleted
01:15:10 <Axman6> or axm<tab> for my name
01:15:15 <zipper> thereisnoquarter: You can get a PM by typing `/query <nick>` and looking for the newly opened buffer
01:15:30 <zipper> thereisnoquarter: Probably tmi for now
01:15:39 <dgomez> ReinH: I'm letting you down eta (a, b) = b a  ?? I don't understand pattern matching with tuples.
01:15:53 <ReinH> eta a b = (b,a)
01:16:10 <dgomez> :t flip (,)
01:16:11 <lambdabot> b -> a -> (a, b)
01:16:25 <dgomez> from what i saw earlier. oh...
01:16:38 <ReinH> @src (,)
01:16:38 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
01:17:26 <solatis> hmmm i'm looking for a cryptographically secure RandomGen for haskell
01:17:31 <Axman6> data (,) a b = (a,b) is the "source code" (but tuples aren't something you can define in haskell, only functionally equivalent things)
01:17:35 <thereisnoquarter> @where paste
01:17:35 <lambdabot> Haskell pastebin: http://lpaste.net/
01:17:40 <solatis> i know HsOpenSSL provides HsOpenSSL.Random
01:17:49 <dgomez> returns a tuple.. ReinH i see. I'm afraid I need a lot more practice.
01:17:50 <solatis> and i can get a bytestring out of it
01:18:01 <solatis> is it possible to seed a RNG with such a bytestring?
01:18:01 <Axman6> isn't there a crypto package that offers such stuff?
01:18:40 <Axman6> solatis: sure, if you can produce some kind of hash from the bytestring that might be a start*
01:18:44 <solatis> yes, Crypto.Random
01:18:53 * Axman6 is not a crypto expert
01:19:14 <solatis> but looking at the source, it's an implementation from scratch
01:19:28 <solatis> that is not enough for my level of trust
01:19:39 <solatis> so i'd rather seed with OpenSSL's RNG
01:20:32 <vanila> isn't openssl notoriously awful?
01:20:33 <dgomez> ReinH: I am going to log off tonight. but i can only express gratitude for you putting up with me in explaining eta and eps. thanks again...
01:20:51 <Axman6> not the algorithms, only everything else
01:20:59 <solatis> vanila: yes, but it has a LOT of eyes looking at it
01:21:21 <solatis> personally, i trust openssl more than some random haskell library that has last been updated in 2012
01:21:27 <Axman6> well, not really, and that's why shit like heartbleed came about
01:21:31 <solatis> yep
01:21:33 <solatis> true
01:21:43 <solatis> so until Saltine (libsodium) becomes stable, it's the best i have
01:21:58 <vanila> why not read /dev/random instead of openssl
01:22:06 <thereisnoquarter> Axman6: http://lpaste.net/117894
01:22:08 <Axman6> in many ways haskell is a safer place to start from. but some sidechannel attacks are more likely with haskell
01:22:32 <solatis> Axman6: what if the RNG is not good and can be predicted ?
01:22:36 <merijn> Which is why we should all move to NaCl where possible
01:22:40 <solatis> you are royally screwed
01:22:47 <merijn> solatis: That's what you use a CSPRNG for
01:23:19 <solatis> i know
01:23:23 <solatis> and there is Crypto.Random
01:23:32 <solatis> how many cryptography experts have audited that code ?
01:24:23 <Axman6> solatis: the crypto algorithms in OpenSSL are supposed to be very good, it's all the infrastructure around the algorithms that sucks (the reason the LibreSSL guys aren't starting from scratch if the the algos are good)
01:24:45 <solatis> i know, but i'm already stuck with OpenSSL for my RSA and AES algos
01:24:59 <solatis> so i might as well use it for random number generation as well
01:25:23 <solatis> and yes, i know, HsOpenSSL sucks, there are haskell alternatives, etc
01:25:47 * hackagebot sql-words 0.1.2.0 - Simple idea SQL keywords data constructor into OverloadedString  http://hackage.haskell.org/package/sql-words-0.1.2.0 (KeiHibino)
01:26:23 <solatis> but i hate to be the guy that writes a library that in the end is not secure because i'm relying on some haskell library that some guy wrote
01:26:29 <solatis> openssl has a *lot* of eyes looking at it
01:26:39 <Axman6> solatis: the crypto algos can easily be verified to be correct by then producing the same outputs for any input as another implementation.
01:26:46 <erikd> merijn: NaCl ?
01:26:49 <vanila> what are you writing?
01:26:50 <Axman6> (ok, shown, not proven)
01:27:02 <solatis> Axman6: right, but they all rely on C code
01:27:16 <solatis> haskell's RSA library? all C code with haskell wrapper
01:27:20 <merijn> erikd: The crypto library by djb and Tanja de Lange which libsodium wraps and packages nicely
01:27:21 <solatis> haskell's AES library? same
01:27:28 <solatis> yes
01:27:33 <erikd> merijn: thanks
01:27:34 <solatis> i'm waiting for Saltine to become safe to use
01:27:49 <solatis> i actually had a few colleges from Tanja
01:27:54 <solatis> they called her Turbo Tanja
01:27:55 <merijn> erikd: http://nacl.cr.yp.to/
01:28:12 <ReinH> solatis: that is generally how Vincent works.
01:28:19 <merijn> erikd: It has the ambitious goal of being a high performance, low resource, sidechannel free crypto library
01:28:24 <Axman6> thereisnoquarter: you're using a lot of unsafe functions to achieve your results there. you can do this a lot more elegantly and safely by using pattern matching
01:28:26 <solatis> she was writing *so* fast, you could either listen to what she's saying, or write what she's writing, but not both at the same time
01:28:41 <merijn> erikd: With the express goal of "programmers are stupid and should not make choices on cypher options"
01:29:05 <erikd> yes, reading up on it now. must say i agree with the goals
01:29:06 <ReinH> solatis: it's been pretty successful
01:29:14 <solatis> yeah i know
01:29:18 <thereisnoquarter> Axman6: i figured something like that was true
01:29:24 <solatis> but the Saltine guys specifically say: do not use this (yet)
01:29:34 <ReinH> solatis: (was referring to Vincent's stuff)
01:29:38 <thereisnoquarter> Axman6: ah, so this actually makes a lot of sense
01:29:41 <merijn> thereisnoquarter: Out of curiosity, why are you creating custom Maybe types for every type?
01:29:53 <ReinH> and "all C code with a Haskell wrapper" isn't quite accurate.
01:30:01 <thereisnoquarter> merijn: do you mean in my "where", or at the top?
01:30:04 <solatis> ReinH: ah
01:30:06 <solatis> i know
01:30:15 <thereisnoquarter> merijn: the MaybeInt and MaybeLogMessage stuff was provided with the exercise (its from CIS194)
01:30:17 <solatis> anyway, i trust he's really good at what he does
01:30:28 <merijn> thereisnoquarter: ah, ok
01:30:42 <thereisnoquarter> Axman6: let me give this another shot with pattern matching and send it your way
01:30:44 <merijn> I guess they haven't covered polymorphic types yet, then :)
01:30:50 <thereisnoquarter> Axman6: i think i know how to do this now
01:30:53 <Axman6> thereisnoquarter: go for it =)
01:30:53 <thereisnoquarter> merijn: nope
01:30:55 <ReinH> solatis: it's a fair amount of Haskell interfacing with low-level data structures and such in C
01:30:59 <solatis> but this is more a decision of "how many people will be angry at me if i rely on vincent's stuff if it has weaknesses, or how many people will be angry at me for relying on openssl?"
01:31:20 <vanila> what are you writing?
01:31:30 <solatis> yeah, i've studied his hs-cipher-aes library
01:31:49 <solatis> i'm writing a library for anonymous, accountable group communication
01:31:49 <ReinH> solatis: well, we're relying on his stuff...
01:32:01 <solatis> as in, it must be NSA-proof
01:32:08 <vanila> lol
01:32:09 <solatis> (ideally..)
01:32:23 <solatis> http://dedis.cs.yale.edu/dissent/papers/ccs10/
01:32:27 <solatis> i'm implementing that
01:33:14 <ReinH> solatis: then again, we work on the same team, so it's a bit easier to rely on his stuff...
01:33:47 <solatis> yeah, like i said, i'm waiting for the NaCl wrapper to become stable
01:33:55 <solatis> it's just so easy to f... up with OpenSSL
01:33:57 <merijn> solatis: Go yell at thoughtpolice ;)
01:34:12 <Lokathor> i'm looking at the help for the cabal tool, but it doesn't seem to have a way to show all my installed packages
01:34:14 <solatis> for example, in AES, it's very important to pad your input data
01:34:16 <Lokathor> is there such a thing?
01:34:18 <solatis> but OpenSSL doesn't do that
01:34:20 <merijn> Lokathor: "ghc-pkg list"
01:34:21 <solatis> HsOpenSSL neither
01:34:31 <solatis> so you must pad it yourself
01:34:40 <solatis> and it's *so* easy to look over that kind of stuff
01:34:44 <Lokathor> oh wonderful
01:35:03 <merijn> Lokathor: Note that cabal doesn't track installed packages and GHC only tracks installed libraries
01:35:18 <merijn> (cabal just asks GHC which libraries are installed)
01:35:20 <solatis> and you would think, "oh, but i'm using aes-256, so i must pad to 256/8 = 32 bytes, right ?
01:35:22 <solatis> but no...
01:35:26 <solatis> 256 is the keysize
01:35:30 <solatis> the block size is always 16 bytes
01:35:35 <solatis> (urgh x2)
01:35:47 <solatis> ok, i'm getting offtopic here
01:35:54 <thoughtpolice> the real crime there is just not using AES in CTR mode
01:36:04 <solatis> CBC mode is quite acceptable
01:37:15 <ReinH> thoughtpolice: o/
01:38:10 <solatis> but yeah, ideally i would use CTR :)
01:38:19 <thoughtpolice> anyway, i have a nacl binding that's in the works, if you're not wedded to RSA or AES
01:38:32 <thoughtpolice> well, it's been in the works for nearly 2 years at this point
01:38:43 <merijn> thoughtpolice: I know that feeling :p
01:39:00 <merijn> "I will finish this library up any day now...."
01:39:19 <thereisnoquarter> can you pattern-match in a case expression against a variable you define in a where clause?
01:39:30 <solatis> thereisnoquarter: you're refering to Saltine ?
01:39:33 <solatis> thoughtpolice:
01:39:34 <thereisnoquarter> in my case, i take a string, and i want to split it up into a list of words using "words"
01:39:39 <thereisnoquarter> nope im referring to myself
01:39:45 <thoughtpolice> no: https://github.com/thoughtpolice/hs-nacl
01:39:54 <solatis> ah, right
01:39:56 <thereisnoquarter> and then i want to pattern match against that list of words
01:40:02 <thereisnoquarter> should i just define a helper function?
01:40:05 <merijn> thereisnoquarter: I'm not quite sure what you mean by "pattern match against a variable defined in a where clause"?
01:40:05 <thoughtpolice> it's pretty complete, pretty close to done. but i haven't given it the final 10%
01:40:08 <solatis> well, i'm implementing a paper that specifically instructs me to use certain modes of encryption
01:40:30 <merijn> thereisnoquarter: lpaste a minimal example of what you mean?
01:40:32 <solatis> so i'm sticking with that, implementing a PoC, and then contact the researchers behind it
01:40:48 * hackagebot scientific 0.3.3.4 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.3.4 (BasVanDijk)
01:43:17 <gamegoblin> So I have an enum-like data type thatâ€™s like data Rank = One | Two | Three | Four | Five | Six | Seven | Eight
01:43:24 <thereisnoquarter> merijn: http://lpaste.net/117897
01:43:39 <gamegoblin> What do you think the best way is to be able to do something like One + Three and get Four?
01:43:58 <gamegoblin> Hard coding it for each possibility is pretty disgusting
01:44:09 <gamegoblin> maybe doing fromEnum and toEnum afterwards?
01:44:21 <gamegoblin> But Iâ€™m not sure if thatâ€™s the most elegant way
01:45:42 <ReinH> gamegoblin: what is Six + Six?
01:45:49 <vanila> yes you can derive Enum then implement a num instance using it
01:46:05 <vanila> it may be better to just write your own 'add' function rather than using Num typeclass though
01:46:13 <gamegoblin> ReinH: Iâ€™d be fine with either an error, Nothing, or overflowing to Four
01:46:23 <gamegoblin> vanila: Yeah I probably wouldnâ€™t use Num
01:46:33 <gamegoblin> vanila: mainly interested in the most elegant way to write the function, though
01:46:34 <vanila> @let data Rank = One | Two | Three | Four | Five | Six | Seven | Eight deriving Enum
01:46:36 <lambdabot>  Defined.
01:46:45 <vanila> :t fromEnum
01:46:45 <lambdabot> Enum a => a -> Int
01:46:46 <vanila> :t toEnum
01:46:47 <lambdabot> Enum a => Int -> a
01:46:53 <ReinH> gamegoblin: Num isn't appropriate, but fromEnum and toEnum would be useful
01:47:06 <vanila> > (\x y -> toEnum (fromEnum x + fromEnum y) :: Rank) Two Four
01:47:07 <lambdabot>  Not in scope: type constructor or class â€˜Rankâ€™Not in scope: data constructor...
01:47:10 <Hafydd> Why isn't Num appropriate?
01:47:13 <gamegoblin> Iâ€™d thought of fromEnum, adding, then toEnum
01:47:24 <gamegoblin> was just wondering if there was a better way
01:47:28 <vanila> @undef
01:47:29 <lambdabot> Undefined.
01:47:32 <vanila> @let data Rank = One | Two | Three | Four | Five | Six | Seven | Eight deriving Enum
01:47:33 <lambdabot>  Defined.
01:47:34 <vanila> > (\x y -> toEnum (fromEnum x + fromEnum y) :: Rank) Two Four
01:47:35 <lambdabot>  No instance for (GHC.Show.Show L.Rank)
01:47:35 <lambdabot>    arising from a use of â€˜M600141543418190835916004.show_M6001415434181908359...
01:47:38 <vanila> @undef
01:47:38 <lambdabot> Undefined.
01:47:42 <vanila> @let data Rank = One | Two | Three | Four | Five | Six | Seven | Eight deriving (Enum, Show)
01:47:43 <Hafydd> [1..8] represents the integers modulo 8 well enough.
01:47:43 <lambdabot>  Defined.
01:47:44 <vanila> > (\x y -> toEnum (fromEnum x + fromEnum y) :: Rank) Two Four
01:47:45 <lambdabot>  Five
01:47:58 <vanila> there's an example, you can see it's off by one though
01:48:04 <ReinH> Hafydd: sure, if that's what they represent
01:48:12 <vanila> something like:  add x y = toEnum (1 + fromEnum x + fromEnum y)
01:48:13 <vanila> might be good
01:48:18 <Hafydd> Which they clearly do.
01:48:37 <ReinH> No, they don't
01:48:52 <ReinH> It's a possible way to interpret the type
01:49:11 <Hafydd> <gamegoblin> ReinH: Iâ€™d be fine with either an error, Nothing, or overflowing to Four
01:49:22 <ReinH> Right, so one of those options is integers modulo 8
01:49:24 <ReinH> and 2 are not
01:49:26 <Hafydd> That means interpreting them as integers modulo 8 fits the intended usage.
01:49:32 * ReinH sighs
01:49:35 <ReinH> it fits an intended usage
01:49:54 <gamegoblin> To be super specific, itâ€™s for coordinates on a chess board
01:50:02 <ReinH> which are not numbers
01:50:07 <gamegoblin> and Iâ€™m trying to think of elegant ways to move around pieces by a particular offset
01:50:13 <vanila> gamegoblin, hope that helps
01:50:26 <vanila> you could just use (Int,Int) for coordinates on a chessboard though
01:50:27 <gamegoblin> so a knight might move (+2, +1)
01:50:40 <vanila> then it's just add (x,y) (dx,dy) = (x+dx,y+dy)
01:50:41 <gamegoblin> vanila: I could, but that would allow for illegal coordinates ;)
01:50:48 * hackagebot sql-words 0.1.3.0 - Simple idea SQL keywords data constructor into OverloadedString  http://hackage.haskell.org/package/sql-words-0.1.3.0 (KeiHibino)
01:50:52 <vanila> that doesn't matter
01:51:39 <merijn> You need to check for validity anyway
01:55:20 <Hafydd> Chess ranks are not numbers?! You have an artificially limited notion of what a number is.
01:55:39 <eXeC64> chess has ranks?
01:55:52 <Hafydd> Yes: ranks and files, for board coordinates.
01:55:59 <ReinH> you actually have a vector space, not a number system.
01:56:04 <eXeC64> Oh, right.
01:56:16 <Hafydd> A vector space?! What is the field of scalars?
01:56:31 <eXeC64> I always forget the coordinate system for chess.
01:56:39 <vanila> can we just not have this discussion :aP
01:56:48 <ReinH> Hafydd: the point being that you aren't performing scalar addition
01:56:51 <ReinH> so Num is not appropriate
01:58:08 <Hafydd> It doesn't make any sense to consider "vector" addition without an underlying notion of scalar addition.
01:58:22 <Hafydd> That is what is associated with the ranks and files, separately.
01:59:45 <Hafydd> Indeed, you must have multiplication as well, for scalars to be able to scale.
02:00:11 * ReinH sighs
02:00:49 * hackagebot threads 0.5.1.3 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.5.1.3 (BasVanDijk)
02:01:08 <Hafydd> The only thing Num has that aren't appropriate is perhaps abs and signum, but don't think that matters too much.
02:01:09 <ReinH> The point is that positions are points and moves are vectors
02:01:17 <Axman6> thereisnoquarter: how're you going?
02:01:28 <ReinH> so position + move is of the wrong type
02:02:06 <ReinH> in any event, this is easily the stupidest argument I've had in here in some time
02:02:31 <Hafydd> I wonder where the stupidity is coming from.
02:02:33 <sivteck> don't be rude!
02:02:37 * sivteck leaves
02:02:42 <ReinH> Hafydd: Ah, ad hominem. Clever.
02:03:09 <ReinH> Nice way to cap off a thoroughly pointless few minutes
02:08:43 <vanila> http://dev.stephendiehl.com/fun/ anyone seen this? looks like it could be fun
02:08:50 * vanila facepalm
02:09:00 <vanila> I didn't mean to pun
02:09:04 <Axman6> yep
02:09:07 <eXeC64> Would I be right in assuming that vector addition forms a monoid? You have an associative rule for combining the vectors (vector addition), and a unit vector (0,0). That's sufficient, no?
02:09:30 <Axman6> sure
02:09:43 <merijn> Time for some more constructive discussion: Can someone explain why you'd choose a parser generator like alex/happy over just handwriting a parser? Actually implementing a grammar seems like the least tricky bit of defining a language and parser generators seem to lack a lot of flexibility
02:09:46 <tdammers> eXeC64: yes, vector addition is as monoid
02:09:48 <ReinH> vanila: it's pretty great so far
02:09:57 <vanila> i want to read the much later chapters though..
02:09:59 <vanila> gotta wait a couple months
02:10:04 <ReinH> vanila: yeah :(
02:10:08 <Axman6> yeah :(
02:10:10 <Axman6> heh
02:10:20 <gamegoblin> Is there a safe way to do toEnum where if the Int is out of range you get Nothing?
02:10:23 <tdammers> (strictly speaking, (vector, vector addition, null vector) is a monoid
02:10:28 <gamegoblin> :t toEnum
02:10:29 <lambdabot> Enum a => Int -> a
02:10:36 <Axman6> it's a bit rough currently, found several typos I wanted to fix but the repo is basically empty
02:10:39 <gamegoblin> @hoogle Enum a => Int -> Maybe a
02:10:40 <lambdabot> Prelude toEnum :: Enum a => Int -> a
02:10:40 <lambdabot> Data.IntMap.Strict lookup :: Key -> IntMap a -> Maybe a
02:10:40 <lambdabot> Data.IntMap.Lazy lookup :: Key -> IntMap a -> Maybe a
02:10:52 <eXeC64> tdammers: is vector itself required as a constructor to create values in the monoid?
02:11:01 <eXeC64> Like pure/lift
02:11:34 <tdammers> nah, vector-the-type is the first element in the tuple, not vector-the-constructor
02:11:43 <eXeC64> Oh, right
02:12:10 <tdammers> type, operation, identity value
02:12:17 <eXeC64> I see, thanks.
02:12:56 <tdammers> it's a bit unfortunate that Haskell models this with a typeclass, so you can only define one Monoid instance per type
02:13:11 <tdammers> even though a type can be part of several monoids
02:13:29 <Axman6> I feel the newtype way of getting around that isn't that horrible though
02:13:43 <gamegoblin> I use this approach if needed: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
02:13:59 <tdammers> Axman6: it's pragmatic, it works, it's just not as beautiful as the mathematical definition
02:14:25 <eXeC64> So, when people say, "Monads are just a monoid in the category of endofunctors." The monoid is constructed from the monad's type, the bind operation is presumably the associative combining operation, so what is the unit value? return id?
02:14:28 <ReinH> eXeC64: Or mathematiclly, the monoid is (V, +,1), V a vector space, 1 the unit vector.
02:14:46 <merijn> Axman6: Scala shows us that multiple instances that can be selected either implicitly or explicitly is even more confusing
02:14:53 <ReinH> eXeC64: the monoidal product is join, the identity is return
02:15:04 <merijn> eXeC64: No, no. The specification talks about TYPES
02:15:12 <Hafydd> Even more strictly speaking, (vectors, vector addition) is a monoid, provided that the zero vector exists.
02:15:18 <merijn> eXeC64: Do you know the term KIND?
02:15:35 <Axman6> merijn: I guess Scala is useful then, it serves as a warning =)
02:15:39 <eXeC64> merijn: Yes, * and (* -> *)
02:15:45 <ReinH> I suppose that should be (V, +, 0) since this is an additive monoid
02:16:18 <tdammers> Hafydd: one could even argue that "vector addition" alone is enough to define the monoid, provided that the definition of "vector addition" specifies that it works on vectors
02:16:25 <ionum> hey, I have written two libraries ./lib1 and /lib2 now i want to write an executable in ./exe using both, how do i tell cabal where my libs are?
02:16:25 <merijn> eXeC64: Right, so Functor (the haskell class) is an endofunctor (functors map objects BETWEEN categories, endofunctors map objects to another object in the same category)
02:16:47 <ReinH> tdammers: it's enough to define a semigroup
02:17:09 <gamegoblin> ionum: did you use cabal-install on your libraries?
02:17:15 <Hafydd> tdammers: maybe, but that's very notationally convenient, because one might wish to write (U, +), where U is a subspace of V, and + is an operation on V.
02:17:34 <ReinH> (to *an* object, just so we're clear that the mapping can be an identity mapping)
02:17:36 <tdammers> Hafydd: yes, of course
02:17:39 <ionum> well inside a sandbox, i do not want to pollute my system
02:17:43 <merijn> eXeC64: So if one endofunctor is a type of kind "* -> *", then a monoid of endofunctors is some operation that takes TWO types of kind "* -> *" and returns a new thing of kind "* -> *"
02:17:57 <ReinH> tdammers: and actually, (V,+) is an abelian group
02:17:58 <ionum> can i share a sandbox ?
02:18:07 <eXeC64> merijn: So, would that just be composition?
02:18:12 <ionum> @gamegoblin
02:18:12 <lambdabot> Unknown command, try @list
02:18:13 <merijn> eXeC64: The monad operation join has type "m (m a) -> m a"
02:18:16 <Hafydd> The point is that the definition of a monoid doesn't need to be made with respect to a particular identity element.
02:18:25 <gamegoblin> ionum: not sure, never used sandboxes, best to ask someone else, sorry
02:18:29 <int-index> Is the `scc` function from Data.Graph guaranteed to return the strongly connected components topologically sorted? I ran a few examples in GHCi and it seems so, but it isn't mentioned in documentation. I wonder how safe it is to assume.
02:18:34 <tdammers> ReinH: yes, but commutativity is yet another concern :D
02:18:46 <ionum> well then i will just try, got an ideo
02:18:51 <ionum> *idea
02:19:03 <ionum> thanks
02:19:12 <merijn> eXeC64: But let's pretend we use the partially applied form on the type level (not something sensible in haskell, but still) we could write join as "m . m -> m" (here both sides of the arrow still need an extra argument and '.' is just composition)
02:19:31 <ReinH> merijn: you can make that sensible
02:19:45 <ionum> well gamegoblin, it is possible to share
02:19:50 <merijn> eXeC64: So join is a monoid that takes two endofunctors 'm' and returns another endofunctor
02:19:53 <tdammers> heh, lol... the wikipedia article on "semigroup" says that it's too technical, and that it should be rewritten such that non-experts can understand it, but without removing technical details
02:20:10 <ReinH> with Compose and Nat and type operators you can get m . m ~> m
02:20:17 <ionum> just doing cabal sandbox init inside ./ and then cabal install ./lib1 ./lib2 ./exe
02:20:22 <ionum> :)
02:20:23 <merijn> eXeC64: (I'm not too great at explaining this, but I hope that clarified it a little bit)
02:20:34 <eXeC64> merijn: Yes, thanks :)
02:20:47 <ReinH> f . g is Compose f g, f ~> g is Nat f g
02:20:48 <merijn> eXeC64: Also note that the statement "a monad is just a monoid in the category of endofunctors" is pretty much not very useful knowledge for writing haskell :p
02:22:09 <merijn> Speaking of categories...
02:22:22 <merijn> Are the CT illuminati around? I have a question...
02:22:29 <ReinH> hahaha
02:22:49 <poppingtonic> ReinH: hi, do you know of any instances in which Haskell's efficiency optimizations don't actually work out the way you'd expect?
02:22:55 <dbushenko> how using aeson I can decode a record if json does not contain all the fields?
02:23:00 <merijn> Specifically: If I have a graph with 1 vertex and a single edge from itself to itself. Does the free category of that graph have 1 identity morphism, an infinite number of identity morphisms (repeated composition of the one edge), or an infinite number of morphisms from the object to itself, one of which is the identity morphism?
02:23:14 <ReinH> poppingtonic: well, I struggle to predict what inline pragmas will do pretty regularly
02:23:24 <zipper> merijn: I have many questions on what I've been reading from this intro to category theory. I wish there was a place to ask these questions.
02:23:32 <zipper> merijn: This intro http://www.cs.nott.ac.uk/~gmh/cat.html
02:23:41 <ReinH> merijn: identity morphisms are unique up to unique isomorphism, right?
02:23:55 <mmmm> is there any way to avoid orphan instances when deriving typeable for promoted types (from DataKinds)
02:24:00 <merijn> ReinH: I don't know :(
02:24:29 <ReinH> merijn: This is because 1 is a terminal object
02:24:47 <ReinH> so the morphism 1 -> 1 must be unique
02:25:08 <ReinH> which iinm means that there is exactly one arrow (up to isomorphism), the identity arrow
02:25:42 <merijn> ReinH: That's what I thought, but the question added the reminder "it can be composed with itself!", so then I started doubting...
02:25:52 <ReinH> merijn: id . id = id
02:25:55 <merijn> ReinH: Also, hold on
02:26:04 <ReinH> it can be composed with itself, just not very interestingly
02:26:05 <merijn> Why must the morphism "1 -> 1" be unique?
02:26:20 <merijn> You can have infinitely different "1 -> 1" morphisms
02:26:41 <merijn> Which don't have to be the identity morphism
02:26:58 <poppingtonic> ReinH: are you referring to the OPTION_GHC pragma?
02:27:00 <merijn> Monoidal categories, for examples
02:27:10 <Cale> merijn: If 1 is a terminal object, then there is a unique arrow from any other object to it.
02:27:14 <Cale> Including itself
02:27:24 <poppingtonic> s/OPTION_GHC/OPTIONS_GHC
02:27:30 <merijn> Cale: My original question was about a free category from a graph
02:27:39 <merijn> Cale: (see 4 mins ago)
02:28:06 <Cale> Oh, okay
02:28:30 <poppingtonic> sorry...I found the documentation for the inline pragma
02:28:35 <Cale> merijn: The free category on that graph is the monoid category for the natural numbers.
02:28:45 <ReinH> Ah, right
02:28:59 <merijn> Cale: Right, so an infinite number of morphisms with 1 identity morphism?
02:29:00 <ReinH> so there are an infinite number of morphisms
02:29:02 <Cale> yes
02:29:05 <ReinH> yep, sorry
02:29:10 <merijn> ok :)
02:29:16 <merijn> Sanity is restored!
02:29:20 <ReinH> merijn: phew!
02:29:42 <merijn> Slowly beating Awodey at a rate of 1 page per month! :p
02:29:47 <ReinH> merijn: :)
02:31:17 <gamegoblin> :t maxBound
02:31:18 <lambdabot> Bounded a => a
02:31:42 <gamegoblin> so I have a function that takes (Bounded a, Enum a)
02:32:00 <gamegoblin> inside of the function I am trying to get the the int value of the maxBound of the type a
02:32:06 <gamegoblin> fromEnum maxBound
02:32:13 <gamegoblin> how can I tell the compiler I want that type?
02:32:30 <vanila> fromEnum (maxBound :: Rank)
02:32:44 <gamegoblin> vanila: but itâ€™s not Rank, itâ€™s `a`
02:33:11 <merijn> gamegoblin: Use ScopedTypeVariables
02:33:35 <vanila> eh??
02:34:02 <gamegoblin> ugh haskell.org loading slowly for me
02:34:35 <merijn> Something like: "foo :: forall a . (Bounded a, Enum a) => a -> Int; foo x = fromEnum (maxBound :: a)"
02:35:17 <gamegoblin> merijn: that did it
02:35:28 <merijn> Enabling ScopedTypeVariables + the explicit forall tells GHC that the 'a' annotation on maxBound is the "same" 'a' as in the top level type signature
02:35:33 <gamegoblin> Is there no other way to do it?
02:35:54 <merijn> By default type variable scopes are limited to the actual type signature
02:36:00 <merijn> Well, you might be able to use
02:36:02 <merijn> :t asTypeOf
02:36:03 <lambdabot> a -> a -> a
02:36:19 <gamegoblin> I could put an Eq a restriction, and then do a pointless == compare with the `a` argument, I guess, which would tell the compiler they are of the same time
02:36:20 <gamegoblin> type*
02:36:29 <merijn> Something like: "foo :: (Bounded a, Enum a) => a -> Int; foo x = fromEnum (maxBound `asTypeOf` x)"
02:36:32 <gamegoblin> or some other function which takes two arguments of the same type
02:36:36 <gamegoblin> ah
02:36:38 <gamegoblin> that does it
02:36:49 <merijn> gamegoblin: That's exactly the usecase asTypeOf exists for ;)
02:36:53 <vanila> why don't you just pass maxBound into foo
02:36:59 <gamegoblin> merijn: didnâ€™t know what it was
02:36:59 <vanila> then you can do foo x = fromEnum x
02:36:59 <merijn> vanila: Ambiguous type
02:37:24 <merijn> vanila: He didn't say he was actually passing any argument in at all
02:38:20 <merijn> gamegoblin: asTypeOf is basically "const with a different type signature" :)
02:38:33 <breadmonster> Guys, I might as well dig in now, umm, how do I learn Parsec?
02:38:46 <breadmonster> it's one of those monads that's escaped my understanding.
02:39:02 <gamegoblin> breadmonster I felt the same way a few months ago
02:39:06 <gamegoblin> I kept saying on this IRC
02:39:09 <mmmm> https://github.com/JakeWheat/intro_to_parsing looked good
02:39:14 <gamegoblin> "I JUST WANT A FREAKING REGULAR EXPRESSION"
02:39:16 <merijn> breadmonster: Real World Haskell has a pretty good chapter on it
02:39:23 <gamegoblin> and people on this IRC were like "JUST LEARN PARSEC"
02:39:26 <merijn> breadmonster: Fair warning, RWH was written when parsec was still version 2, so a lot of code snippets have bitrotted, but the high level overview of RWH is still very useful
02:39:26 <breadmonster> gamegoblin, I don't know how regex works.
02:39:50 <breadmonster> merijn, Okay, umm, I'd like something a *little* simpler? That's not making too much sense to me.
02:39:53 <merijn> breadmonster: IMO just reading the RWH chapter and then looking at the current docs should get you most of the way there
02:40:15 <breadmonster> merijn, because I've got RWH open.
02:40:15 <gamegoblin> breadmonster, Iâ€™ll PM you a tiny intro tutorial
02:41:13 <Haskellfant> iirc the nicta course has a chapter on parsing. once you have written a small parser library yourself using parsec becomes trivial
02:41:37 <breadmonster> Haskellfant, nicta?
02:42:10 <Haskellfant> https://github.com/NICTA/course/blob/master/src/Course/Parser.hs
02:42:28 <merijn> breadmonster: Maybe this example is also helpful? https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec
02:42:43 <Haskellfant> that's probably not the fastest way to learn how to use parsec, but if you want to learn how parser libraries are built which will allow you to use parsec, it's pretty good
02:42:46 <merijn> breadmonster: the basic design of attoparsec and parsec is so similar they might as well be identical
02:48:34 <breadmonster> merijn, what's the difference between Text.Parsec and Text.ParserCombinators.Parsec
02:51:31 <merijn> breadmonster: Hysterical raisins
02:51:56 <breadmonster> merijn, *historical reasons?
02:51:57 <merijn> The latter is the original definition, but recently people started being sensible and realising that long module hierarchies like that aren't sensible
02:52:13 <breadmonster> So they're equivalent?
02:52:25 <merijn> So basically, Text.Parsec is the right thing to use, but Text.ParserCombinators.Parsec reexports everything to avoid breaking old code
02:53:20 <merijn> breadmonster: Hysterical raisins is a common expression for when "historical reasons" are deemed a misfeature :)
02:53:43 <breadmonster> merijn, So which one should I use?
02:53:50 <merijn> Personally I feel like they should've gone all the way and just went with "Parsec" instead of "Text.Parsec"
02:53:54 <merijn> breadmonster: Text.Parsec
02:54:32 <merijn> Also note that Parsec predates the existence of Control.Applicative so it reexports a bunch of common operators from Applicative too (i.e. <|>, many, empty, etc.)
02:54:45 <merijn> Well, not reexports, I guess
02:54:51 <merijn> It defines it's own versions
02:55:10 <merijn> They do the exact same things, though
02:55:12 <breadmonster> merijn, Isn't Parsec an instance of Applicative?
02:55:24 <merijn> It is
02:55:51 * hackagebot repl-toolkit 0.2.0.0 - Toolkit for quickly whipping up command-line interfaces.  http://hackage.haskell.org/package/repl-toolkit-0.2.0.0 (jtapolczai)
02:56:15 <merijn> So confusingly you have "Text.Parsec.<|>" and "Control.Applicative.<|>" and they do the exact same thing, but aren't the same function >.>
02:57:15 <breadmonster> merijn, so can I import both, and use the Applicative instance?
02:57:42 <breadmonster> Because ghc should instantiate the types suitable to Parsec if it's an Applicative instance, right?
02:57:53 <merijn> breadmonster: Right
02:58:07 <breadmonster> Right in theory, will that work in practice?
02:58:16 <merijn> It *does* work
02:58:23 <breadmonster> Okay, excellent.
02:58:31 <merijn> The only thing to be careful with is that if you import both then GHC will complain about ambiguous names
02:58:42 <merijn> Which you can solve by hiding one of the two in the import statement
02:59:14 <merijn> "import Text.Parsec hiding ((<|>), many)", for example
03:00:51 * hackagebot rest-gen 0.16.1.4 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.16.1.4 (ErikHesselink)
03:01:50 <aloiscochard> hi all, I'm in the process of adding some of my lib/app into stackage...
03:01:57 <aloiscochard> but it is failing
03:02:03 <aloiscochard> because I think one of my dep is *not* in hackage
03:02:29 <aloiscochard> what should I do? add that lib with me as maintainer? or try to get in touch with the author...
03:02:41 <aloiscochard> what if he don't want to take care of putting his package on stackage?
03:02:47 <aloiscochard> (/cc @edwardk)
03:03:37 <sivteck> not in *stackage*?
03:07:32 <Taneb> aloiscochard, that doesn't prevent it, I think
03:07:55 <Taneb> Some libraries are only in stackage because they are a dependency of one that is
03:08:05 <Taneb> If you meant Hackage, of course, that's a different issue
03:08:18 <Taneb> aloiscochard, which library is the issue?
03:10:52 * hackagebot xmonad-screenshot 0.1.1.0 - Workspaces screenshooting utility for XMonad.  http://hackage.haskell.org/package/xmonad-screenshot-0.1.1.0 (DmitryMalikov)
03:12:08 <aloiscochard> Taneb: sivteck: I probably don't really understand the problem then: https://github.com/fpco/stackage/pull/400
03:12:16 <aloiscochard> if you have any idea, that would be greatly appreciated!
03:12:28 <aloiscochard> otherwise I'll get in touch with snoyberg
03:12:29 <aisqwe> how can i browse package sources with cabal?
03:13:12 <dcoutts_> aisqwe: you can "cabal get" to download an unpack a package tarball
03:13:18 <sivteck> you can get the source with cabal unpack <package>
03:13:34 <Taneb> aloiscochard, it looks like you are depending on older versions of a bunch of packages
03:14:16 <Taneb> aloiscochard, for example, you depend on machines 0.2.* but the version stackage has is 0.4.1
03:14:21 <Taneb> You see the issue there?
03:14:28 <aloiscochard> aaaaahh, now I understand
03:14:38 <Taneb> :)
03:14:42 <aloiscochard> thanks Taneb I had a hard time understanging the errors! :)
03:14:45 <aloiscochard> understanding*
03:14:59 <Taneb> Haha, no problem!
03:18:58 <aisqwe> where can i find the implementation of Monad in cabal packages?
03:21:01 <adamse_> aisqwe: in base
03:21:03 <adamse_> http://hackage.haskell.org/package/base-4.7.0.2/docs/Prelude.html#t:Monad
03:21:45 <purelazy> I'm trying to install hoogle locally, but get the following error. Any ideas? :o) http://lpaste.net/117903
03:22:07 <aisqwe> how can i find where an implementation is with cabal and hoogle?
03:22:47 <adamse_> aisqwe: as in hoogle on your command line?
03:23:14 <aisqwe> yes, like a combination of hoogle and cabal searches
03:23:14 <purelazy> I've just tried cabal install hoogle --force-reinstalls
03:24:18 <purelazy> But got this error http://lpaste.net/117903
03:24:20 <adamse_> aisqwe: hoogle -v Monad
03:25:30 <adamse_> aisqwe: but that doesn't tell you the package..
03:26:23 <winterland> take 5 [1..] ==> [1,2,3,4,5]
03:26:37 <aisqwe> i want a combination of command line tools to find the implementation of a class
03:27:07 <adamse_> aisqwe: :info Monad in GHCi tells you monad is defined in GHC.Base
03:27:41 <adamse_> then hoogle GHC.Base gives the package base
03:32:24 <d12frosted> I am the only one who gets errors while installing `alex` package using ghc-7.10.1-rc1 and cabal-1.23?
03:32:30 <d12frosted> am I *
03:32:36 <d12frosted> :D
03:35:51 <d12frosted> well and happy as well
03:37:44 <purelazy> Support is a bit quiet today
03:38:42 <d12frosted> in the morning I saw some good discussions
03:38:50 <d12frosted> http://lpaste.net/117904 - errors I see while installing alex
03:41:01 <cic> Let's say I have the following short html document: <p><br></p><p>foo</p> (= doc). If I do (in hxt) runX $ doc >> css "p" /> getText I only get ["foo"] but I would like to get ["", "foo"] instead. Is this possible somehow :(?
03:49:36 <quchen> purelazy: Don't use --force-reinstalls unless you *know* what you're doing. It's very likely to break things.
03:49:44 <quchen> Since Hoogle is a binary, you should always install it within a sandbox. cabal sandbox init && cabal install hoogle
03:49:44 <quchen> Then go to dist/bin, move the executable wherever you want, then delete the sandbox folder again.
03:49:44 <purelazy> quchen: Thanks
03:50:31 <purelazy> quchen: I'm trying to figure out why setOnException is not in scope
03:51:04 <purelazy> I hoogled (via browser) setOnException, and got nothing
03:55:54 * hackagebot rest-happstack 0.2.10.4 - Rest driver for Happstack.  http://hackage.haskell.org/package/rest-happstack-0.2.10.4 (AdamBergmark)
03:55:56 * hackagebot rest-gen 0.16.1.5 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.16.1.5 (AdamBergmark)
03:58:57 <quchen> purelazy: Some package seems to be out of date then.
03:59:03 <quchen> Did you try the sandbox thing?
04:00:05 <purelazy> I have never done a sandbox thing
04:00:24 <purelazy> quchen: I will do that
04:00:41 <purelazy> quchen: An exercise in itself :)
04:00:56 <merijn> d12frosted: Are you installing alex/happy from hackage?
04:01:16 <d12frosted> merijn: yes
04:01:32 <d12frosted> but I haven't seen any differences on github
04:02:15 <merijn> d12frosted: I think github just has mirrors which may not have the correct branches yet
04:02:41 <pavonia> :t when
04:02:42 <lambdabot> Monad m => Bool -> m () -> m ()
04:03:00 <merijn> You're getting an error related to AMP, which most likely means the version on hackage isn't 7.10 ready yet
04:03:04 <purelazy> quchen:
04:03:15 <breadmonster> After an excellent tutorial by gamegoblin, I don't get this: why doesn't parsec backtrack by default?
04:03:24 <pavonia> Has when been generalzied to Applicative?
04:03:24 <purelazy> $ cabal sandbox init
04:03:25 <purelazy> cabal: unrecognised command: sandbox (try --help)
04:04:01 <merijn> breadmonster: backtracking requires keeping parse state, which slows down parsing and costs memory
04:04:08 <d12frosted> merijn: yep, that's why I asked if someone know the version that is ready for new ghc
04:04:18 <merijn> d12frosted: Try asking in #ghc
04:04:20 <breadmonster> merijn, Then how is attoparsec so fast?
04:04:30 <d12frosted> merijn: also on freenode?
04:04:38 <merijn> breadmonster: I don't know the details, tbh :)
04:04:41 <merijn> d12frosted: Yeah
04:04:46 <breadmonster> Oh okay.
04:05:01 <merijn> breadmonster: Also, relevant article: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
04:05:12 <d12frosted> merijn: thank you for advice, I'll do so in few hours :D
04:06:07 <quchen> src/Sort.hs:45:1: Warning: Tab character â™¥
04:06:41 <quchen> Maybe LPaste should emit those warnings as well.
04:07:29 <merijn> quchen: They're now on by default in GHC
04:07:42 <quchen> "Now" as in "in the future"? :-)
04:08:32 <merijn> 7.10
04:08:53 <merijn> 7.10 has loads of goodies anyway :D
04:09:59 <d12frosted> merijn: i do like this warning aswell :d also, do you know, where can one read list of all new features in ghc 7.10?
04:10:27 <merijn> It's not done yet :p
04:10:45 <d12frosted> heh, I will stay turned then :D
04:11:27 <merijn> There's 7.10.1-notes.xml in docs/users_guide of the new 7.10 branch in git, but considering it still has a bunch of TODO notes and I only just got around to writing my own note I expect it's not very comprehensive atm :p
04:12:08 <merijn> d12frosted: The best way to stay in the loop is probably subscribing to ghc-devs@ and libraries@ and hanging out in #ghc
04:12:26 <d12frosted> yes, I understand, that atm it's not very comprehensive, but probably currently notes.xml is enough for me
04:12:47 <d12frosted> merijn: subscribing to emails, right?
04:13:13 <d12frosted> merijn: i am new in this comunity, so din't know all sources of information yet :D
04:14:07 <merijn> d12frosted: https://www.haskell.org/haskellwiki/Mailing_lists#Archives (the wiki is slow atm, though :()
04:14:27 <d12frosted> merijn: cool, thank you very much!
04:15:50 <echo-area> Hi, this is an example in Programming in Haskell: (xs++) = foldl (\ ys y -> ys ++ [y]) xs
04:15:54 * hackagebot cassava-conduit 0.2.0 - Conduit interface for cassava package  http://hackage.haskell.org/package/cassava-conduit-0.2.0 (domdere)
04:16:06 <mmmm> GHC complains about some incomplete pattern match, when I complete the pattern match, the code fails to compile
04:16:10 <mmmm> what to do to avoid the warning?
04:16:26 <breadmonster> merijn, Is lambdabot written in Haskell?
04:16:45 <echo-area> I can't see the base case of the recursion
04:16:52 <echo-area> When will it end?
04:17:34 <mmmm> the base case is xs
04:17:35 <AshyIsMe> breadmonster: yeah, the code is on hackage
04:17:38 <breadmonster> echo-area, foldl is defined in Haskell.
04:17:38 <mmmm> @src foldl
04:17:38 <lambdabot> foldl f z []     = z
04:17:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:17:55 <breadmonster> AshyIsMe, Oh okay, cool.
04:18:03 <merijn> mmmm: Can you show the code?
04:18:17 <vanila> > let (xs++) = foldl (\ ys y -> ys ++ [y]) xs in "abc" ++ "xyz"
04:18:18 <lambdabot>  <hint>:1:6: Parse error in pattern: xs ++
04:18:25 <breadmonster> How do you do a typedef in Haskell, btw?
04:18:25 <vanila> > let (xs++zs) = foldl (\ ys y -> ys ++ [y]) xs zs in "abc" ++ "xyz"
04:18:26 <lambdabot>  <hint>:1:6: Parse error in pattern: xs ++ zs
04:18:31 <vanila> > let xs++zs = foldl (\ ys y -> ys ++ [y]) xs zs in "abc" ++ "xyz"
04:18:35 <lambdabot>  mueval-core: Time limit exceeded
04:18:37 <vanila> t doesn't ever terminate
04:18:38 <merijn> breadmonster: "type Foo = Int"
04:18:42 <vanila> the definition is wrong in a few ways
04:18:44 <echo-area> But e.g. this seems never becoming simpler
04:18:52 <breadmonster> merijn, Okay, fine, I thought it was newtype.
04:18:53 <echo-area> e.g. [1, 2, 3] ++ [4]
04:18:55 <vanila> echo-area, you're right
04:18:56 <vanila> it never terminates
04:19:11 <merijn> breadmonster: newtype defines an *actual* new type that is not interchangeable
04:19:13 <vanila> xs ++ ys = foldr (:) ys xs
04:19:16 <vanila> you can define it this way instead
04:19:29 <mmmm> merijn: not something self contained sorry http://stackoverflow.com/a/27682570/3710751
04:19:32 <merijn> breadmonster: If you're familiar with C++11, newtype is more like an "enum class"
04:19:39 <breadmonster> Oh okay.
04:19:41 <breadmonster> Right.
04:19:48 <merijn> mmmm: Ah, you're doing my level of things :D
04:19:48 <mmmm> In the eval function at the end
04:19:50 <echo-area> vanila: I see.  And it is the other example in the previous section in the same book
04:20:11 <merijn> mmmm: The sad news is "you probably can't add it in a way that compiles"
04:20:23 <merijn> mmmm: GHC coverage checking is a bit shoddy when it comes to GADTs
04:20:28 <echo-area> Thank you guys
04:20:40 <merijn> mmmm: They're working on improving it, but I'm unsure whether that work is in 7.10 already or not
04:20:59 <mmmm> I figured as much
04:21:02 <mmmm> is that your answer btw?
04:21:45 <mmmm> anyway I'm amazed how great the answers are on stack overflow
04:22:09 <merijn> Not my answer, I don't really do much on stackoverflow :)
04:23:03 <merijn> mmmm: I just ran into a similar issue here http://lpaste.net/111788 if I remove the "_" case it complains about incomplete pattern, if you add the constructor it says is missing it refuses to compile, so I added a "_" and error to get it to shut up
04:25:57 <mmmm> merijn: ye, I just turned on -fno-warn-incomplete-patterns for that module
04:27:56 <mmmm> at least it's reassuring that the case is recognised as impossible
04:29:27 <merijn> mmmm: Yeah, it's just that the current type checker can only reall check whether a case is possible, not prove that a missing case can never happen
04:31:16 <mmmm> do you know what held up injective type families from 7.10?
04:33:29 <merijn> No idea, tbh :)
04:33:49 <merijn> I recommend consulting ghc-devs (or #ghc if anyone's around that knows the answer)
04:39:58 <quchen> merijn: The docs are also available online, not just in the docs folder: http://haskell.inf.elte.hu/docs/
04:40:46 <breadmonster> Guys, what is Haskell's grammar?
04:40:51 <breadmonster> LALR(1)?
04:40:53 <chrisdotcode> @grammar
04:40:53 <lambdabot> Unknown command, try @list
04:40:55 * hackagebot codex 0.2.1.2 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.2.1.2 (aloiscochard)
04:41:02 <chrisdotcode> @report
04:41:02 <lambdabot> Error: expected a Haskell expression or declaration
04:41:08 * chrisdotcode shrugs.
04:41:14 <merijn> breadmonster: Not sure? Consult the Report
05:04:41 <lpaste> mettekou pasted â€œSimple Timerâ€ at http://lpaste.net/5839190119755546624
05:05:15 <mettekou> Does anyone know why the code above would just exit without doing anything?
05:11:20 <clrnd> mettekou, first of all, you can import all those as C, youc an use the same name for several imports
05:14:26 <mettekou> clrnd: With the obvious risk of name clashes, of course. But I assume you suggest that because none of those modules actually introduce duplicate names?
05:15:12 <clrnd> oh sorry, I was just saying (I didn't know about it like a month ago), but yeah ofc, names shouldn't clash
05:15:59 <sternenseemann> Is there an implementation of elem (and elemIndex) that also works with Text?
05:17:04 <clrnd> mettekou, didn't threadDelay take time in like, microseconds?
05:17:48 <mettekou> clrnd: Oh, yeah, I see the problem... Microseconds, not milliseconds. I am an idiot. :P
05:18:18 <clrnd> still, it doesn't get to printing
05:20:58 <mettekou> clrnd: Yeah, I adjusted the code, now it waits, but doesn't seem to execute the IO action on my machine as well.
05:22:22 <mettekou> clrnd: Got it. You actually need to pass the action to repeatedStart.
05:22:39 <clrnd> mettekou, then what is the timer for?
05:23:22 <mettekou> clrnd: I have no idea, but it does require an IO () and a Delay to be constructed... Weird.
05:25:15 <clrnd> no idea, if you figure it out tell us
05:25:26 <mettekou> clrnd: Got it: repeatedStart is not necessary, the timer just starts when it is initialised.
05:25:44 <clrnd> oh and repeatedStart killed it?
05:25:57 * hackagebot unix-compat 0.4.1.4 - Portable POSIX-compatibility layer.  http://hackage.haskell.org/package/unix-compat-0.4.1.4 (JacobStanley)
05:26:24 <clrnd> good
05:26:28 <mettekou> clrnd: Killed it and restarted it, I guess. Since it still ran, being initialised twice.
05:30:57 * hackagebot generics-sop 0.1.1 - Generic Programming using True Sums of Products  http://hackage.haskell.org/package/generics-sop-0.1.1 (AndresLoeh)
06:14:10 <brainacid> hi
06:14:15 <pantsman> hi
06:14:17 <sternenseemann> why have elem and elemIndex disappeared from Data.Text? o.O
06:14:21 <sternenseemann> o/
06:20:59 * hackagebot bytes 0.14.1.3 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.14.1.3 (EdwardKmett)
06:22:02 <augustss_> yo
06:23:07 <EvanR> > 1.0f
06:23:08 <lambdabot>  Could not deduce (Debug.SimpleReflect.Expr.FromExpr a0)
06:23:08 <lambdabot>    arising from the ambiguity check for â€˜e_110â€™
06:23:08 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr a,
06:31:32 <augustss_> > f
06:31:33 <lambdabot>  No instance for (GHC.Show.Show a0)
06:31:33 <lambdabot>    arising from a use of â€˜M333093552686939775220266.show_M3330935526869397752...
06:31:33 <lambdabot>  The type variable â€˜a0â€™ is ambiguous
06:32:22 <augustss_> Enlightening
06:35:05 <clrnd> nice
06:35:13 <bergmark> i hope you learned something from it ;(
06:35:27 <bergmark> @type f
06:35:28 <lambdabot> FromExpr a => a
06:35:45 <augustss_> I learnt I should not use M333093552686939775220266.show_M3330935526869397752
06:36:00 * hackagebot toysolver 0.2.0 - Assorted decision procedures for SAT, Max-SAT, PB, MIP, etc  http://hackage.haskell.org/package/toysolver-0.2.0 (MasahiroSakai)
06:36:02 * hackagebot fclabels 2.0.2.1 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-2.0.2.1 (SebastiaanVisser)
06:36:27 <merijn> simple-reflect is not so bad
06:36:34 <k00mi> > f :: Expr
06:36:35 <lambdabot>  f
06:36:44 <merijn> Remember when we had num instance for functions? Caleskell FTW ;)
06:37:09 <k00mi> > foldr f z [a,b,c]
06:37:10 <lambdabot>  f a (f b (f c z))
06:37:21 <augustss_> @type (.)
06:37:22 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:38:04 <augustss_> I remember (.) being overloaded in a way I can't even remember.
06:38:11 <merijn> flip, I think?
06:38:14 <merijn> Or was it fmap
06:38:21 <clrnd> sternenseemann, http://hackage.haskell.org/package/text-1.2.0.3/docs/Data-Text.html#g:23 ?
06:43:37 <sternenseemann> clrnd: so these functions were replaced by findIndex?
06:45:37 <subfactorial> morning.  trying to get a recent haskell-platform going on RHEL 6.6.  Got as far as dl'ing a binary ghc and getting cabal installed from git.  The build of haskell-platform is dying in the middle though.  Any thoughts?  http://lpaste.net/117912
06:46:38 <merijn> subfactorial: Simple thought: Don't bother building haskell-platform
06:46:57 <merijn> IMO haskell-platform is only really useful when used as a binary bootstrapping package
06:47:13 <merijn> If you're compiling everything yourself you might as well just download/install libraries as you go
06:47:15 <subfactorial> is there a binary version for RHEL6?  The one I saw was compiled against glibc 2.14
06:47:52 <subfactorial> fair enough i suppose
06:48:10 <clrnd> sternenseemann, it's a valid design choice, I don't why they named them differently
06:48:25 <clrnd> it seems to be because they don't encourage to index Text values
06:48:51 <subfactorial> This is for a box that I'm admining and trying to provide some creature comforts for my users
06:49:34 <sternenseemann> clrnd: in earlier versions elem was there
06:49:54 <sternenseemann> clrnd: theoretically just Char -> Text -> Bool
06:50:10 <clrnd> sternenseemann, http://hackage.haskell.org/package/text-0.1/docs/Data-Text.html#18
06:50:22 <sternenseemann> clrnd: in that case I don't know why they've thrown it away
06:50:44 <clrnd> I don't know, try asking the maintainers
06:51:00 * hackagebot monad-journal 0.7 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.7 (DimitriSabadie)
06:51:47 <sternenseemann> clrnd: yep, also see http://hackage.haskell.org/package/text-0.1/docs/Data-Text.html#17
06:51:47 <sternenseemann> clrnd: yeah, I think I'll do so
06:51:59 <Aruro> > sin pi
06:52:00 <lambdabot>  1.2246467991473532e-16
06:52:29 <bergmark> sternenseemann: this is a long shot, but it may have been encoding related... just don't believe me :-)
06:52:57 <bergmark> s/encoding/normalization ??
06:54:05 <sternenseemann> bergmark: good question, but it would be extremly useful
06:54:19 <sternenseemann> bergmark: and you can write your own version of thos on top of findIndex
06:55:06 <clrnd> some utf things take more than one ""place""
06:55:14 <Aruro> > cos pi
06:55:15 <lambdabot>  -1.0
06:55:19 <clrnd> coÃ±o
06:55:33 <brainacid> nice papi
06:55:39 <Aruro> how do i store possible infinite user input?
06:55:42 <brainacid> yo entiendo eso clrnd
06:56:09 <clrnd> brainacid, sos de espaÃ±a?
06:56:46 <merijn> Aruro: It depends what you wanna do with it
06:57:05 <Aruro> i want to print it later on
06:57:17 <Aruro> lets say user is interminal
06:57:39 <Aruro> my question is how do i create infinite data structure?
06:57:45 <Aruro> which can be accessed later?
06:58:02 <Aruro> or the way it is done
06:58:08 <Aruro> in haskell
06:58:35 <merijn> That doesn't sound like it needs an infinite data structure at all? Just something like a list that gets updated as input comes in?
06:58:47 <Aruro> yes
06:59:05 <Aruro> but list can become arbitrary long?
06:59:57 <Aruro> if i define global a = [string]
07:00:27 <Aruro> how do i add elements to it which can be accessed from other functions?
07:01:04 <sternenseemann> Aruro: cons them in front of it
07:03:43 <Aruro> is it possible to create infinite record?
07:03:44 <johnw> Aruro: once you've defined 'a', it's meaning cannot be changed
07:03:51 <Aruro> so what do i do?
07:03:56 <johnw> if you want to mutate a list 'in place', you'd need to use an IORef or an MVar
07:04:09 <exio4> Aruro, what do you actually need?
07:04:11 <johnw> which then requires the IO monad to read/write
07:04:20 <clrnd> Aruro, mmm tell us what are you trying to achieve
07:04:36 <Aruro> i wish there is a tutorial which explains how to translate all basic imperative features to their haskell equivalents
07:04:49 <johnw> often you don't want to do that
07:04:50 <Aruro> i want to read user input
07:04:51 <clrnd> Aruro, you can but it's no ideal nor effective
07:04:57 <Aruro> record it and then return when needed
07:05:24 <clrnd> Aruro, you really can programm imperatively in haskell, but it'd be like programming functionally in C++, cumbersome and stupid
07:06:02 <Aruro> ok how do i make program which can remember arbitrary number of strings and there return a given one?
07:06:17 <Aruro> super banal algorithm
07:06:22 <clrnd> main = do { input <- readLn ; putStrLn "hello " ++ input }
07:06:27 <Aruro> no
07:06:31 <Aruro> i want to remember them
07:06:39 <Aruro> you just print them
07:06:55 <clrnd> you want to store them in some kind of structure and later retrieve them based on ... ?
07:06:59 <Aruro> yes!
07:07:02 <Aruro> precisely
07:07:27 <exio4> do you mean something like '' loop xs = do { input <- readLn; loop (input:xs); } '' ?
07:07:35 <clrnd> okay, what kind of performance do you need? do you need quick searching or quick storing? or both?
07:07:44 <johnw> Aruro: and why do you need to do that?
07:07:56 <johnw> you're asking us for a specific solution, without really telling us what the problem is
07:08:12 <johnw> and it sounds like your solution is not what you'd want to do in Haskell
07:08:21 <Aruro> what? why not?
07:08:28 <johnw> tell me what the problem is first
07:08:35 <johnw> then we discuss meaningfully which solution works best
07:08:38 <exio4> the XY problem
07:08:41 <Aruro> simple program which stores blocks of text in editor and then returns the one needed
07:08:58 <johnw> so you're writing an editor?
07:09:17 <Aruro> no
07:09:19 <Aruro> plugin
07:09:33 <ChristianS> Aruro: a mapping from strings to other strings?
07:09:42 <johnw> ah, so it must maintain a persistent state that the editor will have access to
07:09:49 <ChristianS> Aruro: you can use Data.Map.Strict for that
07:09:59 <Aruro> so there is no simple way to STORE infinite things in haskell , got it :)
07:10:08 <clrnd> Aruro, are you trying to learn haskell?
07:10:11 <johnw> you can store infinite things
07:10:18 <Aruro> infinite and mutable
07:10:20 <johnw> using a Data.Map, as ChristianS suggested
07:10:22 <Aruro> not just constant
07:10:25 <johnw> there is no bound on the number of keys
07:10:31 <Aruro> ty
07:10:35 <Aruro> i will check map
07:10:47 <clrnd> weird shit dog
07:11:01 * hackagebot taggy 0.1.3 - Efficient and simple HTML/XML parsing library  http://hackage.haskell.org/package/taggy-0.1.3 (AlpMestanogullari)
07:11:11 <johnw> so, there *is* a trick to make a truly global IORef in which you could store a map
07:11:22 <johnw> it's just such a bad thing to do, I even hestitate to explain how
07:11:30 <johnw> but an editor plugin could be a justified case
07:11:44 <Aruro> not justified case its plain banal
07:11:54 <johnw> well, banal Haskell code doesn't use mutation
07:11:55 <Aruro> no need to make high theory out of it
07:12:07 <johnw> why write this in Haskell at all then?
07:12:27 <Aruro> its not right answer
07:12:47 <Aruro> same as why writing anything in haskell
07:12:55 <Aruro> to use other features
07:13:01 <johnw> fair enough
07:13:03 <moop> :t (=<<)
07:13:03 <lambdabot> Monad m => (a -> m b) -> m a -> m b
07:13:07 <Aruro> only problem is infinite data construction
07:13:26 <merijn> >.>
07:13:26 <clrnd> Aruro, I'd say haskell is better at this than others actually
07:13:31 <johnw> Aruro: https://github.com/jwiegley/logging/blob/master/Control/Logging.hs#L82
07:13:33 <moop> :t (>>=)
07:13:34 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:13:36 <clrnd> > [5,8..]
07:13:38 <lambdabot>  [5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77,80...
07:13:40 <merijn> Why does pandoc install x509 tools? >.>
07:13:41 <johnw> that's an example of creating and mutating a "global variable"
07:13:46 <exio4> why not ReaderT + ioref?
07:13:47 <Aruro> yes logging ty
07:13:48 <ChristianS> Aruro: use Map.insert to extend your map, pretty simple
07:14:06 <ChristianS> Aruro: actually that constructs do you map, but that won't hurt you
07:14:30 <Aruro> yes i will look now into map :)
07:14:44 <Aruro> haskell really needs a book from basic to haskell
07:14:51 <Aruro> which explains all this banaly simple quesitons
07:14:55 <mmmm> what is the problem merijn?
07:16:14 <johnw> this isn't something one would explain to a beginner
07:16:18 <clrnd> regarding pandoc, what's the easy way to make it render markdown in sexy style?
07:16:29 <Aruro> i disagree strongly
07:16:30 <johnw> we'd talk isntead about using ReaderT to avoid what you've asked to do
07:16:31 <mmmm> from the command line or as a library?
07:16:37 <mmmm> clrnd
07:16:38 <Aruro> beginner as noone else needs a fast start
07:17:00 <clrnd> mmmm, command line, for now
07:17:08 <Aruro> and he needs to be confronted from start with all banal problems
07:17:08 <mmmm> what is your input format
07:17:18 <exio4> Aruro, you can think of mutable data as the ''goto'' of functional programming
07:17:23 <geekosaur> presumably because http-client-tls includes client certificate support
07:17:39 <clrnd> mmmm, pandoc thing.md > thoutg.html
07:17:54 <Aruro> repeat something 5 times? it will be replicateM_
07:18:10 <Aruro> but wait , monads are not for beginners :D
07:18:27 <Aruro> wrong approach. book hast so start from replicateM_ mapM_
07:18:30 <Aruro> and stuff like that
07:18:33 <mmmm> well.. that's the exact command
07:18:57 <clrnd> mmmm, oh, what do you need? the thing has classic markdown
07:19:32 <Aruro> who needs musings about lists if to write anything real i need to delve into replicateM_'s and IORefs
07:19:38 <johnw> pandoc can do multi-markdown
07:19:44 <merijn> geekosaur: Sure, but I find the need for a http-client embedded in pandoc a bit worrying :)
07:19:54 <johnw> Aruro: to write "real" things often does *not* require IORefs
07:20:03 <johnw> I use Haskell for all kinds of tasks, and IORefs are extremely rare in my code
07:20:07 <Aruro> i just showed you banal example
07:20:17 <johnw> I haven't yet written an editor plugin, granted
07:20:29 <johnw> but your banal example does not mean it is a common thing to need to do
07:20:31 <Aruro> u even agreed its a justified case :)
07:20:47 <johnw> I'm not arguing against your use of them, in this one case
07:20:48 <mmmm> I don't understand sorry, if you want to go from markdown to html then the verbose way is > pandoc -f markdown -t html in.md > out.html
07:21:07 <geekosaur> merijn, I don't, converting a web page by url seems an obvious fit for pandoc
07:21:10 <Aruro> storing and loggin is a pretty common thing
07:21:15 <Aruro> i would say
07:21:20 <johnw> storing we normally do with StateT
07:21:23 <johnw> logging with WriterT
07:21:37 <Aruro> thats what im talking about :)
07:21:40 <johnw> in the plugin case, you're doing logging on behalf of an external application that might call into your IO function at any time
07:21:47 <merijn> I have a sandbox compilation failing because of an installed library, that shouldn't be possible, no?
07:21:49 <Aruro> this stuff has to come first in all so called beginners books :)
07:21:49 <clrnd> mmmm, ohhhh you didn't understand my question! I wanted to know if it could add style to it, but I guess that's up to me
07:22:12 <johnw> Aruro: no, it shouldn't
07:22:22 <Aruro> yes it should
07:22:32 <clrnd> Aruro, you still can use a List as a store, which is how begginner books start
07:22:35 <johnw> then write such a book and the discussion will be moot
07:22:35 <Aruro> same as a trick to store variable in an extra argument
07:22:36 <mmmm> oh you want to add a stylesheet?
07:22:39 <tzaeru> that's a ton of people! anyway, is there a good, suggested Haskell tutorial that is up-to-date, doesn't have the tone of LYAHFGH and is more focused around practical cases (preferrably around general application cases instead of like calculating convolution in 5-dimensional space) and less on circle-wanking around academic topics in language metafeatures?
07:22:57 <clrnd> mmmm, yeah, I doubt pandoc does that too :P
07:22:59 <merijn> tzaeru: Bird's book?
07:22:59 <mmmm> merijn: http-client is used if you are translating html from the web
07:23:05 <mmmm> oh it does
07:23:16 <merijn> tzaeru: The CIS194 course (I hope I got that right from memory)
07:23:18 <merijn> NICTA
07:23:18 <sivteck> tzaeru, read RWH and check the latest docs :P
07:23:20 <Aruro> tzaeru supports my point :D
07:23:35 <merijn> tzaeru: Also: https://github.com/bitemyapp/learnhaskell
07:23:36 <Aruro> books has to be FAIR, its difficult to store, write yes
07:23:45 <Aruro> sorry better word honest
07:23:45 <clrnd> mmmm, it does?
07:23:58 <exio4> Aruro, that's why we have got monad transformers!
07:24:05 <mmmm> clrnd: pandoc -s --css=mycss.css in.md -o out.html
07:24:17 <clrnd> mmmm, oh I'm loving pandoc so much
07:24:42 <johnw> Aruro: teaching Haskell as "here are the disgusting tricks you can pull to write Haskell as if you were still using C" will not teach Haskell, but how to write C using Haskell syntax.  I'd rather teach Haskell.
07:24:44 <JonReed> tzaeru: The most practical reference I'm familiar with is here https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/Simple%20examples
07:24:52 <tzaeru> sivteck, I was given the impression that RWH is not particularly up-to-date and well-formed.
07:25:11 <Aruro> johnw you are almost correct
07:25:18 <Aruro> problem is in common operations
07:25:21 <johnw> then we almost agree!
07:25:39 <exio4> the problem is that you're writing code that isn't pure Haskell, so you need to adapt to the ''host'' language Aruro
07:25:41 <tzaeru> by the by, it's also helpful, when teaching someone, to not hiddenly refer to their favorite language's features as "disgusting"
07:25:44 <sivteck> tzaeru, it is not, but you can read it and check the latest docs, if you want to implement the examples
07:25:46 <geekosaur> because of course "common operations" can only be written in C...
07:25:51 <JonReed> tzaeru: Also there is a book Parrallel and Concurren Programming in Haskell, which is fairly new
07:26:27 <hasbero> Folks I'm trying to understand why we have a term for functors, applicatives and monads, when what they do is kind of trivial
07:26:42 <Aruro> :D
07:26:42 <hasbero> I meam we can come up with lots of names for lots of things this way
07:27:12 <exio4> hasbero, they're so trivial and common that not giving them a name would be also be silly!
07:27:45 <hasbero> exio4: point
07:27:55 <tzaeru> well, thanks, merijn, sivteck and JonReed. I'll get familiar with your suggestions, perform a few seppukus along the way, and emerge one language richer in the end after some 4, 5 years <3
07:28:33 <hasbero> exio4: why don't we have a name for a function that applies a list of functions to a value that isn't wrapped
07:28:42 <Aruro> {-# LANGUAGE OverloadedStrings #-}
07:28:42 <Aruro> import Text.Blaze.Svg11 ((!), mkPath, rotate, l, m)
07:28:42 <Aruro> import qualified Text.Blaze.Svg11 as S
07:28:42 <Aruro> import qualified Text.Blaze.Svg11.Attributes as A
07:28:42 <Aruro> import Text.Blaze.Svg.Renderer.String (renderSvg)
07:28:43 <Aruro> main :: IO ()
07:28:43 <Aruro> main = do
07:28:44 <Aruro>   let a = renderSvg svgDoc
07:28:44 <Aruro>   putStrLn a
07:28:45 <Aruro> svgDoc :: S.Svg
07:28:45 <Aruro> svgDoc = S.docTypeSvg ! A.version "1.1" ! A.width "150" ! A.height "100" ! A.viewbox "0 0 3 2" $ do
07:28:46 <Aruro>     S.g ! A.transform makeTransform $ do
07:28:46 <Aruro>       S.rect ! A.width "1" ! A.height "2" ! A.fill "#008d46"
07:28:47 <Aruro>       S.rect ! A.width "1" ! A.height "2" ! A.fill "#ffffff"
07:28:50 <sivteck> erm
07:28:58 <Aruro> bug
07:29:11 <ChristianS> Aruro: don't paste in the channel
07:29:14 <clrnd> mmmm, he, pandoc wants the css to be a URL, any way to pass it a file? also, what's -s for?
07:29:21 <glguy> Use a pastebin
07:29:22 <Aruro> its  not really useful not to tackle most common imperative practices in crash course
07:29:54 <mmmm> -s is for standalon
07:29:57 <mmmm> *standalone
07:30:08 <clrnd> yeah and what does that mean?
07:30:14 <Aruro> how to create for cycle? the answer is mapM_, how to create loop the answer it replicateM_
07:30:25 <Aruro> book should start like that
07:30:32 <Aruro> that was mistake
07:30:33 <clrnd> Aruro, you ahve forM and forA (c'mon ...)
07:30:40 <clrnd> have*
07:30:43 <mmmm> it adds the header and footer
07:30:47 <clrnd> mmmm, oh thanks
07:31:28 <mmmm> passing in a filepath should just work?
07:31:35 <hasbero> Don't you sometimes think functional programming abuses the stack for keeping track of state
07:31:48 <hasbero> I mean given it's the only kind of state
07:32:05 <Aruro> also function parameters
07:32:22 <tzaeru> does there exist a throughout documentation of how Haskell language features generally end up being mapped and executed on the hardware with GHC and what kind of ramifications they hold from the perspective of the native code execution?
07:32:44 <Aruro> its called System.F language :)
07:32:51 <Aruro> there is good post about it on stack
07:33:00 <clrnd> errr no
07:33:04 <clrnd> tzaeru, yes
07:33:12 <Aruro> no what?
07:33:14 <clrnd> tzaeru, you have the 2010 haskell report
07:33:36 <tzaeru> clrnd, thank you.
07:33:36 <clrnd> tzaeru, and I saw some cute ppt the other day, let me check
07:33:46 <augustss_> tzaeru: No
07:34:06 <johnw> hasbero: how does it "abuse the stack"?
07:34:35 <tzaeru> both "no" and "yes"? :(
07:34:46 <hasbero> jonnw, anything that needs state ends up on the stack. Say loops
07:34:47 <augustss_> tzaeru: The Haskell report does not say anything about operational semantics.
07:34:58 <johnw> hasbero: That is not true for Haskell
07:35:08 <johnw> it doesn't use a stack in the same way that, say, C uses a stack
07:35:13 <clrnd> tzaeru, I recall this one was nice: http://www.well-typed.com/blog/95/
07:35:20 <hasbero> Well but ostensibly it's the stack isn't it
07:35:22 <augustss_> tzaeru: Your best bet is to read one of the two books Simon PJ has written about implementation.
07:35:23 <hasbero> Even if it's optimized
07:35:26 <johnw> hmmm?
07:35:37 <Aruro> so general approach to storing things was - "use C!" am i correct? :)
07:35:57 <johnw> hasbero: I'm not quite clear on what you're really saying
07:36:05 <mettekou> Does the gtk package (Gtk2Hs) provide a way to update a Widget inside a Table through a callback bound to another control?
07:36:34 <hodapp> hasbero: er, yeah, you're not making a ton of sense.
07:36:37 <tzaeru> clrnd, mh, ye, not quite as low level as I was interested in, but thank you regardless. those look useful.
07:36:41 <augustss_> tzaeru: The blog posts clrnd referred to are good too.  As are some blog posts by ezyang.
07:37:04 <tzaeru> the blog post is a bit closer ya
07:37:39 <hodapp> hasbero: 'ostensible' stack doesn't really mean anything, unless perhaps it's a stack-based language.
07:38:13 <tzaeru> ..it's a little easier me to build mental images around the meaning and purpose of certain paradigms and functionalities if I am aware of how they map to being executed on much lower-level
07:38:25 <ChristianS> Aruro: you are not correct, why do you ask?
07:38:32 <tzaeru> i.e. approaching it from the perspective of the computer instead of from the perspective of real world case or language theory.
07:39:17 <clrnd> tzaeru, ohhh, well I was like that too, bue when you encounter big enough abstractions, that method falls useless
07:39:30 <tzaeru> it eventually does, sure ^^
07:39:43 <hodapp> tzaeru: Certain kinds of abstractions are completely incomprehensible from the point of view of a specific implementation, ignoring the interface.
07:39:50 <hodapp> tzaeru: That's why they're abstractions.
07:40:02 <Aruro> how does data.map store stuff?
07:40:15 <johnw> Aruro: it's a balanced binary tree
07:40:32 <augustss_> Aruro: Red-black tree, I think.
07:40:33 <tzaeru> usually there are plenty of core features and subparts of those abstractions that can be mapped relatively painlessly on low-level operations, though
07:40:47 <tzaeru> I'm quite ok with -everything- not being so.
07:40:57 <clrnd> I don't know crap about haskell, but I know that when I'm using scotty's simple ScottyM Monad, I imagine there are like 5000 "function calls" (which may or may not be optimized to only 2) between a liftIO . putStrLn and actual hardware
07:41:54 <clrnd> in the end, it works fast as hell, and I only need to think in types, that's sexy to me
07:42:02 <johnw> clrnd: I think there are incredibly few, it mainly boils down to a call to write() on the STDOUT file handle
07:42:25 <clrnd> me too, but if you desugar code, you end up with oone really damn line, right?
07:42:35 <augustss_> Yep
07:42:35 <johnw> hmm?
07:42:37 <clrnd> like, every (=<<) and fmap
07:42:52 <hodapp> tzaeru: that's incidental to an abstraction, though, because it's an abstraction.
07:43:05 <johnw> I want to say yes, but fear what that commits me to
07:43:56 <exio4> tzaeru, if you consider systemf as the "low-level" language, it could kind of work
07:44:00 <Aruro> i mean how does insert in Data.Map works?
07:44:07 <augustss_> tzaeru: I think it's good to have a basic understanding of how core Haskell (i.e., lambda calculus + case) is executed.  But it's not necessary.
07:44:18 <johnw> Aruro: you mean, how does a red-black tree insert a new node and keep the tree balanced?
07:44:23 <clrnd> I think he wanted to know how it becomes a system call
07:44:24 <Aruro> yes
07:44:28 <hodapp> there appears to be a lot of stuff with how GHC actually compiles, and various intermediate languages
07:44:33 <tzaeru> augustss_, well, it may not be necessary, but for some it can help to get into the more abstract level
07:44:33 <hodapp> one of these days I'll grok it...
07:44:42 <johnw> Aruro: https://www.cs.auckland.ac.nz/software/AlgAnim/red_black.html
07:44:43 <Aruro> because it is same as variable storing we talked so long
07:45:01 <tzaeru> that things were simpler to understand on a higher level, is a really bad generalization and not exactly applicable to every human type.
07:45:20 <Aruro> so there ARE variables in haskell :) Map being the one :D
07:45:36 <augustss_> tzaeru: I really can't tell if knowing the low level is good.  I've known how it works on a low level ever since I learnt FP. :)
07:45:42 <johnw> Map is not a variable
07:45:51 <hodapp> tzaeru: It's not about it being simpler to understand, it's that the higher level is the *correct* level to understand an abstraction.
07:45:57 <johnw> Map is a type constructor
07:46:09 <Aruro> i insert key i can delete it
07:46:19 <Aruro> how its not variable?
07:46:20 <johnw> inserting into a map does not change the map
07:46:21 <tzaeru> hodapp, that's a) BS b) not actually contradictive to what I said.
07:46:26 <sivteck> tzaeru, this gives a nice idea <http://takenobu-hs.github.io/downloads/haskell_ghc_illustrated.pdf>
07:46:30 <johnw> it generates a new generation of the map, without changing the identity of the old one
07:46:39 <augustss_> Aruro: when you insert an item you get a new map back.  the old one is unaffected.
07:46:45 <johnw> that's why you need to use an IORef, in order to overwrite the old generation with the new one
07:46:58 <Aruro> oh
07:46:59 <johnw> if anything, IORefs are the "variables" you're looking for
07:47:14 <Aruro> so Data.Map solves nothing for me
07:47:21 <Aruro> ok i go look at that loggin example
07:47:30 <clrnd> sivteck, tzaeru that's the pdf I was searching for! that will give you a nice overall look at it
07:47:31 <Aruro> also i think build yourself a scheme has it
07:48:14 <tzaeru> sivteck, thanks, that looks pretty interesting. ( thanks for the idea, clrnd :P)
07:48:27 <clrnd> je\
07:48:29 <johnw> Aruro: the NOINLINE hack that you'll see is to ensure that every reference to the global is a reference to the *same* global
07:48:48 <Aruro> ok, ty
07:48:49 <augustss_> Aruro: Don't use global variables.
07:48:56 <hodapp> tzaeru: It's not BS. The entire nature of an abstraction is that the correct level at which to understand it is at the *interface* it presents. Understanding it at a lower level might be useful for the sake of implementation, but pretty much anything you rely on there is going to be either (1) due to a leaky abstraction or (2) incidental behavior, not essential to the abstraction itself.
07:48:57 <augustss_> It's wrong.
07:48:58 <johnw> augustss_: we've been saying that
07:49:24 <Aruro> how do i do database in haskell? lets adress issue from other perspective
07:49:30 <Aruro> pure one
07:49:36 <Aruro> i want everything to be in memory
07:49:37 <augustss_> Aruro: You should not use global variables until you understand how to solve your problem without one.
07:49:39 <Aruro> no file writing
07:49:55 <johnw> Aruro: you use the State monad to mutate versions of your data set in a principled way
07:50:01 <clrnd> tzaeru, I'm with hodapp here, look, for example, where do you draw the line? os system calls? processor instructions? transistors switching?
07:50:02 <Aruro> i want to save user input, tell me how do i do that?
07:50:04 <clrnd> electrons dancing?
07:50:05 <augustss_> Aruro: What johnw said.
07:50:30 <Aruro> State monad?
07:50:32 <tzaeru> clrnd, I draw the line where I feel comfortable in understanding the purpose and uses and use-cases of certain features.
07:50:49 <augustss_> Aruro: State monad!
07:50:53 <johnw> the State monad provides a monadic interface to an abstraction of the following pattern: s -> (a, s)
07:50:53 <clrnd> tzaeru, haskell compiles to JS now (wooo!), and LLVM
07:51:07 <hodapp> tzaeru: Purpose, uses, and use-cases are all a hallmark of the interface, not of the implementation.
07:51:10 <johnw> i.e., a function that accepts an input state, and produces a possibly modified output state
07:51:23 <hodapp> clrnd: ghcjs does look neat. I've compiled it... just not built anything with it yet.
07:51:36 <hodapp> clrnd: don't forget that GHC also will just generate straight C code if you ask it/
07:51:43 <clrnd> that too
07:51:47 <hodapp> s|/|.|g
07:52:01 <hodapp> clrnd: you used ghcjs?
07:52:24 <tzaeru> hodapp, sure. it doesn't change your preferred way of learning certain things, though.
07:52:24 <clrnd> hodapp, me neither, I'm waiting to all the JS nodebowerangularreact stuff to get apis for it :D
07:52:28 <augustss_> clrnd: Personally I like to know how it works down to the electron dancing level.  But you have to know at what abstraction barrier to stop thing about things, ot you will be forever swamped in details.
07:52:40 <Aruro> ok State monad it is, mythical quest from BASIC to HASKELL, starts on State monad :D
07:52:49 <augustss_> s/thing/thinking/
07:52:55 <hodapp> clrnd: ghcjs already has plenty of APIs for those I think :)
07:53:04 * clrnd googles that
07:53:13 <hodapp> well, jquery and some others at least >_>
07:53:13 <clrnd> holly ***
07:53:16 <hodapp> lol
07:53:20 <clrnd> I only need react
07:53:34 <hodapp> the Facebook library for... whatever it is Facebook's library does?
07:53:35 <clrnd> not into the other MVCVCCCVVVC frameworks
07:54:03 <tdammers> fun fact: there are no MVC web frameworks, they all do it wrong :P
07:54:22 <clrnd> oh react is quite nice, it's really haskell-friendly, all immutable and stuff
07:54:24 <hodapp> tdammers: maybe they need more objects.
07:54:29 <clrnd> lol!
07:54:31 <Aruro> ok, i think i got engightment
07:54:34 <hodapp> clrnd: really? never used it, but that's good to know.
07:54:52 <_deepfire> are there nice FRP web frameworks?
07:55:04 <Aruro> all those crazy simple and dagerous things like  goto and global variables are MOST difficult to deal with in haskell?
07:55:10 <hodapp> _deepfire: some people might claim that Elm is this
07:55:19 <hodapp> other people might claim that Elm is not FRP
07:55:29 <clrnd> facebook is really pro-FP sometimes, flow is a type thing for JS that works charms (but is just too young for now)
07:55:32 <augustss_> Aruro: They really don't exist in Haskell.
07:55:41 <hodapp> clrnd: there's react-haskell too for Haste
07:55:49 <tzaeru> also, knowing lower level implementation *can* help you build mental images of how things work. for example, you can explain a class method in OOP as principally a function call to a function which takes the memory address of the class instance. it's not the full truth and it is not part of the theory behind why classes exist. but IT IS indicative of why you'd write a class method to begin with.
07:55:51 <_deepfire> hodapp, but compatible with haskell is Elm?
07:56:01 <hodapp> _deepfire: not that I know of
07:56:02 <tzaeru> while I am sure there are many abstractions which are too difficult to explain like that, there also are abstractions which CAN be explained like that
07:56:32 <tzaeru> and on being explained like that, you *can* reveal things about their purpose and use-cases even if it isn't laiden in theoretical terminology.
07:56:45 <inerkick> Hi ReinH I am having this issue http://lpaste.net/117921 Kindly help
07:56:51 <hodapp> tzaeru: Yeah... except that in OOP, they're not supposed to be function calls, they're supposed to be messages.
07:56:57 <Aruro> augustss_ saving a variable in a function argument also does not exits?
07:57:08 <hodapp> tzaeru: And why that distinction matters is because the objects are supposed to be *decoupled*.
07:57:21 <tzaeru> well, "supposed" isn't as good as building your own, good mental image.
07:58:00 <hodapp> tzaeru: If your mental image of OOP assumes that it's using function calls and pointers, then your mental image isn't good - it's ignoring the actual point of the abstraction.
07:58:16 <clrnd> hey I understand where he is coming from
07:58:17 <tzaeru> it can matter to people who like to debate language theory to early morning hours. it doesn't matter to me, though.
07:58:38 <exio4> tzaeru, the "assembler" of functional programming would be lambda-calculus, not the real computer
07:58:52 <clrnd> and that's a great statement right there
07:58:56 <augustss_> Aruro: Passing things in function arguments certainly exists.  But not global mutable variables, nor goto.  But you can something that behaves like mutable variables (State monad) and goto (continuation monad).
07:59:03 <clrnd> I remember how that helped me get haskell back in the day
07:59:21 <tzaeru> I'm rather fine in learning and understanding the top-level abstractions, concepts and theory, too.
07:59:37 <clrnd> tzaeru, it's how in imperative languages you pull it back to a turing machine
07:59:48 <clrnd> tzaeru, here in the end it's all function application :D
08:00:01 <hodapp> tzaeru: For someone who is fine with that, you are sure arguing a lot when told the proper top-level abstraction, concepts, and theory in OOP.
08:00:02 <tzaeru> yeah. I understand that aspect.
08:00:38 <tzaeru> hodapp, it's not about "proper", though. you miss the point if it is that to you. it's about having your own mental model that works for *you* and is compatible enough with others' that you can work with them.
08:00:52 <clrnd> tzaeru, I can honestly see how that example you gave for OOP can be helpfull for a C programmer, but believe us when we are saying that it won't work for haskell so well
08:00:58 <narendraj9> clrnd: Is it actually the y combinator that's used when we have a recursive function in Haskell?
08:01:09 <augustss_> tzaeru: If I were you I'd start by understanding in two steps: first, how all of Haskell can be mapped to just lambda calculus.  Second, how lambda calculus can be mapped to an actual machine.
08:01:10 <merijn> narendraj9: No
08:01:13 <clrnd> narendraj9, ehm no
08:01:18 <Aruro> there is no such thing as C-programmer
08:01:26 <tzaeru> augustss_, that can prolly work, too, yeah.
08:01:28 <Aruro> i strongly disagree
08:01:29 <hodapp> tzaeru: If your mental model is completely ignoring the abstraction, then any "works for you" is coincidental.
08:01:49 <exio4> tzaeru, http://research.microsoft.com/en-us/um/people/simonpj/Papers/slpj-book-1987/index.htm
08:02:07 <augustss_> That's a great book.
08:02:14 <hodapp> tzaeru: Why it matters is because OOP becomes a pile of meaningless drivel when one simply tries to call it "functions and pointers".
08:02:31 <merijn> tzaeru: The STG paper discusses how to map a really minimal lazy language to a commodity CPU
08:02:42 <clrnd> fun thing is that that is how it actually end ups being used
08:02:47 <tzaeru> thanks, merijn & exio4. bookmarked that too D:
08:02:51 <merijn> tzaeru: Understanding how to map haskell to the lazy STG language discussed is not too hard either
08:02:54 <hodapp> merijn: ooh, neat.
08:03:06 <merijn> tzaeru: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
08:03:14 <hodapp> clrnd: was that to me?
08:03:23 <merijn> hodapp: STG is basically just "really minimall Core"
08:03:32 <clrnd> hodapp, yeah xD
08:03:38 <tzaeru> hodapp, perhaps, but what I am going for here, is that it can be easier to understand those OOP concepts though "function and pointer", since the latter is a lower-level, common denominator
08:03:50 <tzaeru> it isn't a "wrong" way to understand it either.
08:03:53 <merijn> hodapp: The paper is a bit outdated in terms of exact mapping and implementation, but it's a fairly good intuition
08:03:59 <tzaeru> it's just a different way to approach it and eventually gain better knowledge of the affair.
08:04:24 <hodapp> tzaeru: No, it's not a different way, it's an *incorrect* way because it does not admit of the decoupling and the message-passing that are central to the abstraction.
08:04:26 <tzaeru> you can later drop the whole concept of "function and pointer" and start understanding different elements and unique properties of OOP
08:05:04 <tzaeru> hodapp, that's kind of an egoistic way to approach it. how can you claim that learning a thing from a different path than what you advocate, is "incorrect" if the end result is the same? O,o
08:05:07 <_deepfire> by the way, can the expansion to core be thought of as of macroexpansion?
08:05:42 <merijn> _deepfire: Not for any sensible definitions of macroexpansion, imo
08:05:43 <tzaeru> look, I don't -really- have a need to tangle to any low-level implementation at all. I merely use it as one small waypoint in learning the whole thing.
08:06:03 * hackagebot takusen-oracle 0.9.3 - Database library with left-fold interface for Oracle.  http://hackage.haskell.org/package/takusen-oracle-0.9.3 (PavelRyzhov)
08:06:07 <clrnd> tzaeru, hodapp, it seems to me you are focusing on different things. tzaeru means 'to lear to use it and programm stuff', hodapp means 'to learn the principles and theory'
08:06:09 <hodapp> tzaeru: The end result is *not* the same. Faux-OOP implemented as "functions and pointers" fails the abstraction as soon as one is concerned with making things distributed - which is why we have a hundred half-assed RPC implementations.
08:06:16 <kaiko> Can someone anwer this shared libarary compilation related question? http://stackoverflow.com/questions/27108855/ghc-shared-binary-compiling-gives-fpic-error-for-standard-libraries
08:06:23 <c_wraith> _deepfire, merijn: that conversion requires type inference, so it's way beyond macro expansion
08:06:49 <_deepfire> merijn, you know this Lisp thing, where there's a really small amount of core primitives, and most of lisp implementation is just a bunch of function definitions and macros
08:07:13 <clrnd> one can totally learn OOP in terms of pointers, and programm somethign in it, not just something too big :P
08:07:25 <tzaeru> hodapp, but you fail to understand that the end-goal is not to stay in the "faux-OOP". the end-goal is to take the most approachable path for a while, and then change paths when you feel comfortable to.
08:07:27 <merijn> _deepfire: Yeah, but haskell doesn't really have anything like that
08:07:50 <tzaeru> clrnd, but you can, at that point, start giving up from the concept of "pointer & function" and start more properly learn OOP.
08:08:09 <merijn> _deepfire: This is more like "mapping an OO language to C before doing optimisation/codegen"
08:08:10 <clrnd> tzaeru, oh well that's how Engineers think, hodap thinks like a scientist
08:08:24 <clrnd> both are perfectly good aproaches
08:08:32 <hodapp> clrnd: My degree is engineering.
08:08:40 <merijn> _deepfire: For example, typeclasses and instance look ups are something that can't really be done using things like macros
08:08:47 <clrnd> and my degree is scientis, yet I learned like tzaeru
08:09:01 <clrnd> :P
08:09:08 <_deepfire> merijn, Lisp macros can use global compile-time state
08:09:11 <tzaeru> I don't have a degree, though I have studied for a CS degree ^^
08:09:13 <hodapp> clrnd: oh, I learned like tzaeru too because of everyone frothing at the mouth to teach faux-OOP to everyone as someone that would save programming.
08:09:18 <merijn> _deepfire: Core is really more a "traditional" intermediate representation
08:09:19 <clrnd> jajaja
08:09:43 <tzaeru> but took the whole "welp, this course we'll do a tic-tac-toe.. THIS TIME IN C!" as a bit of a bore after long background in programming already.. also I drank way too much to attend school!
08:09:54 <hodapp> tzaeru: The problem is that practically no one who learns from the incorrect abstraction to start with ever seems to learn the correct one.
08:10:13 <augustss_> _deepfire: Apart from what happens during type checking, expansion to core is a lot like macro expansion.
08:10:16 <tzaeru> hodapp, well, I am hardly like the average.
08:10:22 <clrnd> hodapp, that's not true, come one
08:10:24 <clrnd> come on*
08:10:34 <mseeks> how come this doesn't work: `(return getLine) :: MaybeT IO String`?
08:10:35 <_deepfire> augustss_, bingo!
08:10:37 <merijn> I defer any and all haskell compilation questions to augustss_ expertise :p
08:10:43 <tzaeru> and my goal is not to learn theory per-say, even though I am OK with learning it. my goal in learning Haskell is to be forced to use a completely different approach to solving problems if I want to solve them elegantly ^_^
08:10:44 <clrnd> half people in this cahnnel started programming python, I bet
08:10:56 <merijn> mseeks: You probably want "lift"
08:11:08 <hodapp> tzaeru: And it means that when you *do* encounter something that relies on the more general, correct abstraction, you don't necessarily acknowledge it as just being a form of something you already know.
08:11:12 <_deepfire> augustss_, did anyone ever think of this macroexpand+-to-core functionality, for Emacs?
08:11:13 <merijn> mseeks: "return getLine" results in "Monad m => m (IO String)"
08:11:27 <augustss_> _deepfire: But you'll need powerful macros, like Lisp's.
08:11:27 <mseeks> merijn: ohh, I see
08:11:32 <merijn> :t lift
08:11:33 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
08:11:56 <merijn> mseeks: Notice that with lift the 'm' is an argument to 't', like you want for MaybeT
08:12:06 <_deepfire> augustss_, if people could see the result of this macroexpansion in-place, that could be quite enlightening to people
08:12:08 <mseeks> yeah, it makes sense now -- thanks
08:12:13 <augustss_> _deepfire: You mean being able to hit a button in Emacs and get your Haskell code expanded?
08:12:15 <merijn> _deepfire: You can make GHC dump out Core
08:12:20 <_deepfire> augustss_, yes
08:12:26 <hodapp> clrnd: let's see, I learned Python in... 2003
08:12:29 <hodapp> clrnd: still use it regularly
08:12:44 <hodapp> also, I used Ruby before it was cool
08:12:50 <tzaeru> well, to be honest, almost everything is a form of what we already know.. even a functor can be taking the form of "it's like a gift package, that unwraps itself" to people. ...now, I may have misunderstood functors in that, but whatever the real understanding is, it can still map into something we can relate to in our heads :P
08:12:51 <clrnd> tzaeru, in any case, haskell is a really fucking big beast, I promise you that learning how it compiles to machine code won't help you, just my 2 cents
08:12:58 <_deepfire> augustss_, this is a very commonly used feature in Common Lisp/Emacs
08:13:00 <clrnd> hodapp, I'm a full time python dev :P
08:13:04 <augustss_> _deepfire: I'd not want to write that in elisp!
08:13:07 <hodapp> clrnd: how's that going?
08:13:18 <merijn> _deepfire: See ghc-core for prettified/coloured output of Core
08:13:45 <mseeks> also, why can't I do `newtype A a = MaybeT IO a`?
08:13:49 <merijn> clrnd: I disagree, I think that understanding STG is a pretty good way to get a cost model for haskell execution
08:13:52 <tzaeru> is it -really- different if you, at first, think of functors like that or you think of them as "function A given data that comes with function B that makes that data more usable for the function A"?
08:13:53 <augustss_> _deepfire: First, parsing and module handling is a lot of woring in Haskell.  Second obstacle is type checking.
08:13:57 <clrnd> hodapp, pretty good now that I'm more in the frontend of things, doing react and JS :P
08:14:02 <clrnd> anyway, I have to go
08:14:02 <mseeks> it seems like MaybeT takes a * -> * and *
08:14:04 <hodapp> clrnd: react & JS with Python?
08:14:06 <augustss_> s/woring/work/
08:14:07 <tzaeru> (still given that I may have fully misunderstood functors, which is just OK at this point)
08:14:08 <merijn> mseeks: Newtypes need to define a new constructors
08:14:11 <_deepfire> augustss_, can't we employ the ghci for that?
08:14:13 <clrnd> cya
08:14:20 <merijn> mseeks: Try "newtype A a = A (MaybeT IO a)"
08:14:23 <hodapp> dang, I wanted to see how clrnd combined those things
08:14:24 <_deepfire> augustss_, that's how it done with CL
08:14:29 <hodapp> my web skillz have been... well, shitty
08:14:35 <augustss_> _deepfire: Yes, something like that would be possible.  And quite cool.
08:14:36 <hodapp> in part because I hate web technologies
08:14:39 <mseeks> merijn: oh wow, I should have realized
08:14:42 <mseeks> thanks
08:14:42 <merijn> mseeks: :)
08:14:51 <_deepfire> augustss_, they have two pieces -- lisp-side and emacs-side, which talk by the way of RPC
08:15:19 <merijn> _deepfire: Talk to chrisdone he's working on modifying ghci to use as a tool for stuff like this
08:15:20 <augustss_> _deepfire: You could use the ghc API for that, probably.
08:15:35 <merijn> https://github.com/chrisdone/ghci-ng
08:15:57 <merijn> augustss_: I'm convinced that ghci is probably preferable
08:16:23 <merijn> augustss_: GHC API ties you to a specific GHC version, which means that switching between GHC versions becomes a real hassle that breaks all your editor tools
08:16:33 <augustss_> merijn: Yeah
08:16:38 <merijn> Which is one of the main reasons Chris is trying to add this stuff to ghci
08:17:06 <augustss_> merijn: So he's actually making a stable ghc API. :)
08:17:30 <merijn> Pretty much
08:17:39 <Denommus> hi
08:18:36 <mseeks> if I have a stack like `ReaderT A (MaybeT IO) a` and I want to use MaybeT's instance of MonadPlus, will deriving MonadPlus work?
08:19:10 <merijn> mseeks: Pretty sure that should already have a MonadPlus instance
08:19:14 <mseeks> i.e., will I be able to use `guard` and have the result be something like r -> IO Nothing
08:19:27 <_deepfire> if the haskell community could talk in terms of how the advanced constructions expand to Core..
08:19:43 <_deepfire> that could have brought a lot of light and understanding, I guess
08:19:52 <merijn> mseeks: Yeah, ReaderT uses the underlying MonadPlus of MaybeT, which I should hope does the obvious thing :p
08:20:11 <merijn> _deepfire: That's what almost all papers talking about compiling functional languages do :)
08:20:14 <_deepfire> but this would require an ergonomic way of accessing such expansions
08:20:21 <exio4> _deepfire, something like http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html ?
08:20:34 <mseeks> merijn: got it, thanks. and in general the newtype deriving will use the outermost instance for a given typeclass?
08:20:46 <merijn> mseeks: Yeah
08:20:51 <_deepfire> merijn, you see -- you said "papers"
08:20:57 <mseeks> thanks!
08:21:13 <_deepfire> merijn, people learning Haskell don't read papers, most typically
08:21:17 <merijn> _deepfire: To be fair, Core is an implementation detail of GHC
08:21:29 <merijn> _deepfire: There is no requirement for it in the Report
08:21:54 <_deepfire> merijn, I agree.. but that's true for all Lisp implementations as well
08:22:00 <merijn> _deepfire: People just learning haskell probably don't need to understand the mapping to Core yet either :)
08:22:03 <augustss_> merijn: But the report has it's own core language that is used for explaining things.
08:22:19 <augustss_> merijn: But it's not formally defined.
08:22:23 * merijn mumbles something about denotational semantics
08:22:24 <levi> merijn: Core specifically.... uh, what augustss_ said. :)
08:22:40 <_deepfire> merijn, there's a mandated set of standard "known" primitives, but there's also a lot of implementation-specific stuff which appears in desugaring
08:22:55 <hodapp> blaaah, I may have to add that SPJ book to my list of things to read
08:22:59 <hodapp> but that list is already so long
08:23:14 <merijn> hodapp: You can start with the STG paper I linked, it's very easy to read!
08:23:31 <hodapp> http://research.microsoft.com/apps/pubs/default.aspx?id=67083 ?
08:23:35 <merijn> Yeah
08:23:58 <breadmonster> Do we have macros in Haskell?
08:24:04 <breadmonster> LISP like macros that is.
08:24:18 <dmj`> no
08:24:31 <hodapp> there's Template Haskell, but that's not quite the same
08:24:31 <dmj`> template haskell is a compile time thing iirc
08:24:38 <merijn> hodapp: That defines the lazy STG language (basically, let, case, functions, and some primitive types) and explains how to compile that
08:24:55 <_deepfire> dmj', Lisp macros are compile time too!
08:25:04 <dmj`> and runtime too
08:25:04 <merijn> A lot of uses of LISP macros can be subsumed by laziness, a lot of others can be subsumed by TH
08:25:07 <_deepfire> dmj`, no!
08:25:10 <dmj`> no?
08:25:11 <hodapp> _deepfire: Lisp 'compile' and Haskell 'compile' are maybe not quite the same either...
08:25:16 <merijn> I'm not quite sure if there's anything not covered by those
08:25:24 <hodapp> merijn: and the rest can be subsumed by not wanting to create Skynet accidentally?
08:25:30 <_deepfire> dmj`, macros are expanded during compile-time
08:25:31 <merijn> hodapp: Probably
08:25:47 <_deepfire> dmj`, it just so happens that COMPILE is available at run-time
08:25:55 <hodapp> _deepfire: yeah, that's what I mean.
08:25:56 <merijn> _deepfire: Yes, but LISP compile time is not lways at compile time :)
08:26:04 * hackagebot iso3166-country-codes 0.20140203.6 - A datatype for ISO 3166 country codes  http://hackage.haskell.org/package/iso3166-country-codes-0.20140203.6 (JonFairbairn)
08:26:35 <_deepfire> merijn, yes, Lisp is special in that the compiler is always available
08:26:38 <augustss_> _deepfire: There's nothing to stop a Haskell implementation to have 'compile' available at runtime.  In fact we have one that has that.
08:26:53 <johnw> merijn: pronunciation of your name is not covered
08:27:21 <_deepfire> augustss_, I'm very happy to hear that
08:27:52 <breadmonster> augustss_, What implementation is that?
08:27:53 <hodapp> augustss_: what's this?
08:28:01 <merijn> augustss_: "we" being at Standard Chartered?
08:28:21 <augustss_> breadmonster, hodapp: It's our Haskell we us at Standard Chartered.
08:29:20 <merijn> Clearly the solution is to simply copy augustss_ and make implementing haskell compilers for fun and profit your hobby :)
08:29:20 <dmj`> the clckworks project loads haskell code "plugins" dynamically iirc
08:29:42 <merijn> dons had a bunch of papers on plugins in haskell, but the links have bitrotted :(
08:30:03 <augustss_> It also has the optimizer available at runtime, so you can imporove performance critical pieces of code at runtime.
08:30:18 <hodapp> Mu Haskell?
08:30:32 <_deepfire> augustss_, that's rather intriguing..
08:30:34 <augustss_> hodapp: yes
08:30:55 <merijn> augustss_: What are the odds of working on Mu without having to move to Singapore? :)
08:31:05 <augustss_> _deepfire: It's very cool.  You can optimize partial applications to generate specialized functions.
08:31:21 <hodapp> huh, can't find much info on Mu Haskell
08:31:31 <augustss_> merijn: Quite high.  We're hiring in London.
08:31:35 <merijn> hodapp: Proprietary secrets!
08:31:39 <hodapp> booo
08:32:19 <merijn> augustss_: Oh, cool! Last I checked all the standard chartered haskell jobs were only in Singapore. I'll just keep my fingers crossed you'll still be hiring by the time I finish my phd :p
08:32:23 <_deepfire> augustss_, do you have vague plans to open it, sometime in the future?
08:32:30 <mseeks> another question -- I have a stack like `ReaderT Info (MaybeT IO) a`, where Info contains (let's say) {data :: Map Key Val, num :: Int}
08:32:41 <augustss_> _deepfire: Unlikely :(
08:33:15 <mseeks> I have a function g :: Map Key Val -> Int -> IO String
08:33:26 <breadmonster> augustss_, You're hiring?
08:34:01 <augustss_> breadmonster: We just hired one guy.  One more hire later this year.
08:34:20 <mseeks> actually let me put this in a scratch pad
08:35:09 <merijn> mseeks: "do { myMap <- asks data; liftIO $ g myMap 1 }"
08:40:14 <mseeks> merijn: didn't quite type it correctly; here's the gist of it: http://codepad.org/8MFIIK55
08:40:19 <_deepfire> so, macroexpand-in-emacs depends on ghci-ng, by cdone
08:40:35 <mseeks> i just have a feeling there's a much cleaner way to write `f`
08:41:58 <merijn> :t maybe
08:41:59 <lambdabot> b -> (a -> b) -> Maybe a -> b
08:42:25 <merijn> Flip the arguments to 'g' and use: liftIO $ maybe (return ()) (g n)
08:42:48 <merijn> Actually
08:43:01 <merijn> liftIO $ maybe (return ()) (g n) (M.lookup k v)
08:43:18 <merijn> :t maybe (return ())
08:43:19 <lambdabot> Monad m => (a -> m ()) -> Maybe a -> m ()
08:43:32 <merijn> :t maybe (return ()) (undefined :: Val -> IO ())
08:43:33 <lambdabot> Not in scope: type constructor or class â€˜Valâ€™
08:43:39 <merijn> :t maybe (return ()) (undefined :: Int -> IO ())
08:43:40 <lambdabot> Maybe Int -> IO ()
08:43:50 <merijn> :t liftIO $ maybe (return ()) (undefined :: Int -> IO ()) Nothing
08:43:51 <lambdabot> MonadIO m => m ()
08:43:55 <merijn> Bam :)
08:44:21 <merijn> mseeks: If you use isJust + fromJust, you almost always want fromMaybe and/or maybe
08:44:25 <mseeks> but shouldn't it have MonadIO m => m String?
08:44:36 <mseeks> because `g` returns IO String
08:44:43 <merijn> ah
08:45:01 <merijn> @unmtl MaybeT IO a
08:45:02 <lambdabot> IO (Maybe a)
08:45:09 <mseeks> also would `return ()` give something containing (IO Nothing)?
08:45:37 <merijn> :t MaybeT $ maybe (return Nothing) (undefined :: Int -> IO String) Nothing
08:45:37 <lambdabot> Not in scope: data constructor â€˜MaybeTâ€™
08:45:44 <merijn> :t maybe (return Nothing) (undefined :: Int -> IO String) Nothing
08:45:45 <lambdabot>     Couldn't match type â€˜[Char]â€™ with â€˜Maybe aâ€™
08:45:45 <lambdabot>     Expected type: Int -> IO (Maybe a)
08:45:45 <lambdabot>       Actual type: Int -> IO String
08:45:57 <merijn> oh, duh
08:46:05 <merijn> :t maybe (return Nothing) (fmap Just . undefined :: Int -> IO String) Nothing
08:46:05 * hackagebot ghc-pkg-lib 0.3 - Provide library support for ghc-pkg information  http://hackage.haskell.org/package/ghc-pkg-lib-0.3 (JeanPhilippeMoresmau)
08:46:05 <lambdabot>     Couldn't match type â€˜[Char]â€™ with â€˜Maybe aâ€™
08:46:05 <lambdabot>     Expected type: Int -> IO (Maybe a)
08:46:05 <lambdabot>       Actual type: Int -> IO String
08:46:18 <merijn> mseeks: Yeah, this is quickly becoming a bit cumbersome
08:46:40 <merijn> I don't think you can get it a lot cleaner unless you reshuffle some of the types, which may not be worth it
08:46:43 <mseeks> merijn: yeah, I was trying to think of a concise way to do it but the monads are just sort of tangled
08:47:23 <mseeks> using "isJust/fromJust" just seemed awkward to me
08:48:00 <mseeks> and using two `<-` bindings seemed like I could replace the `do` with a liftM2
08:48:06 <merijn> :t maybe mzero (liftIO . (undefined :: Int -> IO String)) Nothing
08:48:07 <lambdabot> (MonadIO m, MonadPlus m) => m String
08:48:11 <merijn> Bam :)
08:48:38 <mseeks> awesome!
08:48:48 <merijn> :t maybe mzero (liftIO . (undefined :: Int -> IO String)) Nothing :: ReaderT Bool (MaybeT IO String)
08:48:48 <lambdabot>     Not in scope: type constructor or class â€˜MaybeTâ€™
08:48:49 <lambdabot>     Perhaps you meant â€˜Maybeâ€™ (imported from Data.Maybe)
08:48:53 <merijn> bah
08:48:56 <merijn> ok, you get the idea
08:49:16 <mseeks> yep, thanks!
08:49:19 <mseeks> this is really helpful
08:50:25 <alpounet> augustss_: does mu use llvm for codegen?
08:53:49 <augustss_> alpounet: It's an option.  Normally we use an interpreter.
08:54:15 <untseac> hey
08:55:06 <augustss_> alpounet: Using LLVM is actually a runtime choice.  There's a function 'compile :: a -> a' which takes anything and returns an equivalent thing that has been compiled using LLVM.
08:55:39 <clrnd> hodapp, hi
08:56:22 <alpounet> augustss_: that's really nice!
08:57:49 <alpounet> augustss_: your haskell<->excel integration is funnily enough probably what would have the largest impact in some of the projects I ship, despite the fact I'm 100x more intrigued by what you've just mentionned
08:58:07 <augustss_> alpounet: We also support streaming functions between machine.  If you stream a function that has been compiled with LLVM, you actually stream the AST for the function and run the LLVM jitter on the other end.  Since the architectures can be totally different.
08:59:46 <alpounet> augustss_: alright, we just need a plan to hire you to rewrite all of this as open source =)
08:59:50 <augustss_> alpounet: The Excel integration started out being important to use, but we're trying to move away from Excel, so it's much less important now.
09:00:19 <augustss_> alpounet: Just give me enough money! :)
09:00:43 <_deepfire> augustss_, pulling off a Shake again? : -)
09:00:59 <_deepfire> SC gave up, IIRC, and open-sourced it
09:01:19 <alpounet> I think Neil actually rewrote it from scratch on his free time
09:01:31 <_deepfire> ah, right
09:01:41 <augustss_> I've actually considered rewriting the Excel integration as open source.  It's not very difficult once you know how.  And I've done it twice now.
09:02:36 <_deepfire> augustss_, I wonder if you could out-source the process of coming up with open-sourcing pitches for your management
09:03:15 <augustss_> _deepfire: the lawyers are probably the biggest obstacle.
09:03:21 <alpounet> augustss_: I'm pretty sure I can't beat SC money-wise, otherwise there'd already be an offer in your inbox :p
09:03:37 <_deepfire> augustss_, like, by formulating the current anti-stance points..
09:04:04 <_deepfire> augustss_, the community could make the case for you to present them
09:04:17 <augustss_> _deepfire: So here's the lawyers worry: If the bank open sources something, and this something goes wrong, the bank can be sued.
09:04:32 <lpaste> simg pasted â€œSnap Frameworkâ€ at http://lpaste.net/117930
09:05:21 <tasker> Could anyone give me a brief overview / point me to a brief overview of how the ST monad works ?
09:05:27 <simg> oh .. hi .. didn't realise that lpaste talked directly to this irc
09:05:55 <dmj`> http://stackoverflow.com/questions/12468622/how-does-the-st-monad-work
09:06:06 * hackagebot MuCheck 0.3.0.4 - Automated Mutation Testing  http://hackage.haskell.org/package/MuCheck-0.3.0.4 (RahulGopinath)
09:06:09 <tzaeru> seems my installed mingw & haskell platform don't go hand to hand that well.. "cabal install cabal-install -v3" -> C:\MinGW\bin\ld.exe returned ExitFailure 1 with error message: C:\Users\tzaeru\AppData\Local\Temp\10548.o: file not recognized: File format not recognized.
09:06:10 <simg> i don't suppose anyone could help me with a postgres-simple problem ?
09:06:12 <tasker> dmj`: Thanks.
09:06:30 <_deepfire> I wonder how safe BSD-style licenses are in this respect
09:06:47 <simg> it's in the link I just posted. I've added comments at line 83 to explain the issue
09:09:29 <tomejaguar_away> simg: Where exactly do you see that error?
09:09:44 <alpounet> augustss_: and can Mu also compile "math code" to run on GPU, through llvm or otherwise?
09:10:00 <alpounet> it's something i've been thinking about and toying around with on my admittedly rare free time
09:10:20 <hodapp> clrnd: hi!
09:10:35 <tomejaguar> simg: First problem: getCustomer needs to be in IO.  getFirstCustomer needs to be lifting into IO at its point of use
09:10:50 <clrnd> hodapp, hey, saw what you said on the logs, sorry I had to go
09:10:53 <tomejaguar> alpounet: What are you working on?
09:10:58 <hodapp> clrnd: hey, no problem, you had to go :P
09:11:28 <clrnd> hodapp, in short, I work in elections software, so it's absolutely not canonical. we have a python layer that interfaces with the C/Hardware layer and a Web frontend in Flask
09:12:10 <alpounet> tomejaguar: regarding what i've just mentionned?
09:12:11 <tomejaguar> simg: You need `getCustomer :: ByteString -> IO Customer` and `getFirstCustomer :: [Customer] -> IO Customer` I think.  (This can be improved but we'll start there).
09:12:12 <hodapp> ahh, okay!
09:12:15 <clrnd> the web part was kind of aging so they told me to build a new infraestructure in modern tools
09:12:20 <hodapp> are you going to convert them to Haskell?
09:12:37 <tomejaguar> alpounet: Just curious what you're doing that you want augustss_ for :)
09:12:37 <clrnd> jjajajajajja that's a dream of mine :P
09:12:54 <clrnd> but no, because of law issues it has to be in an interpreted language
09:13:30 <simg> tomejaguar: thx. compile error occurs on ln 100
09:14:45 <simg> I thought  that " <- "  would take care of the "IO" part ?
09:14:51 <tomejaguar> simg: If you make the type signature changes I suggested I think it will work.  At the very least you'll get a clearer error.
09:15:12 <tomejaguar> simg: <- doesn't care of putting IO in the type signature!
09:15:31 <rofer> Is there a way to write f a b = abs (a - b) in point-free style?
09:15:33 <hodapp> clrnd: law issues, interpreted, what?'
09:15:50 <augustss_> alpounet: No GPU stuff.  Yet.
09:16:05 <tomejaguar> simg: Hmm I see you need to be running this in a Handler too, but I don't know anything about that.
09:16:06 * hackagebot presburger 1.3 - A decision procedure for quantifier-free linear arithmetic.  http://hackage.haskell.org/package/presburger-1.3 (IavorDiatchki)
09:16:10 <tomejaguar> simg: One step at a time.
09:16:35 <alpounet> tomejaguar: well, who doesn't need an augustss_? :) joke aside, at some point later this year i'll probably be working on something to compile number crunching/AI algorithms to very efficient machine code (ideally mixing cpu & gpu)
09:16:50 <merijn> I wonder why everyone obsesses about GPUs so much, meanwhile I'm more and more convinced GPU is largely useless for 90% of programming
09:16:56 <merijn> (conservatively low estimate)
09:16:57 <augustss_> @pl \ a b -> abs (a - b)
09:16:57 <lambdabot> (abs .) . (-)
09:17:10 <tomejaguar> alpounet: Sounds cool.  What will the algorithms be for?
09:17:16 <augustss_> rofer: ^
09:17:35 <clrnd> hodapp, maybe it's BS, but I was told that it needed to be human readable, and we have had times when we have to show a lawyer a piece of code ... it's hilarious
09:17:46 <rofer> augustss_: Ah, thanks.
09:18:06 <alpounet> merijn: in my case, i have a couple of benchmarks that demonstrate how ridiculously fast GPU-powered neural nets can be compared to when run on CPU.
09:18:20 <merijn> alpounet: Machine learning? :)
09:18:40 <merijn> alpounet: Yeah, neural nets might work
09:18:42 <alpounet> and that's with my laptop's graphics card...
09:18:51 <merijn> At least they're fairly data parallel and regular
09:19:08 <mettekou> Does anyone know of a way to update the contents of Gtk2Hs `Table`s at runtime without resorting to `IORef`s or `MVar`s?
09:19:10 <augustss_> alpounet: But it's only certain problems that work well on GPUs.  It must have a high rate of processing compared to the amount of data.
09:19:22 <merijn> augustss_: Not necessarily
09:19:35 <merijn> Regular access patterns are also crucial
09:19:46 <alpounet> merijn: yeah obviously not all algorithms are amenable to such performance gains :) but some of the ones that I care about are, so I really have to push this work further
09:19:58 <merijn> Guess who's getting paid to do graph processing on GPUs and slowly realising he's boned! ;)
09:20:07 <augustss_> merijn: I didn't mean my criterion to be the only one.  Just a necessary one.
09:20:52 <merijn> augustss_: I don't think it's necessary either. Memory intensive operations can work on the GPU, provided that they don't interfere (i.e., they all align nicely, etc)
09:20:55 <alpounet> augustss_: yup, exactly, but yeah neural nets are a particularly nice example of that. at least those that have an appropriate architecture
09:21:07 * hackagebot MuCheck-SmallCheck 0.3.0.4 - Automated Mutation Testing for SmallCheck tests  http://hackage.haskell.org/package/MuCheck-SmallCheck-0.3.0.4 (RahulGopinath)
09:21:36 <augustss_> merijn: But you have to get the data to/from the GPU.  If that takes longer than processing on the CPU, then you can't win.
09:21:46 <merijn> Sure, that's true
09:22:11 <hodapp> clrnd: but in this case how is bytecode-compiled Python any different from compiled-Haskell?
09:22:52 <merijn> hodapp: The need for a bytecode interpreter? :)
09:23:00 <clrnd> hodapp, I'm not sure, I don't think law knows anything about it. in any case nobody here is a fan of haskell (besides me)
09:23:24 <hodapp> merijn: I mean, for the legal sake of compiled or not
09:24:37 <Chathurga> @pl \a b c -> c (a b c) (b a c)
09:24:37 <lambdabot> liftM2 ap ((ap . ap id) .) (flip id)
09:25:09 <Chathurga> Nice
09:25:11 <merijn> Pretty sure there's no real legal definition of compiled
09:25:18 <clrnd> yeah
09:26:07 * hackagebot MuCheck-QuickCheck 0.3.0.4 - Automated Mutation Testing for QuickCheck tests  http://hackage.haskell.org/package/MuCheck-QuickCheck-0.3.0.4 (RahulGopinath)
09:26:09 * hackagebot MuCheck-HUnit 0.3.0.4 - Automated Mutation Testing for HUnit tests  http://hackage.haskell.org/package/MuCheck-HUnit-0.3.0.4 (RahulGopinath)
09:26:11 * hackagebot MuCheck-Hspec 0.3.0.4 - Automated Mutation Testing for Hspec tests  http://hackage.haskell.org/package/MuCheck-Hspec-0.3.0.4 (RahulGopinath)
09:28:38 <alpounet> tomejaguar: hmm, i can't disclose everything at the moment, but nothing too fancy really. i'm currently working on the data gathering part, once I have it i'll keep adding more data but will start working on predicting some metrics and classifying that data that I gather.
09:29:41 <alpounet> (it's not related to financial markets, although it may sound like it is)
09:34:48 <tzaeru> hm, tried to install sdl2 through cabal and otherwise for a while.. can't quite yet it right. also "cabal install cabal-install" says it installs cabal 1.22, but actually 1.18 never gets replaced :P
09:34:54 <tzaeru> on windows, at that
09:35:46 <clrnd> tzaeru, you'll need to add it to $PATH maybe
09:35:51 <tzaeru> it is.
09:35:59 <clrnd> and remove the old one
09:36:11 <alpounet> it must come before the directory that contains 1.18
09:36:19 <clrnd> or that yeah
09:37:38 <untseac> can I impress the ladies with haskell?
09:38:05 <tzaeru> hm, seems that Haskell platform for Windows comes with half a dozen paths it sets up ^^
09:38:17 <tzaeru> and one of the first points to extralibs/bin where cabal 1.8 resides
09:38:45 <hodapp> untseac: Yes.
09:38:57 <untseac> hodapp, lol
09:40:26 <alpounet> tzaeru: right. now find out what directory 1.22 got installed in, and make it appear _before_ Haskell Platform's
09:40:39 <alpounet> (in the PATH env variable)
09:40:57 <tzaeru> very good question, where it got installed.
09:41:12 <tzaeru> I think the simpler rsolution is to remove whole Haskell Platform for Windows and install the parts one by one
09:41:20 <alpounet> it's probably mentionned in the build log
09:42:17 <alpounet> i haven't used haskell on windows (or even windows at all) in ages, so I don't know where it ends up being installed
09:44:24 <tzaeru> there seem to be quite few minor issues with quite few things on installing to Windows.
09:44:33 <tzaeru> most are pretty quickly fixable
09:46:07 * hackagebot sloane 2.0.0 - A command line interface to Sloane's On-Line Encyclopedia  of Integer Sequences  http://hackage.haskell.org/package/sloane-2.0.0 (AndersClaesson)
10:02:44 <clrnd> tzaeru, I've used haskell on windows and, in my experience, the haskell platform is a life saver
10:02:47 <clrnd> but YMMV ofc
10:14:38 <tzaeru> clrnd, well, replacing it was pretty easy.
10:14:48 <tzaeru> though the sdl2 package is refusing to cooperate :D
10:15:42 <Denommus> damn, haste-boot doesn't work :-/
10:41:09 * hackagebot cabal-debian 4.19.1 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.19.1 (DavidFox)
10:43:06 <lispy> clrnd: on windows it is pretty nice for getting started.
10:43:57 <J_Arcane> Haskell Platform is pretty great.
10:44:13 <J_Arcane> What I ran into a lot though were cabal crashes on Windows.
10:44:37 <lispy> clrnd: the platform tends to be good for people who are starting out with haskell, doing a bunch of mass installs (like in a university computer lab), or "causal haskell use". In my experience, the folks doing more intensive haskell development don't tend to use it as more than a quick way to get ghc+cabal installed.
10:44:47 <hasbero> Haskell is very edutcation but is it supposed to be productive platform for real apps in use I wonder.
10:44:52 <hasbero> educational*
10:45:19 <clrnd> hasbero, yeah it is! is one of it's core concepts
10:45:31 <hasbero> It's more like a proof of concept about 'aggregate state in a few well controlled locations'
10:45:43 <hiptobecubic> I think there's kind of "two camps" of haskell lovers
10:45:44 <clrnd> lispy, in my experience it's pretty practical, then with sandboxes you can get rolling anything you want
10:45:49 <hasbero> And once you do that, you can do it in any language
10:45:52 <lispy> hasbero: It sort of depends on the project and team, I suppose. ghc is of sufficient quality to use for production work (for example)
10:45:53 <c_wraith> hasbero: I've used it to create real applications.  It works well.
10:46:19 <hasbero> I'm sure you *could* but does it blow out of the water, say Java, in any way?
10:46:31 <c_wraith> hasbero: in terms of pleasantness, absolutely
10:46:31 <lispy> clrnd: Right so, to me once you start using packages (or even versions of packages) not provided by the platform you've stop using just the platform
10:46:41 <hasbero> Well pleasantness...
10:46:43 <Hijiri> I would choose Haskell over Java any day
10:46:53 <hiptobecubic> this probably isn't a good room to ask this in
10:46:59 <Hijiri> for actually writing code, haskell is a lot more concise
10:46:59 <clrnd> mmm The Report says:
10:47:00 <clrnd> It should be suitable for teaching, research, and applications, including building large systems.
10:47:07 <clrnd> so, yeah, :P
10:47:25 <lispy> clrnd: I read that as aspirational :)
10:47:38 <clrnd> jajaja
10:48:01 <lispy> I think there are teams that would steer clear of Haskell for production stuff. And that's fine. I bet some people find hackage to be too much of "the wild west" and such.
10:48:19 <clrnd> lispy, you have Haskell LTS for that (?)
10:48:55 <c_wraith> clrnd: as of this week, sure.  As of years ago, nothing like it. :)
10:49:09 <lispy> I think bos made  a good point at Haskell symposium one year. He basically said, for a lot of the toolchain and pleasantry stuff we should defer to the devops teams that want to use Haskell.
10:49:29 <hiptobecubic> lispy, meaning?
10:49:39 <c_wraith> lispy: sure, but we shouldn't make it *painful* for them. :)
10:49:46 <lispy> They will end up building solutions to package distribution that works for them and if we're lucky they will share it. (stackage is an example)
10:49:47 <hiptobecubic> lispy, wait for someone to write fabric in haskell?
10:49:54 <J_Arcane> If I had known and learned about FP when I was younger, I probably wouldn't have waited a decade to become a programmer.
10:50:07 <lispy> I guess to some extent we are those devops folks
10:50:15 <lispy> So we shouldn't wait exactly
10:50:24 <lispy> But we should not expect GHC HQ to do  these things
10:50:32 <hiptobecubic> Oh. No why would they?
10:50:45 <lispy> J_Arcane: heh
10:50:47 <clrnd> Python is ten times more industry friendly and in this matter it sucks so damn much, pip isn't even everywhere yet
10:50:52 <HeladoDeBrownie> J_Arcane, out of curiosity, why did you wait a decade?
10:51:08 <hiptobecubic> probably because programming is pretty annoying
10:51:41 <J_Arcane> HeladoDeBrownie: Because when I was younger, the only serious options for programming for a living were C and Java languages, with a smattering of Visual Basic.
10:51:42 <lispy> And sandboxing in cabal was prototyped by galois and then the cabal team implemented it in cabal proper
10:51:43 <c_wraith> Oh, hey.  Speaking of learning - my girlfriend has been curious about programming. I showed her a bit of haskell, and a bit of python.  Her response to python was "I need alcohol to deal with this."  I think that's probably the standard adult reaction for using "=" as the assignment operator, right?
10:52:02 <clrnd> c_wraith, lovely!
10:52:16 <jfischoff> c_wraith: yeah, same thing happened with my wife
10:52:23 <HeladoDeBrownie> J_Arcane, i take it none of those appealed to you then?
10:52:40 <c_wraith> I learned to program too young to see a problem with using "=" to mean assignment.
10:52:43 <HeladoDeBrownie> hiptobecubic, i didn't know any better and tried to start with c++, that was annoying
10:53:09 <bobvh> my gf would need alcohol with any language :)
10:53:29 <bobvh> except for dutch :P
10:53:39 <hiptobecubic> HeladoDeBrownie, TI-86 BASIC and then perl much later in life for bioinformatics. It was pretty awful, i must say
10:54:15 <J_Arcane> HeladoDeBrownie: Basically. I can *almost* tolerate C until you start passing this and that pointer type around and then my brain hurts. I was the kid who stuck with BASIC in the 8-bit days instead of learning assembly.
10:54:16 <gcganley> is there any reason base isnt dynamically linked on windows. im trying to build a dll but it isnt working
10:54:34 <hiptobecubic> I do python day to day now and if anything I'm amazed that it isn't more terrible, given the landscape it was born in. I do wish we types though :(
10:55:01 <lispy> gcganley: I'm not up to date on the state of dynamic linking with Haskell but AFAIK it's always been in a weird state
10:55:02 <hiptobecubic> the only thing saving it is the ENORMOUS community that has written static analysis tools out the ass to save you from making obvious mistakes
10:55:05 <clrnd> it's only a matter of time, guido is into types now
10:55:11 <gcganley> J_Arcane: I just got done marshaling haskell strings over to C#
10:55:19 <gcganley> J_Arcane: the pain is real
10:55:20 <clrnd> and dropbox hired him to port everything to Golang, so he must be angry as hell
10:55:25 <lispy> gcganley: Typically your FFI libs can be dynamically linked but the Haskell modules get statically linked
10:55:28 <hiptobecubic> gcganley, oh yeah, how did that go? I remember you asking about it
10:55:31 <lispy> gcganley: or something like that
10:55:36 <HeladoDeBrownie> hiptobecubic, it's funny, i wrote an 8kb rpg on my ti-83 in middle school but wouldn't have the patience to do that in ti-basic today since i know haskell.
10:55:41 <hiptobecubic> clrnd, oh did they? that's pretty funny.
10:55:47 <gcganley> lispy: the think is it works on linux but not on windows
10:55:51 <J_Arcane> hiptobecubic: As a BASIC coder, Python was initially revelatory in its flexibility, but eventually just ran into new limitations. The thing that really blew my socks off was 'getting' Scheme/Lisp for the first time.
10:55:58 <hasbero> If you can last top 3 benefits of using Haskell aside from good feels, what would it be
10:55:59 <clrnd> hiptobecubic, https://tech.dropbox.com/2014/07/open-sourcing-our-go-libraries/
10:56:02 <hasbero> list*
10:56:05 <lispy> gcganley: Linux is more first class than windows :(
10:56:09 <hiptobecubic> HeladoDeBrownie, I wrote a pokÃ©mon-clone. Even used the link cable for battles. good times.
10:56:10 <bitemyapp> Anybody use Persistent here? Some ideas on how to get parameterized table truncation would be appreciated: http://lpaste.net/6355039116756779008
10:56:13 <koala_man> HeladoDeBrownie: how was ti-basic? I had a Casio and its basic was attrocious
10:56:15 <gcganley> hiptobecubic: ummm it works. i have functions of type (String -> String -> String) working fine
10:56:36 <sm> http://thedoomthatcametopuppet.tumblr.com/ for haskell, anyone ? might be pretty funny
10:56:37 <lispy> gcganley: anyway, if you want better help we should discuss the details more. Like what you tried and what happened?
10:56:51 <Flonk> koala_man: We had to program *german* TI-BASIC in school.. god, that was terrible
10:56:57 <HeladoDeBrownie> koala_man, the main problem was the editor, which didn't have a go-to-line or go-to-label feature. but the language is not very featureful either. for example, all variables are global, and you get a limited number of them.
10:57:08 <laurie> hello, trying to extract a list of strings using Aeson and Lenses. Current approach is http://lpaste.net/117938
10:57:11 <gcganley> lispy: right now I have a repo up on github @ https://github.com/gcganley/subnet
10:57:21 <laurie> but doesn't work; get empty list back
10:57:26 <J_Arcane> gcganley: I was working on porting my Lisp in C but I ran into "book vs. idea" clash and then just got distracted with a new object system for the original implementation ...
10:58:06 <koala_man> HeladoDeBrownie: casio basic was the same, and had terrible limitations like not being able to check whether an list was defined and crashing if accessing an undefined one
10:58:15 <HeladoDeBrownie> hmm, what say we move this discussion to #haskell-blah since we have some people asking for help in this channel?
10:58:16 <gcganley> J_Arcane: rewrite or importing functions?
10:58:33 <koala_man> and of course it used all sorts of weird symbols that you had to dig through menus for rather than being able to type out as text
10:58:34 <clrnd> sm, je, the original was pretty fun, should do one between LYAH and 50 Shades of Grey
10:58:43 <clrnd> ..... or maybe not
10:58:58 <gcganley> clrnd: wat
10:59:01 <lispy> gcganley: cool. I just looked it over. I don't have a windows machine handy to test it on.
10:59:21 <J_Arcane> gcganley: IT was this book: http://www.buildyourownlisp.com/ It's a good book, but trying to keep track of what it was doing and also changing things as I went for my own version was proving a headache, and to boot it's a very idiosyncratic lisp.
10:59:58 <supki> laurie: does it work?
11:00:19 <laurie> supki: no, empty list (which i presume denotes failure for ^..)
11:00:29 <hiptobecubic> I forgot how great KingJamesProgramming is. "and the sun beat upon the head of the tableâ€™s list of records, each of which is obtained by applying all possible rules (using the unifier)."
11:00:58 <laurie> supki: i think i need to use traverse? so something like ^. key "id" . traverse . _String
11:01:02 <gcganley> lispy: the make script dies with some god awful error saying that I havent installed the "dyn" libraries
11:01:03 <jfischoff> laurie:  ^.. key "Config" . key "Env" . values . _String
11:01:09 <laurie> jfischoff: tyvm
11:01:10 * hackagebot set-extra 1.3.2 - Functions that could be added to Data.Set.  http://hackage.haskell.org/package/set-extra-1.3.2 (DavidFox)
11:01:20 <jfischoff> laurie: well Iâ€™m guessing ;)
11:01:44 <laurie> jfischoff: prob better than my guesses. but i'd never heard of values, so useful regardless
11:01:44 <gcganley> J_Arcane: have you seen Write Yourself a Scheme in 48 hours? its all in haskell
11:02:01 <supki> laurie: yeah, the immediate problem is that _String does not traverse the list by itself
11:02:24 <jfischoff> laurie: https://hackage.haskell.org/package/lens-aeson-1.0.0.3/docs/Data-Aeson-Lens.html#v:values
11:02:25 <laurie> supki: yeah, i was under the (rather silly) impression that ^.. would magically solve that for me :)
11:02:30 <supki> laurie: jfischoff's thing is what the traversal should look at the end
11:02:42 <laurie> jfischoff: ah, yeah, thanks
11:03:00 <jfischoff> as supki pointed out, it is a traversal
11:03:02 <J_Arcane> gcganley: Yeah, I started on it, but I didn't know enough Haskell yet to get far with it, and I was a little disappointed that it doesn't actually do the "Scheme" part by example. IT should probably more precisely be 'Write Yourself a Lisp' with "Make it Scheme" as an exercise.
11:03:10 <ReinH> gcganley: unfortunately, it's quite old and doesn't work with modern GHC as written. It's possible to work around it.
11:03:36 <ReinH> Also some of the choices are questionable
11:03:40 <lispy> gcganley: this error message? http://stackoverflow.com/questions/11711197/could-not-find-module-prelude-dyn-libraries-for-package-base
11:03:50 <ReinH> IORefs for storing the environment, especially
11:04:01 <gcganley> ReinH: its giving me a major headache for marshaling to C# and .Net in general
11:04:06 <J_Arcane> Still, I know a *little* bit more now, and if I was more interested in making it my own, that wouldn't necessarily be a bad thing in my current case.
11:04:14 <ReinH> gcganley: what is?
11:04:52 <laurie> jfischoff: your answer worked perfectly, thanks :)
11:04:57 <gcganley> ReinH: no dynamic linking, using the c ffi on both ends to connect them, the repo is at https://github.com/gcganley/subnet
11:05:28 <gcganley> ReinH: im using the make file
11:05:51 <lispy> gcganley: Have you already read both of these pages? https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/using-shared-libs.html https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/win32-dlls.html
11:06:07 <lispy> gcganley: I'm currently wondering if your windows install of GHC was not built for dyn libraries
11:06:18 <gcganley> lispy: yeah i skimmed them, didnt really read them fully
11:06:20 <lispy> gcganley: I wonder if you need to build GHC yourself to get them?
11:06:36 <gcganley> lispy: wouldnt be my first time doing it
11:06:48 <lispy> gcganley: At this point, I would try asking one one of the ghc mailing lists. I think there is a ghc-users?
11:06:52 <gcganley> lispy: Im' using haskell platform right now
11:07:14 <gcganley> 2014.2.0.0
11:07:32 <lispy> AFAICT, recent ghc should support this but it must be built with this use-case in mind.
11:08:03 <gcganley> what would be the build-flavour i would have to use?
11:08:39 <lispy> That is a good question :)
11:09:31 <lispy> I wonder if this is related: https://www.mail-archive.com/ghc-tickets@haskell.org/msg04921.html
11:09:43 <hasbero> What are the top 3 benefit of Haskell over language X, aside from good feels?
11:10:12 <numberten> that's a pretty open ended question
11:10:21 <lispy> hasbero: Those kind of open ended questions often lead to unproductive debate.
11:10:41 <lispy> hasbero: Have you read the Why functional programming matters paper?
11:10:44 <numberten> it would be easier if X were an actual language
11:10:56 <lispy> hasbero: http://worrydream.com/refs/Hughes-WhyFunctionalProgrammingMatters.pdf
11:11:11 <juri_> 1> it does not suck like language X. 2> Its sexier. 3> I love it.
11:11:29 <hasbero> lispy: I'm not asking this though. You can do functional programming in any language these days
11:11:39 <juri_> oh, and more cowbell!
11:11:56 <lispy> juri_: so much more cowbell
11:12:01 <numberten> hasbero: not really
11:12:29 <hasbero> numberten: not really - why
11:12:49 <lispy> hasbero: I'm not sure what you'd like to learn from this, but be careful with these questions. You're likely to endup (unintentionally?) trolling :)
11:13:18 <hexagoxel> X is like a lambda, but with one unnecessary extra stroke
11:13:31 <hasbero> lispy: it doesn't betray a healthy community if a question "what are the benefits" is suspected as trolling
11:13:36 <lispy> hasbero: Are you trying to figure out why YOU should use/learn Haskell? Do you want to convince someone else? or?
11:13:55 <hasbero> lispy: I thinking learning Haskell is useful. For the way it works.
11:13:59 <hasbero> lispy: as a mental model
11:14:00 <juri_> i want to know why not idris.
11:14:03 * juri_ runs.
11:14:38 <hasbero> lispy: but I'm not asking this, I'm asking once I know Haskell, why would I want to use Haskell for a project. Does it have clear benefits, compared to just taking what I learned and using it, in, say, Java
11:14:52 <clrnd> hasbero, yeah I'd say it does
11:15:03 <hasbero> All right, what do you feel those are
11:15:19 <saml> for all x,  f x = g x. does that mean f = g ?
11:15:38 <lispy> hasbero: To that end, purity is a good constraint. It does constrain you but it does so in a way that leads to better designs.
11:15:40 <clrnd> there are 2 strong reasons: 1) it will teach you a lot about other aspects of computer science that aren't often found in other languages, and 2) it is a really good language
11:15:51 <J_Arcane> IME, idiomatic code in a functional language generally takes 1) less time, 2) less code, 3) less debugging.
11:16:09 <saml> mathematically yes.. but i think there can be infinite variations/implementations of a function that maps same input to same output to f
11:16:12 <hasbero> lispy: you can implement reentrant stateless functions in any language though
11:16:24 <clrnd> yeah purity can be (almost) anywhere, even in QBASIC, but there are limits
11:16:39 <clrnd> for instance it can be really slow to copy stuff arround in Java
11:16:44 <hasbero> clrnd: it's a good language isn't a benefit honestly
11:16:45 <clrnd> or to recurse in say, C
11:16:50 <hasbero> It's an opinion
11:16:52 <lispy> hasbero: but the compiler won't enforce it, say, python
11:16:58 <clrnd> haskell is thought to do this thing really really well
11:17:13 <hasbero> lispy: sure but enforcing it has drawbacks as well.
11:17:23 <hasbero> lispy: a program can't really be 100% pure
11:17:38 <J_Arcane> clrnd: I think this is why FP clicked with me. I wouldn't call my old BASIC code functional, but it was more structured than most even in the linenumbered days, and my biggest frustrations were generally when the language just couldn't do something I wanted.
11:17:41 <hasbero> lispy: I see the choice which parts to be and which parts not to be are mine to decide
11:17:52 <clrnd> exactly J_Arcane
11:18:03 <ReinH> saml: f x = g x => f = g for an reasonable definition of =
11:18:12 <ReinH> *any
11:18:32 * lispy doesn't understand the point of this discusson and has other things to do
11:19:26 <ReinH> saml: for instance, I would consider f = (+2) and g = (+1) . (+1) to be equivalent.
11:19:46 <hasbero> I'm saying it's interesting Haskell does what it does.
11:19:52 <tzaeru> somehow I'd really imagine that there are some projects for which pure functional programming just doesn't map very well.
11:19:55 <hasbero> But it's interesting in an academic way.
11:19:59 <hasbero> Like SmallTalk and Lisp.
11:20:02 <ReinH> saml: equational reasoning works, after all
11:20:03 <hasbero> And Brainfuck
11:20:11 <tzaeru> so ofc if there's a person who only does those kind of projects, there'd hardly be a reason to choose a FP language over something else..
11:20:15 <hasbero> It's less interesting for real projects.
11:20:32 <J_Arcane> What pushed me over though, was writing a roguelike in Python. If I never write another constructor pattern as long as I live, it'll have been too many already.
11:20:36 <tzaeru> but then, I'm not familiar well with any FP language.
11:21:11 * hackagebot scotty 0.9.1 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.9.1 (AndrewFarmer)
11:21:25 <hasbero> Anyway folks, keep going strong.
11:21:33 <tzaeru> J_Arcane, funny, I've mostly been doing python lately on my own projects because I find it insanely suitable for game dev ;P
11:21:38 <clrnd> tzaeru, sure, there is a paper on how to do a sound card driver in ahskell, but I'd say it's not the right tool for those (yet) :P
11:22:10 <tzaeru> and well, almost all of my own projects are games or tools for games or prototyping ideas for games or graphics and so on
11:22:36 <J_Arcane> tzaeru: It's not a good choice anymore, no. The libraries are poor, the performance is poor, and really, just anything involving a lot of random object creation in that language was a pain.
11:22:52 <tzaeru> so naturally I try to map problems generally found in game dev to functional programming. I find that difficult.
11:23:32 <tzaeru> J_Arcane, well, I mostly work on a C++ game engine that has a fully exposed Python bindings. so performance and library quality isn't an issue.
11:24:56 <saml> ReinH, exactly. to me (+2)   and (+1) . (+1)  are different. but outcome is same
11:25:01 <saml> equivalent, i guess
11:25:27 <J_Arcane> tzaeru: Yeah, I was writing in Py2.7 with libtcod.
11:25:29 <tzaeru> to me, anyway, it's difficult to think of, say, a small RPG in terms of functional programming compared to object-oriented programming. I think of the RPG as a set of spaces (be they 2D or 3D) which have a set of entities, which have a set of properties.
11:25:55 <tzaeru> well, that's really the core there is to almost any game.
11:26:07 <c_wraith> saml: they would generally be considered extensionally equivalent, but intensionally different.
11:26:34 <c_wraith> saml: that is, the external view is the same, even though the internal view is the same
11:26:46 <tzaeru> so in my thinking the data and the ordering of data is really the key, not what should be done on that data.
11:26:54 <c_wraith> saml: err, internal view is different
11:28:09 <J_Arcane> tzaeru: I was actually planning on writing a text-mode RPG in my functional Lisp now that I have random and some basic file IO.
11:29:18 <J_Arcane> What was painful for me in Python was the lack of true first-class values. So for instance, if I wanted to generate a weapon object, I had to go through a bunch of tedious intermediary steps just to get to where I had that object.
11:29:52 <ReinH> c_wraith: also we like to work with leibnitz equality because it lets us do equational reasoning... and because it works...
11:30:13 <c_wraith> ReinH: that's a term I'm unfamiliar with.  time to do some reading!
11:30:37 <ReinH> c_wraith: leibnitz equality is a = b iff P(a) = P(b)
11:30:38 <tzaeru> J_Arcane, well, OOP alone is not sufficient to make coding a RPG fun and effortless :P
11:30:47 <tzaeru> on my current RPG project I have set up a comprehensive entity-component system
11:30:53 <c_wraith> ReinH: for what P?
11:31:02 <ReinH> c_wraith: forall P
11:31:06 <J_Arcane> tzaeru: IF anything, it seemed to make it more painful than if I'd coded it in pure imperative, like in the old days. XD
11:31:17 <c_wraith> ReinH: isn't that equivalent to extentional equality then?
11:31:37 <tzaeru> J_Arcane, yeah, this is true. from some reason OOP is commonly taken as THE solution that should be enough on its own, when it seriously is not >_>
11:31:37 <ReinH> c_wraith: Yes.
11:31:46 <ReinH> c_wraith: in philosophy it is also known as http://en.wikipedia.org/wiki/Identity_of_indiscernibles
11:31:50 <J_Arcane> Now, in Haskell, or a Lisp, I'd probably just make a type or a struct and store *that* in a list, and be good to go from the off without any intermediary 'design patterns' that map my stats to a usable object.
11:31:52 <ReinH> Some things have many names ;)
11:31:53 <c_wraith> ReinH: thanks for the pointers
11:31:58 <ReinH> c_wraith: but they are, of course, equal!
11:32:00 <ReinH> ;)
11:32:18 <tzaeru> it's generally a bit stupid that OOP is considered the prime thing in design in those languages. people should rather thinking in components and so.
11:32:40 <tzaeru> *should rather be
11:32:53 <J_Arcane> tzaeru: Yes. The other myth that I think pushes OOP is that there's some kind of difference between object state and any other kind of state. I really don't think that's true.
11:33:41 <tzaeru> myeah. I really tend to see OOP as more a nice language feature to have that helps to organize data and functionality together, rather than as the all-covering silver bullet for anything at all :P
11:33:58 <tzaeru> it's nice to look into a file and see all relevant data and functions using that data at once!
11:34:30 <tolt> Is there a template haskell function written that takes a string to Q Exp and evaluates it as haskell?
11:35:04 <ReinH> saml, c_wraith: Also nlab has a (surprisingly accessible) page on equality http://ncatlab.org/nlab/show/equality
11:35:33 <saml> hard for me :P
11:36:12 * hackagebot temporary-resourcet 0.1.0.0 - Portable temporary files and directories with automatic deletion  http://hackage.haskell.org/package/temporary-resourcet-0.1.0.0 (ThomasTuegel)
11:37:25 <ReinH> saml: You should try looking at any other page on nlab... ;)
11:37:45 <ReinH> saml: So basically, f x = g x => f = g for some values of =
11:37:57 <ReinH> We like to use extensional equality to reason about programs
11:38:34 <J_Arcane> tzaeru: Yes. I tended to think of objects as just handy containers for confining state, at best, and frequently in functional or functional-friendly languages not even necessary. I don't know diddly-squat about Racket objects because I've never needed them, ditto CL, and I only know Heresy's object system because I wrote it.
11:38:45 <n4x> I bet most nlab pages is actually lots of cool-sounding words together that don't actually make sense!
11:38:47 <ReinH> saml: but operationally, f and g might do different amounts of work, etc
11:39:08 <ReinH> n4x: This gives me an idea. I am going to write a markov generator for nlab pages.
11:40:00 <n4x> ReinH: then add a few haskell books to it
11:40:13 <n4x> automatic theorems for free!
11:40:45 <saml> excellent ReinH
11:40:47 <ReinH> heh
11:41:07 <ReinH> n4x: The game is to determine whether the text is an actual nlab page or generated ;)
11:41:31 <n4x> that's is basically the halting problem
11:42:07 <nuncanada> Problem with cabal, when i use sandbox it seems to work fine. But without sandbox, i am getting problems like "/usr/bin/ld: cannot find -lHStext-1.2.0.3-ghc7.8.3" for almost every package
11:42:33 <nuncanada> The library exists and is here /home/nuncanada/.cabal/lib/text-1.2.0.3/ghc-7.8.3/HStext-1.2.0.3.o
11:42:54 <nuncanada> But seems that cabal is not putting it in the library path during linking
11:44:49 <shock_one> Why is thunk called so?
11:45:32 <lisbeth> function where f x = square root of x?
11:46:17 <levi> shock_one: Mostly historical reasons, as far as I know.
11:46:22 <lpaste> nuncanada pasted â€œLast line cabal - problems linkingâ€ at http://lpaste.net/117941
11:46:34 <shock_one> levi: and what are the historical reasons?
11:47:35 <levi> shock_one: Someone, ages ago, invented the name "thunk" for stub routines in assembly, IIRC. People liked the name and adopted it for similar things.
11:47:49 <ReinH> shock_one: http://en.wikipedia.org/wiki/Thunk
11:49:03 <jfischoff> http://archive.computerhistory.org/resources/text/algol/ACM_Algol_bulletin/1064045/frontmatter.pdf
11:49:15 <jfischoff> doesnâ€™t say why he called them thunks though
11:49:19 <levi> Some names have deep, insightful etymologies. Others were just sounds people liked.
11:49:22 <shock_one> levi, Your answer somehow reminds me lazy evaluation. Now I guess I have to go the the assembly room and ask them why a subroutine is called thunk.
11:50:24 <shock_one> ;)
11:51:16 <ReinH> Sometimes the answer to a "why?" question is "why not?" ;)
11:51:21 <jfischoff> http://end.translatum.gr/wiki/thunk#Etymology_3
11:51:39 <shock_one> jfischoff: thunk you very much.
11:52:01 <ReinH> Haha, past tense of "think"? That's actually a far better etymology than I could have imagined.
11:52:03 <ReinH> jfischoff: <3
11:52:07 <jfischoff> np it just took some thunking â€¦ hiyo!
11:52:20 <jfischoff> ReinH: :D
11:52:27 <ReinH> Although I do also like "the supposed sound made by data hitting the stack"
11:52:31 <ReinH> jfischoff: I SEE WHAT YOU DID THERE
11:52:48 <levi> I always wonder about uncited "claims of the inventors" though.
11:52:58 <ReinH> levi: shush, it's a good story :p
11:53:51 <levi> I wonder even more when it's a particularly good story. :)
11:54:34 <levi> "Just so" stories are fun even if they're not entirely true to history.
11:56:13 * hackagebot categories 1.0.7 - Categories  http://hackage.haskell.org/package/categories-1.0.7 (EdwardKmett)
11:57:16 <lisbeth> what is the opposite function of floor?
11:57:52 <lisbeth> > floor 10.0
11:57:53 <lambdabot>  10
11:58:19 <znst> ceiling 4.2
11:58:24 <znst> > ceiling 4.2
11:58:26 <lambdabot>  5
11:58:52 <lisbeth> I am looking to convert to float though
11:59:29 <shock_one> lisbeth: what are you trying to accomplish?
11:59:39 <lisbeth> I have a function f x y
11:59:42 <lisbeth> where x and y are integers
11:59:51 <lisbeth> but I need to do an operation on x which can only be done on a float
12:00:10 <shock_one> Like what?
12:00:13 <znst> > fromIntegral 3
12:00:14 <lambdabot>  3
12:00:17 <lisbeth> I am going to try x / 1 though
12:00:22 <lisbeth> and see if that can do it
12:01:01 <shock_one> Maybe you don't really need a float.
12:01:56 <nuncanada> changed to packaged cabal-install 22 and it worked... Some misconfiguration when you install thru cabal install cabal-install?
12:01:58 <lisbeth> maybe
12:02:17 <shock_one> lisbeth: so, what are you trying to acccomlish?
12:02:31 <znst> > fromInteger 7 :: Float
12:02:32 <lambdabot>  7.0
12:02:58 <lisbeth> I'm trying to use sqrt
12:02:59 <lisbeth> on something that's explicitly an int
12:03:22 <shock_one> And why do you need a square root?
12:03:33 <lisbeth> becaues I am calculating prime numbers
12:03:39 <shock_one> No, I'm not a psychologist, if you're wondering.
12:05:17 <shock_one> And why do you write your own algorithm for calculating prime numbers? Let me guess: Project Euler.
12:05:42 <lisbeth> no it is just an arbitrary task to help get used to the syntax of haskell
12:06:33 <lisbeth> here's my code: http://lpaste.net/117942
12:07:08 <Hijiri> > fromIntegral (5 :: Int) :: Float
12:07:09 <lambdabot>  5.0
12:07:15 <Hijiri> oh, I was scrolled up
12:07:35 <athan> shock_one: I'm actually wokring on a concurrent, low-level prime number enumerator!
12:07:39 <athan> :D
12:08:32 <shock_one> athan: Is that so? What's your opinion on the Riemann hypothesis?
12:09:26 <athan> shock_one: It looks like it'll help with this project! :P
12:09:59 <estulticia> someona was discussing aes earlier, he might want to check this out https://stribika.github.io/2015/01/04/secure-secure-shell.html
12:10:14 <shock_one> But you can't use it until you prove it. And when you prove it, the project won't matter that much.
12:10:35 <Marlin> in `join (+)' what is Monad m?
12:10:47 <RchrdB> Marlin: (->) a
12:10:59 <athan> shock_one: Thank you, I'm gonna dig into this
12:11:10 <RchrdB> lisbeth: you can avoid the need to take the sqrt of x by squaring y instead.
12:11:28 <shock_one> athan: you're always welcome.
12:11:33 <Marlin> RchrdB a function taking one argument and returning what?
12:11:45 <athan> (:
12:11:50 <RchrdB> lisbeth: since (sqrt x >= y) == (x >= y*y)
12:11:52 <lisbeth> RchrdB, wouldn't I just run into the same issue though?
12:11:57 <srhb> Marlin: No, that's the Monad.
12:12:05 <lisbeth> oh thatks a good idea
12:12:06 <Marlin> srhb hmm
12:12:14 <Marlin> not clicking yet
12:12:15 <srhb> Marlin: Remember that Maybe is a Monad, but Maybe Int is not
12:12:36 <Marlin> so (->) a has a kind * -> *?
12:12:45 <srhb> (->) a does
12:12:53 <srhb> (->) has kind * -> * -> *
12:12:53 <RchrdB> Marlin: the syntax in the (forall a. (->) a) monad is a little odd, but yeah
12:12:55 <Marlin> yeah that is what i meant
12:13:10 <srhb> Marlin: And what you wrote. My brain neglected to read it right. :/
12:13:35 <srhb> Marlin: Perhaps [] a looks more familiar.
12:13:42 <Marlin> couldn't (->) also have a kind of * -> * too though?
12:13:50 <srhb> How so?
12:14:00 <Marlin> (a -> b)
12:14:14 <Hijiri> but you're applying both a and b
12:14:16 <shock_one> lisbeth: you can start from 3 and then increment by 2, since there is only one even prime.
12:14:31 <RchrdB> Marlin: you can think of ((->) a) as (a ->), which has kind (* -> *), so when you feed it a (b), you get (a -> b), which is a thing with kind (*).
12:14:31 <Hijiri> * -> * means you can apply it to just one type and get a type
12:14:34 <lisbeth> oh thats another great idea
12:15:10 <Marlin> ok
12:15:14 <srhb> Marlin: I guess you're thinking (a -> b -> c) has not fully applied one of the ->s. That's not so. Recall that -> is right associative
12:15:40 <srhb> Marlin: So it's really (a -> (b -> c))
12:15:56 <Marlin> :k (a -> b -> c)
12:15:57 <lambdabot> Not in scope: type variable â€˜aâ€™
12:15:57 <lambdabot> Not in scope: type variable â€˜bâ€™
12:15:57 <lambdabot> Not in scope: type variable â€˜câ€™
12:16:03 <lisbeth> wow that's alot faster
12:16:08 <lisbeth> I don't know why I didn't think of that
12:16:49 <Marlin> I have been tryiing to write this with (->) syntax that shows the relationship between -> and m but I wasn't able to do it
12:16:51 <Marlin> like this for []
12:16:57 <Marlin> :t join :: ([] ([] a)) -> [] a
12:16:58 <lambdabot> [[a]] -> [a]
12:18:04 <c_wraith> Marlin: you mean like  join :: (a -> (a -> b)) -> (a -> b) ?
12:18:18 <Marlin> I meant using (->) a syntax
12:18:25 <Marlin> `(->) a'
12:18:26 <RchrdB> lisbeth: for calculating primes, you can also calculate (ceiling (sqrt (fromIntegral x)) >= y), but I'm not sure how much error the sqrt function is allowed to have, so I'm not sure if it's actually correct to convert to a float, perform floating-point sqrt, and then convert back, when what you actually want is an integer square root that always rounds up.
12:18:50 <c_wraith> :t join :: ((->) a ((->) a b)) -> ((->) a b)
12:18:51 <lambdabot> (a -> a -> b) -> a -> b
12:19:54 <c_wraith> Marlin: it's the same transformation as, like...
12:20:23 <c_wraith> :t (+) :: ((->) Int ((->) Int Int))
12:20:24 <lambdabot> Int -> Int -> Int
12:20:38 <c_wraith> Marlin: it's just converting the -> from infix to prefix
12:20:44 <Marlin> yeah
12:21:06 <lisbeth> RchrdB, I am not using sqrt anymore
12:21:24 <lisbeth> as someone pointes out testing x against y * y is better than testing sqrt x against y
12:21:37 <Marlin>  join :: (a -> (a -> b)) -> (a -> b)  probably makes it even more clear, that the function is "nested"
12:21:42 <J_Arcane> Wheee. http://rextester.com/CLX22519
12:21:50 <lisbeth> not only cause it is easier to deal with the datatypes but it is less expensive to multiply than to calculate a square root
12:21:51 <shock_one> lambdabot: actually you can use the fundamental theorem of arithmetic and divide not by all the even numbers, but by primes only, which would make your functions recursive.
12:22:07 <c_wraith> Marlin: yeah, that's why I wrote it that way the first time.  Those extra parens clarify things a bit.
12:22:38 <shock_one> lisbeth: It was for you. ^ Please tell me if it makes sense.
12:22:55 <c_wraith> RchrdB: I wrote a decent int sqrt a while ago and put it on lpaste: http://lpaste.net/111078
12:23:22 <c_wraith> RchrdB: it rounds down, but whatever.  Easy enough to deal with.
12:23:25 <lisbeth> shock_one that's a little too math heavy for me
12:23:35 <lisbeth> I didn't do well in math past algebra
12:23:37 <Marlin> > (join (+) . join (*)) 10
12:23:39 <Marlin> fun
12:23:39 <lambdabot>  200
12:23:52 <shock_one> lisbeth: so, for a number to be compound, it must divide a prime.
12:24:22 <RchrdB> c_wraith: that's nice and simple. I was really expecting to see Newton-Raphson in that.
12:24:27 <kadoban> That sounds backwards
12:24:30 <c_wraith> RchrdB: that is newton-rhapson
12:24:34 <shock_one> Now you divide by all integers up to a square root. If you divided by primes up to square root, it would be faster.
12:24:41 <c_wraith> RchrdB: err, depending on if I misspelled it.
12:24:44 <shock_one> lisbeth: ^
12:25:03 <RchrdB> oh wait
12:25:05 <RchrdB> yes it is
12:25:07 <RchrdB> <3
12:25:11 <c_wraith> RchrdB: it's just that for sqrt, divide-and-average is a special case of newton-rhapson
12:25:49 <RchrdB> c_wraith: sorry, I skimmed it too fast, saw (`div` 2) and my tiny brain assumed binary search for some reason, even though it has too few legs on the conditional for that.
12:26:40 <c_wraith> RchrdB: actually, that intuition isn't wrong.  it more or less is a binary search - except that it cheats on the termination condition
12:26:41 <lisbeth> why primes?
12:27:11 <shock_one> lisbeth: what do you mean?
12:27:26 <c_wraith> RchrdB: it only gets to cheat on the termination condition because I designed the algorithm pretty carefully. :)
12:27:48 <lisbeth> "if you divide by primes rather than integers it will be faster" (I am paraphrasing)
12:28:03 <RchrdB> N-R converges faster than a binary search, though, when the function being evaluated is well-behaved?
12:28:17 <shock_one> lisbeth: why a number to be compound must divide a prime? It's a proven theorem. https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic
12:28:44 <c_wraith> RchrdB: I think they converge at the same rate...  approximately doubling the precision of the guess at each iteration.
12:28:48 <shock_one> lisbeth: and it will be faster because there are less primes than numbers.
12:28:52 <RchrdB> lisbeth: you don't have to check division by 4 because if your candidate was divisible by 4, you'd have found out that it was divisible by 2 earlier.
12:29:09 <RchrdB> lisbeth: similarly, you don't have to check division by 9 because division by 3 would've told you.
12:29:39 <RchrdB> lisbeth: the only numbers that you *do* need to test division by are the prime numbers up to sqrt(candidate). :)
12:29:57 <lisbeth> oh that makes sense
12:30:31 <EvanR-work> divide a prime?
12:30:35 <EvanR-work> impossible
12:30:43 <shock_one> 3/2 = 1.5
12:30:44 <c_wraith> EvanR-work: pfft.  I divide them by 1 all the time.
12:30:50 <EvanR-work> lol
12:31:12 <EvanR-work> > divMod 3 2
12:31:13 <lambdabot>  (1,1)
12:31:32 <EvanR-work> phooey
12:31:40 <RchrdB> c_wraith: I would expect a binary search over numbers to converge at a rate of one bit at a time, where N-R doubles the number of correct bits with every guess.
12:32:29 <c_wraith> RchrdB: oh, right.
12:33:08 <RchrdB> Unless you try it on a function like (f x = m * x + c), in which case it will converge to *all of them* on the first step. ;)
12:35:00 <lisbeth> ok here's my revised code although it isn't working at the moment: http://lpaste.net/117943
12:35:27 <lisbeth> I have no idea what "naked expression at top level means"
12:35:38 <dmwit> RchrdB: The claim about doubling the number of correct bits must be specific to a particular function (or class of them), too.
12:35:53 <lisbeth> pj
12:35:54 <ReinH> RchrdB: N-R?
12:35:57 <lisbeth> forgot =
12:36:02 <dmwit> lisbeth: You forgot an equal sign on the last line.
12:36:14 <RchrdB> dmwit: yah. It's way better for some ;)
12:36:20 <dmwit> (for posterity: almost wrote "no equal sign on last lign")
12:36:21 <RchrdB> ReinH: yes.
12:36:29 <ReinH> RchrdB: Rephrase. What is N-r?
12:36:29 <shock_one> lisbeth: when I said add two I meant like this: http://lpaste.net/117943
12:36:35 <dmwit> RchrdB: Newton-Raphson
12:36:37 <RchrdB> ReinH: Newton-Raphson.
12:36:39 <ReinH> Thanks
12:36:42 <ThreeOfEight> I'm having a strange problem with cabal when I try to instal tasty
12:36:44 <ThreeOfEight> "ghc-pkg: cannot create: dist/dist-sandbox-8fc54438/package.conf.inplace already exists"
12:36:59 <ReinH> Oh, newton's method. Ok.
12:37:00 <RchrdB> (c_wraith posted this for a rounding-down integer sqrt: http://lpaste.net/111078)
12:37:11 <shock_one> What if you rename the file, ThreeOfEight?
12:37:44 <ReinH> RchrdB: ah
12:37:54 <lisbeth> oh I didn't even think about that
12:37:56 <lisbeth> you're right
12:39:05 <dmwit> ThreeOfEight: Puzzling. Are you on Windows? Is it possible another process is mucking about with that file at the moment?
12:39:11 <lisbeth> holy crap
12:39:13 <lisbeth> thats alot faster
12:39:14 <lisbeth> thanks
12:40:55 <shock_one> lisbeth: actually it doesn't change the asymptotic complexity of an algorithm. So, real scientists would say it's the same slow algorithm. Dividing by primes only, though, does change O.
12:41:15 * hackagebot bumper 0.6.0.3 - Automatically bump package versions, also transitively.  http://hackage.haskell.org/package/bumper-0.6.0.3 (ErikHesselink)
12:41:42 <ThreeOfEight> dmwit: no, I'm not
12:41:45 <lisbeth> heh whatever you say
12:41:53 <lisbeth> all I can say is it's pretty gat damn fast at the moment
12:42:01 <ThreeOfEight> shock_one just gave me an idea though
12:42:09 <ReinH> RchrdB: Right, newton's method converges pretty much immediately with enough precision to just round down, and iirc it's monotonic in this case so you don't have to worry about undershooting?
12:42:13 <lisbeth> In my first iteration of the program I checked against all integers starting from the potential prime down to 1
12:42:18 <lisbeth> so it was very slow
12:42:45 <EvanR-work> you only need to check numbers less than or equal to the square root of the potential prime
12:43:26 <EvanR-work> since a number between 2 and 1 cant be the divisor, unless you go full-rational on my ass again
12:44:23 <EvanR-work> nevermind, wrong argument
12:44:50 <ReinH> ReinH: tbqh I don't really understand the conditions for M-R to be monotone...
12:45:10 <c_wraith> ReinH: talking to yourself again?
12:45:19 <ReinH> Uh. I guess.
12:45:21 <ReinH> RchrdB: ^
12:45:59 <ReinH> Ah. "The Newton method exhibits monotone convergence under partial ordering." I guess I do understand the conditions then.
12:46:20 <ReinH> (http://www.sciencedirect.com/science/article/pii/S0377042700004350)
12:47:16 <ThreeOfEight> okay, I have no idea what that was, but it works now
12:56:15 * hackagebot alex 3.1.4 - Alex is a tool for generating lexical analysers in Haskell  http://hackage.haskell.org/package/alex-3.1.4 (SimonMarlow)
12:56:17 * hackagebot amazonka-core 0.1.4 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.1.4 (BrendanHay)
12:56:19 * hackagebot amazonka 0.1.4 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.1.4 (BrendanHay)
12:56:21 * hackagebot amazonka-autoscaling 0.1.4 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.1.4 (BrendanHay)
12:56:23 * hackagebot amazonka-cloudformation 0.1.4 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.1.4 (BrendanHay)
13:01:25 * hackagebot amazonka-cloudfront 0.1.4 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.1.4 (BrendanHay)
13:01:27 * hackagebot amazonka-cloudsearch 0.1.4 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.1.4 (BrendanHay)
13:01:29 * hackagebot amazonka-cloudsearch-domains 0.1.4 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.1.4 (BrendanHay)
13:01:31 * hackagebot amazonka-cloudtrail 0.1.4 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.1.4 (BrendanHay)
13:01:33 * hackagebot amazonka-datapipeline 0.1.4 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.1.4 (BrendanHay)
13:06:35 * hackagebot amazonka-directconnect 0.1.4 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.1.4 (BrendanHay)
13:06:37 * hackagebot amazonka-dynamodb 0.1.4 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.1.4 (BrendanHay)
13:06:39 * hackagebot amazonka-ec2 0.1.4 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.1.4 (BrendanHay)
13:06:41 * hackagebot amazonka-elasticache 0.1.4 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.1.4 (BrendanHay)
13:06:43 * hackagebot amazonka-elasticbeanstalk 0.1.4 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.1.4 (BrendanHay)
13:11:23 <Guest58932> did anyone install pcre-light on macos?
13:11:37 <clrnd> quick question, can hakyll inline everything in one html file?
13:11:45 <clrnd> even images
13:11:45 * hackagebot amazonka-elastictranscoder 0.1.4 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.1.4 (BrendanHay)
13:11:47 * hackagebot amazonka-elb 0.1.4 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.1.4 (BrendanHay)
13:11:49 * hackagebot amazonka-emr 0.1.4 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.1.4 (BrendanHay)
13:11:51 * hackagebot amazonka-iam 0.1.4 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.1.4 (BrendanHay)
13:11:53 * hackagebot amazonka-importexport 0.1.4 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.1.4 (BrendanHay)
13:12:42 <johnw> you can code hakyll to do pretty much whatever you want
13:12:43 <johnw> Guestyes
13:12:46 <johnw> Guest58932: yes
13:13:11 <Guest58932> port install pcre
13:13:21 <Guest58932> cabal install pcre-light
13:13:28 <Guest58932> gives me pcre.h not found
13:13:52 <petersr> Is there a word like Pythonic in Haskell?
13:14:03 <clrnd> johnw, including exactly what I said? okay
13:16:56 * hackagebot amazonka-kinesis 0.1.4 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.1.4 (BrendanHay)
13:16:57 * hackagebot amazonka-kms 0.1.4 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.1.4 (BrendanHay)
13:17:00 * hackagebot amazonka-lambda 0.1.4 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.1.4 (BrendanHay)
13:17:02 * hackagebot amazonka-opsworks 0.1.4 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.1.4 (BrendanHay)
13:17:03 * hackagebot amazonka-rds 0.1.4 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.1.4 (BrendanHay)
13:17:10 <hiptobecubic> petersr, I think that's a great example of how other languages take a general concept like "idiomatic" and specialize it to no benefit :)
13:20:04 <petersr> hiptobecubic: Ah, so "idiomatic" is actually the word I am looking for. Great! (Also a very interesting point of view that I actually hadn't considered before)
13:20:56 <dmj`> can uuids be monoids?
13:21:29 <hiptobecubic> dmj`, sure? What that be useful for though?
13:21:32 <hiptobecubic> What would*
13:21:49 <johnw> merging two uuids doesn't give you anything that "more" of a uuid
13:21:56 <mseeks> has anyone used the twitter-conduit package recently?
13:22:06 * hackagebot amazonka-redshift 0.1.4 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.1.4 (BrendanHay)
13:22:07 * hackagebot amazonka-route53 0.1.4 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.1.4 (BrendanHay)
13:22:10 * hackagebot amazonka-route53-domains 0.1.4 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.1.4 (BrendanHay)
13:22:12 * hackagebot amazonka-s3 0.1.4 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.1.4 (BrendanHay)
13:22:14 * hackagebot amazonka-sdb 0.1.4 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.1.4 (BrendanHay)
13:22:17 <mseeks> having trouble installing in a sandbox even after rm -rf'ing ~/.ghc
13:22:30 <quchen> Data types can be monoids, "uuid" is not a data type, but represented by one. That representation might be a monoid.
13:22:42 <freeman42> could an EclipseFP user test this please? I would be really grateful (imaginary karma points or stackoverflow reputation) On my machine the warnings are shown no matter what the HLint.hs contents is https://github.com/JPMoresmau/eclipsefp/issues/252 Thank you!
13:22:59 <mseeks> I get "cabal: The following packages are likely to be broken by the reinstalls:
13:22:59 <mseeks> regex-compat-0.95.1
13:22:59 <mseeks> Use --force-reinstalls if you want to install anyway."
13:23:08 <mseeks> I thought this wasn't supposed to happen in a sandbox
13:23:10 <quchen> mseeks: .cabal also contains things
13:23:24 <quchen> A full wipe is usually .cabal and .ghc
13:23:35 <Guest58932> that helped: https://stackoverflow.com/questions/9445496/macos-how-to-tell-cabal-ghc-to-look-in-opt-for-libraries-include-files
13:23:49 <mseeks> quchen: I see, I'll try that
13:23:58 <hodapp> For a use case that involves iteration over a list, but an iteration that requires that I must be able to access adjacent elements (and know when I am at the last element), what is a typical way of solving this? A fold?
13:24:09 <EvanR-work> i can think of a uuid semigroup but
13:24:20 <dmj`> hiptobecubic: I have a table structure that allows for composite keys, where both the keys are uuids. Some tables have a key with one uuid, some have two (composite). Often times its beneficial to have a third table that stores info related to other tables, where the other tables can have differing key structure (one key vs. two keys). I'd like to merge the composite uuid keys into one, so they can all index the same way into the third
13:24:20 <EvanR-work> how would a monoid work
13:24:20 <dmj`> table. Hope that makes sense
13:24:25 <mseeks> quchen: I'm still getting the same error
13:24:47 <EvanR-work> dmj`: so maybe you want a semigroup
13:24:48 <mseeks> after wiping .ghc and .cabal
13:24:58 <dmj`> EvanR-work: the null uuid is identity
13:25:05 <quchen> mseeks: And your sandbox too?
13:25:08 <EvanR-work> identity isnt a uuid
13:25:23 <EvanR-work> or, whats a null uuid
13:25:32 <EvanR-work> and why
13:25:39 <hodapp> what UUID lib are you talking about? I am in need of one
13:25:41 <quchen> I know what a "uuid" is. What is a UUID
13:25:54 <mseeks> quchen: oops I only deleted the cabal sandbox, not ~/.cabal
13:25:56 <quchen> You can't make monoids of apples since apples are not Haskell types
13:26:18 <dmj`> quchen: UUID is the module for Data.UUID, uuid package, that represents uuids.
13:26:30 <quchen> We need something more specific to talk about here. data UUID = UUID Integer; instance Monoid where <> = xor etc works, but hardly makes any sense.
13:26:36 <quchen> Aaah.
13:26:38 <quchen> Thank you.
13:26:43 <dmj`> er, UUID is the newtype wrapper in the Data.UUID module
13:27:02 <dmj`> quchen: yes I thought xor too ! but would this violate the uniqueness properties
13:27:10 <EvanR-work> "91c38f22-fc5d-424e-b1a5-b719226dcd54"
13:27:14 <dmj`> yes
13:27:16 * hackagebot amazonka-ses 0.1.4 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.1.4 (BrendanHay)
13:27:18 * hackagebot amazonka-sns 0.1.4 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.1.4 (BrendanHay)
13:27:20 * hackagebot amazonka-sqs 0.1.4 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.1.4 (BrendanHay)
13:27:22 * hackagebot amazonka-storagegateway 0.1.4 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.1.4 (BrendanHay)
13:27:24 * hackagebot amazonka-sts 0.1.4 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.1.4 (BrendanHay)
13:27:36 <quchen> dmj`: OR and AND will also make monoids
13:27:38 <EvanR-work> so what is a "null uuid"
13:27:44 <johnw> dmj`: what is it that you want from adding two UUIDs?
13:28:02 <johnw> it shouldn't make a "more unique" UUID than the two you started from
13:28:16 <johnw> and since the only purpose of having one is to have a reasonably unique number...
13:28:18 <dmj`> "the nil UUID, as defined in RFC 4122. It is a UUID of all zeros. null u iff u == nil.
13:28:45 <dmj`> johnw: a new uuid
13:28:49 <EvanR-work> eh.
13:28:56 <hiptobecubic> dmj`, what's wrong with xor then?
13:29:00 <johnw> you're going to use old uuids to generate new uuids?
13:29:11 <Cale> You could just define it to be addition modulo 2^n
13:29:14 <dmj`> hiptobecubic: will xor uphold associativity ?
13:29:16 <Cale> But... why?
13:29:28 <Cale> Yes, xor is associative
13:29:33 <EvanR-work> if you just want to combine them, you dont need any identity
13:29:49 <Cale> xor would be addition in (Z/2)^n
13:29:58 <EvanR-work> all zeros will never come up
13:30:10 <hiptobecubic> Cale, you crazy old mathematician.
13:30:19 <Cale> Well, you need an identity for an instance of Monoid.
13:30:32 <hiptobecubic> there's a null UUID in rfc 4122 he said
13:30:37 <EvanR-work> if the goal is monoid, fine. for monoids sake
13:30:43 <hiptobecubic> which is all zeros, which works fine, no?
13:30:47 <Cale> yeah
13:30:59 <johnw> dmj`: why not just generate new UUIDs the same way that you obtained the other ones?
13:31:14 <dmj`> johnw: I could just string concat the two uuids, and use that string as the key into the new table, but then all the keys are no longer uuids, which I guess is fine, since dynamodb doesn't care.
13:31:23 <EvanR-work> with XOR you might as well make it a group right
13:31:25 <Cale> I can see how you might want a way to generate UUIDs which were uniquely determined by pairs of other ones
13:31:35 <hiptobecubic> I think this is the standard XY problem
13:31:47 <hiptobecubic> dmj`, describe what you *actually* want to do
13:31:53 <dmj`> johnw: I could do that, but some tables are better represented with composite keys, instead of every table having its own unique uuid
13:31:54 <Cale> But... that is a little bit funny :)
13:32:26 * hackagebot amazonka-support 0.1.4 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.1.4 (BrendanHay)
13:32:28 * hackagebot amazonka-swf 0.1.4 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.1.4 (BrendanHay)
13:32:28 <Cale> Also, if it's a group operation, you can invert it, so knowing the sum and one of the operands, you can get the other :)
13:32:28 <tasker> I need to create a Data.Hashtable from an external file.. is there any point in operating in the ST monad rather than just IO ?
13:32:30 * hackagebot linear 1.16 - Linear Algebra  http://hackage.haskell.org/package/linear-1.16 (EdwardKmett)
13:32:32 * hackagebot happy 1.19.5 - Happy is a parser generator for Haskell  http://hackage.haskell.org/package/happy-1.19.5 (SimonMarlow)
13:32:34 * hackagebot h-gpgme 0.3.0.0 -   http://hackage.haskell.org/package/h-gpgme-0.3.0.0 (rethab)
13:33:09 <Cale> tasker: The ability to have the operation which uses the hashtable be a pure function of the contents of the file in the end.
13:33:34 <tasker> Cale: Yeah, I guessed this was true but I'm not really that familiar with ST.
13:33:39 <Cale> tasker: Otherwise, not really.
13:33:52 <Cale> tasker: Are you *sure* that you really need Data.Hashtable?
13:34:09 <tasker> Cale: Need O(1) lookups if I can
13:34:13 <tasker> Data.Map is just too slow
13:34:27 <Cale> So you have a program which uses Data.Map and it's too slow?
13:34:30 <tasker> Yes
13:34:32 <Cale> okay
13:34:51 <EvanR-work> versus the speed of hashing then traversing a hash table
13:34:51 <Cale> Have you tried unordered-containers?
13:35:09 <Cale> Yeah, hashtable lookup isn't really O(1)
13:35:17 <Cale> that's sort of a BS statistic which I like to pick on
13:35:47 <Cale> It's only O(1) if you fix the size of the hashtable, at which point, you could also claim that Data.Map lookup is O(1)
13:35:48 <tasker> Cale: Yeah, also too slow :p
13:35:58 <EvanR-work> IntMap ?
13:36:28 <tasker> Once the table is created it is fixed size. I won't ever have to add to it etc.
13:36:45 <Cale> Is it sparse?
13:37:02 <tasker> Cale: Hm, I don't think I know what that means in this context.
13:37:05 <Cale> What is the key type?
13:37:11 <tasker> (Int, Int)
13:37:24 <EvanR-work> 2d array
13:37:32 <Cale> (I'm asking mostly to determine if using an array would be more reasonable)
13:37:36 * hackagebot endo 0.1.0.0 - Endomorphism utilities.  http://hackage.haskell.org/package/endo-0.1.0.0 (PeterTrsko)
13:37:40 <tasker> EvanR-work: That is my next thing I'm going to try
13:37:56 <tasker> I have a gigantic but sparse matrix, where the only operations I need are lookups at various coordinates
13:38:04 <lpaste> dgpratt pasted â€œwin64 build errorâ€ at http://lpaste.net/4202066010926219264
13:38:08 <tasker> So my most stupid guess was some kind of map
13:38:21 <dgpratt> trying to build this library https://github.com/corsis/clock on Windows (64-bit) results in an error
13:38:31 <EvanR-work> encoding (Int,Int) into an Int and using IntMap might work
13:38:40 <dgpratt> is there an easy fix?
13:38:41 <EvanR-work> unless the Ints are too big
13:39:05 <kadoban> tasker: Are you sure it's actually the lookups that are the slow part?
13:39:07 <tasker> EvanR-work: I could use (Int, Int) as a key on an unordered-container hashmap
13:39:14 <johnw> endo looking interesting
13:39:18 <tasker> kadoban: They are currently the only part :P
13:39:31 <Cale> I wonder if ekmett's structures would be better for you
13:39:35 <kadoban> tasker: Well, that's unlikely. You're at least doing input as well, no?
13:39:43 <EvanR-work> laziness might be obscuring the slow part
13:39:47 <tasker> kadoban: The input isn't measured by criterion
13:39:56 <tasker> ..unless I've misunderstood criterion
13:40:27 <tasker> Cale: Could you point me towards what you mean? I saw he has a sparse matrix lib, if that is what you mean. Its on my list of stuff to test
13:40:37 <Cale> https://github.com/ekmett/structures
13:41:29 <tasker> Cale: Thanks.
13:42:41 <Cale> Actually, no, that won't help you iirc.
13:43:08 <Cale> er
13:43:28 <tasker> Yeah it doesn't look like it from first glance
13:43:31 <Cale> I forget. It does something faster than Map and something slower :)
13:43:39 <tasker> insert faster, lookup slower :p
13:43:41 <tasker> it looks like
13:43:42 <Cale> and I can't remember which way around it was
13:44:40 <Cale> Don't trust the asymptotic analysis to tell you what's fast
13:44:42 <Cale> :)
13:45:02 <breadmonster> Cale, Is there a more modern alternative to Real World Haskell?
13:45:15 <hodapp> what modernness issues does RWH have?
13:45:26 * hodapp grabs his print copy and a red marker
13:45:28 <Cale> breadmonster: I don't know. It's a little strange to me that RWH wouldn't be considered modern :)
13:45:29 <breadmonster> hodapp, A lot of RWH's examples don't work.
13:45:36 <Cale> They might be slightly off
13:45:43 <quchen> hodapp: Parsec 2, old Control.Concurrent for example
13:45:49 <Cale> hmm
13:45:49 <tasker> Cale: I guess that is true. To be fair, I'm actually benchmarking everything I try :)
13:45:55 <hodapp> quchen: those examples do not work?
13:46:07 <breadmonster> quchen, Control.Exception too, I think?
13:46:10 <quchen> hodapp: Those chapters use old libraries
13:46:12 <quchen> breadmonster: Possibly
13:46:17 * hackagebot endo 0.1.0.1 - Endomorphism utilities.  http://hackage.haskell.org/package/endo-0.1.0.1 (PeterTrsko)
13:46:19 <hodapp> quchen: good to know.
13:46:53 <EvanR-work> benchmarking for your own enjoyment might be even sicker than for marketing purposes ;)
13:46:55 <quchen> hodapp: Well, "old" as in "were current when the book was written". I think at some point they asked whether the community would like an updated version.
13:47:12 <breadmonster> And please tell me the community said yes.
13:47:13 <EvanR-work> i.e. how do you design your benchmarks to convince yourself of something, without deluding yourself
13:47:26 <Cale> tasker: The fact that it's a structure which uses arrays would make me intuitively expect that it's eventually really good at lookups
13:47:38 <Cale> tasker: But perhaps that's not true
13:48:09 <quchen> breadmonster: I don't remember to be honest.
13:48:10 <tasker> EvanR-work: I guess that is true. How else can I make a rational choice though?
13:48:25 <EvanR-work> impossible
13:48:35 <hodapp> read lots and lots of Ayn Rand.
13:48:36 <Cale> tasker: How big is this sparse matrix?
13:48:39 <quchen> breadmonster: I think the authors were concerned that updating would take a lot of time, but had doubts whether the market would appreciate it enough.
13:49:02 <Cale> Also, there are some sparse linear algebra libraries on hackage...
13:49:08 <Cale> (if it's really a matrix)
13:49:18 <hodapp> hmmm, I bought my copy in 2013 May
13:49:45 <breadmonster> quchen, So are there any alternatives?
13:50:04 <tasker> Cale: It's working on biological data, and I have some control over how I "bin" it, but definitely more than 5k x 5k, and it would be very nice if it could go bigger.
13:50:23 <quchen> breadmonster: RWH is the only book of its kind that I know of.
13:50:30 <tasker> I don't know "how sparse" it is though..
13:50:39 <tasker> actually, how do people usually measure sparsness ?
13:50:55 <tasker> just % occupation ?
13:51:05 <breadmonster> quchen, Hmm, unfortunate.
13:51:11 <crobbins> 1/density
13:51:30 <breadmonster> quchen, Is there a book that deals with Haskell design patterns and best practices?
13:52:50 <johnw> breadmonster: not that I know of
13:53:09 <hodapp> I'm not really aware of many 'design patterns' in Haskell, given that 'design pattern' basically means 'an abstraction that is clear intuitively but that a language is not expressive enough to cover'.
13:53:41 <breadmonster> hodapp, Oh okay, I thought a design pattern was a way of organizing code so that people know at once how you're solving a particular problem.
13:53:45 <johnw> hodapp: the "functor fixed point" approach to recursion data structures might count as a design pattern
13:53:55 <johnw> since it's not obvious, but methodically applied has certain benefits
13:54:19 <quchen> hodapp: Monad transformer stacks tend to approach that domain.
13:54:43 <hodapp> breadmonster: To me, that's only a design pattern if it can't be an abstraction within the language.
13:54:55 <EvanR-work> the "function" pattern
13:55:08 <johnw> the CPS pattern
13:55:09 <lisbeth> http://lpaste.net/117948
13:55:18 <lisbeth> having some issues with my datatypes in my new iteration of prime number generator
13:55:32 <quchen> The message passing pattern
13:55:45 <lisbeth> as far as my limited understanding of how typeclasses work it should be: Int -> [Int] -> Bool
13:55:50 <johnw> the tying-the-knot pattern
13:55:50 <quchen> "Pattern" is really just a different word for "abstraction" with a lot of room for interpretation
13:55:54 <lisbeth> but ti's saying something different
13:56:10 <quchen> johnw: It would be interesting to gather a couple of these. Article idea! :-)
13:56:24 <johnw> I see a code pattern as a commonly recurring thing, across disparate code bases, that has a unique enough "signature" to be recognizable no matter who wrote it
13:56:45 <johnw> quchen: oh hey, Article idea!
13:57:29 <hodapp> :t scanr
13:57:30 <quchen> johnw: DIBS
13:57:30 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
13:57:36 <hodapp> why did no one tell me about scanr?!
13:57:37 <johnw> quchen: all yours!
13:57:53 <johnw> we reserve knowledge of scanr for only the most elite among us
13:58:13 <hodapp> johnw: you Haskell bastards are all the same :|
13:58:35 <quchen> scanr requires -XExpert, which I have not unlocked in my level 4 GHC
13:58:37 <Cale> breadmonster: It is that, but we don't tend to call things design patterns once the abstraction can be turned into a definition within the language. It just becomes some library that you use.
13:58:37 <johnw> cool, I'm a Haskell bastard now!
13:58:53 <hodapp> johnw: first you wrote 300 monad analogy tutorials to try to hold me down...
13:58:55 <hodapp> johnw: now this?
13:59:07 <Cale> breadmonster: For language designers, design patterns are signs of the failure of the language to capture certain ideas.
14:00:13 <breadmonster> :t scanl
14:00:14 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
14:00:20 <EvanR-work> johnw: "bottom-first design patterns"
14:00:32 <breadmonster> > scanl (+) 0 [1,2,3]
14:00:33 <lambdabot>  [0,1,3,6]
14:00:36 <hodapp> is "using the type system" a design pattern?
14:00:53 <breadmonster> Is scanl some sort of accumulator with folding?
14:00:59 <breadmonster> :t foldl
14:01:00 <lambdabot> (b -> a -> b) -> b -> [a] -> b
14:01:23 <breadmonster> scanl (flip (:)) [] [1,2,3]
14:01:29 <breadmonster> > scanl (flip (:)) [] [1,2,3]
14:01:31 <lambdabot>  [[],[1],[2,1],[3,2,1]]
14:01:33 <hodapp> breadmonster: I think that's literally what it is.
14:02:02 <breadmonster> > scanr  (:) [] [1,2,3]
14:02:03 <lambdabot>  [[1,2,3],[2,3],[3],[]]
14:02:57 <lisbeth> I think it's on the first line that I am having issues
14:03:03 <lisbeth> with my datatype setup
14:03:15 <shock_one> Cale: I agree with that, but people continue to call them design patterns even when they're built into the language. Like Singleton in Scala.
14:03:32 <breadmonster> @src scanl
14:03:32 <lambdabot> scanl f q ls = q : case ls of
14:03:32 <lambdabot>     []   -> []
14:03:32 <lambdabot>     x:xs -> scanl f (f q x) xs
14:04:30 <breadmonster> Yup, got that right!
14:04:35 <breadmonster> Awesome.
14:07:10 <ReinH> johnw: Kent Beck describes patterns as a way to codify and repeat a decision an expert might make given certain requirements
14:07:49 <ReinH> A less charitable definition might be that a design pattern is just something the language isn't expressive enough to provide for you...
14:08:29 * EvanR-work is reading the 400 page book enterprise integration patterns right now
14:08:45 <EvanR-work> it definitely is going with the first version of the definition
14:09:03 <ReinH> Well, Kent's work on design patterns is pretty influential in the OOP community.
14:09:19 <ReinH> I definitely prefer it to gang of four patterns
14:09:30 <Cale> shock_one: I think that wouldn't happen forever though -- it's only because that one has been a pattern for a long while in other languages that the name is sticky.
14:09:33 <ReinH> Which are much more like "things the language can't express for you"
14:09:48 <johnw> ReinH: that's a interesting way to look at it
14:10:00 <ReinH> e.g. iterator basically disappears in a language with internal enumeration like Ruby
14:10:04 <johnw> "more complex feature interactions than would be obvious to a beginner"
14:10:12 <lisbeth> I don't mean to bother you guys but could anybody tell me what's wrong with my typeclassing in the first line her: http://lpaste.net/117948 ?
14:10:18 <lisbeth> I'm still very new to haskell and I have not mastered the datatypes yet
14:10:39 <ReinH> johnw: One issue is that people seem to forget the "given certain requirements" caveat. Design patterns are a solution to a common problem, but must be considered in context.
14:10:42 <Cale> lisbeth: You're being way more on-topic than anyone else is right now ;)
14:10:55 <ReinH> Throwing patterns at a code base is not a way towards better design.
14:10:58 <lisbeth> why thank you
14:11:14 <ReinH> lisbeth: technically I think we are bothering you by being off topic ;)
14:11:35 <lisbeth> heh
14:11:38 <Cale> lisbeth: Your function takes a single pair argument, but its type signature says that it takes two separate arguments
14:11:39 <lisbeth> well there's always #haskell-blah
14:11:54 <ReinH> lisbeth: I accept your rebuke. ;)
14:12:02 <lisbeth> woah there
14:12:05 <Cale> I think you meant to write  primetester x (y:ys)
14:12:07 <lisbeth> not rebuking anybody
14:12:07 <ReinH> lisbeth: kidding
14:12:11 <ReinH> thus the ;)
14:12:36 <EvanR-work> the library pipes is making my head explode. why doesnt anyone talk about using this lib in the channel (much)
14:12:50 <sm> for another perspective, OO patterns were inspired by this: https://en.wikipedia.org/wiki/Pattern_language
14:13:02 <EvanR-work> this seems like a great way to structure the IO part of the program
14:13:32 <Cale> EvanR-work: pipes is great, but it's also sort of really unfortunate what goes on at the type level in that library (and most libraries like it)
14:13:44 <lisbeth> YAY IT RUNS NOW
14:13:47 <lisbeth> THANKS CALE
14:13:49 <lisbeth> SO FAST GOSH
14:13:52 <Cale> lisbeth: No problem :)
14:13:57 <EvanR-work> like what
14:13:58 <lisbeth> it's a freaking beast, now
14:14:06 <lisbeth> cale if you dont' mind me asking
14:14:11 <lisbeth> actually nvm
14:14:12 <Cale> EvanR-work: Just the obscene number of type parameters that things have
14:14:16 <lisbeth> I answered my own question in my head
14:15:31 <lisbeth> its so freaking fast now I can't believe it
14:16:23 <shock_one> Well, I think we can consider type classes with many parameters as multiple dispatch pattern built-in.
14:16:57 <Cale> lisbeth: Did you know that you can just eliminate the intermediate primes' definition if you separate out the fact that 2 is a prime?
14:17:20 <Cale> lisbeth: i.e.  primes = 2 : [x | x <- [3,5..], primetester x primes]
14:17:40 <lisbeth> oh I didn't think to do it recursively
14:18:31 <shock_one> I did't really ever understand why 1 isn't a prime. It's only divided by itself and 1 after all.
14:18:41 <Cale> shock_one: Because it's a unit.
14:18:48 <shock_one> mzero?
14:19:10 <Cale> and units don't contribute information about the divisibility structure of numbers
14:19:49 <Cale> i.e. unique factorisation in the integers is already up to multiplication by units anyway (and permutation)
14:20:05 <lisbeth> cale, that works
14:20:12 <Cale> So, including it as a prime just makes the statement of that theorem more awkward
14:20:41 <shock_one> Even more, there would be only one prime: 1.
14:20:57 <shock_one> Isn't that beautiful? :)
14:21:00 <hodapp> shock_one: also, because I'm fairly sure it's referring to two *unique* factors.
14:21:11 <Cale> Well, a prime p is a nonzero nonunit such that whenever p | ab, then p | a or p | b.
14:21:22 <Cale> ^^ That's the proper definition.
14:22:05 <shock_one> OK, let me rephrase. Why is it defined as a nonunit?
14:22:21 <Cale> It's a convention to make expressing various things simpler.
14:23:35 <shock_one> Are you saying that all the theoretical base would be valid with 1 as a prime?
14:23:55 <lispy> You'd have to rephrase a lot of things
14:23:58 <Cale> Every integer can be expressed as a product of primes n = p_1 ... p_k  in a way which is unique up to permutation and multiplication of each p_i by 1 or -1 (which are the units in the integers)
14:24:05 <shachaf> Definitions can be whatever you want.
14:24:28 <shachaf> You could call 1 "prime", and then a lot of places that say "assuming so-and-so is prime" would say "assuming so-and-so is prime and not equal to 1"
14:24:52 <lispy> Would a prime by any other definition divide composites so sweetly?
14:25:00 <Cale> Yeah, it's just like programming. You can change the basic library definitions and get by, it's just you're likely to break compatibility a bunch, and it might involve making certain programs more tedious to write.
14:25:17 <Cale> (it might also make others easier to write)
14:26:33 <ReinH> Cale: thoughts on johnw's conduit-simple?
14:27:09 <Cale> ReinH: Is that on Hackage?
14:27:11 <johnw> http://hackage.haskell.org/package/simple-conduit
14:27:28 <ReinH> Woops
14:27:48 <ReinH> I think the names commute...
14:27:50 <Cale> This does look a lot more reasonable.
14:28:10 <ReinH> johnw: how much of this was denotationally designed btw?
14:28:13 <Cale> I'm sure it misses out on a lot of the theoretical pleasantness of pipes of course.
14:28:13 <ReinH> it has that feel to it
14:28:24 <johnw> ReinH: this was actually an accidental design
14:28:28 <ReinH> heh
14:28:28 <johnw> I'm sad to say
14:28:32 <ReinH> you lucked into it
14:28:35 <johnw> Cale: it doesn't
14:28:44 <Cale> johnw: oh?
14:28:46 <johnw> Cale: in fact, I've proven all of that theoretical pleasantness in Coq in fact
14:29:01 <ReinH> Cale: Do not underestimate the johnw ;)
14:29:07 <johnw> Cale: https://github.com/jwiegley/coq-haskell/blob/master/Conduit.v
14:29:08 <ReinH> also in fact in fact
14:29:22 <ReinH> doubly factual
14:29:25 <johnw> exactly!
14:29:29 <ReinH> :D
14:29:33 <joelteon> aifif
14:30:20 <Cale> Well, do you have all the same category structures?
14:30:30 <johnw> they are not exactly the same, no
14:30:33 <Cale> It's hard to imagine how you get them all without having all the type variables
14:30:44 <johnw> my monad is more of a ListT than pipes' monad
14:30:57 <Cale> It would be really nice if somehow we could do all of what pipes does without needing to bind so many variables somehow
14:31:17 <joelteon> With enough variables, anything can be accomplished.
14:31:20 * hackagebot fwgl 0.1.0.1 - FRP 2D/3D game engine  http://hackage.haskell.org/package/fwgl-0.1.0.1 (ZioCrocifisso)
14:31:29 <EvanR-work> Cale: you mean in the Proxy type?
14:31:31 <Cale> yes
14:31:47 <Cale> Has anyone done what I suggested a long time ago using type families?
14:31:54 <johnw> what did you suggest?
14:31:56 <EvanR-work> head scratch, is this really that bad if you are given type synonyms to work with that use the underlying general type
14:31:58 <Cale> I don't know if it's clear what I mean by that :)
14:31:59 <hodapp> Cale: what did you- yeah, what johnw said
14:32:57 <johnw> Cale: at the sacrifice of some speed, pipes' Proxy type can be quite simple: https://github.com/jwiegley/notes/blob/master/PipesJ.hs
14:32:59 <Cale> I mean have type variables which are pretty much tuple types for at least the 4 interface variables, and type families for extracting the components.
14:33:11 <johnw> (the speed of the wrapping/unwrapping imposed by Free)
14:33:26 <Cale> Like, instead of having  Proxy a' a b' b m r
14:33:31 <Cale> You might have Proxy i m r
14:34:00 <Cale> where i is an interface variable, and then have type level functions Upstream, Downstream, In, Out
14:34:09 <Cale> which project out bits of that
14:34:14 <johnw> then aren't you just moving around complexity?
14:34:18 <Cale> Maybe
14:34:24 <johnw> regular users don't really see Proxy anyway, they see Producer and Consumer
14:34:48 <Cale> The goal is just to move the complexity to the right place (hopefully)
14:34:59 <Cale> Do they always though?
14:35:11 <Cale> I hate the fact that Producer and Consumer are simply type synonyms
14:35:19 <EvanR-work> im wondering about error messages
14:35:23 <Cale> yes
14:35:47 <Peaker> Powerful abstractions seem to often come at the expense of error messages
14:36:05 <Cale> I'm thinking the error messages might be better with type-level functions for the parts of the interface
14:36:06 <tasker> er, stupid question. If I have a function IO (ST s a), and I have a function that takes a and returns ST s b, how can I do this? Doing what I would expect to work leads to errors about s escaping it's context.
14:36:42 <Cale> tasker: How did you end up with IO (ST s a)? That already looks a little questionable.
14:36:56 <Cale> (maybe it's reasonable, but it's a bit weird)
14:37:00 <tasker> Creating a Hashtable from an external file :s
14:37:12 <tasker> It is likely to be wrong, this is the first time I've used ST.
14:37:16 <Cale> That's an IO action whose result when executed is an ST s action.
14:37:23 <tasker> Ah.
14:37:34 <tasker> Okay, so I guess I want to runST in there somewhere
14:37:43 <Cale> Maybe!
14:38:12 <Cale> If you're creating a hashtable in ST, you probably want to take the file contents as a parameter
14:38:18 <Cale> and not do IO
14:38:33 <tasker> ah. That makes benchmarking more difficult
14:38:36 <Cale> You can do the I/O involved beforehand, and pass the string in.
14:38:45 <EvanR-work> why are you using ST for this?
14:39:06 <tasker> EvanR-work: I guess I could just use IO.
14:39:19 <Peaker> ST is nice when it replaces IO :)
14:39:20 <Peaker> less evil!
14:39:30 <tasker> Well yeah, that is why I was trying :p
14:39:43 <EvanR-work> yeah ST cant do IO (I think)
14:39:55 <Cale> tasker: The idea of ST is this: you're allowed to use mutable datastructures as long as all of the mutable datastructure creation and use is contained within a single application of runST.
14:40:06 <johnw> Cale: I'll experiment with the type family idea and let you kno
14:40:07 <tasker> hm
14:40:07 <johnw> w
14:40:08 <Cale> tasker: and the result doesn't have any of these structures in it
14:40:13 <marchelzo_> How can I get a GHC.Ptr.Ptr Foreign.C.Types.CChar from a String?
14:40:20 <Peaker> tasker, (ST s) is kinda like IO where you can only do the mutable variable stuff of IO, and the "s" type param is like a tag on all mutable state and computations that links them together, to make sure all mutable state is local to a single runST computation
14:40:29 <johnw> unpackCString I think it's called?
14:40:36 <Peaker> marchelzo_, you need to encode it to a ByteString first?
14:40:36 <johnw> it's in the FFI String module
14:40:51 <Cale> johnw: Yeah, I have no idea if it would ultimately be better or worse.
14:40:59 <johnw> it's called withCString
14:41:02 <johnw> no need for ByteString
14:41:04 <johnw> http://hackage.haskell.org/package/base-4.7.0.2/docs/Foreign-C-String.html
14:41:04 <Cale> johnw: But I think it's a UI experiment that might be worth trying :)
14:41:08 <Peaker> what encoding does it use?
14:41:10 <johnw> Cale: yes, I agree
14:41:24 <johnw> Peaker: it doesn't even say
14:41:28 <tasker> Right, so as HashTable takes the s from ST as a parameter, there is no way to do what I want.
14:41:42 <marchelzo_> johnw, thanks
14:41:46 <Peaker> johnw, which is a huge red flag, heh
14:42:03 <Cale> tasker: Right, you can't have a runST which returns a hashtable result. You need to do whatever you were going to do with that hashtable inside the call to runST.
14:42:06 <Peaker> johnw, oh it says above "These functions are different from their CAString counterparts in that they will use an encoding determined by the current locale, rather than always assuming ASCII"
14:42:28 <Peaker> probably safer to just use UTF8 directly in most circumstances
14:42:37 <EvanR-work> at the bottom of the pipes tutorial, it shows that replicateM n in a pipe is "quadratic", ok head explode... then it says you can just making it linear by wrapping and unwrapping Codensity monoad transformer. head explode again
14:43:07 <Peaker> tasker, it's what ST is all about: By making sure mutable state is always local to a single ST computation, you get determinism, allowing it to be pure from the outside
14:43:09 <tasker> Cale: Ok, so if I wanted to use env from criterion (to disregard creating the map), I basically can't ?
14:43:19 <Cale> tasker: Even though it doesn't *really* work that way, you can imagine that runST sets up a heap for objects to be allocated in, and the 's' type parameter sort of refers to that heap.
14:43:44 <tasker> Cale, Peaker: It makes complete sense now I get what it is doing.
14:43:49 <Cale> okay
14:44:02 <Cale> Let me have a look at criterion, it's been a while since I last used it
14:44:04 <tasker> The docs are not so clear about what it means :p
14:44:10 <Peaker> tasker, the typical way to do this kind of thing is to "Freeze" your mutable state into an immutable snapshot you can "leak" out of ST
14:44:21 <tasker> Peaker: How would I go about doing this ?
14:44:44 <Cale> You can use env, you just need the environment to contain the string obtained by reading the file.
14:44:58 <Cale> Or, oh, you wanted it to contain the HashTable itself
14:45:03 <tasker> Cale: Yes
14:45:07 <Peaker> tasker, if you had an MArray, you could use http://hackage.haskell.org/package/array-0.1.0.0/docs/Data-Array-MArray.html#v%3Afreeze  it depends on the type
14:45:17 <booba> Greetings! I'm just getting into Haskell by completing some old online courses and had run into a question I can't seem to figure out. My exercise involves Parsable typeclass instance for Integer and instructs me to write a Parsable instance for a Type that effectively is a subset of Integer (and has its own algebra). How do I distinguish what am I trying to parse when provided a string with a number?
14:45:23 <tasker> Cale: For Map, for example, it returns the Map (Int, Int) Double
14:45:36 <Cale> ah, for that, you might as well use stToIO
14:45:48 <Cale> instead of runST
14:45:53 <Cale> er hmm
14:46:02 <tasker> Heh
14:46:07 <Cale> but you won't be able to *use* the hashtable then, unless you can test IO actions
14:46:22 <tasker> This is not proving to be as straightforward as I had assumed..
14:46:41 <Cale> oh, you can
14:46:49 <Cale> right, nfIO is a thing :)
14:47:09 <tasker> Ah, so it is
14:47:26 <tasker> Ok, I'll just switch to IO and see how it goes...
14:47:39 <tasker> although, maybe I will have a sleep first :p
14:47:44 <Cale> Yeah, performance-wise, there is no difference between ST and IO
14:48:20 <Cale> So even if you really use ST, converting it to IO like that can be considered to be free
14:48:44 <Cale> (there are only compile-time distinctions between the two, really)
14:48:47 <Thulsadum> am I to handicaped to use leksah? Or is it usage counterintuitively?
14:49:01 <Cale> Thulsadum: I don't understand that question
14:49:55 <tasker> Cale: Ok cool, thanks :)
14:50:04 <Cale> Thulsadum: Usage of leksah is entirely optional. I don't really use it -- the closest thing to an IDE that I use for Haskell is to keep two windows open: one for my text editor, and another for ghci.
14:51:23 <Thulsadum> Cale: there are some circumstances, which render it useless for me. but i think I haven't configured it correctly. e.g. Auto completion does not realy work, just defined a type, it's constructors are not completed in the current module.
14:51:41 <Thulsadum> Cale: which editor do you use? vim, emacs?
14:52:24 <booba> Greetings! Sorry for repeating this. I'm just getting into Haskell by completing some old online courses and had run into a question I can't seem to figure out. My exercise involves Parsable typeclass instance for Integer and instructs me to write a Parsable instance for a Type that effectively is a subset of Integer (and has its own algebra). How do I distinguish what am I trying to parse when provided a string with a number?
14:53:32 <mseeks> I wiped ~/.ghc, ~/.cabal, and .cabal-sandbox, did cabal sandbox init, but `cabal install --only-dependencies` still gives me "The following packages are likely to be broken by the reinstalls:"
14:53:35 <Hijiri> it will be inferred from the type of the overall expression
14:53:36 <Thulsadum> in the early days I used both of them, but thanks to other difficult to maintain languages I prefer IDEs, nowadays.
14:53:40 <Hijiri> > read "5" :: Int
14:53:41 <lambdabot>  5
14:53:44 <Hijiri> > read "5" :: Flost
14:53:45 <lambdabot>  Not in scope: type constructor or class â€˜Flostâ€™
14:53:45 <lambdabot>  Perhaps you meant â€˜Floatâ€™ (imported from Prelude)
14:53:46 <Hijiri> > read "5" :: Float
14:53:47 <lambdabot>  5.0
14:53:56 <Hijiri> @booba
14:53:56 <lambdabot> Unknown command, try @list
14:54:03 <dcoutts_> mseeks: it really means those packages will be unusable within the sandbox
14:54:15 <dcoutts_> mseeks: not that they're actually broken in your normal user env
14:54:34 <Hijiri> So if it infers you are looking for an Int, it will use the Int instance, if you are looking for that subset of Integer it will use that instance
14:54:46 <mseeks> dcoutts: I see; how did the package ever work then?
14:54:57 <Hijiri> consequently the compiler has to be able to figure out somehow what type you want, otherwise you will need explicit annotations
14:55:04 <Hijiri> > show . read $ "5"
14:55:05 <lambdabot>  "*Exception: Prelude.read: no parse
14:55:12 <dcoutts_> mseeks: I'm not sure what you mean.
14:55:28 <Hijiri> > show $ (read "5" :: Int)
14:55:30 <lambdabot>  "5"
14:55:49 <mseeks> dcoutts: how would I fix this error?
14:55:55 <dcoutts_> mseeks: it's not an error
14:56:01 <prophile> > show . (:: Int) . read $ "5"
14:56:02 <lambdabot>  <hint>:1:9: parse error on input â€˜::â€™
14:56:05 <prophile> pity
14:56:16 <dcoutts_> mseeks: the point is, your new sandbox starts from a copy of the global env, and it's possible to install things in that new env that cause certain of those packages to be unusable within the sandbox
14:56:20 * hackagebot apache-md5 0.6.1.1 - Apache specific MD5 digest algorighm.  http://hackage.haskell.org/package/apache-md5-0.6.1.1 (PeterTrsko)
14:56:32 <Hijiri> are there any type systems where type annotations are functions?
14:56:57 <booba> Thanks, Hijiri. That is what I assumed. Looks like my exercise lacks a good description. It says that my Sybset Type should be parsed exactly as Integer. No explicit annotations should be in the String, I suggest
14:57:02 <mseeks> dcoutts: if I deleted ~/.ghc and ~/.cabal though shouldn't the global env not have any packages?
14:57:16 <booba> Sounds wrong
14:57:32 <mseeks> I was under the impression that deleting .ghc and .cabal and only using cabal sandboxes should never produce these sorts of issues
14:57:58 <mseeks> unless your package dependencies are actually messed up
14:58:07 <booba> My custom type is
14:58:09 <booba> data Mod5 = MkMod Integer     deriving (Show, Eq)
14:58:15 <Hijiri> in this case you can bootstrap using the parsable instance of Integer
14:58:21 <Hijiri> oh wait, first
14:58:31 <Hijiri> what's the type of Parsable's methods?
14:58:42 <booba> Maybe (a, String)
14:58:48 <Hijiri> right
14:59:00 <Hijiri> So what you  can do first is try to read it in as an Integer
14:59:12 <dcoutts_> mseeks: see ghc-pkg list
14:59:31 <Hijiri> And then if you did get something valid, you see if it's within Mod5
14:59:32 <dcoutts_> mseeks: it shows you the global packages (base, rts etc) and your user ones
14:59:48 <dcoutts_> mseeks: you can't start a sandbox from completely empty, you need the rts, base etc
14:59:59 <Hijiri> If it's not, you return Nothing, because it's not valid input for Mod5
15:00:00 <booba> Hijiri: Interesting, thanks!
15:00:09 <dcoutts_> mseeks: and the way cabal sandbox works currently is that your sandbox is always stacked on top of your global packages
15:01:02 <dcoutts_> mseeks: and the point is, it's possible to mask those global packages in a sandbox, and that gives the same warning as if you were breaking packages (since technically it's the same thing here, it just happens to be non-destructive with a sandbox in this case)
15:01:27 <mseeks> dcoutts: makes sense, thanks
15:01:35 <booba> Hijiri: I thought of that approach, too. But next step in the exercise is to parse and calculate strings like "2 + 3". That means that I could get different types in one string
15:02:02 <mseeks> dcoutts: so basically using --force-reinstalls is fine in a sandbox?
15:02:11 <Peaker> Is there a nice alternative to: Product16 a = Product16 (a,a,a,a,a...a) deriving (Functor, Foldable, Traversable, Eq, Ord, Show, ...)
15:02:21 <Hijiri> what is the result of parsing "2 + 3" supposed to be?
15:02:23 <Hijiri> Integer?
15:02:28 <Peaker> (oops, no tuple there, just a bunch of fields)
15:02:29 <dcoutts_> mseeks: you can't break anything outside of the sandbox by doing it
15:02:38 <Hijiri> or some kind of expression tree
15:02:52 <dcoutts_> mseeks: whether it's "fine" depends on what it says you're breaking and if you care
15:03:12 <dcoutts_> but worst case you just reset the sandbox from clean
15:03:13 <booba> Hijiri: expression tree
15:03:16 <Hijiri> alright
15:03:25 <Hijiri> what type are integer literals in the tree?
15:03:29 <Hijiri> I mean
15:03:32 <Hijiri> what do the constructors take
15:04:14 <Hijiri> or maybe they are supposed to be Mod5 literals
15:05:00 <booba> if we work with Integers, they take Integers. Like (Add (Lit 2) (Lit 3))
15:05:29 <booba> if Mod5: (Add (Lit (Mod5 2)) (Lit (Mod5 3)))
15:05:41 <mseeks> dcoutts: I don't totally understand what it means to break a package; my understanding is that if you have A depending on B == 1.0 and you `cabal install` in a package which depends on B == 1.1 then you'd get that warning for package A
15:05:55 <booba> *MkMod instead of Mod5 in tree
15:06:25 <mseeks> dcoutts: and then if you make a package depending on A and B == 1.1 then it's not possible to resolve the dependencies
15:06:30 <dcoutts_> mseeks: actually it's more subtle. It's fine to have two versions of a package registered.
15:06:35 <Hijiri> is your expression tree type parameterized on the type of its literals?
15:06:49 <booba> Yes
15:07:00 <saml> > abs (minBound :: Int)
15:07:01 <lambdabot>  -9223372036854775808
15:07:05 <Hijiri> in this case, it will be able to tell what to try to read in based on the type parameter
15:07:07 <saml> is this bug?
15:07:28 <Hijiri> If you are trying to read in Expr Mod5 it will use the Mod5 Parsable instance, and if it's Expr Integer it will use the Integer instance
15:07:32 <dcoutts_> mseeks: in your example, we could break A by reinstalling B (e.g. to make it depend on C-1.1 rather than C-1.0)
15:07:52 <dcoutts_> mseeks: that is, reinstalling B-1.0 (to make it depend on C-1.1 rather than C-1.0)
15:08:02 <booba> I predict that when trying to parse "3 + 7" I could get (Add (Lit (MkMod 3)) (Lit 7)) and I don't know how to add them
15:08:30 <mseeks> dcoutts: is it possible to change a package's dependencies without changing its version though?
15:09:07 <Hijiri> booba: could you post the definition of your expression tree type on lpaste or somewhere similar?
15:09:52 <dcoutts_> mseeks: one can often re-build a package against different versions of its deps
15:10:00 <booba> http://lpaste.net/117956
15:10:12 <dcoutts_> mseeks: that gives you a new installed package instance
15:10:13 <Hijiri> ok
15:10:25 <Hijiri> the a on the left side is the same as a on the right side
15:10:30 <mseeks> dcoutts: you mean for example if B-1.0 specifies a dependency on C <= 1.2, for example?
15:10:38 <dcoutts_> mseeks: but any existing packages that depended on the previous package instance are now broken (which may be fixable by rebuliding those against the new instance)
15:10:39 <Hijiri> So if you have RingExpr Integer, Add takes two RingExpr Integer
15:10:50 <Hijiri> so you know that it has the same type as the overall expression
15:10:59 <dcoutts_> mseeks: you need to distinguish between source and installed packages for any of this to make sense
15:11:27 <Hijiri> all the subexpressions must have the same type parameter as the overall expression
15:11:39 <Hijiri> so if you know the type of the overall expression, you know the type of the literals
15:12:08 <dcoutts_> mseeks: so for a concrete example, suppose in your sandbox you want to use the latest version of bytestring, more recent than the one in your global db.
15:12:29 <dcoutts_> mseeks: installing an extra version of bytestring works just fine, that's not itself a problem.
15:12:55 <dcoutts_> mseeks: but of course you'll need to have everything in your sandbox using the same newer bytestring, for example the network package
15:13:27 <dcoutts_> mseeks: but you've already got an instance of the network package in your global db, e.g. network-2.5.
15:13:46 <dcoutts_> mseeks: so in the sandbox, cabal will rebuild network-2.5 against the newer bytestring.
15:14:10 <mseeks> dcoutts: ok, I see. is this where --force-reinstalls is necessary?
15:14:12 <dcoutts_> mseeks: this means that within the sandbox you have different instance of network-2.5, masking the global one
15:14:13 <booba> I guess I get it. But I don't know the other way. I parse the string and get Mod5 when valid and Integer when Mod5 not valid. Can I end up trying to build this tree with different types? (this obviously should crash)
15:15:02 <dcoutts_> mseeks: and this in turn means that anything else in your global package db that depended on the old instance of network-2.5 is now unusable within the sandbox, because one of their deps is missing (actually masked)
15:15:07 <Hijiri> it wouldn't compile
15:15:20 <jacereda> hi... given 'unique :: Ord a => a -> State (S.Set a) Bool', how can I invert the result without doing something like '(\x -> do u <- unique x; return $ not u)' ? That is, how can I compose 'not' and 'unique'?
15:15:20 <Hijiri> I don't think you have the idea of parsing right
15:15:26 <Hijiri> you either get Mod5, or you don't
15:15:37 <Hijiri> if it fails you get nothing, not even an Integer
15:15:41 <dcoutts_> mseeks: right, and cabal will not make packages unusable like that without you using --force-reinstalls
15:15:41 <mseeks> dcoutts: ok, that makes sense
15:15:47 <Hijiri> that is what Maybe (a, String) is saying
15:15:54 <Hijiri> Either you have a valid parse, or you have nothing
15:16:02 <dcoutts_> mseeks: the reinstall in this case would be that of network-2.5
15:16:07 <c_wraith> jacereda: something like fmap not . unique
15:16:08 <booba> oh, now I get it!
15:16:21 * hackagebot git-repair 1.20150106 - repairs a damanged git repisitory  http://hackage.haskell.org/package/git-repair-1.20150106 (JoeyHess)
15:16:23 * hackagebot github-backup 1.20150106 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20150106 (JoeyHess)
15:16:52 <mseeks> dcoutts: cool, this makes sense now. thanks for the explanation!
15:17:03 <dcoutts_> np
15:18:06 <Denommus> blaze-html is so cool
15:18:09 <srid> i come from Python/Ruby/Go/Clojure background; what would be the most suitable book to learn Haskell?
15:18:26 <srid> (and SICP/scheme background as well)
15:18:26 <Denommus> srid: maybe learn you a Haskell
15:18:46 <booba> does that mean that when I parse a string like "2 + 7" in my conext Haskell would effectively guess the type?
15:18:47 <srid> i noticed a bunch listed at https://www.haskell.org/haskellwiki/Learning_Haskell#Textbooks
15:18:49 <Denommus> srid: though Haskell is probably very different from all those languages because of the type system
15:19:04 <booba> infer, not guess
15:19:17 <srid> i'm somewhat familiar with type inference of F#, and I really like it. recently i have been looking at Elm as well.
15:19:39 <jacereda> c_wraith: hmmm... thanks, but that didn't work in the context of the NICTA course... I get "Could not deduce (P.Functor (State (S.Set a))) arising from a use of â€˜P.fmapâ€™"
15:19:48 <Hijiri> If you are trying to read in RingExpr Integer, it will try to read in Integer
15:19:58 <Hijiri> If you are trying to read in RingExpr Mod5, it will try Mod5
15:20:09 <c_wraith> jacereda: it's using an ancient version of State, then.  You can use liftM instead of fmap.  Same function
15:20:11 <Hijiri> It will fail to compile if it doesn't know what kind of RingExpr it is trying to read in
15:20:19 <Hijiri> well
15:20:24 <Hijiri> it has to know when it reads it
15:20:27 <Denommus> srid: http://learnyouahaskell.com/
15:20:38 <c_wraith> jacereda: or it's using its own incomplete version of State, I suppose
15:20:51 <srid> Denommus: alright. i'll start from that.
15:21:00 <Rufflewind_> "Unacceptable result type in foreign declaration: WordPtr"
15:21:02 <jacereda> c_wraith: it's using its own State, yes
15:21:06 <Rufflewind_> Is this supposed to happen?
15:21:21 * hackagebot shell-monad 0.6.1 - shell monad  http://hackage.haskell.org/package/shell-monad-0.6.1 (JoeyHess)
15:21:28 <c_wraith> jacereda: liftM is the same function with a Monad constraint instead of a Functor constraint
15:21:40 <Rufflewind_> I'm trying to write an FFI declaration for a function that accepts uintptr_t but GHC 7.8 doesn't seem to like WordPtr
15:22:06 <booba> in other words I have still to instruct it how to read the string
15:22:31 <Hijiri> Yeah, but all you need to do is say what kind of RingExpr it is
15:22:33 <k00mi> Peaker: a wrapper around Vector with length in the type is pretty easy
15:22:46 <Denommus> srid: don't worry about trying to learn monads now (since everyone seems to think haskell is all about monads)
15:22:58 <Peaker> k00mi, Safe from the outside, but not from the inside :(
15:23:03 <Hijiri> then it can infer that all the literals it encounters should be read as whatever the type parameter is
15:23:15 <Denommus> srid: just learn about typeclasses and higher kinded types. The knowledge on monads will come up naturally
15:23:24 <booba> my guess was that it should derive it from what instance of Parsable succeded
15:23:56 <c_wraith> the netsplits are brutal.
15:24:02 <bernalex> c_wraith: yeah damn that was a wild one
15:24:07 <Hijiri> sos
15:24:10 <EvanR-work> xchats netsplit detection is lacking
15:24:39 <butyoudonot> is there a config parser library that could work with a value defined via Map? configuration cannot do that? maybe anything else?
15:24:56 <butyoudonot> s/configuration/configurator/
15:25:41 <srid> Denommus: ok. also, the book starts with the assumption of experience in imperative languages, so that's good.
15:25:42 <Rufflewind_> neever mind my about my question, dumb mistake â€¦ I should just use CUIntPtr
15:26:26 <srid> so many quits
15:26:49 <c_wraith> srid: it was a netsplit - the irc servers partitioned
15:27:19 <booba> Hijiri: my guess was that it should derive the type from what instance of Parsable succeded
15:33:06 <darkroom> Okay so i was thinking and basically all the list functions can be defined in terms of just foldl is there a function on lists that cant be defined in terms of a fold?
15:33:23 <EvanR-work> (:) ?
15:33:44 <c_wraith> darkroom: map?
15:33:51 <darkroom> no map i can do right here
15:33:51 <EvanR-work> map famously can
15:33:57 <darkroom> map is easy
15:34:04 <c_wraith> map needs at least *two* foldls
15:34:13 <darkroom> EvanR-work: i think : might not be possible
15:34:13 <EvanR-work> since you can do map and filter with fold, people tend to think fold is the most fundamental
15:34:28 <c_wraith> EvanR-work: darkroom said foldl, not foldr
15:34:35 <c_wraith> darkroom: foldr, yes.  foldl, no
15:34:36 <darkroom> no you can have as many folds nested as you want
15:34:57 <darkroom> EvanR-work: i dont think : is possible because its a prim op
15:35:48 <EvanR-work> ok then implement "uncons" with foldl or foldr
15:35:57 <EvanR-work> :t uncons
15:35:58 <lambdabot> Cons s s a a => s -> Maybe (a, s)
15:36:09 <booba> :t parse
15:36:09 <lambdabot> Not in scope: â€˜parseâ€™
15:36:25 <EvanR-work> [a] -> Maybe (a, [a])
15:36:29 <benzrf> someone pinged me..
15:36:51 <Peaker> whew, I think I have a hack in graphics-drawingcombinators that makes it render fonts much more nicely, as long as you tell it the GL coordinate<->pixel ratio, when rendering
15:37:14 <darkroom> EvanR-work: how does that help with cons?
15:37:25 <EvanR-work> it doesnt, different challenge
15:37:56 <EvanR-work> the game being, implement an operation using nothing but folds
15:38:21 <darkroom> its just crazy how powerful folds are
15:38:33 <darkroom> head is foldl (\x _ -> x)
15:38:55 <Peaker> > head [1..]
15:38:57 <lambdabot>  1
15:39:03 <Peaker> > foldl (\x _ -> x) [1..]
15:39:04 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
15:39:04 <lambdabot>    arising from a use of â€˜M468495473220681228629076.show_M4684954732206812286...
15:39:04 <lambdabot>  The type variable â€˜a0â€™ is ambiguous
15:39:14 <srid> TIL that work on haskell began 3 years after my birth
15:39:16 <Peaker> > foldl (\x _ -> x) (error "no head") [1..]
15:39:20 <lambdabot>  mueval-core: Time limit exceeded
15:39:22 <EvanR-work> > foldl (\x _ -> x) [1..] []
15:39:23 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:39:26 <benzrf> srid: and nearly a decade before mine!
15:39:42 <Shibata_Zeshin> srid: when it started?
15:39:46 <EvanR-work> darkroom: unconvinced so far ;)
15:39:52 <nitrix> Is there a monad transformer for sequence of computations that stops at the first successful one?
15:39:53 <Peaker> darkroom, you want foldr for head, not foldl
15:39:54 <srid> 1987, acc. to learn you haskell book
15:39:55 <darkroom> foldl (\x _ -> x) [] [1..]
15:40:09 <darkroom> > foldl (\x _ -> x) [] [1..]
15:40:11 <Peaker> nitrix, EitherT, if you just reverse the meaning of Left and Right :)
15:40:11 <nitrix> E.g. MaybeT yields Nothing at the first failure.
15:40:11 * Shibata_Zeshin has same age with haskell
15:40:13 <lambdabot>  mueval-core: Time limit exceeded
15:40:22 <darkroom> shit its a right
15:40:28 <darkroom> > foldr (\x _ -> x) [] [1..]
15:40:28 <nitrix> Peaker: Ah that's clever!
15:40:29 <lambdabot>  No instance for (GHC.Show.Show t0)
15:40:29 <lambdabot>    arising from a use of â€˜M483412525566595077729137.show_M4834125255665950777...
15:40:29 <lambdabot>  The type variable â€˜t0â€™ is ambiguous
15:40:33 <EvanR-work> foldl cant be good for anything!
15:40:47 <darkroom> > foldr (\x _ -> x) [] [1.0..]
15:40:48 <lambdabot>  No instance for (GHC.Show.Show t0)
15:40:48 <lambdabot>    arising from a use of â€˜M700073505929993514529149.show_M7000735059299935145...
15:40:48 <lambdabot>  The type variable â€˜t0â€™ is ambiguous
15:40:58 <darkroom> what is wrong their?
15:41:18 <darkroom> thing is you can define foldr in terms of foldl
15:41:40 <Peaker> darkroom, head of empty list is not [], it is (error "..")
15:41:58 <darkroom> > foldr1 (\x _ -> x) [1..]
15:41:59 <lambdabot>  1
15:42:03 <darkroom> BOOM
15:42:09 <darkroom> forgot its foldr1
15:42:42 <nitrix> Someone asked be earlier today; provided Monads are essentially wrapping computations into a type (with only the two operators: bind and return), and that Lists are monads in Haskell, how come pattern matching let you obtain the contained value unwrapped?
15:42:51 <nitrix> Isn't this some sort of cheating?
15:43:13 <EvanR-work> you arent restricted to just return and >>=
15:43:24 <EvanR-work> unless the type is polymorphic
15:43:44 <nitrix> I explained that the type is implementing the Monad typeclass, but that it may have other operations.
15:43:50 <laurencer> can't you only pattern match if the type constructor is exposed?
15:44:00 <nitrix> IO, I think, is the only one that's restricted to those two?
15:44:17 <EvanR-work> you dont need to pattern match if you are given another set of operations (eventually implemented with possibly hidden constructors)
15:44:49 <EvanR-work> :t maybe
15:44:49 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:44:57 <EvanR-work> > maybe 3 (+1) Nothing
15:44:58 <lambdabot>  3
15:46:32 <nitrix> What happens when you pattern match (x:xs) though?
15:46:38 <nitrix> How is that implemented?
15:46:42 <EvanR-work> magic
15:47:06 <EvanR-work> its actually built into GHCs low level language that it compiles to
15:47:08 <nitrix> That'd be the first time that I hear something is magic in haskell.
15:47:33 <EvanR-work> at some point, the computer will check the constructor and see if its a (:) value or a [] value
15:47:52 <nitrix> So, pattern matching lets you break some of the
15:48:04 <nitrix> Whoops, that line wasn't meant to be sent.
15:48:14 <EvanR-work> sure wasnt, it seems!
15:48:50 <EvanR-work> lists are not an example of something with hidden constructors. its a public data type, the constructors are [] and :
15:49:02 <Hijiri> booba: It doesn't try all of them, it just tries one of them
15:49:19 <Hijiri> And it knows which one it tries at compile time
15:49:20 <EvanR-work> so you are allowed to pattern match
15:49:27 <nitrix> Okay, so I guess that was his confusion. Because they're implementing monads, he assumed you'd have no way to unwrap the values.
15:49:30 <Hijiri> You *have* to know what kind of expression it is
15:49:34 <Hijiri> It doesn't just try everything
15:49:44 <nitrix> EvanR-work: While I think, the monadic use of lists is for concatenation?
15:49:53 <EvanR-work> yeah you may or may not be able to get at the internal data structure, whether or not it has a monad instance
15:50:01 <nitrix> Only IO implements solely Monad?
15:50:17 <EvanR-work> youre asking if IO is the only abstract data type?
15:50:21 <Peaker> nitrix, nothing implements solely Monad
15:50:33 <Axman6> nitrix: in ghc, there's a few things which can happen. objects in the heap (pretty much anything you'd pattern match on) will be pointed to by a tagged pointer (things are always word aligned so the bottom 3-4 bits can be used to store info which either says that the thing pointed to is a thunk which needs evaluation, or tags it with the constructor which it's pointing to to speed things up a bit)
15:50:34 <Peaker> nitrix, there are a bazillion IO primitives
15:50:41 <Axman6> re pattern matching
15:50:45 <Peaker> nitrix, "solely Monad" is useless
15:50:51 <nitrix> Axman6: I didn't read your sentence because I don't care about GHC.
15:50:57 <nitrix> I'm interested by the semantics.
15:51:10 <booba> Hijiri: I think I have to read about typeclasses more. Looks like I miss something. I greatly appreciate all your help, kind sir!
15:51:14 <EvanR-work> IO can be considered an abstract data type, so can Char
15:51:23 <EvanR-work> er no
15:51:31 <Hijiri> np booba
15:51:36 <Axman6> nitrix: ok, I thought you were asking about how pattern matching is implemented. that's a pretty rude way to blow someone off by the way
15:53:27 <Axman6> Char isn't a great example of an abstract type, since you have access to all the constructors, but those constructors are kind of opaque regarding what they actually are
15:53:37 <Axman6> @src Char
15:53:37 <lambdabot> data Char = C# Char#
15:53:43 <EvanR-work> nitrix: think of Monad, Functor, and other type classes as a way for a concrete data type to provide the functionality of some interface
15:53:49 <EvanR-work> by implementing the specified operations
15:54:11 <nitrix> EvanR-work: Nah, actually, my understanding of monads is that, you can either wrap a value into the monadic type, or call a function that takes the value and returns a wrapped value, effectively making impossible to unwrap the value from its monadic context.
15:54:12 <EvanR-work> its not about wrapping
15:54:43 <nitrix> EvanR-work: So is that how IO achieves the purity? By only being an instance of Monad and nothing else?
15:55:01 <Peaker> nitrix, it's also an instance of Functor, Applicative, MonadError, MonadIO, ...
15:55:13 <EvanR-work> nitrix: its true that if you have a value of type m a for some monad m, you cant necessarily get any particular a from it. The same is true of the list type [a] and Maybe a
15:55:28 <EvanR-work> (happen to both be monads)
15:55:34 <EvanR-work> but thats a coincidence
15:55:36 <kadoban> nitrix: As just a basic analogy: I'm a programmer. That doesn't mean that's /all/ I am. If I make a sandwich, it'd be weird to say "Wow, you can do that? I thought you were a programmer."
15:55:38 <Axman6> nitrix: that doesn't mean specific monads can't also have other functions defined on them which allow you to do things like pull them apart
15:55:53 <nitrix> EvanR-work: Right, we're on the same page. So how come pattern matching let you obtain `a` from `[a]` ?
15:55:55 <prophile> kadoban: you can't be both a programmer and a sandwich
15:55:57 <Hijiri> nitrix: where is the wrapped value in Const a?
15:56:01 <Hijiri> Const a b
15:56:05 <EvanR-work> nitrix: it doesnt. i guess i misunderstood your question
15:56:07 <Peaker> nitrix, how do you obtain `a` from [] ?
15:56:09 <kadoban> prophile: Don't stifle my dreams!
15:56:17 <EvanR-work> nitrix: if you try to pattern match (x:xs) on a empty list, it crashes
15:56:25 <EvanR-work> > let (x:xs) = [] in x
15:56:26 <lambdabot>  *Exception: <interactive>:3:5-15: Irrefutable pattern failed for pattern (x ...
15:57:14 <nitrix> EvanR-work: That's expected, but what about [1] ?
15:57:50 <prophile> > let (x:xs) = [1] in (x, xs)
15:57:52 <lambdabot>  (1,[])
15:58:11 <EvanR-work> you can access the x and xs normally
15:58:18 <EvanR-work> [1] is the same thing as 1:[]
15:58:54 <nitrix> Yeah but this entire thing is supposed to be in the List monad.
15:59:02 <EvanR-work> monad isnt about hiding information
15:59:53 <EvanR-work> to answer your question earlier about list monad, the monad operation is to map then concat the results
15:59:53 <nitrix> Great. So my original answer was the right one.
16:00:19 <c_wraith> Monad is a pattern of composition.  "composition" is really the important part.
16:00:29 <Hijiri> which original answer?
16:01:58 <nitrix> Hijiri: It's in the backlog, close to where I said that question was formulated by someone else.
16:02:18 <EvanR-work> ask your friend to come here to discuss monads! ;)
16:02:26 <Hijiri> well there was a lot of stuff covered and I'm having trouble finding it
16:02:38 <nitrix> EvanR-work: Did.
16:02:57 <nitrix> Hijiri: We're both extremely lazy :)
16:03:45 <Hijiri> oh, I see
16:04:00 <Hijiri> IO isn't just restricted to those two though
16:04:10 <Hijiri> it has stuff like forkIO, putStrLn, etc
16:04:54 <Hijiri> not sure if forkIO is GHC-specific
16:05:05 <c_wraith> Hijiri: I believe forkIO is ghc-specific.
16:05:28 <Hijiri> ok
16:05:33 <Axman6> I thought at least one other compiler implemented it too. LHC?
16:05:35 <c_wraith> Hijiri: though some of the hidden haskells, like Standard Charter's internal version...  they might have it.
16:06:02 <c_wraith> since augustss seems to keep it up to date with GHC
16:07:35 <Hijiri> oh, another one is catch
16:08:09 <Hijiri> well there are a ton but catch feels more like it's putting together IO actions than putChar does
16:18:17 <jp_rider> hi, is there anyway to figure out the location of a library being dynamically linked?
16:22:32 <Peaker> a hard-to-debug bug just slipped through the type-checker :(
16:23:01 <Peaker> composing OpenGL image drawers with: (liftA2.liftA2.liftA2) (*>) render1 render2       (where render1/2 have N params, and liftA2's there are for each param and eventually the IO)
16:23:13 <Peaker> missing liftA2 --> compiles but is wrong (no IO composition!)
16:26:24 * hackagebot aws-lambda 0.1.0.1 - Haskell bindings for AWS Lambda  http://hackage.haskell.org/package/aws-lambda-0.1.0.1 (JonSterling)
16:29:49 <Hijiri> jp_rider: ld + locate?
16:30:03 <Hijiri> or do you mean at compile time? because I wouldn't know
16:31:03 <Axman6> well, surely it'd have to be at runtime?
16:31:25 <jp_rider> I guess at runtime?
16:31:44 <jp_rider> I've installed postgresql-libpq
16:32:06 <jp_rider> and I think it should be linking against psql's 9.2.8 library
16:32:13 <jp_rider> and I'd like to verify this
16:33:10 <jp_rider> because when I try to use the module I get error: unknown symbol `PQescapeIdentifier'
16:33:20 <jp_rider> which happens with previous versions of the psql library
16:33:34 <jp_rider> more details are here: https://github.com/lpsmith/postgresql-libpq/issues/18#issuecomment-68786639
16:34:05 <Hijiri> ldd executablename
16:34:12 <Hijiri> executablepath*
16:35:21 <hodapp> anyone have suggestions for how I might turn a GHC.TypeLit.Nat to an Int? Or, just to use 'show' on one...
16:36:23 <jp_rider> What if it's a haskell library?
16:36:41 <jp_rider> When I run ldd on HSpostgresql-libpq-0.9.0.1.o, I get the error: not a dynamic executable
16:37:15 <gamegoblin> Hodapp: use the function natVal
16:37:16 <jfischoff> hodapp: natVal
16:37:36 <jfischoff> natVal (Nothing :: Maybe 1)
16:37:46 <jfischoff> or similar
16:38:17 <jfischoff> Proxy is probably better, not sure if maybe is going to polykinded
16:38:42 <shachaf> Polykinded Maybe is a problem for GHC as it is because of Just.
16:38:50 <shachaf> It would be a nice feature to have sometime.
16:38:51 <jfischoff> ha yeah
16:39:01 <jfischoff> that would be a problem
16:39:05 <jfischoff> so use Proxy
16:39:12 <jfischoff> Data.Typeable.Proxy
16:39:46 <jfischoff> I was trying to get smart, oh well, Maybe as proxy works for * types :p
16:40:24 <shachaf> You can also use ([] :: [T]) for * types.
16:41:00 <jfischoff> will that type check or will you need â€˜[]?
16:41:31 <jfischoff> oh for * types
16:41:37 <jfischoff> I misread that
16:44:49 <aupiff> hey, using mysql-snaplet, i need query parameter substituion to either not use single quotes to surrond string params, or for those single quote to be  back ticks
16:45:07 <aupiff>  the query_ and query funcitons are from Database.MySQL.Simple, so it's a more general question than just snap
16:45:43 <aupiff> any suggestions?
16:49:19 <Taneb> JuicyPixels is taking a long time to build...
16:49:51 <Taneb> Oh, it's done
16:50:39 <jp_rider> I'm not familiar with mysql-snaplet, but I've used persistent and esqueleto to generate queries and have worked well for me
16:56:25 * hackagebot aws-kinesis-client 0.1.0.1 - A producer & consumer client library for AWS Kinesis  http://hackage.haskell.org/package/aws-kinesis-client-0.1.0.1 (JonSterling)
16:57:57 <Peaker> BEFORE: http://i.imgur.com/k9ngVO9.png  AFTER: http://i.imgur.com/STPzUeD.png
16:58:07 <Peaker> Woohoo, accurate font rendering seems to work nicely now :-)
17:00:34 <Axman6> what's actually changed there? obviously things have moved, but why?
17:03:04 <Peaker> Axman6, the movements are unrelated
17:03:07 <Peaker> Axman6, look at how the letters look
17:03:16 <Peaker> Axman6, the fonts look terrible in one, and nice in the other :)
17:03:47 <Peaker> (My fix is in the lower-level graphics-drawingcombinators library)
17:04:14 <hiptobecubic> Peaker, indeed. Very nice :)
17:04:22 <josephle> anti-aliasing?
17:04:53 <Peaker> nope -- I create multiple FTGL texture fonts instead of 1
17:04:56 <Peaker> for various sizes
17:05:03 <Peaker> and use the closest size to minimize GL scaling which creates the ugliness
17:05:22 <Axman6> Peaker: oo, they do look much smoother
17:06:19 <Axman6> Peaker: so they're not vector then?
17:07:31 <Peaker> they're TrueType/vector originally, but for some reason, they only look good if they're converted to a Texture font first
17:07:34 <Peaker> (in FTGL)
17:07:48 <Axman6> :(
17:08:19 <Peaker> http://ftgl.sourceforge.net/docs/html/ftgl-tutorial.html <-- look at how the polygon fonts look
17:09:02 <Axman6> they all look horrible
17:10:17 <Peaker> maybe it's because there's no polygon smoothing and I've been wasting my time? I'll try a polygon font with smoothing enabled
17:10:56 <Peaker> nope, polygon fonts look terrible
17:11:11 <Peaker> (they're supposed to be perfect!)
17:12:17 <numberten> ;win 12
17:12:39 <Peaker> I'm finally done with font crap, yay! Can do interesting things :)
17:19:43 <Romefeller> Hi all
17:21:07 <lpsmith> jp_rider:  I've found that with ghc 7.8,  I need to compile postgresql-libpq with --enable-shared
17:21:44 <lpsmith> Otherwise I can't use GHCi,  or more importantly,  Template Haskell
18:06:28 * hackagebot incremental-parser 0.2.3.4 - Generic parser library capable of providing partial results from partial input.  http://hackage.haskell.org/package/incremental-parser-0.2.3.4 (MarioBlazevic)
18:29:11 <marchelzo_> Does anyone know of  a good lens cheat-sheet / reference? I'm slowly learning it, but often forget a lot of the syntax, and the operators that are specific to StateT and stuff.
18:29:30 <shachaf> What there is is mostly pretty out of date.
18:29:45 <shachaf> There's the diagram on the Hackage page.
18:29:52 <shachaf> And some things on https://github.com/ekmett/lens/wiki
18:30:48 <benzrf> marchelzo_: dw about operators for now
18:31:02 <benzrf> marchelzo_: just use prefix versions when you don't remember the operators or don't feel like it
18:31:53 <benzrf> marchelzo_: the state ones are mostly <char>= and the other major ones are over and {,pre}{view,use}
18:32:13 <benzrf> ^that's about as much as i carry in my head (plus toListOf i guess)
18:32:19 <benzrf> also zoom
18:32:26 <marchelzo_> thanks, I'll try to keep that in mind
18:32:37 <benzrf> here let me run through them for you
18:33:03 <benzrf> as a regular function or as a Reader, you use view for lenses and preview for prisms
18:33:19 <Axman6> :T zoom
18:33:21 <Axman6> :t zoom
18:33:22 <lambdabot> (Zoom m n s t, Control.Lens.Internal.Zoom.Zoomed n ~ Control.Lens.Internal.Zoom.Zoomed m) => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
18:33:23 <benzrf> as a state operation that reads from the state, you use use for lenses and preuse for prisms
18:33:31 <Axman6> right...
18:33:31 <benzrf> Axman6: don't do thaaat
18:33:37 <Axman6> D:
18:33:41 <shachaf> The qualification makes that type look pretty scary.
18:34:01 <shachaf> (Zoom m n s t, Zoomed n ~ Zoomed m) => LensLike' (Zoomed m c) t s -> m c -> n c -- not so scary
18:34:02 <benzrf> marchelzo_: over is for mapping and zoom is for zooming
18:34:07 <Axman6> got a plain english or simplified type description?
18:34:17 <benzrf> marchelzo_: if you can remember that much that's about 80% of what i just mentioned
18:34:32 <Axman6> what's zoomed, if it's not too much to ask?
18:34:35 <Axman6> Z*
18:34:36 <benzrf> Axman6: i don't personally understand the type fully, but
18:34:40 <shachaf> Hackage does: http://hackage.haskell.org/package/lens-4.7/docs/Control-Lens-Zoom.html#v:zoom
18:35:00 <benzrf> Axman6: `zoom' basically allows you to map a state operation over a lens
18:35:06 <Axman6> ah right, I remember watching something where edward talked about that
18:35:07 <shachaf> Zoomed is a type family.
18:35:11 <dfeuer> Can efficiency ever suffer from the fact that (>>>) is not a member of the Category class, if you're dealing with lots of duals in some kind of very polymorphic context?
18:35:26 <benzrf> dfeuer: why would it?
18:35:31 <benzrf> dfeuer: isn't it just an alias for (.)?
18:35:43 <dfeuer> benzrf, it's  flip (.)
18:35:50 <benzrf> er, that's what i meant
18:35:55 <marchelzo_> benzrf, I can't wait until I become fluent in lenses. Thanks for the advice.
18:35:56 <benzrf> i feel like that's probably inlineable
18:36:11 <dfeuer> So I don't know if that could ever build up some kind of big closure if it doesn't statically know what's going on.
18:36:29 * hackagebot scientific 0.3.3.5 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.3.5 (BasVanDijk)
18:36:46 <Lokathor_> I am attempting to install hsSDL2 for windows, and I followed all the steps here https://www.haskell.org/haskellwiki/SDL/Windows
18:36:53 <Lokathor_> but it still says that it cannot find SDL in the path
18:37:04 <benzrf> marchelzo_: honestly it's helped me a lot to understand the implementation details
18:37:07 <benzrf> amusingly
18:37:41 <shachaf> roconnor: whoa, hi roconnor
18:37:50 <dfeuer> As opposed to just flipping back and forth with coercions.
18:37:50 <benzrf> it gave me a better understanding of how different types of optics compose and play with operators
18:38:24 <dfeuer> What helped you, benzrf?
18:38:41 <Pamelloes> Is it safe to name a function "evaluate" or is that a function in Prefix?
18:38:59 <dfeuer> Pamelloes, I don't know what Prefix is, but it's in Control.Exception.
18:39:07 <marchelzo_> benzrf, I don't think my general Haskell knowledge is sufficient for that to be helpful. Those type signatures genuinely make me uneasy.
18:39:25 <Pamelloes> dfeuer: Alright, thanks :) And I meant Prelude not Prefix.
18:39:31 <benzrf> marchelzo_: same, they're massive
18:39:40 <benzrf> marchelzo_: i don't understand most of them at a glance
18:39:53 <benzrf> marchelzo_: and DEFINITELY not Zoom
18:39:58 <dfeuer> I don't know *why* it's in Control.Exception, though.
18:39:59 <shachaf> marchelzo_: A lot of the lens types are much simpler if you understand where they come from.
18:40:04 <benzrf> marchelzo_: but you can make a lot of educated guesses and recognize common patterns
18:40:06 <dfeuer> That seems like a very strange place for it.
18:40:08 <shachaf> Out of the blue they can be pretty scary.
18:40:29 <dfeuer> benzrf, what is it that you found helpful for getting a handle on them?
18:40:44 <roconnor> shachaf: hey
18:41:09 <marchelzo_> I'll definitely try to understand their motivation at some point
18:41:13 <dfeuer> Pamelloes, evaluate is not, however, in the Prelude, so you're safe, I guess.
18:41:18 <benzrf> dfeuer: once you read a few type synonym definitions you realize there are really only a few basic patterns of types and about 75% of them are different for pragmatic reasons
18:41:50 <dfeuer> benzrf, oh.... yeah, I'm not ready to dig into that.
18:41:57 <benzrf> dfeuer: for example, there are like 5 synonyms which are literally just monomorphic versions of Lens
18:42:06 <ReinH> roconnor: hi!
18:42:20 <benzrf> so that you can avoid unnecessary constraints on the inputs and also rank 2 types
18:42:22 <dfeuer> benzrf, to cut down on signature cruft?
18:42:29 <benzrf> dfeuer: well
18:42:35 * benzrf reaches for an example
18:42:37 <dfeuer> Oh, rank 2 stuff in synonyms? Bleh.
18:42:44 <benzrf> dfeuer: Lens is rank 2
18:42:57 <benzrf> type Lens s t a b = Functor f => (a -> f b) -> s -> f t
18:43:09 <benzrf> you don't necessarily need to know what that type means, just take a glance at its shape
18:43:14 <benzrf> and look at this:
18:43:24 <dfeuer> Wait, Lens itself is a type synonym?
18:43:29 <benzrf> dfeuer: yeah
18:43:32 <dfeuer> Huh.
18:43:33 <benzrf> :t set
18:43:34 <lambdabot> ASetter s t a b -> b -> s -> t
18:43:40 <benzrf> note that set takes "ASetter" rather than a Lens
18:43:41 <benzrf> but:
18:43:47 <benzrf> type ASetter s t a b = (a -> Identity b) -> s -> Identity t
18:43:56 <benzrf> it's literally just Lens if you specialize it to Identity
18:44:12 <benzrf> it's only there to avoid certain type nastiness and so that you can use things that aren't fully-fledged lenses
18:44:14 <roconnor> ReinH: hi!
18:44:22 <dfeuer> benzrf, doesn't that type synonym need a forall in it, or no?
18:44:25 <benzrf> half the types in Lens are pragmatic variations like this
18:44:28 <benzrf> dfeuer: nope
18:44:32 <benzrf> dfeuer: f is replaced
18:44:55 <benzrf> dfeuer: look at the shapes of Lens vs ASetter's bodies
18:45:00 <Axman6> Getter is just s/Identity/Const a/ right?
18:45:08 <benzrf> Axman6: something like that
18:45:21 <Axman6> (where a depends on the type being got)
18:45:28 <shachaf> "type Lens s t a b = Functor f => (a -> f b) -> s -> f t" works without a forall due to a weird GHC quirk.
18:45:38 <shachaf> I'd call it a bug, or at least an inconsistent behavior.
18:46:00 <dfeuer> So it's a non-Haskell 98 type but works without a LANGUAGE pragma?
18:46:14 <shachaf> It needs a pragma.
18:46:21 <benzrf> dfeuer: the LANGUAGE pragma is in Control.Lens.Lens, presumably
18:46:37 <benzrf> dfeuer: i believe you only get a complaint if you try to define your own function generic over lenses
18:46:54 <benzrf> importing functions whose types contain it is fine
18:47:05 <dfeuer> benzrf, according to https://hackage.haskell.org/package/lens-4.7/docs/Control-Lens-Lens.html there is a forall f.
18:47:08 <benzrf> dfeuer: if you know that one of the arguments to a function is an optic of some sort, half the time you can infer what types it operates on just by glancing at the arguments
18:47:27 <benzrf> and it often ends up not mattering what the specific details of the synonym are for getting a decent idea of what it does
18:47:40 <benzrf> dfeuer: yes, and Control.Lens.Lens is the module with the pragma
18:48:06 <dfeuer> benzrf, yeah, I just don't have much more than the slightest clue about what lenses are about. Can you recommend an approachable intro?
18:48:45 <prophile> spj's talk is a reasonable starting point
18:48:53 <benzrf> dfeuer: i can tell you about em
18:49:08 <prophile> https://skillsmatter.com/podcast/home/lenses-compositional-data-access-and-manipulation
18:49:28 <Lokathor> if cabal install says "WARNING: unrecognized options: --with-compiler, --with-gcc" is that a weird sign?
18:49:28 <dfeuer> I can look at that first.
18:49:48 <dfeuer> Except it needs some sort of login.
18:50:58 <prophile> really? how offensive
18:51:11 <benzrf> dfeuer: l-let me spew words at you
18:51:12 <prophile> apologies, I think it was open to everyone when I watched it
18:51:13 <dfeuer> I'll deal.
18:51:24 <dfeuer> It seems rather easy to sign up.
18:51:26 <dfeuer> I'm in.
18:51:32 <dfeuer> benzrf, you can spew!
18:51:43 <benzrf> o3o
18:51:50 <benzrf> dfeuer: how much do you already know of lenses
18:52:00 <shachaf> Please don't spew in here. #haskell-overflow
18:52:35 <dfeuer> shachaf, may I ask what group declared you arbiter of what is and is not on topic in Haskell channels on Freenode?
18:52:45 <Pamelloes> Is there a built-in function for changing elements in a tuple?
18:52:54 <shachaf> dfeuer: #haskell-ops
18:53:15 <benzrf> oh boy is shachaf saying something
18:53:21 <benzrf> Pamelloes: there's first and second
18:53:25 <benzrf> Pamelloes: they're handy :)
18:53:32 <shachaf> dfeuer: This isn't an issue of being off-topic, it's an issue of a long conversation taking over the channel.
18:53:42 <benzrf> dfeuer: what's shachaf whining about this time
18:53:43 <Pamelloes> benzrf: Wait, there's a function "first"?
18:53:47 <shachaf> This is exactly what #haskell-overflow is meant for.
18:53:50 <benzrf> Pamelloes: it's in Control.Arrow
18:53:54 <benzrf> :t first
18:53:55 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
18:54:04 <benzrf> Pamelloes: (->) is an Arrow instance
18:54:19 <benzrf> Pamelloes: also of interest:
18:54:22 <benzrf> :t (&&&)
18:54:23 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
18:54:25 <benzrf> :t (***)
18:54:26 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
18:54:44 <benzrf> :t ceil
18:54:44 <lambdabot> Not in scope: â€˜ceilâ€™
18:54:47 <benzrf> :t ceiling
18:54:48 <lambdabot> (RealFrac a, Integral b) => a -> b
18:54:51 <benzrf> Pamelloes: examples:
18:54:53 <Pamelloes> alright then, these sound useful.
18:55:00 <benzrf> > first ceiling (3.5, 4.5)
18:55:01 <lambdabot>  (4,4.5)
18:55:05 <benzrf> > second ceiling (3.5, 4.5)
18:55:06 <lambdabot>  (3.5,5)
18:55:16 <benzrf> > (floor *** ceiling) (3.5, 4.5)
18:55:17 <lambdabot>  (3,5)
18:55:25 <benzrf> > (floor &&& ceiling) 2.1
18:55:50 <Romefeller> Is possible to make an android app with haskell?
18:55:56 <Axman6> shachaf: I'm of the opinion that long conversations are not inherently bad for the channel, unless others are trying to ask other questions, and then an explicit move to #haskell-{indepth,blah,whatever} is good for the people silently following along with the conversation
18:56:30 <benzrf> Axman6: i recently came to the conclusion that shachaf is actually an extremely deep cover troll
18:56:49 <benzrf> i am pleased with my decision to ignore him
18:56:58 <Axman6> he's the worst kind of troll, one who's often right
18:59:21 <glguy> I think it's crappy to characterize shachaf as a troll
18:59:39 <benzrf> glguy: yes, i really shouldnt
19:00:09 <Axman6> my comment was intended to show I don't think shachaf is at all a troll; I've learnt too much from him to say that =)
19:00:09 <glguy> He cares about the channel and is not insulting your discussion by encouraging you to take it to #haskell-overflow
19:00:26 <benzrf> i dont ACTUALLY think he was a troll
19:00:27 <lisbeth> > "what is the command that will let me print this without quotes?"
19:00:28 <lambdabot>  "what is the command that will let me print this without quotes?"
19:00:32 <benzrf> i was just being a vindictive dick
19:00:43 <Axman6> > text "text"
19:00:44 <lambdabot>  text
19:00:45 <benzrf> lisbeth: lambdabot knows of a type with a Show instance that has no quotes called Doc
19:00:47 <lisbeth> thanks
19:00:51 <benzrf> lisbeth: ...which Axman6 just demo'd
19:01:05 <lisbeth> I think text will suit my purpose just fine but thanks
19:01:12 <prophile> :t text
19:01:13 <lambdabot> String -> Doc
19:01:33 <Axman6> I'm assuming you're just talking about when working with lambdabot
19:01:33 <benzrf> lisbeth: yeah, text converts strings to that type :p
19:01:55 <Axman6> if you meant some other context, then that's a different question
19:02:38 <prophile> @check \x -> show (text x) == x
19:02:40 <lambdabot>  +++ OK, passed 100 tests.
19:16:14 <ezyang> Any way to do the moral equivalent of this? http://lpaste.net/3550990745999507456
19:17:52 <ezyang> oh, I should just use Key
19:18:20 <shachaf> ezyang: "instance Key TrieMap"?
19:18:31 <ezyang> instead of k say Key m
19:18:58 <ezyang> elegant!
19:19:45 <shachaf> I don't understand the kinds in your paste.
19:21:12 <shachaf> Maybe you're getting at something like this? class TrieMap (m :: * -> *) where ...; instance TrieMap m => TrieMap (GenMap m k) where type Key (GenMap m k) = k
19:21:18 <shachaf> Or maybe you solved your own problem already.
19:23:23 <calvinx> Does cabal support installation of packages directly via a git url?
19:24:08 <calvinx> doesnâ€™t look like it :-/
19:25:21 <benzrf> ezyang: can't you use an ordinary type family
19:28:46 <ezyang> shachaf: Yeah I did
19:28:55 <ezyang> benzrf: There are other methods, I just elided them
19:29:12 <glguy> Ezyang: is this related to what you're wanting? https://github.com/glguy/tries/blob/master/src/Data/GenericTrie.hs
19:29:13 <shachaf> ezyang: Eliding the methods confused GHC into thinking that m :: * :-)
19:29:39 <ezyang> shachaf: Oh, you're right
19:30:14 <ezyang> glguy: yeah, we've got a hand-written impl of this in GHC
19:30:22 <ezyang> I guess Simon decided the generic implementation was too magic
19:31:09 <glguy> GHC was the inspiration for that module :)
19:41:39 <pavonia> What is -XDefaultSignatures exactly there for? I don't really understand it from the documentation
19:44:08 <Axman6> pavonia: can you share the link to the docs?
19:44:22 <pavonia> https://www.haskell.org/ghc/docs/7.8.3/html/users_guide/type-class-extensions.html
19:44:38 <pavonia> 7.6.1.4. Default method signatures
19:45:55 <Axman6> yeah not sure myself
19:46:00 <pavonia> As I understand you can generate instances somehow by generics, but why do you need the default type signature?
19:53:15 <c_wraith> pavonia: they let you specify a default implementation that depends on Generic instances, even though the class itself doesn't depend on Generic
19:53:21 <c_wraith> pavonia: there's no other way to do that
19:54:53 <pavonia> Hhm, okay
20:10:13 <Denommus> Hu
20:10:30 <lucs> Helli
20:15:45 <timmy_tofu> Why do lazy bytestring functions all use int64 and strict uses int?
20:16:20 <shachaf> Lazy ByteStrings could be longer.
20:18:23 <shachaf> (They don't have to fit in memory, for instance.)
20:21:54 <timmy_tofu> I guess that must be it... still seems strange... I know the standard only guarantees 30 bits but on my machine GHC Int is 64, I'd guess that's common for most. It'd be nice if the API matched, but, whatever, just wondering
20:30:19 <Axman6> timmy_tofu: on a 32 bit machine Int is 32 bits, so it also adequately gives you the upper bound on how large a strict bytestring can be (but I agree it's a bit strange and annoying, particularly if you're trying to swap the two)
20:41:44 <systemfault> :k ReaderT
20:41:45 <lambdabot> * -> (* -> *) -> * -> *
20:42:09 <systemfault> Can someone help me understand this one?
20:42:14 <systemfault> :t ReaderT
20:42:15 <lambdabot> (r -> m a) -> ReaderT r m a
20:42:34 <tac> systemfault: what are you confused about?
20:43:09 <systemfault> How I should read the "kind" signature.
20:43:42 <johnw> it takes a type, a type constructor, and a type, and gives you a type
20:44:03 <dfeuer> johnw, that seems a little too vague in the "type constructor" part.
20:44:09 <systemfault> johnw: It's just that?
20:44:39 <systemfault> (* -> *) is a higher kinded type like any monad (Maybe for example)?
20:44:49 <systemfault> Hmm, not any monad... Either wouldn't work.
20:44:54 <dfeuer> But yeah, them thar kind signatures for Haskell 98 thingums are actually pretty straightforward. GHC extensions can make funny-looking ones I don't know how to read.
20:44:56 <johnw> Either has kind * -> * -> *
20:44:58 <johnw> and is not a monad
20:45:04 <johnw> Either Int, would be a Monad
20:45:39 <systemfault> Ah right, monad need to have the same kind as a functor, right? * -> *
20:45:44 <systemfault> (Since Monad is more or less a functor on steroid)
20:46:53 <dfeuer> How can I search large amounts of source for uses of a certain function? I don't want to hear about where the word appears in comments; just where it's in real code.
20:47:46 <johnw> a semantic grep would be nice
20:48:11 <pavonia> dfeuer: Parse the source with haskell-src-ext and filter with uniplate functions
20:48:27 <dfeuer> pavonia, that sounds like a lot of learning :-/
20:48:29 <dfeuer> BRB
20:50:39 <joelteon> Fortunately, uniplate mitigates learning
20:51:17 <johnw> well, once you get past the initial hump
20:51:25 <johnw> I didn't find the Haddocks particularly illuminating
20:53:40 <joelteon> it's a traversal that does everything apparently
20:54:12 <joelteon> well, it's a traversal that takes any sort of input and locates the inhabitants of the type you want
20:54:23 <mseeks> has anyone used the twitter-conduit package?
21:04:28 <latermuse> cd ~/s/bbscgi/2chbuildscripts/
21:04:29 <latermuse> ls
21:12:12 <ReinH> dfeuer: how large?
21:13:52 <dfeuer> ReinH, I'm contemplating generalizing evaluate from a->IO a to PrimMonad m=>a->m a. But that likely means rejiggering module dependencies, and it would be helpful to know all the places in base where evaluate is used.
21:14:19 <dfeuer> (in particular, evaluate would move from GHC.IO to Control.Monad.Primitive)
21:14:59 <ReinH> dfeuer: oh I am working on a tool that does exactly that (not semantic search, but large corpus regexp search)
21:15:01 <dfeuer> The reason I started thinking about this is that Control.Exception seems like such an utterly bizarre place to be the official public exposure of evaluate.
21:15:23 <ReinH> dfeuer: but meanwhile you could use https://code.google.com/p/codesearch/
21:15:51 <ReinH> or if you just care about base, a reasonably performant grep would probably be fine
21:16:01 <ReinH> mine is meant for larger corpa like "all of hackage"
21:16:02 <dfeuer> ReinH, I haven't the foggiest notion how to use a regexp to filter out Haskell comments.
21:16:13 <dfeuer> Yeah, I don't need all of Hackage.
21:16:36 <ReinH> dfeuer: I would hazard a guess that the majority of haskell comments use --, which would be relatively easy to do in a naive way
21:16:52 <johnw> dfeuer: if it's compiling Haskell, you could generate Core and search in that
21:17:36 <dfeuer> It sounds like the old "make the change and see what breaks" would be faster than these options :-/
21:17:44 <kazagistar> you have to ignore the -- inside strings
21:18:40 <dfeuer> kazagistar, probably not actually necessary in this context.
21:20:00 <ReinH> dfeuer: well, ghc is pretty good at telling you that something broke
21:20:07 <ReinH> and moderately good at telling what and where...
21:20:25 <dfeuer> ReinH, well, in this case it would give me a nice "not in scope" error each time, so probably not so bad.
21:21:55 <dfeuer> Oh .... this is a problem, ReinH....
21:22:08 <dfeuer> Control.Monad.Primitive isn't in base :-/
21:22:14 <ReinH>  dfeuer welp
21:22:18 <dfeuer> This could make things tricksy.
21:22:49 <ReinH> ABORT
21:22:57 <dfeuer> ReinH, why?
21:23:14 <ReinH> kidding
21:25:34 <dfeuer> ReinH, it does complicate matters badly. Either PrimMonad has to move into base, or evaluate has to depart from Control.Exception (backwards incompatible) or there need to be to *different* evaluate functions (yuck!)
21:25:42 <dfeuer> *two
21:26:46 <dfeuer> I honestly don't understand why primitive isn't part of base, but that's above my pay grade.
21:38:27 <chrisdotcode> johnw: ping
21:38:34 <johnw> hi there
21:38:44 <chrisdotcode> excellent, you're here
21:38:57 <chrisdotcode> johnw: gitlib-libgit2-3.1.0.1 doesn't compile for me
21:39:02 <chrisdotcode> pastebin with error in a sec
21:39:31 <johnw> you can ask in #gitlib
21:50:44 <benzrf> night
22:12:09 <dfeuer> ReinH, sticking PrimMonad in GHC.Base makes it work; not sure what people will think of that.
22:45:40 <_um> hi. has anybody here used the wordnet package? https://hackage.haskell.org/package/WordNet-1.1.0/docs/NLP-WordNet.html#t:WN
22:51:39 * hackagebot gitlib-cmdline 3.1.0.1 - Gitlib repository backend that uses the git command-line tool.  http://hackage.haskell.org/package/gitlib-cmdline-3.1.0.1 (JohnWiegley)
22:54:40 <idnar> do RTS options set in GHCRTS overrides ones specified at compile-time?
22:55:05 <monochrom> does the GHC user's guide talk about it?
22:56:39 * hackagebot gitlib-libgit2 3.1.0.2 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-3.1.0.2 (JohnWiegley)
22:56:41 * hackagebot gitlib-s3 3.1.0.1 - Gitlib repository backend for storing Git objects in Amazon S3  http://hackage.haskell.org/package/gitlib-s3-3.1.0.1 (JohnWiegley)
22:56:43 * hackagebot gitlib-test 3.1.0.2 - Test library for confirming gitlib backend compliance  http://hackage.haskell.org/package/gitlib-test-3.1.0.2 (JohnWiegley)
22:56:45 * hackagebot gitlib 3.1.0.1 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-3.1.0.1 (JohnWiegley)
22:56:58 <idnar> monochrom: it says they override options specified on the command-line, but doesn't seem to say anything clear about compile-time options
22:57:03 <idnar> uh
22:57:05 <idnar> *are overridden
22:58:20 <idnar> experimentally, it seems like the answer is "yes"
22:58:31 <a215> can anyone explain instance to me
22:58:40 <a215> i'm prob just not solid on the type system...
23:03:28 <Axman6> a215: have you programmed in any other languages?
23:08:34 <srhb> Type classes are a way of doing ad hoc function overloading. For instance, the Num class gives you addition via (+), and if you want to use this operator on a certain type, it needs to be an instance of Num. That means defining certain methods that the type class specifies, like (+)
23:10:42 <shachaf> Not all that ad-hoc.
23:16:49 <pavonia> _um: Do you have a more specific question?
23:18:59 <_um> pavonia: it turned out I was trying to figure out implicit parameters. I think I got that okay for the moment. I am now stuck on trying to figure out just which version of the WordNet database the package needs.
23:30:43 <breadmonster> "Most general purpose functional programming languages allow unrestricted recursion and are Turing complete, which makes the halting problem undecidable, can cause unsoundness of equational reasoning, and generally requires the introduction of inconsistency into the logic expressed by the language's type system."
23:30:46 <breadmonster> From wikipedia.
23:31:03 <breadmonster> ...what inconsistency has been introduced into Haskell's type system?
23:33:37 <chrisdotcode> @src head
23:33:37 <lambdabot> head (x:_) = x
23:33:37 <lambdabot> head []    = undefined
23:34:08 <breadmonster> chrisdotcode, but isn't bottom a member of all types?
23:34:25 <chrisdotcode> breadmonster: So ultimately, this program will error out when given an empty list.
23:34:59 <ThreeOfEight> I'm not sure if I would call it inconsistent
23:35:11 <ThreeOfEight> but non-termination/undefinedness is always logically problematic
23:35:16 <ThreeOfEight> f x = f x + 1
23:35:18 <breadmonster> Hmm, okay.
23:35:25 <ThreeOfEight> subtract "f x" from both sides
23:35:27 <ThreeOfEight> you get "0 = 1"
23:35:39 <chrisdotcode> breadmonster: There's a version called safeHead, which returns a Maybe a.
23:35:44 <breadmonster> ThreeOfEight, wait, there's a difference between the two yeah?
23:35:54 <ThreeOfEight> ==> function equations are only "equations" in the mathematical sense when everything terminates and is defined
23:35:57 <chrisdotcode> It's the preferred form, but you know - legacy.
23:36:10 <ThreeOfEight> breadmonster: well, "f 2" is bottom, undefined is bottom
23:36:13 <ThreeOfEight> logically
23:36:19 <chrisdotcode> > []:{]
23:36:20 <lambdabot>  <hint>:1:4: parse error on input â€˜{â€™
23:36:22 <chrisdotcode> > []:[]
23:36:23 <lambdabot>  [[]]
23:36:23 <ThreeOfEight> in practice, the former will not terminate, the latter will throw an exception
23:36:26 * chrisdotcode nods
23:37:00 <ThreeOfEight> I'm not sure what they mean by inconsistency
23:37:11 <ThreeOfEight> maybe they mean that you can write a program for uninhabited types
23:37:27 <breadmonster> Which you can't do in Haskell.
23:37:31 <breadmonster> without unsafePerformIO.
23:37:35 <ThreeOfEight> yes you can. undefined.
23:37:51 <breadmonster> ThreeOfEight, code?
23:37:54 <vanila> breadmonster, if you try to read types as logical tautologies
23:37:55 <vanila> e.g.
23:38:00 <ThreeOfEight> :t undefined :: forall a. a
23:38:01 <lambdabot> a
23:38:05 <vanila> (p -> q) -> p   p implies q implies p
23:38:05 <breadmonster> Oh hi vanila!
23:38:17 <vanila> then typed lambda calculus terms correspond to proofs
23:38:24 <vanila> but with full recursion, you can "prove" thinsg that aren't true
23:38:31 <ThreeOfEight> (a -> a) -> a is also uninhabited
23:38:34 <vanila> that's what they meant by inconsistency
23:38:38 <ThreeOfEight> :t fix
23:38:39 <lambdabot> (a -> a) -> a
23:38:55 <vanila> this isn't a problem for a programming langauge
23:39:05 <ThreeOfEight> if you restrict yourself to terminating and defined programs, this problem does not occur
23:39:06 <vanila> but it would be a problem for a mathematical theory
23:39:15 <ThreeOfEight> yes, it's a huge problem for reasoning about programs
23:39:27 <ThreeOfEight> which is why ideally, you want to prove termination of everything you write
23:39:37 <ThreeOfEight> (in Idris, you often have to do that)
23:39:47 <breadmonster> btw, does anyone do machine learning in Haskell?
23:42:40 <johnw> somebody was just asking that last night
23:48:43 <_um> Thanks #haskell. A good night to all.
23:51:38 <breadmonster> Guys, why is there no strict foldr defined?
23:52:13 <ThreeOfEight> What do you mean by "strict"?
23:52:37 <Axman6> foldr doesn't need to be strict because the strictness of the function passed to it basically determines the strictness of the whole expression
23:52:39 <opqdonut> breadmonster: it could only be efficient if lists could be efficiently reversed
23:52:40 <breadmonster> ThreeOfEight, analogous to foldl'
23:52:43 <ThreeOfEight> you cannot have something like foldl' for foldr
23:53:00 <Axman6> > foldr (\x _ -> Just x) Nothing [1..]
23:53:01 <lambdabot>  Just 1
23:53:04 <ThreeOfEight> because foldr has to blow up
23:53:10 <Axman6> > foldr (\x !_ -> Just x) Nothing [1..]
23:53:13 <breadmonster> Axman6, Ah okay, right perfect.
23:53:15 <lambdabot>  mueval-core: Time limit exceeded
23:53:15 <lambdabot>  mueval: ExitFailure 1
23:53:31 <ThreeOfEight> ah, I see
23:53:38 <johnw> but i would imagine foldr' would only work for finite lists, the same as foldl'
23:53:50 <johnw> that example doesn't show why foldr' can't exist
23:54:17 <Axman6> I didn't say it can't, only that doesn't need to
23:54:17 <ThreeOfEight> well you can have something like it, it just wouldn't be of much use
23:54:25 <johnw> right
23:54:42 <ThreeOfEight> foldl' is there to do stuff in constant space when possible
23:54:49 <ThreeOfEight> foldr' could not possibly achieve that
23:54:58 <johnw> why not?
23:55:17 <ThreeOfEight> because of the call nesting
23:55:30 <johnw> @src foldr
23:55:30 <lambdabot> foldr f z []     = z
23:55:30 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:55:46 <johnw> @src foldl
23:55:46 <lambdabot> foldl f z []     = z
23:55:46 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:55:48 <ThreeOfEight> foldl (+) 0 goes ((0 + 1) + 2) + 3
23:55:50 <johnw> makes sense
23:55:58 <ThreeOfEight> foldr (+) 0 goes 0 + (1 + (2 + 3))
23:56:23 <johnw> ok...
23:56:42 <ThreeOfEight> there is the heuristic that if you use foldl, you're probably doing it wrong
23:56:52 <ThreeOfEight> because you either want foldl' or foldr
23:57:14 <ThreeOfEight> (there are exceptions, of course)
23:57:15 <johnw> how does showing how they associate the calls relate to this?
23:57:25 <breadmonster> @src concat
23:57:25 <lambdabot> concat = foldr (++) []
23:57:28 <johnw> I can see from the definitions that foldl can be tail-call optimized
23:57:33 <breadmonster> Yup, okay.
23:57:42 <ThreeOfEight> there is no such thing as tail-call optimisation in Haskell
23:57:48 <ThreeOfEight> stuff just gets reduced lazily
23:58:37 <ThreeOfEight> if you have "foldl' (+) [1,2] 0", you reduce that to "foldl' (+) [2] (0 + 1)"
23:58:47 <ThreeOfEight> and that to "foldl' (+) [2] 1" because of strictness
23:58:51 <calvinx> If I were to re-implement `fmap`, which approach is better? http://lpaste.net/117976  (are the two approaches - list comprehension and recursion - equivalent?)
23:59:00 <ThreeOfEight> and so on, until you have "foldl' (+) [] 3", which reduces to 3
23:59:10 <breadmonster> @src map
23:59:10 <lambdabot> map _ []     = []
23:59:10 <lambdabot> map f (x:xs) = f x : map f xs
23:59:17 <johnw> perhaps I should have said: the foldl definition is tail recursive
23:59:20 <breadmonster> calvinx, use recursion.
23:59:35 <calvinx> ok - can I know why recursion is better?
23:59:43 <ThreeOfEight> if you have "foldr (+) [1,2] 0", that reduces to "1 + foldr (+) [2] 0"
23:59:47 <breadmonster> Though tbh I don't know if either actually has performance gains.
23:59:55 <Ferdirand> wouldn't the list comprehension desugar to map anyway ?
23:59:57 <ThreeOfEight> and that reduces to "1 + (2 + foldr (+) [] 0)"
