00:00:02 * geekosaur does /whois, notes that it is a bot
00:00:11 <glguy> The text package is nice for decoding utf8
00:00:22 <srhb> mjrosenb: Use text for that.
00:00:44 <srhb> mjrosenb: Specifically Data.Text.Encoding
00:00:52 <mjrosenb> and that can do ByteString -> String?
00:00:53 <glguy> Utf8-string is mine. I use text
00:01:08 <srhb> mjrosenb: ByteString -> Text
00:01:23 <srhb> mjrosenb: If you really _need_ String (you probably don't) you can use unpack afterwards
00:01:23 <mjrosenb> :-/
00:01:37 <geekosaur> for the record, utf8-string was intended for older (pre-6.12 iirc) ghc that did not support encodings. Data.Text is better these days
00:01:56 <shachaf> geekosaur: Unless you happen to want to use UTF8 in memory.
00:02:04 <glguy> But my package still decode s correctly if you want to use it
00:02:47 <mjrosenb> can System.FileName, and System.Directory accept Texts, or do I need to convert to String very early on?
00:03:17 <geekosaur> urgh. that is a ball of badness
00:03:20 <geekosaur> unless you are on windows
00:03:24 <glguy> We used to have to reimplement utf8 everywhere
00:03:26 <srhb> I think FilePath is still String.
00:04:09 <EvanR> theres the system-filepath package
00:04:11 <geekosaur> of course you can blindly pretend that posix uses unicode, and I can break your program trivially by creating filenames with non-normalized utf8
00:05:00 <mjrosenb> geekosaur: this is only going one direction.
00:05:12 <mjrosenb> geekosaur: I'm setting a filename based on data that I get elsewhere.
00:05:27 <shachaf> Is there an easy way to do arbitrary code execution given unsafeCoerce, without using IO?
00:05:34 <shachaf> s/easy/obvious/
00:05:46 <geekosaur> mjrosenb, that doesn't tell me anything useful
00:07:03 <geekosaur> POSIX paths are bytestrings. pretending otherwise, as people always want to do because they want to believe that the filesystem is utf8 or some other unicode encoding, will cause weird problems when someone uses an encoding other than the one you "know" it is, or uses a non-normalized version of the encoding
00:07:24 <glguy> Shachaf could you carefully craft something that you could cast to a function and then jump to it executing something?
00:07:29 <shachaf> They're ByteStrings that don't contain \0, in particular.
00:07:30 <geekosaur> (example: ú can be encoded into utf8 in at least two ways)
00:07:50 <shachaf> glguy: Right, but I'm wondering what you would craft.
00:08:04 <glguy> This is why my computer doesn't show me file names
00:08:26 <glguy> I just blindly edit and delete files to avoid being mislead
00:09:05 * hackagebot scientific 0.3.3.6 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.3.6 (BasVanDijk)
00:09:18 <mjrosenb> geekosaur: right, but if you hand me invalid UTF8, it'll get munged but Data.Text.Encode or Data.ByteString.UTF8, then the munged data will become a new filename, and it is no longer this program's problem.
00:10:38 <EvanR> by default it wont munge, it will crash
00:10:43 <EvanR> you can ask it to munge
00:11:02 <mjrosenb> ok, either one is fine by me.
00:11:08 <EvanR> heh
00:11:16 <mjrosenb> either way, nothing bad happens.
00:14:07 <mjrosenb> geekosaur: do you disagree?
00:17:09 <athan> Is there any way to "pull out" type information from a data constructor that encapsulates it? for instance `data Foo a = Foo (Bar a b c)` then trying to make a function `unFoo :: Foo a -> Bar a b c` will be hard - b and c won't unify
00:20:12 <mjrosenb> athan: can you actuallget data Foo a = Foo (Bar a b c) to compile?
00:23:21 <srhb> With existential quantification.
00:23:36 <srhb> Well, that would allow data Foo a = forall b c. Foo (Bar a b c)
00:25:01 <srhb> But I don't think I understand the question fully anyway.
00:25:34 <shachaf> Yes, you should explain what b and c are.
00:27:49 <mjrosenb> ok, new question: are there things like reads for Text?
00:28:27 <srhb> mjrosenb: Yup.
00:28:33 <srhb> @hoogle readMaybe
00:28:34 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
00:28:35 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
00:28:37 <srhb> ...
00:29:04 <srhb> Text.Read.readMaybe
00:29:18 <srhb> Wait, that's not what I was thinking of
00:29:43 <tdammers> hmm, could it be that pattern-matching on Texts is not a good idea?
00:32:09 <params> Hi I have a qn in Haskell function refactoring
00:32:13 <params> haskell pros please help me out
00:32:56 <srhb> params: Pose your question.
00:33:05 <params> I have some redundant segments shared by two functions and therefore want to remove it by making the function name a variable and dynamically calling it
00:33:08 <params> please check this code
00:33:08 <srhb> tdammers: Come to think of it I've never not used something Parsec-like for it.
00:33:10 <params> <code>
00:33:19 <srhb> params: lpaste.net
00:33:41 <srhb> I doubt you want to do what you're saying you want to do.
00:33:54 <lpaste> params pasted “tree functions” at http://lpaste.net/118814
00:34:02 <params> check this
00:34:02 <params> http://lpaste.net/118814
00:34:23 <params> you can see some duplication in code for both maxdepth and mindepth functions
00:34:41 <srhb> params: deptWith f ...
00:34:43 <params> i want to parameterize the function name "maxdepth" and "mindepth" and resuse the common code
00:34:52 <srhb> No, you want to parameterize the _function_
00:34:59 <srhb> so you get depth min t...
00:35:35 <srhb> 1 + f (depth f l) (depth f r)
00:36:02 <params> can you please paste the complete code.. I dint quite get what you are saying
00:36:07 <params> about the parametrization
00:36:26 <srhb> depth f (Branch _ l r) = 1 + f (depth f l) (depth f r)
00:36:39 <srhb> And depth _ Empty = 0, of course
00:36:49 <params> Oh ok, I see..
00:37:04 <params> and how do I dynamically choose max and min now?
00:37:13 <srhb> depth min myTree
00:37:15 <srhb> depth max myTree
00:37:56 <srhb> fsvo "dynamically": let f = if foo then min else max in depth f myTree
00:41:51 <trap_exit> i need two haskell progs to talk to each other -- is zeromq + haskell the right route?
00:42:51 <EvanR> pipe stdio ;)
00:44:29 <mjrosenb> srhb: ok, so what were you thinking of?
00:44:43 <srhb> mjrosenb: I don't think I was! I think my claim was false.
00:44:57 <srhb> mjrosenb: There isn't one (readily available) -- we tend to use some kind of parser combinator for that.
00:45:19 <srhb> If what you're doing is super simple, there's always read . unpack though
00:45:48 <mjrosenb> yeah, I onlt need read foo :: Int
00:45:57 <srhb> Yeah, go for unpack then.
00:46:07 <mjrosenb> or, I guess reads :: ReadS Int?
00:46:08 <srhb> Though, that case is already handled in text.read
00:46:20 <srhb> Sure.
00:46:29 <mjrosenb> oh, that wfm.
00:46:36 <params> <srhb> thanks for your help.. that solves my problem.. one last quesiton.. what would be the type declaration for the "depth" function though
00:46:59 <shachaf> mjrosenb: There's always http://hackage.haskell.org/package/text-1.2.0.4/docs/Data-Text-Read.html for that.
00:47:28 <params> depth:: String -> Tree a -> Int   ???
00:47:37 <srhb> params: Ask ghci
00:47:48 <srhb> params: (it's Num a => (a -> a -> a) -> Tree t -> a
00:47:50 <srhb> )
00:48:12 <params> ghci gives me this.. but I don't understand why it is so complicated
00:48:14 <params> depth :: Num a => (a -> a -> a) -> Tree t -> a
00:48:40 <srhb> :t min
00:48:41 <lambdabot> Ord a => a -> a -> a
00:48:51 <lpaste> params revised “tree functions”: “No title” at http://lpaste.net/118814
00:49:16 <params> just pasted the funciton here.. http://lpaste.net/118814
00:50:05 <params> srhb: thanks... can you explain why the "(a -> a -> a)" occurs in the type declaration?
00:50:16 <srhb> params: Yes, that's the type of f
00:50:21 <srhb> (Well, almost)
00:50:38 <params> aren't we passing just "min" or "max" while calling the function.. should n't it be just a string
00:50:54 <srhb> No, we're passing the actual functions
00:50:59 <srhb> Not a string with their name
00:51:11 <params> oh I see.. Thanks for clarifying that..
00:51:57 <geekosaur> mjrosenb, I consider it incorrect behavior when users are presented with two files with the same name in the same directory and cannot control which one is actually used because they don't know what kind of normalization if any the program will choose to do in its infinite the-filesystem-is-obviously-utf8 wisdom
00:52:23 <geekosaur> but I should not be surprised any more that this is considered correct behavior by apple, gtk devs, etc.
00:52:51 <geekosaur> and you want to follow in their footsteps because it's clearly correct
00:53:56 <mjrosenb> geekosaur: so are you saying I should avoid creating a file with a non-normalized utf8 string, even though the filename is just a sequence of bytes?
00:54:22 <geekosaur> no, that's actually likely to *cause* the problem
00:54:59 <geekosaur> you should not pretend the filesystem supports any given encoding. it's a bytestring.
00:58:10 <mjrosenb> right, so {file:_ <- getDirectoryContents; newname <- process file; renameFile file newname} shouldn't do anything bad.
00:58:57 <trap_exit> is there a haskell gui like three penny gui, but oes not depend on gtk?
00:59:13 <trap_exit> so the idea is that when I run the haskell app, it opens up a port, I point chorme at it, and it uses the browser as the GUI
01:00:48 <mjrosenb> trap_exit: well, there is wx, which may use gtk, or qt, or cocoa, or whatever windows calls it gui.
01:00:49 <srhb> trap_exit: threepenny-gui depends on gtk?
01:01:04 <trap_exit> srhb: I couldn't install threepenny-gu ivia cabal
01:06:54 <srhb> Sorry, I had a disconnect.
01:06:58 <srhb> I was saying threepenny-gui is exactly what you're asking for.
01:12:40 <aloiscochard> how can I shift an Int64?
01:13:37 <mjrosenb> aloiscochard: Data.Bits, Int64 should have an implementation.
01:14:08 * hackagebot cpphs 1.18.8 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.18.8 (MalcolmWallace)
01:14:10 * hackagebot egison 3.5.4 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.5.4 (SatoshiEgi)
01:29:28 <mjrosenb> If I don't care about perf, or memory usage, Text and String can represent the exact same set of values, right?
01:29:45 <dcoutts_> mjrosenb: yes.
01:29:57 <dcoutts_> abstractly, both are sequences of Char
01:30:15 <mjrosenb> where a char can be any unicode codepoint?
01:30:31 <dcoutts_> > maxBound :: Char
01:30:32 <lambdabot>  '\1114111'
01:32:49 <agocorona> > minBould :: Char
01:32:51 <lambdabot>  Not in scope: ‘minBould’
01:32:51 <lambdabot>  Perhaps you meant ‘minBound’ (imported from Prelude)
01:33:00 <agocorona> > minBound :: Char
01:33:01 <lambdabot>  '\NUL'
01:33:59 <agocorona> > show '\1114111'
01:34:01 <lambdabot>  "'\\1114111'"
01:35:07 <agocorona> > ['\NULL'.. 'a']
01:35:09 <lambdabot>  <hint>:1:7:
01:35:09 <lambdabot>      lexical error in string/character literal at character 'L'
01:35:18 <agocorona> > ['\NUL'.. 'a']
01:35:20 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
01:37:21 <mjrosenb> length ['\NULL'..maxBound]
01:37:44 <agocorona> O(n)
01:37:53 <mjrosenb> oh, I forgot >
01:38:00 <mjrosenb> > length ['\NUL'..maxBound]
01:38:02 <lambdabot>  1114112
01:44:09 * hackagebot egison 3.5.5 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.5.5 (SatoshiEgi)
01:44:11 * hackagebot record 0.1.1 - First class records implemented with quasi-quotation  http://hackage.haskell.org/package/record-0.1.1 (NikitaVolkov)
02:01:49 <grohne> what reasons should I consider for my haskell program to exit with status 245 and no visible message?
02:02:40 <grohne> sporadically.
02:04:10 * hackagebot haskell-names 0.5.1 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.5.1 (PhilippSchuster)
02:26:27 <srhb> grohne: Sounds like some library you're using is throwing that.
02:36:27 <grohne> srhb: I'm a bit closer now. it only happens if I enable profiling (on ghc 7.8)
02:36:36 <srhb> Oh, that sounds funky.
02:36:59 <grohne> in particular, it depends on pointless-haskell to be with or without profiling
02:38:25 <merijn> Eh, what exactly happens? I missed the initial question
02:39:22 <grohne> I have a haskell program (igor2) and run it on an input. it succeeds (ghc 7.8). now I rebuild my cabal sandbox with --enable-library-profiling and configure with --enable-profiling.
02:39:48 <grohne> now the program occasionally exits at random points with exit status 245 (on Linux)
02:40:13 <grohne> merijn: any more details I could provide?
02:41:16 <grohne> full source available at http://www.iai.uni-bonn.de/~grohne/darcs/igor2/. the test cases that occasionally fail are tests/heaD.bat and tests/taiL.bat
02:45:44 <merijn> Have you tried tracing to see where exactly the exit happens?
02:46:40 <grohne> no, how would I do that?
02:50:10 <grohne> also the termination point does not appear to be deterministic
02:50:24 <grohne> (i.e. sometimes it logs more igor2-specific things and sometimes less)
02:50:30 <merijn> Debug.Trace.trace is your friend :)
02:51:00 <grohne> ah that way of tracing.
02:51:00 <merijn> It sounds like something odds going on, though
02:51:07 <merijn> Well, ghci has a debugger too
02:51:10 <merijn> But I've never used it
02:51:14 <merijn> You could try that
02:51:29 <grohne> I guess I just ignore it for now and disable profiling when I don't need it
02:51:59 <grohne> interestingly, it only fails on the "smallest" test cases. all non-trivial examples do not exhibit this issue at all
02:52:41 <grohne> it might have to do with it completing too quickly (whatever that means)
02:56:09 <tasker> Has anyone used the hdf5 haskell bindings ? They don't appear to have been updated for a long while.
03:00:40 <srhb> tasker: Technically "never" it appears. Though maybe they're just correct. :-)
03:01:17 <tasker> Hah, as correct as they may be, it would be nice to use base >5 :p
03:01:36 <tasker> Oh, my mistake
03:01:38 <tasker> we are not over 5 anyway
03:01:41 <srhb> tasker: Indeed.
03:01:50 <tasker> Well I suppose I should just have a go.
03:02:14 <srhb> Yes. :)
03:12:03 <arbelos> I have been trying to re-install the Haskell Platform for a while now but I keep getting to a point where I remove everything using the package manager, and reinstall. After doing so, I end up with an installation without base it seems, so the system is complaining about broken dependencies
03:12:44 <mpickering> this sounds worrying
03:12:50 <arbelos> I also removed ~/.cabal ~/.ghc and /var/lib/ghc before attempting to reinstall (this is on Debian btw.)
03:13:05 <mpickering> right
03:13:14 <mpickering> can you paste the exact error you get?
03:16:12 <arbelos> when I run ghc-pkg check..
03:16:13 <arbelos> http://lpaste.net/118832
03:18:50 <iLike> I'm having troubles understanding the relation between Functors, Applicatives and Monads. Can someone point me to an article explaining this?
03:20:00 <frawgie> iLike: LYAH does it pretty well I think
03:20:04 <tdammers> @where typeclassopedia
03:20:04 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
03:20:52 <iLike> "class Functor f => Applicative f where" means that every Applicative must be a functor, correct?
03:21:30 <iLike> frawgie, tdammers, thanks btw
03:21:39 <LordBrain> hmmm there was a really great chart on wikipedia, but someone may have deleted it
03:22:47 <iLike> I think Typeclassopedia has it? https://www.haskell.org/haskellwiki/File:Typeclassopedia-diagram.png
03:24:27 <LordBrain> iLike, monads are applicative functors which are functor, but if you try to say applicatives are monads or functors are applicatives, that doesn't work.
03:25:10 <iLike> But Applicatives can be defined in terms of monads...?
03:25:23 <LordBrain> applicative functor is more general
03:26:03 <LordBrain> you can make an applicative functor out of any monad tho
03:26:06 <iLike> LordBrain, excuse the ignorance, but why aren't they equally powerful if one can be defined in terms of the other?
03:27:14 <iLike> an "instance Monad a => Applicative a where .." can be made
03:27:24 <LordBrain> yes
03:27:44 <LordBrain> in the future, that wont be necessary, because new versions of haskell are all moving toward making that implicit
03:27:46 <iLike> but an "instance Applicative a => Monad a where.." as well, right?
03:28:22 <gds> So, we could distinguish between "morally the same" and "haskell enforces they be the same"
03:28:51 <iLike> So right now Monad is a 'superclass'(right name?) of Applicative, but that is bound to change in the future?
03:29:04 <koomi> iLike: no, Monad is strictly more powerful than Applicative
03:29:09 <LordBrain> its the other way around...
03:29:25 <iLike> err..
03:29:31 <iLike> yea, sorry
03:29:38 <LordBrain> well koomi it depends on what iLike means by more powerful, in general if you use more general code then it applies in more situations and so is more powerful
03:30:20 <mjrosenb> EitherT Foo m a is a monad, yes?
03:30:42 <LordBrain> but if you're measuing power by what it grants you when writing the function, then of course it is the reverse
03:30:47 <arbelos> hmm.. let's try apt-get remove ghc also then before reinstalling
03:31:10 <mjrosenb> so (y :: EitherT String IO Int), x <- y, then x :: Int, yes?
03:31:12 <LordBrain> iLike, have you been reading typeclassopedia?
03:31:24 <iLike> I'm reading it atm LordBrain :)
03:31:31 <LordBrain> yeah i think that is a good one
03:31:58 <iLike> I understand what each class does and what it encompasses, but I struggle to understand what ties them together
03:32:12 <koomi> mjrosenb: correct
03:36:57 <mjrosenb> oh, derp, I bet this doesn't have type EitherT String IO Int, I bet it is just IO (Either String Int)
03:37:17 <tasker> If anyone fancies helping me optimise some code: https://codereview.stackexchange.com/questions/78013/one-dimensional-convolution-using-data-vector
03:38:04 <arbelos> ok, so that worked. finally. Apparently, since I had other (Debian) packages that depended on ghc, uninstalling haskell-platform left things in a weird state but after doing apt-get remove ghc and some voodoo on the filesystem i managed to reinstall everything nicely
03:38:41 <mjrosenb> koomi: and I bet I can't easily exchange between the two... probably for good reason
03:39:15 * hackagebot morfette 0.4.2 - A tool for supervised learning of morphology  http://hackage.haskell.org/package/morfette-0.4.2 (GrzegorzChrupala)
03:41:06 <koomi> mjrosenb: just pack it in EitherT
03:42:19 <mjrosenb> koomi: the issue is that if I have the left case, EitherT String implies that no IO happened, so that value can never depend on a result of performin IO
03:42:38 <mjrosenb> whereas, I want to use it to singal some limited set of errors.
03:42:40 <koomi> no
03:44:04 <mjrosenb> Am I getting the layerting of EitherT and IO backwards?
03:44:12 <mjrosenb> that would make me very happy.
03:44:19 <koomi> "EitherT String IO a" is literally just a newtype around "IO (Either String a)"
03:44:30 <mjrosenb> eeeeeexcelent.
03:45:43 <LordBrain> arbelos, i leave debian's ghc installed but use the debs that hvr made which install new versions into separate folders under /opt
03:47:02 <koomi> mjrosenb: in a stack of transformers, the inner monad is always really the outter one
03:47:15 <LordBrain> debian should probably change their package layout for ghc, i think it is probably common these days that people have multiple versions installed
03:48:29 <mjrosenb> LordBrain: have they fixed the ld issue yet?
03:48:31 <arbelos> ok, yes. another thing that probably complicates is that there are a bunch of other software platforms that depend on the ghc and cabal, e.g., idris, agda, purescript, fay etc.
03:48:39 <merijn> @unmtl EitherT String IO a
03:48:40 <lambdabot> EitherT String IO a
03:48:43 <merijn> hmmm
03:48:52 <merijn> Not an mtl transformer, I guess
03:49:07 <mjrosenb> koomi: eeexcelent.
03:49:19 <koomi> yup, it's a seperate package
03:54:15 * hackagebot uhc-light 1.1.8.4 - Part of UHC packaged as cabal/hackage installable library  http://hackage.haskell.org/package/uhc-light-1.1.8.4 (AtzeDijkstra)
03:54:50 <LordBrain> is there a consensus on the best way to do effects in haskell that give more extensibility than the transformer idiom? i think i've seen 3 different takes on the issue that all came out around the same time in 2013.
03:55:10 <mjrosenb> LordBrain: oh?
03:55:16 <merijn> LordBrain: Depends, what sort of extensibility do you need?
03:55:22 <mjrosenb> LordBrain: I don't think I've heard of any of these.
03:55:29 <merijn> mjrosenb: extensible-effects is one
03:56:44 <LordBrain> well, they are here: http://www.cs.indiana.edu/~sabry/papers/exteff.pdf  and here: http://www.cl.cam.ac.uk/~ok259/publications/kammar-lindley-oury-handlers-in-action.pdf   and (with dependent types: http://edwinb.wordpress.com/2013/03/28/programming-and-reasoning-with-algebraic-effects-and-dependent-types/ )
03:58:16 <merijn> Lacking any other info about what you want it's hard to say there's any consensus
03:58:48 <LordBrain> So anyway, the predominant idiom is the transformer stack i think, and it would be nice to see a sort of comparison of these papers and how the approaches differ and how they stack up and contrast with the monad transformers too.
03:59:06 <vanila> LordBrain, i want to say exteff but the union thing is so difficult
03:59:39 <merijn> Mostly they contrast with transformers as "slower and not capable to do all things transformers can"
03:59:51 <LordBrain> it would be interesting to see the dependent type approach translated to haskell
03:59:56 <vanila> LordBrain, I really dig monad transsformers, they're just so simple - on the other hand Eff ( http://math.andrej.com/eff/ ) is really fresh and the approach is very interesting
04:00:19 <LordBrain> uh oh, is that a fourth?
04:00:38 <merijn> For a lot of transformers the order in which you stack them is relevant for their semantics, so it's unclear how to translate that to things like extensible effects
04:02:10 <LordBrain> well, we should have a wiki page devoted to it really
04:02:18 <LordBrain> probably
04:02:25 <merijn> hmmm, laggy, did my two last messages make it through?
04:02:47 <koomi> you're welcome to create it :-)
04:02:47 <merijn> LordBrain: Like I said, for the vast majority of people, transformers are still the way to go
04:02:48 <srhb> merijn: "Mostly..." and "For a lot..."
04:03:25 <merijn> srhb: ok, I always worry when irssi says I have a latency of 103 seconds >.>
04:04:59 <koomi> I wonder what became of ro-che's shot at effects
04:11:54 <cryptic_> simon peyton jones said in a lecture that the following is possible: 2 people can, for exmaple in this channel, using only this channel,exchange information that noone else can understand but the start of the communication must start here in the channel so we must exchange keys here
04:12:01 <cryptic_> i dont see how this is possible
04:12:08 <cryptic_> there is some catch clearly
04:12:13 <merijn> cryptic_: Google Diffie-Hellman
04:12:25 <vanila> cryptic_, it's based on "one way functions"
04:12:26 <merijn> Or Helman? I forget
04:12:29 <cryptic_> apparnetly all credit card payments online are done so
04:12:45 <vanila> you have a function that's easy to compute in one direction, and really really hard in the othe way
04:12:52 <vanila> e.g. multiplcation is easy, but factoring is hard
04:13:13 <vanila> and these guys were able to turn that into a way of communicating secretly
04:13:37 <LordBrain> cryptic_, its generally more secure if the keys are exchanged in another way
04:14:05 <LordBrain> as in, you exchange keys via phone or something, but you use the keys over the internet...
04:14:32 <merijn> That depends on whether you have access to a secure channel, which you often don't
04:14:47 <hpc> if you have access to a secure channel, use that instead
04:14:49 <merijn> And even then you wanna use DH for ephemeral keys to guarantee perfect forward secrecy
04:15:08 <vanila> its a complex subject with a lot of factors to take into account
04:15:24 <LordBrain> or maybe you're not asking about asymmetric encryption algorithms, but since everyone else thinks you are... i thought maybe you are too.
04:15:26 <merijn> For example, SSH and SSL use DH exchanges over a secure channel for perfect forward secrecy
04:15:36 <LordBrain> lol
04:17:11 <LordBrain> well the idea is you have 2 halfs of a key, the private half you keep secret allows you to encode messages, the public half you share and allows messages to be encoded for you.
04:17:44 <merijn> LordBrain: That's not really related to his question, though
04:17:49 <LordBrain> oh sorry then
04:17:54 <LordBrain> i'm not quite clear on the question
04:17:57 <merijn> Well, I guess maybe it is?
04:18:23 <merijn> But DH is probably more secure if you don't require authentication
04:18:49 <merijn> And authentication means having to establish the authenticity of the public/private key pair via a trusted third party/secure channel anyway
04:18:57 <LordBrain> if you don't actually exchange the keys in person or via some secured manner, then the key might not actually belong to the person you think it does.
04:19:50 <iLike> That's related to the question, but not really an answer. Diffie-Hellman assumes that Bob is who Bob says he is, as well as Alice
04:21:09 <merijn> iLike: It doesn't assume that at all
04:21:16 <merijn> iLike: It just doesn't do authentication
04:21:27 <iLike> Even when Alice is Eve for example, DH assures you that the keys are privately distributed
04:21:29 <merijn> But you don't always need authentication
04:21:36 <iLike> Well yea, that's what I was trying to say
04:21:38 <pelmrq> I have a problem pattern matching a list of Exp objects: https://gist.github.com/anonymous/db0b8c52283f2b4e7f1b. [x:xs] Should be able to match a list of [Exp] without any problems, yet GHCi keeps telling me about this conflict with the function signature
04:22:02 <flux> ilike, but DH doesn't require any preshared information?
04:22:07 <iLike> Nope
04:22:09 <hpc> pelmrq: it's parens, not square brackets
04:22:15 <pelmrq> shit... thank you
04:22:15 <LordBrain> (x:xs) is a list [x:xs] is a list of a list
04:22:19 <merijn> pelmrq: Because "[x:xs]" is a list containing one single list item
04:22:24 <flux> of course, if you don't know the peer's identity, you cannot know if you are creating an encrypted connection with a MitM or with the peer you wanted
04:22:31 <merijn> flux: Nope
04:22:46 <pelmrq> hpc, thank you so much
04:22:56 <flux> merijn, nope what?
04:23:05 <merijn> flux: DH only requires a modulus and base which can be public
04:23:14 <iLike> flux, exactly what I was trying to say :)
04:23:35 <flux> it seems to be we are in a violent agreement
04:23:37 <merijn> There are some factors that go into selecting the modulus and base (there's some properties that make them "stronger"), but no preshared secrets
04:23:49 <LordBrain> lol
04:23:58 <Taneb> There's a Haskell meetup organized in York for the 29th
04:24:06 <Taneb> http://www.meetup.com/York-Haskell
04:29:17 * hackagebot edenskel 2.0.0.2 - Semi-explicit parallel programming skeleton library  http://hackage.haskell.org/package/edenskel-2.0.0.2 (horstmeyer)
04:32:17 <cryptic_> merijn,vanila: why does s_alice and s_bob become the same number?
04:36:04 <vanila> cryptic_, I can't see those anywhere
04:36:21 <cryptic_> http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange
04:36:22 <cryptic_> sorry
04:36:29 <cryptic_> ^^ vanila
04:36:33 <vanila> are you familiar with modular arithmetic?
04:36:42 <cryptic_> under description
04:36:50 <merijn> modular arithmetic is irrelevant
04:36:59 <merijn> They'd get the same number without the modulus as well
04:37:25 <merijn> The modulus is only used to make the reverse operation intractably hard
04:57:09 <izohask> if I say "data ILog a b = Logs (a, [b]) deriving Show"
04:57:26 <izohask> how can I implement Monad instance, ensuring that "b" is a Monoid ?
04:57:58 <izohask> Doing "instance (Monoid b) => Monad (ILog a b) where" doesnt work due to "Kind mis-match"
04:58:22 <merijn> Ah
04:58:37 <merijn> The problem is not the monoid bit, well not directly anyway
04:58:57 <merijn> A Monad is a type with kind "* -> *"
04:59:01 <merijn> :k Maybe
04:59:01 <lambdabot> * -> *
04:59:06 <merijn> :k Either e
04:59:07 <lambdabot> Not in scope: type variable ‘e’
04:59:13 <merijn> :k forall e. Either e
04:59:14 <lambdabot> * -> *
04:59:26 <merijn> However, your "ILog a b" has kind *
04:59:38 <merijn> In other words, it can't be a monad as-is
04:59:41 <chpatrick> izohask: why don't you make the first type parameter the monoid?
04:59:54 <merijn> Well, afaict it doesn't even have to be a monoid?
05:00:00 <izohask> I can, by using "ILog a" in declaring monad instance
05:00:02 <merijn> [b] is already automatically a monoid
05:00:20 <merijn> izohask: Right, but then you can't require 'b' to be a Monoid
05:00:22 <izohask> chpatrick: but I would like to learn how to setup this for second parameter
05:00:26 <chpatrick> izohask: it looks like you're reinventing Writer
05:00:37 <izohask> chpatrick: exactly :)
05:00:39 <chpatrick> you can't, because Monad isn't allowed to know anything about the parameter
05:00:53 <merijn> izohask: That question doesn't make sense, because monads require "* -> *" without knowing what type parameter
05:00:58 <chpatrick> it's a typeclass over something which can take any type
05:01:14 <merijn> izohask: But anyway, why does 'b' have to be a Monoid anyway?
05:01:35 <merijn> izohask: Writer requires a monoid because it's just using mappend, but if you use a list you're done
05:01:37 <izohask> chpatrick: So, last param always must be "free", I can force only non-last parameters to be of some type ?
05:01:44 <merijn> izohask: Right
05:01:56 <merijn> izohask: Well, it depends on the typeclass
05:02:06 <merijn> izohask: For example, Arrow requires the last two to be free
05:02:29 <merijn> Monoid doesn't allow any "free" parameters
05:02:29 <izohask> merijn: OK I understand now.. thnx
05:03:04 <merijn> izohask: But if it's supposed to be Writer and 'a' is the result then you're type parameters are in the wrong order anyway ;)
05:03:27 <merijn> izohask: Plus, the monoid constraint on 'b' is only necessary for Writer if you don't use the list around 'b' you have now
05:03:31 <mpickering> Is there a way to tag things at the type level? for example at the term level if you wanted a list of strings and ints you could have data Tag = I Int | S String and have [Tag] but how can you do this at the type level to mix different kinds?
05:03:35 <merijn> Because [t] is a monoid for all 't'
05:03:55 <merijn> mpickering: The wondrous world of DataKinds! :D
05:04:10 <merijn> mpickering: Lift arbitrary ADTs to the type level \o/
05:04:19 <mpickering> but you can't promote GADTs right?
05:04:20 <izohask> merijn : I know, but I would be happier that I can use something like "Any" etc.. not only lists
05:04:21 <funfunctor> hi
05:04:26 <merijn> mpickering: Ah, no :\
05:04:36 <izohask> merijn: but also some other Monoid instances
05:05:17 <mpickering> Maybe I don't need GADTs but I want to have a kind with some custom constructors like data Kind = A | B | C <type-level string>
05:05:31 <merijn> izohask: Right, but don't you want "data ILog w a = Log (a, w); instance Monoid w => Monad (ILog w)" then?
05:05:31 <mpickering> but can't work out how to reference the type-level string so it gets lifted properly
05:05:33 <izohask> There is no way to say "b must be monoid" in "data ILog a b = Logs (a, b) deriving Show" ?
05:05:53 <funfunctor> silly question: how can I apply a scalar-valued function across the inputs of a vector-valued function. a.k.a  margin (px 0) (px 0) (px 0) (px 0)
05:05:55 <izohask> merijn: You're fantastic!!
05:06:04 <funfunctor> instead of writing px so many times
05:06:26 <izohask> merijn: NOW I understand why this is being done constantly, changing the order of params :)
05:06:31 <merijn> izohask: :)
05:06:38 <funfunctor> I was thinking fmap but surely there is a nicer way
05:06:48 <izohask> merijn: that's what I needed, great , thanks, going further now!!
05:08:00 <merijn> izohask: Anyway, yes, it's always important to consider the order in which one may want to partially apply functions and types when writing down their parameters. Just a matter of practice and experience to figure out what makes sense
05:09:19 <izohask> merijn: Greatž
05:09:20 <izohask> merijn: Great
05:10:01 <mpickering> merijn: I needed to use "Symbol" for the record, not a GADT
05:10:02 <izohask> merijn: so there is different order in type definition then type-constructor definition.. And now I hope I can understand why
05:10:41 <merijn> izohask: Right, the order of type parameters at the type level and the value parameters at the constructor level are completely independent
05:11:20 <merijn> mpickering: So that works? Good
05:11:49 <esimp> Question about arrays.  How can I get the "nth dimension" of the array as a list?
05:12:11 <izohask> how can I check, in GHCI, if e.g. list is instance of Monoid ?
05:12:49 <merijn> izohask: ":info Maybe" (or whatever type) prints out all typeclass instance (that are currently in scope) for a type
05:13:03 <merijn> There may of course be instances in other modules that are not imported
05:13:04 <esimp> Something like:  "elems $ myArr(1, [1..n])"
05:13:18 <izohask> merijn: Confirm :), thnx
05:14:08 <thevishy> any preferred editor in haskell besides vim and emacs ?
05:14:12 <izohask> Now it works for >>=
05:14:27 <thevishy> nedit is good ( recommended by the official site)
05:14:38 <izohask> but for return , I have return x = Logs (x, [])
05:14:46 <izohask>   Could not deduce (m ~ [a0])
05:14:48 <izohask>     from the context (Monoid m)
05:15:03 <merijn> izohask: You're returning an empty list, but in my version there is no list there
05:15:07 <merijn> You probably want
05:15:08 <merijn> :t mempty
05:15:09 <lambdabot> Monoid a => a
05:15:30 <izohask> merijn: ah right
05:15:33 <merijn> thevishy: Whichever editor you feel at home, imo
05:15:43 <izohask> merijn: now it seems all fine... perfect thnx
05:15:50 <merijn> np :)
05:15:54 <thevishy> okay merijn
05:16:27 <merijn> izohask: basically "~" is "type equality" (not quite, but don't worry about it right now)
05:16:53 <merijn> izohask: So when it's saying "Could not deduce (m ~ [a0])" it means "I can't prove that 'm' is a list"
05:17:13 <merijn> Which leads to the question "why the hell does it think it's a list?" :)
05:19:21 <izohask> merijn: OK I'll remember this
05:25:23 <wz1000> Is there any general way to memoize pure recursive functions over a certain range of input?
05:25:48 <mpickering> What type is your range?
05:25:50 <wz1000> Some magic involving fix?
05:26:26 <wz1000> mpickering: anything that is an instance of Eq
05:27:05 <mpickering> There is a paper by ralph hinze called memo functions, polytopically!
05:27:06 <wz1000> mpickering: Take ints for simplicity
05:27:18 <mpickering> also check out MemoTrie by conal
05:27:21 <merijn> Also Conal has a paper + library for memoisation
05:27:37 <mpickering> http://stackoverflow.com/questions/3208258/memoization-in-haskell
05:40:42 <flux> 1/3
05:48:08 <wz1000> @let fib f 0 = 0; fib f 1 = 1; fib f n = f (n-1) + f (n-2)
05:48:10 <lambdabot>  Defined.
05:48:15 <wz1000> :t fib
05:48:16 <lambdabot> (Num a1, Num a, Eq a1) => (a1 -> a) -> a1 -> a
05:50:10 <wz1000> @let memofib f n = (map (fib memofib) [0..]) !! n
05:50:11 <lambdabot>  .L.hs:197:25:
05:50:11 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ Int -> a
05:50:11 <lambdabot>      Expected type: a1 -> a
05:50:34 <wz1000> @let memofib n = (map (fib memofib) [0..]) !! n
05:50:35 <lambdabot>  Defined.
05:50:42 <wz1000> > memofib 40
05:50:46 <lambdabot>  mueval-core: Time limit exceeded
05:51:16 <wz1000> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 40
05:51:17 <lambdabot>  102334155
05:51:20 <kranius> hello, what packages should I use to parallely fetch multiple http endpoints ?
05:51:28 <wz1000> Why the performance difference?
05:51:52 <cryptic_> > map encrypt [1..10] where encrypt = (+1)
05:51:53 <lambdabot>  <hint>:1:21: parse error on input ‘where’
05:52:08 <cryptic_> > let encrypt = (+1) in map encrypt [1..10]
05:52:09 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
05:52:15 <merijn> wz1000: The first one is a memoised quadratic algorithm
05:52:29 <merijn> wz1000: The 2nd is a linear algorithm
05:52:41 <cryptic_> break that one
05:52:53 <merijn> kranius: All of them, I think?
05:52:59 <merijn> kranius: Just use multiple threads?
05:53:17 <merijn> You probably wanna look into the async library too
05:53:21 <wz1000> @let memofib = let fibs = (map (fib memofib) [0..]) in \n -> fibs !! n
05:53:22 <lambdabot>  .L.hs:198:1:
05:53:22 <lambdabot>      Multiple declarations of ‘memofib’
05:53:22 <lambdabot>      Declared at: .L.hs:187:1
05:53:28 <exio4> merijn, quadratic? you mean exponential?
05:53:32 <wz1000> @let memofib' = let fibs = (map (fib memofib) [0..]) in \n -> fibs !! n
05:53:33 <lambdabot>  Defined.
05:53:39 <merijn> exio4: Eh, yes, my bad
05:53:46 <wz1000> > memofib 40
05:53:50 <lambdabot>  mueval-core: Time limit exceeded
05:53:54 <wz1000> > memofib' 40
05:53:58 <lambdabot>  mueval-core: Time limit exceeded
05:54:32 <wz1000> > let memofib' = let fibs = (map (fib memofib') [0..]) in \n -> fibs !! n in memofib' 40
05:54:34 <lambdabot>  102334155
05:54:55 <cryptic_> so: (g^a)^b == (g^b)^a for all a and b?
05:55:03 <cryptic_> at least integers
05:55:19 <wz1000> merijn: A bit of restructuring completely changed the operational semantics of the expression
05:56:06 <wz1000> Would GHC be able to do the restructuring on its own when compiling with -O2?
05:56:33 <merijn> Doubt it
05:56:45 <wz1000> @undefine
05:56:46 <lambdabot> Undefined.
05:57:39 <wz1000> So I should always try to pull expensive computations out of functions?
05:58:03 <merijn> wz1000: Yes, no, maybe
05:58:12 <merijn> The question is too broad and vague to answer
06:08:55 <kranius> merijn: Yes I think I need async thanks.
06:52:54 <skilpat> Hi everyone. Does anyone know of an existing tool that grabs all the orphan instances defined in some package?
06:53:55 <merijn> What do you mean by "grab"?
06:55:19 <skilpat> Something that parses the source files of a package and spits out, e.g., some textual representation / AST node for each orphan instance.
06:55:51 <skilpat> Either in Haskell source code, or (as part of) some kind of executable
06:56:24 <merijn> I doubt that exists
06:58:40 <skilpat> Yeah, didn't think so, but was still worth a shot. :) I was at least hoping there might be something that analyzes whether an instance definition is an orphan, without actually invoking the full typechecker or reading from a .hi file.
07:01:11 <indiagreen> skilpat: you can get the list of all types, classes, and instances declared in the package by using... well, grep, probably – and it should be enough to determine whether each instance is orphan
07:02:51 <skilpat> Well, that's what I had initially thought too. But there's a fairly complicated analysis to determine whether an instance is an orphan; you at least need to invoke the Renamer to know the full names of the concerning types and classes. (And which types you look at in the instance head is a tricky thing too.)
07:03:08 <indiagreen> ouch, right
07:03:13 <indiagreen> nevermind then
07:03:47 <skilpat> Probably it's best to just download, compile, and then analyze the .hi files of each package!
07:04:24 <ClaudiusMaximus> or grep the output of ghc -Wall for orphan instance warnings
07:04:44 <skilpat> oh good point!
07:06:32 <merijn> Don't forget to use the no code flag to maximise speed
07:17:37 <sx> I thought I once read about an extension which allows definitions to use whatever is in scope for certain identifiers, does anyone know how this extension is named?
07:17:49 <tasker> I have a list of integers, and wish to select the longest continuous (in position) group of them that have a total difference of less than some number. I assume this is similar to substring matching, but maybe there is a more efficient way of doing it?
07:18:44 <merijn> Best I can think of is a single list traversal
07:19:24 * hackagebot Treiber 0.0.1 - Lock free Treiber stack  http://hackage.haskell.org/package/Treiber-0.0.1 (julek)
07:20:47 <tasker> merijn: This is what I was thinking.
07:21:19 <tasker> actually no, what I was thinking of may have more than one traversal actually
07:23:01 <merijn> I think it should be doable in one, but it'll require a bit of clever thinking anyway, because I don't remember exactly how I did something similar earlier this year :p
07:24:05 <tasker> haha
07:24:06 <tasker> fair play
07:24:58 <tasker> I was thinking to traverse a group where the total diff remained below the threshold, but start a new traversal at each point where the difference was >1, then choose the longest of those
07:26:23 <blueonyx> hi, does anyone use a keyboard layout like neo2 and cant type numbers in ghci?
07:26:25 <merijn> tasker: Well, consider the following invariant
07:26:46 <merijn> tasker: Actually, I think my invariant may not hold :p
07:26:52 <tasker> merijn :P
07:26:58 <merijn> The problem I solved was to maximise the difference in a continuous streak
07:27:11 <merijn> Not, longest streak within a certain bound
07:27:36 <merijn> Anyway one notable invariant in my case was, "a new streak can only start at the point I find a new minimum lower than the current one"
07:28:35 <merijn> So you only had to track the "current" streak and the "new" minimum to decide on every item whether you'd found a new streak
07:28:58 <tasker> ahh I see
07:29:37 <merijn> That doesn't directly translate, but I'd aim for such a single traversal (unless your list is short, then who cares ;)
07:30:50 <tasker> True. Actually it should at most be ~100
07:30:55 <tasker> so I guess it probably doesn't matter too much
07:31:03 <tasker> unless my algo is really terrible, of course :p
07:32:17 <ocramz> hi all
07:32:42 <ocramz> I have a bit of an abstract and poorly-worded question, pls bear with me
07:32:46 <c_wraith> tasker: I've written O(n!^2) algorithms before.  They're too slow to be usable when dealing with more than about 8 elements. :)
07:33:06 <tasker> c_wraith: Haha, nice :)
07:33:07 <merijn> c_wraith: This is not n! though
07:33:10 <tasker> Well, we shall se..
07:33:17 <merijn> c_wraith: This is just n^2, no?
07:33:21 <tasker> merijn: You don't know how bad I am at writing algorithms..
07:33:37 <merijn> For every element in the list traverse until your sequence exceeds the bounds
07:33:48 <tasker> True true :P
07:33:50 <merijn> The worst case would be "for every element traverse until the end of the list"
07:34:00 <merijn> n^2 is irrelevant for n < 1,000
07:34:05 <merijn> Or maybe even 10k
07:34:41 <ocramz> I’d like to express algebraic constraints between subexpressions in a formula, for the purpose of simplification
07:35:27 <ocramz> which haskell could represent this?
07:35:29 <tasker> Thanks for the help merijn. I'm gonna go for a run before implementing.
07:35:34 <ocramz> *haskell idiom
07:37:31 <ocramz> e.g. to preserve, A^-1 * A = Id
07:37:50 <ocramz> or A x = b
07:39:33 <ocramz> hope somebody bothers to chime in with a suggestion :) cheers
07:47:09 <ocramz> as in, I’m not interested in the numerical result of those operations, but rather in transporting the information that the present result derived from those previous manipulations
07:48:10 <ocramz> or is this implicit due to lazy evaluation?
07:49:59 <johnw> what are the types involved?
07:50:04 <johnw> what is A, and Id, x and b?
07:52:17 <merijn> Wait
07:52:22 <merijn> Sums are just coproducts?
07:52:44 <hodapp> wut?
07:53:20 <merijn> hodapp: That question requires putting on a category theory hat :)
07:53:32 <hodapp> merijn: there is already a dunce cap permanently on my head
07:53:45 <merijn> :)
07:53:50 <merijn> Stack them!
07:56:16 <aupo> What's up with HaskellWiki being ultraslow to load?
07:56:28 <johnw> aupo: it's a known problem being worked on
07:56:33 <aupo> 'kay.
07:58:08 <merijn> aupo: basically, during an emergency migration a few weeks ago the server was moved to a different datacenter than the one holding the database
07:58:32 <merijn> Hence the speed now sucks >.<
07:58:47 <johnw> it's like anti-sharding
07:59:02 <merijn> johnw: cosharding?
07:59:13 <johnw> contrasharding
07:59:23 <tdammers> unsharding
07:59:27 <johnw> haha
07:59:33 <merijn> unsharing would be mending :p
07:59:51 <tdammers> I bet it would involve lots of glue code
08:00:23 <sx> What's the best way to express an Integer with RebindableSyntax on? Even when I write (1 :: Integer) it gets desugared with fromInteger? Or is fromInteger defined as id for Integer?
08:00:50 <ocramz> merijn, johnw, hodapp : the data types of A, x, b, Id are I’d say undefined at this stage, but I’m just interested in preserving the symbolic constraints
08:01:17 <ocramz> does this make sense in haskell? apologies for the poor wording
08:01:23 <merijn> sx: It better be!
08:02:12 <johnw> ocramz: they can be polymorphic, but I still need to know the kinds
08:02:23 <johnw> is A a concrete type?  a number?
08:02:58 <johnw> also, you cannot ensure that the laws are never violated by any A in Haskell, if other users are allow to provide their own A
08:04:05 <sx> merijn: I defined fromInteger as a record selector and used it with RecordWildCards. Turns out that's a bit problematic when you actually don't use the record wild card pattern, because then you always have to bring another fromInteger in scope.
08:04:24 <ocramz> let’s say A is a symbol in an ADT
08:04:39 <johnw> so, for data Foo = Bar, A is Bar?
08:04:52 <ocramz> and I wish to enforce the definition of identity wrt to a product defined for A’s
08:05:01 <ocramz> yes
08:05:06 <merijn> sx: You just made me really sad :(
08:05:20 <sx> merijn: Trust me, I feel the same. :)
08:08:06 <johnw> ocramz: you can create a type class to indicate that a given type's inhabitants should support inversion; but the laws are sadly not enforceable in Haskell (yet).
08:08:27 <ocramz> hmm this is already very interesting, thank you
08:08:52 <ocramz> you mean there is a language extension or proposal that would do something similar?
08:08:55 <johnw> example: class Monoid a => Group a where inv a :: a -- LAW: a `mappend` inv a = mempty
08:08:56 <merijn> johnw: I doubt they'll ever be :)
08:09:04 <johnw> well, a dependently typed language CAN do this
08:09:08 <merijn> Sure
08:09:10 <johnw> and Haskell is every day inching toward dependent types
08:09:15 <johnw> but it may never reach far enough for this
08:09:26 * hackagebot hxt-relaxng 9.1.5.3 - The HXT RelaxNG validator  http://hackage.haskell.org/package/hxt-relaxng-9.1.5.3 (UweSchmidt)
08:09:30 <ocramz> dependent types, this is the notion
08:09:31 <merijn> Well, a total dependently typed language can. I'm not sure just dependently typed is sufficient
08:09:42 <ocramz> I was lacking the term
08:09:52 <johnw> ocramz: right, in Coq this is our bread and butter
08:10:14 <ocramz> hmm
08:10:45 <ocramz> so I’ll have to devise a way to approximate this behavior in haskell
08:10:55 <johnw> example: Class Group `{Monoid a} := { inv : a -> a; inv_law : forall a, mappend a (inv a) = mempty }
08:11:16 <johnw> your approximations will never have the force of a law
08:11:33 <johnw> now, I've seen people prove that a *specific* Monoid fulfills the law in Haskell
08:11:46 <johnw> but not associating a proof requirement with the type class itself
08:12:17 <ocramz> a Class Group, is this Coq?
08:12:24 <johnw> yeah, that last code example is Coq
08:12:34 <johnw> the law is just another function in the type class
08:12:37 <johnw> with a dependent type
08:12:37 <ocramz> yes that’s precisely what I meant
08:12:45 <ocramz> instancing a monoid
08:12:54 <ocramz> but mappend would be undefined
08:13:05 <johnw> mappend comes from the Monoid instance
08:15:52 <ocramz> so: mappend is associative, and mempty is the identity for mappend
08:16:25 <johnw> right
08:18:17 <fikse> how are migrations handled in haskell?
08:18:26 <johnw> how do you mean?
08:18:58 <ocramz> for a dataype to be an instance of Monoid, I’ll need to define an associative operation and an identity element to go with it
08:19:30 <johnw> correct
08:19:44 <fikse> johnw: sorry that wasn't clear, i was really asking if there was a nice migrations tool for haskell
08:19:50 <johnw> what kind of migration?
08:20:01 <johnw> database?  cabal?  falcon?
08:21:03 <fikse> johnw: i've never heard of falcon, do you have a link?
08:21:10 <ocramz> matrix inner product is associative, and the identity is the kronecker symbol
08:21:17 <fikse> johnw: i didn't realize there were separate types of migrations
08:21:18 <geekosaur> tjat ws not an answer, it was a question
08:21:28 <geekosaur> I can think of all sorts of migrations
08:21:33 <fikse> i thought all db migrations were basically sql scripts
08:21:34 <geekosaur> I have worked on all sorts of migrations
08:21:42 <geekosaur> finally...
08:21:46 <johnw> sorry, I was being humorous, but I failed
08:22:03 <fikse> oh, i see, bird migrations
08:22:09 <johnw> the persistent library handles db migrations
08:22:15 <ocramz> so these concepts are instances, for finite dimensional algebra, of inner products in Hilbert spaces
08:22:19 * fikse pats johnw on the back, it's okay it's not you buddy
08:22:31 <johnw> I'm not sure what else you could use, since I haven't done much in that area yet
08:22:34 <johnw> :)
08:23:16 <ocramz> but operator composition is in general not commutative, so I wonder about a way to guarantee that as well
08:23:40 <tdammers> fikse: two approaches, really - one, keep track of all schema changes and apply them in order, and two, keep note of what the schema should be, and generate suitable changes on the fly based on what you find
08:24:06 <tdammers> the first approach is "more correct", but the second one requires less work and diligence once you have a suitable library in place
08:24:07 <johnw> ocramz: you could always have an Abelian class on top of Group
08:24:19 <johnw> I think algebraic hierarchies have been done a few times in Haskell as libraries
08:24:47 <geekosaur> fikse, there's several things in the databaes category on hackage for database migrations... the ones I spot checked all claim to be experimental and incomplete though
08:25:01 <geekosaur> I thought I saw an announcement for a new one within the past couple weeks
08:25:21 <johnw> does postgresql-simple do migrations, does anyone know?
08:26:23 <ocramz> johnw: thank you, I’ll look into this
08:27:09 <fikse> tdammers: the second option is what i'm looking for
08:29:25 <fikse> geekosaur: that would be neat if you could remember which one it was
08:29:31 <fikse> i'm only seeing https://github.com/jtdaugherty/dbmigrations right now
08:29:47 <NemesisD> is there a sensible reason why the official process package uses strings for everything?
08:30:41 <geekosaur> I also saw http://hackage.haskell.org/package/database-migrate but it seems old.
08:30:49 <NemesisD> i guess there's process-extras
08:30:49 <geekosaur> NemesisD, historical reasons?
08:30:57 <geekosaur> process predates ByteString
08:31:09 <NemesisD> geekosaur: there's no reason why it coudln't be added though right? in a different module
08:31:43 <geekosaur> providing someone did the work and pushed it through libraries...
08:32:16 <NemesisD> i just think its a bad look that the official libraries are doing things that are unacceptable for production systems
08:34:39 <geekosaur> mrr, looks like the message I was remmebering was in fact a different kind of migration (of in-memory data, not SQL databases)
08:35:13 <edk> 7
08:35:16 <edk> oops, sorry.
08:37:43 <mseeks> is there something like (a -> b) -> a -> a -> (b, b)?
08:37:52 <mseeks> I feel like Arrow should have it but can't find it
08:38:12 <mseeks> is it actually (&&&)?
08:39:21 <supki> :t curry . join (***)
08:39:22 <lambdabot> (b -> c) -> b -> b -> (c, c)
08:40:39 <mseeks> thanks
08:41:38 <ezrios> Hello, I am writing a chess AI and I have a function makeMove :: Board -> Move -> Board
08:42:11 <ezrios> I am wondering, if I want to, say, get the value of the board two moves ahead, I usually have to do something like
08:42:19 <ezrios> makeMove (makeMove original move1) move2
08:42:40 <mseeks> supki: why is it OK to do join on (***)?
08:42:46 <ezrios> is there some kind of idiomatic way of doing this as opposed to having to nest repeated function calls and thread the last state of the board through each call?
08:42:50 <mseeks> join is m (m a) -> m a
08:42:50 <ezrios> is this a case for the State monad?
08:43:25 <mmachenry> ezrios: What's the larger context in which you're doing this?
08:43:27 <mseeks> but the `m (m ..)` in (***) are `a b c -> a b' c' -> ...` and they're not the same type
08:43:40 <mmachenry> Are you really just trying to see what would happen if you made two given moves?
08:43:57 <mmachenry> Or are you trying to do a min-max algorithm on ever possible set of moves for two players?
08:45:08 <mmachenry> If you're just wanting to see what happens after two moves, nesting function calls seems totally fine. If you really dislike it, put the result of the first in a let binding. If you're evaluating the result of a list of moves on a game state, I'd suggest using a fold.
08:45:23 <ezrios> mmachenry: both cases actually arise in my code
08:45:45 <ezrios> I am more concerned about the first case right now though
08:45:46 <mmachenry> If you are trying to do something with many possible moves like min-max, I'd suggest using the List Monad
08:45:58 <saep> foldr (flip makeMove) board [move1, move2]
08:46:43 <ezrios> ok, thanks for the recommendation
08:46:51 <mmachenry> ezrios: saep's solution is the fold I was talking about but if you're really just doing that for two moves it might rather obscure the meaning.
08:47:16 <mmachenry> ezrios: Though personally, I would probably right a function called applyMoves that does that fold just to have as a utility.
08:47:40 <sgronblo> Do you always have to create a newtype with an instance of Arbitrary if you want to generate a special type of restricted input with quickcheck?
08:48:58 <sgronblo> And if so, how will you encode something like data IntInRange = data IntInRange Int Int
08:51:25 <sgronblo> Ah there seems to be some choose stuff
08:53:58 <hiptobecubic> I didn't realize Int was 64 bit this whole time :|
08:54:21 <indiagreen> hiptobecubic: it's 32bit on 32bit systems
08:54:28 * hackagebot haddocset 0.3.2 - Generate docset of Dash by Haddock haskell documentation tool  http://hackage.haskell.org/package/haddocset-0.3.2 (HirotomoMoriwaki)
08:54:36 <hiptobecubic> indiagreen, sure. makes sense
08:56:12 <mseeks> does anyone use structured-haskell-mode? i want to turn off the paredit-like functionality; i like the ability to delete arbitrary parens
08:56:37 <sgronblo> It seems like if I created a data IntInRange = data IntInRange Int Int, its arbitrary implementation would have to return a Gen IntInRange
08:56:44 <sgronblo> Instead of returning an Int
08:59:25 <jtanguy> sgronblo: could you give more info on your usecase ?
08:59:28 * hackagebot tasty-kat 0.0.2 - Known Answer Tests (KAT) framework for tasty  http://hackage.haskell.org/package/tasty-kat-0.0.2 (VincentHanquez)
08:59:33 <hiptobecubic> What's the equivalent of foldl1 on Arrays?
09:00:09 <jtanguy> it seems that you might want to define the Arbitrary instance at a higher level indeed
09:00:43 <sgronblo> jtanguy: I would like to test a function for arbitrary Ints within a range
09:01:51 <izohask> How do I reason for such data definition : data Cheat a = Cheat (a (Cheat a))
09:02:03 <izohask> what does it mean, how to understand ?
09:02:18 <sgronblo> Ah wait, quickcheck is based on types, not values right?
09:02:19 <mseeks> does anyone use structured-haskell-mode? i want to turn off the paredit-like functionality; i like the ability to delete arbitrary parens
09:02:55 <glguy> izohask: Which part are you having trouble with?
09:03:34 <chpatrick> izohask: it feeds a back into itself
09:03:37 <izohask> I do not get why (Cheat 4) works, while (Cheat "abc") creates an error ?
09:04:19 <chpatrick> izohask: in what sense does Cheat 4 work?
09:04:24 <glguy> Cheat 4 doesn't really work until you provide a Num instance
09:04:29 <izohask> :t Chat 4 shows type
09:04:30 <lambdabot> parse error on input ‘type’
09:04:36 <glguy> Cheat [Cheat [], Cheat[]] :: Cheat []
09:04:42 <izohask> :t Cheat "abc" shows an error
09:04:43 <lambdabot> Not in scope: data constructor ‘Cheat’
09:04:43 <lambdabot>     Not in scope: ‘an’
09:04:43 <lambdabot>     Perhaps you meant one of these:
09:05:01 <geekosaur> numeric literals are polymorphic, so if you provide a suitable Num instance it can try to build the tyoe
09:05:02 <chpatrick> izohask: it works because 4 could potentially be a literal for anything
09:05:15 <geekosaur> there is an extension to make string literals be similarly polymorphic
09:05:33 <geekosaur> (note that being able to show a type at that stage does not promise that a suitable instance can be created)
09:06:03 <geekosaur> (just that the compiler is prepared to use such an instance, should it ever appear. "open world assumption")
09:06:39 <glguy> data Cheat (a :: * -> *) = MkCheat (a (Cheat a)) -- renaming the data constructor for the moment.  The type "Cheat a" has one constructor MkCheat which has one field of type "a (Cheat a)"
09:06:53 <glguy> You have to pick an "a" with the correct kind, * -> * in this case
09:07:10 <glguy> That's things like list [], Maybe
09:07:23 <glguy> Cheat (Just (Cheat Nothing)) :: Cheat Maybe
09:08:00 <glguy> Cheat :: Maybe (Cheat Maybe) -> Cheat Maybe   -- one possible instantiation of the data constructor
09:08:15 <izohask> Cheat Maybe... Aha...
09:08:18 <fikse> dcoutts: why is stm better than the actor model for single node concurrency
09:08:34 <trap_exit> what's the standard way to have two different haskel progs talk to each other?
09:08:38 <trap_exit> just use TCP ?
09:08:52 <izohask> so basically... part "a (Cheat a)"
09:09:32 <izohask> means that "a" has to be type constructor accepting (Cheat _same_type) as parameter ?
09:10:17 <glguy> yeah
09:10:31 <fikse> for single node concurrency, why should stm or something similar be used?
09:11:18 <glguy> fikse: You might have an invariant that you'd like to preserve across multiple mutable elements which are accessible to multiple threads
09:11:32 <jtanguy> sgronblo: you could make use of the (Testable a => Testable (Gen a)) instance
09:12:28 <jtanguy> i.e. fmap your function in the Gen Int given by choice
09:12:39 <merijn> fikse: STM and actor model are not mutually exclusive
09:12:53 <fikse> merijn: interesting
09:13:38 <merijn> There's even transactional channels you can use to implement communicating actors with
09:14:11 <HelpMen> Help ;) http://fnd.us/c/eviz9 Thanks
09:14:13 <Hijiri> I could imagine also implementing STM as an actor that takes transactions as messages, or something
09:14:27 <mseeks> `hoogle data` gives an error about haskell.org expired certificate, anyway to fix?
09:14:33 <Hijiri> I wouldn't be able to imagine it in much detail though, because I don't have a lot of experience there
09:16:03 <izohask> glguy: why ":t Cheat (Just (Cheat Nothing))" works, while ":t Cheat (Just (Cheat (Just "abc")))" doesnt, while
09:16:20 <izohask> ":t Cheat (Left (Cheat (Left "a")))" seems to be fine ?
09:18:57 <J_Arcane> mseeks: that's odd. cert looks fine to me from here. maybe try the FP Complete mirror?
09:19:57 <J_Arcane> https://www.fpcomplete.com/hoogle?q=data
09:19:59 <lf94> Starting to think Haskell is way too verbose
09:20:14 <indiagreen> lf94: compared to what?
09:20:21 <mseeks> J_Arcane: how can I do that?
09:20:26 <lf94> compared to Python, Ruby, C#
09:20:35 <J_Arcane> mseeks: see link.
09:20:52 <indiagreen> can't say anything about Python, but probably agreed about Ruby
09:21:21 <indiagreen> for me static typing and explicitness are worth it, tho
09:21:34 <ij> lf94, Show me an example where ruby's terser.
09:21:40 <mseeks> J_Arcane: I'm trying to download a local hoogle so I'm running `hoogle data` on the cmd line
09:21:45 <J_Arcane> lf94: Try F#?
09:21:53 <mseeks> that's where I'm getting the error
09:21:58 <lf94> J_Arcane, thinking about it
09:22:07 <J_Arcane> mseeks: oh, never mind, misunderstood, sorry.
09:22:27 <indiagreen> ij: I recently had to rewrite Shopify's template engine to Haskell, and Ruby was much terser
09:23:28 <indiagreen> of course, it was partly because the semantics of template engine itself are closer to Ruby, but still
09:23:41 <hodapp> huh, so https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/hsc2hs.html mentions the generation of header files, but when running it on an .hsc file I created, I only get the -_hsc_make.c file
09:25:04 <hodapp> is there some command I am supposed to pass to hsc2hs to make it generate headers?
09:26:05 <J_Arcane> lf94: I found F#'s 'light syntax' and idiomatic tendency to rely on type inference over explicit type statements could make for a clearer, yet terser syntax even than Lisp. It's a quite nice language, I just need a more solid footing with the .NET world I think to get as much use out of it as I'd like.
09:27:02 <hodapp> the docs seem to say it should just generate them magically, but I have no idea
09:29:30 * hackagebot paypal-adaptive-hoops 0.5.0.0 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.5.0.0 (fanjam)
09:29:37 <ocramz> > let a = 1
09:29:38 <lambdabot>  not an expression: ‘let a = 1’
09:29:44 <ocramz> :D
09:31:30 <matematikaadit> > let a = 1 in a
09:31:32 <lambdabot>  1
09:32:01 <NemesisD> could somebody explain MonadMask to me like i'm 5? i have no idea how i'm supposed to implement this for my transformer stack
09:32:58 <hodapp> okay, perhaps I should just not be using hsc2hs.
09:33:41 <hodapp> it tends to be a red flag when no one can be bothered to write docs.
09:34:25 <hodapp> the source code seems to say something about whether or not it should generate the header, and the docs don't.
09:34:30 * hackagebot monoidal-containers 0.1.0.0 - Containers with monoidal accumulation  http://hackage.haskell.org/package/monoidal-containers-0.1.0.0 (BenGamari)
09:37:30 <hiptobecubic> This code presumably gets fused into a single loop, right? from the memory footprint, it must be. But what stops it from just computing the result at compile time then? It makes for a difficult comparison with, ex. gcc, because gcc essentially just pushes 0x7FFFFFF8000000 into a register and prints it.
09:37:34 <hiptobecubic> http://vpaste.net/4tz0U
09:38:17 <quchen> hodapp: hsc2hs is a tremendous help when you combine it with c2hsc and bindings-dsl
09:38:32 <merijn> hiptobecubic: GHC doesn't do a lot of constant folding
09:38:38 <merijn> hiptobecubic: Try compiling with LLVM
09:39:10 <hodapp> quchen: I'm just having a very hard time finding the answer to the question, "How do I make hsc2hs generate a header?"
09:39:15 <hiptobecubic> merijn, can't apparently. Arch's llvm is too new for 7.8
09:39:21 <hodapp> quchen: the docs say it just "should"
09:39:28 <merijn> hiptobecubic: Grab a VM :p
09:39:33 <quchen> What's a header?
09:39:41 <hodapp> quchen: a C header
09:40:13 <quchen> I've only used hsc2hs to generated hs files, I'm surprised headers are within its scope
09:40:25 <merijn> Why would it generate a C header?
09:41:21 <hodapp> merijn: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/hsc2hs.html - because the docs talk about it like it should?
09:41:33 <quchen> My pipeline is ".h --(c2hsc)--> .hsc --(correct manually)--> .hsc --(hsc2hs via Cabal)--> hs
09:41:34 <quchen> "
09:42:03 <geekosaur> that sounds like a fossil from -fvia-C days, tbh
09:42:17 <hodapp> quchen: all I'm really trying to accomplish is that I have definitions that can be used both from within Haskell and from within C (in this case, generated C that Ivory needs to use - no FFI)
09:42:46 <quchen> Hm, that's beyond my scope then
09:42:53 <hodapp> I don't particularly care if the constants are defined in Haskell, or in C headesr
09:42:57 <merijn> hodapp: GHC already generates header files for foreign exports
09:43:19 <hodapp> merijn: I'm not doing any sort of foreign export here
09:43:33 <merijn> Also, check out the capi foreign import. That can import/deal with macros
09:43:43 <merijn> hodapp: Then I have no clue what you are trying to do
09:43:58 <mseeks> why is Data.Char.isAlpha '\202' == True?
09:44:03 <hodapp> merijn: see what I told quchen
09:44:17 <geekosaur> > chr 202
09:44:18 <lambdabot>  '\202'
09:44:22 <geekosaur> whoops, right
09:44:37 <ChristianS> lambdabot does have very good unicode support
09:44:56 <geekosaur> > text (chr 202 : [])
09:44:58 <lambdabot>  Ê
09:45:05 <geekosaur> looks like alpha to me
09:45:15 <ChristianS> yep
09:45:51 <hodapp> I suppose I could just write a C header and include it from the .hsc file
09:46:07 <mseeks> hmm
09:47:51 <NemesisD> edwardk: is this accurate: he mentions the docs but i don't see where it says that EitherT can't be an instance of MonadThrow https://github.com/ekmett/exceptions/issues/35
09:55:19 <michaelt> NemesisD: bgamari was talking about MonadMask, not MonadThrow, which does have an instance in EitherT or rather the new ExceptT
09:56:01 <NemesisD> erm i meant MonadMask
09:57:09 <NemesisD> so i've got a stack that looks like newtype Foo a = Foo (unFoo :: EitherT (ReaderT Config IO) a), i'm trying to use System.IO.Temp which requires your monad satisfy MonadIO and MonadMask
09:57:12 <michaelt> Oh, it is asserted https://github.com/ekmett/exceptions/blob/master/src/Control/Monad/Catch.hs#L280
09:57:50 <NemesisD> i mechanically implemented a MonadMask instance and in the happy path it seems to work. i have no idea what i'm doing
09:59:04 <NemesisD> i wonder if at the call site i can just unwrap my monad down to ReaderT where MonadMask is defined
09:59:09 <horny-sama> finally managed to install ghc-7.8.4 on my fedora
10:00:03 <clrnd> horny-sama, congrats
10:00:12 <horny-sama> thxx
10:01:19 <hodapp> okay, hsc2hs's tendency to tell me nothing at all in its errors is getting irritating; it is refusing to handle the #const usage I'm giving it...
10:01:46 <NemesisD> that worked! oh monad transformers. is ther any task you can't make more difficult?
10:10:35 <horny-sama> now I have to fix ,my js ide
10:10:35 <horny-sama> :<
10:14:32 * hackagebot entropy 0.3.5 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.3.5 (ThomasDuBuisson)
10:17:41 <mseeks> is there anything to do (Word8 -> a) -> ByteString -> [a]?
10:18:06 <merijn> unpack + map?
10:18:21 <mseeks> ohh should've of thought of that
10:18:24 <merijn> :)
10:18:25 <mseeks> thanks
10:22:07 <quchen> merijn: Semifunctor!
10:22:09 <quchen> ;-)
10:24:33 * hackagebot tasty-kat 0.0.3 - Known Answer Tests (KAT) framework for tasty  http://hackage.haskell.org/package/tasty-kat-0.0.3 (VincentHanquez)
10:27:24 <ij> Why doesn't _2 typecheck? http://sprunge.us/DPYO
10:28:25 <glguy> ij: because of the flip
10:29:06 <ij> Totally... Brainfart.
10:36:22 <sx> Does pure/return actually belong into the Functor class? Or are there functors for which there is no such operation? And could you then give an example of such?
10:36:30 <merijn> No
10:36:38 <merijn> As in, no they don't belong there
10:36:59 <sx> merijn: could you specify this? :D
10:37:08 <glguy> The type   (,) a   is a functor
10:37:16 <mitchty> too much german for the day, read brainfart as brainfahrt and was rather confused
10:37:23 <merijn> glguy: Good point, I was trying to think of that :)
10:37:25 <glguy> then you'd have:    pure :: b -> (a,b)
10:37:32 <sx> glguy: Thank you.
10:37:58 <bitemyapp> Cabal is being batty. Why does it think there's a 1.18 version of Cabal installed? http://lpaste.net/8571569380561780736
10:38:02 <merijn> Where as "fmap :: (a -> b) -> (e, a) -> (e, b)" makes complete sense :)
10:38:16 <sx> To be honest, I always found the functor instance for (,) strange.
10:38:23 <bitemyapp> sx: why?
10:38:25 <merijn> sx: Why? :)
10:38:28 <glguy> WHY?
10:38:29 <hodapp> bitemyapp: Do you have some newer version in ~/.cabal/bin or something?
10:38:39 <bitemyapp> hodapp: no
10:38:47 <hexagoxel> bitemyapp: `ghc-pkg list Cabal` ?
10:39:01 <bitemyapp> [callen@alzhared:~/Work/bloodhound]$ ghc-pkg list Cabal
10:39:02 <bitemyapp> /nix/store/cq4qqjii3s9ghr6p59kkrdf44wnyhpp4-ghc-7.8.4/lib/ghc-7.8.4/package.conf.d Cabal-1.18.1.5
10:39:09 <bitemyapp> hrm. that doesn't seem good.
10:39:11 <sx> bitemyapp, merijn: It seems arbitrary to only map over the first argument.
10:39:11 <bitemyapp> how do I make that go away?
10:39:16 <bitemyapp> sx: is it now?
10:39:21 <merijn> sx: Second argument
10:39:26 <sx> ah, right
10:39:37 <merijn> sx: But that's exactly what fmap *is*, a type changing function with 2 laws
10:39:39 <bitemyapp> sx: you could flip the type arguments, but why bother?
10:39:46 <bitemyapp> hexagoxel: unregister?
10:40:02 <merijn> sx: The laws are: "fmap id == id" and "fmap f . fmap g == fmap (f.g)"
10:40:02 <hexagoxel> won't work, it is boot package, i think
10:40:08 <bitemyapp> hexagoxel: wtf :(I
10:40:10 <hexagoxel> *boot lib
10:40:13 <bitemyapp> hexagoxel: what am I supposed to do then>
10:40:20 <merijn> sx: The instance of Functor for "(,) a" obeys both laws
10:41:23 <sx> merijn: It's true, but the only reason because it is only a Functor for the second argument ist because of the sequentiality of type application in haskells type system.
10:41:24 <glguy> I think people get stuck thinking about things like fmap and traverse working on "containers" of just one type argument
10:41:28 <merijn> sx: The only real restrictions are "do the types match?" and "does it obey the laws?"
10:41:33 <glguy> because those are the early examples
10:41:39 <merijn> sx: Sure, that's why we have a "Flip" newtype ;)
10:41:48 <merijn> sx: Also,  maybe you'll approve more of Bifunctors
10:42:18 <sx> merijn: Yeah, well I guess I can accept it now. :P
10:42:23 <merijn> sx: "bimap :: Bifunctor f => (a -> c) -> (b -> d) -> f a b -> f c d"
10:42:41 <merijn> sx: (,) obviously being a Bifunctor, just like Either
10:44:02 <merijn> I'm guessing the laws of Bifunctor are simply "bimap id id == id" and "bimap f g . bimap h i == bimap (f.h) (g.i)", but there maybe more
10:45:23 <ij> Ghc throws an error at the second one, can I somehow get it to work with the second one? I don't like that much indent. http://sprunge.us/MFHE
10:46:15 <IP92> where should I start learning haskell when I have no prior experience with it, nor functinal programming. I know Java, Python and some C so far.
10:46:17 <glguy> ij: why not:    case way of 'x' -> ...; 'y' -> ... ; _ ->
10:46:48 <michi7x7> I wonder how many typeclasses you could introduce before actually getting lost in all that mess
10:46:52 <merijn> IP92: https://github.com/bitemyapp/learnhaskell and Learn You a Haskell
10:46:58 <glguy> ij: and if it's an error to go with something other than x y z, you might want:  data Axis = X | Y | Z
10:47:04 <merijn> michi7x7: We have a name for that! :p
10:47:36 <merijn> michi7x7: It's not restricted to just typeclasses, though. The Fairbairn-threshold is the "threshold below which a function is easier to reinvent then remember it's existence"
10:47:44 <merijn> Same logic could apply to typeclasses :p
10:47:54 <glguy> ij: Otherwise you might like Multi-way if-expressions   search this page for that https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html
10:48:29 <IP92> merijn: http://www.amazon.com/Learn-You-Haskell-Great-Good/dp/1593272839 this you mean?
10:48:45 <michi7x7> merijn: nice, but nobody actually seems to consider that ^^
10:48:51 <merijn> michi7x7: In practice, the most important ones are probably just Functor, Monad, Applicative, Foldable, Traversable, Bifunctor, Contravariant, and nowadays Profunctor and Category
10:49:02 <merijn> IP92: Yes, it's available for free online too
10:49:13 <merijn> Oh!
10:49:29 <merijn> I forgot Monoid, Alternative and MonadPlus
10:49:35 * shapr hugs bitemyapp
10:49:41 <glguy> It's probably OK to forget the latter 2 ^_^
10:49:55 <michi7x7> merijn: nice, I know Monads and Applicative. I have also been told to know Functor, but I think I forgot the concept
10:49:56 <merijn> glguy: No, their crucial for parsers and list monad
10:50:05 <merijn> michi7x7: Functor is just fmap
10:50:10 <merijn> michi7x7: i.e. generalised "map"
10:50:21 <glguy> merijn: The operations are important in those too cases, but they are less important as classes in general
10:51:00 <merijn> michi7x7: And even if you don't know all of the ones I mentioned, a lot of them only get useful when you start writing more abstract/generic code :)
10:51:28 <merijn> I would say that Functor, Applicative, Monad and Monoid are the most crucial ones
10:51:42 <merijn> Foldable/Traversable are also important, but "obvious"
10:52:02 <ij> glguy, Nice, thanks.
10:52:37 <michi7x7> merijn: aren't Functor, Applicative, Monad and Monoid terribly close?
10:53:49 <michi7x7> I've only used Monad-Instances (Maybe, Either, List, ...) but at least those have instances for all those typeclasses, no?
10:56:31 <merijn> michi7x7: The first three are super (or sub, depending on point of view) sets of eachother
10:56:46 <merijn> michi7x7: i.e. every Monad is also an Applicative and every Applicative is also a Functor
10:56:54 <merijn> michi7x7: But not necessarily the other way around
10:57:35 <merijn> And 7.10 will fix a long standing mistake that will force every Monad to have a corresponding Functor and Applicative instance
10:57:54 <merijn> But, time to go
10:58:12 <michi7x7> I think I might need a real Haskell project, but I don't have time atm ;/
11:04:25 <SrPx> Does anyone know why "sqrt (-7) == NaN" on GHCI, but "sqrt (-7) == 0.0" on GHC?
11:05:40 <athan> SrPx: Is it an Int? Integer?
11:05:57 <SrPx> float
11:06:34 <SrPx> sqrt (-7 :: Float) shouldn't be 0.0 as per IEEE 754
11:06:38 <triptec> I'm coming from ruby and node, used rails, sinatra, express.js, I'm looking to implement a small rest api using postgres. This will be my first thing in haskell, I would like to avoid a bloated framework if there are any. Suggestions?
11:07:02 <joelteon> you could just use the HTTP library
11:07:06 <bennofs1> SrPx: can you try it with explicit type signatures? (iirc ghci has different defaulting)
11:07:25 <bennofs1> triptec: try scotty
11:07:30 <srhb> SrPx: I cannot reproduce that.
11:07:31 <bennofs1> @hackage scotty
11:07:31 <lambdabot> http://hackage.haskell.org/package/scotty
11:07:33 <glguy> SrPx: You've probably mixed something up. main = print (sqrt (-7))   this program prints NaN both in GHCi and when compiled with GHC
11:07:51 <SrPx> triptec: the first year of 24 days of hackage has some introduction to postgres... you might find his content pretty good to collect quick summaries of our tools https://ocharles.org.uk/blog/
11:07:53 <clrnd> triptec, https://github.com/begriffs/postgrest is nice, but you won't do any haskell
11:08:49 <triptec> thanks you!
11:09:01 <triptec> thank*
11:11:15 <SrPx> glguy: thank you, seems like -llvm was the one to blame
11:11:18 <athan> Is there a convenient name for a single-parameter polymorphic function with unified domain and codomain? Like `p :: a -> a`?
11:11:49 <mpickering> id ?
11:11:58 <glguy> SrPx: Compiling that same program with -fllvm also produces NaN for me
11:14:35 <SrPx> glguy: weird, that exact program with -llvm produces 0.0
11:15:35 <glguy> If I compile it with optimizations I get 0.0 now
11:25:20 <shapr> cabal + package = cabbage
11:26:29 <geekosaur> ...with occasional kimchi
11:27:51 <m-e-f> dcoutts / dcoutts_, are you about?
11:28:11 <dcoutts_> m-e-f: mm?
11:48:32 <Denommus> weird
11:48:38 <Denommus> haste-boot is hanged
11:49:25 <glguy> Yikes, better cut the rope
11:49:36 * hackagebot dag 0.0.2 - Basic type-safe directed acyclic graphs.  http://hackage.haskell.org/package/dag-0.0.2 (athanclark)
11:54:18 <ski> SrPx : i think it possibly will be confusing to use that `lift' <http://lpaste.net/118634>,<http://tunes.org/~nef/logs/haskell/15.01.17>, at least if you get type or ambiguity errors
11:58:36 <athan> If I have an existentially quantified data type, with a data constructor that encapsulates some parametric variables, how could I unify those variables "outside" - say an unwrapping function with an explicit type signature?
11:58:45 <athan> Would scopedtypevariables fit the bill?
12:00:09 <athan> right now, it's not :\ flattening (I think) is re-writing type variables: http://lpaste.net/118874
12:05:56 <m-e-f> athan, I think it should be able to infer what you're trying to express if you remove the second type sig
12:09:37 * hackagebot yi 0.11.2 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.11.2 (DmitryIvanov)
12:14:55 <athan> m-e-f: Hmm, alright I'll give it a go :) still feels uncomfortable though
12:15:33 <athan> hmm, no dice :\
12:15:48 <athan> the quantification is on a GADT, if that affects anything
12:24:58 <athan> m-e-f: http://stackoverflow.com/questions/28054481/type-level-unification-and-value-level-pattern-matching-with-encapsulated-types
12:26:50 <m-e-f> athan, hmm... Well, you might as well try ScopedTypeVariables, if you haven't already
12:27:23 <athan> :s
12:29:26 <m-e-f> That doesn't look like GADT syntax in your SO question there... Or am I confused?
12:40:02 <exio4> athan, I can't make sense out of that type, as in that example 'b', 'c', and 'd' could be of _any_ types, and the return type of unWrap would be, too?
12:40:34 <athan> exio4: That makes a lot of sense
12:40:48 <athan> that meaning what you think it does
12:40:52 <athan> :P
12:41:10 <athan> m-e-f: Ehh, same difference :P
12:41:32 <exio4> wouldn't something like "unWrap (WNil (Init 1 'a' 'b' 'c') :: Wrap Int) :: Init Int Int Int Int" typecheck?
12:41:35 <m-e-f> Ah, I see, WNil :: Init a b c d -> Wrap a
12:42:03 <athan> I wonder if I can put the reference of the types somewhere else haha
12:42:05 <athan> yep :_
12:42:08 <athan> :)*
12:42:38 <athan> exio4: For me it's not deducing `a1 ~ a2` ... :\
12:42:45 <m-e-f> In that case, yeah, you can't unwrap it like that
12:42:54 <athan> hmm
12:42:57 <athan> thanks guys
12:43:06 <athan> I might be able to make a first class reference, though
12:43:09 <athan> hrm
12:44:26 <exio4> unWrap . WNil would have a type like Init a b c d -> Init a e f g, which doesn't really make sense
12:44:56 <m-e-f> Consider, you could pass in WNil (Init () () () ()), then use unWrap in a context where the return type is restricted to Init Int Int Int Int
12:45:21 <exio4> the 'a' would catch the first element there
12:45:48 <m-e-f> A `WNil a` can have *any* type b, c and d
12:46:27 <m-e-f> exio4, oh yeah. Make that Init () Int Int Int.
12:49:38 * hackagebot mwc-random-monad 0.7.2.0 - Monadic interface for mwc-random  http://hackage.haskell.org/package/mwc-random-monad-0.7.2.0 (AlexeyKhudyakov)
12:54:38 <SrPx> is there any shortcut for (if a > b then GT else if a < b then LT else EQ)
12:54:59 <exio4> SrPx, compare?
12:55:00 <geekosaur> compare a b?
12:55:00 <m-e-f> :t compare
12:55:01 <lambdabot> Ord a => a -> a -> Ordering
12:55:07 <SrPx> ah okay ! thanks :)
13:32:32 <saml> [1,2..]  => [1,2,3, 2,3,4, 3,4,5, ..]  how ?
13:32:51 <saml> for each element in list, i want to map to three different versions
13:33:24 <saml> map (\x -> (f x, g x, h x))      but instead of tuple...
13:33:54 <Hijiri> > [1..] >>= \n -> [n..n+2]
13:33:56 <lambdabot>  [1,2,3,2,3,4,3,4,5,4,5,6,5,6,7,6,7,8,7,8,9,8,9,10,9,10,11,10,11,12,11,12,13,...
13:34:35 <saml> can i do without concat ?
13:34:36 <saml> only cons
13:35:38 <benzrf> saml: yes, just inline the conses that concat does
13:35:54 <benzrf> saml: but i think you'll have to do a manual fold
13:35:59 <Hijiri> > foldr (\x xs -> x : (x + 1) : (x + 2) : xs) [] [1..]
13:36:01 <lambdabot>  [1,2,3,2,3,4,3,4,5,4,5,6,5,6,7,6,7,8,7,8,9,8,9,10,9,10,11,10,11,12,11,12,13,...
13:36:05 <benzrf> saml: why are you avoiding concat
13:36:23 <saml> for fun
13:39:40 * hackagebot deepseq-magic 1.0.0.2 - Deep evaluation of data structures without NFData  http://hackage.haskell.org/package/deepseq-magic-1.0.0.2 (EdwardYang)
13:39:48 <SrPx> Is there any pretty/point free way to write (\ a b -> f (g a) (h b)) ?
13:41:00 <jophish> What do people generally use for command argument parsing?
13:41:23 <mmachenry> jophish: Optparse-applicative
13:42:35 <delrik> hi all, I’d like some feedback on this: http://lpaste.net/118876 also, are there any outlets where I can get feedback on haskell implementations?  Far and above just learning haskell, I’d like to learn to think like a haskeller.
13:42:55 <delrik> the above is a solution to Euler#8
13:43:49 <Welkin> delrik: read Richard Bird's sudoku solver implementation
13:44:42 <delrik> awesome!
13:44:43 <delrik> thansk
13:45:02 <kranius> @pl (\ a b -> f (g a) (h b))
13:45:02 <lambdabot> (. h) . f . g
13:45:40 <kranius> SrPx: ^
13:47:45 <SrPx> kranius: eh..
13:48:11 <S11001001> SrPx: curry (uncurry f . (g *** h))
13:48:12 <S11001001> :)
13:48:30 <SrPx> uhmmm
13:49:06 <SrPx> I guess I will just make a compose2 function :P
13:49:35 <SrPx> :t ***
13:49:36 <lambdabot> parse error on input ‘***’
13:49:41 <SrPx> :t (***)
13:49:42 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
13:52:22 <gcganley> Pamelloes: have you been working on the AA stuff?
13:54:28 <ocramz> > t = 2
13:54:29 <lambdabot>  <hint>:1:3: parse error on input ‘=’
13:54:48 <ocramz> > let t = 2
13:54:49 <lambdabot>  not an expression: ‘let t = 2’
13:54:52 <ocramz> :D
13:55:01 <ocramz> :k Monad
13:55:02 <lambdabot> (* -> *) -> Constraint
13:55:14 <J_Arcane> delrik: If it's helpful, here's how I did Euler 8: http://rextester.com/AVNGT9308
13:56:15 <J_Arcane> (actually ported from a Racket solution, technically)
13:57:24 <delrik> J_Arcane: I love it!
13:57:38 <delrik> thanks a ton, very clear and concise.
13:57:57 <amf> is there a way to have ghc include shared objects in the final binary? e.g. i want zookeepers libzk_mt.so statically linked when im building my app
13:58:02 <gcganley> :k Functor
13:58:03 <lambdabot> (* -> *) -> Constraint
13:58:15 <gcganley> since when has these things resulted in constraints...
13:58:31 <gcganley> I always thought Functor had kind (* -> *)
13:59:23 <S11001001> gcganley: ~ length has type [a]
14:00:04 <gcganley> S11001001: I have no clue what ~ is. if it 'implies'?
14:00:36 <S11001001> gcganley: a fair approximation in this case
14:00:41 <shachaf> gcganley: Functor doesn't have a kind in Haskell 2010.
14:01:03 <shachaf> gcganley: But "Functor f" is a Constraint, i.e. something that can be on the left side of =>
14:01:31 <glguy> gcganley: You're probably thinking of "things that are functors" having kind * -> *
14:02:47 <gcganley> glguy: yes thats where my misconception lies
14:03:16 <gcganley> shachaf: Interesting. does it have anything to do with 'ConstraintKinds'?
14:03:26 <gcganley> ive heard of it but ive never used it
14:03:27 <delrik> J_Arcane: your solution makes me feel like I was writing java =)
14:03:28 <shachaf> Yes.
14:03:35 <shachaf> Really, there's only one ConstraintKind.
14:03:41 <shachaf> It's called Constraint.
14:03:47 <gcganley> shachaf: oh ok.
14:04:41 * hackagebot deepseq-magic 1.0.0.3 - Deep evaluation of data structures without NFData  http://hackage.haskell.org/package/deepseq-magic-1.0.0.3 (EdwardYang)
14:04:42 <J_Arcane> delrik: Don't feel bad, it takes some practice to get used to the compositional/"wholemeal" style. I had some pretty good teachers (and started in Lisp in the first place).
14:05:30 <delrik> I’ve got not problem sucking as much as I do =), any books you can recommend? you mentioned teachers, so I assume you had reference material.
14:07:22 <jmct> any suggestions/anecdotes on libraries for parsing RSS feeds. There are quite a few on hackage
14:08:18 <pantsman_> Anecdote: one of them seemed to work fine for me. Caveat: I don't recall which one.
14:09:23 <jmct> pantsman_: haha! I'll consider what you say as an existence proof
14:09:58 <pantsman_> I *think* it was the feed package
14:10:10 <pantsman_> that looks like the one I'd have used, because the rss package appears to only support RSS 2.0
14:11:00 <pantsman_> oh, plus the rss package doesn't have a parser.
14:11:04 <delrik> good find for anyone who’s interested.
14:11:05 <delrik> http://stackoverflow.com/questions/6957270/what-is-wholemeal-in-functional-programming
14:11:05 <pantsman_> pretty sure I used feed.
14:11:47 <davean> jmct: Feed works ok, but is rather ugly.
14:11:56 <davean> jmct: It could use cleanup, but it does the job
14:12:42 <SrPx> Why you almost never find a generic version of a list function? Sometimes I feel like prelude really needs to be rewriten :(
14:12:46 <SrPx> :t catMaybes
14:12:47 <lambdabot> [Maybe a] -> [a]
14:13:03 <SrPx> @hoogle f (Maybe a) -> f a
14:13:05 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
14:13:06 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
14:13:06 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
14:13:14 <J_Arcane> delrik: I started out in Lisps, so I already had some amount of practice when I get started with other FP langs like Haskell.
14:13:30 <dfeuer> In the Haskell pqueue package, Data.PQueue.Prio.Min and Data.PQueue.Min make very different claims about amortized bounds for persistent use. I'm not, however, seeing anything in the code that would explain such a difference. Any guesses?
14:13:46 <sx> delrik: I wrote a few comments, which could improve your style and readability of your code. http://lpaste.net/118876
14:14:10 <delrik> J_Arcane: kk, thx anyways!
14:14:30 <delrik> sx: nice I’ll check it out, thanks for taking the time to do this!
14:14:40 <gcganley> :t map fromJust
14:14:41 <lambdabot> [Maybe b] -> [b]
14:14:50 <J_Arcane> How To Design Programs and The Little Schemer are particularly good books (though the former is a big commitment); for Haskell, Learn You a Haskell is a pretty gentle introduction, as is the old Spring '13 CIS194 material.
14:14:57 <gcganley> huh, so (map fromJust) = catMaybes?
14:15:03 <shachaf> gcganley: No.
14:15:03 <gcganley> :t catMaybes
14:15:04 <lambdabot> [Maybe a] -> [a]
14:15:07 <shachaf> Don't use fromJust. :-(
14:15:11 <sx> delrik: I just scratched the surface, and as always it's a bit of personal preference.
14:15:11 <J_Arcane> (save that the latter's exercises *really* expect CS background)
14:15:36 <gcganley> shachaf: whats wrong with fromJust, I've never used it before
14:15:44 <josephle> > fromJust Nothing
14:15:44 <gcganley> i just used pattern matching
14:15:45 <lambdabot>  *Exception: Maybe.fromJust: Nothing
14:15:54 <simon> gcganley, it's a partial function. partial functions are bad.
14:15:56 <gcganley> josephle: PARTIAL FUNCTIONS EWWW
14:16:11 <gcganley> I see now
14:16:22 <simon> gcganley, fromJust is as bad as any function you define but forget to make certain pattern matching cases for, resulting in occasional crashes.
14:16:28 <gcganley> is all caps frowned upon in this channel?
14:16:39 <simon> gcganley, it depends on the purpose. are you really angry?
14:16:42 <benzrf> @unmtl StateT s [] a
14:16:42 <lambdabot> s -> [] (a, s)
14:16:51 <josephle> it should be fine to emphasize your disgust at partial functions
14:16:52 <benzrf> hmm
14:16:55 <gcganley> simon: no not really
14:17:06 <delrik> J_Arcane: not a problem, I’m reading SICP right now, so I’ll tackle your set right after!
14:17:08 <simon> gcganley, sorry, I did not notice that you'd already used all-caps. :)
14:17:32 <gcganley> benzrf: what the hell... @unmtl is a thing?
14:17:58 <benzrf> gcganley: it's not very good
14:18:01 <J_Arcane> delrik: If you can get through SICP, you probably don't need How To Design Programs unless you want to get into learning their design recipe (which is admittedly a helpful one, and one that helped make Haskell easier to pick up in some respects)
14:18:04 <benzrf> gcganley: it isnt recursive
14:18:10 <benzrf> gcganley: it doesnt do real parsing
14:19:06 <gcganley> benzrf: what does it do then
14:19:18 <J_Arcane> This guide has a pretty opinionated but not necessarily wrong overview of Haskell materials: http://bitemyapp.com/posts/2014-12-31-functional-education.html
14:20:05 <gcganley> J_Arcane: he doesnt pull any punchs with his opinions
14:20:20 <J_Arcane> No he does not.
14:21:15 <jmct> davean: Thanks! I'll look into that one
14:21:17 <delrik> sx: I’m a little confused on `gets`
14:21:29 <J_Arcane> CIS194's lectures *are* good; I think I'll probably go back to them. I'm reading through Bartosz Milewski's "Basics of Haskell", and it's a bit too slow going for me, but might be good for someone utterly bewildered by FP.
14:21:30 <delrik> mentioned on lines 16, and 29
14:21:41 <benzrf> gcganley: very little
14:21:46 <gcganley> J_Arcane: i disagree with his opinion of lyah. I found it very helpful but his complaints are understandable
14:21:48 <benzrf> gcganley: it unfolds the top level transformer
14:22:05 <benzrf> gcganley: nobody said it's unhelpful or confusing
14:22:09 <benzrf> gcganley: it's just *not good enough*
14:22:22 <benzrf> gcganley: it helps in some ways but not others
14:22:28 <gcganley> benzrf: what would you envision the perfect @unmtl would do (keep in mind ive never used monad transformers
14:22:29 <gcganley> )
14:22:46 <J_Arcane> gcganley: Yeah, I mostly liked LYAH at first; it drags in the middle though. I never finished it because I got burnt out on the chapters which are basically just walk throughs of the standard libs.
14:22:55 <benzrf> gcganley: parse the type /properly/ and recursively unfold any newtypes or aliases that transformers defines
14:23:27 <gcganley> J_Arcane: Oh i stopped reading it half way through and went and read other things. I dont really stick to things that well.
14:23:35 <sx> delrik: Oh, I made a mistake, it has to be ((> 12) . length), it is called operator section (> x) == \y -> y > x, and (x >) == \y -> x > y.
14:23:39 <J_Arcane> gcganley: I have the same problem. :/
14:23:54 <osa1> so let's say I have a `IO HugeData` and I'm evaluating it to WHNF. (so no NFData involved) this may actually fully evaluate my data structure, right?
14:23:57 <gcganley> J_Arcane: AHDH ftw. I've worked on 5 different languages in the last 4 years
14:24:11 <shachaf> Note that ((> 12) . length) does pointless extra work if your list is longer than 12 elements.
14:24:18 <delrik> sx: cool, I’m familiar with op sections =) really nify stuff!
14:24:22 <shachaf> length isn't that great for linked lists.
14:24:30 <J_Arcane> This has been my undoing thus far with doing anything productive with Haskell, because certain aspects of more advanced material are kinda required to get anything done with it.
14:25:00 <sx> delrik: Writing a function in backticks makes it an infix operator. Was that it?
14:26:29 <delrik> sx:         (\x -> x `elem` zeroThruNine ) gets (`elem` zeroThruNine)
14:26:30 <delrik> I was wondering what the ‘gets’ here was
14:26:49 <sx> delrik: That was my personal code transformation. :P
14:26:50 <delrik> but it looks like you were looking for a “gets” => “begets"
14:26:52 <delrik> lol!
14:27:00 <kadoban> osa1: As far as I understand, no. There is no WhatEver data structure yet to evaluate when all that you have is an IO WhatEver
14:29:43 * hackagebot validation 0.4.3 - A data-type like Either but with an accumulating Applicative  http://hackage.haskell.org/package/validation-0.4.3 (TonyMorris)
14:30:03 <osa1> kadoban: no but I'm evaluating it in IO and using seq. so my code is like `ret <- generateHugeData; ret `seq` ...
14:30:38 <osa1> my reasoning is this
14:30:47 <osa1> let's say I'm doing an IO action to generate every single bit of HugeData
14:30:56 <delrik> J_Arcane: you have a maths backgroudn?
14:31:10 <osa1> now I evaluated this generator in IO and passed this to function that doesn't do IO, and I used seq.
14:31:21 <osa1> now all IO action has to be done before passing this data structure
14:31:23 <J_Arcane> delrik: Nope. I got as far as trig proofs in college and stopped.
14:31:27 <osa1> which means completely evaluating the data
14:32:46 <delrik> J_Arcane: ahh, interesting.  I’ve always assumed proficiency in FP comes with a proficiency in Maths, this is obviosly not the case with most other langs, but I was always under the impression this was the case in FP.
14:32:55 <osa1> otherwise it would be like using unsafeInterleaveIO
14:32:59 <kadoban> osa1: Then you don't have an IO HugeData, you have a HugeData. So I guess you're asking if WHNF can sometimes mean it's fully evaluated?
14:33:09 <osa1> kadoban: yep
14:33:14 <delrik> since so many of the concepts are derived from math concepts. =\
14:33:39 <J_Arcane> delrik: It helps in Haskell's case, in a sense, because it's closer to the maths as it were, and because a lot of Haskellers seem to have math backgrounds and like to write docs that assume you do too. But it's not really required.
14:33:48 <dfeuer> carter, any guess about the pqueue thing?
14:33:54 <osa1> kadoban: the point is that how you generate the data matters for this. e.g. if it would be a pure data structure with no IO involved while generating, that WHNF doesn't mean fully evaluated
14:33:59 <carter> dfeuer: what pqueue thing?
14:34:02 <delrik> J_Arcane: makes sense!
14:34:36 <J_Arcane> The Little Schemer is a great book on recursion and FP techniques, and literally doesn't require anything more than the ability to count (you even implement the basic arithmetic operators at one point!)
14:34:42 <dfeuer> carter, Data.PQueue.Min and Data.PQueue.Prio.Min make very different claims about amortized efficiency in persistent use.
14:34:43 * hackagebot http-streams 0.7.2.5 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.7.2.5 (AndrewCowie)
14:34:53 <dfeuer> But I don't see a difference in the code that would explain that.
14:34:55 <kadoban> osa1: I don't think I have a good enough understanding to answer your question. I'm sure someone else does.
14:35:17 <carter> dfeuer: are they using the same code or not?
14:35:53 <dfeuer> carter, not the same, but very similar. And the strictness annotations and unpacking look to be the same too.
14:36:05 <Denommus> is shade any good?
14:36:08 <carter> dfeuer: still at work, so cant help
14:36:13 <dfeuer> OK.
14:36:56 <delrik> J_Arcane: Yep, I added that to my list.  I’ve also seen “The Reasoned Schemer” , any thoughts on that?
14:37:41 <shachaf> The Reasoned Schemer is about logic programming à la Prolog (or LogicT for Haskell).
14:37:59 <mmachenry> The Reasoned Schemer is awesome.
14:38:10 <J_Arcane> I haven't got to TRS.
14:39:04 <delrik> nice!
14:39:55 <mmachenry> To anyone who likes the Reasoned Schemer, Matthias Felleisen (author on all the other books in that series accept that one) wrote a paper on transliteration of Prolog to Scheme.
14:39:56 <mmachenry> ftp://ftp.extreme.indiana.edu/pub/techreports/TR182.pdf
14:40:47 <J_Arcane> Mr. Felleisen is a very smart bloke. :D
14:40:53 <shapr> true that
14:42:18 <mmachenry> I owe most of my involvement in the PL community to him. I went to undergrad at NU where he is.
14:43:52 <Lokathor> cabal 1.20 can't build on my raspberri pi for some reason
14:43:56 <Lokathor> guess 1.18 will get a try
14:44:43 * hackagebot ip6addr 0.4.0.0 - commandline tool to generate IPv6 address text representations  http://hackage.haskell.org/package/ip6addr-0.4.0.0 (MichelBoucey)
14:44:50 <J_Arcane> I actually had a brief email exchange with him about BASIC and LOGO as learning languages on the list when I first tentatively announced Heresy. :)
14:46:38 <Lokathor> is "the maths" (with 'math' plural) a UK thing?
14:47:08 <J_Arcane> Lokathor: "maths" is correct in British English, yes.
14:52:30 <SrPx> Is there any initiative on rewriting the prelude?
14:52:41 <SrPx> More generically and integrated, that is...
14:53:00 <geekosaur> about a dozen of them on hackage, I think
14:53:03 <hpc> if it happens, it will be in the next standard
14:53:06 <mmachenry> SrPx: Kind of. There are proposals out for lots of different things that would chance it.
14:53:23 <SrPx> mmachenry: interesting. I don't mean something official, though. Is there a list?
14:53:25 <mmachenry> The Applicative/Monad one is the biggest. Traversable/Foldable is also big.
14:53:32 <mmachenry> SrPx: One sec
14:54:02 <mmachenry> https://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
14:54:58 <mmachenry> https://ghc.haskell.org/trac/ghc/ticket/9586
14:55:40 <mmachenry> Those are the two biggest to my knowledge. Iterative, slow improvement is the norm. It's always changing but not much.
14:55:55 <mmachenry> There is no initiative to just rewrite the whole thing.
14:55:59 <ahammel> @undo get attrs ix = do     a <- attrs     i <- ix     getAttrs' a i
14:55:59 <lambdabot> <unknown>.hs: 1: 14:Parse error: =
14:56:28 <ahammel> @undo get attrs ix = do { a <- attrs; i <- ix; getAttrs' a i }
14:56:28 <lambdabot> get attrs ix = attrs >>= \ a -> ix >>= \ i -> getAttrs' a i;
14:56:35 <SrPx> I don't mean that, though... I really mean rewriting it from the scratch so, for example, we don't have a ton of not generic list functions
14:56:43 * HeladoDeBrownie imagines a haskell analog of c++ to c, what would it be called? succ haskell?
14:56:44 <SrPx> ie, fmap vs map, things like that
14:57:56 <mmachenry> I doubt a from scratch rewrite would ever happen.
14:58:03 <SrPx> why
14:58:19 <HeladoDeBrownie> i was being facetious :P haskell does change quite a bit already
14:58:28 <mmachenry> It would disrupt development being done in Haskell too much.
14:59:02 <Chathurga> Idris's Prelude is nice
14:59:04 <mmachenry> If someone rewrote all the prelude so that, for example map was gone, I might chose never to upgrade my work's servers to the next version of Haskell.
14:59:20 <mmachenry> And then eventually have a really out-dated version.
14:59:22 <Lokathor> HeladoDeBrownie: "Haskell" would evolve into "mapHask"
14:59:32 <HeladoDeBrownie> Lokathor, i don't get it
14:59:41 <sebastianrkg> hey guys, is there a way to use HXT on file data that has already been loaded into a ByteString?
14:59:48 <sebastianrkg> Or basically to use it without being the IO Monad?
14:59:55 <Lokathor> you don't incriment in haskell much, but you map over stuff instead
15:00:57 <mmachenry> SrPx: It's worth pointing out that map was, even on the day it was created, eclipsed by fmap. It was added just simply to make transition from other FP languages that have map on lists easy.
15:02:12 <SrPx> mmachenry: a new prelude could just be a different import though
15:03:02 <Lokathor> well map is just a specific kind of fmap, right?
15:03:06 <johnw> nowadays it is
15:03:14 <Lokathor> did it used to not be?
15:03:25 <johnw> map used to be fmap
15:03:28 <mmachenry> Yeah it could be, sure. But you'd need a way to not import prelude. I think that exists, right? How can I hide the prelude and import other stuff?
15:03:42 <erikd> map is an insufficiently general version of fmap :)
15:03:45 <SrPx> mmachenry: yea there is a lang prag for that
15:03:49 <kranius> {-# LANGUAGE NoImplicitPrelude #-}
15:03:51 <HeladoDeBrownie> mmachenry, {-# LANGUAGE NoImplicitPrelude #-}
15:03:59 <mmachenry> Ah, so there you go.
15:04:18 <SrPx> I wonder what haskell does without prelude though, considering even things like "+" come from prelude
15:04:19 <johnw> give me {-# LANGUAGE DisregardPedagogicalConcerns #-}
15:04:38 <HeladoDeBrownie> SrPx, you can define your own (+), or selectively import things from Prelude even
15:04:44 * hackagebot record 0.1.2 - First class records implemented with quasi-quotation  http://hackage.haskell.org/package/record-0.1.2 (NikitaVolkov)
15:04:58 <SrPx> but is it even able to do anything without importing anything from prelude? I mean, even print...
15:05:17 <Lokathor> i thought prelude didn't define anything original, it only re-exported key definitions that are all elsewhere as well
15:05:29 <HeladoDeBrownie> there are precious few things in Prelude you can't define on your own
15:05:37 <HeladoDeBrownie> also that
15:05:50 <kranius> you can always import qualified
15:06:10 <saml> f :: Int -> Maybe Int,  g :: Int -> Maybe Int,  l :: [Int].    filter isJust $ foldr (\x acc -> f x :: g x :: acc)  l
15:06:14 <saml> is there a better way to do this?
15:06:30 <saml> in the end, i want [Int],  not [Maybe Int]
15:06:51 <n4x> saml: do you want something like catMaybes?
15:06:54 <n4x> @type catMaybes
15:06:55 <lambdabot> [Maybe a] -> [a]
15:07:10 <HeladoDeBrownie> @src catMaybes
15:07:10 <lambdabot> catMaybes ls = [x | Just x <- ls]
15:07:23 <mankyKitty> you want mapMaybe
15:07:28 <saml> yah.. so right now, i'm doing [Int] ==> [Maybe Int] ==> catMaybes
15:07:29 <mankyKitty> @type mapMaybe
15:07:30 <lambdabot> (a -> Maybe b) -> [a] -> [b]
15:07:44 <saml> ideally,  i don't want to collect all [Maybe Int]
15:07:55 <HeladoDeBrownie> mankyKitty got it
15:07:56 <saml> just directly go from [Int]  to [Int] in one iteration
15:08:04 <mankyKitty> saml: use mapMaybe :)
15:08:40 <saml> @src mapMaybe
15:08:40 <lambdabot> Source not found. Maybe you made a typo?
15:08:48 <mankyKitty> @type mapMaybe
15:08:48 <HeladoDeBrownie> although mapMaybe could easily be implemented in terms of catMaybes
15:08:49 <lambdabot> (a -> Maybe b) -> [a] -> [b]
15:09:11 <mankyKitty> it's not a complex function, but always nice when you don't have to write it yourself :P
15:09:44 * hackagebot utc 0.1.0.0 - A pragmatic time and date library.  http://hackage.haskell.org/package/utc-0.1.0.0 (LarsPetersen)
15:10:22 <HeladoDeBrownie> right, i just mean it might do the same thing under the surface as you might have done with catMaybes, so there aren't necessarily fewer "steps"
15:10:29 <Lokathor> i always trust the library code over my own code
15:10:58 <saml> not sure how to apply mapMaybe  to   foldr (\x acc -> f x : g x : acc) l
15:11:21 <saml>  foldr (\x acc -> f x : g x : acc)  [] l
15:11:32 <HeladoDeBrownie> oh, actually this seems like not a use case for mapMaybe
15:11:44 <n4x> it'd be a concatMapMaybe
15:12:04 <Lokathor> does concatMapMaybe intersperse the results like that?
15:12:21 <n4x> does it even exist? :P
15:12:25 <HeladoDeBrownie> i don't think it does
15:12:54 <HeladoDeBrownie> saml, in that case go with catMaybes, unless you feel like writing a concatMapMaybe
15:13:11 <HeladoDeBrownie> though if you were only going to use it once, there's not much point in defining it
15:13:15 <Lokathor> is there perhaps a "tupleFlatten" func that turns [(a,a)] into [a] ?
15:13:32 <HeladoDeBrownie> Lokathor, not per se
15:13:55 <saml> actually i can determine if i want  (f x : g x : acc)   or (f x : acc)   or  (g x : acc)  during application start up
15:14:30 <saml> if configuration has values for f, and g, i can  do  (f x : g x: acc)   .  and f, g  returns a, not Maybe a
15:14:31 <HeladoDeBrownie> @hoogle [(a, a)] -> [a]
15:14:34 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
15:14:34 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
15:14:34 <lambdabot> Prelude snd :: (a, b) -> b
15:14:44 * hackagebot hsqml 0.3.3.0 - Haskell binding for Qt Quick  http://hackage.haskell.org/package/hsqml-0.3.3.0 (RobinKay)
15:14:45 <HeladoDeBrownie> yeah, didn't think so
15:14:46 * hackagebot hsqml-demo-samples 0.3.3.0 - HsQML sample programs  http://hackage.haskell.org/package/hsqml-demo-samples-0.3.3.0 (RobinKay)
15:14:49 <saml> if configuration has values for f only, i just need to do  (f x: acc)
15:14:52 <n4x> @type concatMap (\(a,b) -> [a,b])
15:14:53 <lambdabot> [(b, b)] -> [b]
15:15:03 <n4x> something like this would do the trick Lokathor, I think
15:15:54 <Darwin226> Hey guys. What's wrong here? http://lpaste.net/118881
15:16:02 <Lokathor> yeah if you mix that with two mapMaybe... no i don't think you can get away from having to manually do this list walk
15:16:03 <Darwin226> on the 'get :: Get u' line
15:16:26 <Darwin226> the compiler seems to interpret that as 'Get any' instead of 'Get u' as the 'u' specified in the signature
15:16:28 <HeladoDeBrownie> Darwin226, hard to say without more context. did you get an error message?
15:16:40 <HeladoDeBrownie> Darwin226, ah, yes, type variables don't scope like that by default
15:16:48 <HeladoDeBrownie> ScopedTypeVariables may help
15:16:49 <Darwin226> HeladoDeBrownie: I did ScopedTypeVariables
15:16:55 <Darwin226> HeladoDeBrownie: No change
15:17:39 <Axman6> it would help if you pasted the error message
15:17:50 <HeladoDeBrownie> Darwin226, did you write an explicit forall for the variables you wanted in scope there?
15:18:07 <Darwin226> HeladoDeBrownie: Oh, right! I didn't. Hold on
15:18:58 <Darwin226> HeladoDeBrownie: That did it! Thanks! It would be great if there was some error telling me that I probably want to do something other than what I'm doing
15:19:30 <HeladoDeBrownie> often it does, but i guess not for this specific case
15:20:58 <Darwin226> HeladoDeBrownie: Yeah, that's why this felt weird. I was sure the problem was something else since I would think that if reusing a typevariable didn't sound a warning,it must do what I think it does
15:24:45 * hackagebot clanki 1.2.1 - Command-line spaced-repetition software  http://hackage.haskell.org/package/clanki-1.2.1 (marcusbuffett)
15:34:45 * hackagebot language-lua 0.6.0 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.6.0 (OmerAgacan)
15:39:45 * hackagebot filemanip 0.3.6.3 - Expressive file and directory manipulation for Haskell.  http://hackage.haskell.org/package/filemanip-0.3.6.3 (BryanOSullivan)
15:52:21 <SrPx> is there any example of something typeclasses can do, that function polymorphism can't? (that is, defining 2 functions with the same name for different types)
15:53:17 <bitemyapp> SrPx: typeclasses can be implemented in terms of polymorphic records of functions
15:53:19 <Axman6> type classes let you restrict the types which a function can be run on; that's probably a better way to look at type classes, rather than defining functions with the same name that work on fdifferent types
15:53:24 <bitemyapp> SrPx: typeclasses are a convenience
15:53:45 <bitemyapp> Monad m => m a -> m b        ~        Monad m -> m a -> m b
15:53:52 <SrPx> ah I see, is there any reason not to have polymorphic functions?
15:53:58 <bitemyapp> you're "demanding" an instance, typeclasses spare you argument passing.
15:54:04 <n4x> you mean ad-hoc polymorphism?
15:54:04 <bitemyapp> SrPx: do you have a canonical instance in mind?
15:54:09 <bitemyapp> If so, typeclasses are more appropriate.
15:54:14 <SrPx> n4x: that should be it
15:54:20 <bitemyapp> usually it's best to just use typeclasses.
15:54:34 <bitemyapp> record-of-functions is more of an advanced tactic and newtypes subsume many use-cases for them.
15:55:03 <Axman6> bitemyapp: occasionally the class record does actually get passed around (I've seen it cause annoying space leaks in some code at a previous job)
15:55:05 <SrPx> bitemyapp: nah I don't mean a record-of-functions, I mean just defining a function for more than one type. `add :: Int → Int → Int`, `add :: Float → Float → Float`, etc
15:55:17 <bitemyapp> SrPx: you've probably misunderstood what I said.
15:55:22 <bitemyapp> SrPx: re-read it and you'll know what I mean.
15:55:25 <SrPx> maybe... hmm
15:57:19 <bitemyapp> Axman6: RoF - it's existential for the contents of the structure right?
15:57:38 <Axman6> RoF?
15:57:47 <Axman6> and, I don't understand the question
15:57:55 <bitemyapp> n/m, doesn't matter.
15:57:58 <bitemyapp> it was about SrPx's question.
15:58:02 <bitemyapp> RoF - Record of Functions
15:58:03 <Axman6> h'ok
15:58:16 <Axman6> right
15:58:17 <bitemyapp> ie, "what if I implemented Monad has a record that takes a type argument"
15:58:25 <bitemyapp> the "a" in "m a" is existential right?
15:58:37 * SrPx is still trying to understand what you said
15:58:42 <bitemyapp> data Monad m = Monad { join :: forall a . m (m a) -> m a }
15:58:55 <bitemyapp> as opposed to a typeclass.
15:59:02 <bitemyapp> Then you have Monad [], Monad Maybe, etc.
15:59:20 <SrPx> I think I didn't misunderstand you ... it seems like you are comparing two styles, 1. declaring a typeclass, 2. manually passing a record of functions... I'm talking about something else, I guess...
15:59:32 <SrPx> sorry if I'm missing it
15:59:34 <bitemyapp> SrPx: what does "function polymorphism" mean?
15:59:46 * hackagebot permutation 0.5.0.5 - A library for permutations and combinations.  http://hackage.haskell.org/package/permutation-0.5.0.5 (spacekitteh)
15:59:50 <bitemyapp> SrPx: I am showing you the only equivalent alternative to typeclasses unless you mean something really off the wall.
15:59:50 <shachaf> "forall" doesn't mean "existential". When will this misconception stop happening?
15:59:59 <shachaf> forall is exactly dual to existentials
16:00:07 <bitemyapp> shachaf: okay, "more polymorphic" ?
16:00:18 <bitemyapp> it's a type variable being introduced ex nihilo
16:00:49 <bitemyapp> I actually know how universal and existential quantification relate, but I don't have a good word for what *that* is.
16:01:33 <bitemyapp> Axman6: do you have a better word for it?
16:01:45 <Axman6> I do not, this isn't really my area
16:01:56 <SrPx> bitemyapp: "add :: Int → Int → Int; add = ...; add :: Float → Float → Float; add = ...; main = add (1 :: Int) (2 :: Int)" - the compiler picks "add :: Int → Int → Int" based on the type. I guess it is the absolute same thing as typeclasses, though, just without "instance" / "class" declarations. I see. Nevermind then.
16:02:12 <bitemyapp> SrPx: so you made something up that doesn't exist.
16:02:20 <bitemyapp> SrPx: this would explain our communication barrier ;P
16:02:34 <SrPx> I didn't know it didn't exist, my bad. I thought it was common in C++
16:02:39 <bitemyapp> SrPx: np
16:03:04 <SrPx> maybe my memory is failing me though, many years without using it
16:03:05 <bitemyapp> SrPx: if the compiler is picking implementation based on type and assuming a unique implementation for every (Class, Type) pairing, then it's probably just typeclasses.
16:03:23 <bitemyapp> SrPx: what I was showing you with record-of-functions is a little more general, but more tedious and not always appropriate.
16:03:44 <bitemyapp> SrPx: also the compiler can take advantage of optimizations with the former that I don't think are currently possible with the latter.
16:03:44 <glguy> C++'s function overloading where the same function is defined multiple times with different argument types is different than type  classes
16:03:48 <Axman6> SrPx: type classes give the advantage that anywhere where you use add (or (+)), you a) get documentation in the types of what things it will operate on and b) allow you to write generic functions which others can extend later be making new instances. I feel getting the same benefit with your approach is more ad hoc and somewhat of a hack (which is annoyingly common in other languages)
16:04:04 <SrPx> glguy: ah that's the name ...
16:05:03 <SrPx> Axman6: I don't see how? That's exactly what they do in C++. Say, when you implement a Vector3 class, you can overload the global "+" operator to work with it, without needing to implement the rest of the "Num" typeclass
16:07:18 <Axman6> SrPx: but it's not really visible in the types is it? I can't look at something which happens to use operator+ and know that it will work on my own types if I implement operator+
16:08:27 <Welkin> SrPx: https://www.haskell.org/haskellwiki/Polymorphism
16:08:36 <Welkin> parametric vs ad-hoc polymorphism
16:11:01 <SrPx> Axman6: not sure if I understand you - you are saying that typeclasses allow for you to see this: "add :: (Num a) => a → a → a; add a b = a + b" and say: "this will work on my own types if I implement a "Num" typeclass for them.
16:11:19 <SrPx> Axman6: whereas function overloading don't allow you to make the same observation. Am I correct?
16:11:24 <SrPx> doesn't
16:11:28 <SrPx> dunno
16:11:29 <Axman6> right
16:11:41 <SrPx> Interesting, thanks!
16:12:06 <SrPx> also, "
16:13:55 <Axman6> as, afaik, you can use both to implement pretty much the same things, but one gives you free documentation.
16:14:47 * hackagebot hsdev 0.1.3.3 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  http://hackage.haskell.org/package/hsdev-0.1.3.3 (AlexandrRuchkin)
16:15:17 <shachaf> Documentation for free!
16:15:37 <n4x> theorems for free, documentation for free, apparently haskellers love free things
16:15:52 <shachaf> comonads for cofree
16:19:47 * hackagebot mtlparse 0.1.4.0 - parse library using mtl package  http://hackage.haskell.org/package/mtlparse-0.1.4.0 (YoshikuniJujo)
16:20:31 <_um> Can anyone recommend a straightforward, reliable way of dealing with https requests? I've tried a couple approaches so far, and each time I've become enmired.
16:20:50 <Axman6> what are you trying to do?
16:21:13 <_um> The only things I've been able to get to work in a straightforward way is using the Network.Curl library.
16:21:39 <_um> Axman6: A couple things, but first off interface with WordsApi
16:21:39 <Axman6> had a look at wreq? it's got a nice lens based interface*
16:21:51 <Axman6> *you may not find lenses nice and they may be confusing
16:21:58 <Axman6> it;s got good docs though
16:22:03 <_um> I was just trying wreq!
16:22:25 <_um> Lenses (or at least the superficial bit they explain in the (excellent) wreq tutorial) seem very intuitive to me.
16:22:33 <_um> But wreq isn't letting me do https!
16:22:40 <viosdlv> hey how can I configure xmonad for fullscreen games with dual monitors?
16:22:58 <viosdlv> when i start a game it starts on one monitor (the wrong one) and turns the other one off
16:23:00 <_um> I posted a question on SO, and someone suggested it might be related to a known issue with wreq and certain windows based servers.
16:23:08 <Axman6> #xmonad is probably a better place to ask viosdlv
16:23:15 <viosdlv> oh ok
16:23:28 <_um> (Here's the SO question: http://stackoverflow.com/questions/28029422/what-is-the-general-recipe-for-making-https-requests-with-the-wreq-library)
16:24:33 <_um> I should clarify: I can't do https to WordsApi. I don't know if it's user error or the aforementioned issue.
16:25:30 <_um> I was hoping that the relatively common task of getting data via https would have a relatively standard, "just works" Haskell solution.
16:26:07 <Axman6> not that I'm aware of, but it's also not something I've needed to do
16:26:21 <_um> Axman6: That's the most common reply I've received so far.
16:26:54 <Axman6> sorry =)
16:27:19 <_um> In that I case, I wonder if I would be better off Hacking together solutions using Network.Curl or just doing all that stuff via Python or another boring, "pragmatic" language.
16:27:28 <_um> No worries. Thanks for the help Axman6!
16:27:32 <Axman6> is there any way to set the TLS version in the API? seems using TLS1.1 works. not ideal but it;s something
16:27:36 <_um> Wreq is definitely the most user friendly lib I've seen so far.
16:28:05 <_um> Axman6: That's helpful knowledge. I'll see if I can put it to use.
16:28:32 <_um> ("user friendly" meaning easy for me to understand :)
16:30:05 <Axman6> _um: the ticket linked to in the reply to your SO question has lots of good info on what's going wrong
16:32:26 <benmachine> _um: so, I don't remember the last time I tried to do https in Haskell, but if I was starting now, I think I'd start here http://hackage.haskell.org/package/http-client-streams
16:32:49 <_um> benmachine: I'll take a look. Thanks!
16:33:20 <_um> Does this response indicate that most people who use Haskell just don't work in areas where https is needed? Or do they rather tend to use other languages for that side of things?
16:33:45 <benmachine> _um: well, the stuff I'm currently working on isn't Haskell at all :P
16:34:00 <Axman6> "most" is probably not the best thing to take away from two people in a channel of 1000+ replying :P
16:35:45 <_um> Axman6: True!
16:36:23 <Axman6> the only HTTP stuff I'm doing at the moment is using NEtwork.{HTTP,Stream}
16:36:27 <Axman6> Network*
16:36:49 <hexagoxel> how do i nest lists in haddock?
16:37:29 <R0b0t1> _um: apparently, see: https://github.com/haskell/cabal/issues/936
16:38:02 <_um> Well, thanks for the tips Axman6 & benmachine.
16:38:52 <_um> Oh wow, R0b0t1. That's wowzy in deed. Only read the first post so far.
16:38:57 <_um> Thanks for the link.
16:48:29 <hexagoxel> nevermind, read user guide :D
16:52:04 <R0b0t1> _um: yeah idk
16:52:05 * R0b0t1 shrugs
16:52:13 <R0b0t1> gonna just create a separate vm for haskell stuff now
16:54:49 * hackagebot git-vogue 0.2.0.0 - A framework for pre-commit checks.  http://hackage.haskell.org/package/git-vogue-0.2.0.0 (ChristianMarie)
16:57:34 <athan> I found an instance where `f . g` ~/~ `\x -> f $ g $ x` in terms of type inference :]
16:57:48 <athan> for some reason, the latter infers, while the former doesn't
16:58:17 <Axman6> what are the types involved?
17:00:50 <phaazon> hey
17:00:58 <phaazon> how do you install the latest GHC version on Windows?
17:01:01 <phaazon> the moste simple way
17:01:11 <phaazon> along with cabal-install, of course
17:01:28 <Axman6> haskell platform?
17:01:33 <Axman6> @where platform
17:01:33 <lambdabot> http://hackage.haskell.org/platform/
17:01:38 <benmachine> athan: is one of them runST, because runST totally cheats
17:01:39 <glguy> athan: $ cheats, it's special cased into the type checker by name. Are you doing something with Rank2 types? ST?
17:01:53 <glguy> runST's legit, $'s hacked
17:01:54 <benmachine> oh, right, $ cheats
17:02:04 <benmachine> but $ cheats because of runST, originally
17:02:05 <benmachine> I think
17:02:07 <glguy> yeah
17:02:34 <Axman6> not being able to do runST $ do was such a pain
17:02:40 <athan> glguy, benmachine, Axman6: Close! Data.Proxy and demoting singletons!
17:02:43 <zugz> what's the Correct way to cause cabal to reject certain combinations of flags as unsatisfiable, and have it continue to search for a satisfiable combination? The only way I've found is to put in a dependency on a non-existent package, which is rather an ugly hack!
17:02:45 <phaazon> does it include profiling libraries for base?
17:02:50 <phaazon> well, GHC’s RTS, I mean
17:02:51 <athan> But, it works with an explicit signature
17:03:28 <Axman6> that doesn't really make sense, the RTS is kind of what does the profiling of haskell libraries which have been compiled to be profiled
17:03:41 <phaazon> Axman6, I had an issue with profiling
17:03:53 <Axman6> iirc the platform should come with profiling versions of everything, but I may be wrong
17:03:59 <phaazon> I couldn’t profile because a lib missing
17:04:03 <phaazon> libHSrts_debug_p
17:04:49 * hackagebot intricacy 0.3.8 - A game of competitive puzzle-design  http://hackage.haskell.org/package/intricacy-0.3.8 (mbays)
17:05:07 <_um> R0b0t1: Doesn't it seem like somewhat strange situation to arise in an essential tool of an ecosystem for a language that is often endorsed on the basis of the *safety* it provides?
17:05:17 <benzrf> > bool 1 2
17:05:18 <lambdabot>  <Bool -> Integer>
17:05:22 <benzrf> > bool 1 2 True
17:05:23 <lambdabot>  2
17:05:49 <benzrf> hm
17:07:59 <R0b0t1> _um: No. The case is such for a great many platforms. E.g. quite a few web frameworks (which often tout how safety-conscious they are) have install instuctions which are piping the output of a wget/curl command to sh and package repos which are not accessible with TLS and/or do not have any signing.
17:08:13 <R0b0t1> The major difference is in those cases, it's pretty obvious.
17:09:42 <phaazon> hm
17:09:43 <_um> R0b0t1: I see. that makes sense.
17:09:51 <phaazon> haskell platform is not shipped with the latest GHC
17:09:57 <phaazon> 7.8.3
17:10:03 <phaazon> while the latest is 7.8.4
17:10:05 <R0b0t1> security is often orthogonal to getting it working, so it's not like anyone is guilty of anything heinous
17:10:24 <_um> R0b0t1: Right. That's a good point.
17:14:38 <EvanR> ./join #clojure
17:19:49 * hackagebot zip-archive 0.2.3.6 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.2.3.6 (JohnMacFarlane)
17:40:05 <Pamelloes> Is "newtype Ident' = Ident' ()" considered good form, or should I just use "data Ident' = Ident'" instead?
17:40:32 <benzrf> :t mfail
17:40:33 <lambdabot>     Not in scope: ‘mfail’
17:40:33 <lambdabot>     Perhaps you meant ‘fail’ (imported from Control.Monad.Writer)
17:40:34 <EvanR> is this a type isomorphic to () ?
17:40:35 <benzrf> hm
17:40:45 <benzrf> what's monadplus's identity again
17:40:50 <benzrf> oh mzero
17:40:52 <EvanR> mzero?
17:41:12 <Pamelloes> EvanR: Basically
17:41:23 <EvanR> why not data Foo = Foo'
17:41:25 <EvanR> er no '
17:41:57 <EvanR> youll lose all the awesome instance that () has defined anyway
17:42:15 <shachaf> Pamelloes: If there's no reason to make it a newtype you might as well make it a data type of its own.
17:42:17 <Pamelloes> What instances does () have?
17:42:42 <hiptobecubic> > map id ()
17:42:43 <lambdabot>  Couldn't match expected type ‘[b]’ with actual type ‘()’
17:42:46 <hiptobecubic> > fmap id ()
17:42:47 <lambdabot>  Couldn't match expected type ‘f b’ with actual type ‘()’
17:42:54 <EvanR> not a functor wrong kind
17:42:57 <hiptobecubic> not many i guess
17:43:01 <hiptobecubic> EvanR, oh right..
17:43:22 <EvanR> > () <> ()
17:43:24 <lambdabot>  ()
17:43:45 <benzrf> :t msum
17:43:46 <lambdabot> MonadPlus m => [m a] -> m a
17:43:49 <benzrf> oh crud
17:43:52 <benzrf> :t mplus
17:43:52 <lambdabot> MonadPlus m => m a -> m a -> m a
17:43:55 <EvanR> > () + ()
17:43:57 <lambdabot>  No instance for (GHC.Num.Num ()) arising from a use of ‘GHC.Num.+’
17:44:11 <Pamelloes> I'm creating a type class that applies to a variety of types (including ()) but only in a specific context. I created a newtype definition for the other types so I was making a newtype for () for consistency's sake.
17:44:32 <shachaf> Consistency is a reasonable reason to use a newtype, sure.
17:45:03 <Pamelloes> mmm alright
17:50:03 <Welkin> :t ()
17:50:04 <lambdabot> ()
17:50:32 <Zemyla> How does MonadFix for lists work? I read the code, but it somehow produces a list from nothing?
17:51:26 <Pamelloes> Ia there a way to define a typeclass with the type parameter (Writer String a)?
17:57:24 <glguy> > let xs = mfix $ \x -> [1:x,2:x] in map (take 5) xs
17:57:25 <lambdabot>  [[1,1,1,1,1],[2,2,2,2,2]]
17:57:39 <glguy> Zemyla: It uses the list you produce. You have to be lazy enough to do that
17:58:35 <EvanR> the dragon thats eating its own tail
17:58:54 <glguy> > let xs = mfix $ \x -> [1,2] >>= \y -> [3:y:x,4:y:x] in map (take 5) xs
17:58:55 <lambdabot>  [[3,1,3,1,3],[4,1,4,1,4],[3,2,3,2,3],[4,2,4,2,4]]
18:07:13 <Pamelloes> Is there any standard type class along the lines of "class Convertable (a,b) where { convert :: a -> b }"?
18:07:47 <EvanR> http://hackage.haskell.org/package/convertible
18:08:38 <Pamelloes> Thanks :)
18:08:38 <EvanR> its a multiparameter type class
18:11:53 <Pamelloes> How do multi parameter type classes work? I always get scared that MyClass a b means a class with something like (Functor a => a b)
18:12:12 <shachaf> it doesn't hth
18:12:49 <benzrf> Pamelloes: they are just like normal ones except that instances provide 2 types
18:12:57 <benzrf> Pamelloes: here is an example:
18:13:25 <benzrf> @let class Truncate a b where truncate :: a -> b
18:13:26 <lambdabot>  Defined.
18:13:39 <benzrf> @let instance Truncate Float Int where truncate = floor
18:13:40 <lambdabot>  Defined.
18:13:56 <benzrf> > truncate 3.4
18:13:57 <lambdabot>  Ambiguous occurrence ‘truncate’
18:13:57 <lambdabot>  It could refer to either ‘L.truncate’, defined at L.hs:159:9
18:13:57 <lambdabot>                        or ‘GHC.Real.truncate’,
18:14:02 <benzrf> > L.truncate 3.4
18:14:03 <lambdabot>  Could not deduce (L.Truncate a0 b)
18:14:03 <lambdabot>    arising from the ambiguity check for ‘e_134’
18:14:03 <lambdabot>  from the context (L.Truncate a b, GHC.Real.Fractional a)
18:14:06 <benzrf> aw dang
18:14:15 <benzrf> Pamelloes: this is where fundeps come into play :p
18:14:33 <benzrf> > (L.truncate (3.4 :: Float)) :: Int
18:14:34 <lambdabot>  3
18:14:37 <benzrf> there we go
18:14:38 <kadoban> fundeps aren't as fun as they sound…
18:14:56 <benzrf> hue
18:15:03 <Pamelloes> Is it ever the case where a class of kind *->*->* has the second and third parameters associated e.g MyClass Functor Int?
18:15:31 <Gurkenglas> This library provides a Show instance for one of its exports, but I want to use a different one. Can I circumvent the given instance somehow?
18:15:35 <benzrf> Pamelloes: huh?
18:15:42 <kadoban> Pamelloes: I don't think that's correctly kinded
18:15:46 <benzrf> Pamelloes: im not sure what you're asking
18:15:53 <pavonia> Pamelloes: A functor has a different kind, namely * -> *
18:16:07 <Pamelloes> I think my understanding of types was screwed up by the Free monad.
18:16:21 <Pamelloes> :k Free
18:16:21 <bramgg> What's "<|>" called?
18:16:21 <lambdabot>     Not in scope: type constructor or class ‘Free’
18:16:22 <lambdabot>     Perhaps you meant ‘Tree’ (imported from Data.Tree)
18:16:38 <benzrf> Pamelloes: tsk
18:16:44 <Pamelloes> bramgg: bifurcated diamond? :P
18:17:00 <benzrf> i wouldnt learn about free monads just yet
18:17:12 <Welkin> bramgg: Alternative
18:17:18 <Welkin> :t (<|>)
18:17:19 <lambdabot> Alternative f => f a -> f a -> f a
18:17:40 <bramgg> Welkin: thanks, was working up the courage to ask Pamelloes if they were joking or not :p
18:18:43 <Pamelloes> Well, you could very well pronounce it as "bifurcated diamond" if that's what floats your boat. I always pronounced it as "or" with the understanding it was associated with alternatives.
18:18:54 <EvanR> Pamelloes: if something has kind * -> * -> *, then there is no third parameter
18:19:26 <Pamelloes> Yeah, I meant first and second. Anyways, what's the kind of the Free monad?
18:19:26 <EvanR> bramgg: dont try to pronounce the operators ;)
18:23:36 <Gurkenglas> When I do "newtype Mi = Maybe Int", I can't pattern match an Mi on whether it is Just i or Nothing?
18:24:25 <Welkin> "Mi" in that context is a Type
18:24:30 <Welkin> you cannot pattern match on a type
18:24:36 <EvanR> wurg, you used Maybe as a data constructor
18:24:42 <Welkin> you can pattern match on Data constructors
18:25:10 <EvanR> do newtype Mi = Mi (Maybe Int)
18:25:19 <Welkin> left of the "=" is a type
18:25:32 <Gurkenglas> But then I have to wrap/unwrap the Mi thing every time right?
18:25:35 <Welkin> the right-hand side of the "=" has the data constructors
18:25:42 <EvanR> yes
18:26:03 <Gurkenglas> Can I change the show a library uses without putting wrappers everywhere?
18:26:06 <EvanR> newtype Mi = Mi { getMi :: Maybe Int }
18:26:26 <Saizan> Gurkenglas: nope
18:26:40 <Gurkenglas> (I was hoping to just slap a different name on Complex Double and defining my own show for that so the outputs don't take a bazillion digits)
18:27:13 <EvanR> you can also use a different show function
18:27:18 <EvanR> just dont use the Show class
18:27:35 <Gurkenglas> But all the library functions I'm trying to call are using it
18:28:18 <EvanR> also theres "Show isn't for pretty printing"
18:28:31 <Gurkenglas> What's for pretty printing?
18:29:33 <EvanR> theres this formatting library
18:29:48 <Axman6> there are pretty printing libraries which are designed for human consumable output. Show is supposed to be the inverse of Read
18:29:49 <EvanR> havent tried it
18:30:27 <Gurkenglas> Hmm. No time, gotta hand this in in <6 hours and gotta get in sleep somewhere... I'll just turn it to strings, pass that as my show and use notepad++ to ctrl-h the surplus "" afterwards
18:30:52 <EvanR> no time, so just leave the 12 digits on
18:31:09 <Gurkenglas> But that's not pretty!
18:31:15 <EvanR> no time man!
18:32:18 <Welkin> oh dear, oh dear, you will be late!
18:32:45 * Welkin watches Gurkenglas scurry off in a hurry
18:33:01 <Welkin> he dropped these white gloves
18:33:46 <Axman6> Gurkenglas: writing a simple show function using printf would be pretty easy
18:34:09 <EvanR> the library cant be arsed to use a custom show function
18:34:47 <Gurkenglas> Axman6, yes, it was. The problem is getting all the other preexisting Show a => (...) - functions to accept the new show
18:35:11 <Gurkenglas> Cause you can't have duplicate instances etc.
18:36:13 <Axman6> right, which is why you'd need to use a newtype. this is pretty easy to do, you can use GeneralisedNewtypeDeriving to get things like Num Eq etc. for free, and then just manually write the Show instance
18:36:13 <joness> given a function with name mapEvery would you expect `mapEvery 2 (*10) [1..5]' to return [1,20,3,40,5] or [10,2,30,4,50]?
18:36:48 <Axman6> "yes"
18:36:49 <Gurkenglas> Axman6, yes, and then you have to put wrappers everywhere
18:37:14 <benzrf> joness: i wouldnt know
18:37:23 <benzrf> ooh i se
18:37:24 <benzrf> *ese
18:37:29 <benzrf> seee god dammit
18:37:37 <Axman6> using the deriving clauses means that for a lot of things you can treat your wrapped type as if it were the original type and get exactly the same functionality
18:37:38 <joness> yeah, starting from the 0th or Nth element
18:37:41 <benzrf> joness: this seems like something that would work best as a traversal
18:38:09 <Axman6> joness: probably the former
18:39:45 <Gurkenglas> Hm, actually I only need to wrap it when I'm about to print it, which is when all the data-accessing stuff that I would have to unwrap it for is already done. That could work.
18:39:54 <joness> benzrf I am just asking if the `mapEvery 2' should apply the function to 0th, 2nd, 4th.. elements, or 1st, 3rd, 5th..
18:40:48 <Welkin> joness: think about map
18:40:53 <Welkin> it would be mapEvery 1
18:40:57 <joness> yes
18:41:03 <Axman6> that doesn't help though...
18:41:07 <Welkin> mapEvery 2 is shifted to the right by one
18:41:26 <Welkin> so you skip the first one and apply to every second one
18:42:48 <Axman6> mapEvery 0 is an interesting case then
18:42:57 <Welkin> it doesn't map anything
18:43:03 <Welkin> it yields an empty list
18:43:08 <Welkin> at least that is how I see it
18:43:10 <joness> or id?
18:43:18 <Axman6> that seems like odd behaviour
18:43:22 <Welkin> oh
18:43:22 <Pamelloes> I would probably make mapEvery 0 a divide by 0 error.
18:43:23 <Welkin> yes, id
18:43:35 <Welkin> id makes more sense
18:44:04 <benzrf> joness: this would make a lot of sense as a traversal in lens
18:44:26 <benzrf> or rather, as a modification of a traversal
18:45:35 <Pamelloes> Welkin: mapEvery 0 = [] makes more sense then id.
18:46:29 <benzrf> Pamelloes: what?
18:46:36 <lornap> Could anyone point me to an example of using Free monad transformers?  I'm having trouble figuring out how to construct an interpreter for a stack of free monads.
18:46:56 <benzrf> lornap: do you get the point of Free?
18:46:57 <Welkin> Pamelloes: it could
18:47:05 <Welkin> it depends on how you approach map
18:47:18 <nshepperd> 'mapEvery 0 f = id' doesn't work, for f :: A -> B
18:47:39 <shachaf> nshepperd: mapEvery doesn't work f :: A -> B in general.
18:47:41 <lornap> benzrf: What do you mean the point of Free?  In my particular case, I'm using it to separate purity from IO.
18:47:44 <benzrf> i think it'd make more sense for mapEvery 0 f = map f
18:47:50 <benzrf> then 1 skips every oter
18:47:51 <benzrf> etc
18:47:52 <Pamelloes> benzrf: "mapEvery n L" is saying divide L into groups of n and then map the first/last element. If you divide L into groups of size 0, you wind up with an infinite set of infinite groups: []
18:47:54 <joness> yeah mapEvery needs a -> a
18:47:57 <shachaf> (But mapEvery 0 f shouldn't be id.)
18:48:08 <benzrf> Pamelloes: eh
18:48:18 <nshepperd> oh, right, you're including mapped and un-mapped entries
18:48:35 <danilo2_> Hello! :) I'm learning how GHC works and I started wit hthe examples provided here: https://www.haskell.org/haskellwiki/GHC/As_a_library . They work great, but does not present a very important step. The second example shows how can we run manually some of the compilation passes / functions (like: parseModule, typecheckModule, desugarModule, getNamesInScope, and getModuleGraph.) but does not mention how can I further compile the m
18:48:40 <danilo2_> Does anybody know how can I do it?
18:49:19 <joness> shachaf what should it be?
18:49:33 <nshepperd> error "divide by zero"
18:49:34 <shachaf> I don't know. An error?
18:49:45 <nshepperd> or some such
18:49:53 * hackagebot clanki 1.2.2 - Command-line spaced-repetition software  http://hackage.haskell.org/package/clanki-1.2.2 (marcusbuffett)
18:50:18 <shachaf> The obvious definition is that mapEvery n f xs means that every element with an index i such that i `mod` n == 0 is mapped over
18:50:56 <joness> yeah got it
18:51:31 <Denommus> what I want in GHCJS has a name :-D
18:51:38 <Denommus> it's reactive dom
18:52:11 <Denommus> to treat the dom as a reactive behavior, and not override the entirety of it, just update what has changed from one "step" to the other
18:52:50 <Pamelloes> Can I create a type synonym of a typeclass: type EqSynonym = Eq
18:52:52 <Denommus> Eliom has the feature, but the documentation is a bit outdated
18:53:14 <benzrf> what is eliom
18:53:21 <shachaf> Pamelloes: What happened when you tried?
18:53:24 <benzrf> Pamelloes: you can with the right extns
18:53:30 <Denommus> benzrf: an OCaml web framework
18:53:36 <benzrf> Denommus: ah
18:53:43 <Pamelloes> shachaf: "Illegal constraint synontm of kind Constraint"
18:54:07 <Denommus> I don't think a type synonym for a type class is much of a good idea
18:54:09 <shachaf> Pamelloes: So that sounds like a no. What was the next line of the error message?
18:54:25 <Pamelloes> shachaf: IT says I can use ConstraintKinds extn to permit this
18:54:43 <Pamelloes> But extensions are scary :(
18:54:53 * hackagebot readable 0.2.0.1 - Reading from Text and ByteString  http://hackage.haskell.org/package/readable-0.2.0.1 (DougBeardsley)
18:54:55 * hackagebot clanki 1.2.3 - Command-line spaced-repetition software  http://hackage.haskell.org/package/clanki-1.2.3 (marcusbuffett)
18:55:56 <EvanR> Pamelloes: activate all the extensions, itll be like jumping into the pool rather than slowly wading i
18:55:59 <EvanR> n
18:56:09 <Pamelloes> ...
18:56:33 <Pamelloes> That sounds like a sure way to drown whatever understanding of Haskell so far.
18:56:42 <Pamelloes> *of Haskell I do have so far
18:56:51 <MP2E> hah :p
18:57:23 <Welkin> Pamelloes: the only way I was able to stop being confused was by completing a medium-sized web application in yesod
18:57:38 <Welkin> it was very helpful to fix/reinforce my understanding
18:58:07 <Welkin> so, the best way to learn is to just do it
18:58:18 <Pamelloes> One day. Not just yet.
18:58:34 <Welkin> the best time is always now
18:58:48 <Welkin> tomorrow never comes because there is always a tomorrow
18:59:00 <EvanR> often the best time was earlier than now
18:59:42 <Pamelloes> touché
18:59:50 <Pamelloes> How do I activate an extension in ghci?
18:59:56 <_1_Euzel> hey
19:00:01 <_1_Euzel> Idk
19:00:07 <Welkin> {-# LANGUAGE OverloadedStrings #-}
19:00:08 <shachaf> @google How do I activate an extension in ghci?
19:00:09 <lambdabot> http://stackoverflow.com/questions/12584884/how-do-i-enable-language-extensions-from-within-ghci
19:00:10 <lambdabot> Title: haskell - How do I enable language extensions from within GHCi? - Stack Overflow
19:00:17 <Welkin> oh
19:00:23 <Welkin> :set -XOverloadedStrings
19:00:24 <Welkin> I think
19:00:45 <_1_Euzel> si
19:01:10 <Pamelloes> I need to get in the habit of googling again. I am to dependent on asking people in this chat :/
19:03:21 <Pamelloes> "compare is not a visible method of class Ord' ". What?
19:03:35 <Pamelloes> (where type Ord' = Ord)
19:03:45 <Axman6> @src Ord
19:03:46 <lambdabot> class (Eq a) => Ord a where
19:03:46 <lambdabot>     compare              :: a -> a -> Ordering
19:03:46 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
19:03:46 <lambdabot>     max, min             :: a -> a -> a
19:03:50 <Axman6> o.O
19:04:19 <Pamelloes> It has to do with creating a typeclass synonym. But I'm not sure how to fix that :/
19:04:50 <lornap> Hi all, Anyone here familiar with free monad transfomers that can help with building an interpreter of a free monad stack?
19:04:54 * hackagebot pipes-rt 0.5.0 - A few pipes to control the timing of yields  http://hackage.haskell.org/package/pipes-rt-0.5.0 (imalsogreg)
19:08:05 <bananagram> @src Monoid
19:08:05 <lambdabot> class Monoid a where
19:08:05 <lambdabot>     mempty  :: a
19:08:05 <lambdabot>     mappend :: a -> a -> a
19:08:05 <lambdabot>     mconcat :: [a] -> a
19:09:04 <Axman6> heh, didn't realise mconcat was a member of Monoid itself, I guess that could be useful when you need left or right associativity (or balanced too I guess)
19:09:20 <shachaf> What do you mean?
19:09:56 <bananagram> you don't really need it, I defined a monoid without mconcat
19:10:16 <EvanR> left and right shouldnt change the behavior, just performance
19:10:19 <MP2E> tha's because mconcat is defined in terms of mappend
19:10:19 <MP2E> and mempty
19:11:18 <Axman6> I mean the defaut foldr mappend mempty may not be ideal if your type has certain properties, like trees which you might not want to make grossly unbananced when using mconcat
19:11:24 <bananagram> Gloss provides mconcat for Picture and defines mappend in terms ofit
19:11:37 <Axman6> EvanR: right, that may be important
19:25:21 <timmy_tofu> Anyone have experience with linker problems? I'm suddenly getting "can'tload .so/.DLL.... undefined symbol" when rebuilding a package. Literally nothing has changed since it was last built
19:29:25 <timmy_tofu> The package generating the error works fine, as well, it's only other packages depending on it that error when linking.
19:33:14 <fresheyeball> hey
19:33:37 <SrPx> is there a generic filter ?
19:34:03 <fresheyeball> is there a reason that function composition is (.) instead of (<>) ?
19:34:18 <SrPx> why'd it be <> ?
19:34:26 <EvanR> it is <> for Endo
19:34:42 <shachaf> fresheyeball: The types are wrong.
19:34:44 <EvanR> but (.) is more general
19:34:58 <shachaf> fresheyeball: Functions are a category, which is a generalization of a monoid for things that have types.
19:35:04 <fresheyeball> ok sorry
19:35:05 <johnw> SrPx: you mean, like a Filterable?
19:35:09 <fresheyeball> not <>
19:35:11 <fresheyeball> mappend
19:35:11 <johnw> fresheyeball: . is much closer to math's ∘
19:35:15 <shachaf> (.) from Control.Category gives a class that implements (.)
19:35:26 <shachaf> s/implements/has/
19:35:38 <shachaf> fresheyeball: (<>) and mappend are the same thing. :-)
19:35:45 <SrPx> filterable? is that a thing? never heard about it. I thought anything transversable would be filterable? uhmm
19:35:51 <fresheyeball> ok so functions are a monoid right?
19:35:52 <shachaf> Look at the types: (<>) :: m -> m -> m; (.) :: (b -> c) -> (a -> b) -> (a -> c)
19:35:55 <johnw> SrPx: no, I was referring to a discussion from yesterday
19:36:02 <shachaf> fresheyeball: No, they're a category.
19:36:02 <johnw> there is Filterable to my knowledge
19:36:16 <fresheyeball> ok so now I'm confused
19:36:25 <EvanR> functions restricted to one type form a monoid via composition
19:36:30 <EvanR> Int -> Int
19:36:32 <EvanR> Bool -> Bool
19:36:41 <fresheyeball> functions satisfy the axioms no?
19:36:50 <fresheyeball> mappend = (.)
19:36:50 <EvanR> @src Endo
19:36:50 <lambdabot> Source not found. Whoa.
19:36:54 <fresheyeball> mempty = id
19:36:56 <shachaf> fresheyeball: No, one of the axioms is that you have composition :: A -> A -> A
19:37:04 <shachaf> fresheyeball: There's no type A here that works for functions in general.
19:37:23 <joness> since it is far more common to want foldl', and very rarely (if ever) do we want foldl, why didn't library writers rewrite foldl as foldl'? this would automatically fix all the functions that used foldl before foldl' existed (like sum)
19:37:32 <shachaf> You have composition :: A b c -> A a b -> A a c, and identity :: A a a
19:37:48 <johnw> joness: just to save typing '?
19:37:49 <shachaf> When you have something which is like a monoid, but with types like the ones I wrote above, it's called a category.
19:38:03 <shachaf> johnw: It changes semantics.
19:38:07 <shachaf> joness, I mean.
19:38:09 <fresheyeball> oh, I see it now
19:38:19 <fresheyeball> its the restriction of A -> A -> A
19:38:20 <shachaf> joness: Some things work with foldl and fail with foldl'
19:38:52 <joness> johnw did you miss the second part of my sentence? sum is broken because it uses foldl, and nobody bothered to change it. if foldl was reimplemented as foldl' sum (and all the other functions that use foldl while they should be using foldl') would be fixed automatically
19:39:11 <homovitruvius> how do I know that in order to install System.Remote.Monitoring I have to 'cabal install ekg' without searching on hackage?
19:39:26 <fresheyeball> so a category in haskell is a collection of objects
19:39:26 <joness> shachaf and some things work well with foldl' but can fail with foldl.. ie sum. is that scenario not more common?
19:39:43 <EvanR> sum is implemented with foldl??
19:39:45 <shachaf> joness: Yes, but the Report specifies that foldl behaves the way it does.
19:39:46 <fresheyeball> equipped with an associative operator
19:39:55 <fresheyeball> and an identity value
19:39:56 * hackagebot aws-ec2 0.3 - AWS EC2/VPC, ELB and CloudWatch client library for Haskell  http://hackage.haskell.org/package/aws-ec2-0.3 (VladimirKirillov)
19:40:07 <shachaf> joness: Also, GHC's strictness analyzer makes sum work fine with foldl, generally.
19:40:14 <fresheyeball> but where the associative operator is not commutative?
19:40:34 <shachaf> fresheyeball: Neither Monoid nor Category says anything about commutativity.
19:40:54 <fresheyeball> so what is the difference between a monoid and a category?
19:41:09 <EvanR> check the types of (<>) vs (.)
19:41:27 <joness> shachaf code only working properly when certain optimizations are turned on doesn't seem ideal.. why was sum not fixed, at least?
19:41:37 <joness> by making it use foldl'
19:42:03 <shachaf> joness: There can be Num instances where foldl' fails and foldl succeeds.
19:42:08 <joness> and all the other functions that use foldl when they should be using foldl'
19:42:13 <shachaf> joness: Look, this is how the standard is. The standard moves slowly.
19:42:31 <joness> does standard specify how sum should work as well?
19:42:34 <shachaf> Given that GHC can usually optimize this, people have decided that breaking compatibility wasn't really worth it.
19:42:38 <shachaf> Yes.
19:42:59 <shachaf> They might decide differently in the future. Compatibility is being broken more these days.
19:43:13 <joness> GHC or Report?
19:43:32 <EvanR> (compatibilty with whose use of foldl ;)
19:43:58 <fresheyeball> ok so other question
19:44:12 <shachaf> GHC is breaking compatibility with the Report, and the Report might release a new version of Haskell to restore compatibility with GHC.
19:44:19 <fresheyeball> this definition of category is pretty far from what I'm reading in CT
19:44:32 <fresheyeball> how do the concepts relate?
19:44:43 <EvanR> are you sure you understand type class?
19:44:48 <EvanR> the category class?
19:45:01 <fresheyeball> its not very complex
19:45:13 <fresheyeball> I feel like I get the typeclass category
19:45:26 <fresheyeball> but its very different from the math definition of category
19:45:46 <EvanR> the laws arent listed, as usual
19:45:58 <fresheyeball> my understanding is that in math category is extremely non-restrictive
19:46:18 <EvanR> well in haskell all your programs are restricted to dealing with "Hask" types
19:46:23 <shachaf> fresheyeball: The Haskell class Category is very similar to the usual definition of Category.
19:46:33 <shachaf> Especially now that it's polykinded.
19:46:53 <shachaf> There was an issue where you couldn't make small categories before (because every Haskell type was an object).
19:47:33 <fresheyeball> so could to describe the category of monoids in haskell?
19:47:41 <fresheyeball> could you*
19:47:52 <fresheyeball> or is that not possible because of the Hask restriction?
19:48:10 <monochrom> at the onset, math category is not restricted to computable stuff, and any programming language's or library's category is. Haskell is just a programming language, not a math universe.
19:48:11 <johnw> I think that's not possible because of the instance head restriction
19:48:19 <shachaf> You can make such a category, but you'd have to check the laws yourself, as usual in Haskell.
19:48:48 <johnw> although I should try actually writing it before answering
19:49:43 <monochrom> unless, of course, you're a fundie constructivist and so your "math" is restricted to computable stuff
19:50:47 <EvanR> but, you can constructively show that you are missing some things there ;)
19:50:54 <EvanR> just not what they are
19:56:00 <Pamelloes> What does a pipe in a class definition mean?
19:56:23 <fresheyeball> 	
19:56:25 <fresheyeball> shachaf can you show me what that might look like?
19:58:19 <monochrom> Pamelloes: it is "functional dependency". it is related to "multiple parameter type class".
19:59:18 <Pamelloes> Ok
19:59:56 * hackagebot saltine-quickcheck 0.1.0.0 - Quickcheck implementations for some NaCl data  http://hackage.haskell.org/package/saltine-quickcheck-0.1.0.0 (tsuraan)
20:00:04 <shachaf> fresheyeball: Hmm, it's a little trickier than it would be for e.g. the data-category approach.
20:03:33 <shachaf> fresheyeball: OK, I'm not sure how to do id, actually. :-)
20:04:06 <fresheyeball> no problem
20:05:53 <shachaf> This is an interesting question. Does someone else here have ideas?
20:06:16 <shachaf> The obvious thing to do is data Mon a b where { Mon :: (Monoid a, Monoid b) => (a -> b) -> Mon a b }
20:06:35 <shachaf> But you need to only allow things that have Monoid constraints.
20:06:42 <shachaf> Can you make a kind for that?
20:08:00 <fresheyeball> I didn't know you could make kinds
20:11:26 <starless> fresheyeball: Apparently kinds are types in Haskell: https://ghc.haskell.org/trac/ghc/wiki/IntermediateTypes#KindsareTypes
20:11:43 <EvanR> kinds are the type of types
20:12:01 <shachaf> Kinds aren't types -- that page is about GHC's internal representation -- but types can be promoted to kinds with DataKinds.
20:12:05 <starless> EvanR: Isn't the type of types Type?
20:12:17 <EvanR> not in haskell
20:12:29 <EvanR> its usually *
20:12:51 <starless> so wait
20:12:59 <starless> is Haskell dependently typed then?
20:13:04 <EvanR> nope
20:13:06 <starless> disclaimer: I don't understand this stuff!
20:13:06 <shachaf> So, for instance, if you wanted to make a category with one object, you could make data T = T; data K :: T -> T -> * where { ... }; instance Category K where { ... }
20:14:10 <starless> yeah I think I'll save thinking about this for when I have a better understanding of typesystems
20:14:18 <starless> types and values are sufficient for me yet
20:14:29 <EvanR> no!
20:14:38 <starless> EvanR: D:?
20:14:49 <EvanR> dont settle for that
20:15:40 <starless> EvanR: why not, if temporarily? I don't really even understand monoids, or monads, or IO in Haskell yet
20:15:54 <starless> I don't think I'm ready haha
20:15:55 <EvanR> oh well, go ahead and learn that stuff
20:16:46 <shachaf> Well, I'd like an answer to "can you make a category of monoid homomorphisms [without checking the laws]"
20:23:02 <Saizan> shachaf: type Mon = (->)
20:24:01 <shachaf> Saizan: I guess so. :-(
20:24:17 <shachaf> Saizan: With data-category's class you can put the constraints inside the data type.
20:25:34 <Saizan> but do you want to?
20:26:03 <shachaf> I guess it's the usual argument about putting constraints at use site.
20:26:50 <shachaf> At least make Mon a newtype, though.
20:26:55 <shachaf> You want to talk about adjunctions and so on.
20:27:42 <Saizan> yeah
20:53:01 <sdf9e2taksdfjdfa> @pl id
20:53:02 <lambdabot> id
20:53:16 <sdf9e2taksdfjdfa> @pl let f a b c = a d c f
20:53:16 <lambdabot> (line 1, column 22):
20:53:16 <lambdabot> unexpected end of input
20:53:16 <lambdabot> expecting variable, "(", operator, ";" or "in"
20:53:28 <sdf9e2taksdfjdfa> @pl f a b c = a d c f
20:53:28 <lambdabot> f = fix ((const .) . flip (flip . ($ d)))
20:54:59 * hackagebot readable 0.2.0.2 - Reading from Text and ByteString  http://hackage.haskell.org/package/readable-0.2.0.2 (DougBeardsley)
20:58:44 <Pamelloes> git branches are awesome.
21:20:00 * hackagebot clanki 1.2.5 - Command-line spaced-repetition software  http://hackage.haskell.org/package/clanki-1.2.5 (marcusbuffett)
21:24:48 <EvanR> :t flip const
21:24:49 <lambdabot> b -> c -> c
21:24:53 <EvanR> :t const . id
21:24:53 <lambdabot> b -> b1 -> b
21:25:01 <EvanR> :t const id
21:25:02 <lambdabot> b -> a -> a
21:26:41 <benzrf> (.id) = id
21:26:44 <benzrf> :t (.id)
21:26:45 <lambdabot> (b -> c) -> b -> c
21:26:56 <EvanR> far out
21:31:41 <abg> There was recently a thread on /r/haskell (and on Cabal's GitHub) asking for binary caching so that packages don't have to be recompiled for sandboxes. I just discovered that we already have support for this somewhat by adding another package-db entry to the cabal.sandbox.config. Example: http://lpaste.net/118905
21:45:01 * hackagebot readable 0.3 - Reading from Text and ByteString  http://hackage.haskell.org/package/readable-0.3 (DougBeardsley)
21:56:38 <EvanR> haha Default defaults to ()
21:56:46 <EvanR> handy
21:57:37 <lpaste> ClaudiusMaximus pasted “optimization help? (code)” at http://lpaste.net/118908
21:58:07 <lpaste> ClaudiusMaximus annotated “optimization help? (code)” with “optimization help? (prof)” at http://lpaste.net/118908#a118909
21:59:18 <ClaudiusMaximus> anyone got any ideas for speeding up my Rational and Integer stuff?  those small functions are called very often
21:59:54 <EvanR> is Doc a good way to show tables of data
22:01:05 <Axman6> ClaudiusMaximus: what's wrap doing?
22:01:14 <ClaudiusMaximus> Axman6: like `mod'` 1
22:01:20 <ClaudiusMaximus> but faster (i already tried)
22:03:08 <jle`> interesting
22:04:45 <Axman6> um, perhaps making wrap use: | y < 0 = (denominator y + numerator y) % (denominator y) -- which I think is equivalent to 1 + y?
22:05:32 <Axman6> @check \y -> (denominator y + numerator y) % (denominator y) == 1 + (y :: Rational)
22:05:34 <lambdabot>  +++ OK, passed 100 tests.
22:06:30 <ClaudiusMaximus> if it helps, in ceiling' and floor', y is of the form 2^n-1
22:06:51 <ClaudiusMaximus> Axman6: i'll try
22:07:09 <Axman6> (2^n)-1 or 2^(n-1)?
22:08:09 <ClaudiusMaximus> Axman6: (2^n)-1
22:09:09 <ClaudiusMaximus> n can typically be 3 digits, rarely up to 5 digits
22:09:49 <Axman6> can... you in that case do a shift right of the numerator by n, then subtract x?
22:10:00 <Axman6> if that makes sense
22:10:49 <Axman6> ideally you'd be able to avoid ever using the (%) function by knowing that your jnumerator and denominator will be coprime
22:11:43 <ClaudiusMaximus> yeah, something like   ceiling $ ((numerator x `shiftL` n) - numerator x) % (denominator x)   but without % checks slowing things down
22:12:35 <Axman6> my number theory isn't good enough to know if you can make any assumptions like that though
22:13:45 <ClaudiusMaximus> true, the % check is needed in case  (2^n-1) `gcd` denominator x > 1
22:13:53 <Axman6> yeah
22:16:00 <Axman6> jesus, this storm is pretty intense
22:18:13 <chu> It's picking up, haven't got rain yet though.
22:19:06 <Axman6> the streets are practically flooding here
22:19:28 <chu> You're in the city? Woden here.
22:19:50 <chu> Just started :)
22:19:56 <Axman6> yeah, it's about to hit according to the radar
22:23:52 <lpaste> ClaudiusMaximus annotated “optimization help? (code)” with “slightly faster wrap (annotation)” at http://lpaste.net/118908#a118910
22:24:25 <Axman6> so that was actually a win?
22:24:49 <ClaudiusMaximus> Axman6: your suggestion pushed wrap from 9.1% to 7.8% time (no change on alloc)
22:24:51 <Axman6> also, how are you compiling? I wouldn't mind seeing more const centres
22:25:19 <ClaudiusMaximus> i annotated only the cost centres i want to see, compiling with ghc -prof -O2
22:27:02 <ClaudiusMaximus> those 4 functions take up ~75% of the runtime, and i already optimized all the rest (runtime earlier tonight was around 1min, now 27s)
22:27:53 <Axman6> how hard would it be to try the shifting idea?
22:28:12 <ClaudiusMaximus> will give it a go now, hopefully it'll help
22:28:17 <Axman6> you'd need to keep track of the power of 2 you're multiplying
22:34:13 <lpaste> ClaudiusMaximus annotated “optimization help? (code)” with “slower ceiling' floor' (annotation)” at http://lpaste.net/118908#a118911
22:34:32 <Axman6> ClaudiusMaximus: I need to head home and won't be on IRC for several hours (or until tomorrow) but I'd be interested to hear how you go. Feel free to PM me details =)
22:34:43 * Axman6 will check this last paste before going
22:35:25 <ClaudiusMaximus> Axman6: ok, stay safe
22:35:27 <Axman6> I'm not sure that's quite right, does it give the same results?
22:36:05 <ClaudiusMaximus> seems to
22:36:13 <kadoban> ClaudiusMaximus: It seems like it might be quicker to avoid converting the Integer to a Rational and then converting back, wouldn't it? Why not use numerator, demoninator and such manually maybe?
22:36:23 <Axman6> I would've assumes that wrap (n,d) i = (n << i - n) % d would be the right way
22:36:55 <Axman6> that's (n << i) - n btw
22:37:34 <lpaste> ClaudiusMaximus annotated “optimization help? (code)” with “another ceiling' floor' variation (annotation)” at http://lpaste.net/118908#a118912
22:38:27 <kadoban> ClaudiusMaximus: Like, floor' = numerator x * y `div` denominator x  ? You can probably do that other optimization also if it actually helps
22:38:36 <Axman6> (using x*(2^n-1) = (x << n) - x)
22:39:13 <ClaudiusMaximus> kadoban: ah, nice idea
22:39:17 <Axman6> yeah, that's probably a good way to do it; I assume you're only working with positive numbers thanks to wrap
22:39:24 <ClaudiusMaximus> yep
22:39:43 <Axman6> I was going to suggest it but got put off by negatives, but they're irrelevant
22:43:01 <lpaste> ClaudiusMaximus annotated “optimization help? (code)” with “fast ceiling' floor' (annotation)” at http://lpaste.net/118908#a118913
22:44:14 <Axman6> looks like that made an impact?
22:44:18 <ClaudiusMaximus> run time from 27s to 15s with those changes, thanks kadoban!
22:44:20 <ClaudiusMaximus> yep!
22:44:31 <kadoban> Nice
22:46:37 <Axman6> looks like ceiling and floor are almost 10 times faster than before, going by the number of ticks
22:46:41 <ClaudiusMaximus> the majority of the time `double` is called, i know that the denominator is odd
22:47:02 <Axman6> so jkust add the numerators
22:47:24 * Axman6 hasn't gone home yet because rain is still pouring
22:47:42 <EvanR> Default class is changing my life
22:47:53 <Axman6> def ALL the things!
22:48:09 <kadoban> ClaudiusMaximus: I guess you could try testing for that? I'm…skeptical that it'll help though.
22:48:10 <EvanR> its easier to type def than mempty, and so many things are NOT monoids
22:48:42 <ClaudiusMaximus> kadoban: was thinking more of writing a specialized version that i can call when i know the denominator will be odd
22:48:49 <EvanR> > def
22:48:51 <lambdabot>  ()
22:48:58 <kadoban> ClaudiusMaximus: Oh you can know in advance? Then that could help
22:49:20 <EvanR> foldl' def def def
22:49:42 <ClaudiusMaximus> def def def def ?
22:49:46 <EvanR> hahahaha
22:50:13 <EvanR> type checks? check. does something? check. ship it
22:51:05 <kadoban> ClaudiusMaximus: Hmm. I was assuming that there was some like "unsafe%" operator or something, but I don't see one. That would have helped a tad.
22:55:04 * hackagebot record 0.1.3 - First class records implemented with quasi-quotation  http://hackage.haskell.org/package/record-0.1.3 (NikitaVolkov)
22:56:22 <Axman6> ok, time to go home, seems I'm not going to be able to avoid getting wet -_-
22:57:08 <EvanR> gl
23:01:50 <jle`> can someone explain me why the Monad instace for [] where return = repeat and join is taking the longest possible diagonal (the first element of the first list, the second element of the second list, etc.) is not a valid instance?
23:03:59 <EvanR> what happens if you fmap a returned list to make it an infinite list of empties
23:04:08 <EvanR> then join
23:04:27 <jle`> can you illustrate
23:04:33 <EvanR> return 3
23:04:37 <EvanR> [3, 3, 3, 3, ...]
23:04:40 <jle`> mhm
23:04:49 <EvanR> fmap (const []) that
23:04:54 <EvanR> [[], [], [], []...]
23:05:00 <EvanR> join that
23:05:08 <jle`> oh
23:05:19 <jle`> i defined that as just []
23:05:27 <jle`> the longest possible diagonal
23:05:29 <EvanR> well i think that busts a monad law
23:05:33 <jle`> which law?
23:05:49 <jle`> in that case there is no first item in the firs tlist, so the longest possible diagonal is []
23:06:18 <vanila> isnt it _|_ actually?
23:06:19 <EvanR> your instance stops on the first inability to get the nth element?
23:06:32 <jle`> yeah
23:07:34 <jle`> join [] = []; join ([]:_) = []; join ((x:_):yss) = x : join (fmap (drop 1) yss)
23:07:48 <jle`> the second law works for sure
23:08:12 <jle`> the first law i am pretty sure of as well
23:08:43 <jle`> the third law i think i'm going to have to break out pencil and paper for, but i haven't been able to find any counterexamples
23:09:38 <lpaste> ClaudiusMaximus annotated “optimization help? (code)” with “double' assumes input in [0,1) (annotation)” at http://lpaste.net/118908#a118914
23:09:44 <jle`> oh
23:10:04 <jle`> wait maybe i am not so sure of the first one
23:10:07 <EvanR> right
23:10:11 <EvanR> let me try again
23:11:26 <EvanR> computer generate counterexample
23:11:31 <EvanR> cricket cricket
23:12:17 <jle`> yeah i'm pretty certain of the first law again
23:12:37 <EvanR> i see how this join will reproduce those simple laws
23:12:45 <EvanR> you think its invalid?
23:14:31 <shachaf> QuickCheck can give you a counterexample pretty easily
23:14:55 <jle`> haskell docs for prelude say it's invalid
23:14:59 <shachaf> [[[0]],[[],[0,0]]]
23:15:28 <jle`> because there is no Monad instance for List for which ap is the ZipList (<*>)...but this `ap` here is clearly the ZipList (<*>)
23:15:37 <jle`> *it says that there is...
23:15:43 <jle`> ah, thanks shachaf
23:16:02 <shachaf> Taking the diagonal is valid for streams, of course.
23:16:20 <jle`> in what sense is that the counter-example?
23:16:33 <jle`> oh, m >>= return = m?
23:16:34 <shachaf> join . join /= join . fmap join
23:16:38 <jle`> ah
23:16:59 <jle`> thanks
23:18:58 <shachaf> The wonders of quickcheck.
23:25:05 * hackagebot crypto-pubkey-openssh 0.2.7 - OpenSSH keys decoder/encoder  http://hackage.haskell.org/package/crypto-pubkey-openssh-0.2.7 (FedorGogolev)
23:30:06 * hackagebot Irc 0.1.0.2 - DSL for IRC bots  http://hackage.haskell.org/package/Irc-0.1.0.2 (yunxing)
23:55:07 * hackagebot language-c-inline 0.7.8.0 - Inline C & Objective-C code in Haskell for language interoperability  http://hackage.haskell.org/package/language-c-inline-0.7.8.0 (ManuelChakravarty)
23:56:16 <lpaste> ClaudiusMaximus annotated “optimization help? (code)” with “unsafeCoerce to avoid Rational (%) checks (annotation)” at http://lpaste.net/118908#a118915
23:56:56 <vanila> i would recommendnot doing that
23:57:27 <EvanR> unsafeCoWorst
23:58:24 <ClaudiusMaximus> vanila: goes twice as fast - is there a safe way to tell Data.Ratio that "I know you like to check GCD on every operation, but I assure you the GCD will be 1"
23:58:35 <vanila> you could use your own data type
23:58:42 <ClaudiusMaximus> true
