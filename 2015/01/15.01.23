00:08:25 * hackagebot networked-game 0.1.0.1 - Networked-game support library  http://hackage.haskell.org/package/networked-game-0.1.0.1 (EricMertens)
00:08:25 * hackagebot warp 3.0.7 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.7 (KazuYamamoto)
00:16:56 <funfunctor> srhb: ping?
00:17:11 <srhb> funfunctor: Ping.
00:17:13 <srhb> Or, pong.
00:17:24 <funfunctor> yay! hows things?
00:18:05 <srhb> Good good. FFI magic coming along?
00:18:05 <funfunctor> I made a fair amount of progress with the binding getting the bulk of the boring stuff out the way now and the monadic abstraction is starting to form around those low level primitive bindings
00:18:34 <funfunctor> srhb: http://pastebin.com/CumKpM0J
00:19:41 <funfunctor> srhb: I'm not sure how to best proceed with error handling and also pushing back the various functions into being pre-wrapped up in the IO action. The point there is to avoid passing around dev pointers
00:20:10 <funfunctor> hey vanila!
00:20:18 <vanila> hiya :)
00:20:32 <srhb> funfunctor: You might consider wrapping the device up in a Reader
00:20:43 <funfunctor> srhb: oh!
00:20:46 <funfunctor> I didn't think of that
00:20:50 <srhb> Or providing some custom transformer stack of ReaderT IO ...
00:20:57 <srhb> Which you could then call your BladeRF monad
00:21:12 <srhb> Then you'd have a runBladeT ...
00:21:29 <srhb> There are plenty of options. :)
00:22:12 <funfunctor> yea because ideally I would like to end up with purish sort of functions like , instead of  bladerfGetDevInfo :: Ptr C'bladerf -> IO (String, [Char], Word8, Word8, CUInt)   I could have  bladerfGetDevInfo :: (String, [Char], Word8, Word8, CUInt)
00:22:14 <funfunctor> or something?
00:23:20 <srhb> If you went with the custom transformer stack, you could have getDevInfo :: BladeRF DevInfo
00:23:23 <srhb> Or something like that. :)
00:23:31 <srhb> Where DevInfo is the data structure describing that
00:23:40 <funfunctor> that sounds ideal
00:24:23 <srhb> I would suggest looking at other libraries that deal with hardware abstractions like this. I'm sure there must be some around.
00:26:06 <funfunctor> srhb: I had a look around a bit before, I think someone went with some kind of applicative abstraction from memory
00:26:22 <srhb> Oh. Hmm. Not sure how I'd go about that.
00:26:49 <srhb> Anyway, I have to get a lot of homework done today so if those small inspirations didn't help, I probably won't be able to until tomorrow or something. :)
00:27:16 <srhb> (Weekend handins should be forbidden)
00:29:21 <funfunctor> srhb: no problem, just reminding myself of Monad.Control now, many thanks
00:29:33 <srhb> Sure thing, good luck!
00:29:38 <funfunctor> :)
01:03:33 <triptec> is there anyone that has used wreq and parse application/hal+json ?
01:12:33 <quchen2> Is Nikita Volkov around here, or does anyone know his nick?
01:25:47 <funfunctor> srhb: how can I fix up http://pastebin.com/wwN45CtF lines 61-69 ?
01:26:39 <funfunctor> little confused with the Either and IO monad transforms
01:32:48 <funfunctor> hmm I should be thinking about Exceptions not Errors
01:33:51 <EvanR> Error ?
01:33:55 <EvanR> or error
01:34:00 <dramforever> Hi, if you guys have time check this one out: https://github.com/dramforever/kspl
01:34:22 <dramforever> It's the "Lexer" and "Parser" thing I was talking about
01:34:33 <dramforever> Now here's a working version, finally
01:35:34 <dramforever> there's no readme, but you can check out sample.kspl
01:37:45 <joaopizani1> @pl \l -> nub l == l
01:37:45 <lambdabot> (==) =<< nub
01:38:02 <joaopizani1> @pl \l -> l == nub l
01:38:02 <lambdabot> ap (==) nub
01:53:56 <vanila> @src mapM
01:53:56 <lambdabot> mapM f as = sequence (map f as)
01:54:01 <vanila> @src sequence
01:54:02 <lambdabot> sequence []     = return []
01:54:02 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
01:54:02 <lambdabot> --OR
01:54:02 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
02:21:15 <triptec> is there anyone that has used wreq and parse application/hal+json ?
02:36:20 <triptec> is there anyone that has used wreq and parse application/hal+json ?
02:36:23 <triptec> sorry
02:36:30 <triptec> wrong term
02:36:52 <vanila> you could try asking in about 5 hours when america wakes up
02:36:56 <vanila> that is the best time
02:37:24 <triptec> yeah, Ijust pressed up and enter, was trying "cabal install" =)
02:37:57 <Finalfire> :D
02:40:02 <EvanR> america? everyones awake here like me right?
02:41:19 <LordBrain> i' up
02:42:18 <koomi> triptec: if you explain your problem you have a better chance of getting help, usually people don't want to commit without knowing what they are getting into
03:03:28 * hackagebot laika 0.1.0 - Minimalistic type-checked compile-time template engine  http://hackage.haskell.org/package/laika-0.1.0 (NikitaVolkov)
03:13:28 * hackagebot EtaMOO 0.2.0.0 - A new implementation of the LambdaMOO server  http://hackage.haskell.org/package/EtaMOO-0.2.0.0 (RobLeslie)
03:27:50 <funfunctor> vanila: around?
03:28:22 <vanila> yeah
03:29:22 <funfunctor> vanila: sweet, fancy talking over some monadic transforms with me?
03:29:44 <vanila> sure!
03:30:03 <vanila> want to move to PM?
03:30:08 <funfunctor> yes please
03:30:21 <funfunctor> irssi is not working here and this pidgin is annoying..
03:31:57 <vanila> bindings-DSL-1.0.22 failed during the final install step. The exception was:
03:31:57 <vanila> byte sequence)
03:32:01 <vanila> /tmp/pkgConf-bindings-DSL-1.04653.22: hGetContents: invalid argument (invalid
03:32:03 <vanila> cabal broken as usual
03:33:57 <dcoutts> vanila: workaround might be to use a utf8 locale
03:34:11 <dcoutts> though it shouldn't happen at all, details would be appreciated
03:34:36 <vanila> export LANG="en_US.UTF8"
03:34:40 <vanila> does change anything
03:34:46 <vanila> same error
03:40:22 <arw>  /help ignore
03:40:48 <arw> ah, sorry, that wasn't destined for this channel :)
03:42:20 <dramforever> Hi, I just made something cool but small and I want to share it. Should I post it here?
03:42:49 <mniip> I seem to be doing something wrong with Network.Socket.getAddrInfo
03:43:01 <mniip> is this the way it's supposed to be used
03:43:03 <mniip>     addr <- getAddrInfo Nothing (Just serverHost) Nothing
03:43:03 <mniip>     case addrAddress $ head $ filter (\x -> case x of SockAddrInet _ _ -> True; _ -> False) addr of SockAddrInet _ ip -> connect conn $ SockAddrInet serverPort ip
03:43:55 <dramforever> not too bad
03:44:11 <merijn> mniip: That filter seems useless
03:44:37 <mniip> merijn, well
03:44:43 <merijn> There is only one constructor for AddrInfo, so it always returns true
03:44:47 <jbracker> Why isn't it possible to use pattern synonyms with type families?
03:45:11 <mniip> merijn, wait it's not
03:45:49 <jbracker> e.g. pattern One = S Z; type instance Fun One = False
03:45:53 <merijn> mniip: Which other constructor is there according to you?
03:46:15 <merijn> jbracker: Pattern's are term level (i.e. pattern matches and expressions)
03:46:27 <merijn> jbracker: Type families are type level, so that doesn't make any sense
03:46:35 <mniip> merijn, AddrInfo only has one constructor
03:46:42 <mniip> I'm not matching against AddrInfo though
03:46:52 <mniip> rather SockAddr
03:46:54 <jbracker> merjin: well yes but you can lift data with DataKinds
03:47:09 <jbracker> merijn: And then using a pattern like in my example is useful
03:47:24 <merijn> jbracker: patterns aren't data
03:47:49 <merijn> jbracker: So I'm pretty sure that's not gonna work
03:48:40 <jbracker> merijn: But you can write (S Z) on term and on type level. In both cases it is a pattern right?
03:48:45 <superlinux-hp> hi. anyone here into wxHaskell?
03:48:56 <mniip> oh wai
03:48:57 <merijn> mniip: I'm guessing your serverPort value is messed up
03:49:09 <mniip> sec
03:49:18 <jbracker> merijn: So why shouldn't the concept of a pattern synonym transfer to those patterns on type level?
03:49:24 <superlinux-hp> I can't seem to able to install it. even though I followed the instructions verbatim
03:49:25 <merijn> jbracker: Why would it?
03:49:40 <merijn> jbracker: pattern synonyms are different from writing things explicitly
03:49:58 <superlinux-hp> i am getting this : /usr/bin/ld: cannot find -lHSparsec-3.1.7-ghc7.8.3
03:50:07 <merijn> You could maybe make the pattern synonym concept apply to types, but I wouldn't expect anyone to have done that
03:50:24 <mniip> well anyway
03:50:34 <mniip> getAddrInfo returns a list of AddrInfo's
03:50:43 <mniip> I should find ones with AF_INET
03:51:01 <jbracker> merijn: Okay, that it is not implemented is clear. I just wanted to check if there is any obvious reason to keep them from working on type level
03:51:02 <mniip> and extract the IP
03:51:07 <mniip> still seems a bit too complicated
03:51:21 <jbracker> as long as they produce valid type patterns/expressions
04:00:10 <mpickering> jbracker: Do you not want a type synonym?
04:11:51 <krokodil_> Ok, so any programming in purely functional language can be viewed as an initial data structure and a sequence of successive operations on that data structure.
04:12:18 <krokodil_> For example, we can have a starting list, then use map, then filter it, then use some convoluted fold, then convert the list into a tree, then do some tree operations, then convert it back into a list, then do something else again.
04:12:29 <merijn> krokodil_: Actually, it might be better viewed as a graph of expressions that gets reduced
04:12:50 <krokodil_> So if a functional program is just a pair (data structure, ordered sequence of operations), what insight does it give us?
04:12:52 <merijn> krokodil_: But you're description makes some sense, at least for trivial programs
04:13:09 <dramforever> merijn: Wow that was a good explaination!
04:13:15 <merijn> krokodil_: The value of a purely functional language comes from two parts (one part)?
04:13:32 <dramforever> so knot tying corresponds to cycles!
04:13:33 <dramforever> wow
04:13:44 <krokodil_> What I'm getting at is that this idea naturally leads to persistence of data at each stage of transformation (not necessarily in-memory, but theoretically)
04:13:54 <merijn> krokodil_: Equational reasoning, which roughly translates "in any expression the right hand side of any definition can be replaced with it's left hand side"
04:14:20 <merijn> dramforever: It doesn't only correspond to cycles, in GHC haskell those *are* cycles, like you'd make with pointers in C
04:14:58 <dramforever> merijn: but ghc programmers don't refer to it as a graph, do they?
04:15:01 <merijn> dramforever: i.e. "let ones = 1 : ones in ones" is equivalent to "struct list { int val; struct list *next; }; struct list ones = { 1, &ones };"
04:15:18 <merijn> dramforever: Not usually while programming, no. But that *is* the underlying model
04:15:30 <merijn> dramforever: See also: http://www.vex.net/~trebla/haskell/lazy.xhtml
04:15:38 <krokodil_> So if I apply 3 operations to a list in succession, like map (+2) . filter (>3) . fold (+), how can I make explicit these 3 operations in my program, so that I can use them separately, when i need to transform the data again?
04:15:46 <dramforever> merijn: yes I agree with that
04:16:17 <dramforever> krokodil_: have you learned about .hs files?
04:16:20 <merijn> krokodil_: This might be over your head, if so ignore it, but it sounds like you're looking for the Endo monoid :)
04:16:29 <dramforever> ???
04:16:38 <fProgrammer> quick question: I'm getting an exception with regex matching while using Text.Regex | I understand the problem, but can't really figure out a solution.. http://lpaste.net/119053
04:16:41 <dramforever> What does make explicit mean?
04:16:42 <merijn> krokodil_: "newtype Endo a = Endo (a -> a)", i.e. a function from a type 'a' to itself
04:17:02 <krokodil_> merijn: I came up with this vague idea when I was thinking about graph transformations (I want to write a JS application that transforms one graph into another using a query language, just for fun)
04:17:16 <merijn> krokodil_: Then list of operations on a datatype can be described is just [Endo a], of course this is limited in only allowing list of the same operation
04:17:42 <merijn> krokodil_: On the other hand, function composition is *already* a way to make transformations implicit
04:18:08 <krokodil_> merijn: so I thought, hey, queries (which are equivalent to operations/functions/transformations) are well-defined at each stage. And the graph itself is well-defined after every transformation.
04:18:08 <krokodil_> So a user must be able to, say, go back to a previous version, or divert from a previous stage into another branch
04:18:18 <dramforever> Hello, I've just made something cool but small and I want to share it. Is it correct to post it here?
04:18:30 <fProgrammer> solutions anybody?
04:18:36 <merijn> dramforever: Might be better of pasting it to lpaste/Github gists and then linking
04:18:55 <vanila> to wha?T
04:19:02 <merijn> krokodil_: It sounds like you're (roughly) trying to invent the notion of an isomorphism :)
04:19:06 <vanila> dramforever, yea!
04:19:18 <dramforever> krokodil_: it seems that you want something like scanl
04:19:21 <dramforever> :t scanl
04:19:22 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
04:19:43 <merijn> krokodil_: An isomorphism is a pair of conversions 'f :: a -> b' and 'g :: b -> a' such that 'f . g == id' and 'g . f == id'
04:19:45 <dramforever> scanl ($) 0 [(+1), (+2), (+3)]
04:19:51 <fProgrammer> vanila: in case you missed, I'm getting an exception with regex matching while using Text.Regex | I understand the problem, but can't really figure out a solution.. http://lpaste.net/119053
04:19:54 <dramforever> > scanl ($) 0 [(+1), (+2), (+3)]
04:19:55 <lambdabot>  Occurs check: cannot construct the infinite type: b ~ (a -> a) -> b
04:19:55 <lambdabot>  Expected type: ((a -> a) -> b) -> (a -> a) -> (a -> a) -> b
04:19:55 <lambdabot>    Actual type: ((a -> a) -> b) -> (a -> a) -> b
04:19:58 <dramforever> ouch
04:20:16 <dramforever> it's here: http://github.com/dramforever/kspl
04:20:26 <dramforever> to those who say "yes"
04:20:36 <vanila> > scanl (flip ($)) 0 [(+1), (+2), (+3)]
04:20:38 <lambdabot>  [0,1,3,6]
04:20:46 <dramforever> vanila: yes that's what I mean
04:20:54 <dramforever> krokodil_: ^ it that what you want
04:20:55 <merijn> krokodil_: Not every transformation is an isomorphism, therefore not every transformation is reversible (well, not without storing the original input and simply returning that)
04:20:56 <dramforever> ?
04:21:11 <dramforever> krokodil_: so maybe that scanl thingy?
04:21:16 <krokodil_> merijn: like multiplication by 0 is probably not reversible, is that what you mean?
04:21:27 <merijn> krokodil_: For example, 'foldr (+)' collapses an entire list into a single value and this operation is not really reversible
04:21:35 <krokodil_> dramforever: scanl is good to know about, thanks, but I want to explicitly store a sequence of different operations
04:21:38 <merijn> krokodil_: Because how would you expand into the right list again
04:22:02 <merijn> krokodil_: One of the more trivial isomorphis in haskell is
04:22:14 <krokodil_> merijn: that's why I want to store operations explicitly with corresponding data transformations. Or I think i want to
04:22:16 * dramforever can't keep boasting
04:22:37 <merijn> "swap :: (a, b) -> (b, a); swap (x,y) = (y, x)" which is it's own inverse
04:23:17 <merijn> krokodil_: That can make sense, yes, although storing all intermediate results will of course cost you significant amount of memory
04:23:29 <dramforever> krokodil_: I'm not really getting what do you mean by "explicit"
04:24:29 <krokodil_> merijn: maybe not explicitly storing intermediate results, but maybe store any data as a pair (initial data, sequence of operations)
04:24:46 <krokodil_> merijn: I know that I have no concrete question in mind, I just want to harvest relevant ideas :)
04:25:10 <merijn> krokodil_: That shouldn't be too hard, no
04:25:13 <dramforever> so is anyone checking out this concrete thing? http://github.com/dramforever/kspl
04:25:59 <krokodil_> that way we arrive at the idea of history of data, like Git history of code. In other words I have a list (or even a tree, if we have diverting branches) of successive transformations of data, some of them are destructive (like filter)
04:26:41 <dramforever> krokodil_: that reminds me of DiffArray
04:26:41 <krokodil_> and then any intermediate result or any sequence to arrive at certain data can be stored for user's convenience
04:26:45 <merijn> krokodil_: Sure, since there's no mutable state that sort of history of operations is pretty much trivial to make
04:27:08 <krokodil_> for example what if user wants to apply the same sequence of operations, but to another initial data? Or to apply a sequence to a data again?
04:28:11 <dramforever> krokodil_: how is that different from functions?
04:28:16 <merijn> krokodil_: Like I said, if your operations are all of type "a -> a" then you can just store a list of functions
04:28:42 <iLike> fProgrammer, http://hackage.haskell.org/package/regex-posix-0.95.2/docs/Text-Regex-Posix-Wrap.html#v:retBadbr
04:29:37 <fProgrammer> iLike: any way I can avoid that?
04:30:45 <iLike> It seems you want the regex to be (something like, I'm not too good witg regex syntax): "Data \{.*\}"
04:31:51 <dramforever> fProgrammer: ^ this
04:32:07 <dramforever> "{" and "}" are special in regex
04:32:30 <dramforever> let me see...
04:32:52 <fProgrammer> dramforever: I get  lexical error in string/character literal at character '{'
04:33:12 <dramforever> > Text.Regex.matchRegex (mkRegex "Data \{.*\}") " Decoded Data {\"f\":\"somedata\"}"
04:33:13 <lambdabot>  <hint>:1:39:
04:33:13 <lambdabot>      lexical error in string/character literal at character '{'
04:33:17 <iLike> fProgrammer, regex = "Data \\{.(\\}"
04:33:27 <dramforever> hmm..oh!
04:33:31 <dramforever> yes..
04:33:45 <dramforever> \ is special in haskell...
04:33:50 <dramforever> so complicated...
04:33:52 <iLike> We want the literal '\' character, not the escape sequence '\{'. GHC treats \{\
04:34:25 <iLike> Sorry, GHC treats '\{' sort of like '\n', but since there's no '\{', it gives an error.
04:34:41 <RchrdB> regex = "Data [{].[}]" is another way to write that, making the { and } into single-character character classes.
04:35:35 <RchrdB> One-character classes are nice sometimes when you're up to your elbows in multiple levels of string-nesting and you can't remember how many \'s to type in. :)
04:35:39 <dramforever> Did anyone see that kspl thing? (Sorry if I'm being impolite. I'm really excited about it) it's a marco language based on combinatory logic and has a TeX like syntax
04:36:17 <dramforever> like, "\S{a}{b}{c}" renders into "acbc"
04:36:20 <iLike> dramforever, nope, got a link? :)
04:36:41 <dramforever> http://github.com/dramforever/kspl
04:36:41 <fProgrammer> iLike: using regex = "Data \\{.(\\}" doesn't work, I mean the regex = "Data {.(}" is pretty much right, I checked it on regexpal..
04:37:18 <dramforever> iLike: you can check out sample.kspl
04:38:46 <RchrdB> dramforever: did you mean "macro" or "markup" rather than "marco"? >_>
04:39:12 <dramforever> RchrdB: well, TeX like might be appropriate
04:39:16 <dramforever> *be more
04:39:37 <RchrdB> dramforever: is "marco" a typo?
04:39:46 <dramforever> RchrdB: oh, yep
04:39:59 <RchrdB> That's all I meant. :)
04:40:02 <dramforever> I meant macro
04:40:05 <dramforever> oh no
04:41:10 <dramforever> maybe I'll have to grep for marco in my home directory...
04:43:01 <iLike> fProgrammer, it's odd, I don't get your error in GHCi
04:43:14 <dramforever> RchrdB: thank you a lot
04:43:57 <fProgrammer> iLike: ghci --version is 7.6.3
04:44:05 <RchrdB> dramforever: no problem. >_<
04:44:08 <fProgrammer> if that helps
04:44:28 <iLike> dramforever, looks nice, though \bracket seems complicated :P
04:44:32 <iLike> let me see
04:44:52 <dramforever> iLike: but it's interesting that kspl is turing complete
04:45:04 <iLike> fProgrammer, I have 7.8.3, but I think it's more of a library version problem
04:45:24 <fProgrammer> iLike: Lemme check with ghci -7.8.3
04:46:12 <iLike> The regex doesn't match though fProgrammer :P
04:46:38 <dramforever> iLike: Do you have any ideas? Maybe I should add a lambda system?
04:46:51 <dramforever> but that seems more complicated on my side
04:47:04 <RchrdB> dramforever: I have two opinions. One is, kspl is *really* cute. The second is, oh my gosh SK combinator calculus, I have no idea how to do actual things using it. :)
04:47:10 <iLike> It seems to me like you are parsing a logfile. Parsing in Haskell is pretty easy using Parsec, so I suggest you read up on Parsec, it will be useful in the future
04:47:16 <iLike> fProgrammer, ^
04:47:27 <dramforever> RchrdB: what does your second point mean?
04:47:45 <RchrdB> Your sample.kspl shows off just two built-in combinators, S and K.
04:47:51 <fProgrammer> iLike: yeah! I program in python and haskell, I need this to parse a large log file, and I thought haskell IO would be useful
04:48:02 <dramforever> RchrdB: yep, and?
04:48:22 <RchrdB> SK combinators are Turing-complete but *quite* difficult to use.
04:48:31 <dramforever> yes, agreed
04:48:31 <RchrdB> Add more combinators?
04:48:59 <dramforever> RchrdB: Maybe. That's why I'm asking
04:49:05 <dramforever> I'm asking for ideas
04:49:32 <dramforever> Current: add combinators to tell commands, texts and groups apart
04:49:54 <dramforever> add \error for obvious reasons
04:50:00 <merijn> fProgrammer: I strongly support learning parser combinators if you wanna do parsing, yes
04:50:05 <RchrdB> Pretty much everything in Data.Function except for "fix" which I think might have to work differently if your macro language is strict.
04:50:22 <dramforever> It's actually like call by name
04:50:29 <merijn> fProgrammer: Real World Haskell has a chapter on parsec, some of the code samples are out of date (they cover parsec 2, instead of 3), but the high level picture is still accurate
04:50:36 <dramforever> RchrdB: or call by code
04:50:49 <fProgrammer> merijn: On it, thanks
04:50:52 <RchrdB> Huh, cool. :)
04:51:36 <dramforever> It was originally designed to be a markup language, so macros seldom duplicate arguments
04:51:40 <iLike> fProgrammer, https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec, even specified to your usecase :P
04:51:56 <dramforever> therefore call-by-code makes perfect sense
04:52:15 <fProgrammer> iLike: Thanks!
04:53:24 <dramforever> Hey idea: Where's the source code for @pl? I'd like to see what combinators does it use
04:53:35 <dramforever> *combinators it uses
05:03:34 * hackagebot hxt 9.3.1.11 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.1.11 (UweSchmidt)
05:03:57 <Saizan> dramforever: https://hackage.haskell.org/package/pointfree
05:07:22 <dramforever> Saizan: Thanks, I'll check it out
05:10:31 <dramforever> Great, I saw then in Rules.hs starting from line 167
05:15:25 <dramforever> wait a sec...
05:15:27 <dramforever> @pl 5
05:15:28 <lambdabot> 5
05:15:42 <dramforever> oh sorry, ignore that
05:18:57 <halvorg> hm, ghc: out of memory appeared after I did some refactoring in my program.
05:19:10 <halvorg> I stashed the changes and I still get it, any ideas?
05:19:49 <dramforever> did you recompile? git stash doesn't undo the changes it doesn't care, iirc
05:20:43 <merijn> halvorg: Maybe your machine is just low on memory? How much RAM does the machine have? GHC is not particularly lightweight >.>
05:20:52 <halvorg> 8gb ram
05:21:04 <halvorg> I checked out an old commit I know compiled fine.
05:21:11 <halvorg> building with cabal build
05:21:21 <dramforever> halvorg: maybe touch all the files?
05:21:23 <merijn> hmm, that's odd
05:21:30 <halvorg> is there a cache i can delete?
05:21:34 <merijn> halvorg: Have you tried "cabal clean"?
05:21:39 <halvorg> no
05:21:42 <dramforever> yes that one
05:21:53 <jbracker> mpickering: Yes you are right
05:21:58 <halvorg> clean worked
05:22:09 <dramforever> halvorg: how's the program going?
05:22:29 <halvorg> works as it should now, thanks guys
05:25:59 <dramforever> Is there something like Data.Text.Lazy.Builder.Extra? I'd like to tweak them like bytestring builders
05:28:13 <dcoutts_> dramforever: to do what?
05:28:32 <dramforever> dcoutts: tweak buffer size
05:28:35 * hackagebot hmark 1.2 - A tool and library for Markov chains based text generation.  http://hackage.haskell.org/package/hmark-1.2 (JaroslavGridin)
05:28:59 <merijn> dramforever: That doesn't make a lot of sense of lazy text...
05:29:10 <dramforever> okay..
05:29:14 <dcoutts_> dramforever: ahh, if you don't see it there then probably not. It's less sophisticated than the bytestring builder one
05:29:16 <dramforever> maybe I'll try something else
05:29:29 <dcoutts_> merijn: I don't see why it doesn't make sense
05:30:41 <merijn> dcoutts_: afaik lazy ByteString isn't stuck to fixed buffers is it? Maybe I'm just misunderstanding...
05:31:15 <dcoutts_> merijn: right, you can both customise the buffer policy and you can run them with your own buffers
05:31:36 <dramforever> dcoutts: how about a custom typeclass
05:32:01 <dcoutts_> dramforever: I don't know what you're suggesting
05:32:21 <dramforever> dcoutts same function for different uses
05:32:29 <dramforever> one uses builder
05:32:37 <dramforever> the other uses my custom builder
05:32:58 * dcoutts_ doesn't have enough context to comment
05:33:22 * dramforever thinks maybe that question is too vague
05:35:42 <poi_> :t lift
05:35:43 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
05:35:51 <dramforever> Wow this is perfect! http://hackage.haskell.org/package/text-1.2.0.4/docs/Data-Text-Internal-Search.html
05:35:56 <dramforever> Why is it internal..
05:36:22 <vanila> Warning: /tmp/pkgConf-bindings-DSL-1.07421.22: Unrecognized field data-dir on
05:36:22 <vanila> line 32
05:36:22 <vanila> /tmp/pkgConf-bindings-DSL-1.07421.22: Unrecognized field key on line 4
05:36:43 <vanila> weird error after deleting the funny i in Maurício
05:39:12 <vanila> can't do anything with haskell these days :(
05:42:49 <hodapp> what's led to Haskell being the tool of choice (as far as I can tell) for all sorts of EDSLs, vs. something like OCaml that is perhaps better-established and more stable?
05:43:17 <bergmark> is it? :-O
05:43:38 <hodapp> what, Haskell the tool of choice, or OCaml better-established?
05:43:42 <clrnd> I made a meetup in my city and we are already 35 :D
05:44:07 <arw> vanilla: weird error after deleting an utf-8 character might be a broken editor. if the character is composed from a normal 'i' and a composing accent, and the editor just deletes one of them, or even worse, just a part of a character like e.g. a byte.
05:44:48 <bergmark> hodapp: better established
05:45:02 <merijn> hodapp: I would say haskell is better established than OCaml
05:45:04 <hodapp> bergmark: it's the idea I've gotten, even hearing what folks like SPJ say
05:45:29 <merijn> hodapp: OCaml is vastly less popular than haskell and has been for nearly a decade
05:45:40 <vanila> I wish I knew
05:45:56 <bergmark> i did some ocaml several years ago but switched to haskell because the ecosystem seemed much more mature
05:46:08 <dramforever> haskell has many historical mistakes, though
05:46:15 <arw> vanila: try hexdump -C on the file and look for characters with the highest bit set.
05:46:20 <merijn> dramforever: So does ocaml and every language in existence
05:46:28 <dramforever> some of us are working on it
05:46:52 <merijn> dramforever: The biggest haskell issue I see would be the Num hierarchy, but it is unclear what a better alternative would be
05:46:59 <dramforever> And many don't really agree with those pure functions and monads
05:47:10 <hodapp> SPJ seemed to regard Haskell as being much more a proving ground for all sorts of semi-experimental language features
05:47:21 <dramforever> yes
05:47:36 <dramforever> haskell is relatively cleaner
05:48:08 <dramforever> good thing it doesn't get too clean
05:48:11 <merijn> hodapp: Sure, just look at the ridiculous amount of new features at every GHC release
05:48:15 <hodapp> cleaner in what sense?
05:48:36 * hackagebot handsy 0.0.1 - A DSL to describe common shell operations and interpeters for running them locally and remotely.  http://hackage.haskell.org/package/handsy-0.0.1 (utdemir)
05:48:45 <hodapp> oh look, another DSL :P
05:48:49 <dramforever> hodapp: syntax. I think it's a good balance between usablity and higher-orderism
05:49:00 <hodapp> higher-orderism?
05:49:27 <dramforever> > let doubleMe = (+) <$> id <*> id in doubleMe 20
05:49:28 <lambdabot>  40
05:49:36 <dramforever> that's pretty clean
05:49:48 <arw> hodapp: nowadays nobody builds libraries or frameworks anymore, the new hot shit is DSLs ;)
05:49:57 <hodapp> arw: this is true
05:50:02 <merijn> dramforever: Also known as "join (+)" ;)
05:50:02 <bernalex> dramforever: I'd prefer
05:50:09 <merijn> > join (+) 10
05:50:11 <lambdabot>  20
05:50:13 <bernalex> merijn: that
05:50:14 <dramforever> yes, agreed
05:50:19 <hodapp> :t join
05:50:19 <lambdabot> Monad m => m (m a) -> m a
05:50:22 <dramforever> see, that's clean too
05:50:38 <bjornars1> whats wrong with (*2)?
05:50:43 <dramforever> even using a language like
05:50:50 <hodapp> arw: though all the "DSLs" I saw in C++ were royal clusterfucks
05:50:52 <dramforever> C#, they are not this clean
05:51:01 <merijn> bjornars1: That doesn't really translate to other functions, though
05:51:03 <merijn> bjornars1: Like
05:51:06 <merijn> > join (,) 10
05:51:07 <lambdabot>  (10,10)
05:51:12 <vanila> Warning: /tmp/pkgConf-Cabal-1.22.08412.0: Unrecognized field data-dir on line 68
05:51:27 <dramforever> bjornars1: well, that would really be another clean aspect of haskell
05:51:28 <vanila> even getting this when just doing cabal install cabal-install after deleting .ghc and .cabal
05:51:30 <hodapp> is OCaml uglier when it comes to operations like this?
05:51:33 <hodapp> I've little experience with it
05:51:39 <dramforever> I don't know either
05:51:39 <merijn> hodapp: ocaml doesn't have higher kinded types :(
05:51:48 <hodapp> which I guess means I shouldn't apply to Facebook
05:51:51 <hodapp> which I wasn't going to do anyway
05:51:53 <tzaeru> every time I look at this channel, some other language is being bashed on. :P
05:52:07 <arw> hodapp: yes, but there is also the issue of the terminology getting muddier. e.g. people have categorized OpenGL as a library, a framework or a DSL, depending on their respective inclination
05:52:16 <merijn> tzaeru: We can bash on haskell too, if you like :)
05:52:23 <hodapp> tzaeru: I don't know that saying that OCaml lacks higher-kinded types is bashing on it...
05:52:33 <dramforever> haskell doesn't have dependent types
05:52:35 <hodapp> looks more like an easily-verified statement of fact to me.
05:52:40 <merijn> tzaeru: Being proper gentleman we separate all languages into two categories: sucks and doesn't suck
05:52:41 <dramforever> well, not in ghc for now
05:52:44 <tzaeru> hodapp, the line I'd refer to was a bit higher up ^^
05:52:47 <merijn> tzaeru: And then put all of them in the first category :)
05:53:01 <hodapp> dramforever: and the paper on how to achieve something similar is called "Hasochism" :)
05:53:21 <tzaeru> merijn, that generally works with anything that has to do with IT, really!
05:53:27 <bernalex> hodapp: there's work on -XDependentTypes though.
05:53:30 <hodapp> arw: the bigger issue for me was just the giant train-wrecks people would build in C++ :P
05:53:41 <dramforever> actually, the think (iirc it's called Extended Static Checking) the {-# CONTRACT #-} thing is more specific but very useful in practice
05:53:42 <tzaeru> modelling programs? -> well, they suck, suck and suck. image editors? -> they suck, suck and suck. team management software? -> scheisse!
05:53:44 <hodapp> bernalex: I may have to look into this.
05:54:05 <bernalex> tzaeru: it's all just a bunch of somewhat carefully arranged sand anyway. it's a wonder anything even begins to work.
05:54:20 <dramforever> s/the think/I think the/
05:54:27 <hodapp> bernalex: sand is just for people who are too stupid to assemble atoms themselves.
05:54:32 <merijn> tzaeru: oh, btw, since you said you were doing game programming. I remembered a talk from Tim Sweeney (Epic Games) on the future of programming languages for games and how FP fits in there: https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
05:54:37 <hodapp> bernalex: it's just carefully-arranged atoms, after all.
05:54:42 <merijn> tzaeru: Although I dunno if there's any video of that talk
05:54:51 <tzaeru> holy shit is that comic sans
05:55:04 <rebcabin> newcomer here with a beginner's question: I want to try out Test.QuickCheck.Gen in GHCi; i say choose (1,42) and get no instance for (Show(Gen a0)), and I don't remember how to get the value out of the Gen and print it
05:55:08 <bernalex> merijn: I thought his conclusions were a bit ehhh, iirc
05:55:16 <bernalex> merijn: jcarmack's keynote at quakecon was more interesting
05:55:48 <merijn> bernalex: That talk is from 2006 though, so it's a bit old
05:55:54 <merijn> I've not seen Carmack's keynote
05:55:58 <clrnd> I remember J. Carmack talking wonders about Haskell @ QuakeCon
05:56:19 <clrnd> that, it's really good, and realistic
05:56:22 <bernalex> merijn: he talks a bit about haskell and lisp and functional c++ and stuff. he seems to think haskell is The Right Thing.
05:56:37 <dramforever> rebcabin: read the documentation, If you know how to
05:56:44 <clrnd> he even went so far as to implement Doom in Haskell
05:56:51 <clrnd> (he claims)
05:57:05 <bernalex> wolf3d
05:57:17 <bernalex> he worked on implementing it, and got as far as having the basic game up with guards and shooting etc.
05:57:19 <clrnd> oh sorry
05:57:50 <dramforever> seriously? someone called GHCI here??
05:58:16 <merijn> tzaeru: SPJ gives all his talks in comic sans >.>
05:58:27 <merijn> tzaeru: Yellow on blue background too...
05:58:35 <bernalex> yes, shame on him. he should use Comic Neue, like me. a free font.
05:58:40 <tzaeru> I'd be rather unsure if haskell was th thing, but certainly there's an on-going paradigm shift towards thinking less in horizontal OOP and more in vertical composition. -.O
05:58:59 <tzaeru> s/th/the
05:59:12 <nshepperd> -XDependentTypes is a real thing? I thought it was all a cunning joke
05:59:21 <tzaeru> also I do hope I didn't mix up "horizontal" and "vertical" again.
05:59:23 <bernalex> nshepperd: it's uh taking some time
05:59:33 <merijn> tzaeru: My point of view is that Haskell certainly isn't suitable for *everything*, but I believe most languages will keep moving more and more into the haskell side of things
05:59:48 <clrnd> tzaeru, I wa sunder the impression it was the other way arround
05:59:49 <rebcabin> @dreamforever the documents i found are here https://hackage.haskell.org/package/QuickCheck-2.1.0.1/docs/Test-QuickCheck-Gen.html but I don't see how to show a Gen a from it
05:59:49 <lambdabot> Unknown command, try @list
06:00:00 <tzaeru> I'd be more certain about the general approach moving more to composition over inheritance, and groupings of functionality over single objects.
06:00:11 <tzaeru> it doesn't necessarily need to reflect very strongly in languages to happen.
06:00:23 <merijn> tzaeru: i.e. the right way is to start at haskell and see which parts don't work for your goal and modify the language to accomodate those
06:00:49 <tzaeru> clrnd, well, from my perspective component-based systems are more used and many projects try to focus on flat groupings of functionality, instead of ridiculous inheritance messes and so on
06:01:01 <tzaeru> merijn, perhaps!
06:01:02 <merijn> tzaeru: At the same time, let's face it, 95% of all code being written is being written in stuff like JS/python/ruby where most of the criticisms against haskell (lack of real time, overhead of GC, performance) really don't apply at all
06:01:12 <tzaeru> one day I'll actually try & learn Haskell more properly.
06:01:12 <clrnd> tzaeru, I meant OOP is *vertical*
06:01:37 <tzaeru> clrnd, oh my. I mixed the terms. sorry >_>
06:01:41 <clrnd> :P
06:01:59 <jtanguy> rebcabin: its just defined under choose
06:02:05 <jtanguy> :t generate
06:02:06 <lambdabot> Gen a -> IO a
06:02:06 <merijn> I won't argue haskell is the only language people should ever use, it's just a far better default than most others ;)
06:02:06 <tzaeru> I'd put the blame on dyslexia, but that'd be laying. my cat mixed them up!
06:02:10 <nshepperd> haskell seems really flexible to me
06:02:10 <exio4> I'd say languages like Haskell started delivering very powerful abstractions, which are really hard to actually achieve in other languages supposed to be the kings of reusable software
06:02:14 <tzaeru> *lying
06:02:22 <tzaeru> too much coffee, can't write.
06:02:22 <merijn> exio4: Yeah
06:02:24 <nshepperd> I could see it morphing gradually into whatever the Right Thing turns out to be
06:02:34 <clrnd> tzaeru, last one I believe
06:02:59 <merijn> exio4: With things like pipes showing up and older abstractions like transformers, etc. we're starting to see TRUE code reuse
06:03:09 <bernalex> I'm sure the ghc type laboratory will keep us entertained for years to come.
06:03:10 <clrnd> maybe there is no right thing, and after dependent types some other powerfull idea comes by and redefines the paradigm
06:03:15 <tzaeru> still need the performance and so to match up tho :P
06:03:15 <rebcabin> jtanguy, dreamforever: I see it now, sample is a way to get out. sample $ choose (1,42) gets me something i can print
06:03:17 <merijn> nshepperd: No, I think it is fundamentally unsuitable to some things
06:03:29 <tzaeru> and preferrably the ease of learning and easiness of relating to
06:03:33 <merijn> nshepperd: Also morphing haskell into a truly dependently typed language seems challenging at best
06:03:33 <dramforever> rebcabin: look at my nickname carefully
06:03:46 <rebcabin> dramforever: apologies
06:03:55 <dramforever> (It's okay, many people do this)
06:04:06 <nshepperd> you can implement so many things as libraries that would have to be language extensions other places
06:04:07 <exio4> merijn, real composable code \o/
06:04:13 <merijn> nshepperd: If you've played with "dependent" haskell and move to a language like Idris everything will seem SO much simpler
06:04:18 <nshepperd> yeah I don't know about dependent types
06:04:20 <dramforever> rebcabin: hint: maybe your irc client can auto-complete nicks when you press TAB
06:04:43 <clrnd> maybe Idris is the future
06:04:46 <bernalex> nope
06:04:49 <iLike> How can something like: "(\x u z ->  x ++ u : z) <$> count 4 digit <*> char '-' <*> count 4 digit" be simplified?
06:04:52 <merijn> I don't know how stable Idris is atm, but it seems easy enough. It helps that it's 1) implemented in haskell and 2) is explicitly marketed at haskellers
06:04:59 <bernalex> clrnd: I don't accept that the future is strict-by-default.
06:05:03 <merijn> bernalex: Word.
06:05:05 <iLike> It seems that the lambda is very unnecessary
06:05:10 <rebcabin> dramforever: it's known that people can read when most of the internal letters of words are scrambled: the eyes see the first and last letters and infer — properly or improperly — the middle :)
06:05:11 <clrnd> then a lazy idris, I almost said it before you
06:05:31 <exio4> I don't really think a language like Idris may be THE language, but probably a very similar language, with everything learnt from it...
06:05:35 <merijn> rebcabin: You should just use tab complete for names like all lazy people :)
06:05:57 <dramforever> rebcabin: yes, and it's frustrating if you don't have a good nick
06:06:04 <merijn> nshepperd: If you wanna learn about dependent types and you like mathy puzzles, do I have the book for you ;)
06:06:19 <bergmark> merijn: what book?
06:06:20 <clrnd> merijn, I'd like that
06:06:30 <poi_> problem haskell for me now is my colleague and my boss dont know well. to say unpopular my area.
06:06:36 <merijn> Software Foundations, like I've been pimping for a while already :p
06:06:38 <bernalex> clrnd: who knows. 40 years ago we weren't meant to be using UNIX or C forever. maybe by revolutionising programming, haskell has actually hurt future programming language research.
06:06:38 <merijn> @where sf
06:06:38 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
06:06:38 <lambdabot> assistant."
06:07:30 <merijn> bergmark, clrnd: It start with trivial functional programming (like haskell without IO) and moves into proving properties about those functions, then slowly moves into dependent types and continues onto modeling and proving properties for imperative programs
06:07:51 <bergmark> is it only available online/
06:07:53 <merijn> Coq is a bit of an ugly language and terrible for programming, but it makes a decent theoretical CS video game :>
06:08:04 <merijn> bergmark: I think there's a print version, probably expensive, though
06:08:22 <bergmark> eh Silk can pay for it for me :P
06:08:23 <bernalex> merijn: uh coq is not general-purpose. it is excused.
06:08:36 <bernalex> also it's named coq
06:08:42 <bernalex> how can you be mad at a language named coq
06:08:43 <merijn> bergmark: The nice thing is that the digital version are literate Coq files, with exercises inside, so you can interactively step through proofs and do the exercises too
06:09:14 <bergmark> ah that's cool
06:09:25 <merijn> bergmark: You work at Silk?
06:09:57 <bergmark> merijn: indeedily!
06:10:55 <rebcabin> jtanguy: :t generate doesn't work for me: "not in scope 'generate'"  So now I Hoogle generate (far too many hits) and look it up in Dash and find a generate only in "Data.Vector"
06:11:12 <merijn> bergmark: You should tell your colleagues to go to the "commercial FP users" meetup in Amsterdam, I've been wanting to give a few advanced haskell talks, but most people there are Scala/Erlang so I don't wanna waste my time :p
06:12:01 <jtanguy> rebcabin: it's in Test.QuickCheck.Gen
06:12:12 <superlinux-hp>  I am having this when I build buildwrapper:  Could not find module ‘System.IO.UTF8’
06:12:13 <superlinux-hp> cabal install buildwrapper gives me so
06:12:14 <bergmark> merijn: we go there every now and then, did you miss our haskell talks+workshops? :)
06:12:39 <merijn> bergmark: I was away for 6 months, so I haven't been at the meetups since early last year :)
06:13:44 <jtanguy> rebcabin: sample' is just generate repeated several times (quickcheck has a notion of size samples, and sample' takes that into account)
06:14:17 <bergmark> merijn: just look for people who forgot their business cards last time ;-)
06:14:25 <bergmark> s/last/next
06:15:12 <rebcabin> jtanguy: I don't see "generate" in https://hackage.haskell.org/package/QuickCheck-2.1.0.1/docs/Test-QuickCheck-Gen.html … "Real-World Haskell" also refers to it but I haven't found it yet :(
06:16:28 <jtanguy> rebcabin: generate has been introduced in QC 2.7 (it's 2.7.6 atm)
06:16:51 <rebcabin> merijn: bergmark: Chlipala has nice free book using Coq to build up dependent types http://adam.chlipala.net/cpdt/
06:17:12 <tzaeru> I want someone to walk me through one piece of code so I can understand it and base my haskell learning to around modifications to it! D:
06:18:20 <LordBrain> what is the piece of code?
06:18:44 <bergmark> rebcabin: cheers!
06:19:18 <pertl> I just try to install all cabal packages that are supported by eclipse-fp (using current haskell-platform) and cabal already whines "cabal: The following packages are likely to be broken by the reinstalls". Is there any useful advice to get around this?
06:19:20 <pertl> on os x
06:19:59 <merijn> pertl: Yes, don't use reinstall, it's almost certainly not what you want
06:20:27 <pertl> yeah, but then, how can I install packages once this warning shows up?
06:20:29 <tzaeru> LordBrain, some juicypixels' example code: https://github.com/Twinside/Juicy.Pixels/blob/master/skeletons/jpeg-basic.hs
06:20:39 <tzaeru> I'm at work atm tho :P
06:20:47 <merijn> pertl: This is a basic primer on this issue: http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
06:21:15 <bergmark> pertl: you may want to use https://ghcformacosx.github.io/ instead of haskell platform
06:21:59 <rebcabin> jtanguy: wow, this wasn't fun to find.. I had to browse down from top of hackage to get to 2.7.6 version — Google sends me to outdated 2.1.0.1 version (yes, I am just now learning how to find Haskell docs :)
06:22:13 <dramforever> Actually, I think that if we eleantly eliminate both variables and parens we will have a speakable language!
06:22:18 <dramforever> *elegant
06:22:23 <dramforever> *elegantly
06:22:42 <bergmark> rebcabin: there's a browser extension hackage-fu that shows angry red colors if you aren't browsing the latest version of the docs
06:23:00 <merijn> bergmark: Although that backfires if hackage is newer than your local install :p
06:23:22 * merijn is preferring local docs nowadays
06:23:35 <pertl> merijn: This is quite helpful but I can't figure out how this page solves my issue.
06:23:48 <jtanguy> rebcabin: if you are in the haddocs of a package on hackage, you can click on "Contents" which show you the package page
06:23:51 <bergmark> i use hackage because i frequently want to compare different versions
06:23:52 <pertl> I don't install anything fancy, just the stuff that comes with support by eclipse-fp
06:24:13 <merijn> pertl: tbh, I've never used eclipse-fp, so I don't know what the usual workflow is
06:24:22 <jtanguy> rebcabin: you'll see all versions listed here
06:24:38 <pertl> merijn: what do you recommend ? emacs, idea, ... ?
06:25:16 <rebcabin> dramforever: I find the most vexing thing in any programming language is operator-precedence. If I  don't use the language every day, the rules leak and I find myself having to try various parenthesiziations to remember how exprs associate; only in LISPs do I never forget :P
06:25:18 <bergmark> pertl: most people i know use emacs or vim, have seen some leksah users too
06:25:55 * pertl : mv eclipse-fp > /dev/null
06:26:43 <greeny> pertl: for bigger projects i prefer kate
06:27:04 <merijn> pertl: A lot of people (I'd guess 2/3rds) here use either vim/emacs, the rest use a mix of Sublime, Eclipse, Leksah, Notepad++, whatever
06:27:15 <estulticia> so what's with this bird? http://learnyouahaskell.com/introduction
06:27:16 <merijn> pertl: I would just use whatever you're familiar/comfortable with
06:27:17 <bernalex> vi vi vi, editor of the beast
06:27:30 <iLike> Sublime with Sublime-Haskell works like a charm
06:27:47 <pertl> I like Jetbrains IntelliJ IDEA but haskell support seems to be very basic there
06:28:07 <bernalex> pertl: I think you might be trying to write IDE when you write IDEA
06:28:30 <bernalex> it is an acronym for "integrated development environment".
06:28:32 <arw> dramforever: there are variables in spoken language. "today i met some guy. that guy had a red shirt and he was really nice. then i met another guy. i didn't like that guy."
06:28:48 <pertl> no, it's a multiligual IDE with an focus on java: https://www.jetbrains.com/idea/
06:28:50 <dramforever> arw: that's okay
06:28:58 <pertl> but it support loads of additional languages
06:29:12 <dramforever> arw but we have to either eliminate parens or make them easier
06:29:15 <bernalex> pertl: oh. never mind me then. good to know!
06:29:23 <pertl> np :-)
06:29:56 <pertl> actually, if you are imprisoned in java code it's quite helpful to survive the pain
06:30:13 <merijn> arw: English is rather limited in how many references you can have to a variable without becoming confusing
06:30:37 <bernalex> yes, Japanese is much better
06:30:47 <merijn> pertl: Tbh I'm one of those masochists that also codes C++ in vim, so what do I know about IDEs :)
06:30:52 <iLike> merijn, arw, isn't that pretty much the 'fault' of the human brain?
06:31:02 <bernalex> pertl: I literally get blisters from coding in Java. I think my brain gets stressed or something. it's bizarre. so I haven't touched the language in years now.
06:31:17 <merijn> iLike: No, because German and Dutch can have many more backreferences without becoming confusing
06:31:18 <arw> iLike: mostly yes. "the compiler sucks" :)
06:31:27 <pertl> it's more boilerplate that a single human can stand
06:31:33 <merijn> iLike: So part of the blame lies squarely on English
06:31:53 <iLike> merijn, I'm Dutch, what are some words English does not have? (Apart from 'gezellig' :P)
06:32:30 <bernalex> [just another day of #haskell language wars]
06:32:34 <merijn> iLike: It's not about words, but since there's more and gendered indirect objects it's easier to disambiguate
06:33:45 <arw> merijn: its not as much the fault of the language itself i think, its more the contemporary usage. english has developed towards a much simpler sentence structure nowadays, whereas in german, that didn't happen.
06:34:04 <arw> merijn: so I think speakers of english just aren't used to keeping track.
06:34:09 <iLike> Well, yeah. Certainly in German. Usually when speaking Dutch people don't pay too much attention to the gender of an inanimate object
06:34:44 <merijn> arw: I'm used to keeping track in Dutch and I still have trouble in English
06:35:03 <merijn> So it's not just habit
06:35:43 <dramforever> hmmm
06:35:50 <dramforever> are we bashing on German??
06:36:47 <arw> dramforever: i thought we are bashing the limited number of variables in english?
06:37:02 <hodapp> I should learn Dutch one of these days.
06:37:06 <hodapp> but I'm still working on German.
06:37:26 <Itkovian> gezellig = cosy, no?
06:37:33 <merijn> Itkovian: Yes, but no
06:38:07 <merijn> Itkovian: The "correct" meaning of the word is highly context dependent and frequently hard if not impossible to capture in English
06:38:30 <dramforever> arw: I some times say "Let A denote this guy with black hair, and B denote this guy with red hair. A is talking to B about haskell, but B is thinking about germal ..."
06:38:57 <bernalex> merijn: oh, Dutch has a word for koselig too?
06:38:59 <dramforever> that's just an example. I do this when it gets complicated
06:39:20 <arw> dramforever: sign language has something like that as its primary grammar. noun gestures are placed at points in the air.
06:39:26 <rebcabin> jtanguy: found the "Contents" trick .. thanks
06:39:34 <merijn> bernalex: I don't know what that means :p
06:39:39 <arw> dramforever: verbs are moving gestures between the noun points, from subject to object
06:39:47 <bernalex> merijn: according to Google translate koselig = gezellig
06:40:04 <bernalex> merijn: is it kind of like cosy, but a lot more than that, and can't really be captured in English?
06:40:34 <bernalex> merijn: do you say "we're going to have it so gezellig this evening!" a lot?
06:40:43 <bernalex> merijn: these things might be an indication that it's the same word as koselig :-P
06:40:50 <merijn> bernalex: Right
06:40:52 <RchrdB> arw: that is really cool!
06:41:13 <merijn> bernalex: Or when people ask "Wanna go for drinks tonight?" 'Ja, gezellig!'
06:41:26 <bernalex> merijn: sounds about right!
06:41:55 <bernalex> merijn: "I went out to dinner with a friend yesterday, it was very koselig."
06:42:01 <hodapp> the #archlinux.de channel sent me to the German equivalent of The Onion and didn't tell me it was that
06:42:14 <ThreeOfEight> hodapp: Der Postillon?
06:42:23 <hyPiRion> bernalex, merijn: can verify, koselig is ~gezellig
06:42:54 <bernalex> hyPiRion: o hai, how's it going
06:42:58 <arw> would that be "gemuetlich" or "gesellig" in german?
06:43:38 * hackagebot stylish-haskell 0.5.11.1 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.11.1 (JasperVanDerJeugt)
06:43:56 <bernalex> merijn: hyPiRion: hahahahha just tried "koslig" (slang-ish version of koselig) in google translate. it apparently translates to "Such helpful owners" WTF.
06:44:58 <bernalex> arw: I vaguely recall gemütlich being translated to koselig when I took German. I don't know if they are used in the same way always though.
06:45:49 <hyPiRion> bernalex: it's going alright, still programming this transpiler/compiler thingy in Haskell, so I got that going for me
06:45:54 <hodapp> transpiler?
06:45:57 <hodapp> what are you transpiling?
06:46:41 <bernalex> hyPiRion: that's nice. I might be working on a haskell-y lang this year. that would be cool too. did anyone find out you rewrote everything in haskell yet? lol
06:46:44 <forgottenone> in f x:f x:[] expression f x evaluated once or twice?
06:47:16 <forgottenone> or should i write like this: a:a:[] where a=f x
06:47:27 <bernalex> I sure hope it's evaluated only once
06:47:40 <Cale> No, twice
06:47:47 <RchrdB> forgottenone: depends on common subexpression elimination, which is an optional optimisation, so write the latter.
06:47:47 <hyPiRion> hodapp: a horrible 1980s data modelling language (an ISO standard) to several languages
06:47:47 <merijn> arw: Yes, although we're now in -blah territory ;)
06:47:48 <geekosaur> the first is evaluated twice
06:47:50 <Cale> If you write f x twice, it gets evaluated twice
06:47:52 <geekosaur> use let/where for sharing
06:48:06 <merijn> Cale: Actually, not guaranteed
06:48:13 <bernalex> Cale: shouldn't that uh beta reduce to the same thing and then laziness and stuff?
06:48:24 <merijn> If you write 'f x' it MAY be evaluated 0, 1 or 2 times
06:48:30 <merijn> Depending on whether CSE strikes
06:48:38 * hackagebot blaze-html 0.7.1.0 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.7.1.0 (JasperVanDerJeugt)
06:48:39 <merijn> If you wanna guarantee it's evaluated once, introduce a new binding
06:48:41 <Cale> Well, it's not guaranteed by the language spec, but it's practically guaranteed because GHC doesn't do very much CSE
06:48:58 <Cale> GHC will only CSE nested case expressions which have identical scrutinees
06:49:04 <Cale> which you're unlikely to write by hand
06:49:17 <hyPiRion> bernalex: yay! Yeah, my boss knew after the summer vacation :p He didn't mind that much, since I am the only person working on the transpiler
06:49:25 <geekosaur> the interaction between laziness and sharing is difficult...
06:49:30 <forgottenone> ok thanks to you all
06:49:55 <Cale> The reason is that CSE often makes space usage worse
06:49:56 <geekosaur> especially if the expression is polymorphic
06:49:57 <forgottenone> i thought because of laziness it evaluates only once
06:50:03 <merijn> forgottenone: To summarise, your second form with 'a=f x' is guaranteed to be evaluated once in GHC
06:50:20 <Cale> laziness means that any *variable* bound to an expression is evaluated at most once
06:50:37 <Cale> It doesn't mean that all functions are memoised -- that would result in nothing ever being garbage collected.
06:51:24 <hyPiRion> we need more memory
06:52:41 <saep> s/more/faster
06:57:35 <ssarah> Hi guys
06:58:30 <ssarah> question, https://github.com/temoto/nginx-lint i followed instructions here, and did "cabal install", but can't find the bin it's supposed to generate.Any idea where it may be?
07:00:17 <merijn> ssarah: Is cabal's install directory on your path?
07:00:24 <merijn> ssarah: Also, which OS?
07:04:02 <lpaste> dbeacham pasted “GADT with polykinds” at http://lpaste.net/3313717012898775040
07:04:09 <lpaste> dbeacham revised “GADT with polykinds”: “No title” at http://lpaste.net/3313717012898775040
07:04:23 <ssarah> merijn: ubuntu 14. Cabal seemed to have run just fine. But not sure. How do I check that? $PATH ?
07:04:34 <lpaste> dbeacham revised “GADT with polykinds”: “No title” at http://lpaste.net/3313717012898775040
07:04:58 <geekosaur> ssarah, cabal installs binaries to ~/.cabal/bin not to the system path (which you cannot write as an ordinary user)
07:05:22 <geekosaur> "export PATH=$HOME/.cabal/bin:$PATH"
07:06:35 <ssarah> Yei. It's there alright <3
07:06:38 <merijn> dbeacham: I think I know your problem
07:06:56 <merijn> dbeacham: It's assuming [k] is a polymorphic list, not a type level list
07:07:07 <merijn> dbeacham: Try '[k] on line 7
07:07:24 <merijn> dbeacham: Or better yet, try this approach: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
07:09:27 <dbeacham> Playing around with kinds: is it possible to get HList to contain types that are of kind k rather than just *? My implementation - http://lpaste.net/3313717012898775040 - complains that '(:) expects second argument to be of kind [*], but, :k '(:) :: k -> [k] -> [k]. Maybe I need to annotate kinds explicitly in gadt?
07:10:11 <merijn> dbeacham: See my answers just no, I think the only change that's need is to replace [*] with [k] in my example?
07:10:15 <merijn> *now
07:14:54 <dbeacham> merijn: Thanks - I didn't realise the lpaste submissions popped up in the chat. I'll have a quick experiment and get back to you.
07:28:01 <_um> Hi, Haskellers.
07:28:24 <clrnd> hi
07:28:34 <_um> Could anyone tell me the standard approach/solution to things like `findIO :: (a -> IO Bool) -> [a] -> IO (Maybe a)`
07:29:08 <clrnd> _um, what's wrong with that?
07:29:27 * mjrosenb assumes _um is looking for an implementation?
07:29:33 <_um> Nothing. I just figured that would be an existing solution that generalized over this kind of problem.
07:29:34 <forgottenone> why isn't this work:  2:3:[]:1:5:[]:[] (i'm trying to create nested list with recursion)
07:29:49 <barrucadu> :t (:)
07:29:50 <lambdabot> a -> [a] -> [a]
07:29:51 <clrnd> :t (:)
07:29:52 <lambdabot> a -> [a] -> [a]
07:29:52 <_um> clrnd: I wrote another `takeUptoIO :: (a -> IO Bool) -> [a] -> IO [a]`
07:29:52 <mjrosenb> forgottenone: parentheses.
07:29:56 <vanila> > (2:3:[]):(1:5:[]):[]
07:29:57 <lambdabot>  [[2,3],[1,5]]
07:30:18 <_um> And they both have essentially the same structure, so I imagine there's some higher order solution to these kinds of patterns.
07:30:34 <clrnd> _um http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Traversable.html
07:30:38 <_um> mjrosenb: Yep, thanks.
07:30:39 <clrnd> and Data.Foldable
07:30:40 <forgottenone> thanks
07:30:43 <_um> thanks, clrnd.
07:31:36 <merijn> _um: See monad-loops too
07:31:39 <merijn> @hackage monad-loops
07:31:39 <lambdabot> http://hackage.haskell.org/package/monad-loops
07:31:43 <athan> Are there any example functions with a type :: forall b. a -> b?
07:31:56 <merijn> athan: "undefined" and "const undefined"
07:32:01 <athan> :P
07:32:05 <merijn> athan: Not joking
07:32:07 <athan> thanks merijn
07:32:15 <merijn> athan: Other functions of that type can't exist
07:32:23 <athan> merijn: What is your favorite rankN function?
07:32:25 <athan> :s
07:32:40 <merijn> That one's not even rankN :>
07:32:47 <merijn> It's simply "a -> b"
07:33:01 <athan> crap
07:33:35 <athan> would `a -> (forall b. a -> b)` be rankN?
07:33:40 <athan> (rank 2)
07:35:43 <glguy> No
07:35:52 <athan> shoot
07:35:55 <nshepperd> no, but `(forall b. a -> b) -> a` would be
07:36:00 <athan> !
07:36:18 <athan> I need to reconsider arity quantification floating
07:36:20 <athan> thanks guys
07:36:22 <merijn> This is a simpler example
07:36:22 <glguy> Might require the extension due to the use of the keyword forall though
07:36:33 <merijn> "(forall a . [a] -> b) -> b"
07:37:11 <merijn> As that one can actually have a useful implementation :p
07:37:47 <athan> merijn: Thank you :)
07:37:52 <athan> Yall are awesome!!
07:39:03 <nshepperd> generally, "forall a. (X -> Y a)" ~ "X -> (forall a. Y a)"
07:39:37 <nshepperd> it's when you get foralls to the left of -> that things start getting ranky
07:39:56 <athan> nshepperd: That makes sense, it's like going against the grain :)
07:40:10 <JagaJaga> Trying to create `data Tree a = Node a | Leaf a`. How to write that a has to be (Ord a)?
07:40:33 <athan> JagaJaga: instance Ord a => Ord (Tree a) where...`
07:40:46 <nshepperd> uppity functions that demand polymorphic input
07:40:48 <athan> or would you rather have it encoded in the type?
07:40:51 <geekosaur> JagaJaga, use a GADT or put the constraint on uses, not the definition.
07:41:03 <fizbin> JagaJaga: You don't. You write that restriction into certain functions. (or you use a GADT)
07:41:16 <JagaJaga> geekosaur: fizbin: that's what I need. thx.
07:42:01 <geekosaur> basically, with a standard type, putting it on the type used to be possible but does not do what you actually want (it won't bring the constraint into scope, just check it when making a value, so it's kinda useless)
07:42:09 <geekosaur> GADTs can bring the constraint into scope
07:42:27 <merijn> geekosaur: That's still the wrong thing to do, though
07:42:41 <tdammers> yeah
07:42:43 <geekosaur> yeh
07:42:57 <tdammers> the constraint is only relevant to the function, really, not the data type
07:43:16 <JagaJaga> geekosaur: merijn: so GADTs are wrong to do?
07:43:30 <geekosaur> you can do it but again it doesn't quite mean what you intend
07:43:43 <geekosaur> it's closer but still not right
07:45:24 <JagaJaga> geekosaur: hm, but how can I write smth like `class SearchTree z where find :: z -> (type that is a value's type of z) -> Bool`?
07:45:41 <JagaJaga> so find :: Tree a -> a -> Bool?
07:46:42 <merijn> JagaJaga: GADTs are great and wonderful, but a typeclass constraint is the wrong thing for what you want
07:46:57 <merijn> JagaJaga: The solution is to write: "find :: Ord a => Tree a -> a -> Bool"
07:47:17 <athan> plus Tree would then be more applicable to other ideas :\
07:47:25 <JagaJaga> merijn: `Tree` can be different..
07:47:44 <merijn> JagaJaga: This is exactly what, for example, Set does
07:47:53 <JagaJaga> I think I'm saying some bullshit :/
07:48:00 <JagaJaga> merijn: gonna look
07:48:07 <merijn> JagaJaga: Perhaps you want "class SearchTree t where find :: Ord a => t a -> a -> Bool"?
07:48:10 <tdammers> Set does it, HashMap does it, etc.
07:48:37 <merijn> JagaJaga: i.e. "for any type that take's an 'a' argument, if that 'a' is Ord, THEN you can look it up in 't a'"
07:48:51 <JagaJaga> merijn: yeah!
07:49:18 <chrisdone> so, i'm thinking that a tool could generate a proof like this: https://github.com/chrisdone/descriptive/blob/master/src/Descriptive.hs#L130-149
07:49:19 <merijn> JagaJaga: And then you could do "instance SearchTree Tree where ..."
07:49:34 <merijn> JagaJaga: And find would have type "Ord a => Tree a -> a -> Bool"
07:49:49 <chrisdone> given id x = x, and cases whose alts all are id makes the whole case id
07:49:53 <merijn> chrisdone: Coq and keep hitting auto ;)
07:50:14 <chrisdone> i want a tool for haskell tho
07:50:49 <athan> chrisdone: Can I put lucid in Hamlet? :)
07:51:00 <_um> merijn: Thanks for the monad-loops tip! :)
07:51:09 <chrisdone> if i could write e.g. [prove|fmap id ≡ id|] and that'd check it at compile-time, that'd be awesome
07:51:27 <JagaJaga> merijn: yeah. got it. thx!
07:51:38 <chrisdone> athan: sure?
07:51:42 <athan> yay
07:51:47 <tdammers> unsafePerformCoq
07:51:49 <tdammers> :P
07:52:01 <chrisdone> tdammers: not a ridiculous idea
07:52:15 <chrisdone> although TH doesn't need unsafe it can just run any IO
07:52:19 <tdammers> yep
07:52:27 <athan> chrisdone: Doo eeettt
07:52:30 <chrisdone> one would need to convert the whole source to Coq or Agda or something
07:52:38 <tdammers> yeah, that part would be hard
07:52:47 <chrisdone> this example's trivial of course
07:53:01 <chrisdone> where i need help is fmap (f . g) = fmap f . fmap g https://github.com/chrisdone/descriptive/blob/master/src/Descriptive.hs#L151
07:53:11 <tdammers> OTOH, a simple quasiquoter that just takes Coq code, runs it, compiles to nothing if it passes or raises a compiler error if it doesn't, that should be possible
07:53:24 <chrisdone> i did it mechanically enough but it requires more sophisticated rules about collapsing things like nested cases and such
07:53:44 <chrisdone> sure
07:54:06 <merijn> chrisdone: In Haskell you don't need to prove "fmap (f . g) = fmap f . fmap g"
07:54:13 <merijn> chrisdone: It's a free theorem following from parametricity
07:54:22 <merijn> Proving "fmap id = id" is sufficient
07:54:27 <chrisdone> true
07:54:30 <athan> under substitution though, correct?
07:54:58 <merijn> athan: What do you mean?
07:55:18 <athan> merijn: I'm a noob, but idk if haskell would terminate
07:55:23 <shachaf> merijn: Assuming your type is a functor.
07:55:23 <athan> it just doesn't feel like it would
07:55:45 <athan> hrm
07:56:05 <merijn> shachaf: Is that important if "fmap id = id" holds?
07:56:27 <merijn> athan: If the fmap don't terminate than "fmap id = id" can't hold
07:56:50 <shachaf> Well, at least the proof that for foo :: (a -> b) -> F a -> F b, foo id = id implies that foo (f . g) = foo f . foo g uses the fact that F is a functor.
07:57:27 <shachaf> At least the proof that everyone always references when talking about this.
07:57:38 <shachaf> Since it uses a free theorem and all.
07:57:53 * athan goes to the corner
07:58:12 <shachaf> It might be true in general but I'd like to see why.
07:58:22 <chrisdone> in my case i proved that fmap id = id and then considered fmap (f . g) = fmap f . fmap g
07:58:52 <chrisdone> so is foo (f . g) = foo f . foo g is true for all foos?
07:59:15 <shachaf> I don't understand the question.
07:59:23 <shachaf> Which foos?
08:00:03 <merijn> shachaf: "foo id = id" follows from parametricity and the type of fmap
08:00:13 <merijn> shachaf: I don't think you need the fact that F is a functor
08:00:38 <merijn> eh, "fmap id = id", not foo
08:01:00 <shachaf> merijn: So now you're saying you don't need to prove any laws?
08:01:05 <shachaf> Life is getting better and better. :-)
08:01:16 <merijn> shachaf: No, I'm saying that you only need to prove "fmap id = id"
08:01:25 <merijn> The second law follows from that + parametricity
08:01:34 <shachaf> Assuming your type is a functor.
08:01:42 <merijn> Why would I need to assume that?
08:02:14 <shachaf> OK, what's your proof?
08:02:23 <shachaf> The usual proof I know assumes that F is a functor.
08:02:26 <merijn> Parametricity guarantees that *all* a's in F are being changed
08:02:33 <shachaf> If you have one that doesn't that's great.
08:02:41 <shachaf> (I've asked this question before.)
08:02:43 <merijn> The fact that "fmap id == id" guarantees that fmap can't modify the structure or hidden data
08:03:14 <shachaf> Your intuition seems to match mine here.
08:03:19 <merijn> If fmap can't change structure/modify hidden data and parametricity guarantees all 'a' elements are traversed, then "fmap f . fmap g = fmap (f.g)" is a trivial consequence
08:03:26 <shachaf> Trivial!
08:03:45 <merijn> shachaf: Don't you know that trivial describes anything that's proven? Ask Feynman ;)
08:03:57 <shachaf> OK, if it's proven, what's the proof?
08:04:53 <merijn> The only thing fmap can do is apply 'g' to all elements in our F (and nothing more and nothing less, because "fmap id = id")
08:05:20 <merijn> So if we know this then first applying 'g' to all elements and then applying 'f' to all elements is the same as applying 'f.g' to all elements
08:05:35 <merijn> I'm not sure what sort of elaboration you're looking for?
08:05:40 <shachaf> Here's the usual proof that I know:
08:06:06 <shachaf> Assume F is a functor, and we have some function foo :: (a -> b) -> F a -> F b, and we know that foo id = id
08:06:14 <shachaf> @free foo :: (a -> b) -> F a -> F b
08:06:14 <lambdabot> g . h = k . f => $map_F g . foo h = foo k . $map_F f
08:07:41 <merijn> I don't know how lambdabot's answer relates?
08:07:46 <chrisdone> the intuition makes sense but i'm not sure how it'd be encoded formally in e.g. a simple automated checker
08:08:03 <shachaf> merijn: It's a free theorem for foo, I'll use it in a moment.
08:08:51 <shachaf> Let f = id, so that k = g . h, and foo k = $map_F g . foo h
08:08:53 <chrisdone> it makes total sense that fmap id=id means that fmap id . fmap id = id
08:08:53 <merijn> chrisdone: Damn you, now you're tempting me to try and prove it in Coq while I need to finish this essay >.<
08:09:32 <chrisdone> (and therefore fmap f . fmap g = fmap (f . g) but… hum)
08:09:32 <merijn> chrisdone: I think it's more like "fmap f . fmap id = fmap f . id = fmap f"
08:09:34 <shachaf> I.e. foo (g . h) = $map_F g . foo h
08:09:51 <merijn> plus "fmap id . fmap g = id . fmap g = fmap g"
08:10:14 <merijn> Which are identical to "fmap (f.id)" and "fmap (id.g)" respectively
08:10:44 <shachaf> I'm figuring this out too slowly for this channel.
08:11:15 <shachaf> But feel free to prove it in Coq. You'll need a way to talk about parametricity.
08:11:44 <merijn> shachaf: Isn't that already part of Coq's type system?
08:12:08 <merijn> I'm suspicious, this seems so trivial to me so now I'm worried I'm missing something
08:12:17 <shachaf> Is it? I don't know much about Coq.
08:12:26 <chrisdone> shachaf: you wrote let f = id but where was f used? i'm missing something
08:12:29 <merijn> But I'm pretty sure I've had this discussion here before and one of the CT addicts said that it was enough
08:12:45 <shachaf> chrisdone: The free theorem is that for any f,g,h,k, that equation is true.
08:12:51 <shachaf> So I picked f=id
08:13:14 <shachaf> Here, just read roconnor's post on it: http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384
08:14:02 <chrisdone> merijn: in Data.Bifunctor it mentions parametricity as ensuring it http://hackage.haskell.org/package/bifunctors-4.2/docs/Data-Bifunctor.html
08:14:27 <chrisdone> shachaf: thanks
08:14:37 <merijn> shachaf: But the fact that 'f' is a functor is never used anywhere in the proof
08:14:48 <merijn> Other than to be able to use fmap
08:14:50 <shachaf> merijn: Sure it is, it assumes that $map_F exists.
08:14:58 <shachaf> And later proves that foo must be equal to it.
08:15:39 <shachaf> If your type isn't a Functor, but you can write foo :: (a -> b) -> F a -> F b such that foo id = id, that free theorem doesn't work at all.
08:15:42 <merijn> I'm not sure that's necessary, but I'm not confident enough to prove otherwise
08:15:45 <shachaf> (Is there such a type? I don't know.)
08:16:03 <merijn> shachaf: There can't be, unless you allow typecasing, afaik
08:17:24 <chrisdone> ohhh
08:17:30 <chrisdone> i considered:
08:17:32 <chrisdone> data F a = Fail | This a
08:17:32 <chrisdone> foo :: (a -> b) -> F a -> F b
08:17:32 <chrisdone> foo f _ = Fail
08:17:39 <chrisdone> which still satisfies the law
08:17:44 <chrisdone> riiiiiight
08:17:48 <merijn> chrisdone: No
08:17:59 <chrisdone> no?
08:18:03 <merijn> chrisdone: Because "foo id (This 1)" returns Fail
08:18:06 <merijn> Which is not id
08:18:22 <merijn> And our starting assumption was "foo id = id"
08:18:25 <chrisdone> ah, good point
08:18:41 <chrisdone> it *would* satisfy fmap (f . g) = fmap f . gmap g, but not fmap id = id
08:18:43 * hackagebot aivika 3.1 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-3.1 (DavidSorokin)
08:18:44 <chrisdone> ok
08:18:45 * hackagebot aivika-experiment 3.1 - Simulation experiments for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-3.1 (DavidSorokin)
08:18:47 * hackagebot aivika-experiment-chart 3.1 - Simulation experiments with charting for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-chart-3.1 (DavidSorokin)
08:18:49 * hackagebot aivika-experiment-diagrams 3.1 - Diagrams backend for the Aivika simulation library  http://hackage.haskell.org/package/aivika-experiment-diagrams-3.1 (DavidSorokin)
08:18:51 * hackagebot aivika-experiment-cairo 3.1 - Cairo backend for the Aivika simulation library  http://hackage.haskell.org/package/aivika-experiment-cairo-3.1 (DavidSorokin)
08:19:00 <shachaf> chrisdone: Sure, it's easy to write map _ _ = [] with the right type.
08:19:13 <chrisdone> right. intuitively it makes sense to me now
08:19:25 <merijn> chrisdone: This is why you still need "fmap id = id" to be a functor :)
08:19:30 <chrisdone> there's now way to use 'a' or 'b' to decide to return Fail or This, so it will be preserved
08:19:34 <merijn> You only get the 2nd law for free, not the first :)
08:19:36 <shachaf> The id requirement is quite strong.
08:19:43 <chrisdone> s/now/no
08:19:48 <merijn> chrisdone: Right
08:20:02 <merijn> Anyway, beer time :p
08:20:13 <chrisdone> enjoy
08:21:05 * chrisdone deletes his redundant proof
08:21:58 <NightRa> Is there a Map.modify function? (a -> a) -> k -> Map k a -> Map k a
08:22:49 <NightRa> Oh, hoogle solved it for me. It's Map.ajust
08:23:00 <NightRa> Err, Map.adjust
08:23:08 <shachaf> Thanks, Hoogle!
08:23:23 <NightRa> Is there a Hoogle bot on this channel?
08:23:43 * hackagebot lmdb 0.2.5 - Lightning MDB bindings  http://hackage.haskell.org/package/lmdb-0.2.5 (dmbarbour)
08:23:53 <shachaf> Yes, you can /msg lambdabot @hoogle ...
08:24:05 <shachaf> Best not to do it in-channel because it's pretty noisy.
08:24:49 <toblerone> Is there no way to statically enforce dimensions with HMatrix? I couldve sworn there was....
08:25:41 <toblerone> oh.
08:25:47 <toblerone> there is the static module
08:25:49 <alpounet> toblerone: there's a package for that. http://hackage.haskell.org/package/hmatrix-static
08:25:50 <toblerone> maybe thats it
08:25:54 <chrisdone> edwardk and reinh's idea to hoogle the whole of hackage's source types would be very neat to try
08:25:56 <toblerone> yeah
08:25:58 <alpounet> but i htink it's been merged into the main hmatrix package
08:26:03 <alpounet> yeah
08:26:05 <toblerone> yeah i see it now
08:26:06 <toblerone> thanks
08:26:31 <chrisdone> this is all the types in the `tagged` package http://lpaste.net/118617
08:26:50 <chrisdone> "lens" has considerably more
08:27:18 <chrisdone> http://chrisdone.com/lens.txt
08:27:20 <nshepperd> chrisdone: I thought that was supposed to be really slow, which is why hoogle doesn't do it. Or did they have an idea to speed it up?
08:27:40 <chrisdone> they have an idea to speed it up. i think trigram-related similar to google code search did
08:27:52 <chrisdone> http://swtch.com/~rsc/regexp/regexp4.html
08:28:03 <nshepperd> oh cool
08:28:04 <chrisdone> could probably extend that notion to type search?
08:28:31 <shachaf> Google Code Search is so good. :-(
08:33:27 * chrisdone goes to get beer too
08:33:39 <chrisdone> i'll try to prove my type is Applicative when i get back
08:50:09 <hiptobecubic> " so good :-( " ?
08:55:59 <chrisdone> maybe "was so good" [before they canned it]
08:56:57 <mmachenry> Peaches were so good before they canned them.
08:58:11 <hiptobecubic> But peaches come from a can
08:58:25 <mmachenry> Oh good point. Hrm.
08:59:34 <chrisdone> so a can can grow a peach but can a can can-can?
08:59:52 <hiptobecubic> Nope. Doesn't have any legs.
09:02:43 <mmachenry> Yeah you can't do the can-can without legs.
09:03:14 <mmachenry> So… who's writing Haskell today? :)
09:03:59 <chrisdone> meeee
09:04:03 <michi7x7> not me
09:04:23 <mmachenry> chrisdone: What are you writing?
09:04:52 <__jim__> chris, how often are you *not writing haskell?
09:04:54 <chrisdone> at the moment, just proving that my type is actually instances of the classes
09:05:15 <chrisdone> good question
09:05:48 <chrisdone> mmachenry: https://github.com/chrisdone/descriptive
09:06:10 <chrisdone> this package is supposed to abstract formlets, cmdarg libs, etc. into one generic interface
09:06:35 <chrisdone> as just "parsers which describe what they want"
09:07:21 <mmachenry> Interesting.
09:07:51 <chrisdone> turns out i'll have a use-case for the self-describing JSON parser at work, so that's nice
09:08:21 <sgronblo> Do you need GADTs for phantom types?
09:08:27 <chrisdone> nope
09:08:39 <chrisdone> data Proxy a = Proxy
09:08:56 <chrisdone> this is a so-called phantom type
09:09:47 * chrisdone -> afk
09:17:38 <athan> Is there a way to hide data constructors from what a module exports?
09:17:49 <athan> To make smart constructors a little more enforced?
09:17:55 <barrucadu> Just don't export them
09:18:09 <barrucadu> module Foo (list, of, things, exported) where ...
09:18:10 <athan> I should still need the type, though
09:18:20 <athan> hmm
09:18:21 <athan> okay
09:18:34 <barrucadu> If you have a type data Foo = ... and just export Foo, you only get the type
09:18:46 <barrucadu> If you export Foo(...) you also get the constructors
09:18:54 <barrucadu> * Foo(..)
09:19:08 <barrucadu> That's an actual .., not just a placeholder
09:19:50 <athan> Ahh wow okay, sorry. Thank you barrucadu
09:20:02 <sgronblo> how do i add a typeclass constraint to a type constructors parameter?
09:20:16 <glguy> sgronblo: You typically don't
09:20:34 <glguy> assuming you mean at the site of the type's definition
09:20:51 <sgronblo> im trying to fumble my way to generating an Int within a range for use with quickcheck
09:21:29 <glguy> sgronblo: Something like:   arbitrary :: Gen Int
09:21:29 <glguy> ?
09:21:50 <kadoban> sgronblo: Use a newtype and give it an Arbitrary instance that does what you want. There already exist ones for simple stuff, like positive, etc.
09:21:53 <sgronblo> Well won't Gen Int generate from Int's full range?
09:22:07 <sgronblo> kadoban: yeah something like this is what I'm aiming for
09:22:23 <sgronblo> kadoban: but the positive newtype has like the range hardcoded inside of it?
09:22:55 <kadoban> sgronblo: Afaik, yeah. You want it to be configurable?
09:22:55 <sgronblo> i would have to create something like newtype QuiteBigInt = QuiteBigInt Int
09:23:11 <sgronblo> kadoban: yeah i thought maybe there was some cool way that you could generalize it
09:23:31 <kadoban> Maybe there is, I'm not familiar with cute type tricks though so I wouldn't really know.
09:24:22 <sgronblo> in the same way you have to make something like newtype EvenlySizedList, instead of ListOfSizeDivisibleBy 2
09:24:33 <sgronblo> but maybe this is getting into dependent types territory?
09:24:54 <kadoban> I think so, yeah.
09:26:16 <koomi> you can use Test.QuickCheck.Gen.choose or (==>)
09:27:29 <kadoban> ==> might be iffy though, because then you'll generate the full range of Int, or whatever range it does by default, and bail out on any that aren't in your range. If your range is small, or not part of what Arbitrary Int does, it'll go poorly.
09:27:50 <kadoban> I think it eventually gets tired of trying failing ones and just moves on
09:27:55 <koomi> right, but choose is exactly what sgronblo wants
09:28:01 <kadoban> Yeah, sounds like it.
09:28:21 <sgronblo> havent figured out exactly how to work with choose yet
09:28:46 * hackagebot purescript 0.6.4 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.4 (PhilFreeman)
09:31:16 <koomi> do x <- choose (lowerBound, upperBound); stuff with x
09:31:32 <koomi> x is a random value between lowerBound and upperBound (inclusive)
09:32:28 <kadoban> koomi: That's in the Arbitrary instance though, right? I think his question is more about how to do it cutely at the type level so he doesn't have to hardcode the values, or something.
09:33:59 <breadmonster> I don't get something with Parsec.
09:34:10 <koomi> kadoban: choose has nothing to do with Arbitrary at all, and I don't understand what you're trying to say
09:34:23 <saep> newtype MyInt = MyInt Int ; instance Arbitrary int where arbitrary = MyInt <$> choose (13,37)
09:34:32 <breadmonster> I'm talking about type inference specifically.
09:34:43 <breadmonster> Why does Text.ParserCombinators.Parsec not throw the same errors as Text.Parsec?
09:34:53 <koomi> I don't see why one would want to create an Arbitrary instance for that anyways
09:34:55 <saep> \(MyInt x) -> somePropertyWith x
09:36:07 <kadoban> koomi: So you can easily use it in checks? For the same reason that Positive exists, and the rest. Meh, either way it's not problem to solve so I'll bow out.
09:37:20 <koomi> you can use any 'Gen a' easily in properties
09:37:30 <koomi> you don't need an Arbitrary instance for that
09:38:46 * hackagebot paypal-adaptive-hoops 0.5.2.0 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.5.2.0 (fanjam)
09:39:56 <koomi> breadmonster: you should not use Text.ParserCombinators.Parsec, it only exists for compatibility with older versions of parsec
09:40:24 <breadmonster> koomi: Text.Parsec is giving me weird errors that I don't know how to handle :(
09:40:44 <koomi> if you show us the errors, we might be able to help you
09:43:34 <kadoban> koomi: Ah, I didn't know you could use Gen stuff like that. I see now, I think.
09:47:30 <breadmonster> koomi: GHC has issues inferring the stream type.
09:49:04 <_2_lilog> hi
09:49:24 <breadmonster> koomi: And I don't know how to fix that error.
09:49:34 <koomi> breadmonster: what stream do you want to parse? Text, String, ByteString, something else?
09:50:40 <breadmonster> koomi: Umm, string.
09:51:10 <kadoban> In the stackage config files you download, it says "Please place this file next to your .cabal file as cabal.config" What does that actually mean? Are they talking about place it in the same directory as the .cabal directory itself is in?
09:51:31 <kadoban> I feel like there should be more docs somewhere, all I can find is the quickstart that doesn't explain a lot.
09:51:35 <_2_lilog> can you send me a pic of you I will do the same
09:52:03 <_2_lilog> See this image: http://imagizer.imageshack.com/img673/2577/8G31uJ.jpg
09:52:52 <koomi> @where ops
09:52:53 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
09:53:39 <koomi> breadmonster: you can use Text.Parsec.String, if you want to receive more specific help you have to show us your code (lpaste.net)
09:53:47 * hackagebot dag 0.1 - Compile-time, type-safe directed acyclic graphs.  http://hackage.haskell.org/package/dag-0.1 (athanclark)
09:54:05 <breadmonster> Okay, cool, one second.
09:54:34 <_2_lilog> thanks many apoligies
09:55:02 --- mode: ChanServ set +o geekosaur
09:55:47 <funfunctor> if I do a liftIO on some malloc :: IO (Ptr (Ptr BlaBal)) is there any way the liftIO could be scewing up the pointer?
09:56:11 <geekosaur> funfunctor, no
09:56:19 <funfunctor> thx
09:56:28 --- mode: geekosaur set -o geekosaur
09:56:30 <funfunctor> wonder what the hell is going on then..
09:56:49 <athan> blast, I forgot to update the head of the cabal file ><
09:57:18 <kadoban> Oh I see, those instructions are only for per-cabal-project usage, not global.
09:58:48 * hackagebot dag 0.1.0.1 - Compile-time, type-safe directed acyclic graphs.  http://hackage.haskell.org/package/dag-0.1.0.1 (athanclark)
10:01:16 <arduinoQ> can anyone help me understand using IO functions within other IO functions. It seems as if I can't call a function which returns *IO String* from a function which returns *IO ()*
10:01:20 <topi> hey, wha
10:01:26 <topi> ups..
10:01:41 <arduinoQ> http://lpaste.net/119076 the errors are on lines 45 and 46
10:02:12 <EvanR> you can use a function returning IO anywhere, but it doesnt necessarily execute any action
10:02:15 <clrnd> godamnit I can NEVER remember how to make a link in markdown
10:02:21 <fatlazycat> hi is there a nix haskellng package for cabal 1.20.x ? am working off a lcoal repo - not sure how I would search for it - thanks
10:02:30 <chrisdone> clrnd: [foo](bar)
10:02:31 <funfunctor> geekosaur: so line 56 should not have changed things just because I lifted? http://pastebin.com/bH5QgEu4
10:02:40 <chrisdone> clrnd: the link goes in the parentheses
10:02:44 <clrnd> chrisdone, or is it (foo)[bar] ! thanks
10:02:58 <kadoban> arduinoQ: What's the errors?
10:03:04 <EvanR> arduinoQ: remember evaluation of function application is lazy, so its good evaluation doesnt cause execution of side effects
10:03:13 <raek> arduinoQ: what is the type of initializeLight?
10:03:22 <chrisdone> clrnd: as a mnemonic, think of the parens like normal english parens: wikipedia (http://wikipedia.org/)
10:03:47 <clrnd> chrisdone, oh that could actually work
10:03:48 <arduinoQ> raek: I just updated the lpaste
10:04:10 <arduinoQ> Couldn't match type `IO' with `Arduino'  --- Expected type: Arduino Light --- Actual type: IO Light
10:04:11 <geekosaur> it looks like it should be fine. I would wonder about other things, notably what happens after openBladeRF returns / when is it freed?
10:05:01 <arduinoQ> raek: the return type is IO Light, it's returning a data structure called Light, which has an MVar String in it
10:05:11 <kadoban> arduinoQ: Oh. The problem is that you're not actually in a IO (). withArduino takes an Arduino () which is the context you're in.
10:05:19 <funfunctor> geekosaur: well i'm aware of that leak yes
10:05:51 <funfunctor> geekosaur: i'm sort of just ignore it at the moment.. I want the code to start 'working' again after I shuffled around getting this monadic structuring in
10:07:04 <arduinoQ> kadoban: so code in withArduino has an Arduino () context, and withArduino itself is in the IO () context of main, correct?
10:07:17 <raek> arduinoQ: it seems like initializeLight has the type IO Light, but your main definition tries to use it as if it were an Arduino Light
10:07:23 <geekosaur> actually I am wondering if Ptr (Ptr C'bladerf) is what you want there
10:07:35 <kadoban> arduinoQ: Yes. Essentially you're building up an Arduino () in do notation there, so it has different meaning than if you were directly in IO ()
10:07:51 <EvanR> rather than thinking about it as code running in a context, you can think of it returning a value of a certain type, and reason about it that way. thats more generally applicable
10:07:57 <geekosaur> typically if that's to be filled in then you want to allocate a Ptr C'bladerf and then pass a pointer to that
10:08:06 <geekosaur> not allocate a pointer to pointer to thing
10:08:11 <raek> arduinoQ: what is the definition of initializeLight?
10:08:16 <funfunctor> geekosaur: in the malloc? yes that was all working before
10:08:18 <geekosaur> but I am not familiar with the API, so...
10:08:48 * hackagebot inflections 0.1.0.9 - Inflections library for Haskell  http://hackage.haskell.org/package/inflections-0.1.0.9 (jsl)
10:08:50 <funfunctor> geekosaur: C API expects a double dereference
10:08:50 * hackagebot handsy 0.0.2 - A DSL to describe common shell operations and interpeters for running them locally and remotely.  http://hackage.haskell.org/package/handsy-0.0.2 (utdemir)
10:09:08 <arduinoQ> raek: it's on lines 35-38, it just returns an data structure called Light, initializeLight :: IO Light
10:09:42 <raek> arduinoQ: ah. ok. the problem is that you are not allow to mix IO and Arduino as if they are the same types
10:09:57 <raek> the do block in main is of type Arduino ()
10:09:57 <arduinoQ> kadoban: since I'm in Arduino (), would I then have to modify the light data structure to work within it?
10:10:16 <funfunctor> geekosaur: the c'bladerf_open api expects to be passed bladerf_t ** and functions make use of bladerf_t *
10:10:23 <arduinoQ> raek: so, all the stuff in withArduino must be Arduino *something*?
10:10:39 <EvanR> arduinoQ: its good to understand how the do notation works, as far as the types matching up goes
10:10:39 <raek> arduinoQ: you cannot use any IO features from Arduino, unless the Arduino library explicitly provies it for you (with an Arduino type)
10:10:44 <raek> arduinoQ: exactly
10:10:53 <geekosaur> funfunctor, yes, that sounds like an api where a bladerf_t * is a return type
10:11:03 <raek> arduinoQ: that's what the type of 'withArduino' says
10:11:06 <EvanR> arduinoQ: do notation lines get desugared to >>= and >>
10:11:10 <jtanguy> Arduino is an instance of MonadIO though
10:11:11 <geekosaur> so you allocate a (bladerf_t *) and pass a pointer to it
10:11:14 <EvanR> :t (>>=)
10:11:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:11:25 <geekosaur> and it just happened to work before because C pointers are weird
10:11:34 <raek> withArduino :: Bool -> FilePath -> Arduino () -> IO ()
10:11:49 <funfunctor> geekosaur: how can I get a pointer from a pointer in haskell?
10:11:59 <raek> given a book, a filepath and an arduino action, it gives you back an IO action
10:12:13 <arduinoQ> raek: awesome, progress in understanding.
10:12:29 <athan> topi :)
10:12:36 <kadoban> arduinoQ: I don't know exactly the best way to fix what you're trying to do…here's my untested guess at a fix (I don't have that package or and arduino or understand the code):
10:12:46 <raek> compound actions can be made using (>>=) and the like directly, or using do notation (syntactic sugar)
10:12:58 <kadoban> arduinoQ: http://lpaste.net/119076  (take with huge grain of salt)
10:12:59 <arduinoQ> raek: I see, that's why it can fit in main. that also makes what kadoban said about *building up an Arduino ()*
10:13:02 <funfunctor> geekosaur: so if I do dev <- liftIO (malloc :: IO (Ptr C'bladerf)) how do I then get a pointer of dev to pass?
10:13:12 <raek> yes
10:13:13 <ij> Can anyone give me any intuition on what an ArrowPlus instance might be like and what might <+> do?
10:14:07 <kadoban> Actually…that's unlikely to help, probably disregard.
10:14:08 <raek> arduinoQ: I suspect that "Arduino a" values represent code that gets compiled to an arduino sketch that later gets run
10:14:29 <raek> you can't use host language MVars in your arduino program since they run on different computes
10:14:32 <geekosaur> funfunctor, I'm thinking about that... I think the real issue is you need to allocate twice, maybe, since Haskell doesn't do pointers the C way
10:14:56 <arduinoQ> kadoban: thanks kadoban, I'll try that and see if I can update the mvar in the forever loop
10:14:57 <raek> this is a confusing aspect of embedded domain specific languages like this one
10:15:07 <jtanguy> if this comes from the package hArduino, it is not
10:15:11 <kadoban> arduinoQ: You won't be able to, unfortunately. It's not the right way to fix :-/
10:15:19 <raek> ok
10:15:19 <geekosaur> right now you allocate a pointer to a place for a C'bladerf to go, but don't allocate the place for the C'bladerf itself to go
10:15:36 <arduinoQ> raek: I don't think that harduino compiles down to a sketch, but rather communicates over specialized arduino firmware
10:15:39 <geekosaur> in C you allocate the latter and then pass it with &
10:15:42 <topi> athan: heeh, using irssi from a remote server causes some lag and sometimes I have to clear the screen and accidentally post nonsense
10:15:50 <geekosaur> (producing a thing that is a ** instead of a *)
10:16:03 <jtanguy> in hArduino: newtype Arduino a = Arduino (StateT ArduinoState IO a)
10:16:05 <athan> :P
10:16:09 <geekosaur> I am not quite sure how you do that here
10:16:14 <arduinoQ> kadoban: ok, then maybe I have to make my IO Light into an Arduino Light
10:16:17 <raek> arduinoQ: ah, I see!
10:16:31 <kadoban> arduinoQ: I think you have to use…liftIO if you want to do IO actions inside of an Arundio
10:16:54 <arduinoQ> kadoban: even thought it's not the right way to fix it, I got a better understanding of working within monads, so that's good
10:17:15 <geekosaur> (aaaaand I am going to be on a concall shortly.)
10:17:28 <arduinoQ> raek: you first load the firmware using the arduino IDE, then work with harduino once it's loaded
10:17:58 <kadoban> arduinoQ: Alrighty, glad I helped a bit then. I think what you want to do is use liftIO which is of type :: IO a -> m a   -- Where here m is Arundio, if that makes sense?
10:18:00 <raek> ok. so it controlls the arduino using the serial port and the firmata protocol
10:18:03 <arduinoQ> I'll look into making IO Light into Arduino Light, that sounds like the path that I have to take
10:18:35 <arduinoQ> kadoban: I'll look into using liftIO, this is new territory for me, so I really dont know what the best approach is
10:18:40 <geekosaur> arduinoQ, you were just told how to do it
10:19:07 <funfunctor> geekosaur: I thought peek dev was giving me one indirection back
10:19:18 <raek> does hArduino provide liftIO?
10:19:18 <jtanguy> arduinoQ: (liftIO initializeLight) :: Arduino Light
10:19:24 <geekosaur> yes, it's just the wrong one
10:19:43 <raek> ah, it is an instance of MonadIO
10:19:48 <kadoban> Yeah
10:20:08 <arduinoQ> geekosaur: I know two approaches, but I don't know the implications of either. I'll find out soon enough ;)
10:20:22 <raek> ok, so then it allows you to mix IO and Arduino actions then.
10:20:35 <geekosaur> liftIO is the right one here, it reaches into the Arduino and finds the IO, and passes the IO action to that
10:20:39 <geekosaur> which is what you want
10:20:46 <raek> arduinoQ: in this case, you can think of liftIO to have the type IO a -> Arduino a
10:20:52 * geekosaur goes to prepare for concall
10:21:18 <arduinoQ> geekosaur: awesome, I'll look into that then.
10:22:01 <athan> I am bad at proof-reading :c
10:22:24 <funfunctor> arduinoQ: if you are doing hw type stuff you may like to look at my bladerf binding I am currently working on
10:22:35 <funfunctor> arduinoQ: probably similar problems..
10:22:49 <arduinoQ> thanks raek, kadoban and geekosaur for the help. I'll hack away at this this weekend. I have to go pick someone up now.
10:23:49 * hackagebot dag 0.1.0.2 - Compile-time, type-safe directed acyclic graphs.  http://hackage.haskell.org/package/dag-0.1.0.2 (athanclark)
10:23:58 <kadoban> arduinoQ: Good luck :)
10:24:44 <arduinoQ> funfunctor: thanks for the suggestion, I'll look into it
10:26:40 <funfunctor> geekosaur: well C'bladerf size can not be known for malloc since there is no No instance for (Storable C'bladerf) arising from a use of ‘malloc’
10:27:17 <funfunctor> since that is just defined as struct bladerf; in the header with no further detail
10:27:28 <funfunctor> it may as well be void **
10:33:17 <mathu> in ghci: `let a x = x*x; let b x = a x; let a x = x + x;' b 4 returns 16, instead of 8. is a's definition inserted into b when b is defined? (each statement is on its own line in ghci)
10:34:09 <chrisdone> subsequent definitions don't update old definitions using things of the same name
10:34:10 <geekosaur> mathu: yes
10:34:24 <mathu> figured. bummer. i can understand why it's so though
10:34:43 <mathu> thanks!
10:41:10 <clrnd> anything like https://github.com/jakubroztocil/httpie in haskell?
10:42:01 <funfunctor> geekosaur: loooool !!! it was udev permission problems not pointers
10:42:05 <funfunctor> far out!
10:47:40 <ReinH> chrisdone: The idea is actually to do regexp search on all of hackage source. I have a proof of concept.
10:47:43 <funfunctor> great, works now! that only took all bloody night :p
10:47:58 <bergey`> clrnd: http://www.serpentine.com/wreq/ cites python's Requests library as inspiration.  I'm not aware of a wget / curl tool written in Haskell.
10:48:08 <clrnd> thanks bergey`
10:48:26 <chrisdone> ReinH: ah, so it's an orthogonal search
10:48:26 <johnw> ReinH:
10:48:27 <clrnd> oh lol I;ve used wreq, it's pretty good
10:48:40 <clrnd> but I wanted a complete tool
10:48:45 <chrisdone> ReinH: grepping hackage sources is cool too
10:52:15 <johnw> chrisdone: even though I have a mirror of all the hackage sources, I never thought to setup a convenient way to grep through them!
10:55:36 <ReinH> johnw:
10:55:56 <ReinH> It's large enough that a brute force grep is a bit slow, so I use a clever indexing strategy.
10:56:17 <ReinH> Which tbqh I stole from google's codesearch
10:56:48 <ReinH> clrnd: complete tool for what? Sorry, I don't have enough scrollback.
10:57:10 <clrnd> ReinH, like https://github.com/jakubroztocil/httpie
10:57:25 <clrnd> a curl-like cli http tool
10:57:35 <ReinH> clrnd: Ah, yeah, that's a nice library. Nothing like that in Haskell as far as I'm aware. Maybe you could write one!
10:57:49 <ReinH> wreq would be a good choice to write it
10:58:01 <clrnd> ReinH, maybe I will! I could use wreq, which is pretty nice
10:58:11 <hodapp> Does one generally not use a catch-all case when pattern-matching, if the only purpose it would have would be to throw an error?
10:58:12 <clrnd> yeah
10:58:14 <ReinH> clrnd: would be a fun way to dig into wreq and cli stuff
10:58:37 <ReinH> hodapp: One generally tries to avoid partial functions with incomplete pattern matches. :)
10:58:55 <clrnd> ReinH, I'd probably reuse a lib I did for a CLI rest-client, the fun part would be the output formatting
10:59:28 <clrnd> I can never decide between boxes and wadler's pprint
11:00:01 <hodapp> ReinH: Well, I'm matching over the N constructors of an ADT, and if for whatever reason it comes to have N + 1 constructors, the only thing it can do is fail
11:00:28 <hodapp> should one try to pass in the new value it's not able to match
11:00:32 <ReinH> hodapp: Right. In that case, you might prefer to use Maybe.
11:00:48 <ReinH> partial functions cause runtime errors so we try to avoid them when possible
11:00:56 <hodapp> ReinH: The only purpose Maybe would have would be so that a Nothing downstream would throw an error.
11:01:04 <ReinH> hodapp: Yes, exactly.
11:01:10 <hodapp> ReinH: and so I'm not seeing what that gets me.
11:01:23 <ReinH> The ability to handle errors in a typesafe way is always better than a runtime pattern match failure.
11:01:26 <clrnd> modularity maybe, you can build on top of a Maybe a
11:01:37 <clrnd> not in top of an error "lol"
11:01:43 <clrnd> > error "cuack"
11:01:45 <lambdabot>  *Exception: cuack
11:01:57 <hodapp> clrnd: this is an instance where it *should* cause an error, though.
11:02:03 <ReinH> If you later decide you want better error handling, you will be stuck if you have a partial funciton.
11:02:16 <ReinH> hodapp: But you presumably want some control over how that error is handled, reported, logged, etc.
11:02:20 <clrnd> exactly
11:02:25 <hodapp> ReinH: Not really.
11:02:28 <ReinH> Alright then.
11:02:45 <ReinH> Just keep in mind that if you ever change your mind, you will have to rewrite everything to support your new decision.
11:03:06 <hodapp> well, if I change my mind, I'd already have to have rewritten the rest of near everything.
11:03:30 <ReinH> Since you asked what is *generally* done, I am telling you what is generally done. If you want to do something else instead, then go for it.
11:03:50 * hackagebot configuration-tools 0.2.8 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.2.8 (larsk)
11:04:22 <hodapp> it just looks to me like it would overcomplicate everything else to try to route the errors differently.
11:04:22 <ReinH> Sometimes it's better to learn things through experience.
11:04:44 <ReinH> Ok.
11:05:12 <ReinH> No point arguing about it if you've made up your mind.
11:06:01 <ReinH> johnw: The codesearch tool uses a trigram index and transforms regexp into queries against that index in an algebraic sort of way. It's pretty cool.
11:06:21 <ReinH> I'm not quite sure what sort of algebra I have though. Maybe a Heyting Algebra.
11:06:22 <hodapp> It's for code generation, invoking packages that all produce runtime errors for certain instances that can't be resolved within the types.
11:07:39 <ReinH> johnw: It has to be restricted to non-extended regexp (i.e., the actually regular bits) but that's still good enough for most use cases for searching a huge corpus.
11:07:48 <hodapp> so as-is, the software either (1) runs and quits immediately with success or (2) runs and quits immediately with failure.
11:07:58 <ReinH> hodapp: Ok.
11:08:21 <clrnd> so it's like a unix tool
11:08:25 <hodapp> clrnd: Yes.
11:08:29 <clrnd> :P
11:08:37 <clrnd> but can it pipe?
11:08:37 <ReinH> I suppose a descriptive `error' would be more helpul than a pattern match failure, but I would definitely use Maybe or Either or some other typesafe way of handling the exceptions.
11:08:43 <ReinH> s/exceptions/errors
11:09:04 <clrnd> I use haskell for scripting and 80% of times I just pattern match fail, but hey we have deadlines ...
11:09:12 <hodapp> clrnd: do you use Shelly?
11:09:14 <clrnd> (scripting in the sense of `bash`)
11:09:18 <hodapp> a tool I just discovered and wondered at the existence of
11:09:24 <akegalj> when to use stackage and when hackage repos?
11:09:29 <clrnd> no, but I've looked at it
11:09:55 <SrPx> Hello. is there any type on hackage that works like Tree, except that 1. there are no tags, 2. child nodes are stored in an arbitrary container that could be a mutable vector, 3. leaf hold data. Something like: `data Tree f a = Node (f (Tree a)) | Leaf a
11:11:02 <SrPx> Tree f a  *
11:11:10 <raek> isn't that the type signature of the free monad?
11:11:29 <raek> data Free f a = Pure a | Roll (f (Free f a))
11:12:18 <SrPx> interesting, no idea what is that, though... hmm
11:12:22 <SrPx> let me see
11:12:23 <clrnd> hilarious
11:12:32 <hodapp> ReinH: I seem to use the pattern in various places that I have N constructors and N pattern match cases (over all constructors), so perhaps there is a better way to handle that anyhow.
11:12:52 <hodapp> clrnd: why script in Haskell?
11:13:11 <funfunctor> this is maybe a silly question but how do you stop throwE from prefixing my error message string with "Left" ?
11:13:24 <clrnd> hodapp, I meant we have lots of little unix-like tools written haskell
11:13:27 <ReinH> hodapp: Shelly is pretty cool. Greg (the author) is super smart as well.
11:13:32 <hodapp> clrnd: ohhh!
11:13:38 <hodapp> ReinH: he made Hoogle, didn't he?
11:13:42 <clrnd> for example we needed something that made up SQL queries in a specific parallel pattern
11:13:49 <ReinH> funfunctor: I don't think it does. I think it constructs your error with the Left constructor, which you then print.
11:14:20 <hodapp> ReinH: It seems odd to me to do scripting in Haskell... but I've also tried to do Haskell stuff in scripting languages too, and I'd expect that it's considerably sillier and uglier.
11:14:20 <ReinH> hodapp: No, that's Neil Mitchell iirc.
11:14:25 <clrnd> or something that could stream coordinates for some GeoJSON
11:14:38 <raek> SrPx: https://hackage.haskell.org/package/free
11:14:38 <ReinH> hodapp: Well, I work with Greg and I do a fair amount of scripting in Haskell... although I don't use Shelly.
11:14:42 <RchrdB> Yeah, Google is Neil Mitchell.
11:14:45 <RchrdB> *Hoogle.
11:14:47 <raek> "If f is a Functor then the free Monad on f is the type of trees whose nodes are labeled with the constructors of f."
11:14:50 <halvorg> a
11:14:50 <RchrdB> Google is a LOT more people. :)
11:14:51 <clrnd> larry page
11:14:58 <hodapp> clrnd: this is doing code generation as part of a Makefile, probably a Shakefile at some point.
11:15:04 <ReinH> I generally port things from bash to Haskell once they reach a certain level of complexity and I start dreading maintaining them
11:15:23 <funfunctor> ReinH: well I am doing     BladeRF $ catchE (unBladeRF open)      (\e -> throwE e)
11:15:42 <clrnd> hodapp, yeah I think ReinH is absolutely correct, teoretically, but practical matters call for simpler methods :P
11:15:58 <SrPx> ReinH: thanks, I'm trying to wrap my head around that (wtf)
11:16:04 <ReinH> hodapp: Can you make your code generation use regexp somehow so that you have O(n^2) problems?
11:16:10 <clrnd> jajajaja
11:16:18 <funfunctor> ReinH: should the custom error data derive show perhaps?
11:16:26 <hodapp> ReinH: I'm pretty sure I'm converting from some Python code generation that does pretty much that.
11:16:39 <ReinH> hodapp: hahaha
11:16:39 <raek> SrPx: I just read about free monads recently, so that's why I recognized the signature. I don't know enought to explain anything though :-)
11:17:02 <funfunctor> oh what am I talking about, ignore that point
11:17:06 <nomeata> Hi. What’s the cool way to implement Maybe (a,b) -> (Maybe a, Maybe b)?
11:17:16 <ReinH> SrPx: Still working on that octree stuff? One of the comments suggested that the "tree parameterized by shape" was a free monad over the choice of shape functor btw,.
11:17:20 <nomeata> @type (\m -> (fmap fst m, fmap snd m))
11:17:21 <lambdabot> Functor f => f (a, b) -> (f a, f b)
11:17:23 <ReinH> Which is a really cool way of looking at it
11:17:31 <SrPx> raek: it sounds like you really nailed it. Sounds.
11:17:37 <ReinH> e.g. for data Bin a = Bin a a, Free Bin is a binary tree
11:17:52 <geekosaur> @pl \m -> (fmap fst m, fmap snd m)
11:17:52 <lambdabot> ap ((,) . fmap fst) (fmap snd)
11:17:55 <geekosaur> bah
11:18:02 <geekosaur> expected something arrowy
11:18:06 <ReinH> so for data Oct a = Oct a a a a a a a a, Free Oct is a octree. Pretty cool.
11:18:06 <SrPx> ReinH: yea... which comments? On Reddit?
11:18:10 <johnw> @djinn [a] -> a
11:18:11 <lambdabot> Error: Undefined type []
11:18:13 <ReinH> SrPx: yeah, on one of your reddit posts.
11:18:20 <johnw> @djinn Maybe a -> a
11:18:20 <lambdabot> -- f cannot be realized.
11:18:51 * hackagebot diversity 0.3.5.0 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.3.5.0 (GregorySchwartz)
11:19:05 <SrPx> ReinH: if I read that I probably thought "okay this is way over what I can understand right now"... I was exploring other solutions (they said many things). It is starting to make sense now, though.
11:19:10 <funfunctor> https://hackage.haskell.org/package/transformers-0.4.1.0/docs/src/Control-Monad-Trans-Except.html#throwE
11:19:24 <trap_exit> how do I _implement_ type cehcking in haskell?
11:19:43 <funfunctor> yea so for whatever reason, when I created a show instance it started prefixing my error message with Left
11:19:50 <johnw> trap_exit: have you read TAPL?  it takes about writing a type checker for the simply typed lambda calculus, for example
11:20:12 <johnw> which would be a first step towards full Hindley-Milner
11:20:16 <hodapp> trap_exit: why >_>
11:20:27 <trap_exit> johnw: hmm, unfortunately no
11:20:32 <trap_exit> the same guy wrote a coq bok I think
11:20:33 <trap_exit> which was lots of fun
11:21:00 <trap_exit> johnw: http://dev.stephendiehl.com/fun/006_hindley_milner.html <-- isn't this what I want?
11:21:35 <chrisdone> ReinH: johnw: did you see this? http://chrisdone.com/lens.txt =p
11:23:25 <ReinH> chrisdone: I haven't. What do?
11:23:27 <clrnd> chrisdone, WOW
11:23:48 <hiptobecubic> Molten Magma?
11:23:48 <chrisdone> ReinH: spits out the types of all source expressions in all of the lens package
11:23:50 <monochrom> TaPL also has a chapter on type inference
11:24:08 <ReinH> chrisdone: Ah. So that's why that file is longer than Moby Dick.
11:24:09 <hiptobecubic> src/Control/Lens/Tuple.hs:(93,10)-(93,58): Lens ((:*:) f g p) ((:*:) f' g p) (f p) (f' p) -> Field1 ((:*:) f g p) ((:*:) f' g p) (f p) (f' p)
11:24:24 <chrisdone> ReinH: this one is simpler http://lpaste.net/118617 (for tagged)
11:24:27 <ReinH> chrisdone: Also that'll be very useful for my lens type markov chain bot.
11:24:45 <hodapp> oh gawd, another Markov bot.
11:24:58 <chrisdone> Let's someone make a markov bot of markov bots
11:25:36 <funfunctor> dude!!! Don't let C programmers tell you that you can't do a double free in haskell if you really really want to..
11:25:41 <hodapp> chrisdone: how do we know it hasn't been done, and that bot is YOU?
11:25:49 <hiptobecubic> Market?
11:25:50 * chrisdone glances around nervously
11:26:10 <EvanR> dont double free
11:26:16 <hodapp> funfunctor: what?
11:26:26 <ReinH> chrisdone: You've seen my ncatlab markov bot?
11:26:31 <chrisdone> unsafePerformDoubleFree
11:26:31 <ReinH> It's remarkably effective.
11:26:40 <chrisdone> ReinH: i saw the Twitter one =)
11:26:43 <ReinH> chrisdone: yeah that
11:27:15 <funfunctor> hodapp: writing a C binding for hw in haskell
11:27:18 <chrisdone> you could markov chain generate lens types and then use djinn to generate implementations
11:27:19 <ReinH> There's a new free theorem account that doesn't *appear* to be a markov bot but who knows really
11:27:23 <chrisdone> then pipe it all to a package
11:27:27 <chrisdone> release for great profit
11:27:28 <ReinH> chrisdone: Yes that's exactly what I'm saying ;)
11:28:00 <bennofs> acme-lens :O
11:28:02 <ReinH> chrisdone: On a vaguely related note, Richard Bird's new book implements an equational reasoning proof generator. It's pretty cool.
11:28:15 <chrisdone> ooooooooooooooo
11:28:22 <chrisdone> do want
11:28:32 <monochrom> hahaha Markov-chain-generate lens types
11:28:36 <edwardk> chrisdone: it has been done: http://cokmett.github.io/cokmett/
11:28:45 <ReinH> edwardk: damn you.
11:28:55 <monochrom> who is cokmett?!
11:29:16 <edwardk> monochrom: no idea. someone sent me a link to the account a year or so
11:29:29 <chrisdone> that's so last year =p
11:29:33 <monochrom> I guess he's an evil twin
11:30:09 <shachaf> EvilKmett has been renamed to KmettT
11:30:32 <chrisdone> ReinH: i just mechanically made this by hand i just manually generated this (with intentionally dumb transformations, such that a program could make them) https://github.com/chrisdone/descriptive/commit/70c6e4ddff9e51078558120517311fe7cd375e22
11:30:32 <chrisdone> ReinH: is there a program that can make those kind of steps for me in haskell? =)
11:31:25 <zennist> I'm reading Learn You a Haskell; and there's this section on how defining foldMap automatically gives you foldl and foldr
11:31:32 <zennist> anyone can share any light on how this is possible?
11:31:34 <chrisdone> i feel like i could do what neil mitchell does for hlint and state some basic rules of transformation
11:31:50 <zennist> I mean, why is it possible?
11:32:06 <geekosaur> zennist, this is kinda the problem with LYAH
11:32:07 <EvanR> yeah its pretty trippy
11:32:31 <zennist> geekosaur: to be more exact?
11:32:42 <edwardk> zennist: do you know Endo?
11:32:47 <geekosaur> it shows you without helping you to understand
11:33:00 <geekosaur> so you come out of it with a lot of syntax and no real *understandng*
11:33:06 <mmachenry> zennist: What page please?
11:33:20 <ReinH> chrisdone: Wait, what am I looking at?
11:33:21 <zennist> geekosaur: ...I thought this is the recommended material for beginners..
11:33:25 <geekosaur> it used to be
11:33:28 <geekosaur> it's not any more
11:33:32 <edwardk> we can make a Monoid     newtype Endo a = Endo { appEndo :: a -> a } -- instance Monoid (Endo a) where mempty = Endo id; mappend is based on (.)
11:33:37 <ReinH> chrisdone: The Bird thing has some limitations. It requires everything to be written in a point-free form, for example.
11:33:41 <zennist> mmachenry: 214
11:33:45 <chrisdone> ReinH: proof of identity for the Consumer type
11:33:52 * hackagebot lucid-svg 0.2.0.1 - DSL for SVG using lucid for HTML  http://hackage.haskell.org/package/lucid-svg-0.2.0.1 (jeffreyrosenbluth)
11:33:57 <ReinH> chrisdone: what sort of proof though?
11:34:28 <chrisdone> ReinH: just equational, step-by-step substitutions until pure id v = v
11:34:38 <zennist> geekosaur: so which one is the trend now?
11:34:50 <mmachenry> zennist: What passage? My page 214 is about writing an optimal path function
11:35:19 <zennist> mmachenry: all right, maybe our versions are different; it's at the end of chapter 11
11:35:25 <chrisdone> ReinH: er, sorry, until pure id <*> v = v
11:35:27 <zennist> with chapter 11 on monoid
11:35:27 <ReinH> chrisdone: I guess I don't understand the proof structure.
11:35:36 <ReinH> I don't know how you use Haskell to prove such things.
11:35:46 <geekosaur> zennist: Jan 23 00:17:57 <kadoban>	lachenmayer: https://github.com/bitemyapp/learnhaskell has some great resources. cis194 http://www.seas.upenn.edu/%7Ecis194/spring13/index.html is a great start to haskell, and there's homework/exercises, and then there's: https://github.com/NICTA/course/
11:36:10 * geekosaur sighs, that pinged two people who probably don't care about this convo because c&p from logs >.>
11:36:13 <ReinH> zennist: If you like books, I recommend Richard Bird's new one.
11:36:19 <kadoban> Heh, no worries
11:36:20 <mmachenry> zennist: What's the subsection? My page numbers are different.
11:36:41 <ReinH> zennist: Anyway, you should listen to edwardk. It's pretty interesting.
11:36:48 <zennist> mmachenry: the last section of chapter 11 teaches you how to implement Foldable for Tree
11:37:53 <chrisdone> ReinH: well just "applicative_identity v = (pure id <*> v) ≡ v" for some v, i copy this decl and then expand pure into its implementation, then i copy it and expand something else until eventually the decl is expanded and reduced into v ≡ v. i don't have a tool to validate that my expansion is correct, but as a human i'm now convinced it satisfies this law
11:38:47 <chrisdone> ReinH: but yeah, i would like a tool that generates both the expansions and the reductions for me
11:38:59 <mmachenry> zennist: What's the exact quote you're confused about? I can use that to do a search on the web version.
11:39:00 <chrisdone> hang on i've a less convoluted example
11:39:26 <zennist> geekosaur: thanks for your material; I have the feeling that I've been a caveman...
11:39:30 <chrisdone> ReinH: https://github.com/chrisdone/descriptive/blob/70c6e4ddff9e51078558120517311fe7cd375e22/src/Descriptive.hs#L133
11:39:30 <chrisdone> ReinH: proof that Consumer satisfies the fmap id = id law
11:39:56 <chrisdone> ReinH: each of those steps could totally be automated
11:40:15 <zennist> mmachenry: Now that we have a Foldable instance for our tree type, we get foldr and foldl for free!
11:40:34 <mmachenry> Ah I see.
11:40:41 <chrisdone> ReinH: right?
11:40:43 <zennist> I always get fear when I encounter the words 'for free' in LYAH
11:40:51 <mmachenry> This is describing a property of type classes.
11:40:59 <geekosaur> aaaactually... I thinkt hat;s just referring to the fact that, if you create a Foldable instance, you get some things from the typeclass
11:41:12 <mmachenry> It's pretty easy to understand in terms on the sort function and the Ord type class.
11:41:23 <geekosaur> so once you foldMap, you have Foldable, and the definitoon of Foldable *gives* you foldl and foldr
11:41:29 <mmachenry> Take a look at the type of sort
11:41:31 <mmachenry> :t sort
11:41:32 <lambdabot> Ord a => [a] -> [a]
11:41:38 <zennist> mmachenry: sorry I think I get the wrong sentence.. I thought that's just for you to get a direction
11:42:00 <mmachenry> Hm?
11:42:20 <mmachenry> Are you not trying to understand how you get foldl for free?
11:42:25 <zennist> the specific sentences are: oldable so that we get the abilty to fold it up. One way to make a type constructor an instance
11:42:26 <zennist> of Foldable is to just directly implement foldr for it. But another, often much easier way, is to
11:42:26 <zennist> implement the foldMap function, which is also a part of the Foldable type class. The foldMap
11:42:48 <zennist> The thing I don't understand is why impolementing foldMap gives you foldl and foldr
11:43:14 <chrisdone> ReinH: i did make a proof for fmap (f . g) = fmap f . fmap g https://github.com/chrisdone/descriptive/blob/fbbfc52941f0c57320e22419ce118f7f4739384f/src/Descriptive.hs#L151-L306
11:43:14 <chrisdone> ReinH: but merijn and shachaf pointed out i get that for free thanks to parametricity
11:43:33 <zennist> because foldMap relies on a function that transforms an element of the structure into a monoid value; but how for foldl/foldr..?
11:44:12 <mmachenry> Ah. Some type classes allow you to implement some but not necessarily all of the methods.
11:44:27 <mmachenry> Because some methods can be defined in terms of the others.
11:44:28 <ReinH> chrisdone: Yeah, which is rather nice :)
11:44:33 <chrisdone> indeed
11:44:38 <mmachenry> And all Haskell needs you to do is implement one of them.
11:44:53 <zennist> mmachenry: yep, but there must be some default 'magic' implementation out there that makes sure that the stuff I write is enough for it work out the mechanism to do foldl, foldr?
11:45:04 <ReinH> chrisdone: Ah I see, you're just manually walking through the proof steps and manually checking, not using Haskell as some sort of proof assistant.
11:45:06 <mmachenry> It has a default implementation of both in terms of the other and once you define one of them, it can use the default of for the other.
11:45:13 <ReinH> I was like "I don't think Haskell can do that..."
11:45:21 <edwardk> zennist: Foldable's class definition has default definitions of foldr in terms of foldMap, foldMap in terms of foldr and foldl in terms of foldr.
11:45:23 <zennist> mmachenry: I'm just wondering how that 'magic' happens..
11:45:29 <geekosaur> zennist, it's part of the definition of Foldable
11:45:32 <edwardk> zennist: so it is sufficient to define either foldMap or foldr
11:45:39 <shachaf> chrisdone: I think I pointed out that you *don't* get it for free unless you know F is a functor. :-)
11:45:43 <edwardk> zennist: and then the default definitions fill in the rest
11:46:01 <edwardk> because foldl will chain through from foldr to foldMap
11:46:02 <geekosaur> zennist: http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/src/Data-Foldable.html#Foldable if you want to see the source
11:46:05 <zennist> okay I think I'll have a read of the source code to see how that default implementation works
11:46:16 <chrisdone> shachaf: i showed at least fmap id = id for my type
11:46:16 <geekosaur> it includes a definition for foldr in terms of foldMap and a definition of foldMap in terms of foldr
11:46:19 <zennist> geekosaur: thank you. I should be doing that from the start now I look back
11:46:24 <geekosaur> so if you provide one it can get the other
11:46:36 <edwardk> if you scroll back above i gave the explanation of how it works, but reading the original code isn't a bad idea either ;)
11:46:44 <geekosaur> (and it goes into a loop if you provide neither, unless your ghc is recent enough to understand the MINIMAL pragma...)
11:46:46 <shachaf> chrisdone: OK, so I'd it's a functor then the free theorem shows that your fmap is correct.
11:46:47 <quchen_> mmachenery Some classes don't even need a single function implemented manually, e.g. MonadPlus in GHC 7.10
11:46:51 <mmachenry> Type classes have definitions of lists of their methods that constitute a minimal complete definition.
11:47:07 <zennist> edwardk: opps I must have missed your words... I don't have sharp eyes :)
11:47:12 <chrisdone> shachaf: yay!
11:47:14 <geekosaur> and it has other functions defined in terms of one or the other of those, so foldl falls out given either foldr or foldMap
11:47:29 <mmachenry> You can define them allow with a type class (I think doing so might require a language extension) otherwise someone must implement all of the methods in order to implement the typeclass
11:47:33 <geekosaur> (you can also provide a more optimal foldl when defining an instance)
11:47:36 <shachaf> I'm not sure how pedantic this is, because I can't think of any counterexamples (they probably don't exist in Haskell 2010).
11:47:51 <shachaf> chrisdone: s/I'd/if/
11:48:00 <geekosaur> when you define a typeclass you can include definitions for typeclass methods; these will be used as defaults
11:48:23 <geekosaur> you can, when defining an instance, provide some or all (or, occaisonally, no) method definitions specific to the instance
11:48:27 <edwardk> zennist: if you look at the signature of foldr :: (a -> r -> r) -> r -> [a] -> r  -- we can try to figure out how to foldMap that, we need (a -> m) for some monoid m. Endo r = Endo (r -> r), so if m = Endo r  then we get foldMap :: (a -> Endo r) -> [a] -> Endo r
11:48:36 <chrisdone> ReinH: indeed. i just manually made them. i'd *LOVE* a an assistant that does what i just did manually for haskell. not only would i take to writing proofs more often but i think general haskell newbies could be introduced to it as a standard practice
11:48:43 <monochrom> @type foldMap
11:48:44 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
11:48:49 <geekosaur> usually there's some minimal set (for Foldable, either foldr or foldMap) which, if provided, are enough for the typeclass to provide the other methods automatically
11:49:04 <chrisdone> ReinH: also, you could have some TH to embed your proof and have it checked at compile-time. it would be so cool *gushes*
11:49:12 <monochrom> ha, interesting
11:49:36 <geekosaur> there is a GHC extension to check for those minimal sets (standard Haskell will quietly accept a Foldable instance that defines neither foldl nor foldMap, then go into an infinite loop if you use either)
11:49:45 <geekosaur> but no extension needed to do this kind of thing in the first place
11:50:03 <shachaf> If you define a Foldable instance you should define foldMap.
11:50:16 <shachaf> It's better than foldr/foldl.
11:52:28 <c_wraith> Really, though, it's usually best to include everything..  foldMap is the best single piece, but implementing everything in terms of it is suboptimal
11:55:04 <lpaste> bennofs pasted “Show PR's changing files with your name” at http://lpaste.net/119082
11:55:29 <bennofs> Ops, why did I select #haskell in that paste ... ignore that
11:56:03 <monochrom> :)
11:56:23 <quchen_> REDUNDANT DO! (Meet the Streisand effect.)
11:58:17 <chrisdone> i wonder if one can view a proof assistant as something that simply needs to provide valid source transformations (expansions or reductions) for equational reasoning
11:58:37 <funfunctor> hackage /really/ should have a SSL cert
12:07:32 <boothead_> Hi all, I've written a function to lift a Fold from (Control.Foldl) into a fold over a map: overMaps :: (Ord k) => Fold a b -> Fold (M.Map k a) (M.Map k b) but if feels like I'm missing some generalization. Can anyone point out how I could do it better? https://github.com/boothead/hierarchy/blob/master/src/Hierarchy.hs#L75
12:08:54 <ReinH> shachaf: So if this is begging the question, how does it end up working for so many cases? Or is it not really begging the question?
12:11:47 <sebastianrkg> is there a way to wrap System.Locale's "readTime" function in a Maybe?
12:12:18 <sebastianrkg> I looked at the implementation of readMaybe, but I don't understand it at all, it uses readPrec
12:13:10 <tdammers> readPrec ain't black magic
12:14:26 <monochrom> I can't find "readTime" in System.Locale. where can I find it?
12:14:45 <sebastianrkg> ah I guess it's actually in Data.Time.Format
12:15:29 <sebastianrkg> It's not that readPrec is black magic, I just don't understand where I would substitute readTime for read in this function http://lpaste.net/119086
12:15:48 <sebastianrkg> I want readMaybe, but readMaybe is implemented using this readEither function.
12:16:02 <quchen_> When using hsc2hs, I'm getting a lot of warnings like this: http://lpaste.net/119087 -- is there any way I can fix that? They don't seem to impact my program, but the build log is full of this noise.
12:16:26 <quchen_> Maybe it has to do with bindings-dsl as well.
12:16:27 <monochrom> use readsTime instead. it's similar to what I say in http://www.vex.net/~trebla/haskell/reads.xhtml
12:18:16 <mightybyte> Anyone know of a function like this: intersectBy' :: (a -> a -> Bool) -> (a -> a -> b) -> [a] -> [a] -> [b] ?
12:18:16 <sebastianrkg> hmm okay that seems promising
12:18:23 <sebastianrkg> thanks guys
12:18:50 <SrPx> Okay, so free monads are the same idea. We take a functor, and give back a monad. In fact, since monads can be seen as monoids in the category of endo functors, the definition of a list
12:19:12 <jle`> mightybyte: how does it work?
12:19:22 * SrPx nods
12:19:58 <mightybyte> jle`: Just like intersectBy except it uses the second function to combine the two items that matched.
12:20:00 <monochrom> @type intersectBy
12:20:00 <funfunctor> anyone experiencing cabal doing weird shit since  1.22.0.0-1? a.k.a randomly not finding packages
12:20:01 <lambdabot> (a -> a -> Bool) -> [a] -> [a] -> [a]
12:20:21 <funfunctor> even though ghc-pkg list clearly lists them
12:20:32 <jle`> ReinH: it doesn't beg the question because it doesn't have a circular argument :)
12:21:33 <monochrom> combine two elements that match? that is not my understanding of what "intersect" means.
12:22:00 <mightybyte> The two elements that made the equality function return true.
12:22:13 <monochrom> my understanding is that some elements are thrown away and some other elements are kept. there is no "combine".
12:22:32 <mightybyte> I know...I'm saying that I want one that has a combine.
12:22:54 <monochrom> then I oppose to hijacking the name "intersectBy"
12:23:13 <mightybyte> Why?  It's still an intersection.
12:23:20 <mightybyte> It doesn't have to be that exact name.
12:23:24 <monochrom> I have already said why.
12:23:27 <mightybyte> Call it intersectBy' or whatever you want.
12:23:53 <mightybyte> Ok, let's call this function foo.
12:23:59 <mightybyte> If you had it, you could do this.
12:24:08 <mightybyte> intersectBy f as bs = foo f const as bs
12:24:56 <mightybyte> It's very obviously related
12:25:06 <monochrom> I have not seen it in any common library.
12:25:09 <mightybyte> I'm just here to see if such a concept already exists somewhere.
12:28:15 <benmachine> mightybyte: so you call your combining function on the first match pair in the lists?
12:28:20 <benmachine> *matching
12:28:28 <mightybyte> Yeah
12:28:37 <benmachine> if other pairs match, it doesn't matter?
12:28:46 <mightybyte> I was thinking about that.
12:28:56 <mightybyte> I suppose you could make my combining function into a fold of some kind.
12:29:20 <benmachine> (to be honest I'm leaning towards Data.List.intersect already being kinda weird :P )
12:29:30 <mightybyte> Yeah, I was just thinking the same thing.
12:29:38 <benmachine> > intersect [1,1,1] [1]
12:29:39 <lambdabot>  [1,1,1]
12:29:42 <mightybyte> Yep
12:29:56 <chrisdone> huh
12:29:58 <benmachine> > {- that's weird by itself, but also -} intersect [1] [1,1,1]
12:29:59 <lambdabot>  [1]
12:30:03 <mightybyte> I guess it's assuming that the lists you pass are more like sets.
12:30:07 <chrisdone> ah, it's "left-biased"  perhaps
12:30:23 <chrisdone> so it ends up being a filter on the right-hand-side
12:30:31 <benmachine> chrisdone: it is, and that's even documented, but it makes it an odd operation
12:30:33 <mightybyte> If you make the same assumption for my foo function, then the (a -> a -> b) combining function is fine.
12:30:39 <chrisdone> odd for lists, yeah
12:32:02 <benmachine> mightybyte: the main thing that's weird about your idea above that one is that your combining function takes both elements, despite the "equality" predicate saying they're equal
12:32:31 <benmachine> mightybyte: so it seems like it's only useful when you are flouting the intuition of the function
12:32:42 <mightybyte> Yes, but the whole point of passing a comparison predicate is that you might be using something that's not strict equality.
12:32:58 <mightybyte> ...which means that there might be another part of the data that you want to combine.
12:34:14 <benmachine> right, but having differences that you sometimes do and sometimes don't care about makes the duplicates question even thornier
12:34:31 <mightybyte> Depends on your application
12:34:43 <benmachine> mightybyte: is it possible to turn these lists into Data.Maps keyed by the bit you care about?
12:35:03 <mightybyte> I suppose it's *possible*, but that doesn't fit well with my current data model.
12:35:19 <benmachine> then you already have intersectionWith
12:35:20 <rhllor> what other languages are like haskell?
12:35:45 <jle`> there are other languages like hasell in various aspects, but they usually differ in some key aspects
12:35:58 <benmachine> there are not many lazy pure languages
12:35:59 <mightybyte> benmachine: Right, but that just doesn't work for me.
12:36:10 <jle`> be it in the language design or the common idioms
12:36:17 <jle`> and design principles
12:36:27 <rhllor> well, what kind of family does haskell belong to? what are the most similar to it, in you opinion?
12:37:03 <benmachine> ocaml has a strong type system and an emphasis on immutability and functions as values
12:37:06 <mightybyte> rhllor: My criteria for a language these days is: functional, strong static types, pure
12:37:13 <benmachine> and lightweight pattern matching
12:37:19 <jle`> it's a lazy functional pure stronly typed language with type inference
12:37:22 <mightybyte> rhllor: Haskell is the only viable language that has those three criteria.
12:37:28 <benmachine> ocaml is not pure or lazy
12:37:56 <benmachine> ocaml doesn't have type classes, either, in the haskell sense of the word
12:38:08 <tdammers> "functional" is a programming paradigm, not a language property - strictly speaking
12:38:24 <mightybyte> tdammers: Yeah, I know...I debated whether to include that. :/
12:38:25 <benmachine> scala has a sophisticated type system and things like type classes, I don't know a great deal about it though
12:38:27 <rhllor> does haskell come from any other languages, or did it kind of just spring into existence?
12:38:29 <jle`> ocaml is probably the closest member in a "family" of languages; they are very similar on the surface but differ on some key aspects that manifests in very, very different styles of usage and writing
12:38:45 <mightybyte> rhllor: It came from Miranda I believe
12:38:50 <tdammers> "must not get in the way of a functional programming style" works for me
12:38:55 <jle`> rhllor: it was inspired by language features of many different languages at the time. you might like that one history of haskell article
12:39:11 <jle`> "Being Lazy with Class"
12:39:16 <tdammers> that already rules out most languages, including many that tout themselves as "supporting functional programming"
12:39:19 <mightybyte> benmachine: Oh, actually...my function could be generalized further.
12:39:21 <SrPx> There is no way to have a Functor instance for Mutable Vectors right?
12:39:39 <mightybyte> benmachine: foo :: (a -> b -> Bool) -> (a -> b -> c) -> [a] -> [b] -> [c]
12:39:40 <jle`> rhllor: http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/
12:40:16 <jle`> it sort of details the environment that existed around the formation of haskell
12:40:54 <benmachine> mightybyte: my personal vote is that that's too niche to live somewhere general, and should be defined at use sites
12:41:00 <mightybyte> rhllor: A lot of people would probably tell you that F#, Scala, and OCaml are probably the closest to Haskell of the languages that have significant visibility today.
12:41:06 <benmachine> mightybyte: you are of course not required to care what I think :P
12:41:13 <mightybyte> lol
12:41:20 <jle`> but yeah, ocaml is probably the closest surviving language to haskell, but the two differ on certain key aspects that make real-world and program architecture and design completely different
12:41:40 <benmachine> I think ocaml and haskell are more alike each other than either is like most other programming langauges
12:41:48 <benmachine> even though they're quite different
12:42:00 <tommd> Does Daniel Gorin visit here under some nick?
12:42:10 <benmachine> the use of ADTs and lambdas is a surprisingly big deal for how simple they are as ideas
12:42:24 <jle`> ocaml is nice
12:42:30 <rhllor> thanks
12:43:47 <jle`> also ocaml people have this fascination with uncurried functions, what's up with that
12:44:33 <tdammers> don't think that's specific to ocaml, really
12:45:06 <benmachine> jle`: you mean tuples of arguments, or avoidance of partial application?
12:45:22 <benmachine> jle`: (I ask because it sounds like you mean the former but I only have input on the latter)
12:45:23 <jle`> tdammers: :P
12:45:41 <jle`> they tend to like to write their functions as (a, b) -> c instead of a -> b -> c
12:45:43 <mightybyte> benmachine: Here's a decently concise implementation
12:45:44 <mightybyte> foo eq comb xs ys = [comb x y | x <- xs, y <- ys, eq x y]
12:45:59 <tdammers> jle`: yes, I understand that... but then, that goes for almost all programming languages
12:46:07 <jle`> oh that was addressed to benmachine
12:46:10 <jle`> and yes, that was the joke :)
12:46:41 <benmachine> mightybyte: that has different behaviour in the presence of duplicates, and also always traverse the entire second list per first-list element
12:46:42 <adamse> in emacs haskell-mode is there any way to specify environment variables that I need? on osx I need to add some things to LIBRARY_PATH to get X11 to work, but I cannot get haskell-mode to pick up on the env variables
12:46:46 <tdammers> otoh, writing all your functions curried would be really awkward in, say, javascript
12:46:48 <benmachine> mightybyte: but those might not be problems you care about
12:46:58 <tdammers> (in fact, that's probably what makes javascript awkward in the first place)
12:47:07 <benmachine> jle`: oh, I use ocaml at work and we don't do that
12:47:07 <jle`> yes, that's definitely the principle reason
12:47:09 <EvanR> i do it anyway, in javascript
12:47:16 <mightybyte> benmachine: Yeah
12:47:16 <whiiiteee> http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abv
12:47:16 <whiiiteee> chat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/
12:47:18 <whiiiteee> http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abv
12:47:18 <whiiiteee> chat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/
12:47:18 <whiiiteee> http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abv
12:47:19 <whiiiteee> chat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/
12:47:19 <whiiiteee> http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abvchat.com/ http://abv
12:47:33 <tdammers> that was fast
12:47:36 <jle`> benmachine: ah, really?  it must vary by house then
12:47:38 <benmachine> jle`: but we also don't partially apply much, I think because of labelled arguments
12:47:38 <mightybyte> Wow, tht was really fast.
12:47:53 <jle`> i heard that the standard library has a lot of functions like that
12:47:57 <benmachine> (labelled arguments also argue against currying your functions, which is kinda weird)
12:47:59 <jle`> er, popular libraries
12:48:01 <mightybyte> I mean, come on...if you're gonna spam there are better ways to do it. :P
12:48:11 <benmachine> jle`: we mostly use our own libraries :P
12:48:19 <benmachine> but
12:48:21 <jle`> :P
12:48:22 <rhllor> what kind of situations is ocaml mainly used in, as opposed to haskell
12:48:28 <benmachine> we also release them, so
12:48:31 <benmachine> many of them
12:48:41 <jle`> ocaml and haskell are both general purpose languages
12:48:48 <rhllor> or rather, where does ocaml exceed haskell, and haskell, ocaml
12:48:56 <jle`> i think ocaml's runtime is a bit smaller than ghc's
12:49:02 <benmachine> I can't see an obvious domain where haskell is clearly right and ocaml is clearly wrong or vice versa
12:49:22 <monochrom> idoru is like the best of both humans and robots: the judgment of humans, the 24/7 availability of robots
12:49:32 <benmachine> ocaml generally has more predictable performance characteristics, but this is partially because GHC's optimiser is waaay more sophisticated than ocaml's :P
12:49:50 <benmachine> ocaml's inlining is (aiui) pretty primitive at the moment
12:50:19 <rhllor> is there any real areas where haskell or ocaml dominates over other languages? what are their uses?
12:50:31 <monochrom> ocaml's types are pretty nice when you want objects.
12:50:47 <benmachine> monochrom: actually at work we never use objects :P
12:50:54 <josephle> monochrom: second-class modules are nice as well :P
12:51:02 <benmachine> but the ocaml module system is really nice
12:51:12 <monochrom> oh, then s/objects/records/ :)
12:51:22 <benmachine> oh, yeah, the records are way better than haskel's
12:51:24 <benmachine> +l
12:51:28 <benmachine> and the modules
12:52:01 <rhllor> for example, CL is good for ai, FORTRAN for math Python for taking up half your file with whitespace
12:52:12 <benmachine> hah
12:52:17 <rhllor> what are does functiona; programming languages dominate?
12:52:32 <rhllor> *area
12:52:38 <Welkin> rhllor: what do you mean by functional languages?
12:52:40 <cjenkin2> Parallel programming is a good place were research with functional languages is very active
12:52:46 <EvanR> CL for AI >_>
12:52:51 <athan> semantic correctness
12:52:54 <benmachine> research is a good place where functional langauges are very active
12:53:02 <cjenkin2> benmachine, lol
12:53:09 <Welkin> EvanR: yeah, AI researchers seem to have an obsession with common lisp
12:53:14 <Welkin> especially ones from MIT
12:53:29 <cdx> rhllor: Haskell is GREAT for DSL/EDSL, and suprisingly many problems fit into that category :)
12:53:31 <Welkin> it's certainly not special
12:53:57 <jesse__> i don't think thats true anymore, python seems more popular for ai nowadays
12:54:02 <rhllor> Welkin: I hear they get a fresh shipment of parenthesis keyboard keys every month
12:54:09 <athan> Welkin: I think it's a fanatacism of dynamic typing, being "ad-hoc" :\
12:54:10 <mightybyte> rhllor: If you want to write an OS, Haskell might not be ideally suited.
12:54:25 <cjenkin2> jesse__, My friend is pursuing an online masters degree in machine learning, that's what he's said
12:54:46 <mightybyte> rhllor: However, if you want to write something that can *generate* the code for an OS, Haskell might be better suited...
12:54:48 <rhllor> i highly doubt, I'll be writing OSs anytime soon
12:54:50 <Welkin> machine learning is not "AI" to the AI researchers who use lisp
12:55:04 <Welkin> they get quite upset if you say that it is
12:55:24 <johnw> is AI when the program has already learned?
12:55:28 <jesse__> mightybyte actually there's sel4, a microkernel where the implementation is in c and a haskell model is kept in sync with the c to prove correctness
12:55:30 <cjenkin2> Welkin, And I bet those who study machine learning get upset if you say it isn't AI :P
12:55:39 <athan> rhllor: Don't worry, that'll change
12:55:52 <athan> or like, compilers
12:55:56 <athan> compilers are easy in haskell
12:56:06 <cjenkin2> jesse__, Well it's C <-> Haskell <-> Isabelle/HOL
12:56:11 <mightybyte> rhllor: That's a common workaround.  Any time something is too low level to be well suited for Haskell, you can still model the problem in Haskell and use your model to generate code.
12:56:16 <monochrom> people keep forgetting that everyone has only seen a small slice of the world and therefore everyone's statistics is inaccurate.
12:57:02 <cjenkin2> johnw, lol
12:57:08 <rhllor> so, you're saying that haskell is good for generating templated data that's not dependent on hard coded information?
12:57:28 <monochrom> for example I have heard one programmer (who only dabbled in databases) said "you don't need calculus for programming. I have worked on many many databases..."
12:57:39 <abayley> @djinn [IO (Either a b)] -> IO [Either a b]
12:57:39 <lambdabot> Error: Undefined type []
12:57:41 <monochrom> now try telling that to a computer graphics programmer.
12:57:57 <cjenkin2> monochrom, Do you need calculus for programming though, if you're not doing linear algebra stuff?
12:58:21 <monochrom> and I'm sure the computer graphics programmer may say "you don't need databases. I have worked on many many rendering engines..."
12:58:24 <mightybyte> rhllor: I'm saying that Haskell is weak in giving you precise control over very low-level aspects of your code and the way it ultimately gets executed.  But you can work around that by using Haskell to generate code in a language where you have that control.
12:59:02 <rhllor> oh okay
12:59:11 <rhllor> I comepletely understand
12:59:17 <Welkin> oh
12:59:30 <cjenkin2> rhllor, Reasoning about the performance of Haskell programs is a science unto itself
12:59:34 <monochrom> when one person says "lisp is the most popular among AI people", he/she clearly has not worked with AI people who use Prolog. and vice versa.
12:59:51 <tdammers> the more I program in haskell, the more I come to see it not as a programming language, but as a meta- or even meta-meta-programming language
13:00:06 <cjenkin2> tdammers, you should learn Agda then :)
13:00:10 <monochrom> and both of them have not worked with Norvig, who use python.
13:00:14 <rhllor> cjenkin2: I don't really care abou the performance, mainly
13:00:31 <jesse__> rhllor you might be interested in reading about facebook's haxl (using haskell) and flow (ocaml) projects
13:00:38 <EvanR> mightybyte: you work around that or you dont care about that
13:00:39 <rhllor> monochrom: all I said was CL is used in AI not AI is CL
13:00:40 <Welkin> are their pragmas for ghc to call cpu intrinsics?
13:00:42 <Welkin> there*
13:00:43 <jesse__> this in particular explains why haskell was well suited: https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/
13:00:49 <mightybyte> rhllor: Perfect!  That makes you an ideal candidate for Haskell! :)
13:00:54 <cjenkin2> lol
13:01:04 <rhllor> jesse__: I read about those in the lambda the ultimate site
13:01:21 <EvanR> not caring about performance as much gets you better performance in haskell than many languages where you must tediously worry about performance
13:01:37 <johnw> EvanR: very nicely said
13:01:54 <EvanR> if complete unsubstantiated ;)
13:01:58 <EvanR> ly
13:02:12 <SrPx> So, I guess I get how free monads work, but I have a question. Since free monads of some types essentially encode a "tree" structure... is there a generic Zipper that allows me to navigate through that structure?
13:02:31 <rhllor> I'd rather pretty code over fast
13:02:35 <cjenkin2> EvanR, Well, doing multiple maps doesn't traverse a list twice necessarily, I think that's fair
13:02:43 <johnw> SrPx: navigate, or pick apart and put back together piece-wise?
13:02:43 <rhllor> unless I really need my results fast
13:02:46 <SrPx> For example, "Free [Free [Pure 1, Pure 2], Free [Pure 3, Pure 4]]", a value of the free monad on lists. I guess a generic zipper would need a way to chose the index (an int) of the child you are going to when you move down.
13:03:17 <johnw> SrPx: I believe 'lens' will do both
13:03:22 <cjenkin2> Free Monads confuse me
13:03:28 <chrisdone> <monochrom> when one person says "lisp is the most popular among AI people
13:03:31 <johnw> but you'll end up with a lot of x._Free.y._Free, etc.
13:03:31 <tdammers> even when you need results fast, "pretty -> correct -> fast" works better than "fast -> correct -> pretty"
13:03:36 <johnw> cjenkin2: why so?
13:03:41 <chrisdone> i think that is true, but is time-dependent, i.e. in the past
13:03:44 <cjenkin2> It's the second iteration of the "what are monads" question xD
13:03:48 <SrPx> johnw: pick apart and put back together, I guess... I am still trying to figure out if I can make a single implementation for both mutable and immutable vectors, though... on the mutable case it would just be navigating
13:03:49 <johnw> haha
13:03:58 <cjenkin2> johnw, I just need to sit down and work through the types, is all, I think
13:04:01 <SrPx> lens will do both? oh well
13:04:10 <SrPx> how
13:04:37 <monochrom> chrisdone: would you agree if I said "no one uses python"? because it was also once true.
13:04:49 <johnw> SrPx: http://stackoverflow.com/questions/15489324/traversal-tree-with-lens-and-zippers
13:04:52 <nbouscal> cjenkin2: alternatively, work through the category theory. that route was easier for me, ymmv
13:05:15 <johnw> cjenkin2: take the free monoid and lift it to the functor level.  next question
13:05:21 <tdammers> the problem with learning category theory is that everything seems to be defined in terms of everything else
13:05:26 <cjenkin2> nbouscal, I've been meaning to learn that, but now I have HOTT competing for that time
13:05:38 <chrisdone> monochrom: it was true once but i don't think it was a common saying to point it out =p
13:05:40 <nbouscal> tdammers: not only that, but each thing can be defined in terms of each other thing several different ways!
13:06:07 <monochrom> ok, how about this, "emacs hogs 90% of your memory" :)
13:06:13 <nbouscal> cjenkin2: eh, might not be a competition. if you understand a thing from HoTT pov, it's easier to understand the category pov, and vice versa
13:06:25 <cjenkin2> nbouscal, That's what I'm hoping
13:06:52 <kazagistar> man, all those megabytes, emacs is a pig!
13:07:02 <cjenkin2> kazagistar, :P
13:07:02 <monochrom> "lisp is the most popular in writing editor extensions" :)
13:07:11 <zachk> heya :D
13:07:15 <cjenkin2> monochrom, Well, that might be true?
13:07:26 <johnw> cjenkin2: Given a functor over a type variable, the free object for that functor replaces each instance of the type variable in the structure with either a value as before (Pure), or another instance of the same structure (Free)
13:07:27 <cjenkin2> Measured in man-hours
13:07:29 <mniip> how would I go about storing some large structure inside a TVar?
13:07:38 <mniip> TVar (Map k a) sounds quite inefficient to me
13:08:03 <cjenkin2> johnw, That makes sense
13:08:56 <SrPx> johnw: are you sure? I don't see anywhere on that explanation how it choses the index of the child node to go ... nor how it would work like a zipper tbh
13:10:15 <johnw> SrPx: no, I'm not sure, I haven't used them for that purpose yet
13:10:24 <SrPx> ah okay ^^
13:10:45 <biglama> hi guys, I'm looking at unpickling a xml with hxt
13:10:57 <biglama> how can I skip some nodes ?
13:24:50 <quchen_> mniip: Define "inefficient"
13:25:19 <mniip> well when I want to add something to the map
13:25:36 <mniip> I have to copy the whole thing from the MVar, then add, then copy the whole thing back
13:25:41 <mniip> TVar*
13:26:26 <quchen_> You don't have to copy the entire thing, only the spine of the element you're modifying. The rest of the Map can be shared.
13:26:44 <quchen_> And this doesn't have anything to do with TVar, it's a property of Map
13:28:20 <quchen> Just like when you modify the 3rd element of [1..10], you can share the [4..10] part between the old and the new version
13:31:48 <Pamelloes> Does anyone know of any papers on genetic algorithms in Haskell?
13:34:29 <shachaf> ReinH: ?
13:38:57 * hackagebot process-extras 0.3.0.1 - Process extras  http://hackage.haskell.org/package/process-extras-0.3.0.1 (DavidFox)
13:40:33 <lwm> having a brain fart here, for the type sig of (<*>), the `f (a -> b)` is confusing me. I am trying to toy together a really simply usage .. someone please enlighten me here
13:41:49 <shachaf> Just (+5) :: Maybe (Int -> Int)
13:42:34 <shachaf> But you might prefer an alternative formulation of Applicative, which has pure and liftA2 as primitives.
13:45:04 <lwm> shachaf: perfect!
13:51:48 <favonia> I'm using attoparsec and want a function like "skipTill junk match = match <|> (junk *> skipTill junk match)". What's the most beautiful way to write this? For example, is this gadget already available somewhere?
13:56:22 <johnw> you mean, repeatedly skip junk until you find match?
13:56:33 <johnw> many junk *> match
13:57:16 <johnw> or is the problem that junk may match what "match" does?
14:03:58 * hackagebot handsy 0.0.3 - A DSL to describe common shell operations and interpeters for running them locally and remotely.  http://hackage.haskell.org/package/handsy-0.0.3 (utdemir)
14:06:20 <funfunctor> having some issue getting fmap f m = BladeRF (fmap f . unBladeRF $ lift m) to type check
14:06:41 <funfunctor> naturally lift :: (MonadTrans t, Monad m) => m a -> t m a
14:07:03 <funfunctor> and so I get the type error     Expected type: BladeRF a       Actual type: t0 BladeRF a
14:08:32 <c_wraith> funfunctor: it looks a lot like that lift is the problem.  (I can't be fully sure)
14:08:37 <asmyers> Has anyone every seen cabal test fail with "Prelude.read no parse" (I think in stubMain http://hackage.haskell.org/package/Cabal-1.22.0.0/docs/src/Distribution-Simple-Test-LibV09.html#stubMain)
14:08:43 <c_wraith> funfunctor: did you try without it?
14:09:14 <erikd> anyone know of a something like codepad.io that has a decent set of libraries include (specifically http-conduit and all the deps)
14:09:15 <erikd> ?
14:09:30 <c_wraith> erikd: fpcomplete?
14:10:16 <erikd> c_wraith: that allows two people to interactive edit the same file?
14:11:00 <c_wraith> erikd: oh.  I don't think it's optimized for that.  Didn't realize that was codepad's main point
14:11:08 <dfeuer> Has anyone made any progress on making things like http://homepages.inf.ed.ac.uk/slindley/papers/embedding-f.pdf less painful?
14:11:15 <erikd> yeah
14:11:28 <SrPx> So, we've been making an effort to spread haskell around our local programming groups. I know it is kinda of working since people actually started talking about and trying it. Well. Kinda. http://i.imgur.com/Rw8mmad.jpg
14:11:53 <funfunctor> c_wraith: well without the lift its 'worse'
14:12:37 <funfunctor> c_wraith:     Couldn't match expected type ‘ExceptT                                     BladeRFError (StateT (Ptr C'bladerf) IO) b’                 with actual type ‘a0 -> f0 b’
14:13:20 <c_wraith> funfunctor: ah.  That's just telling you you're providing a function where it's expecting a non-function.
14:13:49 <c_wraith> funfunctor: other than the (a0 ->) part, those types unify
14:14:46 <funfunctor> c_wraith: well I am just trying to get this functor instance working so I can make the monad a instance of applicative
14:15:07 <c_wraith> funfunctor: maybe something like...   fmap f m = BladeRF (fmap f $ unBladeRF m)
14:15:25 <c_wraith> funfunctor: that's *entirely* a guess, given that I don't actually know the definition of BladeRF
14:15:45 <funfunctor> c_wraith: newtype BladeRF a = BladeRF { unBladeRF :: ExceptT BladeRFError (StateT (Ptr C'bladerf) IO) a }
14:16:09 <funfunctor> ah that did it thanks c_wraith!
14:16:11 <c_wraith> funfunctor: then yeah, my guess should basically be right.  :)
14:17:09 <funfunctor> c_wraith: and I guess fmap f $ unBladeRF m then becomes f  unBladeRF m
14:17:28 <c_wraith> funfunctor: well, know..  you lost the fmap doing that. :P
14:17:48 <Pamelloes> I have a function that takes a parameter (a -> IO a) and is pure except for the invocation of the specified function. Is there a way to make it so that I can make it so that i can use a pure function for the parameter and have the function be treated pure overall?
14:17:51 <c_wraith> funfunctor: you could write it as something like fmap f = BladeRF . fmap f . unBladeRF     though
14:18:11 <c_wraith> funfunctor: that makes it clear that it's just adding and removing the wrapper
14:18:42 <funfunctor> c_wraith: sorry I mean f <$> unBladeRF m
14:18:49 <c_wraith> funfunctor: oh, then yes.
14:19:01 <funfunctor> where does <$> come from these days?
14:20:03 <monochrom> both Data.Functor and Control.Applicative have it. pick one.
14:20:11 <funfunctor> ah Control.Applicative got it
14:20:14 <funfunctor> thanks
14:20:27 <lf94> IO Monad is considered harmful <- recommended read
14:20:31 <benmachine> Pamelloes: Monad m => (a -> m a) and then use it with Identity for pure functions
14:20:52 <Pamelloes> benmachine: Awesome! Thanks :)
14:21:11 <benmachine> Pamelloes: that was an abbreviated explanation, let me know if you need more :)
14:21:16 <funfunctor> lol, all IO is harmful, humans could be involved !
14:21:53 <funfunctor> human :: IO (Destroy)
14:22:08 <johnw> "Sir, what weapon did the assailant use against you?  All I know is that it was done in IO, officer."
14:22:14 <Pamelloes> benmachine: Can I put that into a type definition? e.g. type State m = (Monad m) => (a -> m a,MoreStateInfo)
14:22:58 <dfeuer> @quote johnw "Sir, what weapon did the assailant use against you?" "All I know is that it was done in IO, officer."
14:22:58 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
14:22:59 <benmachine> Pamelloes: not really, sadly, context can't be hidden inside type synonyms
14:23:05 <dfeuer> @remember johnw "Sir, what weapon did the assailant use against you?" "All I know is that it was done in IO, officer."
14:23:05 <lambdabot> I will remember.
14:23:39 <raek> the article criticizes usage of the term "IO monad" in tutorials and suggests the term "IO type" instead
14:24:52 <raek> I agree that "IO tutorials" are more useful to a Haskell newbie than "monad tutorials"
14:24:56 <Pamelloes> benmachine: Should I define the type with newtype then, or do I have to use a data declaration?
14:25:23 <funfunctor> c_wraith: its still a bit beyond me why "Left" and "Right ()" are getting printed to the screen because of https://github.com/victoredwardocallaghan/hlibBladeRF/blob/monadic/src/LibBladeRF/LibBladeRF.hs#L91
14:25:23 <benmachine> Pamelloes: even those don't help you too much, you basically just have to provide the context on functions that use your thing
14:25:25 <funfunctor> somehow
14:26:41 <Pamelloes> benmachine: Can I do something along the lines of type State m = (a -> m a, ... ) and move the restriction to each function, or is there no way to use a synonym?
14:27:08 <benmachine> Pamelloes: yes, you can do that
14:27:20 <Pamelloes> Awesome! :)
14:27:46 <c_wraith> funfunctor: no ideas there - not something I can jump into as quickly, and I'm a bit busy to take a long look now.
14:29:37 <funfunctor> c_wraith: no problem thanks for the help
14:33:59 * hackagebot RSA 2.1.0.1 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  http://hackage.haskell.org/package/RSA-2.1.0.1 (AdamWick)
14:41:00 <xplat> luite: say, you're the only person i know who's ever created a new backend for ghc.  do you have any advice for people who want to create another backend?  (specifically jvm)
14:43:48 <monochrom> my selfish advice is "the Haskell Report, its FFI section, has long talked of a non-existent, futuristic java interface. so please do it and realize that dream. kthx" :)
14:44:32 <mniip> is there some numeric type where 0 * undefined is 0?
14:45:11 <starless> mniip: Maybe in the JavaScript dimension.
14:45:21 <johnw> @src (*)
14:45:21 <lambdabot> Source not found. My mind is going. I can feel it.
14:45:51 <mniip> starless, I'm speaking of not evaluating the second argument if first is 0 of course
14:46:19 <starless> mniip: I was joking around. I'm not the person to ask. :p
14:46:40 <xplat> mniip: probably an inductive type of unary naturals would behave that way.
14:48:13 <xplat> mniip: but no such type can be commutative, strictly speaking.  you can't have 0 * _|_ = 0 = _|_ * 0
14:48:20 <mniip> hmm
14:48:28 <mniip> true
14:48:56 <mniip> one of those will have to be ⊥
14:50:13 <Pamelloes> Well, if you defined (*) with the case _ * 0 = 0 and 0 * _ = 0, shouldn't that work with _|_?
14:50:32 <Pamelloes> Or does _ not catch bottom?
14:50:44 <geekosaur> what happens with the first pattern match if the second parameter is bottom?
14:50:54 <johnw> _ does catch bottom
14:51:28 <Pamelloes> geekosaur: good point :/
14:51:32 <geekosaur> and if you try to swap them to avoid that, what happens with the first pattern match when the first parameter is bottom?
14:52:13 <mniip> we need a way to find if a value is a bottom
14:52:25 <EvanR> an oracle
14:52:27 <mniip> x * y = if solveHaltingProblem x then
14:54:00 <luite> xplat: other than reading the STG papers and GHC wiki, figure out how to map some features to your target. for example you probably need some way to do tail calls to make things work correctly and predictably, those are notoriously missing from the JVM
14:54:15 <Pamelloes> mniip: As long as there's no IO it's relatively trivial to solve the halting problem. Emphasis on relative.
14:54:22 <Pamelloes> *relatively
14:54:39 <EvanR> how ?
14:55:03 <mniip> you can make x be a result of a turing machine simulation
14:55:03 <luite> xplat: Scala only offers tail recursion, Frege returns objects for deferred computation. neither seems particularly attractive for Haskell
14:55:46 <hiptobecubic> I don't understand why tail calls are so hard to do on the JVM
14:56:13 <hiptobecubic> it's not like they are bleeding edge research
14:56:26 <Pamelloes> If x is pure, then the execution pattern is fixed for any given input. So all you need to do is determine where infinite loops can occur and check if the current input causes them to occur. If they don't the problem halts.
14:56:45 <EvanR> Pamelloes: uh huh
14:56:45 <geekosaur> uh
14:56:59 <c_wraith> hiptobecubic: in practice the problem is integration with the debugging tools, I think
14:57:20 <EvanR> Pamelloes: so you solve the halting problem by first solving the halting problem ;)
14:57:20 <Pamelloes> EvanR: Should be /possible/ maybe not feasible.
14:57:27 <c_wraith> Pamelloes: that sounds a lot like "just run it for BB(n) steps, and if it hasn't terminated, it doesn't terminate"
14:57:40 <hiptobecubic> c_wraith, in what sense?
14:58:04 <c_wraith> Pamelloes: where you're reducing the halting problem to computing a noncomputable function. :P
14:58:25 <Pamelloes> How many ways are there to create recursion in Haskell?
14:58:28 <c_wraith> hiptobecubic: I suspect it has to do with the way the JVM wants to maintain stack traces for debugging tools.
14:58:44 <xplat> luite: how did you do tail calls in js?
14:59:34 <EvanR> Pamelloes: for instance, if you made a function to return the collatz sequence (terminating at the first 1), how can you tell if it terminates for any given input?
14:59:42 <EvanR> using normal haskell recursion
14:59:43 <luite> xplat: trampoline and manage own stack to avoid dynamic allocation for continuations. when JS engines implement ES6 it will use native calls on engines that support them
14:59:43 <hiptobecubic> seems like saying "you can't have a the entire stack of tail-recursive calls" is a totally reasonable approach that everyone would be a big dick to complain about :)
15:00:19 <c_wraith> hiptobecubic: it would be!  But that's been the excuse for not implementing tail calls as jumps in JVMs for as long as I've been paying attention.
15:00:21 <Pamelloes> EvanR: Um... Go to the future and acquire a proof for the Collatz problem. Integrate proof into your code.
15:00:29 <EvanR> Pamelloes: har ...
15:00:37 <xplat> luite: do you think a trampoline could work for jvm?
15:00:43 <EvanR> Pamelloes: we wouldnt have to if you described your plan ;)
15:01:09 <c_wraith> Pamelloes: can't you just decide, based on the input?  That seems to be what you said..
15:01:25 <hiptobecubic> Those java kids and their toys...
15:01:41 <xplat> c_wraith: the debugging tools, and some of the security stuff (stack inspection)
15:02:08 <luite> xplat: sure, the question is mostly whether performance will be acceptable and how it affects integration with existing JVM code (which i presume is the reason for targeting JVM in the first place)
15:02:10 <Pamelloes> c_wraith: Well, I realized that my statements were incorrect.
15:02:10 <c_wraith> xplat: I thought the only security stuff was on code-load.
15:02:23 <hiptobecubic> i don't understand how implementing tail calls as "return and then call again" ruins anything. There's just *less* stack. It's not uninspectable.
15:02:52 * hiptobecubic doesn't understand a lot of things in the world :(
15:02:58 <c_wraith> Pamelloes: ah!  ok then. :)
15:02:59 <xplat> c_wraith: there at least used to be some stack inspection going on, i remember reading some of the first threads about tail recursion
15:03:18 <xplat> c_wraith: the code-load stuff is mostly for memory safety
15:03:42 <c_wraith> xplat: interesting.  I knew it did static analysis of the bytecode to ensure that the stack was the same height for all paths leading to a particular instruction.  I didn't know there was more to it
15:03:48 <hiptobecubic> how does scala do anything fun without tco? transforms them to loops itself?
15:04:18 <c_wraith> hiptobecubic: scala has a special keyword for "insert tail call here" which just gets compiled to a loop.
15:04:32 <hiptobecubic> ah
15:04:42 <luite> hiptobecubic: the information loss is pretty severe, GHC keeps its own cost centre stacks for profiling, since due to pervasive tailcalling, the actual stack isn't all that informative. other platforms could take a similar approach, but unfortunately the cost of maintaining cost centre stacks is rather high, and Java devs are used to always ahving stack traces, not just when compiled/started with profiling
15:04:48 <c_wraith> hiptobecubic: without use of that...  no, it's not fun at all.  stacks explode all over the place.
15:05:02 <n4x> is Frege doing any optimization like this?
15:06:00 <Pamelloes> EvanR: My intuition tells me the existence of a solution for the halting problem in the context of pure functions should be provable to exist. I might be completely wrong, though (which is more than likely)
15:06:17 <EvanR> Pamelloes: well, i think its been proven to not exist
15:06:35 <Pamelloes> Oh :(
15:06:35 <hiptobecubic> I think that's why it's so famous, no?
15:06:36 <xplat> Pamelloes: you are wrong.  the original formulation of the halting problem was essentially for pure functions.
15:06:44 <geekosaur> as xplat says
15:06:52 <Pamelloes> Alright. I guess I'm wrong. :(
15:07:02 <geekosaur> the original formulation did not involve any form of IO
15:07:19 <Pamelloes> Can someone link me to the proof, this seems like it would be interesting to read.
15:08:59 <xplat> i best remember reading a summary in Gödel, Escher, Bach.  There's probably also a proof sketch and a reference in the Wikipedia article for Halting Problem
15:09:15 <EvanR> http://www.math.rutgers.edu/~zeilberg/mamarim/mamarimTeX/halt
15:09:44 <EvanR> well this is somewhat more specific
15:10:14 <xplat> optimizing tailcalls to loops in Haskell would probably generally need some help from the inliner :-/
15:10:35 <EvanR> http://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf
15:11:14 <josephle> the proof has some mindtwisting recursive inputs
15:12:56 <geekosaur> Gödel to the ... rescue? ... again
15:16:40 <xplat> luite: btw why do you feel Frege's approach is inappropriate for Haskell?
15:18:14 <gonzaw> hi, I've read about how you can use recursive schemes in Haskell to achieve dynamic programming
15:18:28 <gonzaw> some places say to use dynamorphisms: dyna :: Functor f => (f (Cofree f c) -> c) -> (a -> f a) -> a -> c
15:18:55 <gonzaw> I've been checking the recursion-schemes library (which I'm trying to learn) and I haven't found that function there
15:19:02 <luite> xplat: because it's extremely expensive if almost all values are lazy and much of your evaluation requires repeatedly tail calling until you reach whnf
15:19:25 <gonzaw> Can you implement it in a way that's as efficient as the usual "global mutable array" solution of the imperative world?
15:20:17 <gonzaw> I tried out using histomorphisms from said library using a simple fibonacci example, and it was much much slower than the "common" memoization solution
15:20:36 <gonzaw> so maybe it's not possible to make them as efficient as memoized solutions?
15:22:38 <luite> xplat: admittedly that's only from casual observation from the rts code, they might not have these problems in practice if they do other things differently.
15:23:45 <xplat> i guess.
15:24:22 <xplat> in general i'd rather have a slowish jvm backend than none at all or one that crashes, though
15:24:29 <luite> xplat: but under GHC's formalism, functions always return a value in WHNF, so the only thing the RTS could do with a returned continuation is call it immeidately. since this happens so often it'd be extremly wasteful to use dynamic allocation for that
15:26:15 <luite> if you want slow, just use ghcjs code and some jvm based js implementation ;)
15:26:30 <cwraith> ghcjs + rhino!
15:27:15 <xplat> luite: i kinda want the ffi to work a little better than that though ...
15:28:37 <xplat> ermine actually runs interpreted, and it still gets used instead of haskell for, um, some things, because those things must be deployed on JVM and talk to Java code...
15:30:02 <xplat> (the record system is great too, but not great enough to get it used if it didn't run on the jvm i think ...)
15:32:25 <luite> xplat: do you need lighter weight threads than jvm threads?
15:33:06 <xplat> luite: hm, i would rather have those ...
15:34:01 <xplat> i don't mind a small constant factor slowdown like 1-2 orders of magnitude, but 3 orders of magnitude is too much and i think that could happen on thread-heavy code
15:34:03 <mmaroti> I am using type families and have a data type with "type Shape d :: * -> *". How can I create an instance where the Shape is the identity, i.e. I want Shape a = a?
15:34:37 <xplat> (even with 2 it would have to be closer to 1 for most things and 2 only in bad cases)
15:36:36 <c_wraith> mmaroti: I'm not sure you can, given the kind signature...
15:36:58 <c_wraith> mmaroti: I suppose it depends on the kind of d, though
15:37:00 <luite> xplat: for JS the decision might've been a bit easier. since there are no (shared memory) threads at all it was either implement them or going completely non-concurrent. it works pretty ok now, but integration with the underlying platform is a bit tricky at some points
15:37:42 <mmaroti> "newtype Identity a = Identity a" would almost work (it has kind * -> *) but does not satisfy "Identity a = a".
15:38:49 <mmaroti> Ops, I want "(Shape d) a = a", and I would get "(Shape d) a = Identity a".
15:39:13 <luite> xplat: that's mostly due to gui code requiring immediate responses, or code calling into the ghcjs expecting a function to return something, rather than spawn a thread in the backround. having threads at all (like the jvm) would make this much easier to deal with)
15:39:24 <c_wraith> mmaroti: ah.  Yeah, pretty sure you can't do that with the type family as written.
15:41:24 <c_wraith> mmaroti: if you can change the definition of the type family, you might be able to write it as type Shape (d :: * -> *) (a :: *) :: *
15:41:58 <luite> xplat: ghcjs code is now faster than handwritten js code by the way! http://stackoverflow.com/questions/28106229/how-can-this-haskell-program-compiled-to-javascript-be-faster-than-javascript
15:42:05 <c_wraith> mmaroti: depends on how it's used, but it might work.
15:42:33 <Pamelloes> Is Int a monoid?
15:42:37 <c_wraith> mmaroti: (syntax in examples is assuming it's an associated type, of course)
15:42:56 <c_wraith> Pamelloes: Int is not an instance of the Monoid class because it has infinite possible implementations
15:42:56 <EvanR> Int has at least two monoid instances exposed via newtypes
15:43:02 <joelteon> GHCJS doesn't depend on glibc, does it?
15:43:12 <mmaroti> And can you write a type constructor, which takes two types d1 :: * -> * and d2 :: * -> * and produces a type constructor d12 :: * -> (*,*)?
15:43:18 <Pamelloes> EvanR: Where are they defined?
15:43:26 <EvanR> c_wraith: infinite? ;)
15:44:02 <c_wraith> EvanR: I suspect so
15:44:02 <EvanR> Pamelloes: Data.Monoid
15:44:13 <EvanR> but Int is a finite set
15:44:17 <Pamelloes> Thanks :)
15:44:33 <c_wraith> EvanR: finite, but the bound isn't specified!  :P
15:44:48 <EvanR> lol
15:45:10 <luite> joelteon: uh the compiler itself is a haskell program ocmpiled by ghc, so it would probably depend on it on some platforms :)
15:45:13 <c_wraith> there always could be a bigger implementation than the current one!
15:45:15 <Pamelloes> EvanR: Isn't the amount of implementations determined by the number of valid implementations of <>?
15:45:44 <c_wraith> Pamelloes: well, sort of.  It needs <> and mempty as a pair to be valid by the monoid laws
15:45:49 <athan> If a rose tree looks like `data RTree a = Node a [RTree a]`, would a co-rose tree look like `data CoRTree a = CoNode { val :: a, parent :: CoRTree a }` ?
15:45:55 <mmaroti> What I mean a lambda which works with types. With data I can write "\x y -> (\z -> (x z, y z))" but can you do this with types as well?
15:46:15 <luite> joelteon: the generated code doesn't, but perhaps some references to it show up in the generated code because of some cruft from comments from the preprocessor or from included files generated by autoconf
15:46:19 <EvanR> for a given finite set, there are finite number of distinct monoids, since theres a finite number of functions from the cartesian product of the set to the set
15:46:22 <c_wraith> mmaroti: haskell does not have type-level lambdas.  They would break a *ton* of things most people depend on implicitly.
15:46:28 <joelteon> no types can't do partial application
15:46:56 <joelteon> luite: i just mean because I tried to eval a GHCJS package using nix and I got an evaluation error in glibc/default.nix, but i'm on OSX
15:47:04 <joelteon> so I think someone in the nix ecosystem messed up
15:47:26 <c_wraith> mmaroti: in particular, it's currently true that (f a ~ g a) implies (f ~ g).  Type-level lambdas would break that.
15:47:57 <Pamelloes> I need to take more math classes....
15:48:05 <joelteon> or fewer
15:48:16 <Pamelloes> joelteon: More. Definitely more.
15:48:22 <c_wraith> Pamelloes: very little of the math I use in this channel was learned in classes. :)
15:48:38 <joelteon> and you can't even do OO in Haskell anyway
15:48:38 <luite> joelteon: oh weird. i usually just install with Cabal on OS X
15:48:39 <c_wraith> Pamelloes: it mostly came from hanging out in this channel and asking questions.
15:49:05 <mmaroti> How could that be true? I can write wit type families a data type which declares embedded types violating what you wrote, no?
15:49:25 <Pamelloes> c_wraith: Don't ruin my dreams D:
15:49:54 <benmachine> I learnt some category theory at university
15:50:01 <benmachine> that's been relevant, ish
15:50:02 <geekosaur> math classes aren't dreams, mostly >.>
15:50:08 <luite> joelteon: it doesn't have any special dependencies, just the ghc package, haskell-src-exts and a bunch of other haskell packages. there are some foreign library dependencies lib libterminfo, but nothing out of the ordinary
15:50:18 <xplat> luite: wow
15:50:19 <joelteon> okay, someone in nix screwed up then
15:50:21 <Pamelloes> geekosaur: Depends on how many hours of sleep you have.
15:50:41 <Pamelloes> At a certain point reality and dreamality become indistinguishable.
15:50:53 <c_wraith> mmaroti: well - type families break that syntactically - but only in terms of syntax.  This works because type families always are resolved to their concrete type during compilation.
15:50:58 <monochrom> add "nightmare" to the mix
15:51:04 * geekosaur is probably better at that one than you are, actually...
15:51:08 <c_wraith> mmaroti: it would break in a different way with type-level lambdas.
15:51:27 <Pamelloes> mm?
15:51:40 <geekosaur> best not to ask :)
15:51:48 <Pamelloes> Are you talking about the text thingy?
15:52:02 <mmaroti> "class Some1 d where type Shape1 d :: *", and another class Some2 with Shape2, now have two instances with Shape1 Int = Shape2 Int = Bool, but certainly Shape1 not the same as Shape2
15:52:06 <geekosaur> reality and dreams becoming indistinguishable
15:52:10 <monochrom> you know, "should I take math classes?" is a question only "I" can answer. unless you have a USB 3.0 port in your head so you can upload your brain for a full analysis.
15:52:14 <Pamelloes> Ah.
15:52:54 <xplat> mmaroti: actually type lambdas wouldn't violate things just by existing, but they would violate them if they actually inhabited arrow kinds.  (type families don't inhabit arrow kinds, which is why they don't break things.)
15:52:54 <geekosaur> (no, this does not happen in contexts when I am able to be on IRC.)
15:52:56 <Pamelloes> monochrom: Fortunately my USB 3.0 port is not in my head! Don't want none of dem scientists running 'speriments on me.
15:53:13 <geekosaur> I'd be more worried about the hackers than the scientists
15:53:22 <monochrom> well, there is another group who can answer, I guess. the group of people who will profit from your taking math classes, e.g., math teachers. they will answer "yes", clearly.
15:53:33 <SrPx> is there any standard function like "foo = if x > 0 then floor x else ceiling x" as well as teh opposite ?
15:53:43 <SrPx> (or obvious way to do it)
15:53:44 <Pamelloes> geekosaur: You can't hack a usb port if it isn't hooked up to a network.
15:54:12 <josephle> in F-omega, type lambdas inhabit arrow kinds, but don't break things like equality
15:54:13 <monochrom> SrPx: is it "truncate"?
15:54:42 <SrPx> thanks :)
15:54:48 <monochrom> the Big Four are floor, ceiling, round, truncate
15:55:31 <SrPx> monochrom: I guess there is no opposite for truncate ? That is, the next integer further than 0
15:55:33 <monochrom> but I guess none of them do the opposite of truncate
15:55:40 <SrPx> ah I see
15:55:54 <monochrom> however, use conjugation. - (truncate (- x))
15:55:58 <SrPx> just noticed I can use signum, though, since I'm on the unit range :)
15:56:10 <luite> xplat: hehe that's an outlier, obviously, carefully handwritten JS working with mutable arrays will likely continue to outperform ghcjs by a large margin in the foreseeable future, but having GHC's rewrite infrastructure available should make it possible to win against directly using immutable data structures in JS. making tight loops really fast in JS/GHCJS will require ES6 tail calls and the new code generator i'm working on now though
15:56:11 <SrPx> monochrom: cool!
15:57:25 <SrPx> monochrom: hmm actually I guess that is the same as truncate :P
15:59:39 <luite> xplat: the new codegen uses an intermediate representation that's less closely tied to JS than the current one (which is basically JMacro with some optimizations), it'd be a better starting point than the current one if you wanted to adapt it for JVM. not sure if it'd be better than the Cmm backend
16:17:05 <fbpsd> hello… i am new to this group and exploring…  I know how great Haskell is and thought if more people get interested in it then we would see lots of exceptionally well written and efficient code and I thought to myself If there was an easier way to learn and/or program using pre-written code components so it would be like building an app with some configuration and minimal programing and my research led me to flow based progr
16:17:20 <benzrf> fbpsd: you got cut off
16:17:32 <benzrf> "program using pre-written code components"
16:17:33 <hpc> "flow based progr"
16:17:37 <benzrf> these are called libraries :)
16:18:08 <fbpsd> well i am thinking of components as group of libraries that work together
16:19:12 <benzrf> what
16:20:32 <fbpsd> have u seen http://noflojs.org/
16:35:35 <bramgg> Using Clay how can I load a color from Data.Map? http://lpaste.net/119111
16:36:07 <bramgg> "Couldn't match expected type 'Color' with actual type 'Maybe a0'"
16:36:41 <hpc> you need to account for the case where the map doesn't have the key
16:43:13 <bramgg> hpc: thanks, do I need to have something like jcast's second block of code in this SO answer every time I want to get a color? http://stackoverflow.com/a/25457410
16:44:00 <hpc> something like it, yes
16:44:04 <hpc> @hoogle Maybe a -> a -> a
16:44:06 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
16:44:07 <lambdabot> Prelude asTypeOf :: a -> a -> a
16:44:07 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
16:45:01 <hpc> you can write something like lookupColor :: Color -> Map String Color -> Color, to have a good default color if one isn't defined
16:45:33 <hpc> and then do things like textColor = lookupColor "#000" and backgroundColor = lookupColor "#FFF"
16:45:49 <hpc> or whatever other abstraction fits what you want
16:45:59 <bramgg> hpc: thanks!
16:48:26 <bramgg> hpc: rather than have a palette function and a lookupColor function could I just define "palette" within the lookupColor function?
16:50:41 <unknownloner> What's a good basic web library? All I really need is routing and URL parameter parsing (like sinatra for anyone who's used ruby), don't want something as complex as yesod
16:51:14 <bramgg> unknownloner: I'm a total noob to Haskell and find Scotty quite simple
16:51:54 <unknownloner> from the example, looks like what I want
16:51:56 <unknownloner> thanks
16:52:03 <bramgg> np
16:59:47 <m-r-r> Hello
17:00:14 <m-r-r> Where can I find examples of web applications writtent in Haskell ?
17:01:55 <bramgg> m-r-r: github
17:01:58 <ph88> can i install the new version of haskell platform without losing my cabal stuff ?
17:02:25 <R0b0t1> m-r-r: look at yesod, there are examples using it in the first few results
17:03:16 <athan> m-r-r: https://github.com/athanclark/hi-basic-web-server
17:03:21 <athan> you'll need `hi` though
17:03:28 <athan> (I'm trying to make things better)
17:03:36 <athan> Also, Snap and Haapstack are great :)
17:03:47 <athan> Scotty / Spock ~ Sinatra, if that helps
17:06:04 <m-r-r> ok, thanks :-)
17:06:10 <athan> (:
17:06:28 <athan> m-r-r: What kind of web development environment are you looking for?
17:06:41 <athan> Something quick, complete, hackable, front-end...?
17:08:08 <Tekus> leaving Clojure for Haskell... let's see what's happen :)
17:08:53 <athan> Tekus: Fair warning, you might get addicted :\
17:08:57 <athan> I literally need haskell
17:09:46 <Tekus> it's a good thing, I listened too many things about it, I beleve you
17:29:34 <chrisdone> k
17:30:01 <benzrf> hello Tekus!
17:30:07 <benzrf> @where to-start
17:30:07 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:30:14 <benzrf> ^this is what u should use to learn haskell
17:31:06 <geekosaur> heh, ok
17:31:08 <geekosaur> @where learn
17:31:08 <lambdabot> https://github.com/bitemyapp/learnhaskell | http://www.seas.upenn.edu/%7Ecis194/spring13/index.html | https://github.com/NICTA/course/
17:31:20 <geekosaur> created that earlier today (in PM)
17:31:35 <EvanR> @where lyah
17:31:35 <lambdabot> http://www.learnyouahaskell.com/
17:31:41 <EvanR> still there ;)
17:31:53 <geekosaur> not sure anyone's willing to just zap it
17:33:24 <benzrf> EvanR: lyah is pedagogically unsound
17:33:25 <benzrf> ;)
17:33:46 <EvanR> the real problem being how popular it is
17:33:57 <EvanR> or wed be going after almost every blog about monads
17:34:19 <athan> it's like... Ruby >_>
17:34:23 <athan> (sorry benzrf)
17:35:00 <benzrf> ruby sux but i like it anyway
17:39:08 * hackagebot SpinCounter 0.0.1 - Lock free Spin Counter  http://hackage.haskell.org/package/SpinCounter-0.0.1 (julek)
17:40:50 <seanmc> I recently posted a question to StackOverflow about an Esqueleto problem I've been having.  If anyone wants to look it over and offer some advice either there or here, I'd appreciate it.  http://stackoverflow.com/questions/28121228/cant-write-double-left-join-using-esqueleto
17:46:27 <hiptobecubic> Has anyone here used Qt stuff from Haskell? Specifically QResources
17:47:37 <geekosaur> last time I checked qthaskell was bitrotting
17:47:59 <geekosaur> oh, hsqml. no idea about that
17:48:29 <geekosaur> I guess qthaskell got removed at some point?
17:48:38 <hiptobecubic> hsqml is nice to use actually. I'm enjoying it
17:48:49 <hiptobecubic> But it leads to the obvious question of how to deal with your qml files
17:49:22 <hiptobecubic> You should be able to compile them into an object that is accessed using Qt's resource management stuff, but I don't know how this would work in haskell
17:55:30 <lf94> s/monad/type/g
18:08:22 <aoeu> hello
18:09:09 <lf94> aoeu yo
18:09:39 <aoeu> lf94: i'm seeking a genius person
18:10:39 <lf94> aoeu: you may be in the right place
18:10:52 <lf94> aoeu: you're definitely speaking to the wrong person though
18:11:24 <aoeu> lf94: why is that?
18:11:43 <aoeu> i'm satisfied with 0 language or technology, not even haskell, and i'm looking for people who look beyond
18:12:07 <lf94> aoeu typing race?
18:12:36 <aoeu> fuck races
18:13:19 <hiptobecubic> aoeu, you are not in the right place.
18:13:37 <aoeu> hiptobecubic: why + what is the right place
18:13:57 <_1_jamar> as sa mean
18:14:42 <hiptobecubic> aoeu, because you aren't interested in haskell and I don't know where the right place is. Try reddit.com/r/futurology or something
18:15:55 <aoeu> hiptobecubic: they're fools at /r/futurology, still my favorite sub
18:16:06 <aoeu> hiptobecubic: i don't dislike haskell, i prefer it to most if not all languages
18:16:32 <aoeu> but i'm sure you guys are not satisfied with it either, and i'm asking if you discovered something better
18:16:47 <_1_jamar> who are you
18:16:52 <_1_jamar> :)
18:18:26 <aoeu> me?
18:18:53 <mseeks> what's a good way to convert integers into hex bytestrings?
18:19:00 <mseeks> Data.Binary involves lazy bytestrings and stuff which is sort of annoying
18:19:21 <mseeks> I feel like among Word8, ByteString, Base16 there has to be a good way
18:23:55 <hiptobecubic> I'm pretty satisfied right now, actually.
18:24:22 <hiptobecubic> Maybe i won't be in a few years, but there's certainly plenty that I don't yet know
18:27:03 <tominc> Does lambda bot still works?
18:27:17 <benzrf> > text "yes i do tominc"
18:27:18 <lambdabot>  yes i do tominc
18:27:34 <Tekus> Thanks benzrf, lambdabot, excelent stuff for learning, I'am on it now
18:27:38 <tominc> thanks :)
18:28:00 <aoeu> hiptobecubic: but you write code by hand.... that's extremely wasteful
18:28:52 <hiptobecubic> aoeu, not compared to what that meant fifteen years ago
18:29:10 * hackagebot TreeCounter 0.0.1 - Wait-free Tree Counter  http://hackage.haskell.org/package/TreeCounter-0.0.1 (julek)
18:29:23 <tominc> > [ x | x <- [1..1000], x mod 3 == 0]
18:29:25 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a2)
18:29:25 <lambdabot>    arising from a use of ‘M78157805265694123773174.show_M78157805265694123773...
18:29:25 <lambdabot>  The type variable ‘a2’ is ambiguous
18:29:29 <hiptobecubic> aoeu, there will always be demand for handmade goods :)
18:30:27 <aoeu> hiptobecubic: hippies, we can do much better
18:30:38 <aoeu> hiptobecubic: what kind of software do people write these days?
18:30:38 <tominc> what's wrong with my list comprehension??
18:31:13 <Tekus> it is innefficent I suppous
18:31:16 <Xeironis> > [ x | x <- [1..1000], x `mod` 3 == 0]
18:31:18 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,...
18:31:18 <hiptobecubic> tominc, `mod`
18:31:31 <Tekus> it is better summing 3
18:31:35 <Tekus> every time
18:31:50 <hiptobecubic> tominc, or alternatively mod x 3
18:32:01 <Tekus> *adding
18:32:08 <tominc> oh, sure
18:32:10 <hiptobecubic> tominc, and you should be using rem anyway for this.
18:32:16 <tominc> mod is a function, right?
18:32:25 <hiptobecubic> yes, but you're using it like an operator
18:32:33 <hiptobecubic> so you need to wrap in `` to make it infix
18:33:06 <tominc> i forgot about this :x
18:33:13 <tominc> thank you sir
18:33:53 <Tekus> for programming contest, should I learn Haskell Platform libraries? or just GHC
18:35:50 <tominc> > fold (+) [x | x <- [1..1000], x `rem` 3 == 0]
18:35:52 <lambdabot>  No instance for (GHC.Show.Show t0)
18:35:52 <lambdabot>    arising from a use of ‘M40697955376549510613282.show_M40697955376549510613...
18:35:52 <lambdabot>  The type variable ‘t0’ is ambiguous
18:36:49 <tominc> They really need to improve that error messages
18:37:17 <mseeks> why does `(Data.ByteString.Base16.encode . Data.ByteString.Lazy.toStrict . Data.Binary.encode) 4` give "0000000004" ?
18:37:24 <glguy> They'll be easier to see if you do you expressiveness
18:37:32 <mseeks> does toStrict introduce the padding?
18:37:42 <glguy> Experiments in ghci locally instead of in an irc channel
18:39:18 <glguy> Binary encodings for many types are fixed width to avoid encoding the length alongside
18:42:35 <joness> > sum [x | x <- [1..1000], x `rem` 3 == 0]
18:42:36 <lambdabot>  166833
18:53:57 <tromp_> > sum [1..1000`div`3]
18:53:58 <lambdabot>  55611
19:03:50 <tominc> what is the big difference between mod and rem??
19:04:51 <joness> > mod (-2)
19:04:52 <lambdabot>  <Integer -> Integer>
19:04:58 <systemfault> :t rem
19:04:58 <lambdabot> Integral a => a -> a -> a
19:05:04 <joness> > mod (-2)
19:05:05 <lambdabot>  <Integer -> Integer>
19:05:07 <systemfault> :t mod
19:05:08 <lambdabot> Integral a => a -> a -> a
19:05:18 <cjenkin1> tominc, http://stackoverflow.com/questions/5891140/difference-between-mod-and-rem-in-haskell
19:05:36 <joness> > mod 10 (-3)
19:05:37 <lambdabot>  -2
19:05:41 <joness> > rem 10 (-3)
19:05:42 <lambdabot>  1
19:09:12 * hackagebot TreeCounter 0.0.2 - Wait-free Tree Counter  http://hackage.haskell.org/package/TreeCounter-0.0.2 (julek)
19:10:07 <tominc> now i get it, thanks guys :D
19:10:25 <cjenkin1> np
20:07:33 <sgronblo> could someone help me figure out how to use quickcheck's choose to create a property?
20:15:10 <sgronblo> I really wish Haskell docs had more examples
20:24:44 <athan> sgronblo: That's what ghci is for :)
20:26:04 <lpaste> nurupo pasted “summing.hs” at http://lpaste.net/3747451341916602368
20:27:15 <glguy> nurupo: You've got your map read and map show crossed
20:27:39 <nurupo> glguy: "crossed"?
20:28:04 <glguy> exchanged, flipped, transposed
20:28:45 <glguy> (for one)
20:29:25 <glguy> there's an "unwords" to complement words, also
20:29:30 <nurupo> words converts String -> [String], map read should convert [String] -> [Int], simpleSum [Int] -> [Int], map show [Int] -> [String]
20:29:34 <sgronblo> Ok, I made it a bit further
20:30:00 <sgronblo> I found Test.QuickCheck.Modifiers
20:30:07 <glguy> nurupo: I think you're thinking of the (.) operator "backwards"
20:30:49 <glguy> (f . g) x = f (g x)
20:30:52 <nurupo> oh, i will go read what . does again :)
20:36:22 <Sumang> hi expert, I am trying  to compile the code in the Monad.Reader Issue 19, and getting the errors below. who knows why?
20:36:26 <Sumang> {-# LANGUAGE FlexibleContexts, Rank2Types, ScopedTypeVariables #-}  import Control.Monad (liftM ) import Control.Monad.Trans (MonadTrans (..))  newtype Trampoline m r = Trampoline { bounce :: m (Either (Trampoline m r ) r ) }  instance Monad m => Monad (Trampoline m) where return = Trampoline . return . Right t >>= f = Trampoline $ (bounce t) >>= (either (return . Left . (>>=f )) (bounce . f ))   a.hs:9:23:     Ambiguous occurrence  
20:36:54 <Sumang> should I post the code here? or is  there somewhere to post?
20:36:59 <geekosaur> @paste
20:36:59 <lambdabot> Haskell pastebin: http://lpaste.net/
20:37:49 <sgronblo> Ok, now I think it's working! How cool.
20:38:01 <Sumang> paste in http://lpaste.net/119124
20:38:19 <Sumang> I got the error msg " Ambiguous occurrence  return "
20:38:26 <Sumang> who knows why?
20:38:51 <geekosaur> line 9 needs to be indented
20:39:02 <geekosaur> it's a top level redefinition as is, not the instance definition
20:39:18 <sgronblo> Aah, and you restrict the type classes when you define the instance of some other typeclass for your newtype, not when you define the actual newtype...
20:39:20 <geekosaur> same with line 10
20:39:42 <geekosaur> well, when you don't indent you are defining a local completely new thing not related to the typeclass at all
20:40:18 <Sumang> oh, cool, like a magic, works now!
20:40:42 <Sumang> Thanks!
20:43:03 <nurupo> glguy: thanks, i had it *all* backwards! :)
20:43:18 <nurupo> fixed with "main = interact (unlines . map show . simpleSum . map read . words)"
20:43:33 <nurupo> now it works as supposed :)
20:43:44 <glguy> Good to hear ^_^
20:47:09 <sgronblo> how do i search for all functions that return CreateProcess?
20:47:12 <sgronblo> in hoogle?
20:47:36 <Clint> @hoogle a -> CreateProcess
20:47:39 <lambdabot> Prelude id :: a -> a
20:47:39 <lambdabot> Data.Function id :: a -> a
20:47:39 <lambdabot> GHC.Exts breakpoint :: a -> a
20:49:40 <sgronblo> I guess that means this was the most specific hits it could get?
20:53:48 <johnw> I usually just hoogle for CreateProcess and then go to the docs
20:54:21 * hackagebot pipes-concurrency 2.0.3 - Concurrency for the pipes ecosystem  http://hackage.haskell.org/package/pipes-concurrency-2.0.3 (GabrielGonzalez)
21:00:58 <Zemyla> <Jsor> Every real computer is just a disgusting perversion of our Father, the one-tape unary Turing Machine, and our Mother, the untyped lambda calculus.
21:12:55 <shachaf> ReinH: If you mean the "fmap id = id --> fmap (f . g) = fmap f . fmap g" thing, it's not begging any questions, it's just making an assumption, namely that the type F is a functor. In just about every case where people use this, F is indeed a functor, because they don't try writing Functor instances otherwise.
21:13:51 <Cale> shachaf: That sounds more like making use of parametricity?
21:14:15 <Cale> But I missed the context
21:14:34 <shachaf> Cale: The usual proof that you just need to prove the first law uses the free theorem for foo :: (a -> b) -> F a -> F b
21:15:00 <shachaf> But the free theorem assumes that F is a functor, i.e. that you have $map_F, and then proves that if foo id = id then foo = $map_F
21:15:28 <shachaf> So saying "you just need to prove the first law for your Functor instance" isn't quite enough -- you also need to know that it's a functor for the reasoning to work.
21:15:43 <shachaf> At least I've never seen anything showing otherwise.
21:16:04 <shachaf> (I'm pretty sure in Haskell 2010 it *is* sufficient. But I don't know with GHC extensions etc.)
21:16:27 <shachaf> Well, moderately sure.
21:17:59 <Cale> hmmmm
21:24:12 <ellipsis_> how can I manually release a ConnectionPool from persistent?
21:25:06 <ellipsis_> I don't want to use withMySQLPool but it doesn't provide a function for releasing the connection pool
21:25:34 <Axman6> that's wht type of withMySQLPool?
21:25:38 <Axman6> the*
21:26:03 <ellipsis_> withMySQLPool :: (MonadIO m, MonadLogger m, MonadBaseControl IO m) => ConnectInfo -> Int -> (ConnectionPool -> m a) -> m a
21:26:43 <Axman6> so, when that function returns, it should be released, if it follows a very common haskell pattern
21:26:50 <ellipsis_> I know
21:26:53 <ellipsis_> but I don't want to use that
21:27:02 <ellipsis_> I'm trying to use createMySQLPool
21:27:05 <Axman6> oh you on't sorry, misread
21:31:07 <hop__> I asked on #ghc with no success... so :-)  I got a mismatch error with ghc and llvm with archlinux. How do I get the LLVM version I need to install from ghc?
21:31:55 <ellipsis_> hop__: Are you using the normal packages for both?
21:32:03 <hop__> ellipsis_: yes
21:32:22 <ellipsis_> hop__: both are updated?
21:32:22 <hop__> I can try to update both though since llvm is not in the dep list of ghc
21:32:27 <hop__> ellipsis_: :-)
21:32:47 <Axman6> it's possible your llvm is too new. there are plans to shipp the pieces of LLVM that it needs along with ghc in the future to avoid thiese issues
21:33:16 <hop__> Axman6: I got this error yes
21:33:37 <hop__> Axman6, ellipsis_ : I am updating let's see :-)
21:34:44 <ellipsis_> hop__: if it's too new try looking in /var/cache/pacman/pkg for an older version
21:34:44 <hop__> This is just that I was looking at the code from plain ghc and simple inner loop code is kind of terrible
21:35:00 <hop__> ellipsis_: ok
21:35:45 <sgronblo> why would my patter match for (_, Just hout, _, _, _) fail for a call to createProcess?
21:36:00 <hop__> Axman6: what is the latest llvm version supported by ghc?
21:36:33 <Axman6> I'm not sure, sorry
21:36:42 <Axman6> 3.4 should be fine I think
21:36:58 <sgronblo> sorry i put one _ too many in that tuple in here
21:36:58 <geekosaur> sgronblo, did you specify CreatePipe for std_out?
21:37:08 <sgronblo> geekosaur: nope?
21:37:14 <sgronblo> oh
21:37:24 <sgronblo> just like in this ls example
21:37:26 <geekosaur> functions can't examine the result context to decide what to return
21:37:39 <geekosaur> so to get it to return a Just you need to explicitly tell it to create a pipe
21:38:19 <Astrocoder> In Soviet Russia, Monad >>= YOU!
21:38:29 <hop__> ellipsis_, Axman6 : same with latest. llvm 3.5 is used by arch. So, I need to get something older
21:39:21 <sgronblo> { std_out = CreatePipe } ah this is the "update syntax" right?
21:39:39 <geekosaur> iirc you need 3.4. 3.5 broke code gen iirc, and a patch was put into llvm HEAD recently
21:39:46 <geekosaur> sgronblo, yes
21:40:13 <systemfault> One Monad to rule them all... and in the darkness >>= them!
21:40:34 <geekosaur> "shell" and "proc" produce records, and you use update syntax to modify them
21:41:18 <sgronblo> geekosaur: it works now, thanks
21:41:30 <sgronblo> i forgot i could use the update syntax
21:41:42 <sgronblo> so i felt a bit locked in with creating by using just shell or proc
21:57:49 <gonzaw> hi, does someone know how to do efficient dynamic programming using recursion schemes?
22:02:08 <mmachenry> gonzaw: I suggest asking a more specific question.
22:02:34 <mmachenry> Probably a lot of people here do know a lot about that. First rule of IRC. Don't ask to ask. Just ask.
22:02:53 <gonzaw> sorry, just wanted to know if someone was around haha
22:03:04 <mmachenry> Yep. I'm around. Hi.
22:03:09 <gonzaw> I was checking out the recursion-schemes library
22:03:21 <gonzaw> and was toying around with histomorphisms (with the trivial fibonacci example)
22:03:38 <gonzaw> but found it much slower than manually memoizing the function
22:04:18 <gonzaw> Then I also read about dynamorphisms, which kind of generalize this kind of dynamic programming
22:04:43 <gonzaw> and I wondered if it's possible to make an implementation of them as efficient as manually memoizing functions
22:05:29 <gonzaw> for dynamorphisms I'm not even sure how to implement it, since I couldn't find it in the recursion-schemes source
22:05:33 <mmachenry> Well sadly I don't know anything about that library. But maybe someone will read that.
22:07:39 <gonzaw> For reference, the type of dynamorphisms is this: dyna :: Functor f => (f (Cofree f c) -> c) -> (a -> f a) -> a -> c
22:08:53 <gonzaw> I just thought it would be so cool to basically have "generic dynamic programming" that's fully optimized and as fast as the mutable imperative algorithms
22:09:42 <gonzaw> Sadly I can't seem to find much resources about this using Haskell, just some papers here and there
22:10:34 * mjrosenb hopes for a long shot
22:11:09 <mjrosenb> @hoogle a -> (a -> Either b c) -> [a] -> ([b],[c])
22:11:11 <lambdabot> No results found
22:11:20 <mjrosenb> blast
22:11:26 <mjrosenb> @djinn a -> (a -> Either b c) -> [a] -> ([b],[c])
22:11:26 <lambdabot> Error: Undefined type []
22:11:33 <glguy> gonzaw: recursion-schemes is just code associated with a paper, it's not something you use to write programs
22:11:40 <mjrosenb> stupid djinn :-p
22:13:06 <mmachenry> mjrosenb: That's an odd type. What's the function applied to? the a you give it or the list of a's? I'm guessing the list since you're returning lists.
22:14:02 <mjrosenb> oh, derp, that a-> should not be at the beginning
22:14:11 <mjrosenb> @hoogle (a -> Either b c) -> [a] -> ([b],[c])
22:14:11 <lambdabot> No results found
22:14:39 <mmachenry> That looks a lot more reasonable. You probably want split?
22:15:12 <mjrosenb> like SAT questions mapMaybe :: Maybe = _ :: Either
22:16:03 <mmachenry> :t partition
22:16:04 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
22:16:36 <mmachenry> That's close but then you need to break apart your function into what would return b or c and also map the results after.
22:16:58 <mjrosenb> yup
22:17:10 <mjrosenb> also all this is *technically* in a monad
22:17:25 <mjrosenb> I wrote it myself, but I wanted to see if it already existed somewhere.
22:19:29 <platz> wasn't there an extension planned in the future to enable strict evaluation for a whole file?
22:21:14 <platz> ahh https://ghc.haskell.org/trac/ghc/wiki/StrictPragma
23:04:47 <xnil> is there a hoogle bot here?
23:11:58 <pavonia> There's a lambdabot plugin for hoogle
23:12:03 <pavonia> @hoogle a -> a
23:12:04 <lambdabot> Prelude id :: a -> a
23:12:04 <lambdabot> Data.Function id :: a -> a
23:12:04 <lambdabot> GHC.Exts breakpoint :: a -> a
23:17:09 <xnil> pavonia: thanks
23:17:43 <xnil> @hoogle (Ord a) => a -> a
23:17:44 <lambdabot> Prelude max :: Ord a => a -> a -> a
23:17:44 <lambdabot> Data.Ord max :: Ord a => a -> a -> a
23:17:44 <lambdabot> Prelude min :: Ord a => a -> a -> a
23:19:06 <xnil> @hoogle String -> IO ()
23:19:06 <lambdabot> Prelude putStr :: String -> IO ()
23:19:06 <lambdabot> System.IO putStr :: String -> IO ()
23:19:06 <lambdabot> Prelude putStrLn :: String -> IO ()
23:29:28 * hackagebot imports 0.1.2.1 - Generate code for importing directories automatically  http://hackage.haskell.org/package/imports-0.1.2.1 (CindyLinz)
