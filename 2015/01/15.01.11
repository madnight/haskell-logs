00:00:26 <EvanR> ex falso quodlibet !
00:00:37 <M-x> In fact, it doesn't needed at all, since strings can be instances of exceptions too, so the code would remain exactly the same
00:00:51 <EvanR> you really dont need or want exceptions here
00:01:42 <M-x> EvanR: just to be clear: by exceptions I mean just that Exception typeclass, not Java-or-whatever style exceptions
00:02:06 <EvanR> the Exception type class is a special class for Java-or-whatever style exceptions specifically
00:02:13 <EvanR> so youre confused
00:02:17 <EvanR> and confusing me
00:03:18 <M-x> Hmm, I guess we have a terminology problem here. :)
00:04:33 <EvanR> youd do Left "heres whats wrong", thats the convention
00:04:42 <EvanR> and its not even that different from Try
00:04:56 <EvanR> (if youre indeed ignoring Exceptions)
00:05:36 <EvanR> wrecklessly dividing by zero or trying to launch missiles isnt validation
00:06:18 <gamegoblin> Hey foks, I just got a compiler error I haven‚Äôt seen before
00:06:23 <gamegoblin> Grants-MacBook-Pro:Chess grant$ ghc Chess.hs -O2
00:06:24 <gamegoblin> [1 of 1] Compiling Main             ( Chess.hs, Chess.o )
00:06:26 <gamegoblin> ghc: panic! (the 'impossible' happened)
00:06:27 <gamegoblin>   (GHC version 7.8.3 for x86_64-apple-darwin):
00:06:29 <gamegoblin> 	find_tycon
00:06:30 <gamegoblin>     main:Main.Square{d r38}
00:06:32 <gamegoblin>     [main:Main.Square{d r38} defined at Chess.hs:232:9,
00:06:33 <gamegoblin>      main:Main.Square{d r38} parent:main:Main.Square{tc r3b}
00:06:35 <gamegoblin>        defined at Chess.hs:224:15]
00:06:36 <gamegoblin> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
00:06:36 <EvanR> please lpaste that
00:06:40 <gamegoblin> Whoops
00:06:48 <gamegoblin> Didn‚Äôt realize I copied all ten lines
00:06:52 <gamegoblin> thought I just copied the last one
00:07:09 <gamegoblin> Anyway, what is "the impossible" the error refers to?
00:07:14 <EvanR> theres #ghc if no one answers here about that
00:07:16 <gamegoblin> Any ideas?
00:08:38 <M-x> EvanR: yep, my only concern was that if one function does Left "oops" and another does Left 42, then we can't easily combine them
00:09:19 <EvanR> M-x: well, your life is a lot easier if you use something that does "42", which is actually whats happening most of the time
00:10:21 * hackagebot doctest 0.9.12 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.12 (SimonHengel)
00:10:21 * hackagebot total 1.0.0 - Exhaustive pattern matching using lenses, traversals, and prisms  http://hackage.haskell.org/package/total-1.0.0 (GabrielGonzalez)
00:11:18 <EvanR> M-x: (alternatively, at each step you can take steps that you think makes sense with the error values to get them to "combine into one" whatever that means)
00:11:45 <EvanR> the only example i can think of in "oops" 42 case is to convert the 42 to a string
00:12:17 <EvanR> of course it might vary wildly for all the different kinds of possible error data structures it might be, but thats what you asked for
00:12:48 <M-x> EvanR: yeah, returning maps of some values would be more realistic example
00:13:09 <EvanR> maps of what?
00:14:09 <EvanR> in theory, you could have a bunch of libraries agreeing to unify on one data structure Data.Map Text Dynamic, essentially java script objects
00:14:12 <M-x> I dunno, something like causes of an error and such
00:14:24 <EvanR> and youre entire program can now fit in any way you want
00:14:27 <EvanR> including wrong ones
00:14:37 <EvanR> basically a dynamically typed exception sub-language
00:14:51 <EvanR> and you could use throws to do control flow instead of using the language like normal ;)
00:15:19 <M-x> lol
00:16:09 <M-x> Well, instead of Data.Map that bunch of libraries could use well-defined set of types too
00:16:45 <EvanR> and different types from this set combine with each other?
00:17:30 <EvanR> sounds more like its one type with a different way of combining than a string does
00:17:40 <EvanR> and youre suggestion is to switch from String to TypeX
00:17:54 <EvanR> your*
00:19:43 <M-x> Yeah, instead of "expected positive, given {x}" use WrongArgument "expected positive" x
00:19:46 <M-x> Something like that
00:20:16 * hackagebot streaming-commons 0.1.8.1 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.8.1 (MichaelSnoyman)
00:20:28 <EvanR> yeah ruby has about ten exception classes like that intended to cover all possible validation problems, they are mostly unused in real life
00:20:59 <EvanR> you have to use them sometimes locally because its the only way to detect this when using a basic parser
00:23:14 <EvanR> another idea here is that by trying to come up with "generic" tools to cover several imagined use cases, youve actually made the error space less general than a String
00:23:29 <EvanR> assuming you want all the libs to use it
00:25:07 <M-x> But no reason to make this set closed
00:27:54 <M-x> (by 'this set' I mean the set of the error types)
00:28:18 <EvanR> which is why Either e doesnt only work with Either String or Either SomeException
00:28:24 <EvanR> its already generalized
00:28:43 <EvanR> i only brought up that X instead of Y because you said they need to be able to combine
00:29:13 <EvanR> and you cant seriously combine any two types X and Y in a general way
00:29:57 <EvanR> :t (+)
00:29:58 <lambdabot> Num a => a -> a -> a
00:30:04 <EvanR> :t (<>)
00:30:05 <lambdabot> Monoid m => m -> m -> m
00:30:51 <M-x> EvanR: not any, only those implementing MyException typeclass. :)
00:31:03 <EvanR> :t convert
00:31:04 <lambdabot>     Not in scope: ‚Äòconvert‚Äô
00:31:04 <lambdabot>     Perhaps you meant ‚Äòcover‚Äô (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
00:31:16 <EvanR> M-x: how do you propose this class works ;)
00:33:03 <M-x> EvanR: well it could contain conventional getCause and getMessage functions
00:33:23 <EvanR> which do what?
00:33:40 <M-x> Instance for string would return Nothing on getCause and itself on getMessage, for example
00:34:09 <EvanR> ... what does getCause do?
00:35:48 <M-x> Just returns the error you've passed to, in case you want to save information about cause of the error you returning
00:36:01 <EvanR> what is the error?
00:36:11 <EvanR> you cant define the thing youre defining with itself ;)
00:36:40 <M-x> Error is any instance of that MyError typeclass
00:37:16 <EvanR> so this other error has also a getCause and getMessage?
00:37:41 <M-x> Well, of course
00:37:46 <EvanR> until you run out of causes
00:38:02 <EvanR> you described something isomorphic to a list of strings ;)
00:38:37 <M-x> List of pairs of string and arbitrary objects rather
00:39:14 <fragamus> MonadCatchIO-mtl-0.3.0.5 failed during the building phase. The exception was:
00:39:16 <fragamus> ExitFailure 1
00:39:16 <fragamus> can someone tell me WTF
00:39:43 <EvanR> M-x: thing is, the kind of "arbitrary objects" that you are thinking of is Dynamic
00:40:03 <EvanR> so [(Dynamic, String)]
00:40:55 <EvanR> M-x: so, this is not a type class
00:42:39 <M-x> EvanR: why dynamic? Say we have some `ConcreteError code message`. Than in any place of the program we can get the message via MyError's getMessage and in those places where we know ConcreteError is returned we can also get the code.
00:43:02 <EvanR> you dont need getMessage first of all, just Strings
00:43:21 <supki> fragamus: the real error is usually earlier in the log
00:43:36 <EvanR> for the arbitrary object, you all in the same data structure, then you need a way to distinguish them apart
00:44:00 <M-x> getMessage for string would just return the string, getMessage for 42 would return "42", etc
00:44:37 <EvanR> i understand youre describing something in scala, but im just trying to help you understand ;)
00:44:54 <EvanR> theres more to it
00:45:14 <fragamus> well I'm trying to install hack-contrib
00:46:20 <M-x> EvanR: I don't quite understand. If I may return FooError from function f, then haskell will infer it's return type as Either FooError. Then for g let it be BarError. Then if I return f or g, then it would be MyError e => Either e, isn't it?
00:46:40 <EvanR> no
00:47:01 <M-x> Why?
00:47:21 <M-x> I fail to see why is it impossible to infer such cases
00:47:38 <EvanR> lets write out the type for the function youre talking about
00:48:30 <EvanR> h :: MyError e => X -> Either e Y
00:48:42 <EvanR> if we put the explicit forall...
00:48:54 <EvanR> h :: MyError e => forall e . X -> Either e Y
00:49:13 <EvanR> now however you write this h, it must work for all types that implement MyError
00:49:34 <EvanR> f :: Z -> Either FooError Y
00:50:30 <EvanR> if you use this to implement h, it wont type check, because FooError is a specific type. if the caller of the function chooses to get back an Either BazError Y, your function wont work
00:51:05 <EvanR> in h :: MyError e => forall e . X -> Either e Y, the client of this function gets whatever e they want back (that implements the class)
00:52:16 <M-x> Hmm, let me think about it
00:52:28 <mikeplus64> EvanR: should that be forall e. MyError e => ...
00:52:52 <EvanR> yep
00:53:05 <EvanR> forall e . MyError e => X -> Either e Y
00:57:16 <gamegoblin> > foldr (-) 4 [8,15,16,23,42]
00:57:18 <lambdabot>  24
00:57:37 <EvanR> :t (-)
00:57:37 <lambdabot> Num a => a -> a -> a
00:58:12 <EvanR> > (-) 5 4
00:58:13 <lambdabot>  1
00:58:17 <EvanR> > subtract 5 4
00:58:18 <lambdabot>  -1
00:59:05 <M-x> I've googled this: https://www.haskell.org/haskellwiki/Existential_type but not sure yet whether it's relevant to the topic or not (it seems to me like we need exist e instead of forall e in the above definition, not realized yet whether existential types are about this or not)
01:00:11 <d12frosted> Any optparse-applicative experts here? :D
01:00:55 <EvanR> M-x: this would be necessary to return a list of error data structures of various types. of course, you have to decide on the uniform interface that something would have to these types
01:01:11 <EvanR> which you have decided was, a string
01:01:45 <EvanR> any use of existential types can be refactored in this way, to just provide the values of the "methods" or a closure to a record of the methods if its a mutation
01:03:00 <EvanR> whats nice about haskell is that it forces you to think this stuff out, rather than concentrating on what shape your data structure is in, you must concentrate on how you will use it, and leave the implementation details aside
01:04:59 <EvanR> you tried to say "ill use it however i want" and the best you can do is Dynamic, which lets you basically do the equivalent of a type case
01:05:27 <EvanR> this makes you code a lot less general though, paradoxically
01:06:54 <vin-ivar> hey
01:07:05 <vin-ivar> can somebody help me out a bit with the CIS 194 course?
01:07:21 <M-x> EvanR: another nice thing about haskell is that whenever I ask any question in here I end up spending the whole day reading about some of its type system extensions. :)
01:07:34 <vanila> sure vin-ivar
01:07:38 <EvanR> you should stop reading about extensions and start writing programs ;)
01:07:43 <vin-ivar> well
01:07:45 <vin-ivar> www.seas.upenn.edu/~cis194/spring13/hw/05-type-classes.pdf
01:07:50 <vin-ivar> the last question
01:07:56 <M-x> EvanR: I don't think I'm quite ready yet. :)
01:08:08 <vin-ivar> I have to implement an instance Expr (M.Map String Integer -> Maybe Integer)
01:08:49 <vin-ivar> the typeclass has a function lit :: Integer -> a
01:09:13 <vin-ivar> so the way I see this, I need lit to return a function that take a map and returns a Maybe Integer?
01:09:18 <vanila> so in this case would that be:   Integer -> M.Map String Integer -> Maybe Integer  ?
01:09:29 <vanila> you could just do:  lit i _ = Just i  then
01:09:37 <M-x> EvanR: anyway, thanks a lot for the discussion, I really appreciate it. Gotta hang here more often I guess. :)
01:10:29 <vin-ivar> but that's a Maybe Integer. shouldn't it return a function, rather than the Maybe Integer directly?
01:10:56 <vanila> it does
01:10:59 <vin-ivar> oh no wait
01:11:01 <vin-ivar> hang on
01:11:13 <vanila> x -> y -> z can b seen as a function that returns a function, or a function taking two parameters
01:11:25 <vin-ivar> okay, so you shift the map as a useless parameter to the left side
01:11:25 <vanila> you can write lit i = \_ -> ... or lit i _ = ...
01:11:27 <vin-ivar> ?
01:11:34 <vanila> its all the same because of currying
01:11:37 <vin-ivar> aah
01:11:38 <vin-ivar> I see
01:11:48 <vin-ivar> wait, let me wrap my head around it first
01:12:24 <vanila> > let plus x y = x + y in map (plus 3) [7,17,97]
01:12:25 <lambdabot>  [10,20,100]
01:12:28 <vanila> there's an example
01:12:32 <vanila> > let plus x = \y -> x + y in map (plus 3) [7,17,97]
01:12:33 <lambdabot>  [10,20,100]
01:12:35 <vanila> and written the other way
01:16:20 <vin-ivar> i get the typeclass bit now
01:16:27 <vin-ivar> but I'm not sure I understand your example
01:16:35 <vin-ivar> oh no wait
01:16:37 <vin-ivar> I do
01:17:10 <vin-ivar> cheers
01:17:12 <vin-ivar> thanks :)
01:17:17 <vanila> :)
02:05:20 * hackagebot calculator 0.1.3.0 - A calculator that operates on string inputs  http://hackage.haskell.org/package/calculator-0.1.3.0 (sumitsahrawat)
02:11:26 <DerisiveLogic> Is it possible to run haskell code on bash by any chance?
02:12:27 <hamid_> DerisiveLogic, On bash? #!/usr/bin/env runhaskell
02:16:05 <DerisiveLogic> hamid_: It seems to not be working unfortunately, I get nothing.
02:17:11 <hamid_> DerisiveLogic, what about runghc?
02:18:53 <DerisiveLogic> hamid_: Yeah that doesn't work either, absolutely nothing happens.
02:19:19 <hamid_> hmm
02:19:32 <DerisiveLogic> hamid_: What works for you?
02:19:43 <DerisiveLogic> I also installed haskell on my mac if that counts for anything.
02:20:14 <hamid_> DerisiveLogic, try `runhaskell foo.hs`
02:20:29 <bramgg> How can I have my forkIO functions complete? Right now they're ending as soon as "main" ends. Example: http://lpaste.net/118243
02:20:50 <hamid_> DerisiveLogic, i tried this on my linux and it worked but right now i have no haskell installed here :/
02:21:23 <DerisiveLogic> hamid_: <no location info>: can't find file: foo.hs
02:21:43 <hamid_> DerisiveLogic, `foo.hs` is your script file :D
02:22:50 <DerisiveLogic> hamid_: Oh wow, awesome!
02:22:57 <DerisiveLogic> hamid_: It works.
02:23:27 <mpickering> bramgg: There are two ways listed at the bottom of Control.Concurrency
02:23:38 <mpickering> they are not that nice though
02:23:52 <mpickering> another alternative is to use `async`
02:24:10 <bramgg> thanks, i'll look into that
02:30:21 * hackagebot djinn-ghc 0.0.2.3 - Generate Haskell code from a type. Bridge from Djinn to GHC API.  http://hackage.haskell.org/package/djinn-ghc-0.0.2.3 (AlejandroSerrano)
02:40:22 * hackagebot stackage 0.5.1 - "Stable Hackage," tools for creating a vetted set of packages from Hackage.  http://hackage.haskell.org/package/stackage-0.5.1 (MichaelSnoyman)
02:48:54 <RaceCondition> given: left x = Right 3, why does :type x yield `Num b => Either a b` and how do I find out which types has Haskell inferred a and b to be?
02:49:05 <RaceCondition> let x = Right 3, I meant
02:49:14 <vanila> those are variables
02:49:19 <vanila> it means they can be any type
02:49:34 <vanila> that's because it doesn't know what the Left side is yet, so it could be anything
02:49:46 <vanila> similarly, it doesn't know what type of number you're using - just that it is a number
02:51:17 <RaceCondition> coming from Scala, Right(3) would be inferred to be Either[Nothing, Int] (where Nothins is bottom type and can be used in place of any other type) -- doesn't Haskell do something comparable?
02:51:51 <jle`> well, a couple of concepts are at play here
02:51:58 <jle`> "3" is actually a polymorphic literal
02:52:05 <jle`> it can be any type that is an instance of Num
02:52:10 <jle`> Int, Integer, Double, Float, etc.
02:52:25 <jle`> haskell always infers the most general type possible
02:52:37 <RaceCondition> OK, that's easy to understand, but is the left side of the Either actually inferred to be the bottom type?
02:52:44 <RaceCondition> like in Scala
02:52:47 <vanila> no
02:52:55 <vanila> there is no bottom type or any sort of subtyping
02:53:02 <vanila> what you have is a type variable
02:53:08 <vanila> it can be instantiated to be any type
02:53:19 <jle`> haskell doesn't have subtyping, basically
02:53:45 <RaceCondition> I know that but https://www.haskell.org/haskellwiki/Bottom
02:54:30 <RaceCondition> but then as I understand, it's not really a type because it takes whatever shape
02:54:32 <jle`> this seems to be an unrelated thing
02:54:38 <jle`> bottom is a value, not a type
02:54:43 <jle`> "value"
02:55:08 <jle`> in haskell, bottom is a concept that applies at the value level
02:55:23 <jle`> values are bottom, not types.
02:55:50 <RaceCondition> ok, that's where the difference lies then
02:56:13 <jle`> i think in practice it's different than what you mean by "bottom type" in scala
02:56:20 <jle`> even though i suspect the name comes from a similar root
02:57:08 <RaceCondition> it's otherwise the same -- it's an instance of any other type, and you can use it like you do `undefined = error "..."` in Haskell
02:58:25 <RaceCondition> I mean, analogous at least, obviously not the same...
02:58:55 <vanila> > Right 3 :: Either Bool Int
02:58:56 <lambdabot>  Right 3
02:59:00 <vanila> > Right 3 :: Either String Double
02:59:01 <lambdabot>  Right 3.0
02:59:21 <vanila> you can make the 'a' variable be anything, and the 'b' variable any number type
03:00:02 <vanila> that's what the type: Num b => Either a b means
03:00:45 <RaceCondition> vanila: yes, and it works the same in Scala
03:00:58 <vanila> its different in scala
03:01:39 <RaceCondition> vanila: I only mean this: http://pastebin.com/Vxwp1GBj
03:02:27 <RaceCondition> I understand the mechanism by which this works is very different but the effects are very similar, no?
03:02:41 <vanila> yeah
03:03:31 <vanila> so it will probably be confusing if you try to understand haskell type system in terms of scala
03:03:39 <RaceCondition> sadly, Scala doesn't automatically enable your types to use type classes
03:04:08 <RaceCondition> vanila: I won't; I'm just learning by comparison, because they are similar enough in the end
03:04:43 <RaceCondition> probably considered blasphemy by many to have said that :P
03:05:05 <vanila> haha
03:06:24 <J_Arcane> I poked at a Scala tutorial the other day but I find the Java syntax pretty painful. XD
03:10:31 <ski> jaspervdj : SYN
03:15:23 * hackagebot olwrapper 0.3.7.15 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.3.7.15 (thomas84)
03:18:17 <gamegoblin> What‚Äôs the best (easiest, fastest) way to set a particular index in a Data.Vector ?
03:20:43 <Taneb> Fastest'd be something horrible with mutable vectors and ST
03:22:09 <gamegoblin> Any chance you can show an example? Never used ST
03:22:29 <trunks1ace> zip of 2 lists gives pairwise combinations of elements, is there some variation that gives all possible combinations of elements?
03:22:49 <gamegoblin> trunks1ace: [(a,b) | a <- firstList, b <- secondList]
03:23:18 <trunks1ace> gamegoblin: ofcourse! thanks
03:23:40 <gamegoblin> trunks1ace: or, if you want to be fancy, you can use applicative ‚Äî (,) <$> firstList <*> secondList
03:23:43 <gamegoblin> I think would do it
03:23:57 <vanila> I think thatll give the cross product
03:23:58 <gamegoblin> > (,) <$> [1,2,3] <*> "abc"
03:23:59 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
03:24:03 <gamegoblin> works
03:24:04 <vanila> instead you could write zip [1,2,3] "abc"
03:24:11 <vanila> oh you wanted cross product
03:24:18 <gamegoblin> he wanted cartesian product
03:25:00 <gamegoblin> trunks1ace: or, monads work also liftM2 (,) firstList secondList
03:25:09 <gamegoblin> trunks1ace: lots of ways to do it ;)
03:26:13 <trunks1ace> gamegoblin: All look good but im noob so ill go for the first for now haha
03:26:28 <gamegoblin> trunks1ace: 100% the best option as far as readability and intent go
03:26:57 <gamegoblin> trunks1ace: the first option actually is just syntactic sugar around the monad instance of a list
03:27:10 <gamegoblin> do a <- firstList
03:27:17 <gamegoblin>    b <- secondList
03:27:20 <gamegoblin>    return (a,b)
03:27:35 <gamegoblin> but that doesn‚Äôt matter for you now
03:29:08 <trunks1ace> gamegoblin: really, thank god for syntactic sugar then >_<
03:29:26 <gamegoblin> trunks1ace: it‚Äôll all make sense soon enough
03:29:30 <RaceCondition> J_Arcane: I find the hybrid nature of Scala actually helped me approach Haskell
03:29:36 <RaceCondition> I find the hybrid nature of Scala actually helped me approach Haskell
03:30:00 <J_Arcane> RaceCondition: I think my problem is 1) I don't know Java, and 2) I'm allergic to curly brace syntax.
03:30:50 <jle`> i like liftA2
03:30:52 <RaceCondition> J_Arcane: 1) it's really just C based syntax (and I despise Java) 2) I'd use Lisp syntax everywhere if I could -- it's the most "editable" syntax around
03:31:50 <J_Arcane> RaceCondition: I am primarily a Lisp programmer (Racket & Heresy), so I agree heavily with #2, but I like the 'light' syntax in Haskell and F# quite a bit more as well.
03:33:16 <RaceCondition> J_Arcane: I prefer how the light syntax looks, but I prefer how I can operate on sexp based syntax -- I wonder if I can make Emacs let me operate on light syntax as it if were sexp based.. so that in memory, everything is parsed into sexps, so there are virtual parens everywhere I can rely on
03:34:02 <RaceCondition> and this could be applied to any language out there
03:34:32 <J_Arcane> F# has done some interesting experiments on that front, and I think Haskell as well. F# has a quote form that actually returns the AST for the quoted syntax, so you can do mangling with it. It's obv. not as easy as s-exps of course, but I was intrigued by what I saw.
03:34:48 <vanila> what do you do once you mangled the syntax?
03:35:47 <therp> J_Arcane: while lisp has arguably the best syntax, it doesn't necessarily do a good job exposing you to all the semantics out there. you are losing out in the long run by not turning a blind eye to other people's disgusting syntax choices :)
03:36:31 <J_Arcane> therp: Well, I did mention Haskell there. ;) I quite love Haskell syntax as well; in fact I'm getting so used to it lately I keep forgetting I'm not in Haskell when I develop Heresy stuff.
03:36:31 <RaceCondition> not sure if we're talking about the same thing... I mean e.g. foo $ bar (f 3) $ baz 4 => (foo (bar (f 3)) (baz 4)), except the parens aren't rendered in the buffer, but all Lisp editing commands work
03:37:52 <RaceCondition> so if I put my cursor on the 2nd $ and do sexp-transpose, I get `foo $ baz 4 $ bar (f 3)`
03:39:41 <J_Arcane> In particular, despite initially hating my first exposure to it (Clojure's threading macros), I'm finding I really love having compositional operators like Haskell's (.) or F#'s |> forward pipe.
03:40:04 <eternaleye> Hey, I'm trying to work with a Distribution.PackageDescription, and I'm not finding any clear information on what the "Maybe" side of condTreeComponents is used for.
03:40:39 <eternaleye> Could someone familiar with Cabal's innards please enlighten me?
03:41:11 <eternaleye> (I'm writing an automated translator from Cabal to Exheres, a distro format)
03:42:45 <RaceCondition> J_Arcane: is |> really a compositional operator? thought it was just function application
03:42:55 <gamegoblin> jesus christ I was representing a chess board as a Map Square (Piece, Player) but then I changed it to a Vector (Maybe (Piece, Player)) and got like 100x speedup
03:43:02 <gamegoblin> didn‚Äôt realize the speed difference
03:43:11 <exio4> function composition is >> and << in F#
03:43:32 <therp> am I missing something, or should the documentation for Data.Packed.Matrix not be a broken link on https://hackage.haskell.org/package/hmatrix-0.16.1.3 ?
03:44:03 <therp> also my local cabal install --enable-documentation fails to write documentation for Data.Packed.*
03:45:47 <quchen> therp: Hackage has been having some problems building documentation automatically lately. When maintainers didn't upload docs themselves, docs are often broken for newer versions.
03:47:25 <therp> quchen: my local "cabal" probably suffers from the same problem as hackage. I am using hsenv just in case that matters. I see Data.Packed.* showing up in my haddock coverage report though. strange.
03:48:17 <quchen> I don't think the problem exists on the client side.
03:52:15 <J_Arcane> RaceCondition: Well, it's sort of more like the Clojure macro. x |> f y = f y x, roughly. So you can write long chains of composed functions in the order they apply, left to right instead of right to left.
03:52:38 <calvinx> I am trying to figure out how to use the ‚Äúdo‚Äù block.  can I know why the 2nd implementation fails? http://lpaste.net/118244
03:53:00 <calvinx> and how should I correct it so that it will compute AND print out the computed value.
03:53:25 <therp> quchen: looks like this is special to hmatrix "(Other modules are exposed with hidden documentation for backwards compatibility.)" nevermind. thanks for your answer though
03:53:27 <vanila> calvinx, you can't make it compute before printing out but y <- return $ x + 2 ; print y   (instead of show y)  could help
03:53:30 <vanila> this will bein IO monad
03:53:53 <mpickering> calvinx: do you know how do blocks desugar? I would recommend starting with that
03:54:10 <calvinx> I read something about >== and return
03:54:15 <calvinx> didn‚Äôt quite understand it
03:54:30 <exio4> J_Arcane, with lazy evaluation, the order actually the other way; and it's just flip ($)
03:54:34 <exio4> @type (&)
03:54:35 <lambdabot> a -> (a -> b) -> b
03:55:10 <exio4> > 2 & (+2) & (*3) & (:[]) & map (*4)
03:55:12 <lambdabot>  [48]
03:55:37 <J_Arcane> Cool, I didn't know that operator.
03:57:04 <RaceCondition> J_Arcane: yeah, I know what it is; scalaz also has it
03:57:06 <exio4> it's in lens, but you can define it yourself
03:58:56 <mpickering> calvinx: it would be good to understand how to use >>= and return before using do notation as..
03:59:18 <mpickering> @undo do {x <- f; return $ g x}
03:59:18 <lambdabot> f >>= \ x -> return $ g x
04:00:19 <mpickering> then you will see that the program you tried to write isn't the correct approach
04:00:25 <trunks1ace> gamegoblin: back again, how can I iteratively give combinations of lists, for example in a list of lists, the first list and the second list, then that new list with the third list and so on...
04:00:40 <calvinx> nice @undo trick. Thanks!
04:00:44 <gamegoblin> trunks1ace: can you give an example
04:01:04 <calvinx> mpickering: okay, will go re-read the >>= and return chapter.
04:02:12 <calvinx> @undo do { y <- return $ x + 2; putStr ‚ÄúThis is what I want ‚Äú; print y }
04:02:12 <lambdabot> <unknown>.hs: 1: 35:Illegal character ''\128''
04:02:34 <calvinx> @undo do { y <- return $ x + 2; putStr ‚ÄúThis is what I want ‚Äù; print y
04:02:34 <lambdabot> <unknown>.hs: 1: 35:Illegal character ''\128''
04:02:42 <calvinx> @undo do { y <- return $ x + 2; putStr ‚ÄúThis is what I want ‚Äù; print y }
04:02:42 <lambdabot> <unknown>.hs: 1: 35:Illegal character ''\128''
04:02:56 <matematikaadit> @undo do { y <- return $ x + 2; putStr "This is what I want "; print y }
04:02:56 <lambdabot> return $ x + 2 >>= \ y -> putStr "This is what I want " >> print y
04:03:27 <calvinx> ah strange. how come it didn‚Äôt work for me.
04:03:57 <calvinx> @undo do { y <- return $ x + 2; putStr "This is what I want "; print y }
04:03:57 <lambdabot> return $ x + 2 >>= \ y -> putStr "This is what I want " >> print y
04:03:58 <matematikaadit> calvinx: see ‚Äú and "
04:04:08 <calvinx> ugh. my irc client warps my ‚Äú
04:04:18 <mpickering> calvinx: Also, if you add a type signature to g then the error should be clearer
04:07:02 <trunks1ace> gamegoblin: so i have this list [[(1,True),(1,False)],[(2,True),(2,False)|],[(3,True),(3,False)]] and want to give all combinatoins of the first two elements: [[(1,True),(2,True)],[(1,True),(2,False)],[(1,False),(2,True)],[(1,False),(2,False)] and then all combinations of this new list with the third elemnt of the first list and so on for an abritrary number of elements in the first list
04:08:02 <gamegoblin> trunks1ace: you‚Äôre going to run into problems because you are creating types out of nowhere
04:08:06 <trunks1ace> gamegoblin: so basically all combinations of an arbitrary number of lists
04:08:28 <gamegoblin> trunks1ace: try to think what the type signature of your function would be
04:10:01 <trunks1ace> gamegoblin: yeah thats whats happening so far, it gave type errors, if I explain what im trying to do perhaps you could suggest an alternative solution
04:11:20 <gamegoblin> trunks1ace: I suggest you think what you want the type signature of your function to look like. When you can answer that, I think the solution will be more clear
04:21:00 <quchen> Is there a way to get the value of a cabal.config setting via cabal?
04:21:31 <quchen> "cabal setting shared" ===>  false
04:21:48 <gamegoblin> is vector a monad the same way list is a monad?
04:23:19 <quchen> Yes
04:23:36 <quchen> return = singleton, bind = flip concatMap
04:23:45 <gamegoblin> ah, awesome, thanks
04:41:48 <statusfailed> Hm. What's a faster way to parse a space-separated list of ints than using "(map read . words) <$> getLine"
04:41:52 <statusfailed> I can't install any libraries
04:43:03 <statusfailed> oh apparently I can use bytestring, nevermind
04:44:29 <wei2912> statusfailed: you appear to be optimizing for some progrmaming competition/challenge?
04:44:44 <wei2912> statusfailed: if so you should take a look at your algorithm instead
04:45:00 <statusfailed> wei2912: nah, it's IO unfortunately haha
04:45:06 <wei2912> statusfailed: :P
04:45:07 <statusfailed> wei2912: I have a linear time solution (i'm pretty sure)
04:45:15 <statusfailed> wei2912: I actually checked just the IO
04:45:25 <statusfailed> reading 1 million ints takes more than the timeout
04:45:29 <statusfailed> on my VM at least
04:45:36 <wei2912> statusfailed: lol
04:45:47 <statusfailed> but good guess with the competition =D
04:45:54 <wei2912> that must be a strict time limit
04:46:06 <wei2912> ... either that or your hard drive is really slow
04:46:16 <statusfailed> it's a crappy vm. I'm guessing theirs is similar :p
04:46:30 <wei2912> well
04:46:31 <wei2912> possibly
04:47:05 <twanvl> This
04:48:04 <statusfailed> wei2912: just summing the list instead of trying solve the problem takes 12s :-)
04:48:25 <wei2912> statusfailed: wow
04:49:48 <wei2912> statusfailed: well, good luck with the competition
04:51:09 <statusfailed> wei2912: just a challenge, but thanks :-)
04:54:18 <simukis_> chinese: gen wo men gang gang yi yang üòÉ
04:54:47 <simukis_> oh dang
04:54:51 <simukis_> wrong window
04:54:53 <simukis_> sorry
04:55:14 <statusfailed> simukis_: mei shi
04:55:54 <simukis_> statusfailed: honestly i don‚Äôt even know what it means, it just sounds very hilarious when read in my language.
04:56:21 <statusfailed> hahah, apparently it means "it's just like what happened to us"
05:01:02 <deni> anyone using vim and syntastic? For some reason it stopped working for me with the latest ghc-mod
05:01:31 <titusg> trying to install ghc-mod in emacs from melpa I get "Error during download request: Not Found"
05:02:47 <deni> ah nevermind...found this https://gist.github.com/yuga/6612105
05:14:58 <mazhksaly> hello haskellers of the world, I am having trouble installing gtk using cabal install (using latest cabal ver, and windows 7, having downloaded the latest glade 3) "the pkg-config package 'glib-2.0' is required but it could not be found"
05:15:12 <mazhksaly> does anyone know how to fix this?
05:16:31 <titusg> Do you have cygwin installed?
05:17:24 <mazhksaly> no, but I have mingw. should I install cygwin?
05:17:57 <random-jellyfish> yep
05:18:07 <random-jellyfish> mingw is very minimalistic
05:18:14 <titusg> idk not a windows user but it might help. check with someone who knows what they're on about, sorry
05:18:16 <random-jellyfish> used mostly for scripting
05:19:08 <mazhksaly> I will try it, thanks for the tip
05:20:04 <titusg> My problem with ghc-mod and emacs: http://stackoverflow.com/questions/27887424/installing-ghc-mod-from-melpa-error-during-download-request
05:31:41 <nmarasoiu> Hi! I am a 12-year Java developer and 2-year hobbist in functional programming; do you know if it is realistic to search for a remote job in functional programming, be it games, web platform or anything? Thank you
05:33:00 <Taneb> nmarasoiu, I think it is
05:35:06 <nmarasoiu> what are you guys using haskell for? is it for aliving, for a hobby?
05:36:52 <mazhksaly> I installed cygwin, added its bin to PATH variable, but cabal still cannot install glib, do you know why this is so?
05:38:57 <ski> i'd presume one'd need a version of `cabal' that's built for CygWin, if one wants to use it
05:42:36 <mazhksaly> I also have Ubuntu installed on my desktop, will it be easier just switching systems to code in haskell? I am more used to windows, but getting everything going has been a real pain in the ass
05:43:21 <ski> there are people here who develop on windows, iirc
05:44:06 <ski> depending on what you're used to, you could possibly SSH from your windows machine
05:44:45 <ski> (assuming you have access to more than one. one could also ponder virtualization)
06:05:04 <sdx32> hi, I'm atm. trying to get an idea of how to write interactive programs in haskell. For this purpose I implemented the nim-game, like this http://lpaste.net/118246 - I'm mostly concerned of getMod and the concept around it: how would I (in a haskellish way) solve the problem of too high substract values (which modifyBoard currently takes care of)?
06:09:46 <ski> sdx32 : you possibly want `i :: Int <- readLn' rather than `c <- getLine; let i = read c :: Int'
06:09:52 <ski> (`readLn' calls `readIO')
06:11:45 <sdx32> ski: ah, this is nice
06:12:58 <ski> instead of `take (t-1) b ++ [mt] ++ drop t b', you can use `front ++ [mt] ++ back', `where (front,x:back) = splitAt (n-1) b', and replace `b !! (t-1)' by `x'
06:13:12 <quchen> You possibly want to not use read at all.
06:13:19 <quchen> > read "hello" :: Int
06:13:21 <lambdabot>  *Exception: Prelude.read: no parse
06:13:34 <quchen> > readMaybe "hello" :: Maybe Int
06:13:35 <lambdabot>  Not in scope: ‚ÄòreadMaybe‚Äô
06:13:40 <quchen> ‡≤†_‡≤†
06:13:50 <notdan> sdx32: I would move the `if c > m ' check up a little bit
06:14:02 <notdan> you don't need `n' to preform it
06:14:10 <ski> btw, you don't need to use `exitSuccess' in this case
06:14:15 <matematikaadit> @let import Safe
06:14:17 <lambdabot>  Defined.
06:14:37 <matematikaadit> > readMaybe "hello" :: Maybe Int
06:14:38 <lambdabot>  Not in scope: ‚ÄòreadMaybe‚Äô
06:14:38 <lambdabot>  Perhaps you meant ‚ÄòreadMay‚Äô (imported from Safe)
06:14:44 <SrPx> Hello, does anyone know a library that symbolically solves equations such as "f(t) = a + b*t, g(t) = c + d*t, find f(t) == g(t)?"
06:14:46 <matematikaadit> > readMay "hello" :: Maybe Int
06:14:47 <lambdabot>  Nothing
06:15:31 <ski> > readMay "  0123  " :: Maybe Integer
06:15:33 <lambdabot>  Just 123
06:15:50 <bernalex> > readYolo "hello" :: Maybe Int
06:15:52 <lambdabot>  *Exception: Prelude.read: no parse
06:16:09 <sdx32> notdan: that's the kind of direction im concerned with. That check is quite easy to do, needs only the board-length as parameter. But the check, how much I may substract needs the whole board - which is mixing up logic and IO
06:16:17 <matematikaadit> :t readYolo
06:16:18 <lambdabot> Read a => String -> a
06:16:25 <ski> SrPx : unification of polynomials ?
06:16:32 <matematikaadit> what is readYolo?
06:16:46 <sdx32> quchen: indeed, I'd have overlooked this.
06:17:00 <SrPx> ski: uhm it could have sin, tan and exp too... if that is a problem
06:17:07 <bernalex> matematikaadit: the correct name for what is today "read". ;-) "read" should behave like "readMay".
06:17:17 <quchen> sdx32: There's readMaybe in Text.Read that gives you Nothing if there's no parse
06:17:23 <ski> SrPx : yes, it makes it quite a lot harder :)
06:17:23 <quchen> Not sure why Lambdabot doesn't haveit
06:17:30 <SrPx> so, unification of algebraic formulas, is that a hard problem? that sounds like it is
06:17:59 <SrPx> I'm happy with fast approximate solutions though, if that is a thing
06:18:24 <SrPx> anyway, if it was just polynomials then there is something? ski
06:18:53 <ski> SrPx : just unify corresponding coefficients
06:19:32 <matematikaadit> lol. it's user defined then. I thought that there are something like that in the packages that lambdabot imported
06:19:38 <ski> (well, at least over integers, rationals, reals .. i think that doesn't work for any ring)
06:24:49 <Xnuk> > [x|x<-[1..], x<7]
06:24:52 <lambdabot>  mueval-core: Time limit exceeded
06:25:30 <Xnuk> > take 6 [x|x<-[1..], x<7]
06:25:32 <lambdabot>  [1,2,3,4,5,6]
06:31:29 <sgronblo> So I managed to get one solution for N Queens by using Data.Graph.AStar. But I would have liked a dfs algorithm instead that can deal with a similar "functionally defined" graph. Is there something like this available?
06:32:17 <sgronblo> Oops, I guess DFS relies on having access to all nodes from the start...
06:32:55 <sgronblo> no wait, im confused
06:40:48 <sdx32> so, i took over the suggestions - http://lpaste.net/8694409284928143360 - however, I've still the question: How do i properly / haskellish separate logic and interaction?
06:41:51 <sdx32> e.g. I've still to check, whether one entry is already 0 before allowing this index (in c)
06:44:48 <vanila> hi
06:49:27 <NightRa> Is there a Category f => Monoid (f a a) somewhere?
06:55:23 <SrPx> ski: hmmmm
06:55:32 * hackagebot total 1.0.1 - Exhaustive pattern matching using lenses, traversals, and prisms  http://hackage.haskell.org/package/total-1.0.1 (GabrielGonzalez)
07:12:15 <mr-> NightRa: is Data.Monoid.Endomrophism to your liking?
07:30:28 <belst> hey guys, is there any funky function which does this? \x y -> if x > y then Just (x - y) else Nothing
07:30:58 <belst> so if difference is negative return Nothing
07:31:20 <sipa> :t when
07:31:21 <lambdabot> Monad m => Bool -> m () -> m ()
07:32:19 <sipa> @let nozero x = when (x > 0) $ Just x
07:32:20 <lambdabot>  .L.hs:188:22:
07:32:20 <lambdabot>      No instance for (Num ()) arising from the literal ‚Äò0‚Äô
07:32:20 <lambdabot>      In the second argument of ‚Äò(>)‚Äô, namely ‚Äò0‚Äô
07:36:24 <int-e> :t let nozero x = guard (x > 0) >> Just x in nozero
07:36:24 <lambdabot> (Ord b, Num b) => b -> Maybe b
07:36:53 <int-e> (not the same, but perhaps that's what was intended?)
07:37:55 <int-e> > let gtzero x = guard (x > 0) >> Just x in (gtzero 1, gtzero 0, gtzero (-1))
07:37:56 <lambdabot>  (Just 1,Nothing,Nothing)
07:38:34 <belst> well thats not really shorter than the lambda :D
07:39:26 <int-e> :t let nozero x = guard (x > 0) >> return x in nozero {- it almost has a more general type though -}
07:39:27 <lambdabot> (MonadPlus m, Ord b, Num b) => b -> m b
07:39:29 <ski> belst : so a partial subtraction on natural numbers ..
07:40:16 <ski> belst : note that if you want to allow zero difference, then you should have `x >= y'
07:40:30 <belst> yes sure. dont want zero though
07:41:02 <int-e> belst: with the MonadComprehensions extension, you could write \x y -> [x - y | x > y]
07:41:11 <ski> well .. you said "so if difference is negative return Nothing" (which doesn't explicitly say what's to happen in the other cases, so `\_ _ -> Nothing' would also be ok, if only going by that)
07:41:39 <belst> in other cases return Just $ x - y
07:41:49 <belst> I wrote the lambda
07:41:55 <belst> \x y -> if x > y then Just (x - y) else Nothing
07:42:07 <ski> `x == y' is one of those other cases, since `x - y' is then not negative
07:42:52 <ski> (i'm just pointing out a small discrepancy between your code, and your description/specification of it. you have to decide which (if any) is what you wanted)
07:44:20 <belst> my lambda is what i want :D i was just curious if there was any function which would do this without a lambda seems like there isnt
07:48:30 <twanvl> :t \x y -> find (>0) [x-y]
07:48:30 <lambdabot> (Ord a, Num a) => a -> a -> Maybe a
07:48:58 <vanila> nice :)
07:54:35 <athan> Is it okay to have overlapping type family instances?
07:56:11 <thevishy> any recommended books for haskell ?
07:56:35 <thevishy> practical approach books
07:56:49 <Thooms> Real World Haskell
07:56:52 <athan> thevishy: Bird & Walder's Intro to Functional Programming
07:57:04 <athan> oh shoot practical approach
07:57:25 <athan> that one is like an intro to rigour and math programming
07:57:55 <thevishy> http://learnyouahaskell.com/introduction is the one I got from google search
07:58:04 <thevishy> I don't mind rigour and math programming btw
07:58:18 <thevishy> alongside a practical book like eloquent javascript
08:00:04 <iElectric> so I use blaze and want to calculate some time diff based on current time and write it to html
08:00:26 <iElectric> I fetch Channel data from sql, having UTCTime stored in there
08:00:58 <iElectric> I take it it's bad to mix pure blaze code with IO
08:01:14 <iElectric> so it's best to map the Channel and create another type holding the time diff?
08:04:24 <athan> Is there a way to manually promote data types?
08:05:09 <vanila> promote?
08:18:18 <EvanR> :t fromIntegral (127 :: Word8)
08:18:20 <lambdabot> Num b => b
08:22:10 <ski> athan : hm, prefix by apostrophe or something ?
08:27:42 <malochsky> I just migrated to ubuntu because I was having a hard time making everything work out in windows, but now I cannot find my .cabal folder to add it to path (currently, I am experiencing that issue in which the cabal install that comes with the platform is the one being used and I cannot upgrade it)
08:27:58 <malochsky> as I am a newbie on ubuntu, can any one of you help me ?
08:28:52 <deni> does anyone have an example at hand for modeling http calls with types? (perhaps using Free) ?
08:29:59 <athan> ski: But how would I create my own kinds? :s
08:31:44 <hyper123> can anynone help me convert this python code to haskell, im desperate, have no idea how to do it. Gonna flunk tomorrow :(  Its part of bigger project, have real problems with converting procedural code... http://pastebin.com/bP3uSPVC
08:32:25 <athan> ski: Oh wait, data Foo :: BOX works
08:32:39 <athan> ...maye
08:32:43 <athan> maybe*
08:34:39 <HeladoDeBrownie> malochsky, $HOME/.cabal/bin is the directory. do you already know how to append to your path?
08:35:36 * hackagebot possible 0.1.0.1 - Three valued Data.Maybe  http://hackage.haskell.org/package/possible-0.1.0.1 (tolysz)
08:37:40 <malochsky> HeladoDeBrownie I do not know how to do it... I cannot browse through the system's GUI to that folder, though I can find it through the terminal (I would like to be able to open it visually)
08:38:28 <geekosaur> xdg-open ~/.cabal
08:38:43 <HeladoDeBrownie> malochsky, your gui file manager will usually hide files beginning with .; if you want to show them, you may be able to find an option in the menu.
08:38:50 <geekosaur> alternately something like ctrl-l or cmd-l may open a location dialog
08:39:10 <geekosaur> er win-l (super-l)
08:39:29 <HeladoDeBrownie> malochsky, as for how to add that directory to your PATH, one way is to write in your .bashrc file (create it if it doesn't exist) the following: PATH=$HOME/.cabal/bin:$PATH
08:39:45 <malochsky> thank you so much for your help!!! was able to do it
08:40:22 <HeladoDeBrownie> malochsky, then, after you've run `cabal update && cabal install cabal-install`, you will be using the latest cabal from bash.
08:40:37 <HeladoDeBrownie> (bash is the default shell for that distro among others)
08:40:57 <HeladoDeBrownie> malochsky, make sense?
08:41:23 <HeladoDeBrownie> (i used ` only to delimit commands from other text, you do not need to write them out)
08:41:45 <malochsky> oui, there is just one thing I do not understand... how come are there people disposed to spend time on sunday helping me out with haskell?
08:42:12 <HeladoDeBrownie> i haven't yet figured out what else to do with my sunday :) i'm also playing 3ds right now :P
08:42:52 <malochsky> sounds nice, I am making lunch with my gf and setting up my working environment :)
08:43:00 <HeladoDeBrownie> yesterday i had a birthday party and was exhausted afterwards and now i just want a really calm day
08:50:03 <hyper123> whats equivalent in haskell to while (i<len(rijec)) ?
08:50:54 <c_wraith> hyper123: there's no direct equivalent. That construction has a lot of different potential semantics, and there are different things in haskell for each variant.
08:50:55 <HeladoDeBrownie> hyper123, it depends on how you translate the rest of that
08:51:36 <c_wraith> hyper123: for instance, what changes each iteration? i? len(rijec)? both?  those three cases generally have different translations
08:51:55 <hyper123> HeladoDeBrownie: Im trying to translate pythong code, after that i have bunch if else statements which i can keep in haskell? iterator changes only, words is the same
08:52:09 <c_wraith> hyper123: additionally, what is done in the body of the loop? executing an action for side effects requires different constructs than just returning a value
08:53:00 <hyper123> c_wraith: simple list append in bunch of if else statements, thats the body
08:53:02 <HeladoDeBrownie> hyper123, haskell expressions are not allowed to mutate variables and other things. so, where you might use mutation in python you have a few options for how to translate it into haskell. can you show some code with your attempts so far?
08:53:22 <HeladoDeBrownie> c_wraith, this is a homework assignment, fyi
08:53:47 <hyper123> HeladoDeBrownie: yea it is, have real problem converting procedural to functional code
08:54:11 <HeladoDeBrownie> hyper123, show us what you've tried, even if it's wrong. we can help you work it out from there.
08:54:26 <c_wraith> hyper123: you generally have the best results when you back up a level.  Consider what the loop does, and rewrite that from scratch.  Ignore the syntactic constructions.
08:55:07 <hyper123> c_wraith: let me paste code to pastebin and put it together a bit, will show you, thanks :D
08:55:09 <c_wraith> hyper123: for instance: is the loop a fold? a map? a filter? Some composition of those?
09:01:42 <Lokathor> the mingw that comes with the haskell platform clashed with the other ming install on my computer, and then when i tried to fix it they both ended up killing each other >_<
09:02:05 <hyper123> c_wraith: Here it is http://pastebin.com/AVChteUS Code is too large for pasting whole, i pasted and added comments to get general idea what im trying to do
09:06:10 <hiptobecubic> is "scratchdir" not a thing anymore?
09:07:44 <HeladoDeBrownie> hyper123, did they teach you pattern matching in haskell?
09:08:36 <hyper123> HeladoDeBrownie: yea, but i dont have idea how to apply it here, can u show simple example?
09:09:10 <c_wraith> hyper123: That python code is kind of a mess. I have no idea what it's doing - there's a lot going on with no clear goal.
09:09:53 <hyper123> c_wraith: Its parsing a word to sylabels, there is outer loop and bunch of if else
09:10:22 <hyper123> c_wraith: How should i convert that pattern to haskell?
09:10:37 * hackagebot sitemap 0.1 - Sitemap parser  http://hackage.haskell.org/package/sitemap-0.1 (AlpMestanogullari)
09:10:39 * hackagebot sitemap 0.1.1 - Sitemap parser  http://hackage.haskell.org/package/sitemap-0.1.1 (AlpMestanogullari)
09:11:02 <c_wraith> hyper123: the problem sounds like a state machine. I'd encode it as an explicit one, rather than an implicit one hidden in a mess of ifs
09:11:45 <hyper123> c_wraith: Im not sure what u mean?
09:12:08 <ChristianS> if i make a cabal-installable program, should i tell my users to call "cabal configure && cabal build && cabal install" ? or is just "cabal install" sufficient?
09:12:13 <HeladoDeBrownie> hyper123, instead of computing the length, checking whether it's above a certain number, and then grabbing the element at that position, you can use pattern matching on the left side of the function: f [] = ... ; f [x] = ...; f (x:x2:xs) = ... (x2) -- where ... indicates elided code
09:12:52 <hyper123> HeladoDeBrownie: ahaa, thanks it will help :)
09:13:02 <HeladoDeBrownie> hyper123, so that third case, f (x:x2:xs), only applies to lists of length at least two, and furthermore gives you the values of those two elements, x and x2
09:13:15 <HeladoDeBrownie> hyper123, do you understand how you can rewrite your current code to use that?
09:13:28 <c_wraith> hyper123: yeah..  Don't worry about it.  It's a somewhat more advanced technique that you probably haven't been exposed to if this is homework.
09:14:46 <hyper123> HeladoDeBrownie: I think so
09:15:08 <hyper123> HeladoDeBrownie: Going to try do that now, thanks for the help
09:15:12 <HeladoDeBrownie> hyper123, no problem
09:16:33 <quchen> What's up with a Shake-based GHC build system? I've heard about it every now and then a year ago, did it go anywhere?
09:17:01 <quchen> The wiki page was last edited 3 months ago, but there's no indication of current status
09:20:12 <SrPx> So, does anyone know a library to solve a set of polynomial equations? Or some keywords I can google for?
09:20:58 <HeladoDeBrownie> @hackage polynomial
09:20:58 <lambdabot> http://hackage.haskell.org/package/polynomial
09:21:22 * HeladoDeBrownie found that just now using hackage search
09:28:21 <joneshf-laptop> is base special in some way where you have to use the globally installed version even in a sandbox?
09:28:28 <thevishy> in haskell used in the industry ?
09:29:10 <HeladoDeBrownie> thevishy, yep https://www.haskell.org/haskellwiki/Haskell_in_industry
09:29:57 <thevishy> Thank You HeladoDeBrownie , wil go over that
09:30:55 <tommd> joneshf-laptop: Yes.
09:30:55 <alpounet> joneshf-laptop: ghc will always pick the version of base that was shipped with it, yes
09:34:13 <joneshf-laptop> poop
09:34:14 <joneshf-laptop> okay
09:36:18 <cinimod> Can someone point me at a reference for equality constraints. They aren't part of Haskell 2010. There is some explanation in the ghc user guide but no reference to the theory behind the implementation.
09:37:06 <J_Arcane> thevishy: Microsoft actually uses it in production code. The Bond compiler is in Haskell: https://github.com/Microsoft/bond/tree/master/compiler/Bond
09:38:36 <thevishy> J_Arcane, wow cool didn't guess that
09:39:04 <thevishy> they were doing everything in .net framework
09:41:05 <HeladoDeBrownie> haskell.net confirmed??
09:42:19 <J_Arcane> HeladoDeBrownie: actually, they tried that already. couldn't get it working well, so it was abandoned, and F# was developed instead.
09:42:44 <HeladoDeBrownie> J_Arcane, what about it didn't work so well?
09:43:11 <J_Arcane> I forget precisely, the gist was they just couldn't get the way .NET does things to agree very well with Haskell.
09:43:56 <HeladoDeBrownie> i suppose it would be somewhat inconvenient to expose the entire framework in IO instead of being able to do anything smarter with it
09:48:39 <J_Arcane> .net has very particular ideas of how it wants types to work, and I guess they just don't get along with Haskell's, especially since some of them are explicitly mutable and poorly optimized otherwise.
09:49:13 <J_Arcane> F# is a semi-pure language, owing to compromises with .NET expectations in part I think.
09:50:19 <d-snp> J_Arcane: I think more because it's based on ml, which also is semi-pure right?
09:50:34 <J_Arcane> that too, sure.
09:50:41 <Hijiri> what does semi-pure mean?
09:50:42 <HeladoDeBrownie> ml allows evaluation to have effects, however it does make some effort to expose immutable structures
09:50:42 <d-snp> using the .net standard library from a pure language would be much like using a FFI, not comfortable at all
09:51:21 <HeladoDeBrownie> Hijiri, my guess is that ^ is what was meant
09:51:46 <J_Arcane> Hijiri: it allows you to use mutability when you want. in fact, you can right pretty imperative code in it, if you want to. Kinda like Scheme; it's meant to be functional, but you can write it otherwise if you want.
09:51:48 <Hijiri> oh, ok
09:52:11 <Hijiri> I just don't see how you quantify pureness other than being or not being pure
09:52:23 <Hijiri> I guess it just means that it's not hard to write pure code?
09:52:30 <HeladoDeBrownie> i don't suppose you technically can
09:52:59 <J_Arcane> F# does do a bit more to encourage functional style though, like forcing you to explicitly declare a var as mutable, and disabling some features like closures if mutable values or mutation operations are present.
09:53:51 <HeladoDeBrownie> so impurity is marked in types and is infectious?
09:54:08 <wacco> G'day
09:54:40 <HeladoDeBrownie> wacco, hey
09:54:58 <lb5tr> hello
09:55:11 <HeladoDeBrownie> come to think of it, a system like i just described wouldn't be so different from haskell's
09:55:15 <wacco> anyone mind if I jump right in with a question, or am I interrupting? :)
09:55:20 <HeladoDeBrownie> wacco, feel free
09:55:23 <wacco> cool
09:55:26 <lb5tr> how one can implement applicative redundant function ( *> and <*) using only fmap, pure and <*>?
09:55:32 <deni> when modeling a rest client for a remote api...using free monads and an interpreter...does it make sense to have 2 functions for an api request like so: apiCallM :: URL -> HttRequestM URL and the actual call like so apiCall :: URL -> IO () (where i basically just do "run (apiCallM url)"??
09:55:39 <wacco> newbie here, trying to wrap my head around what the heck I'm fundamentally doing wrong
09:55:52 <deni> or is it just too much bolierplaty
09:55:53 <lb5tr> nvm found it
09:56:07 <lb5tr> forgot that hackage can point me to soure
09:56:14 <wacco> function is given either a char or a string, regardless, add it to the current string
09:56:37 <wacco> for the life of me I can't get around "cannot construct the infinite type: t ~ [t]"
09:56:44 <HeladoDeBrownie> wacco, show what you tried
09:56:51 <d-snp> on lpaste.net :)
09:56:52 <HeladoDeBrownie> wacco, also give the full error message
09:56:54 <wacco> I got it down to
09:56:57 <mreh> how could I quickly and simply, execute some action periodically?
09:56:59 <wacco> wrap q@(_:_) = q wrap q = [q]
09:57:06 <HeladoDeBrownie> wacco, in an lpaste please
09:57:10 <wacco> oops. imagine a newline somewhere
09:57:17 <HeladoDeBrownie> oh, or if it's just one line then that could be fine
09:57:23 <d-snp> it's 2 lines :P
09:57:29 <wacco> hehe
09:57:31 <mreh> threadDelay would probably get out of sync quite quickly
09:58:04 <HeladoDeBrownie> ah, so it is. well the infinite nesting of lists comes from q = [q]. did you know, definitions are recursive in haskell? so the q is the same on both sides of that equation
09:58:19 <HeladoDeBrownie> maybe you wanted to give two different names to two different variables
09:58:20 <d-snp> wacco: the problem is that you can't have overloading functions in haskell
09:58:37 <wacco> more context here; http://lpaste.net/118257
09:58:39 <d-snp> so you can't have the same function wrap both characters and strings
09:58:52 <HeladoDeBrownie> you can but it'd have to take in Either Char String or a similar type
09:59:11 <wacco> well, I originally went for a "show" approach, but didn't want the quotes
09:59:18 <HeladoDeBrownie> which also means you'd construct values sent to it something like Left 'a' and Right "hey"
09:59:27 <ski> wacco : there might be a char that's represented in the same way as a string. how would `wrap' be able to distinguish ?
09:59:35 <wacco> and show's clearly "seeing" the difference between chars and strings, so why can't I
09:59:44 <d-snp> eh oh yeah you could make a typeclass I guess
09:59:50 <HeladoDeBrownie> typeclass is overkill for this
10:00:06 <HeladoDeBrownie> but yeah, show is a typeclass method
10:00:27 <wacco> is that the GADT business google came up with?
10:00:31 <HeladoDeBrownie> no
10:00:50 <wacco> well so much for my ~Fu then :p
10:00:54 <HeladoDeBrownie> wacco, i would suggest simply passing in Either Char String, or if that's too awkward maybe give more context and see if we can't come up with something better
10:01:15 <HeladoDeBrownie> and then pattern match on the Left and Right constructors
10:01:24 <d-snp> wacco: perhaps the better question is why do you want to wrap the character?
10:02:24 <fread2282> I'm looking for f :: f (Either (g a) (g (Either a b))) -> Either (f (g a)) (f (g (Either a b)))
10:02:26 <wacco> see earlier lpaste for my work in progress, I'm playing with the run length encoding questions from here; http://en.wikibooks.org/wiki/Haskell/Solutions/More_about_lists
10:03:04 <HeladoDeBrownie> wacco, one thing it may help you to know: type String = [Char]
10:03:10 <HeladoDeBrownie> i.e., a String is just a list of Char
10:03:15 <ski> fread2282 : `f (Either a b) -> Either (f a) (f b)' in general ?
10:03:29 <d-snp> wacco: it shows the definition of wrap, but nowhere how you're going to use it
10:03:33 <wacco> yeah, hence the 'wrap' - if it's a char, just make it a list, if it's already a list, keep it as one
10:03:35 <fread2282> ski: I don't think that's possible? but yes that would work
10:03:51 <wacco> ah yes
10:04:03 <ski> fread2282 : i'm not seeing how your extra stuff would make it more probable, either :)
10:04:04 <wacco> "show b" in rlWrite
10:04:24 <ski> fread2282 : .. obviously `f' must be more than a functor, though
10:05:25 <d-snp> wacco: so you're supposing b there could either be a string or a char?
10:05:27 <fread2282> ski: g a -> g (Either a b) is a thing, so if there are any Rights in f, go Right, else go Left
10:05:32 <davidthomas> is it possible to force a timeout to be applied to all TH splices?
10:05:39 * hackagebot friday 0.2.0.1 - A functional image processing library for Haskell.  http://hackage.haskell.org/package/friday-0.2.0.1 (RaphaelJavaux)
10:05:41 <davidthomas> (in GHC, of course...)
10:06:25 <HeladoDeBrownie> wacco, okay, let's try this. answer the question that asks you what the types of encode and decode are. do you know what they'd be?
10:06:50 <davidthomas> I have a build that's hanging, and I'd like to know who to blame :-P
10:07:02 <wacco> d-snp: yes. depending on what test string I'm passing
10:07:08 <ski> fread2282 : something like `class Functor f => Linear f where distribute :: f (Either a b) -> Either (f a) (f b); scaleFactor :: f (a,b) -> (a,f b)' might perhaps work
10:08:01 <wacco> ah nuts, I gotta run or the missus gets pissed
10:08:07 <ski> (perhaps some more stuff like `annul :: f Void -> Void' should also be added)
10:08:16 <wacco> thanks everybody & will return in a bit :)
10:09:10 <d-snp> wacco: so b is not either a string or a char, it can be anything in the class Show
10:09:10 <ski> fread2282 : "if there are any Rights in f, go Right, else go Left" would give something like `f (Either a b) -> Either (f a) (..a..b..)', no ?
10:09:40 <d-snp> wacco: the most important mistake you made is that you did not defined a type of the wrap function, it would've helped you a lot in determining what was going on
10:10:29 <d-snp> if you would have, you would find out that it would have to be Show a => a -> String, and then you would discover that the only thing you can do to a Show is show :P
10:10:31 <ski> fread2282 : if there's no `Right b's, then we could imagine getting to `f a'. otherwise, there some `Right b', but there may still be `Left a's as well ! (hence `..a..b..')
10:11:19 <ski> fread2282 : only in some very special circumstances (`Linear f' above, more or less) is it the case that either it's all `Left a's or it's all `Right b's
10:13:38 <fread2282> ski: got it!
10:14:11 <ski> fread2282 : perhaps you want something like `Linear'. perhaps you want something weaker and more general. i don't know
10:14:21 <fread2282> f :: (Traversable f, Applicative f) => f (Either (g a) (g (Either b a))) -> Either (f (g a)) (f (g (Either b a)))
10:14:34 <fread2282> f = traverse (over _Left pure)
10:14:53 <ReinH> quchen: I see you solved your own problem with cabal-install-bin :)
10:15:00 <ReinH> I'm probably going to use that as well, thanks!
10:15:11 <ski> fread2282 : .. btw, note that the converses of the three `Linear' operations can be defined for any (strong) functor `f' (all Haskell `Functor's are strong)
10:15:25 <fread2282> although I'm not sure if that's what I want, it fits the type
10:15:29 <quchen> ReinH: My own problem?
10:15:39 * hackagebot friday-devil 0.1.0.1 - Uses the DevIL C library to read and write images from  and to files and memory buffers.  http://hackage.haskell.org/package/friday-devil-0.1.0.1 (RaphaelJavaux)
10:15:41 <ReinH> quchen: installing binaries from a sandbox
10:15:42 <ski> fread2282 : .. and presumably `Linear' would have laws that those converses are the inverses of the corresponding methods
10:15:49 <quchen> ReinH: Oh, yeah. That kept nagging me.
10:15:49 <ReinH> quchen: you were talking to dcoutts about it
10:15:51 <ReinH> eah
10:15:54 <ski> (or maybe just retract situations ?)
10:16:06 <dcoutts_> @yarr!
10:16:06 <lambdabot> Avast!
10:16:07 <quchen> ReinH: I was talking to Duncan because I wasn't sure whether I did something stupid inventing that script.
10:16:14 <ReinH> I always just cabal build && cp dist/build/Foo/Foo ~/.cabal/bin
10:16:19 <ReinH> but this is better
10:16:28 <fread2282> yep, it works
10:16:29 <ski> fread2282 : yeah, with `Traversable' and `Applicative', we might reach further :)
10:16:34 <quchen> ReinH: Now I'm blessed with pull requests by people who know what they're doing!
10:16:49 <ReinH> quchen: living the open source dream
10:17:47 <quchen> ReinH: I'm still a bit unsure how correct the "works/doesn't work" list is. It's kind of hard to find these things out.
10:17:54 <ski> (one would sometimes want to claim "only in Haskell can you write a program, and still have no clue what it's supposed to do")
10:18:01 <quchen> I thought Alex and Happy worked until I got really weird build failures in unrelated packages.
10:18:02 <fread2282> it doesn't more Right Rights Left, but that's fine
10:18:53 <dcoutts_> quchen: so does your tool now do --prefix=$HOME/.cabal for the final exe now?
10:19:13 <quchen> dcoutts_: It does, yes. Not good?
10:19:34 <dcoutts_> quchen: no, that's good. Better than the cp approach. So that should make alex etc work right?
10:20:03 * dcoutts_ is writing about nix-style package management, which makes this all redundant
10:21:14 <quchen> Nix, yeah, I've heard stories
10:21:26 <quchen> I'm always *this* close to switching to it. ;-)
10:22:01 <ski> @type traverse (left pure)
10:22:01 <lambdabot> (Traversable t, Applicative f) => t (Either b d) -> Either (f b) (t d)
10:22:35 <fread2282> that's really not that I want :(
10:22:40 <d-snp> hey ReinH how's it going? do you do much Haskell nowadays? I'm still waiting for episode 3 of haskelllive ;)
10:22:41 <quchen> dcoutts_: The reason I didn't use --prefix initially was because I liked the prompting mv allowed me to do.
10:22:56 <fread2282> > traverse (left pure) [Left 1,Right 2]
10:22:58 <lambdabot>  No instance for (GHC.Show.Show (f0 a0))
10:22:58 <lambdabot>    arising from a use of ‚ÄòM251166856248535253411088.show_M2511668562485352534...
10:22:58 <lambdabot>  The type variables ‚Äòf0‚Äô, ‚Äòa0‚Äô are ambiguous
10:22:59 <quchen> ReinH is busy clouding around
10:22:59 <ski> fread2282 : makes it more clear what's going on, i think
10:23:07 <fread2282> yep
10:23:42 <dcoutts_> quchen: you can still do that
10:24:05 <dcoutts_> quchen: configure with --prefix= and then do cabal copy --destdir=$image
10:24:51 <dcoutts_> quchen: you can then do the install step yourself if you want, copying from the $destdir to the real install loc. Similarly with cabal register --gen-pkg-desc=...
10:25:02 <ski> fread2282 : i think if there's only `Right's in there, you'll get `Right' factored out of `t', otherwise you'll get `Left' of *some* `Left'ed value
10:25:15 <quchen> dcoutts_: Oh, so it's "sandbox init && configure --prefix=... && cabal install XXX && cabal copy" then?
10:25:18 <dcoutts_> quchen: which is what binary packages use, they generate an image
10:25:34 <fread2282> ski: yep, something like that
10:25:35 <ski> fread2282 : in case `f = t', then "some `Left'ed value" means a singleton container
10:25:52 <quchen> I didn't even know about cabal copy
10:25:58 <dcoutts_> quchen: only the final thing can have the --prefix outside of the sandbox. You still want the deps installed in the sandbox.
10:26:11 <NightRa> mr-: Yes, thank you!
10:26:30 <dcoutts_> quchen: copy+register. And both have modes that just generate files so that binary package managers can do the actual copy and the ghc-pkg register.
10:28:34 <wacco> d-snp: wrap was mostly a quick put-together to clarify what I'm trying to do. I suppose Char is part of Show - but how can show differentiate between Char and [Char]?
10:29:01 <quchen> dcoutts_: Wait, I'm a bit lost. "cabal configure" would set the sandbox up to targeting a certain prefix upon installation/copying. "cabal install" would still do the compilation inside the sandbox. Afterwards, I'm "cabal copy"ing the files to the appropriate location (i.e. $prefix again?). What's the "cabal register" step for?
10:29:20 <wacco> so, ehm. I think wrap :: (Show a) => a -> String?
10:29:47 <hakujin> is there a way to use unix sockets with Network.HTTP or Network.HTTP.Client? parseUrl fails with "http:///tmp/socket.sock"
10:30:25 <deni> what are "unpromotable types"?
10:30:26 <d-snp> wacco: yes, have you learned what typeclasses are?
10:30:57 <dcoutts_> quchen: so, install is a "mega command" that covers configure+build+copy+register for the package in question plus all of its deps.
10:30:59 <wacco> it got mentioned, but let's say no
10:31:07 <dcoutts_> quchen: to have more precise control you need to not use install.
10:31:09 <wacco> more as a "not like c++" :)
10:31:33 <HeladoDeBrownie> deni, without further context, i'd say probably types that cannot be made into kinds
10:31:41 <dcoutts_> quchen: what you want is to install all the deps into the sandbox. ie cabal init; cabal install --only-dependencies $blah
10:32:05 <d-snp> a typeclass by itself is just a name, and any number of generic functions that go with that name (without implementations)
10:32:28 <d-snp> then, for every type you would like to add into that typeclass, you will have to write implementations for that type
10:32:43 <deni> HeladoDeBrownie: data Endpoint = VersionEndpoint | ListEndpoint and then I wanted to have a function bla :: VersionEndpoint -> IO ()
10:32:55 <dcoutts_> quchen: then you want to do the final one step by step: cabal configure --prefix=$HOME/.cabal; cabal build; cabal copy [--destdir=$image]; cabal register [--gen-pkg-desc=package.conf]
10:32:56 <deni> HeladoDeBrownie: this is with the DataKinds extension
10:33:01 <HeladoDeBrownie> deni, hmm, that looks promotable to me. i don't know what the problem would be
10:33:11 <d-snp> so imagine class Show has one function defined for it, of type  show :: Show a => a -> String, then when you add string to that typeclass you would have to
10:33:29 <dcoutts_> quchen: if you do the --destdir and --gen-pkg-desc thing then you just get a collection of files that you could tar up and move to another machine
10:33:29 <d-snp> define a function show :: String -> String, and implement it
10:33:37 <HeladoDeBrownie> deni, can you give the entire error message, on lpaste?
10:33:48 <deni> HeladoDeBrownie: ups sorry...I have data Endpoint = VersionEndpoint | ListEndpoint | StartEndpoint String
10:34:09 <dcoutts_> quchen: if we ever have a cabal bindist then that's more or less what it'd do, though we'd probably also want to have it be relocatable
10:34:13 <HeladoDeBrownie> deni, hmm, i'm not familiar enough with that extension to know whether that String case would gum up the works
10:34:31 <wacco> d-snp: ok.. that doesn't sound too cray. I can just do wrap :: Char -> String, and wrap :: String -> String below it?
10:34:46 <deni> HeladoDeBrownie: yeah I think it's back to the drawing board for me
10:35:09 <HeladoDeBrownie> deni, or at least the ghc documentation, presumably :)
10:35:13 <quchen> dcoutts_: Hmm, let me see whether I can put that into the script correctly
10:35:27 <HeladoDeBrownie> deni, however posting an error message may allow, if not me, then someone else to give a better idea of a fix
10:35:41 <wacco> nope :p
10:35:43 <deni> HeladoDeBrownie: that stuff is way to hard for me to read....the examples are just not my kind of examples i guess
10:36:04 <deni> HeladoDeBrownie: the code is a mess...I would need to tidy it up a bit and then post it. tnx
10:36:47 <d-snp> wacco: no you would have to define a typeclass Wrappable, and do the dance, but as HeladoDeBrownie said before, it's overkill
10:37:01 <d-snp> there is already a typeclass that can turn any type into a string, and it's Show :P
10:37:07 <d-snp> so I don't know why show isn't working for you
10:37:13 <wacco> well it is
10:37:20 <wacco> but my intention was to get rid of the quotes
10:37:25 <d-snp> what quotes?
10:37:37 <exio4> > show "abc"
10:37:38 <lambdabot>  "\"abc\""
10:37:42 <d-snp> oh
10:37:45 <EvanR> can someone explain to me "ListT done right"
10:37:46 <wacco> ["Foo", "Foo", "Bar"] -> "2Foo1Bar"
10:37:47 <d-snp> oh I didn't know that :P
10:37:50 <HeladoDeBrownie> wacco, i think you need to revisit the types of the functions you want to define. (what are they?)
10:38:19 <deni> HeladoDeBrownie: it seems that string makes it unpromotable
10:38:43 <HeladoDeBrownie> deni, you could try substituting a type variable and then using a type-level string instead, perhaps?
10:38:49 <wacco> HeladoDeBrownie: I originally had something like String -> [(Int, Char)] for rlEncode, if I recall correctly
10:39:01 <HeladoDeBrownie> wacco, sounds okay. and for decode?
10:39:02 <wacco> and wanted to get it working for ["Foo", "Foo" etc
10:39:07 <wacco> the opposite :p
10:39:36 <HeladoDeBrownie> hmm, wait, maybe i misunderstood something: should encode take a string of format aaabb or one of format 3a2b?
10:39:48 <HeladoDeBrownie> er, rather
10:40:12 <HeladoDeBrownie> aaabb -> [(3, 'a'), (2, 'b')] ? or 3a2b -> [(3, 'a'), (2, 'b')] ?
10:40:51 <wacco> (rlDecode . rlRead . rlWrite . rlEncode) rlTestStrA (or B) would do "aaabbc" -> "3a2b1c" -> print it, read it, and return the original test string
10:41:08 <deni> HeladoDeBrownie: but then i can't use Endpoint in a type signature..guess I can't have it both ways
10:41:39 <HeladoDeBrownie> deni, i meant: data Endpoint a = VersionEndpoint | ListEndpoint | StartEndpoint a. isn't that promotable?
10:42:08 <deni> HeladoDeBrownie: what i meant is then I can't write bla :: Endpoint -> IO ()
10:42:13 <kgadek> hi all. I'm starting to write a semi-advanced genetic algorithm library (as a part of my master thesis) and I'm wondering what can be done to hint GHC to better optimise memory? As a rule, the set of mid-results will be processed and a new pool of mid-results will replace the former one. I'm quite concerned since genetic algos are "quite memory intensive" (no doubt I will fill all of RAM available without problem). In eg.
10:42:13 <kgadek>  C/C++ I could preallocate appropriate memory to never de/allocate memory again. Is there anything I shall do/learn about beside STRef/IORef and/or mutable (unboxed) arrays?
10:42:30 <deni> i think i'm just way too confused at this point and need to step away from the code
10:42:45 <HeladoDeBrownie> deni, write Endpoint a maybe? yeah, that might be a good idea, i honestly don't know enough to be able to help as well as i might be able to
10:43:58 <HeladoDeBrownie> kgadek, i don't know if this precisely addresses your question but it may interest you: http://ivorylang.org/
10:44:07 <wacco> I tried making [(Int, [a])] but then I got [(1, "a")] for "a" and [(1, ["Foo"])] for ["Foo"] - which is as expected, except the "a" would need ++, and the ["Foo"] would need concat in rlWrite
10:45:00 <wacco> one way or the other I keep running into "if it's not a list, make it one, and if it's already one, keep it as such"
10:45:48 <kgadek> HeladoDeBrownie, thanks. I was - too - thinking of making Haskell DSL as a fa√ßade to C/C++, however I believe I could get satisfying results in Haskell alone. I have an early, buggy prototype of some in python but GOD HOW SLOW THEY ARE.
10:46:05 <quchen> dcoutts_: ‚Ä¶ something along these lines? http://lpaste.net/118258
10:46:12 <quchen> (plus some backslashes)
10:52:33 <deni> HeladoDeBrownie: basically what I want to be able to do is this: generalfn :: Endpoint -> IO () and a specificfn :: VersionEndpoint -> IO ()
10:52:53 <noquarter> is there any particular reason i get cabal install errors all the tiem?
10:52:56 <noquarter> time*
10:53:09 <HeladoDeBrownie> deni, hmm, are you sure DataKinds is what you need? it's possible the problem may be formulated better. what do generalfn and specificfn do?
10:54:17 <HeladoDeBrownie> wacco, i think that may be the wrong approach. afaik, you shouldn't have to solve that specific (nontrivial) problem in order to implement these functions
10:54:35 <tommd> Should we eliminate the HaskellInIndustry wiki page?  I feel that 1) It doesn't really explain the depth of use or if these groups even still exist 2) The fact that we can, or try to, enumerate the industrial uses can be argued to show Haskell's industry penetration is limited.
10:54:37 <HeladoDeBrownie> wacco, how far did you get playing with the functions the problem specifically suggested?
10:55:10 <HeladoDeBrownie> tommd, how do you want to answer people asking about haskell's use in industry?
10:55:42 <tommd> Ask them why they care and answer what is likely a different driving question.
10:55:59 <deni> HeladoDeBrownie: I'm not sure they are no. Basically I have functions that need to be general ie. operate on every endpoint (ie. a functions for constructing a full url). and some functions that need to work only on specific endpoints....so basically if i have a function that needs to call the version endpoint and i call it some other endpoint I want it to fail at compile time.
10:56:20 <HeladoDeBrownie> tommd, you mean things like "can i get a haskell job" and answering with "here are some jobs ads placed recently"?
10:56:41 <HeladoDeBrownie> s/jobs/job/
10:56:55 <wacco> HeladoDeBrownie: for both test strings I got it working
10:56:58 <wacco> just not at the same time
10:57:11 <wacco> now trying this; http://lpaste.net/118260
10:57:35 <wacco> but totally out of my depth to be honest, wikibooks tutorial hasn't touched any of this yet :)
10:58:13 <deni> HeladoDeBrownie: altough since this is all internal library code I guess I can write tests for these cases....but I was wondering if I can get the compiler to somehow check this for me
10:58:15 <HeladoDeBrownie> deni, ah, well DataKinds isn't quite used for that. in that case though, what comes to mind for how i might solve that is have the endpoint constructors carry a value of another type and have the function only accept values of that type, so that only the value you get from that one specific constructor of the Endpoint type will work. make sense? i can try illustrating
10:58:58 <HeladoDeBrownie> data Endpoint = VersionEndpoint VersionEndpoint | ListEndpoint ListEndpoint | StartEndpoint String
10:59:01 <HeladoDeBrownie> something like that
10:59:17 <HeladoDeBrownie> where those other types are defined as necessary
10:59:39 <HeladoDeBrownie> and may or may not carry some form of proof that that's the correct endpoint, depending on how sure you want to be
11:00:29 <HeladoDeBrownie> again, i'm still missing information about your problem (possibly nontrivial amounts) that might help solve it better, but that is what comes to mind
11:00:58 <deni> HeladoDeBrownie: the domain is just a remote (rest) api wrapper
11:01:17 <deni> HeladoDeBrownie: if you have an example where something like this is solved in this way do share a link
11:02:46 <HeladoDeBrownie> i can't think of how i'd find such a thing, but i'm sure examples exist. anyway, my idea was have your functions be of types like VersionEndpoint -> IO () and ListEndpoint -> IO () instead of trying to enforce that the value of type Endpoint you have is constructed with one specific constructor at compile time, which afaik is impossible
11:02:52 <HeladoDeBrownie> DataKinds doesn't solve that problem
11:03:21 <HeladoDeBrownie> sorry if that's not helpful enough, but i hope this gives you some idea at least
11:03:24 <deni> HeladoDeBrownie: the thing is that all endpoints accept the same thing...an ID....so every constructor would accept the same thing
11:04:20 <HeladoDeBrownie> have you thought of allowing the function to fail instead? Endpoint -> Maybe (IO ())
11:04:25 <HeladoDeBrownie> Nothing indicates it was the wrong constructor
11:04:38 <deni> that's the problem it should indicate
11:04:45 <HeladoDeBrownie> you can do something like print "this case should not have been reached" if necessary
11:05:54 <deni> HeladoDeBrownie: this thing is meant to be a library that other people would use. This case doesn't affect them. This is purely for me to not mistype something during refactoring and make a function that needs to do one thing do a totally different thing
11:06:43 <deni> HeladoDeBrownie: so i guess tests are an option for this as well
11:06:50 <HeladoDeBrownie> i suppose so
11:06:53 <deni> HeladoDeBrownie: i'm just experimenting with the best approach
11:07:00 <HeladoDeBrownie> there is, after all, a limited amount that haskell's type system can enforce
11:07:15 <HeladoDeBrownie> encoding semi-complex constraints can get tricky
11:09:11 <deni> HeladoDeBrownie: yeah. tnx for your help.
11:09:24 <HeladoDeBrownie> no problem
11:15:42 * hackagebot haste-perch 0.1.0.6 - Create, navigate and modify the DOM tree with composable syntax, with the haste compiler  http://hackage.haskell.org/package/haste-perch-0.1.0.6 (AlbertoCorona)
11:15:42 <hakujin> is the appropriate way to omit features for Windows platforms {-# LANGUAGE CPP -#} with #if?
11:21:46 <schell> have you guys ever experienced a computation running from forkIO takes much longer than the same computation running in main?
11:22:17 <sbrg> seeing as I have upgraded from 7.8.3 to 7.8.4 which broke a lot of packages, is it safe to delete .cabal/lib/...-7.8.3/* ?
11:22:18 <schell> my intuition says it should be the same time wise, but for some reason it‚Äôs around 10x longer in forkIO
11:22:35 <dcoutts_> sbrg: yes
11:23:06 <sbrg> dcoutts_: thanks!
11:24:55 <platz> Kind of amazed how much more noisy looking just adding a newtype makes a function look.  I thought something esoteric was going on with the lambda.  it's just fmap but disguised behind the newtype http://lpaste.net/118263
11:28:05 <wacco> I give up >__< typeclasses are too much for now
11:28:37 <EvanR> wacco: what are you trying to do?
11:30:04 <wacco> get my function to accept both Char and [Char] - basically to do show on it, but without the quotes
11:30:06 <HeladoDeBrownie> wacco, step back even further, forget about typeclasses, you don't need them to solve this problem
11:30:40 <EvanR> myFunction :: Either Char [Char] -> String
11:30:54 <EvanR> for that, no type classes necessary
11:31:09 <HeladoDeBrownie> that was the very first thing i suggested hours ago, but i doubt even that is necessary for the problem
11:31:29 <d-snp> EvanR: no the input of his function is of the typeclass Show
11:31:31 <EvanR> no, but it corresponds to the stated goal
11:31:35 <EvanR> ah
11:31:49 <d-snp> so he first has to change his surrounding function to not take Show as a parameter anymore
11:32:07 <EvanR> i tried
11:32:42 <wacco> I don't know how to read that signature, Either is a thing?
11:32:50 <ski> yes
11:32:54 <wacco> I thought HeladoDeBrownie meant I was supposed to create one :)
11:33:08 <ski> @type [Left "help",Right False,Left "me"]
11:33:09 <lambdabot> [Either [Char] Bool]
11:33:20 <d-snp> wacco: that last lpaste is very close
11:33:43 <d-snp> you would call it like this: wrap (Two "a")
11:33:52 <d-snp> but then you see how this approach is useless for you
11:33:52 <EvanR> wacco: data Either a b = Left a | Right b
11:34:10 <d-snp> because you don't have a string, you have a Show, so you really need to change the function so it doesn't get a Show anymore
11:34:24 <ski> wacco : you seem to be asking for something nonparametric. one should ask oneself in such cases whether that is really what one wants to do
11:34:32 <d-snp> yes
11:34:57 <HeladoDeBrownie> ski, thank you for formulating that in a way i didn't know how, now i will know for next time :)
11:35:02 <d-snp> I don't know what function is giving you a Show, but that's not a good practice, and you should change it
11:35:29 <d-snp> there's only one thing you should pass a Show too, and that's show :P
11:35:42 * hackagebot haste-perch 0.1.0.7 - Create, navigate and modify the DOM tree with composable syntax, with the haste compiler  http://hackage.haskell.org/package/haste-perch-0.1.0.7 (AlbertoCorona)
11:35:57 <wacco> d-snp: I was wondering how to instantiate them then - so much for that
11:36:04 <ski> to encode a non-parametric thing in Haskell, commonly one would invent a new type class .. but is it worth it here ? .. is there some real need, apart from a trivial concrete syntax issue ?
11:36:42 <wacco> probably not
11:36:47 <wacco> mostly because I don't know what I'm doing yet :)
11:37:01 <d-snp> wacco: any time you are solving a really simple problem, and all the solutions seem super complex, it's probably because you're approaching the simple problem from the wrong angle
11:37:18 <ski> the methods of a type class are supposed to "behave the same" (including satisfying some reasonable *laws*) for all instances
11:37:19 <d-snp> if you can show me your original lpaste again, I'll point it out
11:38:05 <ski> while you can stretch the meaning of "behave the same" (Haskell doesn't even check that your instance follows the laws, let alone formally keeps track of them), the question is whether you want to
11:38:06 <wacco> http://lpaste.net/118257
11:38:43 <d-snp> rlWrite :: (Show a) => [(Int, [a])] -> String
11:38:49 <wacco> wrap was just toying around with how to change "show b" in rlWrite
11:38:52 <d-snp> that rlWrite, why does it get Show a?
11:39:01 <d-snp> isn't there a better concrete type you can give it?
11:39:41 <ski> wacco : my advice basically boils down to "you (usually) don't want to do this" .. of course, there may be legitimate cases where one *do* want something like this, and then you can of course ask whether we advice against it because it happens to be harder to do it Haskell
11:40:22 <wacco> lol
11:40:24 <ski> wacco : i hope that i'm able to convey that we believe there are deeper reasons to attempt to avoid doing this, in most cases
11:40:43 <EvanR> rather than requiring a Show instance you can require a String to be provided instead
11:40:44 <ski> wacco : one such would be that parametric code has more useful reasoning laws
11:40:54 <EvanR> or Text
11:41:09 <d-snp> ski, EvanR, he already pasted his code, it's quite simple
11:41:41 * HeladoDeBrownie wonders if typeclasses demonstrably violate parametricity laws, given that there's a translation into things you can do just with datatypes and parameters
11:42:02 <d-snp> I'm a bit confused though
11:42:15 <d-snp> (rlDecode . rlRead . rlWrite . rlEncode) <-- the rlWrite gets the result of rlEncode right?
11:42:22 <ski> `wrap' is not used in that paste
11:42:34 <d-snp> but rlEncode returns (Eq a) => a
11:42:48 <d-snp> ski: he wants to replace all instances of 'show' with 'wrap'
11:42:53 <bitraten> Is DeepSeq still advisable to use? I wanna catch Excpetions and evaluate doesn't work.
11:42:54 <wacco> not really
11:43:08 <wacco> I was just trying to boil down the error message & what was causing it
11:43:25 <ski> HeladoDeBrownie : probably depends exactly on how you define parametricity, in the presence of type classes. i'd probably prefer a formulation where they technically doesn't violate parametricity
11:43:46 <ski> (i'm not sure whether that would hold for GADTs, though)
11:43:50 <d-snp> is Eq a super class of Show? why does rlWrite accept the result of rlEncode?
11:44:20 <EvanR> i think it is
11:44:32 <wacco> ski: basically, tutorial gave it as a challenge, I fixed it for "aaabbcc", then found out about the original "blog post inspiring the question"  talking about things like being able to apply it to ["Foo", "Foo", "Bar"], and I ran with the idea
11:44:42 <ski> wacco : Haskell doesn't alloc cyclic (aka equi-recursive) types. you have to hide / break up the cycle via a named data type
11:45:02 <EvanR> @src Show
11:45:02 <lambdabot> class  Show a  where
11:45:02 <lambdabot>     showsPrec :: Int -> a -> ShowS
11:45:02 <lambdabot>     show      :: a   -> String
11:45:02 <lambdabot>     showList  :: [a] -> ShowS
11:45:11 <EvanR> well not in there
11:45:19 <benzrf> > showList [1, 2, 3] ""
11:45:21 <lambdabot>  "[1,2,3]"
11:45:26 <ski> wacco : the main reason it doesn't allow them is pragmatic : if they weren't disallowed, then lots of type errors (like forgetting to pass one argument) would become strange cyclic types instead
11:45:28 <benzrf> > showList "foobar" ""
11:45:30 <lambdabot>  "\"foobar\""
11:46:40 <ski> (wacco : the other reason is that, seen from a "logical perspective", it would be "inconsistent". however Haskell is already "inconsistent" in this sense, due to the presense of general recursion (causing nontermination of some programs))
11:46:43 <d-snp> wacco: are you sure (rlDecode . rlRead . rlWrite . rlEncode) works?
11:47:09 <d-snp> I don't get how you can cast from Eq to Show like that
11:47:58 <ReinH> bennofs: ping
11:48:24 <ski> d-snp : there is no "cast from Eq to Show"
11:48:33 <d-snp> ski: I know
11:48:58 <d-snp> so his code must not work
11:49:08 <d-snp> right?
11:49:12 <wacco> give me a minute, let me undo half a dozen attempts that messed up stuff
11:55:23 <wacco> http://lpaste.net/118264
11:55:43 * hackagebot persistent-postgresql 2.1.2.2 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.1.2.2 (GregWeber)
11:55:45 * hackagebot Spock 0.7.7.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.7.7.0 (AlexanderThiemann)
11:55:48 * hackagebot swish 0.9.1.2 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.1.2 (DouglasBurke)
11:58:09 <wacco> the errors / warnings - I've had a look at those suggestions already, neat new stuff to learn, but left things as they were how I came up with it :)
11:59:06 <EvanR> wacco: why cant rlTestStrB be written
12:00:36 <wacco>  Couldn't match type ‚Äò[Char]‚Äô with ‚ÄòChar‚Äô -- Expected type: [Char] -- Actual type: [[Char]]
12:00:47 <EvanR> you mean you cant use it in your program at the top
12:02:10 <wacco> I suppose
12:02:20 <EvanR> wacco: did you try doing :t (rlDecode . rlRead . rlWrite . rlEncode) in ghci
12:02:20 <d-snp> I still don't get it, it still says rlWrite . rlEncode, why isn't it giving an error on that?
12:02:41 <EvanR> rlWrite . rlEncode is ok
12:02:45 <d-snp> why?
12:02:56 <deni> HeladoDeBrownie: I've ended up with this http://dpaste.com/32MVRE9 and it works fine I guess
12:02:56 <EvanR> rlEncode returns a [(Int,a)]
12:03:04 <EvanR> rlWrite takes a [(Int,Char)]
12:03:06 <wacco> EvanR: I did now :)
12:03:11 <EvanR> they are compatable
12:03:19 <EvanR> compatible
12:03:21 <d-snp> oh right
12:03:34 <EvanR> wacco: do you like what you see? ;)
12:03:37 <wacco> no :P
12:03:58 <HeladoDeBrownie> deni, looks good to me
12:04:05 <wacco> I wanted to take out the Char from rlWrite but then ran into the "how to flatten"
12:04:13 <wacco> might've not been my brightest moment
12:04:14 <HeladoDeBrownie> deni, sorry if i drew you away from the gadt trail, it turned out to be a good thought
12:05:01 <EvanR> wacco: well, at least you write a well typed program. its just not as general as you hoped. which happens a lot actually, things we think are general because "i took care of two cases" is actually making your thing really specific
12:05:06 <EvanR> wrote*
12:06:26 <wacco> call me stubborn
12:08:13 <Thulsadum> It realy took me about a year to understand the real nature of monads.
12:08:51 <wacco> rlWrite :: (Show a) => [(Int, a)] -> String , and then rlWrite ((a,b):c) = show a ++ show b ++ rlWrite c
12:09:23 <Thulsadum> Well, there was a one year long break for haskell, but the concept of monads bothered me here and then nevertheless
12:09:37 <wacco> would be the next hurdle.. except I now end up with the quotes
12:10:02 <EvanR> > show 'a'
12:10:03 <lambdabot>  "'a'"
12:10:12 <EvanR> > ['a']
12:10:14 <lambdabot>  "a"
12:10:17 <EvanR> > show "a"
12:10:18 <lambdabot>  "\"a\""
12:10:21 <EvanR> > "a"
12:10:22 <lambdabot>  "a"
12:10:50 <EvanR> (:[]) and id will convert a char and a string into non-quoted strings, respectively
12:11:13 <wacco> id?
12:11:31 <EvanR> :t id
12:11:32 <lambdabot> a -> a
12:11:37 <EvanR> > id "a"
12:11:38 <lambdabot>  "a"
12:11:39 <deni> HeladoDeBrownie: not at all...a discussion like this is very useful. in the end i'm experimenting with different approaches.
12:12:26 <wacco> but.. you're now using two different things for when you're being given a Char or a String
12:13:02 <Ptival> hello, do I need a selenium server to use webdriver, or is it possible to have a serverless test? :\
12:13:03 <EvanR> yeah, you start with two different things, and you want one thing. so you need to use two different operations to do it
12:13:25 <EvanR> one for each thing
12:14:27 <wacco> so far so good, how do I tell my compiler this? :)
12:15:10 <EvanR> use a function of type Either a b -> (a -> c) -> (b -> c) -> c ;)
12:15:41 <EvanR> which exists already in the standard library
12:15:43 <EvanR> :t either
12:15:43 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
12:15:55 <EvanR> > (:[]) id (Left 'a')
12:15:57 <lambdabot>  Couldn't match expected type ‚ÄòData.Either.Either GHC.Types.Char b0
12:15:57 <lambdabot>                                -> t‚Äô
12:15:57 <lambdabot>              with actual type ‚Äò[a0 -> a0]‚Äô
12:16:08 <wacco> is that what show's doing?
12:16:17 <EvanR> sort of
12:16:22 <EvanR> > either (:[]) id (Left 'a')
12:16:23 <lambdabot>  "a"
12:16:29 <EvanR> > either (:[]) id (Right "a")
12:16:30 <lambdabot>  "a"
12:16:41 <wacco> yeah, I was looking at the prelude earlier, just in a nut shell I mean :)
12:17:26 <EvanR> typeclasses can be implemented by passing the implementation of all the methods along with the value which is an instance of the class
12:17:41 <EvanR> in case of Show this is rather trivial, its a String
12:18:59 <phooby> does anyone know how to hide code from pandoc with markdown+lhs? i tried %if False ... %endif trick but pandoc of course ignores that when converting
12:19:22 <wacco> and the compiler can figure out if it's a Left or Right?
12:19:40 <EvanR> its a runtime check
12:19:57 <EvanR> the compiler doesnt know what youre going to pass to it, only that its Left or Right
12:20:08 <wacco> ah so it's the pattern matching business again?
12:20:13 <EvanR> @src either
12:20:14 <lambdabot> either f _ (Left x)  = f x
12:20:14 <lambdabot> either _ g (Right y) = g y
12:23:28 <quchen> In a basic interpretation, a typeclass parameter to a function means you're implicitly passing the typeclasses functions. "Show a => a -> Bool" is pretty close to "(a -> String) -> a -> Bool" in this picture, only that you don't have to explicitly pass the "a -> String" function (namely "show").
12:26:02 <_1_yakin> Mira Èsta imagen: http://imagizer.imageshack.com/img633/4075/rWaH2r.jpg
12:26:48 <EvanR> dont click on that
12:28:02 <phooby> oh well, one solutions is just to wrap \code{} blocks inside <!-- ... --> html comments and then they won't show in html output. that seems actually be the only solution atm. :)
12:28:18 <wacco> http://lpaste.net/118266 Grm.
12:29:21 <d-snp> wacco: it gets a Char from rlEncode, not an Either Char [Char]
12:29:46 <EvanR> yeah
12:29:50 <wacco> I get that
12:29:56 <wacco> I'm wondering why that would be my problem
12:29:57 <EvanR> your lego blocks are not fitting together
12:30:14 <d-snp> :P
12:30:19 <wacco> consider me the baby trying to hammer a square in the circle, and not getting why this is so troublesome
12:30:27 <wacco> ;)
12:30:48 <EvanR> well, what would you expect it to do if that magically passed the checker?
12:31:06 <EvanR> a Char and a [Char] are two totally different things
12:32:04 <wacco> not for show they're not
12:32:11 <EvanR> yeah they are
12:32:12 <d-snp> they are for show
12:32:17 <wacco> well.. I mean, they're treated differently
12:32:23 <wacco> but show's capable of figuring out what to do when
12:32:39 <wacco> can't be *that* hard to do that in my function, no?
12:33:02 <d-snp> it's not that hard, you'd have to define a typeclass :P
12:33:04 <HeladoDeBrownie> wacco, imagine instead of typeclass constraints we had explicit passing of values containing the typeclass methods. E.g., instead of Show a => a -> String you'd have Show a -> a -> String
12:33:31 <d-snp> there is an existing typeclass for this, called Stringable, but for some reason Char doesn't instance it, so you'd have to instance it yourself :P
12:33:44 <HeladoDeBrownie> wacco, in fact the only practical difference between that and how typeclasses work is that the compiler automatically supplies those values how they really work, whereas it wouldn't in this hypothetical translation
12:34:32 <EvanR> Stringable?
12:34:37 <wacco> I didn't get any of that xD
12:34:45 <wacco> maybe I should just stick to the tutorial for now
12:34:53 <d-snp> EvanR: yeah, no one uses it though, it's not very standard
12:35:38 <EvanR> d-snp: what does it do?
12:35:40 <HeladoDeBrownie> wacco, hmm, maybe not the best way to trigger your intuition. but suffice to say typeclasses don't do anything special compared to regular old parameters.
12:35:53 <d-snp> EvanR: it provides a Stringable typeclass, that has a toString function
12:36:08 <d-snp> it works on a bunch of texty types
12:37:00 <HeladoDeBrownie> wacco, okay, let's try it this way in fact. so, imagine the Read typeclass were defined like so: class Read a where show :: a -> String
12:37:15 <HeladoDeBrownie> wacco, then, a Read a constraint is exactly as good as accepting a parameter of type a -> String
12:37:28 <HeladoDeBrownie> so, Read a => a -> String translates to (a -> String) -> a -> String
12:37:38 <HeladoDeBrownie> (which as we can see is really just id)
12:37:51 <HeladoDeBrownie> (or rather, can be id)
12:38:34 <HeladoDeBrownie> wacco, does that make more sense?
12:38:41 <EvanR> wacco: i tried to run your program, after making some changes. theres a bug in rlRead involving the [(a,b)] = reads n
12:39:08 <EvanR> i.e., if reads n in [], it crashes
12:39:16 <EvanR> or has more than one element
12:39:51 <HeladoDeBrownie> wacco, so, the "magic" we're seeing must lie in how the compiler figures out which instance to use
12:40:06 <HeladoDeBrownie> wacco, and as it happens *that* looks at the type and tries to match it against available instances
12:40:37 <HeladoDeBrownie> wacco, so, it stands to reason that you can do this yourself, manually, just by passing in the correct arguments to some function.
12:41:07 <wacco> EvanR: I see what you mean, just feed it correct stuff for now? ;)
12:41:21 <joe9> How can I convert POSIXTime (epoch) to Integer (seconds)? :t fmap (utcTimeToPOSIXSeconds . flip UTCTime 0) today = fmap (utcTimeToPOSIXSeconds . flip UTCTime 0) today :: IO POSIXTime
12:41:22 <joe9> *
12:41:28 <EvanR> whats correct, i actually only looked at the types
12:41:37 <joe9> I cannot figure out how to get the Seconds portion of POSIXTime.
12:41:44 <EvanR> joe9: try floor
12:42:11 <wacco> EvanR: "3a4b"
12:42:22 <joe9> EvanR: cool, thanks.
12:43:00 <wacco> I had an alternative dealing with "3Foo4Bar", nevermind for now
12:43:02 <EvanR> wacco: ok. the program crashes when rlTestStrA is given as input
12:43:24 <karshan> Hello, does anyone know if I can derive Read instance for a datatype that already exists in a ghci session
12:43:25 <EvanR> hmm
12:43:53 <wacco> HeladoDeBrownie: I'm not actively ignoring you, just trying to wrap my head around it all in the mean time ;)
12:44:32 <EvanR> wacco: nevermind i see the problem with the quotes.
12:45:06 <Thulsadum> is there a simple way to declare a integral data type with a specific range? i.e. `newtype Hours = 0 .. 23`?
12:45:08 <EvanR> wacco: so to answer your remark before about Show already knowing how to do this, its just that Show instance arent formating stuff the way you want.
12:45:39 <HeladoDeBrownie> wacco, i understand, it's a lot to process. take your time, ask questions if necessary
12:45:45 * hackagebot abt 0.1.1.0 - Abstract binding trees for Haskell  http://hackage.haskell.org/package/abt-0.1.1.0 (JonSterling)
12:46:03 <joe9> wacco, EvanR, instead of rlRead, why not use a read function from Safe?
12:46:08 * tectonic installs haskell.
12:46:17 <HeladoDeBrownie> wacco, essentially the point i want to get across is there is not some fundamental magic to typeclass constraints, it's as good as syntactic sugar really
12:46:22 <EvanR> tectonic: sweet
12:46:24 <mrlami> quick inquiry - where does haskell shine?  why would a web developer want to learn it?
12:46:50 <EvanR> in order to come to a better understanding of the world they work in
12:47:43 <EvanR> which may or may not lead to them hating their jobs and quitting to get an advanced degree in mathematics
12:49:06 <Pamelloes> EvanR: Yeah........
12:49:08 <phooby> true dat
12:49:45 <wacco> HeladoDeBrownie: (a -> String) -> a -> String I should read as a function mapping a to String, taking an a and giving a String?
12:49:49 <HeladoDeBrownie> mrlami, my favorite thing about haskell for anything is how it gives me a strong framework for thinking about problems in the form of its type system and its algebraic data types. others may cite other things, but those are my favorite parts.
12:50:23 <HeladoDeBrownie> wacco, that sounds either weirdly phrased or wrong
12:50:44 <HeladoDeBrownie> wacco, what if i were to write it this way, which is exactly equivalent? (a -> String) -> (a -> String)?
12:50:57 <wacco> possibly both
12:51:24 <wacco> still find it hard to read these things
12:51:55 <HeladoDeBrownie> wacco, let's break it down then. the type is Yaddayadda -> Yaddayadda. what is that?
12:52:08 <HeladoDeBrownie> (for some Yaddayadda :)
12:52:13 <EvanR> a -> b -> c is the same as a -> (b -> c). each -> has only two arguments, the left and the right. dropping parens is a shorthand based on the defined right associativity
12:52:47 <benzrf> HeladoDeBrownie: )
12:52:52 <wacco> HeladoDeBrownie: x y = y + 1
12:53:01 <HeladoDeBrownie> benzrf, hush, i elided that :P
12:53:08 <HeladoDeBrownie> wacco, huh?
12:53:11 <wacco> lol
12:53:21 <HeladoDeBrownie> wacco, we're just talking about reading the type in words for now
12:53:25 <wacco> ghci agrees with me though, except for (Num a) =>
12:53:32 <HeladoDeBrownie> wacco, how would you put Yaddayadda -> Yaddayadda into words?
12:53:56 <wacco> a map from yadda to yadda?
12:53:58 <Pamelloes> A bunch of old ladies prattling?
12:54:07 <HeladoDeBrownie> wacco, okay, i would've said "function", but that's fine too
12:54:25 <HeladoDeBrownie> wacco, okay so now let's say that Yaddayadda = a -> String. what is the larger type now?
12:55:14 <wacco> the function yaddayadda takes an a and returns a string
12:55:33 <HeladoDeBrownie> wacco, sorry for the confusion; the type we're discussing is (a -> String) -> (a -> String)
12:55:39 <HeladoDeBrownie> wacco, how do you put that into words?
12:55:53 <HeladoDeBrownie> wacco, actually let's start with this: put a -> String into words.
12:56:42 <HeladoDeBrownie> (it's easier than it may seem)
12:56:48 <wacco> a function from a to String
12:56:51 <HeladoDeBrownie> good!
12:56:59 <HeladoDeBrownie> so then, what is (a -> String) -> (a -> String)?
12:57:14 <mrlami> EvanR and HeladoDeBrownie Where does haskell fit into my stack? - I guess I'm too much of a OOP/OOD guy to get what you are saying.  I have a pretty good background in mathematics already coming form an EE background.
12:57:20 <wacco> a function taking a function from a to string giving a function from a to string
12:57:28 <mrlami> do i have to be developing a wolfram type application to need it?
12:57:29 <HeladoDeBrownie> mrlami, you can use it on client or server, it fits anywhere really
12:57:49 <EvanR> no you dont need to be doing wolfram type stuff
12:57:51 <HeladoDeBrownie> mrlami, which are you interested in?
12:58:04 <HeladoDeBrownie> wacco, good!
12:58:12 <HeladoDeBrownie> wacco, so, does that make sense now?
12:58:21 <mrlami> both, but lets start with server side
12:58:42 <HeladoDeBrownie> mrlami, want to try a haskell web framework?
12:59:00 <mrlami> that would be fun
12:59:47 <HeladoDeBrownie> mrlami, here we have a listing, i haven't tried most of these but someone else might give you a better suggestion where to start https://www.haskell.org/haskellwiki/Web/Frameworks
13:00:26 <HeladoDeBrownie> actually i think fp complete has some articles on using yesod
13:00:45 <HeladoDeBrownie> https://www.fpcomplete.com/blog/2012/10/yesod-tutorial-1-my-first-web-site
13:00:46 * hackagebot myTestlll 1.0.0 - testign upload  http://hackage.haskell.org/package/myTestlll-1.0.0 (MarkSantolucito)
13:01:03 <HeladoDeBrownie> anyone feel free to interject if they think there's a better place to start
13:01:44 <HeladoDeBrownie> mrlami, oh, you might also want to read some introductory haskell material if you haven't. see https://github.com/bitemyapp/learnhaskell
13:03:38 <HeladoDeBrownie> wacco, there are two ways we tend to think of functions in haskell, one being fundamentally true and the other being an often useful approximation. the former: every function is of one input and one output. (that output can in turn be a function.) the latter: functions can have several parameters and have one output.
13:04:00 <HeladoDeBrownie> wacco, you *must* understand the former, otherwise you are likely to get thoroughly confused by the latter.
13:04:14 <EvanR> > (+)
13:04:16 <lambdabot>  <Integer -> Integer -> Integer>
13:04:19 <EvanR> > (3 +)
13:04:21 <lambdabot>  <Integer -> Integer>
13:04:23 <EvanR> > (3 + 3)
13:04:24 <lambdabot>  6
13:04:46 <HeladoDeBrownie> wacco, so when you say that (a -> String) -> a -> String is the type of "functions taking an a -> String and an a and giving a String", you are right, as long as you realize this is a potentially intuition and not quite how things actually work.
13:04:51 <HeladoDeBrownie> +useful
13:06:25 <HeladoDeBrownie> i should have said "inputs" instead of "parameters" for consistency
13:06:31 <wacco> I've seen bits and pieces of this before, and I think I get why the latter brackets are optional, it's just.. not natural :P
13:06:46 <HeladoDeBrownie> wacco, it should become natural as you go on doing haskell
13:07:13 <wacco> *shrugs* I got time
13:07:59 <ski> wacco : `A -> B -> C' means `A -> (B -> C)' because `f a b' means `(f a) b'
13:10:30 <ski> or, more clearly we've decided that `A -> B -> C' is to mean `A -> (B -> C)', and `f a b' is to mean `(f a) b', because `f :: A -> (B -> C)' ("curried style") is the "default" (or most common) style of *representing* multiple arguments in Haskell (and so we want a brief syntax for it)
13:10:43 <ski> (here `a :: A' and `b :: B' was intended)
13:11:09 <wacco> I ran into uncurry
13:11:19 <ski> (the other style, "tupled style" would be `g :: (A,B) -> C' and `g (a,b)')
13:11:20 <wacco> figured I'd focus on the Char/String thing first
13:12:10 <ski> `uncurry' transforms a function from curried to tupled style, and `curry' in the other direction -- or rather, in the special case with "two arguments" (so a *pair* in the tupled style, as opposed to any tuple)
13:12:41 <ski>   curry :: ((a,b) -> c) -> (a -> (b -> c))
13:12:54 <ski>   uncurry :: (a -> (b -> c)) -> ((a,b) -> c)
13:13:02 <ski> you can imagine also
13:13:13 <ski>   curry3 :: ((a,b,c) -> d) -> (a -> (b -> (c -> d)))
13:13:13 <wacco> yeah, not sure if you saw my rlDecode definition; rlDecode = concat . map (\(a,b) -> replicate a b)
13:13:21 <wacco> just didn't know uncurry was a thing ;)
13:13:22 <ski>   uncurry3 :: (a -> (b -> (c -> d))) -> ((a,b,c) -> d)
13:13:24 <ski> and so on
13:13:29 * HeladoDeBrownie wonders if it would be useful or just confusing to have a Curriable typeclass with instances for all tuples
13:13:43 * HeladoDeBrownie wonders if that would even be feasible
13:13:52 <wacco> I'm not stopping you!
13:14:30 <wacco> anyways
13:14:38 <wacco> it's been fun, I'm calling it a night
13:14:43 <HeladoDeBrownie> o/ good night
13:14:52 <wacco> likewise \o
13:15:02 <ski> HeladoDeBrownie : would perhaps be simpler to have a way to transform from tuples to (right-, or left-) nested pairs
13:15:17 <ski> (but how to handle the nonexisting unituple case, then ?)
13:15:42 <HeladoDeBrownie> Identity is the unituple :P
13:15:46 * hackagebot possible 0.1.0.2 - Three valued Data.Maybe  http://hackage.haskell.org/package/possible-0.1.0.2 (tolysz)
13:16:47 <HeladoDeBrownie> o_o is that possible package a joke?
13:18:30 <nitrix> Is it common practice to have a codebase under a directory to not pollute the import namespace?
13:18:43 <nitrix> import YourProject.SomeModuleOfIt
13:18:56 <HeladoDeBrownie> nitrix, many do that
13:18:57 <nitrix> instead of simply import SameModule
13:19:39 <adamse> nitrix: for not-libraries I do not use an extra hierarchy
13:20:27 <nitrix> adamse: It's an executable.
13:20:30 <Hijiri> HeladoDeBrownie: there's a problem with Possible's monad instance at least
13:21:02 <HeladoDeBrownie> Hijiri, i was just checking the laws, what did you find?
13:21:10 <Hijiri> MissingData >>= k = MissingData, but MissingData >> k = k
13:21:35 <HeladoDeBrownie> Hijiri, yep, good catch
13:22:32 <HeladoDeBrownie> that also makes it so that a >> b /= a >>= \_ -> b, which is very bad in my opinion :P
13:24:09 <HeladoDeBrownie> Hijiri, unless you want to, i'm going to submit an issue on their github
13:25:24 <nitrix> Second question, is it preferable to use `type` or `newtype`, if the underlying type is a String? I feel like newtype is more appropriate, because then, not every String is accepted, only those promoted to the type I created, but isn't it just wrapping and unwrapping? It doesn't bring much safety actually.
13:25:28 <Hijiri> You can go ahead
13:25:34 <Hijiri> you pointed out the package originally
13:25:56 <HeladoDeBrownie> Hijiri, hackagebot did, but okay
13:25:58 <nitrix> So I wonder what is the argument for/agaisn't. In my case it's a file system, a BlockID has a very specific format.
13:26:15 <Hijiri> well I wouldn't have looked at the package :P
13:27:01 <Hijiri> Is the idea that null is more failurey than missing data?
13:27:10 <HeladoDeBrownie> ¬Ø\_(o_0)_/¬Ø
13:29:15 <adamse> nitrix: _I_ use type mostly for abbreviation and documentations, newtypes for when it really is different thing I'm representing
13:30:19 <HeladoDeBrownie> newtype is also handy for alternative instances. see, e.g., ZipList
13:30:36 <nitrix> adamse: They are different things, but they both use string representations.
13:30:45 <nitrix> adamse: Still newtype?
13:31:15 <nitrix> I'll go with that.
13:31:36 <adamse> I would use a newtype if it is important that your thing has some kind of structure and is not just a String with different name
13:31:43 <Hijiri> wrapping/unwrapping adds safety if you can control when you wrap or unwrap
13:32:20 <Hijiri> If the user of your library (possibly yourself) must use the "safe" ways to make them, then it can prevent bugs where you pass in the wrong thing
13:32:55 <Hijiri> by not exporting the constructors or something like that
13:33:28 <adamse> nitrix: nice thing about newtypes is that you can keep it abstract, and then you can change the underlying representation to data or whatelse
13:33:31 <adamse> easier
13:35:14 <ski> abstract data types are often used to simulate subtypes, or quotient/factor types (or combinations thereof)
13:35:31 <nitrix> adamse: Well, everywhere you use the value constructor, there's usually a little refactoring to do, but I get your point.
13:35:46 * hackagebot possible 0.1.0.3 - Three valued Data.Maybe  http://hackage.haskell.org/package/possible-0.1.0.3 (tolysz)
13:36:26 <nitrix> Hey! I'm finally using the MaybeT monad transformer in a codebase :3
13:36:39 * nitrix feels like a pro!
13:36:45 * ski would like to be able to say `newtype k Abstract = Hide (k Representation)'
13:37:15 <sbrg> three-valued Maybe.. huh. Why not just Maybe (Either a)?
13:37:38 <HeladoDeBrownie> sbrg, it's actually Maybe (Maybe a))
13:38:07 <sbrg> HeladoDeBrownie: hmm, yeah, I guess
13:38:24 <nitrix> My use case is an IO (Maybe Block) into a MaybeT IO Block
13:38:38 <nitrix> Not the most useful thing, but hey.
13:38:53 <nitrix> Baby steps.
13:39:13 <ski> nitrix : can often clean up some boilerplate :)
13:40:08 <nitrix> I like how you can write haskell however you want, then later polish it. The code is so terse that you end up seeing the same things over and over again, and eventually you improve those as well.
13:40:51 <nitrix> Which is, in my opinion, a very important part of development. Code has to be continually refactored to not accumulate technical debts.
13:40:57 <nitrix> And with haskell I'm having fun doing it.
13:41:12 <nitrix> Maybe because there's so much to learn :D
13:41:18 <bms1> When -fwarn-incomplete-patterns is enabled, is there some way to have it warn about incomplete matches in let-bindings or do-notation bindings?
13:41:52 <tasker> could anyone point me to a discrete convolution using Vector ?
13:46:32 <myndzi> i'm not writing in haskell but i'm having a bit of trouble with some functional concepts, hoping it's okay to ask here
13:47:08 <Hijiri> it's probably fine
13:47:10 <myndzi> actually, i suppose the language matters too much for this sort of thing, but i'll try anyway :(
13:47:29 <myndzi> i'm trying to paginate over page requests lazily in javascript with an FRP library and trying to work out how to combine things such that i essentially get a stream of html tags
13:47:50 <myndzi> right now i'm playing with kefir, though i've sort of solved this problem in rx.js before i really dislike rx
13:48:57 <myndzi> so i'm trying to do something like use flat map to combine the contents of the first page with X
13:49:11 <myndzi> X being the contents of the next page.... after i've found the link in the current page and requested it
13:50:13 <myndzi> my current problem is getting it to stop early without making a bunch of requests
13:50:26 <myndzi> which is why, when i thought it over, i think it's too language specific :\
13:50:43 <myndzi> but i have no idea where to get help on this sort of thing
13:51:30 <meretrix> Can anyone explain why I get an ambiguous type error here?
13:51:31 <meretrix> http://paste.hskll.org/get/1901
13:51:59 <fiola> nitrix:  Was that a quote from somewhere?  ("Code has to be continually refactored to not accumulate technical debts.")
13:52:17 <meretrix> I want to store a function in a data type that will apply to any type in a specified type class.
13:53:02 <nitrix> fiola: Nah, just my own words of wisdom after dealing with such projects :)
13:53:44 <nitrix> fiola: Actually, I might have read that somewhere. I mean, it's a popular saying.
13:54:06 <fiola> nitrix: Ah, righto.  Well I know it's a common observation in the mess that is practical computing today, but in the context of FP, I think that notion violates referential integrity.
13:55:20 <nitrix> fiola: I'm not there yet (first couple months into FP, but I'd love to see you right :p)
13:55:40 <fiola> Hehe, I hope so too :-)
13:56:01 <meretrix> I also get why this doesn't work: http://paste.hskll.org/new
13:56:17 <nitrix> fiola: I will dare say that I might have been doing programming wrong for a long time though.
13:56:39 <adamse> @hoogle deep
13:56:40 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
13:56:40 <lambdabot> package deepseq
13:56:40 <lambdabot> package deepseq-generics
13:57:03 <meretrix> oops meant this http://paste.hskll.org/get/1902
13:57:05 <hexagoxel> meretrix: you might wanna read https://www.haskell.org/haskellwiki/Existential_type
13:57:22 <meretrix> Ok, I thought I understood it, but maybe not.
13:57:50 <fiola> nitrix: Ditto, which is why I know it's a huge mess out there.  It even has a name, The Software Crisis, dating back many decades, and it's as true as always today or worse.
13:58:05 <hexagoxel> meretrix: the placement of the forall / type class constraint matters, iirc
13:59:10 <hexagoxel> data A = A { foo :: B x => .. }  /=   data A = forall x . B x => A { foo :: .. }
14:03:23 <hexagoxel> bms1: i simply point you to a recent discussion: http://ircbrowse.net/day/haskell/2015/01/02?id=19780141&timestamp=1420233270#t1420233270
14:03:51 <nitrix> fiola: There's a language out there that I wont name, but it starts with J- and ends with -ava, anyway, the language itself is decent, but the communauty made it flawed. It's a good example of an ecosystem going wrong. There are so many tools to help them, design patterns, and huge conferences, books on the topic, yet I feel no one realise the source of the problem is much below and we just carry it along.
14:03:52 <gamegoblin> Why isn‚Äôt Vector a monadplus?
14:04:37 <hexagoxel> bms1: note glguy's link
14:04:59 <bms1> hexagoxel: Thanks!
14:05:01 <EvanR> gamegoblin: according to the doc, it is
14:05:18 <gamegoblin> EvanR: whoops, google had linked me to an old version that wasn‚Äôt
14:05:18 <nitrix> fiola: It's like we put the smartest minds on the wrong problems. And, if you take Haskell, well, you have the opposite. It's like, people got fed up working on broken systems, took the time to learn the theory, expand the knowledge and implement something concrete on their free time.
14:05:32 <nitrix> fiola: Anyway, just ranting :P I'm not a Java dev :P
14:05:52 <EvanR> i am and youre being incredibly generous
14:06:01 <EvanR> </offtopic>
14:08:45 <bms1> hexagoxel: Yep, the GHC Trac page was very helpful. Thanks!
14:18:11 <fiola> nitrix: You can't fix the world, because you can't fix people, they can only fix themselves.  Picking up Haskell is a bit like leaving the old world behind for a new one, which you can fix unmolested.
14:21:11 <topi> 6
14:23:34 <gamegoblin> is there an equivalent of concat for Data.Sequence?
14:24:07 <hpc>  mconcat should work, i believe
14:24:18 <gamegoblin> ah, gotcha
14:24:32 <hpc> yep, instance Monoid (Seq a)
14:29:11 <ski> fiola : "referential integrity" ?
14:30:49 * hackagebot yesod-purescript 0.0.4.1 - PureScript integration for Yesod  http://hackage.haskell.org/package/yesod-purescript-0.0.4.1 (mp)
14:32:28 <therp> just to rule out that I don't misunderstand the interface of hmatrix's "eig" (for eigenvectors): the call returns something different than my example data for a 2x2 matrix. it is that the last column vector is (-a b) instead of my example's (a -b). as far as I know, eigenvectors are not a particular vector but a set of vector being the multiple of other.
14:32:33 <fiola> ski: Informally, pure expressions don't change their meaning.  The remark about refactoring (which I think comes from non-FP langs) would suggest that expressions break over time, which I think isn't consistent with referential integrity.
14:33:26 <therp> s/don't// (on too many negotation :)
14:33:57 <Hijiri> an eigenvector is any v where Av = \v (pretend \ is lambda)
14:34:04 <Hijiri> so each vector in the set is an eigenvector
14:34:14 <fiola> ski: AKA referential transparency
14:34:16 <Hijiri> so eigenvectors aren't the sets themselves, but what's in the sets
14:34:23 <HeladoDeBrownie> is there any way i can eliminate explicit mention of any of the type variables labeled f in this code, while maintaining generality? https://gist.github.com/HeladoDeBrownie/e00cea0eaf6b8fa89923
14:34:51 <HeladoDeBrownie> the reason it seems i need them is so that i can choose specifically to make the actions used by the Var constructor use IO
14:34:56 <Hijiri> (\ is a scalar value)
14:35:15 <HeladoDeBrownie> choosing another implementation of Var is fine
14:36:27 <hvr> therp: what Hijiri said; eigenvectors are equivalent up to a non-zero scalar factor
14:36:49 <HeladoDeBrownie> notice, e.g., that example is polymorphic over all f. i'd prefer for *every* program in this edsl to be as well, and to do away with that f
14:37:00 <therp> Hijiri: thanks that's what I thought it was.
14:37:35 <therp> Hijiri: then my mistake must be further down the road.
14:38:31 <therp> hvr: hello btw! good to see you
14:38:40 <HeladoDeBrownie> an explanation that what i just asked is not possible would also be good
14:39:17 <ski> fiola : oh, RT
14:40:11 * ski thought "referential integrity" was a concept in the relational database model
14:41:03 <fiola> ski: it is, but they're related, essentially that the meaning of a reference in one place has to be the same as in another.  RT more common in FP.
14:42:13 <fiola> Which is why the idea that code bit rots without refactoring doesn't seem right for FP.
14:42:39 <ski> aiui, referential integrity means that there's "foreign references" between attributes of different relations, "where you expect there to be such"
14:43:54 <fiola> I'd quite like to hear from long-term Haskell programmers if there is such pressure to refactor in Haskell programs as well.
14:44:33 <ski> e.g. a constraint like `forall bookID,authorID. authored bookID authorID => exists title,publicationDate. book bookID title publicationYear'
14:45:27 <ski> would say that for any `bookID' that occurs in the `authored' relation (linking each book to one or more authors), that `bookID' already has to exist somewhere in the "basic"/"entity" relation `book' that describes what books there are
14:46:54 <ski> otoh. referential *transparency* (the concept comes from analytic philosophy, and linguistics, originally) means that every *context* is "referentially transparent"
14:48:10 <fiola> It's just preservation of a given semantic across more than one table, but RDBMS tables aren't relevant to us here, only the core "preservation of semantic" part which is what I'm referring to.
14:48:15 <ski> "Hesperus" and "Phosphorus" are two names for the same thing ("Venus" : the evening star, and the morning star) -- they have the same *denotation*, they *conotate*
14:49:43 <ski> the context "Sara believes that Hesperus is not ..." is not referentially transparent (it is referentially opaque), because even though "Hesperus" and "Phosphorus" denotes the same thing, that context yields two sentences with *different* meanings, when the context hole "..." is filled with one or the other
14:49:57 <ski>   "Sara believes that Hesperus is not Hesperus"
14:50:00 <ski> is not the same as
14:50:04 <ski>   "Sara believes that Hesperus is not Phosphorus"
14:51:19 <ski> referential transparency (or opacity) in programming languages similarly apply to *contexts*, and whether we can substitute one expression for another (with the same denotation/value) in the hole in the context, without changing the meaning of the program (iow refactoring)
14:53:06 <fiola> ski: So link it back to nitrix's quote now, which is what interests me.  Do you feel FP programs with RT (at least the pure functions) are under pressure to refactor with time, or else "accumulate technical debts"?
14:53:34 <ski> you might find "Referential Transparency, Definiteness and Unfoldability" by Harald S√∏ndergaard,Peter Sestoft in 1987-11-30 - 1990-01-04 at <http://www.itu.dk/people/sestoft/papers/SondergaardSestoft1990.pdf> interesting
14:53:40 <ski> also perhaps
14:53:46 <ski> @where purely-functional
14:53:46 <lambdabot> "What is a Purely Functional Language?" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>
14:54:15 <geekosaur> fiola: my personal observation is that all code accumulates technical debt, but the rate and the *kind* of debt varies
14:54:47 <bernalex> ski: is that the paper where they conclude that a purely functional language is one in which there exists a weak equivalence between call-by-need and call-by-value? that paper is a good read, though I do not recall its name.
14:55:16 <bernalex> (amr sabry was one of the authors, or possibly the only author, of the paper I'm thinking of at least.)
14:55:30 <fiola> geekosaur: I don't (currently) see how a pure function can accumulate "technical debt", if that phrase has any objective meaning at all.
14:55:38 <geekosaur> well written haskell code avoids the more common kinds of technical debt but can be subject to improvements in a somewhat mutable ecosystem
14:55:51 <Zemyla> > 93,5::(Fixed E3)
14:55:52 <lambdabot>  <hint>:1:3: parse error on input ‚Äò,‚Äô
14:55:58 <Zemyla> > 93.5::(Fixed E3)
14:55:59 <lambdabot>  Ambiguous occurrence ‚ÄòFixed‚Äô
14:55:59 <lambdabot>  It could refer to either ‚ÄòData.Fixed.Fixed‚Äô,
14:55:59 <lambdabot>                           imported from ‚ÄòData.Fixed‚Äô at L.hs:82:1-17
14:56:18 <geekosaur> that said, I have generally been more a sysadmin than a developer and my view of technical debt differs a bit from pure developers
14:56:18 <Zemyla> > 93.5::(Fixed.Fixed E3)
14:56:19 <lambdabot>  Not in scope: type constructor or class ‚ÄòFixed.Fixed‚Äô
14:56:28 <Zemyla> > 93.5::(Data.Fixed.Fixed E3)
14:56:29 <lambdabot>  93.500
15:00:06 * fiola giggles at "somewhat mutable"
15:00:07 <EvanR> > 93.5 :: Data.Fixed.Milli
15:00:08 <lambdabot>  93.500
15:00:14 <EvanR> Zemyla: ^
15:00:24 <ski> bernalex : basically yes
15:00:50 <ski> (also see the Reddy responses at <http://stackoverflow.com/questions/210835/what-is-referential-transparency/9859966#9859966>,<http://stackoverflow.com/questions/210835/what-is-referential-transparency/11740176#11740176>, and also see <http://www.nobugs.org/blog/archives/2008/11/12/why-do-they-call-it-referentially-transparent/>)
15:01:46 * ski would like to get hold of "Referential Transparency and Allied Notions" by Harald Sondergaard,Peter Sestoft in 1988 :(
15:01:51 <fiola> ski: the link that lambdabot gave for Amr Sabry in 1993-01 failed BTW
15:02:54 <ski> fiola : works here ..
15:03:25 <fiola> I'll try without https
15:03:25 <ski> (maybe you mistakenly managed to include one of the angle brackets in the URL used ?)
15:03:33 <fiola> No, didn't
15:03:39 <ski> ok
15:04:03 <fiola> Came over http fine, apparently a cert problem
15:04:04 <bernalex> ski: I agree with amr's definition btw. it is elegant and precise.
15:04:05 <Zemyla> But yeah, the rounding in Fixed doesn't work at all.
15:04:23 <EvanR> how so
15:04:23 <Zemyla> @let cmfix n = let (nf, nf2, n2f) = ((realToFrac n)::(Data.Fixed.Fixed E1), nf * nf, (realToFrac $ n * n)::(Data.Fixed.Fixed E1)) in (nf2, n2f, nf2 == n2f)
15:04:25 <lambdabot>  Defined.
15:04:31 <bernalex> ski: difficult to explain to programmers that don't have a theoretical background though.
15:04:33 <Zemyla> > cmfix 1.7
15:04:35 <lambdabot>  (2.5,2.8,False)
15:05:05 <Zemyla> > 1.7 * 1.7
15:05:07 <lambdabot>  2.8899999999999997
15:05:08 <ski> fiola : re "Do you feel FP programs with RT ... ?" -- i think so
15:05:18 <ski> bernalex : yes :/
15:06:04 <fiola> ski: By what mechanism of "pressure"?
15:06:06 <bernalex> ski: I know, because when I first read it, years ago, I did not understand it myself. and a prof tried to explain it, but clearly did not understand it himself, so he confused me further. :-]
15:06:09 <ski> fiola : referential transparency and (whatever notion of) purity helps with refactoring though. making more reasoning laws available (to human and computer)
15:06:13 <Zemyla> First off, why is realToFrac 2.89 to Fixed E1 2.8 instead of 2.9?
15:06:19 <ski> fiola : changing requirements
15:06:37 <EvanR> Zemyla: maybe bankers rounding?
15:06:54 <EvanR> even round up, odd round down
15:07:19 <ski> .. doesn't seem to be the case here
15:07:45 <ski> fiola : and more features being implemented, if you don't count that under the former
15:07:50 <fiola> ski: A different program necessitate different code.  That's a different thing to suggesting that code bit rots if not refactored.
15:08:25 <EvanR> Zemyla: nevermind that.
15:08:26 <ski> oh, i suppose i must have misunderstood what you were asking about, then
15:08:51 <Zemyla> Banker's rounding would only explain it if it were 2.85/
15:08:54 <ski> fiola : the libraries that it depends on can still drift away in behaviour
15:08:59 <hexa> hey
15:09:15 <ski> hello, hexa
15:09:19 <hexa> is there a function like $ but that is left associative?
15:09:28 <hexa> so like i could do
15:09:38 <ski> hexa : not any standard one, i think, but you could define it ..
15:09:42 <EvanR> > (realToFrac (2.89 :: Centi)) :: Data.Fixed.E1
15:09:43 <Zemyla> And even so, it shouldn't be using banker's rounding if it's trying to act like a normal floating-point number.
15:09:43 <lambdabot>  No instance for (GHC.Real.Fractional Data.Fixed.E1)
15:09:43 <lambdabot>    arising from a use of ‚ÄòGHC.Real.realToFrac‚Äô
15:09:50 <ski> some of us would prefer `$' to be left associative ..
15:10:03 <EvanR> > (realToFrac (2.89 :: Centi)) :: Data.Fixed.Fixed E1
15:10:05 <lambdabot>  2.8
15:10:12 <EvanR> > (realToFrac (2.88 :: Centi)) :: Data.Fixed.Fixed E1
15:10:13 <fiola> ski: I'm just vaguely worried about the general proposition that nitrix raised.  I've heard it before, and I've experienced the need to refactor, but I think the statement is overreaching by being purely defined.
15:10:14 <lambdabot>  2.8
15:10:15 <hexa> how would I define it, ski?
15:10:24 <EvanR> > (realToFrac (-2.89 :: Centi)) :: Data.Fixed.Fixed E1
15:10:25 <lambdabot>  -2.9
15:10:27 <Zemyla> Fixed is broken.
15:10:32 <bernalex> ski: I've been toying with the idea of making rpn-haskell, heh.
15:10:37 <fiola> s/purely defined/poorly defined/
15:10:42 <ski> hexa : `infixl $$; ($$) :: (a -> b) -> a -> b; f $$ x = f x'
15:10:47 <EvanR> it rounds down, it seems
15:10:53 <ski> hexa : er, i mean `infixl 0 $$'
15:11:06 <hexa> infixl means the precendence right?
15:11:19 <ski> bernalex : RPN, or concatenative ?
15:11:32 <bernalex> ski: I'm not sure what the latter implies.
15:11:51 <ski> the latter is sometimes called "stack-based". e.g. Forth,Factor,Joy
15:11:55 <bernalex> hexa: infix means that it's an operator used infix instead of prefix like other functions. then you use l or r to denote left or right associativity.
15:12:13 <fiola> RPN is postfix
15:12:15 <ski> you can express `3 dup *' in concatenative, but not in RPN
15:12:16 <hexa> ooooohh i get it
15:12:23 <ski> fiola : yes
15:12:28 <Zemyla> Also, ($) is right-associative so you can do (f $ g $ h $ x) and it does the right thing.
15:12:43 <bernalex> ski: oh, right. I'm not entirely sure. maybe some sort of hybrid. I might be working on making a PL this year, so I'll spend some time thinking about this.
15:12:50 <Zemyla> (f $$ g $$ h $$ x) would be (((f g) h) x).
15:13:06 <Zemyla> And that's rarely what you want.
15:13:22 <EvanR> > round 2.8
15:13:24 <lambdabot>  3
15:13:29 <EvanR> > round (-2.8)
15:13:31 <lambdabot>  -3
15:13:33 <EvanR> > round 2.5
15:13:35 <lambdabot>  2
15:13:37 <EvanR> > round 3.5
15:13:38 <lambdabot>  4
15:13:47 <ski> Zemyla : it would be for :  foldl' f z (x:xs) = foldl' f $! f z x $ xs
15:14:05 <hexa> how would I use $$ anyway?
15:14:08 <ski> Zemyla : currently you have to say :  foldl' f z (x:xs) = (foldl' f $! f z x) xs
15:14:16 <ski> hexa : as Zemyla said
15:14:25 <hexa> Oh ok
15:14:42 <hexa> is there a way I could do a thing like this intersperse '.' xs $$ ++ "."
15:14:43 * fiola wonders if ghc can spit out the AST of a program
15:14:47 <hexa> without parentheses
15:14:57 <EvanR> > toRational (2.89 :: Centi)
15:14:58 <lambdabot>  289 % 100
15:15:06 <EvanR> > round (289 % 100)
15:15:07 <lambdabot>  3
15:15:10 <EvanR> >_>
15:15:23 <ski> hexa : it's not clear (to me) what result you want
15:15:46 <Zemyla> Also, round absolutely should not ever be banker's rounding by default.
15:15:48 <ski> hexa : if `xs' is `"abc"', what's the expected answer ?
15:15:54 <hexa> \xs -> (intersperse '.' xs) ++ "."
15:15:54 <EvanR> Zemyla: no?
15:16:03 <Zemyla> There should be a "bankersRound" function to do so.
15:16:03 <hexa> if xs is "abc" it would do "a.b.c."
15:16:22 <hexa> if i remove the parentheses, it gives me an error, is there a way to do it without parentheses?
15:16:41 <ski> hexa : that can be written as just `\xs -> intersperse '.' xs ++ "."' (no brackets needed, though brackets shouldn't be feared. `$' is (usually) uglier, imho)
15:16:48 <EvanR> Zemyla: its the default and recommended rounding more for floating point
15:16:59 <ski> > (\xs -> intersperse '.' xs ++ ".") "abc"
15:17:01 <lambdabot>  "a.b.c."
15:17:01 <Kaidelong> is there a typeclass for things like IO+IOVar, ST+STVar, etc?
15:17:15 <hexa> \xs -> intersperse '.' xs ++ "." gives an error
15:17:16 <Zemyla> It's a violation of expectations.
15:17:26 <EvanR> heh
15:17:30 <hexa> does it?
15:17:31 <hexa> wait
15:17:38 <EvanR> are numeric bias expectated
15:17:42 <hexa> oh jeez
15:17:45 <hexa> it doesn't
15:17:54 <hexa> Thanks, sorry for being stupid
15:18:05 <ski> Kaidelong : sometimes i've seen (or used) `MonadRef'
15:18:15 <EvanR> > round (25 / 10)
15:18:16 <lambdabot>  2
15:18:19 <EvanR> > round (35 / 10)
15:18:21 <lambdabot>  4
15:18:26 <Zemyla> "round", to most people, means "round to nearest, always round up at .5".
15:18:37 <hexa> wait so f $ g $ h $ x would do f(g(h(x))) ?
15:18:48 <Zemyla> Yep.
15:18:49 <EvanR> Zemyla: what do most people expect for negative something .5?
15:18:59 <hexa> Thank you zemlya
15:19:06 <Kaidelong> MonadRef seems to have the wrong type
15:19:08 <Zemyla> Round up.
15:19:13 <hexa> wouldn't f . g . h $ x do the same thing?
15:19:15 <ski> hexa : yes. i'd write that as `(f . g . h) x', or as `f . g . h $ x' if it's really long
15:19:22 <EvanR> Zemyla: toward zero?
15:19:24 <hexa> Oh ok
15:19:32 <hexa> it's because of currying right?
15:19:41 <ski> hexa : `f $ g $ h $ x' is parsed as `f $ (g $ (h $ x))'
15:19:53 <EvanR> Zemyla: you think the default rounding mode should be "toward +infinity"
15:20:00 <Kaidelong> MonadRef fixes IO to only use an IORef and ST to only use STRef
15:20:12 <Kaidelong> this seems like an unneccessary restriction, but I guess it makes type inference easier
15:20:13 <hexa> Ok
15:20:35 <ski> hexa : `.' is preferred here because in `f . g . h', both `f . g' and `g . h' are valid subexpressions that you could (re)factor out into a separation function .. not so with the corresponding `f $ g $ h $ x'
15:20:51 <Kaidelong> but it means you would have to use the newtype hack if you want to use your own reference type
15:21:14 <ski> hexa : currying is unrelated to this
15:21:21 <karshan> > source ($)
15:21:22 <lambdabot>  Not in scope: ‚Äòsource‚Äô
15:21:22 <lambdabot>  Perhaps you meant ‚Äòcoerce‚Äô (imported from Control.Lens)
15:21:29 <Kaidelong> mmm, you also lose some monomorphism, you can't be monomorphic in the monad but polymorphic in the reference
15:21:31 <karshan> :src ($)
15:21:34 <EvanR> > fromRational 289%100 :: Data.Fixed.Fixed E1
15:21:35 <lambdabot>  Couldn't match expected type ‚ÄòData.Fixed.Fixed Data.Fixed.E1‚Äô
15:21:35 <lambdabot>              with actual type ‚ÄòGHC.Real.Ratio a0‚Äô
15:21:35 <karshan> > :src ($)
15:21:37 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
15:21:41 <exio4> f $ x = f x
15:21:47 <exio4> @src ($)
15:21:47 <lambdabot> f $ x = f x
15:21:48 <EvanR> > fromRational (289%100) :: Data.Fixed.Fixed E1
15:21:50 <lambdabot>  2.8
15:21:50 <ski> Kaidelong : yes, i'm not that happy about that FD either. iirc, when i used it, i didn't have the FD
15:22:05 <karshan> exio4: I wanted the fixity declaration as well :/
15:22:13 <EvanR> Zemyla: i see the bug in the code. it does a floor when doing fromRational
15:22:21 <exio4> karshan, it's infixr 0
15:22:24 <Kaidelong> do type families strictly generalize functional dependencies?
15:22:34 <karshan> exio4: ah I see. that makes sense. thanks
15:22:39 <Kaidelong> as an extension, I mean
15:22:54 <ski> Kaidelong : also, one can ponder whether to split it into several classes .. and there should probably be a "modify" operation in the class as well
15:23:10 <EvanR> Zemyla: probably explicit decimal shifting will get what you want
15:23:11 <hexa> thanks ski
15:23:24 <ski> Kaidelong : hm .. how about `class C a b | a -> b,b -> a' ?
15:24:05 <ski> Kaidelong : or `class C a b c | a b -> c,a c -> b,b c -> a' ?
15:25:07 * Kaidelong squints at the second example as he tries to figure out how it isn't a kind error
15:26:09 <ski> Kaidelong : in FD syntax, `a b' there isn't application, it's just a listing of variables that together functionally determine `c'
15:26:17 <Kaidelong> oh alright
15:26:58 <fread2282> is there a concise may to see if two Maybe a values are equal (Nothings are not, Just should recurse)
15:27:14 <Kaidelong> yeah I see what you mean
15:27:22 <Kaidelong> type families only allow FDs in the form of
15:27:31 <Kaidelong> t -> a, t -> b, t -> c, etc
15:27:35 <Hijiri> fread2282: x == y
15:27:39 <Kaidelong> for a singular t
15:27:41 <Hijiri> > Just 5 == Just 5
15:27:42 <lambdabot>  True
15:27:56 <fread2282> > Nothing == Nothing
15:27:57 <lambdabot>  True
15:27:58 <geekosaur> Hijiri, "Nothings are not"
15:28:01 <Hijiri> oh
15:28:03 <Hijiri> didn't see that
15:28:05 <ski> Kaidelong : well, not necessarily, i think. but i think it can have troubles with "cycles" in the FDs
15:28:34 <Zemyla> Actually, EvanR...
15:28:44 <Zemyla> > cmfix 1.7
15:28:45 <lambdabot>  (2.5,2.8,False)
15:28:56 <Zemyla> How is 1.7 * 1.7 = 2.5?
15:29:22 <Zemyla> @let nf = (realToFrac 1.7)::(Data.Fixed.Fixed E1)
15:29:25 <lambdabot>  Defined.
15:29:29 <Zemyla> >nf
15:29:34 <EvanR> > 1.7 * 1.7
15:29:35 <lambdabot>  2.8899999999999997
15:29:35 <Kaidelong> mmm another reason not to fix the reference's type would be because then all you depend on is MultiParamTypeClasses
15:29:43 <Zemyla> > nf
15:29:44 <lambdabot>  1.6
15:29:50 <Kaidelong> which as I understand it, is going to be rolled into the standard
15:30:00 <dropp> hello
15:30:08 <ski> in statically moded (and statically "determined") logic programming, the FDs correspond to "modes" of the predicate/relation (with "semi-deterministic" as associated determinism)
15:30:10 <EvanR> > toRational (1.7 * 1.7)
15:30:12 <lambdabot>  3253850730775183 % 1125899906842624
15:30:17 <Kaidelong> then again this is all moot if mtl is not portable itself
15:30:26 <ski> i think one can also have something like that in deductive database
15:30:39 <EvanR> > fromRational (3253850730775183 % 1125899906842624) :: Data.Fixed.Fixed E1
15:30:41 <lambdabot>  2.8
15:30:48 <Zemyla> > resolution (undefined::E1)
15:30:49 <lambdabot>  Couldn't match expected type ‚Äòp0 a0‚Äô
15:30:49 <lambdabot>              with actual type ‚ÄòData.Fixed.E1‚Äô
15:31:05 <Zemyla> What is p in hasResolution?
15:32:07 <EvanR> Zemyla: guess its implicily quantified?
15:32:13 <Zemyla> > resolution (MkFixed $ (undefined::E1))
15:32:14 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Integer.Type.Integer‚Äô
15:32:15 <lambdabot>              with actual type ‚ÄòData.Fixed.E1‚Äô
15:32:42 <Zemyla> > resolution (Just $ (undefined::E1))
15:32:44 <lambdabot>  10
15:32:47 <EvanR> withResolution foo = withType (foo . resolution)
15:32:55 <EvanR> literally foo in the code
15:34:24 <Kaidelong> oh well
15:34:30 <Kaidelong> there is a ref-fd library as well
15:34:37 <Zemyla> So how the hell does 1.7 become 1.6 with resolution 10?
15:34:43 <hexagoxel> dropp: hi!
15:35:01 <EvanR> > 1.7
15:35:02 <lambdabot>  1.7
15:35:12 <EvanR> > fromRational (toRational 1.7)
15:35:13 <lambdabot>  1.7
15:35:17 <Zemyla> > toRational 1.7
15:35:18 <lambdabot>  7656119366529843 % 4503599627370496
15:35:37 <EvanR> its gotta be something with the fact that youre starting with Doubles
15:35:38 <dropp> hey hexagoxel
15:35:40 <Zemyla> > 1.7::Rational
15:35:42 <lambdabot>  17 % 10
15:35:48 <ski> > toRational 1.7 < 17 % 10
15:35:49 <lambdabot>  True
15:36:07 <EvanR> 1.7 < 1.7 ;)
15:36:12 <Zemyla> So why is toRational 1.7 different from 1.7::Rational?
15:36:13 <karshan> thats IEEE 754 for you
15:36:38 <EvanR> 7656119366529843 % 4503599627370496 is probably closer to the truth than 1.7 is
15:36:58 <karshan> Imagine if our fpu's actually worked with fixed precision rationals instead. Its a trade off, but I think overall it would be better
15:36:59 <ski> > [0.0,0.1 .. 0.3]
15:37:00 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004]
15:37:06 <Zemyla> That's why it needs to do actual rounding.
15:37:17 <EvanR> yeah its the floor
15:37:24 <karshan> > [0.0,0.1 .. 0.3] :: [Rational]
15:37:25 <lambdabot>  [0 % 1,1 % 10,1 % 5,3 % 10]
15:37:31 <Zemyla> > [0.0..0.3] :: [Centi]
15:37:32 <lambdabot>  [0.00,0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.10,0.11,0.12,0.13,0.14,...
15:37:39 <Zemyla> > [0.0..0.3] :: [Deci]
15:37:40 <EvanR> Zemyla: alternatively, you could do actual rounding instead of relying on "magic" coercion
15:37:40 <lambdabot>  [0.0,0.1,0.2,0.3]
15:37:52 <phaazon> god, I read a scala article, which is a scala traduction of the ìWhy Free monads matterî Haskell paper
15:37:56 <phaazon> from tekmo, I guess
15:37:59 <EvanR> but its still surprising and annoying
15:37:59 <karshan> Zemyla: wow that's pretty cool, I didn't know about these types
15:38:02 <ClaudiusMaximus> > approxRational 1.7 0.01
15:38:03 <lambdabot>  17 % 10
15:38:03 <karshan> @src Centi
15:38:04 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:38:04 <phaazon> one point: scala is pretty awful.
15:38:20 <phaazon> (http://eed3si9n.com/learning-scalaz/Free+Monad.html)
15:38:40 <ski> @where src
15:38:41 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
15:39:34 <EvanR> phaazon: wow..
15:39:55 <phaazon> yeah, wow :D
15:40:39 <Zemyla> :t cmfix
15:40:40 <lambdabot> Real s => s -> (Data.Fixed.Fixed E1, Data.Fixed.Fixed E1, Bool)
15:41:44 <Zemyla> But yeah, Fixed is broken.
15:42:46 <EvanR> i think rounding in the coercion might also be weird
15:43:06 <EvanR> you cant expect realToFrac to always do what you want in all combinations
15:43:10 <EvanR> especially with doubles
15:43:34 <EvanR> to go from E2 to E1, just divide by ten first
15:43:51 <EvanR> or multiply
15:44:10 <EvanR> then you dont have to even know what realToFrac wil do
15:45:51 * hackagebot possible 0.1.0.4 - Three valued Data.Maybe  http://hackage.haskell.org/package/possible-0.1.0.4 (tolysz)
15:48:06 <Zemyla> Well, that's why it needs to do actual rounding. Just like a floating-point number x represents all actial numbers [x - 0.5 * eps, x + 0.5 * eps), a fixed-point number n should represent all numbers [n - 0.5/r, n + 0.5/r).
15:48:20 <EvanR> i dont know about that
15:48:45 <EvanR> 2.99 at mcdonalds is exactly 2.99, not 2.99 +/ 0.005
15:48:57 <EvanR> the remainders are all keep track of exactly
15:49:14 <Zemyla> Except when multiplication gets involved.
15:49:26 <EvanR> even when multiplication gets involved
15:49:38 <Zemyla> How many sales taxes have been calculated incorrectly because of Fixed?
15:49:43 <Zemyla> How much interest?
15:49:44 <kaiyin> what is wrong with this code? http://lpaste.net/118270
15:50:16 <EvanR> when you apply extra tax, it comes out to some exact extra amount, and thats all
15:50:18 <osa1> any ideas what happened to this: "We improve the runtime of the benchmarks in our suite by a geometric mean of 42%, and reduce the amount of memory which the benchmarks allocate by a geometric mean of 34%." ? (it's from https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-835.pdf)
15:50:38 <EvanR> theres no remainder involved in sales tax calculations
15:51:05 <phaazon> hey, do you have any toy exercises about comonads?
15:51:18 <phaazon> I understand the abstraction, but I donít get the use of it
15:51:42 <EvanR> implement all the instances for all the standard types
15:51:56 <phaazon> EvanR, what? :D
15:52:01 <geekosaur> kaiyin, because pattern syntax uses the same precedence as expression syntax, rather than requiring you to learn multiple rules, like 4 is parsed as (lastbutOne x):y:ys = ...
15:52:02 <phaazon> thereís no Comonad instance for Maybe
15:52:07 <geekosaur> which isn't valid.
15:52:09 <phaazon> since extract wouldnít exist
15:52:10 <EvanR> for ones that have one
15:52:17 <phaazon> yeah, like what?
15:52:18 <phaazon> Tree?
15:52:21 <geekosaur> you need to parenthesize the pattern, lastButOne (x:y:ys) = ...
15:52:22 <phaazon> I guess Tree might have on
15:52:23 <EvanR> yeah, NonEmpty list
15:52:33 <Zemyla> Well, fromRational definitely needs to round to nearest, since floor produces vastly unacceptable results.
15:52:39 <phaazon> yeah, write, Iím gonna do that
15:52:57 <EvanR> Zemyla: well what if you didnt start with double
15:52:59 <kaiyin> geekosaur, i see. thanks.
15:53:18 <topi> [
15:55:33 <Zemyla> EvanR: If a programmer converts 1.7 to a fixed-point number and gets 1.6, that's not going to increase his confidence in the algorithms used.
15:56:07 <EvanR> there is no such thing as 1.7 in double precision floatin gpoint
15:56:14 <EvanR> that programmer is deluding himself
15:56:23 <Zemyla> Also, "don't ever let doubles touch your fixed-point code or monkeys will fly out of your nose" is a bad argument.
15:56:34 <EvanR> its like "excel is broken because 0.1 + 0.1 isnt 0.2"
15:57:01 <EvanR> doubles and floats are just really hard to reason about
15:57:01 <MP2E> It's not a bad argument, if you understand how floating point numbers work, it's unreasonable to expect the results to be exact
15:57:14 <MP2E> close maybe
15:57:40 <Zemyla> EvanR: Saying (1.7::Double) is 1.7 is wrong. Saying (1.7::Double) is 1.6 is wrong. But saying the two are equally wrong is even more wrong than both of them combined.
15:58:06 <EvanR> theyre not equally wrong, they are both wrong
15:58:20 <EvanR> and the more you try to hide the fact, the harder its going to be to verify
15:58:30 <Zemyla> Well, then it behooves us to produce the answer that is less wrong.
15:58:43 <EvanR> you caught the issue since it was "so wrong", now you can write the code to do it right
15:59:08 <EvanR> the point of using Fixed is so its not even wrong
15:59:16 <EvanR> not less wrong
15:59:19 <Zemyla> Then why does Haskell even have doubles if you aren't ever supposed to use them?
15:59:27 <EvanR> performance
15:59:35 <MP2E> Why do doubles exist at all?
15:59:36 <MP2E> performance.
15:59:44 <Kaidelong> who said you're not supposed to use Doubles?
16:00:10 <Kaidelong> you have to accept that sometimes you get 1.6 instead of 1.7
16:00:14 <Zemyla> EvanR said you aren't ever supposed to use Doubles with Fixed numbers.
16:00:18 <Kaidelong> so long as that's okay, you're golden
16:00:19 <EvanR> i didnt
16:00:50 <dropp> accept that sometimes you get 1.6 instead of 1.7?!
16:00:51 <EvanR> but using the constant 1.7 :: Double as an input the fixed point math is probably not a good idea.
16:01:00 <EvanR> youll never get 1.7 as a real double value in real life so it doesnt amtter
16:01:35 <Zemyla> Okay, we have two choices: Either change the code so it produces relatively consistent results, or write a warning saying that if you try to convert Doubles to Fixed, demons start flying out of your nose.
16:01:49 <EvanR> they fly out of your nose either way
16:02:12 <EvanR> at some point someone will expand the difference between the two not-equal numbers, and be mad
16:02:19 <Kaidelong> "change the code so it produces relatively consistent results" <- this seems impossible to me
16:02:53 <Kaidelong> you're wanting to take an imprecise (by design) representation and map it to a precise representation with no error?
16:02:57 <EvanR> floor seems better to me than "round toward positive infinity" at least
16:04:05 <EvanR> nevermind, floor rounds toward negative infinity
16:04:14 <Zemyla> So what if a programmer can't avoid working with both doubles and fixed-point numbers? What if they have to interface with a legacy library?
16:04:39 <EvanR> they need to be really careful, perhaps the magic conversion should be eliminated ;0
16:04:45 <Kaidelong> then there will be inaccuracies in their results
16:04:50 <Kaidelong> although
16:04:58 <Kaidelong> maybe they should just work with floating point
16:06:11 <PrinceMachiavell> I thought floating points had the same problem.
16:06:18 <ski> MP2E : floating-point is one way to handle approximations of real numbers. see the topic of <http://en.wikipedia.org/wiki/Numerical_analysis>
16:06:22 <ski> @where floating-point
16:06:22 <lambdabot> "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
16:06:29 <Zemyla> EvanR: So they should write an explicit conversion to do what the library should do sensibly in the first place?
16:06:50 <EvanR> yeah you should definitely write explicit conversions to meet your specific needs
16:07:22 <Zemyla> And to force them to do that, you're going to leave the standard Fixed library returning nonsense.
16:08:31 <EvanR> probably better to not have that
16:09:15 <Zemyla> So it shouldn't have any built-in way of converting from any other numeric instance to Fixed.
16:09:37 <EvanR> or, no adhoc ways to convert anything from Double
16:10:00 <EvanR> or all parties are to blame, Double Fixed and Rational
16:10:36 <MP2E> interesting reads :p
16:10:45 <Zemyla> Why are you arguing so hard against fromRational doing rounding instead of using floor?
16:10:56 <EvanR> it shouldnt do floor
16:11:15 <EvanR> im not a numeric dude, but id feel better if it was truncate
16:11:42 <EvanR> Fixed point calcluations arent rounded they are truncated
16:12:15 <EvanR> > 12.34 / 1.23 :: Centi
16:12:17 <lambdabot>  10.03
16:12:25 <EvanR> > 12.34 / 1.23
16:12:26 <lambdabot>  10.032520325203253
16:12:36 <Zemyla> "You're not a numeric dude" Well, guess what, I am.
16:12:55 <EvanR> ... but you dont like bankers rounding...
16:13:29 <EvanR> > 12.34 / 1.227
16:13:30 <lambdabot>  10.057049714751425
16:13:35 <EvanR> > 12.34 / 1.227 :: Centi
16:13:37 <lambdabot>  10.11
16:13:51 <EvanR> > 12.340 / 1.227 :: Milli
16:13:53 <lambdabot>  10.057
16:14:04 * EvanR throws hands up
16:14:17 <Zemyla> Okay, even if we're using banker's rounding, we should be doing rounding of some kind.
16:14:29 <EvanR> give me Z | S N
16:14:36 <Zemyla> Does that make sense?
16:14:50 <EvanR> bankers rounding makes sense if you asked the computer to round
16:15:03 <EvanR> your code wasnt asking for rounding it was asking for a type conversion
16:15:59 <phaazon> ok
16:16:06 <phaazon> I got NonEmpty Comonad instance implemented
16:16:10 <phaazon> thatís interesting
16:16:18 <phaazon> it looks look some kind ofÖ forward iterator
16:16:23 <phaazon> like*
16:16:37 <dropp> I wish I understood Monads. I am sort of getting them, but not there yet :-|
16:16:55 <EvanR> phaazon: data Stream a = Stream a (Stream a) ...
16:17:01 <dropp> I just started with Haskell about two months ago thou
16:17:02 <Kaidelong> you know all the laws and methods, dropp?
16:17:03 <athan> dropp: Think "monoid in category of endofunctors"
16:17:07 <athan> oh shoot
16:17:13 <athan> do you know what a monoid is?
16:17:18 <EvanR> phaazon: yeah, did you get the laws right
16:17:34 <phaazon> duplicate (a :| b) generates a non-empty list of all ìforward iterated non empty sub listsî
16:17:39 <phaazon> EvanR, yeah
16:17:43 <phaazon> my implementation is pretty stupid :)
16:17:52 <phaazon> extract (a :| _) = a
16:18:04 <phaazon> duplicate (a :| l) = (a :| l) :| dupList l
16:18:18 <phaazon> dupList [] = []; dupList (x:xs) = (x :| xs) : dupList xs
16:18:20 <dropp> I am not like, up on my category theory or anything, no :-) But I get the general gist that they're used for bringing impurity into purity
16:18:29 <Zemyla> EvanR: Yes, but even if you're converting types, you should be as correct as possible.
16:18:33 <Kaidelong> dropp: that's not actually right
16:18:35 <EvanR> heres a standard one data Store s a = Store s (s -> a)
16:18:46 <athan> dropp: It's actually moreso an organizational technique
16:18:48 <phaazon> I think Iím gonna make the Tree instance first
16:18:53 <dropp> Kaidelong: Correction, I don't know the general gist of it after all :-)
16:18:58 <athan> monads just appear in a lot of places
16:19:00 <EvanR> Zemyla: but if you didnt want it to round, how is it more correct than truncate?
16:19:00 <Kaidelong> dropp: Monads are about (>>=), fmap, <*>, and return, and their associated laws
16:19:03 <bms1> Is it possible to ever convince Haskell of type disequalities when the typechecker is following type family rules?
16:19:06 <Kaidelong> they really are not about anything other than that
16:19:12 <EvanR> if you did want it to round why not program it to
16:19:16 <athan> dropp: Monads are fuctors, too, remember
16:19:17 <Kaidelong> IO happens to be a monad, but that's all
16:19:21 <athan> (and applicatives now)
16:19:31 <athan> functors*
16:19:41 <bms1> I have written a type-level Symbol (a.k.a type-level string) based list lookup
16:19:46 <Zemyla> EvanR: Because with rounding, the maximum error is 0.5/r. With truncation, the maximum error is 1/r.
16:19:47 <Kaidelong> however!
16:19:59 <Kaidelong> you can say that monads are about functions that do "extra things"
16:20:20 <EvanR> Zemyla: assuming that rounding is correct yeah. by that defition, truncate is almost always "wrong"
16:20:29 <EvanR> why have it
16:20:31 <Zemyla> Therefore, you want to have the solution that minimizes the maximum error by default.
16:20:31 <bms1> But can't write the corresponding "runtime" function because I can only convince Haskell of equality constraints, not disequality constraints
16:20:36 <dropp> what's the diff between fmap and map?
16:20:38 <EvanR> because people want it to truncate, or floor, or whatever
16:20:46 <Kaidelong> dropp: map is specialized to list, that's all
16:20:49 <EvanR> in a type conversion, its ambiguous
16:20:51 <athan> dropp: If I have a functor `F (x)`, I can do some action on x `x -> y`, such that I get `F (y)`
16:21:08 <Kaidelong> there's no difference between map and fmap except in their types
16:21:09 <phaazon> Kaidelong, thatís actually applicative
16:21:31 <athan> dropp: If I have a functor of actions `F (fs)`, and some functor of inputs `F (x)`, then I can piecewise apply `x` to `fs` like `F fs <*> F x`
16:21:38 <Kaidelong> phaazon: I don't think so, do you get ArrowApply or a kleisli category out of applicatives?
16:21:52 <athan> the first one is functo
16:21:55 <athan> functor*
16:22:00 <athan> the second is applicative
16:22:06 <Zemyla> EvanR: Because I want to minimize surprise to programmers, instead of maximizing it.
16:22:13 <Kaidelong> anyway one way to look at monads is as functions that can do more than just map type t to type u
16:22:25 <EvanR> then dont let them use floats
16:22:31 <Zemyla> To pad the edges of floating-point representations, instead of honing them with a whetstone.
16:22:36 <athan> dropp: Monads let us reduce nested Functors
16:22:41 <phaazon> Kaidelong, Applicative can do that
16:22:58 <athan> so `join $ F (F x) = F x`
16:23:01 <phaazon> you can use IO as an applicative functor
16:23:07 <EvanR> i definitely avoid floats in real life, they have not much use in databases, websites
16:23:31 <phaazon> monads enable you to ìextractî value out of the structure and repack them
16:23:34 <dropp> would a monad always need to take input from a nested function?
16:23:43 <Kaidelong> phazon: applicative gives you "f (a -> b) -> f a -> f b" rather than "(b -> m c) -> (a -> m b) -> (a -> m c)
16:23:48 <phaazon> dropp, that doesnít make sense
16:23:51 <phaazon> a monad doesnít take anything
16:23:55 <Zemyla> Well, see, there's the difference. I am primarily a programmer of games. I need floats.
16:23:59 <athan> dropp: No, but you can stage things with >>=
16:24:01 <athan> so like
16:24:05 <EvanR> phaazon: well, you cant extract a value out of a monadic value, generally. there may not be a value
16:24:19 <Zemyla> However, I jeed them converted to fixed so they can be passed through networks portably.
16:24:21 <phaazon> EvanR, thatís why I said ìit enables youî
16:24:26 <EvanR> Zemyla: yeah i can see that. but why do you need fixed? ...
16:24:32 <EvanR> Zemyla: theres a better way to do that with floats
16:24:33 <athan> dropp: if I have two expressions with types `F x` and `F y`, I can run them together with `do {F x; F y}`
16:24:33 <Kaidelong> so I misspoke up there
16:24:45 <Kaidelong> one way to think of monads is to instead think of kleisli arrows
16:24:52 <athan> dropp: That's the same as `F x >> F y`
16:25:04 <phaazon> you can also see them as ìfunction with hidden contextsî
16:25:08 <Kaidelong> kleisli arrows are like functions with added functionality, that can be composed together
16:25:08 <phaazon> or ìstatesî
16:25:09 <Zemyla> Also, you don't have a horse in this race, as you have admitted, so why are you fighting against rounding so hard?
16:25:16 <phaazon> (thatís what monad-control is about)
16:25:19 <EvanR> Zemyla: if you format the float in base 16, with printf or something, its an exact representation of the float. then you can read it back with scanf family
16:25:19 <athan> if I instead had `\y -> F y`, I could do this:
16:25:30 <athan> dropp: `F x >>= \y -> F y`
16:25:35 <dropp> athan: I got that part, chaining with >> instead of the do block
16:25:37 <Kaidelong> this is basically what IO could be seen to be about
16:25:52 <athan> dropp: It's weird, bind is the same as join from a different angle
16:25:54 <phaazon> yeah
16:26:03 <phaazon> I like to see monads as ìfunction decoratorsî
16:26:11 <dropp> applying the output of F x to y ?
16:26:11 <phaazon> like Maybe, which decorates function with failure
16:26:14 <athan> because if you only use the functor, you would just keep nesting the expressions, not unifying them to the same level dropp
16:26:24 <phaazon> Either, which decorates functions with failure with errors
16:26:29 <athan> dropp: That's exactly right
16:26:31 <Kaidelong> although the real issure here is that you can look at monads from many different viewpoints
16:26:40 <athan> moreso, we're pulling `x` out of `F x`'s context
16:26:46 <Kaidelong> you can see them as giving contexts to values (like functors) where the context is collapsible
16:26:47 <athan> and injecting it into `F y`
16:26:52 <Kaidelong> that's the return + bind interpretation
16:27:04 <phaazon> thereís also the join one
16:27:05 <athan> which is basically the same as wrapping `F x` into `F (F x)` and joining them dropp
16:27:06 <Kaidelong> or as a space where functions are allowed to have special extra effects
16:27:14 <Kaidelong> which is the kleisli arrow interpretation
16:27:33 <Zemyla> Also, I think unbiased rounding should be round-to-odd, rather than round-to-even, so that 0.5 and -0.5 don't both become 0.
16:27:42 <athan> dropp: Check this out:
16:27:47 <phaazon> there was a debate a few months ago here, saying that monads should be implemented in terms of join
16:27:54 <Kaidelong> since monads can be seen from many angles, it's fruitless to try and understand "monads"
16:27:54 <athan> > Just 1 >>= (\x -> Just x)
16:27:55 <lambdabot>  Just 1
16:28:02 <athan> dropp: ^
16:28:09 <EvanR> Zemyla: just saying for the network issue, you dont have to round at all
16:28:15 <phaazon> Kaidelong, yeah
16:28:27 <phaazon> the most important thing to understand is the mathematical idea
16:28:29 <phaazon> the type signatur
16:28:30 <phaazon> e
16:28:31 <dropp> oh sweet, nice bot :-)
16:28:31 <athan> > Just (+1) <*> Just 1 -- dropp
16:28:33 <lambdabot>  Just 2
16:28:37 <Kaidelong> when you've seen them used a lot, you can recognize them all over the place
16:28:57 <EvanR> Kaidelong: alternatively, when you can view the same object from many angles to get many pictures, it begs the question what the pure object is like ;)
16:28:58 <athan> > Just 1 >> Just 2 -- dropp
16:29:00 <lambdabot>  Just 2
16:29:10 <athan> > Just 1 >> Nothing -- drop
16:29:12 <lambdabot>  Nothing
16:29:17 <athan> dropp* :P
16:29:19 <phaazon> athan, bad example :P
16:29:24 <phaazon> > Just 1 >> Nothing >> Just 5
16:29:26 <lambdabot>  Nothing
16:29:27 <athan> that's actually how it is!
16:29:38 <athan> > Just 1 <> Nothing -- dropp
16:29:39 <lambdabot>  No instance for (GHC.Show.Show a0)
16:29:39 <lambdabot>    arising from a use of ‚ÄòM34758121874141957017458.show_M34758121874141957017...
16:29:39 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
16:29:44 <athan> oops
16:29:50 <athan> > Just True <> Nothing -- dropp
16:29:51 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Bool)
16:29:51 <lambdabot>    arising from a use of ‚ÄòData.Monoid.<>‚Äô
16:29:53 <dropp> that's really good for a basic example though, it makes a lot of sense for a building block of them
16:29:55 <athan> ><
16:30:02 <athan> > Just () <> Nothing -- dropp
16:30:03 <lambdabot>  Just ()
16:30:04 <PrinceMachiavell> Is lambda currying related to monads? They seem similar.
16:30:11 <athan> dropp: Okay those were bad examples :P
16:30:19 <phaazon> > Just (Any True) <> Nothing
16:30:21 <lambdabot>  Just (Any {getAny = True})
16:30:30 <athan> PrinceMachiabell: Its closer to CCCs
16:30:31 <phaazon> > Just (All True) <> Nothing
16:30:32 <lambdabot>  Just (All {getAll = True})
16:30:49 <dropp> > :t <>
16:30:50 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
16:30:56 <phaazon> :t (<>)
16:30:57 <lambdabot> Monoid m => m -> m -> m
16:30:57 <dropp> > :t (<>)
16:30:59 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
16:30:59 <dropp> :-)
16:31:12 <athan> PrinceMachiavell: currying is like this:
16:31:18 <dropp> oh, i was thinkingt he > was a prompt for it
16:31:30 <PrinceMachiavell> athan: CCCs  ?
16:31:30 <dropp> thanks phaazon
16:31:33 <phaazon> dropp, it is
16:31:47 <EvanR> phaazon: heres another one i encountered, possible comonad, ... newtype B a = B (Double -> a)
16:31:47 <phaazon> but if you want to interact with the ìmetaî part of it, just use : directly
16:31:54 <EvanR> oops
16:32:02 <phaazon> EvanR, like a function that takes time?
16:32:06 <phaazon> oh
16:32:06 <Iceland_jack> Mentioning CCCs is a great idea
16:32:07 <athan> PrinceMachiavell: A x B |- C  ~   A |- C => B
16:32:08 <phaazon> let me guess
16:32:10 <phaazon> B likeÖ
16:32:11 <EvanR> newtype B a = B (Double -> (a, B a))
16:32:12 <phaazon> Behavior !
16:32:18 <athan> PrinceMachiavell: Closed Cartesian Category
16:32:24 <phaazon> youíre an FRP guy!
16:32:45 <EvanR> phaazon: this gives you a value some time in the future, plus a "continuation"
16:32:52 <phaazon> Iíd love to add some smart abstractions in my codebase
16:33:01 <athan> PrinceMachiavell: (feel free to ask questions)
16:33:02 <phaazon> like comonads, contravariant and profunctors
16:33:20 <phaazon> I actually think I could use contravariant to implement ìadaptorsî
16:33:27 <phaazon> however, I have no idea about profunctors :D
16:33:53 <exio4> contravariant what?
16:34:02 <phaazon> contravariant functor
16:34:09 <phaazon> :t contramap
16:34:10 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
16:34:11 <phaazon> that ^
16:34:17 <athan> phaazon: That's badass man, I've been toying in the little kids area for too long
16:34:23 <EvanR> lol
16:34:26 <phaazon> :D
16:34:29 <phaazon> well
16:34:33 <athan> what's an adaptor?
16:34:37 <phaazon> Iím using Free monads in my 3D engine
16:34:39 <phaazon> thatís pretty neat
16:34:48 <athan> wow man, that's beyond me
16:34:52 <phaazon> athan, I†see contramap as a way to create adaptors
16:34:55 <phaazon> for instance
16:34:55 <EvanR> get out of jail free monad
16:35:03 <phaazon> if you know a predicate
16:35:19 <phaazon> like Int -> Bool
16:35:27 <EvanR> contra lets you compose predicate conditions
16:35:31 <EvanR> thats all i know
16:35:47 <phaazon> you could adapt that predicate to a generate a predicate on lists
16:35:54 <athan> EvanR: As in chain them? Or...?
16:35:58 <EvanR> yeah
16:35:59 <phaazon> contramap length
16:36:01 <EvanR> backwards
16:36:16 <athan> OH WOAH
16:36:24 <EvanR> but predicates are annoying ;)
16:36:26 <athan> is that useful for the inductive list direction or something?
16:36:37 <Kaidelong> is [] unique in that join == mconcat?
16:36:37 <phaazon> athan, the first time I saw contramapís signature
16:36:42 <phaazon> my mind exploded :D
16:36:43 <dropp> hey, thanks athan, phaazon, Kaidelong for the monadic explanations :-) i'll be back later
16:36:46 <athan> LOL
16:36:49 <phaazon> :t contramap
16:36:50 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
16:36:51 <phaazon> like
16:36:59 <phaazon> like
16:36:59 <athan> dropp: \o
16:37:02 <phaazon> you have (a -> b)
16:37:04 <phaazon> you give it a b
16:37:07 <phaazon> and you get a a
16:37:09 <phaazon> :P
16:37:22 <EvanR> theres also comap :: CoFunctor f => (b -> a) -> f b -> f a
16:37:25 <phaazon> then you use it, and understand the whole thing :)
16:37:28 <Kaidelong> oh no, it isn't
16:37:35 <Kaidelong> I mean literally, it is, but not in the sense I meant
16:37:37 <athan> EvanR: :P
16:37:39 <Kaidelong> @ty fold
16:37:40 <lambdabot> (Monoid m, Foldable t) => t m -> m
16:37:55 <phaazon> but yeah, contravariant functor = backward.
16:38:03 <phaazon> and profunctor = both :D
16:38:07 <athan> paazon: What are some example contravariant functors?
16:38:10 <phaazon> contravariant AND covariant
16:38:13 <athan> a list could be one, right?
16:38:13 <phaazon> (bifunctor)
16:38:21 <athan> !!
16:38:22 <phaazon> athan, predicates
16:38:23 <athan> !!!!!!!
16:38:26 <Kaidelong> > fold (map enumFromTo 1 [1..10])
16:38:27 <lambdabot>  Couldn't match expected type ‚Äò[t1] -> t0 m‚Äô
16:38:27 <lambdabot>              with actual type ‚Äò[a0 -> [a0]]‚Äô
16:38:28 <athan> >:OOOO
16:38:31 <phaazon> a list couldnít
16:38:38 <EvanR> a list cant be a contrafunctor
16:38:40 <Kaidelong> > fold (map (enumFromTo 1) [1..10])
16:38:41 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,1,2...
16:38:47 <phaazon> athan, imagine this:
16:38:58 <Kaidelong> so the real think you'd be looking for is stuff where join == fold
16:38:58 <phaazon> contramapList :: (a -> b) -> [b] -> [a]
16:39:03 <phaazon> how would you write such an instance?
16:39:20 <zq> :t (!!!!!!!)
16:39:21 <lambdabot> Not in scope: ‚Äò!!!!!!!‚Äô
16:39:29 <Kaidelong> not all functions are contravariant functors
16:39:35 <Kaidelong> functors*
16:39:38 <phaazon> however, a predicate:
16:39:52 <phaazon> contramapPredicate :: (a -> b) -> (b -> Bool) -> (a -> Bool)
16:39:55 <athan> phaazon: Oh wait I think I see!
16:39:59 <phaazon> thatís easy to see we can implement that
16:40:21 <athan> through a prepend
16:40:27 <EvanR> though booleans tests arent the greatest glue
16:40:28 <phaazon> a composition, yeah
16:40:35 <Kaidelong> the canonical example IMO would be for functions
16:40:36 <ski> EvanR : `CoFunctor' is a bad name
16:40:36 <Kaidelong> (.
16:40:41 <Kaidelong> (.) is fmap for functions
16:40:47 <Kaidelong> flip (.) is contramap
16:41:00 <EvanR> ski: capitalization?
16:41:04 <Kaidelong> :t flip (.)
16:41:05 <lambdabot> (a -> b) -> (b -> c) -> a -> c
16:41:07 <athan> > fix ("!" ++)
16:41:08 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
16:41:16 <athan> That's awesome Kaidelong :)
16:41:18 <ski> s/for functions/for functions considered as environment-actions/
16:41:58 <ski> EvanR : no. "Co" suggests duality, but the concept of an ordinary functor is not dual to the concept of a "cofunctor"
16:42:03 <phaazon> :t extend
16:42:04 <lambdabot> Not in scope: ‚Äòextend‚Äô
16:42:05 <Zemyla> > fix (\x -> (x + 2.0/x) / 2)
16:42:06 <EvanR> ski: yes i was joking
16:42:09 <lambdabot>  mueval-core: Time limit exceeded
16:42:13 <Kaidelong> ski: well okay yeah functions form two different functors, that's right, and the covariant one is different from the contravariant one
16:42:20 <phaazon> @let import Control.Comonad
16:42:21 <lambdabot>  <no location info>:
16:42:21 <lambdabot>      The package (tagged-0.7.2) is required to be trusted but it isn't!
16:42:22 <ski> EvanR : the proper names are "(covariant) functor" and "contravariant functor"
16:42:23 <phaazon> :(
16:42:25 <Kaidelong> so I guess it might be confusing
16:42:25 <ski> EvanR : oh
16:42:25 <athan> There's no ContraMonads are threre? 0_o
16:42:37 <phaazon> athan, it‚Äôs in a package called contramap
16:42:45 <Kaidelong> athan: I don't see why there shouldn't be myself
16:42:45 <phaazon> hu
16:42:48 <ski> athan : not that i'm aware of
16:42:53 <phaazon> comonad*
16:42:58 <phaazon> but it‚Äôs more the dual of a monad
16:43:02 <phaazon> not a ‚Äúcontravariant‚Äù version
16:43:03 <Kaidelong> comonads are still covariant
16:43:06 <phaazon> yeah
16:43:06 <ski> yes
16:43:18 <athan> Yeah I cant think of a use
16:43:26 <phaazon> of what?
16:43:31 <athan> but thank you guys, you're steering me on the right track :)
16:43:34 <athan> a contravariant monad
16:43:41 <phaazon> well
16:43:47 <phaazon> I think it does exist
16:43:51 <phaazon> might be in mmorph
16:43:57 <phaazon> or a similar package
16:43:59 <Kaidelong> :t join . fmap
16:44:00 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f a)
16:44:00 <lambdabot>     Expected type: (a -> b) -> f a -> f a -> b
16:44:00 <lambdabot>       Actual type: (a -> b) -> f a -> f b
16:44:16 <EvanR> :t f . g
16:44:17 <lambdabot>     Could not deduce (Show b0) arising from a use of ‚Äòf‚Äô
16:44:17 <lambdabot>     from the context (FromExpr c, Show a)
16:44:17 <lambdabot>       bound by the inferred type of it :: (FromExpr c, Show a) => a -> c
16:44:18 <ski> athan : i'm not even sure how one would attempt to formulate the operations of the "contramonad" (as natural transformations, or something of that vein)
16:44:26 <athan> :t (\x -> join . fmap t)
16:44:27 <lambdabot>     Couldn't match expected type ‚Äòa1 -> m a‚Äô with actual type ‚ÄòExpr‚Äô
16:44:27 <lambdabot>     In the first argument of ‚Äòfmap‚Äô, namely ‚Äòt‚Äô
16:44:27 <lambdabot>     In the second argument of ‚Äò(.)‚Äô, namely ‚Äòfmap t‚Äô
16:44:40 <phaazon> hm
16:44:45 <phaazon> I think (a,) is a also a comonad
16:44:51 <phaazon> I‚Äôm gonna try to write the instance
16:44:51 <Kaidelong> :t (join .) . fmap
16:44:51 <EvanR> yeah
16:44:51 <ski> phaazon : no
16:44:52 <lambdabot> (Functor m, Monad m) => (a1 -> m a) -> m a1 -> m a
16:45:01 <Kaidelong> there we go
16:45:09 <ski> it's a monad (called "output" or "writer")
16:45:10 <athan> lol
16:45:16 <ski> (assuming `a' is a monoid)
16:45:28 <Kaidelong> :t ((undefined :: (a -> b) -> (f b -> f a)) .) . fmap
16:45:29 <lambdabot> (a1 -> b) -> (a -> a1) -> f b -> f a
16:45:34 <Kaidelong> there we go
16:45:39 <Kaidelong> there's our contravariant monad
16:45:42 <EvanR> ski: isnt it also the Environment comonad
16:45:50 <EvanR> no monoid
16:45:54 <athan> Ha!
16:46:00 <ski> Kaidelong : you replaced `join' by `contramap' ?
16:46:06 <Kaidelong> oh whoops
16:46:11 <Kaidelong> thanks for catching that
16:46:31 <Kaidelong> :t (join .) . (undefined :: (a -> b) -> (f b -> f a))
16:46:32 <lambdabot> Monad m => (m a -> b) -> m b -> m a
16:46:32 <ski> EvanR : yes and yes
16:46:33 <EvanR> extract (e, x) = x
16:46:45 <ski> EvanR : that is using the trivial comonoid, in fact
16:46:48 <Kaidelong> okay, well, that looks a lot better, doesn't it
16:46:55 <EvanR> cojoin f (e, x) = (e, (e, f x))
16:47:02 <ski> (there are no nontrivial comonoids in `Hask')
16:47:15 <EvanR> comonoid?
16:47:17 <Kaidelong> or any cartesian closed category, right?
16:47:18 <ski> yes
16:47:30 <phaazon> arf
16:47:41 <phaazon> ((,) a) is already defined as a comonad
16:47:48 <phaazon> I‚Äôm gonna make a wrapper :P
16:47:52 <Zemyla> You know what, Evan? You're right. The programmer should specify the rounding mode for a Fixed number.
16:48:01 <EvanR> phaazon: everything we discussed is already defined in comonads package ;0
16:48:02 <ski> EvanR : `class Comonoid a where destroy :: a -> (); duplicate :: a -> (a,a)', satisfying coassociativity and counit laws
16:48:19 <athan> !
16:48:23 <Profpatsch> So I‚Äôve got some data Foo { ‚Ä¶ fooOptions :: [?] }. A fooOption has a name and some value which can be basically anything, but the list can of course have fooOptions of different types.
16:48:24 <phaazon> EvanR, yeah but I defined my own NonEmpty list :P
16:48:27 <Profpatsch> How would I do that?
16:48:28 <Zemyla> FixedR E1 Truncate, or FixedR E1 Bankers, or so on.
16:48:58 <Zemyla> They just shouldn't have to write the code themselves.
16:49:00 <ski> @type System.Random.split  -- cf. `duplicate'
16:49:01 <lambdabot> RandomGen g => g -> (g, g)
16:49:11 <EvanR> ski: i see so theres really only one such instance
16:49:19 <ski> EvanR : in `Hask', yes
16:49:20 <Profpatsch> data FooOption a doesn‚Äôt work, because then the [FooOption a] can only take fooOptions that take the same kind of values.
16:49:30 <ski> EvanR : in other categories, there can be nontrivial comonoids
16:50:06 <phaazon> ahah
16:50:12 <ski> EvanR : e.g. in `Kleisli []' (if you ignore ordering)
16:50:13 <Zemyla> Profpatsch: What are you doing with the values in the list?
16:50:13 <phaazon> the instance for (a,b) is ridiculous :P
16:50:15 <spopejoy> anyone know why 'deepseq' causes 'trace' not to fire? i was hoping to just force eval of a big datastructure in GHCI without printing it out, and see the Debug.Trace output. No dice.
16:50:23 <phaazon> duplicate (a,b) = (a,(a,b))
16:50:23 <ski> phaazon ?
16:50:45 <spopejoy> :t trace
16:50:46 <lambdabot> Not in scope: ‚Äòtrace‚Äô
16:51:00 <ski> phaazon : that corresponds to `join f a = f a a'
16:51:05 <EvanR> yeah i messed up the cojoin above
16:51:08 <Profpatsch> Zemyla: First I‚Äôm parsing some JSON from a golang program (that breaks its type system with interface{} for such things).
16:51:25 <Profpatsch> Then I want to use the info to do some stuff.
16:51:27 <phaazon> hm
16:51:29 <phaazon> interesting
16:51:33 * ski prefers to call `cojoin', `scaffold'
16:51:36 <phaazon> extend fst (2,1) = (2,2)
16:51:47 <phaazon> it looks a bit like reflection isn‚Äôt it :)
16:51:55 <phaazon> that reminds me the loeb function :P
16:52:01 <platz> codensity is contravariant as well i believe
16:52:04 <EvanR> phaazon: eh, its basically a Reader
16:52:09 <EvanR> CoReader
16:52:12 <ski> phaazon : yes, `loeb'-like stuff is related
16:52:31 <ski> platz : no
16:52:33 <phaazon> extend sounds very important
16:52:35 <phaazon> I should inquire
16:52:43 <EvanR> =>= is cool ;)
16:52:52 <phaazon> oh
16:52:57 <spopejoy> e.g., a function foo = trace "bar" "baz" in ghci prints "bar\nbaz". deepseq () foo just prints "baz". What happened to the trace output?
16:52:59 <phaazon> isn‚Äôt extend id == duplicate?
16:53:17 <EvanR> yes
16:53:21 <phaazon> :)
16:53:26 <phaazon> so basically
16:53:28 <EvanR> thats a possible law
16:53:29 <Zemyla> Do you have a definition of "some stuff"? Because you either need to have a list of types the data in the JSON objects can be, or a class that defines all the things that can be done to the objects.
16:53:29 <platz> @define newtype Codensity m a = Codensity { runCodensity :: forall b. (a -> m b) -> m b }
16:53:30 <lambdabot>  .L.hs:195:1:
16:53:30 <lambdabot>      Multiple declarations of ‚ÄòCodensity‚Äô
16:53:30 <lambdabot>      Declared at: .L.hs:192:1
16:53:35 <phaazon> a comonad lets you ‚Äúlook up‚Äù at the structure
16:53:51 <phaazon> and the resulting value is inserted where it‚Äôs fetched from
16:53:53 <EvanR> phaazon: or down, or all around, depending on the structure
16:54:02 <phaazon> yeah sure
16:54:08 <phaazon> hm, let‚Äôs try with non empt
16:54:09 <phaazon> y
16:54:12 <phaazon> sounds more tricky
16:54:13 <platz> changing the 'a' to 'c' alters the 'a' in the 'input position', no?
16:54:16 <ski> platz : right. clearly covariant in `a'
16:54:30 <ski> (`c' ?)
16:54:48 <EvanR> phaazon: it lets you do an fmap, but with a view of more than just the spot youre replacing
16:54:59 <EvanR> how much more, depends
16:55:13 <Zemyla> Profpatsch: For instance, if you had a list of objects which could all be Shown, you could write 'data Showable = forall a. (Show a) => Showable a'.
16:55:34 <ski>   extend (uncurry (+)) (2,1)  =  (2,3)
16:55:42 <Zemyla> But then the only thing you could do with the objects is call 'show' on them.
16:55:43 <EvanR> phaazon: as such, extend doesnt affect the structure, only the values. unlike monads
16:55:49 <platz> instance Functor (Codensity k) where fmap f (Codensity m) = Codensity (\k -> m (k . f))  -- f alters the input to k, not the output
16:56:10 * ski would prefer to call comonadic extension something else. possibly `preserve'
16:56:10 <phaazon> yeah
16:56:11 <phaazon> hm
16:56:15 <phaazon> extend on NonEmpty is weird
16:56:21 <EvanR> ski: yeah it doesnt seem to extend at all
16:56:33 <EvanR> phaazon: its similar to Stream
16:56:48 <ski> there already is a *monadic* extension operator, `(=<<)' (that former name is used in the literature)
16:56:53 <phaazon> oh
16:56:54 <platz> I admit when higher order functions I don't quite understand how the terminology works
16:57:31 <Zemyla> (The exception is 'data IsData = forall a. (Data a) => IsData a, which lets you do pretty much whatever you want by dismantling and rebuilding the obkects. :P)
16:57:40 <Profpatsch> Zemyla: An option in the json looks like {"name"="foo", "value"="bar", "type"="int"}
16:57:52 <ski> platz : because `a' is "to the left" of two (an even number) `->', `a' occurs positively/covariantly in `forall b. (a -> m b) -> m b'
16:58:06 <phaazon> ahah
16:58:09 <phaazon> that‚Äôs so weird :D
16:58:36 <phaazon> http://lpaste.net/118273
16:58:43 <Profpatsch> Zemyla: But I see that they don‚Äôt even use the "type" field, so I guess I‚Äôm just gonna use string for everything.
16:58:46 <ski> each application of of `(-> ...)' to some type flips the polarity of the components of it
16:59:01 <ski> this is because `a -> b' is contravariant in `a', but covariant in `b'
16:59:06 <EvanR> phaazon: right. fmap with the "rest of the list" provided as input
16:59:08 <Profpatsch> Funny, because that way the program is going to crash with a bad config file.
16:59:14 <ski> two negatives makes a positive
16:59:18 <phaazon> yeah
16:59:27 <phaazon> it‚Äôs a special fold
16:59:31 <phaazon> yeah, a map
16:59:39 <phaazon> a map with a see of the structure
16:59:46 <EvanR> extend extract is fmap
16:59:47 <phaazon> it‚Äôs a focus with-context
17:00:07 <EvanR> er is id
17:00:13 <ski> in `(\k -> k 0 && k 1) :: (Int -> Bool) -> Bool' .. clearly this in some sense contains/provides `Int' (as opposed to consuming it)
17:00:17 <phaazon> yeah
17:00:21 <phaazon> fmap would be‚Ä¶
17:00:23 <phaazon> extend f ?
17:00:26 <phaazon> no
17:00:26 <EvanR> no
17:00:44 <phaazon> extend f . duplicate
17:00:45 <EvanR> extend (f . extract)
17:00:58 <EvanR> or that
17:01:15 <phaazon> that‚Äôs very interesting
17:01:25 <spopejoy> nm btw, my NFData instance was bad
17:01:28 <Zemyla> Profpatsch: Look at the Real World Haskell site, http://book.realworldhaskell.org/
17:01:32 <gamegoblin> Guys, I was wanting to make some structure that would allow me to use List monad type of non-determinism but with lots of list-like structures in the same go. Please tell me if I am reinventing the wheel or if there is a better way to do this http://lpaste.net/118274
17:01:42 <gamegoblin> I‚Äôd appreciate it if anyone could take a look
17:02:03 <Zemyla> They talk about parsing and printing JSON data in two of the chapters.
17:02:42 <ski> phaazon : no, that doesn't work
17:02:45 <platz> hm ok, then i guess this confused me https://hackage.haskell.org/package/kan-extensions-3.7/docs/Data-Functor-Coyoneda.html the note about "a *covariant* Functor"
17:02:46 <HeladoDeBrownie> gamegoblin, what operations do you want to support? there's Foldable, Traversable, Functor...
17:03:08 <EvanR> phaazon: im working on one.. its the type Store R2 Color. by using =>= on values of this type, its a combination of image painting and image effects
17:03:16 <ski> platz : yes. "covariant" vs. "contravariant" is distinct from "X" vs. "coX"
17:03:24 <gamegoblin> HeladoDeBrownie: I just want to be able to do list-like non-determinism, but with different types of list-like structures all at once
17:03:37 <phaazon> EvanR, sounds great :)
17:03:42 <EvanR> phaazon: in my case, for pixel graphics. so you can have warps, fogs, mirrors, etc
17:03:47 <gamegoblin> HeladoDeBrownie: think the list monad in do-notation, but with any list-like structure
17:03:51 <HeladoDeBrownie> gamegoblin, how are you going to encode that non-determinism using types?
17:04:05 <HeladoDeBrownie> gamegoblin, and laws
17:04:08 <platz> ski: yes, but in this case the 'a' appears in the other position in the first arg, compared to codensity, where it appears in the first position
17:04:22 <platz> how can they both be covariant when the 'a' appears in different positions?
17:04:25 <gamegoblin> HeladoDeBrownie: The code I pasted does what I want, you can see what it does, I was just wondering if there was a better way
17:04:27 <phaazon> EvanR, despite the use of Free, my 3D engine is basically like an imperative engine
17:04:33 <phaazon> I‚Äôd love to make it more‚Ä¶ haskellish
17:04:39 <phaazon> but it‚Äôs not that simple
17:04:42 <EvanR> yeah
17:05:28 <phaazon> latest screenshot from it http://i.imgur.com/FRk3mOT.png
17:05:31 <ski> platz : which case are you talking about here ?
17:05:35 <phaazon> I took it on the afternoon :)
17:05:41 <gamegoblin> HeladoDeBrownie: you can see I‚Äôm using Foldable, Functor, and Monoid to accomplish this
17:05:45 <phaazon> however, it‚Äôs a very declarative engine
17:05:52 <EvanR> nice
17:05:58 <platz> ski: comparing Coyoneda to Codensity
17:05:58 <phaazon> you declare everything you want, and hop, just call render :)
17:06:02 <HeladoDeBrownie> gamegoblin, sorry, i had missed the url somehow
17:06:03 <EvanR> you know about #haskell-game ?
17:06:08 <phaazon> yeah, I‚Äôm on it :)
17:06:25 <HeladoDeBrownie> gamegoblin, i don't notice any wheels being reinvented there
17:06:27 <yulate> call render?
17:06:46 <phaazon> yulate, the interface of the engine is a Free-like monad
17:06:52 <phaazon> you have a few combinators
17:07:01 <phaazon> like load (to load assets), render, postProcess and display
17:07:03 <platz> ski: i think it's that maybe one is a newtype and the other is a gadt
17:07:30 <phaazon> however I‚Äôm not satisfied with that way of doing
17:07:35 <phaazon> the same way I don‚Äôt want to use FRP
17:07:40 <phaazon> because it‚Äôs too‚Ä¶ tight
17:07:41 <ski> platz : ah, i see. well that definition is essentially the same as `data CoYoneda f a = forall b. MkCoYoneda (b -> a) (f b)' .. iow `CoYoneda f a' is iso to `exists b. (f b,b -> a)' -- clearly `a' occurs positively/covariantly here
17:07:45 <phaazon> I want the more freedom as possible
17:07:52 <ski> platz : presumably the GADT syntax here threw you off
17:07:53 <phaazon> and even a Free monad is a too tight constraint
17:08:48 <EvanR> phaazon: the type of a game (ignoring IO stuff) i have not seen a good one yet ;)
17:09:07 <phaazon> yeah
17:09:10 <phaazon> well
17:09:16 <EvanR> IO is the crunchy outside. and with games, the inside is always also crunchy in another way
17:09:29 <phaazon> the issue with a Free monad is very simple
17:09:36 <phaazon> I can‚Äôt cover all uses
17:09:48 <phaazon> I take a few IO¬†actions lifted into the Free monad
17:09:59 <phaazon> like a user event poller (IO [u])
17:10:04 <phaazon> a log handler (Log -> IO ())
17:10:08 <phaazon> but that‚Äôs pretty all
17:10:14 <platz> ski: ah, well thanks; clears that up
17:10:20 <phaazon> if the user wants to do some socket networking at each frame, he just can‚Äôt :(
17:10:37 <phaazon> some guys advised me to use FreeT, but I‚Äôm not certain it‚Äôs a good idea
17:10:38 <EvanR> yeah
17:10:46 <phaazon> (and furthermore, Free is fucking slow!)
17:10:54 <phaazon> (and I yeah, I know F and optimize)
17:10:54 * hackagebot atlassian-connect-descriptor 0.3.0.0 - Code that helps you create a valid Atlassian Connect Descriptor.  http://hackage.haskell.org/package/atlassian-connect-descriptor-0.3.0.0 (RobertMassaioli)
17:11:23 <phaazon> I just think I shouldn‚Äôt export a ‚Äúyou do that that way, or you don‚Äôt do it‚Äù design
17:11:29 <phaazon> a lot of FRP frameworks do that
17:11:34 <phaazon> and it‚Äôs a disgrace to me
17:11:52 <phaazon> like ‚Äúyou have to build an ugly FRP network to make it work‚Äù
17:12:16 <phaazon> such things should be put in specific packages
17:12:23 <phaazon> like the mvc package, which does make sense to me
17:12:24 <EvanR> building a network seems like the wrong way around to me
17:12:30 <phaazon> yeah
17:12:37 <EvanR> using monad fix or arrows
17:12:47 <phaazon> I‚Äôm not for too intrusive designs
17:13:28 <EvanR> i also think that functions of the form Game -> Bool to try to define conditions on which events should trigger, is wrong
17:14:06 <EvanR> but also, describing the action in terms of when stuff collides is a natural thing to do
17:14:15 <phaazon> in my engine
17:14:31 <EvanR> when pacman collides with a ghost (in certain context), X happens, where X is a bunch of stuff
17:14:36 <phaazon> the events are handled in a function of the form Event -> Photon a
17:14:41 <phaazon> where Photon is my Free-like monad
17:14:46 <phaazon> (my engine‚Äôs called photon :) )
17:14:59 <HeladoDeBrownie> so your functions emit photons, huh
17:15:03 <phaazon> :)
17:15:07 <HeladoDeBrownie> that was a bright thing to do
17:15:09 <EvanR> lol
17:15:46 <EvanR> yeah Event -> Photon a, so what is the effect of doing this
17:15:57 <EvanR> and whats the a
17:16:18 <phaazon> a is user-defined
17:16:44 <phaazon> and Photon is the engine monad, so that you can, for instance, call load, log, render or postProcess
17:17:18 <EvanR> monad code that uses that function will get any a they want back (or it does a "goto")
17:17:53 <phaazon> EvanR, the ‚Äúa‚Äù is user-defined, like MyApp
17:17:59 <EvanR> ok
17:18:11 <phaazon> Event -> MyApp -> Photon MyApp
17:18:15 <phaazon> oh yeah
17:18:18 <phaazon> Event -> a -> Photon a
17:18:35 <phaazon> and the a is passed around in the ‚Äúframe loop‚Äù
17:18:41 <phaazon> which is implemented in internal
17:18:49 <phaazon> however, I‚Äôm going to change that
17:18:51 <EvanR> instance Monad Photon where ?
17:18:59 <phaazon> ahah
17:19:09 <phaazon> type Photon = Free PhotonCmd
17:19:11 <phaazon> ;)
17:19:13 <EvanR> so you should be able to combine actions of type Photon Bool, Photon (), and Photon MyApp
17:19:16 <EvanR> oh
17:19:32 <phaazon> yeah
17:19:36 <EvanR> well im still confused
17:19:54 <phaazon> PhotonCmd is a bunch of actions you can do
17:19:56 <phaazon> like
17:20:20 <phaazon> data PhotonCmd n = Render SceneDescription n | Display n | ‚Ä¶
17:20:41 <EvanR> n?
17:20:42 <phaazon> you define the logic of your application in the Free version of PhotonCmd
17:20:44 <phaazon> yeah
17:20:53 <phaazon> Render myScene Display
17:21:00 <phaazon> it‚Äôs a free monad
17:21:05 <phaazon> so that I can do
17:21:08 <phaazon> do { render myScene; display }
17:21:16 <EvanR> oh, its recursive?
17:21:18 <phaazon> yes
17:21:23 <phaazon> well
17:21:24 <phaazon> not really
17:21:46 <phaazon> but it‚Äôs defined with the idea that it could be recursive, yeah
17:22:39 <EvanR> how do you terminate a expression of type PhotonCmd
17:22:41 <EvanR> n
17:22:48 <EvanR> Display up there takes an arg
17:23:08 <phaazon> with a special command, Destroy
17:23:13 <phaazon> it quits the application
17:23:25 <EvanR> nevermind i guess ill have to read about free monads
17:23:36 <EvanR> im not sure monads are the right abstraction for a game
17:23:43 <phaazon> you could also terminate it with Pure
17:23:49 <phaazon> what abstraction would it be then?
17:24:05 <EvanR> got me, theres a whole universe out there
17:26:04 <phaazon> :)
17:26:04 <RustyShackleford> i'm going to make another attempt at learning haskell. I'm wondering if you have a good idea for a toy project
17:26:11 <EvanR> phaazon: theres a lot of mixed models in a given video game... each one needs to be modeled differently to achieve the desired amount of clarity, performance, flexibility
17:26:24 <RustyShackleford> something not too trivial that would let me experiment with haskell's different features
17:26:27 <EvanR> you can make models in isolation, but then they dont fit together
17:26:34 <EvanR> so theres gotta be some way to link them
17:26:45 <EvanR> frp is one model
17:27:02 <EvanR> non-reactive animation is one
17:27:11 <phaazon> yeah
17:27:14 <EvanR> game trees
17:27:23 <phaazon> RustyShackleford, yeah
17:27:28 <phaazon> do you know codingame?
17:27:40 <phaazon> I‚Äôm used to doing their challenges
17:27:57 <phaazon> pick one, like the multiplayer ones (you have to write smart AI)
17:28:01 <phaazon> and do it in Haskell
17:28:05 <phaazon> they support it :)
17:28:30 <phaazon> I won a rasberry pi, T shirts and a Drone Parrot AR :P
17:28:55 <RustyShackleford> hm that looks sorta interesting
17:29:08 <phaazon> yes it is, it‚Äôs also so much fun
17:29:15 <phaazon> I don‚Äôt know when the next one is
17:29:15 <RustyShackleford> i kinda dislike having to code in the browser
17:29:25 <phaazon> yeah, but well
17:29:32 <phaazon> it‚Äôs just AI
17:31:26 <RustyShackleford> well maybe i'll try it. How long did it take you to complete?
17:31:32 <phaazon> off to bed, it‚Äôs 2:28¬†AM, and I‚Äôll have to work in a few hours :P
17:31:52 <phaazon> RustyShackleford, the ‚ÄúMultiplayers‚Äù challenges run for 10 days
17:31:59 <phaazon> you can write an AI in a few hours
17:32:04 <phaazon> and enhance it each day
17:32:09 <phaazon> so it depends
17:32:21 <phaazon> the ‚Äúponctual‚Äù challenges are less than two hours long
17:32:36 <phaazon> I might find something from my codebase, wait
17:32:49 <RustyShackleford> and an unrelated question: how do you pronounce "haskell"?
17:33:20 <phaazon> ohohoh! next multiplayer challenge the 26th!
17:33:26 <phaazon> RustyShackleford, I‚Äôm French
17:33:41 <phaazon> so I said [askel]
17:33:42 <EvanR> hask…ôl
17:33:55 <phaazon> yeah, like EvanR
17:34:24 <RustyShackleford> hah what's the upsidedown e again? So it's like haskull?
17:34:33 <EvanR> maybe not
17:34:33 <phaazon> ohoh
17:34:35 <phaazon> 224/48621
17:34:38 <phaazon> I have a nice rank :P
17:35:13 <EvanR> http://www.forvo.com/word/haskell/
17:35:24 <phaazon> http://www.codingame.com/challengereport/340622fd484d574a02af69c74bfdfcc19da2b7
17:35:28 <phaazon> don‚Äôt know if you can see that
17:35:35 <phaazon> don‚Äôt look the second exercise
17:35:44 <phaazon> I didn‚Äôt provide a code to make it through :D
17:35:46 <phaazon> however
17:35:53 <phaazon> I‚Äôm pretty proud of my solution for the first one :)
17:35:59 <EvanR> Ààh√¶sk…ôl
17:36:08 <Kaidelong> huh? Pascal?
17:36:30 <RustyShackleford> okay. "haskell" sounds like "rascal"?
17:36:46 <RustyShackleford> you gotta admit, thats a wierd word haha
17:36:50 <phaazon> ok, off to bed
17:36:52 <phaazon> see you :)
17:36:53 <phaazon> night
17:37:10 <EvanR> pas'kal
17:39:14 <RustyShackleford> oh you say it like that?
17:39:48 <EvanR> Pascal, yeah
17:39:55 <HeladoDeBrownie> i once spoke with an older person with a cs degree during a dance, so it was loud, and i told her i programmed in haskell and she was like "oh yeah, i've done some pascal"
17:40:33 <johnw> I've had people give me that response in a perfectly quiet room :-)
17:41:24 <EvanR> ive heard has'kel, but this is almost certainly wrong
17:41:25 <rjsalts> people still program in pascal, only it's usually the object oriented extension called delphi now
17:43:35 <rjsalts> and first time I heard of haskell I thought that they were pronouncing pascal wrong, even though I'd studied miranda the year before
17:53:28 <gamegoblin> Is there a generic version of filter? like fmap is more generic than map, is there a more generic filter?
17:53:47 <gamegoblin> that would work on sequence, vector, list, etc
17:54:01 <EvanR> yeah
17:54:12 <gamegoblin> What is it/where is it?
17:54:42 <EvanR> ... *computer noises*
17:55:37 <EvanR> https://www.haskell.org/haskellwiki/Foldable_and_Traversable#Some_trickier_functions:_concatMap_and_filter
17:56:16 <EvanR> filter :: (Applicative f, Foldable f, Monoid (f a)) => (a -> Bool) -> f a -> f a
17:56:21 <EvanR> gnarly
17:57:16 <EvanR> gamegoblin: so the answer is basically no, not at this time
17:57:34 <EvanR> but each big data collection module usually has a filter-like function
17:57:48 <EvanR> probably a lot faster than the above generic one
17:58:28 <gamegoblin> Time to make a Filter typeclass ;)
17:59:41 <EvanR> theres probably a good reason why it doesnt exist (if it doesnt exists yet)
17:59:57 <gamegoblin> Such as?
18:00:11 <EvanR> thats just the intuition i get from haskell libs
18:01:16 <EvanR> gamegoblin: try to write the filter function for this data type: data Tree a = Tree a [Tree a]
18:01:56 <benzrf> :t foldM
18:01:56 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
18:02:29 <EvanR> you can use foldable to get a list to filter, but you may not be able to restore the structure as it was "without" some of the elements
18:03:03 <gamegoblin> EvanR: Your datastructure doesn‚Äôt make any sense, I think, because it can‚Äôt have 0 elements?
18:03:23 <EvanR> ok then write it for Maybe (Tree a) ;)
18:06:20 <gamegoblin> Involves some weird tree manipulations, but it can be done
18:06:31 <EvanR> how?
18:07:57 <gamegoblin> It also depends a lot on the contract for how the elements are stored in the tree
18:08:04 <gamegoblin> If it‚Äôs just a set-like structure it‚Äôs pretty easy
18:08:11 <EvanR> no contract
18:08:11 <gamegoblin> You can just flatten it to a single layer ;)
18:08:19 <EvanR> yeah, a list
18:08:28 <EvanR> you can do this for any Foldable
18:15:57 * hackagebot hasql 0.7.2 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.7.2 (NikitaVolkov)
18:37:26 <_um_> Good time of day, haskellers.
18:37:48 <_um_> What a more elegant way of doing this:
18:38:04 <_um_> > foldr ((++) . fromJust) [] [Just [1,2,3,4], Just [5,6,7]]
18:38:06 <lambdabot>  [1,2,3,4,5,6,7]
18:38:19 <_um_> Or is there?
18:38:27 <shachaf> That depends on what "this" is.
18:38:31 <vanila> > maybe [] id =<< [Just [1,2,3,4], Just [5,6,7]]
18:38:33 <shachaf> Does it include crashing if there's a Nothing in the list?
18:38:33 <lambdabot>  [1,2,3,4,5,6,7]
18:38:58 <_um_> sorry I was too fast for you snark, shachaf :(
18:39:30 <shachaf> I didn't really think of it as snark. But you need to specify what happens in the Nothing case.
18:39:33 <_um_> Handling Nothing would be nice.
18:39:40 <vanila> > msum [Just [1,2,3,4], Just [5,6,7]]
18:39:41 <lambdabot>  Just [1,2,3,4]
18:39:44 <vanila> > msum [Just [1,2,3,4], Just [5,6,7], Nothing]
18:39:45 <lambdabot>  Just [1,2,3,4]
18:39:49 <vanila> hm
18:39:55 <vanila> what do you want to do on nothing
18:39:56 <_um_> msum! that's a nice one.
18:39:59 <_um_> Nothing.
18:40:04 <shachaf> msum is doing the wrong thing here
18:40:05 <_um_> Just treat it like an empty list.
18:40:11 <vanila> > sequence [Just [1,2,3,4], Just [5,6,7], Nothing]
18:40:13 <lambdabot>  Nothing
18:40:15 <Iceland_jack> Yeah, that's not sequence
18:40:15 <vanila> > sequence [Just [1,2,3,4], Just [5,6,7]]
18:40:17 <lambdabot>  Just [[1,2,3,4],[5,6,7]]
18:40:39 <Iceland_jack> you want something like 'catMaybes'
18:40:42 <Iceland_jack> @ty catMaybes
18:40:45 <lambdabot> [Maybe a] -> [a]
18:41:10 <Iceland_jack> Then you can 'concat' the result.
18:41:16 <karshan> > ['h', 'e', 'l', 'l', 'o']
18:41:17 <lambdabot>  "hello"
18:41:18 <_um_> Iceland_jack: I'll check it out.
18:41:19 <karshan> [1,2,3]
18:41:26 <karshan> > [1,2,3]
18:41:27 <lambdabot>  [1,2,3]
18:41:37 <shachaf> > let l = [Just [1,2,3,4], Nothing, Just [5,6,7]] in [y | Just x <- l, y <- x] -- so many different ways
18:41:38 <lambdabot>  [1,2,3,4,5,6,7]
18:41:42 <Iceland_jack> > concat (catMaybes [Just [1,2,3,4], Nothing, Just [10,20,30]])
18:41:43 <lambdabot>  [1,2,3,4,10,20,30]
18:41:44 <shachaf> > toListOf (traverse.traverse.traverse) [Just [1,2,3,4], Just [5,6,7]]
18:41:45 <lambdabot>  [1,2,3,4,5,6,7]
18:41:54 <karshan> how does that work ? how is show specialized for [Char]
18:42:11 <shachaf> karshan: The Show type class definition has a special hack for it.
18:42:20 <vanila> its some weird hack
18:42:24 <karshan> hmm
18:42:29 <vanila> the typeclass has a special field for lists
18:42:33 <vanila> and normally it has a default
18:42:40 <vanila> but char overrides it with that
18:42:41 <karshan> I ask because Data.String.IsString doesn't have a toString function in the class
18:42:46 <_um_> A wealth of handy solutions. Thanks for the help!
18:42:56 <karshan> and I was planning to use show
18:43:07 <shachaf> IsString is a bad name for that class.
18:43:29 <karshan> then I can write string functions with type (IsString a) => a -> a
18:43:49 <karshan> and they will work with all strings... rather than having to do some crazy stuff with unpacking and packing
18:43:58 <karshan> when using multiple libraries
18:44:11 <shachaf> That class is really not meant for that. :-(
18:44:19 <shachaf> And show is especially bad for it.
18:44:58 <karshan> I know, its hacky. but it is quite annoying to do f (BS.pack $ LBS.unpack str)
18:45:09 <karshan> or T.pack etc...
18:45:17 <glguy> More like: class WasString
18:45:25 <zq> badum tish
18:45:43 <karshan> actually LBS and BS is a bad example, consider Text and ByteString
18:45:49 <shachaf> Well, don't use Data.ByteString.{,Lazy}.Char8 in the first place
18:46:07 <shachaf> That solves your problem.
18:46:20 <shachaf> The IsString instance for ByteString is badly broken.
18:46:43 <karshan> umm, I want to use Network.Wreq for example, and it uses Lazy ByteStrings to represent HTTP responses
18:46:52 <karshan> then I want to throw that into XML.Light
18:47:04 <shachaf> OK, but you shouldn't use Data.ByteString.Char8 or the IsString instance for ByteStrings.
18:47:11 <karshan> which won't take lazy ByteStrings
18:47:15 <shachaf> You should be using decodeUtf8 or something like that.
18:47:30 <karshan> yea
18:47:39 <shachaf> If you really want to do things like the thing you're saying, you're probably best off making your own type class or your own something. IsString and Show are very ill-suited for it.
18:47:40 <karshan> I guess that makes sense
18:47:46 <karshan> @src decodeUtf8
18:47:47 <lambdabot> Source not found. The more you drive -- the dumber you get.
18:47:49 <shachaf> (And of course it'll be terribly inefficient too.)
18:48:00 <_um_> What is the reigning sentiment on using Data.String.Conversions?
18:48:02 <shachaf> (You shouldn't be doing it in the first place.)
18:48:42 <karshan> yea, I agree its terrible and inefficient, but while prototyping (especially in the repl) it is *really* annoying to pack and unpack strings all the time :(
18:48:43 <_um_> *("prevailing" is probably a better word there).
18:49:30 <EvanR> > text "abc"
18:49:32 <lambdabot>  abc
18:49:36 <EvanR> :t text
18:49:37 <lambdabot> String -> Doc
18:49:40 <EvanR> nvm
18:49:54 <Iceland_jack> _um_: Agreed
18:50:23 <_um_> Iceland_jack: What with?
18:50:51 <Iceland_jack> That working with strings/bytes in Haskell is underdocumenting and often annoying
18:51:17 <_um_> Oh! I didn't make that point, but I have also found it to be so!
18:51:31 <Iceland_jack> I added some things :)
18:51:43 <_um_> When I was trying figure out the Aeson library I ended up using that Data.String.Conversions function `cs` for a while, and it really helped ease my work flow.
18:52:31 <_um_> Could just do things like `decode (cs "{\"k\":\"v\"}")` instead of packing into ByteStrings.
18:52:41 <_um_> Iceland_jack: very well added.
18:53:24 <glguy> karshan: this module has a function to turn your lazy bytestring into a string: http://hackage.haskell.org/package/utf8-string-0.3.8/docs/Data-ByteString-Lazy-UTF8.html
18:53:41 <_um_> But I have no idea of the tradeoffs or what good reasons there might be fore avoiding Data.String.Conversions.
18:53:53 --- mode: ChanServ set +o glguy
18:54:07 --- mode: glguy set +b *!~tumaru@99.Red-79-153-211.dynamicIP.rima-tde.net
18:54:07 --- kick: tumaru was kicked by glguy (Your behavior is not conducive to the desired environment.)
18:54:46 * EvanR doubletake
18:58:07 --- mode: glguy set +b-bo *!*@99.Red-79-153-211.dynamicIP.rima-tde.net *!~tumaru@99.Red-79-153-211.dynamicIP.rima-tde.net glguy
18:58:55 <Zemyla> Question. If a newtype is in WHNF, then is the object it contains also in WHNF?
18:59:13 <shachaf> Yes.
19:06:28 <Axman6> Zemyla: newtypes only exist during type checking basically, newtype Foo a = Foo a has exactly the same run time representation as the a within
19:11:30 <Twey> Hm, well.  That means that ‚ÄòWHNF‚Äô with regards to the newtype *constructor* isn't a concept that makes sense ‚Äî a newtype is *always* in WHNF (there is never a thunk that, when forced, yields the constructor, since there is no constructor at runtime).
19:12:05 <Twey> Practically speaking, you could say that newtypes are always in WHNF ‚Äî the thunk is only ever for their argument
19:14:03 <Kaidelong> I think newtypes actually do show up at runtime under certain specific circumstances
19:14:25 <Twey> Kaidelong: What circumstances?
19:14:47 <Kaidelong> trying to find it on google
19:17:29 <Vennix> https://www.youtube.com/watch?v=hP42YTD0YGM
19:18:30 <Twey> Kaidelong: As far as I know, various features (e.g. GeneralizedNewtypeDeriving) rely on that not being the case
19:19:13 <Kaidelong> Twey: apparently the canonical example is this
19:19:38 <Kaidelong> product -- O(n)
19:19:49 --- mode: ChanServ set +q *!*@unaffiliated/vennix
19:19:54 <Kaidelong> mconcat . map Product -- O(n) + O(n)
19:20:16 <Kaidelong> when you're trying to tell apart f t from f u, there can be overhead
19:20:34 <Kaidelong> but
19:20:38 <Kaidelong> I guess that's not what I thought
19:20:45 <Kaidelong> it doesn't actually tag the type at runtime
19:20:47 <Twey> Kaidelong: Isn't that just because naively, map Product ‚áí map id?
19:20:53 <n4x> considering the constructor something like "id" works
19:21:02 <Kaidelong> yes
19:21:08 <Kaidelong> apparently GHC cannot optomize away map id
19:21:09 <Twey> (I'd assume stream fusion would catch that, afterwards)
19:21:14 <Twey> Huh, interesting.
19:21:31 <shachaf> Kaidelong: whoa, that's as much O(2n)!
19:21:32 <Twey> Even with a high -O level?
19:21:39 <Twey> Hehe.
19:21:43 <Kaidelong> yes, it's a constant factor
19:21:51 <Kaidelong> but newtypes are *supposed* to be entirely free, shachaf
19:21:58 <shachaf> Anyway, the newtypes aren't going to "exist" at runtime, but the fact that you're using newtypes can have a runtime overhead.
19:22:02 <Twey> Kaidelong: The newtype is free; the map isn't
19:22:15 <Kaidelong> nonetheless if you want to use the newtype, you incur overhead
19:22:22 <shachaf> It could be that Newtype = id, but map Newtype = map id /= id
19:22:39 <Twey> Don't we have a RULE for map id?
19:22:45 <Kaidelong> yes
19:22:49 <Kaidelong> fmap id == id
19:22:51 <Kaidelong> functor law
19:22:51 <Twey> I wonder if those are applied before or after the newtype transformation.
19:22:56 <shachaf> Kaidelong: That's not a RULE.
19:23:02 <Kaidelong> oh
19:23:04 <Kaidelong> I see
19:23:05 <shachaf> But maybe there is one, so maybe it works for lists, but not necessarily for other things.
19:23:07 <Kaidelong> you meant a rewrite rule
19:23:12 <Kaidelong> not rule, emphasis
19:23:16 <Twey> Yes
19:23:23 <Twey> I don't use capitals for emphasis, sorry ‚ò∫
19:23:43 <shachaf> What about Data.Set.map Newtype?
19:23:49 <shachaf> That can completely rearrange your tree.
19:24:37 <Kaidelong> mmm, that's true, another reason why Data.Set is somewhat silly for relying on Ord instances rather than low level representations
19:25:09 <Twey> Kaidelong: Low-level representations may not be canonical
19:25:57 <Kaidelong> to me that seems like the better tradeoff for the role people usually use maps in (key-value maps)
19:26:00 <Twey> You want at least that a == b ‚áí member a s == member b s, surely
19:26:10 <Kaidelong> but I guess with Set
19:26:15 <Kaidelong> you actually do want that
19:26:27 <Twey> Things would get really weird otherwise.
19:26:27 <Kaidelong> so mm, I guess that's fair enough
19:26:57 <Kaidelong> well
19:27:22 <Kaidelong> you could enforce the same result by doing member a s == member b s and then only doing the (possibly expensive) a == b later
19:28:02 <Kaidelong> (does Data.Text at least do pointer equality as its first resort when comparing Text?)
19:28:07 <Twey> Kaidelong: True.  But then you still need an Eq constraint.
19:28:41 <Kaidelong> yeah getting rid of the constraint would be another reason to make some kind of low level hash table
19:28:55 <Kaidelong> Haskell doesn't seem to have that many great mutable data structures =/
19:30:43 <karshan> @src maybe
19:30:43 <lambdabot> maybe n _ Nothing  = n
19:30:43 <lambdabot> maybe _ f (Just x) = f x
19:31:52 <Twey> Kaidelong: No, it doesn't work, because there are also false negatives.  Consider the case where a == b, but not a ‚â° b (using ‚â° for representational equality).  If you have a in the map or set and try to look up b, you have no way of *finding* a in the tree.
19:32:07 <Twey> (actually, there are *only* false negatives‚Ä¶)
19:32:49 <Twey> You need the Ord constraint to respect Eq at all
19:33:55 <Twey> The representational ordering can at best be used as an optimization; you need to fall back to using Ord if you don't find anything
19:34:09 <Kaidelong> Twey: well the idea would be, whatever state you have that originally put the key in the hash table would retain that exact same key
19:34:10 <Twey> And that means you need to have an Ord-ordered representation, too
19:34:40 <Kaidelong> Hash tables work in practice in places like C++
19:34:46 <Twey> Kaidelong: Sure, I can see it for weird low-level bit-hacking things, but you don't get any kind of sane semantics out of it.
19:35:06 <Twey> Certainly Data.Map and Data.Set shouldn't have this behaviour
19:36:00 <Kaidelong> Mm
19:36:27 <Twey> I'd say they're practical in C++ because in C++ value equality is usually considered to be equivalent to representational equality; that's really not the case in Haskell, where we insert pointers everywhere and have a higher-level notion of equality we expect things to respect in the first place
19:36:33 <Kaidelong> When I've worked with Haskell, I've mostly had to work at a low level because the libraries to do much else just aren't there so I keep getting frustrated at the lack of good interfaces with C and the like
19:36:48 <Kaidelong> so maybe that colors my perspective
19:37:25 <bjorkintosh> Kaidelong, welcome to the frustration of pioneers.
19:37:58 <bjorkintosh> Discovered new land. Stop. No civilization to be seen here. Stop.
19:37:59 <bjorkintosh> :)
19:38:01 <Kaidelong> I guess there are a few narrow use cases though where Haskell is "production ready"
19:38:09 <Kaidelong> Yesod possibly?
19:38:20 <bjorkintosh> no idea what yesod is or does.
19:39:30 <Twey> Kaidelong: You'd also need an NFData constraint on your representational table ‚Äî the keys must be completely evaluated, or evaluation of that term changes the ordering of the table (and you might not even have control of the thread when it happens!)
19:40:19 <Twey> Kaidelong: Haskell's production-ready for a bunch of things.  It's just not C and doesn't really behave like it.  ‚ò∫
19:40:53 <Twey> Hm
19:41:22 <Twey> Kaidelong: Even with NFData, you're not safe.  The GC can re-order things at any time, changing the representation of anything with a pointer in it.
19:42:58 <Twey> Can you make them/require them to be PINNED somehow?  I don't know GHC well enough to know whether that's practical, but maybe someone does
19:43:10 <EvanR> id like to think haskell is production ready as a thing to compile your whiz bang new language that is specialized for the problem at hand
19:43:36 <Kaidelong> oh yes
19:43:42 <Kaidelong> compilers and programming languages
19:43:49 <Kaidelong> although
19:43:58 <EvanR> good error messages still eludes me
19:44:07 <Kaidelong> how would you do a futumura projection with haskell?
19:44:22 <Twey> Ah, ByteStrings are always pinned; you could just store ByteString representations of the term into the table
19:46:26 <vanila> Kaidelong, can you elaborate?
19:47:06 <Twey> Kaidelong, EvanR: Facebook would like to disagree with you about the production-ready thing :√æ
19:47:10 <Kaidelong> partially evaluate an interpreter you wrote in Haskell using an interpreter you wrote in the language Haskell interpreter is targeting to make your first compiler
19:47:26 <Twey> Huh, Futamura projection is cool.
19:47:31 <bjorkintosh> sounds back-asswards.
19:47:53 <vanila> is there an example code of that I can read?
19:47:53 <bjorkintosh> and NEEDLESSLY complicated, serving no discernible purpose.
19:48:05 <bjorkintosh> vanila, sure, the prelude and libraries!
19:48:14 <bjorkintosh> among others.
19:48:15 <vanila> hi bjorkintosh
19:49:48 <Kaidelong> vanila: I could try to find the original paper
19:50:10 <vanila> thats ok
19:50:12 <Clint>  /win 23
19:50:24 <vanila> i have looked over the paper
19:50:31 <vanila> but he doesn't give his code
19:50:51 <vanila> also I didn't understood too well how you make a compiler from it
19:52:14 <Kaidelong> well, the interpreter emits object code
19:52:45 <Kaidelong> but further than that it doesn't seem obvious to me how it's supposed to work
19:53:01 <vanila> it's a pretty wild idea - I like it, want to try it out :D
20:01:44 <bjorkintosh> vanila, what's the wild idea exactly?
20:04:50 <benzrf> functors that are fun:
20:05:24 <benzrf> @let Fun a = forall r. Fun r (r -> a)
20:05:24 <lambdabot>  Parse failed: Parse error in expression: r -> a
20:05:48 <benzrf> @let data Fun a = forall r. Fun r (r -> a)
20:05:48 <geekosaur> .@let data ... ?
20:05:50 <lambdabot>  Defined.
20:06:25 <benzrf> yeah i fixed it
20:06:30 <benzrf> i have a habit of leaving out the data kwd
20:08:32 <benzrf> oh wait i confused myself, wrong functor
20:09:05 <benzrf> @let data MoreFun f a = forall r. MoreFun (f r) (r -> a)
20:09:06 <lambdabot>  Defined.
20:09:11 <benzrf> ^a fun functor
20:11:36 <Twey> benzrf: Isn't that isomorphic to f a?
20:12:25 <benzrf> Twey: if f is a functor, yes
20:12:34 <benzrf> but MoreFun f is a functor regardless of whether f is
20:13:14 <Twey> Oho
20:13:48 <benzrf> Twey: the isomorphism is the yoneda lemma
20:14:05 <benzrf> wait. hold on i think that might be worng
20:14:15 * benzrf tries to remember
20:14:22 <Twey> fmap f (MoreFun fr g) = MoreFun fr (f . g) ?
20:14:28 <benzrf> Twey: yeah
20:14:55 <Twey> Does this thing have a name?
20:15:10 <benzrf> i think it might be coyoneda in one of edwardk's packages
20:15:24 <glguy> coyoneda is in kan-extensions
20:16:51 <calvinx> So I figured that bind (>>=) in haskell is a lot like pipes in bash.  What‚Äôs the simplest way I can implement my own bind monad?
20:17:36 <EvanR> its not like pipes in bash, not really
20:17:39 <Twey> glguy: Ah yes
20:17:53 <calvinx> not it‚Äôs not?
20:18:07 <EvanR> the simplest way you can implement a Monad is to implement the Monad instance for this data structure
20:18:10 <EvanR> @src Identity
20:18:10 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
20:18:10 <calvinx> it does some computation and the result of the computation is passed on to the second computation after the bind
20:18:10 <Cale> only in as much as function application is like pipes in bash
20:18:11 <benzrf> erm. the yoneda lemma is the isomorphism between (forall r. (a -> r) -> f r) and (f a)
20:18:25 <Twey> calvinx: ‚ÄòBind monad‚Äô?  The way to implement a Monad is to define its bind operation (and return).
20:18:36 <benzrf> so no that isomorphism is not the yoneda lemma, i was writing w/o thinking
20:19:13 <benzrf> calvinx: it sounds to me like u dont understand functors
20:19:26 <calvinx> So something like `x >>== f = f x` will result in a new bind operator ‚Äú>>==‚Äú ?
20:19:27 <EvanR> calvinx: well, it might be passed on, or not, or the second computation is use in another way
20:19:42 <EvanR> depends on the instance
20:19:44 <Cale> calvinx: yeah, that's valid syntax
20:19:57 <johnw> benzrf: I think you meant (a -> f r) in that last one
20:20:27 <johnw> oh, maybe not
20:20:31 <calvinx> why is it valid? I read an article that mentioned this (x >>== f = f x) but I do not understand why it works to create `>>==` as a new bind monad.
20:20:45 <johnw> sorry, memory failed me
20:20:50 <Cale> But if you want to implement your own monad, you want to write an instance of the Monad type class:   instance Monad MyMonad where return v = ...; x >>= f = ...
20:21:27 <davidthomas> >>== is a terribly misleading name for $
20:21:27 <Cale> where in this case we have return :: a -> MyMonad a, and (>>=) :: MyMonad a -> (a -> MyMonad b) -> MyMonad b
20:21:44 <Cale> calvinx: What's a "bind monad"?
20:21:58 <Zemyla> Shiiiiit, now I know why the author of Fixed had to do all those "withResolution" calls. Because Haskell's type system for some reason can't deduce that, when I declare a name 'a' in an 'instance' clause, and then I use that name a in the function definition, it's talking about the same damn a.
20:22:08 <Cale> calvinx: Every monad is required to support an operation called "bind" which is written (>>=)
20:22:44 <Cale> calvinx: and the definition of how this operation works is part of what makes something a monad in the first place.
20:22:45 <calvinx> Well, I know that `:t (>>=)`  gives me `(>>=) :: Monad m => m a -> (a -> m b) -> m b` and what I am trying to do is to create a new symbol that is essentially an instance of `>>=` as an academic exercise in understand bind.
20:23:13 <Cale> For example, Maybe is a monad, because we can define operations  return :: a -> Maybe a,  and  (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
20:23:29 <Javran> is "instance Integral a => Show a where show = show . toInteger" reasonable?
20:23:41 <Cale> and list is a monad, because we can define operations  return :: a -> [a]  and  (>>=) :: [a] -> (a -> [b]) -> [b]
20:24:04 <Cale> (and in each of these cases, the operations satisfy a few basic properties which are required of them)
20:24:14 <calvinx> Yes, I understand that a monad has to fulfill 3 conditions (type container, return, bind)
20:24:27 <calvinx> So I understand what you are saying about list being a monad and Maybe being a monad.
20:24:39 <johnw> calvinx: and the laws, don't forget
20:24:48 <calvinx> ‚Äúand the laws‚Äù ?
20:24:52 <johnw> the monad laws
20:24:58 <johnw> that's another set of conditions a monad must fulfill
20:25:10 <EvanR> this is where a monad laws musical number breaks out
20:25:15 <calvinx> LOL
20:25:19 <EvanR> like conjuction junction
20:25:25 <EvanR> whats your function
20:25:25 <johnw> what's your function?
20:25:26 <Cale> Yeah, that return v >>= f = f v, and that x >>= return = x, and lastly that (x >>= f) >>= g = x >>= (\v -> f v >>= g)
20:25:36 <gfixler> monad laws: 1. no analogies, 2. don't make a monad tutorial, ...
20:25:42 <calvinx> Right. left identity, right identity, associativity
20:25:46 <EvanR> lol
20:26:06 <calvinx> LOL
20:26:14 <dfeuer> @tell erikd Sorry for my curt reply on the libraries list. I'm in a weird mood.
20:26:14 <lambdabot> Consider it noted.
20:26:28 <calvinx> But back to the question about creating my custom bind operator
20:26:49 * dfeuer gives Cale some popcorn with nutritional yeast and smoked paprika.
20:26:51 <calvinx> Why does `x >>== f = f x` achieve that? (create a new bind operator >>==)
20:27:01 <Cale> If your question is just about defining infix operators, you can do that -- any sequence of symbol characters is a valid name for an infix function.
20:27:07 * Twey wishes people would just give the laws in terms of (>=>)
20:27:16 <calvinx> How does this statement suddenly, magically make `>>==` available
20:27:19 <calvinx> ?
20:27:26 <Cale> any sequence of symbol characters is a valid name for an infix function
20:27:32 <calvinx> AHHHHHHHHHH
20:27:37 <Twey> calvinx: That declaration *defines* an operator >>==
20:27:47 <EvanR> > let x | y = x + y in 4 | 2
20:27:47 <calvinx> THAT answers my question. Thank you!
20:27:48 <lambdabot>  <hint>:1:24: parse error on input ‚Äò|‚Äô
20:27:51 <calvinx> :D
20:27:52 <Twey> You can also write it (>>==) x f = f x
20:27:59 <EvanR> > let x @ y = x + y in 4 @ 2
20:28:01 <lambdabot>  <hint>:1:24: parse error on input ‚Äò@‚Äô
20:28:04 <davidthomas> Prelude> let a %@%@^ b = 3
20:28:04 <davidthomas> Prelude> 3 %@%@^ 7
20:28:04 <davidthomas> 3
20:28:08 <Cale> okay, there are some reserved ones :)
20:28:18 <EvanR> the second one was an accident
20:28:31 <Zemyla> That's why resolution is (p a -> Integer).
20:28:43 <Zemyla> That explains the whole dumbfuck enchilada.
20:28:46 <EvanR> Zemyla: seems like some serious hax
20:28:48 <dfeuer> I think only @ is reserved.
20:28:57 <Twey> dfeuer: ' is also magic
20:29:00 <calvinx> well, the reason why that article mentioned using `x >>== f = f x` is that it doesn‚Äôt want to override the default `>>=` (bind) operator.
20:29:15 <Cale> The list of reserved operator symbols are (space separated) .. : :: = \ | <- -> @ ~ =>
20:29:18 <Twey> And the obvious ones like ;, {, }, (, ), ,
20:29:23 <dfeuer> Twey, oh yes, ' and ". And you should think twice about using ! and #.
20:29:37 <calvinx> Now I see how this statement defines a new infix operator.
20:29:37 <davidthomas> ' is a letter, sometimes :-P
20:29:39 <dfeuer> Although they'relegal.
20:29:49 <Cale> Yeah, and things like ; and various types of parens don't even count as symbol characters for this purpose.
20:29:52 <Twey> davidthomas: Better to say ' is a number :√æ
20:30:01 <davidthomas> Twey: yes
20:30:03 <dfeuer> And ` is no good either.
20:30:07 <Twey> Oh, also _ is special
20:30:14 <calvinx> And this new infix operator, because it is expressed as `x >>== f = f x`, is essentially a bind operation?
20:30:39 <dfeuer> > let x $_$ y = x^y in 3 $_$ 4
20:30:41 <lambdabot>  <hint>:1:5: Parse error in pattern: x $ _
20:30:41 <davidthomas> I don't know what you mean by "a bind operation" in this case
20:30:54 <dfeuer> > let x $&$ y = x^y in 3 $&$ 4
20:30:56 <lambdabot>  81
20:31:01 * hackagebot prednote 0.28.0.0 - Evaluate and display trees of predicates  http://hackage.haskell.org/package/prednote-0.28.0.0 (OmariNorman)
20:31:26 <Twey> calvinx: A bind operation is defined by its type and its obedience to the monad laws
20:31:31 <dfeuer> Yeah, _ *could* probably be allowed in operators, but it's not.
20:31:44 <dfeuer> Er ... maybe not.
20:31:45 <gfixler> let x %!#$%!@ y = "3 demerits for swearing" in 3 %!#$%!@ 4
20:31:46 <Cale> Twey: er, that might be a slight overstatement
20:31:48 <dfeuer> That would be messy.
20:31:59 <Twey> Cale: Hmm?
20:32:14 <Cale> There can be more than one implementation of (>>=) for a given type which leads to a valid monad instance
20:32:17 <calvinx> This is my context http://lpaste.net/118277
20:32:39 <calvinx> Twey: I see.
20:32:40 <Twey> Cale: And they all both bind operations
20:32:49 <Twey> s/all both/are all/
20:33:17 <davidthomas> calvinx: you can do that with any operator
20:33:19 <davidthomas> you can do it with +
20:33:33 <davidthomas> (you can do it without an operator...)
20:33:39 <Cale> Yeah, I was just being picky that knowing the type and the fact that the operation satisfies the monad laws doesn't define what the operation is
20:33:46 <calvinx> davidthomas: how so?
20:33:49 <Twey> calvinx: The type of  x >>== f = f x is:  a ‚Üí (a ‚Üí b) ‚Üí b  , i.e. you give it an ‚Äòa‚Äô and a function ‚Äòa ‚Üí b‚Äô and get back a ‚Äòb‚Äô
20:34:09 <Twey> Cale: There's a reason I used the indefinite article :√æ
20:34:29 <davidthomas> calvinx: the splitting over lines and aligning...
20:34:31 <Twey> calvinx: (rather, the type of (>>==) given that definition)
20:34:32 <Cale> "is defined by"
20:34:46 <Cale> The "A" I had no problem with :)
20:34:56 <davidthomas> otherwise, I'm not sure what you're thinking is special there
20:35:07 <Cale> (anyway, it's a silly nitpick)
20:35:37 <davidthomas> the wrapping of the values?
20:36:31 <davidthomas> all you're doing there is successive function application, by way of an operator instead of the regular way
20:36:34 <PompomHat> Hafydd: :(
20:36:40 <Twey> calvinx: The type of a bind operation is: (>>=) ‚à∑ m a ‚Üí (a ‚Üí m b) ‚Üí m b.  This almost matches your type signature: you have nothing to take the place of your ‚Äòm‚Äô.  But it's easy to define a boring type that can be the m whilst not really adding much else: we usually call this ‚ÄòIdentity‚Äô, but you've called it ‚ÄòPosition‚Äô.
20:36:44 <davidthomas> but if you replace those >>== with $, it'll be the same thing
20:37:44 <davidthomas> oh, but right-associative...
20:38:00 <Twey> davidthomas: Also flipped
20:38:21 <davidthomas> not flipped
20:38:27 <davidthomas> or
20:38:28 <davidthomas> wait
20:38:29 <Twey> Oh, right.
20:38:34 <Twey> Not in the paste, sorry.
20:38:35 <davidthomas> you wrote it flipped
20:38:37 <davidthomas> right
20:38:39 <davidthomas> heh
20:38:41 <davidthomas> no worries
20:38:56 <Twey> calvinx wrote a flipped version in the channel before
20:39:00 <calvinx> sorry, I think I made a mistake. My bad. This  is what I meant: http://lpaste.net/118278
20:39:11 <Twey> Yeah, that makes more sense.
20:39:19 <calvinx> yea, flipped the x and f
20:39:22 <calvinx> my bad
20:40:21 <Twey> calvinx: Your definition of myReturn and >>== are not quite right if you're trying to define a monad, because you never actually wrap or unwrap a Position.  So if you have x ‚à∑ Position a and f ‚à∑ (a ‚Üí Position b), x >>== f ‚à∑ Position (Position b), whereas you actually want just ‚ÄòPosition b‚Äô
20:41:22 <Twey> calvinx: Likewise, for myReturn, you have: myReturn ‚à∑ a ‚Üí a  when really you want  myReturn ‚à∑ a ‚Üí Position a
20:41:29 <Zemyla> So obviously, I can't do any kind of optimization in Fixed because the compiler can't let me know the very type I'm using until it gets a varisble of that type.
20:41:32 <calvinx> O, I see.
20:41:45 <calvinx> I can‚Äôt use ‚Äúx‚Äù again in the custom return and bind definitions
20:42:12 <Twey> calvinx: You can, it's valid, but you don't want to for >>== (you probably do want to for myReturn)
20:42:28 <Twey> calvinx: Try writing the type signatures out.  You'll find it helps you think about it.
20:42:32 <Twey> :t return
20:42:33 <lambdabot> Monad m => a -> m a
20:42:36 <Twey> :t (>>=)
20:42:37 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:42:43 <Twey> Replace m with Position and see what you get
20:50:54 <Zemyla> Is it even possible to choose one function based on a class value before you get any arguments of that variable?
20:51:40 <Cale> :t read
20:51:41 <lambdabot> Read a => String -> a
20:51:47 <Cale> Is that what you mean?
20:52:20 <Axman6> :t let f :: Int -> String; f = read in f
20:52:21 <lambdabot>     Couldn't match type ‚Äò[Char]‚Äô with ‚ÄòInt‚Äô
20:52:21 <lambdabot>     Expected type: Int -> String
20:52:21 <lambdabot>       Actual type: String -> String
20:52:35 <Axman6> :t let f :: String -> Int; f = read in f -- oops
20:52:36 <lambdabot> String -> Int
20:52:42 <Cale> > read "[1,2,3]" :: [Integer]
20:52:43 <lambdabot>  [1,2,3]
20:52:54 <Cale> > read "35.543" :: Double
20:52:55 <lambdabot>  35.543
20:53:10 <Cale> It selects the parser based on the type of result needed.
20:53:57 <echo-area> How to define strict evaluation for an operator?
20:54:47 <Cale> echo-area: I'm not sure what that question is asking... you're trying to ensure that a function forces the evaluation of its arguments?
20:54:56 <Pamelloes> echo-area: Pretty sure everything in Haskell is evaluated lazily.
20:55:06 <Cale> Note that pattern matching the arguments is sufficient to make a function strict.
20:55:10 <Axman6> > let !a +++ !b = const a b in 10 +++ undefined
20:55:11 <lambdabot>  <hint>:1:8: parse error on input ‚Äò+++‚Äô
20:55:15 <Cale> You can also use bang patterns
20:55:21 <Axman6> bah
20:55:23 <echo-area> I mean how to use $! in the definition of an operator
20:55:51 <Axman6> I don't understand the question
20:56:02 <HeladoDeBrownie> echo-area, do you already know how to use ($!) in general?
20:56:38 <Cale> It's not any different than how you'd use $! in the definition of anything else
21:02:56 <echo-area> http://pastebin.com/GLD2F6s0
21:03:03 <dgomez> Hi again. I've been silent but listening to the snide racist remarks around me while trying to do this in public is hard and sad.
21:03:06 <lpaste> dgomez pasted ‚ÄúDiash**‚Äù at http://lpaste.net/118281
21:03:20 <lpaste> Zemyla pasted ‚ÄúCould Not Deduce Type‚Äù at http://lpaste.net/118282
21:03:21 <dgomez> I mean do you think I feel good putting up pathetic work like this (as proof?), seeming as if though I lack the level of logic esp when I want it to make us both happy?
21:03:30 <echo-area> I tried many different ways to put $! in this definition but all of them failed to be loaded
21:03:58 <dgomez> The pressure is out there to code, code, code and Im all for it but I'm not making excuses. My reality is I've gone through a major brain change over the last year that I am working out of.
21:03:59 <dgomez> I am learning and reading; I find myself mirroring others thought processes to understand my own. But Im making it manageable. SO WHAT????
21:04:00 <Zemyla> There;s a stupid little example. Why doesn't it work?
21:04:06 <vanila> dgomez, looks like you're doing great, keep it up :)
21:04:37 <vanila> is this functional reactive programming?
21:05:24 <dgomez> vanila: ah thanks i guess.
21:05:26 <karshan> @src dropWhile
21:05:26 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:06:07 <karshan> > dropWhile (/= '"') ":\"asd"
21:06:08 <lambdabot>  "\"asd"
21:08:20 <dgomez> karshan: >dropWhile to remove the colon?
21:08:55 <HeladoDeBrownie> echo-area, oh i see, you want to apply an operator using ($!)? well, to do that you will need to use its prefix form, which involves surrounding it in parens. E.g., (+) $! 1 $! 2
21:09:13 <HeladoDeBrownie> that will apply (+) strictly to 1 and then the result of that to 2
21:10:31 <Cale> except you can't write (+) $! 1 $! 2 because $! has the wrong associativity, just like $, it associates to the right
21:10:38 <HeladoDeBrownie> woops
21:10:41 <Cale> So you have to awkwardly write ((+) $! 1) $! 2
21:11:02 * hackagebot extensible 0.2 - Poly-kinded, extensible ADTs  http://hackage.haskell.org/package/extensible-0.2 (FumiakiKinoshita)
21:11:57 <glguy> Zemyla: the type 'a' in your type signature is not the same as you've ascribed to undefined
21:12:14 <HeladoDeBrownie> okay i need some fresh air, off for a walk \o
21:12:15 <Pamelloes> Is there a built in `rem` for fractionals, or do I have to write my own?
21:12:41 <Zemyla> There's one in Data.Fixed.
21:14:03 <lpaste> glguy annotated ‚ÄúCould Not Deduce Type‚Äù with ‚ÄúCould Not Deduce Type (annotation)‚Äù at http://lpaste.net/118282#a118283
21:14:21 <glguy> Zemyla: See that paste for one way to do what you wanted
21:15:05 <Zemyla> Okay. I found another possible way, but okay.
21:15:47 <glguy> Zemyla: is greenAmount supposed to return the same value for all arguments of the same type?
21:16:23 <Zemyla> glguy: Yep, that's why I feed it undefined.
21:17:50 <lpaste> glguy annotated ‚ÄúCould Not Deduce Type‚Äù with ‚ÄúCould Not Deduce Type (annotation)‚Äù at http://lpaste.net/118282#a118286
21:17:59 <glguy> Zemyla: OK, then this is the thing to do to avoid using undefined
21:20:53 <ElderFain> Could someone spare a moment to explain this to me? http://lpaste.net/118284  I read it as "xs takes from xxs" (so the first value would be a list of numbers), but I don't quite know how to think about what the | is doing, I initially thought it was like declaring the variables for the method, but this particular example seems like it has to be read right to left vs left to right. I get that the , is a predicate (filter) on the incoming value
21:21:20 <Zemyla> glguy: I figured out how to do it without Scoped Type Variables.
21:21:34 <dgomez> glguy: what are you trying to do with Proxy on line 13?
21:21:39 <ElderFain> and how do you know whats returned? just the evaluation of each statement is always returned to the same "type" ?
21:21:54 <glguy> Zemyla: Using a proxy is still a good idea with or without scoped type variables
21:22:01 <dgomez> glguy: I don't think you can call a Type Proxy of type Proxy...
21:22:36 <dgomez> glguy: unless i'm mistaken.
21:22:45 <glguy> dgomez: That line has two different Proxys, Proxy {- the data constructor -} :: Proxy {- the type constructor -} a
21:22:45 <Cale> ElderFain: The expression before the | is the generic element of the list, and the stuff to the right is a sequence of generators (using <-) which bind variables to the elements of given lists, and predicates (boolean expressions) which must hold of the bound variables in order for the choices to be represented in the list
21:23:19 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
21:23:20 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
21:23:37 <RustyShackleford> are there GUI toolkits for haskell?
21:23:44 <Cale> > [10000 * x + 100 * y + z | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
21:23:44 <glguy> dgomez: The Proxy here is being used to provide type information to pick the correct instance of GreenNeeder
21:23:44 <dgomez> glguy: type punning? Ive tried it but it's never worked for me
21:23:45 <lambdabot>  [30405,51213,60810,81517,91215,121620]
21:23:51 <lpaste> Zemyla annotated ‚ÄúCould Not Deduce Type‚Äù with ‚ÄúCould Not Deduce Type (annotation)‚Äù at http://lpaste.net/118282#a118291
21:24:21 <Cale> RustyShackleford: There's Gtk2hs and wxHaskell
21:24:26 <glguy> Zemyla: That still suffers from needing to use "undefined"
21:24:26 <Zemyla> Basically, it just needs something to show the two types a are the same.
21:24:37 <ElderFain> Cale: so how does that example have an.. entire i guess, List Comprehension as the generic element of the list?
21:24:40 <ElderFain> as it has two | |
21:24:51 <glguy> dgomez: No, it's just a different namespace, types and values
21:24:53 <Zemyla> glguy: So? As long as undefined remains uninstantiated, it works.
21:24:55 <Cale> yes
21:25:08 <Cale> The thing before the | can be any Haskell expression
21:25:16 <Cale> and in this case, it's another list comprehension
21:25:27 <glguy> Zemyla: It's error prone and it doesn't convey that the typeclass isn't supposed to inspect the value
21:28:43 <Cale> and then there's the other reason for Proxy, which was that in order for the Typeable stuff to be kind polymorphic (and avoid the old mess of Typeable1, Typeable2, etc.), you end up needing values that can be passed to things like the typeRep function, but there's no value of type "Maybe"
21:28:44 <zq> Zemyla: "uninstantiated"?
21:28:55 <Cale> (as that's not even a complete type, but a type constructor)
21:29:12 <zq> Zemyla: you need to give the undefined that you're feeding into greenAmoutF (and ultimately greenAmount) a type
21:29:59 <ElderFain> Cale: okay so the thing you posted.. that was a .. list comprehension with a.. tuple of x,y,z.. x took from a range of 1-20, y took from a range of x-20 (huh?? so if x is 1, y is 1-20?), and z takes from y-20, so 1-20 again for first iteration.. not sure what that last thing is doing... its saying only use a value if this equation evaluates to true?
21:30:08 <Zemyla> In the real code I'm doing, it turns out that I don't.
21:30:23 <Cale> ElderFain: Yep, that's correct
21:31:21 <ElderFain> okay
21:31:23 <zq> Zemyla: y-you don't? how does ghc even know which instance to use
21:31:24 <ElderFain> why would I ever want to do that? =0
21:31:37 <Cale> Well, it was just a demo
21:32:02 <Cale> But these triples are called Pythagorean triples
21:32:13 <ElderFain> oh i figured there was a real math thingy behind it
21:32:26 <Zemyla> zq: Because since I call pa:ls, pa must be of type a.
21:32:38 <glguy> zq: You can use type-signatures on definitions to associate multiple arguments' types together: asTypeOf :: a -> a -> a ; asTypeOf = const -- is an example of that
21:32:45 <Cale> They're the triples of integers for which there is a right angled triangle having those side lengths.
21:32:54 <ElderFain> Cale: thank you. sorry for the dumb questions =) I'm working through this tutorial and it usually explains what its talking about, but not always
21:40:09 <echo-area> HeladoDeBrownie: I tried for another couple of minutes but still didn't get the gist.  I think I need more reading.  Thank you anyway.
21:40:55 <echo-area> But I have noted the prefix notation
21:46:33 <Pamelloes> xor = (/=)
21:46:36 <Pamelloes> Mind blown.
21:48:32 <vanila> another cool one is that -> = <=
21:49:27 <Zemyla> And now I just realized why you can't use <= as a reverse constraint arrow :P
21:57:42 <fread2282> simpler easier is confusing me (http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html), (\(a : t) -> b) : ((a : t) -> b[a = t]) it seems to imply, is this correct?
21:58:19 <vanila> it seems to imply what
21:59:50 <fread2282> my problem is that then (\(t : *) -> \(a : t) -> a) : ((t : *) -> (a : *) -> *)
22:00:06 <vanila> the type rule for a lamdba term?
22:00:52 <fread2282> yep, the one in the dependent types part
22:01:41 <vanila> http://lpaste.net/118292
22:01:44 <vanila> this is the type rule
22:02:27 <vanila> you only perform the substitution when checking an application
22:02:50 <vanila> it was probably confusing that i used y on the top and x on the bottom actually
22:03:01 <EvanR> "safer programs run faster"
22:03:13 <EvanR> hehe
22:03:15 <vanila> ive annotated with a less confusing version
22:03:50 <vanila> now S will have x free in it, so in checking f 7, say, you will have the type S[x := 7]
22:04:46 <HeladoDeBrownie> echo-area, i'm around again. so, what are you trying to make strict exactly?
22:05:43 <HeladoDeBrownie> echo-area, also, did you note what Cale said right after what i said? that was more correct
22:06:42 <fread2282> well, in my version i have (\(a : t) -> b) : ((a : t) -> typeof b[a = t]), what am I doing wrong?
22:07:16 <fread2282> also, simpler easier != simply easy
22:07:19 <vanila> I think you aren't applying the type rule correctly
22:07:47 <vanila> it should just be (\(a : t) -> b) : ((a : t) -> "type of b in the context extended with the assumption a : t")
22:08:35 <fread2282> ah yes that makes sense
22:09:03 <vanila> for example:   \(x : nat) -> VNil x has type (x : nat) -> Vector x
22:09:20 <vanila> [ given VNil, NCons constructors for a vector type]
22:09:43 <vanila> and  (\(x : nat) -> VNil x) 7 has type Vector 7, it's only the application rule which performs a substitution in the types
22:11:32 <echo-area> HeladoDeBrownie: Yes I was aware of what Cale said.  I'm trying to understand the evaluation model.  More precisely, I think the evaluation of `factorial (n+1) = (n+1) * factorial n` requires more memory than the tail recursive version and I want to check if this is correct, and I'm more and more sure that it does require more memory
22:12:17 <HeladoDeBrownie> echo-area, well the first thing to note is that tail recursion doesn't have quite the same properties in a non-strict language
22:12:38 <HeladoDeBrownie> but it's entirely possible you're correct, depending on what you're referring to as "the tail recursive version"
22:12:54 <vanila> this looks like something you'd want to consider the strict versions of
22:12:58 <vanila> to compare
22:13:41 <echo-area> Oh, for what I can see I should call that version in my mind a strict, tail-recursive one.
22:13:44 <HeladoDeBrownie> echo-area, yeah, so, if you wanted to strictify both arguments of (n+1) * factorial n, for example, you'd write ((*) $! (n+1)) $! factorial n
22:13:58 <vanila> it could be simpler to just talk about scheme code version
22:16:39 <opqdonut> echo-area: naively written, the tail-recursive version is quite inefficient too. consider "factorial_ acc 0 = acc; factorial_ acc n = factorial_ (n*acc) (n-1)"
22:16:57 <opqdonut> echo-area: the pattern match forces the second argument every time, but the first argument accumulates a large thunk
22:18:13 <opqdonut> echo-area: factorial_ 1 4 => factorial_ (4*1) (4-1) => factorial_ (4*1) 3 => factorial (3*(4*1)) (3-1) => factorial (3*(4*1)) 2 => ... => factorial (1*2*3*4*1) 0 => (1*2*3*4*1) => 24
22:19:32 <opqdonut> echo-area: however the fact that GHC is very good at spotting excess laziness in cases exactly like this confuses the issue a bit
22:19:35 <echo-area> opqdonut: That seems the same effect of the first version
22:20:19 <echo-area> I.e. accumulating a large thunk of numbers to be multiplied
22:20:24 <opqdonut> yeah
22:21:14 <opqdonut> however the naive recursive version, "factorial 0 = 1; factorial n = n * factorial (n-1)" is impossible to optimize automatically
22:21:27 <fread2282> what's the point of Int being lazy? aren't Int operations almost always faster than building thunks?
22:21:46 <opqdonut> well not impossible, it would have to be effectively transformed to the strict tail recursive version :)
22:21:57 <opqdonut> fread2282: Int operations are strict. however haskell is lazy
22:22:20 <echo-area> Okay.  I have built a better vision.  Thank you all!
22:22:23 <opqdonut> fread2282: GHC's strictness analysis however often eliminates laziness when you're operating with Ints
22:22:38 <opqdonut> fread2282: since laziness is of no use with arithmetic expressions
22:22:50 <fread2282> opqdonut: couldn't Int be data Int = Int !Int#   ?
22:23:00 <opqdonut> fread2282: it effectively is
22:23:26 <opqdonut> but you see it doesn't matter what Int is, if nobody is forcing the expression (3*2) it won't get evaluated
22:23:40 <fread2282> oh
22:23:53 <platz> I tried to find the F-algebra in vector due to Gabriel's comment 'This is why F-algebras and F-coalgebras are pervasive in high-performance Haskell libraries like vector' - if it's there, or was there, it's pretty hard to find
22:24:02 <opqdonut> but if you have a large arithmetic expression, the instant the top level of it is forced, it gets computed completely
22:24:23 <calvinx> ok, so I re-read the part about `return` and `>>=` and experimented with where I left off earlier; is this correct? Any comments? http://lpaste.net/118296
22:25:17 <Twey> calvinx: Looks good!  You've written the Identity monad.
22:25:27 <calvinx> LOL. Okay.
22:25:38 <Twey> calvinx: Uh, I don't think par is what you want, though.
22:25:45 <Twey> What were you trying to do there?
22:25:55 <calvinx> I am trying to cmpute f1 and f1 in parallel
22:26:00 <calvinx> *and f2
22:26:18 <calvinx> is that part of the code a problem?
22:26:58 <Twey> Ah.  What you're actually doing is generating IO values representing the printing of f1 and f2, then executing whichever one finishes getting constructed first.
22:27:12 <calvinx> yes
22:27:13 <ElderFain> let rightTriangles' = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]  In this example, how does Haskell know that the last two , are predicates?  The "AND" Nature of them is implied, so I guess you cannot OR them
22:27:45 <Twey> calvinx: That's a significantly different thing
22:28:03 <calvinx> o, elaborate?
22:28:08 <HeladoDeBrownie> Twey, are you sure that's how par works? its type is a -> b -> b
22:28:09 <Twey> calvinx: (one may not even be evaluated, and the one that is is only evaluated as a side-effect of the print)
22:28:20 <Twey> Oh, wait
22:28:23 <HeladoDeBrownie> http://hackage.haskell.org/package/parallel-3.2.0.6/docs/Control-Parallel.html
22:28:29 <Twey> No, I'm being an idiot.  Thanks, HeladoDeBrownie
22:29:08 <calvinx> `print f1` doesn‚Äôt get evaluated unless I force it again if I am not wrong.
22:30:03 <Twey> It's still not what you want, though ‚Äî that just means it will *never* evaluate f1 there, unless print is strict, since only ‚Äòprint f2‚Äô is ever executed
22:30:41 <Zemyla> I kind of love how the Monomorphism Restriction is almost universally called "Dreaded".
22:30:46 <Twey> Probably you wanted something like: print $ par f1 f2.  But it's a very weird thing to do, anyway
22:32:30 <Twey> calvinx: I suspect you're confusing evaluation and execution.  A term like ‚Äòprint f1‚Äô is a function application.  When fully evaluated, it will produce a *value* that represents the action of printing f1 ‚Äî but f1 will not be printed.  In order for anything else to happen, the result of ‚Äòprint f1‚Äô must then be *executed* by attaching it, directly or indirectly, to the value of ‚Äòmain‚Äô.
22:33:25 <Twey> calvinx: Why were you trying to force evaluation of f1 and f2?
22:33:38 <calvinx> so that I can see if I get the expected result?
22:34:19 <calvinx> I want to IO to produce ‚ÄúPosition (-3)  Position (-3)‚Äù essentially.
22:34:25 <calvinx> *the IO
22:34:51 <calvinx> so I can see that f1 indeed produces the expected result and f2 indeed produces the expected result.
22:37:43 <Twey> calvinx: You don't need to force evalution to do that.  You can just print them out: main = do print f1; print f2
22:38:03 <Twey> You don't need Control.Parallel.  You should probably put that module away for now.
22:38:09 <calvinx> right
22:38:19 <Twey> evaluation**
22:38:25 <calvinx> I was just messing with that module
22:38:30 <Twey> Ah, okay.
22:38:34 <calvinx> I do realize that I can print sequentially
22:38:38 <Twey> It doesn't do what you think it does :√æ
22:38:45 <calvinx> O it doesn‚Äôt? :D
22:38:51 <Twey> You're still printing sequentially.
22:38:56 <calvinx> O why?
22:39:06 <Twey> :t par
22:39:07 <lambdabot>     Not in scope: ‚Äòpar‚Äô
22:39:07 <lambdabot>     Perhaps you meant one of these:
22:39:07 <lambdabot>       ‚ÄòSym.var‚Äô (imported from Data.Number.Symbolic),
22:39:09 <Twey> Bah.
22:39:13 <calvinx> ‚ÄúNote that actual parallelism is only supported by certain implementations (GHC with the -threaded option, and GPH, for now). On other implementations, par a b = b."
22:39:17 <Twey> calvinx: par ‚à∑ a ‚Üí b ‚Üí b
22:40:06 <calvinx> I see. So a  just sits in memory
22:40:13 <calvinx> only b gets executed
22:40:34 <Twey> calvinx: What par does is return the b whilst ‚Äòsparking off‚Äô the evaluation of the a.  So in your case, you're returning the ‚Äòprint f2‚Äô whilst (potentially) also beginning evaluation of ‚Äòprint f1‚Äô.  But you're not *executing* the ‚Äòprint f1‚Äô until the next line ‚Äî that evaluated ‚Äòprint f1‚Äô is never used.
22:40:39 <Twey> Right
22:41:09 <calvinx> so how would I force parallel execution ?
22:42:02 <Twey> Usually you use par something like: let x = slowlyMakeAnX; doSomethingSlowWithY (par x y); doSomethingWithX x.  That is to say, you hope that by the time the doSomethingSlowWithY is done, x has finished evaluating and it'll be ready for you to use
22:42:18 <Twey> calvinx: You probably want forkIO from Control.Concurrent
22:42:25 <calvinx> Ah. Ok.
22:43:40 <Twey> You can write: main = forkIO $ print f1; print f2
22:44:14 <Twey> And that will print both of them ‚Äòsimultaneously‚Äô (in practice I wouldn't be surprised if f2 finished before f1 got fully started, and you probably won't see anything interesting anyway due to line buffering on the console)
22:44:14 <fread2282> does anyone have any resources on encoding where blocks (into lets)?
22:44:47 <calvinx> complains about naked expression at top level...
22:45:00 <fread2282> or even into non-recursive lets + fix?
22:46:25 <calvinx> needed a `do`
22:46:41 <Twey> calvinx: Sorry, yeah ‚Äî edited the wrong bit
22:46:45 <calvinx> that worked. though I get a weird output because the threads and outputting to stdout in parallel...
22:46:47 <calvinx> fun!
22:47:06 <calvinx> I got this http://lpaste.net/118303
22:47:25 <calvinx> the printing garbles up with each other. very cool :D
22:48:15 <Zemyla> :t MkFixed
22:48:16 <lambdabot> Integer -> Data.Fixed.Fixed a
22:48:29 <Zemyla> :t withResolution
22:48:30 <lambdabot> Not in scope: ‚ÄòwithResolution‚Äô
22:48:33 <glguy> Watch out doing "main = forkIO $ print f1; print f2"
22:48:38 <glguy> if f2 prints quickly f1 might not
22:49:02 <Twey> Indeed
22:50:11 <calvinx> So this - http://lpaste.net/118304 - is correct?
22:50:22 <Zemyla> :t ap (flip asTypeOf) (MkFixed . resolution)
22:50:23 <lambdabot> HasResolution a => Data.Fixed.Fixed a -> Data.Fixed.Fixed a
22:50:45 <Zemyla> :t nf
22:50:46 <lambdabot> Data.Fixed.Fixed E1
22:51:00 <Zemyla> > ap (flip asTypeOf) (MkFixed . resolution) nf
22:51:02 <lambdabot>  1.0
22:51:25 <Hijiri> calvinx: if the main thread finishes before the forked one, the forked one will die
22:51:25 <Zemyla> > ap (flip asTypeOf) (MkFixed . resolution) (undefined::(Data.Fixed.Fixed E1))
22:51:27 <lambdabot>  1.0
22:51:33 <Hijiri> so you need to add something to make sure it waits
22:51:42 <calvinx> I see.
22:52:00 <fread2282> what's the complex (not just *) typing rule for Pi?
22:52:06 <Hijiri> you can use an MVar as a sort of lock that the branched thread will use to signal that it's done
22:52:37 <HeladoDeBrownie> huh, i thought i remembered seeing some sort of wait :: ThreadId -> IO ()
22:52:47 <calvinx> or just put a getLine
22:52:48 <Hijiri> oh, maybe there was
22:53:06 <calvinx> O, there‚Äôs a built-in wait function?
22:53:08 <HeladoDeBrownie> oh, there's a wait here: http://hackage.haskell.org/package/async-2.0.2/docs/Control-Concurrent-Async.html
22:53:08 <Hijiri> what if the user presses return?
22:53:15 <Hijiri> then the thread will end still
22:53:18 <glguy> HeladoDeBrownie: Are you thining of http://hackage.haskell.org/package/async-2.0.2/docs/Control-Concurrent-Async.html
22:53:18 <calvinx> true
22:53:21 <glguy> thinking of*
22:53:21 <HeladoDeBrownie> glguy, i was :)
22:53:29 <Zemyla> > (ap (flip asTypeOf) (MkFixed . resolution) undefined)::Centi
22:53:30 <lambdabot>  1.00
22:53:40 <Zemyla> > (ap (flip asTypeOf) (MkFixed . resolution) undefined)::Milli
22:53:41 <lambdabot>  1.000
22:53:41 <glguy> I should look back at chat I guess before I press enter :)
22:54:23 <fread2282> or, better, is there a paper that gives the typing rules for simple DTLC with Set 0 : Set 1 : Set 2 ... ?
22:55:08 <calvinx> in this trivial program, it should be alright with a `getLine`. It‚Äôs actually obvious when the two prints show up
22:55:28 <calvinx> after the two prints show up, I hit enter and `main` terminates.
22:55:53 <Zemyla> glguy: I use that to get the resolution of the fixed-point objects, making sure it's the same type with asTypeOf.
22:55:57 <Twey> fread2282: What do you mean ‚Äònot just ‚òÖ‚Äô?
22:56:00 <calvinx> but yea, in more sophisticated programs, will need to figure out a mechanism to handle waiting.
22:56:26 <Twey> fread2282: With levels?
22:57:08 <fread2282> Twey: yes, or even without, but the one that's needed for levels (that recurses on the pi's body)
23:00:00 <Twey> fread2282: It usually goes something like http://lpaste.net/3095605186194833408
23:01:39 <fread2282> Twey: thanks
23:01:58 <glguy> Zemyla: Code that looks like ?pl generated it isn't really suitable outside of IRC, something like this would be more clear: http://lpaste.net/1670004248143724544
23:02:44 <Twey> fread2282: Whoops, forgot a context: http://lpaste.net/3095605186194833408
23:03:56 <Twey> fread2282: I don't know of a simple paper, but Andrej Bauer has an implementation, from which you can read off the typing rules: http://math.andrej.com/2012/11/08/how-to-implement-dependent-type-theory-i/
23:03:59 <Zemyla> glguy: I didn't define it in my file with ap and flip. :P
23:04:38 <Zemyla> That's just the simplest one-liner I came up with.
23:05:48 <glguy> Zemyla: While we're making fun examples:
23:05:49 <glguy> > let thing = fix (MkFixed . resolution) in thing :: Fixed E1
23:05:50 <lambdabot>  Ambiguous occurrence ‚ÄòFixed‚Äô
23:05:50 <lambdabot>  It could refer to either ‚ÄòData.Fixed.Fixed‚Äô,
23:05:50 <lambdabot>                           imported from ‚ÄòData.Fixed‚Äô at L.hs:82:1-17
23:05:57 <glguy> > let thing = fix (MkFixed . resolution) in thing :: Data.Fixed.Fixed E1
23:05:58 <lambdabot>  1.0
23:06:14 <Twey> fread2282: The only difference from e.g. ‚ÄòA Tutorial Implementation‚Äô, though, is that you parameterize ‚òÖ by a natural, change ‚òÖ : ‚òÖ to ‚òÖ_i : ‚òÖ_(i+1) and have the max shown in that Œ† rule
23:11:49 <Zemyla> :t \f g a b c -> f >>= a . b . c =<< g
23:11:50 <lambdabot>     Precedence parsing error
23:11:50 <lambdabot>         cannot mix ‚Äò>>=‚Äô [infixl 1] and ‚Äò=<<‚Äô [infixr 1] in the same infix expression
23:12:01 <Zemyla> :t \f g a b c -> (f >>= a . b . c) =<< g
23:12:02 <lambdabot> Monad m => (a -> a1) -> m a -> (b1 -> a -> m b) -> (b2 -> b1) -> (a1 -> b2) -> m b
23:12:23 <calvinx> so the custom monads I wrote must also conform to Applicative properties?
23:12:31 <calvinx> ref https://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
23:12:46 <Zemyla> :t \f g a b c -> (f >>=) . a . b . c =<< g
23:12:47 <lambdabot> Monad m => m a1 -> m a -> (b1 -> a1 -> m b) -> (b2 -> b1) -> (a -> b2) -> m b
23:13:35 <Zemyla> calvinx: pure = return, (<*>) = ap.
23:14:21 <calvinx> yea, that suppresses the warning
23:15:35 <Twey> calvinx: If you obeyed the Monad laws, you get an Applicative (and a Functor) for free.
23:15:47 <Twey> @src liftM
23:15:47 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
23:15:49 <calvinx> is there a more concise way of re-writing this? http://lpaste.net/118306
23:15:52 <Twey> @src ap
23:15:52 <lambdabot> ap = liftM2 id
23:16:06 <Twey> @src liftM2
23:16:06 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:16:13 <jle`> is every strict language automatically required to have operational semantics
23:16:26 <Twey> jle`: I don't think Agda has one
23:16:44 <jle`> hm
23:16:56 <jle`> didn't think about that
23:17:49 <calvinx> Twey: so my original `instance Monad Position where ‚Ä¶` did not obey Monad laws?
23:18:12 <calvinx> (lines 10-12 in http://lpaste.net/118306 are the original declarations)
23:19:18 <jle`> it looks lawful to me
23:20:42 <glguy> Agda is a strict language?
23:20:55 <vanila> its total so doesn't really matter
23:20:58 <HeladoDeBrownie> jle`, lawful good? neutral? evil?
23:20:59 <vanila> it has coinductive types though
23:21:02 <vanila> which need to be lazy
23:21:36 <Twey> calvinx: There's always a way to write it more concisely: http://lpaste.net/986704380466036736
23:22:04 <Twey> calvinx: Alternatively, ‚Äòimport Data.Functor.Identity‚Äô ;)
23:22:05 <calvinx> o wow.
23:22:16 <glguy> vanila: Operational tells us about its execution, so it matters for things like "will it terminate before I die"
23:22:51 <Twey> calvinx: That obeys the Monad laws fine.
23:25:10 <Zemyla> :t liftM
23:25:11 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
23:25:25 <Zemyla> :t (>>= (return . f))
23:25:26 <lambdabot>     Ambiguous occurrence ‚Äòf‚Äô
23:25:27 <lambdabot>     It could refer to either ‚ÄòL.f‚Äô,
23:25:27 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:206:1
23:25:37 <Zemyla> :t \f -> (>>= (return . f))
23:25:38 <lambdabot> Monad m => (a -> b) -> m a -> m b
23:25:51 <Zemyla> @pl \f -> (>>= (return . f))
23:25:52 <lambdabot> fmap
23:26:03 <jle`> what
23:26:04 <Zemyla> @pl \f -> (j (return . f))
23:26:04 <lambdabot> j . (return .)
23:26:15 <jle`> did @pl already upgrade to 7.10 :P
23:26:32 <Zemyla> @pl \f -> (`j` (return . f))
23:26:32 <lambdabot> flip j . (return .)
23:26:33 <jle`> blasphemyyy
23:27:05 <Zemyla> :t (=<<) . (return .)
23:27:05 <lambdabot> Monad m => (a -> b) -> m a -> m b
23:27:48 * HeladoDeBrownie idly wonders how to implement join in ski
23:34:40 <HeladoDeBrownie> hmm, ss(ki) is *almost* the right type.
23:35:08 <HeladoDeBrownie> wait, no that's exactly the right type
23:35:12 <HeladoDeBrownie> i did it \o/
23:35:34 <shachaf> Oh, by join you don't mean join, you mean a function :: (a -> a -> b) -> a -> b
23:35:54 <HeladoDeBrownie> yeah, that's join as restricted to m ~ (e ->)
23:35:57 <HeladoDeBrownie> or a as it may be
23:36:51 <Twey> @src join
23:36:52 <lambdabot> join x = x >>= id
23:37:00 <Twey> I assumed you meant that
23:37:29 <HeladoDeBrownie> well to implement general join in ski we'd need to figure out an encoding for some other stuff i'd think
23:37:33 <shachaf> That's a confusing way to put it.
23:37:41 <HeladoDeBrownie> but yeah, i could have been clearer
23:37:43 <shachaf> But yes, that's what the usual ski algorithm will give you.
23:38:58 <Hijiri> oh
23:39:04 <Hijiri> just realized ski's name was combinators
23:39:19 <jle`> lol
23:39:21 <HeladoDeBrownie> yep, and we've probably highlighted them a bunch now
23:39:45 <HeladoDeBrownie> but it's probably one of the known dangers of using that nick :P
23:40:20 <Zemyla> :t ap ap (const id)
23:40:21 <lambdabot> (a -> a -> b) -> a -> b
23:40:42 <HeladoDeBrownie> :t (<*>) <*> const id
23:40:43 <lambdabot> (a -> a -> b) -> a -> b
23:52:21 <vanila> :t let i x = x ; k x y = x ; s x y z = (x z) (y z) in s s (k i)
23:52:21 <lambdabot> (t1 -> t1 -> t) -> t1 -> t
23:54:02 <jle`> ss(ki)fx = sf(kif)x = sfix = fx(ix) = fxx
