00:03:12 <L8D> Anyone here familiar with using Hasql? I'm trying to write a query where the result uses Text instead of String
00:03:33 <L8D> Couldn't match expected type ‘Data.Text.Internal.Text’ with actual type ‘[Char]’
00:03:50 <L8D> Since I'm guessing Hasql uses [Char] for string queries
00:03:57 <L8D> I could be completely wrong about this though
00:05:15 <L8D> actually nvm I think I know why
00:09:11 * hackagebot base-prelude 0.1.15 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.15 (NikitaVolkov)
00:09:11 * hackagebot husk-scheme 3.19 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.19 (JustinEthier)
00:13:03 <L8D> for some reason whenever I use quasiquotes I'm getting the same error
00:13:40 <lpaste> L8D pasted “quasi quotes error” at http://lpaste.net/119681
00:16:24 <L8D> overloaded strings got rid of the issue
00:25:36 <EvanR> is it possible to poke individual fields of a struct with ffi
00:27:15 <ab9rf> i'm fairly certain i have Windows API FFI impolementations that do that
00:27:41 <EvanR> storable seems to be just for dumping an entire struct
00:27:56 <EvanR> which is pretty big in this case
00:36:38 <ab9rf> there are peek and poke functins somewhere
00:54:06 * hackagebot debian-build 0.5.0.2 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.5.0.2 (KeiHibino)
01:56:02 <izohask> if I define simple list with "data IList a = Nil | Elem (a, IList a) deriving Show"
01:56:23 <izohask> why Functor instance can be defined with "instance Functor IList"
01:56:46 <izohask> while Monoid must have "instance Monoid (IList a)" instead of "instance Monoid IList" ?
01:58:19 <mauke> izohask: because Monoid takes a type of kind * but Functor takes a type of kind * -> *
01:59:03 <mauke> (* means it's a real type, * -> * means it takes a parameter (which is itself a type))
01:59:39 <mauke> class Functor f where fmap :: (a -> b) -> f a -> f b
02:00:04 <izohask> mauke: I understand "half" of this
02:00:05 <mauke> class Monoid m where mempty :: m; mappend :: m -> m -> m
02:00:13 <jle`> izohask: look at the type signatures for `fmap` and `mempty`/`mappend`
02:00:16 <izohask> functor makes type B from type A
02:00:22 <izohask> while monoid always have type A
02:00:30 <jle`> can "IList" go for `mempty`?
02:00:33 <jle`> :t mappend
02:00:34 <lambdabot> Monoid a => a -> a -> a
02:00:36 <mauke> if you plug in IList for f, you get fmap :: (a -> b) -> IList a -> IList b
02:00:39 <mauke> this makes sense
02:00:39 <jle`> can you have an IList -> IList -> IList ?
02:00:43 <jle`> ah i'll back ou
02:00:45 <jle`> t
02:00:55 <mauke> but if you set m to IList, you get mempty :: IList; mappend :: IList -> IList -> IList
02:00:58 <mauke> this is an error
02:01:07 <jle`> it just doesn't make any sense :O
02:01:25 <jle`> how can i have a value of type `x :: IList` ???
02:01:33 <jle`> what's gone wrong with the world ;____;
02:01:54 <mauke> > "hi" :: []
02:01:55 <lambdabot>  Expecting one more argument to ‘[]’
02:01:55 <lambdabot>  Expected a type, but ‘[]’ has kind ‘* -> *’
02:01:59 <izohask> if x = 5, then x::IList can be Elem (5, Nil)
02:02:02 <izohask> where is the issue here ?
02:02:03 <mauke> no, it can't be
02:02:09 <jle`> x :: IList Int
02:02:10 <mauke> x :: IList is an error because IList is not a type
02:02:18 <izohask> aaaa
02:02:24 <izohask> ok , x::IList Int
02:02:30 <jle`> i can have a value of type `Maybe Int`.  but not a value of type `Maybe`. that doesn't make any sense.
02:02:36 <jle`> so how can i have mappend :: IList -> IList -> IList
02:02:40 <jle`> that just doesn't make any sense
02:02:43 <izohask> I agree
02:03:13 <izohask> it doesnt make sense... because IList is type constructor, it needs something more to become real type...
02:03:20 <izohask> I mean, it DOES make sense
02:03:36 <izohask> the thing that bothers me
02:04:04 <izohask> is that only "definition", "instance Monoid (IList a)"
02:04:11 <izohask> only here is the "a" part
02:04:25 <izohask> and nowhere in the definitions of functions (mempty, etc)
02:04:40 <izohask> and compiler already knows  about IList..
02:04:50 <mauke> well, it's implicit
02:04:52 <izohask> so why I have to add "IList a" there ?
02:04:53 <mauke> mempty :: IList a; etc
02:05:13 <izohask> aha... types of functions are created based on this type in "instance" declarations ?
02:05:25 <jle`> instance Monoid MYMONOID
02:05:26 <mauke> yes
02:05:27 <jle`> :t mempty
02:05:28 <lambdabot> Monoid a => a
02:05:33 <jle`> so MYMONOID would go where `a` is
02:05:40 <jle`> :t mappend
02:05:41 <lambdabot> Monoid a => a -> a -> a
02:05:44 <jle`> MYMONOID would go where `a` is
02:06:05 <jle`> it's a part of the syntax :)  whatever you put in instance Monoid (blah blah) goes where the `a` is in the type signatures
02:06:11 <mauke> in the class declaration it says mappend :: m -> m -> m. with your instance declaration this becomes mappend :: IList a -> IList a -> IList a
02:07:15 <jle`> by the way, the fact that the `a` is there also means a lot too in and of itself
02:07:29 <jle`> you could for example have written instance Monoid (IList Int) where ....
02:07:33 <jle`> and defined mempty, mappend, etc.
02:07:38 <jle`> and then write instance Monoid (IList Bool) where ...
02:07:43 <jle`> and definied mempty, mappend, etc., as well
02:07:53 <pavonia> Is there a way to show the definition of a GHCi command?
02:07:55 <mauke> that's not H98, is it?
02:08:09 <jle`> and those all "fit into" the type signatures of mappend and mempty
02:08:55 <jle`> but writing instance Monoid (IList a) where ... means, "if you give me an `a`, i'll give you a Monoid instance for `IList a`."
02:09:04 <jle`> hm this seemed more relevant before i started writing it
02:09:06 <jle`> i should probably sleep :)
02:09:49 <jle`> oh i guess you do need -XFlexibleInstances
02:09:51 <jle`> how weird
02:10:31 <jle`> probably best to ignore me at this state, sorry
02:14:35 <niklaus> interesting projects to learn haskell anyone
02:24:06 <PinealGlandOptic> hi everybody. ML praised for excellent type system. is it possible to encode there a value in range 0..11 for month in date, so it would be impossible to push 12 there? in Haskell?
02:24:12 <PinealGlandOptic> are there any other PL which makes this possible?
02:24:17 <PinealGlandOptic> this can be solved by allocating n bits for value, but it works only for values in 0..2^n range
02:24:58 <izohask> jle`: thank you
02:25:03 <FUZxxl> PinealGlandOptic: Haskell can't do that directly, but you can make a sum type with 12 constructors.
02:25:05 <izohask> I think I got better understanding now
02:25:17 <izohask> speciall with "Instance Monoid (List Int) / List (String9
02:25:31 <mauke> PinealGlandOptic: I bet Ada can do that directly
02:25:34 <FUZxxl> i.e. type Month = Jan | Feb | Mar | ...
02:25:41 <FUZxxl> mauke: yeah
02:25:59 <PinealGlandOptic> FUZxxl: but this is like enumeration... what if I need encode day in range of 0..30
02:26:38 <scott> in a dependently typed language like idris you can be very specific about your types like that
02:26:54 <FUZxxl> PinealGlandOptic: same thing. Haskell doesn't have the feature you want.
02:28:56 <FUZxxl> what's a good introduction to type theory?
02:29:03 <PinealGlandOptic> FUZxxl: IC. thanks!
02:29:32 <MP2E> You could 'cheat' and hide the constructor, only exposing functions that create one of the 12 months :P Or a sum type like said
02:29:58 <MP2E> but yeah as for encoding it in the type directly, not as far as I know..
02:30:24 <alpounet> FUZxxl: the TAPL book (Types and Programming Languages)
02:30:52 <PinealGlandOptic> alpounet: got it, thanks
02:31:35 <scott> I've learned a lot about dependent types without learning much type theory the way it looks in "math form" or something like that
02:32:07 <scott> I went through a bit of Software Foundations by the same author as TAPL
02:32:51 <alpounet> TAPL is quite easy to follow, and you get to implement type systems (if you want to -- that's recommended), so quite fun if you've not done that before
02:33:32 <scott> I should look into that. I've just started getting into writing my first non-dynamic language
02:38:33 <FUZxxl> what is the relationship between category theory and type theory?
02:41:14 <scott> as I understand it type theories can be viewed as categories, like the category Hask which has Haskell types as objects and Haskell functions as the arrows between objects
02:41:27 <scott> I'm not really sure of all the implications of the relationship
02:43:03 <scott> lots of connections show up like () being the terminal object of the category and Void being the initial object, but this won't mean anything to you unless you know those definitions
02:43:29 <scott> I guess it just gives you another way to examine things
02:57:08 <FUZxxl> Is there a paper on this topic I can read?
03:06:33 <scott> FUZxxl: iirc Basic Category Theory for Computer Scientists by Benjamin Pierce is a nice introduction
03:08:37 <FUZxxl> thank you.
03:17:05 <phaazon> hi
03:18:14 <phaazon> I’m trying to install cuda, the haskell package, on Windows
03:18:23 <phaazon> but it fails and I have no idea how to install it then :(
03:18:29 <phaazon> cuda is installed on my platform
03:19:13 * hackagebot buffer-builder 0.1.0.0 - Library for efficiently building up buffers, one piece at a time  http://hackage.haskell.org/package/buffer-builder-0.1.0.0 (chadaustin)
03:19:16 <phaazon> Cuda compilation tools, release 6.5, V6.5.13
03:20:19 <pavonia> phaazon: Please paste the build log with the error message
03:20:26 <phaazon> yep, sorry
03:21:27 <phaazon> pavonia: http://lpaste.net/119682
03:21:36 <phaazon> I’m still looking to the config.log file
03:21:43 <phaazon> for*
03:22:10 <phaazon> oh, nvm.
03:22:17 <pavonia> "checking whether the C compiler works... no" heh :)
03:22:18 <phaazon> it’s on line 4 :D
03:22:34 <phaazon> pavonia: hm
03:23:01 <phaazon> $ gcc --version
03:23:02 <phaazon> gcc.exe (rubenvb-4.6.3) 4.6.3
03:23:17 <phaazon> I guess it’s looking for cl.exe?
03:23:59 <pavonia> I'm not sure. Do you have MinGW installed on your system?
03:24:23 <phaazon> pavonia: I have git bash
03:24:30 <phaazon> maybe I need more tools?
03:25:11 <phaazon> I’m installing it right now.
03:25:12 <pavonia> I don't know about that, on Windows you usualy use MinGW + MSYS
03:25:22 <pavonia> or CygWin
04:27:51 <dramforever> I'm trying to play with DataKinds
04:28:06 <lpaste> dramforever pasted “My attempt” at http://lpaste.net/119684
04:28:26 <dramforever> But I have a problem:
04:28:27 <dramforever> http://lpaste.net/119684
04:31:33 <alpounet> dramforever: what's the problem?
04:32:11 <alpounet> oh, sorry, didn't see the comment in there
04:32:16 <dramforever> alpounet: See the comment
04:32:22 <dramforever> "How do I..."
04:32:31 <alpounet> yeah, didn't see it at first
04:32:44 <dramforever> alpounet: line 39
04:39:00 <alpounet> dramforever: hmm i think your type family only makes ghc aware of O + n = n, not of n + 0 = n
04:39:29 <lpaste> Alp annotated “My attempt” with “My attempt (annotation)” at http://lpaste.net/119684#a119685
04:39:48 <alpounet> dramforever: ^^^ would probably work, it uses a closed type family though
04:40:05 <alpounet> and I suppose you need Valued n =>  in eq0 sicne you use value. haven't tested but should work
04:40:14 <wz1000> On cabal building a project , I'm getting <command line>: cannot satisfy -package-id base-4.7.0.1-e4b74d27ad8c8987c63abc42a80e7335
04:44:28 <saep> wz1000: does `ghc-pkg check` detect anything?
04:44:55 <dramforever> alpounet: sorry for the delay. just came back
04:45:40 <alpounet> no worries
04:46:03 <dramforever> alpounet: well, I'm trying to prove that n+0 = 0
04:46:29 <alpounet> from 0+n = 0?
04:46:33 <scott> dramforever: you need to do induction on n (which means recursion here)
04:46:34 <alpounet> you need commutativity then
04:46:48 <scott> I don't know what form that would take in this context
04:48:00 <dramforever> alpounet: well, scott is right
04:48:01 <dramforever> It seems that I have ghc 7.6.4, and type family ... where doesn't work
04:48:01 <dramforever> Hmmm...
04:48:10 <alpounet> ha
04:48:19 <alpounet> right, closed type families landed in 7.8
04:48:43 <dramforever> It seems that alpounet doesn't know the peano arithmetic thing I'm doing, and scott doesn't really know how these bizarre types work
04:49:37 <scott> you already have the base case, and the other case should go like this: S n + 0 = S n ==> S (n + 0) = S n ==> S n = S n
04:49:59 <scott> the first step by definition of Add and the second step by the inductive hypothesis (recursion)
04:50:33 <scott> but I have no idea how this works in haskell with datakinds :)
04:50:34 <dramforever> scott: yes, but pattern matching on value to get a Zero doesn't make GHC think that n ~ Zero
04:51:12 <dramforever> Hmmm...Maybe I need *more* types
04:51:14 <scott> I believe agda/idris have something called dependent pattern matching, which may be a requirement here....
04:51:16 <alpounet> there's no reason to think n ~ 0
04:51:35 <alpounet> you want to prove: forall n. Add n Zero = n
04:51:43 <alpounet> so you don't want n ~ 0
04:51:44 <scott> dramforever: is it the base case that's not working right now?
04:51:48 <wz1000> saep: I fixed it by running cabal clean
04:51:59 <dramforever> alpounet: yes you are right
04:52:12 <dramforever> I'm trying to emulate dependent types
04:53:22 <dramforever> alpounet: How about data INat (n :: Nat) where IZ :: INat Zero; IS :: INat n -> INat (Succ N), and value :: proxy n -> INat n
04:53:37 <scott> right, in idris when you are proving n + 0 = n and you pattern match n as 0 in the definition, the type on the right hand side for that part becomes 0 + 0 = 0 which the type checker simplifies to 0 = 0 which is what allows you to write Refl
04:53:51 <scott> seems to rely on pattern matching affecting the type of the rhs
04:54:14 <dramforever> yes, I know how to do this in a dependent language
04:54:22 <alpounet> dramforever: so either you use the singletons library or you reinvent it just for your natural number type
04:54:41 <alpounet> but I think you can have a GADT do what you want yeah
04:54:46 <scott> it's funny how much *simpler* dependent types make everything
04:55:01 <dramforever> alpounet: yes I'm reinventing for fun
05:04:31 <alpounet> dramforever: i think you could then write a function: INat n -> NatEq (Add n Zero) n, since you can pattern match on the GADT value
05:04:58 <alpounet> and hence can have your induction
05:05:27 <dramforever> alpounet: well, I already have eq0 :: forall n. Valued n => NatEq (Add n Zero)
05:05:58 <dramforever> But I think that Valued n constraint is uncomfortable
05:06:10 <alpounet> yeah, you probably want to replace it by INat n
05:06:27 <alpounet> that you can pattern match on *while reflecting some information to the type level*
05:06:29 <dramforever> wait a sec, I think your INat n -> blah is better, I'll try it
05:06:36 <alpounet> I think i've just managed to implement whaty ou want
05:06:55 <alpounet> you should succeed too, but let me know if you need one more hint
05:07:51 <dramforever> alpounet: yes I think I'm heading the right way
05:08:10 <dramforever> thank you
05:18:43 <dramforever> alpounet: I wonder if I could convince GHC that Valued n, for all n :: Nat
05:19:00 <dramforever> I mean, the constraint is satisfied
05:19:32 <alpounet> well, you've written the two instances haven't you?
05:19:43 <alpounet> it's just not so great for proving anything at the type level
05:20:23 <dramforever> alpounet: yes you are right
05:20:44 <alpounet> dramforever: did you manage to prove n+0=0?
05:20:49 <alpounet> err, n+0=n
05:20:59 * alpounet jups on his coffee machine
05:21:18 <alpounet> jumps*, well, maybe i should just take a break and have my coffee before saying anything else =)
05:21:52 <dramforever> alpounet: yes I did it
05:22:05 <dramforever> but just for all n such that Valued n
05:22:17 <alpounet> uh? you don't need the Valued constraint
05:22:32 <dramforever> alpounet: yes, then I need a INat argument
05:22:40 <alpounet> yes
05:23:18 <dramforever> hmm...I think I saw a de-Valued-er with type blah -> (Valued n => a) -> a
05:23:33 <dramforever> I saw a thing similar to that in singletons
05:25:18 <rasen> How can I see which of my dependencies depends on binary?
05:25:41 <dramforever> alpounet: great, I've proved n+m = m+n on the type level!
05:27:13 <rasen> The problem is I'm want to install binary-7.3.0 but that causes error resolving dependencies
05:28:01 <alpounet> dramforever: cheers :)
05:30:20 <phaazon> pavonia: I still can’t install cuda :(
05:30:29 <phaazon> I get the same error, even from a msys shell
05:33:10 <lpaste> dramforever pasted “Here, I'm posting my proof in 40 lines of "elegant" haskell code” at http://lpaste.net/119686
05:33:50 <dramforever> alpounet: ^
05:38:09 <pavonia> phaazon: I don'T know how to read the configure script. Have you tried to compile a simple C file to a binary?
05:38:39 <michi7x7> heya
05:38:46 <michi7x7> ghc.io is down :(
05:41:03 <phaazon> pavonia: well
05:41:07 <phaazon> gcc is there
05:41:09 <phaazon> cc is not
05:41:18 <phaazon> the issue might be related to that?
05:41:57 <pavonia> Maybe
05:42:23 <phaazon> yeah, it does compile a simple C file to a binary
05:42:36 <phaazon> sh: cc: command not found
05:42:52 <phaazon> that’s embarrassing…
05:44:38 <phaazon> I don’t get why…
05:44:45 <pavonia> I'm wondering what compiler is used then
05:44:48 <phaazon> pavonia: have you tried to install the cuda package from hackagedb?
05:45:15 <pavonia> No
05:45:19 <phaazon> may you?
05:46:14 <phaazon> checking for gcc... gcc c:\Program Files\Haskell Platform\2014.2.0.0\mingw\bin\gcc.exe
05:46:17 <phaazon> checking whether the C compiler works... no
05:46:20 <phaazon> :(
05:46:45 <pavonia> gcc isn't actually a compiler, IIRC
05:48:02 <pavonia> I can't install atm, sorry, but configur script from Haskell packages worked for me earlier
05:48:26 <pavonia> Have you installed the MinGW tools too?
05:48:30 <phaazon> yeah
05:49:19 <pavonia> Oh well, I haven't installed cc either
05:49:19 * hackagebot web-routing 0.2.0 - simple routing library  http://hackage.haskell.org/package/web-routing-0.2.0 (HirotomoMoriwaki)
05:49:36 <phaazon> pavonia: cc is often a symlink to gcc
05:49:46 <phaazon> I don’t understand why it’s failing :(
05:49:53 <phaazon> cuda is perfectly working
05:50:17 <pavonia> Hhm, I thought gcc is only a tool that chooses the actual compiler
05:51:18 <phaazon> no
05:51:28 <phaazon> gcc is a compiler with several stages
05:51:35 <phaazon> front, back, and so on and so forth
05:52:44 <pavonia> Okay
05:54:29 <phaazon> :(
05:54:34 <phaazon> that bothers me a lot
05:54:40 <phaazon> I wanted to do some haskell cuda :(
05:55:39 <pavonia> I'm out of ideas, sorry. Maybe contact the author
05:55:52 <phaazon> I’ve already reported a ticket
05:56:01 <phaazon> https://github.com/tmcdonell/cuda/issues/25
05:56:11 <petercommand> cuda as in nvidia cuda?
05:56:27 <petercommand> oh yeah..
05:56:45 <phaazon> yeah, why?
05:57:33 <petercommand> just check if i understood correctly :p
05:57:54 <phaazon> https://www.haskell.org/pipermail/haskell-cafe/2013-March/107292.html
05:58:01 <phaazon> hm, it might help
06:01:02 <phaazon> ahah
06:01:09 <phaazon> the issue is related to spaces in names
06:01:15 <phaazon> https://github.com/tmcdonell/cuda/issues/25
06:01:17 <phaazon> see my latest comment
06:01:51 <phaazon> I’ll see that later, got to go
06:01:53 <phaazon> see you later
06:05:12 <Shockk> hello, I wondered if someone that has experience with the Haskell `network` library could answer a question for me; Network.Socket exposes the function `inet_addr` which is of the type String -> IO HostAddress; does this function support IPv6 addresses or only IPv4?
06:06:35 <saep> Shockk: Nope. HostAddress is equivalent to Word32.
06:07:01 <Shockk> oh, I should probably have looked that up
06:07:02 <Shockk> thanks
06:07:24 <Shockk> do you know of a way to get a HostAddress6 from the String representation of an IPv6 address?
06:08:24 <Shockk> actually, a better question would be: do you know of a way to get a SockAddr from a String
06:08:51 <saep> getAddrInfo
06:09:35 <saep> Shockk: Are you familiar with hoogle or hayoo?
06:09:43 <Shockk> ahh perfect, thanks
06:10:04 <Shockk> and I do know hoogle but I didn't find anything from a search for String -> IO SockAddr
06:14:20 * hackagebot web-routing 0.3.0 - simple routing library  http://hackage.haskell.org/package/web-routing-0.3.0 (HirotomoMoriwaki)
06:21:28 <alios> hi playing around with ghcjs/sodium and ran into this (already documented) issue - any ideas where and how to investigate: https://github.com/ghcjs/ghcjs/issues/296 ... what could possibly happen "after a few seconds" - some GC related things?
06:23:19 <alios> oh already an answer on the issue tracker \o/
06:29:21 * hackagebot web-routing 0.4.0 - simple routing library  http://hackage.haskell.org/package/web-routing-0.4.0 (HirotomoMoriwaki)
06:34:26 <Craig123> Can someone help me looping through a list ["I","will","finish","later","be","right","back"] and it replaces the two elements 'I will' with one element I'll  and replaces 'be right back' with 'brb'
06:35:41 <mniip> Craig123, f [] = []; f ("I":"will":xs) = "I'll":f xs; f ("be":"right":"back";xs) = "brb":f xs; f (x:xs) = x:f xs
06:35:59 <mniip> oops s/;xs/:xs/
06:38:34 <Craig123> mniip: thank you. So if there are 10-20 expressions I want to replace I just keep adding the new one on the next line?
06:39:06 <pranz> Craig123: to the line before the final case
06:39:10 <pranz> f xs; f (x:xs) = x:f xs
06:39:17 <pranz> must be last
06:39:45 <Craig123> mniip: Thank you so much! Which part was the oops for exactly? I'm still learning haskell
06:40:17 <mniip> Craig123, add them in the middle
06:40:42 <mniip> the oops was 'f ("be":"right":"back";xs)'
06:40:45 <mniip> should be ...:xs)
06:41:23 <mniip> if the 10-20 expressions are static, this will do
06:41:34 <mniip> if they're dynamic you might want to write a proper matching function
06:42:39 <Craig123> mniip: What exactly do you mean by if they are dynamic vs static?
06:42:54 <mniip> are the 20 expressions known at compile time
06:43:00 <mniip> or are they supplied at runtime
06:43:23 <Craig123> They are know and will be hard coded in
06:43:33 <Craig123> known*
06:45:19 <bennofs> Does a function foldMapM :: (Foldable t, Applicative f, Monoid m) => (a -> f m) -> t a -> f m exist in base?
06:46:09 <mniip> @hoogle foldMapM
06:46:09 <lambdabot> No results found
06:46:33 <mniip> yeaaah probably not
06:46:39 <ryantm> I'm trying to install GHCJS on Travis CI and here is the log where it fails: https://travis-ci.org/talklibre/talklibre/builds/49004132 The error message is "cabal: The program 'ghcjs' version >=0.1 is required but it could not be found." for "cabal install --reorder-goals --max-backjumps=-1 ./ghcjs ./ghcjs-prim" Anyone know what that probably means?
06:51:40 <jophish> Yo yo yo,
06:52:02 <jophish> Could somebody with a linux machine test something for me?
06:52:19 <ryantm> jophish: What do you want to test?
06:52:28 <jophish> I've written a simple example of calling into a shared library from Haskell, but don'e have a linux box to test this on
06:52:33 <jophish> https://github.com/expipiplus1/simple-shared
06:52:47 <jophish> clone, run build.sh and run the executable, it should print '5'
06:55:56 <ryantm> jophish: which file is the executable?
06:56:13 <jophish> executable/.cabal-sandbox/executable
06:56:44 <jophish> ryantm: you might need to run it from the same directory as the shared library file
06:56:47 <jophish> also thanks!
06:59:36 <ryantm> jophish: it did not work. https://gist.github.com/ryantm/74ff316956f0d414fd43
07:00:04 <ryantm> jophish: the executable was not where you said it would be, I think.
07:00:50 <jophish> oh sorry .cabal-sandbox/bin/executable
07:01:19 <jophish> ryantm: I think you might need to be in simple-shared/executable (where libadd.so is) for it to find the library
07:01:31 <jophish> thanks for checking though I appreciate it!
07:01:51 <ryantm> jophish: I went to that directory and ran the .cabal-sandbox one with the same error message
07:02:21 <jophish> ok, I'll investigate this next time I'm at a linux station
07:02:23 <ryantm> jophish: You should be able to use travis ci for this pretty easily and then it will check it every single time
07:02:37 <ryantm> jophish: that you make a commit
07:26:01 <tomphreek> what is filterM equivalent to? Trying to work through powerset xs = filterM (\x -> [True, False]) xs example, intuition fails me so badly, I d rather work through an explicit example in my head, but I don't really what filterM in terms of primitives like sequence, lift
07:28:05 <Rotaerk> tomphreek, it looks like,intuitively, it's the same as filter, but where the predicate is an IO action that produces a Bool
07:28:15 <hpc> @src filterM
07:28:15 <lambdabot> Source not found. My brain just exploded
07:29:29 <saep> tomphreek: Look up the definitions (i.e. source)  you need for the powerset function in terms of filterM, and write out a small example by hand.
07:30:02 <saep> tomphreek: That helped me a lot, anyway.
07:30:10 <hpc> tomphreek: a good example would be filterM doesFileExist
07:30:28 <Rotaerk> well, what I said is the IO-specific interpretation of it...
07:30:43 <Rotaerk> so doesn't help to understand in other monadic contexts necessarily
07:31:11 <hpc> it's not a member of Monad, so understanding for any Monad is sufficient
07:31:26 <hpc> http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Control-Monad.html#filterM
07:31:57 <tomphreek> hpc: thanks!
07:33:54 <hpc> tomphreek: by the way, if you are dead-set on understanding powerset, try translating filterM to be defined in terms of join
07:34:02 <hpc> that may make it easier
07:34:15 <hpc> (instead of do-notation / (>>=))
07:37:01 <tomphreek> hpc: I ll try. I love the implementation. It's the kind of "naive" implementation even I'd be able to write, still trying to work out the powerset magic
07:45:13 <tomphreek> > do a <- (\x -> [True, False]) 0; return (if a then 'A' else 'B')
07:45:15 <lambdabot>  "AB"
07:46:16 <rasen> Why not
07:46:16 <rasen> > do a <- [True, False]; return (if a then 'A' else 'B')
07:46:18 <lambdabot>  "AB"
07:49:20 <sdegutis> Anyone getting invalid HTTPS certificate warnings on haskell.org ?
07:50:57 <rigsby> hmm sdegutis.. yea
07:52:49 <tomphreek>  > [True, False] >>= (\x -> if x then ['A'] else ['B'])
07:54:25 * hackagebot deepseq-bounded 0.6.1.0 - Bounded deepseq, including support for generic deriving  http://hackage.haskell.org/package/deepseq-bounded-0.6.1.0 (AndrewSeniuk)
07:54:27 * hackagebot leaky 0.2.1.1 - Robust space leak, and its strictification  http://hackage.haskell.org/package/leaky-0.2.1.1 (AndrewSeniuk)
07:54:29 <jedai42> > [True, False] >>= (\x -> if x then ['A'] else ['B'])
07:54:30 <lambdabot>  "AB"
07:59:25 * hackagebot seqaid 0.2.1.1 - Dynamic strictness control, including space leak repair  http://hackage.haskell.org/package/seqaid-0.2.1.1 (AndrewSeniuk)
08:00:54 <raek> someone should make t-shirts that say "I >>= Monads"
08:05:24 <mniip> I bind Monads?
08:06:08 <barrucadu> Well, they're not going to bind themselves
08:07:26 <sdegutis> How do you specify -lfoo in a .cabal file?
08:10:34 <sdegutis> Oh: ghc-options
08:11:26 <arianvp> Any haskellians currently at FOSDEM? I'd love to meet
08:11:28 <athan> I think I saw one that said "Monads are like T-Shirts"
08:12:07 <rasen> It remind me about "Monads are like burritos"
08:12:13 <athan> haha
08:12:40 <rasen> @google Monads are like burritos
08:12:42 <lambdabot> http://blog.plover.com/prog/burritos.html
08:12:42 <lambdabot> Title: The Universe of Discourse : Monads are like burritos
08:12:55 <athan> double-layer chalupa >>= crunchwrap supreme?
08:13:18 <cmccann> monads are like analogies, they're abstract and prone to being overused
08:14:36 <athan> gold
08:15:25 <tomphreek> > filterM (\x -> [True, False]) [0, 1]
08:15:27 <lambdabot>  [[0,1],[0],[1],[]]
08:15:35 <tomphreek> > do flg <- [True, False]; ys <- [[1], []]; return (if flg then 0:ys else ys)
08:15:37 <lambdabot>  [[0,1],[0],[1],[]]
08:16:25 <deech> Having issues with `cabal build <executable-name>`. It keeps saying that <executable-name> is  a bad flag.
08:16:29 <mniip> > filterM (const [True False]) "abc"
08:16:30 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool -> GHC.Types.Bool’
08:16:31 <lambdabot>              with actual type ‘GHC.Types.Bool’
08:16:37 <mniip> > filterM (const [True, False]) "abc"
08:16:39 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
08:16:41 <mniip> fancy
08:16:46 <Zoetrope> all hail the monad
08:17:31 <Zoetrope> really though that function is really cool and makes perfect sense
08:17:52 <cmccann> it makes perfect sense once you understand what filterM does
08:17:59 <cmccann> it looks deeply magical to newbies though
08:18:13 <Zoetrope> Don't worry, I remember the first time
08:19:26 * hackagebot deepseq-bounded 0.6.2.0 - Bounded deepseq, including support for generic deriving  http://hackage.haskell.org/package/deepseq-bounded-0.6.2.0 (AndrewSeniuk)
08:19:35 <pranz> :t filterM
08:19:36 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
08:22:28 <sdegutis> How do you convert an Int to a CInt?
08:22:31 <pacific> Hello all, I am trying to learn to package something in haskell and I'm getting errors about "Not in scope: type constructor or class 'Bool'"
08:22:43 <cmccann> sdegutis: fromIntegral will work
08:22:49 <sdegutis> Oh cool thanks
08:23:35 <pacific> I figured this was due to build-depends problems, but shouldn't 'base' be enough? http://lpaste.net/119695
08:23:44 <profil> sdegutis: mkCInt, which uses fromIntegral
08:23:58 <profil> oh, didnt see cmccann there
08:24:15 <cmccann> hm. why "fromIntegral" and "realToFrac"?
08:24:21 <sdegutis> profil: oh cool
08:24:30 <cmccann> shouldn't it be "integralToNum" or "fromReal"?
08:24:35 <cmccann> to be consistent
08:24:40 <cmccann> this concerns me.
08:24:50 <profil> :)
08:25:04 <sdegutis> For my next trick, I plan to *create* a C function pointer from a Haskell function.
08:25:37 <mniip> sdegutis, so hold on a second
08:25:45 <mniip> are you actually rewriting mjolnir in haskell right now?
08:25:48 <mniip> is this for real?
08:28:05 <sdegutis> mniip: yes
08:28:30 <sdegutis> https://github.com/sdegutis/servum/commit/8a7a2de724a81c477fc3a59cfd96a8a40eaa1242
08:32:01 <HeladoDeBrownie> sdegutis, your commit messages are very… terse :P
08:32:15 <sdegutis> HeladoDeBrownie: meh its all experimentation for now so
08:36:03 <tomphreek> > do flg <- [True, False]; ys <- [[1], []]; return (if flg then 0:ys else ys)
08:36:05 <lambdabot>  [[0,1],[0],[1],[]]
08:36:06 <tomphreek> > concat (map (\x -> if x then [0]:ys else ys) [True, False])
08:36:07 <lambdabot>  Not in scope: ‘ys’
08:36:07 <lambdabot>  Perhaps you meant one of these:
08:36:07 <lambdabot>    ‘y’ (imported from Debug.SimpleReflect),
08:37:11 <athan> The unification algorithm from Martelli, Montanari can fulfil the substitutions over an inductive list of substitutions (involving functions, terms, constants, etc). Does this algorthm look at both the lhs and rhs of each substitution in order to find some result? I'm seeing some examples where if a variable is on the rhs and a constant is on the lhs, they are "flipped" in the result
08:45:23 <sdegutis> How do you pass a Haskell function where a C function pointer is expected?
08:45:41 <sdegutis> Better yet, how do you declare a C function that takes a function pointer?
08:45:50 <sdegutis> And how do you convert the Haskell function pointer to the C argument?
08:47:13 <Clint> sdegutis: look at the modules in base that start with Foreign.
08:48:36 <sdegutis> CInt: Oh I see FunPtr now, thanks
08:59:09 <Lisured> hi
08:59:53 <Lisured> could somebody explain me why when I import Data.Text as qualified it can't be found?
08:59:55 <Lisured> https://gist.github.com/jtojnar/227d9afe0dc63894bb82
09:01:24 <HeladoDeBrownie> Lisured, the problem is you didn't import it qualified. import qualified Data.Text as T.
09:01:50 <sdegutis> Help, I'm trying to turn a () -> IO () into a FunPtr (() -> IO ()) and I can't find a function to do this!
09:01:51 <HeladoDeBrownie> oh, sorry, i missed the second part >_<
09:02:43 <tomphreek> still with putting 2 and 2 together and working out the powerset example. I understand this: [True, False] >>= (\x -> if x then ['A'] else ['B']), but not this: do flg <- [True, False]; ys <- [[1], []]; return (if flg then 0:ys else ys)
09:03:12 <tomphreek> still struggling*
09:03:47 <Lisured> HeladoDeBrownie it's pretty weird
09:04:07 <HeladoDeBrownie> Lisured, is everything else the same? also, how are you compiling your project?
09:04:24 <cmccann> tomphreek: what powerset example is this?
09:04:53 <sdegutis> Oh I see, I need to create a "wrapper stub" in Haskell.
09:05:02 <Lisured> yes, I only changed the import line and build it using ghc --make src/weirwood.hs
09:05:09 <rasen> If I have State monad but part of state doesn't mutate. Should I roll ReaderT on top?
09:05:11 <cmccann> tomphreek: the only confusing powerset function I can recall is the filterM one mentioned earlier
09:05:26 <cmccann> oh wait I see you tried both
09:05:40 <tomphreek> that's the one, I am working through filterM implementation to see how it works
09:05:47 <cmccann> oh ok
09:07:21 <Lisured> HeladoDeBrownie can't laziness have something to do with it?
09:07:24 <HeladoDeBrownie> Lisured, this might be a longshot, but make sure there are no special invisible characters on that line, maybe retype it entirely? i'm sort of at a loss because i've never seen this before
09:07:26 <cmccann> tomphreek: trying to analyze that by looking at the implementation is confusing, yes
09:07:32 <HeladoDeBrownie> Lisured, no that has nothing to do with imports
09:07:47 <cmccann> tomphreek: instead, start by thinking about what a filter-based version would look like
09:07:57 <HeladoDeBrownie> anyway, just remembered i have to go. sorry i couldn't help so much
09:08:21 <cmccann> tomphreek: filterM is using a function (a -> m Bool) which in this case is the "const [True, False]" bit
09:09:58 <cmccann> tomphreek: regular filter would use a function (a -> Bool). (const True) or (const False) would filter everything or nothing regardless of the elements, right?
09:10:15 <tomphreek> yeah
09:10:21 <cmccann> tomphreek: so conceptually the list monad here represents non-determinism
09:10:39 <tomphreek> I am not happy with the analogy of non-determinism
09:11:07 <cmccann> so instead of always everything or nothing, it's nondeterministically filtering or not filtering every element, then collecting every possibility
09:11:19 <cmccann> why not? that's the best way to think about it in this case.
09:13:58 <tomphreek> analogies guide us to understanding, but could also mislead. the implementation doesn't mislead, though might provide no guidance
09:14:48 <Lisured> HeladoDeBrownie oh, I missed the errod didn't come from ghc but from hastec
09:15:05 <cmccann> in this case it barely even qualifies as an analogy. it's straightforward (though not necessarily efficient) to implement stuff like nondeterministic state machines this way.
09:16:05 <scott> lists modelling non-determinism made a lot most sense to me after my automata class. if you want to run a non-deterministic turing machine deterministically, whenever you have multiple choices, you just do all of them (and have a list of new states instead of just one new state)
09:17:14 <tomphreek> I don't like nondeterministic term either. It defines probability space, but it doesn't do so in non deterministic manner, there's no probability involved in generating multiple returns
09:17:42 <scott> nondeterministic turing machines have nothing to do with probability
09:17:59 <tomphreek> great
09:18:12 <cmccann> and anyway, if you want to get a single answer out of a "nondeterministic" computation you have to pick an element from the list. that's where probability would come in.
09:18:48 <monochrom> my way to explain it is that non-determinism doesn't even tell you the probabilities
09:19:38 <tomphreek> however, probability measure is still missing. we are just defining the space of events, but not assigning probabilities along the way (unless you wanna assign a to each outcome and try to indroduce probability measure by returning same outcome more than once)
09:20:08 <scott> a single step in a nondeterministic turing machine works like this: you start, possibly in any number of states -> for each state you find out which states you could get to -> your result is the set of all states you could reach from any of the initial states
09:20:12 <monochrom> although, in colloquial layperson imprecise thought, "it acts randomly" and "it acts non-deterministically" are lumped together
09:20:17 <scott> the above describes exactly what >>= does on lists
09:20:47 <cmccann> tomphreek: in the automata sense, non-determinism just means "when presented with a choice, take all branches". that's the sense being used for the list monad as well.
09:20:56 <scott> you take each element in the starting list, make a list from each, and join them all together
09:21:44 <cmccann> tomphreek: but yes, if you want a probability every list element would be considered equally likely
09:24:15 <sdegutis> I got *this close* to using Lua from Haskell, it even compiled and ran! But my Haskell function is never called from Lua.
09:30:32 <tomphreek> cmccann, scott: you win. analogy is better
09:31:16 <sdegutis> Do you usually just use 'cabal run' to compile and run your Haskell project?
09:31:29 <cmccann> tomphreek: so, back to the power set thingie
09:33:20 <cmccann> tomphreek: if you think of it as filtering the list non-deterministically, with each element being both kept and discarded, does that make sense?
09:37:06 <tomphreek> right now see it as a distinct union {filter (\x -> True) list, x \in list} U {filter (\x -> False) list, x \in list} <- the latter is just {list}
09:37:14 <tomphreek> oh not that's wrong
09:38:23 <tomphreek> it's more of running all possible {\x_i -> True or False} against the list
09:40:33 <cmccann> tomphreek: yes
09:41:43 <tomphreek> this is the bit when I don't like analogies, cuz my first interpration fails: the one when I generate all possible sublists with at most one element missing
09:43:20 <cmccann> tomphreek: I'm not sure what you mean there
09:44:35 <rasen> The only way to terminate current thread is to throw exception?
09:44:36 <dfeuer> How, if at all, does the many member of Alternative relate to the many function in Parsec?
09:45:06 <dfeuer> (Note: Parsec lets its Alternative instance use the default def of many)
09:45:20 <tomphreek> well one way I could interpret the analogy (which is wrong, but I don't see why yet) is to generate all possible f_x = {\x -> False} lambdas (only one element is filtered out) and then run all f_x's against the list, to get list of sublists of cardinality |list| - 1.
09:45:41 <tomphreek> then generate f_x = {\x -> True
09:45:53 <cmccann> dfeuer: parsers were the original use case for Applicative and Alternative, so I imagine the Alternative combinator is a generalization, give or take
09:46:05 <tomphreek> run those filters, and get all sublists of cadrinality 1
09:46:08 <tomphreek> and then finally join
09:46:39 <dfeuer> cmccann, that makes it particularly peculiar that it would use the default def there....
09:48:11 <scott> tomphreek: have you tried going through what filterM (const [True, False]) [1,2,3] does step by step (even at a high level)?
09:48:42 <cmccann> tomphreek: there's no point where it would be filtering out a specific number of elements
09:48:48 <scott> tomphreek: first step, we look at the 1 and we have two possibilities: keep it or throw it away, so our states are [[], [1]]
09:49:29 <cmccann> tomphreek: it just generates [True, False] as the filter choice for each element, like this:
09:49:38 <scott> tomphreek: next step, we see 2 and have the same possibilities, but this time two initial states, so we go [] => [[], [2]] and [1] => [[1], [1,2]] and combine to the new state list [[], [2], [1], [1,2]]
09:49:43 <cmccann> > replicate 3 [True, False]
09:49:44 <lambdabot>  [[True,False],[True,False],[True,False]]
09:50:27 <cmccann> tomphreek: and then runs through each possibility to get the result lists
09:50:31 <cmccann> > sequence $ replicate 3 [True, False]
09:50:33 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
09:54:16 <cmccann> tomphreek: keep in mind that the list being filtered and the list monad used for filtering are completely separate. what filterM does makes sense in any monad.
09:54:41 <cmccann> e.g. you could use filterM with IO to filter a list of filenames by whether the files exist
09:56:10 <cmccann> tomphreek: with the list monad, the choice to keep/discard each element is made independently, rather than generating schemes to filter the whole list in various ways
09:57:07 <sdegutis> hahahahaha unsafePerformIO
09:57:23 <mniip> what about it
09:58:04 <sdegutis> i just discovered it
09:58:18 <sdegutis> totally lets you break the entire purity thing
09:58:31 <scott> hence the name
09:58:35 <sdegutis> :)
09:58:47 <mniip> anything named unsafe lets you break the entire thing
09:58:52 <scott> `unsafeCoerce :: a -> b` is also a lot of fun
09:59:18 <mniip> > unsafeCoerce [] :: Integer
09:59:19 <lambdabot>  Not in scope: ‘unsafeCoerce’
09:59:20 <sdegutis> mniip: what am i doing wrong here?  lua_pcallk is returning 2 on https://github.com/sdegutis/servum/blob/master/Main.hs#L28
09:59:22 <mniip> awww
09:59:30 * hackagebot drifter 0.1.0.1 - Simple schema management for arbitrary databases.  http://hackage.haskell.org/package/drifter-0.1.0.1 (andrewrademacher)
09:59:57 <mniip> isn't 2 like... LUA_ERRRUN?
10:00:08 <cmccann> mniip: yeah, lambdabot isn't going to let you cause a segfault :P
10:00:30 <sdegutis> mniip: yes but what could possibly go wrong here?
10:00:41 <sdegutis> im just running "print('welp')
10:00:43 <sdegutis> "
10:00:47 <cmccann> it's programming, everything can always go wrong
10:00:53 <thoughtpolice> as an exercise, try implementing unsafeCoerce in terms of unsafePerformIO :)
10:01:10 <thoughtpolice> (if you want an exercise in being evil, anyway)
10:01:31 <cmccann> thoughtpolice: implementing unsafePerformIO in terms of unsafeCoerce is more exciting
10:01:52 <monochrom> exercises of being evil are instructive
10:01:57 <mniip> sdegutis, what are you doString'ing
10:02:05 <mniip> (also I have no experience with foreign)_
10:02:08 <cmccann> or, if you're shachaf, you can implement unsafeCoerce in terms of exciting new GHC bugs
10:02:40 <monochrom> for example, [in]computability is full of exercises of "try solving the halting problem if this other problem is decidable"
10:02:58 <csd_`> In the context of accumArray, what would the symbolic representation of the accumulation function (\/), where this represents an upside down caret, mean?
10:03:17 <sdegutis> mniip: "print('welp')"
10:03:21 <scott> or the standard dependently typed language favourite: prove false
10:03:23 <sdegutis> mniip: its all in this one file
10:04:18 <thoughtpolice> cmccann: :) was talking with someone earlier about how elegant GHC ticket #10000 is
10:05:00 <sdegutis> even simpler fail-case:  https://github.com/sdegutis/servum/blob/master/Main.hs#L48-L52
10:05:08 <cmccann> thoughtpolice: yes, I think that's the most photogenic unsafeCoerce-implementation-via-GHC-bug I've seen so far
10:07:15 <rasen> Just realized that I can have fields with the same name in different constructors within the same type.
10:07:27 <lpaste> sgillis pasted “deduceGeneric” at http://lpaste.net/1848900734217617408
10:07:28 <lpaste> sgillis pasted “deduceGeneric” at http://lpaste.net/6770589048164581376
10:07:33 <lpaste> sgillis revised “deduceGeneric”: “No title” at http://lpaste.net/6770589048164581376
10:08:34 <sgillis> Can anyone help me with making the previous snippet compile?
10:08:55 <sgillis> I get an error stating:  No instance for (Generic (f a)) arising from a use of `from'
10:09:11 <sgillis> But I don't know how I could add that as a type constraint
10:09:56 <cmccann> sgillis: make it a constraint on gname?
10:10:33 <sgillis> How would you do that?
10:10:52 <cmccann> gname :: (Generic (f a)) => f a -> String -> Bool
10:10:55 <cmccann> in the class definition
10:12:03 <sgillis> I tried that
10:12:05 <sgillis> That gives
10:12:08 <sgillis> Could not deduce (Generic (f a1)) arising from a use of `from' from the context (Generic (f a))
10:14:47 <shachaf> thoughtpolice: Such a shame #10000 is a duplicate.
10:21:41 <aaronj1335> hey folks i'm reading http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass and i'm trying to figure out how `Map k` is made an instance of Functor
10:21:48 <aaronj1335> where can i check my answer?
10:22:07 <cmccann> sgillis: ok, I have no idea how to fix that easily. you seem to be having issues with it not unifying unnamed type variables the result of type family application
10:22:12 <aaronj1335> can i run something like `:typeclasses Data.Map.Map`?
10:22:23 <cmccann> aaronj1335: you can look at the source code for Data.Map
10:22:34 <aaronj1335> cmccann where do i find that?
10:22:50 <aaronj1335> wait
10:22:59 <aaronj1335> i think i see a link in the hackage docs...
10:23:02 <cmccann> yeah
10:23:04 <cmccann> http://hackage.haskell.org/package/containers-0.5.6.3/docs/src/Data-Map-Base.html#Map
10:23:10 <cmccann> scroll down, the Functor instance is near the bottom
10:23:29 <cmccann> and it uses other functions defined in Data.Map
10:23:48 <cmccann> that said, if your Functor instance works at all it's probably correct
10:23:49 <aaronj1335> RADDDD
10:23:53 <aaronj1335> thanks
10:24:10 <aaronj1335> yea, well i was also reading a SO answer
10:24:15 <mp> if there a way to share state between TH invocations? for example, I might want to bake-in binaries into executable; how do I cache them, so they are not baked in many times? or how could I cache result of some computation/interaction so that second TH reuses results computed by first TH?
10:24:16 <aaronj1335> or a couple
10:24:24 <aaronj1335> and it seemed like there were more than one way to do it
10:24:38 <aaronj1335> so i figured i'd check the cannonical way too
10:24:47 <tasker> urlencode from Network.HTTP.Types.URI doesn't encode =. What does ?
10:25:09 <sgillis> cmccann: Is that a problem that occurs in other places? Do you have any idea in which direction I should look for an answer?
10:25:30 <cmccann> sgillis: I'd suggest posting a question on Stack Overflow
10:25:54 <sgillis> cmccann: Alright, thanks for your time anyway!
10:26:37 <cmccann> you're probably going to need ScopedTypeVariables and more type annotations, I'm just not sure where and don't have time to figure it out myself right now
10:26:55 <Phillemann> I'd like to serialize Haskell structures and send/receive them over a socket. What libraries are recommended for both serialization/network?
10:27:02 <Phillemann> It doesn't have to be ultrafast or anything.
10:27:38 <cmccann> Phillemann: http://hackage.haskell.org/package/binary is popular for binary serialization
10:28:13 <cmccann> there's also http://hackage.haskell.org/package/aeson if you want JSON
10:28:32 <cmccann> and if you really, REALLY don't care about performance, just using read/show goes a long way
10:29:06 <Phillemann> I'd favor something where I can just "derive XY" and don't have to worry about how the structure is serialized. :>
10:29:30 <Phillemann> You're right, read/show might just do it. Didn't even think of that :D
10:29:44 <cmccann> Phillemann: for binary and aeson, you can derive Generic with a GHC extension
10:29:50 <hpc> tasker: it seems to for me
10:29:58 <cmccann> and they both define generics-based implementations
10:29:59 <hpc> urlEncode "123=456&zork=baz"
10:30:02 <tasker> hpc: huh
10:30:03 <hpc> "123%3D456%26zork%3Dbaz"
10:30:44 <hpc> oh, i am using Network.HTTP.Base
10:30:55 <tasker> Ahh
10:31:00 <tasker> That would be it
10:32:01 <Phillemann> cmccann: Ah, ok.
10:32:24 <cmccann> Phillemann: the performance of read/show can leave a lot to be desired in some cases, but for small data structures or proofs-of-concept they're fine
10:32:36 <darthdeus_> why is the stackage lts locked at cabal-install 1.18? isn't that like a really old version?
10:32:37 <hpc> tasker: are you specifying extra unreserved chars?
10:32:45 <tasker> hpc: No, I want all to be encoded.
10:32:55 <osa1> does anyone here know about msgpack? is it possible to find length of the msgpack object coming from a stream without parsing the whole thing?
10:33:13 <hpc> er, whatever that Bool is called
10:33:15 <hpc> "Whether input is in query string. True: Query string, False: Path element"
10:33:21 <cmccann> Phillemann: personally I'd start by using read/show but make sure it won't be too difficult to switch to something better if it becomes necessary
10:33:43 <hiptobecubic> osa1, isn't the whole point of msgpack that it prepends lengths so you can decode without parsing?
10:33:51 <hpc> make sure it's True for query string, (meaning, assume the string goes after "?")
10:34:22 <cmccann> ahahaha I can't believe someone actually requested this: https://ghc.haskell.org/trac/ghc/ticket/6162
10:34:22 <Phillemann> cmccann: Yeah, in the end, there's a function for "T -> ByteString" and an inverse function. How they work sholdn't affect the rest of the code. :)
10:35:12 <osa1> hiptobecubic: I'm looking here https://github.com/msgpack/msgpack/blob/master/spec.md#formats-array and I can't see how can I know how many bytes to expect from the stream
10:35:35 <hiptobecubic> cmccann, maybe they don't know what 'defer' means
10:36:01 <osa1> hiptobecubic: to be more specific
10:36:16 <osa1> hiptobecubic: let's say I'm expecting an array and yes I can know the length of the array from the first few bytes
10:36:36 <osa1> hiptobecubic: but there's no way to know how many bytes _in total_ to expect. e.g. how big is the whole serialized array
10:37:12 <hiptobecubic> ah, yeah. I don't think it makes any claims that that should be possible.
10:37:28 <osa1> hiptobecubic: so parser needs to be interleaved in stream producer. maybe attoparsec style Partial would work, or a Pipe
10:38:05 <osa1> hiptobecubic: the problem is that msgpack library in haskell is implemented using cereal(or binary) so they're basically useless to incrementally parse from a stream
10:38:12 <osa1> you have to provide exact right amount of bytes
10:38:22 <osa1> which you can't really know
10:38:27 <osa1> unless the sender first sends the length
10:39:19 <tomphreek> cmccann, scott: thank you
10:40:15 <osa1> oooh wait, this one is using attoparsec http://hackage.haskell.org/package/msgpack-0.7.2.5/docs/Data-MessagePack-Unpack.html
10:40:30 <osa1> it should be possible to implement a Pipe on top of this
10:41:09 <athan> aww yea http://deconfigured.com/blog/atlc3
10:41:13 <osa1> too bad it's not maintained
10:42:01 <osa1> this one is the one that sucks http://hackage.haskell.org/package/messagepack
10:42:08 <osa1> it's using cereal so useless for parsing from streams
10:42:16 <osa1> unless you unsafeInterleaveIO, I guess
10:50:00 <sdegutis> this is interesting http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/HaskellRetrospective-2.pdf
10:52:10 <darthdeus_> if anyone could take a look at https://www.reddit.com/r/haskell/comments/2ubsti/what_are_the_current_best_practices_for/ i'd be really happy :) i've literally spent more time re-compiling packages than programming in the past week
10:54:23 <sdegutis> ha! figured it out: "[string "print(3)"]:1: attempt to call global 'print' (a nil value)" /cc mniip
10:54:27 <sdegutis> duh lol
10:56:15 <rasen> What I like about Haskell is that every extension usage is obvious (I mean, you put pragma and everyone knows it's extension). In C I've said to people that something is gcc extension and generally shouldn't be used at least hundred times.
10:56:43 <sdegutis> IT WORKSSSSSS
10:57:11 <sdegutis> awesomeeeeee
10:58:38 <cmccann> rasen: unless you enable the extension via compiler flags using a .cabal file
10:59:29 <rasen> cmccann: Anyway, you stated somewhere that you use extension
10:59:36 <cmccann> yeah
11:00:02 <monochrom> yeah, what C compiler extensions you use are hidden in the makefile rather than in the files that use the extensions
11:00:50 <rasen> monochrom: nope, there is no mention even in makefile.
11:01:04 <rasen> Usually, all extension are on by default
11:01:25 <darthdeus_> shit, is there a way to edit title on reddit?
11:01:29 <darthdeus_> forgot to put a question mark :X
11:01:31 <monochrom> yes, the word "gcc" and the lack of suppression flags
11:01:38 <darthdeus_> now it doesn't look like a question :P
11:01:57 <cmccann> darthdeus: sorry
11:01:57 <monochrom> retract the post altogether
11:02:09 <cmccann> darthdeus: not even mods can edit submission titles
11:02:13 <monochrom> then log off from reddit. don't ever return again. :)
11:02:38 <monochrom> reddit is the main cause of all reddit problems
11:02:46 <monochrom> <-- the greatest tautologist ever
11:02:55 * cmccann can't argue with monochrom's logic there
11:03:39 <osa1> I'm wondering if we have a maintained fork of msgpack package.
11:05:59 <lpaste> lwm pasted “reader + readerT” at http://lpaste.net/119700
11:06:17 <lwm> guys, trying to figure out differences between Reader + ReaderT
11:06:30 <lwm> quite confused now, bot those examples work from the lpaste
11:06:48 <lwm> I can use a 'Just x' a pass it into a regular 'Reader', why do I need 'ReaderT'
11:07:26 <rasen> lwm: If you want two manads at the same time, you can use ReaderT to do that
11:07:29 <EvanR> how is FILE* supposed to be treated in the ffi
11:07:30 <rasen> monads*
11:07:45 <cmccann> lwm: what do you think the types of those definitions are?
11:07:47 <rasen> EvanR: foreignPtr?
11:08:17 <mniip> just like one would treat a void *
11:08:23 <EvanR> ok
11:08:31 <EvanR> Ptr a ?
11:08:43 <lwm> rasen: hmm ... so I would use ReaderT if I was doing some IO and using Maybe and wanted some Reader data
11:08:52 <rasen> lwm: yes
11:08:53 <mniip> Ptr ()
11:09:19 <rasen> lwm: but you want MaybeT also
11:09:23 <EvanR> Ptr () is weird
11:09:50 <mniip> I heard it's used because there's no Storable ()
11:09:55 <cmccann> lwm: I'm not sure those examples are doing what you think
11:10:05 <mniip> no instance Storable ()
11:10:24 <lwm> cmccann: both give me back the value of the Reader?
11:10:37 <ClaudiusMaximus> EvanR: Ptr CFile
11:10:43 <ClaudiusMaximus> i think
11:11:07 <hiptobecubic> Christ
11:11:14 <ClaudiusMaximus> EvanR: http://hackage.haskell.org/package/base-4.7.0.2/docs/Foreign-C-Types.html#t:CFile
11:11:22 <lwm> cmccann: oh wait, you are right
11:12:12 <hiptobecubic> Not only did microsoft not document any of the exceptions that the translator API can return, they also change the names of them without telling users of the service.
11:12:20 <osa1> do we have a library that provides attoparsec parsers like getWord64be, getFloat64be etc. ?
11:12:40 <hiptobecubic> "Unfortunately, we do not have a list of exceptions available right now.  Do you have any specific questions about the Quota Exceeded exception that we can answer?"
11:12:46 <EvanR> ah didnt notice CFile in there
11:12:53 <cmccann> hiptobecubic: that's marvelous.
11:13:05 <hiptobecubic> yes
11:13:10 <rasen> @hackage attoparsec-binary
11:13:11 <lambdabot> http://hackage.haskell.org/package/attoparsec-binary
11:13:37 <rasen> osa1: ^
11:13:38 <hiptobecubic> "You could look for these strings in the error message: "IP is over the quota", "AppId is over the quota" "
11:14:18 <jophish_> Yo yo yo
11:14:52 <jophish_> What machinery is there in Haskell for rust-like memory management? The regions package looks to be on the right lines
11:15:15 <osa1> rasen: awesome, thanks
11:17:42 <sinelaw> jophish_, take a look at the ResourceT package https://hackage.haskell.org/package/resourcet
11:17:55 <sinelaw> (There are probably others too)
11:18:00 <jophish_> An unrelated question: I'm getting an untrusted certificate from haskell.org
11:18:25 <rasen> jophish_: you're not alone
11:18:49 <sinelaw> I don't. weird.
11:19:10 <rasen> I don't too, but there were other guys who do
11:21:43 <phaazon> https://github.com/tmcdonell/cuda/issues/25 is there anyone there who could help me with that issue? :(
11:22:01 <Pamelloes> jophish_: Same thing just happened to me...
11:22:16 <cmccann> jophish: I get a warning about the page containing unencrypted content, but nothing about the certificate
11:22:43 <EvanR> so Show... if its not possible to write a Read instance for something, is Show justified? it is still possible for debugging, inspection, but what if i cant show all the fields in a way that will be Readable
11:22:50 <geekosaur> platform matters
11:22:51 <EvanR> is there a convention for this
11:23:06 <geekosaur> OS X seems to have whatever cert in the system keychain
11:23:47 <geekosaur> there is no convention for it and given how Show/Read conflates things it might not be worth worrying about
11:24:19 <EvanR> nice
11:24:28 <geekosaur> I would probably go for something that is a deliberate syntax error just in case it finds its way into something that ought to be Read-able
11:24:38 <cmccann> the convention is to use Show and Read as if there is no convention
11:25:57 <jophish_> sinelaw: thanks for the pointer, I've not yet found a library which reaches the sophistication of the rust borrow checker, but I think that's beyond Haskell
11:26:20 <EvanR> i guess some "standard" show instances do not care about this, like the time types
11:27:55 <cmccann> EvanR: a well-behaved Show/Read pair should have the property that read.show = id and that the string representation can be pasted into Haskell source and evaluate to something equal to the original value
11:28:48 <cmccann> for a lone Show instance I don't know that anyone really cares.
11:29:08 <Yuras> jophish_: I know two packages: regions and regional-pointers. Unfortunately both are old
11:29:34 * hackagebot MSQueue 0.0.1 - Michael-Scott queue.  http://hackage.haskell.org/package/MSQueue-0.0.1 (julek)
11:29:43 <Yuras> it is not common in haskell to use Rust-like regions
11:30:38 <jophish_> Yuras: yeah, regions looks really nice, but not perfectly suited to scarce resources
11:30:59 <Yuras> resourcet is used far more widely, but it doesn't really enforces anything
11:31:15 <johnw> and pipes-safe
11:31:24 <jophish_> Yuras: that's what I'm not so keen on, It would be lovely to get static guarantees on this kind of stuff
11:32:06 <Yuras> jophish_: not perfectly suited? what exactly do you mean?
11:32:07 <johnw> jophish: how about http://www.haskellforall.com/2014/08/managed-100-monad-for-managed-resources.html
11:32:52 <Yuras> johnw: its a bit different from rust approach
11:33:08 <rasen> Oh... Read "100 monads for managed resources" from url
11:33:30 <Yuras> AFAIK rust enforces that the resource will not go out of the region
11:33:31 <jophish_> Yuras: this thread pointed me in that direction: http://www.reddit.com/r/haskell/comments/orh4f/combining_regions_and_iteratees/c3jgyy2
11:33:43 <jophish_> johnw: I'll take a look, thanks
11:34:16 <linman32> hi, have problem with aeson. when extracting json variable, it returns Nothing
11:34:17 <linman32> http://lpaste.net/119701
11:35:01 <Yuras> jophish_: I like dynamic regions: https://github.com/Yuras/io-region
11:36:18 <linman32> using parseMaybe function
11:36:44 <cmccann> linman32: that means the parse failed, doesn't it?
11:37:31 <cmccann> linman32: use parseEither if you want to see the error message
11:38:00 <linman32> yes, this is true. the json is just a single key-value.. ok will give that a try
11:40:16 <linman32> cmccann: that helped thanks
11:40:22 <cmccann> linman32: no prob
11:42:00 <EvanR> yurg, >>= has lower precedence than <*> so i cant do  Foo <$> a >>= b <*> c >>= d <*> ...
11:43:04 <rasen> EvanR: you can. Indeed, I did this a second ago, but the meaning was different
11:43:19 <cmccann> EvanR: are you sure that would do what you want anyway? that seems kind of suspicious if you were expecting (=<<) to have lower fixity
11:43:38 <cmccann> er, (>>=)
11:44:08 <cmccann> and also confusing because (>>=) is argument-function while (<*>) is function-argument
11:44:35 * hackagebot Treiber 0.0.4 - Lock free Treiber stack  http://hackage.haskell.org/package/Treiber-0.0.4 (julek)
11:44:52 <EvanR> a >>= b and c >>= d above arent functions, they are m a's
11:44:56 <EvanR> Foo is the function
11:45:17 <EvanR> b and d are functions
11:45:38 <cmccann> ok
11:45:51 <EvanR> if you read it correctly according to defined precedence, yeah, it makes no sense ;)
11:46:16 <cmccann> personally I'd use (=<<), not that that helps with the fixity
11:46:53 * EvanR uses parentheses or repeats variables
11:46:59 * EvanR with do notation
11:47:19 <cmccann> a pure version would be written "Foo (b a) (d c)" so I like to keep the same structure
11:47:44 <cmccann> so Foo <$> (b =<< a) <*> (d =<< c) ... seems most readable to me
11:47:57 <EvanR> makes sense
11:48:10 <EvanR> :t (=<<)
11:48:11 <lambdabot> Monad m => (a -> m b) -> m a -> m b
11:48:20 <EvanR> kind of like Monad application
11:48:26 <cmccann> exactly like that
11:48:47 <cmccann> compare it to to the type of <$> or <*> and you can see the parallel
11:48:54 <EvanR> the function uses its little grabber to grab the argument
11:48:54 <cmccann> :t (<*>)
11:48:55 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:49:01 <cmccann> :t (<$>)
11:49:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:49:42 <cmccann> my utility library also has a function (=<*) but nobody else likes it :[
11:49:53 <cmccann> :t (\f x -> join $ f <*> x)
11:49:54 <lambdabot> (Applicative m, Monad m) => m (a1 -> m a) -> m a1 -> m a
11:50:26 <EvanR> that actually solves my next issue of how to write argument >>= fmap f action
11:50:37 <EvanR> f <$> action =<< argument
11:51:09 <EvanR> (hopefully)
11:51:11 <cmccann> so I can write stuff like "action <$> foo <*> bar =<* baz" when action has a type like a -> b -> m c
11:52:06 * EvanR rewrites all his monadic code ever
11:52:27 <aaronj1335> cmccann so is it possible to make like `Map * v` an instance of Functor? so that you're like mapping over the keys instead of the values?
11:52:42 <aaronj1335> (and no i have no idea why u would do this)
11:53:02 <EvanR> aaronj1335: theres an Ord constraint on the keys...
11:53:04 <cmccann> aaronj1335: consider that "Map a ()" is equivalent to "Set a"
11:53:13 <cmccann> and look at whether Set has a Functor instance
11:53:25 <cmccann> and/or try writing one and see what happens
11:53:41 <aaronj1335> k brb
11:54:03 <linman32> cmccann: it says "when expecting a (), encountered String instead"
11:54:23 <linman32> cmccann: why would it expect ()?
11:54:33 <cmccann> ??? I'm not sure what you were doing to get that message.
11:54:58 <linman32> cmccann: http://lpaste.net/119701
11:55:05 <enthropy> with uu-parsinglib is there some better way to track down the reason for ambiguity "uncaught exception: ErrorCall (ambiguous parser?)" than cutting out parts of my parser?
11:55:11 <rasen> d
11:55:25 <cmccann> linman32: ah right
11:57:06 <linman32> cmccann: what?
11:57:15 <cmccann> linman32: eh I'm afraid I'm not familiar enough with aeson to really help :T
11:57:37 <EvanR> using Foo <$> x <*> y <*> z is awesome to construct something from IO actions... now i dont have to go renaming field names in multiple places
11:58:05 <EvanR> tutorials dont emphasize the fact that IO is applicative
11:58:35 <ab9rf> EvanR: of course it's applicative
11:58:37 <linman32> cmccann: ok, understand. appreciate help
11:58:42 <ab9rf> EvanR: i suppose that isn't obvious to a newbie
11:59:24 <cmccann> ab9rf: especially with the superclass constraint nonsense we're FINALLY getting fixed
11:59:52 <ab9rf> i realized that monads were applicative prety much as soon as i knew that there was a thing called "applicative"
11:59:54 <cmccann> which meant that a Monad constraint alone wouldn't let you use <$> and <*>
12:00:17 <ezrios> what exactly do applicatives lack that monads have?
12:00:35 <cmccann> ab9rf: the funny thing is that the category theoretical abstract nonsense they're based on is almost entirely unrelated, they just happen to overlap in how they're used in Haskell
12:00:44 <cmccann> ezrios: join
12:01:00 <Zekka> cmccann: It is?
12:01:14 <ab9rf> cmccann: since i don't really understand the category theory nonsense anyway, i suppose that's a good thing :)
12:01:28 <ezrios> cmccann: what are the implications of not having join
12:01:35 <ezrios> you can't "flatten" a nested applicative
12:01:41 <ezrios> I guess
12:01:56 <cmccann> ezrios: correct, but that actually means a great deal
12:02:20 <cmccann> it means that the "structure" of an Applicative computation can't depend on the values in it
12:02:50 <ezrios> hm, I see
12:02:52 <cmccann> e.g. you can use the Monad instance on lists to write filter; with Applicative, the length of the result list depends entirely on the length of the input lists
12:03:21 <cmccann> you can write a conditional function like ifM :: (Monad m) => m Bool -> m a -> m a -> m a
12:03:38 <cmccann> you could write something with the equivalent signature for Applicative, but you'd get the "effects" from both branches
12:04:14 <ab9rf> http://stackoverflow.com/questions/23342184/difference-between-monad-and-applicative-in-haskell
12:04:22 <cmccann> ezrios: Applicative can also be implemented more efficiently, such as the "other" list monad
12:04:40 <ezrios> ok, I think I see what Edward Kmett (I think?) was talking about when he said "Applicatives are like Monads without conditional execution based on the results of monadic computations" (paraphrased terribly)
12:04:50 <cmccann> (which is only valid on fixed-length, including always-infinite, lists)
12:05:16 <cmccann> ezrios: yes, exactly
12:06:00 <cmccann> ab9rf: here, read this: http://cstheory.stackexchange.com/questions/16241/is-there-a-concept-of-something-like-co-applicative-functors-sitting-between-com/16264#16264
12:06:47 <EvanR> cmccann: the other list monad?
12:07:00 <cmccann> EvanR: a.k.a. ZipList
12:07:24 <EvanR> is that an alternative monad instance for list?
12:07:30 <maxade> are there decent openssl bindings in haskell
12:07:31 <cmccann> on fixed-length lists you can write a valid Monad instance for it
12:07:37 <EvanR> oh
12:07:47 <maxade> anyone who have an estimate on the size of the haskell community?
12:07:50 <cmccann> infinite streams also work, being obviously "equal" in length
12:08:45 <sdegutis> What editor do you use for Haskell?
12:09:05 <cmccann> Zekka: er, sorry, what "it" where you asking about that possibly "is" something
12:09:05 <ezrios> vim
12:09:08 <rasen> sdegutis: vim
12:09:13 <sdegutis> bitemyapp: why in the world am I banned from #haskell-beginners>
12:09:18 * cmccann uses SciTE
12:09:27 <sdegutis> ezrios, rasen: thanks I'll try vim
12:09:39 <ezrios> sdegutis: ooh, if you've never used vim I wouldn't suggest learning it just for Haskell
12:09:42 <ezrios> maybe sublime
12:09:45 <sdegutis> ezrios: no I know vim
12:09:48 <ezrios> ok
12:09:54 <sdegutis> I just use emacs for most things, but haskell-mode is just so weird for it
12:09:58 <Zekka> cmccann: Are monads/applicatives basically unrelated from a category theoretic standpoint?
12:10:01 <owa> or notepad++
12:10:07 <cmccann> Zekka: oh
12:10:10 <Zekka> This is a legit question to be clear, not me trying to be pedantic
12:10:19 <sdegutis> I like vim-mode's indentation a lot better so far.
12:10:20 <cmccann> Zekka: see that link I gave ab9rf
12:10:23 <sdegutis> I mean vim's
12:10:26 <Zekka> cmccann: I'll look
12:11:26 <maxade> Anyway, I don't see the point of Haskell. Cobol has served me well for the last 20 years.
12:11:36 <cmccann> maxade: troll less obviously plz
12:11:42 <spindles_> I have a question on module hierchy if that's ok?
12:12:38 <rasen> spindles_: sure
12:12:55 <sdegutis> For the record this channel has been vastly more helpful to me as a Haskell beginner than #haskell-beginners, which I'm apparently banned from now I guess.
12:13:02 <sdegutis> So, thanks yall.
12:13:08 <EvanR> lol
12:13:09 <t4nk072> when attempting to install the haskell platform on OpenBSD i run into the following: http://pastebin.com/eDn1C5zw
12:13:16 <spindles_> so from what's I've been reading, generally, value constructors are not exported, instead export functions to make specific branch of a data type
12:13:26 <spindles_> for encapsulation purposes
12:13:33 <ezrios> sdegutis: this channel is quite helpful, pretty sure we have people at all levels of Haskell here
12:13:34 <sdegutis> That channel is run like a very strange dictatorship and it's really off-putting.
12:13:40 <sdegutis> ezrios: :)
12:13:44 <cmccann> spindles_: exporting constructors is very common, actually
12:13:51 <sdegutis> So, no that I've learned what monads are, what's the next step in becoming a Haskell expert?
12:13:59 <cmccann> spindles_: the only exception is if your type requires complicated internal invariants to be useful
12:14:01 <Xe> sdegutis: writing something useful
12:14:07 <cmccann> sdegutis: write lots of code
12:14:13 <ezrios> sdegutis: personally I used to just write a bunch of Haskell katas/code challenges
12:14:15 <sdegutis> ok, ill port my osx window manager to it
12:14:20 <ezrios> recently I implemented a chess AI in Haskell
12:14:27 <spindles_> recently, I learned that you can also export modules, so you can do some kind of Foo.Bar, but it would export a Foo.Bar.Extension with extra things you dont want to stuff into Foo.Bar
12:14:50 <cmccann> sdegutis: weren't you messing with FFI stuff? if you're not scared of monads and know how to use the FFI you can probably tackle anything
12:14:53 <rasen> sdegutis: http://stackoverflow.com/a/1016986/2538771
12:15:16 <sdegutis> cmccann: yep: https://github.com/sdegutis/servum/blob/master/Main.hs
12:15:24 <ezrios> sdegutis: rasen's link is great
12:15:25 <sdegutis> oh sorry I refactord it out:  https://github.com/sdegutis/servum/blob/master/Lua.hs
12:15:28 <EvanR> confused by this, after running hsc2hs on my hsc file, then trying to ghc -c the hs file, it gives an error in the hsc file
12:15:29 <sdegutis> will look
12:15:38 <ezrios> pretty sure this is what I used as a rough guide as well
12:15:53 <EvanR> naked expression at top levell
12:15:55 <spindles_> so Foo.Bar.Extension here would imports Foo.Bar for the extra things, but Foo.Bar also import and export back Foo.Bar.Extension correct?
12:15:59 <sdegutis> okay, trying http://tonymorris.github.io/blog//posts/20-intermediate-haskell-exercises/
12:16:44 <spindles_> so my question is if there is a way so that constructors in Foo.Bar can be available in Foo.Bar.Extension, but not outside of say Foo.Baz, kinda like "protected"
12:16:50 <ezrios> woo, coming back to this link it looks like I've come a long way :D
12:17:29 <sdegutis> I think I have a terrible idea.
12:17:54 <cmccann> spindles_: generally what people do is have a Foo.Bar.Internal module or the like, which exports everything, then Foo.Bar selectively re-exports stuff
12:17:55 <sdegutis> I plan to embed a bunch of partially applied functions into a record-syntax-style data type, in order to emulate "methods".
12:18:01 <sdegutis> Would that be terrible?
12:18:18 <cmccann> sdegutis: no, that's the correct way to do something OOP-like in Haskell
12:18:24 <sdegutis> Awesome.
12:18:50 <sdegutis> Because I have a Lua virtual machine, and I'd hate to have to pass the VM into every function -- oh wait, I'd still need the VM object, it would just be reversing the call notation.
12:19:20 <sdegutis> Never mind, dumb idea :)
12:19:27 <cmccann> spindles_: that said, it's better to just export everything unless you have a compelling reason not to
12:20:10 <cmccann> sdegutis: it's fun to tinker with but it's not worth the hassle unless you're trying to do something that lends itself strongly to an OOP design
12:20:19 <sdegutis> gotcha
12:20:33 <spindles_> cmcann: there it is generally not a concern if Internal is too long/large
12:20:40 <cmccann> sdegutis: if you just want to have access to some value without passing it around manually, use an appropriate monad
12:20:45 <spindles_> then?
12:21:00 <cmccann> spindles_: long/large in what sense?
12:21:08 <raek> sdegutis: you may find interesting topics to explore here too: http://stackoverflow.com/questions/3077866/large-scale-design-in-haskell
12:21:12 <sdegutis> cmccann: hm, monads might make the Lua API cool -- but I don't think I understand *how* to design this just yet
12:21:38 <sdegutis> for now I just plan to mirror the C functions with similar Haskell functions, figuring that'll be good enough
12:21:51 <t4nk072> when attempting to install the haskell platform on OpenBSD i run into the following: http://pastebin.com/eDn1C5zw
12:22:10 <spindles_> cmccann: long large as in too many functions or things to do with the data
12:22:14 <c_wraith> sdegutis: monads are painful to use without simple syntax for first-class functions
12:22:27 <sdegutis> c_wraith: which we have in Haskell
12:23:16 <cmccann> sdegutis: what type is it you want to pass around implicitly, LuaState?
12:23:24 <sdegutis> cmccann: yep
12:23:41 <cmccann> because from the look of it all you'd need there is something like ReaderT IO
12:23:52 <sdegutis> okay
12:24:07 <bitemyapp> sdegutis: you were banned because you were being disruptive and have a long history of being so.
12:24:07 <rasen> sdegutis: you can use ReaderT for that
12:24:25 <sdegutis> bitemyapp: heh, you haven't changed a bit.
12:24:27 <rasen> sdegutis: and create a couple of wrappers that will pass lus_State to functions
12:24:28 <bitemyapp> sdegutis: you are banned from many IRC channels and somebody from a non-FP IRC community privmsg'd me after your little outburst.
12:24:30 <spindles_> cmccamm: I guess my concern is that i dont want Foo.Bar to have too many things, so i want Foo.Bar.This, Foo.Bar.That, and have Foo.Bar reexport them, but the data definition is located in Foo.Bar. Or is the backward way of doing thing?
12:24:39 <sdegutis> bitemyapp: I had an outburst?
12:24:44 <bitemyapp> sdegutis: you have been trolling different communities on Freenode for *years* and nobody has been able to get you to behave.
12:24:56 <sdegutis> bitemyapp: I'm sorry buddy, but you're not only misinformed, but now on my ignore list
12:25:10 <sdegutis> (if I can figure out how to do it in Limechat)
12:25:31 <sdegutis> cmccann, rasen: thanks, looking into ReaderT
12:25:47 <cmccann> spindles_: generally you want your types defined in a module with few imports, that everything else can import
12:27:10 <cmccann> sdegutis: a type like "a -> b -> ReaderT LuaState IO c" is equivalent to "a -> b -> LuaState -> IO c"
12:27:16 <sdegutis> bitemyapp: you should be careful not to take too seriously what trolls on IRC with grudges will tell you. those people are just trying to pick a fight, and they suckered you.
12:27:34 <sdegutis> cmccann: wow that's one heckova type
12:27:38 <spindles_> cmccann: so importing Internal is normal / well accepted?
12:27:57 <sdegutis> cmccann: that looks exactly like what I want, thanks :)
12:28:05 <cmccann> spindles_: I'd recommend looking at some actual libraries to see what they do. there are multiple approaches.
12:28:22 <spindles_> cmccann: Thanks!
12:31:11 <dmwit> glguy: Well, I see the InstallDirs data structure in Distribution.Simple.InstallDirs. But I can't see a way to get my hands on one.
12:31:35 <glguy> dmwit: That's why I feel about most of the types I want from those modules :)
12:31:50 <cmccann> dmwit: smash the window, grab it, and run before the cops arrive?
12:31:57 <dmwit> hehehe
12:34:21 <dmwit> glguy: I was sort of thinking you might do something wacky like make a Setup.hs that prints... something? somehow? and ask "cabal configure" what it thinks of that.
12:34:29 <dmwit> But I've never really made a custom Setup.hs before.
12:34:41 <dmwit> And it seems like kind of a hack.
12:35:15 <glguy> dmwit: It's not *too* bad, there's a default main that you can modify in the smallest way
12:35:23 <sdegutis> Haskell is definitely the hardest language I've learned to date.
12:35:34 <Xe> it's not hard more of different
12:35:39 <glguy> dmwit: I bet if we ask someone who knows how this works there's a perfectly reasonable simple way to get one of these structures
12:35:41 <geekosaur> quick, someone teach sdegutis Agda :p
12:35:46 <sdegutis> Xeironis: I'd say it's also hard ;)
12:35:52 <sdegutis> er, Xe
12:36:07 <Xe> sdegutis: it's only as hard as you make it
12:36:16 <zachk> everything is immutable and use Monads :D
12:36:24 <sdegutis> Yeah immutable is fine, coming from Clojure.
12:36:29 <sdegutis> But monads are really blowing my mind.
12:36:34 <Xe> yeah
12:36:36 <sdegutis> I'll do those exercises you all recommended.
12:36:42 <zachk> they still blow my mind
12:36:43 <cmccann> I think it's more that in Haskell it's harder to write code without knowing what you're doing
12:36:45 <sdegutis> Maybe that'll help me understand monads better.
12:37:19 <cmccann> I remember tutoring college students learning C++ and believe me it was too hard for most of them. that didn't stop them from writing programs, though.
12:37:23 <sdegutis> It seems that writing clean Haskell code requires knowing how to write monads.
12:37:36 <sdegutis> cmccann: lol true
12:37:44 <rasen> sdegutis: it requires knowing how to *use* them
12:38:02 <sdegutis> rasen: I think I know how to use monads like IO and Maybe and []
12:38:13 <zachk> sdegutis, do you understand (>>=) and do notation blocks, yet?
12:38:14 <raek> somewhat off-topic: in lexical analysis, is there a word for both operators (such as +, -, *) and punctuators (such as {, }, ;)?
12:38:20 <sdegutis> zachk: yep, that part I fully get.
12:38:31 <rasen> sdegutis: but there're lot more monads. And all they are different
12:38:50 <zachk> raek, paired brackets?
12:38:53 <dmwit> glguy: Well, I mean, it really is a pretty bad hack, because it wouldn't work cleanly with packages that actually do use Cabal's features.
12:39:13 <glguy> dmwit: Oh, I thought you were trying to do it for a particular package
12:39:20 <sdegutis> What does this "forall" mean in the documentation for >>= ?
12:39:21 <glguy> dmwit: You mean you want it as a general tool?
12:39:27 <dmwit> glguy: (Eventually I want to just type "documentation" and have the appropriate index.html open in my browser...)
12:39:30 <dmwit> glguy: yeah
12:39:52 <rasen> sdegutis: http://two-wrongs.com/the-what-are-monads-fallacy
12:40:12 <sdegutis> rasen: thanks reading
12:40:57 <raek> zachk: some background: I'm writing a lexer for C and the C standard lists characters that are operators and punctuators. many characters belong to both sets, so I'm looking for a word that covers both operators and punctuators
12:41:18 <cmccann> sdegutis: forall introduces type variables. usually it's implicit, a type like "a -> b" really means "forall a b. a -> b"
12:41:25 <raek> operators: [ ] ( ) . -> ++ -- & * + - ~ ! etc
12:41:26 <sdegutis> oh I see
12:41:28 <sdegutis> cmccann: thanks
12:41:45 <raek> punctuators: [ ] ( ) { } * , : = ; ... #
12:41:53 <cmccann> sdegutis: it means that you can fill in any type ("for all types...") you want into those variables
12:41:53 <Xe> can I define a custom operator called :^) in haskell?
12:42:07 <sdegutis> xe: lol
12:42:08 <cmccann> Xe: no, ) can't be part of an operator
12:42:09 <sdegutis> cmccann: right
12:42:14 <rasen> Xe: yes
12:42:15 <Xe> damn
12:42:24 <raek> also, the colon means it is an infix data constructor, right?
12:42:25 <sdegutis> :^ works tho I think
12:42:31 <dmwit> For a single package, it seems like the postConf UserHook is what I want.
12:42:35 <rasen> Xe: sorry, it'll be constructor
12:42:38 <sdegutis> :^| probably does too
12:42:39 <geekosaur> raek: symbol characters?
12:43:11 <Xe> :^>
12:43:36 <dmwit> ?let data Happy a = a :^> a
12:43:38 <lambdabot>  Defined.
12:43:47 <dmwit> :t (^) :^> (^)
12:43:47 <lambdabot> (Num a, Integral b) => Happy (a -> b -> a)
12:43:56 <sdegutis> `` Attempting to learn how to use monads by understanding what they are is like asking "What is a musical instrument?" and then assuming once you know the answer to that, you'll be able to play all of the musical instruments. ''
12:43:59 <raek> geekosaur: that's good. but the word "symbol" often mean something like "identifier" in compiler theory, though...
12:44:31 <raek> naming things is always one of the hardest activities of programming
12:44:35 <geekosaur> there is that. I think in Haskell the definition from Unicode trumps though
12:45:03 <geekosaur> (in particular the definition of "operator" leans heavily on the Unicode "symbol" class)
12:45:35 <raek> hmm. you have a point
12:45:35 <geekosaur> but that is why I said "symbol character" and not just "symbol"
12:45:44 <griotspeak> hello
12:45:58 <griotspeak> I am having trouble installing CCA
12:46:00 <griotspeak> https://gist.github.com/griotspeak/fd58275c6eb2290e08ef
12:46:30 <griotspeak> might someone have a suggestion? I am not well versed in Haskell or the install process
12:47:18 <dmwit> At a guess: cca was written for an older compiler than you have. Or newer.
12:47:22 <geekosaur> I think that means you have both outdated cabal-install and outdated happy
12:47:47 <geekosaur> (cbaal-install can't check versions of executables because they don't register libraries)
12:47:55 <maxade> Can I invent my own syntax in haskell?
12:47:56 <cmccann> so does hackage, apparently: http://hackage.haskell.org/package/CCA-0.1.5.1/reports/1
12:48:11 <maxade> for DSLs
12:48:17 <geekosaur> maxade: not in standard haskell or ghc. you might look for "liquid haskell" though
12:48:17 <dmwit> maxade: To a certain extent. If you want something really wacky, you'll need to design a DSL rather than an EDSL.
12:48:29 <griotspeak> geekosaur using version 1.20.0.1 of the Cabal library
12:48:30 <rasen> maxade: internal or external DSL?
12:48:37 <geekosaur> DSLs, using the standard Haskell syntax, are certainly possible, but you can't e.g. define a new kind of bracket
12:48:38 <dmwit> maxade: There are several good libraries and tools for writing parsers.
12:48:53 <dmwit> maxade: See also quasiquoters.
12:49:00 <geekosaur> griotspeak, that is why I said "cabal-install". Cabal library is something else, and predates cabal-install by a long time
12:49:14 <rasen> yep. quasiquoters are nice
12:49:15 <geekosaur> but all the warninsg about unknown keywords are from cabal-install (the "cabal" executable)
12:49:49 <griotspeak> ok
12:50:20 <geekosaur> and the fact that you have those suggests to me that your happy is also out of date, since generally you get happy and cabal-install from the same place
12:51:00 <sdegutis> Okay, I'm confident that I understand the ReaderT monad now.
12:51:04 <sdegutis> Just need to use it to get a feel for it.
12:51:31 <dmwit> Excellent. Please explain ReaderT r (Cont r') a to me, please.
12:51:33 <maxade> dmwit: parsing -> external dsl? what is internal dsl? just a library?
12:51:55 <dmwit> maxade: re: "what is internal dsl? just a library?" yes =)
12:52:07 <dmwit> maxade: Though most people aren't so honest about it.
12:52:30 <cmccann> dmwit: that's a trick question, nobody understands ContT :P
12:52:35 <sdegutis> dmwit: lol no idea
12:52:43 <sdegutis> dmwit: what's Cont?
12:52:50 * dmwit shrugs in confusion
12:52:55 <sdegutis> oh, Continuation
12:53:01 <tomphreek> > concat (map (\flg -> (concat (map (\ys -> return (if flg then 0:ys else ys)) [[1], []]))) [True, False])
12:53:03 <lambdabot>  [[0,1],[0],[1],[]]
12:53:33 <tomphreek> finally got round finishing working through an explicit example of a powerset through filterM anyway
12:53:38 <geekosaur> the Cont monad will definitely stretch your mind. (not to say twist it into a pretzel)
12:53:44 <athan> lol
12:55:43 <raek> maxade: This article explores some approaches to implementing DSLs in Haskell: http://queue.acm.org/detail.cfm?id=2617811
12:55:47 <sdegutis> Is Cont anything like call/cc in Scheme?
12:55:53 <geekosaur> yes
12:56:00 <sdegutis> Okay. Staying far away from Cont.
12:56:53 <griotspeak> forgot to thank you geekosaur! (not sure if that worked yet, but thanks either way)
12:57:05 <geekosaur> ...the scariest part is that it's deceptively simple in its implementation, not requiring any special language support at all
12:57:19 <cmccann> sdegutis: http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Cont.html#v:callCC
12:58:01 <sdegutis> wow
12:58:14 <geekosaur> (I have to relearn how it works every so often since I never seem to have any reason to use it...)
12:58:35 <sdegutis> It's great for building exceptions, but I don't see any practical use for it in normal applications.
12:59:16 <zachk> sdequtis, try wrapping ReaderT around the IO monad for immutable environment variables
12:59:17 <raek> do pipes and conduit use ContT under the hood?
12:59:34 <sdegutis> hmm
13:00:00 <rasen> sdegutis: lua_State is your immutable environment
13:00:11 <sdegutis> rasen: yeah thats what I planned to use it with
13:00:22 <sdegutis> but I'm still looking around a sample usage of it
13:00:23 <sdegutis> *for
13:00:55 <rasen> I can show you how I used StateT
13:01:05 <sdegutis> I think that'll just confuse me more right now :)
13:01:07 <sdegutis> but thanks anyway
13:02:48 <TTimo> hello. I'd like to use the following package: http://hackage.haskell.org/package/random-shuffle-0.0.3/docs/System-Random-Shuffle.html
13:02:58 <TTimo> I thought I could do 'cabal install random-shuffle'
13:03:04 <TTimo> but that doesn't work ?
13:03:15 <rasen> sdegutis: https://github.com/rasendubi/htorrent/blob/master/src/Network/BitTorrent/Tracker/UDP.hs
13:03:43 <rasen> sdegutis: line 169: I'm creating a StateT TrackState IO to mix State monad and IO
13:03:45 <geekosaur> TTimo, "doesn't work" how?
13:03:48 <sdegutis> I think I came up with a good way to practice using and understanding the ReaderT example:  I'll wrap an Int in it, and continually take a number from the user, each time printing the result of adding the wrapped number to the one the user gave
13:03:52 <geekosaur> also I note that is not the most recent version
13:03:54 <TTimo> aaand it just did work
13:04:08 <TTimo> outdated list, apparently this is a very recent package
13:04:11 <TTimo> ty ty :)
13:05:12 <dmwit> sdegutis: Sounds like a handy exercise to me.
13:05:13 <zachk> sdegutis, StateT would be better for that
13:05:17 <griotspeak> Updating cabal-install eliminated the 'unrecognized field' errors but not the template problem
13:05:19 <sdegutis> zachk: :(
13:05:32 <sdegutis> zachk: no no, I don't plan on mutating the one I started with
13:05:35 <geekosaur> right, that's where you need to upgrade happy most likely
13:05:37 <griotspeak> I'm using happy Happy Version 1.19.5
13:05:39 <sdegutis> zachk: that one remains (e.g. 3)
13:05:39 <geekosaur> what version of ghc is this?
13:05:50 <zachk> try reading in a configuration file and using a record for it, and then passing that into a ReaderT IO thingie
13:06:29 <griotspeak> https://gist.github.com/griotspeak/fd58275c6eb2290e08ef
13:06:59 <geekosaur> actually... so that is the most recent version of happy. maybe it requires an older one, since it's poking in ghc internals
13:08:09 <geekosaur> and I see the hackage page reports build errors for the CCA package anyway
13:08:55 <geekosaur> at this point I'd suggest contacting the maintainer of cca
13:08:56 <dmwit> zachk: Say his configuration file contains an Int. Now you're back at his proposed exercise.
13:09:25 <geekosaur> http://hackage.haskell.org/package/CCA suggests poking around https://github.com/ninegua/CCA
13:09:34 <zachk> mmm, rarely use transformers myself
13:11:21 <rasen> zachk: today is the first time I use them for real (about 3 months using Haskell)
13:13:09 <zachk> rasen, which one(s) are you using?
13:13:12 <griotspeak> ok thanks
13:13:14 <athan> rasen: The important thing to remember is that the transformer's type is unified throughout the whole monad expression
13:13:23 <athan> so things like Lucid templates can be hairy
13:13:26 <athan> (or yesod)
13:13:27 <rasen> StateT + IO
13:14:22 <TTimo> what's the recommended way to ask a question or report a bug about a hackage package ?
13:14:37 <zachk> emailing the maintainer???
13:15:23 <phaazon> hm
13:15:27 <dmwit> zachk++
13:16:04 <dmwit> Unless the package's homepage mentions a bug tracker (esp. github).
13:18:06 <spindles_> exit
13:19:19 <sdegutis> I'm having trouble importing Control.Monad.Reader so I can use ReaderT
13:19:24 <sdegutis> is this package moved?
13:19:58 * zachk thinks it is contained in Base
13:20:00 <dmwit> Show us the code and error.
13:20:02 <dmwit> It is not in base.
13:20:04 <systemfault> sdegutis: You probably need the mtl and/or transformer package, no?
13:20:09 <systemfault> *transformers
13:20:15 <sdegutis> Probably.
13:20:22 <systemfault> hoogle is your friend.
13:20:23 <sdegutis> I've only ever installed Hspec, nothing else.
13:20:51 <systemfault> https://www.haskell.org/hoogle/?hoogle=ReaderT :)
13:21:17 <sdegutis> But it's weird that ReaderT shows up in Dash if it's not built-in -- I don't think I've ever seen this happen before.
13:21:28 <sdegutis> But I guess so.
13:22:29 <dmwit> What does "built-in" mean?
13:22:40 <sx> Is someone interested in a new haskell record syntax, which extends the typesystem by anonymous records without breaking any existing code? Because I had some ideas, and would love to get some feedback on it (and sorry for my english, I'm not a native speaker).  http://lpaste.net/7617479633121837056
13:23:20 <dmwit> Yet Another Record Proposal
13:23:39 <sx> dmwit: Yes it is getting out of control. :)
13:24:16 <sdegutis> dmwit: comes with the thing
13:24:21 <sdegutis> welp, I can't wrap my head around this today
13:24:28 <sdegutis> (this = ReaderT)
13:24:30 <sdegutis> will try again another day
13:25:01 <dmwit> What is the thing?
13:25:25 <dmwit> mtl comes with some things and not others.
13:26:44 <dmwit> And it's not clear to me what the connection between "comes with the thing" and "appears in Dash" is.
13:28:29 <enthropy> sx: use HList already
13:28:36 <enthropy> (somewhat joking)
13:29:51 <rasen> How to call files that are placed on disk when you're downloading torrent. Need a name for module
13:30:10 <sx> enthropy: I actually never needede anonymous records, I just hate functions which are not total. I did it because it was fun wrapping my head arround it.
13:30:47 <rasen> sorry, that was a question
13:30:51 <systemfault> sdegutis: Monad Transformers are not easy to grasp... it personally took me a lot of time.
13:31:05 <dmwit> There are only two hard problems in computer science: cache coherency, and naming things.
13:31:10 <dmwit> Off-by-one errors show up sometimes, too.
13:31:24 <athan> don't forget non-unifying kinds
13:31:34 <athan> :(
13:31:48 <sx> systemfault: It's actually not that complicated once you get monads, just an adapter.
13:32:25 <systemfault> sx: I got that the first minute I learned about them..... Getting some intuition is what took me time.
13:32:33 <dmwit> rasen: How about "fragments" or something like that.
13:32:53 <systemfault> sx: The whole when/how to use them.
13:33:03 <dmwit> when: always
13:33:11 <rasen> dmwit: I'd like have name for the whole "thing"
13:33:11 <exio4> it's (somewhat) monad composition!
13:33:18 <Lokathor> is there a file that ghci will read every time it starts up and execute lines from before waiting for user input? Something like a .bashrc, but for ghci
13:33:39 <eraker> typically: ~/.ghc/ghci.conf
13:33:40 <dmwit> .ghci
13:33:46 <zachk> yep
13:33:49 <dmwit> It will look in the current directory, then ~
13:34:11 <systemfault> Yo dawg.. I herd u liek monadz so I put a monadz inside ur monadz so u can lift while lifting
13:34:15 <Lokathor> ah, my ~/.ghc has no ghci.conf, which is where i got lost
13:34:16 <sx> systemfault: Well, considering the amount of haskell blog posts about uses of monad transformers, people find new uses all the time. ;)
13:34:42 <kadoban> Lokathor: Lots of confs aren't created unless you want them. Most unixy tools will just use default settings if they don't exist.
13:35:00 <rasen> kadoban: or system-wide settings
13:35:05 <zachk> wouldn't a person get really "Buff" if they lifted, whilst lifting?
13:35:13 <Lokathor> kadoban, yes i always find that troubling myself
13:35:51 <systemfault> zachk: It would get buffed . buffed :/
13:36:35 <Lokathor> maybe you can use parMap to distribute the buffing across multiple cores
13:44:02 <jophish_> I'm having some trouble calling a dll on Windows. I've created a small testcase here: Could someone else with a windows box try and run this, please? (Just clone build.sh and run)
13:44:02 <jophish_> https://github.com/expipiplus1/simple-shared
13:46:18 <bms1> I am getting some strange behavior from type families
13:46:20 <bms1> http://lpaste.net/119711
13:46:38 <bms1> That error does not make any sense to me
13:48:27 <Fuco> @pl \_ -> do { return () }
13:48:27 <lambdabot> (line 1, column 10):
13:48:27 <lambdabot> unexpected '{'
13:48:27 <lambdabot> expecting variable, "(", operator or end of input
13:48:53 <Fuco> hm... how can I write that? ^ I need MaybeT m a -> m ()
13:49:38 <bms1> :t runMaybeT
13:49:39 <lambdabot> Not in scope: ‘runMaybeT’
13:50:03 <benzrf> Fuco: why are you using do
13:50:04 <Fuco> ah, void . runMaybeT
13:50:14 <benzrf> :t return ()
13:50:15 <lambdabot> Monad m => m ()
13:50:21 <geekosaur> that's just @pl being limited in parsing, you generally have to desugar do into >>= etc. with @pl
13:50:31 <Fuco> benzrf: because it's inside MaybeT, I need to run into the `m'
13:50:33 <geekosaur> but in this case the do isn't doing anything
13:50:42 <geekosaur> do { return () } is return ()
13:50:43 <Fuco> hm, okeythen
13:50:43 <benzrf> Fuco: wat
13:50:48 <csd_`> What's the easiest way for a Haskell newb to insert the equivalent of printlns to watch code execute?
13:50:54 <geekosaur> @undo do { return () }
13:50:54 <lambdabot> return ()
13:50:59 <benzrf> csd_`: use the repl
13:51:06 <benzrf> csd_`: evaluate subexprs
13:51:22 <csd_`> i want my recursive function to print what the args are as its being called
13:51:33 <geekosaur> Debug.Trace?
13:51:37 <benzrf> geekosaur: :[
13:51:48 <jmcarthur> i think Debug.Trace is fine
13:51:56 <EvanR> how else would you do it
13:52:03 <benzrf> EvanR: y-you SHOULDNT
13:52:05 <fread2282> csd_`: Debug.Trace.trace , but be careful and remove it after you've fixed the bug. also repl breakpoints
13:52:08 <jmcarthur> benzrf: why?
13:52:10 <geekosaur> those kidns of recursive calls are one of the places where it's somewhat useful
13:52:18 <benzrf> jmcarthur: umm
13:52:33 <csd_`> ok
13:52:45 <EvanR> benzrf: for sufficiently complex recursion, its hard to understand whats going on, especially if its not working (frozen, uninformative crashing)
13:53:21 <jmcarthur> benzrf: in general, i don't find it worth using IO to debug functions that otherwise don't need IO
13:53:27 <fread2282> traceShowId is the most useful trace variant.  fn a = traceShowId a $ functionBody
13:53:32 <agocorona> debug= flip trace       is better. It can be used  infix    :        something             `debug`  debuginfo
13:53:56 <fread2282> no that's wrong
13:54:14 <csd_`> OK so how would i wrap Debug.Trace into the following https://www.refheap.com/96735 ?
13:54:18 <bms1> Can anyone explain the GHC error in my code? http://lpaste.net/119711
13:54:27 <koomi> I really like hood for debugging recursive functions
13:54:57 <csd_`> would i add the trace call to the recursions in lines 5 and 6?
13:55:08 <EvanR> koomi: cool
13:55:34 <fread2282> csd_`: you could replace a with traceShowId a in the recursive call (same with b)
13:55:40 <dmwit> bms1: wow, cool error
13:55:59 <bms1> dmwit: I was quite surprised!
13:56:13 <jmcarthur> fread2282: that will be confusing unless the function immediately evaluates them
13:56:14 <dmwit> bms1: I would be tempted to file a bug on the Trac, especially if this is the most recent GHC.
13:56:23 <fread2282> jmcarthur:
13:56:26 <fread2282> whops
13:56:49 <bms1> dmwit: It's 7.8.3; which I assume is what you mean most recent?
13:56:56 <dmwit> bms1: Normally that error is the result of some kinds not matching up. But all your kinds are monomorphic here, so that's not what's happening.
13:56:57 <fread2282> true (it'll print in evaluation order), but it's still useful
13:57:09 <geekosaur> 7.8.4 is most recent release, 7.10rc2 most recent
13:57:24 <geekosaur> s/release/released version/
13:57:28 <jmcarthur> csd_`: i would do    traceShow (<stuff you want to show>) $ <rest of function>
13:57:38 <jmcarthur> csd_`: just at the very beginning of the function body
13:57:42 <bms1> dmwit: Is it possible that there is something called "Ord" other than with the kind * -> Constraint?
13:57:55 <glguy> bms1: You aren't supposed to be able to partially apply type families like that
13:58:07 <glguy> specifically:  Exp (Ord & Ord) Int
13:58:18 <csd_`>  within the helper function or the main function?
13:58:24 <csd_`> @jmcarthur
13:58:24 <lambdabot> Unknown command, try @list
13:58:36 <bms1> glguy: Oh
13:58:36 <glguy> (that's fixed in 7.10)
13:58:41 <dmwit> glguy: That's probably what's wrong; but even if so the error message reported could definitely use work.
13:58:47 <jmcarthur> csd_`: that depends on what you want it to show
13:58:47 <dmwit> aha
13:59:04 <jmcarthur> csd_`: if you only care about the helper function arguments, i'd do it in the helper function
13:59:37 <csd_`> jmcarthur, i'd like it to show how the helper is called, but i'm not sure how I'd stick the trace in as that seems like an imperative thing and not something that would work in haskell
14:00:07 <jmcarthur> csd_`: it will print whenever the result is demanded
14:00:14 <jmcarthur> or at least the first time
14:00:24 <jmcarthur> which is enough, since it will be a fresh application in each recursive call
14:00:39 <csd_`> ok
14:01:05 <fread2282> csd_`:  if you have some info that you can deduce the location w/ it might be useful to also trace that
14:01:20 <jmcarthur> csd_`: to be more clear...    (trace "foo" x) == x,  and when (trace "foo" x) is evaluated, "foo" is printed
14:01:33 <fread2282> usually i go w/o first then if it's confusing I go back and try to add something more
14:02:26 <csd_`> It seems like it's not playing nicely with the guards
14:03:48 <Haans> Can someone help explain which version is better? http://pastebin.com/DwR7zF4s
14:04:44 <jmcarthur> Haans: i think neither is substantially better than the other
14:04:48 <Haans> Learn You a Haskell seems to put end conditions at the start of functions, similar to Lisp. But with pattern matching is there a problem with mine?
14:04:59 <jmcarthur> Haans: yours is not wrong
14:05:11 <Haans> okay, thanks
14:05:44 <glguy> Haans: From GHC's point of view they are nearly identical, the difference is that the first is strict in the first argument
14:05:50 <glguy> second argument*
14:06:12 <jmcarthur> ah, there is that difference
14:06:36 <csd_`> , got it working thanks
14:06:44 <csd_`> gah, jmcarthur
14:07:39 <glguy> (strict in both but it tests them in different orders)
14:09:18 <jmcarthur> wouldn't being strict in both arguments mean that   (forall x. f x _|_ = _|_) && (forall x. f _|_ x = _|_)  ?
14:09:41 * hackagebot postgrest 0.2.5.1 - REST API for any Postgres database  http://hackage.haskell.org/package/postgrest-0.2.5.1 (begriffs)
14:10:56 <Haans> Is using stricter arguments preferred in open source software? Or is there no standard?
14:11:17 <jmcarthur> Haans: it depends.
14:11:26 <jmcarthur> a terrible answer, i know
14:13:01 <jmcarthur> it is better to make an argument strict when not doing so would incur a performance or space cost, but it is not always obvious whether this is so
14:13:38 <jmcarthur> making the wrong function strict can also hurt
14:13:53 <jmcarthur> it could even make the difference between your program terminating and not terminating
14:30:46 <EvanR> for the return type of the initialization action of a C lib via FFI, which either succeeds with no result or gives an error, IO (Either MyError ()) ?
14:30:53 <fresheyeball> @pl (\x -> f (show x) x)
14:30:54 <lambdabot> f =<< show
14:32:06 <fresheyeball> how the hell is that true
14:33:25 <EvanR> fresheyeball: well first, its the same as f (show x)
14:33:47 <EvanR> never mind that
14:33:53 <fresheyeball> there are no monads in this picture
14:33:55 <fresheyeball> haha
14:34:07 <laar> fresheyeball, look into ((->) e) as a monad
14:34:08 <tel> fresheyeball: functions are monads with `join f = \x -> f x x`
14:34:31 <tel> fresheyeball: return = const
14:34:32 <jascase901> I want to start using haskell as a shell replacement, what libraries should I look at and is this a bad idea?
14:34:48 <fresheyeball> mind = blown
14:35:01 <raek> EvanR: sounds resonable to me. as long as the other functions in your module use the same style of error management
14:35:08 <fresheyeball> so all functions are monads?
14:35:12 <tel> fresheyeball: It can be a little easier to recognize that `Reader e a` is the same as `e -> a`
14:35:15 <fresheyeball> or only functions that take one argument?
14:35:33 <Black0range> Hello ladies and gents, Wodning when appending two Lazy Texts (Data.Text.Lazy) is the result lazy or not?
14:35:33 <tel> fresheyeball: all functions take only one argument, so... "yes"
14:35:38 <raek> so that one can automate the error propagation with a monad or something
14:35:41 <EvilTerran> jascase901, I think shelly is a fairly well-established library for it: https://github.com/yesodweb/Shelly.hs
14:36:05 <jascase901> Thanks EvilTerran Ill check it out
14:36:07 <exio4> fresheyeball: remember, all functions take a single argument
14:36:20 <augur> any suggestions for parallelizing some List and Map heavy code?
14:36:30 <tel> fresheyeball: a type like `a -> b -> c` is the same as `Reader a (b -> c)`
14:36:39 <EvilTerran> jascase901, I wouldn't recommend using Haskell as a shell replacement unless you're already familiar with Haskell, mind - there's inevitably a lot of side-effects floating around in shell-script-like code, so it might encourage bad habits
14:36:44 <augur> especially where the code involves lots of uses of map?
14:37:05 <raek> fresheyeball: you can compose functions from a shared "environment" to anything
14:37:24 <jascase901> EvilTerran, Oh thanks for the warning. I was thinking about using it to help me learn haskell a bit better.
14:37:49 <EvilTerran> jascase901, see, the thing is... normally you should try to keep as much of your Haskell code pure as possible, but that might be difficult if you're writing the sort of thing you'd normally do a shell script for
14:37:53 <raek> fresheyeball: so if you have a bunch of funtions with type "e -> a", "e -> b", "e -> c" you can use them in the same do block and make the monad apply the e argument behind the scenes
14:38:08 <sdegutis> dmwit: Dash is a documentation app that usually only shows the standard library that comes with a language
14:38:12 <fr33domlover> Hello! Are there any conventions for writing a parser? I see some packages named lannguage-<langname> and they're all under the Language module, but I didn't find info about it
14:38:18 <sdegutis> dmwit: so I was surprised to see mtl stuff documented in it if mtl doesn't come iwht it
14:38:25 <EvilTerran> jascase901, still, no harm in checking it out - just something to bear in mind
14:39:43 <jascase901> EvilTerran, ill check it out but thanks for the warning.
14:40:04 <jmcarthur> fresheyeball: all functions only take one argument :P
14:40:39 <shock_one> Hi. Is there a de-facto standard worker pool implementation in Haskell? My main language is Ruby, and in Ruby it would be celluloid, hands down.
14:41:50 <Black0range> Does anyone know if Text.Lazy append is fully lazy or does the first argument have to be evaluated?
14:41:51 <fresheyeball> jmcarthur : :P :P
14:42:00 <fread2282> shock_one: no, but if you're usng it for IO, haskell's threads are *very* lightweight, so the common thing is to just fork as many threads as you need
14:42:19 <fread2282> also IO integrates w/ the scheduler
14:42:43 <shock_one> So, what I want to do, is to perform about a 1,000,000 HTTP requests as soon as possible. My main bottleneck is therefore newtork.
14:42:48 <rasen> fr33domlover: They are different packages. You can find info for each of them separetely
14:43:35 <tel> shock_one: you can use something like http://hackage.haskell.org/package/resource-pool to manage connection limiting---then just spawn 1M threads
14:43:55 <rasen> fr33domlover: they aren't connected behind the fact their module names begin with Language.
14:47:37 <shock_one> tel, looks like what I want, but the package has no documentation. At all. I even wonder what's the point in open sourcing a library without documentation? Is it so hard to write a couple example or something?
14:49:40 <tel> shock_one: I agree that it's unfortunate. It's subpar to true documentation, but worth noting, that the types can guide you in usage of the library. Essentially you call `createPool` once setting the parameters on your pool and then fork a bunch of threads which each call `withResource doWork` immediately
14:50:01 <tel> shock_one: See also here for some notes on creating large numbers of threads quickly w.r.t. memory use: http://stackoverflow.com/questions/1900165/how-long-does-it-take-to-create-1-million-threads-in-haskell
14:52:03 <shock_one> tel, thank you. I've already tried forkIO with millions of threads, and was really impressed.
14:52:18 <EvilTerran> hm... is is possible to "uncons" a GHC.TypeLits.Symbol?
14:53:22 <EvilTerran> I'm playing with -XDataKinds -XTypeFamilies, and I feel like "type family SymbolLength (s :: Symbol) :: Nat" should be possible, but can't see any way of decomposing a Symbol
14:54:22 <tel> shock_one: np, and good luck :)
14:55:57 <EvilTerran> or indeed do anything with Symbols other than pass them around as an opaque blob, compare them, and convert them to runtime Strings
14:55:59 <glguy> EvilTerran: That strikes me as something you won't be able to do very easily
14:56:06 <tel> EvilTerran: I'm not so sure. I feel like it goes against the abstraction a bit, yeah? Symbols are treated as atomic things.
14:56:31 <EvilTerran> oh right. I was thinking of them as type-level Strings, is that not really the intention behind them?
14:57:38 <fr33domlover> rasen, I realize they're separate, the question is whether there's any written standard or people just copy the idea of calling a package lannguage-___ and putting under the Language module
14:57:58 <fr33domlover> if there writte info about it, I'd be happy to see it and follow the conventions
14:58:34 <fr33domlover> or should I just assume these are good practices and copy them? :-)
15:03:33 <dmwit> sdegutis: Again, "comes with it" is nebulous. e.g. the Haskell Platform includes mtl.
15:04:33 <EvilTerran> glguy / tel - I'd initially expected Symbol to be something like a type-level list of type-level characters... I guess not. oh well, so much for that plan.
15:04:51 <EvilTerran> (like String is a value-level list of value-level characters)
15:06:03 <EvanR> is it possible to convert a Handle into a Ptr CFile
15:06:31 <geekosaur> no, Handle is not a C (FILE *)
15:06:36 <geekosaur> at least not in ghc
15:07:16 <geekosaur> you would need to flush it (if open for write), extract the file descriptor, and fdopen() that
15:07:37 <geekosaur> and since extracting the fd from a Handle closes it, do the reverse on return from C
15:07:51 <EvanR> nah that would defeat the purpose of this c lib taking a existing FILE
15:08:30 <EvanR> it has two functions one takes a file path, the other a FILE*
15:08:42 <EvanR> i guess ill just ignore the FILE* one
15:10:04 <reformed_con> Hello. I am a con. Thanks to the new humane american prison system I am allowed to study computer science in jail. I am learning haskell and have some questions on category theory, I guess this is the right place to ask?
15:10:24 <dmwit> Go for it.
15:10:37 <dmwit> (Also: wow, what an introduction!)
15:10:58 <osa1> I'm confused about pipes. I have a pipe with this type: Proxy a' a () Object IO () what do I need to do to run this in a IO function?
15:12:23 <favetelinguis> Is there any good tools to read in an XML file and generate Haskell code depending on the content. I want to be able to generare arbitrary code
15:12:36 <EvanR> dont drop the soap
15:12:52 <trap_exit> python 3 came out in 2008 right? so what is it with reading 2015 tutorials, and ppl are like "dude, python 2.7 is cool; python 3.4 has lots of breaking changes"
15:13:02 <mauke> reformed_con: you've been here before under the nicks success, kolossen, asdfsf, vrooom, setpoint
15:13:04 <dmwit> favetelinguis: haskell-src-exts
15:13:05 <mauke> what's up with that?
15:13:12 <trap_exit> wrong channel, sorry
15:13:35 <favetelinguis> mauke: ??
15:13:38 <EvilTerran> hm... I can't find anything at all like "type-level characters". ho hum.
15:14:06 <mauke> favetelinguis: ??
15:14:17 <glguy> !
15:14:24 <dmwit> ooo, a quest!
15:14:32 <dmwit> *click*
15:14:34 <favetelinguis> mauke: woops sry wrong nic
15:14:41 <reformed_con> mauke: I forget my nick?
15:14:45 * meoblast001 looks at codehero and relrod 
15:14:58 <glguy> Right... Go kill 5 .... Frog monsters
15:15:17 * codehero looks at meoblast001
15:15:21 <benzrf> glguy: #slayer
15:15:21 <meoblast001> :D
15:16:49 <tel> osa1: You can't run proxies which are still producing things. If you had a function like `go :: Object -> IO ()` then you could do `runEffect (for yourPipe (\obj -> liftIO (go obj)))` which is of type `IO ()`
15:17:27 <osa1> tel: thanks, later I realized that I need to add this to my pipeline consumer :: Consumer Object IO ()
15:17:28 <osa1> now it works
15:17:44 <tel> osa1: Yep, that'll do it :)
15:19:58 <orion> Hi. What is Data.Tagged useful for?
15:20:08 <orion> Erm, For what is Data.Tagged useful?
15:21:11 <HeladoDeBrownie> orion, basically, passing types without needing a value of that type. (by the way, your original question was more idiomatic.)
15:21:22 <geekosaur> are you familiar with phantom types?
15:21:59 <rasen> fr33domlover: there is no write about it. It's because of same reason people put their modules under Data. or Network.
15:22:35 <orion> Are phantom types an anti-pattern in Haskell?
15:22:49 <glguy> No
15:23:29 <fr33domlover> rasen, ok thanks
15:24:03 <sx> orion: A phantom type is a type argument, which does not appear at the right side of a type declaration.
15:24:44 * hackagebot hannahci 0.1.4.0 - Simple Continuous Integration/Deployment System  http://hackage.haskell.org/package/hannahci-0.1.4.0 (Elzair)
15:24:45 <sx> orion: so you can distinct values by type, even though the type does not influence the value at all.
15:26:05 <sx> orion: sry, what i meant was distinguish :)
15:30:29 <c_wraith> orion: no.  phantom types are definitely a good thing.  They put more semantic content into types, letting the type system do more work for you.  That's good, not bad. :)
15:31:17 <LordBrain> i recall reading another name for 'phantom type', but i can't recall what it was, anyone?
15:31:37 <dmwit> Another name?
15:31:46 <dmwit> GADTs are related, but not another name for the same thing.
15:32:00 <LordBrain> yes, as in, spj or someone like this mentioned a blabla and said also known as a 'phantom type'
15:32:32 <LordBrain> i read it in some paper, but later on i forgot the other term even though i thought it better
15:36:08 <LordBrain> hmmm may have been 'gaurded recursive datatype'
15:36:21 <LordBrain> http://www.cs.bu.edu/~hwxi/academic/papers/popl03.ps
15:37:56 <raek> off-topic: when specifying locations in source files by line and column numbers, are the column numbers usually zero-based or one-based?
15:38:10 <rasen> raek: 1
15:40:09 <raek> rasen: thanks!
15:40:19 <rasen> raek: you're welcome
15:42:07 <LordBrain> actually, gaurded recursive datatype' doesn't seem like a good name either, and maybe its worse.
15:47:20 <raek> rasen: btw, do you have a source for that?
15:47:43 <raek> I just realized that Emacs display column numbers zero-based...
15:47:54 <benzrf> raek: whomp
15:48:48 <rasen> raek: experience. All known compilers start from 1
15:48:59 <rasen> all known to me*
15:49:08 <raek> GHC and Text.Parsec.Pos.updatePosChar uses one-based, so I think I'm gonna go with that
15:49:11 <raek> okay
15:49:27 <raek> so maybe it's just Emacs that's the strange one
15:49:38 <jascase901> how do I remove imports from the repel?
15:49:47 <rasen> raek: Vim starts from 1
15:49:49 <jascase901> I want to not include the prelude for abit
15:50:00 <jascase901> repl*
15:50:28 <rasen> jascase901: import Prelude()
15:50:57 <raek> huh. when I follow an error message that points to foo.c:1:2, then Emacs puts the cursor at (1,1)
15:51:10 <dmwit> jascase901: -XNoImplicitPrelude
15:51:14 <raek> so at least it's aware that everyone else does this differently... :-)
15:51:25 <Fylwind> apparently, ioeSetLocation has signature IOError -> String -> IOError instead of String -> IOError -> IOError  :(
15:52:10 <rasen> flip ioeSetLocation?
15:52:53 <Fylwind> rasen: yeah I know, just a slight annoyance :)
15:53:35 <jascase901> thanks dmwit and rasen
16:04:45 * hackagebot generic-trie 0.1 - A map, where the keys may be complex structured data.  http://hackage.haskell.org/package/generic-trie-0.1 (EricMertens)
16:09:45 * hackagebot stable-tree 0.6.0 - Trees whose branches are resistant to change  http://hackage.haskell.org/package/stable-tree-0.6.0 (tsuraan)
16:16:37 <diracdelta> I'm looking at using haskell to implement some simple scripts that will talk to servers over http and process xml responses. If I were doing this as a bash script, I would be using curl to handle the kerberos authentication part; Are the built in HTTP libraries a good choice for simple scripting applications?
16:18:05 <rasen> @hackage HTTP
16:18:05 <lambdabot> http://hackage.haskell.org/package/HTTP
16:19:54 <Clint> diracdelta: if you need a krb5 client you may want to use the curl library
16:20:45 <drewbert> I'm attempting to use WarpTLS to encrypt traffic for a yesod website, and I'm seeing an odd TLS Exception.  Basically the same one this guy encountered (HandshakeFailed: Error_Packet_Parsing): https://github.com/basvandijk/kaltura-tls-failure/blob/master/kaltura-tls-failure.hs
16:21:29 <kranius> what is the size of hoogle's extended database ?
16:22:00 <diracdelta> Clint: thanks! There were several additional libraries, and I wasn't sure which I should go with.
16:22:24 <diracdelta> rasen: Thank you, I had found that, I wasn't sure if it was the best choice.
16:24:54 <hiptobecubic> is it possible to define operators that take more than two arguments?
16:24:56 <cmccann> I really don't understand the half dozen or so people on /r/programming who are appear to be very emotionally invested in not understand Haskell to the point they put more effort into NOT getting it than most people put into actually learning it
16:25:16 <cmccann> what even motivates someone like that, I don't get it
16:25:25 <hiptobecubic> like  `vec idx <~ value`
16:25:28 <rasen> hiptobecubic: yes
16:25:39 <hiptobecubic> cmccann, it's easier than trying to understand anything
16:26:09 <rasen> hiptobecubic: but the other way around
16:26:26 <rasen> :t x <~ y = \z -> undefined
16:26:27 <lambdabot> parse error on input ‘=’
16:26:30 <cmccann> hiptobecubic: that's what I'd usually think, but these people put huge amounts of effort into talking about how they don't understand Haskell
16:26:39 <hiptobecubic> rasen, `value ~> vec i` you mean? That seems pretty easy to me
16:27:01 <drewbert> cmccann: they are afraid of trying and failing?
16:27:08 <rasen> or use prefix (<~) x y z = undefined
16:27:09 <hiptobecubic> cmccann, sure but they don't know how much effort learning haskell would be and whining about things is often even *fun*
16:27:16 <cmccann> I guess so
16:27:26 <drewbert> looks like warpTLS is causing an internal server error :-(
16:27:47 <rasen> hiptobecubic: application would look like (x <~ y) z
16:27:56 <rasen> hiptobecubic: because of precedence
16:28:05 <hiptobecubic> rasen, right, but that's easy enough
16:28:18 <hiptobecubic> rasen, the question was about having two on the left I guess
16:28:26 <rasen> hiptobecubic: then answer is no
16:28:32 <enthropy> that'll parse as x <~ (y z)
16:28:45 <hiptobecubic> For example, when working with mutable vectors we have `write v i value`
16:29:16 <benzrf> :t (<~)
16:29:17 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
16:29:19 <benzrf> Taken!
16:29:45 <hiptobecubic> benzrf, well sure. I'm not suggesting that lens has actually left any operators available for anything
16:29:56 <hiptobecubic> it's more of a theoretical question
16:30:03 <benzrf> :t traverse <~ use traverse
16:30:04 <lambdabot> (MonadState (t a) m, Monoid a, Traversable t) => m ()
16:30:05 <benzrf> hiptobecubic: lol
16:30:22 <benzrf> @remember hiptobecubic benzrf, well sure. I'm not suggesting that lens has actually left any operators available for anything
16:30:22 <lambdabot> I will remember.
16:31:16 <benzrf> > runState (traverse <~ use traverse) ["ayy", "lmao", "more", "stuff"]
16:31:17 <lambdabot>  ((),["ayylmaomorestuff","ayylmaomorestuff","ayylmaomorestuff","ayylmaomorest...
16:31:22 <benzrf> coool
16:31:43 <hiptobecubic> what?
16:31:54 <benzrf> hiptobecubic: ??
16:31:58 <hiptobecubic> what is going on there
16:32:11 <benzrf> hiptobecubic: im runnin the state action (traverse <~ use traverse) on that list
16:32:25 <hiptobecubic> :t (use)
16:32:26 <lambdabot> MonadState s m => Getting a s a -> m a
16:33:00 <benzrf> :t use _1 :: State (Int, String) Int
16:33:02 <lambdabot> State (Int, String) Int
16:33:10 <dmwit> Not only that, but thanks to aggressive use of polymorphism, all applications of operators are well-typed. Though most are nonsensical.
16:33:18 <benzrf> dmwit: kek
16:33:32 <enthropy> > let x ~> y = (x,y) in x ~> (f :: Expr->Expr) z
16:33:33 <lambdabot>  (x,f z)
16:34:16 <benzrf> @let type f ~> g = forall a. f a -> g a
16:34:18 <lambdabot>  Defined.
16:34:46 <benzrf> join :: (m . m) ~> m
16:36:55 <dmwit> return :: Identity ~> m
16:36:59 <dmwit> how suggestive
16:37:04 <dmwit> I wonder whether those form a monoid
16:37:08 <benzrf> ;)
16:38:28 <fread2282> benzrf: type level (.)?
16:38:29 <fread2282> is that possible?
16:38:34 <fread2282> (in GHC)
16:38:34 <dmwit> sort of
16:38:37 <benzrf> fread2282: not really
16:38:45 <benzrf> fread2282: newtypes at best
16:38:54 <benzrf> @let type (.) = Compose
16:38:55 <lambdabot>  .L.hs:191:7: parse error on input ‘.’
16:38:57 <benzrf> :|
16:39:04 <augur> :)
16:39:05 <benzrf> @let type f . g = Compose f g
16:39:05 <lambdabot>  Parse failed: Parse error: .
16:39:09 <benzrf> aw dang
16:39:19 <dmwit> fread2282: https://hackage.haskell.org/package/transformers-0.4.2.0/docs/Data-Functor-Compose.html
16:39:19 <augur> @let type (:.) = Compose
16:39:19 <lambdabot>  .L.hs:191:13: Not in scope: type constructor or class ‘Compose’
16:39:25 <benzrf> @let type f ◦ g = Compose f g
16:39:26 <lambdabot>  .L.hs:191:16: Not in scope: type constructor or class ‘Compose’
16:39:30 <benzrf> bwug
16:39:35 <benzrf> @let import Data.Functor.Compose
16:39:37 <lambdabot>  Defined.
16:39:38 <benzrf> @let type f ◦ g = Compose f g
16:39:39 <lambdabot>  Defined.
16:39:40 <benzrf> :^)
16:40:08 <augur> are there any conventionally used systems for doing login stuff in haskell web programming?
16:40:17 <benzrf> @let join' = join . getCompose
16:40:18 <lambdabot>  Defined.
16:40:35 <benzrf> :t join' :: Monad m => m ◦ m ~> m
16:40:36 <lambdabot> Monad m => () m m a -> m a
16:40:48 <dmwit> my unicode
16:40:49 <benzrf> lambdabot here's not too great at unicode
16:40:55 <hpc> augur: i don't know of a package specifically for just that
16:41:11 <hpc> it'd probably be part of one of the frameworks, though i don't think they get that specific in functionality
16:41:25 <benzrf> @let return' = return . runIdentity
16:41:26 <lambdabot>  Defined.
16:41:38 <mikeplus64> there is the 'authenticate' package, but i think the apis it implements might be on the way out, idk
16:41:44 <benzrf> :t return' :: Monad m => Identity ~> m
16:41:45 <lambdabot> Monad m => Identity a -> m a
16:41:47 <benzrf> wewt
16:42:13 <fread2282> @let type Id a = a
16:42:14 <lambdabot>  .L.hs:196:1:
16:42:14 <lambdabot>      Multiple declarations of ‘Id’
16:42:14 <lambdabot>      Declared at: .L.hs:160:1
16:42:19 <hpc> at the end of the day, you just need some kind of storage engine and hashing function
16:42:40 <hpc> plus a 2-factor library of your choosing if it's something really important
16:42:53 <fread2282> @let type Id' a = a
16:42:54 <lambdabot>  Defined.
16:43:01 <hpc> then an httpOnly secure session cookie
16:43:32 <hpc> about 150 lines of code if you write it in the most readable way
16:43:35 <fread2282> :t return :: Monad m => Id' ~> m
16:43:36 <lambdabot> Monad m => Id' a -> m a
16:44:27 <jle`> nice
16:44:55 <benzrf> oh nice
16:45:11 <benzrf> :k Id
16:45:12 <lambdabot> * -> *
16:45:17 <benzrf> :k Id 3
16:45:18 <lambdabot>     The first argument of ‘Id’ should have kind ‘*’,
16:45:18 <lambdabot>       but ‘3’ has kind ‘GHC.TypeLits.Nat’
16:45:18 <lambdabot>     In a type in a GHCi command: Id 3
16:45:19 <benzrf> oop
16:45:25 <fread2282> @let  type Compose' f g a = f (g a)
16:45:26 <benzrf> :k S
16:45:26 <lambdabot>  Defined.
16:45:27 <lambdabot> Nat -> Nat
16:45:28 <benzrf> hm
16:45:30 <jle`> benzrf: you mean
16:45:33 <jle`> :k Id'
16:45:33 <lambdabot> k -> k
16:45:40 <jle`> (or you might be interested in)
16:45:40 <benzrf> fread2282: sadly you cannot partially apply type syms
16:45:46 <benzrf> *syns
16:45:48 <dmwit> Oh neat, \bot grew a :k
16:46:01 <benzrf> dont call lambdabot mean names like ⊥  :(
16:46:04 <jle`> :k Id' (->)
16:46:05 <lambdabot> * -> * -> *
16:46:06 <fread2282> :t join :: Monad m => Compose' m m ~> m
16:46:07 <lambdabot> Monad m => Compose' m m a -> m a
16:46:07 <dmwit> Does it have a :k! too?
16:46:13 <dmwit> :k! Id' Int
16:46:15 <benzrf> dmwit: nope
16:46:18 <benzrf> PR it in :^)
16:46:27 <fread2282> benzrf: true
16:46:27 <dmwit> heck no
16:46:28 <jle`> :k Id' Category
16:46:29 <lambdabot> (k -> k -> *) -> Constraint
16:46:32 <dmwit> I have important IRC business to attend to
16:46:36 <dmwit> complaining and the like
16:46:46 <benzrf> oooooh damn
16:46:50 <benzrf> fancy new category class 8D
16:46:59 <glguy> I bet it doesn't have an :info! either
16:47:10 <jle`> yup
16:47:18 <benzrf> @undef
16:47:18 <lambdabot> Undefined.
16:47:29 <benzrf> @let data Nat = Z | S Nat deriving Show
16:47:30 <lambdabot>  Defined.
16:47:37 <benzrf> then i can..
16:47:58 <Lokathor> is a Haskell MVar kinda like a golang channel?
16:48:08 <benzrf> @let data NatMorph (n :: Nat) (m :: Nat) where ...
16:48:08 <jle`> @let infinity = S infinity
16:48:08 <lambdabot>  .L.hs:154:14:
16:48:09 <lambdabot>      Ambiguous occurrence ‘infinity’
16:48:09 <lambdabot>      It could refer to either ‘L.infinity’, defined at .L.hs:154:1
16:48:09 <lambdabot>  Parse failed: Parse error: ...
16:48:10 <benzrf> er, wait
16:48:17 <dmwit> glguy: I can't tell what :info! does differently from :info.
16:48:24 <glguy> It gives you more info!
16:48:34 <Lokathor> yeah it gives you the info harder
16:48:39 <glguy> dmwit: Try: import Control.Applicative, :info! Const
16:48:45 <glguy> compare with the meager info given by :info
16:48:46 <jle`> @let inf = S inf
16:48:47 <lambdabot>  Defined.
16:48:52 <jle`> > inf
16:48:53 <lambdabot>  S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S...
16:49:09 <dmwit> ...huh
16:49:20 <benzrf> @let data NatMorph (n :: Nat) (m :: Nat) where EqNM :: NatMorph n n; SuccNM :: NatMorph n m -> NatMorph n (S m)
16:49:22 <lambdabot>  Defined.
16:49:30 <cmccann> Lokathor: I'm not familiar with golang channels but MVar is probably more limited
16:49:33 <glguy> Iavor and I added that one day after we got frustrated with the tiny amount of info we were getting ^_^
16:49:47 <cmccann> Lokathor: an MVar has a capacity of 1 if nothing else
16:50:15 <dmwit> Okay, the documentation is clear about the difference, and I should have started there instead of starting with experiments.
16:50:34 <Lokathor> cmccann, i'm not too famililar with them, but the basic properties is that you can pass them between threads, and they've got a fixed buffer (which might be more than 1), and reading from them blocks if empty, and writing to them blocks if full
16:50:43 <benzrf> @let instance C.Category NatMorph where C.id = EqNM; EqNM C.. m = m; SuccNM n C.. m = SuccNM (n C.. m)
16:50:44 <lambdabot>  Parse failed: Parse error in pattern: C.id
16:50:47 <benzrf> whaa
16:50:47 <dmwit> err... but it seems incorrect?
16:50:57 <benzrf> @let instance C.Category NatMorph where id = EqNM; EqNM . m = m; SuccNM n . m = SuccNM (n C.. m)
16:50:59 <lambdabot>  Defined.
16:51:00 <Lokathor> I'm wondering if it's a similar sort of intuition with MVars
16:51:01 <benzrf> =D
16:51:03 <benzrf> coooooooooooool!
16:51:05 <dmwit> glguy: :info mentions instance Monoid m => Applicative (Const m), but Monoid is not in scope...
16:51:29 <glguy> dmwit: Which GHC?
16:51:32 <cmccann> Lokathor: sounds more like Control.Concurrent.Chan
16:51:33 <dmwit> 7.8.3
16:51:42 <glguy> It works correctly on my 7.8.4, at least
16:51:47 <cmccann> Lokathor: except those have unlimited capacity
16:51:53 <dmwit> 'k
16:51:58 <glguy> dmwit: Are you sure that Monoid isn't in scope?
16:52:16 <dmwit> It's qualified. :info Monoid says it isn't in scope.
16:52:36 <rasen> cmccann: I see there is Control.Concurrent.BoundedChan
16:52:40 <Lokathor> cmccann oh my there's a whole thing for that then. okay.
16:52:41 <glguy> Yeah, :info only works on things in scope
16:52:47 <glguy> :info Data.Monoid.Monoid would work
16:53:09 <dmwit> But that would work whether Monoid was in scope or not.
16:53:15 <dmwit> Because ghci has funny scoping rules.
16:53:17 <cmccann> rasen: that's a separate package, isn't it? it's an obvious thing to want, anyway.
16:53:28 <rasen> cmccann: yes
16:53:38 <Lokathor> so an MVar is like a single element channel
16:53:46 <rasen> @hackage BoundedChan
16:53:46 <lambdabot> http://hackage.haskell.org/package/BoundedChan
16:53:46 <benzrf> hmmmmmmm waaait
16:53:47 <cmccann> Lokathor: there's also an equivalent in STM, which is fancier
16:53:51 <glguy> dmwit: Oh, the rule for when :info shows stuff doesn't require *everything* to be in scope any more
16:53:52 <benzrf> why is Category in Control
16:53:58 <benzrf> i feel like it should really be Data
16:54:00 <jle`> heh
16:54:05 <dmwit> glguy: But... the documentation...
16:54:08 <glguy> dmwit: and :info! doesn't require anything to be in scope
16:54:33 <benzrf> Category may be seen as a generalization of monoids or of functions, both of which are in Data
16:54:35 <cmccann> benzrf: to counterbalance the fact that Data.Functor isn't in Control?
16:54:41 <benzrf> cmccann: it oughtnt
16:54:49 <Lokathor> cmccann oh? Well if i were just trying to safely store updates from several threads at once, would MVar be "sufficient enough" for that sort of thing?
16:54:54 <dmwit> glguy: Yeah, I think I understand :info!. But now I don't understand :info.
16:54:54 <Zemyla> Okay, so I have a class Convertible a with a method a -> Integer, yes?
16:55:03 <benzrf> hmm i suppose honestly it would make more sense for Control.Function and Control.Category
16:55:05 <dmwit> glguy: What things need to be in scope to qualify as being included in :info?
16:55:12 <benzrf> Data.Functor stays tho
16:55:34 <cmccann> Lokathor: if you don't need to run multiple operations on the MVar atomically then it's 100% fine
16:55:55 <Zemyla> And I want to have (Convertible a) => Convertible [a], with convert [] = 0.
16:56:08 <cmccann> benzrf: given that Applicative is in Control I always thought Functor should be as well, personally
16:56:14 <Zemyla> But when I call convert [], it says it's ambiguous.
16:56:16 <glguy> dmwit: Good question. I find the documented behavior to be rather useless, in any case ^_^
16:56:33 <cmccann> but tbh the choice between Control and Data seems arbitrary as often as not
16:56:34 <Zemyla> Why is show [] not ambiguous, but convert [] is?
16:56:42 <glguy> So far it seems :info shows up when the class is in scope
16:56:43 <dmwit> show [] *is* ambiguous
16:56:45 <geekosaur> beause show is subject to defaulting
16:56:51 <Zemyla> > show []
16:56:52 <lambdabot>  "[]"
16:56:54 <geekosaur> you can't turn that on for user defined things
16:56:55 <dmwit> It's just that we have special-case rules for that particular ambiguity.
16:56:59 <athan> Is there like an obstacle course or something that people have to go through before they can call themselves a "computer scientist"?
16:57:05 <athan> :(
16:57:13 <Lokathor> cmccann the example i was looking at was passing a lambda into modifyMVar for each update. Does that sound about right?
16:57:25 <dmwit> athan: Oh, nobody had told you about the snake fight?
16:57:42 <athan> dmwit: I've heard stories
16:57:49 <glguy> from dmwit  just now?
16:58:20 <dmwit> Perhaps everything in the instance head has to be in scope.
16:58:26 <dmwit> contexts are right out
16:58:40 <rasen> athan: Everyone can call himself how it wishes to
16:59:03 <cmccann> Lokathor: apparently modifyMVar is only atomic if no other threads are trying to write to the MVar
16:59:08 <Zemyla> Is it possible to fix the ambiguity with a forall?
16:59:31 <benzrf> cmccann: applicative strikes me as a way of structuring flow n stuff, idk
16:59:47 * hackagebot battlenet 0.2.0.0 - API client for Battle.Net  http://hackage.haskell.org/package/battlenet-0.2.0.0 (teozkr)
16:59:48 <benzrf> cmccann: but Functor explicitly is structure-respecting
16:59:49 * hackagebot battlenet-yesod 0.2.0.0 - Yesod integration for the battlenet package  http://hackage.haskell.org/package/battlenet-yesod-0.2.0.0 (teozkr)
16:59:57 <benzrf> it's only for manipulating values
17:00:10 <dmwit> rasen: Joshua Norton calls himself the Emperor of the United States.
17:00:26 <jle`> anyone can make whatever ad-hoc rules they like to justify anything when it comes to this :P
17:01:03 <rasen> dmwit: I have no objections
17:01:07 <benzrf> dmwit: *called :I
17:01:10 <benzrf> RIP
17:01:16 <Lokathor> cmccann so i suppose i should use takeMVar, modify the data, and then do putMVar? or would looking into proper STM be better? I don't actually know how complex working with STM is...
17:01:49 <cmccann> Lokathor: I think that's what modifyMVar is doing, which is why it's not atomic if something else can putMVar in the meantime
17:02:28 <cmccann> Lokathor: STM is slightly less efficient, so it's a performance overhead if you use it when regular concurrency would work fine
17:02:45 <Lokathor> cmccann so if all code is only using modify, does it end up simulating being atomic in that case? since they'd need to read before modifying
17:02:52 <cmccann> Lokathor: otherwise, it's no more complex to use and much, much simpler to reason about. atomic things are atomic and it mostly Just Works (tm)
17:03:23 <glguy> Lokathor: Yes, that's how it works. Keep using things like "withMVar" and "modifyMVar" etc and it behaves correctly
17:03:52 <Lokathor> glguy: Alright thanks.
17:05:24 <cmccann> Lokathor: you really should try using STM, though. it's nice.
17:06:13 <dmwit> As soon as you want to touch two MVars at once atomically, you're going to want to switch to STM.
17:06:29 <Lokathor> hmm, well the situation is that i have a server that is managing data changes among several clients, and announcing changes to them all when a change happens
17:06:41 <dmwit> It's not strictly speaking necessary at that point. But it means you're walking down the path to where you're going to avoid headaches by switching.
17:07:14 <cmccann> my rule of thumb is that if I have to stop and think about whether my use of MVars will work correctly, I should just use STM until I have hard performance data indicating I need to reconsider the design
17:10:05 <Lokathor> hmm, so i just change my MVar into a TMvar and it's mostly the same sort of thing, but using the STM library instead of the normal concurrency library?
17:10:37 <cmccann> Lokathor: yes, anything that worked with MVars should work the same using TMVars instead
17:10:52 <tomphreek> is there a reason we have to declare instance X MyType where f = *implementation* rather than just provide implementation for f. Is it to avoid collision of names or there's a deeper reason why it is necessary?
17:10:57 <cmccann> Lokathor: but now you can combine operations into one use of atomically and it will be atomic
17:11:46 <Lokathor> i guess the changes to the TMvar are atomic, but I can't also write the change into a database as part of the same atomic action, can i?
17:11:56 <Lokathor> all these operations are STM only it seems
17:12:04 <Lokathor> (which makes sense after all)
17:12:09 <cmccann> Lokathor: right, because the STM operations can be rolled back and repeated
17:12:29 <cmccann> you can read about how it works if you want, it's pretty slick
17:12:38 <darthdeus_> is cabal 1.22.x recommended on ghc 7.8.x? or should I stick with 1.20?
17:13:03 <Lokathor> cmccann: I've seen a few SPJ lectures on the concurrency stuff, it does seem nice
17:13:43 <Lokathor> so i'd "atomically" update the server state (held in a TMvar) and then I'd write the new contents of the TMvar to the database as a second action? Or how would I normally keep those two parts synchronized?
17:14:10 <cmccann> atomically blocks until it completes successfully, so yeah, do what you need to in IO afterwards
17:14:43 <cmccann> it only gets tricky if you need to do multiple things in STM with an IO action in the middle. then you're back to taking locks and other headaches, unfortunately.
17:14:48 <Lokathor> readTVarIO seems to be a key part of things
17:15:10 <cmccann> I think readTVarIO is just atomically . readTVar, but more efficient
17:15:20 <Lokathor> yeah that's what the doc says
17:15:44 <Lokathor> I don't need to interweave IO and STM, i just need to keep the database lined up with the server as much as possible in case the server suddenly crashes and i need to restart
17:16:00 <Lokathor> the "database" could be a file on disk for all i care really
17:16:19 <cmccann> Lokathor: in that case it should be easy, you'll always see a consistent view of the stuff in STM so you can just write it out as needed
17:16:28 <Lokathor> sounds perfect
17:17:09 <dmwit> tomphreek: I don't know that there's a deep reason, but I imagine things would get kind of complicated.
17:17:17 <Lokathor> the abstractions we build, just to play board games over the internet :P
17:17:34 <dmwit> tomphreek: Remember there's many methods; and you get to announce an instance context.
17:17:49 <cmccann> Lokathor: the ideal scenario for STM is when different transactions are almost entirely independent of each other, but it'd be painfully hard to synchronize things in the usual manner
17:18:05 <dmwit> tomphreek: Trying to gather up all the implementations of the different methods, guess which instance you're trying to write, guess which context you want, etc. seems at least complicated, and at worst heuristic.
17:18:33 <cmccann> Lokathor: the worst-case scenario is when you have a bunch of writes to the same variables and transactions are constantly retrying and it's all really slow
17:18:36 <dmwit> tomphreek: Giving a heading as is currently required is a small price, and has a much simpler implementation. So.
17:18:54 <Lokathor> sadly, i think i have more like the second thing. most of the "state" is a big nested data structure that i'm updating via lens
17:19:16 <cmccann> dmwit: I actually can't think of any reason standard, no-GHC-extensions type classes couldn't be implicit like that. seems like it'd be harder to read for human and compiler alike though.
17:19:31 <Lokathor> each update should be very small though, the clients do most of the processing
17:19:52 <codygman> Is this a good example of working with errors as values with Wreq to fetch webpages? Should I be using errors (or some other library), eitherT, or something else instead? code: http://lpaste.net/119717
17:20:06 <dmwit> cmccann: Well, suppose I write a very polymorphic implementation. What instance should you make? Like, "f = undefined", now what?
17:20:27 <cmccann> dmwit: I'm assuming full type signatures would be obligatory
17:20:44 <dmwit> Oh. Well then that seems like a bad tradeoff to me.
17:21:02 <cmccann> allowing it without type signatures seems worse to me.
17:21:09 <cmccann> because who KNOWS what it would do.
17:21:18 <dmwit> You write type signatures on your instance methods?
17:21:19 <cmccann> not me, and probably not the compiler either.
17:21:34 <cmccann> sometimes, actually
17:21:45 <cmccann> but mostly no, because the key information is in the instance declaration :P
17:21:46 <Lokathor> dmwit: I probably would actually
17:21:50 <dmwit> Okay. Well, I think you'll agree that's not a very common practice.
17:22:42 <cmccann> I'm just saying that you'd either want obligatory type signatures without an instance declaration OR the current situation, with instance declarations and optional signatures
17:22:50 <dmwit> cmccann: Right. And I think I would even go as far as to say that repeating the key information once for each method, instead of just once, would be a bad tradeoff.
17:22:59 <nshepperd_> Writing type signatures on instance methods is being added as a GHC ext I think
17:23:15 <cmccann> dmwit: well, I'm not saying I think it'd be a good idea, either
17:23:22 <nshepperd_> Currently you can't
17:23:37 <dmwit> cmccann: In that case, you have a reason that classes aren't implicit like that. =)
17:23:53 <cmccann> just that implicit instances without explicit type signatures would be horrible :P
17:24:29 <Lokathor> accidental duck typing :P
17:24:35 <cmccann> for single-function classes I can kinda see the appeal though. I wouldn't mind being able to write fmap with an explicit signature and no instance declaration around it.
17:24:50 <Rotaerk> how many types of accidental ducks are there?
17:25:17 <nshepperd_>  You wouldn't be able to grep for instances anymore
17:25:36 <cmccann> Rotaerk: if you put a male and female duck in the same cage, probably quite a few
17:25:40 <Lokathor> Rotaerk: as many as your dynamic language of choice allows i suppose
17:26:11 <Zemyla> But yeah, I've come up with a type class for reversibly converting things to Integer for indexing purposes.
17:26:18 <rasen> @hoogle Either e a -> Maybe a
17:26:19 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
17:26:19 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
17:26:20 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
17:26:39 <cmccann> Zemyla: isn't that called "Integral" and/or "Ix"?
17:27:05 <cmccann> or "Enum" I guess. we have a lot of redundant ways to do things like that.
17:27:20 <cmccann> also, I hate most of those ways.
17:27:32 <mniip> rasen, either Just (const Nothing)
17:27:35 <mniip> I think
17:27:44 <mniip> or the reverse
17:28:13 <rasen> reverse
17:29:07 <cmccann> :t const Nothing ||| Just
17:29:08 <lambdabot> Either b a -> Maybe a
17:29:29 <rasen> :t (|||)
17:29:29 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
17:29:54 <mniip> a what now
17:29:57 <mniip> oh
17:30:00 <cmccann> it's a generalized version of "either"
17:30:21 <cmccann> but I think it looks better as an operator
17:30:25 <benzrf> cmccann: is that transformation natural though
17:30:41 <benzrf> where's (***) for ArrowChoice
17:30:55 <cmccann> :t (+++)
17:30:56 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
17:30:59 <cmccann> like that?
17:31:15 <benzrf> aha!
17:31:37 <benzrf> is ArrowChoice a subclass of Arrow
17:31:51 <cmccann> I assume so
17:31:56 <benzrf> :t \f g -> (f *** g, f +++ g)
17:31:57 <lambdabot> ArrowChoice a => a b c -> a b' c' -> (a (b, b') (c, c'), a (Either b b') (Either c c'))
17:32:03 <benzrf> that's garbage
17:33:00 <rasen> hm...
17:33:13 <rasen> @djinn Either a b -> Maybe b
17:33:14 <lambdabot> f a =
17:33:14 <lambdabot>     case a of
17:33:14 <lambdabot>     Left _ -> Nothing
17:33:14 <lambdabot>     Right b -> Just b
17:33:21 <rasen> oh... boring
17:33:36 <exio4> @. pl djinn Either a b -> Maybe b
17:33:36 <lambdabot> (line 3, column 10):
17:33:36 <lambdabot> unexpected '_'
17:33:36 <lambdabot> expecting variable, "(", operator or end of input
17:33:53 <mniip> you can do that? o.o
17:33:54 <exio4> uh, well, something like that ;P
17:34:11 <cmccann> I think pl wants an expression as input
17:35:04 <cmccann> in any case, (const Nothing ||| Just) is as pointless as it's going to get, I suspect
17:36:05 <cmccann> mniip: do what, compose lambdabot commands? yeah
17:36:33 <benzrf> @pl f a case a of Left _ -> Nothing; Right b -> Just b
17:36:33 <lambdabot> (line 1, column 20):
17:36:33 <lambdabot> unexpected '_'
17:36:33 <lambdabot> expecting variable, "(", operator or end of input
17:36:44 <benzrf> @pl f a case a of Left x -> Nothing; Right b -> Just b
17:36:44 <lambdabot> (line 1, column 24):
17:36:44 <lambdabot> unexpected '>'
17:36:44 <lambdabot> expecting operator
17:36:46 <benzrf> pfft
17:45:11 <rasen> @pl f a = case a of { Left _ -> Nothing; Right b -> Just b }
17:45:11 <lambdabot> (line 1, column 17):
17:45:11 <lambdabot> unexpected '{'
17:45:11 <lambdabot> expecting variable, "(", operator or end of input
17:45:11 <Zemyla> cmccann: No, because I can convert (Integer, Integer) to a single Integer.
17:45:11 <Zemyla> :t either (const Nothing) Just
17:45:12 <Zemyla> Hmm? A netsplit or something?
17:45:12 <Zemyla> What the hell?
17:45:17 <lambdabot> Either a a1 -> Maybe a1
17:45:28 <samba1> can someone please give me advice? http://lpaste.net/5723065890677719040 folding lists of two datastructures into a list of a third
17:45:38 <cmccann> oh boy, netsplits are fun
17:45:54 <benzrf> :v(
17:46:18 <cmccann> Zemyla: so basically Ix, except you want to use Integer instead of Int?
17:48:15 <mcjohnalds> I want to use the gloss package but I want to have control over the main loop, any ideas?
17:51:53 <Hijiri> mcjohnalds: have your game functions implement its own loop that has the gloss loop under it
17:53:12 <Zemyla> cmccann: Yeah, basically. I can also convert lists to and from I tegers.
17:54:10 <rasen> what's the name for flip (.)?
17:54:26 <mcjohnalds> Hijiri: I'm not sure what you mean, with gloss it seems like you have to use `playIO` or `play`
17:54:43 <Hijiri> I mean, keep track of your own loop within the game state
17:54:44 <Adeon> rasen: >>>
17:55:56 <mcjohnalds> I tried, but I'm encapsulating everything within the Eff type from extensible-effects. It would be much cleaner to not use playIO at all and just write the loop myself
17:56:09 <Hijiri> I don't think you can do that with gloss
17:56:21 <Hijiri> you could try modifying gloss itself if you want
17:56:30 <mcjohnalds> Mkay, I guess I'll do that. Thanks.
17:56:41 <Zemyla> :t flip (.)
17:56:42 <lambdabot> (a -> b) -> (b -> c) -> a -> c
17:56:56 <Zemyla> :t (>>>)
17:56:57 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
17:57:19 <Zemyla> rasen: It's (>>>).
17:58:10 <cmccann> :t (<<<) >>> (<<<) >>> (<<<)
17:58:11 <lambdabot> Category cat => cat b c -> (a2 -> a1 -> cat a b) -> a2 -> a1 -> cat a c
17:58:19 <cmccann> :t (>>>) <<< (>>>) <<< (>>>)
17:58:20 <lambdabot> Category cat => cat a b -> ((cat b c2 -> c1) -> c) -> (cat a c2 -> c1) -> c
17:58:47 <rasen> Adeon, Zemyla: Thanks
17:59:56 <Zemyla> Basically, I want a type class that can be used for infinite trees.
18:00:33 <cmccann> @quote Int.->.Int
18:00:34 <lambdabot> cmccann says: :t \f -> \x -> f x :: Int :: (Int -> Int) :: (Int -> Int) -> Int -> Int
18:00:39 <cmccann> I still love how that's legal syntax
18:02:52 <enthropy> @quote benmachine evar
18:02:52 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
18:03:04 <glguy> :t if True then True else True :: Bool :: Bool
18:03:05 <lambdabot> Bool
18:06:22 <cmccann> ooh, those are nice too
18:06:30 <cmccann> Haskell syntax is marvelously flexible
18:08:55 <__jim__> has anyone used gtk2hs-buildtools on windows?
18:09:34 <__jim__> I've had some issues with long/expensive build times
18:14:36 <samba1> can someone please give me advice? http://lpaste.net/5723065890677719040 folding lists of two datastructures into a list of a third
18:14:51 * hackagebot calculator 0.1.4.1 - A calculator that operates on string inputs  http://hackage.haskell.org/package/calculator-0.1.4.1 (sumitsahrawat)
18:15:21 <Tokenizer> hi, i'm trying to uninstall cabal and ghc completely (on OSX), there's some doc about haskel but not about cabal.. can someone comment on this (dont' know if just finding and removing is enough)
18:16:54 * EvanR runs cabal init
18:17:09 <EvanR> if im not back in a minute and a half send MPs
18:17:12 <rvxi> hey
18:17:24 <yac> I don't get it ... https://gist.github.com/yaccz/22cc393476300da40f25
18:17:27 <rvxi> is there much demoscene activity in haskell?
18:17:33 <rvxi> probably a dumb question
18:17:40 <rvxi> (i'm guessing no...)
18:17:40 <yac> https://github.com/yaccz/os-release/commit/5a87293947de247a2c6325fb79b5f26e6ba146e6 what's the problem there?
18:17:54 <Tokenizer> nvmd, found the answer
18:18:06 <glguy> rvxi: The only thing that comes to my mind is https://github.com/ekmett/quine/wiki/Screenshots
18:18:31 <alpounet> rvxi: you probably want to talk to phaazon -- although getting tiny tiny binaries is harder in haskell :p but you should hang out on #haskell-game, where quine & other fun things are happening
18:18:57 <EvanR> its asking me to pick a license, and i have no idea what im doing here. this is bindings to a LGPL library
18:19:08 <EvanR> and most haskell projects seem to be MIT or BSD?
18:19:33 <Hijiri> LGPL has exceptions for library use
18:19:40 <Hijiri> so you can choose a non-GPL license
18:20:03 <Hijiri> for the bindings
18:20:15 <EvanR> no idea how bindings factors into the legalities of it
18:20:19 <rvxi> alpounet: thanks
18:20:25 <Hijiri> probably would just make sense to LGPL the bindings too, since any users of it will have to follow the library's LGPL anyway
18:20:48 <Hijiri> LGPL is like GPL except you don't have to use GPL when you link to it
18:21:02 <Hijiri> in your main program, I mean
18:21:20 <Hijiri> I would assume it applies to bindings too
18:23:02 <EvanR> yeah i knew that much
18:23:40 <Hijiri> I think bindings would be like any other use of the library
18:24:07 <cmccann> I'd say use the library's license, that way anyone using the package will know that they're using LGPL'd code
18:24:25 <cmccann> even though I'm pretty sure it's not strictly necessary
18:27:54 * EvanR replaced MIT with LGPL
18:33:16 <EvanR> that went really smooth
18:40:27 <Rotaerk> do you guys prefer specifying the individual items to be imported from a package, or just import the entire package and hide things as-needed?
18:40:53 <Rotaerk> i was thinking explicitly importing things would make it clear where they came from, but now I'm wondering if I'm just being obsessive compulsive
18:41:06 <Rotaerk> the packages I've seen don't seem to do that
18:41:09 <Zemyla> Okay, this is kind of a chicken and egg problem.
18:41:11 <drewbert> Rotaerk: I think there's no right or wrong answer to that one.
18:42:00 <Rotaerk> hmm k
18:43:33 <kentangsofa> Chicken sounds nice
18:43:43 <Rotaerk> I think I will explicitly specify; helps to determine when an import is no longer needed
18:44:04 <Rotaerk> either explicitly specify items, or qualify the import
18:45:08 <Rotaerk> meh, that would be a pain in the ass for packages like gl
18:45:10 <Zemyla> Hmm. Constr doesn't really have any DataType items, fortunately.
18:45:45 <kentangsofa> Wooah..some deep shit words there bruh..
18:45:47 <kentangsofa> Chao
18:48:23 <cmccann> Rotaerk: consider importing everything for now, then go back and add explicit import lists when the module is mostly "done"
18:48:37 <Rotaerk> hmm good idea
18:48:52 <EvanR> cabal clean doesnt seem to be removing any of the .o files .hs files that are produced by hsc2hs
18:48:59 <cmccann> explicit import lists are a pain while you're making major changes, but really helpful when you come back three months later and wonder wtf you were doing
18:49:21 <EvanR> more annoyingly, my changes to the hsc files dont appear in the next build
18:49:52 * hackagebot calculator 0.1.5.0 - A calculator repl.  http://hackage.haskell.org/package/calculator-0.1.5.0 (sumitsahrawat)
18:51:05 <enthropy> EvanR: those generated files go into dist/ somewhere... and cabal clean removes that directory
18:51:36 <EvanR> ok
18:51:52 <EvanR> then im building my test program wrong
18:51:58 <enthropy> but you've called hsc2hs yourself?
18:52:06 <EvanR> before i cabalized things
18:52:22 <EvanR> making sense now
18:57:50 <EvanR> holy shiz my haskell program is playing music
18:58:15 <EvanR> without dropouts
18:59:05 <Clint> is it good music?
18:59:53 * hackagebot calculator 0.1.5.1 - A calculator repl.  http://hackage.haskell.org/package/calculator-0.1.5.1 (sumitsahrawat)
19:01:27 <EvanR> "when you walk alone.it"
19:02:38 <EvanR> more importantly, it sounds just like the C program
19:03:43 <rcharles> EvanR: Careful it probably has side effects
19:04:06 <EvanR> no, pure audio
19:04:21 <EvanR> but it requires i represent myself as part of the program
19:04:21 <rcharles> :)
19:04:33 <EvanR> kind of awkward
19:04:37 <Hijiri> sounds zen
19:05:43 <cmccann> EvanR: what sort of program are you working on?
19:06:12 <EvanR> mikmod bindings
19:07:42 <cmccann> oh fun
19:07:56 <cmccann> man that brings back memories. that library is kinda ancient, isn't it?
19:08:39 <EvanR> back when libraries dont just cease to function because time passed
19:09:51 <EvanR> i was surprised to see no bindings to it, except via SDL-mixer
19:09:53 * hackagebot CCA 0.1.5.2 - preprocessor and library for Causal Commutative Arrows (CCA)  http://hackage.haskell.org/package/CCA-0.1.5.2 (PaulLiu)
19:12:14 <cmccann> is the library still be updated? or did it fossilize in a surprisingly working state?
19:13:02 * EvanR checks the mecurial (??) repo
19:13:41 <EvanR> load_xm.c (XM_Load): fix a possible undefined behavior found by gcc5, 2014-12-28
19:13:44 <EvanR> merry christmas
19:14:02 * EvanR needs to find some food
19:14:28 <cmccann> that's kinda cool
19:14:57 <cmccann> mikmod being active, that is. you going to get food is not cool, but probably necessary.
19:15:32 <yac> https://github.com/yaccz/os-release/commit/d5debb40dcb261c999214a53cf22547420e19019 not sure if I am doing this right
19:16:45 <dmwit> This is the most minor of comments, but: why did you add a "do"?
19:17:53 <glguy> > 10 + do do 20 -- it let's lambdabot know you're serious
19:17:55 <lambdabot>  30
19:18:25 <dmwit> ?let please = id
19:18:27 <lambdabot> Plugin `eval' failed with: .L.hs: getSymbolicLinkStatus: does not exist (No such file or directory)
19:18:32 <benzrf> whoah
19:18:41 <benzrf> > do do doo
19:18:42 <lambdabot>  dum dum dum
19:19:02 <mniip> > :t do 20
19:19:03 <lambdabot>  <hint>:1:1: parse error on input ‘:’
19:19:07 <mniip> :t do 20
19:19:07 <lambdabot> Num a => a
19:19:14 <mniip> waaaaaaaait what
19:19:15 <yac> dmwit: me?
19:19:25 <dmwit> > please (do this)
19:19:26 <lambdabot>  okay
19:19:33 <dmwit> yac: yes
19:19:53 <dmwit> mniip: do-notation gets translated away completely blind to semantics.
19:19:59 <glguy> It's handy (not handy) for avoiding even more parentheses
19:20:08 <yac> dmwit: which line?
19:20:11 <glguy> > 2 * do 4 + 6
19:20:13 <lambdabot>  20
19:20:14 <mniip> I thought you can't do without complex types
19:20:19 <mniip> so wait
19:20:21 <yac> oh, the tests?
19:20:25 <dmwit> yac: errCase x = do
19:20:37 <benzrf> mniip: do is extremely simple syntactic sugar
19:20:37 <mniip> > let (>>) = (+) in do 2; 4
19:20:38 <lambdabot>  Could not deduce (GHC.Num.Num (m a0))
19:20:38 <lambdabot>    arising from the ambiguity check for ‘e_124’
19:20:38 <lambdabot>  from the context (GHC.Num.Num (m b),
19:20:42 <mniip> aw crap
19:20:50 <yac> yeah, that's an overlook. I was experimenting with writing it better which requried do but I couldn't get it working
19:20:52 <dmwit> > length "2 * do 4 + 6"
19:20:53 <lambdabot>  12
19:20:58 <benzrf> mniip: for that you need RebindableSyntax
19:20:58 <dmwit> > length "2 * (4 + 6)"
19:20:59 <lambdabot>  11
19:21:31 <yac> so I deleted it again but forgot to delete the do
19:21:55 <mniip> so 'do' translates into some builtin fixed '>>' and '>>='
19:22:02 <mniip> not literal '>>' and '>>=' calls
19:22:05 <dmwit> yac: Yeah, it doesn't really matter. But I didn't want to put in the effort required to make a comment that mattered. (sorry)
19:22:40 <dmwit> mniip: right
19:23:08 <benzrf> mniip: no, i think it's literal, it's just that the literal calls are to (Prelude.>>) or something
19:23:26 <benzrf> im not sure what the precise rules are tbh
19:23:35 <dmwit> It doesn't go through name resolution. So if you import Prelude as SomethingElse and import MyPrelude as Prelude, that doesn't replace (>>).
19:24:46 <mniip> yeah I bet you can't alter the behavior of do without -X stuff
19:25:04 <yac> hum, I hoped I can finish making it correct today but looks like it will take another day
19:25:37 <yac> s/it/the parser/
19:26:20 <dmwit> -ddump-simpl and -fdefer-type-errors is a strange combination
19:26:34 <benzrf> what is simpl
19:26:34 <dmwit> You get type error strings in your pretty-printed core.
19:27:04 <geekosaur> simplifier output, or something silly like that
19:30:29 <dmwit> Honesty time: I don't actually know what simpl means. But it's what the experts use to see Core, so I cargo-culted it.
19:32:54 <benzrf> hah
19:34:55 * hackagebot hjsonschema 0.1.0.0 - Haskell implementation of JSON Schema v4.  http://hackage.haskell.org/package/hjsonschema-0.1.0.0 (seagreen)
19:36:11 <EvanR> what experts use to see core, i imagine it being these crazy looking glasses
19:37:50 <cmccann> dmwit: clearly haskell experts are so clever that cargo-cult imitating them means you're merely a competent programmer
19:38:17 <hcore> haskell experts are the cleverest experts to ever expert
19:51:11 <tsani> I'm trying to use the github library, and most of the functions are of the form a -> IO (Either Error b)
19:51:37 <tsani> I feel like it should be possible to exploit do-notation to make this more elegant.
19:51:54 <enthropy> @type ErrorT
19:51:55 <lambdabot> m (Either e a) -> ErrorT e m a
19:52:10 <tsani> :D
19:52:40 <tsani> Awesome! Thanks. I'll look into using ErrorT then.
19:53:40 <glguy> ErrorT is deprecated in the latest version of the transformers library, fwiw
19:53:53 <enthropy> if you don't actually want to recover from an error, you could also have  Right b <- githubFunction a
19:54:17 <sdegutis> I like how Haskell non-functions are just basically like functions which take 0 parameters.\
19:54:30 <glguy> ExceptT is the replacement (it doesn't have a requirement that of a function String -> ErrorType)
19:54:38 <tsani> glguy: huh, why so ? It seems like a pretty useful transformer to have
19:56:03 <glguy> But ExceptT was added in transformers-0.4, but is a boot package of GHC in 7.8 (which comes with transformers-0.3) (oh my!) fortunately not all is lost and you can depend on transformers-compat to make sure you have ExceptT even when using transformers-0.2 or 0.3
19:56:41 <tsani> ah
19:57:28 <jle`> tsani: ErrorT's Monad instance only works if the error value is an instance of the Error typeclass
20:00:42 <SilentNuke> possibly
20:01:11 <enthropy> > runErrorT $ do Just () <- return Nothing; return () :: ErrorT String [] ()
20:01:12 <lambdabot>  [Left "Pattern match failure in do expression at <interactive>:3:16-22"]
20:01:50 <sdegutis> Am I supposed to know when to call freeHaskellFunPtr myself?
20:01:50 <enthropy> people don't like that feature of do notation?
20:02:06 <sdegutis> You could use >>= instead of do, btw.
20:02:33 <enthropy> @undo do Just () <- return Nothing; return ()
20:02:33 <lambdabot> return Nothing >>= \ a -> case a of { Just () -> return (); _ -> fail ""}
20:03:24 <glguy> enthropy: Some people probably don't like it, but I think that the problem is that in some cases you don't want to reflect fail errors in your exception type
20:03:57 <sdegutis> Is it common to create your own Either type that has better names than Left and Right?
20:04:26 <glguy> Yes, people create new sum types all the time
20:04:29 <benzrf> enthropy: i dont think that's well-typed
20:04:31 <sdegutis> Cool beans.
20:04:37 <benzrf> oh wait
20:04:54 <sdegutis> what?
20:04:54 <benzrf> no, yea
20:04:56 <enthropy> @botsnack thinks so
20:04:56 <lambdabot> :)
20:04:57 <sdegutis> ok
20:05:00 <benzrf> what the heck
20:05:07 <benzrf> ooooh derp
20:05:09 <mniip> data Some a b = Better a | Worse b
20:05:24 <sdegutis> Sure, but then if you want to use that as a monad, you have to declare it so.
20:05:29 <sdegutis> Whereas if you just use Either, it's already done.
20:05:33 <sdegutis> So that's a trade-off.
20:05:35 <enthropy> @let data Some a b = Better a | Worse b deriving Ord
20:05:35 <lambdabot>  .L.hs:170:24:
20:05:36 <lambdabot>      No instance for (Eq (Some a b))
20:05:36 <lambdabot>        arising from the 'deriving' clause of a data type declaration
20:05:42 <enthropy> @let data Some a b = Better a | Worse b deriving (Eq,Ord)
20:05:43 <lambdabot>  Defined.
20:05:47 <sdegutis> And we all know you can't just derive Monad.
20:06:00 <enthropy> > Worse 'z' > Better 'a'
20:06:02 <lambdabot>  True
20:06:09 <mniip> dang
20:06:11 <mniip> backwards
20:06:18 <sdegutis> > Worse 3 >> Better 4
20:06:20 <lambdabot>  No instance for (GHC.Show.Show (L.Some a0 b0))
20:06:20 <lambdabot>    arising from a use of ‘M847160667776351191528111.show_M8471606677763511915...
20:06:20 <lambdabot>    arising from a use of ‘e_134’
20:06:26 <sdegutis> wait what
20:06:34 <rasen> ... ok. I need flip bit order in every byte in bytestring
20:06:37 <sdegutis> > fmap succ Worse 3
20:06:38 <lambdabot>  No instance for (GHC.Show.Show (L.Some a0 a1))
20:06:38 <lambdabot>    arising from a use of ‘M343676550774588808328136.show_M3436765507745888083...
20:06:38 <lambdabot>    arising from a use of ‘e_13’
20:06:50 <mniip> @let data Some a b = Worse b | Better a devicing (Eq, Ord, Show)
20:06:51 <lambdabot>  .L.hs:172:1:
20:06:51 <lambdabot>      Multiple declarations of ‘Some’
20:06:51 <lambdabot>      Declared at: .L.hs:168:1
20:06:55 <mniip> ugh
20:07:03 <glguy> lambdabot spam -> /msg
20:07:20 <mniip> but it's not spam
20:07:22 <mniip> it's science
20:07:48 <rasen> Does anybody know how to do that?
20:08:08 <benzrf> rasen: hm
20:08:11 <benzrf> :t BS.map
20:08:12 <lambdabot> (Word8 -> Word8) -> BSC.ByteString -> BSC.ByteString
20:08:20 <benzrf> :t bits
20:08:21 <lambdabot> (Bits b, Indexable Int p, Applicative f, Num b) => p Bool (f Bool) -> b -> f b
20:08:31 <benzrf> > :t over bits reverse
20:08:32 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:08:35 <benzrf> :t over bits reverse
20:08:36 <lambdabot>     Couldn't match type ‘Bool’ with ‘[a0]’
20:08:36 <lambdabot>     Expected type: Bool -> Bool
20:08:36 <lambdabot>       Actual type: [a0] -> [a0]
20:08:39 <benzrf> derp
20:08:47 <glguy> rasen: Check out https://graphics.stanford.edu/~seander/bithacks.html for sweet bit hack tricks
20:08:56 <glguy> rasen: map one of them over your bytestring
20:08:59 <benzrf> rasen: well if you can figure out how to reverse a Word8 or whatever...
20:09:19 <mniip> what's an 'over'
20:09:25 <rasen> :t over
20:09:26 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
20:09:39 <mniip> I can't find it on hoogle?
20:09:43 <rasen> omg
20:09:45 <Clint> mniip: lens
20:10:08 <mniip> o
20:11:08 <rasen> glguy: thanks. b = ((b * 0x0802LU & 0x22110LU) | (b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
20:12:00 <rasen> hm.. anyway... If i'm going to unpack string I can build bitarray without packing it back
20:12:03 <benzrf> /bin/sh: 1: Syntax error: "(" unexpected
20:12:04 <benzrf> crap
20:12:10 <benzrf> :t over (toListOf bits) reverse -- ( ͡° ͜ʖ ͡°)
20:12:12 <lambdabot>     Couldn't match type ‘[Bool]’ with ‘s -> Identity t’
20:12:12 <lambdabot>     Expected type: Setting (->) s t [a0] [a0]
20:12:12 <lambdabot>       Actual type: ([a0] -> Identity [a0]) -> [Bool]
20:12:21 <benzrf> oh you gotta be kidding me
20:12:36 <benzrf> :t toListOf bits
20:12:37 <lambdabot> (Bits s, Num s) => s -> [Bool]
20:12:45 <benzrf> erm.
20:12:56 <benzrf> :t over (partsOf bits) reverse
20:12:57 <lambdabot> (Bits t, Num t) => t -> t
20:12:59 <benzrf> :)
20:13:09 <benzrf> > over (partsOf bits) reverse 8
20:13:12 <lambdabot>  mueval-core: Time limit exceeded
20:13:16 <mniip> fun
20:13:20 <benzrf> oh crud i forgot
20:13:26 <benzrf> that's not how it works >.<
20:13:27 <mniip> > over (partsOf bits) reverse (8 :: Int)
20:13:29 <lambdabot>  1152921504606846976
20:13:40 <benzrf> nice
20:14:10 <benzrf> > over bits not (8 :: Int)
20:14:12 <lambdabot>  -9
20:14:17 <benzrf> oooh nice
20:14:25 <benzrf> i forgot that's how it works as a representation
20:14:33 <rasen> > over (partsOf bits) reverse (8 :: Word8)
20:14:34 <lambdabot>  16
20:14:48 <mniip> > complement (8 :: Int)
20:14:49 <lambdabot>  -9
20:14:53 <mniip> pls
20:15:00 <benzrf> haha nice
20:18:32 <benzrf> lens is nifty
20:19:05 <rasen> where `bits` come from?
20:19:16 <Clint> rasen: http://hackage.haskell.org/package/lens-4.7/docs/Data-Bits-Lens.html#v:bits
20:19:39 <rasen> ok. b = ((b * 0x0802LU & 0x22110LU) | (b * 0x8020LU & 0x88440LU)) *  0x10101LU >> 16;
20:19:53 <rasen> ok. b = ((b * 0x0802LU & 0x22110LU) | (b * 0x8020LU & 0x88440LU)) *  0x10101LU >> 16;
20:20:14 <rasen> this trick is fine
20:21:02 <Clint> didn't you want to operate on a Word8?
20:21:13 <rasen> yep
20:21:34 <Clint> ah
20:26:17 <mniip> foldr (.|.) zeroBits . ap (map . (bit .) . (-) . bitSize) (liftM2 filter testBit (enumFromTo 1 . bitSize))
20:26:35 <mniip> actually that's output of @pl, the thing I wrote is
20:26:36 <mniip> f x = foldr (.|.) zeroBits $ map (bit.((bitSize x)-)) $ filter (testBit x) [1..bitSize x]
20:29:43 <sdegutis_> Anyone have opinions on xmonad's source?
20:33:31 <gcganley> sdegutis_: I've been meaning to read the core but havent gotten to it
20:33:55 <sdegutis_> You mean http://code.haskell.org/xmonad/src/XMonad/Core.hs ?
20:34:18 <gcganley> yes
20:34:37 <sdegutis_> It looks really well commented.
20:34:48 <sdegutis_> With a little syntax highlighting, this'll be pretty easy to read.
20:35:24 <sdegutis_> ok, off to re-read http://learnyouahaskell.com/for-a-few-monads-more#reader
20:35:34 <benzrf> sdegutis_: i can explain reader p well
20:35:37 <benzrf> if u interested
20:35:56 <dedgrant> Anyone around familiar with cabal x86_64 mingw32 linkage issues? Trying to figure out why one project will load sdl2 (x86_64) fine, whereas another gives the dreaded "mingw32: The specified module could not be found." error (same dep)
20:36:05 <sdegutis_> benzrf: feel free if you want, but I still might not get it
20:36:09 <sdegutis_> benzrf: I think an example works best
20:36:09 <benzrf> ok!
20:36:12 <gcganley> dedgrant: there be dragons...
20:36:17 <dedgrant> yes
20:36:18 <benzrf> sdegutis_: well, have you been told about monads a la join
20:36:31 <dedgrant> willing to debug cabal if needed darnit
20:36:32 <sdegutis_> um, maybe?
20:36:38 <benzrf> sdegutis_: well, what have you heard
20:37:05 <gcganley> dedgrant: I've dont a lot of hacking on dynamic linking and its given me numerous migranes. i just ended up running an arch linux vm
20:37:16 <sdegutis_> benzrf: I read a lot about monads so far, and I understand the [] monad, the IO monad, and the Maybe monad.
20:37:32 <sdegutis_> benzrf: and I think I get the Reader monad in theory, but no idea how to use it in practice
20:37:34 <benzrf> hmmm
20:37:43 <benzrf> sdegutis_: the key to understanding monads in general is
20:37:48 <benzrf> sdegutis_: (>>=) is an obfuscation
20:37:49 <dedgrant> gcganley: Yea longstanding issue with lack of Windows devs. Want to see if I can get to the root of some of these, or at least surface the causes again and get a solution
20:38:03 <benzrf> sdegutis_: in a more just world, Monad would look like this:
20:38:17 <benzrf> class Functor m => Monad m where
20:38:21 <benzrf>   return :: a -> m a
20:38:27 <benzrf>   join :: m (m a) -> m a
20:38:59 <gcganley> dedgrant: I want to learn how to do it... I have a project that uses both C# and Haskell. (haskell backend, C# front end). It was a pain because i only know how to compile .so and not .lib... its really annoying
20:39:10 <sdegutis_> benzrf: that looks like bind
20:39:15 <sdegutis_> ie, >>=
20:39:17 <gcganley> benzrf: you really belive in the fmap, return, join over bind
20:39:22 <benzrf> gcganley: yes
20:39:24 <nitrix> I'm having a hard time picking between C and Haskell for a project.
20:39:31 <benzrf> sdegutis_: stare
20:39:34 <benzrf> stare at the join signature!
20:39:37 <nitrix> Like I've been debating for a week now.
20:39:41 <sdegutis_> nitrix: well C is boring and fun, but Haskell is boring and fun
20:39:45 <gcganley> :t join
20:39:46 <lambdabot> Monad m => m (m a) -> m a
20:39:46 <sdegutis_> nitrix: just, in a different way
20:39:50 <gcganley> :t fmap
20:39:51 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:39:53 <benzrf> sdegutis_: if you have join as a class method, you can define (>>=) as a separate function
20:39:56 <benzrf> sdegutis_: like so:
20:39:59 <gcganley> :t fmap join
20:40:00 <lambdabot> (Functor f, Monad m) => f (m (m a)) -> f (m a)
20:40:02 <benzrf> x >>= f = join (fmap f x)
20:40:12 <gcganley> got it backward
20:40:12 <benzrf> sdegutis_: for exaple
20:40:18 <benzrf> sdegutis_: join for lists is just concat
20:40:23 <rasen> nitrix: what's the project?
20:40:23 <gcganley> :t (\f x -> join (fmap f x))
20:40:24 <lambdabot> (Functor m, Monad m) => (a1 -> m a) -> m a1 -> m a
20:40:25 <dedgrant> nitrix: Project requirements should help decision. What do you want to achieve?
20:40:28 <benzrf> sdegutis_: so (>>=) for lists is map followed by concat
20:40:31 <sdegutis_> benzrf: you're describing mappend it seems
20:40:37 <nitrix> dedgrant: sdegutis_: It's a file system, so I feel I'd gain from Haskell's safety, but at the same time, all the FUSE stuff of linux/unix libraries are just so readily available/simple with C.
20:40:39 <benzrf> no i most certainly am notd
20:40:45 <sdegutis_> benzrf: wait, >>= for lists is mapcat?
20:40:46 <benzrf> sdegutis_: mappend :: m -> m -> m
20:40:48 <benzrf> sdegutis_: yes
20:40:53 <sdegutis_> oh duh, why didn't I see that before!
20:40:59 <benzrf> sdegutis_: join :: m (m a) -> m a
20:41:13 <sdegutis_> benzrf: join confuses me; also where does it come into play?
20:41:16 <benzrf> sdegutis_: the fundamental ability that the Monad class adds, is the ability to collapse a nested structure
20:41:23 <gcganley> benzrf: its mapcat? i use that a ton in clojure when i was obsessed with Lisp. i didnt realize that was the join operation for the list monad
20:41:33 <sdegutis_> oooh
20:41:35 <benzrf> sdegutis_: a Monad is a Functor that has meaningful return and join
20:41:41 <rasen> nitrix: in real world I would choose C. But it may be fun to implement it in Haskell
20:41:43 <sdegutis_> gcganley: heh
20:41:44 <gcganley> benzrf: that and concatmap
20:41:58 <benzrf> gcganley: no, concatmap is just map followed by join
20:42:07 <benzrf> sdegutis_: the monad laws are simply that fmapping a join and then joining is the same as joining twice
20:42:12 <sdegutis_> rasen: why not choose Haskell for real world? it's legit
20:42:12 <gcganley> benzrf: I'm talking about clojrue
20:42:14 <benzrf> sdegutis_: and that returning then joinining does nothing
20:42:25 <benzrf> sdegutis_: and that fmapping return and then joining does nothing
20:42:44 <benzrf> sdegutis_: that is, if you have a nested structure, you can collapse it from the inside out or the outside in and it works both ways
20:42:47 <sdegutis_> ok
20:42:48 <rasen> sdegutis_: Mainly because I've implemented a couple of filesystems and hacked another two in C.
20:42:48 <sdegutis_> thanks
20:42:54 <sdegutis_> rasen: whoa
20:42:58 <benzrf> sdegutis_: and nesting added by return evaporates when you join it
20:43:27 <rasen> sdegutis_: and it would be first in Haskell.
20:43:39 <rasen> C is more... confident for me
20:43:45 <benzrf> sdegutis_: you listenin?
20:44:03 <sdegutis_> benzrf: yes I said "ok thanks" to you :)
20:44:12 <dedgrant> nitrix: C interop isn't too badin ghc, but it will proably be significant extra work to satisfy haskell and rethink performance.
20:44:15 <gcganley> rasen: as my teacher would say "Thats a you problem"
20:44:31 <benzrf> sdegutis_: well the timing seemed sort of "yeah thx ok :)" given to you by somebody in the middle of something else
20:44:34 <dedgrant> nitrix: As an exploration, could be incredibly useful.
20:44:43 <sdegutis_> benzrf: sorry :)
20:44:44 <gcganley> rasen: and honestly i write logic in Haskell and glue in C
20:44:58 <benzrf> sdegutis_: anyway in this context there is a very natural way to view the reader monad
20:44:58 <sdegutis_> benzrf: I'm very sleepy so it's hard to convrsation correctly.
20:45:04 <benzrf> kk soz
20:45:06 <nitrix> dedgrant: Right. I'm so torn apart ;-;
20:45:08 <sdegutis_> benzrf: go on
20:45:38 <benzrf> sdegutis_: the key is to view an (r -> a) as an a that comes into being when immersed in an environment with an 'r' available
20:45:58 <benzrf> sdegutis_: alternatively, an `a' defined in terms of an `r' "environment variable"
20:46:35 <fread2282> is there any way for a try in trifecta to stop backtracking?
20:46:48 <fread2282> how can I debug an early returning parser?
20:46:51 <gcganley> can someone explain to me the Proxy type
20:46:57 <benzrf> sdegutis_: then "r -> r -> a" is like a dependent-on-env value that's in turn a dependent-on-env value
20:47:17 <dedgrant> nitrix: Simple search on hackage: https://hackage.haskell.org/package/HFuse-0.2.4.4/docs/System-Fuse.html
20:47:21 <benzrf> sdegutis_: join for the reader monad is "(r -> r -> a) -> (r -> a)"
20:47:25 <benzrf> sdegutis_: it looks like
20:47:32 <benzrf> join f = \r -> f r r
20:47:45 <benzrf> sdegutis_: in other words, both arguments are fed the same input
20:48:16 <mniip> that kind of makes sense if you substitute m in 'm m a -> m a' for (r ->)
20:48:21 <dedgrant> gcganley: Not sure I understand re: .so vs .lib. so is dynamic link, but lib is static link. Is that what you're referring to? Or Linux vs Win linkage?
20:48:30 <benzrf> sdegutis_: the environment-dependent value is extracted, and then that value is in turn treated as an environment-dependent value and is applied to the environment
20:49:00 <sdegutis_> benzrf: ooooh
20:49:33 <benzrf> sdegutis_: in this context, the Functor instance allows you to apply a function to the deferred result
20:49:39 <benzrf> sdegutis_: er, in this view
20:49:57 <sdegutis_> benzrf: sorry, I thought I was close to understanding this.. and then it just all went away
20:50:00 <fread2282> gcganley: data Proxy a = Proxy. Proxy is represented as () at runtime, but at compile time/type level it has a type argument that will be checked just like Identity. it doesn't matter if or where a type variable is used in a data decl, it's all treated the same by the type checker
20:50:06 <sdegutis_> benzrf: you're just really really smart for being able to understand this
20:50:11 <benzrf> sdegutis_: probably better to try when you arent sleepy
20:50:12 <sdegutis_> benzrf: but I don't think I can
20:50:17 <benzrf> sdegutis_: nah
20:50:27 <benzrf> sdegutis_: a lot of haskell concepts are extremely difficult
20:50:31 <benzrf> and take a while to really get ahold of
20:50:33 <benzrf> ive had 2 years
20:50:46 <sdegutis_> I learn best by seeing example code that demonstrates a concept.
20:50:52 <benzrf> check this out then:
20:50:53 <sdegutis_> That's what I've been looking for for the Reader monad.
20:51:07 <sdegutis_> But I can't find it.
20:51:11 <fread2282> sdegutis_: double = join (+)
20:51:21 <sdegutis_> fread2282: um
20:51:23 <fread2282> sdegutis_: const = return
20:51:23 <sdegutis_> :t join
20:51:24 <lambdabot> Monad m => m (m a) -> m a
20:51:25 <benzrf> @let data Config = Config {username :: String, userage :: Int}
20:51:27 <lambdabot>  Defined.
20:51:34 <sdegutis_> > join (+) $ 4
20:51:35 <lambdabot>  8
20:52:00 <fread2282> > return 1 :: Int
20:52:02 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
20:52:02 <lambdabot>              with actual type ‘m0 a0’
20:52:09 <benzrf> @let sampleConfig = Config {username = "benzrf", userage = 17}
20:52:11 <fread2282> > return 1 2 :: Int
20:52:11 <lambdabot>  Defined.
20:52:12 <lambdabot>  1
20:52:18 <benzrf> sdegutis_: ok, check this out
20:52:24 <benzrf> :t username
20:52:25 <lambdabot> Config -> String
20:52:32 <sdegutis_> benzrf: you're only 17?
20:52:35 <benzrf> yeh
20:52:46 <sdegutis_> (now I feel old)
20:52:47 <benzrf> sdegutis_: the normal way to look at this is as a function that extracts a string from a config
20:52:53 <mniip> I'm 16 :D
20:52:56 <athan> benzrf: You gotta stay low key
20:52:59 <athan> niggas
20:53:03 <athan> there are like
20:53:12 <athan> crazy robot diabolocal human eater things out there
20:53:16 <benzrf> k
20:53:19 <gcganley> dedgrant: dynamic vs static
20:53:19 <athan> that turn kids into slaves
20:53:20 <benzrf> sdegutis_: but
20:53:20 <athan> okay
20:53:26 <gcganley> I'm 17...
20:53:33 <benzrf> sdegutis_: however
20:53:38 <mniip> hehe beat yall
20:53:40 <sdegutis_> benzrf: go on
20:53:51 <monochrom> I am over 10000 years old
20:53:53 <sdegutis_> I own a house.
20:53:55 <benzrf> sdegutis_: you can also view `username' as a deferred String that becomes available when there's a Config "in scope'
20:53:56 <rasen> benzrf: For me haskell also took 2 years
20:53:58 <benzrf> "
20:54:00 <gcganley> monochrom: mel brooks?
20:54:01 <sdegutis_> And some land around it.
20:54:08 <monochrom> base two
20:54:09 <sdegutis_> Not sure how far down...
20:54:19 <sdegutis_> benzrf: that makes sense
20:54:23 <benzrf> sdegutis_: ok!
20:54:27 <sdegutis_> benzrf: how can you put that into a Reader and use it though?
20:54:32 <benzrf> that IS a Reader
20:54:36 <sdegutis_> !!!
20:54:37 <benzrf> here, look:
20:54:40 <sdegutis_> benzrf: show me
20:55:38 <benzrf> @let ageDescription = fmap (\age -> (++" is " ++ show age ++ " years old!")) userage
20:55:40 <lambdabot>  Defined.
20:56:00 <benzrf> sdegutis_: so i'm treating `userage' as a "deferred Int"
20:56:13 <dedgrant> gcganley: There's not a lot of difference. Linkage really happens almost the same way, just that there's extra code to map the dynamic lib image to the process if needed. Principles are the same on lin and win.
20:56:29 <benzrf> sdegutis_: i'm fmapping across its "future value" something that takes the number and gives something that appends an age description
20:56:34 <tsani> Can anyone tell me why the HTTP library's version version is 3000 ?
20:56:37 <benzrf> sdegutis_: so this is now a "deferred string function"
20:56:39 <tsani> *first version
20:56:47 <benzrf> :t ageDescription
20:56:48 <lambdabot> Config -> [Char] -> [Char]
20:56:50 <sdegutis_> Wait, that just returned a function I think.
20:56:54 <gcganley> dedgrant: except dynamic dll linking of haskell libraries is IMPOSSIBLE which kinda blows
20:56:55 <benzrf> sdegutis_: right
20:56:55 <sdegutis_> A "section".
20:57:14 <benzrf> sdegutis_: so in the presence of a Config, this appending-function becomes available
20:57:30 <gcganley> dedgrant: unless you got a port of GHC that performs some dark arts
20:57:36 <benzrf> :t (ageDescription defaultConfig)
20:57:37 <lambdabot> Not in scope: ‘defaultConfig’
20:57:39 <benzrf> erm
20:57:43 <benzrf> > (ageDescription sampleConfig)
20:57:44 <lambdabot>  <[Char] -> [Char]>
20:57:47 <gcganley> dedgrant: ancient magicks
20:57:48 <benzrf> > (ageDescription sampleConfig) "some guy"
20:57:50 <lambdabot>  "some guy is 17 years old!"
20:58:16 <benzrf> sdegutis_: so this is where Applicative for Reader comes into play
20:58:20 <benzrf> :t username
20:58:21 <lambdabot> Config -> String
20:58:25 <sdegutis_> I'm still stuck on that first thing with \age
20:58:30 <benzrf> sdegutis_: ok!
20:58:31 <benzrf> i'll back up
20:58:35 <gcganley> tsani: i never really questioned it...
20:58:37 <dedgrant> gcganley: There is definitely build pain, but I have numerous haskell binaries here that link both opengl and sdl2 DLLs.
20:58:45 <benzrf> sdegutis_: that's the function i'm mapping across userage
20:58:59 <sdegutis_> :t userage
20:59:00 <lambdabot> Config -> Int
20:59:15 <gcganley> dedgrant: how did you get past the fact that nothing in the ghc standard library is compiled dynamicaly
20:59:25 <benzrf> sdegutis_: userage is a "deferred Int"
20:59:26 <sdegutis_> benzrf: Oh so, the int returned from userage will go into this functino which then returns another function which ultimately returns a string?
20:59:28 <tsani> gcganley: I'm building dependencies for a package, and the fact that HTTP is at version 4000 dawned on me. So I wondered where it all started.
20:59:31 <benzrf> sdegutis_: right
20:59:40 <sdegutis_> Right, because fmap on functions is the same as (.)
20:59:43 <benzrf> sdegutis_: but the key is to think of the userage function as a "deferred Int" waiting on a Config
20:59:53 <sdegutis_> With the rightmost one first, like f . g
20:59:55 <benzrf> sdegutis_: while thinking of the section as a normal function
20:59:58 <benzrf> so like
21:00:00 * hackagebot stable-tree 0.6.1 - Trees whose branches are resistant to change  http://hackage.haskell.org/package/stable-tree-0.6.1 (tsuraan)
21:00:05 <benzrf> Reader Config (String -> String)
21:00:06 <dedgrant> gcganley: Why would it need to be? In my case only the external native dependencies are linked as DLLs. The OS does this.
21:00:10 <sdegutis_> benzrf: okay, I see
21:00:13 <benzrf> alright!
21:00:20 <benzrf> @let runReader = id
21:00:20 <sdegutis_> > :t Reader Config (String -> String)
21:00:21 <lambdabot>  Defined.
21:00:21 <lambdabot>  <hint>:1:1: parse error on input ‘:’
21:00:28 <sdegutis_> :t Reader Config (String -> String)
21:00:29 <lambdabot>     Not in scope: data constructor ‘Reader’
21:00:29 <lambdabot>     Perhaps you meant ‘ReaderT’ (imported from Control.Monad.Reader)
21:00:29 <lambdabot>     Pattern syntax in expression context: String -> String
21:00:34 <sdegutis_> blarg
21:00:34 <benzrf> > (runReader ageDescription sampleConfig) "some guy"
21:00:36 <lambdabot>  Ambiguous occurrence ‘runReader’
21:00:36 <lambdabot>  It could refer to either ‘L.runReader’, defined at L.hs:176:1
21:00:36 <lambdabot>                        or ‘Control.Monad.Trans.Reader.runReader’,
21:00:42 <benzrf> > (L.runReader ageDescription sampleConfig) "some guy" -- sdegutis_
21:00:43 <dedgrant> gcganley: Are you trying to make a ghc produced DLL available to .net?
21:00:43 <fread2282> @let type Reader r a = r -> a
21:00:44 <lambdabot>  "some guy is 17 years old!"
21:00:44 <lambdabot>  Defined.
21:00:53 <sdegutis_> wait sdegutis_ ?
21:00:54 <benzrf> sdegutis_: ok now
21:00:55 <sdegutis_> fixing that.
21:00:58 <sdegutis> fixed.
21:01:09 <sdegutis> wait wait wait
21:01:13 <sed-utils> ok fixed.
21:01:17 <gcganley> dedgrant: my project is https://github.com/gcganley/subnet. what i did was link the RTS and my haskell library to a C# program and treated it as an unmanaged C library that i could call from
21:01:17 <benzrf> sed-utils: so ageDescription is a deferred String -> String
21:01:25 <benzrf> sed-utils: and username is a deferred String
21:01:36 <benzrf> sed-utils: so i can get another deferred String by using (<*>)
21:01:43 <benzrf> :t ageDescription <*> username
21:01:44 <lambdabot> Config -> [Char]
21:01:52 <sed-utils> benzrf: functors I totally already get
21:02:01 <sed-utils> benzrf: fmap is easy compared to monads
21:02:11 <sed-utils> <$> and <*> are really simple
21:02:18 <benzrf> :t L.runReader (ageDescription <*> username) sampleConfig
21:02:19 <sed-utils> it's >>= that's crazay
21:02:19 <lambdabot> [Char]
21:02:20 <gcganley> dedgrant: The thing is i can get it to work on linux using mono but not on Visual Studio
21:02:29 <ab9rf> heh
21:02:35 <benzrf> > L.runReader (ageDescription <*> username) sampleConfig
21:02:37 <lambdabot>  "benzrf is 17 years old!"
21:02:43 <gcganley> Good morning all!!!
21:02:43 <sed-utils> > sampleConfig
21:02:44 <benzrf> sed-utils: yes, the reason (>>=) makes no sense is that it's really 2 functions in one
21:02:45 <lambdabot>  No instance for (GHC.Show.Show L.Config)
21:02:45 <lambdabot>    arising from a use of ‘M458677631632602238629405.show_M4586776316326022386...
21:02:59 <sed-utils> benzrf: what is, >>= ?
21:03:01 <gcganley> on the east coast that is
21:03:12 <benzrf> sed-utils: as gfixler has said, trying to make sense of (>>=) without learning about fmap and join is like trying to make sense of git pull without learning about git fetch and git merge
21:03:28 <sed-utils> I get fmap
21:03:47 <benzrf> sed-utils: in an alternate universe, Monad has the method join :: m (m a) -> m a instead of (>>=)
21:03:55 <sed-utils> lol
21:04:00 <benzrf> sed-utils: and (>>=) is declared separately, as an auxiliary function defined in terms of join
21:04:01 <sed-utils> i think i need o slep
21:04:02 <sed-utils> sorry
21:04:04 <benzrf> kk
21:04:06 <ab9rf> hehe
21:04:21 * ab9rf throws an oslep at sed-utils
21:07:26 <gcganley> is there any way to read types from lens without being striken with fear?
21:07:39 <ab9rf> heh
21:07:47 <ab9rf> lens, now with Fear +3
21:09:40 <glguy> The way to do that (read lens types without extra fear) is to look at them with :info or in the haddocks so that they have their type synonyms still
21:13:30 <dedgrant> gcganley: I'm not sure I understand how that cs program builds...
21:14:06 <dedgrant> gcganley: (no dllimport etc)
21:14:37 <tsani> A library that my project depends on was missing a feature, so I added that feature to the library. How can I make cabal use my patched version of the library instead of the one I've installed to the sandbox?
21:15:33 <dedgrant> gcganley: But so long as ghc actually produces a valid DLL, it can be p/invoked like any other native lib.
21:15:42 <glguy> dedgrant: He left
21:16:09 <dedgrant> *vanish* :)
21:16:11 <glguy> tsani: "cabal help sandbox" and read about add-source
21:18:43 <tsani> glguy: thanks! add-source does the trick :)
21:25:53 <benzrf> let 2 = 3 in 2 + 2
21:25:59 <benzrf> > let 2 = 3 in 2 + 2
21:26:00 <lambdabot>  4
21:26:10 <benzrf> > let 2 + 2 = 5 = 2 + 2
21:26:11 <lambdabot>  <hint>:1:15: parse error on input ‘=’
21:26:13 <benzrf> > let 2 + 2 = 5 in 2 + 2
21:26:14 <lambdabot>  5
21:26:20 <mikeplus64> > let !2 = 3 in 2 + 2
21:26:21 <lambdabot>  *Exception: <interactive>:3:5-10: Non-exhaustive patterns in pattern binding
21:27:40 <Lokathor> when defining modules for a program, is there any advice for canonical module name pathing like java has?
21:28:12 <obb> format :: String -> String
21:28:12 <obb> format representation = rmSpaces $ rmEmptyLines representation
21:28:12 <obb>  how can i curry this?
21:28:29 <mniip> how can you... curry a one-argument function?
21:28:34 <Lokathor> obb you can't because it's already got only 1 argument
21:28:52 <obb> oh i see
21:28:54 <fread2282> obb: format representation = rmSpaces . rmEmptyLines          ?
21:28:56 <Lokathor> currying applies some arguments and then leaves others to be applied later. maybe you want something else?
21:29:01 <fread2282> obb: format = rmSpaces . rmEmptyLines          ?
21:29:05 <fread2282> whops, ^
21:29:18 <mniip> what fread2282 did is called point-free representation
21:29:25 <mniip> also known as point-less
21:29:35 * Lokathor chuckles
21:29:48 <obb> ok looks like i got that mixed up :)
21:30:44 <obb> thanks fread2282 seems to work
21:30:53 <mniip> obb, also
21:30:58 <mniip> @pl format representation = rmSpaces $ rmEmptyLines representation
21:30:58 <lambdabot> format = rmSpaces . rmEmptyLines
21:31:16 <mniip> (use that in PM to lambdabot though if you want to spam)
21:31:38 <obb> wow thanks mniip
21:32:54 <mniip> it can even do crazy stuff like
21:32:57 <mniip> @pl \x y -> x (y y) (x y x x)
21:32:57 <lambdabot> liftM2 ap (. join id) (flip =<< join flip)
21:33:05 <mniip> ignoring the invalid infinite types
21:33:05 <Lokathor> yikes
21:33:13 <benzrf> @pl \x -> x x
21:33:13 <lambdabot> join id
21:33:17 <benzrf> :t join id
21:33:18 <lambdabot>     Occurs check: cannot construct the infinite type: a1 ~ a1 -> a
21:33:18 <lambdabot>     Expected type: a1 -> a1 -> a
21:33:18 <lambdabot>       Actual type: a1 -> a1
21:33:21 <benzrf> :-[
21:33:53 <Lokathor> mniip is that sort of thing available in ghci or elsewhere besides lambdabot?
21:33:58 <mniip> yeah I think
21:34:10 <mniip> @hackage pointfree
21:34:10 <lambdabot> http://hackage.haskell.org/package/pointfree
21:34:25 <Lokathor> ah-ha
21:34:52 <Lokathor> oh i almost forgot my question: is there any sort of canonical package name scheme in haskell like java has?
21:35:02 * hackagebot deepseq-bounded 0.7.0.0 - Bounded deepseq, including support for generic deriving  http://hackage.haskell.org/package/deepseq-bounded-0.7.0.0 (AndrewSeniuk)
21:35:04 * hackagebot seqaid 0.3.0.0 - Dynamic strictness control, including space leak repair  http://hackage.haskell.org/package/seqaid-0.3.0.0 (AndrewSeniuk)
21:35:06 * hackagebot leaky 0.3.0.0 - Robust space leak, and its strictification  http://hackage.haskell.org/package/leaky-0.3.0.0 (AndrewSeniuk)
21:39:31 <mniip> what about
21:39:32 <mniip> @pl \x y z w t -> x (y (x (z w)) (x (w y t) t))a
21:39:33 <lambdabot> flip flip a . ((flip . ((flip . (flip .)) .)) .) . ap ((.) . (.) . (.) . (.)) (ap (ap . ((flip . (liftM2 (.) .)) .) . flip ((.) . (.)) . (.)) (flip flip id . ((flip . (ap .)) .) . (. flip id) . (.) . (.)))
21:39:36 <mniip> oops
21:39:37 <mniip> @pl \x y z w t -> x (y (x (z w)) (x (w y t) t))
21:39:38 <lambdabot> ap ((.) . (.) . (.) . (.)) (ap (ap . ((flip . (liftM2 (.) .)) .) . flip ((.) . (.)) . (.)) (flip flip id . ((flip . (ap .)) .) . (. flip id) . (.) . (.)))
21:39:39 <benzrf> gross
21:43:33 <mniip> oh look
21:43:36 <mniip> it can even djinn that
21:43:59 <obb> readTerms text = (Mpt terms) where terms = lines text << can i abbreviate that somehow?
21:44:28 <mniip> readTerms = Mpt . lines
21:44:43 <obb> nice
21:44:52 <mniip> also why not just write '(Mpt $ lines text)'
21:44:56 <obb> ah
21:45:05 <obb> mpt is not a function i should mention
21:45:17 <mniip> all data constructors are functions
21:45:23 <obb> ah ok
21:45:25 <mniip> :t Maybe
21:45:26 <lambdabot> Not in scope: data constructor ‘Maybe’
21:45:26 <obb> thanks
21:45:29 <glguy> or even better : Mpt (lines text) -- no need to use more operators than you have to
21:45:32 <mniip> :t Just
21:45:33 <lambdabot> a -> Maybe a
21:45:49 <mniip> yeah that
21:46:02 <mniip> although I would've preferred $ to () in that specific case
21:47:26 <mniip> waaaait what
21:47:43 <mniip> you can represent any function as point-free with just id, const, and <*> ?
21:48:45 <mniip> so what pointfree does is just try to translate the SKI calculus into as many Common Haskell functions as possible?
21:49:14 <fread2282> mniip: also (.)/fmap
21:49:26 <fread2282> and flip
21:49:31 <mniip> those aren't needed
21:49:40 <fread2282> oh?
21:49:46 <fread2282> wow
21:50:10 <fread2282> @pl \f a b -> f b a
21:50:10 <lambdabot> flip
21:50:34 <athan> :)
21:51:04 <mniip> sec I'll try to
21:56:44 <mniip> (. const) . (<*>)
21:57:11 <fread2282> !
21:57:17 <fread2282> :t (. const) . (<*>)
21:57:17 <lambdabot> (b -> a -> b1) -> a -> b -> b1
21:57:39 <glguy> Now you just need to get rid of the composition
21:57:46 <mniip> oh right
21:57:51 <mniip> the . thing
21:58:29 <mniip> sec
21:59:44 <mniip> I might have just come up with fmap by accident?
22:00:21 <benzrf> haha
22:00:26 <fread2282> mniip: fmap = (.) :)
22:00:27 <mniip> but there you go
22:00:27 <mniip> const (const (<*> const) <*> const) <*> (<*>)
22:00:40 <enthropy> for uu-parsinglib, does it make any sense that "a <|> b" fails while "a" succeeds?
22:01:18 <mniip> fread2282, only in context of Monad (r ->)
22:01:26 <fread2282> mniip: true
22:01:28 <mniip> er
22:01:35 <mniip> Functor (r ->)
22:02:55 <mniip> oh wait
22:02:58 <fread2282> how can I debug an early returning parser?
22:03:01 <mniip> that's what we're talking about yes
22:03:15 <mniip> fread2282, the good old Debug.trace ?
22:03:19 <mniip> Debug.Trace.trace
22:05:11 <obb> data Mpt = Mpt [String] deriving (Show) << i have this in a separate module and import it to another module. but i get "not in scope" errors when my functions from the other module want to use it
22:05:37 <ttt_fff> so I'm using ipython ... and it's absolutely amazing .... is there anyway to do "interactive/repl" dev in haskell? or is haskell forced to be code in vim/emacs, compile, get compile errors, fix errors, ....
22:06:44 <mniip> obb, are you exporting it
22:06:59 <obb> how would i do that?
22:08:13 <Hijiri> ttt_fff: ghci is the ghc compiler's repl
22:08:19 <mniip> obb, module Whatever ( Mpt(..)
22:08:35 <mniip> ttt_fff, ghci yes
22:08:37 <jle`> there's ghci and also a haskell version of ipython
22:08:52 <obb> thanks
22:09:02 <ttt_fff> Hijiri, mniip, jle`: is there a good youtube somewhere of someone doing repl devl in ghci then copying/pasting code over?
22:09:05 <ttt_fff> I would love to mimic and learn
22:09:09 <mniip> yes
22:09:19 <mniip> http://www.youtube.com/watch?v=RqvCNb7fKsg
22:09:34 <jle`> nice :)
22:11:59 <mniip> hfeflflfof fsfaftfofsfhfi
22:12:00 <mniip> :P
22:19:46 <ttt_fff> is there an emacs variant of: http://www.stephendiehl.com/posts/vim_haskell.html ?
22:20:59 <mniip> oh man
22:21:03 <mniip> I should sintall some of those
22:23:03 <ttt_fff> yeah
22:23:05 <ttt_fff> i saw that page
22:23:12 <ttt_fff> and was like fuck, maybe i should go back to vim
22:24:34 <jle`> aw, i already have those installed
22:24:40 * jle` is slightly disappointed
22:25:52 <mniip> well I am using vim
22:26:09 <MP2E> I really should install some stuff for emacs and haskell integration
22:26:16 <MP2E> i just use whatever it comes with
22:26:17 <MP2E> :X
22:26:18 <MP2E> and hlint
22:29:57 <Hijiri> I'm using haskell-mode in emacs
22:29:59 <Hijiri> and some other things
22:30:36 <EvanR> at first when i randomly found a relevant page of RWH, and it seemed to make sense, now i may have back myself into a corner. representing a bunch of C-style bit flags in a way to is nice to the user
22:30:58 <EvanR> going with RWH i have a view of a structure that looks like [ModuleFlag]
22:31:33 <EvanR> but it will appear as [ModuleFlag { marshalModuleFlag = 4 }, ModuleFlag { marshalModuleFlag = 16 }]
22:31:39 <EvanR> not informative
22:32:39 <mniip> huh
22:32:53 <mniip> autocmd BufEnter *.hs set formatprg=pointfree
22:32:59 <mniip> implies that pointfree takes code on stdin
22:33:11 <mniip> meanwhile it takes it via arguments
22:38:47 <mniip> needs like
22:38:49 <mniip> au FileType haskell set formatprg=pointfree\ \"$(cat)\"
22:39:00 <mniip> someone should probably poke the author of that page
22:39:11 <dawik> whats with programmers and cats
22:39:31 <mniip> well excuse me I'm redirecting stdin into a string
22:39:47 <dawik> i know, just trying to be funny
22:39:51 <mniip> I know
22:55:06 * hackagebot deepseq-bounded 0.7.0.1 - Bounded deepseq, including support for generic deriving  http://hackage.haskell.org/package/deepseq-bounded-0.7.0.1 (AndrewSeniuk)
22:55:38 <Lokathor> it looks like i can't use hspec with websockets
22:55:53 <Lokathor> cabal tells me my packages would explode because of versioning
23:00:29 <Lokathor> mmm, once again deleting the entire sandbox and doing it again fixes the issue
23:00:36 <ab9rf> exploding packages, brought to yo by the cabal!  happy boomday!
23:14:31 <obb> how can i import Data.List.Split?
23:14:47 <obb> getting "cant find module"
23:14:58 <glguy> You have to have the "split" package installed
