00:09:21 * hackagebot json-rpc-server 0.1.4.0 - JSON-RPC 2.0 on the server side.  http://hackage.haskell.org/package/json-rpc-server-0.1.4.0 (grayjay)
00:09:21 * hackagebot hi 1.0.0.0 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-1.0.0.0 (DaisukeFujimura)
00:10:19 <supki> Welkin: you can do something like this with lens: http://lpaste.net/1263275389287923712
00:10:26 <supki> doesn't even use Attr
00:14:49 <Welkin> that's interesting
00:14:51 <Welkin> thanks supki
00:15:19 <hrumph_> thang1 i think i got it
00:15:22 <hrumph_> http://pastebin.com/ztQcwuSh
00:15:48 <hrumph_> i've made sure that the state transitions are enforced by using the the "enforce" function
00:17:40 <hrumph_> it looks like its gonna work but i haven't designed any tests for it....
00:19:00 <hrumph_> what a monad
00:30:04 <rootnode> happy new year everyone
01:31:50 <chrisdotcode> Is it true that haskell flattens this: `map (+2) $ map (+5) [1..5]` into O(N) because of laziness?
01:33:58 <pavonio> Yes
01:34:23 <chrisdotcode> pavonio: Thanks
01:34:51 <chrisdotcode> pavonio: And that works across the IO monad ,if there happen to be IO computations relating to lists somewhere in a string of list functions as well?
01:36:24 <pavonio> Hhm, that depends on how these function suse their input
02:22:52 <JohnSmith> is writing a game a good way to learn haskell?
02:30:48 <JohnSmith> I find java easier to write correct programs in, what is wrong with haskell
02:32:50 <sinelaw> JohnSmith, example?
02:33:15 <JohnSmith> just in general, you don't have to write the algorithm again in java cause it works most of the time
02:33:28 <JohnSmith> in haskell it says it works but then it doesn't
02:34:26 <sinelaw> JohnSmith, this actually happened to you?
02:35:01 <JohnSmith> my haskell algorithm kept on recursing too much, so it was lagging my cpu
02:35:05 <augur_> i must agree -- what do you mean, JohnSmith? what examples do you have of this happening?
02:35:08 <JohnSmith> my java version used hashmaps so it worked
02:35:46 <augur_> JohnSmith: why didnt you haskell version use hashmaps?
02:36:11 <sinelaw> JohnSmith, so you wrote a bug in haskell?
02:36:29 <JohnSmith> the haskell map didn't provide the functionality I needed
02:36:36 <JohnSmith> so I used a recursive map instead
02:36:43 <augur_> JohnSmith: are you sure? it probably did
02:36:49 <augur_> you should paste your code
02:36:59 <sinelaw> JohnSmith, an actual example would really help
02:37:12 <JohnSmith> I tried using a haskell map, but the function didn't work as appropriate
02:37:29 <sinelaw> JohnSmith, you mean it didn't do what you expected it to do?
02:37:32 <JohnSmith> my game worked in java though, so why would I use haskell
02:37:47 <sivteck> no reason!
02:38:00 <augur_> JohnSmith: you should really post your code
02:38:12 <chrisdotcode> Can someone help me refactor the follow piece of short code?:
02:38:15 <chrisdotcode> case (foo) of
02:38:16 <chrisdotcode>     (Just bar) -> writeFile file $ f x y z
02:38:16 <chrisdotcode>     Nothing    -> putStrLn $ f x y z
02:38:34 <augur_> chrisdotcode: fwiw you dont need the parens there
02:38:45 <sinelaw> chrisdotcode, you don't use 'bar' in the Just case?
02:38:46 <chrisdotcode> The "f x y z" is repeated, and I could use a varialbe, but I want to know if maybe has a way to do stuff like that inately
02:39:19 <chrisdotcode> er, sorry, the `bar` == `file`
02:39:34 <chrisdotcode> case (foo) of
02:39:35 <chrisdotcode>     Just file  -> writeFile file $ f x y z
02:39:35 <chrisdotcode>     Nothing -> putStrLn $ f x y z
02:39:39 <augur_> chrisdotcode: you can always make a let statement if you want
02:39:44 <chrisdotcode> Does maybe have any niceties for this, or am I stick with let?
02:39:50 <augur_> let v = f x y z in case ...
02:39:55 <chrisdotcode> Yeah, I figured as much; thought let might be the only way.
02:40:03 <chrisdotcode> Thanks guys
02:40:05 <augur_> not the only way, but
02:40:13 <augur_> i mean, you could do like
02:40:21 <augur_> (case ...) (f x y z)
02:40:33 <augur_> where the case returns either writeFile file or putStrLn
02:40:42 <augur_> eh.. you could also use the maybe function
02:40:45 <augur_> :t maybe
02:40:46 <lambdabot> b -> (a -> b) -> Maybe a -> b
02:40:58 <augur_> maybe putStrLn writeFile (f x y z)
02:41:02 <augur_> er woops
02:41:06 <augur_> maybe putStrLn writeFile foo (f x y z)
02:41:29 <augur_> @src maybe
02:41:29 <lambdabot> maybe n _ Nothing  = n
02:41:29 <lambdabot> maybe _ f (Just x) = f x
02:41:30 <chrisdotcode> wouldn't it need to be (const writeFile)?
02:41:37 <augur_> no
02:41:53 <augur_> you want to apply writeFile to the contents of the just
02:41:53 <chrisdotcode> :t maybe putStrLn (writeFile "f")
02:41:54 <lambdabot>     Couldn't match type ‘IO ()’ with ‘String -> IO ()’
02:41:54 <lambdabot>     Expected type: String -> String -> IO ()
02:41:54 <lambdabot>       Actual type: String -> IO ()
02:42:05 <augur_> :t maybe putStrLn writeFile
02:42:07 <lambdabot> Maybe FilePath -> String -> IO ()
02:42:27 <chrisdotcode> right, that's it.
02:42:36 <chrisdotcode> I knew there was something simple I was overlooking
02:42:39 <chrisdotcode> thanks, augur_
02:42:42 <augur_> :)
02:42:55 <augur_> there are often combinators that wrap up certain case patterns
02:43:17 <chrisdotcode> Which was my primary thought.
02:43:24 <chrisdotcode> I much prefered a one-line combinator.
02:43:36 <chrisdotcode> I thought maybe could do it, but I applied it wrong.
02:43:42 <chrisdotcode> Had a brainfart.
02:43:47 <augur_> so chrisdotcode: you can refactor to   (case foo of { Nothing -> putStrLn ; Just file -> writeFile file }) (f x y z)   right
02:44:02 <augur_> which of course is just   maybe putStrLn writeFile
02:44:05 <chrisdotcode> augur_: Which was what my intuition was looking for.
02:44:06 <augur_> (f x y z)
02:44:13 <chrisdotcode> But the combinator is nicer :D
02:44:54 <augur_> chrisdotcode: yeah. you could try the following technique: refactor to a convenient form like that, then use types to search hoogle
02:45:10 <augur_> @hoogle b -> (a -> b) -> Maybe a -> b
02:45:12 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
02:45:12 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
02:45:12 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
02:45:14 <chrisdotcode> I checked hoogle, but my searches were all off.
02:45:30 <chrisdotcode> I got it now.
02:45:32 <chrisdotcode> Thanks, augur_.
02:45:35 <augur_> np
02:54:22 * hackagebot ll-picosat 0.1.0.0 -   http://hackage.haskell.org/package/ll-picosat-0.1.0.0 (DanielWaterworth)
03:02:41 <Phillemann> Is there a type class capturing the notion of "elem"?
03:03:43 <Phillemann> So like "HasElem (a x) => a x -> x -> Bool"
03:04:09 <Phillemann> Oh, Foldable has this function, hmm.
03:24:14 <chrisdotcode> @src filterM
03:24:14 <lambdabot> Source not found. Maybe if you used more than just two fingers...
03:24:26 <chrisdotcode> pls lambdabot
03:24:30 <chrisdotcode> @src filterM_
03:24:30 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
03:25:35 <chrisdotcode> filterM f m = do { m' <- m; return $ filter f m'; } look about right?
03:29:23 * hackagebot eventstore 0.2.0.1 - EventStore Haskell TCP Client  http://hackage.haskell.org/package/eventstore-0.2.0.1 (YorickLaupa)
03:30:19 <pavonio> :t filterM
03:30:19 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
03:30:58 <pavonio> You defintion is something different
03:31:01 <pavonio> *Your
03:31:28 <adamse_> :t \f m -> do { m' <- m; return $ filter f m'; }
03:31:29 <lambdabot> Monad m => (a -> Bool) -> m [a] -> m [a]
03:31:32 <chrisdotcode> Oh, wow. I'm thinking of (a -> b) -> m [a] -> m [b]
03:31:39 <chrisdotcode> Yup.
03:32:06 <chrisdotcode> @hoogle Monad m => (a -> Bool) -> m [a] -> m [a]
03:32:07 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
03:32:07 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
03:32:07 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
03:32:17 <chrisdotcode> :t return filter
03:32:18 <lambdabot> Monad m => m ((a -> Bool) -> [a] -> [a])
03:32:24 <chrisdotcode> :t fmap filter
03:32:25 <lambdabot> Functor f => f (a -> Bool) -> f ([a] -> [a])
03:32:25 <adamse_> :t liftM filter
03:32:26 <lambdabot> Monad m => m (a -> Bool) -> m ([a] -> [a])
03:32:28 <chrisdotcode> ding ding ding
03:33:00 <chrisdotcode> adamse_: liftM == fmap, correct?
03:33:04 <adamse_> yep
03:33:11 <chrisdotcode> perfect
03:33:14 <chrisdotcode> thanks
03:33:33 <adamse_> :t \p -> liftM (filter p)
03:33:34 <lambdabot> Monad m => (a -> Bool) -> m [a] -> m [a]
03:33:56 <chrisdotcode> I'm surprised liftM filter isn't a think in Control.Monad
03:34:05 <chrisdotcode> s/think/thing
03:35:36 <adamse_> chrisdotcode: relevant discussion: http://thread.gmane.org/gmane.comp.lang.haskell.libraries/5280/focus=5322
03:36:15 <zwer_z_a> :t (filter <$>)
03:36:16 <lambdabot> Functor f => f (a -> Bool) -> f ([a] -> [a])
03:36:41 <zwer_z_a> :t fmap . filter
03:36:42 <lambdabot> Functor f => (a -> Bool) -> f [a] -> f [a]
03:39:31 <chrisdotcode> Is there lift1AndAHalf :: Monad m => (a -> b -> c) -> m a -> b -> c
03:39:34 <chrisdotcode> (Just kidding)
03:39:40 <chrisdotcode> * m c
03:39:49 <chrisdotcode> lift1AndAHalf :: Monad m => (a -> b -> c) -> m a -> b -> m c
03:40:00 <chrisdotcode> dang it, missed it again
03:40:03 <chrisdotcode> Whatever.
03:44:25 <zwer> :t \f mx y -> liftM (`f` y) mx
03:44:26 <lambdabot> Monad m => (a1 -> t -> r) -> m a1 -> t -> m r
03:47:13 <e11> hey guys, I got a question. I'm trying to use persistent to make some simple sqlite queries with Yesod and Haskell.
03:47:50 <e11> but the documentation for Persistent is out of date -- the code in the example book no longer runs, where should I look
04:08:07 <Loan-266> which of you live in detroit here ? à-
04:16:22 <khanage> hi all
04:16:43 <khanage> i'm writing a wrapper around an api
04:16:53 <khanage> and it uses underscores for types
04:17:02 <khanage> e.g. 'name_person':'etc'
04:17:25 <khanage> i'm using Data.Aeson.TH to derive json instances
04:18:01 <khanage> but i can't get idiomatic fields for haskell (e.g. pdNamePerson) to work
04:18:32 <lpaste> khanage pasted “Aeson derving” at http://lpaste.net/117568
04:19:11 <khanage> would someone with some experience in this area be so kind as to take a look and make some suggestions?
04:29:23 <lisbeth> let me run this idea by you guys
04:29:36 <vimes_> ok
04:29:50 <lisbeth> in a haskell shell a big problem when writing commands is how to incorporate the concept of "options" into the syntax of haskell
04:30:10 <lisbeth> mainly because in most shells with options all input and output starts as a string
04:30:16 <lisbeth> how about simply
04:30:36 <lisbeth> <command> "options" <input2> <input3>
04:30:46 <lisbeth> such as
04:31:00 <lisbeth> ls "a"
04:31:33 <lisbeth> To me that seems a better way than trying to add to the syntax of haskell
04:31:56 <lisbeth> also there is no reason why options in a command shouldn't be a string
04:32:09 <lisbeth> so it would be almost functionally the same
04:32:26 <lisbeth> you'd just have the hassle of typing the quotes
04:32:48 <vimes_> well it sounds good to me
04:33:31 <tremon> lisbeth: how would you separate multiple options?
04:33:59 <lisbeth> the syntax of the options is up to the whim of the person designing the command, but if this was the standard it would all be in the string
04:34:24 <lisbeth> so you could have a syntax like "-xbga" or "x b g a " or "xorg bash gimp apple"
04:34:38 <lisbeth> which is not very different from how bash or zsh works
04:39:06 <tremon> I'd prefer a list of strings, otherwise you will end up needing to have an escape sequence for whatever separator character you choose
04:40:32 <lisbeth> the reason I go against a list of strings is then it is easier to have a variable number of arguments
04:41:50 <tremon> I don't follow. Why is a the length of a list more variable than the length of a single string?
04:42:22 <lisbeth> I am a beginner at haskell so withing the scope of the syntax I know it is that way
04:42:33 <lisbeth> I may be unaware of a way to escape that, or maybe just not explaining it right
04:48:46 <tremon> what "variable number of arguments" are you considering? the number of parameters to a haskell expression, the argv array as passed to execv, something else?
04:53:07 <lisbeth> as far as my understanding of haskell stretches, a function has a fixed number of arguments
04:53:19 <lisbeth> I am here right now: http://learnyouahaskell.com/recursion
04:53:32 <lisbeth> so still very new
04:54:09 <tremon> ah, but a list is still just one argument
04:54:52 <lisbeth> exactly
04:55:06 <lisbeth> lets imagine I create the command foo
04:55:22 <lisbeth> and foo, in my shell called bar, has a set syntax for options
04:55:44 <lisbeth> and that is that options must be contained in a string in the first argument in the command
04:55:55 <lisbeth> foo "options" argument2
04:56:20 <lisbeth> the function foo I have created, would take whatever is in the string and evaluate it into the math it wants
04:56:32 <lisbeth> which is not so different from how commands in bash work
04:56:48 <lisbeth> because in bash all you do is deconstruct strings using math and use that to do more math
04:57:00 <lisbeth> then output that to a string (but now I am going off on a tangent)
04:57:29 <tremon> yes, in bash you do. But why would you in haskell construct a string, only to have it deconstructed by its recipient?
04:58:23 <Axman6> stringly typed programming should be avoided at all costs
04:59:22 * lisbeth is away from keyboard
05:00:35 <elfeck> I need a efficient version of set equality which will be called in a function with runtime O(n²) ... are there improvements to this version?
05:00:35 <elfeck> setEq :: Eq a => [a] -> [a] -> Bool
05:00:35 <elfeck> setEq s1 s2 = length s1 == length s2 && null (s1 \\ s2)
05:01:12 <tomejaguar> elfeck: Why not use a Set?
05:01:21 <Axman6> I wouldn't bother with the length check, your function will traverse both lists twice
05:01:30 <Axman6> Set implies Ord
05:01:57 <elfeck> Is the length-check really unnecessary?
05:02:43 <Axman6> hmm
05:03:31 <elfeck> [1,2,3] \\ [1,2,3,3] == []
05:03:58 <tomejaguar> Are they not the same set?  Presumably you want [1,2,3,4].
05:04:01 <Axman6> so to make a more efficient version, it would be good to know the type of the elements
05:04:30 <Axman6> if you can order the elements, then you can get O(n log n) algorithms very easily
05:04:33 <tremon> if sets are always ordered, wouldn't a loop with early-out semantics be better?
05:05:09 <tomejaguar> Hence my original question.  If elfeck is happy with an Ord constraint then just use Set.
05:05:11 <Axman6> well, that depends on if there is a notion of order for the elements of not
05:05:18 <elfeck> I cannot guarante Ord sadly but Int and [[Int]] is common
05:05:47 <tomejaguar> Pop quiz:  What types support Eq but not Ord?
05:06:01 <tremon> Bool, for one
05:06:10 <Axman6> > False < True
05:06:11 <lambdabot>  True
05:06:16 <tremon> argh. buh
05:06:17 <khanage> but true is greater than false!
05:06:17 <elfeck> Permutations (e.g. in Symmetric Group)
05:06:39 <elfeck> what is the runtime of my version?
05:06:47 <elfeck> with length and \\
05:07:06 <Axman6> O(n^2)
05:07:16 <tomejaguar> Why can permutations not be ordered?
05:07:25 <Axman6> but it seems more complex then it needs to be
05:07:31 <Axman6> @hoogle delete
05:07:32 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
05:07:32 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
05:07:32 <lambdabot> Data.IntMap.Strict delete :: Key -> IntMap a -> IntMap a
05:08:16 <elfeck> can you give me a order-relation tomejaguar?
05:08:39 <Axman6> > let f xs ys = null $ foldr (\x ys -> Data.List.delete x ys) ys xs in f [1,2,3] [1,2,3,3]
05:08:40 <lambdabot>  False
05:08:44 <tomejaguar> elfeck: On what?
05:08:53 <Axman6> > let f xs ys = foldr (\x ys -> Data.List.delete x ys) ys xs in f [1,2,3] [1,2,3,3]
05:08:54 <lambdabot>  [3]
05:08:55 <elfeck> permuations (in cyclenotation)
05:09:00 <tomejaguar> elfeck: On the permutations of n?
05:09:08 <tomejaguar> They biject with n!
05:09:28 <elfeck> with what function?
05:09:37 <tomejaguar> Well, that's a good question :)
05:09:47 <elfeck> I'm not so sure if that function exists
05:09:54 <elfeck> but didnt think much about it
05:10:21 <tomejaguar> It certainly exists.  There exist computable functions bijecting n! with S_n.
05:10:33 <elfeck> but should acutally since the permutations are disticnt
05:10:36 <elfeck> yes
05:10:44 <tomejaguar> I don't know how to write one nicely, but it may well be worth it to pick up a factor of n/log n.
05:11:09 <elfeck> problem is I work with algebraic groups and cannot guarante Ord in any case :|
05:11:15 <tomejaguar> Anyway, there are probably simpler ways to get an ording on O_n.
05:11:28 <tomejaguar> elfeck: Please explain.
05:11:39 <tomejaguar> s/O_n/S_n/
05:11:55 <elfeck> a group is a set and binary opertion ... there is no requirement for a order relation in the set
05:12:13 <tomejaguar> But on any concrete example of such there will be an ordering.
05:12:45 <tomejaguar> Assuming it supports Eq (That is my hypothesis anyway)
05:12:48 <elfeck> yes that is true
05:13:36 <elfeck> hm maybe I should require Ord then ... but it's not really mathematically corret
05:14:47 <elfeck> but coming back to the original question: There is no way to get to O(nlogn) if I do not require Ord for set equality?
05:15:31 <tomejaguar> elfeck: I suspect not but I can't think how to prove it off the top of my head.
05:16:25 <elfeck> okay
05:16:35 <elfeck> thank you
05:17:38 <lisbeth> the reason I propose the string thing is that one of the two major implementations of a haskell shells, plush, tries to retain the idea of "options"
05:18:05 <lisbeth> whereas I am not sure that it is syntactically wise to use "options" in the same was as previous shells have done it
05:18:12 <lisbeth> so I am thinking of alternatives
05:18:33 <lisbeth> obviously it isn't a good idea to write a dozen different versions of every command such as ls or grep
05:27:28 <lisbeth> I just think that options are ugly and are part of why learning the command line is hard
05:27:40 <lisbeth> there is probably a syntactically better way
06:02:38 <babilomax> Hi, I got some stupid error with a 10-line file: http://lpaste.net/117570
06:02:53 <babilomax> error is:
06:02:55 <babilomax> Color.hs:3:4: Not in scope: type constructor or class `White'
06:02:56 <babilomax> Color.hs:4:4: Not in scope: type constructor or class `Black'
06:03:30 <Haskellfant> hm cabal repl just says “preprocessing library …" and exists after that with a 0 exit code. I tried deleting the cabal project and the sandbox and reinitializing both with no success. cabal exec ghci works just fine. any idea what could be going on here? the code is a pretty simple example from a blog post http://lpaste.net/117571 and I just used the defaults for cabal init
06:09:30 * hackagebot polyparse 1.11 - A variety of alternative parser combinator libraries.  http://hackage.haskell.org/package/polyparse-1.11 (MalcolmWallace)
06:12:55 <tremon> babilomax: module Color (Color(..), other) where
06:13:41 <tremon> babilomax: data constructors can only be exported along with the type, not as separate functions
06:14:30 * hackagebot HaXml 1.25.1 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.25.1 (MalcolmWallace)
06:17:09 <babilomax> yes thank you, I just got the same answer on the french chan ;)
06:17:25 <babilomax> tremon:
06:19:00 <Haskellfant> ah I figured it out. my file had a main method and I specified library
06:19:18 <Haskellfant> strange, imho that should at least print a warning when running cabal repl instead of just exiting
06:19:59 <Haskellfant> need to check if there is a bug report for that
06:55:20 <lisbeth> I am trying to write a function called intersperse which is similar to zip
06:55:33 <lisbeth> where intersperse f [abc] results in
06:55:43 <lisbeth> "afbfcf"
06:55:51 <lisbeth> and I meant to type "abc" not [abc]
06:55:53 <lisbeth> here's what I have so far
06:55:55 <lisbeth> let intersperse a b = case a b of Intersperse [] _ = []; Intersperse _ [] = []; intersperse (x:xs) (y:ys) = x ++ y ++ intersperse xs ys
06:56:29 <everetthitch> .
06:56:46 <lisbeth> nevermind I found a pretty obvious error
06:56:50 <lisbeth> I'll get back to you gu ys
06:57:02 <dutchie> you need a pattern like (x:x':xs)
06:58:04 <dutchie> oh maybe you don't, since your intersperse differs from Prelude's
06:58:17 <hgdyijhftfhju> .
06:58:27 <lisbeth> heh I can't use prelude's intersperse for some reason
06:58:31 <lisbeth> maybe I'm using it wrong
06:59:04 <lisbeth> such as
06:59:12 <lisbeth> let swedish = intersperse "f"
06:59:29 <guest788> hi
06:59:31 * hackagebot cabal-test-compat 0.1.0.0 - Compatibility interface of cabal test-suite.  http://hackage.haskell.org/package/cabal-test-compat-0.1.0.0 (KeiHibino)
06:59:37 <dutchie> > intersperse 'f' "ABC"
06:59:39 <lambdabot>  "AfBfC"
06:59:52 <dutchie> note no terminal f
07:00:26 <HoloIRCUser> ...
07:02:04 <lisbeth> it keeps saying intersperse is not in my scope
07:02:43 <chrisdotcode_> > 1 + 1 -- test
07:02:44 <lambdabot>  2
07:03:13 <dutchie> oh it's in Data.List
07:03:21 <dutchie> not Prelude
07:09:43 <KrzyStar> o/
07:47:01 <nkar> can haskell-mode (or any other tool) show a "function call graph"?  e.g., foo calls bar which calls baz and qux...
07:51:59 <benzrf> nkar: well
07:52:08 <benzrf> nkar: i wrote a tool for that but it's totally broken on recursion
07:52:34 <benzrf> @hackage vampire
07:52:34 <lambdabot> http://hackage.haskell.org/package/vampire
07:52:40 <benzrf> nkar: it's not /exactly/ that
07:53:36 <nkar> benzrf: hi, I've just found simple call tree on emacswiki, but it's too much work to setup, so I'm not going to do it right now
07:54:29 <benzrf> oh good
07:54:48 <nkar> benzrf: are you planning to work on it?  an example in readme.md would be nice to have
07:56:01 <benzrf> nkar: work on what?
07:56:07 <nkar> on vampire
07:56:10 <benzrf> oh
07:56:13 <benzrf> its pretty much a cruddy toy
07:56:21 <benzrf> it's pretty broken
07:58:16 <luite> without a proper way to resolve names you don't get very far, the ghc api is probably the best way
07:58:49 <benzrf> nkar: fwiw use vampire by running `vampire rerepl Thing.hs' and then use :vview and :veval in the ghci
07:59:27 <benzrf> nkar: :vview expr will show a tree of expr and :veval expr will just print its result like a normal ghci expression
07:59:32 <nkar> okay, you convinced me to try :)
08:00:10 <nkar> haha
08:00:13 <nkar> it fails to build
08:00:18 <benzrf> lol
08:00:29 <nkar> from hackage because of the base dependency
08:00:33 <benzrf> nice
08:01:12 <nkar> I'm on 783, and vampire has base <4.7
08:01:47 <nkar> going to try the github version
08:04:14 <benzrf> h-ha
08:04:23 * benzrf checks his last commit to see if it builds at all
08:04:34 * hackagebot text-ldap 0.1.1.4 - Parser and Printer for LDAP text data stream  http://hackage.haskell.org/package/text-ldap-0.1.1.4 (KeiHibino)
08:05:58 <osa1> any ideas why this gtk program updates the GUI with seemingly random intervals http://lpaste.net/117578 ?
08:15:37 <nkar> benzrf: doesn't build due to typeerrors
08:15:40 <Cale> osa1: My guess would be it's because nothing is doing a widgetQueueDraw to make sure the TreeView knows it needs to update
08:16:02 <benzrf> nkar: mfw
08:17:05 <nkar> benzrf: this is starting to look like yakshaving, so I'm going back to work
08:17:12 <nkar> maybe next time :)
08:17:30 <benzrf> :|
08:17:32 <Cale> osa1: Also, using threads with GTK is fiddly business.
08:18:01 <Cale> http://dmwit.com/gtk2hs/ documents stuff about what you need to do to use threads and GTK
08:18:17 <osa1> thanks
08:19:34 * hackagebot duplo 1.6.3 - Frontend development build tool  http://hackage.haskell.org/package/duplo-1.6.3 (kenhkan)
08:20:09 <Cale> (basically if you're making a GTK-related call from another thread, it needs to be given to postGUIAsync which will send it back to be run in the main thread)
08:20:33 <Cale> (or postGUISync, if you need the result of the action)
08:20:44 <nkar> benzrf: also, I hope it doesn't rewrite files in-place, does it?  I haven't looked very closely, but I'd rather do it in the temp directory
08:21:28 <benzrf> nkar: dw it makes new ones :)
08:21:37 <benzrf> nkar: in fact if you use "rerepl" it puts the new one in /tmp
08:21:58 <benzrf> nkar: be warned that this is not programmatic and it may be more fiddly than what you want
08:22:00 <nkar> yeah, I saw a call to getTempDirectory, just wanted to make sure
08:22:02 <nkar> be *
08:22:18 <benzrf> it just makes a pretty tree diagram on your screen detailing which expressions are composed of which other expressions
08:22:34 <benzrf> incl. function call
08:22:51 <nkar> sounds cool, and it's not that much code.  maybe I should give it a try some day, but today is not that day :)
08:22:59 <benzrf> and it breaks on recursion due to the truly horrific implementation method
08:39:28 <deech> Hi all, I have a small program that takes many seconds to compile. The
08:39:28 <deech>         `v2` flag tells me it's stuck in the Renamer/Typecher phase. How do I
08:39:28 <deech>         get more info?
08:39:34 <deech> Crap, sorry.
08:41:35 <deech> Here it is again: I have a small program that takes many seconds to compile. The `v2` flag tells me it's stuck in the Renamer/Typechecker phase. How do I get more info?
08:46:44 <osa1> hm can I set this property of a progress bar in gtk2hs https://developer.gnome.org/gtk3/3.14/GtkProgressBar.html#GtkProgressBar--show-text ?
08:59:27 <matthew-_> just reading https://www.haskell.org/haskellwiki/GHC/Typed_holes. "so if f :: [a] -> [a] as we said earlier, then we get the free theorem f [] = [] by definition - try writing that case another way! You can't!"
08:59:36 <matthew-_> erm, how about f [] = f []
08:59:55 <matthew-_> don't care that it doesn't terminate. It satisfies the type as required.
09:00:46 <carter> deech: you should share the code here
09:01:18 <Cale> matthew-_: Yeah, free theorems don't exactly apply to partially defined functions.
09:02:35 <matthew-_> hmm, the bottom of that page does cover that agda is total...
09:02:44 <Buttons840> in OOP I can have a list of objects that implement a certain interface, but the data contained in each object can be completely different forms -- is this possible in Haskell? presumably I would have to use IO, but I'm planning to do that anyway
09:03:15 <zipper> Is there a way to encode such a property in haskell?  `notReverse x ++ notReverse y == notReverse (y ++ x)`
09:03:22 <zipper> It seems undoable to me
09:03:48 <matthew-_> Buttons840: the elements of the list have the type that is the interface (type class) you care about. Thus gives you the type of the list too
09:04:01 <matthew-_> the actual data representation is then irrelevant
09:07:28 <Buttons840> I've spoke about this in the chat before: I'm attempting to implement a card game in haskell with some AI players, I would like a list of players, something like [(gameState -> IO validMove)], which the "game supervisor" can call -- I would like one player to present the user with a UI to select a move (a human player), and a few other types of players, a heuristic player, a nerual network player, a random player, etc -- each player wo
09:08:23 <tpsinnem> what's the sane way of installing a new version of cabal-install system-wide, so that every user doesn't have to run 'cabal install cabal-install' before they can do stuff? this is an oldish fedora system
09:09:02 <zipper> tpsinnem: Installing cabal binaries in usr/bin
09:09:37 <zipper> tpsinnem: For me it's in ~/.cabal/bin/cabal
09:09:41 <tpsinnem> zipper: should that just work? should i expect linking issues if i do something wrong?
09:09:48 <deech> https://github.com/deech/fltkhs/commit/a810f8320e4fc7ab26f731bea41eb0d4ba635901#diff-1
09:10:13 <tpsinnem> anyhow, thanks, i'll try that out
09:10:21 <Saizan> Buttons840: the supervisor can just have that list
09:10:26 <zipper> tpsinnem: I don't know about linking issues but that should install the binaries system-wide.
09:10:42 <deech> This program takes almost 20 seconds to compile. The `v2` flag says it's spending most of it's time in the Renamer/Typechecker phase. How do I go about profiling that phase?
09:10:55 <deech> Sorry for the noise earlier.
09:10:56 <benzrf> Buttons840: you could use an existential type, but in practice it'd probably work better to just pass around the implementation of the class
09:11:08 <Saizan> Buttons840: and you can have for each kind of player a function that returns that representation, and maybe put that in a typeclass, but that's not necessary
09:11:41 <Saizan> Buttons840: basically the upcasting is going to be explicit
09:13:07 <Buttons840> Saizan, benzrf: can I have something like a State Monad; where each player can remember some state from one call to the next? some player might not need to remember any state, while others might want to persist a complex state -- can all this be done with the same type?
09:13:24 <zipper> tpsinnem: The other method is for a single user. cabal install cabal-install is for updating cabal and requires cabal :) At least as far as I know.
09:16:17 <carter> deech: did you try -v3
09:16:25 <carter> deech: v3 is REALLY DETAILED
09:16:33 <carter> if you lpaste or github gits -v3
09:16:39 <carter> we'll see exactly whats doing what
09:16:45 <Saizan> Buttons840: that's also possible but complicates things, because you have to figure out the tuple type of all the states of the players, and make each one look at its own part
09:17:01 <Saizan> Buttons840: maybe start with IO for the state?
09:18:45 <carter> deech: also asking for help on new years day! ;)
09:19:08 <deech> carter: I realize that. :)
09:21:17 <Buttons840> maybe my goal is too ambitious for now -- in python I would have a "game supervisor" that inspected a directory for all classes with a certain interface and dynamically load them as available players, then you could add new players by writting a new class and wouldn't need to change any other code -- i guess this is more difficult in a static typed compiled language, especially one such as haskell (not saying it's bad, just that I need
09:21:38 <deech> carter: Here it is: https://gist.github.com/deech/d4be3357c1630b30ce24
09:21:50 <nkar> dolio: yesterday watched your optimization talk from september, learned a lot.  I hope there'll be part 2 at some point.
09:22:03 <deech> There was no additional output in the Renamer/Typechecker phase.
09:22:20 <nolrai66> Buttons840: I've done that, its not too hard.
09:22:27 <dolio> nkar: Glad you liked it.
09:22:40 <carter> deech: did you notice the part whree all your deps are busted?
09:23:07 <deech> Yes. But I ignored it because that doesn't seem to be where it's spending it's time.
09:23:15 <carter> deech: your build is bsuted
09:23:22 <carter> how can we debug it if its busted
09:23:31 <Buttons840> nolrai66: glad to hear it, maybe I'll attempt it after I have 1 or 2 player types hard coded
09:23:51 <carter> nkar: the -ddump-to-file trick is one i showed dolio  i think,  though i think i originally noticed in in some johan tibbel code
09:24:08 <carter> dolio: oh, whats your take on the MonadST / PrimMonad back and forth?
09:24:10 <deech> carter: Ok I'll fix that and try again.
09:24:21 <deech> carter: Thanks again for taking a look. Happy New Year!
09:24:51 <carter> dolio: i guess it comes down to whether breakage should happen at the Vector or PrimMonad level
09:25:07 <dolio> carter: I'm not totally sure. I kind of lean toward changing PrimMonad.
09:25:10 <carter> yeah
09:25:20 <carter> otoh, for people using primmonad its a more confusing breakage
09:25:27 <carter> the vector level one is more blatant
09:25:34 <carter> idk
09:25:35 <dolio> There are a lot of operations in primitive itself that would be generalized by that.
09:25:43 <carter> huh
09:25:45 <carter> fair
09:26:02 <carter> prim2prim moves to PrimMonadStrong
09:26:04 <carter> or whatever
09:26:06 <carter> right?
09:26:14 <dolio> And I think Ed wouldn't mind if MonadST were made obsolete because of that.
09:26:33 <Saizan> Buttons840: right, things like loading code at runtime are not as straightforward with an implementation focused on compiled code like ghc
09:26:36 <dolio> No, I mean a bunch of stuff in other modules, like working with primitive arrays and such.
09:26:43 <carter> ahhhh
09:26:44 <carter> yeah
09:26:46 <carter> ooo
09:26:47 <carter> ok
09:26:54 <carter> THAT arguement sells me
09:27:44 <dolio> It has its own generalization of mutable variables that is useless for anything but IO and ST.
09:27:54 <dolio> Addrs, etc.
09:27:54 <carter> ew
09:27:59 <carter> ok
09:28:23 <carter> dolio: OK I LIKE
09:28:57 <dolio> Yeah, that pushes me to split the class, so that PrimMonad is the one-stop for all that stuff, instead of cobbling together a couple different packages.
09:29:28 <carter> vs MonadST?
09:29:44 <carter> would the split be the one ~ snoyman style one?
09:30:05 <carter> i think the ST s a -> lift api is a better one than the ( # ### - > #### )
09:30:05 <carter> one
09:30:14 <carter> at least from a UX perspective
09:30:17 <carter> but whats your take
09:30:19 <carter> ohhh
09:30:19 <dfeuer> Hi dolio! Hi carter!
09:30:20 <carter> hrmm
09:30:54 <dolio> I don't know about that one.
09:31:01 <dfeuer> I'm rewriting breadth-first monadic Tree builders now :-)
09:31:03 <carter> yeah, maybe you're right
09:31:07 <dolio> I actually don't think it makes anything easier to use ST.
09:31:15 <carter> oh ok
09:31:18 <dolio> Because only the base needs to worry about the argument.
09:31:22 <dfeuer> I think I can make them simpler, lazier, and more efficient all at once, but we'll see.
09:31:30 <carter> awesmom
09:31:40 <dolio> Everything else is calling the method on something lower.
09:31:49 <carter> lower?
09:32:01 <carter> dolio: also, this change really motivates the make the .Mutable modules richer
09:37:53 <johnw> happy new year everyone
09:38:08 <johnw> carter will be able to compute the factors of 2015 extra fast this year I bet
09:38:23 <carter> haha
09:41:00 <NemesisD> is there an alternative to gadts for embedded DSLs where you get the same level of type safety?
09:41:21 <vanila> yeah, 'tagless' olegs page has stuff about it
09:41:40 <carter> NemesisD: write a type checker :)
09:41:42 * carter ducks
09:41:48 <NemesisD> hehe
09:42:09 <deech> carter: Updated the gist: https://gist.github.com/deech/d4be3357c1630b30ce24
09:42:44 <carter> deech: fix the defaulting warnings?
09:43:01 <carter> deech: does it take a lot longer with O2?
09:44:47 <deech> carter: fixing defaulting warnings now. O2 doesn't seem to make a lot of difference.
09:45:19 <carter> deech: i have no clue
09:45:40 <carter> deech: so with GHC related things, if you can remove ALL the deps, and still get a funny perf issue, its more likely a ghc problem
09:45:44 <carter> but you have SOOOO MANY DEPS
09:45:46 <carter> i have no clue
09:49:53 <tpsinnem> if i have a shared sandbox at /path/to/shared and i set up a project at /path/to/other with 'cabal sandbox init --sandbox /path/to/shared', where will the stuff i build in /path/to/other go? to the sandbox at /path/to/shared or to someplace under /path/to/other ?
09:50:43 <tpsinnem> i'm hoping i could set up a hierarchy of shared sandboxes
09:51:30 <deech> carter: Updated with defaulting fixed. No difference to compile time. https://gist.github.com/deech/d4be3357c1630b30ce24
09:51:45 <carter> deech: can you remove all the deps?
09:52:16 <tpsinnem> where i could have a project at /path/to/yet-another that uses /path/to/other as a shared sandbox, while still having stuff done in /path/to/other affecting the stuff in /path/to/shared
09:52:31 <tpsinnem> erm, *not* affecting
09:53:23 <carter> woah woah, you want purity in your OS?
09:53:51 <deech> carter: Do you mean remove all the dependencies from the Build-Depends section of the Cabal file?
09:54:10 <carter> idk, make it not depend on stuff
09:54:15 <carter> so its a single file
09:54:17 <carter> that ghc is slow on
09:54:21 <carter> so we can file a a bug report
09:54:35 <deech> carter: Oh, ok.
09:54:38 * hackagebot duplo 1.6.4 - Frontend development build tool  http://hackage.haskell.org/package/duplo-1.6.4 (kenhkan)
09:54:44 <carter> deech: or that i can look at in isolation
09:54:52 <carter> deech: also, it COULD be that its fine in 7.8
09:54:56 <carter> and you just need to update :)
09:54:57 <Cale> Buttons840: still here? I'm still catching up on the conversation
09:55:16 <deech> carter: Ok. I'll try updating. Because isolating it will take a *lot* longer.
09:55:22 <carter> hehe
09:55:27 <carter> deech: ubuntu?
09:55:34 <carter> updating should be easy with hvr 's ppas
09:55:36 <Cale> Buttons840: The usual way to encode OO in Haskell is just to make a record type whose fields are the methods of the objects you want to work with.
09:55:54 <deech> carter: Yes, but I downloaded the binary release of GHC.
09:56:29 <Cale> Buttons840: and then just write multiple functions for constructing such objects by filling in the methods appropriately with different behaviours. Parameters to those functions become like "private" data.
09:57:03 <deech> carter: Thanks for taking the time on a holiday.
09:57:22 <carter> deech: I WILL DEMAND RECOMPENSE WITH BLUD AND LAMBDAS :)
09:58:07 <Cale> Buttons840: There are at least a couple of ways to handle statefulness when you do this. The pure encoding is to not do any real mutation, and instead have methods which produce a new version of the object where you might otherwise update your object.
09:58:41 <Cale> Buttons840: but of course, you can have the methods produce IO actions and use IORefs or other sorts of mutable variables
10:02:47 <dmj`> is "tidy core" different from "core"
10:06:54 <arjanb> dmj`: in ghc tidy core is an intermediate step in the conversion to stg and is basicly core with a lot more restrictions
10:07:44 <dmj`> arjanb: thanks
10:09:40 <johnw> Does anyone have a patch for lambdabot so that it can build with GHC 7.8.4?
10:14:29 <RchrdB> johnw: i built it with ghc 7.8 recently ish
10:15:02 <johnw> hmm... trying now I get a mismatch of type declarations between boot file and source file
10:15:16 <RchrdB> johnw: http://carefully.understood.systems/repos/welpbot.git/
10:15:29 <johnw> welpbot is lambdabot?
10:15:40 <RchrdB> That is a close descendant of lambdabot
10:16:06 <RchrdB> You'll want to review the patches I made carefully because you might not want all my changes
10:16:35 <RchrdB> e.g. I removed some of the commands that I really dislike.
10:17:29 <brainacid> sweet im back online
10:17:36 <heatsink> I have a functor-like class where the parameter has kind (* -> *)
10:17:44 <heatsink> class Functor' t where fmap' :: (forall i. f i -> f' i) -> t f -> t f'
10:17:45 <RchrdB> You should be able to cherry-pick out, say, the patch that alters the hs-boot file which is broken and maybe the patch to drag in a patched copy of the djinn module
10:17:56 <johnw> ok, thanks!
10:18:09 <heatsink> Is there a name for that functor-like class?
10:18:34 <johnw> heatsink: usually it's called HFunctor, I think
10:18:54 <johnw> http://hackage.haskell.org/package/category-extras-0.52.3/docs/Control-Functor-HigherOrder.html
10:18:58 <johnw> is that what you're looking for?
10:19:13 <johnw> (hfmap is the same as what you wrote)
10:19:24 <RchrdB> Good luck!
10:19:26 <RchrdB> johnw: oh and you almost CERTAINLY don't want to run it with the same name+connection details as I do … :)
10:19:38 <johnw> i only intend to run it locally
10:19:39 * hackagebot haskell-updater 1.2.6 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.6 (SergeiTrofimovich)
10:19:59 <heatsink> johnw: Yeah, that looks like it
10:20:16 <heatsink> johnw: I was reading http://www.andres-loeh.de/Rec/MutualRec.pdf which defines HFunctor differently
10:20:17 <shachaf> heatsink: The type johnw linked to isn't the same.
10:20:35 <heatsink> Hmm
10:20:38 <benzrf> 01:14 <%benzrf> that meme was so nice
10:20:38 <benzrf> 01:14 <%benzrf> it got friendzoned
10:20:38 <benzrf> - benzrf, 2015
10:20:38 <benzrf> a portrait of my formative years
10:20:41 <benzrf> fuck
10:20:42 <heatsink> the last arrow is :~> instead of ->
10:20:44 <RchrdB> Cool. You might be able to use it as-is, then. There is a Dockerfile for it in there iirc which was successfully building when i last touched it. :)
10:20:45 <benzrf> mispaste
10:20:46 <johnw> ah, right
10:20:48 <benzrf> x_x
10:21:34 <shachaf> That HFunctor is probably a more common sort of functor, though.
10:21:38 <nolrai66> benzrf: which meme?
10:21:48 <benzrf> nolrai66: i'd rather not mention this incident
10:22:04 <ruukasu> benzrf: ayy lmao
10:22:20 <benzrf> the horrendous internet irony meme culture that has corrupted my brain has no place in this channel
10:22:23 <benzrf> >.>
10:22:25 <shachaf> nolrai66, ruukasu: Off-topic in here.
10:22:35 <heatsink> Then category-extras has the same HFunctor as in the paper I was reading
10:22:44 <heatsink> I guess I'll make up a new name for mine
10:22:48 <ruukasu> benzrf: can you accidentally paste in #haskell-blah
10:22:58 <shachaf> heatsink: Yours is also a sort of functor, but it maps the category of Hask endofunctors to Hask.
10:23:09 <benzrf> ruukasu: g-go away
10:24:03 <shachaf> heatsink: Using some of the fancier Functor classes it wouldn't need to be a separate class.
10:27:05 <heatsink> shachaf: What do you have in mind?  It's not clear to me how to take advantage of HFunctors in my class
10:27:58 <shachaf> Well, something like http://hackage.haskell.org/package/categories-1.0.6/docs/Control-Categorical-Functor.html
10:28:04 <shachaf> Or http://hackage.haskell.org/package/data-category-0.6.1/docs/Data-Category-Functor.html
10:28:20 <shachaf> Maybe that doesn't help much in your situation.
10:29:17 <sipa> 12:17 pm, is that midnight or noon?
10:29:36 <heatsink> noon
10:29:56 <sipa> thanks!
10:33:56 <heatsink> It's out of my comfort zone.  I haven't learned category theory.
10:36:08 <sinelaw> Yet.
10:37:41 <darkroom> hello i am having this problem where whenever i try to install a cabal project that uses matrices it fails saying i need blas and lapack
10:38:07 <quchen> You should probably install BLAS and LAPACK.
10:39:15 <geekosaur> darkroom, cabal cannot install C (or fortran) libraries for you, you must use your OS's package manager or etc. on a Linux that distinguishes between runtime and devel packages, you need the devel packages
10:39:54 <darkroom> alright do you know where i can find these packages?
10:40:08 <geekosaur> I don't even know what platform you are on
10:40:11 <darkroom> would sudo apt-get install blas work?
10:40:12 <darkroom> linux
10:40:28 <capcar> exit
10:40:40 <geekosaur> so you're on a debianish system. "apt-cache search blas" might be informative
10:40:50 <darkroom> thanks
10:41:22 <t7> @hoogle Random g => [a] -> g -> a
10:41:24 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
10:41:24 <lambdabot> Prelude (!!) :: [a] -> Int -> a
10:41:24 <lambdabot> Data.List (!!) :: [a] -> Int -> a
10:43:12 <sinelaw> darkroom, you may need dev libs, like libblas-dev, liblapack-dev or so
10:43:22 <geekosaur> so I checked my work mint system, "blas" appears to not point to anything useful, there is libopenblas-dev and there is libatlas-dev (atlas being a variant of blas)
10:43:26 <darkroom> yea i am using the dev libaries
10:44:49 <geekosaur> atlas also provides a subset of lapack, but you probably need liblapack3-dev
10:49:04 <t7> my ghci isnt printing unicode
10:49:10 <t7> do i have to tell it to?
10:49:23 <Iceland_jack> t7: just use 'putStrLn' if you're showing a string
10:49:43 <Iceland_jack> ghci> "æ"
10:49:43 <Iceland_jack> "\230"
10:49:43 <Iceland_jack> ghci> putStrLn "æ"
10:49:43 <Iceland_jack> æ
10:52:54 <sinelaw> > show "\230"
10:52:55 <lambdabot>  "\"\\230\""
10:53:39 <EvanR> > show "æ"
10:53:40 <lambdabot>  "\"\\230\""
10:53:46 <t7> Iceland_jack: is there no way?
10:53:50 <t7> i use unicode a lot :(
10:54:28 <Iceland_jack> t7: No way to do what?
10:54:35 <t7> what about asian users
10:54:42 <EvanR> the show instance encodes unicode characters escaped to make it easy to use in environments that cant show unicode characters
10:54:51 <t7> but mine can
10:54:56 <t7> there should be a flag
10:54:56 <EvanR> > read (show "æ"")
10:54:57 <lambdabot>  <hint>:1:17:
10:54:57 <lambdabot>      lexical error in string/character literal at end of input
10:55:02 <EvanR> > read (show "æ")
10:55:03 <lambdabot>  *Exception: Prelude.read: no parse
10:55:13 <Iceland_jack> > read (show "æ") :: String
10:55:15 <lambdabot>  "\230"
10:55:24 <EvanR> > text "æ"
10:55:25 <lambdabot>  æ
10:55:27 <geekosaur> t7, Show is not intended for this use
10:55:36 <Iceland_jack> > char 'æ'
10:55:37 <lambdabot>  æ
10:55:37 <geekosaur> you want prettyprinting, not unambiguous debug output
10:55:52 <t7> ah ok
10:55:56 <t7> is there a class for that?
10:55:56 <benzrf> :t char
10:55:57 <lambdabot> Char -> Doc
10:56:00 <geekosaur> Show serves too many masters as it is, prettyprinting is not something it can do for you
10:56:15 <geekosaur> (debugging and serialisation)
10:56:58 <EvanR> even if all environments could show unicode, it would be hell for debugging
10:57:03 <geekosaur> anyway hackage has several prettyprinting libraries (the problem being that different people have different notions of "pretty")
11:00:01 <HeladoDeBrownie> prettyPrint :: (PrettyPrintable a) => PrettyNotion -> a -> IO ()
11:00:34 <EvanR> -> String maybe
11:00:41 <HeladoDeBrownie> er, yes
11:00:57 <HeladoDeBrownie> anyway it's a joke, it seems like it'd be hard to implement that :P
11:01:48 <EvanR> another great idea goes out the window ;)
11:02:02 <geekosaur> cannot instantiate infinite type PrettyNotion
11:02:06 <geekosaur> :p
11:02:09 <HeladoDeBrownie> XD
11:02:41 <EvanR> (peoples notion of pretty printing may boil down to how they want trees of strings/trees to be indented)
11:03:16 <HeladoDeBrownie> well then you could have PrettyNotion include an indent amount among other things?
11:03:31 <EvanR> in clojure though, for all the configurability of its pretty print.. its still very wrong and ugly regardless
11:04:17 <HeladoDeBrownie> is it because of the parens everywhere?
11:04:29 <EvanR> not necessarily amount of indent, but whether to carriage return and where (and then how much to indent, which may not be a fixed amount)
11:05:30 <EvanR> HeladoDeBrownie: off topic, but they like to display "maps" like key newline value newline key newline value ... which is impossible to read. just imagine if the phone book looked like that
11:07:25 <heatsink> Why are exceptions pretty-printed by 'show'?
11:07:48 <homovitr`> any good example of a frontend using Parsec and doing C-style preprocessing (#include, and #define type of things at minimum)?
11:08:59 <EvanR> if define doesnt affect anything before it, you can do that with the state feature of parsec
11:09:49 <heatsink> File I/O (#include) would probably interact poorly with a backtracking parser
11:10:07 <heatsink> Not sure if it's possible
11:10:10 <heatsink> with ParsecM
11:10:44 <EvanR> nevermind
11:10:46 <HeladoDeBrownie> there's a ParsecT isn't there? you could use it over IO probably
11:10:47 <heatsink> looks like Parsec uses a monad transformer, so I guess you could wrap IO with it
11:17:20 <homovitr`> heatsink: I have something for "include" (you can lift readfile into the IO monad (using ParsecT) and then setInput to make the file content visible to parsec). I still have to decide how to call that, which is why I wanted to look at other examples: do they have a preproc :: string->string or do they have a token stream based parser
11:18:31 <Voldenet> Hello, does haskell have an option to memoize recursive calls on a certain function?
11:18:56 <vanila> Voldenet, you can use lazyness to memo things
11:18:58 <benzrf> Voldenet: i think graph sharing might do that for you but im not sure
11:21:13 <homovitr`> EvanR: my problem is how to detect and replace the #define (and uses of the defined things) [and similarly for #include]. Should I go to the main parser work on token streams (produced by the pre-processor) and loosing some of the builtin combinators (I think) or can I have the preprocessor being a strig->string function and then use a normal Char stream parser?
11:22:04 <Voldenet> benzrf: not really, but I think naive memoization will do, I just thought that haskell /might/ have some fast memoization based on hashsets or something
11:22:11 <Voldenet> vanila++ thanks, I'll use that
11:23:07 <Voldenet> but wait, how do I use that on, say, naive fibonacci numbers func
11:23:35 <twanvl> Voldenet: there are several memoization libraries for haskell
11:23:38 <quchen> Voldenet: There are a couple of memoization libraries to do this kind of operation, e.g. data-memocombinators.
11:23:53 <quchen> I think it even mentions the Fibonacci example in its docs.
11:23:58 <Enzoray> I need help with constructing data types and understanding recursion.
11:24:07 <Enzoray> Could someone lend me a hand?
11:24:09 <Voldenet> (fib is a hello world for memoization, always ;>)
11:24:16 <vanila> Voldenet, ill show you
11:24:24 <Voldenet> Enzoray: to understand recursion you need to understand recursion
11:24:39 <Voldenet> I know it's an old joke, just couldn't stop myself
11:24:44 <benzrf> Enzoray: recursion is when you use recursion
11:24:57 <benzrf> actually no that's overly specific
11:24:58 <vanila> http://lpaste.net/117586
11:25:00 <benzrf> make that
11:25:13 <benzrf> a value is bottom if it is bottom
11:25:14 <benzrf> :-D
11:25:17 <vanila> you can try comparing both ways, to make sure its faster
11:25:36 <dfeuer> Is there a standard way to deal with repeated parentheses? Like (Paren 3) would mean "three left parentheses" and (Paren (-4)) would mean "four right parentheses"?
11:25:49 <Enzoray> And this will help me understand recursion when I understand recursion.
11:26:14 <dfeuer> Recursion is sort of a dual to induction.
11:26:22 <benzrf> Enzoray: recursion is when a value is defined in terms of itself
11:26:45 <dfeuer> benzrf, what kind of mathematician are you?
11:26:49 <vanila> dfeuer, can you elaborate?
11:26:53 <benzrf> dfeuer: a shity one :D
11:26:59 <dfeuer> vanila, oh, just that that's kind of a vague statement :P
11:27:13 <heatsink> homovitr`: You should have a parser to provide the input to the macro engine
11:27:25 <dfeuer> And there are lots of different kinds of recursion out there For Great Justice.
11:27:41 <heatsink> homovitr`: For example, the preprocessor needs to distinguish #define from "#define" and /* #define */
11:27:48 <Enzoray> dfeuer, you're barely toching the surface with that statement.. :P
11:28:22 <dfeuer> The most general I know of being well-founded recursion. If you ever have to use that in programming... good luck to you.
11:28:24 <sinelaw> recursion is also the fixed point of some function
11:28:46 <heatsink> homovitr`: So the macro engine should receive a token stream from the parser, and it should operate on the token stream
11:29:00 <Voldenet> quchen++ I think I'll use your solution for memoization, sounds saner than reinventing the wheel for more complex things
11:29:01 <dfeuer> People do, I think, but then they fill pages with proofs. Yech.
11:29:14 <nkar> there was a good post by sigfpe on data and codata, which is relevant, iirc
11:29:20 <nkar> s/was/is/
11:30:31 <vanila> Enzoray, yes I could help
11:30:33 <dfeuer> nkar, yes, those are the mathematicians masquerading as Haskell programmers.
11:30:47 <nkar> :)
11:31:05 <Enzoray> vanila, I see.
11:32:27 <dfeuer> As strange as this may sound, my complete ignorance of parsing is turning out to be a bit of a barrier to my reimplementation of Data.Tree.unfoldForestM_BF.
11:32:28 <nkar> here's the post: blog.sigfpe.com/2007/07/data-and-codata.html
11:32:50 <exio4> dfeuer, isn't that half of haskell community?
11:33:25 <dfeuer> Because the "rebuilding" step (as described by Okasaki) ends up being a sort of parsing problem in my version.
11:39:34 <Voldenet> Is using haskell on windows a good idea or not really?
11:39:42 * hackagebot jsontsv 0.1.4.3 - JSON to TSV transformer  http://hackage.haskell.org/package/jsontsv-0.1.4.3 (DanielChoi)
11:39:54 <sivteck> windows is a supported platform.
11:40:13 <Voldenet> that's a nice idea, but the same thing perl devs say about it
11:40:40 <sivteck> you should be able to use GHC and cabal, if not we have a bug@
11:40:43 <sivteck> !
11:40:55 <Voldenet> ./configure didn't work for some packages
11:41:26 <Voldenet> and, unless configure is a powershell script then I don't think it'll work
11:41:30 <mauke> haskell modules don't usually come with configure scripts
11:41:35 <mauke> nor do perl modules
11:42:36 <Voldenet> >cabal install cabal-install >Configuring network-2.6.0.2... >setup.exe: The package has a './configure' script. This requires a Unix compatibility toolchain such as MinGW+MSYS or Cygwin.
11:43:05 <mauke> why are you reinstalling cabal?
11:43:24 <Voldenet> because I want the newest version, obviously ;)
11:43:31 <sinelaw> Voldenet, sounds like you're building stuff that usually ships pre-built
11:43:44 <sinelaw> network is a headache on windows
11:43:44 <mauke> well, then ...
11:43:52 <sinelaw> I never got it to build
11:43:59 <sinelaw> Voldenet, maybe try on #ghc
11:44:03 <Voldenet> Oh.
11:44:17 <Voldenet> I guess it might work on linux though
11:44:42 * hackagebot jsontsv 0.1.4.4 - JSON to TSV transformer  http://hackage.haskell.org/package/jsontsv-0.1.4.4 (DanielChoi)
11:44:54 <sivteck> Voldenet, this might help <http://neilmitchell.blogspot.in/2014/12/beta-testing-windows-minimal-ghc.html>
11:53:49 <mauke> ah, that sounds a bit like strawberry perl
11:54:06 <mauke> which bundles build tools and even gcc
11:59:00 <Voldenet> mauke: well, there's no other sane perl distro for windows
11:59:23 <Voldenet> inb4 active perl
11:59:27 <Voldenet> :cough:
12:00:11 <mauke> activeperl is more platform-y but not really
12:01:01 <Voldenet> but tbh why would anyone use perl on anything non-unix
12:01:09 <Voldenet> all linux distros ship with perl
12:19:08 <hiptobecubic> activeperl + bioperl on windows is a really common setup for bioinformatics as well
12:19:28 <hrumph_> can i use hayoo t find classes?
12:21:27 <Buttons840> are there any functions like ([a] -> Maybe a) -> [a] -> [a]  which add a number of elements to a list until a certain criteria is met? something like an unfold but a little different
12:22:22 <prophile> @hoogle ([a] -> Maybe a) -> [a] -> [a]
12:22:24 <lambdabot> No results found
12:22:37 <prophile> I must confess I'm not sure how that would work?
12:22:37 <heatsink> @t until
12:22:38 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
12:22:42 <heatsink> :t until
12:22:42 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
12:30:47 <johnw> Buttons840: do you mean takeWhile?
12:30:50 <johnw> :t takeWhile
12:30:51 <lambdabot> (a -> Bool) -> [a] -> [a]
12:31:07 <johnw> or do you want the predicate to be on the "list examined thus far"?
12:36:55 <RedNifre> Happy new year!
12:37:03 <Buttons840> johnw: the latter; I want the predicate to be a function of "the list generated thus far"
12:37:59 <Buttons840> johnw: of all my difficulties, this seems the smallest right now ;) i was just wondering if there was a standard function I should be aware of since I couldn't find anything on hoogle
12:38:18 <RedNifre> I have some JSON that looks like { "type":1 } and I would like to use derive Generic, but I can't declare data Answer = Answer { type :: Integer } because type is a reserved keyword. Is there something I can do?
12:39:13 <mmmm> you can use template haskell
12:39:50 <RedNifre> How long would that take if I don't know what template haskell is?
12:40:32 <mmmm> https://hackage.haskell.org/package/aeson-0.3.2.12/docs/Data-Aeson-TH.html
12:40:52 <RedNifre> Is it like Java's data Answer = Answer { @SerializedName("type")answerType :: Integer } or is it more involved?
12:40:59 <RedNifre> Thanks, I'll have a look.
12:40:59 <mmmm> sorry this one https://hackage.haskell.org/package/aeson-0.3.2.12/docs/Data-Aeson-TH.html
12:41:01 <johnw> :t \f ys -> case L.takeWhile f $ L.inits ys of [] -> []; xs -> last xs
12:41:02 <lambdabot>     Not in scope: ‘L.takeWhile’
12:41:02 <lambdabot>     Perhaps you meant one of these:
12:41:02 <lambdabot>       ‘BSL.takeWhile’ (imported from Data.ByteString.Lazy),
12:41:04 <johnw> Buttons840: ^^
12:41:07 <johnw> s/L.//g
12:41:07 <mmmm> no not that one one sec..
12:41:24 <mmmm> https://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson-TH.html
12:41:25 <mmmm> that one
12:41:26 <johnw> type is :: ([t] -> Bool) -> [t] -> [t]
12:41:48 <mmmm> I've got no idea about Java sorry
12:45:04 <athan> Can I derive monads, like in the movies?
12:45:16 <johnw> what?
12:45:38 <prophile> yes, by invoking the rite of GeneralizedNewtypeDeriving
12:45:51 <RedNifre> Hm, please correct me if I'm wrong here, but I understand what you linked like this: With template haskell, I can specify how the JSON parser would be derived when using derive Generic? I guess this is useful when dealing with nested records, but how does it help in my case?
12:47:04 <mauke> it lets you rename fields
12:47:42 <athan> prophile: Ahh, okay thank you. I've seen some people use `data Foo ... deriving (... , Monad)`, this is possible?
12:47:56 <athan> I know GeneralizedNewtypeDeriving uses the `deriving instance Monad ...` syntax
12:48:00 <johnw> only if it's a newtype of a type that's a Monad
12:48:03 <athan> johnw: Sorry, a bit too silly :P
12:48:07 <johnw> otherwise, auto-deriving a Monad instance is impossible
12:48:12 <athan> ahh okay
12:48:14 <athan> hmm
12:48:16 <athan> thank you
12:48:32 <mauke> athan: data ... deriving (...) and deriving instance ... are the same thing
12:48:46 <athan> mauke: Oh woah
12:48:52 <mmmm> RedNifre: You can name your field something like data Payload = Payload { payloadType :: Int } and then use the template haskell to drop the first 7 characters so you get the right json
12:48:57 <mauke> except one of them is attached to the type definition
12:49:30 <RedNifre> Ah, I see. So I would prefix all my record's fields with "something" and then drop the first 9 characters with template haskell, to deal with the "somethingtype" field that I can't name "type", correct?
12:49:45 <RedNifre> Guess I need to type faster :)
12:50:03 <mauke> or you could special case that one field
12:50:25 <mauke> fieldLabelModifier = \x -> if x == "xtype" then "type" else x
12:50:29 <mauke> might be silly, though
12:51:48 <RedNifre> Maybe something like "If it starts with '_', drop the '_'"... that way I could just prefix an underscore whenever I encounter any haskell keyword in the JSON file.
12:56:01 <hiptobecubic> one _ is never enough
12:57:01 <mauke> fieldLabelModifier = \x -> fromMaybe x (stripPrefix "_" x)
12:57:22 <RedNifre> why would one _ not be enough?
12:58:13 <dfeuer> @ask edwardk Do you think it's possible to define unfoldForestM_BF so that it ends up exactly as lazy and asymptotically as fast as unfoldForest when used with the trivial monad?
12:58:13 <lambdabot> Consider it noted.
13:04:45 * hackagebot duplo 1.6.5 - Frontend development build tool  http://hackage.haskell.org/package/duplo-1.6.5 (kenhkan)
13:11:56 <RedNifre> mauke, how exactly do I use that for all records?
13:14:03 <RedNifre> I guess I need something like $(deriveJSON defaultOptions{fieldLabelModifier = \x -> fromMaybe x (stripPrefix "_" x)} ???) ?
13:17:01 <tammytg> [ 0.762548] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0).
13:19:04 <wallyyyyyyyy> (I think)
13:19:45 <wallyyyyyyyy> wallyyyyyyyy, hi sir
13:23:15 <RedNifre> Oh... I guess you use $(deriveJSON INSTEAD of using instance FromJSON... I thought it was meant to augment what instance FromJSON does... is there a way to do fieldLabelModifier = \x s> fromMaybe x (stripPrefxi "_" x)} automatically whenever I add a To/FromJSON instance?
13:25:42 <RedNifre> Is it just me or do I have to move template haskell things to the end of the file?
13:29:46 * hackagebot event-list 0.1.1.2 - Event lists with relative or absolute time stamps  http://hackage.haskell.org/package/event-list-0.1.1.2 (HenningThielemann)
13:36:02 <darkroom> if you get an error that just says matrix multiplication size error is there a way to know which line that error occurs in?
13:36:24 <sinelaw> code golf:
13:36:27 <sinelaw> :t let f = f . f in f
13:36:28 <lambdabot> b -> b
13:36:54 <sinelaw> the diverging identity function
13:37:31 <sinelaw> > let f = f . f in f ()
13:37:36 <lambdabot>  mueval-core: Time limit exceeded
13:38:20 <sinelaw> Which type systems can statically prevent such values?
13:38:26 <sinelaw> (fail type checking, that is)
13:39:48 <HoloIRCUser1> f = f -- also the diverging id
13:39:56 <lightstep> hi all, i've got a "cabal hell" problem. the dependencies of category-extras cannot be resolved, with a fresh install of both ghc 7.8.3 and ghc 7.8.4. is there some database of "tried and true" versions of hackage packages? until now, i used the haskell platform, but now i want to try "reactive" which is not avaiable there.
13:40:40 <sinelaw> :t let f = f in f
13:40:41 <lambdabot> t
13:41:44 <EvanR> darkroom: btw if you run the program with +RTS -xc you might get some kind of backtrace when it crashes
13:42:01 <EvanR> you might have to compile with profiling or something, which is -prof
13:42:12 <darkroom> EvanR: like ghc +RTS -xc?
13:42:22 <EvanR> ./a.out +RTS -xc
13:42:25 <hvr> lightstep: there simply is no valid install-plan w/ GHC 7.8.x for category-extras (which isn't surprising as its last release was in 2012)
13:42:34 <sinelaw> quchen-mobile, true! and that's actually worse: the type is 'a'
13:43:17 <hvr> lightstep: otoh, it's not category-extra's fault
13:43:40 <quchen-mobile> Well, you can specialize to a -> a
13:43:53 <lightstep> hvr: yes, i understand, the language and packages change too fast.
13:44:23 <lightstep> so, does anyone know if is there some up-to-date frp library based on the push-pull paper?
13:45:06 <EvanR> sinelaw: dependent types?
13:45:15 <sinelaw> EvanR, yes, but how exactly?
13:45:27 <hvr> lightstep: ok, part of the problem is that category-extras depends on the deprecated representable-functors package
13:45:49 <hvr> lightstep: and since it's deprecated, it's not kept up2date in terms of its build-deps
13:46:00 <EvanR> sinelaw: well whats the problem type, forall a . a -> a ?
13:46:07 <lightstep> how does one know that a package is deprecated?
13:46:10 <EvanR> in idris, you cant write that type
13:46:22 <hvr> lightstep: it shows up in hackage: http://hackage.haskell.org/package/representable-functors
13:46:45 <lightstep> cool then.
13:48:42 <EvanR> sinelaw: actually the answer in that case is the totality check. your diverging version uses a general recursion step, which can be disallowed
13:49:04 <EvanR> the type of id is not actually very different, just (a : Type) -> a -> a
13:49:29 <sinelaw> EvanR, i'm beginning to see that. but again how is id different?
13:49:30 <EvanR> where the first parameter would be implicit
13:49:51 <EvanR> how is id different from what?
13:50:32 <EvanR> the actual id function doesnt use recursion
13:51:39 <sinelaw> EvanR, with respect to the totality check you mentioned
13:51:46 <sinelaw> how is id different from f = f . f
13:51:51 <vanila> f is recursive
13:51:53 <vanila> id isn't
13:52:04 <vanila> id T x = x  <- 'id' is not used in this definition
13:52:05 <sinelaw> so it disallows all non-inductive recursion?
13:52:38 <kraljev10> data A = String | Int
13:52:40 <kraljev10> "dasasd" :: A
13:52:50 <kraljev10> Why doesn't this work (in REPL)?
13:52:52 <EvanR> the totality check is off by default except for functions used in types, but even if its on it still allows corecursion
13:52:53 <vanila> types wont stop programs looping if you allow functions to self reference
13:53:25 <sudoman> hello, i hit an issue when trying to compile haskell platform: http://pastebin.com/n5LeGK9K
13:54:41 <sudoman> according to hackage, hscolour only requires base<10  http://hackage.haskell.org/package/hscolour-1.20.3
13:55:14 <lennartl> sinelaw: if i understand correctly, any strongly-normalizing type system without letrec?
13:59:29 <ReinH> kraljev10: you are making String and Int data constructors of type A.
13:59:36 <ReinH> so you have String :: A and Int :: A
13:59:57 <ReinH> These happen to have the same name as the types String and Int
14:00:58 <ReinH> kraljev10: you would need to do something like data A = AS String | AI Int and then AS "foo" :: A
14:01:49 <kraljev10> thank you!
14:12:21 <TeddyMurray> how well does haskell pay?
14:12:38 <TeddyMurray> ive never even heard of it until i looked at the freenode channel list. i guess i was lost now im found :)
14:13:04 <carter> TeddyMurray: i'm starting a haskell job monday and its 1.5x any other offer i got in NYC
14:13:11 <carter> so theres that
14:13:20 <ReinH> TeddyMurray: well enough that it depends more on the particular job
14:13:23 <carter> yes that
14:13:23 <ReinH> carter: yay :)
14:13:27 <carter> ReinH: HAH
14:13:27 <TeddyMurray> awesome
14:13:42 <carter> ReinH: hows the deving the competitor to DarkMail going?
14:13:44 <EvanR> dang getting paid for haskell why didnt i think of that
14:13:46 <carter> that IS what you're doing now
14:13:55 <ReinH> carter: heh, I've been on vacation for a couple weeks
14:14:01 <ReinH> So that's what I'm doing now
14:14:02 <ReinH> but it's going well
14:14:03 <TeddyMurray> lmao EvanR
14:14:07 <carter> how many weeks is a couple?
14:14:12 <ReinH> two
14:14:18 <carter> cool
14:14:25 <ReinH> yeah, much needed break
14:14:34 <sinelaw> carter, cool! can I ask where?
14:14:42 <StoneCypher> carter: grats
14:14:49 * hackagebot type-iso 0.1.0.0 - Typeclasses for injective relations and isomorphisms between types.  http://hackage.haskell.org/package/type-iso-0.1.0.0 (jtapolczai)
14:14:51 * hackagebot duplo 1.6.6 - Frontend development build tool  http://hackage.haskell.org/package/duplo-1.6.6 (kenhkan)
14:14:57 <carter> sinelaw: if you look at my linked in you'll know
14:15:28 <carter> if i dont say their name publicaly, i can say dumb stuff online safely :)
14:15:42 <carter> or something
14:15:45 <carter> idk how it works
14:16:06 <StoneCypher> carter: good place to work.  high pressure though.
14:16:16 <StoneCypher> lots of space to go upwards if you do well.  lots of $$$ too.
14:16:21 <carter> StoneCypher: hehe
14:16:26 <carter> StoneCypher: high pressure how?
14:16:33 <StoneCypher> long hours, expectation to deliver
14:16:48 <carter> idk, the hours might be pretty sane ofr this group
14:16:50 <StoneCypher> high risk on security failures
14:16:51 <StoneCypher> oh?
14:17:03 <StoneCypher> well i'm speaking in vague generalities, so probably i shouldn't
14:19:49 * hackagebot storablevector 0.2.9.1 - Fast, packed, strict storable arrays with a list interface like ByteString  http://hackage.haskell.org/package/storablevector-0.2.9.1 (HenningThielemann)
14:40:57 <Zemyla_> @pl \ls -> Just (5:ls)
14:40:57 <lambdabot> Just . (5 :)
14:41:50 <Zemyla_> @pl \a -> maybe (Just [a]) (Just . (a:))
14:41:50 <lambdabot> ap (maybe . Just . return) ((Just .) . (:))
14:42:14 <Zemyla_> :t maybe . Just . return
14:42:15 <lambdabot> Monad m => a -> (a1 -> Maybe (m a)) -> Maybe a1 -> Maybe (m a)
14:42:52 <Zemyla_> :t ((Just .) . (:))
14:42:53 <lambdabot> a -> [a] -> Maybe [a]
14:50:02 <Luke> Was going to ask my question here but things seem pretty quiet now so I stuck it on reddit instead. http://www.reddit.com/r/haskell/comments/2r1l42/haskell_rest_libraryserver_breakdown/ If anyone's around to and has some input that'd be great
14:56:41 <Zemyla> @pl \(a, b) -> (length a, length b)
14:56:41 <lambdabot> length *** length
14:56:47 <Zemyla> :t ***
14:56:48 <lambdabot> parse error on input ‘***’
14:56:54 <Zemyla> :t (***)
14:56:55 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:59:30 <Norfair> \join #tsurucapital
15:00:14 <Norfair> woops
15:17:10 <Buttons840> System.Random says "but very little work has been done on statistically robust implementations of split" -- what does this mean? is it ok for me to be using split in my code?
15:17:40 <ReinH> Buttons840: it depends on what you need a source of randomness for
15:17:43 <rqiu_> need some help: defining an instance of functor, but because of the data type is [String] wrapped in a Data constructor, have to constrain f in fmap f to forall a f. f a -> [String], but not sure how to do it
15:17:46 <ReinH> System.Random is not a secure random number generator
15:18:01 <Buttons840> ReinH: nothing crypographic, just for a card game
15:18:21 <Buttons840> good to know though, where can you get crypo secure numbers in haskell?
15:18:50 <ReinH> Buttons840: http://hackage.haskell.org/package/cprng-aes might be a good choice
15:18:51 <hrumph_> hi
15:19:11 <hrumph_> what would you call a monad with a bind operator but no return function?
15:19:41 <hrumph_> i have come up with a monad-like thing but the identity laws for return don't work so i want to ditch the return
15:19:42 <johnw-> a Semimonad maybe
15:19:51 <ReinH> hrumph_: iirc that has been called "Bind" before?
15:20:00 <johnw-> I think edwardk calls it Bind
15:20:34 <hrumph_> is there a class in hackage?
15:21:11 <johnw-> hrumph_: http://hackage.haskell.org/package/semigroupoids-4.2/docs/Data-Functor-Bind.html
15:21:28 <hrumph_> ok thanks
15:23:36 <Benzi-Junior> anyone here know of interesting phd reaserch opportunities to do with haskell open for next year ?
15:24:08 <edwardk> it probably should be "Semimonad"
15:24:15 <edwardk> i'll eventually replace it i think
15:26:33 <Clint> what is >>=.\.ks' supposed to tell me in profiler output?
15:30:10 <RedNifre> How do I print a [IO String]? Can I turn it into an IO [String]?
15:31:56 <sshine> RedNifre, mapM_ (\iostr -> do { s <- iostr; putStrLn s }) iostrs
15:33:32 <sshine> @hoogle [IO String] -> IO [String]
15:33:34 <lambdabot> No results found
15:33:43 <ReinH> :t mapM_ putStrLn
15:33:44 <lambdabot> [String] -> IO ()
15:34:05 <ReinH> :t sequence (undefined :: [IO String])
15:34:06 <lambdabot> IO [String]
15:34:07 <EvanR> :t sequence
15:34:08 <lambdabot> Monad m => [m a] -> m [a]
15:34:19 <EvanR> :t T.sequenceA
15:34:20 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
15:34:51 <utdemir> @hoogle [m a] -> m [a]
15:34:51 <lambdabot> Parse error:
15:34:51 <lambdabot>   [m a] -> m [a]
15:34:51 <lambdabot>         ^
15:35:05 <utdemir> @hoogle [m a] -> m [a]
15:35:05 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
15:35:05 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
15:35:05 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
15:35:10 <hrumph_> can i use "do" syntax with a bind?
15:35:10 <utdemir> sshine: -^
15:35:25 <sshine> utdemir, it goes to RedNifre.
15:35:29 <RedNifre> ah, thanks.
15:35:33 <ReinH> hrumph_: I think you can with RebindableSyntax
15:36:20 <bananagram> can you remove input buffering from stdin, so it reads characters immediately?
15:37:01 <utdemir> @hoogle hSetBuffering
15:37:02 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
15:37:02 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
15:37:14 <bananagram> ah, thanks
15:42:04 <hrumph_> ReinH do i'll have to define >>= as being the same as >>- to get rebindable syntax to work, correct?
15:44:05 <ReinH> hrumph_: yeah
15:55:57 <RedNifre> How do you deal with the problem that Aeson is unable to parse values (e.g. "true" or 123)?
15:56:18 <RedNifre> I once wrote an email to the maintainer, but didn't get an answer.
15:58:01 <chrisdotcode> is Text.Regex in base?
15:58:44 <EvanR> RedNifre: isnt there a function that loosens the restriction that the top level value is an array or object
16:01:21 <geekosaur> chrisdotcode, regex-compat. it's in the platform, but not in base
16:01:50 <chrisdotcode> geekosaur: bah. that might be close enough-ish. my problem is a one line regex, and certainly doesn't need parsec
16:02:23 <chrisdotcode> Ideally, a no-install library in base is ideal, but being in the platform isn't bad
16:03:46 <EvanR> id like a cheatsheet which shows how to write any regex as a parsec parser
16:04:12 <chrisdotcode> EvanR: "Your brain" :)
16:04:20 <EvanR> its probably also one line for simple regexes
16:04:31 <RedNifre> EvanR that restriction isn't a part of the JSON standard (that restriction is from 2006 and deprecated). I see that there is a "value" function that you can use instead of "json", but how do I do that for Bool?
16:05:06 <chrisdotcode> EvanR: problem is, parsec is too heavy for my use-case
16:05:21 <vanila> if it solves the problem, is there a problem?
16:06:09 <EvanR> chrisdotcode: like its too slow?
16:06:38 <chrisdotcode> vanila, EvanR: As in 20 extra seconds of download time isn't worth the one-line regular expression I need solved.
16:06:52 <EvanR> RedNifre: parse value myBS
16:07:32 <vanila> have you measured the difference in program download time for using a regex library vs parsec?
16:07:36 <vanila> i doubt that it is 20 seconds
16:08:06 <chrisdotcode> I'm being hyperbolic, but unless parsec is also in the platform, regex-compat is infinitely faster to download, as it's already downloaded.
16:08:30 <ReinH> That's a pretty strange way to select a tool
16:08:46 <TallerGhostWalt> chrisdotcode: there are some simple parser things in the Text.Read module
16:08:49 <vanila> fair enough, but I think that  haskell-platform / haskell-platform+parsec is very close to 1
16:09:13 <exio4> unless the dependency was either lens or  src-exts, I wouldn't bother about that ;P
16:09:24 <chrisdotcode> ReinH: Carig about compilation time downloading a whole other package for a literal one line regex is odd?
16:09:47 <chrisdotcode> TallerGhostWalt: Sweet, I'll check them out
16:09:48 <ReinH> Yes.
16:09:50 <vanila> yeah it's really weird.. :)
16:09:55 <ReinH> And btw parsec is in the platform
16:10:11 <chrisdotcode> Oh, really? Even better, then.
16:10:13 <ReinH> And you don't download a package every time you compile...
16:10:15 <TallerGhostWalt> Text.Read.Lex, I mean really simple though
16:10:20 <EvanR> whether it already happens to be installed or not... ...
16:10:32 <chrisdotcode> I know, I'm assuming installation into a blank sandbox
16:10:40 * ReinH shrugs
16:10:49 <ReinH> I'm willing to pay a small one-time cost for access to the right tool
16:10:51 <ReinH> but to each their own
16:11:07 <chrisdotcode> Yeah, all I need is really simple; I need to match /(readme)\\.?(markdown|md)?/i
16:12:03 <geekosaur> parsec is in the platform
16:12:17 <chrisdotcode> * /(readme)\.?(markdown|md)?/i
16:12:18 <TallerGhostWalt> Text.Parser.Combinators is in base too
16:12:37 <chrisdotcode> Excellent, excellent, excellent
16:12:50 <geekosaur> RedNifre, I'm having trouble understanding your question
16:13:03 <chrisdotcode> Thanks guys.
16:13:13 <vanila> I still don't know what im doing with sandboxes/stackage/whatever the hell
16:13:15 <TallerGhostWalt> i totally agree with everyone though that trifecta or parsec are easier to use though
16:13:18 <vanila> i can't get a sensible workflow setup
16:13:34 <TallerGhostWalt> vanila: what is unsensible about it?
16:13:35 <geekosaur> also Text.ParserCombinators.Parsec (and Text.Parsec) are in the parsec package, not base
16:13:41 <geekosaur> but that package is part of the platform
16:14:36 <chrisdotcode> If parsec is in the platform, I can work with that; my target dev-machines are machines with the platform, but not other machines.
16:14:50 <chrisdotcode> aptitude installed' haskell-platform'd machines, essentially.
16:14:57 <ReinH> Honestly, what's the big deal about a negligible one-time cost to install a package?
16:15:00 <ReinH> I just don't get it
16:15:27 <chrisdotcode> Because it's not just for local machine use.
16:15:32 <chrisdotcode> I already have parsec installed locally.
16:15:33 <ReinH> So?
16:15:49 <chrisdotcode> All users of my program would have to install an extra package, just to parse a single line.
16:15:55 <vanila> it doesn't matter
16:16:12 <vanila> cabal just handles it all perfectly for them
16:16:16 <TallerGhostWalt> geekosaur: no I am looking at it in base , http://hackage.haskell.org/package/base-4.7.0.2/docs/Text-ParserCombinators-ReadP.html
16:16:38 <ReinH> So users of your program would do what they do to use every other haskell package. Seems fine.
16:16:53 <geekosaur> ReadP is not Parsec
16:17:05 <vanila> seconding ReadP, awesome lib
16:17:09 <vanila> way past cool
16:17:17 <TallerGhostWalt> geekosaur: I know, but it is usable for what he wants to do
16:17:37 <chrisdotcode> Yes, but I'd prefer to use as few dependencies as possible; both for not needing unnecessary imports, and for the extra download time.
16:17:48 <chrisdotcode> Why use a hammer when I need a tiny screwdriver, essentially.
16:18:01 <vanila> why use a tiny screwdriver when a gammer gets the job done 30 mins ago?
16:18:06 <vanila> hammer*
16:18:15 <chrisdotcode> Well now I'm just hearing your guy's opinions out :)
16:18:33 <TallerGhostWalt> chrisdotcode: so are you not going to use stuff like bytestring?
16:19:22 <chrisdotcode> Wait - hold on; am I being silly?
16:19:32 <chrisdotcode> Why did I think parsec had like 5 million dependencies?
16:19:34 <ReinH> The only reason people thing that regexp is a "tiny screwdriver" is because so many languages have native library and sometimes syntax support for them
16:19:38 <ReinH> *think
16:19:57 <ReinH> regexp are far from being a "tiny screwdriver"
16:20:01 <ReinH> parsers are the tiny screwdriver here
16:20:09 <EvanR> lol tiny screwdriver
16:20:12 <chrisdotcode> I mean in terms of codebase and install time.
16:20:18 <ReinH> So do I.
16:20:22 <chrisdotcode> I thought Parsec had a huge amount of deps, like lens.
16:20:40 <chrisdotcode> Bad memories of installs that took years there.
16:20:42 * chrisdotcode shudders.
16:20:48 <ReinH> lol, it has 3 dependencies
16:21:05 <chrisdotcode> 4, but close enough.
16:21:16 <chrisdotcode> Unless base doesn't count?
16:21:44 <ReinH> I don't count base as a dependency since it's ubiquitous
16:21:45 <edwardk> parsec has few dependencies, trifecta has a bunch
16:22:01 <chrisdotcode> I totally wasn't saying anything bad about lens just now, edwardk
16:22:09 <ReinH> regexp are not in any way simple
16:22:21 <edwardk> chrisdotcode: i was just speaking up for parsec, not lens =)
16:22:48 <vanila> I think combinator parsing is more modern and less easy to understand than regex
16:22:49 <EvanR> http://lpaste.net/117600
16:22:54 <chrisdotcode> Agreed, vanila
16:23:10 <vanila> the languages that regex capture are very very simple compared to what something like parsec handles
16:23:29 <chrisdotcode> So do you guys have a one-line (in parsec) for the following regex: /(readme)\.?(markdown|md)?/i
16:23:34 <dfeuer> Ping edwardk
16:23:35 <EvanR> in my paste there it shows that regexes are a simple subset of parsec
16:23:37 <edwardk> pong
16:23:49 <ReinH> vanila: if people were taught combinator parsing in uni that might be a bit different
16:23:56 <dfeuer> edwardk, it's a monadic tree unfold in Data.Tree.
16:24:21 <dfeuer> I have the feeling that if the answer is "it's impossible", then there probably is some way to do it in MonadFix.
16:24:28 <dfeuer> But that's a vague feeling.
16:24:30 <edwardk> so what is the BF in unfoldForestM_BF?
16:24:33 <EvanR> string "readme" >> option (char '.') >> option (string "markdown" <|> string "md")
16:24:37 <dfeuer> Breadth first.
16:24:41 <edwardk> ah k
16:24:43 <dfeuer> Which is what makes things hard.
16:24:48 <edwardk> yeah
16:25:00 <edwardk> does iterative deepening help?
16:25:04 <chrisdotcode> EvanR: Awesome. And beautiful, too. I've never learned parsing or compilers, but I really want to.
16:25:22 <chrisdotcode> I asked edwardk one time when he was sitting next to me at HacNY, but he was too smart to help me :)
16:25:50 <chrisdotcode> (in the sense that he tried, but I couldn't keep up mentally)
16:25:52 <ReinH> chrisdotcode: http://www.holub.com/software/compiler.design.in.c.html
16:25:58 <edwardk> chrisdotcode: sorry bout that
16:26:04 <nolrai66> EvenR: I think you need a try on the 'string "markdown"'
16:26:07 <dfeuer> I dunno exactly what you mean. I've so far come up with two approaches, each of which have problems. 1. descend from the top each time, getting deeper iteratively. This is bad because it gets O(n^2) with skinny trees.
16:26:17 <EvanR> nolrai66: yeah...
16:26:34 <dfeuer> 2. Flatten everything out, and then build it back up again (reminiscent of parsing, I think). This has a laziness problem.
16:26:40 <chrisdotcode> No worries, edwardk, it was the thought. Also, what you showed me at that moment was that haskell programmers can eventually get to the point where haskell comes out as naturally as Python for experiencedPython programmers.
16:27:04 <EvanR> as natural as python
16:27:08 <EvanR> i hope not ;)
16:27:20 <edwardk> #1 is iterative deepening depth first search
16:27:32 <chrisdotcode> ReinH: Can this take me from nothing to being able to implement? Let's Build a Compiler is too old, and the dragon book is basically "you need to know to design compilers before you can learn to design compilers"
16:27:45 <ReinH> chrisdotcode: yes
16:27:51 <chrisdotcode> Thanks!
16:27:59 <ReinH> chrisdotcode: np
16:27:59 <RedNifre> geekosaur, I complained that Aeson seems to be stuck on the 2006 JSON standard that did not allow parsing of things like "true" or 123 (only ["true"] or {"thing":"true"}) and now I wonder how to do that. I currently use decode and I guess I have replace it with parseOnly value, which returns an Either, so I checked hoogle for Either a b -> Maybe b, which leads to typeOf2 and Typeable, which I don't
16:28:01 <RedNifre> understand... am I thinking too complicated here?
16:28:10 <edwardk> you basically have to pick your poison, between leaking pointers to all the things at a given depth, and starting over and over and over
16:28:26 <dfeuer> edwardk, how's this "leaking pointers" thing work?
16:28:37 <geekosaur> you were talking about using the json combinator? value is a drop-in replacement for it
16:28:37 <chrisdotcode> EvanR: I can grok parsec from it's homepage?
16:28:41 <chrisdotcode> Or do you recommend the doc?
16:29:19 <seanparsons> I'm seeing a particularly baffling error from TH, which seems to have been barely experienced by anyone:
16:29:21 <dfeuer> Good question, chrisdotcode. I'd like to read a good intro to that too.
16:29:22 <seanparsons> https://www.irccloud.com/pastebin/OvcP8YNe
16:29:46 <chrisdotcode> dfeuer: I see people with knowledge, and then beginners in it, with no intermediates. The typical Haskell problem.
16:29:52 <RedNifre> No, I currently use decode. What's the json combinator?
16:29:55 <EvanR> chrisdotcode: well i read the doc, but only after someone explained how monadic parsers work in basic terms
16:30:06 <chrisdotcode> EvanR: Any linkages?
16:30:10 <nolrai66> I learned it from the homepage I think. (this was like 10 years ago so..)
16:30:11 <dfeuer> edwardk, how's this "leaking pointers" thing work?
16:30:55 <vanila> Q: Why do compiler books always start with 5 or more chapters on parsing?
16:31:12 <chrisdotcode> ^
16:31:31 <dfeuer> vanila, because most programming language designers read a lot about parsing and then get sick of reading and come up with a hacked up language with lots of fancy syntax.
16:31:37 <EvanR> chrisdotcode: none. but taking this sentence "Parser a is a function that takes an input stream and returns a [a] list of possible parses, and the remaining input stream" and seeing if you can implement something yourself is a good start
16:31:40 <chrisdotcode> Most compiler books are "know how to build a compiler if you want to learn how to build a compiler"
16:32:21 <chrisdotcode> EvanR: I've read the functional pearl, and can certainly grok it all, given knowledge of the parsec combinators
16:32:32 <EvanR> er list of a and the remaining stream for that parse
16:32:58 <geekosaur> ideally it'd be because you need to know the pitfalls of parsing to know how to design a language which can be parsed sensibly
16:33:14 <EvanR> lisp? ;)
16:33:32 <geekosaur> a language spec which allows for some program to have multiple interpretations depending on parser vagaries is a bad language spec
16:33:42 <ReinH> EvanR: I like http://www.willamette.edu/~fruehr/haskell/seuss.html
16:34:22 <EvanR> type Parser a = String -> [(a, String)]
16:34:28 <EvanR> good stuff
16:34:40 <vanila> parsec itself is a bit more advanced than just that
16:34:45 <EvanR> and then parsec is a bunch of stuff loaded onto that
16:34:56 <geekosaur> (iirc, haskell98's brace insertion rule had this problem!)
16:35:24 <TallerGhostWalt> I love all the language definition stuff in parsec
16:35:37 <nolrai66> geekosaur (What problem?)
16:35:45 <chrisdotcode> Ambiguous parsing.
16:37:01 <fizbin> The hardest thing about parsers that I've found is getting decent error messages out of them.
16:37:18 <TallerGhostWalt> fizbin: trifecta!
16:37:32 <ReinH> trifecta is pretty good
16:37:39 <dfeuer> Haskell's syntax is just too complicated.
16:37:45 <dfeuer> ReinH, does trifecta have documentation?
16:37:53 <TallerGhostWalt> dfeuer: no!
16:37:54 <TallerGhostWalt> lol
16:37:57 <geekosaur> nolrai66, as the brace insertion rule was written in the H'98 standard, two compilers could be fully Haskell98 compliant but parse something differently because the brace insertion rule was not fully deterministic
16:38:11 <geekosaur> that is, two compilers could make different but equally conformant decisions
16:38:25 <geekosaur> (I seem to recall someone demonstrating such a case with ghc and hugs)
16:38:39 <dfeuer> Undocumented packages are hard to use.
16:38:48 <fizbin> Specifically, if you're going to write something like a compiler, it's nice for the user if you don't just crash after the first error, but try to recover and maybe find multiple errors in a single pass.
16:39:22 <TallerGhostWalt> dfeuer: yes!
16:39:34 <TallerGhostWalt> fizbin: right, like industrial grade parsers
16:39:53 <dfeuer> Unfortunately, it seems edwardk has given up on trifecta for now.
16:40:24 <ReinH> dfeuer: what is it missing?
16:40:24 <fizbin> Right. Why does it seem that none of haskell's parser combinator libraries are aimed at building industrial grade parsers in that sense?
16:40:33 <TallerGhostWalt> fizbin: trifecta!
16:40:34 <dfeuer> ReinH, it's definitely missing documentation.
16:40:39 <ReinH> true enough
16:40:51 <dfeuer> I also hear it's on the slow side. But I care a lot more about the missing documentation.
16:40:52 <ReinH> although most of the time you're using it via the parsers interface
16:40:55 <TallerGhostWalt> fizbin: yeah fail over and alt path parsing is a lot more complex
16:41:31 <TallerGhostWalt> fizbin: you said "bleh" but you probably meant "blah" so I'll just try it, that kind of stuff?
16:41:43 <dfeuer> I don't know nearly enough about parsing to understand the Haddocks for any of these things :/
16:42:03 <fizbin> I said what?
16:42:17 <sshine> vanila, why shouldn't a basics compiler book start off with introduction to parsers? if we assume that parsing is one of the first stages of compilation, it makes sense to start off by learning that.
16:42:29 <TallerGhostWalt> fizbin: "it's nice for the user if you don't just crash after the first error,
16:42:29 <TallerGhostWalt>          but try to recover and maybe find multiple errors in a single pass."
16:42:51 <sshine> vanila, (on a side note, I just TA'ed a compilers course where all the parsing bits were left for last.)
16:43:05 <fizbin> TallerGhostWalt: Oh, I get what you mean.
16:43:06 <dfeuer> sshine, sounds sensible to me.
16:43:26 <sshine> dfeuer, one doesn't really need to know how to build a parser generator in order to use one. :)
16:43:30 <dfeuer> sshine, the entire LISP family pretty much gets by wwithout.
16:43:34 <vanila> sshine, well im not too sure, I'm trying to learn to write a compiler myself but all the books want me to sit through weeks for parsing which isnt' too interesting to me
16:43:45 <vanila> so it just stuck out to me that they always do this
16:43:52 <rqiu> let me try to rephrase my question.  Is there a way to add kind constraints to a typeclass instance?  For example, in my instance, can I constrain the fmap to take a function (a -> String) instead of (a -> b)?
16:43:52 <chrisdotcode> So guys, why is Go's compiler so fast, but Haskell slow? Does this have more to do with the hand-implementation, or the language parsing rule?
16:43:55 <TallerGhostWalt> So, if I have a tree and I want to replace an element deep in the tree, what is the best way to do this?
16:43:55 <chrisdotcode> *rules
16:43:56 <sshine> vanila, ah. yeah, I guess learning the syntax for yacc or similar should be sufficient.
16:44:08 <fizbin> And.. sort of. More something like "You had a syntax error inside this construct, so the compile will fail, but after this close-brace, let's pick up where we were before and see if there are multiple error messages in the rest of the program to find"
16:44:14 <geekosaur> vanila, did you catch what I said about why the parser stuff can be useful?
16:44:18 <dfeuer> chrisdotcode, it's mostly not about parsing. GHC parses pretty quickly, IME.
16:44:27 <sshine> vanila, or, if you follow some of the "make a compiler with Haskell" tutorials, just use whatever library they recommend.
16:44:28 <chrisdotcode> dfeuer: What's the primary bottleneck?
16:44:28 <TallerGhostWalt> I mean direct replacement
16:44:41 <vanila> geekosaur, yeah that is a very good point
16:44:49 <TallerGhostWalt> I suppose I really mean, is there a data structure that has been set up to allow direct replacement of deep elements in a tree?
16:44:51 <dfeuer> Type checking sometimes takes longer than one might expect, and then optimization can take a while.
16:44:54 * hackagebot json-rpc 0.2.1.2 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.2.1.2 (XenoGenesis)
16:44:57 <geekosaur> you really do not want to design a language where some "irrelevant" implementation detail in (say) byacc vs. bison leads to each parsing programs differtently
16:45:02 <yukko> rqiu class C (a :: *) works for me
16:45:09 <yukko> with -XKindSignatures
16:45:12 <fizbin> TallerGhostWalt: You seem to be talking about a Zipper.
16:45:24 <TallerGhostWalt> zippers traverse the tree though
16:45:37 <TallerGhostWalt> Maybe you just have to
16:45:40 <dfeuer> TallerGhostWalt, that's (approximately) my current problem :-/
16:45:44 <rqiu> @yukko: not class, but in the instance definition
16:45:44 <lambdabot> Unknown command, try @list
16:45:56 <geekosaur> but, you need to know something abotu parsing to know what to watch out for, granted, this is less compilers than language design, but they often go together especially in university courses
16:45:57 <TallerGhostWalt> dfeuer: yeah I thought it looked similar
16:46:04 <yukko> you want the constaint in the instance definition?
16:46:07 <yukko> hmm
16:46:24 <rqiu> yes
16:46:28 <vanila> http://alephnullplex.github.io/cradle/chapters/introduction.html like this?
16:46:47 <rqiu> I want to constrain the instance to only take a subset of the types
16:46:56 <TallerGhostWalt> would an indexed tree of MVars just be awful? cause that is where I am heading
16:47:13 <yukko> instance C (Maybe (a :: *)) ?
16:47:18 <TallerGhostWalt> stm-containers Map of index (MVar a)
16:47:45 <nolrai66> Can I talk a problem out here? I am having trouble figureing out what I want my data structure to look like.
16:47:46 <yukko> seems to work for me
16:47:50 <TallerGhostWalt> then some indexed tree of those MVars
16:48:00 <EvanR> dont do it!
16:48:02 <rqiu> so let's take the functor typeclass
16:48:08 <ab9rf> nolrai66: i don't think that would be problematic.
16:48:29 <fizbin> rqiu: "Take my Functors, please"?
16:48:31 <EvanR> TallerGhostWalt: the Data.Map allows "direct replacement" doesnt it?
16:48:43 <rqiu> how do I constrain my instance to limit fmap only takes f with a type signature (a -> [String])?
16:49:06 <EvanR> rqiu: that wouldnt be a functor then would it
16:49:09 <fizbin> rqiu: That's not a Functor, then.
16:49:11 <TallerGhostWalt> EvanR: yeah I could implement it in map as a pseudo tree I suppose
16:49:25 <TallerGhostWalt> EvanR: coding the tree structure in the index
16:49:31 <EvanR> oh you want a tree
16:49:50 <EvanR> data Tree a = Tree a [Tree a] ?
16:49:51 <TallerGhostWalt> Yeah, basically I am trying to write a DOM stub
16:49:54 * hackagebot table 0.1.0.0 - Simple tool to generate tables from DSV input  http://hackage.haskell.org/package/table-0.1.0.0 (DanielChoi)
16:49:59 <rqiu> right, might be a bad example
16:50:47 <fizbin> Well, HXT seems to do rather well manipulating what are essentially DOM trees with lots of arrows.
16:50:51 <rqiu> but is my original question valid?
16:50:52 <TallerGhostWalt> EvanR: it can be : data Tree i a = Tree i a [Tree i a]
16:51:02 <TallerGhostWalt> with i as an index
16:51:15 <ReinH> rqiu: you can't change the type of a typeclass member function in an instance definition
16:51:42 <rqiu> ok
16:51:44 <EvanR> TallerGhostWalt: well, thats isomorphic to my version because you can use a product type. as far as lookup is concerned, that i wont help, and you just use numeric indexes
16:51:54 <vanila> any links to compiler tutorials?
16:52:00 <TallerGhostWalt> EvanR: yeah I saw that after I typed it :(
16:52:02 <vanila> for haskell or similar
16:52:16 <rqiu> but why was it this way?  any problems if allowed?
16:52:37 <EvanR> TallerGhostWalt: lookup or replacement
16:52:44 <TallerGhostWalt> EvanR: replacement
16:52:58 <fizbin> vanila: Some ok references can be found at https://www.reddit.com/r/haskell/comments/21x8br/tutorial_for_building_a_compiler_in_haskell/
16:52:59 <EvanR> i mean you can use a list of numbers for looking up or replacing
16:53:09 <Welkin> TallerGhostWalt: http://hackage.haskell.org/package/rosezipper-0.2/docs/Data-Tree-Zipper.html
16:53:32 <TallerGhostWalt> Welkin: but that traverses the tree right?
16:53:36 <Welkin> TallerGhostWalt: Map is actually a tree underneath
16:53:41 <e11> hey everybody!!!
16:53:44 <nolrai66> So I have these things that can be composed in three differnt ways.
16:53:55 <EvanR> TallerGhostWalt: if you only have data at the leaf nodes though, theres data Tree a = Leaf a | Tree [Tree a]
16:54:08 <TallerGhostWalt> Welkin: yes but it is organized differently than the structure of the tree I want
16:54:30 <nolrai66> So I guess I want like a 3d list?
16:54:55 * hackagebot nibblestring 0.0.3 - Packed, strict nibble arrays with a list interface (ByteString for nibbles)  http://hackage.haskell.org/package/nibblestring-0.0.3 (jamshid)
16:54:55 <TallerGhostWalt> EvanR: I think I missed how the direct insert happens
16:55:10 <nolrai66> ..no that doesn't work because the the second two can interweave.
16:55:19 <TallerGhostWalt> EvanR: Don't I still have to traverse the tree to find what I want to replace
16:55:40 <EvanR> TallerGhostWalt: you seem to implying that you want something like pointers into a mutable data structure, and you only need the pointer and not the data structure itself to have some side effect
16:55:44 <ab9rf> TallerGhostWalt: just the branch of interst, not the entire tree
16:55:44 <Welkin> TallerGhostWalt: what is wrong with traversing a tree?
16:55:51 <Welkin> log n is very fast
16:55:56 <ab9rf> traversing a fairly balanced tree is log n
16:56:13 <EvanR> were not talking about a binary search tree
16:56:16 <ab9rf> as long as the tree is more or less balanced
16:56:28 <EvanR> its O(n) where n is the depth of the thing youre interested in
16:56:30 <ab9rf> er, not traversing, but finding a particular node
16:56:44 <ab9rf> EvanR: yeahg, but depth is log n if the tree is "more or less" balanced
16:56:50 <EvanR> its not balanced
16:56:59 <ab9rf> if it's not balanced then it's O(n)
16:57:14 <nolrai66> I think you want two differnt trees to the same values?
16:57:16 <ab9rf> at least in the wurst case
16:57:16 <TallerGhostWalt> EvanR: nothing is wrong with it.  But my question was, if there was a way to not do it
16:57:24 <ab9rf> now i want a sausage
16:57:34 <nolrai66> So you can keep one balenced to seach through?
16:57:40 <EvanR> were discussing two different things, search tree like Data.Map is for lookups, and Tree-like structures are for Tree data which you use something like xpath on
16:58:11 <TallerGhostWalt> I was thinking of making the tree data Tree (MVar a)
16:58:18 <nolrai66> Right, but you want a tree that you can replace branches of?
16:58:48 <EvanR> TallerGhostWalt: you can simulate a network of C structs and pointers, but its going to be painful. rather than do it directly, you might want to use an IntMap to model your situation purely
16:58:50 <TallerGhostWalt> then having an index (MVar a) map
16:59:25 <TallerGhostWalt> EvanR: is what I am saying similar to what you are saying ?
16:59:35 <EvanR> thats going to traverse some search tree to find your mvar right?
16:59:55 * hackagebot appc 0.0.5 - app container types and tools  http://hackage.haskell.org/package/appc-0.0.5 (wereHamster)
16:59:58 <EvanR> no youre talking about using mutable variables, and i was suggesting a pure structure
17:00:07 <TallerGhostWalt> k
17:00:23 <gamegoblin> Which do you guys prefer — `f` x      or       flip f x
17:00:34 <TallerGhostWalt> I would be able to look the MVar up in the Map
17:00:35 <ab9rf> gamegoblin: depends
17:00:46 <gamegoblin> ab9rf: on?
17:00:49 <TallerGhostWalt> which would be a reference to the value stored in the tree right?
17:00:51 <EvanR> TallerGhostWalt: but why is that better than traversing your tree directly?
17:01:07 <ab9rf> gamegoblin: depends on which yields a clearer indication of code intent in the circumstance
17:01:15 <ReinH> TallerGhostWalt: So rather than traverse a tree you have Data.Map traverse a tree... ;)
17:01:36 <ab9rf> ReinH: heh
17:01:45 <ab9rf> abstract it away, so you don't have to think about it
17:01:49 <TallerGhostWalt> ReinH: Right, but I figured Data.Map is a very optimized for indexes tree
17:01:54 <EvanR> (and the data.map is going to be deeper since its representing your whole structure)
17:02:01 <TallerGhostWalt> whereas the tree I would be traversing is representational of a document structure
17:02:23 <EvanR> yeah, you really want to use your document directly
17:02:32 <ab9rf> gamegoblin: one of the reasons for having essentially equivalent syntaxes is to allow for code to be written in more than one way to allow the code to be more readily self-documenting.
17:02:58 <TallerGhostWalt> EvanR: okay so you are saying that an Int Map to look up an MVar and edit it would be slower than traversing a tree
17:03:17 <TallerGhostWalt> that is a Tree
17:03:17 <EvanR> its more complex
17:04:10 <EvanR> what are some dom operations you do... "nth child please" this would be !! on the branches of a node
17:04:22 <EvanR> "append new node here" thats (:)
17:04:54 <EvanR> and searching requires some kind of traversal of a tree
17:05:17 <EvanR> if at least to build the index to search faster
17:05:23 <vanila> if you're going to be editing deep inside the structure you might want a zipper
17:06:00 <TallerGhostWalt> what if you have two functions and they are going to be manipulating the same deep leaf, my thought was to have them look up that index in a map and then edit that MVar
17:06:13 <augur_> is there a tutorial anywhere on how to elegantly do automatic parenthesization for pretty printing?
17:06:29 <TallerGhostWalt> EvanR: really you already gave me the answer which is it is a bad idea!
17:06:30 <EvanR> you can do both at once
17:06:48 <EvanR> two functions can be composed ;)
17:06:58 <TallerGhostWalt> yes but only in advance
17:07:06 <EvanR> or dynamically
17:07:13 <TallerGhostWalt> on different threads?
17:07:38 <TallerGhostWalt> I mean it gets to be a more complicated problem to compose the functions than to share the data
17:07:41 <EvanR> you want concurrent updates to the same mutable structure?
17:07:57 <TallerGhostWalt> yeah
17:08:05 <TallerGhostWalt> one DOM
17:08:08 <EvanR> using basically pointers ;)
17:08:16 <TallerGhostWalt> I know :(
17:08:24 <EvanR> well dont do it lol
17:08:48 <TallerGhostWalt> EvanR: <TallerGhostWalt> EvanR: really you already gave me the answer which is it is
17:08:48 <TallerGhostWalt>                  a bad idea!
17:09:07 <vanila> i think zippers can be done ina concurrent way
17:09:15 <vanila> its pretty tricky though, i dont know the details
17:09:50 <EvanR> im not sure it makes sense to be doing concurrent dom edits, like, not serialized at all
17:10:41 <TallerGhostWalt> EvanR: yeah, everything I am trying to do is GHCJS side
17:11:02 <EvanR> if you have one MVar MyTree, this makes more sense to be having many threads modifying, by borrowing it and swaping in the new version
17:11:25 <EvanR> in which case MyTree can be immutable
17:11:38 <TallerGhostWalt> EvanR: so just swap the tree every time
17:11:39 <EvanR> the zipper thing can give you the concept of a pointer
17:11:48 <EvanR> yes thats how it works
17:11:56 <vanila> augur_, I couldn't find a tutorial but the trick is just to pass in a precidence level
17:12:06 <TallerGhostWalt> EvanR: yeah I know how zippers work, it just seems so much less efficient than modifying directly
17:12:09 <vanila> then you know when you can omit a bracket
17:12:18 <augur_> vanila: hmm.
17:12:29 <EvanR> you may have some preconceptions about how you think these structures get updated
17:12:40 <TallerGhostWalt> EvanR: I'm sure!
17:12:41 <EvanR> updating with a zipper is fast
17:12:53 <EvanR> as long as you are pointing at the right thing
17:13:28 <TallerGhostWalt> EvanR: i'll just give it a try and see
17:13:36 <TallerGhostWalt> EvanR: thanks so much
17:13:57 <dfeuer> One problem with zippers is that you don't have any hope of laziness.
17:14:29 <vanila> zippers are lazy
17:14:42 <vanila> I use them on an infinite tree and it works ok
17:15:44 <dfeuer> vanila, what I means is that there are cases where a modification to a tree can be done "top-down", so you get immediate access to the new root and the changes propagate down. I don't *think* you can do such nice things with zippers, can you?
17:16:21 <vanila> i dont really understand :(
17:16:51 <dfeuer> Well, maybe I'm confused?
17:17:10 <dfeuer> But to get from a zipper to a tree, you need to zip the zipper.
17:17:20 <dfeuer> Everything's backwards.
17:17:36 <vanila> yeah that's true
17:18:19 <edwardk> dfeuer: breadth first search normally needs to keep hold of all the pointers to the next level to keep walking, id-dfs achieves the same result by re-walking the tree
17:19:27 <dfeuer> edwardk, so is there some pleasantly lazy way to keep hold of those pointers?
17:20:17 <dfeuer> Or izzat some sorta lost cause?
17:23:27 <kix11> testing
17:23:32 <kix11> haha yay
17:30:59 <calvinx> I am using Haskell Platform on Mac OS X and I just discovered that there’s no way to uninstall a cabal installed package???
17:32:03 <lachenmayer> calvinx: yeah, that's a bit of a mess... `ghc unregister` does the trick
17:32:28 <calvinx> target ‘unregister’ is not a module name or a source file
17:32:42 <lachenmayer> there's also a helpful cabal package called `cabal-uninstall`
17:32:56 <calvinx> which I tried but doesn’t work either.
17:33:08 <lachenmayer> oops sorry, ghc-pkg unregister
17:33:29 <calvinx> ghc-pkg: cannot find package hsenv
17:33:39 <calvinx> `which hsenv` says “/Users/calvin/Library/Haskell/bin/hsenv"
17:36:39 <lachenmayer> package names include the version, do `ghc-pkg list` to check the actual name you're looking for
17:36:54 <lachenmayer> so it'll likely be something like "hsenv-0.5"
17:38:57 <calvinx> for some reason, ghc-pkg cannot find the hsenv that I have previously installed using cabal install……. :-/
17:39:29 <geekosaur> that sounds like you managed to reset your package database or installed a new ghc; the bin directory will still have the executable but the library is goe
17:39:31 <geekosaur> *gone
17:39:39 <geekosaur> just remove the hsenv binary manually
17:40:43 <calvinx> cabal list does manage to locate it.
17:41:13 <calvinx> ok, that sucks. I guess I will remove it manually.
17:41:26 <calvinx> I am shocked that cabal doesn’t do uninstall… makes no sense...
17:41:51 <geekosaur> poeple always expect cabal to be a package manager
17:41:56 <geekosaur> ghc won't let it be the package manager
17:41:58 <calvinx> well, it should be...
17:42:05 <geekosaur> ghc-pkg is the package manager
17:42:21 <calvinx> then ghc-pkg should handle the install as well.
17:42:24 <geekosaur> ghc-pkg is incomplete and if you try to work around it, it will break things even worse
17:42:33 <calvinx> the splitting of responsibility is what confuses people
17:42:43 <calvinx> install and uninstall should come together.
17:42:49 <geekosaur> and there are *unfortunately) good reasons for this. but it means cabal-install, and its developers, are caught in an impossible position
17:43:04 <Iceland_jack> Yeah it's a shame
17:43:06 <calvinx> can I know what the reasons are?
17:43:25 <calvinx> it’s bad to have inconsistent interfaces like this.
17:44:54 <geekosaur> ghc libraries are not just compiled libraries but contain source components for cross-module inlining. it's not really possible for any external tool to keep library/package dependencies straight
17:45:09 <geekosaur> because you need an exact match, not just same version but same *exact build*
17:45:35 <geekosaur> this snowballs through all the dependencies and produces an impossible mess.
17:46:23 <geekosaur> the ghc folks were actually talking about installs building every possible combination of packages in order to minimize conflicts as a serious proposed solution. I suspect what's actually going to end up happening is a move to whole-program compilation
17:47:06 <calvinx> wouldn’t that cause build times to be unacceptably long?
17:47:15 <ab9rf> get more cores.
17:47:26 <geekosaur> indeed, that is why things are as they are now, where they're either reasonable or impossible
17:47:35 <geekosaur> take your pick
17:47:39 <calvinx> that sucks… :/
17:48:01 <geekosaur> also, the reason ghc insists on cross-module inlining is that otherwise performance is terrible
17:48:31 <ab9rf> in general, i'm willing to sacrifice build time for runtime performance, the idea being "build once, run many"
17:48:40 <calvinx> ab9rf: “get more cores” isn’t a good solution if you want to use haskell in arm5,6,7 devices like raspberrypi.
17:48:40 <Iceland_jack> That's basically the curse of depending on inlining like GHC does
17:48:48 <Iceland_jack> *so much
17:48:54 <geekosaur> yep
17:49:18 <ab9rf> calvinx: i'm nt convinced that we need to be that concerned about supporting a build environment in what is essentially an embedded envrionment
17:49:21 <geekosaur> C has a similar problem if you do inlining via macros. KDE used to do this and found out the hard way that it makes include files part of your binary compatibility contract
17:49:30 <ab9rf> i really don't care if ghc runs acceptably on a Pi.
17:49:42 <calvinx> golang compiles in arm perfectly. and crazy fast too.
17:50:39 <ab9rf> i do care that ghc-compiled code runs acceptably on a PI.
17:50:52 <calvinx> so cross compile
17:50:53 <calvinx> ?
17:51:09 <ab9rf> cross-compilation is a time-honored practice.
17:51:17 <geekosaur> cross compilation is its own little nightmare with ghc
17:51:24 <calvinx> :(
17:51:37 <ab9rf> geekosaur: so address that, don't cripple ghc so it will run on an extremely limited platform.
17:52:06 <geekosaur> they're trying to...
17:52:09 <ab9rf> it is a problem that we haven't had decent cross-comp platforms (at all, really) for a long time
17:52:13 <ab9rf> and not just for haskell
17:52:51 <geekosaur> paet of the problem is that cross compilation currently depends on llvm, and llvm is a moving target that breaks ghc a lot because the llvm devs care more about their supported languages and pay little attention to the needs of niche stuff like ghc
17:52:55 <ab9rf> i've never really understood why, but then again i'm not a compiliation toolchain expert
17:53:10 <geekosaur> I know enough about it to know that it's much, much easier said than done
17:53:29 <geekosaur> let's put it this way: llvm was designed to *solve* cross compilation issues
17:53:47 <ab9rf> geekosaur: anything that seeks to solve them usually makes them worse
17:53:50 <geekosaur> llvm does not look like the kind of thing you'd want to solve it; you would think it'd be an easier problem
17:53:53 <geekosaur> but it's not
17:54:33 <ab9rf> it just makes the problems more abstract instead of actually resolving them
17:54:53 <ab9rf> i think part of the problem is that the ARM and i86 instruction sets are so different
17:54:53 <geekosaur> there's a reason for that
17:55:09 <geekosaur> specifically, that other methods have been tried and all of them have major porblems
17:55:15 <ab9rf> RISC v CISC and all that
17:55:30 <ab9rf> but i've never touched the ARM architecture
17:55:49 <ab9rf> my background is as a VAX-11 programmer, and it's hard to get more CISCy than VAX-11
17:58:28 <Iceland_jack> Man searching for "product preorder" is annoying
17:59:02 <ab9rf> were you looking for something other than ecommerce?
17:59:17 <Iceland_jack> Yes :) but Google doesn't think so
17:59:29 <ab9rf> heh
17:59:44 <oleo>  lol
17:59:53 <ab9rf> i wish google had the ability to restrict to a particular semantic meaning of a word
18:01:12 <ab9rf> whiskey is a remarkably effective treatment for muscle pain, but it has side effects.
18:03:00 <EvanR> > succ 2014
18:03:01 <lambdabot>  2015
18:03:27 <ab9rf> 2014 is dead, leave it be
18:03:37 <ab9rf> odd numbered years are better anyhow
18:03:54 <EvanR> when is the next prime year number
18:04:26 <EvanR> 2017
18:07:12 <Sornaensis> http://www.godhateselves.com/
18:08:21 <Welkin> > pred 2015
18:08:23 <lambdabot>  2014
18:08:37 <Welkin> > pred False
18:08:38 <lambdabot>  *Exception: Prelude.Enum.Bool.pred: bad argument
18:08:42 <Welkin> > pred True
18:08:43 <lambdabot>  False
18:09:03 <Welkin> > pred cos
18:09:05 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
18:09:05 <lambdabot>    arising from a use of ‘M876912609970277169913607.show_M8769126099702771699...
18:09:05 <lambdabot>  The type variable ‘a0’ is ambiguous
18:09:35 <Welkin> > cos 0
18:09:36 <lambdabot>  1.0
18:09:49 <EvanR> > pred cos :: Double -> Double
18:09:50 <lambdabot>  No instance for (GHC.Enum.Enum
18:09:51 <lambdabot>                     (GHC.Types.Double -> GHC.Types.Double))
18:09:51 <lambdabot>    arising from a use of ‘GHC.Enum.pred’
18:10:45 <Welkin> > succ Nothing
18:10:46 <lambdabot>  No instance for (GHC.Show.Show a0)
18:10:47 <lambdabot>    arising from a use of ‘M305147527205027141213669.show_M3051475272050271412...
18:10:47 <lambdabot>  The type variable ‘a0’ is ambiguous
18:11:01 <Welkin> > succ Nothing :: Maybe Int
18:11:02 <lambdabot>  No instance for (GHC.Enum.Enum (Data.Maybe.Maybe GHC.Types.Int))
18:11:03 <lambdabot>    arising from a use of ‘GHC.Enum.succ’
18:14:58 * hackagebot unagi-chan 0.3.0.0 - Fast concurrent queues with a Chan-like API, and more  http://hackage.haskell.org/package/unagi-chan-0.3.0.0 (BrandonSimmons)
18:22:13 <Arnie01> Hello is there someone who I can ask for help
18:22:19 <vanila> just ask here
18:22:25 <vanila> if someone knows they might tryto help
18:23:43 <arrdem> so for Clojure I have an emacs script "align-cljlet" that will indent datastructures and let forms "idiomatically". Is there something equivalent for Haskell?
18:23:46 <Arnie01> ok, it's about irc in general and identities, I connected on some irc channel and after few ip resets I connected again and mods recognized me, how is that possible, how do they know my identity after ip reset?
18:23:49 <calvinx> so how do I use the libraries I have installed in the cabal sandbox?
18:24:20 <calvinx> `cabal sandbox init` in my project directory, followed by `cabal install yesod` seems to work great.
18:24:41 <calvinx> but `yesod` isn’t available at command line...
18:25:52 <sshine> calvinx, try and find the yesod binary in a subdirectory in your sandbox and add this path to $PATH.
18:26:54 <sshine> calvinx, I think it might just be: export PATH="~/.cabal-sandbox/bin:$PATH" or something similar.
18:27:54 <kazagistar> arrdem: I don't know of one, but there are a few contrasting styles I have seen, so I am not sure if there is a particular "idomatic" way to do things... I am sure there is something out there if you just want formatting though
18:28:31 <geekosaur> calvinx: "cabal exec yesod" maybe?
18:29:39 <calvinx> sshine: yes, prepending cabal sandbox’s bin to $PATH works.
18:30:06 <calvinx> geekosaur: there’s no “exec” subcommand… :(
18:30:25 <CyberAce> Hello guys, happy new years!
18:30:47 <geekosaur> what version of cabal-install is this?
18:31:07 <calvinx> cabal-install version 1.18.0.5
18:32:59 <sshine> calvinx, were you thinking of something alternative to this, where you do 'cabal ...'?
18:33:23 <calvinx> that would be better.
18:33:40 <calvinx> otherwise, I have to create a “virtualenv.sh” like shell script like how the python virtualenv works.
18:34:37 <calvinx> in case you have not use python and python’s virtualenv, what it simply does is to automate `export PATH=“~/myproject/.cabal-sandbox/bin:$PATH" `
18:35:07 <Enzoray> Hey guys
18:35:39 <Enzoray> I'm supposed to split a "String" into two pieces where "/" is written.
18:35:59 <Enzoray> Given; split :: String -> (String,String)
18:36:14 <Enzoray> Why doesn't this work;
18:36:14 <Enzoray> split :: String -> (String,String)
18:36:15 <Enzoray> split a = (takeWhile (>'/') a, (takeWhile (<'/') a))
18:36:24 <vanila> why not write it using recursion on the string
18:36:27 <vanila> a string is just a list of characters
18:36:35 <vanila> so there is a case for '/':rest, and x:xs
18:36:44 <Enzoray> split has to be defined that way
18:36:47 <sshine> Enzoray, System.FilePath has useful functions here.
18:37:07 <geekosaur> Enzoray, becayse (>'/') does not look for characters after a '/', it looks for characters which compare greater than '/'
18:37:10 <vanila> it doesn't have to
18:37:35 <geekosaur> > '/" > '?'
18:37:36 <lambdabot>  <hint>:1:2: parse error on input ‘/’
18:37:47 <geekosaur> > '/' > '?'
18:37:49 <lambdabot>  False
18:37:58 <geekosaur> > ord '/'
18:37:59 <lambdabot>  47
18:38:25 <Enzoray> geekosaur, any easy way to fix this?
18:38:40 <mikeplus64> Enzoray: you could write it as (takeWhile (/= '/') a, dropWhile (/= '/') a)
18:39:40 <Enzoray> mikeplus64, then I get the "/" with the other word.
18:39:50 <mikeplus64> you can use 'drop 1' or 'tail' to drop it
18:40:08 <EvanR> > drop 1 []
18:40:10 <lambdabot>  []
18:40:33 <mikeplus64> > tail []
18:40:34 <Enzoray> drop 1 means..? dropping the first element in the list?
18:40:34 <lambdabot>  *Exception: Prelude.tail: empty list
18:40:55 <mikeplus64> Enzoray: yes. it's the same as tail but it won't throw an error if the list is empty
18:41:07 <Enzoray> Oh, okay.
18:42:20 <Enzoray> Is there any function that removes duplicates?
18:42:37 <sshine> nub
18:42:42 <Enzoray> Ex. randomFunction [1,2,2,3]
18:42:44 <Enzoray> Oh, oj.
18:42:46 <Enzoray> ok.
18:43:29 <Enzoray> I'm supposed to write a quickcheck-property for nub. Is this right?
18:43:33 <dhrosa> > let randomFunction = nub in randomFunction [1,2,2,3]
18:43:34 <lambdabot>  [1,2,3]
18:43:47 <sshine> Enzoray, you're supposed to test the standard library?
18:44:00 <Enzoray> randomFunction xs = (nub xs) == (xs)
18:44:48 <Enzoray> sshine, I have an exam soon
18:44:50 <EvanR> > nub [1,2,2,4] == [1,2,2,4]
18:44:51 <lambdabot>  False
18:45:18 <sshine> Enzoray, are you testing for duplicates or removing them?
18:45:33 <Enzoray> Consider the function
18:45:33 <Enzoray> nub :: Eq a => [a] -> [a]
18:45:33 <Enzoray> It removes all elements from the list that occur more than once.
18:45:33 <Enzoray> For example:
18:45:33 <Enzoray> Main> nub "Mississippi"
18:45:34 <Enzoray> "Misp"
18:45:34 <Enzoray> Main> nub [5,4,5,1,2]
18:45:35 <Enzoray> [5,4,1,2]
18:45:35 <Enzoray> Do not implement this function! Instead, define a QuickCheck property about nub that expresses that the resulting list does not contain any duplicate elements.
18:46:05 <sshine> Enzoray, ah. then that is right. :P
18:46:11 <Enzoray> I DID IT½!
18:46:14 <Enzoray> BELIEVE IT!
18:47:09 <sshine> Enzoray, you did what?
18:47:22 <Enzoray> My answer was right.
18:47:29 <Enzoray> I wrote the right answer.
18:47:48 <EvanR> > let xs = [1,2,2,3] in (nub xs) == (nub xs) -- check that nub removes all the duplicates ;)
18:47:49 <lambdabot>  True
18:48:04 <sshine> haha
18:48:20 <Enzoray> Jeeeesus christ of programming jesus.
18:48:24 <sshine> Enzoray, you can't use nub to test itself.
18:49:11 <sshine> Enzoray, how would you check if there exists a duplicate without using nub, and without re-implementing nub and testing it with that?
18:49:59 <Iceland_jack> sshine: Does it have to be efficient? You can sort the list and compare neighboring elements
18:49:59 * hackagebot text-show 0.5 - Efficient conversion of values into Text  http://hackage.haskell.org/package/text-show-0.5 (ryanglscott)
18:50:00 <EvanR> you could write a function that tells if there is at least one duplicate
18:50:15 <sshine> Iceland_jack, I was hinting at that, but go ahead and give the answer away. :P
18:50:22 <Enzoray> sshine, idk..
18:50:37 <Enzoray> I don't know how to write a function which checks for duplicates
18:50:38 <Iceland_jack> Sorry, didn't know this was a pedagogical question
18:50:52 <vanila> Does anyone know what I could read to learn how to take a grammar and analyze it, and produce an LR parser from it?
18:51:02 <vanila> I want to make a parser genrator like this
18:51:29 <sshine> Iceland_jack, does it get more efficient than that? I suppose one could avoid a second re-run by constructing a tree.
18:52:16 <Enzoray> duplicates :: [a] -> [a]
18:52:22 <sshine> vanila, Torben Mogensen's Basics of Compiler Design describes how to construct an "SLR parser". going from there to a full LALR parser or similar could be accomplished by reading an article on that.
18:52:35 <sshine> vanila, the book is available at http://www.diku.dk/~torbenm/Basics/
18:52:38 <Iceland_jack> You can get more efficient, but using 'sort' already uses the Ord constraint which allows you to verify fewer lists than you're able to 'nub'
18:52:52 <Enzoray> duplicates a = a == a
18:53:02 <EvanR> > group . sort $ [1,2,3,2]
18:53:03 <lambdabot>  [[1],[2,2],[3]]
18:53:16 <Enzoray> change return [a] to Bool
18:53:36 <Iceland_jack> since 'nub :: Eq a => [a] -> [a]' while 'sort :: Ord a => [a] -> [a]'
18:53:45 <Enzoray> EvanR, are you saying that if it's sorted that a list is bigger than 1..
18:54:01 <Iceland_jack> The interesting solution is writing the duplicate checker using only an Eq constraint
18:54:04 <EvanR> what
18:54:10 <sshine> vanila, there's an example with drawn graphs of how to do it by hand. I want to make a parser generator, too.
18:54:20 <sshine> Iceland_jack, linear sorting? :P
18:54:52 <Enzoray> I need to create a function which sorts, if there are two elements in ONE LIST.. I can tell if it's true/false.
18:55:04 <Iceland_jack> sshine: Those also add unnecessary constraints to the data type
18:55:05 <vanila> thanks sshine :) If you do it i would be interested in looking at the code
18:55:19 <sshine> Iceland_jack, I thought linear-time sorting only adds Eq.
18:55:37 <sshine> vanila, I'd write this code in ML.
18:55:43 <vanila> great!
18:55:53 <EvanR> it would be interesting to make the duplicate checker but doesnt even required the Eq constraint ;)
18:56:23 <Enzoray> Could someone explain this code for me?
18:56:32 <Enzoray> split :: String -> (String,String)
18:56:33 <Enzoray> split a = (takeWhile (/='/') a, tail (dropWhile (/='/') a))
18:56:45 <Iceland_jack> You can do it without sorting but it would look quite similar to the actual 'nub' implementation
18:56:57 <int-e> @type (/= '/')
18:56:58 <lambdabot> Char -> Bool
18:57:13 <Enzoray> given "haskell/tricky" it would return ("haskell","tricky") - How does it do it?
18:57:35 <sshine> Iceland_jack, I'm thinking of a O(n) way with the Eq constraint only.
18:57:46 <Iceland_jack> Enzoray: Do you understand:
18:57:47 <Iceland_jack> > takeWhile (/= '/') "haskell/tricky"
18:57:48 <lambdabot>  "haskell"
18:58:01 <int-e> Enzoray: (/='/') is a function that checks whether its argment is not equal to '/'.
18:58:05 <Enzoray> No, not really. How does it know what to take?
18:58:20 <Enzoray> Yeah, but. Then why not take both? "haskelltricky"
18:58:21 <Iceland_jack> Enzoray: (/= '/') is a function that only returns True for '/'
18:58:25 <int-e> > takeWhile odd [1,3,4,5,2,1]
18:58:27 <lambdabot>  [1,3]
18:58:31 <Iceland_jack> Because it stps searching after the first match Enzoray
18:58:34 <Iceland_jack> *it stops
18:58:37 <Enzoray> Oh, cool!
18:58:44 <Iceland_jack> Hence the name "takeWhile(andThenStopTaking)"
18:58:45 <Enzoray> So...
18:58:46 <Iceland_jack> :-)
18:58:53 <Enzoray> Drop basically LEAVES the rest?
18:58:56 <int-e> > dropWhile odd [1,3,4,5,2,1]
18:58:58 <lambdabot>  [4,5,2,1]
18:59:02 <Iceland_jack> > takeWhile "just.a.quick.test"
18:59:02 <int-e> > span odd [1,3,4,5,2,1]
18:59:03 <lambdabot>  mueval-core: L.hs: openBinaryFile: does not exist (No such file or directory)
18:59:03 <lambdabot>  ([1,3],[4,5,2,1])
18:59:06 <pavonio> > filter (/= '/') "haskell/tricky"
18:59:08 <lambdabot>  "haskelltricky"
18:59:11 <Iceland_jack> > takeWhile (/== '.') "just.a.quick.test"
18:59:12 <lambdabot>  Not in scope: ‘/==’
18:59:13 <lambdabot>  Perhaps you meant one of these:
18:59:13 <lambdabot>    ‘/=’ (imported from Data.Eq), ‘==’ (imported from Data.Eq),
18:59:17 <Iceland_jack> Sigh :)
18:59:18 <Iceland_jack> > takeWhile (/= '.') "just.a.quick.test"
18:59:20 <lambdabot>  "just"
18:59:26 <Enzoray> Thanks Iceboi.
18:59:27 <Iceland_jack> > dropWhile (/= '.') "just.a.quick.test"
18:59:29 <lambdabot>  ".a.quick.test"
18:59:42 <Enzoray> Now for the quickcheck property.
18:59:42 <Iceland_jack> Hope the noise didn't distract from the meaning
18:59:55 <Enzoray> It did. But I solved it.. with your help.
19:00:09 <Enzoray> prop_Nub_NoDuplicates :: [Int] -> Bool
19:00:09 <Enzoray> prop_Nub_NoDuplicates xs =
19:00:09 <Enzoray> nodups (nub xs)
19:00:09 <Enzoray> where
19:00:09 <Enzoray> nodups (x:xs) = x `notElem` xs && nodups xs
19:00:09 <int-e> > let split a = (takeWhile (/='/') a, tail (dropWhile (/='/') a)) in split "abc" -- hmm
19:00:09 <Enzoray> nodups _ = True
19:00:11 <lambdabot>  ("abc","*Exception: Prelude.tail: empty list
19:00:33 <EvanR> nodups :: Set a -> Bool
19:00:39 <EvanR> nodups _ = True
19:00:42 <int-e> EvanR: hah
19:01:19 <Iceland_jack> That looks remarkably similar to my function:
19:01:19 <Iceland_jack>     isSet :: Set a -> Bool
19:01:19 <Iceland_jack>     isSet = const True
19:01:28 <Iceland_jack> I'm contemplating legal action
19:02:02 <Enzoray> :D
19:05:06 <greymalkin> It appears `cabal install ./package/` has stopped working. is there another way to install a project-in-a-directory into a sandbox?
19:05:29 <vanila> haha
19:05:55 <AshyIsMe> greymalkin: i think it's cabal add-source
19:06:36 <AshyIsMe> cabal sandbox add-source actually
19:07:48 <Enzoray> I'm looking at old exams, the older ones are much harder it seems
19:08:21 <Enzoray> They look more complex, should I be worried? :P
19:08:45 <Iceland_jack> Don't Panic.
19:09:06 <Iceland_jack> You can post questions you find difficult on #haskell and someone is sure to help you
19:09:17 <EvanR> whatever you do, DONT PANIC!!!!
19:09:44 <Enzoray> How can I not panic? They all seem to be beyond my knowledge of haskell.
19:10:06 <EvanR> step 1, read the entire question
19:10:22 <EvanR> step 2, think very hard
19:10:27 <EvanR> step 3, write down the answer
19:11:05 <Enzoray> Oh, yeah. You're right on the first step. Some of the things actually stood in the question.
19:11:13 <Enzoray> Not that hard anymore... ^^
19:11:21 <greymalkin> AshyIsMe: That is *exactly* what I was looking for thanks!
19:11:22 <arrdem> sadly, we are not all Feynman
19:11:42 <EvanR> well if you were feynman the first thing is to understand the problem
19:11:48 <Enzoray> arrdem, I don't know what you mean.. But I agree!
19:12:20 <arrdem> Enzoray: the above three step "solution" is better known as the Feynman Algorithm. it's from some interview of his.
19:12:36 <Enzoray> I figured it was something like that.
19:12:51 <Iceland_jack> Knowing whether or not you're Feynman is an undecidable problem in general.
19:13:13 <Enzoray> I'm probably not Feynman.. it seems. :P
19:13:25 <EvanR> it was coined by murray gell-mann who was describing feynman
19:14:24 <EvanR> :t scanWhile
19:14:25 <lambdabot> Not in scope: ‘scanWhile’
19:15:12 <EvanR> :t span
19:15:13 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
19:15:25 <Iceland_jack> :t \f e pred -> scanr f e . takeWhile pred
19:15:26 <lambdabot> (a -> b -> b) -> b -> (a -> Bool) -> [a] -> [b]
19:15:41 <Enzoray> I've never heard about someone called Feynman in my entire life I think. Either I'm not that into.. interviews.. or you're a bit older than me. :P
19:15:50 <EvanR> hahaha
19:16:07 <EvanR> my hobby is interviews, sorry
19:16:21 <Welkin> you have never heard of Richard Feynman?
19:16:29 <Welkin> what a travesty
19:16:41 <int-e> Welkin: well we remedied that ;-)
19:16:48 <Welkin> he is one of the best science educators (and scientists) in human history
19:16:50 <Enzoray> No, sounds like an elf who crafts his own wings to fly with.
19:16:51 <vanila> Richard Feynman is cool!
19:16:56 <vanila> check his physics lectures out
19:16:56 <EvanR> i was in high school when someone gave me surely youre joking mr feynman
19:17:08 <Enzoray> I agree, an elf who crafts his own wings to fly with is pretty cool.
19:17:25 <Welkin> he worked on the manhattan project
19:17:33 <Welkin> and he played pranks on everyone
19:17:57 <EvanR> hopefully Enzoray is currently studying for high school, because that means they are teaching haskell in high school ;)
19:18:16 <Welkin> my high school only had one programming class, and it was in visual basic
19:18:18 <Welkin> I never took it
19:18:20 <Enzoray> EvanR, if only you could imagine.. :')
19:18:25 <Enzoray> Wait a minute.
19:18:33 <Enzoray> I'm not in high school.. duh.. now I feel old.
19:18:38 <Welkin> the only programming I did in high school was mirc scripting and rpgmaker scripting
19:18:45 <EvanR> haha
19:18:52 <EvanR> i had Dark Basic (tm)
19:19:11 <Enzoray> Great.. one day you're teaching VB.. and another you're talking about Feynman
19:21:06 <Enzoray> :r
19:21:31 <int-e> Enzoray: couldn't match type IRCWindow with GHCISession
19:21:47 <Enzoray> :P
19:21:48 <Welkin> perhaps it was a variant of :P
19:22:07 <Iceland_jack> Enzoray: unknown command ':P'
19:22:21 <Enzoray> This is why I hate haskell, it never works.. :S
19:22:41 <Enzoray> It actually is pretty nice when it does work, but it never does.
19:23:04 <EvanR> if you can only get it to compile, the program is perfect!
19:23:20 <EvanR> (not really)
19:23:22 <Enzoray> I think I've done something stupid now.. Want to see what's wrong? :P
19:24:29 <EvanR> you can use lpaste to let people see what code you see
19:24:40 <Enzoray> Why not just copy-paste?
19:24:45 <Enzoray> I mean, it's not that long.
19:24:48 <Welkin> @lpaste
19:24:48 <lambdabot> Haskell pastebin: http://lpaste.net/
19:24:50 <Enzoray> Atleast not what I'm doing.
19:25:03 <Welkin> because lpaste lets you annotate and make revisions
19:25:19 <Welkin> if it is more than 2 lines, use lpaste
19:25:48 <Enzoray> two lines? Everything is longer than two lines. :P
19:25:56 <Welkin> not in haskell
19:26:05 <Welkin> a lot of times my functions are one line
19:26:11 <Iceland_jack> Enzoray:
19:26:13 <Iceland_jack> @src sum
19:26:13 <lambdabot> sum = foldl (+) 0
19:26:21 <Iceland_jack> @src product
19:26:21 <lambdabot> product = foldl (*) 1
19:26:27 <Enzoray> But you have to define them aswell etc.
19:26:51 <Enzoray> Private/public @ iPaste+
19:27:32 <EvanR> lpaste is better for haskell than a lot of paste sites
19:27:51 <Enzoray> http://lpaste.net/117605
19:29:04 <int-e> Enzoray: line 16 is indeneted too far
19:29:07 <Iceland_jack> Enzoray: Do you want the solution?
19:29:15 <Enzoray> I want to know what's the problem
19:29:17 <int-e> (it should not be indented at all)
19:29:21 <Enzoray> I already have the solution. :P
19:29:24 <EvanR> what did the compiler say
19:29:58 <Iceland_jack> Enzoray: Do you mean 'totalPrice a = sum a'?
19:30:13 <Enzoray> parse error on input type, then too few arguments.
19:30:25 <Enzoray> Iceland, yes.
19:30:28 <Iceland_jack> Enzoray: Don't indent 'type Item = String'
19:30:34 <Enzoray> I removed it.
19:30:38 <Iceland_jack> That definition shouldn't type check
19:31:26 <int-e> Enzoray: but if you remove it, the compiler won't know what `Item' refers to.
19:31:42 <Iceland_jack> Enzoray: You need to keep the line 'type Item = String', and not add any spaces in front of it
19:31:45 <Enzoray> int-e: The excess space that being.
19:31:56 <EvanR> sum a is a number, the result of totalPrice x should be a function
19:31:56 <Iceland_jack> and then you need to look at your totalPrice function, which takes two arguments
19:32:04 <int-e> Enzoray: oh.
19:32:50 <Iceland_jack> Enzoray: If you write:
19:32:50 <Iceland_jack>     totalPrice (Item -> Int) -> [Item] -> Int
19:32:50 <Iceland_jack>     totalPrice priceFunction items = ...
19:32:50 <Iceland_jack> then 'priceFunction :: Item -> Int' and 'items :: [Item]'
19:33:10 <Iceland_jack> You will need to map the 'priceFunction' over the items before summing
19:33:48 <Enzoray> totalPrice priceOf items = sum $ map priceOf items
19:34:23 <Iceland_jack> Yup that's it
19:34:40 <Iceland_jack> ghci> totalPrice priceOf ["milk", "butter"]
19:34:40 <Iceland_jack> 28
19:34:45 <Enzoray> That's not my solution and I didn't quite understand it.
19:34:55 <Iceland_jack> Enzoray: Okay, let's take it step by step
19:35:13 <Iceland_jack> another way to write that solution is:
19:35:14 <Iceland_jack>     totalPrice priceOf items = sum [ priceOf item | item <- items ]
19:36:03 <Enzoray> Could you make it more simple? :P
19:36:05 <Iceland_jack> If 'items = ["milk", "butter"]' then:
19:36:05 <Iceland_jack>     [ priceOf item | item <- items ]
19:36:05 <Iceland_jack>     [ priceOf item | item <- ["milk", "butter"] ]
19:36:05 <Iceland_jack>     [ priceOf "milk", priceOf "butter" ]
19:36:08 <Iceland_jack>     [ 10, 28 ]
19:36:55 <Enzoray> I understand.
19:36:56 <Iceland_jack> Does that make sense Enzoray? You have a list of strings (Items):
19:36:56 <Iceland_jack>     ["milk", "butter"]
19:36:56 <Iceland_jack> and you want to apply the function 'priceOf' to every single string (Item):
19:36:56 <Iceland_jack>     [priceOf "milk", priceOf "butter"]
19:37:11 <Enzoray> It does, it's just that I would never be able to remember that.
19:37:19 <Iceland_jack> That's the same as writing 'map priceOf items':
19:37:19 <Iceland_jack>     [ priceOf item | item <- items ]
19:37:19 <Iceland_jack>     ==
19:37:22 <Iceland_jack>     map priceOf items
19:37:49 <Iceland_jack> Enzoray: Don't worry about that at all, first you understand a concept: then you eventually become familiar enough with it that you can use it
19:38:09 <carter> Iceland_jack: i did it1
19:38:13 <carter> mwahahah
19:38:14 <Iceland_jack> Enzoray: Every time you have a list and you want to do the same thing to every element, use a map
19:38:21 <Iceland_jack> What did you do carter?
19:38:28 <carter> Iceland_jack: one of the more boring possible things
19:38:48 <carter> theres now a storable complex pkg on ahckage that works with ghc >= 7.10
19:38:53 <carter> its empty in that case
19:39:04 <carter> and otherwise, it provides a 7.10 style storable instance for Complex a
19:39:16 <carter> for ghc 7.2-7.8
19:39:23 <carter> not possible for older ghc
19:39:24 <Iceland_jack> Ah great! I saw your patches for Complex, I've needed it in the past
19:39:39 <carter> Iceland_jack: what patches where?
19:39:40 <Iceland_jack> 7.2 should be perfectly fine
19:39:45 <Iceland_jack> on Phabricator
19:39:49 <carter> ohh yeah those
19:39:58 <carter> this is for the orphan package everyone standardized on before
19:40:03 * hackagebot storable-complex 0.2.2 - Storable instance for Complex  http://hackage.haskell.org/package/storable-complex-0.2.2 (CarterSchonwald)
19:40:21 <Iceland_jack> Nice :)
19:40:33 <carter> he
19:40:35 <Enzoray> What does '$' do in Haskell?
19:40:41 <int-e> @src ($)
19:40:42 <lambdabot> f $ x = f x
19:40:45 <carter> Iceland_jack: https://travis-ci.org/
19:40:50 <carter> lhttps://travis-ci.org/cartazio/storable-complex
19:40:50 <Iceland_jack> Enzoray: You can think of it as a way of avoiding parentheses for now
19:40:53 <carter> look, ALL GREEEEN
19:41:06 <Enzoray> int-e. I can't comprehend that.
19:41:06 <Iceland_jack> Enzoray:
19:41:06 <Iceland_jack>     totalPrice priceOf items = sum $ map priceOf items
19:41:06 <Iceland_jack>     ==
19:41:06 <Iceland_jack>     totalPrice priceOf items = sum (map priceOf items)
19:41:10 * StoneCypher rather does like travis
19:41:35 <carter> StoneCypher: honestly, travis CI has made OSS a richer more robust place
19:41:36 <Enzoray> This might sound pretty sick. But I hate not using parentheses.
19:41:43 <Iceland_jack> Enzoray: Focus on what I wrote, it just avoids a single pair of parentheses
19:41:46 <Enzoray> I mean, it's dreadful without it.
19:41:59 <Iceland_jack> That's perfectly fine Enzoray, I prefer to use them most of the time as well
19:41:59 <StoneCypher> carter: generally agreed.  i just wish there was a personal price version
19:42:18 <int-e> Enzoray: $ is just an infix operator, and f $ x  evaluates to  f x. However, it has a very low precedence, so while f x + 1 parses as (f x) + 1, f $ x + 1 will parse as f $ (x + 1). So it can be used to avoid many parentheses.
19:42:26 <carter> StoneCypher: theres some alternatives which palateable pricing i guess
19:42:32 <Enzoray> Why even bother using $? I can't read it without parentheses... :P
19:42:41 <carter> StoneCypher: per se, their whoel stack is open source
19:42:50 <Enzoray> int-e, I see. But what's the point of using it when there is only ONE to be used.
19:43:13 <Iceland_jack> Enzoray: Because it allows you to write:
19:43:13 <Iceland_jack>     f (x (y (a b (u v))))
19:43:13 <Iceland_jack> as
19:43:13 <Iceland_jack>     f $ x $ y $ a b $ u v
19:43:22 <Iceland_jack> It just depends on style Enzoray
19:43:29 <carter> https://github.com/travis-ci/travis-ci
19:43:41 <int-e> Enzoray: the point is that things like return (f (g (h x)))  tend to become incomprehensible. With $ one can group them:  return $ f (g (h x)), say, or return $ f . g . h $ x  (where f . g . h is the function composition).
19:43:44 <Enzoray> Should you really apply style when you're trying to learn the basics?
19:43:59 <oleo> as early as possible
19:44:01 <carter> StoneCypher: so in theory, someone could eg dockerize it or something
19:44:01 <int-e> Enzoray: you don't have to use $ if you don't like it.
19:44:05 <oleo> idiomatic
19:44:09 <Iceland_jack> I avoid ($) when teaching
19:44:12 <Enzoray> int-e, the proctors use it.
19:44:20 <int-e> Enzoray: but if you read other people's code then it's good to know what it means
19:44:40 <Iceland_jack> But then again I don't like how ubiquitous it is in Haskell, makes it look like Perl
19:44:52 <int-e> Enzoray: and you may grow to like it over time.
19:44:56 <Enzoray> Yeah, my thanks to you guys.
19:45:05 <Enzoray> int-e, I don't think so.. :P
19:45:52 <Enzoray> totalPrice priceOf items = sum ( map priceOf items)
19:45:57 <Enzoray> So, that looks a lot better.
19:46:11 <Iceland_jack> Enzoray: It's especially nice with something like
19:46:11 <Iceland_jack>     print $ 1 + 2 * 20
19:46:11 <Iceland_jack>     print $ "quick" ++ " " ++ "test"
19:46:11 <Iceland_jack>     print $ not True && not (not False)
19:46:19 <Enzoray> Okay, why are there so many arguments now?
19:46:19 <int-e> (Some things are simply ugly without it. One can write fairly intuitve loops with  forM [1..3] $ \x -> do ....   but there's no good place for the closing parenthesis that is required without the $)
19:46:29 <Iceland_jack> It creates a sort of "visual box" around them
19:46:57 <Iceland_jack> Enzoray: So many arguments to "totalPrice"?
19:47:02 <Enzoray> Iceland, I get what you're saying when there are MULTIPLE parenteses around.
19:47:18 <Enzoray> But this one. I mean, this proctor is just trying to brag or something.
19:47:50 <Iceland_jack> int-e's argument is really the best one, when you have a lot of code:
19:47:51 <Iceland_jack>     forM_ [1..10] $ \element -> do
19:47:51 <Iceland_jack>       print element
19:47:51 <Iceland_jack>       print element
19:47:54 <Iceland_jack> rather than:
19:47:57 <Iceland_jack>     forM_ [1..10] (\element -> do
19:48:00 <Iceland_jack>       print element
19:48:01 <int-e> Enzoray: I wouldn't think so. I expect it was used out of habit, without thinking about the fact that this may confuse students.
19:48:03 <Iceland_jack>       print element)
19:48:21 <Enzoray> int-e I guess so.
19:48:43 <Enzoray> How do I read definitions?
19:49:03 <Iceland_jack> You mean any function definition?
19:49:04 <Enzoray> A list of standard-haskell functions are included.
19:49:27 <Enzoray> Yeah.
19:49:29 <Enzoray> I mean, like map
19:49:30 <Enzoray> etc.
19:49:39 <Iceland_jack> Enzoray: You read them top-to-bottom
19:49:52 <Iceland_jack> as equations chosen if their patterns apply
19:50:11 <Iceland_jack>     map f []     = []
19:50:11 <Iceland_jack>     map f (x:xs) = (f x) : (map f xs)
19:50:42 <Iceland_jack> If a list is empty (map plusFive []), then the first equation is chosen ([])
19:50:42 <Enzoray> map :: (a -> b) -> [a] -> [b]
19:50:42 <Enzoray> map f xs = [ f x | x <- xs ]
19:50:46 <Enzoray> That's the map I have.
19:50:58 <Enzoray> I can't read it.
19:51:00 <Iceland_jack> Sure, that map is kind of cheating Enzoray
19:51:14 <Iceland_jack> Since it's implemented in terms of a list comprehension which is built into Haskell
19:51:19 <int-e> Enzoray: does "list comprehension" mean anything to you?
19:51:32 <Enzoray> int-e. It does ring a bell.. :P
19:51:40 <Iceland_jack> Enzoray: Remember what I told you earlier?
19:51:45 <Iceland_jack> <Iceland_jack> That's the same as writing 'map priceOf items':
19:51:45 <Iceland_jack> <Iceland_jack>     [ priceOf item | item <- items ]
19:51:45 <Iceland_jack> <Iceland_jack>     ==
19:51:45 <Iceland_jack> <Iceland_jack>     map priceOf items
19:51:46 <Enzoray> Hey, I don't make the rules.. :P
19:51:51 <Iceland_jack>  
19:51:57 <Enzoray> Yeah, I do. It looked similar.
19:51:59 <Iceland_jack> That was a list comprehension
19:52:07 <Iceland_jack> exactly the same as [ f x | x <- xs ]
19:52:22 <Iceland_jack> Only the list 'items' had a different name ('xs')
19:52:35 <int-e> Enzoray: I'd read it as "the list comprised of  f x  for  x from xs."
19:52:36 <Iceland_jack> and the function 'priceOf' had a different name ('f')
19:52:49 <Iceland_jack> > [ 15 + a | a <- [1..10] ]      -- Enzoray
19:52:50 <lambdabot>  [16,17,18,19,20,21,22,23,24,25]
19:52:58 <Iceland_jack> See if that makes sense to you
19:53:41 <Iceland_jack> We have a list [1..10] of numbers from 1 to 10 ([1,2,3,4,5,6,7,8,9,10])
19:53:42 <Enzoray> I mean the syntax, [ random stuff | absorbing <- [1..3]]
19:53:57 <Enzoray> in a?
19:54:07 <Iceland_jack> Enzoray: That's just the syntax of the list comprehension, "absorbing" is the name of the element you pick/draw from the list [1..3]
19:54:17 <Iceland_jack> > [ (a, a) | a <- [1..10] ]
19:54:18 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
19:54:23 <Iceland_jack> Look at that example ^
19:54:36 <Iceland_jack> > [ (a, a, a) | a <- [1..10] ]
19:54:38 <lambdabot>  [(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5),(6,6,6),(7,7,7),(8,8,8),(9,9,9),(10...
19:54:44 <Iceland_jack> > [ (a, True, a) | a <- [1..10] ]
19:54:45 <lambdabot>  [(1,True,1),(2,True,2),(3,True,3),(4,True,4),(5,True,5),(6,True,6),(7,True,7...
19:54:46 <Enzoray> Okay, I see.
19:54:48 <Enzoray> a = list
19:54:58 <Enzoray> Or, the element in the list.
19:55:02 <Iceland_jack> Yes
19:55:19 <Enzoray> | means..?
19:55:30 <Iceland_jack> Enzoray: It doesn't "mean" anything, it's just a part of the syntax
19:55:37 <int-e> read it as "for" or "such that"
19:55:41 <Iceland_jack> Enzoray: So if you want to multiply each element by 2, then add 1:
19:55:41 <Iceland_jack> > [ 2 * x + 1 | x <- [1..5] ]
19:55:42 <lambdabot>  [3,5,7,9,11]
19:56:12 <Enzoray> I understand now.
19:56:17 <Enzoray> using , in haskell means?
19:56:19 <Enzoray> ex.
19:56:41 <Iceland_jack> Enzoray: In Python it would be:
19:56:41 <Iceland_jack> In [1]: [ 2 * x + 1 for x in range(1, 6) ]
19:56:41 <Iceland_jack> Out[1]: [3, 5, 7, 9, 11]
19:56:45 <Enzoray> list a = sum a, reverse a
19:56:48 <EvanR> > (,) 'a' 0
19:56:49 <lambdabot>  ('a',0)
19:56:57 <dfeuer> ''''''''''''''''''@tell edwardk I'm wondering if restricting the signature to MonadFix would let the tree of monadic actions be fed back in in a useful fashion. Don't really know.
19:56:59 <Iceland_jack> Enzoray: The first is not valid, the second is a tuple
19:57:05 <dfeuer> @tell edwardk I'm wondering if restricting the signature to MonadFix would let the tree of monadic actions be fed back in in a useful fashion. Don't really know.
19:57:05 <lambdabot> Consider it noted.
19:57:13 <dfeuer> Wow, that was some keyboard fail.
19:57:26 <Enzoray> So. It's for tupels?
19:57:32 <Iceland_jack> Yes
19:57:34 <Iceland_jack> :t (,)
19:57:35 <lambdabot> a -> b -> (a, b)
19:57:36 <Enzoray> I had an exercise about this.
19:57:43 <Enzoray> (String, String) was the result.
19:57:43 <Welkin> list comprehensions are not idiomatic
19:57:44 <Iceland_jack> (,) is a function that takes two things, returns a tuple containing them
19:57:47 <EvanR> :t (,,)
19:57:48 <lambdabot> a -> b -> c -> (a, b, c)
19:57:57 <Enzoray> I didn't understand what "," was for at the time.
19:58:00 <Enzoray> I know now.
19:58:26 <Enzoray> So, if I want to write a function for tupels, that's how I do=
19:58:27 <Enzoray> ?
19:58:27 <Iceland_jack> List comprehensions are idiomatic for certain classes of problems and in certain Haskell circles
19:58:37 <EvanR> > [ x + y | x <- [1,2,3], y <- [4, 5, 6] ]
19:58:39 <lambdabot>  [5,6,7,6,7,8,7,8,9]
19:58:46 <EvanR> thats another use of ,
19:59:00 <Iceland_jack>     foo x | a, b = y
19:59:01 <Iceland_jack> and that :)
19:59:10 <Enzoray> Is this valid?
19:59:14 <Iceland_jack> Yes
19:59:21 <Enzoray> I was going to write an example.
19:59:22 <Enzoray> :P
19:59:35 <EvanR> wait what
19:59:40 <EvanR> what does a, b mean there
19:59:52 <int-e> EvanR: it's a conjunction of two guards
20:00:05 <EvanR> instead of && ?
20:00:15 <Iceland_jack> Yes, but it also allows patterns EvanR
20:00:17 <Enzoray> lelman a b = sum a,b
20:00:41 <Enzoray> if a and b were lists, would it print; 123,456?
20:00:41 <Iceland_jack>     foo x
20:00:41 <Iceland_jack>       | [a, b] <- x
20:00:41 <Iceland_jack>       , a == b
20:00:41 <Iceland_jack>       = ...
20:01:00 <Iceland_jack> Enzoray: no, that is invalid syntax
20:01:06 <Enzoray> Why? :P
20:01:14 <int-e> Iceland_jack: sure, just lay it on...
20:01:23 <Enzoray> Or, I mean. Could you correct it? :P
20:01:29 <Iceland_jack> int-e: Hm? Was I maybe being too harsh
20:01:30 <int-e> Iceland_jack: you really didn't have to use pattern guards there...
20:02:28 <Iceland_jack> Ah right, they aren't needed for topic at hand
20:03:02 <Enzoray> Anyway, disregard the syntax thing.
20:03:04 <Iceland_jack> I mentioned them as an offhand remark but then someone asked more about them
20:03:17 <Enzoray> What common functions should I be aware of?
20:03:24 <Enzoray> I mean, apparently map was very important.
20:03:30 <Iceland_jack> Enzoray: 'filter'
20:03:37 <int-e> > let foo [a,b,c] | a == b, b == c = "List with three equal elements"; foo _ = "Something else" in map foo ["aaa", "abc", "xxxx"]
20:03:38 <lambdabot>  ["List with three equal elements","Something else","Something else"]
20:04:00 <Enzoray> Could you also demonstrate how to use them? :P
20:04:07 <Iceland_jack> Enzoray:
20:04:08 <Iceland_jack> > filter even [1,2,3,4,5,6]
20:04:08 <Enzoray> In a simple version ofc.
20:04:10 <lambdabot>  [2,4,6]
20:04:29 <Enzoray> filter f xs?
20:04:31 <Iceland_jack> Yes
20:04:32 <Iceland_jack> > filter (== 's') "Mississippi"
20:04:34 <lambdabot>  "ssss"
20:04:37 <Iceland_jack> > length (filter (== 's') "Mississippi")
20:04:38 <lambdabot>  4
20:04:46 <Iceland_jack> Enzoray: There are 4 s-es in Mississippi.
20:04:50 <Iceland_jack> That's one use
20:04:52 <Enzoray> Can't i filter single elements? :P
20:05:01 <Iceland_jack> What do you mean?
20:05:21 <Enzoray> filter (random) "lol" = lo
20:05:26 <Iceland_jack> No
20:05:28 <Enzoray> removing all duplicates.
20:05:34 <Iceland_jack> That's a different function, "nub"
20:05:36 <Iceland_jack> > nub "lol"
20:05:37 <lambdabot>  "lo"
20:05:46 <Enzoray> So that's important aswell.
20:05:55 <Iceland_jack> Not as important as filter
20:06:21 <Iceland_jack> 'map, filter and foldr' are important (foldr is the most important, but map/filter are probably simpler)
20:06:33 <mikeplus64> nub is more of a thing you might be asked to write in an exam
20:06:41 <Iceland_jack> What mikeplus64 said
20:07:03 <Enzoray> Iceland, think of this.. as an exam-ish.. haskell..thing.
20:07:13 <Welkin> the best way to learn about these functions is to read their definitions in the source
20:07:28 <Welkin> it all comes down to simple recursive functions
20:07:32 <int-e> Hmm. :browse Prelude   and  :browse Data.List  will provide many hours of reading pleasure ;-)
20:07:38 <Enzoray> About recursive..
20:07:40 <Welkin> foldr is really just recursion
20:07:45 <Welkin> there is nothing magic
20:07:49 <Iceland_jack> Except when the source is convoluted as it is in base...
20:07:50 <Enzoray> I can't really fully grasp recursion yet.
20:07:54 <Welkin> but the recursion is hidden away
20:08:02 <Enzoray> Mind writing something simple in recursion? :P
20:08:08 <Iceland_jack> Enzoray: Yup!
20:08:24 <Iceland_jack>     len :: [a] -> Int
20:08:24 <Iceland_jack>     len []     = 0
20:08:24 <Iceland_jack>     len (_:xs) = 1 + len xs
20:08:28 <Welkin> @src foldr
20:08:28 <lambdabot> foldr f z []     = z
20:08:28 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:08:34 <Iceland_jack> Enzoray: A list is either "empty" or "non-empty"
20:08:39 <Enzoray> empty list = 0
20:08:47 <Iceland_jack> "empty" case is [], "non-empty" case is (x:xs)
20:08:47 <mikeplus64> @src nub
20:08:47 <lambdabot> nub = nubBy (==)
20:08:51 <mikeplus64> @src nubBy
20:08:51 <lambdabot> nubBy eq []     = []
20:08:51 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
20:09:09 <Iceland_jack> Enzoray: Do you understand how lists work?
20:09:12 <Enzoray> why would you (_:xs)
20:09:17 <Enzoray> Yeah, I think so.
20:09:19 <Iceland_jack> Because we don't use the head of the list Enzoray
20:09:31 <Enzoray> Why not just leave it as x then?
20:09:40 <Iceland_jack> You can Enzoray, it means the same thing.
20:09:49 <Enzoray> Then why change?.. :P
20:09:51 <Iceland_jack> Using a pattern wildcard (_) makes it explicit tha tyou don't use it
20:09:56 <Enzoray> Oh, ok.
20:10:01 <Iceland_jack>     [1,2,3,4,5]
20:10:01 <Iceland_jack> is really:
20:10:01 <Iceland_jack>     1:(2:(3:(4:(5:[]))))
20:10:01 <Iceland_jack> or:
20:10:04 * hackagebot ethereum-rlp 0.0.1 - Ethereum Recursive Length Prefix Encoding  http://hackage.haskell.org/package/ethereum-rlp-0.0.1 (jamshid)
20:10:04 <Iceland_jack>     1:2:3:4:5:[]
20:10:05 <Enzoray> I mean, it's just so obvious. :P
20:10:06 * hackagebot ethereum-merkle-patricia-db 0.0.1 - A modified Merkle Patricia DB  http://hackage.haskell.org/package/ethereum-merkle-patricia-db-0.0.1 (jamshid)
20:10:13 <Iceland_jack> Enzoray: It stops being obvious in longer examples
20:10:25 <Enzoray> Iceland, I see it as 1 : [2,3,4,5]
20:10:29 <Enzoray> Am I wrong of thinking it like that?
20:10:38 <Iceland_jack> Nope, that's a perfect way of thinking of it for this example
20:10:42 <Welkin> it's the same thing
20:10:48 <latermuse> I see it like this: (:) 1 [2,3,4,5]
20:10:53 <Welkin> [1,2,3] is just syntactic sugar for 1:2:3:[]
20:11:01 <Iceland_jack> Enzoray: That means that:
20:11:01 <Iceland_jack>        len [1,2,3,4,5]
20:11:01 <Iceland_jack>     == 1 + len [2,3,4,5]
20:11:08 <Iceland_jack> Do you understand that fully Enzoray?
20:11:16 <Enzoray> Yes.
20:11:17 <int-e> latermuse: your infix vision must be broken
20:11:30 <Enzoray> Somewhat, I guess someone tried to infuse me with the wrong information before.
20:11:34 <latermuse> > (:) 1 [2,3,4,5]
20:11:36 <lambdabot>  [1,2,3,4,5]
20:11:38 <Iceland_jack> Okay, then:
20:11:39 <Iceland_jack>     == 1 + len [2,3,4,5]
20:11:39 <Iceland_jack>     == 1 + (1 + len [3,4,5])
20:11:48 <latermuse> int-e: not broken, just skewed ;)
20:11:50 <Welkin> int-e: perhaps he rolled a 3 for infix vision
20:12:05 <Enzoray> Lists can contain strings aswell.
20:12:11 <Iceland_jack> Yes Enzoray
20:12:15 <Welkin> lists can contain anything
20:12:15 <Enzoray> leaving +1.. as what?
20:12:15 <Iceland_jack>     == 1 + len [2,3,4,5]
20:12:15 <Iceland_jack>     == 1 + (1 + len [3,4,5])
20:12:16 <Iceland_jack>     == 1 + (1 + (1 + len [4,5]))
20:12:16 <Iceland_jack>     == 1 + (1 + (1 + (1 + len [5])))
20:12:21 <Iceland_jack>     == 1 + (1 + (1 + (1 + (1 + len []))))
20:12:27 <Welkin> a string is a list of characters
20:12:32 <Enzoray> You sure write fast.
20:12:34 <Welkin> String is a synonym for [Char]
20:12:47 <Enzoray> But Char /= Integer
20:12:47 <Iceland_jack> Enzoray: Did every one of those steps make sense?
20:12:52 <latermuse> > (:) 'h' ['e','l','l','o']
20:12:52 <Enzoray> Yes.
20:12:53 <lambdabot>  "hello"
20:12:59 <Iceland_jack> Enzoray: Recall that the type of len is:
20:13:00 <Iceland_jack>     len :: [a] -> Int
20:13:09 <Iceland_jack> so 'a' can be anything:
20:13:09 <Iceland_jack>     len :: [Char] -> Int
20:13:09 <Iceland_jack>     len :: [Int]  -> Int
20:13:10 <Welkin> forall a
20:13:40 <Iceland_jack> Enzoray: Now there is only a single case of 'len' in our expression:
20:13:40 <Iceland_jack>     1 + (1 + (1 + (1 + (1 + len []))))
20:13:47 <Iceland_jack> Can you tell me what the value of 'len []' is Enzoray
20:13:54 <Enzoray> 0.
20:14:07 <Iceland_jack> Okay so:
20:14:07 <Iceland_jack>     1 + (1 + (1 + (1 + (1 + len []))))
20:14:07 <Iceland_jack>     ==
20:14:07 <Iceland_jack>     1 + (1 + (1 + (1 + (1 + 0))))
20:14:17 <Enzoray> == 5
20:14:19 <Iceland_jack> Which is equal to '5'
20:14:33 <Iceland_jack> Yes, that was an example of a simple recursive function: 'len'
20:14:45 <Enzoray> You still write in the speed of light.
20:14:52 <Iceland_jack> Enzoray: :-)
20:15:01 <Enzoray> Have you like copied this before I came? :P
20:15:07 <Welkin> teach him Church numerals next
20:15:23 <Iceland_jack> haha no I haven't, maybe I should though
20:15:29 <Enzoray> Lol, yeah.
20:15:34 <Enzoray> What are you even doing here?
20:15:39 <Iceland_jack> What do you mean?
20:15:59 <Enzoray> Someone with your skill.. could work right now? :P
20:16:06 <Iceland_jack> Oh that's simple, I love Haskell
20:16:12 <wizao> I'm wondering how to write something like: \a b -> [a + b, a - b, a * b, a `div` b] in point free form
20:16:16 <Welkin> life is not about work
20:16:18 <Iceland_jack> and I like explaining it
20:16:19 <wizao> any pointers haha
20:16:26 <Enzoray> Welkin, are you sure?
20:16:27 <Welkin> and haskell is not work
20:16:46 <pavonio> @pl \a b -> [a + b, a - b, a * b, a `div` b]
20:16:46 <lambdabot> ap (ap . ((:) .) . (+)) (ap (ap . ((:) .) . (-)) (ap (ap . ((:) .) . (*)) (flip flip [] . ((:) .) . div)))
20:16:49 <Iceland_jack> wizao:
20:16:50 <Iceland_jack> > [(+), (-)] <*> [a] <*> [b]
20:16:51 <lambdabot>  [a + b,a - b]
20:17:01 <Welkin> wizao: have fun with @pl
20:17:02 <Iceland_jack> It's not point-free but it's quite nice
20:17:03 <wizao> awesomet hanks
20:17:15 <Iceland_jack> > [(+), (-), (*), div] <*> [a] <*> [b]
20:17:15 <wizao> thats what i needed i just couldn't come up with it
20:17:17 <lambdabot>  [a + b,a - b,a * b,a `div` b]
20:17:20 <Enzoray> I think my problem is I always look in the xs in (x:xs), so I tend to forget about the x in life.
20:17:30 <Iceland_jack> Okay well that's about to change Enzoray
20:17:31 <wizao> i need to learn to use lambdabot, any good tuts?
20:17:47 <Iceland_jack> Let's walk through:
20:17:47 <Iceland_jack>     sum :: [Int] -> Int
20:17:47 <Iceland_jack>     sum []     = 0
20:17:47 <Iceland_jack>     sum (x:xs) = x + sum xs
20:18:06 <Iceland_jack> Or see if it makes intuitive sense to you having gone through 'len'.
20:18:09 <Welkin> wizao: there isn't much to know, just use "> " to evaluate expressions and :t (or :k) to look up types (or kinds)
20:18:25 <Enzoray> Iceland, I'm talking about life. It was just a metaphor for you. :P
20:18:40 <Enzoray> I mean, when you brought up work and everything. :D
20:19:00 <Iceland_jack> Metaphors are a distraction from explaining code online :-)
20:19:10 <Enzoray> I see. Continue.
20:19:18 <Iceland_jack> Nah I was kidding
20:20:04 * hackagebot ethereum-client-haskell 0.0.1 - A Haskell version of an Ethereum client  http://hackage.haskell.org/package/ethereum-client-haskell-0.0.1 (jamshid)
20:20:14 <Enzoray> About continuing? Lel. :D
20:20:24 <Welkin> that's right
20:20:35 <Welkin> teach Enzoray about the Cont monad -- the mother of all monads
20:20:47 <Enzoray> We're not done with recursion yet! :P
20:20:53 <Iceland_jack> Enzoray: Or well:
20:20:53 <Iceland_jack>       sum [10,20,30,40]
20:20:53 <Iceland_jack>     = 10 + (sum [20,30,40])
20:20:53 <Iceland_jack>     = 10 + (20 + (sum [30,40]))
20:20:56 <Iceland_jack>     = 10 + (20 + (30 + (sum [40])))
20:20:59 <Iceland_jack>     = 10 + (20 + (30 + (40 + (sum []))))
20:21:12 <Iceland_jack> and finally given the base case 'sum [] = 0':
20:21:12 <Enzoray> Oh, I see how you did there.
20:21:12 <Iceland_jack>     = 10 + (20 + (30 + (40 + 0)))
20:21:16 <Enzoray> That was cool!
20:21:52 <Iceland_jack> Enzoray: You can think of 'sum' as replacing every (:) in the list with a (+)
20:21:54 <Iceland_jack> and [] with a 0
20:22:03 <int-e> Welkin: you mean like  http://lpaste.net/117608  which "proves" the point by implementing a free monad in terms of (essentially) Cont?
20:22:32 <Iceland_jack> Enzoray:
20:22:33 <Iceland_jack>     sum [10, 20, 30, 40]
20:22:33 <Iceland_jack>     =
20:22:33 <Iceland_jack>     sum (10 : 20 : 30 : 40 : [])
20:22:36 <Iceland_jack>     =
20:22:39 <Iceland_jack>          10 + 20 + 30 + 40 + 0
20:22:45 <Enzoray> Iceland, would you like to see an exam question regarding recursion?
20:22:50 <Iceland_jack> That's pretty cool I think :)
20:22:52 <Iceland_jack> sure
20:23:27 <int-e> > sum [a,b,42,23,c]
20:23:28 <lambdabot>  0 + a + b + 42 + 23 + c
20:24:03 <int-e> (right, it's a left fold)
20:24:08 <Enzoray> 1. Implement a function
20:24:08 <Enzoray> occurs :: Eq a => a -> [a] -> Int
20:24:08 <Enzoray> that given an x and a list xs, finds out how often x occurs in the list.
20:24:08 <Enzoray> Examples:
20:24:08 <Enzoray> Main> occurs 'a' "bepacepadepa"
20:24:08 <Enzoray> 3
20:24:08 <Enzoray> Main> occurs 11 [2,3,5,7,11,13,7,5]
20:24:09 <Enzoray> 1
20:24:22 <Enzoray> Oh yeah, ipaste right? :P
20:24:30 <Welkin> @lpaste
20:24:30 <lambdabot> Haskell pastebin: http://lpaste.net/
20:24:34 <Iceland_jack> Enzoray: Sure, for the future
20:24:49 <Iceland_jack> Enzoray: You're probably supposed to implement using direct recursion?
20:24:57 <Enzoray> I have no idea.
20:25:08 <Iceland_jack> You can implement it using 'filter' and 'len'
20:25:09 <Enzoray> occurs a (x:xs)
20:25:11 <Enzoray> Is a good start
20:25:12 <Enzoray> right?
20:25:22 <Iceland_jack> In fact I did implement 'occurs' earlier by accident for you :)
20:25:31 <Iceland_jack> Sure, it's a good start
20:25:34 <Enzoray> I've already forgot about it. :P
20:25:38 <Iceland_jack> Or maybe 'occurs a []' is
20:25:47 <Enzoray> Yeah right, basecase huh?
20:25:48 <Iceland_jack> <Iceland_jack> > length (filter (== 's') "Mississippi")
20:25:48 <Iceland_jack> <lambdabot>  4
20:25:48 <Iceland_jack>  
20:26:11 <Enzoray> occurs a [] = error "no list, no service"
20:26:27 <Iceland_jack> 'length (filter (== x) xs)' return how often x occurs in xs
20:27:01 <Enzoray> So, my work here is done.
20:27:05 <Enzoray> :P
20:27:10 <Iceland_jack> Enzoray: Let's implement the recursive version
20:27:22 <ReMOT3KonTRoL> heeelpp the zombies are coming
20:27:23 <Iceland_jack>     occurs :: Eq a => a -> [a] -> Int
20:27:23 <Iceland_jack>     occurs element []     = 0
20:27:23 <Iceland_jack>     occurs element (x:xs) = ...
20:27:49 <Enzoray> Iceland, why can't you just write my exam? lel :D
20:27:55 <Iceland_jack> Enzoray: We know how often 'element' occurs in the empty list right?
20:27:59 <Iceland_jack> Never. Because it's empty
20:28:06 <Enzoray> Right.
20:28:18 <Iceland_jack> Then we pick up the next element, 'x'
20:28:36 <ReMOT3KonTRoL> i think i broke something
20:28:57 <dhrosa> when did "lol" start being a thing
20:29:03 <Iceland_jack> Enzoray: If it's equal to 'element', then we should add one
20:29:15 <Iceland_jack> Enzoray: If it is not equal to 'element', then we skip it
20:29:22 <ReMOT3KonTRoL> HEY!
20:29:33 <ReMOT3KonTRoL> grr
20:29:33 <dhrosa> err
20:29:36 <Iceland_jack> So it will look like:
20:29:36 <Iceland_jack>     occurs :: Eq a => a -> [a] -> Int
20:29:36 <Iceland_jack>     occurs element []     = 0
20:29:36 <Iceland_jack>     occurs element (x:xs)
20:29:36 <dhrosa> I meant "lel"
20:29:39 <Iceland_jack>       | element == x = ...
20:29:42 <Iceland_jack>       | otherwise    = ...
20:29:43 <ReMOT3KonTRoL> OHAI..
20:30:04 * hackagebot language-ecmascript 0.17 - JavaScript parser and pretty-printer library  http://hackage.haskell.org/package/language-ecmascript-0.17 (AndreyChudnov)
20:30:05 <dhrosa> does haskell have a way of doing occur element (element:xs) in the pattern match?
20:30:10 <Iceland_jack> No dhrosa
20:30:20 <Iceland_jack> Haskell does not have non-linear patterns
20:30:28 <Enzoray> dhrosa, dolan gooby dafty bogs sanikk, does that tell you anything?
20:30:42 <carter> Iceland_jack: except at the type level!
20:30:43 * carter ducks
20:30:54 <Iceland_jack> carter: Hah equality is nicer there :) ....for now!
20:31:21 <Enzoray> | a == x = occurs xs + 1
20:31:23 <Enzoray> right?
20:31:29 <Iceland_jack> Enzoray: Yes
20:31:33 <Enzoray> YES! I DID IT!
20:31:42 * ReMOT3KonTRoL doesnt kR7pTo...this was supposed to be a fun channel
20:32:19 <ReMOT3KonTRoL> !eat 732
20:32:20 <Iceland_jack> Enzoray: You can also use an if expression:
20:32:20 <Iceland_jack>     occurs :: Eq a => a -> [a] -> Int
20:32:20 <Iceland_jack>     occurs element []     = 0
20:32:22 <Enzoray> | otherwise = occurs a xs + 1
20:32:23 <Iceland_jack>     occurs element (x:xs) = if element == x
20:32:26 <Iceland_jack>                             then 1 + occurs element xs
20:32:26 <Iceland_jack>                             else     occurs element xs
20:32:29 <Iceland_jack>  
20:32:41 <Iceland_jack> or oops, Enzoray I was too quick to say yes
20:32:55 <Iceland_jack> When they are equal, you add one:
20:32:56 <Iceland_jack>     | a == x = occurs a xs + 1
20:32:56 <Enzoray> i cri evry tiem. :'(
20:33:06 <Enzoray> Why is the a included?
20:33:10 <Enzoray> I never got that.
20:33:20 <dhrosa> why is the a included where?
20:33:27 <Iceland_jack> Because you always need to pass that to the recursive call Enzoray
20:33:43 <Iceland_jack> Even though it remains constant
20:33:51 <Enzoray> I thought I just wanted to pass the xs, hence a is already typed in.
20:34:54 <Iceland_jack> Enzoray: You *could* factor it out into its own function:
20:34:54 <Iceland_jack>     occurs :: Eq a => a -> [a] -> Int
20:34:54 <Iceland_jack>     occurs element xs = go xs where
20:34:54 <Iceland_jack>       go [] = 0
20:34:57 <Iceland_jack>       go (x:xs) | element == x = go xs + 1
20:35:01 <Iceland_jack>                 | otherwise    = go xs
20:35:05 <Enzoray> noo nothing complicated!
20:35:15 <int-e> go!
20:35:29 <Enzoray> It's too much to remember.. :P
20:35:32 <Iceland_jack> Okay, then for now just pass both arguments
20:35:58 <Enzoray> Okay, if a /= x
20:36:00 <Iceland_jack> When your function is 'occurs a xs' it takes two arguments, so when you call it recursively you must pass it both arguments
20:36:25 <int-e> @type any
20:36:26 <lambdabot> (a -> Bool) -> [a] -> Bool
20:36:43 <Enzoray> Iceland I see.
20:36:47 <Enzoray> But, what now?
20:36:51 <Enzoray> Otherwise being... ?
20:37:00 <Iceland_jack> "otherwise" is when a /= x
20:37:22 <Enzoray> I know.
20:37:31 <Enzoray> Then we want to check xs?
20:37:39 <Iceland_jack> Then we also call it recursively
20:37:43 <Iceland_jack> and don't add 1
20:37:59 <Enzoray> So, just occurs a xs?
20:38:01 <Iceland_jack>     occurs a (x:xs)
20:38:01 <Iceland_jack>       | a == x = occurs a xs + 1
20:38:01 <Iceland_jack>       | a /= x = occurs a xs
20:38:06 <Enzoray> Oh!
20:38:07 <Enzoray> Great!
20:38:10 <Iceland_jack> same as:
20:38:10 <Iceland_jack>     occurs a (x:xs)
20:38:10 <Iceland_jack>       | a == x    = occurs a xs + 1
20:38:10 <Iceland_jack>       | otherwise = occurs a xs
20:38:14 <Enzoray> I understand.
20:38:27 <Iceland_jack> Prefer the latter version though
20:38:49 <Enzoray> I don't know which is the latter version, but I like the one with guards and otherwise etc.
20:39:02 <Iceland_jack> The second version, the one with "otherwise"
20:39:05 <Enzoray> Me too.
20:39:08 <Enzoray> It's so clean.
20:39:17 <Enzoray> 2. Accountants are always interested in finding numbers that contain the digit '7'. Implement a function
20:39:17 <Enzoray> hasSeven :: [Integer] -> [Integer]
20:39:17 <Enzoray> that given a list of numbers, returns exactly those numbers that contain the digit '7'.
20:39:18 <tac_> Is data Fix f = Fix (f (Fix f)) in any well-known library?
20:39:33 <Enzoray> Iceland, mind checking my solution out?
20:39:33 <Iceland_jack> Enzoray: The compiler/GHC can't know that the first one is exhaustive
20:39:38 <Iceland_jack> Enzoray: Not at all
20:39:57 <Enzoray> Iceland, for a second I stopped understanding english.
20:40:04 <Enzoray> The second seem to be longer than I thought.
20:40:05 * hackagebot ethereum-client-haskell 0.0.2 - A Haskell version of an Ethereum client  http://hackage.haskell.org/package/ethereum-client-haskell-0.0.2 (jamshid)
20:40:07 * hackagebot prednote 0.26.0.4 - Evaluate and display trees of predicates  http://hackage.haskell.org/package/prednote-0.26.0.4 (OmariNorman)
20:40:09 * hackagebot prednote-test 0.26.0.4 - Tests and QuickCheck generators to accompany prednote.  http://hackage.haskell.org/package/prednote-test-0.26.0.4 (OmariNorman)
20:40:12 <Iceland_jack> tac_: There is one in data-fix and also in recursion-schemes I think
20:40:37 <Iceland_jack> Enzoray: For that example you need to be able to check if a number contains a character
20:40:39 <Enzoray> So, you don't mind... meaning you would like to see it. I could sense some sarcasm in my head. :P
20:40:59 <Iceland_jack> Enzoray: I'll take a look at the solution
20:41:07 <Enzoray> Okay. There is no solution, yet.
20:41:11 <Enzoray> Any hints?
20:41:14 <Iceland_jack> Sure
20:41:15 <Enzoray> filter?
20:41:16 <Iceland_jack> > "1472"
20:41:17 <lambdabot>  "1472"
20:41:21 <Iceland_jack> > elem '7' "1472"
20:41:22 <lambdabot>  True
20:41:24 <Enzoray> I KNOW!
20:41:28 <Iceland_jack> > show 1472
20:41:30 <lambdabot>  "1472"
20:41:32 <Enzoray> filter (==7) list
20:41:35 <Enzoray> Is this true?
20:41:37 <Iceland_jack> No
20:41:56 <Iceland_jack> You can make it work but you should really use "elem"
20:42:05 <Enzoray> Hint:
20:42:05 <Enzoray> You may use the standard functions show and elem.
20:42:07 <Iceland_jack> 'elem' checks if a list contains an element
20:42:15 <Enzoray> returns true or false
20:42:16 <ahf> 14
20:42:58 <Iceland_jack> Enzoray: Implement the following function 'sevenNumber :: Integer -> Bool'
20:43:06 <Iceland_jack> that checks if a single number contains a 7
20:44:14 <Iceland_jack>       elem '7' (show 1573)
20:44:14 <Iceland_jack>     = elem '7' "1573"
20:44:14 <Iceland_jack>     = True
20:44:18 <Enzoray> Wait!
20:44:19 <Enzoray> before.
20:44:30 <Enzoray> This is what my standardhaskell function list show me.
20:44:35 <Enzoray> elem, notElem :: (Eq a) => a -> [a] -> Bool
20:44:35 <Enzoray> elem x = any (== x)
20:44:35 <Enzoray> notElem x = all (/= x)
20:44:44 <Enzoray> How does this even help me?
20:44:56 <Welkin> any and all are functions
20:45:13 <Iceland_jack> Enzoray: One way to describe 'elem x xs' is "is x an element of the list xs"
20:45:18 <Welkin> any is True is the predicate is True for at least one element in the list
20:45:24 <Iceland_jack> Or another way: "is any element of xs equal to x"
20:45:25 <tac_> > elem 3 [1,2,3]
20:45:27 <lambdabot>  True
20:45:29 <tac_> > elem 5 [1,2,3]
20:45:30 <lambdabot>  False
20:45:40 <Welkin> all is True if and only if the predicate is True for all elements of the list
20:46:04 <Iceland_jack> Enzoray: First try to understand what 'elem' does, then how it's defined
20:46:37 <Enzoray> You just asked me to use something like "elem 7 (in xs)", but elem only takes one argument
20:46:46 <Welkin> :t elem
20:46:46 <Enzoray> I know it returned true/false
20:46:47 <lambdabot> Eq a => a -> [a] -> Bool
20:46:51 <Welkin> it takes 2
20:46:52 <Iceland_jack> Enzoray: No, 'elem' takes two
20:46:53 <Enzoray> I just don't know how to write it.
20:47:00 <Iceland_jack> > elem '7' "hello"
20:47:02 <lambdabot>  False
20:47:07 <Enzoray> elem x = one element?
20:47:17 <tac_> :t elem 1
20:47:17 <lambdabot> (Num a, Eq a) => [a] -> Bool
20:47:22 <tac_> :t elem 1 [1,2,3]
20:47:23 <lambdabot> Bool
20:47:26 <Welkin> then it is partially applied
20:47:51 <Enzoray> If you take a look at what I posted earlier, the standard-definition of elem I've been given.
20:47:53 <Welkin> what kind of an exam is this? Are you in university?
20:48:02 <Enzoray> Yes... :/
20:48:05 <Iceland_jack> Ah, Enzoray
20:48:07 <Welkin> oh, where?
20:48:08 <Iceland_jack> I understand your confusion
20:48:15 <Enzoray> Gothenburg, Sweden.
20:48:19 <Welkin> ah
20:48:24 <Iceland_jack> Chalmers Enzoray?
20:48:26 <Welkin> of course in Europe
20:48:30 <Welkin> haskell is rare in the US
20:48:59 <Enzoray> Iceland, I guess you could say so. It's the university of Gothenburg. We are actually at the same campus. :P
20:49:10 <Iceland_jack> I know, I also study there
20:49:16 <ddellacosta> Welkin: is it more common to find people using Haskell in industry and/or academia in Europe?
20:49:24 <Enzoray> Really?... *.*
20:49:29 <Iceland_jack> Yes Enzoray
20:49:35 <tommd> Nonsense!  Most of my coworkers use Haskell daily, and I am clearly a representative sample of the US tech sector.
20:49:41 <Welkin> ddellacosta: it depends where you look
20:49:59 <Enzoray> You can't be serious.
20:50:01 <ddellacosta> tommd: are you being sarcastic?
20:50:05 * hackagebot ethereum-client-haskell 0.0.3 - A Haskell version of an Ethereum client  http://hackage.haskell.org/package/ethereum-client-haskell-0.0.3 (jamshid)
20:50:06 <Welkin> I meant haskell is rare in US universities, to be more specific
20:50:08 <Iceland_jack>     elem :: (Eq a) => a -> [a] -> Bool
20:50:08 <Iceland_jack>     elem x = any (== x)
20:50:08 <Iceland_jack> for the record Enzoray, that takes two arguments even though you only see a single "x": it's the same as:
20:50:08 <Iceland_jack>     elem :: (Eq a) => a -> [a] -> Bool
20:50:11 <Iceland_jack>     elem x xs = any (== x) xs
20:50:11 <Welkin> but yes, also in industry
20:50:11 <ddellacosta> Welkin: ah, gotcha
20:50:46 <arrdem> is there a parallel partition/merge idiom for Haskell?
20:50:55 <Enzoray> Can we just pause this quick..? You know this... and you study at Chalmers? :S
20:50:58 <Welkin> arrdem: you mean mergesort?
20:51:08 <greymalkin> gah! <directory
20:51:09 <Iceland_jack> Yes Enzoray
20:51:13 <Enzoray> That you study in Chalmers is even more confusing.
20:51:13 <greymalkin> >is a relative path.
20:51:23 <Iceland_jack> How come
20:51:28 <tommd> ddellacosta: No, actually.
20:51:31 <Enzoray> You seem to know everything about Haskell.
20:51:38 <ddellacosta> tommd: well then, I'm jealous. ;-)
20:51:40 <Enzoray> And you're just a student.
20:51:42 <greymalkin> you can make paths relative to the package database... but then "unexpected span"
20:51:43 <Iceland_jack> We've only been talking for some time
20:51:51 <Enzoray> And look at me, I know nothing.. and I'm just a student.
20:52:22 <Welkin> school and learning are not the same thing
20:52:32 <Enzoray> And Haskell is the first course you take.
20:52:35 <Iceland_jack> Does it help if I told you there are a lot of people who know much more than I do about Haskell at Chalmers
20:52:35 <Welkin> if you really enjoy something, you will do it a lot
20:52:51 <Iceland_jack> I'm working on my master's thesis in Iceland, currently
20:52:58 <arrdem> Welkin: in terms of the recursive partition/combine yes, I suppose so
20:53:04 <Enzoray> So, you're on your 5th year..
20:53:06 <Iceland_jack> And organizsing Reykjavík Haskell User Group meetups
20:53:12 <Enzoray> Oh, that makes more sense.
20:53:27 <Enzoray> I thought you just began, I mean. This is the first course you take.
20:53:28 <Iceland_jack> And organising... some weird mix between American and UK spelling
20:53:28 <Welkin> arrdem: you can implement a bottom-up mergesort
20:53:38 <Welkin> arrdem: in fact, that is how Data.List.sort is implemented
20:53:42 <Iceland_jack> Enzoray: No no, I started Haskell two years ago
20:53:52 <Enzoray> How can you then do master things?
20:54:14 <Iceland_jack> Enzoray: You can easily do this stuff if you dive into it
20:54:24 <Iceland_jack> If you want you can ping me any time on IRC and I'll answer questions
20:54:43 <Enzoray> I already added you to the notify list, this is where I keep the skilled people, lel. :D
20:55:05 * hackagebot ethereum-client-haskell 0.0.4 - A Haskell version of an Ethereum client  http://hackage.haskell.org/package/ethereum-client-haskell-0.0.4 (jamshid)
20:55:22 <Enzoray> That might have sound shallow. But it's not.
20:55:24 <Iceland_jack> If you hang out with the right people at Chalmers you can't help but become at least decent at Haskell by second-hand Haskelling
20:55:25 <Welkin> for haskell, the best resources are right here in this channel and the haskell wiki + free haskell books (Learn You a Haskell, Real World Haskell, Parallel and Concurrent Haskell, etc.)
20:56:02 <Welkin> Enzoray: make sure you read the Typeclassopedia and refer back to it often
20:56:09 <Enzoray> Iceland, I think that might be hard..?
20:56:17 <Welkin> understanding the type system is key
20:56:47 <Iceland_jack> Enzoray: It depends! When I get back to Sweden I'll ping you and we can go out for drinks and I'll introduce you to some excellent people
20:57:13 <Welkin> I still don't know a single person (in person) who uses haskell
20:57:30 <Welkin> I just picked up LYAH and joined this channel
20:57:32 <Iceland_jack> Welkin: If you start teaching it to everyone you know you will ;)
20:57:34 <Welkin> that's how I started
20:57:38 <Enzoray> Iceland, I think that might be hard..
20:57:45 <Enzoray> I don't know what will happend then.
20:58:19 <Enzoray> I'm pretty.. screwed atm. :P If so to speak.
20:58:25 <Iceland_jack> How so
20:58:34 <Enzoray> Detta är en omtenta... :S
20:58:41 <Iceland_jack> Well when is the omtenta
20:58:47 <Enzoray> Two days.
20:58:56 <Enzoray> I've been practicing for two straight weeks.
20:59:01 <Enzoray> I have not been able to learn it.
20:59:10 <Iceland_jack> You can definitely make it in two days from what I've heard from you
20:59:30 <Enzoray> Okay, it's in one day, as it's over 12
20:59:33 <Enzoray> Really?
20:59:39 <Iceland_jack> start by reading through the first couple of chapters of LYAH and try running every example
21:00:03 <Iceland_jack> I sent you a Chalmers channel that you can join and ask questions tomorrow
21:00:10 <Enzoray> I don't know if I started this too early. I might not be ready for the challenge.
21:00:14 <Enzoray> I'll do my best though.
21:00:41 <Enzoray> How old were you when you started university?
21:01:11 <Iceland_jack> 17-18 I guess
21:01:15 <Iceland_jack> but I didn't learn anything for 2 years
21:01:33 <Enzoray> Iceland, that's what they all say.. :S
21:01:46 <Iceland_jack> No I really didn't, I started learning Japanese
21:01:51 <Enzoray> Really...?
21:02:00 <Iceland_jack> went to Japan, dicked around for some years without a job
21:02:09 <Enzoray> So you're experienced...
21:02:14 <Iceland_jack> That's where I got my nickname
21:02:21 <Enzoray> Well, you also started one year earlier? :P
21:02:28 <Iceland_jack> I started 2 years early
21:02:39 <Enzoray> Gifted or what? :P
21:02:41 <Iceland_jack> or well, slightly earlier because of my birthday
21:02:51 <Enzoray> How did you even get in?
21:03:10 <Enzoray> I mean.. you can't attend high school and university at the same time.
21:03:10 <Iceland_jack> no I just attended a gymasium that was two years early by changing the structure
21:03:17 <Enzoray> Oh, ok.
21:03:18 <Enzoray> I see.
21:03:38 <Iceland_jack> I actually attended university and elementary school at the same time but that's just because I was a stubborn kid, not because of any brains
21:03:52 <Enzoray> Oh, sounds.. hard.
21:04:09 <Iceland_jack> It wasn't. I wanted to study Japanese with my friend so we walked to the university and asked the professor if we could attend her classes
21:04:31 <Iceland_jack> and then we asked our headmaster who said we could skip classes until the department of education heard of it and shouted at him
21:04:44 <Enzoray> Well, I'm 18 now, I started university at age 17 after attending three years at a technical gymnasium. Nice to meet you.
21:05:01 <Iceland_jack> Nice to meet you too, when I was your age I couldn't program :)
21:05:05 <Iceland_jack> So kick butt
21:05:10 <Enzoray> I can't do shit. :')
21:05:32 <Iceland_jack> You can go through past exams
21:05:40 <Enzoray> I did, they are too hard.
21:05:56 <Iceland_jack> Didn't you just post several problems here that made sense to you?
21:06:02 <Enzoray> I did.
21:06:20 <Enzoray> They make sense before I go to sleep, after.. not so much. :D
21:06:28 <Iceland_jack>     map tryToUnderstand (filter makesSense problems)
21:06:31 <Iceland_jack> oops..
21:06:35 <Iceland_jack>     map tryToUnderstand (filter (not . makesSense) problems)
21:06:56 <Enzoray> Iceland, mind filling me in what happends in case i fail this exam?
21:07:10 <Iceland_jack> I think you just re-sit it next semester
21:07:29 <Iceland_jack> But you shouldn't think like that right before an exam :-) that isn't motivating
21:07:38 <Enzoray> Do I get to continue or am I getting thrown out? :S
21:07:44 <Iceland_jack> You don't get thrown out
21:07:50 <Iceland_jack> a lot of people flunk
21:08:56 <Enzoray> I'll tell you this.
21:09:01 <Enzoray> I can solve the previous exam.
21:09:06 <Enzoray> But, that's about it.
21:09:25 <Iceland_jack> Give me a problem you can't solve
21:09:51 <Enzoray> I'll just give you xs then. lol :P
21:09:52 <shachaf> This is pretty off-topic for this channel by now.
21:10:12 <Iceland_jack> Yes you're right, you can ask me if you need help in the future Enzoray
21:10:16 <Enzoray> shachaf, I see. I apologize for any inconviniece.
21:13:26 <hiptobecubic> It's pretty annoying when a library doesn't export the things you need to write  a type signature
21:14:12 <jfeltz> amen
21:15:06 * hackagebot LambdaNet 0.2.0.0 - A configurable and extensible neural network library  http://hackage.haskell.org/package/LambdaNet-0.2.0.0 (jbarrow)
21:20:06 * hackagebot cudd 0.1.0.0 - Bindings to the CUDD binary decision diagrams library  http://hackage.haskell.org/package/cudd-0.1.0.0 (adamwalker)
21:26:39 <EvanR> :t (=<<)
21:26:40 <lambdabot> Monad m => (a -> m b) -> m a -> m b
21:26:53 <EvanR> :t (=>>)
21:26:54 <lambdabot>     Not in scope: ‘=>>’
21:26:54 <lambdabot>     Perhaps you meant one of these:
21:26:54 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
21:27:51 <fengshaun> I need to learn haskell again
21:27:55 <fengshaun> it was fun
21:28:03 <fengshaun> but then my brain started hurting :<
21:28:14 <EvanR> head exploding is good for you
21:28:25 <fengshaun> it *is*
21:28:43 <fengshaun> I think I gave up at State monad
21:29:02 <EvanR> @unmtl State s a
21:29:02 <lambdabot> s -> (a, s)
21:31:12 <EvanR> @unmtl Cont r a
21:31:12 <lambdabot> (a -> r) -> r
21:35:07 * hackagebot text-show-instances 0.1 - Additional instances for text-show  http://hackage.haskell.org/package/text-show-instances-0.1 (ryanglscott)
21:48:05 <ddellacosta> I'm trying to write some code that is basically imitating some C, which is casting like so: (int)(0.75 * 32768.0 * ... etc.)
21:48:32 <ddellacosta> not sure how to approach this--any suggestions for converting from floats to integers here?
21:48:36 <EvanR> :t floor
21:48:37 <lambdabot> (RealFrac a, Integral b) => a -> b
21:48:48 <tommd> > floor (0.75 * 32768.0 *1)
21:48:50 <lambdabot>  24576
21:49:03 <ddellacosta> EvanR, tommd: okay, thanks
21:50:46 <ddellacosta> yeesh, now what am I going to with this 0xff thing...been a while since I've read C code...
21:50:54 <EvanR> > 0xff
21:50:55 <lambdabot>  255
21:51:22 <ddellacosta> EvanR: yeah, I just don't know what function it has in this buffer I'm stuffing it into
21:51:49 <ddellacosta> gotta try to understand the structure of the thing and then figure out the best way to build it in Haskell, and pass it to C.  Using Storable Vector now
21:52:13 <ddellacosta> (writing FFI code if that wasn't obvious)
21:56:43 <biinui> hello :) I need to convert Int into ALsizei. ALsizei is synonym of CInt. CInt has constructor CInt Int32. Is http://lpaste.net/117610 acceptable? May you suggest a better way? Does it risk an overflow?
21:56:49 <rqiu> :t optional
21:56:50 <lambdabot> Alternative f => f a -> f (Maybe a)
21:57:30 <EvanR> biinui: fromIntegral
21:58:34 <EvanR> biinui: i doubt you will see a list with length > maxBound :: Int32
21:59:09 <fengshaun> why would the where clause be needed?
21:59:30 <fengshaun> isn't `sizeOf = fromIntegral . length` not enough?
22:05:09 * hackagebot text-show-instances 0.1.0.1 - Additional instances for text-show  http://hackage.haskell.org/package/text-show-instances-0.1.0.1 (ryanglscott)
22:06:47 <biinui> EvanR: you have a point
22:07:12 <biinui> fengshaun: nice thanks!
22:23:53 <calvinx> is there a way to list all the cabal sandboxes I have on my machine?
22:28:20 <ddellacosta> calvinx: as far as I know sandboxes aren't registered globally, you'd have to do something like (on a posix system) `find . -name .cabal-sandbox |wc -l`
22:28:40 <ddellacosta> to get a count for example, I guess leave off the wc -l for a listing
22:31:04 <calvinx> yea - I guess that will have to do for now.
22:33:30 <Javran> if I build a binary in a sandbox, will the binary run if I move it to somewhere outside the sandbox?
22:34:27 <Javran> for example I build xmonad in some sandbox then later can I move it to ~/.xmonad/xmonad-xxx-xxx ?
22:36:46 <pavonio> Depends if you build with dynamic or static linking, I guess
22:38:15 <solatis> hmmm what are my best options if i want to include mathematical documentation into my haskell code ?
22:38:38 <solatis> literate haskell seems to be somewhat suboptimal
22:38:59 <solatis> i was thinking haddock, but it seems haddock has very limited support for unicode
22:45:13 <ddellacosta> solatis: I'm not sure if this exactly fits the bill, but have you checked out lhs2tex? http://www.andres-loeh.de/lhs2tex/
22:49:10 <solatis> ddellacosta: yeah i know, but i find lhs2tex to be a bit awkward
22:49:23 <ddellacosta> solatis: okay...sorry, I got nothin' else
22:49:41 <solatis> i'd much rather have haddock support mathematical symbols, but guess i might have to contribute to haddock myself in order to do that
22:50:11 <solatis> (imho it would make sense in the world of haskell, given its academic nature)
22:50:29 <ddellacosta> yeah, that seems like it could be handy
22:51:07 <ddellacosta> is there a safe way to convert from CInt to Int?
22:51:19 <ddellacosta> other than writing my own fn I guess
23:05:16 <gienah> ddellacosta: One way is: (toEnum . fromEnum) x
23:06:16 <ddellacosta> gienah: thanks.  I was trying unsafeCoerce, since I know that the value I'm converting should be within the range of a haskell Int, but I'm not sure what the "right" way is
23:07:39 <gienah> ddellacosta: I am not sure what the right way is, (toEnum . fromEnum) x seems to be able to handle some conversions
23:07:50 <ddellacosta> gienah: although, that's giving me "bad argument," maybe I'm doing something wrong here?
23:08:30 <ddellacosta> *** Exception: Prelude.Enum.().toEnum: bad argument
23:08:39 <gienah> ddellacosta: I tried it like this in ghci: :m +Foreign.C.Types
23:08:50 <gienah> let x = 5 :: CInt in ((toEnum . fromEnum) x) :: Int
23:09:30 <ddellacosta> gienah: ah, okay, that works for me
23:09:40 <gienah> ddellacosta: great
23:09:46 <ddellacosta> gienah: thank you!
23:09:47 <pavonio> https://www.haskell.org/haskellwiki/Converting_numbers
23:10:12 * hackagebot persistent-postgresql 2.1.2.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.1.2.1 (MichaelSnoyman)
23:10:14 * hackagebot persistent-mysql 2.1.2.1 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-2.1.2.1 (MichaelSnoyman)
23:10:29 <ddellacosta> pavonio: thanks for that too! good general information I was missing
23:12:40 <ddellacosta> wow, appending really is freaking slow huh
23:15:13 * hackagebot yesod-bin 1.4.3.3 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.3.3 (MichaelSnoyman)
23:22:33 <khumba> I believe fromIntegral converts between the various Int, IntXX, WordXX, CInt, etc. types via casting, and it seems to return -1 in case of overflow, e.g. fromIntegral (maxBound :: CLong) :: CInt
23:23:00 <khumba> ddellacosta: ^
23:23:15 <ddellacosta> khumba: thanks, will check it out
23:24:12 <ddellacosta> now I'm stumbling around trying to figure out how to do a O(log n) append (or something close to it) though
23:24:32 <khumba> ddellacosta: Yep; see the documentation notes at the bottom of Data.Int.
23:24:55 <khumba> "Coercing word types (see Data.Word) to and from integer types preserves representation, not sign."
23:25:05 <pavonio> ddellacosta: Use Seq instead of lists
23:25:30 <ddellacosta> pavonio: well, I've got to end up with something I can pass into a C fn, so was thinking I should use Data.Vector.Storable
23:26:03 <ddellacosta> not sure if that obviates the need for seq or not though
23:26:31 <solatis> hmmm i always thought that haskell did memoization out of the box, but according to wikipedia you have to manage the data structures for memoization yourself?
23:30:15 <pavonio> ddellacosta: Not sure what you are trying to do, but can't you use Seq for the calculation of your result and convert the final result to something storable?
23:30:41 <ddellacosta> pavonio: yeah, I think so, just foggy on the particulars (never done FFI stuff before so learning as I go)
23:31:32 <ddellacosta> pavonio: I'm guessing I can do something like toList from a Seq then into my Data.Vector.Storable
23:31:42 <ddellacosta> not sure how inefficient that is
23:35:52 <ddellacosta> pavonio: that worked like a charm, thanks!
23:36:18 <pavonio> No problem
23:38:21 <_1_alexsabir7111> hi
23:40:14 * hackagebot eventstore 0.3.0.0 - EventStore Haskell TCP Client  http://hackage.haskell.org/package/eventstore-0.3.0.0 (YorickLaupa)
