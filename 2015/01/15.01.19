00:08:10 * hackagebot wai-app-file-cgi 3.0.4 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-3.0.4 (KazuYamamoto)
00:08:10 * hackagebot basic-prelude 0.3.11 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.11 (MichaelSnoyman)
00:32:11 <southp> Hi. In some articles, seq x y is described as "seq is a special function which evaluates x to its weak head normal form, and return y". I know we can use this property to force strict evaluation. However, in the prelude source code, seq is just defined as: seq _ y = y, I don't understand why this code make anything strict.
00:32:31 <southp> Is there any special thing behind the hood specifically for seq?
00:33:35 <kazagistar> southp: yes, that code normally wouldn't do what seq does
00:34:19 <kazagistar> southp: I am wondering where you got that definiton from though?
00:35:06 <southp> kazagistar: I did 'cabal get base', and found it in the Prelude.hs.
00:35:29 <shachaf> southp: That looks wrong.
00:35:51 <southp> Ouch. I just found that it is surrounded by #ifdef __HADDOCK__.
00:36:00 <shachaf> southp: Look around that code, it's -- yes.
00:36:16 <southp> So it's just a placeholder code...my bad :(
00:36:44 <kazagistar> yeah, seq is pretty deeply magical afaik
00:38:14 <southp> So its an intrinsic function that does strict evaluation magic. That's make much more sense now.
00:39:49 <shachaf> It's slightly magical at best.
00:40:30 <glguy> which way does worst go?
00:40:37 <glguy> dramatically magical?
00:41:21 <kazagistar> yeah, you could implement it on a case by case basis by inspection via typeclass, right?
00:42:03 <glguy> might need help to seq a function
00:49:42 <f0rk> Could someone explain to me why type inference works this way? http://lpaste.net/118746
00:51:25 <ab9rf> f0rk: can you elaborate?
00:51:42 <glguy> f0rk: You're probably being confused by the monomorphism restriction
00:51:57 <glguy> and then defaultig
00:52:01 <glguy> defaulting
00:52:25 <ab9rf> oh, yeah i see wehat you mean
00:52:29 <ab9rf> that's monomorphism for you
00:52:33 <glguy> This is covered in detail in https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-930004.5.5
00:53:30 <glguy> The idea is that if something looks like it isn't a function (no arguments) then it should behave like a value that will only be evaluated once
00:53:52 <glguy> but that wouldn't be the case if it was allowed to be polymorphic with a class constraint on its type
00:55:02 <shachaf> glguy: Should the MR not apply to things that have a function type?
00:55:19 <shachaf> f = show and so on
00:55:47 <glguy> I mean "looks like a function" syntactically
00:55:58 <glguy> f x = vs  f =
00:56:04 <f0rk> glguy: thanks
00:56:56 <shachaf> glguy: Right. But I'm wondering if there would be any negative effects of specifically disabling the MR for things function with known function types.
00:57:09 <shachaf> Other than a restriction which is less syntactic and more complicated, I guess.
00:58:42 <glguy> You can have complex computation that produces a single function value, so having it for obvious function types probably serves a purpose
00:58:58 <glguy> I haven't really thought about that, though
00:59:17 <glguy> single/reusable
01:03:03 <glguy> I think people get used to the MR; the one that I think surprises people is turning on TypeFamilies and getting MonoLocalBinds :)
01:04:40 <trap_exit> class View a b where \n view :: a -> b \n
01:04:46 <shachaf> Hah, yes.
01:04:46 <trap_exit> now, if b is fully determined given a, what is this called?
01:05:06 <trap_exit> shachaf: help me :-), see ^ above
01:07:59 <nomeata> Hi. It seems that time-1.5 defines "defaultTimeLocale", when previously I had to import System.Locale. Is there a CPP-free way that works with time-1.4 and time-1.5?
01:08:22 <nomeata> Also, where would I find a changelog describing this change and suggested migrations?
01:09:24 <shachaf> nomeata: You mean defaultTimeLocale is now exported from both, so you get a redundant import warning?
01:09:37 <nomeata> shachaf: well, they have different types it seems
01:09:46 <shachaf> Oh.
01:10:02 <Lokathor> you can hide the new function if you don't want it as part of your import, if that's what you mean?
01:10:14 <nomeata> ah, https://ghc.haskell.org/trac/ghc/wiki/Migration/7.10 mentions it
01:10:37 <nomeata> but the suggested way to handle this requires CPP: https://github.com/bos/aeson/commit/730a8c42b75f38e241da39933b03735a7c905538
01:11:05 <nomeata> CPP and changes to .cabal
01:11:40 * nomeata agrees more and more with some of the voices that say that Haskell is not really having a good grip on having non-disruptive changes
01:13:04 <Lokathor> there does seem to be a bit of a namespace issue, yes
01:13:56 <nomeata> I don‚Äôt think it‚Äôs a matter of namespaces. The new values are supposed to replace the old once, and as long as you want to compile against precisely one set of dependency versions, it makes sense
01:14:43 <Lokathor> but it seems that you actually do want to support compilation with time 1.4 and time 1.5 at the same time?
01:16:16 <nomeata> Lokathor: yes. It‚Äôs a library that comes with GHC and not always easily upgradeable
01:48:04 * hackagebot plot 0.2.3.4 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.2.3.4 (VivianMcPhail)
01:52:24 <glguy> Trap_exit. Functional dependency
01:52:56 <trap_exit> glguy: exactly
01:52:57 <trap_exit> thanks
01:53:04 * hackagebot tttool 0.1 - Working with files for the TiptoiÆ pen  http://hackage.haskell.org/package/tttool-0.1 (JoachimBreitner)
01:53:08 <trap_exit> glguy: notation is "class Foo a b c | a b -> c ... "
01:53:11 <trap_exit> to mean that a + b determines c
01:55:21 <glguy> Yes
02:34:52 <AshyIsMe> nomeata: hopefully stackage saves us all...
02:38:05 * hackagebot amazonka-core 0.2.1 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.2.1 (BrendanHay)
02:38:07 * hackagebot amazonka 0.2.1 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.2.1 (BrendanHay)
02:38:09 * hackagebot amazonka-autoscaling 0.2.1 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.2.1 (BrendanHay)
02:38:11 * hackagebot amazonka-cloudformation 0.2.1 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.2.1 (BrendanHay)
02:38:13 * hackagebot amazonka-cloudfront 0.2.1 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.2.1 (BrendanHay)
02:40:29 <bergmark> nomeata: the only other option i see is to make a time-compat library that handles the CPP
02:43:15 * hackagebot amazonka-cloudhsm 0.2.1 - Amazon CloudHSM SDK.  http://hackage.haskell.org/package/amazonka-cloudhsm-0.2.1 (BrendanHay)
02:43:17 * hackagebot amazonka-cloudsearch 0.2.1 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.2.1 (BrendanHay)
02:43:19 * hackagebot amazonka-cloudsearch-domains 0.2.1 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.2.1 (BrendanHay)
02:43:21 * hackagebot amazonka-cloudtrail 0.2.1 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.2.1 (BrendanHay)
02:43:23 * hackagebot amazonka-cloudwatch 0.2.1 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.2.1 (BrendanHay)
02:48:24 * hackagebot amazonka-cloudwatch-logs 0.2.1 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.2.1 (BrendanHay)
02:48:27 * hackagebot amazonka-codedeploy 0.2.1 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.2.1 (BrendanHay)
02:48:29 * hackagebot amazonka-cognito-identity 0.2.1 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.2.1 (BrendanHay)
02:48:31 * hackagebot amazonka-emr 0.2.1 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.2.1 (BrendanHay)
02:48:33 * hackagebot amazonka-iam 0.2.1 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.2.1 (BrendanHay)
02:48:35 <flux> :-)
02:48:42 <jle`> you go, BrendanHay
02:49:11 <mpickering> Are there any libraries which make it easier to specify which types of errors can be thrown from a certain function?
02:49:33 <mpickering> ie "Either '[Error1, Error2] a"
02:50:09 <flux> feature: hackagebot could wait 1 minute before announcement, collect all new packages within that time, find they parent dependency, output only its information, and list the rest in format amazonka{,-{core,cloud{,search,shm},etc}}
02:50:15 <Axman6> I wrote a small thing that allows you to do that for IO code using data kinds and a few other things
02:50:29 <flux> ("find their common nearby parent dependency")
02:51:00 <mpickering> I'm worried that any solution wouldn't scale well
02:51:09 <mpickering> and/or require RebindableSyntax
02:51:24 <Axman6> mpickering: https://gist.github.com/axman6/19adc08a809d919a2efb lines 82 onwards in particular
02:52:18 <Axman6> IIRC the error messages are pretty readable too
02:52:52 <Axman6> The ("Error" ~ "foo") trick is a nice hack
02:53:24 <mpickering> looks nice, I was wondering whether it would be sensible one day to build in support for indexed monads
02:53:34 * hackagebot amazonka-importexport 0.2.1 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.2.1 (BrendanHay)
02:53:36 * hackagebot amazonka-kinesis 0.2.1 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.2.1 (BrendanHay)
02:53:38 * hackagebot amazonka-kms 0.2.1 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.2.1 (BrendanHay)
02:53:40 * hackagebot amazonka-lambda 0.2.1 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.2.1 (BrendanHay)
02:53:42 * hackagebot amazonka-opsworks 0.2.1 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.2.1 (BrendanHay)
02:53:50 <Axman6> seems like the easiest way to track these things
02:54:21 <mpickering> because an indexed monad is more general when a normal monad so you could then use normal do notation for both
02:54:42 <Axman6> yeah
02:54:54 <Axman6> which I guess is why you mentioned RebindableSyntax
02:56:05 <mpickering> exactly but.. using both Ix and Non-Ix in the same module then becomes a pain but it needn't
02:57:34 <Axman6> newtype WrappedM i o m a = WrappedM (m a); instance IxMonad WrappedM where ...
02:57:51 <Axman6> or... not
02:58:44 * hackagebot amazonka-rds 0.2.1 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.2.1 (BrendanHay)
02:58:46 * hackagebot amazonka-redshift 0.2.1 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.2.1 (BrendanHay)
02:58:48 * hackagebot amazonka-route53 0.2.1 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.2.1 (BrendanHay)
02:58:50 * hackagebot amazonka-route53-domains 0.2.1 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.2.1 (BrendanHay)
02:58:52 * hackagebot amazonka-s3 0.2.1 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.2.1 (BrendanHay)
03:00:57 <gregnwosu> can someone tell me the an advantage of the IO monad, other than retaining purity
03:01:26 <reem> That's really *the* major advantage
03:01:38 <jle`> do you mean the IO type in haskell, as opposed to unchecked side effects?
03:01:43 <Axman6> it means that you can use generic functions that work on any monad
03:01:53 <jle`> or do you mean, in particular, the Monad instance/interface?
03:02:35 <gregnwosu> jle`: I mean the reason behind making I/O into a monad
03:02:47 <jle`> i don't really see the IO type's benefits in "purity" as that much of a main advantage anymore...in my day-to-day usage, one big advantage as opposed to unchecked side effects is really first-class effects and io actions
03:02:48 <reem> It lets you purely compose and build IO actions using the same tools as for all other monads
03:03:01 <jle`> gregnwosu: if the IO type in haskell wasn't a Monad, it'd be a bit awkward to use
03:03:10 <jle`> that'd be like having an array type and not offering indexing
03:03:14 <Axman6> gregnwosu: because IO is something which can be used monadically, that's it really
03:03:38 <gregnwosu> jle`: i'll clarify , why make input output operations monadic
03:03:44 <jle`> but really, the power of IO in haskell doesn't really come from the fact that it's a monad
03:03:54 * hackagebot amazonka-sdb 0.2.1 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.2.1 (BrendanHay)
03:03:56 <jle`> the power of IO in haskell is that it is represented by just a normal data type
03:03:56 * hackagebot amazonka-ses 0.2.1 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.2.1 (BrendanHay)
03:03:58 * hackagebot amazonka-sns 0.2.1 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.2.1 (BrendanHay)
03:04:00 * hackagebot amazonka-sqs 0.2.1 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.2.1 (BrendanHay)
03:04:02 * hackagebot amazonka-storagegateway 0.2.1 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.2.1 (BrendanHay)
03:04:04 <jle`> just like an array, or a map, or a string
03:04:11 <jle`> it's just normal data that represents things a computer can do
03:04:22 <jle`> *that's* where the "purity" part comes from
03:04:34 <jle`> the Monadic interface is just a convenient interface to using it
03:04:49 <tdammers> gregnwosu: the fact that IO turns out to fit the profile of a monad is more like a useful observation. It is absolutely not required to make IO itself possible or useful in Haskell.
03:05:02 <jle`> the fact that IO in haskell is first-class data, as opposed to in other languages, is the real gain
03:05:10 * tdammers nods
03:05:12 <jle`> you don't have to have anything to do wiht monads to have first-class IO actions
03:05:30 <jle`> in short, the monad-ness isn't the important part
03:05:36 <tdammers> hmm, where's that article again that builds an IO type without providing the monadic interface...
03:06:07 <gregnwosu> jle`: so why..... have the concept of IO actions, what does it buy apart from purity
03:06:16 <jle`> the monad-ness isn't what is important...what's important is that IO in haskell is represented by normal data that doesn't execute arbitrary side effects on evaluation
03:06:23 <gregnwosu> or rather what does the purity of IO actions enable us to do
03:06:24 <jle`> gregnwosu: you get first-class actions
03:06:32 <jle`> actions that you can manipulate as data
03:07:03 <gregnwosu> jle`: and manipulating first class actions as data is good because....?
03:07:08 <jle`> i wrote a post on this idea a couple months back, if you want -- http://blog.jle.im/entry/first-class-statements
03:07:19 <tdammers> because the alternative is not being able to manipulate them
03:07:41 <gregnwosu> im not trolling , you are preaching to the converted, I just dont know why in my own heart its so useful
03:07:42 <tdammers> you don't *need* first-class IO actions, but they can make for very elegant solutions
03:08:02 <gregnwosu> tdammers: for example...?
03:08:09 <jle`> i think one thing people often say is that you can "combine" IO actiosn in different ways
03:08:12 <jle`> you can defer the combination
03:08:19 <tdammers> indeed
03:08:20 <jle`> if you have a list of IO actions, and you want to merge them into one giant IO action
03:08:27 <jle`> you can either combine them sequentially, or in parallel
03:08:51 <Axman6> you can write things like forever $ <answer queries from clients>
03:08:52 <gregnwosu> jle`: sequence vs traverse no?
03:08:52 <tdammers> or you can chunk up the list, insert other operations in between, etc.
03:08:55 <jle`> but that's because they are normal data.  you can chose to "merge" lists in any way you want
03:09:04 * hackagebot amazonka-sts 0.2.1 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.2.1 (BrendanHay)
03:09:06 <jle`> yeah, you can insert actions between lists
03:09:06 * hackagebot amazonka-support 0.2.1 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.2.1 (BrendanHay)
03:09:08 * hackagebot amazonka-swf 0.2.1 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.2.1 (BrendanHay)
03:09:21 <jle`> another thing that i like is that it frees your mind to think "outside" of IO directly
03:09:27 <gregnwosu> Axman6: you can do that with non first class action types
03:09:34 <tdammers> more down-to-earth, one thing I wrote a while ago did pagination by producing a list of IO actions, each of them responsible for rendering one page
03:10:00 <gregnwosu> jle`: please expand on the mind freeing bit
03:10:05 <jle`> if you can represent your entire program as a data type, your own custom data type, or a DSL...then your user can just spend their whole time working with your data tyle
03:10:08 <jle`> *data type
03:10:09 <tdammers> it needed part of the rendering context, so its type signature ended up as Document -> IO [IO]
03:10:13 <jle`> just normal data
03:10:21 <jle`> and then...at the end, you provide a function MyData -> IO ()
03:10:41 <jle`> so the user assembles their program using your data type, a program specification, and then all you do is turn that program specification into an IO action
03:10:58 <jle`> no different than, say, [a] -> Maybe a
03:11:05 <tdammers> then you could say, for example, print only the first page: paginate document >>= print . head
03:11:07 <jle`> just a structural transformation, even
03:11:12 <gregnwosu> jle`: i understand now thank you
03:11:27 <jle`> and not only that, you can provude guaruntees as to what actions MyData can represent
03:11:43 <jle`> so your user can be sure of things like, "if i build my program using the MyData DSL, i won't ever launch any missiles"
03:11:51 <gregnwosu> lol
03:11:53 <gregnwosu> true
03:12:01 <jle`> what tdammers is saying is also a more direct and immediate everyday benefit
03:13:35 <gregnwosu> yes, tdammers: that looks useful too, so you can treat the io in a structural way
03:14:00 <gregnwosu> and like jle` says this frees the mind of concern around side effects
03:14:53 <gregnwosu> simililarly one can construct actions as data, defering execution, then extract the parts of the action structure to execute
03:15:22 <gregnwosu> thank you all for your patience and for you help with my rather ill-defined question
03:15:27 <gregnwosu> *your
03:26:13 <jle`> no problem :)
03:26:17 <gregnwosu> :)
03:37:55 <Pieter_> Hi, I was looking at the '-:' function (which allows us to first give the value and than the function: x -: f = f x). I am practicing for an oral exam about Haskell, and I am curious if this function has a special name ?
03:38:49 <Iceland_jack> Pieter_: It's sometimes called (&) or (|>), you can call it "flipped function application" or "pipe operator" in F#
03:39:10 <Iceland_jack> another name is (#)
03:39:28 <int-e> I was going to suggest "flipped function application" as well.
03:40:06 <Pieter_> Okay thanks for the suggestions. Although at first sight I find flip confusing with the function flip which flips the two arguments of a function.
03:40:06 <Iceland_jack> or "reverse application operator"
03:40:15 <Pieter_> I like that one !
03:40:26 <Iceland_jack> that's what the changelog calls it
03:40:47 <Iceland_jack> From GHC 7.10's base:
03:40:47 <Iceland_jack>     * Add reverse application operator `Data.Function.(&)`
03:40:47 <Iceland_jack>     
03:41:26 <Pieter_> Okay , great ! I got what I came for ! Thanks guys
03:41:31 <Iceland_jack> But (:-) is just a bespoke operator defined in a single chapter of LYAH, I'd focus on other things
03:41:57 <Iceland_jack> I meant *(-:)
03:42:04 <Pieter_> Yes indeed, it is something small.
03:53:07 * hackagebot hmatrix-gsl 0.16.0.3 - Numerical computation  http://hackage.haskell.org/package/hmatrix-gsl-0.16.0.3 (AlbertoRuiz)
04:05:07 <dementorr> Hello, is there a way to set +RTS -N in .hs file with some pragmas? Or is it necesairy to specify it when you compile it?
04:07:43 <merijn> dementorr: You can actually dynamically set it from your code :)
04:08:09 <merijn> @hoogle setNumCapabilities
04:08:11 <lambdabot> No results found
04:08:15 <merijn> ah, not indexed
04:08:19 <merijn> Anyway
04:08:37 <merijn> GHC.Conc.Sync let's you alter the number of capabilities (i.e., number of concurrent haskell threads)
04:12:37 <dementorr> merijn: it got an error: http://pastebin.com/DX9sK6F8
04:13:01 <merijn> dementorr: Ah, you didn't use the threaded runtime
04:13:16 <merijn> dementorr: use the -threaded flag for GHC to tell it to link the multithreaded runtime
04:16:14 <dementorr> merijn: Ok it works, but if I let someone else compile my code, and I can just see the result of the program, is there a way (pragma I think) to see if -threaded is specified or to specify it?
04:19:03 <merijn> I think there probably is, but I don't know it off the top of my head
04:22:18 <merijn> dementorr: Ok, I don't see a way, beyond someone on SO suggesting "that's a good idea, maybe you should file a feature request"
04:22:34 <merijn> tbh, I don't think it'd be very hard to implement, but I'm not sure whether anyone has
04:23:15 <dementorr> merijn: ok, thanks for your help
04:24:04 <merijn> dementorr: Check if there's already a ticket and if not, file a feature request: https://ghc.haskell.org/trac/ghc/
04:32:46 <blueonyx> dementorr, merijn: cant you just pass a threaded rts opt? eg
04:32:53 <blueonyx> ./bubbleblast +RTS -N
04:32:55 <blueonyx> bubbleblast: the flag -N requires the program to be built with -threaded
04:33:19 <blueonyx> ah dementorr gone
04:36:09 <merijn> blueonyx: Sure, but that requires your users to know that
04:36:24 <merijn> blueonyx: Which shouldn't be something an application user cares about
04:38:10 * hackagebot jwt 0.5.3 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.5.3 (StefanSaasen)
04:38:38 <kaiko> How to compile ghc with -fPIC? (Want to build shared library without libHSbase dependency)
04:40:32 <blueonyx> but this cant happen, she said someone else has compiled her code, so she can test it, if you compile for a user, shouldnt you use --with-rtsopts="threaded-requiring-opt"
04:40:33 <int-e> kaiko: I suppose you can add -fPIC to GhcLibHcOpts in mk/build.mk
04:40:46 <blueonyx> sry, whatever
04:53:11 * hackagebot regex-genex 0.6.2 - From a regex, generate all possible strings it can match  http://hackage.haskell.org/package/regex-genex-0.6.2 (AudreyTang)
04:53:13 * hackagebot jwt 0.4.4 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.4.4 (StefanSaasen)
05:01:01 <R0b0t1> https://github.com/haskell/cabal/issues/936
05:01:03 <R0b0t1> ...
05:02:38 <R0b0t1> "(lack of package signing and ability for anyone with a hackage account to push any package are much bigger ones.)"
05:02:40 * R0b0t1 runs away
05:06:55 <kaiko> int-e: I tried it but it didn't help. Here is same issue: http://stackoverflow.com/questions/7652799/compiling-ghc-with-fpic-support?rq=1 (but it doesn't say what to do)
05:10:34 <merijn> kaiko: For building GHC you may also want to consult #ghc (although it's mostly quiet there)
05:23:57 <solirc> ezrios: Either specify e.g. -a 1000 on the command-line or use the combinators from http://hackage.haskell.org/package/hspec-2.1.2/docs/Test-Hspec-QuickCheck.html
05:24:27 <solirc> ezrios: e.g. (modifyMaxSize $ cont 1000) spec
05:32:25 <davd> any non-bindings options to ncurses in haskell?
05:36:47 <merijn> davd: vty + vty-ui
05:36:58 <merijn> davd: Pure haskell library for ncurses like stuff
05:37:09 <merijn> And vty-ui is a widget library on top of vty that's pretty neat
05:37:25 <merijn> It's not as beautiful as I would like, but considerably simpler and usable than ncurses
05:37:26 <davd> awesome
05:37:39 <davd> mostly concerned about security, so cool
05:37:41 <merijn> (beautiful in terms of code/API design)
05:42:57 <IRWolfie-> I don't know the right terminology for it, but how do I undefine a list that I have in ghci?
05:44:10 <IRWolfie-> i.e, I have let test = 2, how do I make it forget about having defined test
05:44:19 <eXeC64> This probably isn't the proper way, but you could: let test = undefined
05:44:49 <merijn> ":reload" should wipe all local definitions
05:45:19 <IRWolfie-> that does it
06:03:59 <vanila> anyone familiar with appels compiler stuff? confused about something..
06:05:46 <merijn> That depends on what you mean by that
06:20:51 <tomejaguar> Under Debian I just installed the latest haskell-mode package for emacs, but it doesn't load, nor can I 'M-x haskell-mode'.  Does anyone know why?
06:22:54 <tomejaguar> Ah it requires emacs24.  I shall file a bug on the Debian package.
06:34:43 <J_Arcane> the perpetual Debian curse: outdated packages.
06:35:48 <tdammers> not curse. choice.
06:39:41 <J_Arcane> perhaps. this is why I chose not to use Debian anymore ...
06:42:01 <tasker> Does anyone know of a haskell dockerfile that enables profiling ?
06:54:19 <aleator> If I make a function that removes all consecutive duplicates of a list, is it ana, cata, or paramorphism? (Or some other morphism?)
06:54:40 <vanila> no
06:55:02 <mauke\> @src group
06:55:02 <lambdabot> group = groupBy (==)
06:55:06 <mauke\> @src groupBy
06:55:07 <lambdabot> groupBy _  []     =  []
06:55:07 <lambdabot> groupBy eq (x:xs) =  (x:ys) : groupBy eq zs
06:55:07 <lambdabot>     where (ys,zs) = span (eq x) xs
06:56:29 <aleator> vanila: Why?
06:57:44 <vanila> it doesn't fit into one of those templates
06:57:48 <vanila> its a different recursion structure
06:59:10 <aleator> vanila: Why doesn't fit?
06:59:36 <johnw> aleator: I think you could do it with a catamorphism
06:59:38 <quchen2> Well, it's "some other morphism" because it's a morphism from lists to lists.
06:59:41 <vanila> they all do one step at a time yours does an arbitrary number
07:00:03 <johnw> aleator: you should try coding it up and see
07:00:49 <aleator> johnw: I did: http://pastebin.com/tiXRtAaW
07:01:11 <aleator> vanila: See paste above, as a paramorphism it doesn't take many steps. I think
07:01:18 <johnw> > foldr (\x rest -> x : dropWhile (== x) rest) [] [1,2,2,2,3,3,4]
07:01:20 <lambdabot>  [1,2,3,4]
07:01:24 <johnw> that's just cata
07:01:53 <aleator> johnw: Is it a cata if you use dropwhile, which does it's own recursion, inside?
07:02:20 <johnw> I didn't require any additional structure, like para would
07:04:23 <aleator> johnw: But you needed dropWhile, which is another cata
07:04:59 <johnw> cata refers to the type of the foldr
07:05:09 <johnw> I don't tihnk it refers to how I implement it
07:05:34 <johnw> if it had required para, I wouldn't have been able to get away with just using foldr
07:05:40 <johnw> and ana would have needed something like unfoldr
07:06:21 <aleator> That's the point I was unclear about. If a function is expressible as catamorphism by making use of other recursive functions? For example?
07:07:35 <johnw> you're thinking about implementation
07:08:05 <johnw> being expressible as catamorphism simply means that it fits the type of a simple fold
07:08:29 <johnw> (i.e., that it's a morphism from the initial algebra)
07:08:33 <Geraldus_> hi friends! Does anybody familiar with WebKitGtk3 package?
07:09:46 <quchen2> > foldr (\x rest -> nub (x:rest)) [] [1,2,2,2,3,3,4] -- johnw: so this is a cata as well?
07:09:50 <lambdabot>  [1,2,3,4]
07:09:56 <johnw> quchen2: I'm pretty certain it is
07:10:09 <aleator> johnw: So anything is cata?
07:10:15 <johnw> anything you can write with foldr is
07:10:33 <johnw> which may be everything but ana!
07:10:42 <johnw> because I can imagine how to write para using foldr
07:11:12 <aleator> johnw: So, what is not a cata?
07:11:14 <johnw> catamorphisms are very general, so this does not surprise me
07:11:18 <johnw> ana is not cata
07:11:28 <johnw> cata cannot work on infinite structures, cata can
07:11:35 <johnw> s/cata/ana (last position)
07:11:45 <johnw> ana is co-recursive
07:13:07 <johnw> I think that para and all the rest are simply specific special cases which are general enough in themselves to warrant attention
07:14:03 <johnw> para f base xs = foldr g base (init $ tails xs) where g (x:xs) = f x xs
07:16:30 <athan> How many tactics can I use for reflecting (pretty sure) a type back into a value? I've specifically got a rose tree... I just can't wrap my head around constructively doing this
07:16:57 <vanila> athan, you could use typeclasses
07:17:16 <athan> vanila: !!! That is perfect!
07:17:20 <athan> Thank you!
07:17:42 <tasker> Are there any tools avaliaible to analyse a .prof file ?
07:18:12 <quchen2> tasker: profiteur gives you a nice graphical view
07:18:57 <tasker> quchen2: Where can I get this ?
07:19:07 <quchen2> ?hackage profiteur
07:19:07 <lambdabot> http://hackage.haskell.org/package/profiteur
07:19:16 <kqr> quick curiosity question: is there a container agnostic filter? (similar to how fmap is a container agnostic map)
07:19:16 <quchen2> Hackage, as usual :-)
07:19:36 <tasker> ah, I was spelling it incorrectly :p
07:20:32 <quchen2> kqr: I think Filterable would be a subclass of Traversable
07:21:03 <kqr> that's what my intuition tells me
07:21:04 <athan> vanila: Ahh, but how could I do this compositionally if my input type is hidden, something like `Proxy (the fullly promoted rose tree)`
07:21:08 <kqr> but there's nothing like that in the common libraries
07:21:10 <kqr> ?
07:21:21 <athan> Oh wait
07:21:24 <athan> a superclass...?
07:21:35 <vanila> i dont know about proxy
07:22:01 <athan> vanila: I'll hope haha
07:22:04 <johnw> quchen2: wouldn't it have to be a subclass of only Foldable?
07:22:27 <johnw> because we can do filtering with foldMap
07:22:49 <johnw> and I don't see why that would need another typeclass
07:22:51 <quchen2> johnw: My gut tells me that since Traversable traverses without altering e.g. length Filterable should be a subclass, but I'm not sure at all
07:22:58 <johnw> oh, I see
07:23:05 <quchen2> You can't filter with foldMap because you'd get a monoid out
07:23:06 <johnw> you may not know how to build the new structure up
07:23:11 <quchen2> Right.
07:23:24 <johnw> write it! :)
07:23:27 <quchen2> Hylomorphism? :-)
07:23:31 <johnw> haha
07:23:46 <quchen2> That's what it's called, no?
07:24:33 <johnw> I think hylo is to ana, as para is to cata
07:24:36 <ClaudiusMaximus> tasker: http://hackage.haskell.org/package/prof2pretty is one i wrote
07:24:39 <johnw> oh, no
07:24:42 <johnw> hylo = cata + ana
07:24:52 <johnw> http://conal.net/talks/folds-and-unfolds.pdf
07:25:02 <quchen2> What's para?
07:25:11 <tasker> ClaudiusMaximus: Cool, cheers.
07:25:17 <johnw> para gives you access the original structure at each point in the recursion
07:25:32 <johnw> in the case of a list, you get both the element and the sublist it's the head of
07:25:47 <quchen2> para xs = foldr (f xs) z xs -- something like this?
07:25:54 <johnw> 09:13 <johnw> para f base xs = foldr g base (init $ tails xs) where g (x:xs) = f x xs
07:26:28 <johnw> you were extremely close
07:26:30 <quchen2> Ah, I see
07:27:43 <johnw> I find that generalizing recursion schemes can be quite valuable, but that the categorical taxonomy is not so much :)
07:27:44 <kqr> I love how the most innocent little practical question can turn #haskell into a really cool discussion on What Things Really Are
07:27:50 <kqr> i've bookmarked those slides, looked interesting :)
07:28:05 <johnw> kqr: I have more links for you, if you are truly interested :)
07:28:09 <clrnd> how do I get a Word8 from a literal Char?
07:28:18 <johnw> :t Data.Char.ord
07:28:19 <lambdabot> Char -> Int
07:28:24 <clrnd> thanks johnw
07:28:27 <johnw> not all Char's will fit in a Word8
07:28:41 <johnw> kqr: https://www.youtube.com/watch?v=Zw9KeP3OzpU
07:28:49 <johnw> I was present in that meeting, which is when I learned this stuff :)
07:29:55 <kqr> johnw, definitely interested, though way, waaay too tired to dig into it at the moment
07:30:02 <johnw> I use recursion schemes in hnix
07:30:04 <kqr> but I've bookmarked that video too!
07:30:06 <johnw> but it's a trade-off
07:30:10 <tasker> Ok, can anyone suggest a way to make my stupid implementation of convolution using vectors faster? http://lpaste.net/118759
07:30:14 <johnw> there's more boilerplate, but your evaluators are dead simple
07:30:22 <Geraldus_> can someone help to convert NodeList (http://hackage.haskell.org/package/webkitgtk3-0.13.1.1/docs/Graphics-UI-Gtk-WebKit-DOM-NodeList.html) to list of Elements (or at least Nodes). Can't figure out how to do that
07:30:25 <tasker> (other than using fft ;p)
07:30:26 <johnw> so if you only ever need a single evaluator for a given structure, they are overkill
07:30:47 <johnw> if you need lots of evaluator, they can be awesome
07:30:57 <johnw> (and possibly a speed benefit)
07:33:38 <kqr> I'm interested mostly because it seems like something that would expand my view on things
07:34:00 <johnw> that it certainly will
07:34:08 <johnw> it's one piece of a *very* large puzzle
07:34:32 <johnw> in my opinion, the most profitable part of that piece comes from understanding how data structures in Haskell relate to initial algebras
07:34:42 <horny-sama> johnw: you know how if you do :t "hi" it will return "hi" :: [Char]
07:34:51 <johnw> horny-sama: sure
07:35:04 <horny-sama> I am just wondering how do you get ghci to display type string instead of [Char]
07:35:10 <kqr> I love those little, "hey, did you know if you think about this normal thing this way, you start seeing the connections between things you previously thought were completely disparate"
07:35:10 <johnw> ahh
07:35:21 <johnw> horny-sama: that's a great question!
07:35:26 <horny-sama> is it there no such thing as string like c
07:35:33 <horny-sama> where string is an char array
07:35:33 <horny-sama> :P
07:37:36 <horny-sama> and one more thing according to my textbook you don't need a explicit type declaration for functions and why do it
07:37:37 <horny-sama> :P
07:38:20 <steffen> Hi, Is there a way to generate a hoogle or hayoo database for my cabal project (or just Haskell project)?
07:38:29 <sx_> horny-sama: Well type aliases can have n:1 relations to a concrete type, but not the other way round. So you would have either to list all type aliases (which are potentially infinitely many) or just the concret type, which one do you think is more easy to do?
07:38:50 <dcoutts_> steffen: yes, cabal has hoogle support
07:39:07 <horny-sama> sx_: I honestly don't know
07:39:10 <mr-> sx_: haskell is a streaming compiler? :-)
07:40:11 <steffen> dcoutts: I mean, how can I hoogle all the toplevel functions in my project?
07:40:14 <horny-sama> I think geany will become my go to haskell compiler :P
07:40:28 <steffen> dcoutts: not how to add my project to hoogle
07:40:30 <sx_> horny-sama: Well, just listing the single concrete type that results from a type alias is the easiest way.
07:40:35 <sx_> mr-: what is that? :)
07:40:42 <horny-sama> ok
07:41:09 <dcoutts_> steffen: oh, no cabal just helps with making an index of all your installed libs. You'll have to check the hoogle docs to see if it can help with the exe you're working on
07:41:10 <sx_> horny-sama: If you want an extra type, you can always wrap in a newtype.
07:41:40 <steffen> dcoutts: okay, thanks
07:41:48 <horny-sama> hopefully I can wrap my head on haskell before feb 6 my haskell hw due date
07:42:13 <dcoutts_> steffen: there's c-tag like tools, and things like ghc-mod that help with symbol lookup within the project one is hacking ing
07:42:17 <dcoutts_> ing/on
07:42:33 <sx_> horny-sama: There are actually other implementations of string like data structures (e.g. Text. ByteString, which do not have a list type).
07:42:59 <horny-sama> sx_: interesting
07:43:11 <steffen> dcoutts: yes I have that, but sometimes I would like to search for functions within my project like I search functions on hoogle, by type
07:43:29 <sx_> horny-sama: The type system helps you in getting your thoughts right. That's the most important reason to type types, because the compiler is almost always right, but you/we are not.
07:43:47 <horny-sama> sx_: err
07:43:58 <dcoutts_> steffen: hoogle might help, you'd have to check the docs
07:44:43 <sx_> horny-sama: A static type system is one of the most important tools to sort out errors at compile time.
07:44:55 <horny-sama> ok
07:47:31 <ClaudiusMaximus> tasker: maybe adjust paddedSlice to have the (more common) unpadded case at the top; otherwise i think writing a lookupDefault function that returns 0 for out of range and a lookupReverse function that reverses indices might be quicker than V.++ and V.reverse, needs your own zipWith implementation though - also I think V.fromList is slow, maybe there is a V.enumFromTo
07:47:57 <kqr> horny-sama, the string type in haskell is actually called [Char] (which stands for list of char)
07:48:02 <tasker> ClaudiusMaximus: Awesome, thanks. I'll get to benchmarking.
07:48:07 <horny-sama> kqr: that sounds like c ish
07:48:09 <kqr> horny-sama, you can also write String in your code, but it gets translated to [Char] internally
07:48:10 <tasker> I've got no real experience doing highish performance haskell
07:48:14 <tasker> but it seems quite fun so far
07:48:28 <kqr> horny-sama, yeah, it's similar in some ways
07:48:41 <kqr> horny-sama, though haskell uses a list of char, while C uses an array of char
07:48:48 <horny-sama> on chapter 3 of learn your haskell and still have not teach you to write a program
07:48:51 <horny-sama> just ghci stuff
07:48:51 <horny-sama> :<
07:48:59 <kqr> horny-sama, yeah, that's a problem with learn you a haskell :(
07:49:22 <horny-sama> kqr: do they ever teach you to write a real program ?
07:50:44 <kqr> horny-sama, not sure... there's some of that stuff in chapter 9 it seems
07:51:12 <kqr> horny-sama, but that book isn't very good at teaching you to write real programs, and I don't know one that is either, unfortunately
07:51:36 <horny-sama> kqr: lol
07:51:48 <horny-sama> in chapter 4 it talks about syntax in functions
07:51:56 <clrnd> horny-sama, Real World Haskell maybe
07:51:57 <horny-sama> hopefully it will teach me to write real program
07:52:19 <horny-sama> clrnd: url?
07:52:33 <ClaudiusMaximus> tasker: also see V.backpermute, and see if specializing to Double or Complex Double or whatever (maybe use pragmas for that) gives a speedup, and finally try unboxed vectors
07:52:35 <clrnd> horny-sama, http://book.realworldhaskell.org/read/
07:55:19 <horny-sama> should I stick with learn you a haskell?
07:55:32 <arianvp___> hey
07:55:34 <arianvp___> how can I detect where an Exception <<loop>> happens?
07:56:25 <bernalex> horny-sama: if it's fun and you feel like you're learning, stick with it. if not, maybe look at something else.
07:56:54 <ClaudiusMaximus> arianvp___: my rubbish technique is -Wall and look for unused or shadowed variables...   otherwise +RTS -xc might help
07:57:03 <ClaudiusMaximus> @where rtsxc
07:57:03 <lambdabot> I know nothing about rtsxc.
07:57:05 <horny-sama> bernalex: I am learning haskell but it is not teaching me ghc
07:57:09 <horny-sama> just ghci
07:57:09 <horny-sama> :<
07:57:27 <arianvp___> horny-sama: patience!
07:57:40 <arianvp___> haskell programmers (at least I ) spend a lot of time in GHCi
07:57:41 <bernalex> horny-sama: I think that's mostly OK. but what I did when reading it was writing .hs, and :l-ing them into ghci
07:57:42 <arianvp___> :)
07:57:54 <horny-sama> arianvp___: I need to be square before feb 76 when the hw is due
07:57:55 <horny-sama> :p
07:58:09 <FireFly> There's a long way 'til february 2076 :P
07:58:19 * hackagebot endo 0.1.0.2 - Endomorphism utilities.  http://hackage.haskell.org/package/endo-0.1.0.2 (PeterTrsko)
07:58:28 <bernalex> yeah I think most people should be able to learn haskell in ~60 years
07:58:44 <ClaudiusMaximus> @where rts-xc
07:58:44 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
07:58:45 <horny-sama> bernalex: you can still put this into hs like factorial :: INteger -> Integer factorial n = product [1..n] and it will work?
07:58:56 <bernalex> horny-sama: sure
07:59:31 <bernalex> $EDITOR file -> write some haskell, close file -> ghci -> :load file
07:59:53 <bernalex> then you can modify the file and just :load again
08:00:41 <mr-> or :r(eload) :-)
08:00:51 <bernalex> ah yeah
08:02:37 <arianvp___> err
08:02:42 <arianvp___> I get the following error:
08:02:44 <arianvp___> the flag -prof requires the program to be built with -prof
08:02:46 <arianvp___> lol
08:02:55 <arianvp___> ????
08:06:11 <arianvp___> How do I enable profiling in Cabal?
08:06:40 <clrnd> arianvp___, you are gonna need profiling in your dependencies too
08:06:51 <clrnd> in cabal you add -prof to ghc-args
08:07:12 <arianvp___> ugh why aren't there any tutorials on tis kind of stuff :P
08:08:03 <barrucadu> Like this? http://nikita-volkov.github.io/profiling-cabal-projects/
08:08:30 <mauke\> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
08:22:30 <timwaagh> im new here. im trying to convert a php script but of course i run into trouble. how do you go about debugging on (windows, ghc, vim)  a function like
08:22:38 <lpaste> timwaagh pasted ‚Äúfunction_that_needs_debugging‚Äù at http://lpaste.net/118760
08:30:39 <hodapp> am I gonna have to write some kind of coroutine abstraction to be able to write this code sanely? bleeeargh.
08:30:54 <hodapp> Ivory + code generation + async C calls, I'm scared.
08:37:54 <benzrf> hodapp: pipes is coroutines o3o
08:38:20 <seagreen> Any suggestions on reducing redundancy in the build-depends sections of a .cabal file with a lot of executables? I've got a yesod project with a couple of test suites and utility executables, all of which share a lot of packages. Right now I have 4 very long build-depends sections that are all almost the same.
08:39:28 <hodapp> benzrf: this wouldn't be for Haskell runtime, though, it'd be to basically turn into C code myself via Ivory.
08:39:47 <hodapp> but I do need to learn about pipes.
08:40:01 <benzrf> pipes is neat
08:40:09 <hodapp> ARE
08:40:14 * hodapp runs
08:44:18 <johnw> knowing pipes is a very valuable tool in your toolbox
08:45:12 <hodapp> johnw: I will learn them soon, but probably won't be able to use them for this
08:45:25 <bananagram> whenever I run cabal update for the first time, it uses massive amounts of memory
08:45:33 <bananagram> around 400 megabytes
08:45:46 <johnw> bananagram: is that a problem?
08:46:08 <bananagram> yeah, I usually develop on my netbook which has 1GB
08:46:14 <johnw> you don't need to use cabal update
08:46:15 <NemesisD> my browser uses more memory than that on gmail sometimes :(
08:46:18 <int-e> johnw: it's a problem for many VPSs, too.
08:46:41 <johnw> use this instead: https://gist.github.com/e86e05f9e245f8c50520
08:46:52 <johnw> dropping the "| pv -s $size" part
08:47:06 <johnw> because that's actually all that cabal update really achieves
08:47:20 <bananagram> hm, okay
08:47:31 <bananagram> I'll store that for future use
08:47:45 <int-e> (then again, ghc can also gobble up tons of memory easily)
08:47:47 <NemesisD> johnw: interesting. does it parse it or anything or is it just holding the whole download in memory?
08:47:55 <johnw> good question
08:48:06 <johnw> i've never really understood why cabal update is slow
08:48:52 <horny-sama> I have a question when do you use print vs putStr?
08:48:59 <johnw> print implies "show"
08:49:05 <johnw> > putStr "foo"
08:49:06 <lambdabot>  <IO ()>
08:49:07 <johnw> > print "foo"
08:49:09 <lambdabot>  <IO ()>
08:49:09 <johnw> oh, duh
08:49:17 <johnw> teh former prints foo, the latter "foo"
08:49:57 <int-e> johnw: curious, where does $size come from? (one can just drop the pv part, of course)
08:49:57 <mr-> print = putStrLn . show
08:50:02 <horny-sama> lol
08:50:09 <int-e> (pv is not standard anyway)
08:50:10 <horny-sama> then print is shorter to type
08:50:15 <johnw> int-e: it's 0 for that download
08:52:00 <NemesisD> i think cabal update does store the file in memory
08:52:53 <NemesisD> it uses Network.Browser from the network package whose respone type is either doing lazy io trickery or loading the whole response: http://hackage.haskell.org/package/HTTP-4000.0.8/docs/Network-HTTP-Base.html#t:Response
08:53:24 <dcoutts> hmm, it should be using lazy io for writing it out
08:53:55 <dcoutts> it then does read it back, to make an index, but that should also be approx constant space
08:54:10 <dcoutts> would have to go profile to see what's going wrong
08:54:20 <dcoutts> probably a simple mistake somewhere
09:00:49 <spearman> is '\b' the only escape sequence for backspace? i'm getting the character "" from hscurses when trying to handle backspaces
09:00:56 <spearman> ''
09:00:58 <spearman> \
09:01:05 <spearman> bleh
09:01:17 <johnw> your terminal is sending DEL instead of BS
09:01:34 <hodapp> people tell me my terminal only sends BS >_>
09:02:09 <spearman> johnw: ah, thanks
09:02:23 <benzrf> > text "test\btest"
09:02:25 <lambdabot>  testtest
09:02:56 <fread2282> I have GHC.Generics deriving for ShowText that generates fast code, but takes a long time to compile (per instance), how can I speed it up?
09:04:20 <fread2282> or profile it at all
09:07:19 <ij> edwardk, In http://hackage.haskell.org/package/lens there's a link to "an introductory video on the style of code..." that links to skillsmatter.com, that doesn't let you see the video that doesn't exist unless you've logged in. Maybe it should be removed?
09:08:22 * hackagebot alea 0.3.2.0 - a diceware passphrase generator  http://hackage.haskell.org/package/alea-0.3.2.0 (rnhmjoj)
09:10:40 <EvanR-work> > '\b'
09:10:41 <lambdabot>  '\b'
09:11:04 <EvanR-work> > "a\bc"
09:11:05 <lambdabot>  "a\bc"
09:11:16 <glguy> ij: It merely requires an account to download the video, there are other videos if that's a problem for you
09:11:50 <nuttycom> Okay, I still can't seem to get my head around Control.Lens. I need a simple example for something like the following:
09:11:50 <nuttycom> newtype B = B A
09:11:50 <nuttycom> makeWrapped (or makePrisms???) ''B
09:11:50 <nuttycom> How can I then use the lenses/prisms generated to get [B] -> [A]  ?
09:12:37 <glguy> map (view _B) :: [B] -> [A]
09:12:53 <glguy> makePrisms ''B would make:   _B :: Prism' B A
09:13:42 <nuttycom> glguy: really? I've been using fmap (^. _B) but I assumed that, given the way that lenses generalize functors, that there would be a more natural way.
09:14:08 <fread2282> @type view (each._Wrapped)
09:14:10 <lambdabot> (Each s s s1 b, Rewrapped s1 b, Rewrapped b s1, MonadReader s m, Monoid (Unwrapped b), Unwrapped s1 ~ Unwrapped b) => m (Unwrapped b)
09:14:39 <fread2282> @type view (each._Unwrapped)
09:14:40 <lambdabot> (Each s s (Unwrapped s1) (Unwrapped s1), Rewrapped s1 s1, MonadReader s m, Monoid s1) => m s1
09:15:26 <nuttycom> That reminds me, where is the class (~) defined? I've not been able to find it.
09:15:27 <glguy> nuttycom: Lens isn't intended to replace normal functions completely like map, when it's the clearest way to implement something you're supposed to use it
09:15:49 <ahammel> @djinn (Maybe b) -> a -> Either a b
09:15:49 <lambdabot> f a b =
09:15:49 <lambdabot>     case a of
09:15:49 <lambdabot>     Nothing -> Left b
09:15:49 <lambdabot>     Just c -> Right c
09:16:00 <glguy> If you're using makeWrapped, then you have:  view _Wrapped :: B -> A :: B -> A
09:16:18 <glguy> (oh, accidentally doubled the type)
09:16:40 <ij> glguy, Where's the download btn?
09:17:21 <nuttycom> glguy: okay, thank you. Is there a good rule of thumb as to whether to choose makeWrapped or makePrisms for straightforward newtypes?
09:18:23 * hackagebot psqueues 0.2.0.0 - Pure priority search queues  http://hackage.haskell.org/package/psqueues-0.2.0.0 (JasperVanDerJeugt)
09:19:32 <glguy> ij: When you're logged in the video shows up on that page
09:20:53 <glguy> nuttycom: Personally I just only ever use makePrisms. I don't know if there is a generally accepted rule
09:21:31 <ij> glguy, Well, that's not what I get. http://i.imgur.com/97Kpj0b.png
09:22:01 <ij> And I tried to follow the vimeo link and it didn't work in vimeo either.
09:23:06 <glguy> ij: I don't know, but this is what it looks like for me: http://www.galois.com/~emertens/skillsmatter.png
09:23:34 <glguy> ij: Maybe you're using an OS or browser or something that they don't like?
09:23:34 * gds sees the same as glguy
09:23:48 <ij> hmmmm
09:23:49 * gds is using FF on slackware.
09:24:47 <geekosaur> Chrome on OS X, I get "Please log in to view this content.:
09:25:02 <geekosaur> (I am disinclined to create an account I'll never use for anything else, tbh.)
09:25:40 <gds> (Yeah, I'm already logged in -- I actually created an account to see that vid...)
09:25:49 <glguy> That's probably not an uncommon position, but it's still a useful video for people who want to learn more than they want to not create an account
09:26:28 <ij> that's odd, works in firefox
09:26:46 <gds> ij: What did it fail in?
09:27:15 <ij> no idea
09:27:31 <glguy> I think gds is asking which browser it didn't work in
09:27:40 <gds> Indeed i am -- sorry if unclear.
09:27:51 <ij> Oh, chromium.
09:28:07 * gds fires up chromium to see if that happens here too.
09:28:08 <sx_> Excellent talk.
09:28:30 <NemesisD> hey johnw you're a smartparens user right?
09:29:33 <johnw> not any longer
09:29:35 <johnw> it got annoying
09:29:50 <johnw> I was spending my time deleting pairs more often than my time was being saved
09:29:53 <gds> ij: FWIW, It works in my chromium too.
09:29:59 <ij> gds, Works in a new instance of chromium. :/ I'm just unlucky.
09:30:12 <raydlor> test
09:30:29 <glguy> Sorry raydlor , test failed
09:30:41 <raydlor> :-(
09:31:08 <NemesisD> damn. i'm not a power user so i don't have too many problems with it but one thing that really irks me is it seems to have trouble with multiline ghc comments/language pragmas and dumps an error about an unmatched expression into the minibuffer if your point is on {-#
09:32:55 <NemesisD> i think i may need to configure an sp-local-pair or something
09:32:57 <dfeuer> Has Daniel Fischer abandoned arithmoi? It kind of looks like he's not been responding of late, and Mi√´tek Bak has a clone on GitHub for bug fixes.
09:34:22 <athan> Anyone wanna give it a shot? http://stackoverflow.com/questions/28030118/reflecting-heterogeneous-promoted-types-back-to-values-compositionally
09:35:01 <athan> NemesisD: I'm lazy and just do them all one-line :P
09:35:10 <geekosaur> autoinstalled new version perhaps?
09:35:15 <geekosaur> (re chromium)
09:35:22 <geekosaur> probably broke flash or something
09:36:06 <hodapp> when is Flash not broken?
09:36:26 <NemesisD> athan: me too but i think language pragmas have to be inside {-# #-}
09:36:47 <athan> NemesisD: Yeah you're right, wait what's your error?
09:37:05 <athan> I just do `{-# LANGUAGE ... #-}; {-# LANGUAGE ... #-}`
09:37:14 <athan> I'm getting pretty good at typing that word fast
09:37:31 <NemesisD> athan: its an error in smartparens for emacs, it complains that there's an unmatched expression
09:37:44 <athan> oh shoot
09:37:47 <athan> yeah I'm not sure :\
09:40:38 <NemesisD> yep actually that fixed it: (sp-local-pair 'haskell-mode "{-#" "#-}")
09:41:41 <fikse> will someone please create a microframework around distributed-process?
09:42:08 <NemesisD> fikse: doing what?
09:44:35 <fikse> NemesisD: i don't understand your question
09:44:59 <NemesisD> fikse: i don't understand yours. microframework is a pretty vague term
09:45:17 <fikse> NemesisD: something like scotty or flask for python
09:45:46 <mauke\> oh, web?
09:45:52 <mr-> like scotty, for haskell?
09:46:10 <athan> I can't wait to get my cms done
09:46:16 <athan> SEO out the wazoo
09:46:37 <NemesisD> i'm not sure what that microframework would do
09:46:58 <hiptobecubic> fikse, scotty *is* for haskell.
09:47:08 <athan> So if Sets form a monoid with <nil, union>, could it also do so with <universe, intersection>?
09:47:20 <NemesisD> hiptobecubic: he means create a simple scotty-like API but for distributed-process i think
09:47:22 <hiptobecubic> athan, test it.
09:47:23 <fikse> mr-, hiptobecubic: i understand, my request was that someone write a framework like scotty on top of distributed-process
09:47:28 <fikse> that would be really nice
09:47:53 <athan> hiptobecubic: It's all metacircular-y, though :\
09:48:21 <athan> fikse: It will come eventually
09:48:28 <hiptobecubic> fikse, what would it do?
09:48:53 <mr-> athan: sure, if there was a universe
09:49:02 <fikse> hiptobecubic: make it easy to write fault tolerant web services
09:49:13 <athan> mr-: That's the crazy part
09:49:19 <athan> it would make quantification first-class
09:49:42 <athan> fikse: Scotty, on my machine
09:49:48 <athan> gets like 15k responses / sec
09:49:57 <athan> it's pretty friggin crazy
09:50:34 <indiagreen> what's the place to submit fixes for documentation for ‚Äúbase‚Äù?
09:50:49 <NemesisD> fikse: is there an existing version of this in erlang?
09:50:58 <athan> fikse: I'm trying to develop a suite of generic web tools, I really want a hardcore low-level front-end abstraction, so we can make fault-tolerant, constant memory web applications
09:51:04 <athan> but that might take like a year
09:51:14 <athan> WebMachine?
09:51:38 <athan> indiagreen: GHC Trac? :)
09:52:05 <fread2282> with text Builder, will (singleton 'a' <> fromString foo) or fromString ('a':foo) be faster? will (fromString foo <> singleton 'a') or fromString (foo++"a") be faster? in terms of compile time
09:52:45 <NemesisD> fread2282: benchmark it with criterion :)
09:53:06 <Welkin> athan: why bother doing that in the browser?
09:53:21 <fread2282> NemesisD: compile time speed
09:53:22 <Welkin> just write a native application
09:53:23 <athan> Welkin: I know, right? :\
09:53:35 <athan> Welkin: Availability :P
09:53:35 <arianvp___> T_T writing compilers is hard
09:53:43 <arianvp___> type-checker crashes if no main method is defined for some reason lel
09:53:56 <athan> like... mass availability
09:54:16 <indiagreen> athan: do I have to create a ticket? or generally, is it worth doing if the fix is small and I haven't ever contributed to <anything which isn't on Github> before?
09:54:46 <athan> indiagreen: I have no idea honestly. If it's just documentation, you might be able to find the file...
09:54:48 <athan> hmm
09:54:56 <Welkin> athan: network latency kills web applications for me
09:54:57 <Fuco> johnw: I would appreciate if you'd report your issues. :) A sensible out-of-the-box configuration isn't something smartparens does well (yet).
09:55:15 <athan> Welkin: Yeah, you've got to be productive with it
09:55:23 <Welkin> I didn't notice how bad it was until I compared the speed of the application running locally vs online
09:55:29 <athan> I really want the communications to be flexible but adapt to the setting
09:56:00 <athan> And it's not like _all_ the logic will be in the server
09:56:29 <Welkin> and stuffing an entire application into the browser is a horrible alternative
09:56:46 <athan> That's where I really need to do some work, I just need to somehow add a browser to some form of distributed-process like abstraction
09:56:57 <athan> Welkin: It's not that bad lol
09:57:02 <athan> you just gotta be smart
09:57:08 <NemesisD> Fuco: does smartparens include any local pairs for specific languages?
09:57:30 <fikse> NemesisD: you can look at the plug project for elixir
09:57:36 <NemesisD> Fuco: because out of the box it fails to parse language pragmas which can be kind of annoying. could be solved by the library including an sp-local-pair for 'haskell-mode
09:57:37 <athan> indiagreen: I actually would just create a ticket
09:57:40 <fikse> NemesisD: https://github.com/elixir-lang/plug
09:59:06 <athan> Are there any typeclasses for heterogeneous variants of the ones we know and love, like monoid?
10:01:17 <joness> is there a Language pragma that prevents loading of typeclass instances from Prelude? for example Functor instance for list
10:01:34 <NemesisD> hmm not sure if NoImplicitPrelude gives you that
10:01:50 <NemesisD> but i think you have to throw out the prelude then...
10:02:01 <joness> hmm yes
10:02:05 <NemesisD> what are you trying to do
10:02:43 <joness> to allow defining those instances manually for learning purposes
10:03:00 <NemesisD> just use a newtype
10:03:22 <NemesisD> newtype List = List [a], then define instances to your heart's content
10:03:25 * hackagebot indentation 0.2.0.2 - Indentation sensitive parsing combinators for Parsec and Trifecta  http://hackage.haskell.org/package/indentation-0.2.0.2 (AlekseyKliger)
10:04:05 <joness> that makes the code more verbose.. but i guess it still beats not having a single function from Prelude
10:04:36 <monochrom> for learning purposes, use a newtype or a new type class name. banning all of the Prelude is uneducational.
10:04:51 <NemesisD> if this is for educational purposed you cold also probably do type List a = [a] and use the TypeSynonymInstances extension
10:05:12 <monochrom> for example to practice writing Functor instances you can simply first define your own MyFunctor class.
10:05:20 <NemesisD> ah good point
10:06:17 <monochrom> I support the path of least resistance, but you really have to first know which path has really least resistance.
10:06:56 <SRPx> Since nobody answered, may I assume that there is no reliable way to extend a type with a new interface without rewriting a wrapper for every function? :(
10:08:02 <monochrom> what does "extend a type with a new interface" mean, in haskell?
10:08:06 <joness> I am curious, is there a way to resolve conflict if we have two modules that implement typeclass instance for the same type?
10:08:17 <dfeuer> carter, is there a version of bitvec around that really tries to work around aliasing issues for bit vectors that are mutated a lot?
10:08:25 <SRPx> monochrom: http://stackoverflow.com/questions/28016209/is-there-any-way-to-extend-data-vector-to-accept-2d-indices-without-having-to-a
10:08:31 <carter> @hackage bitvect
10:08:31 <lambdabot> http://hackage.haskell.org/package/bitvect
10:08:34 <carter> @hackage bitvec
10:08:34 <lambdabot> http://hackage.haskell.org/package/bitvec
10:08:39 <dfeuer> joness, yes, don't do that.
10:08:40 <monochrom> no, joness, unfortunately no, apart from banning one of the two moduels
10:08:42 <carter> dfeuer: what aliasing issues
10:08:59 <SRPx> monochrom: for example, mofidying the vector implementation to use polar coordinates instead
10:09:29 <dfeuer> carter, I'm not an expert like you, but if you're doing a bunch of reads and writes to adjacent bits, won't the CPU throw up its hands?
10:11:43 <osa1> I can have something like this in Cabal, right? `ghc-options:         -Wall -main-is MyModule.myFun`
10:11:47 <osa1> because it's giving a syntax error
10:12:07 <clrnd> osa1, cabal already has a main-is config entry
10:12:22 <dfeuer> If it's giving a syntax error, then you can't have it.
10:12:45 <dfeuer> The parser is never wrong: it always parses the language that it parses.e
10:12:51 <osa1> dfeuer: that doesn't allow me to specify main function thought
10:13:01 <osa1> ok I fixed it, minor problem with something else.
10:13:12 <osa1> s/thought/though
10:13:59 <alpounet> SRPx: what exactly are you trying to achieve in your case? it'll be simpler to reason on your concrete problem
10:15:55 <SRPx> alpounet: I was trying to extend data.vector.unboxed.mutable to use 2d coordinates. People suggested to just use other things, not vector, that already support it. I'm not really content with that answer since in other situations I might not be able to find something ready and must find myself needing to extend a user type. Also, even for this case, vectors have a better api compared to the suggestions
10:16:16 <SRPx> a library type*
10:16:43 <alpounet> SRPx: can't you do the usual 2D -> 1D transformation for indices?
10:17:36 <Fuco> NemesisD: if you have some useful haskell config, please start an issue. We can add smartparens-haskell.el for haskel specific config (as there is for latex, ruby etc...)
10:17:59 <SRPx> alpounet: yes, but I will have to write: "read (positionToIndex myPos) array" instead of the more obvious/readable "read myPos matrix"
10:18:22 <NemesisD> Fuco: cool. will do
10:18:37 <hiptobecubic_> SRPx, so wrap read?
10:19:14 <hiptobecubic_> read2D pos = read (posToIdx pos)  ?
10:19:22 <alpounet> SRPx: vector isn't that high-level a library, regarding indexing. either you write little wrappers for your particular use case, or you switch to something that supports "generic indexing" out of the box. if you come up with a solid design, a generic indexing machinery could be discussed/integrated for vector though :)
10:19:31 <SRPx> hiptobecubic_: hiptobecubic_ posToIdx needs the matrix width, though
10:20:02 <SRPx> hiptobecubic_: so, `read2D pos width = ...` and now I have: `read2D pos (width matrix) array` ?
10:20:30 <SRPx> instead of: read2D pos matrix
10:21:11 <hiptobecubic_> SRPx, you can specialize read2D inside your functions pretty easily though
10:21:18 <dfeuer> Er ... Is repa still alive? I see no recent activity, and there's a base==4.7 constraint on the package.
10:21:51 <SRPx> that is true, but I need to create a specialization everywhere ... I guess, I haven't think a lot about that
10:21:54 <hiptobecubic_> read2D w p = ....;   then later you'll have read = read2D (width matrix) in a where clause
10:22:23 <breadmonster> @src scanr
10:22:23 <lambdabot> scanr _ q0 []     =  [q0]
10:22:23 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
10:22:23 <lambdabot>     where qs@(q:_) = scanr f q0 xs
10:22:31 <SRPx> that doesn't sound realy much better imo :(
10:22:33 <ClaudiusMaximus> SRPx: or read2D :: Position2D -> (MatrixSize2D, Vector a) -> a   and pass around the tuples
10:22:53 <breadmonster> Interesting.
10:23:02 <hiptobecubic_> you'll have to do something like this because you need both pieces of information. Either that or you try to jam it into the types or you pass around the width with the matrix object
10:24:19 <SRPx> ClaudiusMaximus: so at this point I could just alias (MatrixSize2D, Vector a) to Matrix ... but now what then I need something like "map f matrix"? I'll have to do the opposite, "Matrix (dim matrix) (map f (getVector matrix))"
10:24:21 <SRPx> right?
10:27:35 <hiptobecubic_> SRPx, you have to accept that are no longer using the vector api. you are writing an abstraction on top of it and you'll have to implement the operations that you want
10:28:44 <SRPx> hiptobecubic_: http://lpaste.net/118768 so is this the way to go? Should I keep working on? It just raised all my alerts on dry
10:29:10 <hiptobecubic_> matmap f matrix = matrix { getVector = map f (getVector matrix) }   or something  (this is starting to look like you should use lens)
10:29:24 <SRPx> there are 4 huge apis to wrap around ... I'm not sure how to proceed ... I mean, not for this case, since I will use array, but I'm not sure what I'd do if there wasn't it...
10:30:09 <lifter> Is it possible to write numeric literals in binary?
10:30:26 <indiagreen> lifter: I think there's an extension
10:30:51 <indiagreen> {-# LANGUAGE BinaryLiterals #-}
10:31:01 <lifter> oh neat thanks
10:31:18 <fread2282> how can I get GHC to not insert patError when matching on Int# (from comparison primops)?
10:38:26 * hackagebot autonix-deps 0.2.0.0 - Library for Nix expression dependency generation  http://hackage.haskell.org/package/autonix-deps-0.2.0.0 (ThomasTuegel)
10:38:28 * hackagebot autonix-deps-kf5 0.2.0.0 - Generate dependencies for KDE 5 Nix expressions  http://hackage.haskell.org/package/autonix-deps-kf5-0.2.0.0 (ThomasTuegel)
10:38:29 <hodapp> huh, what I am dealing with is almost more 'continuation' than it is coroutine - I think
10:38:44 <hodapp> however I doubt that it is one that Cont/ContT can help me with
10:39:23 <hodapp> as it is not properly Haskell functions it's being applied to, but a C procedure type that Ivory uses... albeit, one that one can treat similarly
10:43:24 <phaazon> http://stackoverflow.com/questions/28020899/profiling-an-application-on-windows-with-cabal-ghc
10:43:28 <phaazon> if you haven‚Äôt see it yet
10:43:40 <phaazon> may you have any clue, please contribute!
10:47:53 <fread2282> GHC.Generics is generating simpl like http://lpaste.net/287817200297836544 how can I get it to optimize away the head (conName c)   (case GHC.Generics.$fConstructorBool2 of) in core?
10:48:45 <fread2282> it's from   (if head (conName c) == ':' then foo else bar)
10:55:51 <blueonyx> hi, why are there so much less operations for immutable vectors in Data.Vector? is it safe to unsafeFreeze >>= operate >>= unsafeThaw?
10:56:31 <dfeuer> blueonyx, yes, that should be safe, I believe, but look at Data.Vector.Mutable.
10:56:33 <glguy> fread2282: You'll probably need to patch GHC to generate the proper inlinable pragma on the derived generics code. I don't think there's much you can do
10:57:20 <dfeuer> blueonyx, also, think very hard about using boxed vectors. Usually you want them unboxed.
10:57:25 <dreixel> fread2282: glguy is probably right
10:57:33 <dreixel> though you could just provide your own instance of Generic, for testing.
10:57:48 <blueonyx> dfeuer: yea but its the same for Data.Vector.Unboxed vs Data.Vector.Unboxed.Mutable
10:58:13 <dfeuer> blueonyx, yeah, what function do you want from Data.Vector that's not in Data.Vector.Mutable?
10:58:27 * hackagebot rng-utils 0.2.1 - RNG within an MVar for convenient concurrent use  http://hackage.haskell.org/package/rng-utils-0.2.1 (DougBeardsley)
10:58:37 <blueonyx> dfeuer: folds, filters,...
10:59:00 <glguy> fread2282: I think that the issue is actually due to the way string literals work in GHC
10:59:26 <glguy> fread2282: Even if you locally define a string constant and locally define a head function and mark everything for inlining
10:59:31 <glguy> you still get the pattern match
11:00:47 <lpaste> glguy pasted ‚Äústring literals‚Äù at http://lpaste.net/118771
11:00:50 <glguy> fread2282 ^
11:01:11 <dfeuer> blueonyx, folds don't usually produce vectors, and filtering is a bit awkward for mutable vectors. The library probably should offer an in-place filter, but it doesn't.
11:01:26 <fread2282> :(
11:02:43 <spearman> anyone have an idea of why when i use wAddStr on a string (HSCurses library), i get quotes between all the characters? like: 'a''b''c''d'
11:02:59 <glguy> fread2282: Profiling is showing this head function is the slow spot?
11:03:00 <tasker> I posted some code at https://codereview.stackexchange.com/questions/78013/optimissing-a-1d-convolution-in-haskell-using-data-vector if anyone fancies helping me optimise it!
11:04:43 <fread2282> glguy: benching shows that getting ghc to generate a top-level thunk makes it faster, so yes
11:04:51 <spearman> i can also call waddch on a single character and it works...but if i mapM over a string the quotes reappear
11:06:44 <glguy> https://hackage.haskell.org/package/ghc-prim-0.3.1.0/docs/src/GHC-CString.html unpackCString# is intentionally NOINLINE, but here's the relevant code
11:07:57 <Denommus> why is everybody suddenly into lenses now?
11:08:24 <glguy> Suddenly?
11:12:27 <clrnd> I'm not into them
11:16:02 <Cale> Who is everybody? :)
11:17:12 <bitemyapp> I can't get Cabal to rebuild my add-source'd dependency.
11:17:22 <bitemyapp> https://github.com/haskell/cabal/issues/2378 any ideas?
11:17:50 <bitemyapp> I also can't get sandbox hc-pkg to --force unregister the add-sourced dependency so I can reinstall it from scratch: https://github.com/haskell/cabal/issues/2379
11:18:00 <bitemyapp> deleting and reinstalling the sandbox will take a really long time (Yesod & lens)
11:18:12 <johnw> Yesod & lens, that's like saying Hackage
11:18:25 <Denommus> I read about lenses all the time on reddit and SO now
11:18:27 <bitemyapp> har har
11:19:24 <ahammel> Is there a maybeToEither function kicking around somewhere?
11:19:36 <ahammel> as in maybeToEither :: a -> (Maybe b) -> (Either a b)
11:19:40 <bitemyapp> @ty maybe
11:19:42 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:19:48 <bitemyapp> ahammel: fold the Maybe value.
11:19:53 <johnw> ahammel: there's a version of it in the 'errors' package
11:19:58 <johnw> called "notE"
11:20:00 <johnw> note
11:20:19 <bitemyapp> ahammel: http://hackage.haskell.org/package/errors-1.4.7/docs/Control-Error-Util.html#v:note
11:20:25 <bitemyapp> note a = maybe (Left a) Right
11:20:27 <bitemyapp> fold the Maybe.
11:20:35 <bitemyapp> johnw: do you use errors or either?
11:20:43 <johnw> I use either
11:21:11 <bitemyapp> johnw: good.
11:21:30 <glguy> Data.Foldable.foldr (const . Right) . Left :: a -> Maybe b -> Either a b
11:21:47 <glguy> (maybe not ideal, but it worked ^_^)
11:21:52 <johnw> heh
11:21:54 <johnw> clever
11:22:17 <johnw> :t maybe (Left a) Right
11:22:19 <lambdabot> Maybe b -> Either Expr b
11:22:35 <johnw> :t \a -> maybe (Left a) Right
11:22:36 <lambdabot> a -> Maybe b -> Either a b
11:22:57 <glguy> that one's actually worth using :)
11:23:24 <johnw> it's the definition for "note" in errors :)
11:23:25 <ahammel> 'maybe'  looks like what I was looking for, thanks
11:24:08 <ahammel> Although I'm not sure it wouldn't be better to just write a 'maybeToEither' with pattern matching
11:24:40 <johnw> ahammel: if you need it a lot, then yes
11:25:00 <johnw> some things are missing from the Prelude simply because people haven't wanted them enough yet
11:25:02 <hexagoxel> bitemyapp: so your package contains library + non-library?
11:25:20 <bitemyapp> hexagoxel: app add-source'd a library.
11:25:26 <bitemyapp> hexagoxel: trying to rebuild app because library changed
11:25:35 <bitemyapp> hexagoxel: it refuses because it's being a dick.
11:25:36 <int-e> johnw: there's also a very strong opposition to extending the Prelude further.
11:25:59 <johnw> yes, with reasno
11:25:59 <hexagoxel> bitemyapp: `cabal sandbox hc-pkg -- --force unregister frontrow-entities`
11:26:02 <glguy> Just one more waffer thin function?
11:26:07 <bitemyapp> hexagoxel: gerd dermert.
11:26:14 <bitemyapp> hexagoxel: let me give that a whirl.
11:26:43 <bitemyapp> hexagoxel: that worked, thanks.
11:27:10 <hexagoxel> bitemyapp: it has a reason i added all those optional `--` to the documentation :D
11:27:31 <hexagoxel> (in `cabal help sandbox`)
11:27:32 <bitemyapp> hexagoxel: where?
11:27:37 <bitemyapp> I didn't see it
11:27:55 <bitemyapp>  cabal sandbox hc-pkg        [FLAGS] [--] COMMAND [--] [ARGS]
11:27:58 <bitemyapp> hexagoxel: ^^ you mean that?
11:28:02 <hexagoxel> yes
11:28:09 <bitemyapp> hexagoxel: that totally flew under the radar for me. An example would've been nice :(
11:28:14 <bitemyapp> hexagoxel: thanks for adding that though.
11:28:19 <lpaste> jmcarthur pasted ‚ÄúAn alternative representation for pipes‚Äù at http://lpaste.net/118775
11:28:28 * hackagebot simple-get-opt 0.1.0.0 - A simple library for processing command-line options.  http://hackage.haskell.org/package/simple-get-opt-0.1.0.0 (IavorDiatchki)
11:28:40 <jmcarthur> ^^ shared just for those interested, because i'm probably going to put it away soon
11:28:54 <bitemyapp> hexagoxel: thank you for your help :)
11:29:49 <hexagoxel> bitemyapp: np; agreed reg. lack of examples; it is on my to-do list somewhere..
11:30:53 <jmcarthur> however, if somebody manages to address either of the comments i put in there, i'd be interested to hear about it
11:32:57 <hexagoxel> bitemyapp: btw i sometimes succeed by forcing an install of an add-source dep by `cabal install $DEP`
11:33:43 <hexagoxel> no idea if that advice was applicable here
11:35:54 <dfeuer> @ask edwardk Are you planning to add any kind of fusion rules to your streams package?
11:35:54 <lambdabot> Consider it noted.
11:35:55 <bitemyapp> hexagoxel: I tried that, it didn't work.
11:36:17 <bitemyapp> hexagoxel: Also this is what happened after I install'd the dep post-unregister: https://github.com/haskell/cabal/issues/2335#issuecomment-70548064
11:36:28 <edwardk> dfeuer: hadn't thought about it. they could support a form of stream fusion
11:36:34 <edwardk> well, most of them anyways
11:36:37 <edwardk> but it'd be a lot of work
11:37:01 <dfeuer> edwardk, they could also support the other sort. No idea which would be better for the ways they're used.
11:37:06 <edwardk> i'd say this, if such a patch landed on my doorstep i'd probably take it ;)
11:37:11 <dfeuer> Heh.
11:37:28 <x77686d> I'm trying to be more precise in my slides for a class.  Are variables bound to values or are values bound to variables? The 2010 report uses the former but LYAH uses the latter.
11:37:46 <edwardk> x77686d: i'd say the former
11:38:19 <hexagoxel> bitemyapp: and post-configure, i presume?
11:38:41 <sebastianrkg> how would I convert from Data.Text.Internal.Text to Data.Text.Text?
11:38:45 <bitemyapp> hexagoxel: doing another configure to see what it does.
11:38:48 <Black0range> Hello! How do I turn a number to a ByteString such that 2015 => "2014"
11:38:54 <dfeuer> edwardk, also, where is this Foldable1 class?
11:39:00 <glguy> sebastianrkg: You don't, it just reports the Internal name because that's where the type is actually defined
11:39:10 <glguy> sebastianrkg: It is re-exported as Data.Text
11:39:12 <glguy> (.Text)
11:39:15 <dfeuer> Oh, found it.
11:39:20 <dfeuer> semigroupoids.
11:39:27 <x77686d> edwardk: Thx!  Anybody else?
11:39:50 <Sayuri-ue> guys
11:40:00 <bitemyapp> hexagoxel: that was it.
11:40:05 <Sayuri-ue> some info on a guy hes a annoying person so if you live nearby him beat him up http://pastebin.com/5hBL8baq
11:40:27 --- mode: ChanServ set +o glguy
11:40:35 --- mode: glguy set +b *!*@188.53.225.158
11:40:37 <dfeuer> Mmmhmmm.
11:40:40 <hexagoxel> bitemyapp: well i certainly consider this a bug, when cabal does not detect it needs a reconfigure
11:40:41 --- kick: Sayuri-ue was kicked by glguy (Your behavior is not conducive to the desired environment.)
11:40:51 --- mode: glguy set -o glguy
11:40:57 <sebastianrkg> glguy: That's what I would think, but I'm getting an error "Couldn't match type ‚Äò[text-1.1.0.0:Data.Text.Internal.Text]‚Äô with ‚ÄòText‚Äô"
11:41:12 <sebastianrkg> And I'm not importing the Lazy version, so I don't think it's that either
11:41:13 <glguy> sebastianrkg: That means you're trying to use the type across different packages
11:41:25 <glguy> sebastianrkg: Check your ghc-pkg list, you probably installed too many copies of text
11:41:28 <Black0range> Sayuri-ue: You're seriously asking the Haskell changell to beat someone up because you think he is anoying?
11:41:35 <bitemyapp> hexagoxel: documented this in the GH issue. Thanks for your help. Tremendous.
11:41:48 <sebastianrkg> glguy: Okay, I'll try it out. Thanks
11:41:52 <bitemyapp> hexagoxel: I need to write a "flight rules" for Cabal and Cabal sandboxes. Yeesh.
11:42:05 <sebastianrkg> What's up with Haskell fight club guy, why would you come here for that
11:42:30 <Black0range> No one knows how to do number to Bytestring?
11:43:29 * hackagebot AbortT-transformers 1.0.1.1 - A monad and monadic transformer providing "abort" functionality  http://hackage.haskell.org/package/AbortT-transformers-1.0.1.1 (GregoryCrosswhite)
11:44:40 <pavonia> Black0range: What do you mean by number to ByteString?
11:44:50 <Black0range> 123 => "123"
11:44:56 <glguy> Black0range: Depending on what you mean (kind of a weird way to phase that) http://hackage.haskell.org/package/bytestring-0.10.4.1/docs/Data-ByteString-Builder.html#g:11
11:44:59 <dfeuer> edwardk, I'm playing with Melissa O'Neill's famous prime sieve implementation, and several places she uses lists would more naturally be streams. The outer loop could be fused away by any fusion method. The inner streams, less fortunately, would probably be better represented as pairs of unboxed numbers.
11:45:09 <sebastianrkg> pack . read?
11:46:43 <Black0range> pack . show is a way but it is not optimal
11:47:59 <dfeuer> Is there an efficiency advantage to adding Int64 to Int64 rather than Int32 to Int64?
11:48:45 <Black0range> well int 32 takes less ram
11:48:48 <Black0range> thats about it
11:50:04 <darkroom> :type let rep = print "Repeating" >> r
11:50:09 <dfeuer> Well, I know that, Black0range. The question is whether I will take a hit using  fromIntegral (foo ! n) + m  when foo is an unboxed vector of Int32 and m is an Int64.
11:50:19 <darkroom> > :type let rep = print "Repeating" >> r
11:50:20 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
11:50:49 <glguy> darkroom: The problem is you defined "rep" and then used "r"
11:50:53 <darkroom> > :type let rep = print "Repeating" >> rep
11:50:55 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
11:51:09 <darkroom> still didnt work?
11:51:11 <glguy> and now you need to use an "in" to say what you want to use that new name for
11:51:19 <athan> Is there another name for ($)? I was thinking "_broad_ function application"
11:51:40 <glguy> let rep = print "Repeating" >> rep in rep -- for example
11:52:01 <darkroom> > :type let rep = print "Repeating" >> rep in rep
11:52:02 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
11:52:24 <glguy> The > is for evaluation of an expression, :t is for printing the type of an expression
11:52:29 <glguy> They are different commands
11:52:35 <int-e> dfeuer: I wouldn't expect a difference (except possibly from the reduced memory footprint of the smaller array), but as usual benchmarks are the only way to be certain
11:52:35 <athan> @type fix
11:52:36 <lambdabot> (a -> a) -> a
11:52:58 <athan> (sorry) I'll go this way ->
11:53:16 <darkroom> glguy: when i run let rep = print "rep" >> rep in ghci it works
11:53:28 <dfeuer> int-e, thanks.
11:53:30 * hackagebot rosa 0.1.3.0 - Query the namecoin blockchain  http://hackage.haskell.org/package/rosa-0.1.3.0 (rnhmjoj)
11:53:30 <darkroom> glguy: then when i try to get the type signarute it returns IO b
11:53:36 <darkroom> what is that b?
11:53:42 <glguy> GHCi 's prompt is like you're writing in a large "do" notation block
11:53:56 <glguy> b is whatever you want it to be, it's unconstrained
11:54:04 <glguy> You can tell it's a variable because it is lowercased
11:54:08 <Black0range> dfeuer: that I can not say. I do not know what haskell does internally there. My guess would still be that Int32  is ever so slighty quicker
11:54:27 <darkroom> glguy: but it will never return a value?
11:55:05 <int-e> dfeuer: (assuming the array is unboxed. if it's boxed then there's no reason at all to prefer Int32, I think.)
11:55:06 <glguy> it will never stop executing, so it doesn't matter what type it finishes with
11:55:19 <dfeuer> int-e, yeah, I knew that part. I'm talking unboxed.
11:55:21 <darkroom> glguy: alright thanks
11:57:47 <d12frosted> any optparse-applicative experts?
11:59:39 <glguy> d12frosted: You should always just ask your actual question
11:59:51 <glguy> Unless you're just wondering if experts exist
11:59:54 <MP2E> lol
11:59:57 <d12frosted> glguy: oh, ok
12:00:22 <Thulsadum> if i have an algebraic data type, which happens to be a list of alternative data constructors in record syntax, there is no convenient way to pattern match just against the constructor name (i.e. ignoring all fields), is there?
12:00:25 <glguy> That way if someone knows the answer they can speak up, expertise varies
12:00:52 <jmcarthur> dfeuer: conversions will not really hurt you. the space savings of a Vector Int32 over a Vector Int64 often result in better performance due to cache effects. the arithmetic operations for Int32 are not any better than for Int64 when using the native ghc backend, but i think Int32 can be more efficient when using the llvm backend
12:01:07 <shachaf> Thulsadum: case ... of A{} -> ...; B{} -> ...
12:01:32 <Thulsadum> shachaf: ah, this makes my day. thank yoy :D
12:01:35 <Thulsadum> *you
12:02:08 <bricked> http://lpaste.net/118778
12:02:25 <d12frosted> well, i am working on command line application; and it expects args as `my_app PROG CMD CMD_ARGS`. So actually my appication contains few 'progs', every progs has it's own set of commands, and every command has it's own arguments. So wanted to ask, if it's actully good to use optparse-applicative in suhc situations? Or maybe some alternatives?
12:02:36 <bricked> ^^ why does ghci not throw an error messae when I do let One=Two?
12:02:37 <d12frosted> glguy: yeah, my bad :D
12:03:07 <sebastianrkg> So xml-conduit uses an outdated Data.Text...
12:03:24 <sebastianrkg> That was my actual problem
12:03:29 <sebastianrkg> but unsure what to do about it
12:03:30 <d12frosted> I am trying to get things working using subparsers, but help messages doesn't work quite as I excpected.
12:05:00 <ClaudiusMaximus> bricked: try 'let a@One = Two' ; and then see what happens when you use 'a' - without a name to use ghci doesn't care that the pattern doesn't match, because it's unused.  also try ':set -XBangPatterns' and 'let !One = Two'
12:06:54 <bricked> what does @ do?
12:07:00 <d12frosted> what I have: PROG is defined as sum data type (something like data PROG = Prog1 | Prog2 | ...), the same with commands: (data Prog1CMD = P1Cmd1 | P1Cmd2 | ... and so on for every prog). And I also have parsers for every type with different metavars and help messages. But when `my_app -- help` it shows only available progs. It's actually not bad. But when I do something like `my_app prog1 --help` it prints
12:07:02 <d12frosted> error (--help is not supported) and prints usage (like `my_app prog1 PROG1_CMD`)
12:08:50 <d12frosted> I tried defining ProgNCMD using hsubparsers, but it doesn't work anyway. Am I missing something?
12:08:58 <d12frosted> Sorry for big message :D
12:09:27 <jmcarthur> bricked: let One = Two says you want to pattern match on Two. that pattern match would fail (since One doesn't match Two), except that since you aren't demanding the result it is never evaluated
12:10:19 <jmcarthur> bricked: @ allows you to name a value you are pattern matching on at the same time that you are pattern matching some internal structure. i'll demonstrate:
12:10:42 <jmcarthur> > let f a@(b, c) = (a, b, c) in f (1, "foo")
12:10:44 <lambdabot>  ((1,"foo"),1,"foo")
12:11:18 <jmcarthur> bricked: ^^ so in f, a is the entire tuple, b is the fst component, and c is the snd component
12:23:31 * hackagebot alea 0.3.3.0 - a diceware passphrase generator  http://hackage.haskell.org/package/alea-0.3.3.0 (rnhmjoj)
12:25:09 <sebastianrkg> What is everyone's favourite XML-selection library, xml-conduit? HXT-Xpath?
12:28:31 * hackagebot SimpleLog 0.1.0.3 - Simple, configurable logging  http://hackage.haskell.org/package/SimpleLog-0.1.0.3 (AndrasSlemmer)
12:29:07 <NightRa> It's so wired to read FP papers predating Haskell which use some wired languages such as KRC and HOPE
12:29:27 <NightRa> With a Pascal-style syntax
12:30:38 <johnw> ah, weird; for a second, I thought you meant that it was really exciting :)
12:30:55 <evilptr> wow! 15K users on #haskell... First time around. Just starting out...
12:31:03 <hpc> 1/5k
12:31:07 <hpc> 1.5k rather
12:31:17 <hpc> 15k would be O.O
12:31:24 <johnw> do I hear 1%5k?
12:31:24 <evilptr> I forgot a comma
12:31:28 <clrnd> jaja
12:31:29 <hpc> :P
12:31:49 <evilptr> would be grat with 15K though
12:31:53 <evilptr> grate
12:31:56 <Pamelloes> I once was in an irc channel with 15k people in it.... It didn't work so well
12:31:56 <evilptr> great
12:32:20 <evilptr> You see, my fingers are slipping today
12:32:36 <NightRa> Pamelloes: What channel?
12:32:58 <Pamelloes> NightRa: It was on another server. It was corresponding a debut of a much anticipated animation
12:33:06 <evilptr> probably #ubuntu
12:33:09 <Pamelloes> *It corresponded with
12:33:52 <Pamelloes> It was fun, but when the animation ended the channel reached around 300 messages a second. It was a unique experience.
12:34:58 <bricked> where is haskell used outside the desktop?
12:35:05 <MitchellSalad> the laptop
12:35:17 <Pamelloes> The cloud!
12:35:21 <MitchellSalad> the tablet
12:35:38 <Pamelloes> Where is Reader located?
12:35:52 <NightRa> There are some attemps for using it for modeling hardware
12:36:41 <clrnd> any idea why wai is so far down here: https://www.techempower.com/benchmarks/ ?
12:36:53 <evilptr> I'm watching videos by Erik Meijer, and he's starting to get on my nerves so I needed a little break. But good intro to Haskell I believe...
12:45:45 <dgpratt> evilptr, I find Erik to be...enigmatic
12:47:20 <dgpratt> but he's probably the person most responsible for getting me interested in Haskell
12:47:31 <Pamelloes> Currently I have a type (a,b). What are the advantages to converting it into WriterT b Identity a?
12:47:50 <Pamelloes> *Advantages and disadvantages
12:48:06 <clrnd> Pamelloes, well it gives you the ability to ... write to it
12:49:32 <Pamelloes> On second thought, I should probably use Reader...
12:50:28 <Pamelloes> Regardless, is it more idiomatic to use a monad instead of a tuple?
12:51:39 <benmachine> Pamelloes: it depends what you are using it for
12:52:49 <benmachine> Pamelloes: I think just-tuples are often fine, I'd think this even more if I could remember where the Monad instance was
12:53:11 <Pamelloes> In my current case I have (BitSeries,Primitive). Where BitSeries is a fixed set of data and Primitive is one interpretation of the data. I have a variety of methods for switching the type of Primitive without changing the BitSeries.
12:54:23 <Pamelloes> I created the tupled type before reading about monad transformers, but now it seems like using Reader BitSeries Identity Primitive might be better.
12:55:59 <evilptr> dgpratt, Yes. That sounds like a good word for it. ;-)
13:01:39 <srhb> Pamelloes: The advantage you get from reader is not having to pass your BitSeries explicitly
13:02:15 <Pamelloes> srhb: Hm, I don't think I'll rewrite any time soon...
13:04:35 <Factionwars> Ohai there
13:04:42 <Pamelloes> HI!
13:04:47 <Factionwars> Somebody up for a small question regarding some code?
13:05:25 <shachaf> I only answer questions about questions regarding code.
13:05:41 <Factionwars> Kewl :)
13:05:43 <shachaf> But maybe if you ask your real question people can see it and decide whether to answer.
13:06:02 <shachaf> Rather than volunteering to help with something without knowing what it is.
13:06:46 <Factionwars> I was wondering if in this piece of code http://pastebin.com/gLkFHhAN i can combine the 2 functions so i don't have to do the same thing twice actually.
13:06:50 <Pamelloes> shachaf: Is this question about questions idiomatic, or should I convert it to applicative style? "do {print "Can I haz some help with this question?";}
13:07:46 <srhb> Factionwars: What's h?
13:08:07 <Factionwars> It's a linear function who returns y of x
13:08:19 <Factionwars> h x = 1*x
13:08:21 <srhb> Factionwars: Because it look like sum . map (\(a,b) -> a-b)
13:08:35 <shachaf> Factionwars: Why not difference [] = 0?
13:09:00 <Factionwars> woiw
13:09:03 <Factionwars> Okay
13:09:06 <Factionwars> Thanks shachaf
13:09:19 <srhb> Oh I forgot the square
13:09:38 <shachaf> Factionwars: But you're still probably better off using sum or something because of strictness issues.
13:09:41 <Factionwars> I did not know (x:xs) could still match to a list with length 1
13:09:43 <srhb> sum . map (\(a,b) -> (h a - b)^2)
13:09:51 <srhb> Factionwars: In that case xs is []
13:09:57 <shachaf> sum [(h x - y)^2 | (x,y) <- xs]
13:10:25 <Factionwars> Yes that comprehension looks good
13:10:34 <Factionwars> I was mostly using this to get a mental image.
13:10:36 <Factionwars> Thanks !
13:10:53 <srhb> also it should clearly be xys, not xs. :-)
13:11:56 <d34df00d> Hi!
13:12:15 <d34df00d> Is there something like iterateUntilM (in Control.Monad.Loops), but that rather resembles `do {} while` than plain `while`?
13:12:38 <d34df00d> I need the first step to always happen, and checking the initial "null" value always aborts it.
13:15:56 <quchen> d34df00d: start >>= iterateUntilM p f?
13:16:14 <phaazon> what‚Äôs the default -O option passed to ghc in cabal?
13:16:19 <phaazon> -O only or -O2?
13:16:21 <d34df00d> quchen: yeah, I have something similar to this in my code now, but was just wondering if there is already something off the shelf.
13:16:41 <quchen> phaazon: -O. -O2 is rarely worth the increased compilation time, and it's not recommended as a default.
13:17:19 <quchen> phaazon: When your benchmarks show -O2 is beneficial then enable it, but don't do it without good reason.
13:17:28 <srhb> quchen: Really? Does cabal always pass an optimization flag by default?
13:17:42 <phaazon> quchen, I have issue with my code
13:17:45 <phaazon> I‚Äôd like to profil it
13:17:54 <phaazon> but I have an error :(
13:18:04 <phaazon> http://stackoverflow.com/questions/28020899/profiling-an-application-on-windows-with-cabal-ghc
13:20:06 <quchen> srhb: The "optimization" flag in cabal.config can specify 3 optimizations as far as I know: 0/false, 1/true, 2. Those are O0, O1, and O2.
13:20:09 <horny-sama> need some help with updating my ghci to the lastest one on fedora
13:20:10 <jmcarthur> quchen: whether -O2 is worth it is pretty subjective. for me it's usually not worth it during normal development, but if i'm optimizing or deploying/installing, then i use it.
13:20:20 <horny-sama> I mean my fedora default one is using 7.6.3
13:20:28 <srhb> quchen: Right, just wondering about the default.
13:20:36 <srhb> quchen: I would have assumed it was the same as the GHC default
13:20:43 <srhb> (ie. -O0_
13:21:02 <quchen> jmcarthur: Right, if you're building an executable for standalone use and have the time -O2 is fine. But if you've got a long-build dependency the O2 might be annoying.
13:23:50 <quchen> srhb: My cabal.config has the setting untouched and cabal -v3 passes -O
13:23:59 <srhb> Righto.
13:24:20 <shachaf> My ~/.cabal/config sets optimization to 2
13:24:24 <quchen> Build log of DList in a sandbox, line 405: http://lpaste.net/118785
13:26:11 <horny-sama> knock knock anyone here familiar with ghc?
13:27:11 <clrnd> with fedora you mean
13:27:28 <jmcarthur> horny-sama: this is more of a fedora question than a ghc question, isn't it?
13:27:52 <horny-sama> jmcarthur: not really considering most platiforms does not come with the latest ghc
13:28:13 <clrnd> horny-sama, I use a ppa with ubuntu, I guess fedora has something simillar
13:28:22 <jmcarthur> horny-sama: what is the normal mechanism for getting more up to date packages on fedora?
13:28:33 <horny-sama> yum update?
13:28:41 <geekosaur> you might check COPR
13:28:49 <horny-sama> jmcarthur: the latest one is not on the fedora package list
13:28:53 <horny-sama> geekosaur: copr?
13:28:56 <clrnd> horny-sama, you can always build it http://new-www.haskell.org/downloads/linux
13:29:03 <geekosaur> it's sort of PPAs for fedora/rhel/centos
13:29:17 <ezyang> Is there a way to "touch" a Haskell pointer, so that it is kept live? (Something like StablePtr but more efficient)
13:29:23 <geekosaur> https://copr.fedoraproject.org/
13:29:36 <clrnd> never ehard of copr, looks like a great idea that works like crap in real life
13:30:07 <johnw> ezyang: if anyone would know, I'd've thought it would be you :)
13:30:09 <jmcarthur> horny-sama: this seems to indicate it may be possible to get some unstable package for the latest ghc somewhere? https://apps.fedoraproject.org/packages/ghc/undefined/packages/
13:30:21 <jmcarthur> silly link
13:30:35 <jmcarthur> nevermind, i don't know how to link to things on this web site...
13:30:39 <clrnd> horny-sama, https://copr.fedoraproject.org/coprs/fulltext/?fulltext=ghc
13:31:28 <horny-sama> clrnd: I am trying to figure out how to add the respo to it
13:31:38 <horny-sama> so I don't have to compile it myself
13:31:41 <clrnd> feels similar to Arch's yaourt
13:31:52 <jmcarthur> clrnd: you mean aur?
13:32:07 <clrnd> well the command was yaourt, iirc
13:32:09 <clrnd> but yeah
13:32:22 <jmcarthur> that's just one of many commands, actually
13:32:22 <horny-sama>  dnf copr enable petersen/cabal-install-1.18
13:32:22 <horny-sama> No such command: copr. Please use /usr/bin/dnf --help
13:32:23 <horny-sama> It could be a DNF plugin command.
13:32:36 <jmcarthur> you can get a number of clients for aur
13:32:55 <Welkin> fedora is redhat's guinea pig
13:32:56 <clrnd> oh I don't remember, I only used arch for a short while, and pacman was enough
13:33:21 <Welkin> you may want to use something more stable, like centOS, if you want a redhat distro
13:33:50 <horny-sama> Welkin: I know
13:34:00 <horny-sama> Welkin: but fedora is cutting edge
13:34:11 <jmcarthur> Welkin: surprising. fedora is the *unstable* distro and has such an out of date ghc?
13:34:36 <clrnd> yeah funny
13:35:14 <ezyang> iirc, ghc narrowly missed the last release cutoff
13:35:37 <shachaf> Maybe my bug report is going to delay GHC.
13:35:40 <glguy> Haskell community's notion of cutting edge is a little sharper than the cutting edge of most distros
13:35:52 <jmcarthur> oh, a release cutoff. so it's still a non-rolling release distro.
13:35:55 <jmcarthur> that makes more sense
13:36:06 <geekosaur> yep
13:36:27 <horny-sama> added the respo
13:36:32 <horny-sama> repo time to roll?
13:36:38 <balor> Is it possible to disable System.Log.Logger logging via an environmental var or similar?
13:37:31 <jmcarthur> ezyang: there is a way for ForeignPtrs
13:37:40 <jmcarthur> it's touchForeignPtr
13:38:00 <jmcarthur> ezyang: not sure that's exactly what you meant
13:40:08 <jmcarthur> oh like StablePtr
13:40:50 <ezyang> yeah, basically ForeignPtr but for a instead of Ptr a
13:41:58 <jmcarthur> you could make your own box around it and use Control.Exception.evaluate to "touch" the box
13:42:28 <jmcarthur> if you are just trying to avoid the penalty of pinning the memory
13:43:18 <ezyang> I'm not sure that's semantically guaranteed to DTRT
13:43:19 <jmcarthur> this would just use IO for evaluation ordering. if you don't even need IO, you could do some more manual management of evaluation order (a monad can still make this more convenient of course)
13:43:26 <jmcarthur> DTRT?
13:43:41 <jmcarthur> i can guess what you mean. you may be right
13:44:11 <jmcarthur> ezyang: there's also some touch# primitive that looks promising
13:44:16 <jmcarthur> i don't know what it actually does
13:44:31 <jmcarthur> it lives under the weak pointer stuff
13:45:25 <jmcarthur> ezyang: ah, touchForeignPtr uses it, too
13:45:53 <ezyang> hmm, it does kind of look like the right thing
13:46:31 <jmcarthur> ezyang: it's also wrapped in the primitive package
13:47:32 <Bor0> I have specified version in my .cabal file. is this value built in the executable itself? I want to display this version to the end-user without specifying the same version on multiple places
13:48:38 <glguy> They're available as CPP macros generated by cabal automatically, look in dist/build/autogen/cabal_macros.h
13:49:41 <Bor0> glguy, cool, thanks. now just to find out how to use those macros within my haskell code :)
13:49:54 <glguy> add {-# LANGUAGE CPP #-}
13:56:27 <hexagoxel> glguy: could it be that cabal_macros.h only defines macros for all dependencies?
13:57:30 <kfowler> anyone notice www.haskell.org being *very* slow?
13:57:37 <Welkin> yes
13:57:41 <Welkin> it is a network issue
13:57:49 <Welkin> it's been like that for weeks (or months)
13:57:54 <Welkin> it'll get fixed eventually
13:58:17 <kfowler> who maintains the site? maybe we could getthem some help?
13:58:18 <Welkin> at least hackage works fine
13:58:33 <horny-sama> gosh added the repo but it is still not getting the ghc7.8.x :<
13:58:39 <Welkin> I think they are in #haskell-infrastructure
14:00:28 <hexagoxel> Bor0: well let me add my cents: i think it is better to use the auto-generated Paths_$PACKAGENAME module, which you can import from haskell and contains a `Version` record
14:00:50 <kfowler> thanks Welkin.
14:00:58 <Bor0> hexagoxel, yeah, I just noticed that. the project version is not there in the macros file, only the for the deps
14:01:05 <Bor0> thanks to both :)
14:01:10 <hexagoxel> and not even for all dependencies, i think
14:01:23 <Bor0> oh, I see. I didn't notice that. I just saw a couple of them were there
14:01:53 <hexagoxel> Bor0: note that you can even expose the Paths_... module, so dependencies can access it
14:02:53 <hexagoxel> (and - is transformed to _, so package "abc-def" has module "Paths_abc_def")
14:03:11 <Zemyla_> Okay, I'm trying to do type-level arithmetic on my own, using binary numbers, and the most natural parameterization seems to me to be n = 0 | 2*n' + 0 | 2*n' + 1.
14:03:44 <Zemyla_> However, this means that 0 has an infinite number of parameterizations.
14:03:56 <Zemyla_> (0, 2 * 0, 2 * 2 * 0, etc.)
14:04:05 <hexagoxel> s/dependencies/reverse dependencies/
14:04:06 <hexagoxel> or smth
14:05:44 <c_wraith> Zemyla: naturals only?
14:07:51 <Zemyla> So 1 | 2n + 0 | 2n + 1?
14:09:41 <c_wraith> Zemyla: actually,  Nil | 1 n | 0 n.  Still allows you to have infinite leading zeroes, I suppose.
14:14:39 <horny-sama> installing the latest version of haskell is tough as shit
14:14:47 <horny-sama> someone just make a rpm package nwo
14:14:51 <Zemyla> c_wraith: Starting with 1 actually makes sense for this, though, because it's representing a resolution for Fixed, which can't be zero.
14:14:58 <shachaf> I just download the PDF usually.
14:15:09 <c_wraith> Zemyla: oh.  That would work, then.
14:15:36 <metanat> Hi, is this an appropriate place to ask Haskell questions?
14:15:39 <sinelaw> jmcarthur, heya
14:15:57 <quchen> horny-sama: Downloading the binary distribution of GHC, the biggest Haskell implementation, should give you a pretty straightforward installation.
14:16:09 <jmcarthur> sinelaw: yo!
14:16:18 <sinelaw> jmcarthur, hows NYC?
14:16:19 <horny-sama> quchen: trying to install it no goal
14:16:28 <jmcarthur> sinelaw: generally cold!
14:16:38 <jmcarthur> :)
14:16:45 <sinelaw> jmcarthur, heh. I miss that actually
14:17:09 <jmcarthur> i like changing weather. i dislike when it just stays one way for a long time
14:17:25 <sinelaw> same here
14:17:45 <Lokathor> if i'm using ByteString, and I want to patten match on the contents, do I have to use the Overloaded Strings extension to write out ByteString constants? or is there some alternate way?
14:18:52 <Lokathor> and/or, is it considered fine to just use language extensions all the time?
14:19:21 <quchen> You shouldn't try to pattern match on bytestrings, as they do not contain letters or characters. They're literally chains of bytes without any further meaning.
14:20:06 <Lokathor> er, well these are ByteString.Char8, if that makes a difference?
14:20:14 <quchen> If you want to check whether the first n bytes are 1,2,3,4,5 then use (unpack . take 5) and match on that.
14:20:46 <glguy> If you want to check if the first 5 bytes are the bytes 1-5 it's just as well to compare for equality
14:20:48 <glguy> no need to unpack
14:20:58 <metanat> I have a ADT (some constructors of which have args), and I am wanting to enumerate all the possible values of the data type. How would I go about doing this?
14:21:04 <quchen> glguy: ‚Ä¶ it was an example.
14:21:19 <quchen> Using Char8 is probably a mistake. See https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
14:21:24 <mgsloan> It's reasonable to use ViewPatterns to match on bytestrings.  E.g. this pattern: (splitAt 5 -> ("hello", rest))
14:22:23 <mgsloan> (and this will even be efficient, since slicing bytestrings is O(1))
14:22:35 <SrPx> Does anyone know where is the documentation on unboxed st array? This is empty: http://hackage.haskell.org/package/array-0.2.0.0/docs/Data-Array-ST.html#2 (???)
14:22:43 <Lokathor> quchen: the IRC library in question hands me data as ByteString.Char8 because IRC has no encoding specified by the protocol
14:23:05 <Hijiri> metanat: I usually write an Enum instance manually, which is annoying and boilerplatey
14:23:41 <SrPx> ah found it
14:23:46 <quchen> "No encoding speficied" means that you should not assume ASCII and therefore should not use Char8.
14:24:09 <metanat> I should also mention that the data type is recursive
14:24:47 <Hijiri> what does it look like?
14:24:57 <mgsloan> Lokathor: Note that Data.ByteString.Char8.ByteString and Data.ByteString.ByteString are the same type
14:24:59 <Hijiri> it might have inifite possible values
14:25:06 <Hijiri> infinite
14:25:28 <metanat> Hijiri: Imagine that I had, data Expr = Val Int | Plus Expr Expr | Minus Expr Expr
14:25:57 <metanat> Hijiri: It does have infinite values
14:26:04 <Lokathor> quchen: tell that to the writers of simpleirc >_<
14:26:19 <Hijiri> you want an infinite list of values or something?
14:26:50 <Hijiri> an infinite tree might be better suited
14:26:51 <horny-sama> the repo for ghc 7.6.x is having a conflict with ghc 7.8.x one
14:27:06 <metanat> Yes, I am wanting to generate an infinite list of "functions" in a small expression language
14:27:10 <Lokathor> quchen: actually they use "ByteString" (which lets you pick any variant?) and then you can decode however you like to get it as Text
14:27:45 <Hijiri> I think it would be easier to first create an infinite tree, and make a breadth-first list of values from that tree
14:27:54 <Lokathor> quchen: Still you have to pick *some* encoding at some time if you want to attempt to see what's in the message you just got.
14:28:21 <Hijiri> actually it would be a trie I think
14:29:08 <zipper> Cryptographically secure random generator in haskell?
14:29:20 <c_wraith> zipper: try the packages with csprng in the name
14:29:32 <zipper> c_wraith: Thanks :)
14:30:52 <Hijiri> ExprTrie = TVal Int | TPlus [ExprTrie] [ExprTrie] | TMinus [ExprTrie] [ExprTrie]
14:31:03 <Hijiri> wait, that's not quite right
14:31:23 <trap_exit> C++ has this notion of "friend" where if X is a friend of Y, X can access hidden members of Y // now, does Haskell modules have a notion of "friend" ? I.e. I want a way for module X to access a non-exported function in module Y
14:31:50 <benmachine> no
14:31:55 <trap_exit> :-(
14:32:01 <c_wraith> trap_exit: the only thing even close is that packages have non-exported modules that aren't part of the external interface
14:32:19 <benmachine> trap_exit: a common thing to do is to have an Internal module that exports lots of things
14:32:24 <c_wraith> trap_exit: so modules within the package can use those hidden modules, but external modules can't.
14:32:36 <benmachine> and module A re-exports some subset and module B re-exports some other subset and that's your public interface
14:32:40 <trap_exit> benmachine c_wraith: ah, that makes sense :-)
14:33:01 <c_wraith> trap_exit: I don't like that, though, as it often turns out to harm users.  A ".Internal" module that's specified to be likely to change at any time is a better compromise, in my experience.
14:34:01 <Hijiri> not even sure this is a tree anymore
14:34:51 <Hijiri> ExprTrie = [ExprNode]; ExprNode = TVal Int | TPlus ExprTrie ExprTrie | TMinus [ExprTrie] [ExprTrie]
14:35:29 <Hijiri> exprs :: ExprTrie; exprs = [TVal ?, TPlus exprs exprs, TMinus exprs exprs]
14:35:39 <Hijiri> and I don't know what you would use for the Int
14:36:28 <Hijiri> if you have a range of integers you want you could have exprs = map TVal [n..m] ++ [TPlus exprs exprs, TMinus exprs exprs]
14:37:39 <trap_exit> data Rect = Rect Int Int Int Int ... "Rect" just exports the type Rect, but not constructor, "Rect(..)" exports type + constructor; however is there a way, via hiding to hide JUST THE CONSTRUCTOR?
14:38:13 <Hijiri> hide just the constructor or just the type?
14:38:21 <Hijiri> oh
14:38:23 <Hijiri> you mean when importing
14:38:41 <Hijiri> I think you can do the same thing importing?
14:38:53 <Hijiri> not sure
14:39:00 <trap_exit> I want to hide _+just the consturcotr_ but make the type available
14:39:05 <trap_exit> and I want to do this via "hiding" instead of listing everything else
14:39:45 <Hijiri> maybe not
14:40:13 <quchen> import Prelude hiding (Nothing) -- works for me in GHCi.
14:40:24 <Hijiri> oh, I was wrong
14:42:08 <monochrom> no, when exporting, there is not short syntax for "export everything except this".
14:43:12 <Hijiri> for some reason I thought we were talking about importing
14:43:15 <monochrom> you should propose to join the Haskell committee so that you can propose syntax changes like this.
14:43:20 <Hijiri> because there is no hiding keyword that works with export list
14:43:30 <Darwin226> Hey guys. What's the best way to read from a socket if I want to collect everything that came in in some time period and then deserialize objects from that ByteString? The problem right now is that those object might have varying sizes so I don't know how many bytes to read at a time
14:44:21 <quchen> Have a look at pipes/pipes-parse
14:44:22 <Darwin226> It seems very tricky to get this right because not being able to read a single object is bad, but reading more than one at the time is equally as problematic
14:45:50 <monochrom> beware that when one says "export everything except so-and-so", there are two kinds of "everything": "everything" the module defines itself, and "everything" the module itself plus the module imports from elsewhere.
14:48:30 <Lokathor> I used "cabal init", but it did not auto-detect my dependencies
14:48:31 <Lokathor> how sad
14:49:24 <Welkin> cabal build
14:49:32 <Welkin> and it will tell you the deps
14:50:27 <Darwin226> quchen: This looks about what I wanted. I should not that pipes were nowhere to be found when searching for terms like "haskell networking" "haskell simple tcp" or similar. I realize this has nothing to do with you, but maybe someone can do something with that piece of info
14:50:53 <horny-sama> is there a big change from 7.6.x to 7.8.x
14:51:06 <horny-sama> I am thinking of jsut sticking with 7.6.x for fedora
14:51:07 <Lokathor> Welkin: it failed to parse the .cabal file
14:51:19 <horny-sama> since updating to 7.8.x is proving to be next to impossible
14:51:21 <horny-sama> :P
14:51:48 <mpickering> what error are you running into?
14:52:02 <quchen> Darwin226: Pipes is pretty general (and -parse as well) so that I'm not sure how to mention all the use cases in the documentation.
14:52:13 <horny-sama> mpickering: I am trying to install it manually and thru corp
14:52:25 <mpickering> what do you mean by manually?
14:52:27 <mpickering> from source?
14:52:32 <horny-sama> mpickering: yes
14:52:48 <horny-sama> source  resulted in ./configure --prefix=/usr/bin
14:52:48 <horny-sama> checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
14:53:12 <horny-sama> corp one resulted in trying to pull both 7.6 and 7.8 at the same time
14:53:24 <horny-sama> basically just blow up my compiler
14:53:26 <ahammel> @undo f a = do { var <- d; g var a }
14:53:26 <lambdabot> f a = d >>= \ var -> g var a;
14:53:30 <Darwin226> quchen: It isn't a logical problem, but it is a UX one. Is pipes are indeed the go to solution for something I feel is a pretty common need, it's a shame it isn't exposed more to a person looking for that solution
14:53:38 <mpickering> well the first error is that you're missing libgmp
14:53:38 * hackagebot gipeda 0.1 - Git Performance Dashboard  http://hackage.haskell.org/package/gipeda-0.1 (JoachimBreitner)
14:53:50 <mpickering> I would not reccomend building from source though, there must be some binaries floating around?
14:54:14 <horny-sama> mpickering: I did yum install libgmp already no packages found
14:54:19 <horny-sama> mpickering: there is
14:54:39 <quchen> Darwin226: Funny you mention networking, there's also pipes-network :-)
14:54:48 <horny-sama> https://www.haskell.org/ghc/download_ghc_7_8_3#x86_64linux
14:54:56 <horny-sama> or https://copr.fedoraproject.org/coprs/petersen/ghc-7.8.4/
14:55:03 <horny-sama> both are killing me
14:55:04 <hexagoxel> is there a list of all exposed module names from hackage packages somewhere? i want to get a feeling for an appropriate structure for my package
14:55:31 <Darwin226> quchen: Well, that settles it then! thanks for pointing me in the right direction
14:57:47 <hexagoxel> hmm `cabal info -v` prints the modules. now i just need some clever shell piping like `cabal list | .. cabal info -v | ...`
14:57:49 <joness> how is randomIO implemented? a top-level IORef containing current seed?
14:58:34 <glguy> http://hackage.haskell.org/package/random-1.1/docs/src/System-Random.html#getStdGen
14:58:37 <glguy> joness
14:58:38 * hackagebot gipeda 0.1.0.1 - Git Performance Dashboard  http://hackage.haskell.org/package/gipeda-0.1.0.1 (JoachimBreitner)
14:59:19 <joness> ah
14:59:34 <joness> my next question was supposed to be.. can we do it without unsafePerformIO
15:00:17 <joness> (can we create a top-level IORef without unsafePerformIO)
15:00:27 <johnw> not to my knowledge
15:00:35 <johnw> the constructor is not available to you
15:00:37 <glguy> File a bug if you figure out how :)
15:00:39 <c_wraith> only with things morally equivalent to unsafePerformIO
15:00:43 <geekosaur> MonadRandom lets you carry a seed, originally obtained via IO, around; you can think of it as a custom state monad
15:00:47 <c_wraith> like..  unsafeCoerce and runST.  :P
15:00:56 <shachaf> c_wraith: JHC's ACIO isn't morally equivalent to unsafePerformIO
15:01:13 <horny-sama> the repo has issues
15:01:15 <horny-sama> fuck it
15:01:18 <c_wraith> shachaf: true, I was restricting myself to ghc
15:03:37 <joness> at http://hackage.haskell.org/package/random-1.1/docs/src/System-Random.html#getStdGen getStdGen calls theStdGen, which not only creates IORef, but calls mkStdRNG, which fetches current time and cpu usage. why is it safe to unsafePerformIO all that?
15:03:38 <horny-sama> I guess I will use my mac or window or ubuntu machine for haskell
15:04:40 <Pamelloes> Is there a way to accumulate all processed tokens in parsec?
15:05:27 <Pamelloes> Preferably in alternative notation.
15:05:32 <Hijiri> joness: theStdGen is only used in other things that are IO, and never leaves unsafePerformIO thunks in pure values (as far as I can tell)
15:05:46 <glguy> I'm surprised that that doesn't need a {-# NOINLINE
15:06:40 <glguy> maybe it's OK if it gets inlined because the interface to it is behind getStdGen and there's no promise that what you set is what you get back out
15:06:45 <hexagoxel> ah yis `cabal list --simple-output | sed "s/ .*//" | uniq | xargs cabal info -v | grep "^        [^ ]" | sed "s/        //" | sort`
15:07:29 <ezyang> Did anyone implement a function rnf :: a -> () (no NFData constraint)?
15:07:45 <shachaf> ezyang: How would it work?
15:07:53 <glguy> (`seq` ()) ?
15:07:56 <c_wraith> ezyang: isn't rnf the function in the NFData class?
15:08:00 <shachaf> i,i rwhnf
15:08:54 <glguy>     In the use of ‚Äòrwhnf‚Äô (imported from Control.Parallel.Strategies):    Deprecated: "renamed to rseq"
15:09:09 <shachaf> glguy: whoa, that's a real thing?
15:09:29 <glguy> Control.Parallel.Strategies.rseq :: Strategy a
15:09:31 <shachaf> I guess it is, as a Strategy.
15:09:45 <ezyang> c_wraith: Yes. Such an implementation of rnf would be deeply magical
15:10:18 * shachaf thinks many uses of NFData are misguided anyway.
15:10:20 <c_wraith> I suppose GHC's data structures have enough metadata to be that magical
15:13:05 <c_wraith> Yeah, I've found that NFData is almost never the correct solution in the long term.  Though it's handy as a quick tool to check whether a particular data structure is the source of a leak.
15:13:22 <dhinojosa> I thought that the kind for Monoid would be * -> * but it is * -> Constraint. Can someone explain Constraint?
15:13:42 <shachaf> dhinojosa: A Constraint is something that can be on the left side of =>
15:13:47 <joness> Hijiri what does this mean? "never leaves unsafePerformIO thunks in pure values "
15:13:54 <shachaf> So (Monoid a) is a constraint.
15:13:57 <shachaf> a :: *
15:14:01 <shachaf> So Monoid :: a -> Constraint
15:14:06 <geekosaur> the value is fully evaluated
15:14:13 <shachaf> (This isn't part of official Haskell, it's a GHC extension.)
15:14:20 <geekosaur> so it won't suddenly do I/O in the middle of a pure computation due to laziness
15:14:27 <dhinojosa> thanks shachaf
15:14:41 <shachaf> Er.
15:14:45 <shachaf> I meant Monoid :: * -> Constraint
15:15:04 <dhinojosa> shachaf for official haskell am I correct in thinking that Monoid kind is * -> *?
15:15:11 <shachaf> No.
15:15:20 <shachaf> Monoid doesn't have a kind, it's a class.
15:15:22 <c_wraith> in base Haskell, Monoid has no kind.  It's a class
15:15:47 <shachaf> * -> * is the kind of things like Maybe
15:15:56 <shachaf> Maybe is a very different sort of thing from Monoid
15:16:04 <dhinojosa> yes, agree
15:16:30 <shock_one> What's the command to make a function point free?
15:16:43 <shachaf> /msg lambdabot @pl ...
15:16:59 <shock_one> lambdabot @pl \x -> (+ (succ (succ x)))
15:17:03 <shock_one> Thank you.
15:17:15 <shock_one> @pl \x -> (+ (succ (succ x)))
15:17:15 <lambdabot> (+) . succ . succ
15:17:23 <shachaf> I mean that you send it as a private message to lambdabot. :-)
15:17:31 <joness> is the output in here guaranteed? will "creating foo" come after "start", and will it be printed only the first time we access foo? http://lpaste.net/118795
15:17:44 <dhinojosa> so shachaf, when we talk about kinds, we are only talking about the type variable, never about the class?
15:18:02 <Hijiri> joness: yes
15:18:08 <shachaf> I'm not sure what you mean.
15:18:21 <shachaf> The kind of a thing which is an instanceo f Monoid is *
15:18:21 <Hijiri> when you print it the first time, foo gets reduced to 10
15:18:42 <Hijiri> because it needs to be reduced that far to be printed
15:18:44 <joness> yeah, thunk is replaced with 10, correct?
15:18:45 <shachaf> Hijiri: Why is it guaranteed?
15:19:12 <Hijiri> I guess it isn't
15:19:24 <joness> what part isn't?
15:19:39 <Hijiri> GHC could choose not to share
15:20:19 <Hijiri> since sharing isn't part of the haskell standard, just nonstrictness
15:20:30 <joness> meaning creating foo" could be printed each time we access foo?
15:20:43 <c_wraith> GHC itself will always share a named value across its uses, though.
15:20:45 <Hijiri> It's possible, ghc might optimize in some way
15:20:59 <c_wraith> well, I guess except in the case of inlining.
15:21:05 <shachaf> c_wraith: It's guaranteed that it'd never inline in a case like this?
15:21:05 <c_wraith> Yeah, there are potential tricks
15:21:10 <ezyang> Hmm.  I don't remember if C-- primops can jump into Haskell. They ought to but i don't remember how to do it
15:22:43 <joness> would {-# NOINLINE foo #-}  guarantee that "creating foo" will only be printed once, first time foo is evaluated?
15:23:05 <dhinojosa> shachaf: All type classes are constraints?
15:23:15 <ezyang> It doesn't guarantee it, semantically, but usually that will be the case
15:23:49 <shachaf> dhinojosa: No, but they all return constraints when applied to some number of arguments.
15:24:00 <joness> it is interesting that randomIO implementation doesn't have NOINLINE when creating a top-level IORef with unsafePerformIO (while also calling getTime, getCPU)
15:24:12 <dhinojosa> shachaf: Thanks for the clarity
15:24:42 <c_wraith> joness: eh, what does it matter if different uses get different seeds?  :)
15:25:05 <Cale> getStdGen/setStdGen is pretty dumb, I think that probably ought to be removed
15:25:07 <c_wraith> joness: remember, randomIO is one heck of a hack anyway
15:25:36 <Welkin> getStdGen confused me
15:25:52 <Welkin> I had to ask here to learn the difference between getStdGen and newStdGen and which to use
15:26:23 <joness> c_wraith woudln't that mean seed is reset using getTime and getCPU on every access? that doesn't seem like a good ida
15:26:25 <joness> idea*
15:26:40 <Cale> It shouldn't be using getTime and getCPU in the first place
15:26:48 <Cale> That's *also* really dumb
15:26:52 <glguy> joness: It means that it could doesn't have to, (and also it doesn't)
15:27:11 <Cale> (Especially if it's still doing that after so many years?)
15:27:28 * Cale goes to look at the code...
15:27:55 <Cale> yeah, it is
15:27:58 <shachaf> Don't worry, the RNG algorithm is so nondeterministic that it compensates for a predictable seed.
15:28:00 <Cale> jeez
15:28:09 <Cale> lol
15:28:32 <Cale> Why not just get a seed from the system RNG?
15:28:34 <joness> Cale we are wondering if theStdGen needs NOINLINE
15:28:53 <Cale> i.e. /dev/urandom on most systems, something else on Windows
15:28:56 <joness> http://hackage.haskell.org/package/random-1.1/docs/src/System-Random.html#getStdGen
15:29:20 <joness> second definition
15:29:26 <Cale> oh
15:29:31 <Cale> uhhh...
15:29:37 <Cale> Yes, it probably ought to
15:29:43 <Cale> If it's going to exist at all
15:29:50 <geekosaur> I thought that was to keep multiple cal sites from each getting their own IORef
15:29:56 <geekosaur> so yes you want NOINLINE
15:30:18 <Cale> But I'd be all in favour of just removing theStdGen
15:30:18 <c_wraith> it really doesn't matter if different call sites get their own IORef in the case of things that use that, though
15:30:52 <c_wraith> It doesn't change the semantics unless for some reason you are depending on randomIO acting identically to a serially passed gen value
15:31:36 <Cale> You could redefine getStdGen to be newStdGen with a deprecation warning, and just remove setStdGen, and not affect most programs.
15:32:24 <Cale> and define newStdGen to get a seed from the system RNG
15:32:34 <Cale> and not the damn clock
15:35:12 <Cale> Actually, while we're at it, we should probably just adopt tf-random, even if it's slightly slower, just because it actually supports split properly rather than giving highly correlated values after a few splite.
15:35:15 <Cale> splits*
15:36:18 <Cale> and/or, we should rip all the Gen monad stuff out of QuickCheck and make that into the standard way to generate random values
15:36:36 <Cale> Arbitrary/Gen should be their own package
15:36:53 <glguy> A major shakeup would be a nice time to split the types that make sense to generate a bounded random from the ones that don't
15:36:54 <Cale> (and Coarbitrary of course, you need that too)
15:39:43 * hackagebot webdriver-angular 0.1.7 - Webdriver actions to assist with testing a webpage which uses Angular.Js  http://hackage.haskell.org/package/webdriver-angular-0.1.7 (JohnLenz)
15:39:43 <Cale> and of course, that stuff uses tf-random, because QuickCheck tests that were spuriously passing was one of the original reasons for tf-random to be developed.
15:39:44 <linman32> hi, i am working on nicta course on githb. i find it very challenging. anyone else find it challenging?
15:40:37 <ReinH> linman32: you might find more folks working on NICTA in #haskell-beginners, FYI.
15:40:49 <Cale> Feel free to ask any questions you might have here
15:41:18 <shachaf> This channel is intended to be suitable for beginners.
15:41:45 <linman32> i'll haskell-beginners first. thanks
15:41:50 <linman32> *i'll try
15:42:00 <hexagoxel> sorted list of first module identifiers from packages on hackage, for those interested: https://gist.github.com/lspitzner/43443ec2cb395c6bb244
15:42:12 <hexagoxel> what is HROOT?
15:42:33 <Cale> Well, I'm not in #haskell-beginners
15:42:36 <Cale> Maybe I should be
15:42:53 <shachaf> I'm not in #haskell-beginners and I probably won't be.
15:44:04 <shachaf> It's not related to #haskell or the haskell-beginners list except for the name.
15:47:13 <trap_exit> Cale: what do you need help with?
15:47:18 <ghosty> \join #python
15:47:25 <trap_exit> Cale: we're a very encouraging, beginner-friendly here
15:47:28 <Cale> trap_exit: heh
15:47:29 <hiptobecubic> trap_exit, :D
15:47:42 <Cale> trap_exit: No, my interest is in making myself more available to potential beginners
15:47:58 <Cale> I don't know how many people might go there and not here
15:48:08 <trap_exit> Cale: as in preaching the gospel? the unsaved heathens are in #ocaml; they're so close, but they don't see the light yet
15:48:20 <Cale> Maybe I should grab the nick lists and do a difference :)
15:48:51 <Pamelloes> There's a #haskell-beginners o.o The things you learn
15:48:56 <shachaf> It would be better named #haskell-bitemyapp
15:49:01 <trap_exit> you should do it lazily, i.e. when someone in #haskell-begnners talk, look up and see if the'[re in #haskell
15:53:56 <pouledodue> why is haskell so popular
15:54:47 <Welkin> why are computers so popular?
15:54:50 <Pamelloes> pouledodue: It's a way of life.
15:55:50 <pouledodue> I mean which sector of the industry uses haskell (honest question, I want to know more about the typical applications)
15:55:56 <Pamelloes> Haskellers started having a higher birthrate then the global average around 1927 and ever since Haskell's market share has grown.
15:56:08 <Pamelloes> Nowadays we are at around 15% of the global population.
15:56:58 <Hijiri> I heard imvu migrated their php to haskell
15:57:02 <Hijiri> or maybe it wasn't php, I don't remember
15:57:07 <Welkin> haskell is used heavily in finance
15:57:14 <Welkin> but you can use it for anything
15:57:17 <Welkin> it is general purpose
15:57:25 <Welkin> several people use it for games
15:57:30 <Welkin> I am using it for games right now
15:57:38 <Welkin> I use it for web development too
15:57:54 <phaazon> no one about my issue with profiling on windows? :(
15:58:10 <Welkin> Hijiri: it was php
15:58:11 <J_Arcane> I'm learning Haskell because I'm catastrophically attracted to powerful but relatively unpopular languages with deeply arcane underbellies.
15:58:37 <Pamelloes> Welkin: Haskell is used in finance?
15:58:41 <phaazon> http://stackoverflow.com/questions/28020899/profiling-an-application-on-windows-with-cabal-ghc
15:58:42 <Cale> J_Arcane: cool! Feel free to ask any questions you might have.
15:58:45 <phaazon> still no one? :(
15:59:08 <Welkin> Pamelloes: Standard Chartered is a good example
15:59:16 <Welkin> also, Facebook and Microsoft use Haskell
15:59:28 <Welkin> and now JP Morgan Chase Bank too
15:59:53 <hiptobecubic> Is there a anything nicer than the raw wrapping of the C library for handling HDF5 files? It seems not, but it's always worth asking
16:00:06 <Cale> Yeah, it seems like all the banks have "secret" Haskell groups.
16:00:10 <Pamelloes> Really! My understanding was that it was a research language and that it wasn't really used by anyone.
16:00:15 <Cale> (and sometimes not so secret)
16:00:17 <Welkin> Cale: except Standard Chartered
16:00:49 <J_Arcane> Cale: Language choice as trade secret is a really weird phenomenon to me, and one that seems deeply counterproductive at times.
16:00:59 <Hijiri> maybe one day I'll be able to sell my soul to Big Finance and get paid for haskell
16:01:10 <Cale> J_Arcane: Well, Haskell is a pretty decent secret weapon
16:01:20 <Cale> J_Arcane: but yeah, I agree
16:01:20 <Pamelloes> J_Arcane: Banks aren't supposed to be efficient, they're supposed to be profitable.
16:01:40 <benzrf> oh, capitalism
16:02:40 <Welkin> it's only a matter of time before companies begin moving away from OOP dogma and realize they are wasting their time with a terrible abstraction
16:02:52 <J_Arcane> Like, there are seriously big companies using Racket for another example, but almost none of them talk about it. The last time I inquired about a Racket job, the guy handling it wasn't even allowed to tell me what the company was.
16:02:56 <Welkin> some sooner than others
16:04:02 <Welkin> I see a lot of job postings that list: "Expert in Object Oriented Programming"
16:04:08 <kadoban> J_Arcane: Are you sure it wasn't just some goofy recruiter that didn't want you to eliminate the middleman?
16:04:40 <Welkin> recruiters generally do not reveal who their clients are
16:05:22 * SrPx sighs
16:05:25 <J_Arcane> kadoban: Naw, how it tends to work is, they contact one of the more visible members of the community, who act as a go-between; the listing rarely if ever makes it to a public site.
16:06:12 <SrPx> I'm so low right now. Everything I try to make in Haskell ends up so slow that I it is barely ysable
16:06:51 <lericson> SrPx: spend more time designing your algorithm!
16:07:17 <Welkin> more likely, look at your data structure
16:07:18 <SrPx> nothing to do with the algorithms ... :(
16:07:23 <Welkin> is it appropriate?
16:07:35 <SrPx> more to do with the kind of stuff I'm trying to do... I guess Haskell just isn't meant for that
16:07:47 <Welkin> like what?
16:08:14 <SrPx> yea sometimes I do a straightforward translation from another language (javascript) using the same structures, unboxed mutable vectors, usafe writes and reads. and it is still slower by a order of magnitude
16:08:43 <Welkin> that may be your problem
16:08:57 <Welkin> you are trying to write in another language while using haskell
16:09:36 <SrPx> Welkin: last time I was trying to port a graph library that did BFSs, A* and similar. At least 8x slower than JS :( now I'm trying to write a rasterizer for a scene and I need very low level write/reads on arrays for that
16:10:14 <SrPx> Welkin: no, I have tried the linguistic approach in so many occasions and it is always much worse :/
16:10:42 <srhb> I usually experience very-close-to-c performance when I do low-level porting with mutable structures
16:10:46 <kadoban> SrPx: That doesn't sound like my experience, albeit somewhat limited, unless you're talking about highly tuned other-language code vs. first draft haskell code.
16:10:48 <srhb> I don't think your problem is coding in another language.
16:10:56 <srhb> I think you're doing something very specifically wrong.
16:10:58 <srhb> In each case.
16:11:05 <J_Arcane> https://ianthehenry.com/2015/1/17/decoding-utf-8/
16:11:18 <Pamelloes> And if worse comes to worse, you could always consider FFI
16:11:23 <SrPx> That's my guess, so, after all Haskell is on par with C++ in performance. I don't know, I just can't work it
16:11:40 <srhb> Well, start by making a small example that is super much worse even though you don't expect it to be
16:11:42 <srhb> Then share in channel
16:11:48 <srhb> Or even stackoverflow.
16:12:23 <SrPx> srhb: http://stackoverflow.com/questions/28035350/why-is-this-haskell-array-filling-operation-so-slow?noredirect=1#comment44456173_28035350 that is just what I did :(
16:12:27 <kadoban> SrPx: Do you have an example of what you're talking about, preferably something bitesized? The graph library or part of it maybe?
16:13:01 <SrPx> I tried isolating the most basic operation which is filling of the mutable unboxed array... I know there is something really wrong there but I can't identify it. Is forM_ creating a stack???
16:13:29 <SrPx> foldl' is compiled into a stackless loop right? So it must be forM_
16:13:41 * hackagebot hmatrix-quadprogpp 0.2.0.2 - Bindings to the QuadProg++ quadratic programming library  http://hackage.haskell.org/package/hmatrix-quadprogpp-0.2.0.2 (AkioTakano)
16:14:08 <srhb> Is O3 a thing? Doesn't that imply O1?
16:14:38 <glguy> GHC goes up to O2
16:14:59 <srhb> I wonder if O3 means O2 or something else then
16:15:04 <SrPx> Just tried -O2, same measure
16:15:12 <srhb> OK, it's O2 then
16:16:31 <Welkin> SrPx: disassemble the code and inspect it
16:17:07 <SrPx> can't read assembly :(
16:17:28 <Welkin> it's easy
16:17:35 <Welkin> you can learn it in an hour at most
16:17:43 <srhb> SrPx: Where's unsafeFreeze from?
16:17:51 <Pamelloes> If I have a datatype where each constructor is a monoid with itself but not other constructors, how can I make the datatype a monoid?
16:18:11 <shachaf> What does it mean for a constructor to be a monoid?
16:18:49 <shachaf> Do you mean data T = T1 A | T2 B | T3 C, where A,B,C are instances of Monoid?
16:18:53 <SrPx> hmmm guys
16:18:57 <Pamelloes> shachaf: my datatype has 5 constuctors. If I broke it up into 5 datatypes, each wtih one constructor, the 5 datatypes would be monoids
16:19:06 <SrPx> seems like I'm getting the same time with and without O2
16:19:17 <SrPx> guess I'm using it wrong? "ghc -O2 bench.hs -o bench" isn't that it?
16:19:35 <shachaf> Is that a yes?
16:19:40 <Pamelloes> yes
16:20:01 <shachaf> If so, you're in a bit of trouble. What would you want (T1 x <> T2 y) to be?
16:20:09 <shachaf> You could go with a Category rather than a Monoid.
16:20:19 <ClaudiusMaximus> SrPx: try adding -fforce-recomp - it might think it doesn't need to recompile if the source hasn't changed
16:20:27 <SrPx> srhb: my bad. I couldn't find it (???)
16:20:41 <SrPx> srhb: ah, Data.Array.Unsafe
16:20:54 <shachaf> What do you call a category where you only have endomorphisms?
16:21:05 <shachaf> I was going to say "discrete" but it's not that.
16:21:11 <shachaf> Anyway, that's what you have.
16:21:24 <Pamelloes> mm.
16:21:45 <kadoban> Pamelloes: So it's not a Monoid. Why do you want it to be one?
16:22:08 <SrPx> Oh lord that  can't be true, thank you <3 <3 my particles... are so freaking fast right now. Yaaaaaaay wooow
16:22:12 <SrPx> It was at like, 3fps
16:22:43 <SrPx> wow
16:23:09 <Pamelloes> kadoban: I'd like to use Writer with it as the parameter.
16:23:39 <shachaf> Then maybe you want indexed Writer.
16:23:46 <unknownloner> what's it at now SrPx
16:23:49 <shachaf> But maybe it would be simpler to split out your types.
16:24:01 <Pamelloes> Maybe...
16:24:05 <kadoban> Pamelloes: What is the meaning of the type(s)?
16:24:15 <Pamelloes> I have to go, sorry :(
16:24:21 <SrPx> unknownloner: from 700ms to 30ms that benchmark ... I don't know the fps of the particles, I just guessed (it is smooth now)
16:24:28 <SrPx> that benchmark = the vector filling
16:24:41 <unknownloner> oh, wow
16:24:49 <kadoban> Pamelloes: No worries. Cya later
16:25:10 <SrPx> man that speedup came almost as a gift from heaven.. I spent so much time on that
16:25:38 <Welkin> SrPx: what was the problem?
16:25:47 <Zemyla> How is BOX used when defining types?
16:26:03 <carter> SrPx: did you write that game yet?
16:26:25 <hiptobecubic> SrPx, that code is fast as hell for me. Not sure what the deal is on your system
16:26:47 <SrPx> carter: I would if I didn't spent a whole day trying to get above 3 fps :( but that was my fault, I guess. I should've known that it wasn't recompiling
16:26:48 <hiptobecubic> oh, someone solved it for you :)
16:26:50 <hiptobecubic> my mistake
16:26:58 <carter> SrPx: i always a) use cabal
16:27:05 <SrPx> Welkin: ghc wasn't recompiling the unopt version when I used -O2, needed -fforce-recomp
16:27:08 <carter> b) when not using cabal, i use -fforce-recomp
16:27:22 <Axman6> Zemyla: I've never seen in, but I assume it's the opposite of UNBOX? If so, it specifically says "This should be a thunk, don't unbox it into the constructor"
16:27:41 <carter> Axman6: i think Zemyla  means constraint kinds
16:27:55 <carter> Zemyla: box is the kind of Constraints
16:28:00 <SrPx> I'll follow that now :) mind I have a very precise idea of the game I want to make, I'll not be happy with a simple pong
16:28:00 <carter> :t Num
16:28:01 <lambdabot>     Not in scope: data constructor ‚ÄòNum‚Äô
16:28:01 <lambdabot>     Perhaps you meant ‚ÄòSum‚Äô (imported from Data.Monoid)
16:28:04 <carter> :k Num
16:28:05 <lambdabot> * -> Constraint
16:28:12 <carter> i think Box == Constraint ?
16:28:15 <carter> i could be wrong though
16:28:22 <carter> @google box kind GHC
16:28:24 <lambdabot> https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/kind-polymorphism-and-promotion.html
16:28:49 <carter> huh
16:28:53 <carter> i'm confused
16:28:55 <carter> :k BOX
16:28:56 <lambdabot> Not in scope: type constructor or class ‚ÄòBOX‚Äô
16:29:10 <carter> Zemyla: ok, i have no clue what i'm talking about
16:30:00 <unknownloner> So as a haskell noob, if I were to write a basic minecraft clone, with the world split into 16x16x16 chunks, would it make more sense to make them immutable or mutable. And also, if they were mutable, would that force any code accessing them to be IO or ST (whichever was used)
16:30:10 <ReinH> Zemyla: What is "BOX"?
16:30:33 <unknownloner> 'basic minecraft clone' in this place means, the player can move about the world and edit it
16:30:38 <carter> ReinH: its a ghc kinda, i think
16:30:46 <ReinH> carter: I'm asking Zemyla for a reason :p
16:30:50 <carter> *kind
16:30:59 <carter> unknownloner: write the dumb version, then benchmark :)
16:32:17 <carter> unknownloner: hav eyou ever used criterion?
16:32:56 <unknownloner> Can't say I've heard of it
16:33:44 <carter> @hackage criterion is amazing for benchmarking
16:33:44 <lambdabot> http://hackage.haskell.org/package/criterion is amazing for benchmarking
16:33:54 <carter> as erikd  and many others will attest
16:34:17 <unknownloner> alright thanks
16:34:25 <Cale> unknownloner: This is a tough question if you want to do this at the scale that Minecraft does it and get really good performance, but probably using immutable unboxed 16x16x16 arrays wouldn't be too horrible
16:35:13 <unknownloner> I've written code that should do that now, though I'm not sure what a good test for it would be for performance
16:35:35 <Zemyla> ReinH: I don't know, that's why I was asking here!
16:35:36 <Cale> You can then have perhaps a Map of those arrays
16:35:37 <unknownloner> that and I havent written the renderer yet, but the renderer should be like dead simple anyhow, I've written block renderers enough
16:35:56 <Cale> If you want to stick to the immutable side of things
16:36:04 <Cale> Or maybe some spatial data structure would be better
16:36:12 <erikd> unknownloner: yes, criterion is really very good!
16:37:30 <srhb> SrPx: What did you change?
16:37:49 <Zemyla> Cale: A better data structure might perhaps be splitting each 16x16 block along the Z axis, then X, then Y, then Z, then X, then Y, and so on.
16:38:25 <Zemyla> Actually, that uses a bunch of extra pointers. :V
16:38:31 <Cale> Zemyla: yeah, I'm thinking it would be very useful to be able to relatively efficiently chop the structure along an axis aligned plane
16:39:31 <Welkin> srhb: he compiled with -O2 using force recompile
16:39:36 <srhb> Ah.
16:40:32 <SrPx> interesting, the pure int map performance almost didn't change with O2, but the mutable array is absurdly fast now ... guess I have what I need, at least
16:40:49 <joness> is there a way to use guards in lambda?
16:41:20 <joness> (\x | x == 0 = ... \n otherwise = ...
16:42:31 <enthropy> joness: -XLambdaCase looks like that
16:42:41 <Zemyla> Cale, unknownloner: Actually, if you are doing 16x16x16 arrays, store them in Z-order ( http://en.wikipedia.org/wiki/Z-order_curve ) or Hilbert order ( http://en.wikipedia.org/wiki/Hilbert_curve ).
16:43:09 <Zemyla> This improves locality when accessing objects.
16:43:22 <Cale> Zemyla: The question is how to store the collection of all such 16x16x16 arrays
16:43:47 <Cale> oh, that is what you mean
16:43:58 <Cale> I suppose you could store them in some linear order
16:44:49 <unknownloner> if you take the example of minecraft though you've got the problem of having a massive world with only certain sections of it loaded into memory at a time
16:45:18 <Welkin> you can stream the cotent
16:45:20 <Welkin> content*
16:45:27 <Zemyla> Well, they should be turned into 16 x 16 x 128 "stacks", since you want the entire z-axis loaded.
16:46:17 <unknownloner> If you mean up/down, go with Y axis in this case, since usually you write OpenGL code as Y = up/down
16:49:24 <unknownloner> oh actually I've seen this Z-order thing before, in rasterization, neat
16:52:28 <Zemyla> Oh, unknownloner, idea for optimization.
16:53:43 * hackagebot deepseq-magic 1.0.0.0 - Deep evaluation of data structures without NFData  http://hackage.haskell.org/package/deepseq-magic-1.0.0.0 (EdwardYang)
16:53:44 <Zemyla> Even though the blocks are in an array, if they're in Z-order, you can pretend they're a kind of tree.
16:54:45 <Zemyla> The 16x16x16 is made of 8 8x8x8s, which are each 8 4x4x4s, and so on.
16:55:09 <t4nk100> hello
16:55:19 <c_wraith> ezyang: so does it take advantage of knowing about GHC's closure types...
16:56:13 <Zemyla> And, since updating blocks is rare compared to rendering, you can make an optimization in the latter by doing a little extra work in the former.
16:57:05 <unknownloner> makes sense
16:57:11 <unknownloner> although
16:57:16 <unknownloner> updating and rendering are going to be pretty much linked
16:57:26 <unknownloner> since when I'm rendering it's going to be using pre-generated vertices
16:57:33 <unknownloner> which I only regenerate when the blocks are changed anyhow
16:57:44 <unknownloner> or rather, updating and rendering aren't linked?
16:57:45 <unknownloner> idk
16:59:06 <Zemyla> unknownloner: This is only when a block actually changes in a 16x16x16 chunk.
16:59:34 <unknownloner> right
16:59:56 <Zemyla> When a block is changed, you try and see if it's now identical to the 7 other blocks in the 2x2x2 cube.
17:00:43 <Zemyla> If it is, you set a flag at the top corner of that cube that says to the renderer, "Hey, you can render me as a 2x2x2 cube instead of 8 1x1x1 cubes."
17:01:12 <unknownloner> like an oct tree
17:01:23 <Zemyla> And then you go up a level, and see if it's identical to the otherb7 2x2x2 cubes.
17:01:27 <Zemyla> Precisely,
17:01:39 <unknownloner> although that's kinda pointless optimization for 2x2x2
17:01:44 <unknownloner> oh wait nvm
17:01:45 <unknownloner> inner sides
17:01:46 <unknownloner> right
17:01:48 <Zemyla> And do that all the way up to the 16x16x16 level.
17:02:51 <Zemyla> This is an especially big win for 16x16x16 air cubes, of which there will be many many many.
17:04:53 <Zemyla> It's also big for the network, where you can use it as a sort of RLE. "These next 64 cubes are all dirt. These next 8 cubes are all air." And so on.
17:08:44 * hackagebot deepseq-magic 1.0.0.1 - Deep evaluation of data structures without NFData  http://hackage.haskell.org/package/deepseq-magic-1.0.0.1 (EdwardYang)
17:09:14 <ReinH> This structure is called an "octree". It's the 3D version of a quadtree. :)
17:09:53 <ReinH> Oh unknownloner mentioned that.
17:12:20 <ezyang> c_wraith: Yeah
17:33:45 * hackagebot clanki 1.1.0 - Command-line spaced-repetition software  http://hackage.haskell.org/package/clanki-1.1.0 (marcusbuffett)
17:48:45 * hackagebot clanki 1.2.0 - Command-line spaced-repetition software  http://hackage.haskell.org/package/clanki-1.2.0 (marcusbuffett)
18:21:09 <Pamelloes> So I'm trying to write a parsec parser to parse a value. The parsed value needs to be associated with all of the tokens parsed to determine its value. Currently, I have long do blocks where some things are added just to the parsed tokens, and some are added to the calculated value and parsed tokens. This results in long, unwieldily do blocks. Any ideas for how to parse both aspects simultaneously in an idomatic fashion?
18:23:48 * hackagebot mtlparse 0.1.3.0 - parse library using mtl package  http://hackage.haskell.org/package/mtlparse-0.1.3.0 (YoshikuniJujo)
18:23:50 * hackagebot witty 0.0.3 - A network server to show bottlenecks of GHC  http://hackage.haskell.org/package/witty-0.0.3 (KazuYamamoto)
18:25:53 <lostman> hi folks. I have just tried installing haste but didn't get far. the compiler itself installs ok, haste-boot works too but when I try to 'haste-inst install react-haskell' it tries to reinstall and upgrade a bunch of libraries including hashable and that won't work. has anyone seen this before?
18:28:23 <carter> lostman: i like ghcjs personally, :)
18:30:49 <konne_> @pl \xs n -> take n xs
18:30:49 <lambdabot> flip take
18:33:49 * hackagebot language-lua 0.5.0 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.5.0 (OmerAgacan)
18:46:46 <gcganley> Pamelloes: editing you 6000 word doc... did you get to the typeclassopedia?
18:47:16 <EvanR> a picture is worth 1/6 of a 6000 word doc
18:47:36 <gcganley> EvanR: wow. such insight
18:47:45 <EvanR> ikr
18:48:07 <gcganley> EvanR: have you seen cokmett?
18:48:15 <lostman> carter: I do have ghcjs installed. just wanted to see how haste is doing ;-)
18:48:24 <carter> fair
18:48:25 <EvanR> no
18:48:55 <gcganley> EvanR: off the top of my head i think its github.cokmett.io
18:48:59 <gcganley> but let me look it up
18:49:43 <benzrf> cokmett
18:49:48 <benzrf> hsa he finally changed his name
18:50:47 <gcganley> EvanR: cokmett.github.io/cokmett
18:50:58 <EvanR> well im forking right now
18:52:26 <benzrf> would a cokmett be somebody who pulls a worrying number of commits
18:54:51 <gcganley> could someone explain what kan-extensions are? I'm just curious because i've heard of them every so often
18:57:25 <SrPx> Does anyone know how I make a "Unbox" instance for Color, defined on Gloss?
18:57:33 <SrPx> seems like I need it for "print $ fromListUnboxed (Z :. 1) [makeRawColor 1 1 1 1]"
18:57:49 <gcganley> :t (:.)
18:57:51 <lambdabot>     Not in scope: data constructor ‚Äò:.‚Äô
18:57:51 <lambdabot>     Perhaps you meant one of these:
18:57:51 <lambdabot>       ‚Äò:+‚Äô (imported from Data.Complex),
18:58:47 <EvanR> (.:) = (.) . (.)
18:59:11 <gcganley> EvanR: but he wrote (:.)
18:59:14 <Axman6> different thing
18:59:33 <SrPx> ?
18:59:42 <SrPx> REPA
18:59:56 <Axman6> it's basically a list of index types and values. 1 :. 2 :. Z :: Int :. Int :. Z
18:59:58 <Axman6> yes
19:00:34 <Axman6> SrPx: can you get the individual components of the colour? if so, then you should be abler to just use the instance for (,,,)
19:01:23 <Axman6> SrPx: see also https://hackage.haskell.org/package/vector-th-unbox
19:01:25 <SrPx> I can. How I do it?
19:01:59 <Axman6> that package is probably the easiest way
19:02:38 <Axman6> also, I'm sure you can convince Ben to add it to the package; repa and gloss are both his projects
19:02:53 <gcganley> Ben?
19:03:13 <Axman6> Ben Lippmeier
19:03:34 <benzrf> thats me!
19:03:40 <benzrf> [i am lying]
19:03:45 <gcganley> you arent benl23
19:03:57 <benzrf> > length "Lippmeier"
19:03:59 <lambdabot>  9
19:04:02 <benzrf> oh
19:04:03 <Welkin> benzrf is also not liyang
19:04:13 <gcganley> ^
19:05:00 <SrPx> benzrf: could you add it to the package
19:05:18 * SrPx is not convincing 
19:05:29 <SrPx> maybe if I add a question mark
19:06:23 <SrPx> why nothing is an instance of NFData t_t
19:06:41 <benzrf> SrPx: Nothing is a value,  not a type
19:06:44 <benzrf> it cant be an instance
19:07:26 <EvanR> why void is an instance of NFData
19:07:36 <gcganley> :t void
19:07:37 <lambdabot> Functor f => f a -> f ()
19:07:39 <EvanR> :t nothing
19:07:40 <lambdabot>     Not in scope: ‚Äònothing‚Äô
19:07:41 <lambdabot>     Perhaps you meant ‚Äò_Nothing‚Äô (imported from Control.Lens)
19:07:43 <gcganley> what the hell
19:07:51 <benzrf> :k Void
19:07:52 <lambdabot> Not in scope: type constructor or class ‚ÄòVoid‚Äô
19:07:53 <gcganley> where did the functor go
19:07:58 <rustyPipe> I had a quick question
19:08:04 <benzrf> > void [1, 2, ]
19:08:05 <EvanR> where have all the functors gone
19:08:05 <gcganley> rustyPipe: hit me
19:08:05 <lambdabot>  <hint>:1:13: parse error on input ‚Äò]‚Äô
19:08:07 <benzrf> > void [1, 2, 3]
19:08:08 <lambdabot>  [(),(),()]
19:08:17 <rustyPipe> What's the best resource to learn Haskell from?
19:08:19 <Lokathor> sqlite3 will not configure and install via cabal, despite having the .dll and .h files in the same directory as the cabal sandbox. Any guesses?
19:08:23 <gcganley> whats some weird stuff.
19:08:24 <benzrf> rustyPipe: https://github.com/bitemyapp/learnhaskell
19:08:35 <Lokathor> specifically, HDBC-sqlite3
19:08:49 <gcganley> rustyPipe: learn you a haskell for great good to start
19:08:50 <benzrf> rustyPipe: some people will tell you to read "Learn You A Haskell For Great Good" but it has some issues
19:09:17 <gcganley> benzrf: what problems do you have with it?
19:09:22 <benzrf> oy gevalt
19:09:28 <Lokathor> Learn You a Haskell is pretty good, but it also feels like only half a book by the time you get to the end. It just sorta stops suddenly.
19:09:28 <benzrf> can i not go a day without this happening
19:09:42 <benzrf> Lokathor: thats not really the problem w/ it
19:09:49 <benzrf> give me a minute tho im busy
19:09:50 <simon> haha
19:09:51 <EvanR> Lokathor: i think its been growing incrementally over the years, thats why
19:09:59 <simon> benzrf, you should write a blog post.
19:10:06 <benzrf> i dont have a blog
19:10:13 <simon> benzrf, okay, anything with a hyperlink, I mean.
19:10:16 <EvanR> yes publically denounce someones lifes work ;)
19:10:17 <gcganley> benzrf: WHY NOT. ILL FUCKING HOST IT
19:10:19 <Lokathor> benzrf: i never said it was the only possible problem with it ;)
19:10:48 <simon> EvanR, you're right... it should be done pseudonymously. ;)
19:11:13 <tacoshellmcgee> guys
19:11:13 <rustyPipe> I know about LYAHFGG, but I heard it's not that good to learn from
19:11:18 <tacoshellmcgee> Betty Lou's getting out tonight
19:11:21 <rustyPipe> What about Real World Haskell?
19:11:28 <ArisFr> Hi, does anyone know if it is possible to build GHC (e.g. 7.8.4) with a different dependency on Cabal (e.g. use Cabal-1.22 instead of 1.18)?
19:11:29 <geekosaur> RWH is not a great beginner book
19:11:29 <simon> rustyPipe, did you try?
19:11:37 <EvanR> @lyah
19:11:37 <lambdabot> Unknown command, try @list
19:11:38 <SrPx> benzrf: not funny
19:11:40 <SrPx> ¬¨¬¨
19:11:43 <rustyPipe> From LYAHFGG? Yeah, a while back
19:11:47 <gcganley> rustyPipe: there are tons of blogs. look up the dude that made pipes, his blogs are great
19:11:54 <Lokathor> Real World Haskell should take out the comments at this point... I always end up trying to read them too and getting distracted
19:11:57 <EvanR> ¬¨¬¨
19:12:06 <geekosaur> it has some beginner stuff but is better used after you've worked out some basic Haskell; it's about turning basic Haskell knowledge into working knowledge you can do things with
19:12:16 <gcganley> Lokathor: a good point came up that rwh is a bit outdated
19:12:30 <Welkin> LYAH is great as a way of first getting into the language
19:12:31 <simon> gcganley, apparently the real world progresses.
19:12:45 <Welkin> but it becomes far less useful once you actually want to start writing non-trivial programs
19:13:07 <Lokathor> gcganley: It wouldn't happen to be outdated in the sockets and database sections would it? I was about to start in on that very subject tonight...
19:13:33 <Welkin> I found this channel and the haskell wiki to be more helpful in that regard
19:13:48 <gcganley> Lokathor: i would go with blogs for that sort of inution. higher turnover rate of information.
19:13:52 <benzrf> rustyPipe: use
19:13:53 <benzrf> crap
19:13:54 <gcganley> mmm turnovers sound good
19:13:57 <Welkin> also, reading a lot of haskell programs written by other people
19:14:04 <benzrf> rustyPipe: use https://github.com/bitemyapp/learnhaskell
19:14:09 <Welkin> sigfpe has great blogposts
19:14:16 <Lokathor> others often seem to write haskell rather cryptically :/
19:14:18 <Welkin> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
19:14:20 <starless> sometimes I wrap my function arguments with parantheses and have an identity crisis
19:14:23 <benzrf> rustyPipe: LYAH will leave you in a state of nonunderstanding
19:14:26 <Welkin> my favorite article on monads
19:14:34 <gcganley> Welkin: I've always been shit at reading other peoples code. i really dont have the knack for it. IDK if its something learned or im just dumb
19:14:37 <EvanR> Lokathor: well theres idioms
19:14:59 <trap_exit> cabal appears broken ; how do I nuke all of my cabal?
19:15:02 <trap_exit> i.e. I want a blank slate
19:15:04 <trap_exit> this is osx
19:15:09 <benzrf> trap_exit: remove cabal
19:15:13 <Welkin> trap_exit: delete .cabal
19:15:14 <Lokathor> EvanR: any time a function becomes polymorphic on its monadic type my brain starts to lose track of what's supposed to be going on at that point
19:15:23 <trap_exit> benzrf: I got it via haskell platform
19:15:24 <Welkin> ~/.cabal
19:15:31 <gcganley> trap_exit: sudo rm -r ~/.ghc ~/.cabal; cabal update; cabal install cabal-install
19:15:37 <trap_exit> theres no ~/Library/Haskell/... that I need to clean up ?
19:15:40 <EvanR> Lokathor: heh. then pretend m = Identity
19:16:00 <Welkin> trap_exit: yes, on OSX it is in ~/Library/Haskell
19:16:15 <gcganley> trap_exit: are you trying to nuke the repo or the executable?
19:16:20 <trap_exit> so it's .ghc, .cabal, Library/Haskell/repo-cache that I need to nuke ?
19:16:26 <trap_exit> I need to nuke my cabal repo
19:16:37 <gcganley> trap_exit: sudo rm -r ~/.cabal ~/.ghc
19:16:40 <Lokathor> EvanR: year, I always pretend that m = IO and it makes more sense. Then I start trying to imagine how you'd use another monad instead, and Lovecraft music begins to play softly in the background
19:17:19 <gcganley> trap_exit: unless you mess with where its placed thats the usual nuke command
19:17:21 <EvanR> Lokathor: ill have to figure out wth lovecraft music is, is like that stephen king music? but IO?
19:17:22 <rustyPipe> Okay, this is my understanding of it
19:17:44 <rustyPipe> RWH is outdated and LYAHFGG doesn't go all that deep into the stuff
19:18:05 <trap_exit> mgngcganely: cool, thanks
19:18:17 <gcganley> rustyPipe: i like lyahfgg but there is that problem yes
19:18:23 <Welkin> rustyPipe: bitemyapp has a great resource page on github
19:18:35 <EvanR> rustyPipe: did you miss this from benzrf rustyPipe: https://github.com/bitemyapp/learnhaskell
19:18:38 <Welkin> Philip Wadler's haskell course is also on youtube
19:18:46 <gcganley> rustyPipe: go with bitemyapp and just get high on the information
19:18:52 <Lokathor> EvanR: Lovecraft music is perhaps something like this https://www.youtube.com/watch?v=qAkZT_4vL_Y
19:18:57 <gcganley> can someone still take FP101x?
19:19:01 <gcganley> i found that nice
19:19:05 <rustyPipe> Okay, so use bitemyapp's github page and Philip Wadler's online videos
19:19:15 <EvanR> Lokathor: hahahahahahaha
19:19:45 <Welkin> rustyPipe: https://www.youtube.com/watch?v=AOl2y5uW0mA&list=PLtRG9GLtNcHBv4cuh2w1cz5VsgY6adoc3
19:19:53 <gcganley> rustyPipe: later on if you want high performance haskell there is a great book by Simon Marlow on Parrellel and concurrent programming in haskell
19:20:18 <Welkin> actually, this one: https://www.youtube.com/watch?v=I1zhPHBiVBk&list=PLtRG9GLtNcHBv4cuh2w1cz5VsgY6adoc3&index=2
19:20:42 * bitemyapp grumbles awake and snorts
19:20:44 <gcganley> rustyPipe: I've never seen it but Philip Wadler's videos must be good because he co-created the damn language lol
19:20:53 <EvanR> Lokathor: that super improsed on techno music was great theme music for reading cryptic haskell code
19:20:57 <bitemyapp> gcganley: I didn't like the videos that much.
19:21:13 <bitemyapp> gcganley: Wadler's papers are brilliant if you're able to understand them, but I didn't like the video course. *shrug*
19:21:28 <gcganley> bitemyapp: not too good? we're trying to find resources for a beginer
19:21:36 <bitemyapp> gcganley: you know my recommendations :P
19:21:54 <gcganley> bitemyapp: yes we are very familier
19:21:56 <gcganley> lol
19:22:00 <bitemyapp> gcganley: I look for material voraciously. if I find something better, I will update the guide and notify everybody loudly :)
19:22:37 <gcganley> bitemyapp: do you have rwh listed? we've been discussing if its too outdated or not
19:23:06 <bitemyapp> gcganley: http://bitemyapp.com/posts/2014-12-31-functional-education.html
19:23:43 <gcganley> bitemyapp: i hate this... i have to get my mouse to use a web browser...
19:24:06 <EvanR> you can fix that
19:24:06 <Welkin> gcganley: that is one intelligent mouse
19:24:25 <gcganley> I need emacs bindings for chrome...
19:24:32 <gcganley> Welkin: I named him Bruce
19:24:45 <Lokathor> can't you make emacs run a shell command? then run lynx though that?
19:25:01 <EvanR> wget
19:25:11 <gcganley> isnt there eww now?
19:25:24 <gcganley> the meacs web browser or something
19:25:43 <gcganley> yup, there is HAHAHA
19:25:52 <bitemyapp> gcganley: vimium
19:25:58 <gcganley> sweet now i never have to take my eyes off of emacs
19:26:27 <gcganley> bitemyapp: I used that a ton for when i used vim. it was a massive hoot to use
19:26:41 <Lokathor> so why isn't cabal looking in the extra directories i'm specifying properly?
19:26:55 <bitemyapp> gcganley: I'm primarily an Emacs user, but I still use vimium.
19:27:02 <bitemyapp> mostly because vimium is relatively unobtrusive.
19:27:33 <gcganley> bitemyapp: I used vim exclusivly until I started writing clojure (or any other lisp)
19:28:20 <EvanR> gcganley: really, im using fire place at work
19:28:24 <EvanR> oh emacs, nvm
19:28:27 <bitemyapp> gcganley: I went in and out with Emacs.
19:28:49 <bitemyapp> gcganley: was serious about it with CL, took a break when I first started doing Python pro, picked it back up shortly before I started doing Clojure.
19:28:56 <bitemyapp> gcganley: stuck with it for Python/Clojure, then with Haskell.
19:29:42 <gcganley> bitemyapp: Things like python and java i use an IDE for. just not enough support on emacs and the IDE's out there are just too amazing
19:30:05 <gcganley> EvanR: Where do you work?
19:30:10 <Welkin> OH!
19:30:17 <Welkin> I forgot about Richard Bird's new book
19:30:32 <gcganley> Welkin: he has a new book? ive never read his books but i wanted to
19:30:50 <Welkin> http://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird/dp/1107452643/ref=sr_1_4?ie=UTF8&qid=1421724590&sr=8-4&keywords=haskell+functional+programming
19:31:00 <SrPx> http://lpaste.net/118806 does that mean I can't use sumP with a REPA array contianing "V4 Float"s? With just Float it works fine...
19:31:06 <gcganley> damn bitly that shit. it hurts my eyes
19:31:07 <bitemyapp> Welkin: I don't recommend that book except as a supplementary resource.
19:31:10 <EvanR> gcganley: java shop
19:31:14 <Welkin> that should be a great resource for a beginner
19:31:24 <bitemyapp> Welkin: it's really not enough though. Stops way too early.
19:31:37 <gcganley> EvanR: huh... do you have a git repo of your .emacs.d? I'd like to take a look
19:31:41 <bitemyapp> the second half is pretty dodgy as well.
19:31:53 <EvanR> gcganley: i dont use emacs, fireplace is clojure for vim
19:32:03 <gcganley> EvanR: oh ok lol
19:32:12 <gcganley> EvanR: you use clojure at work?
19:32:50 <Welkin> gcganley: it's all jvm
19:33:20 <gcganley> Welkin: do your collegues use clojure or do they write in vannila java (sorry for my bad spelling)
19:33:29 <Cale> http://hackage.haskell.org/package/repa-3.3.1.2/docs/Data-Array-Repa-Eval.html#t:Elt
19:33:38 <Welkin> gcganley: I think that was directed toward EvanR
19:33:54 <Pamelloes> gcganley: I read about 30 pages of the Typeclassopedia. I understood the first half pretty well, but I'm a little fuzzy as to the rest. I plan on rereading it sometime soon.
19:33:58 <Cale> SrPx: It's saying you need to define an instance of that class for V4 Float
19:34:00 <EvanR> gcganley: yes
19:34:14 <gcganley> EvanR: lol so mixed?
19:34:19 <Welkin> Pamelloes: the Typeclassopedia is something you will want to read multiple times over several months
19:34:25 <EvanR> i was answering a differnt question
19:34:27 <Welkin> every time you read it, you will understand it better
19:34:31 <gcganley> Pamelloes: wich ones do you not understand?
19:34:55 <gcganley> Pamelloes: Welkin does make a great point. I re-read it consitantly
19:34:58 <Welkin> the exercises are helpful as well
19:35:30 <Cale> SrPx: an empty instance declaration might do, if there's an instance of Generic for V4
19:36:07 <Pamelloes> I believe I fully understand functors. Everything beyond that my understanding isn't perfect. I'm pretty good with monads and applicatives. Monoids are dicey. Everything after that is a little mystifying.
19:37:02 <gcganley> Pamelloes: alot of people have trouble with Arrow's
19:37:17 <EvanR> bitemyapp: wow i read your blog post. pretty harsh on lyah!
19:37:42 <Pamelloes> gcganley: I didn't even make it to Arrows. I stopped right before Categories.
19:37:42 <gcganley> Pamelloes: monoids are easy to look at examples to build an intuition on what they are and how to use them
19:37:48 <bitemyapp> EvanR: you must not've read the whole post.
19:37:55 <EvanR> heh
19:37:58 <gcganley> Pamelloes: What do you think Monoid's are?
19:38:12 <bitemyapp> EvanR: I have partially-intentional content canaries in my articles so I know how far they read when people remark upon them.
19:38:24 <bitemyapp> EvanR: usually if they remark upon something earlier and not a content canary, I know they didn't finish it.
19:38:31 <EvanR> lol
19:38:42 <EvanR> i skipped the ones ive never heard of
19:38:48 <bitemyapp> EvanR: that was a mistake.
19:39:05 <Pamelloes> gcganley: They're combineable... things....
19:39:32 <gcganley> Pamelloes: lets look at some examples
19:39:36 <gcganley> Pamelloes: STRINGS!
19:39:42 <gcganley> :t (<>)
19:39:43 <lambdabot> Monoid m => m -> m -> m
19:39:46 <gcganley> :t (++)
19:39:47 <lambdabot> [a] -> [a] -> [a]
19:39:51 <Pamelloes> Yay!
19:40:02 <gcganley> Pamelloes: see the similarities?
19:40:07 <Pamelloes> mhm
19:40:18 <gcganley> > "123" <> "456"
19:40:19 <lambdabot>  "123456"
19:40:26 <gcganley> > "123" ++
19:40:28 <lambdabot>  <hint>:1:9:
19:40:28 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:40:29 <gcganley> crap
19:40:34 <gcganley> > "123" ++ "456"
19:40:35 <lambdabot>  "123456"
19:40:39 <gcganley> :t mempty
19:40:40 <lambdabot> Monoid a => a
19:40:43 <Welkin> a monoid has a binary operation that combines two things, and an identity value
19:40:48 <gcganley> :t mempty :: String
19:40:49 <lambdabot> String
19:40:52 <gcganley> crap
19:40:57 <Pamelloes> lol
19:41:15 <Welkin> + and 0
19:41:16 <gcganley> Pamelloes: it combines things together and it has an identity element
19:41:17 <Welkin> * and 1
19:41:26 <gcganley> ++ and ""
19:41:39 <gcganley> :t mconcat
19:41:40 <lambdabot> Monoid a => [a] -> a
19:41:43 <Pamelloes> I was doing research into WriterT, so I understand more or less how monoids work. They just sort of mystify me to applications out of that
19:42:12 <gcganley> Pamelloes: have you heard of diagrams?
19:42:19 <gcganley> the haskell library
19:42:25 <Welkin> Pamelloes: I used them in an alchemy system I wrote for combining game items to create new game items
19:42:41 <Pamelloes> gcganley: Nope.
19:42:50 <Pamelloes> Welkin: Huh, that actually makes a lot of sense
19:43:32 <gcganley> Pamelloes: now there is something called a semigroup
19:43:44 <gcganley> Pamelloes: which is like a monoid, but with no identity element
19:43:55 <Pamelloes> I read about that. It didn't make much sense.
19:44:14 <gcganley> Pamelloes: its literally just a monoid without a idenetity element
19:44:24 <Welkin> all monoids are also semigroups
19:44:42 <gcganley> Pamelloes: So it can just combine whold things together but cant do cool things like mconcat
19:44:44 <gcganley> :t mconcat
19:44:45 <lambdabot> Monoid a => [a] -> a
19:44:51 <Pamelloes> What's an example of something that's a semigroup but not a monoid.
19:45:03 <gcganley> mconcat = foldr mappend mempty
19:45:13 <Welkin> Pamelloes: I still wonder that too
19:45:26 <Pamelloes> gcganley: Why can't you just do mconcat = foldr1 mappend?
19:45:29 <gcganley> Pamelloes: ughhh they gave one in rwh i just have to dig it up
19:45:44 <gcganley> Pamelloes: only works for lists i think
19:45:46 <SrPx> just double checking, if I have 4 slow computations, the right way to parallelize them is: a `par` b `par` c `par` d `pseq` f a b c d, right? I mean, 3 pars and 1 pseq
19:46:10 <gcganley> SrPx: I only use the par monad for that sort of stuff...
19:47:22 <gcganley> Pamelloes: there is a Max and Min data types that dont form a monoid but form a semigroup. whats the empty version of a set of numbers to find the Max? there is none. so it forms a monoid
19:47:47 <Pamelloes> Ah, that makes sense :)
19:48:12 <bitemyapp> shachaf: I don't do much of the helping there anymore. Don't need to.
19:48:33 <Pamelloes> On a different note: Do you know a method of turning WriterT a m b into WriterT b m () ?
19:48:34 <gcganley> Pamelloes: rule of thumb when working with a lot of these type classes is to go with the 'weakest' one that fits your needs
19:49:07 <Pamelloes> gcganley: That's helpful to know :)
19:49:39 <gcganley> Pamelloes: so if Functor fits your bill. dont try and  build a monad
19:50:26 <Pamelloes> But if I build a monad, I can use do :P
19:50:37 <Pamelloes> (but fair enough)
19:51:23 <gcganley> Pamelloes: do notation can sometimes be quite harmfull and take you away from a more elegent abstraction (if i can use buzzwords)
19:51:57 <gcganley> :t liftM2
19:51:58 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:52:02 <gcganley> :t liftM2 id
19:52:03 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
19:52:48 <Pamelloes> I'm confused
19:53:13 <Pamelloes> what does liftM2 id do? id takes what argument so shouldn't it be liftM id?
19:53:34 <Pamelloes> :t liftM id
19:53:34 <lambdabot> Monad m => m r -> m r
19:53:38 <gcganley> nope
19:53:42 <gcganley> :t (<*>)
19:53:43 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:53:48 <gcganley> :t liftM2 id
19:53:49 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
19:53:54 <gcganley> look similar?
19:54:01 <Pamelloes> Yep
19:54:18 <gcganley> that because a monad can become a applicative functor
19:54:32 <gcganley> but an applicative functor cannot become a monad
19:54:42 <Pamelloes> Monads have to be applicative functors as of the newest ghc
19:54:44 <gcganley> unless it can be
19:54:55 <gcganley> Pamelloes: yes they do. about time too
19:55:54 <gcganley> now you can use applicative sugar with every monad, and also fmap for every monad because of the applicative dependency i belive
19:56:31 <Pamelloes> Actually, that reminds me: If I have a type that is an instance of Monad, can I make it an instance of Functor and Applicative by simply defining the functions in terms of the monad functions?
19:56:59 <Welkin> Pamelloes: yes
19:57:22 <Welkin> which is amusing
19:57:30 <lpaste> Lokathor pasted ‚ÄúHSCurses failed build‚Äù at http://lpaste.net/118811
19:57:39 <gcganley> Pamelloes: yes! for applicative all you have to do is pure = return; (<*>) = ap
19:58:06 <Lokathor> does anyone know why the HSCurses library would fail to compile properly?
19:58:26 <Pamelloes> Similarly, if I have a type that is an instance of Ord, can I make its Eq instance: a == b = (a`compare`b)==Eq?
19:58:47 <Lokathor> i mean i see the obvious errors... am i missing a library? a versioning issue?
19:58:52 <Pamelloes> Or more idiomatically: (==) = (== Eq) . (compare)
19:58:53 * hackagebot hsshellscript 3.3.3 - Haskell for Unix shell scripting tasks  http://hackage.haskell.org/package/hsshellscript-3.3.3 (VolkerWysk)
19:59:17 <gcganley> Pamelloes: ive never done it before but it makes sense... i would test it first though
19:59:19 <benzrf> Pamelloes: actjually thats wrong
19:59:29 <benzrf> :t (==Eq) . compare
19:59:30 <lambdabot>     Not in scope: data constructor ‚ÄòEq‚Äô
19:59:30 <lambdabot>     Perhaps you meant ‚ÄòEQ‚Äô (imported from Data.Ord)
19:59:34 <benzrf> :t (==EQ) . compare
19:59:35 <lambdabot>     Couldn't match type ‚Äòa -> Ordering‚Äô with ‚ÄòOrdering‚Äô
19:59:35 <lambdabot>     Expected type: a -> Ordering
19:59:35 <lambdabot>       Actual type: a -> a -> Ordering
19:59:44 <benzrf> Pamelloes: that becomes, e.g.,
19:59:52 <benzrf> (==EQ) $ compare 3
19:59:53 <Hijiri> Lokathor: maybe the names of functions where blockM and unblockM are have changed since hscurses was written?
19:59:56 <benzrf> compare 3 == EQ
19:59:57 <Hijiri> hscurses seems pretty old
20:00:05 <Hijiri> as far as haskell libs go
20:00:20 <Pamelloes> benzrf: Fine: (== EQ) . (compare .)
20:00:27 <Pamelloes> Should work, I think.
20:00:37 <Pamelloes> Maybe I have to rearrange the dots, but it can be made to work
20:00:38 <benzrf> actually
20:00:41 <Lokathor> Hijiri what's weird is that it built just the other day on another machine >_>
20:00:42 <enthropy> @unpl \x y -> EQ == compare x y
20:00:42 <lambdabot> \ x y -> (EQ) == (compare x y)
20:00:43 <benzrf> ((==EQ) .) . compare
20:00:46 <enthropy> @pl \x y -> EQ == compare x y
20:00:46 <lambdabot> ((EQ ==) .) . compare
20:00:55 <benzrf> im not sure i'd call that more idiomatic :U
20:00:58 <Hijiri> Lokathor: were you using the same versions of base?
20:00:59 <benzrf> just do the pointful version
20:01:11 <Hijiri> If you're using a newer version of base, maybe that pulled in a newer version of some other library
20:01:18 <Hijiri> which brought in changed names
20:01:21 <pavonia> Lokathor: block and unblock have been removed from the base package
20:01:27 <Lokathor> Hijiri: how would I check that?
20:01:28 <SrPx> how can I check if GHC is actually creating threads on my "par" code? I got a speedup of <10% for 4 cores, and I sparked 4 threads with the absolute same type of work. It doesn't make sense :(
20:01:32 <Hijiri> wait oh
20:01:37 <Hijiri> unblockM is part of hscurses
20:01:49 <Lokathor> pavonia: oh, can i get block/unblock  from another package?
20:01:51 <Pamelloes> :t \t->(== EQ) . (compare t)
20:01:52 <lambdabot> Ord a => a -> a -> Bool
20:01:58 <Welkin> > let fmap' f a = return . f =<< a in fmap' (+3) (Just 5)
20:02:00 <lambdabot>  Just 8
20:02:00 <Pamelloes> There we go!
20:02:05 <Virus-X> Hello quick question. Does the Haskell Network.Socket accept function block if no connection is currently queued?
20:02:17 <glguy> it does
20:02:21 <Lokathor> i hope it does
20:02:23 <pavonia> Lokathor: You can use Control.Exception.mask instead
20:03:08 <Welkin> benzrf: pl all the things
20:03:10 <Lokathor> uhm, so if i just go in and fiddle with the .hs files now that they're downloaded will cabal notice and/or care?
20:04:08 <Pamelloes> gcganley: I'm debating redefining DataType with monads/functors. Do you think a BitSeries is a context for a Primitive, or a Primitive is a context for a BitSeries?
20:04:13 <Hijiri> it might be better to cabal get the sources in another directory and make the modifications there
20:04:19 <Hijiri> and then add source to your sandbox
20:04:20 <Lokathor> okay
20:04:24 <Hijiri> if you are using sandboxes
20:04:41 <Lokathor> i would like to... not sure how to switch my current drive leter in cygwin actually
20:04:50 <Lokathor> usually i do my developmenton my D drive and not C
20:05:06 <Hijiri> I just mean cabal sandboxes
20:05:29 <Lokathor> right, but to compile it i have to go through cygwin to have curses in the path properly
20:05:32 <gcganley> Pamelloes: I actually have to go to bed. I'll look at it tomorrow at like.. 9am est OK?
20:05:40 <Hijiri> oh, ok
20:06:48 <Pamelloes> gcganley: I probably won't be active again until 6 or 7 pm est tommorrow. Maybe later. If you get around to looking at it, PM me and I'll take a look once I get around to it
20:07:13 <Lokathor> so "fetch" is the command i want?
20:09:29 <Lokathor> says it's cached and now it won't download it again
20:09:36 <Lokathor> time to hunt through my C drive
20:10:57 <gcganley> Pamelloes: it doesnt look like it can be. It has to have a kind of * -> * (think of Maybe or IO where they take a type argument)
20:11:13 <Hijiri> Lokathor: I was pretty sure it was cabal get
20:11:46 <Pamelloes> gcganley: I was thinking of doing something like type DataType' = Writer BitSeries Primitive
20:11:51 <Lokathor> oh, so it is. i guess "get" puts it in the current directory, and "fetch" puts it in the normal sources location
20:12:32 <gcganley> Pamelloes: if that has a kind * -> * and if we could get to the `a`'s then we'd have at least a functor
20:13:02 <gcganley> Ive never used the Writer monad before though
20:13:32 <Pamelloes> gcganley: That has kind *; It has the same information but stored differently.
20:14:33 <gcganley> Pamelloes: wait... if we're working with writer than we're fine to use fmap for Writer. we dont need to write one for Writer
20:14:41 <gcganley> i mean BitSeries
20:15:24 <gcganley> but i have to get my 5 hours of sleep lol
20:15:25 <gcganley> gn
20:15:29 <Pamelloes> Alright, gn
20:18:54 <arbelos> Does anyone know how to reinstall the haskell-platform on Debian?
20:19:44 <Pamelloes> Given a :: ParsecT s u m a, How would I fmap a function of the type (m a) -> (n b)?
20:20:08 <Pamelloes> To change a to type ParsecT s u n b
20:20:33 <Lokathor> pavonia: HSCurses seems to want both block and unblock, but when using mask instead there doesn't seem to be an "unmask" to go with it
20:20:44 <Lokathor> will forkIOUnmasked work?
20:20:48 <Pamelloes> arbelos: Wouldn't that just be apt-get reinstall, or whatever the exact command is?
20:22:06 <pavonia> Lokathor: Yeah, I had a look at it but I don't know how to use it. The mask function is meant to be a replacement for block and unblock, though
20:22:34 <arbelos> i am trying that. I first did an uninstall, which left most of it intact.. I then tried to remove the files manually which seems to have broken everything
20:23:13 <arbelos> so, when i try to install using apt-get install, it says "ok, done" but nothing is installed
20:23:51 <arbelos> i'd like to remove everything and install again, afresh
20:24:05 <Pamelloes> mm, I haven't used debian in a while so I can't really help you :(
20:24:18 <Lokathor> well i give up on hscurses for now then. Making yet another curses wrapper will be my FFI project some day
20:24:43 <EvanR> sounds like an advanced project
20:24:53 <EvanR> if youre messing with async exception masks
20:25:51 <Lokathor> Yeah I don't even know what that stuff was for, curses is a really basic C library and the block/unblock stuff was in some advanced Monadic wrapper section that wasn't even part of the main file
20:27:10 <EvanR> ncurses doesnt look too basic
20:27:42 <EvanR> and its concurrent?
20:28:24 <Lokathor> as far as i know, curses is not a concurrent library. it takes control of stdout and uses escape sequences to reconfigure the terminal on the fly, that's it
20:28:42 <arbelos> apt-get remove --auto-remove haskell-platform (maybe that could do the trick)
20:29:25 <Lokathor> arbelos: make sure that you remove your ~/.ghc and ~/.cabal directories. I'm not sure if it was you or someone else asking about that earlier, but that was the problem i had when resintalling haskell platform
20:30:16 <EvanR> Lokathor: what happened when you tried to use the existing bindings
20:30:17 <arbelos> Lokathor: thanks.
20:31:38 <Lokathor> EvanR: Which existing bindings?
20:31:51 <EvanR> https://hackage.haskell.org/package/ncurses
20:32:05 <EvanR> are you not on *nix?
20:32:19 <Lokathor> oh, well I haven't looked at that version of the bindings so closely
20:32:42 <EvanR> heh, it might be prudent to use this instead of writing replacement bindings, especially if they work
20:33:25 <Lokathor> ah, i tried cabal just now, and I remember now why i didn't use haskell's ncurses package: doesn't build on windows it seems
20:33:49 <EvanR> makes sense then, theres no ncurses on windows
20:34:07 <Lokathor> it says i need "c2hs" >= 0.15 , but could not be found
20:34:20 <EvanR> try cabal install c2hs
20:34:40 <Lokathor> however, there is curses on windows
20:34:41 <Lokathor> is the thing
20:35:18 <Lokathor> either ncurses (the C library) via cywin, or you can even run pdcurses without cygwin
20:35:55 <EvanR> pdcurses right, i havent heard much success stories with that
20:36:05 <EvanR> youre confirming ;)
20:36:21 <Lokathor> oh right now i'm not using pdcurses
20:36:28 <Lokathor> i'm using ncurses in cygwin
20:37:00 <Lokathor> installed c2hs of a high enough version, now the ncurses package says...
20:37:12 <lpaste> Lokathor pasted ‚ÄúNo title‚Äù at http://lpaste.net/118813
20:37:18 <EvanR> need to develop unix software is why i stopped using windows ;)
20:38:24 <geekosaur> sounds like your ncurses is too old; wide-character is default in current ncurses but it sounds like the one you have installed only does narrow CChar-s
20:39:04 <geekosaur> (older versions of ncurses had a separate set of headers and libraries for wide character / Unicode support; still older ones didn't support it at all)
20:42:12 <geekosaur> if your ncurses is the first one, you may need to add some cabal options to make it find the wide-character versions of the headers and libraries (often an include/ncursesw subdirectory and, on Windows, (lib)ncursesw.dll)
20:43:30 <geekosaur> also, curses is kinda funky on Windows anyway, so I would not be surprised if various things fail in odd ways. (Unix ncurses uses terminal escape sequences; WIndows provides that functionality as device driver commands, the equivalent of Unix ioctl())
20:43:56 <geekosaur> cygwin can only do so much to paper over the differences between Unix and Windows
20:45:43 <Lokathor> geekosaur, ncurses my C library is too old, or ncurses the Haskell library is too old? the haskell version i pulled down via cabal just today
20:46:24 <geekosaur> the C library
20:46:27 <Lokathor> oh, hmm
20:46:37 <Lokathor> It's not the worst thing in the world if it doesn't work
20:46:43 <geekosaur> the Haskell one is just a wrapper for the C one --- but if the C one is too different, the Haskell one will fail in the way you are seeing
20:47:19 <geekosaur> and at this point the ncursesw merge is close to 10 years old... even Debian has mostly caught up with it
20:47:56 <Lokathor> i also got my ncurses out of cygwin just now, so i expect that it's a recent enough version
20:48:24 <geekosaur> *but* I am not sure that the Windows implementation of ncurses, which is radically different internally, is easily updated to match the ncursesw merge
20:49:35 <geekosaur> (although cygwin might use the Unix impl and require you to use its bash that creates a terminal window that emulates Unixy escapes and does the Windows device driver calls... been a long time since I messed with cygwin)
20:50:01 <Lokathor> I'll just have to implement a curses-style system within SDL ;)
20:50:12 * geekosaur does not like cygwin much; it manages to hide just enough of Windows to really bite his *ss when he invariably hits soemthing that *can't* be papered over...
20:51:01 <Pamelloes> And that's why Intel added VT-X
20:51:06 <Lokathor> a classic "if only more of my Steam library ran on linux" moment for us all
20:52:03 <Pamelloes> Steam actually started supporting linux directly, though...
20:52:26 <Pamelloes> And wine really has made great advances over the past couple of years.
20:58:16 <Lokathor> of this, i am aware
21:06:10 <gigawatts> interesting reactions from the word on the street http://i.imgur.com/vLsagVC.jpg
21:06:39 <arbelos> the problem when I try to reinstall haskell platform seems to be that it thinks base is already installed.. so it fails to install base even though I have removed everything
21:06:49 <arbelos> i am running: apt-get remove --auto-remove haskell-platform
21:06:56 <arbelos> sudo apt-get purge haskell-platform
21:07:00 <arbelos> rm -rf ~/.cabal
21:07:03 <arbelos> rm -rf ~/.ghc
21:07:12 <arbelos> rm -rf /var/lib/ghc
21:07:23 <Welkin> arbelos: the platform comes with a utility called hp-uninstall
21:07:26 <Welkin> or something similar
21:07:34 <Welkin> also
21:07:38 <arbelos> where is it?
21:07:50 <Welkin> do not install it from your distro's repo if possible
21:08:22 <arbelos> ok, actually maybe i didn't do that the first time i installed it.. hmm
21:08:27 <Welkin> it should be located in the same directory as ghc
21:08:30 <lfairy> Welkin: why not?
21:08:43 <Welkin> lfairy: because it's out of date
21:09:23 <Welkin> https://www.haskell.org/platform/
21:14:05 <hop_> Is it reasonable to use infinite lists and to rely on GC to have bounded memory consumption? This example: https://gist.github.com/anonymous/939aba79512fae851e94 has bounded memory usage (on my machine). Obviously this one: https://gist.github.com/anonymous/a9333c381d4f1c26b59b  has not. More surprisingly, this one  https://gist.github.com/anonymous/3fd9188a03ab6221c6ed is bounded . Is there no common sub-expression elimination in Core?
21:16:47 <EvanR> if you hold on to some prefix of an infinite list while also traversing down into it, youll consume a lot of memory
21:17:28 <EvanR> well, it depends on the list
21:17:43 <hop_> EvanR: I know. But is it reasonable to assume that GC will get rid of the heads? Also, how CSE interacts with that?
21:18:02 <EvanR> i dont think ghc does cse
21:18:20 <EvanR> if you dont hold on to the heads, the gc will get them, probably soon
21:18:27 <glguy> -fcse On by default.. Enables the common-sub-expression elimination optimisation. Switching this off can be useful if you have some unsafePerformIO expressions that you don't want commoned-up.
21:18:47 <EvanR> whoa
21:18:48 <glguy> (I don't know which CSE it actually does, but it has a flag for it
21:19:38 <EvanR> id be interested to know if and what cse happens
21:20:14 <hop_> EvanR: no CSE in core? or no CSE in next stages (cmm and the rest)? So is it reasonable to assume GC of lists heads with infinite lists? Is it something people do (in an idiomatic way)?
21:21:21 <glguy> GHC is specifically careful about CSE like that to void the memory problem you anticipated
21:23:33 <hop_> glguy: OK!
21:46:11 <karshan> @src lefts
21:46:11 <lambdabot> Source not found. My pet ferret can type better than you!
21:46:20 <karshan> @src Data.Either.lefts
21:46:20 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:46:38 <systemfault> Why would I ever need the non-transformers versions of reader/state/writer/etc? (still trying to build my intuition)
21:47:18 <karshan> :i State
21:47:24 <karshan> >:i state
21:47:30 <karshan> > :i State
21:47:31 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
21:47:39 <karshan> @src State
21:47:39 <lambdabot> Source not found. Take a stress pill and think things over.
21:48:12 <systemfault> :k State
21:48:13 <lambdabot> * -> * -> *
21:48:38 <systemfault> :k StateT
21:48:39 <lambdabot> * -> (* -> *) -> * -> *
21:50:13 <Axman6> karshan: lambdabot is not ghci, it just acts like it sometimes
21:50:23 <Axman6> s/it/she/
22:43:02 <gamegoblin> Is there a GHC extension that lets you assign default values to record constructors?
22:43:39 <gamegoblin> so Data Blah = Blah { wat = 5 :: Int } would then enable me to do Blah { } and it would fill in wat = 5 for me
22:44:05 <EvanR> you can do that with a default record d, then set the few fields how you want with d { wat = 5 }
22:44:11 <EvanR> or just d
22:46:22 <gamegoblin> Yeah, I was just wondering if there was a way I could inline them into the actual data definition and have GHC desugar it
22:47:15 <pavonia> You can also define an instance of the Default class
22:47:25 <pavonia> @hackage data-default
22:47:25 <lambdabot> http://hackage.haskell.org/package/data-default
22:47:36 <gamegoblin> huh, didn‚Äôt know about that one
22:49:04 <glguy> gamegoblin: The answer to your specific question is "no, GHC can't do that as described"
22:49:18 <gamegoblin> glguy: thanks ;)
22:56:08 <vanila> hi #haskell
23:00:05 <adu> hi vanila
23:05:31 <EvanR> whats a basic way to find all the items in a Map which have key less than or greater than a value
23:05:38 <EvanR> rather than equal
23:05:51 <EvanR> or which data structure can do this
23:05:58 <glguy> There's a partition function in map
23:06:16 <EvanR> oh awesome
23:06:31 <glguy> split :: Ord k => k -> Map k a -> (Map k a, Map k a)
23:07:26 <glguy> Poke around in there http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map-Lazy.html#g:20
23:11:13 <Enigmagic> filterWithKey seems appropriate
23:11:24 <Enigmagic> split might be faster
23:11:59 <EvanR> yeah but filterWithKey would be simpler and faster than doing two splits followed by a intersection
23:12:07 <EvanR> for a a < k < b kind of search
23:14:23 <Enigmagic> depends on the size of the trees and the intersection i'd imagine
23:14:33 <glguy> two splits will be faster than one filter with key in general
23:14:44 <Enigmagic> split is pretty fast, but intersection isn't so much..
23:15:37 <EvanR> nvm, this wont work either, i want to find out which region (if any) the mouse is in. maybe the pktree package
23:16:00 <opqdonut> you don't need an intersection?
23:16:00 <EvanR> i guess this is a spatial index problem
23:16:39 <opqdonut> split all -> less-than-a, more-then-a, then split more-then-a -> between-a-and-b, more-than-b
23:19:59 <EvanR> that split operation is really handy though
23:24:47 <steffen> How do I pattern match on a big long product-type within a case statement where I want all fields to be bound but the case differentiates only on one filed?
23:25:14 <steffen> field*^^
23:25:48 <opqdonut> can you do something like "let Constructor a b c d important e = val in case important of Foo -> ... Bar -> ..."?
23:26:18 <vanila> steffen, you could abstract this pattern out of the data type itself
23:28:05 <steffen> opqdonut: That is a good idea! Thanks!
23:28:32 <steffen> vanila: I do not understand :) how do you mean?
23:28:41 <vanila> Ah sorry I actually misunderstood your question
23:28:52 <vanila> I thought it was not just one constructor
23:29:00 <steffen> vanila: ahh ok :)
23:41:28 <srhb> steffen: Otherwise it might be worth noting that any record-type definition Foo { a :: ..., b :: ... } can also be understood as Foo a b
23:42:02 <shachaf> You mean Foo ... ... :-)
23:42:03 <srhb> steffen: Thus making important a function for extracting that one parameter, should you desire.
23:42:13 <srhb> shachaf: HUrgh, yes, thanks.
23:47:03 <Lokathor> >cabal-install-1.22.0.0 depends on Cabal-1.22.0.0 which failed to install.
23:47:05 <Lokathor> is this normal?
23:47:24 <steffen> srhb: Thanks, you are right, but i think the first approach from opqdonut suites me well for my problem :)
23:47:51 <srhb> steffen: Great. :)
23:49:55 <geekosaur> iirc Cabal 1.22 is somewhat broken at the moment
23:50:31 <geekosaur> it's out there in prerelease for ghc 7.10-rc1 but the changes needed for that caused problems with using it in 7.8.x
23:51:22 <srhb> Lokathor, geekosaur: It builds here on 7.8.4
23:51:49 <Lokathor> ahhh, well i'm using GHC 7.old so i should maybe update that then
23:52:09 <srhb> Lokathor: Or just wait. Do you really need it?
23:52:34 <Lokathor> well i need a version of cabal that can sandbox, i'm on 1.14 which cannot
23:52:40 <geekosaur> it's hit and miss and depends to some extent on what Cabal library is already installed because there's some backward compatibility issues
23:52:43 <srhb> Lokathor: Just get 1.18 then
23:52:50 <srhb> At least I think it's 1.18
23:52:53 <Lokathor> how does one specify that i want 1.18 specifically?
23:53:26 <srhb> Lokathor: cabal install cabal-install-1.20.0.6 -- try that version
23:53:27 <geekosaur> --constraint='Cabal=1.18.*'
23:54:04 * hackagebot monad-control 1.0.0.2 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-1.0.0.2 (BasVanDijk)
23:54:20 <srhb> Otherwise go further down.
23:54:55 <Lokathor> cabal --dry-run predicts that it will be able to do 1.20
23:54:59 <Lokathor> so i will try that
23:55:17 <Lokathor> however, it will take probably an hour to build at least, so i suspect i won't check back on it tonight
23:55:36 <fred3> hi
23:56:08 <Lokathor> hi fred3
23:56:14 <mjrosenb> this doesn't bode well
23:56:19 <mjrosenb> I have Data.ByteString
23:56:37 <mjrosenb> but not Data.ByteString.Utf8
23:56:50 <mjrosenb> err, UTF8
23:57:10 <fred3> Hello
23:57:43 <srhb> mjrosenb: That package is from utf8-string I think. Do you really need it?
23:57:59 <srhb> mjrosenb: iirc it's old.
23:58:08 <srhb> That module* is from ...
23:58:16 <mjrosenb> oh, what should I use instead?
23:58:23 <srhb> mjrosenb: What are you trying to do?
23:58:32 * mjrosenb didn't see any indeication that it is old
23:58:42 <srhb> fred3: Why are you poking in private messages?
23:59:02 <geekosaur> is it bad spanish pointing you at a website?
23:59:19 <srhb> geekosaur: It's "hello"
23:59:20 <mjrosenb> srhb: I'm trying to decode a ByteString that I believe holds UTF8.
