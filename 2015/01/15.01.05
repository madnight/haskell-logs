00:09:44 * hackagebot bindings-levmar 1.1.0.3 - Low level bindings to the C levmar (Levenberg-Marquardt) library  http://hackage.haskell.org/package/bindings-levmar-1.1.0.3 (BasVanDijk)
00:09:44 * hackagebot debian-build 0.4.0.1 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.4.0.1 (KeiHibino)
00:14:38 <dgomez> ?
00:18:11 <calvinx> is there a way to introspect ‘stuff’ in a running wai/warp app in ghci ?  For instance, I want to explore a ‘req’ that’s given to my Application.
00:21:53 <calvinx> looks like emacs has haskell mode - https://github.com/haskell/haskell-mode/wiki/Haskell-Interactive-Mode-Debugger
00:23:18 <calvinx> another way seems to be to set the ghci option with -fbreak-on-exception
00:23:32 <calvinx> is there a way to introduce breakpoints?
00:23:56 <EvanR> yes you can. you can also Debug.trace things in your pure code
00:24:29 <solatis> is there a Debug.traceWithStackTrace already?
00:24:41 <solatis> Debug.trace is very useless in a lot of real-world debugging scenarios
00:25:09 <EvanR> +RTS -xc may give some sort of stack trace when a compiled program crashes
00:25:11 <solatis> (i know, that would require compiling with -prof, yada yada)
00:25:47 <calvinx> how do you use Debug.trace?
00:25:50 <solatis> yeah i know, but i personally avoid exceptions whenever i can -- but it can still be useful to log a stack trace once in a while
00:25:55 <solatis> :t Debug.trace
00:25:56 <lambdabot> Not in scope: ‘Debug.trace’
00:26:00 <solatis> :t trace
00:26:01 <lambdabot> Not in scope: ‘trace’
00:26:07 <solatis> ok, well, pretty simple
00:26:16 <solatis> Debug.trace ("about to call f") (f)
00:26:18 <EvanR> :t Debug.Trace.trace
00:26:19 <lambdabot> String -> a -> a
00:26:41 <EvanR> im not sure "show a stack trace" works just anywhere in code
00:27:09 <EvanR> im not sure what would be useful to see at any given moment
00:28:34 <calvinx> how do I import Debug.trace...
00:28:47 <tdammers> import Debug.Trace (trace) -- ?
00:28:49 <solatis> import Debug.Trace (trace)
00:29:04 <calvinx> pfff. ok. lol.
00:29:12 <tdammers> import qualified Debug -- then use as Debug.trace
00:30:29 <Black0range> Hey guys, I'm getting this problem where "listen" doesn't work on a socket... anyone know why? http://lpaste.net/117804
00:30:51 <calvinx> This doesn’t work http://lpaste.net/117803
00:31:22 <EvanR> Black0range: try not using 50, i saw 5
00:31:28 <EvanR> pretty often
00:31:34 <calvinx> type doesn’t match.
00:31:45 <EvanR> Black0range: another one is that Datagram sockets dont listen
00:32:10 <solatis> Black0range: https://github.com/solatis/dissent/blob/master/src/Dissent/Network/Socket.hs
00:32:18 <solatis> feel free to take a look there for some wrapper functions i personally use
00:32:41 <EvanR> Black0range: use recvFrom or whatever the equivalent is in that module to wait for a message on that socket
00:34:16 <raisin_> Quick question: what does this syntax mean? "instance Monoid a => Monoid (Maybe a)" I understand that it's a type class instance, but why is the => needed and why does the monoid have a type parameter 'a'? Why isn't it just, say, "instance Monoid (Maybe a)"?
00:36:00 <EvanR> that instance will use the monoid operations on the type a in the implementation of the monoid operations for Maybe a
00:36:38 <EvanR> but without the Monoid constraint on a, you dont know a has any such operations
00:37:21 <tdammers> this also means that Maybe a is an instance of Monoid iff a is also an instance of Monoid
00:38:17 <raisin_> So what does the fat arrow signify?
00:39:45 <EvanR> the left side is the constrains on type variables appearing on the right
00:41:22 <EvanR> raisin_: this syntax appears also in type signatures
00:41:27 <EvanR> :t mappend
00:41:27 <lambdabot> Monoid a => a -> a -> a
00:43:01 <raisin_> Oh, I think I get it now
00:43:24 <solatis> what does an 'orphane instance: instance MFunctor blah' mean? it's incredibly annoying with -Wall -Werror
00:44:01 <solatis> as i understand, it's an instance defined in a module it should not be defined at ?
00:44:03 <raisin_> If you strip away the type constraints part, it looks exactly like what I wanted it to look like
00:44:04 <tdammers> EvanR: it's shorthand for forall a. Monoid a => a -> a -> a
00:44:12 <tdammers> sorry, raisin_
00:44:40 * hackagebot git-vogue 0.1.0.4 - A framework for pre-commit checks.  http://hackage.haskell.org/package/git-vogue-0.1.0.4 (ChristianMarie)
00:44:49 <tdammers> you can read it as "for all types 'a' such that 'a' implements 'Monoid', the type of this function shall be a -> a -> a"
00:45:06 <EvanR> raisin_: instance Monoid (Maybe a) where ... how would you implement this one?
00:45:59 <solatis> jle`: just as an fyi, look at this: https://github.com/Gabriel439/Haskell-MMorph-Library/issues/15
00:46:13 <solatis> apparently, EitherT is not the way to go anymore, and ExceptT is
00:46:26 <jle`> interesting
00:46:30 <jle`> thanks for the heads up
00:46:36 <raisin_> tdammers, by function you are referring to mappend?
00:46:50 <tdammers> raisin_: in this particular example, yes
00:47:06 <jle`> what is ExceptT even
00:47:10 <jle`> i don't even
00:47:31 <tdammers> jle`: ExceptT is the new ErrorT :D
00:47:48 <jle`> oh, i see
00:47:51 <raisin_> So the Monoid a type constraint is necessary because the the monoid is acting on the value wrapped by Maybe, which is of type a. Correct?
00:47:51 <jle`> Monad m => Monad (ExceptT e m)
00:48:05 <jle`> when did this happen...
00:48:07 <jle`> i'm so out of date
00:48:13 <jle`> out of the loop
00:48:14 <solatis> but... what edge does ExceptT have over ErrorT ?
00:48:28 <solatis> i thought ErrorT was fubar ?
00:48:37 <tdammers> raisin_: the Monoid constraint is needed because the Monoid instance for Maybe a depends on the Monoid instance for a in order to do Monoid things with the wrapped value
00:48:45 <jle`> ErrorT has a constraint on `e`
00:48:55 <jle`> it's not really fubar, it's just a little annoying i think
00:48:55 <solatis> yeah i know, to be string-only, right ?
00:49:03 <solatis> EitherT is more flexible
00:49:08 <jle`> it has to be an instance of Error
00:49:12 <jle`> to be able to use its Monad instance
00:49:12 <solatis> right
00:49:16 <tdammers> raisin_: i.o.w., the most general implementation of Monoid for Maybe a can only be defined in terms of Monoid oprations on the wrapped a value
00:49:16 <raisin_> tdammers, right. I think the pieces are falling into place.
00:49:29 <solatis> well, since I am using it for CPS-style error reporting, maybe I should switch to ErrorT...
00:49:40 * hackagebot json-rpc-client 0.1.0.0 - JSON-RPC 2.0 on the client side.  http://hackage.haskell.org/package/json-rpc-client-0.1.0.0 (grayjay)
00:49:42 <solatis> ehr
00:49:43 <solatis> ExceptT
00:49:45 <solatis> dammit
00:50:21 <raisin_> Thanks tdammers and EvanR
00:50:57 <solatis> so, ExceptT is in transformers, while ErrorT is in mtl
00:51:11 <jle`> well they are both in transformers
00:51:15 <solatis> yes
00:51:30 <solatis> and mtl is 'officially' maintained by haskell, and transformers is not
00:51:39 <solatis> so that gives ErrorT an edge, not ?
00:51:49 <jle`> that seems kind of hard to believe for me, because mtl depends on transformers
00:52:03 <solatis> just look at the maintainer
00:52:06 <jle`> mtl is basically just a bunch of new typeclasses and orphan instances for transformers types
00:52:11 <solatis> oh
00:52:12 <solatis> wait
00:52:14 <EvanR> raisin_: you could have defined the monoid operations without using the inside value, but the standard one combines them if both Just
00:52:17 <solatis> mtl-1 was libraries@haskell.org
00:52:19 <solatis> mtl-2 is not
00:52:34 <jle`> s/transformers types/the types in transformers
00:52:41 <tdammers> EvanR: would that even be a valid monoid instance?
00:52:48 <EvanR> i think so, i just checked
00:53:11 <tdammers> oh, right, it would
00:53:21 <jle`> in fact i don't really like calling mtl a monad transformer library
00:53:33 <EvanR> > mempty :: Maybe String
00:53:34 <lambdabot>  Nothing
00:54:15 <tdammers> no, I mean not using the Monoid instance of the wrapped type
00:54:28 <EvanR> tdammers: whether you can define an instance over a polymorphic type with no constraint, that im not sure about exactly
00:54:38 <EvanR> yes you dont have to
00:54:40 <tdammers> you can, but it wouldn't be very useful
00:55:03 <solatis> hmmm ExceptT looks a lot more sane than EitherT
00:55:26 <tdammers> e.g., if one of the operands is Just, use that, if both are Just, use the second one, if both are Nothing, return Nothing
00:55:42 <jle`> i don't quite see the difference at this point but
00:55:45 * jle` shrugs
00:55:47 <jle`> :|
00:55:50 <tdammers> I think that would be a valid Monoid instance, though not extremely useful
00:56:02 <jle`> i suddenly feel out of the loop on everything
00:56:04 <EvanR> or use the first one
00:56:17 <tdammers> using the first one would be the Alternative instance, wouldn't it?
00:56:24 <tdammers> so that'd just be redundant
00:56:47 <jle`> yeah, the first-Just is the monoidal behavior of the Alternative instance with (<|>)
00:56:48 <EvanR> hehe
00:57:03 <jaseemab`> Noob Q. I have a data type that can be instantiated with 2 constructors, like Maybe. In a particular case, I know the result will always be made with one specific instance. Can I make the type of that expression even more specific?
00:57:06 <EvanR> Alternative is an alternative monoid
00:57:33 <jaseemab`> s/specific instance/specific constructor/
00:57:38 <tdammers> haskell is a quick-and-dirty get-things-done language after all
00:57:46 <Black0range> Using a TCP socket how do i set a read timeout? When i attempt doing this "setSocketOption sock RecvTimeOut 3000" I get "setSocketOption: invalid argument (Invalid argument)"
00:57:49 <jle`> jaseemab`: well, you can turn `Maybe a` into `a`
00:57:57 <jle`> `a` is probably "more specific" :)
00:58:02 <jle`> if you know it's Just
00:58:06 <Cale> jaseemab`: That's kind of what GADTs do
00:58:12 <jle`> if you know it's Nothing, then you can turn your `Maybe a` into `()`
00:58:15 <Cale> You can have something like
00:58:22 <Cale> data MyType a where
00:58:26 <jaseemab`> So a pattern match where you just match the type you want.
00:58:34 <Cale>   C1 :: MyType Integer
00:58:39 <Cale>   C2 :: MyType Bool
00:58:44 <solatis> Black0range: https://github.com/search?l=Haskell&q=RecvTimeout+language%3AHaskell&ref=advsearch&type=Code&utf8=%E2%9C%93 contains a lot of code samples
00:58:49 <jle`> yeah i'm not sure what you want anymore, sorry
00:59:02 <jaseemab`> Cale: Ah! Yep. That's what I wanted.
00:59:46 <jaseemab`> Thanks jle` Cale.
01:00:05 <calvinx> Reference http://stackoverflow.com/questions/23578836/is-there-a-debugger-statement-for-haskell-ghci-something-else - “:break [<mod>] <l> [<col>]  set a breakpoint at the specified location”  what does <mod> stand for? module?
01:00:33 <Iceland_jack> yup
01:00:38 <calvinx> k
01:00:44 * jaseemab` is pretty mind blown with haskell by now. 
01:01:18 <tac_> jaseemab`: Just please fight the urge to blog about how monads work ;P
01:04:14 * hvr wonders when ppl will start blogging about applicative functors
01:04:41 * hackagebot wai-extra 3.0.4 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.4 (MichaelSnoyman)
01:04:47 <jaseemab`> tac_: ha ha. Sure.
01:05:18 <EvanR> just rename applicative functors to Gonads or something to attract attention
01:05:43 <EvanR> Applicative is a regular word
01:06:00 <jaseemab`> Well, I'm happy with the language, but not the ecosystem. cabal is a pain. Something like virtualenvwrapper would be great.
01:06:22 <solatis> huh, what
01:06:25 <solatis> i don't understand anymore
01:06:29 <solatis> mtl has Except
01:06:33 <solatis> and transformers has Except
01:06:45 <calvinx> jaseemab`: https://github.com/calvinchengx/cabalenv  I made a simple script that acts much like virtualenv
01:06:56 <calvinx> and works with cabal sandboxes
01:07:01 <jle`> solatis: well, mtl has every type that transformers has
01:07:03 <jle`> "has"
01:07:07 <jle`> as in, re-exports
01:07:10 <solatis> aha
01:07:23 <Zemyla> An applicative functor is a chef wrapped in a tortilla. You apply him to a burrito to get another burrito.
01:07:33 <calvinx> lol.
01:07:40 <calvinx> I love applicative functors
01:07:58 <jle`> like i mentioned before, mtl basically re-exports all of transformer's types, and adds along some new typeclasses and orphan instances
01:08:02 <EvanR> hahaha
01:09:39 <jaseemab`> calvinx: I'll give it a try.
01:09:57 <jle`> jaseemab`: what about cabal sandboxes?
01:10:02 <ionum> hi, i am writing a paper and i'd like to visualize my Haskell program, what's the best way to do it?
01:10:16 <calvinx> zsh only at the moment; will add in corresponding bash function when I have time.
01:11:21 <vanila> ionum, what do you want to visualize abou tit?
01:12:40 <ionum> well like a flowchart or so, for example: it gets input a b, if the args are parsed succesfully. go on. else. terminate with error.
01:14:17 <ionum> the program is a kind of parser and id like to have sth like a blueprint to describe what it does
01:15:15 <solatis> gmrbl
01:15:20 <solatis> i have an Except e a
01:15:23 <jle`> do you want a programmatic approach to analyze your haskell program, or do you want flowcharting software?
01:15:29 <solatis> i need to get that into an ExceptT e m a
01:15:30 <ionum> I did sth like f :: A -> B as [A] ----f----> [B]  -----g-----> [C]
01:15:31 <lpaste> nathan7 pasted “No title” at http://lpaste.net/6803058399626919936
01:15:42 <solatis> what is the way to do that ?
01:15:46 <jle`> solatis: that's `hoist generalize` :)
01:15:53 <solatis> right
01:15:55 <ionum> but it gets really messy when i have sth like Either ParseError or IO ()
01:16:05 <lpaste> nathan7 revised “No title”: “No title” at http://lpaste.net/6803058399626919936
01:16:05 <jle`> it's actually the example given on the docs for mmorph
01:16:21 <nathan7> I'm trying to make use of the ST monad, but I'm having some trouble making my code work
01:16:27 <nathan7> http://lpaste.net/6803058399626919936 works if I replace `a` with `Int`
01:16:33 <solatis> jle`: that's for ErrorT :)
01:16:35 <ionum> I do not want a software, I'd like to know if there is some standard way to visualize it
01:16:43 <nathan7> But I want my code to be generic over the type
01:16:56 <solatis> jle`: thanks, that did the trick!
01:17:30 <nathan7> I have a feeling this could work with the scoped type variable extension, but I figured there'd be a better way
01:17:43 <jle`> solatis: ah i meant the whole, State s a -> StateT s m a, Writer w a -> WriterT w m a deal
01:18:15 <lpaste> nathan7 pasted “error” at http://lpaste.net/117809
01:18:17 <solatis> jle`: ah
01:18:50 <nathan7> It doesn't seem to unify the two a's, even though as far as I can tell, that should be inferrable
01:18:53 <jle`> it's a shame that the abstractions in haskell doesn't work out so that `hoist generalize` can turn a Maybe a into a MaybeT m a
01:19:11 <jle`> the kind signature of MFunctor is too specific
01:19:58 <jle`> maybe some day we'll have a neat abstraction that can take both State s a -> StateT s m a and Maybe a -> MaybeT m a
01:20:57 <jle`> i guess we can always go the path that transformers took with Except
01:21:01 <jle`> ...that could work today, even.
01:22:44 <solatis> jle`: urgh, apparently mmorph in nix isn't compiled against transformers 0.4.0
01:22:57 <solatis> so i still have to define my own MFunctor instance
01:22:58 <solatis> bah
01:26:58 <solatis> you know, i just had a realization
01:27:00 <jle`> :/
01:27:11 <solatis> all this ExceptT, CPS, runExceptT, hoisting nonsense
01:27:19 <solatis> it's just mimicking actual exceptions ?
01:28:10 <solatis> i mean, it's /almost/ equal to running ablock of code in a catch block..
01:28:36 <solatis> (other than that it's more explicit)
01:28:50 <vanila> CPS?
01:29:01 <solatis> continuations
01:29:08 <vanila> thats more general than just exceptions
01:29:55 <solatis> i know, but runExceptT runs a block of code, and bails out as soon as one of the functions returns an error
01:31:50 <vanila> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html#g:2
01:31:56 <vanila> the docs say ErrorT, but shouldn't it say ExceptT?
01:32:32 <vanila> how is Except/ExceptT different from the Either monad?
01:33:27 <jle`> ExceptT is an "Either transformer"
01:33:39 <jle`> newtype ExceptT e m a = ExceptT (m (Either e a))
01:33:44 <vanila> why isn't it called EitherT then?
01:34:03 <jle`> idk :|
01:34:11 <jle`> EitherT is already in the `either` package
01:34:16 <jle`> but it is essentially the same thing...
01:34:33 <vanila> thats really confusing :/
01:34:43 <solatis> well that's nice
01:34:47 <jle`> ikr
01:34:52 <jle`> i think `either` is being depreciated though
01:34:59 <jle`> so that ExceptT can be the one true EitherT
01:35:06 <solatis> ah yes
01:35:12 <vanila> I wish it could be called EitherT
01:35:27 <solatis> http://xkcd.com/927/ is relevant here
01:36:04 <solatis> so, now, haskell, on top of Maybe, Either and exceptions, also has Error
01:36:12 <solatis> ehr, Except
01:36:14 <solatis> and Error
01:36:15 <solatis> geez
01:36:24 <raisin_> Haskell makes me feel clever like no other language
01:36:27 <jle`> well, my impression of the story, which may or not be correct
01:36:58 <nedo007> !topic
01:37:03 <jle`> first, we had Either.  then, we needed an Either transformer.  So transformers made ErrorT.  but ErrorT had a constraint on the `e` paramter for its Monad instance in order to implement `fail`, which wasn't idea because it's useful to have one without a constraint
01:37:30 <hvr> fyi, https://github.com/haskell/hackage-server/issues/305
01:37:37 <jle`> so then a couple of "ErrorT without Error e" libraries came up and eventually `either` became the main one
01:37:37 <solatis> but ExceptT has no constraint on the `e` parameter either!
01:37:55 <jle`> and then now transformers realized that it's a good idea to not have a constraint on the `e`
01:38:18 <jle`> but instead of breaking compatibility for people who *did* rely on `fail` for ErrorT and removing it from ErrorT, they decided to make a new type, ExceptT
01:38:27 <jle`> which is ErrorT w/out the constraint, aka EitherT
01:38:28 <solatis> right
01:38:33 <jle`> but they didn't want to name it EitherT, because...
01:38:40 <solatis> naming conflicts
01:38:46 <jle`> maybe it would be a conflict with the already supreme EitherT from `either`?
01:39:04 <vanila> it should be called EitherT if it's normal excepted monad transformation for Either
01:39:06 <jle`> but in introducing `ExceptT`, `either` is now more or less rendered obsolete
01:39:13 <jle`> so now EitherT will disappear
01:39:15 <solatis> yes
01:39:22 <nedo007> hello, is there a haskell channel for beginners?
01:39:22 <jle`> leaving only ExceptT which should have been called EitherT
01:39:26 <solatis> and Error is officially deprecrecated by transformers
01:39:29 <solatis> nedo007: #haskell-beginners
01:39:41 <solatis> ehr, deprecated*
01:39:45 <vanila> well than you for the overview jle`!
01:39:48 <vanila> thank you
01:40:04 <solatis> so it seems like ExceptT will be the one true way, in the future ahead
01:40:05 <jle`> that is what i have sort of gathered after learning about ExceptT tonight
01:40:08 <jle`> haha.
01:40:15 <vanila> I think honestly i should just make my own monad transformers library
01:40:18 <jle`> no problem. i might have some details off.
01:40:34 <jle`> yeah, on top of it all, we have a library called `mtl` that is not even a monad transformers library!
01:40:43 <jle`> what is up with haskell
01:40:43 <solatis> but, but
01:40:50 <solatis> it re-exports transformers!
01:41:23 <jle`> :P
01:42:07 <solatis> damn
01:42:08 <nathan7> well, ScopedTypeVariables fixed my problem
01:42:09 <solatis> https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-Error-Class.html#MonadError
01:42:13 <solatis> it is just a re-implementation
01:42:23 <solatis> and they borrow only the instances from ErrorT
01:42:42 <nedo007> solatis: thanks
01:42:55 <solatis> why would they do that?
01:43:10 <jle`> what do you mean?
01:44:32 <jle`> i guess well, if you go the "way of mtl", you don't really have to worry about ErrorT/ExceptT/EitherT
01:44:38 <jle`> they are all abstracted under a common interface
01:44:44 <jle`> so you can write-once and have it work for all three
01:45:03 <vanila> the typeclasses?
01:45:05 <jle`> and that is...the dream?
01:45:18 <jle`> yes
01:45:19 <vanila> I don't like the typeclasses because they make error messages and type inference worse
01:45:37 <vanila> I think that it will be harder for beginners to learn to use monad transformers because of that stuff
01:45:58 <jle`> yeah, most people recommened people to use the way of `transformers`
01:46:16 <jle`> i am still writing an article about why `mtl` should be disassociated with monad transformers completely, or as much as possible
01:46:40 <jle`> and its usefulness being isolated from its tenuous relationship with monad transformers
01:46:48 <solatis> well, transformers sums it up pretty well:
01:46:53 <jle`> *most people recommened newcomers to use the way of `transformers`
01:47:06 <solatis> "The package can be used on its own in portable Haskell code, in which case operations need to be manually lifted through transformer stacks (see Control.Monad.Trans.Class for some examples). Alternatively, it can be used with the non-portable monad classes in the mtl or monads-tf packages, which automatically lift operations introduced by monad transformers through other transformers."
01:47:31 <jle`> the idea of monad transformer stacks is still really weird to me and i don't think i'll ever really get used to it
01:47:36 <mjrosenb> if I have a monad Foo, and I'm using it as Foo (Maybe t), would I want to use FooT Maybe t, or MaybeT Foo t?
01:47:38 <jle`> or really get on board with it
01:47:42 <mjrosenb> jle`: ditto!
01:47:55 <jle`> I'm perfectly happy with monads combining several effects...IO, State, Either, Reader...w/e
01:48:02 <jle`> but "transformer stacks"...is...what
01:48:10 <vanila> i dont follow
01:48:21 <jle`> mjrosenb: it depends on what you want as your behavior of (>>=)
01:48:40 <vanila> stacking monad transformers is just a way to combine effects
01:48:44 <mjrosenb> jle`: I'd Imagine so, but I am not too sure what I want that to be!
01:48:45 <jle`> mjrosenb: if you are aware of the "newtype wrappers" to provide alternative typeclass instances for Monoid for Maybe and numbers, etc.
01:49:04 <jle`> then MaybeT m a is a newtype wrapper around m (Maybe a) that just gives an "alternative Monad instance"
01:49:12 <mjrosenb> (fwiw, I've written Foo, and I'm 90% sure I also need to write FooT)
01:49:14 <solatis> jle`: well, i'm now having functions that return ExceptT String (ResourceT IO) [NS.Socket]
01:49:18 <solatis> which feels... awkward
01:49:21 <jle`> vanila: it's a way, but it's sort of a hard-to-reason-about one
01:49:30 <mjrosenb> I've never written a monad transformer before, so this should be interesting.
01:50:00 <vanila> I really like the approach and find it useful a lot
01:50:11 <vanila> I think it's cool that people are exploring alternatives like exteff though
01:50:35 <jle`> if i wanted an effects combining type for the real world i would just roll one from scratch
01:50:48 <jle`> then i could explicitly decide the behavior of the compositions of effects
01:51:03 <vanila> so you would make a data type and then implement a monad instance for it?
01:51:04 <jle`> instead of leaving it up to hoping the order of my stacking works out
01:51:07 <jle`> yes
01:51:18 <jle`> and then i'd write the appropriate instances from mtl for it
01:51:19 <vanila> well I think that is just what stacking automates
01:51:31 <jle`> so i can use ask, get, liftIO, etc. for it
01:51:45 <jle`> yeah, but stacking makes yo deal with all of those weird things about stacking :|
01:51:48 <solatis> i'm so confused as to how use multiple layers of monads + error reporting right now
01:51:58 <jle`> like the order of stacking changing what you are talking about
01:52:04 <vanila> but it should do
01:52:30 <jle`> mjrosenb: why don't you give an example and we can see which instance is better for you :)
01:52:40 <jle`> mjrosenb: one way to look at it it is to consider the type of (>>=) for each
01:53:00 <vanila> well anyway, stacks are just a tool to automate all that and help building instances - doing it by hand is fine too
01:53:06 <solatis> so you are actually writing your monad instance for every transformation ?
01:53:08 <jle`> one is m (Maybe a) -> (Maybe a -> m (Maybe b)) -> m (Maybe b)
01:53:11 <vanila> it should be clear why order changes things. It's just like how [(e,a)] is a different to (e,[a])
01:53:24 <jle`> the other is m (Maybe a) -> (a -> m (Maybe b)) -> m (Maybe b)
01:53:36 <jle`> in the latter, you don't "have access" to the maybe-ness.
01:53:52 <jle`> solatis: it's not transformations, it's just a single type
01:54:01 <jle`> that incorporates several effects
01:54:05 <solatis> right
01:54:20 <jle`> vanila: yeah, it does change things, and i guess if you look at it long enough you can get used to it
01:54:21 <solatis> if you care, take a look at some code i'm working on as we speak https://github.com/solatis/dissent/blob/master/src/Dissent/Protocol/Shuffle/Leader.hs
01:54:27 <solatis> i have the feeling i'm trapped in monads
01:54:34 <solatis> and the code is losing all its elegance
01:54:45 <jle`> solatis: when i do that, i'd use the typeclasses from mtl to provide the generic interface if my effects happen to match up with common effects
01:54:48 <vanila> well a good example is thinking about the way you can combine effects
01:54:50 <solatis> 50% of the code i'm writing is lifting and transforming between monads
01:54:57 <vanila> take state (a mutable cell) and list (backtrackign nondeterminism)
01:55:23 <vanila> you can think of two ways to compose those effects: the state gets undone when backtracking, or the state stays the same even when you backtrack
01:55:45 <vanila> you can imagine programs where you want either of those, so you would just stack them the other way around for each
01:56:10 <solatis> anyone has any sample code online that implements this ? i understand what you are saying, but i'm interested in seeing it applied in real life
01:56:20 <jle`> it's just not obvious to me which order of stacking does which
01:56:29 <jle`> if i wrote my own type, then i could explicitly just "say so" in my Monad instance
01:56:47 <vanila> im not sure that's quite true
01:56:56 <vanila> in defining the data type you have already set the order of the stacking
01:56:59 <jle`> it might be simple for two effects but for several it gets a bit unweildy conceptually for me
01:57:16 <jle`> vanila: you're probably right on that
01:57:18 <vanila> well a lot of effects actually commute, in those cases it desn't matter what order you stack
01:57:23 <jle`> actually yeah, you're right
01:57:30 <jle`> i get to "decide" on the definition of my constructor
01:57:36 <jle`> explicitly
01:58:10 <jle`> solatis: i might consider generalizing your code or making it more polymorphic to MonadError and MonadIO and MonadTrans...then a lot of your functions can compose w/out explicit lifting
01:58:11 <solatis> jle`: you have some sample code that i can look at that dos this ? i'm feeling a bit lost between the theory of this and the practical implementations of it
01:58:26 <vanila> I do think your approach is fine though, im not saying like "everyone should use stacks!" - but what bugs me a lot is that the typeclass stuff makes this way more confusing and difficult
01:58:57 <vanila> so i think people who start to learn haskell with the typeclass stuff (rather than a few years ago) will not want to use stacks finding them more confusing
01:59:10 <solatis> jle`: hmm that's interesting
01:59:27 <jle`> yeah, i deifnitely agree that transformers should be the first introduced method of combining effects
01:59:38 <jle`> i think one problem is that the typeclass approach's worst failure is with monad transformers
01:59:49 <jle`> the typeclass approach seems to work fine for me until you use it with monad transformers
02:00:04 <jle`> in terms of pedagogy etc.
02:00:16 <jle`> actually it's probably just really late now and i'm rambling
02:00:18 <vanila> yeah and with monad transformers already being a difficult thing for beginners to grasp...
02:00:28 <jle`> so i think they should really be decoupled
02:00:31 <vanila> no I follow you, I agree a lot too
02:00:40 <jle`> mtl should not be used as a way to combine effects, transform monads
02:00:41 <solatis> jle`: you have a blog somewhere iirc, right ?
02:00:45 <solatis> that rambles about these things
02:00:54 <jle`> yeah, but i have been a bit busy lately to update, heh.  http://jle.im
02:01:33 <jle`> solatis: one way to write your program then with this approach is to forget transformers altogether
02:01:40 <jle`> write your functions to return Monad m => m a
02:01:55 <jle`> or well, leave your functions as they are, and change the type signature to return that
02:01:56 <solatis> hmmm!
02:02:06 <jle`> GHC will complain, "whoa whoa whoa...that's way too general"
02:02:12 <jle`> (...or will it?)
02:02:22 <solatis> hold on
02:02:25 <jle`> and then slowly add more constraints until your return type is specific enough to do what you want
02:02:34 <solatis> right
02:03:02 <jle`> "oh, you need to be able to incorporate IO?  then now i have (MonadIO m => m a)"
02:03:43 <solatis> since, my ExceptT String (ResourceT IO) [NS.Socket] is actually just a monad
02:03:46 <jle`> "oh, you need to be able to fail with a string?  then you have (MonadError String m, MonadIO m => m a)
02:03:55 <jle`> er, the parentheses should be moved
02:04:07 <solatis> right, this sounds like something i should try out
02:04:20 <solatis> but, i fail to see how that would get rid of the explicit transformations ?
02:04:27 <jle`> "oh, you need to be able to incorporate ResourceT effects?  then you have (MonadError String m, MonadTrans ResourceT m, MonadIO m) => m a
02:04:29 <solatis> i will still need to hoist, right ?
02:04:38 <jle`> and then for each of your functions, only constrain the minimum amount
02:04:42 <jle`> leave them as general as possible
02:04:48 * hackagebot koofr-client 0.1.1.0 - Client to Koofr API  http://hackage.haskell.org/package/koofr-client-0.1.1.0 (edofic)
02:04:49 <jle`> i think the hoisting will go away...
02:05:01 <jle`> hm
02:05:15 <solatis> and i will still need to transform some Either's to Except's
02:05:16 <solatis> etc
02:05:39 <solatis> and i will probably still need to liftIO
02:05:41 <solatis> :)
02:06:18 <jle`> looking at `transformers`...
02:06:32 <jle`> i don't understand why it is not except :: Monad m => Either e a -> ExceptT e m a
02:06:40 <jle`> :/
02:06:46 <solatis> yeah, i am severely annoyed by that
02:07:14 <solatis> so now i need to (hoist generalize (except functionThatReturnsEither)))
02:07:36 <jle`> whyyyy :(
02:07:46 <solatis> heck
02:07:58 <jle`> except' = either throwError return
02:08:02 <jle`> :t either throwError return
02:08:03 <lambdabot> MonadError a m => Either a a1 -> m a1
02:08:07 <jle`> use that one ok
02:08:09 <jle`> :)
02:08:16 <solatis> woa
02:08:18 <solatis> genius
02:09:45 <jle`> i wonder how one would submit a patch/pr to transformers
02:10:52 <breadmonster> http://lpaste.net/117812
02:11:03 <breadmonster> Can someone tell me why this error comes up?
02:11:04 <solatis> but, shouldn't it be possible to just define some instance for ErrorT e m a that, say, automatically converts an Either e a ?
02:11:04 <jle`> if you wanted to stick with explicitly ExceptT and not go with polymorphism, you could always have done `ExceptT . return`, btw
02:11:56 <d12frosted> hi all
02:12:04 <jle`> solatis: technically MonadError is strong enough to be able to do that
02:12:22 <jle`> in fact, `either throwError return` could really just go into mtl as a helper method for MonadError
02:12:32 <jle`> hi d12frosted :)
02:12:45 <solatis> right
02:13:00 <jle`> jst like the various helper methods for Data.Foldable
02:13:23 <jle`> it could even become a part of the typeclass...
02:13:31 <jle`> and it wouldn't really break anything
02:13:39 <jle`> hm
02:14:26 <gregnwosu> hello a wise man once said evaluate languages via its primitives , abstraction and combination
02:15:20 <gregnwosu> does haskell have any other means of abstraction other than types, type classes and functions?
02:17:28 <solatis> jle`: thanks a lot for your help
02:17:40 <solatis> i think i've got a few things to work with (again)
02:17:47 <jle`> np.  thanks for helping me get back into the loop :) i have been a bit rusty lately...
02:18:17 <solatis> well if i can judge, it almost sounds like you're ahead of the loop
02:18:42 <ab9rf> types and functions go a long way, i should think
02:18:45 <solatis> the loop is doing a lot of duplicated effort, in this case, without making sense
02:18:54 <solatis> ab9rf: "less is more" :)
02:19:49 * hackagebot koofr-client 1.0.0.0 - Client to Koofr API  http://hackage.haskell.org/package/koofr-client-1.0.0.0 (edofic)
02:21:07 <jle`> haha i guess it's all a matter of perspective
02:21:08 <gregnwosu> solatis: ab9rf: I still struggle with the fact the haskell doesnt have oo like encapsulation, i think this is more due to my mind being oo-tainted than a fault of haskell though
02:21:39 <jle`> haskell is an ecosystem where if you are gone for two months, you come back to something completely different than what you remember
02:21:47 <jle`> it's almost like node
02:21:47 <ab9rf> heh
02:21:49 <jle`> :)
02:22:01 <ab9rf> i've never used node, but yeah, the ecosystem does change markedly very quickly :)
02:22:11 <solatis> i've used node.js
02:22:13 <solatis> it's insane
02:22:21 <solatis> and people are not keeping up
02:22:22 <jle`> s/like node/like node in 2010
02:22:31 <ab9rf> solatis: i've never heard anyone say anything otherwise about node
02:22:37 <solatis> i've used node.js last year-ish
02:22:51 <solatis> one critical thing changed: streams
02:23:06 <ab9rf> i think haskell's lack of oo-style encapsulation is a strength :)
02:23:13 <solatis> instead of streams acting in a 'pull' manner, they made it more 'push'-like
02:23:25 <ab9rf> i really dislike object-oriented style programming
02:23:50 <solatis> but since javascript is loosely typed, they had to implement *both* type of streams using the same interface
02:24:10 <solatis> so, if you did a 'stream.read ()', internally, the streams would go into a v1-mode
02:24:14 <ab9rf> pushyupullme
02:24:31 <solatis> but if you did not do that, and instead, subscribed to an 'ready' event, they would go into v2-mode
02:24:45 <solatis> core library programmers simply kept using v1 streams, like http libraries
02:24:51 <solatis> because they simply did not know (or care)
02:25:06 <ab9rf> solatis: insane dried fruit
02:25:07 <solatis> so i started patching all the libraries i used to use v2 streams
02:25:10 <solatis> people were happy
02:25:13 <solatis> but i left the scene
02:25:19 <solatis> and that was, about 1 year ago
02:25:25 <solatis> i've heard they're at streams v3 now
02:25:32 <solatis> i pity the people that have to work with the code...
02:27:43 <mjrosenb> Is there something like replicate, but for general monads?
02:28:22 <ab9rf> replicateM?
02:29:15 <d12frosted> basic rule: whenever you need m a use fM :D
02:29:31 <ab9rf> :t replicateM
02:29:32 <lambdabot> Monad m => Int -> m a -> m [a]
02:29:56 <d12frosted> cool, do we have ghci here?
02:30:09 <ab9rf> we have lambdabot, which is not quite the same thing
02:30:19 <d12frosted> where can I read about it?
02:30:43 <d12frosted> oh sorry, found on wiki
02:31:14 <ab9rf> no problem :)
02:31:44 <mjrosenb> ab9rf: indeed, thanks!
02:31:55 <mjrosenb> (hoogle did not report that one
02:32:05 <ab9rf> i used hoogle to find it :)
02:32:08 <mjrosenb> then again, I replaced Int with Integer in the type
02:32:18 <ab9rf> @hoogle Int -> m a -> m [a]
02:32:19 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
02:32:19 <lambdabot> Test.QuickCheck.Gen vectorOf :: Int -> Gen a -> Gen [a]
02:32:19 <lambdabot> Test.QuickCheck vectorOf :: Int -> Gen a -> Gen [a]
02:32:29 <mjrosenb> foogle should /really/ know those two are interchangable
02:32:46 <mjrosenb> https://www.haskell.org/hoogle/?hoogle=Integer%20-%3E%20m%20a%20-%3E%20m%20[a]
02:33:06 <d12frosted>  > map (+1) [1..10]
02:33:14 <d12frosted> > map (+1) [1..10]
02:33:15 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
02:33:27 <d12frosted> hell, it's so cool, hoogle, evaluation
02:33:34 <ab9rf> lots of other commands too
02:33:51 <d12frosted> yeah, reading about them
02:34:41 <mjrosenb> with at least one known DOS :-p
02:36:39 <chrisdotcode> Correct me if I'm wrong...but aren't some and many1 from Parsec isomorphic?
02:37:12 <mmmm> yes chrisdotcode
02:37:48 <mmmm> parsec predates control.applicative by a number of years though
02:37:54 <chrisdotcode> mmmm: Thought so. So why does the latter exist, when many is just re-imported, and people can just use some?
02:37:58 <chrisdotcode> Ah, ninjad.
02:38:07 <chrisdotcode> So why are they still there? Let me guess - legacy?
02:38:17 <mmmm> yes exactly
02:38:24 <mmmm> parsec also exports (<|>)
02:38:44 <chrisdotcode> Right, so that's doubly odd.
02:38:45 * chrisdotcode shrugs.
02:42:28 <merijn> chrisdotcode: Parsec has custom exports of pretty much everything an Applicative
02:42:48 <solatis> jle`: hmz, it doesn't seem that there is a Control.Monad.Except.Class -- how would i go defining a MonadExcept (or should i, anyway?)
02:42:57 <merijn> People don't wanna remove it because they're scared to break existing code. Although maybe that'll happen when Applicative goes into Prelude
02:43:07 <solatis> or wait, MonadExcept is just a MonadError
02:43:13 <solatis> ehr ExceptT i mean
02:43:14 <jle`> solatis: MonadError is actually "unrelated" to ErrorT
02:43:27 <jle`> another unhelpful historical artifact :P
02:43:36 <solatis> yeah, i'm just having fights with the compiler to accept my MonadError String m
02:44:36 <solatis> phase2 :: [NS.Socket] -> ExceptT String IO [R.Encrypted]
02:44:50 * hackagebot yesod-dsl 0.1.1.22 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.22 (TeroLaitinen)
02:45:03 <solatis> (MonadIO m, MonadError String m) -> m [R.Encrypted] doesn't do the trick
02:45:18 <jle`> hmmmm
02:45:28 <jle`> what happened to the [NS.Socket] argument?
02:45:28 <mjrosenb> Is there anything like ByteString, but which records the history of deconstruction such that it can be re-constructed later?
02:45:33 <tdammers> hmm, this isn't good... latest Aeson depends on scientific, and accepts 0.3.* per dependencies, but scientific moved some stuff around going from 0.2 to 0.3, and Aeson doesn't actually compile against 0.3
02:45:48 <solatis> i left it out for clarity sake
02:45:51 <tdammers> if I fix scientific to < 0.3, stuff seems to work, but ugh
02:45:53 <solatis> wait, i'll just paste some code
02:45:58 <solatis> (on lpaste)
02:46:09 <calvinx> I seem to have some trouble introspecting variables with `:print` in a wai/warp app - http://stackoverflow.com/questions/27777830/using-ghci-debugger-in-a-wai-warp-app - any idea what I am doing wrong?
02:46:29 <calvinx> (with ghci of coursea0
02:47:10 <merijn> mjrosenb: What do you mean "history of deconstruction"?
02:47:50 <mjrosenb> merijn: if I discard a large portion of a buffer with buf' = BS.splitAt 10240 buf
02:48:14 <lpaste> solatis pasted “No title” at http://lpaste.net/117814
02:48:22 <solatis> jle`: ^^
02:48:58 <solatis> so i thought, maybe i should just return the Either
02:49:17 <jle`> solatis: you're using throwE
02:49:22 <jle`> which returns an ExceptT
02:49:38 <jle`> if you want to make it polymorphic on all MonadError you'd have to use throwError
02:49:44 <solatis> ah, right
02:50:28 <merijn> mjrosenb: I guess I'm just not sure what you want to do? "reconstruct the bytestring" <- why not just keep the old one?
02:50:30 <mjrosenb> I want to make a new buffer, buf'' = buf' --- ok, evidently, there isn't an update function.
02:50:52 <solatis> bah, i feel i'm over my head on this one
02:51:00 <jle`> no, yo're almost there :)
02:51:03 <mjrosenb> merijn: I have a file with N records in it, I want to update the nth record with a function that looks at the full record as a ByteString
02:51:12 <solatis> i know
02:51:23 <solatis> well, the compiler accepts the function now
02:51:24 <mjrosenb> and I want it to update the whole group by updating the one record.
02:51:35 <solatis> but my code block that is doing a runExceptT is now complaining:
02:51:47 <solatis>    No instance for (MonadError String (ExceptT String IO))
02:51:49 <solatis>       arising from a use of ‘phase2’
02:51:54 <solatis> since my code expects an ExceptT
02:51:59 <solatis> but it doesn't do that
02:52:03 <solatis> it uses throwError
02:52:21 <merijn> mjrosenb: Ah, I would probably write "splitRecords :: ByteString -> [ByteString]", update the Nth ByteString and then "concat :: [ByteString] -> ByteString"
02:52:23 <solatis>     ciphers <- hoist liftIO (phase2 sockets)
02:52:28 <solatis> that is the violating line of code
02:52:37 <jle`> can you post it again
02:52:44 <jle`> hm
02:52:54 <lpaste> solatis pasted “No title” at http://lpaste.net/117816
02:53:01 <solatis> jle`: the entire code
02:53:04 <merijn> mjrosenb: Although that'd be expensive for actual files. You may want to do manual hSeek and only read/write part of the file without reading the entire thing into memory
02:53:08 <solatis> it's complaining about line 28 now
02:53:31 <merijn> mjrosenb: Do you know in advance how big each record is?
02:53:39 <solatis> maybe this is a case for generalize again
02:53:51 <jle`> id on't think you need hoist liftIO anymore
02:54:02 <jle`> if ResourceT IO is already MonadIO
02:54:03 <mjrosenb> merijn: Ideally, I would have an interface like a MutableArray, which knows how to write back only the updated data
02:54:07 <mjrosenb> merijn: negative :-(
02:54:25 <solatis> jle`: if i do that, it complains about this:
02:54:31 <merijn> mjrosenb: You can't do the mutable array interface as-is with bytestring
02:54:36 <solatis> src/Dissent/Protocol/Shuffle/Leader.hs:28:16-21:
02:54:38 <solatis>     No instance for (MonadError String (ExceptT String (ResourceT IO)))
02:54:40 <solatis>       arising from a use of ‘phase2’
02:54:49 <merijn> mjrosenb: You'll have to do a bunch of seeks/reads and then a write to update in place
02:54:54 <solatis> oh, so I need to tell it is a MonadResource ?
02:55:00 <jle`> no, you shouldn't have to
02:55:02 <jle`> hm
02:55:04 <ddellacosta> so, I'm a bit confused about blocking code and IO in Haskell.  I've got some FFI code that blocks in the original C, but it doesn't seem to be executing in the Haskell version.  Any suggestions on what to read up on to learn more about how this works in Haskell?
02:55:12 <jle`> that's weird, because i see the instance right here
02:55:26 <merijn> ddellacosta: What makes you think it isn't executing?
02:55:34 <jle`> `Monad m => MonadError e (ExceptT e m)`
02:55:43 <jle`> mtl-2.2.1
02:56:01 <ddellacosta> merijn: because it should be putting out a sound.  If I run it without the cleanup routines present in the C version it does do so, but otherwise it just seems to clean up immediately
02:56:04 <solatis> ah!
02:56:11 <solatis> maybe that's where the problem is
02:56:21 <solatis> i'm using the one from transformers
02:56:37 <jle`> it should be the same ExceptT though
02:56:40 <jle`> hm
02:56:42 <solatis> ahhh...
02:56:55 <solatis> src/Dissent/Protocol/Shuffle/Leader.hs:8:18-37:
02:56:57 <solatis>     Could not find module ‘Control.Monad.Except’
02:56:59 <solatis>     Perhaps you meant
02:57:01 <solatis>       Control.Monad.Cont (from mtl-2.1.3.1)
02:57:03 <solatis> ...
02:57:04 <mjrosenb> merijn: I guess I could write my own :-p
02:57:05 <solatis> etc
02:57:07 <merijn> ddellacosta: I'm gonna need more contest. Do you have a small example?
02:57:12 <solatis> my mtl is outdated
02:57:16 <solatis> i'm using 2.1
02:57:22 <ddellacosta> merijn: yeah, sure thing, give me a sec to paste something
02:57:36 <merijn> solatis: That's not outdated
02:57:44 <solatis> oh
02:57:50 <merijn> solatis: That's the one for 7.8
02:58:15 <jle`> ah ha it looks like 2.1 doesn't have the MonadError instance for ExceptT yet
02:58:15 <merijn> oh, wait, is mtl a boot library? Maybe I'm confused with transformers
02:58:17 <solatis> merijn: i know, but 2.1 doesn't define Control.Monad.Except, yet
02:58:26 <jle`> https://hackage.haskell.org/package/mtl-2.1/docs/Control-Monad-Error-Class.html
02:58:32 <jle`> instance conspicuously missing
02:58:35 <jle`> here is our culprit
02:58:49 <solatis> ok, so i have to define my own instance
02:58:55 <jle`> well...
02:59:02 <jle`> yeah, you can do that for now
02:59:04 <solatis> or rather, perhaps hit some nixos people to upgrade mtl
02:59:10 <jle`> but i suspect when you finish refactoring
02:59:11 <ddellacosta> merijn: https://gist.github.com/ddellacosta/a06e2405a2914216f195
02:59:14 <jle`> you might be able to get rid of it :)
02:59:23 <solatis> right
02:59:26 <solatis> thanks for the help
02:59:30 <solatis> i've gotta fix dinner now
02:59:33 <ddellacosta> merijn: original C I'm working from is here: https://xiph.org/ao/doc/ao_example.c
02:59:34 <jle`> by changing runExceptT to runErrorT
02:59:42 <jle`> and having all of your magically polymorphic code still work :D
03:00:08 <ddellacosta> solatis: where are you in the world?
03:01:42 <jle`> have a nice dinner :)
03:03:42 <moop> >filter (\line -> length line < 10) "A very long line that is totally longer than ten characters."
03:03:49 <moop> > filter (\line -> length line < 10) "A very long line that is totally longer than ten characters."
03:03:51 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[a]’
03:03:51 <lambdabot>  Expected type: [[a]]
03:03:51 <lambdabot>    Actual type: [GHC.Types.Char]
03:04:25 <moop> but
03:04:27 <moop> but
03:04:33 <moop> oh, wait
03:04:43 <moop> > filter (\line -> length line < 10) ["A very long line that is totally longer than ten characters."]
03:04:44 <lambdabot>  []
03:04:46 <moop> now i see
03:04:49 <moop> k
03:05:06 <moop> > filter (\line -> length line < 10) ["A very long line that is totally longer than ten characters.", "a pretty short line"]
03:05:07 <lambdabot>  []
03:05:20 <moop> wow, 10 chars is not that much
03:05:27 <moop> > filter (\line -> length line < 10) ["A very long line that is totally longer than ten characters.", "sup"]
03:05:28 <lambdabot>  ["sup"]
03:06:37 <ph88> why does [(*2), (+1)] <*> [1, 2, 3] work and [1, 2, 3] <*> [(*2), (+1)] does not work? what does the second one even mean ?
03:08:08 <jle`> ph88: check out the type of  (<*>) when applied to lists
03:08:17 <jle`> :t (<*>) `asAppliedTo` []
03:08:18 <lambdabot> [a -> b] -> [a] -> [b]
03:08:36 <ddellacosta> so, I think merijn maybe disappeared, but can anyone clue me into how blocking works w/C code in Haskell IO?
03:08:41 <ph88> jle`: wow nice function asAppliedTo !
03:08:56 <eikke> :t asAppliedTo
03:08:57 <lambdabot> (a -> b) -> a -> a -> b
03:08:59 <jle`> yeah it's just const but we get a lot of mileage out of it here in #haskell w/ lambdabot, heh
03:09:05 <moop> :t (<$>) `asAppliedTo` []
03:09:06 <lambdabot>     Couldn't match expected type ‘a -> b’ with actual type ‘[t0]’
03:09:06 <ddellacosta> I feel like I'm missing something basic here
03:09:06 <lambdabot>     In the second argument of ‘asAppliedTo’, namely ‘[]’
03:09:06 <lambdabot>     In the expression: (<$>) `asAppliedTo` []
03:09:26 <moop> :t (<$>)
03:09:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:10:47 <tdammers> huh, aeson's been fixed, apparently
03:11:01 <ph88> question 2:   [(*2), (+1)] <*> [1, 2, 3] gives (*2) applied to [1, 2, 3] then  (+1) applied to [1, 2, 3]      how would i get [(*2), (+1)] applied to 1  then  [(*2), (+1)] applied to 2  then  [(*2), (+1)] applied to 3   and as output: [2,2,4,3,6,4]  ?
03:12:00 <jle`> oh
03:12:03 <jle`> i know this one...
03:12:47 <ph88> that was what i originally intended to do by reversing   [(*2), (+1)] <*> [1, 2, 3]   to   [1, 2, 3] <*> [(*2), (+1)]
03:14:07 <jle`> well you can do (\x f -> f x) <$> [1,2,3] <*> [(*2),(+1)]
03:14:23 <jle`> > (\x f -> f x) <$> [1,2,3] <*> [(*2),(+1)]
03:14:25 <lambdabot>  [2,2,4,3,6,4]
03:14:34 <jle`> the former is flip ($)
03:14:39 <jle`> er, the lambda
03:14:48 <sshine> @pl (\x f -> f x)
03:14:48 <lambdabot> flip id
03:14:50 <jle`> there is also a cute way using the Backwards newtype i think
03:14:51 * hackagebot sign 0.4.1 - Arithmetic over signs and sets of signs  http://hackage.haskell.org/package/sign-0.4.1 (MasahiroSakai)
03:15:16 <erdeszt> maybe this can help a bit. i was curious about the same piece of code and made a manual evaluation of the original problem: https://gist.github.com/erdeszt/fb31ba3080a9a30ca19e
03:15:26 <ph88> :t flip
03:15:27 <lambdabot> (a -> b -> c) -> b -> a -> c
03:15:37 <sshine> flip id <$> [1,2,3] <*> [(*(-1)), (+1)]
03:15:43 <sshine> > flip id <$> [1,2,3] <*> [(*(-1)), (+1)]
03:15:44 <lambdabot>  [-1,2,-2,3,-3,4]
03:15:45 <sshine> sorry
03:16:05 <ph88> > flip id <$> [1,2,3] <*> [(*2), (+1)]
03:16:07 <lambdabot>  [2,2,4,3,6,4]
03:16:20 <ph88> why use   id   there ?
03:16:35 <jle`> it's "really" flip ($)
03:16:58 <jle`> but ($) is just a specialized `id`
03:17:00 <jle`> :t ($)
03:17:01 <lambdabot> (a -> b) -> a -> b
03:17:08 <ph88> i see <$> as the functor version of $    but  ($)  i don't know
03:17:17 <jle`> ($) is function application
03:17:19 <jle`> f $ x = f x
03:17:25 <jle`> ($) f x = f x
03:17:25 <sshine> flip ($) is just applying backwards.
03:17:39 <jle`> ($) takes a function and a value, and returns the function applied to that vallue
03:17:41 <sshine> isn't there a a (&) somewhere for this?
03:17:48 <bernalex> sshine: Data.Function.
03:17:56 <jle`> flip ($) takes a value and a function and returns the function applied to that value
03:18:00 <jle`> well, not until 7.10 :)
03:18:03 <sshine> i.e. (&) = flip ($)
03:18:04 <sshine> ok.
03:18:30 <bernalex> sshine: yes
03:18:34 <bernalex> @src (&)
03:18:34 <lambdabot> Source not found. There are some things that I just don't know.
03:18:36 <bernalex> oh well
03:18:38 <bernalex> :t (&)
03:18:39 <lambdabot> a -> (a -> b) -> b
03:19:00 <nbl_> what is "<
03:19:02 <ph88> > (&) [1,2,3] <*> [(*2), (+1)]
03:19:03 <nbl_> what is "<$>"
03:19:04 <lambdabot>  Couldn't match expected type ‘[(a0 -> a0) -> b]’
03:19:04 <lambdabot>              with actual type ‘([t0] -> b0) -> b0’
03:19:11 <ph88> hhmm
03:19:12 <jle`> forwards $ Backwards [(*2),(+1)] <*> Backwards [1,2,3]
03:19:14 <jle`> should also work
03:19:21 <jle`> ph88: you forgot the (<$>)
03:19:24 <sshine> @pl (<$>)
03:19:24 <lambdabot> (<$>)
03:19:36 <ph88> > (&) <$> [1,2,3] <*> [(*2), (+1)]
03:19:37 <lambdabot>  [2,2,4,3,6,4]
03:19:51 * hackagebot reasonable-lens 0.2.1.0 - Lens implementation. It is more small but adequately.  http://hackage.haskell.org/package/reasonable-lens-0.2.1.0 (outoftune)
03:19:53 * hackagebot nonlinear-optimization-ad 0.2.0 - Wrapper of nonlinear-optimization package for using with AD package  http://hackage.haskell.org/package/nonlinear-optimization-ad-0.2.0 (MasahiroSakai)
03:19:57 <sshine> nbl_, <$> is fmap
03:21:09 <ph88> flip id <$>   =   (&) <$>      <sshine> i.e. (&) = flip ($)   forgot id ?
03:21:26 <nbl_> sshine: ok ty =)
03:21:55 <sshine> ph88, no, id and ($) do the same thing here, as jle` said.
03:22:06 <jle`> :t flip ($)
03:22:06 <lambdabot> b -> (b -> c) -> c
03:22:08 <jle`> :t flip id
03:22:08 <lambdabot> b -> (b -> c) -> c
03:22:11 <jle`> magic
03:22:22 <ph88> that's magic indeed !
03:22:32 <bernalex> $ is just id where a = a->b
03:22:39 <bernalex> :t ($)
03:22:40 <lambdabot> (a -> b) -> a -> b
03:22:41 <bernalex> :t id
03:22:41 <sshine> ph88, ($) is the identity function for functions 'a -> b'.
03:22:42 <lambdabot> a -> a
03:22:58 <ph88> thanks guys
03:22:59 <ph88> :)
03:23:05 <jle`> eta reduction can be fun too
03:23:24 <jle`> f $ x = f x   ==>  ($) f x = f x  ==> ($) f = f
03:23:33 <jle`> ($) f = f?  looks like ($) = id
03:27:34 <ddellacosta> so, according to this: http://blog.ezyang.com/ ...an unsafe FFI call will block.  So if I have a bunch of unsafe FFI calls in main, theoretically they should be blocking.  So if they are not executing, then the problem has to be something to do with my understanding of IO and laziness (presumably)?  Referring to this code: https://gist.github.com/ddellacosta/a06e2405a2914216f195 which is a port of: https://xiph.org/ao
03:27:34 <ddellacosta> /doc/ao_example.c
03:27:39 <ddellacosta> whoops: https://xiph.org/ao/doc/ao_example.c
03:29:52 * hackagebot yarr-image-io 1.3.2.1 - Image IO for Yarr library  http://hackage.haskell.org/package/yarr-image-io-1.3.2.1 (DominicSteinitz)
03:29:59 <mjrosenb> :t (<$>)
03:30:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:30:32 <mjrosenb> All monads are functors, yes?
03:31:33 <jle`> yeah, but as of now, not all Monad instances are required to have a Functor instance
03:33:40 <mjrosenb> cool, so I can use <$> in a monad without fear that it'll break randomly if someone tries to use it on a monad that isn't a functor
03:34:13 <jle`> you can use (<$>) on specific types
03:34:27 <jle`> but you can't use (<$>) right now if your function is something like foo :: Monad m => ... -> m a
03:36:14 <mjrosenb> ok, another silly question: why is Functor in Data, rather than Control?
03:38:16 <merijn> ddellacosta: You should almost certainly NOT use unsafe for FFI functions unless you know what you're doing
03:38:32 <merijn> ddellacosta: unsafe will, potentially, hang all of your haskell code
03:38:45 <ddellacosta> merijn: oh, I see.  I thought the reason to use it was to imply that it was impure...I misunderstood
03:38:52 <merijn> mjrosenb: Ridiculous hysterical raisins
03:39:24 <merijn> ddellacosta: safe/unsafe means "call in a safe way" vs "call in an unsafe way", NOT "the function is safe" vs "the function is unsafe"
03:39:43 <merijn> Also, you can leave out safe/unsafe and it will use the sensible default of "safe"
03:39:52 * hackagebot yarr 1.3.3.3 - Yet another array library  http://hackage.haskell.org/package/yarr-1.3.3.3 (DominicSteinitz)
03:40:01 <merijn> ddellacosta: The way to show that a functions is impure is by simply marking it's return value as IO
03:40:36 <merijn> i.e. "void foo(int, int)" becomes "foreign import safe "foo blah.h" c_foo :: CInt -> CInt -> IO ()"
03:40:58 * ddellacosta goes back to read up on unsafe
03:40:58 <ddellacosta> merijn: for example, the Haskell wikibook FFI section (http://en.wikibooks.org/wiki/Haskell/FFI)--which maybe is a bad reference, I dunno--says:
03:40:58 <ddellacosta> We then specify that we are importing a foreign function, with a call to C. A "safety level" has to be specified with the keyword safe (the default) or unsafe. In general, unsafe is more efficient, and safe is required only for C code that could call back a Haskell function. Since that is a very particular case, it is actually quite safe to use the unsafe keyword in most cases.
03:40:58 <ddellacosta> merijn: okay, got it, thanks for clarifying that for me
03:41:36 <merijn> ddellacosta: unsafe basically means "call RIGHT HERE in the current haskell thread like a normal C function call"
03:42:01 <merijn> ddellacosta: Which means that until the C function returns, the haskell thread is blocked and thus GC is also blocked (potentially impacting other threads)
03:42:30 <ddellacosta> merijn: so, now I'm even more confused--if that's the case, why isn't it blocking in my do block?  All my functions are currently defined as unsafe at the present time
03:42:32 <merijn> ddellacosta: safe calls are more expensive, because they're handed of to a new "system/foreign call"-thread. Which means the haskell thread remains unblocked
03:43:08 <merijn> ddellacosta: Show me a minimal example?
03:43:20 <ddellacosta> merijn: more generally, how does one ensure FFI code is run in an imperative fashion, or should a do block enforce that?
03:43:20 <ddellacosta> sure
03:43:20 <ddellacosta> merijn: https://gist.github.com/ddellacosta/a06e2405a2914216f195
03:43:34 <merijn> ddellacosta: What do you mean "imperative fashion"?
03:43:50 <ddellacosta> merijn: oh, I mean by that, you need X to execute and then Y, in that order
03:44:14 <merijn> ddellacosta: The IO return value of your foreign call already enforces that
03:44:42 <ddellacosta> merijn: okay, so that's what I thought--but for example, as a test, I put some putStrLn in the code I just sent you the gist to
03:44:55 <ddellacosta> merijn: and the putStrLn ran, then the audio came out in a garbled fashion
03:45:10 <ddellacosta> but the call to the audio fn happened before that, sequentially, in the do block
03:45:14 <merijn> ddellacosta: basically, while the foreign call happens on another thread, the haskell thread that started it is suspended until it returns
03:45:15 <ddellacosta> I'm confused by what to expect
03:45:42 <merijn> ddellacosta: As long as your foreign signatures have IO results, they will do exactly what you expect
03:46:02 <merijn> ddellacosta: All this stuff deals with foreign calls from multiple concurrent threads and how they impact what happens
03:46:58 <ddellacosta> merijn: I see, so the foreign import etc.... line itself needs to have an IO return value?  I'd been wrapping those in functions that return IO instead, maybe that's my mistake?
03:47:07 <merijn> ddellacosta: Yes
03:47:20 <ddellacosta> I see!
03:47:30 <merijn> If your foreign imports don't show an IO return value, then GHC will assume they're pure and do whatever it likes with them
03:47:37 <exfalso> hi, is there a quasiquoter that parses haskell expressions?
03:47:39 <ddellacosta> oh wow, that makes sense
03:48:03 <ddellacosta> merijn: wow, thanks so much for your explanation. That was extremely helpful.
03:48:42 <exfalso> that is is there a way to access the quasiquoter that's used when using plain [||] splices?
03:49:36 <ddellacosta> merijn: and one last question--can I just cavalierly change, for example, CInt to IO CInt in my FFI declarations?
03:49:40 <ddellacosta> I guess I should just try it and see
03:49:43 <ddellacosta> seems like magic to me though
03:49:44 <merijn> ddellacosta: Yes
03:49:51 <ddellacosta> merijn: okay, thanks
03:49:53 * hackagebot cabal-lenses 0.4.3 - Lenses and traversals for the Cabal library.  http://hackage.haskell.org/package/cabal-lenses-0.4.3 (DanielTrstenjak)
03:50:01 <merijn> ddellacosta: See some examples of importing/using C functions here: https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L237-L256
03:50:20 <merijn> ddellacosta: Though I just realised the foreign import of errno is completely wrong, so don't do that like I did >.>
03:50:23 <exfalso> ddellacosta: by default thats what you should do, non-IO FFI should only be used if you're 101% sure its a pure function
03:50:29 <ddellacosta> merijn: haha, okay, gotcha
03:50:53 <ddellacosta> exfalso: right, thanks, I think merijn said basically the same thing above.  This is all super helpful.
03:50:58 <merijn> ddellacosta: Have you read the FFI chapter of the report?
03:51:18 <merijn> ddellacosta: It specifies exactly how haskell has to marshal/convert values across the FFI
03:52:05 <ddellacosta> merijn: is that this?  https://www.haskell.org/onlinereport/haskell2010/haskellch8.html
03:52:10 <merijn> Yeah
03:52:22 <merijn> Especially the section of foreign types/marshallable foreign types
03:52:32 <ddellacosta> merijn: no, I haven't, just skimmed it.  I'll read it more carefully now.
03:53:24 <callumacrae> Learn You a Haskell for Great Good just arrived :D
03:53:35 <clrnd> quick question, do sandboxes `see` user-level cabal-installed pkgs?
03:53:40 <ddellacosta> wonderful, I have learned so much in like five minutes. Thanks again merijn
03:54:18 <merijn> ddellacosta: The short summary is that a "marshallable foreign result type" includes "IO t where t is a marshallable foreign result type", i.e. "you can wrap any return value for a foreign function with IO"
03:54:43 <ddellacosta> I see
03:55:29 <merijn> ddellacosta: See also http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/ and http://blog.ezyang.com/2014/12/unintended-consequences-bound-threads-and-unsafe-ffi-calls/
03:55:45 <merijn> As it starts out "Attention conservation notice. Don’t use unsafe in your FFI imports! We really mean it!"
03:56:11 <ddellacosta> merijn: gotcha.  Yeah, I only discovered his c2hs series yesterday, it was a revelation.  I'll dig into those posts too, thanks
03:56:23 <ddellacosta> that's a really great blog
04:00:41 <merijn> And now for something completely different
04:01:20 <merijn> The free category of any connected graphs is essentially just the fully connected version of that graph, no?
04:09:53 * hackagebot cayley-client 0.1.0.0 - An Haskell client for Cayley graph database  http://hackage.haskell.org/package/cayley-client-0.1.0.0 (MichelBoucey)
04:19:00 <deni> is hackage broken right now? i can't even install cabal
04:20:09 <deni> i have no idea what this means: http://dpaste.com/0A99KS8
04:21:09 <dcoutts_> deni: looks like you deleted all your package files, without unregistering them
04:22:00 <deni> dcoutts_: well I had cabal installed in ~/.cabal and i just removed that directory
04:22:12 <dcoutts_> right, exactly.
04:22:13 <deni> dcoutts_: where were the packages registered if not in that directory?
04:22:23 <dcoutts_> ~/.ghc
04:23:00 <deni> dcoutts_: ah...makes sense. i f-ed up..sorry for the noise. tnx for your help. :)
04:23:53 <deni> for the record i only jumped at hackage cause i saw a new issue on github that mentioned something not working properly (and I didn't quite understand what)
04:24:47 <deni> 99% of the time it's a bug on my machine so I should have known
04:29:54 * hackagebot wai-extra 3.0.4.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.4.1 (MichaelSnoyman)
04:29:56 <bartavelle> Is there a package that's a bit like "mvc" but for implementing network servers ? Extra points if it has native integration with cereal (so that I don't have to handle leftovers of ByteStrings)
04:30:26 <bartavelle> actually it won't work with something like mvc as the server has to send out of band messages :(
04:30:56 <bartavelle> but something that accepts connections on a given port and abstracts for me bidirectionnal tcp communication
04:34:33 <mjrosenb> ok, so if (Either a) is a monad, then (Either String) is equivalent to a failure monad, where the right type is the non-error type, and errors are represented as strings, yes?
04:35:53 <hyPiRion> yes
04:35:59 <merijn> bartavelle: Tekmo had a post on MVC for pipes, I think?
04:36:15 <merijn> bartavelle: FYI, cereal is slowly becoming deprecated
04:36:29 <merijn> bartavelle: binary has incremental parsing now, so there's not much use for cereal anymore
04:36:36 <bartavelle> merijn, the problem of mvc is that you need to have a finite amount of inputs, or else you need another thread to multiplex
04:36:49 <bartavelle> merijn, hah I didn't know that, I'll switch to binary then
04:37:38 <merijn> bartavelle: The main "advantage" left for cereal is builder for strict ByteStrings, but I've been informed that building a lazy ByteString and then using toStrict is actually asymptotically faster
04:37:54 <bartavelle> wait what ?
04:38:05 <bartavelle> that shouldn't be the case :)
04:38:07 <merijn> bartavelle: Appending to lazy ByteStrings is cheaper
04:38:18 <bartavelle> yeah but appending builders should be cheap too ?
04:38:20 <merijn> Or, I guess not appending, but building them
04:38:27 <bartavelle> oic
04:38:57 <merijn> bartavelle: The lazy ByteString builder is cheaper than the strict one, I'm just parroting what I've been told in the past, so take it with a grain of salt :p
04:39:24 <bartavelle> I don't have much performance needs anyway, I won't dig that deep
04:39:26 <bartavelle> for now
04:39:41 <bartavelle> let's convert all the things to binary *sigh*
04:40:47 <merijn> bartavelle: I wouldn't bother if you've already written everything with cereal
04:40:58 <merijn> Just more of a thing to keep in mind for future code :)
04:42:40 <bartavelle> I'm just startijng
04:43:35 <bartavelle> it's not like it's complicated though
04:46:08 <mjrosenb> @hoogle m a -> EitherT e m a
04:46:10 <lambdabot> Warning: Unknown type EitherT
04:46:10 <lambdabot> No results found
04:46:32 <mjrosenb> :t eitherT
04:46:33 <lambdabot>     Not in scope: ‘eitherT’
04:46:33 <lambdabot>     Perhaps you meant ‘either’ (imported from Data.Either)
04:46:39 <mjrosenb> :-(
04:47:04 <mjrosenb> @hoogle m a -> Control.Monad.Trans.Either.EitherT e m a
04:47:05 <lambdabot> Parse error:
04:47:05 <lambdabot>   m a -> Control.Monad.Trans.Either.EitherT e m a
04:47:05 <lambdabot>                  ^
04:47:24 <mjrosenb> lambdabot: well, you aren't being very useful, now are you?
04:47:58 <clrnd> @hoogle m a -> ErrorT e m a
04:47:59 <lambdabot> Control.Monad.Trans.Error throwError :: (Monad m, Error e) => e -> ErrorT e m a
04:48:11 <mjrosenb> *ErrorT* ?
04:48:14 <mjrosenb> :-(
04:48:18 <clrnd> lulz
04:49:47 <merijn> There's ExceptT too, which doesn't require the Error instance
04:50:22 <mjrosenb> can I just use EitherT String, and hope for the best?
04:51:04 <clrnd> I preffer EitherT most times
04:51:26 <mjrosenb> I have a a computation that returns m a, and I want to change that into EitherT String m a, but I can't seem to find a function that will do that.
04:52:05 <merijn> :t lift
04:52:06 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
04:52:37 <mjrosenb> @hoogle lift
04:52:37 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
04:52:38 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
04:52:38 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
04:52:53 <tdammers> the Monad.Trans.Class one
04:53:57 <mjrosenb> ahh, of course the issue is I haven't imported the correct library
05:09:10 * mjrosenb has more silly questions.
05:09:45 <mjrosenb> with an EitherT or an ErrorT, is there a way to handle pattern match failures as a value of this type?
05:10:03 <mjrosenb> being able to do this would make my code slightly nicer.
05:11:26 <merijn> mjrosenb: Try the Alternative/MonadPlus instances?
05:11:36 <merijn> > mplus (Left 1) (Right 'c')
05:11:37 <lambdabot>  No instance for (GHC.Show.Show a0)
05:11:37 <lambdabot>    arising from a use of ‘M150794475264151896828108.show_M1507944752641518968...
05:11:37 <lambdabot>  The type variable ‘a0’ is ambiguous
05:11:45 <clrnd> ehm, match on `otherwise` and return Left?
05:11:47 <merijn> > mplus (Left 1) (Right 'c') :: Either Int Char
05:11:48 <lambdabot>  No instance for (Control.Monad.Trans.Error.Error GHC.Types.Int)
05:11:48 <lambdabot>    arising from a use of ‘Control.Monad.mplus’
05:11:54 <merijn> wait, what?
05:12:14 <merijn> :t mplus `asAppliedTo` (Left 'c')
05:12:15 <lambdabot>     No instance for (Error Char) arising from a use of ‘mplus’
05:12:15 <lambdabot>     In the first argument of ‘asAppliedTo’, namely ‘mplus’
05:12:15 <lambdabot>     In the expression: mplus `asAppliedTo` (Left 'c')
05:12:20 <merijn> ugh
05:12:30 <merijn> monadplus instance requires an instance of Error? >.<
05:12:39 <clrnd> thats weird
05:12:45 <merijn> > mplus (Left "test") (Right 1)
05:12:46 <lambdabot>  Right 1
05:12:55 <clrnd> @info MonadPlus
05:12:55 <lambdabot> MonadPlus
05:12:57 <merijn> hmm, ok not that one
05:13:02 <merijn> clrnd: There is no @info
05:13:06 <mjrosenb> merijn: that is what I'm doing now, but it (obviously) requires using case, or something that supports multiple patterns
05:13:28 <merijn> mplus/Alternative don't require case
05:13:33 <mjrosenb> I'd like to be able to just use a binding from a do block, to handle the one non-error case
05:13:47 <mjrosenb> and let a pattern match failure turn into an error value for all the other cases.
05:13:49 <merijn> Pattern match fail in do blocks results in fail
05:13:58 <merijn> And what "fail" is implemented as depends on the monad
05:14:16 <mjrosenb> ok, so this is currently EitherT String
05:14:48 <mjrosenb> the docs page for Either didn't seem to mention what the implementation of fail looked like
05:15:00 * mjrosenb suspects it isn't implemented?
05:19:56 * hackagebot plot 0.2.3.3 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.2.3.3 (VivianMcPhail)
05:19:58 * hackagebot hpc-coveralls 0.8.0 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.8.0 (killy971)
05:26:43 <clrnd> mjrosenb, why not use a case? maybe with XLambdaCase, it's more explicit
05:26:47 <clrnd> I like it
05:28:14 <mjrosenb> clrnd: because Pat foo <- bar looks nicer than tmp <- bar; case tmp of ...
05:30:44 <clrnd> that's totally subjective I'd say :P
05:31:26 <merijn> "bar >>= \case Left _ -> blah; Right _ -> stuff" <3
05:33:08 <deech> Hi all, I have a project where I build some C files into one static lib and some Haskell files into another. I'd like Cabal to publish them as one static library. Is there any support for this?
05:33:59 <dcoutts_> deech: cabal can compile simple C files and link them into the same lib as the Haskell lib
05:34:47 <deech> dcoutts_: The build process for the C files is unfortunately not simple. They have their own Makefile.
05:35:25 <dcoutts_> deech: then the other standard approach is to install the C lib first, and then have the haskell lib depend on it as an external library.
05:37:50 <deech> dcoutts_: At the `buildHook` step I have my C .o files in a directory. Is there some way to append them in the static Haskell lib after linking?
05:39:20 <merijn> deech: Change the GHC arguments to include the .o files?
05:39:33 <deech> merijn: Ooh, that would work?
05:41:15 <merijn> deech: Sure
05:41:20 <merijn> Last I tried anyway
05:41:28 <deech> merijn: Neat. I'll try that. Thanks!
05:50:39 <merijn> btw, now that Swift's been out for awhile. Anyone played around with it? What are your thoughts?
05:51:05 <benzrf> i have not played around with it and yet i can confidently tell you that it looks like Scala By Apple
05:51:21 <benzrf> ^100% unfounded
05:51:29 <SharpGAF> benzrf: It looks like every language.
05:51:47 <merijn> benzrf: Basically, I'm trying to keep tabs on how sucky it is, because it's useful to keep tabs on things important for Money-Oriented Programming ;)
05:52:20 <benzrf> it looks like if ruby were inspired by objective-c instead of perl, perhaps
05:52:35 <merijn> benzrf: I would take "comparable/slightly better than F#" or "Scala by Apple" to be fairly major improvements for Money-Oriented Programming, compared to C#/Java/C/C++
05:53:34 <sivteck> MOP Paradigm
05:54:58 * hackagebot fwgl 0.1.0.0 - FRP 2D/3D game engine  http://hackage.haskell.org/package/fwgl-0.1.0.0 (ZioCrocifisso)
06:05:49 <SwashBuckla> haskell.org is down?
06:05:56 <SwashBuckla> or at least v. slow to load
06:07:39 <merijn> SwashBuckla: It's slow, yeah
06:17:08 <clrnd> super slow lately, whats up with that?
06:19:59 * hackagebot lucid 2.6.0 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-2.6.0 (ChrisDone)
06:24:05 <sbrg> Given a quickcheck property that tests whether two functions return the same results for some random inputs, is it possible for me to do something so that the results of the functions are returned as well when the property fails?
06:26:24 <merijn> sbrg: QuickCheck should do that by default?
06:26:53 <merijn> @check \(xs :: [Int]) -> xs == reverse xs
06:26:54 <lambdabot>  <unknown>.hs: 1: 16:ScopedTypeVariables is not enabled
06:26:57 <merijn> hm
06:27:25 <merijn> @check \xs -> (xs :: [Int]) == reverse xs
06:27:26 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 1 shrink):
06:27:27 <lambdabot>  [0,1]
06:27:31 <Cale> If you test \x -> f x == g x  then it will print x, but won't print f x or g x
06:27:35 <sbrg> merijn: in this case, I want not only the xs parameter in your example, but the result from running, say "f xs" vs "g xs"
06:27:42 <sbrg> what cale said
06:27:47 <merijn> ah
06:27:50 <Cale> You can probably make use of the counterexample function
06:28:04 <Cale> :t counterexample
06:28:05 <lambdabot> Testable prop => String -> prop -> Property
06:29:01 <Cale> @check \xs -> counterexample (show (reverse xs)) ((xs :: [Int]) == reverse xs)
06:29:02 <lambdabot>  *** Failed! Falsifiable (after 5 tests and 3 shrinks):
06:29:02 <lambdabot>  [0,1] [1,0]
06:29:43 <sbrg> alright, thanks. I'll try that
06:29:48 <Cale> oh, also
06:29:58 <Cale> @check \xs -> (xs :: [Int]) === reverse xs
06:29:59 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 2 shrinks):
06:29:59 <lambdabot>  [0,1] [0,1] /= [1,0]
06:30:15 <Cale> that prints out what it was that wasn't equal
06:30:29 <sbrg> oh, that seems better
06:30:31 <Cale> (===) :: (Eq a, Show a) => a -> a -> Property
06:30:31 <Cale> x === y = counterexample (show x ++ " /= " ++ show y) (x == y)
06:30:52 <sbrg> I see
06:30:55 <sbrg> that was precisely what I needed
06:30:57 <sbrg> thanks!
06:31:23 <rom1504> what's Property ?
06:31:44 <ph88> what's id ?
06:31:52 <sbrg> ph88: the identity function
06:31:55 <sbrg> @src id
06:31:55 <lambdabot> id x = x
06:32:23 <ph88> so it takes one value and gives back the same value ?
06:32:37 <mmmm> in fact, that's the only thing it can do
06:32:54 <mmmm> as the type is id :: a -> a
06:33:03 <ph88> so here it's because flip usually take 2 arguments ?
06:33:05 <ph88> > flip id <$> [1,2,3] <*> [(*2), (+1)]
06:33:07 <lambdabot>  [2,2,4,3,6,4]
06:33:09 <Cale> rom1504: You can check out the definition here: https://hackage.haskell.org/package/QuickCheck-2.7.6/docs/Test-QuickCheck-Property.html
06:33:16 <ph88> :t flip
06:33:16 <lambdabot> (a -> b -> c) -> b -> a -> c
06:33:25 <rom1504> Cale: ok thanks
06:33:35 <ph88> oh even 3 arguments o_O
06:33:47 <sbrg> :t flip id
06:33:48 <lambdabot> b -> (b -> c) -> c
06:34:30 <ph88> what's the order of evaluation predence in    flip id <$> [1,2,3] <*> [(*2), (+1)]     first <$>  or <*>    ?
06:34:55 <mauke> order of evaluation and operator precedence are very different things
06:35:13 <ph88> ok operator precedence
06:35:21 <mauke> <$> binds tighter
06:35:30 <mauke> (x <$> y) <*> z
06:35:36 <ph88> oh
06:35:41 <mauke> at least I hope it does
06:35:54 <mauke> otherwise you'd get a type error :-)
06:35:55 <ph88> > flip id <$> [1,2,3]
06:35:56 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable c0)
06:35:56 <lambdabot>    arising from a use of ‘M660830520987490445029403.show_M6608305209874904450...
06:35:56 <lambdabot>  The type variable ‘c0’ is ambiguous
06:35:59 <ph88> :t flip id <$> [1,2,3]
06:36:00 <lambdabot> Num a => [(a -> c) -> c]
06:37:03 <ph88> so it turns 1,2,3 into 3 functions which take a function, and output the output of that function
06:37:10 <merijn> ph88: You can ask ghci what the precedence of operators is by using ":i <$>"
06:37:24 <ph88> :i flip id <$> [1,2,3] <*> [(*2), (+1)]
06:37:24 <merijn> ph88: The default (when no precedence is shown) is infixl 9
06:38:04 <mauke> lambdabot is not ghci
06:38:13 <ph88> noted
06:38:45 <merijn> Also, :i I don't think :i does something meaningful for arbitrary expressions
06:39:18 <ph88> so what's this?    Num a => [(a -> c) -> c]    a list of functions which take functions ?
06:39:28 <ph88> which take a value
06:39:31 <ph88> Num
06:40:12 <merijn> ph88: Correct
06:40:28 <merijn> A list of functions whose argument is a function that takes any Num instance :)
06:40:47 <ph88> where did the actual Num instance go? like the 1,2,3  ?
06:41:17 <ph88> i can understand that for example (*2) can go into  (a -> c)
06:42:02 <ph88> the type information does not show it has a value packed inside ?
06:42:07 <merijn> ok, first let's see what "flip id" does
06:42:13 <merijn> :t flip id
06:42:14 <lambdabot> b -> (b -> c) -> c
06:42:24 <merijn> Do you understand that type?
06:42:54 <merijn> :t id
06:42:55 <lambdabot> a -> a
06:43:01 <clrnd> > flip id $ 1 (+1)
06:43:02 <lambdabot>  Could not deduce (GHC.Num.Num ((a0 -> a0) -> s))
06:43:02 <lambdabot>    arising from the ambiguity check for ‘e_111’
06:43:02 <lambdabot>  from the context (GHC.Num.Num ((a -> a) -> s), GHC.Num.Num a)
06:43:04 <mauke> instances of Num are types
06:43:15 <mauke> the "actual Num instance" would be Integer here
06:43:21 <merijn> Let's mentally replace 'a' with "(b -> c) -> (b -> c)" do you still see how that is equal to 'id'?
06:43:42 <ph88> merijn: it's a function which takes a value and a function and returns the output value when applying that value to the function
06:43:58 <merijn> Now, we note that that is identical to "(b -> c) -> b -> c" and if we apply 'flip' to that, then we get the "obvious" "b -> (b -> c) -> c", yes?
06:44:47 <ph88> ye ok
06:44:51 <merijn> "(b -> c) -> b -> c" does "take a function and a 'b', then apply the function to 'b'", yes?
06:45:19 <merijn> So "b -> (b -> c) -> c" does "take a 'b' and a function, then apply the function to 'b'"
06:46:01 <merijn> So if we partially apply "b -> (b -> c) -> c" we get "(b -> c) -> c" which says "if you give me a function that takes a 'b', I'll give you whatever that function returns
06:46:09 <ph88> it's just take when i read this     Num a => [(a -> c) -> c]    i just read it as some inner function takes Num   ... but since i already supplied a list of Nums    :t flip id <$> [1,2,3]    i don't expect to see this in the type description
06:46:15 <merijn> This is called CPS (continuation passing style)
06:46:50 <merijn> ph88: It's basically saying "if you give me a function that takes a number, I will apply it to *some* number and give you back the result"
06:47:49 <ph88> i thought that *some* number was already part of the type
06:48:55 <ParahSailin> i upgraded to cabal 1.22 last night and now am having difficulty installing local packages to sandbox: "ghc-pkg: cannot create: dist/dist-sandbox-4a4757b/package.conf.inplace already exists"
06:49:00 <merijn> ph88: Well, suppose you gave me a function "Bool -> Char", how could I give you back a Char? I only have a number to apply the function too...
06:49:15 <tdammers> ParahSailin: rm -rf dist; cabal install # fixed that for me
06:49:26 <tdammers> ("if in doubt, use brute force")
06:49:39 <merijn> ph88: To give you back ANY result, I need to apply your function to SOME value, but the only value I have is a number
06:49:52 <merijn> ph88: Therefore, I can only accept functions that can be applied to numbers
06:49:58 <ParahSailin> tried brute force already
06:50:10 <merijn> :t flip id <$> ([1,2,3] :: [Int])
06:50:10 <lambdabot> [(Int -> c) -> c]
06:50:18 <merijn> Maybe this is less confusing?
06:50:55 <merijn> I promise to give you back ANY 'c', but the only way I have to construct c's is by using your function. Since I only have an Int to apply to, your function *has* to accept an Int
06:51:37 <ParahSailin> tdammers: is there a different dist i need to delete too?
06:51:47 <ParahSailin> a dist hidden in .cabal-sandbox or something?
06:51:48 <tdammers> ParahSailin: not that I know of
06:52:00 <tdammers> although I did drop and recreate the entire sandbox
06:52:14 <ParahSailin> same here
06:53:05 <ph88> merijn: ah yes i understand now ... it's not the Num that still has to be applied ... it's a list of functions that take a Num that have to be supplied ...
06:53:36 <merijn> ph88: Right :)
06:53:45 <Phillemann> Is is possible to compile a dependency of my program with specific cabal flags (the ones displayed on the bottom the hackage page, enabled with -f)?
06:53:52 <merijn> ph88: May also wanna read up on CPS for more examples/usecases of this sorta function
06:53:58 <merijn> Phillemann: No
06:53:59 <Phillemann> I mean, without checking out the source code manually and doing a cabal install.
06:54:17 <merijn> Phillemann: Package functionality should not depend on flags
06:55:00 * hackagebot yesod-markdown 0.9.3 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.9.3 (PatrickBrisbin)
06:55:15 <Phillemann> That makes sense, really, but I'd like to configure this dependency nontheless (just for my system).
06:55:17 <ph88> merijn: is there also some way to find out which primitive data is already contained ?
06:55:59 <merijn> ph88: Other than the type signature? No
06:58:48 <ph88> so i could also look at flip as   a modifier for a type so that it goes from    Value to      Function that takes Value    right ?
06:59:21 <merijn> ph88: That depends on the function that is passed to flip
06:59:50 <merijn> Flip really just swaps two arguments around. It's just that THAT in combination with 'id' leads to an "odd" type
06:59:53 <merijn> :t id
06:59:53 <ph88> oh this only goes for     flip id    ?
06:59:54 <lambdabot> a -> a
06:59:58 <merijn> :t flip
06:59:58 <lambdabot> (a -> b -> c) -> b -> a -> c
07:00:17 <merijn> :t flip `asAppliedTo` (undefined :: Int -> Bool -> Char)
07:00:17 <lambdabot> (Int -> Bool -> Char) -> Bool -> Int -> Char
07:00:19 <ph88> ok so    flip id    is already pretty powerful, and does what i said above  ?
07:01:01 <ph88> :t flip id `asAppliedTo` 1
07:01:01 <lambdabot> Num a => a -> (a -> c) -> c
07:01:08 <merijn> The point is that GHC tries to unify the type of 'flip' and 'id' and it turns out that this is possible *if* you specialise id's type to be "(b -> c) -> (b -> c)"
07:01:28 <merijn> ph88: I prefer to use Char for this sorta thing, this eliminates the Num constraint
07:01:35 <merijn> :t flip id `asAppliedTo` 'c'
07:01:35 <lambdabot> Char -> (Char -> c) -> c
07:02:13 <ph88> hhmm i would expect     (Char -> c) -> c     here
07:02:49 <c_wraith> ph88: remember, id is the same as ($)
07:03:09 <ph88> i know   id   more than i do    ($)
07:03:22 <merijn> ph88: asAppliedTo doesn't apply anything
07:03:28 <SrPx> Hello, I have a datatype, "Skeleton", that could be described as: "data Bone = Bone { data :: Foo, children :: [Bone] }; type Skeleton = Bone" or "data Bone = Bone { data :: Foo }; type Skeleton = Tree Bone". My question is: what should I prefer? To define the "tree" structure myself, or to use the prelude Tree on my type and be able to use its functions?
07:03:42 <merijn> ph88: So that's the type of "flip id" specialised to what it would be "if I wanted to apply it to 'c'"
07:03:48 <merijn> Else you'd do
07:03:51 <merijn> :t flip id 'c'
07:03:52 <lambdabot> (Char -> c) -> c
07:03:56 <ph88> merijn: d0h :P ok that was stupid
07:04:20 <ph88> ok brilliant, i got this part now :P
07:08:51 <clrnd> SrPx, if it's a Tree, then use a Tree, right?
07:09:08 <mitu> textArgs <- fmap T.pack getArgs -- is this obviously wrong? T here is Data.Text
07:09:50 <mauke> :t T.Pack
07:09:50 <lambdabot> Not in scope: data constructor ‘T.Pack’
07:10:01 <mauke> :t T.pack
07:10:02 <lambdabot>     Not in scope: ‘T.pack’
07:10:02 <lambdabot>     Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
07:10:06 <mauke> aw, man
07:10:14 <mauke> mitu: I'm going to assume it's String -> Text
07:10:26 <mauke> in which case the problem is that you're giving it a list of strings, not a string
07:10:29 <ij> It seems that you can make a mappend from a monad bind, since (=<<) . return can be constrained to it, but can you make a mempty from return?
07:10:29 <mitu> :t Data.Text.pack
07:10:30 <lambdabot> String -> Data.Text.Internal.Text
07:10:55 <mitu> mauke: have I forgotten what fmap does?
07:11:08 <mauke> mitu: fmap does one level
07:11:10 <mauke> getArgs is two
07:11:12 <mauke> IO [String]
07:11:33 <mitu> I'd like to pack every argument
07:11:41 <clrnd> fmap fmap ? :P
07:11:43 <mauke> fmap (map T.pack)
07:11:46 <ph88> merijn: i made flip id in javascript :P    http://pastebin.com/UQYK2C3q
07:11:54 <mauke> T.pack :: String -> Text
07:12:02 <SrPx> clrnd: if you say so, right (:
07:12:02 <mauke> map T.pack :: [String] -> [Text]
07:12:08 <mitu> oh derp
07:12:12 <mauke> fmap (map T.pack) :: IO [String] -> IO [Text]
07:12:19 <clrnd> :t (<$>).(<$>)
07:12:20 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
07:12:39 <ddellacosta> I'm stumped, how do I convert a Floating a to a CChar in Haskell?  I'm trying to mimic some C code which casts a float to (int) and stuffs it into a char array.  I was just using floor but I'm getting wildly different values so I figure I must be doing something wrong.
07:12:59 <mauke> show the C code
07:13:13 <ph88> that would be pretty useful for people new to haskell that you can take a piece of haskell and convert it to javascript
07:13:17 <ddellacosta> mauke: sample = (int)(0.75 * 32768.0 * sin(2 * M_PI * freq * ((float) i/rate)));
07:13:19 <ph88> maybe lambdabot can do it
07:13:26 <clrnd> textArgs <- T.pack (<$>).(<$>) getArgs -- maybe? who knows
07:13:33 <mitu> mauke: thanks
07:13:34 <mauke> ddellacosta: ok, but that's no char array
07:13:49 <mauke> clrnd: misleading spacing :-(
07:13:56 <ddellacosta> mauke: I left out that part--here: https://xiph.org/ao/doc/ao_example.c
07:13:59 <idnar> can I give a type declaration for the pattern on the left of <- in a do block?
07:15:10 <SrPx> clrnd: I don't know, it make the thing bigger as I have to write (Node (Bone ...) [children]) instead of (Bone ... [children]), but if you say so
07:16:02 <ph88> can i set a variable on lamdabot ?    for the output of    flip id 'c'
07:16:06 <mauke> ddellacosta: ok, that seems simple enough. for the "wildly different values", are you comparing sample in C to sample in Haskell?
07:16:38 <ddellacosta> mauke: well, I'm just comparing them in ghci, I split out the C buffer generation code into a fn that I've got a FFI wrapper around, to test
07:16:44 <ph88> how can i set a variable on here ?   https://tryhaskell.org/
07:16:54 <mauke> ddellacosta: comparing what?
07:17:17 <ddellacosta> mauke: comparing my attempt and writing the buffer generation function in Haskell with the C version, the output I mean
07:17:23 <ddellacosta> my attempt at*
07:17:25 <mauke> you've lost me
07:18:01 <ddellacosta> mauke: I wrote a function that attempts to generate this buffer in Haskell.  I also wrapped up the C buffer generation code in a single C function and wrote an FFI wrapper for it
07:18:08 <ddellacosta> mauke: then I run them both in ghci, and compare the output
07:18:48 <ddellacosta> mauke: it's obvious that the one I wrote in Haskell is not producing the same values as the C version, and furthermore the C version actually generate values that work (they play a tone as in the original C example code)
07:19:10 <clrnd> SrPx, do you need the Bone constructor? why not just `Node "Stuff" [cildren]`
07:19:37 <SrPx> clrnd: `data Bone a = Bone { len :: a, rotation :: Quaternion a }`
07:28:49 <zachstone> quit
07:32:21 <clrnd> jaja you fail at life
07:33:47 <dfeuer> 4
07:41:08 <zwer> ddellacosta it would help if you showed both your attempt at writing the haskell equivalent and the original C function
07:41:45 <lisbeth> I has question
07:41:46 <lisbeth> in this function: ghci> let (fw, rest) = span (/=' ') "This is a sentence" in "First word:" ++ fw ++ ", the rest:" ++ rest
07:41:53 <lisbeth> (fw, rest) is not a tulple correct?
07:43:25 <ddellacosta> zwer: original C: https://xiph.org/ao/doc/ao_example.c  My fn: https://gist.github.com/ddellacosta/0d5c98a248010ccc4709
07:43:52 <ddellacosta> d'oh, that should be floor
07:44:23 <ddellacosta> zwer: in any case, I've established that the sample generation and casting to int/floor is equivalent
07:44:32 <ddellacosta> zwer: so seems like I don't know what I'm doing w/the bit shifting
07:44:50 <ddellacosta> which is unsurprising to me, since I don't know what I'm doing with the bit shifting.
07:45:02 * hackagebot warp 3.0.5.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.5.1 (MichaelSnoyman)
07:45:12 * ddellacosta goes back to reading up on bitwise operations
07:45:25 * ddellacosta but would still love any suggestions from anyone
07:49:44 <mhd_> I compiled this code http://lpaste.net/117830 with ghc Main.hs. The executable generates the output correctly but ./Main | cat doesn't have output. Why?
07:50:45 <deni> quick question..I was installing ghc-mod into a sandbox....and noticed that it failed to compile...now the interesting part it the log it said it was .cabal-sandbox/logs/ghc-mod-0.3.0.log
07:50:56 <deni> meaning that it was installing the 0.3.0 version...which is ancient...
07:51:17 <deni> doesn't cabal install package-name install the latest version?
07:51:23 <mauke> mhd_: you haven't waited long enough
07:51:48 <zwer> ddellacosta does sample produce correct result with added floor?
07:52:11 <ddellacosta> zwer: no, I was just playing with the ceiling, I had floor in there originally and it didn't work
07:52:43 <Chathurga> What does piping to cat do in this case?
07:52:56 <mauke> Chathurga: make stdout not a terminal, thus enabling block buffering
07:53:05 <ddellacosta> zwer: I'm pretty sure at this point that it's some combination of the bitwise operations I'm doing and the types, as I have confirmed the C version outputs the same as the Haskell version at the point I call floor (in the Haskell version).  That is, the assignment to sample is identical.
07:53:39 <Chathurga> Oh right, didn't expect that
07:53:49 <mauke> mhd_: anyway, buffering
07:54:03 <mauke> add hFlush stdout after print to get output right away
07:55:16 <zwer> ddellacosta what is the value before you call  floor in haskell and cast it to int in C?
07:55:34 <nedo007> hello, excuse me, what was the haskell channel for beginners? #haskell-beginner ?
07:55:49 <arrdem> nedo007: #haskell-beginners
07:55:50 <nedo007> nevermind
07:55:54 <nedo007> thanks
07:55:55 <arrdem> you were close :P
07:55:59 <nedo007> i just though of using an s
07:56:08 <ddellacosta> zwer: well, it's slightly different at that point in C and Haskell, but after I call floor in Haskell and int in C, it's the same--at that point it is identical.
07:56:10 <mauke> it's also #haskell
07:56:50 <mhd_> thank you mauke  it works but it is a bit of strange for me
07:57:16 <ddellacosta> zwer: slightly different before floor (Haskell)/int casting (C) I mean, but only in terms of significant digits
07:57:27 <nedo007> well, i guess that here people that actually know the language a bit come and talk, and a guy that just started asking reading from a haskell book, would be better asking on the beginner's channel
07:57:27 <mauke> mhd_: oh?
07:57:44 <mauke> nedo007: we have both
07:57:44 <zwer> ddellacosta sorry, I misread. so the sample produces the correct value, and the issue is in fillSampleVector
07:58:17 <ddellacosta> zwer: yeah, seems like it's after the point I do the calculation that I'm screwing things up--somewhere in the bitwise operations and the stuffing it into the Seq
07:58:35 <ddellacosta> zwer: I'm surprised the bitwise operations are off though, testing it now seems like those should be identical too
07:58:41 <nedo007> mauke: thank you, i will keep that in mind, when i will need to ask questions, right now i am just learning :)
07:58:48 <ddellacosta> zwer: so maybe (probably) I'm confused about how the types work
07:59:38 <mhd_> why should I add hFlush stdout after print to turn on the output in the piping ./Main | cat ?
08:00:13 <qrpnxz> mhd_: Because output operations buffer.
08:00:13 <mauke> hFlush doesn't turn on output
08:01:06 <mauke> https://en.wikipedia.org/wiki/Shishi-odoshi
08:01:38 <qrpnxz> mauke: Nice.
08:01:55 <mauke> I got it from perlbot :-)
08:02:11 <qrpnxz> lol
08:02:21 <ddellacosta> what a lovely metaphor
08:03:13 <mhd_> Ok but why doesn't  ./Main | cat have output without hFlush?
08:03:17 <qrpnxz> This is one of the few IRC rooms that actually gets activity.
08:03:58 <qrpnxz> mhd_: Because output operations buffer in a hypothetical toilet until it fills or you flush it.
08:04:11 <mauke> mhd_: it seems like you ignored most of what I said
08:05:16 <ddellacosta> the toilet metaphor, slightly less lovely
08:05:27 <ddellacosta> but perhaps more apt
08:05:57 <ddellacosta> and on that note, I am going to bed.  night lovely #haskell folks
08:06:42 <qrpnxz> ddellacosta: Good night.
08:19:06 <deech> Is there any way to get GHC to not expand out a type synonym in error messages?
08:20:36 <thoughtpolice> deech: no, but it's been a long-requested feature IIRC. there's a bug relating to this topic somewhere in Trac but I don't know which one it is.
08:20:53 <deech> thoughtpolice: Thanks!
08:21:20 <thoughtpolice> noodling, perhaps the behavior should be to never expand synonyms unless a specific flag is given or somesuch, which would cause the expanded version to appear in the error
08:21:39 <thoughtpolice> FWIW this may not be hard to implement :)
08:21:50 <deech> thoughtpolice: Actually I'd like a feature to match an error message and print a custom one. Probably more general and easier to implement that not expanding type synonyms.
08:22:15 <deech> s/that/than/
08:22:20 <thoughtpolice> yes, that one would be a lot trickier to think about, but much more general.
08:22:55 <thoughtpolice> not expanding synonyms is a specific-enough and oft-requested case it's probably worth adding on its own, however
08:23:33 <deech> thoughtpolice: Good to know more people are bugging the team about it. :)
08:39:58 <sbrg> Hey guys. I'm having a really hard time getting my implementation of minimax with alpha/beta pruning to work as it should. I believe the issue may be a combination of unintended strictness combined with a small error in my implementation of the algorithm(which is linked in the beginning of my link as an imgur link). The explanation is somewhat lengthy and there is a bit of code, but much of it is included so
08:40:00 <sbrg> you guys can see the whole(or most of) the picture. Here is the link: https://gist.github.com/44a807cf9d9de1b868b3 -- I would really appreciate if someone could take a look.
08:47:45 <sveit> is hashtables considered the "best" hash table implementation currently available?
08:49:49 <sveit> in particular, is it faster than a simple IntMap?
08:50:01 <mmmm> sbrg: Stackoverflow is usually a good bet for that sort of thing if no one is around here
08:50:35 <sbrg> mmmm: yeah, I had considered it
08:50:53 <agibiansky> sveit: Yes, I think you are right
08:51:19 <agibiansky> Hashtables is the fastest in my experience – there are also Judy arrays though
08:51:27 <agibiansky> I had the following question a month or two ago: http://stackoverflow.com/questions/26765232/haskell-hashtable-performance
08:51:55 <Cale> I've never really messed with hashing that much, but one thing which is easier to try is the stuff in the unordered-containers package.
08:52:23 <agibiansky> Unordered containers is simpler but not as performant due to its persistent nature
08:52:25 <Cale> If you have code which uses Map/Set, that package has modules which are nearly drop-in replacements
08:54:24 <Cale> Well, it's always questionable. Sometimes you can get better time complexity out of recursive algorithms that need to backtrack. I'd also go quite a long way to avoid having to use IO or ST for primitive operations on my data.
08:54:25 <sveit> Data.Judy seems to be exactly what I was looking for, thanks@
08:55:13 <dave971> is there a separate channel for cabal?
08:55:22 <Cale> I've also gotten worse results from unordered-containers than from ordinary containers in certain cases.
08:55:50 <c_wraith> Data.Judy only really works for word-sized keys.  For anything else...  It's not going to be faster than anything else.
08:55:57 <c_wraith> err, word-sized values.  not just keys
08:56:05 <tolt> After building a project the first time I'm getting the error "cabal: Prelude.chr: bad argument: 1848275" on cabal version 1.22
08:56:06 <agibiansky> Yeah, it's not a replacement for generic hashmaps
08:56:14 <tolt> (inside a sandbox)
08:56:58 <dcoutts_> dave971: for cabal/hackage development we use #hackage, for support Qs, this channel is usually best.
08:57:08 <dcoutts_> tolt: try a cabal clean first
08:57:34 <tolt> dcoutts_: That worked but should I have to clean before each build?
08:57:45 <sveit> c_wraith: also, I just realized it forces you into the IO monad fairly strongly
08:58:05 <tolt> dcoutts_: it could also be the fact that it's a ghcjs project.
08:58:06 <SrPx> I have a recursive function on trees that work like that: "foo (Node _ children) = map foo children". The obvious problem is that this will not typecheck - I am generating lists of lists of lists of lists... how do I make it so my function only returns a list of the deepest elements? Other than calling an (expensive) flatten on each recursion?
08:58:06 <c_wraith> dcoutts_: does cabal have any command to clean all build artifacts in a sandbox, even across add-source'd stuff?
08:58:15 <dave971> dcoutts_: thank you
08:58:21 <dcoutts_> c_wraith: don't think so
08:58:33 <dcoutts_> tolt: no you shouldn't have to do that
08:58:42 <tolt> that's not good then :(
08:59:11 <c_wraith> dcoutts_: it'd really be nice in the cases when something gets corrupted and I'm not sure where.
08:59:20 <dcoutts_> aye
09:00:07 * hackagebot cayley-client 0.1.0.1 - An Haskell client for Cayley graph database  http://hackage.haskell.org/package/cayley-client-0.1.0.1 (MichelBoucey)
09:01:10 <ChristianS> agibiansky: my experience is that Data.Map is fast enough in real-life code, even though it doesn't look that great in micro-benchmarks
09:01:27 <ChristianS> agibiansky: and Data.Map is pure, that's the nice thing about
09:07:28 <Cale> Yeah, in my experience a lot of people underestimate the cost of computing hashes
09:09:58 <juanpablo_> Is it possible to modify the value in an ImplicitParams for subsequent calls?
09:10:11 <juanpablo_> jvilla: ^^^^^
09:12:28 <c_wraith> juanpablo_: I think you should be able to shadow the implicit param.
09:14:30 <c_wraith> > let f = ?foo in (let ?foo = "bar" in (f, let ?foo = "q" in f))
09:14:32 <lambdabot>  ("bar","q")
09:14:50 <c_wraith> juanpablo_: yep, you can shadow the binding of the implicit param
09:28:06 <quam6246>  /msg NickServ VERIFY REGISTER quam6246 tskkhjlekadw
09:31:19 <clrnd> ups
09:31:36 <callumacrae> might want to change that password
09:31:59 <agibiansky> ChristianS: I agree with you, but there are some cases where it matters
09:32:07 <agibiansky> Ultimately my microbenchmark was motivated by real code
09:32:27 <agibiansky> Some NLP stuff that stored millions of stuff in nested hashmaps
09:34:00 <agibiansky> So yes, for most real-world code Data.Map or Data.HashMap are enough, but there are cases where you need high performance mutable hash maps, which for the time being, Haskell has in the form of hashtables, which is fast but not quite as fast for the general usecase as Python's dicts (which are of course hugely optimized for python, etc)
09:34:55 <hiptobecubic> python's dict object is really pretty incredible.
09:35:08 * hackagebot disk-free-space 0.1.0.1 - Retrieve information about disk space usage  http://hackage.haskell.org/package/disk-free-space-0.1.0.1 (MariosTitas)
09:35:26 <agibiansky> Yeah – I do not think I appreciated the optimization that went into it until I spent time exploring Haskell alternatives
09:35:28 <johnw> people also underestimate how quick a really small associated list can be
09:44:02 <lpaste> gregnwosu pasted “can you help” at http://lpaste.net/117834
09:46:26 <hodapp> I wonder what influences the decision of whether one implements a dependently-type language in Haskell, or just tries to put up with Hasochism...
09:50:17 <geekosaur> gregnwosu, not without knowing about your system. you presumably need a system devel package for this libblink1
09:50:30 <geekosaur> it is not a haskell library, cabal can do nothing about it
09:50:53 <nedo007> Hasochism? :))
09:51:15 <hodapp> nedo007: aye, it's a paper about the current state of dependent typing in Haskell
09:53:02 <nedo007> hodapp: The Pleasure and Pain of Dependently Typed Haskell Programming, correct?
09:53:25 <gregnwosu> geekosaur:  yes i have the binaries ive compiled the binaries and have a libblink1.so file in /var/host/media/removable/sd64/lib/blink1/commandline
09:53:47 <gregnwosu> i dont see why its complaining of missing binaries :\
09:53:54 <hodapp> nedo007: yes!
09:53:55 <geekosaur> then you need to point cabal at that, or install it in a directory that ld knows how to search automatically
09:54:06 <nedo007> thank you
09:54:17 <geekosaur> oddly enough the error message even tells you how to do that
09:54:27 <nedo007> added to the "to read" about haskell
09:54:33 <nedo007> what is haskell usually used for?
09:55:12 <gregnwosu> geekosaur: i will try adding the suggestions to the command line, although i have those directives in the cabal file itself
09:55:38 <ChristianS> nedo007: whatever you like
09:55:51 <geekosaur> I amnot sure it's v alid in a cabal file, because a cabal file wants to be general
09:56:22 <geekosaur> certainly there is no /var/host/media/... path on my system, so you have a cabal file that only works on your system
09:56:37 <hodapp> fun fact: Haskell is sometimes used for programming
09:57:25 <nedo007> hodapp and in the rest of the time it's used to solve math problems? :))
09:59:00 <gregnwosu> geekosaur: thanks i will keep hacking
10:02:29 <Welkin> how does getStdGen work?
10:02:35 <Welkin> where does it get the seed value from?
10:03:03 <Welkin> I noticed that getStdGen always gives me the same sequence of generators
10:03:05 <Beardful> When i'm building ghc for crosscompiling from linux to win32, what is the target name for windows ?
10:03:07 <johnw> maybe the current time?
10:03:08 <Welkin> so the seed must always be the same
10:03:10 <glguy> Welkin: it uses a global ioref and you generally shouldn't use that
10:03:19 <Welkin> I changed it to newStdGen
10:03:25 <Welkin> and now it produces a difference sequences each time
10:03:30 <glguy> Right, that's the one you should use
10:03:32 <Welkin> different*
10:03:54 <glguy> getStdGen and setStdGen are for modifying the global
10:04:03 <Welkin> okay
10:04:11 <Welkin> where is this global ioref stored?
10:04:16 <glguy> While newStdGen actually gets, splits, and sets
10:05:20 <Welkin> what do you mean by split?
10:05:45 <glguy> Turns the gen into two new ones
10:05:48 <sinelaw> Welkin, I think he means you can make two gens from one
10:05:50 <Welkin> I read in the description that it forks the generator, leaving the previous generator available
10:05:54 <glguy> Gives you one and puts the other back
10:06:13 <Welkin> does that have any resource implications?
10:06:27 <Welkin> or does it not matter, as long as I only call newStdGen once (at the beginning of the program)?
10:06:31 <glguy> No, it's just a seed value
10:07:30 <ChristianS> Welkin: you always have the use the newest generator, or you'll get repeated values
10:11:43 <Welkin> ChristianS: yes, I update the generator each time I run it
10:12:08 <Welkin> from randomR
10:17:35 <Beardful> While building ghc, it says cannot find ar in your path. How do i fix that. Might it be something like '--with-ar='?
10:17:55 <ReinH> Beardful: what does `which ar` say?
10:18:15 <ReinH> Beardful: also what OS?
10:19:44 <Beardful> ReinH: /usr/bin/ar, Im on Archlinux targetting windows.
10:20:33 <geekosaur> sounds like it's looking for a cross-ar then
10:20:50 <Beardful> geekosaur: Probably mingw32-ar
10:21:43 <Beardful> Because it said it doesn't have mingw32-ar, but before it also said i don't have nm and clang, but i added --with-nm/clang='' and it worked.
10:22:23 <dfeuer> :t (sequence.fmap (:[]))
10:22:24 <lambdabot> [a] -> [[a]]
10:22:34 <dfeuer> :t (traverse (:[]))
10:22:35 <lambdabot> Traversable t => t b -> [t b]
10:22:40 <Beardful> Nevermind, i fixed it.
10:24:13 <utdemir> Hey. I have an acid-state database containing many big records. Now I have to do a search & replace on one small field. Can anyone show me a way to not updating whole record to update that small field?
10:24:17 <ReinH> dfeuer: traverse = sequenceA . fmap, right?
10:24:49 <dfeuer> ReinH, uh ... traverse f = sequenceA . fmap f, I think.
10:24:58 <sbrg> There is something in the definition of either foldUntil or minimaxAlphaBeta here that is causing it to evaluate too far, I believe. This is, as the name suggests, minimax with alpha beta pruning, and I want to find the path and value to the first child with the maximal value that is equal to or larger than the beta value(in the case of a maximizing player) or equal to or smaller than the alpha value(in the
10:25:00 <sbrg> case of the minimizing player). Can any of you see why there might be 'too much evaluation' going on here?
10:25:40 <sbrg> The problem is showing itself in that some testcases I have provided that are static game trees contain nodes that are simply 'error "shouldn't be inspected due to pruning"' are being evaluated
10:26:03 <sbrg> https://gist.github.com/2b96461a1d8f740fc973
10:26:06 <sbrg> sorry
10:26:08 <sbrg> link
10:28:50 <SrPx> Hey guys, I posted this SO question about how to implement an efficient path enumerating algorithm for trees. I've offered the naive Haskell implementation as well as the correct/efficient JS implementation. Does anyone know how to translate the JS to Haskell properly? Do I need ST or only the List monad?
10:28:53 <SrPx> Here it is: http://stackoverflow.com/questions/27784506/what-is-the-proper-efficient-way-to-write-this-function/27784765#27784765
10:34:43 <ReinH> SrPx: generally speaking, functional algorithms on immutable structures can come within a log n factor of their mutable, imperative versions.
10:36:03 <ReinH> SrPx: so as a comment to dfeuer's answer mentions, a structure that provides logarithmic or amortized constant concatenation (like a DList) would be a good first step
10:36:12 <johnw> ReinH: that makes it sound like they are always slower
10:37:01 <dfeuer> ReinH, I am not seeing the problem with my answer... Data.Sequence.Seq has O(1) snoc and O(1) viewl.
10:37:18 <ReinH> dfeuer: I am not seeing a problem with your answer either
10:38:46 <ReinH> dfeuer: Well, I think the issue is with the concats of the form concat xs (concat ys xz)
10:38:57 <SrPx> ReinH: are you really sure? I'm not convinced this is the case. If you just make GHC do the recursion correctly and cons your final results to a list on ST, I don't see where the log(n) factor would come from.
10:39:13 <ReinH> SrPx: ST allows mutable structures.
10:39:15 <dfeuer> ReinH, I don't think there is an issue, because there's no concat . concat anywhere.
10:39:47 <ReinH> johnw: Hmm, maybe I worded it poorly. I was trying to express an upper bound.
10:40:07 <SrPx> Essentially, the algorithm I posted is creating a proper answer for every call of the recursion. But we don't need those answers, we can just keep recursing and only actually build an answer in the last step...
10:40:50 <SrPx> I'm not sure I'm making sense
10:41:42 <dfeuer> SrPx, that's what my answer does, essentially. You can replace Seq with difference lists, which you might be able to twist onto the stack somehow, but I'm not sure why you'd want to.
10:44:02 <SrPx> dfeuer: I *think* I understand your answer, but that is what *Seq* itself does, essentially, isn't it? It allows O(1) concatenation (by that strategy, maybe?) thus it can be used here...
10:44:31 <dfeuer> SrPx, the fundamental problem is that *nothing* producing a list of list, where the inner lists represent paths from the root to leaves, can ever be better than your original solution.
10:44:35 <SrPx> the reason I asked for a list-only structure is that I was curious in how to actually implement it :) mostly for learning purposes - using Seq is probably the way to go here
10:45:05 <dfeuer> SrPx, whether you want Seq, or DList, or something else, depends tremendously on how you plan to use the paths afterwards.
10:45:35 <dfeuer> SrPx, Seq does not allow O(1) concatenation, but it allows O(1) cons and snoc.
10:45:53 <dfeuer> As I said, all you need for this is O(1) snoc. There are a *lot* of structures that offer that.
10:46:03 <SrPx> The way I'm going to use it is, I'll convert it to a list of vectors and render it using opengl. But why does this matter?
10:46:12 <dfeuer> ACtually, DList is a silly way, because if you want that, just use your original solution.
10:47:16 <SrPx> indeed
10:47:20 <dfeuer> SrPx, it matters because you want a data structure that you can use efficiently in the manner in which you plan to use it! To make vectors, you might actually want to use a sort of size-tagged difference list in place of the Seq.
10:47:39 <dfeuer> So when you get to the leaf, you know how deep you are and you can allocate the vector accordingly.
10:48:25 <mmmm> what you have something like the following.. newtype Useless = forall i . Useless { useless :: Proxy i } I assume you permanently lose information about what i was?
10:49:10 <dfeuer> mmmm, that does sound fairly useless.
10:49:34 <SrPx> hmmmm...
10:52:57 <ReinH> dfeuer: I guess you could use an Okasaki heap as well...
10:54:26 <ReinH> Hmm, you can actually parameterize over a choice of structure and get different traversals if you want
10:54:30 <eacameron> It seems that mysql package has some pretty serious concurrency problems...Is this true? It seems like a pretty big gap in the Haskell ecosystem: https://github.com/bos/mysql/issues/11
10:57:20 <mmmm> do I need to do anything to get typeable instances for my own datatypes?
10:57:37 <geekosaur> deriving (Typeable)
10:57:58 <shachaf> DeriveDataTypeable and deriving (Typeable), or AutoDeriveTypeable to do it automatically
10:58:04 <dfeuer> SrPx, ReinH the way to do it for this purpose, I think, is the super-simple method I mentioned in my answer: build *backwards lists*.
10:58:18 <dfeuer> So instead of using (s |> a), use (a:s)
10:58:37 <dfeuer> Then you get a list of backwards lists, and you can build the vectors backwards.
10:59:02 <mmmm> ok thanks and what about this error?  "No instance for (Typeable '[])"
10:59:44 <shachaf> It sounds like it doesn't have a Typeable instance.
10:59:46 <geekosaur> uh. '[]? type level list?
11:00:02 <mmmm> yes, type level list
11:00:04 <ReinH> dfeuer: seems reasonable
11:00:12 <shachaf> Maybe you're supposed to use singletons instead? I don't know.
11:00:27 <shachaf> It seems like it would be reasonable for it to have a Typeable instance.
11:01:03 <ReinH> I assume AutoDeriveTypeable fails silently for data types it can't derive for? That seems like the only reasonable behavior, but it also seems problematic if you are trying to troubleshoot an issue with deriving Typeable...
11:01:28 <ReinH> Er, "for data types for which it can't derive Typeable?" How does English work?
11:02:17 <SrPx> dfeuer: I see, but still using "seq" right
11:02:26 <dfeuer> SrPx, oh, and keep track of the sizes as you go, so (a:s) (n+1)
11:02:40 <shachaf> AutoDeriveTypeable is only for types you declare, of course.
11:03:21 <dfeuer> SrPx, you probably won't need that for lists.
11:04:25 <mmmm> '[] is just from using DataKinds
11:04:44 <SrPx> dfeuer: woops, I mean... no, I don't understand. You still have the concatMap there... so it is slow if you use lists, no?
11:04:55 <ReinH> shachaf: How do you declare them? I can't find any docs on AutoDeriveTypeable.
11:05:12 <ReinH> https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/data-type-extensions.html doesn't mention the extension
11:05:13 <shachaf> Maybe I mean define.
11:05:24 <shachaf> You define types with data or newtype.
11:05:58 <ReinH> shachaf: Right, that makes sense, but I'm not sure how it relates to my question.
11:06:54 <shachaf> ?
11:08:07 <dfeuer> SrPx, why are you afraid of concatMap?
11:08:16 <ReinH> I assumed that the extension works on types defined in the file(s) using the extension.
11:08:36 <ReinH> shachaf: Oh, perhaps you weren't talking to me at all. Never mind then.
11:08:53 <shachaf> I'm confused.
11:09:08 <shachaf> At any rate, you can "deriving instance Typeable '[]"
11:09:18 <SrPx> dfeuer: well if I am analyzing it properly, it is O(N^2) for lists and O(N) for Seq
11:09:34 <ReinH> shachaf: I'm confused as well. Best forget it. :)
11:09:52 <dfeuer> SrPx, let me look again and make sure i'm not being stupid.
11:09:56 <shachaf> Though it means that typeRep (Proxy :: Proxy []) and typeRep (Proxy :: Proxy '[]) look the same
11:09:56 <SrPx> for lists, looks like it has to traverse every list inside the outer list... but for Seq it can just loop once and append them as it go
11:10:51 <mmmm> shachaf: I just tried that (deriving instance Typeable '[]) which caused the first error to go away
11:11:28 <mmmm> then ghc complains about No instance for (Typeable (':))
11:11:41 <mmmm> adding the deriving instance Typeable (':) causes a parse error..
11:13:51 <dfeuer> Oh, I see what delnan is saying now. SrPx, it seems I have made a mistake.
11:15:55 <SrPx> ah :(
11:18:34 <dfeuer> This is very confusing.
11:22:12 <S11001001> Does transformers 0.4.* work on ghc 7.6?
11:39:22 <lisbeth> how does the lamdabot decide when to stop computing a function
11:39:35 <lisbeth> for example if I ask it to do [1..]
11:39:43 <lisbeth> does it just take a certain number?
11:40:13 <yitz> lisbeth: it goes for a while, and then stops
11:40:14 <srhb> lisbeth: I think it runs things with a timeout AND limits the output
11:40:30 <yitz> lisbeth: it goes for longer when you pm it than when you use it in a channel.
11:40:55 <lisbeth> I see
11:40:57 <lisbeth> is it open source?
11:41:12 <yitz> > fix ("lisbeth " ++)
11:41:14 <lambdabot>  "lisbeth lisbeth lisbeth lisbeth lisbeth lisbeth lisbeth lisbeth lisbeth lis...
11:42:43 <lisbeth> ooh fix sounds pretty cool
11:42:58 <EvanR-work> :t fix
11:43:02 <lambdabot> (a -> a) -> a
11:43:06 <yitz> @where lambdabot
11:43:06 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
11:43:11 <yitz> @hackage lambdabot
11:43:11 <lambdabot> http://hackage.haskell.org/package/lambdabot
11:43:19 <lisbeth> that's cool
11:43:34 <lisbeth> I think it would be pretty rad to use lamdabot in any irc, even if it is unrelated to haskell
11:43:38 <sbrg> > let myCode = ("broken" ++) in fix myCode
11:43:39 <lambdabot>  "brokenbrokenbrokenbrokenbrokenbrokenbrokenbrokenbrokenbrokenbrokenbrokenbro...
11:44:19 <lisbeth> heheh
11:44:22 <EvanR-work> cofix
11:44:23 <lisbeth> you forgot the space
11:44:43 <lisbeth> also ++ is expensive from what I try to understand
11:44:51 <lisbeth> so I try to use x : xs if I can
11:45:02 <EvanR-work> in this case its not expensive
11:45:19 <EvanR-work> because laziness
11:45:30 <yitz> > let myCode = const "It's fixed!" in fix myCode
11:45:31 <lambdabot>  "It's fixed!"
11:47:47 <yitz> @google lambdabot
11:47:47 <lambdabot> https://www.haskell.org/haskellwiki/Lambdabot
11:48:02 <sshine> I'm playing around with Scotty. can anyone give an example of when 'scottyT portNo f g app' is applied for f and g that are not identical? I haven't seen a tutorial where these aren't.
11:48:14 <lisbeth> > take 5 $ fix $ "ha" ++
11:48:15 <lambdabot>  <hint>:1:23:
11:48:15 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:48:18 <lisbeth> NOOOO
11:48:35 <lisbeth> take 5 ( fix ("ha" ++))
11:48:41 <lisbeth> > take 5 ( fix ("ha" ++))
11:48:42 <lambdabot>  "hahah"
11:48:56 <lisbeth> This is why I can't have nice things
11:48:59 <Hijiri> what's the name of the property where if you compose something with itself it's equivalent to the identity function?
11:49:20 <zipper> From Hacker News: Introduction to Category Theory  http://www.cs.nott.ac.uk/~gmh/cat.html
11:49:31 <lisbeth> > fix ("ha" ++)
11:49:32 <sshine> Hijiri, cyclic with order 2?
11:49:32 <lambdabot>  "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah...
11:49:37 <lisbeth> there we go
11:49:48 <Hijiri> ok, thanks
11:51:14 <sshine> Hijiri, or: it is its own inverse. those are equivalent.
11:51:42 <Welkin> like a moduis strip?
11:51:45 <Welkin> movuis*
11:51:48 <Welkin> mobius*
11:52:21 <sshine> Welkin, not really. a mobius strip is a topological entity.
11:55:14 * hackagebot aws-lambda 0.1.0.0 - Haskell bindings for AWS Lambda  http://hackage.haskell.org/package/aws-lambda-0.1.0.0 (JonSterling)
11:55:24 <hardkey> Hi Everyone.
11:55:29 <dfeuer> @tell SrPx I think I fixed it.
11:55:30 <lambdabot> Consider it noted.
11:58:28 <hardkey> Excuse me if my question is stupid, but is there a way to load an image and use it as a sprite in HOpenGL?
12:03:03 <Hijiri> how accepted is the idiom of using unsafePerformIO to make "constant" assests that you don't need to explicitly load in
12:03:06 <Hijiri> for example
12:03:23 <Hijiri> "bob_image = unsafePerformIO $ loadImage "bob.png""
12:03:55 <Hijiri> and then the first time you use bob_image it gets replaced by the bytestring representation of the image, or however the library being used works
12:03:58 <Hijiri> I've seen it used a few times
12:04:06 <Hijiri> maybe it's not a real idiom
12:04:11 <dfeuer> hardkey, I can't even seem to figure out where HOpenGL can be found.
12:04:24 <Hijiri> or just used in some proof of concept thing that isn't supposed to be a full program
12:04:36 <dfeuer> Hijiri, well, it's kind of disgusting.
12:04:44 <hardkey> Hum, it is with my haskell package on ubuntu.
12:04:46 <Hijiri> that's what I thought when I first saw it
12:04:54 <srhb> dfeuer: It's just opengl on hackage, I believe
12:04:59 <Hijiri> but there wasn't any clear explanation in the code why it was being used that way
12:05:09 <srhb> The name is annoying.
12:05:18 <srhb> Well, the fact that the package is differently named from the project is.
12:05:38 <ksira> If I'm in the ST Monad, how to map a readSTRef over a tuple of STRefs?
12:05:54 <hardkey> Oh, I see. So OpenGL on Hackage.
12:06:18 <ksira> mapM readSTRef (ref1, ref2) has type ST s (STRef s Double, Double)
12:06:37 <ksira> I want ST s (Double, Double)
12:08:30 <rbocquet> bitraverse would work
12:08:36 <dfeuer> hardkey, I'm not seeing anything that obviously looks like it's for file stuff....
12:08:45 <rbocquet> from Data.Bitraversable
12:09:27 <ksira> Thanks, was looking in bifunctors for the solution. =)
12:09:32 <Welkin> there is a new set of opengl bindings called gl
12:09:48 <Welkin> hardkey: ^
12:09:57 <agibiansky> Welkin: Is it better than OpenGL somehow?
12:10:03 <Welkin> yes
12:10:11 <srhb> hardkey: Look at imageTexture, I think
12:10:22 <hardkey> Thanks Welkin
12:11:45 <hardkey> and srhb
12:13:01 <srhb> hardkey: Also gl is very lowlevel, you might want to look at Caramia if you really want to use that.
12:13:09 <srhb> hardkey: Not sure if it's production ready though
12:14:03 <hardkey> Ok, I'll look at it. Basically, I want to handle simple 2D graphics for a shmup (with Yampa too)
12:15:21 <srhb> Has any explanation been given for why haskell.org is so slow?
12:15:38 <srhb> Or more to the point: Is it being fixed?
12:19:04 <dfeuer> srhb, there's an explanation.
12:19:10 <gcganley> has anyone here interop'd with C# through the C ffi?
12:19:20 <srhb> dfeuer: Yes?
12:20:01 <srhb> dfeuer: Link? :)
12:20:04 <dfeuer> srhb, people are working on it, but I haven't seen any expected fix time mentioned. The problem is that when hard drives crashed weeks ago, there was a rather rushed recovery, with things moved all over.
12:20:04 <gcganley> specifically functions taking in and returning strings
12:20:16 * hackagebot adblock2privoxy 1.3.0 - Convert adblock config files to privoxy format  http://hackage.haskell.org/package/adblock2privoxy-1.3.0 (zubr)
12:20:18 * hackagebot fay-jquery 0.6.0.3 - jQuery bindings for Fay.  http://hackage.haskell.org/package/fay-jquery-0.6.0.3 (AdamBergmark)
12:20:20 <srhb> dfeuer: OK. Thanks. :)
12:20:24 <dfeuer> One thing that happened was that the database and the web server ended up far away from each other (different data centers)
12:20:59 <dfeuer> And fixing that is appparently hard because the web server and mail server are tied together, and moving mail servers is apparently dicey with spam filter stuff.
12:21:21 <danilo2> Hello! Do existential datatypes introduce always some performance overhead or are there situations where they are just cut off ? :)
12:21:41 <srhb> dfeuer: Definitely. Thanks. :)
12:22:57 <dfeuer> danilo2, if they have class constraints, then there's overhead. Otherwise, there may not be.
12:22:57 <dfeuer> I believe.
12:23:36 <S11001001> danilo2: I would imagine the only overhead is where you can't specialize stuff, and of course the dictionaries from constraints dfeuer mentions.  It's not like you need a Sigma at runtime to represent existentials in Haskell :)
12:23:50 <gcganley> i back what dfeuer says. thats my understanding
12:24:12 <dfeuer> S11001001, specialization doesn't really seem to help, unfortunately, I don't think.
12:24:54 <S11001001> dfeuer: hmm, I've heard otherwise from dolio
12:25:00 <danilo2> dfeuer: I'm talking about such situation where we've got class constraints. I'm just asking if when I'm using them in my logging library to handle different handlers - is it possible they woudl be just as fast as without them if haskell sees that I'm putting in the arrays some data which type is instance of some class. If there would be any overhead I would not use it because logging is performance critical in some way
12:25:08 <S11001001> he gave a good presentation in ny showing a good speedup from specialization
12:25:48 <S11001001> danilo2: so if you have an array of Blah where Blah = forall a. C a => Blah a, each Blah carries a dictionary
12:25:58 <dfeuer> danilo2, I think generally specialization does not help, because of https://ghc.haskell.org/trac/ghc/ticket/9701
12:26:36 <S11001001> danilo2: but if you have an (Array (Blah a)) then the dictionary for a is assembled later at point of use
12:26:40 <dfeuer> danilo2, if you want to find a way to fix that, you are very welcome to.
12:26:42 <S11001001> danilo2: the C dictionary that is
12:27:24 <gcganley> how often do people use the C ffi in real code. there is some info on importing but not much on exporting
12:27:45 <zipper> What does this sign mean? <==>
12:27:59 <danilo2> dfeuer, S11001001 : Ok thank you. dfeuer the bug you mentioned is indeed very interesting
12:28:05 <zipper> I came across it in a category papaer by Graham Hutton
12:28:13 <zipper> Used together with sets
12:28:14 <gcganley> zipper: equivilant
12:28:38 <gcganley> zipper: oh... idk if thats a defined operator then
12:28:51 <gcganley> havent read the paper
12:28:56 <dfeuer> zipper, yeah, the only one Hoogle finds is http://haddocks.fpcomplete.com/fp/7.8/20141022-182/webdriver-snoy/Test-WebDriver-Commands.html#v:-60--61--61--62- and that doesn't look relevant.
12:29:38 <gcganley> isnit defined in the paper?
12:29:42 <jrc12> How do I convert pre-escaped text to html using the Text.Blaze library?
12:30:14 <jrc12> In earlier versions the funcion - preEscapedString :: String -> Html seemed to exist, but no longer
12:30:16 * hackagebot adblock2privoxy 1.3.1 - Convert adblock config files to privoxy format  http://hackage.haskell.org/package/adblock2privoxy-1.3.1 (zubr)
12:30:18 <cschneid> I'm giving a talk at the local meetup tomorrow about StG - doing prep work.  Is there much practical use of it, or is it mostly interesting as an implementation detail of how GHC works?
12:30:42 <zipper> gcganley: It's a math thing not a haskell thing
12:30:46 <zipper> dfeuer: ^
12:30:56 <dfeuer> Ah.
12:31:01 <zipper> dcoutts: I'll assume it means equivilant
12:31:32 <gcganley> then im shooting for my original thought, equivilant
12:31:52 <zipper> Like the one used under axioms of extensionality in https://en.wikibooks.org/wiki/Set_Theory/Axioms
12:31:57 <zipper> gcganley: ^
12:32:01 * dcoutts_ assumes zipper is talking to dfeuer and wanders off
12:32:09 <DrSkyLizard> I'm trying to install a code sample from the Haskell Data Analysis Cookbook , however after I run make on sample it gives me an unsatisfied dependency hell error: https://paste.kde.org/py07nekbv/41go5v Any ideas why?
12:32:26 <zipper> dcoutts_: lol yeah typo
12:32:45 <dcoutts_> zipper: np, I do that all the time :-)
12:33:30 <srhb> DrSkyLizard: Because it's requesting base < 4.7 and you have base >= 4.7?
12:33:32 <dcoutts_> DrSkyLizard: that's quite a simple one. Code0712 claims to require exactly base-4.6.*
12:33:38 <zipper> gcganley: So Uh what do I need to read to know about these things? To be ready for this http://www.cs.nott.ac.uk/~gmh/cat.html
12:33:43 <dcoutts_> ie a single ghc version
12:33:50 <zipper> gcganley: Like prerequisites
12:34:23 <Hijiri> @define instance (Read a) => instance IsString a where fromString = read
12:34:23 <lambdabot>  Parse failed: Parse error: instance
12:34:30 <dcoutts_> DrSkyLizard: worth trying relaxing the constraint on base
12:34:31 <Hijiri> @define instance (Read a) => IsString a where fromString = read
12:34:32 <lambdabot>  .L.hs:153:22:
12:34:32 <lambdabot>      Not in scope: type constructor or class ‘IsString’
12:34:32 <lambdabot>      Perhaps you meant ‘String’ (imported from Prelude)
12:34:54 <gcganley> one moment while i look at that zipper
12:35:16 * hackagebot aws-kinesis-client 0.1.0.0 - A producer & consumer client library for AWS Kinesis  http://hackage.haskell.org/package/aws-kinesis-client-0.1.0.0 (JonSterling)
12:35:18 * hackagebot happstack-server 7.4.0 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.4.0 (JeremyShaw)
12:35:20 * hackagebot happstack-server-tls 7.1.5 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-7.1.5 (JeremyShaw)
12:35:28 <DrSkyLizard> dcoutts_: srhb indeed, that's it; is there a way to verify the version of the base package?
12:35:43 <srhb> DrSkyLizard: It already did.
12:35:44 <dcoutts_> verify in what sense?
12:36:09 <gcganley> zipper: nah youre fine
12:36:09 <DrSkyLizard> I mean to check what is my version of that package
12:36:11 <DrSkyLizard> is it base-4.7.0.2 ?
12:36:16 <srhb> DrSkyLizard: rejecting: base-4.7.0.1/installed-1a5
12:36:25 <DrSkyLizard> i.e. the first item cabal rejected
12:37:05 <srhb> DrSkyLizard: Easiest fix is probably to bump the dependencies in the cabal file and see if it flies.
12:37:32 <DrSkyLizard> srhb: yes, it works, I've modified the upper bound constraint to a greater value
12:37:54 <clrnd> just realized pandoc is haskell, yay!
12:38:11 <dcoutts_> DrSkyLizard: for future reference, ghc-pkg list ${the-pkg-name}  will tell you what version(s) you've already got installed.
12:38:39 <qrpnxz> clrnd: Cool!
12:39:26 <DrSkyLizard> dcoutts_: srhb thanks
12:40:16 * hackagebot happstack-hsp 7.3.4 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.3.4 (JeremyShaw)
12:42:16 <nokwe> clrnd: when did you first hear about pandoc?
12:42:42 <nokwe> I don't think I ever heard about these tools written in haskell before hearing about haskell, so I think this is good news
12:42:51 <clrnd> nokwe, mmm not sure, I heard about it several times but never needed it so I didn't installed it
12:43:28 <clrnd> but today I needed to render some markdown and a workmate passed it on
12:45:00 <sbrg> So I'm trying to explain typeclasses to someone who is familiar with interfaces from java and C# and similar. I believe I've read somewhere that the comparison might fall short in some places, though I don't recall how exactly, but is there anything greviously wrong with comparing them in an attempt to help someone gain intuition?
12:45:17 * hackagebot tzdata 0.1.20141110.0 - Time zone database (as files and as a module)  http://hackage.haskell.org/package/tzdata-0.1.20141110.0 (MihalyBarasz)
12:46:04 <platz> sbrg: I think the interface analogy works pretty well until you have multiparameter typeclasses
12:46:12 <sbrg> platz: ah, yes
12:46:17 <platz> then they sort of look like a contract between two classes
12:46:19 <sbrg> the person in question doesn't even know about those
12:47:55 <platz> sbrg: and really it's just sugar for passing a dictionary around, which helps understand typeclasses a bit i think ; I'm not sure interfaces have such a nice implementation so there may be mismatches depending on the language
12:48:21 <LoneElf_> What's the most high-profile project developed in haskell? Github is not yeilding results that include anything I have ever heard of?
12:48:41 <platz> i'm not sure it might have implicications for type inference - such as dispatching on the return type
12:48:57 <platz> typically interfaces subvert that
12:49:16 <qrpnxz> LoneElf_: "yesod", maybe?
12:49:41 <johnw> is that really high profile?
12:49:47 <johnw> I think git-annex probably has way more users
12:49:57 <geekosaur> xmonad, pandoc, git-annex
12:50:17 * hackagebot happstack-lite 7.3.6 - Happstack minus the useless stuff  http://hackage.haskell.org/package/happstack-lite-7.3.6 (JeremyShaw)
12:50:19 * hackagebot tz 0.0.0.9 - Efficient time zone handling  http://hackage.haskell.org/package/tz-0.0.0.9 (MihalyBarasz)
12:50:21 * hackagebot web-routes 0.27.8 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.27.8 (JeremyShaw)
12:50:32 <LoneElf_> Thanks guys :D
12:50:56 <sm> pandoc by far I would guess
12:51:02 <johnw> and hledger
12:51:10 <geekosaur> probably
12:51:13 <qrpnxz> johnw: Woah; that git-annex thing looks pretty cool!
12:51:20 <johnw> I use git-annex a lot
12:51:21 <kadoban> GHC is probably the most high profile :)
12:51:44 <qrpnxz> kadoban: I was going to suggest that but I don't think it really counts.
12:52:02 <Welkin> yesod and hakyll are pretty popular
12:52:11 <ReinH> darcs?
12:52:22 <qrpnxz> ReinH: That too.
12:52:24 <ReinH> Facebook? ;)
12:53:20 <sm> I don't think hledger qualifies yet, its mail list activity is close to zero
12:53:22 <Peaker> Does anyone have a nice Haskell-usable way to render nice fonts in OpenGL? http://i.imgur.com/k9ngVO9.png <-- FTGL/graphics-drawingcombinators fonts look terrible when scaled down
12:53:50 <sm> maybe if I find a magic world-domination pill
12:54:11 <Peaker> I want to fix graphics-drawingcombinators and/or FTGL itself to do this right
12:54:23 <Peaker> but I don't know enough about OpenGL/etc to fix it :(
12:54:29 <Peaker> (Why is it aliased like hell?)
12:54:46 <sm> it's the mighty pandoc all the way (outside of a few eggheads who know about GHC)
12:55:17 * hackagebot vector-space 0.9 - Vector & affine spaces, linear maps, and derivatives  http://hackage.haskell.org/package/vector-space-0.9 (ConalElliott)
12:55:18 <sbrg> platz: Very well -- I will use it for comparison, then
12:55:19 * hackagebot web-routes-happstack 0.23.9 - Adds support for using web-routes with Happstack  http://hackage.haskell.org/package/web-routes-happstack-0.23.9 (JeremyShaw)
12:55:24 <johnw> I heard about xmonad long before I ever heard about pandoc
12:55:48 <johnw> yesod I really never encounter, except that the author wrote a book that got published
12:55:56 <qrpnxz> johnw: Because it's a novelty. I think pandoc is used more.
12:56:31 * sm wishes we could invest in FOSS projects like others play the stock market
12:56:50 <Ralith> Peaker: you're not supposed to scale rendered fonts
12:56:57 <Ralith> render them at a smaller size instead
12:57:01 <Peaker> Ralith, hmm.. that's what FTGL guides say, though
12:57:24 <Ralith> font rendering is meant to be pixel-perfect and that is wholly incompatible with post-rendering scaling...
12:57:55 <Ralith> consider the case of bitmap fonts, for example
12:58:06 <Peaker> Ralith, FTGL has setFaceSize(size, resolution), and the recommendation I saw was to use 72,72
12:58:23 <sm> johnw: well, git-annex and everything fpcomplete does use yesod
12:58:24 <Ralith> I don't know what any of that means
12:58:34 <Peaker> Ralith, neither do I :(
12:58:40 <sm> just a niggle, you have encountered it :)
12:58:45 <Peaker> Ralith, but fonts look like: http://i.imgur.com/k9ngVO9.png
12:58:59 <Ralith> is there a reason you're not using freetype and harfbuzz directly?
12:59:16 <Ralith> that sort of shim library tends to be pointless and low quality
13:00:04 <Ralith> and force stupid assumptions on you (like bad scaling)
13:00:08 <conal> BTW, these spatial sampling considerations apply to time also. Hence continuous time in FRP.
13:00:33 <ReinH> conal: hi
13:00:40 <conal> ReinH: hi :)
13:00:55 <ReinH> conal: some interesting discussion came out of the podcast :)
13:02:18 <anhar> hello all?
13:02:24 <sm> I really enjoyed that episode - thanks guys
13:02:40 <qrpnxz> k
13:02:46 <Peaker> Ralith, I'm using graphics-drawingcombinators
13:03:01 <conal> sm: :)
13:03:06 <Peaker> Ralith, Using FreeType directly in OpenGL context sounds hard, but maybe I'm wrong and it's easy? I'd hope so!
13:03:21 <Ralith> Peaker: it's easier than you might expect; the primary difficulty is the lack of documentation
13:03:33 <SuperFoo> Haskell Peeps, a quick question if you kind sirs will?
13:03:38 <Peaker> Ralith, is Freetype wrapped in Haskell?
13:03:48 <Ralith> I don't know
13:03:52 <qrpnxz> SuperFoo: What?
13:04:13 <SuperFoo> I've heard learning Haskell is difficult, how has your experience been?
13:04:35 <Peaker> Ralith, well, FTGL is :-) That's quite a big point in its favor
13:04:50 <johnw> SuperFoo: it depends somewhat on your background
13:04:50 <qrpnxz> SuperFoo: Pretty awesome. I recommend learn you a Haskell for great good. http://learnyouahaskell.com/
13:05:04 <fbiville> hi everyone
13:05:12 <johnw> fbiville: hi
13:05:16 <qrpnxz> johnw: He asked for a personal opinion.
13:05:17 * hackagebot gl 0.6.3 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.6.3 (Polarina)
13:05:17 <Peaker> Ralith, ah, FreeType2 is a Haskell wrapper
13:05:19 * hackagebot fay 0.22.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.22.0.0 (AdamBergmark)
13:05:21 * hackagebot fay-base 0.19.4.2 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.19.4.2 (AdamBergmark)
13:05:27 <Ralith> Peaker: correct font rendering is not easy. You're going to need to go well past the point of "whatever's packaged up conveniently" to get it working properly.
13:05:28 <fbiville> i'm playing around with haskell and project-euler and have a question (problem 12)
13:05:30 <johnw> qrpnxz: it was hard for me
13:05:53 <conal> SuperFoo: some learning resources & recommendations: http://bitemyapp.com/posts/2014-12-31-functional-education.html
13:06:15 <fbiville> i've got an awfully slow solution (I guess is correct) there: head (dropWhile (\m -> length (filter (\n -> m `mod` n == 0) [1..truncate(fromIntegral(m)/2)]++[m]) < 100) [ (foldl1 (+) [1..i]) | i <- [1..] ])
13:06:20 <SuperFoo> I've played with F# and a little lisp
13:06:37 <Ralith> Peaker: I probably need to remind you that for general text rendering you *need* harfbuzz, too; freetype alone is not sufficient outside of specific narrow cases.
13:06:37 <fbiville> to speed it up, i was thinking about memoizing  [ (foldl1 (+) [1..i]) | i <- [1..] ]
13:07:09 <Peaker> Ralith, what's harfbuzz?
13:07:17 <fbiville> I believe this is where I waste most of the computations
13:07:26 <conal> fbiville: looks like scanl
13:07:27 <Peaker> Ralith, Such a common problem, font rendering, would be packaged properly by now?? :P
13:07:42 <Ralith> it's only relatively recently even been *possible* to do properly
13:07:46 <fbiville> however, I thought I understood how to memoize it, but it's not getting le anywhere (in short, still very slow)
13:08:08 <fbiville> conal: thx, ill check the function (disclaimer: quite new to haskell)
13:08:11 <conal> fbiville: scanl computes these cumulative prefix folds without redundant computation.
13:08:29 <Ralith> Peaker: harfbuzz is the component responsible for positioning glyphs into larger units of text
13:08:51 <ReinH> fbiville: or just take advantage of the fact that 1+ 2 + 3 + ... + n = n(n + 1)/2
13:09:07 <fbiville> ReinH: doh! right! :D
13:09:10 <fbiville> conal: thx!
13:09:22 <ReinH> conal is right about scanl generally though
13:09:26 <conal> fbiville: have fun!
13:09:39 <fbiville> ReinH: I dunno how I even didn't think about that :/ anyway, thx!
13:09:39 <conal> and likes folds, scans parallelize nicely for associative operations (e.g., (+))
13:09:47 <fbiville> conal: thx!
13:10:03 <ReinH> conal: wait, they do?
13:10:11 <ReinH> but they depend on previous results for sharing
13:10:13 <conal> ReinH: yeah. it's really lovely!
13:10:18 * hackagebot fay-text 0.3.2.1 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.3.2.1 (AdamBergmark)
13:10:19 <SuperFoo> I was thinking of implementing the collatz conjecture: (return 1) sorry I kid! :)
13:10:20 * hackagebot fay-builder 0.2.0.2 - Compile Fay code on cabal install, and ad-hoc recompile during development  http://hackage.haskell.org/package/fay-builder-0.2.0.2 (AdamBergmark)
13:10:22 * hackagebot snaplet-fay 0.3.3.9 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.3.9 (AdamBergmark)
13:10:32 <conal> ReinH: https://github.com/conal/talk-2013-understanding-parallel-scan
13:10:38 <fbiville> and there is even a scanl1, great :)
13:10:40 <ReinH> conal: huh!
13:10:59 <conal> ReinH: yeah. it's lovely stuff!
13:11:02 <ReinH> conal: oh right, I seem to recall now, parallel prefix scan
13:11:05 <Ralith> Peaker: without it, you will be unable to render much of languages that go beyond ASCII correctly, and not even that if you account for cases that exist even in English where a correct rendering of certain character sequences consists of a single glyph
13:11:31 <conal> ReinH: yes. and *very* useful, given an eye for monoids.
13:11:36 <ReinH> conal: indeed!
13:11:40 <Ralith> Peaker: e.g. ligatures
13:12:30 <fbiville> conal / reinh : newbie question, although last scanl yields the same as foldl, last scanl is more efficient (in my case at least), right?
13:12:59 <ReinH> fbiville: so you only need the last value?
13:13:35 <ReinH> fbiville: what's the full calculation you are performing?
13:14:08 <fbiville> im dropping results until I find a triangle number which has >= 500 divisors
13:14:17 <ReinH> ah right
13:14:33 <fbiville> first version was: head (dropWhile (\m -> length (filter (\n -> m `mod` n == 0) [1..truncate(fromIntegral(m)/2)]++[m]) < 500) [ (foldl1 (+) [1..i]) | i <- [1..] ])
13:15:15 <ReinH> so a specification might be: head . dropWhile (\n -> length (divisors n) < 500) $ triangleNumbers
13:16:21 <fbiville> yep
13:16:31 <ReinH> fbiville: The naive way is of course to list all the triangle numbers and select the first one matching your predicate.
13:16:43 <fbiville> yep, my way so far :)
13:17:05 <ReinH> The less naive way is to notice that n and n + 1 are coprime.
13:17:06 <fbiville> very naive, i'd say even :p
13:19:11 <ReinH> and then to also notice that at each step you only need to calculate the factors of n + 1 since you previously calculated n as n + 1 on the last step
13:19:12 <Peaker> Ralith, I thought that stuff was handled by FreeType already?
13:19:31 <fbiville> reinH, I noticed the second point
13:19:33 <Ralith> Peaker: well, you thought wrong :p
13:19:54 <ReinH> fbiville: the fact that n and n + 1 are coprime imply that you can calculate the factors separately
13:19:57 <ReinH> since they do not share any
13:20:00 <ReinH> since that is what coprime means ;)
13:20:09 <ReinH> *implies
13:20:33 <Ralith> Peaker: a correct font rendering stack uses freetype ONLY for parsing fonts and rasterizing individual glyphs
13:20:44 <Peaker> Ralith, I keep getting disappointed with the state of computing.. I fail to lower my expectations :(
13:20:54 * Ralith sympathizes
13:21:10 <Ralith> but hey, at least you don't have to write the hard algorithmic stuff yourself.
13:21:41 <ReinH> fbiville: then you can notice that you don't need to calculate every actual triangle number, you just need to calculate the factors for n and (n + 1), then you construct the triangle number at the end using the reverse of the definition triangle(n) = n(n+1)/2
13:22:26 <Peaker> Ralith, people on #opengl suggested using SDF which does seem to imply that at this point
13:22:57 <Ralith> Peaker: "SDF"?
13:23:57 <Peaker> Ralith, Signed-difference-fields
13:24:08 <Ralith> Peaker: I assume you meant to type 'distance'
13:24:15 <Peaker> Ralith, probably :)
13:24:16 <ReinH> fbiville: does this make sense?
13:24:22 <Ralith> and you probably don't want that
13:24:28 <Peaker> Ralith, a (new?) technique to render fonts in a texture-like manner but that scales well and renders well on low-end hardware
13:24:31 * Ralith has found #opengl to be a rather useless channel
13:24:32 <Peaker> Ralith, why not?
13:24:44 <Ralith> because it does not render text accurately
13:24:50 <Ralith> what are you actually building?
13:25:13 <Peaker> Ralith, An IDE -- super-precise font rendering isn't actually that important, and non-English support can suck for the next few years (we'll have to get it right eventually)
13:25:33 <Peaker> Ralith, but it has to look good, and currently with FTGL it looks terrible when scaled down
13:25:47 <ReinH> fbiville: The Euler projects generally admit both a naive, brute force solution and a solution that depends on some interesting properties of number series, etc
13:25:48 <Ralith> that's because you are (and perhaps FTGL in general is) doing it wrong
13:26:13 <sinelaw> Peaker, did you try starting with a font size closer to the target scale?
13:26:18 <Ralith> use freetype and harfbuzz, render directly, do not ever scale
13:26:31 <fbiville> ReinH: yep, I rarely get to the clever solution
13:26:50 <Peaker> sinelaw, I am not sure how to even do that, the FTGL size interface is not clear to me
13:27:16 <Ralith> if you want a different size, change the font size parameter to freetype and harfbuzz and rerender
13:27:27 <Zemyla> @pl \k v l -> (k,v):l
13:27:27 <lambdabot> ((:) .) . (,)
13:27:51 <Zemyla> :t uncurry
13:27:52 <lambdabot> (a -> b -> c) -> (a, b) -> c
13:28:06 <Peaker> Ralith, that means changing graphics-drawingcombinators first (we use that one)
13:28:32 <Peaker> Ralith, the FreeType2 bindings only expose APIs under "Internal" modules
13:28:35 <Zemyla> :t curry (:)
13:28:36 <lambdabot> a -> b -> [(a, b)] -> [(a, b)]
13:29:08 <Ralith> Peaker: doing things properly usually requires patching higher-level libraries, in my experience
13:29:30 <benzrf> @unmtl ReaderT m a
13:29:30 <lambdabot> Plugin `unmtl' failed with: `ReaderT m a' is not applied to enough arguments, giving `/\A. m -> a A'
13:29:35 <benzrf> @unmtl ReaderT r m a
13:29:35 <lambdabot> r -> m a
13:29:40 <Peaker> Ralith, if you ever had to do that, why didn't you package it nicely? :)
13:29:43 <benzrf> @unmtl MaybeT m a
13:29:43 <lambdabot> m (Maybe a)
13:29:47 <benzrf> augh
13:30:10 <Peaker> benzrf, ?
13:30:19 <benzrf> nothing, thinking...
13:30:36 <Ralith> Peaker: I habitually upstream my patches. If graphics-drawingcombinators is broken, the obvious conclusion is that nobody's had to do correct text rendering with it yet.
13:31:17 <Peaker> Ralith, I mean -- why not create a "GLText" package on hackage that has a simple API to render Text with given size or what-not?
13:31:33 <Peaker> (using FreeType, harfbuzz and GL, if necessary)
13:31:42 <Ralith> because I haven't had to do that in Haskell yet.
13:31:54 <Peaker> Ralith, did you package such a lib for any other language?
13:32:01 <Peaker> (I'd gladly make bindings)
13:32:08 <ksira> extend take n is a semi-sliding window on non-empty lists, maybe now I will finally understand comonads!
13:33:05 <johnw> k
13:33:14 <EvanR-work> comonads are like nightclubs
13:33:25 <Ralith> Peaker: I'm working closely with someone who's in the process of doing it as part of a GUI library in C, but it's not production ready
13:33:40 <Peaker> Ralith, GUI library in C?! :-)  Weird!
13:33:48 <Peaker> Ralith, Why write a GUI library in C?
13:33:57 <EvanR-work> to avoid c++
13:34:02 <qrpnxz> Peaker: Why not?
13:34:11 <Ralith> so that you can use it anywhere
13:34:22 <qrpnxz> SDL FTW
13:34:22 <Peaker> qrpnxz, Because GUIs can typically suffer the overhead of GC & higher-level languages, so why not use those?
13:34:44 <Peaker> Ralith, Cool, will the text rendering part be separate?
13:35:00 <Ralith> for example, if it wasn't written in C, it certainly wouldn't be written in Haskell, and would thus be useless to people in your situation
13:35:01 <benzrf> @let type Tr f g t = forall a. f (g a) -> t a
13:35:03 <lambdabot>  Defined.
13:35:07 <qrpnxz> Peaker: ...why not use GC & higher-level languages?
13:35:07 <benzrf> hmm
13:35:19 <benzrf> :t MaybeT
13:35:20 <lambdabot> Not in scope: data constructor ‘MaybeT’
13:35:21 <Peaker> qrpnxz, yeah?
13:35:23 <Ralith> qrpnxz: that was his question, yes
13:35:37 <benzrf> does lambdabot not import MaybeT
13:36:17 <qrpnxz> Peaker: If GUIs can *typically* have an overhead why would you add the GC & higher level languages overhead on top of that?
13:36:28 <geekosaur> MaybeT is not a data constructor, it's a type constructir
13:36:30 <Ralith> Peaker: that isn't presently planned to my knowledge, but it's not terribly large or complex; see https://github.com/tiffany352/sui/blob/master/src/sui/renderer.c and nearby stuff
13:36:50 <Peaker> qrpnxz, I get clean 60FPS for my GUI written in Haskell
13:37:03 <benzrf> geekosaur: what's the data constructor then
13:37:17 <Peaker> geekosaur, MaybeT is also the data constructor
13:37:22 <qrpnxz> Peaker: That's not a reason not to use C other than preference.
13:37:27 <Ralith> qrpnxz: you misunderstood Peaker
13:37:40 <Ralith> qrpnxz: he was observing that a GUI does not typically suffer in the presence of overhead.
13:38:20 <Peaker> qrpnxz, I use C for my day job. I like C. But I wouldn't use it when the benefit of C (tight resource use, less overheads) just isn't needed. In that case, you're mostly paying the price but not gaining much
13:38:39 <ab9rf> hmphf
13:38:55 <Ralith> ease of binding is a large gain, in my opinion
13:39:02 <qrpnxz> All I'm saying is that there is no (efficiency) reason not to use C or write a GUI library for C.
13:39:04 <Ralith> as is independence from unusual RTSs
13:39:23 <Ralith> that seems like a fairly obvious and uninteresting thing to say
13:39:41 <Ralith> certainly nobody has indicated an opinion to the contrary
13:40:03 <Ralith> there are, however, many practical concerns for writing software beyond efficiency
13:40:14 <qrpnxz> Ralith: It was a misunderstanding.
13:40:19 <Peaker> I assumed those concerns are well known in #haskell (!) :-)
13:40:19 * hackagebot happstack-foundation 0.5.8 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  http://hackage.haskell.org/package/happstack-foundation-0.5.8 (JeremyShaw)
13:40:30 <Ralith> indeed :p
13:40:54 <Peaker> Ralith, I guess portability is nice, isn't it a bit tedious in C though?
13:41:12 <Ralith> depends
13:41:22 <Peaker> Ralith, btw, I recommend hiding "__attribute__((warn_unused_result))" behind a macro :)
13:41:46 <Ralith> that had occurred to me
13:42:02 <Ralith> it's not clear what such a macro should be called, though
13:42:34 <Ralith> I guess there's not much reason not to just wrap up the attribute all on its own, even
13:42:35 <Peaker> Ralith, we call it WARN_UNUSED_RESULT (we also place it after the end of the prototype to make the params visible)
13:48:04 <tremon> does anyone know a comprehensive reference for persistent's entity syntax? I'm now using https://github.com/yesodweb/persistent/wiki/Persistent-entity-syntax but it looks incomplete and quite handwavy for me
13:51:34 <breadmonster> Are there any adjoint functors in Haskell, btw?
13:53:49 <johnw> breadmonster: yes, tuple and function
13:53:59 <johnw> they give rise to the State monad, and the Store comonad
13:54:13 <johnw> and also, to a certain extent, function and function, which gives rise to Cont
13:54:18 <breadmonster> johnw, What exactly are comonads?
13:54:36 <johnw> that's a big question, but the simplest answer is that they are the categorical dual of monads
13:55:07 <Thulsadum> wasn't it just arrows flipped?
13:55:11 <johnw> yep
13:57:03 <ezyang> Is there any function in the standard libraries which does removeFile if the file in question is a file, and removeDirectoryRecursively if it is a directory?
13:57:51 <johnw> that would be a nice function to have sometimes
13:57:54 <johnw> removeEntry
13:58:21 <johnw>  I'm pretty sure that I've written that very function in several projects
13:58:46 <Peaker> yeah, I have that here: https://github.com/ElastiLotem/buildsome/blob/master/src/Lib/Directory.hs#L47  (though I'm a bit more restrictive there)
13:58:48 <Thulsadum> i bet it's too simple, i.e. 'left as an exercise to the interessted reader'
13:59:05 <johnw> should it remove symbolic links too?
13:59:12 <johnw> special files?  what if it's a mountpoint?
13:59:29 <sinelaw> if it fails, should it restore atomically?
13:59:35 <qrpnxz> ezyang: You could test if it's a folder and prefix the name to the path of files you are deleting for each level.
13:59:47 <ezyang> removeDirectoryRecursive is wrong for following symlinks, in any case
14:00:20 * hackagebot trace 0.1.0.4 - A monad transformer for tracing provenience of errors  http://hackage.haskell.org/package/trace-0.1.0.4 (JonSterling)
14:00:22 * hackagebot bindings-gpgme 0.1.6 - Project bindings-* raw interface to gpgme  http://hackage.haskell.org/package/bindings-gpgme-0.1.6 (JohnWiegley)
14:00:25 <ezyang> I don't know who thought it would be a good idea. Probably was the easiest thing to implement.
14:00:56 <johnw> what if you try to remove a named socket that has active listeners?  move it to /tmp, or force close the socket?
14:01:19 <qrpnxz> johnw: Yes.
14:01:23 <johnw> engineering: the practice of ignoring implications until you can get something done
14:01:27 <ezyang> I mean, I just want it to work like rm -rf
14:01:52 <qrpnxz> ezyang: Then why don't you just "rm -fr"?
14:02:00 <ezyang> well, that's not portable
14:02:11 <qrpnxz> And a binary is?
14:02:14 <johnw> it would be so cool if busybox was also a library you can import into Hasekll
14:02:32 <ezyang> If the compiler is protable, yes
14:02:35 <ezyang> *portable
14:03:41 <qrpnxz> ezyang: http://tinyurl.com/ou8h2lx
14:06:00 <lisbeth> what is the function to take a float ending in .0 and turn it into an int?
14:06:18 <qrpnxz> lisbeth: floor
14:06:34 <qrpnxz> :t floor
14:06:35 <lambdabot> (RealFrac a, Integral b) => a -> b
14:08:12 <fbiville> is there a more concise notation for, e.g. (\n -> x `mod ` n  == 0) ?
14:08:35 <qrpnxz> fbiville: (mod x)
14:08:57 <fbiville> qrpnxz : I "lose" the == 0 part, then, or?
14:09:10 <benzrf> fbiville: you could write `(==0) . mod x'
14:09:25 <fbiville> right!
14:09:25 <qrpnxz> ^
14:09:31 <qrpnxz> Sorry.
14:09:32 <fbiville> benzrf: thx!
14:09:34 <benzrf> it's pretty ugly though
14:09:39 <lisbeth> I'm having trouble understanding why I get an error here
14:09:40 <lisbeth> > let primetester' x y = if (y /= (floor (x / 2)) && (y /= 1) && ((x `mod` y) == 0)  then False else if y < (floor (x / 2)) then primetester' x (y + 1) else True
14:09:41 <lambdabot>  <hint>:1:84: parse error on input ‘then’
14:09:51 <fbiville> that feels like yoda writing :)
14:10:34 <lisbeth> mine?
14:11:09 <qrpnxz> lisbeth: You have unbalanced parenthesis.
14:11:16 <lisbeth> damnit
14:11:17 <lisbeth> ok thanks
14:11:42 <qrpnxz> > let primetester' x y = if (y /= (floor (x / 2)) && (y /= 1) && ((x `mod` y) == 0)) then False else if y < (floor (x / 2)) then primetester' x (y + 1) else True
14:11:43 <lambdabot>  not an expression: ‘let primetester' x y = if (y /= (floor (x / 2)) && (y /=...
14:12:14 <qrpnxz> > let primetester' x y = if (y /= (floor (x / 2)) && (y /= 1) && ((x `mod` y) == 0)) then False else if y < (floor (x / 2)) then primetester' x (y + 1) else True in primetester' 2 3
14:12:15 <lambdabot>  No instance for (GHC.Real.RealFrac a0)
14:12:15 <lambdabot>    arising from a use of ‘primetester'’
14:12:15 <lambdabot>  The type variable ‘a0’ is ambiguous
14:12:40 <qrpnxz> lisbeth: What is the type for primetester'?
14:13:01 <lisbeth> I don't know
14:13:17 <qrpnxz> lisbeth: What are the types of x and y?
14:13:24 <lisbeth> integers
14:13:32 <fbiville> last newbie question from me: i couldn't find via hoogle a function that does like '++' for 1 element, i.e. [a] -> a -> [a]
14:13:35 <geekosaur> nope
14:13:35 <fbiville> isn't there any?
14:13:45 <geekosaur> because you're applying (/) to an Integer in that case
14:13:51 <geekosaur> whence the RealFrac
14:13:57 <lisbeth> dangit
14:14:14 <lisbeth> simple solution though I think
14:14:19 <qrpnxz> reverse . (:) . reverse
14:14:29 <qrpnxz> fbiville: ^
14:14:34 <fbiville> [1,2] ??? 3 -> [1,2,3]
14:14:38 <fbiville> ok
14:14:39 <lisbeth> I'll just write a function that divides by 2 then returns an integer version of the answer
14:14:44 <lisbeth> because I'm supremely lazy
14:14:58 <geekosaur> fbiville, wasn't responding to you, but there is indeed not one because if you need that often enough, you probably want to buold the list in reverse using (:) and reverse all at once at the end
14:15:19 <geekosaur> alternatively look at Data.Sequence
14:15:21 <qrpnxz> geekosaur: Already sugested.
14:15:37 <fbiville> geekosaur: ok, thx
14:16:04 <Eiam> Is there a good starting point if I wanted to stand up something in Haskell using a Buildpack? I have not really dived into Haskell development outside of ghci just working through problems, thought I might put up a small service to try out some more tangible work.. web service
14:16:20 <Eiam> I saw https://github.com/begriffs/heroku-buildpack-ghc
14:16:43 <lisbeth> noooooooooooo
14:16:48 <lisbeth> it was so perfect and now it doesn't work
14:16:52 <qrpnxz> lisbeth: Here a primality tester I wrote: http://lpaste.net/117843
14:17:01 <mmmm> Eiam: https://github.com/mietek/haskell-on-heroku ?
14:17:37 <Eiam> mmmm: well, I can google for build packs, I was actually looking for someone thats actively using one to comment =)
14:18:28 <mmmm> Well I've heard good things about mietek's halycon for doing deployment
14:21:04 <Eiam> okay
14:21:10 <Eiam> now I need to figure out what Halycon is =)
14:21:11 <mietek> Eiam: hi
14:21:18 <mietek> Join #haskell-deployment and I’ll walk you through it
14:21:34 <mietek> I am currently working on a tutorial to answer your question
14:22:20 <mietek> TLDR: Halcyon is a wrapper around cabal-install which allows installing Haskell packages in one command, even tricky packages.
14:22:28 <mietek> Haskell on Heroku is a Heroku buildpack which uses Halcyon.
14:24:19 <mietek> I hope to announce both publicly this week.
14:24:38 <mietek> Meanwhile, you can check out https://halcyon.sh — there’s lots of examples.
14:25:09 <mietek> I know not everything is 100% clear yet, especially for someone who is just starting out.
14:25:39 <Welkin> like me
14:26:09 <mietek> Welkin: but you managed.
14:26:09 <mietek> :)
14:26:23 <Welkin> it is easy now that it is set up
14:26:52 <S11001001> @pl \a -> f >>= g a
14:26:52 <lambdabot> (f >>=) . g
14:27:51 <jle`> S11001001: bind is coming soon so it'll be `bind f . g` some day
14:27:54 <jle`> but
14:28:05 <bernalex> jle`: where do you have that from?
14:28:59 <S11001001> jle`: isn't bind =<<?
14:29:06 <bernalex> S11001001: no, bind is >>=
14:29:10 <jle`> S11001001: oh yeah, sorry
14:29:28 <jle`> bind is more meaningfully (=<<) i think
14:29:39 <jle`> and yeah, you're right, it wasn't for sure, it was only a proposal v.v i didn't follow up on it
14:29:56 <bernalex> it has historically been >>= everywhere I can remember. look at one of the most common haskell logos.
14:30:01 <bergmark> people didn't like the name bind for =<<
14:30:29 <S11001001> bernalex: I'm referring specifically to the proposal to introduce the name "bind" for an operation, not the colloquial pronunciation
14:30:44 <bernalex> jle`: it was rejected because a) bind means >>= to most of us, and the proposal was for =<<, and b) because what's the point? (=<<) or (=<<) isn't much shorter than bind.
14:31:06 <jle`> the point was an analogy for `fmap` to (<$>)
14:31:18 <jle`> you like to use fmap when you really just want a (a -> b) -> (f a -> f b)
14:31:22 <Welkin> but if you want fmap, you use fmap, not <$>
14:31:39 <jle`> but if you want a (a -> m b) to be an (m a -> m b)...when what do you do?
14:31:48 <bernalex> (=<<)
14:31:59 <johnw> slap a . return on the front?
14:32:06 <dmj`> pure then join?
14:32:10 <bernalex> I really don't see the problem with using the operator prefix.
14:32:17 <jle`> operator prefix is silly ;_;
14:32:18 <bernalex> or sectioning or whatever.
14:32:31 <jle`> you can use it prefix or section but i think `fmap` is nice
14:32:41 <jle`> there's a reason people use `fmap` over (<$>) or (f <$>)
14:32:43 <mmmm> there'd always be that guy who used `bind` infix
14:32:54 <monochrom> @type (=<<)
14:32:54 <bernalex> jle`: yeah because it happens to exist
14:32:54 <lambdabot> Monad m => (a -> m b) -> m a -> m b
14:32:56 <c74d> Can a Warp Web-server easily be made to redirect HTTP connections to HTTPS?
14:32:58 <jle`> i think people would be sad if we took away `fmap`
14:33:06 <johnw> I use `liftM`, but I like <$>
14:33:08 <bernalex> fmap should be named map anyway
14:33:12 <S11001001> bernalex: ah
14:33:17 <jle`> same deal...imagine a world where we took away `map`
14:33:28 <jle`> and (<$>) was in Functor
14:33:28 <bernalex> jle`: people would whine because omg change
14:33:32 <johnw> we have fmap, map and ap; where is p?
14:33:35 <bernalex> if it wasn't there in the first place it would be less of a deal
14:33:40 <monochrom> please don't take away my nap
14:33:40 <bernalex> jle`: (<$>) *is* in Functor.
14:33:40 <mmmm> also when you want to fmap two levels deep it's nicers to fmap f <$>
14:33:49 <sipa> @let p = ap
14:33:51 <lambdabot>  Defined.
14:33:56 <sipa> :t p
14:33:57 <lambdabot>     Ambiguous occurrence ‘p’
14:33:57 <lambdabot>     It could refer to either ‘L.p’,
14:33:57 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:157:1
14:33:58 * HeladoDeBrownie has occasionally defined fmap2 or even fmap3 locally
14:34:03 <jle`> (<$>) is in Functor since when?
14:34:10 <HeladoDeBrownie> fmap2 = fmap . fmap; fmap3 = fmap . fmap2
14:34:13 <bernalex> jle`: probably since it was introduced?
14:34:16 <mmmm> @let bind = (>>=)
14:34:17 <lambdabot>  Defined.
14:34:23 <jle`> :i on ghci for me shows fmap in Functor, not (<$>)
14:34:31 <bernalex> @let dnib = (=<<)
14:34:32 <lambdabot>  Defined.
14:34:33 <bernalex> problem solved
14:34:42 <bernalex> jle`: both are in Data.Functor
14:34:47 <jle`> i meant the Functor typeclass
14:34:52 <mmmm> maybe we should make a version of prelude which gets modified by lambdabot sessions
14:34:58 <bernalex> jle`: I don't know what you mean
14:35:04 <bernalex> (<$>) :: Functor f => (a -> b) -> f a -> f b
14:35:04 <lisbeth> > let primetester' x y = if ((x / y) >= y) && ((x `mod` y) == 0) then False else if y < ((x / y) >= y) then primetester' x (y + 1) else True
14:35:05 <lambdabot>  not an expression: ‘let primetester' x y = if ((x / y) >= y) && ((x `mod` y)...
14:35:06 <bernalex>   -- Defined in ‘Data.Functor’
14:35:14 <lisbeth> :(
14:35:21 <jle`> class Functor f where fmap :: ..., (<$) :: ...
14:35:27 <HeladoDeBrownie> mmmm, like a hackage package that updates every time we use @let in here? that would be… "interesting".
14:35:48 <jle`> i like how fmap has a name, and is not an operator
14:35:48 <qrpnxz> lisbeth: You have two "then"s
14:35:57 <lisbeth> dangit
14:36:16 <fbiville> my function is still quite slow :/
14:36:17 <lisbeth> no that's cause I have two ifs
14:36:17 <jle`> imagine a world where it was class Functor where (<$>) :: ...
14:36:19 <fbiville> triangle count = head . dropWhile (\m -> (length $ divisors m) < count) $ triangle_numbers
14:36:24 <qrpnxz> lisbeth: AND tow "else"s
14:36:25 <jle`> and there was no such thing as `fmap` or `map`
14:36:30 <jle`> it would be a sad world
14:36:31 <qrpnxz> lisbeth: Ah.
14:36:32 <fbiville> triangle_numbers = [ let i'=(fromIntegral i) in truncate ((i'*(i'+1))/2) | i <- [1..] ]
14:36:33 <jle`> that is the world we live in today!!!!
14:36:42 <jle`> open your eyes !!
14:36:48 * jle` rests his case
14:36:50 <qrpnxz> lisbeth: Try using parenthesis.
14:37:25 <EvanR-work> map = (<$>) thx
14:37:32 <lisbeth> no success: let primetester' x y = if ((x / y) >= y) && ((x `mod` y) == 0) then False else (if y < ((x / y) >= y) then primetester' x (y + 1) else True)
14:37:40 <fbiville> I have yet to see 'triangle 500' complete :)
14:37:44 <EvanR-work> <> = mappend
14:38:04 <jle`> EvanR-work: that works for your own code base, but wouldn't i be nice to have that in base for everyone to have >_>
14:38:05 <lisbeth> oh wait
14:38:07 <lisbeth> hold on a minute
14:38:19 * monochrom supports "class Functor f where fmap, map, (<$>) :: (a -> b) -> f a -> f b; fmap = map; map = (<$>); (<$>) = fmap"
14:38:22 <EvanR-work> jle`: to hell with em ;)
14:39:13 <shachaf> monochrom: {-# MINIMAL fmap | map | (<$>) #-}
14:39:23 <Axman6> fbiville: btw, since i or i+1 will always be even, you can use integer div: (i*(i+1)) `div` 2
14:39:24 <monochrom> yeah!
14:39:28 <shachaf> But I don't really see the point of synonyms in a class.
14:39:36 <monochrom> it's a joke :)
14:39:50 <jle`> maybe if you couldn't decide on an implementation
14:39:55 <jle`> or an evaluation strategy
14:39:57 <Axman6> fbiville: then you never need to convert to and from floating point numbers
14:39:57 <jle`> :)
14:40:20 <shachaf> Oh. Well then.
14:40:21 <AdNauseaum> that feel when a wild pack of niggers kills your grandma ;_; rip granny 2014
14:40:27 <monochrom> "This April 1st, the Functor class will get an update to answer everyone's request..." :)
14:40:42 <Axman6> @where ops
14:40:42 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:40:53 --- mode: ChanServ set +o johnw
14:40:53 --- mode: johnw set +b *!*@99.32.15.3
14:40:53 --- kick: AdNauseaum was kicked by johnw (Kicked)
14:40:54 --- mode: johnw set -o johnw
14:41:06 <Axman6> thanks johnw
14:41:15 <johnw> thanks for summoning
14:41:54 <dmj`> banhammer !
14:42:25 <qrpnxz> lisbeth: Try using guards: http://lpaste.net/117844
14:45:25 <fbiville> @Axman6: thx
14:45:25 <lambdabot> Unknown command, try @list
14:45:32 <qrpnxz> lol
14:53:29 <tempay> I need a type constructor to declare an instance of a typeclass, right? So it couldn't be declared with type
14:54:23 <mmmm> there is TypeSynonymInstances
14:54:23 <geekosaur> there is TypeSynonymInstances extension
14:54:46 <tempay> oh, nifty, I'll check it out
14:56:34 <shachaf> That extension doesn't let you do anything you couldn't do without it.
14:58:36 <EvanR-work> there once was an extension that let you do anything you couldnt do without it
14:59:14 <EvanR-work> using the extension, can you use the extension
14:59:21 <monochrom> that sounds suspiciously like a tautology :)
14:59:27 <S11001001> EvanR-work: mu
15:00:08 <tempay> huh, I think I see what shachaf means
15:00:56 <tempay> say I have "type Foo a = Bar -> IO a"
15:00:57 <S11001001> tempay: It would be highly ambiguous to let you do what you can't do without it, even more so than OverlappingInstances
15:01:28 <monochrom> {-# LANGUAGE Very,VeryFlexibleInstances #-} :)
15:01:38 <S11001001> -XDWIMInstances
15:01:57 <tempay> S11001001: Yeah, that was my concern, might not be well defined
15:02:09 <tempay> ah well, I'll suck it up and use a constructor
15:02:35 <S11001001> GND :)
15:02:38 <monochrom> {-# LANGUAGE AllowInstancesThatWouldn'tBeAllowedWithoutThis #-}  -- thanks EvanR-work :)
15:04:00 <tempay> unrelated question - is there a build-in for doing a sequence (as in [IO a] -> IO [a]) on other data structures, like Data.Map?
15:04:20 <tempay> now that I say that, I bet it's in traversal
15:04:28 <monochrom> Traversable or Foldable may have it
15:04:34 <dmj`> :t sequenceA
15:04:35 <lambdabot>     Not in scope: ‘sequenceA’
15:04:35 <lambdabot>     Perhaps you meant one of these:
15:04:35 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
15:04:40 <dmj`> :t T.sequenceA
15:04:41 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
15:04:59 <tempay> sweeet :)
15:05:02 <S11001001> :t F.forM
15:05:02 <lambdabot>     Not in scope: ‘F.forM’
15:05:03 <lambdabot>     Perhaps you meant one of these:
15:05:03 <lambdabot>       ‘T.forM’ (imported from Data.Traversable),
15:05:08 <S11001001> :t Data.Foldable.forM
15:05:09 <lambdabot>     Not in scope: ‘Data.Foldable.forM’
15:05:09 <lambdabot>     Perhaps you meant one of these:
15:05:09 <lambdabot>       ‘Data.Foldable.fold’ (imported from Data.Foldable),
15:05:12 <S11001001> :t Data.Foldable.forM_
15:05:12 <lambdabot> (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
15:05:16 <S11001001> :t Data.Foldable.sequence_
15:05:17 <lambdabot> (Foldable t, Monad m) => t (m a) -> m ()
15:05:25 <dmj`> :t T.forM
15:05:26 <lambdabot> (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
15:05:28 <S11001001> :t Data.Foldable.sequenceA_
15:05:28 <lambdabot> (Foldable t, Applicative f) => t (f a) -> f ()
15:06:13 <rom1504> :k Foldable
15:06:13 <lambdabot> (* -> *) -> Constraint
15:06:43 <rom1504> :k Constraint
15:06:43 <lambdabot>     Not in scope: type constructor or class ‘Constraint’
15:06:44 <lambdabot>     Perhaps you meant ‘Contains’ (imported from Control.Lens)
15:06:46 <monochrom> that means Foldable is a type class
15:06:53 <rom1504> :t Contraint
15:06:53 <lambdabot> Not in scope: data constructor ‘Contraint’
15:07:17 <rom1504> right ok
15:07:20 <monochrom> Constraint is a type but you have to import GHC.Exts to get its name into scope.
15:07:32 <monochrom> err, Constraint is a kind. the rest is right.
15:07:58 <lisbeth> erk
15:08:04 <lisbeth> I can never get anything to compile: http://lpaste.net/117850
15:08:45 <monochrom> GHC does have the bad habit of outputting names that you haven't imported so you can see them but you can't enter them.
15:09:44 <monochrom> delete "let "
15:10:09 <lisbeth> good call
15:11:10 <lisbeth> OH WOW now I am in a whole heap of other trouble
15:11:24 <qrpnxz> lisbeth: Explain.
15:11:40 <monochrom> "the real journey begins after you have no syntax errors" :)
15:11:50 <qrpnxz> lol
15:12:05 <qrpnxz> monochrom: Then it's types.
15:12:28 <lisbeth> remove let and see what happens
15:15:03 <marioxcc> Hello.
15:15:42 <qrpnxz> lisbeth: Define your types.
15:16:28 <jonsterling> Are any of the maintainers of Scotty online?
15:16:44 <monochrom> lisbeth: I'm pretty sure when you wrote "x / y" you meant "x `div` y"
15:16:54 <marioxcc> I'm trying to prepare haskell mode for using it in Emacs, but I get this error: http://lpaste.net/117851
15:16:59 <marioxcc> what should I do?
15:17:06 <ab9rf> heh
15:17:27 <ab9rf> my favorite type errors are the ones that generate three and a half screens of output
15:17:59 <monochrom> this case is a case of buggy error message. the error message fails to mention the Fractional class, which is the real culprit of being unable to find an instance.
15:18:22 <qrpnxz> lisbeth: Change "/" to "`div`" and define the types.
15:18:47 <qrpnxz> primetester :: Int -> Int -> Bool and primes :: [Int]
15:19:16 <lisbeth> heh
15:19:23 <marioxcc> Does anyone uses haskell-mode for Emacs?
15:19:33 <Hijiri> I do
15:19:36 <marioxcc> I'm trying to prepare it for installation, but I get this: http://lpaste.net/117851
15:19:37 <qrpnxz> marioxcc: VIM user sorry.
15:19:43 <Hijiri> I don't know if I can help set it up
15:19:45 <hiptobecubic> vim 4 lyfe!
15:19:48 <marioxcc> qrpnxz: Ok.
15:19:49 <Hijiri> I just followed bitemyapp's guide
15:19:57 <marioxcc> Hijiri: could you please give me a link?.
15:20:11 <monochrom> it seems that the shell cannot find your emacs.
15:20:13 <qrpnxz> hiptobecubic: It's the only real way to program.
15:20:19 <hiptobecubic> marioxcc, yeah you should install emacs first, probably.
15:20:44 <ab9rf> installing emacs is usually a key step inthe process of using it.
15:20:45 <Hijiri> actually it wasn't bitemyapp's guide
15:20:53 <Hijiri> https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
15:20:58 <marioxcc> I have emacs already installed actually
15:21:02 <Hijiri> It was linked in https://github.com/bitemyapp/learnhaskell though
15:21:02 <marioxcc> Let me check my PATH.
15:21:31 <marioxcc> Ok Hijiri
15:23:25 <tempay> So I have a type "data Foo x = Bar -> IO x" that I'd like to behave basically like the IO monad, and pass in the Bar after building the whole Foo
15:23:36 <tempay> Is that an application for monad transforms?
15:24:09 <quchen> ?unmtl ReaderT Bar IO x
15:24:09 <lambdabot> Bar -> IO x
15:24:19 <quchen> That's the Reader transformer.
15:24:43 <tempay> okie doke, guess it's time to learn transformers. thanks quchen
15:26:06 <t4nk207> quit
15:28:20 <hiptobecubic> tempay, note that with reader, every function will see the same Bar though. If you need to modify it throughout your Foo computation you'll need State
15:29:24 <dmj`> tempay: it's all in the kinds for transformers
15:29:57 <dmj`> :k StateT Int IO Int
15:29:58 <lambdabot> *
15:31:37 <dmj`> :k StateT Int (StateT Int IO) Int
15:31:38 <lambdabot> *
15:31:49 <dmj`> :k StateT Int (StateT Int (StateT Int IO)) Int
15:31:50 <lambdabot> *
15:32:20 <hiptobecubic> that's pretty horrible.
15:32:39 <dmj`> they all follow the pattern T (s :: *)  (m :: * -> *) (a :: *)
15:32:41 <dmj`> :k StateT
15:32:42 <lambdabot> * -> (* -> *) -> * -> *
15:33:22 <dmj`> :k ReaderT
15:33:23 <lambdabot> * -> (* -> *) -> * -> *
15:33:41 <shachaf> No, a monad transformer is :: (* -> *) -> * -> *, but that s argument is just a parameter for the specific transformers you happened to look at.
15:34:01 <johnw> :k IdentityT
15:34:02 <lambdabot>     Not in scope: type constructor or class ‘IdentityT’
15:34:02 <lambdabot>     Perhaps you meant ‘Identity’ (imported from Control.Monad.Identity)
15:34:08 <shachaf> ReaderT isn't a monad transformer anyway. ReaderT s is a monad transformer.
15:34:25 <shachaf> So is MaybeT.
15:37:40 <hrumph> hi
15:37:49 <johnw> hello
15:37:59 <hrumph> what do i do to get the compiler to read string literals as Text so i don't have to call "pack" all the time?
15:38:14 <johnw> the OverloadedStrings extension
15:38:19 <seagreen> Are there any haskell implementations of json-schema.org draft 4? The closest I can find is this (for draft 3): https://github.com/timjb/aeson-schema
15:38:34 <johnw> put this at the top of your file: {-# LANGUAGE OverloadedStrings #-}
15:39:32 <hrumph> johnw ok thank i know how to set up the extensions (already using a few). my next question is how come some extensions like this one are extensions instead of just built in defaults
15:39:43 <hrumph> this one is a big no-brainer for always having
15:39:51 <johnw> you'd think, wouldn't you
15:39:58 <hrumph> yes!
15:40:00 <johnw> except that it can lead to confusing errors for those attempting to teach Haskell
15:40:08 <ReinH> (Actually it can make type errors more... yep)
15:40:18 <ReinH> Also the default is to maintain compatibility with the Haskell standard
15:40:23 <qrpnxz> Not everyone wants to use Text.
15:40:44 <hrumph> qrpnxz, what's the advantage of String over Text?
15:40:54 <ReinH> language extensions are precisely that: things that are extensions of (and not a part of) the language specification
15:41:03 <qrpnxz> I can't think of any.
15:41:09 <Hijiri> String is usually less efficient than Text
15:41:15 <qrpnxz> True.
15:41:19 <Hijiri> maybe if your String represents a stream of characters it could take less memory
15:41:37 <qrpnxz> Bytestring is used for that.
15:41:48 <Hijiri> lazy bytestring?
15:41:53 <qrpnxz> Lazy Bytestring in particular.
15:41:55 <qrpnxz> Yes.
15:42:04 <Hijiri> ok, I guess String isn't too useful there either
15:42:08 <Hijiri> but it's easy to reason about
15:42:24 <lisbeth> rate my prime number generator: http://lpaste.net/117853
15:42:40 <johnw> don't lazy bytestrings even have a rather large minimum buffer size?  So that if you have lots of very short ByteStrings resident, won't it use a lot of heap?
15:44:00 <tommd> It reads in just under 32KB chunks but I don't know about a default minimum allocation size.
15:44:10 <johnw> I'd think String would be the most predictable if you want laziness at character granularity
15:44:27 <qrpnxz> Lazy Bytestrings are actually made to have better heap usage than Bytestrings
15:45:18 <qrpnxz> They're more memory efficient because characters are restricted to Word8 (eight bits).
15:45:36 <ReinH> there are no characters, only bytes
15:46:05 <dmj`> lisbeth: you can do even better if you only go up to the square root of the number you're checking primality on
15:46:05 <dmj`> http://lpaste.net/117853
15:46:06 <Welkin> Char cannot only be a byte since it supports unicode
15:46:30 <hrumph> is it more efficient to append to the beginning or the end of a Vector?
15:46:49 <Welkin> a vector is just an array
15:46:55 <qrpnxz> dmj`: That's how I did it. http://lpaste.net/117843
15:46:57 <Welkin> so either should be O(1)
15:47:01 <Welkin> right?
15:47:10 <johnw> how could it be O(1)?
15:47:19 <hrumph> Welkin yes but the way its implemented the arrays may have some pre- allocted space at the end
15:47:28 <johnw> then indexing would need to consider multiple blocks
15:47:47 <hrumph> Welkin, so maybe if you add at the end it's probably a bit more efficient than adding at the beginning on average
15:47:49 <johnw> I would think it would be O(n+m), for appending a Vec n and Vec m, to either side
15:48:09 <dmj`> qrpnxz: oh I was looking at this snippet: http://lpaste.net/117853
15:48:13 <hrumph> johnw i'm thinking of adding, say one character on
15:48:20 <johnw> hmm
15:48:21 <dmj`> qrpnxz: looks good !
15:48:24 <johnw> i don't know about preallocation
15:48:26 <hrumph> john w or a very small number of elements relative to what's already there
15:48:35 <qrpnxz> dmj`: Thanks.
15:48:52 <lisbeth> dmj are you saying that the number you are checking against a potential prime can't be higher than the square root of the potential prime?
15:48:55 <hrumph> johnw sure i don't really know i just thought it possible
15:49:12 <qrpnxz> lisbeth: Yes.
15:49:25 <dmj`> lisbeth: yes
15:49:27 <numberten> vectors are arrays?
15:49:30 <qrpnxz> lisbeth: Because x * y = y * x
15:49:39 <numberten> I thought (!) was O(log n) though
15:49:50 <johnw> vectors are arrays
15:49:57 <qrpnxz> :t !
15:49:58 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:50:07 <qrpnxz> :t (!)
15:50:08 <lambdabot> Ix i => Array i e -> i -> e
15:50:10 <hrumph> john i think i remember from somewhere that when declaring big arrays you would stop worrying about the exact length and go with sizes like 32, 64 etc. up until the page size
15:50:13 <johnw> "(!) :: Vector a -> Int -> a Source -- O(1) Indexing"
15:50:14 <johnw>  
15:50:14 <johnw>  
15:50:43 <hrumph> johnw that is array size in bytes but maybe i'm misremembering
15:51:02 <johnw> i don't know how it's implemented
15:51:12 <johnw> and any assumption about how it's implemented is likely to change
15:51:43 <numberten> what is the difference between
15:51:45 <numberten> Array and Vector
15:51:48 <numberten> then?
15:51:57 <johnw> Array supports more flexible indexing, for one
15:51:58 <hrumph> its because if you go with standard sizes you will have to realloc less
15:52:18 <hrumph> reallocing a whole array for one addition is maybe not worth it
15:52:35 <hrumph> depends on how many arrays you've got relative to memory you're willing to use i guess
15:53:03 <johnw> I think Vector's "generic" interface is something Array doesn't have
15:53:12 <johnw> hvr would know :)
15:58:06 <m1dnight_> Guys, I have a datatype Variable = Var String, and show is implemented for Var as show (Var lbl) = show lbl
15:58:28 <m1dnight_> but it always shows me the name with quotes. I've been googling and found that you should do "id lbl" but it still shows me quotes
15:58:50 <vanila> just put = lbl, not = show lbl
16:00:27 <m1dnight_> well what do you know, it was that simple
16:00:31 <m1dnight_> it works :) Thank you vanila
16:01:37 <meiji11> is there a way around not being to unpack Integer values in strict fields?
16:01:51 <meiji11> not being able to unpack ..
16:02:10 <Welkin> m1dnight_: it's already a String, so there is no need to apply show
16:04:40 <m1dnight_> Welkin: indeed. I understand now :)
16:05:26 * hackagebot cabal-lenses 0.4.4 - Lenses and traversals for the Cabal library.  http://hackage.haskell.org/package/cabal-lenses-0.4.4 (DanielTrstenjak)
16:12:03 <dmj`> cabal lenses :)
16:13:02 <tolt> Does anyone have recommendations for a mailbox library to use?
16:15:26 * hackagebot cabal-bounds 0.9 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.9 (DanielTrstenjak)
16:16:20 <godel> suppose I have something like "let a = a:a". How does haskell's typechecker stop, and does not loop infinitely? Is there an expression that can do that?
16:16:49 <vanila> godel, are you familiar with how type inference uses unification
16:16:59 <godel> vanila: a little
16:17:05 <vanila> the way it knows to stop in cases like that (infinite types) is that it performs an occurs check during unification
16:17:26 <godel> vanila: some resource I can read from?
16:17:40 <vanila> so in a : a it needs to check that a :: t and a :: [t]
16:17:59 <godel> vanila: so if the algorithm uses unification it always terminates?
16:18:00 <vanila> but unifying those types t = [t] will get an occurs check and fail
16:18:09 <vanila> thats right
16:18:14 <godel> nice
16:19:06 <bergmark> godel: http://stackoverflow.com/questions/12493773/what-cases-do-the-ghc-occurs-check-identify
16:19:07 <godel> I'm writing a language that has no primivite types (expcept for (->) if you will), and I'm puzzled with these things
16:19:31 <ksira> What's the best way to avoid writing fromIntegral all the time with numeric heavy code to do a type conversion, will numeric prelude help? Specifically I have a lot of divisions involving the length of containers.
16:19:33 <godel> thanks bergmark
16:21:26 <Saizan> ksira: define a fromIntegral . length ?
16:23:50 <shock_on_> Hi. In this tutorial https://www.fpcomplete.com/user/byorgey/introduction-to-haskell/5-type-classes Brent Yorgey writes about holomorphicity of number literals. To quote "This means that literals like 5 can be used as Ints, Integers, Doubles, or any other type which is an instance of Num (Rational, Complex Double, or even a type you define...)". So, how would I create my own type that would use the literals? As far as I
16:23:50 <shock_on_>  understand, any ADT should have a type constructor, so my type would be not, say, 42, but MyConstructor 42.
16:24:13 <vanila> holomorphicity? lol
16:24:25 <shock_on_> polimorphicity.
16:24:52 <Fuuzetsu> newyorkcity
16:24:52 <exio4> shock_on_, the Num typeclasses has a function "fromInteger"
16:25:02 <exio4> @type fromInteger
16:25:03 <lambdabot> Num a => Integer -> a
16:25:26 * hackagebot cabal-cargs 0.7.6 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.7.6 (DanielTrstenjak)
16:25:28 * hackagebot formatting 6.1.0 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-6.1.0 (ChrisDone)
16:28:26 <Axman6> shock_on_: if you want to define a type where the text "42" in your program means "MyConstructor 42", then you need to make the type that defined Myconstructor an instance of the Num class, specifically making fromInteger n = MyConstructor n (or MyConstructor (fromInteger n) if you need the value inside MyConstructor to be a type which isn't an Integer)
16:29:28 <ab9rf> holomorphicity is that place in cyberspace where all the holomorhic intelligences hang out when they're not on duty.
16:30:43 <Axman6> shock_on_: having Num as a type class is really handy, it means that if you have a type say data Expr = Int Integer | Add Expr Expr | Mul Expr Expr | Negate Expr | ..., you can have instance Num Expr where fromInteger n = Int n; a + b = Add a b; a * b = Mul a b, and then you can write 1 * 2 + 3 * 4 to get Add (Mul (Int a) (Int 2)) (Mul (Int 3) (Int 4))
16:31:06 <muahtorski> ?wiki Monad
16:31:06 <lambdabot> http://www.haskell.org/haskellwiki/Monad
16:31:22 <muahtorski> give example
16:31:43 <Axman6> you get all the presidence stuff for numeric expressions for free so you don't have to write parsers
16:31:47 <Axman6> muahtorski: ?
16:32:06 <muahtorski> sorry, new here
16:32:28 <Axman6> welcome! do you have a question?
16:35:27 * hackagebot lens-action 0.1.0.1 - Monadic Getters and Folds  http://hackage.haskell.org/package/lens-action-0.1.0.1 (EricMertens)
16:35:47 <Jello_Raptor> oh, does #haskell have any recommendations for textbooks on category theory and the theory side of dependent type systems?
16:35:49 <shock_on_> Thank you, Axman6.
16:36:34 <Axman6> no worries
16:36:36 <Zemyla> @pl \(a, b) = [Left a, Right b]
16:36:37 <lambdabot> (line 1, column 9):
16:36:37 <lambdabot> unexpected "="
16:36:37 <lambdabot> expecting operator, pattern or "->"
16:36:43 <Zemyla> @pl \(a, b) -> [Left a, Right b]
16:36:44 <lambdabot> uncurry ((. (return . Right)) . (:) . Left)
16:36:45 <Axman6> Zemyla: ->
16:36:50 <Axman6> =)
16:37:09 <muahtorski> @type fromInteger
16:37:10 <lambdabot> Num a => Integer -> a
16:37:14 <Axman6> > read "1 + 2 * 3" :: Int
16:37:16 <lambdabot>  *Exception: Prelude.read: no parse
16:37:19 <Axman6> :(
16:37:41 <Axman6> > reads "1 + 2 * 3" :: Int
16:37:42 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
16:37:43 <lambdabot>              with actual type ‘[(a0, GHC.Base.String)]’
16:37:56 <Axman6> > reads "1 + 2 * 3" :: [(Int, String)]
16:37:57 <lambdabot>  [(1," + 2 * 3")]
16:38:36 <muahtorski> bye
16:38:42 <Axman6> :\
16:39:10 <Zemyla> @djinn [Either a b] -> ([a], [b])
16:39:10 <lambdabot> Error: Undefined type []
16:39:27 <Axman6> :t partitionEithers
16:39:28 <lambdabot> [Either a b] -> ([a], [b])
16:39:42 <Axman6> @hoogle partitionEithers
16:39:44 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
16:39:59 <Axman6> djinn doesn't support recursive types like list btw
16:41:56 <liyang> conal: http://connpass.com/event/10638/ , 3:40pm :)
16:49:20 <shock_on_> Axman6: about your example with Expr. I fail to see why it's useful. Could you explain, please?
16:50:50 <Axman6> shock_on_: it just means that in your haskell source code, you can write expressions like: myExpr :: Expr; myExpr = 1+2*3+4 `div` 6 and you'll get an abstract syntax tree of the expression without having to write an annoying parser
16:50:59 <qrpnxz> tolt: http://hackage.haskell.org/package/mailgun
16:52:25 <Axman6> so your own types can be used just like any other haskell Num types now. this means you can do things like defining more complex types (say maybe matrices) as Num and you can clean syntax for everything
16:56:29 <Axman6> shock_on_: one cool example is the AD package (automatic differentiation), which lets you write expressions which automatically calculate their derivative as well as the expression itself
17:00:11 <random-jellyfish> question : why is function composition so important?
17:00:32 <qrpnxz> It facilitates a lot of stuff.
17:00:55 <random-jellyfish> like what
17:01:04 <vanila> its how we build programs
17:01:23 <qrpnxz> Like if you want a function that does multiple thing you can just chain them.
17:02:00 <Hijiri> you do something and you do something with the result
17:02:11 <Hijiri> if programs could only do something and not use the results, they would be very limited
17:02:16 <Axman6> > let sumSquared = sum . map (\x -> x*x) in sumSquared [1..10] -- sumSquared is defined by the process is executes, not by the arguments
17:02:17 <qrpnxz> addTenAndMultiplyByTwo = (*2) . (+10)
17:02:17 <lambdabot>  385
17:02:44 <josephle> when your set of tools are nicely optimized for creating pipelines, many problems start looking like they can be solved with pipelines :P
17:02:52 <josephle> not that it's a bad thing
17:03:08 <random-jellyfish> I'm asking this because I noticed that the main reason monads are used is to create composition some special types of functions
17:03:38 <random-jellyfish> I'm still in the phase in which I'm digesting the concept of monad
17:03:52 <ksira> There is a combinatorial explotions of functions that result from taking all possible compositions from set of functions, less work for you!
17:04:12 <tommd> That phase lasts several decades, Moggi is almost done with it.
17:04:30 <Axman6> random-jellyfish: composition is the essence of programming itself; making composition easy makes programming easy. easy composition encourages making smaller, more compositional code and then composing it together to make a larger tool from reusable aprts
17:05:25 <pharaun> so its basically composition all the way down?
17:05:29 <Axman6> you don't see huge functions very often in Haskell, because it's usually nicer to write smaller pieces and put them together. it's all about reusability and clarity
17:05:48 <pharaun> that's what i love
17:05:57 <qrpnxz> ^^
17:05:58 <Pamelloes> pharaun: Most of the way down. About 55% of the way down, it switches to turtles.
17:06:31 <random-jellyfish> I'm coming from an OOP background ... I'm wondering if there any design patterns in haskell like in OOP
17:06:40 <pharaun> monads?
17:07:00 <Pamelloes> random-jellyfish: Any problem solvable in OOP is solvable in Haskell, but you have to solve them differently.
17:07:20 <qrpnxz> TBH if you try to OOP in Haskell you're just gonna hurt yourself.
17:07:23 <Axman6> random-jellyfish: monads are just one p[articular form of being able to compose nicely abstract ideas (often quite unrelated types can benefit from some similar interfaces, and monad is just one of them that crops up regularly)
17:07:50 <hrumph> is the first element of a Vector always 0?
17:07:56 <pharaun> can you call monads a more strict version of "design patterns" ?
17:08:06 <pharaun> i mean it has laws n' all
17:08:09 <josephle> hrumph: you mean the index of the first element?
17:08:15 <hrumph> josephle, yes
17:08:23 <Axman6> random-jellyfish: this article may be useful to you; it's not the best article to explain the monad idea, but it will use some familliar concepts for your OOP broken mind: http://codon.com/refactoring-ruby-with-monads
17:08:24 <josephle> yeah, it's 0
17:09:07 <Axman6> hrumph: if you use the Array package, you can choose your own ranges for the indices in the array
17:09:12 <random-jellyfish> interesting, I'll have a look
17:09:21 <Peaker> random-jellyfish, Design patterns are programming language bugs :)
17:09:21 <Axman6> so you can have the first element start at 3, or even at (7,9)
17:09:32 <josephle> random-jellyfish: this might interest you http://blog.ezyang.com/2010/05/design-patterns-in-haskel/
17:09:45 <qrpnxz> lol
17:09:56 <josephle> basically a translation of design patterns to simple uses of haskell primitives
17:10:38 <random-jellyfish> Peaker: not sure about that :)
17:10:43 <Axman6> I feel things like Traversable mean that "design patterns" are somewhat unnecessary. Haskell makes ity easy to see common patterns between types and abstract them
17:11:12 <qrpnxz> Haskell is all about pattern matching.
17:11:45 <random-jellyfish> patterns appear when you can't rearrange some repeatable code into a reusable library...so you create a reusable "recepy" that will be applied differently for different problems
17:12:32 <qrpnxz> Like function composition.
17:14:04 <mseeks> hey guys, I have a function of type `a -> IO b` and want to make a function of type `Maybe a -> IO (Maybe b)` -- any tips?
17:14:09 <Zemyla> Can you define a pair of functions in a file as (func1, func2) = ...?
17:14:20 <vanila> yes
17:15:33 <Axman6> Zemyla: sure, but it would be kind of awkward if you're actually defining the functions to be anything more than something trivial
17:15:42 <qrpnxz> mseeks: Pattern match the function with Just x and after you process it return Just result (not with the result function if you know what I mean)
17:15:53 <Axman6> like (add,sub) = (map (+1),map (subtract 1))
17:16:14 <mseeks> I see
17:16:29 <mseeks> I was trying to find a way to do it using monad combinators or something
17:16:38 <Axman6> mseeks: well, you can start with foo Nothing = return Nothing.
17:16:47 <cite-reader> mseeks: Alternatively, monad transformers (in particular MaybeT, for this case) were pretty much made for problems with this shape.
17:17:06 <mseeks> yeah, I was hoping to do without monad transformers
17:17:10 <Axman6> depending on the problem that may be overkill though
17:17:16 <mseeks> if I only need Maybe and IO functionality it doesn't seem so necessary
17:17:17 <qrpnxz> Just pattern match.
17:17:22 <mseeks> cool, thanks
17:17:48 <mseeks> is there anything that "inverts" monads though? like Monad m1, m2 => m1 m2 a -> m2 m1 a?
17:17:57 <mseeks> can't find anything on hoogle
17:18:07 <heatsink> In general, no
17:18:36 <mseeks> yeah it looks like it exists only for specific outer monads
17:18:39 <ij> e.g. you can't get out of a IO monad
17:18:54 <mseeks> right, doesn't make sense for m1 = IO
17:18:54 <geekosaur> right, IO, ST, STM you could not implement that for
17:19:11 <heatsink> :t traverse
17:19:12 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
17:19:29 <Zemyla> :t \f -> maybe (return Nothing) (\a -> (f a) >>= (return . Just))
17:19:29 <lambdabot> Monad m => (a -> m a1) -> Maybe a -> m (Maybe a1)
17:19:45 <qrpnxz> > return Nothing
17:19:46 <lambdabot>  No instance for (GHC.Show.Show (m0 (Data.Maybe.Maybe a0)))
17:19:46 <lambdabot>    arising from a use of ‘M81838162371540040327194.show_M81838162371540040327...
17:19:46 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
17:19:48 <shachaf> :t Data.Distributive.distribute
17:19:48 <lambdabot> (Data.Distributive.Distributive g, Functor f) => f (g a) -> g (f a)
17:19:52 <Zemyla> @pl \f -> maybe (return Nothing) (\a -> (f a) >>= (return . Just))
17:19:52 <lambdabot> maybe (return Nothing) . flip flip (return . Just) . ((>>=) .)
17:20:18 <heatsink> :t sequence
17:20:19 <lambdabot> Monad m => [m a] -> m [a]
17:20:25 <qrpnxz> double flip is a double negative
17:20:47 <Zemyla> mseeks: Is that what you're looking for?
17:20:59 <Zemyla> :t flip flip
17:21:00 <lambdabot> b -> (a -> b -> c) -> a -> c
17:21:00 <heatsink> mseeks: Data.Traversable.sequence will do it, if the outer monad is container-like
17:21:20 <Zemyla> :t ((>>=) .)
17:21:20 <lambdabot> Monad m => (a -> m a1) -> a -> (a1 -> m b) -> m b
17:21:53 <Zemyla> :t flip flip (return . Just)
17:21:53 <lambdabot> Monad m => (a -> (a1 -> m (Maybe a1)) -> c) -> a -> c
17:21:54 <mseeks> Zemyla: yeah, that's what I had in mind -- i was wondering if it existed for m1, m2 as general monads
17:22:02 <mseeks> it makes sense that it does not though
17:22:16 <Zemyla> :t flip flip (return . Just) . ((>>=) .)
17:22:17 <lambdabot> Monad m => (a -> m a1) -> a -> m (Maybe a1)
17:22:52 <mseeks> hm I think that might be what I could use
17:23:15 <Zemyla> Use the pointfree version. :D
17:23:36 <qrpnxz> @pl flip flip (return . Just) . ((>>=) .)
17:23:36 <lambdabot> flip flip (return . Just) . ((>>=) .)
17:23:37 <hodapp> Wooo, it's good to see that the spirit of Dijkstra lives on in a Comp Sci professor at my university.
17:23:52 <mseeks> lol
17:23:56 <hodapp> though it doesn't help me when I want to ask "what did Dijkstra mean here?" in one of his memos where no reference is given.
17:24:12 <Zemyla> @unpl flip flip (return . Just) . ((>>=) .)
17:24:12 <lambdabot> (\ j f -> (j f) >>= \ m -> return ((Just) m))
17:24:30 <Zemyla> @unpl maybe (return Nothing) . flip flip (return . Just) . ((>>=) .)
17:24:31 <lambdabot> (\ j -> maybe (return Nothing) (\ f -> (j f) >>= \ p -> return ((Just) p)))
17:25:07 <hodapp> he is telling all incoming and prospective Comp Sci students that the ultimate aim is to get people *out* of the coding loop because, frankly, they just can't do it
17:25:29 <qrpnxz> ha
17:25:31 <EvanR> coding loop?
17:25:42 <qrpnxz> question?
17:25:54 <Zemyla> @djinn (Monad m) => (b -> c) -> (a -> m b) -> (a -> m c)
17:25:54 <lambdabot> -- f cannot be realized.
17:26:14 <hodapp> EvanR: 'loop' as in feedback loop. Have you heard "in the loop" as an expression?
17:26:27 <EvanR> in the know?
17:26:38 <qrpnxz> You must be a bot.
17:26:43 <hodapp> EvanR: that's a similar but kind of different sense.
17:26:48 <EvanR> like coding circle
17:26:53 <Zemyla> :t \f mf a = (mf a) >>= f
17:26:54 <lambdabot> parse error on input ‘=’
17:27:01 <Zemyla> :t \f mf a -> (mf a) >>= f
17:27:01 <lambdabot> Monad m => (a -> m b) -> (t -> m a) -> t -> m b
17:27:11 <qrpnxz> EvanR: Like every point within a certain radius.
17:27:13 <Zemyla> :t \f mf a -> (mf a) >>= (return . f)
17:27:14 <lambdabot> Monad m => (a -> b) -> (t -> m a) -> t -> m b
17:27:17 <heatsink> hodapp: You mean the write-debug loop?
17:27:35 <EvanR> must be a bot
17:28:09 <hodapp> heatsink: I don't know if it has a strict definition. Where I come from, it's just sort of engineering slang.
17:28:56 <heatsink> I have heard of "in the loop" to mean that one is kept informed on recent developments.
17:29:07 <EvanR> just trying to understand what his aim was, to discourage students from going to "coding" as a profession?
17:29:25 <qrpnxz> Afirmative.
17:29:52 <hodapp> heatsink: that's a different meaning, I'm fairly sure.
17:30:30 <heatsink> then idk wut u meen
17:30:56 <qrpnxz> OMG
17:34:01 <hodapp> EvanR: His research area is code generation from specifications.
17:34:09 <EvanR> ah
17:35:12 <vanila> hodapp, I'm interested in that - any pointers I could read up on?
17:35:42 <Zemyla> :t index
17:35:42 <lambdabot> Ix a => (a, a) -> a -> Int
17:35:56 <Zemyla> :t Data.Sequence.index
17:35:57 <lambdabot> Seq.Seq a -> Int -> a
17:37:28 <hodapp> vanila: Cryptol is one language he's a fan of.
17:37:41 <hodapp> vanila: also, Ivory, Atom, and Copilot all do basically this.
17:37:57 <hodapp> vanila: also, don't you use Coq? Coq can extract code from a spec.
17:38:18 <heatsink> vanila: A useful search term for this area is "program synthesis"
17:38:57 <qrpnxz> :t id
17:38:58 <lambdabot> a -> a
17:39:27 <qrpnxz> >id supercalifragilisticoespialidoso
17:39:34 <qrpnxz> > id supercalifragilisticoespialidoso
17:39:35 <lambdabot>  Not in scope: ‘supercalifragilisticoespialidoso’
17:40:03 <vanila> hm googling atom specification language isn't getting me there
17:40:12 <hodapp> vanila: check Hackage
17:40:22 <vanila> ah!
17:40:24 <qrpnxz> http://hackage.haskell.org/package/atom
17:40:29 <vanila> thanks lots to look into :)
17:40:41 <hexagoxel> Zemyla: and bind followed by return is fmap
17:41:05 <EvanR> > (>>= return)
17:41:06 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
17:41:06 <lambdabot>    arising from a use of ‘M64545548047898273647589.show_M64545548047898273647...
17:41:06 <lambdabot>  The type variable ‘b0’ is ambiguous
17:41:10 <EvanR> :t (>>= return)
17:41:11 <lambdabot> Monad m => m b -> m b
17:44:24 <hexagoxel> :t \a b -> a >>= return . b
17:44:25 <lambdabot> Monad m => m a -> (a -> b) -> m b
17:44:31 <hexagoxel> :t \a b -> fmap b a
17:44:31 <lambdabot> Functor f => f a -> (a -> b) -> f b
17:44:42 <hodapp> vanila: Atom docs unfortunately are a bit slim.
17:44:54 <hodapp> Cryptol is by far the best-documented.
17:45:21 <hexagoxel> or, applied:
17:45:22 <monochrom> if you work at Apple, you're in an infinite loop. in fact, you're at 1 Infinite Loop.
17:45:22 <vanila> yeah Cryptol is so great :)
17:45:31 <vanila> so happy when they made it free software
17:45:41 <hexagoxel> :exf (Monad m) => (b -> c) -> (a -> m b) -> (a -> m c)
17:45:41 <exferenceBot> \ b c d -> fmap b (c d)
17:45:51 <Zemyla> @djinn (Either a b, c) -> (Maybe (a, c), Maybe (b, c))
17:45:51 <lambdabot> f (a, b) =
17:45:51 <lambdabot>     case a of
17:45:51 <lambdabot>     Left c -> (Just (c, b), Nothing)
17:45:51 <lambdabot>     Right d -> (Nothing, Just (d, b))
17:51:39 <solatis> anyone here using nix for development ?
17:51:50 <johnw> I am
17:52:06 <bergmark> we are hopefully soon :-)
17:52:11 <solatis> any advice on how i can make nix use ghc HEAD instead of the default ghc ?
17:52:40 <benzrf> solatis: >>>#nixos
17:52:49 <johnw> yeah, let's discuss that there sola
17:52:51 <solatis> there's no one responding to my questions there... :)
17:53:18 <benzrf> hmmmm
17:53:28 <benzrf> @let data Ex = forall a. Ex a
17:53:30 <lambdabot>  Defined.
17:53:33 <benzrf> :t Ex
17:53:34 <lambdabot> a -> Ex
17:53:40 <benzrf> @let unEx (Ex v) = v
17:53:41 <lambdabot>  .L.hs:157:15:
17:53:41 <lambdabot>      Couldn't match expected type ‘t’ with actual type ‘a’
17:53:41 <lambdabot>        because type variable ‘a’ would escape its scope
17:53:44 <benzrf> aww
17:55:54 <Zemyla> :t uncurry $ either (curry $ (flip (,) Nothing) . Just) (curry $ ((,) Nothing) . Just)
17:55:55 <lambdabot> (Either a b1, b) -> (Maybe (a, b), Maybe (b1, b))
17:56:06 <benzrf> eekl
17:56:37 * benzrf considers
17:57:11 <benzrf> :t either (const Nothing) Just
17:57:12 <lambdabot> Either a a1 -> Maybe a1
17:57:15 <benzrf> :t left
17:57:16 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
17:57:28 <Zemyla> @let data ShowRead = forall a. (Show a, Read a) => ShowRead a
17:57:29 <lambdabot>  Defined.
17:57:55 <Zemyla> @let unShowRead (ShowRead a) = read (show a)
17:57:56 <lambdabot>  Defined.
17:58:06 <Zemyla> :t unShowRead
17:58:07 <lambdabot> Read a => ShowRead -> a
17:59:20 <Zemyla> @pl \f (a, b) = (f a, b)
17:59:20 <lambdabot> (line 1, column 11):
17:59:20 <lambdabot> unexpected "="
17:59:20 <lambdabot> expecting pattern or "->"
17:59:28 <Zemyla> @pl \f (a, b) -> (f a, b)
17:59:28 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
17:59:57 <Zemyla> @pl \(a, b) -> (Left a, b)
17:59:57 <lambdabot> first Left
18:00:06 <dibblego> @type (^? _Right)
18:00:06 <lambdabot> Either c b -> Maybe b
18:00:30 * hackagebot markup 0.0.6 - Abstraction for markup languages  http://hackage.haskell.org/package/markup-0.0.6 (athanclark)
18:00:37 <Zemyla> :t reads
18:00:38 <lambdabot> Read a => ReadS a
18:00:57 <Zemyla> :t reads ""
18:00:58 <lambdabot> Read a => [(a, String)]
18:01:08 <dibblego> @type (%~) _1
18:01:09 <lambdabot> Field1 s t a b => (a -> b) -> s -> t
18:03:13 <Zemyla> :t \s -> (fmap (first Left) $ reads s) ++ (fmap (first Right) $ reads s)
18:03:14 <lambdabot> (Read a, Read b) => String -> [(Either a b, String)]
18:03:36 <EvanR> mad science
18:03:43 <Zemyla> @pl \s -> (fmap (first Left) $ reads s) ++ (fmap (first Right) $ reads s)
18:03:44 <lambdabot> ap ((++) . fmap (first Left) . reads) (fmap (first Right) . reads)
18:06:40 <Zemyla> :t fst . head . (filter (null . snd)) . (ap ((++) . fmap (first Left) . reads) (fmap (first Right) . reads))
18:06:40 <lambdabot> (Read a, Read b) => String -> Either a b
18:09:19 <Zemyla> :t \s -> [fmap (first Left) . reads, fmap (first Right) . reads] >>= ($ s)
18:09:20 <lambdabot> (Read a, Read b) => String -> [(Either a b, String)]
18:09:37 <Zemyla> @pl \s -> [fmap (first Left) . reads, fmap (first Right) . reads] >>= ($ s)
18:09:37 <lambdabot> ([fmap (first Left) . reads, fmap (first Right) . reads] >>=) . flip id
18:10:29 <Zemyla> :t flip id
18:10:30 <lambdabot> b -> (b -> c) -> c
18:10:31 * hackagebot markup 0.0.6.1 - Abstraction for markup languages  http://hackage.haskell.org/package/markup-0.0.6.1 (athanclark)
18:12:29 <Zemyla> :t foldl False $ const $ const True
18:12:29 <lambdabot>     Couldn't match expected type ‘(b -> b1 -> Bool)
18:12:29 <lambdabot>                                   -> a -> b -> b1 -> Bool’
18:12:29 <lambdabot>                 with actual type ‘Bool’
18:12:47 <Zemyla> :t foldl (const $ const True) False
18:12:48 <lambdabot> [a] -> Bool
18:14:18 <pavonia> > map (foldl (const $ const True) False) ["", "a", "abc"]
18:14:20 <lambdabot>  [False,True,True]
18:15:14 <johnw> > map (not . null) ["", "a", "abc"]
18:15:15 <lambdabot>  [False,True,True]
18:20:31 * hackagebot llvm-pretty-bc-parser 0.1.3.1 - LLVM bitcode parsing library  http://hackage.haskell.org/package/llvm-pretty-bc-parser-0.1.3.1 (TrevorElliott)
18:23:34 <tac> > (map not . map null) ["", "a", "abc"]
18:23:35 <lambdabot>  [False,True,True]
18:23:39 <tac> > (map not . map id .map null) ["", "a", "abc"]
18:23:41 <lambdabot>  [False,True,True]
18:28:00 <Zemyla> > foldl (flip (flip (ap . (flip . (maybe . Just))) const)) Nothing [1..10]
18:28:02 <lambdabot>  Just 1
18:28:09 <Zemyla> > foldl (flip (flip (ap . (flip . (maybe . Just))) const)) Nothing []
18:28:11 <lambdabot>  Nothing
18:28:34 <Zemyla> So foldl (flip (flip (ap . (flip . (maybe . Just))) const)) Nothing is safeHead. :P
18:29:27 <mgsloan> Hmm, does anyone know why async has both link and link2, but no direct way of saying "I want exceptions from async x rethrown in async y"?
18:29:54 <Zemyla> @pl \a b -> maybe (Just b) (const a) a
18:29:54 <lambdabot> flip =<< flip (maybe . Just) . const
18:30:25 <mgsloan> Looks like I can write something like that by copy modifying the code for link2, and the "forkRepeat" helper, but this seems ugly.  I'm wondering if this was a consicous decision on simonm's part because maybe the function is ill advised for some reason?
18:30:31 <mgsloan> Or maybe it's just an arbitrary omission
18:32:05 <johnw> maybe no one has really needed to do that
18:32:08 <johnw> what's the use case?
18:33:11 <mgsloan> Hey johnw! :)  The use case is that all of the child threads of a process should be killed when the main thread is killed.  However, I'm expecting some child threads to receive async exceptions
18:33:29 <mgsloan> So, rather than link2 which will bring down the main thread (and everything else), I need a unidirectional variant
18:33:32 <mgsloan> seems quite handy
18:33:46 <mgsloan> "link" is almost it, but that would need to be called from within the main thread
18:34:12 <Zemyla> @hoogle if'
18:34:14 <lambdabot> No results found
18:37:04 <mgsloan> Ah, looks like there's already an issue about it: https://github.com/simonmar/async/issues/7
18:37:10 <mgsloan> With essentially the same usecase
18:40:05 <johnw> well, good to know you're not crazy than :-)
18:41:49 <solatis> jle`: gmrbl, i'm still battling with my last fight in the more generic error handling you suggested last night: ResourceT
18:41:59 <solatis> MonadIO and MonadError String are working perfectly
18:42:15 <solatis> but what is the equivalent for ResourceT ?
18:42:33 <johnw> solatis: can you give a little bit more context?
18:43:10 <Zemyla> :t ((head . (++[Nothing])) . (map Just))
18:43:10 <solatis> johnw: jle` was helping me refactor some code to get rid of a lot of code bloat (as in, multiple monad layers upon monad layers)
18:43:10 <lambdabot> [a] -> Maybe a
18:43:35 <johnw> solatis: ResourceT comes with its own complexities
18:43:41 <solatis> yeah true
18:43:42 <johnw> so watch out for specious simplicity
18:43:43 <solatis> anyway
18:43:43 <karshan> Hello, I was wondering if there was a way of accessing functions defined within a where block of another function from ghci. Does anyone know of a way to do this ?
18:43:45 <Zemyla> There, that works better for infinite lists.
18:43:50 <solatis> instead of having this return type:
18:43:53 <solatis> ExceptT String (ResourceT IO) [NS.Socket]
18:44:00 <solatis> i rather have m [NS.Socket]
18:44:20 <solatis> (it makes things more clear)
18:44:30 <solatis> now, MonadIO and MonadError are working perfectly
18:44:51 <solatis> but i'm trying to figure out the equivalent of ResourceT
18:45:02 <johnw> MonadResource
18:45:08 <johnw> if you must
18:45:45 <solatis> hmmm
18:45:46 <solatis> wait
18:45:48 <vanila> newtype S a = S { unS :: ExceptT String (ResourceT IO) [a] }
18:46:20 <ruuns> Hi :) Does anyone know, if GHC has a flag for disabling the implicit creation of record accessor functions (access would be only possible then through pattern matching and maybe with necessary type annotations)
18:46:46 <johnw> the only real reason to use ResourceT instead of just bracket (if you're already in IO) is that you are passing around some kind of continuation value so that you don't know the actual lifetime of the resource
18:47:09 <solatis> johnw: http://lpaste.net/117881#line75
18:47:16 <solatis> that's where i get an error
18:47:45 <solatis> johnw: well, i'm using sockets, and I want my *library* to handle the closing of the sockets, instead of relying upon some client to run my code in a bracket
18:48:01 <johnw> don't lift
18:48:03 <solatis> or to rephrase it: i want to write the code where i close the socket, next to the code where i create the socket
18:48:09 <mgsloan> johnw: Hmm, not sure about that.  You get finer grained control of the lifetime as well.  It's also very handy to be able to fork threads within ResourceT, although you need to use https://hackage.haskell.org/package/resourcet-1.1.3.3/docs/Control-Monad-Trans-Resource.html#v:resourceForkIO
18:48:12 <johnw> you'll have to liftResourceT
18:48:41 <johnw> you're in m, so what is "lift" supposed to do?
18:48:45 <johnw> that's for use with monad transformers
18:48:49 <mgsloan> I've got a theory that for some code ResourceT may be faster than bracket due to not using try / catch, which could impact optimization.  Haven't tried to measure it yet though :)
18:48:54 <hexagonest> hey guys I have a question.
18:49:03 <solatis> ah!!
18:49:06 <solatis> johnw: thanks a bunch
18:49:15 <johnw> do try/catch have a cost if no exception occurs?
18:49:16 <solatis> yeah sorry, jle` was holding my hand yesterday through this
18:49:25 <solatis> i'm over my head :)
18:49:31 <vanila> you can just newtype your stack
18:49:38 <hexagoxel> woah, common 6 char prefix
18:49:54 <hexagonest> So for pattern matching with lists, I don't get what the tutuorial means by x:xs in a pattern. Is it like [x | x:xs -> [1,2,3,4]] isn't it supposed to return [1] ?
18:49:58 <mgsloan> johnw: I believe so, but I'm not sure.  I know that in Java try/catch is quite expensive
18:50:00 <hexagonest> haha hexagoxel nice
18:50:08 <johnw> in C++ it's no t at all
18:50:09 <solatis> johnw: in my c++ experience, try/catch *have* a cost if you use it at one place in your code
18:50:27 <johnw> try/catch are supposed to be zero cost if there is no exception
18:50:30 <hexagonest> if not how would I return the head of a list using comprehension?
18:50:32 <mgsloan> So, having just the one try catch in the runResourceT, instead of one per bracket, could have a real benefit
18:50:46 <solatis> johnw: around every function, there needs to be additional code for propagating exceptions
18:50:48 <johnw> mgsloan: benchmark it, then tell me :)
18:50:49 <mgsloan> johnw: Cool, I hope so!  Remains to be measured :)
18:51:04 <johnw> solatis: so?  that code doesn't need to execute
18:51:17 <hexagoxel> karshan: but the arguments of the top-level function are in the scope of the where-clause; what would there value be if you accessed it from "outside"?
18:51:23 <ruuns> there's additional code size, but performance is zero when nothing is thrown.
18:51:31 <hexagonest> could someone help me please
18:51:46 <solatis> johnw: there is no *time* overhead, but your L1 cache gets filled with code that doesn't need to be executed
18:51:51 <glguy> hexagonest: Generally you wouldn't use a list comprehension to take the head of a list, but if you were set on doing so you'd write:
18:51:52 <solatis> thus, there is significant code bloat overhead
18:51:54 <johnw> C++ generates that code, and put it into a special function which the exception handling code knows the address of thanks to data kept in an ELF section.  But it's never executed unless there's an exception
18:52:11 <johnw> the cleanup function doesn't need to be kept in the same place as the scope it relates to
18:52:19 <solatis> that's why most embedded systems compile with gcc -fno-except
18:52:19 <hexagonest> thanks glguy it's just because i'm doing a tutorial and i'm learning pattern matching in comprehension
18:52:20 <glguy> something like: [x | x:_ <- [ ys ]]
18:52:20 <johnw> these are all compiler decisions
18:52:29 <hexagonest> what is ys?
18:52:42 <hexagoxel> ruuns: and what part of records _do_ you want to use?
18:52:45 <glguy> the thing you were taking the first element of
18:52:48 <solatis> johnw: http://stackoverflow.com/a/691306/1764661
18:52:52 <solatis> sums it up pretty nicely
18:52:55 <johnw> what I'm saying is, we're making guesses about operational decisions
18:53:09 <vanila> C++ is a different language though
18:53:20 <johnw> the way GHC does it could change with each version
18:53:28 <johnw> nothing in the denotational semantics requires a cost
18:53:33 <hexagonest> glguy: so do I need to have a list inside a list? like
18:53:42 <hexagonest> [x | x:_ <- [ [1,2,3] ]]
18:53:45 <solatis> oh yes, i'm not talking about ghc here
18:53:51 <solatis> i'm talking about gcc
18:54:09 <solatis> i wouldn't be surprised if there was no overhead in ghc
18:54:11 <vanila>  i thought you were struggling with some monad stack stuff
18:54:15 * johnw realizes mgsloan just trolled us :)
18:54:24 <solatis> vanila: i am! :)
18:54:34 <mgsloan> Hahaha, not intentionally!
18:54:45 <vanila> well what about newtyping the stack instead of all the typeclass stuff?
18:54:49 <vanila> I showed above how you'd do that
18:55:17 <mgsloan> I don't think try catch ought to be inherently costly, but it seems reasonable that it might impede optimization
18:55:28 <solatis> vanila: yeah i'm going to try that approach too
18:55:50 <johnw> the typeclass stuff is useful when writing a library, where the functions might be used at any point within the users transformer stack;  but they are mostly noise if you're writing an application, in which case the new type approach given by vanila is much better
18:55:56 <glguy> hexagonest: You would if you were trying to use list comprehensions like this
18:56:34 <hexagonest> glguy: Thanks mate. I'm just doing this http://learnyouahaskell.com/syntax-in-functions tutorial and they mention x:xs is a popular pattern in recursive functions and i didn't get it
18:57:12 <glguy> ?src foldr
18:57:12 <lambdabot> foldr f z []     = z
18:57:12 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:57:22 <glguy> hexagonest: That's what they're talking about, not list comprehensions
19:01:22 <hexagonest> glguy: oh ok
19:03:17 <hexagonest> Woah! I get it. x:y is sugar for [x,y] so you can pattern match head' (x:_) = x to return first item of the list
19:03:53 <Axman6> no, it's not sugar for [x,y], it's actually unsugar for a list with at least one element
19:04:33 <Axman6> a:b matches [1,2,3], [1] etc, but not []. in those two cases, a is 1 in both, and [2,3] or [] respectively
19:04:41 <Axman6> @src []
19:04:41 <lambdabot> data [] a = [] | a : [a]
19:05:02 <Clint> Axman6: you missed some words
19:05:29 <Axman6> remember, a list is either the [] constructor, or the (:) constructor with an a and a list of a's
19:05:37 <Axman6> Clint: I don't think I did?
19:05:44 <Clint> Axman6: "b is", perhaps
19:05:51 <Axman6> oh, yes
19:06:38 <Axman6> > [(a,b) | (a:b) <- [[],[1],[1,2],[1,2,3]] ]
19:06:40 <lambdabot>  [(1,[]),(1,[2]),(1,[2,3])]
19:07:07 <Zemyla> Hmm, I think I've come up with a pointfree safe head function.
19:07:22 <johnw> [x,y] is sugar for x:y:[]
19:07:45 <Axman6> yes, that's also worth pointing out
19:10:20 <fread2282> is OTT just saying "for each type, let's introduce a more powerful equality type, and give all there equality types the same type for ease of use" ?
19:11:37 <tac> Something kinda like that
19:11:49 <tac> From what I remember, I believe it gives each type constructor its own notion of equatliy
19:12:47 <tac> This is different from Agda or HoTT, where you just have one singular notion of equality for all types
19:16:03 <fread2282> well, if we're going to give types their own equality types, why don't we also let types provide their own unification?
19:16:38 <lwm> hey, if anyone is bored, can they take a look at my code: lpaste.net/117882
19:17:00 <vanila> which paper are you looking at fread2282?
19:17:25 <fread2282> vanila: http://strictlypositive.org/ott.pdf
19:17:35 <lwm> it is a library. It does some DB reads. I just want to know if I can seperate the IO action from functions like 'form', because they don't a DB read or anything
19:17:51 <Zemyla> Is head (a++b) noticeably slower than head a?
19:18:06 <vanila> do you see Observational Equality, Now! also? Which is a bit newer and covers an agda formalism
19:18:38 <fread2282> because then we can e.g. pretend (or use klee if we really want) that gmp integers are a ring and have them work as one
19:18:40 <fread2282> vanila: yep
19:18:41 <qrpnxz> lwm: Ain't nobody got type for that.
19:19:06 <glguy> Using GHC.Generics to generate Traversable instances that without any runtime overhead from using generics: http://www.galois.com/~emertens/generic-traverse/Data-Traversable-Generic.html
19:19:06 <heatsink> Zemyla: they are both constant time operations
19:19:12 <vanila> you can actually build quotients types in this theory, for example squashing pairs of ints (x,y) with a relation to get fractions
19:19:37 <lwm> qrpnxz: haha, it's a long shot ... but I need to ask Haskell people this stuff. Is there somewhere I can trap a Haskeller and make the answer all my questions?
19:19:41 <Axman6> lwm: I'm not sure that form is really a necessary function to define; any haskeller worth their salt will write versions of it themselves for their own needs, since IO and list are such common types
19:20:04 <qrpnxz> ^
19:20:06 <Axman6> lwm: #haskell is where haskellers trap you to make you ask them questions
19:20:16 <qrpnxz> lol
19:20:38 <Zemyla> lwm: Well, I heard that the favorite food of Haskellers is burritos, because they remind them of monads. You might want to bait your trap with those.
19:21:02 <qrpnxz> LMAO
19:21:39 <Axman6> lwm: also, the type annotation in [v :: Infinitive] is unnecessary given the type of the function already guarantees that v is an Infinitive
19:23:22 <Axman6> lwm: and, you might want to co0nsider using Text instead of String where possible
19:24:23 <fread2282> 2 things bug me about existing type theories: 1. they make some encapsulation impossible in that the unifier will expand unexported things to prove stuff (that you might want to make impossible to prove), and 2. there is no way to use foreign data (e.g. gmp) in proofs
19:24:34 <Zemyla> :t ap (fmap . flip (,) . tail) (head . (++ [Nothing]) . map Just)
19:24:35 <lambdabot> [a] -> Maybe (a, [a])
19:24:56 <Zemyla> @let safeHeadTail = ap (fmap . flip (,) . tail) (head . (++ [Nothing]) . map Just)
19:24:58 <lambdabot>  Defined.
19:25:26 <lwm> Axman6: ok, 'form' function point makes sense.
19:25:46 <lwm> Axman6: I read this stackoverflow.com/questions/19608745/data-text-vs-string, and decided to use String
19:25:55 <Axman6> :t foldr (\x _ -> Just x) Nothing
19:25:56 <lambdabot> [a] -> Maybe a
19:26:08 <Axman6> @pl \x _ -> Just x
19:26:08 <lambdabot> const . Just
19:26:21 <Axman6> :t foldr (const . Just) Nothing
19:26:22 <lambdabot> [a] -> Maybe a
19:26:39 <Zemyla> > foldr (const . Just) Nothing [1..10]
19:26:40 <lambdabot>  Just 1
19:28:38 <lwm> also, thanks for the tips :)
19:29:29 <Zemyla> :t ap (fmap . flip (,) . tail) (foldr (const . Just) Nothing)
19:29:30 <lambdabot> [a] -> Maybe (a, [a])
19:29:49 <Axman6> Zemyla: remember that foldr is essentially the list equivalent of the maybe function for Maybe, and either for Either
19:29:53 <Axman6> :t maybe
19:29:53 <lambdabot> b -> (a -> b) -> Maybe a -> b
19:29:54 <Axman6> :t either
19:29:55 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
19:31:02 <Zemyla> I tried several different foldrs, and they all choked on infinite lists.
19:31:20 <Axman6> foldr should be fine with infinite lists. foldl not so much
19:31:33 <heatsink> > foldr const 0 $ repeat 1
19:31:34 <lambdabot>  1
19:31:44 <vanila> > foldr (\x ys -> x : ys) [] [1..]
19:31:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
19:31:47 <Axman6> depending on how you use it anyway (if you're lazy in the second argument of the function given to foldr then it should be fine)
19:31:53 <vanila> > foldr (\x ys -> head (show x) : ys) [] [1..]
19:31:54 <lambdabot>  "123456789111111111122222222223333333333444444444455555555556666666666777777...
19:32:21 <platz> Axman6: are those all examples of Boehm-Berarducci encodings?
19:32:53 <Axman6> ... possibly. they have a name, but I can't remember what it is =)
19:33:12 <vanila> they are folds or eliminators
19:33:53 <tac> Axman6: It's too bad Haskell can't distinguish infinite lists from finite ones in its type system :~P
19:34:19 <platz> in the case of lists it seems it seems the Church encoding and the Boehm-Berarducci encoding are identical
19:34:23 <Zemyla> tac: Data.Sequence is necessarily finite.
19:34:38 <Axman6> Zemyla: well, not really
19:34:53 <Axman6> > Data.Seq.fromList [1..]
19:34:54 <lambdabot>  Not in scope: ‘Data.Seq.fromList’
19:34:57 <Axman6> bleh
19:35:08 <Zemyla> Also, can you get tail f with a fold?
19:35:38 <Axman6> > foldr (\_ t -> t) [] [1..10] -- Maybe?
19:35:40 <lambdabot>  []
19:36:00 <fread2282> my plan for my toy language is that types provide their own unifiers, but it's kinda strange when types get to choose if they're ITT or ETT (if their unifier is decidable or not)
19:36:13 <Axman6> "probably" but I'm too sleepy to figure it out right now
19:36:43 <vanila> what do you mean unifier?
19:37:04 <vanila> I mean isn't that a derived notion?
19:38:46 <fread2282> vanila: the thing that gets to run to see if two types are definitionally equal
19:39:30 <vanila> oh okay, sounds interesting!
19:41:29 <fread2282> vanila: so I guess it could be considered to be derived from the equality relation, but I think that that would be a rather roundabout way to make it overrideable
19:44:04 <Zemyla> :t foldr (flip const)
19:44:05 <lambdabot> b -> [a] -> b
19:44:09 <Zemyla> :t foldr (flip const) []
19:44:10 <lambdabot> [a] -> [t]
19:44:59 <Axman6> well, that type tells us that that definitely cannot contain anything from the input list
19:48:11 <alv-r-> can anyone tell me why this doesn't work?
19:48:27 <alv-r-> digits :: Int -> [Int]
19:48:32 <alv-r-> digits = map read . show
19:48:48 <exio4> @type show
19:48:49 <lambdabot> Show a => a -> String
19:48:58 <Axman6> because read takes Strings, not Chars, and aString is a list of Chars
19:49:21 <alv-r-> but that's exactly what I want
19:49:41 <alv-r-> my intention is something like: digits 123 = [1, 2, 3]
19:50:17 <alv-r-> aw, ok
19:50:28 <alv-r-> Axman6: was thinking about the show, srry
19:50:50 <EvanR> > map (read . show) . show :: [Int]
19:50:51 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Int]’
19:50:52 <lambdabot>              with actual type ‘a0 -> [b0]’
19:50:52 <Zemyla> :t map (read . (:[])) . show
19:50:53 <fread2282> > (map read . return . show) 123
19:50:53 <lambdabot> (Show a, Read b) => a -> [b]
19:50:54 <lambdabot>  [*Exception: Prelude.read: no parse
19:51:18 <fread2282> > (map (read . return) . show) 123
19:51:19 <lambdabot>  [*Exception: Prelude.read: no parse
19:51:33 <EvanR> > map ord . show :: [Int]
19:51:34 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Int]’
19:51:35 <lambdabot>              with actual type ‘a0 -> [GHC.Types.Int]’
19:51:46 <EvanR> :t map ord . show
19:51:46 <lambdabot> Show a => a -> [Int]
19:52:17 <fread2282> > (map (read . return) . show) 123 :: [Int]
19:52:19 <lambdabot>  [1,2,3]
19:52:24 <Zemyla> > (map (fromInteger . read . return) . show) 123
19:52:25 <lambdabot>  [1,2,3]
19:52:50 <fread2282> alv-r-: digits = map (read . return) . show
19:53:04 <EvanR> > (map (fromInteger . read . return) . show) 0x123
19:53:05 <fread2282> alv-r-: return turns a into [a]
19:53:05 <lambdabot>  [2,9,1]
19:53:44 <alv-r-> nice, didnt know about that, was doing map (\x -> read [x]) now haha
19:53:45 <alv-r-> thanks
19:53:52 <Welkin> :t (map (fromInteger . read . return) . show) 123
19:53:53 <lambdabot> Num b => [b]
19:53:56 <Axman6> > alv-r- that's essentially the same thing
19:53:57 <lambdabot>  Not in scope: ‘alv’
19:53:57 <lambdabot>  Perhaps you meant one of these:
19:53:57 <lambdabot>    ‘all’ (imported from Data.List),
19:54:05 <EvanR> > (:[]) 3
19:54:05 <Axman6> return for lsits is return x = [x]
19:54:06 <lambdabot>  [3]
19:54:08 <Axman6> lists*
19:54:26 <Welkin> :t return
19:54:27 <lambdabot> Monad m => a -> m a
19:54:32 <Welkin> it isn't just for lists
19:54:37 <Zemyla> :t map (fromInteger . read . return) . show
19:54:37 <lambdabot> (Show a, Num b) => a -> [b]
19:54:56 <Axman6> fromInteger shouldn't be necessary there
19:55:12 <Axman6> unless you need a list of any Num type
19:55:15 <Zemyla> :t map (fromInteger . read . return) . show . abs
19:55:15 <lambdabot> (Show b1, Num b1, Num b) => b1 -> [b]
19:55:44 <alv-r-> > (map  (read . return) . show) 123
19:55:45 <lambdabot>  [*Exception: Prelude.read: no parse
19:56:17 <Axman6> you need to specify the return type in that case, because it will be defaulting to the () instalce of read
19:56:23 <Axman6> > read "()"
19:56:24 <lambdabot>  ()
19:56:27 <Axman6> > read "1"
19:56:28 <lambdabot>  *Exception: Prelude.read: no parse
19:56:32 <Axman6> > read "1" :: Int
19:56:33 <lambdabot>  1
19:56:36 <Zemyla> :t map (fromInteger . read . return) . (takeWhile isDigit) . show . abs
19:56:36 <lambdabot> (Show b1, Num b1, Num b) => b1 -> [b]
19:57:02 <Zemyla> :t map (fromInteger . read . return) . (takeWhile isDigit) . show . abs $ 291.5
19:57:03 <lambdabot> Num b => [b]
19:57:12 <Zemyla> > map (fromInteger . read . return) . (takeWhile isDigit) . show . abs $ 291.5
19:57:13 <lambdabot>  [2,9,1]
19:59:41 <EvanR> for an actual mutable 2d array, is IOUArray (Int,Int) or IOVector better
19:59:43 <EvanR> or neither
20:00:29 <Zemyla> :t unfoldr (\b -> if b == 0 then Nothing else Just $ swap $ divMod b 10)
20:00:29 <lambdabot> Integral a => a -> [a]
20:01:13 <Zemyla> > unfoldr (\b -> if b == 0 then Nothing else Just $ swap $ divMod b 10) 291
20:01:14 <lambdabot>  [1,9,2]
20:01:40 <Zemyla> > (reverse .) $ unfoldr (\b -> if b == 0 then Nothing else Just $ swap $ divMod b 10) 291
20:01:41 <lambdabot>  Couldn't match expected type ‘a -> [a1]’ with actual type ‘[a0]’
20:02:04 <Zemyla> > (reverse . unfoldr (\b -> if b == 0 then Nothing else Just $ swap $ divMod b 10)) 291
20:02:05 <lambdabot>  [2,9,1]
20:02:58 <Zemyla> That way, you don't have to futz with show and read.
20:04:15 <Zemyla> @pl \b -> if b == 0 then Nothing else Just $ swap $ divMod b 10
20:04:15 <lambdabot> ap (flip if' Nothing . (0 ==)) (Just . swap . flip divMod 10)
20:04:41 <Zemyla> @pl \b -> if b /= 0 then Just $ swap $ divMod b 10 else Nothing
20:04:41 <lambdabot> flip (liftM2 if' (0 /=) (Just . swap . flip divMod 10)) Nothing
20:05:10 <Zemyla> @src if'
20:05:11 <lambdabot> Source not found.
20:05:54 <fread2282> Zemyla: if' a b c = if a then b else c
20:06:51 <bananagram> for making an IRC bot, is ircbot the recommended library?
20:07:01 <bananagram> I heard "irc" wasn't the most stable
20:07:33 <tac> bananagram: I use simpleirc
20:07:43 <tac> it does what I need it to and it's super easy to get up and going
20:07:50 <Zemyla> @pl \b -> foldr (const . Just) Nothing $ replicate b (swap $ divMod b 10)
20:07:50 <lambdabot> foldr (const . Just) Nothing . ap replicate (swap . flip divMod 10)
20:07:51 <bananagram> I'm reading about that too
20:09:40 <Zemyla> > (reverse . unfoldr (foldr (const . Just) Nothing . ap replicate (swap . flip divMod 10))) 291
20:09:41 <lambdabot>  [2,9,1]
20:10:12 <Zemyla> :t (f $!)
20:10:13 <lambdabot> (FromExpr b, Show a) => a -> b
20:10:24 <Zemyla> :t ($!_
20:10:25 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
20:10:29 <Zemyla> :t ($!)
20:10:30 <lambdabot> (a -> b) -> a -> b
20:10:40 <Zemyla> @src FromExpr
20:10:40 <lambdabot> Source not found. Take a stress pill and think things over.
20:11:42 <jle`> :t \f -> (f $!)   -- Zemyla ?
20:11:42 <lambdabot> (a -> b) -> a -> b
20:25:36 * hackagebot MuCheck 0.3.0.0 - Automated Mutation Testing  http://hackage.haskell.org/package/MuCheck-0.3.0.0 (RahulGopinath)
20:30:36 * hackagebot MuCheck-QuickCheck 0.3.0.0 - Automated Mutation Testing for QuickCheck tests  http://hackage.haskell.org/package/MuCheck-QuickCheck-0.3.0.0 (RahulGopinath)
20:30:38 * hackagebot MuCheck-Hspec 0.3.0.0 - Automated Mutation Testing for Hspec tests  http://hackage.haskell.org/package/MuCheck-Hspec-0.3.0.0 (RahulGopinath)
20:30:40 * hackagebot MuCheck-HUnit 0.3.0.0 - Automated Mutation Testing for HUnit tests  http://hackage.haskell.org/package/MuCheck-HUnit-0.3.0.0 (RahulGopinath)
20:30:42 * hackagebot MuCheck-SmallCheck 0.3.0.0 - Automated Mutation Testing for SmallCheck tests  http://hackage.haskell.org/package/MuCheck-SmallCheck-0.3.0.0 (RahulGopinath)
20:30:44 * hackagebot DMuCheck 0.3.0.0 - Distributed Mutation Analysis framework for MuCheck  http://hackage.haskell.org/package/DMuCheck-0.3.0.0 (RahulGopinath)
20:38:12 <lispy> is automated mutation testing the same as fuzzing?
20:39:01 <lispy> oooh...and they are osu folks
20:39:18 <lispy> I wonder if they is loosely based on the work Tim Budd did
20:40:24 <lispy> It's a shame it's GPL :/
20:40:42 <Welkin> why?
20:40:49 <vanila> you could contact the author and buy a different liscense off him
20:41:16 <EvanR> GPL is communism of course
20:41:22 <mgsloan> lispy: Nah, the idea is that if you randomly change your program, but the tests still pass, then the tests aren't good enough
20:41:51 <lispy> Is the haskell wiki down?
20:42:11 <EvanR> having to repair tests after every code change is annoying
20:42:14 <lispy> mgsloan: yeah, I think Tim Budd did the original work on that idea
20:42:26 <EvanR> when its the test which is now wrong, not the program
20:42:38 <EvanR> deadweight
20:43:01 <lispy> Welkin: I was trying to find an existing article on why not GPL for haskell, but the wiki is not loading for me
20:43:24 <Welkin> haskell.org is slow lately
20:43:28 <mgsloan> lispy: Gotcha, cool!  I really like the idea of mixing automated program modification with testing
20:43:56 <mgsloan> like you can imagine inserting threadDelays or strategic blocking bits so that timings can be manipulated externally
20:44:10 <Welkin> yes, GPL is possibly problematic for commercial purposes
20:44:25 <Welkin> SaaS usually gets around this
20:44:28 <Welkin> unless it is GPL 3
20:44:31 <vanila> GPL is good if you support freedom
20:44:40 <lispy> Welkin: for me the main reason is that it's a lot easier to convince work to use BSD stuff but GPL is a harder sell (not impossible, but not an automatic "sure")
20:45:30 <lispy> For Haskell generally there seems to be debate around the linking clauses
20:46:04 <lispy> GHC does optimizations across module boundaries and the phrasing in the GPL around this hasn't been tested in courts
20:46:13 <jonsterling> @tell fread2282 / I have a few ideas on how to fix that aspect of type theory... (in particular, providing equational theories to external code like gmp etc)
20:46:13 <lambdabot> Consider it noted.
20:50:37 * hackagebot influxdb 0.9.0.1 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.9.0.1 (MitsutoshiAoe)
20:51:34 <Zemyla> :t (ap ((.) . flip (.)) . (.)) compare
20:51:35 <lambdabot> Ord b => (a -> b) -> a -> a -> Ordering
20:51:38 <EvanR> src/Numeric/Half.hs:2:14: Unsupported extension: PatternSynonyms :(
20:51:43 <Zemyla> :t comparing
20:51:43 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
20:51:50 <EvanR> Failed to install fixed-0.2.1
20:52:16 <Welkin> @unpl (ap ((.) . flip (.)) . (.)) compare
20:52:16 <lambdabot> (\ d -> return ((\ x b c i -> b c (x i)) d ((\ k l -> compare (k l)) d)) d)
20:52:51 <Welkin> how does it decide what to use for variable names?
20:53:07 <Welkin> b c d x i k l?
20:53:28 <Welkin> @unpl (ap ((.) . flip (.)) . (.)) compare
20:53:28 <lambdabot> (\ d -> return ((\ x b c i -> b c (x i)) d ((\ k l -> compare (k l)) d)) d)
20:53:34 <Welkin> it's the same
20:54:04 <Zemyla> Why doesn't unpl immediately apply would-be partial lambdas?
20:55:09 <Zemyla> (\x b c i -> b c (x i)) d = \b c i -> b c (d i), for instance.
20:56:32 <Zemyla> (\k l -> compare (k l)) d =
20:56:47 <Zemyla> (\k l -> compare (k l)) d = \l -> compare (d l).
20:58:23 <Zemyla> :t \g -> ((\f x -> f x) (return g))
20:58:24 <lambdabot> a -> t -> a
21:01:03 <Zemyla> :t return . extract
21:01:04 <lambdabot> Not in scope: ‘extract’
21:01:18 <Zemyla> :t return . Control.Comonad.extract
21:01:19 <lambdabot> (Control.Comonad.Comonad w, Monad m) => w b -> m b
21:01:58 <Zemyla> :t join . Control.Comonad.duplicate
21:01:59 <lambdabot> (Control.Comonad.Comonad m, Monad m) => m a -> m a
21:03:10 <Zemyla> :t (join . Control.Comonad.duplicate) [1..5]
21:03:11 <lambdabot>     Could not deduce (Control.Comonad.Comonad [])
21:03:11 <lambdabot>       arising from a use of ‘Control.Comonad.duplicate’
21:03:11 <lambdabot>     from the context (Num a, Enum a)
21:04:38 <rofer> Something really weird is happening. My script generates a list which is equal to [100..199] then takes the product and gets 0
21:05:07 <vanila> > product [100..199] :: Int
21:05:08 <lambdabot>  0
21:05:14 <vanila> I think it wraps around and hits 0
21:05:15 <rofer> If I compare the list it generates to [100..199] it says they're equal, however if I take the product of [100..199] in my script it gets the right number
21:05:19 <vanila> > product [100..199] :: Integer
21:05:20 <lambdabot>  4225275093462314747919078546927702282720683361006230982780207366192864310798...
21:05:43 <Zemyla> pl has no clue how to handle triples.
21:05:44 <vanila> > 300 :: Word8
21:05:46 <lambdabot>  44
21:05:48 <vanila> > 300 :: Integer
21:05:49 <lambdabot>  300
21:05:50 <vanila> its similar to this
21:05:54 <vanila> does that help explain whats going on?
21:06:54 <EvanR> (seems like this should be some sort of syntax error but it would only manifest itself after type checking)
21:07:25 <bananagram> is IOError a member of Show?
21:07:32 <Zemyla> rofer: It's always 0 because there's 50 multiples of 2, 25 of which are multiples of 4, and so it's x * 2^75, whose 64 lowest bits are always 0.
21:07:49 <Zemyla> @src IOError
21:07:49 <lambdabot> Source not found. Just try something else.
21:08:12 <rofer> I was confused because if I just hardcode [100..199] into it I was getting 0
21:08:58 <Axman6> > scanl (*) 1 [100..199]
21:08:59 <lambdabot>  [1,100,10100,1030200,106110600,11035502400,1158727752000,122825141712000,131...
21:09:10 <Axman6> > drop 15 $ scanl (*) 1 [100..199]
21:09:11 <lambdabot>  [2725450422877119543012126720000,313426798630868747446394572800000,363575086...
21:09:17 <Axman6> > drop 30 $ scanl (*) 1 [100..199]
21:09:18 <lambdabot>  [53302324527079900778691094496786771759686130815991808000000000,692930218852...
21:09:28 <Axman6> > drop 70 $ scanl (*) 1 [100..199]
21:09:29 <lambdabot>  [457435029235584517045640723656767587683468334975410989047063015222161388441...
21:09:40 <Axman6> > drop 70 $ scanl (*) 1 [100..199] :: [Int] -- -_-
21:09:41 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
21:10:29 <Zemyla> > length $ ((takewhile (/=0) $ scanl (*) 1 [100..199]) :: [Int])
21:10:30 <lambdabot>  Not in scope: ‘takewhile’
21:10:30 <lambdabot>  Perhaps you meant one of these:
21:10:30 <lambdabot>    ‘takeWhile’ (imported from Data.List),
21:10:38 * hackagebot DMuCheck 0.3.0.1 - Distributed Mutation Analysis framework for MuCheck  http://hackage.haskell.org/package/DMuCheck-0.3.0.1 (RahulGopinath)
21:10:38 <Zemyla> > length $ ((takeWhile (/=0) $ scanl (*) 1 [100..199]) :: [Int])
21:10:39 <lambdabot>  63
21:11:02 <Zemyla> > drop 63 (scanl (*) 1 [100..199]) :: [Int])
21:11:03 <lambdabot>  <hint>:1:42: parse error on input ‘)’
21:11:14 <Zemyla> > drop 63 (scanl (*) 1 [100..199] :: [Int])
21:11:15 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
21:11:20 <Zemyla> > drop 60 (scanl (*) 1 [100..199] :: [Int])
21:11:22 <lambdabot>  [-864691128455135232,-9223372036854775808,-9223372036854775808,0,0,0,0,0,0,0...
21:11:32 <Axman6> dat negative
21:12:36 <Zemyla> > length $ ((takeWhile (/=0) $ scanl (*) 1 [2..199]) :: [Int])
21:12:37 <lambdabot>  65
21:13:37 <Zemyla> > reverse $ ((takeWhile (/=0) $ scanl (*) 1 [2..199]) :: [Int])
21:13:38 <lambdabot>  [-9223372036854775808,-9223372036854775808,1585267068834414592,7638104968020...
21:14:34 <kakos> Hey, I have a TH function that takes a Name and it works great except if I want to use a List type. If I do "foo ''[Char]", for example, I get a "parse error on input 'Char'". How do get this to work?
21:17:29 <glguy> You'll probably need a TH function that takes a Type, or one that knows how to resolve type synonyms and make a type synonym
21:19:00 <kakos> glguy: Interestingly enough, it works perfectly if I do ''String
21:19:08 <calvinx> how can I instruct ghc-mod to look up modules installed in my cabal sandbox?  I tried feeding the `-package-db` flag to ghc-mod but it still tells me that it cannot find wai.  (I double checked with ghci -package-db=.cabal-sandbox/x86_64-osx-ghc-7.8.3-packages.conf.d and ghci behaves correctly and manages to import Network.Wai)
21:19:22 <calvinx> http://lpaste.net/117889
21:19:28 <glguy> kakos: That's the type synonym solution I mentioned
21:20:05 <homovitruvius> is there anything similar to haskeline/repline but supporting multiline input like python repls do and allows editing of all input lines?
21:20:24 <kakos> glguy: Okay. Sucks that it isn't simple. :(
21:20:41 <glguy> What're you trying to do?
21:26:50 <calvinx> any idea how I can instruct ghc-mod to use packages in my cabal sandbox?
21:27:08 <EvanR> while trying to install dependencies, it seems to be unable to build hxt-9.3.1.10 due to a syntax error in src/Text/XML/HXT/Arrow/Pickle/Xml.hs:192:22 parse error on input ‘case’
21:27:25 <EvanR> looking at that source, i cant see any syntax error
21:28:31 <EvanR> https://github.com/UweSchmidt/hxt/blob/master/hxt/src/Text/XML/HXT/Arrow/Pickle/Xml.hs#L192
21:29:21 <creichert> could it be the indentation of the "do" lining up with case?
21:29:35 <EvanR> nope i see that in haskell report
21:30:03 <creichert> 98? or 2010 (serious question :))
21:30:23 <EvanR> 98
21:30:51 <Axman6> looks ok to me too. CPP isn't breaking things somehow?
21:31:31 <creichert> there is an extension for enabling non-decreasing of do blocks. just a though
21:31:40 <creichert> they have to be indented further in 2010
21:31:42 <EvanR> i dont know. i just uninstalled ghc 7.6 and installed platform again, with 7.8
21:31:54 <EvanR> not necessarily in that order
21:32:07 <creichert> -XNondecreasingIndentation
21:32:20 <creichert> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs-and-infelicities.html#infelicities-syntax
21:32:38 <EvanR> i tried to unpack and mess with the formatting, it only moves the error somewhere else in the file
21:32:39 <creichert> (testing that hypothesis now)
21:33:04 <creichert> did you see the link, though?
21:33:08 <EvanR> reading
21:33:19 <creichert> the first block of code look like that issue to me
21:35:30 <EvanR> attempting to build the package with NondecreasingIndentation
21:36:21 <pavonia> creichert: But there's not second, non-indented do context in that code
21:36:38 <EvanR> did not help
21:37:14 <EvanR> maybe my PATH is messed up and im using the wrong cpp or something
21:37:59 <creichert> yea, just a thought. too bad. that version compiled here, though
21:38:09 <EvanR> version of ghc?
21:38:22 <creichert> 7.8.3
21:38:33 <EvanR> me too
21:40:03 <EvanR> cabal install cabal-install also failed. so maybe system is probably borked. http://lpaste.net/117890
21:40:34 <creichert> yea, that's very weird
21:40:39 <creichert> newest cabal, hmm
21:40:46 <creichert> i'll test it out on another machine as well
21:40:48 <EvanR> well i need to upgrade
21:41:56 <creichert> ahh, of course :). might just be a funky path. did you try a new shell?
21:43:18 <mietek> Anyone seeing issues with transformers-compat?
21:43:25 <mietek> Like this: https://gist.github.com/mietek/6574e61b379dd667def5
21:43:41 <EvanR> yes i restarted my shell
21:45:03 <EvanR> i noticed i do not have a ~/Library/Haskell much less a ~/Library/Haskell/bin to put in my path
21:45:41 <EvanR> maybe running uninstall-hs after installing the newer platform removed it, and i needed it
21:55:39 * hackagebot DMuCheck 0.3.0.2 - Distributed Mutation Analysis framework for MuCheck  http://hackage.haskell.org/package/DMuCheck-0.3.0.2 (RahulGopinath)
21:57:14 <calvinx> Anyone else I can ask regarding a ghc-mod problem?  Reference - http://stackoverflow.com/questions/27792830/ghc-mod-does-not-use-my-cabal-sandbox-why
22:10:40 * hackagebot persistent-mongoDB 2.1.2.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.1.2.1 (GregWeber)
22:20:40 * hackagebot levmar 1.2.1.5 - An implementation of the Levenberg-Marquardt algorithm  http://hackage.haskell.org/package/levmar-1.2.1.5 (BasVanDijk)
22:21:44 <solatis> jle`: i think i nailed it: https://github.com/solatis/dissent/blob/master/src/Dissent/Protocol/Shuffle/Leader.hs
22:22:13 <solatis> i'm using ErrorT for now, until nixos upgrades to ghc 7.10
22:24:22 <jle`> :D
22:24:26 <jle`> congrats :D
22:25:11 <solatis> yeah, thanks a bunch
22:25:16 <jle`> cringing at one space indent but that's just personal taste i guess...
22:25:26 <jle`> :)
22:25:33 <solatis> hmm it's what emacs does
22:25:42 <jle`> on line 27
22:25:45 <jle`> but yeah, it's nice, right?
22:25:51 <solatis> yeah!
22:25:53 <solatis> no more hoisting
22:25:56 <jle`> when you do switch to another type, ExceptT or EitherT or whatever
22:26:00 <jle`> you can just change one line, line 20
22:26:03 <solatis> yep!
22:26:09 <jle`> your actual functions are polymorphic over all of them
22:26:13 <solatis> it's very, very convenient
22:26:28 <jle`> you've abstracted the idea of error handling from the idea of monad transformers
22:26:39 <solatis> i still don't fully grasp the implementation details of the concepts behind them, but I do understand how to use them now
22:27:00 <jle`> if you chose to, you could even make your own error handling type, different from ErrorT, ExceptT, etc....one type that already integrates resource handling and IO by itself...
22:27:08 <jle`> and then make it an instance of MonadIO, MonadError, MonadResource
22:27:14 <jle`> and then just use that one instead.
22:27:16 <solatis> yep, I understood that already
22:27:20 <jle`> not that you would
22:27:32 <jle`> but it's just nice that you separate the idea of error rhanding from the idea of monad transformers
22:27:35 <jle`> that's just me.
22:27:35 <solatis> i think that's a bit overengineering for now
22:27:40 <jle`> bu the ability to swap them out is nice :)
22:27:49 <solatis> yeah, i like this a lot
22:31:40 <EvanR> i may have fixed it. platform installed new ghc, and it defaulted to using "gcc" as the cpp. but gcc on osx (clang) does not service haskells cpp needs well enough.
22:31:42 <solatis> jle`: https://github.com/solatis/dissent/compare/ce1da468c53630072e8c5a028c8b26d4f9b2792b...master#diff-d2b3417aee72ce3601087d808f0c37adR1
22:31:47 <glguy> solatis: the transformers-compat package exists so that you can use the new transformers-0.4 types while still using the version of transformers that comes with your GHC
22:31:47 <solatis> just look at that
22:32:09 <glguy> solatis: The transformers-compat package adds the missing types depending on the version of transformers you have
22:32:10 <EvanR> so i was able to set the (apparently new) cpp binary setting to real gcc
22:32:15 <solatis> glguy: i will look into that!
22:32:17 <jle`> yeaa no more hoists
22:32:28 <jle`> :D
22:32:48 <solatis> yeah, a lot less imports
22:32:51 <solatis> no more hoists
22:32:58 <solatis> some lifts had to be more explicit
22:33:00 <platz> do people run into the single-instance-per-stack limitation often, or is it kind of rare?
22:33:06 <jle`> i wish there was a better way than `either throwError return`
22:33:08 <jle`> oh well
22:34:52 <platz> i.e. https://ro-che.info/articles/2014-06-11-problem-with-mtl  seems annoying but maybe it doesn't occur in actual applications
22:37:03 <solatis> but i'm really happy!
22:37:03 <solatis> glguy: i think i was looking for some instance MFunctor that translates an Either to an ExceptT, which was only defined in mtl-2.2.1
22:37:03 <solatis> i don't think it's in the transformers-compat package
22:37:03 <solatis> anyway, thanks to this code, it's just one line of code to change between ErrorT to ExceptT :)
22:37:03 <solatis> well, maybe a few throwE into throwExcept too, but that's it
22:37:51 <jle`> throwExcept will work everywhere throwE would, so no harm in just changing it now if you felt like it
22:38:18 <solatis> not at this point, i'm missing the MFunctor instance
22:38:39 <solatis> mtl-2.2 has that, i'm using mtl-2.1
22:50:12 <vanila> platz, I'm pretty skeptical of that claim
22:51:08 <djahandarie> I'm completly failing to trigger CSE at all, has something changed? (I don't see any GHC tickets about it... but I'm on such an old version, 7.4.1, that it must have been reported by now if it were an actual issue)
22:51:49 <djahandarie> Even the stupidest thing like let x = trace "test" 1 in x + trace "test 1" + x doesn't get CSE'd, which it absolutely did at some point.
22:52:09 <Axman6> really? I didn't think GHC did CSE
22:52:35 <djahandarie> It definitely did.
22:53:47 <djahandarie> It was extremely conservative given how easy it is to cause memory usage, but things like an expression which is already bound to a variable being replaced by that variable definitely happened.
22:54:32 <vanila> idont want to distract from your actual question but im really curious: Is this optimization important for haskell?
22:54:47 <EvanR> let x = abc in expr(x) doesnt need cse for x
22:54:53 <EvanR> with laziness
22:55:04 <vanila> oh i just realized, it probably matters for allowing other optimizations to trigger
22:55:28 <djahandarie> EvanR, who said it did?
22:55:53 <EvanR> i guess i misread "expression already bound to a variable being replaced by that variable"
22:56:03 <djahandarie> In my exmaple, the inner  trace "test" 1  would get CSE'd to x.
22:56:15 <EvanR> which was x in the example
22:56:54 <EvanR> you dont have a second trace "test" 1
22:57:55 <djahandarie> I do! I just typo'd here in the chat window (obviously, I would hope, given that it doesn't type-check as is, nor make any sense :-)
22:58:09 <EvanR> oh
22:58:33 <djahandarie> let x = trace "test" 1 in x + trace "test" 1 + x     =>     let x = trace "hit" 1 in x + x + x
22:58:43 <djahandarie> That is the optimization that definitely used to happen and doesn't seem to be anymore.
22:58:45 <platz> vanila: 'optimization' is one thing - maybe this has to do more with expressiveness, but that is more a subjective thing imho
22:58:49 <EvanR> definitely interesting if cse did happen and you got confused about when the trace executed ;)
23:05:43 <dgomez> SO last night there was talk about comonads and their duality with monads.
23:06:36 <dgomez> When I was trying to apply category theory to currying I got an understanding that there had to be a natural transformation requirement between two homomorphisms in order for there to be an adjunction.
23:07:19 <dgomez> I saw an expression trying to denote the |      C <-( x X) && ()^X -> C
23:07:31 <shachaf> Between two homomorphisms?
23:07:44 <shachaf> You mean between functors in particular?
23:08:05 <dgomez> hom (AxB, C) = hom (A, C^B)
23:08:28 <dgomez> well I suppose two functions in the homomorphisms. if thats correctly stated...
23:09:27 <shachaf> I don't know what you mean.
23:09:29 <dgomez> if I understand adjunction's a bit more clearly I would like to see how that expression could be stated or seen more clearly in haskell
23:10:35 <dgomez> Bc I am assuming the comonad in this case is the expression (AxB) and the right monad (C^B)?
23:10:43 <shachaf> There's pretty much only one adjunction in Haskell.
23:10:50 <shachaf> It happens to be the one you're talking about, though.
23:11:41 <ReinH> There is an adjunction (,) e -| (->) e
23:12:12 <dgomez> shachaf: ok, I understand that.. but I guess is there a way to ask to see a currying adjunction in haskell?
23:12:32 <shachaf> dgomez: What are the monad and comonad you're talking about here?
23:12:34 <dgomez> or is that not the right way to state an example of the category theory understanding of adjunction?
23:12:52 <shachaf> If you have an adjunction, F -| G, that doesn't tell you that F or G is a monad or a comonad.
23:13:06 <tac> A category theorist just thinks Hom(FA, B) ~ Hom(A, GB) has a natural isomorphism
23:13:11 <shachaf> Is tells that you that G . F is monad, and F . G is a comonad, but it doesn't look like you're talking about those.
23:13:35 <tac> More simply, show the two sets are isomorphic, then it's almost certainly "natural"
23:15:05 <dgomez> shachaf: sorry if I am not explaining myself well. I suppose I'm wondering how you know G . F is a monad and F . G is a comonad when you know there is an adjunction between two functions.
23:15:25 <shachaf> An adjunction is between two functors, not two functions.
23:16:13 <shachaf> You should start with a good definition of an adjunction, to make sure you know what the structure you're talking about is. There are several definitions to choose from, but I'm not sure you're using any of them.
23:16:20 <dgomez> shachaf: sorry, i did mean functors, it was a mistake
23:16:36 <ReinH> dgomez: you might enjoy http://www.stephendiehl.com/posts/adjunctions.html
23:16:52 <ReinH> String diagrams really help with the intuition imo
23:17:02 <dgomez> shachaf: could you provide an example? bc I thought I was trying to talk about the structure of adjunction as it related to currying...
23:17:42 <shachaf> An example of what?
23:18:03 <shachaf> Let's say that our definition of an adjunction within Haskell is this:
23:18:11 <dgomez> shachaf: umm "a good definition of an adjunction"
23:18:14 <dgomez> :)
23:18:29 <shachaf> F -| G means that you have two function, eps :: F (G a) -> a and eta :: a -> G (F a)
23:18:36 <d12frosted> hi all
23:18:44 <shachaf> Such that fmap eps . eta = id, and eps . fmap eta = id
23:19:16 <d12frosted> does anyone know if alex and happy are base-4.8 ready?
23:19:23 <dgomez> shachaf: following along so far thanks.
23:20:00 <dgomez> ReinH: thanks for the link.
23:20:12 <shachaf> (These functions are natural transformations, which you get for free in Haskell.)
23:20:33 <inerkick> I am getting this error "cabal: unrecognised command: sandbox (try --help)" why is that.
23:20:43 * hackagebot system-canonicalpath 0.2.3.0 - Abstract data type for canonical paths with pretty operations  http://hackage.haskell.org/package/system-canonicalpath-0.2.3.0 (d12frosted)
23:20:43 <ReinH> inerkick: what is cabal --version ?
23:20:48 <ReinH> (your cabal is probably too old)
23:20:52 <dgomez> shachaf: ahh i get what you are saying now. I'm sorry for the confusion...
23:20:52 <ReinH> or, rather, yoru cabal-install
23:20:58 <inerkick> 1.15 ReinH
23:21:03 <inerkick> 1.16 ReinH
23:21:05 <ReinH> inerkick: you need to update cabal-install
23:21:09 <shachaf> dgomez: So I claim that (e,) -| (e ->)
23:21:14 <inerkick> i did already ReinH
23:21:45 <ReinH> inerkick: then you need to make sure that ~/.cabal/bin (or wherever cabal-installed binaries are installed) is in your $PATH
23:21:57 <shachaf> dgomez: You should figure out what eta and eps are, and show that the laws hold.
23:24:14 <d12frosted> also, if you just did cabal install cabal-install, try to load new session
23:24:26 <d12frosted> open new terminal window or call bash (or zsh)
23:25:25 <d12frosted> inerkick: my last two messages where for you :D
23:25:30 <ReinH> dgomez: maybe start by figuring out their types (specialized to F ~ (,) e, G ~ (->) e
23:26:13 <dgomez> shachaf:  i see. from the first I recognize that adjunction and one as the monad reader i believe?  as far as eta and eps go I should figure out what their types are and why there is an adjunction? I can do that. I am not sure I know right now.
23:26:19 <inerkick> I tried update cabal again nothing happened d12frosted
23:26:38 <shachaf> dgomez: We didn't say anything about monads so far.
23:26:53 <shachaf> dgomez: We have type F a = (E,a) and type G a = E -> a
23:27:00 <inerkick> i didn't do cabal install cabal-install d12frosted
23:27:08 <shachaf> Give me eps :: F (G a) -> a and eta :: a -> G (F a)
23:27:24 <d12frosted> inerkick: `cabal update` update packages database, but not cabal itself
23:27:25 <dgomez> shchaf: no? then what is (e ->) I thought it was the reader monad?
23:27:38 <d12frosted> inerkick: you need to do `cabal install cabal-install` to update cabal-install :D
23:27:48 <shachaf> (e ->) is a lot of things.
23:27:53 <inerkick> hmm ok so i just gave cabal install cabal-install
23:27:54 <shachaf> For our purposes it's a functor.
23:27:59 <shachaf> Why bring up monads?
23:28:17 <d12frosted> inerkick: and then (probably, I am just not sure) you need to restart your session so your environment catches new version of cabal
23:28:42 <ReinH> inerkick: what OS, how did you upgrade cabal-install?
23:29:04 <ReinH> dgomez: let's just start with the type of eta
23:29:12 <dgomez> shachaf: I'm sorry again for confusing terms. I am just spotting familiarities was all. I do get what you are referring to when talking about type F and G
23:29:21 <ReinH> what's the type of eta if F ~ (e,) and G ~ (e ->)?
23:29:22 <dgomez> ReinH: i think that might help
23:29:24 <inerkick> mine is Ubuntu 14.04 ReinH , i did https://answers.launchpad.net/ubuntu/+source/haskell-platform/+question/226960 this which i had issue earlier
23:30:27 <ReinH> dgomez: Oh, apt tends to lag behind for things like this. To upgrade cabal-install, you should cabal install cabal-install
23:31:21 <ReinH> dgomez: woops, wrong person
23:31:23 <ReinH> inerkick: ^
23:31:48 <inerkick> i installed cabal-install now it's version is 1.22.0.0
23:31:54 <ReinH> Seems good.
23:31:57 <inerkick> will this be ok now?
23:32:00 <inerkick> to try
23:32:01 <ReinH> inerkick: yep
23:32:01 <d12frosted> yep, the last available on hackage
23:32:07 <inerkick> ok thanks
23:32:09 <inerkick> let me try
23:32:41 <shachaf> I wonder what you were doing if not figuring out the types. What steps were you taking to solve the problem?
23:32:59 <inerkick> it still says cabal: unrecognised command: sandbox (try --help)
23:33:28 <dgomez> ReinH: I am still not sure I understand types that well.
23:33:37 <inerkick> i was trying with Yesod
23:34:03 <inerkick> cabal sanbox init gives that error
23:34:10 <ReinH> inerkick: and what is cabal --version now?
23:34:35 <inerkick> cabal-install version 1.16.0.2
23:34:36 <inerkick> using version 1.16.0 of the Cabal library
23:34:46 <ReinH> Ok, so it isn't using the new binary
23:34:50 <d12frosted> try tin other session
23:34:51 <inerkick> yup
23:34:52 <ReinH> You need to have ~/.cabal/bin in your $PATH
23:35:09 <inerkick> how to do that. Kindly help
23:35:38 <ReinH> so you want to add, e.g., export PATH=$HOME/.cabal/bin:$PATH in your shell's profile file (~/.profile for bash) and either source it or start a new shell session.
23:36:06 <ReinH> dgomez: it's easier for us to help if you share your thought process with us...
23:36:07 <d12frosted> ReinH: probably, ask him to echo $PATH
23:36:52 <ReinH> (export PATH="$HOME/.cabal/bin":$PATH with quotes to be safe)
23:37:06 <ReinH> inerkick: see http://wiki.loria.fr/wiki/Haskell/cabal
23:37:18 <inerkick> thanks ReinH
23:37:42 <dgomez> ReinH: I suppose I don't understand the mathematical notation you used for F and G. I would assume the type would be in some way a composition of F . G?
23:38:05 <dgomez> ReinH: but I know its not the correct thought process.
23:38:25 <ReinH> dgomez: e.g., eps :: (Functor f, Functor g) => f (g a) -> a
23:38:49 <ReinH> And yes, the type is a sort of composition of F and G
23:39:36 <ReinH> so can you write the type of eps specialized to f ~ (,) e and g ~ (->) e?
23:39:57 <ReinH> Maybe start with g
23:40:15 <ReinH> as in, fill in f (???) -> a
23:40:45 <inerkick> Hi ReinH the cabal version now as it says "$ cabal --version
23:40:45 <inerkick> cabal-install version 1.22.0.0
23:40:45 <inerkick> using version 1.22.0.0 of the Cabal library"
23:40:51 <ReinH> inerkick: seems good
23:41:00 <inerkick> let me try
23:41:16 <dgomez> ReinH: f(->) -> e?
23:41:40 <ReinH> dgomez: Do you know what (->) e means?
23:42:00 <dgomez> ReinH: not at this exact moment no
23:42:00 <inerkick> yeah it's working, ReinH . Thanks so much
23:42:11 <ReinH> dgomez: it's a partially applied function type constructor.
23:42:12 <inerkick> Thanks d12frosted
23:42:16 <ReinH> (->) a b ~ (a -> b)
23:42:35 <d12frosted> inerkick: you're welcome :D
23:42:36 <ReinH> (->) e takes a type t and gives (e -> t)
23:43:07 <ReinH> dgomez: but you can also just treat g ~ (->) e like an algebraic equation and "solve for g"
23:43:55 <ReinH> dgomez: as in just basic algebraic symbol manipulation, without even worrying about what (->) e "means"
23:44:19 <ReinH> so can you solve for g in (g a) given g ~ (->) e ?
23:45:02 <dgomez> ReinH: wow. i thinksorry i freezing..
23:45:23 <vanila> dgomez, do you have diagrams to help visualize all this?
23:45:25 <ReinH> dgomez: no worries, what about solving for x in (x 2) given x = (+) 1?
23:45:43 * hackagebot HsOpenSSL 0.11.1.1 - Partial OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.11.1.1 (MasatakeDaimon)
23:45:46 <dgomez> vanila: no diagrams with me at this moment.
23:45:56 <vanila> well you should have a diagram to help
23:46:11 <dgomez> ReinH: 3 correct?
23:46:16 <d12frosted> ReinH: is answer e (for g a)?
23:46:18 <ReinH> dgomez: what is the unevaluated expression?
23:46:27 <ReinH> We can ask Haskell:
23:46:29 <ReinH> > let x = (+) 1 in x 2 :: Expr
23:46:30 <dgomez> vanila: noted for next time..thank you
23:46:31 <lambdabot>  1 + 2
23:46:36 <dgomez> :)
23:46:38 <d12frosted> lol
23:46:42 <vanila> dgomez, http://upload.wikimedia.org/wikipedia/commons/8/83/Adjoint_functors_sym.svg
23:46:53 <dgomez> ReinH: x = 2 (+) 1 ???
23:46:54 <jascase901> I am just starting out with haskell. Can someone give me some pointers for getting random numbers? This is the code I want to a write with a stub for random the random number.
23:46:58 <vanila> Here are the conditions for an adjunction as a diagram
23:48:04 <ReinH> dgomez: the substitution steps are: (((+) 1) 2) (definition of x), ((+) 1 2) (function application binds to the left), (1 + 2) (prefix expression to infix operator)
23:48:05 <dgomez> ReinH: yeah, I'm sorry for being a bit behind.
23:48:09 <ReinH> dgomez: no worries
23:48:25 <ReinH> So you can do the exact same steps to solve for (g a) when g ~ (->) e
23:48:30 <dgomez> vanila: thanks :)
23:49:02 <ReinH> dgomez: so step 1, replace g with its definition.
23:49:05 <jascase901> whoops forgot the paste bin . This is the code I want to write a stub for random numbers with  http://pastebin.com/Rs3Lc7b2
23:49:29 <EvanR> jascase901: just to get started, you can use randomIO
23:49:32 <EvanR> :t randomIO
23:49:33 <lambdabot> Random a => IO a
23:49:41 <dgomez> ReinH: ((->) e ) a  ??
23:49:47 <ReinH> dgomez: correct
23:50:10 <ReinH> dgomez: now you can remove the outer parens because (f a) b = f a b
23:50:48 <ReinH> so step 2  is?
23:50:50 <jascase901> thanks EvanR
23:51:01 <dgomez> -> e a  but I am not sure what this means?
23:51:06 <ReinH> dgomez: just the outer parens
23:51:15 <dgomez> (->) e a
23:51:35 <ReinH> dgomez: now, recall that (+) 1 2 = 1 + 2
23:51:39 <ReinH> this is the same for (->)
23:51:45 <ReinH> so step 3?
23:52:00 <dgomez> e -> a
23:52:03 <ReinH> right
23:52:07 <dgomez> oh
23:52:23 <dgomez> type constructor...
23:52:29 <ReinH> So we started with eps :: (Functor f, Functor g) => f (g a) -> a
23:52:30 <dgomez> makes more sense.
23:52:44 <ReinH> now we have eps :: Functor f => f (e -> a) -> a
23:52:53 <ReinH> and we also have f ~ (,) e
23:52:55 <ReinH> so now solve for f
23:52:59 <ReinH> same way
23:53:06 <ReinH> step 1?
23:53:32 <dgomez> ((,) e) a ?
23:53:37 <ReinH> step 2?
23:53:42 <ReinH> well
23:53:44 <ReinH> not quite
23:53:48 <ReinH> because it isn't f a
23:53:50 <ReinH> it's f (e -> a)
23:54:16 <dgomez> ((,) e) (e -> a) ??
23:54:31 <ReinH> right, step 2?
23:54:49 <dgomez> (,) e (e -> a)
23:55:01 <ReinH> now, recalling that (,) a b = (a,b), step 3?
23:55:12 <dgomez> (e, e -> a)
23:55:21 <ReinH> so, putting that back into the above
23:55:27 <ReinH> eps :: (e, e -> a) -> a
23:55:44 * hackagebot simple 0.10.0.3 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.10.0.3 (AmitLevy)
23:56:01 <dgomez> is (e, e -> a) the Functor?
23:56:07 <dgomez> Functor f?
23:56:46 <ReinH> f was (,) e and g was (->) e
23:57:40 <dgomez> ReinH: yes, sorry
23:58:17 <ReinH> So that's the type of eps
23:58:40 <ReinH> can you give me a definition of eps when eps :: (e, e -> a) -> a ?
