00:01:36 <koz_> Why is the last function here: http://paste.rel4tion.org/131 giving me this error? http://paste.rel4tion.org/132
00:02:47 <Ralith> probably because there is no instance for Eq CTNode
00:03:04 <Ralith> you should consider providing one
00:03:22 <koz_> Ralith: Ah. Whoops.
00:03:49 <Ralith> that was pretty much a verbatim quote from the error message
00:03:49 <koz_> What's the default Eq that Haskell will give something if I tell it to? Just a field-for-field comparison?
00:04:02 <Ralith> that is what deriving Eq does, yes
00:04:09 <koz_> Ralith: That works fine for me.
00:04:18 <Ralith> then you should probably do that!
00:04:54 <koz_> Wants Hashable too. Hmmm.
00:05:16 <Ralith> I also strongly recommend adjusting your indentation/newline convention for if/then/else to be sane
00:05:34 <koz_> Ralith: Yeah, should do that, sorry.
00:05:39 <koz_> It's my first day Haskelling.
00:05:59 <Ralith> you are doing pretty well, then
00:06:12 <koz_> Ralith: I'm trying - what's the normal convention for if-then-else in Haskell?
00:06:33 <koz_> Is it one line for if, one for then, one for else?
00:06:50 <Ralith> I'm not sure about "the normal convention", but general rule of thumb is "be consistent"
00:07:05 <Ralith> if you are putting 'else' at the start of a new line, 'then' should also be at the start of a new line
00:07:18 <koz_> Ah, I see.
00:07:27 <koz_> Well, that's fixed now.
00:08:34 <Ralith> can't help you as far as obtaining a Hashable instance goes; are you sure you really want CTNode to be a HashMap key?
00:08:55 <koz_> Well, that was the original plan. I think I might have to rethink it now.
00:09:09 <koz_> I just realized the issue in obtaining Hashable - it's hidden.
00:09:52 <Ralith> https://hackage.haskell.org/package/hashable-1.2.3.3/docs/Data-Hashable.html may be of interest
00:10:08 <Xeironis_> When I have a Coordinates Type, would it be more advisable to use newtype Coords = Coords (Int, Int) or data Coords = Coords Int Int?
00:10:10 <Ralith> but your data structure does not look very hashable to begin with
00:10:29 <koz_> Yeah.
00:10:35 <koz_> Could I do a simple pairlist instead?
00:10:58 <jle`> Xeironis_: data Cords = Cords Int Int makes more sense to me...you don't gain anything from having a newtype here
00:11:07 <Xeironis_> okay, that makes sense, thanks
00:11:08 <jle`> because tuples are lazy anyways
00:11:14 <koz_> Although that's potentially O(n) recursive structure comparisons...
00:11:18 <jle`> i would in real life recommend data Coords = Coords !Int !Int
00:11:20 <koz_> I think I need to rethink this.
00:11:25 <Xeironis_> I see
00:11:27 <koz_> jle`: What does !Int mean?
00:11:34 <jle`> it makes the fields strict
00:11:37 <koz_> Ah.
00:12:05 <jle`> there aren't really many good reasons why you'd want these fields to be lazy
00:12:16 <jle`> i can think of a few contrived ones
00:12:32 <Ralith> you can also make those fields unboxed, which can be nice
00:12:59 <jle`> that'd probably be better too.  but i think they are automatically optimized to be unboxed?
00:13:07 <koz_> OK, I think I need a different approach.
00:13:29 <Ralith> jle`: isn't there an explicit extension for unboxing strict fields?
00:13:39 <jle`> i'm not sure :O
00:13:39 <Ralith> I'm not remotely familiar with the default optimizations
00:14:00 <Ralith> but I'm pretty sure 'unbox strict fields' has been an opt-in thing at least in the recent past
00:14:11 * hackagebot postgrest 0.3.0.0 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-0.3.0.0 (begriffs)
00:14:15 <jle`> i usually try to write correct code first before optimizing on that level
00:14:21 <Xeironis_> -funbox-strict-fields seems to be a thing
00:14:28 <jle`> i usually don't get to that point in most of my application
00:14:28 <Ralith> I have never needed to optimize on that level, so *shrug*
00:14:53 <jle`> going from lazy fields to strict fields changes the semantics of your type/program to match more what you'd expect
00:15:15 <jle`> going from strict int to unboxed int here feels like fine tuning optimization.  but i know a lot of people do it automatically habit
00:15:37 <jle`> *automatically by habit
00:16:59 <Ralith> having small fixed-size fields *not* be unboxed seems vaguely sinful
00:17:15 <Ralith> assuming strictness
00:17:16 <jle`> semantics over flowers <3
00:26:27 <koz_> Man, hlint is a great teacher.
00:26:34 <koz_> I just learned of two new functions thanks to it.
00:28:02 * tdammers nods
00:31:49 <koz_> :t maximumBy
00:31:50 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
00:32:18 <koz_> Are Eithers foldable?
00:32:25 <koz_> Foldable* rather
00:35:32 <kadoban> koz_: Probably not in the way you're hoping.
00:36:33 <koz_> kadoban: :(
00:36:51 <koz_> I'll finish writing my idea and see what you nice people suggest.
00:36:53 <kadoban> koz_: Why do you want it to be?
00:38:04 <koz_> kadoban: I think it best if I show you: http://paste.rel4tion.org/133
00:38:28 <koz_> greatestSubtree relies on foldability, which under this definition, it kinda won't have according to what you've said.
00:40:17 <kadoban> koz_: I don't really understand what you're trying to do that would require Either to be Foldable.
00:40:41 <koz_> kadoban: Subtrees are defined as a Map from Strings to (Either CLeaf CInternal).
00:41:00 <koz_> The current definition (or former definitioN) of greatestSubtree relies on maximumBy.
00:41:05 <koz_> :t maximumBy
00:41:06 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
00:41:40 <koz_> Oh, wait...
00:41:44 <koz_> Derp.
00:41:53 <koz_> The *list* is foldable, but the entries need not be.
00:41:56 <koz_> Right?
00:42:20 <kadoban> Yes, I guess?
00:42:29 <koz_> Goddamn it.
00:42:37 <koz_> I'm having an interesting first day of Haskell.
00:45:01 <koz_> OK, I defined a typeclass with 'class Sizeable a where size :: a -> Natural'. How would I do an instance definition for Sizeable for type foo, where the value size returns on anything of type foo is a constant?
00:46:11 <quchen> How do you define a normal constant function?
00:46:19 <quchen> How do you define a normal instance?
00:46:37 <koz_> quchen: A constant function would just be bar = 1 or whatever.
00:46:51 <quchen> "bar = 1" is not a function.
00:47:04 <quchen> > let bar = 1 in bar ()
00:47:05 <lambdabot>      No instance for (Show a0)
00:47:05 <lambdabot>        arising from a use of ‘show_M72186300742156914107263’
00:47:05 <lambdabot>      The type variable ‘a0’ is ambiguous
00:47:15 <quchen> > let bar = (1 :: Int) in bar ()
00:47:16 <lambdabot>      Couldn't match expected type ‘() -> t’ with actual type ‘Int’
00:47:16 <lambdabot>      The function ‘bar’ is applied to one argument,
00:47:16 <lambdabot>      but its type ‘Int’ has none
00:47:32 <koz_> Ah, my bad. bar x = 1
00:47:41 <koz_> With an appropriate type annotation.
00:47:41 <shachaf> /msg, please.
00:47:42 <quchen> A function needs to take an argument.
00:47:44 <quchen> A constant function needs to take an argument and ignore it. :-)
00:48:09 <shachaf> koz_: The usual way to do this would be to use the type Proxy, defined as data Proxy a = Proxy.
00:48:51 <shachaf> Then you can write class Size where { size :: Proxy a -> Natural }, which indicates that you really want to pass a type and not a value of that type.
00:50:06 <quchen> I think the lower-case "foo" was supposed to be "Foo" in the question.
00:50:32 <quchen> (In which case we don't need proxies, because only the "Foo" instance should be constant.)
00:50:34 <koz_> quchen: Yeah, it was.
00:51:49 <quchen> koz_: So, back to question 2, how do you define an instance of something?
00:51:58 <koz_> quchen: Never mind, I figured out how to do what I wanted.
00:52:01 <quchen> In particular, how would you define an instance of your Sizeable
00:52:03 <quchen> OK.
00:52:12 <koz_> instance Sizeable CTLeaf where size _ = 1
00:52:31 <koz_> Thanks for your patience with me, though.
00:58:02 <hc> moin, quick question. i have a function (withDB :: ConnectionPool -> (Connection -> IO a) -> IO a)
00:58:27 <hc> now i wish to write a generic library that is passed that function. but the type a would be different for each call. what does the type have to look like for this to work?
00:59:12 <hc> dbUsingLibFunction :: ((Connection -> IO a) -> IO a) -> IO ()       would restrict the function to one specific type of a
01:01:50 <frerich> hc: Moin - I'm not sure I get it: you want to pass 'withDB' to another function but you're not sure what type that other function has? That's kind of hard to say, execpt that one argument would be of the type of 'withDB'. :-}
01:02:18 <hc> yeah i want to pass it to another function but without the first argument
01:02:22 <hc> so different types of connection pools can be used
01:02:52 <hc> (or a single "fixed" connection even if desired)
01:02:56 <anonon> hi
01:03:00 <anonon> why is :t 4
01:03:05 <anonon> not giving int
01:03:10 <anonon> it's giving Numm
01:03:16 <anonon> is Num typeclass?
01:03:18 <hc> i know all types that will be used, but the dbUsingLibFunction will need to call the passed function with different types of a
01:04:25 <Xandaros> anonon: 4 could be a lot of things. could be an integer, a float, a double... and yes, Num is a typeclass
01:04:26 <kadoban> anonon: Yes, Num is a typeclass. Numeric literals are a bit special in haskell. This is so it's easy to make literals of whatever numeric type you want, instead of having to manually choose between Int, Integer, Float, Double, Rational, etc.
01:04:58 <koz_> anonon: Without context, I assume that Haskell would give the broadest type it can.
01:05:34 <koz_> Never mind, got beaten to it...
01:05:35 * Black-Wolf SaudaÃ§Ãµes
01:05:56 <anonon> thank you guys 
01:05:59 <Xeironis_> :t (4 :: Int, 4 :: Float, 4) -- just to demonstrate
01:06:00 <lambdabot> Num t => (Int, Float, t)
01:07:17 <Xandaros> too bad you need an extension to get the same functionality for string-like things
01:07:44 <Xeironis_> hc: not sure I fully understand what you want, but since you know all the possible types, maybe make a typeclass for them and use that as type?
01:07:53 <koz_> OK, now I'm trying to extend Sizeable to (Either CTInternal CTLeaf) and I'm struggling. I want it to just delegate to whatever it happens to be at the time.
01:07:57 <anonon> how to read 4 :: Num a => a
01:08:03 <anonon> in sentence
01:08:19 <Xeironis_> anonon: 4 is of type a, where a is a type in the Num class
01:11:23 <lpaste_> hc pasted “whatIsTheTypeSignatureOfSomeFunc.hs” at http://lpaste.net/145874
01:11:32 <hc> Xeironis_: i've pasted an example to illustrate what i mean
01:15:54 <hc> okay i guess i'll have to use my own typeclass for that...
01:17:43 <frerich> hc: I don't understand that example: 'someFunc' should return different types of values?
01:17:55 <Xandaros> hc: someFunc :: (db -> SomeMonad a) -> SomeMonad a?
01:18:26 <Xandaros> the last a is string, actually
01:18:29 <hc> Xandaros: yeah, only problem is that once this is passed to a function, the "a" is bound to a specific type
01:18:36 <hc> i'm trying to solve the problem with a new typeclass now
01:19:08 * frerich notes that 90% of the time you think typeclasses solve a problem, they actually do not solve a problem :-}
01:19:46 <hc> i'm open to suggestions :)
01:19:54 <Xandaros> I'm not sure what you are trying to accomplish - that function always returns a string in a monad
01:19:54 <hc> right now i have
01:20:00 <hc> class WithPostgreSQLConn a where withPostgreSQLConn :: a -> (Connection -> IO b) -> IO b
01:20:14 <frerich> I didn't even understand the problem yet. I only saw some pseudo code which is syntactically incorrect :-}
01:20:31 <hc> okay, i'll try again
01:21:06 <Xandaros> frerich: I imagined a dollar before the lambdas
01:21:32 <hc> I have a library function x which must perform several operations on a database. Each time a database connection is needed, the function shall call a "withDatabase" function. Like shown in the example.
01:22:07 <hc> Now the question is, how can the "withDatabase" function that is passed to the library function as a parameter be made to accept different return values each time it is used, but in the same call of x
01:22:18 <hc> As shown in the example I pasted
01:22:47 <frerich> hc: Wouldn't it be more sensible to rather pass a connection to your 'x' function?
01:22:48 <Xandaros> you just make it polymorphic and it should work fine, I think
01:23:00 <hc> frerich: no it wouldn't
01:23:12 <hc> Xandaros: how to do that? by using a typeclass?
01:23:22 <frerich> hc: What's the actual name of 'x', what does it do?
01:23:32 <Xandaros> no, just regular type variables
01:23:50 <hc> frerich: It's an implementation of a Wai.Session store
01:26:16 <frerich> hc: So 'x' is like 'SessionStore' in http://hackage.haskell.org/package/wai-session-0.3.2/docs/Network-Wai-Session.html ?
01:26:47 <hc> Okay, I think I solved it
01:27:05 <lpaste_> hc pasted “typetest.hs” at http://lpaste.net/145875
01:27:24 <hc> here's my attempt to solve it. if someone wants to pass a db pool instaed of a connection, they'll just have to implement the typeclass
01:31:23 <koz_> OK, I'm a bit confused. This code: http://paste.rel4tion.org/137 is a-OK by GHC, but this code: http://paste.rel4tion.org/138 is not, with this error: http://paste.rel4tion.org/139 .
01:32:49 <koz_> Why is the second one making GHC unhappy but the first one not?
01:33:51 <liste> koz_ your type signature means that the functions should work for *all* Sizeables
01:34:29 <liste> not just *some* Sizeable
01:35:12 <liste> the caller chooses the concrete types for type variables
01:35:33 <koz_> Ah, but the function forces it.
01:35:38 <koz_> Because of the where.
01:35:45 <koz_> That makes sense.
01:36:00 <lpaste_> frerich annotated “typetest.hs” with “typetest.hs (annotation)” at http://lpaste.net/145875#a145876
01:36:36 <frerich> hc: I just annotated your paste with an alternative which does not use a type class. From what I gathered, you want to use the same function with either a single connection or a pool?
01:37:28 <s4ke> hi there
01:37:30 <frerich> hc: If that's true, then modelling 'either a connection, or a pool' as an ADT seems plausible to me.
01:37:45 <hc> frerich: thanks. actually, i want to be able to use different implementations of pool
01:37:49 <s4ke> haskell beginner here, can someone give me a good link to a state introduction?
01:38:11 <hc> frerich: being able to use a "direct connection" is just a "side effect" of using the typeclass
01:38:19 <s4ke> i could just copy paste some code from the internet, but i guess that doesnt help me in understanding the whole concept
01:44:08 <koz_> What kind of pattern would I use to match to a list of exactly 2 elements?
01:44:47 <Shockk> koz_: you can use [x, y]
01:44:53 <koz_> Shockk: Thanks!
01:45:02 <Shockk> koz_: that's equivalent to the constructor pattern:
01:45:08 <Shockk> x : y : []
01:47:39 <koz_> Shockk: Am I using it right? I get a parse error. insert :: CTInternal -> [String] -> CTInternal
01:47:41 <koz_> insert cti [x y] = cti {subtreeSize = 2, children = HM.insert x (makeLeaf y) (children cti)}
01:49:09 <Iceland_jack> koz_: [x,y] instead of [x y] is at least one
01:49:14 * hackagebot ical 0.0.0 - iCalendar format parser and org-mode converter.  https://hackage.haskell.org/package/ical-0.0.0 (ChrisDone)
01:49:37 <koz_> Goddamn it Lisp habits.
01:50:31 <s4ke> so, basically State contains a function that maps a someState -> (value, someState) right?
01:51:38 <Xandaros> s4ke: yes
01:52:34 <s4ke> Xandaros: what does the value do in that context then? is it just some internal representation to make sure i know where i was?
01:52:52 <s4ke> why isnt it just someState -> someOtherState
01:53:09 <s4ke> sorry for the dumb questions on #haskell, but #haskell-beginners is sleepy
01:53:13 <Xandaros> s4ke: "value" is the result of your stateful computation. The last state is not necessarily what you are interested in
01:53:18 <bartavelle> s4ke, if you want to roll dices, you will want something like
01:53:19 <jle`> s4ke: it's useful to have results, too :)
01:53:21 <quchen> #haskell is the channel for Haskell beginners.
01:53:23 <bartavelle> RngState -> (Int, Rngstate)
01:53:25 <quchen> I don't know what #haskell-beginners is.
01:53:30 <Xandaros> #haskell-beginners is an inofficial channel, you can ask beginner questions here :)
01:53:36 <s4ke> okay. cool.
01:53:52 <akegalj> where is hackage documentation of GHC.Classes ? I cannot find it on hackage
01:54:02 <jle`> s4ke: you can think of a `State s a` as something that generates an `a`, but that possibly changes an `s` in the processes
01:54:21 <jle`> s4ke: State s a  is a fancy   s -> (a, s)
01:54:45 <s4ke> hmm. the example we had in the lecture to show the usage of State didnt get me any big idea on how to use it properly
01:55:03 <Xandaros> s4ke: Take a look at the typeclassopedia for functors and applicatives. I sense you are lacking an understanding of those :)
01:55:03 <jle`> if you're looking for someState -> someState, you want `State s ()`.  It's something that "produces a ()", but changes an `s` in the process
01:55:04 <quchen> akegalj: You can find the Haddocks generated by GHC next to the user's guide: https://downloads.haskell.org/~ghc/latest/docs/html/
01:55:05 <s4ke> so for a TicTacToe game, what is the value for example?
01:55:22 <jle`> s4ke: an s -> ((), s), essentially.  all it does is change a state...it doesn't produce anything meaningful as a result
01:55:59 <quchen> It could produce True if the game is over.
01:56:01 <bartavelle> s4ke, you will want to have multiple functions, for example `permittedMoves :: State Board [Position]`
01:56:15 <s4ke> bartavelle: i already have that calculation in place :)
01:56:17 <akegalj> quchen: thank you
01:56:30 <jle`> s4ke: well, that's like asking, for a normal Haskell program, what is the "result" of IO in `IO a`?   -- you'll be using a bunch of IO a's and composing them with Monad, Applicative, etc. combinators
01:56:35 * dramforever just picked up diagrams, and was immediately bugged by the fact that diagrams does not have a function for a segment from (x1, y1) to (x2, y2)...
01:56:55 <bartavelle> s4ke, but also the function `play :: Player -> Position -> State Board (Maybe Winner)`
01:57:02 <jle`> s4ke: for example, do { putStrLn "what is your name?"; name <- getLine; putStrLn ("hello " ++ name) }
01:57:13 <jle`> s4ke: we used a bunch of IO actions, each giving different types of results, to make our program
01:57:30 <jle`> in the case of a game like a tic tac toe game, you'll be composing a bunch of stateful actions, each with different types of results, to make your final program
01:58:06 <s4ke> yep. i know that, i think :D. was just wondering what to do for my case with the gameValue
01:58:16 <jle`> it depends on what you want your function to do
01:58:19 <s4ke> i think i  can just set it to whatever and see whether i need it and not
01:58:26 <s4ke> whatever
01:58:32 <s4ke> s/whether/whatever
01:58:52 <jle`> for example, if you want, "i want an action in my tic tac toe game that checks if the game is won or not", that'd be (State Board Bool)
01:59:27 <jle`> if you want an action that will take a piece from Player 1 and return whether or not that won him the game, you'd want (Piece -> State Board Bool)
02:00:25 <jle`> if you want an action that would tell you whose turn it currently is, and your Board contains this information, you'd want a State Board Player   -- return the Player whose turn it is
02:00:31 <s4ke> okay. thanks. i dont understand that fully yet, but i guess i can figure it out along the way
02:01:04 <s4ke> https://gist.github.com/s4ke/1eb084b9c9b4b3e4c859 (the code if you're interested)
02:02:27 <Xandaros> @where typeclassopedia
02:02:27 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
02:02:30 <Xandaros> s4ke: ^
02:02:39 <s4ke> ok.
02:02:56 <Xandaros> It helped me a lot to understand monads
02:02:57 <akegalj> quchen: when I type `:i Ord` repl says `instance (Ord a, Ord b) => Ord (a, b) -- Defined in ‘GHC.Classes’` but GHC Api doesn't seem to have Classes (https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-7.10.2/index.html) module. How should I find this Ord instance of tuple.
02:03:04 <s4ke> thanks :)
02:03:11 <s4ke> i like the intuition part so far :D
02:03:18 <s4ke> while scanning over it
02:03:46 <quchen> akegalj: Hmm. Haddocks aren't such a good place to search GHC internals. I'd search the GHC source directly.
02:03:48 <s4ke> thats something a lot of haskell's doc lacks in other places. i guess i have to learn how things are documented in the haskell world more
02:03:55 <Xandaros> s4ke: Don't skip Functor and Applicative. They are simpler concepts and every monad is both functor and applicative :)
02:04:07 <s4ke> i already implemented a monad before :)
02:04:26 <Xandaros> :)
02:04:42 <s4ke> but really thanks. doing it once doesnt mean i know everything :D
02:04:44 <s4ke> haha
02:04:57 <akegalj> quchen: ok, thanks. I thought I am missinterpreting something (felt really dumb a second ago)
02:09:48 <tranma> anyone tried to install inline-r with ghc 7.10 on OS X El Capitan?
02:09:58 <tranma> I got "Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/usr/include/stdlib.h:177: (column 47) [ERROR]  >>> Syntax error ! The symbol `__WATCHOS_PROHIBITED' does not fit here."
02:10:47 <merijn> tranma: Looks like soeone is using non-portable header/CPP stuff in their haskell files because "every *nix is linux"
02:11:21 <tranma> fffffffuuuuuuu looks like it https://github.com/haskell/c2hs/issues/85
02:11:41 <tranma> this is during trying to install HaskellR btw
02:16:33 <tranma> fine, I'll generate a glorious String and call the R CLI
02:20:03 <tranma> oh, looks like they fixed it on master....
02:21:36 <ocramz> hi all
02:23:21 <s4ke> ... in my lecture pointless style is used ALL the time. this makes it so hard to understand stuff...
02:24:16 * hackagebot ical 0.0.1 - iCalendar format parser and org-mode converter.  https://hackage.haskell.org/package/ical-0.0.1 (ChrisDone)
02:24:33 <s4ke> having this declaration: playGame :: String -> State GameState GameValue
02:24:33 <s4ke> what is the equivalent to playGame[] = do (_, score) <- get; return score
02:25:05 <s4ke> or is there any pointless even?
02:25:31 <merijn> "const (gets snd)"
02:25:38 <merijn> :t const (gets snd)
02:25:39 <lambdabot> MonadState (a1, a) m => b -> m a
02:25:45 <s4ke> (haven't felt so dumb about programming since learning C+
02:25:52 <s4ke> 7 years ago
02:25:57 <merijn> But pointfree code is overrated
02:26:16 <s4ke> pointfree code is so annoying to read
02:26:21 <Xandaros> I like pointfree code. I find it a lot easier to read, personally
02:26:42 <Xandaros> It does take some getting used to, though, I agree
02:26:43 <s4ke> well if you are trying to understand States and the lecture uses pointfree code to explain it 
02:26:57 <merijn> Xandaros: It really depends
02:27:07 <ocramz> s4ke: it actually depends; in small doses, pointfree is very powerful
02:27:16 <dramforever> Xandaros: pointfree can both help and...oh yeah those two already said it
02:27:22 <s4ke> ocramz: it is used ALL THE TIME, thats the problem :/
02:27:55 <s4ke> oh, look, i can leave that part that would help you understand it out
02:28:04 <s4ke> *leaves it out*
02:28:17 <ocramz> problem being is that we are humans so we can't keep too many implicit transformations in our heads at any one time
02:28:23 <jle`> the thing is that a lot of people treat point free code as an end in and of itself
02:28:33 <jle`> when it's really supposed to only be a means to an end
02:28:42 <jle`> the goal is readability, and sometimes pointfree helps, and sometimes it doesn't
02:28:50 <jle`> but some people treat pointfree itself as the goal
02:28:54 <s4ke> i guess i will go and ask for help at university. i cant be so dumb
02:29:06 <jle`> you are definitely not dumb
02:29:37 <s4ke> as a java programmer (the single most explicit language) pointfree is such an awkward concept
02:29:49 <merijn> Why's that?
02:30:17 <s4ke> java doesnt do much to help you in order to write things shorter
02:30:19 <frerich> s4ke: I think many people who are used to a Unix-style shell have been using pointfree code without realizing it, e.g. 'grep foo * | wc -l' is point free.
02:30:49 <Xandaros> > (ap ((.) . (.) . (.) . (:)) . (((flip (:) .) .) .) . flip ((.) . (.) . (:)) . (flip (:) .) . (. return) . (:)) 'l' 'y' '!' 'p' 'a'
02:30:51 <lambdabot>  "yaypl!"
02:30:55 <Xandaros> So easy to read! :P
02:31:09 <mauke^0> @unpl (ap ((.) . (.) . (.) . (:)) . (((flip (:) .) .) .) . flip ((.) . (.) . (:)) . (flip (:) .) . (. return) . (:)) 'l' 'y' '!' 'p' 'a'
02:31:09 <lambdabot> return ((\ ao b c f i -> ((:)) ao (b c f i)) 'y' ((\ bq bt bw l -> (:) l (((:)) bq ((:) bw (((:)) 'l' (return bt))))) 'y')) 'y' '!' 'p' 'a'
02:31:09 <s4ke> not a big fan of the unix shell as well. i work with it a lot, but automation with it is just a pain in the ass
02:31:26 <merijn> s4ke: Pointfree to me isn't about writing things shorter, it's just an extension of the idea that you can simply write "plus = (+)" instead of "plus x y = x + y"
02:31:32 <Xandaros> Seriously, though. Often pointfree makes the code really nice. Of course, you can overdo it
02:31:56 <s4ke> Xandaros: for people who know all the apis yes, that's definitely true
02:32:09 <merijn> tbh, the main reason I use pointfree code is because thinking up good names is *hard*
02:32:10 <s4ke> but for a Functional Programming 101 that's a bit too much if you overuse it
02:32:26 <s4ke> anyhow, thanks 
02:32:38 <s4ke> i think i will be back later. g2g
02:33:15 <lb5tr> Hello, do you guys have a bot that is written in Haskell?
02:33:22 <lb5tr> I mean IRC bot
02:33:27 <Xandaros> lambdabot: Hi!
02:33:36 <Xandaros> @version
02:33:37 <lambdabot> lambdabot 5.0.3
02:33:37 <lambdabot> git clone https://github.com/lambdabot/lambdabot
02:33:40 <lb5tr> cool!
02:33:43 <lb5tr> thanks
02:34:02 <lb5tr> Does it implement 'eval' function?
02:34:15 <KaneTW> sort of
02:34:17 <KaneTW> >> 1+1
02:34:20 <KaneTW> eh
02:34:23 <KaneTW> > 1+1
02:34:25 <lambdabot>  2
02:34:44 <lb5tr> thank you
02:34:46 * hackagebot streaming-commons 0.1.15 - Common lower-level functions needed by various streaming data libraries  https://hackage.haskell.org/package/streaming-commons-0.1.15 (MichaelSnoyman)
02:34:58 <KaneTW> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
02:34:59 <KaneTW> etc
02:35:00 <lambdabot>  <no location info>:
02:35:00 <lambdabot>      not an expression: ‘let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)’
02:35:05 <KaneTW> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
02:35:07 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:42:33 <lyxia> > fix ( (0 :) . (1 :) . join (zipWith (+) . tail) )
02:42:35 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:45:05 <mauke^0> > fix ( (0 :) . (1 :) . ap (zipWith (+)) tail )
02:45:07 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:45:31 <mauke^0> > fix ( (0 :) <$> (1 :) <$> (zipWith (+) <*> tail) )
02:45:34 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
03:19:47 * hackagebot hlint 1.9.25 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.25 (NeilMitchell)
03:32:08 <ChristianS> does lambdabot have a command for desugaring do blocks (similar to ?pl) ?
03:32:37 <mauke^0> yes, @undo
03:33:06 <ChristianS> mauke: ah, cool
03:52:36 <koray>  /set irc.look.smart_filter_delay 5
03:53:52 <koray>  /set irc.look.smart_filter_delay 5
03:54:28 <mauke^0> koray: ?
03:54:44 * padre_angolano just learned about pattern matching in guards :-) addMaybes mx my | Just x <- mx, Just y <- my = Just (x + y)
03:55:05 <mauke^0> addMaybes (Just x) (Just y) = Just (x + y)
03:55:11 <mauke^0> no pattern guards needed
03:55:12 <koray>  /set irc.look.smart_filter_join_unmask 30
03:55:16 <mauke^0> koray: stop it
03:55:31 <padre_angolano> mauke^0: sure, but I didn't know this construct was possible :-)
03:55:31 <koray> oh sory :)
03:56:10 <koray> i didn't notice the whitespace at the head of these commands
04:22:36 <merijn> mauke^0: You don't need pattern guards anyway
04:22:41 <merijn> mauke^0: PatternGuards is Haskell2010
04:27:56 <m1dnight_> Is it possible in haskell to make an alias for a type? I have a typechecker where I have to write a lot of `(SimpleType IntType)`, and I would like to make a sort of alias for that. I have tried `type Num = SimpleType InType` but that doesnt work.
04:28:32 <merijn> m1dnight_: That probably doesn't work because Num is the name of a typeclass
04:29:05 <m1dnight_> I tried `Numbr` as well. Error is: Not in scope: type constructor or class ‘IntType’
04:29:07 <merijn> m1dnight_: Otherwise I don't see why that wouldn't work
04:29:29 <merijn> m1dnight_: Can you lpaste a minimal example?
04:29:41 <m1dnight_> Euhm, the datatypes file is kind of big.
04:29:42 <m1dnight_> Let me see.
04:33:58 <m1dnight_> https://www.refheap.com/112020 There you go
04:34:00 <m1dnight_> same error.
04:34:51 * hackagebot posix-pty 0.2.1 - Pseudo terminal interaction with subprocesses.  https://hackage.haskell.org/package/posix-pty-0.2.1 (MerijnVerstraaten)
04:36:02 <quicksilver> m1dnight_: constructors are not types.
04:36:18 <quicksilver> m1dnight_: IntType is not a type, so you can't use it to define a type
04:36:36 <m1dnight_> So is there anyway to achieve that?
04:36:42 <quicksilver> achieve what?
04:36:43 <m1dnight_> If you understand what Im trying to do.
04:37:02 <quicksilver> if you want BoolType, IntType and UnitType to be types, make them types
04:37:08 <quicksilver> (not constructors)
04:37:38 <quicksilver> in general one of the compromises with haskell ADTs is that you dont' have a type to represent "only this constructor was used"
04:37:44 <m1dnight_> huh.
04:37:55 <m1dnight_> Im confused. I thought (Simple IntType) was a type value of the type Type
04:38:04 <m1dnight_> It is of kind *, hence a proper type, no?
04:38:25 <quicksilver> no
04:38:31 <merijn> m1dnight_: IntType doesn't have a kind, it has a type and that type is Simple
04:38:36 <quicksilver> IntType is a term - an expression.
04:38:41 <quicksilver> IntType :: Simple
04:38:56 <m1dnight_> Okay and (Simple IntType) :: Type,
04:39:02 <quicksilver> no
04:39:07 <quicksilver> "Simple IntType" is just rubbish
04:39:16 <quicksilver> that is not a meaningful juxtaposition in haskell
04:39:22 <quicksilver> Simple is a type which takes no parameters
04:39:26 <m1dnight_> data Type = Simple Simple <-
04:39:27 <quicksilver> you would never put anything to the right of it
04:39:36 <quicksilver> oh sorry
04:39:38 <m1dnight_> Unfortunate naming, though.
04:39:43 <quicksilver> my apologies
04:39:48 <m1dnight_> np np
04:39:53 <quicksilver> Simple IntType :: Type
04:39:55 <quicksilver> exactly as you said :)
04:40:11 <quicksilver> but despite the word 'Type' there, that is a value, not a type :)
04:40:29 <m1dnight_> Okay, so I could do numberType = Simple IntType then
04:40:33 <quicksilver> yes certainly
04:40:37 <quicksilver> and then numberType :: Type
04:40:38 <m1dnight_> fair enough, I guess. That declutters it a bit as well.
04:41:00 <m1dnight_> Thanks for the patience guys/ladies
04:41:07 <quicksilver> my confusion in making sense of your comment was compounded by 'Type' being a type within your program
04:41:11 <quicksilver> but values of type Type are values, not types
04:44:27 <E4xoi> quicksilver: Int :: Type, data Type = Int :p
04:46:36 <quicksilver> E4xoi: well yes
05:14:54 * hackagebot trurl 0.4.1.0 - Haskell template code generator  https://hackage.haskell.org/package/trurl-0.4.1.0 (dbushenko)
05:24:56 * hackagebot hpc-coveralls 1.0.3 - Coveralls.io support for Haskell.  https://hackage.haskell.org/package/hpc-coveralls-1.0.3 (killy971)
05:24:58 <akegalj> does anybody have experiance with haskell chart package ? I can't plot negative values.
05:54:57 * hackagebot eventstore 0.9.1.0 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.9.1.0 (YorickLaupa)
05:57:10 <hc> fyi, the questions i was asking earlier... i've created a github repository for the project now, see: https://github.com/hce/postgresql-session
06:19:58 * hackagebot dimensional 1.0.1.0 - Statically checked physical dimensions,  using Type Families and Data Kinds.  https://hackage.haskell.org/package/dimensional-1.0.1.0 (dmcclean)
06:44:59 * hackagebot wai-session-postgresql 0.1.0.0 - PostgreSQL backed Wai session store  https://hackage.haskell.org/package/wai-session-postgresql-0.1.0.0 (hc)
06:46:31 <orion> Is there a *really* simple way to serialize this to JSON?: https://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-Stats.html
06:47:50 <orion> Like, can I do a newtype deriving on GCStats with (Generic, ToJSON)?
06:48:29 <quicksilver> that wouldn't be a newtype deriving
06:48:34 <quicksilver> it would be standalone deriving
06:48:43 <quicksilver> but I see no reason you couldn't do it, the data type is exported
06:48:57 <orion> Will it work like I think it will?
06:49:04 <quicksilver> yes it should
06:49:07 <orion> Cool. :)
06:49:10 <frerich> orion: http://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson-TH.html features a 'deriveJSON' function which gets you the JSON instance and then you can use encode from http://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson-Encode.html to get a bytestring
06:49:41 <dmj> orion: you can use Generics as well
06:50:21 <ocramz> hi there
06:50:21 <orion> dmj: Aren't I using Generics when I do: newtype MyGCStats { gcStats :: GCStats } deriving (Generic, ToJSON)?
06:52:44 <ocramz> I have a few types that can exchange data with their Storable counterparts; I'd like to unify the interface with a typeclass like the following: `class Monad m => PetscObject i p h m where { initO :: i -> p -> m h;   updateH :: p -> m h;  updateP :: p -> h -> m ();   destroyO :: p -> m () } `; am I re-doing something obvious? any suggestions welcome 
06:54:38 <ocramz> (`p` above is a Storable type)
06:54:42 <dmj> orion: I don't think generalized newtype deriving is invoking the default signature... but I could be wrong
06:54:52 <dmj> orion: this is what I'm referring to http://lpaste.net/145882
06:55:23 <orion> Oh wow, I never knew you could do that.
06:55:42 <orion> Aren't those technically orphan instances?
06:56:01 <quicksilver> they are two things, orion 
06:56:07 <quicksilver> they are orphan, and they are standalone
06:56:21 <quicksilver> that's what I meant when I said "that wouldn't be a newtype deriving it would be standalone deriving"
06:56:24 <quicksilver> :)
06:56:30 <orion> Ah. :p
06:56:42 <dmj> orion: I don't receive warnings for orphans... but it would seem like the class, the instance and the data type are all separate. 
06:57:06 <dmj> Generic, GCStats, instance Generic GCStats, that is
06:57:22 <orion> dmj: Would you consider it to be "professional" to use orphans, at least in this case?
06:57:33 <quicksilver> it is necessary to use orphans
06:57:52 <quicksilver> because you are neitehr the author of 'ToJson' nor are you the author of 'GCStats'
06:58:16 <orion> Ah, in my Haskell travels I've always gotten the sense that I should avoid them if possible (but granted, it's not possible in this case).
06:58:41 <quicksilver> it is more that library authors should avoid them
06:58:55 <quicksilver> application authors a.k.a. normal programmers should not worry
06:59:02 <orion> Good point.
06:59:16 <quicksilver> ocramz: that looks horrible :) what is h? the handle to the stored object?
07:00:09 <ocramz> quicksilver : no, a Haskell-side copy of the data, let's say a Vector
07:00:28 <ocramz> quicksilver: why horrible? plz expand
07:00:38 <akegalj> how would you convert (IO a, IO a) into IO (a, a) ? I was hoping for something like sequence
07:00:41 <orion> Does GHC provide any other useful diagnostic information that can be helpful in the event of problems? I'm writing a "/status" endpoint in scotty.
07:03:00 <quicksilver> ocramz: it's horrible because there is no context to explain why so much polymorphism is desirable
07:03:14 <quicksilver> ocramz: do you really need i,p,h,m to be independently variable
07:03:28 <quchen> akegalj: I don't know of anything nice other than the straightforward solution
07:03:52 <frerich> Hm, wasn't there a Haskell package which provided some HTTP server which can be linked into applications in order to connect to them at runtime and inspect various statistics?
07:03:53 <ocramz> quicksilver: good point, no, in fact for every `p` there is a distinct `h` and `i`
07:04:22 <dmj> orion: browsing 'base' haddocks under 'GHC' might show some things
07:04:36 <Xeironis_> I was just looking into OpenGL textures, and it looks like I need the image data in an array referenced by a `Ptr a'. Is there some haskell library which would let me load an image like that or do I need to use the C FFI and load an image that way?
07:04:42 <quchen> :t uncurry (liftA2 (,)) -- if you feel like golfind, akegalj 
07:04:43 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
07:04:55 <quchen> golfing*
07:06:01 <quchen> frerich: rkg?
07:06:03 <quchen> ekg*
07:06:55 <ocramz> Xeironis_ : usually there are `with-` constructs for that
07:07:38 <frerich> quchen: That's the one, awesome! I would have never remembered *that* name! Thanks!
07:07:45 <ocramz> quicksilver: could you suggest improvements to the above?
07:08:17 <Xeironis_> ocramz: Do you mean in libraries that can be used for loading images?
07:08:18 <quicksilver> ocramz: can you give me one concrete example too?
07:08:21 <ocramz> e.g. functional dependencies? it's my first stab at library design and I'm frankly lost in the options
07:09:13 <quicksilver> ocramz: two concrete examples might be even clearer, come to think of it :)
07:09:24 <Xeironis_> oh, wait, I see
07:09:57 <ocramz> Xeironis_ : I'd guess in the OpenGL binding; a `withX` takes the form `f x -> (Ptr x -> IO a) -> IO a`
07:10:15 <Xeironis_> okay, thanks
07:10:22 <Xeironis_> I'll see if I find something
07:11:54 <akegalj> quchen: thnx
07:12:17 <yesza_> Yo, I'm using a filter that checks the heads of lists of lists, but I want to add a condition that if the list is null, it skips this and checks the next, essentially im asking how to do you add a not null as an extra argument to a filter
07:12:19 <yesza_> Any ideas?
07:13:00 <merijn> yesza_: Just make it a double filter?
07:13:09 <merijn> yesza_: "filter pred . filter (not . null)" ?
07:13:51 <merijn> yesza_: Alternatively "filter (\l -> case l of [] -> False; (x:_) -> pred x)"
07:14:02 <merijn> In which case you should really move the function to a where clause
07:14:06 <lpaste_> ocramz pasted “polymorphic Storable interface” at http://lpaste.net/145884
07:14:13 <ocramz> quicksilver: see ^
07:15:21 <opqdonut> yesza_: one more option is to do "filter (liftA2 (&&) (not.null) pred) xs"
07:15:26 <opqdonut> but the double filter is nicer
07:16:40 <merijn> ocramz: I would use associated type family over MultiParamTypeclass
07:17:46 <ocramz> merijn: could you show an example?
07:18:06 <dmj> Cale: think I figured out why there isn't a default Generic implementation for Arbitrary, arbitrary :: Gen a, there's no value present to satisfy 'from'
07:18:45 <quicksilver> ocramz: what is MatInfo? the dimensions of the thing?
07:19:21 <merijn> ocramz: What's the 'h' type in those functions? The array?
07:19:25 <ocramz> quicksilver, for example. A type with some numbers inside. VecInfo has a different structure (# and size of fields, etc)
07:19:45 <ocramz> merijn: it's the type of a Haskell-side copy of the data, let's say `Vector a`
07:19:51 <quicksilver> I'm not sure this polymorphism is going to buy you much
07:20:01 <quicksilver> but I would make the class jsut on 'Mat' and 'Vec'
07:20:11 <quicksilver> and I'd make 'MatInfo' and 'Matrix Double' associated types
07:22:08 <ocramz> quicksilver: as in TypeFamilies? like `class Potato a where type PotatoType a` ?
07:22:14 <merijn> ocramz: Yeah
07:22:28 <ocramz> ok
07:22:45 <merijn> I kinda dislike multi-param + fundeps
07:24:17 <CodeWar> Can I ask a basic question about Functional Programming here? How do large programs maintain state. In OO, an object has state and behaviour. How does it work in Functional designs
07:25:13 <ocramz> merijn: library design newb here, it's such a mess
07:25:25 <Xeironis_> CodeWar: There are several options
07:26:04 <Xeironis_> CodeWar: For example, say you'd write a loop in an imperative language, than you might write a recursive function that contains state as one of the arguments
07:26:22 <Xeironis_> CodeWar: each time the function calls itself, it changes that argument and thus changes the state
07:27:03 <Xeironis_> CodeWar: Another option that can be very elegant is using Monads, especially the State Monad, as the name would say, there are many explanations about how that works online, it feels a little like imperative programming
07:28:17 <Xeironis_> CodeWar: apart from that, there are also ways to make mutable variables like you would in impertive programming
07:28:18 <CodeWar> Xeironis_: I see. and in option (1) does State contain pointer to other States? Sort of like what struct A { struct B * b }; Or are there other ways of doing this
07:28:23 <merijn> CodeWar: It's certainly possible and reasonable to write something that uses a somewhat "object oriented" design at the high level. But in general I just tend to think in terms of 1) data structure and 2) operations
07:28:51 <davean> rt/273n265e.png: PNG image data, 16384 x 16384, 8-bit grayscale, non-interlaced
07:28:51 <merijn> CodeWar: Can you give an example application? What you do is rather application specific
07:28:53 <davean> art/273n270e.png: PNG image data, 16384 x 16384, 8-bit grayscale, non-interlaced
07:28:55 <davean> art/274n268e.png: PNG image data, 16384 x 16384, 8-bit grayscale, non-interlaced
07:28:57 <davean> art/274n269e.png: PNG image data, 16384 x 16384, 8-bit grayscale, non-interlaced
07:28:59 <davean> art/274n270e.png: PNG image data, 16384 x 16384, 8-bit grayscale, non-interlaced
07:30:06 <CodeWar> merijn: Consider I am writing an Operating System kernel. I have a Context Class (corresponds to the Application Processes) Each Context has a pointer to Memory class. Memory class contains information about the Address Space, Page table etc. Lets keep it at this. The complexity arises when there are different CPUs, each have a subtype of Memory class 
07:31:13 <merijn> CodeWar: I don't think haskell is very suitable for writing OS kernels atm. It's not impossible, but it will be rather painful
07:31:14 <CodeWar> Memory subtypes will override base class behaviour like writing Page tables differently. Context has behaviour, Memory has behaviour. How would the corresponding functional design be
07:31:45 <merijn> CodeWar: Although, tbh, this OO design would probably already be rather painful and unrealistic for an OO language too
07:32:01 <hodapp> large designs with OO tend to be far worse than, say, procedural
07:32:12 <hodapp> some people just have this strange notion that they're not
07:32:25 <merijn> hodapp: Not really, large designs tend to be rather actor based (which is basically OO as it was originally intended)
07:32:53 <hodapp> merijn: OO was *originally* intended as basically actor based, yes
07:33:51 <CodeWar> merijn: the "Haskell not suitable for kernel" arises because of some reason specific to Haskell or does that apply to any functional language. 
07:34:16 <merijn> CodeWar: Specifically haskell and specifically current implementations of haskell
07:34:21 <CodeWar> I really don't know how to break a large OO program to functional. Any articles providing a breakdown of this would be helpful
07:34:37 <merijn> CodeWar: There was a group in Oregon working on a dialect of Haskell specifically designed for systems programming
07:34:54 <hodapp> sounds like Galois :P
07:34:56 <CodeWar> some dudes at Intel? :-)
07:35:04 <merijn> CodeWar: Basically, most of the current runtime system/threading/etc. is currently designed on the idea that there's an underlying OS
07:35:14 <merijn> CodeWar: Galois together with Portland State University
07:35:20 <merijn> Not sure if the project is still alive
07:35:33 <Xeironis_> Conceptually, this would be rather easy to design though, wouldn't it? You'd have a Context type which contains a specific instance of a Memory typeclass
07:35:35 <merijn> People have written bare metal runtimes for haskell (see House and HaLVM)
07:35:37 <hodapp> merijn: are you talking about Ivory?
07:35:41 <merijn> hodapp: Habit
07:35:43 <hodapp> yeah, HaLVM is also from Galois
07:35:49 <merijn> hodapp: Ivory is a DSL for generating C
07:35:58 <merijn> hodapp: Habit was supposed to compile and run directly on bare metal
07:36:10 <hodapp> merijn: I know, I'm an Ivory contributor
07:36:13 <Xeironis_> Do Haskell typeclasses count as something that is part of functional programming in general?
07:36:22 <hodapp> merijn: but they refer to it as an EDSL for 'safe systems programming'
07:36:31 <merijn> CodeWar: You could build threading/concurrency into a bare metal runtime, but you'd have to reimplement a complete bare metal runtime from scratch
07:36:31 <CodeWar> Xeironis_: and there would be separate functions operating on Memory and Context types? How would one get polymorphism? Some form of type specialization I suppose?
07:36:32 <jeltsch> Xeironis_: No.
07:36:51 <jeltsch> Xeironis_: Scheme is also functional and does not even have a static type system.
07:36:59 <CodeWar> merijn: ignore kernel and systems for now, it was a bad example on my part. I am more curious about Functional program breakdown 
07:37:00 <Xeironis_> yeah, that makes sense
07:37:40 <Xeironis_> CodeWar: a typeclass specifies which functions (I think they are even called methods for typeclasses) have to be implemented and each instance implements them
07:38:03 <Xeironis_> so kind of like OO interfaces
07:38:25 <CodeWar> I see and the polymorphically dispatched based on the type of input arguments?
07:38:33 <CodeWar> is this runtime or static polymorphism
07:39:09 <Xeironis_> I think static
07:39:12 <jeltsch> CodeWar: Dispatching can also happen based on the type of output arguments. Advantage over OO! :-) 
07:39:29 <hodapp> most OO also loves single-dispatch, for whatever ass-backwards reason
07:39:42 <jeltsch> CodeWar, Xeironis_: Whether it is static or dynamic depends on the implementation.
07:39:49 <jeltsch> The Haskell standard leaves this open.
07:39:50 <CodeWar> jeltsch: sounds a lot like C++ function partial specialization
07:39:51 <Xeironis_> ah, I see
07:40:14 <jeltsch> Typically, dispatch is dynamic.
07:40:40 <jeltsch> But static calls can be generated if the types are known at compile time.
07:41:11 <jeltsch> And there was at least one experimental compiler that did whole program analysis, doing all the dispatch at compile time.
07:45:31 <kras> :t negate
07:45:34 <lambdabot> Num a => a -> a
07:46:10 <kras> No instance for (Num Primary) arising from a use of ‘negate’
07:46:17 <merijn> GHC will already inline pretty much all statically known typeclass calls
07:46:33 <kras> why do I get this when :t negate says
07:46:35 <kras> :t negate
07:46:37 <lambdabot> Num a => a -> a
07:46:44 <ocramz> why does flycheck-mode in Emacs simply turn off sometimes?
07:47:19 <merijn> kras: Well, waht else what you get?
07:47:31 <merijn> kras: Well, does Primary have a Num instance?
07:48:31 <kras> I have data Primary = Num Int | Iden String
07:48:38 <Ankhers> ocramz: I have never seen it just turn off. Usually there is some warning in the *Warnings* buffers. Usually because there are too many issues.
07:48:47 <hodapp> merijn: in what cases must it use that run-time dictionary thingy?
07:48:59 <geekosaur> kras: that is not a Num instance
07:49:09 <merijn> hodapp: Polymorphic recursion or generic functions
07:49:10 <Ankhers> ocramz: At least that is the reason it turns off for me.
07:49:18 <geekosaur> that is a data constructor named Num, which is completely different from the Num typeclass
07:49:24 <ocramz> Ankhers: there is this errors/warnings counter , like 0/3. It disappears
07:49:29 <merijn> hodapp: i.e. "foo = (+)" <- can't specialise here because it might be called with an unknown instance
07:49:44 <Ankhers> ocramz: Is there anything in the *Warnings* buffer?
07:50:11 <hodapp> merijn: oh, to where 'foo' is still just 'Num a => a -> a -> a'?
07:50:15 <merijn> hodapp: Yeah
07:50:17 <kras> geekosaur: isn't Int an instance of Num
07:50:26 <Denommus> what's the equivalent to the `either` function for ExceptT?
07:50:31 <geekosaur> kras: but that is not an Int, it is a Primary
07:50:41 <merijn> Unless foo gets inline somewhere where you know 'a' is Int, but that might not happen if foo is very large and thus not a proper target for inlining
07:50:44 <ocramz> Ankhers: there is no such buffer at present
07:51:02 <geekosaur> and you do not have a Num instance (and probably can't have a sane one because of the Iden constructor)
07:51:15 <Ankhers> ocramz: Are the errors / warnings displaying below your mode line?
07:51:47 <geekosaur> kras: given "data Primary = Num Int", (Num 5) is a value of type Primary. it does not have a Num instance
07:52:00 <ocramz> Ankhers: only in certain buffers
07:52:28 <Ankhers> ocramz: Where do you see the 0/3?
07:52:35 <ocramz> in one of the good ones
07:52:53 <kras> geekosaur: ohhh, I got it
07:53:00 <kras> geekosaur: thanks a lot
07:53:00 <ocramz> makes me feel so .. exposed
07:53:06 <Ankhers> ocramz: But where within the buffer do you see it?
07:53:08 <merijn> hodapp: This is why, for example Ur/Web is so fast, it ALWAYS inline polymorphic functions therefore never having dynamic dispatch
07:53:29 <hodapp> quit reminding me that I've still refused to learn Ur/Web
07:53:43 <merijn> hodapp: So do I :p
07:53:52 <ocramz> Ankhers: (Haskell FlyC 0/3 Ind Doc) is the modeline, right?
07:54:21 <Ankhers> ocramz: Yes. Let me test something real quick.
07:56:13 <merijn> hodapp: He had a talk at ICFP on "how to write fast optimising compilers" explaining this stuff
07:56:34 <Ankhers> ocramz: That 0/3 is supposed to say you have 0 errors and 3 warnings. I don't know how it decides on that. My file has ~170 warnings, but it says 0/4.
07:57:37 <ocramz> Ankhers: there must be a hierarchy of warning levels, it's just that I hate poking at the emacs internals
07:59:52 <Ankhers> ocramz: Maybe someone in #emacs would be able to help a little more. Unfortunately, I'm not overly familiar with flycheck. I just use it :(
08:00:08 <ocramz> Ankhers: yeah, I'll try; thanks :)
08:00:16 <kras> geekosaur: realize now that Num is a really bad name for a data constrcutor, really got confused by the error message
08:05:00 <merijn> 8
08:10:23 <sidek> hey, quick question! Is there an equivalent to ‘race’ that can race more than two operations? I ask because I have around 4 TVars,  most of which will always be empty. I would like to have a function which attempts to check all the TVars and do something whenever any one of them fills up. Race-like operations seem like the nicest way to do this, but I’m not sure how to extend it enough…
08:12:32 <merijn> sidek: Look at the async library?
08:13:09 <merijn> sidek: That has a "waitAny" operation
08:13:11 <quicksilver> TMVars?
08:13:41 <sidek> alright, I’ll check those out
08:13:42 <sidek> thanks!
08:13:57 <quicksilver> no, I was just askinga  quesiton :)
08:14:03 <quicksilver> TVars can't  be empty, did you mean TMVars?
08:14:07 <mauke^0> race a (race b c)?
08:15:02 <sidek> I actually meant TChans, not sure why I typed TVar ^^
08:15:32 <quicksilver> would it be a bad idea to just have 4 threads, each thread blocked on a channel?
08:15:35 <merijn> sidek: oh!
08:15:37 <quicksilver> that's the way I'd do it.
08:15:42 <merijn> sidek: You want something else entirely
08:15:54 <merijn> sidek: You just want <|> (aka orElse)
08:16:20 <merijn> sidek: Reading from an empty TChan does retry (which results in blocking if there's no alternative)
08:16:23 <sidek> ohh 
08:16:27 <sidek> ok!
08:16:30 <sidek> thank you very much!
08:16:44 <merijn> But "x <|> y" says "do 'x', if it retries, try 'y'"
08:16:59 <merijn> If 'y' also retries, retry the entire operation
08:18:44 <sidek> maybe more threads would be nicer — but for what I’m making I think it would make the code really hard to follow, so I think I’ll try out orElse! Thank you guys very much again
08:19:13 <quicksilver> if you have 4 completely independent operations which should just proceed as soon as stuff comes in
08:19:20 <quicksilver> that then sounds like 4 threads reading on 4 Chans
08:19:32 <quicksilver> if you want to "do the first thing that comes in and then, do this common thing"
08:19:48 <quicksilver> then it sounds like one thread <|>'ing on the TChans like merijn said.
08:20:19 <merijn> Racing four chans is just "foldr (<|>) retry" over a list of STM operations
08:20:46 <merijn> Also, why have 4 channels instead of having 4 threads writing to one TChan?
08:20:57 <quicksilver> maybe they have different types, merijn ?
08:21:12 <merijn> quicksilver: Right, but then <|> won't work without messy wrapping either :)
08:21:17 <mauke^0> ADT
08:21:24 <quicksilver> wrapping might not be that messy
08:21:27 <Denommus> I'll try asking again: what's the equivalent to `either` in `ExceptT`?
08:21:37 <merijn> Denommus: runExceptT?
08:22:24 <merijn> Or something based on catchE, I guess?
08:22:42 <quicksilver> (readTChan ta >>= do_a_thing) <|> (readTChan tb >>= do_b_thing)
08:22:55 <quicksilver> Denommus: see also mapExceptT and withExceptT
08:23:04 <quicksilver> depending which bits you have to change
08:23:07 <merijn> quicksilver: That might have different semantics
08:23:17 <merijn> quicksilver: Because if do_a_thing retries you also move to the right
08:23:26 <quicksilver> merijn: an excellent point.f
08:23:42 <quicksilver> merijn: and whether that is the right thiing is kind of critical to whether this is what sidek wants :)
08:23:48 <sidek> it’s an irc like structure — there are several channels, users can join some of them, and I’ve represented this by having BroadcastTChans for each channel, and each ‘user’ who wants to duplicates the TChan and can read off of it/ quit it without having to interact again with the channel thread 
08:24:19 <quicksilver> multiple users of IRC channels sounds like multiple idependent threads to me
08:24:24 <Denommus> so, `exceptT fe fa = withExceptT fe . fmap fa`?
08:24:28 <quicksilver> just guessing from your description
08:24:41 <quicksilver> Denommus: yes, if htat's what you want :)
08:24:44 <sidek> each user is on their own thread, but should I also then probably run one thread per channel they’re in?
08:24:45 <merijn> quicksilver: He yes, but he has one user reading from multiple broadcast chans
08:24:54 <quicksilver> Denommus: that only works if ExceptT is at the top level
08:24:57 <quicksilver> of the stack
08:25:40 <Denommus> quicksilver: oh, it might run the monadic computation more than once, right?
08:26:30 <quicksilver> Denommus: no, I don't think so
08:26:53 <merijn> sidek: I'd have one Chan per user and when they join a channel fork a thread that copies from the channel to the user's channel and then when you leave you kill the thread
08:26:53 <quicksilver> all it does is alter the value and the error, you can imagine that happens "afterwards:
08:28:01 <Denommus> quicksilver: ah, I only understood what you said now. You're saying that if ExceptT is nested another monad transformer it won't work, right?
08:28:03 <sidek> alright! thanks!
08:29:03 <quicksilver> Denommus: yes, exactly.
08:29:53 <quicksilver> I think there is a combinator to apply that 'deeply in the stack'
08:29:54 <quicksilver> here:
08:29:54 <quicksilver> https://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html
08:29:57 <Denommus> quicksilver: are there equivalent generic operations?
08:30:00 <quicksilver> but I'm not quite sure which one it is
08:30:50 <quicksilver> hoist I think.
08:31:04 <quicksilver> well you want to hoist the 'withExceptT' part
08:31:12 <quicksilver> the fmap part you apply before or after the hoist
08:31:15 <quicksilver> (doesn't matter which)
08:39:26 <hackrilege> How is traverse not just map?
08:40:19 <Xeironis_> On this page, there is a reference to a type `Pixels', in surfaceGetPixels, but it's not hyperlinked. Is there a way to find out where that's defined? http://hackage.haskell.org/package/SDL-0.6.5.1/docs/Graphics-UI-SDL-Types.html
08:40:28 <hackrilege> What does traverse add to foldable?
08:40:41 <merijn> hackrilege: Rebuilding the original structure
08:41:03 <merijn> hackrilege: traverse is mapM, i.e. map with effects
08:42:32 <Xeironis_> nevermind, I found the source
08:42:43 <Xeironis_> the source code, that is, not the source of the type
08:42:59 <hackrilege> So it's a Monad thing. I have applicative functors, which could be monads as i can define join, but i have found no use for this in my case. Could we speak about when it is a good time to use foldable and when to define traverse?
08:43:42 <hackrilege> The key reason for avoiding Monad is that there is no IO
08:43:56 <hackrilege> So no effects i think. It's all pure
08:44:04 <merijn> Monads have nothing to do with effects
08:44:06 <merijn> And IO is pure
08:44:15 <hackrilege> Doh
08:44:19 <merijn> (Well, FSOV of nothing)
08:44:26 <hackrilege> Ok
08:44:49 <hackrilege> I though the IO Monad was for handling effects
08:45:11 <merijn> IO is for handling IO, the fact that it's a Monad is just a happy coincidence that provides a convenient interface
08:45:49 <merijn> It's perfectly possible to have haskell style handling of IO without typeclasses or Monads
08:46:02 <quicksilver> I would personally say "Applicative is every bit as much about effects as Monad is, it is just a more restricted interface to them"
08:46:14 <quicksilver> but that does depend on a specific definition of 'effect'
08:46:20 <quicksilver> curse these words and their meanings
08:46:40 <hackrilege> So i have a graph where i used to have a list. I was using unzip and zipWith. I guess i can emulate this fine with applicative, but i films on it too so maybe it should be foldable. When would it be obvious that out would be Traversable?
08:46:47 <merijn> The difference between Applicative and Monad is that the choice of future "effects" can't depend on the result of earlier effects
08:48:12 <akegalj> is there a function like splitOn :: Int -> [a] -> [[a]] , splitOn 2 "banana" = ["ba", "na", "na"] ?
08:48:23 <hakrilege> Sorry i went through a tunnel
08:48:35 <mauke^0> > chunksOf 2 "banana"
08:48:36 <lambdabot>  ["ba","na","na"]
08:48:47 <akegalj> mauke^0: thnx
08:49:42 <hakrilege> Last message i got was merinj "the difference between"
08:50:24 <Xeironis_> that was the last message for you
08:50:30 <hakrilege> Thanks
08:50:58 <mauke^0> there are channel logs; see /topic
08:51:00 <hakrilege> So when does one use Traversal?
08:51:08 <mauke^0> really handy when you get disconnected
08:51:14 <Xeironis_> Are the channel logs updated in real time?
08:51:25 <mauke^0> yes
08:51:28 <Xeironis_> cool
08:51:33 <mauke^0> or fake time
08:51:38 <mauke^0> I'm not sure how to tell the difference
08:51:56 <Xeironis_> You'll know it when you see it
08:54:10 <quicksilver> hakrilege: Traversable is a single, canonical, Traversal
08:54:21 <hakrilege> It's what you replace real time with when you steel it
08:54:44 <hakrilege> I don't understand how map it's not a single canonical traversal
08:54:45 <quicksilver> the type-system guarantees that it has to traverse every instance of the type 'a' which is parametrised in the signature
08:55:03 <quicksilver> "map" is also single and canonical in precisely this sense, yes.
08:55:23 <quicksilver> you can however write *other* Traversals which are not this one - and only traverse some elements.
08:55:36 <hakrilege> So since my collection has fmap which maps over the innards nicely, why traverse?
08:55:48 <quicksilver> hakrilege: because fmap can't let you apply effects at each point
08:56:25 <hakrilege> So it's for collections of monads?
08:56:29 <quicksilver> no
08:56:44 <quicksilver> i'ts for applying an effect (Applicative and, therefore, Monadic) at every item in the collection
08:56:51 <quicksilver> and constructing a new result.
08:57:22 <hakrilege> But functors are monads
08:57:28 <quicksilver> no they are not.
08:57:35 <Zekka|Sigfig> Nah, monads are functors
08:57:39 <quicksilver> quite
08:57:50 <hakrilege> OK oops
08:58:14 <hakrilege> Applicative then too are not
08:58:30 <hakrilege> (quicksilver) i'ts for applying an effect (Applicative and, therefore, Monadic) at every item in the collection
08:58:34 <quicksilver> > traverse (\i -> if i > 0 then Just i else Nothing) [1,2,3,4]
08:58:36 <lambdabot>  Just [1,2,3,4]
08:58:39 <quicksilver> > traverse (\i -> if i > 0 then Just i else Nothing) [1,-2,3,4]
08:58:41 <lambdabot>  Nothing
08:58:43 <quicksilver> boom.
08:59:03 <quicksilver> that is a kind of "check everything is non-negative" traversal
08:59:10 <quicksilver> using the "effect" of the Maybe applicative.
08:59:24 <hakrilege> So here you did some concat thing
08:59:34 <quicksilver> and the container I am traversing is the [a] container.
08:59:39 <quicksilver> No, there was no concat thing.
08:59:44 <hakrilege> Like a fold
08:59:52 <quicksilver> it is a bit like a fold, certainly
08:59:59 <Zekka|Sigfig> traverse is kind of like an applicativier map
09:00:04 <Zekka|Sigfig> :t traverse
09:00:06 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:00:24 <Zekka|Sigfig> Compare (a -> b) -> t a -> t b
09:00:42 <orion> In the FFI, what's the effective difference between Ptr CCHar and Ptr Word8?
09:00:47 <Zekka|Sigfig> (and also compare: (a -> f b) -> t a -> t (f b))
09:00:57 <quicksilver> orion: CChar is 32 bit IIRC
09:01:06 <hakrilege> 1 sec
09:01:08 <quicksilver> orion: but the types of Ptrs are essentially hints, you can cast them.
09:01:27 <srhb> No, CChar is just CChar Int8
09:01:35 <srhb> (I think.)
09:01:52 <quicksilver> srhb: is right.
09:02:06 * quicksilver apologises
09:02:13 <Zekka|Sigfig> hakrilege: FWIW, if you don’t know how the IO monad works don’t worry about this, because it’s a little confusing, but I started seeing why Foldable/Traversable were useful when I had to do things like printing every string in a collection
09:02:19 <orion> So, CChar is signed and Word8 is unsigned?
09:02:36 <Zekka|Sigfig> (I didn’t learn Foldable/Traversable until I was already writing nontrivial personal projects in Haskell, so I knew IO pretty well)
09:03:12 <Zekka|Sigfig> traverse is basically ‘map’ followed by an operation that moves the effect to the outside of the Traversable collection
09:03:39 <quicksilver> traverse is equivalent to sequenceA . fmap, yes
09:03:49 <quicksilver> although it can invariably be defined directly
09:03:56 <quicksilver> and you might imagine it's more efficient that way
09:04:00 <Zekka|Sigfig> :t sequenceA
09:04:01 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
09:04:16 <Zekka|Sigfig> this is the op that does the flippy business
09:04:38 <quicksilver> orion: I guess so, yes, although again the type of ptr is just a hint
09:04:48 <quicksilver> orion: only the C API you are binding to knows what the raw bytes really mean :)
09:05:17 <Zekka|Sigfig> > sequenceA [Just 1, Just 2, Just 3]
09:05:18 <lambdabot>  Just [1,2,3]
09:05:24 <Zekka|Sigfig> > sequenceA [Just 1, Nothing, Just 3]
09:05:28 <lambdabot>  Nothing
09:05:37 <hakrilege> OK back
09:06:18 <mnoonan> how come sequence kept the Monad-specialized type after the AMP?
09:06:41 <hakrilege> So sequence executed action
09:07:00 <ChristianS> is there a more succinct/idiomatic way to write this? -> either Left (Right . fromJsonTop) $ decodeLenient bs
09:07:14 <ChristianS> i.e transform if Right, return unchanged otherwise
09:07:20 <quicksilver> ChristianS: fromJsonTop <$> decodeLenient bs
09:07:37 <quicksilver> hakrilege: you can think that if you like
09:07:38 <Zekka|Sigfig> hakrilege: Yeah, sequenceA takes a container full of applicative actions and uses knowledge about the container to turn it into an action with a container of their results
09:07:42 <ChristianS> quicksilver: ah, of course, thanks
09:07:53 <quicksilver> it's close to say 'sequence joins a bunch of small actions into a bigger action which retursn all their results together'
09:08:20 <quicksilver> mnoonan: they moved a bunch of functions from Data.Foldable etc into the Prelud
09:08:29 <hakrilege> So if i don't find it natural to sequence the contents of my graph type then it's probably not a traversal
09:08:34 <hakrilege> ?
09:08:42 <quicksilver> mnoonan: the only things which 'changed type' were those things which existed in the prelude already and also existed with a generalised type in Data.Foldable
09:09:05 <quicksilver> mnoonan: since the generalisation of sequence was called sequenceA, it didn't change.
09:09:12 <Zekka|Sigfig> hakrilege: IMHO if this operation makes sense, you should probably consider making your type a traversable
09:09:19 <Zekka|Sigfig> If it doesn’t make sense your type is probably not a traversable
09:09:27 <quicksilver> hakrilege: what does your type look like?
09:10:39 <hakrilege> It's a graph
09:11:29 <quicksilver> :)
09:11:37 <quicksilver> a graph can be many things to many people
09:11:39 <hakrilege> data Graph a = Graph a [Graph]
09:11:50 <hakrilege> Lists neighbours
09:11:54 <quicksilver> data Graph a = Graph a [Graph a] ?
09:11:59 <Zekka|Sigfig> Oh yeah. I can think of some useful ways to make that Traversable — although I think you dropped an ‘a’
09:12:02 <hakrilege> Yeh sorry
09:12:12 <quicksilver> is it cyclic then?
09:12:18 <quicksilver> because really that's just a tree
09:12:26 <hakrilege> It is cyclic yes
09:12:32 <quicksilver> ok, then don't make it Traversable
09:12:41 <quicksilver> because traverse will necessarily loop
09:12:42 <Zekka|Sigfig> If it’s cyclic it might be hard to guarantee your Traversable ops terminate
09:12:48 <quicksilver> but how does your fmap instance not loop? :)
09:13:01 <quicksilver> to be honest cyclic data structures are not that convenient.
09:13:08 <Zekka|Sigfig> quicksilver: I suspect laziness handles it for him!
09:13:19 <quicksilver> a cyclic data structure is really an infinite data structure.
09:13:23 <quicksilver> Zekka|Sigfig: ah yes, good point.
09:13:36 <quicksilver> but it re-does the work each time you visit a new copy of the same node.
09:13:57 <Zekka|Sigfig> There’s other ways to represent a graph of course: data Graph label a = Graph [(label, a)] [(label, label)]
09:14:25 <hakrilege> Actually it's more like data Graph a Graph (Set (a),Map (Int,Int)) storing values and a corresponding map of edges
09:14:33 <Zekka|Sigfig> That representation can deal with cycles without breaking a sweat, and it’s really easy to define stuff like traverse on it — although it’s not a recursive data structure, so pick your poison
09:14:37 <hakrilege> Dropped an =
09:15:40 <Zekka|Sigfig> hakrilege: Hm. I’m not quite sure how that represents a graph, because I don’t see how the edges identify what ‘a’ they correspond to, but that is probably easier to define Traversable for
09:16:09 <shersh> Hello everyone! I'm studying lens now. And I'm wonder: is there way to define `view :: Lens' s a -> s -> a` in terms of `over :: Lens' s a -> (a -> a) -> s -> s` for simple lens: `type Lens' s a = forall a . Functor f => (a -> f a) -> s -> f s` ?
09:16:15 <Zekka|Sigfig> Except that sets aren’t functors — if you used a structure that allowed duplicates you could probably get away with it
09:16:49 <quicksilver> shersh: no.
09:17:42 <Zekka|Sigfig> hakrilege: The tricky bit is probably Applicative and Monad, because you also want to maintain the number of ‘a’s
09:17:57 <shersh> qucksilver: Maybe some informal explanations? And what about real lens: `type Lens s t a b = forall f . Functor f => (a -> f b) -> s -> f t` ?
09:18:01 <hakrilege> I presented cyclicTree a = cyclicTree a [cyclicTree a] [cyclicTree a], where the first list is all neighbours, or an extended list of neighbours of neighbours for use in a local stencil, and the second list giving a minimal spanning tree
09:18:18 <Zekka|Sigfig> You could possibly take a cue from ZipList to get your Applicative behavior, but I don’t know exactly how you would do Monad behavior with that representation
09:18:44 <aweinstock> :t flip over id
09:18:46 <lambdabot> Setting (->) s t b b -> s -> t
09:18:49 <Zekka|Sigfig> Although the ZipList behavior would be confusing because the order you list graph nodes in generally isn’t significant afaik
09:18:53 <aweinstock> :t view
09:18:54 <lambdabot> MonadReader s m => Getting a s a -> m a
09:19:04 <quicksilver> shersh: you can't write view using over, whichever lens representation you choose.
09:19:09 <s4ke> hi. is there any way to change the value of an already existing state?
09:19:20 <s4ke> or well like put/get
09:19:23 <s4ke> but for states
09:19:25 <quicksilver> shersh: it is a bit hard to prove a negative, sometimes :)
09:19:34 <Zekka|Sigfig> hakrilege: This stuff is making me suspicious your structure isn’t Traversable after all!
09:19:43 <hakrilege> Monad join is flatten
09:19:59 <quicksilver> shersh: intuitively, 'over' just lets you apply a function to the 'a' without knowing where it is, or even that it exists.
09:20:01 <hakrilege> It folds inner graphs
09:20:05 * hackagebot prelude-edsl 0.1 - An EDSL-motivated subset of the Prelude  https://hackage.haskell.org/package/prelude-edsl-0.1 (EmilAxelsson)
09:20:11 <quicksilver> shersh: 'over' is definable even for non-lens structures
09:20:12 <Zekka|Sigfig> Might still be Foldable
09:20:21 <quicksilver> shersh: such as ones which don't have a value in at all :)
09:20:35 <hakrilege> How could it be foldable but not traversable?
09:21:01 <shersh> qucksilver: Ok, I just believe it :) Because I couldn't find the way to do it for some time. But other combinations works fine.
09:21:10 <quicksilver> > over mapped (+1) Nothing
09:21:11 <lambdabot>  Nothing
09:21:22 <quicksilver> ^^ over works there, but view can never work because there is no number to view.
09:21:25 <aweinstock> :t mapped
09:21:26 <lambdabot> (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
09:21:32 <Xeironis_> would you consider something like ((f .) .) . g readable, given appropriate function names?
09:21:48 <hakrilege> No
09:21:49 <quicksilver> Xeironis_: I avoid them although they are readble with practice.
09:21:51 <Zekka|Sigfig> hakrilege: Actually, hold up — I should probably bow out since I’m at work, but I think I was wrong aobut that. Traversable only requires the Traversable type to be a Functor, even though many of the Traversable functions operate on Applicatives
09:21:55 <Xeironis_> ok
09:22:11 <Xeironis_> I'm mostly just too lazy to come up with variable names :P
09:22:27 <quicksilver> Xeironis_: oh, did you jsut mean `f` and `g` ?
09:22:37 <Xeironis_> no
09:22:56 <Xeironis_> I mean instead of \name1 name2 name3 -> f $ g name1 name2 name3
09:23:11 <Zekka|Sigfig> But the difference between Traversable and Foldable afaik is that Traversable requires the collection type to be a Functor, while Foldable doesn’t — and Traversable gives you a thing like ‘fmap’, while Foldable only gives you a thing like ’foldr'
09:23:14 <hakrilege> Applicative is simple enough, you can apply a graph the same shape, if functions, as a function
09:23:27 <hakrilege> Of functions*
09:23:41 <Zekka|Sigfig> hakrilege: Yeah, but I’m not sure you can do it in general — e.g. for graphs of different shape
09:23:47 <quicksilver> Xeironis_: right. Yes. I wouldn't, personally
09:23:51 <Xeironis_> ok
09:24:16 <quicksilver> the intuitive difference between Foldable and Traversable is that Foldable can't rebuild the structure
09:24:18 <hakrilege> It's OK for map though
09:24:23 <quicksilver> Foldable can give you all the elements, but that's all
09:24:32 <quicksilver> Traversable can let you rebuild the same structure with modified elements
09:24:39 <quicksilver> (but never 'alter' the structure)
09:24:54 <Zekka|Sigfig> quicksilver: I like your version better, I’ll have to steal it for the next time someone asks me this
09:25:04 <hakrilege> You copy the shape it's fine, repeating the same function at each node, so fmap is fine, and pure comes easily in the same way
09:25:05 * hackagebot prelude-edsl 0.1.1 - An EDSL-motivated subset of the Prelude  https://hackage.haskell.org/package/prelude-edsl-0.1.1 (EmilAxelsson)
09:25:09 <quicksilver> the order is Foldable -> Functor -> Traversable
09:25:13 <quicksilver> Foldable just gives you the elements
09:25:19 <quicksilver> Functor lets you edit them in-place
09:25:19 <hakrilege> Yeh
09:25:27 <quicksilver> Traversable lets you apply an effecti n each place
09:25:36 <hakrilege> I don't get that
09:25:46 <hakrilege> I really don't understand what that means
09:26:05 <Zekka|Sigfig> :t sequenceA
09:26:06 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
09:26:18 <quicksilver> if you have a concrete container which supports Functor it will support Traversable
09:26:23 <Zekka|Sigfig> hakrilege: This says that if you have a structure containing a bunch of Applicative actions, you can get an Applicative action containing the structure
09:26:29 <hakrilege> Ask it says to me is, something to do with monads, possibly IO. That's the only time iv heard effect used as a term
09:26:38 <hakrilege> All not ask
09:26:55 <quicksilver> it's a pretty specific sense of the word 'effect' hakrilege 
09:26:57 <quicksilver> it is jargon.
09:27:00 <Zekka|Sigfig> ‘Applicative’ is pretty general, but it includes a lot of the things people talk about as effects
09:27:08 <Zekka|Sigfig> (for instance, all monads including IO are Applicative)
09:27:21 <Zekka|Sigfig> But it also includes mundane stuff like Identity
09:27:25 <quicksilver> I don't have a good way to explain the generic sense of 'effect' except by listing examples
09:27:32 <Zekka|Sigfig> > sequenceA [Identity 1, Identity 2, Identity 3]
09:27:35 <lambdabot>  Identity [1,2,3]
09:27:42 <Zekka|Sigfig> @src Identity
09:27:43 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
09:27:52 <quicksilver> have a play with Maybe, State s, (r->), IO
09:28:09 <quicksilver> ZipList
09:28:19 <Zekka|Sigfig> hakrilege: You might want to get familiar with Applicative to understand the heavy details, but Applicative is basically Functor plus a few operations
09:28:36 <Zekka|Sigfig> it’s basically Functor that supports fmap with as many arguments as you want
09:28:39 <hakrilege> I know applicative
09:28:47 <hakrilege> My graph is applicative
09:28:48 <quicksilver> if you know applicative then you know 'effect'
09:29:00 <Zekka|Sigfig> hakrilege: OK — well by ‘effect’ we just mean “the applicative thingy attached to a value”
09:29:01 <quicksilver> effect is just the word used for the things that applicatives do.
09:29:04 <hakrilege> It's also foldable
09:29:35 <hakrilege> So i think of i can identify my effect, then i could make it traversable
09:30:06 <quicksilver> Traversable instances are easy to write
09:30:13 <hakrilege> Wait sorry how is a foldable applicative not a traversable?
09:30:14 <quicksilver> you just apply the constructor with <$> and <*>
09:30:45 <quicksilver> traverse f (Foo g xs h) = Foo <$> f g <*> traverse f xs <*> pure h
09:30:59 <quicksilver> it looks like your fmap instance
09:31:06 <hakrilege> That's a default definition, i have a traversable
09:31:12 <Zekka|Sigfig> hakrilege: Ignore the part where I said your structure probably wasn’t Traversable, I misremembered the requirements of Traversable
09:31:39 <hakrilege> It's OK!! You said many helpful things
09:32:48 <NemesisD> does anyone know why stack tries to run tests for your dependencies?
09:32:53 <NemesisD> and how to avoid that
09:33:03 <hakrilege> Then the question is still how is that not just fmap f written in applicative? This gives some ordering to the effects or something...
09:33:22 <Zekka|Sigfig> hakrilege: It’s basically fmap written in Applicative, actually
09:33:35 <hakrilege> OK I'm clear great
09:33:39 <hakrilege> Thanks
09:33:42 <Zekka|Sigfig> The order comes from how Applicative works
09:34:06 <hakrilege> The traversal congress from the data structure implicitly
09:34:07 <Zekka|Sigfig> because order matters with <*>
09:34:13 <hakrilege> Comes
09:34:14 <Zekka|Sigfig> (and with <$>)
09:34:23 <Zekka|Sigfig> Well, it doesn’t always matter with (<*>), but it’s allowed to matter
09:35:08 <Zekka|Sigfig> > (+) <$> (“first”, 1) <*> (“second”, 1)
09:35:10 <lambdabot>  <hint>:1:10: lexical error at character '\8220'
09:35:18 <Zekka|Sigfig> oh dear, my client and smart quotes
09:35:20 <kadoban> NemesisD: Do you have them written as extra-deps ?
09:35:23 * hackagebot exact-real 0.11.0 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.11.0 (jophish)
09:35:27 <hakrilege> You think i will struggle to define pure without specifying the shape to copy?
09:35:29 <monochrom> :)
09:35:38 <Zekka|Sigfig> > (+) <$> ("first", 1) <*> ("second", 1)
09:35:40 <lambdabot>  ("firstsecond",2)
09:35:42 <NemesisD> kadoban: some of them yeah. they have to be as they aren't on stackage
09:35:59 <Zekka|Sigfig> hakrilege: Your Traversable type doesn’t actually need to be Applicative, it just needs to be a Functor
09:36:14 <kadoban> NemesisD: Can you lpaste the stack.yaml ?
09:36:23 <Zekka|Sigfig> I’m not entirely convinced your Traversable is a lawful Applicative, but I bet it doesn’t really matter if it is
09:36:32 <Zekka|Sigfig> :t sequenceA
09:36:33 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
09:36:34 <hakrilege> I thought it was applicative but i can't trek about this problem with pure
09:36:43 <Zekka|Sigfig> You’re writing the ’t’ here — the ‘f’ is something separate
09:36:52 <Zekka|Sigfig> So you’re writing a function over the ’t’ that’s fairly agnostic to what the ‘f’ is
09:37:06 <Zekka|Sigfig> In this case: sequenceA :: Graph (f a) -> f (Graph a)
09:37:12 <Zekka|Sigfig> :t traverse
09:37:13 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:37:21 <hakrilege> It's got to be applicative, i need to fmap functions over it
09:37:37 <Zekka|Sigfig> traverse :: (a -> f b) -> Graph a -> f (Graph b)
09:37:44 <Zekka|Sigfig> hakrilege: You don’t need to be Applicative to support fmap
09:37:48 <Zekka|Sigfig> you only need to be a Functor
09:37:51 <Zekka|Sigfig> @src Functor
09:37:51 <lambdabot> class  Functor f  where
09:37:51 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
09:38:09 <hakrilege> No that's what i mean, it takes the function composition out of the data structure
09:38:42 <hakrilege> <$>
09:38:54 <aweinstock> <$> is just infix fmap
09:38:57 <kadoban> <$> is fmap, which only requires Functor.
09:39:06 <NemesisD> kadoban: http://lpaste.net/699207924030898176
09:39:08 <aweinstock> :t [(<$>),fmap]
09:39:09 <lambdabot> Functor f => [(a -> b) -> f a -> f b]
09:39:12 <Zekka|Sigfig> hakrilege: Are you reacting to the Applicative stuff in this example from earlier? traverse f (Foo g xs h) = Foo <$> f g <*> traverse f xs <*> pure h
09:39:17 <hakrilege> No it has put also
09:39:20 <hakrilege> I thought
09:39:24 <hakrilege> Pure
09:39:27 <Zekka|Sigfig> Because that applicative stuff doesn’t come from the container — it comes from f
09:39:29 <Zekka|Sigfig> :t traverse
09:39:30 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:39:34 <NemesisD> kadoban: it building dependency tests is problematic because its not uncommon for test suites to create orphan instances
09:39:48 <Zekka|Sigfig> We’re using the Applicative’s Applicative instance — we don’t care if t has one, because we don’t use t as an Applicative in that definition
09:39:55 <hakrilege> @src (<$>)
09:39:55 <lambdabot> f <$> a = fmap f a
09:39:55 <aweinstock> hakrilege: where's an lpaste of the relevant code?
09:39:58 <hakrilege> Oh
09:40:34 <kadoban> NemesisD: Well, if I understand correctly it's not supposed to test extradep dependencies, but it will if you have them specified incorrectly probably.
09:40:42 * hackagebot exact-real 0.11.1 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.11.1 (jophish)
09:40:59 <hakrilege> You want the graph in using? I can put it in a paste but ill need to fire up the old beast, it will take a short while
09:41:15 <NemesisD> kadoban: that's not outside the realm of possibility. i'm new to stack and trying to set up a large project on it
09:41:16 <kadoban> NemesisD: The stack.yaml specifying thing is a bit not great. If you lpaste the stack.yaml I'll try to see if it looks right at least.
09:41:45 <NemesisD> kadoban: here's my stack.yaml http://lpaste.net/699207924030898176
09:42:46 <kadoban> NemesisD: Oh, yeah that looks like you're basically saying those are all part of the project. Let me look up the syntax you need real quick
09:43:35 <NemesisD> maybe its "packages" i want...
09:44:06 <NemesisD> wait that's what i have lol
09:45:34 <kadoban> NemesisD: Heh, yeah. So what you want is to specify: 'extra-dep: true' for all of them, it looks like the syntax is … https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md look for "example of the different settings", and right below that is an example
09:46:53 <hakrilege> aweinstock http://lpaste.net/145897
09:47:01 <kadoban> NemesisD: I think you then don't need them in the extra-deps list. Like it looks like you're bringing in amazonka both as a locally specified extra-dep and it's also in the extra-deps list, I don't think that's necessary.
09:49:41 <hakrilege> The above paste contains the graph in trying to make applicative and traversable
09:51:13 <hakrilege> I think it's pretty snazzy, seems to be fast enough
09:51:45 <NemesisD> kadoban: i think that worked. thank you! i'll try seeing if i can remove some of the items from extra-deps
09:52:03 <kadoban> NemesisD: Yay :)
09:52:50 <t7> hey guys, i am looking for a simple way to draw some (3d) shapes on screen. i have found a nice package called scenegraph but it looks like it is no longer maintained. Anyone know of a more active package?
09:55:43 * hackagebot exact-real 0.11.2 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.11.2 (jophish)
09:55:45 * hackagebot prelude-edsl 0.1.2 - An EDSL-motivated subset of the Prelude  https://hackage.haskell.org/package/prelude-edsl-0.1.2 (EmilAxelsson)
10:01:31 <hakrilege> t7 try gloss
10:01:48 <t7> hakrilege: havnt been able to get it to build for months
10:01:53 <t7> maybe there has been an update
10:01:58 <t7> or maybe i should update ubuntu
10:02:13 <t7> or clear cabal/ghc cache or something
10:02:18 <t7> also, does gloss do 3d?
10:04:21 <tommd> No
10:16:14 <phadej> matrix seem to be very slow
10:16:29 <phadej> togive any api responses even
10:20:15 <Denommus> hm, is there a way to convert IO exceptions into ExceptT e IO somehow?
10:24:16 <Denommus> something like liftEitherIO
10:25:10 <s4ke> hi. quick question, how can i let interact work together with a state
10:25:24 <hakrilege> If not gloss then glut
10:25:46 <hakrilege> t7^
10:26:03 <t7> yeah i should use glut
10:26:54 <hakrilege> I'd like to see a better solution tbh
10:27:01 <Denommus> MonadError e m => IO a -> m a would also be good
10:27:23 <hakrilege> I render 3d to 2d and use gloss
10:27:57 <hakrilege> As I'm only using circles, i can scale then for perspective easily
10:29:34 <hakrilege> But a nice ray tracing of spheres would be nice
10:34:13 <hodapp> s4ke: what do you mean, let interact with together with a state?
10:35:15 <magneticduck> :t interact
10:35:16 <lambdabot> (String -> String) -> IO ()
10:35:37 <magneticduck> interact's type signature clearly specifies that it carries no state
10:35:54 <magneticduck> look into the State monad transformer
10:36:00 <magneticduck> :t runState
10:36:02 <lambdabot> State s a -> s -> (a, s)
10:36:06 <magneticduck> :i State
10:36:12 <magneticduck> uh
10:36:22 <magneticduck> I mean, you want StateT
10:36:31 <magneticduck> with the underlying monad as IO
10:37:01 <magneticduck> s4ke: anyway the way you asked that question suggests you're not ready for StateT yet... ^^
10:37:15 <magneticduck> for now roll it yourself, you won't be able to 'make interact use state'
10:38:44 <Black0range> Hey i just downloaded the latest haskell platform. Why can't i find the module Data.Text? 
10:38:56 <Geraldus> hi folks!
10:39:33 <Geraldus> I heard there was some issues with OS X El Captain.  What about current situation? 
10:39:56 <Geraldus> I'm actively using `stack` with GHC 7.10.2
10:40:05 <magneticduck> Black0range: what OS
10:40:23 <Black0range> osx 10.11
10:40:45 <Ankhers> Geraldus: I have not had issues. Though, I don't do a lot of Haskell work.
10:40:50 <Black0range> Everything else works fine, just Data.Text is missing 
10:40:53 <Black0range> or something
10:41:09 <magneticduck> run 'ghc-pkg list'
10:41:15 <Geraldus> Ankhers: do you use stack?
10:41:41 <Ankhers> Geraldus: I switch back and forth.
10:41:43 <Ankhers> but yes.
10:41:50 <s4ke> nvm guys :)
10:41:58 <s4ke> i got it to work with a input loop
10:42:16 <Geraldus> Ankhers: nice, thank you, friends!  I'll try to upgrade in this case.
10:42:24 <Black0range> magneticduck: jup not there :(
10:42:26 <Geraldus> *friend
10:42:41 <magneticduck> well then, in that case you don't have Data.Text
10:42:45 <magneticduck> install the 'text' package
10:44:22 <Black0range> reinstalled the package, now it's there but i still can't use it...
10:45:49 <magneticduck> Black0range: how are you trying to use it
10:46:15 <Black0range> ghci then typing  :m Data.Text
10:46:43 <Geraldus> Black0range: :m +Data.Text ?
10:47:03 <geekosaur> shouldn't matter
10:47:10 <Geraldus> oh, surely
10:47:28 <Ankhers> Black0range: How did you install the package?
10:47:58 <Black0range> google -> haskell platform -> download -> instal -> acceppt -> click click -> done
10:48:21 <magneticduck> no, the *package*
10:48:31 <Ankhers> the text package.
10:48:35 <magneticduck> and is 'text' now in the output of 'ghc-pkg list'?
10:48:45 <Black0range> it should be included in the haskell platform 
10:48:47 <Black0range> and yes
10:49:11 <Black0range> Maybe i should just try good old restart computer trick
10:49:33 <Denommus> how can I convert an ExceptT e m a into a MonadError e m => m a?
10:50:04 <hodapp> "This one weird trick will solve your computer problem!"
10:50:25 <Ankhers> "IT experts hate him"
10:50:50 <Ankhers> Denommus: MonadError is a typeclass. You can't "convert" a value to it.
10:50:55 <Black0range> Nope, didn't work
10:50:56 <opqdonut> Denommus: runExceptT gives you m (Either e a)
10:51:08 <opqdonut> Denommus: then you fail if it's a Left
10:51:32 <obadz> Denommus: isn't ExceptT e m a an instance of MonadError e m already ?
10:52:03 <obadz> Denommus: if it isn't, then I don't know what is :)
10:52:35 <Denommus> obadz: it is, but I'd like to have a function ExceptT . liftIO . try
10:52:48 <Denommus> obadz: to return a generic MonadError. I have no idea how to proceed, though
10:53:08 <pyon-tinuation> I think Denommus' point is to convert, say, an IO action that throws (core language) exceptions into `Except e IO`, where `e` is presumably some type whose values could be any exception.
10:54:25 <opqdonut> :t runExceptT >=> either throwError return -- Denommus 
10:54:27 <lambdabot> MonadError e m => ExceptT e m c -> m c
10:54:50 <obadz> opqdonut: nice!
10:55:11 <opqdonut> yeah it's surprisingly neat
10:56:10 <m1dnight_> Is there really no way to force a trace? Im getting frustrated :<
10:56:33 <obadz> m1dnight_: what's forcing a trace?
10:57:28 <m1dnight_> force it to print. the laziness is being a PITA
10:57:52 <dmj> m1dnight_: there is Debug.Trace.traceIO 
10:57:53 <m1dnight_> I have a typechecker in which I really need to trace the environment. But due to laziness its not being printed and Im stuck figuring out what going on.
10:57:57 <obadz> m1dnight_: if the value is not evaluated, why do you care what it is?
10:58:04 <suppi> m1dnight_, why do you knead it?
10:58:23 <pyon-tinuation> Denommus: Just wondering - shouldn't you write your monad transformer code so that its inferred type is already `MonadError e m => m Foo`, instead of `Monad m => ExceptT e m Foo`, without explicit `lift`ing or anything?
10:58:27 <Denommus> opqdonut: cool
10:58:33 <obadz> m1dnight_: maybe print it if it derives Show ?
10:58:55 <NemesisD> is it possible to compose stack.yaml files, i.e. one for production build, one for dev
10:58:58 <Denommus> pyon-tinuation: I'm trying to do that
10:59:02 <Xeironis_> couldn't you just make it strict?
10:59:03 <m1dnight_> But the entire function is pure so I cant use IO
10:59:09 <Denommus> pyon-tinuation: but I need to lift actions to my transformer
10:59:16 <pyon-tinuation> Ah.
10:59:20 <obadz> m1dnight_: unsafePerformIO
10:59:35 <obadz> m1dnight_: which Debug.Trace surely uses
11:00:00 <m1dnight_> hmm
11:00:06 <m1dnight_> but then I could use it with deepseq
11:00:06 <obadz> m1dnight_: if your trace isn't printing, your function probably isn't evaluated at all
11:00:26 <m1dnight_> I know but I dont want to stop finding my bug, find out why its not printing and then find my bug again.
11:00:35 <m1dnight_> Its just annoying. I understand what you mean, but still..
11:01:33 <obadz> m1dnight_: if you have a Debug.Trace in the head of your function, and it doesn't print, your function can't be causing the bug as it's never evaluated
11:02:33 <Denommus> for now, liftErrorIO = liftIO . try >=> either throwError return
11:02:40 <m1dnight_> aaaah...
11:02:51 <m1dnight_> this makes more sense
11:03:42 <obadz> m1dnight_: see lazy evaluation is not a PITA, it's actually telling you the bug isn't there :)
11:03:53 <Denommus> now I need to have an equivalent to `bracket`
11:04:27 <magneticduck> in in the class of languages I will tacitly refer to as 'uncool languages', it is said that "allocations are really slow, they're your worst enemy"
11:04:52 <magneticduck> in Haskell however, 'allocations' of immutable objects are just a thing that happens whenever you do anything 
11:04:58 <magneticduck> is this somehow inherently slow?
11:05:05 <m1dnight_> The thing I didn't know was that say I have `trace (show foo) $ func x y z`, that the trace prints whenever func is evaluated.
11:05:18 <m1dnight_> I thought it only printed when in `func x y z`, `foo` got evaluated.
11:05:30 <magneticduck> or do the assumptions we can make about those allocations because our language is cool and immutable make our code just as fas
11:05:33 <jophish> edwardk: NoEq was best then?
11:05:44 <magneticduck> fast, ideally?
11:05:47 <edwardk> decided to merge it and decide if I want to bikeshed the name later
11:07:12 <makalu> when compiling accelerate-llvm from git, I get a segfault or illegal instruction or std::bad_alloc
11:07:16 <magneticduck> does my question make sense?
11:07:42 <m1dnight_> boom, got the bug.
11:07:54 <m1dnight_> Thanks for letting me rant and explaining it to me guys :>
11:07:55 <obadz> m1dnight_: squash it!!!!
11:08:13 <obadz> m1dnight_: show no mercy, take no prisoners
11:08:21 <jophish> edwardk: NoTruncate perhaps
11:08:29 <jophish> although it's a little long
11:09:00 <obadz> magneticduck: my very limited understanding is that ghc does what it can to prevent some allocations
11:09:14 <kadoban> So I think I talked about this with someone else before, but … does it bother anyone else that the 'safe' module has a bunch of stuff that's … not safe at all? :-/
11:09:18 <obadz> magneticduck: and you can help it with unpack pragma/bang patterns
11:09:31 <shock_one> Is there a data structure which would hold the previous version of my data along with the current one so that I could check what was changed? I know I can easily make it, but I suspect something like that should exist.
11:09:36 <obadz> magneticduck: which also helps with cache misses
11:09:38 <clahey> I went a little lens crazy just now.
11:09:50 <obadz> magneticduck: don't know if there's much more that a compiler can do.
11:10:05 <obadz> magneticduck: however where the compiler can really leverage the language, it's for garbage collection
11:10:28 <obadz> magneticduck: purity takes generational GC to a new level
11:10:47 <obadz> magneticduck: since you know for sure older objects can never ever point to newer ones
11:11:00 <obadz> magneticduck: that's about all I think I know
11:11:48 <obadz> magneticduck: maybe see https://skillsmatter.com/skillscasts/5466-bryan-o-sullivan and https://skillsmatter.com/skillscasts/6547-high-performance-programming-in-haskell and https://wiki.haskell.org/GHC/Memory_Management
11:13:10 <barrucadu> Although there is mutation going on under the hood in Haskell, because of laziness. But yes, it does help a lot.
11:14:25 <kadoban> shock_one: That seems like it depends more on what your data is than anything. Like if you want to see what happens after you run 'f' on your data, (x, f x) is a tuple containing both versions of course.
11:14:35 <kadoban> shock_one: I have a feeling you're looking for something … more, but I'm not sure what.
11:16:08 <shock_one> kadoban: I need to write some data to the terminal and would like to do as little re-rendering as possible when the content changes. You can think of this as of what React or ncurses do.
11:17:10 <hakrilege> obadz, do you know where else i could find the skills cast without logging on?
11:17:43 <obadz> hakrilege: ah, not sure, sorry. I think you can create free a account though.
11:18:11 <hakrilege> Damn this segregation of knowledge commons
11:18:11 <obadz> hakrilege: I doubt these exact videos are available otherwise. though the same talks could have been given somewhere else and be on youtube.
11:19:01 <hakrilege> Yeh i should search for it
11:23:07 <hakrilege> It's not on YouTube... Looks like i join this site and give then my data
11:23:52 <obadz> hakrilege: skillsmatter isn't the devil.. imho they do good things for the community.
11:27:14 <bb010g> Can I augment an existing package with something in a local directory?
11:27:44 <bb010g> (E.g. ./Biz.hs as Foo.Bar.Biz)
11:27:59 <Ankhers> Foo/Bar/Biz/Extended.hs
11:28:04 <Ankhers> Is what I have seen.
11:28:20 <Ankhers> Which would become Foo.Bar.Biz.Entended
11:28:26 <Ankhers> Extended rather.
11:43:24 <ed|win> why do duplicate let declarations in a do block not cause an error, but a single let with similarly named variables do (no pun intended)
11:44:29 <ed|win> this in particular: https://gist.github.com/aspidites/17ba6561d2e1ab5d4bf4
11:44:42 <shachaf> Because the former means something like "let { x = y } in let { x = z } in ..."
11:44:52 <shachaf> If you turn on warnings you'll get a warning about shadowing.
11:45:47 * hackagebot inline-r 0.7.2.0 - Seamlessly call R from Haskell and vice versa. No FFI required.  https://hackage.haskell.org/package/inline-r-0.7.2.0 (MathieuBoespflug)
11:45:58 <ed|win> how does that desugar in the latter?
11:46:14 <shachaf> Something like "let { x = y; x = z } in ...", presumably.
11:46:20 <shachaf> But it's an error anyway.
11:46:32 <rpfun> I was trying to compare python vs haskell for numerics, and wrote a prime number sieve in both (using the same algorithm). Here is the haskell: http://lpaste.net/2660920243475447808 , here is the python: http://lpaste.net/5262323772215525376 . I have gotten the haskell to within ~12-20% of the python, but it is still slower, and I was wondering if there was anything obvious that can be done?
11:46:53 <rpfun> on my machine input sizes ~1e8 to the algorithm give times O(500ms)
11:47:50 <rpfun> python runs consistently at 510ms, Haskell (with criterion) averages 590ms
11:47:51 <ed|win> shachaf: thanks
11:49:07 <ed|win> i was under the impression that independent of there being a let binding or not duplicate declarations weren't permitted due to immutability
11:49:53 <shachaf> Nothing is being mutated.
11:50:19 <ed|win> looks that way, but I suspect I simply don't understand how let bindings work
11:50:47 * hackagebot ghc-simple 0.2 - Simplified interface to the GHC API.  https://hackage.haskell.org/package/ghc-simple-0.2 (AntonEkblad)
11:50:48 <shachaf> They're different variables that happen to reuse the same name.
11:51:03 <shachaf> You could rewrite it as "let { x1 = y } in let { x2 = z } in ..."
11:51:11 <Xeironis_> does anyone happen to know if there's some complete (whether minimal or not) Haskell example about getting a texture to work in OpenGL? I can't seem to get it to work
11:51:24 <arkeet> it's like how in \x -> (\x -> ...), the two xs are different variables.
11:51:26 <arkeet> with the same name.
11:51:37 <ed|win> arkeet: BOOM
11:51:42 <ed|win> thansk for the analogy
11:51:44 <arkeet> np
11:51:51 <ed|win> that totally makes sense now
11:52:03 <ed|win> even more clear looking back at what you wrote, shachaf 
11:52:05 <bergmark> bindings within the same let group can all refer to each other, that's why you need unique names for all of them
11:52:35 <zomg> rpfun: it looks like you've copied it quite closely in Haskell as to how you'd write it in Python... that doesn't always result in very good perf, but I'm not too familiar with this particular issue so can't offer any more specific advice :)
11:52:40 <kurushii> got a bit of a problem and i need some help. I'm woking on doing some animations in haskell using a simple library. Trying to implement this particular image (https://s-media-cache-ak0.pinimg.com/originals/eb/8b/86/eb8b865d66d7e3a5df132123efb9fa74.gif).
11:53:07 <kurushii> the link to the library i am using is http://pastebin.com/FXAbRCAa
11:53:23 <rpfun> zomg: thanks, if you have an example of a faster prime number generator in Haskell i'd be interested as well
11:53:36 <rpfun> I just want to evaluate it to see if it can be competitive for numeric code
11:53:39 <kurushii> any help would be much appreciated. Thank you in advance.
11:55:19 <kadoban> rpfun: This is a neat paper on that in haskell: https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf and this is a package for it https://hackage.haskell.org/package/primes
11:56:09 <rpfun> looking at the code I suspect it is MUCH slower than the python I posted, but i'll run a benchmark right now
11:57:36 <geppettodivacin> kurushii: Did you write the library / have other people used it before?
11:57:57 <kurushii> nope i didn't write the library
11:58:22 <kadoban> rpfun: What sieve is that in the python one, out of curiosity?
11:58:41 <kurushii> I was directed to this library by a mate of mine
11:58:45 <geppettodivacin> kurushii: Have you written anything yet? I haven't delved much into the library, but it might help to see what you've already done.
11:58:56 <kurushii> yes i have written some code for it
11:59:03 <kurushii> i'll link it now
12:00:20 <kurushii> http://pastebin.com/q9WMJZki
12:00:49 * hackagebot posix-realtime 0.0.0.4 - POSIX Realtime functionality  https://hackage.haskell.org/package/posix-realtime-0.0.0.4 (MichalGajda)
12:01:23 <Denommus> does this make sense? https://gist.github.com/Denommus/93acfd5241210c31a1de
12:03:06 <rpfun> kadoban: it's the standard sieve i think
12:06:21 <geppettodivacin> kurushii: It looks like you've got an animation on there. You're trying to make the previously posted image, though?
12:06:29 <kurushii> yep
12:07:34 <kurushii> I tried doing some list comprehensions but kept getting very vague errors
12:07:54 <kurushii> obviously i'm a complete noob when it comes to haskell
12:08:22 <kurushii> so I thought I would come on here and ask for help
12:08:27 <submain> Is there a version of "lines" that takes into account carriage return?
12:09:31 <ed|win> submain: splitOn from the split package?
12:09:57 <ed|win> http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html
12:10:17 <ed|win> or splitOneOf when you want to check for multiple characters
12:10:34 <submain> Gotcha, looks like splitOneOf is the way to go. Thanks!
12:10:42 <geppettodivacin> kurushii: I'm kind of a noob, too, but I didn't want to leave you hanging. I'm poking around and seeing what I can do, though!
12:10:50 * hackagebot postgresql-connector 0.1.0 - Initial project postgresql-connector from stack  https://hackage.haskell.org/package/postgresql-connector-0.1.0 (markfine)
12:11:07 <kurushii> awesome i appreciate any help
12:11:21 <geppettodivacin> It's always better for two eyes to be looking at it, and if we can't figure it out now, someone else will probably be able to later!
12:15:04 <ed|win> what's everyone doing for frontend development nowadays?
12:15:11 <ed|win> still plain javascript? ghcjs? purescript?
12:15:37 <cabbibo> Hey, I've got a pretty silly question about lens / Naked expressions that I can't figure out...
12:15:50 <cabbibo> I'm super new to all this, 
12:15:51 <geppettodivacin> kurushii: It would probably help to start with the inside. That seems doable, and then we can add the animations together with the others.
12:17:13 <ggVGc> How could something like Lenses be implemented without a macro layer like TH?
12:17:28 <cabbibo> http://lpaste.net/145903 Is basically whats going on, where I am trying to make a lens that I can use later in the program, but if I import that module somwhere where it is actually used, it says there is a naked expression...
12:17:37 <kurushii> I see where you're coming from but the main issue is if i try and use some sort of list comprehension to draw rectangles it doesn't seem to work
12:17:39 <ed|win> ggVGc: you can use lenses without using template haskell
12:17:53 <ed|win> you'd jus then have to manually write them before you can use them
12:18:05 <kurushii> as i will need to use comprehension to draw many smaller rectangles
12:18:06 <ed|win> purescript, for instance, does this
12:18:07 <ggVGc> ed|win: I was under the impression the lens library was implemented using TH? For generating all the "accessors"
12:18:14 <ggVGc> ah right
12:18:45 <ggVGc> ed|win: I'm asking because I'm curious about what route Elm will/should take. There's some talk about that something Lens-like is needed for record updates primarily
12:18:57 <cabbibo> and I get that you can't write an expression at a top level,  but do i have to make the lens once they are inside the main loop ?
12:19:03 <ggVGc> Since Elm won't have a template system anytime soon
12:19:39 <ggVGc> I guess something like PureScript is the way to go initially then
12:19:42 <ed|win> I'm not sure how lenses would be written without typeclasses
12:19:50 <ggVGc> yeah, that's another issue
12:20:02 <ggVGc> maybe type classes or something equivalent will be introduced first
12:20:07 <ggVGc> but I doubt it
12:20:13 <tzh> cabbibo: makeLenses uses template haskell to automatically generate the lenses; if you want to use it then you need to enable template haskell
12:20:14 <ed|win> I guess you could do something like fclabels?
12:20:22 <geppettodivacin> kurushii: What list comprehension have you tried?
12:20:41 <kurushii> stuff like [(rect (always 200) (always 250) | n <- [0..1])
12:20:41 <ggVGc> never heard of fclabels. Will take a look
12:20:42 <ggVGc> thanks
12:20:55 <ggVGc> I mean this is in no way up to me. I'm just curious in the subject
12:21:42 <cabbibo> @tzh thanks so much! I see that I'm missing that at the top now :)
12:21:42 <lambdabot> you are welcome
12:21:54 <cabbibo> @tzh its always great when the fix is a one liner :)
12:21:54 <lambdabot> you are welcome
12:22:04 <geppettodivacin> kurushii: How are you flattening that into an animation?
12:22:29 <kurushii> well currently it's not an animation but a still drawing
12:22:36 <tzh> cabbibo: yeah in a way the best bugs are the ones with the simplest reasons, b/c they're so easy to fix :V
12:22:45 <kurushii> I was trying to get it to at least draw a series of rectangles
12:23:16 <ggVGc> I aways have the feeling list comprehensions are a bit superflous in haskell.
12:23:33 <hodapp> ggVGc: I very rarely see them used.
12:23:34 <ggVGc> i.e I can't decide if having them in the langage is useful enough to warrant the additional syntax
12:23:35 <geekosaur> superfluous but sometimes quite convenient
12:23:41 <ggVGc> hodapp: right, my point exactly
12:24:34 <geppettodivacin> kurushii: Can you post that code?
12:24:46 <cabbibo> @tzh haha. I wish they were all this good of bugs ;)
12:24:46 <lambdabot> you are welcome
12:25:09 <kurushii> which code? to draw rectangles repeatedly
12:25:12 <ggVGc> I think you don't need to add the @ in front. lambdabot seems to react to that
12:25:19 <ggVGc> cabbibo: ^
12:25:27 <geppettodivacin> kurushii: Yeah. Even if it's got bugs, it'll help me to know what you're trying.
12:25:52 <kurushii> ok want me to post it here or on pastein?
12:25:53 <geppettodivacin> kurushii: I'm working on code that just draws one rectangle first, myself.
12:25:56 <ggVGc> bugs are just implementation details anywway...
12:26:07 <kurushii> pastebin*
12:26:08 <geppettodivacin> kurushii: pastebin. Or lpaste.net.
12:26:21 <ggVGc> kurushii: never post code in channel. always use a paste site. github gist is the best currently by far, imo
12:26:30 <cabbibo> ggVGc thanks for the info :)
12:26:40 <kurushii> yh sorry will take note
12:26:54 <geekosaur> #xmonad currently demolished by someone who pasted into channel... something huge :/
12:27:05 <kurushii> http://pastebin.com/ubVfcwet
12:27:20 <kurushii> this will just draw a series of rectangles
12:27:42 <Denommus> edwardk: what do you think? https://github.com/ekmett/mtl/issues/28
12:27:56 <ggVGc> geekosaur: hahaha... oh man..
12:28:04 <ggVGc> long time since I saw something like that
12:28:09 <geekosaur> they finally dropped connection to end it
12:28:23 <geekosaur> worse, they hadn't intended to paste and started experiemnting to see what triggered it
12:28:28 <geekosaur> and, er, found out
12:28:43 <geekosaur> without emptying the clipboard first :/
12:28:55 <ggVGc> geekosaur: agile!
12:29:00 <ggVGc> who needs staging
12:32:26 <geppettodivacin> kurushii: That looks like a good start to me. You might want to get rid of the genPaint, then put a withBorder just on the outside of the translate.
12:33:32 <kurushii> do you mean right after `plus` change withGenPaint to withBorder?
12:33:47 <cabbibo> I've got another question too, I hope that asking these super n00b questions here is the right place....
12:33:49 <orion> When uploading documentation to hackage, what should the structure of the zip file be?
12:33:59 <geppettodivacin> kurushii: I'm typing it up to see if it works. One sec.
12:34:10 <cabbibo> I just saw a type error I've never seen before where the complier says
12:34:12 <cabbibo>  Couldn't match type ‘Float’ with ‘n GLfloat’
12:34:38 <cabbibo> what is the 'n' in that case ( I've been trying to google it, but it turns out that searching for a specific letter is near impossible ).....
12:34:41 <kurushii> ok thanks
12:35:16 <kadoban> cabbibo: There should be more context to the message than that.
12:37:15 <kurushii> can't do withBorder it will get rid of the animation
12:37:16 <cabbibo> kabodan yes, there is the usual http://lpaste.net/145904
12:37:32 <cabbibo> kabodan ^ expected type / actual type
12:38:05 <geppettodivacin> kurushii: That's weird, you're right.
12:38:27 <geppettodivacin> kurushii: There's still animation, but it definitely doesn't give what I expected.
12:38:55 <kurushii> yep
12:39:03 <lpaste_> geppettodivacin pasted “kurushii Animation” at http://lpaste.net/145905
12:39:20 <geppettodivacin> kurushii: That's the code I've got currently.
12:39:45 <kurushii> let me run it
12:40:22 <kadoban> cabbibo: There should be more, really … isn't there?
12:40:41 <kadoban> cabbibo: You might as well just paste the whole thing, and a decent selection of the code causing the error.
12:41:23 <geppettodivacin> kurushii: Never mind, fixed it.
12:41:31 <geppettodivacin> I forgot a withoutPaint.
12:41:35 * hackagebot exp-pairs 0.1.4.1 - Linear programming over exponent pairs  https://hackage.haskell.org/package/exp-pairs-0.1.4.1 (Bodigrim)
12:41:54 <kurushii> may i just say geppettodivacin you are awesome
12:42:00 <lpaste_> geppettodivacin revised “kurushii Animation”: “kurushii Animation” at http://lpaste.net/145905
12:42:22 <geppettodivacin> kurushii: I'm interested in the problem and procrastinating on an essay.
12:42:46 <kurushii> lol thank you truly thank you 
12:42:48 <cabbibo> kaboda Here you go! I always want to make sure I'm not posting too much code to sift through, but thats usually way more difficult to actually parse than just having all the code....
12:42:53 <kurushii> i just can't get my head around haskell
12:42:55 <cabbibo> kadoban http://lpaste.net/145908
12:43:03 <kurushii> if it was c++ i would be done in an instant
12:43:18 <Iceland_jack> kurushii: Treat it like learning programming again 
12:43:39 <kurushii> yes that is exactly what i'm trying to do
12:43:49 <cabbibo>  kurushii: I know the emotion
12:43:55 <cabbibo> :)
12:44:03 <kurushii> thank you it's very frustrating 
12:44:17 <kurushii> you keep asking where is the goddamn for loop
12:44:20 <kadoban> cabbibo: Yeah it's usually nice to avoid pasting /too/ much, but error messages you generally want to just give the whole thing. They tend to be a bit verbose, but there's good info spread around in them. That said, *looks at paste*
12:44:28 <rpfun> i asked this before but got disconnected; i have two prime number sieves, one in python: http://lpaste.net/5262323772215525376 and one in haskell http://lpaste.net/2660920243475447808 . my implementation in haskell, although imperative, runs MUCH faster than the haskell package Data.Numbers.Primes for large inputs. It's still slower than the python, and i was wondering if anyone had any advice on how to make it competitive? i'd like to
12:44:28 <rpfun> be able to use haskell for numerics, but it needs to be able to compete with/beat short, silly python programs like this
12:44:42 <geppettodivacin> kurushii: It's cool because this project actually really shows off how cool Haskell's list processing is.
12:44:53 <cabbibo> kurushii: until it works and than you feel like a GODDDD
12:44:54 <Welkin> lol kurushii 
12:45:06 <Welkin> pretty soon you will be saying "How did I ever program without haskell?"
12:45:09 <cabbibo> kadoban: thanks! thats good feedback
12:45:27 <kurushii> i'm hoping haskell can win me over 
12:45:44 <cabbibo> kadoban: I should also say that I am working with another person on this code who actually knows haskell, so everything we do is out of my league...
12:46:05 <kurushii> but with a community such as this makes learning haskell worth it
12:46:09 <kadoban> cabbibo: Ah, that sounds troublesome. Do you have time to do some more basic haskell learning first?
12:46:12 <geppettodivacin> kurushii: Now, instead of composing over the translate, we should probably compose over the rectangle size.
12:46:18 <edwardk> Denommus: i think that Control.Exception is a very GHC-specific thing and that the mtl works on all sorts of compilers today. I'd be very hesitant to pick up the implicit dependency
12:46:35 * hackagebot propellor 2.14.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.14.0 (JoeyHess)
12:47:11 <cabbibo> kadoban: reading through learn you a haskell for the second time, so I'm working on it, but in the mean time we are also trying to make some fun things :)
12:47:24 <kadoban> cabbibo: Hmm, sorry I don't really know the libraries you're using there, and there doesn't seem to be enough to guess at what's wrong :(
12:47:46 <kadoban> cabbibo: I'm pretty … negative on LYAH. It doesn't have any exercises, so you don't really learn how to actually do any coding.
12:48:10 <Welkin> the best way to learn is to just start building something
12:48:16 <Jookia> ^
12:48:17 <Welkin> and ask for help when you need it
12:48:31 <kadoban> cabbibo: https://github.com/bitemyapp/learnhaskell has good advice, and I think http://haskellbook.com/ is likely to be quite good (but I don't have a copy yet)
12:48:32 <Welkin> explore the documentation, read the source code, experiment
12:48:34 <cabbibo> kadoban: no problem! Thanks for looking still, basically my brain is a wet sponge so every new piece of information is useful, including when the code i provide isn't enough to make sense of anything
12:48:44 <geppettodivacin> kurushii: And instead of cycleSmooth, we should use onceSmooth.
12:48:49 <kadoban> Ehhh, I don't think haskell is a language you can learn by just starting a project, personally. That's going to be frustrating.
12:48:50 <Welkin> cis194 is helpful to start though
12:48:59 <cabbibo> Welkin : totally agreed! 
12:49:05 <kurushii> geppettodivacin man i didn't even know onceSmooth existed
12:49:08 <rpfun> edwardk: i was wondering if you could take a quick look at this haskell http://lpaste.net/2660920243475447808 and say if there are any obvious speedups? i know you have spoken about performance/math in hasekll before
12:49:25 <geppettodivacin> kurushii: The export list in the library helps a lot to know what's in there.
12:49:26 <rpfun> edwardk: or if you know of a fast prime number generator in haskell :)
12:49:40 <edwardk> rpfun: a bit busy at the moment, but i can maybe take a look later
12:49:44 <kurushii> i'll have a look at it now 
12:49:49 <cabbibo> Welkin : kadoban : I've always found that its good to have a combo from starting from scratch, and also seeing what you can do by playing with other peoples code
12:49:54 <Welkin> rpfun: there is a primes package
12:50:03 <Welkin> it uses a wheel sieve
12:50:06 <c_wraith> rpfun: edwardk is generally pretty busy. But you can get good results by asking the whole channel for help. 
12:50:35 <cabbibo> the biggest problem is that I come from graphics, and  always wanna do crazy gl projects
12:50:47 <rpfun> Welkin: my code is much faster than the primes package, just benchmarked
12:50:50 <cabbibo> and ekmetts code is AWESOME, but also uses the craziest parts of haskell...
12:51:07 <rpfun> c_wraith: i had, no one responded, i figured maybe he hadn't seen it and might be interested
12:51:50 <rpfun> c_wraith: of course, if you're interested i'd really like your input, i just figured it was seen by most of the channel already. sorry
12:51:55 <Denommus> edwardk: you're right, but maybe there's a way to make it generic, I dunno
12:52:13 <Denommus> edwardk: (I also didn't know Control.Exception was GHC-specific)
12:52:17 <edwardk> Denommus: i think i'm going to push back on it as out of scope for the mtl
12:52:28 <edwardk> but it might be worth packaging up separately
12:52:30 <edwardk> not sure
12:52:36 <edwardk> there are a lot of points in the design space
12:52:43 <edwardk> which is usually a sign to me to step back ;)
12:53:23 <Denommus> edwardk: I also just discovered that somehow I can call this liftErrorIO from inside IO actions, because there's some instance lost somewhere that makes IO instance MonadError
12:53:39 <Denommus> edwardk: so, in practice, little gain
12:53:56 <kurushii> geppettodivacin played around with it got a single square
12:54:26 <geppettodivacin> kurushii: I can't actually get onceSmooth to work right. You might have to send me your code.
12:54:40 <kurushii> haven't done onceSmooth 
12:54:52 <kurushii> kept it same as yours
12:55:01 <kurushii> gonna try work on onceSmooth now
12:55:29 <kurushii> also geppettodivacin i have more examples
12:55:42 <kurushii> i'll post them in pastebin
12:58:50 <kurushii> http://pastebin.com/aKJupGw8
12:59:32 <kurushii> http://pastebin.com/JQ2sC0M7 example 2
12:59:42 <hesiod> Cabal complains about some directory not existing when compiling in a sandbox with one local package (add-sourced). What are could be the cause?
13:00:29 <hesiod> The custom package in question is units, and the failed "not existing" is in the units-defs package
13:01:00 <dcoutts> hesiod: we'd need to see a log
13:01:07 <hesiod> Interestingly, while I added ../units, cabal looks for ./units-defs
13:01:34 <hesiod> dcoutts: Give me a second
13:04:33 <hesiod> dcoutts: I thourougly checked the logs again, but there is nothing unusual, really
13:05:25 <hesiod> Could it help to not only remove the sandbox, but also the dist directory?
13:07:16 <jotrk> I already tried using a signature: `("" ++) <<< show :: forall a. Show a => a -> String`
13:07:21 <jotrk> ups, sorry
13:07:31 <jotrk> wrong channel :)
13:07:56 <hesiod> jotrk: Nevertheless, your function looks fancy :D
13:08:16 <kurushii> ok but i haven't managed to get anything done apart from what you gave me
13:08:38 <jotrk> hesiod: thanks :)
13:08:42 <kurushii> oops sorry accidentally replied to earlier message again
13:08:53 <jotrk> hesiod: it's actually a purescript snippet, but it works the same in Haskell ;)
13:09:20 <hesiod> jotrk: I guess that's why you mixed up the channels :)
13:10:16 <jotrk> hesiod: I admit that could be the reason, but actually I just pressed some odd keys in irssi :)
13:12:54 <Guest50526> hello
13:12:56 <kurushii> geppettodivacin managed to solve anything?
13:13:53 <Guest50526> I'm going through the introductory "Learn You a Haskell for Great Good"
13:14:21 <Guest50526> and I'm having a hard time understanding his usage of foldl in this function
13:14:53 <geppettodivacin> kurushii: I've got one shrinking rectangle. Let me share it.
13:15:19 <lpaste_> geppettodivacin pasted “kurushii Animation shrinking rect” at http://lpaste.net/145910
13:15:25 <icen> When trying to work out the folds, it can help to manually expand them for smaller cases
13:15:34 <Guest50526> thanks icen
13:15:50 <Guest50526> wife just called me to leave... Guess I hopped on at the wrong time
13:16:03 <Sonolin> I'm trying to understand unsafePerformIO 
13:16:07 <Guest50526> icen: would it be a good idea for me to come back here for similar help?
13:16:09 <Sonolin> what does this mean: case m realWorld# of (# _, r #) -> r
13:16:26 <Sonolin> can't find "realworld#" anywhere on google (hoogle gives reference to Control.Monad.ST)
13:17:13 <icen> Guest50526: sure, ask away
13:18:01 <jophish> edwardk: glguy: Will ad get a release sometime for the NoEq functions?
13:18:16 <icen> Sonolin: there's a thing called MagicHash; RealWorld is also (iirc) a special type (GHC people please correct this!)
13:18:31 <icen> MagicHash is a ghc extension, and you can read more about it there
13:18:58 <wetmore> as for understanding RealWorld, check out http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf
13:19:06 <kurushii> geppettodivacin seems like you got it i'll try to do some coding but you'll probably complete this before i do
13:19:09 <wetmore> at least conceptually
13:23:02 <Guest50526> http://lpaste.net/145911
13:23:06 <Guest50526> Here is the code
13:23:12 <Guest50526> my problem isn't so much with foldl
13:23:18 <Guest50526> i think i Understand the function
13:23:36 <Guest50526> I just don't understand why its beneficial in that particular context
13:24:02 <Guest50526> is it just preference, or is there a reason to use foldl their instead of my implelmentation
13:28:21 <lpaste_> geppettodivacin revised “kurushii Animation shrinking rect”: “kurushii Animation shrinking rect” at http://lpaste.net/145910
13:28:59 <kurushii> gonna check it now
13:29:01 <geppettodivacin> kurushii: Now it shrinks several rectangles around a point.
13:29:08 <geppettodivacin> It doesn't do it all at the same rate, though.
13:29:58 <kurushii> Oh my god you are epic
13:30:15 <kurushii> you actually did it after i spent so loooong on it
13:31:17 <kurushii> and you used list comprehensions when i couldn't get it even work
13:31:57 <kurushii> guess i need to pick up a beginners book again this time a better one and learn haskell again
13:32:05 <geppettodivacin> kurushii: I used your code a lot. I'm not usually good at working on things from scratch, but if you give me something that works I can usually figure out the underlying system from there.
13:32:11 <geppettodivacin> kurushii: Just never stop learning.
13:32:21 <kurushii> never will i stop learning
13:32:37 <kurushii> i am already very fluent in many object orientated languages
13:33:02 <kurushii> but functional i stayed away from due to me thinking it's not really worth learning
13:33:13 <kadoban> kurushii: I've heard a lot of good things about http://haskellbook.com/ , and the author really seems to know what he's talking about, pedagogically and otherwise.
13:33:55 <kurushii> thanks for the link 
13:35:03 <kurushii> will definitely look into buying that book searched far and wide for a good haskell book but this probably looks like the book i need
13:45:33 <kurushii> geppettodivacin still there? got one more thing i need help with if you don't mind. If you're busy just let me know i'm sure i can figure it out on my own.
13:46:04 <kurushii> actually no worried figured it out
13:46:08 <kurushii> worries*
13:46:53 <dmwit> Let's play "Name That Newtype"!
13:47:10 <dmwit> instance (Applicative f, Monoid m) => Monoid (Newtype f m)
13:47:42 <Iceland_jack> dmwit: AM :)
13:47:53 <Iceland_jack> https://hackage.haskell.org/package/diagrams-core-0.1/docs/src/Graphics-Rendering-Diagrams-Monoids.html
13:47:57 <Guest50526> dmwit:Monoid?
13:48:29 <dmwit> Iceland_jack: Excellent, thanks.
13:50:11 <dmwit> Iceland_jack: Kind of a strange dependency to put for this newtype, though, huh? =D
13:50:34 <JonReed> Is there a way to pattern guard and match a field inside a record. For example, lets say I have "data Sample = Sample { dur :: Maybe Int }. I want to do guard like "compare y x | (Nothing (dur  x)) (Nothing (dur y)) = EQ"
13:50:59 <Iceland_jack> It is :)
13:51:05 <dmwit> Iceland_jack: Also, wow! You have to go all the way back to v0.1 to get it?
13:51:40 <dmwit> JonReed: compare Sample { dur = Nothing } Sample { dur = Nothing } = EQ
13:51:45 <Iceland_jack> I wasn't recommending the package as such, byorgey mentioned it in his blog some time ago https://byorgey.wordpress.com/2011/04/18/monoids-for-maybe/
13:52:10 <Iceland_jack> I guess it should be in monoid-extras but I don't think it is there (that's where monoid actions are)
13:52:32 * dmwit nods agreeably
13:54:20 <Iceland_jack> dmwit: In the comments edwardk says that it's called "App" in his monoids package (http://hackage.haskell.org/package/monoids-0.3.2/docs/Data-Monoid-Applicative.html) which was deprecated for 'reducers' (http://hackage.haskell.org/package/reducers-3.12.1/docs/Data-Semigroup-Applicative.html)
13:54:30 <Iceland_jack> I think it's what's now caled "Ap" 
13:54:31 <Iceland_jack> *called
13:55:11 <dmwit> Yeeees, much better.
13:56:52 <orzo> What's the idiom for when I need to support Functor on the first argument of a parameterized type that has a second argument?  If it was the last argument, I'd merely implement Functor on a partially applied type.  I can't refactor, because it would case me to have to a similar instance issue with the last parameter
13:57:05 <bitemyapp> orzo: Bifunctor
13:57:19 <bitemyapp> orzo: http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Bifunctor.html#v:first
13:58:21 <JonReed> dmwit: Great solution. Thx!
13:58:36 <orzo> bitemyapp: that's not good for me because only one of the parameters has a Functor interface, the other has different type class called Dup (from regions package)
13:59:09 <orzo> I could use Bifunctor and put an error call for second, I suppose.  Is that best practice?
13:59:10 <dmwit> orzo: You will either need to use a different class or a newtype wrapper.
13:59:44 <dmwit> orzo: I would definitely not encourage `second = undefined`.
14:00:36 <orzo> dmwit: i an't even do it anyway it turns out.  My second argument is a second-order type, not a first-order one that Bifunctor would require
14:01:41 <orzo> i want more than just FUnctor, i want Monad
14:01:48 <bitemyapp> pasting the type would help.
14:01:50 <orzo> so my own type class doesn't sound like a good idea
14:01:55 <bitemyapp> and please don't write a partial function.
14:02:26 <orzo> that leaves me with a newtype wrapper, but it's not clear whehter i should use the wrapper for the first or the second type argument
14:02:51 <dmwit> I don't understand what "use the wrapper for the first or the second type argument" means.
14:03:17 <dmwit> I was thinking something like `newtype Flip f a b = Flip { runFlip :: f b a }`.
14:03:31 <orzo> well i have two type classes, Dup and Functor.  I have one underlying representation.  I can implement one of those directly, but I'd need a newtype wrapper for the other
14:04:08 <orzo> right, i just need to figure out whether to ask the user to Flip when he wants to dup or when he wants to fmap
14:04:12 <dmwit> Okay, I think I understand the question now. I would say it is a purely aesthetic choice.
14:05:00 <orzo> does your Flip construct already exist somewhere?
14:10:15 <gargawel_> Hi, I've been trying to encode the fact that insertion sort does not change the length of a vector at type level. I ended playing with proxy values and propositional type equality witnesses to try and provide more context to the compiler. I've been partly successful, but I'm still struggling with a key case in an auxiliary function.
14:10:22 <gargawel_> Could someone provide some help ?
14:10:37 <gargawel_> Here is my code: https://gist.github.com/gaeldeest/4e7e5b458c19462c0cf7
14:14:25 <orzo> i doubt i can be much help with your type level stuff, gargawel_, but line 17 looks odd to me
14:14:43 <orzo> i think you meant something like VCons x (VCons y ys)
14:16:03 <gargawel_> Oh yes, there is an obvious mistake
14:16:17 <gargawel_> Updated version: https://gist.github.com/gaeldeest/235b164bea8d2853344b
14:17:08 <shachaf> I'm not sure what case Refl of Refl -> is supposed to do, but it probably isn't doing it.
14:17:43 <gargawel_> It feels like the compiler should be able to derive solveable constraints from the context.
14:18:13 <gargawel_> Refl is the GADT constructor of the propositional equality type: a:~:b
14:18:21 <geppettodivacin> kurushii: Sorry I missed your ping. Glad you figured it out! I'm not going to be available for the rest of the day, though.
14:18:39 <gargawel_> It's only constructor is, well Refl :: a:~:a
14:19:08 <shachaf> I know what Refl is.
14:19:56 <gargawel_> Ok. That wasn't clear to me, sorry :)
14:20:25 <gargawel_> But well, the point is, I am out of ideas as to how to proceed.
14:21:07 <gargawel_> Maybe someone has ideas of new tricks to try...
14:27:08 * hackagebot postgresql-connector 0.2.0 - Initial project postgresql-connector from stack  https://hackage.haskell.org/package/postgresql-connector-0.2.0 (markfine)
14:27:25 <Welkin> gargawel_: teaching your dog new tricks?
14:29:27 <gargawel_> Welkin: kind of. I don't expect to go very far with that, though.
14:30:23 <gargawel_> What I like is that it forces me to think in terms of how the compiler tries to typecheck my code.
14:31:46 <lyxia> gargawel_: Enable ScopedTypeVariables and replace "case Refl of" with "case witness of"
14:32:08 * hackagebot exact-real 0.11.3 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.11.3 (jophish)
14:33:12 <gargawel_> Oh my god, I feel stupid
14:33:18 <gargawel_> thanks a lot :)
14:33:22 <lyxia> :)
14:35:46 <kurushii> geppettodivacin no worries although i'm trying to improve upon what you gave me now to make also spin around if possible but to no avail. I'll do what i can for the rest of the day and i appreciate all your help. Although i'll probably ask for more help tomorrow lol
14:47:18 * hackagebot shellmate 0.2.2 - Simple interface for shell scripting in Haskell.  https://hackage.haskell.org/package/shellmate-0.2.2 (AntonEkblad)
15:12:19 * hackagebot ghc-simple 0.2.1 - Simplified interface to the GHC API.  https://hackage.haskell.org/package/ghc-simple-0.2.1 (AntonEkblad)
15:15:33 <geppettodivacin> kurushii: I think the best way to think of it is as a set of transformations of a shape over time. Each transformation happens separately, and the transformations are written in as particular values at particular times.
15:16:15 <geppettodivacin> I think with what we had today as building blocks, you should be able to put together the entire animation you showed originally.
15:16:43 <kurushii> yest i've been working on that but couldn't get it to work with the code you gave so i went back to basics and created a rotating circle
15:17:24 <kurushii> but yh haven't managed to figure out how to rotate the square
15:34:25 <sm> argh, this is pretty basic. Network.Netrc parses ByteString (not the Char8 version) from .netrc. What's the best way to test one of these for equality with a String ?
15:35:47 <geekosaur> um? they're both the same thing; only the functions differ, the underlying ByteString is identical
15:37:34 <geekosaur> so if you have a ByteString, use Data.ByteString[.Lazy] to get an ASCII codepoint / Word8 view and the .Char8 variant to get a (moderately evil) Char view of it
15:37:56 <sm> I guess the problem is the netrc lib doesn't provide a Char view
15:38:02 <geekosaur> you don't need it to
15:38:09 <geekosaur> it gives you a ByteString
15:38:18 <geekosaur> so import Data.ByteString.Char8 and have at it
15:38:26 <geekosaur> it's *the same ByteString*
15:38:41 <sm> woah.. 
15:40:26 <sm> cool, I did not know that. I was seeing mismatched types, but just due to lazy/strict difference
15:41:00 <geekosaur> right, those types are different, but .Char8 is just whether the fuinctions take/return Word8 or Char when operating on the ByteString
15:41:45 <sm> geekosaur: that's very helpful, thanks!
16:13:49 <pdxleif> @unmtl StateT IState (ExceptT Err IO)
16:13:49 <lambdabot> Plugin `unmtl' failed with: `StateT IState (ExceptT Err IO)' is not applied to enough arguments, giving `/\A. IState -> ExceptT Err IO (A, IState)'
16:14:26 <pdxleif> @unmtl StateT IState (ExceptT Err IO) ()
16:14:26 <lambdabot> IState -> ExceptT Err IO ((), IState)
16:15:24 <pdxleif> @unmtl ExceptT Err IO String
16:15:24 <lambdabot> ExceptT Err IO String
16:17:00 <pdxleif> Any advice for having https://hackage.haskell.org/package/fsnotify-0.2.1/docs/System-FSNotify.html run something like the above as its action?
16:17:14 <pdxleif> Currently it just does an IO () as its callback...
16:27:23 * hackagebot simplest-sqlite 0.0.0.14 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.0.0.14 (YoshikuniJujo)
16:39:25 <sm> at last.. first official use of haskell in $DAYJOB \o/ 
16:40:01 <sm> (a web UI regression test script)
16:43:13 <johnw> sm: nice!!
16:43:17 <johnw> sm: congrats, man
16:44:31 <sm> thanks johnw. I have been good for soo long :)
16:45:31 <TimWolla> Hi! I need to read from a binary file that contains UTF-8 encoded parts do some calculations with them (among those are calculating the SHA1) and write those parts as part of a JSON object properly encoded to another file. These parts currently reside inside a strict ByteString inside my program. Unfortunately Aeson mangles them when encoding them as a JSON string.
16:45:51 <TimWolla> I think I have to use https://www.haskell.org/hoogle/?hoogle=decodeUtf8, but this does not really change anything. Do you have some pointers?
16:47:16 <TimWolla> Example: I have the bytes C3A4 (the German umlaut ) inside my source file, but the encoded string is written as: C383 C2A4 (ä)
17:09:18 <jaarood> hi.. can someone recommend me a high-quality high drain (8 amps continuous) unprotected 18650 cell?
17:09:30 <orion> Does anyone know where c2hs searches for header files?
17:09:57 <johnw> jaarood: this isn't the channel for such questions
17:12:22 <bitemyapp> @karma+ mgsloan
17:12:22 <lambdabot> mgsloan's karma raised to 6.
17:12:36 <jaarood> johwn #python?
17:12:43 <johnw> heh, that's up to them
17:23:03 <solrize_> jaarood, look for IMR cells but yeah, #electronics.  candlepowerforums.com has a subforum about batteries where you could also look, or try an R/C forum.
17:25:15 <jaarood> solrize_ thanks, I'll give that forum a try. I actually asked by accident, but as usual #haskell is very helpful. :)
18:40:01 <Nikhil_learn_Has> hi anyone here for haskell ?
18:40:23 <Nikhil_learn_Has> when i type ghci in haskell platform editor 
18:40:29 <Nikhil_learn_Has> i get this error : <interactive>:8:1: Not in scope: ‘ghci’
18:40:37 <Nikhil_learn_Has> anyone knows why ?
18:41:10 <lamefun> Looks like you already are in ghci.
18:41:52 <lamefun> GHCI displays the very same message when I type 'ghci' in it.
18:43:55 <lamefun> What's "Haskell platform editor"?
18:44:24 <geekosaur> nothing I've ever heard of
18:46:11 <orion> In c2hs, when using {#fun ... #}, what do you do if the C function has type signature foo(..., int some_size, char* some_string) ?
18:46:44 <lamefun> Does Haskell Platform ship an editor?
18:47:15 <Ashy> most haskellers use vim or emacs afaict
18:48:04 <Ashy> i highly encourage you to learn one of those but there's also leksah if you prefer an easier ide to get up and running with: http://leksah.org/
18:48:19 <derekv> I've got    f <$> g <*> (g . h) $ x   and it works.  For fun/learning/code-golf type purposes, I'm trying to see if I can construct this in a way that g is mentioned only once
18:53:43 <paraseba> Given (x :: ReaderT r m a) I'm trying to use it from (f :: ReaderT r' m b) and I have a trivial function (r' -> r). Is there a simple way to "lift" x to use it in f? (I'm not sure lift is the right word here)
18:54:00 <paraseba> of course r' /= r
18:54:26 <lamefun> I can't IDEs, they mess with my head, perhaps I'm an idiot. And last time I tried Leksah it took so long to load that I just uninstalled it.
18:55:47 <geekosaur> :t withReaderT
18:55:48 <lambdabot> (r' -> r) -> ReaderT r m a -> ReaderT r' m a
18:57:30 <paraseba> geekosaur: cool, now what happens if I have (MonadReader r)  instead of ReaderT r ?
18:57:46 <derekv> ((.)<$>(.(+1))<*>(.(+100))) (+1000) 1   ... I wish there was a sort of macroexpand I could use to help me visualize what is happening with this sort of thing
18:58:34 <derekv> I'm sitting here facinated writing statements like that, if it passes the type checker I have no idea what I'm going to get
18:58:42 <geekosaur> there isn't one based on the class, you need to COntrol.Monad.Trans.lift to get to the actual ReaderT
18:59:40 <paraseba> geekosaur: ohhh so, I'd first (lift) from my MonadReader and then apply withReaderT?
19:00:05 <geekosaur> not exactly
19:00:54 <geekosaur> a MonadReader is just something that has a ReaderT somewhere in the stack. they didn't provide a class method for withReader so you have to find the ReaderT yourself; this may involve multiple `lift`s
19:01:30 <derekv> what the heck does "Num (a -> b) => a -> b"  mean?
19:01:35 <paraseba> hum, i see, so you have to bring everything to the "concrete world" of ReaderTs
19:01:51 <geekosaur> derekv, usually that you used a function where a number was expected
19:01:56 <derekv> a function from a to b where a function from a to be is a number?
19:02:30 <geekosaur> (note that there *is* a sensible Num instance for functions, but it's not part of the Prelude for good reason)
19:02:46 <derekv> geekosaur: ohh, ok ... that was my next question
19:03:21 <geekosaur> every so often someone will load it into lambdabot and play with it. it's rather mind-bending
19:03:39 <hamishmack> lamefun: That sounds like a bug.  Did you file an issue?  What version of Leksah was it? What OS was this on?  Had it created/downloaded the metadata for your installed packages?
19:03:52 <derekv> like a y-combinator thing?
19:04:12 <geekosaur> well, mostly it's not there so you get an error when you use a function where you were supposed to get a number
19:04:45 <geekosaur> if you have a Num instance for functions in scope, ghc will happily use it when you don;t expect it and if you do get an error it'll be completely incomprehensible
19:05:13 <geekosaur> (this is also why we don't have Num instances for everything someone can think of a reason to have one)
19:05:25 <derekv> heh, sure
19:05:49 <geekosaur> I mean, the errors you get are hard enough to decipher as it is, if you give ghc the rope it will go out of its way to hang you with it >.> 
19:06:33 <geekosaur> (ghc is entirely too clever about finding "creative" ways to use typeclass instances)
19:08:14 <derekv> I'll keep those imports as qualified then.
19:08:27 <derekv> actually that might not help
19:09:45 <geekosaur> it wouldn't :)
19:11:01 <lamefun> hamishmack, this was before Stack... anyway I don't want IDEs, they mess with my mind, I'm probably too stupid to use them.
19:12:25 <derekv> the list of things I shouldn't do grows ever larger
19:18:23 <hamishmack> lamefun: Do you remember what tasks you found difficult in Leksah?
19:18:53 <lamefun> I didn't get to use it.
19:23:27 <hamishmack> lamefun: Well if you have time to try it again sometime I would love to know how you find it.  The first time you load it it will take some time collecting metadata, but after that it should start in about 5 secs.
19:28:52 <blischalk> Is it possible to get a list of Value Constructors e.g If I have data Weekday = Monday | Tuesday | Wednesday | Thursday | Friday is it possible to get these in a list?
19:30:37 <geekosaur> derive Enum
19:31:20 <geekosaur> if you also derive Bounded then you don't even need to know which one is first...
19:32:01 <geekosaur> actually you don't need Bounded for that. [toEnum 0 ..] :: YourType
19:32:27 <geekosaur> (again, need to add `deriving (Enum)` for this)
19:42:15 <Pamelloes> Is there a monadic "fix" function? i.e. fixM :: Monad m => (a -> m a) -> m a
19:43:05 <geekosaur> :t mfix
19:43:06 <lambdabot> MonadFix m => (a -> m a) -> m a
19:43:21 <Pamelloes> Oh cool!
19:44:26 <blischalk> geekosaur: awesome! thanks. enumFrom is then possible after deriving Enum
19:44:30 <derekv> seems like   f <$> (g . h) <*> g $ x   can also be written   flip f `on` ($x) <*> (.h) $ g
19:45:19 <derekv> not a readability improvement but accomplishes what I set out to do =]
19:54:53 <dldl> Could someone help me with an introductory Haskell problem?
19:54:55 <dldl> http://lpaste.net/2960274344405630976
19:55:25 <ttt_fff> what is the problem?
19:55:31 <ttt_fff> you got a warning, not a error
19:56:05 <dldl> Sorry, that is the working code
19:56:07 <ttt_fff> though I do have to admit, area'R looks sorta weird, why not areaR' ?
19:56:12 <dldl> at the bottom is a commented out problem
19:56:23 <ttt_fff> why do you have "'" all over the place? generally in haskell, it means strictness
19:56:24 <dldl> Its just for my own readabillity
19:56:28 <dldl> its a scratch notebook
19:56:43 <dldl> and i want to easily reference where about some code is
19:56:54 <dldl> but areaR' was my first name for it
19:57:11 <hakujin> learning about unix pseudoterminals and attempting to build a small proof of concept. currently copying master stdin to slave and from slave to master stdout. sort of works? simple programs like `ls` draw correctly. more complex ones like `vim` don't. am I missing some pty setup after creation? https://gist.github.com/hakujin/ec5aa22d328ba4ee33a2
19:57:27 <ttt_fff> dldl: so I think what you want is "pointfree style", if you're trying to curry the function
19:57:43 <ttt_fff> dldl: is your goal to define area'R without using "x" ?
19:57:46 <ttt_fff> where the argument is implicit ?
19:57:47 <dldl> yes
19:57:54 <dldl> exactly
19:58:16 <dldl> just trying to wrap my head around implicit arguements with (,$,. notation
19:58:21 <ttt_fff> @pl (\x -> 1 + x)
19:58:21 <lambdabot> (1 +)
19:58:34 <ttt_fff> dldl: see, if you type in @pl [function def], the bot will do the point free conversion for you
19:58:48 <ttt_fff> dldl: so just take your code; and simplify it a bit so that you can feed it to @pl
19:59:17 <dldl> wow! really?
19:59:21 <geekosaur> hakujin, you need to at minimum copy stty settings to the actual terminal (more commonly you set the actual terminal to raw mode)
19:59:24 <dldl> that kind of seems like cheating to me
19:59:41 <hakujin> geekosaur: is the actual terminal here the spawned pty?
19:59:42 <dldl> but then again, coming from imperative language, a lot of Haskell feels like cheating
19:59:43 <ttt_fff> dldl: I think that depends on if (1) this is a hw problem or (2) you're learning how to do point free conversion
19:59:58 <geekosaur> no, the one you run it in
20:00:07 <ttt_fff> @pl (\x -> (x + 2) * (x / 3))
20:00:08 <lambdabot> liftM2 (*) (2 +) (/ 3)
20:00:08 <geekosaur> http://www.linusakesson.net/programming/tty/ might be of interest...
20:00:18 <hakujin> will read, thanks
20:00:38 <geekosaur> (what is likely happening is that vim expects to set raw mode and then send ^Js to move directly down instead of it doing newlines)
20:01:22 <geekosaur> but if you left the terminal you ran it in in normal mode, those will become newlines when you write them back out and the drawn screen will be all mangled
20:01:34 <hakujin> yep that sounds spot on
20:02:10 <ttt_fff> for storing persistent data, is haskell-redis, haskell-sql, haskell-aeson-store-to-file, or ahskell-acid-state suggested ?
20:02:17 <dldl> there, "liftM2" is a library function like zipWith but works on non-list items? 
20:02:26 <ttt_fff> I'm currently usin haskll+sqlite via opaleye; but I'm tempted to use haskell+redis
20:02:38 <ttt_fff> dldl: http://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html#v:liftM2
20:02:39 <dldl> wait nvm
20:02:44 <dldl> thanks
20:07:39 <koz_> What's a good Haskelly way to generate all permutations of length-10 lists of Bools?
20:07:39 <dldl> Do i have to import something to get @pl to work?
20:07:51 <geekosaur> um, @pl is a bot command, not a ghci command
20:08:00 <geekosaur> @pl \x -> x + 2
20:08:00 <lambdabot> (2 +)
20:08:39 <geekosaur> if you're planning to play with it a bit, might "/query lambdabot" to get a private window/tab with the bot
20:10:19 <pavonia> koz_: Permutations or combinations?
20:11:14 <koz_> pavonia: Permutations. I.e. [False, False, True] is different to [False, True, False].
20:12:18 <Pamelloes> fix is super cool :D
20:12:55 <pavonia> :t permute
20:12:56 <lambdabot> Not in scope: ‘permute’
20:13:18 <pavonia> :t permutations
20:13:19 <lambdabot> [a] -> [[a]]
20:13:31 <koz_> OK, I'll look it up.
20:13:42 <dldl> ttt_fff: I just rewrote the function definition as a lambda function, but I'm still interested to know if there is a way to write it with only $ , . , ()'s
20:14:43 <koz_> pavonia: That's close to what I need. It'll certainly save me a lot of time.
20:15:45 <pavonia> Actually, I didn't mean combinations
20:16:10 <pavonia> > sequence $ replicate 3 [False, True]
20:16:12 <lambdabot>  [[False,False,False],[False,False,True],[False,True,False],[False,True,True]...
20:16:25 <pavonia> ^ What are the elements of this list called?
20:17:41 <nitrix> pavonia: The elements of this list are lists of booleans.
20:17:41 <MarcelineVQ> The elements of that list are [Bool]
20:17:49 <geekosaur> I think they mean the pattern...
20:18:00 <Pamelloes> dldl: You can always rewrite in a point less form. The question is whether the rewrite makes it more readable or less readable :P
20:18:42 <submain> I always thought point less more elegant, though less readable
20:19:03 <MarcelineVQ> pavonia: Listing out all possible combinations like that is called a cartesian product
20:19:35 <Pamelloes> submain: It often can be both—more elegant and readable (if you're used to it). Sometimes, though, it just makes things an ugly mess.
20:19:39 <Pamelloes> For instance:
20:19:47 <Pamelloes> @pl \a b c d -> a + b + c + d
20:19:47 <lambdabot> ((((+) .) . (+)) .) . (+)
20:19:59 <Pamelloes> I mean, you /could/ write that....
20:20:03 <pavonia> MarcelineVQ: Okay, I thought there was another word
20:20:22 <MarcelineVQ> There probably is :>
20:20:52 <geekosaur> pavonia, there are permutations and combinations, but those are more specific than what you are probably looking for
20:21:57 <pavonia> Yes, permutations are only a subset of this. I just wasn't sur if koz_ was actually asking for this set
20:24:06 <geekosaur> maybe you're thinking of powerset? which is again not the same thing
20:25:49 <dldl> I'm just trying to wrap my head around $ and () and '.'
20:26:00 <dldl> the function I am making is just for learning
20:26:29 <dldl> it seems to me that you need to do something a little extra than just rewrite parens and what not
20:27:02 <geekosaur> $ can always be replaced by parentheses; it's just using precedence to add "implicit" parentheses
20:27:13 <dldl> right
20:27:57 <dldl> but that means, in my example, that we need more that parentheses, and therefore any combination of Parens/$/. would be insufficient for rewriting implict
20:28:01 <dldl> right?
20:29:19 <geekosaur> I am looking at your paste from earlier
20:29:54 <geekosaur> so you are missing one key point. you *could* write that as a section, so you can end it with an operator like that... but $ is just application, so in this case you just leave it off
20:29:58 <geekosaur> (the final one)
20:30:17 <geekosaur> because application is what will happen anyway
20:30:24 <pavonia> geekosaur, MarcelineVQ: What I meant was "variation with repetition" which again doesn't seem to be a widely used term in English :)
20:30:55 <geekosaur> that however is specific to $. if you want to do that with some other operator, you need to use section syntax:
20:30:58 <dldl> geekosaur: but that doesn't compile
20:31:03 <geekosaur> @pl \x -> x + 2
20:31:03 <lambdabot> (2 +)
20:31:10 <geekosaur> ^ that is a section
20:31:53 <monochrom> wait, the answer should be (+ 2)
20:32:25 <geekosaur> > let area'R = area' $ Circle' (Point 0 0) $ Point 0 in area'R 2 -- this won't work since it has neither Circle' nor Point nor area'...
20:32:27 <lambdabot>      Not in scope: ‘area'’
20:32:27 <lambdabot>      Perhaps you meant ‘area'R’ (line 1)Not in scope: data constructor ‘Circl...
20:33:21 <geekosaur> but you will note that it successfully parsed, since that's the only way it could get around to noticing undefined names
20:33:32 <dldl> isn't area' defined right between the Type definition and the area'R definition
20:33:49 <geekosaur> in your paste, yes. not in the bot
20:34:11 <geekosaur> all you (normally) get is one-liners and I can't define your types in that one-liner
20:34:55 <geekosaur> but the definition parsed. notice the difference between what you were trying and what I did above
20:35:11 <geekosaur> (which I tried to explain to you earlier, apparently unsuccessfully)
20:40:27 <dldl> http://lpaste.net/2960274344405630976
20:40:35 <dldl> I see what you were saying now
20:40:47 <dldl> the problem is, this code still isn't working for me
20:40:50 <geekosaur> define "doesn't work"
20:40:54 <dldl> is it because I am in interpreitive mode
20:41:15 <dldl> I'm trying to copy/paste the error output, but its not being nice.  I will get it in a second'
20:41:28 <geekosaur> you can't just type that into ghci as is, you have to prepend "let "
20:42:33 <geekosaur> because ghci thinks it's an expression otherwise
20:45:32 <monochrom> I don't think "currying" is the right word. "eta reduction" is.
20:46:12 <c_wraith> eta reduction working is a side effect of functions being curried by default, though.
20:46:21 <monochrom> eta reduction is when you simplify "f x = blahblah x" to "f = blahblah"
20:46:22 <dldl> http://lpaste.net/145923
20:47:25 <dldl> monochrom: c_wraith: thanks for the correction :)
20:47:33 <monochrom> but until you really have "f x = blahblah x" for real, you cannot just freely intuitively "let me delete the trailing x, for my favourite sense of 'trailing'", and call it valid
20:47:40 <dldl> I'm loading a module
20:47:52 <dldl> doing a :l mycode.hs
20:48:25 <geekosaur> ah, I see your problem. you do need to do that a little differently, because you would be saying (Point 0 x) but you want to omit the x
20:48:43 <dldl> exactly
20:48:49 <geekosaur> problem is those parens around it mean it's not actually the last thing in there, so you need to rephrase it
20:48:49 <monochrom> it is not obvious to me how "area' (Circle' (Point 0 0) (Point 0 x))" can be rewritten to "blahblah x". in fact, it seems to me can't be done
20:48:53 <dldl> I know there is many ways to rewrite it
20:48:57 <geekosaur> (Point 0 .)
20:49:19 <dldl> but I want to understand the way (,.,$ works
20:49:22 <geekosaur> (partial application of the Point constructor)
20:49:30 <dldl> cool!  let me try
20:50:12 <geekosaur> @pl \x -> area (Circle (Point 0 0) (Point 0 x)) -- acrtually you need to deal with 2 levels of parens that way...
20:50:12 <lambdabot> area . Circle (Point 0 0) . Point 0
20:51:05 <monochrom> I understand $ by getting rid of it
20:51:13 <c_wraith> dldl: a point monochrom was making is that you need to actually make it a function first.  You were just describing an expression with a free variable.  That's not the same as a function.
20:51:55 <dldl> geekosaur: you are my hero
20:52:07 <dldl> I swear that was the first think I tried
20:52:10 <geekosaur> dldl, I will also say that it's often a good idea to forget that $ exists when you are starting out; it just confuses things
20:52:19 <monochrom> I understand . by sometimes leaving it as "it's just another binary operator, leave it alone", and some other times by using its definition.
20:52:21 <dldl> but I probably didn't put a . between the first and second point
20:53:07 <monochrom> lastly, I understand parentheses by knowing that it's a gimmick for the parser (so is operator precedence) and drawing the whole parse tree
20:53:09 <geekosaur> the rest is understanding partial application and function composition; I suspect it is the latter you are having trouble with
20:53:49 <dldl> geekosaur: Yeah.  I'm still trying to wrap my head around it.  This was the first non-trivial example that I could come up with
20:53:55 <geekosaur> (f . g) x        is     f (g x)        that is, apply g to x and then apply f to the result of that
20:54:11 <monochrom> overall, I understand nothing by intuition.
20:54:18 <geekosaur> but learning to think in compositional terms is a bit harder than just knowing how (.) is defined
20:54:51 <dldl> its just weird to me how a function thats defined as F(x,y) = G(y)
20:55:07 <geekosaur> (for me, it was pretty intuitive... but, well, my brain is a bit "different")
20:55:19 <monochrom> but no one is doing F(x,y) here
20:55:21 <dldl> I feel like I'm picking it up pretty well
20:55:33 <dldl> its so much fun when it works
20:55:40 <dldl> but its a pain to debug
20:55:52 <dldl> (sometimes)
20:55:52 <monochrom> do algebra
20:57:47 <lifter> What is the relationship, if any, between DisambiguateRecordFields (which we have now) and the Overloaded Record Fields that will be in GHC 8.0? Will DisambiguateRecordFields be necessary in 8.0?
20:58:48 <dldl> :r
20:58:55 <dldl> excuse me
20:59:16 <lifter> ^ that was awesome
21:00:22 <geekosaur> lifter, DisambiguateRecordFields only applies when ghc can infer from types exactly which record type is used. there are many use cases when it can't (see bad1 and bad2 in https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#disambiguate-fields)
21:00:55 <geekosaur> so DisambiguateRecordFields can't help with bad1 and bad2 at that link but can handle ok1 and ok2; standard Haskell rejects all four of them
21:01:22 <geekosaur> Overloaded record fields can handle bad1 and bad2 as well, by generating typeclasses for the fields and inferring polymorphic types using them
21:01:43 <lifter> yes I was reading the docs; but I'm not sure what the future of DisambiguateRecordFields is, given that we are getting ORF in 8.0
21:01:55 <monochrom> that is a lot of automation
21:02:36 <geekosaur> it'll likely stick around for a while, since not everyone will be turning on ORF (and it won't be on by default). also there is some cost to ORF which can be avoided if DRF will work
21:03:06 <lifter> geekosaur, thanks.
21:03:20 <lifter> Anyone know when 8.0 might be released?
21:04:10 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1 says release candidate planned for next month
21:04:23 <lifter> ow wow
21:04:24 <lifter> nice
21:05:00 <geekosaur> also note that full ORF may not make 8.0.1
21:05:19 <geekosaur> "Possible, if the authors push forward fast enough"
21:05:57 <lifter> well, what an improvement it'll be
21:08:40 <Welkin> next month!?
21:08:51 <Welkin> it's like the baby is being born already
21:08:56 <Welkin> and we have not made any preparations
21:10:16 <monochrom> you can always buy a gift card for the babyshower at the last minute :)
21:10:17 <geekosaur> yes, well, ghc release dates have been known to slip...
21:10:22 <geekosaur> (by a year, sometimes...)
21:11:00 <kadoban> That'd be a nice christmas present if it happens.
21:11:20 <kadoban> Or christmas next year, whichever XD
21:11:24 <monochrom> which of the following two phenomena is harder to predict? earthquake, GHC release
21:13:04 <athan> hi everybody
21:13:35 <athan> I've been thinking about a concept - incremental program modification
21:14:06 <geekosaur> you might want to poke at Erlang a bit
21:14:24 <lamefun> Will there be any reason to define normal function instead of HasField instances after ORF?
21:14:36 <athan> The idea is that, if you "modify" a data type to, for instance, add a new sum-type switch, then you have to modify all functions that use that data type as input to remain total
21:14:54 <athan> geekosaur: hmm, okay I'll give it a shot
21:15:41 <athan> in effect, I would need an incremental unification system, and a way to change the compiled components of the values, in a way that would atomically keep the code's integrity
21:15:58 <athan> but I'm not sure if this has already been done
21:18:16 <monochrom> I think Erlang gives up on the "remain total" part.
21:18:49 <athan> ah shoot
21:19:10 <athan> If you packed a substitution to be made atomically, then performed it at one time, then I think it would work
21:19:28 <monochrom> not to mention that Erlang also gives up on static type checking at the onset, even if you never hot-swap modules
21:19:36 <athan> but I don't know what the substitution would look like, in a traditional FP AST
21:19:47 <athan> agh jeez :\
21:19:53 <athan> looks like I have a project then :)
21:20:56 <athan> (because you would not simply match against the data constructor, but for all functions that _use_ the constructor, you have to embed the case-statement on the function expression (maybe))
21:21:32 <athan> that would be an interesting project itself, too, I think - the properties of expressions remaining total, based on their pattern-matching semantics
21:21:44 <athan> like the use of `_` wildcards, etc
21:37:09 <dldl> http://lpaste.net/145924
21:37:13 <dldl> what do you guys think
21:38:38 <dldl> koz_: Not sure if you got your answer, but I think my code will give you all permutations of Bool for a list of a given size n
21:38:50 <dldl> does anybody else have a solution that could verify mine?
21:39:05 <monochrom> I don't know what it does
21:39:41 <kadoban> dldl: What's the goal?
21:40:51 <dldl> from <koz_> What's a good Haskelly way to generate all permutations of length-10 lists of Bools?
21:41:10 <athan> :t permutations
21:41:11 <lambdabot> [a] -> [[a]]
21:41:27 <athan> dldl: It's under Data.List I think :)
21:42:40 <monochrom> I'm pretty sure "permutation" is the wrong word here
21:42:52 <kadoban> I think it's more they want … "give me every possible list of length 10 of Bools"
21:42:55 <kadoban> Yeah.
21:43:14 <dldl> so, like [true,true,false] == [true,false,true] ?
21:43:16 <monochrom> delete "permutations of" and you'll be completely clear
21:43:29 <monochrom> no
21:43:32 <kadoban> dldl: Hmm?
21:43:45 <dldl> is permutation being used here as a Haskell keyword
21:43:49 <pavonia> Heh, we already had that discussion an hour ago
21:43:56 <dldl> or as a mathematical concept
21:44:09 <dldl> yeah, I was working on my other problem, but it sounded interesting to implement
21:44:10 <pedantic_> dldl: there is a function in Data.List called permutation
21:44:26 <kadoban> dldl: Either one, 'permutations' is a function … which generates all of the permutations of the input list.
21:44:34 <monochrom> Data.List permutation is consistent with the mathematical concept of permutation
21:44:46 <lamefun> Monad transformers n²?
21:44:51 <monochrom> "enumerate all 10-bit vectors" is not
21:45:39 <monochrom> the only defense you can resort to is "I use that word colloquially, like plain English"
21:46:02 <monochrom> but then every colloquial plain English word is utterly ambiguous and informationless
21:46:24 <Welkin> the definition depends on usage and context
21:46:27 <Welkin> as always
21:46:56 <lamefun> I mean, it looks like every monad transformer in eg. mtl has to forward every other transformer.
21:46:59 <kadoban> dldl: But the code itself, that's interesting. You should probably avoid calling 'generateBools (n-1)' twice, I'd think.
21:47:05 <monochrom> yes, this is why plain English is never really used, no matter how much people think they're using it
21:47:57 <monochrom> every time you depend on context, you're using contextually specialized English, even insider English. not plain English any more
21:48:19 <Welkin> what is "plain english"?
21:48:23 <dldl> @monochrom I have much to learn
21:48:23 <lambdabot> Unknown command, try @list
21:48:23 <Welkin> like wikipedia simple?
21:48:39 <dldl> i think plain english is like "list" means a list of items
21:48:45 <dldl> but Haskell List means something more specifgic
21:49:54 <kadoban> dldl: It's not really like that in this case, your use of permutations doesn't really match any usage I've ever noticed. But it's not a big problem, just … a think.
21:49:55 <monochrom> I am wondering what is going on that needs the extra base case for 1
21:49:56 <kadoban> a thing.
21:51:02 <dldl> I'm creating a dfault for 0
21:51:07 <dldl> and 1 is the only base case
21:51:08 <monochrom> Welkin, plain English is whenever you're talking about enumeration or combinatorics you throw in "permutation" and/or "combination" somewhere for good measure
21:51:17 <dldl> (the recursion fails at 0 I think)
21:51:36 <Welkin> monochrom: you mean like "theory" being used to describe a wild ass guess?
21:51:47 <monochrom> yes
21:52:17 <dldl> Would it be a good idea to remove the double " generateBools (n-1) " statements with a where/let statement
21:53:42 <monochrom> it is a trade off between spending more memory vs spending more time
21:54:04 <monochrom> it is a good idea if you have 20GB of RAM and a 1MHz CPU
21:54:20 <dldl> lol. I'm having a hard time understanding the trade offs of one implementation over another
21:54:21 <monochrom> it is a bad idea if you have 1MB of RAM and a 20GHz CPU
21:54:40 <dldl> seems like everything can be done at least 2 ways
21:55:16 <Welkin> dldl: everything can be done a million ways in programming
21:55:27 <dldl> Welkin++ Good point
21:55:52 <monochrom> if you have only 1MB of RAM and a 1MHz CPU, you're doomed
21:56:39 <Welkin> if that's the case, then write it in assembly or system c, and don't allocate any memory at runtime
21:57:43 <monochrom> and if you have 20GB of RAM and a 20GHz CPU, you go with the where/let version on the ground that it's shorter and also probably more robust to future editing
21:58:10 <dldl> monochrom: noted
21:58:18 <monochrom> (i.e., if you have two occurrences of the same expression that you need to sync, you will always forget to sync them)
21:58:45 <monochrom> (aka some mantra along the line of "don't repeat yourself")
21:59:34 <monochrom> a lot of performance trade-off dilemmas can be resolved by "but I want my code to look nicer!"
22:01:19 <monochrom> would a 5GHz CPU interfere with 5GHz wifi? is that why they don't make 5GHz CPUs?
22:03:54 <monochrom> you don't need the base case of 1. you only need the base case of 0.
22:04:41 <monochrom> map (True:) [[]] ++ map (False:) [[]] = [True:[]] ++ [False:[]] = [[True], [False]]
22:05:11 <dldl> @monochrom You are absolutely right
22:05:11 <lambdabot> Unknown command, try @list
22:05:12 <dldl> thanks
22:05:20 <dldl> dang
22:05:30 <dldl> monochrom: You are absolutely right!
22:05:49 <kadoban> > replicateM 3 [False, True] -- stupid Monad tricks
22:05:51 <lambdabot>  [[False,False,False],[False,False,True],[False,True,False],[False,True,True]...
22:07:43 * hackagebot postgresql-connector 0.2.2 - Initial project postgresql-connector from stack  https://hackage.haskell.org/package/postgresql-connector-0.2.2 (markfine)
22:08:20 <dldl> kadoban: that was beautiful
22:09:18 <monochrom> @src replicateM
22:09:18 <lambdabot> replicateM n x = sequence (replicate n x)
22:10:10 <monochrom> that one is pretty natural, not stupid. also, sequence can be just sequenceA, you just need Applicative
22:10:50 <monochrom> the filterM trick for "enumarate all subsets" is the stupid or mysterious monad trick
22:11:31 <monochrom> or stupid Jedi mind trick
22:15:18 <jle`> yeah, i'd actually call the sequence/replicate method a non-stupid applicative trick
22:15:26 <jle`> it makes more sense if you see it in list comprehension notation
22:15:44 <jle`> > [[x,y,z] | x <- [False, True], y <- [False, True], z <- [False, True]]
22:15:46 <lambdabot>  [[False,False,False],[False,False,True],[False,True,False],[False,True,True]...
22:16:02 <jle`> replicateM n is just the same thing but doing that n times isntead of just 3
22:16:31 <dldl> wow.  That is kind of mind blowing
22:16:49 <jle`> that's what replicateM "is"...bind the same action n times, and return all the results in a list
22:17:10 <jle`> here we sampled from [False, True] three times and put all of the three results in a list
22:17:37 <jle`> um i feel like, the more i say, the more difficult i'm making it to understand. i'll stop now :)
22:17:45 <dldl> no... I get it
22:17:53 <Nikhil_learn_Has> hi, when i define b= "Abc"
22:18:06 <Nikhil_learn_Has> and then, i try to append it, with "Mr" 
22:18:14 <Nikhil_learn_Has> "Mr":b
22:18:22 <dldl> "Mr" is a list
22:18:22 <Nikhil_learn_Has> its throwing an error
22:18:29 <jle`> check the type of (:)
22:18:29 <monochrom> "Mr" ++ b
22:18:29 <dldl> you can't con a list with a list
22:18:39 <jle`> (:) :: a -> [a] -> [a]
22:18:42 <jle`> you want [a] -> [a] -> [a]
22:18:57 <jle`> which is (++)
22:18:57 <Nikhil_learn_Has> ok
22:19:06 <Nikhil_learn_Has> thanks
22:19:11 <dmj> jle`:++
22:19:24 <jle`> btw, the compile error might help you see what happened :)
22:19:40 <pavonia> > 'M' : 'r' : "Abc"
22:19:42 <lambdabot>  "MrAbc"
22:24:11 <dldl> [ f x | x<-xs ] == map f xs
22:24:18 <dldl> is that literally true?
22:24:21 <monochrom> yes
22:24:25 <dldl> cool
22:27:11 <lispy> it's so true that you can use = instead of ==
22:27:47 <Nikhil_learn_Has> what is the difference between ':' and '++' exectly
22:27:56 <dldl> lispy: that thought makes me incredibly happy
22:27:58 <Nikhil_learn_Has> ++ is used only for list or what?
22:28:02 <dldl> ++ combines 2 lists
22:28:09 <monochrom> they have different types.
22:28:10 <dldl> : adds an element to the front of a list
22:28:15 <kadoban> :t ((:), (++))
22:28:17 <lambdabot> (a -> [a] -> [a], [a1] -> [a1] -> [a1])
22:28:40 <dldl> Nikhil_learn_Has: 'a' : "bcdefg" vs "a" ++ "bcdefg"
22:28:43 <monochrom> there are also some unimportant differences
22:28:43 <lispy> dldl: have you ever read the Haskell2010 report? It's actually quite readable and it covers things like desugaring
22:29:01 <dldl> lispy: no I havent
22:29:04 <lispy> dldl: https://www.haskell.org/onlinereport/haskell2010/
22:29:08 <dldl> but that sounds exactly what I am looking for
22:29:13 <dldl> thank you thank you thank you
22:29:17 <lispy> yw!
22:30:31 <jle`> Nikhil_learn_Has: when in doubt, just look at the types :)
22:30:47 <jle`> (:) is `a -> [a] -> [a]`, and (++) is [a] -> [a] -> [a]
22:30:55 <jle`> the types are the keyyy
22:36:10 <Nick_learn_haske> hi
22:37:37 <dmj`> Nick_learn_haske: hi
22:38:02 <dldl> dmj`: Nick_learn_haske : hi
22:39:57 <MarcelineVQ> dldl: hi
22:49:09 <thimoteus> hi
22:49:51 <Kneiva> hi
23:31:03 <HEGX64> :t ()
23:31:05 <lambdabot> ()
23:38:59 <cow_2001> there are exactly two bajillion csv packages in this here hoogle search - https://www.haskell.org/hoogle/?hoogle=CSV
23:39:04 <cow_2001> which one should I choose?
23:45:52 <cocreature> cow_2001: casava seemed to be one of the more popular ones last time I looked
23:47:08 <cocreature> if you want to stream your csv there is pipes-csv and probably also something for conduit
23:49:24 <cow_2001> what's the difference between pipes and conduits?
23:51:21 <liste> cocreature isn't https://hackage.haskell.org/package/cassava-0.4.4.0/docs/Data-Csv-Streaming.html enough for streaming?
23:51:28 <Xeironis_> What's the canonical way of converting CInt to Int?
23:52:08 <cocreature> Xeironis_: fromIntegral should do the job
23:52:14 <Xeironis_> ok, thanks
23:53:01 <Xeironis_> the code snippet I'm looking it is doing it with unsafeCoerce, but that seemed a little... unconventional
23:53:07 <Xeironis_> looking at*
23:53:15 <cocreature> liste: sure, that’s what pipes-csv uses under the hood. I just prefer to go to pipes when I need streaming instead of figuring out a different interface for each library
23:54:20 <pyrtsa> My Google-fu is failing me. Is there a way to define a GHCi command ":paste" such that it calls the system command "pbpaste" and evaluates the result (like ":cmd ..." does) in the REPL?
23:54:37 <pyrtsa> Would be nice if it existed out of the box, btw.
23:54:51 <jle`> that'd be fun :)
23:55:04 <jle`> you can set commands like that in ~/.ghci
23:55:34 <pyrtsa> I know. But I don't know how to do the equivalent of ":cmd ..." in my own bindings.
23:55:48 <jle`>  :def paste \s -> return ":! pbpaste " ++ s\
23:55:51 <jle`> er, without the last \
23:55:55 <jle`> i think that's the syntax
23:56:12 <pyrtsa> I mean, I want GHCi to evaluate the result. Not just print it.
23:56:23 <jle`> that's what :def syntax does
23:56:31 <jle`> oh
23:56:32 <jle`> i see
23:56:43 <jle`> that's interesting
23:57:34 <pyrtsa> I've set up several commands with :def already. The problem is they aren't really functions I could call, and I can't see how the built-in ":cmd" is implemented (see its usage info in GHCi by calling ":help").
23:57:47 * hackagebot strict-base-types 0.4.0 - Strict variants of the types provided in base.  https://hackage.haskell.org/package/strict-base-types-0.4.0 (SimonMeier)
23:59:25 <pyrtsa> Hmm, got this far in source: https://github.com/ghc/ghc/blob/master/ghc/InteractiveUI.hs#L1352-L1363
