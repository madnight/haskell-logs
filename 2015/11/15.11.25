00:07:40 * hackagebot postgresql-connector 0.2.2 - Initial project postgresql-connector from stack  https://hackage.haskell.org/package/postgresql-connector-0.2.2 (markfine)
00:07:40 * hackagebot strict-base-types 0.4.0 - Strict variants of the types provided in base.  https://hackage.haskell.org/package/strict-base-types-0.4.0 (SimonMeier)
00:08:48 <pyrtsa> I'm blind. It works!
00:09:00 <pyrtsa> :def paste \_ -> do { cmd <- System.Process.readProcess "pbpaste" [] ""; return $ ":cmd return " ++ show cmd }
00:09:08 <pyrtsa> (Plus extra handling for multi-line.)
00:09:23 <pyrtsa> jle`: ^ Thanks for your rubber-duckling help!
00:12:06 <jle`> np :)  can't say i did much! :)
00:23:16 <cow_2001> :D:D:D https://github.com/jb55/pipes-csv/pull/13
00:45:28 <jle`> i have a vector of length n and a vector of length m, and i have to dot their concatenation with a vector of length (n + m)
00:45:40 <jle`> i wonder if it's faster to concat the two inputs and dot it with the other vector
00:46:02 <jle`> or to keep my other vector to be two separate vectors n and m, dot them pair-wise, and then add the results
00:46:08 <jle`> i probably will have to just benchmark
00:46:37 <opqdonut> if you do a lazy streaming concat instead of building an actual vector it should be pretty fast
00:46:41 <opqdonut> fusion and all
00:47:26 <jle`> hm so you're asing that GHC might fuse it so that my original two vectors might not ever be allocated/built in the first place anyways
00:47:39 <jle`> and just the concat is allocated
00:48:05 <jle`> i basically have a choice on choosing how the third vector is represented.  as a vector of length (n + m) or as two vectors of length n and m each
00:48:27 <jle`> i probably will defer worrying about this until after everything is done
00:48:51 <jle`> although i do foresee this will be a bottleneck, it's not too difficult to fix later if i benchmark and find one is better than th eother
00:55:06 <rpfun> I have written a prime number sieve in haskell: http://lpaste.net/2660920243475447808 . It is quite close to the following python prime number sieve: http://lpaste.net/5262323772215525376 , but is slower by about 20% (ghc -O2). I was wondering if anyone could suggest speedups that can be made to the haskell code?
00:55:36 <rpfun> i am a bit surprised/disappointed that such short/simple python code completely blows the haskell implementation out of the water
00:56:58 <merijn> rpfun: realToFrac is generally a contender for "why is my numeric code slow?"
00:57:45 <rpfun> merijn: really? ok thanks! although that is only evaluated once...
00:57:51 <rpfun> also i think it might be unavoidable here
00:59:24 <rpfun> so in my tests, the haskell code for input 1e8 runs for ~595ms, with python at ~500ms. i would be surprised if running realToFrac once accounts for the discrepancy?
00:59:30 <merijn> rpfun: As for why it's slower, (GHC) haskell has very different performance characteristics than python, so I would not expect a direct translation to necessarily perform well
01:00:48 <rpfun> merijn: thanks, but i don't think there is a much better algorithm. I have tried benchmarking against the hackage version based on the wheel sieve, and my code runs much faster (not surprising, the purpose of that package is to be functional/lazy, mine is to be fast)
01:01:40 <merijn> rpfun: There's a bunch of implementations here too: https://wiki.haskell.org/Prime_numbers
01:02:14 <merijn> You could try writing it explicitly unboxed by hand, it depends where the cost is
01:02:19 <merijn> Did you try profiling the code?
01:02:23 <quicksilver> numpy isn't really python
01:02:33 <merijn> oh, it's using numpy?
01:02:35 <quicksilver> that's not really "haskell being slower than python"
01:02:47 <quicksilver> it's "haskell being slower than a pretty good numerics library which has a python API"
01:03:17 <merijn> I'm actually pretty impressed it compares so well to numpy :)
01:04:15 <rpfun> at least to my eye it mostly uses the bitarray feature of numpy, which should be well-reflected in unboxed vectors of Bools
01:04:29 <merijn> Not really if their bitarray is fast
01:04:39 <merijn> Unboxed vector of bools is still 1 word per element
01:04:48 <merijn> Whereas numpy is probably using an optimised bit vector
01:05:58 <rpfun> ah that's true, looking at the source Bool is a Word8!
01:06:00 <rpfun> why?
01:06:12 <rpfun> sorry, Unboxed bool is a word8
01:06:14 <quicksilver> simplicity probably
01:06:24 <quicksilver> so it might just be a cache effect
01:06:31 <quicksilver> how do they compare for 1e7?
01:06:35 <merijn> quicksilver: No, because anything smaller is generally (like 90% of the time) slower
01:06:39 <athan> Does anyone here know of the current intermediate language GHC is using to compile haskell? Last I checked, it was system FC-pro, but I feel like it must be changing because of the incoming 8 release: http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
01:07:02 <merijn> Word8 is really just a Word too, afaik (just with mod 255 semantics)
01:07:18 <merijn> Because using 1 byte storage is generally slow to access/process
01:07:28 <merijn> So in most cases you're better of wasting three bytes
01:07:41 <quicksilver> unboxed word8 vectors are byte-packed though
01:07:43 <merijn> Densely packed bit vectors are not one of those cases, but how many people implement those
01:08:10 <merijn> quicksilver: Sure, but that's still not a bit vector :)
01:08:14 <quicksilver> merijn: you are being inconsistent with yourself :P
01:08:31 <merijn> quicksilver: Not really
01:08:33 <quicksilver> you suggested that unboxed bool vectors were word because anything smaller is generally slower
01:08:46 <quicksilver> and now you're saying 'except for densely packed bit vectors'
01:08:55 <quicksilver> but what else would unboxed bool vector be for?
01:08:56 <merijn> quicksilver: I said Bool/Word8 is generally a Word
01:09:14 <quicksilver> then you were talking at cross purposes to athan and myself.
01:09:30 <quicksilver> he was asking why unboxed bool vectors were implemented as Word8 vectors.
01:09:30 <merijn> I didn't know that unboxed used a different representation
01:09:31 <rpfun> benchmarked for 1e7, Haskell still 20% slower
01:09:44 <merijn> i.e. packed Word8
01:09:53 <quicksilver> rpfun: interesting. hmm
01:09:54 <merijn> but packed Word8 is *still* slower than bit vector
01:10:07 <frerich> rpfun: It might be my lame benchmarking but with Python 2.7.10 vs. GHC 7.10.2 (compiled vs. -O2) the Haskell version is magnitudes faster. Maybe startup cost of Python? How did you benchmark it? I used 'time' :-}
01:10:25 <quicksilver> right. I'm just saying your answers were at cross-purposes to the questions.
01:10:36 <athan> o_0
01:11:02 <merijn> rpfun: Try replacing the bool vector with a specialised bit vector in haskell?
01:11:38 <merijn> frerich: How many times did you run them using time? (i.e. did you rerun with files in OS cache?)
01:12:07 <merijn> The first invocation has disk overhead dominating, most likely
01:12:11 <frerich> merijn: A couple of times until the numbers stabilize
01:12:17 <rpfun> frerich: i use %timeit in ipython
01:12:18 <merijn> ok
01:12:24 <rpfun> and criterion for haskell
01:13:42 <rpfun> is there a specialized bit vector in haskell? i don't see a clear mature package online
01:14:18 <quicksilver> athan: I don['t understand your question. That is the paper which introduces FC-pro.
01:14:30 <quicksilver> athan: what is your reason to think GHC8 will be anything other than FC pro?
01:15:10 <athan> quicksilver: InjectiveTypeFamilies, I'm just not sure if that would induce a redesign of the calculus
01:15:27 <athan> or if it's general purpose enough to accomplish it without changes, I'm just not sure
01:15:50 <quicksilver> I suspect it's just FC-pro
01:15:52 <quicksilver> I'm not 100% sure.
01:17:37 * hackagebot wai-session-postgresql 0.1.0.1 - PostgreSQL backed Wai session store  https://hackage.haskell.org/package/wai-session-postgresql-0.1.0.1 (hc)
01:20:32 <athan> quicksilver: Actually, lonokhov showed me a different branch of FC - http://www.cis.upenn.edu/~eir/papers/2013/fckinds/fckinds-extended.pdf
01:20:51 <athan> this has kind equality and embedded coherence (whatever that means!)
01:21:03 <lonokhov> athan: that paper is linked to from here https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell/Phase1
01:24:16 <frerich> rpfun: I think I couldn't reproduce your numbers unless I'm misreading things. Here are my results: http://lpaste.net/145928
01:25:01 <frerich> rpfun: Maybe I don't have a C-based 'numpy' installed so the Python module falls back to a pure Python implementation (Which is much slower)?
01:26:06 <rpfun> I don't think so. can you try higher inputs (~1e7, 1e8 work well on my machine)
01:26:27 <rpfun> also I am running from python 3, it's probably worth it to replace the // -> / in python 2
01:27:14 <rpfun> but yeah, that seems surprisingly good for haskell compared to what i'm getting
01:27:47 <athan> What would be a concise specification for a HM-typed lambda calculus, with sum and product types, like Haskell98? I'm thinking in terms of a pure type system, if  anyone has one lying around :)
01:28:19 <varaindemian> Choose a valid type signature for squares n = [x*x | x <- [1..n]]. And the answer is Integer -> Integer. I thought the answer would be Integer a => a -> [a]. Can someone explain me?
01:28:51 <athan> I'm guessing it would need some concept of a case statement in terms, and a concept of a pattern to match, too
01:29:50 <opqdonut> varaindemian: Integer is a type, not a type class
01:29:55 <frerich> rpfun: I annotated my paste now with the results for 1e8
01:30:06 <opqdonut> varaindemian: however Integral a => a -> [a] is a possible type for it
01:30:16 <opqdonut> :t \n -> [x*x | x <- [1..n]]
01:30:17 <lambdabot> (Enum t, Num t) => t -> [t]
01:30:34 <opqdonut> varaindemian: ^ that's the most general type (as deduced by GHC)
01:30:42 <varaindemian> opqdonut: so a typeclass would is Num. and Integer is included in Num, right?
01:30:47 <opqdonut> yes
01:30:55 <varaindemian> now I see
01:30:56 <opqdonut> Num gives you +
01:31:04 <opqdonut> Enum gives you [a..b]
01:31:09 <opqdonut> err
01:31:14 <opqdonut> Num gives you * in this case :)
01:32:34 <Freundlich> athan: Sum types require a simple form of pattern matching. I had to do this as an exercise of a course I did. Unfortunately, I don't have anything written down I could hand to you.
01:33:28 <athan> Freundlich: thank you, that makes sense at least. If you happen to find a simple unification algorithm for a calculus like this, maybe based on AlgorithmW, please let me know :)
01:35:19 <merijn> athan: Pure type system as in Barendregt? I'd say just System F_ω
01:35:45 <merijn> athan: I have a (somewhat brittle and untested) System F_ω implementation in haskell lying around :)
01:35:51 <athan> merijn: I was thinking that, but how do you encode sum types? :\
01:36:08 <athan> ooh! okay :) I'm really digging for type checkers, though
01:36:20 <merijn> athan: Well it has a type checker, obviously
01:36:25 <athan> I'm not sure if I'm looking for higher-order quantification just yet :\
01:36:36 <rpfun> frerich: so haskell does worse on the larger inputs for you as well :)
01:36:47 <athan> merijn: Oh, okay :| do you have a github profile I could lurk? :)
01:36:54 <merijn> https://github.com/merijn/lambda-except
01:37:00 <merijn> athan: No promises about correctness ;)
01:37:13 <rpfun> frerich: i just ran benchmarks for 1e3 myself, and yes, haskell beats out python for these small arguments
01:37:18 <athan> merijn: Thank you!!
01:37:37 <merijn> athan: This is mostly based on the SPJ & Erik Meijer paper "Henk: A Typed intermediate language"
01:37:44 <rpfun> for larger inputs it still does signficantly worse, unfortunately
01:38:06 <athan> merijn: Ahh okay, I was just looking at morte
01:38:11 <merijn> athan: It doesn't support inference, though. I plan to rewrite it a bit to support inference
01:38:38 <merijn> athan: Morte is also based on that paper, but Morte is full CoC, whereas I (currently) restrict it to System F_ω
01:38:46 <athan> merijn: Good luck :x the paper by SPJ on arbitrary-ranked inference is like an inch thick
01:38:59 <merijn> additionally, morte doesn't have datatypes it relies on Church encoding all datatypes
01:39:13 <athan> hmm, okay
01:39:14 <merijn> Whereas I added explicit ADTs
01:39:44 <merijn> (Recursive, parametric, sum, and product, etc.)
01:40:08 <athan> merijn: I'm going to do the same, I'll definitely check yours out
01:40:15 <athan> thank you for your help
01:40:48 <merijn> athan: And I assume you've been told to look into TaPL?
01:41:09 <athan> hmm, so declarations for _creating_ a type expression are part of the syntax you're working with? To represesnt `data Foo = ...`?
01:41:14 <athan> merijn: Already read it :P
01:41:44 <merijn> I use GADT style syntax (not actually supporting GADTs)
01:41:51 <merijn> athan: Lemme post some example source code
01:42:10 <athan> merijn: That's fine :) Just trying to get a hold of the scope of entities in the grammar
01:42:58 <rpfun> frerich: do you have llvm?
01:47:10 <merijn> athan: Looks like parametric types are still buggy :p
01:47:23 <athan> :(
01:48:11 <lpaste_> merijn pasted “System F_omega” at http://lpaste.net/145931
01:48:18 <merijn> i.e. that typechecks and works
01:49:16 <athan> merijn: That's awesome! okay cool
01:49:40 <lpaste_> merijn annotated “System F_omega” with “System F_omega (annotation)” at http://lpaste.net/145931#a145932
01:49:46 <merijn> But that doesn't, sadly
01:50:49 <athan> merijn: :\
01:50:56 <athan> still cool though
01:51:04 <frerich> rpfun: I do, but it doesn't help much (about 6%). I think there might rather be some benefit in being more precise about the types of your Haskell code to avoid that 'Integer' (arbitrary sized integers) is deduced everywhere
01:52:57 <rpfun> frerich: where is Integer inferred?
01:53:08 <merijn> athan: It's on hold now, I plan to work on it more in December
01:53:20 <merijn> rpfun: Use -Wall and it should warn you about defaulting to, e.g. Integer
01:54:20 <merijn> Actually, I just realised that annotated code is wrong by my own grammar
01:54:27 <merijn> But the right code doesn't work either, so :p
01:54:41 <merijn> Should be "/\(a : *) . \(l : List a) -> case l of"
01:55:05 <merijn> athan: Feel free to hunt for the typechecker issue :p
01:56:01 <rpfun> frerich, merijn: when running with -Wall i get nothing about defaulting to integer
01:56:21 <rpfun> i also added type signatures it did nothing except somehow slow down the code
01:56:24 <merijn> rpfun: Ok, the  it should be fine
01:56:29 <rpfun> (very small amount, probably fluctuations)
01:56:49 <absence> is there a clever way to make this shorter? if p1 then xs else filter p2 xs
01:57:36 <dramforever> absence: Seriously? Is it not short enough or something?
01:57:44 <kadoban> absence: Not really.
01:58:43 <rpfun> merijn, frerich: i'd really like to use haskell for numeric code, do you know if this performance deficiency is a common feature w.r.t. to python code? i include practical libraries like "numpy" when I say python; i'm not worried about reimplementing features in haskell, but i'd like the possibility to run as fast as at least python
01:59:39 <absence> kadoban: ok, thanks
02:00:08 <kadoban> rpfun: numpy is pretty nicely optimized C, so … the bar isn't as low as you seem to be implying there.
02:02:02 <rpfun> kadoban: sure, but it's not magic. i'm just wondering if there is some real fundamental barrier. i'm worried because this sieve is relatively simple; i don't see where (apart from possibly using a real bit vector) this code can be further improved: http://lpaste.net/2660920243475447808 .
02:02:24 <mauke`[]> (if p1 then id else filter p2) xs
02:02:49 <rpfun> and yet it runs signficantly slower than the python for large inputs
02:03:09 <kadoban> rpfun: What is "significantly"? I thought it was like 20% off or something you were talking about?
02:03:22 <rpfun> kadoban: yes, for me that is significant :)
02:03:33 <dramforever> mauke`[]: in fact, that's 2 chars longer
02:03:43 <absence> dramforever: often there are clearer alternatives to the first idea you come up with. for example "isJust (find (== a) xs)" vs "elem a xs". no need to be snarky :)
02:03:53 <rpfun> kadoban: when i say signficant, i mean consistently measurable (not a "fluke")
02:04:09 <dramforever> absence: oh that's reasonable =)
02:07:03 <kadoban> rpfun: Yeah, I mean … I'm not sure offhand. If it were me and I really have to tune that thing, I'd certainly start with profiling. I have no idea if it's guaranteed you can do it /much/ faster though. If you're looking at a 20% difference between tuned C and haskell, that's pretty good. I mean that's not /exactly/ what you're seeing, but I have no idea how much overhead python is adding there, probably not a lot though.
02:07:50 <ggVGc> are the Xmonad docs representative of haskell projects in general? Because I find them incredibly hard to navigate, with types such as data StackSet i l a sid sd
02:08:28 <fractalsea> I want to append a Word64 to a bytestring, what is the best way of doing this?
02:09:55 <tdammers> ggVGc: I wouldn't say so, no. Many Haskell projects have very spartan documentation, but the better and more popular ones are pretty well documented
02:10:28 <dramforever> ggVGc: what do you mean by "hard to navigate"
02:10:34 <pavonia> fractalsea: bytestring has conversion function for the Word types
02:10:42 <pavonia> +s
02:10:50 <absence> mauke`[]: ohh, point-free ;)
02:12:18 <ggVGc> dramforever: it's just very cryptic often. like in the example I gave with StackSet. The type parameters "i l a sid sd" say basically nothing about it
02:12:38 <ggVGc> and by extension it becomes very hard dealing with StackSet, which is a fundamental thing when configuring xmonad
02:12:47 <ggVGc> but maybe I'm just being stupid/missing something
02:12:52 <ggVGc> hence why I'm asking
02:13:13 <fractalsea> pavonia, oh yeah thanks I found it in the Builder module
02:13:40 <fractalsea> pavonia, do you have to use a parser to uncons the value?
02:14:13 <pavonia> You mean for decoding?
02:14:40 <fractalsea> yes
02:14:46 <dramforever> ggVGc: oh, sure I guess it's their problem in that case =)
02:15:30 <mtesseract> ggVGc: It happens sometimes for me that I am missing some kind of *manual* for a Haskell library, as opposed to a plain list of functions/types along with two lines of description for each taken straight from the source code.
02:15:32 <pavonia> fractalsea: Hhm, no idea what's the best way to do that, but I bet there's a package for that too
02:17:09 <ggVGc> mtesseract: yeah, but I often find that it's easier just picking up some source and reading through signatures in most other languages, compared to Haskell. But I don't feel that has to do with Haskell the language, but rather Haskell the community
02:17:35 <ggVGc> specifically things like type parameters of 1-2 letters and over use of pointfree for public APIs
02:17:40 <pavonia> fractalsea: Maybe the binary package
02:17:53 <fractalsea> OK, thank you :)
02:18:03 <pavonia> No problem
02:18:10 <mtesseract> ggVGc: I would say there is definitely space for improvement.
02:27:39 * hackagebot shellmate 0.2.3 - Simple interface for shell scripting in Haskell.  https://hackage.haskell.org/package/shellmate-0.2.3 (AntonEkblad)
02:27:41 * hackagebot alex 3.1.5 - Alex is a tool for generating lexical analysers in Haskell  https://hackage.haskell.org/package/alex-3.1.5 (SimonMarlow)
02:33:36 <varaindemian> The expression a f b g c is equivalent to ((a f)b)g c?
02:34:03 <mauke`[]> (((a f) b) g) c
02:35:40 <varaindemian> The type a -> f -> b -> g -> c is equivalent to a -> (f -> b -> (g -> c) cuz it's right associative?
02:36:04 <merijn> varaindemian: Missing a set of parenthesis, but yes
02:36:09 <mauke`[]> a -> (f -> (b -> (g -> c))), fully parenthesized
02:36:12 <varaindemian> merijn: the last one
02:38:22 <varaindemian> The type (a, f, b, g, c) is equivalent to:? I don't get this. which ones are functions which ones are parameters?
02:38:42 <mauke`[]> none
02:38:48 <mauke`[]> that's a tuple type
02:39:29 <varaindemian> so maybe this one is the answer: ((a, f, b, g, c))
02:40:48 <frerich> varaindemian: Maybe you're thinking of currying, i.e. 'a -> (f -> (b -> (g -> c)))' vs. '(a,f,g,b) -> c'?
02:41:06 <varaindemian> frerich: http://imgur.com/N5mXOs8
02:41:35 <frerich> Ah, so this is not about functions at all anymore, ok.
02:41:52 <varaindemian> frerich: then the last one should be the answer
02:42:06 <frerich> varaindemian: It's your exercise, not mine. I don't want to spoil the fun. :-)
02:42:33 <varaindemian> I was right :D
02:42:39 * hackagebot haxl 0.3.1.0 - A Haskell library for efficient, concurrent,  and concise data access.  https://hackage.haskell.org/package/haxl-0.3.1.0 (SimonMarlow)
02:45:29 * frerich imagines thousands of vuvuzelas going off
02:47:09 * blueonyx hears john cena fanfares
03:10:33 <tobiasBora> Hello !
03:10:37 <blueonyx> heya, whats the status quo on compiling multiple .hs in a package in parallel?
03:10:45 <blueonyx> hi
03:11:53 <bennofs> blueonyx: ghc 7.10 can do it
03:12:08 <bennofs> blueonyx: and I think cabal will do it by default if you use -j
03:12:11 <tobiasBora> A little question about ghci : I use ":set prompt "ghci> " in my .ghci file, but in multiline mode (:{ :} or :set +m) it continues to write "Prelude|" instead of "ghci |". How could I solve my problem ?
03:12:29 <bennofs> tobiasBora: :set prompt2 "ghci| "
03:12:35 <bennofs> iirc
03:12:50 * hackagebot tuple-generic 0.6.0.0 - Generic operations on tuples  https://hackage.haskell.org/package/tuple-generic-0.6.0.0 (Artyom)
03:13:01 <bennofs> λ: :set prompt<TAB>
03:13:02 <tobiasBora> bennofs: I have the error ghci> :set prompt2 "ghci|"
03:13:02 <bennofs> prompt   prompt2
03:13:03 <tobiasBora> Some flags have not been recognized: prompt2, ghci|
03:13:25 <tobiasBora> tab gives me only prompt...
03:13:30 <blueonyx> bennofs: how? -j only builds packages in parallel, but not modules
03:13:39 <bennofs> tobiasBora: works for me, GHCi 7.10.2
03:13:51 <tobiasBora> Hum... I have ghci 7.6.3
03:14:06 <geekosaur> right, IIRC that was adde din 7.8
03:14:06 <bennofs> blueonyx: ghc gained a -j flag in recent versions, and I believe it is used by cabal when you specify parallel builds
03:14:46 <blueonyx> bennofs: kthx, will loog into it
03:16:11 <bennofs> blueonyx: my `cabal build --help` lists -j for me
03:16:37 <bollu> Can I use diagrams for interactive stuff?
03:16:48 <bollu> or is it only for creating SVG/PNG/what have you?
03:17:24 <bennofs> bollu: I believe you can create interactive diagrams
03:17:52 <bollu> ooh, that's awesome :)
03:17:54 <bennofs> bollu: http://hackage.haskell.org/package/diagrams-lib-1.3/docs/Diagrams-Animation.html
03:18:33 <bollu> holy crap, I *really* gotta learn diagrams now ^_^
03:18:45 <bollu> I've been pushing it away for a while now
03:19:14 <bennofs> bollu: so I'm not sure if "interactive" is possible, but I think you can at least create animated SVGs
03:21:17 <bennofs> bollu: this looks like better documentation: http://projects.haskell.org/diagrams/doc/manual.html#animation
03:21:40 <luite> x
03:21:45 <luite> oops
03:25:52 <ggVGc> so, fmap show (Just 10) gives me 'Just "20'. How would I get "20" instead?
03:26:16 <jle`> ggVGc: what do you want to happen when it's Nothing ?
03:26:21 <frerich> ggVGc: What would you expect if it's a Nothing?
03:26:47 <jle`> `maybe stringWhenItsNothing show` should work
03:26:57 <jle`> > maybe "i am nothing :(" show $ Just 10
03:27:00 <lambdabot>  "10"
03:27:04 <jle`> > maybe "i am nothing :(" show $ Nothing
03:27:08 <lambdabot>  "i am nothing :("
03:27:19 <tobiasBora> bennofs: Great it works thank you !
03:27:24 <jle`> also you might have bigger issues if fmap show (Just 10) gives you Just "20"
03:27:27 <ggVGc> ah yeah
03:27:51 <ggVGc> so, what I actually want to do is make a [Maybe a] into [a] and then fmap show [a]
03:27:57 <ggVGc> I guess
03:28:14 <frerich> ggVGc: You might want 'mapMaybe', but still - you need to decide what to do about Nothing values
03:28:31 <tobiasBora> Hum... Is it possible to have the full multiline bloc rewritten when I do up arrow in multiline mode in ghci ?
03:28:33 <ggVGc> frerich: yeah, I want to filter away Nothing values
03:29:02 <geekosaur> :t catMaybes
03:29:04 <lambdabot> [Maybe a] -> [a]
03:29:16 <bollu> geekosaur: why is it called "catMaybes"?
03:29:32 <bollu> >catMaybes [Just 1, Nothing, Just 2]
03:29:38 <bollu> > catMaybes [Just 1, Nothing, Just 2]
03:29:40 <jle`> i always thought of it as "concat all the Maybes"
03:29:40 <lambdabot>  [1,2]
03:29:41 <geekosaur> it ought to be called catJusts because it concatenates the Just values
03:30:00 <jle`> maybe it's supposed to possibly give you a cat.  but every time, it doesn't :(
03:30:08 <jle`> "cat, Maybe?"
03:30:15 <jle`> "nope, just an [a]"
03:30:26 <bollu> I was thinking it was some schrodinger's cat reference
03:31:25 <geekosaur> > catMaybes [Nothing, Just 'm', Nothing, Just 'e', Nothing, Just 'o', Nothing, Just 'w']
03:31:26 <liste> maybe I'll try to evaluate it 1000000000 times to see if a cat comes out (:
03:31:29 <lambdabot>  "meow"
03:32:51 * hackagebot rncryptor 0.0.2.3 - Haskell implementation of the RNCryptor file format  https://hackage.haskell.org/package/rncryptor-0.0.2.3 (AlfredoDiNapoli)
03:36:59 <mpickering> Is [$qq|expr] valid quasiquoter syntax?
03:37:41 <mpickering> mainly wondering about the $
03:40:46 <mpickering> hmm, seems like the old syntax, does anyone know how old?
03:43:23 <hackrilege> > (+) <$> [1,2,3] <*> pure 5
03:43:24 <lambdabot>  [6,7,8]
03:44:01 <hackrilege> how does pure know what shape the list is? or is it because list has an applicative instance? is there a natural way to define pure for trees?
03:45:16 <bollu> hackrilege: even the list "pure" is one of two instances. The other valid instance is "zippyList"
03:45:36 <hackrilege> (+) <$> [1,2,3] <*> pure 5 = [1+,2+,3+] <*> pure 5
03:45:45 <bollu> hackrilege: but we pick the current definition of Applicative for List because it admits a monad while the other does not
03:46:01 <merijn> hackrilege: Pure just generates a list of length 1
03:46:02 <hackrilege> how does the other not?
03:46:15 <hackrilege> @src <*>
03:46:16 <merijn> hackrilege: The applicative for lists applies the function to the cartesian product
03:46:16 <lambdabot> Source not found. Take a stress pill and think things over.
03:46:31 <merijn> > (+) <$> [1,2] <*> [3,4]
03:46:34 <lambdabot>  [4,5,5,6]
03:46:45 <bollu> hackrilege: in the other list Applicative, you "zip" the two lists together with the given operation
03:46:48 <merijn> Note the fact that there's 4 (2*2) results, not two
03:47:04 <opqdonut> hackrilege: the other instance is the ziplist instance. it doesn't admit a monad e.g. because join :: [[a]] -> [a] is tricky
03:47:22 <hackrilege> map fold
03:47:32 <merijn> opqdonut: s/tricky/impossible
03:47:33 <opqdonut> (sure you could do join = map head, but that would break some laws IIRC)
03:48:03 <hackrilege> @where ziplist
03:48:04 <lambdabot> I know nothing about ziplist.
03:48:10 <bollu> @where ZipList
03:48:10 <lambdabot> I know nothing about ziplist.
03:48:21 <opqdonut> https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Applicative.html#t:ZipList
03:48:47 <hackrilege> lambdabot is obstinateand belligerent
03:48:51 <bollu> > getZipList $ (+) <$> ZipList [4, 5, 6] <*> ZipList [1, 2, 3]
03:48:53 <lambdabot>  [5,7,9]
03:49:17 <bollu> the problem is that you can't write a sensible (>>=) instance on it that satisfies the monad laws IIRC
03:49:41 <hackrilege> ZipList fs <*> ZipList xs = ZipList (zipWith id fs xs)
03:50:12 <hackrilege> @src (>>=)
03:50:12 <lambdabot> Source not found. Do you think like you type?
03:50:15 <hackrilege> omg
03:50:37 <merijn> @src just does lookups in a textfile
03:50:37 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
03:50:52 <merijn> There's no reason to expect anything but the most basic things to be in there
03:51:15 <hackrilege> ok
03:51:31 <hackrilege> yeh, i thought there was a default definition in terms of join...
03:52:01 <bollu> (>>=) = fmap . join?
03:52:28 <bollu> x >>= f = join (fmap f x) ?*
03:52:34 <hackrilege> is foldm good?
03:52:56 <hackrilege> :t (fmap.join)
03:52:57 <lambdabot> Functor f => (a -> a -> b) -> f a -> f b
03:53:06 <hackrilege> :t (>>=)
03:53:07 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:53:10 <hackrilege> no
03:53:35 <bollu> :t \x f -> join (fmap f x)
03:53:37 <lambdabot> Monad m => m a1 -> (a1 -> m a) -> m a
03:53:54 <bollu> ^ correct definition :)
03:54:03 <opqdonut> :t (join.).flip fmap
03:54:04 <lambdabot> Monad m => m a1 -> (a1 -> m a) -> m a
03:54:13 <opqdonut> now 200% less point
03:54:28 <hackrilege> +1
03:55:01 <bollu> I wish I understood that stupid use of (.) :P
03:55:13 <bollu> Ive seen it so many times but it just doesn't click
03:55:19 <hpc> :t (join .)
03:55:20 <lambdabot> Monad m => (a -> m (m a1)) -> a -> m a1
03:55:24 <hpc> yeah
03:55:34 <hackrilege> :t (\a b -> a.b)
03:55:36 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:55:40 <hackrilege> :t (\a b -> (a.).b)
03:55:40 <opqdonut> I just spot the (f.). pattern
03:55:41 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
03:55:50 <opqdonut> and remember it means composition of a twoary function
03:55:58 <bollu> :t \f -> (.) f
03:55:59 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:56:14 <bollu> :t \f -> ((.) f).
03:56:15 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
03:56:17 <hackrilege> @pl (\a b -> (a.).b)
03:56:17 <lambdabot> (.) . (.)
03:56:36 <bollu> :t \f ->  ((.)((.) f))
03:56:38 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
03:56:51 <bollu> *sigh*
03:57:05 <hackrilege> omg so many parenthesis
03:57:18 <hackrilege> anyway...
03:57:51 <bollu> yeah, so, different things have multiple Applicative instances. The "most sensible" one is picked. Which is up for debate…
03:57:53 <hackrilege> (join.).flip fmap
03:58:23 <hackrilege> the problem was defining join no?
03:58:31 <bollu> yep
03:58:40 <bollu> one that holds the laws at least
03:58:55 <hackrilege> the other instance is the ziplist instance. it doesn't admit a monad e.g. because join :: [[a]] -> [a] is tricky
03:59:06 <hackrilege> map fold?
03:59:19 <merijn> map fold doesn't remotely typecheck
03:59:22 <merijn> :t map foldr
03:59:23 <lambdabot> Foldable t => [a -> b -> b] -> [b -> t a -> b]
04:00:00 <hackrilege> :t (\f -> map (foldr1 f))
04:00:01 <lambdabot> Foldable t => (b -> b -> b) -> [t b] -> [b]
04:00:02 <bollu> yeah, pretty much. for the usual list type you can just flatten it, but that doesn't work for ZippyList
04:00:32 <hackrilege> what is this zippyList and why is it behaving so poorly!? breaking laws
04:00:47 <bollu> ZipList* 
04:01:11 <hackrilege> i can find no documentation for ZippyList
04:01:18 <hackrilege> oh ok sry
04:01:24 <frerich> merijn: Not even remotely? Typechecking is just one 'id' away!
04:01:46 <hackrilege> newtype ZipList a = ZipList { getZipList :: [a] }
04:01:48 <bollu> no, my mistake :) I remember it first being explained to me as "Zippy" IIRC so I always wind up looking for "ZippyList"
04:01:54 <hackrilege> ...
04:02:09 <bollu> hackrilege: it's just a wrapper over the regular list
04:02:09 <quicksilver> ziplist has a 'join' if you promise to stick to lists of a fixed length
04:02:15 <hackrilege> anyway, thats just a list, so i dont see why folding it to make join wouldnt work
04:02:17 <quicksilver> (including infinite)
04:02:22 <bollu> so we can write custom Functor and Applicative instances
04:02:29 <athan> quicksilver: I was wondering!!
04:02:33 <bollu> quicksilver: what? really?
04:02:36 <bollu> quicksilver: do show :)
04:02:57 <quicksilver> you take the diagonal
04:03:06 <quicksilver> the 0th element of the 0th list, the 1st of the 1st, the 2nd of the 2nd
04:03:07 <quicksilver> etc
04:03:19 <hackrilege> ....
04:03:24 <bollu> quicksilver: hm
04:03:37 <quicksilver> join (xs:xxs) = head xs : join (map tail xxs)
04:03:39 <hackrilege> thats not folding each internal list to one ellement, you have a more specific indexed fold thing going on there
04:03:52 <athan> quicksilver: That makes sense - the cartesian version includes all entities, while the parallel instance accounts only for it's `n` entity
04:04:07 <mpickering> http://zenzike.com/posts/2010-10-21-streams-and-monad-laws
04:04:13 <bollu> quicksilver: isn't it equivalent to the "Omega" monad then? (at least I think that is what it is called)
04:04:17 <athan> but still kinda borky :\
04:04:35 <quicksilver> bollu: Omega is that for the infinite case, yes
04:04:42 <quicksilver> but it also works for "lists of length 4"
04:04:44 <hackrilege> zipWith (!) l [1..]
04:04:47 <hackrilege> zipWith (!) l [0..]
04:04:52 <quicksilver> or any fixed length
04:05:06 <hackrilege> zipWith (!!) l [0..] sorry!
04:05:33 <orion> Hi. Does anyone know how to write a {#fun#} directive for this?: http://lpaste.net/7268788817660739584
04:05:40 <bollu> I want to prove this by hand
04:05:44 <bollu> it seems too good to be true :P
04:05:59 <bollu> I mean, I can "see" why it works by thinking of the cartesian product
04:06:05 <orion> I'm getting errors like, "Couldn't match type ‘CChar’ with ‘C2HSImp.CUChar’"
04:06:52 <hackrilege> oh so because you cant say much about the general properties of the Applicative type parameter, namely how it composes.. so thats when you think you might like to restrain Applicative a to Monoid a => Apllicative a
04:07:01 <bollu> > take 10 $ do x <- [1..]; y <- [1..]; return [x, y]
04:07:02 <quicksilver> athan: yes, the parallel instance always only lets each parallel see its own stuff
04:07:03 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9],[1,10]]
04:07:08 <quicksilver> athan: which does make sense.
04:07:20 <bollu> right, the usual List doesn't diagonalize
04:07:21 <bollu> hm
04:07:32 <hackrilege> as then we would have an a->a->a to fold with
04:07:33 <quicksilver> oh it isn't omega, bollu 
04:07:35 <athan> quicksilver: Thanks :)
04:07:46 <quicksilver> omega is just the normal list instance re-ordered for fair choice
04:08:07 <bollu> quicksilver: "fair choice" is the way in which you construct fractions from integers right?
04:08:28 <hackrilege> so what about when we have applicatives of monoids?
04:08:31 <bollu> quicksilver: by defining levels and picking all elements whose row + col <= level?
04:08:44 <merijn> hackrilege: That makes no sense, applicative and monoid have different kinds
04:08:51 <hackrilege> ?
04:08:52 <bollu> quicksilver: the proof that N x N  ~= N?
04:08:54 <hackrilege> of monods
04:08:56 <hackrilege> monoids
04:08:57 <merijn> hackrilege: Monoid is for types of kind *, Applicative is for types of kind * -> *
04:09:04 <hackrilege> yeh
04:09:11 <hackrilege> like lists of doubles
04:09:15 <quicksilver> athan: it's also consistent with the reader monad, viewing lists of length 4 as functions from data Four = One | Two | Three | Four
04:09:19 <blueonyx> bennofs: what's your cabal version? mine has -j but only builds multiple packages in parallel, i want to build the modules of the package i'm developing to build in parallel
04:09:19 <merijn> So "Monoid a => Applicative a" is a kind error
04:09:24 <hackrilege> oh
04:09:29 <hackrilege> Applicative Monoid
04:09:36 <merijn> Also kind error
04:09:39 <hackrilege> !!!
04:09:45 <athan> quicksilver: That's a brilliant correspondence
04:09:48 <merijn> Monoid :: * -> Constraint
04:09:53 <hackrilege> oh
04:09:58 <quicksilver> athan: and the infinite one is functions from Nat
04:09:59 <bollu> quicksilver: I don't understand the Reader correspondence?
04:10:00 <merijn> Applicative :: (* -> *) -> Constraint
04:10:17 <hackrilege> i never really understood that
04:10:23 <quicksilver> bollu: a list of four elements [a,b,c,d] is also a function defined only on the numbers 0,1,2,3
04:10:24 <hackrilege> i get constraint error sometimes
04:10:24 <bennofs> blueonyx: cabal-install version 1.22.6.0. That cabal install version has a `-j` flag for the `build` command as well (`build` only builds a single package, so that is probably not used package parallelism)
04:10:42 <quicksilver> bollu: f 0 = a; f 1 = b; f 2= c; f 3 = d;
04:11:16 <bollu> quicksilver: so.. (!!) ?
04:11:26 <hackrilege> hmmm is Num kind (*->*) -> Constraint?
04:11:41 <bollu> quicksilver: but.. how is it Reader?
04:11:41 <hackrilege> i can say Num a => Applicative a
04:11:57 <hackrilege> sorry (*)->Constraint
04:12:01 <quicksilver> bollu: so we have a mapping between (lists of length 4) and (functions from {0,1,2,3})
04:12:14 <quicksilver> bollu: but (functions from) is *already* an Applicative and a Monad
04:12:34 <quicksilver> and under this correspondance it is the same thing as ZipList
04:12:37 <bollu> quicksilver: because Reader a is equivalent to ((->) a) ?
04:12:40 <quicksilver> yes.
04:12:44 <bollu> huuh
04:13:29 <hackrilege> so we require that the lists are of equal length
04:13:33 <bollu> oh, oh, oh my god. I geddit. You view a list l as a partially applied ((!!) l )
04:13:39 <athan> quicksilver: So they're not counted, they're "identified"
04:13:43 <athan> that's very awesome
04:13:44 <bollu> which is waiting for the "index" to give a list eleent
04:13:45 <bollu> slick
04:13:47 <bollu> element*
04:14:05 <hackrilege> but its not fold so it is useless
04:14:07 <bollu> athan: what do you mean by that?
04:14:17 <athan> bollu: for ZipList
04:14:34 <athan> I had the impression that it was something like the intersection of both lists
04:14:34 <hackrilege> is there a mapFold?
04:14:38 <quicksilver> bollu: yes. About the partially applied (!!).
04:14:44 <quicksilver> > let f 0 = 'a'; f 1 = 'b'; f 2 = 'c'; f 3 = 'd'; g 0 = 'w'; g 1 = 'x'; g 2 = 'y'; g 3 = 'z'; in ((,) <$> f <*> g) 0
04:14:46 <lambdabot>  ('a','w')
04:14:55 <Axman6> hackrilege: what do you want that to do?
04:14:56 <athan> which it is, but by their identified elements, not simply because one has a smaller length
04:14:58 <quicksilver> ^^ that uses the applicative instance for functions. but it gets the ZipLlist-style answer.
04:15:16 <hackrilege> :t map.foldl
04:15:18 <lambdabot> Foldable t => (a -> a1 -> a) -> [a] -> [t a1 -> a]
04:15:21 <quicksilver> > let f 0 = 'a'; f 1 = 'b'; f 2 = 'c'; f 3 = 'd'; g 0 = 'w'; g 1 = 'x'; g 2 = 'y'; g 3 = 'z'; in map ((,) <$> f <*> g) [0,1,2,3]
04:15:24 <lambdabot>  [('a','w'),('b','x'),('c','y'),('d','z')]
04:15:25 <quicksilver> hackrilege: there is a foldMap
04:15:39 <hackrilege> @src foldMap
04:15:39 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:15:42 <hackrilege> sorry...
04:15:47 <bollu> :t foldMap
04:15:49 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
04:16:10 <athan> hackrilege: You can implement it with `Endo`, pretty sure
04:16:16 <athan> er
04:16:17 <quicksilver> if t is also a Functor, then we have "foldMap f = fold . fmap f"
04:16:22 <athan> yeah :P
04:16:22 <quicksilver> but not all Foldables are Functors.
04:16:23 <bollu> quicksilver: I don't get it - ((,) <$> f <*> g) does what exactly?
04:16:26 <quicksilver> (most foldables)
04:16:36 <bollu> oh, I geddit
04:16:44 <quicksilver> bollu: that was the simplest example using Applicative I could come up with.
04:16:44 <bollu> you're lifting f and g into tuples. 
04:16:58 <quicksilver> it just typles up the result so you can see applicative working
04:17:00 <hackrilege> ok, so i think im looking for a class which has naturally foldable internal lists. a monad whoes join is written in terms of a maping a partially applied fold to the lists. i know it dosent look much like join because it requires a function and a basecase, but a monoid has these things....
04:17:18 <athan> bollu: (+) <$> xs <*> ys
04:17:22 <quicksilver> > (,) <$> [0,1,2] <*> ['a','b','c']
04:17:24 <lambdabot>  [(0,'a'),(0,'b'),(0,'c'),(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c')]
04:17:26 <athan> > (+) Just 1 <*> Nothing
04:17:27 <lambdabot>      Couldn't match expected type ‘Maybe (a0 -> b)’
04:17:28 <lambdabot>                  with actual type ‘a1 -> Maybe a1’
04:17:28 <lambdabot>      Probable cause: ‘Just’ is applied to too few arguments
04:17:33 <athan> :|
04:17:36 <quicksilver> ^^ the list instance is not zippy!
04:17:39 <athan> > (+) <$> Just 1 <*> Nothing
04:17:40 <quicksilver> it's cartesiany
04:17:40 <lambdabot>  Nothing
04:17:48 <bollu> quicksilver: right, but I'd never seen anyone use the applicative over *functions* before :P
04:17:53 <bollu> took a second for the types to click
04:17:54 <quicksilver> yes
04:18:06 <quicksilver> well I was making the point that the applicative for functions is the applicative for ZipList :)
04:18:18 <quicksilver> "pointwise" the mathematicians call it.
04:18:23 <athan> quicksilver: Would `Maybe` be /extra/ zippy, in that `Nothing` consumes the identity of `Just _`?
04:18:40 <hackrilege> so now lets make it a monad
04:18:41 <quicksilver> I would say that Maybe is shortcircuiting
04:18:46 <quicksilver> one Nothing blows it all up
04:19:13 <athan> Only because Nothing is a consuming element though
04:19:18 <hackrilege> can we ask that the thing we have a collection of is a Monoid?
04:19:22 <bollu> oh my god that is so stupid and awesome it hurts. you're using the fact ((->) a) is an Applicative
04:19:26 <bollu> right?
04:19:39 <hackrilege> yes he is
04:20:13 <quicksilver> yes
04:20:21 <bollu> quicksilver: Applicative over Maybe is like bitwise AND, Alternative over Maybe is bitwise OR is the way I like to look at it
04:20:29 <hackrilege> how can we ask that the thing we have a collection of is a Monoid?
04:20:42 <quicksilver> the point I was making was just that the applicative/monad we were talking for for ZipList was already there in the prelude
04:20:46 <quicksilver> just hiding under a different name
04:20:54 <bollu> hackrilege: show that you have an identity element and an associative binary operator?
04:21:02 <hackrilege> we have those
04:21:05 <quicksilver> hackrilege: well normally you don't bother
04:21:11 <hackrilege> we can use natural numbers for example
04:21:15 <quicksilver> restricting the types in collections is counter productive
04:21:21 <quicksilver> instead you just restrict on operations
04:21:22 <hackrilege> its nesacary infact
04:21:28 <quicksilver> kind fo the point of Foldable is this
04:21:36 <hackrilege> if we want to fold those internal lists we will need a base case and a function
04:21:45 <quicksilver> to say "if this container happens to contain Monoids then we can fold them"
04:22:09 <hackrilege> oh so Foldable is a Monad of Monoids?
04:22:16 <quicksilver> no.
04:22:17 <athan> :|
04:22:22 <hackrilege> then its no good!
04:22:29 <quicksilver> Foldable is a container which, if you happen to fill it with Monoids, you can reduce.
04:22:42 <hackrilege> sorry an Applicative of Monoids that is therefor a foldable monad
04:23:10 <quicksilver> general haskell design principle - don't restrict thetypes of things you can put in containers
04:23:11 <hackrilege> just as applicative is a container which if i happen to fill it with monoids i get a monad
04:23:14 <bollu> hackrilege: what does an "Applicative of Monoids" mean?
04:23:23 <quicksilver> make your containers fully polymorphic
04:23:30 <quicksilver> and just restrict certain operations.
04:23:46 <hackrilege> same as applicative of numbers would mean instance Num a => Applicative a where
04:24:04 <quicksilver> that doesn't make sense, hackrilege
04:24:10 <quicksilver> numeric types can't be applicative.
04:24:14 <hackrilege> i am describing a datatype mapFold
04:24:15 <quicksilver> it's a kind error, again
04:24:28 <hackrilege> which is a monad
04:24:34 <quicksilver> you could have Num f a => Applicative f
04:24:39 <athan> @msg lambdabot > getMax <$> getOption $ foldMap (Option  . Just . Max) [1,2,3,4,5]
04:24:39 <lambdabot> Not enough privileges
04:24:53 <athan> >.>
04:24:54 <quicksilver> Num (f a) => Applicative f
04:25:00 <hackrilege> yes
04:25:02 <quicksilver> athan: lambdabot doesn't have semigroups in scope anyway.
04:25:03 <jle`> i don't think that works
04:25:10 <athan> shoot
04:25:21 <athan> I was going to try `ala`, but then my brain broke
04:25:26 <quicksilver> I dobut it's useful but it is at least kind-correct
04:25:38 <quicksilver> athan: I don't think you can `ala` composed constructors.
04:25:48 <quicksilver> although maybe I misunderstand.
04:26:07 <hackrilege> (Monoid (f a), Applicative f) => Monad f
04:26:09 <bollu> :t ala
04:26:11 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
04:26:22 <bollu> okay.. I need an explanation :P
04:26:25 <athan> quicksilver: Really? I thought it followed a lens-like compoisition principal
04:26:26 <hackrilege> is that ok now?
04:26:32 <quicksilver> athan: but you need instances.
04:26:34 <athan> bollu: Just... just ignore it for now :|
04:26:47 <athan> quicksilver: that makes sense, and you can't make them without overlapping
04:26:52 <quicksilver> athan: you'd need "Option . Just" to be an instance of Wrapped/Rewrapped
04:26:53 <bollu> athan: "for now"? :P so there is a stage in Haskell learning that I get it to?
04:27:03 <jle`> hackrilege: that doesn't quite work because `a` doesn't appear in on the other side of the =>
04:27:14 <athan> bollu: It's some dark magic
04:27:35 <jle`> it also doesn't really make too much sense
04:27:36 <bollu> athan: isn't most of haskell that way until you "get it"? :P
04:27:38 <hackrilege> omg!
04:27:46 <hackrilege> el frustraition
04:27:46 <jle`> hackrilege: Monad is a property of `f`, not of `f a`
04:27:47 <athan> > ala Sum $ fold [1,2,3,4]
04:27:49 <lambdabot>      Could not deduce (Num ((b0 -> Sum b0) -> e -> Sum b1))
04:27:49 <lambdabot>      from the context (Num b1, Num ((b -> Sum b) -> e -> Sum b1))
04:27:49 <lambdabot>        bound by the inferred type for ‘e_11234’:
04:27:53 <athan> I think i borked that one
04:28:08 <jle`> hackrilege: what would you have expected the type of `return` to be?
04:28:11 <jle`> for such an instance?
04:28:29 <quicksilver> hackrilege: it may be that the process you are going through is helpful to you, but I think you are spending too much time thinking "how do I express this with haskell typeclasses" and not enough time simply thinking "what are my data types and what are my operations"
04:28:29 <jle`> it doesn't quite make sense
04:28:36 <hackrilege> how do i write "this is an instance making all applicative collections of monoids into monads"
04:28:37 <bollu> oh lol, it's lens
04:28:39 <bollu> I give up
04:29:24 <hackrilege> my datastructure is foldable, so are its ellements, and the ellements of tose e.t.c forever to a fixed point
04:29:24 <quicksilver> hackrilege: start with data types and operations and then look to see if, actualy, some of those operations represent type class instances.
04:29:44 <quchen> > ala Sum foldMap [1,2,3,4]
04:29:46 <lambdabot>  10
04:29:50 <jle`> hackrilege: "applicative collections of monoids" sounds like something of kind *
04:29:55 <jle`> but Monads can only be * -> *
04:29:55 <athan> gaaa
04:29:57 <quchen> > ala Product foldMap [1,2,3,4]
04:29:59 <lambdabot>  24
04:30:04 <jle`> they're fundamentally uncompatable ideas
04:30:06 <athan> thanks quchen
04:30:08 <hackrilege> quicksilver: the whole exersize is to use haskell typclasses to express a concept from another field
04:30:19 <bollu> what the hell is ala? >_<
04:30:21 <quchen> athan: The docs mention quite a few examples. http://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Wrapped.html#v:ala
04:30:28 <hackrilege> i can code fine without them. but i need to use them for this and its a steep learning curve.
04:30:46 <athan> quchen: I'll check those out, the only exposure I had was wikipedia on epigram :|
04:30:50 <jle`> it might be a fruitless exercrise, as you're using typeclasses for something they're not meant to be used for :p
04:30:57 <quicksilver> why is "using typeclasses to express this concept" a goal?
04:31:03 <quicksilver> are you trying to answer someone's question?
04:31:08 <quicksilver> or are you trying to write a program?
04:31:09 <quicksilver> or....
04:31:11 <jle`> typeclasses are bad at expressing 99.999999% of concepts
04:31:15 <hackrilege> im generating an expressive communication
04:31:34 <hackrilege> and will use datatypes to avoid proxy types
04:31:38 <athan> bollu: It's pronounced "ala some method to knowledge... do something that doesn't involve it yet", I think
04:32:01 <hackrilege> but its key i get the thing im working with to be a monad, since the paper is titled such and such is a monad...
04:32:17 <quicksilver> aha
04:32:27 <jle`> the idea that you have is fundamentally incompatable with the idea of the Monad typeclass
04:32:27 <quicksilver> the old "I need to satisfy the promise in the title of this paper" reason :)
04:32:37 <jle`> but
04:32:37 <hackrilege> now if its a monoid i get 0 and a->a->a i need for an internal fold
04:33:05 <hackrilege> its kind of a Applicative (Applicative (Applicative ....... Monoid))))))))
04:33:14 <jle`> remember that Monads are type *constructors*
04:33:27 <jle`> but "applicatives containing monoids" are the types of *values*
04:33:40 <jle`> so you can't really make Int a Monad
04:33:42 <hackrilege> i get that
04:34:05 <hackrilege> but since the type parameter is applied at the end of an infine nesting, maybe i escape unscathed
04:34:14 <hackrilege> infinite
04:35:05 <jle`> Monad is a property of a type constructor, though...not a fully applied type.  you're trying to state properties of the fully applied type, but Monad says things about the constructor itself
04:35:07 <hackrilege> maybe im saying actually i have an applicative containing monads, and thats why its a monad. is that better?
04:35:20 <jle`> what is an example of an Applicative containing monads?
04:35:28 <hackrilege> a list of lists
04:35:54 <athan> But you would never be able to use the monad contained, unless you could destroy the applicative level
04:36:03 <hackrilege> !?
04:36:03 <quicksilver> Applicative ( Applicative ( Applicative ....) ) ) makes no sense either
04:36:04 <jle`> one thing you can do is create your own MonoMonad typeclass
04:36:07 <athan> (unless they're the same type, liek a list of lists)
04:36:09 <hackrilege> that sounds distressing
04:36:11 <jle`> for things that are *
04:36:11 <quicksilver> many recursive types are Applicate
04:36:24 <jle`> Applicative (Applicative (Applicative ... is a kind-error, yes
04:36:26 <quicksilver> you dont 'have to nest the Applicative constraint just because your type is nested
04:36:33 <hackrilege> they are the same type
04:36:35 <jle`> do you mean Applicateive f => f (f (f .. )) ?
04:36:35 <athan> that's a specific difference between a monad and an applicative
04:36:42 <quicksilver> Tree a = Leaf a | Rose a [Tree a]
04:36:49 <athan> a monad can comprehend a level nested in itself, an applicative cannot
04:36:53 <hackrilege> yes i do jle'
04:37:04 <quicksilver> is nested, it's recursive, and doesn't need nested constraints
04:37:06 <jle`> btw, there's a way to give any Applicative a Monad instance for free
04:37:19 <athan> this is useful for something like Elm, which cannot represent hotswapping, like `Signal (Signal a)`, because it's not a monad
04:37:24 <jle`> or, construct a Monad from an Applicative instance for free
04:37:28 <hackrilege> no but this would be a Tree (Tree a)
04:37:48 <hackrilege> no but this would be a Tree (Tree (Tree a)) e.t.c.
04:37:57 <jle`> i think i see what you're getting at
04:38:00 <quicksilver> ok but since Tree is a Monad those are reducible.
04:38:05 <jle`> you can encode that as a data type
04:38:08 <athan> hackagebot: I think you need recursion :P
04:38:11 <hackrilege> hmm
04:38:13 <hackrilege> sounds good
04:38:15 <jle`> data Fix f a = Fix (f (Fix f a))
04:38:18 <hackrilege> yeh
04:38:20 <hackrilege> that one
04:38:33 <jle`> a `Fix Tree a` is equivalent to a Tree (Tree (Tree (Tree ...)))) forever
04:38:36 <hackrilege> the fixed point is the Monoid?
04:38:37 <quicksilver> you don't normally 'Fix' something which is already recursive though
04:38:44 <hackrilege> nvm
04:38:50 <hackrilege> i am
04:39:07 <quicksilver> beacuse the point of 'Fix' is to separate the recursion from the structure
04:39:13 <jle`> anyways, there's a neat thing you can do to construct a Monad out of any Applicative f
04:39:27 <hackrilege> its not an applicative i lied sorry
04:39:33 <hackrilege> or at least im not sure if it is
04:39:37 <athan> hackagebot: well, it's an `mconcat` for the `replicate infinity f`, if your monoid was an endomorphism
04:39:37 <hackrilege> its definatly foldable
04:39:57 <hackrilege> athan, i almost understand that
04:40:09 <jle`> data Free f a = Pure a | Free (f (Free f a))
04:40:14 * athan throws the wrench in the gears with honor and grace
04:40:15 <hackrilege> the problem is im not sure how to define pure for trees
04:40:44 <athan> hackrilege:  Are the trees keyed by some index?
04:40:52 <jle`> in this case, inhabitants of `Free f a` would roughtly a, f a, f (f a), f (f (f a)), f (f (f (f a))), etc.
04:40:53 <athan> if not, then it would be the singleton tree with no children :)
04:41:26 <jle`> it turns out that if your type is a Functor, you can write a Monad instance for this
04:41:27 <athan> if so, then you might not be able to, because it would require more information than just the element you want to embed
04:41:40 <hackrilege> but how is that a function over eache ellement? id like a tree the same shape poulated with functions to make a nice zipWith
04:41:51 <hackrilege> in my mind thats what applicative does
04:42:10 <athan> remember, `pure f <*> xs ~ f <$> xs`, and also `f <$> pure x ~ pure (f x)` :)
04:42:15 <hackrilege> im saying how is pure f being a single leaf going to opperate nicely over the tree?
04:42:54 <hackrilege> > (+) <$> [1,2,3] <*> pure 5
04:42:56 <lambdabot>  [6,7,8]
04:43:03 <hackrilege> how does pure know what shape the list is? or is it because list has an applicative instance? is there a natural way to define pure for trees?
04:43:13 <jle`> in that case, pure 5 = [5]
04:43:15 <athan> hackrilege: You can put a function inside a list, can't you?>
04:43:19 <jle`> > (+) <$> [1,2,3] <*> [5]
04:43:21 <lambdabot>  [6,7,8]
04:43:24 <athan> :t [+1]
04:43:26 <lambdabot>     A section must be enclosed in parentheses thus: (+ 1)
04:43:30 <athan> >_>
04:43:40 <hackrilege> i can fmap a function yes.
04:43:41 <jle`> hackrilege: you can think of it as it using the same [5] for every element in the first list
04:43:42 <absence> :t (+1)
04:43:44 <lambdabot> Num a => a -> a
04:44:00 <athan> hackrilege: You can also store functions as elements in your parametric data structures
04:44:04 <jle`> if you want an analogous instance for Tree, then <*> with a single leaf would be using the same leaf for every nested part of the other tree
04:44:06 <athan> :t [(+1)]
04:44:07 <lambdabot> Num a => [a -> a]
04:44:16 <athan> this is what gives Applicative its magic
04:44:26 <athan> [(+1)] <*> [3]
04:44:34 <athan> > [(+1)] <*> [3]
04:44:36 <lambdabot>  [4]
04:44:42 <hackrilege> okok so applicative just fmaps and i dont need to worry about the shape of pure applied to a function, thats nice
04:44:52 <jle`> hackrilege: pure doesn't know what shape the list is.  pure gives a "default shape", and the Applicative instance works so that this default shape plays nicely with everything
04:44:57 <athan> ? no, you still need to obey the laws
04:45:11 <athan> like `f <$> pure x ~ pure (f x)`
04:45:15 <hackrilege> i did not shoot the deputy
04:45:28 <athan> fmapping over a pure'd thing, is just like pure-ing a normal application
04:45:47 <athan> hackrilege: Quit smoking weed, focus here
04:46:07 <hackrilege> im trying to patiently accept being told to obay the law again
04:46:15 <athan> .-.
04:46:20 <hackrilege> i promise
04:46:46 <athan> do you understand the expression I wrote up there?
04:46:55 <hackrilege> i get they are important. yes i understand your expression
04:46:56 <athan> about f <$> over pure?
04:47:18 <athan> hackrilege: then it should be obvious how you implement pure, if you already have fmap working
04:47:21 <hackrilege> your saying fmaping f over pure applied to x is equivilant to applying pure to (f x)
04:47:28 <athan> yep!
04:47:37 <hackrilege> its a law that must be satisfied, i must ensure this property holds
04:47:41 <hackrilege> ok
04:47:45 <athan> and pure only has its one input argument to create structure
04:47:56 <athan> so a singleton instance is really the only thing that makese sense
04:47:59 <hackrilege> so it had better work
04:48:05 <hackrilege> ok cool thanks
04:48:11 <athan> hackrilege: Yeah guess so
04:48:54 <hackrilege> right, so the thing with fix was totally what i need to be getting towards
04:49:08 <hackrilege> there was some other thing Free, ill scroll up and read that now it looked really promising
04:49:28 <hackrilege> and yes, i think its a hylomorphism not just an endomorphism
04:49:41 <athan> hylos are cool :)
04:49:42 <hackrilege> i generate the structure also
04:49:51 <athan> :t hylo -- is this in scope? :(
04:49:53 <lambdabot> Not in scope: ‘hylo’
04:49:55 <hackrilege> infact the tool im working on is a catamorphism
04:49:56 <athan> mooo
04:50:24 <athan> Muuuuu: https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html#t:Mu
04:50:30 <hackrilege> :t Control.Morphism.Hylo.hylo
04:50:33 <lambdabot> Not in scope: ‘Control.Morphism.Hylo.hylo’
04:50:46 <hackrilege> someone forgot to turn it on this morning
04:51:19 <hackrilege> Unfoldable!?
04:51:58 <athan> :)
04:52:08 <hackrilege> argh i just had a stroke, ill have to come back on later my ears need tissues in
04:52:17 <hackrilege> thanks for your help
04:52:17 <athan> hackrilege: Now implement it with unfoldMap
04:52:20 <athan> :)
04:52:54 * hackagebot ghc-simple 0.3 - Simplified interface to the GHC API.  https://hackage.haskell.org/package/ghc-simple-0.3 (AntonEkblad)
04:53:12 <hackrilege> whats the difference between Fix and Mu?
04:54:44 <athan> hackrilege: Mu is like waiting for the ability to deconstruct an `f a` into an `a`, in order to get an `a` out of it
04:54:52 <athan> but I honestly don't know
04:55:07 <hackrilege> newtype Mu f = Mu (forall a. (f a -> a) -> a)
04:55:24 <athan> oh, but it's also polymorphic for all a's
04:55:35 <athan> not at the top-level, so it only works for functions
04:55:52 <hackrilege> refix looks nice
04:56:19 <hackrilege> refix :: Foldable t => t -> Fix (Base t)
04:56:41 <hackrilege> type instance Base (Fix f) = f
04:56:48 <hackrilege> i have never seen type instance before
04:57:29 <athan> hackrilege: That's a type family
04:58:28 <hackrilege> :t cata
04:58:29 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
04:58:59 <athan> it just passes the continuation to `Mu`
04:59:04 <athan> (and runs Mu, also)
04:59:21 <hackrilege> :t cata fromJust
04:59:23 <lambdabot> Mu Maybe -> a
05:00:13 <hackrilege> look i found an fmap fold
05:00:15 <hackrilege> instance Functor f => Unfoldable (Mu f) where
05:00:15 <hackrilege>   embed m = Mu (\f -> f (fmap (fold f) m))
05:01:43 <jophish> how silly is it that I can't define fromInteger on a type without defining a host of other operations
05:02:18 <athan> Well, `foldMap` /= `fmap . fold`
05:02:24 <athan> I'm actually curious how that typechecks
05:02:33 <athan> the `f` should be `f :: f a -> a`, right?
05:02:37 <athan> :t fold
05:02:38 <lambdabot> (Foldable t, Monoid m) => t m -> m
05:02:56 <athan> how would `f a -> a ~ t m`?
05:03:09 <athan> er `(f a -> a) ~ t m`?
05:03:45 <hackrilege> im defining mapFold, not foldMap
05:03:53 <athan> hahaha
05:03:56 <hackrilege> ?
05:04:08 <frerich> jophish: Maybe you can live with just 'toEnum'?
05:05:48 <hackrilege> athan, what are you saying?
05:06:00 <hackrilege> :t embed
05:06:01 <lambdabot> Not in scope: ‘embed’
05:06:06 <athan> words
05:06:16 <hackrilege> :t (\f -> f (fmap (fold f) m))
05:06:17 <athan> :v
05:06:18 <lambdabot>     Couldn't match expected type ‘f a’ with actual type ‘Expr’
05:06:18 <lambdabot>     Relevant bindings include
05:06:18 <lambdabot>       f :: f b -> a -> b (bound at <interactive>:1:3)
05:06:30 <hackrilege> :t (\f m -> f (fmap (fold f) m))
05:06:32 <lambdabot> (Functor f, Foldable ((->) (f b)), Monoid b) => (f b -> a -> b) -> f a -> a -> b
05:07:07 <hackrilege> well anyway it typechecks, its in a library...
05:08:36 <jophish> frerich: the enum class is even worse!
05:08:49 <hackrilege> there is so much stuff in this Data-Functor-Foldable. im not sure i need the hylomorphism aspect just yet. im just trying to define the Monad. i have been told i cannot request that the contents of my Applicative are Monoids, which would give them the required methods. i instead ask, is an applicative of monads a monad?
05:09:41 <hackrilege> jophish, if you dont need the other methods of the class dont use that class, if no class exsits that has no superfluous methods, you should make a new class that encapsulates your desired functionality
05:10:30 <jle`> hackrilege: try looking in http://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Free.html.  if you have an Functor f, then `Free f` is a Monad, and you can use bind, return/pure, join, etc. on it
05:10:32 <hackrilege> is an applicative of monads a monad? join = fmap join
05:11:08 <jle`> the only thing "missing" is for you to define a `Free f a -> f a` for what f you need
05:11:11 <hackrilege> thanks jle'
05:11:42 <jle`> hackrilege: so, what you can do is write a function `(Applicative f, Monoid a) => Free f a -> f a`
05:12:06 <jle`> this is somewhat like to being able to use any `Applicative f` as a Monad, *as long as* the final result is a Monoid
05:12:42 <hackrilege> i can simply say; instance Monoid (f a)=> Monoid f where ?
05:12:43 <jle`> so, if you want to use your Applicative f as a Monad, you always use it as `Free f`, in do notation, mapM, etc., wherever you'd need a Monad
05:12:54 <jle`> no, that's not well-kinded
05:13:02 <jle`> i already told you what you needed, heh.
05:13:06 <hackrilege> ...
05:13:09 <hackrilege> you used free
05:13:14 <jle`> yes
05:13:14 <hackrilege> i just want it to be a monad
05:13:19 <jle`> yeah, Free gives you a Monad
05:13:28 <jle`> so if you have an Applicative f, then `Free f` is a Monad
05:13:29 <hackrilege> it also gives me free...
05:13:41 <jle`> and there you have it; a Monad constructed from `f`
05:13:49 <hackrilege> if f a is a monad then f is a monad
05:14:18 <jle`> what do you mean?
05:14:31 <hackrilege> ... if thats wrong im trying to say, if i can join the internal ellements i can fmap join for my definition of join
05:14:45 <hackrilege> :t fmap join
05:14:47 <lambdabot> (Monad m, Functor f) => f (m (m a)) -> f (m a)
05:14:55 <hackrilege> :t join
05:14:56 <lambdabot> Monad m => m (m a) -> m a
05:15:10 <jle`> here's how you can express this in Haskell...to be able to use any Applicative f as a Monad
05:15:14 <jle`> you use `Free f` instead
05:15:23 <hackrilege> im not trying to do that
05:15:23 <jle`> and the Monad instance is already defined for you
05:15:45 <hackrilege> im trying to say that functors of monads are monads
05:15:46 <jle`> and, at the end, you can write an (Applicative f, Monoid m) => Free f m -> f m
05:16:21 <jle`> and that's sort of like having a Monad instance for any Applicative f, as ong as the result is a Monoid
05:16:25 <jle`> which is what you wanted, right?
05:16:29 <hackrilege> no
05:16:37 <jle`> you wanted to have a Monad instance for any Applicative f, where the contained value is a Monoid
05:16:44 <hackrilege> i want an answer to the question "is it right to say that functors of monads are monads" ?
05:16:50 <hackrilege> not for every one
05:16:55 <hackrilege> just applicatives of monads
05:16:58 <jle`> define what you mean by a "functor of a monad"
05:17:10 <hackrilege> :t fmap join
05:17:12 <lambdabot> (Monad m, Functor f) => f (m (m a)) -> f (m a)
05:17:16 <hackrilege> like that
05:17:30 <jle`> do you mean that `(Functor f, Monad m) => f . m` is a Monad?
05:17:30 <hackrilege> the return type
05:17:39 <hackrilege> yes
05:17:54 <jle`> well, you can prove it, if you can write:
05:18:03 <hackrilege> join = fmap join
05:18:06 <jle`> return :: (Functor f, Monad m) => a -> f (m a)
05:18:42 <blueonyx> bennofs: ah the problem was cabal, i used cabal install -j to build my package, but only cabal build -j forwards the -j to ghc
05:18:43 <jle`> and bind :: (Functor f, Monad m) => f (m a) -> (a -> f (m b)) -> f (m b)
05:18:55 <jle`> if you can write those functions, and they interact together lawfully, then yes.
05:18:59 <hackrilege> you use the constructor of f with return for the internal monad
05:19:04 <lyxia> hackrilege: f (m (f (m a))) -> f (m a)
05:19:19 <hackrilege> whats that lyxia?
05:19:38 <jle`> not all Functors have constructors
05:19:48 <hackrilege> then how the hell do you use them!?
05:19:49 <dcoutts> blueonyx: that's actually a tricky problem, with there being potential parallelism at multiple levels, it's hard to coordinate on where to make use of it.
05:19:50 <jle`> in fact...most don't
05:19:58 <lyxia> hackrilege: your signature of join is incorrect. If you apply f . m twice you are applying f . m . f . m, not f . m . m.
05:20:13 <hackrilege> ah
05:20:16 <hackrilege> doh
05:21:18 <hackrilege> no but f -> m
05:21:25 <jle`> and remember, there's no way write a `Functor f => a -> f a` that works for all Functors
05:21:28 <hackrilege> rather f "turns into" m
05:21:31 <jle`> *that is polymorphic over all Functors
05:21:32 <hackrilege> thats what im trying to show
05:22:05 <hackrilege> i dont see how you can have a functor you cant construct...
05:22:32 <hackrilege> i mean, default constructors are generated by data declerations
05:22:53 <jle`> data BlackHole a = BlackHole BlackHole
05:23:05 <hackrilege> ok i promise not to do that
05:23:11 <opqdonut> hackrilege: IO
05:23:24 <opqdonut> ok well you can return into it but that's not quite constructing
05:23:26 <jle`> functors aren't tied to the idea of data constructors
05:23:37 <blueonyx> dcoutts: i get that, but the my problem is i need to install anyhow and i cant configure, since dependencies are missing (i'm using sandbox) so i was under the impression install automatically does configure,build,install as i think it will
05:23:38 <tobiasBora> Does an alternate top level (ghci like) solve this bug https://ghc.haskell.org/trac/ghc/ticket/3984 ?
05:23:41 <hackrilege> :t (\a->return a)::IO ()
05:23:43 <lambdabot>     Couldn't match expected type ‘a0 -> m0 a0’ with actual type ‘IO ()’
05:23:43 <lambdabot>     The lambda expression ‘\ a -> return a’ has one argument,
05:23:43 <lambdabot>     but its type ‘IO ()’ has none
05:23:55 <hackrilege> :t (\a->return a)::(a -> IO a)
05:23:56 <lambdabot> a -> IO a
05:24:07 <jle`> but that's not the point, anyways...the point is that there's no way to write a Functor f => a -> f a in a parametrically polymorphic way
05:24:17 <hackrilege> :t return
05:24:18 <lambdabot> Monad m => a -> m a
05:24:21 <jle`> remember, when you write foo :: Functor f => a -> f a, the *same implementation* is supposed to work for *all Functors*
05:24:23 <blueonyx> dcoutts: (i'm only installing the package i'm currently developing)
05:24:34 <jle`> but there's no way to implement `foo` so that the same `foo` will work for all Functors
05:24:39 <jle`> foo x = Just x doesn't work
05:24:40 <hackrilege> ok
05:24:47 <jle`> because then foo won't work for IO, or []
05:24:54 <tobiasBora> (the bug it that it's not possible to edit multiline edition in only one time (you have to recall each single line with <up>)
05:24:58 <jle`> this is what parametricity is
05:24:59 <dcoutts> blueonyx: indeed it will. If you wanted to build all deps with parallelism, and then build the local package with parallelism, you could do: cabal install --only-deps -j; cabal build -j;
05:25:01 <hackrilege> and there is no way to call the constructor in a generic way?
05:25:07 <hackrilege> i guess not... nayway
05:25:10 <jle`> there isn't
05:25:23 <jle`> if there was, you'd be able to construct a bunch of unconstructable data types
05:25:28 <jle`> like the one i just put up above
05:25:42 <hackrilege> so what was the problem? to create a monad i need return, but i cant define return for a functor, even if its contents are monads?
05:25:48 <dcoutts> blueonyx: one day I hope we'll sort this out by doing the parallel build of individual packages using Cabal rather than calling ghc --make -j
05:25:55 <jle`> yes, you can't define return in a parametrically polymorphic way
05:26:17 <dcoutts> blueonyx: so that we have one build manager that can see all the opportunities for parallelism
05:26:18 <blueonyx> dcoutts: yea will do now, but used cabal install -j when all dependencies are already installed
05:26:19 <jle`> you can define return for a specific Functor.  you can define return for Maybe, or define return for []
05:26:41 <jle`> so, you can say "*some* compositions of functors and monads are monads"
05:26:50 <jle`> and you can list the ones that you have shown: Maybe, [], etc.
05:26:54 <hackrilege> but i can for each instance, so lets say my Functor is a Graph a with a functor instance. now i can define a monad instance for Graphs of monads
05:27:24 <jle`> yes.  you can define a Monad instance for Graph . Monad
05:27:45 <jle`> yes, it's true that for *some* specific Functors f, f . m is a Monad
05:27:46 <hackrilege> that solves the polymorphism problem you present, we must work on specific instances. thats fine
05:27:52 <jle`> yes
05:28:00 <hackrilege> getting closer!
05:28:03 <jle`> but this is different than saying that compositions of functors and monads are monads
05:28:20 <jle`> this is like saying, "I want to prove that x * y = y * x"
05:28:26 <jle`> and then proving that 3*2 = 2*3
05:28:31 <jle`> 3*4 = 4*3
05:28:34 <jle`> etc.
05:28:51 <jle`> all you've done is proved that there is at least one combination of x and y such that x * y = y * x
05:28:55 <hackrilege> but we can provide a default if we make a new class called FriendlyFunctor or something that has no blackHoles?
05:29:07 <jle`> 3*2 = 6, and 2*3 = 6.  proven for 2 and 3!
05:29:18 <hackrilege> i get it
05:29:23 <jle`> hackrilege: this is an interesting question
05:29:34 <jle`> what sort of constraints does `f` has to satisfy so taht f . m is a Monad for all f?
05:29:36 <hackrilege> it would need a constructor
05:30:19 <hackrilege> and be foldable
05:30:43 <hackrilege> so join can just be fold for the outer level.
05:30:52 <hackrilege> and we need a monoid like a->a->a
05:30:55 <jle`> remember that whatever laws your container has has to be strong enough to prove the Monad laws for (f . m)
05:30:55 <hackrilege> for that fold
05:31:00 <jle`> s/container/class
05:31:15 <hackrilege> are the monoid laws strong enough?
05:31:17 <jle`> you're listing a couple of properties that you suspect are necessary/sufficient
05:31:19 <hackrilege> we inherit the rules?
05:31:29 <jle`> well, you get to choose the laws for your typeclass :)
05:31:34 <jle`> call it FriendlyFunctor
05:31:38 <jle`> you get to pick the laws for it
05:31:51 <hackrilege> im saying they might be available from Monoid
05:31:56 <jle`> but in the end you have to prove that (Monad m, FriendlyFunctor f) => f . m is a Monad
05:32:03 <opqdonut> :t traverse
05:32:05 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
05:32:17 <opqdonut> :t sequence
05:32:19 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
05:32:32 <jle`> you can use the monoid laws as inspiration for your typeclass if you want, yes
05:32:56 <hackrilege> no, i will inherit them by using Monoid as a constring on the lhs of a => in an instance decleration
05:33:03 <hackrilege> constaint
05:33:07 <hackrilege> ...
05:33:16 <hackrilege> constraint
05:33:49 <hackrilege> (Monad m, Functor f, Monoid (f.m)) => f . m is a Monad?
05:34:05 <jle`> you can't use constraints on what you "hold", here
05:34:28 <jle`> what i meant by this is, you have to show that you can write return :: (FriendlyFunctor f, Monad m) => a -> f (m a)
05:34:43 <hackrilege> the contents of a FriendlyFunctor must be Monoids, how do i write that?
05:34:46 <jle`> and join :: (FriendlyFunctor f, Monad m) => f (m (f (m a))) -> f (m a)
05:35:04 <jle`> if you have that constraint, it no longer fits in to this picture
05:35:18 <hackrilege> because they must also be monads
05:35:19 <hackrilege> ?
05:35:34 <jle`> no, because `return` and `join` will have different types now
05:35:45 <jle`> they'll have constraints on the `a` type variable
05:35:53 <hackrilege> but the monads are of monads of monads e.t.c. with a monoid at the fiexed point, so the whole thing is a monoid, it requires no type parameters
05:36:03 <jle`> if it doesn't have type parameters, it isn't a Monad
05:36:14 <hackrilege> no its a monoid
05:36:37 <hackrilege> but Monad $ Monad .... Monad  is a monad
05:37:02 <jle`> if you constrain what `f` can be applied to, the `return` and `join` can't be written
05:37:06 <jle`> right off of the bat
05:37:15 <jle`> you already make return and join impossible to implement
05:37:39 <quicksilver> just because you believe that constraint applies in your example, you don't have to bake it into the type or class
05:37:52 <quicksilver> you can perfectly well write the type or class for general `a`
05:37:56 <hackrilege> is what im sayng about non terminating recursive applications of the Monad type opperater being a monad but a monoid upon application to a moinoid correct?
05:38:12 <quicksilver> and just apply the Monoid constraint to functions which need it.
05:38:21 <quicksilver> hackrilege: no, because Monad isn't a type operator
05:38:28 <quicksilver> and cannot be applied recursively.
05:38:46 <hackrilege> how do i call (Monad (Monad ...))
05:38:52 <quicksilver> nonsense?
05:38:56 <jle`> Monad m => m (m (m ... ) .. ?
05:39:01 <hackrilege> ah yes sorry
05:39:24 <hackrilege> so Monad m => m $ m $ ...... m is a Monad?
05:39:28 <jle`> it's true that `m . m` is a Monad when m is a Monad
05:39:45 <hackrilege> and (Monad m,Monoid a) => m $ m $ ...... m a is a Monoid
05:40:07 <hackrilege> as (Monad m,Monoid a) => m a is a Monoid
05:40:11 <jle`> well
05:40:18 <jle`> Monad m => m a is already a monoid...
05:40:24 <hackrilege> and (Monoid m) => m.m is a monoid
05:40:33 <jle`> Monoid m => m.m is not well-kinded
05:40:45 <quicksilver> jle`: Monad m => m a is merely a semigroup, I think
05:40:55 <jle`> quicksilver: ah yeah you're right
05:41:19 <quicksilver> but we can agree "there is an obvious way to make (Monoid a, Monad m) => m a into  Monoid"
05:41:24 <hackrilege> i was trying to write out what you meant with "it's true that `m . m` is a Monad when m is a Monad "
05:41:34 <quicksilver> even though we do not (and will not) write that instance
05:41:41 <hackrilege> i will...
05:41:51 <ecthiender> hello, I'm very new to haskell (just started learning few days back). So I want to create a data type which has two fields. One is mandatory the other one is optional. What is the correct approach for this?
05:41:53 <hackrilege> only for specific instances though
05:41:59 <jle`> ecthiender: you can use Maybe :)
05:42:18 <jle`> hackrilege: actually, (Monad m, Monoid a) => m a is a Monoid for all MOnad m and Monoid a
05:42:22 <tdammers> ecthiender: you can't really have optional fields, but you can use Maybe to allow a value to be Nothing
05:42:24 <jle`> it's true for all instances
05:42:31 <jle`> *is a monoid
05:42:38 <hackrilege> data Mydata a b = Mydata a (Maybe b)? is that ok
05:43:09 <ecthiender> so something like this: data Square = Square Color (Maybe Piece) ? and then a Square can have only Color and Nothing or it can have a Color and a Piece?
05:43:27 <jle`> anyways, i ahve to head to bed :)  best of luck
05:43:43 <hodapp> ecthiender: that should work, I believe
05:43:45 <hackrilege> jle' so your coming round to the idea that i nested collection of monads of monads terminating in a monoid is a monoid?
05:43:56 <Hafydd> ecthiender: yes, although you might find it useful to note that you could use field labels: data Mydata a b = Mydata{ field1 :: a, field 2 :: Maybe b }.
05:44:01 <ecthiender> hodapp, a'ight!
05:44:08 <Hafydd> *field2
05:44:10 <ecthiender> ok. thanks
05:44:18 <hackrilege> okok good night jle' thanks for your help
05:44:28 <hodapp> yes... if you start adding in more and more fields it's generally good practice to use something like a record instead
05:44:53 <Hafydd> I wouldn't say "instead," because it's the same mechanism...
05:44:57 <hackrilege> data Square = Square {colour::Color, piece (Maybe Piece)}
05:45:01 <hackrilege> is that right?
05:45:12 <hackrilege> oops dropped a ::
05:45:23 <Hafydd> If you include the ::, yes.
05:45:33 <ecthiender> hodapp, right..
05:45:34 <ecthiender> ok
05:45:50 <hodapp> Hafydd: Same mechanism, but abstractions aren't about what mechanism is inside.
05:46:00 <Hafydd> hodapp: it's the same abstraction, too.
05:46:01 <quicksilver> hodapp: this isn't an abstraction though
05:46:13 <quicksilver> hodapp: because the syntax "Square Red Knight" works in both cases
05:46:17 <quicksilver> abstraction violated :P
05:46:53 <hodapp> field1/field2 are not however valid in both cases.
05:46:54 <hackrilege> then we can change the ellements like f :: (Square -> Square) ; f s = s{color = red}
05:47:03 <hackrilege> is that right?
05:47:06 <jophish> hackrilege: That's not always an option with Num or Enum which are pervasive in everyone elses code. It's a huge barrier to using a package if one has to turn on rebindablesyntax
05:47:22 <quicksilver> well you said 'colour' not 'colour' but yes, that's the syntax
05:47:25 <quicksilver> ehe
05:47:30 <quicksilver> 'colour' not 'color' :)
05:47:33 <hackrilege> yeh
05:47:46 * frerich imagined quicksilver writing that same word with two different pronounciations
05:48:07 <frerich> 'le colour'!
05:48:11 <ecthiender> *pronunciations
05:48:14 <ecthiender> frerich, ^
05:48:16 <hackrilege> hey quicksilver, do you know if a nested recursive collection of monoids contained within one another, applied to a monoid is always natuarlly a monoid?
05:48:20 <bollu> ecthiender: hey :)
05:48:32 <ecthiender> although pronounce! strange language eh?
05:48:33 <hackrilege> monads contained within each other*
05:48:33 <frerich> ecthiender: prounounciatiouns
05:48:40 <ecthiender> bollu, hey!! what's up? :)
05:48:42 <quicksilver> hackrilege: Monad m => m (m (m (m (m (m a) ) ) ) ) ) will be a Monoid if a is, yes
05:48:53 <bollu> ecthiender: life as usual :) Exams from tomorrow :P
05:48:54 <hackrilege> thanks!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
05:48:56 <quicksilver> hackrilege: but that nesting itself is bizarre
05:49:01 <hodapp> owwww not so many !s
05:49:02 <quicksilver> hackrilege: why not just use "m a"
05:49:12 <quicksilver> the 'whole point' of monads is that m (m a) can be reduced to m a
05:49:22 <ecthiender> bollu, heh :D all the best :)
05:49:31 <hackrilege> ok so im really not saying anything stronger than a monad of a monoid is a monoid
05:49:32 <bollu> quicksilver: that's because Monad m a will be a Monoid if a is a monoid, right?
05:49:40 <bollu> quicksilver: so recursively the entire stack will be a monoid?
05:49:42 <Hafydd> Maybe (Maybe a) can be useful where Maybe a isn't.
05:49:43 <quicksilver> yes
05:49:47 <quicksilver> Hafydd: sure
05:49:56 <bollu> ecthiender: thanks :)
05:49:59 <quicksilver> Hafydd: but I'd like to understand hackrilege's reason because I suspect he doesn't have one.
05:50:04 <hackrilege> lol
05:50:06 <hackrilege> i do 2!
05:50:16 <bollu> Hafydd: yeah, but you'd never need an *arbitrary* layer of monad nesting?
05:50:34 <hackrilege> i think its cos i want to join the inner ellements
05:50:44 <hackrilege> not the outer list, which i still want to be only a functor
05:50:52 <hackrilege> "list"
05:50:58 <hackrilege> i mean functor
05:51:06 <bollu> hackrilege: but.. how are you getting that type anyway? like, the m (m … (m a))?
05:51:19 <Hafydd> bollu: probably not.
05:51:22 <hackrilege> for a proof
05:51:35 <quicksilver> it's like *either* you do data ListPrim f a = Nil | Cons a (f a) and then you take Fix ListPrim - and you can use nested ListPrims if you want, or you just use []
05:51:37 <hackrilege> it neednt be so deep, i think you ust need to prove the base case and the recursive step
05:51:38 <bollu> hackrilege: the proof is just using recursive definition
05:51:41 <quicksilver> but you never use Fix []
05:51:53 <hackrilege> as i wasworking with f (m a) i wanted to use join on the inner list
05:51:57 <quicksilver> hackrilege: ok, so don't reduce the outer once
05:52:03 <quicksilver> but still reduce all the inner ones
05:52:07 <quicksilver> so you just have m (m a)
05:52:10 <bollu> hackrilege: that looks like Traversable?
05:52:16 <quicksilver> two layers not n layers
05:52:23 <bollu> :t traverse
05:52:24 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
05:52:33 <bollu> ^ do you actually need the full power of the monad?
05:52:40 <hackrilege> i shall use Fix momentarily. so i guess (Monad m,Monoid a) => (Fix m) a is a Monoid?
05:53:10 <bollu>  hackrilege: why do you want a Monad? Functor is all you need for Fix (I'm just curious)
05:53:15 <quicksilver> no
05:53:20 <quicksilver> you don't Fix monads
05:53:24 <quicksilver> you Fix the non-recursive thing
05:53:40 <quicksilver> monads don't have the spare type parameter you need to fix.
05:53:52 <bollu> :t Fix
05:53:53 <lambdabot>     Not in scope: data constructor ‘Fix’
05:53:54 <lambdabot>     Perhaps you meant one of these:
05:53:54 <lambdabot>       variable ‘iix’ (imported from Control.Lens),
05:53:54 <hackrilege> n layers comes implicity. i want infinityly nested lists of lists (or graphs of graphs, e.t.c. functors of functors to change into monads of monads if 'a' is a Monoid)
05:53:56 <bollu> :t fix
05:53:58 <lambdabot> (a -> a) -> a
05:54:01 <bollu> argh
05:54:18 <quicksilver> hackrilege: sure but infinite nesting of *data* isn't infinite nesting of *types*
05:54:28 <quicksilver> infinite nesting of *data* just requires recursion
05:54:35 <quicksilver> that's the whole point of recursive data types
05:54:41 <quicksilver> you don't need any nesting at the type level.
05:54:43 <hackrilege> newtype Fix f = Fix (f (Fix f))
05:54:48 <bollu> quicksilver: what about Nat?
05:55:03 <quicksilver> solving a different problem.
05:55:20 <quicksilver> that's not for deeply nested data - it's for type-level computaiton.
05:55:24 <hackrilege> ok so Trees are recusivly defined. but i genuinly have trees of trees at the leaves
05:55:44 <bollu> oh, I thought you were saying that it is pointless. nvm me
05:56:16 <quicksilver> you can make a simple recursive type that includes tree of trees if you wish
05:56:18 <hackrilege> so yeh, its a monad, and so trivially the Fix thing is a monad.
05:56:26 <hackrilege> and thats what i wanted to show so im happy
05:56:37 <quicksilver> that isn't hte Fix thing.
05:56:37 <bollu> how come I can't import Data.Fix in ghci?
05:56:50 <quicksilver> the Fix thing is when you have an extra parameter.
05:56:54 <hackrilege> module Data.Functor.Foldable
05:57:02 <hackrilege> bollu^
05:57:06 <hackrilege> https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/src/Data-Functor-Foldable.html#Mu
05:57:34 <quicksilver> data SuperTree a = Leaf | Tree (SuperTree a) | STree (SuperTree (SuperTree a))
05:57:35 <hackrilege> it shouldnt be pointing at Mu sorry...
05:57:44 <hackrilege> NO!
05:57:48 <hackrilege> tree as normal
05:57:48 <quicksilver> ^^ simple data type which permits trees-of-trees
05:58:04 <quicksilver> my point isyou don't need to nest your types to have 'trees of trees at the leaves'
05:58:06 <bollu> I found it, nvm. data-fix package
05:58:07 <hackrilege> fun :: Tree (Tree (Tree... a))
05:58:18 <nicocbg> haskell noob question  : if I do shake —demo, I get a small demo project which contains a Build.hs file
05:58:20 <quicksilver> hackrilege: I know. I'm saying you do not need that type.
05:58:25 <bollu> hackrilege: this AGAIN begs the question - why do you want *arbitrary* levels of nesting?
05:58:33 <quicksilver> you can write a type which is *not* nested at the type level
05:58:43 <quicksilver> and still has the nesting you want at the data level.
05:58:46 <hackrilege> ill link the paper when its published... but id prefer to publish it myself...
05:59:14 <nicocbg> now if I do cabal init and put the default choice, the file looks OK but `cabal build` will say :[1 of 1] Compiling Main             ( Build.hs, dist/build/Main.o ) ar: dist/build/Build.o: No such file or directory
05:59:17 <hackrilege> its just like a list of lists!
05:59:36 <hackrilege> list could be defined recurslvly but you dont cry about [[[[[[[[a]]]]]]]]]]
05:59:52 <hodapp> actually, if I saw that, I probably *would* cry about it
05:59:52 <quicksilver> but if you need infinitely nested lists (or abitrartily nested lists)
05:59:52 <hackrilege> graph of graphs, its fine
05:59:56 <quicksilver> you define a different type
06:00:10 <quicksilver> Tree is exactlyt he type you get if you want 'arbitrarily nested lists'
06:00:18 <quicksilver> and you can do arbitrarily nested trees the same way
06:00:19 <nicocbg> do I have to have a Main even for libraries ?
06:00:23 <quicksilver> with no nesting at the type level.
06:00:25 <hackrilege> ok, sijnce i do infact need to use fix, ill define a new type
06:00:36 <bollu> quicksilver: what? not really?
06:00:39 <hackrilege> its not a finite nesting, it never reaches the monoid
06:00:43 <bollu> quicksilver: a tree is much stronger than that..?
06:00:48 <dcoutts> nicocbg: you probably wanted it to be an exe not a lib. But if you make it a lib, the module names and file names need to match. Your Build.hs file actually is a Main module, since there's no module decl in the file.
06:01:05 <blueonyx> is atan arcus tangens?
06:01:26 <hackrilege> nicocbg. the .cabal file specifies if cabal build should make libraries or exe's and sometimes both
06:01:28 <quicksilver> bollu: data NList = a | L [NList a]
06:01:28 <bollu> blueonyx: atan is tan-1
06:01:31 <blueonyx> nvm, messed with degrees 
06:01:38 <quicksilver> bollu: is "arbitrarily nested lists"
06:01:42 <bollu> quicksilver: right, so it's a tree such that all of it's left nodes are leaves or whatever
06:01:43 <quicksilver> bollu: (like you get in LISP, say)
06:01:48 <bollu> quicksilver: so it's not *just* a tree
06:01:54 <quicksilver> bollu: it's one kind of tree
06:01:58 <bollu> hm. I guess
06:02:03 <quicksilver> bollu: a rose tree with values at leaves only
06:02:05 <nicocbg> dcoutts :  indeed.. thank you ! 
06:02:09 <quicksilver> bollu: but there are other formulations.
06:02:23 <quicksilver> bollu: point being, recursive data is just adding another constructor to the type
06:02:26 <bollu> quicksilver: haven't read rose trees :)
06:02:28 <quicksilver> bollu: not nesting the type.
06:02:42 <hackrilege> data myTree = myTree a [myTree a]
06:02:42 <quicksilver> bollu: a rose tree is a tere with a list of nodes at each level not just 2 (or 3 or whatever)
06:02:50 <bollu> quicksilver: ahh
06:03:01 <hodapp> blueonyx: atan = arctan = arctangent = tan^-1
06:03:29 <hodapp> though it's not really properly called tan^-1 since it's not properly an inverse function, as tan is not one-to-one
06:03:46 <hackrilege> :t (!!)
06:03:48 <lambdabot> [a] -> Int -> a
06:03:59 <hackrilege> :t (!!..!!)
06:04:01 <lambdabot> Not in scope: ‘!!..!!’
06:04:02 <bollu> quicksilver: soo data RoseTree = a | [RoseTree a] ?
06:04:15 <hackrilege> :t ((!!).(!!))
06:04:16 <lambdabot>     Couldn't match type ‘Int -> a1’ with ‘[a]’
06:04:16 <lambdabot>     Expected type: [a1] -> [a]
06:04:16 <lambdabot>       Actual type: [a1] -> Int -> a1
06:04:21 <hackrilege> :t ((!! .).(!!))
06:04:22 <lambdabot> parse error on input ‘.’
06:04:25 <hackrilege> sorry...
06:04:49 <KaneTW> what are you trying to do?
06:04:56 <hackrilege> point is, if i access the ellements of my tree, i will always be able to use the same accessor on those elements
06:04:59 <bollu> quicksilver: data RoseTree = a | [RoseTree a] ?
06:05:04 <hackrilege> this is not the case for a normal tree
06:05:26 <hackrilege> its a different type of infinite nesting
06:05:38 <hackrilege> that the recursive datatype decleration
06:06:20 <hackrilege> as if the directions of recursion were perpendicular, but thats me confusing things
06:08:22 <hackrilege> @pf (\f a i -> (a `f` i) `f` i )
06:08:23 <lambdabot> Maybe you meant: pl bf
06:08:27 <hackrilege> @pl (\f a i -> (a `f` i) `f` i )
06:08:27 <lambdabot> flip flip id . (ap .) . ((.) =<< (.))
06:08:45 <hackrilege> yuk
06:09:31 <hackrilege> did everyone go for lunch or is my tree of trees caused deep reflection?
06:10:51 <mnoonan> I think you need to actually state what is is that you're trying to do, because what you're saying doesn't make any precise sense yet.
06:11:20 <hackrilege> im trying to write Instance (Monad m) => Monad (Fix m)
06:11:23 <hackrilege> i think
06:11:33 <hackrilege> but i dont know the syntax to use Fix propperly
06:11:52 <tobiasBora> A little question about indentation :
06:11:54 <merijn> hackrilege: And why are you trying to do that?
06:12:00 <mnoonan> So that already doesn't make sense, right? Fix has kind (* -> *) -> *, and Monad needs a * -> *
06:12:03 <hackrilege> *facepalm*
06:12:08 <hackrilege> i dont even know anymore
06:12:10 <tobiasBora> what is the usual way to indent "case x of a -> b; c -> d" ?
06:12:34 <merijn> tobiasBora: I indent one indent to the right of case
06:12:43 <hackrilege> mnoonan Fix m kind *->* ?
06:13:00 <hackrilege> no
06:13:02 <hackrilege> ok
06:13:16 <jeltsch> tobiasBora: I indent as follows:
06:13:35 <jeltsch> case e of
06:13:37 <hackrilege> so maybe i can do  (Monad m) => Monoid (Fix m)
06:13:38 <jeltsch>     p1 -> e1
06:13:40 <jeltsch>     p2 -> e2
06:13:42 <jeltsch>     …
06:13:44 <hackrilege> but im not sure thats what i want
06:14:07 <hackrilege> that indentation looks ok
06:14:29 <jeltsch> Typically, I indent relative to the case:
06:14:31 <jeltsch> f x y = case (x, y) of
06:14:33 <jeltsch>             p1 -> e1
06:14:35 <jeltsch> etc.
06:14:36 <tobiasBora> merijn: You mean the same thing as jeltsch ?
06:14:55 <hackrilege> looks like it yes
06:15:06 <tobiasBora> jeltsch: Ok... And do you know why emacs mode indentation doesn't indend case at all ?
06:15:08 <tobiasBora> like :
06:15:12 <tobiasBora> case (x,y) of
06:15:15 <tobiasBora> 1 -> 2
06:15:18 <hackrilege> its wrong
06:15:27 <jeltsch> tobiasBora: Because the emacs Haskell mode sucks? :-D 
06:15:38 <hackrilege> yeh, its not handeling case properly there
06:15:57 <hackrilege> just indent it manually like a warrior
06:16:02 <jeltsch> tobiasBora: I once tried this mode out and quickly abandoned it, because the code formatting logic of its designers didn’t match mine.
06:16:04 <tobiasBora> hackrilege: jeltsch : So do you use any mode or indent just with hands and spaces ?
06:16:15 <merijn> tobiasBora: Basically
06:16:17 <hackrilege> i do it all by hand in wordpad on windows
06:16:29 <hackrilege> emacs breaks my mind
06:16:41 <hackrilege> so does vi or any of thse things. im a windows kid
06:16:51 <tobiasBora> Too bad...
06:16:55 <jeltsch> tobiasBora: I use Vim with Haskell syntax highlighting. I indend “semi-manually”, meaning that I can use the Tab key to insert spaces up to the next tab position.
06:17:22 <kurushii> geppettodivacin are you available at the moment as i could use your help with some animation
06:17:45 <jeltsch> And I can use block-oriented editing, which is sometimes useful. I mean things like marking a rectangular block and replacing every line of it with a certain character sequence (->, =, whatever).
06:17:52 <hackrilege> i love kurushii. what animation package are you using out of interest?
06:18:17 <kurushii> it is a simple svg animation package a friend sent me 
06:18:27 <kurushii> i can link it if you wish to see it
06:18:33 <hackrilege> that sounds good!
06:18:44 <mnoonan> tobiasBora: which haskell mode / indentation mode are you using? I get cases indented fine here.
06:18:45 <hackrilege> im looking for a new package
06:18:51 <hackrilege> is it not on hackage?
06:18:55 <kurushii> http://pastebin.com/FXAbRCAa
06:19:10 <tobiasBora> jeltsch: Ok ! I try to use some rectangular sometimes, but I'm not sure I'm doing it in the right way
06:19:16 <kurushii> no it's something either he developed or used some time ago
06:19:47 <hackrilege> there are no imports!? how is it doing any animation
06:19:49 <hackrilege> ?
06:19:57 <kurushii> and i wanted to learn haskell so he gave me this library to make haskell more interesting
06:20:21 <hackrilege> ah ok. so what was your question? how to get it to display to the screen?
06:20:26 <tobiasBora> mnoonan: I used haskell-indent-mode before, but I do not like some things (it's long to type 5 times <tab> to go in the right position), so I'm trying haskell-indentation-mode, but the case bloc doesn't work
06:20:35 <hackrilege> it might not be the easyest way to do it to use that code...
06:20:43 <kurushii> no i am trying to implement some spinning squares 
06:20:48 <hackrilege> ah ok
06:21:05 <kurushii> but i think the issue is haskell's syntax i just can't get to grips with it
06:21:22 <hackrilege> you want to use the method spinner no?
06:21:32 <kurushii> yes
06:21:42 <kurushii> but i tried writing up the code
06:21:49 <kurushii> getting some errors
06:22:01 <kurushii> i can post what i wrote if you wish to look at it
06:22:08 <hackrilege> yes
06:22:12 <hackrilege> please post the error
06:22:37 <hackrilege> still not sure about animations returning strings but ok
06:22:41 <kurushii> http://pastebin.com/wKq94skS
06:22:49 <kurushii> that's the code i have written
06:23:10 <kurushii> the error i get is a parse error on input ]
06:23:26 <hackrilege> Paint (always blue) (combine
06:23:26 <hackrilege>                 [translate
06:23:30 <hackrilege> what is that!!!???
06:23:37 <mnoonan> tobiasBora: huh, I'm using haskell-indentation-mode too and it works here (emacs 24).  Maybe it is a new version of haskell-indentation-mode?  I think I followed these instructions: https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md#haskell-mode
06:24:06 <kurushii> well i'm trying to paint all the rectangles blue
06:24:23 <hackrilege> kurushii!!! noo what is this, translate is being applied to like a million arguments!
06:24:37 <kurushii> oh sorry
06:24:40 <hackrilege> those newlines are not doing much
06:24:54 <hackrilege> it looks like your trying to compose these opperations
06:25:37 <kurushii> i'm using translate to get the rectangle to replicate from it's current position 
06:25:38 <hackrilege> maybe you should try to use . or $
06:25:48 <hackrilege> a $ where each of those newlines is might be ok
06:25:50 <kurushii> yh i was looking into that
06:25:51 <tobiasBora> mnoonan: Are you using hi2 ?
06:25:56 <kurushii> but i don't know how to use it
06:26:02 <hackrilege> ok its something like this
06:26:16 <hackrilege> > 1+ (2 + 3)
06:26:18 <lambdabot>  6
06:26:31 <mnoonan> tobiasBora: no
06:26:37 <hackrilege> >((1+).(2+)) 3
06:26:41 <hackrilege> > ((1+).(2+)) 3
06:26:44 <lambdabot>  6
06:26:49 <hackrilege> does that make sense?
06:27:00 <hackrilege> :t (.)
06:27:01 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:27:04 <kurushii> sorry i am completely lost 
06:27:18 <hackrilege> im showing you (.)
06:27:21 <kurushii> complete beginner to haskell
06:27:23 <hackrilege> called "dot"
06:27:28 <hackrilege> it composes functions
06:27:31 <hackrilege> :t (.)
06:27:32 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:27:35 <bollu> kurushii: how much of a mathematics background do you have?
06:27:58 <kurushii> college (uk) level
06:28:13 <kurushii> not university but college
06:28:20 <hackrilege> its like if you have a function which takes one argument, like e.g. sum. you cant write sum map (+2) [1]
06:28:22 <hackrilege> watch
06:28:28 <hackrilege> > sum map (+2) [1]
06:28:30 <lambdabot>      Couldn't match type ‘[b0]’ with ‘[t0] -> t’
06:28:30 <lambdabot>      Expected type: (a0 -> b0) -> (a1 -> a1) -> [t0] -> t
06:28:30 <lambdabot>        Actual type: (a0 -> b0) -> [a0] -> [b0]
06:28:37 <hackrilege> > sum  $ map (+2) [1]
06:28:38 <lambdabot>  3
06:28:50 <bollu> hackrilege: you should probably check if they're comfortable with "map" before showing that..?
06:28:56 <hackrilege> the dollar sign puts parenthesis around everything to its right hand side
06:29:09 <hackrilege> oh my god. i didnt think of that
06:29:18 <hackrilege> map is like breakfast
06:29:19 <bernalex> what's a sensical datatype for bytes? bytestring? I basically want [Instruction] -> Binary translation. so f (Mul:is) = 0110 1000 + f is, and so on.
06:29:26 <kurushii> hold on lol 
06:29:36 <hackrilege> > sum  $ map (+2) [1,2,3]
06:29:37 <kurushii> i'm still trying to get the $ sign
06:29:38 <lambdabot>  12
06:29:44 <hackrilege> :t ($)
06:29:45 <lambdabot> (a -> b) -> a -> b
06:30:01 <kurushii> ok so you said, the dollar sign puts parenthesis around everything to its right hand side
06:30:06 <bernalex> kurushii: f $ x = f x
06:30:15 <hackrilege> hmm not so informative, thats saying, dollar sign takes a function from a to be and turs into a function from a to b
06:30:22 <hackrilege> thanks bernalex
06:30:38 <bernalex> kurushii: it's just a neat way to get function application with nice fixity so that we can omit parens.
06:30:46 <bernalex> f x (g y) == f x $ g y
06:30:47 <kurushii> oh ok 
06:30:48 <hackrilege> a $ b $ c $ d = a (b (c d))
06:31:03 <bernalex> it's best used sparingly.
06:31:07 <kurushii> i can understand what you're saying
06:31:15 <bernalex> it's just id monomorphic to (a->b) really.
06:31:27 <kurushii> but to be honest i don't have the faintest idea on how to use it in my code
06:31:34 <hackrilege> yes, brackets are good. but when you are composing lots of functions together such as in your paste, i think ($) is a good way to do it
06:31:47 <hackrilege> well you see what you were trying to do with the newlines?
06:31:53 <hackrilege> thats what the $ does
06:31:57 <kurushii> sorry newlines?
06:32:09 <bernalex> kurushii: you don't ever need to do it. it's just if you have something like (f . g . h) x, someone will prefer writing f . g . h $ x. same difference.
06:32:13 <bernalex> newlines
06:32:15 <bernalex> are
06:32:17 <bernalex> like
06:32:17 <hackrilege> yes, you give each transformation a new line in the hope that haskell will apply them in sequence
06:32:19 <bernalex> this
06:32:54 <hackrilege> you have lots of functions of the form Animation -> Animation
06:32:59 <kurushii> yes
06:33:42 <hackrilege> you need to take the Animation that is returned and supply it to the next function
06:34:14 <hackrilege> like if i had 2 functions that took one number and returned one number, i could join them in a sequence like;
06:34:32 <hackrilege> > (+1) $ (+2) $ (+3) 123
06:34:33 <lambdabot>  129
06:34:49 <hackrilege> > +1 $ +2 $ +3123
06:34:50 <lambdabot>  <hint>:1:1: parse error on input ‘+’
06:34:53 <bernalex> what datatype would be useful to add bytes? I want to be able to do f xs y = xs <> y, where ys is a sequence of bytes and y is a byte. e.g. 0001100010001000 <> 01011000
06:34:54 <hackrilege> oh dear...
06:35:20 <bollu> :t +1
06:35:22 <lambdabot> parse error on input ‘+’
06:35:25 <kurushii> yes got it it basically acts like a glue and sticks the outputs of each function together?
06:35:29 <bollu> :t (+) 1
06:35:31 <lambdabot> Num a => a -> a
06:35:41 <hackrilege> it breaks up the think like parenthesis
06:35:51 <hackrilege> > putStrLn $ show 3
06:35:54 <lambdabot>  <IO ()>
06:35:59 <hackrilege> ...
06:36:09 <bollu> lol
06:36:22 <hackrilege> > putStrLn  show 3
06:36:25 <lambdabot>      Couldn't match expected type ‘Integer -> t’
06:36:25 <lambdabot>                  with actual type ‘IO ()’
06:36:25 <lambdabot>      The function ‘putStrLn’ is applied to two arguments,
06:36:28 <tobiasBora> mnoonan: And what do you call correct ? For example if you just hit in a new buffer : "fact n<RET>case n of<RET>0 -> 1<RET>_ -> n * fact (n-1)", what is the output ?
06:36:53 <hackrilege> here the compiler is complaining that we have applied putStrLn to too many arguments, it needs some brackets, or a dollar sign
06:37:06 <kurushii> I probably can use the $ symbol in very basic applications but completely lost on how to use it in this big of function
06:37:30 <hackrilege> spin =
06:37:31 <hackrilege>     translate (always (300, 200))
06:37:31 <hackrilege>         (rotate (spinner 5)
06:37:35 <bernalex> kurushii: give me an example and I will show you.
06:37:50 <bernalex> spin = translate $ always (300, 200 $ rotate (spinner 5)
06:37:54 <hackrilege> bernalex http://pastebin.com/wKq94skS
06:37:54 <hackrilege>     translate (always (300, 200))
06:37:55 <hackrilege>         (rotate (spinner 5)
06:38:12 <bernalex> note however that I would likely write it exactly how it is written. I think using $ there would be bad form.
06:38:40 <kurushii> ok i'll try this out and look at the example you have given me
06:39:09 <kurushii> thank you for the help but i'll probably be back since this has been causing me some difficulty since the morning
06:39:12 <hackrilege> yes, and removing those newlines should remove that other bug you had
06:39:24 <hackrilege> we will still be here dont worry!
06:39:29 <kurushii> thank you
06:40:20 <hackrilege> and yes, when you see a )))))) at the end of a line, try using $
06:40:46 <hackrilege> a $ b $ c $ d = a (b (c d))
06:41:18 <kurushii> ok will do
06:46:31 <bernalex> merijn: ping?
06:47:29 <kurushii> hackrilege i've tried doing what you said obviously completely wrong lol but i had a go getting errors but would you mind having a look at it and let me know what i did wrong?
06:47:34 <merijn> bernalex: pong
06:47:36 <kurushii> will paste link
06:47:39 <hackrilege> kk
06:48:10 <bernalex> merijn: you seem like someone who'll know this. I want to <> bytes. what datatype should I be using? like 0001100010000101 <> 10010110
06:48:45 <opqdonut> <> as in concat?
06:49:04 <merijn> bernalex: ByteString/Builder?
06:49:05 <bernalex> no. 
06:49:16 <bernalex> merijn: that's what I assumed. do you know what I'm looking for in there?
06:49:17 <merijn> Can you give more concat?
06:49:23 <merijn> *context
06:49:23 <opqdonut> there's Data.BitVector
06:49:25 <kurushii> http://pastebin.com/EhdWXSGi
06:49:30 <merijn> Do you want to output bytes?
06:50:03 <kurushii> i pasted all my code there but it's the spin function i'm concerned about
06:50:11 <bernalex> merijn: assemble is (Push n:js) = is <> 0001000 <> assemble js; assemble is (Mul:is) = is <> 01101000 <> assemble js, etc.
06:50:15 <blueonyx> why does the cabal install in 'cabal build -j && cabal install -j' build again :/
06:50:37 <bernalex> merijn: simply 0001100010000101 <> 10010110 = 000110001000010110010110
06:50:52 <merijn> bernalex: Right and we're talking Word8/sequences of Word8 here?
06:51:17 <merijn> binary/cereal might be what you want for that?
06:51:43 <merijn> with putWord8
06:51:45 <bernalex> merijn: is/js are [Instruction]s, Instruction = Push | Add | Mul | etc. -- Push = 00010000. etc.
06:51:53 <merijn> Yeah, I figured
06:52:52 <kurushii> hackrilege i also have the api but as a webarchive
06:53:00 <mnoonan> tobiasBora: I get the 0 -> 1 line indented one space (in your case), or two if I do "fact n = case n of<RET>" etc
06:53:09 <bernalex> merijn: I'll look at putWord8. I wish I could use <> though, as I deem that more elegant.
06:53:24 <merijn> bernalex: Depending how much performance matters I'd just write "Instruction -> Word8" and use Data.Binary.Put
06:53:25 <bernalex> then again levels this low are rarely that elegant.
06:53:31 <bernalex> merijn: performance doesn't matter *at all*.
06:53:56 <bernalex> merijn: I'm teaching myself compiler construction. :]
06:54:00 <merijn> bernalex: Right. binary also has hacky do-notation support
06:54:37 <bernalex> merijn: is Word8 just a byte?
06:54:46 <merijn> So you'd write "assemble is (Push n:js) = do { is; putWord8 00010000; assemble js }"
06:55:07 <bernalex> merijn: hm what's :t assemble then?
06:55:08 <merijn> bernalex: Internally? No, in output used by binary, yes
06:55:32 <merijn> bernalex: "[Instruction] -> Put" and you have "runPut :: Put -> ByteString"
06:55:56 <tobiasBora> mnoonan: When you say one space you mean align with case ? If yes shouldn't be aligned with the 'n' in 'case n' ?
06:56:33 <bernalex> merijn: interesting. btw is there something in base for Dec->Bin? :p
06:56:41 <bernalex> I need dec2bin the n in that assemble equation lol
06:56:49 <mnoonan> I think it just needs to be indented more than the previous line to get parsed as a continuation of the case statement
06:56:56 <merijn> Representation? I think there's a binary literal extension
06:56:59 <mnoonan> (it compiles fine)
06:57:01 <merijn> > 0b001
06:57:03 <lambdabot>  Not in scope: ‘b001’
06:57:25 <bernalex> merijn: note in your example for assemble, you discard the n
06:57:45 <bernalex> merijn: I want e.g. push 2 to become 0001 0000  0000 0010
06:57:48 <merijn> bernalex: So did your original example :)
06:57:56 <bernalex> merijn: no, it merely didn't dec2bin it
06:58:13 <bernalex> merijn: oh, I did!
06:58:31 <bernalex> merijn: that was a mistake. it should have been is <> the push code <> dec2bin n <> assemble js
06:58:44 <merijn> dec2bin doesn't make a lot of sense to me?
06:59:03 <bernalex> merijn: I'll have a Push 5 instruction
06:59:10 <merijn> Unless you're converting a number to a string of 0s and 1s?
06:59:18 <merijn> Which is silly
06:59:29 <bernalex> merijn: which should be turned into 0001 0000 (push) 0000 0101 (5).
06:59:32 <tobiasBora> mnoonan: Yes, but if I understand well it's not well aligned right ? Here is what I get : http://paste.ubuntu.com/13502847/
06:59:52 <bernalex> merijn: lol well IDK what I'm doing. I read chapter 1 and just wanted to do something fun at the end of it. :]
06:59:53 <merijn> bernalex: Right, but "putWord8 5" just output a single byte at value 5
07:00:15 <bernalex> sorry, what does that mean?
07:00:21 <bernalex> "byte at value 5"?
07:00:29 <merijn> bernalex: So you just need to turn "Push 5" into "putWord8 8 >> putWord8 5"
07:00:31 <mnoonan> tobiasBora: oh, I see. I missed the = in your first example. Yeah, I see the same thing here.
07:00:41 <bernalex> mnoonan: why pushWord8 8?
07:00:49 <bernalex> push = 0001 0000 = 16
07:00:56 <mnoonan> tobiasBora: I usually put the case on the same line as the "fact n =", so I hadn't noticed that before
07:01:02 <merijn> bernalex: Oh, I counted wrong then :p
07:01:11 <merijn> bernalex: "putWord8 16 >> putWord8 5", then
07:01:14 <bernalex> merijn: so I should be using 16/96/104 for push/add/mul, not the binary?
07:01:35 <bernalex> interesting... and sorry for being such a noob! lol
07:01:38 <merijn> bernalex: Well, like I said if you enable -XBinaryLiterals you can write "0b00010000"
07:01:51 <tobiasBora> mnoonan: Hum so you agree this mode is buggy ?
07:02:00 <bernalex> unless it is more efficient/useful somehow, that's not necessary, I guess. :]
07:02:01 <merijn> bernalex: Representation and value are orthogonal concepts
07:02:11 <bernalex> :t Put
07:02:13 <lambdabot>     Not in scope: data constructor ‘Put’
07:02:13 <lambdabot>     Perhaps you meant one of these:
07:02:13 <lambdabot>       variable ‘out’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
07:02:15 <bernalex> uhm
07:02:28 <bernalex> @hoogle Put
07:02:30 <lambdabot> Test.HUnit.Text PutText :: (String -> Bool -> st -> IO st) -> st -> PutText st
07:02:31 <lambdabot> Test.HUnit.Text data PutText st
07:02:31 <lambdabot> Network.HTTP.Base PUT :: RequestMethod
07:02:33 <merijn> bernalex: Output the numeric value '5' as a single byte results in 0000 0101
07:02:41 <merijn> @hackage binary -- bernalex 
07:02:42 <lambdabot> http://hackage.haskell.org/package/binary -- bernalex
07:02:45 <bernalex> aha OK
07:03:01 <eacameron_> How do you import all the data constructors of an type-level operator? E.g. import Servant ((:<|>)..) <- ???
07:03:10 <mnoonan> tobiasBora: maybe, though I haven't really had problems with it before. If I do "fact n =<RET>case n of<RET><TAB>0 -> 1" etc then it seems to do better.
07:03:27 <mnoonan> annoying that it isn't automatic though
07:03:53 <bernalex> mnoonan: so are you sure about everything? because typechecking fails. :]
07:03:56 <frerich> bernalex: Are you writing an assembler?
07:04:25 <mnoonan> bernalex: I think you meant somebody else :)
07:04:25 <tobiasBora> mnoonan: Really ? Me the tab just stay on the current line...
07:04:33 <bernalex> mnoonan: sorry :)
07:04:36 <bernalex> merijn: ohh my mistake. :]
07:04:44 <mnoonan> I get a 1-space indent on the tab
07:04:57 <bernalex> frerich: I'm writing a lexer/parser/assembler for a tiny jvm subset lol
07:05:18 <eacameron_> Oh...apparently with (:<|>)(..)   Weird.
07:05:36 <mnoonan> looks like my haskell-mode is 13.14.2, fwiw
07:06:01 <kurushii> hackrilege any feedback?
07:07:15 <frerich> bernalex: I'd imagine that if you have some type 'data Instruction' and 'type Program = [Instruction]' then you could define 'translate :: Instruction -> [Bit]' and 'assemble :: Program -> [Bit]' (with 'assemble = concatMap translate', I guess).
07:08:10 <bernalex> frerich: I suppose
07:10:38 <bernalex> merijn: I guess the type and everything is quite off. obviously if assemble is going to recurse and keep state it should be assemble :: ? -> [Instruction] -> ?. so if I have assemble is (Push n:js) it must basically "add" 16 to is, and then recurse with assemble [the updated is] and js.
07:11:33 <bernalex> merijn: so I guess here it would be :: Put -> [Instruction] -> Put? and then assemble is (Push n: js) puts 16 and n into is and does assemble is js. am I on the right track?
07:12:01 <merijn> bernalex: Why the Put as first argument?
07:12:18 <bernalex> merijn: OK maybe not. :)
07:13:12 <bernalex> merijn: just assemble (Push n:js) = do putWord8 16; putWord n; assemble js; ?
07:13:19 <bernalex> with appropriate {}s
07:13:21 <merijn> bernalex: Yeah
07:18:24 <bernalex> merijn: so how do I get a binary representation out of this?
07:18:44 <merijn> runPut produces a ByteString with the binary representation of everything you just put
07:19:00 <bernalex> I have f $ C1.parse $ C1.lex program :: Put; where f is just 'f (Right is) = C1.assemble is' for my convenience atm.
07:19:09 <bernalex> merijn: λ runPut $ f $ C1.parse $ C1.lex program
07:19:11 <bernalex> "\DLE\ENQ\DLE\ACK\DLE\a`h"
07:20:09 <merijn> Right?
07:20:32 <bernalex> merijn: parse :: [Token] -> Either String [Instruction]
07:23:14 <bernalex> merijn: hmm what do I do for []?
07:23:15 <merijn> I'm unsure whether this is a question? :)
07:23:32 <bernalex> i.e. in assemble :: [Instruction] -> Put -- the instruction being empty
07:23:37 <merijn> "return ()"?
07:23:39 <bernalex> merijn: I thought you were asking why there was a Right
07:23:43 <bernalex> merijn: that was my assumption. good. :]
07:25:24 <hackrilege> kurushii sorry i was afk
07:25:36 <kurushii> no worries 
07:25:36 <bernalex> merijn: here's my code: http://lpaste.net/1162990943763169280 looks ok?
07:26:12 <merijn> bernalex: Put is already a synonym for PutM (), but sure
07:26:27 <bernalex> merijn: oops. :]
07:26:39 <hackrilege> can you tell me a bit about what you are struggeling with? does this code produce an error?
07:26:54 <bernalex> merijn: but uhm how do I get ghci to print actual binary? i.e. 0s and 1s
07:27:11 <merijn> write a quick function that shows ByteString as 0s and 1s?
07:27:22 <bernalex> merijn: oh there isn't one?
07:27:27 <merijn> Might be, I don't know
07:27:38 <merijn> Alternatively open up your output in hex editor of choice :)
07:27:57 <hackrilege> kurushii^
07:27:59 <geekosaur> binary digits are not a common output format, no
07:28:45 <hackrilege> instance Show ByteString where
07:28:46 <hackrilege>     showsPrec p ps r = showsPrec p (unpackWith w2c ps) r
07:28:51 <geekosaur> might look at Numeric.showIntAtBase in conjunction with Data.Char.intToDigit
07:28:57 <orion> Anyone know how to write a {#fun#} c2hs directive for ByteStrings?
07:29:22 <blueonyx> why does the cabal install in 'cabal build -j && cabal install -j' build again? (ping dcoutts)
07:29:45 <kurushii> hackrilege i think i linked the wrong code before it didn't have the import at the top
07:29:50 <hackrilege> ok
07:29:56 <kurushii> http://pastebin.com/Q2wvkggK
07:30:01 <kurushii> that's the correct one
07:30:13 <blueonyx> what else but cabal register does cabal install do?
07:30:52 <bernalex> merijn: well L.unpack gets me dec at least. :]
07:31:01 <hackrilege> it looks very similar
07:31:23 <bernalex> λ L.unpack . runPut . f . C1.parse . C1.lex $ "push 5; push 6; push 7; mul; add;"
07:31:25 <bernalex> [16,5,16,6,16,7,96,104]
07:31:30 <bernalex> looks about right
07:31:45 <kurushii> yes sorry uhm i undid the $ statements let me link you the updated spin method
07:32:13 <hackrilege> oh yeh i can see that in the other one, it works ok?
07:32:36 <kurushii> http://pastebin.com/2jzsk3CA
07:32:50 <hackrilege> but whats the problem?
07:32:55 <kurushii> yes it works ok but i wish to create list of these squares
07:33:03 <kurushii> whilst also making them spin
07:33:41 <hackrilege> does this not do that?
07:33:44 <kurushii> no 
07:33:52 <kurushii> it only creates one square and spins that
07:33:58 <hackrilege> but it has rect given a parameter that looks like spinning...
07:34:01 <hackrilege> oh ok
07:34:35 <hackrilege> (rect (cycleSmooth 7 [30, 50]) (cycleSmooth 7 [30, 50])
07:34:37 <kurushii> but when i try to use list comprehension to create more squares and make them spin i get errors regarding use of brackets or very obscure errors
07:34:45 <hackrilege> so maybe you could use map rect
07:34:49 <hackrilege> :t map
07:34:50 <lambdabot> (a -> b) -> [a] -> [b]
07:35:19 <kurushii> no idea on how to use especially with something as tricky as this
07:35:25 <kurushii> use map*
07:35:30 <hackrilege> as a list comprehension [rect a b| (a,b) <- suppliedList]
07:35:41 <hackrilege> ok so lets see map in use
07:35:52 <hackrilege> > map (+1) [1..10]
07:35:54 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
07:36:02 <hackrilege> :t (+1)
07:36:05 <lambdabot> Num a => a -> a
07:36:07 <hackrilege> :t [1..10]
07:36:10 <lambdabot> (Enum t, Num t) => [t]
07:36:31 <hackrilege> so we have a list and a function that opperates on the ellemnts, map applies the function to each of the elements
07:36:45 <hackrilege> as if it were a for loop accessing each ellement in turn and modifying it
07:37:02 <kurushii> so for example map (+1) [1..10] will apply + 1 to all the elements
07:37:12 <hackrilege> [f a | a <- b] === map f b
07:37:18 <hackrilege> yeh you got it
07:37:30 <kurushii> ok got it but on something like this where do i even start?
07:37:31 <hackrilege> so we can apply rect to a list of the arguments
07:37:58 <hackrilege> but since it takes two arguments, we want to wrap those up in a tuple and get them back out.
07:38:12 <hackrilege> we could define rect' (a,b) = rect a b
07:38:19 <kurushii> ok so far so good
07:38:25 <hackrilege> and then map rect' to a list of the pairs of the arguments
07:39:09 <kurushii> so rect' (a,b) will be the function declaration righ
07:39:21 <kurushii> right*
07:39:43 <hackrilege> yeh, and we need to supply it 2 varying lengths
07:39:48 <kurushii> as in spin :: (a,b) -> Animation
07:39:58 <bollu> :t curry
07:40:00 <lambdabot> ((a, b) -> c) -> a -> b -> c
07:40:35 <hackrilege> rect' :: (Varying Length,Varying Length) -> Animation
07:40:46 <hackrilege> @src uncurry
07:40:46 <lambdabot> uncurry f p = f (fst p) (snd p)
07:40:56 <hackrilege> @src curry
07:40:56 <lambdabot> curry f x y = f (x, y)
07:41:33 <hackrilege> those are the names for this "wrapping two functin arguments into one tuple" and back again is known as currying and uncurrying
07:41:40 <hackrilege> the dude was called haskell curry
07:42:04 <kurushii> ok gonna define this function hold on
07:42:44 <hackrilege> rect' = curry p
07:42:48 <hackrilege> oops
07:42:54 <hackrilege> rect' = curry rect
07:43:25 <kurushii> ok so far got this
07:43:33 <hackrilege> anyway then we can generate a list of arguments to act on, a list of pairs of Varying Length
07:44:02 <kurushii> spin :: (a, b) 
07:44:09 <kurushii> -> Animation
07:44:18 <kurushii> and spin = curry rect
07:44:24 <hackrilege> something like [cycleSmooth a [30, 50] | a <- [5,6,7,8]]
07:44:33 <hackrilege> hmm, spin /= curry rect
07:44:57 <hackrilege> spin is an already defined function, rect' was a wrapper for the function rect which makes squares
07:45:03 <bollu> is there anyway to *disable* multiple argument function definitions in ghci? (that is, *not* allow let f a b c = ..)
07:45:16 <bollu> I've been teaching someone Haskell, and I didn't show them multi-parameter lambdas
07:45:37 <kurushii> sorry i'm kind of lost mind elaborating
07:45:46 <bollu> because IMO, understanding how single parameter lambdas with functions-returning-functions sort of.. emphasizes the point of partial application
07:45:53 <bollu> is that crazy? 
07:45:57 <hackrilege> kurushii, would you like to see a multi parameter lambda expression?
07:46:06 <kurushii> yes please
07:46:11 <bollu> kurushii: I was asking the IRC :)
07:46:17 <hackrilege> > (\ a b c -> a + b - c) 1 2 3
07:46:19 <lambdabot>  0
07:46:28 <hackrilege> its the same as;
07:46:40 <bollu> > (\a -> \b -> \c a + b - c) 1 2 3
07:46:42 <lambdabot>  <hint>:1:19: parse error on input ‘+’
07:46:46 <hackrilege> > let f a b c = a + b - c in f 1 2 3
07:46:48 <lambdabot>  0
07:46:50 <bollu> > (\a -> \b -> \c -> a + b - c) 1 2 3
07:46:51 <lambdabot>  0
07:46:59 <hackrilege> what is that!?
07:47:00 <bollu> ^ so a function with 
07:47:10 <hackrilege> why use more than one lambda?
07:47:39 <bollu> hackrilege: just to emphasize the fact that lambda calculus doesn't acknowledge more than one lambda? it's just syntactic sugar
07:48:04 <bollu> (AFAIK)
07:48:13 <bollu> do not quote me on this :P 
07:48:18 <kurushii> ok hackrilege can we start with the function definition again what did you mean by rect is a wrapper?
07:48:18 <hackrilege> ok, fair i guess, your returning functions that take one argument multiple times, i guess that has the spirit of haskell function composition
07:48:44 <bernalex> merijn: can you not get it in binary digits using printf somehow?
07:48:59 <hackrilege> ok, so i didnt like how rect took 2 arguments, as i just wanted it to have one argument so i could supply it as the first argument to map, which requires a function which takes one argument;
07:49:01 <merijn> bernalex: Probably
07:49:01 <hackrilege> :t map
07:49:03 <lambdabot> (a -> b) -> [a] -> [b]
07:49:13 <hackrilege> (a->b) is a function of one argument
07:49:15 <kurushii> ok so how would i define that function
07:49:41 <bernalex> merijn: :) closest I've gotten is 10000101100001101000011111000001101000. but it should be 0001000000000101000100000000011000010000000001110110100001100000.
07:49:45 <hackrilege> well, by currying the two arguments of rect in our definition of rect' we are making such a one argument function, then we can use map
07:50:17 <merijn> bernalex: Looks like the expected output is using 16bit words
07:50:19 <hackrilege> so i can go map rect' [       (   cycleSmooth 7 [30, 50]    ,   cycleSmooth 7 [30, 50] )     ]
07:50:22 <bernalex> merijn: or something
07:50:29 <bollu> merijn: is it stupid to not teach someone new to haskell that \a b c -> … exists? I only showed them \a -> \b -> \c -> …. . I plan on showing them \a b c the next time I meet them and I am fully prepared to have them rip my head off :P
07:50:39 <bernalex> merijn: using "%b ", I get 10000 101 10000 110 10000 111 1100000 1101000
07:50:48 <hackrilege> which i can expand using our definition of rect' as;
07:50:50 <kurushii> so our function declaration would be rect' :: (Varying Length,Varying Length) -> Animation
07:50:55 <merijn> bernalex: Oh, maybe %b is stripping leading zeroes
07:51:05 <merijn> bernalex: Lookup format specifiers to pad to 8 digits
07:51:14 <hackrilege> map (\ (a,b) -> rect a b) [       (   cycleSmooth 7 [30, 50]    ,   cycleSmooth 7 [30, 50] )     ]
07:51:21 <hackrilege> or even;
07:51:22 <bollu> bernalex: you can fill in the leading zeroes right?
07:51:27 <bollu> by hand
07:51:30 <hackrilege> map (rect.curry) [       (   cycleSmooth 7 [30, 50]    ,   cycleSmooth 7 [30, 50] )     ]
07:51:49 <bollu> merijn: thoughts on the lambda-teaching?
07:52:01 <geekosaur> should be %8.8b, if it's not up to POSIX snuff then it'll be %08b
07:52:19 <merijn> bollu: We used to start by teaching lambda calculus (everything unary) first, then only later show the other as syntactic sugar (which it is)
07:52:43 <bernalex> merijn: bollu: I just looked at the what it should be and what it is generated with spaces, and yep, that's indeed it.
07:53:28 <bernalex> geekosaur: yeah I just did 08b and it worked great
07:53:52 <bernalex> is there a way to use printf more directly than unpacking it though?
07:54:00 <bernalex> I'm mapM-ing printf on the unpacked runPut lol
07:54:35 <hackrilege> i was totally happy using haskell for years and years before i really understood about haskell functions only taking one argument
07:54:44 <hackrilege> im sure the sugary way is ok first
07:54:50 <hackrilege> as the later lesson is harder
07:54:55 <hackrilege> and unnesacary
07:55:22 <Zekka|Sigfig> obadz: I wasn’t here but someone may have mentioned this to you yesterday
07:55:41 <Zekka|Sigfig> > let x = ‘a’:y in let y = ‘b’:x in x
07:55:43 <lambdabot>  <hint>:1:9: lexical error at character '\8216'
07:55:50 <Zekka|Sigfig> oh screw my cliet
07:55:54 <obadz> ?
07:55:58 <hackrilege> lol
07:56:14 <bollu> merijn: cool, thanks :)
07:56:19 <Zekka|Sigfig> > let x = 'a':y in let y = 'b':x in x
07:56:20 <lambdabot>      Couldn't match expected type ‘[Char]’ with actual type ‘Expr’
07:56:20 <lambdabot>      In the second argument of ‘(:)’, namely ‘y’
07:56:20 <lambdabot>      In the expression: 'a' : y
07:56:44 <Zekka|Sigfig> hm. In a moment I’ll probably figure out what I screwed up
07:56:49 <obadz> Zekka|Sigfig: this for me?
07:56:57 <Zekka|Sigfig> What I was going to show you is a case where two objects created at the same time point to each other
07:57:00 <hackrilege> let (x,y) = ('a':y,'b':x) in x
07:57:09 <hackrilege> > let (x,y) = ('a':y,'b':x) in x
07:57:11 <lambdabot>  "abababababababababababababababababababababababababababababababababababababa...
07:57:15 <Cale> > let x = 'a':y; y = 'b':x in x
07:57:17 <lambdabot>  "abababababababababababababababababababababababababababababababababababababa...
07:57:20 <hackrilege> dno why your one didnt work
07:57:28 <geekosaur> Zekka|Sigfig, 'y' in the outer let is getting the one from simple-reflect
07:57:32 <Cale> It would have worked, but the lets were nested.
07:57:34 <geekosaur> do them as a single binding group
07:57:35 <Zekka|Sigfig> geekosaur: Oh! Yeah, makes sense
07:57:36 <kurushii> ok hackrilege wrote up some code using map but getting errors 
07:57:41 <Zekka|Sigfig> Thanks for catching me on that
07:57:41 <geekosaur> let { x = ...; y = ... } in ...
07:58:27 <Zekka|Sigfig> obadz: Pretty sure you can also do something tricky with STRefs to get an STRef that points to another STRef newer than it
07:58:28 <obadz> is this two objects pointing to each other from a GC standpoint?
07:58:53 <Zekka|Sigfig> obadz: Pretty sure the underlying representation is in fact two objects pointing at each other, but I have no ghc commits so you shouldn’t trust me
07:58:54 <hackrilege> its a recursive definition
07:59:11 <hackrilege> i non trivial one
07:59:29 <hackrilege> i would like to find a list of ordered recursion schemes, does anyone know of one?
08:00:03 <Zekka|Sigfig> If I had unsafePerformIO we could see how many times it evaluates ‘x’ and find out!
08:00:32 <obadz> Zekka|Sigfig: your only access to haskell is via lambdabot ? :)
08:00:42 <hackrilege> mine is
08:00:42 <bollu> what's a recursion scheme?
08:00:43 <Zekka|Sigfig> obadz: Nah, I’ve got a copy on my local machine here
08:01:02 <hackrilege> bollu. recursion is where a function definition is written in terms of itself
08:01:14 <bollu> hackrilege: yes, I was wondering what the "scheme
08:01:19 <hackrilege> eg let x = f x in
08:01:20 <bollu> "scheme" is, not what recursion is :)
08:01:35 <hackrilege> ok sorry im not keen on that word ill drop it
08:01:41 <hackrilege> recursion realtions?
08:02:36 <hackrilege> relation
08:02:40 <hackrilege> nvm
08:02:47 <hackrilege> its just terminology
08:02:56 <Zekka|Sigfig> hackrilege: let x = trace “x evaluated” (‘a’: y); y = ‘b’: x in putStrLn $ take 40 x
08:03:06 <Zekka|Sigfig> This prints “x evaluated” once followed by 20 “ab”s
08:03:12 <obadz> Zekka|Sigfig: in any case, I think x and y are in the same generation no?
08:03:28 <Zekka|Sigfig> obadz: Pretty sure, not dead positive. I bet you can get old referring to new with ST though
08:03:40 <hackrilege> once x is evaluated it should know what it is and not need evaluating again if it is used later
08:03:44 <hackrilege> maybe thats why
08:03:44 <Zekka|Sigfig> But I don’t know the details of how GHC represents ST, it could be a big special case
08:03:47 <hackrilege> im not sure
08:03:58 <obadz> Zekka|Sigfig: yes that's beyond me
08:04:32 <bollu> I want to help GHC dev / learn about how the compiler works
08:04:36 <bollu> how do I get started? :3
08:04:51 <kurushii> http://pastebin.com/FtnT6t90 what i've got so far
08:04:54 <Zekka|Sigfig> bollu: Probably download a copy of the source code!
08:05:01 <bollu> Zekka|Sigfig: that aside :P
08:05:11 <kurushii> but the errors i get from terminal are not helpful 
08:05:16 <bollu> and I do have a local copy pf GHC
08:05:25 <kurushii> so trying to fix this is a pain in the backside
08:05:28 <Zekka|Sigfig> No commits on GHC here — I’m not sure who you’d talk to
08:05:31 <obadz> Zekka|Sigfig: I think semantically once you mutate an array in ST to point to something young maybe the array gets bumped down to a younger generation? I really have no idea..
08:05:37 <bollu> prog du -sh ghc/
08:05:37 <bollu> 1.6G	ghc/
08:06:00 <Zekka|Sigfig> obadz: Gut is that that would be an acceptable way to implement it, although doesn’t bumping generations entail a copy?
08:06:17 <obadz> I don't see why it would?
08:06:32 <hackrilege> ok so if i define my Graph in terms of Map and then I want to write an applicative instance (the functor instance uses Map.map) how do i extract the function from the pure Graph?
08:06:37 <obadz> Couldn't you just copy the root pointer?
08:06:51 <Zekka|Sigfig> obadz: When you say root pointer, which do you mean?
08:06:55 <jeltsch> Zekka|Sigfig, bollu: Just looking at GHC’s source code is probably a very bad idea, since it is a nontrivial piece of software.
08:07:17 <Zekka|Sigfig> Are you suggesting an implementation where the actual array is allocated elsewhere and all ST operations are just handled on a pointer to that array, where it’s cheap to move that pointer around?
08:07:18 <jeltsch> bollu: I had this question a short time ago, and I found the excellent GHC Commentary: https://ghc.haskell.org/trac/ghc/wiki/Commentary
08:07:21 <obadz> Zekka|Sigfig: I think this is the paper if you are interested: http://community.haskell.org/~simonmar/papers/parallel-gc.pdf
08:07:27 <obadz> Zekka|Sigfig: the pointer to the array
08:07:34 <bollu> jeltsch: did you wind up sending commits to GHC?
08:07:47 <hackrilege> anyone?
08:07:48 <Zekka|Sigfig> obadz: I’m at work and would feel guilty getting *too* involved in something like that, but maybe later this evening
08:07:59 <jeltsch> bollu: I am not yet that far, but I definitely plan to do so.
08:08:02 <obadz> Zekka|Sigfig: let me know if you end up finding out :)
08:08:13 <hackrilege> pure just makes a singleton Graph.
08:08:34 <lyxia> hackrilege: Should it be applicative in the first place?
08:09:07 <lyxia> hackrilege: what does the type parameter represent? The type of nodes?
08:09:27 <bollu> jeltsch: any pointers for me?
08:09:52 <mpickering> jeltsch: unfortunately the only way to understand how a lot of it works is to read the source code
08:09:58 <mpickering> the guide only gets you so far :(
08:09:59 <obadz> Zekka|Sigfig: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC/Aging
08:10:14 <jeltsch> bollu: Pointers to what? The link https://ghc.haskell.org/trac/ghc/wiki/Commentary, which I already sent, is my ultimate pointer. It links to all kinds of useful stuff.
08:10:28 <obadz> Zekka|Sigfig: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC/EagerPromotion
08:10:35 <jeltsch> mpickering: My point was that *only* looking at the source code is a bad idea.
08:10:44 <bollu> jeltsch: ah, cool. ty!
08:11:02 <jeltsch> mpickering: I think you first need a bit of general information and then dive into the code.
08:11:22 <obadz> Zekka|Sigfig: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC
08:12:44 <hackrilege> lyxia yes the parameter is the type of the nodes
08:13:09 <hackrilege> how is something i can map a function over not applicative?
08:14:36 <hackrilege> for example it could be data Graph a = Graph (Map Int a)
08:15:01 <lyxia> that's not really a graph is it?
08:15:04 <hackrilege> :t Data.Map.singleton
08:15:06 <lambdabot> k -> a -> M.Map k a
08:15:13 <hackrilege> data Graph a = Graph {neighbours :: Map Vertex (Set Vertex),points :: Map Vertex a}
08:15:17 <hackrilege> if you want to be picky
08:15:29 <Xandaros> There is no safe version of tail in base, is there? …
08:15:38 <hackrilege> but we can just use the points as the edges are not modified by our function application
08:16:02 <lyxia> hackrilege: Oh okay.
08:16:44 <hackrilege> so the only problem is if i have;
08:16:53 <lyxia> hackrilege: how do you choose the value of the vertices?
08:16:55 <hackrilege> pure a = Graph Map.empty (Map.singleton 0 a)
08:17:11 <lyxia> from 0 to sizeOfTheGraph - 1 ?
08:17:12 <hackrilege> the verticies are incramented, we can get the max vertex and add one to it
08:17:18 <hackrilege> as they are added
08:17:47 <hackrilege> snoc g a = addVertex (1+(size g)) a g
08:18:04 <Xandaros> I guess fmap snd . uncons works :/
08:18:34 <hackrilege> :t fmap (snd . uncons)
08:18:36 <lambdabot>     Couldn't match type ‘Maybe (a, [a])’ with ‘(a0, b)’
08:18:36 <lambdabot>     Expected type: [a] -> (a0, b)
08:18:36 <lambdabot>       Actual type: [a] -> Maybe (a, [a])
08:18:36 <lyxia> hackrilege: uh, so adding a vertex to a singleton gives it index 2...
08:19:00 <hackrilege> i guess so yeh, i should supply 1 as the index of empty i guess
08:19:03 <hackrilege> pure*
08:19:35 <hackrilege> anyway, thats how i do pure, but then i need to access the function in that graph in (<*>)
08:19:44 <lyxia> or index from zero and add size g instead of 1+size g...
08:19:56 <hackrilege> i just get it using the index 1 ? it seems v sloppy
08:20:03 <lyxia> hackrilege: <*> must also work if the graph is not a singleton
08:20:10 <hackrilege> yeh it seems nasty
08:20:36 <hackrilege> but then;
08:20:36 <lyxia> so you have to define the "product" operation between graphs
08:20:37 <hackrilege> > (+) <$> [1,2,3] <*> pure 5
08:20:40 <lambdabot>  [6,7,8]
08:20:51 <hackrilege> does not create a list of length 3 of repeat (+)
08:21:15 <hackrilege> or of repeat 5
08:21:21 <lyxia> I did not understand your point
08:21:43 <hackrilege> your saying a singleton graph does not hold enough functions
08:21:53 <hackrilege> but here a singleton list was sufficint
08:22:33 <lyxia> No, I'm saying <*> could hold many functions... for example obtained by mapping (+) over a large graph.
08:22:54 <hackrilege> > [(1+)] <*> pure 1
08:22:56 <lambdabot>  [2]
08:23:07 <hackrilege> > [(1+),(2+)] <*> pure 1
08:23:09 <lambdabot>  [2,3]
08:23:20 <hackrilege> > pure 1
08:23:22 <lambdabot>      No instance for (Show (f0 a0))
08:23:22 <lambdabot>        arising from a use of ‘show_M62495557483521613613560’
08:23:22 <lambdabot>      The type variables ‘f0’, ‘a0’ are ambiguous
08:23:27 <lyxia> You're talking as if there is just one function you need to extract and then fmap on the second argument of (<*>).
08:24:03 <hackrilege> first argument, but yeh
08:24:37 <lyxia> It's not really a matter of extracting anything though... an Applicative instance does not imply the existence of a function extract :: f a -> a.
08:24:45 <hackrilege> here, pure 1 knows it needs to go on a list of length 2 somehow, it seems to be fmaping in some way
08:25:20 <hackrilege> well its the <*> that seems to be mapping
08:25:31 <lyxia> (+) <$> [2,4,6] <*> [1,2,3
08:25:33 <quicksilver> <*> with pure on one side is just fmap, yes
08:25:41 <lyxia> > (+) <$> [2,4,6] <*> [1,2,3]
08:25:43 <lambdabot>  [3,4,5,5,6,7,7,8,9]
08:26:03 <quicksilver> that is not right.
08:26:06 <hackrilege> ok so we expect different behaviour if we use (+) with lists or single elements
08:26:08 <quicksilver> (what I said, I mean)
08:26:20 <hackrilege> yeh it seemed strange dont worry
08:26:32 <quicksilver> pure f <*> blah is fmap f, though
08:26:38 <hackrilege> so how do i know what i would expect my graph to do
08:26:48 <hackrilege> im basically just using like a functor to appy the functions
08:26:53 <hackrilege> fmaping them in
08:27:01 <hackrilege> im not sure about Applicative...
08:28:04 <hackrilege> can we define an applicative instance for graphs and trees?
08:28:21 <quicksilver> for trees there are two obvious ones
08:28:27 <quicksilver> just like there are two obvious ones for lists
08:28:46 <quicksilver> the 'zippy' one which requires both trees to be the same shape
08:28:50 <hackrilege> a length preserving one, and a cartesian product one
08:28:55 <quicksilver> yes
08:29:04 <hackrilege> i want length preserved plz
08:29:51 <quicksilver> that will only work if your two graphs are exactly the same shape
08:30:01 <quicksilver> or
08:30:10 <hackrilege> i guess there is the possability to put a different f in each node, but thats not what im doing, i really am fmaping the functions in, i dont get how applicative gets away with being an actual thing, i dont understand why its not just functor, other than its ability to modify shape, which i dont require
08:30:15 <quicksilver> well it will still work, but it will effectively take the intersection of the graphs
08:30:24 <hackrilege> hmmm, thats ok
08:30:35 <quicksilver> if you don't need to put a different f at each node
08:30:37 <hackrilege> since they will contain each other it should work ok
08:30:38 <quicksilver> then you aren't applicative
08:30:43 <quicksilver> you're just a Functor.
08:30:50 <hackrilege> > [(1+),(2+)] <*> pure 1
08:30:52 <lambdabot>  [2,3]
08:30:56 <hackrilege> is using applicative like a functor?
08:31:06 <quicksilver> no, that has different functions at each node
08:31:12 <quicksilver> it has (1+) at one node
08:31:16 <quicksilver> and (2+) at the other node.
08:31:36 <hackrilege> hmm but thats just fmap (+) [1,2]
08:31:39 <hackrilege> thats what i mean
08:31:51 <quicksilver> ok, but (1+) and (2+) are different functions :)
08:32:03 <quicksilver> and it still works even when they aren't generated from an fmap
08:32:11 <hackrilege> its like im trying to partially apply something, or zipWith
08:32:17 <hackrilege> right?
08:32:19 <quicksilver> > [(2+),(2*)] <*> pure 5
08:32:21 <lambdabot>  [7,10]
08:32:24 <hackrilege> aha
08:32:38 <hackrilege> i think i need zipWith
08:32:43 <hackrilege> do you agree?
08:32:56 <quicksilver> yes, that zippy instances
08:33:13 <quicksilver> so you're using Graph a = Graph (Map Vertex a) [(Vertex,Vertex)] now? or what?
08:33:30 <hackrilege> which is not like an applicative? or is a fine applicative instance? i dont really get whats going on here and what idiom im preserving
08:34:02 <quicksilver> well the <*> part is easy now
08:34:13 <quicksilver> on vertices you do
08:34:20 <hackrilege> its ok i can scale it up to my graph from data nonGraph a = nonGraph (Map Int a)
08:34:23 <quicksilver> intersectionWith f
08:34:41 <quicksilver> intersectionWith ($) that is
08:34:41 <hackrilege> :t intersectionWith
08:34:42 <lambdabot>     Not in scope: ‘intersectionWith’
08:34:43 <lambdabot>     Perhaps you meant one of these:
08:34:43 <lambdabot>       ‘IM.intersectionWith’ (imported from Data.IntMap),
08:34:50 <quicksilver> :t M.intersectionWith
08:34:52 <lambdabot> Ord k => (a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
08:35:03 <quicksilver> that applies a function to points with matching keys
08:35:08 <quicksilver> but you have a problem with pure
08:35:17 <quicksilver> you need to designate your set of Vertices to do 'pure'
08:35:19 <hackrilege> awesome, thats a zipWith in the perfect way taking the intersection, awesome
08:35:59 <hackrilege> i dont understand your last point. your saying my pure will not know the shape of the graph (its indexes)?
08:36:13 <hackrilege> the one it will be applied too...
08:36:14 <quicksilver> you have pure a = fromList (map (\vx -> (vx,a)) allVertices)
08:36:23 <quicksilver> so you need a fixed 'allVertices' set
08:36:51 <quicksilver> so pure a is the graph with "the value a everywhere"
08:36:58 <quicksilver> whatever 'everywhere' is supposed to mean
08:37:20 <quicksilver> (it's also not completely clear what you do with the edge sets - but you probably intersect them too - so pure has to have 'every edge')
08:37:40 <hackrilege> :t M.elems
08:37:42 <lambdabot> M.Map k a -> [a]
08:37:48 <hackrilege> sorry
08:37:59 <hackrilege> :t M.keys
08:38:00 <lambdabot> M.Map k a -> [k]
08:38:39 <hackrilege> but my point is that when i call pure, i dont supply the graph to copy the shape of
08:38:56 <hackrilege> i have nothing to supply M.keys too
08:39:34 <hackrilege> no?
08:40:26 <quicksilver> exactly
08:40:33 <quicksilver> that's why you need a notion of 'all vertexes'
08:40:39 <hackrilege> !?
08:40:44 <hackrilege> partially applied?
08:40:46 <quicksilver> that's why pure fora  ZipList is an infinite list
08:40:56 <quicksilver> because the infinite list is 'all indices' for a list
08:41:37 <hackrilege> so i could specify a range and make functions for each index in this range and then the intersection would be good as long as the range contained all the verticies of the graph?
08:41:40 <hackrilege> seems overkill...
08:41:59 <hackrilege> unless i misunderstand
08:42:06 <hackrilege> i guess its a bit like;
08:42:19 <hackrilege> zioWith (+) [1,2,3] [1..]
08:42:25 <hackrilege> > zipWith (+) [1,2,3] [1..]
08:42:27 <lambdabot>  [2,4,6]
08:43:03 <hackrilege> which does not seem too slow. but maybe if i have a Graph in 100 dimensions, with huge tuples, then the generator will create far too many ellemnts?
08:43:23 <quicksilver> maybe
08:43:27 <hackrilege> [(a,b,c.....)|a<-z,b<-z...]
08:43:31 <quicksilver> you cvould add a special case data constructor for this
08:43:38 <quicksilver> but again we ask the question "why"
08:43:42 <quicksilver> why do you want this type to be Applicative?
08:43:47 <quicksilver> how do you think that will help?
08:43:49 <hackrilege> no that was my question sorry you cant do that
08:44:14 <quicksilver> if oyu just like the intersection-forming product operation (which is probably a nice thing)
08:44:17 <quicksilver> then just write
08:44:21 <hackrilege> is it sensible to have an applicative graph?
08:44:30 <quicksilver> that is a meaningless question
08:44:34 <hackrilege> ah
08:44:39 <quicksilver> the right question is "what operations do I want to perform on my graphs?"
08:44:46 <hackrilege> that will be why im finding it hard to answer
08:44:53 <quicksilver> ...and do any of those operations suggest an Applicative instance?
08:44:54 <hackrilege> i wish to fold and zip my graphs
08:45:05 <quicksilver> if you wish to zip graphs, then just write
08:45:16 <quicksilver> zipGraph :: Graph a -> Graph b -> Graph (a,b)
08:45:20 <quicksilver> or, indeed 
08:45:33 <quicksilver> zapGraph :: Graph (a->b) -> Graph a -> Graph b
08:45:33 <Summh> i didn't still able when the tinder of big boobs open: this inferior to get used to see
08:45:35 <Summh> _Forbin: these in ever how to american in and safe. NOODLEARM. the food and soccer = grass fairy's. why dont was legal. Viking vital
08:45:36 <hackrilege> three is a chance also that i want them to be monads, if they contain graphs of graphs .. of monoids at the nodes
08:45:37 <Summh> chrome | ExtremeTech. haha chick riding vital
08:45:38 <Zekka|Sigfig> hackrilege: ‘zip’ like behavior frequently suggests an applicative instance, but only if you can define it for all pairs of members of your type
08:45:39 <Summh> chrome Why I'm dumping they article and they're open: this...is a socer = grass fairy's. we was good and soccer
08:45:41 <Summh> you are me! all take a bicycle want see it reach into my software. ooo. soccer jersey. - Imgur to wait sucks. culture: yeah, like things. Blair Walsh receives extensions update socer as i do?. no. i would have this on 7-11 doors when when that's not racist. all take a $14 breakfast
08:45:43 <Summh> i didn't sting pleasant.. still land these hands will fuckin shit out. I mean. no. i mean they'll take a yelp comment
08:45:45 <Summh> "I gave drugs? thats when the fuck out. I mean the tip of alabama. specimens inferior to reach into mobile. crap. i've never inconvenies though. profiling!
08:45:47 <Summh> fuckin' game? nice was legal. Viking Him Cheating ever do another channel and safe. NOT CLICKING. how to chrome toe and soccer jersy if it wait 40minutes funny and soccer
08:45:48 <Zekka|Sigfig> !ops
08:45:49 <Summh> Key NFL over Brady. pants. i became the stories or pic plz. L0c0: i just post amazing an ice was still go to leave drugs? that i do?. no beer! el puton!
08:45:50 <Summh> noodlearm. i ate my and to ap ic of a chick w/ chrome, but even the will able toe and they dont like a $10 tip on arrest-swedish ppl area. your hip pocket (Bad Advice was stickin shit out of news sting calibre. the pedals. we hands
08:45:52 <Summh> i jus pressuring pants. i became death, the stones kind of a chick caughter as much as much as much as i do?. no. i ate my dick caughter inconvenies hands with a need no beer. NOODLEARM. throw furniture! gin a medivac
08:45:54 --- mode: ChanServ set +o glguy
08:45:54 <Summh> 's snoop Dogg blames-racist. all me runatrain
08:45:54 --- mode: glguy set +b *!*@41.215.40.78
08:45:55 --- kick: Summh was kicked by glguy (Summh)
08:46:01 <Zekka|Sigfig> glguy: Thanks!
08:46:10 <quicksilver> sorry. Seems I asn't identified
08:46:12 --- mode: ChanServ set +o quicksilver
08:46:15 <quicksilver> bah
08:46:18 --- mode: quicksilver set -o quicksilver
08:46:29 <quicksilver> as I was saying
08:46:35 <quicksilver> zipGraph :: Graph a -> Graph b -> Graph (a,b)
08:46:35 <hackrilege> wow Summh are you writing in the wrong window!? please keep that stuff off this board
08:46:39 <quicksilver> zapGraph :: Graph (a->b) -> Graph a -> Graph b
08:46:45 <quicksilver> you can write these two easily enough
08:46:52 <quicksilver> using 'intersectionWith' like I showed before
08:47:08 <quicksilver> but that isn't enough to make an Applciative instance because you don't have a good way to write `pure`
08:47:16 <Zekka|Sigfig> ‘zip’ is basically liftA2 (,), which gives you *half* of Applicative
08:47:19 <quicksilver> but... who cares? maybe `pure` doesn't work for you. Maybe you aren't Applciative.
08:47:32 <quicksilver> Zekka|Sigfig: zip is liftA2 (,) and zap is <*>, yes
08:47:55 <quicksilver> Applicative is only actually useful if you need to run traverse
08:48:00 <quicksilver> and other combinators built that way
08:48:16 <hackrilege> i dont see why i should be able to do;
08:48:32 <hackrilege> > [(1+),(2+)] <*> pure 1
08:48:34 <lambdabot>  [2,3]
08:48:36 <Zekka|Sigfig> (emphasis being that in the role of ‘traverse’, you’ve got an effect and a container — the container only needs Functor/Foldable, while the effect needs Applicative)
08:48:38 <hackrilege> and not have pure for my graph
08:49:00 <quicksilver> you can write you own 'nearly pure'
08:49:08 <quicksilver> you can write one which takes the list of Vertices explicitly
08:49:28 <quicksilver> pureGraph :: [Vertex] -> a -> Graph a
08:49:34 <quicksilver> then you can write
08:50:02 <hackrilege> hmm, since im given the domentionality of my index i think ill use that generator thing, maybe its not too slow, anyway we have a pure with that, an infinite graph rather than a singleton graph
08:50:08 <hackrilege> but its the same thing
08:50:12 <quicksilver> fmap (+) g `zapGraph` pureGraph (getVertices g) 1
08:50:56 --- mode: glguy set -o glguy
08:51:01 <hackrilege> yeh thta would work, but id rather use the real pure, and since we have a fiar definition for it i say we forget that problem now
08:51:27 <hackrilege> id like to talk a bit about going on to extend it to monad and traversable
08:51:27 <blueonyx> quicksilver: are taking about a particular Graph data type? Data.Graph or fgl?
08:51:37 <hackrilege> data Graph a = Graph {neighbours :: Map Vertex (Set Vertex),points :: Map Vertex a} deriving Show
08:51:58 <blueonyx> kthx
08:51:58 <hackrilege> its just a Map of contents and a Map of Sets of neighbours
08:52:08 <quicksilver> blueonyx: hackrilege's own
08:52:14 <blueonyx> kthx
08:52:24 <hackrilege> the indexes in both graphs are the same, ensured by the construction methods
08:52:33 <clahey> And type Vertex = Int or what?
08:52:36 <hackrilege> yeh
08:52:55 <hackrilege> its pulled from some ancient example that was probably pulled from some other place
08:53:00 <quicksilver> Foldable and Traversable are easy for taht
08:53:04 <hackrilege> it fits my requirements fine
08:53:18 <quicksilver> any 'plain old data' container is always easy to make into instance of Foldable and Traversable
08:53:19 <hackrilege> faldable is cool
08:53:21 <clahey> And you're trying to define instance Applicative Graph ?
08:53:25 <hackrilege> but traversable i dont understand
08:53:33 <quicksilver> hackrilege: traversable is like functor
08:53:33 <hackrilege> yes clahey i am
08:53:43 <quicksilver> except you can 'do something' at each point as well as just changing it
08:53:48 <quicksilver> look how similar these types are
08:53:49 <quicksilver> :t fmap
08:53:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:53:51 <quicksilver> :t traverse
08:53:52 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:53:56 <hackrilege> i can map to each ellement in some order with a function which will do voodoo or something
08:54:05 <hackrilege> "effects"
08:54:18 <geekosaur> it's generalized map
08:54:33 <Zekka|Sigfig> fmap is basically traverse for f=Identity
08:54:35 <hackrilege> i visit each ellement and do some thing?
08:54:42 <quicksilver> instance Traversable Graph where traverse f (Graph n p) = Graph n (traverse f p)
08:54:48 <quicksilver> you just steal Map's traversable instance.
08:54:58 <quicksilver> since that's where all your `a`s live.
08:54:58 <hackrilege> acn i derive it?
08:55:04 <quicksilver> no you can't derive it
08:55:05 <hackrilege> ok
08:55:07 <quicksilver> but it's a one-liner ^^
08:55:10 <hackrilege> yeh
08:55:25 <quicksilver> you should find this looks exactly like your Functor instances
08:55:26 <hackrilege> but what does it mean!?
08:55:31 <clahey> So, the effects would happen in the order of the points map.
08:55:32 <Zekka|Sigfig> hackrilege: Emphatically, Traversable does not require your container type to be an Applicative — only for it to be a functor!
08:55:34 <hackrilege> i dont really get what functionality that would enable
08:55:46 <Zekka|Sigfig> hackrilege: What does this mean? fmap f (Graph n p) = Graph n (fmap f p)
08:55:59 <quicksilver> hackrilege: it would enable you to number your points, for example
08:56:08 <quicksilver> numberPoints :: Graph a -> Graph (Int,a)
08:56:09 <hackrilege> im fmaping onto the nodes, not the edges
08:56:18 <kurushii> hackrilege instead of using map i went back to using the list comp but getting syntax error on the | symbol
08:56:19 <Zekka|Sigfig> This means the same thing, but f can produce its result in an applicative
08:56:21 <quicksilver> see what I did there? it adds an 'Int' to each node, numbering it.
08:56:39 <Zekka|Sigfig> FWIW I think quicksilver may have meant traverse f (Graph n p) = Graph n <$> (traverse f p), but I’m not positive
08:56:39 <hackrilege> kurushii, awesome! well done for finding your bug
08:56:53 <quicksilver> Zekka|Sigfig: thanks, I did :)
08:56:55 <kurushii> but i am unable to solve it
08:57:03 <kurushii> mind directing me on how to solve it
08:57:09 <hackrilege> haha, ok link up the details
08:57:22 <kurushii> http://pastebin.com/b24iM2ej
08:57:25 <clahey> So, what conclusion did y'all come up with about Applicative?
08:57:26 <blueonyx> i also would love to use my graphs more functionally, but i represent molecules and delNode,addNode around only specific nodes :/
08:58:25 <quicksilver> clahey: graphs like this have a very natural definiton of <*> but `pure` needs to be an infinite fully connected graph and that's a pain.
08:58:30 <quicksilver> clahey: is my conclusion
08:58:34 <hackrilege> clahey since its a Map its definately Traversable, and there seems to be a natural way to define pure to use with intersectWith for (<*>)
08:58:54 <quicksilver> clahey: so the Applicative instance is a stretch unless you are prepared to modify your data type to specfically accomodate the infinite case.
08:59:08 <Zekka|Sigfig> quicksilver: It’s probably easier to do if you use a function type instead of sets and maps
08:59:14 <hackrilege> it seems it can be made to be Applicative, but we debate that this is not just using it as a Functor in a strange way...
08:59:17 <quicksilver> Zekka|Sigfig: with a function type it's no problem at all
08:59:24 <hackrilege> but i got a bit confused so maybe thats not quite right
08:59:24 <clahey> So, there's a natural definition of pure in my head. I wonder if you could define <*> to match that.
08:59:25 <Zekka|Sigfig> But that makes it expensive to operate on
08:59:28 <quicksilver> Zekka|Sigfig: but that is a less practical type
08:59:43 <hackrilege> clahey, go on
08:59:48 <quicksilver> Zekka|Sigfig: you can't even list all the nodes unless you store a list of nodes separately....
09:00:06 <Zekka|Sigfig> quicksilver: Probably a pretty good way to do it is with data ProbablyALot a = Some a | Everything
09:00:13 <Zekka|Sigfig> then special-case checks on that
09:00:23 <quicksilver> yes Zekka|Sigfig that's what I mean
09:00:34 <hackrilege> oh i dont follow
09:00:37 <quicksilver> by "modify your datat type to specifically accomodate the infinite case"
09:00:48 <quicksilver> only it would be Everything a
09:00:48 <Zekka|Sigfig> Although of course some operations are no longer feasible on that, like ‘filter’
09:00:52 <clahey> Specifically pure a = Graph (singleton 0 (singleton 0)) (singleton 0 a
09:00:55 <quicksilver> because you do need a value at every point
09:00:56 <clahey> Specifically pure a = Graph (singleton 0 (singleton 0)) (singleton 0 a)
09:00:58 <hackrilege> sorry kurushii, whats the error?
09:01:06 <quicksilver> clahey: a single specific 0-vertex
09:01:15 <kurushii> parse error on input |
09:01:19 <quicksilver> clahey: that does work for pure but it implies a *different* <*>
09:01:24 <Zekka|Sigfig> quicksilver: Whoops — being clear, my ideal usages were ProbablyALot (Map k v) and ProbablyALot (Set v)
09:01:24 <clahey> Right.
09:01:29 <quicksilver> clahey: the one which tries "every possibility"
09:01:35 <clahey> It implies a multiplicative <*>.
09:01:40 <hackrilege> looks like you have unballenced square braces kurushii...
09:01:44 <clahey> Or maybe additive. I don't know.
09:02:03 <Zekka|Sigfig> That probably works OK for Enum k, Enum v if you want to implement ops like filter
09:02:04 <quicksilver> clahey: it implies the graph cartesian product, basically
09:02:07 <clahey> Right.
09:02:14 <kurushii> how would i solve this add another square brace?
09:02:15 <clahey> That also seems like the natural <*> to me.
09:03:22 <hackrilege> clahey, i was using singleton, but that dosent work well with intersectWith, and basically you are just fmaping as you use the same function at each ellemnt... i think!
09:03:54 <hackrilege> remove the second close sqare brace by the looks of it kurushii
09:03:54 <clahey> It's supposed to be fmap.
09:04:18 <clahey> pure f <*> a === fmap f a
09:04:18 <kurushii> but that closes the brace before translate
09:04:22 <clahey> (I think I did that right.)
09:04:25 <kurushii> i'll give it a try
09:05:00 <hackrilege> clahey, yeh something like that, thats why i was getting confused as to how to use applicative properly, namely to get more functionality than just fmap
09:05:01 <kurushii> yep not working
09:05:19 <geekosaur> kurushii, I worry about the indentation but I see a missing close paren
09:05:43 <geekosaur> (rect (always 2.5) (always 200)  {- need this: -}   )
09:05:51 <clahey> hackrilege: So, my <*> may be different from the one you're imagining.
09:06:22 <hackrilege> there are several missing close parenthesis
09:06:33 <kurushii> yes added them in
09:06:40 <kurushii> still error on |
09:06:47 <geekosaur> where did uyou add them?
09:06:52 <geekosaur> can't just glom them onto the end
09:06:53 <kurushii> closed all missing brackets at the end
09:06:58 <hackrilege> lol
09:07:01 <hackrilege> good attempt
09:07:17 <hackrilege> did you also try adding them randomly in all positions?
09:07:21 <geekosaur> your syntax error is because `(rect (always 2.5) (alwasy 200)' is not complete
09:07:29 <geekosaur> so you can't follow it with the | for the list comp
09:07:56 <clahey> But what is: Graph (fromList [(0,singleton 1), (1 singleton 2)]) (fromList [(0, (+1)), (1, (*2)), (2, (+3))]) <*> Graph (fromList [(0, singleton 1), (1, singleton 0)]) (fromList [(0, 4),(1,5)])
09:08:04 <kurushii> can't add them randomly as rotate applies to all rectangles with pain applies to all rectangles 
09:08:06 <hackrilege> clahey, no i think we have the same thing in the end.
09:08:34 <kurushii> geekosaur can eloborate
09:08:37 <kurushii> can you*
09:08:48 <geekosaur> did you read it carefully?
09:08:58 <kurushii> since rect takes and argument of rect (size) (size)
09:09:01 <kurushii> an*
09:09:02 <geekosaur> yes
09:09:11 <geekosaur> but what you wrote does not say that, quite
09:09:27 <geekosaur> ok, to be explicit (and please turn on bracket matching in your editor):
09:09:45 <geekosaur> you are missing the close parenthesis ) matching the one before `rect`
09:09:58 <hackrilege> kurushii, why not make other functions and call them? you write e.g. (a1,a2 .. e.t.c.) = (always (400,300),always 2.5 .. e.t.c.
09:10:00 <clahey> I get: Graph (somethingsomething) (fromList [(0, 5), (1, 6), (2, 8), (3, 10), (4, 7), (5, 8)])
09:10:08 <hackrilege> this would make it less messy and difficult to read
09:10:11 <clahey> hackrilege: I haven't figured out somethingsomething yet.
09:10:26 <fractalsea> I’m trying to test the maximum throughput of my system by pumping as many messages down a TCP socket as the program will accept. The odd thing is that when I look at the output of `top`, the CPU usage is only 75-80% why is it not using as much as possible?
09:10:40 <geekosaur> you are *also* missing the one matching the one before `rotate`, but that does not contribute to the | syntax error because it's outside the list comprehension
09:10:45 <kurushii> because this library is confusing and every time i try and define a function i get so many obscure rrors
09:10:59 <hackrilege> hmmm
09:11:23 <hackrilege> you should try getting small things with no error and building it slowly so you dont get lots of crazy error all at the same time
09:12:03 <hackrilege> clahey, im not sure what you mean
09:12:23 <kurushii> yh i'm trying to but since this function is a very small one i don't see the point in making multiple smallr functions
09:12:25 <kurushii> smaller*
09:12:38 <hackrilege> :t traverse
09:12:40 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:12:47 <clahey> Let's see somethingsomething = fromList [(0, fromList [1, 2]), (1, fromList [3, 0]), (2, fromList [3, 4]), (3, fromList [5, 3]), (4, singleton 5), (5, singleton 4)]
09:12:54 <clahey> hackrilege: Okay.
09:13:00 <hackrilege> ok
09:13:02 <clahey> So you have a graph with 3 nodes, each with a function.
09:13:05 <kurushii> so geekosaur i added a bracket before rect after the combine
09:13:10 <clahey> And a graph with 2 nodes each with a value.
09:13:12 <kurushii> statement
09:13:16 <geekosaur> ...
09:13:19 <hackrilege> ok
09:13:26 <clahey> And each of them has two directed edges.
09:13:40 <clahey> When you <*>, you get a graph with 6 nodes.
09:14:00 <kurushii> now i get parse error on ) i added after combine
09:14:05 <hackrilege> oh the cartesian product syle applicative
09:14:13 <hackrilege> no i was going for the zippy one
09:14:13 <geekosaur> you are throwing random syntax around
09:14:19 <clahey> And for each edge in the first graph, you get two edges in the combined graph and for each edge in the second graph, you get three edges in the combined graph.
09:14:42 <clahey> hackrilege: Hence " So, my <*> may be different from the one you're imagining."
09:14:58 <hackrilege> i was joking about adding the parenthesis randomly kurushii, you need to be able to understand where they go, if its too messy you should test each part on its own
09:15:13 <clahey> So, you want the intersection of the two graphs?
09:15:19 <kurushii> sorry guys need to go turn the cooker off lol will be back
09:15:19 <hackrilege> yep
09:15:42 <clahey> So, rename your type so far to Graph'.
09:16:19 <clahey> And define Graph a = Finite (Graph' a) | Everything a
09:16:39 <clahey> And then pure = Everything.
09:16:52 <hackrilege> !?
09:16:58 <hackrilege> woah thats ninja stuff
09:17:04 <hackrilege> what are you doing there?
09:17:28 <clahey> Everything f <*> Finite g' = Finite (fmap f g')
09:17:52 <clahey> Finite f' <*> Finite g' = whateverzipwiththingyou'vedefined
09:18:01 <lpaste_> geekosaur pasted “kurushii original function” at http://lpaste.net/145948
09:18:05 <clahey> Everything f <*> Everything a = Everything (f a)
09:18:10 <hackrilege> okok, hold up
09:18:14 <hackrilege> this seems perfect
09:18:21 <hackrilege> but i dont know what you are doing
09:18:36 <hackrilege> can i get a rewind?
09:18:39 <lpaste_> geekosaur annotated “kurushii original function” with “kurushii function with syntactically correct braces” at http://lpaste.net/145948#a145949
09:18:51 <clahey> So, you've defined a graph type.
09:18:51 <tobiasBora> Is it a good idea when a "variable" change often to do something like :
09:18:55 <clahey> It has nodes with values.
09:19:05 <hackrilege> ok not that far
09:19:06 <clahey> And unlabeled directed edges.
09:19:07 <geekosaur> kurushii, see http://lpaste.net/diff/145948/145949
09:19:16 <clahey> No, this is important.
09:19:19 <hackrilege> what about everything and finite. whats the principle there?
09:19:34 <hackrilege> ok i have a graph of edges and nodes stored as Data.Maps
09:19:43 <clahey> Doesn't matter how it's stored right now.
09:19:47 <hackrilege> kk
09:20:02 <clahey> Oh, and I forgot to mention, each node has a label and a value.
09:20:17 <clahey> So, imagine an infinite graph with every possible label.
09:20:17 <hackrilege> tobiasBora?
09:20:29 <clahey> And every possible edge.
09:20:37 <hackrilege> yeh, that was the pure instance we were using
09:20:42 <clahey> Exactly.\
09:20:48 <clahey> So how do you represent that in haskell?
09:20:48 <hackrilege> ok
09:21:02 <glguy> geekosaur: I think your paste is still missing a )
09:21:10 <tobiasBora> Is it a good idea when a variable (for example a Map) is often updated to store it another variable with the same name, with something like "var <- create_var (); var <- edit1 var; var <- edit2 var", or is it better to do "var1 <- create_var (); var2 <- edit1 var1; var3 <- edit2 var2"... ?
09:21:21 <hackrilege> fromList [(a,b) | a <- [1..],b<-[1..]]
09:21:24 <hackrilege> kind of thing
09:21:28 <hackrilege> for a 2d graph
09:21:30 <clahey> That's one way.
09:21:31 <hackrilege> mine is 2d
09:21:32 <tobiasBora> (or same thing with let in pure functionnal parts)
09:21:51 <clahey> That is one option.
09:21:56 <clahey> Assuming that the type is finite.
09:22:03 <Rembane> A lazy graph is another solution. Functions that return for instance which nodes a certain node is connected.
09:22:06 <hackrilege> tobiasBora, the first one
09:22:08 <clahey> However, that will take too too long.
09:22:21 <geekosaur> oh, sigh, don't trust other people's indentation...
09:22:31 <clahey> I have to go for a minute. Be right back.
09:22:39 <hackrilege> k
09:22:50 <lyxia> tobiasBora: Try to write it all as composition of functions, or use State.
09:22:55 <tobiasBora> hackrilege: Ok ! And does haskell do some modification like "I can see that var1 isn't used anymore so I can delete it ?
09:23:02 <lpaste_> glguy annotated “kurushii original function” with “trying to recover some structure” at http://lpaste.net/145948#a145950
09:23:12 <lpaste_> geekosaur revised “kurushii function with syntactically correct braces”: “kurushii function with syntactically correct braces” at http://lpaste.net/145949
09:23:25 <hackrilege> Rembane. i store the edges to the neighbouring nodes, this is executed lazily im sure
09:23:43 <tobiasBora> lyxia: The problem is that I write with differents kinds of variables, so composing functions isn't that simple...
09:24:03 <hackrilege> tobiasBora. more than that even you can use the same variable name, e.g. x, in many places, the most local scope will apply
09:24:23 <hackrilege> tobiasBora, your example actually confuses me a little since its in do notation.
09:24:37 <hackrilege> i think you should get a second oppinion, maybe the 2nd way you gave is better
09:25:22 <hackrilege> "different kinds of variables" kind is a keyword in haskell, what do you mean?
09:26:59 <clahey> hackrilege: Okay, so one option is to have a function (of 0 values, i.e. a value) allVertices = [(a,b) | a <- [1..], b<-[1..]] and then define pure a = Graph (fromList (zipWith allVertices (repeat (fromList allVertices)))) (fromList (zipWith allVertices (repeat a)))
09:27:08 <hackrilege> ug, g2g. i hope i have enough tips to make my applicative instance. still in need of more information about the monad instance
09:27:20 <hackrilege> i can stay a short while, is ok
09:27:24 <kurushii> ok i'm back tried the code from jesus christ thanks geekosaur
09:27:36 <kurushii> gonna look at the placing if the braces
09:27:38 <kurushii> of*
09:27:40 <clahey> However, presumably allVertices is huge.
09:27:43 <geekosaur> again, look at the diff link I pasted
09:27:48 <clahey> So this is a huge data structure.
09:27:50 <kurushii> i just cannot get to grips with the syntax
09:27:58 <geekosaur> shows where I inserted the parentheses
09:28:07 <tobiasBora> hackrilege: By kind I mean that I have several variables that doesn't represent the same object.
09:28:11 <clahey> So someone suggested another way to do it, which is a functional definition of our data structures.
09:28:27 <hackrilege> clahey, yeh its big, but if the thing im intersecting with is small it should be ok
09:28:45 <hackrilege> a functional definition of our data structures?
09:28:54 <clahey> hackrilege: I haven't figured that out exactly.
09:29:12 <hackrilege> hmmmm...
09:29:25 <tobiasBora> hackrilege: For example my_students could be a list of the students in a class room, my_teachers could be a list of the teachers, and sometimes I want to add peaople in my_teacher, sometimes in my_students
09:29:32 <clahey> So, using this definition of pure...
09:29:58 <clahey> Firstly, I don't know how well Map works with infinite lists.
09:31:05 <clahey> But even if it's perfect, say you have a single vertex in the thing you're intersecting with, but the single Vertex is called 10000000000, 10000000000?
09:31:12 <clahey> You have to iterate through all those other values.
09:31:18 <clahey> Here's the thing though.
09:31:33 <hackrilege> ok so Students and Teachers are a different type, you have something like data Ppls = Ppls {teachers :: [Teacher], students :: [Student]} ? is that right tobiasBora?
09:32:04 <hackrilege> yes tahts a valid criticism clahey
09:32:29 <clahey> There's only one really big value you need.
09:32:47 <clahey> You don't need any other infinite (or very large) graphs.
09:33:10 <hackrilege> so now the singleton definition looks much nicer
09:33:14 <clahey> For example, you don't need: Graph empty (fromList (zipWith allVertices allVertices)) :: Graph Vertex
09:33:46 <hackrilege> ok
09:34:10 <clahey> You only need one infinite graph.
09:34:22 <clahey> The complete graph.
09:34:28 <hackrilege> !?
09:34:51 <hackrilege> the graph im using is finite. only in pure with intersectWith was a infinite graph used
09:35:04 <clahey> Right, but you want to define pure, so we need the infinite graph.
09:35:15 <clahey> At no other time do you need an infinite graph.
09:35:18 <hackrilege> as repeat (+) is used in (+) <*> [1] <*> [2]
09:35:33 <hackrilege> yeh i follow you
09:35:37 <clahey> (+) <*> [1] <*> [2] doesn't type check.
09:35:49 <hackrilege> as repeat (+) is used in (+) <$> [1] <*> [2]
09:36:33 <clahey> Except that the Applicative definition for list is the product definition, not the intersect definition.
09:36:41 <hackrilege> we dont want to have to use an infinite graph.
09:36:49 <hackrilege> i think is what your saying
09:36:54 <clahey> Right, but we need to represent it somehow.
09:36:57 <Mitzelflick> ok so I should drop everything and learn the haskkell?
09:37:12 <hackrilege> > (+) <$> [1] <*> [2]
09:37:14 <lambdabot>  [3]
09:37:19 <kadoban> Mitzelflick: Sure, it's a quite interesting language (and useful)
09:37:19 <clahey> So, you can think of data types as being sets of values.
09:37:29 <hackrilege> > (+) <$> [1,2] <*> [2,3]
09:37:31 <lambdabot>  [3,4,4,5]
09:37:34 <hackrilege> oh i see
09:37:58 <clahey> > (+) <$> ZipList [1, 2] <*> ZipList [2,3]
09:37:59 <lambdabot>  ZipList {getZipList = [3,5]}
09:38:04 <hackrilege> like how lists are functions from the natural numbers to the ellemnts?
09:38:20 <hackrilege> ok ZipList is nice
09:38:24 <clahey> That's true, but not what I'm talking about.
09:38:31 <hackrilege> oh
09:38:49 <hackrilege> anyway, i see how datatypes are sets of values
09:38:51 <clahey> What I'm talking about is the fact that List (capital L) is the set of "functions from the natural numbers to the elements"
09:39:01 <hackrilege> thats what i said!
09:39:05 <kadoban> Mitzelflick: https://github.com/bitemyapp/learnhaskell is good advice, and http://haskellbook.com/ seems to be a good way to go if you don't mind getting a book (good idea)
09:39:17 <clahey> The important part was the "set of"
09:39:22 <clahey> I think you see it.
09:39:27 <Mitzelflick> why do java apps use things like hornetq and how does haskell solve that problem?
09:39:33 <hackrilege> kk
09:39:38 <clahey> So your Graph type is the set of finite graphs.
09:39:47 <hackrilege> what is hornetq?
09:39:58 <clahey> But you need to represent finite graphs and one single infinite graph.
09:40:14 <hackrilege> oh ok
09:40:16 <clahey> And that's what union types are for.
09:40:19 <hackrilege> aha
09:40:28 <hackrilege> so thats where finite and everything coe in
09:40:30 <hackrilege> come in
09:40:31 <hackrilege> ?
09:40:34 <clahey> Exactly.
09:40:42 <hackrilege> awesome, well explained
09:40:53 <clahey> The set of "graphs we care about" is equal to "finite graphs" union the Everything graph.
09:41:11 <clahey> I just realize there is an Everything graph for every value, so more than one infinite graph, but only a limited set of them.
09:41:26 <hackrilege> it takes a function as an argument
09:41:34 <clahey> It takes a value as an argument.
09:41:39 <clahey> That value might be a function.
09:41:43 <hackrilege> kk
09:41:50 <hackrilege> not a function that may be a value?
09:41:52 <clahey> In order to use <*>, the one on the left has to be a function.
09:41:54 <hackrilege> nvm
09:42:27 <clahey> :t <*>
09:42:28 <lambdabot> parse error on input ‘<*>’
09:42:32 <clahey> :t (<*>)
09:42:34 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:42:47 <hackrilege> an applicative of functions
09:43:01 <sleblanc> Mitzelflick, a message bus provides a nice abstraction layer between applications made out of different platforms, languages and components; Haskell has support for one of such message protocols (AMQP) https://hackage.haskell.org/package/amqp
09:43:21 <clahey> So in your case, the type of (<*>) is Graph (a -> b) -> Graph a -> Graph b.
09:43:42 <clahey> But you also have to account for a finite graph on the left and an infinite graph on the right.
09:43:46 <clahey> Or infinite on both sides.
09:43:54 <sunnymilk> what is library function to test for primality of Integer types with the fewest dependencies
09:43:54 <clahey> So that's what I was doing when I started to define <*>.
09:44:04 <hackrilege> nono the graph of functions is infinite
09:44:15 <hackrilege> its the function we are appling pure too
09:44:24 <clahey> pure doesn't have to take a function.
09:44:32 <clahey> You can do things like:
09:44:33 <hackrilege> okok
09:44:37 <clahey> pure f <*> pure a.
09:44:44 <clahey> (It must be equal to pure (f a)
09:44:52 <hackrilege> oh cool
09:45:13 <hackrilege> but yeh, even if its a data constructor its still a function of one argument
09:45:34 <hackrilege> so where was this leading?
09:45:37 <clahey> I can do (pure 0)
09:45:44 <clahey> I was saying how I would define <*>.
09:46:02 <clahey> You have to define what it does to each of the union values.
09:46:14 <clahey> So you had a definition of <*> on your finite graphs, right? What was it?
09:46:31 <hackrilege> no thats where i got stuck
09:46:40 <hackrilege> i was using singleton for pure
09:46:52 <hackrilege> then i guess i was extracting that...
09:47:12 <clahey> Put you want <*> to be the intersection, right?
09:47:21 <hackrilege> (<*>) (Graph _ f) (Graph n p) = Graph n (f (p!0))
09:47:36 <hackrilege> (<*>) (Graph _ f) (Graph n p) = Graph n (f!0 p)
09:47:37 <hackrilege> sorry
09:47:39 <clahey> Ignore pure for now.
09:47:51 <hackrilege> anyway, thats more or less what i was using
09:48:11 <clahey> Right.
09:48:18 <clahey> And pure was singleton.
09:48:22 <clahey> But that doesn't work.
09:48:33 <hackrilege> sure
09:48:36 <osa1> stack noob here, does anyone know what it is trying to say here: Failure when adding dependencies: haskell-src-exts: needed (>=1.17 && <1.18), 1.16.0.1 found (latest is 1.17.0)
09:48:41 <clahey> Let me look up the Applicative laws.
09:48:42 <osa1> does that mean the version is not in stack repos?
09:49:06 <clahey> interchange:   u <*> pure y = pure ($ y) <*> u
09:49:14 <clahey> That's one of the problems with your law.
09:49:20 <clahey> Your definition, I mean.
09:49:27 <hackrilege> yeh i see
09:49:54 <hackrilege> not symetric enough
09:49:55 <clahey> Because the left side loses all the functions other than the one at position 0 and it loses all structure.
09:50:01 <clahey> A good way to think of it.
09:50:05 <hackrilege> so we use intersectWith
09:50:16 <clahey> Right.
09:50:26 <hackrilege> i think it got defined earlyer by someone else, but it would be hard to find it was hours ago
09:51:05 <clahey> You're using maps, right?
09:51:18 <clahey> (I'm going to call it Graph' for now because I'm gonna use Graph later)
09:51:44 <hackrilege> ok
09:51:52 <hackrilege> i am using Map yes
09:53:50 <hackrilegeM> Just grabbing snacks, still online
09:53:53 <clahey> Graph' edgesF pointsF <*> Graph' edgesA pointsA = Graph' (M.intersectionWith S.intersection edgesF edgesA) (M.intersectionWith ($) pointsF pointsA)
09:55:32 <quchen> edward: Hey, did you add the "right zero" law for fail to the Wiki article? That would make IO not an instance.
09:56:40 <quchen> I just noticed it while migrating the entry from the Haskell Wiki, https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail
09:56:50 <quchen> … to the prime wiki
10:21:51 <solrize_> @pl \a b -> a ++ (show b)
10:21:51 <lambdabot> (. show) . (++)
10:22:46 <Iceland_jack> solrize_: You can define (.:) = fmap.fmap and write
10:22:46 <Iceland_jack>     show .: (++)
10:22:48 <Iceland_jack> :t let (·) = fmap.fmap in show · (++)
10:22:50 <lambdabot> Show a => [a] -> [a] -> String
10:23:22 <solrize_> cute
10:24:33 <Iceland_jack> It's just
10:24:33 <Iceland_jack>     (f .: g) x y = f (g x y)
10:24:33 <Iceland_jack> it's often nice, I would use it more often if it were in base
10:24:38 <Iceland_jack>     concatMap = concat .: map
10:25:34 <jeffrin> hello all
10:25:39 <Iceland_jack> Hey jeffrin 
10:26:26 <jeffrin> is there anything like sicp and scheme for haskell related
10:26:54 <Iceland_jack> jeffrin: There is a "Write a Sceme in 48 hours" in Haskell
10:27:11 <Iceland_jack> What is your Haskell status
10:27:32 <jeffrin> i have to started typically
10:27:40 <jeffrin> i have not started typically
10:28:20 <jeffrin> i saw a lecture from ocw.mit.edu related to lisp and sicp
10:29:27 <Iceland_jack> What do you expect to get out of Haskell material related to Lisp/Scheme
10:30:57 <jeffrin> :)
10:31:05 <vqrs> What projects could I look at to get a feel what non-toy Haskell programs look like?
10:31:46 <jeffrin> can i learn bot haskell and scheme
10:31:52 <jeffrin> can i learn both haskell and scheme
10:32:01 <jeffrin> is that possible
10:32:07 <sm> you might like http://learn.hfm.io
10:32:13 <sm> (jeffrin)
10:32:25 <Iceland_jack> it is possible jeffrin 
10:32:35 <sm> vqrs: there are a lot on hackage...
10:33:05 <Mitzelflick> possibilities are endless
10:33:07 <Iceland_jack> If you learn both at the same time it may overwhelm you with details
10:33:09 <Mitzelflick> life however is finite
10:33:19 <Mitzelflick> robots could do all the works
10:33:27 <jeffrin> Iceland_jack : which should i learn  first ?
10:33:29 <Iceland_jack> Mitzelflick: {{citation needed}}
10:34:19 <vqrs> sm: but, hackage is "all the things", no? I understand the basics, I understand typeclasses, so I'm looking for something that doesn't go all out with GHC extensions and such
10:34:58 <sm> vqrs: I'd suggest pandoc and hledger
10:34:59 <Iceland_jack> jeffrin: Both are fine. Scheme is smaller, I have issues with Lisps pedagogically but there really is no correct answer to that question so go learn Haskell.
10:34:59 <jeffrin> anyway leave it
10:36:29 <vqrs> sm: cool, thanks
10:38:59 <jeffrin> anyway thanks
10:48:07 * hackagebot SWMMoutGetMB 0.1.0.1 - A parser for SWMM 5 binary .OUT files  https://hackage.haskell.org/package/SWMMoutGetMB-0.1.0.1 (siddhanathan)
10:49:50 <kadoban> So just to check: there's no way to directly check for a cabal flag in haskell code, or CPP or anything, right? I have to add cpp-options: -DWHATEVER in the cabal file, based on the flag, and then use /that/ with the CPP extension in haskell code?
10:50:09 <sbrg> Can someone explain to me why something like: let xs = map (+1) [1..3]; seq xs (); :sprint xs   does not reduce it to WHNF unless a type signature is explicitly specified?
10:50:38 <sbrg> That is, let xs = map (+1) [1..3] :: [Int]; seq xs (); :sprint xs shows _:_, while without the type signature it is just xs = _
10:51:03 <sm> kadoban: I think you're right, and it's a bit of a pain
10:51:19 <hiptobecubic> sbrg, is OverloadedLists on?
10:51:45 <kadoban> sm: Alright, thanks.
10:54:24 <sbrg> hiptobecubic: nope.
10:55:07 <hiptobecubic> If you explicitly specify the generic type it also doesn't go to WHNF
10:55:09 <hiptobecubic> odd
10:55:39 <MarcelineVQ> http://stackoverflow.com/questions/21518584/sprint-for-polymorphic-values
10:56:34 <sbrg> aah
10:57:24 <quchen> How would you pronounce <> from Semigroup, as opposed to <> from Monoid? I can't use "mappend" because I want to refer to the semigroup specifically. sappend? :-s
10:58:13 <sbrg> quchen: surely you can just say "let sappend be <> but from semigroup" and then use that?
10:58:29 <sbrg> MarcelineVQ: thanks!
10:58:31 <quchen> sbrg: That's a bit too long for an entry in PrelNames.hs ;-)
10:58:36 <Cale> quchen: "semigroup multiplication"
10:58:49 <MarcelineVQ> sbrg: np, I just learn about that myself
10:58:56 <quchen> thenMName          = methName gHC_BASE (fsLit ">>")     thenMClassOpKey
10:59:04 <quchen> I want that line, but for Semigroup.<>
10:59:21 <quchen> semigroupMultiplicationName, hmmm
10:59:25 <Cale> lol
10:59:27 <quchen> smult maybe
10:59:42 <quchen> Ah, sappend will do, up to code review at least
10:59:46 <Cale> I thought you were asking about speaking it aloud of course ;)
10:59:48 <Cale> but yeah
10:59:52 <Cale> sappend maybe
11:18:08 * hackagebot inf-interval 0.1.0.0 - Non-contiguous interval data types with potentially infinite ranges.  https://hackage.haskell.org/package/inf-interval-0.1.0.0 (RaminHonary)
11:19:32 <jophish> Does anyone remember that chatter a while back about importing something like gists as mini-packages
11:19:43 <jophish> without having to add them to the .cabal file
11:20:09 <jophish> so you'd do something like: import some-hash (headMaybe)
11:20:31 <jophish> or have I just dreamed this up?
11:22:08 <nkaretnikov> what's the trick for making runQ work in ghci?
11:22:16 <nkaretnikov> i always forget
11:23:50 <nkaretnikov> i think i found it
11:24:05 <nkaretnikov> runQ (...) >>= putStrLn . pprint
11:25:25 <hackeilege> Sorry, dropped connection completely, I'll check the logs
11:25:47 <luite> nkaretnikov: you get a limited functionality Quasi instance then though
11:25:54 <hackeilege> Was talking about union types for handling intersections with infinite sets
11:26:09 <hackeilege> In the definition of pure for graphs
11:26:11 <nkaretnikov> luite: could you elaborate?
11:26:53 <hackeilege> Does anyone know a good resource?
11:27:32 <luite> nkaretnikov: that uses the IO instance of Quasi where you don't have name lookup and reification
11:28:09 * hackagebot minilens 0.1.0.0 - A minimalistic lens library, providing only the simplest, most basic lens functionality.  https://hackage.haskell.org/package/minilens-0.1.0.0 (RaminHonary)
11:28:27 <Guest38> haskellers, I have a lazy evaluation question
11:28:43 <Guest38> Here I'm making a map out of an infinite list:
11:28:43 <Guest38> myMap = foldr (\i m -> trace (show m) (insert i i m)) (empty) [1..]
11:28:55 <Guest38> and I trace the map as I build it
11:29:04 <Guest38> this just hangs and doesn't print anything for me
11:29:17 <Guest38> but this works fine:
11:29:17 <Guest38> myMap = foldr (\i m -> trace (show i) (insert i i m)) (empty) [1..10]
11:29:21 <nkaretnikov> luite: i'm still getting "cannot reify in the IO monad" anyway :)
11:29:28 <Guest38> why would that happen?
11:29:47 <Guest38> seems like it is hanging while trying to evaluate the map for `show`
11:31:37 <tromp__> the map is not strict in the values
11:33:09 * hackagebot rose-trie 0.1.0.0 - Provides "Data.Tree.RoseTrie": trees with polymorphic paths to nodes, combining  properties of Rose Tree data structures and Trie data structures.  https://hackage.haskell.org/package/rose-trie-0.1.0.0 (RaminHonary)
11:33:11 * hackagebot HaskRel 0.1.0.2 - HaskRel, Haskell as a DBMS with support for the relational  algebra  https://hackage.haskell.org/package/HaskRel-0.1.0.2 (thormick)
11:33:16 <monochrom> Data.Map is a finite map. not going to work if you try to stuff in infinitely many key-values
11:33:30 <chreekat> Guest38: Buffering is also a big thing. Buffering + laziness  means you can't expect a computation of an infinite value to eagerly 'trace' things to the terminal
11:33:54 <nkaretnikov> chreekat: o/
11:33:58 <monochrom> that's sounds wrong
11:33:59 <chreekat> nkaretnikov: yo :)
11:34:30 <Guest38> monochrom it does work ... `show i` shows that it is inserting values
11:34:46 <Guest38> (I'm not trying to make an infinite map, just trying things out)
11:34:48 <tromp__> try using Data.Map.Strict and you shld see some trace output
11:35:11 <chreekat> Guest38: in your  first example you were building with [1..]
11:35:23 <chreekat> I didn't even see you changed what you were 'show'ing :) That was the difference I noticed
11:35:33 <chreekat> [1..] vs  [1..10]
11:35:36 <Guest38> oops, typo on my part :)
11:35:37 <Guest38> myMap = foldr (\i m -> trace (show i) (insert i i m)) (empty) [1..]
11:35:49 <monochrom> ok I quit, since your "does work" and "doesn't work" seem to be moving targets
11:35:50 <Guest38> tromp__ Data.Map.Strict has the same behavior
11:36:20 <Guest38> does work == I want to see debug lines printed out
11:36:37 <tromp__> well color me shocked then
11:37:21 <Guest38> :D
11:37:34 <Guest38> well I'm glad I'm not the only one surprised by this behavior
11:38:09 * hackagebot hpp 0.3.0.0 - A Haskell pre-processor  https://hackage.haskell.org/package/hpp-0.3.0.0 (AnthonyCowley)
11:39:13 <chreekat> Guest38: so what was the typo   precisely? Do you use [1..10] in both cases?
11:39:25 <Guest38> No I'm using [1..] in both cases
11:42:12 <chreekat> ah, ok
11:43:09 * hackagebot minilens 0.1.0.1 - A minimalistic lens library, providing only the simplest, most basic lens functionality.  https://hackage.haskell.org/package/minilens-0.1.0.1 (RaminHonary)
11:44:13 <lyxia> Guest38: in the function you are passing to foldr, m does not have a defined value because Map only represents finite maps.
11:44:29 <johnw> I wonder how many lens alternatives we're going to end up with
11:44:30 <lyxia> Guest38: and it does not do insertion lazily
11:45:01 <lyxia> Guest38: and when you show i, the map is just there as a thunk so the computation doesn't hang.
11:45:36 <Guest38> that's weird lyxia ... I would think `m` has a defined value every time that function is called
11:45:38 <lyxia> uh
11:45:53 <lyxia> actually you force m after printing i
11:46:07 <lyxia> it doesn't
11:46:09 <monochrom> what forces m?
11:46:30 <lyxia> whatever code Guest38 has downstream I guess.
11:46:38 <lambdafan> how do I prnounce this operator (<>)?
11:46:44 <quchen> mappend
11:46:58 <monochrom> ok yeah but that's like saying "flying spaghetti monster"
11:47:00 <quchen> "monoidal append" if you feel like it
11:47:10 <KaneTW> associative operation on a monoid structure
11:47:16 <KaneTW> *ducks*
11:47:29 <quchen> "Invertible structure on a group structure"
11:48:02 <Guest38> that's the explanation that makes the most sense lyxia , thank you
11:48:10 <lambdafan> KaneTW: could I also say "associative operation on a semigroup structure"?
11:48:11 <monochrom> how does group enter? and what is being invertible?
11:48:26 <lambdafan> because it's defined in semigroup s well
11:48:46 <KaneTW> lambdafan: depends on which <> you're talking about, i guess
11:49:14 <quchen> lambdafan: Monoid is much older than Semigroup, that's why we have <> in Monoid
11:49:19 <lambdafan> KaneTW: the one from Data.Semigroup. That's why I wondered since it's defined in two places.
11:49:38 <quchen> In an ideal world we'd like to move <> to Semigroup and remove it from Monoid.
11:50:19 <KaneTW> applicative/monad/functor 2.0
11:50:25 <KaneTW> but, yes
11:50:45 <KaneTW> every lawful mappend in Monoid defines a lawful mappend in Semigroup
11:50:51 <happyfeet> hey i am trying a few things with System.Process, is there a way to run a command of the system (that opens a new window) and remain in the orginal process?
11:51:20 <quchen> KaneTW: Yes, it's pretty much the same.
11:51:43 <Guest38> happyfeet: fork?
11:51:46 <quchen> Except for the fact that we don't have Semigroup in Base right now. (It will be in 8.0 though.)
11:51:55 <KaneTW> and you can make a Monoid out of a Semigroup by adding a zero element if it exists, or introducing a new element outside of the structure as a zero element (in haskell terms, Semigroup a => Monoid (Maybe a))
11:52:00 <Guest38> https://downloads.haskell.org/~ghc/7.0.4/docs/html/libraries/unix-2.4.2.0/System-Posix-Process.html
11:52:35 <geekosaur> might ask what platform this is about first
12:04:56 <guillaum1> Hi there. Suppose I have a list :: [(a - b)] filled such as [foo, bar, baz]. I want a way to write a function :: [(a -> b)] -> String -> (a -> b) which takes a function name and returns the function with that name in the list?
12:05:32 <monochrom> can't be done.
12:06:10 <monochrom> however, [(String, a->b)] -> String -> (a->b) is doable, a simple lookup
12:06:34 <monochrom> more efficiently, use Map String (a->b). (import Data.Map)
12:07:20 <guillaum1> monochrom: yes, that's my current solution, but it is a bit boilerplate ([("foo", foo), ("bar", bar), ("baz", baz)] :: Map String (a -> b)
12:08:10 * hackagebot package-description-remote 0.1.0.0 - Fetches a 'GenericPackageDescription' from Hackage  https://hackage.haskell.org/package/package-description-remote-0.1.0.0 (yamadapc)
12:10:00 <guillaum1> monochrom: (sorry, I lost my interet connection, if you answered something else, or someoneelse, please, could you repeat?)
12:10:15 <monochrom> I said nothing more
12:10:48 <hackriledge> Weird post to log on to!
12:12:04 <hackriledge> How can i use union types to handle a pure instance of a graph which generates an infinite graph?
12:13:17 <hackriledge> Where the applicative instance definition of pure generates infinite copies of a function
12:15:19 <hackriledge> Something like data Graph a = Finite (Graph' a) | Everything (Graph a)
12:15:46 <hackriledge> Everything (Graph' a) rather
12:16:32 <hackriledge> And then to make the Applicative instance...
12:17:16 <hackriledge> over
12:17:35 <happyfeet> any1 who can help me with gloss?
12:18:25 <hackriledge> I can try happyfeet what's up?
12:21:38 <bernalex> happyfeet: not unless you ask a question.
12:23:10 * hackagebot rest-gen 0.19.0.1 - Documentation and client generation from rest definition.  https://hackage.haskell.org/package/rest-gen-0.19.0.1 (ErikHesselink)
12:25:57 <bernalex> happyfeet: if you have a question, please just ask it here, so others can benefit from it.
12:26:18 <happyfeet> so: i am trying to make a game
12:26:35 <happyfeet> currently i have this:
12:26:43 <happyfeet> 	1 - a program that moves the player inside the board in a textual way
12:26:52 <happyfeet> 2 -  a program that "reads" the temp file and shows it in a gloss window
12:27:05 <happyfeet> http://i.imgur.com/MElnzlT.png
12:27:22 <happyfeet> my problem is in "joining" this
12:27:30 <happyfeet> and make a "pretty" game
12:28:11 * hackagebot exact-real 0.12.0 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.12.0 (jophish)
12:28:13 * hackagebot package-description-remote 0.1.1.0 - Fetches a 'GenericPackageDescription' from Hackage  https://hackage.haskell.org/package/package-description-remote-0.1.1.0 (yamadapc)
12:34:07 <bernalex> hackagebot: what more specifically is the problem?
12:35:28 <geekosaur> tab-o :p
12:35:38 <bernalex> happyfeet: ^
12:37:26 <happyfeet> bernalex: http://lpaste.net/2386170846247911424 in the dots section there is more code that is irrelevant to the problem
12:37:54 <happyfeet> basically my problem is in gloss recognizing the input of keys
12:39:50 <bernalex> happyfeet: https://github.com/plaimi/blubber-client/blob/master/src-exec/blubber.hs has a very basic example, see the handle function.
12:40:35 <happyfeet> bernalex thank you :)
12:41:33 <bernalex> happyfeet: just@ ignore the chan message, and give handle to play or playIO (whichever you are using) without it.
12:41:38 <bernalex> -@
12:42:44 <bernalex> happyfeet: also, consider joining #haskell-game. people love hearing about projects and updates on them in there.
12:43:36 <happyfeet> @bernalex i will join, i did not knew about that channel :)
12:43:36 <lambdabot> Unknown command, try @list
12:48:11 * hackagebot haste-compiler 0.5.3 - Haskell To ECMAScript compiler  https://hackage.haskell.org/package/haste-compiler-0.5.3 (AntonEkblad)
12:50:03 <cabbibo> Does anyone on here do openGL stufff?
12:51:58 <bernalex> cabbibo: try #haskell-game.
12:52:19 <cabbibo> thanks bernalex
12:55:25 <cabbibo> I'll ask it here too @bernalex , just in case :)  
12:55:39 <cabbibo> I'm getting a type error that looks like : Couldn't match type ‘Int’ with ‘()’   Expected type: Ptr ()   Actual type: Ptr Int
12:55:45 <cabbibo> when trying to create a texture
12:55:56 <cabbibo> the code / full error is here: http://lpaste.net/145957
12:58:12 * hackagebot reflex-dom-contrib 0.3 - A playground for experimenting with infrastructure and common code for reflex applications  https://hackage.haskell.org/package/reflex-dom-contrib-0.3 (DougBeardsley)
13:13:12 * hackagebot matrices 0.4.3 - native matrix based on vector  https://hackage.haskell.org/package/matrices-0.4.3 (kaizhang)
13:15:17 <clahey> hackagebot: seen hackriledge
13:16:24 <clahey> guillaum1, Why do you want to look up functions by name?
13:17:55 <jophish> Does ghc optimize away redundant constraints?
13:18:04 <jophish> for example if I had (Num a, Fractional a)
13:18:34 <clahey> I thought ghc optimized away all constraints.
13:18:53 <jophish> clahey: they are implemented by passing dictionaries at runtime
13:18:56 <coventry`> I'm getting "cabal: <file descriptor: 8>: resource exhausted" when I do "cabal update".  How can I correct this?
13:19:01 <clahey> Though if you're using forall explicitly, there may be some specific cases I'm not thinking of.
13:19:07 <jophish> I'm sure it makes very little runtime difference, but I'm curious
13:19:10 <clahey> jophish, They are?
13:19:13 <bernalex> jophish: that's like saying f :: Int -> Int; f x = x; should "optimise out Int".
13:19:19 <coventry`> (Ubuntu 14.04, haskell-platform, if it matters.)
13:19:24 <bernalex> clahey: really?
13:19:45 <clahey> bernalex, I don't understand forall, so I don't know is my point.
13:20:12 <jophish> bernalex: no, If I pass (Num a, Fractional a) then the dictionary for (Num a) could be passed twice, once when I requested it, and again in the dictionary for Fractional
13:20:21 <clahey> jophish, What dictionary?
13:20:23 <bernalex> jophish: oh I see
13:20:40 <bernalex> jophish: I thought you meant Num a => a -> a but not using a Num function. :]
13:20:51 <jophish> clahey: https://www.ps.uni-saarland.de/courses/typen-ws99/class.ps.gz
13:22:11 <bernalex> jophish: TIAS?
13:22:40 <bernalex> jophish: in ghci, ":set -ddump-simpl", and see if it makes it to core.
13:22:43 <coventry`> Looks like one other person has spoken publically about this error message :)  : http://ircbrowse.net/day/haskell/2013/11/25?id=16907932&timestamp=1385351041#t1385351041
13:22:55 <bernalex> jophish: you can also dump stg and many other things, see man ghc.
13:23:20 <clahey> Reading. I will be a while.
13:23:22 <zoku> I have kind of a noob question
13:23:28 <kadoban> coventry`: Is it a pretty limited system in some way or another?
13:23:32 <zoku> I'm trying to work with Yogurt: https://hackage.haskell.org/package/Yogurt
13:23:40 <zoku> but it fails to compile on recent ghc
13:23:51 <zoku> https://hackage.haskell.org/package/Yogurt-0.4.1/src/Network/Yogurt/IO.hs
13:24:00 <zoku> ^ This file can't resolve the "catch" reference
13:24:26 <zoku> When I import catch from Control.Exception, the type checker fails
13:24:45 <coventry`> kadoban: No, it's my desktop system.  No other applications are failing with complaints of resource exhaustion.
13:25:10 <zoku> http://lpaste.net/145958
13:25:29 <geekosaur> zoku, that makes me think it's a really old package using the old exception system
13:26:17 <zoku> yea it looks pretty old geekosaur, 'UploadedSat Jun 18 20:54:29 UTC 2011'
13:26:32 <coventry`> kadoban: Ah, it was a permissions issue on /home/coventry/.cabal/packages/hackage.haskell.org/
13:26:35 <johnw> joeyh: ping
13:26:58 <kadoban> coventry`: Interesting. That's a funny error message for that.
13:27:37 <kadoban> coventry`: You might want to make an issue for it with cabal-install if you feel like it, that doesn't sound great.
13:27:41 <coventry`> Actually, I'm wrong... but it works when I run it as root, but not as myself.
13:27:41 <geekosaur> hm 2011 seems like after Control.Exception revamp
13:27:59 <coventry`> chown'ing the directory makes no difference, though.
13:28:14 <geekosaur> coventry`, that makes me wonder if you ran it as root at some point and now have to fix ownerships under ~/.cabal. still that'd be an odd error message for that
13:28:30 <zoku> geekosaur: was "catch" always in Control.Exception ? There was no import from Control.Exception to begin with
13:28:46 <geekosaur> it used to be in Prelude but that was a later change
13:28:48 <kadoban> coventry`: root probably has different limits than a normal user then, so that would explain it I guess, kind of.
13:28:52 <zoku> Ahh
13:28:55 <coventry`> geekosaur, that's what I thought, but "chown -R coventry.coventry ~/.cabal" didn't fix the problem.
13:29:03 <zoku> yeah this must be assuming it's in Prelude
13:29:12 <zoku> Is there documentation for how exceptions changed?
13:29:13 <geekosaur> types didn't change at that poiint though
13:29:30 <geekosaur> look for Control.OldException
13:29:38 <geekosaur> which might still be around on Hackage
13:31:06 <zoku> hm, not in base-4.7.0.2 (my version)
13:31:15 <zoku> it might be prudent to fix this anyhow
13:31:15 <geekosaur> no, it's no longer distributed
13:31:20 <geekosaur> that's why I said on hackage
13:31:22 <zoku> ah
13:31:38 <geekosaur> but I just remembered there was a type change, because the catch in Prelude only worked for IO exceptions
13:31:55 <clahey> jophish: I found the first reference to a dictionary.
13:31:58 <zoku> yeah, this is an IO function
13:32:06 <clahey> jophish: I figured those dictionaries existed.
13:32:26 <clahey> jophish, But I assumed they were a compile time dictionary, not a run time dictionary. I still think that, but I'll keep reading.
13:37:03 <harwiltz> Hello, does anyone have any experience with hscurses?
13:37:24 <clahey> jophish, I see. The translation does have them as explicit dictionaries. I would hope those are compiled out, but I don't know for sure.
13:38:40 <coventry`> OK, I'd run out of  space, and clearing space allowed me to run cabal update as a regular user.  So it could be that.
13:41:58 <rrika> Hello, I'd like to get into proving program equivalence, and similar stuff, but I have no idea what IRC channels to lurk in. Anyone have hints?
13:42:37 <rrika> (LEAN for example doesn't seem to have its own channel)
13:47:01 <johnw> rrika: you could use Coq to build a model of the programming environment you want to prove equivalence in, but it might get tricky depending on the target language
13:47:41 <defanor> also agda and idris. and they all have channels here
13:51:19 <rrika> johnw, defanor, I know that these languages are roughly what I need but I barely understand their concepts and much less how I'd apply them to specifically show how a C program does the same as some machine code.
13:51:37 <rrika> (I can convert both to some intermediate representation if needed)
13:52:18 <defanor> rrika: "software foundations" may be a nice starting point, it's a free coq book that outlines similar things
13:52:35 <rrika> defanor, will check out
13:54:23 <coventry`> Is it OK to ask questions here about haskell errors while building elm from source?  Compilation is failing on this line, with the complaint that it wants type "FilePath -> IO()" and is getting "FP.FilePath -> IO()".  https://github.com/elm-lang/elm-reactor/blob/master/backend/Socket.hs#L20
13:55:09 <coventry`> This looks like some silly package mismatch.  How can I figure out what's causing it and fix it?
13:55:41 <defanor> rrika: also, things like http://sel4.org/ may be worth checking
13:55:50 <rrika> defanor, this is what inspired me ;)
13:57:49 <defanor> rrika: heh. but it's also considerably harder to do that, than to write a program in coq/agda/idris, and then extract/compile it from that language – instead of writing in C and analyzing it with those
13:57:59 <coventry`> Nevermind, I think I've found the answer.  https://github.com/elm-lang/elm-platform/issues/62#issuecomment-135484211
13:59:50 <rrika> defanor, the goal is to verify that reverse engineered C code actually matches the original machine code.
14:00:08 <rrika> asm → C is rather straightforward. asm → functional language I'm not sure.
14:00:32 <rrika> at least, I don't know what to represent memory writes as.
14:02:12 <defanor> rrika: ah, right. pretty much anything that normally uses GC is tricky (if even possible) to translate into from asm
14:04:25 <defanor> though depends on what "matches" means. one can always represent memory with a list or smth
14:06:17 <kyfho> ok so with haskkell I can get 10x as much done in 1% the time?
14:15:29 <broma0> What are some strategies for isolating the side-effecting parts of a program to the most focused bit of code? I know you can use the free monad / interpreter pattern to do this, but im wondering if there are other ways
14:19:16 <johnw> type classes are another alternative, MonadSomeFunctionality
14:19:42 <dart> Hi, i have a long running application that has to run an action every second, what's the best way to keep the timer precise on osx ?
14:19:47 <johnw> Free monads give the additional freedom of reflecting on the structure of the action
14:22:40 <Cale> Or defining record types which contain various functions-producing-actions and are polymorphic in the choice of monad
14:23:07 <broma0> Cale: thats an interesting idea
14:23:11 <Cale> Like, in place of having a type class MonadState s m where get :: m s; put :: s -> m ()
14:23:30 <Cale> you can have   data StateOps s m = SO { get :: m s, put :: s -> m () }
14:24:01 <Cale> This is very similar, except for example, you can build a  StateOps s IO  record which interacts with an IORef, or a file on disk
14:24:41 <Cale> While it doesn't make sense to write an instance of MonadState s IO which does that kind of thing
14:25:56 <nkaretnikov> i have a bunch of types with ToJSON instances, which are objects.  now i put them into a record and want to construct a bigger object out of them using the already defined toJSON methods.  how do i do that in aeson?  looks like there's no painless way for that
14:26:41 <nkaretnikov> i could mappend them if Value were a monoid, but it isn't, which makes sense
14:26:53 <nkaretnikov> looks like the only way is to pattern match
14:26:59 <broma0> Cale: i've never actually tried doing it that way.. so essentially: group actions into polymorphic record types instead of into free monads 
14:28:17 <nkaretnikov> it seems i just need to get rid of the per-type instances and define a single one for the record
14:31:02 <Cale> broma0: hah, I just *really* misparsed "group actions" there
14:31:12 <Cale> https://en.wikipedia.org/wiki/Group_action
14:31:19 <Cale> But yeah
15:00:02 <athan> guyz: http://tinyurl.com/of2ee4g
15:00:11 <athan> halp
15:05:13 <Mon_Ouie> u
15:08:17 * hackagebot luthor 0.0.2 - Tools for lexing and utilizing lexemes that integrate with Parsec.  https://hackage.haskell.org/package/luthor-0.0.2 (ZankokuOkuno)
15:10:13 <magbo> Hey, people. How do you test FSM-check your code with QuickCheck?
15:10:33 <athan> magbo: FSM?
15:11:35 <magbo> Let's say, I have a ledger implementation, I want to be able to define initial state, list of transtitions, then ask QuickCheck to do a random walk for some time using legal transitions (possibly checking for postconditions on every step)
15:11:45 <magbo> (and for preconditions before the next one)
15:12:14 <magbo> then, after random walk, perform all the transitions and check if conditions are satisfied there.
15:12:22 <magbo> FSM — Finite State Machine.
15:12:33 <magbo> something along the lines what they have in Erlang with proper / statem
15:13:03 <Adeon> make a data type that enumerates possible transactions
15:13:13 <Adeon> then implement Arbitrary typeclass for it
15:13:17 * hackagebot file-modules 0.1.0.0 - Takes a Haskell source-code file and outputs the modules it  . imports. Follows links to local modules as well.  https://hackage.haskell.org/package/file-modules-0.1.0.0 (yamadapc)
15:13:19 * hackagebot luminance 0.7.1 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.7.1 (DimitriSabadie)
15:13:34 <Adeon> then quickcheck can generate random transition lists for you
15:13:42 <Adeon> is that what you were looking for?
15:13:48 <athan> magbo: What Adeon said
15:14:16 <magbo> athan: Adeon: thank you.
15:14:33 <Adeon> depending on if you want to exclude certain sequences of transaction might be more or less work
15:14:40 <Adeon> but writing Arbitrary instances is usually easy
15:14:43 <magbo> I thought that there is something frameworky around it. It's a very common use-case for property testing, I think.
15:14:54 <magbo> Yeah, I was trying that.
15:14:58 <magbo> s/trying/doing
15:15:00 <magbo> thanks!
15:15:21 <athan> :)
15:32:28 <Horforia> What is Haskell?
15:32:37 <guillaum1> monochrom: using template haskell, I was able to get what I wanted (But it was complicated ;)
15:32:43 <athan> Horforia: Awesome.
15:33:00 <Horforia> is it a language?
15:33:14 <Horforia> Do I learn it here?
15:33:28 <athan> Horforia: Yep, it's a language
15:33:38 <athan> a good place to learn it is in bitemyapp's resource:
15:33:52 <athan> @learn --?
15:33:52 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
15:33:55 <athan> hmm
15:34:03 <sunnymilk> i liked learn you a haskell a lot
15:34:43 <sunnymilk> my favorite parts are the part where you print "GAYBALLS" and the BMI calculator
15:34:54 <athan> Horforia: Check this out: https://github.com/bitemyapp/learnhaskell
15:35:17 <athan> :P
15:35:17 <Horforia> can I use Haskell to make a Text based game?
15:35:26 <lambdafan> yes you can!
15:35:28 <kadoban> Horforia: Sure
15:35:32 <lambdafan> what did you have in mind?
15:35:47 <athan> Horforia: You can use it for lots of stuff, LOTS
15:36:08 <Horforia> I want to make a text based incremental game.
15:36:37 <athan> Horforia: You should take Haskell slowly, trying to build basic skills first
15:36:46 <athan> instead of trying to tackle your game all at once
15:36:53 <Horforia> ahh
15:37:04 <athan> build on the philosophy that Haskell embodies
15:37:08 <Horforia> what language could I takle quickly, if any?
15:37:25 <athan> take some of the free courses, and read around, then you'll slowly get into a comfortable development environment
15:37:30 <athan> then you'll hit rocket speed
15:37:35 <kadoban> Horforia: Haskell is not a bad choice, you're going to need to take your time regardless of language.
15:37:49 <Horforia> shoot...
15:37:56 <kadoban> Horforia: python is a common suggestion for beginner programmers, I'd pick that or haskell.
15:38:01 <athan> Horforia: Most other languages also compromise correctness for ease of use
15:38:18 * hackagebot extract-dependencies 0.1.0.0 - Given a hackage package outputs the list of its dependencies.  https://hackage.haskell.org/package/extract-dependencies-0.1.0.0 (yamadapc)
15:38:21 <athan> which means, it won't get easy to use after a lot of coding :P
15:38:32 <athan> (but it Haskell, it is!)
15:38:36 <Horforia> The only language I'm any sort of comfortable with is html...
15:39:00 <kadoban> Horforia: That's a good start, you can have a lot of fun learning to program.
15:39:01 <athan> Horforia: If you want motivation through hands-on development, try javascript for a while
15:39:02 <Horforia> I've been told that's not a real language though
15:39:03 <Horforia> lol
15:39:08 <athan> warning, though, it's a hell
15:39:27 <kadoban> Horforia: http://haskellbook.com/ is a good way to learn for a beginner I believe, that's specifically what it's designed for
15:39:29 <athan> Horforia: Yeah, you can't "react" in any way with HTML
15:39:38 <Horforia> i've noticed...
15:39:48 <kadoban> Horforia: HTML isn't a programming language really, no. It's markup. But it's still not a bad way to kind of edge into programming.
15:39:54 <athan> now with fancy Angular / polymer, you actually can :x
15:40:38 <kadoban> I … don't really suggest javascript as a beginner lanugage, but if you really want to it's not the worst choice out there.
15:41:14 <athan> My friend thought assembly would be good for newbs trying to make websites v_v
15:41:20 <athan> I couldn't shake his tenacity
15:41:48 <Horforia> lol
15:42:32 <Horforia> alright. thanks everyone. off to try out some classes.
15:42:46 <lambdafan> Horforia: Learn Haskell now and I believe you will find other language much easier later. Whereas if you learn an imperetive language now, you'll find Haskell a little harder.
15:42:46 <Iceland_jack> athan: That's ridiculous when you can write an EDSL for generating said assembly
15:43:18 <Horforia> mmk
15:44:23 <athan> Iceland_jack: He is just curious right now I think, it's still a magic box to him
15:44:52 <sunnymilk> i have a question about haskell - on the http://haskell.org web site it says that haskell is "purely function" but in its most popular implementation, ghc, it isnt actually pure at all - there are lots of unsafe functions like unsafePerformIO that violate referential transparency (thus meaning the purity property doesnt hold) - why do they advertise it as having the purity property when all of its imple
15:44:58 <sunnymilk> mentations dont actually have it?
15:46:14 <Cale> sunnymilk: unsafePerformIO isn't something which is used in day-to-day programming
15:46:34 <sunnymilk> well sure but thats not what purity means
15:46:45 <Cale> sunnymilk: It's basically used to implement some libraries which you'd otherwise have to extend the compiler to write, and using it should be taken with the same gravity as modifying the compiler.
15:47:07 <Cale> Apart from unsafePerformIO, expression evaluation is indeed pure
15:47:17 <sunnymilk> its "for all f" not "for most f"
15:47:29 <Cale> Well, you can avoid importing that low-level hook easily
15:47:47 <hodapp> sunnymilk: the point of those functions is also generally for cases where something either *doesn't* violate referential transparency, but the compiler must trust the programmer on this, or for cases where it does so inconsequentially (e.g. for certain kinds of diagnostics and traces)
15:47:47 <Cale> and you can also apply flags during compilation which will prevent it from being imported
15:47:59 <sunnymilk> well sure *i* can just make sure all my code is pure
15:48:07 <sunnymilk> but i didnt write everything i use
15:48:16 <sunnymilk> hodapp those are social conventions
15:48:25 <sunnymilk> and are not included in the definition of purity
15:48:28 <hodapp> sunnymilk: how are those "social conventions"?
15:48:28 <Cale> sunnymilk: Sure, but the general culture is not to use unsafePerformIO unsafely
15:48:36 <guillaum1> I was wondering about the whole purpose of template haskell compared to something such as eval("string of haskell code")
15:48:38 <Cale> Everything is a social convention
15:48:49 <Cale> when it comes to programming languages generally
15:48:50 <sunnymilk> its not - if haskell was implemented according to spec, it would be pure
15:48:59 <sunnymilk> sans a compiler bug, there would be no way to have impure functions
15:49:08 <Cale> unsafePerformIO is actually part of the FFI specification
15:49:13 <sunnymilk> thus upholding the purity property: for all f, blah blah
15:49:27 <sunnymilk> oh well there you have it, not even the spec is pure!
15:49:30 <Cale> You need it occasionally when importing C code which implements a pure function, for example.
15:49:36 <hodapp> guillaum1: for one thing, with TH, you're more generating bits of the Haskell AST than you are generating strings
15:49:40 <Cale> Do you have a point, or are you just trolling?
15:50:05 <hodapp> guillaum1: and this I've found is a good deal more manageable than eval'ing strings
15:50:06 <sunnymilk> well i mean its a lie isnt it, to call it "purely functional" when the purity property doesnt hold
15:50:09 <arkeet> the spec is pure. reading the spec does not launch any missiles.
15:50:36 <Cale> I've been programming in Haskell, often (and currently) professionally for the last 14 years, and the number of times I've needed unsafePerformIO for something is like... 2?
15:50:53 <Cale> Nah, one of those was unsafeCoerce
15:50:58 <sunnymilk> im aware its not frequently used
15:51:00 <Pamelloes> arkeet: I don't know. This one time I read the spec, but fell asleep and hit my big red launchMissiles button. So....
15:51:17 <sunnymilk> but its still true that if there are counterexamples to a universal quantifier then its not true in general
15:51:31 <Cale> sunnymilk: It's not a lie if you can write the vast majority of programs in a pure way
15:52:00 <Cale> There will be exceptions to almost any universal statement you could make about a programming language.
15:52:15 <tzh> also, you can throw exceptions in "pure" code! it's a mess! but generally if you avoid writing actively malicious code the whole "bottom is a member of every type" thing doesn't come up much in practice.
15:52:21 <Cale> Unless you're talking about a very formal impractical language
15:52:36 <sunnymilk> coq is pure!
15:53:05 <hodapp> sunnymilk: Coq is only proven pure by "social convention".
15:53:06 <sunnymilk> it literally holds, sans proofs of false (eg, compiler bugs and metatheory inconsistancies)
15:53:42 <lispy> coq lets the user add axioms
15:53:51 <sunnymilk> hodapp well sure, all proofs are, or boil down to that
15:54:00 <sunnymilk> lispy you can imagine those as implicit arguments
15:54:02 <lispy> I don't really see that as different than the use case Cale already mentioned for unsafePerformIO
15:54:12 <sunnymilk> they dont change the metatheory
15:54:51 <hodapp> sunnymilk: You already dismissed something I said because it is "social convention", so it's curious that it's suddenly irrelevant now.
15:55:00 <Pamelloes> Is read the best function for converting a string like "12345" to 12345::Int64?
15:55:21 <guillaum1> Pamelloes: define "best".
15:55:33 <sunnymilk> i didnt say it was irrelevent, just that it doesnt change anything - "exists x. ~(p x)" isnt negated by "oh but we dont care about those x's"
15:55:43 <Pamelloes> guillaum1: Robust and reliable
15:55:53 <sunnymilk> so that there exist impure functions doesnt negate that purity doesnt hold, evne if they are rarely used
15:55:58 <kadoban> > read "1234a" :: Int -- Pamelloes, probably not really
15:56:00 <lambdabot>  *Exception: Prelude.read: no parse
15:56:04 <sunnymilk> the definition of purity is for all functions, not most
15:56:20 <guillaum1> Pamelloes: in this case, have a look on the Safe library using readMay.
15:56:32 <hodapp> sunnymilk: So, Coq and Haskell are both pure only by 'social convention', but that doesn't matter in Coq's case, only in Haskell's. Got it.
15:56:47 <hodapp> sunnymilk: What was your point again?
15:56:54 <Pamelloes> guillaum1: Thanks!
15:56:57 <kadoban> > readMay "1234a" :: Maybe Int
15:56:58 <lambdabot>  Nothing
15:57:01 <kadoban> Nicer
15:57:05 <hodapp> guillaum1: did that answer your TH question, by the way?
15:57:23 <sunnymilk> hodapp i think your argument is too stupid for me to follow sorry
15:57:34 <lispy> hey now
15:57:35 <guillaum1> Pamelloes: (sorrry, in fact, it is in Text.Read and it is called readMaybe)
15:57:37 <lispy> Be polite!
15:57:45 --- mode: ChanServ set +o mauke
15:57:45 --- mode: mauke set +b $a:kyfho
15:58:39 <Iceland_jack> guillaum1: it's in base
15:58:57 --- kick: kyfho was kicked by mauke (ban evasion)
15:59:04 <guillaum1> hodapp: actually no, sorry ;) For now I don't see the adventages of manipulating an AST versus writting a string, but perhaps I'll see with experience.
15:59:15 --- mode: mauke set +b *!*@209-6-212-33.c3-0.bkl-ubr1.sbo-bkl.ma.cable.rcn.com
15:59:49 <hodapp> guillaum1: Manipulating an AST, for one thing, involves a lot less error-prone boilerplate code that is only there to generate syntax.
15:59:52 <Iceland_jack> ghci> Text.Read.readMaybe "12345" :: _ Double
15:59:52 <Iceland_jack> Just 12345.0
16:00:24 <sunnymilk> it seems obvious to me that "there is a proof of purity" and "there is a social convention that people will generally probably hopefully maybe not use the functions that break purity" are not equivalent
16:00:29 <fvh> hi, guys. help me out. I'm using `postgresql-simple` and have string list ["0", "s", "a"] but first column is `bigint`, and I have conversion error. how can I make it execute? Do I really need something like heterogeneous collection?
16:00:40 <Iceland_jack> sunnymilk: Have you looked at SafeHaskell?
16:00:45 <sunnymilk> ive heard of that yeah
16:01:12 <Iceland_jack> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/safe-haskell.html
16:01:15 --- mode: mauke set -o mauke
16:01:16 <guillaum1> hodapp: I'll have to trust you on that point. The simple fact that you told me that it's less error-prone is a strong argument, thank you. (But I guess I'll have to observe that by myself ;)
16:01:26 <Iceland_jack> "Haskell offers a powerful type system and separation of pure and effectual functions through the IO monad. There are several loop holes in the type system though, the most obvious offender being the unsafePerformIO :: IO a -> a function. The safe language dialect of Safe Haskell disallows the use of such functions."
16:01:27 <hodapp> guillaum1: Would you agree that it's fairly silly to go through the work of generating proper syntax, and then to have it parsed back in again?
16:01:46 <athan> fvh: Probably not, you more than likely need to parse the string into something that already is heterogenous, like a pair
16:01:56 <Iceland_jack> "It also codifies an existing culture in the Haskell community of trying to avoid using such unsafe functions unless absolutely necessary."
16:04:08 <fvh> :athan what if i have 20 values? Updating 20 columns, are there any restrictions for Tuple type length?
16:04:10 <hodapp> guillaum1: Second, do you see that generating it by strings doesn't really *get* you anything additional over generating ASTs, since the gap between what the AST can express and what strings can express is basically just "syntax errors"? (minus a handful of things that TH possibly can't generate... not sure)
16:04:18 <sunnymilk> Iceland_jack i like that
16:04:24 <Iceland_jack> You can argue that this should be opt-out but here we are
16:04:38 <sunnymilk> i do think it should be opt-out
16:04:43 <sunnymilk> but thats a minority opinion i think
16:05:30 <cabbibo> Hey all! I had a question about storable arrays ( module Data.Array.Storable )
16:05:36 <Iceland_jack> You can still write functions that blow up or don't terminate or ...
16:05:36 <cabbibo> I am currently using it like so : storedArray <- newArray (1,1024) 0.3 :: IO (StorableArray Float)
16:05:41 <guillaum1> hodapp: the only thing I get with string versus AST is that "(5, 3)" is far more readable than TupE [LitE . IntegerL 5, LitE . IntegerL 3] for an untrained eye ;)
16:05:49 <cabbibo> but really want to be able to use an array filled with values already, 
16:05:59 <fvh> atah: I think I'll need something like TemplateHaskell
16:06:06 <sunnymilk> Iceland_jack yeah haskell would be drastically less useful if it didnt allow partial functions
16:06:10 <cabbibo> and im such a n00b I can't figure out how to pass this array in to get back a storable array
16:06:17 <hodapp> guillaum1: generally, though, if you're dealing in readable strings - why do you require TH? Why can't you just put it into your code?
16:06:28 <Welkin> sunnymilk: I get frustrated with other languages because they lack partial functions
16:06:29 <sunnymilk> but it would not i think be drastically less useful if it was pure
16:06:37 <cabbibo> like so : let arr = newArray (1,1024) 0.3   storedArray <- arr :: IO (StorableArray Float)
16:06:39 <sunnymilk> Welkin what the heck languages do you use
16:06:41 <sunnymilk> coq?
16:06:52 <cabbibo> obviously that second thing will thro an error...
16:06:53 <Welkin> sunnymilk: haskell, sometimes javascript
16:07:26 <sunnymilk> i think maybe we have a different definition of "partial function" - what definition are you using?
16:07:45 <Welkin> sunnymilk: partially applied
16:07:47 <sunnymilk> ahh
16:07:56 <Welkin> I see
16:08:00 <sunnymilk> what i am thinking of is that every function always returns a value
16:08:05 <Welkin> you mean non-total functions
16:08:11 <sunnymilk> yeah
16:08:13 <Welkin> > head []
16:08:14 <lambdabot>  *Exception: Prelude.head: empty list
16:08:16 <sunnymilk> lol
16:08:39 <sunnymilk> "well-typed programs dont go wrong" "there are partial functions in the standard library" ?????
16:08:57 <Iceland_jack> sunnymilk: That's not the "go wrong" that refers to ;)
16:09:17 <sunnymilk> well sure but they never tell you that
16:09:32 <Welkin> there are none in classy-prelude
16:09:37 <Welkin> headMay replaces head
16:09:45 <arkeet> well-typed programs don't have type errors.
16:09:52 <sunnymilk> i think haskellers should have to take a mandatory class on what guarantees you actually get out of haskell before getting their proselytization license
16:10:24 <arkeet> Welkin: sum is a partial function.
16:10:25 <E4xoi> arkeet: are you part of the tautology club in #haskell? 
16:10:25 <hodapp> guillaum1: however, IIRC, you still can use quasiquoting in TH to where you're not using strings, but you're not directly slinging AST either
16:10:39 <Welkin> > sum []
16:10:41 <lambdabot>  0
16:10:42 <hodapp> E4xoi: isn't the tautology club the tautology club though?
16:10:45 <arkeet> > sum (repeat 1)
16:10:51 <lambdabot>  mueval-core: Time limit exceeded
16:10:54 <Welkin> okay, I see
16:11:12 <Welkin> that is because + is strict
16:11:45 <guillaum1> hodapp: ok. Suppose I want to transform ["foo", "bar", "baz"] into [("foo", wrap foo), ("bar", wrap bar), ("baz", wrap baz)]. Using an string evaluation, I can write map (\name -> (name, wrap (eval name)) ["foo", "bar", "baz"]
16:12:32 <guillaum1> hodapp: with TH, I had to write (but perhaps I did it wrong) ListE (map (\name -> TupE [LitE (StringL name), AppE (VarE (mkName "wrap")) (VarE (mkName name))]) names)
16:12:48 <Iceland_jack> sunnymilk: "can't go wrong" was coined by a type theorist :) I don't think it's a stretch to talk about referential transparency without blurting out the same old disclaimer every time and you never know when you're talking to someone who doesn't understand the caveats
16:13:03 <guillaum1> hodapp: and call that in another module using $()
16:13:50 <Iceland_jack> Especially when we have SafeHaskell and the caveats really aren't that significant for your usual Haskell code
16:13:52 <pavonia> guillaum1: That ListE sounds wrong
16:14:49 <lispy> Welkin: To be even more pedantic, (+) isn't strict, but the implementation for Int is
16:14:53 <Cale> sunnymilk: Well typed programs don't go wrong in very specific ways.
16:15:03 <anks> how can i use Parser Alternative instance if parsers are wrapped in StateT ?
16:15:04 <hodapp> guillaum1: to be clear, writing an AST still often has some syntactical overhead.
16:15:13 <hodapp> guillaum1: so I didn't mean that it's automatically shorter.
16:17:20 <guillaum1> hodapp: (that's the point of my question/discussion, I was trying to find the adventages.)
16:17:50 <guillaum1> pavonia: do you have a solution without the ListE ? 
16:18:42 <hodapp> guillaum1: brevity is likely not an advantage, depending on what you're doing - but I do consider the statically-typed AST to be an advantage.
16:21:41 <guillaum1> hodapp: do you have a example where it is an advantage ?
16:21:49 <sunnymilk> Cale specifically, they dont get type errors, and you can encode useful information in the type system ,making this useful
16:22:29 <sunnymilk> however many haskellites dont seem to realize this and go around spewing garbage about how haskell's type system will prevent all sorts of bugs
16:22:46 <Cale> sunnymilk: Right. I don't consider it a huge failing of Haskell's type system that nontermination is possible. It's possible to do without that, but it's a reasonable compromise in the design space.
16:23:02 <Cale> It does prevent a *lot* of bugs!
16:23:03 <pavonia> guillaum1: Err, sorry, I think I misunderstood your code
16:23:40 * hackagebot pipes-csv 1.4.3 - Fast, streaming csv parser  https://hackage.haskell.org/package/pipes-csv-1.4.3 (WilliamCasarin)
16:24:34 <Welkin> isn't that Godel's incompleteness theorem?
16:25:56 <sunnymilk> Cale of course, thats not really something im worried about
16:26:14 <Cale> sunnymilk: What *are* you worried about?
16:26:26 <Welkin> "spewing garbage"? lol
16:26:29 <Cale> sunnymilk: It's possible to make the type system more expressive.
16:26:34 <sunnymilk> bogus claims about haskell superiority
16:26:46 <Welkin> sunnymilk: well, I have not found anything better that is as practical
16:26:46 <sunnymilk> i like haskell and i think its great and more people should use it
16:26:48 <Cale> sunnymilk: Superiority in this setting doesn't require very much :P
16:26:53 <sunnymilk> lol
16:26:59 <sunnymilk> i just think we should be honest
16:26:59 <Cale> sunnymilk: Most programming languages' type systems are trash
16:27:15 <Cale> At least, among the programming languages which are very popular
16:27:21 <sunnymilk> i dont really consider dynamic typing to be a type system at all (except a trivial one)
16:27:30 <sunnymilk> the "everything inside the same type" type system
16:27:53 <orb_> sunnymilk: `dynamic type systems' (rather runtime tagging systems) are still better than weak / none.
16:27:57 <sunnymilk> you dont get preservation so you dont actually have type safety
16:28:03 <orb_> But it's orthogonal to static typing.
16:28:14 <Cale> So I think it's not wrong to claim that Haskell's type system is far superior to those of the typed languages that most people use.
16:28:20 <guillaum1> sunnymilk: (As a python and c++ developer, I rather prefer dynamic typing with strict types, such as python, versus static typying with implicing convertibles types such as c++ ;)
16:28:43 <Cale> It's not as powerful or expressive a type language as exists
16:28:45 <orb_> guillaum1: python ain't very strict in their typing.  They use ducks after all.
16:29:01 <sunnymilk> Cale that is a subjective claim, the claim that "well-typed programs dont get runtime crashes" and "all haskell functions are pure" are objective claims and also false
16:29:05 <Cale> But the better type systems are all in less practical or at least less mature languages.
16:29:05 <Welkin> sunnymilk: I think you should be more worried about all the google drones preaching the good word of their lord and savior, and the gift bestowed upon them known as "golang"
16:29:20 <sunnymilk> i tried to learn go and i couldnt figure out why it was popular
16:29:21 <Welkin> "it's like haskell, but you don't need to learn anything!"
16:29:27 <orb_> The antidote to golang is Rust, ain't it?
16:29:27 <guillaum1> orb_: yes, but, except "forced", a float stays a float and does not become a matrix by the way of an implicit rule of conversion ;)
16:29:29 <Cale> Who says that well typed haskell programs don't get runtime crashes?
16:29:34 <orb_> (And Rust is Haskell in C clothing..)
16:29:37 <Cale> That's just clearly wrong.
16:29:42 <Welkin> best quote from an actual essays published in wired
16:29:42 <sunnymilk> Cale many people think that is what "dont go wrong" means
16:29:53 <orb_> guillaum1: sure.
16:30:10 <Cale> Well-typed programs avoid many specific sorts of crashing at runtime.
16:30:16 <orb_> Welkin: Wired ain't the most reputable source anyway.
16:30:35 <Welkin> with haskell, as soon as I get the types to fit together, it works
16:30:46 <Welkin> in other languages, I have no idea what the problem is and spend hours debugging
16:31:11 <Cale> Yeah, there is a surprising extent to which Welkin's feeling here is actually true
16:31:17 <Cale> It's obviously not absolutely true
16:31:17 <hodapp> sunnymilk: I have a feeling that the generalization you're making about "Haskellites" probably boils down to an experience that was basically, "This one time I heard this one person say something about Haskell that I didn't think was true."
16:31:26 <Cale> But *often* when things typecheck they also work
16:31:55 <sunnymilk> hodapp i have a feeling that you are wrong and dont have a clue what my experiences are
16:32:27 <Iceland_jack> Let's assume good faith
16:32:33 <guillaum1> Welkin: I'm still an inexperimented haskell developer, I agree with you on the fact that "most of the time" when it typechecks, stuff are close to ok. But when they are not ok, I find haskell really difficult to debug. Mainly because I still cannot wrap my head around the ghc debugger.
16:32:36 <monochrom> Haskell makes a practical concession and allows you to abort early, so you see a way to crash. But even if you remove that to get a well-typed language, Turing-completeness will still mean that you're trading crashes for infinite loops.
16:32:42 <orb_> hodapp: it is a common attitude, though.
16:32:44 <sunnymilk> Iceland_jack tell that to hodapp 
16:32:44 <Welkin> sunnymilk: you seem impassioned about this topic
16:32:51 <Iceland_jack> hodapp: Let's assume good faith
16:32:59 <sunnymilk> :-)
16:33:02 <Welkin> is it because of existential angst?
16:33:14 <sunnymilk> universal angst i am afraid
16:33:18 <sunnymilk> just kidding
16:33:18 <Iceland_jack>     data EA where
16:33:18 <Iceland_jack>       MkEA :: Angst a => a -> EA
16:33:23 <orb_> monochrom: that's why Turing completeness should be treated the same way as unsafePerformIO.
16:33:40 <orb_> Most of the time, Turing complete is too flexible.
16:33:40 * hackagebot GLUtil 0.8.8 - Miscellaneous OpenGL utilities.  https://hackage.haskell.org/package/GLUtil-0.8.8 (AnthonyCowley)
16:34:08 <monochrom> I don't go that far, but I see your flexibility point.
16:34:23 <orb_> use the weakest mechanism possible to express your program.
16:34:27 <monochrom> so how about this...
16:34:32 <orb_> fmap before fold.
16:34:35 <orb_> Etc.
16:34:41 <monochrom> Haskell makes a practical concession and give you Turing-completeness XD
16:36:10 <Cale> guillaum1: The best way to debug Haskell programs is often not to attempt to use any sort of debugger
16:36:18 <pavonia> Would there be practical implications if you'd give up Turing-completeness in Haskell, i.e. would there be a set of programs you couldn't write anymore?
16:36:23 <monochrom> on odd number days I feel that "well-typed programs don't crash, they just may hang" is better than "they may crash"
16:36:32 <Cale> guillaum1: Instead, pull them apart into smaller pieces, and inspect and test those pieces independently from one another.
16:36:37 <hodapp> pavonia: Have you read the paper, "Total Functional Programming"?
16:36:43 <orb_> Cale: that's partially because the tools for debugging are bad.
16:36:50 <monochrom> on even number days, I feel "that's just pot vs kettle"
16:36:51 <hodapp> pavonia: It explores this question a bit with a rather Haskell-like (albeit hypothetical) language
16:37:03 <pavonia> hodapp: I haven't
16:37:12 <hodapp> pavonia: Give it a look. D. A. Turner is the author, I think?
16:37:12 <Cale> orb_: Maybe partially, but also because you can rely on expressions evaluating to the same thing in isolation as they do in the real program
16:37:15 <hodapp> It's not a long read.
16:37:24 <pavonia> Okay, thanks
16:37:34 <orb_> I used to use hat (haskell tracer) a long time ago.
16:37:41 <hodapp> huh, never heard of hat
16:37:43 <orb_> (It no longer works.)
16:37:48 <orb_> Bitrotted.
16:37:53 <orb_> Was pretty awesome.
16:37:56 <Cale> Yeah, things like hat are pretty cool, especially as learning and teaching tools
16:38:05 <Cale> I wish someone would bother to maintain hat :)
16:38:22 <hodapp> I only used things like Debug.Trace maybe once.
16:38:34 <Cale> Actually, it did get updated not *too* long ago
16:38:51 <Cale> But it's the sort of tool which needs constant attention
16:38:59 <orb_> I used Debug.Trace quite often when working professionally with Haskell.
16:39:06 <orb_> Cale, cool.
16:39:26 <hodapp> orb_: I worked professionally with Haskell as well, but in a capacity where Haskell-runtime was sort of not nearly as relevant, if that makes any sense
16:39:37 <hodapp> as I was mainly using Haskell as a compiler via Ivory and other stuff
16:39:51 <orb_> hodapp: Last time, with Standard Chartered Haskell-lookalike.
16:39:52 <hodapp> so that's probably part of why I had little use for Debug.Trace
16:40:00 <hodapp> orb_: oh, Mu or whatever?
16:40:05 <orb_> Yeah.
16:40:13 <hodapp> The elusive dialect I know nothing about :P
16:40:21 <hodapp> except Neil Mitchell's one or two posts
16:40:28 <orb_> QuickCheck with good properties and shrink is way superior to printf-debugging.
16:40:36 <hodapp> I need to learn to use QuickCheck.
16:40:45 <Cale> orb_: have you tried the hat which is on hackage lately?
16:40:48 <orb_> QuickCheck is the best thing since forever.
16:40:52 <Cale> orb_: I'm trying to build it right now
16:40:59 <orb_> Cale: haven't used hat in ages.  No.
16:41:07 <Cale> cabal install hat
16:41:46 <orb_> cale, use stack!
16:41:51 <Cale> Should I?
16:41:56 <hodapp> yes.
16:42:01 <orb_> I recently started.  It's great.
16:42:08 <guillaum1> orb_: quickcheck is a really great tool. But sometime it is difficult to find good properties ;(
16:42:38 <orb_> It's easy to convert your projects from old cabal to stack.  They have tooling for it.
16:42:47 <Cale> Well, unit tests are a limiting case of quickcheck tests :)
16:42:50 <orb_> guillaum1: yes.  But you get better.  And, funny enough,
16:43:03 <orb_> even crappy properties catch a lot of stupid errors.
16:43:17 <orb_> (Mostly because they just exercise your API.)
16:43:29 <Cale> But yeah, figuring out what the properties you want to test are can require lots of thinking -- but at least it's a valuable sort of thinking
16:43:44 <orb_> Cale, also making your API have good properties is good design.
16:43:58 <Cale> If you can find a way to arrange your libraries so that there *are* nice properties to test, yeah, you're probably on to something
16:44:04 <orb_> It's like these claims that Test-driven development improves your APIs turned up to 11.
16:44:15 <Iceland_jack> guillaum1: Testing is not just for completed functions, a *very* common use of QuickCheck for me is to verify refactoring
16:44:52 <nappyheadedscien> Hey guys! I'm getting this compiler error that I don't know how to handle. I'm trying to make Integer an instance of the class "Mutable"
16:44:54 <Welkin> orb_: tdd is a cult
16:44:55 <Iceland_jack> I have 'oldFoo' and refactor into 'foo', then I simply run 'quickCheck (\a b -> oldFoo a b == foo a b)
16:45:05 <nappyheadedscien> Mutation.hs:43:31:     Couldn't match type `Value' with `Integer'     Expected type: AList Integer Integer       Actual type: Memory     In the first argument of `lookupA', namely `mem'     In the expression: lookupA mem key     In an equation for `get': get mem (P key) = lookupA mem key Failed, modules loaded: AList.here is the error: 
16:45:06 <Iceland_jack> '
16:45:14 <hodapp> Welkin: a cult?! how?
16:45:23 <guillaum1> orb_: I totally agree with you. but unfortunately some domains are more difficult to test than others. I'm writting monte carlo sampling function every day so I have mostly function Float from N dimensions to Float from N dimensions, and they are difficult to test ;)
16:45:27 <orb_> Haskell is a cult, too.
16:45:37 <hodapp> occult*
16:45:40 <Iceland_jack> nappyheadedscien: paste the code on lpaste
16:45:40 <Iceland_jack> @where lpaste
16:45:40 <lambdabot> http://lpaste.net/
16:45:51 <nappyheadedscien> ok hold on
16:46:04 <Iceland_jack> to what
16:46:23 <orb_> guillaum1: yes, some are more difficult to test.  I bet I could find some good properties, though.
16:46:24 <nappyheadedscien> http://lpaste.net/145973
16:46:35 <nappyheadedscien> that's Mutation.hs
16:46:51 <guillaum1> Iceland_jack: nice usage of quickcheck, indeed.
16:47:07 <nappyheadedscien> AList.hs : http://lpaste.net/145974
16:47:31 <hodapp> orb_: is there any sort of publicly-available information about Mu Haskell besides the one or two references I see online about it?
16:47:58 <guillaum1> Iceland_jack: but usually, refactoring of stuffs involving floating point leads to subtiles differences which does not satisfy equality between oldFoo and newFoo ;(
16:47:59 <orb_> hodapp: there's some stuff available online, some talks.
16:48:02 <nappyheadedscien> @Iceland_jack there it is
16:48:02 <lambdabot> Unknown command, try @list
16:48:24 <orb_> guillaum1: that's a property you want to test.
16:48:45 <hodapp> orb_: ah, I've just never been able to find much of anything
16:49:29 <orb_> hodapp: it's actually not all that interesting.  You are better off using ghc.
16:49:39 <hodapp> orb_: hah, fair enough :)
16:49:49 <orb_> hodapp: there were just some historical internal reasons for Standard Chartered to not use ghc there.
16:50:08 <orb_> hodapp: the main takeaway from Mu for the general public is:
16:50:21 <hodapp> I was curious, given the recent GHC commits that also enable Strict Haskell
16:50:39 <orb_> Haskell does work really well to express your programs, even as a strict-by-default language and without recursion.
16:50:52 <sm> hmm, what's a good way to take a fairly evenly-distributed sampling of a list of items, eg every hundredth one ?
16:50:54 <hodapp> no recursion?
16:51:20 <orb_> (Mu works on a VM somewhat similar to the JVM, in the sense that Mu has the same restrictions about recursion as eg Clojure battles with.
16:51:27 <hodapp> oh, huh
16:51:28 <orb_> Recursion is disabled-by-default in Mu.
16:51:42 <orb_> You can enable it with a LANGUAGE-pragma.  But performance sucks.
16:52:13 <orb_> But---it doesn't make a difference.  Well written Haskell code uses combinators.
16:52:57 <guillaum1> sm: you want one item every 100 in a list ?
16:53:05 <orb_> (In Mu's case the combinators are implemented imperatively via loops on a lower level.  But the user of fold and fmap doesn't have to now about these internals ever.)
16:53:19 <Iceland_jack> nappyheadedscien: 'lookupA mem' returns a Value, not an Integer
16:53:36 <Iceland_jack> nappyheadedscien: but the type of 'get' is
16:53:36 <Iceland_jack>     get :: Memory -> Pointer Integer -> Integer
16:54:39 <Iceland_jack> nappyheadedscien: You can write
16:54:39 <Iceland_jack>     get mem (P key) = case lookupA mem key of
16:54:39 <Iceland_jack>       IntVal  i -> i
16:54:39 <Iceland_jack>       BoolVal b -> ???
16:54:39 <nappyheadedscien> @Icelandjack OOOOHHoohhhh
16:54:39 <lambdabot> Unknown command, try @list
16:55:07 <Iceland_jack> nappyheadedscien: Don't use '@' to reference people, prefer 'nick: '
16:55:28 <Iceland_jack> Otherwise lambdabot gets twitchy
16:55:38 <nappyheadedscien> Iceland_jack: ok the prof said you pattern match on the result
16:55:43 <orb_> Because lambdabots sensibilities predate the twitter generation.
16:55:53 <nappyheadedscien> Iceland_jack: like this?
16:56:01 <orb_> nappyheadedscien: exactly.
16:57:11 <nappyheadedscien> orb_: thanks
16:57:32 <guillaum1> (Thank you for the interesting discussions, time to sleep for me)
16:57:57 <Iceland_jack> nappyheadedscien: this will work just fine
16:57:57 <Iceland_jack>     >>> get [(4, IntVal 1928)] 4
16:57:57 <Iceland_jack>     1928
16:58:20 <Iceland_jack> But this will crash
16:58:21 <Iceland_jack>     >>> get [(4, BoolVal False)] 4
16:58:21 <Iceland_jack>     ***BOOM***
16:58:57 <nappyheadedscien> Iceland_jack: would making bool an instance of mutable solve it?
16:59:06 <Iceland_jack> No, then you'd have the opposite problem
16:59:46 <nappyheadedscien> Iceland_jack: oh no for the BoolVal case I'm supposed to return an error
16:59:51 <Iceland_jack> Okay
17:00:02 <Iceland_jack> Would you like feedback on the AList code?
17:00:08 <nappyheadedscien> Iceland_jack: Ok, thank you so much!
17:00:13 <nappyheadedscien> Iceland_jack: yes please?
17:00:45 <Iceland_jack> I guess you're not allowed to use existing functions, like 
17:00:46 <Iceland_jack> :t lookup
17:00:50 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
17:01:08 <sm> guillaum1: yep. Pretty simple I guess
17:01:31 <nappyheadedscien> Iceland_jack: I asked, we are
17:02:00 <Iceland_jack> Okay let's look at the filter function, in isolation
17:02:01 <Iceland_jack> > filter (\x -> fst x == "hi") [("hi", 5), ("bye", 10)]
17:02:03 <lambdabot>  [("hi",5)]
17:02:08 <Iceland_jack> You're doing something like this, essentially
17:02:46 <nappyheadedscien> Iceland_jack: yes, that looks about right
17:02:53 <Iceland_jack> Instead of 'fst' you can pattern match
17:02:54 <Iceland_jack> > filter (\(x, _) -> x == "hi") [("hi", 5), ("bye", 10)]
17:02:56 <lambdabot>  [("hi",5)]
17:03:27 <nappyheadedscien> Iceland_jack: Oh I see, much cleaner. The use of fst and snd always bothered me
17:03:35 <Iceland_jack> You can go further
17:03:45 <Iceland_jack> Let's set it up as a list comprehension
17:03:46 <Iceland_jack> > [ val | (key, val) <- [("hi", 5), ("bye", 10)] ]
17:03:47 <lambdabot>  [5,10]
17:04:07 <Iceland_jack> If you only want keys that match "hi" 
17:04:07 <Iceland_jack> > [ val | ("hi", val) <- [("hi", 5), ("bye", 10)] ]
17:04:09 <lambdabot>  [5]
17:04:27 <Iceland_jack> But then you've 'hardcoded' the key, so you'd rather use a guard
17:04:27 <Iceland_jack> > [ val | (key, val) <- [("hi", 5), ("bye", 10)], key == "hi" ]
17:04:29 <lambdabot>  [5]
17:05:38 <Iceland_jack> So if you wanted that approach, you can define lookupA as
17:05:38 <Iceland_jack>     lookupA alist thekey = head [ val | (key, val) <- alist, key == thekey ]
17:06:17 <Iceland_jack> Which is what 'lookup' provides
17:06:17 <Iceland_jack> > lookup "hi" [("hi", 5), ("bye", 10)]
17:06:19 <lambdabot>  Just 5
17:06:39 <Iceland_jack> Only it returns 'Maybe' in case the key isn't there
17:06:39 <Iceland_jack> > lookup "bogus" [("hi", 5), ("bye", 10)]
17:06:41 <lambdabot>  Nothing
17:07:25 <Iceland_jack> I see you're using 'lookup' in the definition of 'insertA'
17:08:21 <nappyheadedscien> Iceland_jack: Yes it returns a Maybe a
17:08:28 <nappyheadedscien> which I don't like
17:08:35 <Iceland_jack> Would you prefer it crashed?
17:09:12 <nappyheadedscien> Iceland_jack: Not familiar with the term crashed
17:09:35 <Welkin> > head [] -- nappyheadedscien 
17:09:36 <lambdabot>  *Exception: Prelude.head: empty list
17:10:17 <Iceland_jack> nappyheadedscien: Look at "drop"
17:10:30 <Iceland_jack> you can also look at 'splitAt' from Data.List
17:10:34 <Iceland_jack> > splitAt 5 "hello world"
17:10:37 <lambdabot>  ("hello"," world")
17:11:05 <Iceland_jack> > drop 5 "hello world"
17:11:07 <lambdabot>  " world"
17:11:17 <Iceland_jack> Those might be useful for updateA
17:11:28 <nappyheadedscien> Iceland_jack: essentially like 'tail' iterated
17:11:45 <nappyheadedscien> Iceland_jack: I'll check those out
17:11:51 <Iceland_jack> Yes, only it doesn't crash and is more legible and also more efficient
17:11:55 <Iceland_jack> > drop 10 "hello"
17:11:57 <lambdabot>  ""
17:12:07 <Iceland_jack> > iterate tail "hello" !! 10
17:12:09 <lambdabot>  "*Exception: Prelude.tail: empty list
17:12:21 <justin_smith> when I go to wiki.haskell.org code examples with primes in binding names (a' etc.) break the syntax highlighting - is there a known way to avoid this?
17:12:37 <justin_smith> I mean I can copy/paste into my editor but that's tedious
17:13:27 <nappyheadedscien> Iceland_jack: Oh I see that would be useful in updateA
17:14:08 <Iceland_jack> nappyheadedscien: Although it's not functionally necessary I suggest you add a single pragme
17:14:10 <Iceland_jack> *pragma
17:14:21 <Iceland_jack> It's called InstanceSigs and you enable it by placing {-# LANGUAGE InstanceSigs #-} at the top of your source file or by entering the following into GHCi:
17:14:22 <Iceland_jack>     ghci> :set -XInstanceSigs
17:14:43 <Iceland_jack> nappyheadedscien: That way you can write down the types for methods like get/set/def
17:15:50 <Iceland_jack> So before you write any code you write
17:15:50 <Iceland_jack>     instance Mutable Integer where
17:15:50 <Iceland_jack>       get :: Memory -> Pointer Integer -> Integer
17:15:50 <Iceland_jack>       get = undefined
17:15:53 <Iceland_jack>       set :: Memory -> Pointer Integer -> Integer -> Memory
17:15:56 <Iceland_jack>       def :: Memory -> Integer -> Integer -> (Pointer Integer, Memory)
17:16:44 <Iceland_jack> It helps me when writing type class instances for the same reason as usual, being more explicit about the types you're working with
17:16:52 <nappyheadedscien> Iceland_jack: That would definitely make this project smoother, I find myself parsing the text with my eyes
17:16:59 <nappyheadedscien> exactly I agree
17:17:15 <Iceland_jack> nappyheadedscien: the 'undefined' “trick” is very nice if you aren't aware
17:17:48 <Iceland_jack> You can use it to incrementally type-check your program, leaving some holes ('undefined's) to be filled in as it suits you
17:17:59 <nappyheadedscien> Iceland_jack: It's usually used as a placeholder so it compiles I believe
17:18:18 <Iceland_jack> Yes, it's the first thing I use when something doesn't compile
17:18:42 * hackagebot stack-run-auto 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/stack-run-auto-0.1.0.0 (yamadapc)
17:19:10 <nappyheadedscien> Iceland_jack: OK, I'll try that out as well
17:19:12 <Iceland_jack> this is how I debugged your problem for example
17:19:12 <Iceland_jack>     get mem (P key) = undefined
17:19:12 <Iceland_jack>     get mem (P key) = lookupA undefined undefined
17:19:12 <Iceland_jack> and it still crashed, then 'lookupA' probably returns something of the wrong type
17:21:09 <nappyheadedscien> Iceland_jack: I was fixated on the compiler error message, I thought the issue was with the association list (memory) argument
17:23:34 <nappyheadedscien> Iceland_jack: thank you again
17:25:18 <Iceland_jack> That's why I perform a sort of back-and-forth binary search by replacing leaves of expressions with "undefined", if I have a big expression that fails and I'm too lazy to look at the types^W^W^W^Wthink I just write
17:25:18 <Iceland_jack> [:(] [original]           foobar 5 ('a':xs) = f (g xs) (h 'a' (j 'u'))
17:25:18 <Iceland_jack> [:)] [remove everything]  foobar            = undefined
17:25:18 <Iceland_jack> [:)] [add arguments]      foobar 5 ('a':xs) = undefined
17:25:23 <Iceland_jack> [:)] [add f]              foobar 5 ('a':xs) = f undefined undefined
17:25:26 <Iceland_jack> [:(] [add g]              foobar 5 ('a':xs) = f (g undefined) undefined
17:25:27 <Iceland_jack>     ooh, "g" must the the error
17:25:30 <Iceland_jack>  
17:25:37 <Iceland_jack> nappyheadedscien: where "[:(]" means the code to the right doesn't typecheck and "[:)]" means it does
17:26:11 <Iceland_jack> I'm done spamming the channel :)
17:29:59 <nappyheadedscien> Iceland_jack: Got it :)
17:43:44 * hackagebot STL 0.3.0.3 - STL 3D geometry format parsing and pretty-printing  https://hackage.haskell.org/package/STL-0.3.0.3 (bergey)
17:58:44 <rpfun> yesterday i asked how I could possibly make this haskell code: http://lpaste.net/2660920243475447808 run as fast as this equivalent python code: http://lpaste.net/5262323772215525376 (these are prime number sieves, faster than others I have tried written in haskell). Right now there is about a 20% discrepancy between the two, and I was wondering if anyone had ideas, even big-picture, how the haskell code could be made to run as fast?
17:59:14 <rpfun> i tried implementing a custom bitvector (from a vector of Word8's), and while that helped on memory it made running time much worse
18:03:17 <justin_smith> rpfun: I'm no expert, but for one thing you could look for something similar to numpy
18:04:08 <rpfun> justin_smith: the main use of numpy in that code is what is purported to be provided by "vector"
18:04:21 <rpfun> just fast, mutable arrays
18:04:39 <justin_smith> OK
18:06:30 <rpfun> justin_smith: of course, if you have some suggestion for an improved array i would definitely be interested, it just seems that vector is the best library at the moment
18:06:39 <justin_smith> rpfun: from my reading, there's no promise that the vectors are arrays, just that they are unboxed. There are vector implementations that are not nearly as linear and compact as arrays (given the expected feature of vectors that they can be resized)
18:07:04 <justin_smith> I don't know this implementation so I don't know whether that's a concern here or not
18:08:01 <justin_smith> rpfun: might be worth trying Data.Array.Unboxed though
18:08:23 <rpfun> justin_smith: if you look at the code I am :)
18:08:32 <justin_smith> oh, n/m then hah
18:08:38 <rpfun> oh sorry, Data.Array, not Data.Vector
18:11:22 <justin_smith> rpfun: yeah, looking at Data.Vector more, I see O(n) prepend, O(n) append, O(m+n) concat, which actually makes me think this isn't a hashed immutable vector (the kind you use for fast resizes), which would make my concern mute
18:11:34 <justin_smith> *moot
18:12:08 <rpfun> justin_smith: i am using mutable vectors in the algorithm itself, and simply return an immutable vector at the end
18:12:54 <justin_smith> rpfun: emphasis was on the "hashed" part above (I know them better in clojure, in clojure the vector is actually backed by a tree of arrays)
18:13:22 <justin_smith> which allows efficient slicing and growing and combining, but clearly is not linear like a real array
18:13:56 <justin_smith> anyway, I am sure there is someone else here more qualified to help you with this, best of luck
18:14:11 <rpfun> justin_smith: thanks!
18:27:32 <Guest67602> hello
18:28:19 <dldl> I'm trying to make a secret santa partner generator
18:28:47 * hackagebot time-locale-compat 0.1.1.1 - Compatibility of TimeLocale between old-locale and time-1.5  https://hackage.haskell.org/package/time-locale-compat-0.1.1.1 (KeiHibino)
18:28:51 <dldl> It was pretty easy using [ (x,y) | x<-names , y<-names, not (x==y) ]
18:29:04 <dldl> but this seems similar to the True/False permutations problem
18:29:19 <dldl> should I be able to do this with replicate / sequence?
18:29:21 <orb_> dldl: you want to find a random permutation?
18:29:36 <dldl> I was going to d a !! rand on the results
18:29:53 <orb_> If you have more than, say, 10 people, that will be crazy inefficient.
18:30:08 <dldl> really?
18:30:11 <dldl> I can see that
18:30:19 <dldl> but isn't this a np problem?
18:30:26 <orb_> http://apfelmus.nfshost.com/articles/random-permutations.html
18:30:34 <dldl> thanks
18:30:45 <orb_> dldl: strictly speaking, it's an NP problem.  But that's because P is contained in NP. ;)
18:31:33 <orb_> Shuffling a list is in some sense the inverse problem of sorting a list.
18:32:10 <orb_> Can be done in O(n log n) random bits, and in O(n) operations (if you can generate a random number in constant time).
18:32:23 <dldl> I need to take the list, and match it with another element in that list, without matching it to itself
18:32:27 <dldl> in a random manner
18:32:36 <dldl> i figured this works too:
18:33:02 <dldl> @sequence (replicate ["dldl","orb_","linus"])
18:33:02 <lambdabot>  Sequence not found.
18:33:12 <dldl> > sequence (replicate ["dldl","orb_","linus"])
18:33:14 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘[[Char]]’
18:33:14 <lambdabot>      In the first argument of ‘replicate’, namely
18:33:14 <lambdabot>        ‘["dldl", "orb_", "linus"]’
18:33:26 <dldl> > sequence (replicate 2 ["dldl","orb_","linus"])
18:33:28 <lambdabot>  [["dldl","dldl"],["dldl","orb_"],["dldl","linus"],["orb_","dldl"],["orb_","o...
18:33:36 <orb_> dldl: zip originalList shuffledList
18:33:38 <dldl> that kind of works, but again, seems inefficent
18:33:48 <orb_> if anyone got themselves, try again.
18:33:52 <dldl> oh... thats a pretty good idea
18:34:20 <orb_> (There's a beautiful little theorem that says that the probability of having to reshuffle because someone got themselves is around 1-1/e.
18:34:32 <orb_> Where e = 2.71...)
18:34:40 <orb_> That means, around 30%, I think.
18:34:48 <orb_> So you don't have to reshuffle too often on average.
18:35:23 <orb_> You get the shuffled list by using the shuffle method from Apfelmus's package.
18:35:46 <dldl> 1-1/e indepndednt of the list size?
18:36:09 <orb_> dldl: strictly speaking, the probability approaches 1-1/e as the list size goes to infinity.
18:36:21 <orb_> It oscilates around that value before that.
18:36:23 <dldl> okie dokie
18:36:42 <dldl> I'm having a hard time with not using !=
18:37:25 <orb_> dldl: https://math.stackexchange.com/questions/14925/probability-that-a-random-permutation-has-no-fixed-point-among-the-first-k-ele for a slightly more general result.
18:37:46 <orb_> dldl: (!=) = (/=)
18:37:48 <orb_> problem solved.
18:38:09 <dldl> that doesn't cause some kind of conflict?
18:38:37 <orb_> Nope.
18:38:57 <orb_> And if it did, the worst you gonna got is a compiler error.
18:39:50 <orb_> I wouldn't really advise you using it, but that's only because it would make your code deviate from standard Haskell style for no good reason.
18:40:33 <MarcelineVQ> People will have to figure out if it's a special operator when you're showing them your code too
18:41:14 <MarcelineVQ> Though the `-> Bool` in the sig will tip them off in simple cases. best just to learn to like /= imo :>
18:43:27 <orb_> MarcelineVQ: exactly.  Operators are just weirdly named functions.  And just like it's good to stick to community accepted names for functions by default, it's good to do so for operators, too.
18:43:54 <orb_> It is however good to know that Haskell is flexible enough, that defining != is perfectly cromulent as far as the compiler is concerned.
18:45:41 <KaneTW> @let (!=) = (/=)
18:45:43 <lambdabot>  Defined.
18:45:44 <KaneTW> > 1 != 2
18:45:47 <lambdabot>  True
18:45:56 <KaneTW> ez
18:46:07 <orb_> > 1 != 1
18:46:09 <lambdabot>  False
18:46:40 <orb_> > :info (!=)
18:46:42 <lambdabot>  <hint>:1:1: parse error on input ‘:’
18:46:48 <orb_> @info (!=)
18:46:48 <lambdabot> (!=)
18:47:14 <KaneTW> :t (!=)
18:47:15 <lambdabot> Eq a => a -> a -> Bool
18:47:58 <orb_> Compare eg QuickCheck's ===
18:48:02 <orb_> > :t (===)
18:48:04 <lambdabot>  <hint>:1:1: parse error on input ‘:’
18:48:17 <yamadapc> Can I specify a version when using PackageImports?
18:48:18 <orb_> :t (===)
18:48:19 <lambdabot> (Eq a, Show a) => a -> a -> Test.QuickCheck.Safe.SProperty
18:49:07 <orb_> yamadapc: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#package-imports
18:49:36 <orb_> Yes.  It's a fairly recent extension, if I remember right.
18:50:39 <yamadapc> orb_: But there's no version there... I looked at trac, but it said the proposal with versions had been dropped or something
18:50:54 <orb_> Oh, ok.
18:51:04 <yamadapc> So I'm not sure :P
18:51:05 <orb_> Can't you specific the version in the cabal file?
18:52:03 <yamadapc> Where's the fun in that...? haha... Yeah... I can, I'm just wondering, thinking about https://github.com/yamadapc/stack-run-auto
18:53:20 <yamadapc> Maybe reading from the header is an option for the future
18:53:35 <yamadapc> But it doesn't look like something in haddock
18:56:05 <yamadapc> orb_: Aha! https://git.haskell.org/ghc.git/commitdiff/5971ad56afbdadc9af1cf9e8d708783d2fddbd95
18:56:29 <yamadapc> That could be useful though
18:56:41 <orb_> I wonder why they made that choice.
18:57:15 <yamadapc> I remember cabal can't have two versions of the same package, but maybe I'm wrong
18:57:40 <yamadapc> Maybe that's it; choose not to implement, rather than remove it
18:57:51 <c_wraith> so..  is it impossible to use older versions of ghc on el capitan?
18:57:56 <yamadapc> That commit is just adding validation for something that wasn't supported but failed weirdly
18:57:59 <c_wraith> Like, older than 7.10.2
19:00:55 <orb_> cabal can't.  I think stack can.
19:01:51 <derekv> Is there some reason why let fibs = 0:1:[x+y | x <- fibs, y <- tail fibs] doesn't work right for me, but seems to at least have worked for this guy: http://www.techrepublic.com/article/infinite-list-tricks-in-haskell/
19:02:20 <jle`> > let fibs = 0:1:[x + y | x <- fibs, y <- tail fibs] in fibs
19:02:22 <lambdabot>  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:02:30 <jle`> what do you mean by "works right" ?
19:02:49 <jle`> > let fibs = 0:1:[x + y | x <- fibs | y <- tail fibs] in fibs
19:02:51 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:02:52 <derekv> jle`: I was trying to do the fibonacci sequence 
19:02:55 <jle`> ah
19:02:58 <jle`> then you mis-typed it
19:03:08 <jle`> note that a pipe comes after the x, not a comma
19:04:15 <Pamelloes> I have a function fromMaybe :: MonadPlus m => Maybe a -> m a; Is there a simple way to create the Arrow version (ArrowZero a => a (Maybe b) b) via transforms of the first function, or should I just rewrite it as an Arrow?
19:04:25 <derekv> jle`: it hates that in ghci, I get "Unexpected parallel statement in a list comprehension"
19:04:35 <derekv> When I put in the pipe
19:04:36 <jle`> what does the next line say?
19:04:39 <jle`> in the error
19:04:51 <derekv> jle`: "    Use ParallelListComp "
19:04:53 <Iceland_jack> derekv: Have you enabled ParallelListComp?
19:04:55 <jle`> exactly :)
19:05:01 <jle`> :set -XParallelListComp
19:05:07 <jle`> you have to enable ParallelListComp
19:05:28 <jle`> usually errors like this tell you how to fix themselves ^^
19:05:32 <derekv> ohhh, Parellel List Comprehension I suppose
19:06:10 <derekv> I just assumed it was gibberish produced by it trying to make sense of a syntax error
19:06:12 <jle`> yeah.  i'm not sure what the list comprehension really adds too much here
19:06:26 <jle`> i like zipWith (+) fibs (tail fibs) here instead
19:06:37 <jle`> it makes more sense to me...but i guess the list comprehension looks nice to someone coming from python
19:09:05 <derekv> jle`: I'm doing the katas on codewars everynight, writing the memoized Fibonacci was the kata, I was trying to do it from memory and also use list comprehension because I want to understand that better as well 
19:09:17 <jle`> mhm
19:09:28 <jle`> in normal haskell, list comprehensions aren't used very often, actually
19:09:45 <jle`> you might see one every few months when someone wants to take advantage of how it handles failed pattern matches
19:10:10 <jle`> stylistically most people use map, filter, (>>=), concatMap, etc. over list comprehensions because they just fit better with the language
19:10:21 <augur> i would hesitate to call these things "memoized" fibs
19:10:41 <derekv> jle`: good to know, I felt like I was seeing a lot.  But, I'm not really involved in every-day haskell.  More like code golf sometimes. 
19:10:45 <augur> just because memoization really ought to be reserved for functions
19:11:00 <augur> this is the knot-tied fibs!
19:11:07 <derekv> augur: dynamic programming, or, at least, not naive 
19:11:31 <augur> knot tying is the better mental label for this technique
19:12:07 <MarcelineVQ> > take 15 $ fix ((1:) . scanl (+) 1)
19:12:09 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
19:12:19 <augur> i suppose its vaguely related to dynamic programming, but only vaguely
19:12:31 <MarcelineVQ> fix is wicked cool
19:13:51 <jle`> i've seen a lot of people call it a haskell approach to dynamic programming...and it think it matches with the spirit in a sense
19:13:57 <augur> not re-evaluating a declared variable is rather different tho than not evaluating a function at some arguments
19:14:06 <jle`> even though the mechanism is not memoization, but knot tying
19:14:46 <augur> jle`: i think there's definitely a nice way of using it to implement something roughly like dynamic programming and memoization, but only for those cases where you can cleanly define the values ab initio and then just do lookup
19:15:06 <jle`> instead of the naive recursive evaluation of fib, it takes advantage of the list structure to only require evaluation of each entry once
19:15:33 <jle`> i've seen people apply this to boxed arrays when they know before-hand all possible inputs, yeah
19:16:03 <jle`> evaluating a cell in the array might require evaluation of other cells in the array, but in the end each cell is only evaluated once
19:16:04 <augur> jle`: the list structure, but also haskell's storage of the values of bound variables, and also of course laziness, but you can use explicit thunking for that
19:16:27 <jle`> yes, it's probably that more important than list structure, heh
19:16:48 <augur> i wonder if there are other examples of this approach
19:17:32 <augur> that is, of getting efficiency gains from knot tying + laziness + single evaluation of bound vars
19:18:26 <jle`> this is a post that comes to mind talking about extensions of this technique http://jelv.is/blog/Lazy-Dynamic-Programming/
19:18:57 <jle`> well, it doesn't go too far beyond what we've already discussed
19:19:03 <jle`> heh
19:19:04 <augur> hmm.. probably jle`: the list structure stores all the values of the structural recursion, and fibonacci is linearly recursive, so maybe for the general case, you'd be storing a tree
19:19:06 <jle`> but it goes into depth
19:19:20 <augur> and i wonder, then, if the tree is some form of reified call tree
19:20:10 <augur> well, it couldnt be directly, since the list version really is taking advantage of the sharing in the call tree being linearizable
19:21:05 <jle`> it would be interesting to see if anyone has talked about this before :)
19:21:59 <augur> indeed! if not, we should work out the theory of it! :)
19:22:04 <augur> or even if so, we should work out the theory
19:22:13 <derekv> jle`: I doubt it ;)
19:22:20 <augur> but! i must sleep
19:22:32 <augur> talk to you tomorrow, jle`
19:24:18 <jle`> later :)
19:24:26 <jle`> good night!
19:26:29 <Pamelloes> I'm trying to make an arrow ArrowZero a => a (Maybe b) b. I'm currently able to use maybe to produce a function ArrowZero a => Maybe b -> a c b, which I can lift into ArrowZero a => a (Maybe b) (a c b), but I'm not sure how to merge the two arrows.
19:28:28 <jle`> Pamelloes: do you mean you're trying to make obvious forall a b. ArrowZero a => a (Maybe b) b ?
19:28:48 <jle`> or are you talking about one for a specific type b you had in mind
19:29:03 <Pamelloes> the forall a b.
19:29:32 <Pamelloes> Obviously it can be done, but I'm not familiar enough with arrows to figure it out :/
19:32:00 <acertain> is there any way to tell what's BlockedIndefinitelyOnMVar?
19:34:36 <jle`> Pamelloes: i'm not sure if it's possible actaully
19:34:50 <Pamelloes> jle`: Really?
19:35:03 <Pamelloes> It seems like it should be trivial...
19:35:03 <jle`> i can write it if it's ArrowApply, or more reasonably if it's ArrowChoice
19:35:42 <jle`> but actually that might give the wrong definition hm.
19:35:51 <Pamelloes> Hm...
19:36:03 <jle`> yeah i think Arrow might just not be powerful enough to do that
19:36:26 <Pamelloes> I'm going to be using this function in an ArrowXML (from hxt) so I can add ArrowApply without any issues. It just seems weird.
19:36:28 <jle`> as in, ArrowZero
19:36:48 <jle`> yeah, for ArrowXML, you can do it
19:36:55 <jle`> but you might not be able to do it for all ArrowZero
19:37:06 <jle`> writing functions polymorphically over all Arrow is pretty weird anyways
19:37:20 <jle`> most of the useful functions polymrophic over all Arrow are already in Control.Arrow
19:37:27 <jle`> the rest might not be worth writing :)
19:38:26 <Pamelloes> I've already written the trivial (MonadPlus m) => Maybe a -> m a—it seems like I should be able to lift that into Arrow form somehow.
19:38:27 <jle`> imo Arrow and its associated things are just too vague to write useful polymorphic functions over.  i also don't see many situations where you might want to
19:39:14 <jle`> the MonadPlus m => Maybe a -> m a works because you know the Arrow you're talking about concretely
19:39:31 <jle`> but it's hard to generalize that many things over *all* Arrows
19:39:42 <jle`> you should in general assume that you can't generalize things, other than thinking that you can :p
19:39:54 <learn_haskell> i wanted to calculate from range 50 to 100, i should divide it by 7 and reminder should be 3
19:40:07 <Pamelloes> Huh
19:40:21 <learn_haskell> so, i do this [x | x<- [50..100], mod x 7 ==3]
19:40:40 <Pamelloes> jle`: That's pretty profound :P
19:41:04 <learn_haskell> which gives right ans but when i do, [mod x 7 | x <- [50..100], x==3]
19:41:09 <learn_haskell> it throws an error
19:41:23 <learn_haskell> giving condition at start why its throwing error ?
19:41:56 <jle`> heh.  reading it again it might have come off as a little harsh.  it's good to follow instincts you've acquired on things, but many things you take for granted about (->) can't relaly be generalized
19:42:08 <geekosaur> you're not giving the condition at the start, the condition is still at the end and the x it refers to is the x set immediately before
19:42:39 <jle`> Pamelloes: look at the instances for Kleisli m, btw -- http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Control.Arrow.html#line-190
19:42:54 <jle`> this is the case where you can use MonadPlus -- when you actually have a Monad, heh
19:42:56 <geekosaur> so it is at the least nonsense, since no number between 50 and 100 will be equal to 3
19:43:47 <learn_haskell> no, dividing by 7 and reminder should be equal to 3, u got it wrong
19:44:13 <geekosaur> learn_haskell, the x in x==3 does not refer to the result of mod x 7
19:44:20 <geekosaur> it refers to the x in x <- [50..100]
19:44:31 <learn_haskell> ok
19:44:56 <learn_haskell> what does it means when i do,[mod x 7 | x<- [50..100], x==3]
19:45:03 <geekosaur> and the first thing ios not a condition, it is a formula to construct values to be returned
19:45:19 <learn_haskell> right right
19:45:33 <geekosaur> > [ mod x 7 | x <- [1..8] ]
19:45:36 <lambdabot>  [1,2,3,4,5,6,0,1]
19:45:52 <geekosaur> > [ mod x 7 | x <- [1..8], x == 3]
19:45:54 <lambdabot>  [3]
19:46:40 <geekosaur> > [ x | x <- [1..8], x == 3]
19:46:41 <lambdabot>  [3]
19:47:01 <geekosaur> > [ x | x <- [1..8], x == 3 || x == 5]
19:47:03 <lambdabot>  [3,5]
19:47:08 <nshepperd> Pamelloes: 'arr (maybe (Left()) Right) >>> (zeroArrow ||| arr id) :: (ArrowZero cat, ArrowChoice cat) => cat (Maybe c) c' seems like maybe what you want ish?
19:47:34 <geekosaur> > [ x - 2 | x <- [1..8], x == 3 || x == 5]
19:47:36 <lambdabot>  [1,3]
19:47:43 <geekosaur> see what's going on?
19:48:00 <Pamelloes> nshepperd: Pretty much, but I don't have ArrowChoice—just ArrowApply
19:52:36 <learn_haskell> yes thanks :)
19:53:18 <nshepperd> hmm
19:53:25 <rpfun> i benchmarked this program: http://lpaste.net/2660920243475447808 and found that the majority of the time was spent in the function called "every"; this is a function every :: (Int -> m ()) -> Int -> Int -> m () that when called like "every f d i", runs the action f i, f (i + d), f (i + 2d), so on and so forth. in my usecase, f sets the value of a mutable vector. is there some way to speed this up?
19:53:27 <nshepperd> oh, apparently 'Any instance of ArrowApply can be made into an instance of ArrowChoice by defining left = leftApp.'
19:55:27 <jle`> arr id = id
19:55:28 <rpfun> more specifically, if i have a mutable vector, and a set of indices that looks like "i1, i1 + d, i1 + 2d, ..." is there a way to set to those indices quickly?
19:55:48 <rpfun> would it be worth it to write the setting function in C?
19:57:19 <nshepperd> 'arr (\case { Just x -> (arr (const x), ()); Nothing -> (zeroArrow, ()) }) >>> app' -- bleh
20:04:03 <nitrix> How would I prove that `MaybeT IO ()` and `IO (Maybe ())` are isomorphic types?
20:04:29 <mniip> @unmtl MaybeT IO ()
20:04:30 <lambdabot> IO (Maybe ())
20:04:50 <mniip> as simple as that
20:04:57 <nitrix> What would a proof look like though?
20:05:17 <mniip> @src MaybeT
20:05:17 <lambdabot> Source not found. Take a stress pill and think things over.
20:05:35 <mniip> http://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Monad-Trans-Maybe.html#MaybeT
20:05:43 <mniip> runMaybeT . MaybeT = id
20:05:48 <mniip> MaybeT . runMaybeT = id
20:06:10 <mniip> because it's the constructor and the record accessor for a newtype
20:06:34 <nitrix> So they necessarily cancel each others?
20:06:50 <jle`> nitrix: proving an isomorphism w/ f and g is proving f . g = g . f = id
20:06:52 <nitrix> I just find it weird to explain other than "well, the language makes it pretty clear".
20:06:54 <jle`> so you can prove it here
20:07:02 <jle`> runMaybeT (MaybeT x) = x
20:07:06 <Iceland_jack> nitrix: They actually do! because it's a newtype
20:07:21 <mniip> whenever you have newtype D = D { d :: ... }
20:07:21 <jle`> er, (runMaybeT . MaybeT) x = runMaybeT (MaybeT x) = x
20:07:27 <jle`> and now, the reverse
20:07:28 <Iceland_jack> "MaybeT" and "runMaybeT" turn into the identity function at compile time
20:07:29 <Pamelloes> nshepperd: Well, I wrote it in pl. It's slightly better: arr (flip (,) () . maybe zeroArrow (arr . const)) >>> app
20:07:32 <mniip> you have D . d = id, d . D = id
20:07:55 <jle`>  (MaybeT . runMaybeT) (MaybeT x) = MaybeT (runMaybeT (MaybeT x)) = MaybeT x
20:08:04 <jle`> so, i've shown that both directions are `id`
20:08:11 <jle`> that's the proof :)
20:08:13 <nitrix> Right.
20:08:50 <nitrix> Mkay, I'll go with that ;o
20:08:58 <mniip> nshepperd, arr (\x -> (maybe zeroArrow (arr . const) x, ())) >>> app
20:09:36 <nitrix> Does it means all newtypes are isomorphic?
20:09:44 <jle`> gotta love equational reasoning
20:09:53 <mniip> that's kind of their purpose
20:10:21 <jle`> i think they're actually truly isomorphic even with respect to _|_, as well, which is stronger than what we mean when we usually talk about isomorphisms in haskell
20:10:23 <mniip> the only difference from contained types is that they're typechecked differently
20:10:29 <nitrix> I'm learning type theory; I'm just validating my learnings and connecting the dots.
20:10:59 <Iceland_jack> nitrix: Some things are considered "isomorphic" in Haskell, up to strictness
20:11:35 <Iceland_jack> for example 'data A = MkA Int' and 'newtype B = MkB Int' are isomorphic, but only up to strictness.
20:13:58 <nitrix> What does strictness has to do with it? I thought that was solely for evaluation.
20:14:42 <Iceland_jack> Maybe not the best example, but like jle` said
20:14:42 <Iceland_jack> <jle`> nitrix: proving an isomorphism w/ f and g is proving f . g = g . f = id
20:14:42 <Iceland_jack>  
20:15:02 <jle`> consider data A = MkA { getA :: Int }, you want to show that MkA . getA = getA . MkA = id
20:15:40 <jle`> um i forgot where i was going with this
20:15:46 <nitrix> This makes sense.
20:16:03 <jle`> i was supposed to use this to show that they werne't always going to be id
20:16:36 <Iceland_jack> yeah, they aren't
20:17:04 <Iceland_jack> If you implement 
20:17:04 <Iceland_jack>     back  (MkA i) = MkB i
20:17:04 <Iceland_jack>     forth (MkB i) = MkA i
20:17:22 <Iceland_jack> then
20:17:22 <Iceland_jack>     >>> back (forth undefined)
20:17:22 <Iceland_jack>     MkB *** Exception: undefined
20:18:23 <Iceland_jack> Hm.. I'm not sure if I just made sense :) afk
20:18:38 <jle`> using A and B as separte types make it make more sense, heh
20:19:10 <nitrix> It's the same really; but I'm curious about the strictness thing he mentioned.
20:20:35 <jle`> okay, so you want (MkA . getB) . (MkB . getA) = (MkB . getA) . (MkA . getB) = id
20:21:00 <jle`> or back . forth = forth . back = id
20:21:15 <jle`> but, let's look at it applied to (MkA undefined)
20:21:30 <jle`> or (MkA _|_)
20:22:05 <jle`> MkA (getB (mkB (getA x)) should be x
20:22:19 <jle`> but if you apply it to MkA _|_, you get _|_
20:22:31 <jle`> MkA _|_ is not _|_, so, it's not isomorphic
20:22:50 <jle`> um wait, did i do this right >_>
20:23:08 <nitrix> I don't know, the end result seems isomorphic.
20:23:23 <Iceland_jack> Yeah it was a bad example
20:23:49 <jle`> yeah ignore what i said, i'm going to eat v.v
20:24:23 <nitrix> Like, how are you supposed to prove isomorphicity if even using those laws, you can have an intermediate result that disproves it.
20:24:31 <nitrix> Now I'm confused, lol.
20:24:56 <nitrix> Isn't it because _|_ is part of EVERY types?
20:25:41 <shachaf> I'm not sure where he was going with that exactly.
20:25:50 <shachaf> But (MkA . getA) _|_ = MkA _|_, which is not equal to _|_
20:26:55 <nitrix> Right.
20:27:08 <nitrix> That makes more sense. Actually it could be verified with Expr probably.
20:39:09 * hackagebot haskell-tor 0.1.1 - A Haskell Tor Node  https://hackage.haskell.org/package/haskell-tor-0.1.1 (AdamWick)
20:39:42 <Pamelloes> Is there a foldr1Maybe anywhere?
20:41:36 <jle`> in the safe library, probably?
20:41:45 <Pamelloes> Yep, found it :)
20:41:48 <kadoban> foldr1May in safe, yeah.
20:41:59 <athan> Pamelloes: You could also use foldMap with Option, I think
20:42:14 <athan> (if you can turn your computation into a semigroup)
20:42:41 <Pamelloes> I think I'll just use foldr1May :)
20:43:14 <Pamelloes> On a more serious note—is the old Hoogle ever going to get an updated list of definitions/is the new Hoogle ever going to get type search support?
20:43:31 <Pamelloes> This whole mix and match business makes searching for functions challenging :/
20:43:36 <jle`> last i heard of this matter was neil's blog post
20:43:52 <jle`> which was a while ago...and said it was coming sooon
20:44:35 <Pamelloes> Well, the Milkyway will collide with Andromeda in about 6 billion years, so as long as I get it by the destruction of the galaxy I'll call it a win :)
20:44:36 <jle`> for now there's stackage hoogle
20:44:50 <Pamelloes> stackage hoogle?
20:44:53 <jle`> which allows you to search by types and also indexes all of hackage
20:44:55 <jle`> *stackage
20:45:06 <Pamelloes> Cool! That's what I'm looking for.
20:45:08 <jle`> https://www.stackage.org/
20:45:11 <jle`> in the corner up there
20:47:16 <acertain> is there any way to show a MVar (to it's address or so)?
20:56:11 <gfixler> what does f () mean in a typeclass constraint like IsString (f ())?
20:56:40 <bitemyapp> gfixler: some type f applied to the type ()
20:56:58 <bitemyapp> you're asking for or using an IsString instance for that.
20:57:14 <bitemyapp> seems unlikely to work, but I don't know enough to say anything useful because you didn't paste the code.
20:57:35 <gfixler> https://github.com/paf31/haskell-slides/blob/master/hoas/Applicative.hs
20:57:43 <gfixler> line 11
20:57:53 <gfixler> also wondering about line 29
20:57:59 <gfixler> (a ~ ())
20:58:07 <bitemyapp> it's saying a is ()
20:58:22 <bitemyapp> GADTs gives you type equality assertions for free
20:58:33 <bitemyapp> that it's a HOAS thing explains a bit.
20:58:34 <gfixler> are you talking about 29?
20:58:42 <gfixler> I'm still not grokking 11
20:58:50 <bitemyapp> a ~ () means, "a is unit btw"
20:59:04 <bitemyapp> it's a constraint that applies to the entire type signature it constraints
20:59:05 <gfixler> hmmm
20:59:13 <bitemyapp> it constrains*
20:59:22 <gfixler> can't just say IsString (PrintRoute ())?
20:59:25 <pavonia> acertain: Maybe unsafeCoerce to a sensible datatype and show that
21:00:48 <gfixler> "a is unit" == the type unit, or the value unit?
21:01:08 <gfixler> I'm guessing type
21:01:49 <pavonia> gfixler: You can't  use values in constraints
21:02:04 <gfixler> pavonia: didn't think so - that would be dependent types, or similar
21:03:59 <pavonia> OTOH, you can have variable names with ImplicitParams in constraints :p
21:04:13 <pavonia> *function names
21:04:26 <gfixler> vaguely rings a bell
21:05:09 <gfixler> so what did we decide line 11 is about?
21:05:52 <gfixler> does it mean that only f () has to be a member of IsString?
21:05:56 <gfixler> and f anything else doesn't?
21:06:02 <nh4clo4> Hey, so I've been trying to learn Haskell and one of the exercises had me write a fibbonacci function
21:06:15 <nh4clo4> Problem is whenever I try to run it it eats up all my memory
21:06:26 <nh4clo4> like 12gb + pagefile
21:06:35 <nh4clo4> http://pastebin.com/MQaB4Nth
21:06:49 <nh4clo4> that's the code if anyone wants to look at it, just 8 lines
21:06:49 <Pamelloes> Is there a more concise method to write this function? f :: Ord a => Maybe a -> Maybe a -> Maybe a; f Nothing x = x; f (Just x) Nothing = x; f (Just x) (Just y) = Just $ min x y
21:07:19 <pavonia> gfixler: Yeah
21:08:11 <Pamelloes> nh4clo4: You need to put (n-1) and (n-2) in parentheses. Right now it is executing (fib n) - 1—which results in a contradiction.
21:09:00 <Pamelloes> nh4clo4: Alternatively, you could write (fib $ n - 1) to avoid a second pair of parentheses.
21:09:02 <c_wraith> :t \x y -> liftA2 min x y <|> x <|> y
21:09:03 <lambdabot> (Ord a, Alternative f) => f a -> f a -> f a
21:09:14 <c_wraith> Pamelloes: Maybe that?
21:09:33 <Pamelloes> c_wraith: That looks right :)
21:09:38 <c_wraith> Pamelloes: as that also handles that Nothing/Nothing case
21:09:58 <pavonia> Do you need the "<|> y" part?
21:10:08 <Pamelloes> c_wraith: Case 2 in my function handles the Nothing/Nothing, as well ;)
21:10:20 <Pamelloes> err Case 1.
21:10:33 <c_wraith> Pamelloes: ok, in that case, my version doesn't have a type error. :)
21:11:00 <Pamelloes> That's true.
21:11:00 <Pamelloes> hehe
21:11:21 <nh4clo4> Pamelloes: that makes sense, I'll try it
21:13:01 <Pamelloes> pavonia: I think you do need the <|> y in the case that the first one is Nothing but the second is Just.
21:13:02 <nh4clo4> Pamellos: it worked! Thank you! Also, what does the dollar sign do in (fib $ n - 1)?
21:13:06 <c_wraith> pavonia: I believe the <|> y is necessary.  Without it you'll get Nothing if the first arg is Nothing
21:13:20 <nh4clo4> *Pamelloes
21:13:26 <Pamelloes> :t ($)
21:13:27 <lambdabot> (a -> b) -> a -> b
21:15:00 <Pamelloes> nh4clo4: the $ is the same as normal function application (f a) and (f $ a) are isomorphic. However, function application (f a) has highest priority while ($) has lowest priority. This means that (f a + 1) is evaluated as ((f a) + 1) while (f $ a + 1) is evaluated as (f (a + 1))
21:15:09 <Pamelloes> nh4clo4: Does that makes sense?
21:15:26 <Pamelloes> *make
21:17:05 <dldl> is it possible to define two functions in one "let..in" block?
21:17:12 <nh4clo4> Pamelloes: So $ acts as a sort of separator? Like f (a + 1) is the same as f $ a + 1?
21:17:23 <Pamelloes> Yep :)
21:17:53 <nh4clo4> That makes sense then. Thanks! :D
21:18:00 <Pamelloes> dldl: Yes. Separate them with a semicolon or a new line and indent.
21:23:14 <Pamelloes> Huh, you can use (***) with normal functions. That's super useful!
21:23:24 <gfixler> ?
21:23:42 <Pamelloes> :t (***)
21:23:43 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
21:23:52 <Pamelloes> ^ I forgot (->) was an Arrow.
21:24:16 <gfixler> oh yeah
21:24:25 <gfixler> I've done that (forgot :))
21:26:23 <nh4clo4> Pamelloes++
21:33:20 <jle`> nowadays a lot of people like `bimap` over (***), but yeah, they both work :)
21:33:30 <jle`> for using with functions and tuples
21:34:51 <Pamelloes> Interesting.
21:36:32 <Pamelloes> I wonder if there's an unzipGeneric :: (Traversable t, Bifunctor p) => t (p a b) -> p (t a) ( t b)...
21:36:49 <Pamelloes> Or if more constraints are needed.
21:37:43 <Pamelloes> Oh cool, there's a Bitraversable, too.
21:45:02 <dldl> my where statement needs a where statement
21:45:10 <dldl> or my let statement needs a let statement
21:45:23 <dldl> or I need to break something into two functions
21:45:58 <dldl> is where/where or let/let possible>
21:46:34 <Pamelloes> dldl: where/where and let/let are possible, though both statements are recursive so be sure you actually need one ;)
21:47:00 <Pamelloes> (both statements as in a normal where and a normal let are recursive_
21:47:00 <Pamelloes> )
21:47:15 <jle`> dldl: the language works like (declaration) where (declarations)
21:47:31 <jle`> dldl: so any of the delcarations in the where block might also have where blocks
21:47:57 <dldl> do i start a new where statement block by indenting again>?
21:48:01 <jle`> and for let, it's let (declaration) in (expression), or let f = expression; g = expression in expression, etc.
21:48:09 <jle`> so you can use a let .. in .. in any of those expressions
21:48:18 <jle`> yeah, indent past the identifier of the new declaration
21:50:28 <Cale> dldl: 'where' is part of the syntax of declarations (i.e. the equations that you're writing), while 'let' is part of the syntax of expressions (the things which have values, and which occur to the right hand side of an = sign)
21:52:49 <Arahael> Hey, I have stack installed (on mac os x), however stack is using ghc 7.8.4.  How do I get it to install a newer GHC instead?
21:53:41 <gfixler> stack update?
21:53:59 <simony> Arahael: just curious, how'd you install stack?
21:55:19 <Arahael> simony: I forget, it was a while ago.
21:55:37 <Arahael> gfixler: I've already run that. It updated the packages, but kept GHC to 7.8.4
21:55:47 <gfixler> simony: I did this: http://ghcformacosx.github.io/
21:55:53 <gfixler> took <1 minute
21:56:02 <gfixler> downloaded and moved it to my path
21:56:28 <simony> yeah, i'd start with updating stack itself
21:56:51 <Arahael> So, I've done stack update && stack update.  It's _still_ using ghc 7.8.4
21:57:14 <Arahael> Which is to say, stack update only seems to update the individual packages.
21:57:17 <simony> gfixler: i've gone and removed ghc/cabal and co myself, and let stack do it all, found it to work a lot better with less issues for me
21:57:17 <gfixler> Arahael: you mean  stack upgrade?
21:57:24 <Arahael> gfixler: I've also tried that.
21:57:40 <gfixler> Arahael: how are you launching ghci?
21:57:56 <Arahael> gfixler: I'm not.  I'm testing using: stack exec ghc -- --version
21:58:09 <Arahael> I've also tried: stack setup 7.10.2
21:58:13 <simony> Arahael: what/where is ghc installed?
21:58:19 <Arahael> But that just reports that it's using my installed ghc, which is 7.8.4
21:58:31 <Arahael>  /Applications/ghc-7.8.4.app/Contents/bin/ghc
21:58:48 <gfixler> I feel like there's a .stack-something that can be cleared out
21:58:48 <Arahael> I want to have stack upgrade and manage my ghc installations - if possible
21:59:05 <Arahael> gfixler: I feel like documentation should exist for this, but I'm somehow blind.
21:59:18 <gfixler> Arahael: bitemyapp has a video that goes over this, I think
21:59:21 <simony> Arahael: if that's the goal, i'd start with removing your ghc*.app (warning things may break until you fix things and get settled)
21:59:52 <gfixler> Arahael: what's stack --version tell you?
21:59:56 <Arahael> simony: That implies installing the ghcformacosx latest version, which includes stack.  That's defeating the purpose of my investigation.
21:59:57 <simony> but yeah, documentation needs to be better
22:00:06 <Arahael> Version 0.1.5.0, Git revision 1893348f11301684e64567c93b49f9e0ceb602f9 (2154 commits) X86_64
22:00:12 <Arahael> Which I know is old.
22:00:15 <gfixler> whoa
22:00:20 <gfixler> I have 0.1.4.1
22:00:21 <Arahael> (Hence the desire to update it, funnily enough)
22:00:27 <simony> Arahael: nope, i'm recommending only having stack installed (i now install stack via brew)
22:00:51 <simony> and ghc is living somewhere in ~/.stack
22:00:52 <Arahael> simony: I thought brew's haskell had a really bad rep here.
22:01:01 <Arahael> simony: Nice.
22:01:03 <simony> again, not brew's haskell
22:01:05 <simony> just brew's stack
22:01:10 <Arahael> Ah, ok.
22:01:37 <Arahael> Luckily, brew's update functionality actually works, so will do that first, then try installing it's stack.
22:01:39 <gfixler> strange, I don't get a commit version
22:01:41 <simony> specifically, haskell-stack (latest is 0.1.8.0)
22:01:57 <gfixler> I get: Version 0.1.4.1 (UNKNOWN commits) X86_64
22:02:14 <kadoban> gfixler: It depends how you got it or how you built it.
22:02:19 <gfixler> very non-committal
22:06:24 <Arahael> Curiously, brew's stack is 0.1.6.0
22:06:31 <Arahael> Oh, wait - no it isn't.
22:08:50 <glguy> Arahael: You get different versions of GHC based on which "resolver" you're using
22:09:01 <glguy> upgrading stack isn't going to change which GHC stack uses
22:09:38 <kadoban> Though upgrading stack is probably a decent idea, it's new enough that a lot changes between versions.
22:19:52 <gfixler> glguy: I wish it were easier to pick resolver versions
22:21:21 <glguy> I can't imagine how it could be easier. What did you have in mind?
22:23:27 <gfixler> glguy: stack --resolver <Tab><Tab>
22:24:03 <gfixler> stack --list-resolvers
22:24:50 <gfixler> stack --list-resolvers-for 7.10.2
22:25:43 <kadoban> gfixler: You basically always want either the newest one or a specified old one, right? Why not:   --resolver lts or --resolver nightly or --resolver lts-2 ?
22:25:44 <gfixler> stack --ghc-version 7.6.1 ghc (uses latest resolver with that ghc)
22:26:09 <gfixler> kadoban: I presumed the latest one was what I got with no flags
22:26:22 <gfixler> and no, I don't always want the latest
22:26:27 <gfixler> if I'm specifying, I don't want the latest
22:27:42 <glguy> If you don't want the latest of the series you must have some reason for wanting a specific one, so use that
22:27:49 <glguy> otherwise there aren't many choices
22:28:06 <gfixler> glguy: you mean I can specify by ghc version?
22:28:09 <glguy> lts-2 for the 7.8 stackage, lts-3 for the 7.10, or just use ghc-7.10 and forget about "curated" package sets
22:28:19 <gfixler> that's what I mean
22:28:21 <gfixler> "I can't imagine how it could be any easier"
22:28:32 <gfixler> it could be a lot easier without having to remember which lts goes with which version
22:28:39 <gfixler> or having to look it up
22:29:01 <glguy> Just listing a bunch of lts releases would be meaningless without telling you what packages went with them
22:29:05 <glguy> that's what the website is for
22:29:28 <kadoban> gfixler: I guess my question would be: why would you use that? In what circumstances do you want not the newest GHC version, but some old specified one?
22:29:52 <gfixler> kadoban: teaching, helping people on older versions, checking out differences locally
22:30:04 <glguy> if you're not using an old version for a specific reason use the latest, if you have a reason use the one you have a reason to use
22:30:31 <gfixler> that's what I do
22:31:07 <Arahael> glguy: The question is: How do I update to an up-to-date ghc.  Ie, which resolver do I use?
22:31:17 <gfixler> if I want to demo something in 7.8.4, I just want whatever resolver is the latest 7.8.4
22:31:50 <gfixler> glguy: and there you go - Arahael doesn't know which resolver to use
22:31:53 <gfixler> it takes investigation
22:31:54 <kadoban> gfixler: Not sure. I mean doesn't sound like something I'd ever use, but I can't say it's not useful either. You can always suggest it, add it as a github issue. They're good at responding to those.
22:32:11 <kadoban> gfixler: Arahael's question is different.
22:32:15 <gfixler> kadoban: it's funny, because I can't fathom how that isn't useful - it's much more useful than lts versions for me
22:32:18 <gfixler> :)
22:32:31 <gfixler> I don't use haskell for work - it's entirely an environment for learning and teaching for me
22:32:56 <gfixler> so if I feel like explaining something with types pre-ftp, then I'm much more likely to know which ghc version that is
22:33:00 <kadoban> gfixler: Well, because I just pick the newest lts or nightly, I … never use anything else except for with old code that already has a specified resolver. Or let 'stack init' figure it out for me based on the .cabal for old packages that aren't set up for stack yet.
22:33:25 <gfixler> kadoban: right - I don't even make packages
22:33:39 <gfixler> stack is mostly just a ghci launcher for me
22:33:58 <Arahael> So, I'm now on stack 0.1.8.0, yet it's reporting ghc version 7.8.4.
22:34:16 <gfixler> Arahael: ~/.stack/global/stack.yaml
22:34:21 <gfixler> that should list the version to use
22:34:46 <Arahael> gfixler: This is getting frustrating - I just wanted something _clear and simple_.  Do I modify the stack.yaml version numbers by hand?
22:34:48 <simony> Arahael: what's reporting ghc 7.8.4?
22:34:51 <gfixler> Arahael: of course, it does it by lts, so you'll have to investigate which one to use online
22:34:58 <Axman6> Arahael: lts-3.x will use GHC 7.10(.2)
22:35:00 <Arahael> simony: stack ghc -- --version
22:35:35 <Axman6> Arahael: are you running that inside a stack enables package? or just in say your home dir?
22:35:39 <gfixler> Arahael: I know - that's why I just wanted to be able to say stack --ghc-version 10.2 (or whatever) ghc[i]
22:35:48 <kadoban> gfixler: Well, I'd definitely recommend you add it as an issue, and explain what you'd use it for and why it's better. Getting info on what people use software for and what isn't as nice as it should be is really hard.
22:35:49 <Arahael> Axman6: Within a stack configured package.
22:35:51 <simony> Arahael: where are you putting that? there may be a stack.yaml causing it to use a different ghc version
22:36:09 <Arahael> gfixler: Honestly, I just want something like: stack upgrade-package and have it magically step me through updating it.
22:36:15 <Axman6> Arahael: then the resolver needs to be lts3.x (currently lts-3.14 I believe)
22:36:22 <gfixler> kadoban: alright - I haven't done it, because I feel like a weirdo in the community
22:36:27 <simony> I think we're at 3.15 now haha
22:36:36 <gfixler> everyone is focused on packages and interop between them and jobs
22:37:00 * Arahael gives up, and deletes his stack.yaml
22:37:12 <gfixler> how do you say "stack --latest-lts-whatever-it-is-i-don't-care"?
22:37:41 <gfixler> Arahael: yeah, sounds nice
22:37:42 <glguy> for stuff like that I don't use stack
22:37:42 <koz_> gfixler: Best flag ever.
22:38:03 <glguy> I only use it when coordinating multiple packages under development
22:38:15 <gfixler> and also stack --latest-ghc-7.8.4-whatever-one-that-is-you-figure-it-out"
22:38:22 <glguy> for opening ghc I type ghc, for building single packages I use cabal
22:38:50 <Arahael> Well, that's much easier.  Seems deleting stack.yaml was the missing step - it walks you through it nicely.  It's now telling me how to select a resolver, etcetera, etcetera.
22:39:06 <gfixler> Arahael: was going to suggest that - sorry I delayed :)
22:39:07 <Arahael> Of course, my cabal package versions aren't quite compatible with any of them, but now I can actually fix stuff.
22:42:19 <dldl> http://lpaste.net/145978
22:42:28 <dldl> This doesn't load in ghci
22:42:39 <dldl> parse error on input where
22:42:46 <dldl> (the last where in the code)
22:43:46 <dldl> I know that the code isn't great.  Just trying to understand the syntax
22:44:16 <cite-reader> dldl: My editor's auto-indenting mode tells me you want to push that `where` further to the right.
22:45:29 <cite-reader> Indent it further than the _makePerms' identifier.
22:46:59 <kadoban> dldl: By the way, there seems to be no reason for that second 'where' there at the end to exist, you can just delete the word 'where' and line oldLists up with _makePerms' above it.
22:47:23 <cite-reader> No, oldLists needs `n` to be in scope.
22:47:32 <dldl> I get not in scope 'n' error
22:47:33 <kadoban> Oh it does
22:47:38 <dldl> yea
22:47:39 <dldl> thanks
22:48:17 <cite-reader> There's probably a better way to do this but I'm about to head to bed so.
22:48:20 <gfixler> kadoban: https://github.com/commercialhaskell/stack/issues/1432
22:48:37 <gfixler> kadoban: no idea if it makes sense, but it's been the thing that's stood out to me since I started with stack months back
22:49:45 <kadoban> gfixler: Sounds interesting. I certainly don't know the answer myself
22:51:11 <gfixler> kadoban: I guess it might not make sense if ghc is just seen as another thing like any other package
22:51:35 <gfixler> then making a version flag that looks up the latest LTS with that version seems odd to only exist for one thing that stack can serve up
22:52:13 <kadoban> gfixler: Well, it's not quite seen as just that or anything. There's clearly a mapping from LTS version to GHC version specially and such.
22:52:43 <gfixler> kadoban: this is basically just a table lookup - just seek backwards until you find ghc.7.8.4, e.g., then return that lts
22:53:03 <gfixler> unless it's a tree - I thought it was a list of resolvers, though
22:53:46 <kadoban> Right, yeah I think it's kind of just basically a list (or two … nightly and lts are kind of parallel ?) but that shouldn't matter much. I'll just let someone who knows what they're talking about hopefully give you a real answer instead of speculating though, heh.
22:58:47 <dldl> so, for tabbing, i just need to make sure my current where statement is in a column further to the right than the previous where statement?
22:59:55 <kadoban> dldl: I think it has to be farther right than the … start of the definition it's part of, so farther to the right than the start of _makePerms'
23:00:28 <kadoban> So IIUC the 'w' needs to be under the 'm', or farther to the right.
23:05:28 <kadoban> Is: find (/= "foo") [someVal]  too cute as a replacement for: if someVal == "foo" then Nothing else Just someVal ?
23:06:59 <Axman6> when (someVal == "foo") $ pure someVal :P
23:11:09 <kadoban> Heh
23:19:44 <tnks> is it unreasonable to think that Bifunctor should be defined in terms of Functor with first (or second) being fmap?
23:31:02 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
23:31:02 --- topic: set by quicksilver!~jules@roobarb.crazydogs.org on [Wed Oct 07 07:39:49 2015]
23:41:45 <CoconutCrab> erm, what?
23:43:19 <simony> #JustFreenodeThings
23:50:41 <fvh> hi guys. Help me out. I have function written in TemplateHaskell that with provided int can generate n-tuple from list, but to use it I need to know size of my list beforehand in splice.How can I generate for example all conversion function from 1 to 10 and then dispatch them in execution?
23:50:52 <fvh> using this code now http://stackoverflow.com/questions/2921345/how-do-i-convert-a-list-to-a-tuple-in-haskell/2923574#2923574
