00:07:38 * hackagebot irc-core 1.1.3 - An IRC client library and text client  https://hackage.haskell.org/package/irc-core-1.1.3 (EricMertens)
00:07:38 * hackagebot exact-real 0.3.0.0 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.3.0.0 (jophish)
00:29:53 <saulzar_> Is anyone familiar with what criterion does with respect to GC? e.g. does it 'performGC' between benchmarks? I guess it's reasonable to call it myself in a benchmark so that the gc costs are specific to that benchmark?
01:12:39 <quicksilver> saulzar_: pretty sure criterion calls performGC
01:13:45 <quicksilver> given that it runs things many many times I wouldn't worry about calling GC yourself
01:13:49 <quicksilver> you'll just make it much slower
01:16:03 <saulzar_> quicksilver, Hmm. Actually I was noticing it was faster, and with less variance calling performGC
01:17:24 <quicksilver> heh
01:17:27 <quicksilver> then I'm wrong :)
01:17:34 <saulzar_> Maybe I should look at the source :)
01:19:05 <saulzar_> Hm, it calls performGC just before the start of every benchmark
01:20:27 <saulzar_> Ah, before one entire benchmark (many calls of the benchmark).
01:26:49 <fizruk> hi all! is there a way to precompute a Vector at compile time? the best way I got was to do xs = fromList [...] :: Vector, but that does not create a Vector it creates a list which is turned into a Vector when the program is run (and thus affects the first use of xs)
01:28:08 <jle`> fizruk: not sure what you mean...would the vector itself be stored in the binary?
01:28:36 <fizruk> jle`: yes stored in a binary
01:33:42 <quicksilver> fizruk: no. Is it really such a big list that the time to force it first time is significant?
01:33:56 <quicksilver> if so I recommend writing it to a file in a fast-to-load format :)
01:34:49 <dramforever> fizruk: does the list takes really long to evaluate? or it's just the cost making a vector?
01:35:50 <fizruk> dramforever: yea, the list is huge
01:36:18 <solatis> ok, so, I developed a package I think other people might be interested in. what is the best way to "announce" this library to the world?
01:36:22 <fizruk> quicksilver: I though about file, but hoped I could hardcode the vector somehow :)
01:36:23 <dramforever> fizruk: um...no I mean is the list written out like [1, 17, 42, -1, 9] or some complexed function?
01:36:25 <solatis> put it on reddit?
01:36:41 <quicksilver> solatis: ANNOUNCE it on haskell-cafe?
01:36:53 <quicksilver> (and then put the link to the mailing list archive on reddit, possibly)
01:36:54 <fizruk> dramforever: it's a list of primes < 10^8
01:37:02 <solatis> quicksilver: sounds reasonable
01:37:16 <quicksilver> fizruk: I would write it to a file in a format which is convenient and fast to load into a Vector
01:38:07 <quicksilver> for example, using the Binary instance for Data.Vector
01:38:09 <quicksilver> that should be very fast.
01:38:33 <fizruk> I didn't realise I could use Binary instance for Vector
01:38:39 <fizruk> quicksilver: thanks!
01:38:42 <jle`> yeah, you can't really get past loading something from disk to memory
01:38:59 <jle`> but something like this could potentially be optimized using template haskell
01:39:07 <dramforever> quicksilver: I wonder if using Storable and somehow linking it in is suitable...
01:39:19 <jle`> by doing everyone's favorite thing -- doing aribtrary IO with template haskell at compile time
01:39:39 <quicksilver> can template haskell pack data into Addr# constructors?
01:39:43 <quicksilver> I'm not sure how that stuff works
01:39:53 <merijn> dramforever: I recently learned the (probably *nix only) trick of linking arbitrary data into binaries, so that should be easy
01:39:59 <dramforever> :t "blah"# -- yes I think
01:40:00 <lambdabot> GHC.Prim.Addr#
01:40:15 <quicksilver> merijn: all executable formats can do that as far as I know
01:40:18 <quicksilver> FSOV "all"
01:40:23 <dramforever> but could take a hell long time
01:40:36 <merijn> quicksilver: Sure, but I only know how to do it using ld and I don't think Windows has that :p
01:40:49 <joco42> how can i give a type annotation to a let f = ... inside a do ?
01:40:57 <jle`> let f :: Int
01:41:01 <jle`>     f = ...
01:41:01 <dramforever> let f :: TypeAnnotation
01:41:03 <quicksilver> let f :: Blah; f = ....
01:41:06 <joco42> ahh
01:41:10 <quicksilver> can use a newline there
01:41:10 <joco42> ok
01:41:17 <jle`> layouting is fun
01:41:17 <joco42> thanks
01:41:18 <quicksilver> or you can do let f = (.....) :: Blah
01:41:28 <quicksilver> but having the annotation up front proabbly reads better
01:41:47 <jle`> my syntax highlighter messes this up every time though :(
01:41:53 <quicksilver> with PatternSignatures (?) you can even do let f :: Blah = (....) I think
01:41:54 <phadej> it depends, foo = Proxy :: Proxy Bar - imho reads better
01:41:55 <joco42> up front is better :)
01:42:22 <phadej> (i.e in the case where the expression is quite short, and the type signature is *the* interesting part)
01:42:23 <dramforever> asking yet again: Anyone familiar with structured-haskell-mode here? Is there a quick guide somewhere?
01:42:27 <jle`> quicksilver: ScopedTypeVariables
01:43:03 <jle`> i prefer foo = Proxy `asTypeOf` (undefined :: Proxy Bar)
01:43:06 <joco42> dramforever:  i remember on reddit there was something about shm
01:43:13 <joco42> might be good to search it
01:43:20 <dramforever> joco42: ok I'll try
01:43:51 <quicksilver> dramforever: well there is an intro on the github page? https://github.com/chrisdone/structured-haskell-mode
01:44:02 <dramforever> It just seems that everyone is so happy with shm, yet I can't seem to figure out the more basic things
01:44:22 <joco42> dramforever:  in this thread https://www.reddit.com/r/haskell/comments/3bqy5h/survey_which_haskell_development_tools_are_you/
01:44:26 <phadej> jle`: why on earth? it's two words more and one of them is undefined?
01:44:42 <jle`> if people read through my code too fast they might stop paying attention
01:44:46 <jle`> think of it like a mental speed bump
01:44:53 <phadej> :)
01:44:57 <joco42> cocreature uses it
01:45:01 <phadej> that makes sense
01:45:08 <jle`> i'm just kidding btw :|
01:45:08 <phadej> won't use it myself though :)
01:45:10 <cocreature> *wakes up*
01:45:13 <dramforever> joco42: thanks, reading it
01:45:25 <jle`> you have awaked cocreature from its coslumber
01:45:32 <joco42> :)
01:45:46 <cocreature> let’s have a coslumber party
01:45:49 <joco42> one day i try shm myself too...
01:46:06 <joco42> its on my to-try list
01:46:10 <dramforever> cocreature: hmm...so...um...
01:46:15 <dramforever> have anything to say?
01:46:28 <cocreature> dramforever: it's pretty nice :)
01:46:30 <merijn> joco42: I would highly recommend going over the Haskell 2010 report some time if you have time :) It's probably one of the most readable standards ever and chapters like the lexical grammar one explain very thoroughly where you can write things like type annotations :)
01:46:46 <cocreature> dramforever: there are some videos on it, let me find them
01:46:59 <dramforever> sounds interesting...
01:47:13 <cocreature> dramforever: https://www.youtube.com/user/ChristopherDone/videos
01:47:39 <dramforever> cocreature: Is it just me? or do you also find the README confusing because it leaves out some rather important details?
01:47:49 <dramforever> I'm saying so because I can't seem to make shm like me...
01:47:56 <dramforever> cocreature: oh wow video, thanks
01:48:05 <cocreature> dramforever: I'm actually not sure whether I've read the readme :)
01:48:12 <joco42> merijn:  next summer on the beach ... i can read that...
01:48:22 <joco42> or some category theory books...
01:48:29 <cocreature> it doesn't look too confusing to me
01:49:38 <merijn> joco42: tbh, the report is probably substantially easier AND more useful than category theory :)
01:49:47 <dramforever> what about this: how am I supposed to *create* a guarded definition for something like "foo" in the first example?
01:50:17 <dramforever> like, if I have arguments to foo, it indents the next line to line up with the first argument
01:50:17 <merijn> joco42: The usefulness of category theory for becoming a better haskell programmer is *severely* overrated, and I say this as someone trying to learn Category Theory bit by bit :)
01:50:44 <cocreature> merijn: it's still a lot of fun :)
01:50:57 <cocreature> dramforever: just type it in?
01:51:15 <dramforever> like this? SPC SPC |
01:51:18 <jle`> oh i found a lambdabot bug
01:51:19 <joco42> merijn:  yeah... maybe then i read the report in 2016 and ct in 2017 summer...
01:51:32 <cocreature> dramforever: yeah
01:51:33 <merijn> cocreature: Sure, I'm not saying "don't learn CT", I'm just saying that if the goal is "become better haskeller" then there are more efficient ways to spend your time
01:51:38 <jle`> @let (>-->) = (-)
01:51:40 <lambdabot>  Defined.
01:51:43 <jle`> > 10 >--> 4
01:51:44 <lambdabot>  6
01:51:46 <jle`> :t (>-->)
01:51:47 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
01:51:49 <cocreature> yeah I agree
01:51:55 <dramforever> oh man...end up indenting anyway...
01:52:03 <joco42> ct is indeed very abstract stuff
01:52:11 <merijn> I would recommend type theory, algebra and the STG machine before category theory if the goal is to become a better functional programmer
01:52:24 <merijn> Incidentally, CT is a lot easier after the type theory and algebra stuff :p
01:52:33 <joco42> yeah... type theory is good stuff
01:52:37 <joco42> i read tapl
01:52:44 <joco42> understood 20%
01:52:46 <u-ou> Hmm
01:52:50 <merijn> joco42: TaPL is a good start :)
01:52:51 <joco42> its nice
01:53:13 <merijn> joco42: You just have to keep retrying, the next time you'll understand 30-40% :)
01:53:21 <u-ou> i think i want to learn ct at some point, just because it looks interesting in its own right
01:53:23 <joco42> something like that...
01:53:30 <u-ou> tt also
01:53:40 <merijn> Bartosz' blog series CT for programmers is good
01:54:07 <joco42> its like quantum mechanics.... u r still learning it after 15 years
01:54:21 <u-ou> tapl?
01:54:39 <merijn> u-ou: Types and Programming Languages
01:54:39 <joco42> types and prog lang
01:54:42 <merijn> @where tapl
01:54:42 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
01:54:47 <u-ou> ok
01:54:51 <merijn> u-ou: It's the de facto standard intro to type theory
01:55:02 <merijn> u-ou: It includes lots of example code implementing various type checkers
01:55:05 <u-ou> you just answered my next question
01:55:21 <u-ou> so what's a good intro to ct?
01:55:23 <merijn> (in ocaml, but it only uses a basic subset of ocaml that any haskell beginner should trivially understand)
01:55:39 <merijn> u-ou: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
01:55:45 <u-ou> thank you
01:57:30 <merijn> u-ou: I think the start (maybe first half, depends on how complex you want to get) of TaPL should be sufficient to basically implement your own haskell compiler
01:57:47 <merijn> It'll be a compiler that produces shittily slow code, but hey, still a haskell compiler :p
01:57:59 <u-ou> :O
01:58:47 <merijn> u-ou: tbh, writing a compiler for a language that's vaguely haskell-like (typeclasses make things a little complicated, but not THAT much) is pretty easy
01:58:54 <merijn> It's the optimising bit that's hard :p
01:59:21 <u-ou> ic
02:01:39 <tdammers> merijn: so, a bit like writing a FRP framework, yes?
02:01:40 <earthy> merijn: to qualify that a bit, if you haven't reasoned about code generating code ever at all that bit is also quite hard
02:02:09 <earthy> but if you know haskell and are reasonably comfortable with higher order functions it becomes a tad simpler. :)
02:02:33 <merijn> earthy: If you've read the start of TaPL you should've managed to learn that step ;)
02:03:01 <earthy> read and understood :P
02:03:13 <u-ou> :3
02:03:28 <earthy> (I've seen people struggle and fail at the latter)
02:03:43 <merijn> earthy: Perhaps, I did read it after writing an (imperative) compiler before, but still
02:04:04 <merijn> earthy: Oh, sure, I just meant that it's not nearly as hard and overwhelming as most people think it is
02:04:20 <earthy> oh, no, indeed it isn't
02:04:33 <dramforever> ha, found "quick guide" here: https://github.com/chrisdone/structured-haskell-mode/blob/master/elisp/shm.el#L43
02:05:05 <merijn> Certainly a motivated intermediate(or advanced beginner, I suppose?) haskeller should be capable of writing a compiler like that
02:05:21 <merijn> Instead of requiring you to be a supergenius hacker
02:06:06 <tdammers> fwiw, my first haskell project was a sheet music processor / engraver, which architecturally pretty much boils down to a compiler
02:06:15 <tdammers> parse, transform AST, write output
02:07:46 * dramforever gives up and reads about paredit-mode
02:09:19 <u-ou> merijn: what about the recommendations here? http://purelytheoretical.com/sywtltt.html
02:15:15 <dramforever> wow, wasn't disappointed
02:15:31 <merijn> u-ou: Probably good, I went to OPLSS it's a very good summer school, but it involves a lot more reading than just TaPL :)
02:15:43 <Profpatsch> Can I do something like
02:15:56 <Profpatsch> data T = T Int deriving (Coercible)
02:16:01 <merijn> u-ou: tbh I think you can start in TaPL with minimal knowledge. It starts at basic lambda calculus and build up from there
02:16:27 <merijn> Profpatsch: You can't derive Coercible, also what would that be Coercible too?
02:16:29 <dramforever> Profpatsch: no, Corecible is automagic
02:16:35 <u-ou> merijn: ok =)
02:17:01 <merijn> u-ou: It'd help if you've seen lambda calculus before, but it's not necessary (it's all explained, but if you've seen it before the refresher is good)
02:17:27 <merijn> u-ou: It basically goes: lambda calculus -> simply typed lambda calculus -> increasingly more complex extensions/features
02:17:43 <merijn> And includes evaluators/type checkers for almost all of them
02:18:05 <Profpatsch> dramforever: Oh, ok, so it should always be possible to do (coerce (T 5)) == 5
02:18:08 <u-ou> ahh
02:18:23 <u-ou> merijn: lambda calculus was another thing i wanted to look into
02:18:25 <dramforever> Profpatsch: In this case it should *never* be possible to do that
02:18:36 <dredozubov> Profpatsch: it's not possible
02:18:44 <dramforever> Corecible is for types that have the same representations
02:18:46 <merijn> Profpatsch: No, you can't safely coerce "data" types
02:18:48 <dredozubov> it would be, if T is a newtype
02:18:50 <dramforever> like newtype T = T Int
02:19:00 <Profpatsch> Ah, Ok.
02:19:06 <dramforever> Profpatsch: not the same as "convert", if you are used to that sorts of things
02:19:19 <Profpatsch> So I can completely skip the unwrapping function.
02:19:22 <Profpatsch> Nice.
02:19:41 <dredozubov> dramforever: coerce is like saying "this thing looks like this thing at runtime, i swear"
02:20:00 <dramforever> dredozubov: i swear -> i know it, ftfy
02:20:31 <dredozubov> you have to swear to the compiler
02:20:41 <dramforever> sort of
02:20:44 <dredozubov> otherwise it won't work
02:21:10 <Profpatsch> So I can completely skip finding names for unwrappers now.
02:21:17 <Profpatsch> And just use coerce every time.
02:21:57 <dredozubov> yes, you can
02:21:59 <merijn> dredozubov: No, unsafeCoerce is "I swear"
02:22:03 <merijn> dredozubov: coerce is safe
02:22:07 <merijn> That's the entire point
02:22:13 <Profpatsch> And if I want to do an implicit coercion I use lens’ Isomorphisms.
02:22:17 <dredozubov> merijn: unsafeCoerce is ", i said"
02:22:54 <dredozubov> Profpatsch: another way is to use prisms, if you're using lenses
02:23:09 <dramforever> merijn: I got interested in tapl now... Is it a book on the basics of an implementation of a FP language? If so I might start looking into it
02:23:19 <Profpatsch> dramforever: How are they different from Isos?
02:23:21 <dredozubov> it's type theory 101
02:23:48 <dredozubov> not a book on implementing languages
02:24:02 <f-a> hello, has anyone here submitted an entry for hcar? I need help with drating mine (tex problems)
02:24:06 <dramforever> dredozubov: oh good to know. I'm just more interested in the evaluators and compilers
02:24:08 <dredozubov> if you don't have a clue about parsing/compilation - you still won't after tapl
02:25:11 <dredozubov> if you'll feeling like training on the imperative language, you can try dragon book
02:25:25 <dredozubov> you're*
02:25:33 <tdammers> I think the dragon book is still a good intro for non-imperative languages
02:25:40 <dramforever> nah, not really *that* into it
02:25:54 <m1dnight_> Im trying to use HUnit but the package cant be found, so it seems. Or the module, rather. I have a cabal sandbox and succesfuly installed Hunit `cabal install hunit` but in the repl I can not load `import HUnit`
02:25:58 <m1dnight_> any tips?
02:26:03 <tdammers> in essence, it really boils down to parse -> transform AST -> write output though
02:26:21 <dredozubov> tdammers: in away that it introduces all the basic steps and parsing techniques?
02:26:25 <dredozubov> yeah, ok
02:26:45 <tdammers> I think so, yes. It's been a while since I looked at it
02:26:51 <m1dnight_> dramforever: simon peyton jones wrote an ancient book on the implementation of functioal languages
02:27:12 <dredozubov> m1dnight_: :set -package hunit
02:27:12 <m1dnight_> Its an old book, but still relevant.
02:27:14 <nani___> m1dnight_ are you loading the repl with cabal repl?
02:27:17 <tdammers> enough for you to figure out the magic google incantations at least
02:27:17 <m1dnight_> yes
02:27:19 <m1dnight_> cabal repl.
02:27:32 <dredozubov> you have to add hunit to the .cabal file
02:27:37 <m1dnight_> also did that
02:27:51 <merijn> dramforever: It focuses mostly on type checking
02:27:53 <dramforever> m1dnight_: don't worry, I'm just interested, but not really into it
02:28:04 <dramforever> merijn: oh good to know that too
02:28:10 <merijn> dramforever: It has simple interpreters, but doesn't do anything in terms of compilation/optimisation
02:28:23 <m1dnight_> oh yeah, I had to add "HUnit" to cabal, instead of "hunit"
02:28:42 <dredozubov> m1dnight_: yes
02:28:45 <merijn> dramforever: But for the "how do I implement typechecking" part of implementing functional language (or even any language) it's probably the best book
02:29:11 <merijn> dramforever: It also covers structural subtyping, inheritance, impredicativity, etc.
02:29:11 <dramforever> merijn: from now on you can just assume I replied "oh good to know" to every message you send that you find appropriate
02:29:14 <m1dnight_> http://termbin.com/mcmg <- this is the output of `cabal install hunit`
02:29:17 <dredozubov> m1dnight_: anyway if you have something within a sandbox, but not automatically loaded by cabal, you can use :set package <package>
02:29:21 <m1dnight_> which is strange since in lowercase cabal doesnt recognize it.
02:29:28 <m1dnight_> Ill give it a shot, thanks
02:30:03 <m1dnight_> ugh, cabal repl says hunit is missing -_-
02:30:08 <m1dnight_> what is this for sorcery
02:30:09 <dredozubov> speaking of impredicativity
02:30:26 <dredozubov> i wonder if we'll get sane impredicative types in haskell sometime
02:31:11 <m1dnight_> Doesnt seem to work, dredozubov 
02:31:36 <dredozubov> you have to type "HUnit", i thinke
02:31:40 <dredozubov> think*
02:31:43 <m1dnight_> I tried both of them :<
02:32:11 <m1dnight_> `import qualified Distribution.TestSuite.HUnit as CabalHUnit` this is what I see on SO etc
02:32:18 <dredozubov> do you have it installed?
02:32:21 <m1dnight_> yes
02:32:24 <dredozubov> or just added to .cabal
02:34:47 <m1dnight_> http://pastebin.com/raw.php?i=M24QQ48y
02:35:00 <m1dnight_> So from all that info, it seems to me that it should work 
02:37:12 <merijn> m1dnight_: Try running with -v3 for more verbose errors?
02:39:43 <m1dnight_> I solved it. import Test.HUnit instead of import HUnit 
02:39:49 <m1dnight_> damn you, documentation!
02:41:16 <dredozubov> open a PR!
02:44:58 <saulzar_> Does anyone know how to get ghc to give the full name in a heap profile? I see things like this (616)triggerFrame/readSche...>17832
02:52:11 <plojtvopzo> hi
02:55:29 <CoconutCrab> ummm, I am having a bit of problem with installing hakyll on an arm board (armv7). Currently cabal-install is compiling highlighting-kate, consuming 1.8 GBs of RAM and 1.7 GBs of swap 
02:55:41 <CoconutCrab> is it normal for ghc on ARM to consume that much memory?
02:56:28 <merijn> CoconutCrab: GHC consumes a lot of memory on almost any platform
02:56:45 <CoconutCrab> sigh
02:56:48 <uncurried> What data type or library should i use to work with matrix? 
02:57:10 <CoconutCrab> my arm box only has 2 GBs of RAM, maybe I should go with cross compiling
02:58:55 <dramforever> CoconutCrab: consider using -j1 to slow it down
02:59:41 <dramforever> um...make it only run one compiing job, so that it takes less RAM
03:00:21 <CoconutCrab> dramforever: er.. I am going with cabal install highlighting-kate --ghc-options='-O0' --jobs=1
03:00:27 <CoconutCrab> it is painfully slow though
03:00:52 <CoconutCrab> I was using --jobs=4 before, the compilation failed due to out of memory
03:04:30 <roseniki> I want to answer JSON queries posed via TCP by another program on the same machine written in another language. What library should I use/is there already a tutorial for this usecase?
03:05:21 <tdammers> raw TCP sockets?
03:05:23 <tdammers> or HTTP?
03:05:54 <tdammers> the go-to JSON encoding/decoding library is aeson
03:06:32 <tdammers> a nice option for quickly pumping out a JSON-over-HTTP API without thinking too much about the nitty-gritty is Scotty
03:08:32 <roseniki> kthx
03:12:41 <sinelaw> hi, I'm getting Exception: expectJust checkFamInstConsistency
03:12:53 <sinelaw> in ghci, but no error from ghc
03:21:25 <meditans> hi, I have a question on functional dependencies: I have a `class IsRelation a as | a -> as, as -> a where`
03:21:25 <meditans>  
03:21:46 <meditans> and a bunch of instances like `instance IsRelation (a0, a1) '[a0, a1] where`
03:21:56 <meditans> or `instance IsRelation (a0, a1, a2) '[a0, a1, a2] where`
03:22:20 <meditans> they can all coexist, but when I add: `instance IsRelation a0 '[a0] where`
03:22:20 <meditans>  
03:22:37 * hackagebot sync-mht 0.3.8.2 - Fast incremental file transfer using Merkle-Hash-Trees  https://hackage.haskell.org/package/sync-mht-0.3.8.2 (emink)
03:22:39 <opqdonut> that's because a0 could well be (x,y)
03:22:48 <meditans> suddently I get functional dependencies conflict between declarations
03:23:14 <opqdonut> the instance you're trying to get is something like "a0, where a0 is not a tuple"
03:23:35 <meditans> opqdonut: you're right, is there a way to write that?
03:23:42 <opqdonut> not really
03:23:51 <meditans> (I could also drop that instance, is not really necessary)
03:24:11 <meditans> opqdonut: thanks for the help! :)
03:24:15 <opqdonut> you could use a "newtype Single a = Single a" and then write "instance IsRelation (Single a0) '[a0] where"
03:24:21 <opqdonut> or somethign to that effect
03:24:35 <opqdonut> haskell doesn't have tuples of length 1, otherwise you could use those :)
03:25:12 <meditans> this was probably the reason package tuple-hlist used a package named onetuple
03:25:29 <opqdonut> ah there's a package for it :)
03:26:02 <meditans> yeah, I didn't realize that was the problem it was trying to solve
03:34:07 <ski> @type (# False #)
03:34:08 <lambdabot> (# Bool #)
03:34:17 <ski> @type (# False,() #)
03:34:18 <lambdabot> (# Bool, () #)
03:34:24 <ski> @type (# #)
03:34:26 <lambdabot> (# #)
03:36:54 <quicksilver> I use Identity as a 1-tuple sometimes
03:36:58 <quicksilver> it's a bit verbose
03:49:08 <jophish> merijn: have you got a link to that "optional constraints" package? The one where one can call a different function is a type satisfies a constraint
03:49:24 <jophish> (I think it was you who was talking about it)
03:49:44 <Taneb> > let loeb x = go where go = fmap ($ go) x in tail . loeb $ const 1 : map (fmap sum . take) [0..]
03:49:46 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
03:51:51 <Radivarig> can I fallthrough with pattern match? to have > 1 consecutive matches return the same error 
03:52:36 <m1dnight_> Sorry to bother you guys again but Im trying to setup the `cabal test` command and the documentation is all over the place again.
03:52:47 <m1dnight_> From what I can tell I have HUnit tests, and they have to be converted to cabal tests, right?
03:52:47 <Taneb> Radivarig: no, that is not possible
03:53:06 <Taneb> Radivarig: you can however use _ to match many patterns at once, which may be helpful
03:53:16 <joco42> if i want to pass --prof to ghc when i have a cabal project then where should i put --prof ? i wanna debug a !! : index too large exception
03:53:29 <joco42> following this https://wiki.haskell.org/Debugging
03:54:47 <jophish> joco42: This is a good resource for that: https://nikita-volkov.github.io/profiling-cabal-projects/
03:54:55 <joco42> jophish:  thanks
03:54:59 <merijn> jophish: ifCxt?
03:55:30 <Radivarig> Taneb, instead of two matches I used _ at the end and it works, thx
03:55:31 <jophish> that's the one
03:56:51 <jophish> merijn: do you have a link, google isn't helping much
03:57:32 <merijn> https://github.com/mikeizbicki/ifcxt#ifcxt
03:58:13 <jophish> thanks again!
04:08:44 <there_is_a_path> grep >
04:41:47 <Profpatsch> Does somebody know what these Constants represent? https://hackage.haskell.org/package/ghc-paths-0.1.0.9/docs/src/GHC-Paths.html
04:41:55 <Profpatsch> Environment Variables? #defines?
04:43:48 <f1u77y> did you notice {-# LANGUAGE CPP #-}
04:43:58 <Profpatsch> f1u77y: Yes, that’s why I’m asking3
04:44:48 <Profpatsch> I’m not sure where those are defined. Or does the docs-source (https://hackage.haskell.org/package/ghc-paths-0.1.0.9/docs/src/) simply not show the C-files?
04:45:25 <Profpatsch> Wait CPP is the C-Preprocessor.
04:45:30 <f1u77y> these are defines, because environment variables are got in another way
04:46:16 <opqdonut> https://github.com/simonmar/ghc-paths/blob/master/Setup.hs
04:46:22 <opqdonut> that's where they're defined
04:47:11 <Profpatsch> Argh, you must be shitting me.
04:47:17 <Profpatsch> That’s just plain evil.
04:47:19 <rtpg> is there a guide anywhere to using stack with an existing project?
04:47:28 <m1dnight_> Does anyone have a cabal project with HUnit I can have a look at?
04:47:30 <liste> rtpg cabal project?
04:47:37 <m1dnight_> Im getting frustrated with the divergence in documentation..
04:47:41 * hackagebot glue-common 0.4.6 - Make better services and clients.  https://hackage.haskell.org/package/glue-common-0.4.6 (seanparsons)
04:47:41 <rtpg> yes
04:47:43 * hackagebot glue-core 0.4.6 - Make better services and clients.  https://hackage.haskell.org/package/glue-core-0.4.6 (seanparsons)
04:47:45 * hackagebot glue-example 0.4.6 - Make better services and clients.  https://hackage.haskell.org/package/glue-example-0.4.6 (seanparsons)
04:47:47 * hackagebot glue-ekg 0.4.6 - Make better services and clients.  https://hackage.haskell.org/package/glue-ekg-0.4.6 (seanparsons)
04:47:47 <liste> rtpg stack init should work with existing cabal projects
04:47:58 <phadej> rtpg: https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md#existing-projects
04:48:43 <rtpg> thanks :)
04:48:57 <f1u77y> Profpatsch: why do you think that's plain evil?
04:49:47 <Profpatsch> f1u77y: Because it makes things go awry.
04:50:03 <Profpatsch> f1u77y: There is not only one ghc on a system.
04:50:26 <Profpatsch> There’s probably 50 ghcs on mine, each with another library path.
04:50:41 <quicksilver> indeed, but those constants are used for one particular GHC
04:50:46 <merijn> Profpatsch: So? Cabal will query whichever GHC you're using to compile
04:50:50 <quicksilver> each other GHC will have its own different onces.
04:50:50 <f1u77y> different ghcs has different path
04:51:00 <f1u77y> *paths
04:51:14 <quicksilver> most cabal and GHC developers also have more than one GHC on their system :)
04:51:21 <quicksilver> so it's not like they don't need this to work right themselves.
04:51:52 <merijn> Why would you not hardcode the GHC paths? You can't switch them dynamically in a sensible way anyway
04:53:00 <Profpatsch> merijn: Except it destroys the abstraction.
04:53:13 <merijn> Profpatsch: Which abstraction?
04:53:40 <Profpatsch> e.g. I have taffybar compiled with GCC a.
04:54:19 <Profpatsch> Which is a GCC who only knows about the dependencies of taffybar.
04:54:22 <merijn> Profpatsch: Do you have multiple installs of the same version of GHC?
04:54:30 <Profpatsch> merijn: Yes.
04:54:41 <Profpatsch> Okay, so GCC a compiles taffybar.
04:54:44 <merijn> o.O Why?
04:54:48 <quicksilver> the compiler is called GHC :)
04:54:50 <Profpatsch> Now taffybar uses dyre.
04:54:54 <Profpatsch> Ah, of course.
04:55:20 <Profpatsch> When I start taffybar, dyre recompiles the configuration in my homefolder.
04:55:46 <Profpatsch> For that it calls a GHC; which GHC you ask? Of course GHC a.
04:56:14 <Profpatsch> Which does not know about the taffybar library.
04:56:28 <Profpatsch> yay.
04:56:47 <quicksilver> you're confusing more than one GHC with more than one library set
04:57:05 <quicksilver> there are lots of excellent reasons to have multiple library sets - stack and cabal sandboxes are two ways to do that
04:57:17 <merijn> Yeah, I don't see the point of having multiple identical GHC versions instead of multiple different library sets
04:57:17 <quicksilver> in general those reasons don't require to you have multiple GHCs
04:57:30 <quicksilver> GHC is not binary compatible with itself
04:57:34 <quicksilver> it has no fixed ABI
04:57:45 <Profpatsch> quicksilver: Well, there is not really a difference between multiple library sets and multiple GHCs on nixos.
04:57:51 <quicksilver> so it makes no effort to make it possible to reuse object files from other versions.
04:58:04 <quicksilver> to do so would be to invite segfaults
04:58:31 <quicksilver> your probably simply sounds like dyre can't see the right library path
04:58:48 <quicksilver> make sure dyre is running with the right environment to see the taffybar library?
04:58:49 <m1dnight_> I have written a testsuite entry in my .cabal file and I have configured it properly, I think but it wont execute. It says the test suite has not been built.
04:58:51 <Profpatsch> quicksilver: Then forget I said multiple GHCs, it’s probably just multiple library sets.
04:59:16 <Profpatsch> quicksilver: Yeah, except it’s decided at compile time of taffybar.
04:59:22 <Profpatsch> Which is exactly my point.
05:00:01 <Profpatsch> Which is why this: https://github.com/simonmar/ghc-paths/blob/master/Setup.hs is a really bad hack.
05:02:30 <obadz> y :: Integer ; y = 2^3 triggers warning: Defaulting the following constraint(s) to type ‘Integer’
05:02:38 <obadz> I'm sure there's a good reason but can't see what it is?
05:02:54 <obadz> also is there a cleaner way to placate than doing 2^(3 :: Int) ? 
05:02:58 <bennofs> Profpatsch: on NixOS, we patch ghc-paths
05:03:06 <merijn> :t (^)
05:03:07 <lambdabot> (Integral b, Num a) => a -> b -> a
05:03:12 <bennofs> Profpatsch: there's NIX_GHC_LIBDIR, NIX_GHC_BINDIR, ... env variables to set those in NixOS
05:03:21 <merijn> obadz: You're only providing enough info to default the result, not the second argument :)
05:03:43 <obadz> merijn: yes, I can see, but 2^(3 :: Int) feels uglier than needed?
05:03:49 <Profpatsch> bennofs: Actually, I remembered something like that and just found the corresponding entry.
05:03:50 <bennofs> Profpatsch: https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/patches/ghc-paths-nix.patch
05:04:26 <Profpatsch> bennofs: Only it broke for me when I tried compiling a changed taffybar version myself.
05:04:32 <merijn> obadz: Any other solution (besides ignoring the warning) will be even uglier :p
05:04:33 <Profpatsch> bennofs: Not sure why, though.
05:04:44 <obadz> merijn: ok :)
05:06:03 <Profpatsch> bennofs: It’s a shame Peter already left the Nixos sprint yesterday, he could have told me directly.
05:06:08 <Profpatsch> meh.
05:06:20 <bennofs> Profpatsch: #nixos :)
05:07:34 <Profpatsch> bennofs: What’s his username there?
05:08:03 <bennofs> Profpatsch: peti. You can also ping me if you've got Haskell questions, I think I'm pretty deep in Haskell nixos now :)
05:10:00 <chris2> does the ghc llvm backend generate llvm code as text file?
05:47:42 * hackagebot process 1.4.1.0 - Process libraries  https://hackage.haskell.org/package/process-1.4.1.0 (MichaelSnoyman)
05:53:40 <bennofs> chris2: if you want to view the LLVM, I think you can use -ddump-llvm
05:55:11 <chris2> i wonder how it actually generates the code
05:55:21 <chris2> since it doesnt seem to link against llvm
05:56:21 <bennofs> chris2: Yeah, I think it calls the llvm binaries iirc
05:57:02 <chris2> ok
06:13:06 <mnoonan> Is there something to fill in the blank here?  "A ____ category is to an applicative functor as a Kleisi category is to a monad"
06:15:37 <quicksilver> without join you can't compose them
06:15:43 <quicksilver> so, I don't think so.
06:16:34 <mnoonan> that makes sense. I was fiddling around with recursion schemes to get rid of some boilerplate last night, and I could write
06:17:08 <mnoonan> cataM :: Monad m => (ExprF t -> m t) -> Expr -> m t
06:17:46 <mnoonan> which looked like a nice generalization of cata :: (ExprF t -> t) -> Expr -> t to a Kleisi category
06:18:25 <mnoonan> and I could write a cataA :: Applicative m => m (ExprF t -> t) -> Expr -> m t, but that didn't quite feel as natural
06:32:44 * hackagebot exact-real 0.4.0.0 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.4.0.0 (jophish)
06:42:28 <anks> Hi, i've got function that depending on the value returns F Word, or F Int16, or F Word8, etc, and i need it to have type: Show a => Something -> F a, is it possible?
06:42:59 <opqdonut> anks: nope
06:43:15 <opqdonut> anks: because the return type is F a, it means the _caller_ can decide what type he gets out
06:43:46 <anks> but im only interested in having an instance of Show ..
06:43:57 <opqdonut> then just return the string :)
06:44:34 <opqdonut> (or use existential types: https://wiki.haskell.org/Existential_type )
06:44:44 <Cale> Yeah, there's essentially no difference between some value which you don't know what type it is except that it's some instance of Show, and a String.
06:45:15 <Cale> Because pretty much all you can legally do with such a value is to apply show (or showsPrec or something) to it.
06:45:36 <anks> yea, but then ill have to strip " ", and so i thought maybe i could just return restricted polymorphic value
06:45:47 <anks> or write special case for strings
06:45:51 <Cale> What's this about stripping whitespace?
06:46:08 <anks> no
06:46:09 <anks> quotes
06:46:14 <Cale> quotes?
06:46:21 <Cale> There won't be quotes in the string.
06:46:31 <Cale> Unless you apply show again
06:46:38 <anks> And i am ;]
06:46:41 <anks> i do
06:46:55 <Cale> when?
06:47:20 <anks> then, i've got a function that takes Show a -> f a -> IO() or w/e
06:47:32 <opqdonut> anks: why do you even bother returning different widths? why not just return Integer?
06:47:37 <opqdonut> (or Int perhaps)
06:47:37 <anks> anyway i was also interested in general approach, and i think what i meant was existential types
06:47:53 <quicksilver> yes you can return existential types.
06:47:54 <Cale> Existential types are not a solution to this problem :P
06:48:00 <quicksilver> for any particular problem you might identity
06:48:05 <quicksilver> existential types are the wrong solution
06:48:13 <quicksilver> [*] with 99.95% certainty :)
06:48:32 <ARM9> what's the actual problem?
06:48:37 <Cale> Yeah, I'm not sure I'd go that far, but with the extra qualifier about probability, maybe
06:48:42 <ARM9> because the original question sounds xy-ish
06:48:44 <bernalex> Hijiri: there by any chance?
06:49:06 <bernalex> anyway... givent data NonDetermTree a = EmptyND | Leaf a | Branch (NonDetermTree a) (NonDetermTree a) -- what's a sensible monad?
06:49:27 <bernalex> the Applicative I wrote: instance Applicative NonDetermTree where pure = Leaf; EmptyND <*> _ = EmptyND; Leaf f <*> t  = fmap f t; (Branch l r) <*> t = Branch (l <*> t) (r <*> t)
06:49:51 <Cale> bernalex: Well, did you try just writing (>>=) case by case?
06:49:53 <opqdonut> bernalex: join seems pretty natural in this case
06:50:01 <Cale> The Monad instance for that is entirely obvious.
06:50:04 <anks> I am a bit unsatisfied with this string conversion :
06:50:10 <opqdonut> bernalex: join :: NonDetermTree (NonDetermTree a) -> NonDetermTree a, that is
06:50:21 <quicksilver> Cale: maths question; do you happen to know if there is a theory for 'monoidal' functions over measurable sets? With the property that f(U u V) = f(U) <> f(V) if U and V are disjoint? It seems like an obvious thing but I failed to google it.
06:50:26 <Cale> It'll fall out immediately as you think through what type of thing you need to produce in each case
06:50:51 <quicksilver> integration is one such function (viewed as a function on domain)
06:51:11 <Cale> quicksilver: Yeah, I don't know about with an arbitrary monoid operation
06:51:40 <quicksilver> I was trying to find a generalisation of the haskell reducers stuff
06:51:46 <Cale> But it's easy to see that the monoid has to be commutative.
06:51:53 <quicksilver> which lets you apply monoids over fairly arbitrary stuff
06:51:56 <byorgey> bernalex: that Applicative instance seems weird to me, but I am having trouble deciding whether it is actually invalid
06:52:05 <quicksilver> Cale: nod
06:52:06 <anks> thanks though
06:52:09 <bernalex> byorgey: do expand. I'd hate for it to be wrong!
06:52:10 <Cale> Or at least, the image of f has to lie in its centre
06:52:15 <aweinstock> :t flip ((join .) . fmap) `asTypeOf` (>>=) -- bernalex
06:52:16 <lambdabot> Monad m => m a1 -> (a1 -> m a) -> m a
06:53:00 <quicksilver> Cale: there is non-commutative version with a strong side condition on U and V
06:53:16 <Cale> byorgey: Nah, it's fine. This is just like the list instance, only more tree-like :)
06:53:24 <quicksilver> Cale: you only apply the law if U is "adjacent to" V and "strictly lower"
06:53:53 <byorgey> bernalex: note e.g.   EmptyND <*> Branch EmptyND EmptyND = EmptyND   but   Branch EmptyND EmptyND <*> EmptyND = Branch EmptyND EmptyND
06:53:58 <quicksilver> which requires a one-dimension kind of measure
06:54:01 <bernalex> Cale: that was the intention at least.
06:54:39 <Cale> Oh, yeah, the Branch case is weird though, haha
06:54:52 <byorgey> at the very least you need another case   _ <*> EmptyND = EmptyND
06:54:55 <bernalex> byorgey: right. what would be preferable do you think?
06:54:57 <Cale> yeah
06:55:09 <bernalex> yeah I actually had that. IDK where that line went. :]
06:55:11 <byorgey> but as Cale says I am also unsure about the Branch case
06:55:35 <Cale> There should be an Applicative instance. It's more easy to write the Monad instance correctly first, and then figure out how Applicative should behave in terms of it :P
06:55:52 <byorgey> hehe, agreed =)
06:56:02 <byorgey> the Monad instance is just grafting new trees at the leaves
06:56:03 <quicksilver> it attaches a tree of results at each function
06:56:14 <quicksilver> the applicative is like that too, byorgey 
06:56:26 <quicksilver> at each function `f` you graft the entire tree of `f` applied to the right-hand tree
06:56:37 <byorgey> OK, right, fair enough
06:57:30 <byorgey> Yes, in that case I guess the Branch case is fine, it's just the missing  _ <*> EmptyND case
06:58:14 <bernalex> Cale: ok do you agree with
06:58:17 <bernalex>   EmptyND      >>= _ = EmptyND
06:58:19 <bernalex>   Leaf x       >>= f = f x
06:58:21 <bernalex> ?
06:58:39 <byorgey> after all these years of Haskelling, teaching five courses in which I introduce Applicative before Monad, etc., and I *still* have better intuition for Monad than for Applicative o.O
06:58:59 <Cale> I still believe Monad should be taught first
06:59:12 <byorgey> Cale: interesting, why is that?
06:59:14 <Cale> (perhaps after Functor, but before Applicative)
06:59:21 <byorgey> sure
07:00:05 <opqdonut> I think applicative is hard because "ap" is a bit unnatural
07:00:09 <bernalex> and I suppose (Branch (Leaf l) (Leaf r)) >>= f = Branch (f l) (f r)
07:00:14 <opqdonut> e.g. a tree of functions in this case
07:00:21 <opqdonut> whereas join and >>= are quite natural
07:00:23 <Cale> There are few things which are instances of Applicative but not Monad, and also comparatively fewer things which are written in terms of an arbitrary Applicative.
07:00:27 <quicksilver> applicative for fixed-length vectors is natural
07:00:32 <byorgey> bernalex: you need to just define  Branch l r >>= f
07:00:37 <quicksilver> data Four a = Four a a a a
07:00:39 <quicksilver> for example
07:00:41 <bernalex> and therefore (Branch l r) >>= f = Branch (l >>= f) (r >>= f)
07:00:44 <byorgey> bernalex: but yes, your equation is correct
07:00:47 <byorgey> bernalex: right
07:01:01 <mnoonan> You can talk about the monad operations all at a boring-value level, without needing to hit any function-values with a functor.
07:01:04 <bernalex> byorgey: yes I was writing out the separate cases to get down to the solution, as Cale suggested.
07:01:04 <quicksilver> it seems to me that Four is a natural Functor and a natural Applicative and an unobvious Monad
07:01:13 <byorgey> bernalex: OK, nice
07:01:40 <Iceland_jack> quicksilver: It is
07:01:47 <byorgey> quicksilver: agreed
07:02:41 <bernalex> anyone have any ideas how to demonstrate the utility of this monad?
07:02:46 <byorgey> Cale: There are lots of things written in terms of an arbitrary Applicative.
07:03:05 <Cale> byorgey: ehhhh... there's a bunch of lensy stuff
07:03:05 <byorgey> Cale: and many of the things written in terms of an arbitrary Monad should have instead been written in terms of an arbitrary Applicative.
07:04:01 <quicksilver> there is a sense in which "things-like-traverse" is everything you ever want to do with Applicative
07:04:34 <quicksilver> similarly there is a sense in which "things-like-foldMap" is everything you ever want to do with Monoid
07:05:05 <quicksilver> and it turns out that the lens library made a good stab at formalising "things-like-traverse" and "things-like-foldMap"
07:05:13 <Cale> Sure
07:05:39 <quicksilver> pun intended.
07:05:46 <Cale> Maybe we could agree that if you know Monad but not Applicative, you'll be much better off in terms of what you can accomplish than if you know Applicative but not Monad?
07:05:49 <byorgey> hehe
07:06:02 <quicksilver> it's not intended to seem limiting, because those "things" are large and interesting groups of things.
07:06:09 <byorgey> Cale: I agree with you there
07:06:26 <Cale> I still think about what (<*>) does in terms of ap
07:06:31 <quicksilver> reducers was a previous attempt at "things-like-foldMap"
07:06:37 <Cale> most of the time
07:06:48 <quicksilver> coincidentally another edwardk production.
07:07:52 <byorgey> Cale: My sense is just that students become comfortable with Applicative + Monad  more quickly if you teach them in that order.  Obviously I have no particular evidence for this assertion.
07:08:05 <byorgey> other than anecdotal/intuitive.
07:08:10 <quicksilver> you should test it.
07:08:22 <Cale> It's much easier to understand (<*>) at first (and often in general) if you can just say that it means "run the computation on the left, and then the computation on the right, and apply the resulting function to the resulting value"
07:08:28 <lyxia> test it with quickcheck?
07:08:34 <quicksilver> split the class in half, teach one half one way and one half the other way
07:08:44 <byorgey> quicksilver: hehe
07:08:50 <quicksilver> make it a blind test, don't use the words 'Applicative' or 'Monad' but make up two arbitrary new words
07:08:51 <Cale> That's not always appropriate unfortunately, but it's pretty close, and it's appropriate in most instances.
07:08:58 <quicksilver> make it double-blind, don't even tell yourself which is which
07:09:02 <Cale> lol
07:09:02 <quicksilver> good luck with the teaching tho
07:09:08 <Cale> double blind
07:09:09 <byorgey> quicksilver: this is sounding better and better
07:09:25 <byorgey> "Today we are going to learn about Flurbles, whatever THOSE are"
07:09:26 <quicksilver> well I read your slides, so i thought this would go well with your teaching style :)
07:09:35 <Cale> woooow
07:09:41 <Cale> burn
07:09:56 <quicksilver> I hope it doesn't really seem so. I'm just being daft.
07:10:07 <byorgey> ...I don't get it =)
07:10:36 <Cale> byorgey: i.e. he's saying that your slides make it seem like you don't know what you're talking about
07:11:25 <quicksilver> for the record, I like byorgey's course and I often recommend it to people.
07:11:33 <Cale> Me too
07:11:34 <quicksilver> teaching is hard, and interesting.
07:11:44 <quicksilver> I certainly don't know the best way(s) to do it.
07:11:44 <Cale> Though it would be good to get some patches in
07:11:44 <byorgey> Cale: my course doesn't even have slides =)
07:12:19 <byorgey> yes, I have been thinking about setting up a github repo with the course content so the community could better collaborate on keeping it up-to-date
07:13:04 <Cale> byorgey: There's a point where your lectures refer to mapIntList, but never define it, and I've seen so many people trip over that
07:13:19 <byorgey> I believe it.
07:14:00 * byorgey resolves to make a github repo TODAY
07:14:03 <Cale> I figured it was something you did on a blackboard or something during the lecture
07:14:14 <byorgey> Cale: it may have been.  More likely it is just a mistake.
07:15:20 <quicksilver> byorgey: what do you use to format the haskell code fragments in your blog?
07:16:03 <byorgey> quicksilver: BlogLiterately -> pandoc -> highlighting-kate
07:16:12 <quicksilver> (funny how many of your blog posts use this diagrams package)
07:16:21 <byorgey> fancy that
07:16:33 <quicksilver> ooh hadn't heard of BlogLiterately
07:16:33 <quicksilver> thanks
07:16:51 <byorgey> you hadn't?  huh, maybe I should advertise more =)
07:17:01 <quicksilver> well I've been away for a few years
07:17:07 <byorgey> quicksilver: OK, fair enough
07:17:38 <byorgey> quicksilver: for diagrams there is  BlogLiterately-diagrams  which includes a diagrams plugin on top of BlogLiterately.  You just include inline diagrams code in your markdown
07:17:54 * quicksilver just read that in the manual :)
07:17:57 * hackagebot clash-lib 0.6.5 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.5 (ChristiaanBaaij)
07:17:59 <byorgey> =)
07:18:24 <byorgey> so each of my blog posts is produced from a single source document, and running BlogLiterately-diagrams automatically compiles the diagrams and uploads everything to wordpress
07:18:44 * quicksilver nods
07:19:04 <byorgey> quicksilver: if you want to see some examples, http://hub.darcs.net/byorgey/byorgey-wordpress
07:20:01 <quicksilver> the [ghci] specials are cute
07:20:16 <quicksilver> but I was considering using org-babel for that
07:20:23 <frerich> byorgey: Reading http://hub.darcs.net/byorgey/byorgey-wordpress/browse/2015-11-Dorroh/dorroh.markdown and assuming that's a draft, I think it would be fun if you would keep the drafts around just for laughs and spying your brain
07:20:31 <frerich> 'The answer is yes, using Dorroh extension. Definition. What the heck? '
07:20:51 <byorgey> frerich: well, it's a darcs repo, so the history is all there for anyone to see =)
07:21:08 * frerich reads 'hemiring' and is ashamed to admit that his first thought is about muscle cars
07:21:23 <frerich> Like a club of muscle car owners. A hemiring.
07:21:47 * byorgey had to google 'hemi' in that context
07:22:45 <byorgey> quicksilver: yes, org-babel will probably work for that too
07:22:57 * hackagebot clash-systemverilog 0.6.3 - CAES Language for Synchronous Hardware - SystemVerilog backend  https://hackage.haskell.org/package/clash-systemverilog-0.6.3 (ChristiaanBaaij)
07:22:59 * hackagebot clash-verilog 0.6.3 - CAES Language for Synchronous Hardware - Verilog backend  https://hackage.haskell.org/package/clash-verilog-0.6.3 (ChristiaanBaaij)
07:23:01 * hackagebot clash-vhdl 0.6.4 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.6.4 (ChristiaanBaaij)
07:23:03 * hackagebot clash-ghc 0.6.5 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.5 (ChristiaanBaaij)
07:24:45 <quicksilver> byorgey: so many choices to investigate and experiment with to put off actually writing an article
07:24:53 <byorgey> hehe
07:26:34 <mnoonan> Just fishing a bit: are there any experts on automatic structures here (e.g. automatic semigroups and the like)?
07:34:06 <byorgey> mnoonan: I am not, but since I had not heard of automatic (semi)groups I googled them and am already fascinated =)
07:35:22 <mnoonan> byorgey: I had several friends in grad school doing things related to automatic groups, and I was always a little jealous :)
07:37:49 <mnoonan> I'm working on something now where I think the right generalization needs an automatic structure kind of like a semigroup, but with an order relation instead of equality
07:58:32 <jophish> Why does readFloat have a constraint on RealFrac and not Fractional?
08:09:42 <bollu> soo I implemented callCC
08:09:45 <bollu> now how do I use it?
08:09:46 <bollu> >_<
08:10:00 <bollu> like, I got a valid instance that "makes sense" for callCC
08:10:07 <bollu> but I have no idea as to how to use it
08:10:39 <bollu> callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a is what I was able to write a valid function definition for. Now I want to know how to *use* it
08:11:27 <johnw> bollu: cool!
08:11:34 <johnw> bollu: so, here's a quick primer
08:11:42 <johnw> callCC $ \k -> ...
08:12:01 <johnw> "k" is what would have happened, if the callCC hadn't been there at all.  I.e., it refers to all the code "after" the callCC
08:12:20 <johnw> you call it with a value.  OR, you "return" that value from the whole callCC block, they mean the same thing
08:12:35 <johnw> so you can imagine an implicit call to k with the value of the callCC action at its very end
08:12:56 <bollu> okay, hm, I think I'm with you so far
08:13:40 <johnw> thus: do { x <- callCC $ \k -> k 10 ; return $ x + 10 }
08:13:44 <johnw> that whole action results in "20"
08:13:51 <johnw> now, why is this cool or useful?
08:14:13 <johnw> because "k" is a value, and you can pass it around, and use it from anywhere within the Cont block that you wish
08:14:22 <lpaste_> lmj pasted “fmap.hs” at http://lpaste.net/145440
08:14:32 <bollu> johnw: wait, what is "k" in this callCC example you gave?
08:14:36 <lmj> lyxia: that's a simplified version of what we discussed yesterday
08:14:42 <johnw> k has type: a -> Cont r b
08:15:13 <bollu> and "x" has type Cont r a?
08:15:19 <lmj> I suppose the lesson is that fmap can't be tricked with indirection
08:15:19 <johnw> x has type 'a'
08:15:24 <johnw> no, it has type 'b'
08:15:30 <johnw> in my example a ~ b ~ Int
08:15:57 <johnw> 'k' is the continuation, it's the "rest of the enclosing Cont block"
08:16:26 <bollu> oh wait, right, x is pulled from the <-. "rest of the enclosing block" meaning the "return $ x + 10 " ?
08:16:33 <johnw> yes
08:16:41 <johnw> the entire action, however large it is
08:17:01 <johnw> in languages like Scheme the "continuation" is the "rest of the program"
08:17:08 <johnw> for Haskell, it's the rest of the Cont action
08:17:12 <quicksilver> you can for example use callCC to implement 'last' or 'break'
08:17:37 <bollu> hm, so the parameter to every callCC function call is the value stored inside the "rest of the program" ? (which is why you get a raw `a` and not a Cont r a)?
08:17:39 <johnw> yeah, callCC lets you take control of sequencing, and implement your own control structures
08:17:57 <johnw> bollu: the parameter to callCC is a function that receives a function
08:17:58 <johnw> :t callCC
08:18:00 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
08:18:09 <quicksilver> x <- callCC $ \break -> ... some long bit of code, possibly including loops etc ..
08:18:16 <johnw> that function, gives an 'a', returns you the remainder of the enclosing Cont action
08:18:20 <quicksilver> if you use 'break' from inside that block it stops early and just returns.
08:18:38 <bollu> johnw: that should be "given an `a`", right?
08:18:39 <johnw> quicksilver: except that your break will need to be passed a value of some kind, unless break in other languages
08:18:46 <quicksilver> yes
08:18:50 <quicksilver> which is even better :)
08:18:51 <johnw> yes, the continuation is a function that requires a value of type 'a'
08:19:10 <quicksilver> it's a bit like an C/Java/perl/javascript 'return' in that sense
08:19:14 <quicksilver> early exit with return value
08:19:25 <bollu> huh
08:19:54 <bollu> hm, wait, but the *total* return value of the callCC is a Cont r a, so in some sense the "b" is swallowed?
08:19:58 <bollu> ignored*
08:20:17 <johnw> the return value of callCC is used for the implicit continuation call
08:20:27 <johnw> imagine that every callCC $ \k -> .... <implied call to k>
08:20:34 <johnw> that's why the action must end with an 'a' and not a 'b'
08:20:47 <johnw> actually calling 'k' is always optional
08:21:06 <quicksilver> bollu: if you use 'k' then what is returned is always the thing you passed to k
08:21:16 <quicksilver> not the return type it claims to have
08:21:31 <johnw> bollu: also, remember that what 'k' returns is the *rest of the Cont block*
08:21:39 <johnw> the rest of the Cont block will end in a different type
08:21:49 <johnw> so my explanation wasn't actually correct
08:21:52 <johnw> let me give you an example
08:23:02 <bollu> callCC $ k, k is a *function*, that takes _another_ function which takes an `a` and returns a `Cont r b`? after which invoking k with the said function returns `Cont r a` correct?
08:23:19 <johnw> bollu: https://gist.github.com/7b52e58b6d73426bbd1b
08:23:26 <johnw> bollu: that outputs "10" and then "30"
08:23:27 <bollu> like k $ s , where s :: a -> Cont r b, k :: (a -> Cont r b) -> Cont r a?
08:24:00 <johnw> bollu: execution starts in the callCC block, then transfers outside the block, then *returns* into the callCC block, then ends at the end of the callCC block.  There is no implied call to 'k', I was very wrong about that.
08:24:33 <johnw> in order for execution to have resumed at the end of the callCC block and flowed into the next block, there would have had to have been a call to 'k' at the end of the callCC
08:25:23 <bollu> johnw: I really don't understand how control flow is taking place :/
08:25:29 <bollu> in the example you gave
08:25:34 <johnw> step through it line by line
08:25:58 <johnw> we enter the do block, then we enter the callCC with an argument that, given an 'a', yields the remainder of the Cont block (everything after the callCC)
08:25:58 <bollu> :x <- callCC:
08:26:03 <jophish> The laws for RealFrac seem broken, for example it says that in (n,f) = properFraction x, n is an integral type with the same sign as x. Observe:
08:26:08 <bollu> right, so when is that executed?
08:26:12 <jophish> > properFraction (-1 :: Float)
08:26:13 <johnw> when you call 'k'
08:26:14 <lambdabot>  (-1,0.0)
08:26:21 <jophish> > properFraction (-0.1 :: Float)
08:26:22 <johnw> it may help to unsugar this do-block
08:26:22 <bollu> and who calls k?
08:26:23 <lambdabot>  (0,-0.1)
08:26:29 <bollu> oh, wait, what?
08:26:32 <johnw> inside the callCC block, the first line calls 'k'
08:26:37 <bollu> yeah, can we desugar it please?
08:26:41 <jophish> in that example 0 has positive (or no) sign, but -0.1 has negative sign
08:26:42 <johnw> callCC ... >>= \x -> ....
08:26:51 <johnw> that function, the one after >>=, that *is* k
08:26:54 <quicksilver> :t properFraction
08:26:55 <lambdabot> (Integral b, RealFrac a) => a -> (b, a)
08:27:00 <lmj> OK I've solved this problem http://lpaste.net/edit/145440 by placing the Num constraint in a GADT constructor. Is there a portable solution?
08:27:05 <johnw> callCC is just giving it a name
08:27:22 <lmj> (Not that portability is a real issue, just wondering how plain haskell would do it)
08:27:55 <jophish> I think that it should be "n has the same sign or is zero"
08:28:00 * hackagebot exact-real 0.5.0.0 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.5.0.0 (jophish)
08:28:33 <varaindemian> max :: (Ord a) => a -> (a -> a). That could be read as: max takes an a and returns (that's the ->) a function that takes an a and returns an a. That's why the return type and the parameters of functions are all simply separated with arrows.
08:29:11 <varaindemian> actually I didn't udnerstand why they are separated only by arrows
08:29:20 <bollu> johnw: okay, so callCC receives a k that is the "rest of the computation"
08:29:28 <johnw> bollu: yep, that's what continuation means :)
08:29:32 <bollu> and you call the "k" with 10 and store the value in y
08:29:36 <johnw> yes
08:29:42 <bollu> so I'm guessing y is 30?
08:29:45 <johnw> "store" is a dubious term to use here, but hey
08:29:51 <bollu> since the "rest of the computation has "return 30"?
08:29:57 <johnw> yeah, y is the result of 'k', which ends with "return 30"
08:30:20 <bollu> well, you know, gets passed onto the next >>= as … >>= \y -> … which will be trapped in the closure
08:30:40 <bollu> okay, so then you "print y" which will print 30 first
08:30:43 <mauke[o}> varaindemian: every function takes exactly one argument
08:30:55 <bollu> and then you return 40
08:30:57 <johnw> bollu: "10" prints first, because 'k' received 10
08:31:17 <johnw> and the first thing that 'k' does is to print 'x'
08:31:21 <bollu> "liftIO $ print x" <- this is the line that is printing 10?
08:31:25 <johnw> yes
08:31:28 <bollu> oh my god that is mind numbing
08:31:29 <bollu> okay
08:31:36 <johnw> it's manual control flow, nothing more
08:32:04 <bollu> serious question that may seem silly: can you "see" what is happening, de sugared, in your head?
08:32:12 <bollu> because I sure as hell can't
08:32:20 <johnw> in this simple case, sure, let me desugar it for you
08:33:18 <johnw> bollu: approximately this: https://gist.github.com/4b193c73efd9b39300de
08:33:47 <johnw> all I've done is to inject the body of 'k' where we call it in the callCC version
08:34:09 <johnw> now imagine that you have the freedom of calling 'k' ZERO OR MORE THAN ONE TIMES, and you'll see the power of Cont
08:34:43 <bollu> "($ 10) $ \x -> do"
08:34:51 <bollu> this "do" block has which monad as the context?
08:34:52 <johnw> "call the lambda argument with 10"
08:35:09 <johnw> in this case, it's still ContT, but it's now equivalent to Identity in my example
08:35:13 <johnw> since we aren't using the power of Cont in any way
08:35:53 <bollu> and here "x" is a value of type Int?
08:36:02 <johnw> yeah, 'x' is bound to that 10
08:36:24 <johnw> I wrote it that way so you could clearly see the 'k' as a value
08:37:35 <bollu> what's the final type of the internal do block? it should be a function of the form Int -> ContT Int IO Int, right?
08:37:46 <johnw> yep, exactly that
08:38:20 * johnw has no idea why he talked about implicit calls to k; it must still be too early
08:38:45 <bollu> so the output of this will be?
08:39:04 <johnw> you mean, when we runContT foo return?
08:39:07 <bollu> yeah
08:39:13 <johnw> so, here the story changes a bit
08:39:20 <johnw> the first foo returns (), the second foo returns 40
08:39:44 <lyxia> lmj: Scalar x should not be equivalent to Pair x 0 ?
08:39:53 <bollu> which one is "first" and which one is "second" ?
08:40:00 <johnw> in order of pasties I gave you
08:40:03 <johnw> one sec, let me clarify
08:41:06 <lmj> lyxia: it should, just a simplified example
08:41:16 <johnw> bollu: https://gist.github.com/5aa5be648a914ae60279
08:41:34 <lyxia> lmj: but your fmap' does not follow functor laws
08:41:36 <johnw> x1 = 30, x2 = 40. We must now uncover why that is. Be sure to run it there
08:41:48 <lmj> lyxia: anyway GADTs solves it by moving the Num constraint to the Scalar constructor, but was wondering about a "plain haskell" solution
08:42:54 <quicksilver> the traditional haskell answer, lmj, is "that is not a functor" :P
08:42:55 <lyxia> lmj: Uh, I mean shouldnt "fmap (+1) (Scalar 0)" be equivalent "fmap (+1) (Pair 0 0)" frmo the point of view of the user?
08:43:21 <lyxia> lmj: In which case the Num constraint in the GADT wouldn't allow you to write Functor.
08:44:43 <bollu> johnw: question: 1) are there interesting uses of ContT with Id as the monad? (as in, just Cont, not ContT). 2) why are you calling runConT with "return"? and is this the same return :: a -> m a?
08:44:45 <lyxia> lmj: Basically I'm not convinced an implicit 0 is possible in whatever you are trying to do. What do you benefit from it anyway?
08:44:49 <lmj> lyxia: yes those two are equivalent. ghc didn't complain about the Functor instance
08:45:26 <johnw> bollu: "return" is passed as the final 'k'
08:45:40 <lyxia> lmj: well these are semantics you can't expect the compiler to catch on
08:46:07 <lmj> lyxia: I'm saying the semantics are equivalent
08:46:16 <lmj> what's a counter-example?
08:46:32 <bollu> :t runContT
08:46:33 <lambdabot> ContT r m a -> (a -> m r) -> m r
08:46:33 <lmj> the benefit is that an algebra with thousands (or millions) of dimensions benefits by recognizing scalars rather than padding with zeros.
08:46:34 <johnw> bollu: Cont has its uses sometimes
08:46:46 <lyxia> lmj: What is fmap (+1) (Scalar 0), and fmap (+1) (Pair 0 0)?
08:47:27 <lmj> lyxia: I checked that when you asked, and said they are the same, both semantically and in code
08:47:55 <bollu> johnw: when you said "final k", final k for the continuation in what sense?
08:48:18 <bollu> oh, wait, gotcha
08:48:23 <lyxia> lmj: Oh right.
08:48:26 <johnw> bollu: when you don't use callCC, every line of the Cont action is flowing into the next. When it reaches the end, it flows into the continuation you passed to runContT
08:48:29 <bollu> it just lifts the final value of the cont into the monad space
08:48:30 <bollu> right
08:49:01 <johnw> ah, I was very wrong about something
08:49:03 <lyxia> lmj:  but then what's the point of Scalar if it disappears as soon as you do anything with it?
08:49:11 <johnw> bollu: in my first 'foo', where I called "k 10"
08:49:17 <johnw> that 'k' does *not* return to the callCC block
08:49:24 <johnw> once you call that continuation, you've continued on
08:49:35 <johnw> when the Cont action reaches the end of that 'k', the action is done
08:49:51 <johnw> I was a bit fooled by ghci and its behavior of printing result values
08:49:57 <bollu> oh, so the print y doesn't happe?
08:49:59 <bollu> happen*
08:50:01 <johnw> right
08:50:06 <johnw> so, ignore a bunch of what I said
08:50:16 <johnw> I added in putStrLn calls, as a poor man's trace
08:50:22 <johnw> always a valuable trick when dealing with ContT
08:50:25 <lmj> lyxia: it disappears when you want to fmap something, but arithmetic operations (multiply, etc) take advantage of the operation. Plus numeric promotions are cheap (as opposed to padding).
08:50:40 <lmj> *take advantage of the optimization I mean
08:50:54 <bollu> 10
08:50:55 <bollu> x1 = 30
08:50:55 <bollu> 10
08:50:55 <bollu> 30
08:50:55 <bollu> x2 = 40
08:50:59 <bollu> that's the output I get.
08:51:05 <bollu> whoops, sorry for the copy-paste newlines
08:51:07 <johnw> yeah, so those two functions are *not* equivalent
08:51:10 <johnw> my apologies
08:51:20 <bollu> hm, np, this is interesting either way :)
08:51:34 <johnw> figuring out why they are not equivalent is a valuable exercise unto itself :)
08:52:53 <johnw> anyway
08:53:04 <johnw> once this stuff becomes old hat to you, the next thing to look at are delimited continuations
08:53:18 <johnw> because those are pretty sexy too, and you can do some neat things with them
08:53:37 <bollu> delimited in what sense?
08:53:48 <bollu> and I love haskell for the fact that I keep running into weird new things all the time :P
08:53:58 <johnw> start here: http://blog.moertel.com/posts/2005-09-13-scope-herding-with-delimited-continuations.html
08:53:59 <bollu> wonder what using haskell will be like once the honeymoon phase is over
08:54:36 <johnw> bollu: it's still hella fun :)
08:54:51 <Hafydd> bollu: my honeymoon period has been going for about 4 years.
08:54:55 <bollu> cool, ty. I'm going to go make myself coffee and get back to continuations
08:55:07 <johnw> bollu: good on you for sticking to it
08:55:12 <bollu> Hafydd: hahaha, that is pretty awesome then :P I've been at haskell for like a.. year now?
08:55:14 <lmj> lyxia: can you think of a solution without GADTs? Not that I'm against extensions, but I've been able to have portable code until now.
08:56:08 <bollu> oh, also, this is probably very early, but I was wondering if it was even slightly possible for me to apply for Haskell under GSoC? As in, I don't know if I know enough of Haskell to even be considered for GSoC this year
08:56:35 <bollu> I'd love to spend the summer working in Haskell if that counts :)
08:56:37 <Hafydd> What does it mean to "apply for Haskell"? Do you mean GHC?
08:57:00 <johnw> bollu: you know enough, if you choose the right problem
08:57:11 <johnw> bollu: being effective with Haskell as a functional language does not require mastery
08:57:23 <johnw> there are tons of things you can do that involve no understanding of many of #haskell's favorite topics
08:57:49 <bollu> Hafydd: not just GHC, I think they allow working on haskell libraries / ecosystem as well
08:58:04 <Hafydd> bollu: who is "they"?
08:58:07 <bollu> I think working on GHC requires more knowledge than I have right now? I would love to be wrong
08:58:21 <bollu> they == the mentors for GSoC for Haskell?
08:58:29 <lyxia> lmj: well I don't think you need to enforce that the contents of your type contain a Num instance in the first place
08:58:40 <bollu> https://ghc.haskell.org/trac/summer-of-code/
08:58:51 <bollu> johnw: examples of things I can do? :)
08:59:16 <bollu> I worked on VisPy last year for GSoC, and while that was extremely fun, I'd like to work on Haskell this time because Haskell
08:59:47 <johnw> bollu: improvements to the criterion library sounds more task-focused than language-skill-focused
08:59:51 <lyxia> lmj: this can be enforced instead with smart constructors and a clean interface
08:59:52 <Hafydd> I'm not sure what organisation that represents... the owners of haskell.org?
09:00:01 <johnw> also IHaskell projects
09:00:05 <Hafydd> I once tried to find out who exactly that is, but all I could see were some people on GitHub.
09:00:19 <johnw> Hafydd: Haskell.org does not have owners
09:00:29 <johnw> Hafydd: as of two days ago, we are our own corporation under New York law
09:00:31 <bollu> I think it is edwart kemmet, seymon PJ/(marlow?), and others
09:00:43 <johnw> Hafydd: our board consists of 7 members
09:00:48 <bollu> oh, that's awesome
09:00:55 <Hafydd> Oh...
09:01:03 <Hafydd> Who registered the domain?
09:01:05 <bollu> johnw: hm, could you point me to things that I might find interesting? 
09:01:13 <johnw> Ryan Trinkle is our treasurer and secretary, he did the filing
09:01:17 <bollu> and what about IHaskell? is that like IPython?
09:01:18 <johnw> bollu: https://ghc.haskell.org/trac/summer-of-code/report/1
09:01:22 <johnw> bollu: yes
09:01:36 <bollu> oh, cool. Is anyone working on integrating diagrams into it?
09:01:41 <bollu> if not, can I pick it up?
09:02:00 <johnw> sounds like a neat idea
09:02:06 <bollu> I've been learning and writing a small computational group theory package for haskell, because I don't really like using Sage
09:02:40 <umib0zu> bollu github link?
09:03:09 <bollu> umib0zu: It's not up :) my profile is http://github.com/bollu
09:03:20 <Hafydd> johnw: was the standards committee for Haskell involved in this at all?
09:03:23 <umib0zu> bollu :-(
09:03:30 <bollu> umib0zu: I don't really know anything about computational group theory though, so I've been reading and implementing it all on my own
09:03:31 <lmj> lyxia: But fmap operates on an already-created data structure. The Num constraint has to be there because 0 is used. It's too lat for smart constructors (which I use in the motivating code) to help.
09:03:37 <johnw> Hafydd: haskell.org is an orthogonal entity to Haskell standards
09:03:41 <umib0zu> still post it! bollu
09:03:47 <lmj> *too late
09:03:53 <Hafydd> johnw: I'm sure; but were they involved?
09:03:57 <johnw> haskell.org in particular manages the resources of the open source community; it does not decide anything about the Haskell language
09:03:59 <johnw> no, they were not involved
09:04:05 <Hafydd> Interesting.
09:04:14 <bollu> umib0zu: it's literally ~200 lines of code right now :P I promise I'll keep you posted once I have automorphism groups encoded in Haskell
09:04:14 <johnw> I'm not sure why they even would be?
09:04:16 <Hafydd> Was it just some people on IRC who decided to make a website, then?
09:04:29 <bollu> which reminds me, I need to learn Template Haskell for the generator representation of groups
09:04:30 <johnw> Hafydd: wait, I may have missed something
09:04:34 <lmj> If you can achieve the effect of http://lpaste.net/edit/145440 without GADTs I would be very interested.
09:04:40 <johnw> Hafydd: what is the exact question again?  Who owns http://haskell.org?
09:04:49 <Hafydd> johnw: that was my initial question, yes.
09:04:58 <johnw> The haskell.org committee owns http://haskell.org
09:05:04 <bollu> johnw: are you a mentor as well? for GSoC?
09:05:11 <johnw> bollu: I was this past summer, yes
09:05:40 <bollu> johnw: awesome :) think you'll be around this summer as well?
09:05:52 <johnw> bollu: I have a feeling that I'm not going to have enough time probably
09:06:23 <Hafydd> johnw: was the haskell.org committee also responsible for and involved in registering the company you mention in New York?
09:06:42 <johnw> Hafydd: yes, that's actually what I thought we were talking about
09:06:51 <johnw>  it then occurred to me that you may be referring to the website of the same name
09:06:56 <bollu> johnw: aww :/ know anyone who is probably going to mentor and hangs out on IRC?
09:07:01 <lyxia> lmj: All you're using the GADT for is to store 0
09:07:04 <Zekka|Sigfig> bollu: FWIW I started getting annoyed with haskell about a year after I started using it seriously
09:07:10 <johnw> the Haskell.org committee pays for the Web servers that run that website, and we also administrate the domain name and the content
09:07:12 <lyxia> lmj: so store 0 instead at construction time with the smart constructor
09:07:19 <Zekka|Sigfig> But I’m not as much of a math person as a lot of people here are, I think, and I don’t have that much patience for highly abstract code
09:07:24 <johnw> bollu: probably a few people
09:07:25 <Hafydd> johnw: it doesn't seem like there's a distinction!
09:07:52 <johnw> Hafydd: the Haskell.org committee maintains several things outside of that website, like the hackage server, Google Summer of code, and other uses of donated funds
09:08:12 <Hafydd> I see.
09:08:14 <Zekka|Sigfig> I still think learning it was a good idea but I won’t write all my programs in it unless someone comes up with type-light solutions to most of the things that bugged me
09:08:23 <lmj> lyxia: er, the goal is to not store zero. In the motivating code, I'm avoiding an arbitrary number (thousands, millions) of zeros.
09:08:26 <bollu> johnw: where is IHaskell's website?
09:09:00 <lmj> I would just store Pair x 0 otherwise
09:09:03 <lmj> forget Scalar
09:09:05 <Hafydd> johnw: is there any documentation on the administrative side of this?
09:09:42 <Zekka|Sigfig> (I’m also dubious about laziness as a default behavior but I think it’s good enough most of the time, even though it’s not fit for microoptimized programs and requires you to rely on ghc’s optimizer to do the right thing if you want C-order of magnitude performance)
09:09:55 <lyxia> lmj: You have Scalar :: Num a => a -> Complex a  <- this is already a pair...
09:10:20 <Hafydd> I see <https://wiki.haskell.org/Haskell.org_committee>, but that doesn't look particularly official.
09:10:32 <bollu> all I can find for IHaskell is mainly the github link - https://github.com/gibiansky/IHaskell
09:10:36 <bollu> does it have a website?
09:10:45 <johnw> Hafydd: https://wiki.haskell.org/Haskell.org_committee
09:10:49 <johnw> bollu: not sure
09:13:45 <lmj> lyxia: It's semantically a Pair x 0, but we're avoiding storing the zero because in the general case there could be millions of zeros. The motivating code is https://hackage.haskell.org/package/cayley-dickson-0.1.4.0/docs/Math-CayleyDickson.html
09:16:06 <lyxia> lmj: I never said to store millions of zeros... You could have data Array0 a = First { first :: a, allOthers :: a } | Array (Array a) {- an actual array type -}
09:23:36 <lmj> lyxia: what is allOthers? A value to be padded? Using an array representation would require code generation to derive the multiplication formulas. (I've done this in lisp, actually.) Beyond 2^9 dimensions compilers just take too long. Code-generating higher than that is not really feasible, practically.
09:23:56 <lyxia> lmj: The fact that it is an array wasn't my point at all
09:24:11 <mniip> data Nion n a = Scalar a | Nion n a :@ Nion n a
09:24:13 <mniip> shouldn't that be a GADT
09:24:45 <lyxia> lmj: basically you just replace the Num a field you had with the actual thing you need it for, which is the padding value.
09:31:38 <lmj> lyxia: I've had versions of this that had a constructor representing a padded scalar -- this is basically your suggestion, right? There would be three constructors in all, since using the padded scalar for the leaves would be wasteful.
09:32:50 <lmj> Having two constructors was so much more elegant, and since all the necessary information was already there I dropped the third constructor.
09:32:55 <lyxia> lmj: Well you could make sure the padded scalar is always 0 and switch the representation when you fmap
09:33:26 <lyxia> lmj: That's still two constructors, except the "Scalar" is a bit heavier.
09:33:54 <lyxia> But actually less than Num a => a -> MyType q
09:33:57 <lyxia> a
09:36:14 <lmj> lyxia: but that could lead to a million copies of zero that we don't need.
09:36:39 <lmj> if each scalar has a zero
09:36:58 <lyxia> lmj: With a GADT you have a million copies of dictionaries that you don't need either...
09:38:01 <lyxia> Or give up both GADT and Functor because it doesn't make much sense to fmap over a complex number...
09:40:00 <joco42> how can i get a stack trace ? i am using the :trace in ghci... https://usercontent.irccloud-cdn.com/file/2SehfYcZ/Screen%20Shot%202015-11-17%20at%2019.38.37.png
09:40:39 <joco42> and i would like to know who called the function where this breakpoint is
09:41:02 <joco42> what is history?
09:41:05 <joco42> what is back ?
09:44:33 <m1dnight_> The Hunit package really has no recent documentation? The git only has docs for 1.0 and it seems to me that the syntax is radically different?
09:45:17 <joco42> this looks much better :) https://usercontent.irccloud-cdn.com/file/JfGBeGLZ/Screen%20Shot%202015-11-17%20at%2019.44.38.png
09:46:55 <lmj> lyxia: I noticed Functor and Applicative being commonly offered over structures (including quaternions), and figured this was somewhat expected. After all, addition is just fmap (+).
09:47:20 <glguy_> The hunit documentation is on hackage
09:47:22 <lmj> lyxia: the suggestion to drop Functor (& Applicative) is probably the sanest solution so far. :)
09:48:36 <lyxia> addition would be more like liftM2 (+) actually
09:49:11 <lyxia> whereas "fmap (+1) (x + i y) = (x+1 + i (y+1))"
09:49:36 <lmj> lyxia: yes, I had liftM2 (+) in there once, but it went away with the scalar optimizations.
09:49:58 <lmj> right, fmap (+) isn't what I meant
09:51:46 <lmj> ugh, well Foldable and Traversable run into the same problem, and those make a lot of sense. I need to think about it more.
09:51:50 <lmj> lyxia: thanks for the help
09:52:28 <lyxia> You're welcome.
09:53:02 * hackagebot hreader 1.0.2 - Generalization of MonadReader and ReaderT using hset  https://hackage.haskell.org/package/hreader-1.0.2 (AlekseyUymanov)
09:54:43 <VictimOfCulture> weird aye http://puu.sh/loYYv.jpg
09:58:44 <m1dnight_> glguy_: are you sure? ive checked the github, source forge and they al Doc about 1.0
10:04:50 <joco42> wow.... is it possible to get a function call trace on an exception in ghc ?
10:05:18 <joco42> +RTS does not seem to give much meaningful info....
10:05:30 <KaneTW> joco42: with ghc HEAD iirc
10:05:41 <joco42> ghc HEAD?
10:05:49 <KaneTW> the current development version
10:05:52 <joco42> ahh
10:05:54 <KaneTW> the feature is coming with 8.0
10:05:58 <joco42> i see
10:05:59 <joco42> :)
10:06:01 <joco42> nice
10:06:11 <joco42> when is it out /
10:06:14 <joco42> ?
10:06:16 <VictimOfCulture> http://tomatobubble.com/economist_magazine_cover.html
10:06:33 <KaneTW> not sure
10:06:48 <joco42> 1 year ?
10:06:51 <joco42> less?
10:07:10 <joco42> what is the workaround?
10:07:24 <joco42> how do people live without stack trace?
10:07:27 <KaneTW> did you try compiling with profiling, then +RTS -xc?
10:07:30 <bergmark> hmm i thought that was in 7.10? is that just source locations?
10:07:39 <joco42> yeah
10:07:42 <joco42> i tried
10:07:50 <joco42> gives nothing meaningful...
10:08:29 <KaneTW> bergmark: i might be mistaken
10:08:47 <KaneTW> lemme check
10:09:51 <bergmark> my colleague says otherwise :-) https://github.com/tomjaguarpaw/haskell-opaleye/pull/124#issue-111591554
10:11:13 <joco42> how should i read this ? https://usercontent.irccloud-cdn.com/file/6bIf71w9/Screen%20Shot%202015-11-17%20at%2020.10.31.png
10:13:03 <joco42> is this a stack trace ?
10:13:48 <joco42> it really does not tell where the exception occured
10:13:49 <KaneTW> bergmark: error in GHC HEAD prints a stack trace by default
10:14:02 <orion> Is anyone familiar with AESGCM and/or cryptonite?
10:14:05 <joco42> ahha
10:14:20 <KaneTW> joco42: Main.makeAllCards.f
10:14:26 <joco42> i see
10:14:43 <joco42> but that does not make much sense
10:15:10 <joco42> but maybe i am just reading it incorrectly
10:15:13 <KaneTW> can you post the code
10:16:22 <joco42> KaneTW, here is a screenshot https://usercontent.irccloud-cdn.com/file/XhVQFxAr/Screen%20Shot%202015-11-17%20at%2020.15.42.png
10:16:27 <joco42> of Main
10:16:58 <joco42> so actually is the exception the same as an error/
10:16:59 <joco42> ?
10:17:15 <monochrom> have you heard of pastebins?
10:17:28 <joco42> monochrom:  sorry it is not so easy for me
10:17:31 <bergmark> `error' throws an exception
10:17:37 <joco42> remote ssh in tmux....
10:18:13 <joco42> bergmark:  there are a lot of exceptions thrown
10:18:23 <joco42> but they do not seem to crash the program...
10:18:33 * hackagebot exact-real 0.7.1.0 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.7.1.0 (jophish)
10:19:34 <joco42> are these errors or exceptions or what ? why do they not crash the program? https://usercontent.irccloud-cdn.com/file/UMzhgJdO/Screen%20Shot%202015-11-17%20at%2020.18.35.png
10:19:39 <joco42> why are there so many?
10:21:48 <joco42> my feeling is that in that stacktrace i cannot see the stacktrace due to the "error"
10:21:59 <joco42> but all sorts of other strange stack traces...
10:22:04 <joco42> which are all irrelevant
10:22:17 <joco42> oh my really confusing... any explanation?
10:23:18 <joco42> how do people debug in haskell?
10:23:31 <joco42> someone enlighten me... i go back to java...
10:23:39 <joco42> at least could debug there :)
10:23:54 <KaneTW> debugging without code is hard
10:23:57 <dmj> joco42: you don't, haskell debugs you
10:24:00 <KaneTW> run the code without -xc
10:24:03 <KaneTW> see where it errors
10:24:14 <KaneTW> or what it puts out
10:24:14 <joco42> ahha
10:24:16 <joco42> ok
10:24:17 <KaneTW> look where that is
10:24:20 <bergmark> joco42: as soon as i have to use a debugger i think the opposite...
10:24:25 <joco42> i know where that is....
10:24:43 <joco42> i just wanna see a stacktrace...
10:24:55 <johnw> dmj: lol
10:24:55 <joco42> how the code gets to the error
10:25:35 <dolio> Haskell doesn't have stacks that explain how you got to an error.
10:25:36 <mauke[o}> that's slightly hard because haskell has no call stack
10:25:42 <joco42> like in any other prog language... nice simple call stack trace... is that so much to ask ?
10:25:48 <mauke[o}> yes
10:25:51 <bergmark> joco42: what i would do: find out which function throws an error, put a Debug.Trace.traceShow to print the arguments passed to it, and then i might make a test case for that
10:25:53 <joco42> really?
10:26:07 <medfly> hello
10:26:08 <joco42> no stack trace?
10:26:13 <mauke[o}> no call stack
10:26:15 <joco42> i am lost
10:26:28 <medfly> is haddock supposed to come with GHC? I need it to install cabal-install.
10:26:32 <joco42> is it due to lazyness?
10:26:37 <mauke[o}> yes
10:26:41 <elNodo> Hey, y'all, anyone here willing to help me fix this error? "Negative index". Ty http://lpaste.net/145454
10:26:43 <joco42> my god...
10:26:57 <dolio> It's not just laziness.
10:26:57 <joco42> the price i have to pay for lazyness...
10:27:10 <joco42> i am not sure about it....
10:27:21 <joco42> debug hell....
10:28:06 <joco42> but yeah, bergmark has a point
10:28:13 <joco42> trace to the rescue
10:29:00 <joco42> how about :trace main in ghci and the using :back
10:29:05 <joco42> will that help?
10:31:20 <suppi> joco42, this is also possible: https://www.youtube.com/watch?v=1OYljb_3Cdg
10:31:32 <joco42> suppi:  thanks, i have a look
10:31:33 <medfly> how should I obtain haddock?
10:31:47 <monochrom> GHC comes with haddock
10:31:53 <medfly> hm
10:32:18 <medfly> monochrom: what does it mean if I have GHC but not haddock?
10:33:26 <suppi> medfly, do you need to generate docs for a project? you can use 'cabal haddock' I think.
10:33:42 <monochrom> "cabal haddock" still needs haddock installed
10:33:42 <medfly> suppi: cabal-install requires haddock
10:34:29 <monochrom> it can mean you obtained GHC from someone's repackaging, and that someone split things due to fetish ideologies
10:34:34 <c_wraith> elNodo: your todos list sometimes goes outside the map. You'll have to fix that. 
10:34:50 <mauke[o}> medfly: how did you install ghc and which version?
10:34:51 <medfly> monochrom: no. it is not intentional, it was in error
10:35:03 <monochrom> or it can mean you made some mistake
10:35:40 <elNodo> c_wraityh when it goes outside the map it gives me a '#' anyway, i made it on purpose to avoid that problem
10:36:19 <medfly> monochrom: I am trying to update GHC for a package manager
10:36:21 <c_wraith> elNodo: I'm telling you, sometimes it has negative numbers in it, and that's your problem. 
10:36:44 <elNodo> c_wraith I'll take a look at that, thanks :) will comment later
10:37:29 <monochrom> well then I don't understand the question
10:40:28 <byorgey> bollu: IHaskell already has diagrams support
10:42:41 <elNodo> c_wraith it's fixed, thanks. I have another problem now but it's unrelated, will have a look into it
10:43:32 <bollu> byorgey: oh :( so what can I help out with, then?
10:43:40 <medfly> monochrom: any idae what could be wrong that I dont have haddock?
10:43:56 <byorgey> bollu: I have no idea how you can help with IHaskell, I am not involved in that project
10:44:02 <bollu> also, why can't you use where clauses with lambdas? I've been teaching someone Haskell and I couldn't think of a reason why they're disallowed except maybe for parsing problems
10:44:04 <byorgey> but there are lots of ways you can help with diagrams!
10:44:08 <bollu> byorgey: do tell! :)
10:44:30 <bollu> byorgey: I first need to grok diagrams completely :P 
10:44:36 <byorgey> bollu: no, you don't!
10:45:02 <medfly> in order to contribute, first you must understand the universe
10:45:08 <medfly> become one
10:45:19 <byorgey> bollu: I started diagrams development, and have been working on it ever since (7+ years).  *I* don't grok it completely.
10:45:58 <bollu> byorgey: that's.. impressive / crazy / how does that work?
10:46:34 <joco42> this seems interesting is it any good ? https://www.reddit.com/r/haskell/comments/2fwwx3/how_to_get_approx_stack_traces_with_profiled/
10:46:38 <byorgey> excuse me, the tornado sirens are going off
10:47:29 <medfly> what
10:47:35 <bollu> ^
10:47:43 <mnoonan> good old midwest living :)
10:48:22 <Welkin> I thought byorgey was in arkansas
10:49:34 <joco42> what is this dwarf and not dwarf stack trace thingy?
10:51:55 <joco42> finally! https://usercontent.irccloud-cdn.com/file/z6dhyfz0/Screen%20Shot%202015-11-17%20at%2020.51.11.png
10:52:18 <joco42> a stack trace after a million years.... :) oh my... why can this not be standard?
10:53:18 <joco42> well, for a short while i started to think that i need to go back to java....
10:56:24 <Denommus> I had no idea how awesome monad transformers could be
10:56:55 <Denommus> I mean, I can do anything "ugly" I'd do in an imperative language, except inside a properly typed scope
10:58:13 <koshmar> As for GPU, what the difference between GPipe and accelerate, what's batter to use for scientific computing(linear algebra, and Furier transforms)?
10:59:57 <Cale> joco42: Good luck figuring out what it means :P
11:00:10 <Cale> joco42: Given that there really isn't a call stack
11:01:58 <Cale> If that's some kind of representation of the actual stack though, pretty cool.
11:02:07 <fryguybob> bollu: While byorgey dodges tornados, you might want to look here: http://projects.haskell.org/diagrams/community.html
11:02:22 <bollu> fryguybob: thank you :)
11:03:01 <medfly> byorgey: are you okay/
11:03:36 <Cale> bollu: Diagrams has a lot of mathematical foundation, and that foundation has consequences which might not be obvious. I think that's what Brent means when he says that he doesn't grok it completely.
11:05:13 <bollu> Cale: ah, I see. Yeah, I did see a ton of linalg in between the diagrams types which I found curious and awesome :)
11:08:48 <byorgey> I am fine.  There is some serious weather here though.
11:09:47 <joco42> Cale: why there is no call stack?
11:10:04 <Cale> joco42: Because lazy evaluation is outermost-first
11:10:33 <byorgey> Cale, bollu: that's true, but mostly what I meant is that there are a lot of people contributing to it, and the code base is so large now that I don't really understand all of it
11:10:47 <Cale> joco42: There is a stack used while pattern matching, but it's better to think of it as a stack of case expressions (or other pattern matches) who are waiting for their scrutinee to be sufficiently evaluated to match a pattern.
11:10:54 <joco42> but if an error occurs somewhere... then it can be traced back to the origin?
11:11:36 <joco42> or not?
11:11:40 <Cale> hm?
11:11:53 <Cale> If an error occurs, you can generally tell which expression threw the error
11:12:15 <Cale> But you can't tell why that expression is being evaluated, because that's the part of the program which has already run.
11:12:35 <Cale> and there would be no reason to keep that information apart from debugging
11:12:50 <Cale> Well, not entirely true
11:13:03 <Cale> You might be able to determine which case expression(s) are forcing the evaluation of the expression
11:13:17 <Cale> But that's very different from what you might expect from a call stack in a strict language
11:13:51 <Cale> and it might indicate a much later point in the program's evaluation than the place which allocated the expression which is now being evaluated and throwing the error.
11:14:28 <joco42> hmm...but i have a set of functions
11:14:38 <Cale> There's all sorts of crazy things which get done to try to make things which look more like the call stacks you'd get if your program was being evaluated strictly
11:14:42 <joco42> calling each other
11:14:45 <Cale> But they're weird and approximate
11:14:49 <Cale> and I don't really trust them
11:14:55 <joco42> i can trace the data flow in principle?
11:15:20 <Cale> The evaluation of the program looks like rewriting a graph over and over
11:15:32 <joco42> where the data flows.. 
11:15:37 <joco42> hmmm
11:15:44 <joco42> right
11:15:46 <joco42> true
11:15:56 <Cale> You could, if you wanted to waste a hell of a lot of memory, store all the previous graphs and try to work your way back through them
11:15:56 <joco42> i see
11:16:14 <joco42> something like that...
11:17:22 <mrapogee> How do I create qualified data fields? I have multiple data types that have the same field names, do I need to put them each in separate files? ( data Item1 = { field } data Item2 = Item2 { field } )
11:17:37 <joco42> is this thing explained somewhere?
11:17:49 <joco42> in some nice video?
11:18:02 <joco42> why there is no stacktrace in haskell...
11:18:26 <joco42> or how the data flows?
11:18:29 <liste> mrapogee that's right, you can't have two fields with the same name in one file
11:19:02 <geekosaur> joco42, stack traces coming in ghc 8
11:19:14 <geekosaur> it's not trivial with lazy evaluation
11:19:33 <condy> Hi, guys, I'm attempting to implement church numbers. `cexp x y = y x` is the definition of power in church numbers. When I add sinature, it doesn't compile. It looks like this `cexp :: Church a -> Church a -> Church a` where Church is `type Church a = (a -> a) -> a -> a`
11:19:43 <joco42> geekosaur: when is ghc 8 out?
11:19:44 * condy enrolling FP101x in edx
11:20:47 <geekosaur> I don't know.
11:21:42 <mniip> when using Data.ByteString.Builder, what should I use to append a newline?
11:21:47 <mniip> string7 "\r\n"? string8? stringUtf8?
11:21:54 <mniip> word8 0xD <> word8 0xA ?
11:22:15 <condy> it's my code. http://paste.pound-python.org/show/LoclwGjIu46ADPMaBgQZ/
11:23:03 <Welkin> mniip: encodeUtf8 "\r\n"
11:23:12 <mniip> why though
11:23:25 <Welkin> more readable
11:23:40 <Welkin> or even write your own unlines
11:23:56 <Welkin> > encodeUtf8 "\r\n"
11:23:58 <lambdabot>  Not in scope: ‘encodeUtf8’
11:24:06 <lpaste_> condy pasted “church number” at http://lpaste.net/145460
11:24:33 <Welkin> https://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text-Encoding.html#v:encodeUtf8Builder
11:24:53 <Welkin> encodeUtf8Builder in this case
11:26:24 <anelson> hey guys, is there a compelling reason why Data.Text isn't an instance of Text.Printf.PrintfType? It seems like it should be...
11:27:25 <geekosaur> afaik because nobody bothered to make such an instance, and Text.Printf is more of an example of typeclass abuse than something you should really be using
11:27:55 <anelson> hmmm, well it's all over Marlow's book on concurrent haskell
11:28:05 <geekosaur> this is Haskell, printf is not exatcly a strongly typed interface
11:28:14 <anelson> heh, well that's true :P
11:28:58 <liste> condy I think you need a wrapper type for that
11:29:15 <liste> to avoid infinite types
11:29:49 <Nornorna> Hi. Brain tired, could anyone provide a version without lambda? Can't seem to get rid of "a". (\a b -> 0 /= rem a b)      =       (\a -> (0/=) . rem a)
11:30:03 <johnw> @pl \a -> (0/=) . rem a
11:30:03 <lambdabot> ((0 /=) .) . rem
11:30:14 <johnw> not sure that helps a tired brain at all
11:30:35 <condy> liste: OMG, silly me
11:31:30 <Nornorna> Well it's quite tired but isn't that what I wrote johnw?
11:32:01 <liste> condy something a bit akin to this: http://r6.ca/blog/20060919T084800Z.html
11:32:26 <johnw> Nornorna: I fed your function to @pl, and it dropped the 'a'
11:32:27 <condy> liste: thx :)
11:36:30 <Nornorna> On closer inspection, yes. Thanks.
11:51:51 --- mode: ChanServ set +o mauke
11:51:51 --- mode: mauke set -b *!*@209-6-212-33.c3-0.bkl-ubr1.sbo-bkl.ma.cable.rcn.com
11:52:34 <ricky_clarkson> Hi. Anyone know of any efforts towards being able to flatMap/filter/etc or otherwise compose APIs? E.g., if you have an API (a REST one, for instance) that gives you bulk data, and another that can tell you whether an item is ok, you could compose them to filter the bulk data, maybe creating a new API.
11:53:01 <ricky_clarkson> Just want some evidence that the idea I want to explore isn't completely bonkers.
11:53:51 --- mode: mauke set -o mauke
11:54:41 <Welkin> ricky_clarkson: https://haskell-servant.github.io/
11:55:06 <KaneTW> yeah, servant can do that
11:55:12 <bergmark> ricky_clarkson: rest-core as well, to some degree
11:55:28 <KaneTW> the apis you define have a Functor instance as they're monad transformers
11:55:29 <ricky_clarkson> Thanks, I'll take a look.
11:57:19 <bergmark> same for rest, each sub resource is (typically) a ReaderT over its parent
11:57:26 <ricky_clarkson> How about if you want to make the composition be on the client side, so you have one API service call another, somewhat like recursive DNS?
11:58:11 <ricky_clarkson> Like recursive DNS I imagine that the service could say no, then the client would need to get all data and call the second API itself.
11:59:13 <bergmark> i'm not sure i understand, if you want one api to wrap another, why does the user need to know that there's a second one?
11:59:35 <ricky_clarkson> The user might know what APIs they want to compose.
11:59:59 <ricky_clarkson> but it might be better for the composition to happen server-side
12:00:27 <ricky_clarkson> e.g., if the APIs know each other and can avoid fetching information that will be filtered out
12:01:42 <bergmark> we have one public rest api with several others behind it that we proxy calls to
12:03:37 * hackagebot hackager 1.3.0.0 - Hackage testing tool  https://hackage.haskell.org/package/hackager-1.3.0.0 (DavidTerei)
12:04:59 <Ste1891> Hi.  Does anyone know if nullPtr (from Foreign.Ptr) is guaranteed to be zero in all cases?  The reason I ask is that I know it can be zero but need to pass a pointer that is definitely zero when calling certain OpenGL functions (such as glVertexAttribPointer from Graphics.Rendering.OpenGL.Raw.Core41).
12:06:32 <geekosaur> that's the whole point of nullPtr, I believe
12:07:20 <arek221b> Hello. I am a total beginner and could someone please explain why do I need 'bmi' here? 
12:07:30 <arek221b> calcBmis :: [(Double, Double)] -> [Double]calcBmis xs = [bmi w h | (w,h) <- xs]   where bmi weight height = weight / height^2
12:07:57 <Iceland_jack> arek221b: You don't!
12:07:58 <geekosaur> you don't need it, it just makes things easier to read
12:08:06 <apriori> arek221b, you dont, that is a list comprehension
12:08:08 <arek221b> Without bmi it won't work and I don't know why
12:08:19 <apriori> arek221b, because you demand type [Double]
12:08:28 <apriori> that code reads:
12:08:28 <Iceland_jack>     calcBmis :: [(Double, Double)] -> [Double]
12:08:28 <Iceland_jack>     calcBmis xs = [ w/h^2 | (w, h) <- xs ]
12:08:53 <geekosaur> :t (^)
12:08:54 <lambdabot> (Integral b, Num a) => a -> b -> a
12:09:06 <geekosaur> hm, ok, not it
12:09:14 <geekosaur> (shouldn;t have been, I guess0
12:10:10 <Ste1891> I would have thought so but the documentation on it stope short of saying this, instead saying it is "a distinguished value of Ptr a that is not associated with a valid memory location."
12:10:19 <apriori> arek221b, [bmi w h | (w,h) <- xs] = fmap (uncurry bmi) xs
12:10:55 <apriori> or differently: for every xs, extract (w, h) and construct a value "bmi w h" for every generated (w, h)
12:11:21 <geekosaur> Ste1891, that's because C is actually that vague itself
12:11:58 <monochrom> ah, but it gets better (I mean worse) than vague.
12:12:06 <geekosaur> although it also guarantees that a literal 0 will map to that distiguished value, IIRC
12:12:14 <monochrom> yes, that.
12:12:17 <arek221b> bmi here is as a function, yes?
12:12:28 <geekosaur> since we can't use that from Haskell, we use nullPtr for the same purpose.
12:12:53 <apriori> arek221b, yes, it takes two arguments
12:13:05 <monochrom> at the C source code level you will say 0. but the compiler will convert that to the right thing for the hardware, which varies with hardware.
12:13:13 <monochrom> (or perhaps, for the OS)
12:13:41 <arek221b> it's weird because I don't think it says here that I declared type of arguments for bci function. I did that only for calcBmis function
12:13:47 <monochrom> then again, for the OS and hardware you use, it's likely still 0 underneath
12:14:08 <geekosaur> yes
12:14:23 <monochrom> . o O ( it's 0's all the way down )
12:14:26 <apriori> arek221b, the type was inferred
12:14:29 <arek221b> So how does it know what types of arguments will bci take then?
12:14:42 <apriori> arek221b, where bmi weight height = weight / height^2 => bmi :: Double -> Double -> Double
12:14:45 <geekosaur> but the Haskell spec has to hew to the C spec there, so it can't rely on the actual bit pattern that way, so we have nullPtr and use a C compiler when generating it to get the right bit pattern
12:15:05 <Ste1891> OK.  So does this mean there is any risk in me assuming it will be zero, when the C function I pass the argument to interprets the value as a buffer offset (i.e. adds it to another pointer?)
12:15:08 <apriori> arek221b, the type inference is constrainted by your usage of bmi. your function works on doubles throughout
12:15:18 <geekosaur> Ste1891, you're fine using it to mean 0
12:15:21 <apriori> arek221b, *constrained
12:16:11 <geekosaur> the weasel wording is because of the C standard being weasel worded, but in any case it comes out to the same thing on any platform you're going to have OpenGL on
12:17:02 <dolio> Isn't it weird for the C function to be expecting a pointer argument, but adding it to another pointer?
12:18:54 <monochrom> an offset is supposed to have type size_t or something
12:19:06 <dolio> ptrdiff_t, presumably.
12:19:43 <mauke> Ste1891: you can't add a pointer to another pointer in C
12:20:17 <Welkin> mauke: yes you can
12:20:26 <mauke> Welkin: you're fired
12:20:27 <Welkin> that is one of the primary activities in C
12:20:30 <Ste1891> OK, thanks guys.  To be on the safe side I had been creating a Word64 type value that was 0 and using unsafeCoerce to pass it as a pointer, which I guess is actually rather unsafe (but worked).
12:20:48 <mauke> Ste1891: what function are you calling?
12:22:32 <nitrix> mauke: You can add and even substract pointers with each others. C has pointer arithmetic.
12:22:38 <mauke> nitrix: you're also fired
12:22:44 <Ste1891> glVertexAttribPointer (from Graphics.Rendering.OpenGL.Raw.Core41) takes a Ptr a as its last argument, but this is actually the offset within a buffer you want it to start reading from.  Working this out nearly drove me mad.
12:23:07 <Welkin> Ste1891: opengl sucks
12:23:09 <monochrom> "pointer arithmetic" only means "ptr + integral_type = ptr" and "ptr - ptr = integral_type"
12:23:15 <apriori> nitrix, it should be evident that mauke considers pointer arithmetic so ugly that he declares it as non existent
12:23:20 <mauke> monochrom: you're hired
12:23:51 <mauke> apriori: no, I just fire people who contradict me on basic C stuff without even trying them in their compiler
12:24:11 <apriori> mauke, ok :)
12:24:16 <monochrom> do not use your intuition on the phrase "pointer arithmetic" and deduce that "gcd(ptr, ptr) makes sense"
12:24:18 <nitrix> Because the other results aren't sensible doesn't mean it isn't possible.
12:24:38 <mauke> nitrix: try it, please
12:24:53 <Ste1891> OK, got to go out (in the real world) but thanks again.
12:27:58 <hc> is there a way to shorten a function like "\a b -> some a == some b"?
12:28:10 <dolio> (==) `on` some
12:28:20 <hc> wow, thanks! :)
12:28:39 <mniip> that only works if a and b are the same type
12:28:55 <monochrom> yes
12:28:55 <mauke> glVertexAttribPointer is pissing me off. its documentation doesn't make sense
12:28:55 <hc> where to get "on" from, though?
12:28:59 <mauke> @index on
12:29:00 <lambdabot> Data.Function
12:29:02 <hc> thx
12:29:05 <monochrom> @type (==) `on` some
12:29:07 <lambdabot> (Eq (f [a]), Alternative f) => f a -> f a -> Bool
12:29:22 <hc> beautiful :)
12:29:54 <dolio> That's weird.
12:30:07 <apriori> mauke, what's the issue with it?
12:30:23 <dolio> Oh, right. It's not weird.
12:30:30 <mauke> it describes the last argument ("pointer") as both a memory address and an offset
12:30:32 <kadoban> Yeah, the 'some' tripped me up on the type, heh.
12:31:11 <sinelaw> So JVM's GC has 36MB as the default "young" generation size
12:31:17 <sinelaw> GHC - 512K
12:31:22 <mauke> (GLvoid*)(4 * 4)
12:31:29 <sinelaw> something seems fishy.
12:31:35 <mauke> goddammit, C coders
12:31:43 <nani___> say, in general, that I have a problem I want to solve and I have no idea about how to structure the program. I also don't know exactly what to look up. How do I proceed? This is probably too general to the point of being useless, but I'm probably going to ask specific questions in a few days
12:31:52 <dolio> sinelaw: Does setting GHC to 36MB make things a lot better?
12:32:03 <mniip> hmm
12:32:13 <nani___> actually nevermind, I'll ask in a few days the specific problem
12:32:17 <mniip> is there a good inverse to Data.ByteString.Builder?
12:32:17 <sinelaw> dolio: YES
12:32:21 <Iceland_jack> nani___: You can describe the problem now
12:32:26 <mniip> I don't think I want to use something as huge as attoparsec here
12:32:27 <kadoban> nani___: Sounds too general to the point of being useless …
12:32:30 <kadoban> ;)
12:32:34 <mauke> "OpenGL is tricky - there's at least one situation where a Pointer is interpreted differently, depending on whether the target it is bound to is a texture or a PBO. In one case it's a pointer, in the other it's an integer offset into the buffer."
12:32:36 <sinelaw> dolio: -A16M made it 3x faster IIRC
12:32:41 <dolio> sinelaw: You should tell someone in charge. :)
12:32:55 <mauke> and that should technically be "an integer offset cast to (void *)"
12:33:07 <apriori> mauke, awesome, isn't it?
12:33:15 <apriori> who cares about proper semantics anyway
12:33:31 <mauke> just j-j-jam it in!
12:34:18 <nani___> Iceland_jack I want to really understand the problem better so I can describe it exactly
12:34:38 <nani___> Iceland_jack so in a few days :)
12:36:14 <dolio> You'd think that someone using a language predicated on (these days), "I never make mistakes," would care about accurate semantics.
12:37:10 <monochrom> nani___: I would study the problem itself too, like you are doing. but you still have the choice of studying in solitude or brainstorming in group
12:37:37 <monochrom> but either way, I would not rush to a program or even a program sketch
12:38:04 <mniip> is there a good inverse to Data.ByteString.Builder?
12:38:05 <mniip> I don't think I want to use something as huge as attoparsec here
12:38:47 <monochrom> yeah, parsing is an inverse of building. is trifecta small enough?
12:39:40 <mauke> there was that one regex library
12:40:34 <mniip> mauke, hell no
12:40:48 <monochrom> :)
12:41:40 <mauke> http://hackage.haskell.org/package/regex-applicative-0.3.2.1/docs/Text-Regex-Applicative.html
12:41:43 <mauke> this one
12:42:40 * mniip reverts to BS.uncons and BS.span
12:43:37 <byorgey> bollu: you were asking earlier about ways to help with diagrams.  For starters you can take a look at https://trello.com/b/pL6YdKgz/diagrams  for a list of projects, todos, etc.  Many of them are probably cryptic but we would be happy to explain any of them in more detail.
12:44:19 <byorgey> bollu: but in any case what I always recommend is to just try playing with making some diagrams, in the process you will likely stumble across some missing features, things that could be improved, etc.
12:46:01 <stoogenmeyer> hey if I am defining an instance function can I put a where in there?
12:46:41 <byorgey> stoogenmeyer: by 'an instance function' do you mean a method in a type class instance?
12:47:42 <stoogenmeyer> byorgey: yes
12:48:02 <dmj> stoogenmeyer: yes
12:48:10 <byorgey> stoogenmeyer: OK, yes, you can attach a where clause to any clause of a function definition
12:48:26 <byorgey> no matter whether it is a top-level function, in an instance, nested inside another where clause, ... etc.
12:48:57 <stoogenmeyer> im trying something on the lines of this and it's not compiling
12:48:57 <stoogenmeyer> http://pastebin.com/EmfH4cjB
12:49:18 <monochrom> x = y+y where {y = z+z  where {z = 4+4}}
12:49:20 <byorgey> stoogenmeyer: Q can't be uppercase
12:49:26 <stoogenmeyer> oh
12:49:28 <stoogenmeyer> (-:
12:49:47 <byorgey> only the names of types and data constructors can start with an uppercase letter
12:50:13 <stoogenmeyer> thank you very much
12:50:21 <byorgey> sure
12:51:08 <Denommus> why does Servant defines Server api = ServerT api (EitherT ServantErr IO) instead of using ExceptT?
12:51:52 <johnw> Denommus: maybe to have other instances?
12:52:50 <jle`> Denommus: it was possibly written before ExceptT
12:53:16 <jle`> ExceptT is still less than a year old i think...
12:53:20 <dmj> Denommus: 0.5 will using ExceptT
12:53:24 <dmj> will use*
12:53:36 <dmj> it's in master
12:57:37 <Denommus> ah, great
12:57:50 <Denommus> well, will have to use EitherT for now
13:01:53 <apriori> any linux mint user here?
13:02:27 <johnw> apriori: if that's leading to a Haskell question, you might want to ask that first
13:02:51 <apriori> johnw, a user here is using linux mint and that apparently provides only an ancient version of ghc (7.6.3)
13:03:06 <apriori> I'm asking whether someone knows the common way to get a more current (say 7.10) version
13:03:09 <Welkin> apriori: install form the binary
13:03:34 <Welkin> apriori: https://www.haskell.org/ghc/download_ghc_7_10_2
13:03:49 <apriori> Welkin, thank you
13:03:56 <Welkin> apriori: and cabal-install 
13:03:58 <Welkin> https://www.haskell.org/cabal/download.html
13:03:59 <ReinH> apriori: personally I use stack to install ghc
13:04:08 <Welkin> sure, you could also use stack
13:04:15 <ReinH> It manages its own ghc and cabal-install installations
13:04:16 <Welkin> stack install cabal-install --install-ghc
13:04:27 <johnw> heh, on 7/15, someone else asked this exact same question apriori 
13:04:36 <ReinH> Welkin: is --install-ghc the default if it doesn't detect ghc in path?
13:04:48 <ReinH> I think it is
13:05:05 <apriori> johnw, sry, man, didn't check the archives. I'm just doing this quick reseach for arek221b, here
13:05:10 <johnw> no problem, it wasn't answered then
13:05:23 <apriori> ReinH, where would I get stack? part of the repo? 
13:05:26 <johnw> shoggoth asked, "I'm running linux mint and the apt-get'd version of ghc is 7.6.3; can anyone give me an idea of how to fix this?"
13:05:28 <johnw> but no one answered
13:05:44 <ReinH> apriori: https://github.com/commercialhaskell/stack/blob/master/doc/install_and_upgrade.md
13:05:49 <bollu> ihaskell-magic-0.3.0.0 depends on magic-1.1 which failed to install.
13:05:49 <bollu> magic-1.1 failed during the building phase. The exception was:
13:05:49 <bollu> ExitFailure 1
13:05:55 <bennofs> apriori: I don't think anyone will complain that you didn't look through the last 10 years of IRC log before asking a question :P
13:05:56 <bollu> Now what? IHaskell build failed
13:06:18 <apriori> bennofs, who knows:)
13:06:22 <bennofs> bollu: magic build failed
13:06:31 <ReinH> bollu: try `cabal install magic-1.1` and see what error it gives. (Assuming you're using cabal)
13:06:54 <bollu> thanks guys, I'll try that
13:07:05 <bollu> Data.hsc:19:10: fatal error: 'magic.h' file not found
13:07:06 <bollu> #include "magic.h"
13:07:16 <bollu> Not very helpful, not sure where that header comes from
13:07:39 <monochrom> johnw: haha pun on "a priori"
13:07:46 <Ankhers> bollu: libmagic. What OS are you on?
13:08:00 <bollu> mac os X
13:08:00 <johnw> monochrom: wow, if only I'd done it intentionally!
13:08:16 <bollu> libmagic is from imagemagick?
13:08:23 <Ankhers> bollu: Do you use homebrew?
13:08:30 <johnw> libmagic, properly executed, should be from thin air
13:08:39 * hackagebot crypto-enigma 0.0.2.6 - An Enigma machine simulator with display.  https://hackage.haskell.org/package/crypto-enigma-0.0.2.6 (Orome)
13:08:39 <bollu> Ankhers: yep
13:08:45 <Ankhers> bollu: brew install libmagic
13:08:48 <Ankhers> Should work.
13:08:57 <Ankhers> Then try installing the package again.
13:09:05 <bollu> what does libmagic even do?
13:09:10 <apriori> ty ReinH 
13:09:15 <bollu> and ah, I didn't realize brew packages libraries as well
13:09:42 <bollu> hm, I already have libmagic installed
13:10:23 <Ankhers> bollu: Apparently you can "determine the type of a file by examining its contents rather than its name"
13:10:57 <Ankhers> bollu: You may need to tell cabal where to find the header file(s)
13:10:59 <geekosaur> libmagic is what makes the "file" command work
13:11:13 <Ankhers> Unfortunately, I do not know the cabal switches.
13:11:14 <bollu> huh, TIL
13:11:19 <geekosaur> (name from the old convention of "magic numbers" at the start of binary files to identify them)
13:11:37 <bollu> I first need to figure out where mac os stores header files :P
13:11:50 <bollu> geekosaur: PNG still does that right?
13:11:51 <dcoutts> Ankhers, bollu: --extra-lib-dirs and --extra-include-dirs
13:11:58 <Ankhers> dcoutts: Thanks!
13:11:58 <geekosaur> bollu, yes
13:12:10 <dcoutts> Ankhers, bollu: or as fields in the local cabal.config file
13:12:15 <geekosaur> as for header files: make sure you have the xcode command line tools installed
13:12:42 <bollu> yes, I do have them. But.. where are they stored? (on arch, it was /usr/include IIRC)
13:12:55 <geekosaur> and then use --extra-{lib,include}-dirs for /usr/local/include and /usr/local/lib
13:13:02 <geekosaur> um, swap those
13:13:09 <geekosaur> and then use --extra-{include,lib}-dirs for /usr/local/include and /usr/local/lib
13:13:17 <geekosaur> because homebrew does not install into apple directories
13:13:41 <geekosaur> (and on el capitan it *can't* install into them)
13:14:09 <bollu> geekosaur: what's with the "can't install"?
13:14:31 <geekosaur> https://en.wikipedia.org/wiki/System_Integrity_Protection
13:14:39 <bollu> and cool, install worked :) do I submit a bug report for IHaskell?
13:15:25 <bollu> geekosaur: oh right, I remember disabling it for something
13:16:02 <geekosaur> hm. apple is generally considering the need to disable it (as opposed to just wanting to disable it to pretend it's more unixy) as a bug
13:16:45 <geekosaur> they have overrides for config files and various other adaptations so you shouldn't actually lose functionality with SIP enabled; if you found something that actually needed it to be disabled, might file a report at https://bugreport.apple.com
13:17:13 <geekosaur> (this does not include third party things that want to inject code, like some spaces extensions; those have to do things differently now)
13:17:13 <lamefun> I have an idea for a wish to make if wish-granting genies were real, and the wish is, please make Microsoft, the creator of C#, the best imperative programming language on Earth, adopt Haskell overhaul and re-do it into Haskell.NET!
13:17:50 <geekosaur> I think they had enough with F#... a Haskell on the CLR would be nice though
13:17:52 <bollu> I can't recall for what I disabled it. I'll try and recall and file a bug report
13:19:11 <suppi> I'm became a bit discouraged with Haskell...
13:19:15 <suppi> ve*
13:19:31 <Ankhers> suppi: Why?
13:19:33 <medfly> what's the matter?
13:19:52 <suppi> I mean, I really like the language, but I miss having tutorials for things
13:20:16 <suppi> I feel like when I want to learn something new I have to invest a lot in learning things
13:20:27 <suppi> like reading haddocks and source code
13:22:16 <lamefun> I've become discouraged with Haskell because it's been a disappointment after a disappointment so far.
13:22:28 <Welkin> suppi: it happens
13:22:29 <Ankhers> lamefun: how so?
13:22:29 <bollu> lamefun: what? in what way?
13:22:41 <Welkin> suppi: but once you have made the investment to learn a useful library, it really pays off
13:22:54 <lamefun> I guess I expected it to be better than it is.
13:23:03 <Ankhers> lamefun: In what way?
13:23:09 <lamefun> Ankhers, https://www.reddit.com/r/haskell/comments/3t5p5e/is_there_something_comparable_to_c_destructors/
13:23:21 <Welkin> um, what?
13:23:28 <Welkin> you don't manage memory in haskell
13:23:51 <dmj> memory manages you
13:23:57 <lamefun> I still have to close files though.
13:24:21 <johnw> lamefun: in the FFI libraries, there are equivalents to destructors (see ForeignPtr) and shared pointers
13:24:42 <johnw> but that's really low-level, and the use of it suggests you are either interoperating with C code, or you might be designing it wrong
13:25:36 <Ankhers> lamefun: As /u/Yuras pointed out, there are things like `withFile' that can deal with the opening/closing for you.
13:26:05 <johnw> right, the RAII pattern from C++ is implemented using "bracket" style scoping in Haskell
13:26:43 <rofl> using Conduit, trying to come up with a function of type `[Source m a] -> Source m [a]`?
13:26:48 <rofl> s/?//
13:27:00 <johnw> try sequenceA?
13:27:00 <dmj> :t sequence
13:27:02 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
13:27:04 <Welkin> :t sequence -- rofl
13:27:06 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
13:27:12 * Welkin slaps dmj with a fermented trout
13:27:15 <johnw> oh, yeah, post-7.10 sequence, yum
13:27:23 * rofl tries it
13:27:28 <Denommus> is it overengineering to have my entire servant application inside a ReaderT [(String, String)] IO only to have access to getEnvironment globaly?
13:27:39 <lamefun> TH has been underwhelming too (can't splice names, can't document TH declarations).
13:27:40 <rofl> i need to learn to recognize typeclasses when i'm working with them
13:27:55 <Welkin> Denommus: why not just use liftIO?
13:28:03 <dmj> Denommus: you have environment variables in your reader?
13:28:07 <bollu1> this is completely irrelevant, but I find it crazy that I went from not understanding monads to being able to instantly think "hm, that looks like sequence". Learning is so weird
13:28:22 <Denommus> Welkin: because then I'd only execute the getEnvironment action once
13:28:25 <johnw> bollu1: indeed
13:28:33 <geekosaur> brains are weird
13:28:41 * hackagebot cndict 0.6.3 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  https://hackage.haskell.org/package/cndict-0.6.3 (DavidHimmelstrup)
13:28:46 <Denommus> dmj: yes, that's what I'm putting in there
13:28:46 <dmj> Denommus: but how often do you need to retrieve environment variables?
13:28:54 <bollu1> aww, how do I get rid of "bollu"?
13:28:58 <suppi> Welkin, yeah, but it's hard, it takes a long time and I'm never really sure I'm doing things right
13:29:01 <Denommus> dmj: there's one environment variable that I'll need all the time
13:29:09 <Denommus> no, wait. I'm wrong
13:29:11 <Welkin> suppi: you learn as you go
13:29:11 <johnw> bollu1: if he's registered with nickserv, you can ask nickserv to bounce him out
13:29:16 <Welkin> suppi: the process is self-correcting
13:29:21 <stephen_> has anyone compiled an update graph of hackage downloads recently? https://galois.com/blog/2009/03/one-million-haskell-downloads/
13:29:24 <Welkin> learning is self-correcting
13:29:25 <stephen_> *updated
13:29:26 <bollu1> johnw: what's the command? and yeah, the nick is registered IIRC
13:29:26 <Denommus> it's not an environment variable. It's just... a variable
13:29:28 <suppi> Welkin, like, say, you want to do some web development
13:29:30 <lamefun> And I'm afraid of using fold* because the first time I used it I got thunk leak.
13:29:32 <Denommus> that depends on an environment variable
13:29:34 <suppi> Welkin, I don't know web development
13:29:37 <johnw> bollu1: oh, I don't remember
13:29:40 <Welkin> suppi: that is 99% of what I do
13:29:43 <johnw> recover maybe?
13:29:51 <Welkin> suppi: and learning to use yesod took a while, but it has paid off handsomely
13:30:14 <monochrom> suppi: do not use feeling to measure "is it right?". use tests. even correctness proofs, if you're into it.
13:30:23 <bollu1> johnw: it was release
13:30:27 <Ankhers> Welkin: How long would you say it would take someone to learn Yesod? I have poked it a couple times, but never really built anything.
13:30:32 <johnw> lamefun: thunk leaks are indeed one of the trickiest things about using Haskell well, where efficiency matters
13:30:32 <Welkin> monochrom: that is not what suppi means, I believe
13:30:35 <suppi> Welkin, so I need to start with some framework, and I didn't like the feeling I got from yesod from viewing videos of live coding and stuff
13:31:17 <suppi> Welkin, but any other web framework like snap, scotty, spock, almost has no tutorials at all
13:31:19 <bollu1> did it work?
13:31:26 <Welkin> Ankhers: I read the yesod book over the weekend, then started building immediately after that and rebult an entire application I had already built in another language in 2 weeks, with more features and cleaner codebase
13:31:49 <suppi> the only one that has decent tutorials is servant, that uses a lot of type-foo I don't yet understand
13:31:54 <Welkin> this was with very little haskell experience
13:31:58 <bollu1> Welkin: there's a book for yesod?
13:32:04 <Ankhers> Welkin: Interesting. Do you know if the book is still relatively up to date?
13:32:11 <Welkin> I didn't understand how to really use monads or monad transformers
13:32:20 <Welkin> Ankhers: yes, it is kept up to date
13:32:23 <Ankhers> bollu1: http://www.yesodweb.com/book
13:32:29 <Ankhers> Welkin: Awesome. Thanks!
13:32:32 <suppi> so not only I have to learn the library with no tutorials, I have to learn the domain as well
13:32:37 <Welkin> http://www.yesodweb.com/book
13:32:55 <bollu1> ooh, awesome
13:32:55 <Welkin> suppi: once you learn how to use one framework (like yesod) you will know how to use the others
13:33:01 <Welkin> web is pretty simple
13:33:11 <Welkin> suppi: try starting with a Wai tutorial for a simple web application
13:33:24 <Welkin> webApp :: Request -> Response
13:33:54 <dmj> Denommus: outside of your web server, does anything else change that environment variable
13:33:56 <suppi> same thing with, say, frp. there are a few web frameworks like reactive-banana and reflex, but no tutorials on how to use them and all the examples looks like meaningless boiler plate
13:34:38 <suppi> Welkin, I can request -> response, but what about sessions? authentication? db? stuff?
13:34:51 <Welkin> suppi: that is included with yesod
13:34:59 <Welkin> suppi: it makes it very easy, which is why I use it
13:35:07 <Welkin> you could build it yourself, bu why?
13:35:30 <Denommus> dmj: it shouldn't, no
13:35:34 <medfly> yes, tutorials kinda suck past the beginner phase
13:35:47 <Welkin> also, in regard to servant, I do not understand all the type-level programming going on, but the tutorials and users in #servant show me enough to build real applications
13:35:54 <Denommus> dmj: nevertheless, it's not really an environment variable. I read an environment variable to produce a Haskell value
13:36:09 <dmj> Denommus: only once right? When the process starts?
13:36:51 <Denommus> dmj: yes
13:37:06 <suppi> Welkin, watching this: https://www.youtube.com/watch?v=BEWJnDgrmp0#t=5m - I don't understand that haskell
13:37:26 <Welkin> with yesod, the book only scratches the surface
13:37:49 <Welkin> I had to ask around in #yesod and carefully read the docs and source code (and the yesod wiki) to find out how to do certain things
13:37:57 <Welkin> but once you figure out how to do it, it is great
13:38:10 <Welkin> if you need helo with yesod, I am usually around to answer questions in #yesod
13:38:30 <Welkin> suppi: that is very old, haha
13:38:43 <Welkin> suppi: start with the book
13:38:46 <Welkin> it is up to date
13:38:58 <suppi> thanks, but the way you described your learning experience is what I feel discouraged about, not only with web, but many other things
13:38:58 <Welkin> also, use the scaffolding
13:39:01 <dmj> Denommus: you should check out envy, it maps haskell types to environment variables
13:39:03 <Welkin> it sets everything up for you
13:39:07 <dmj> Denommus: getEnv = YourType <$> envMaybe "ENV_VAR" .!= defaultValue
13:39:19 <dmj> you can provide defaults if it doesn't exist
13:39:29 <Welkin> suppi: yes, the learning experience can always be made better
13:39:50 <dmj> then just: getEnv >>= \x -> flip runReaderT x op
13:39:52 <Welkin> yesod does need more tutorials
13:40:10 <Denommus> dmj: well, why couldn't I just use ReaderT, then? I inevitably have transformers as dependency anyway
13:40:28 <suppi> I feel like I'm investing a lot of time and effort and not gaining much ability to do things.
13:41:07 <suppi> where in other languages I might gain a lot more ability to do things with the same amount of time and effort
13:41:08 <dmj> Denommus: you can, your web handler transformer stack is orthogonal to env. initialization based on env. variables
13:41:12 <Welkin> suppi: basically, if you just use the auto-generated scaffolding, all you need to do is open up Handler/Home.hs and modify the contents of the do-block in `getHomeR` to get started
13:41:29 <glguy> suppi: It's OK to use other languages
13:41:32 <suppi> that tells me nothing
13:41:44 <Welkin> suppi: that is your handler function for your Home route
13:41:45 <suppi> sorry
13:42:03 <Welkin> you can create your own routes too
13:42:05 <suppi> glguy, yes. I know
13:42:15 <Welkin> every route has a corresponding handler function
13:42:20 <suppi> glguy, I should try doing something else for a while I guess
13:42:36 <Welkin> suppi: it's in the book. If you skim through it you should be able to start building yesod apps quickly :P
13:43:48 * hackagebot tellbot 0.6.0.6 - IRC tellbot  https://hackage.haskell.org/package/tellbot-0.6.0.6 (DimitriSabadie)
13:48:22 <suppi> Welkin, thanks.
13:49:47 <Welkin> suppi: if you have questions you can ask in #yesod
13:50:01 <suppi> Welkin, thanks but I'm not really interested in yesod...
13:50:10 <Welkin> lol
13:50:28 <Wizek> Hello! What would you consider to be the simplest GUI library for Haskell?
13:51:04 <suppi> Wizek, hmm.... perhaps fltk?
13:51:13 <suppi> Wizek, I haven't done any haskell gui though
13:52:41 <suppi> Wizek, also many check wx, threepenny-gui
13:53:12 <suppi> Wizek, this might help you get started: https://en.wikibooks.org/wiki/Haskell/GUI
13:53:46 <monochrom> threepenny-gui is the simplest
13:53:53 <dmj> Wizek: ghcjs + browser
13:54:29 <rofl> i'm seeing sequence :: [Source m a] -> Source m a
13:54:33 <suppi> dmj, how? with react-dom?
13:54:38 <rofl> not [Source m a] -> Source m [a]
13:54:41 <Welkin> reflex-dom
13:54:46 <suppi> woops.
13:54:50 <Welkin> I looked into it briefly
13:54:52 <Welkin> it looks interesting
13:55:07 <dmj> suppi: think there's vdom bindings
13:55:07 <Welkin> ghcjs is still a pain to set up
13:55:14 <Welkin> I have only written hello world with it so far
13:55:16 <Wizek> Yes, threepenny-gui does look simple enough, but I wonder if it can be used for anything beyond very simple examples/projects
13:55:18 <suppi> dmj, can you use your regular tools with it? like stack?
13:55:44 <mniip> should I use Network.Socket or System.Socket
13:55:48 <dmj> suppi: https://github.com/commercialhaskell/stack/wiki/Stack-&-GHCJS
13:55:48 <mniip> (network vs socket)
13:55:54 <johnw> rofl: the first type signature you gave is asum, not sequence
13:56:04 <rofl> sequence would apply to the final result of the Source which is (), not the input value
13:56:07 <johnw> how are you "seeing" that?
13:56:38 <Welkin> dmj: did you get my lambdabot message?
13:57:10 <dmj> Welkin: yes
13:57:16 <rofl> johnw, seq = sequence_ :: [Source IO a] -> Source IO a compiles
13:57:21 <rofl> `seq = sequence_ :: [Source IO a] -> Source IO a` that is
13:57:47 <johnw> sequence_ is not the same as sequence
13:57:51 <rofl> i understand
13:57:54 <johnw> in that case, it's just inferring a to be ()
13:57:54 <suppi> dmj, I mean using stack, ghc-mod and other while developing and building ghcjs apps
13:58:05 <johnw> (or I think that's what it is doing)
13:58:14 <johnw> but you wrote: 13:54 <rofl> i'm seeing sequence :: [Source m a] -> Source m a
13:58:21 <johnw> which means something very different
13:58:22 <trubert8> Prelude> "\x2040" returns "\8256" . How would I define a function that takes "\8256" and returns the string "\x2040" ?
13:58:43 <luite> ghc-mod is not completely compatible yet. it's pretty easy to hardcode it to typecheck with GHCJS, but it should really detect the appropriate compiler flavour from the cabal config
13:58:52 <rofl> you're correct johnw, i had let sequence = sequence_
13:59:10 <suppi> luite, thanks for the info
13:59:17 <johnw> rofl: I recommend not doing that :)
13:59:27 <rofl> noted, johnw :)
13:59:42 <Zemyla> Hmm. A parser type Parser a is isomorphic to a (potentially infinite) list of [(String, a)] which is the list of accepted strings and their values, correct?
14:00:02 <johnw> a Parser a yields a single 'a' as a result value
14:00:04 <aweinstock> :t Numeric.showHex
14:00:06 <lambdabot> (Integral a, Show a) => a -> ShowS
14:00:23 <johnw> so it should be isomorphic to String -> Either String (String, a)
14:00:46 <dolio> In what library? That's certainly not true of all parsers.
14:00:52 <johnw> I was thinking of parsec
14:01:06 <arek221b> Hi, I'm trying to install GHC to new version on Linux Mint. I used ./stack install cabal-install --install-ghc as apriori suggested and I'm kind of stucked with next steps.
14:01:29 <aweinstock> > let octal = sum . zipWith (*) (iterate (*8) 1) in showHex (octal [6,5,2,8]) ""
14:01:30 <Zemyla> johnw: Yes, but it yields it when it's parsed. A parser that takes any number of 'a's and returns that number is equivalent to the list [("", 0), ("a", 1), ("aa", 2), ...]
14:01:32 <lambdabot>  "10ae"
14:01:44 <dmj> suppi: I think you can use ghc-mod while writing code that will compile to ghcjs, since it's still haskell at that point. But ghcjsi repl isn't publicly released yet AFAIK
14:01:55 <aweinstock> > showHex 8256 ""
14:01:56 <lambdabot>  "2040"
14:02:00 <johnw> Zemyla: then I don't understand
14:02:02 <aweinstock> trubert8: ^
14:02:15 <coeus> hi,
14:02:20 <trubert8> aweinstock: fantastic, thank you!
14:02:29 <johnw> dolio: granted, 'Parser' is too opaque a term to know anything about it
14:02:38 <coeus> Zemyla, the strings are the unparsed tails.
14:02:41 <aweinstock> trubert8: are you familar with ShowS / difference lists?
14:02:47 <benzrf> anyone recommend any libaries for shell stuff besides turtle?
14:02:59 <benzrf> is there a better option, or is turtle the best choice?
14:03:03 <coeus> :i ShowS
14:03:03 <aweinstock> > ("hello"++) . (" world"++) $ ""
14:03:05 <lambdabot>  "hello world"
14:03:16 <johnw> benzrf: there is also shelly
14:03:18 <Zemyla> johnw: Well, basically I'm thinking I could represent a parser as Parser a = Parser { onPure :: Maybe a, onEOF :: Maybe a, onChar :: Map Char (Parser a) }.
14:03:27 <benzrf> johnw: do you recommend it over turtle?
14:03:33 <aweinstock> basically, you compose functions that prepend to a string to get O(1) concatenation, and it's what showHex returns
14:03:36 <johnw> I haven't used both, only shelly
14:03:42 <coeus> > :i ShowS
14:03:45 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:03:51 <coeus> >  ShowS
14:03:53 <lambdabot>  Not in scope: data constructor ‘ShowS’
14:03:59 <aweinstock> coeus: Lambdabot doesn't support :i
14:04:12 <coeus> hmpf.
14:04:13 <aweinstock> ShowS = String -> String -- (I think)
14:04:26 <Zemyla> And that way, it would be amenable to static analysis.
14:05:33 <coeus> gaah.. ReadS
14:05:39 <coeus> Prelude> :i ReadS
14:05:39 <coeus> type ReadS a = String -> [(a, String)]
14:05:39 <coeus>         -- Defined in `Text.ParserCombinators.ReadP'
14:06:17 <aweinstock> "a parser of things is a function from strings to lists of pairs of things and strings" -- seussian parser
14:07:33 <coeus> Prelude> (readsPrec 0::ReadS Int) "123abc" 
14:07:33 <coeus> [(123,"abc")]
14:08:14 <glguy> coeus: You're welcome to ask a question, but please stop pasting raw output from GHCi
14:08:22 <coeus> ok
14:09:43 <coeus> a parser will give you a result value and the remaining unparsed string, if parsing was successfull.
14:10:12 <coeus> a parser can have one result or multiple valid results or none.
14:11:23 <coeus> so it is more or less equivalent to ReadS. besides that, it could give you additional infos about line numbers etc.
14:12:08 <dolio> That's one way to represent a parser. But not the only way.
14:13:49 * hackagebot atlassian-connect-descriptor 0.4.3.0 - Code that helps you create a valid Atlassian Connect Descriptor.  https://hackage.haskell.org/package/atlassian-connect-descriptor-0.4.3.0 (RobertMassaioli)
14:13:51 <johnw> dolio++
14:13:53 <coeus> left to say, that ReadS parsers are inefficient because they re-parse the entire input in case they have multiple alternating outputs.
14:16:48 <rofl> turns out, it was zipSources
14:17:01 <mniip> sooo
14:17:07 <mniip> Network.Socket or System.Socket?
14:17:24 <rofl> actually, sequenceSources
14:17:30 <rofl> anyway there's a built-in function
14:17:40 <rofl> conduit-dependent i mean
14:18:30 <alpounet> Denommus: servant is switching to ExceptT in the next release, FWIW
14:18:38 <bitemyapp> alpounet: grumble
14:18:57 <bitemyapp> alpounet: :)
14:19:11 <alpounet> yeah well it's already merged, so... i was against it, but an "underwhelming minority" =)
14:19:29 <bitemyapp> alpounet: I don't think the type should exist in transformers, but what do I know?
14:19:35 <bitemyapp> alpounet: what did it replace? What did you prefer?
14:19:53 <bitemyapp> alpounet: as it happens, writing the stuff for the monad transformers chapter.
14:19:59 <bitemyapp> then back to parsers
14:20:26 <alpounet> bitemyapp: it replaced EitherT, from the 'either' package
14:20:54 <alpounet> i was against it because it's identical and will break all the servant code i've ever written =)
14:21:39 <bitemyapp> alpounet: bloody unnecessary type.
14:21:55 <dmj> alpounet: dep. hardcoding, 'servant == 0.4.4.5', problem solved =)
14:22:58 <alpounet> dmj: yeah, well, 0.5 would bring a lot of goodness to those apps =) even though i might not be writing servant services/apps in a while
14:23:22 <alpounet> i might just let julian, andres, you etc lead servant where you guys want and not oppose anything anymore, caring about other stuffs =P
14:24:01 <dmj> alpounet: noooo ! don't leave us =)
14:24:07 <dmj> maybe MonadError has instances for both ExceptT / EitherT
14:27:14 <dmj> alpounet: servant-devops will soon generically infer testing, profiling, benchmarking, builing, ci and deployment all from a type. The future awaits us.
14:27:31 <bitemyapp> dmj: good lord man
14:28:25 <bitemyapp> dmj: alpounet MonadError has Either and ExceptT, but not EitherT.
14:28:34 <bitemyapp> dmj: alpounet which makes sense. `either` isn't used by a lot of people.
14:28:44 <bitemyapp> dmj: alpounet would it perhaps make more sense to use MonadError instead?
14:28:48 <bitemyapp> and let users pick their concretion.
14:28:55 <glguy> Monad m => MonadError e (EitherT e m)
14:29:15 <bitemyapp> Monad m => MonadError e (EitherT e m)
14:29:17 <glguy> The 'either' package depends on 'mtl' and provides that instance
14:29:18 <bitemyapp> yeah I just saw it
14:29:47 <bitemyapp> dmj: alpounet yeah since EitherT has it as well, it seems like strictly a win to use MonadError unless there's some issue with the polymorphism?
14:30:10 <KaneTW> imo ExceptT is much better simply because it actually tells you what the type does
14:30:33 <alpounet> bitemyapp: IIRC it's a bit tricky to make that work, but that's what I've always wanted, yup! Just didn't find some time to investigate it
14:30:40 <bitemyapp> alpounet: tricky how?
14:30:44 <KaneTW> it shouldn't be that hard to change though
14:30:49 <bitemyapp> alpounet: it should even avoid breaking existing code.
14:30:52 <KaneTW> i thought EitherT/ExceptT were largely isomorphic
14:31:05 <bitemyapp> alpounet: since the specified type would yank down the constraint.
14:31:16 <forker> Hey guys, could you please take a look at MergeJSON (case description inside):  http://lpaste.net/145410 . Is there anything available to fill in the same gap?
14:31:33 <dmj> bitemyapp, alpounet: I think the problem comes in with runEitherT on tests, etc. You can't really run-* on MonadError e m (unless I'm mistaken)
14:31:40 <dmj> from servant-client
14:32:02 <bitemyapp> dmj: argh
14:32:06 <bitemyapp> wait really?
14:32:10 <alpounet> bitemyapp: we return 'EitherT ...' at the end of some type-family recursion (mapping an API type to types of handlers, glued together), so it's not obvious if (and where) we could state the MonadError constraint 
14:32:37 <bitemyapp> alpounet: could you link an example?
14:32:39 <KaneTW> wait did they refactor to MonadError or ExceptT?
14:32:44 <alpounet> dmj: well, we could just pick EitherT (or ExceptT) for the tests and not care I guess.
14:32:47 <dmj> bitemyapp: afaik yea
14:33:03 <alpounet> bitemyapp: well... the example here is servant-server itself really =)
14:33:22 <alpounet> bitemyapp: but tl;dr: type Server (Get ctypes a) = EitherT ServantErr IO a
14:33:31 <alpounet> but then Server is defined for all the other type-level "combinators" as well
14:34:09 <alpounet> and i'm not sure just writing: type Server (Get ctypes a) = MonadError m => ... would do what we want
14:35:30 <alpounet> also, if a handler just does, say, "return [1, 2]", GHC might complain about ambiguous type for the handler
14:36:19 <bitemyapp> right it would.
14:36:21 <alpounet> anyway, if anyone wants to dive deep down that rabbit hole, i'm happy to provide guidance in #servant, but we should probably not steal #haskell for servant dev discussions =P
14:36:35 <dmj> alpounet: true, wonder if :~> can shield the user from a lot of breakage. At least, confining the breakage to that definition.
14:40:18 <ttt_fff> this might be OT (but is for my haskell dev). So I'm using (1) vim, (2) cabal repl, (3) tmux, and (4) now -- nixos. My old setup was (1) put a "cabal repl" inside a named tmux (2) vim can then pipe commands to cabal repl by using tmux. Recently, I switched from ubuntu to nixos. Unfortunately, nix-shell appears to screw up my tmux where two tmuxes can only talk to each other if in the same nix-shell. Has a
14:40:24 <ttt_fff> nyone else run into this problem? If so, how did you resolve it? (Some people in nixos have given up on tmux). I'm happy with a non-tmux solution as long as I can pipe from vim to cabal repl.
14:44:06 <Cale> ttt_fff: What does tmux do which using multiple terminal windows doesn't?
14:44:27 <ttt_fff> it allows me to put "cabal repl inside a tmux
14:44:32 <ttt_fff> then from vim, I can send commnads to the cabal repl
14:44:43 <Cale> uh
14:44:46 <merijn> Cale: You can pipe to a "remote" tmux, another terminal can't be piped too
14:44:49 <ttt_fff> so from vim, I can do things like
14:45:04 <merijn> Cale: i.e. I can run a command that tells tmux to "pretend the following text came on remote tmux' stdin"
14:45:12 <ttt_fff> tmux send-keys -t "BLAHBLAH" Enter C-l ":r" Enter
14:45:14 <Ralith> sounds like a ridiculously complicated reinvention of a named pipe
14:45:26 <ttt_fff> and this tells the "cabal repl" in BLAHBLAH to run ":r" to reload all my *.hs files
14:45:44 <Cale> uhhh okay
14:46:03 <ttt_fff> this way, I'm in vim, I type ":make", and it causes "cabal repl" to run ":r" to reload/recompile stuff and give me ghc errors
14:46:06 <Cale> I don't know why you'd need such a command to send 2 keystrokes, but I'm not sure I want to know :)
14:46:09 <mniip> how can I get a subsecond precision clock in haskell?
14:46:27 <ttt_fff> isn't this the standard "write a little bit of code + continuously see if it type checkes dev strategy" ?
14:46:52 <Cale> ttt_fff: What I usually do is to save my file, and then point at the other window and hit :r
14:47:02 <Cale> which doesn't require anything fancy at all
14:47:07 <ttt_fff> yeah, now that I'm in xmonad, it's actually not that bad at all
14:47:10 <monochrom> am I reading an elaborate scheme of "using tmux to glue a lot of off-the-shelf components into a homebrew IDE"?
14:47:13 <mniip> I usually write a bunch of code and then start fixing type-errors one by one
14:47:18 <koshmar> if I write let x = 1 + x,  then I ask what is a value of 0 * x, why it is in infinite loop, taking into accout laziness, why (0*) needs secod argument?
14:47:32 <ttt_fff> monochrom: pretty much
14:47:35 <mniip> koshmar, that's how * (on Integers) works
14:47:35 <Cale> I also don't use xmonad, it's by no means required to do this
14:47:40 <Cale> any window manager should do
14:47:48 <Cale> Just use more than one window
14:47:52 <hexagoxel> ttt_fff: dumb suggestions: have you compared the environments inside and outside nix-shell?
14:47:59 <mniip> koshmar, it could support 0*undefined, but then it wouldn't support undefined*0
14:48:29 <ttt_fff> hmm, dumb followup: how does this effect tmux? (honest question; no idea how tmux works
14:48:45 <ttt_fff> I mean, the env vars definitely differ
14:48:47 <koshmar> in other words (*) is strict
14:48:51 <ttt_fff> but what should I be looking for?
14:48:54 <mniip> on Integers
14:48:55 <mniip> yes
14:49:01 <mniip> you could define your own Num instance
14:49:35 <koshmar> thx
14:50:56 <hexagoxel> ttt_fff: TMUX, perhaps? (inside tmux started in one shell vs the other, just for diagnosis
14:51:15 <monochrom> koshmar: when one day you define your own number type and write your Num instance, you can make your own (*) conditionally non-strict i.e. "x * y | x==0 = 0". but then people will ask "so what happens to undefined*0?" and you can't win it all.
14:51:50 <Cale> Unless you do crazy unsafe things :)
14:51:53 <koshmar> =)
14:52:34 <koshmar> it is tradeof performence vs symetry(niceness)
14:52:36 <koshmar> I guess
14:52:50 <mniip> performance is not involved
14:52:52 <ttt_fff> hexegoxel: hmm, one is /run/user/1001/tmux-1001/... the other is /tmp/tmux-1001/....
14:52:56 <ttt_fff> I suspect that is the problem
14:53:05 <mniip> performance is a measure of code that terminates
14:53:07 <ttt_fff> they can't find each other since they're using different 'temp' directories ?
14:53:16 <mniip> we are talking about bottoms vs non-bottoms
14:53:27 <hexagoxel> ttt_fff: that would be my guess, yeah.
14:53:29 <koshmar> what about product [..... 0 .....]
14:53:36 <mniip> still not
14:53:51 * hackagebot cndict 0.6.4 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  https://hackage.haskell.org/package/cndict-0.6.4 (DavidHimmelstrup)
14:54:13 <lynnard> how can I tell ghc to use another directory as my .ghc?
14:54:44 <ttt_fff> hexegoxel: okay, according to the man page, sockets are created under TMUX_TMPDIR, which is TMPDIR if TMUX_TMPDIR is not set, and is /tmp if both are unset. So it appears that nix-shell must be changing env TMP, okay; thanks for your help!
14:55:05 <bernalex> lynnard: IDK, but you could always just use symlinks.
14:55:32 <lynnard> bernalex: sure, but I'm using two different ghcs on the same version but with different setup
14:55:47 <bernalex> lynnard: maybe ask #ghc
14:55:58 <lynnard> okay will give that a try thx
14:56:05 <monochrom> Haskell 2010 doesn't say whether (*) should be unconditionally strict or not. not even when you know the type is Int.
14:56:23 <dfeuer> Some things in Data.Configurator look too lazy for their own good. The ones I've seen so far are lookup and lookupDefault. Hrmmm.
14:57:13 <monochrom> so I guess one fine afternoon in the past an implementer decided to make it unconditionally strict to reduce programming effort. (if you do this, then you have a simpler story of mapping it to stock hardware)
15:00:42 <Cale> > undefined * 0
15:00:45 <lambdabot>  0
15:00:47 <Cale> ^^ btw
15:00:58 <KaneTW> wat
15:01:02 <Welkin> yes, that is because of how it is defined
15:01:04 <Welkin> pattern matching
15:01:18 <Welkin> times _ 0 = 0
15:01:21 <Welkin> times 0 _ = 0
15:01:21 <Cale> This happened with the recent change to the way that GMP is used to implement Integer
15:01:33 <Cale> It's probably an accident
15:01:39 <monochrom> haha
15:02:26 <monochrom> Welkin, you mean you know how it is defined?
15:02:45 <Welkin> monochrom: that is what I remember from looking at something a couple months ago
15:02:48 <Welkin> the same question came up
15:03:34 <monochrom> is that something GHC source code? base source code?
15:03:35 <Cale> This means that we have
15:03:44 <Cale> > 1 `div` 0
15:03:45 <lambdabot>  *Exception: divide by zero
15:03:48 <Cale> > (1 `div` 0) * 0
15:03:50 <lambdabot>  0
15:03:55 <Cale> ^^ oops!
15:04:27 <Cale> There are downsides to being nonstrict when it comes to numbers sometimes
15:05:36 <Welkin> https://hackage.haskell.org/package/integer-gmp-1.0.0.0/docs/src/GHC.Integer.Type.html#timesInteger
15:05:39 <Welkin> here it is
15:06:35 <Cale> Yeah, it no longer uses GMP's integer implementation, just big naturals.
15:07:19 <geppettodivacin> Cale: I can't reproduce that result in ghci.
15:07:27 <Cale> geppettodivacin: Which ghci?
15:07:40 <geppettodivacin> v. 7.6.3
15:07:49 <monochrom> that's too old
15:07:51 <Cale> Yeah, that's way way too old
15:08:03 <Cale> This started happening in 7.10.1
15:08:06 <Welkin> geppettodivacin: this is a recent change
15:08:16 <geppettodivacin> Hmm. It's the one that came with Ubuntu's haskell platform.
15:08:40 <Cale> Yeah, never trust your linux distribution to provide anything Haskell related :P
15:08:47 <geppettodivacin> Indeed.
15:08:49 <monochrom> yeah but ubuntu takes ghc from debian. and debian people never catch up.
15:09:19 <monochrom> by 2020 they may finally adopt 7.10
15:09:19 <Cale> Debian is almost optimally off-cycle with GHC, they freeze like a month before GHC releases come out
15:09:25 <KaneTW> on my ubuntu server i still have 7.6.3 as hte /usr/bin install but i never bother updating
15:09:44 <KaneTW> i have 7.10.2 in /opt if i need it 
15:09:50 <Cale> and then sometimes they miss doing the update altogether
15:09:53 <KaneTW> i should replace /usr/bin ghc but i never get around to it
15:10:16 <geppettodivacin> It doesn't appear that cabal can update ghc and/or haskell-platform.
15:10:22 <KaneTW> no, it can't
15:11:29 <Denommus> in Parsec, how do I parse any character that ISN'T a spaceChar?
15:11:54 <ttt_fff> I think there is a "not"
15:12:03 <glguy> Denommus: with 'satisfy'
15:12:07 <Cale> satisfy (not . isSpace)
15:13:13 <jophish> How do people go about comparing the performance of a package between versions. I'm trying to make my package a little more speedy and what I'm doing at the moment is creating a criterion report with one version, moving it elsewhere, changing the code and creating the report again
15:13:51 * hackagebot exp-pairs 0.1.4.0 - Linear programming over exponent pairs  https://hackage.haskell.org/package/exp-pairs-0.1.4.0 (Bodigrim)
15:13:58 <jophish> It's not too bad, but it would be nice to know if there was a better way
15:14:41 <aisqwe> is STM implemented in haskell or is it ghc base?
15:16:12 <lambda-11235> STM is part of the haskell platform but not base. So it is implemented in haskell.
15:17:13 <Welkin> base is haskell too
15:17:20 <Welkin> it's all haskell afaik
15:18:29 <lambda-11235> It isn't all implemented in haskell though, particularly GHC base.
15:18:45 <dfeuer> Is it just me, or is `empty` in http://hackage.haskell.org/package/configurator-0.3.0.0/docs/src/Data-Configurator.html#empty completely and totally broken in combination with things like `addGroupsToConfig`?
15:23:14 <monochrom> no, STM has to have its foundational parts built into the runtime written outside Haskell
15:23:23 <Zemyla> aisqwe: To answer your question, the STM stuff is defined in http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Conc.html, but it's exported in the STM package.
15:23:29 <monochrom> the package library "stm" is only a wrapper around the builtins
15:24:46 <aisqwe> why isnt it written in Haskell itself? what is the barrier? performance or somekind of shortcoming?
15:24:48 <monochrom> for example you can see how the high-level orElse simply calls the low-level orElse
15:27:05 <Cale> aisqwe: Why isn't what written in Haskell?
15:27:34 <aisqwe> why isnt STM written in Haskell but C? what is the barrier? performance or somekind of shortcoming?
15:28:16 <Zemyla> aisqwe: It has to do with threading, I think.
15:28:18 <Denommus> Cale: I wasn't aware of isSpace in Data.Char
15:28:21 <Denommus> thanks
15:28:25 <Cale> aisqwe: Well, the RTS is written in C. I think the RTS was just originally written in C, and nobody saw the need to rewrite it, because it's the sort of code which C is well-tuned to (lots of pointer manipulation), and rewriting it in Haskell would have limited benefit.
15:32:44 <Cale> aisqwe: At least, that's what I recall hearing Simon Marlow say at some point. He may or may not be right about it. I can see how perhaps an approach to RTS construction using Haskell code that generates LLVM or something might work out nicely and have some good properties.
15:33:20 <Cale> But it'd mean repeating a lot of work regardless
15:33:52 * hackagebot tellbot 0.6.0.7 - IRC tellbot  https://hackage.haskell.org/package/tellbot-0.6.0.7 (DimitriSabadie)
15:34:53 <ReinH> Cale: Also according to SimonM it's hairy enough that it would be pretty difficult to port correctly
15:36:19 <monochrom> Hairy Porter and the Half-Working ARM Port
15:37:31 <Cale> https://www.youtube.com/watch?v=tsp2JntuZ3c Harry Porter and the Computer of Relays
15:37:53 <jophish> hmm, I've got some code which runs in 100ms when compiled into an executable, but in ghci has taken 5 minutes and still hasn't terminated. Any thoughts?
15:38:04 <mniip> jophish, optimization
15:38:08 <mniip> namely strictness analysis
15:38:27 <jophish> yeah, that's what I'm trying to debug, but I'm not sure where to go
15:38:39 <Cale> GHCi will load .o files if they're available
15:38:52 <Cale> You might want to compile the code and load the compiled code into ghci
15:38:52 * hackagebot tellbot 0.6.0.8 - IRC tellbot  https://hackage.haskell.org/package/tellbot-0.6.0.8 (DimitriSabadie)
15:39:09 <jophish> I think it's very similar to the issue I had a while ago where things took minutes without -fprof but with profiling were taking millisecods
15:39:16 <monochrom> haha Cale
15:39:54 <bitemyapp> monochrom: LOL
15:40:04 <Cale> btw, that is a really good lecture for people wanting to get a basic understanding of computer architecture
15:40:38 <jophish> hmm, cabal doesn't seem to be picking up the object files after cabal build
15:40:42 <jophish> ghci*
15:41:00 <Cale> There's some relay-specific stuff to it, but not much
15:41:03 * sm bookmarks
15:42:14 <monochrom> loading compiled code into ghci has become more complicated since ghc yanked its homebrew linker and moved to OS's linker
15:42:42 <jophish> It would still be nice to find out what's causing this behavior
15:42:49 <cheater> can someone explain to me what this new Strict extension is about?
15:42:52 <monochrom> more precisely, OS's dynamic lib linker
15:43:07 <jophish> I solved the previous issue like this by chucking in a few INLINE pragmas
15:43:51 <monochrom> at the same time, ghc still defaults to compiling to code for static-linking rather than for dynamic-linking. (oh, static-linking has its advantage, too)
15:44:42 <jophish> Does the ghci interpreter inline functions at all?
15:45:12 <monochrom> all in all you have to say "ghc -c -dynamic X.hs" to obtain the right kind of compiled code that later ghci feels like loading
15:45:49 <monochrom> and if you don't feel like using ghc directly, if you feel like going through cabal, then I don't even know where you should start
15:46:16 <monochrom> ghci doesn't inline
15:46:27 <jophish> ah, that would be it then
15:46:39 <jophish> It's a bit of a pain for any users of my package
15:46:45 <monochrom> but yeah, 100ms vs 5-minutes-and-counting is bizzare
15:46:53 <jophish> I'll put some strictness annotations in :)
15:47:46 <jophish> monochrom: what I discovered last time was that with profiling turned on (or with the INLINE pragmas) some values were being shared and culling some exponential tree of repeated work
15:48:38 <jophish> a tool to visualize the program graph and each reduction step would be amazingly useful here
15:48:55 <jophish> It would be possible to see exactly where all these calls are coming from
15:49:53 <monochrom> the next best thing is using Debug.Trace's stuff at a few places
15:51:16 <jophish> monochrom: that's what I did last time, but it was pretty tricky. The whole package is build around a type CReal (Word -> Integer). So putting traces in the functions which generated those datatypes and in the type's function itself just lead to a huge tangle
15:54:12 <sm> jophish: in what sense ? too much output ?
15:55:42 <jophish> sm: yeah, it was just reams of the same output as it was evaluated over and over again while the profiled version was more or less the same pattern but only a handful of times
15:56:15 <sm> I like to give trace statements a debug level, so I can adjust the verbosity level without recompiling
15:56:49 <sm> also I've had some luck strategically indenting their output, to indicate the call nesting and help readability
15:57:47 <jophish> I'm at it again now, with just one trace statement and there's already more than a page for a simple calculation
15:58:31 <jophish> and the indentation is a problem as most of the trace statements are inside lambda functions which are being passed about willy-nilly
15:58:53 <sm> sometimes I'll have it just print a single character, eg .
15:59:17 <jophish> yup, I'm just printing the argument to the lambda, just single Word < 100
16:00:10 <jophish> I wish there was some way to put strictness annotations everywhere by default ¯\_(ツ)_/¯
16:00:40 <ReinH> jophish: use GHC head
16:01:07 <jophish> ReinH: sadly I can't get most things to compile with it
16:01:15 <monochrom> :)
16:01:15 <jophish> nixpkgs at ghcHEAD seems totally broken
16:01:16 <ReinH> well yeah
16:10:39 <rcat> quit
16:28:07 <tommd> No.
16:37:01 <Wizek> Hello. I presume it is possible to do something the lines of `Exception e => Either e a`, right? And if so, does it make sense to handle errors like so?
16:38:06 <Wizek> e.g. pure, total functions returning Either values, when different kinds of exceptions are also possible to be returned.
16:38:49 <Wizek> I am thinking about this for more expressive way to handle errors than `Maybe a` or `Either String a`
16:46:39 <pavonia> Wizek: Returning "Either SomeErrorType a" isn't uncommon
16:49:02 <ReinH> it's even common
16:59:33 <Wizek> pavonia, ReinH, and is it possible to have a function that may return any kind of exceptions? I'm thinking about a situation, where a function doesn't want to handle an exception type explicitly, but rather wants to return it even further up. `case foo of Left SomeException -> handle; Left e -> Left e; a -> a`
17:03:11 <jle`> it's possible but not recommended as a solution in a real project
17:03:33 <jle`> er wait let me re-read
17:04:07 <jle`> okay, that actually won't really work as you've written it like you'd like it
17:04:54 <jle`> `foo` is of a fixed type, so it's inferred to be Either SomeException a
17:05:31 <jle`> so the Left branch is never gone down
17:05:38 <jle`> *the second Left branch
17:06:09 <geekosaur> unless data AnException = SomeException | AnotherException | ...
17:06:19 <Wizek> Yeah, that's what I'm trying to wrap my head around atm. Even if I try to say `Exception e => Either e a`, GHC will just assign a concrete type, right?
17:06:23 <jle`> oh yeah, i was guessing that they were using SomeException from base
17:06:35 <geekosaur> yeh, if doing that then you need to be trickier
17:06:54 <geekosaur> but then, those are for actual exceptions and not intended for use with Either
17:06:55 <jle`> Wizek: yeah, so, if you have Either MyException a, but another exception type was thrown, I believe that it'll still "show up" when you try to evaluate `a`
17:07:15 <jle`> er wait, no ><
17:08:54 <alevy> Is there a way to reference the associated type of a class generically?
17:09:11 <ReinH> "the associated type of a class"?
17:09:20 <alevy> for example, if I have a class `class Foo where;  data Bar :: *`
17:09:51 <Wizek> geekosaur, So that path is rather clear to me: I could define a data type for all the different kinds of errors one of my functions might return in the Left branch, what I am worried about is that is not very scalable, because whichever other function calls that function would need to handle all exceptions explicitly and it wouldn't really be capable to selectively handle a few and pass on the rest.
17:09:52 <alevy> and i want to write a function that, given a Foo, returns the `Bar` for that `Foo`
17:10:28 <orb__> alevy: on the value level?
17:10:43 <jle`> Wizek: if you're talking about IO actions that can throw IO errors, it's common to chain catch's and try's, I think
17:11:00 <jle`> that should give you that fall-through chained catching that i think you're going for
17:11:21 <geekosaur> actually, handle a few is exactly what you get with that because you can case ... Left x -> Left x as long as all possible x are constructors of the same "exception" type. but yes, it's got scalability issues.
17:11:22 <alevy> orb__ not sure what you mean, but I'd like to write something like `extractFoo :: Foo a => a -> A'sBar`
17:11:41 <bitemyapp> jle`: https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Exception.html#v:catches ?
17:11:51 <alevy> If it's a method of the class, I can just call it `Bar` i think, but can I reference it from a non-method function?
17:11:52 <geekosaur> this is why extensible exceptions uses an existential wrapper (SomeException) and handlers which are essentially specializations of Data.Typeable.cast
17:12:02 <jle`> bitemyapp: oh neat, that would work too
17:12:14 <glguy> alevy: In general a class can have 0 to many associated types. There's no special relationship between those things for you to do something like this without writing it yourself
17:12:30 <geekosaur> but that has its own issues, since you can;t just case-match on them
17:12:41 <glguy> alevy: but for extractFoo, you have :: Foo a => a -> Bar a
17:12:57 <glguy> alevy: The associated types are always indexed by the class variables
17:13:00 <geekosaur> see what bitemyapp just pointed to; it's essentially what you replace the case matching with
17:13:01 <alevy> oh, `extractBar` was just a randomly chosen function name. this would be a function that I write that actually does something with the associated type
17:13:18 <alevy> I'm just trying to figure out if there is a way to name that type in the function signature
17:13:23 <bitemyapp> jle`: use it all the time at work. Really nice.
17:13:30 <orb__> alevy: how about
17:13:30 <glguy> alevy: The name fo the type is 'Bar a'
17:13:31 <orb__> class FooBar f a | f -> a where     convert :: f -> a
17:13:46 <jle`> interesting that it has to be built into GHC
17:13:59 <glguy> alevy: class Foo a where data Bar a :: *
17:14:05 <glguy> not, data Bar :: *
17:14:15 <alevy> ooooooohhhhh.....
17:14:43 <alevy> and `data Bar a :: *` can stil be instantiated to something like `Int64`, right? (because it's `*)
17:15:36 <glguy> instance Foo Stuff where data Bar Stuff = NewCon Int
17:15:52 <alevy> orb__ yeah, I have it with type families now, but using associated data types would make the types less cumbersome as they propogate up, in my case
17:16:11 <orb__> alevy: what's your use case, actually.
17:16:37 <alevy> I'm trying to implement a generic primary key type in postgresql-orm
17:16:46 <geekosaur> (but `catches` is for async exceptions. you could probably use the same Typeable machinery to do an out of band / Either version)
17:16:52 <alevy> which is an ORM for postgresql (surprise surprise)
17:17:20 <alevy> so a Model would have an associated primary key type (currently we just assume Int64)
17:17:38 <BlackCap> How do you create the infinite list:
17:17:38 <BlackCap> [ (1,1)
17:17:38 <BlackCap> , (1,2), (2,1), (2,2)
17:17:38 <BlackCap> , (1,3), (3,1), (3,2), (2,3), (3,3) ... ]
17:17:38 <Wizek> geekosaur, well, yes, `Left e -> Left e` would indeed pass uncaught exceptions upwards, I was thinking that if that function also wanted to throw other kinds of exceptions, I would need to define yet another data type even if the kinds of exceptions are rather common, (e.g. DivideByZero, NoFileFound, AccessDenied, etc...)
17:17:57 <alevy> Since Model is a primitive of the library, using type families really explodes the type signatures in the rest of the library
17:18:11 <johnw> BlackCap: we've golfed that in channel before, a few times even
17:18:19 <tobiasBora> Hello !
17:18:20 <johnw> I think dolio had the best answer then
17:18:31 <ReinH> @hackage control-monad-omega -- BlackCap
17:18:31 <lambdabot> http://hackage.haskell.org/package/control-monad-omega -- BlackCap
17:18:48 <geekosaur> Wizek, so read on the rest of what I said
17:18:55 <BlackCap> Thanks :)
17:19:28 <tobiasBora> A little question about Text.Rgexp.Posix : What does "faa fbb" =~ "(aa|bb)":: [[String]] means ? I understand if it would be [String], but [[String]] is less clear in my mind...
17:19:34 <tobiasBora> *Regexp
17:19:51 <geekosaur> basically, you can use an existential wrapper (like SomeException) and develop your own machinery. it's kinda annoying though
17:20:03 <johnw> tobiasBora: all the matches: ["aa", "bb"], I think
17:20:03 <benzrf> in turtle, how does one get a FilePath out of an env var
17:21:05 <Wizek> jle`, Yes, I am considering using `throw` and `catch` as well, although I don't quite like how catching only works in IO. That's why I am thinking if I can make `Either e a` work somehow so I can have pure and total functions.
17:21:28 <Wizek> benzrf, isn't FilePath a type synonym for String?
17:21:36 <benzrf> shit, is it?
17:21:44 <tobiasBora> johnw: Well actually it has in my example some duplicates : [["aa","aa"],["bb","bb"]]
17:22:03 <benzrf> Wizek: no not this one
17:22:07 <johnw> yes, group 0 and group 1
17:22:08 <tobiasBora> johnw: (and your expression is [String], not [[String]])
17:22:18 <johnw> group 0 is the entire string that matched, group 1 is the first group that matched
17:22:29 <johnw> "(aa)" <-- the size of the entire match is the same as the size of the first group
17:22:30 <benzrf> Wizek: its different from prelude FilePath
17:22:42 <johnw> oh, right
17:22:59 <johnw> it's the list of groups of each match :)
17:23:04 <geekosaur> tobiasBora, the documentation is kinda impenetrable. but the idea is that you can match multiple times, and each one can have submatches (captures)
17:23:24 <tobiasBora> johnw: geekosaur: oh I see !
17:23:31 <johnw> "faa fbb" =~ "f(aa|bb)":: [[String]]  -->  [["faa", "aa"], ["fbb", "bb"]]
17:24:11 <tobiasBora> geekosaur: And where their are several matches, it begins after the last match right ?
17:24:17 <geekosaur> yes
17:24:25 <geekosaur> although regex flags may control that
17:24:29 <tobiasBora> Great thank you !
17:24:36 <tobiasBora> geekosaur: What's that ?
17:26:50 <geekosaur> tobiasBora, http://hackage.haskell.org/package/regex-posix-0.95.2/docs/Text-Regex-Posix-Wrap.html#t:ExecOption although in that particular case there doesn;t seem to be such an option
17:27:09 <Wizek> benzrf, Is this the one perhaps? https://hackage.haskell.org/package/system-filepath-0.4.13.4/docs/Filesystem-Path.html
17:27:24 <geekosaur> other regex engines may offer it
17:27:42 <Wizek> benzrf, and if so, you have toText, and fromText https://hackage.haskell.org/package/system-filepath-0.4.13.4/docs/Filesystem-Path-CurrentOS.html
17:27:47 <geekosaur> (it's kinda unusual; there used to be ways to enable it but they've largely gone away from disuse)
17:28:12 <geekosaur> (that is, an option to rescan something it already matched for more matches)
17:28:18 <tobiasBora> geekosaur: Ok thank you ! Thank you also johnw !
17:28:19 <Wizek> benzrf, To me it seems Turlte is importing FilePath from system-filepath
17:28:29 <johnw> tobiasBora: :)
17:28:53 <hackrilege> Hi
17:29:35 <benzrf> aha
17:29:37 <benzrf> thanks !
17:30:41 <alevy> can I declare a default type for an associated data type?
17:30:56 <Wizek> benzrf, Cheers! Please let me know if/when it worked, I'm also interested in learning more about Turtle. 
17:32:23 <hackrilege> I still have questions about the correct use of classes and data structures. I recently encountered proxy types when trying to define an empty method returning just the type parameter to a parametrised class. If trying to make all classes data structures, excessive construction is required which would have a default in a class with default definitions
17:33:15 <johnw> hackrilege: in general, avoid type classes until they become such a good idea that not using them seems wrong
17:33:37 <hackrilege> The question is how to determine that point
17:33:45 <johnw> it should be self-evident at some point
17:33:55 <johnw> the moment you're "manually passing around dictionaries" everywhere, making you reach for Reader
17:33:56 * hackagebot GPipe-GLFW 1.2.1 - GLFW OpenGL context creation for GPipe  https://hackage.haskell.org/package/GPipe-GLFW-1.2.1 (plredmond)
17:34:01 <johnw> you'll know that you're basically implementing a type class by hand
17:34:31 <hackrilege> I don't understand the reference to Reader
17:34:53 <johnw> it manages "passing an argument argument", so that you don't have to do contortions to compose functions
17:35:02 <johnw> "passing an argument around"
17:35:27 <hackrilege> Like deciding scope?
17:35:39 <hackrilege> With where clauses
17:35:42 <johnw> I don't know what that means
17:36:49 <hackrilege> If rather not pass arguments to internally defined functions of they are available in the wider scope of the function arguments, or in a where clause
17:36:57 <hackrilege> If
17:36:59 <johnw> ah, I see
17:37:12 <johnw> i was thinking more along the lines of composing multiple functions at module scope
17:37:23 <johnw> which, without reader and always passing the same arguments, gets tedious
17:38:03 <hackrilege> Constructing nested data types by hand is long, is that what you are saying?
17:38:14 <johnw> no, not at all
17:38:21 <johnw> I'm wondering if we're talking about the same thing...
17:38:37 <hackrilege> Well i don't understand reader
17:38:51 <johnw> a -> b -> c =~ a -> Reader b c
17:39:19 <johnw> given several a -> Reader b c functions, you can conveniently use >>=
17:39:34 <hackrilege> So what do you mean by "reaching for" the reader?
17:39:46 <johnw> composing multiple a -> b -> c functions gets annoying
17:39:53 <johnw> so you'll want to factor out the drudgery
17:40:02 <johnw> and that will mean "reaching for Reader" as your first ray of hope
17:40:07 <hackrilege> Scan dot out something?
17:40:16 <johnw> "Scan dot out"?
17:40:17 <hackrilege> Or not out sorry
17:40:44 <hackrilege> Factor out drudgery what is that?
17:40:59 <johnw> oh, maybe it's just a language barrier
17:41:12 <hackrilege> :t scan (.)
17:41:13 <lambdabot>     Not in scope: ‘scan’
17:41:13 <lambdabot>     Perhaps you meant one of these:
17:41:13 <lambdabot>       ‘scanl’ (imported from Data.List),
17:41:23 <johnw> factoring out drudgery means doing a little up front work to eliminate repetitive and tedious work
17:41:34 <johnw> nothing to do with scan
17:41:59 <hackrilege> OK
17:42:26 <hackrilege> My point was about construction
17:43:06 <hackrilege> That default methods should be provided in class header, I'm not sure about data types though.
17:43:14 <montanonic> Hey, anyone have opinions of good books for learning about web development? I know that it's a broad category, but that's kind of the problem for me. I need a solid overview of the different parts all along the Stack because I'm still finding Yesod to be a bit too much for me to wrap my head around.
17:43:49 <montanonic> I'm working on HTML/CSS/JS currently, and that's helped a lot, but it still feels like there's so much to cover beyond that.
17:44:28 <johnw> hackrilege: in the context of Haskell, I don't know what that means
17:44:28 <hackrilege> Oh i can talk about that but i don't have a resource to direct you to monatonic other than to scratch around HTTP.Simple
17:44:59 <montanonic> hackrilege: HTTP.Simple? That a website?
17:45:28 <hackrilege> OK so suppose i have a vector, it's clearly a class, why? Because we don't want to define dot each time we construct a vector
17:46:16 <hackrilege> http://hackage.haskell.org/package/HTTP-Simple-0.1/docs/Network-HTTP-Simple.html
17:46:32 <hackrilege> That is
17:46:32 <montanonic> ^ ty
17:46:40 <hackrilege> Np
17:47:42 <hackrilege> Does that analogy of vector construction help johnw?
17:48:51 <hackrilege> It's just a partially applied function that i seek I'm being really dumb sorry
17:49:54 <hackrilege> hey monatonic, what's your web app?
17:50:41 <johnw> hackrilege: ok :)
17:50:48 <hackrilege> Yeh sorry
17:51:16 <hackrilege> What do you mean passing round dictionaries all the time?
17:51:26 <montanonic> hackrilege: https://en.wikibooks.org/wiki/Main_Page + http://hellohappy.org/beautiful-web-type/, + StackOverflow-inspired Reputation and Priveleges
17:51:39 <hackrilege> Awesome
17:52:04 <montanonic> I'm new to this stuff so my initial plan is to just have the most basic core
17:52:23 <montanonic> I'm not expecting things to go any where on my first try, but I do want to learn the full stack as much as I can.
17:53:12 <alevy> is there a way to say that an associated data type should be an instance of a particular class (like `Eq`)?
17:53:27 <montanonic> It's just hard knowing where to start after I graduate with my HTML/CSS skills. There are a billion JS things
17:53:42 <montanonic> And a lot of that JS is super-beginner friendly but not scalable or high-level
17:53:56 <hackrilege> Instance Superclass Subclass where
17:54:13 <montanonic> and coming from several months of dedicated haskell study, I need my tools to be scalable and high-level
17:54:31 <hackrilege> E.g. instance Eq Mytype where
17:54:56 <alevy> hackrilege, i mean, in my class decleration
17:56:07 <hackrilege> class Eq a => MyParamatrisedType a where
17:56:14 <hackrilege> Is that any good?
17:56:43 <hackrilege> It's a parametrised class not a parametrised type sorry
17:57:32 <hackrilege> Then anything that instantiates that class should also instantiate Eq
17:58:49 <hackrilege> monatonic Haskell and web js have a bad history. I'd love an expert on that to talk to
17:59:20 <alevy> hackrilege not examtly, but looks like `class Eq (MyAssoc a) => MyType a where data MyAssoc a :: *` does
17:59:31 <alevy> *exactly
17:59:45 <hackrilege> Aha
18:00:21 <hackrilege> Not sure about the placement of the word data there
18:02:11 <hackrilege> (Eq a,Assoc a) =>
18:03:08 <hackrilege> You can write an instance of Eq fit Assoc
18:03:17 <hackrilege> For
18:03:42 <hackrilege> and then just require  Eq a
18:08:46 <hackrilege> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html
18:43:01 <anks> why:  many` parser, throws an incomplete input exception?
18:43:15 <anks> how can I achieve manyTillFail functionality?
18:43:22 <anks> in attoparsec
19:11:29 <cwl> :hoogle Traversal' t a -> Traversal' t b -> Traversal' t (a, b)
19:12:29 <cwl> Does this function already exists?
19:13:16 <shachaf> No.
19:14:00 <shachaf> It's problematic when the traversals overlap.
19:15:51 <cwl> I have a json array, and want to get the 5th and 6th elements. What's the simplest way to get [(5th, 6th)]
19:16:03 <cwl> sorry, a json array of array
19:16:13 <cwl> [[a]] -> [(a, a)]
19:17:19 <Axman6> only the 5th and 6th elements?
19:17:33 <Axman6> why do you need the wrapping list in the result, wouldn't (a,a) work?
19:18:27 <cwl> Axman6: I get data from http request
19:18:53 <cwl> Axman6: And I am interested in 5th and 6th elements only.
19:20:19 <Axman6> any reason you can't just (,) <$> arr ^? nth 5 <*> arr ^? nth 6?
19:23:48 <cwl> Axman6: let val = (r ^. responseBody) ^.. key "data" . values . nth 5  -- to get 5th elements
19:24:19 <Axman6> you could do (r ^. responseBody) ^.. key "data" . values just once and then use nth on that result
19:24:27 <Axman6> if you care about not traversing everything twice
19:24:44 <Axman6> my experience with even large json files is that it doesn't matter a whole lot
19:26:20 <glguy> You don't need to mix ^. and ^..
19:26:35 <glguy> In that context:  r ^.. responseBody . key "data" . values
19:26:43 <glguy> but instead of making a list like that
19:26:55 <cwl> Axman6: That would work. But I think if we can get a function :: (a -> b -> c) -> Lens s a -> Lens s b -> Lens s c is great
19:27:00 <glguy> r ^? responseBody . key "data" . _Array
19:27:08 <glguy> and then just use vector operations on it
19:27:39 <glguy> liftA2 (,) (arr !? 4) (arr !? 5) -- if you want to get fancy
19:28:26 <cwl> glguy: Yes, that's more concise
19:38:18 <Wizek> Anyone here has experience with reactive-banana-wx? And if so, is it just me, or does it also seems to you that constructing and managing `Behavior Layout`s is more complicated than desirable?
19:39:37 <qmm> lenList [] = 0
19:39:42 <qmm> lenList (x:xs) = 1 + lenList xs
19:40:27 <qmm> {- open ghci -} :load lenlist.hs --lenList.hs:3:24: Not in scope: ‘+’
19:49:23 <geekosaur> you showed 2 lines, and an error on line 3. what's the third line?
19:49:25 <geekosaur> @paste
19:49:25 <lambdabot> Haskell pastebin: http://lpaste.net/
19:49:28 <geekosaur> ^ pastebin
19:50:45 <tabemann> btw, what's the difference between rem and mod?
19:52:41 <kadoban> > (-1) `rem` 5
19:52:43 <lambdabot>  -1
19:52:46 <kadoban> > (-1) `mod` 5
19:52:48 <lambdabot>  4
19:52:51 <kadoban> tabemann: That ^
19:52:53 <geekosaur> quot truncates toward 0 (so upward for negative numbers), div truncates downward; rem is the remainder relative to quot, mod is the remainder relative to div
19:53:01 <qmm> http://lpaste.net/6075377101576339456
19:53:30 <tabemann> aren't quot and rem faster than div and mod?
19:53:52 <kadoban> Hmm. I wouldn't think so.
19:53:54 <geekosaur> qmm, it's still complaining about line 3 of a 2-line file. which makes me wonder if you have something in ~/.ghci
19:54:05 <P4Titan> Hello all, Is it possible to do this: data Triplet a = Triplet a a a and then define Show only on Triplet Double?
19:54:22 <qmm> my .ghci http://lpaste.net/1022395734789455872
19:54:44 <kadoban> P4Titan: I don't see why not, though you probably shouldn't usually I would think.
19:55:13 <logavanc> Hello... very large room of people...
19:55:26 <P4Titan> I want Triplet to be generic and not contrain it like data (Show a) => Triplet a = Triplet a a a
19:55:39 <geekosaur> qmm, next question is if the directory identified in the -i option has a module Prelude in it
19:56:07 <kadoban> P4Titan: Well, you can make it an instance of Show iff 'a' is an instance of Show. You don't have to constrain it like that for that.
19:56:14 <kadoban> logavanc: Hello
19:56:19 <tabemann> class constraints in types are generally a bad idea
19:56:21 <geekosaur> (one of the directories? I didn';t think : acted as a separator there)
19:56:34 <tabemann> you normally want to put class constraints on individual functions rather than on types themselves
19:56:37 <logavanc> I guess I will just throw my question out there and see if any of you smart people can point me in the right direction.  =)
19:56:51 <P4Titan> ok
19:56:53 <kadoban> P4Titan: instance (Show a) => Show (Triplet a) where …  I think should be the syntax
19:56:53 <geekosaur> ...ah, I see it does
19:57:23 <P4Titan> So, will that limit Triplet to hold only showable values?
19:57:28 <qmm> geekosaur: nope, just two files that i've created
19:57:33 <qmm> ch2.hs and LenList.hs
19:57:33 <geekosaur> so check for a Prelude.hs (or Prelude.o / Prelude.hi pair) in one of theose directories; ghci will load that as the Prelude and you will be unhappy if it is not based on the standard one
19:57:36 <tabemann> P4Titan: you generally don't want to do that
19:57:45 <kadoban> P4Titan: No. It'll make Triplet a only an instance of Show if 'a' is an instance of Show (or if another instance applies)
19:57:50 <geekosaur> (or not otherwise a usable Prelude)
19:57:52 <tabemann> you want to put the class constraint on your relevant functions that act on Triplet
19:58:12 <P4Titan> so doing what kadoban is bad?
19:58:19 <P4Titan> or bad practice at least
19:58:28 <geekosaur> otherwise, I don't have enough information
19:58:46 <kadoban> I believe they are talking about your original idea, starting with data (Show a) => …
19:58:46 <logavanc> I am on problem #4 of the Haskell exercises of exercism.io (named "sublist").  I am trying to understand what I need to put into my module so that the given unit test code witll work.  The line in the unit test code that imports my module's stuff (or will once I make it) is as follows, and I don't understand it:  import Sublist (Sublist(Equal, Sublist, Superlist, Unequal), sublist)
19:58:53 <glguy> No, kadoban is doing it right, your putting the constraint in the data type is wrong
19:59:03 <P4Titan> ok
19:59:16 <qmm> geekosaur: all i did was `mkdir rwh` and create 2 files ch2.hs and LenList.hs  ls -tra shows no extra files in .rwh
19:59:20 <P4Titan> very well, thanks
19:59:30 <qmm> geekosaur: i perform `cd rwh` before starting ghci
19:59:43 <pavonia> qmm: Did you write that .ghci file?
19:59:54 <geekosaur> is there a directory named "config" or a directory named "dist/build/autogen" somewhere it could find?
19:59:58 <qmm> ah, i think i may know what's going on
20:00:03 <qmm> i need to run `stack ghci`
20:00:11 <geekosaur> because those also are in the -i option and a Prelude in one of those directories will override
20:00:11 <qmm> sorry, it's been a couple of months since i've used haskell
20:00:20 <logavanc> It looks like "sublist" is the function, so I need to implement that.  But what is the other stuff?
20:00:21 <geekosaur> um. you shouldn't need stack to get a working Prelude
20:00:23 <P4Titan> now, can I do the following
20:00:30 <kadoban> logavanc: Sublist should be a type. It should have data constructors Equal, Sublist, Superlist, etc. There should also be a value named sublist (Actually a function I assume)
20:00:53 <P4Titan> somehow type Vector = Triplet Double and then implement a custom show for Vector. I know type simply makes a synoynm and should not be used here, newtype maybe?
20:01:17 <logavanc> Alright, a type and constructors!  Awesome! Thank you kadoban, I will start googling.
20:01:19 <qmm> i get the same error though. i guess `stack ghci` isn't the solution. i didn't write that entire ~/.ghci file. i copy/pasted hoogle and doc commands from the haskell wiki i think
20:01:22 <kadoban> logavanc: So you want something like: data Sublist = Equal | Sublist | Superlist | Unequal
20:01:59 <tabemann> you can't make an instance for a type synonym that doesn't also apply to the type it is a synonym of
20:02:21 <qmm> geekosaur: there isn't a directory in `~/rwh` named config/ or dist/
20:02:27 <qmm> just those two files
20:02:46 <qmm> can't find those directories anywhere
20:03:19 <P4Titan> In short: How should I best make a Vector type out of my defined Triplet type?
20:03:20 <qmm> `locate -i autogen | grep -i dist` doesn't show up anything
20:03:35 <tabemann> R4Titan: use a newtype
20:03:45 <logavanc> kadoban: so the sublist function will return... a Sublist type, which can be... yeah, I need to read up a bit.
20:03:54 <tabemann> *P4Titan
20:03:55 <P4Titan> newtype Vector = Vector (Triplet Double)
20:04:18 <P4Titan> yes?
20:04:36 <kadoban> logavanc: Yeah, it's basically a function that returns a "sum type" which tells the caller how the two lists compare
20:05:34 <kadoban> logavanc: If you're just getting started with haskell, there's some good resources we can probably point you towards, if you're interested. exercism.io is nice, but I don't think it's really designed to teach you the whole lanugage, just kind of get some style tipse here and there.
20:08:10 <logavanc> Yeah, any resources you have would be nice.  I tend to learn by doing, so reading through Learn you a haskell for the greater good is nice, but I drift off.  I like that exercism.io makes me write code.
20:14:12 <logavanc> Only other question I have is why the Haskell code I have seen puts the comma before items in a list rather than after?
20:14:28 <logavanc> Assuming that the choice wasn't arbitrary.
20:14:48 <glguy_> We like lining them up
20:15:44 <P4Titan> So, I have newtype Vector = Vector (Triplet Double). Is there a neat way to pattern match vector rather than doing (Vector (Triplet i j k)) or a neat way to contructo Vector rather than Vector $ Triplet i j k?
20:15:57 <Axman6> logavanc: makes it easier to comment out lines too
20:16:34 <logavanc> I have been trying to follow the style guide here: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
20:17:21 <kadoban> logavanc: Sorry, I got a bit distracted. https://github.com/bitemyapp/learnhaskell has good advice. There's also a book in progress by the same person that sounds good to me: http://haskellbook.com/ . Yeah LYAH is … severely lacking in exercises.
20:17:22 <logavanc> But I have to admit that I have been having a hard time since it is so different from Python or JS... or C, or C++, etc.
20:17:55 <logavanc> Awesome kadoban, thank you!
20:17:56 <glguy_> If the placement of commas messes you up, Haskell is going to be a rough transition :)
20:18:34 <kadoban> logavanc: I do it because it works better in version control. It's easier to see what was added/removed in diffs.
20:18:54 <logavanc> lol glguy_ that might be true... but so help me I *WILL* learn Haskell, or die trying.
20:19:40 <logavanc> What little I have been able to grasp of Monads and Curying has straight up blown my mind already.
20:22:10 <P4Titan> What depicts whether a class takes * or *->*?
20:24:58 <kadoban> P4Titan: Just how it's used in the methods of the class I think
20:25:39 <pavonia> Or an explicit kind annotation
20:26:08 <kadoban> For example, (>>=) :: m a -> (a -> m b) -> m b, so m has to be kind * -> *.
20:26:08 <P4Titan> Where in fmap does it require * -> *?
20:26:14 <kadoban> There's kind annotations?
20:26:19 <kadoban> :t fmap
20:26:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:26:28 <P4Titan> ohhh
20:26:33 <P4Titan> I see it
20:26:41 <kadoban> P4Titan: f a  is kind *, so f has to be * -> *. Right
20:27:21 <pavonia> :t undefined :: (m :: * -> *) a
20:27:23 <lambdabot> m a
20:27:46 <kadoban> Are those an extension or something?
20:27:54 <kadoban> Don't remember reading about kind annotations.
20:28:33 <pavonia> Not sure if this requires an extension
20:34:10 <pavonia> :t undefined :: (m :: k -> *) (a :: k)
20:34:11 <lambdabot> forall (k :: BOX) (m :: k -> *) (a :: k). m a
20:34:22 <kadoban> Apparently it's KindSignatures. Can't tell if it's on by default in GHC though
20:34:47 <pavonia> There you also have an annotation for a kind, I always forget how this is called
20:35:03 <pavonia> Sort?
20:35:32 <glguy> KindSignatures is an extension and not enabled by default in GHC
20:37:35 <emmanuel_erc> hi guys!
20:38:21 <Pamelloes> Hi!
20:42:42 <emmanuel_erc> That's an interesting name Pamelloes.
20:51:19 <Pamelloes> Oh?
20:52:25 <Pamelloes> emmanuel_erc: How so?
20:54:00 <emmanuel_erc> I don't know... it seems like you're trying to make a joke with your handle... though I am not quite sure what that joke is.
20:54:33 <Pamelloes> Not a joke per se. Just a large misspelling.
20:55:21 <Pamelloes> It was supposed to be Pomelos referring to the fruit which I had just eaten before first registering the name.
20:55:55 <Pamelloes> I was pretty young at the time and had never seen Pomelo written so I spelled it how I thought it should have been spelled.
20:56:19 <Pamelloes> Now many many years later I'm still using it :)
20:57:45 <Pamelloes> On a haskell related note, are there any good caching libraries?
21:00:39 <emmanuel_erc> What are you trying to do Pamelloes?
21:02:21 <emmanuel_erc> Do you have any experience using hmatrx Pamelloes?
21:02:39 <Pamelloes> I'm making calls to an online api that puts a "cache until" value on all of its responses. So I need to cache all of my queries to respect the cache timer.
21:03:30 <Pamelloes> emmanuel_erc: I haven't used hmatrx before, though I'm pretty familiar with linear algebra.
21:09:24 <dmj> Pamelloes: you could use hashtables, or put a Map / IntMap / HashMap in an IORef / MVar / TVar
21:10:26 <Pamelloes> Why would I put the Map/IntMap/HashMap in an IORef/MVar/TVar instead of just passing it around normally?
21:10:59 <Pamelloes> Oh, well I guess the MVar/TVar allows for concurrency.
21:11:18 <Pamelloes> Does a hashtable automatically compensate for concurrency?
21:16:00 <emmanuel_erc> Hi there, Pamellos, I hope this does not seem like to basic a question: But I need to solve a least squares problem, however, the rectangular matrix in question is huge (800 rows). Every other part of my code is fine, except that part (predictably). Any pointers on what I could do to get over this hump?
21:17:01 <dmj> Pamelloes: what do you mean by 'compensate' for?
21:17:05 <dmj> @package hashtables
21:17:05 <lambdabot> http://hackage.haskell.org/package/hashtables
21:17:41 <Pamelloes> emmanuel_erc: 800 rows doesn't sound that huge, are you having performance issues?
21:19:03 <emmanuel_erc> yes, I am.
21:19:21 <ReinH> 800 rows is the opposite of huge
21:19:51 <emmanuel_erc> Then I must be doing something wrong... I wanted to wait to ask for help on the matter at at least try to figure it out on my own.
21:20:09 <Pamelloes> dmj: Oh, interesting. Hashtables are mutable.
21:20:17 <peddie> emmanuel_erc: can you post your code?
21:20:25 <peddie> or at least the slow part?
21:20:25 <emmanuel_erc> I've alread traced my code and I know that it is stalling on matrix part.
21:20:32 <emmanuel_erc> Yeah, it is on github.
21:20:36 <emmanuel_erc> hold on
21:21:14 <Pamelloes> dmj: Why would I use a HashTable vs a HashMap? Is the table substantially faster?
21:21:56 <emmanuel_erc> The link is https://github.com/emmanueldenloye/manifoldRNC/blobb/master/src/InterpolationAlgorithms.hs
21:22:45 <peddie> emmanuel_erc: remove one 'b' from 'blobb' ;)
21:22:57 <emmanuel_erc> I am bad at typing.
21:23:06 <peddie> so the slow part is L.<\> ?
21:23:12 <emmanuel_erc> https://github.com/emmanueldenloye/manifoldRNC/blob/master/src/InterpolationAlgorithms.hs
21:23:29 <emmanuel_erc> No, the slow part is the second argument to L.<\>
21:23:53 <emmanuel_erc> Or at least that is it what seems to be the problem to me.
21:24:21 <peddie> 'ptdists'?  so doesn't that mean that forming the argument is the problem, not the actual least-squares solve?
21:25:42 <emmanuel_erc> I think so. The argument ptdists is really "L.fromRows $ dists pt"
21:25:50 <emmanuel_erc> That might be lazy.
21:26:22 <peddie> isn't it built from 'projections pt' which has a fold with a cons and a dgemv in the accumulator function?
21:26:23 <dmj> Pamelloes: HashMap is pure, it should be a little slower (base on a trie), average case O(log n), but amortized to O(1). hashtables is impure and can potentially benefit by exploiting certain cpu instructions. It's based on arrays (vector). Most operations are in constant time.
21:27:38 <Pamelloes> Alright.
21:27:38 <emmanuel_erc> I am sorry, you're right.
21:27:49 <emmanuel_erc> My mind is not 100% right now.
21:27:54 <dmj> Pamelloes: here's benchmarks, http://gregorycollins.net/posts/2011/06/11/announcing-hashtables
21:27:55 <emmanuel_erc> But thank you.
21:28:00 <peddie> no prob, just trying to understand
21:28:53 <emmanuel_erc> IIRC, I am using the foldr to create a list of vectors, which will then be converted to a matrix.
21:28:57 <emmanuel_erc> by the function L.fromRows
21:29:13 <ReinH> why not just use a list of lists?
21:29:57 <peddie> how are you profiling?  is is it possible to ask for a more fine-grained profile?  hmatrix's least-squares solve just calls out to a pretty fast C routine, so it seems more likely that the problem might come from all the bashing back and forth between storable vectors, unboxed vectors, lists, etc.
21:30:25 <Pamelloes> dmj: Thanks! I have to go to bed now, but I will definitely look over that tomorrow :)
21:30:32 <emmanuel_erc> That is probably the problem. I use unboxed vectors to make certain operations fast.
21:30:54 <emmanuel_erc> I am profiling by using the -sstderr flag when I run it.
21:31:01 <peddie> is your algorithm difficult to rewrite in terms of some of the many manipulation functions in Numeric.LinearAlgebra.Data?
21:31:17 <peddie> it's not guaranteed that those will be fast, but maybe it's faster than going back and forth with lists
21:31:43 <emmanuel_erc> I can't rewrite everything in terms of Numeric.LinearAlgebra.Data
21:32:03 <peddie> if I understand correctly, Storable vectors are like C arrays, so if you're just using doubles and ints, I don't think you will gain anything by using Unboxed vectors
21:32:49 <peddie> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html also
21:32:49 <emmanuel_erc> https://github.com/emmanueldenloye/manifoldRNC/blob/master/src/NearestNeighbor.hs
21:33:10 <peddie> oh, I just meant the algorithm right here in InterpolationAlgorithms.hs
21:33:14 <emmanuel_erc> In this module, for the same algorithm, I used unboxed vectors and everything was fine.
21:33:34 <emmanuel_erc> though admittedly I am doing something completely different here.
21:33:59 <peddie> sure, I don't think unboxed vectors are any worse
21:34:41 <emmanuel_erc> But, I suppose I'll just try passing in a list of lists.
21:34:50 <peddie> I dunno, maybe someone more knowledgeable about the vector package can comment
21:35:00 <peddie> I just chimed in because I'm familiar with a bunch of hmatrix stuff
21:35:18 <emmanuel_erc> So the (L.<\>) function is definitely not the problem?
21:35:37 <peddie> well, it sounded like you said you had profiled and determined that the problem was in evaluating its argument
21:35:58 <peddie> I would be surprised if L.<\> were the cause of performance problems here
21:36:09 <emmanuel_erc> I am sorry, I am really tired and I just can't stop making errors.
21:36:18 <peddie> don't sweat it :)
21:36:21 <emmanuel_erc> I fucked up describing my problem ... agghhh
21:36:44 <emmanuel_erc> It was "dists pt" that is taking so much time to evaluate.
21:37:31 <peddie> ah, interesting
21:38:04 <emmanuel_erc> I just had to check to make sure I didn't make another problem description error.
21:38:26 <emmanuel_erc> but yea, that is taking quite some time to even evaluate.
21:38:27 <peddie> I can't tell from your description how you're profiling, but the profiling guide I linked is worth a read if you haven't
21:38:33 <abg> Hey. I have a GADT with zero-arg constructors like, data Foo a where A :: Foo TypeA, B :: Foo TypeB. My experiments tell me it's safe but I just want to confirm: Checking (A == unsafeCoerce B) is "safe", right?
21:38:37 <emmanuel_erc> I'll take a look
21:38:42 <abg> At least, to the extent you can be using a function called unsafe
21:44:53 <emmanuel_erc> peddie, I think may have I realized what the problem is.
21:45:32 <peddie> emmanuel_erc: oh, really?  what is it?
21:46:22 <emmanuel_erc> It is this line I think -> rowBuilder rw = L.vjoin[1,L.vector rw,L.flatten $ L.vector rw `L.outer` L.vector rw] .
21:46:58 <emmanuel_erc> Every row of a matrix that I use at a later time is construted by this code.
21:47:17 <peddie> I see
21:47:46 <emmanuel_erc> And I am guessing that (L.<\>) cannot begin to evaluate until its arguments have been evaluated.
21:47:49 <peddie> so too much converting back and forth or something?
21:47:56 <peddie> yes, that's correct about L.<\>
21:48:00 <emmanuel_erc> That might be it.
21:48:48 <peddie> do you know that that line is really slow to evaluate, or are you guessing based on some other info?
21:49:08 * hackagebot foscam-filename 0.0.1 - Foscam File format  https://hackage.haskell.org/package/foscam-filename-0.0.1 (TonyMorris)
21:49:10 * hackagebot foscam-directory 0.0.1 - Foscam File format  https://hackage.haskell.org/package/foscam-directory-0.0.1 (TonyMorris)
21:52:33 <orion> Are there any good tutorials for writing a custom monad which restricts the functionality of IO?
21:54:39 <dibblego> there is free monad and monadic regions
21:57:10 <Cale> orion: The simplest thing to do is just to make a module with a newtype of IO in it, using generalised newtype deriving to get instances for Functor, Monad and Applicative at least, define a function MyMonad a -> IO a which unwraps it, and then the specific actions you want to allow
21:57:19 <Cale> Don't export the newtype's data constructor
21:57:49 <emmanuel_erc> peddie, I am just trace statements to see what might be happening
21:58:47 <peddie> emmanuel_erc: I really suggest using the GHC profiling tools to get a more accurate picture of what's taking up all the time
21:59:04 <emmanuel_erc> Yeah, I'll incorporate that.
21:59:37 <peddie> GHC knows how to attribute costs correctly, and it will generate a profile for the whole program
22:00:24 <peddie> then it's safe to experiment with speeding things up, because you won't accidentally speed up your trace statement but slow things down someplace else or whatever
22:02:40 <emmanuel_erc> Yeah, I originally didn't because I wasn't able turn on profiling for some of the libraries I had installed, and I guess I was getting anxious because I was low on time and I didn't want to bother reinstalling every package.
22:02:53 <emmanuel_erc> But it seems to be find right now.
22:02:56 <emmanuel_erc> fine*
22:03:22 <peddie> I think you'll save time in the long run if you can just get GHC to tell you exactly what's slow ;)
22:04:16 <emmanuel_erc> Right. Can I get the profiling information even without using the -prof flag?
22:04:22 <peddie> I don't think so
22:04:24 <emmanuel_erc> Just thought I'd ask to be sure
22:04:42 <emmanuel_erc> ok, now I have to  reinstall a bunch of stufff....
22:04:50 <peddie> :/
22:05:08 <peddie> you can configure cabal to install profiling libs by default if you expect to do a lot of development
22:05:32 <emmanuel_erc> I've tried that... I wasn't successful though
22:05:54 <peddie> it won't reinstall stuff you've already installed just from changing the .cabal/config file
22:05:59 <emmanuel_erc> I see
22:06:05 <emmanuel_erc> What do I have to do?
22:06:21 <emmanuel_erc> Unearth everything?
22:06:23 <peddie> reinstall it all by hand, unfortunately (unless someone else knows a better way)
22:06:28 <peddie> yeah . . . 
22:06:29 <emmanuel_erc> fuck
22:06:38 <peddie> indeed
22:06:41 <emmanuel_erc> Sorry for my language
22:06:49 <emmanuel_erc> There are so many dependencies
22:06:51 <peddie> I'm not offended
22:07:27 <peddie> yeah . . . this has bitten me as well in the past
22:07:37 <orion> Cale: How would I go about specifying the actions I want to allow?
22:07:42 <peddie> so I learned to always enable profiling libs as soon as I set up a new machine
22:07:51 <orion> Within the unwrapping function
22:08:03 <Cale> orion: By applying the newtype's data constructor to them and exporting them
22:08:15 <emmanuel_erc> I am going to reinstall everything by hand, but I may have found what the problem was.
22:08:30 <peddie> not that `vjoin` call?
22:08:37 <Cale> The unwrapping function doesn't do anything much in this scheme -- you can just let it be the field extractor if you use record syntax.
22:08:46 <emmanuel_erc> I put a trace on this line (it is long): map (L.vector . map (snd . head . unLPath) . tail . flip spTree graph . snd)  val
22:09:07 <emmanuel_erc> And it was producing each line for the outer map very slowly
22:09:20 <orion> Cale: I see. I'll have to give that a try. Thanks!
22:09:24 <peddie> is spTree slow?
22:10:00 <emmanuel_erc> the big operation on that line in spTree.It is getting all the shortest paths from some point p to all the other nodes in the graph. 
22:10:56 <emmanuel_erc> I am probably recalculating the same results more times than I should be.
22:11:18 <peddie> ok
22:12:08 <emmanuel_erc> To be specific, the function takes as input a some points in the same neighborhood and finds all the shortest paths from each point in than neighborhood to all other points in the graph.
22:12:21 <peddie> excluding one another, it looks like
22:12:26 <emmanuel_erc> As you might imagine, this is expensive and  wasteful. 
22:12:31 <emmanuel_erc> Yea, I goofed.
22:12:48 <peddie> I can imagine it's expensive ;)  but I can't tell how wasteful it is, I don't fully understand what the code is doing
22:13:18 <emmanuel_erc> For that part of the calculation I don't actually need the full paths, I just need the distances.
22:13:26 <peddie> ah
22:13:30 <emmanuel_erc> Which is why I have that huge expression
22:13:32 <peddie> well, nice
22:14:09 * hackagebot envy 1.0.0.0 - An environmentally friendly way to deal with environment variables  https://hackage.haskell.org/package/envy-1.0.0.0 (DavidJohnson)
22:14:17 <emmanuel_erc> Did that part make sense to youu? I may have stated it awkwardly
22:14:42 <peddie> yeah, I get the idea
22:15:28 <emmanuel_erc> I might have to restort to some trickery to get this code working fast.
22:15:34 <peddie> I have to go, but it sounds like between getting profiling set up and thinking carefully about the problem, you are on the right track
22:15:57 <peddie> I'm sure once you measure precisely what the expensive part is, others will be able to suggest ways to speed it up
22:16:57 <emmanuel_erc> thanks you for your patience peddie
22:16:58 <peddie> good luck!
22:17:04 <peddie> you're welcome
22:56:21 <varaindemian> But because functions are curried by default, the second pair of parentheses is really unnecessary, because -> is right associative by default. (a -> b -> c) -> (b -> a -> c) is the same as (a -> b -> c) -> (b -> (a -> c)), which is the same as (a -> b -> c) -> b -> a -> c. We wrote that g x y = f y x.
22:56:43 <varaindemian> Can someone explain me what does right associative mean?
22:57:32 <peddie> varaindemian: https://en.wikipedia.org/wiki/Operator_associativity
22:57:49 <liste> "operator * is right associative" means that a * b * c is a * (b * c)
22:58:16 <liste> in this case, a -> b -> c is a -> (b -> c)
22:58:27 <geekosaur> most operators are left associative. -> is right associative, as is ^ (that is, 2^3^4 is 2^(3^4))
23:03:48 <varaindemian> geekosaur: so + is left associative 2 + 2 + 2 = (2 + 2) + 2, right?
23:04:28 <geekosaur> right, although it's irrelevant for (+) because it doesn't care what order its parameters are in
23:04:32 <davidar> :i (+)
23:04:52 * davidar fails at lambdabot :(
23:05:13 <geekosaur> lambdabot doesn't do :i / :info
23:05:21 <geekosaur> only ghci does
23:08:50 <Cale> Rather, it doesn't matter for (+) because (+) is associative
23:09:57 * hackagebot wai-extra 3.0.13 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.13 (MichaelSnoyman)
23:10:10 <Cale> i.e. for all x, y, z, we have x + (y + z) = (x + y) + z
23:10:26 <Cale> It's also true that for all x, y, we have x + y = y + x, but that doesn't matter
23:16:05 <mauke[o}> > 1e99 + (-1e99) + 1
23:16:07 <lambdabot>  1.0
23:16:09 <mauke[o}> > 1e99 + ((-1e99) + 1)
23:16:10 <lambdabot>  0.0
23:19:44 <varaindemian> How would we read (a -> b -> c) -> (b -> (a -> c))?     flip' :: (a -> b -> c) -> (b -> a -> c)  
23:19:47 <varaindemian>     flip' f = g  
23:19:49 <varaindemian>         where g x y = f y x  
23:20:57 <mauke[o}> what exactly are you asking?
23:21:15 <varaindemian> mauke[o}: How would we read (a -> b -> c) -> (b -> (a -> c))? 
23:21:51 <mauke[o}> "I take a function from a and b to c and return a function from b and a to c"
23:22:16 <mauke[o}> where "a function from a and b to c" actually is "a function from a to (a function from b to c)"
23:22:37 <mauke[o}> that is, fully parenthesized it's (a -> (b -> c)) -> (b -> (a -> c))
23:23:36 <varaindemian> I see
23:23:39 <kadoban> varaindemian: By the way, that's actually the same as: (a -> b -> c) -> b -> a -> c (but you can't remove the last parens without changing the meaning)
23:24:38 <varaindemian> why don't we remove all parens?
23:24:58 * hackagebot foscam-directory 0.0.2 - Foscam File format  https://hackage.haskell.org/package/foscam-directory-0.0.2 (TonyMorris)
23:25:33 <mauke[o}> because that changes the meaning
23:25:34 <kadoban> Because:   a -> b > c -> b -> a -> c means something different. In particular, its first argument is no longer a function, necessarily. It means something totally distinct.
23:26:16 <varaindemian> Does it mean there are 5 arguments?
23:26:27 <mauke[o}> yeah, basically
23:26:29 <kadoban> Yes
23:26:53 <mauke[o}> and the only sensible function of that type is \_ _ x _ _ -> x
23:27:03 <mauke[o}> because where else are you going to get a c to return?
23:38:02 <jle`> deep
23:54:42 <akfp2> using stack, how can I patch a specific package, say servant-client?  I want to add some debug message.
23:57:04 <pharaun> akfp2: fetch it locally
23:57:09 <pharaun> into a different dir
23:57:17 <pharaun> then dep it via packages: in the stack.yaml
