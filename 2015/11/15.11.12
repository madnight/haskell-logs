00:00:12 <aramiscd> @hoogle elem
00:00:14 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
00:00:14 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
00:00:14 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
00:01:11 <aramiscd> these commands seem to be publicly visible.
00:01:18 <aramiscd> isnt this annoying?
00:01:49 <kadoban> aramiscd: You can PM lambdabot, which is usually more polite unless you're actually demonstrating or asking about something.
00:02:00 <aramiscd> i see. thanks.
00:02:37 <liste> > 3 ＋3
00:02:39 <lambdabot>  7
00:03:06 <aramiscd> :-)
00:05:15 <theme2> > 3 + 3
00:05:16 <lambdabot>  6
00:05:20 <theme2> > 3  + 3
00:05:22 <lambdabot>  6
00:05:29 <theme2> liste, wtf did you do?
00:08:08 <liste> theme2 magic.
00:08:52 <kadoban> Heh, it's not + it's ＋ . Ohhhhh unicode.
00:09:06 <jle`> unicode, and also magic
00:09:15 <kadoban> Mostly magic.
00:11:07 <theme2> > 3 ＋ 3
00:11:08 <lambdabot>  Not in scope: ‘＋’
00:11:15 <theme2> > 3 ＋3
00:11:16 <lambdabot>  Not in scope: ‘＋’
00:11:22 <theme2> liste, how?????
00:12:14 <kadoban> theme2: You can use @let to define things in private, and they're persistent until someone does @undef. Also unicode is psycho.
00:12:42 <theme2> O_o
00:12:57 <aramiscd> @let + *
00:12:58 <lambdabot>  Parse failed: Parse error: +
00:13:05 <aramiscd> @let (+) (*)
00:13:05 <lambdabot>  Parse failed: TemplateHaskell is not enabled
00:13:22 <jle`> for normal function definitions it's the same thing you'd do in ghci
00:13:32 <jle`> @let foo x y = x + y * 2
00:13:34 <lambdabot>  Defined.
00:13:35 <jle`> > foo 3 9
00:13:38 <lambdabot>  21
00:14:33 <jle`> @let x ＋y = x + y + 1
00:14:34 <lambdabot>  Defined.
00:16:34 <theme2> > 3 ＋ 3
00:16:35 <lambdabot>  5
00:16:37 <theme2> :P
00:16:46 <roelof> Is this a good solution : http://lpaste.net/145091
00:16:52 <FireFly> Is that a full-width +?
00:16:58 <liste> FireFly yep
00:17:02 <liste> at least the one I used
00:17:23 <theme2> > 3 ＋ 3
00:17:25 <lambdabot>  7
00:17:45 * theme2 is doing some stupid stuff with lambdabot
00:18:01 <FireFly> Mmm, plenty of fun near-identical glyphs in Unicode
00:18:07 <liste> roelof that looks nice
00:18:19 * theme2 actually copy-pasted those 2 commands
00:18:56 <FireFly> let (/) = (+) in [2 / 3, 2 / 3]
00:18:59 <FireFly> > let (/) = (+) in [2 / 3, 2 / 3]
00:19:00 <lambdabot>  [5,5]
00:19:06 <FireFly> oops
00:19:15 <FireFly> darn, should've been ⧸
00:20:18 <roelof> oke, so the way I made the database is a good one ? I most in doubt with that 
00:21:01 <liste> I'd make Person and Book newtypes though
00:21:08 <liste> so it's harder to mix them up
00:21:26 <liste> maybe datas so they can be easily expanded later
00:22:00 <roelof> liste:  oke newtypes were not explained in the book 
00:23:45 <liste> roelof newtypes are like datas with only a single constructor and single value, and different semantics when it comes to bottoms
00:23:56 <liste> you can use data if you want
00:24:34 <liste> single constructor *with* single parameter, I mean
00:24:45 <liste> @let newtype Person = Person String
00:24:46 <lambdabot>  Defined.
00:25:01 <liste> @let newtype Person = Person String | NotPerson
00:25:01 <lambdabot>  Parse failed: newtype declaration must have exactly one constructor.
00:25:12 <liste> @let newtype Person = Person String Int
00:25:13 <lambdabot>  Parse failed: newtype declaration constructor must have exactly one parameter.
00:25:26 <roelof> oke, then also a chapter ready, Im almost half way the Craft book :) 
00:29:19 <james9909> ls
00:30:28 <roelof> liste:  I think the problem is here :  @let newtype Person = Person String . Person has one Structor nl. String 
00:32:18 <liste> roelof that defines one (nullary) type constructor, Person, and one unary value constructor, Person.
00:33:57 <liste> I just demonstrated that the other declarations are illegal
00:34:45 <liste> (btw which is the better name, value or data constructor?)
00:35:32 <roelof> oke, another question: Is this right ? returnLoan dBase pers bk = [ Loan person book  | Loan person book  <- dBase , Loan person book /= pers && Loan person book /= bk ] 
00:35:58 * hackagebot ciphersaber2 0.1.1.0 - Implementation of CipherSaber2 RC4 cryptography.  https://hackage.haskell.org/package/ciphersaber2-0.1.1.0 (BartonMassey)
00:36:35 <liste> roelof that dosn't typecheck
00:36:50 <liste> you mean person /= pers && book /= bk ?
00:36:57 <roelof> I have seen it. I try to solve it 
00:37:53 <roelof> Thanks, everythings compiles now 
00:38:24 <roelof> sometimes it is difficult to keep track what must be placed where 
01:02:19 <joco42> is there some tool that can tell what types are instances of given class ? besides grep searching ?
01:02:29 <joco42> ghc-mod or something?
01:02:30 <Lokathor> :info ?
01:02:54 <joco42> Lokathor:  i try that...
01:03:20 <lpaste_> Lokathor pasted “No title” at http://lpaste.net/145101
01:03:44 <joco42> Lokathor:  that looks nice
01:06:40 <joco42> it seems that for :info only the modules that are loaded into ghci are searched...
01:06:51 <joco42> is there a way to load all modules ?
01:06:56 <joco42> in cabal repl?
01:07:00 <Lokathor> ah, yes, that is a limitation
01:07:06 <Lokathor> no way to just load every module that I know of
01:07:12 <joco42> ok
01:07:13 <joco42> thanks
01:07:23 <joco42> good to know
01:54:12 <tim_> Just to say that Haskell is wonderful :)
02:03:46 <concept3d> Hello, what is the advantage of having a function declaration inside a record syntax.
02:04:39 <concept3d> for instance I often see the pattern         data Foo =  Foo { run :: Int -> IO Int }
02:05:02 <concept3d> what is the advantage of using this style
02:05:31 <quicksilver> it just gets you 'run' for free
02:05:39 <NathanielHiggers> hello
02:05:51 <quicksilver> it is one line shorter than data Foo = Foo (Int -> IO Int); run (Foo f) = f
02:06:05 <NathanielHiggers> my name's nathaniel but you can call me nate
02:06:08 <concept3d> ok I see
02:06:17 <quicksilver> two lines shorter if you add the type sig for run :)
02:06:37 <NathanielHiggers> it ain't about the line count it's about the thought count
02:06:39 <quicksilver> they're normally newtypes.
02:06:48 <concept3d> I was reading RWH bloom filter..
02:06:50 <concept3d> data MutBloom s a = MB {       mutHash :: (a -> [Word32])     , mutArray :: STUArray s Word32 Bool     }
02:07:48 <quicksilver> perhaps you're just asking "why put functions in datatypes at all?"
02:07:54 <quicksilver> the answer is because it's really useful :)
02:08:00 <quicksilver> not sure if I have a more abstract answer right now
02:08:25 <jg_> is there a good practice for importing stuff in haskell? I'm often getting name clashes between Prelude and other modules
02:09:12 <jg_> each module into a separate qualified name maybe?
02:09:16 <quicksilver> those things which clash with the Prelude are generally expected to be imported qualified
02:09:23 <quicksilver> other things generally aren't :)
02:09:29 <jg_> right
02:09:47 <quicksilver> I import qualified Map, Set, Text, ByteString
02:09:51 <quicksilver> Seq
02:09:57 <quicksilver> most other things I import unqualified
02:11:29 <jg_> also, i was recently stumped by a Prelude.head empty list exception. What's with backtraces/debugging in haskell?
02:11:38 <jg_> is that a thing?
02:14:39 <agentsmith16384> join #Fsharp
02:14:43 <agentsmith16384> join #Fsharp/
02:14:55 <agentsmith16384> sorry
02:26:01 * hackagebot relational-query-HDBC 0.3.0.0 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.3.0.0 (KeiHibino)
02:39:44 <betaceti> how do you map a function pair-wise over a pair (,) like (2,3) + (4,5) = (2+4,3+5) ?
02:40:49 <phadej> betaceti: there aren't very concise way.
02:40:59 <opqdonut> the both lens
02:41:13 <phadej> that, true.
02:41:27 <opqdonut> if you're lensy
02:41:40 <quicksilver> > let pair f (a,b) (c,d) = (f a c,f b d) in pair (+) (2,3) (4,5)
02:41:41 <lambdabot>  (6,8)
02:41:42 <FireFly> There's also an Arrow thing for that
02:41:46 <FireFly> I believe
02:41:49 <quicksilver> is moderately concise
02:41:50 <betaceti> aw, i was hoping there was some concise way, with (,) being an instance of some fancy class
02:41:53 <opqdonut> in the standard library, (***) is ok
02:42:09 <opqdonut> > (+1) (***) (+1) $ (2,5)
02:42:11 <lambdabot>      Couldn't match expected type ‘(b, c)’
02:42:11 <lambdabot>                  with actual type ‘Integer -> Integer’
02:42:11 <lambdabot>      In the second argument of ‘+ 1’, namely ‘(+ 1)’
02:42:16 <quicksilver> (***) doesnt do binary functions does it?
02:42:22 <FireFly> @ty (***)
02:42:23 <opqdonut> oh right
02:42:23 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
02:42:28 <opqdonut> didn't read it carefully enough
02:42:42 <opqdonut> the question, that is
02:43:51 <quicksilver> the `both` lens lets you do the same thing to both components, which isn't particularly what you have here
02:44:07 <quicksilver> this is more like applicative 
02:44:26 <opqdonut> yeah
02:44:46 <quicksilver> I don't think lens has a thing which generalises applicative instances
02:44:53 <opqdonut> Biapplicative?
02:44:56 <opqdonut> https://hackage.haskell.org/package/bifunctors-5.1/docs/Data-Biapplicative.html
02:45:12 <quicksilver> no this isn't biapplicative
02:45:16 <quicksilver> it's normal applicative
02:45:35 <quicksilver> it's the natural applicative instance for newtype Pair a = Pair (a,a)
02:45:39 <FireFly> My J-y approach would be to uncurry to get something akin to a matrix (as nested tuples) and then fold the binary operator along columns.. but that's probably not applicable in Haskell
02:45:53 <quicksilver> but you can imagine a lens-like trick to avoid the newtype
02:46:02 <quicksilver> by making the application a value-level thing
02:46:11 <quicksilver> however I don't think such a thing exists
02:46:14 <opqdonut> I meant "bipure ((+),(+)) <<*>> (2,3) <<*>> (4,5)"
02:46:19 <opqdonut> but that's pretty verbose, of course
02:46:33 <opqdonut> errhm
02:46:37 <quicksilver> liftA2 (+) (Pair 2 3) (Pair 4 5) seems nicer
02:46:46 <opqdonut> "bipure (+) (+)" of course
02:46:47 <opqdonut> yeah
02:47:02 <phadej> > join bimap (+) (1, 2) <<*>> (2, 3)
02:47:04 <lambdabot>  Not in scope: ‘<<*>>’
02:47:44 <phadej> or > join bipure (+) <<*>> (1, 2) <<*>> (2, 3)
02:47:53 <phadej> but I'd rather use Pair :)
02:47:56 <phadej> a bit too golfy
02:48:37 <quicksilver> > liftA2 (+) (ZipList [2,3]) (ZipList [4,5])
02:48:39 <lambdabot>  ZipList {getZipList = [6,8]}
02:49:07 <quicksilver> `both` works perfectly well as a Traversal
02:49:17 <quicksilver> but that's not quite enough I don't think. I thought it was for a moment.
02:49:43 <quicksilver> actually it kind-of is
02:49:45 <FireFly> well if you use ZipList [2,3] then you might as well  zipWith (+) [2,3] [4,5]  no?
02:49:59 <quicksilver> you can 'zipWith' any Traversal to any Fold, in principle
02:50:39 <quicksilver> but it feels a little inelegant
02:55:35 <arw>  /win 74
02:56:06 <arw> ah, I'm sorry for that accident.
02:58:26 <betaceti> quicksilver: does liftA2 need that newtype to work?
02:58:31 <quicksilver> yes
02:59:04 <quicksilver> > liftA2 (+) (1,2) (3,4)
02:59:06 <lambdabot>      No instance for (Show t0)
02:59:06 <lambdabot>        arising from a use of ‘show_M19192852753613222267063’
02:59:06 <lambdabot>      The type variable ‘t0’ is ambiguous
02:59:21 <quicksilver> :t liftA2 (+) (1::Int,2::Int) (3,4)
02:59:22 <lambdabot>     No instance for (Monoid Int) arising from a use of ‘liftA2’
02:59:23 <lambdabot>     In the expression: liftA2 (+) (1 :: Int, 2 :: Int) (3, 4)
02:59:41 <quicksilver> the liftA2 for (,) applies the function to the R-component and requires a Monoid for the L-component
03:11:33 * hackagebot zipkin 0.1.0.0 - Zipkin-style request tracing monad  https://hackage.haskell.org/package/zipkin-0.1.0.0 (srijs)
04:20:13 <ozgura> oh, I notice my code is broken with cereal-0.5.0.0
04:20:28 <ozgura> "No instance nor default method for class operation Data.Serialize.get"
04:20:36 <ozgura> does anyone know if they were removed?
04:21:05 <ozgura> I see this in the source code: https://github.com/GaloisInc/cereal/blob/master/src/Data/Serialize.hs#L98
04:21:54 <merijn> Does your datatype derive Generic?
04:22:00 <ozgura> yes
04:22:14 <merijn> mmm, for some reason cereal installed without generics
04:22:21 <ozgura> it used to work with 0.4.1.1
04:22:31 <ozgura> that's weird
04:23:28 <merijn> Not quite sure where the GENERICS define is supposed to come from
04:23:57 <ozgura> yes, I am trying to find that too
04:24:05 <ozgura> not in the cbaal file
04:24:07 <ozgura> cabal*
04:24:36 <ozgura> I think I found it
04:24:46 <ozgura> how does this work for anyone?
04:25:02 <ozgura> look at the diff between 0.4.1.1 and 0.5.0.0: http://hdiff.luite.com/cgit/cereal/commit
04:25:05 <ozgura> search for GENERICS
04:25:30 <merijn> That seems like a mistake...
04:25:40 <merijn> Or they forgot to remove the IFDEFs :p
04:26:01 <ozgura> pffff
04:26:05 <ozgura> creating an issue
04:27:24 * hackagebot clash-lib 0.6.4 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.4 (ChristiaanBaaij)
04:27:26 * hackagebot clash-vhdl 0.6.3 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.6.3 (ChristiaanBaaij)
04:27:28 * hackagebot clash-ghc 0.6.4 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.4 (ChristiaanBaaij)
04:37:24 * hackagebot syntactic 3.0 - Generic representation and manipulation of abstract syntax  https://hackage.haskell.org/package/syntactic-3.0 (EmilAxelsson)
04:43:27 <schoppenhauer> hi. how can I read a file chunkwise in haskell?
04:43:40 <schoppenhauer> (like I would in for example C with read(...)) ?
04:44:00 <merijn> schoppenhauer: Strict ByteString has fixed length reads similar to C
04:44:41 <merijn> schoppenhauer: See hGet and hGetSome https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html#g:26
04:45:22 <schoppenhauer> merijn: thanks.
04:45:32 <merijn> schoppenhauer: This works well with libraries like pipes/conduits if you plan to do streaming processing
04:45:44 <merijn> Since those can abstract over the repeated reads
04:46:26 <schoppenhauer> merijn: actually, I have to give a talk about iteratees, and I want an example for more low-level file access first.
04:46:44 <merijn> schoppenhauer: ah :)
04:58:33 <roelof> hello, how can I take care that a float or a double is shown with 2 numbers after the . 
04:59:48 <merijn> roelof: This question makes me suspicious. What does the float/double represent?
05:00:47 <merijn> Because I'm about 80% certain the answer to this question will be "You shouldn't be using floats for that"
05:00:57 <roelof> It represent a amount which has to be paid. it is stored as a integer 
05:01:04 <liste> roelof then, divmod
05:01:08 <liste> or divMod even
05:01:16 <liste> @type divMod
05:01:18 <lambdabot> Integral a => a -> a -> (a, a)
05:01:32 <liste> > 1500 `divMod` 100
05:01:33 <merijn> roelof: I'd recommend using Fixed from Data.Fixed, that gives you numbers with a fixed precision after the comma
05:01:35 <lambdabot>  (15,0)
05:01:45 <roelof> oke, but then you can get answers like 1.1 where I want it to be 1.10 
05:02:19 <merijn> > 1.23 :: Centi
05:02:20 <lambdabot>  1.23
05:02:26 <merijn> > 1.23567 :: Centi
05:02:27 <lambdabot>  1.23
05:02:45 <roelof> > 1.1 :: Centi
05:02:58 <lambdabot>  mueval: ExitFailure 1
05:03:05 <merijn> wait, wut?
05:03:09 <merijn> > 1.1 :: Centi
05:03:11 <lambdabot>  1.10
05:03:14 <merijn> There we go
05:03:34 <roelof> that is what im looking for 
05:03:35 <merijn> "type Centi = Data.Fixed E2
05:03:50 <merijn> There's others in Data.Fixed for other precisions
05:05:39 <roelof> oke so I can do convert :: Integer -> Data.Fixed E2 ?? 
05:06:03 <merijn> :t fromIntegral
05:06:05 <lambdabot> (Integral a, Num b) => a -> b
05:07:50 <roelof> merijn:  now I miss what you mean to say 
05:07:53 * hackagebot open-typerep 0.3.2 - Open type representations and dynamic types  https://hackage.haskell.org/package/open-typerep-0.3.2 (EmilAxelsson)
05:08:13 <merijn> roelof: Fixed is an instance of Num
05:08:23 <merijn> fromIntegral can convert any Integral into a Num
05:08:34 <merijn> :t fromIntegral :: Int -> Centi
05:08:35 <lambdabot> Int -> Centi
05:09:06 <julianleviston> If I have a Map ByteString [ByteString] and I want to turn it into a Map String String, must I use foldr? I can’t use fmap, can I?
05:09:28 <roelof> oke, so the definition becomes  convert :: Int -> Centi  ? 
05:09:41 <merijn> julianleviston: Might be simpler to "fromList . map conversion . toList"?
05:10:01 <julianleviston> merijn: ah ok. I thought of that but dismissed it because I thought it would be terribly inefficient.
05:10:15 <julianleviston> merijn: if it’s good, though, it’s good :)
05:10:16 <merijn> julianleviston: Not more so than foldr, imo
05:10:22 <julianleviston> merijn: ok cool
05:10:27 <julianleviston> merijn: thanks!
05:10:30 <merijn> julianleviston: Changing the type of the key means rebuilding anyway
05:10:37 <julianleviston> yet
05:10:39 <julianleviston> yep*
05:10:43 <merijn> julianleviston: Since the ord instance of String and ByteString might differ
05:11:01 <roelof> merijn:  that I understand. I wonder what the types now have to be on my function ? 
05:11:03 <merijn> And both of those functions should be well behaved producers/consumers of lists
05:11:10 <julianleviston> I didn’t realise Map s were ordered
05:11:20 <merijn> roelof: What was the initial type?
05:11:29 <roelof> Integer 
05:11:37 <merijn> julianleviston: How'd you think Map did lookups? :p
05:11:52 <julianleviston> merijn: I didn’t think.
05:12:21 <roelof> and the output type is Centi 
05:12:34 <schoppenhauer> in what package is "ifM" defined?
05:12:39 <merijn> roelof: Right, so just call "fromIntegral" on your integer?
05:12:51 <schoppenhauer> I thought control.monad, but seems not to
05:14:21 <merijn> schoppenhauer: I've never seen ifM?
05:14:28 <roelof> merijn:  I think so 
05:14:34 <schoppenhauer> http://stackoverflow.com/questions/29717327/monadic-if-how-it-works
05:15:15 <merijn> schoppenhauer: Well, the definition is right there, not sure if there's a library for it
05:15:48 <merijn> oh, "extras" seems to have it
05:16:33 <roelof> > 1 :: Centi
05:16:37 <lambdabot>  mueval-core: Time limit exceeded
05:17:15 * roelof thinks that the system do not like him 
05:17:47 <concept3d> I just saw this declaration, infoM, warningM :: MonadIO m => String -> m () 
05:17:49 <julianleviston> Haksell is so flipping cool :)
05:18:05 <julianleviston> merijn: thanks, that worked a treat :)
05:18:06 <concept3d> and I am not sure how can we declare two functions?
05:18:16 <concept3d> in the same declration
05:18:23 <liste> concept3d just like that
05:18:28 <julianleviston> concept3d: you don’t have to - that just says they’re both the same type
05:18:40 <roelof> > 1 :: Centi
05:18:42 <lambdabot>  1.00
05:19:07 <concept3d> infoM, warningM :: MonadIO m => String -> m () [infoM, warningM] = map ($ "Events.Reading") [L.infoM, L.warningM]
05:19:19 <concept3d> what is more confusing, when defining the function, the guy used a list
05:19:47 <concept3d> I understand what map ($ "string")  does here
05:20:11 <concept3d> but it wasn't clear how we have a list on the left side
05:20:30 <merijn> concept3d: You can't define multiple functions in one declaration
05:20:41 <merijn> concept3d: But you CAN define multiple type annotations at the same time
05:20:49 <concept3d> infoM, warningM :: MonadIO m => String -> m ()
05:20:50 <concept3d> [infoM, warningM] = map ($ "Events.Reading") [L.infoM, L.warningM]
05:21:26 <concept3d> merijn: can you explain how the second line have a list on the left side ?
05:22:10 <julianleviston> concept3d: isn’t it just a pattern match?
05:22:21 <merijn> Yeah, this is some disgusting stuff
05:22:29 <concept3d> that is what I thought
05:22:34 <concept3d> pattern matching
05:22:35 <merijn> It's defining a list without a type annotation
05:22:48 <merijn> And pattern matching on it to define two functions
05:22:53 * hackagebot hath 0.3.0 - Hath manipulates network blocks in CIDR notation.  https://hackage.haskell.org/package/hath-0.3.0 (MichaelOrlitzky)
05:25:43 <concept3d> https://www.haskell.org/hugs/pages/users_guide/type-annotations.html
05:25:47 <concept3d> ^
05:26:05 <concept3d> is this recommened anymore? seems dated to me
05:26:21 <merijn> concept3d: Anything using Hugs is dated :p
05:27:40 <frerich> ...but not necessarily bad! One of the best Haskell books I know uses Hugs, too :-) Some things are plain timeless.
05:28:04 <ent> which book is that?
05:28:07 <merijn> ghci is better in virtually every way
05:28:29 <frerich> ent: http://www.cs.nott.ac.uk/~pszgmh/book.html <-- this one
05:28:39 <frerich> I wish I would have started with that...
05:29:24 <ent> I wonder how that compares to the haskellbook.com book
05:29:47 <julianleviston> yeah I really liked that book.
05:30:19 <julianleviston> ent: they’re quite different.
05:30:48 <ent> how so?
05:30:51 <julianleviston> ent: the hutton one is really good for learning how to program functionally. The haskellbook one is good for learning Haskell.
05:31:25 <julianleviston> ent: the Hutton one has some really nice things in it about equational reasoning and functional thinking that are invaluable, IMO.
05:31:56 <ent> sounds interesting
05:32:08 <ent> I guess I'll have to check that one out too then :)
05:32:22 <julianleviston> :)
05:32:46 <julianleviston> ent: there are a few gotcha because it uses HUGS tho… things like the (n-1) pattern match which doesn’t exist anymore.
05:33:03 <frerich> I think the Hutton book is really nice because *all of it* is very good. With other things like RWH or LYAH (which are also very nice) I find some chapters to be much more useful than others. I.e. with RWH -- even though it's a bit dated by now -- I still kind of treat it like a catalogue of howtos. :-}
05:33:16 <jg_> i'm having problems using foldl, could someone point me in the right direction? http://lpaste.net/2898871610746339328
05:33:28 <frerich> Like, sometimes you buy a CD (does anybody still buy CDs?) when you only like a efw songs but you skip the rest.
05:33:29 <jg_> it compiles but the program doesn't seem to terminate...
05:33:37 <frerich> And then sometimes you have a CD which you can easily listen to start to finish :-)
05:33:56 <ent> I found it pretty frustrating that both RWH and LYAH have lots of examples that just don't run as they are any more
05:34:06 <jg_> naively chaining the filterTag function works fine though 
05:34:14 <julianleviston> probably one of my favourite things about hutton’s books are that he takes you through at least one or two WHOLE problems...
05:36:40 <roelof> frerich:  I use the Hutton book but sometimes very much maths 
05:36:59 <roelof> and sometimes the exercises I find vague 
05:37:14 <roelof> but the explanations are very good
05:37:15 <freinn> Hi! I've posted a question in codereview, is about improving the performance of my attoparsec parser, you can see it here: http://codereview.stackexchange.com/questions/110361/lazy-attoparsec-parser-for-log-files
05:37:56 <merijn> freinn: Oh, simple
05:37:57 <poucet> Are there standard ways of serializing data structures that have sharing inside
05:38:02 <merijn> freinn: use takeWhile over many
05:38:23 <freinn> merijn are you a wizard? too fast xD
05:38:39 <merijn> freinn: The problem with many is that it parses one character at a time
05:39:07 <merijn> freinn: takeWhile takes a "Char -> Bool" (or "Word8 -> Bool") and runs a tightloop over the input until it becomes False
05:39:50 <freinn> ok merijn, is there any alternative for manyTill, or other performance/implementation issue you can tell me?
05:40:53 <merijn> freinn: Basically rewriting as much as possible in terms of things like "takeWhile" and other fixed operations will be fastest. But it can make things like manyTill more complex
05:41:52 <julianleviston> > length $ lookup 3 [(3, "hello"), (5, "world")]
05:41:55 <lambdabot>  1
05:42:41 <tdammers> :t length
05:42:42 <lambdabot> Foldable t => t a -> Int
05:42:48 <tdammers> > length (Just ())
05:42:50 <lambdabot>  1
05:42:58 <julianleviston> tdammers: yeah, I understand it, it’s ok :)
05:43:11 <tdammers> had me baffled for a moment though :D
05:43:21 <julianleviston> hehe one of the arguments against FTP
05:43:25 <tdammers>  > length <$> lookup 3 [(3, "hello"), (5, "world")]
05:43:29 <julianleviston> apparently.
05:43:34 <tdammers> > length <$> lookup 3 [(3, "hello"), (5, "world")]
05:43:35 <lambdabot>  Just 5
05:43:53 <tdammers> not really a very strong one if you ask me
05:43:57 <julianleviston> tdammers: same.
05:44:26 <aweinstock> > lookup 3 [(3, "hello"), (5, "world)]
05:44:27 <julianleviston> https://www.reddit.com/r/haskell/comments/3ojekh/excuse_me_i_think_this_is_my_stop_haskell_platform/
05:44:27 <lambdabot>  <hint>:1:37:
05:44:27 <lambdabot>      lexical error in string/character literal at end of input
05:44:31 <aweinstock> > lookup 3 [(3, "hello"), (5, "world")]
05:44:33 <lambdabot>  Just "hello"
05:44:48 <aweinstock> > length . fromJust $ lookup 3 [(3, "hello"), (5, "world")]
05:44:50 <lambdabot>  5
05:44:53 <tdammers> oh, that one... blah.
05:45:13 <julianleviston> blah indeed
05:45:30 <pavonia> What does the new length denote, how many values of type 'a' occur in the value of type 't a'?
05:45:39 <merijn> pavonia: Yeah
05:45:48 <julianleviston> There’s really no problem if you’re explicit about what you’re doing, which we all should be anyway, really.
05:45:55 <ggole> Rather, how many instances of type a are folded over by the Foldable instance
05:46:01 <julianleviston> IMO prelude was a little too lax and unspecified previously… or something :)
05:46:06 <merijn> pavonia: I think it's supposed to be equivalent to "foldl (+1) 0"
05:46:10 <ggole> > length ('1', '1')
05:46:12 <lambdabot>  1
05:46:15 <julianleviston> > length Nothing
05:46:16 <lambdabot>  0
05:46:36 <ggole> There are two '1's, but only one is eaten by length
05:46:50 <merijn> ggole: The other is not 'a' in 't a'
05:47:10 <merijn> It's a separate (coincidentally similary valued) type variable
05:47:23 <julianleviston> foldable length is a little silly for some things…
05:47:24 <ggole> It's easy to write a type for which it is though.
05:47:34 <julianleviston> > length $ Just [1,2,3]
05:47:35 <lambdabot>  1
05:47:53 <tdammers> generalizing all the list functions *except* length to Foldable/Traversable is equally silly
05:47:55 <merijn> ggole: Not in a way that's lawful
05:50:18 <julianleviston> prelude is trying to do dual-purpose: pedagogy AND good defaults for non-newppl.
05:51:31 <pavonia> We should have GHC options --n00b and --l33t to choose between the old and new Prelude :p
05:52:36 <aweinstock> :t getSum . foldMap Sum
05:52:37 <lambdabot> (Num c, Foldable t) => t c -> c
05:52:44 <aweinstock> :t getSum . foldMap Sum . const 1
05:52:45 <lambdabot> (Num c, Num (t c), Foldable t) => b -> c
05:52:56 <aweinstock> :t getSum . foldMap (Sum . const 1)
05:52:57 <lambdabot> (Num c, Foldable t) => t b -> c
05:54:17 <Smace> Where can I learn about functional programming? Is it possible to use it for building an ERP? is it a bad idea?
05:54:23 <julianleviston> I reckon prelude should just be for experts. Make a new thing callend learn… the experts won’t feel comfortable using it anyway ;-)
05:55:19 <julianleviston> Smace: you can probably learn about FP in here pretty easily.
05:56:11 <julianleviston> Smace: but it’ll take you a while to get to grips with it, so while it’s handy to have a project to learn with, don’t expect to build any serious software for a while when you’re learning.
05:56:11 <Smace> I come from stateful imperative programming. And I am exploring the idea of stateless imperative programming. And I wonder if it makes sense to use for building an ERP.
05:56:27 <Smace> Ops
05:56:28 <Smace> Sorry
05:56:33 <julianleviston> Smace: stateless imperative isn’t functional.
05:56:36 <Smace> *Stateless Functional Programming
05:56:37 <julianleviston> Smace: is it?
05:56:41 <julianleviston> ah ok
05:56:45 <Smace> I typed wrong.
05:57:55 <julianleviston> Smace: this might help: http://stackoverflow.com/questions/1604790/what-is-haskell-actually-useful-for
05:58:54 <julianleviston> Smace: but, basically, you can program whatever you would like to in FP.
05:59:47 <julianleviston> Smace: it always makes me a bit curious when people talk about stateless programming… 
06:00:09 <julianleviston> Smace: I’m guessing you mean programming where you’re not mutating state as much…
06:00:16 <Smace> julianleviston, the idea is just having a flow and not having a central persistence (database).
06:00:22 <julianleviston> Smace: All programming uses state.
06:00:38 <Smace> julianleviston, I know, but what I meant is not having a central state repository.
06:00:40 <julianleviston> Smace: what does a database have to do with state in programming?
06:00:50 <julianleviston> Smace: I don’t really follow, sorry.
06:01:18 <julianleviston> Smace: mostly when people talk about “stateful imperative programming” I think they mean when there’s mutable state EVERYWHERE.
06:01:28 <Smace> julianleviston, yes.
06:01:36 <julianleviston> Smace: but they tend to go the other way in their minds… saying “oh, no state here”...
06:01:47 <Smace> many procedures altering the same data.
06:02:24 <julianleviston> Smace: yep.
06:02:35 <julianleviston> Smace: mutable state is a better term then.
06:03:44 <Smace> Right. mutable state, There is a lot I have to learn.
06:03:58 <julianleviston> Smace: you’re using it the way most people do. It’s fine.
06:04:37 <Smace> julianleviston, I've used to build ERP using Delphi. And now company is using Java. But what happens is, as the system grows complexity reaches a level that things starts to fail.
06:06:03 <julianleviston> Smace: FP isn’t some magic bullet for complexity. I mean, it can help enormously depending on how you structure things, but that’s a loaded statement.
06:06:10 <Smace> So I wonder if Functional programming could be helpful for solving the complexity problem. What I really wanted to happen is to have management and developers in sync in such way procedures would match. I see management think in 'flows' instead of 'data + commands + output'.
06:06:37 <Smace> I don't expect a magic pill. I just wanted to understand how it could solve things better, and what is the limit.
06:06:52 <julianleviston> Smace: the guy who designed MVC recently put out a “new” acronym … you heard of it?
06:06:59 <Smace> No
06:07:06 <julianleviston> it’s called DCI
06:07:11 <julianleviston> http://www.artima.com/articles/dci_vision.html
06:07:24 <julianleviston> but it’s basically advocating pulling your data out from its interfaces...
06:07:30 <julianleviston> interestingly, it’s very similar to FP 
06:07:59 <julianleviston> it advocates flows of data and making the functions that interact with them as separate from the model objects.
06:08:06 <Smace> I see.
06:08:19 <julianleviston> but FP is sort of the same thing, but with a lot less moving parts IMO
06:09:17 <julianleviston> because OOP & MVC don’t really cut it for things that aren’t GUI based apps… when you want to build large scale multi-segment applications, you need things to be a bit more flexible… and FP can afford that… in particular, Haskell makes things very nice from a reuse point of view.
06:09:26 <liste> Gonzales has an interesting point about FP complexity here: http://www.haskellforall.com/2014/04/scalable-program-architectures.html
06:10:16 <Smace> Thank you for links.
06:10:26 <julianleviston> liste:  yeah, that’s a really good link.
06:11:16 <julianleviston> but, OOP is a really good fit where you actually need your data bound tightly to your functions.
06:11:47 <julianleviston> Wish I could rememeber the stack overflow link where (can’t rememeber his name) was espousing the benefit of both… 
06:12:41 <julianleviston> oh here it is: http://stackoverflow.com/questions/2078978/functional-programming-vs-object-oriented-programming
06:12:44 <julianleviston> norman ramsey
06:12:56 <julianleviston> Object-oriented languages are good when you have a fixed set of operations on things, and as your code evolves, you primarily add new things. This can be accomplished by adding new classes which implement existing methods, and the existing classes are left alone.
06:13:21 <julianleviston> Yeah… the trouble is, it’s almost NEVER the case where we have a fixed set of operations on things :)
06:15:59 <saulzar_> You never have either - I don't think that really makes total sense, it seems a kind of stereotypical answer based around the difference between sum types and virtual functions..
06:18:01 <merijn> julianleviston: I've never run into a situation where I needed data bound tightly to functions, tbh
06:18:36 <julianleviston> yeah
06:18:54 <julianleviston> He makes the point that this is “the expression problem”.
06:19:07 <merijn> The expression problem has problems in OO too
06:19:21 <julianleviston> The major problem with OO is that the programming industry thought it was a magic bullet, IMO
06:19:42 <julianleviston> merijn: yea, I think “the expression problem” is in all programming…
06:19:48 <julianleviston> “so far” ;-)
06:20:00 <julianleviston> though isn’t there a paper about how haskell solves the expression problem or something?
06:20:21 <julianleviston> http://paulkoerbitz.de/posts/Solving-the-Expression-Problem-in-Haskell-and-Java.html
06:20:39 <merijn> julianleviston: Plenty
06:20:45 <julianleviston> mm
06:22:55 * hackagebot airship 0.4.1.0 - A Webmachine-inspired HTTP library  https://hackage.haskell.org/package/airship-0.4.1.0 (reiddraper)
06:22:57 * hackagebot cayley-dickson 0.1.1.0 - Complex numbers, quaternions, octonions, sedenions, etc.  https://hackage.haskell.org/package/cayley-dickson-0.1.1.0 (lmj)
06:27:58 <Xandaros> The equational-reasoning package defines two kinds of equality. Normal Refl-equality using (:~:) and (:=:) (synonyms) and Leibniz-equality. Just what is this Leibniz thingy?
06:29:23 <scshunt> Xandaros: Leibniz equality considers x = y if P(x) = P(y) for all properties P
06:29:40 <merijn> It's the difference between intensional/extensional equality
06:30:10 <merijn> Xandaros: Consider two different sort functions, one using mergesort, one using quicksort. Are these equal?
06:30:22 <merijn> Xandaros: Clearly they're not definitionally "the same"
06:30:36 <merijn> On the other hand, we can't really observe their behaviour every differing...
06:30:40 <Xandaros> Hmm, I see. They have different defintions, yet are functionally the same
06:30:56 <Xandaros> How would you prove that, though?
06:31:18 <merijn> This is extensional equality (i.e. things are equal if they behave identically in all situations)
06:31:44 <merijn> Xandaros: There's multiple PhD thesis on different types of equality and how to prove them in the dependent types world :p
06:32:33 <Xandaros> merijn: Ah, well. I shall ignore Leibniz for now. Just trying to understand how this package works^^
06:32:53 <Xandaros> I had always defined my own equality so far
06:33:47 <Xandaros> I understand the core concepts, but these libraries are on a way different level. Especially singletons :D
06:34:07 <merijn> Xandaros: tbh, it might be easier to learn a dependently typed language and then come back to haskell
06:34:33 <merijn> Xandaros: So you can properly distinguish "what you're trying to do" from "the ugly hacks/hoop jumping needed to do it in haskell"
06:34:46 <Xandaros> I had messed around with Idris a little. Didn't do much with it, though
06:35:24 <julianleviston> are dependently typed languages awesomness?
06:36:26 <merijn> julianleviston: Yes, no, maybe :p
06:36:31 <merijn> Depends on what you want
06:36:36 <Xandaros> So far, I haven't seen that many ugly hacks in haskell. Works mostly the same as in idris, though applying proofs is a bit dodgy (hence I'm looking at equational-reasoning. The proofs in type-natural look fairly neat)
06:36:37 <merijn> I don't think we have a practical one yet
06:36:46 <julianleviston> merijn: yeah, sorry, was a stupid question :)
06:36:56 <merijn> Xandaros: The biggest problem is reifying values from types
06:37:07 <Xandaros> julianleviston: If you want to play around with dependent types - yes, they are awesome. If you want to do something practical... maybe
06:37:08 <merijn> julianleviston: The underlying theory is pretty nice
06:37:26 <julianleviston> Xandaros: yeah, I thought that might be the case…
06:37:41 <merijn> julianleviston: Calculus of Constructions is a lot simpler than, say Haskell and the System F_ω it's based on
06:37:42 <julianleviston> from what I understand, Haskell is trying slowly to become a practical one, right?
06:37:58 <merijn> julianleviston: Won't happen any time soon
06:38:20 <merijn> julianleviston: That would require a major overhaul of the underlying theory
06:38:37 <Xandaros> What exactly do you mean by reifying values from types?
06:39:16 <merijn> Xandaros: Suppose I have "length :: Vector n a -> Int" how do I turn the type-level 'n' into a term-level Int?
06:39:41 <merijn> julianleviston: But moving to CoC means you can cut a lot of redundancy from your system
06:39:46 <Xandaros> Assuming n is of kind Nat, you can easily turn it into a Sing Nat, can't you?
06:40:04 <julianleviston> merijn: there are some problems with that though aren’t there? 
06:40:05 <merijn> Xandaros: That's still doable, but requires some hacky typeclasses/Singletons in haskell
06:40:16 <merijn> julianleviston: With what?
06:40:28 <julianleviston> merijn: moving to CoC from SystemF based things?
06:40:29 <Xandaros> merijn: True, but it's neatly abstracted away - out of sight, out of mind :P
06:40:37 <julianleviston> merijn: I’ve got no idea...
06:40:44 <merijn> julianleviston: Moving yes, if you straight up start from CoC it's really simple
06:40:58 <merijn> julianleviston: CoC has a much smaller number of primitive things than System F
06:41:06 <merijn> julianleviston: System F has terms, types, kinds, etc.
06:41:08 <julianleviston> merijn: why aren’t the CoC based languages practical then? lack of code?
06:41:22 <merijn> julianleviston: CoC only has like 5 primitives
06:41:48 <julianleviston> merijn: do CoC based languages still have inference?
06:42:31 <merijn> julianleviston: There's only 4 languages implemented based on it, two of which are theorem provers, one is no longer developed and only one is really trying to be a practical language
06:42:39 <merijn> julianleviston: Not full inference, but partial inference is possible
06:42:43 <julianleviston> merijn: coq, idris, …?
06:42:54 <merijn> Coq, Agda, Idris and Epigram
06:43:03 <julianleviston> which one is trying to be practical?
06:43:06 <merijn> Idris
06:43:10 <julianleviston> oh.
06:43:14 <julianleviston> it’s written in Haskell isn’t it?
06:43:16 <merijn> Well, probably more, as I said, CoC is pretty simple :p
06:43:23 <merijn> Tekmo's Morte is also based on CoC
06:43:29 <quicksilver> coq is extremely practical.
06:43:31 <merijn> julianleviston: Agda and Idris are both written in haskell
06:43:34 <quicksilver> it's not just a practical programming language.
06:43:40 <quicksilver> merijn: and epigram!
06:43:54 <merijn> quicksilver: I already mentioned Epigram
06:44:00 <merijn> But it's no longer being worked on, afaik
06:44:20 <julianleviston> So why isn’t using Idris for day to day programming viable? lack of libraries and code?
06:44:22 <merijn> pigworker had a "crisis of faith", not sure exactly what said crisis was and how it relates to HoTT
06:44:38 <merijn> julianleviston: It's only a few years old, not well tested, little libraries, etc.
06:44:49 <julianleviston> ah ok
06:45:26 <merijn> julianleviston: Just implement your own CoC language! ;)
06:45:35 <julianleviston> huh?
06:45:52 <merijn> There's actually a few tutorials on how to implement CoC around
06:46:04 <merijn> It's pretty easy and as good a way to learn dependent types as any :p
06:47:45 <quicksilver> merijn: sorry that "and epigram!" was in response to saying that agda and idris were written in haskell.
06:47:56 * hackagebot manifolds 0.1.5.2 - Coordinate-free hypersurfaces  https://hackage.haskell.org/package/manifolds-0.1.5.2 (leftaroundabout)
06:48:28 <merijn> ah :)
06:50:00 <quicksilver> I really liked epigram's program-constructing assistant tho
06:50:08 <quicksilver> at least, I liked the ideas
06:50:48 <merijn> quicksilver: Did you read Conor's thesis?
06:50:56 <merijn> I thought it was really interesting
06:51:07 <merijn> And fairly understandable for his writing ;p
06:52:56 * hackagebot dynamic-plot 0.1.1.1 - Interactive diagram windows  https://hackage.haskell.org/package/dynamic-plot-0.1.1.1 (leftaroundabout)
06:53:33 <quicksilver> no, I didn't
06:53:38 <quicksilver> I saw him give a couple of presentations on epigram
07:17:56 <petercommand> Is there a compiler warning for "No match in record selector XXX"?
07:18:35 <petercommand> I thought I would get something like the non-exhaustive pattern warning thing
07:19:13 <julianleviston> petercommand: what’s the context? if you turn on ALL warnings it might help...
07:19:24 <quchen> petercommand: fwarn-incomplete-record-updates
07:19:37 <quchen> (Not part of -Wall)
07:19:45 <julianleviston> quchen: thanks.
07:19:47 <petercommand> quchen: thx!
07:20:00 <petercommand> this should be part of -Wall imo
07:20:03 <quchen> See here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/options-sanity.html
07:20:19 <quchen> I think "all warnings" would be a good setting for -Wall.
07:21:28 <MarcelineVQ> https://www.youtube.com/watch?v=VwClFPzo9Vs omg
07:22:03 <julianleviston> MarcelineVQ: ummmm?
07:22:17 <MarcelineVQ> yes wrong channel, I'm okay with that though because it's still fun
07:22:41 <julianleviston> MarcelineVQ: ok. Just for other people, it’s animals getting scared.
07:29:18 <eikke> is there anything available to parallellize ST actions?
07:31:39 <hpc> eikke: there's pure libraries for parallelization
07:32:04 <hpc> even just par/pseq would work, and it wouldn't matter that you're using ST actions
07:32:32 <hpc> unless you mean something like forkST :: ST s () -> ST s ThreadId, which is concurrency and doesn't exist
07:32:50 <eikke> :t par
07:32:51 <lambdabot>     Not in scope: ‘par’
07:32:51 <lambdabot>     Perhaps you meant one of these:
07:32:51 <lambdabot>       ‘Sym.var’ (imported from Data.Number.Symbolic),
07:33:00 <eikke> grmbl
07:33:25 <eikke> anyway, hpc: afaik 'par' wont be compatible with monadic actions?
07:34:24 <Cale> eikke: par works with any expression evaluation
07:35:29 <eikke> even then
07:36:11 <eikke> say I have a source vector, and a (mutable) target vector, now I want to map over every element of the source and do something to the same-index element in the target
07:36:34 <eikke> my target vector should be allocated inside an ST action, and the whole thing should run with runST or similar and freeze the target in the end
07:36:47 <eikke> I fail to see how I could do divide-and-conquer with 'par' and 'pseq'
07:37:15 <Cale> Yeah, you can't use pure parallelism there because it wouldn't be clear that the computations wouldn't interfere with each other
07:37:28 <eikke> I know they don't ;-)
07:38:10 <augur> anyone interested in batting around ideas about calculating/deriving (pure) function definitions from example behavior?
07:38:12 <eikke> in theory I could use repa, but then the problem is I need FFI to a C function (custom SIMD assembly), and combining that with repa seems complicated
07:38:18 <Cale> Probably the easiest thing is to use IO and concurrency
07:38:44 <eikke> Cale: and unsafePerformIO?
07:38:51 <Cale> eikke: If you must.
07:39:03 <Cale> eikke: But I'd be very careful about that
07:39:13 <Cale> It's hard to prove that you'll really get the same result every time
07:39:16 <eikke> hence myy worry  :)
07:47:58 * hackagebot syntactic 1.16.2 - Generic abstract syntax, and utilities for embedded languages  https://hackage.haskell.org/package/syntactic-1.16.2 (EmilAxelsson)
08:38:02 * hackagebot DRBG 0.5.5 - Deterministic random bit generator (aka RNG, PRNG) based  HMACs, Hashes, and Ciphers.  https://hackage.haskell.org/package/DRBG-0.5.5 (ThomasDuBuisson)
08:43:02 * hackagebot Lambdajudge 1.0.0.3 - A library to easily host Haskell based programming competitions  https://hackage.haskell.org/package/Lambdajudge-1.0.0.3 (ankitku)
08:43:28 <fosterite> @pl \f k a c -> f a (k c)
08:43:28 <lambdabot> flip . ((.) .)
08:44:19 <obadz> lol
08:44:45 <Xandaros> Please don't actually use that :D
08:45:23 <obadz> @pl \ a b c d e f g h -> a (b c) (d (e f g)) h
08:45:23 <lambdabot> flip flip ((.) . (.)) . ((flip . (((.) . (.) . (.) . (.)) .)) .) . (.)
08:45:25 <fosterite> currently I use a help f k a c = f a (k c)
08:45:31 <fosterite> on another funciton
08:45:36 <fosterite> but it's ugly
08:45:41 <quicksilver> @pl -> d e h o l r w -> h e l l o . w o r l d
08:45:41 <lambdabot> (line 1, column 1):
08:45:41 <lambdabot> unexpected "-"
08:45:41 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:45:46 <quicksilver> @pl -> \d e h o l r w -> h e l l o . w o r l d
08:45:46 <lambdabot> (line 1, column 1):
08:45:46 <lambdabot> unexpected "-"
08:45:46 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:45:52 <obadz> it's like morse code for programming
08:45:54 <quicksilver> @pl \d e h o l r w -> h e l l o . w o r l d
08:45:55 <lambdabot> flip (flip . ((ap . (liftM2 ((.) . (.) . (.)) .) . flip) .) . flip flip id . (ap .) . flip id) . flip (flip . ((flip . (flip .)) .) . flip . (flip .) . flip . flip id)
08:46:03 <quicksilver> haskell hello world.
08:46:06 <quicksilver> it's beautiful.
08:46:11 <fosterite> so terse!
08:47:04 <nani___> I'm saving this, and when in a couple years I finish reading an haskell tutorial I will understand it and maybe laugh
08:47:22 <nani___> in the meantime "wut"
08:47:45 <fosterite> @pl \k a c -> f a (k c)
08:47:45 <lambdabot> flip ((.) . f)
08:47:58 <Xandaros> nani___: Don't misunderstand. Nobody can make sense of that without trying to decipher it for at least a few minutes first
08:49:56 <fosterite> got it down to go'' k a c r = f a (k c) `op` r
08:53:46 <fosterite> @pl \k a -> op . f a . k
08:53:47 <lambdabot> ((op .) .) . flip ((.) . f)
08:53:53 <fosterite> oh no, it's getting worse
08:56:10 <Xandaros> Stop trying to play haskell golf and just do what's right - using pointful style :P
08:56:35 <Xandaros> I like to use pointless as much as I can, but sometimes it just doesn't improve readability
08:56:54 <fosterite> I mostly just wanted to get rid of the hlint duplication warning
08:56:56 <fosterite> it doesn't warn anymore
08:57:21 <fosterite> I use this in two folds, over verts and edges (and faces when I write it)
09:02:27 <kazagistar> I used to have a variable problem. Then I used @pl. Now I have a (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .)) problem
09:03:02 <quicksilver> :)
09:04:39 <Xandaros> @unpl (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
09:04:39 <lambdabot> (\ as f -> (snd >>= \ db -> return ((\ cf k d -> (snd >>= \ bf -> return ((\ y -> (\ ao cx af ag aj am -> ((,)) (ao cx aj) (af ag am)) as (fst cf) as k (fst y)) d bf)) d) f db)) f)
09:04:49 <Xandaros> not much better :P
09:05:08 <kazagistar> @Xandaros: try the type, it actually is a really simple function
09:05:08 <lambdabot> Unknown command, try @list
09:05:14 <Zekka|Sigfig> Xandaros: Looks pretty straightforward to me
09:05:18 <Xandaros> :t (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
09:05:20 <lambdabot> (a -> a1 -> a2) -> (a, a) -> (a1, a1) -> (a2, a2)
09:05:44 <Xandaros> I see
09:05:58 <kazagistar> @pl f g (a, b) (c, d) = (g a c, g b d)
09:05:59 <lambdabot> f = (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
09:12:54 <quicksilver> > ((flip ((.) . (.) . (.) . (.) . (:)) .) . flip ((.) . (.) . (.) . (.) . (:)) . ap ((.) . (.) . (.) . (:)) . ap ((.) . (.) . (.) . (:)) . ((ap ((.) . (.) . (:)) . ((flip (:) .) .) . flip ((.) . (:)) . flip (:)) .) . flip (:) . return) 'd' 'e' 'h' 'l' 'o' 'r' 'w'
09:13:05 <lambdabot>  mueval: ExitFailure 1
09:13:08 <quicksilver> :(
09:13:11 <quicksilver> > ((flip ((.) . (.) . (.) . (.) . (:)) .) . flip ((.) . (.) . (.) . (.) . (:)) . ap ((.) . (.) . (.) . (:)) . ap ((.) . (.) . (.) . (:)) . ((ap ((.) . (.) . (:)) . ((flip (:) .) .) . flip ((.) . (:)) . flip (:)) .) . flip (:) . return) 'd' 'e' 'h' 'l' 'o' 'r' 'w'
09:13:13 <lambdabot>  "helloworld"
09:13:50 <dmj> quicksilver: +1
09:13:54 <hydraz> +1
09:17:04 * ackthet lol's at the backlog
09:21:51 <sinelaw> Am I right to conclude that Parsec (or similar packages) are difficult to use for left-recursive grammars?
09:22:29 <c_wraith> sinelaw: that's correct, and why they usually have primitives like chainl
09:23:10 <roelof> I have this code : http://lpaste.net/145113  but when n = 1 I see as answer 0.1 where I expect to see "0.01"  
09:23:14 <sinelaw> c_wraith: and when there are multiple mutually recursive terminals, chainl gets complicated too. Am I right?
09:23:28 <roelof> Where did my thinking gets the wrong turn 
09:23:41 <c_wraith> sinelaw: alternatively, there is the earley package. The Earley algorithm doesn't care about left or right recursion. 
09:24:06 <sinelaw> c_wraith: I've heard but didn't look yet. Happy/Alex seem to do a good job also
09:24:53 <c_wraith> sinelaw: happy is lalr(1), I believe. So it handles left recursion fine, but it had other cases where it breaks down. 
09:24:59 <saulzar_> roelof, because the part which prints the decimal prints 1 as 1 not 01
09:25:40 <roelof> oke, and how can I solve this ? 
09:25:50 <sinelaw> c_wraith: i got it to loop infinitely once. is that what you mean?
09:26:16 <c_wraith> sinelaw: yep. There are grammars where it will do that. 
09:27:20 <c_wraith> sinelaw: in comparison, the Earley algorithm (iirc) handles all context free grammars, at the cost of some performance. 
09:27:44 <saulzar_> roelof, Maybe make a function 'pad' which takes a string adds padding (in this case of '0's) when length is less than what you want?
09:27:51 <sinelaw> c_wraith: amortized over the cases of infinite loops, it's infinitely faster then :)
09:28:06 <c_wraith> Minor detail. :) 
09:28:08 <sinelaw> c_wraith: thanks, I'll look at Early
09:28:14 <jophish> roelof: you could use printf also, but it's perhaps overkill
09:28:18 <jophish> > printf "%02d" 1  :: String
09:28:19 <lambdabot>  "01"
09:28:34 <roelof> oke, I can try that , The only thing I have to figure out if the pad is before or after the number 
09:28:40 <saulzar_> roelof, e.g. https://gist.github.com/hanshoglund/5941143  
09:29:11 <jophish> > printf "%d.%02d" 0 1  :: String
09:29:12 <lambdabot>  "0.01"
09:29:13 <saulzar_> roelof, Should always need to pad before - 10 will print as 10 already :)
09:29:56 <sinelaw> c_wraith: would quickchecking Happy (by generating arbitrary ASTs and rendering them) satisfy you? if I need performance
09:30:01 <roelof> jophish:  also a idea, I have to figure out how to let it work with the show function 
09:30:37 <jophish> roelof: padding as saulzar_ suggested is probably easiest
09:31:17 <sinelaw> I'd expect any problematic loopy terms to come up that way
09:31:30 <c_wraith> sinelaw: with a fixed grammar? I'm not sure you'd find the worst cases. But you can learn what the bad cases are and (usually) work around them statically 
09:34:42 <roelof> I tried the pad function but see this error : http://lpaste.net/145115
09:35:53 <roelof> BRB dinner 
09:36:01 <sinelaw> c_wraith: I wrote an applicative (combinator) parser that uses explicit fix-points to limit left-recursive terms so that they terminate when the required input stream would be longer than the given input stream
09:36:13 <sinelaw> it works, but it's very slow.
09:37:17 <jophish> roelof: the compiler has told you exactly what's gone wrong
09:43:04 * hackagebot html-conduit 1.2.1 - Parse HTML documents using xml-conduit datatypes.  https://hackage.haskell.org/package/html-conduit-1.2.1 (MichaelSnoyman)
09:48:30 * hackagebot blake2 0.1.0 - A library providing BLAKE2  https://hackage.haskell.org/package/blake2-0.1.0 (jgalt)
09:48:34 <orion> tommd: ^
09:58:30 * hackagebot cereal 0.5.1.0 - A binary serialization library  https://hackage.haskell.org/package/cereal-0.5.1.0 (TrevorElliott)
10:02:08 <thimoteus> @faq Is Predicate a functor?
10:02:08 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
10:03:51 <roelof> jophish:  correct but do not see how to solve this ? 
10:03:54 <quicksilver> it's a contravariant functor, thimoteus 
10:04:00 <E4xoi> it's not a covariant functor
10:04:12 <E4xoi> which is what we represent with the Functor typeclass 
10:04:14 <quicksilver> if you mean newtype Predicate a = Predicate (a -> Bool)
10:06:12 <tommd> orion: Good work.
10:08:13 <jophish> fmap :: a -> b -> f a -> f b; contramap :: a -> b -> f b -> f a; thimoteus 
10:08:14 <orion> :)
10:08:45 <selveskii> Hello, everyone! I currently have something like data A w = A (w (A w)). Is it possible to write something like data A w = A (w A)?
10:08:49 <Iceland_jack>     fmap      :: (a -> b) -> (f a -> f b)
10:08:49 <Iceland_jack>     contramap :: (a -> b) -> (f b -> f a)
10:08:56 <selveskii> It seems that I ran into a infinite kind issue.
10:10:28 <selveskii> I tried to use kind signatures, say w :: (* -> *) -> *, then A became ((* -> *) -> *) -> *
10:10:49 <selveskii> I tried to use PolyKinds but essentially I ended up with same limitations.
10:11:30 <roelof> jophish:  saulzar  thanks, solved this way : http://lpaste.net/145119  I hope it's the right way 
10:11:32 <phadej> selveskii: looking for http://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html#t:Fix
10:11:36 <phadej> ?
10:12:57 <jophish> roelof: looks pretty good
10:13:33 <roelof> Im happy, learned another things and solved again a challenging exercise 
10:13:35 <jophish> roelof: you might want to consider making a function showPadded :: Int -> Int -> String
10:14:18 <selveskii> phadej: Yes, that's the solution I came up with though not tried yet, but it still requires me to type Fix for a lot of times…
10:15:08 <roelof> jophish:  what is the difference between showPadded and padL, or do you want the show also in the sub function 
10:15:41 <jophish> roelof: padL is only really useful for numbers, it doesn't /really/ make sense for it to be taking any stribng
10:15:42 <selveskii> And a more serious issue is related with instances deriving, I could not get it right (without trying Fix new type though)
10:15:44 <jophish> string*
10:17:21 <roelof> jophish:  oke, In this function padL does only have to work with numbers 
10:17:22 <phadej> selveskii: which kind of instance you try to write. You probably cannot derive any instances automatically
10:17:23 <selveskii> Oh, I solved the deriving instances issue by adding three extensions…
10:17:32 <phadej> selveskii: I'll be surprised if GHC actually can
10:17:53 <roelof> one thing to find out. How to make a difference between a integer like 234 and a double/float 2.35 
10:18:09 <phadej> selveskii: except something trivial like: deriving instance Eq (f (Fix f)) => Eq (Fix f)
10:18:50 <selveskii> http://codepad.org/ET1GzgYA indeed, I just try to derive Eq and Show
10:21:38 <selveskii> oops, it seems that after adding all standalone instances GHC complains again.
10:22:09 <selveskii> maybe I should use recursion scheme library
10:22:42 <sinelaw> I have an application that uses ByteStrings all over the place. Heap profiling shows ARR_WORDS leak. I Can't seem to track down who is holding on to what...
10:23:48 <roelof> anyone a tip how I can see if a number is a float /double or a integer ? as far as I can see there is no isFloat or isInteger ? 
10:24:14 <sinelaw> roelof: look to the type
10:24:17 <sinelaw> :t 3.2
10:24:19 <lambdabot> Fractional a => a
10:24:27 <suppi> roelof, types are determined in compile time and not runtime
10:24:28 <sinelaw> :t 3/2
10:24:29 <lambdabot> Fractional a => a
10:24:33 <suppi> roelof, why do you need to know?
10:24:45 <sinelaw> :t 3 `div` 2
10:24:47 <lambdabot> Integral a => a
10:24:54 <sinelaw> roelof: see?
10:25:01 <sinelaw> or, if it's a specific type:
10:25:07 <sinelaw> > (3 :: Int)
10:25:09 <lambdabot>  3
10:25:25 <roelof> because I need to convert 123 to 1.23 but if the number is already 1.23 I need only to be converted to a string , suppi
10:25:27 <sinelaw> err. you know what I mean.  It could be Int, Double, etc.
10:26:07 <phadej> selveskii: I don't really understand what kind of recursion you want
10:26:23 <phadej> selveskii: it helps you (and others) to write base type first, and then abstract
10:26:33 <phadej> ... the recursion out
10:26:37 <suppi> roelof, what is the type of your input?
10:26:44 <sinelaw> roelof: think with static types. what's the type of the function you propose? what type of argument does it take and what does it return?
10:27:03 <roelof> Num ? so the input can be 1 but also 2.45 
10:27:19 <sinelaw> and what do you want to return?
10:27:42 <roelof> in both cases a string 
10:27:48 <sinelaw> ok, so Num a => a -> String
10:27:49 <jophish> roelof: if you're using mod and div then the argument will be Integral
10:27:51 <jophish> :t div
10:27:52 <lambdabot> Integral a => a -> a -> a
10:27:54 <phadej> selveskii: data Alt w = Alt (w (Pat (Alt w))) (w (Expr (Alt w))) (w (Decl (Alt w))) works, but I have no idea if that what you want
10:28:06 <sinelaw> roelof: you want to know if the argument is an integer?
10:29:18 <sinelaw> roelof: there's a nice trick: use 'floor n == ceiling n'  http://stackoverflow.com/a/2898459/562906
10:29:43 <Iceland_jack> sinelaw: you can also use Text.Read.readMaybe to check, then turn it into a pattern synonym
10:29:56 <Iceland_jack> Or.. prisms :)
10:30:04 <sinelaw> > (\x -> floor x == ceiling x) 3.2
10:30:06 <lambdabot>  False
10:30:11 <sinelaw> > (\x -> floor x == ceiling x) 3
10:30:12 <roelof> sinelaw:  thanks, I will try that 
10:30:13 <lambdabot>  True
10:30:23 <Iceland_jack>     asInt :: String -> Maybe Int
10:30:23 <Iceland_jack>     asInt = readMaybe
10:30:26 <suppi> > (\x -> floor  ceiling x) 3.0
10:30:28 <lambdabot>      Could not deduce (RealFrac (a0 -> b0))
10:30:29 <lambdabot>        arising from a use of ‘floor’
10:30:29 <lambdabot>      from the context (Fractional a, Integral (a -> t))
10:30:34 <suppi> > (\x -> floor == ceiling x) 3.0
10:30:36 <lambdabot>      No instance for (Integral b0) arising from a use of ‘floor’
10:30:36 <lambdabot>      The type variable ‘b0’ is ambiguous
10:30:36 <lambdabot>      Note: there are several potential instances:
10:30:39 <sinelaw> :t floor
10:30:40 <lambdabot> (Integral b, RealFrac a) => a -> b
10:30:41 <suppi> meh
10:30:44 <suppi> > (\x -> floor x == ceiling x) 3.0
10:30:46 <lambdabot>  True
10:30:51 <suppi> sorry.
10:31:08 <selveskii> phadej: You are right, I should try that first. I am refactoring my parser which produces an AST, each node of which could attach some information.
10:31:10 <suppi> > (\x -> floor x == ceiling x) (3 :: Int)
10:31:12 <lambdabot>      No instance for (RealFrac Int) arising from a use of ‘floor’
10:31:14 <lambdabot>      In the first argument of ‘(==)’, namely ‘floor x’
10:31:16 <lambdabot>      In the expression: floor x == ceiling x
10:31:23 <sinelaw> roelof: yeah see above, won't work
10:31:33 <sinelaw> it's good if you get a RealFrac as your argument
10:31:36 <sinelaw> which maybe you should?
10:31:43 <selveskii> phadej: I am thinking of putting the information container and the actual AST in two datatypes
10:31:48 <sinelaw> or you can use Iceland_jack's method
10:31:53 <Iceland_jack> then
10:31:53 <Iceland_jack>     pattern :: Int -> String
10:31:53 <Iceland_jack>     pattern AsInt int <- (asInt -> Just int) where
10:31:53 <Iceland_jack>             AsInt int = show int 
10:32:58 <lpaste_> flexfit pasted “Parser” at http://lpaste.net/9086010886715342848
10:33:31 <flexfit> I'm trying to understand some parsing code. What exactly is happening on line 47? I'm not exactly sure what return does there.
10:33:56 <selveskii> I am a bit confused, what is the meaning of deriving instance Eq (f (Fix f)) => Eq (Fix f) after all, forming a cycle in my view
10:35:26 <sinelaw> flexfit: does that compile?
10:35:43 <sinelaw> oh yeah it shoul.
10:37:17 <sinelaw> flexfit: that return is of the list monad
10:37:18 <sinelaw> > (return 3) :: [Int]
10:37:20 <lambdabot>  [3]
10:37:34 <sinelaw> :t return . last
10:37:35 <lambdabot> Monad m => [a] -> m a
10:38:03 <sinelaw> in this case m = [], so return . last :: [a] -> [a], takes the last element from the argument and returns it alone in a list
10:38:18 <phadej> selveskii: just have an ann on each ast node, it's much easier
10:38:21 <sinelaw> > return . last $ [ 1, 2, 3 ]
10:38:23 <lambdabot>      No instance for (Show (m0 a0))
10:38:23 <lambdabot>        arising from a use of ‘show_M380787606719160478914779’
10:38:23 <lambdabot>      The type variables ‘m0’, ‘a0’ are ambiguous
10:38:33 <sinelaw> > (return . last $ [ 1, 2, 3 ]) :: [Int]
10:38:35 <lambdabot>  [3]
10:38:39 <phadej> i.e. data AST ann = Node1 ann | RecNode ann (Ast ann) (Ast ann) etc.
10:38:51 <sinelaw> flexfit: there ^^^
10:40:19 <selveskii> phadej: thanks, that's the original approach I chose; must be the willing of the Force
10:47:54 <FofG> stackage having issues? 
10:47:57 <FofG> `SQLite3 returned ErrorIO while attempting to perform prepare "PRAGMA journal_mode=WAL;": disk I/O error`
10:48:27 <ReinH> selveskii: Are you asking about how to annotate a recursive data type like an AST?
10:50:58 <selveskii> ReinH: maybe I should summarize my problem on something like StackOverflow or Reddit
10:51:08 <flexfit> sinelaw: wouldn't I get the same thing if I wrapped the whole thing in a list? Like [last . (list (spot p))]
10:53:09 <michal__> hello, would it be possible to remove the () from fromDay utcTime = posixSecondsToUTCTime $ 10^9 + (utcTimeToPOSIXSeconds utcTime)
10:53:21 <Cale> yes
10:53:28 <michal__> I tried it with $ but failed to do it
10:53:40 <Cale> You can do that, because function application binds more tightly than any infix operator
10:54:05 <michal__> aha!
10:54:09 <michal__> thanks very much! :) 
10:54:09 <Cale> So simply deleting the parens will give an expression which means the same thing
10:54:44 <michal__> and is the dollar usage there appropriate?
10:54:59 <michal__> I am new to haskell but it seems a little odd for me (but I am trying to write haskelly code
10:56:36 <FireFly> The dollar isn't appropriate there
10:56:40 <FireFly> oh, wait
10:56:46 <FireFly> sorry, that dollar is okay I guess
10:57:03 <FireFly> although I think I would write it with explicit parentheses.. but that's mostly up to taste/personal style
10:57:31 <selveskii> I think maybe I have found the solution from  ezyang's blog, using data Expr a = If a a a rather than data Expr a = If (a (Expr a)) … seems to be better
10:58:06 <selveskii> oops, I forgot my AST is slightly more complicated…
10:58:20 <selveskii> like this data Expr w = ELam  [w (Pat w)]  (w (Expr w))
10:58:22 <tzh> the problem with using a dollar there is that then you have another infix section `10^9 +` right next to it, and that generally doesn't parse
10:59:24 <monochrom> I don't think I understand "a (Expr a)" and "w (Pat w)". both why you do it and why you think it is even legal.
10:59:26 <michal__> thanks for the input :)
10:59:51 <Welkin> dollar?
10:59:55 <Welkin> you mean dollar sign?
11:00:43 <michal__> the dollar sign that was in a code I posted few lines up :)
11:03:33 * hackagebot stack-hpc-coveralls 0.0.0.1 - Initial project template from stack  https://hackage.haskell.org/package/stack-hpc-coveralls-0.0.0.1 (rubik)
11:03:35 * hackagebot consul-haskell 0.3 - A consul client for Haskell  https://hackage.haskell.org/package/consul-haskell-0.3 (sseveran)
11:06:44 <ReinH> selveskii: That's... impossible. What are you trying to do?
11:13:13 <tommd> That isn't so impossible.  It's a common way to add location information to expressions.
11:14:25 <tommd> http://lpaste.net/145123
11:21:22 <selveskii> ReinH: http://stackoverflow.com/questions/33679522/choose-an-ast-representation-in-haskell I have posted it on SO, thanks for your interest
11:22:29 <ReinH> tommd: Ok, now how do you actually construct values?
11:23:16 <ReinH> The common ways to add annotations are SPJ's way from his book and Cofree unfixed functors, afaik
11:25:24 <monochrom> thanks tommd
11:25:46 <johnw> ReinH: what is an "unfixed functor"?
11:26:23 <ReinH> johnw: A functor that you might apply Fix to :) like data HuttonF x = Int Int | Plus x x
11:26:51 <johnw> ah
11:27:11 <monochrom> hmm, is the word "unfixed" widely used for this?
11:27:13 <ReinH> type Hutton = Fix HuttonF
11:27:18 <johnw> monochrom: I'd not seen it before
11:27:22 <ReinH> I've seen it in a few places, e.g., http://mpickering.github.io/posts/2014-11-27-pain-free.html
11:27:40 <ReinH> But no, I suppose it is not widely used
11:28:29 <ReinH> (I guess it isn't actually SPJ's originally, but it's the way from his book.)
11:33:01 <jgballin> i know this is a haskell channel but can anyone help with a simple python code?
11:33:11 <ReinH> johnw: It's weird how these things happen. I've just been reading up on AST annotations this week and now we get a question about it.
11:33:28 <ReinH> jgballin: Why don't you try a python channel?
11:33:52 <jgballin> its to crowded question keeps getting over looked
11:34:31 <dolio> This channel is also very crowded.
11:34:37 <ReinH> This isn't an appropriate place to ask python questions.
11:35:03 <jgballin> thanks anyway
11:35:05 <SrPx> Is there any intuition behind the fact that simply typed lc, system f and coc are strongly normalizing ?
11:35:06 <selveskii> ReinH: which book
11:35:07 <ackthet> why would you come to a haskell channel to ask about pythong...
11:35:12 <ackthet> *python
11:35:25 <cite-reader> I'm so happy I'm not the only one who makes that typo.
11:35:51 <ReinH> @google the implementation of functional languages
11:35:53 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
11:35:53 <lambdabot> Title: The Implementation of Functional Programming Languages
11:35:57 <ReinH> selveskii: ^
11:36:08 <ReinH> Might be useful for you
11:36:26 <selveskii> wow, I didn't notice that, I actually have read the chapter 1 of it…
11:36:32 <selveskii> thank you
11:37:05 <ReinH> selveskii: Oh wait that's the older version. http://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/
11:37:30 <selveskii> Yes, I am reading the later version. Thank you
11:37:34 <ReinH> yw
11:37:41 <selveskii> *was reading
11:38:36 <lpaste_> echo1 pasted “printf ” at http://lpaste.net/145126
11:38:45 <funrep> hi guys, anyone here study at kth/su? im interested in hearing experiences from the datateknik and datavetenskap programmes and what the differens is, please pm or #haskell-blah
11:39:00 <lpaste_> echo1 revised “printf ”: “No title” at http://lpaste.net/145126
11:39:32 <lpaste_> echo1 revised “printf ”: “No title” at http://lpaste.net/145126
11:40:13 <echo1> Hi I have a question about printf : http://lpaste.net/145126 It doesn't print a simple %d 
11:40:49 <echo1> I have followed the discussion on the SO http://stackoverflow.com/questions/2468332/string-formatting-in-haskell
11:41:45 <echo1> whereas from ghci it works well
11:42:11 <Ankhers> echo1: I think if you write `printf "%d" (5 :: Int)' it may work.
11:42:15 <ReinH> echo1: does printf "%d" (5 :: Int) work?
11:42:16 <Ankhers> maybe
11:42:20 <echo1> no
11:42:29 <echo1> tried that too
11:42:32 <Ankhers> echo1: Do you get the same error when you do that?
11:43:56 <Ankhers> echo1: It compiled for me when I add the :: Int
11:43:59 <echo1> I have omitted the parenthesis that's the huge difference I guess... now it's ok thank you
11:44:02 <Ankhers> Did you have the brackets around it?
11:44:07 <Ankhers> cool
11:46:10 <echo1> Why should I specify 5::Int, shouldn't be deduced by the type inference?
11:46:37 <akegalj> echo1: it could be Integer/Int/...?
11:46:57 <ReinH> Not without defaulting
11:47:02 <ReinH> Which ghci has
11:47:11 <Ankhers> > 5 :: Float
11:47:13 <lambdabot>  5.0
11:47:23 <echo1> from repl printf "%d\n" 5 works well that's why I'm wondering
11:47:42 <ReinH> Because GHCi has extended default rules
11:48:05 <zopa> echo1: the type of 5 is Num a => a. But not every Num is a PrintfArg
11:48:05 <echo1> my version is 7.6.3
11:48:31 <echo1> zopa: oh I see now..
11:49:00 <ReinH> (You should also update GHC)
11:52:11 <echo1> the printf is defined as follows PrintfType r => String -> r but I pass in my case two args one of them is an Int for instance, what does printf manage this?
11:52:32 <echo1> I mean How not what
11:53:33 <suppi> http://chris-taylor.github.io/blog/2013/03/01/how-haskell-printf-works/
11:53:45 <Ankhers> echo1: printf "%s %s" "hello" "World"
11:53:49 <suppi> if I remember correctly ^_^"
11:54:36 <echo1> Ankhers: I mean internally
11:55:05 <flexfit> Is there any method in haskell that removes whitespace inside of a string?
11:55:18 <jophish> flexfit: filter (not.isSpace)
11:55:33 <jophish> > filter (not . isSpace) "hello cruel world\n"
11:55:35 <lambdabot>  "hellocruelworld"
11:55:45 <flexfit> ah
11:55:49 <flexfit> I see
11:55:50 <echo1> suppi: thx
11:55:54 <suppi> np
11:55:55 <flexfit> I was looking at strip
11:56:01 <flexfit> and lstrip and rstrip
11:56:03 <flexfit> thanks!
11:57:14 <jophish> flexfit: they'll just remove whitespace at the beginning and end of a string
11:58:02 <echo1> If have understood correctly in order to printf a list [Int] I have extend it to new types, is this correct?
11:58:05 <jophish> flexfit: you may also be interested in words
11:58:13 <jophish> > words "hello cruel world\n"
11:58:14 <lambdabot>  ["hello","cruel","world"]
11:58:49 <mpickering> Is there a canonical example of something which is a functor but not traversable? 
11:59:01 <mpickering> some like Cont maybe?
11:59:06 <Ankhers> > unwords $ words "   This  is a\nsentence"
11:59:08 <lambdabot>  "This is a sentence"
12:01:47 <jophish> mpickering: (->) r perhaps
12:05:25 <impure_hate> how does one uses showsPrec?
12:05:53 <cguille> Hello, which web framework would you recommend for a beginner to start playing with Haskell? I was going to give a try to this tutorial about Yesod, but it seems that I can't even get the Yesod install to work: http://yannesposito.com/Scratch/fr/blog/Yesod-tutorial-for-newbies/
12:06:52 <cguille> (Also, the installation instructions on Yesod's website are quite different than those on this tutorial so it makes me a bit skeptical.)
12:07:44 <ackthet> cguille: i basically used stack to install it, but their quick start guide instructions did not work for me
12:07:52 <ackthet> i asked about it in #yesod but no reply
12:07:53 <zopa> echo1: `mapM_ (printf "%d ") ([3, 4, 5] :: [Int])`
12:08:34 <cguille> Thank you ackthet, so maybe it's not just me. The blog post just uses cabal to install Yesid but well…
12:08:37 * hackagebot urlpath 4.2.0 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-4.2.0 (athanclark)
12:08:56 <echo1> zopa: ye that's a traditional way, formatInt :: (Integral a, Bounded a) => a -> FieldFormatter
12:09:15 <kadoban> cguille: I wouldn't generally recommend a project for a haskell newbie. Haskell doesn't tend to be a language that can be learned by just winging it. I'd start with https://github.com/bitemyapp/learnhaskell or http://haskellbook.com/ (haven't read the later, but I've heard good things and suspect it's very nice).
12:09:31 <echo1> zoppa: I'm trying to figure out how to use FielFormatter
12:11:02 <echo1> I think it doesn't make sense to extend printf for lists, too complicated
12:11:52 <cguille> kadoban: I went through http://learnyouahaskell.com some time ago. Does this do any good? I feel like I understood some things but could not grasp any real usage. Since I am a web dev, I thought it would be interesting to see how a Haskell web framework would be.
12:12:18 <echo1> maybe something like this could work printf "%s" show [1,2]
12:12:57 <kadoban> cguille: I'm … not a fan of LYAH for basically the reason you said. There aren't any exercises in it, so it doesn't actually ask you to … do anything yourself, or guide you towards how. So I got to the end and I'm like "welp … still can't program in haskell".
12:13:09 <ReinH> cguille: That's about par for the course with LYAH
12:13:51 <kadoban> cguille: So I'd probably consider that … some time helping you familiarize yourself with basic concepts, and start again with something like cis194 (from the first link I said) or the book, and it'll go faster because you have some familiarity. But it'll be more grounded in actually accomplishing something.
12:13:55 <echo1> zepo: printf "%s" $show [1,2] works
12:14:03 <echo1> zepo: printf "%s" $show [1,2]
12:14:09 <ReinH> cguille: It isn't ready yet but you might be interested in following https://www.indiegogo.com/projects/haskell-web-development-a-freely-available-book#/
12:14:17 <ReinH> cguille: I'd recommend trying Scotty
12:14:48 <ReinH> cguille: There are some good resources listed at https://github.com/bitemyapp/learnhaskell
12:15:10 <pandantic> kadoban: I like to read LYAH after I get a basic grasp of what ever I'm learning. To see if their explanation helps or if I'm missing anything.
12:15:24 <cguille> Current status: opening all of your URLs in my browser. Thank you!
12:15:45 <bitemyapp> cguille: how well do you know Haskell?
12:16:13 <bitemyapp> cguille: if you learn Haskell well, figuring out a library shouldn't be too big of an ordeal. Especially if you've done web dev before and know the usual patterns (route, template, etc.)
12:18:41 <kadoban> pandantic: I suspect it's useful as a companion, yeah. Just not a main book. I'm also not in love with the way they explain some things, but don't really have real gripes personally besides the lack of exercises.
12:18:43 <ReinH> bitemyapp: As long as that library isn't Yesod... Yesod is pretty opinionated...
12:18:43 <cguille> bitemyapp: Not well. I don't remember a lot of what I read months ago. But as you say, I am well familiar with web dev concepts.
12:19:24 <ReinH> cguille: If you've used Sinatra for Ruby or a similar "microframework" then you might like Scotty. At least I think it's the most straightforward way to get into web dev with Haskell.
12:20:03 <cguille> Sinatra seems to have inspired lots of "microframeworks" :p
12:20:26 <ReinH> kadoban: my gripe is exactly what was demonstrated here again: it's very superficial, like an inch-deep ocean, and doesn't actually prepare people to do meaningful stuff with the knowledge they acquire.
12:20:33 <ReinH> cguille: yep
12:20:55 <ReinH> And the lack of exercises is a real problem
12:23:20 <kadoban> ReinH: Indeed. It's more like … light reading on Haskell than an actual pedagogical tool. It's like those popular science books that just kind of show you some cool part of physics or whatever, without you actually being able to do much with it.
12:23:33 <bitemyapp> ReinH: being opinionated isn't a problem for new people.
12:24:07 <bitemyapp> cguille: well, my recommendation is going to be to get the fundamentals of Haskell together, otherwise you'll spin your wheels on things like, "how the fuck do I run an IO action in this web app?"
12:24:24 <bitemyapp> cguille: Naturally I'd recommend my book or my free guide, depending on your circumstances.
12:24:29 <bitemyapp> @where learnhaskell
12:24:29 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:24:31 <bitemyapp> @where book
12:24:31 <lambdabot> http://haskellbook.com/
12:25:00 <bitemyapp> cguille: this channel or #haskell-beginners can help if you get stuck, but the basic idea here is to get the basics in place, do exercises, then start stretching your legs with a web app project and note where you get stuck so you know what to practice next.
12:25:13 <cguille> Thanks, I'm reading it.
12:25:30 <cguille> Well, more like I'm removing haskell-platform.
12:25:33 <bitemyapp> cguille: the book is wayyyyy more comprehensive than the guide.
12:25:49 <bitemyapp> I'm trying to put together an alternative to cis194, but I don't have time (because of the book)
12:25:56 <cguille> Since the first advice it tells is "DO NOT INSTALL HASKELL PLATFORM"
12:26:19 <ReinH> bitemyapp: Sure, I just mean to suggest that you have to learn the "Yesod Way" to do things, beyond just knowing basic Haskell.
12:26:33 <bitemyapp> there's not much there, there.
12:26:38 <ReinH> Ok.
12:43:38 * hackagebot stack-hpc-coveralls 0.0.0.2 - Initial project template from stack  https://hackage.haskell.org/package/stack-hpc-coveralls-0.0.0.2 (rubik)
12:44:20 <Jello_Raptor_> how do you express the Tuple functor instance at the type level? I've got an Foo :: (* -> *) -> * and I want to use (Int,) but I get a parse error 
12:44:43 <Jello_Raptor_> err, I want to use `Foo (Int,)`
12:44:54 <Jello_Raptor_> and this is which TupleSections turned on
12:45:13 <Iceland_jack> @kind ((,) Int)
12:45:14 <lambdabot> * -> *
12:45:31 <Iceland_jack> TupleSections are for the term level, not type level
12:50:56 <cguille> Thanks for your advices! Bye.
12:51:10 <bitemyapp> cguille: cheers :)
12:51:55 <funrep> found this great image: http://composingprograms.com/img/function_print.png
12:54:47 <kruskoph> #haskell-beginners
12:57:01 <jg_> i'm searching for a working regex haskell library that supports the 'replace' api. Anyone knows one?
12:59:56 <average> jg_: Haskell doesn't have a substitute regex library ?
13:00:02 <average> that seems unlikely
13:07:59 <sm> average: so you would think!
13:08:35 <average> sm: I'm being told that iteration is slow in R
13:08:39 <average> so... it could be worse..
13:08:39 <sm> jg_: Hledger.Utils.Regex has a replace, works with regex-tdfa
13:09:00 <average> at least Haskell people are ok with iterating
13:17:53 <lpaste_> echo1 pasted “fromInteger” at http://lpaste.net/145135
13:18:05 <echo1> How can I define fromInteger definition for lists in Num class; I don't even understand what's it purpose. http://lpaste.net/145135
13:19:28 <glguy> The purpose is for mapping literals in source code to your type
13:19:51 <glguy> So figure out what (42 :: [Int]) means to your instance
13:20:24 <AleXoundOS> Hi. How do you think, which GUI library is supported best by Haskell at the moment, GTK or QT ?
13:22:06 <echo1> glguy: 42 in my case would an element of the array, but I can't understand it what to do with it
13:23:05 <glguy> echo1: An instance of Num for list doesn't generally make sense, so you'll just have to make something up
13:23:40 * hackagebot path-extra 0.0.3 - Chris Done's path library, enriched with URL-related goodies.  https://hackage.haskell.org/package/path-extra-0.0.3 (athanclark)
13:23:42 * hackagebot GPipe 2.1.4 - Typesafe functional GPU graphics programming  https://hackage.haskell.org/package/GPipe-2.1.4 (TobiasBexelius)
13:24:02 <jg_> sm: thanks! looks exactly what i need
13:24:36 <echo1>  fromInteger: takes Integer and gives a generic type back; how would you implement it
13:25:08 <jg_> from what i've seen so far haskell regexp libraries are not very good in comparison to mainstream langs
13:25:25 <echo1> abs, * , + , etc were obvious to me
13:25:43 <glguy> fromInteger is implemented once per instance. You konw what type you're suppoosed to return because it's the instance you're writing
13:25:55 <sinelaw> da-x is working on some nice regex stuff
13:27:06 <jg_> da-x: make sure to include Data.Text + search & replace support in your library :)
13:27:10 <echo1>  "a" is my instance right?
13:27:11 <ChristianS> echo1: do could convert 42 to [42], i guess, though whether that makes much sense is up to you
13:27:23 <tobiasBora> Hello !
13:28:10 <ChristianS> echo1: also, just curious, what's your + doing? [1,2] + [3,4,5] e.g.
13:28:27 <tobiasBora> Is there an easy way to get the maximums (notice the s) of a lists (something like "maximumsBy (compare `on` (\(a,b) -> a)) l" ?
13:28:29 <tobiasBora> )
13:28:40 * hackagebot urlpath 5.0.0 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-5.0.0 (athanclark)
13:28:41 <lpaste_> echo1 pasted “No title” at http://lpaste.net/145137
13:28:48 <echo1> http://lpaste.net/145137
13:29:44 <ChristianS> echo1: you're asking us to do your homework?
13:31:09 <echo1> I'm missing the last step, I did it almost by myself... I can't figure out how to deal with the last step
13:32:13 <ChristianS> echo1: make something up, i proposed a possible something above
13:34:34 <monochrom> echo1: do you know the type of fromInteger?
13:36:00 <echo1> Integer -> a as somebody suggested is should be I guess the same type of the instance therefore Num [a]
13:36:33 <monochrom> you wrote it wrong. Num a => Integer -> [a]
13:37:06 <echo1> I wrote the definition from hoogle
13:37:19 <echo1> fromInteger :: Integer -> a
13:37:46 <monochrom> I give up.
13:38:33 <ChristianS> echo1: Num a => Integer -> [a]  is the type required for your specific instance
13:40:25 <echo1> fromInteger x = [x]?
13:41:31 <ChristianS> echo1: alomost, but x is an Integer, not yet an a
13:41:37 <ChristianS> echo1: how can you convert it?
13:42:14 <echo1> fromInteger x = [fromInteger x]?
13:42:25 <ChristianS> looks good!
13:43:31 <echo1> It doesn't look not so straightforward to me
13:44:12 <echo1> That was hard
13:47:25 <echo1> Can fromInteger be seen as whenever you encounter an integer literal put in a default context?
13:48:01 <echo1> in my case default context would a list: 1 -> [1]
13:49:38 <kazagistar> echo1: it is exactly what its type signature says: "Whenever you see something that is of the Integer type, convert it to whatever Num you need."
13:50:22 <kazagistar> echo1: if you are comfortable with function overloading, it is the same thing, just overloading based on return type instead of input type.
13:50:29 <xpilot> question about functional dependencies: what exactly does "Functional dependencies conflict between instance declarations" mean?
13:50:56 <xpilot> in particular, my two instances are non-overlapping
13:51:05 <glguy> xpilot: Maybe show us the instances?
13:51:24 <glguy> (and the class)
13:51:56 <echo1> I couldn't figure out a sample explanation for that operation, that's why I was stuck
13:52:51 <echo1> Thank you all for help
13:53:14 <lpaste_> xpilot pasted “Functional Dependency Error” at http://lpaste.net/145140
13:53:53 <glguy> xplat: Can you attach the error?
13:54:26 <glguy> oops, xpilot.
13:54:46 <glguy> xpilot: Your c -> l dependency is overlapped, at least
13:55:47 <glguy> xpilot: note that: (f r) is more general than (f a -> c)
13:56:21 <glguy> (f a -> c) is   ((->) (f a)) c
13:56:48 <xpilot> ah I see
14:02:43 <rpfun> is there a way to decide on the values of type-level naturals at runtime?
14:04:12 <rpfun> i mean suppose I have some type "T a" (classic example is a length-encoded vector), and the user says "give me a vector of length 10". is there a way to handle such a case?
14:04:59 <shachaf> http://hackage.haskell.org/package/reflection
14:14:35 <rios> @pl any
14:14:35 <lambdabot> any
14:14:55 <rios> @pl \p->((.) or) (map p)
14:14:55 <lambdabot> any
14:15:13 <rios> @pl \f p->((.) f) (map p)
14:15:13 <lambdabot> (. map) . (.)
14:16:43 <glguy> rios: You can play with lambdabot in private message
14:33:43 * hackagebot stack-hpc-coveralls 0.0.0.3 - Initial project template from stack  https://hackage.haskell.org/package/stack-hpc-coveralls-0.0.0.3 (rubik)
14:58:30 <Denommus> aren't you guys freaking out about frege?
14:59:20 <pharaun> ?
14:59:25 <pharaun> why would we be?
14:59:37 <EvanR> did something happen to it? ;)
14:59:44 <monochrom> no, we don't freak out, we are not on LSD
14:59:59 <Clint> speak for yourself
15:00:05 <EvanR> were on acid-state
15:00:34 <monochrom> haha
15:01:13 <mossey> if I have a function f :: a -> Maybe a, how do I sequence them like Just x >>= f >>= f >>= etc., collecting all the Maybe results, and stopping on Nothing?
15:01:23 <cite-reader> No but seriously. Why would any of us be freaking out about Frege?
15:02:08 <glguy> mossey: unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
15:02:14 <glguy> mossey: Is that what you're looking for?
15:03:39 <mossey> glguy: but that doesn't use the conciseness of Monad composition, I don't think
15:03:44 * hackagebot eventstore 0.9.0.0 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.9.0.0 (YorickLaupa)
15:03:46 <mossey> looks lengthy to implement
15:03:59 <EvanR> @src unfoldr
15:03:59 <lambdabot> unfoldr f b = case f b of
15:03:59 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
15:03:59 <lambdabot>    Nothing        -> []
15:04:33 <EvanR> if it wasnt already implemented
15:04:44 <broma0> Hey all, I need some help with Aeson. Why is this not working: "(decode (encode [t :: UTCTime]) :: Maybe [UTCTime)"? it gives 'Nothing'. The encoded [UTCTime] gives "[utctime]", but not the expected "[\"utctime\"]"
15:04:49 <mossey> would takeWhile isJust (Just x >>= repeat f) work?
15:05:21 <broma0> it's like aeson unquotes the timestamp when it's inside of a list..
15:06:08 <EvanR> :t takeWhile isJust (Just () >>= repeat Just)
15:06:09 <lambdabot>     Couldn't match type ‘Maybe’ with ‘[]’
15:06:10 <lambdabot>     Expected type: [()]
15:06:10 <lambdabot>       Actual type: Maybe ()
15:06:12 <EvanR> no
15:07:09 <mossey> takeWhile isJust (sequence (Just x : repeat f))?
15:07:30 <EvanR> :t takeWhile isJust (sequence (Just () : repeat Just))
15:07:31 <lambdabot>     Couldn't match expected type ‘[a]’ with actual type ‘Maybe ()’
15:07:31 <lambdabot>     In the first argument of ‘(:)’, namely ‘Just ()’
15:07:31 <lambdabot>     In the first argument of ‘sequence’, namely
15:07:34 <EvanR> nope
15:07:59 <mossey> seems to think it's a list Monad, when I want it to be a Maybe Monad
15:08:06 <EvanR> :t repeat
15:08:07 <lambdabot> a -> [a]
15:08:09 <Denommus> I'm just excited that it might be possible to build actual applications for Android in Haskell
15:08:41 <EvanR> java implies "actual applications" now :(
15:08:44 <mossey> :t sequence (Just ())
15:08:45 <lambdabot>     Couldn't match expected type ‘m a’ with actual type ‘()’
15:08:45 <lambdabot>     In the first argument of ‘Just’, namely ‘()’
15:08:45 <lambdabot>     In the first argument of ‘sequence’, namely ‘(Just ())’
15:09:02 <mossey> :t sequence [Just 3]
15:09:03 <lambdabot> Num a => Maybe [a]
15:09:09 <monochrom> no, it implies "actual applications for Android" now :)
15:09:12 <glguy> lambdabot: can be played with in /msg
15:09:47 <EvanR> its not haskell, so theres some portability issues
15:10:11 <mossey> :t sequence (Just 3 : repeat (Just (++1))
15:10:12 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:10:14 <EvanR> haskell itself has "java-bridge"
15:10:23 <mossey> :t sequence (Just 3 : repeat (Just (++1)))
15:10:26 <lambdabot> (Num ([a] -> [a]), Num [a]) => Maybe [[a] -> [a]]
15:10:45 <mossey> :t sequence (Just 3 : repeat (\x -> x+1))
15:10:46 <lambdabot>     Couldn't match expected type ‘Integer -> Integer’
15:10:46 <lambdabot>                 with actual type ‘Maybe a’
15:10:46 <lambdabot>     The lambda expression ‘\ x -> x + 1’ has one argument,
15:10:55 <mossey> :t sequence (Just 3 : repeat (\x -> Just $ x+1))
15:10:56 <lambdabot>     Couldn't match expected type ‘Integer -> Maybe Integer’
15:10:56 <lambdabot>                 with actual type ‘Maybe a’
15:10:56 <lambdabot>     The lambda expression ‘\ x -> Just $ x + 1’ has one argument,
15:11:52 <mossey> :t sequence (\x -> Just x+1)
15:11:53 <lambdabot> (Num (Maybe a), Traversable ((->) a)) => Maybe (a -> a)
15:11:57 <Denommus> EvanR: "for Android"
15:12:04 <mossey> :t sequence [(\x -> Just x+1)]
15:12:05 <lambdabot> Num (Maybe a) => a -> [Maybe a]
15:12:09 <EvanR> mossey: using Maybe as a monad would amount to losing all your work so far, not what you want. unfoldr, or takeWhile . iterate sounds more like what you want
15:12:30 <Denommus> EvanR: I can build applications in Haskell, of course. But in Android I'd have to go from scratch using only the NDK, wouldn't I?
15:12:47 <Denommus> EvanR: that's what I hate about Android, anyway
15:12:51 <mossey> :t iterate
15:12:53 <lambdabot> (a -> a) -> a -> [a]
15:12:53 <EvanR> assuming the only want to make android programs is use java libraries
15:12:58 <EvanR> you can use haskell's java-bridge
15:13:05 <EvanR> ... assuming you can use haskell
15:13:15 <mossey> take 3 (iterate (+1) 1)
15:13:17 <EvanR> ........ assumin the only way to make*
15:13:41 <mossey> :t take 3 (iterate (+1) 1)
15:14:01 <EvanR> [Int]
15:14:26 <Denommus> EvanR: the other way is to use the NDK, which provides far too little for a practical way of build an application
15:14:36 <EvanR> yeah
15:14:47 <EvanR> the libraries are in java
15:14:58 <Denommus> EvanR: wouldn't Haskell's runtime over the JVM be too heavy, though?
15:15:04 <benzrf> hey Denommus
15:15:06 <Denommus> EvanR: I might try that java-bridge
15:15:11 <Denommus> benzrf: long time no see
15:15:17 <EvanR> youll have a ghc and a jvm
15:15:18 <benzrf> remember when i used to argue at you about how python was great :')
15:15:33 <Denommus> benzrf: haha
15:15:38 <Denommus> benzrf: yeah
15:15:46 <benzrf> (tbh i still think its one of the nicer imperative languages)
15:16:10 <Denommus> benzrf: well, good to see you. But I'm leaving now XD
15:16:11 <Denommus> bye
15:16:22 <benzrf> (the other day i wrote a small program in python and was shocked by how nice it was, i think my memory embellished imperative programing's problems at a small scale)
15:16:50 <monochrom> a certain subset of python is nice
15:17:41 <monochrom> but all of python... all of python is not as nice as all of javascript. this is because javascript has at least got Guy Steele writing a semantics for it. all of it. where is python's semantics, all of it?
15:18:22 <monochrom> especially since python gets its object system by pulling a trick on things like __class etc
15:19:27 <monochrom> to be sure, javascript pulls tricks too, but at least they are documented at Guy-Steele-level quality
15:19:42 <monochrom> python's is documented at you-know-what-I-mean quality
15:19:50 <broma0> Anyone use Aeson extensively?
15:20:41 <EvanR> monochrom: thats all just semantics
15:21:07 <mossey> okay now I'm thinking -- f::Maybe a -> Maybe a, catMaybes . takeWhile isJust $ (iterate f x) -- does that sound right?
15:21:37 <EvanR> takeWhile isJust (iterate f x) is... unfoldr
15:21:41 <mossey> or catMaybes . takeWhile isJust $ (iterate f (Just x)) -- does that sound right?
15:22:03 <EvanR> well, with the catMAybes
15:22:11 <mossey> okay sorry I was slow to get it... will look at definition of unfoldr
15:22:18 <EvanR> you dont even have to ;)
15:22:22 <EvanR> :t unfoldr
15:22:23 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
15:22:49 <broma0> :t getCurrentTime
15:22:51 <lambdabot> Not in scope: ‘getCurrentTime’
15:23:08 <EvanR> :t Data.Time.getCurrentTime
15:23:09 <lambdabot> IO time-1.5.0.1:Data.Time.Clock.UTC.UTCTime
15:23:46 <SiIky> is it possible to create infixed (i dont know if thats the right english word) functions?
15:23:57 <broma0> > Data.Time.getCurrentTime >>= \t -> print (decode (encode [t]))
15:23:59 <lambdabot>  Not in scope: ‘Data.Time.getCurrentTime’Not in scope: ‘decode’Not in scope: ...
15:24:01 * hackagebot stack-hpc-coveralls 0.0.0.4 - Initial project template from stack  https://hackage.haskell.org/package/stack-hpc-coveralls-0.0.0.4 (rubik)
15:24:13 <EvanR> lambdabot can't do IO
15:24:24 <broma0> > Data.Time.Clock.getCurrentTime >>= \t -> pure (decode (encode [t]))
15:24:26 <lambdabot>  Not in scope: ‘Data.Time.Clock.getCurrentTime’Not in scope: ‘decode’Not in s...
15:24:26 <monochrom> wait, do you really want [t] as opposed to t?
15:24:35 <broma0> EvanR: bleh, not even getCurrentTime?
15:24:46 <EvanR> haha
15:24:56 <EvanR> a whitelist of "safe" IO actions?
15:25:03 <EvanR> nothing is safe! NOTHING
15:25:10 <monochrom> lambdabot won't do IO for you. not even return ().
15:25:41 <broma0> monochrom: no, but why oh why does (encode (decode someutftime)) not work?!!?
15:25:42 <tzh> SiIky: yes. `(*^?) :: a -> a -> a` and then `a *^? b = ...`
15:25:50 <monochrom> I don't know
15:26:07 <EvanR> what is decode and encode, at least, what are their types?
15:26:14 <broma0> EvanR: aeson
15:26:34 <EvanR> what does not work mean
15:26:36 <monochrom> I know. decode wants a complete JSON object.
15:26:38 <broma0> > Data.Aeson.encode [1,2,3,4]
15:26:40 <lambdabot>  Not in scope: ‘Data.Aeson.encode’
15:26:50 <SiIky> tzh thank you!
15:27:10 <SiIky> tzh is "infixed" the right word though? 
15:27:22 <tzh> SiIky: it's just "infix"
15:27:26 <monochrom> a complete JSON object means { fieldname : value }.  encode some_utc_time is never going to give you that.
15:27:46 <SiIky> tzh close enough... thx :)
15:27:47 <frerich> Hm, anybody here familiar with 'stack new'? I can't seem to figure out from where it's pulling default values to use for the .cabal file, i.e. where to put a file as given in e.g. https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#templates
15:27:48 <broma0> monochrom: i mistyped. i meant [someutctime] (a list of one UTCtime)
15:27:52 <monochrom> it only gives you the value part. no field name, no curry braces
15:28:06 <frerich> I tried ~/.stack/config.yaml but that doesn't seem to have any effect. Neither does ~/.stack/global/stack.yaml
15:28:22 <monochrom> that one I don't know.
15:28:55 <broma0> monochrom: moral of the story is that 'encode someutc' gives me "thejson", but 'encode [someutc]' gives me '[someutc]' (notice the lack of quotes in the list example
15:29:34 <mgsloan> frerich: Here's the default template used by "new": https://github.com/commercialhaskell/stack-templates/blob/master/new-template.hsfiles
15:30:40 <frerich> mgsloan: Yeah, that looks familiar - when running 'stack new', the placeholders like {{author-name}} are replaced with e.g. author-name as described at https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#templates right?
15:30:57 <frerich> mgsloan: What I can't seem to figure out is where to put the .yaml file which defines author-name :-}
15:31:30 <mgsloan> That stuff goes in .stack/config.yaml
15:31:51 <EvanR> i do recall that aeson has a weird instance for UTCTime
15:32:17 <frerich> mgsloan: Hm... maybe I got the syntax wrong? Does http://lpaste.net/145148 look ok to you?
15:33:44 <mgsloan> Seems correct
15:34:40 <frerich> mgsloan: Pity... here's a sample session showing my 'stack' version and the 'maintainer' line from a generate .cabal file. Maybe you can spot something? http://lpaste.net/145149
15:34:48 <frerich> Maybe I need to call 'stack new' differently somehow...
15:35:28 <mgsloan> stack 0.1.2 is pretty old!
15:35:40 <frerich> Oh. :-)
15:35:52 <mgsloan> I wouldn't be surprised if these docs don't apply to it
15:36:25 <mgsloan> At least within the scheme of stack's short lifetime, 0.1.2 is ages ago :)
15:36:41 <frerich> Hm I see there's an 'upgrade' command to stack. I never tried that before, ahem... let's see. It fetches stack-0.1.6.0
15:37:33 <frerich> mgsloan: I feel kinda stupid for not considering that my version might be plain outdated and hence the documentation I'm looking at doesn't apply. :-[ Thanks for pointing that out!
15:37:51 <mgsloan> No worries, you're welcome!
15:46:02 <parsnip> hmm, emacs is a little weird with it's defaults? http://sprunge.us/ERPP?hs
15:47:07 <monochrom> you can press <tab> a few times to get alternative alignment points
15:47:52 <parsnip> monochrom: oh of course. i thought i tried that, guess not >.<
15:48:01 <parsnip> thank you
15:48:17 <monochrom> although, line 3 is a be strange. I don't know why it is the first alignmnent point offered. and I probably can't reproduce it.
15:49:53 <monochrom> in fact, in my emacs, the first offers are all at the same column for lines 2-4.
15:50:09 <Welkin> is there something like replicateM that I can use to collect the result in a tuple?
15:50:15 <Welkin> results*
15:50:38 <Welkin> > replicateM 4 getLine
15:50:40 <lambdabot>  <IO [[Char]]>
15:51:08 <monochrom> can you write down a type for the function you desire?
15:51:35 <Lokathor> Welkin, since tuples are each their own type for each length even with all the same element types, you'd have to write each one custom
15:51:43 <Welkin> well yes
15:51:55 <Welkin> I can also just use this
15:52:00 <Lokathor> but you could write some helpers, toFourTuple :: [a] -> (a,a,a,a) or something
15:52:15 <Welkin> (a,b,c,d) <- (,,,) <$> g <*> g <*> g <*> g
15:52:18 <Welkin> which works
15:52:40 <Welkin> but has too much repetition
15:52:44 <Lokathor> now that's the applicative stuff I like to see
15:53:09 <monochrom> I would not shy away from [a,b,c,d] <- replicateM 4 getLine
15:53:21 <frerich> mgsloan: A-ha! With a more recent stack version, everything works just fine.
15:54:19 <parsnip> monochrom: okay yeah, i'll experiment with emacs -q etc later, but this will work for now; want to dive in as quick as i can. 
15:54:34 <parsnip> thank you
15:54:42 <monochrom> you're welcome
15:58:49 <monochrom> hrm, replicateM does not need full Monad, right? because sequenceA (replicate n x) will do.
16:01:08 <tommd> tmux at
16:01:10 <tommd> oops
16:02:43 <lmj> After installing ghc and cabal from scratch (just for the adventure, I guess), there were weird problems. (1) ghci had the random package, but the compiler didn't; (2) I had to register random manually with ghc-pkg and the conf file I found in .ghc/
16:03:45 <lmj> If that's unexpected I can file a bug, but I get the feeling manually registering packages might be required for some reason?
16:04:34 <lmj> this was after "cabal install random"
16:06:03 <haskellistight> this is so epic
16:09:46 <Darwin226> Has anyone ever gotten cabal repl to work when your project contains c/++ files?
16:15:19 <c_wraith> lmj: how was GHC installed? System-wide, or user-local? 
16:16:06 <c_wraith> lmj: I generally find user-local installs to be more reliable, about that sort of thing. 
16:16:51 <lmj> c_wraith: it was install with --prefix=/home/me/...
16:16:56 <lmj> *installed
16:17:12 <c_wraith> Well so much for that theory. :) 
16:21:58 <lmj> c_wraith: one thing that may be different about my install steps is that I didn't configure cabal with the --user flag, but just gave the same prefix I gave to ghc.
16:23:07 <Sindriava> Are there things not representable by numbers?
16:26:39 <nshepperd> how odd, there's a replicateA, but only in Data.Sequence
16:27:19 <nshepperd> no replicateA for lists
16:29:42 <nshepperd> Sindriava: apart from things that are infinitely big, I don't think so
16:30:36 <Sindriava> nshepperd: I'm talking about *any* things. I'm having hard time imagining anything that's not enumerable somehow, but infinite things are a good start, I guess
16:30:47 <Sindriava> nshepperd: I was thinking more of paradoxical definitions and so on
16:31:50 <Lokathor> there doesn't appear to be a windowing toolkit that's easily setup on windows
16:31:53 <Lokathor> how sad
16:31:58 <lmj> Sindriava: the real numbers are not enumerable
16:32:00 <nshepperd> well, anything you can write down, you can turn into a number by the usual binary encoding...
16:32:54 <Sindriava> lmj: Why not? You assign every real number to itself and bob's your uncle
16:33:03 <nshepperd> I assumed that by numbers here you meant integers
16:33:11 <Sindriava> Oh, nope
16:33:15 <Sindriava> Numbers in general
16:33:37 <Sindriava> I guess enumerable isn't the best word to use for that
16:34:05 <nshepperd> well, it's impossible to do things with real numbers in general, since our computers run on integers
16:34:20 <nshepperd> but there's always the power set of real numbers
16:34:39 <Darwin226> So I have this package for which I can't get 'cabal repl' and 'cabal run' to work properly. Where's the best place to put it so others can try?
16:34:42 <Sindriava> I wasn't talking necessarily about computers, just in general…
16:34:51 <Sindriava> nshepperd: But still, thanks ^^
16:34:51 <Lokathor> 2 is an integer and also a real number :3
16:35:09 <lmj> Sindriava: a real number has no successor
16:35:09 <nshepperd> having a cardinality strictly greater than the real numbers, and therefore some subsets of the real numbers can't be corresponded to a real number
16:35:25 <lmj> floats do, but reals don't
16:35:59 <Sindriava> lmj: As I said, "enumerable" might have been the wrong number to use, since it's already a word for something else.
16:36:06 <Sindriava> nshepperd: That's a good point.
16:36:27 <Sindriava> nshepperd: But you can pretty easily define it and then convert that definition into numbers?
16:36:38 <Sindriava> nshepperd: Or am I being silly/
16:36:39 <Sindriava> ?
16:36:57 <nshepperd> well, there are subsets that you can't define
16:37:11 <nshepperd> because there's just too darn many of them
16:37:59 <Denommus> What really blew my mind was that rational numbers ARE enumerable
16:38:30 <lmj> Sindriava: you mean representing the axioms of real numbers in software? Yes there are theorem provers that do so.
16:38:53 <hdgarrood> @pl \a b c -> f <$> g a b c
16:38:54 <lambdabot> (((f <$>) .) .) . g
16:40:50 <Denommus> @pl \a b c -> fmap f $ g a b c
16:40:50 <lambdabot> ((fmap f .) .) . g
16:43:19 <Denommus> @pl \a b c -> g a b c & fmap f
16:43:19 <lambdabot> flip flip (fmap f) . ((flip . ((&) .)) .) . g
17:04:05 * hackagebot cayley-dickson 0.1.2.0 - Complex numbers, quaternions, octonions, sedenions, etc.  https://hackage.haskell.org/package/cayley-dickson-0.1.2.0 (lmj)
17:15:52 <Darwin226> If anyone's got a second to take a look at my question, I'd appreciate it
17:15:53 <Darwin226> http://stackoverflow.com/questions/33684369/cabal-repl-causes-ghc-panic-on-simple-project-with-c-files
17:18:13 <RedNifre> Good evening. 
17:18:43 <RedNifre> I was wondering, what's the most advanced Haskell programming tool available right now? 
17:18:53 <parsnip> monochrom: if you do C-h m in haskell mode, do you see haskell-indent, or haskell-indentation in list of minor modes? when i switch to the latter, RET does something more expected. 
17:19:01 <tabemann> what od you mean by "most advanced Haskell programming tool"
17:19:04 <tabemann> *do
17:19:04 <parsnip> originally it was the former. 
17:19:41 <RedNifre> Currently I use vim, I miss IntelliJ and I heard that emacs might be good for Haskell. 
17:20:22 <dmj> RedNifre: by tool are you referring to 'haskell text editor' ?
17:20:26 <RedNifre> I wrote a tiny project in Haskell so I now see how great the language is but I do wonder about the tools. 
17:20:32 <tabemann> I'm used to editing Haskell with haskell-mode in emacs; I tried editing it with yi, but I didn't really like it
17:20:49 <RedNifre> Well, everything related to get something going in Haskell. 
17:21:35 <RedNifre> For package management I like cabal with sandboxes, but yes, I'm looking for an IDE. 
17:22:13 <kadoban> RedNifre: 'stack' is a really big improvement over cabal with sandboxes
17:22:19 <tabemann> there isn't really an IDE for Haskell; Haskell is normally edited with text editors
17:22:49 <sm> there's leksah and several haskell plugins for intellij 
17:22:57 <Linx> need help with a logo im creating for my fathers business anyone willing to help ?
17:23:05 <RedNifre> Yeah, I heard about stack, though I want the IDE sorted out before I start another project. 
17:23:23 <dmj> RedNifre: haskell-mode for emacs has a nice 'send to repl' feature. I think you can use stack-ide w/ it as well
17:23:31 <RedNifre> sm do you use those? 
17:23:59 <sm> no, I failed to get them working well
17:24:21 <sm> but I have heard of some happy users
17:24:54 * tabemann wasn't aware of leksah existing
17:25:05 <RedNifre> So how do you people edit Haskell code? How do you rename a type constructor or function in the entire project? Find usage? Step through an execution in a debugger? 
17:26:40 <sm> most probably do these with emacs or vim, tags and/or grep. The emacs haskell mode can drive the GHCI debugger, but very very few people use that
17:26:50 <Sonolin> vim + ag + fzf :)
17:26:53 <gfixler1> RedNifre: my Haskell ends up so small that usually usage is in only a few small files, and I just jump through them in Vim in a few seconds.
17:27:07 <dmj> RedNifre: I don't really debug. Use the 'silver searcher' (ag) for finding things. I think haskell-mode has some built in stuff that's useful for that. But yea, emacs for everything
17:29:18 <RedNifre> Hm. So you're saying that the quality of the language offsets the inferiority of the tools so that developing in Haskell is still a good idea? 
17:29:22 <dmj> RedNifre: haskell takes allocation and mutability out of the picture (unless you're doing FFI stuff / concurrency), and the strong typing usually gives you a program that 'just works' if you compile it. Learning the types just takes time
17:29:23 <jophish> Darwin226: github?
17:29:43 <sm> RedNifre: yes, generally
17:30:18 <gfixler1> RedNifre: yep
17:30:40 <gfixler1> RedNifre: anecdote: joined a C# program at work, spent 2 hours reading 35 lines of 7-level deep nested code
17:30:43 <jophish> neovim+plugins makes a pretty snazzy haskell environment
17:30:51 <gfixler1> RedNifre: realized at the end that all of it was a tiny one-liner in Haskell
17:31:01 <gfixler1> map doThing listOfThings
17:31:03 <RedNifre> dmj I noticed, my exploratory project ended up having medium complexity but even though I only have basic Haskell knowledge it just worked and was easy to understand. Hm... 
17:31:12 <gfixler1> the hoops they were jumping through..
17:31:21 * sm wonders how do we get jetbrains to knock out a haskell IDE
17:31:34 <gfixler1> RedNifre: you could also just change the constructor and run it, and let it tell you what broke :)
17:32:24 <gfixler1> also, I tend to like to run searches over every Haskell thing I've written, not just the current project
17:32:37 <gfixler1> then I learn things, like tha I'm using something in 5 other places, and I change my mind about renaming it, maybe
17:32:47 <gfixler1> and such searches take a fraction of a second
17:32:51 <gfixler1> no thick IDE in my way
17:33:26 <Guest16505> sm: you know there is an unofficial plugin for idea right?
17:33:42 <sm> Guest16505: yes, I mentioned there were a couple
17:33:43 <platz> the clojure people still built Cursive, which allows things like global rename 
17:33:57 <platz> they didn't have to build that - it was a new ecosystem
17:34:11 <sm> Guest16505: did you get one of them working well ?
17:34:19 <RedNifre> gfixler I know, but IntelliJ's code aware rename means that I change the name of anything as soon as I come up with a better alternative. In Haskell I tend to think "well, I COULD rename that to make it more consistent with the name of that other thing... but that would be tedious and the name is not really wrong.."
17:34:26 <platz> I'd love to be able to do a global rename across an entire project
17:36:19 <scottj> RedNifre: HaRe for emacs, no clue how good it is
17:36:31 <scottj> https://github.com/alanz/HaRe
17:37:05 <sm> M-x tags-query-replace is pretty quick
17:37:48 <platz> i suppose tags do give some support
17:38:15 <sm> hasktags is a haskell-specific tag file generator (not sure why, but it's there)
17:38:19 <platz> if one knows how to generate them without much effort
17:38:32 <RedNifre> Ah, HaRe looks interesting, thanks for that. 
17:39:03 <Guest16505> sm: nope, i dont have time to use haskell a lot. but i think currently our only hope for intellij is some community effort.
17:39:43 <RedNifre> The clojure IntelliJ version is actually commercial I think. 
17:40:32 <RedNifre> It's not done by jet brains itself, it looks like some clojure users built their own IntelliJ plugin and plan to make money. 
17:40:42 * tabemann would prefer that a Haskell IDE not be commercial; do you know how much an IntelliJ Ultimate license costs?
17:41:01 <RedNifre> No, how much? 
17:41:25 <sm> even though I'm a lifetime emacs user, I will happily pay jetbrains if they bring out a haskell IDE
17:41:40 <Guest16505> well someone has to get paid or work for free (tautology of the day)
17:42:20 <Guest16505> yeah ive been using vim for many years, but for static languages i really like intellij
17:42:48 <tabemann> a single user license for IntelliJ Ultimate last time I checked costed $199.00, but they've changed their pricing structure since then
17:42:48 <sm> I've been using phpstorm, it's fricking awesome
17:43:31 <Guest16505> yeah i use intellij for my daily es6 work. its pretty good at working with what little its got. still hoping i will be able to move over to typescript eventually.
17:43:46 <tabemann> note that there is a watered-down version of IntelliJ that is gratis
17:44:22 <sm> intellij IDEA community 
17:44:23 <scottj> tabemann: yeah, and if there were a third-party commercial haskell plugin (like the clojure one Cursive) then it could run on that the pricing would be up to the third-party not Jetbrains 
17:44:24 <sm> edition
17:44:30 <RedNifre> Guest why do you use ES6 instead of typescript, purescript or ghc js? 
17:45:50 <Guest16505> RedNifre: i joined the project after it started and i dont have the required experience with purescript or ghcjs. typescript was too immature at the time, though its getting better.
17:46:01 <RedNifre> Scottj that would be great, I'd happily pay extra for a third Patty Haskell plugin. 
17:46:18 <scottj> if Jetbrains were to make a haskell version, it would likely be priced $59-89 not the same price as IDEA Ultimate
17:46:19 <Guest16505> if i havent battle tested the language i would be too afraid to bring it in for a commercial project.
17:46:25 <scottj> ^ per year
17:46:39 <Guest16505> typescript still suffers from the npm problem.
17:46:54 <RedNifre> What's the npm problem? 
17:47:10 <Guest16505> it can at least read header files from npm modules now, but most modules havent realized they need to provide a header file yet.
17:47:40 <Guest16505> there might be some hacky workaround that i didnt try
17:48:03 <Guest16505> like defining a custom npm_require that prefixes node_modules or something but i doubt it would cover all cases
17:48:29 <RedNifre> (I only have limited experience with js, I wrote one database thingy with node, CoffeeScript, Ramda, Bluebird promises (basically IO Monad) and a custom do notation I made) 
17:49:40 <Guest16505> ugh coffee
17:50:03 <Guest16505> many years ago when i still thought ruby was cool i thought coffee seemed awesome
17:50:08 <RedNifre> Speaking of other languages, using the same language on the server and the client would be convenient. Unfortunately, for me, client means android which limits the options somewhat. Has anyone tried out Frege yet? 
17:50:22 <Guest16505> now i can just see a js with syntactic sugar that adds a compilation phase but doesnt provide type checking
17:51:13 <haskellistight> can anyone here help me with a quick haskell question?
17:51:26 <RedNifre> Sure, it's just a nicer way to write js. But this is crucial when dealing with monads, those are just way too verbose in the original js syntax IMHO. 
17:51:35 <dmj> haskellistight: yea
17:52:59 <RedNifre> I mean, Frege being a Haskell for the JVM sounds exciting, on the other hand it's not even practical to use Scala on Android because of some silly technical limitations. 
17:53:02 <haskellistight> messaged you dmj
17:53:21 <RedNifre> Oh secret Haskell questions, huh? 
17:53:22 <dmj> haskellistight: it'd be better to ask your question here, where more people can see it
17:53:36 <haskellistight> oh I'm an IRC scrub lol, haven't used IRC since I was a teenager
17:53:46 <haskellistight> i'm trying to filter out whitespaces of a parsing expression
17:54:15 <Guest16505> RedNifre: there is supposed to be some jvm backend for purescript
17:55:11 <RedNifre> I haven't used purescript yet, is it just a compromise or is it a viable alternative to Haskell? 
17:55:28 <dmj> haskellistight: yes
17:55:44 <CoconutCrab> dmesg
17:55:51 <haskellistight> I want to filter out whitespace in this function declaration: parser = litParse `alt` varParse `alt` opExpParse and I placed filter (/=' ')  after the function equals sign and it spits out tons of errors 
17:56:24 <haskellistight> like so: parser = (filter (/=' ') parser = litParse `alt` varParse `alt` opExpParse)
17:56:40 <CoconutCrab> ops, sorry, wrong windows
17:56:44 <davidar> :/
17:56:48 <dmj> haskellistight: can you paste your code on lpaste.net
17:56:50 <dmj> @wher paste
17:56:50 <lambdabot> Maybe you meant: where where+
17:56:55 <haskellistight> yeah I will paste real quick
17:56:55 <dmj> @where paste
17:56:56 <lambdabot> Haskell pastebin: http://lpaste.net/
17:56:59 <davidar> parser = filter (/=' ') $ litParse `alt` varParse `alt` opExpParse
17:57:30 * DanC__ resumes his quest to get flycheck working with haskell in a sandbox
17:57:32 <davidar> assuming that's a string, which it probably isn't :/
17:57:45 <haskellistight> yeah it's not a string :/ http://lpaste.net/145151
17:58:51 <RedNifre> I don't understand the code but if it's LIKE a a string you might get it to work by enabling ghc's overloaded strings. 
18:01:14 <Guest16505> RedNifre: i still havent tried it seriously myself either, but it seems promising. cant be worse than js at least.
18:01:18 <haskellistight> the code is mostly from parsing expressions in the craft haskell FP book
18:03:11 <RedNifre> Guest yeah, but if I decided that Haskell should be my one true language I would prefer to use it wherever I can so that I don't have to do all that context switching (e.g. Remembering that purescript is eager) 
18:04:30 <RedNifre> Haskell on the server works great, I heard that ghc js works okay as well but I still wonder what I should do about android. 
18:06:16 <RedNifre> At least jet brains developed Kotlin which is a slightly better Java (sane lambda syntax and functors and monads) but the type system just doesn't compete. 
18:06:56 <RedNifre> Hm.... 
18:07:15 <RedNifre> Does native Haskell compile to arm processors? 
18:08:53 <tabemann> IIRC GHC does have some support for ARM but I'm not sure how complete it is; e.g. I know GHCi, last time I checked, didn't support ARM
18:08:58 <RedNifre> I wonder if you could compile a Haskell binary complete with a database to run on an android phone as a local server and have a regular android app just talk to it. 
18:09:50 <RedNifre> Eh, it's probably not worth the complexity anyway. 
18:10:02 <pavonia> haskellistight: You cannot use filter with the Parse values, but you probably can filter the spaces before you pass the input to your parser function
18:10:12 <Clint> RedNifre: look at what joeyh does with git-annex
18:10:30 <RedNifre> Will do. 
18:10:46 <Kaidelong> Data.Number.Symbolic is kind of terrible, is there something better?
18:11:07 * tabemann would just use something else on Android; of course, he tends to be of the view that one should select the language for the task rather than trying to apply the every-problem-is-a-nail approach
18:11:19 <Kaidelong> also, if there isn't, I might try to implement it, who should I ask for help?
18:11:46 <RedNifre> tabemann maybe, maybe not. I'm torn on this question. 
18:12:06 <tabemann> (of course, then, for most applications Haskell *is* the ideal language unless one is trying to squeeze out the last cycle of processor time or byte of memory)
18:12:23 <Guest16505> RedNifre: yeah Kotlin sounds much better than Scala too I think
18:12:54 <tabemann> (even for concurrency Haskell is much better than even straight C)
18:13:13 <RedNifre> tabemann the problem is that when I use a language that is well suited I sometimes miss the features of another language. The only language where that doesn't happen is Haskell (except that I miss IntelliJ) 
18:13:21 <Kaidelong> (the features I'd like is the use of a source of unique identifiers to turn lambda exprs into symbolic expressions and the use of subtyping rather than an ADT to distinguish constants from expressions that vary in a variable)
18:14:07 <RedNifre> Guest I'm not sure it's better than Scala. I haven't used Scala yet, but I heard its type system is much better. 
18:14:15 <Lokathor> tabemann, and who ever else wanted to know about ARM
18:14:21 <Lokathor> you have to get GHC 7.10.3
18:14:28 <Lokathor> there's a release canidate 1 available on the website
18:14:39 <Lokathor> https://downloads.haskell.org/~ghc/7.10.3-rc1/
18:14:46 <RedNifre> For example, in Kotlin you have no self type so you have to hack it by defining a recursive type. 
18:14:54 <Lokathor> RedNifre, you i guess
18:15:12 <RedNifre> Which works, but then I couldn't figure out how to do a type constructor. 
18:15:17 <Kaidelong> also am I right to intuit that the free structure you get from a boolean algebra is a set?
18:16:18 * tabemann doesn't get those deliberately use inferior languages just so they can use the JVM
18:17:25 <tabemann> it's not like you're doing it because you're constrained in the area of bytes, cycles, or realtime-ness, but just because "oh there's so many libraries therefore I *have* to use the JVM just because I could just possibly use them sometime"
18:17:29 <Lokathor> tabemann, i do. here's an example good point: the windowing toolkit actually just works for you
18:17:45 <RedNifre> tabemann the android api is completely tailored to Java, while you CAN write your app in a compiled language it would not be practical (except for games) 
18:18:15 <Lokathor> haskell + windows OS + windowing toolkits = basically never works
18:18:55 <tabemann> RedNifre: but Android is the exception to that, but a lot of people are using languages like Scala just because they can use the JVM, even though there are superior alternatives
18:19:42 <Lokathor> tabemann, i think a lot of the time it's infastructure compatibilty reasons, "you can use anything that compiles into .class files"
18:20:23 <RedNifre> tabemann so I heard. But that's not my reasoning. 
18:20:43 <Lokathor> that's part of why there's elixer, after all
18:21:08 <RedNifre> It's also the reason why I haven't used Scala yet: On Android, there are some technical difficulties and on the server I can just use Haskell. 
18:21:50 <RedNifre> Lokathor I thought Elixir ran on the beam vm? 
18:22:16 <Lokathor> right, but it was delibterately made for the beam VM to take advantage of that VM's nice systems
18:22:40 <Lokathor> like how scala/jython/jruby/etc are on the JVM to try and share in having the big library of java
18:22:54 <Lokathor> ironpython/F#/etc with cli
18:23:16 <RedNifre> Lokathor I thought it was a more pleasant way to write Erlang, similar to how CoffeeScript is a more pleasant way to write Javascript? 
18:23:53 <Lokathor> well, I've only dabbled in erlang, and i only looked at some example pages of elixer, but the elixer made my eyes hurt
18:24:21 <Lokathor> erlang is easy to get used to, elixer looked too busy
18:24:30 <Kaidelong> Elixer compiles to Erlang but I don't know if that counts as it just sugar over Erlang the way CoffeeScript is over JavaScript
18:24:56 <Kaidelong> Curry and Cosmos both transpile to Prolog, for example, but you wouldn't compare either to it
18:25:17 <Kaidelong> Haskell transpiles to JavaScript (potentially), etc
18:25:53 <Lokathor> Kaidelong, perhaps you'd know this, could you compile non-haskell languages into Core and then run those through GHC's final stages as a compilation system?
18:25:54 <RedNifre> I like how real world ready Erlang seems to be but I'm not sure I like dynamic typing for large projects. 
18:25:58 <Lokathor> would it give useful results?
18:26:22 <Kaidelong> You could do that
18:26:26 <Kaidelong> I don't know if anyone has
18:26:31 <Lokathor> RedNifre, "real world ready" is kinda understating the fact that like 40% of cell phone taffic goes through an erlang phone system
18:26:50 <Kaidelong> C-- might be a better target than Core depending on what you are after, though
18:26:52 <DanC__> I'm looking for String -> Data.ByteString.Lazy.ByteString
18:27:01 <DanC__> hoogle says Parse error: (line 1, column 16): unexpected "B" Bad symbol
18:27:17 <tabemann> back
18:27:39 <tabemann> I'm looking at Elixir, and I don't get what one'd get out of it vis-a-vis Erlang
18:27:45 <Kaidelong> also arguably if you're going to target core you might as well just target Haskell since Haskell can give you pretty precise control over what core gets generated
18:28:04 <Kaidelong> similar argument goes for targeting C rather than assembler
18:28:17 <tabemann> Elixir just looks like Erlang with slightly different syntax
18:28:24 <RedNifre> Knowing Ruby I think the Elixir syntax is nicer. But that's probably just personal taste. 
18:28:46 <Kaidelong> sounds like you are in the target demographic
18:29:33 <RedNifre> I'm not sure, I'm somewhat biased against dynamically typed languages when it comes to large projects. 
18:29:41 <Lokathor> Kaidelong, i was just wondring for say, a scheme compiler. there's that "write yourself a scheme in 48 hours" haskell guide. Just musing over how far one could take it
18:29:53 <RedNifre> ... Though I have no experience to justify that view... 
18:29:55 <Kaidelong> from what I know, Elixer's raison d'etre is for the situation where you have a Ruby code base that doesn't scale
18:30:03 <Kaidelong> so you need to port your Ruby code to something else
18:30:34 * tabemann wouldn't use Erlang unless he was working on a preexisting Erlang project just because he likes Haskell's concurrency model better
18:30:44 <RedNifre> Then I'm not the target demographic since I strictly use Ruby for tiny scripts that don't have to scale. 
18:31:05 <Lokathor> i just don't like the sigils in ruby
18:31:44 <RedNifre> tabemann really? I thought the Erlang concurrency model is regarded as one of the best? I haven't done concurrency in Haskell yet, how is it better? 
18:31:51 <Kaidelong> gtg
18:31:55 <tabemann> RedNifre: it's that I don't like the actor model
18:32:16 <Lokathor> RedNifre, erlang's concurrency system can be emulated (rather well but not perfectly) in Haskell if you want to
18:32:22 <Lokathor> but haskell can also do other things
18:32:28 <RedNifre> tabemann it seems robust, what's wrong with it? 
18:32:53 <tabemann> e.g. in my current project I am basing it based on threads listening to events generated by other threads... but mind you each thread can simultaneously listen to events from multiple places than's to STM's orElse, whereas you can only listen to things sent specifically to you in Erlang's actor model
18:33:00 <RedNifre> Lokathor what do you mean by sigil? 
18:33:24 <Lokathor> RedNifre, the punctuation on variables depending on if they're class variables or such
18:33:50 <tabemann> the use of TChan with STM in Haskell allows the implementation of broadcast events
18:35:36 <Lokathor> tabemann, i'm going to have to write a multi-channel chat server rather soon. Would two TChan for each user be too much? I was thinking one for inbound and one for outbound
18:35:44 <RedNifre> Aren't broadcasts like Intercal's "come from" statement i.e. reverse goto? :) 
18:35:48 <tabemann> as Lokathor mentions, the currency model in Haskell is more general than that in Erlang
18:36:11 <tabemann> Lokathor: for inbound I would use a TQueue
18:36:33 <tabemann> TQueue has better performance than TChan but isn't capable of broadcast unlike TChan
18:36:43 <Lokathor> tabemann, i'll note that in this particular setup, there's more than one channel active, but each user can only be joined into a single channel at a time
18:36:58 <Lokathor> i'm not sure if that would call for a different design or not
18:36:58 <RedNifre> I used broadcasts once, I'm not convinced it's a good concept. Isn't it very far away from functional programming conceptually? 
18:37:39 <tabemann> my project, an IRC client, is essentially not written functionally
18:38:04 <RedNifre> Why not? 
18:38:12 <Lokathor> I might end up with something gross like a TVar (Map ChannelName (TVar ChannelUserList))
18:38:19 <tabemann> because it maintains large amounts of state through STM
18:39:40 <RedNifre> Ah gotta go. Thanks for the talk and have a nice day/night. 
18:39:46 <Lokathor> RedNifre, http://chimera.labs.oreilly.com/books/1230000000929/index.html
18:39:49 <Lokathor> bookmark that
18:39:54 <tabemann> yes
18:40:11 <tabemann> that book tells you basically everything you need to know about concurrency in Haskell
18:41:12 <tabemann> (in this case I'm not using Haskell for functional programming - I'm using Haskell for concurrency)
18:41:12 <RedNifre> Thanks, bookmarked. Bye! 
18:41:43 <Lokathor> I usually like using haskell as the best imperative langauge out there
18:41:50 <Lokathor> in addition to all the functional stuff
18:43:32 <tabemann> hmm I've got a question - why does Clojure, at least last time I checked, lack orElse and retry?
18:43:55 <tabemann> since in Haskell orElse and retry makes STM infinitely more powerful than it would be without them
18:50:07 <c_wraith> tabemann: That's weird.  Clojure's STM is more consistent than GHC's, aside from that.  And of course aside from being unable to statically prevent side effects.
18:51:18 <c_wraith> (consistent in this case meaning that it gets transactions fully serializable where GHC sometimes allows... something.. to go wrong.  I think GHC gives you the equivalent of read committed)
18:51:35 <tabemann> it's more consistent than GHC's? last time I checked you had to do more work to ensure consistent state across threads due to it's use of MVCC
18:51:36 <tabemann> *its
18:54:10 <tabemann> i.e. you have to know when to explicitly use ensure with Clojure
18:54:21 <tabemann> (whereas in GHC there is no need for such a thing as ensure)
19:24:26 * hackagebot latex-formulae-hakyll 0.2.0.0 - Use actual LaTeX to render formulae inside Hakyll pages  https://hackage.haskell.org/package/latex-formulae-hakyll-0.2.0.0 (LiamOConnorDavis)
19:37:24 <haskell283> I want to ignore TLS certificate check in wreq, how would I do that?
19:39:56 <haskell283> I want to do it for testing purpose, I tried by creating a manager with TLSSettings with settingDisableCertificateValidation to True
19:40:44 <haskell283> but I still get HandshakefailedException with ProtocolError "certificate rejected: [NameMismatch "server_name"]
20:06:48 <haskellistight_> hey guys, how do I check if a monad is equal to nothing? can I use the == operator?
20:07:31 <pingu_> haskellistight_: you mean two values within a common monad?
20:07:41 <pingu_> like, m a -> m a -> Bool?
20:07:45 <Axman6> that question doesn'ty make much sense
20:08:23 <haskellistight_> yeah let me make it more clear
20:09:16 <haskellistight_> I am implementing the store abstract data structure in haskell, so each store contains a value mapped to a key where only one value can be mapped
20:09:56 <haskellistight_> I am writing a function to merge two "stores" together by checking the keys in each store and making a third store that uses one key or the other, or nothing
20:11:29 <glguy_> ?paste
20:11:29 <lambdabot> Haskell pastebin: http://lpaste.net/
20:11:55 <glguy_> It'll help if you can post some code to show what you're doing
20:12:01 <haskellistight_> wait actually I just figured it out
20:12:25 <haskellistight_> I know I'm probably acting super weird to all you haskell gurus, but I'm really trying to get this language under my belt lol
20:12:32 <haskellistight_> project euler is 1000000x easier with it :)
20:17:43 <fread2281> is there a tool that will monadify code? that is, if i change f : a -> .. -> b to f : a -> .. -> m b, i want it to fix all the callers of f
20:20:33 <Ralith> what does "fix" mean
20:22:12 <fread2281> wrap their return type in m (unless its already m) and somehow make it compile
20:34:11 <KaneTW> why do you want to do that
20:35:13 <fread2281> I'm trying to use unbound with meta vars (which are implemented usually with ST, I'm trying lvish)
20:35:32 <fread2281> and the aeq should expand metas
20:36:08 <fread2281> so I need to monadify unbound :(
20:38:35 <fread2281> and of course aeq should also constrain metas
20:39:30 <joneshf-laptop> what's the state of ghc on these arm boards like beaglebone and rpi?
20:39:54 <joneshf-laptop> the wiki doesn't seem to provide very in depth information.
20:40:35 <bitemyapp> joneshf-laptop: Stack + 7.10.3 supports RPi I think. Just found that out from Lokathor. (did I get that right?)
20:41:23 <joneshf-laptop> bitemyapp, nice
20:44:30 <fread2281> would using LVars (single-update, subsequent updates error if != existing value, get blocks until value) and lots of forking work for metavariables?
20:46:45 <broma0> I'm having some trouble with Aeson and UTCTime's.. the code here (http://lpaste.net/145155) shows (decode (encode x)) resulting in Nothing when a UTCTime is wrapped in a record. I cant figure out why.
20:46:51 <broma0> Any ideas?
20:46:51 <Lokathor> joneshf-laptop, https://downloads.haskell.org/~ghc/7.10.3-rc1/ you want to get ghc from here
20:47:01 <Lokathor> and you'll need a raspberry pi 2
20:47:10 <fread2281> i.e. would it fix the invalid terms issue with correctly-placed forks?
20:47:12 <Lokathor> and of the rpi 1 editions won't work i think
20:49:29 * hackagebot Lambdajudge 1.0.0.4 - A library to easily host Haskell based programming competitions  https://hackage.haskell.org/package/Lambdajudge-1.0.0.4 (ankitku)
20:54:35 <glguy> broma0: I don't think that the ToJSON instance for UTCTime is actually valid
20:58:25 <glguy> https://github.com/bos/aeson/issues/313
20:59:57 <broma0> glguy: got it. thanks
21:08:33 <lpaste_> fread2281 pasted “ambiguious types ?? ” at http://lpaste.net/145157
21:08:40 <fread2281> ^
21:09:15 <lpaste_> fread2281 revised “ambiguious types ?? ”: “No title” at http://lpaste.net/145157
21:10:03 <glguy> fread2281: there's an 'f' in your context that doesn't appear in the type outside of the context
21:10:18 <glguy> probably change it to a 'g'
21:10:23 <glguy> on line 14
21:10:44 <dfeuer> That usually doesn't work too well.
21:11:37 <fread2281> glguy, GAlpha is class GAlpha f c
21:12:01 <glguy> fread2281: That doesn't matter, the f needs to appear in the method tyep
21:12:12 <glguy> If it can't then you can't do that
21:15:58 <glguy> fread2281: ignoring your default implementation, 'f' doesn't appear in the type signature for fvAny' at all
21:16:19 <glguy> Are you expecting to pick an instance solely based on 'a'?
21:18:56 <fread2281> ah yep, fundeps/TFs would work, thanks
21:19:21 <glguy> are you sure that 'f' should even be a class variable?
21:21:01 <athan> fread2281: They let you know that your input types resolve to a single, unique output type, thus eliminating ambiguity.
21:21:50 <fread2281> yes. this is from unbound, I'm playing around with metas, aeq etc should be able to read them here
21:24:25 <fread2281> and with TFs I would need to use Identity instead of m for most things, so lots of Composes, which is probably more correct, but more painful
21:29:19 <athan> Is there another package for urlencoded data other than urlencoded?
21:29:29 <athan> I'm just looking for a parser, really. Maybe an attoparsec one?
21:32:55 <athan> Or maybe a form-creating / urlencoded parsing isomorphic thing?
21:33:02 <athan> Like digestive-functors maybe?
21:33:26 <Axman6> what are you actually trying to do?
21:34:25 <athan> Axman6: Parse urlencoded data on the server, for form data
21:34:38 <athan> I see the urlencoded package, but failure is delayed until lookups
21:35:11 <athan> I'm ideally looking to make a parser for a specific type, like ToJSON and FromJSON do
21:35:34 <Axman6> that should be handled automatically by most libraries already
21:36:33 <athan> Axman6: ...which libraries?
21:37:56 <Axman6> maybe I'm misunderstanding and probably can't help =)
21:38:35 <athan> crud :(
21:38:49 <athan> I think digestive-functors has a lot of tooling I haven't explored yet, though. Thanks anyway!
21:41:09 <fread2281> GHC.Generics's :+: and :*: should have at least a Functor instance
21:43:02 <synergistics> Anyone familiar with church encoding?
21:45:00 <Axman6> probably lots of people. do you have a question about it?
21:45:30 <thimoteus> is there a way to get ghci to show the type of a function immediately after i declare it?
21:46:02 <synergistics> Yep. If in church numerals, one is defined as lambda f x . f x, and zero is defined as lambda f x . x, is negative one defined as lambda f x . x f?
21:46:40 <athan> synergistics: Well, we can only implement peanos. We can do subtraction, though
21:46:50 <athan> actually wait
21:47:01 <synergistics> But I thought subtraction in church encoding could only go to sero
21:47:12 <synergistics> s/sero/zero
21:47:15 <athan> synergistics: I'm pretty sure that's the only way
21:47:24 <synergistics> athan: Hmm. Cool
21:47:26 <athan> We can't un-apply a function
21:47:37 <synergistics> athan: Are you sure?
21:48:01 <athan> synergistics: If the function doesn't have any properties we know of, then yes
21:48:03 <synergistics> Could you find the relation between the input and the output and then just reverse apply it to the input?
21:48:09 <synergistics> Oh I see
21:48:10 <athan> because the image has no relation to its domain
21:48:26 <synergistics> Image?
21:48:29 <athan> it would need to be surjective, I think
21:48:32 <athan> synergistics: codomain
21:48:38 <athan> slash result
21:49:33 <synergistics> The image is or is not the range of the function?
21:49:43 <athan> synergistics: it is
21:49:48 <synergistics> Ah ok
21:50:06 <athan> but it's more intuitive to think of it as uncorrelated to the domain, as a "picture" of what the input gave us
21:50:15 <athan> but we couldn't find what created the image
21:50:37 <athan> fread2281: Can you tell me your use case? I'd really like to see it :)
21:50:39 <synergistics> Wouldn't finding the recipricol of the image (switching x and y) give you a nature of the image
21:51:12 <synergistics> Because then you would know the relation of x to y and y to x. Are you saying those are unrelated?
21:51:13 <athan> synergistics: That's the thing, you're assuming we can find an inverse function
21:51:23 <synergistics> Oh ok I get ya
21:51:28 <athan> and you're also assuming that each output has a _unique_ input
21:51:39 <synergistics> Bijectivity?
21:51:44 <athan> Yes
21:51:49 <ReinH> Well, Kleene figured out how to do subtraction for Church-encoded natural numbers.
21:52:43 <fread2281> athan, I'm playing around with using LVars to represent metas, to see if it works nicely just aggressively forking
21:52:55 <ReinH> It's non-trivial enough that Church didn't think it was possible, so it isn't surprising if you haven't figured it out on your own.
21:54:03 <mossey> :t null
21:54:05 <ReinH> The trick is implementing pred
21:54:05 <lambdabot> Foldable t => t a -> Bool
21:54:14 <synergistics> Then what would be the nature of x f. I'm just starting to learn about mathematical logic. Is there a relation you can say that exists between f x and x f? Is it just input and output but applied to functions instead of numbers or something?
21:54:36 <ReinH> You can't count the number of f's, so you don't. Instead, you count up to the number you want the pred of and memoize the previous number seen, and then finally once you reach it, you return the memoized number.
21:54:51 <ReinH> synergistics: the nature of x f would be that it is nonsense.
21:55:25 <synergistics> ReinH: I had a feeling that would be the obvious case, but is there really no relation?
21:55:32 <ReinH> "relation"?
21:55:48 <ReinH> It's just a syntax error.
21:56:06 <synergistics> No, x is also a function
21:56:32 <ReinH> Ok, it's a semantic error.
21:56:47 <synergistics> It doesn't have to be
21:57:01 <synergistics> Depends on what types f and x work on
21:57:21 <ReinH> Well, whatever it is, it has nothing to do with subtraction.
21:57:26 <synergistics> And if they operate on their own types and they are of the same type, I don't see why any error's would exist
21:57:37 <synergistics> I'm not so sure
21:57:48 <ReinH> "x f" literally is a syntax error, so what exactly do you mean?
21:58:15 <Hafydd> How is "x f" a syntax error?
21:58:39 <athan> Hafydd: Because types are terms? :v
21:59:02 <Hafydd> > :t let x = id; f = id in (x f, f x)
21:59:03 <lambdabot>  <hint>:1:1: parse error on input ‘:’
21:59:07 <Hafydd> :t let x = id; f = id in (x f, f x)
21:59:08 <lambdabot> (a -> a, a1 -> a1)
21:59:35 <synergistics> I'm not even talking about haskell specifically though
21:59:36 <ReinH> > x f
21:59:37 <lambdabot>      Couldn't match expected type ‘a0 -> t’ with actual type ‘Expr’
21:59:37 <lambdabot>      The function ‘x’ is applied to one argument,
21:59:37 <lambdabot>      but its type ‘Expr’ has none
21:59:37 <Hafydd> athan: I don't know what you mean.
21:59:44 <ReinH> Ok, that's a bad example
21:59:46 <ReinH> > foo bar
21:59:47 <lambdabot>      Not in scope: ‘foo’
21:59:47 <lambdabot>      Perhaps you meant ‘for’ (imported from Data.Traversable)    Not in scope...
21:59:47 <lambdabot>      Perhaps you meant one of these:
21:59:59 <ReinH> What would you call it?
22:00:16 <Hafydd> That's a semantic error.
22:00:18 <athan> ReinH: A type error :P
22:00:20 <ReinH> Ok.
22:00:40 <synergistics> ReinH: I'm not sure you're getting the point
22:01:12 <synergistics> ReinH: I'm talking in the context of just lambda calculus with church encoding
22:01:15 <ReinH> Ok, x f is a valid term, but it is semantically invalid.
22:01:20 <ReinH> I already said that.
22:02:22 <Hafydd> It isn't necessarily (given a suitable context), as demonstrated above.
22:02:34 <ReinH> What is the suitable context? That's what I'm asking.
22:02:56 <Hafydd> That's an unusual way of asking it.
22:03:14 <ReinH> Ok, I give up
22:03:15 <synergistics> When two functions operate on functions of their own type and are of the same type
22:03:22 <synergistics> Or have the ability to
22:03:25 <synergistics> Like id
22:03:40 <synergistics> But I want to find more complex examples
22:03:42 <ReinH> synergistics: Are you talking about a typed lambda calculus? Because I haven't seen any indication of types.
22:03:51 <ReinH> Or is that more context that I'm missing?
22:04:35 <synergistics> Type as in a set of possible inputs or outputs from a function that act as proofs for that type
22:04:39 <synergistics> So I guess so
22:04:42 <ReinH> Ok, so type as in not type.
22:04:57 <ReinH> I don't see any types?
22:05:31 <synergistics> Wouldn't a mapping from one type to another be a type also? Meaning a function can be a type?
22:05:48 <ReinH> What types? Where are there any types at all?
22:06:17 <synergistics> I'm just talking about the context in when both x f and f x would make sense
22:06:20 <synergistics> As you asked earlier
22:06:33 <ReinH> we generally write, e.g., \x:t.e to say that x is of type t
22:06:40 <ReinH> (in the simply typed lc)
22:06:46 <ReinH> so... what types are you talking about?
22:07:19 <synergistics> What do you mean?
22:07:30 <ReinH> You keep using the word "type". I want to know what you mean.
22:07:53 <ReinH> Because I can't reconcile your usage with my understanding of the meaning of "type" in this context.
22:08:43 <synergistics> Type as in a set of possible inputs or outputs from a function that prove the specification of that type.
22:08:51 <ReinH> What does that mean?
22:09:04 <ReinH> How is it specified?
22:09:32 <ReinH> I don't see any mention of type specifiers anywhere in the backlog.
22:09:41 <ReinH> All I see is "lambda f x . f x" and similar.
22:10:32 <ReinH> So I don't understand what you mean by "type".
22:10:38 <synergistics> It would be specified by giving it properties. I'm not sure how that works in a formal sense. But an object of the type natural numbers is specified in what happens when you add two together, the successor of one, et cetera.
22:11:01 <synergistics> I'm being fairly general in my description
22:11:40 <ReinH> Ok... so do you understand that the Church encoding for the natural numbers is given in the untyped lambda calculus?
22:11:45 <ReinH> Where there are no types?
22:11:51 <synergistics> Yea
22:11:58 <synergistics> Not talking church encoding 
22:12:08 <synergistics> Just an example
22:12:18 <ReinH> So... what are you talking about?
22:12:27 <synergistics> What do you mean?
22:12:35 <ReinH> ... that's what I'm asking you.
22:12:47 <glguy> No, Who's on first.
22:13:11 <ReinH> Your very first question to the channel was "Anyone familiar with church encoding?"
22:13:19 <ReinH> So at what point did you stop talking about church encoding?
22:13:54 <ReinH> I mean, perhaps you can understand why I thought you were talking about church encoding.
22:14:01 <synergistics> When you asked in what context f x and x f would both be valid and sensical
22:14:08 <synergistics> Yea I can
22:14:34 <synergistics> After that, what I explained to you was ostensive
22:14:46 <synergistics> Not specific 
22:14:55 <synergistics> Sorry about the confusion
22:15:19 <monochrom> in the untyped lambda calculus, "f x" always makes sense, "x f" too.
22:15:21 <ReinH> So, x f and f x *per se* are just two terms with free variables x and f
22:16:03 <synergistics> No. You're being really, really literal. Look back in chat. I mean lambda f . lambda x . f x and lambda f . lambda x . x f
22:17:18 <monochrom> sure. that's even better. in the untyped lambda calculus, "lamba f. lambda x. f x" always makes sense, in call contexts. "lambda f. lambda x. x f" does too.
22:17:33 <monochrom> s/call/all/
22:17:49 <synergistics> Yea I know that. You conveyed that better than I did :)
22:17:50 <ReinH> Ok. \f.\x.fx is "one". \f.\x.xf is... something else, basically flip ($), but it isn't negative one.
22:18:00 <synergistics> Why
22:18:07 <synergistics> That's what I'm trying to figure out
22:18:16 <ReinH> Why what?
22:18:30 <synergistics> Why isn't x f negative one?
22:18:52 <athan> synergistics: because x is zero
22:18:57 <monochrom> do you feel that it should be negative one? do you use your intuition? do you extrapolate?
22:18:58 <athan> and we can only do things to zero
22:19:05 <athan> not let zero do things
22:19:07 <ReinH> How did you decide that it should be negative one?
22:19:44 <monochrom> here is the litmus test whether "\f x. x f" can be considered an encoding of negative one or not.
22:19:59 <monochrom> write a lambda term for addition. let me name it "add".
22:20:12 <synergistics> ok
22:20:15 <ReinH> (\f.\x.xf is CWK in the BCWK calculus, fwiw)
22:20:22 <ReinH> er, BCWK system
22:20:28 <monochrom> then compute what you get with "add (\f x. f x) (\f x. x f)"
22:20:42 <monochrom> do you get zero?
22:21:05 <monochrom> if yes, then you have some license to claim that (\f x. x f) works as negative one
22:21:22 <monochrom> but if not, then it can't be
22:21:50 <synergistics> Well that would be based on whether or not x and f were opposite operations wouldn't it?
22:22:02 <monochrom> what opposite operations?
22:22:32 <monochrom> IMO you are looking for an excuse to not do my litmus test
22:22:49 <synergistics> No, I'm trying to understand it
22:23:47 <monochrom> do you understand "so-called 'negative one' is a number such that 1 + 'negative one' = 0"? do you understand that basically that's the all and only criterion?
22:24:15 <ReinH> If there's a sense in which they are "opposite operations", it would be in the sense that monochrom's litmus test is true.
22:24:32 * hackagebot versions 1.0.2 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-1.0.2 (fosskers)
22:24:33 <monochrom> do you understand that if you guess you have a way to express negative one, but if fails the equation I said, then all your essay writing is BS?
22:24:36 <ReinH> e.g. add (\f x. f x) (\f x. x f) === x
22:24:47 <synergistics> I mean that x f applied to f x would have to result in x. That doesn't make sense though, so I can g
22:24:51 <synergistics> Oops
22:25:00 <synergistics> I can see why it's not
22:25:23 <synergistics> ReinH: What you said pretty much
22:25:26 <monochrom> why is it relevant to consider applying x f to f x?
22:25:46 <monochrom> no, scratch that. I'm sure it's irrelevant.
22:26:07 <ReinH> Besides, the real predecessor function is far more interesting.
22:26:08 <synergistics> Don't you define addition as applications of f?
22:26:24 <ReinH> https://en.wikipedia.org/wiki/Church_encoding#Derivation_of_predecessor_function
22:26:36 <monochrom> no I don't think so
22:27:00 <synergistics> f x == 1, f f x == 2. No?
22:27:48 <monochrom> do you really mind writing out "\f x. f f x"? is it really that much bother to write out the "\f x." part?
22:28:05 <ReinH> f^n = f . f . f ... f (n times), yes. So 0 = \f.\x.x and 1 = \f.\x.f x and so on.
22:28:31 <synergistics> monochrom: Were you able to infer what I was saying?
22:29:03 <monochrom> I mean I already don't mind abbreviating "\f. \x." to "\f x." and saving a backslash
22:29:28 <ReinH> We're talking about the lambda calculus. The lambda calculus has an incredibly simple, specific grammar. If you can't use that grammar to describe your lambda calculus terms when trying to get us to understand your questions about lambda calculus...
22:29:58 <synergistics> I can understand that, but you did.
22:30:00 <ReinH> (that grammar or its ascii approximation, at least)
22:30:33 <ReinH> Yes, because this one was obvious and I was able to infer what you meant. But that places an unnecessary additional burden on me and everyone else who you are trying to communicate with.
22:31:04 <ReinH> If you recall, a few minutes ago this conversation started with me not understanding you and wasting a bunch of time asking you to write things out explicitly.
22:32:28 <dolio> I was not able to infer what you meant, because it's impossible to tell if you're being imprecise or not understanding.
22:32:32 <monochrom> hell, even the part "f f x" is wrong. it should be "f (f x)".
22:33:09 <synergistics> That's right. Sorry for the confusion I caused.
22:37:02 <monochrom> I have provided my litmus test. you can carry it out and face its consequence. or you can evade its consequence by more essay writing that sounds good to your ears and looks good to your eyes and tells you what you what to hear but doesn't pass any test.
22:37:16 <ReinH> monochrom: (maybe the simpler route would be to attempt to show that succ (-1) = zero?)
22:37:44 <monochrom> yeah, that's shorter
22:38:11 <ReinH> Anyway it shouldn't take too long to see if you actually try it.
22:41:52 <synergistics> monochrom: I accepted that the earlier definition of -1 is incorrect
22:46:32 <Lokathor> fun generator range issues!
22:46:47 <Lokathor> might have to use a CPP setup for the first time, based on machine size
22:57:21 <fread2281> Couldn't match representation of type Identity with that of Compose (Compose (Compose Identity Identity) Identity) (Compose Identity Identity)
22:57:29 <fread2281> any way to make GHC do this?
23:03:34 <fread2281> Couldn't match representation of type a with that of Compose Identity a
23:06:32 <athan> fread2281: They're conceptually the same, not literally
23:06:43 <athan> to make them literally the same, you need to `run` the newtypese
23:33:16 <athan> Anyone know if there's a x-www-urlencoded parser for attoparsec? Something like `Parser [(ByteString, ByteString)]`?
23:38:29 <ThreeOfEight> Does anyone know whether anyone's formally proven GHC's rewrite rules sound? And by ‘formally’, I mean in a theorem prover.
23:38:56 <ThreeOfEight> And ideally also with correct handling of ⊥
23:40:47 <varaindemian> can someone explain me how does this function work what's the deal with that "n"? length = foldr (/_ n -> 1+n) 0. Didn't we have to apply / on the n too?
23:41:43 <liste> > (foldr (\_ -> \n -> 1 + n) 0) "hello"
23:41:45 <lambdabot>  5
23:42:01 <liste> \x y -> is shorthand for \x -> \y ->
23:42:41 <liste> though why is it 5?
23:42:46 <liste> > (foldr (\_ n -> 1 + n) 0) "hello"
23:42:48 <lambdabot>  5
23:45:33 <srhb> liste: What do you mean?
23:45:46 <liste> oh, nvm :D
23:45:49 <srhb> :P
23:45:52 <liste> I can't count
23:56:23 <quicksilver> ThreeOfEight: most of the rewrite rules in GHC are entirely obviously sound
23:56:50 <quicksilver> ThreeOfEight: but the answer to your question is, "No, not all in one go. You might find some in the papers they were introduced in".
23:57:58 <quicksilver> ThreeOfEight: as for correct handling of _|_, I imagine some of them aren't sound w.r.t. that.
23:58:10 <quicksilver> some of GHC's optimisation rules aren't sound w.r.t. _|_
