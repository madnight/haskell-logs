00:12:28 <solatis> jle`: which library was that?
00:12:51 <solatis> trying to find it on /r/haskell, cant find it
00:14:21 <jle`> solatis: https://github.com/bjornbm/dimensional-dk
00:14:41 <solatis> that's interesting, thanks
00:16:11 <solatis> it's a pretty neat one, too
00:18:38 <jle`> np!  dimensional analysis and unit conversions are actually one of the first things people think about when they think about typesafe programming with a strong type system
00:19:25 <sbrg> is using resolver: ghc-7.8.4 the same as using the newest snapshot that uses ghc-7.8.4?
00:21:36 <solatis> jle`: yeah, i'm actually implementing a similar library in another language and want to study how other people do it
00:22:21 <solatis> jle`: this seems like a useful guideline
00:23:29 <jle`> the approach w/ dimensions-dk and libraries using the same structure is that it's hard to add a new dimension, i think
00:24:23 <jle`> letting the user specify arbitrary dimensions/dimensions that aren't built into the library might be do-able with some sort of type level Map/symbols, but I'm not sure if the state of things is up for that yet
00:26:10 <jle`> dimensions-dk only can handle the 7 SI base dimensions, for example -- https://github.com/bjornbm/dimensional-dk/blob/master/src/Numeric/Units/Dimensional/Dimensions/TypeLevel.hs#L47-L59
00:40:57 <Reshi> quit
00:41:02 <Reshi> oops
00:46:28 <skeuomorf> Most of the examples in the 1st section here https://wiki.haskell.org/Example_code don't exist
01:20:24 <phaazon> edward: NullaryTypeClasses? what have you needing them for?
01:21:49 <indigo945> Hey. What is the memory complexity of (iterate f val) !! n  ?
01:22:04 <indigo945> And if it's O(n), is there a O(1) equivalent somewhere?
01:22:36 <phaazon> indigo945: how can you have a O(1) with iterate?
01:22:43 <indigo945> not in time, in space
01:23:07 <indigo945> Since you can discard all previous results after each iteration step, you shouldn't need O(n) stack space
01:23:31 <dramforever> indigo945: I would expect it to be O(1), assuming the values each uses O(1), but I wouldn't rely too much on it if I really need to optimize for memory
01:24:00 <dramforever> indigo945: and yes, just like how you reasoned about it
01:24:31 <jle`> there's potential memory leakage based on f, though
01:24:54 <jle`> because neither (!!) nor iterate force results as they go along
01:24:59 <dramforever> jle`: wow
01:25:04 <indigo945> Ah, space leaking, true
01:25:14 <jle`> yeah it makes me a little sad that there's no "strict !!" or "strict iterate"
01:25:15 <dramforever> indigo945: so that breaks the "assuming" part =(
01:25:34 <dramforever> :t iterate'
01:25:35 <lambdabot>     Not in scope: ‘iterate'’
01:25:36 <lambdabot>     Perhaps you meant one of these:
01:25:36 <lambdabot>       ‘iterate’ (imported from Data.List),
01:25:50 <jle`> i usually just define a one-off one when the need arises
01:25:51 <phaazon> you can easily write it though
01:25:57 <jle`> yeah
01:26:06 <jle`> striterate
01:26:32 <phaazon> with a deepseq and so
01:26:34 <quicksilver> jle`: don't really see how you would change (!!)
01:26:45 <jle`> @src (!!)
01:26:45 <lambdabot> xs     !! n | n < 0 = undefined
01:26:45 <lambdabot> []     !! _         = undefined
01:26:45 <lambdabot> (x:_)  !! 0         = x
01:26:45 <lambdabot> (_:xs) !! n         = xs !! (n-1)
01:27:04 <jle`> in the last line, you would do (x:xs) !! n = x `seq` xs !! (n-1)
01:27:27 <quicksilver> make it force the values it doesn't inspect
01:27:28 <quicksilver> interesting.
01:27:39 <quicksilver> that's not really what "strict !!" says to me :)
01:27:44 <quicksilver> but I can see it could be useful.
01:27:53 <jle`> heh, yeah, "strict (!!)" might not be the best way to describe it
01:27:59 <phaazon> or
01:28:03 <jle`> but it does the same thing as having a strict iterate in iterate f x !! n
01:28:12 <indigo945> okay, thanks!
01:28:15 <phaazon> x !!! i = x `deepseq` x !! i
01:28:33 <jle`> might not be very smart if x is an infinite list
01:28:37 <quicksilver> that would not work well with infinist lists, phaazon 
01:28:38 <jle`> which is the case for `iterate f x` :P
01:28:41 <quicksilver> and iterate will always
01:28:42 <quicksilver> right
01:28:52 <phaazon> ah, nice point
01:29:26 <jle`> even if it's not an infinite list, you could def evaluate more than you need
01:31:51 <quicksilver> this is kind of like foldl' vs foldl
01:32:07 <quicksilver> force things asap even if you won't need them for a while
01:32:13 <quicksilver> because you know you'll need them eventually
01:34:07 <jle`> @let striterate f x = x `seq` x : striterate f (f x)
01:34:08 <lambdabot>  Defined.
01:34:27 <jle`> > iterate succ 0 !! 1000000
01:34:29 <lambdabot>  *Exception: stack overflow
01:34:30 <jle`> > striterate succ 0 !! 1000000
01:34:32 <lambdabot>  1000000
01:35:26 <quicksilver> does LB have quite tight stack limits?
01:35:36 <quicksilver> because I thought GHC was quite happy with a 1M-deep stack these days?
01:36:49 <quicksilver> certainly that works fine locally
01:37:55 <jle`> i think lambdabot/mueval limits things artificially cause...it's literally executing arbitrary foreign code
01:38:07 <quicksilver> yes it puts rlimits on
01:38:16 <quicksilver> I can run the version with two more 0s locally
01:38:19 <quicksilver> takes a little while
01:38:23 <quicksilver> doesn't seem to use memory
01:38:33 <quicksilver> maybe -O2 can fix this one
01:39:30 <jle`> making it auto-strict could potentially change semantics though
01:39:32 <jle`> darn you seq
01:44:19 <jle`> imagine a world without seq
01:44:25 <jle`> it's easy if you try
01:45:34 <quicksilver> it's really easy actually. E.g. SML or ocaml.
01:45:39 <quicksilver> but there are reasons I don't use them :)
01:46:14 <quicksilver> It's awesome that GHC has an optimiser than can sometimes actually change algorithmic complexity (e.g. O(n) space to O(1) space)
01:46:32 <dramforever> gcc has one too, you know
01:46:35 <quicksilver> but the downside is it's a real blow when some refactoring of your program defeats the optimiser
01:46:37 <dramforever> "strlen"
01:46:46 <quicksilver> dramforever: :)
01:53:57 <poucet> quicksilver: know of any libraires that support serialization that preserves internal sharing
01:58:23 <latermuse> I have a concurrency problem. I have a lot of reads and relatively few writes on a TVar and its not fast enough for the reads. Any idea if switching to MVar or something will make it faster?
01:58:36 <latermuse> im using STM. will it speed up if i stop using stm?
01:59:27 <quicksilver> poucet: no. I think the cloud haskell people thought about it, I don't know where it got to.
01:59:46 <quicksilver> latermuse: I doubt it but it's worth a try. STM is normally pretty fast, unless you are causing a lot of retries?
02:00:48 <latermuse> What would cause a retry on STM?
02:00:55 <latermuse> as far as I know, I havent used the 'retry' function at all
02:01:25 <Peaker> latermuse: I think contention would cause retries (internally)
02:01:27 <dramforever> latermuse: things being read have been written to before the transaction finished
02:02:01 <dramforever> X reads A, Y writes to A, and X finishes but has to retry because A changed
02:02:06 <latermuse> I have approx 10 writes a minute with 10,000 reads a minute
02:02:48 <latermuse> feels like the process is locking during reads
02:03:22 <latermuse> this is a dev server, my prod servers peak around 100k reads a minute
02:03:24 <dramforever> looks unexpected...are you sure it isn't something else that is being slow?
02:04:28 <latermuse> I will investigate more to see if its something else or not
02:04:40 <latermuse> But the process feels locked during reads
02:04:50 <poucet> quicksilver: I guess the problem would be easier for a DAG sharing structure because at least reconstructing it is somewhat feasible
02:05:11 <dramforever> that's one of the problems of haskell...you just have to _feel_ about lots of things
02:05:27 <dramforever> because they are soooo magical
02:07:10 <latermuse> haskell profiling feels like using an oscillator to debug hardware drivers. meh
02:09:25 <frerich> I think it's true for any technology which bridges a big abstraction gap: you define things in a very abstract manner and some program does the hard work of translating this to something your CPU can process -- but it's a leaky abstraction because when profiling thiings you need to establish the reverse connection, i.e. how the generated machine code corresponds to your Haskell program. And that reverse connection needs to bridge an equa
02:09:25 <frerich> lly large gap.
02:11:58 <Peaker> frerich: some of the gap (laziness) might not be worth it (when debugging performance issues is just as important)
02:25:01 * hackagebot aeson-value-parser 0.11 - An API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.11 (NikitaVolkov)
02:31:48 <khanage> has anyone done much image processing recently? i'm kicking around reimplementing something i did for work a while ago and came across friday
02:32:00 <khanage> looks positive - does anyone have any comments on it?
02:32:18 <khanage> i'm mostly wanting to do image resizing and composition (not cv)
02:35:01 * hackagebot yesod-transloadit 0.7.1.0 - Transloadit support for Yesod  https://hackage.haskell.org/package/yesod-transloadit-0.7.1.0 (boblong)
02:35:57 <Axman6> khanage: I just spent the last few days implementing a resizing algorithm (using DCT) on top of friday, it workes really well
02:36:53 <khanage> Axman6: awesome to hear! i'm not even doing anything special, just grunt work
02:37:19 <Axman6> what sort of stuff? I've never done much with images and it made it quite easy
02:37:31 <mcveat> Hi. Noob question. When recursively applying a function `a -> IO(a)` with `>>=` do I get tail recursive execution? Or is it executed with a constant stack? I know that it is possible if `>>=` is nonstrict in second argument but I cannot find confirmation of that in documentation stackage.
02:37:44 <khanage> like literally just calling "resize" and composing images
02:38:02 <Axman6> heh right
02:39:14 <khanage> i have dreams of doing something a bit more interesting, but this is a "real world" project for noob me
02:39:28 <Axman6> mcveat: should be fine. if you want to you can look at the Core/ASM output to confirm if you like =)
02:39:43 <liste> or profile (:
02:41:42 <ersran9> hello, is typeRepFingerprint of a typeRep "constant" across runs / builds?
02:44:43 <t0by> !seen
02:45:16 <t0by> seen BONUS
02:45:22 <t0by> :(
02:46:35 <Taneb> We don't as far as I know have a bot with a !seen functionality
02:47:01 <t0by> I figured that :|
02:48:19 <Taneb> And bonus hasn't been active here for a looooong while
02:48:26 <Taneb> Do you have questions regarding LYAH?
03:06:05 <t0by> Taneb, not directly. But, while we are at it, do you know any other resource that presents the same topics in a more structured, formal fashion? I was suggested LYAH by an instructor and I'm having troubles extracting the precise ideas and definitions of what exactly is what from there.
03:06:13 <t0by> *trouble
03:14:51 <t0by> I'm confused. What's wrong with fmap(\f -> f 3) Just (3 *) ? 
03:16:13 <Saizan> t0by: parentheses at least, you're passing 3 arguments to fmap that way
03:16:27 <Saizan> > fmap (\f -> f 3) (Just (3 *))
03:16:29 <lambdabot>  Just 9
03:17:23 <t0by> Saizan, thanks. Then I am not fully understanding the problem BONUS is talking about in http://learnyouahaskell.com/functors-applicative-functors-and-monoids
03:17:56 <t0by> Paragraph "But what if we have a functor value of Just (3 *) and a functor value of Just 5 and we want to take out the function from Just (3 *) and map it over Just 5?"
03:18:04 <t0by> Didn't I just do so?
03:19:24 <Saizan> nope, becuase you provided the 3 yourself with "\ f -> f 3", you didn't get it from a Maybe Int like "Just 5" would be
03:20:57 <Saizan> basically, it's saying you can't give a good definition for "Maybe (a -> b) -> Maybe a -> Maybe b" with just knowing that Maybe is a Functor
03:21:09 * t0by scratches head
03:21:28 <t0by> as in we'd like to do something like fmap (Just (\f -> f 3)) (Just (3 *)) but we... can't
03:21:39 <t0by> right?
03:22:26 <Saizan> more like "fmap (\ f x -> f x) (Just (3 *)) (Just 5)" -- but fmap does not actually typecheck there
03:23:00 <t0by> Saizan, what would that be? :-o
03:23:04 <Saizan> (your expression does not typecheck either)
03:23:15 <frerich> t0by: Right - that's where "Applicative" comes into play.
03:23:16 <t0by> What would that result in?
03:23:33 <Saizan> t0by: Just (3*5) = Just 15
03:23:40 <frerich> t0by: I.e. when the function to apply is 'wrapped' into a Maybe value, too.
03:23:44 <t0by> oh okay.
03:23:51 <t0by> Thank you.
03:24:13 <Saizan> t0by: i guess if you continue reading things might get clearer
03:32:30 <Ferdirand> t0by: maybe things get clearer if you consider a different functor, like pairs
03:34:29 <khanage> or maybe spaceship (<*>) help?
03:34:33 <khanage> (+) <$> (Just 3) <*> (Just 5)
03:34:38 <khanage> Just 15
03:34:57 <khanage> (+) <$> Nothing <*> (Just 5)
03:34:59 <khanage> Nothing
03:35:20 <Ferdirand> well he is trying to understand why you cannot implement spaceship with fmap
03:35:44 <Ferdirand> if i understood correctly
03:36:39 <Ferdirand> > fmap (+1) ("hello", 0)
03:36:40 <lambdabot>  ("hello",1)
03:36:53 <khanage> ahh, that's what i get for not reading the whole conversation
03:38:16 <Ferdirand> now how would you combine (x, (+1)) and (y, 0) to get some (z, 1) ?
03:38:22 <t0by> Mom?
03:38:25 <t0by> Mom?
03:38:50 <Ferdirand> if you have no information about the type of x,y and z, there is no single obvious way
03:39:56 <t0by> Ferdirand, right.
03:40:33 <t0by> But then if it's ill-defined... how can I make it happen, which is implied I can?
03:44:17 <t0by> khanage, can you help me parse (+) <$> (Just 3) <*> (Just 5) ? 
03:44:37 <t0by> By the way, I only see regular functions and functors in there
03:44:55 <fractalsea> If I have a concrete transformer stack, is there a way of turning it into monad transformer typeclasses, e.g. f :: (Monad IO m, MonadReader r m, MonadWriter w m) => WriterT w (ReaderT r IO) a -> m a 
03:44:58 <khanage> t0by: that's right, applicative is in (<*>)
03:45:06 <khanage> so
03:45:17 <khanage> (+) <$> Just 3
03:45:24 <t0by> khanage, are we trying to do something *like* (+ (Just 3) (Just 5)) ? 
03:45:34 <khanage> t0by: exactly
03:45:51 <khanage> but the plus needs to be inside the functor
03:46:08 <khanage> so that it becomes (Just (3 +)) 
03:46:25 <khanage> and then you need to apply that function to (Just 5)
03:46:32 <t0by> Okay, I am following.
03:47:01 <khanage> now, the problem is that you have to define how to "get out" of any particular functor
03:47:10 <t0by> er?
03:47:21 <khanage> because you want the (Int -> Int) part of (Maybe (Int -> Int))
03:47:47 <khanage> which is why you need to implement the applicative for each functor and you don't just get it for free
03:47:49 <t0by> A second. Isn't the type of 3 + Int -> Int?
03:47:57 <khanage> yeap
03:48:08 <khanage> but Just (3 +) :: Maybe (Int -> Int)
03:48:09 <t0by> And where di d that Maybe come from?
03:48:11 <t0by> Oh.
03:48:18 <t0by> Right.
03:48:22 <khanage> when we picked up the 3 
03:48:25 <khanage> it went
03:48:34 <khanage> Int -> Int -> Int
03:48:44 <khanage> we fmap'ed it into (Maybe Int)
03:48:53 <khanage> and we get back a (Maybe (Int -> Int))
03:49:48 <t0by> Okay. I'm following.
03:52:12 <khanage> so you need something that will take your f :: Maybe (Int -> Int) , apply it to a :: Int, and give you back your nice r :: Maybe Int
03:53:32 <khanage> remember fmap is :: Functor f => (a -> b) -> f a -> f b
03:53:53 <khanage> so you can't use it for your :: Functor f => f (a -> b)
03:54:19 <khanage> so you need to "unwrap" all your functors to get at the function
03:54:26 <t0by> Mh.
03:54:28 <khanage> and *then* you can fmap it again
03:54:39 <khanage> so
03:54:43 <khanage> case f of
03:54:54 <khanage>   Just f -> fmap f fa
03:54:59 <khanage>   Nothing -> Nothing
03:56:00 <t0by> Okay.
03:56:09 <t0by> I've just noticed that in the type of <*>
03:56:21 <t0by> we have f a and f b, not g b
03:56:49 <t0by> am I correct in saying that <*> defines a bunch of rules to apply the functions in a Functor f to another f (of the same type f) with the values in it?
03:56:57 <khanage> yup!
03:57:12 <t0by> And that is not a propriety of *all* applicative functors?
03:57:28 <t0by> Which is why [(+2), (+3)] <*> [1,2,3] types but [(+2), (+3)] <*> Just 1 doesn't?
03:57:34 <t0by> *typechecks
03:57:46 <khanage> yeah, it's all for the same f
03:58:11 <t0by> khanage, and can I define my own applicative functor which can do that?
03:58:36 <khanage> yeah - you can implement the Applicative class for any functor
03:58:55 <t0by> khanage, you mean any  *pair* of functors?
03:59:23 <t0by> ([+1, +2], Just 3) being a pair
04:00:03 <khanage> i'm not sure what you mean by that - you mean List and Maybe?
04:00:05 <Ferdirand> i don't think you can do that in the general way
04:00:09 <t0by> khanage, yes
04:00:25 <khanage> no - as Ferdirand says - it's for one functor only
04:00:31 <Ferdirand> it only seems to work in this specific case because Maybe is kind of a subset of lists
04:00:33 <t0by> Ferdirand, so applicative functors are limited to defining how functions in a f can be applied to values in another f?
04:00:43 <Ferdirand> yes
04:00:53 <Ferdirand> but not all functors are applicative functors
04:01:10 <t0by> Ferdirand, such as...?
04:01:12 <Ferdirand> ((,) e) 
04:01:30 <t0by> Ferdirand, khanage by the way - thank you, you are saving me probably a couple days of headache
04:01:35 <t0by> or more
04:01:42 <Ferdirand> but, Monoid m => ((,) m) is one
04:02:06 <t0by> Ferdirand, I have absolutely no idea what Monoids are. is this gonna be a problem?
04:04:31 <Ferdirand> well you can look up the definition, it's something that has a closed associative operation, and a neutral element
04:04:47 <Ferdirand> for instance lists of any type are a monoid, (++) is the associative operation and [] is the neutral element
04:05:22 <t0by> Ferdirand, just to be clear
04:05:24 <Ferdirand> > ("hello ", (+1)) <*> ("world", 0)
04:05:26 <lambdabot>  ("hello world",1)
04:05:43 <t0by> when earlier on I did [(+2), (+3)] <*> [1,2,3]
04:05:50 <t0by> and it worked
04:06:06 <Ferdirand> that works because List is a proper applicative functor
04:06:06 <t0by> is it because [] *is* an applicative functor?
04:06:15 <khanage> t0by: yeap
04:06:15 <Ferdirand> that has nothing to do with ((,) e) and Monoid
04:06:19 <t0by> Wonderful.
04:06:25 <t0by> And what do we call <*>?
04:06:27 <Ferdirand> ap
04:06:33 <khanage> spaceship ;)
04:06:40 <t0by> no, seriously :P
04:06:44 <Ferdirand> seriously, ap
04:06:46 <t0by> what is that, an operator?
04:07:01 <t0by> Oh.
04:07:02 <t0by> Okay.
04:07:03 <Ferdirand> ap [(+2),(+3)] [1,2,3]
04:07:06 <Ferdirand> > ap [(+2),(+3)] [1,2,3]
04:07:08 <lambdabot>  [3,4,5,4,5,6]
04:07:20 <jameseb> t0by: ap is short for apply
04:07:34 <t0by> Okay. And all and only applicative functors have ap?
04:07:36 <liste> @type ap
04:07:38 <lambdabot> Monad m => m (a -> b) -> m a -> m b
04:07:42 <liste> @type (<*>)
04:07:43 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:08:21 <Ferdirand> but this is a wart inherited from the times where Monad didn't imply Applicative in the language
04:08:54 <liste> t0by applicative functors have (<*>), and `ap` is just <*> but more restrictive
04:09:05 <liste> like Ferdirand said, for historical reasons
04:09:07 <t0by> liste, *all and only* applicative functors?
04:09:14 <liste> t0by yep
04:09:20 <t0by> wonderful.
04:09:31 <Ferdirand> all monads are also applicative functors
04:09:49 <t0by> liste, jameseb, Ferdirand, khanage I thank you.
04:09:58 <t0by> Now the whole thing makes *some* sense to me.
04:10:39 <Ferdirand> don't stop there, you are one step away from making sense out of Monad as well
04:14:52 <t0by> Ferdirand, the wikipedia article doesn't look *that* related or familiar (https://en.wikipedia.org/wiki/Monad_%28functional_programming%29#The_Maybe_monad)
04:16:10 <Ferdirand> t0by: this is confusing because Monad is introduced in terms of (>>=) and return
04:16:29 <Ferdirand> but return is like pure from Applicative
04:16:42 <Ferdirand> and (>>=) can be implemented with fmap and join
04:16:52 <Ferdirand> @t join
04:16:52 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
04:16:58 <Ferdirand> @type join
04:16:59 <lambdabot> Monad m => m (m a) -> m a
04:17:14 <Ferdirand> this is what you need to add to an Applicative to make it a Monad
04:18:13 <hc> will return become obsolete?
04:18:18 <hc> and replaced by 'pure'?
04:18:41 <t0by> Uh, Not in scope: `join'
04:19:48 <phadej> hc Ferdirand: https://ghc.haskell.org/trac/ghc/wiki/Proposal/MonadOfNoReturn
04:19:58 <quchen> hc: As of 7.10, return *is* obsolete. Furthermore, "return" will never be entirely gone. It's safe to use it in your code.
04:20:48 <quchen> Me and a couple of others encourage you to implement pure and omit a definition of return (which defaults to pure) in new Monad instances, if backwards compatibility permits it.
04:21:37 <t0by> Wait. How is pure 1 different from 1?
04:21:51 <hc> right
04:21:54 <Axman6> :t 1
04:21:56 <lambdabot> Num a => a
04:21:57 <Axman6> :t pure 1
04:21:59 <lambdabot> (Num a, Applicative f) => f a
04:22:08 <hc> i always thought return was there to confuse people coming from imperative languages anyway ;-p
04:22:21 <Ferdirand> > pure 1 :: Maybe Integer
04:22:22 <lambdabot>  Just 1
04:22:28 <Ferdirand> > pure 1 :: [Integer]
04:22:29 <lambdabot>  [1]
04:22:35 <t0by> Axman6, but I can't treat is as a function
04:22:42 <Ferdirand> > pure 1 :: (String,Integer)
04:22:44 <lambdabot>  ("",1)
04:23:15 <t0by> Help. Mom.
04:23:36 <t0by> Ferdirand, Axman6, what did you just do with ::? Isn't that for type declarations?
04:23:45 <siddhu_> how does pure 1 :: (String,Integer) work?
04:24:13 <cocreature> Monoid a => ((,) a) is an applicative
04:24:21 <t0by> Did you just *declare a type for pure 1*?
04:24:24 <cocreature> so it uses mempty for the left side
04:25:03 <Ferdirand> pure 1 has type (Num a, Applicative f) => f a 
04:25:27 <Axman6> more like "give me the result of 'pure 1' which has the type [Integer]"
04:25:41 <Ferdirand> so it is a polymorphic expression that can cover all possible combinations of f a, for all possible applicative f and num a
04:25:55 <Ferdirand> with :: i'm just asking it to narrow down to a specific type
04:26:26 <meditans> hi, I have a question on HList usage: I want to express the constraint that all types in the HList have an Eq constraint. But how?
04:29:18 <t0by> Ferdirand, why doesn't (pure 1) 2 [] typecheck, then? I thought that list *was* an applicative functor
04:29:34 <t0by> In my head it should return [2]
04:29:47 <t0by> or rather, "evaluate to"
04:30:41 <nshepperd> where'd the 1 go?
04:30:58 <liste> t0by (pure 1) is [1], so your expression would be [1] 2 []
04:31:14 <liste> (in that case)
04:31:14 <Ferdirand> > (pure 1) 2
04:31:16 <lambdabot>  1
04:31:33 <Ferdirand> but this is in the ((->) r) applicative, which we haven't discussed yet
04:31:44 <t0by> nshepperd, don't ask me. If pure 1 has type (Num a, Applicative f) => f a that's one way I can make it make sense
04:32:15 <t0by> Ferdirand, but in (pure 1) 2 where did the f go?
04:32:18 <Ferdirand> you are confusing value-level and type-level functions, i think
04:33:02 <Ferdirand> and => is a constraint, it's not the same as ->
04:33:46 <meditans> Ferdirand: are ^ addressed to me?
04:34:13 <Ferdirand> meditans: no, sorry, i have no idea about your issue, this was for t0by 
04:34:20 <meditans> Ferdirand: np :)
04:34:35 <t0by> me iz in ur irc
04:34:39 <t0by> hijacking ur help
04:34:57 <t0by> (a sec, brb)
04:35:24 <nshepperd> meditans: I think you could solve your problem with a type family, not sure if it would be a good idea
04:36:29 <cocreature> meditans: you can do something similar to http://lpaste.net/145373
04:36:41 <cocreature> so type family + constraint kinds
04:37:00 <nshepperd> yeah that
04:37:23 <cocreature> then you can write Showable as => Show (Hlist as) or something like that
04:37:33 <cocreature> assuming your HList is parametrized by a list of types
04:38:09 <meditans> cocreature: thanks, I didn't know that was possible
04:38:23 <meditans> cocreature hi, by the way :)
04:38:32 <cocreature> hi :)
04:39:03 <meditans> who exports `Constraint`?
04:39:37 <cocreature> GHC.Exts iirc
04:43:46 <t0by> Ferdirand, ok, => is a constraint. My bad, I brainfarted. So that type is "f a". But why isn't it a -> Num? pure 1 something eats "something" and just returns 1, where did I get lost?
04:44:22 <srhb> t0by: Num isn't a type.
04:44:28 <t0by> : - O 
04:44:51 <t0by> Oh.
04:44:53 <t0by> Okay.
04:45:01 <t0by> a -> b with Num b  
04:45:12 <t0by> (you can blame 10 years of Java for that)
04:45:36 <ggole> Num is a red herring there, it's just the type of the 1
04:45:46 <ggole> :t pure (1::Int)
04:45:47 <lambdabot> Applicative f => f Int
04:45:49 <ersran9> hello, is typeRepFingerprint of a typeRep "constant" across runs / builds?
04:45:55 <ggole> :t pure 1
04:45:56 <lambdabot> (Num a, Applicative f) => f a
04:46:03 <nshepperd> t0by: that works because (a ->) is a possible applicative
04:47:03 <t0by> Still why does it return an f a?
04:47:11 <nshepperd> :t pure (1::Int) `asTypeIn` (\pure1 -> pure1 ())
04:47:12 <lambdabot> () -> Int
04:47:16 <t0by> When I print it, it prints just 1
04:47:22 <t0by> not Just 1, or [1], or...something
04:47:40 <nshepperd> if you type 'pure 1' on the command line, it assumes you mean Num a => IO a
04:47:53 <nshepperd> "the IO action that returns 1"
04:48:02 <nshepperd> and so ghci runs that and outputs the result
04:48:20 <t0by> er.
04:49:12 <t0by> nshepperd, I assume that's a special case then. What sould a non-special case be?
04:49:15 <t0by> *would
04:49:39 <nshepperd> try (pure 1 :: IO Int) and (pure 1 :: Maybe Int) in ghci
04:50:40 <nshepperd> yeah, the thing where ghci runs an IO action instead of just displaying it is a special case in the repl
04:50:49 <nshepperd> > print 1 -- otherwise it would just do this
04:50:50 <lambdabot>  <IO ()>
04:50:58 <t0by> nshepperd, what magic is being done with that ::, though? I would have expected that from (Maybe (pure 1))
04:51:06 <breadmonster> Hey guys.
04:51:09 <Ferdirand> you can think of (pure 1) as an abstract value
04:51:17 <t0by> or something like that
04:51:54 <Ferdirand> it stays polymorphic unless the context makes it clear to which particular functor this applies
04:52:04 <Ferdirand> (pure (+1)) <*> [0,1]
04:52:06 <Ferdirand> > (pure (+1)) <*> [0,1]
04:52:08 <lambdabot>  [1,2]
04:52:12 <Ferdirand> > (pure (+1)) <*> Just 3
04:52:13 <lambdabot>  Just 4
04:52:18 <Ferdirand> > (pure (+1)) <*> (5,6)
04:52:19 <lambdabot>      No instance for (Show t0)
04:52:19 <lambdabot>        arising from a use of ‘show_M358195201591614914630697’
04:52:19 <lambdabot>      The type variable ‘t0’ is ambiguous
04:52:29 <Ferdirand> wat
04:52:39 <Ferdirand> > (pure (+1)) <*> ("",6)
04:52:41 <lambdabot>  ("",7)
04:53:04 <Ferdirand> the :: was just a shortcut to force a particular context
04:53:10 <nshepperd> t0by: (Maybe (pure 1)) isn't a valid expression, it's mixing types and values together
04:53:49 <Ferdirand> in all the cases above, all the (pure 1) look the same, but they all have different types
04:54:13 <Ferdirand> and different values
04:55:08 <t0by> Ferdirand, is it blasphemous to think of casting?
04:55:45 <Axman6> yes
04:55:46 <Ferdirand> well they are not the same value
04:56:21 <Ferdirand> the first (pure (+)) was [(+1)], the second was Just (+1), and the third was ("",(+1))
04:56:39 <t0by> But then what does this imply regarding Monads (which is where the headache started from)?
04:56:50 <Copperis> "pure" puts a value in a minimal context
04:57:15 <Copperis> it usually infers which that is
04:57:33 <Ferdirand> well, initially you were trying to understand the difference between plain Functors, and Applicatives
04:57:46 <Ferdirand> there is a similar relationship between Applicatives and Monads
05:00:05 * hackagebot smsaero 0.4.1 - SMSAero API and HTTP client based on servant library.  https://hackage.haskell.org/package/smsaero-0.4.1 (NickolayKudasov)
05:05:17 <t0by> Okay. Thanks everybody a huge lot, I'm off to lunch for now. Thank you a lot.
05:40:06 * hackagebot FPretty 1.1 - Efficient simple pretty printing combinators  https://hackage.haskell.org/package/FPretty-1.1 (OlafChitil)
05:42:37 <frerich> I seem to recall there was a function which could 'diff' two rose trees, yielding a list of modifications which -- when applied to the source tree -- yield the target tree. Does anybody happen to know anything about that? I thought I saw a Haskell definition somewhere...
05:49:00 <fizruk> frerich: probably not what you asked for, but there was a post recently http://liamoc.net/posts/2015-11-10-patch-theory.html
05:49:28 <fizruk> frerich: and there is a corresponding package for trees: http://hackage.haskell.org/package/composition-tree
05:49:39 <newbie_haskeller> Hi guys. I need to implement the disjoint-set data structure and use it in algorithms on graphs. I am unsure of how to pursue this in functional style, since mutability seems to be the key feature. I don't want to make the performance worse. Any advice?
05:50:14 <ocramz> frerich: rose trees are something like this? `data Rt a = a :> [Rt a]`
05:50:45 <newbie_haskeller> Don't need and don't want the code. Just advice me on how to pursue this conceptually.
05:50:57 <ocramz> frerich: what type of diff where you looking for?
05:51:45 <fizruk> newbie_haskeller: there is something (although pretty old) on Hackage: https://hackage.haskell.org/packages/search?terms=disjoint
05:52:24 <frerich> ocramz: Yes, that's the kind of tree I meant. IIRC the implementation I saw produced a sequence of insert/remove operations which, when applied to the source tree, yields the target tree.
05:53:09 <ocramz> frerich: wow, sounds like a job for a constraint solver
05:53:10 <newbie_haskeller> fizruk: I don't need and don't want the code. Just advice me on how to pursue these kinds of tasks (graph algorithms based on mutability) in functional style.
05:53:42 <lmj> newbie_haskeller: there's a reference at https://hackage.haskell.org/package/disjoint-set
05:56:27 <ackthet> ff
05:56:57 <lyxia> newbie_haskeller: you can use a Map to represent memory and integer values as "pointers", and then have functions accept Map as an argument and return a possibly modified version (which is what State abstracts over). 
05:57:13 <lyxia> Or you can use ST to have "true" mutability without IO.
05:59:58 <ocramz> lyxia: could you elaborate on ST having "true" mutability? I'm currently struggling with this
06:00:01 <newbie_haskeller> lyxia I can't see how I do that without getting an overhead
06:00:34 <lmj> newbie_haskeller: did you see the reference I posted?
06:00:41 <newbie_haskeller> yes
06:00:49 <newbie_haskeller> I have the code up and working
06:00:52 <newbie_haskeller> playing with it
06:01:03 <lmj> I meant Cormen et al
06:01:18 <newbie_haskeller> I have read Cormen's book
06:01:43 <lmj> nor I, but that's where I'd look first
06:02:27 <lmj> (oh, I thought that said "have not read")
06:02:27 <newbie_haskeller> lmj: If I had mutability at my disposal, I would write a simple piece of working code already
06:02:37 <newbie_haskeller> unfortunately that's not the case
06:02:50 <ocramz> newbie_haskeller: what do you mean?
06:03:18 <ocramz> wrapping in ST is just a way to abstract over the mutability
06:04:31 <fryguybob> @tell latermuse STM can handle millions of transactions per second. I would love to figure out what the problem is in your case.
06:04:31 <lambdabot> Consider it noted.
06:06:49 * Black-Wolf Back
06:10:43 <phaazon> hey, is there a good paper about why dynamic typing sucks vs. static typing gives nice guarantees?
06:10:52 <phaazon> I thought SPJ has written one
06:13:50 <bernalex> is there a *->*-polymorphic zipWith of sorts?
06:17:01 <lyxia> ocramz: With ST you can write programs which make use of mutation only locally. It's IO without Input/Output, without global variables. Then it is safe to unwrap the result of such a computation with runST.
06:17:47 <lpaste_> lmj pasted “Tree.hs” at http://lpaste.net/145378
06:17:53 <ocramz> lyxia: and in the cases where we have IO at the bottom by necessity, such as FFI interop?
06:18:27 <ocramz> what I'm struggling with is how to represent FFI callbacks with this ST machinery
06:18:43 <lmj> I hope I've sufficiently explained this (http://lpaste.net/145378). I want to implement Functor, Foldable, etc with a level of indirection.
06:18:54 <ocramz> callbacks with in-place updates, in particular
06:19:33 <lyxia> ocramz: I'm not too familiar with FFI but I guess you will have to cheat the type system with something like unsafeIOToST
06:20:22 <ocramz> lyxia: this would convert IO actions to ST actions
06:20:29 <ocramz> simple as that?
06:20:52 <lyxia> ST is mostly a hack around the type system to restrict the possible actions you can do with it.
06:21:44 <bernalex> also, is there a *->*-polymorphic repeat somewhere?
06:28:14 <sbrg> is cloud haskell(the distributed-process package) the go-to package for distributed programming? I am currently working on a parallel computing project for which I chose Haskell. I was originally thinking of a shared memory implementation, but it won't scale as well as message passing, and I have the opportunity to attempt to get my program to scale across hundreds of cores
06:31:14 <lyxia> lmj: Try GADTs.
06:31:33 <bernalex> related: can someone show me how to do a ziptree? :]
06:37:23 <t0by> Sorry for the zillionth stupid question, but... again, what's the difference between pure 1 and Just 1 and when would I use either?
06:38:03 <Ankhers> > pure 1 :: Maybe Int
06:38:04 <lambdabot>  Just 1
06:38:08 <Ankhers> > pure 1 :: Either String Int
06:38:10 <lambdabot>  Right 1
06:38:27 <bernalex> :t pure
06:38:28 <lambdabot> Applicative f => a -> f a
06:38:30 <bernalex> :t Just
06:38:31 <lambdabot> a -> Maybe a
06:38:35 <Ankhers> t0by: `pure' is the generalized function to wrap something in an applicative.
06:38:41 <bernalex> t0by: pure = Just for Applicative Maybe.
06:39:43 <Ankhers> t0by: `Just' is specific to the Maybe Applicative. `pure' is the general function to wrap a value into any Applicative.
06:39:44 <t0by> bernalex, could please explain that?
06:39:46 <t0by> seems interesting.
06:40:06 <t0by> Ankhers, are you saying that Just can be defined in terms of Pure?
06:40:08 <t0by> *puore
06:40:11 <t0by> *pure
06:40:13 <t0by> *ach
06:40:18 <Ankhers> pure is defined in terms of Just
06:40:28 <Ferdirand> pure is the abstract, polymorphic operation
06:40:41 <t0by> But isn't pure the more generic one?
06:40:41 <bernalex> t0by: pure is polymorphic. Just is the implementation of pure for Maybe.
06:40:49 <ARM9> pure is the identit function of the Applicative typeclass
06:40:52 <ARM9> identity*
06:41:06 <bernalex> t0by: other examples include :[] for list
06:41:15 <bernalex> > pure 5 :: [Int]
06:41:17 <lambdabot>  [5]
06:41:22 <bernalex> > 5:[]
06:41:23 <t0by> OH.
06:41:24 <jophish_> the monkey face operator (:[])
06:41:24 <lambdabot>  [5]
06:41:29 <t0by> lol @ monkey face
06:41:44 <Ferdirand> you said earlier that you came from Java
06:41:54 <t0by> are saying that pure 5 :: [Int] IS 5:[]?
06:41:59 <t0by> *are we
06:42:20 <bernalex> t0by: for Applicative [], pure = (:[])
06:42:34 <bernalex> t0by: pure is defined in terms of the instances.
06:42:38 <Ferdirand> the analogy is flawed and I might get blasted for it, but you can think of typeclasses are somehow similar to abstract classes whose subclasses would be the types
06:42:41 <bernalex> t0by: so for Maybe, pure = Just.
06:42:52 <bernalex> analogies are usually bad.
06:43:04 <t0by> This is getting intereseting.
06:43:07 <t0by> *interesting.
06:43:11 <bergmark> pure 5 :: [Int] IS 5:[] <-- exactly, feel free to replace IS with an equals sign :-)
06:43:15 <bernalex> if you want to know the differences between typeclasses and OOP interfaces, see https://stackoverflow.com/questions/8122109/difference-between-oop-interfaces-and-fp-type-classes
06:43:47 <t0by> So, if I were to come up with a RedBlackTree typeclass of my own I would define pure info::RedBlackTree so that it yields a single leaf node with info inside it?
06:43:58 <t0by> bernalex, thanks for the link
06:44:03 <bernalex> I don't know what pure info::RedBlackTree means
06:44:08 <Ferdirand> ah well, guess the analogy was bad indeed then
06:44:16 <Ferdirand> RedBlackTree would not be a typeclass
06:44:17 <bernalex> you would do "instance Applicative RedBlackTree where pure = ..."
06:44:24 <Ferdirand> RedBlackTree would be a type
06:44:40 <bernalex> that too. I don't see how RedBlackTree would be a useful typeclass. it would probably be an adt.
06:44:57 * t0by cries
06:44:58 <bernalex> typeclasses exist to provide constraint polymorphism, in order to solve ad-hoc polymorphism.
06:45:03 <Ferdirand> but you are right, you can make a RedBlackTree that is a type like List
06:45:15 <bernalex> class Num α where (+), (-), (*) :: Num α ⇒ α → α → α
06:45:31 <bernalex> here we can say that the functions are constrained to work on any type α which has a Num instance
06:45:32 <Ferdirand> now there is the hidden pitfall that you need the Ord constraint to put things in a binary tree but
06:45:36 <t0by> The last time I learnt to program from scratch was 10 years ago, and I remember it being less painful :*D
06:45:38 <bernalex> that way we get 5 + 5 and 5.0 + 5.0
06:45:49 <Ferdirand> conceptually, you are right that you would make your RedBlackTree type an instance of Functor and Applicative
06:45:51 <bernalex> so we avoid needing addInt 5 5 and addFloat 5 5
06:46:06 <Ferdirand> and Functor would give you a way to apply a function to every value in the tree
06:46:24 <Ferdirand> and Applicative would give you a way to apply two trees together, whatever that would mean
06:46:33 <Ferdirand> and Monad would give you a way to turn a tree of trees into a tree
06:46:33 <t0by> Then why was bernalex protesting?
06:46:37 <bernalex> t0by: hang in there. it's not that hard, really. once you're over the hump you'll be forever enlightened.
06:46:56 <bernalex> t0by: protesting to what?
06:47:06 <t0by> RedBlackTree datatype.
06:47:15 <bernalex> you called it a typeclass. that doesn't make sense. it is an adt.
06:47:28 <t0by> gah
06:47:32 <Ferdirand> people coming from java fall into the trap of thinking typeclasses work like java classes
06:47:33 <t0by> sorry, brainfart.
06:47:37 <bernalex> typeclasses are the things we use to get ad-hoc polymorphism so that we can operate on values of different types.
06:47:41 <t0by> but of course java classes are adts
06:47:44 <t0by> sorry, sorry.
06:47:51 <t0by> brainfart.
06:47:59 <t0by> *a RedBlackTree adt
06:48:00 <bernalex> java classes are not adts at all. I'm not sure how that could make sense.
06:48:01 <ARM9> java classes aren't adts
06:48:10 <bernalex> classes as they exist in java do not exist in haskell.
06:48:29 <tdammers> not as built-in language constructs anyway
06:48:30 <bernalex> you could mock them. hell, you can even have subtype polymorphism OOP style if you're masochistic enough. but that's hardly commonplace.
06:48:49 <tdammers> it's about as pleasant as doing FP in Java
06:48:53 <bernalex> then again you could do all your programming in LaTEX, so it's not a strong argument.
06:48:56 <t0by> Do...doesn't ADT stand for abstract data type?
06:49:04 <Ferdirand> well, fields in java classes are kind of type products, and single-generation inheritance is kind of sum types
06:49:06 <Ankhers> The closest thing in Java to Haskells typeclasses would be an interface.
06:49:09 <Ferdirand> no, A is for Algebraic
06:49:12 <bernalex> tdammers: it's actually a lot more pleasant to maintain, but more horrid to write.
06:49:19 <t0by> oh, okay.
06:49:20 <tdammers> bernalex: ofc
06:49:28 <t0by> Double brainfart, then. Sorry again.
06:49:48 <tdammers> at least with "OOP in Haskell", you can hide the gore in a nice concise EDSL
06:49:54 <Ferdirand> because these types are composed of sums (alternative constructors) and products (multiple fields in the constructor)
06:49:56 <tdammers> whereas "concise" is not a thing in Java
06:50:01 <bernalex> t0by: you better leave all your conceptions from Java behind. it won't end well for you if you try to find analogies to Java for everything in Haskell.
06:50:27 <bernalex> tdammers: it's difficult, I know. most of #haskell has probably been there at some point in time. myself included.
06:50:31 <t0by> bernalex, hey, you guys started it :P
06:50:39 <bernalex> oops t0by ^ not tdammers 
06:51:16 <bernalex> tdammers: did you read oleg's paper on OOP in Haskell? absolute masochism.
06:51:30 <tdammers> yep
06:51:30 <bernalex> now tell me how do ziptree, because i noob. :]
06:52:07 <bernalex> i.e. given data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
06:52:08 <t0by> So in practce I'd have something like RedBlackTree info :: (Node info blah blah) ... ; class (Functor f) => RedBlackTree f where pure :: a -> f a?
06:52:29 <lmj> lyxia: Thanks, but could you give more of hint about what you mean? GADTs provide more specifically-typed contstructors, but the issue in this case is the interpretation of an already-constructed leaf.
06:52:42 <bernalex> consider data ZipList a = Z [a], instance Applicative ZipList where pure x            = Z (repeat x); (Z fs) <*> (Z xs) = Z (zipWith id fs xs); -- what's a sensible implementation for data ZipTree a = ZT (Tree a) ?
06:53:13 <bernalex> t0by: I don't understand what any of that means. what's RedBlackTree, info, Node, blah?
06:53:37 <bernalex> t0by: you'd have data RedBlackTree = Node...; instance Applicative RedBlackTree where pure = ... -- if that's what you're asking.
06:53:51 <Ferdirand> ^ what bernalex said
06:54:25 <trubert7> what is the evaluation order of arguments to a function, if all are strict? E.g. f !x !y, is x evaluated to WHNF and then y is evaluated to WHNF?
06:54:40 <t0by> bernalex, Ferdirand screw RBT for a moment and let's just consider data Tree a from http://learnyouahaskell.com/making-our-own-types-and-typeclasses
06:55:22 <t0by> I'd have instance Applicative Tree a where pure = Tree
06:55:34 <lyxia> lmj: For oneYou would be able to restrict a with Num a with a GADT. I also feel like you meant Tree n a = ... | Node (Tree (n-1) a) (Tree (n-1) a), didn't you?
06:55:41 <t0by> And so pure 1 :: Tree would give me (Node 1 Empty Empty)?
06:55:42 <bernalex> t0by: that doesn't make any sense
06:55:45 <bernalex> t0by: what's Tree?
06:55:54 <bernalex> t0by: oh wait
06:56:00 <Ferdirand> you would have rather
06:56:04 <bernalex> t0by: I misread the data type in the book.
06:56:05 <t0by> bernalex, I'[m thinking of data Tree a from http://learnyouahaskell.com/making-our-own-types-and-typeclasses
06:56:06 <Ferdirand> pure x = Tree x Empty Empty
06:56:21 <bernalex> t0by: there are multiple legal instances for Applicative Tree
06:56:39 <t0by> Ferdirand, you mean in the instance definition?
06:56:43 <bernalex> do you want your Tree to model non-determinism? a collection? something else?
06:56:49 <trubert7> Can I have a bang pattern on a function argument that has type `IO a` ?
06:56:53 <lyxia> lmj: It seems fmap f (Leaf x) would depend on the type too, which is another place where GADTs might help.
06:56:57 <t0by> bernalex, say a BST
06:57:08 <Ferdirand> t0by: yes. But maybe for the tree you should first focus on Functor
06:57:12 <Ferdirand> and even then
06:57:21 <t0by> (I'm sticking to the example in the book)
06:57:27 <Ferdirand> for Applicative to make sense, it must be possible to have something of type Tree (a -> b)
06:57:31 <Ferdirand> so a tree of functions
06:57:41 <Ferdirand> then <*> would apply a tree of functions to a tree of values
06:57:51 <t0by> arf, but pure 1 is valid and 1 is no function, is it?
06:58:00 <Ferdirand> but, to get a binary search tree, you need to be able to compare the values
06:58:10 <Ferdirand> and how do you compare functions ?
06:58:47 <lyxia> lmj: Another idea, without GADTs, how about representing a Leaf instead by Leaf a a, where the second value is the "default" for all other leaves of the tree it implicitly represents?
06:59:39 <t0by> Ferdirand, a second. I saw you doing that magic in which pure 1::[Int] returns [1] and pure4 1::Maybe Int returns Just 1. Say I want to do the same with another functor, such as... a BST, in which pure 1::Tree Int returns a single Node (1, null ,null). What's stopping me?
06:59:52 <lmj> lyxia: Here n is a tag class serves to (1) know the depth of the tree from just a leaf and (2) prevent other-depth trees from interacting, so we want n, not (n - 1). If you want to see the practical application its https://hackage.haskell.org/package/cayley-dickson-0.1.4.0/docs/Math-CayleyDickson.html , i.e. we don't want to mix quaternions and octonions.
06:59:56 <bernalex> funny how I came in here asking about trees, but ended up helping people with trees.
07:00:56 <lyxia> lmj: Oh okay, so n is the depth of the whole tree when you have only a subtree of it?
07:01:06 <lmj> lyxia: right
07:01:17 <lmj> the subtrees only get involved in the implementation
07:01:58 <bernalex> I figured it out anyway.
07:02:00 <bernalex>   (Node l f r) <*> (Node l' x r') = Node (l <*> l') (f x) (r <*> r')
07:02:33 <lmj> it's a nice trick to use the numeric promotions to give a scalar (leaf) without having to pad the thing with zeros. But it screws over Functor, Foldable, etc. when we have just a scalar (leaf).
07:02:50 <lyxia> lmj: So, the Foldable instance would pass it "0" something like (2^n-1) times?
07:03:06 <lmj> lyxia: yes something like that
07:03:28 <lyxia> I guess that for this type you wouldn't be able to define a Foldable instance then.
07:03:38 <lmj> lyxia: fmap (*2) x is coincidentally correct because 0*2 = 0, but fmap (+2) would be wrong when we just have a scalar.
07:03:42 <lyxia> You need a wrapper which holds a concrete representation of the depth.
07:03:48 <aweinstock> t0by: the Applicative typeclass defines both pure and (<*>), you can't just define one of them
07:04:15 <aweinstock> > [(+1), (*5)] <*> [1,10,100]
07:04:17 <lambdabot>  [2,11,101,5,50,500]
07:04:58 <Ferdirand> t0by: that is a good question actually
07:05:09 <Ferdirand> whether it makes sense to define pure without (<*>)
07:05:23 <lyxia> lmj: So what do you say of representing the "padding" explicitly with a single field? Tree n a = Leaf { leftValue :: a, padding :: a } | ...
07:05:43 <aweinstock> Ferdirand: I think I asked about this before, and apparently they're called "pointed functors", but they don't have any good laws without combining them with <*>
07:05:45 <Ferdirand> I think at some point someone proposed an intermediary Pointed class, which is a Functor, and has pure, but not ap
07:05:47 <slomo> Ferdirand: that's https://hackage.haskell.org/package/pointed-4.2.0.2/docs/Data-Pointed.html
07:05:49 <t0by> I would assume the answer has to do with the semantics of my functor, doesn't it?
07:07:15 <aweinstock> which sort of tree are we talking about? data Tree a = Nil | Node a (Tree a) (Tree a) -- ?
07:07:23 <Ferdirand> t0by: you mean for the definition of (<*>) ? yes
07:07:25 <Ferdirand> aweinstock: yes
07:07:37 <Ferdirand> but again
07:07:48 <Ferdirand> for this thing to be a Functor, you need to be able to store any type inside
07:07:59 <Ferdirand> so you must be able to have a Tree (a -> b)
07:08:10 <lyxia> Funny thing, there are two concurrent discussions about "trees" and typeclasses.
07:08:28 <t0by> Ferdirand, how is that a problem?
07:08:29 <lmj> lyxia: that doesn't match the mathematical structure, but your general idea of having another field might work
07:08:31 <Ferdirand> there is no problem storing functions into that tree datastructure you defined
07:08:36 <t0by> Oh, good.
07:08:37 <aweinstock> I'd think the only sensible functor for it would be: instance Functor (Tree a) where {fmap f Nil = Nil; fmap f (Node x l r) = Node (f x) (fmap f l) (fmap f r)}
07:08:45 <Ferdirand> but there is a problem if you want to organise it in a binary search tree
07:09:06 <lyxia> lmj: what mathematical structure
07:09:10 <t0by> Ferdirand, yes, right, forget about the BST. Just make it an auto balancing tree with no particular order. Something.
07:09:14 <aweinstock> Ferdirand: but it's not a problem if you just want an unbalanced binary tree
07:09:22 <Ferdirand> of course
07:09:39 <ackthet> i have a question about https://wiki.haskell.org/Hoogle#GHCi_Integration, is there a way to make it show only the first result?
07:09:49 <t0by> aweinstock, well, it can be balanced if you forget about ordering, can't it? Just fill it breadth first.
07:10:25 <lyxia> lmj: You can still put Num in every constructor type signature if you insist on there being numbers.
07:10:27 <aweinstock> t0by: that gets you O(n) lookups, unless I'm missing something
07:10:41 <Ferdirand> in that case, what is the advantage of a tree over a list ?
07:10:56 <quicksilver> foldMap is nicer for a tree :)
07:11:07 <quicksilver> it can divide the work more efficiently
07:11:08 <Ferdirand> hmmm ok, granted
07:11:15 <t0by> aweinstock, I couldn't care less about the efficiency of an hypotetical structure that I'm postulating for the purpouse of understanding Applicative :P
07:11:18 <lmj> lyxia: the mathematical structure in the hackage link I posted; multiplication etc is defined on pairs, it's only the bottom of the tree where we get a real number and a (2^n - 1)-dimensional pure (quaternions, octonions, etc)
07:11:20 <t0by> *purpose
07:11:27 <geekosaur> ackthet: I think you can just insert `| head -n 1` before the final `'`
07:11:27 <t0by> *pourpose*
07:11:33 <aweinstock> t0by: ok, that's a valid answer :)
07:11:35 <t0by> *purpose. engrish iz dificult
07:11:57 <ackthet> geekosaur: yeah, i guess it wouldn't be super useful, but its annoying when you search map for example, and there are a ton of results
07:12:12 <sbrg> how does one pass something like --extra-include-dirs and --extra-lib-dirs to stack?
07:12:14 <aweinstock> :t (<*>)
07:12:15 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:12:25 * t0by cries some more
07:12:43 <aweinstock> Nil <*> Nil = Nil -- probably makes sense
07:13:08 <lmj> lyxia: the original problem was that the 'a' Num was erased in Functor (Nion n), but having another field won't erase it. I think it may work, thanks. But it will require a fair bit of wrapping, since we want users to see Tree n a, not Tree n a a.
07:13:13 <aweinstock> actually, we could go further and say: _ <*> Nil = Nil <*> _ = Nil --?
07:13:41 <Ferdirand> then all is left to define is Node x l r <*> Node x' l' r'
07:14:33 <lyxia> lmj: In what I proposed I thought the user would still see (Tree n a)
07:14:34 <aweinstock> Node f fl fr <*> Node x xl xr = Node (f x) (fl <*> xl) (fr <*> xr)
07:15:42 <lmj> lyxia: oh right, because the leaf (scalar) constructor is hidden from the user. this is looking better than I thought!
07:15:50 <aweinstock> so then <*> means something like "align the trees, call the functions on the corresponding values, and truncate the tree as soon as their shapes differ"?
07:19:40 <lmj> lyxia: er wait, we have Tree n a, whose instance looks like Functor (Tree n). We need an 'a' field that is numeric so we can pad with zeros. Having Tree n a a will give us Functor (Tree n a), which seems like it would work, putting aside the wrapping
07:19:46 <lpaste_> aweinstock pasted “Applicative instance for tree” at http://lpaste.net/145381
07:19:57 <aweinstock> t0by: ^
07:20:22 <aweinstock> it typechecks, and doesn't do anything obviously weird, so it's probably valid
07:21:31 <lyxia> lmj: But fmap-ping that with (a -> b) gives you Tree n a b...
07:21:51 <t0by> aweinstock, thanks. what is   _? 
07:22:12 <aweinstock> a wildcard pattern
07:22:18 <t0by> oh right ok
07:22:35 <lyxia> lmj: I have to go but I'd be happy to discuss later if you are still working on it.
07:22:43 <aweinstock> so it handles Node <*> Nil, Nil <*> Node, and Nil <*> Nil
07:22:54 <lmj> lyxia: k thanks for the help
07:22:55 <aweinstock> (since the only case defined above it is Node <*> Node
07:22:57 <aweinstock> )
07:23:17 <t0by> aweinstock, tell me if I'm reading this correctly: say I have two trees of the same shape. One has functions (like +1), the other values (like 1)
07:23:32 <t0by> and t1 <*> t2 yields another tree with f x, like 2
07:23:53 <dzhus> why swapTMVar isn't just takeTVar .. >> putTMVar .. ? What is `retry` for? http://hackage.haskell.org/package/stm-2.4.4/docs/src/Control-Concurrent-STM-TMVar.html#swapTMVar
07:23:55 <t0by> while pure 1 gives me a single orphan node with 1, nil, nil
07:24:03 <t0by> er pure 1::Tree
07:24:07 <Ferdirand> right
07:24:16 <t0by> hee hee hee. 
07:24:34 <t0by> This is cool.
07:24:51 <Ferdirand> and then you figure that this is not a valid applicative functor, because it does not respect the applicative law that pure f <*> t = fmap f t
07:24:59 <hwanzike> any suggestions to improve this code? http://lpaste.net/1263430609406001152
07:25:02 <aweinstock> (>>=) = flip ((join .) . fmap) -- is this true?
07:25:22 <t0by> Ferdirand. Wat.
07:25:22 * hackagebot tip-lib 0.2.1 - tons of inductive problems - support library and tools  https://hackage.haskell.org/package/tip-lib-0.2.1 (DanRosen)
07:25:38 <t0by> ah.
07:25:39 <t0by> eh.
07:26:04 <aweinstock> Ferdirand: fixed by making (pure x = Node x (pure x) (pure x))?
07:26:23 <t0by> doesn't that explode in an infinite height tree?
07:26:30 <aweinstock> t0by: it does
07:26:45 <aweinstock> but so long as you use only finitely many elements of it, that's fine
07:26:59 <aweinstock> (which <*> would do, if the right-hand argument is a finite tree)
07:27:28 <Ferdirand> and then you also get that pure f <*> pure x = pure (f x)
07:28:28 <lmj> A general question about Applicative and friends. Applicative reminds me of the del operator (https://en.wikipedia.org/wiki/Del) where a structure is filled with (scalar) functions, and we apply the function-structure to things. At least conceptually, this is what Applicative is doing.
07:28:36 <aweinstock> or something like (prune 0 x = Nil; prune n Nil = Nil; prune n (Node x l r) = Node x (prune (n-1) l) (prune (n-1) r)), to make an infinite tree finite
07:28:59 <lmj> Is the structure-filling optimized away, or is there actually a temporary tree (for instance) filled with functions?
07:30:16 <lpaste_> aweinstock revised “Applicative instance for tree”: “Applicative instance for tree” at http://lpaste.net/145381
07:30:55 <aweinstock> t0by: (pure 0 :: Tree Int) will be infinite, but (prune 5 (pure 0 :: Tree Int)) isn't
07:31:14 <aweinstock> Ferdirand: the revised version satisfies the Applicative laws?
07:32:07 <Ferdirand> aweinstock: i am no expert on this
07:32:15 <trubert7> what is `putStrLn "foo"` evaluated to WHNF?
07:32:16 <Ferdirand> but if ZipList does, probably this one does too
07:32:30 <Darwin226> Say I have `data Color = Red | Green | Blue`. What's the best way to go about using this type in an unboxed vector? Ideally, I'd like it to have the performance characteristics of something like `Vector Word8` but the typesafety of `Vector Color`
07:33:21 <tobiasBora> Hello !
07:33:52 <tobiasBora> I'm trying to understand some stuff about monad, but it's not really clear in my mind... Is is possible to "mix" the monads ?
07:34:05 <tobiasBora> For example
07:34:42 <tobiasBora> I'm using this package : https://hackage.haskell.org/package/webdriver
07:35:28 <tobiasBora> and this package uses a monad
07:35:41 <apriori> tobiasBora, yo're not quite done with your question, but I guess you mean using monad transformers with mixing - but we will see
07:36:06 <t0by> Hello, near namesake
07:36:22 <tobiasBora> I found a function : Test.WebDriver.Commands getText :: WebDriver wd => Element -> wd Text
07:37:05 <tobiasBora> and I would like to write the Text on the standard output with something like "myText <- getText el; putStrLn myText"
07:37:47 <tobiasBora> However Haskell says me "Wrong man ! putStrLn is IO, and you are dealing with wd monad, don't try to **** me !"
07:37:57 <dzhus> tobiasBora: WD monad is rooted in IO. Use liftIO to get back to IO.
07:37:59 <sbrg> tobiasBora: Yes -- depending on the monad, you can sometimes lift computations
07:38:05 <sbrg> so yeah, what dzhus said
07:38:18 <sbrg> so: liftIO $ putStrLn myText
07:38:24 <aweinstock> Darwin226: You'd need to implement Unbox for Color
07:39:01 <aweinstock> Darwin226: which depends on having instances for (Vector Vector Color) and (MVector MVector Color), if I'm reading https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Unboxed.html correctly
07:39:54 <Darwin226> aweinstock: Yeah, I was thinking it would be something along those lines. I'm kind of worried if I lose the benefits of having an unboxed vector if every time there's a manual conversion from Word8 to my type and back.
07:40:05 <fryguybob> dzhus: swapTMVar would need a different type if it always wrote the value even if the variable was empty.
07:40:19 <t0by> aweinstock, thank you very much
07:40:22 <aweinstock> :t (toEnum, fromEnum)
07:40:23 <lambdabot> (Enum a, Enum a1) => (Int -> a, a1 -> Int)
07:40:51 <Darwin226> aweinstock: I guess I actually want `data Color = R | G | B` to have the performance characteristics of `newtype Color = Color Word8`
07:40:53 <aweinstock> Darwin226: I'm pretty sure Int is fixed-size, I'm not sure whether toEnum and fromEnum are free though
07:40:54 <dzhus> fryguybob: if the variable was empty takeTMVar would block then
07:41:18 <aweinstock> Int is 4-8 bytes though (depending on archtecture)
07:41:19 <fryguybob> dzhus: Right, that's what the retry is doing.
07:42:19 * tobiasBora TobiasBora is trying liftIO
07:42:22 <dzhus> fryguybob: why is explicit retry used instead of relying on takeTMVar semantics?
07:42:26 <aweinstock> Darwin226: possibly try unsafeCoerce, but be very careful (unsafeCoerce is guarenteed to be zero-cost, but will cause segfaults if the data types don't have the same representation)
07:42:35 <Darwin226> aweinstock: Yeah but I'm not that worried about the size of the vector. I'm worried about killing cache locality by making a new Color on the heap every time I access an element in my Vector.
07:43:22 <aweinstock> also, are you sure that `data Color = R | G | B` is what you want? that's only a 3 color palette
07:43:45 <Darwin226> aweinstock: Yeah, it's just an exmample of some enum.
07:43:48 <fryguybob> dzhus: Because that involves an extra write.
07:44:12 <fryguybob> dzhus: A sufficiently smart compiler could get rid of that write, but GHC is not such a compiler.
07:44:57 <tobiasBora> dzhus: sbrg Great that's it, thank you !
07:45:00 <dzhus> fryguybob: Ah, I get it now. takeTMVar does read AND write, right. Thanks!
07:45:31 <Darwin226> aweinstock: Yeah see, https://hackage.haskell.org/package/vector-th-unbox-0.2.1.3/docs/Data-Vector-Unboxed-Deriving.html
07:45:57 <Darwin226> aweinstock: The strategy this uses also seems to be to map my type to something that already has Unbox and then back again when I lookup
07:46:41 <Darwin226> aweinstock: I don't know how smart GHC is about these things but if it does a heap allocation every time than it's kind of pointless using an unboxed vector in the first place since I'll be jumping to some random memory location on every read
07:47:12 <aweinstock> Darwin226: measure it and see whether it helps?
07:48:06 <Darwin226> aweinstock: That's probably the best approach but it's kind of hard to think of a benchmark that would isolate cache locality problems like this.
08:00:23 * hackagebot data-layer 1.0 - Data layering utilities. Layer is a data-type which wrapps other one, but keeping additional information. If you want to access content of simple newtype object, use Lens.Wrapper instead.  https://hackage.haskell.org/package/data-layer-1.0 (danilo2)
08:03:16 <Guest4729> Um. Folks?
08:04:04 <Guest4729> Is anyone alive here by any chance?
08:04:48 <geekosaur> nope. 1500+ people all dead
08:04:54 <bergmark> or robots
08:05:00 <Guest4729> Certainly seems like it. : /
08:05:37 <Guest4729> I am here coz I am kinda fed up with Haskell right now. 
08:05:39 <Guest4729> Sadly.
08:05:51 <tdammers> that doesn't compute
08:05:52 <Zekka|Sigfig> Guest4729: I’m around, little busy though
08:05:58 <Zekka|Sigfig> What’s up?
08:06:10 <apriori> Guest4729, so in for venting some steam, eh? :)
08:06:18 <Guest4729> Yeah!
08:06:45 <apriori> then shoot ^^
08:06:48 <Guest4729> My prof has asked to make me a chess engine entirely in Haskell.
08:07:25 <Guest4729> I am kinda stuck because I cant modify the game state and need too many variables and have to pass too many arguments to functions!
08:07:38 <Guest4729> I'll confess that my Haskell is limited.
08:07:46 <mnoonan> records are your new friend
08:07:49 <apriori> Guest4729, that might be the issue :)
08:08:09 <apriori> Guest4729, records/lenses.. have fun learning 100+ operators.. nah, joking. I guess like 5 suffice
08:08:14 <Zekka|Sigfig> Guest4729: You can get what’s effectively implicit arguments with Reader, and implicit mutable arguments with State
08:08:17 <bartavelle> Guest4729, not sure how that would help you, but threading arguments is handled by the Reader monad, theading state by the State monad, and manipulating nested data structures by the lens library
08:08:19 <bergmark> Guest4729: are you familiar with the Reader and Writer monad transformers?
08:08:35 <Zekka|Sigfig> Lens is a popular tool to make this easier although imho it’s not necessary
08:09:07 <bartavelle> like many things, it becomes necessary once you have used it !
08:09:08 <Guest4729> Wait, "records/lenses". What's that?!
08:09:28 <Zekka|Sigfig> Record types are types with named fields
08:09:38 <bartavelle> records is the action of naming the "slots" in your constructors, like Foo { _bar :: Int, _baz :: Char }
08:09:41 <Zekka|Sigfig> Lenses are a particular kind of accessor function that have gotten very popular recently
08:10:03 <apriori> Guest4729, data SomeRecord = SomeRecord { someField :: someFieldType }
08:10:24 * hackagebot haeredes 0.4.4 - Confirm delegation of NS and MX records.  https://hackage.haskell.org/package/haeredes-0.4.4 (MichaelOrlitzky)
08:11:08 <Guest4729> Okay, slow down please! I am gonna look all this up and be back in a few mins!
08:11:34 <Zekka|Sigfig> Guest4729: Poke us if you want usage examples
08:11:48 <Zekka|Sigfig> Heads up, lenses are kind of tricky imho (records are not that tricky)
08:12:00 <Guest4729> Alright. Thank you. :) I'll be sure to. :P
08:12:07 <bartavelle> start with records
08:12:37 <tobiasBora> I would like to write the utf8 key "U+E009", how could I write it with only ascii character in a Text entry ?
08:13:29 <Zekka|Sigfig> tobiasBora: I’m not sure why you want to do this, but here is what Python says:
08:13:31 <Zekka|Sigfig> >>> u"\ue009".encode("utf8")
08:13:32 <Zekka|Sigfig> '\xee\x80\x89'
08:13:39 <quicksilver> no
08:13:43 <quicksilver> Text is not UTF8
08:13:45 <quicksilver> so that would be wrong
08:13:45 <mnoonan> Guest4729: see GameState in http://projects.haskell.org/operational/examples/TicTacToe.hs.html for example
08:13:55 <Zekka|Sigfig> Well, he said he was using ascii
08:14:05 <Zekka|Sigfig> My parse was that he capitalized “Text” for no obvious reason
08:14:29 <quicksilver> \xe009
08:14:33 <Zekka|Sigfig> (I like your parse better now, in which case my response is just “why would you want to do that, given that Text can unambiguously represent unicode characters”)
08:14:38 <Zekka|Sigfig> characters?*
08:14:45 <quicksilver> because he's typing in an ascii source file
08:14:56 <quicksilver> so he can't put U+E009 in literally
08:14:58 <Zekka|Sigfig> Oh! Wow, that’s a way better parse than mine
08:15:01 <Zekka|Sigfig> My parsing skills ned work
08:15:06 <quicksilver> > "this works though \xe009"
08:15:07 <lambdabot>  "this works though \57353"
08:15:31 <quicksilver> tobiasBora: ^^
08:15:51 <quicksilver> and with overloaded strings that works for Text too.
08:15:57 <quicksilver> without overloaded strings, just `pack` it.
08:17:11 <Guest4729> On a completely unrelated note, I'll say as overloaded strings are mentioned:
08:17:18 <tobiasBora> I talk about Text because it's the type they ask here: https://hackage.haskell.org/package/webdriver-0.0.1/docs/Test-WebDriver-Commands.html#g:8
08:17:23 <tobiasBora> (see sendKeys)
08:17:29 <Guest4729> I wished those ByteStrings were default 'Strings' in Haskell.
08:17:32 <Zekka|Sigfig> tobiasBora: You should probably ignore me fwiw because I completely misunderstood you
08:17:49 <Guest4729> Aren't they much in every aspect as compared to our [Char]s?
08:17:54 <quicksilver> bytestrings would be a poor string
08:18:01 <quicksilver> do you mean Text, Guest4729 ?
08:18:06 <Zekka|Sigfig> my level of misunderstanding was beyond the pale, it was like D. G. Leahy-level *opposite* understanding
08:18:16 <geekosaur> Haskell Char is a Unicode codepoint, not a byte like in C
08:18:31 <Guest4729> I mean, Data.ByteString s
08:18:32 <geekosaur> > maxBound :: Char
08:18:34 <lambdabot>  '\1114111'
08:18:58 <Guest4729> @quicksilver , why would they be poor strings?
08:18:58 <lambdabot> Unknown command, try @list
08:19:11 <geekosaur> for the reason I just pointed out?
08:19:11 <Guest4729> quicksilver , why would they be poor strings?
08:19:18 <quicksilver> Guest4729: because they are strings of 8-bit words
08:19:28 <quicksilver> Guest4729: and that's not a good representation for Char
08:19:50 <Zekka|Sigfig> Haskell’s Chars can still only be two bytes wide, right?
08:19:57 <quicksilver> nope
08:19:58 <Zekka|Sigfig> Or is my memory failing me?
08:20:05 <geekosaur> siiigh
08:20:09 <geekosaur> > maxBound :: Char
08:20:09 <quicksilver> haskell chars go up to 1114111
08:20:10 <lambdabot>  '\1114111'
08:20:13 <quicksilver> as geekosaur just showed
08:20:20 <Zekka|Sigfig> Oh. Screw my memory then!
08:20:31 <quicksilver> which is 0x10FFFF
08:20:32 <geekosaur> goes up to U+1FFFF
08:20:34 <geekosaur> er, yes
08:20:39 <geekosaur> 10FFFF
08:20:54 * hackagebot pandoc 1.15.2.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.15.2.1 (JohnMacFarlane)
08:20:56 * hackagebot concurrent-output 1.7.1 - Ungarble output from several threads or commands  https://hackage.haskell.org/package/concurrent-output-1.7.1 (JoeyHess)
08:20:56 <Zekka|Sigfig> Yeah, that’s enough evidence. For some reason I had a strong memory of it using an alternate representation that couldn’t
08:21:08 <quicksilver> on unix it actually uses wchar_t
08:21:11 <quicksilver> which is a whole 32 bits
08:21:21 <geekosaur> Zekka|Sigfig, that's actually what Text uses internally
08:21:22 <quicksilver> although it only really needs 21 of them
08:21:34 <geekosaur> it's UTF16 and uses surrogate pairs for the higher ones
08:21:40 <quicksilver> text uses UTF-16, but that can still represent the higehr stuff
08:21:46 <Zekka|Sigfig> geekosaur: Oh yeah, maybe that’s what I remembered
08:21:55 <lonokhov> Is there a fast immutable hash table package with only "fromList" construction? Or I should just use unordered-containers?
08:22:02 <Zekka|Sigfig> quicksilver: Yeah, and it can do it transparently with overloaded strings, right?
08:22:23 <quicksilver> overloadedstrings doesn't change much, it's just about how you write your source code
08:22:32 <quicksilver> it is a minor convenience
08:22:41 <Zekka|Sigfig> Yeah, but compare Java where you have to manually transcribe surrogate pairs
08:22:54 <quicksilver> you could always have written foo :: Text; foo = pack "emoji goes here"
08:22:56 <Zekka|Sigfig> Are there any operations which can split your surrogate pairs unintentionally?
08:23:15 <quicksilver> Zekka|Sigfig: sure, but you don't even need overloaded strings :) you just need `pack` to work.
08:23:23 <quicksilver> overloadstrings just save you 5 characters
08:23:32 <quicksilver> > length "pack "
08:23:33 <lambdabot>  5
08:23:44 <quicksilver> maybe 7, you might need ()
08:23:45 <Zekka|Sigfig> quicksilver: I’ll put it this way: in a language that implements this feature I expect ‘pack’ to work more than I expect string literals to work
08:24:05 <quicksilver> in niether case do you manually do your surrogate pairs, anyhow
08:24:17 <quicksilver> if you treat your Text as a sequence of Char then nothing you can do breaks the pairs
08:24:31 <quicksilver> I don't know if other Text functions might accidentally. It's conceivable.
08:25:48 <Zekka|Sigfig> It’s cool if the function is literally designed to operate utf16thing-by-utf16thing, but not if it’s a surprise behavior in a related function
08:25:53 <Zekka|Sigfig> in an unrelated function*
08:34:52 <tobiasBora> quicksilver: Zekka|Sigfig : the \xe009 works great ! Thank you !
08:36:33 <quicksilver> :)
08:38:48 <apriori> does anyone here happen to work with SPIR-V
08:38:59 <apriori> more precisely, the generation of it?
08:39:21 <tommd> apriori: You might want to ask in haskell-game
08:39:37 <tommd> If they did use spir-v then they might be in that channel (too), which is also lower traffic.
08:39:57 <apriori> thank you
08:50:02 <danza> can anybody give me some hints about finding a job with Haskell? i am having some hard times with that ... i think that i looked into all conventional and unconventional platforms, without much luck
08:50:55 * hackagebot ghci-ng 10.0.0 - Next generation GHCi  https://hackage.haskell.org/package/ghci-ng-10.0.0 (ChrisDone)
08:51:56 <t0by> danza, you could write a job ad scraper with haskell, that would qualify :P
08:52:08 <Ankhers> danza: I think most people have issues with that. Unfortunately, there are still not a plethora of companies hiring Haskell devs. Most of the companies I've seen hiring, are not allowing remote workers.
08:52:52 <danza> yep, i am looking for something from remote, so this is blocking a lot of opportunities
08:53:20 <danza> on the other hand, given how offers are spread all over the world, i think that remote could be accepted a bit more ...
08:55:19 <danza> alright i thought that someone here had access to some secret mailing list where desperate employers were continuously looking for big amounts of Haskell devs :D
08:55:57 <bitemyapp> Easiest way to go is to find a company willing to try a team+project in Haskell
08:56:05 <bitemyapp> but that's easier to pull off if you can train the team yourself
08:57:33 <danza> i don't want to ask to a company allowance for the technology, i would rather find a job where they don't care about the tech, and i choose it
08:57:42 <bitemyapp> that's even better, yes.
08:58:29 <danza> unfortunately these seem to be either: CTO jobs (no remote) or jobs found online on Upwork on Freelancer, where usually they care more for the cheapest rates than for the quality of the result
08:58:41 <quicksilver> no company would not care *at all* about the tehc
08:58:44 <quicksilver> that would be daft.
08:58:55 <quicksilver> the tech choice has implications for maintenance, deployment etc.
08:59:08 <quicksilver> it's more, prepared to give it a go, like bitemyapp said
09:00:27 <danza> i am the tech person, right? why should i be allowed or told which technology to use? oh well this is going into #haskell-blah i guess
09:00:42 <Zekka|Sigfig> danza: Because if you’re wrong your boss will be held accountable!
09:01:00 <quicksilver> if you are the only tech person, perhaps, yes.
09:01:09 <quicksilver> even then they have to maintain it after you are gone
09:01:28 <danza> i can show that it is easier to find Haskell devs than Angular devs :D
09:03:53 <Ankhers> .join @haskell-blah
09:03:54 <Ankhers> wow
09:03:56 <Ankhers> I'm badd.
09:08:54 <sm> why are we getting a new call for HCAR entries ? I submitted one for the oct deadline
09:09:12 <SrPx> What is wrong in this morte expression? (λ (idType : *) → λ (id : idType) → (id (∀(t : *) → ∀(x : t) → t))) (∀(t : *) → ∀(x : t) → t) (λ(a : *) → λ(x : a) → x) -- The compiler says "Error: Only functions may be applied to values"...
09:09:41 <sm> never mind
09:09:57 <tobiasBora> I still have a problem with Monad (really I don't like it...) : I have in this module : http://hackage.haskell.org/package/robot-1.2/docs/Test-Robot.html
09:10:28 <nkaretnikov> how do i implement a timer, i.e. a counter that increments every second/minute, etc.?  (i don't want to rely on the machine's clock)
09:10:35 <tobiasBora> Hum use this one instead : https://hackage.haskell.org/package/robot-1.4/docs/Test-Robot.html
09:10:46 <tobiasBora> Well I defined slowTap x = x `hold` sleep 0.1
09:11:02 <tobiasBora> When I do "runRobot (slowTap _A)" it works,
09:11:35 <tobiasBora> but now I would like to do something like "runRobot (fmap slowTap [_A,_B,_C])"
09:11:47 <tobiasBora> However I have tiping error
09:11:55 <tobiasBora> *typing
09:12:16 <tobiasBora> What is the good function to use ? I tried fold, but it doesn't work...
09:13:16 <glguy> runRobot (mapM_ slowTap [_A,_B,_C])
09:14:02 <tobiasBora> glguy: Oh yes I forgot mapM_... Thank you !
09:14:50 <tobiasBora> By the way, do you know if you can easily convert a string like "hello" into [_H,_E,_L,_L,_O] ?
09:15:06 <tobiasBora> (I don't really want to do an horrible case of)
09:19:53 <bergmark> tobiasBora: you can do it with splitOn from the split package, and intersperse/intercalate
09:20:10 <glguy> bergmark: No, this is slightly different
09:20:23 <glguy> tobiasBora: needs a function: Char -> Switch
09:20:28 <tobiasBora> bergmark: _A isn't a string...
09:20:53 <glguy> tobiasBora: I didn't see anything in the library to help you lookup Switch values
09:20:55 <bergmark> oh
09:21:03 <tobiasBora> glguy: Yes... I just saw that with the ascii code I can do something like read "Key <my ascii number>"
09:22:00 <glguy> Yeah, just make sure you capitalize the letters first
09:23:53 <nkaretnikov> okay, i've been told to checkout monotonic clock
09:28:01 <obadz> tobiasBora: implement a read instance for your ADT
09:28:05 <obadz> tobiasBora: then map read
09:28:27 <tobiasBora> glguy: obadz : I did that :
09:28:29 <tobiasBora> pressable_of_char :: Char -> RT.Switch
09:28:31 <tobiasBora> pressable_of_char x = read $ "Key " ++ (show (DC.ord x))
09:28:32 <glguy> This isn't a job for Read
09:28:57 <obadz> come to think of it glguy is right
09:28:57 <tobiasBora> (it's dirty, but I don't know any other solution...)
09:29:03 <nkaretnikov> ah, i totally forgot about this article: http://chrisdone.com/posts/measuring-duration-in-haskell
09:29:44 <glguy> tobiasBora: It's going to be more like this:   pressable_of_char = Key . fromIntegral . ord . toUpper
09:30:08 <glguy> If you want to support uppercase letters then you can't go directly to Switch
09:30:34 <glguy> You'll have to build "Robot"s so you can hold shift
09:30:42 <obadz> tobiasBora: if you want to avoid the case statement, maybe write pressable_of_char c = readMaybe . ['_', Char.toUpper c]
09:31:03 <obadz> without the .
09:31:04 <glguy> No, that's not going to work, _A is a Haskell name
09:31:13 <glguy> not something you can build via String
09:31:23 <obadz> isn't _A one of the cases of his ADT ?
09:31:33 <glguy> no
09:31:43 <obadz> what's the type of _A ?
09:31:53 <glguy> https://hackage.haskell.org/package/robot-1.4/docs/Test-Robot.html
09:31:55 <glguy> The docs are here
09:32:54 <obadz> ah it's just a value
09:35:23 <ocec> Is there any real reason to prefer one or the other out of ExceptT and EitherT?
09:35:40 <obadz> ocec: ExceptT is the latest and greatest imho
09:36:03 <glguy> EitherT is old tech
09:36:26 <Jello_Raptor> hmm, is there somelike hoogle that will work with kinds? I'm looking for existing haskell types that have kind "(* -> *) -> *" to see if any of them fit what I want to do
09:36:35 <Jello_Raptor> something like*
09:37:13 <ocec> Hm, thanks. Should the EitherT documentation have some indication of that?
09:37:51 <obadz> ocec: it says Deprecated in favor of either
09:38:21 <obadz> actually there's another EitherT in either that doesn't say that
09:38:55 <glguy> ocec: Probably not. It's not going anywhere, it just predates exceptT being added to transformers
09:39:15 <ocec> kk
09:39:20 <tobiasBora> obadz: Yes, it's not a string, that's why I do "read "Key " ++ (ord x)" to convert it in key...
09:39:33 <obadz> tobiasBora: I would use glguy's solution
09:39:43 <glguy> tobiasBora: You shouldn't be using read for this, did you see the code I wrote above?
09:39:44 <obadz> tobiasBora: (i.e. go through numbers instead)
09:40:56 * hackagebot hsshellscript 3.3.4 - Haskell for Unix shell scripting tasks  https://hackage.haskell.org/package/hsshellscript-3.3.4 (VolkerWysk)
09:45:50 <tobiasBora> glguy: Oh sorry I missed it. Thank you !
09:48:42 <tobiasBora> I also have a very annoying problem with the difference between [Char] and T.Text..
09:48:47 <tobiasBora> I always have this error   Couldn't match expected type `[Char]' with actual type `T.Text'
09:49:01 <Jello_Raptor> hmm, given "Foo f a = a -> f a" to represent "Foo f :: * -> *" without wrapping things in a data or new type? 
09:49:04 <tobiasBora> so I play with Data.Text.(un)pack, but it's pretty annoying...
09:49:16 <tobiasBora> I tried to put at the very beginning {-# LANGUAGE OverloadedStrings #-}
09:49:25 <tobiasBora> bug it doesn't solve all my problems
09:49:28 <tobiasBora> Any solution ?
09:49:30 <glguy> OverloadedStrings is for string literals
09:49:44 <ski> Jello_Raptor : you can't partially apply type synonyms, if that's what you're asking about
09:49:49 <Cale> tobiasBora: Those are two distinct types, so you should expect to have to convert between them
09:49:55 <glguy> otherwise you have to convert between them, or avoid using one of them
09:49:58 <veyn> I think this should work, It does't, I need to know if I'm crazy or not
09:50:02 <veyn> length.show
09:50:06 <Cale> tobiasBora: I guess the solution is just to be more aware of which type you're using.
09:50:19 <bollu> guys, I managed to implement the Cont monad on my own(thanks johnw :). So now what do I do with it?
09:50:23 <Jello_Raptor> ski: partially applying a type synonym is exactly what I want to do, but there's probably some type operators that I could use to get the same effect 
09:50:28 <bollu> like, Cont doesn't really *do* anything special, right?
09:50:49 <bollu> the Cont monad simply "uncontinuates" the values and extracts the values, while "return" turns it back into a continuation
09:51:04 <bollu> so, like, what can I do with it? (callCC?) how?
09:51:19 <Cale> Yeah, callCC is the main thing you'd want to implement first.
09:51:37 <ski> Jello_Raptor : note that if you have e.g. `type MyMonad = StateT MyState IO', then you can use `MyMonad', but if you define it as `type MyMonad a = StateT MyState IO a', then you must apply `MyMonad' like in `MyMonad T'
09:51:53 <Cale> (I don't understand most of what you just said regarding "uncontinuates"...)
09:53:15 <ski> bollu : you could also implement `shift' and `reset'
09:53:46 <tobiasBora> Cale: The OverloadedString convert all "xxx" strings into Text ?
09:54:20 <Cale> It makes "xxx" strings polymorphic by automatically applying fromString to them, which *may* convert them to Text if that's what type is required.
09:54:39 <johnw> bollu: the ability to write and use callCC is pretty much the quintessential operation; shift and reset are variations on a theme
09:55:06 <Cale> tobiasBora: It's exactly like what goes on with Num and integer literals
09:55:11 <bitemyapp> Cale: we just added an explanation of that to the book
09:55:20 <bitemyapp> Cale: showed fromInteger/fromRational/fromString :)
09:55:33 <tobiasBora> Cale: Ok thank you.
09:55:52 <Cale> tobiasBora: Where fromInteger is automatically applied to literals such as 5 so that they can be treated as Integer, Double, Rational, Complex Float, or what-have-you
09:56:25 <Cale> bitemyapp: cool
10:01:57 <tobiasBora> Cale: Yes, I got it, thank you ;)
10:06:25 <t0by> > [1,2,3,4] >>= (\x -> [x+1]) -- Help. Why not [[2], [3], [4], [5]]?
10:06:26 <lambdabot>  [2,3,4,5]
10:07:08 <Hijiri> t0by: (>>=) maps the function then flattens the list
10:07:31 <Hijiri> it's like first mapping the function then applying concat
10:07:46 <t0by> Hijiri, what does "flatten" mean in this context?
10:07:57 <t0by> in Mathematica, "flatten" means [[1,2,3]] -> [1,2,3]
10:08:02 <Hijiri> if you have a list of lists, make a list that's just the concatenation of the lists
10:08:06 <t0by> mh.
10:08:20 <Hijiri> so basically the same as mathematica it looks like
10:08:20 <t0by> > [1,2,3,4] >>= (\x -> [[x+1]]) -- Let's see.
10:08:22 <lambdabot>  [[2],[3],[4],[5]]
10:08:30 <t0by> Ah.
10:08:34 <Ankhers> > concat [[1],[2],[3],[4]]
10:08:36 <lambdabot>  [1,2,3,4]
10:09:23 <ski> > map (\x -> [x+1]) [0,1,2,3]
10:09:24 <lambdabot>  [[1],[2],[3],[4]]
10:09:34 <ski> > concatMap (\x -> [x+1]) [0,1,2,3]
10:09:36 <lambdabot>  [1,2,3,4]
10:09:39 <t0by> Hijiri, is this build *into* >>=? 
10:09:44 <ski> `concatMap' is `(=<<)'
10:09:50 <ski> t0by ^
10:10:00 <Hijiri> t0by: it's how >>= is defined for lists
10:10:10 <ski> @src [] (>>=)
10:10:10 <lambdabot> xs >>= f = concatMap f xs
10:10:38 <t0by> @src Maybe (>>=)
10:10:39 <lambdabot> (Just x) >>= k = k x
10:10:39 <lambdabot> Nothing  >>= _ = Nothing
10:10:47 <mada> that way you can compose many functions that take a list and return many lists
10:11:03 <t0by> > Just 1 >>= (x -> (Just x)) -- erm
10:11:04 <lambdabot>      Pattern syntax in expression context: x -> (Just x)
10:11:05 <ski> `concat' of course only flattens the outermost two list levels
10:11:32 <ski> > concat [[[0,1],[2,3]],[[4,5],[6,7]]]
10:11:34 <lambdabot>  [[0,1],[2,3],[4,5],[6,7]]
10:11:51 <ski> > concat [["01","23"],["45","67"]]
10:11:53 <lambdabot>  ["01","23","45","67"]
10:12:07 <Ankhers> > Just 1 >>= (\x -> (Just x)) -- t0by You missed a `\'
10:12:09 <lambdabot>  Just 1
10:12:17 <t0by> oopsie
10:12:20 <ski> those two works similarly. `concat' treats the inner list (alternatively string) as "atomic", wrt to the flattening/concatenation
10:15:18 <elkorn> hello everyone. I'm having another noobish problem :) namely, i seem to have configured modules for my project incorrectly, cabal does not recognize them. Here's the build output: http://sprunge.us/OEbg, the directory tree: http://sprunge.us/KCBM and the cabal file: http://sprunge.us/DJiM?haskell. Also, here's Table.hs: http://sprunge.us/aUCV?haskell
10:15:29 <elkorn> (all the other modules are defined along these lines)
10:15:40 <elkorn> what is the problem?
10:17:21 <bergmark> elkorn: You need to have a PrepareDB folder on the same level as the cabal file
10:17:22 <glguy> elkorn: Your cabal file says your source files are in the "src" directory
10:17:35 <bergmark> also that:-)
10:18:02 <glguy> And Main.hs shouldn't be inside PrepareDB/
10:18:34 <glguy> Oh, unless it's only for the prepare-db case below..
10:18:36 <elkorn> glguy, yes but for the `rest-api` module
10:18:47 <elkorn> yes, i'm trying to `cabal build prepare-db`
10:18:58 <elkorn> bergmark, I do have it there
10:19:14 <glguy> elkorn: If your source directory is PrepareDB, then you need another PrepareDB directory for the modules
10:19:31 <glguy> e.g. PrepareDB/PrepareDB/Tables/Recipe.hs
10:19:44 <glguy> <source directory>/Module/Module/Module.hs
10:20:04 <elkorn> the tree looks like this: http://sprunge.us/dEOL
10:20:15 <elkorn> ahhhh
10:20:23 <elkorn> :)
10:20:27 <glguy> probably make a new rest-src directory
10:20:33 <glguy> move stuff into that and change the hs-source-dir
10:23:49 <elkorn> thanks!
10:25:14 <latk> I'm getting the error "user error (RTS doesn't support multiple OS threads (use ghc -threaded when linking))" when trying to run a binary built with stack. How do I solve this?
10:26:58 <glguy> latk: Add "-threaded" to the "ghc-options:" section for the executable in its cabal file
10:27:04 <kadoban> latk: Add -threaded to the ghc options inside the .cabal file. I believe 'stack new blah' will give you a project that already has that set up (might require the newest 'stack'), so you can peak at what it does.
10:27:25 <latk> Ah, ghc-options. Wasn't sure what I should be looking for.
10:28:26 <t0by> pure 1 >>= (+ 1) -- good people, why not 2?
10:28:59 <latk> glguy, kadoban: That has done it. Thanks!
10:29:19 <t0by> here (http://learnyouahaskell.com/a-fistful-of-monads) it says that "return x >>= f is the same damn thing as f x", so I would expect that to work
10:29:24 <Taneb> t0by: well, that requires a Num instance for ((->) e)
10:29:35 <glguy> Taneb: almost
10:29:41 <glguy> pure 1 >>= (+ 1) :: (Monad m, Num (m b)) => m b
10:29:48 <t0by> Or at least Just 1 >>= (+ 1)
10:29:49 <Taneb> Ach
10:30:04 <t0by> since "For the Maybe monad return is defined as Just."
10:30:14 <ReinH_> t0by: but there's no return there.
10:30:17 <glguy> do x <- pure 1; x+1
10:30:25 <t0by> ReinH_, ^
10:30:30 <glguy> the result of "x+1" has to have the type of the monad for the rest of the do-expression
10:30:57 <t0by> glguy, I haven't caught up with do-expressions yet
10:31:06 <ReinH> t0by: ?
10:31:32 <t0by> ReinH, "t0by: but there's no return there", but <t0by> Or at least Just 1 >>= (+ 1) since "For the Maybe monad return is defined as Just."
10:31:45 <ReinH> Yes, that's a response to that statement
10:32:12 <t0by> ReinH, but if return ==def== Just, shouldn't Just 1 >>==(+1) work just as well?
10:32:15 <glguy> Just 1 >>= \x -> return (x+1)
10:32:19 <ReinH> There's no return there.
10:32:21 <glguy> return is something you have to write
10:32:29 <glguy> it's a function 
10:32:48 <ReinH> What does the definition of return have to do with Just 1 >>= (+1)?
10:33:08 <t0by> Bu-bu-but, it says it's defined as Just. Which in my head implies "interchangeable"
10:33:16 <kadoban> :t (>>=)
10:33:17 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:33:17 <t0by> Well, never mind.
10:33:24 <ReinH> There's no return there,
10:33:28 <ReinH> You don't use return.
10:33:32 <ReinH> Return doesn't exist in that expression
10:33:38 <ReinH> Not sure how else I can put it.
10:33:56 <t0by> ReinH, that much I got ;)
10:33:58 <kadoban> t0by: You have 'm a' on the left, but the thing on the right isn't (a -> m b), it's a -> b
10:34:59 <kadoban> > fmap (+1) (Just 1) -- by the way <---
10:35:00 <lambdabot>  Just 2
10:35:16 <kadoban> If that's what you're trying to do, you don't need (>>=), just fmap.
10:35:17 <apriori> or if you want to see return: 
10:35:23 <apriori> > Just 1 >>= return . (+1)
10:35:26 <lambdabot>  Just 2
10:35:58 * hackagebot type-unary 0.2.21 - Type-level and typed unary natural numbers, inequality proofs, vectors  https://hackage.haskell.org/package/type-unary-0.2.21 (ConalElliott)
11:06:08 * hackagebot atp-haskell 1.7 - Translation from Ocaml to Haskell of John Harrison's ATP code  https://hackage.haskell.org/package/atp-haskell-1.7 (DavidFox)
11:11:08 * hackagebot logic-classes 1.7 - Framework for propositional and first order logic, theorem proving  https://hackage.haskell.org/package/logic-classes-1.7 (DavidFox)
11:15:31 <lpaste_> aweinstock pasted “Monad instance for Tree” at http://lpaste.net/145390
11:16:48 <aweinstock> does anyone know if it's possible to make a valid instance of Monad for the Tree datatype in that lpaste (assuming the version of join I provided is either unlawful, or inconsistant with the included Applicative instance)
11:18:36 <mauke> huh. a ZipTree
11:20:32 <aweinstock> mauke: I was helping someone with it earlier today, the Monad instance is my own question though
11:21:08 <Cale> If you're doing a zippy instance, it'll be Applicative, but you'll need the trees to be infinite or otherwise forced to be the same shape in order to get a law-abiding Monad instance.
11:21:15 <Cale> Otherwise, you fail on associativity.
11:21:22 <fonzy> hi guys, i am still new to haskell, so I have newbie question, i think: How can I store state in haskell?
11:21:30 <fonzy> I thought of something like this:
11:21:32 <fonzy> echo i = do    line <- getLine    putStrLn ("line " ++ show i ++ ": " ++ line)    echo (i+1)  main = echo 1
11:21:42 <fonzy> but the compiler yells at me
11:21:46 <Cale> fonzy: Start with the most basic thing which can change: function parameters.
11:22:17 <Cale> wait, did you type that with just spaces like that?
11:22:37 <Cale> That looks vaguely okay, if indented correctly.
11:23:04 <fonzy> so, it was indented, but i just pasted it into chat 
11:23:05 <Cale> What error did you get?
11:23:46 <fonzy> compiler said:     Non type-variable argument in the constraint: Num (IO b)     (Use FlexibleContexts to permit this)     When checking that `blah' has the inferred type       blah :: forall t b. Num (IO b) => t -> IO b
11:24:03 <fonzy> in this case echo was called blah
11:24:21 <Cale> did you give an explicit type signature to blah?
11:24:39 <Cale> (if so, try removing it)
11:24:44 <fonzy> nope, I could not image one - I would expec sth like
11:24:50 <aweinstock> echo :: Num a => a -> IO () -- this is what it should look like, probably
11:24:54 <Cale> yes
11:24:54 <fonzy> IO a -> IO ()
11:24:59 <mauke> show your real code
11:25:12 <aweinstock> fonzy: lpaste.net
11:25:14 <Cale> fonzy: No, it shouldn't take an IO action argument, per the code you have there
11:25:19 <gganley> fonzy: have you used lpaste?
11:25:36 <mauke> it sounds like you did 'blah i + 1' instead of 'blah (i + 1)'
11:25:39 <fonzy> i dont know lpaste
11:25:43 <Cale> fonzy: A value of type IO Integer is very very different from an Integer, in the same way as /bin/ls is very very different from a list of files.
11:25:54 <fonzy>     Non type-variable argument in the constraint: Num (IO b)     (Use FlexibleContexts to permit this)     When checking that `blah' has the inferred type       blah :: forall t b. Num (IO b) => t -> IO b
11:25:59 <Cale> http://lpaste.net/
11:26:08 <Cale> ^^ go there, paste your code, give us a link :)
11:26:08 <fonzy> main = do    blah 0  blah val = do       s <- size       line<- getLine       let consoleWidth = width $ fromJust s           consoleHeight = height $ fromJust s           centerY = consoleHeight `div` 2           output = show(centerY) ++ line           l = length output           centerX = (consoleWidth - l) `div` 2        setCursorPosition 0 0       putStrLn $ output       blah val + 1
11:26:10 <Cale> nooo
11:26:14 <mauke> fonzy: stop it
11:26:18 <fonzy> sorry
11:26:18 <Cale> don't paste into IRC
11:26:21 <aweinstock> @quote /bin/ls
11:26:22 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
11:27:09 <mauke> hah, looks like I was right
11:27:15 <mauke> I spot 'blah val + 1' at the end
11:27:22 <fonzy> right
11:27:57 <fonzy> but should I <$> it somehow or how do I? access it in its IO environment
11:28:04 <mauke> what
11:28:08 <aweinstock> :t consoleHeight
11:28:10 <lambdabot> Not in scope: ‘consoleHeight’
11:28:32 <aweinstock> oh, nvm, misread
11:29:00 <Cale> fonzy: A value of type IO t represents some things which could be done in order to produce a result of type t, provided that it terminates normally.
11:29:11 <ski> fonzy : just bracket properly
11:29:18 <aweinstock> fonzy: function application is highest precedence: `blah val + 1` means `(blah val) + 1`, not `blah (val + 1)`
11:29:25 <Cale> fonzy: and in the meantime, which may have any sort of effect that your computer is capable of
11:29:41 <Cale> It's not like "a value of type t in an IO context" at all
11:29:59 <Cale> If anyone told you that, they are themselves probably confused about it :P
11:30:06 <aweinstock> :t Foreign.Storable.poke
11:30:07 <lambdabot> Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> a -> IO ()
11:30:16 <aweinstock> ^ arbitrary memory write primitive :)
11:30:56 <Cale> That is, you should think of values of type IO t as being procedures or programs.
11:31:16 <Cale> (not functions, because there's no parameter)
11:32:54 <fonzy> thanx guys it works - it's always those tiny nifty details you easily overlook as newbie...
11:33:33 <Copperis> Cale, so IO can be thought of as a computation? (I've understood, that two popular ways to understand monads are computations and boxes)
11:33:51 <Cale> Well, IO itself is a type constructor
11:34:00 <Copperis> yup
11:34:07 <Copperis> but like IO String
11:34:21 <Cale> Values of type IO t are computations which may have arbitrary effects before producing a result of type t (provided that they terminate and don't throw an exception)
11:34:22 <aweinstock> Copperis: values of type (IO a) are computations-returning-values-of-type-a, but monads in general aren't computations
11:35:14 <Cale> It's always possible, for any monad M definable in Haskell, to interpret the values of type M t as some sort of computations whose result has type t.
11:35:26 <fonzy> but there must be something more magical about IO besides being a Box. Why is for example <- a keyword and not a function? 
11:35:40 <Cale> But your notion of what a computation is may have to bend a little bit
11:35:49 <Copperis> ok
11:36:02 <Copperis> fonzy, that's just syntactic sugar 
11:36:04 <Cale> fonzy: Well, <- is syntax sugar for using the function (>>=)
11:36:16 <Cale> do v <- x; f v  means  x >>= (\v -> f v)
11:36:21 <t0by> I hate to break the news, but according to this page, "Haskell died in 2003": http://www.geni.com/people/Haskell-Block/6000000032813710913
11:36:22 <kadoban> i.e. Maybe is computations that can fail.  [] is computations in a non-deterministic setting (can have multiple results), etc.
11:36:39 <mauke> do { v <- x; ... } means x >>= \v -> do { ... }
11:36:56 <Cale> t0by: Wrong Haskell, he died in 1982
11:37:09 <Cale> https://en.wikipedia.org/wiki/Haskell_Curry
11:37:23 <t0by> I know, I know :P
11:37:53 <t0by> Then again curried functions are one thing, but blocks are obviously named after that other gentleman.
11:44:22 <koshmar> I just started nicta course. the "introduction" modules (Id,Optional,Validation) is like Id,Maybe,Either monads alternatives. well it seems I get that, but what I do not get is what I should do with them? what is the point of "introduction" modules?
11:44:48 <koshmar> It's like I am missing something...
11:45:18 <koshmar> what should I do with them&
11:45:42 <t0by> besides the fact that let is ugly, what exactly could be the problem with let x = 2 \n in (let y = 3 \n in (x + y))?
11:45:49 <t0by> I get a parse error :(
11:45:57 <dredozubov> koshmar: you program with these concepts
11:46:00 <kadoban> koshmar: If there's no exercises inside, just look at them and realize they exist. You'll probably have to refer back to them as you do other exercises.
11:46:19 <dredozubov> they're really general, so they're everywhere in haskell
11:47:06 <koshmar> well, interesting type of introduction=)
11:47:08 <bitemyapp> koshmar: Identity is for when you need do-nothing additional structure
11:47:37 <bitemyapp> koshmar: Either is so you can have a Functor that is biased to the right side (often used in error handling when you want computation to "stop" on an error or success value)
11:47:38 <lyxia> t0by: Can you lpaste the code?
11:47:49 <bitemyapp> koshmar: Optional is Either without any information for the "fuck-it" case.
11:48:00 <bitemyapp> koshmar: sort of an explicitly typed alternative to null values.
11:48:13 <Copperis> t0by, let x = 2 in (let y = 3 in (x + y))
11:48:29 <Copperis> oh, those were newlines
11:50:03 <koshmar> well, thanks
11:51:16 <koshmar> t0by: you most likely have problem with indention... it is important in haskell
11:53:13 <NeedsQuickEasyHe> Hey guys, I would appreciate some help here, the problem is described in the link as well. Thanks! http://lpaste.net/145395
11:54:46 <Ferdirand> NeedsQuickEasyHe: type Pos = (x,y) ?
11:55:25 <NeedsQuickEasyHe> Holy fak I must be reqally tired, it should be (Int, Int) right?
11:55:26 <lyxia> NeedsQuickEasyHe: length tab <= y || length (head tab) <= x
11:56:01 <NeedsQuickEasyHe> lyxia why <= and not <?
11:56:25 <lyxia> Because lists are 0-indexed, so the last element is at length-1, and index length is out of bounds
11:56:34 <NeedsQuickEasyHe> well on my .hs file I do have type Pos = (Int, Int) so thats not the problem here
11:56:59 <NeedsQuickEasyHe> http://lpaste.net/145396 (updated)
11:57:06 <mauke> the problem is that you're accessing index 3 of a list with indices 0,1,2
11:57:43 <NeedsQuickEasyHe> mauke, how do i make it so that if the coords are too big for that list it still gives me a '#' ?
11:58:00 <lyxia> replace < with <=
11:58:08 <NeedsQuickEasyHe> lyxia gonna try it, wait a sec :)
11:58:10 <mauke> check the index before you use it
11:58:39 <NeedsQuickEasyHe> doesn't work lyxia :(
11:58:41 <lyxia> Also you check that it is equal to one value and then return that value
12:00:33 <NeedsQuickEasyHe> mauke, the problem is that I need it to give me a '#' if the index is too large, if the Pos was (99,99) it should give me a "#"
12:00:44 <mauke> stop repeating at me
12:00:46 <lyxia> NeedsQuickEasyHe: And put the check before.
12:00:50 <mauke> my answer is unchanged
12:00:56 <lyxia> NeedsQuickEasyHe: move the last clause first
12:01:52 <lyxia> NeedsQuickEasyHe: The guards are evaluated top-down, so you are checking that element (x,y) is '#'|' '|'.' before you even checked that the indices are valid
12:01:56 <NeedsQuickEasyHe> lyxia it works! thanks, bless you
12:02:19 <NeedsQuickEasyHe> I need to pay close attention in the future...
12:02:32 <lyxia> NeedsQuickEasyHe: And so my next suggestion was replacing the three other clauses with | otherwise = map reverse tab !! y !! x
12:02:51 <t4nk034> i asked this yesterday as well but didn't get many replies, how do i make this type instance of monad ? http://pastebin.com/2jmQTcpU
12:03:26 <NeedsQuickEasyHe> yeah you're right, I have some useless code there... ty
12:05:40 <mnoonan> t4nk034: looks a lot like a combo of Maybe and State; have you looked at those monad instances for inspiration?
12:08:10 <t4nk034> i know about maybe monad but it isn't very helpful, monads confuse the hell out of me
12:08:44 <Cale> t4nk034: any particular reason why you want the instance of Monad then?
12:08:52 <Cale> Is it just an exercise?
12:09:04 <derekv> can I do this without the if-then-else and lambda ? map (\x -> predicate x then foo x else bar x) 
12:09:51 <Cale> derekv: you're probably not going to do much better (also you're missing an 'if')
12:09:54 <t4nk034> i read the book chapter 8 and want to understand monads before continuing
12:09:57 <ski> derekv : if you define `cond :: (a -> Bool) -> (a -> b) -> (a -> b) -> (a -> b)'
12:10:12 <Cale> t4nk034: fair enough
12:11:05 <derekv> Cale yea I retyped a simpler version
12:11:34 <Cale> t4nk034: So, where do you get stuck?
12:11:43 <Cale> Did you try to implement return?
12:12:31 <Cale> return :: a -> Timeout a
12:12:45 <t4nk034> ma >>= f 
12:13:24 <Cale> Right, so with x >>= f, the idea is that this will result in a Timeout computation that will first run x with the given amount of time remaining
12:13:42 <Cale> and if it fails (producing Nothing), the whole computation fails
12:13:56 <Cale> but if it succeeds with some result v, and some new amount of time remaining
12:14:10 <Cale> then it will run (f v) with that new amount of time remaining
12:14:19 <Cale> and produce the result of that
12:14:27 <Cale> (whether it succeeds or fails)
12:14:40 <Cale> So
12:15:04 <Cale> x >>= f = Tick ... -- we don't have many ways to make Timeout computations apart from using the data constructor yet, so might as well use it
12:15:37 <Cale> x >>= f = Tick (\t -> ...) -- Tick expects a function of type Int -> Maybe (b, Int) here, so that function might as well be a lambda. We now have t :: Int the time remaining
12:16:10 * hackagebot git-annex 5.20151116 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-5.20151116 (JoeyHess)
12:16:22 <Cale> x >>= f = Tick (\t -> case runTimeout x of ... ) -- we first want to run the computation x, and what result we will have depends on its result
12:16:50 <Cale> x >>= f = Tick (\t -> case runTimeout x t of ... ) -- oops, of course, let's pass the initial amount of time remaining, t
12:17:31 <Cale> x >>= f = Tick (\t -> case runTimeout x t of Nothing -> ... ) -- what if it's Nothing? Well, that means we ran out of time. If x runs out of time, then so must the whole computation, so...
12:17:44 <Cale> x >>= f = Tick (\t -> case runTimeout x t of Nothing -> Nothing; ...) -- we produce Nothing in that case
12:18:11 <Cale> x >>= f = Tick (\t -> case runTimeout x t of Nothing -> Nothing; Just (v,t') -> ...) -- what if it succeeds, with result v and new amount of time remaining t'?
12:18:40 <Cale> x >>= f = Tick (\t -> case runTimeout x t of Nothing -> Nothing; Just (v,t') -> runTimeout (f v) t') -- in that case, we run the computation f v with the remaining time on the clock.
12:19:47 <Cale> As it happens we can simplify this code a bit using the Maybe monad instance:
12:20:09 <Cale> x >>= f = Tick (\t -> do (v,t') <- runTimeout x t; runTimeout (f v) t')
12:21:01 <Cale> t4nk034: Make sense?
12:21:47 <ski> `Timeout' being a subquotient of `StateT Int Maybe' ?
12:21:49 <t4nk034> :/ where do we get the t from
12:21:59 <Cale> t4nk034: It's bound by the lambda
12:22:16 <Cale> It's the parameter to the function which we're writing, which is the argument to the Tick data constructor
12:22:45 <Cale> Are you familiar with lambda syntax?
12:22:51 <Cale> > (\x -> x^2) 5
12:22:53 <lambdabot>  25
12:23:32 <ski>   x >>= f = Tick g where g t = ..t..x..f..
12:27:24 <t4nk034> yes but how does the functin know t is the second field 
12:27:38 <Cale> what field?
12:27:56 <Cale> There are no record types here...
12:28:13 <rcrcrc> I'm seeing an issue where some 'forkIO $ forever $ foo >> threadDelay x' processes are sleeping for far too long (over a second too long)
12:28:43 <rcrcrc> the strangest part is that this only happens with compiled code -- the problem doesn't exist while running it in ghci
12:29:06 <rcrcrc> the code is too large to paste in here, but any idea as to why this could be?
12:29:31 <Cale> rcrcrc: According to the documentation for threadDelay: There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run earlier than specified.
12:29:49 <Cale> However, a second too long is a bit surprising.
12:29:56 <opqdonut> rcrcrc: how many of these threads are there? 
12:30:03 <Cale> Do you have an enormous number of threads?
12:30:07 <rcrcrc> opqdonut: always 3
12:30:08 <opqdonut> rcrcrc: also, this sounds like a job for ThreadScope (a debugging tool)
12:30:13 <opqdonut> ok 3 sounds reasonable
12:30:23 <rcrcrc> and no threads are doing large amounts of work
12:30:43 <rcrcrc> top tells me I'm staying below 5% cpu and memory usage
12:30:49 <Cale> and this is with -threaded?
12:31:49 <Cale> If not, then try -threaded and see if it behaves better.
12:31:56 <Cale> (while compiling)
12:31:57 <rcrcrc> Cale: ug no - I didn't know that that was required
12:32:04 <Cale> It's not strictly required
12:32:07 <rcrcrc> why would that be by default off?
12:32:12 <rcrcrc> oh, what does it do?
12:32:29 <Cale> It uses the multi-threaded runtime system rather than the single-threaded one.
12:32:39 <rcrcrc> (Also thank you, you've completely fixed my problem!)
12:32:42 <deech> Hi all, I have this really weird problem where when I pass a pointer to a C function it's address gets reset to 0x1.
12:32:55 <rcrcrc> Cale: so the RTS itself isn't spread across cores?
12:32:59 <Cale> Concurrency still works without it, but you don't take advantage of SMP in any way, and sometimes the performance behaviour is a bit different
12:33:00 <deech> I have confirmed that it does have a legit address before the hand-off.
12:33:03 <rcrcrc> but the processes are?
12:33:08 <rcrcrc> oh I see
12:33:15 <rcrcrc> awesome, thank you!
12:33:31 <bitemyapp> deech: it's Storable?
12:33:53 <deech> bitemyapp: Nope.
12:34:06 <bitemyapp> can you provide more context/code?
12:34:19 <deech> Just a void pointer from another C function, stored in a newtype, unwrapped and passed to another C function.
12:34:38 <deech> bitemyapp: unfortunately I can't. I've tried to reproduce.
12:34:50 <deech> I was hoping someone had seen something like this before.
12:35:20 <bitemyapp> deech: what type are you using in the newtype for the pointer?
12:35:53 <deech> It's just like `newtype SomePointer  = SomePointer { unSomePointer :: Ptr () }`.
12:36:06 <bitemyapp> Ptr () is what I'd expect.
12:36:22 <bitemyapp> Dunno. Without code or repro, nothing I can do.
12:36:30 <deech> Yeah, it's hard.
12:36:53 <deech> I mean I have a big huge example, but probably not easy to help debug that.
12:37:31 <nitrix> Is mplus restricted on having homogenous arguments?
12:38:12 <nitrix> Is there similar that'd work on two different monads or am I entering monad transformers here?
12:39:05 <johnw> :t mplus
12:39:06 <lambdabot> MonadPlus m => m a -> m a -> m a
12:39:58 <nitrix> And there we go. I just checked MaybeT and that's how it's done.
12:40:00 <beepbeep_> When using an infix style declaring a function. Is it normal that the left operator cannot be "_"? _ foo x = ..
12:40:08 <nitrix> So the monad transformer provides the MonadPlus instance.
12:41:24 <aweinstock> beepbeep_: if you're defining foo infix, it'd be: _ `foo` x = ...
12:41:27 <geekosaur> beepbeep_, is it ... that
12:41:42 <geekosaur> if you're using an infix with word characters it needs to be wrapped in ``
12:41:47 <beepbeep_> aweinstock is `` required?
12:41:53 <geekosaur> yes
12:41:54 <beepbeep_> because it sometimes works without ``
12:41:58 <beepbeep_> or is that my imagination?
12:42:03 <geekosaur> operator characters don't need ``
12:42:03 <aweinstock> > 5 `elem` [1,2,3]
12:42:05 <lambdabot>  False
12:42:07 <geekosaur> word characters need ``
12:42:14 <aweinstock> > elem 5 [1,2,3]
12:42:16 <beepbeep_> operator characters
12:42:17 <lambdabot>  False
12:42:19 <beepbeep_> what does that mean?
12:42:32 <aweinstock> > (+) 2 3
12:42:34 <lambdabot>  5
12:42:36 <beepbeep_> aha
12:42:36 <beepbeep_> :)
12:42:37 <beepbeep_> great
12:42:45 <beepbeep_> that explains a lot actually
12:42:47 <beepbeep_> thx!
12:42:49 <aweinstock> > 2 + 3
12:42:50 <lambdabot>  5
12:42:54 <geekosaur> technically? anything with a Unicode character type "symbol", aside from things like quotes
12:43:02 <beepbeep_> so
12:43:04 <geekosaur> there's a formal definition in the language report
12:43:09 <beepbeep_> _ || _ = true would work
12:43:13 <nitrix> Correct.
12:43:14 <beepbeep_> but _ disjunction _ does not
12:43:14 <geekosaur> yes
12:43:18 <beepbeep_> great
12:43:25 <aweinstock> and _ `disjunction` _ should
12:43:27 <beepbeep_> yep
12:43:28 <nitrix> Yep.
12:43:32 <beepbeep_> I get it! thx guys!
12:44:00 <nitrix> beepbeep_: This is to distinguish the operator that's being introduced from it being a free variable (argument name).
12:45:17 <beepbeep_> right, makes sense
13:21:26 * hackagebot exact-real 0.2.0.0 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.2.0.0 (jophish)
13:21:57 <zipper> Uh hello, I am using hspec for my tests and I want to assert that a value is not equal to another. The way to do it is usually using `shouldBe` but now I want something like `shouldNotBe`
13:22:50 <zipper> using a simple /= is having errors with IO.
13:23:12 <geekosaur> sounds like you need an fmap
13:23:46 <geekosaur> fmap not . whatever
13:24:53 <zipper> Heh I just came up with a dirty workaround.
13:25:24 <zipper> geekosaur: I don't see how fmap would've helped in such a case "Couldn't match expected type ‘IO b0’ with actual type ‘Bool’"
13:25:57 <Peaker> zipper: Show the code?
13:26:11 * geekosaur would assume IO Bool, thus using fmap applies the not "under" the IO
13:26:39 <lamefun> What's the current recommended library for resource management (like C++ shared_ptr and RAII)?
13:27:01 <selveskii> hello everyone, I am learning to use GADT
13:27:11 <selveskii> I am currently representing AST
13:27:18 <selveskii> and hope to use an index type in GADT
13:27:31 <selveskii> something like data AstF (f :: AstTypeIndex -> *) (i :: AstTypeIndex)  here   VarF :: Var -> i -> AstF f i
13:28:00 <zipper> Peaker: geekosaur http://lpaste.net/464141997393838080
13:28:04 <selveskii> What I am trying to do is that VarF :: Var -> AstExpr -> AstF f AstExpr
13:28:40 <selveskii> and VarF :: Var -> AstPat -> AstF f AstExpr
13:28:40 <Peaker> lamefun: Control.Exception.bracket ?
13:28:51 <glguy> zipper: Did you look in the documentation to see if they already had a function that did what you wanted?
13:28:58 <selveskii> so I try to write VarF :: Var -> i -> AstF f i
13:29:14 <selveskii> but it seems that this is rejected by GHC...
13:29:17 <selveskii> any workaround?
13:29:17 <FreeFull> lambdabot: (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
13:29:21 <geekosaur> zipper, so I would have said something like: fmap not (balanceBooks ... `shouldBe` 0)
13:29:30 <geekosaur> thus giving you shouldNotBe
13:29:33 <FreeFull> > (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
13:29:35 <lambdabot>      A 64-tuple is too large for GHC
13:29:35 <lambdabot>        (max size is 62)
13:29:35 <lambdabot>        Workaround: use nested tuples or define a data type
13:29:58 <zipper> glguy: Yes, which is weird. They should have a shouldNotBe :(
13:30:06 <kadoban> FreeFull: You can play with lambdabot in private message, if you didn't already know.
13:30:08 <zipper> geekosaur: hmmm yes that's more concrete.
13:30:35 <FreeFull> kadoban: Yeah, I just find it interesting that 62 is the limit
13:31:07 <glguy> zipper: Because they do have one
13:31:15 <geekosaur> expr `shouldNotBe` val = fmap not (expr `shouldBe` val)
13:31:28 <glguy> You can't fmap a not into shouldBe, it doesn't return an IO Bool
13:31:40 <selveskii> http://codepad.org/uTmMPYul
13:31:42 <geekosaur> ag
13:31:44 <geekosaur> ah
13:31:45 <zipper> geekosaur: Well that actually wouldn't work. I jst tried it and failed.
13:31:54 <lamefun> Peaker, is there something better, that, eg. prevents working with an already closed file handle for example?
13:31:57 <geekosaur> glguy just pointed that out, sadly
13:32:10 <geekosaur> I think it's a Property or some such, actually, probably need somethimng more clever
13:32:10 <zipper> glguy: I've been reading http://hspec.github.io/
13:32:10 <selveskii> so that link should summarize my question on GADT things
13:32:32 <zipper> glguy: Which docs are you on?
13:33:01 <glguy> zipper: The actual hackage haddock documentation. the stuff you just linked to is more fluff and less content
13:33:43 <glguy> http://hackage.haskell.org/package/hspec-expectations-0.7.2/docs/Test-Hspec-Expectations.html
13:34:31 <zipper> glguy: Yeah I just found this too https://hackage.haskell.org/package/hspec-expectations-0.7.2/docs/Test-Hspec-Expectations.html
13:38:08 <jophish_> haskell is so pleasant to write: x = until satisfied improve initialGuess
13:38:47 <glguy> Imagine writing that in C... until(satisfied, improve, initialGuess);
13:38:50 <glguy> yikes
13:39:59 <selveskii> it seems that I could have some proxy things
13:41:57 <monochrom> in "until(satisfied, improve, initialGuess)", the parameters have to be pointers to functions, not simple expressions
13:42:20 <monochrom> and not even lambdas
13:44:46 <qmm> there's an item that costs 100. it's 30% off of for the first person who purchases it. for the second person it's 15% off the original price. 7.5% for the third person and so on. i'm trying to come up with a formula to see how much person X will pay
13:44:57 <qmm> is there a mathematical term that would help me?
13:45:02 <monochrom> wrong channel
13:45:17 <arahael2> mknochrom: nah, "until" itself would be specialised if this was in C
13:45:51 <monochrom> what is "specialised"?
13:45:54 <hellertime> has anyone implemented a priority queue version of a TQueue?
13:46:17 <qmm> sorry i wasn't clear, i'm more interested in what percentages off they are getting, not necessarily how much they will pay
13:46:36 <qmm> monochrom: oh, i should ask in #math maybe?
13:46:52 <monochrom> yes
13:47:53 <arahael2> monochrom: eg, as "until_foo", which uses the foo algorithm
13:48:32 <monochrom> I think you completely misunderstand the context
13:49:14 <arahael2> monochrom: i was merely stating that if done in idiomatic C...
13:49:57 <jophish_> It's not nearly as often in C that I find myself writing some code which reads exactly like a sentence
13:50:41 <pyon> Is there any way to clear the REPL in interactive-haskell-mode?
13:50:44 <koala_man> have you tried COBOL?
13:51:00 <jophish_> qmm: person x gets 0.3 / 2^(x-1) off
13:51:11 <pyon> koala_man: You'd thikn these COBOL guys never heard of subordinate clauses. :-p
13:51:19 <jophish_> (assuming the first person is at index 1 and not 0
13:51:19 <Rembane> It's trivial to write Python code that reads like a spoken sentence: http://www.staringispolite.com/likepython/
13:51:36 <monochrom> pyon, loading or reloading clears a lot of things
13:51:57 <pyon> monochrom: Oh, I don't mean the REPL's internal state. I mean, literally, the contents of the REPL buffer.
13:52:06 <pyon> (As in, Emacs buffer.)
13:52:23 <monochrom> I see. let me think. I haven't looked for it.
13:53:01 <geekosaur> shades of poetry mode...
13:53:21 <athan> I see the openid package implements the OpenID-2.0 spec, but I guess google has deprecated -2.0 for OpenID-Connect; does this exist in haskell-landia yet?
13:53:36 <athan> or lambdia, not sure if that would be better :x
13:54:11 <monochrom> pyon: found, C-c C-k  (I went through the list from C-h b)
13:54:29 <pyon> monochrom: Oh, wonderful. Does the trick. :-)
13:54:37 <pyon> I'll also remember `C-h b` from now on.
13:55:53 <sphinxo> What does "Prelude.!!: index too large" mean?
13:56:08 <monochrom> actually C-h m gives you a shorter, less complete, but more relevant list
13:56:39 <monochrom> sphinxo, it means you're doing the like of [1,2,3] !! 1000000
13:57:00 <sphinxo> hmm, ok
13:58:10 <sphinxo> I can't seem anything like that, this is my code: http://lpaste.net/145408
13:58:20 <sphinxo> s/seem/see/
13:58:40 <glguy> fmap (!!0) getArgs
13:58:52 <sphinxo> ahh
13:58:55 <pavonia> > [] !! 0
13:58:57 <lambdabot>  *Exception: Prelude.!!: index too large
13:59:48 <ChristianS> listToMaybe instead of (!!0) (or head) would be safer
14:01:47 <sphinxo> What would it look like to pass program into evalbf?
14:02:14 <jophish_> What are the laws (formal or otherwise) for the Ord class?
14:02:40 <monochrom> it would look like "evalBF program". is that what you're looking for?
14:02:40 <Hijiri> I would guess it has to be a total ordering
14:03:27 <sphinxo> Yep, but main returns IO ()
14:03:41 <ChristianS> jophish_: see https://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#t:Ord
14:03:51 <monochrom> ok, "print (evalBF program)"
14:04:33 <sphinxo> yes but evalBF returns an infinate array
14:05:19 <monochrom> ok, then you have to first decide which part of it you want to output. then write code to pick out exactly that part, and output it.
14:05:49 <sphinxo> Right the bit i'm stuck on is how to output exactly that part
14:06:09 <monochrom> you can tell me which part it is, and I can suggest how to code it
14:06:40 <jophish_> ChristianS: that doesn't list any laws or guidelines
14:06:45 <monochrom> explain to me like I am not telepathic
14:06:47 <sphinxo> Say the center and last and first of each list
14:06:56 <jophish_> (apart from the "totally ordered" hint)
14:07:28 <ChristianS> jophish_: which is enough, i'd think
14:07:34 <glguy> jophish_: "total order" is a technical term
14:07:41 <glguy> https://en.wikipedia.org/wiki/Total_order
14:07:57 <jophish_> ChristianS, glguy. I think you're right, thanks!
14:08:05 <monochrom> case evalBF program of (xs, y, zs) -> print (last xs, y, head zs)
14:09:09 <glguy> If you update that BF interpreter to handle the Read/Write instructions it will probably be less important to print the infinite tape at the end
14:09:27 <glguy> and printing the last of an infinite list probably isn't awesome :)
14:09:32 <sphinxo> How would I do that? glguy 
14:09:39 <monochrom> actually "last xs" is a bad idea. perhaps "head xs" is the real answer
14:10:16 <glguy> sphinxo: I'm not going to write a BF interpreter but monochrom might ;-) We can all answer more specific questions, though
14:10:31 <monochrom> I don't care about BF either
14:10:46 <sphinxo> thanks monochrom, i'll try to better define my questions next time
14:11:53 <sphinxo> Ok how about, execute a function and ignore what it returns and then return ()
14:11:55 <johnw> are there any modules that can diff two fgl graphs?
14:12:17 <monochrom> but you can tell me "I have an infinite list that models an infinite tape and it is only infinite to the left but since Haskell lists can only be infinite to the right I am using the list in reverse. now how do I fetch the right end of the tape?" then it is the left end of the list, which is head xs.
14:12:30 <monochrom> left is right. freedom is slavery. ignorance is strength
14:14:02 <sphinxo> Python 2: True = False
14:14:08 <monochrom> sphinxo, I'm pretty sure we went through this last week. if you want to execute it but discard its output, then how to do it depends on what you want out of the execution.
14:14:54 <sphinxo> The function itself will print to stdout
14:15:13 <monochrom> then its type has to be "IO something"
14:15:38 <monochrom> and its code will contain output commands
14:16:14 <sphinxo> Great, then how do I adapt to foldl?
14:16:35 <monochrom> then you can't use foldl
14:17:00 <monochrom> foldM maybe. or maybe something else. but not going to be foldl
14:17:06 <sphinxo> it's not foldlefting itself
14:17:21 <monochrom> or write your own recursion
14:17:30 <sphinxo> Foldm looks like it'll work
14:20:07 <sphinxo> And then when evalBF returns IO Tape how do I handle that?
14:20:54 <monochrom> ignore the Tape?
14:21:29 <forker> Hi guys, I somewhat struggled figuring out how to implement handling of partial JSON representations of data types. Could someone take a look and rate sanity of the approach: http://lpaste.net/145410 ? Comments and pointers for relevant reads/studies are much appreciated! 
14:22:00 <monochrom> you know what, I dislike considering hypothetical questions like this. until you have actually finished up coding your evalBF such that it does IO and it outputs stuff, all else is hypothetical.
14:22:39 <sphinxo> Sorry, thanks for your help
14:22:56 <frerich> When I did the BF-interpreter exercise, I found that the major source of slowdown was actually foldM, IIRC because it was not inlined.
14:23:47 <frerich> https://github.com/frerich/brainfuck/blob/master/src/Data/Language/Brainfuck/Interpreter.hs#L31 <-- indeed, I even wrote a comment, that's not common for me. :-}
14:24:07 <sphinxo> Cheers! frerich 
14:24:51 <sphinxo> Thank you everybody, goodnight.
14:25:13 <kwisatz> Hi, I just read http://learnyouahaskell.com/chapters to chapter 11 (I don't really get the point after chapter 11, probably because now I should _code_ not _read_). What should I read next to get some good exercises ?
14:26:03 <Hijiri> @where learnhaskell
14:26:03 <lambdabot> https://github.com/bitemyapp/learnhaskell
14:26:06 <Hijiri> @where NICTA
14:26:07 <lambdabot> https://github.com/nicta/course
14:26:15 <Hijiri> kwisatz: ^
14:26:19 <kadoban> kwisatz: LYAH is pretty bad on its own. https://github.com/bitemyapp/learnhaskell has good advice or http://haskellbook.com/ sounds good, though I haven't read it.
14:26:21 <kwisatz> thx :)
14:26:21 <bernalex> what would a sane mappend be for data Tree a = Empty | Node (Tree a) a (Tree a)?
14:26:22 <tag> So, I'm looking for a good general purpose concurrency and asynchronous I/O framework  and hoping to find one that already has a web server built on top f it.
14:26:29 * hackagebot atlassian-connect-descriptor 0.4.2.0 - Code that helps you create a valid Atlassian Connect Descriptor.  https://hackage.haskell.org/package/atlassian-connect-descriptor-0.4.2.0 (RobertMassaioli)
14:26:31 <bernalex> i.e. with instance Monoid (Tree a)
14:26:37 <kadoban> NICTA is probably not the right next step if all you've done is some of LYAH.
14:27:39 <Hijiri> bernalex: are there any contraints on a?
14:27:48 <bernalex> Hijiri: I don't think so
14:30:21 <bernalex> Hijiri: I could say Monoid a in the above a, and do mappend = flip Node mempty, I suppose.
14:30:25 <forker> Hey guys, could you please take a look at MergeJSON:  http://lpaste.net/145410 . Is there anything available out there to fulfill the same gap?
14:30:39 <bernalex> Hijiri: I think maybe I won't make it a Monoid at all...
14:31:10 <bernalex> Hijiri: what I'm really working with is how to make it an Applicative that models nondeterminsm like list
14:31:32 <bernalex> Applicative that models collections (a "zip tree") is simple:   (Node l f r) <*> (Node l' x r') = Node (l <*> l') (f x) (r <*> r')
14:31:50 <bernalex> but then consider data NonDetermTree a = ND (Tree a)
14:32:38 <bernalex> so  pure x = ND (Node Empty x Empty), and the ND Emptys are pattern matched away to ND Emptys. but then ND (Node l f r) <*> ND t = ..?
14:33:44 <bernalex> ND l <*> ND t, f <$> ND t, and ND r <*> ND t, but I need a way of collecting the results.
14:34:21 <Hijiri> I'm not really sure
14:34:55 <Hijiri> maybe if the as were in the leaves, you could expand it out like a concatMap for trees
14:35:19 <Hijiri> (and implement <*> using that)
14:36:12 <bernalex> Hijiri: yes I'm considering doing a data Tree' a = Leaf a | Branch (Tree' a) (Tree' a). maybe that would be saner for this type of Applicative?
14:36:56 <Hijiri> I don't see how you would implement it with the a's in the Nodes (though maybe somebody else would be able to)
14:37:25 <Hijiri> but the in the leaves would be fairly straightforward I think
14:37:58 <Hijiri> since you could just do (Leaf f) <*> tree = fmap f tree
14:38:24 <Hijiri> and then the Branches would be just apply <*> recursively
14:43:07 <bernalex> Hijiri: ok so
14:43:10 <bernalex> data NonDetermTree a = EmptyND
14:43:12 <bernalex>                      | Leaf a
14:43:14 <bernalex>                      | Branch (NonDetermTree a) (NonDetermTree a)
14:43:15 <bernalex> instance Functor NonDetermTree where
14:43:18 <bernalex>   fmap _ EmptyND      = EmptyND
14:43:20 <bernalex>   fmap f (Leaf a)     = Leaf (f a)
14:43:22 <bernalex>   fmap f (Branch l r) = Branch (fmap f l) (fmap f r)
14:43:24 <bernalex> instance Applicative NonDetermTree where
14:43:26 <bernalex>   pure          = Leaf
14:43:28 <bernalex>   EmptyND <*> _ = EmptyND
14:43:30 <bernalex>   Leaf f <*> t  = fmap f t
14:43:32 <bernalex>   (Branch l r) <*> t = Branch (l <*> t) (r <*> t)
14:43:34 <bernalex> ?
14:43:41 <kadoban> bernalex: … lpaste.net
14:43:56 <bernalex> kadoban: it's OK, the chan is nigh dead right now and it was just a few lines.
14:45:15 <bernalex> λ Branch (Leaf (+1)) (Leaf (*2)) <*> Branch (Leaf 5) (Leaf 6)
14:45:16 <bernalex> Branch (Branch (Leaf 6) (Leaf 7)) (Branch (Leaf 10) (Leaf 12))
14:45:20 <bernalex> that doesn't look half bad
14:48:37 <Hijiri> bernalex: that looks good to me
14:56:43 * hackagebot medium-sdk-haskell 0.1.0.0 - Haskell SDK for communicating with the Medium API  https://hackage.haskell.org/package/medium-sdk-haskell-0.1.0.0 (timmy_tofu)
15:00:47 <forker1> Hey guys, could you please take a look at MergeJSON:  http://lpaste.net/145410 . Is there anything available to fill in the same gap?
15:07:27 <Hijiri> rip
15:19:11 <Zemyla> You know, there is actually a Monad instance for Data.Map.
15:21:38 <Zemyla> It's basically isomorphic to the Monad instance for WriterT k [].
15:22:37 <pavonia> What is the sementics of (>>=)?
15:22:42 <mniip> Zemyla, what would its liftM be
15:22:45 <pavonia> *semantics
15:24:33 <Zemyla> pavonia: The semantics of m >>= f is for each (k, a) value in m, get mapKeys (k <>) (f a), and then union them all together.
15:25:05 <clrnd> ski, so, the other thay I asked you about a fixed length container like thingy, you said Data.Array, just wanted to say thank you for that
15:25:16 <clrnd> it was preciselly what I needed
15:25:22 <mniip> Zemyla, that doesn't make a Monad instance
15:25:44 <Zemyla> Why not? If return is singleton mempty, then it sounds like a perfectly good monad instance.
15:26:27 <clrnd> pavonia, it's just an infix function of two arguments
15:26:27 <aweinstock> Ord constraint?
15:26:47 <Zemyla> aweinstock: The constraint is (Monoid k, Ord k) => Monad (Map k).
15:26:58 <Zemyla> There isn't any constraint on the value, just the key.
15:27:06 <aweinstock> ah
15:27:17 <mniip> :t mapKeys
15:27:19 <lambdabot>     Not in scope: ‘mapKeys’
15:27:19 <lambdabot>     Perhaps you meant one of these:
15:27:19 <lambdabot>       ‘IM.mapKeys’ (imported from Data.IntMap),
15:27:23 <mniip> :t M.mapKeys
15:27:24 <lambdabot> Ord k2 => (k1 -> k2) -> M.Map k1 a -> M.Map k2 a
15:27:26 <aweinstock> so Map can be made a Functor/Applicative/Monad/etc, but Set can't?
15:27:28 <mniip> ooh
15:27:43 <pavonia> Aha, you need a Monoid contraint too
15:27:45 <mniip> oh wait yes actually
15:27:50 <mniip> that does make sense
15:27:58 <mniip> aweinstock, Set is of a different kind
15:28:18 <lyxia> the Functor doesn't touch the keys though.
15:28:25 <mniip> Set k is isomorphic to Map k ()
15:28:31 <mniip> which is not very useful functor-wise
15:29:15 <aweinstock> functor-wise, is it the same thing as Const?
15:29:57 <aweinstock> @src Const
15:29:58 <lambdabot> Source not found.
15:41:17 <Zemyla> aweinstock: No, it's not.
15:41:35 <ski> clrnd : yw
15:42:00 <ski> clrnd : `Array' can be especially nice, if you can leverage dynamic programming
15:44:14 <ski> Zemyla : interesting
15:51:10 <kwisatz> how can I simply "num:_ <- fmap read getArgs :: Int" (which doesn't work ?) I want to read an integer from getArgs...
15:51:45 * hackagebot coinbase-exchange 0.3.0.0 - Connector library for the coinbase exchange.  https://hackage.haskell.org/package/coinbase-exchange-0.3.0.0 (andrewrademacher)
15:52:29 <shachaf> The type of fmap read getArgs isn't Int.
15:52:30 <monochrom> change ":: Int" to ":: IO [Int]". the type refers to the whole "fmap read getArgs"
15:52:53 <kwisatz> mmm right
15:52:59 <shachaf> In fact it's a type error.
15:53:13 <shachaf> Maybe you want something like fmap (map read) getArgs.
15:53:29 <monochrom> ah, yeah
15:53:30 <shachaf> Then you can specify the type as monochrom said.
15:54:33 <dmj> kwisatz: I'd use Text.Read.readMaybe over read though
15:54:35 <kwisatz> which works :)
15:55:04 <kwisatz> dmj : perfect, thx :)
15:56:45 * hackagebot HaskRel 0.1.0.1 - HaskRel, Haskell as a DBMS with support for the relational  algebra  https://hackage.haskell.org/package/HaskRel-0.1.0.1 (thormick)
16:00:46 <fosterite> @pl either Left Left
16:00:46 <lambdabot> either Left Left
16:02:32 <Clint> fosterite: you didn't give it a lambda
16:02:48 <fosterite> @pl \x -> either Left Left x
16:02:49 <lambdabot> either Left Left
16:03:12 <hacker> Q
16:03:32 <hacker> oops, sorry :/
16:03:53 <KaneTW> @pl \x -> either x x
16:03:53 <lambdabot> join either
16:07:43 <glguy> Instead of using (->)r's Monad instance, you could use Either a's instance:
16:07:44 <glguy> (Left 07=<<) 07:: Either a a 07-> Either a b
16:08:01 <Pamelloes> colors :O
16:08:05 <kwisatz> not exactly what I wanted : I'd like "Nothing" both when first arg is not an Int, and when no args exists...
16:08:13 <kwisatz> I forgot that second condition
16:08:42 <kwisatz> so num <- fmap (head . map Text.Read.readMaybe) getArgs :: IO (Maybe Int) does not work when <- getArgs returns []
16:08:57 <kwisatz> (because head gets an empty list)
16:09:43 <Enigmagic> maybe try `listToMaybe` or `safeHead` instead of `head`
16:09:44 <glguy> fmap (readMaybe 07<=< listToMaybe) getArgs 07:: Read c 07=> IO (Maybe c)
16:10:39 <glguy> or just case on the list and make it easy
16:21:43 <mpickering> The Applicative constraint on prisms seems quite strong, what is the intuition behind it? 
16:21:47 * hackagebot exact-real 0.2.1.0 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.2.1.0 (jophish)
16:33:56 <germany> how to do this guys 
16:33:57 <germany> Write a function anyBigNumbers that takes a threshold and a list of numbers and returns True if any of the numbers is > threshold, false otherwise.  anyBigNumbers 100 [4,5,600]   à True  anyBigNumbers 100 [4,5,6]       à False
16:34:20 <Enigmagic> i love homework questions
16:34:43 <Guest26183> hey guys 
16:34:48 <Axman6> Guest26183: how do you think you would do it?
16:35:02 <Guest26183> how to do this ? Write a function anyBigNumbers that takes a threshold and a list of numbers and returns True if any of the numbers is > threshold, false otherwise.  anyBigNumbers 100 [4,5,600]   à True  anyBigNumbers 100 [4,5,6]       à False
16:35:12 <Zemyla> Oh, for the Map Monad, (<|>) has to be M.unionWith const, to satisfy left catch.
16:35:12 <Axman6> we saw your question the first time.
16:35:48 <Axman6> this is not a place to ask for solutions to homework questions. we're happy to help you figure it out, but it will be you figuring it out, not us telling you the answer
16:36:07 <glguy> This question was asked in exactly the same way on the 9th including the à's ^_^
16:36:07 <kadoban> :t any -- take a look at this function Guest26183
16:36:09 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
16:36:34 <johnw> riscv
16:36:37 <kadoban> glguy: So two students too lazy to even reword it? :)
16:36:37 <johnw> sorry, wrong channel
16:37:09 <Guest26183> I am not student 
16:37:16 <rcrcrc> looks like from here: http://eecs.mines.edu/Courses/csci400/ASSIGN/Haskell/Haskell_Chap5-3.html
16:37:19 <Guest26183> I got the QS by google
16:37:24 <Guest26183> I need to learn haskell 
16:37:28 <Axman6> glguy: ha
16:37:32 <Guest26183> not just get an answert
16:37:36 <Guest26183> answer 
16:37:46 <Zekka> Guest26183: I can give you some hints if you want
16:37:55 <Zekka> How do you do it for one number?
16:37:56 <Guest26183> yes please 
16:37:59 <Axman6> Guest26183: are you following a tutorial?
16:38:20 <Guest26183> no I need best tutorial please 
16:38:22 <APic> Guest26183: What does „QS“ stand for?
16:38:32 <Zekka> APic: I think he meant "questions"
16:38:37 <APic> Ok
16:38:41 <Guest26183> QS = questions 
16:39:15 <Zekka> Guest26183: Most Haskell programmers would see this as three problems
16:39:40 <Zekka> "how do I do this operation for one number?" "how do I use step 1 to do it for all numbers?" "how do I consolidate all the results from step 2?"
16:39:49 <Guest26183> so could any one clear it to me ? 
16:40:05 <Guest26183> to do the base case ? right ? 
16:40:23 <Zekka> Oh yeah, you can do this recursively too.
16:40:34 <Zekka> So how do you define your function for the case of the empty list?
16:40:42 <Guest26183> so what is the easiest one 
16:40:43 <Guest26183> ?
16:40:52 <Guest26183> [] = [] ?
16:41:03 <Zekka> If you're recursing over a list, usually you handle the empty list first, then the empty list plus one element
16:41:34 <Zekka> That would get you something like this: anyBigNumbers threshold [] = ???
16:42:06 <Guest26183> anyBigNumbers threshold [] = [] 
16:42:15 <Guest26183> like this yot ment ? 
16:42:18 <Guest26183> you ^
16:42:26 <Zekka> Guest26183: That's a valid function definition but I'm not sure if it does what you want
16:42:45 <ski> wrong return type
16:42:48 <Zekka> This is what you're saying: "Q: Are there any numbers greater than `threshold` in the empty list? A: The empty list."
16:42:55 <fread2281> Guest26183, in your example it's returning a Bool
16:42:55 <Guest26183> I need to get big number from the list [ 4 , 5 , 47] 
16:43:02 <Guest26183> so > 47 
16:43:56 <Zekka> Do you want to get a list of the big numbers? I don't think that's what the problem asked for, but we can talk about how to do that
16:44:40 <Zekka> It's true that the numbers greater than `threshold` in the empty list are the empty list.
16:44:42 <Guest26183> not I just need to weahter true or false. it depense of the list. 
16:44:50 <Guest26183> you got it ? 
16:45:05 <Zekka> Yeah. So I think your program is answering a different related question
16:45:14 <Zekka> We don't really need a list of the numbers, we just want to know if there are any
16:45:53 <Guest26183> yes, excatlly 
16:46:25 <Zekka> anyBigNumbers threshold [] = {- whether or not there are any big numbers in [] -}
16:46:33 <Zekka> ({- -} is a comment, of course)
16:47:38 <lethjakman-l> Is it weird to use either for things other than errors? 
16:47:45 <Guest26183> so I am getting confused now 
16:48:14 <Zekka> Guest26183: Your program's goal is to answer a yes or no question -- so it'd be weird for your answer not to be yes or no
16:48:16 <MarcelineVQ> lethjakman-l: nope
16:48:21 <Zekka> (your answer has to be a Bool, specifically)
16:49:39 <Guest26183> I think so 
16:49:55 <Guest26183> let me try it 
16:50:11 <Zekka> So here's some sample interactions with my version of anyBigNumbers: http://lpaste.net/raw/5132893863303708672
16:50:28 <Zekka> It's always answering True or False -- it's never answering with a list
16:51:40 <Guest26183> how you got it ? 
16:51:57 <Zekka> Guest26183: My answer's kind of tricky and probably wouldn't help you
16:52:23 <Guest26183> why wouldn't ? 
16:52:30 <Zekka> There are some really short ways to write this program and my way was one of them
16:52:39 <Guest26183> explain it to me  ! 
16:52:41 <Zekka> You'd probably be better off trying to figure out a more straightforward way yourself
16:52:50 <Zekka> Guest26183: Yeah, sure, but I won't give you code
16:53:13 <Guest26183> yea don't give me 
16:53:22 <Guest26183> teach me ^_^
16:53:27 <Zekka> My way uses the 'any' function given to you earlier to check if any element of the list matches a yes/no question
16:53:41 <Zekka> Then I wrote a rule that says whether or not a value is greater than a number
16:53:43 <Zekka> Reminder:
16:53:45 <Zekka> :t any
16:53:46 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
16:54:01 <Zekka> > any (`elem` ["abc"]) "abacus"
16:54:03 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
16:54:03 <lambdabot>      Expected type: [[Char]]
16:54:03 <lambdabot>        Actual type: [Char]
16:54:08 <Zekka> > any (`elem` "abc") "abacus"
16:54:10 <lambdabot>  True
16:54:16 <Zekka> > any (`elem` "abc") "room"
16:54:18 <lambdabot>  False
16:54:26 <Zekka> So I used 'any' to phrase a similar question, but one that solves your problem.
16:55:21 <Zekka> > let anyAbc x = any (`elem` "abc") in (anyAbc "a", anyAbc "b", anyAbc "c", anyAbc "none of those letters")
16:55:23 <lambdabot>      No instance for (Typeable t0)
16:55:23 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
16:55:23 <lambdabot>        arising from a use of ‘show_M37378035141866761459336’
16:55:44 <Zekka> > let anyAbc = any (`elem` "abc") in (anyAbc "a", anyAbc "b", anyAbc "c", anyAbc "none of those letters")
16:55:46 <lambdabot>  (True,True,True,False)
16:55:57 <Zekka> That's a summary of how 'any' works
16:56:36 <jle`> lethjakman-l: i use it sometimes when i want arbitrary sums...but in many cases it's better to just make a new sum type with appropriate constructors
16:56:47 <jle`> but it's good for one-off sums
16:57:24 <jle`> but it's sort of like using Bool for things that aren't True/False
16:58:03 <jle`> you can use Bools to represent things that can be one thing or the other, but a lot of people like to make their own custom data type
16:58:07 <Guest26183> i think i got it 
17:01:48 <Guest26183> can someone teach me more 
17:01:54 <Guest26183> not got it yet 
17:02:14 <tzh> Guest26183: what does your code look like at this point?
17:02:30 <Axman6> Guest26183: we're here to help you learn, but we're not teachers (at least mnost of us aren't)
17:02:49 <Guest26183> anyBigNumbers :: [Char] -> Bool anyBigNumbers [] = True anyBigNumbers _ = False
17:03:14 <Guest26183> that's my code up to now 
17:03:51 <Axman6> Guest26183: are any of the numbers in an empty list greater than some large number?
17:04:00 <tzh> so how would you call that, if you have a list of numbers and a big number to check against?
17:04:19 <Guest26183> no 
17:04:27 <Zekka> I'm back. I'll defer a little to the rest of the channel, going to be gone for a moment again
17:05:54 <Guest26183> what's wrong with my code ? 
17:06:10 <Zekka> Guest26183: Try it with the tests I wrote and see if it does the same thing
17:06:20 <Zekka> If not you'll see there must be a problem
17:07:03 <tzh> Guest26183: so what are you expecting your code to do, and what does it do instead of that?
17:07:38 <Guest26183> it gave me errors 
17:07:50 <Guest26183> Zekka still errors 
17:08:07 <Zekka> What are the errors? They might tell you what you need to fix
17:09:12 <Guest26183> can I see your code "? 
17:09:28 <Zekka> Probably not for the best, but I can give you some more examples
17:09:42 <Zekka> Are you going with the recursive approach or the 'any' approach? It looks like you would rather write recursive code
17:10:14 <kras> Parsec question: I am using makeTokenParser, is there a way I can ignore newlines as well while parsing along with whitespace?
17:10:17 <Guest26183> yes I'd like it 
17:10:32 <Zekka> Let me write a similar recursive "look at everything in a list and come to a conclusion about it" function
17:13:21 <MarcelineVQ> The docs for GHC.List have an if that comes up quite often `#ifdef USE_REPORT_PRELUDE` when does USE_REPORT_PRELUDE matter for a general basic user like myself? Why is it so prevalent? The 'report' versions seem to use library functions whereas non-report versions use basic recursion, does this matter?
17:13:37 <MarcelineVQ> e.g. http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.List.html#reverse
17:15:51 <kadoban> MarcelineVQ: I think it's because certain functions are defined a certain way in the haskell report, but the GHC implementation doesn't use that exact defiintion for one reason or another, probably performance mostly. So those ifdefs are to use the report version, if you want to for whatever reason. As far as I understand anyway.
17:16:13 <geekosaur> it's not generally relevant in practice. the language report says you do it that way... ghc provides optimized versions, which occasionally may have slightly different time or space complexity but will usually have the same strictness
17:16:16 <Zekka> Guest26183: This function does something slightly more complicated, but similar to what yours is doing: http://lpaste.net/7810370041769099264
17:16:56 <geekosaur> you may use it if debugging the compiler / implementation, which sometimes is needed when something is found to have different strictness than the report specifies
17:17:30 <Zekka> Guest26183: Whoops! Those docs are erroneous
17:17:30 <Zekka> One sec
17:18:25 <Zekka> Guest26183: Refresh that page, they shoulld be fixed now
17:18:35 <MarcelineVQ> Thank you both for the prompt replies.
17:18:52 <Zemyla> Why the hell are listen and pass part of MonadWriter?
17:19:21 <Zekka> @let http://lpaste.net/7810370041769099264
17:19:21 <lambdabot>  Parse failed: TemplateHaskell is not enabled
17:19:32 <Guest26183> is there any simple why to do it  so far ? 
17:19:36 <Zekka> hm, am I orgetting how you do this or did I include a syntax error without realizing it?
17:20:07 <Zekka> Guest26183: There are pretty concise ways to write the program you want to write, and my demo program is pretty short if you strip all the documentatio
17:20:28 <Zekka> I don't have a strong sense of what you aren't understanding or else I would try to help you with that specifically
17:20:29 <geekosaur> @letlpaste 7810370041769099264
17:20:30 <lambdabot>  Defined.
17:20:44 <Zekka> > lexicoCompare "Hello!" "Hfllo!"
17:20:46 <lambdabot>  LT
17:20:56 <Zekka> ("Hfflo!" comes alphabetically after "Hello!")
17:21:24 <Zekka> We get there by recursing on line 25 and then comparing 'e' and 'f' on line 24
17:22:23 <Guest26183> I got errors on line 25 
17:23:09 <Guest26183> one sec
17:26:49 <Lokathor> https://github.com/Lokathor/roguelike-hs/blob/master/src/Roguelike/Util/RNG.hs
17:27:27 <Lokathor> I think i've finished up my RNG module for now, but if folks can spot any obvious flaws or missteps that'd be handy
17:31:31 <Guest26183> leaving.
17:31:36 <Guest26183> quit
17:31:38 <Guest26183> quit.
17:31:54 <Zekka> Pretty sure he wanted help cheating on his homework
17:31:55 <Zekka> not positive
17:35:05 <tzh> oh well at least you tried :V
17:35:44 <glguy> That homework assignment was due 4 days ago, at least, so you aren't inflating any grades
17:36:48 <Zekka> 4  days? That's at least one and a half dead grandparents
17:37:19 <glguy> http://eecs.mines.edu/Courses/csci400/CSCI400_ScheduleFall15.html "Haskell Cap 5 Pt 3"
17:38:18 <tommd> Lokathor: Going by the repo, this is just a statsitical use right?  Not for security?
17:39:25 <lethjakman-l> jle`: that makes sense
17:39:27 <lethjakman-l> Sorry, I just saw that. 
17:39:33 <Lokathor> tommd, correct, just for games not for crypto
17:39:43 <orb_> Roguelike games are serious business.
17:39:51 <Lokathor> max serious :3
17:40:16 <MarcelineVQ> people might savescum if you don't encrypt your gamestate
17:41:06 <orb_> Lokathor: Why do you need your own rng for your game?  (I can see that you want functions for rolling dice etc on top of a given RNG, but why bother implementing your own lower level bits?)
17:41:38 <Lokathor> well the states are setup to work with any RandomGen
17:42:09 <orb_> Oh, ok.
17:42:26 <geekosaur> fwiw DCSS implements its own RNG (actually three of them currently, I think; there's an effort to avoid things like UI behavior affecting the game state RNG)
17:42:56 <Lokathor> M.E. O'Neill has a video linked to on her site, and it's about an hour of the aspects of various RNG methods
17:43:23 <geekosaur> (otherwise reproducing a game from a given seed for debugging can fail to produce the same game, depending on which of the 3 UIs is used)
17:43:24 <Lokathor> she makes a strong case for using her flavor of RNG
17:43:53 <emmanuel`> hello there everyone!
17:44:38 <jophish> Has anyone got a link to that optional constraint package. I can't seem to find it
17:45:01 <Lokathor> plus, it was easy enough to convert her example minimal version from C into haskell
17:45:06 <jophish> (the one where you can call a different function if the type in question has that constraint)
17:46:05 <jophish> is an instance of*
17:46:53 <lethjakman-l> Is there some special vodoo I should know about for nesting case statements? 
17:46:54 <emmanuel`> Are there any reasons to stay away from using the STMonad?
17:47:18 <geekosaur> lethjakman-l, indentation / layyout applies
17:47:39 <Lokathor> lethjakman-l, you can case match on a tuple if you want to be terser about it
17:48:01 <lethjakman-l> I have a data type like so: (Maybe (Text:|:[(Maybe Value)]))
17:48:27 <lethjakman-l> What do you mean?
17:49:06 <Lokathor> ah, i thought it was two seperate computations
17:49:21 <Lokathor> not a nested value
17:49:59 <lethjakman-l> Also, the :|: is Either. 
17:50:09 <Lokathor> if it's two different computations you could do something like
17:50:10 <Lokathor> case (foo a, bar b) of (True,True) -> .. ; (True, False) -> .. ; (_ , _) -> .. ;
17:51:13 <lethjakman-l> Yeah, it's a weird json structure. 
17:51:25 <lethjakman-l> Hmmm that's interesting. 
17:52:01 <Enigmagic> lethjakman-l: what do you have now? you can match with nested patterns like so: case x of Just (Right (Just x)) -> ..;
17:53:03 <Enigmagic> replace x with better names..
17:53:28 <lethjakman-l> Enigmagic: I was going to nest case statements, but that's way better!
17:53:32 <lethjakman-l> I was hoping something like that was possible
17:54:07 <lethjakman-l> Is there something that I can do to match both Left and Right?
17:54:21 <lethjakman-l> So I can do Just (Either Nothing) or something like that?
17:54:35 <Enigmagic> _
17:54:49 <Enigmagic> case x of Just _ -> ..
17:54:51 <geekosaur> that won;'t match a constructor
17:55:20 <geekosaur> as I read it, lethjakman-l wants to say Just (_ Nothing)
17:55:29 <geekosaur> but that's not valid becauseyou cn';t match a constructor
17:55:37 <lethjakman-l> So, just put that at the end so that it's the last one matched?
17:55:40 <lethjakman-l> Oh. 
17:55:53 <lethjakman-l> So I'm just left catching Left and Right Nothing?
17:56:06 <Enigmagic> or you can use _ which says 'i dont care what is here'
17:56:19 <Enigmagic> but..
17:56:37 <lethjakman-l> Maybe just Just _ at the end to catch the Nothings that wouldn't match otherwise?
17:56:44 <Enigmagic> yes
17:56:48 <lethjakman-l> Or maybe I'm understanding that wrong. 
17:56:54 <lethjakman-l> Sweet. I'll play with that for a bit. 
18:00:23 <pavonia> When you're building a monad stack and you're defining types for different layers of this stack, when would you use a newtype instead of just a type synonym?
18:02:23 * lastAck99 help
18:03:07 <pavonia> e.g. in lambdabot there's "newtype Cmd m a = Cmd { unCmd :: ReaderT CmdArgs (WriterT [String] m) a }" and then there's a lot of boilerplate code for all the different instances
18:06:29 <niquefa_diego> o.o
18:07:27 <geekosaur> pavonia, usually the reason you'd newtype is to use newtype deriving to pass through (in that case) MonadReader and MonadWriter without requiring users of your monad to know how far they have to lift
18:08:21 <pavonia> But wouldn't that work with a type synonym too?
18:08:35 <geekosaur> no, you;d have to know you need to lift to get to the WriterT
18:08:54 <elbiot> Hey, pretty new here. How would I map over a list of tuples with a function that operates on just one of the elements?
18:09:01 <geekosaur> because it's "inside" the ReaderT
18:09:02 <elbiot> like: ([b]->[c]) ->  [(a,b)] -> [(a,c)]
18:09:36 <orb_> elbiot: (fmap.fmap)
18:10:04 <Iceland_jack> elbiot: You can instead write
18:10:04 <Iceland_jack> :t map.second
18:10:05 <lambdabot> (b -> c) -> [(d, b)] -> [(d, c)]
18:10:06 <orb_> (But that plain second fmap only works for manipulating the last element of a tuple.)
18:10:10 <Iceland_jack> that's more explicit
18:10:32 <orb_> :t [fmap.fmap, map.second]
18:10:34 <lambdabot> [(a -> b) -> [(d, a)] -> [(d, b)]]
18:10:54 <pavonia> geekosaur: I thought the point of the Monad* classes is to avoid the need of lifting
18:11:13 <Cale> Sometimes you might prefer to write something like [(x,f y) | (x,y) <- xs]
18:11:16 <geekosaur> it is --- when used with GND
18:11:34 <geekosaur> the point of them is you can derive them through a newtype so the user of your type doesn't need to lift
18:13:08 <betaceti> is there a difference between 'types' in general and 'data types'? or are they synonyms?
18:13:37 <orb_> betaceti: synonyms in most usages.
18:13:43 <orb_> In most contexts.
18:13:52 <elbiot> orb and Iceland_jack thanks.  Need to import arrow real quick to test
18:14:11 <orb_> elbiot: if you are feeling like learning a lot, try lens.
18:14:24 <Iceland_jack> elbiot: If you have a recent GHC, you should use Data.Bifunctor
18:14:26 <Iceland_jack> Not Control.Arrow
18:14:34 <slowbait> I would like to start learning lenses
18:14:40 <Iceland_jack> :t Data.Bifunctor.first
18:14:41 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
18:14:42 <Iceland_jack> :t Data.Bifunctor.second
18:14:43 <lambdabot> Bifunctor p => (b -> c) -> p a b -> p a c
18:14:45 <pavonia> geekosaur: But there already is e.g. an instance MonadWriter w m => MonadWriter w (ReaderT r m). Why do you still need to lift then?
18:14:49 <slowbait> It feels like it would me too complicated
18:15:17 <Iceland_jack> slowbait: Treat it like learning a new programming language and it will be fine
18:15:25 <betaceti> orb_: the only difference i can see is sometimes 'data type' might mean a type that isn't an 'abstract data type', while 'type' can mean both
18:15:48 <slowbait> I'm at a loss of where to start
18:16:02 <betaceti> orb_: but I don't know if types divide cleanly into abstract vs. concrete
18:16:12 <niquefa_diego> Hello everyone, could you recomend me some site to get started with Haskell? (I know to program already)
18:16:14 <geekosaur> pavonia, er? you showed me a MonadWriter, not a MonadReader...
18:16:29 <orb_> betaceti: yeah, if anything it's a very context dependent thing, if you want to make a distinction in usage.
18:16:36 <Iceland_jack> slowbait: Try focusing on the problems that lens is solving
18:16:39 <orb_> niquefa_diego: Learn you a Haskell is good.
18:16:47 <Cale> niquefa_diego: perhaps try http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
18:16:58 <orb_> niquefa_diego: The haskell wiki has a quite a few suggestions, too.
18:17:00 <geekosaur> pavonia, do you see the difference?
18:17:21 <elbiot> Iceland_jack: Why data data.bifunctor?
18:17:31 <Cale> niquefa_diego: also, no matter which tutorial you pick, feel free to ask lots of questions here :)
18:17:41 <niquefa_diego> :) thanks
18:17:52 <geekosaur> the instance you showed says that if MonadWriter w m, then MonadWriter w (ReaderT r m). it says nothing about it being MonadReade
18:18:03 <Iceland_jack> elbiot: Bifunctor is a simpler abstraction than Arrow for most things
18:18:37 <pavonia> geekosaur: The context is the definition of Cmd given above. AFAIU, the inner Writer has a MonadWriter instance and by the instance just given the outer Reader becomes a MonadWriter too
18:19:19 <slowbait> Iceland_Jack: that's part of the problem, other than setters and getters, I don't know much about. the motivation
18:19:30 <Iceland_jack> slowbait: Why learn it then :)
18:19:48 <Iceland_jack> Have you ever wanted to "fmap" over a Text or ByteString?
18:20:11 <elbiot> Iceland_jack: GHC 7.8.1 how do I import bifunctor?
18:20:27 <elbiot> sorry 7.8.4
18:20:30 <slowbait> I see it a lot
18:20:51 <Iceland_jack> elbiot: I'm not sure if Bifunctor was included in 7.8 but try Data.Bifunctor
18:21:01 <Iceland_jack> otherwise use Arrow
18:21:15 <nshepperd> pavonia: I think you're right, if you just use something like 'ReaderT x (Writer y)' it will automatically have MonadWriter and MonadReader instances
18:21:34 <elbiot> No go.  Data.Functor exists, but not Bifunctor
18:21:49 <nshepperd> 'type MyMonad = ReaderT x (Writer y)' works
18:22:24 <geekosaur> elbiot, I think you need ghc 7.10 for it to be in base
18:23:49 * geekosaur admits to being somewhat confused, then. it is rather common to use GND for that. maybe it's historical?
18:24:00 <nshepperd> pavonia: I think you usually use a newtype when you want to avoid exposing the internals
18:24:20 <nshepperd> well, that or just to keep the types straight
18:24:24 <timemage> geekosaur, right channel?
18:24:43 <nshepperd> using a newtype with GND gives a little bit more type safety than a synonym
18:24:47 <geekosaur> timemage, context is pavonia's question / nshepperd's response
18:24:52 <timemage> geekosaur, ah
18:25:59 <pavonia> Okay, so I guess I will use a newtype too if it's more common than a type synonym
18:27:05 <pavonia> Thanks geekosaur and nshepperd!
18:32:44 <elbiot> Hey, so I'm a little lost still.
18:32:54 <elbiot> I was looking for ([b]->[c]) ->  [(a,b)] -> [(a,c)]
18:33:29 <elbiot> (b->c) ->  [(a,b)] -> [(a,c)] is close but wondering if what I'm looking for exists
18:35:50 <Cale> elbiot: Oh, that's a bit harder
18:36:00 <Cale> elbiot: You could unzip the list of pairs, I suppose
18:36:21 <Iceland_jack> elbiot: Are you sure you want that function, what are you solving?
18:36:28 <Cale> elbiot: But you're not guaranteed that your function [b] -> [c] will produce a list of the same length as it received
18:36:43 <Cale> elbiot: So when you go to zip the result with the list of a's, it might not match up
18:37:22 <Cale> :t unzip
18:37:23 <lambdabot> [(a, b)] -> ([a], [b])
18:37:25 <Cale> : zip
18:37:27 <Cale> :t zip
18:37:28 <lambdabot> [a] -> [b] -> [(a, b)]
18:38:41 <elbiot> thanks Cale.  That probably works for me.
18:38:54 <Cale> elbiot: I would probably want to avoid doing this
18:38:56 <Cale> If possible
18:39:07 <Cale> It might be worth discussing what you're actually computing
18:40:08 <Cale> It might be fine, particularly if, e.g. the lists are infinite and you don't really care how the elements line up, or you know for certain that your function [b] -> [c] produces a list of the same length for certain.
18:40:49 <Cale> heh, duplicated the "for certain" there, but yeah, you probably want to be pretty sure, unless you want truncated output
18:42:01 <elbiot> Okay.  I'm still learning.  I have a list of (Color, Geometry)'s.  I have a function that takes a bounding box, a list of geometries, and returns a list of geometries transformed to fit in that bounding box.
18:42:27 <elbiot> So I know the two lists are the same length.  
18:43:15 * ski misreads "elbiot" as "elgot"
18:43:24 <elbiot> Or, rather, that the list doesn't change lengths
18:44:34 <pedantic_> elbiot: maybe this will help. > fmap (fmap length) [(1,"aaa"),(2,"bbbb"),(3,"cccc")]
18:50:06 <elbiot> pedantic: no, because I translate each geometry based on the bounding box that `all` of the geometries fit into.
18:50:27 <elbiot> Taking the aribtrary scale of the geoms and fitting into the canvas 
18:56:40 <pedantic_> elbiot: you could do it with a lens. A traversal could focus on the second elements of the list
18:56:54 <pedantic_> elbiot: and return you a new list where your function was applied
19:02:21 * hackagebot http2 1.3.0 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.3.0 (KazuYamamoto)
19:05:52 <Lokathor> https://github.com/Lokathor/roguelike-hs/blob/master/src/Roguelike/Util/Pathing.hs
19:06:09 <Lokathor> alright folks, next module up. Is this a sane sort of outline for implementing pathfinding with?
19:07:21 * hackagebot parsec2 1.0.1 - Monadic parser combinators  https://hackage.haskell.org/package/parsec2-1.0.1 (AntoineLatter)
19:07:23 * hackagebot warp 3.1.9 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.9 (KazuYamamoto)
19:09:24 <elbiot> pendantic_ I'll take note of lens but I think that might be too much new for me right now.
19:09:44 <elbiot> step one: get something to work.  step two: learn to do it elegantly
19:10:08 <synergistics> Why are lists particularly important to functional programming?
19:10:28 <Lokathor> they're really handy
19:11:53 <ski> synergistics : lists encode iteration
19:12:00 <Cale> synergistics: Because they act as our loops
19:12:33 <Cale> Just like a loop either doesn't occur (e.g. because its precondition isn't met), or it consists of an iteration followed by another loop
19:12:38 <Lokathor> in a non-strict language, the "interface" of a list is the same as that of a stream as well, so also good
19:12:43 <Cale> a list is either empty, or consists of a single element followed by another list
19:12:50 <synergistics> Like with recursion and cdr?
19:12:52 <synergistics> For looping
19:12:55 <synergistics> Yea
19:12:58 <pedantic_> synergistics: they are the most simplistic sequenced structure
19:13:01 <Cale> This connection is especially strong in a language with lazy evaluation
19:13:04 <Lokathor> yes, cons and cdr
19:13:05 <Cale> because loops can be infinitely long
19:13:13 <ski> rather more like `while'- than `for'- looping
19:13:14 <Cale> and so can lists
19:13:17 <synergistics> I've been messing around with infite streams
19:13:25 <synergistics> infinite*
19:14:21 <synergistics> And isn't a cons in lambda calculus something like \f.\x.\y.f x y ?
19:14:47 <ski> that's a (Church) *encoding* ..
19:14:56 <synergistics> Yea
19:15:00 <ski> (and really of a pair, not a cons as in a potentially-empty list)
19:15:08 <synergistics> Ah I see
19:15:17 <synergistics> But are they similar?
19:15:20 <mniip> no
19:15:43 <ski> `\c.\n.\x.\xs. c x xs' would work as an encoding of cons
19:15:45 <mniip> well everything in church encoding is similar to a degree
19:15:56 <ski> (one extra argument)
19:16:28 <ski> well, i suppose you'd normally have `x' and `xs' be the first arguments, though
19:16:35 <synergistics> What's the n for?
19:16:35 <Moonman420> would you teach programming to a subhuman?
19:16:38 <Moonman420> nigger?
19:16:40 <ski> synergistics : empty list
19:16:49 --- mode: ChanServ set +q *!*@gateway/web/freenode/ip.31.3.244.59
19:17:58 <synergistics> I don't understand why it's there
19:18:16 <ski> to present a uniform interface to users of the list
19:18:51 <ski> `2:3:5:7:[]' would be represented by `\c.\n. c 2 (c 3 (c 5 (c 7 n)))'
19:19:04 <yihuang> I'm tired to have to specify string type explicitly like this `test ("-d"::ByteString) dir`, I'm using OverloadedString, is there a way to specify a default string instance where there is uncertainty
19:19:25 <synergistics> Oooh
19:19:32 <synergistics> Ok the order was confusing me then
19:19:37 <synergistics> Read your other comment
19:19:38 <ski> the user of the list can't know whether the top constructor is a cons or a nil. it will pass one "branch" for handling the conses, and another for handling the nil at the end
19:19:43 <ski> (assuming the list was finite)
19:20:18 <Lokathor> yihuang, you could test a function that wraps the function you want to actually test, taking in a ByteString specifically (via type signature) and passing it on
19:20:29 <mniip> [06:18:05] <ski> `2:3:5:7:[]' would be represented by `\c.\n. c 2 (c 3 (c 5 (c 7 n)))'
19:20:52 <mniip> not \c.\n.c 2 (\c.\n.c 3 (\c.\n.c 5 (\c.\n.c 7 (\c.\n.n)))) ?
19:21:29 <synergistics> ski: So do you just not apply c? Or is that simulating recursion by applying the function to each element in the list?
19:21:52 <mniip> synergistics, what do you mean not apply
19:22:04 <yihuang> Lokathor, the `test` function is from shell-conduit library.
19:22:26 <synergistics> mniip: Would you leave it there to maintain structure, leaving it unapplied? Or is that nonsense?
19:22:28 <Lokathor> ah, troublesome
19:22:33 <synergistics> Like a placeholder that means connection
19:22:49 <mniip> it's not a placeholder
19:22:56 <mniip> it's a bound variable
19:23:12 <mniip> we encode the list with a function
19:23:12 <synergistics> No I get that
19:23:19 <mniip> that takes another function, namely 'c'
19:23:26 <mniip> and folds the list with it
19:23:39 <synergistics> Oh ok
19:23:58 <mniip> also in ski's encoding cons would be
19:24:12 <ski> mniip : no, that encoding is called something else
19:24:14 <mniip> \x.\xs.\c.\n.c x (xs c n)
19:24:22 <ski> (i forget what)
19:24:29 <synergistics> Makes sense
19:25:01 <mniip> ski, it corresponds to ADTs
19:25:14 <synergistics> ADTs?
19:25:27 <mniip> algebraic datatypes
19:25:53 <mniip> data List a = Nil | Cons a (List a)
19:26:05 <ski> mniip : the church encoding corresponds to the fold/`cata' on the `data' type in question
19:26:06 <mniip> is isomorphic to
19:26:18 <mniip> r -> (a -> List a -> r) -> r
19:26:25 <ski> mniip : the other one you mentioned corresponds to a "`case'" function on it
19:26:33 <mniip> ski, yes
19:26:57 <ski> mniip : you *need* `forall r.' in that type
19:27:18 <mniip> sure
19:27:37 <ski> the fold/`cata' is based on `List a' being isomorphic to `forall r. r -> (a -> r -> r) -> r'
19:27:50 <mniip> hmm
19:32:22 * hackagebot irc-core 1.1.3 - An IRC client library and text client  https://hackage.haskell.org/package/irc-core-1.1.3 (EricMertens)
19:37:49 <synergistics> Do types correspond to classes at all?
19:38:18 <fread2281> synergistics, OOP classes or haskell typeclassses?
19:38:25 <synergistics> OOP
19:40:31 <codygman> Is there a better way to write all of this? http://lpaste.net/145417
19:40:44 <geekosaur> also, whose types? there are different ways to build type systems; OOP classes are based on a different way than Haskell's types
19:41:20 <fread2281> synergistics, you can give OOP classes types, depending on the language it might be row types (python duck typing) or subtypes (most OOP)
19:42:18 <synergistics> geekosaur: Hmm, I'm not too sure. I was thinking of types in FP in general, or whatever can be said about types regardless of implementation
19:42:24 <Lokathor> synergistics, a haskell type is, in some ways, similar to an OOP class, but a haskell typeclass is more like an OOP class
19:42:36 <Lokathor> in terms of how you'd use them
19:42:43 <ski> synergistics : Java classes ? Smalltalk classes ? .. what flavor of classes ?
19:42:45 <synergistics> Lokathor: Yea
19:43:00 <synergistics> ski: More on the Java end
19:43:25 <Lokathor> synergistics, if you mean a Java class in the sense of polymorphic function dispatch based on subclasses and stuff, that's more like a typeclass
19:44:11 <synergistics> Lokathor: Polymorphic function dispatch, what do you mean?
19:44:45 <fread2281> Java classes are similar to records with subtyping afaik
19:44:47 <Lokathor> i mean how uh, new List().toString() and new Integer().toString() each have their own toString method that gets called
19:44:57 <synergistics> Ah I see
19:45:07 <synergistics> What about dispatch
19:45:14 <Lokathor> well haskell typeclasses don't ever override the definition of a supertype like happens in java
19:45:31 <Lokathor> instead, each typeclass carries around a dictionary of functions that get pulled out and used at the right time, basically
19:45:44 <Lokathor> each instance of a typeclass, that is
19:46:01 <synergistics> What did you mean by dispatch? Like a call to that function?
19:46:05 <Lokathor> so Int and Double each know how to do the (+) operation in the correct way
19:46:43 <Lokathor> yeah, dispatch is when a function is called, in java there's a dynamic dispatch so that the correct version of a method is used, for example if a subclass overrides a method of a superclass
19:47:42 <Lokathor> haskell doesn't normally do that, because haskell isn't as big on live code loading like java is
19:47:46 <ski> synergistics : a Java class (the interface part of it) corresponds with a type in Haskell. the constructor(s) of the Java class otoh would compare better with the value level in Haskell
19:47:47 <synergistics> Well I'm having trouble understanding types in an academic sense then, because all of that makes sense to me. I heard types described as sets of inputs or outputs. How are they structured?
19:49:00 <ski> Lokathor : you can easily emulate this aspect of dynamic dispatch in Java by having a record of functions
19:49:24 <ski> (to get open recursion, you have to have a more fancy encoding)
19:49:33 <Lokathor> synergistics, a type is a way to limit the possible data in a location. If a thing is said to be of type Bool then it must be spefically either the values True or False. If it's of type Int it can be all sorts of whole number values but not decimal numbers, and so on
19:50:00 <Lokathor> ski, well this is a beginner's explanation, so "normally you don't do that" seems fine to start :P
19:50:25 <ski> depends on the "normally", imho
19:50:35 <ski> sometimes it's appropriate, sometimes it isn't
19:50:50 <synergistics> Lokathor: So how do you define them? Should I look into typed lambda calculus for figuring that out?
19:50:58 <ski> this is related to the difference between shallow and deep embedding
19:51:22 <Lokathor> synergistics, how do you define them in haskell? or how do you define them in the abstract mathimatical sense?
19:51:27 <fread2281> synergistics, they aren't really structured. a type checker goes through a program and makes sure everything you do is allowed by the rules of the type system basically
19:51:33 <synergistics> Lokathor: the latter
19:51:34 <fread2281> that's all
19:51:56 <pavonia> Could anyone explain to me how to find out if using UndecidableInstances in your code is safe?
19:51:56 <Lokathor> i don't know much about the latter. I'm usually a little closer to practical applications
19:52:12 <ski> @wiki Embedded domain specific language
19:52:12 <lambdabot> http://www.haskell.org/haskellwiki/Embedded_domain_specific_language
19:52:15 <synergistics> fread2281: Aren't the rules for types based on proofs that certain objects have certain properties?
19:52:46 <synergistics> Like objects of a type is analogous to proofs of a proposition
19:52:50 <davidar> anyone here who knows stuff about type reification?
19:52:58 <davidar> eg: https://www.fpcomplete.com/user/thoughtpolice/using-reflection
19:53:07 <shachaf> Lots of people, probably.
19:53:28 <davidar> ok, I'll ask my question then :)
19:53:43 <ski> pavonia : when you're convinced instance resolution will terminate
19:53:59 <shachaf> You should ask your question anyway, rather than prompt people to volunteer to help you without knowing what the question is.
19:54:35 <davidar> so, say I have a function like: dot :: Matrix r c -> Vector c -> Vector r
19:54:39 <Lokathor> "don't ask to ask" is the mantra in most IRC places
19:55:02 <davidar> yeah, sorry, just didn't want to post a wall of text without checking first :)
19:55:14 <fread2281> synergistics, the rules for types are such that certain objects have certain properties
19:55:22 <davidar> (were r and c represent row and column counts resp)
19:55:29 <synergistics> fread2281: Ok, yea
19:55:42 <synergistics> fread2281: Is there no formal way to describe and prove these rules?
19:56:14 <davidar> so, I want GHC to infer the size of the output vector based on this type signature, but these sizes are only known at runtime
19:56:31 <davidar> Is `reflection` what I want to use for this?
19:57:02 <pavonia> ski: So e.g. for MonadReader, instance resolution will terminate because the left-hand side of the instance declaration gets "smaller" for each resolution step (one monad layer is removed in each step). Is this a sane reasoning?
19:57:16 <davidar> I feel like I'll run into escaping existential types if I'm not careful
19:58:24 <fread2281> synergistics, there is a formal way, all the rules are of form "given a then b is valid", e.g. in the figures of http://strictlypositive.org/Easy.pdf
19:59:39 <fread2281> or https://github.com/sweirich/pi-forall/blob/2014/notes.md is probably easier to understand
19:59:58 <davidar> it seems like reflect always needs to appear within the argument of reify, rather than reifying a value here, and then reflecting it somewhere else in the program
20:01:01 <fread2281> synergistics, "L |- a : A" means 'in context L (of local variables), a has type A'
20:04:18 <shachaf> davidar: You will.
20:04:38 <shachaf> But if you want a type based on something that happened at runtime, there's not much else you can do.
20:04:55 <davidar> yeah
20:05:04 <ski> pavonia : sounds like it
20:06:08 <pavonia> Okay
20:06:09 <davidar> shachaf: i don't even really care about the type, i just want to leverage the inferences made by the typing system when I construct the new object from the arguments
20:06:27 <shachaf> You should still be able to make inference work.
20:07:51 <davidar> as in, I want to put the row count of the matrix into the constructed vector, without having to actually special case it
20:08:22 <davidar> or am I asking too much of type inference to be doing stuff like that?
20:09:44 <davidar> I'm already able to reify dimensionalities of arrays, just not the actual sizes
20:10:13 <davidar> (but the dimensions are fixed at compile time)
20:12:13 <davidar> maybe I should just fill in the sizes manually rather than trying to do it generically :/
20:12:24 * hackagebot exact-real 0.3.0.0 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.3.0.0 (jophish)
20:12:53 <codygman> I once saw something about building strings/texts with do notation, does anyone know how to do that?
20:13:04 <shachaf> Writer?
20:13:26 <shachaf> davidar: What issue are you running into?
20:15:25 <davidar> shachaf: I haven't actually tried it yet, I just wanted to check whether it was a sensible idea or not first
20:15:27 <codygman> shachaf: I'm after doing something like blaze-html does except for just strings
20:16:09 <shachaf> I haven't used blaze-html but I heard it violates the monad laws or something.
20:17:55 <shachaf> davidar: Seems doable.
20:20:14 <davidar> shachaf: cool, thanks
21:51:36 <yihuang_> Lokathor, I've found the answer to my previous question: http://stackoverflow.com/questions/26778415/using-overloaded-strings
21:52:10 <Lokathor> interesting
22:04:59 <Lokathor> A strict version of an algorithm fills a 2d array completely with elevation values, and then walks downhill from a given location until it can't any more
22:05:52 <Lokathor> with this same algorithm in a non-strict setting, would a lot of the 2d array not be filled in if, for example, you only "walked" through a part of the grid?
22:06:19 <Lokathor> it feels like the answer is some sort of "yes if you do it right" deal
22:21:32 <srhb> Lokathor: Yes.
22:21:58 <srhb> Lokathor: Assuming you mean that it's lazy in the sense that the elevation values are not evaluated until they're neighbouring the walker.
22:23:29 <Lokathor> well
22:24:53 <Lokathor> all the grid locations are set to some "max" default value, and then the low-points are set to 0 and each "set" floods out setting the next location to x+1 if it's not already lower
22:25:00 <Lokathor> until the whole thing is generated
22:26:58 <Lokathor> but that seems like it would probably just force most of the whole grid as soon as any location's value is checked for
22:27:22 <Lokathor> which isn't a huge loss i suppose
22:30:19 <nshepperd> yeah, so probably need a calculation of elevation with less interdependence if you want to lazify that usefully
22:31:29 <Lokathor> don't think that's possible in this case
22:34:45 <Lokathor> ah well, the whole deal is that you're paying a bigger up front cost and then expecting to use the generated structure more than once anyway
22:37:39 <dmj> using Generics is there a way to get access to the constructor of a datatype, not the metadata, but the actual function
22:38:16 <dmj> i.e. if I had data Foo = Foo Int String, then I could get `Foo`
22:38:50 <nshepperd> hmm, i think A* with lazy nats could do this in principle
22:38:59 <glguy> dmj: The data type has a single constructor?
22:40:01 <dmj> glguy: yes
22:40:07 <nshepperd> would probably be horribly slow though
22:40:10 <Lokathor> nshepperd, what i'm doing is a variation of Djikstra's Algorithm. But rather than computing a path once, you build up a data structure that lets you path from any point to a goal point and then you can reuse it
22:41:11 <Lokathor> you get a savings if, for example, it's a turn based game and every monster shares the structure for its pathfinding on that turn
22:46:55 <Peaker> Lokathor: Does the data structure have the path costs from any point A to any point B? Or just to a single goal point? If the latter, then I think it *is* the Dijkstra algorithm, not a variant
22:47:55 <Lokathor> Peaker, you end up with a 2d array of ints. To find a path from A to any goal square you start at A's location, and always step "downhill" until eventually you reach a 0 point
22:48:31 <Lokathor> more than one zero point can be on the grid though, and stepping downhill will take you to whatever the closest goal was to your starting point
22:48:42 <Peaker> Lokathor: surely from A to B, and from A to C would need different "downhill" directions?
22:48:46 <Lokathor> so it's pretty much djikstra's, yes
22:48:55 <Peaker> Lokathor: ah, pre-determined goal, then sure
22:49:31 <Lokathor> yes, the goals have to be pre-determined when you build up the grid. However, you can also make one grid per goal and then overlay the grids when you want to have more than one goal
22:49:40 <Lokathor> potentially gets costly on your memory though
22:50:09 <Lokathor> but you'd just use some sort of... let goalGridAB = zipWith2D min goalGridA goalGridB
