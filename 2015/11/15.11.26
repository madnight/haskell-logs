01:03:22 <M2tias> why do you even need a generic n-tuple? o_O
01:04:45 <M2tias> only reason I can think of, that doesn't do something wrong with types, is that you need it for serialization or something similar. but then you can just serialize the list in the way you want
01:05:26 <merijn> generic n-tuple is just similar to heterogeneous list. They have their uses :)
01:05:50 <merijn> Well, I guess a TRUE n-tuple would have O(1) access, vs O(n) for heterogeneous list
01:06:47 <M2tias> but you'd have to use templates everywhere to utilise them, right?
01:07:31 <cocreature> no you can implement hlists as a type parametrized by a list of types
01:07:43 <cocreature> requires some extensions but no templates
01:07:52 <M2tias> ok
01:10:13 <merijn> See https://gist.github.com/merijn/dc00bc7cebd6df012c5e
01:10:15 <jle`> yeah i use them all the time :)  they're actually quite a joy to use.
01:10:28 <merijn> Which might have a little extension overkill :p
01:10:41 <merijn> But I wanted to show the ability to zip too :p
01:10:48 <M2tias> yeah... I can't read Haskell yet :D
01:10:56 <M2tias> still a baby
01:11:02 <jle`> what's even more interesting is an HList parameterized over a Functor, which i've been trying recently
01:11:11 <cocreature> jle`: that’s vinyl no?
01:11:24 <jle`> because then you get nice generalizations of Traversable
01:11:46 <jle`> ooh, i don't know
01:12:11 <cocreature> the rec type https://hackage.haskell.org/package/vinyl-0.5.1/docs/Data-Vinyl-Core.html
01:12:31 <jle`> oh yeah, i see it
01:12:37 <jle`> yeah, same as that :)
01:12:49 <cocreature> the nice thing is that you can perform some sort of mapping using rmap
01:13:00 <jle`> being able to generalize Traversable, Functor, Applicative, etc. is nice
01:13:33 <jle`> Traversable is definitely a typeclass that only gets more useful the more I learn haskell
01:13:41 <cocreature> do you have a link on how that gives you a generalization of traversable, …? I haven’t seen that one yet I think
01:13:52 <jle`> or at least, the traversal pattern
01:14:10 <jle`> the general Applicative f => (a -> f b) -> (s -> f t) pattern
01:14:10 <cocreature> or is that just the rtraverse, rmap, … stuff from vinyl
01:14:25 <jle`> yeah it's rtraverse from vinyl
01:14:41 <cocreature> I should play around with it more
01:14:58 <jle`> there was a library i was using that offered a lifted Traversable typeclass, so rtraverse from vinyl would be Rec's instance of it
01:21:13 <hc> good day
01:21:27 <hc> what is the recommended haskell zip library for processing large untrusted zip files?
01:21:42 <hc> (untrusted == "uploaded by a user to be processed by a web application")
01:27:45 <frerich_> hc: I think I'd start with zip-archive because it appears that a) it gracefully fails on malformed .zip archives b) the author is well-known and probably did a good job and c) you can extract files individually, so you can detect zip bombs.
01:31:43 <hc> Okay, thay's whay I'm currently using. Thanks! :-)
01:38:23 <joco42> any idea why i cannot install ghc-mod with stack ? https://usercontent.irccloud-cdn.com/file/PRvjlE7t/Screen%20Shot%202015-11-26%20at%2011.37.16.png
01:38:56 <joco42> phadej:  ?
01:43:05 <cocreature> because cabal-helper is not in the snapshot your using
01:44:06 <joco42> ok, cocreature , so if i add to extra-deps, what will that do ?
01:44:15 <joco42> take it from hackage?
01:44:27 <cocreature> yep
01:44:29 <joco42> it kinda seems to help...
01:44:32 <joco42> cool
01:44:34 <joco42> thanks
02:18:11 <Geraldus> hi friends!
02:19:35 * hackagebot optimization 0.1.7 - Numerical optimization  https://hackage.haskell.org/package/optimization-0.1.7 (BenGamari)
02:20:26 <liste> hi Geraldus!
02:20:34 <Geraldus> I'm developing a Yesod app and want to launch some daily database interactions in separate thread.  I'm trying to launch this process `makeFoundation` action.  The issue is that I need to run database actions inside IO monad somehow.  Can anyone suggest something?
02:21:24 <Geraldus> I've found one old question on StackOverflow from 2013, but it seems a bit outdated.
02:23:29 <liste> @paste -- Geraldus, please paste here the code you have
02:23:30 <lambdabot> Haskell pastebin: http://lpaste.net/
02:24:24 <phadej> joco42: I don't have any idea :( haven't used ghc-mod for a while
02:28:53 <joco42> ok, cool, it works now
02:32:22 <lpaste_> Geraldus pasted “Worker example” at http://lpaste.net/145985
02:32:49 <Geraldus> liste: done (:
02:37:27 <lyxia> Geraldus: what's the issue?
02:41:56 <liste> Geraldus you can just use runSqlite (or equivalent with other databases)
02:42:16 <liste> http://www.yesodweb.com/book/persistent#persistent_migrations <-- the `main' function here has an example
02:43:02 <liste> or the third example here: http://www.yesodweb.com/book/persistent#persistent_code_generation
02:43:19 <phadej> can I assume that `Int` fits into `Int64` always?
02:44:43 <merijn> phadej: Define always
02:45:11 <merijn> phadej: Practically on current platforms GHC supports? Yes. Forever? Hell no
02:45:40 <merijn> phadej: You should see how much C code breaks once char becomes 32 bits >.>
02:45:55 <Geraldus> liste: hmm… let me check.  I had similar thoughts. 
02:49:52 <Geraldus> liste: can you help a bit more?  I use PostgreSQL.  So, it seems that I need either `withPostgresqlPool` or `withPostgresqlConn` (http://haddock.stackage.org/nightly-2015-11-25/persistent-postgresql-2.2.1.1/Database-Persist-Postgresql.html).  But I'm certain about what connection string is.  It seems, that this answer from Michael is still relevant indeed.
02:49:56 <Geraldus> http://stackoverflow.com/questions/16517968/how-to-querying-the-database-inside-the-makeapplication-function
02:51:05 <jle`> is there a comonad without extract, just duplicate?  a co-semigroup ?
02:51:15 <jle`> the only law would be associativity
02:52:02 <jle`> fmap duplicate . duplicate = duplicate . duplicate
02:54:36 * hackagebot rest-client 0.5.0.4 - Utility library for use in generated API client libraries.  https://hackage.haskell.org/package/rest-client-0.5.0.4 (ErikHesselink)
02:57:11 <liste> Geraldus so you do have a connection string?'
02:58:42 <liste> https://www.fpcomplete.com/school/advanced-haskell/persistent-in-detail/existing-database#translating-to-csv <-- the first code example here is one way (using a connection pool)
03:02:46 <Geraldus> liste: ok, indeed I have a connection string, this is easy: `(pgConnStr  $ appDatabaseConf appSettings)`.  Let me try
03:28:16 <greg> hello, just a really silly Cat Theory question, if i have a functon f a b =  a + b in the Hask Category , is the object a x b implied?
03:29:35 <joco42> can ghc compile to arm? 
03:29:45 <joco42> say odroid?
03:29:54 <joco42> or raspberry pi?
03:30:43 <greg> joco42: yes it can
03:30:53 <joco42> ok, thanks greg
03:31:06 <greg> to be clear, i have ghc running on arm
03:31:14 <greg> but i guess you mean cross compile
03:34:01 <greg> i suspect it doesnt cross compile
03:34:23 <joco42> cross?
03:34:27 <joco42> greg?
03:34:28 <joco42> no
03:34:43 <joco42> say i compile one way or other...
03:34:47 <joco42> anything goes...
03:34:56 <joco42> cross or not cross
03:35:01 <joco42> does not matter
03:35:03 * hackagebot pipes-shell 0.1.4 - Create proper Pipes from System.Process  https://hackage.haskell.org/package/pipes-shell-0.1.4 (kbrei)
03:35:57 <joco42> what is the simplest/fastest way to use scipy/numpy from haskell? any experience on that?
03:37:11 <greg> huh?
03:37:21 <greg> scipy/numpy are python libraries
03:37:43 <greg> if you want an arm build you probably need to run ghc on an arm processor
03:37:53 <joco42> i know :)
03:37:54 <joco42> http://www.lunaryorn.com/2014/04/15/calling-python-from-haskell.html
03:38:10 <joco42> i wanna do numeric stuff from haskell
03:38:24 <joco42> and use the optimized python libraries...
03:38:58 <joco42> write less python and more haskell and be a happier person...
03:39:05 <joco42> along the way
03:41:13 <liste> joco42 I think LAPACK/BLAS are even more optimized (maybe Numpy uses them too?), and hmatrix uses them: https://hackage.haskell.org/package/hmatrix
03:41:44 <liste> oh, Numpy uses them
03:42:36 <joco42> liste: nice
03:43:02 <joco42> for simple stuff maybe that is good...
03:43:12 <liste> though for heavy duty numerics I guess Fortran is still the way to go
03:43:13 <joco42> but numpy is kinda fast and powerfull...
03:43:27 <joco42> no Fortran....
03:43:35 <joco42> not anymore...
03:43:39 <joco42> for me at least
03:44:03 <greg> i daresay you should just use python all the way down
03:44:23 <joco42> yeah... that is what i am trying to avoid...
03:44:47 <joco42> i guess i have to learn the haskell ffi
03:44:55 <joco42> and python ffi
03:46:21 <frerich_> joco42: Depending on how many Python<->Haskell roundtrips you need you could also just call an external Python interpreter process and then read stdout.
03:47:00 <greg> io is the universal ffi
03:47:07 <joco42> frerich_:  yes, indeed, that could be a simple way
03:47:32 <joco42> i try to go with the simple way as far as i can... as a start...
03:47:59 <joco42> probably it won't be much overhead...
03:48:26 <frerich_> Maybe you could even start the Python interpreter up front once in interactive mode and then use a little Haskell API which interfaces with that, so that you get an 'eval' function.
03:48:42 <frerich> To avoid any process startup costs.
03:48:45 <peddie> joco42: what numerical problem are you trying to solve?
03:48:52 <joco42> frerich: hmmm...
03:49:10 <joco42> peddie:  matrix multiplications and fft at the moment
03:49:20 <joco42> signal processing
03:49:43 <peddie> I believe there are already FFTW bindings
03:49:44 <joco42> data mining on radio signals
03:49:47 <joco42> sort of
03:50:04 <joco42> hmm
03:50:46 <joco42> the thing is that the computationally intensive part is about 3 lines of python code...
03:50:49 <joco42> the rest is glue
03:51:06 <joco42> and i wanna glue python together with haskell
03:51:09 <joco42> sort of
03:51:13 <frerich> joco42: Maybe just an 'withPython :: FilePath -> (Python -> IO a) -> IO a' function and then 'eval :: Python -> String -> IO String' such that yu can use 'withPython "/usr/bin/python" $ \python -> do { x <- eval python "1 + 1"; y <- eval python "2 + 1"; print (x+y) '
03:51:26 <joco42> frerich:  nice
03:51:36 <peddie> maybe you should just glue the python together with python if you already have it working :)
03:52:07 <peddie> if you're just going to call out to python anyway, and the numerical heavy lifting is done, adding haskell into the mix may not buy you much
03:52:12 <joco42> peddie:  yeah... if i glue stuff with python then my fingers get too sticky....
03:52:26 <frerich> joco42: I did that for Tcl once, it had a nice cost/benefit ratio. I could easily migrate existing Tcl code by reusing it and then gradually porting it.
03:52:41 <peddie> maybe I should ask, what do you hope to gain by calling out to python from some haskell code?
03:53:05 <joco42> peddie:  less run time errors
03:53:35 <joco42> frerich:  ok, cool, i wanna do this little experiment and see how it feels...
03:54:12 <peddie> joco42: this sounds a bit misguided, but I'm sure I just don't have the full story -- good luck :)
03:54:32 <joco42> peddie: the problem is that i am too stupid for python....
03:54:50 <joco42> i need a type checker .... 
03:56:38 <peddie> I feel the same way a lot of the time, but if you're already calling out to python, which is calling out to FORTRAN and C, it seems like you've got plenty of stuff that's not covered by the type checker
03:56:58 <peddie> maybe you have a crazy amount of gluing
03:57:01 <peddie> I dunno :)
04:24:01 <Heather_> what is MonadIO
04:24:06 <Heather_> ...
04:26:34 <liste> Heather_ a class with liftIO :: m a -> IO a
04:27:35 <liste> so basically all monad stacks with IO at bottom have instances of it
04:27:40 <Heather_> liste where is IO
04:27:46 <barrucadu> liste: Wrong way around, :: IO a -> m a
04:27:59 <liste> barrucadu thanks for the correction (:
04:28:27 <Heather_> I've found type IO a  =  RealWorld -> (a, RealWorld) but where is it :)
04:28:48 <liste> Heather_ it's magic
04:29:00 <Heather_> liste is it defined in hs?
04:29:18 <Heather_> liste can I have my own IO :D
04:29:58 <Heather_> I think I slowly understand overall point of idris effects :/
04:30:19 <liste> Heather_ check out https://wiki.haskell.org/IO_inside for a peek under the hood
04:30:57 <Heather_> liste I saw it
04:31:26 <Heather_> liste I just wanted to understand more clear which parts are unchangeable
04:34:46 <liste> Heather_ there's a fake pure IO: https://hackage.haskell.org/package/pure-io
04:36:31 <Heather_> liste that's interesting, and I can run main with pureIO?
04:37:53 <liste> Heather_ note that it's a different type than Prelude.IO
04:38:01 <liste> so you need import Prelude hiding (IO)
04:39:39 <liste> and it implements only a small subset of real IO
04:40:19 <liste> but, IIUC the real IO is implemented by the (non-Haskell) RTS
04:40:32 <liste> at least the primitives are
04:40:51 <Heather_> liste yes, seems like so for me too
04:41:34 <liste> but it's an implementation detail of GHC, the Haskell report specifies just the API
04:48:40 <quicksilver> personally I think the lie "type IO a = RealWorld -> (RealWorld,a)" helps people *misunderstand* IO rather than helping them understand it.
04:48:44 <quicksilver> but YMMV.
04:49:06 <merijn> quicksilver++
04:50:25 <M2tias> you make me vomit?
04:50:35 <liste> your mileage may vary
04:50:36 <quicksilver> I have that effect on lots of people.
04:50:50 <tdammers> I still think the sanest way to approach IO is to consider it a transparent EDSL for an imperative language that isn't Haskell
04:51:49 <quicksilver> I don't think "an imperative language that isn't Haskell" helps there
04:51:54 <quicksilver> it's an EDSL.
04:52:19 <tdammers> yeah, OK, it works just as well without the second part
04:52:27 <quicksilver> EDSLs are inherently Haskell in a sense - but it's primitives are not defined in haskell which I suppose is what you meant
04:52:43 <tdammers> yes, that's what "transparent" was supposed to hint at
04:52:49 <quicksilver> the "imperative" part is just haskell; after haskell is by far the best imperative language I've used.
04:53:00 <tdammers> hmhm
04:53:08 <tdammers> it certainly is
04:54:45 <frerich> I always explain Haskell's IO model in terms of Java's "Runnable" (because that's apparently a widely known thing) plus a bit of type safety (the Runnable declares the type of value it promises to produce) and minus the ability to actually run a Runnable.
04:55:26 <quicksilver> I think an entirely reasonable view is to consider IO a complex, abstract (but pure haskell) type, which the RTS knows how to 'run'.
04:55:35 <quicksilver> however I don't think that's a useful view for teaching :/
04:55:59 <quicksilver> because the kind of person who wants to know what that is, tends not to have a good model of how the RTS might act as an interpreted for a complex abstract type.
04:56:07 <tdammers> quicksilver: I'd think it would be a very useful view for teaching...
04:56:18 <quicksilver> my experience in this channel speaks to the contrary :)
04:56:19 <tdammers> you don't need to know what the RTS does in great detail
04:56:29 <quicksilver> although certainly simpler explaantions along those general lines
04:56:42 <quicksilver> "IO a is a recipe, a set of instructions, to produce an a"
04:59:56 <frerich> No matter what metaphor you use, I believe it's very important to avoid mixing Monads and IO. It's unneeded and in my experience a very slippery slope.
05:00:16 <frerich> Mixing the two things in explanations, I mean.
05:04:13 <Copperis> what's an rts?
05:04:17 <quicksilver> run time system
05:04:30 <Copperis> oh
05:04:37 <quicksilver> it's the module of a compiler that provides basic services for the things it compiles
05:04:43 <quicksilver> C has a rather small RTS
05:04:54 <quicksilver> haskell has quite a big one with GC, IO manager, thread manager, etc.
05:06:47 <naudiz> are there libraries that convert LaTeX code into pictures? I'd like to write LaTeX code in a blog that uses Yesod.
05:07:21 <quicksilver> yes.
05:07:41 <quicksilver> LaTeX is designed to produce pictures (dvi files, ps files, pdf files)
05:07:45 <quicksilver> that's rather the point of it
05:07:59 <quicksilver> some libraries exist to make it easier to produce fragments rather than whole pages
05:08:00 <merijn> naudiz: Presumably you want MathJaX
05:08:03 <merijn> Not pictures
05:08:25 <naudiz> mathjax uses JS, doesn't it? I'd like to avoid using JS.
05:08:38 <merijn> Yes, but it also produces text, instead of a picture
05:08:44 <merijn> Which means it can be zoomed, scaled, etc.
05:08:49 <merijn> Copy+pasted
05:09:34 <merijn> Especially in a retina display era that's important, because I hate pixellated fixed graphics :\
05:10:07 <frerich> naudiz: You could also convert LaTeX to SVG (there are various tools for this)
05:10:23 <naudiz> but that means that those texts won't be readable without JS... 
05:12:21 <naudiz> frerich: I'd prefer a library that does so over a tool. Otherwise, I'd just render it and link the images instead of asking here.
05:12:59 <quicksilver> there are few if any independent implementations of TeX
05:13:14 <quicksilver> ultimately you're going to shell out to a tex process if you want real processing
05:13:23 <quicksilver> (or a hack which just parses a simple subset)
05:14:01 <naudiz> tex live and xetex come without any C library?
05:16:02 <naudiz> okay, guess it's either mathjax or rendering by hand... thanks anyway.
05:16:32 <tdammers> why by hand? can't you run actual latex in a subprocess?
05:16:34 <frerich> naudiz: I see, I imagined that since it's for a blog you already have a toolchain anyway.
05:17:29 <tdammers> I do something similar for thumbnails, running them through magick in a subprocess
05:18:19 <naudiz> guess I could do that but it's not worth those few lines of LaTeX code I'll be using.
05:25:07 * hackagebot hashids 1.0.2.2 - Hashids generates short, unique, non-sequential ids from numbers.  https://hackage.haskell.org/package/hashids-1.0.2.2 (arbelos)
05:54:56 <nkaretnikov> i'm writing a FromJSON instance for a record that has an Int64 field.  unfortunately, aeson happily converts 3.14 to 3 if i use something like Foo <$> v .: "x" <*> v .: "y"
05:55:06 <nkaretnikov> is there a way to make it more restrictive?
05:57:29 <nkaretnikov> i've already tried Foo <$> parseX <$> (v .: "x") <*> parseY <*> (v .: "y") where parseX and parseY are helpers used to input validation
05:58:06 <nkaretnikov> but that means that the resulting json values will be strings, not ints, which is not ideal either
05:59:23 <nkaretnikov> ah, i guess i need to look at the FromJSON Int64 instance
06:00:20 <quicksilver> nkaretnikov: your problem here is that the FromJSON Int64 instance has this behaviour, yes
06:00:36 <quicksilver> it's permissive, it will parse anything that looks like a number and effetively discard the fractional part
06:00:39 <nkaretnikov> quicksilver: thanks, i could try with a newtype wrapper
06:00:42 <quicksilver> (as an aside, I find this pretty surprising)
06:01:02 <nkaretnikov> quicksilver: do you think i should report to bos on github?
06:01:25 <quicksilver> I guess they won't want to break backwards compatibility to change it
06:01:34 <nkaretnikov> who knows
06:01:52 <quicksilver> would be worth checking to see if it has already been discussed
06:01:53 <nkaretnikov> i'll experiment with it and maybe file an issue
06:02:00 * nkaretnikov nods
06:03:05 <quicksilver> you should be able to construct a parser directly without using an instance
06:03:07 <quicksilver> I hate typeclasses
06:03:27 <quicksilver> isn't there a version of (.:) somewhere which uses an explicit parser not a FromJSON instance?
06:03:48 <nkaretnikov> quicksilver: hm, how so?  that'd mean losing all the functions that work for From/ToJSON
06:03:52 <nkaretnikov> no?
06:05:32 <nkaretnikov> quicksilver: don't see anything suitable by quickly scanning the haddocks
06:06:31 <quicksilver> nkaretnikov: no
06:06:37 <quicksilver> nkaretnikov: you'd just override it for one field
06:06:47 <quicksilver> I'll use fromJSON for most stuff but a custom parser here and here and here
06:07:02 <quicksilver> it's a terrible idea to base a parsing library *only* on typeclass instances
06:07:02 <nkaretnikov> quicksilver: i can add a newtype wrapper and define a proper instance, no?
06:07:11 <quicksilver> you can but that's a horrific hack :)
06:07:16 <nkaretnikov> what?
06:07:28 <nkaretnikov> that's one of the main uses of newtypes
06:07:29 <quicksilver> I mean, the API is horrific if it requires you to hack around it that way.
06:07:33 <nkaretnikov> ah
06:07:37 <quicksilver> it's one of the main ABuses of instances
06:07:54 <nkaretnikov> lol, whatever.  in any case, i'm glad that bos wrote aeson
06:07:58 <quicksilver> in general, it indicates that the API was designed wrongly and there should be an non-typeclass based route
06:08:12 <nkaretnikov> otherwise, i would be designing my own parsing lib right now
06:08:12 <quicksilver> I thought there was, for aeson, but for some reason I find it hard to find my way around the docs :)
06:08:48 <greg> was just on the math channel, tried to talk to them about the category Hask
06:08:54 <quicksilver> "parseIntegral expected = withScientific expected $ pure . truncate
06:08:55 <greg> it didnt go down very well
06:09:05 <quicksilver> ^^ that 'truncate' is the source of the issue
06:09:18 <nkaretnikov> quicksilver: yeah, i've already checked that module
06:09:33 <nkaretnikov> thanks for your help!
06:09:54 <nkaretnikov> greg: there's #haskell-lens for that, lol
06:10:35 <greg> nkaretnikov: a channel just for talking about lens'?
06:10:43 <quicksilver> nkaretnikov: I guess the answer is to 'fromJSON' at type 'Value'
06:10:47 <quicksilver> and then manually process the Value
06:11:10 <quicksilver> not the whole thing, just that Int64 field
06:11:22 <nkaretnikov> greg: sort of, i tend to think of it as #haskell from 2006
06:11:59 <greg> nkaretnikov: i dont follow, im going to hop on and see what its like
06:12:15 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
06:12:15 --- topic: set by quicksilver!~jules@roobarb.crazydogs.org on [Wed Oct 07 07:39:49 2015]
06:13:11 <quicksilver> nkaretnikov: yes, you don't need a newtype wrapper and an instance
06:13:13 <nkaretnikov> greg: i was referring to the fact that it's supposed to be about lens, but they talk about lots of things.  and it is populated by oldtimers who are not that active on this channel
06:13:39 <quicksilver> just parse it to Value, and then parse *that* and if it's not an integer 'fail' to return your parse error
06:14:16 <quicksilver> even better 'typeMismatch'
06:14:20 <greg> nkaretnikov: ah i see, thanks i think that was what i was looking for , have only been away from the haskell channels for 2 months and so much has changed
06:18:47 <nkaretnikov> greg: according to chanserv it was registered in 2012 :)
07:06:05 <nkaretnikov> quicksilver: i now see the problem, when i pass 12, aeson sees that as 12.0.  that's probably why it simply floors stuff
07:09:28 <nkaretnikov> the other two libs i've looked through have the same problem.  they treat numbers as rationals from the start
07:10:24 <geekosaur> I think JSON "natively"  treats all numbers as doubles?
07:11:45 <geekosaur> or "decimal" (~ Rational)
07:12:06 <nkaretnikov> geekosaur: take a look at the spec on json.org
07:12:38 <nkaretnikov> number is int, int frac, int exp, or int frac exp
07:14:02 <mauke`[]> yes, if by "int" you mean "integer part"
07:15:21 * hackagebot ansi-pretty 0.1.1.0 - AnsiPretty for ansi-wl-pprint  https://hackage.haskell.org/package/ansi-pretty-0.1.1.0 (phadej)
07:15:36 <Xandaros> parsing json ints is fun
07:15:49 <Xandaros> When I wrote a json parser, that took the longest
07:16:43 <mauke`[]> -?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][-+]?\d+)?
07:17:30 <nkaretnikov> mauke`[]: oh no
07:17:39 <geekosaur> "ypu fool, you've unleashed the regex!" >.>
07:18:11 <hpc> that's not so bad
07:18:22 <mauke`[]> super simple stuff
07:18:32 <hpc> most of the ugly is in (?:)
07:18:46 <Xandaros> I don't even understand it. It uses some syntax I don't understand (The ?: stuff)
07:18:56 <rom1504> ?: means don't capture
07:18:56 <lambdabot> Maybe you meant: v @ ? .
07:19:18 <hpc> it's also a natural jumping off point into (?!) and such
07:19:30 <hpc> which do some rarely needed things
07:19:58 <mauke`[]> optional(char'-')*>(char'0'<|>(oneOf['1'..'9']*>many digit))*>optional(char'.'*>some digit)*>optional(oneOf"eE"*>optional(oneOf"-+")*>some digit)
07:20:02 <mauke`[]> there, now it's perfectly readable
07:20:24 <rom1504> https://regex101.com/r/iU3sF7/1 is pretty good at explaining regexes
07:20:25 <hpc> needs more frivolous (.)
07:25:21 * hackagebot b9 0.5.16 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.16 (SvenHeyll)
07:40:06 <tobiasBora> Hello !
07:40:49 <tobiasBora> What is the good package to use to deal with directories ? (list directory, remove...)
07:41:18 <tobiasBora> I wanted to use this https://hackage.haskell.org/package/system-filepath-0.4.13.4/docs/Filesystem-Path.html
07:41:23 <tobiasBora> and this https://hackage.haskell.org/package/system-fileio-0.3.16.3/docs/Filesystem.html
07:41:28 <tobiasBora> but they seems to be depracated
07:41:32 <tobiasBora> *deprecated
07:42:30 <jerv> what function should I use to replace all occurrences in a Text with some other Text? i.e. I am trying to replace all spaces with underscores
07:42:51 <hpc> @hoogle replace
07:42:53 <lambdabot> Data.Text replace :: Text -> Text -> Text -> Text
07:42:53 <lambdabot> Data.Text.Lazy replace :: Text -> Text -> Text -> Text
07:42:53 <lambdabot> Data.Text.Encoding.Error replace :: b -> OnError a b
07:43:11 <tobiasBora> Is this library better : https://hackage.haskell.org/package/directory-1.2.4.0/docs/System-Directory.html ?
07:43:16 <hpc> oh, yay
07:43:21 <jerv> hpc: afaik only replaces first occurrence? I could wrap this I guess but thought there might be something else
07:43:31 <hpc> oh, hmm
07:44:07 <saulzar> tobiasBora, How about 'filepath'
07:44:37 <mauke`[]> :t Data.Text.map
07:44:38 <lambdabot> (Char -> Char) -> Data.Text.Internal.Text -> Data.Text.Internal.Text
07:44:49 <mauke`[]> :t Data.Text.map (\c -> if c == ' ' then '_' else c)
07:44:51 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text
07:45:14 <mauke`[]> > Data.Text.map (\c -> if c == ' ' then '_' else c) (Data.Text.pack "hello, world!")
07:45:16 <lambdabot>      Not in scope: ‘Data.Text.map’
07:45:16 <lambdabot>      Perhaps you meant ‘Data.List.map’ (imported from Data.List)Not in scope:...
07:45:37 <Xandaros> :t pack
07:45:40 <lambdabot>     Not in scope: ‘pack’
07:45:40 <lambdabot>     Perhaps you meant one of these:
07:45:40 <lambdabot>       ‘BS.pack’ (imported from Data.ByteString),
07:45:46 <Xandaros> :t T.pack
07:45:48 <lambdabot>     Not in scope: ‘T.pack’
07:45:48 <lambdabot>     Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
07:45:50 <Xandaros> :/
07:51:22 <Xandaros> jerv: It replaces all occurences
08:10:41 <fitzavig> hi
08:15:00 <nrolland> hi, there is a library called configifier, which has written WARNING NOT READY FOR USE YET in its description
08:15:12 <nrolland> inevitably, it becomes tempting to use it
08:16:12 <nrolland> it uses type level description of parameters to a program to read fraom various standard sources
08:16:25 <nrolland> or generate documentation
08:16:47 <nrolland> using the same ideas that servant is using
08:17:18 <nrolland> I am wondering if anyone has used it or how bad of an idea it would be to use it…
08:17:19 <nrolland> https://github.com/zerobuzz/configifier
08:18:25 <Xandaros> I love the example they have. It uses 12 GHC-extensions :D
08:19:03 <nrolland> yes, it’s quite promising to start off with a wall of extensions, puts you in the mood
08:19:05 <nrolland> :)
08:19:49 <nrolland> but the code using the damn thing is not bad.. there is a top level config made up of 3 parts : fontend config, optional backend config, and user list config
08:20:22 <nrolland> each piece being described individually
08:22:24 <nrolland> now i can imagine having to debug the guts might be tricky but it’s a quite powerful and worthwhile techinque as well
08:23:49 <orion> Does c2hs support anonymous unions yet?
08:45:23 * hackagebot lambdacube-gl 0.2.1 - OpenGL backend for LambdaCube graphics language (main package)  https://hackage.haskell.org/package/lambdacube-gl-0.2.1 (CsabaHruska)
08:50:48 <Profpatsch> What is the #haskell opinion about https://github.com/agocorona/transient ?
08:51:05 <Profpatsch> It reads like “I solved all problems, here you go”.
08:51:13 <Profpatsch> Does it work? Are there drawbacks?
08:51:38 <Profpatsch> s/Are there/What are the/
08:52:53 <mauke`[]> drawback: documentation is painful to read
08:53:54 <saulzar> Profpatsch, Got the same feeling ..
08:54:34 <tobiasBora> saulzar: System.Directory and System.FilePath works great, thank you !
08:54:56 <saulzar> tobiasBora, np :)
08:56:43 <Profpatsch> Also, no reverse dependencies yet.
08:58:20 <Xandaros> Profpatsch: Skimming over the readme, it looks good. I might have a proper look at it later
08:59:03 <nkaretnikov> Profpatsch: ask ed kmett, who has transients
09:02:12 <Profpatsch> nkaretnikov: You mean https://github.com/ekmett/transients ? Those look like something different
09:02:18 <saulzar> Are they related? Kind of seems ed kmett's thing is something to do with mutable data structures.
09:02:29 <Profpatsch> Nah, not really.
09:02:33 <nkaretnikov> ah
09:02:36 <nkaretnikov> sorry
09:02:55 <Profpatsch> transients is kind of a generic name. :)
09:03:23 * mauke`[] uploads transience
09:20:24 * hackagebot lambdacube-gl 0.2.2 - OpenGL backend for LambdaCube graphics language (main package)  https://hackage.haskell.org/package/lambdacube-gl-0.2.2 (CsabaHruska)
09:50:31 * hackagebot tasty-golden 2.3.1 - Golden tests support for tasty  https://hackage.haskell.org/package/tasty-golden-2.3.1 (RomanCheplyaka)
09:50:33 * hackagebot tasty 0.11.0.2 - Modern and extensible testing framework  https://hackage.haskell.org/package/tasty-0.11.0.2 (RomanCheplyaka)
09:50:35 * hackagebot tasty-smallcheck 0.8.1 - SmallCheck support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-smallcheck-0.8.1 (RomanCheplyaka)
09:53:37 <bollu> what IDE does everyone use for haskell?
09:53:48 <bollu> I've tried to get into Spacemacs but I don't like it
09:54:01 <bollu> plus hindent doesn't seem to work with stack :(
09:54:54 <MarcelineVQ> I'm pretty happy with atom's haskell plugins + ghc-mod, with ghci running nearby to test outputs
09:55:22 <nkaretnikov> bollu: i use vim
09:56:53 <bollu> MarcelineVQ: oh, does it play well with stack?
09:57:19 <bollu> also, ghci question: if I load a haskell file, and then reload it, assuming the new version has a compiler error, is there any way to "keep the older version" lying around?
09:57:23 <MarcelineVQ> I've not had a problem yet, as long as I run stack-build after adding a new dependancy
09:57:38 <monochrom> no, not yet
09:58:03 <monochrom> and so there has been the idea of "run two ghci's" :)
09:59:55 <bollu> monochrom: aww
10:00:06 <bollu> monochrom: I was hoping for some flag or something that I'd missed
10:00:21 <bollu> nkaretnikov: what's your workflow with vim?
10:00:52 <Lenalunatik> Good Evening Everyone
10:00:56 <Lenalunatik> :)
10:01:22 <nkaretnikov> bollu: edit, hit ctrl-z, and compile.  or run it inside tmux if i need ghci.  pretty primitive
10:01:56 <nkaretnikov> bollu: and i don't use any haskell-specific plugins
10:02:07 <nkaretnikov> bollu: the ones that help are tabularize and commentary
10:02:54 <nkaretnikov> bollu: fwiw, the person who wrote half of hackage uses vi without plugins :3
10:03:21 <glguy> That's fairly common
10:03:47 <nkaretnikov> oh, they left :(
10:15:05 <zaquest> nkaretnikov, really? but vi doesnt even have haskell syntax highlighting out of the box...
10:15:29 <nkaretnikov> zaquest: that's what i heard
10:17:11 <bollu> nkaretnikov: thanks :)
10:17:34 <nkaretnikov> bollu: if you like bells and whistles, take a look at vim-haskell-now
10:17:51 <bollu> nkaretnikov: I shall!
10:19:26 <bollu> what tags tool does everyone use for haskell to go through codebases?
10:21:21 <nkaretnikov> bollu: ctags
10:21:37 <nkaretnikov> or hasktags if you're in emacs
10:21:47 <bollu> oh hm, cool
10:21:57 <nkaretnikov> wait
10:22:03 <nkaretnikov> ignore the ctags bit
10:22:10 <nkaretnikov> hasktags can generate tags in two formats
10:22:32 <gfixler> just tried ctags - doesn't know what haskell is :(
10:22:37 <nkaretnikov> bollu: wait a sec, i'm going to find a good intro vid for you
10:22:50 <nkaretnikov> gfixler: see above, i made a mistake
10:23:37 <nkaretnikov> bollu: http://begriffs.com/posts/2015-07-27-haskell-source-navigation.html
10:23:43 <bollu> thanks!
10:23:46 <bollu> that helps a lot
10:23:47 <nkaretnikov> bollu: not even vim-specific
10:23:55 <nkaretnikov> np
10:26:12 <gfixler> yay, stack install hasktags works
10:27:05 <gfixler> sweet, it works great in vim after a quick hasktags -c * in my project
10:40:56 <JonReed> Hi, what is the philosophy behind writing custom Show instances. Is the result only for human consumption or people expect that, e.g., "show . read . show = show", in other words that it should obey some laws?
10:41:29 <mauke`[]> it should be valid Haskell source
10:41:50 <mauke`[]> also read . show = id if instance Read
10:43:19 <JonReed> Oh ok. So it's better to just write a custom print function for pretty printing, instead of having custom show.
10:43:44 <kadoban_> JonReed: Yes, it's not for pretty-printing, more for like basic debugging usage.
11:10:27 <Pamelloes> Is there a good way to see what line(s) a haskell program is running at any given time?
11:13:55 <aaronm04> Pamelloes: Debug.Trace
11:14:15 <aaronm04> I've actually never used it, but I read about how to use it :^)
11:17:24 <Pamelloes> Well, I fixed my problem.
11:17:43 <aaronm04> ah nice
11:17:44 <Pamelloes> I had an unintended infinite loop. You'd think GHC would catch those....
11:17:52 <aaronm04> not possible
11:18:13 <aaronm04> at least not for all infinite loops a programmer could construct
11:20:28 <Pamelloes> I know, but this was a trivial infinite loop—I had basically written "let (y,z) = case (Just 10) of Just x -> (x,z); Nothing -> (0,z) in (y,z)"
11:20:38 <Pamelloes> And GHC just deadlocked.
11:20:42 <Pamelloes> err the runtime
11:21:01 <Pamelloes> Whereas, if I do that in ghci it exits with Exception: <<loop>>
11:26:02 <ski> Pamelloes : iirc, if you don't run with threaded, GHC can sometimes detect such self-chasing loops
11:26:38 <ski> (also the brackets in `(Just 10)' there are redundant)
11:27:50 <Pamelloes> It was originally a tuple and I forgot to remove the brackets when I got rid of the second element ;)
11:28:19 <Pamelloes> I am running threaded—so that means ghc won't detect loops?
11:30:36 <glguy> GHC can only detect loops where while evaluating a thunk it tries to evaluate the same thunk. GHC can optimize your program to cause that not to happen, however
11:36:46 <Pamelloes> I see.
11:38:08 <duck___> Can a monad instance not be instance of Applicative (in theory) ?
11:38:42 <glguy> No, if something has a Monad instance you can always derive an Applicative instance for it
11:38:45 <Pamelloes> duck___: Not unless the monad instance breaks monad laws.
11:39:15 <xpilot> has anyone encountered "Splices within declaration brackets not (yet) handled by Template Haskell"
11:39:37 <duck___> I'm implementing a one dimension universe as a datatype like this: data Line a = Line [a] a [a]
11:40:09 <xpilot> I'm following the singletons readme
11:40:10 <duck___> Line is a functor for sure, bu I don't know how I implement (<*>) for my Line type
11:40:26 <xpilot> duck___: it looks like you have a zipper
11:41:13 <xpilot> https://wiki.haskell.org/Zipper
11:41:17 <duck___> yes but lists implementation of (<*>) is more of a product operation, like developping expression in maths
11:41:34 <xpilot> there are actually two different ways to do <*> for lists
11:42:04 <xpilot> the cartesian product, which corresponds to ap from the Monad instance
11:42:26 <xpilot> and something more like zip
11:43:01 <duck___> thanks, I'm not familiar yet with all those typeclasses rules
11:43:19 <xpilot> the zip version translates pretty easily to your Line
11:43:53 <xpilot> the zip <*> that I'm talking about would satisfy [f, g] <*> [x, y] = [f x, g y]
11:45:15 <xpilot> note that this is not the standard <*> found in the Applicative instance for lists and it does not extend to a Monad
11:45:28 <duck___> thanks a lot
11:45:55 <xpilot> there is a newtype wrapper called ZipList which exposes this version of <*>
11:46:19 <xpilot> it's actually found in Control.Applicative
11:46:53 <xpilot> ZipList [(+1), (+2)] <*> ZipList [0, 0]
12:19:43 <mpickering> can someone please add citeproc-hs to the matrix builder queue?
12:27:23 <rpfun> i have an FFI IO () action that modifies data pointed to by a ByteArray. When I run this IO action at the ghci prompt directly, it runs and modifies the data at the pointer accordingly. But if I compile code using this function (-O2, still in the IO monad), the action appears to be a no-op, and the data at the pointer is never modified
12:27:28 <rpfun> is there a way to force an IO () action to run?
12:27:52 <rpfun> unfortunately I have no use for the FFI's return value
12:28:23 <rpfun> also, if i insert copious print statements around the FFI call to the pointer it is modifying, everything works (but obviously this is a hack and a bad solution for many reasons)
12:28:30 <glguy> rpfun: Put the code on lpaste if you can
12:29:12 <coventry> I've installed cabal on ubuntu 14.04 via the haskell-platform package.  "cabal --version" tells me 1.16.0.2, and "cabal sandbox" fails.  "cabal install cabal" tells me Cabal-1.22.4.0 is installed, though.  How do I access the 1.22.4.0 executable?
12:29:58 <athan> coventry: The haskell platform is obsolete and outdated :\
12:30:00 <glguy> coventry: The Cabal library doesn't come with a "cabal" executable, you have to build the cabal-install executable separately
12:30:15 <glguy> the one you have it built against the old version of the Cabal library
12:30:35 <glguy> You can build a new "cabal-install" package against the new Cabal library
12:30:49 <rpfun> the ffi call is here: http://lpaste.net/7253331419340996608
12:30:59 <rpfun> the extra "do" is since i have been testing with print statements
12:31:17 <khanage> @coventry is ~/cabal/bin in your path?
12:31:17 <lambdabot> Unknown command, try @list
12:31:30 <coventry> glguy: cabal-install is also installed, version 1.22.6.0.  
12:31:44 <coventry> khanage: No, there's no ~/cabal directory.
12:31:53 <khanage> @coventry whoops, .cabal
12:31:54 <lambdabot> Unknown command, try @list
12:32:05 <khanage> (sorry lambdabot)
12:32:11 <coventry> khanage: Thank you, it's there.
12:32:30 <khanage> coventry: i have a suggestion though - just install stack
12:32:42 <MarcelineVQ> If you put that folder at the beginning of your path it'll look there first
12:32:51 <glguy> khanage: That's not helpful
12:33:07 <rpfun> glguy: the actual code that calls this is an IO whose return type i use, it gets called in a loop
12:33:20 <khanage> glguy: i think coventry's problem is solved though, it's an additional suggestion
12:33:33 <khanage> coventry: try https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md
12:33:38 <coventry> glguy, khanage: What are the relative merits of stack vs what I'm trying to do right now?
12:34:03 <khanage> stack manages ghc and dependencies
12:34:12 <khanage> it calls into a curated list of deps
12:34:30 <khanage> which means you won't end up with dependency clashes
12:34:51 <khanage> coventry: i'm jumping in a little late though, and just assuming you're trying to get something to compile
12:35:08 <khanage> do you have a further problem?
12:35:08 <coventry> khanage: your assumption is correct.  I'm trying to build elm from source.
12:35:32 <shlevy> Is there a function [Maybe a] -> Maybe a that takes the first "Just" value or is Nothing if none are Just?
12:36:01 <hpc> unsafeCoerce . catMaybes
12:36:02 * hpc ducks
12:36:22 <ski> @type listToMaybe . catMaybes
12:36:23 <lambdabot> [Maybe a] -> Maybe a
12:36:39 <hpc> oh cool, that exists
12:36:51 <jg_> could someone explain the reason for the single field restriction when using 'newtype'? 
12:36:53 <rpfun> glguy: any thoughts?
12:37:06 <athan> :t getFirst . foldMap First
12:37:07 <lambdabot> Foldable t => t (Maybe a) -> Maybe a
12:37:13 <shlevy> asum seems to do it
12:37:38 <ski> jg_ : the idea is that there should be no wrapping and unwrapping overhead, so there can be only a single data constructor with a single component (argument)
12:37:43 <mpickering> jg_: The point of a newtype is that newtype A = A Int has the same representation as an Int
12:38:00 <jle`> shlevy: sum
12:38:02 <jle`> *asum
12:38:05 <jle`> oh, you already got it
12:38:19 <khanage> coventry: i'm just trying to compile elm-compiler with stack (to check that versions are correct)
12:39:41 <glguy> rpfun: I was afk, looking
12:40:14 <khanage> coventry: ok - it builds just fine with stack
12:40:17 <rpfun> glguy: thank you!
12:40:31 <zomg> coventry: in case you don't have any specific reason to compile it, you can also install it from npm :)
12:40:48 <khanage> but you need to run stack init to create the stack.yaml
12:40:56 <khanage> so... stack init && stack build
12:41:08 <glguy> coventry: The relative benefits of what? It seems like what you're trying to do is install cabal-install
12:42:08 <glguy> rpfun: "Yield a pointer to the array's data. This operation is only safe on pinned byte arrays allocated by newPinnedByteArray or newAlignedPinnedByteArray.
12:42:21 <rpfun> yep, allocated with newPinnedByteArray
12:42:23 <glguy> rpfun: Is your bytearray one of those?
12:42:53 <rpfun> glguy: yep
12:43:15 <glguy> rpfun: Then I think that this code is probably fine and that the problem might be around the callsite
12:43:36 <rpfun> glguy: if i paste it, could you take a look?
12:44:26 <athan> Ah wow I didn't know the alternative instance for Maybe ~ First
12:44:52 <glguy> rpfun: I'd look. I'm not promising that I know the answer :) Someone else might, too
12:45:26 <rpfun> here it is: http://lpaste.net/3647141891092250624 , the call is baClearBits, the code definitely gets there, but in the compiled version nothing happens to the bytearray
12:47:42 <coventry`> Now it's failing with "Not in scope: `<$>' Perhaps you meant `</>' (imported from System.FilePath)" at src/Elm/Package.hs:60:25... in elm-compiler, which was working before.  Sigh.
12:48:24 <Haskell_Newbie> Hello, guys. I'm a newbie and would like more experienced people to look at my code and criticize/give tips. Would you know where I can get code reviews (on possibly boring code)?
12:48:52 <Arahael> Haskell_Newbie: Have you tried hlint?
12:49:12 <Arahael> Haskell_Newbie: And stack clean && stack build --pedantic?
12:50:16 <Haskell_Newbie> Arahael: I have no idea what those things are. I guess I will google hlint and "stack" .-. Thanks!
12:50:38 * hackagebot GPipe 2.1.5 - Typesafe functional GPU graphics programming  https://hackage.haskell.org/package/GPipe-2.1.5 (TobiasBexelius)
12:50:46 <Arahael> Haskell_Newbie: For stack, I just meant: Did you compile with *all warnings enabled*? -wall?
12:51:18 <Haskell_Newbie> Arahael: Oh yes. I did load it with -Wall 
12:52:06 <Arahael> Haskell_Newbie: So now you just need to learn about hlint.
12:52:53 <glguy> rpfun: I don't know, I've never tried exporting mutablebytearrays like this via the FFI
12:53:16 <ski> Haskell_Newbie : you could also try pasting the code, showing it to this channel (or perhaps #haskell-beginners)
12:53:18 <glguy> I suspect that the C code is running but the optimizer is assuming that the pointer didn't change and is using an older value or something
12:53:19 <ski> @paste
12:53:19 <lambdabot> Haskell pastebin: http://lpaste.net/
12:53:33 <glguy> rather that the values at the Addr# didn't change
12:53:47 <rpfun> glguy: but it shouldn't be allowed to do that, no? :)
12:54:02 <rpfun> glguy: the weird part is it works great if i just load it into the interpreter
12:54:03 <glguy> Depends, I'm not sure if you're allowed to do what you're doing
12:54:14 <glguy> the interpreter does 0 optimizations, basically
12:54:43 <Haskell_Newbie> ski: Didn't know there was an IRC chat specifically for beginners. I will post there thanks!
12:54:59 <glguy> #haskell is fine for beginner questions
12:55:08 <rpfun> glguy: thanks for your advice so far. i thought as long as the action was IO () the optimizer could make no assumptions about this sort of thing?
12:55:15 <coventry`> So to use stack I do "stack runhaskell BuildFromSource.hs 0.16" in place of "runhaskell BuildFromSource.hs 0.16", right?
12:55:26 <glguy> rpfun: I'd be surprised if your C function wasn't running
12:55:27 <rpfun> and if i'm not allowed to modify the data pointed to by bytearrays in C, what other structure could I possibly use?
12:55:35 <glguy> I think it's making assumptions about the Addr#
12:55:52 <coventry`> When I do that, "No compiler found, expected minor version match with ghc-7.10.2 (x86_64) (based on resolver setting in /home/coventry/.stack/global-project/stack.yaml)."
12:55:56 <rpfun> glguy: so like caching the array? hmm. any way to force it?
12:56:06 <khanage> coventry`: i assume that stack build is not enough for you?
12:56:18 <rpfun> if i add prints of all the elements of the bytearray in baClearBits it works
12:57:01 <coventry`> khanage: The build script looks straightforward enough... can probably transnlate.
12:58:12 <athan> glguy: Is there an advanced haskell channel?
12:58:34 <koshmar> give me please explainging example for fix function
12:59:50 <rpfun> glguy: i just added a printf to the c function. you're completely right! my c function gets run exactly as many times as I expect
12:59:53 <khanage> coventry`: try stack setup
13:00:03 <lpsmith> koshmar,  take any recursive function,  like   fact = \n -> if n == 0 then 1 else n * fact (n-1)
13:00:07 <glguy> athan: There are lots of #haskell channels, but I don't think there's a #haskell-advanced or similar specifically
13:00:10 <rpfun> glguy: so is there anything I can do about it?
13:00:33 <lpsmith> then you can open the recursion like this:   fact = \fact n -> if n == 0 then 1 else n * fact (n-1)
13:00:43 <coventry`> khanage: Thanks, that looks like it's doing sensible things.
13:00:53 <lpsmith> that's no longer recursive:  "fact (n-1)" actually refers to the parameter
13:01:14 <lyxia> fix $ \fact ...
13:01:25 <lpsmith> then you can close it again:   fact = fix $ \fact n -> if n == 0 then 1 else n * fact (n-1)
13:01:28 <glguy> rpfun: If you want arrays you can use with the FFI I'd probably start with Foreign.Marshal.Alloc and peek/poke methods from Storable
13:01:42 <Cale> athan: pls no :)
13:01:57 <glguy> I don't know how to use stuff from the primitive package with the FFI
13:01:57 <Cale> There are already way too many channels
13:02:04 <hsk4> Every blog on Haskell have the platitude "once you get your Haskell code to compile, it usually just works!". Why isn't this equally true of say C++, which is also statically typed?
13:02:08 <rpfun> glguy: ok. for academic reasons, do you know why it might not be working?
13:02:26 <rpfun> i thought the primitive stuff was supposed to be the fastest, which is why i went for it
13:02:27 <Cale> hsk4: Because Haskell types say quite a bit more about what the program is allowed to do, or at least, can.
13:02:49 <Arahael> hsk4: And haskell's types are far more restrictive.
13:02:54 <Cale> hsk4: Also, Haskell expression evaluation is not generally allowed to have arbitrary effects like in C++
13:03:06 <Arahael> Specifically, that.
13:03:12 <Cale> So, when you have a function Integer -> Integer, say, you know that it doesn't, for instance, do network IO
13:03:19 <coventry`> hsk4: You have to really beg for it to get a segfault from haskell.
13:03:42 <Arahael> Why is 'fix' required/
13:03:47 <hsk4> ok thanks
13:04:10 <Cale> hsk4: Polymorphism also helps a lot
13:04:21 <Cale> hsk4: Consider as a small example, the type of map
13:04:22 <lpsmith> koshmar, "fix" is useful in cases when you want to create a recursive function as an expression,  or when the thing you are taking a fixpoint of is a composition of several other functions.
13:04:23 <Cale> :t map
13:04:24 <lambdabot> (a -> b) -> [a] -> [b]
13:04:24 <Arahael> *parametric* polymorphsm.
13:04:32 <Cale> Yeah, *parametric* polymorphism
13:04:45 <Arahael> C++ does have that, incidentially. (Via templates)
13:04:51 <Cale> Kind of.
13:04:58 <hsk4> but then you're into metaprogramming hell
13:05:07 <koshmar> thx
13:05:16 <lpsmith> koshmar, http://www.dsi.uniroma1.it/~labella/absMcAdam.ps
13:05:23 <Cale> Yeah, and you can special case what happens for specific types, which defeats the guarantees it would otherwise give you
13:05:37 <coventry`> khanage: The build script is failing with "cabal: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with Cabal."  Is there a way to tell stack not to use GHC_PACKAGE_PATH?
13:05:40 <Cale> map here is a function which takes a function of type (a -> b) for some types a and b
13:05:44 <Cale> and a list of values of type a
13:05:49 <Cale> and produces a list of values of type b
13:05:53 <Cale> @src map
13:05:53 <lambdabot> map _ []     = []
13:05:53 <lambdabot> map f (x:xs) = f x : map f xs
13:05:59 <Cale> Let's consider some possible bugs
13:06:07 <Cale> What if the second line were:
13:06:13 <Cale> map f (x:xs) = x : map f xs
13:06:20 <Cale> Well, that's a type error!
13:07:02 <Cale> We forgot to apply the function, so we're actually producing a list of values of type a now, and a and b might not be the same type
13:07:37 <Cale> map also can't, say, inspect the type b, and when it's Integer, produce a list of 0's or something like that
13:07:53 <Cale> map can't do anything to actually observe what the values of type a and b are
13:07:54 <khanage> coventry`: you could try `unset`
13:07:58 <Arahael> Ala generics.
13:08:20 <coventry`> khanage: It's not set in my working shell.  Do you mean in the build script?
13:08:31 <Cale> The only way to get a value of type b is to apply the function, and so we're at least guaranteed that every element of the resulting list is obtained by applying the function to some element of the input list.
13:08:38 <khanage> coventry`: no - i meant unset ENV
13:09:18 <Cale> This eliminates enough of the possible incorrect programs that you almost have to be trying to get the program wrong
13:09:30 <coventry`> khanage: What stack commands did you use to build the compiler?
13:09:30 <koz_> Is there a way I can define a type which is just like Numeric.Natural.Natural, but not including 0?
13:09:31 <Cale> e.g. you might just always produce an empty list
13:09:48 <Cale> or you might go and reverse the resulting list
13:09:56 <khanage> coventry`: stack build
13:10:09 <khanage> coventry`: stack init first sorry
13:10:14 <khanage> stack init && stack build
13:10:42 <khanage> in my stack.yaml
13:10:50 <khanage> i have the resolver lts-3.13
13:10:54 <coventry`> OK, once the compiler is built, do I need to publish it somewhere in a local stack repository for the other elm packages which depend on it to find it?
13:12:01 <khanage> if you run `stack install` it will copy the compiler to ~/.local/bin
13:12:10 <coventry`> Thanks, I'll give that a go.
13:15:26 <krgn> I would like to draw to an x11 window (the DefaultRootWindow in particular). Are the Window types in OpenGL and X11 compatible?
13:16:21 <krgn> I am not quite sure which set of libraries I can use with, say, X11. Please advise :)
13:19:58 <coventry`> khanage: "stack build" in elm-package is failing with "elm-compiler: needed (==0.16.*), not present in build plan (latest is 0.15)", despite doing "stack install" in elm-compiler.  Is there another stack command for locally publishing a package?
13:21:29 <nawal_> Hi guys, I'm reading https://github.com/kqr/gists/blob/master/articles/gentle-introduction-monad-transformers.md
13:21:42 <suppi_> coventry`, from what I know elm related stuff is no longer on hackage, I would recommend using the BuildFromSource.sh script to build elm
13:21:47 <nawal_> and trying to annotate the intermediate results in the applicative instance
13:21:48 <nawal_> http://pastebin.com/RZww1bXf
13:22:43 <nawal_> I'm struggling to reconcile liftA2's first parameter type  a->b->c with the parameters of (<*>)
13:23:44 <coventry`> suppi_: Thanks for the suggestion.  I started there, but ran into other problems.
13:23:49 <nawal_> Sorry, full paste here: http://pastebin.com/nF1ECqZw
13:24:46 <glguy> nawal_: liftA2's first parameter having type  (a -> b -> c) means that the only constraints it imposes on its argument is that it's a function that returns a function
13:25:08 <glguy> (<*>) :: f (x -> y) -> f x -> f y
13:25:25 <glguy> so a is unified with f (x -> y), b is unified with f x, c is unified with f y
13:26:11 <koz_> Is there a way I can define a type which is just like Numeric.Natural.Natural, but not including 0?
13:27:02 <nawal_> thanks glguy *back to the drawing board*
13:27:17 <khanage> coventry`: what are you trying to achieve exactly? you're trying to compile all of elm from source?
13:27:27 <coventry`> khanage: Yes.
13:27:31 <jle`> nawal_: you're looking to figure out liftA2 (<*>) (runEitherIO f) (runEitherIO x); runEitherIO f is IO (Either e (a -> b)), runEitherIO x is IO (Either e a)
13:27:34 <coventry`> Esp. elm-reactor.
13:28:23 <jle`> nawal_: liftA2 :: (a -> b -> c) -> IO a -> IO b -> IO c, so you want liftA2 :: ?? -> IO (Either e (a -> b)) -> IO (Either e a) -> IO (Either e b)
13:28:42 <jle`> nawal_: so the type that it's inferring of (<*>) there is Either e (a -> b) -> Either a b -> Either b
13:29:20 <jle`> honestly the way it's written there isn't how I'd write it; i'd probably use explicit do notation and pattern matching
13:29:24 <coventry`> The stack.yaml boilerplate has extra-include-dirs and extra-lib-dirs.  Can I set these to point to the elm-compiler results, somehow?  Neither /home/coventry/src/elm-platform/Elm-Platform/0.16/elm-compiler nor /home/coventry/src/elm-platform/Elm-Platform/0.16 works there, though.
13:30:01 <nawal_> joe`, I got   -- (<*>) :: EitherIO e (a -> b) -> EitherIO e a -> EitherIO e b
13:30:32 <jle`> that is one way (<*>) can be instantiated, yes
13:30:52 <jle`> but that's not how it's instantiated on line 31
13:33:38 <Arahael> Given a code base.  How do I identify all the useless imports (even the () imports), and dead code?
13:34:01 <rpfun> i am trying to modify a Mutable Storable Vector through the FFI, and my procedure works well as long as optimizations are not applied, but when they are, my vector doesn't get modified as many times as it should, despite the C calls happening (printf statements in c functions)
13:34:15 <rpfun> does anyone know how to work with this problem?
13:35:10 <Arahael> rpfun: Yes.  A guy named "rpfun" had the same issue about an hour or so back.
13:35:41 <rpfun> Arahael: yes, but that was not with vectors but ByteArrays, which people appear to be less familiar with
13:35:52 <rpfun> and now the modifications happen, but not all of them
13:36:09 <rpfun> i'd consider it a different problem, since the storable vectors are managed differently from ByteArrays
13:36:38 <Arahael> rpfun: I'm still very new to haskell, but isn't it the same root issue?  You're trying to mutate something that haskell isn't completely aware of being mutable?
13:37:16 <rpfun> Arahael: the whole point of /Mutable/ Storable Vectors is mutating them through the FFI
13:37:22 <glguy> rpfun: The documentation for mutable, storable vectors says not to modify them through their foreignptrs
13:37:39 <rpfun> glguy: really? where?
13:38:16 <coventry`> How do I burn all ghc-related files to the ground to start a fresh install?
13:38:39 <Arahael> coventry`: Toss it out of the window.  Order a new laptop.
13:38:46 <glguy> rpfun: all over the place in the documentation for that module
13:38:54 <rpfun> glguy: it does say " Modifying data through the pointer is unsafe if the vector could have been frozen before the modification.", but i never freeze my vectors at all
13:39:10 <rpfun> glguy: are you looking here? http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Storable-Mutable.html
13:39:44 <rpfun> look at the last function, unsafeWith. it's my impression modifying vectors through that should be fine
13:40:48 <coventry`> So if haskell-platform is out of date, and stack is incompatible with elm's build script, what's the right way to get cabal on an ubuntu system?
13:41:29 <Cale> coventry`: I don't know about elm or stack, but I usually just get cabal-install from Hackage
13:41:39 <khanage> coventry`: ok, so i was able to compile that by copying over the stack.yaml for elm-compiler into elm-pacakge
13:41:54 <khanage> and adding an extra line to the packages
13:41:57 <Cale> http://hackage.haskell.org/package/cabal-install-1.22.6.0/cabal-install-1.22.6.0.tar.gz
13:42:39 <Arahael> coventry`: Why is stack incompatible with elm - isn't elm a different language?
13:43:00 <Arahael> I guess elm's build script is haskell!?
13:43:09 <Cale> Yeah, I thought Elm was a different language as well, I wouldn't imagine that it's compatible with any of the tools for Haskell.
13:43:24 <khanage> coventry`: also, if you want to get rid of a package, can't you use the appropriate uninstall? like, apt-get remove, brew uninstall etc?
13:43:33 <Cale> Oh, he's trying to build Elm?
13:44:05 <mariooo> Hey guys – I'm working through https://wiki.haskell.org/Arrow_tutorial, but I can't get the Kleisli example to compile. Any idea why the `liftA2` is having issues in that example? Here's the full error and my code: https://gist.github.com/supermario/369afe958d2996e9fcd8
13:44:25 <Cale> The Elm compiler is written in Haskell
13:44:31 <coventry`> khanage: e.g., "apt-get remove stack" did not delete "~/.stack".
13:44:33 <lpaste_> khanage pasted “Elm with stack” at http://lpaste.net/146017
13:45:10 <Cale> mariooo: Wrong liftA2
13:45:17 <rpfun> glguy: can you point out what I am missing?
13:45:19 <Xeironis_> Arahael: is there a point to having () imports in the first place?
13:45:35 <coventry`> khanage: I see.  Thanks.  I'll give that a try if I loop back to stack.
13:45:37 <Cale> mariooo: I'm guessing that tutorial was written before Control.Applicative even existed
13:45:44 <Shockk> Xeironis_: to import instances, I think
13:45:46 <khanage> coventry`: no, .stack is a runtime artefact - apt-get remove haskell-platform won't delete .cabal either
13:45:51 <Xeironis_> ah
13:46:09 <coventry`> khanage: Yes, that's why I was asking what I need to delete
13:46:22 <mariooo> Cale: looks like it's had updates are recently as 2014 though. Which liftA2 would I need then? According to Hoogle the only one is in Control.Applicative...
13:46:51 <Arahael> Xeironis_: Yes.  For instances.
13:46:51 <khanage> it should suffice to just remove it from your path
13:47:03 <khanage> if you're getting issues
13:47:31 <Xeironis_> thanks
13:48:42 <mariooo> Cale: or alternatively, if you could point me in the right direction for getting the kleisli example to work – I was kinda banking on seeing it's output to try figure out what it does / how it works :(
13:48:49 <jle`> it's kind of weird becuase i'd expect Kleisli to have an Applicative instance
13:48:57 <jle`> but it doesn't
13:49:11 <jle`> what gives?
13:49:26 <jle`> you can define your own instance, marioo, until we can sort out what is going on
13:49:32 <nawal_> jle`, glguy thanks!
13:49:48 <Cale> mariooo: It's defined just above there in the tutorial
13:49:56 <Cale> > liftA2 :: (Arrow a) => (b -> c -> d) -> a e b -> a e c -> a e d
13:49:56 <Cale> > liftA2 op f g = split >>> first f >>> second g >>> unsplit op
13:49:57 <lambdabot>      Could not deduce (Applicative (a1 e1))
13:49:57 <lambdabot>        arising from a use of ‘liftA2’
13:49:57 <lambdabot>      from the context (Arrow a)
13:49:58 <lambdabot>  <hint>:1:15: parse error on input ‘=’
13:50:00 <Cale> oops
13:50:17 <Cale> You may have to name it something other than liftA2
13:50:36 <jle`> ah i guess the "A" there means "arrow", heh
13:51:07 <Cale> yeah
13:51:58 <jle`> i still feel like Kleisli should at least have a Functor/Applicative instance in base.  even if there are people against the Monad instance.  Applicative and Arrow usage are so intertwined these days
13:53:18 <Cale> I kind of think that Arrow's laws should be changed in a way which would usually disallow Kleisli apart from commutative monads (of which there are very few)
13:54:06 <mariooo> Ok – so defining my own instances of liftA2 (dropping the Control.Applicative include entirely), as well as split and unsplit has done the trick.
13:54:31 <mariooo> I guess the begginner pitfall for me here was I just assumed the examples were just showing me existing source for things like liftA2 and split and unsplit
13:54:45 <Cale> The problem with Arrow is that it's usually kind of useless as an abstraction right now, because it largely undermines the applications which would otherwise take advantage of it.
13:55:12 <mariooo> Hrm. Can you explain what you mean by that, perhaps with an example?
13:55:15 <Cale> A lot of that has to do with 'arr', but it's not only arr -- it's the fact that you have to use arr in order to obtain many basic wiring operations
13:55:50 <mariooo> The context under which I'm motivated to learn Arrows presently, is on the back of jekors tutorials on Yampa and FRP.
13:56:10 <Cale> A big advantage that Arrow has over Monad, for instance, is that when you define a computation using (>>=), the right hand parameter is a function, and functions are black-boxes to analysis
13:56:13 <jle`> Arrow also isn't too relevant in today's modern haskell is because Applicative now takes the role of what most of what Arrow used to do before
13:56:21 <jle`> mariooo: in that case, i don't recommend learning about arrows in general, really
13:56:25 <Cale> You can't analyse what a function does at runtime prior to applying it
13:56:35 <jle`> mariooo: i'd recommend learning about the specific types in Yampa
13:56:47 <jle`> (yampa is also pretty out of date too; netwire is probably the more modern alternative)
13:56:51 <Cale> While with computations built from (>>>), both arguments are of a type which we may control
13:57:19 <coventry`> So when I try to build  elm with the recommended procedure, using cabal 1.22.4.0, the first failure is on this line with "Not in scope: `<$>'".  https://github.com/elm-lang/elm-compiler/blob/master/src/Elm/Package.hs#L60
13:57:31 * mariooo sighs and opens even more browser tabs...
13:57:38 <Cale> and so we might be able to do some analysis to optimise the interpretation of f >>> g before that interpretation begins
13:57:47 <coventry`> There are a bunch of similar complaints throughout Package.hs, for <$> and <*>.  What could be causing this?
13:58:02 <jle`> mariooo: learning how to use a type by learning everything about an abstraction is like learning how to use lists by learning everything about Monads, Monoids, APplicatives, Functors
13:58:05 <Cale> mariooo: Make sense?
13:58:21 <coventry`> It's a difficult error to google for.
13:58:25 <Cale> (so far)
13:58:34 <jle`> mariooo: you don't need to learn about Monoids/Monads to use lists.  just use `map`, or `filter`, or pattern matching...learn about the type itself, not about the abstraction in general :)
13:58:37 <Cale> I don't have a lot of time right now
13:59:00 <mariooo> Cale: not 100%, but I think I've got a vague intuition about what you're trying to get across
13:59:02 <Cale> okay
13:59:09 <jle`> but yeah, i don't recommend yampa at this point; netwire has more or less supplanted yampa in functionality and offers a more modern Arrow+Applicative hybrid based interface.
13:59:16 <coventry`> I've beat my head against this long enough.  Time to file another issue against elm-package, I guess.
13:59:37 <Cale> So, the reason that Arrow undermines this kind of analysis is that it pretty much requires you to use arr all the time in order to wire things up
13:59:59 <Cale> There's no primitive  swap :: (Arrow a) => a (b,c) (c,b)
14:00:18 <Cale> or  rAssoc :: (Arrow a) => a ((b,c),d) (b,(c,d))
14:00:20 <Cale> etc.
14:00:28 <mariooo> Cale: the "bending" point for me at the moment is "functions are black-boxes to analysis" –> I'm taking that as meaning (possibly) because you might be binding a function of type (a -> d), whereas with arrows you'd have all the more general intermediary parts, which may have some optimisation possible prior to interpreting them into GHC land for example... 
14:00:58 <Cale> mariooo: Yeah, like values of type MyArrow s t are data structures of some sort
14:00:58 <zoku> YAARRRRR
14:01:03 * hackagebot lens-tutorial 1.0.1 - Tutorial for the lens library  https://hackage.haskell.org/package/lens-tutorial-1.0.1 (GabrielGonzalez)
14:01:08 <Cale> which we might be able to pattern match on
14:01:14 <mariooo> Cale: yeah cool! :D
14:02:08 <Cale> So at runtime, the implementation of >>> might look at its two arguments and determine that it can combine them into a program which is easier to evaluate than simply the one which runs both
14:02:28 <Cale> However, arr spoils this completely by introducing lots of functional black boxes everywhere again
14:02:28 <mariooo> jle`: where were you 6 months ago when I was banging my head against all the Monad tutorials, and then one suddenly, "omg a list is a Monad are you srs"
14:02:44 <Cale> mariooo: a list isn't a monad, the type constructor for lists is a monad
14:03:03 <Cale> (this is a nitpick though)
14:03:10 <mariooo> Hrm. A list is an instance of a Monad? Would that be correct to say?
14:03:10 <Cale> For example, IO is a monad, but getLine is not
14:03:32 <mariooo> Ok wow hold on, let me process that.
14:03:32 <Cale> "List" (that is, the type-level []) is an instance of Monad
14:03:48 <Cale> class Monad m where ...
14:03:57 <Cale>   return :: a -> m a
14:04:05 <Cale>   (>>=) :: m a -> (a -> m b) -> m b
14:04:19 <mariooo> So what about my "realisation" -> "a list is a Monad" is analogous to me saying "getLine is a Monad"?
14:04:21 <Cale> The type constructor m is what we call a monad
14:04:25 <jle`> but yeah, trying to understand how to use lists in haskell by understanding monads is a little silly.  learning to understand lists using the functions/combinators you use on lists (sum, foldr, map, filter, etc.) is the way to go
14:04:26 <Cale> yeah
14:04:34 <Cale> [1,2,3] isn't a monad
14:04:58 <Cale> But it is an action of the list monad
14:05:06 <mariooo> Aha... I'd say that's a value?
14:05:06 <Cale> > [1,2,3] >>= (\x -> [x,x])
14:05:08 <lambdabot>  [1,1,2,2,3,3]
14:05:51 <Cale> Yeah, in Haskell, monads aren't values, they're type level things
14:06:17 <mariooo> > :t (>>=)
14:06:19 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:06:25 <Cale> Maybe in a dependently typed language, they'd be values as well (but still getLine would not be a monad)
14:06:25 <mariooo> Heh, just wondering.
14:06:31 <mariooo> (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:06:31 <Shockk> :t (>>=)
14:06:32 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:06:38 <mariooo> Right, got it.
14:07:12 <mariooo> So the [1,2,3] isn't itself a Monad, but it's List Int, List being the instance of Monad
14:07:17 <Cale> yeah
14:07:24 <mariooo> Weow, learning.
14:07:32 <mariooo> Thanks :thumbsup:
14:07:36 <Cale> no problem
14:07:54 <jle`> 👍
14:08:34 <Xeironis_> now, this feels like a stupid question, but is coerce safer than unsafeCoerce?
14:09:02 <Adeon> yes
14:09:08 <Xeironis_> how?
14:09:19 <jle`> "there are no stupid questions, only stupid .... oh"
14:09:32 <jle`> jk, it's a very fair question :)
14:09:37 <mariooo> jle`: I had all the intuition/understanding around lists in general, but I guess all the "mystery" around Monads in general and style of tutorials never led me to connect the two in anyway. By the time I realised Monads had anything to do with List as an example of one, I was so far down the Monad rabbit hole already.
14:09:56 <Adeon> with coerce unsafe coercing does not compile...although if I recall correctly it's a bit magical
14:10:09 <Xeironis_> ok
14:10:17 <Adeon> unsafeCoerce will just let you coerce anything
14:10:25 <Xeironis_> I see, thanks
14:11:42 <jle`> Xeironis_: coerce can still only coerce things that GHC can prove are coercible/have the same runtime represenation
14:11:50 <Xeironis_> Ah
14:12:05 <jle`> which isn't necessarily *all* things that have the same runtime representation
14:12:13 <Xeironis_> that makes sense
14:12:53 <jle`> in particular it deals with things having the same rep becuase they're newtypes of each other, and things like that, i believe
14:13:20 <Xeironis_> I saw castPtr = coerce
14:13:27 <Xeironis_> which is why I'm asking the question
14:13:43 <coventry`> Are <$> and <*> not in the default scope?  Should I need to import them from Control.Applicative in order to use them?
14:14:29 <exio4> coventry`: they are in Prelude in GHC 7.10
14:15:38 <coventry`> Ah... and I have ghc 7.6.3.
14:22:52 <jle`> yikes
14:23:05 <ania12> ?
14:23:43 <jle`> ghc 7.6.3 :O
14:24:33 <Xeironis_> outdated since 9th April 2014
14:24:59 <jle`> really? :O  feels like so long ago :|
14:25:14 <jle`> could have sworn it was in like 2010 or something v.v
14:25:16 <Xeironis_> well, at least that's the next version that's on the ghc front page
14:25:36 <Xeironis_> no, 7.6.3 was released on 21st april 2013
14:26:47 <Xeironis_> the release dates seem rather inconsistent
14:27:12 <Xeironis_> ah, maybe not. Looks like there's a pattern
14:28:18 <coventry`> jle: I'm on an ubuntu 14.04.3 machine.  http://packages.ubuntu.com/trusty/haskell/ghc
14:29:00 <siddhu> coventry`: Look at hvr's PPA for getting newer versions of GHC
14:29:13 <coventry`> siddhu: Yep, that's what I'm building with now.
14:31:42 <coventry`> OK, I have elm-reactor built from source.  Whew.
14:33:43 <coventry`> Is there a way to check the ghc version, from within haskell?  And a better way to check the cabal version than to run the system command "cabal --version" and parse the output?
14:34:59 <cite-reader> There's a CPP macro you can interrogate at compile time to discover the GHC version, but I don't remember what it is.
14:59:58 <Hafydd> __GLASGOW_HASKELL__, I believe.
15:30:08 <coventry`> What's the right way to abort when a Boolean is false?  I'm trying to use Control.Exception.Assert, here, but I'm getting "No instance for (Num (IO t0)) arising from the literal ‘1’": http://pastebin.com/SAmR2z8g
15:31:52 <Arahael> coventry`: '1' doesn't look much like a boolean to me?
15:32:06 <Arahael> coventry`: Is it supposed to indicate false?
15:32:33 <coventry`> checkVersions, the first argument to assert, is a Boolean.
15:33:36 <coventry`> Essentially, I want to do "if checkVersions then exitFailure", but that doesn't work either.
15:33:55 <Arahael> coventry`: Should I repeat my question?
15:35:05 <coventry`> Arahael: The signature for assert is assert :: Bool -> a -> a.  The second argument to it can be anything.
15:36:20 <Arahael> coventry`: What is the boolean you're providing?
15:36:24 <coventry`> checkVersions
15:36:40 <Arahael> coventry`: What is the type of checkVersions?
15:36:59 <coventry`> Says it's a Bool right there on the tin.  (Top of the pastebin.)
15:38:40 <Arahael> coventry`: I was only going off the error you're getting. Haskell errors tend to be very helpful.
15:39:20 <coventry`> 1 is a dummy argument.  If you have any alternative suggestions I'm open.
15:47:49 <Arahael> coventry`: The overall type of the 'assert checkVersions', is then Integer.
15:50:06 <coventry`> Yes, "dummy" gets assigned an integer value in a do block, followed by other instructions.
15:50:47 <flobber> helo all
15:51:00 <flobber> why can I do this
15:51:00 <flobber>  map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]
15:51:03 <flobber> but I cannot do this
15:51:12 <flobber>  map (*3) . [1,2,3,4,5]
15:51:31 <flobber> :t map (*3) takes a parameter [b]
15:51:33 <lambdabot>     Not in scope: ‘takes’
15:51:33 <lambdabot>     Perhaps you meant one of these:
15:51:33 <lambdabot>       ‘take’ (imported from Data.List),
15:51:36 <geekosaur> because (.) composes functions
15:51:42 <flobber> :t map (*3)
15:51:43 <geekosaur> and [1,2,3,4,5] is not a function
15:51:43 <lambdabot> Num b => [b] -> [b]
15:51:49 <flobber> oh
15:51:51 <flobber> simply as
15:51:57 <geekosaur> :t (.)
15:51:59 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:52:06 <flobber> ok
15:52:07 <flobber> got it
15:52:09 <flobber> thanks ;)
15:52:13 <flobber> happy thanks giving
15:52:17 <geekosaur> your list is trying to be the (a -> b) there 
15:55:39 <bollu> the reason Applicative needs "pure" is so that we can re-define functor from Applicative, right? (i.e, to make the statement "every applicative is a functor)?
15:55:50 <bollu> is there a deep reason as to why applicative needs pure?
15:57:51 <hpc> bollu: there were plans to split it into a new class Point
15:58:10 <hpc> bollu: but the only law Point would have is in relation to (<*>), and it turns out that law was a free theorem
15:58:30 <bollu> where Point had a -> f a?
15:58:39 <bollu> hpc: "free theorem" from..?
15:58:59 <hpc> a free theorem is a property that comes out of the types of things
15:59:16 <hpc> it's sort of like you get it "for free" because you don't really need to do anything for it or think about it at all
15:59:22 <coventry`> Arahael: I see where you were pointing now.  Thanks.
15:59:24 <hpc> free theorems can be derived automatically
15:59:52 <bollu> hpc: hm, no, I was asking, we get the theorem from *what*? Pointed + Applicative?
15:59:57 <hpc> oh
16:00:03 <hpc> from the type of pure :: a -> f a
16:00:13 <hpc> and (<*>) :: too-sleepy-to-type
16:00:22 <bollu> hpc: I'm sorry if I came across as rude :) I'm just incredibly sleepy
16:00:22 <coventry`> Why can't I have dummy assigned to an int there, though?  Why is "assert checkVersions (return ())" the correct way?
16:00:30 <bollu> ahh, thanks
16:00:36 <hpc> bollu: ;)
16:01:10 <hpc> bollu: look up "theorems for free" if you want to halfway-understand the original paper
16:01:36 <hpc> ive skimmed it but haven't spent the time to read it completely
16:01:51 <bollu> thanks :)
16:01:57 <hpc> lambdabot also has a @free command that i have no idea how to use
16:02:02 <bollu> (and thus, my pile of haskell grows again) :P
16:02:06 <hpc> which is the automation
16:02:15 <bollu> this one? http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
16:02:58 <hpc> exactly that
16:03:30 <bollu> thanks :)
16:03:59 <geekosaur> @free a -> f a
16:03:59 <lambdabot> Extra stuff at end of line
16:04:15 <Xeironis_> @free pure
16:04:22 <lambdabot> Extra stuff at end of line in retrieved type "Applicative f => a -> f a"
16:04:22 <geekosaur> right, I'm too tired today :/
16:04:40 <Xeironis_> everyone seems to be tired today
16:04:48 <hpc> everyone in the US anyway :P
16:04:51 <dalastboss> Do both of these implementations use constant space? Or only the latter?
16:04:52 <ryan___> Hi all, I'm trying to go through exercise 2 of https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing and am having difficulties with it. For some reason, my code (http://lpaste.net/146027) incorrectly accepts strings like "AAA""
16:04:56 <dalastboss> http://pastebin.com/ZJdJaLp8
16:05:04 <dalastboss> *implementations of fib
16:05:53 <bollu> xD
16:07:44 <glguy> dalastboss: You'll need to specify that you don't want any left-over characters
16:08:06 <Xeironis_> glguy: I think you mean ryan___ ?
16:08:17 <glguy> Oh, yup
16:09:51 <ryan_____> how do i specify that i don't want any remaining characters?
16:10:03 <glguy> dalastboss: Due to laziness those potentially both use linear space
16:10:15 <coventry`> Oh, you can only use do to chain actions in the same monad.  I get it now.
16:10:27 <glguy> dalastboss: They might be accumulating thunks in the addition expressions
16:10:48 <glguy> dalastboss: but resolving that they could both use constant space
16:12:31 <glguy> ryan_____: http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec.html#v:eof
16:13:27 <dalastboss> glguy: not sure i understand. could you elaborate?
16:13:42 <glguy> which part?
16:29:16 <Ankhers> Does anyone know of any maintained Qt Haskell bindings? And on a different note, how does Qt look on OS X?
16:32:04 <geekosaur> the answer to the second is "lousy"
16:33:47 <hpc> the qt bindings are lousy too
16:36:15 <cmears> Does Qt really look that bad on OS X?
16:36:35 <geekosaur> yes
16:37:30 <geekosaur> the claim I am aware of is they got into a fight with Apple over an early Qt built-in theme that made it fit into Aqua better, and in the end not only used a crappy theme but disabled theming on OS X
16:37:31 <luis> Hmm, it looks acceptable to me. I use LyX and Anki.
16:37:41 <cmears> I guess I've never noticed
16:38:00 <geekosaur> I hear about it a lot from calibre users on OS X >.>
16:38:21 <luis> Oh, calibre looks funky. That's true.
16:38:37 <cmears> Yeah, calibre looks a bit odd
16:38:46 <luis> But I don't think that's Qt's fault.
16:38:56 <geekosaur> but have also seen various other programs using "raw" Qt that look pretty bad. have also seen programs that go out of their way to try to look better...
16:40:56 <taksuyu> Can anybody point me in the direction of a haddock property checker? I can't seem to figure out how others have done it.
16:46:16 * geekosaur will also note that the complaint about calibre on OS X is compared to calibre on Windows/Linux, not to other OS X programs
16:46:30 <geekosaur> since calibre does have an ... interesting ... UI
16:49:02 <hiptobecubic> I use a lot of Qt on OSX. It looks fine.
16:49:14 <hiptobecubic> as fine as Qt ever looks, at least
16:50:52 <Ankhers> Thanks for the tips
17:03:39 <M-davidar> there's also http://www.gekkou.co.uk/software/hsqml/ but I haven't tried it yet
17:24:22 <hiptobecubic> HsQML is alright, but it's not very haskelly
17:24:55 <hiptobecubic> Its model is javascript-with-haskell-callbacks
17:31:12 * hackagebot lifted-async 0.7.0.2 - Run lifted IO operations asynchronously and wait for their results  https://hackage.haskell.org/package/lifted-async-0.7.0.2 (MitsutoshiAoe)
17:32:08 <Ankhers> is HsQML still maintained? I found it on Hackage. Last update was January.
17:33:36 <hiptobecubic> Oh I hope so :(
17:36:14 <M-davidar> hiptobecubic: I've considered trying to use something like elm (or even ghcjs) with qml instead, no idea how well it would work though :/
17:37:31 <hiptobecubic> that sounds like a lot of trouble
17:37:59 <hiptobecubic> Doing what Wagon is doing with Electron seems like a reasonable way forward to me
17:38:27 <Ankhers> Is hub.darcs.net still a thing? Or is it just down at the moment?
17:38:42 <Rc43> Hello
17:39:13 <Rc43> Is "rank" from "RankNTypes" the same as "universe level" from "Universe Polymorphism"?
17:41:04 <Cale> Rc43: no
17:41:49 <Cale> Rc43: all the types which get added by rank-n types are still in the same universe.
17:42:00 <M-davidar> hiptobecubic: how is that better than hsqml though?
17:42:28 <Rc43> Cale, thanks
17:43:17 <hiptobecubic> M-davidar, because rather than a strange half-javascript environment with shared memory and whatever else, you can just treat it like a typical client-server web app and use the standard web development tools
17:44:27 <hiptobecubic> Don't get me wrong. If you need particular Qt functionality, then you don't have a choice, but if you're just looking for a way to build a GUI desktop application then it could work.
17:44:43 <M-davidar> yeah... but then you're still using electron :p
17:45:03 <hiptobecubic> Well sure, you have to use *something* :)
17:46:29 <M-davidar> hiptobecubic: a QML edsl for haskell, that compiled appropriate bits to JS and smooth interop between the two, would be really cool
17:46:55 <hiptobecubic> I think someone did try, but I don't remember the name of the library now
17:47:21 <M-davidar> hiptobecubic: ooh, link me if you remember :)
17:47:33 <Matt____> Does anyone know where user preference/profile settings are stored for WinGHCi on windows 10? I attempted to change the prompt to the lenny face, but didn't know it'd freakout over the special characters, and now the WinGHCi crashes and I cant open it
17:47:44 <hiptobecubic> It was doing something to try to flip the callback paradigm back around
17:48:00 <hiptobecubic> Matt____, :DDD
17:48:36 <Matt____> I even tried uninstalling and re installing, but I think the settings were stored elsewhere cause I can't open it still
17:50:39 <Matt____> just found a stackoverflow from same issue, ill give the fix a try, thanks
17:51:02 <pavonia> Matt____: I recall I had a similar problem once on an old Windows system. The settings are stored somewhere in the Registry, IIRC
17:51:18 <Matt____> yup, thats what the stackoverflow said, thanks pavonia
17:52:28 <hiptobecubic> Matt____, https://www.reddit.com/r/haskell/comments/3ssudt/adopt_a_library_hsqmltransient/
17:52:34 <hiptobecubic> Matt____, errr.. sorry wrong nick
17:52:37 <hiptobecubic> M-davidar, https://www.reddit.com/r/haskell/comments/3ssudt/adopt_a_library_hsqmltransient/
17:55:06 <M-davidar> hiptobecubic: thanks, will have a look later :)
18:01:22 <Ankhers> What is the suggested library for sockets? Network.Socket from the network package?
18:02:45 <verement> it has worked for me
18:07:17 <Ankhers> Alright, I thought for some reason people suggested something else
18:34:10 <coventry`> What are some ways to clean up the expression (do cabalExecutable <- (fmap fromJust (findExecutable "cabal")) ; (readProcess cabalExecutable [ "--version" ] ""))
18:36:06 <pavonia> Use (>>=)?
18:36:38 <pavonia> And you probably want to handle the case when findExecutable return Nothing
18:39:24 <Ankhers> I have an address "foo.com", how can I create a socket to that address? The `connect' function seems to require a HostAddress, but I can't seem to find how to create one from a domain name.
18:39:59 <glguy> You'll need to use getAddrInfo to resolve the domain name , first.
18:40:50 <glguy> If you're just making tcp connetions (and wouldn't mind having easy support for TLS and SOCKS proxies) you can also use: http://hackage.haskell.org/package/connection-0.2.5
18:41:37 <glguy> It'll be easier than using raw sockets and resolving names yourself
18:43:30 <Ankhers> glguy: Thanks. I'll take a look at that.
18:45:56 <coventry`> pavonia, can you give me an example of using >>= here?
18:47:53 <pavonia> coventry`: do { x <- f; g x } is the same as f >>= g
18:52:40 <coventry`> Ah, right.
18:59:28 <nh4clo4_away> What is an Integral type? I'm seeing it in the Haskell for the Evil Genius run-through but I don't know what it's for
19:01:22 <idem-pyon-tent> nh4clo4: It's a type class for integer types (Integer, Int, Word, etc.), excluding other numeric types (Float, Double, etc.).
19:01:25 <roconnor_> Integral numbers, supporting integer division.
19:01:26 <glguy> nh4clo4: Integral is a typeclass. You can read about the operations in that typeclass here http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#t:Integral
19:02:22 <roconnor_> e.g. not gaussian integers
19:04:00 <nh4clo4> so an Integral is like any other language's int and implements integer division, whereas double don't? What happens when you mix an Integral with a Float?
19:04:24 <roconnor_> nh4clo4: type error
19:08:14 <nh4clo4> That would make sense
19:08:25 <nh4clo4> thanks!
19:08:40 <roconnor_> you can convert an Integral to a float using fromIntegral
19:09:51 <nh4clo4> Is there a similar function for the other way around or is it one-way?
19:10:25 <roconnor_> well, you have to use floor, or something like that.
19:11:37 <roconnor_> fromIntegral and floor together form a Galois Connection, if you like mathy things.
19:20:05 <Xeironis_> When a function is called, do the arguments have to be copied in memory?
19:23:50 <wolfofhaskstreet> I managed to install (on a fresh install), using tarballs, both GHC 7.10.2, cabal-install 1.22.6.0 and stack 0.1.6.0 and got an hello work running in ghci and building as well
19:24:35 <wolfofhaskstreet> now I'd like to get company-mode working with haskell and ghci-ng and I'm lost...  For example how should I install ghci-ng? Using cabal or stack?
19:24:43 <nitrix> Hi, is there a library that offers a distributed message queue?
19:24:59 <nitrix> Ideally it'd handle peer discovery and everything on its own.
19:25:37 <peddie> Xeironis_: I don't think so . . . why would they?  especially if the data is immutable?
19:26:06 <Xeironis_> peddie: that's what I thought as well, just wanted to ask to make sure I don't waste a ton of resources
19:26:07 <peddie> nitrix: there are AMQP bindings; there are also ZMQ and nanomsg bindings, but for those you'll definitely have to do peer discovery etc. yourself
19:26:24 <peddie> Xeironis_: I would just write the program and then profile it later if it's too slow or allocates too much
19:26:33 <Xeironis_> yeah that makes sense
19:26:34 <nitrix> peddie: I was hoping for something embedded.
19:27:00 <peddie> what do you mean by "embedded" in this context?  when I hear "embedded," I think "on a microcontroller, with no heap"
19:27:41 <nitrix> Whithin the application; not as an external service.
19:28:29 <peddie> if you're running in a single process, you could use the ZMQ or nanomsg "inproc" transport, and it'd probably be quite easy to do service discovery yourself
19:28:30 <nitrix> So no backend database/server, all within the clients, as in peer-to-peer.
19:28:41 <nitrix> I don't want to use ZMQ.
19:28:41 <peddie> oh, I see
19:28:52 <peddie> I don't know much more about this kind of thing
19:29:02 <peddie> maybe someone else has a better idea about what would suit your need
19:29:12 <peddie> sorry
19:32:12 <peddie> nitrix: although I am curious to hear more details
19:32:39 <nitrix> Well, if it doesn't exists, I'll have to write it myself. I'm afraid there isn't any details yet.
19:33:21 <peddie> ok
20:36:23 * hackagebot git-fmt 0.3.0.0 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.3.0.0 (hjwylde)
20:37:30 <BLACK_POWER> IF YOU BLACK ND YOU WANNA TALK ABOUT RILL PROBLEMS TYPE /join #NIGGERSONLY
20:37:46 <cite-reader> @where ops
20:37:46 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
20:38:05 --- mode: ChanServ set +o geekosaur
20:38:10 --- mode: ChanServ set +o dibblego
20:38:11 --- mode: geekosaur set +b *!*u931732@172.56.30.*
20:38:11 --- kick: BLACK_POWER was kicked by geekosaur (BLACK_POWER)
20:38:18 --- mode: dibblego set -o dibblego
20:38:21 --- mode: geekosaur set -o geekosaur
20:46:36 <coventry`> What is the right way to say ((readProcess "/opt/cabal/1.22/bin/cabal" [ "--numeric-version" ] "") >>= liftM (readP_to_S parseVersion))?  (liftM (readP_to_S parseVersion) (readProcess "/opt/cabal/1.22/bin/cabal" [ "--numeric-version" ] "") ) does what I want, but with the bind notation I'm getting "Expected type: String -> IO [(Version, String)] Actual type: IO Char -> IO [(Version, String)]" in the liftM expression.
20:49:22 <cite-reader> coventry`: I'm not sure what modules half those identifiers come from. Have a minimal reproduction you can lpaste?
20:51:11 <coventry`> cite-reader: http://lpaste.net/146034
20:57:25 <monochrom> more abstractly, you are looking at rewriting "liftM x y" into a bind version. that's going to be y >>= (return . x), not y >>= liftM x
20:59:51 <coventry`> Ah, I see.  Thanks.
21:03:24 <Pamelloes> Is there a way to make sure a Text has only a specific set of characters in it? i.e. onlyCharacters :: [Char] -> Text -> Bool
21:03:53 <lethjakman-l> Pamelloes: Sounds like a regex to me?
21:04:22 <geekosaur> or parsec
21:04:55 <cite-reader> T.all (`elem` yourCharacters)
21:05:24 <geekosaur> or that, which I had just dug out
21:05:48 <Pamelloes> Oh, perfect :)
21:09:20 <Pamelloes> Is there a better way to write ['a'..'z'] <> ['A'..'Z'] <> ['0'..'9']?
21:10:16 <Pamelloes> By better I mean, can I write it with one pair of brackets without resorting to a mess of list comprehensions.
21:10:43 <monochrom> no. also, these are not list comprehensions
21:10:52 <cite-reader> If you're building a predicate, import Data.Char; let isInMyClass char = isAscii char && isAlphaNum char
21:11:13 <dmj> :t mconcat
21:11:15 <lambdabot> Monoid a => [a] -> a
21:11:43 <Pamelloes> monochrom: A list comprehension is something like [ x | x <- [0,1,2]], right?
21:11:49 <monochrom> yes
21:12:25 <Pamelloes> I said "without resorting to a mess of list comprehensions" ;)
21:12:42 <monochrom> there is no list comprehension anywhere
21:13:16 <Pamelloes> Right. But I could ostensibly use list comprehensions to express the same thing in one set of brackets. It would just be ugly. Maybe.
21:13:17 <monochrom> for God's sake you don't even have a |
21:13:25 <monochrom> ok I see
21:14:29 <athan> > fold [['a'..'z'], ['A'..'Z'], ['0'..'9']] --?
21:14:38 <lambdabot>  <hint>:1:46:
21:14:38 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
21:14:45 <athan> merp
21:24:57 <Geraldus> hi friends!
21:25:15 <dmj> Hi
21:26:19 <lamefun> can I do something like "myFunc ?(something 10) ?somethingElse" instead of "do { arg1 <- something 10; arg2 <- somethingElse; myFunc arg1 arg2 }"?
21:26:24 <Geraldus> Is there a way to write persistent filter to compare two record fields, e.g. `selectList [ CommentPublished ==. CommentAdded ]`
21:27:20 <pavonia> :t liftM2  -- lamefun
21:27:22 <dmj> lamefun: myFunc <$> something 10 <*> arg2
21:27:23 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:30:45 <dmj> lamefun: myFunc <$> something 10 <*> somethingElse ***
21:30:47 <lamefun> I thought I read about some kind of a hardcoded extension for that...
21:31:04 <dmj> lamefun: hard-coded extension?
21:31:18 <cite-reader> Is there an implementation of idiom brackets yet?
21:31:31 <cite-reader> (I think this is what lamefun is thinking about.)
21:32:24 <lamefun> so I can eg. (myFunc ?action normalValue) instead of (myFunc <$> action <*> return normalValue).
21:36:43 <logavanc> @pl \f g x y -> f (x ++ g x) (g y)
21:36:43 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
21:36:54 <logavanc> I... didn't believe it.
21:37:51 <coventry`> Thanks for your help, everyone!  https://github.com/elm-lang/elm-platform/pull/118
22:00:16 <jle`> logavanc: what were you expecting? :p
22:02:07 <logavanc> I don't know anymore... I've just beein trying to go through https://www.fpcomplete.com/school/starting-with-haskell/introduction-to-haskell and came across that. Wanted to see if it really worked.
22:02:50 <logavanc> jle`
22:08:11 <jle`> ah, okay :)
22:11:27 * hackagebot language-java 0.2.8 - Manipulating Java source: abstract syntax, lexer, parser, and pretty-printer  https://hackage.haskell.org/package/language-java-0.2.8 (VincentHanquez)
22:18:23 <CodeWar> I am a Haskell wannabe (know C++/D/Java and some tidbits of functional programming) But before I take the plunge, how good is the current set of compilers. Can I build large systems with Haskell (say Big Data processing / Graph processing / Systems(?))
22:18:57 <dmj> CodeWar: facebook seems to think so. 
22:19:02 <CodeWar> put in plain words can I compete with C++ in terms of performance or are the current compilers not there yet
22:19:22 <CodeWar> dmj: very nice
22:19:37 <dmj> CodeWar: this might be relevant for you, https://github.com/Gabriel439/post-rfc/blob/master/sotu.md, from Tekmo
22:22:25 <CodeWar_> ok the post above seems to suggest Haskell is Garbage Collected 
22:22:31 <CodeWar_> is that optional 
22:24:41 <dfrey> How do I define a function like this:  isSmall :: (Ord a) => a -> Bool   isSmall x = x < 17.3
22:24:43 <coventry`> That article pitches STM as a huge win for Haskell.  Early on, that was  seen as a big win for Clojure, but people don't seme to use it much.  Is it really a big deal in Haskell?
22:25:18 <ibid> CodeWar_: no
22:25:23 <dfrey> Do I need to do something to mark the literal 17.3 as an Ord?
22:25:26 <pavonia> dfrey: Add a Num constraint for a
22:26:26 <CodeWar_> ibid: no to Working around the GC or no GC is not mandatory
22:26:27 * hackagebot git-fmt 0.3.0.1 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.3.0.1 (hjwylde)
22:27:00 <pavonia> dfrey: Wait, for floating point numbers you need Fractional, not Num
22:29:04 <dhalgren> CodeWar_: haskell started as a project to explore efficient compilation of lazy languages, and its not necessarily perfect. Performant code is certainly possible, often straightforward but not infrequently a little subtle and occasionally downright ugly. I think Java is a better comparison than C++ for where one can get, so within say ~x2 of C. Systems doesn't sound like a good fit, for its necessarily GCed
22:29:14 <dfrey> pavonia: Thanks
22:29:43 <dhalgren> on the backend it should be a strong choice. GHC is def a very mature compiler
22:30:35 <ibid> CodeWar_: I was answering the question you asked: "is that optional"
22:30:58 <CodeWar_> ibid: thats a wonderfully written article for one :-) Wish other languages/runtimes had similar documents
22:31:16 <ibid> CodeWar_: though i am sure there are deep magic hacks that can be deployed in select cases
22:31:43 <ibid> CodeWar_: note that if your GC experience comes from Java or similar languages, don't automatically assume that translates to Haskell
22:31:51 <CodeWar_> dhalgren: its ThanksGiving and some of them are drunk but I know folks who would jump up and down with anger at the "C++ within ~x2 of C" :-) C++ is supposed to be faster than C for large sized projects but then I digress
22:32:13 <CodeWar_> ibid: why is that (the GC part )
22:32:23 <MarcelineVQ> pavonia: Fractional's are still Num's :>
22:32:39 <ibid> CodeWar_: functional languages have a quite different allocation pattern than the usual languages, and the GC algorithms have been tuned to take that into account
22:32:51 <dhalgren> CodeWar_: hehe, but actually agreed; I was talking about Haskell and intentionally not commenting C++ :) I would expect C++ to be usually faster
22:32:52 <Cale> coventry`: People use STM quite often in Haskell. It's a really nice way to implement various concurrent data structures. Sometimes you might want to replace usage of STM with something a bit harder to reason about in order to get slightly better performance, but usually programmer time and being able to understand your code is worth more than that.
22:32:58 <ibid> CodeWar_: specifically, FP programs tend to assume allocation and GC are efficient
22:33:10 <M-davidar> CodeWar_: and yet not as fast as fortran... :p
22:33:34 <ibid> CodeWar_: and so, the algorithms have been heavily optimized
22:33:53 <pavonia> MarcelineVQ: But Num is not restrictive enought here
22:34:03 <Cale> Hey, there are some naive programs written using ByteString in Haskell which are faster than the corresponding naive programs written in C :)
22:34:06 <ibid> CodeWar_: though to be sure, GC never gives you that sort of precise control that manual alloc does (but it does eliminate a class of very nasty bugs)
22:34:37 <Cale> That doesn't happen all the time, but every once in a while you can get a nice win by using fancy techniques under the hood :)
22:34:39 <CodeWar_> ibid: I am all in favor of GC until I care about latency (microsecond level latency) 
22:35:03 <dhalgren> maybe if supercompiler research becomes practical getting to speedy code reliably could be what Hs can offer, now I think expecting "papercuts" is reasonable. And systems, hard-realtime simply a bad fit
22:35:14 <MarcelineVQ> pavonia: true dat
22:35:18 <ibid> CodeWar_: i would hesitate to use haskell for hard real time stuff myself. for soft real time, it probably is good enough
22:35:56 <ibid> CodeWar_: and you may be able to separate the hard RT stuff into its own program written in some other language, depending on your application
22:36:03 <CodeWar_> ibid: true
22:36:30 <ibid> CodeWar_: and then use haskell for the more complicated analysis that is allowed to occasoonally miss deadlines :)
22:38:14 <Cale> There's a software defined network controller called McNettle which is written in Haskell (and uses STM), and has the best performance of any such piece of software on machines with many cores.
22:38:35 <ibid> CodeWar_: but more problematic for RT stuff is laziness. it often is very unpredictable, and it may be difficult to control it precisely enough
22:39:16 <ibid> (though I haven't written that sort of stuff in Haskell in years, so I may be behind the state of the art)
22:39:18 <Cale> http://haskell.cs.yale.edu/wp-content/uploads/2012/11/mcnettle-talk-wg2.8.pdf
22:39:24 <dhalgren> though I guess now we're getting a strict-by-default option 
22:40:27 <Cale> If you're talking about lazy evaluation specifically, I don't think unpredictable is a good word to use. GHC's implementation of non-strict semantics, which is not exactly the same thing as lazy evaluation, on the other hand, is more unpredictable, though generally for the better.
22:41:34 <ibid> Cale: i was using "laziness" as the umbrella term for the call-by-need and nonstrictness things that separates haskell from most other languages.  i am aware of its technical definition and that it differs from what i was using :)
22:42:58 <Cale> If you're a pessimist, and just assume that GHC will always use lazy evaluation, in my experience, you are pretty much only ever pleasantly surprised.
22:43:35 <ibid> Cale: yes, but that's typically not good enough for RT
22:43:52 <Cale> Oh, sure
22:44:11 <Cale> if you're doing hard realtime stuff, you're better off using Haskell as a metalanguage to write machine code
22:44:22 <Cale> Or something lower level like that
22:45:08 <dhalgren> like those embedded dsls for various low-level/hardware stuff I saw in the recent community report?
22:45:19 <Cale> yeah
22:45:58 <ibid> CodeWar_: see what Cale wrote above?  that's a very good suggestion :)
22:46:48 <coventry`> Is there an easy way to determine what packages are already available given a baseline install of specific versions of ghc and cabal?
22:47:29 <Cale> Atom ( https://hackage.haskell.org/package/atom ) is a good example of that, it's a Haskell library which was used to write realtime microcontroller code for hybrid hydraulic vehicles (things like garbage trucks which you definitely do not want to control incorrectly)
22:47:38 <dhalgren> am I right in assuming numeric-heavy code isn't the greatest fit either? Like, that there's still a significant gap between what accelerate can do on the GPU, I presume in its llvm-cpu backend too, and what one would do with cuda? and the simd branch hasn't landed yet?
22:47:47 <MarcelineVQ> coventry`: is `ghc-pkg list` enough?
22:47:49 <dhalgren> yy, that's one of those
22:48:17 <Cale> There's nothing *in principle* about Haskell which I think would prevent it from being a good fit for numerical analysis code
22:48:35 <dhalgren> sure; I meant, in the current ecosystem
22:48:44 <Cale> However, that tends to be an area where libraries help a lot, and there's only been so much of that sort of code which has been written.
22:48:49 <MarcelineVQ> coventry`: ghc-pkg list --package-db=FILE/DIR specifically, if you have different installs to check
22:48:53 <Cale> There are some really good statistical analysis libraries
22:49:06 <Cale> But lots of stuff is still needed
22:49:12 <coventry`> MarcelineVQ: Yes, that sounds like what I need.  Thanks.
22:49:45 <coventry`> Is there a website like packages.ubuntu.org which will show the packages for a  given version, though?
22:50:26 <Cale> There are a bunch of different linear algebra libraries, but they focus on different aspects, and there's nothing which I could point at and say "just use this"
22:51:30 <Cale> But have a look around on hackage, you might find some packages relevant to what you want to do
22:51:58 <MarcelineVQ> coventry`: http://hackage.haskell.org/package/base-4.8.1.0 and clicking the version you're after might be enough, I'm not sure if anything is installed passed `base` on a standard install
22:51:58 <dhalgren> and there's nothing that can really compete in machine learning, w say torch, tensorflow etc. even though the model of say tensorflow sounds like just dataflow programming ; ie what haskell uses for its parallelism, and easily expressible in cloud haskell etc. fits perfectly, just not done
22:52:00 <Cale> There's so much stuff on there that I long ago stopped being able to keep track of it all
22:52:28 <MarcelineVQ> As to what version of base means what GHC you might need to google that
22:52:38 <Cale> Yeah, Cloud Haskell looks really cool, I haven't had any reason to put it to use, but at some point I'd love to find an excuse :)
22:54:46 <dhalgren> there are other areas, closer to the core of the language - like I stumbled on the stream-fusion pkg the other day; apparently plain old lists could go faster (and fuse zips) if something like that were done, but w/o a more expressive RULES, they can't rewrite concatMap to something performant (they did in HAMLET for benchmarks). sounds fascinating but clearly WIP
22:55:18 <Cale> Well, stream-fusion already gets used for ByteString and Text
22:55:27 <Cale> and there is a kind of fusion which is in use for lists too
22:55:41 <Cale> It's just that stream fusion wasn't a clear winner over what lists already had
22:56:15 <dhalgren> y, it works fine w vectors, but for lists concatMap is inefficient, that kills it. However, they show that it can be made into a pure win, just not within the existing RULES language
22:57:28 <dhalgren> i'll link,sec
22:57:44 <Cale> I remember that paper, but sure :)
22:58:19 <dhalgren> http://ittc.ku.edu/~afarmer/concatmap-pepm14.pdf
22:58:19 <dhalgren>  
22:58:40 <dhalgren> ah, sry
22:59:49 <Cale> It would be nice. It's already often a better idea to think of lists and list operations as being essentially loops which haven't happened yet, whether that fusion is there or not. The fusion cuts down on the amount of allocation required, which is nice, but in any case, GHC is pretty amazingly good at picking up short-lived garbage, so while it does affect time performance, in practical situations, the distinction is 
22:59:49 <Cale> often between fast enough and a bit faster. :)
22:59:54 <dhalgren> anyhow, bunch of small wins seem still open, so I'm rather exited about the future
23:00:23 <Cale> But yeah, that's discounting a bunch of things for which maybe we would presently avoid using lists
23:00:36 <Cale> at the high performance end of the spectrum
23:21:29 * hackagebot git-fmt 0.3.0.2 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.3.0.2 (hjwylde)
23:26:10 <defanor> i'd like to see whether there are unhandled exceptions (those from Control.Exception, `throw#`) in a program, preferably from emacs. and it would also be nice to see totality/coverage; is there any relatively quick/simple way to get that? e.g., some code analysis tool, or at least a way to get a call graph easily
23:26:12 <quantumtremor> How would I partially instantiate a type with not-the-first parameter? For example, if I wanted to make type intValMap = Map k Int?
23:28:19 <Cale> quantumtremor: You generally don't. You could define a newtype
23:29:12 <Cale> There are issues with type inference even for that restricted notion of type lambda though, iirc.
23:31:24 <quantumtremor> Cale: Interesting. How would I define a new type in that case?
23:31:29 <quantumtremor> without rewriting Map?
23:38:52 <submain> is unsafeCoerce the recommended way to do Int -> Double?
23:39:59 <solrize_> lol
23:41:34 <tzh> submain: you want `fromIntegral`, probably
23:41:51 <submain> gotcha, thanks!
