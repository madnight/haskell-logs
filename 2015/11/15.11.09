00:07:36 * hackagebot JuicyPixels-scale-dct 0.1.0.0 - Scale JuicyPixels images with DCT  https://hackage.haskell.org/package/JuicyPixels-scale-dct-0.1.0.0 (phadej)
00:07:36 * hackagebot hScraper 0.1.0.0 - A Haskell library to scrape and crawl web-pages  https://hackage.haskell.org/package/hScraper-0.1.0.0 (nishant)
00:27:39 <vkt> Could someone help me define a comprehension that deletes leading 0s from a list of 0s and 1s?
00:27:52 <vkt> im a little lost
00:28:00 <opqdonut> you can't really do that with a list comprehension
00:28:11 <opqdonut> since the comprehension does the same thing for every element
00:28:15 <vkt> i had that feeling
00:28:36 <vkt> any idea for an alternative method?
00:28:39 <opqdonut> > dropWhile (==0) [0,0,1,0,1,1,1]
00:28:41 <lambdabot>  [1,0,1,1,1]
00:28:44 <opqdonut> > dropWhile (==0) [1,0,0,1,0,1,1,1]
00:28:45 <lambdabot>  [1,0,0,1,0,1,1,1]
00:28:51 <opqdonut> dropWhile is exactly what you want :)
00:28:57 <vkt> hehe thx ! =)
00:56:29 <varaindemian> Can someone tell me how can I mak this piece of code work?
00:56:30 <varaindemian> doubleTuple (a,b)  = case a of a `mod` 2 == 0 -> (a,2*b) (a,_) -> (a,_)
00:57:14 <roelof> what is a good way to make a custom data-structure. Im now doing things like this data Structure Circle Float Float (Float, Float)  but I think when I look later I never know what the floats represent 
00:57:54 <chattered> You can use a record. It's exactly the same, but you get syntax sugar for named fields.
00:57:55 <pavonia> varaindemian: Why no use guards instaed of case?
00:58:25 <varaindemian> how?
00:59:09 <pavonia> doubleTuple (a, b) | ... = ... | otherwise = ...
00:59:46 <liste> @let data ExampleRecord = MkExampleRecord { foobar :: String, foobaz :: Int } -- roelof
00:59:48 <lambdabot>  Defined.
01:01:41 <roelof> liste: thanks, Does the second always has to be a name of mk  ??
01:02:06 <liste> roelof no, it can be anything
01:02:26 <varaindemian> pavonia: tried it and it looks like the compiler is complaining about this a `mod` 2 == 0 = (a,2*b)
01:02:41 <varaindemian> parse error on input ‘|’
01:03:05 <roelof> oke, so also data Examplerecord = ExampleRecord { ...... } is good In Haskell
01:03:09 <varaindemian> actually it looks like this | a `mod` 2 = 0 = (a,2*b)_
01:03:38 <ely-se> Can I use 32-bit Cabal with 64-bit GHC on Linux?
01:03:45 <pavonia> varaindemian: Paste your complete function code please at lpaste.net
01:03:51 <ely-se> Or should I expect problems?
01:04:18 <ely-se> I don't want to build it from source but Debian doesn't have the latest version.
01:04:48 <varaindemian> pavonia: http://lpaste.net/144920
01:05:25 <pavonia> varaindemian: That looks correct. What is the error?
01:05:33 <MarcelineVQ> the = on line 1
01:05:45 <varaindemian> pavonia: baby.hs:116:3: parse error on input ‘|’
01:05:46 <varaindemian> Compilation failed.
01:05:54 <keko-2> no = before |
01:05:56 <pavonia> Oh right, good catch
01:06:35 <varaindemian> hmm?
01:07:35 <MarcelineVQ> oops, it was set to emacs channel? <_< http://lpaste.net/144920#a144921
01:08:21 <varaindemian> MarcelineVQ: thank you
01:10:38 <roelof> liste:  Can this also be converted to  the way you did : http://lpaste.net/144922
01:11:15 <liste> roelof it can, but it produces partial functions which can be dangerous
01:11:26 <arbelos> <no side effects> implies <referential transparency> but <ref. transparency> does not imply <no side effects>? Is that correct, or? 
01:11:32 <liste> unless you define new types for Circle and Rectangle
01:12:44 <roelof> oke, so one data for shape , one for circle and one for rectangle you mean ? 
01:13:05 <phadej> arbelos: it depends on what's your definition of "no side effects".
01:13:18 <lpaste_> liste annotated “No title” with “No title (annotation)” at http://lpaste.net/144922#a144923
01:13:31 <liste> roelof check that out
01:14:10 <arbelos> phadej: yeah I guess I didn't reach that far.. hmm :)
01:15:04 <arbelos> a function is allowed to interact with .. what's outside the "black box"
01:15:39 <phadej> arbelos: e.g. does Haskell has side-effects or not?
01:16:33 <phadej> someone might say it does, other may say that it doesn't (you only build IO actions, and pass them to black-box rts for execution)
01:17:48 <roelof> liste:  that was also what Im thinking about , thanks 
01:20:04 <arbelos> phadej: but if we say that side effects are present in the IO monad.. then IO actions allow side effects, but they are still referentially transparent, or??
01:20:42 <arbelos> as opposed to "pure" functions, that are both side-effect free and ref. transparent?
01:22:28 <phadej> arbelos: IO monad is no different than any other "pure" monad. we just don't have `runIO :: IO a -> a` (we do, unsafePerformIO - but let's pretend we don't :)
01:23:19 <phadej> i.e. we cannot escape IO, thus `main` is IO action
01:24:23 <tdammers> "side effects are present in IO" is not a very enlightening way of putting it
01:24:33 <tdammers> "IO represents effects" is a better way
01:25:26 <arbelos> right
01:25:45 <tdammers> so `putStr "Hello"` is not "print the string 'Hello' on stdout", it is "the action that, when run, prints the string 'Hello' on stdout"
01:25:55 <tdammers> we're just declaring it, not running it
01:26:03 <arbelos> that's an important point
01:26:21 <tdammers> and then at some point, we bind an action of type IO () to Main.main
01:26:37 <tdammers> which is the cue for the runtime to evaluate and execute it
01:31:54 <arbelos> so talking about side-effect free only makes sense in languages that take that approach.. 
01:32:18 <arbelos> I mean like F# etc.
01:33:42 <tdammers> there's the "Haskell is useless" thing that explains things a bit
01:33:49 <arbelos> the video?
01:34:02 <tdammers> yeah
01:34:14 <arbelos> i remember watching it a long time ago.. I'll have a look again
01:34:30 <tdammers> when you say "side effect", you imply two things: one, that there are *effects*, and two, that they are "on the side"
01:35:10 <arbelos> outside? the box I thought
01:35:11 <tdammers> you obviously need effects at some point in order to do anything useful
01:35:37 <tdammers> "on the side" in the sense of "a side channel next to the normal way data flows through functions (arguments and return values)"
01:42:31 <merijn> a side effect is an effect that happens *despite* not being visible in, e.g. the type system
01:42:36 <arbelos> but so no side effects ==> ref. transparency seems to make sense.. because if the function can't interact in any way with anything except its arguments, then how can it not be ref. transparent
01:43:49 <tdammers> arbelos: functions that do interact with things outside of their arguments and return values can still be referentially transparent
01:44:04 <tdammers> "referentially transparent" is a weaker guarantee than "no effects"
01:44:37 <tdammers> a common example would be a function that caches the results of expensive calculations
01:45:51 <tdammers> (but then, you could argue that if the cache can be modified from outside that function in any way, it is no longer referentially transparent
01:47:26 <arbelos> so isn't that to say.. A => B but B does not imply A .. where A is <no side effects> and B is <ref. transparency>
01:47:37 <arbelos> or wait.. ;/
01:48:08 <tdammers> yes
01:48:26 <tdammers> "no effects" => "referentially transparent", but not the other way around
01:48:40 <arbelos> ok, that was my initial question :) 
01:48:57 <arbelos> and purity is A & B
01:49:29 <tdammers> purity == no side effects
01:49:51 <tdammers> (or even, no effects)
01:50:52 <tdammers> referential transparency follows from that
01:52:44 <arbelos> ok
02:06:34 <arbelos> yes it follows from no side effects, that's what we just said... hehe i was confused, sorry 
02:07:09 <arbelos> or "no effects", as you phrased it
02:08:38 <tdammers> when you have effects, but not side effects, then you can reason about *part* of the code in pure terms
02:09:05 <tdammers> e.g., in Haskell, effects happen in the realm of the runtime, but the Haskell language is pure
02:09:06 <arbelos> ok now it is getting advanced.. hmm
02:09:07 <bernalex> anyone with ghc-mod 5.4.0.0?
02:09:25 <tdammers> we can reason about evaluation (which is pure) and execution (which isn't) separately
02:09:52 <tdammers> main = putStr "Hello" -- is a top-level binding of a pure expression to a name
02:09:54 <MarcelineVQ> bernalex: I use 5.4.0.0
02:10:20 <merijn> You can reason about all of the code in haskell, it's perfectly ok to reason about IO, the only problem is that we lack a denotational semantics that's sensible for IO
02:10:22 <tdammers> we can *evaluate* the expression on the RHS without causing any effects
02:10:45 <bernalex> MarcelineVQ: can you confirm that http://lpaste.net/5849308878021328896 is broken for you too? i.e. that ghc-mod doesn't complain about how few patterns appendPerhaps matches.
02:10:54 <arbelos> tdammers: any resources to recommend for getting a better understanding of this stuff? except the video mentioned before.
02:11:38 <tdammers> arbelos: maybe just let it sink in? Other than that, the usual beginner resources all make attempts at explaining the matter - RWH, LYAH, and that tutorial from bitemyapp
02:11:39 <MarcelineVQ> bernalex: I do get a non-exhaustive pattern match warning on appendPerhaps
02:11:49 <bernalex> MarcelineVQ: really? how strange that I do not.
02:11:52 <bernalex> MarcelineVQ: which GHC?
02:12:04 <MarcelineVQ> 7.10.2
02:12:13 <bernalex> I'm on 7.10.2-r1. :(
02:12:19 <bernalex> MarcelineVQ: what command did you run?
02:13:05 <MarcelineVQ> My editor enviroment uses ghc-mod for me so I'm not sure
02:13:18 <bernalex> MarcelineVQ: can you try just running ghc-mod check [file], and see what that does?
02:13:23 <MarcelineVQ> sure
02:13:40 <MarcelineVQ> Still warns me
02:13:44 <arbelos> tdammers: ok, thanks
02:13:51 <MarcelineVQ> `Patterns not matched: _ (Have _)`
02:13:57 <bernalex> darn! I wonder what's broken here then. thanks for checking though!
02:14:26 <MarcelineVQ> np
02:17:57 <merijn> bernalex: Are you using -Wall?
02:18:04 <bernalex> merijn: wat
02:18:28 <bernalex> merijn: I am using ghc-mod check [file]. that should do the trick by itself. at least it has done so up until this point.
02:18:46 <bernalex> as it did in fact do for MarcelineVQ.
02:24:45 <merijn> bernalex: non-exhaustive patterns only show up with -Wall
02:25:05 <merijn> I use hdevtools but if I don't configure that to use -Wall it won't warn about non-exhaustive patterns either
02:25:18 <merijn> I'm assuming ghc-mod requires you to specify warning flags too
02:26:23 <bernalex> merijn: it haaas never required it before.
02:27:15 <merijn> bernalex: Do you usually use cabal? Doesn't ghc-mod grab warning flags from cabal files?
02:27:29 <bernalex> merijn: it's broken in cabal projects too.
02:28:15 <merijn> hmmm, then I dunno
02:57:03 <merijn> I have a naming issue, what to call the function ":: FooError -> IO String" that looks up the description of an error?
02:57:52 <quicksilver> getErrorName? getErrorString?
02:58:34 <merijn> quicksilver: Yeah, I had something like that, but it seemed so silly and general as a name :\
02:59:12 <quicksilver> optimiseOrthographicExceptionDescription
02:59:19 <merijn> :p
02:59:45 <quicksilver> naming things in isolation is hard; normally a desirable property is somet kind of consistency with the rest of the API
03:02:05 <tdammers> lookupErrorDescription
03:02:54 <tdammers> although, maybe just "describe" would also work, depending on namespace conventions
03:07:55 <bernalex> :t mconcat
03:07:56 <lambdabot> Monoid a => [a] -> a
03:08:16 <bernalex> why is mconcat using []?
03:09:29 <cocreature> not sure, but foldMap id should do the trick
03:10:04 <bernalex> cocreature: I mean from a correctness/design POV -- I don't have practical use for it right now.
03:10:22 <cocreature> yeah feels weird
03:10:23 <quicksilver> the FTP left various monomorphic functions untouched for historical reasons
03:10:30 <bernalex> the lack of semigroups is worrying, but I don't see why mconcat uses [] in post-FTP GHC.
03:10:32 <quicksilver> like 'map' and 'mconcat'
03:11:01 <shock_one> What are the historical reasons, exactly?
03:11:01 <bernalex> I understand the need to leave map untouched (although I disagree with doing it nonetheless), but mconcat?
03:11:17 <quicksilver> I suppose the short answer is "because Foldable / Traversable didn't contain a polymorphic mconcat"
03:11:30 <quicksilver> presumably because the authors felt that 'fold' is a better name
03:11:35 <tdammers> shock_one: Functor, Applicative and Monad were discovered after lists, and Monad was already a thing in Haskell before Functor and Applicative
03:11:39 <quicksilver> so fold remains the polymorphic choice
03:11:47 <quicksilver> :t fold
03:11:49 <lambdabot> (Foldable t, Monoid m) => t m -> m
03:12:40 <quicksilver> I think FTP (mostly?) restricted itself to replacing stuff in the prelude which already existed under taht exact name in Foldable or Traversable
03:12:45 <quicksilver> :t concatMap
03:12:47 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
03:12:48 <shock_one> tdammers: I'm not sure I understand how is that connected with the fact that map is monomorphic.
03:13:02 <bernalex> Monoid is just one big wart IMO.
03:13:04 <tdammers> shock_one: map was in Haskell long before fmap
03:13:32 <tdammers> shock_one: originally, the idea was that "mapping" is something that involves a list and a function
03:13:36 * quicksilver doesn't think Monoid is a wart.
03:13:42 <bernalex> it's horrible
03:13:47 <bernalex> <> should be in SemiGroup
03:13:54 <bernalex> mappend is maybe the worst name in all of Prelude
03:14:03 <bernalex> mconcat is []
03:14:08 <bernalex> mconcat should probably not even be there in the first place
03:14:14 <bernalex> there's probably more.
03:14:26 <shock_one> tdammers: why was it monomorphic? Was it added before parametric polimorphism? Or why is that important to have Functors and stuff to have a polymorphic map?
03:14:29 <quicksilver> oh that's probably why mconcat didn't change, it's a method isn't it?
03:14:39 <bernalex> quicksilver: yeah
03:15:00 <quicksilver> one can imagine monoids where there is a more direct and efficient n-ary append
03:15:43 <quicksilver> such an n-ary combination _probably_ has to be written over [] and not over a general Foldable, since you want to inspect the [] deeply to choose the optimum execution.
03:15:58 <quicksilver> writing it over Foldable by using toList is probably a false generalisation
03:19:32 <quicksilver> https://mail.haskell.org/pipermail/libraries/2015-August/026086.html
03:19:48 <quicksilver> ^^ it was discussed; unfortunately the thread continues into september which is a pain with pipermail
03:40:04 <merijn> shock_one: No, it was explicitly chosen to be monomorphic to make the language simpler for beginners
03:40:39 <merijn> shock_one: Because some of the type errors involving typeclasses can be rather...confusing
03:41:11 <merijn> tdammers: I doubt map was in haskell long before fmap
03:41:25 <shock_one> merijn: Thank you. One more question, if you don't mind: why wasn't its signature changed as a part of FTP?
03:41:57 <merijn> The first typeclass paper dates from 1989
03:42:04 <quicksilver> as I said above, as far as I recall, the brief of FTP was only to bring in the functions from the existing Foldable and Traversable modules
03:42:21 <merijn> So typeclasses predate the first Haskell Report
03:42:21 <quicksilver> so, whether or not functions got 'replaced' depends if they were in those modules already
03:42:36 <merijn> I'm pretty sure Functor has been around since nearly the beginning
03:42:38 <quicksilver> merijn: to be fair 'haskell' predates the first haskell report by quite a long time
03:43:12 <quicksilver> 1.0 ... 1.4 all preceeded haskell 98
03:43:16 <phadej> IIRC some comment somewhere that map was renamed to fmap
03:43:20 <merijn> quicksilver: The first report is from 1990, the haskell committee was from 1987
03:43:25 <phadej> i.e. Functor had `map`
03:43:35 <phadej> but it might be some dream.
03:43:40 <merijn> quicksilver: There were Haskell reports before Haskell Report 98
03:44:04 <quicksilver> exactly
03:44:14 <quicksilver> oh I see what you mean :)
03:44:15 <shock_one> quicksilver: I'm afraid it raises a new question: why such a decision was made, to bring only functions that exist in Foldable and Traversable?
03:44:32 <quicksilver> shock_one: it's not so much a decision being made as a proposal being made
03:44:35 <merijn> shock_one: Because the people arguing changing map to fmap would make things "to confusing" were very adamant, and no one cared enough about the extra letter to fix it
03:44:48 <quicksilver> shock_one: the only "decision" was - adopt this proposal or don't adopt it
03:44:51 <phadej> eg. http://www.cs.tufts.edu/comp/150GIT/archive/mark-jones/fpca93.pdf
03:45:07 <phadej> found by http://stackoverflow.com/questions/16880577/whats-the-history-behind-the-functor-type-class
03:45:10 <quicksilver> although of course there were reasons for the proposl to take the form it did
03:45:30 <quicksilver> "map" has considerable history; it exists in ML and Miranda too
03:45:34 <merijn> The real solution to these historical questions is to ask Lennart whenever he gets on here next time :)
03:45:44 <quicksilver> augustss has forsaken us :(
03:46:39 <shock_one> Is there a technical reason to keep map operating only on lists?
03:46:48 <merijn> shock_one: No
03:47:04 <bernalex> shock_one: not technical as such.
03:47:08 <merijn> shock_one: Well, depending on your definition of technical reason
03:47:14 <bernalex> merijn: my thoughts exactly :p
03:47:20 <quicksilver> there probably are some 'minor' technical reasons to do with rewrite systems
03:47:43 <quicksilver> which seem like htey should be resolvable if someone took the time
03:47:54 <shock_one> Wouldn't GHC infer the new type correctly?
03:47:59 <merijn> shock_one: The main reason is "Why potentially break what isn't broken"
03:48:39 <merijn> fmap is one letter more, no one can be arsed to investigate if it COULD break anything and if so what it would break, etc. for that one single letter
03:49:02 <merijn> shock_one: If it makes you happy you can "import Prelude hiding (map); map = fmap" and done :)
03:49:06 <shock_one> merijn: in order to be consistent. If you decided monomorphism in Prelude is a bad thing, please follow your decisions.
03:49:25 <quicksilver> ah, but no one did decide monomorphism in the Prelude is a bad thing
03:49:25 <merijn> shock_one: The problem wasn't monomorphism being bad
03:49:39 <bernalex> there's the pædagogical trade offs with (f)map
03:49:54 <merijn> shock_one: The problem was: "Having to constantly import Foldable/Traversable as qualified to avoid naming collisions was annoying"
03:49:58 <bernalex> 1. "why is it not polymorphic? this is confusing to me!", 2. "what is a Functor? this error message is confusing to me!"
03:50:18 <saulzar_> and, 95% of the time I'd find  <$> more readable compared to fmap anyway!
03:50:48 <merijn> shock_one: The solution to "I hate having to import Foldable/Traversable qualified and writing T.traverse" is "export from Prelude replacing the functions where names clash"
03:51:11 <merijn> shock_one: Making the prelude more polymorphic is just a side-effect of the solution to the real problem
03:51:26 <shock_one> merijn: got it, thank you.
03:52:22 <quicksilver> looks like higher-kinded typeclasses didn't come in until haskell 1.3
03:52:34 <quicksilver> not sure if Functor made it into 1.3
03:53:22 <quicksilver> yes
03:53:29 <quicksilver> so haskell had been around about 6 years before fmap :)
03:53:45 <quicksilver> although Gofer probably had a fmap before haskell did
04:12:04 <itssa> is it difficult to create an image from haskell code? this year our school is running a competition for who can create the best fractal pattern from haskell
04:12:06 <Xandaros> saulzar_: I almost always use <$> instead of fmap. Pretty much the only time I don't is when I use fmap partially applied
04:12:22 <merijn> itssa: Depends on the kinda of image, I guess?
04:12:43 <merijn> itssa: Stuff like diagrams should be easy, but I dunno how well you could draw a fractal using diagrams :p
04:13:13 <itssa> merijn: I know the code that I'd need to use to produce something but i'm not sure how to output it as an image
04:13:51 <merijn> Try browsing the graphics section on hackage?
04:14:02 <Taneb> merijn, I created an L-system renderer a while back using Diagrams
04:14:03 <itssa> yeah ill check thx
04:14:08 <Taneb> Did the dragon curve
04:14:10 <quicksilver> if you want to work at the pixel level
04:14:23 <quicksilver> the juicy pixels will write it to a file for you
04:14:37 <itssa> what's that? sorry
04:14:41 <quicksilver> it's a library
04:14:45 <quicksilver> http://hackage.haskell.org/package/JuicyPixels
04:14:47 <itssa> oh Ive found it, yeah thanks
04:14:49 <Taneb> merijn, I made this using diagrams: http://40.media.tumblr.com/f436429c2aecad3f71610c71bad5d670/tumblr_mrvg5bHdXg1rysy5go1_1280.png
04:14:50 <itssa> illcheck it out
04:15:06 <itssa> Taneb: how long'd it take?
04:15:28 <Taneb> To write or to run?
04:15:38 <itssa> write
04:15:52 <Taneb> Can't actually remember, I did this a few years ago
04:15:56 <itssa> oh
04:15:57 <Taneb> Not too long, it's a quite short program
04:16:19 <itssa> im just wondering whether it's in my current knowledge span
04:16:47 <Taneb> Do you know how L-systems can be used to generate fractals?
04:16:48 <merijn> itssa: Pffft, always attempt to do things you don't think you're smart enough for. That's how you learn :p
04:16:54 <Taneb> If so, then yeah, it's within your reach
04:17:21 <itssa> nah but I'll read up
04:19:48 <itssa> you got any tips for making my design stand out?
04:19:49 <itssa> e.g to win?
04:21:52 <Xandaros> write it all in pointless
04:22:34 <Taneb> itssa, colours are good
04:23:09 <phadej> is there a package providing Hashable Vector instance
04:25:33 <quicksilver> seems not?
04:25:38 <quicksilver> easy enough to write via toList
04:26:03 <phadej> quicksilver: it is, so I'll make a package
04:27:02 <phadej> hashable though depends on text, it might depend on vector as well...
04:27:22 <itssa> I'll try use OpenGL
04:27:22 <kuribas> you can create that dragon fractal by folding paper.
04:27:26 <itssa> and see where it takes me
04:27:51 <quicksilver> if you've never used opengl before, it will take you down a twisty path of understanding the opengl API :)
04:27:58 <itssa> oh
04:28:08 <kuribas> fold the left side to the right, and repeat.  Then open the paper with right angles, and you have the dragon fractal!
04:28:29 <MarcelineVQ> idk why you'd want to use opengl to generate fractals, you just need to generate a 2d array of pixels
04:28:29 <rhz> the loch package isn't building on latest GHC
04:28:50 <itssa> MarcelineVQ: what do you suggest
04:29:00 <MarcelineVQ> A fragment shader could do it fast but learning opengl just for that seems like overkill
04:29:49 <itssa> ok well I gotta go to class but I'll no doubt be back once I've read some stuff on it
04:29:55 <MarcelineVQ> Any library at all for saving images in the format you want to finish in
04:29:58 <MarcelineVQ> bleh
04:31:21 <quicksilver> juicypixels suffices for that part, but it has no way to display it onscreen as you go
04:31:31 <MarcelineVQ> .tell itssa It's just a 2d array, so maybe something like JuicyPixels, you can generate a fractal as a 2d vector then save it
04:31:40 <MarcelineVQ> @tell itssa It's just a 2d array, so maybe something like JuicyPixels, you can generate a fractal as a 2d vector then save it
04:31:40 <lambdabot> Consider it noted.
04:31:45 <kuribas> diagrams + gtk?
04:36:01 <quicksilver> diagrams is not ideally suited to pixel-based drawing is it?
04:39:58 <kuribas> no, more to vector graphics.
04:42:39 <jophish> How does GHC optimize enumeration data types (i.e. data Foo = Foo | Bar | Baz)?
04:42:54 <jophish> The wiki page says it doesn't, but the page is pretty old
04:43:05 <merijn> jophish: How would you expect it to optimise that?
04:45:18 <jophish> merijn: something along the lines of unpacking in a similar way to single constructor types. Like this: https://wiki.haskell.org/Performance/Data_types
04:45:55 <merijn> That makes no sense
04:46:09 <merijn> Unpacking only makes sense if your constructors have arguments
04:46:14 <merijn> Else, what would you unpack?
04:46:44 <jophish> merijn: what is the workaround doing at the bottom of that page?
04:47:49 <Xandaros> It's using an int instead of an enum, with you defining constants instead of constructors
04:47:53 <merijn> jophish: I don't understand what they're trying to accomplish. I would just explicitly unpack if that's what you want
04:48:45 <Xandaros> I'm not sure you gain anything from that, though. I'd imagine constructors are represented as ints regardless
04:49:51 <jophish> that's what I thought, but I got a little confused by that example
04:52:32 <Xandaros> Those are all microoptimisations, though. Do you really need those? If you can parrallelise anything, I'd go for that first
04:53:17 <jophish> Xandaros: oh, I'm not doing anything like that yet, just curious
04:54:30 <quicksilver> what is more important IMO than optimising the storage
04:54:34 <quicksilver> is optimising case statements
04:54:46 <quicksilver> since case statements are how you use enumerated data types.
04:55:01 <quicksilver> GHC does a fairly good job by inlining case statments and doing the case-of-case optimisation
04:55:08 <quicksilver> in many cases the data will be eliminated entirely.
05:01:00 <nshepperd> oh, representing the enum as an int lets you {-# UNPACK #-} it
05:02:20 <quicksilver> but you probably lose case-of-case optimisation
05:02:28 <quicksilver> I'm not sure about that.
05:02:51 <Xandaros> Any gains you get will be minute anyway
05:03:17 <quicksilver> hard to generalise about such things
05:03:24 <quicksilver> gains vary by workload. Profile your workload ;)
05:05:01 <Xandaros> I'm a big fan of parrallelising things if I want them to go faster. Getting a speedup of like 3.5 times on my quadcore machine is quite a lot :D (Of course, even more important is using efficient algorithms)
05:07:00 <Heather> hello, I need help with aeson / yaml on linux
05:07:10 <liste> Heather go ahead
05:08:01 <Heather> I'm using .:? for Maybe Bool
05:08:12 <Heather> so I've got also Null in yaml file
05:08:28 <Heather> but during parsing getting:  Error in $[0].enabled: failed to parse field enabled: expected Bool, encountered Null
05:08:34 <Heather> happens on linux only
05:08:56 <Heather> here is possible related source https://hackage.haskell.org/package/aeson-0.7.0.6/docs/src/Data-Aeson-Types-Instances.html
05:09:10 <Heather> well... version I use is 0.10 instead
05:09:26 <Heather> corrected link: https://hackage.haskell.org/package/aeson-0.10.0.0/docs/src/Data-Aeson-Types-Instances.html
05:10:31 <Heather> there is very strange code addKeyName = (("failed to parse field " <> unpack key <> ": ") <>)
05:14:23 <Hafydd> Heather: what do you find strange about that?
05:17:16 <tdammers> "happens on Linux only" sounds a bit strange to me
05:19:43 <quicksilver> odd to me too. line endings?
05:20:14 <tdammers> shouldn't affect JSON, but YAML maybe
05:20:51 <Heather> Hafydd I can't understand how does it work personally, don't see possible error place
05:21:12 <Heather> quicksilver "enabled" property is on line 7-8, not first, just first Maybe one
05:21:25 <Heather> so it shouldn't be line endings
05:21:41 <Heather> tdammers iiuc yaml is using aeson
05:22:07 <tdammers> yes, but line endings are syntax-relevant in YAML, but not in JSON
05:22:41 <tdammers> could also be a matter of locale settings
05:22:44 <Hafydd> Heather: do you know the syntax of infix operators and infix operator sections?
05:22:51 <Heather> tdammers I'm using yaml but as I said it complains not on first property but on first Maybe one
05:23:02 <Hafydd> Heather: and do you know what <> is?
05:23:46 <tdammers> Heather: I'm just poking a little here - Aeson and Attoparsec are pretty much pure Haskell, so there shouldn't be anything in there that produces differences between platforms
05:24:14 <tdammers> Heather: so it's promising to look in the general direction of I/O primitives
05:26:19 <Heather> I guess I will end in creating minimal reproducing behavior... can't see for now more ways to debug it
05:27:30 <Xandaros> Heather: I've used aesom to parse two fields of json before, one of which was optional. Worked perfectly fine
05:28:46 <Heather> Xandaros on linux?
05:29:03 <Xandaros> Yup. Wouldn't want to use anything else :P
05:29:11 <Heather> Xandaros aeson 0.10 ?
05:29:31 <Heather> Xandaros tryed with null value?
05:29:45 <Xandaros> Probably not 0.10, was a while ago. Don't have a version constraint on it
05:29:55 <Xandaros> Heather: https://github.com/Xandaros/GithubNotify
05:31:34 <Heather> Xandaros hm... TemplateHaskell with makeFields ''Config - is it just outdated way of Language DeriveGeneric?
05:32:23 <Xandaros> That's for lens. Don't know if there is another way to do that
05:33:28 <Heather> Xandaros https://hackage.haskell.org/package/aeson-0.8.1.0/docs/Data-Aeson.html - here LANGUAGE DeriveGeneric
05:33:52 <Heather> "Instead of manually writing your FromJSON instance, there are three options to do it automatically"
05:34:50 <Xandaros> Well, I wrote it manually. The makeFields is from lens, that's jsut for easier access to the datatype (probably a _slight_ bit overkill in this case)
05:34:51 <Heather> ah I see, it's not that case
05:39:20 <Heather> Xandaros I will try this project maybe tomorrow, in case if I will be able to reproduce it there I'll let you know :)
05:40:07 <Xandaros> Heather: Keep in mind that it has an external dependency - libnotify. You probably have it installed, but in case you don't - it won't compile :P
05:40:34 <Heather> Xandaros installed
05:46:48 <kqr> the turtle documentation says that "The command inherits stdout and stderr for the current process" – is there a way to set stdout to /dev/null when running a command, or otherwise ignore the output?
05:47:29 <kqr> I guess I could run procStrict and not use the output Text blog
05:50:38 <f-a> :t sum
05:51:56 <lambdabot> (Num a, Foldable t) => t a -> a
05:55:34 <keviv> Must be oing something wrong with the types
05:55:44 <keviv> Code: http://paste.pound-python.org/show/cAXFDTiTvdetJ0k1ROUz/
05:55:50 <keviv> Error: http://paste.pound-python.org/show/DyDXFq3w1YulIfgv5KAU/
05:56:53 <quicksilver> well digitToInt returns Ints
05:57:09 <keviv> Aren't Ints members of Integral though?
05:57:12 <quicksilver> yes
05:57:21 <quicksilver> but your sumSquares is going to return an Int
05:57:27 <quicksilver> not an arbitrary Integral
05:57:29 <f-a> yep
05:57:30 <merijn> keviv: Yes, but your code claims to work with ANY Integral, whereas digitToInt will only ever produce Int
05:57:41 <quicksilver> you can add a fromIntegral in there
05:57:43 <f-a> a fromIntegral could fix it I guess
05:57:52 <quicksilver> to convert 'up' from Int to any other Integral
05:58:31 <keviv> So functions can't be called with more specific types?
05:58:46 <f-a> your function claims to work with all Integrals
05:58:53 <keviv> right
05:58:53 <merijn> keviv: They can, but they can't RETURN more specific types
05:59:01 <f-a> but you wrote a bit of it to work with Ints only 
05:59:07 <merijn> keviv: You can't return an Int and claim to return any Integral
05:59:19 <f-a> hence mayhem
05:59:38 <keviv> But I'm never returning an Int
05:59:39 <Xandaros> Hmm, sumSquares doesn't have a type annotation, though. If you tell it that it returns an Int, would it work?
05:59:48 <keviv> I return Bools
05:59:49 <merijn> keviv: Because there's no way GHC can magically convert your Int into "any Integral" (well, there is, fromIntegral, but GHC shouldn't magically insert code)
06:00:07 <f-a>          f-a :t sum . map (^2) . map digitToInt . show
06:00:08 <f-a>    lambdabot Show a => a -> Int
06:00:12 <merijn> keviv: sumSquares returns an Int
06:00:18 <f-a> (I paste it because lambdabot seems lazy today)
06:01:04 <merijn> keviv: Line 11, "happyHelper start (sumSquares n)" <- start is any Integral, "sumSquares n" is Int
06:01:07 <keviv> f-a: right, so if it returns an int, which then gets passed into where happyHelper expects an Integral, what's the problem?
06:01:14 <merijn> keviv: And happyHelper does "n == start"
06:01:20 <keviv> oh
06:01:21 <MarcelineVQ> keviv, it expects them both to be the same type
06:01:22 <keviv> ah
06:01:31 <merijn> keviv: You can't compare Int with an arbitrary Integral :)
06:01:46 <keviv> ok that makes more sense
06:02:10 <merijn> keviv: The problem is that happyHelper expects two identical arguments of type 'a', so sumSquares passing in Int means that it's forcing the first to ALSO always be Int :)
06:02:29 <keviv> right
06:02:42 * hackagebot darcs 2.10.2 - a distributed, interactive, smart revision control system  https://hackage.haskell.org/package/darcs-2.10.2 (GuillaumeHoffmann)
06:02:58 <keviv> if happyHelper only takes one Integral, then applying an Int would be ok right?
06:03:28 <merijn> keviv: Note that unlike, say, a Java interface where "bool happyHelper(Integral a, Integral b)" could take two different Integral types (i.e. subclasses) "(Integral a) => a -> a -> Bool" requires both a's to be the same
06:04:01 <merijn> keviv: It's fine to pass in an Int, but then the OTHER argument also has to be Int, which your current type doesn't guarantee
06:04:10 <keviv> right yeah]
06:04:35 <merijn> keviv: Try replacing "happyHelper start" on line 11 with "happyHelper 1" then it should typecheck (because 1 can be Int and sumSquares n is also Int)
06:04:46 <merijn> (Of course that won't make sense in terms of what the code does)
06:05:09 <merijn> The real solution is to convert the Int from sumSquares into a more general value using fromIntegral
06:06:03 <keviv> I think it's  complaining that and Integral isn't a Show?
06:06:07 <keviv> I'll paste the tb
06:06:25 <keviv> http://paste.pound-python.org/show/Uree258htjKNCVSxKDHB/
06:06:26 <merijn> keviv: Oh, right, yeah. your use of show also requires a Show constraint on 'a'
06:06:42 <merijn> keviv: i.e. "happyHelper (Integral a, Show a) => a -> a -> Bool"
06:06:52 <keviv> ah
06:07:41 <keviv> Yea that did it
06:07:43 * hackagebot cacophony 0.3.0 - A library implementing the Noise protocol.  https://hackage.haskell.org/package/cacophony-0.3.0 (jgalt)
06:09:07 <keviv> oh lol
06:09:39 <keviv> I love when you don't take something into consideration and it produces just hilarious bugs
06:10:40 <keviv> I intended the n == start predicate to return False if ever it lands on the same number that it started with, indicating an infinite loop, but I also forgot that I'm always passing in the same number in twice
06:18:04 <keviv> Final code: http://paste.pound-python.org/show/TnEymM3BWgGZFckFXhXh/
06:18:10 <keviv> Any comments of areas to improve?
06:18:18 <orion> Hey, anyone know of a crypto library which implements the Goldilocks-448 curve?
06:20:07 <lamefun> Vector has no Hashable instance?
06:21:58 <kadoban> keviv: Is this for NICTA?
06:22:14 <keviv> kadoban: codewars
06:23:31 <stobix> <outcry type=frustration>argh! My head refuses to understands arrows!</outcry>
06:24:01 <Xandaros> stobix: I feel you^^
06:24:20 <merijn> stobix: Good news for you, they've fallen pretty much out of favour, so no one cares about them :p
06:24:27 <keviv> kadoban: although this nicta course looks pretty cool
06:24:31 <stobix> hughes makes it sound like it ought to be so simply understood
06:24:38 <stobix> merijn: hehe. :)
06:24:52 <kadoban> keviv: Ah. Well the most obvious place to improve is that you're essentially using a list to store what items you've seen before, but that's quite inefficient because for each new element you check, it has to rescan all of history.
06:24:59 <stobix> merijn: were they replaced, or simply "meh'd" away?
06:25:04 <Xandaros> I have used arrowised frp before. I had no idea what I was doing and I still don't
06:25:05 <MarcelineVQ> merijn: someone here told me they use bifunctors instead, is that the common thing to do now or is there another thing that has made arrows redundant?
06:25:24 <merijn> stobix: Basically Category + Applicative covers most use case better
06:25:47 <merijn> MarcelineVQ: Category + Applicative, although Profunctors are all the range too, nowadays
06:25:51 <stobix> ah. yeah, they ought to cover most of the arrow use cases anyway
06:26:17 <Xandaros> Heh, I have never used a profunctor, I think...
06:26:20 * stobix still wanna understand arrows, gdammit
06:26:24 <keviv> kadoban: Idk how else to check if a certain number is going to create an infinite loop
06:26:31 <kadoban> keviv: You can also use State, though it's not strictly necessary. isHappy is in the NICTA course in the State exercises, if you've been looking for a reason to do NICTA. It leads you through some things that end up being very useful for that.
06:26:38 <merijn> stobix: Did you read the arrow paper? it's pretty easy too read (the start at least)
06:26:43 <kadoban> keviv: Well, you do the same thing you're doing, just with a different data structure, like a Set.
06:26:49 <keviv> ahh
06:27:18 <kadoban> keviv: But if what you're currently doing is fast enough, I guess you don't actually have to bother. It kind of depends what size inputs are important.
06:27:25 <stobix> merijn: yeah. In the end, hughes is all "and then you simply used advanced magic and incredoulus incantations, and you end up with this nice example without any effort"
06:27:45 * hackagebot pipes-cacophony 0.1.1 - Pipes for Noise-secured network connections.  https://hackage.haskell.org/package/pipes-cacophony-0.1.1 (jgalt)
06:27:55 <stobix> merijn: I just started on http://staff.city.ac.uk/~ross/papers/notation.pdf to see if that makes things clearer for me
06:28:22 <kadoban> keviv: In terms of style, I'd probably have made happyHelper local to isHappy (put it in a where block), and then shorten the name. 'go' is what I usually use.
06:28:39 <stobix> merijn: the start I had no problem with. Other than that I always end up thinking &&& and ||| ought to be commutative
06:30:23 <stobix> merijn: the stream example from the paper was pure magic to me. I guess I need to have to get some more intutition for lazyness
06:31:06 <Xandaros> I can't wait to get a kindle to read all sorts of papers on the train. Don't really like reading on LCDs :/
06:31:31 <Xandaros> arrows sound very interesting, even if they may not be as important anymore
06:32:45 * hackagebot huckleberry 0.9.0.0 - haskell EDSL Huckleberry  https://hackage.haskell.org/package/huckleberry-0.9.0.0 (tkmsm)
06:33:01 <jg_> Xandaros: +1. You might want to check out the 'krop' tool. I've found it very useful for cropping the margins on the tech papers for easier reading
06:33:50 <Xandaros> jg_: Ah, thanks. Does it also change to single-column or do I still need another tool for that?
06:35:43 <bennofs> Xandaros: k2pdfopt is a very nice tool to make papers readable on ebook readers
06:36:01 <bennofs> Xandaros: it also handles double-column papers
06:36:25 <Xandaros> bennofs: Yeah, heard about that one before. (I think we are going a bit OT here :D)
06:36:31 <jg_> Xandaros: it does
06:40:00 <Sornaensis> Does no one here use the certificate package..???
06:42:31 <keviv> kadoban: http://paste.pound-python.org/show/n11JapZiCfX5l5B4Jf2x/
06:42:42 <keviv> oh oops
06:42:45 * hackagebot pseudo-boolean 0.1.3.0 - Reading/Writing OPB/WBO files used in pseudo boolean competition  https://hackage.haskell.org/package/pseudo-boolean-0.1.3.0 (MasahiroSakai)
06:43:08 <keviv> What's wrong with the type declaration in line 14? http://paste.pound-python.org/show/MPFllbOaqR9M5nse60xg/
06:43:24 <keviv> Oops, code is here http://paste.pound-python.org/show/n11JapZiCfX5l5B4Jf2x/
06:46:15 <quicksilver> keviv: Set.Set isn't a constraint
06:46:18 <MarcelineVQ> constraints are for classes, set is a data type `data Set a`
06:46:23 <quicksilver> although that is a pretty weird error message :/
06:47:18 <quicksilver> (Integral b, Show b) => Set.Set a -> b -> Bool
06:47:28 <roelof> Can this be improved : http://lpaste.net/144931
06:47:45 * hackagebot fft 0.1.8.2 - Bindings to the FFTW library.  https://hackage.haskell.org/package/fft-0.1.8.2 (HenningThielemann)
06:48:21 <quicksilver> it's fine, roelof 
06:48:39 <roelof> quicksilver:  thanks 
06:48:46 <quicksilver> some people would use lens but it would have no particular benefit on an example that small
06:48:52 <quicksilver> except forcing you to learn something new :)
06:49:14 <keviv> quicksilver MarcelineVQ: So I should set the type constraint to data Set a?
06:49:22 <roelof> Im thinking how to solve the same sort problem but then check if they overlap each other 
06:49:52 <MarcelineVQ> keviv, something like: happyHelperSet :: (Integral b, Show b) => Set.Set a -> b -> Bool
06:49:55 <prsteele> keviv: (Integral b, Show b) => Set.Set a -> b -> Bool
06:50:02 <keviv> ah
06:50:21 <MarcelineVQ> `| n `Set.member` history = False` won't work with that though so you'll have to play with it I think
06:50:25 <prsteele> keviv: if you wanted your code to work 'for all set-like data' then you'd need a typeclass for set-like things
06:50:50 <roelof> I cannot do something like this : overlap  (NewShape ( ?? because I cannot know if the shapes are rectangles, circles or one of both of them  
06:51:18 <roelof> or I must make several functions ,. one to check if two circles are overlapping etc. 
06:51:27 <quicksilver> roelof: well it would only be one function
06:51:28 <frerich> roelof: I think(!) that as it is, you might get warnings because the arguments 'width' and 'height' shadow the global functions 'width' and 'height'
06:51:52 <dzhus> Can I get `typeOf` take type synonyms into account?
06:51:52 <roelof> frerich:  I see no warnings on compiling 
06:51:54 <quicksilver> roelof: but it would have several cases in its definition yes
06:52:07 <quicksilver> :t typeOf
06:52:09 <lambdabot> Typeable a => a -> TypeRep
06:52:19 <quicksilver> dzhus: no. Type synonyms do not exist as far as TypeRep is concerned.
06:52:23 <keviv> hmm
06:52:29 <dzhus> quicksilver: ok
06:52:59 <keviv> MarcelineVQ prsteele: http://paste.pound-python.org/show/fIrcWMkesYNioGvW8FQd/
06:53:09 <keviv> MarcelineVQ prsteele: http://paste.pound-python.org/show/6lSy7VcLpIC77fyx8dV3/
06:54:00 <MarcelineVQ> "In the second argument of `Set.member', namely `history'"
06:54:06 <MarcelineVQ> :t S.member
06:54:07 <lambdabot> Ord a => a -> S.Set a -> Bool
06:55:02 <roelof> oke, something like this: http://lpaste.net/144932 , no test, just writing out of my head, quicksilver 
06:55:34 <quicksilver> roelof: no.
06:55:40 <quicksilver> roelof: no typeOf, no ==
06:55:52 <quicksilver> roelof: just use the ability to write functions by cases on the constructor
06:56:46 <quicksilver> roelof: overlap (RectangleShape r) (RectangleShape r) = {- 2 rects code -}; overlap (RectangleShape r) (CircleShape c) = {- rect/circle code goes here -}
06:56:49 <quicksilver> etc.
06:56:51 <roelof> quicksilver:  sorry, I do not see what you mean , These datastructures are only mentioned so far 
06:57:05 <quicksilver> roelof: does what I just typed make it clearer?
06:57:08 <roelof> oke, that way, Thanks 
06:57:17 <roelof> quicksilver: yes, I can work on now 
06:57:22 <roelof> thanks 
06:59:59 <quicksilver> roelof: explicit run-time type checking like 'typeOf' is often "code smell"
07:00:07 <quicksilver> in most languages, not just haskell
07:00:31 <quicksilver> sometimes it is the best way, but first consider if you can work *with* the type system to do it without that.
07:00:43 <roelof> oke, then I misunderstood you when you said typeOff here 
07:01:04 <quicksilver> roelof: yes, I was replying to dzhus there :)
07:01:22 <quicksilver> the risks of answering two questions at once.
07:01:31 <roelof> oke, no problem. 
07:01:49 <roelof> Im trying now to solve the missing code 
07:02:01 <MarcelineVQ> keviv: http://paste.pound-python.org/show/MQuLiEWQ6OvgeIKCooDp/
07:12:02 <roelof> why is where here not good : http://lpaste.net/144934
07:12:46 * hackagebot spir-v 0.0.0.2 - Some utilities for reading and writing SPIR-V files  https://hackage.haskell.org/package/spir-v-0.0.0.2 (jophish)
07:13:01 <keviv> MarcelineVQ: ahhhh ok thanks!
07:13:20 <rmrfroot> roelof: missing = on `overlap` ? 
07:15:04 <roelof> rmrfroot:  thanks, and also a few ) to close things 
07:17:01 <rmrfroot> anyone know why persists `runMigration` loggs ever though my runDB function has `SqlPersistT (NoLoggingT (ResourceT IO)) a`?
07:19:38 <rmrfroot> nvm, found out `runMigrationSilent` exist :)
07:27:25 <Bugdet> This may be a stupid question but I installed Morte - how do I run it with a file (not as a REPL)?
07:32:25 <Ankhers> Bugdet: Does http://hackage.haskell.org/package/morte-1.3.1/docs/Morte-Tutorial.html help? It has a section on using a file.
07:33:19 <Bugdet> Ankhers: of course, thanks!
07:34:36 <rmrfroot> Bugdet: Morte seems to install an executable you can use to read from stdiN
07:37:21 <rmrfroot> Bugdet: You could probably use the code for the executable if you want a fast POC: https://raw.githubusercontent.com/Gabriel439/Haskell-Morte-Library/master/exec/Main.hs
07:41:22 <Bugdet> rmrfroot: I understand, thanks!
07:42:48 * hackagebot ghc-session 0.1.0.1 - Simplified GHC API  https://hackage.haskell.org/package/ghc-session-0.1.0.1 (PiotrMlodawski)
07:47:54 * hackagebot ghc-session 0.1.0.2 - Simplified GHC API  https://hackage.haskell.org/package/ghc-session-0.1.0.2 (PiotrMlodawski)
07:51:11 <Bugdet> Where can I find the normalization proof for the calculus of constructions?
08:24:23 <joco42> what is the advantage of lazyness besides allowing to use infinite data-structures ?
08:24:37 <joco42> is there something more to it ?
08:26:13 <urusai> What does Data.Graph.graphfromEdges do when the list of nodes contains duplicate keys?
08:26:15 <johnw> it also allows "unknown answers" within structures
08:26:25 <Black-Wolf> joco42, avoid unnecessary calculations
08:26:27 <johnw> fst (10, error "oops") = 10
08:26:30 <prsteele> joco42: the compiler can abuse it. E.g. sum $ map f xs might be just as efficient as a fold
08:26:48 <prsteele> joco42: since we're lazy, the map doesn't actually need to have the whole list in memory at once
08:26:55 <prsteele> joco42: it can be consumed by sum as required
08:27:12 <johnw> joco42: a huge advantage is that algorithms compose better.  You don't need to encode short-circuits for efficiency in the data-generating parts of a composition
08:27:38 <quicksilver> it is surprisingly satisfying to write an algorithm once
08:27:50 <quicksilver> and know that the caller can consume just part of the result and still it runs efficiently
08:27:55 <quicksilver> instead of needing 4/5 special cases
08:28:02 <johnw> quicksilver++
08:28:22 <quicksilver> but to be honest the *really* good thing is the composability point, which I struggle to clearly express.
08:28:34 <prsteele> for example, isn't head . sort O(1) for the default implementation? I haven't actually verified this
08:29:19 <bennofs> head . sort is O(log n)
08:29:29 <bennofs> afaik
08:29:50 <prsteele> bennofs: ah, but that's still better than O(n log n) with a strict implementation
08:30:11 <joco42> ok, thanks for the answers, so to summarize lazyness is good for 2 reasons:1) infinite data structures 2) performance, is there something else?
08:30:18 <prsteele> bennofs: also I definitely meant to write O(n) and not O(1)
08:30:57 <bennofs> ugh, I meant O(n) ofc. O(log n) is impossible: you have to visit each element at least one
08:31:01 <bennofs> s/one/once
08:31:06 <prsteele> joco42: for me it makes the code map more closely to the math. I can reason easily about 'the list of all primes', rather than worrying about how many I need. This falls under point (1), I suppose
08:31:25 <prsteele> bennofs: exactly. but being O(n) is still somewhat surprising if you're not used to laziness
08:31:31 <joco42> yeat, prsteele , that seems point 1)
08:34:29 <rvb> It's also nice for dynamic programming.
08:35:11 <rvb> You just say "make a table, each cell (i,j) saves the result of f(i,j)" and f(i,j), in turn, is computed from the table.
08:35:25 <rvb> Without side effects.
08:36:54 <rvb> joco42: That is, in case of dynamic programming, lazy evaluation is not only for performance, but saves a lot of manual work since you do not have to care in which order to compute the f(i,j)
08:37:20 <rvb> And really only the needed table entries will be computed.
08:37:24 <prsteele> joco42: it doesn't have to be infinite for things like that to happen though. Suppose in branch 1 you want computation A, and in branch 2 you want computation B. You don't need to defer the computations to the branches to avoid extra work; you can do them all in a where clause or let statement and just let the compiler figure out which one actually needs computing
08:38:25 <rvb> A downside is that I have not found a way to implement standard dynamic programming tricks of saving memory yet ... for example, if you can prove that your f(i) needs f(j) only for j>i-x, then you only need a table with x entries and can reuse the rest.
08:38:42 <prsteele> rvb: look into memoization
08:38:47 <joco42> rvb interesting point
08:38:54 <prsteele> rvb: simple implementation would be to store the computed values in a map
08:39:01 <prsteele> rvb: and pass around the map in the state monad
08:39:16 <prsteele> rvb: whenever you need a value, try to look it up. If it isn't there, recursively compute and store
08:39:29 <rvb> prsteele: I think you missed my point.
08:39:57 <prsteele> rvb: perhaps. this removes the table entirely, and hoists it to a map
08:40:23 <rvb> But that leads to much slower table lookups.
08:40:43 <joco42> ok so to summarize : lazyness is good for 1) infinete data structures 2) performance 3) dynamic programming/automagic order handling
08:40:50 <joco42> anything else?
08:42:09 <tommd> @tell orion You could make bindings to hamburg's 448 implementation in about an hour, I'd bet.  I don't know of a pre-existing Haskell library.
08:42:09 <lambdabot> Consider it noted.
08:42:10 <rvb> prsteele: Yes, of course, the memory saving tricks are possible.  But in the end, the program would look similar to C++. ;-)
08:42:30 <rvb> prsteele: What I mean is, that I have not found a "nice" way yet.
08:44:18 <prsteele> rvb: ah. yes, I'm actually working on a library for infinite-horizon dynamic programs right now, and am wrestingling with that problem
08:45:43 <Perl6_is_dead> Hello everyone!
08:45:50 <prsteele> Perl6_is_dead: hello
08:45:51 <tommd> Hello pessimist.
08:46:36 <rvb> prsteele: Infinite-Horizon ... that's like in a "moving average" for subsequences of an infinite sequence?
08:47:14 <prsteele> rvb: depends on your goal. If there is a discount factor (e.g. risk-free investment rate) you can compute actual long run payoff. Or you can try to minimize the long-run cost per unit time
08:47:40 <prsteele> rvb: I'm actually solving stochastic dynamic programs, so expectations are well-defined
08:56:19 <joco42> numeric programming in haskell ? too bad it went all into python... 
08:56:40 <joco42> numpy , scipy , matplotlib... 
08:57:11 <prsteele> joco42: I'm in a somewhat unique situation in that I don't need to rely on existing libraries, so I can just start from scratch. However, you can be sure that when my Haskell code spits out results it is getting plotted with matplotlib
08:57:12 <joco42> did not happen for haskell... kinda... strange... 
08:57:56 <joco42> :) prsteele ... yeah then its a nice situation
08:58:18 <joco42> maybe 10 more years and we have scientific computation in haskell
08:59:31 <joco42> there are some haskell python bridges... in the IO monad ...  
09:00:03 <prsteele> joco42: https://hackage.haskell.org/package/numeric-prelude
09:02:03 <joco42> prsteele: did u use this lib?
09:02:11 <joco42> how is it?
09:02:16 <prsteele> I haven't used it, unfortunately
09:02:29 <joco42> i keep in mind... 
09:02:33 <prsteele> but I think their goal is to get Haskell to be as friendly as Python for numerics
09:02:39 <rvb> And somehow all the more high-level graph algorithms are implemented in C++ libraries.
09:03:08 <joco42> rvb: and they have nice python bindings...
09:03:29 <prsteele> rvb: I think that is an artifact of how these algorithms are specified
09:03:40 <prsteele> pseudocode in papers is often *heavily* state dependent
09:03:44 <rvb> prsteele: Yes, probably.
09:04:04 <prsteele> so unless you want to understand the topic as thoroughly as the authors, the most reliable way to implement their work is to translate the logic exactly
09:04:05 <joco42> i guess haskell is somehow more "difficult" for simple problems and folks don't use it... 
09:04:10 <rvb> Not even the mathematicians write their pseudocode in functional style. ;-)
09:04:44 <prsteele> I think it might be institutionalized in peer review by now
09:04:56 <rvb> prsteele: What do you mean?
09:05:07 <rvb> That reviewers reject functional pseudocode?
09:05:27 <prsteele> I could imagine that being a reason, but I haven't seen it happen
09:05:31 <joco42> or maybe the problem is that when i grew up in primary school not haskell was thought but basic
09:05:48 <joco42> in 86 
09:05:57 <joco42> or 90 
09:06:56 <joco42> c64 had no haskell , it was load "bla",8,1
09:07:52 <joco42> http://selmiak.bplaced.net/games/c64/coding/load01.png
09:07:54 <rvb> prsteele: I somehow doubt that this would happen.
09:08:25 <rvb> I have to check me own pseudocodes, however, whether they are functional or not. ;-)
09:09:21 <prsteele> rvb: you're right, it probably wouldn't happen
09:13:51 <nshepperd> a lot of pseudocode is static-single-assignment, which is *almost* functional
09:14:33 <rvb> Yep.
09:14:46 <rvb> Or incrementing some index in a loop, which is also almost functional.
09:14:53 <Bugdet> Is there any simple explanation/implementation of pure/dependent type systems, that is simpler than http://strictlypositive.org/Easy.pdf ? I am not responding well to this paper's content due to added complexity
09:15:23 <rvb> But many graph algorithms are really not very functional ... they mark stuff, unmark stuff, mark stuff differently.
09:15:27 <emilypi> ooo thanks for the link Bugdet
09:15:34 <rvb> Change some flow here, flow there...
09:16:07 <prsteele> see: all cycle-canceling algorithms
09:16:16 <Bugdet> No problems emilypi. I want to understand how type checking works on the simply typed lambda calculus and on dependently typed calculi - I can't filter that information from the cited paper.
09:21:07 <jerin> http://fpaste.org/288564/raw/
09:21:07 <jerin> Having trouble with the types in this code. Code loads into the interpreter, while g' n gives an error when called.
09:21:07 <jerin> can someone help
09:23:05 <clrnd> jerin, what error?
09:23:08 <prsteele> jerin: example or error?
09:24:23 <prsteele> jerin: /s/or/of
09:25:46 <jerin> http://fpaste.org/288570/raw/
09:25:46 <jerin> This is what I'm getting
09:25:50 <jerin> in the interpreter
09:26:37 <clrnd> oh, try g' 3 :: Float
09:26:43 <prsteele> jerin: specify the type of one of the functions to help it out? or try g' 3 :: Double, for example
09:26:46 <clrnd> or g' (3 :: Float)
09:28:29 <jerin> prsteele: Everything is supposed to give integer answers, g hashes (x, y)  to unique integer. g' is the inverse operation
09:28:39 <jerin> sqrt probably gives a double answer
09:29:02 <prsteele> :t (/)
09:29:03 <lambdabot> Fractional a => a -> a -> a
09:29:11 <prsteele> :t 1 / 2
09:29:12 <lambdabot> Fractional a => a
09:29:19 <prsteele> I think that's your problem
09:29:30 <prsteele> :t div 
09:29:32 <lambdabot> Integral a => a -> a -> a
09:29:50 <prsteele> :t sqrt
09:29:51 <lambdabot> Floating a => a -> a
09:29:52 <prsteele> is also a problem
09:30:00 <prsteele> but floor fixes it
09:30:21 <Denommus> hi
09:30:51 <prsteele> jerin: so change / to `div`
09:30:55 <prsteele> Denommus: hello
09:37:27 <Reiser> Silly question, I see that any Monad can be made into an Applicative/Functor easily in terms of Monad operations
09:37:46 <Reiser> But is the reverse always possible? Like, if I have a monad instance, can I always define its join in terms of Applicative?
09:38:22 <jerin> prsteele: Specified the type signatures of all functions to be Integer conversions
09:38:22 <clrnd> Reiser, no
09:38:24 <johnw> no, you cannot
09:38:37 <johnw> join represents new functionality on top of Applicative
09:38:45 <jerin> prsteele: Now I'm getting compile error on w, involving sqrt
09:38:54 <johnw> (or rather, on top of Functor actually)
09:38:55 <prsteele> jerin: that's not the problem, the problem is the typ eof (/)
09:39:12 <prsteele> :t (/)
09:39:13 <lambdabot> Fractional a => a -> a -> a
09:39:20 <prsteele> jerin: you want to use div
09:39:22 <prsteele> :t div
09:39:23 <lambdabot> Integral a => a -> a -> a
09:39:28 <Reiser> johnw, I'm with you, I just mean, can I always implement the function using the old functionality in some manner
09:39:42 <Reiser> Such as how, for Applicative Maybe for instance, I could do (<*>) f = map f
09:40:00 <prsteele> jerin: although you probably need to use sqrt . fromIntegral as well
09:40:04 <johnw> I can't say for each particular instance of Monad, but certainly not in general
09:40:29 <Reiser> Ah ok, that's what I was after, thank you
09:41:58 <prsteele> jerin: you probably want w :: Integer -> Integer, but sqrt expects a float
09:42:04 <prsteele> :t sqrt . fromIntegral
09:42:06 <lambdabot> (Floating c, Integral a) => a -> c
09:48:34 <Taneb> Ugh, I can never get the FFI working
09:48:45 <Taneb> If I have a function in C, how do I actually tell GHC where to find it?
09:49:15 <glguy> I don't think GHC cares where it is. You tell Cabal which libraries to link you with
09:49:38 <Taneb> So I can't just have a C file in the same directory?
09:49:53 <glguy> You can, but then you tell Cabal which C files to compile and link you with
09:50:43 <glguy> You need the 'c-sources:' section
09:51:41 <jerin> prsteele: Still no luck, can you give me some resource which properly explains how type casting / type classes in haskell works?
09:52:11 <prsteele> jerin: https://en.wikibooks.org/wiki/Haskell/Classes_and_types
09:52:21 <prsteele> jerin: but I'd honestly just play in the interpreter (ghci)
09:52:30 <prsteele> jerin: type :t (/) in ghci to get the type of the / operator
09:52:34 <prsteele> jerin: and you'll see
09:52:36 <prsteele> :t (/)
09:52:38 <lambdabot> Fractional a => a -> a -> a
09:52:42 <prsteele> jerin: whereas
09:52:44 <prsteele> :t div
09:52:45 <lambdabot> Integral a => a -> a -> a
09:53:33 <prsteele> jerin: if you write your definition of w in the interpreter, you get w :: (Floating r, Integral b, RealFrac r) => r -> b
09:53:57 <prsteele> jerin: the Floating r is introduced both by sqrt, and (/)
09:54:14 <prsteele> jerin: change (/) to div, since you want integer division, and change sqrt to sqrt . fromIntegral
09:54:16 <prsteele> :t fromIntegral
09:54:18 <lambdabot> (Integral a, Num b) => a -> b
09:57:43 <ski> jerin : it's not a cast, it's a conversion
10:10:26 <muzzle> hi
10:11:32 <dmj> muzzle: hi
10:11:34 <prsteele> hello muzzle 
10:13:31 <Mikie> i've found that there is weird behavior when "compare (0/0) (0/0)". why can i compare NaN's? furthermore, why alwas GT?
10:14:41 <dzhus> Could someone try `(\now -> decode (encode (now, now)) :: Maybe (UTCTime, UTCTime)) <$> getCurrentTime`?
10:15:05 <dzhus> For some reason aeson's encode gives a naked value when encoding UTCTime
10:16:22 <ski> @src compare
10:16:22 <lambdabot> compare x y | x == y    = EQ
10:16:22 <lambdabot>             | x <= y    = LT
10:16:22 <lambdabot>             | otherwise = GT
10:16:28 <ski> > let nAn = 0/0 in map (\(<>) -> nAn <> nAn) [(==),(<=)]
10:16:30 <lambdabot>  [False,False]
10:16:32 <ski> Mikie ^
10:18:20 <Mikie> Ok, but why we have instance of (==) for nan's?
10:18:44 <clrnd_> dzhus, well ... it works here :P
10:19:38 <Mikie> dzhus: Just (2015-11-09 18:16:16.4760601 UTC,2015-11-09 18:16:16.4760601 UTC)
10:19:42 <clrnd> yep
10:20:00 * clrnd always amazed how cool haskell is
10:20:18 <itsmeyo> what are some newbie-friendly graphic libraries?
10:20:28 <itsmeyo> for 2d graphics
10:20:52 <clrnd> gloss maybe
10:21:14 <itsmeyo> ok thanks
10:21:23 <itsmeyo> also my professor say something about ray tracing?
10:21:25 <itsmeyo> I think
10:21:28 <itsmeyo> is that the right term
10:22:04 <ski> Mikie : there is a NaN in both `Float' and `Double'. both those types have instances for `Ord'
10:22:44 <ski> Mikie : what is the type of that `Just (2015-11-09 18:16:16.4760601 UTC,2015-11-09 18:16:16.4760601 UTC)' ?
10:22:50 <clrnd> itsmeyo, I'm quite sure there are no haskell 2d libs that do ray tracing for now
10:23:47 <Mikie> ski, IO (Maybe (UTCTime, UTCTime))
10:24:11 <ski> hrm, ok (well, rather without the `IO', but ok)
10:24:12 <itsmeyo> I get the error "Could not find module `Graphics.Gloss" despite having install gloss
10:24:15 <itsmeyo> I ran cabal install gloss
10:25:52 <Mikie> try not gloss but GraphViz
10:25:54 <Mikie> https://github.com/BinRoot/Haskell-Data-Analysis-Cookbook/tree/master/Ch11
10:26:59 <Mikie> I found it user-friendly enough:)
10:27:10 <lpaste_> tzh pasted “app” at http://lpaste.net/144947
10:27:42 <tzh> re: that paste; is there a way to do some type-level programming to unify the types of those two functions together?
10:29:52 <lyxia> tzh: I see twelve functions, you said two.
10:30:29 <lyxia> tzh: Do you want to unify all of them? all the appl together? all the appr together?
10:31:02 <tzh> lyxia: the latter, all the appl* into just `appl`, and ditto with the appr*s
10:33:05 <lyxia> tzh: How would you know which to use, t could be another function type.
10:34:56 <tzh> lyxia: well, that's what i'm unclear on how to do. i saw a polyvaradic function in haskell that worked via overlapping instances so that its type could always be `t -> [t]` or `[t]`, and required a manual type declaration on the result to actually finish and generate a list. but that seems real messy
10:37:49 <tzh> alternately, if t is another function type then that means the nested tuple has just provided the first n arguments to the function. but i don't know if my sense that that would work could be extended to me actually... writing that code
10:38:33 <tzh> i.e., `:: (a -> b -> c -> d) -> (a, b) -> c -> d` doesn't seem like a fundamentally conflicting type
10:38:45 <tzh> to what appl would be
10:38:56 <lyxia> right
10:41:57 <ski> @type uncurry `asTypeIn` \uncurry f xy z -> uncurry f xy z
10:41:58 <lambdabot> (a -> b -> t1 -> t) -> (a, b) -> t1 -> t
10:43:25 <urusai> > let uniq = map head . group in uniq [1,1,1,1,2,2,2,3,3,3,3,3,4,4,4,5,5,5,5,5,5,5] -- does the standard library already have something like this?
10:43:27 <lambdabot>  [1,2,3,4,5]
10:44:38 <prsteele> urusai: Data.List (nub, nubBy)
10:45:08 <prsteele> urusai: note nub is O(n^2), since it doesn't assume the input is sorted
10:45:38 <prsteele> > nub [1, 2, 1, 2, 2, 3, 2, 4]
10:45:40 <lambdabot>  [1,2,3,4]
10:46:59 <bergmark> you can also use something like HashSet.toList . HashSet.fromList or the containers equivalent
10:48:56 <hesiod> Hi! I would like to implement a recursive "reparenting" function using Lenses/Traversals from xml-html-conduit-lens that roughly goes like this: If a predicate, given a node, returns True, "remove" that node and moves the node's children to the parent. Is there an straightforward (as in non-boilerplate and Haskellish) way to do this?
10:51:20 <prsteele> hesiod: no experience with Lens, sorry
10:51:26 <urusai> predator217: bergmark: Thanks!
10:51:48 <jophish> What regex library do all the cool kids use now?
10:52:14 <urusai> jophish: I think parser combinator libraries are generally preferred. :-)
10:52:21 <jophish> ah, this is for text replacement
10:52:25 <urusai> Oh.
10:52:28 <jophish> just for some really dirty hack
10:53:18 <jophish> s/<[^ >]* ([^>]*)>/<\1>/
10:53:20 <jophish> that kind of thing
10:53:41 <sm> jophish: I like regex-tdfa. Cross platform, pure haskell, and fairly featureful
10:53:50 <jophish> sold, thanks sm
10:54:07 <joco42> jophish: is that posix?
10:54:15 <jophish> joco42: I have no idea
10:54:19 <sm> jophish: see also some helpers in Hledger.Utils.Regex
10:54:39 <joco42> i just used pcre yesterday... if u want perl/python compatible syntax
10:54:59 <joco42> is regex-tdfa posix?
10:55:49 <slomo_> regex-applicative is also nice if you want combinators for regular expressions
10:56:13 <jophish> yeah, I've used regex-applicative before, very cool
11:01:08 <lpaste_> lyxia pasted “for tzh” at http://lpaste.net/144949
11:03:28 * hackagebot uniform-io 1.0.0.0 - Uniform IO over files, network, anything.  https://hackage.haskell.org/package/uniform-io-1.0.0.0 (marcosdumay)
11:07:50 <dgpratt> you know that haskell persistence library that basically keeps everything in memory, but logs it? that must have the worst name ever because I can *never* remember it
11:08:21 <Welkin> dgpratt: acid-state?
11:08:27 <dgpratt> YES!
11:08:33 <Welkin> that is an in-memory database
11:08:34 <dgpratt> thanks, Welkin
11:09:41 <tzh> lyxia: okay wow thank you! i'm going to have to read this like ten times to understand why it works but this is going to be a huge help!
11:09:54 <jophish> sm: thanks for the pointer to the hledger utils. I'm really surprised those functions aren't in regex-base or somewhere
11:16:03 <sm> many haskellers don't value regexps :)
11:16:18 <unknownloner> why is that?
11:16:20 <sm> I agree, it's unfortunate
11:17:05 <jophish> unknownloner: perhaps because there are better tools for the job most of the time
11:17:27 <unknownloner> like I get that people like parser combinators, but is there any reason for it besides "you could use something else"
11:18:23 <unknownloner> I don't often need to use regex, but whenever I do I spend half an hour trying to remember which regex library I'm supposed to use and how to use it
11:18:54 <unknownloner> usually because someone using my code wants to be able to configure a list of expressions in a file and filter stuff or something
11:19:02 <clrnd> mmm what would be a nice fixed length lists/vectors library?
11:19:20 <clrnd> basically for storing a 3x3 board
11:19:21 <Cale> unknownloner: Regular expressions as commonly implemented tend to do a really poor job of abstraction. You usually can't, within the language of regular expressions, name some regular expression and then reuse it.
11:19:22 <Zekka|Sigfig> unknownloner: They’re just a solution that gives you pretty intuitive support for backtracking and value-grabbing in a way that composes without you having to be clever
11:19:30 <dolio> Most people over-value regexps.
11:19:53 <Cale> unknownloner: Also, they usually don't give you all the operations which can be efficiently provided on regular languages, which is upsetting to me and weird.
11:19:59 <Zekka|Sigfig> making them ordinary functions that can produce values and take arguments means you get macroing and assigning-names-to-recognized-subparts for free
11:20:06 <clrnd> or would a [[t]] make sense anyway?
11:20:07 <dolio> Well, not most people. Most programmers. :)
11:20:18 <mauke> Cale: regexes don't implement regular expressions
11:20:33 <Cale> mauke: I suppose in many implementations that's true as well, which is unfortunate.
11:20:53 <mauke> why? you get features that can be efficiently provided
11:20:54 <unknownloner> I suppose I just wish most of the questions asking how to use regex weren't answered with "use somethng else" online, makes it difficult to find the answers when I actually need them
11:20:54 <Cale> and if you want some more general class of languages, they're just bad notation
11:20:56 <urusai> If you actually want to process a regular expression, a regex can make sense. But processing arbitrarily complex languages with extended regexes is just disgusting.
11:21:14 <Cale> Those features can't be provided without harming asymptotic efficiency
11:21:22 <urusai> err, s/expression/language/
11:21:29 <mauke> I don't care about that
11:22:30 <Zekka|Sigfig> FWIW I’m a big regex fan although I usually use them just as a terse way to say “please skip X” in a more conventional parser
11:23:06 <Zekka|Sigfig> it’s easier to express “an identifier looks like *this*” in terms of regex than in anything else in languages that don’t have a terse way to express something like parser combinators
11:23:49 <dolio> They're fine for recognizing. But the typical API for doing anything with the matches is awful.
11:23:57 <JKS__> Hello, I have existing structure containing expression tree
11:23:58 <dolio> regex-applicative looks much better for that kind of thing.
11:24:15 <mauke> dolio: awful in what way?
11:24:31 <JKS__> how can I easily expand it attaching attribute saying how deep is the tree down there?
11:25:24 <dolio> In that it's just a bunch of lists/arrays that have no checked connection to the expression you wrote.
11:25:24 <mauke> JKS__: I know how to do it with open recursion but not with an existing type
11:25:44 <JKS__> well I have existing type
11:25:49 <JKS__> and already built data
11:26:04 <JKS__> is there a better way than making parallel tree?
11:26:15 <JKS__> or making new data type with same attributes + my new attribute
11:26:39 <mauke> can't you change your type?
11:27:03 <JKS__> this type is generated by external module
11:27:48 <JKS__> haskell must have an easy way to do that
11:29:32 <JKS__> let's say we have tree of data like html
11:29:39 <JKS__> and we would like to know depth of each node
11:29:50 <JKS__> there must be an easy way to do that
11:33:27 <dolio> There are easy ways, but someone involved has to design with it in mind.
11:33:31 <dolio> It doesn't just happen.
11:34:38 <JKS__> well functional languages are made to traverse trees and analyze data
11:34:45 <JKS__> so it should be a common problem
11:40:26 <magbo> Hey, people! I'm being really stupid tonight. In a function that makes use of Update monad (from acid-state), how am I supposed to bind the result from IO context?
11:41:36 <magbo> Update isn't a transformer, I've read the code and it mentions State underneath, which is transformer, but I don't want to mess with "internals".
11:43:37 <magbo> Oh for f.
11:43:39 <magbo> http://hackage.haskell.org/package/acid-state-0.13.1/docs/src/Data-Acid-Abstract.html#update'
11:49:41 <aphocus> Anyone here familar with Repa? The type messages I get just look like nonsense to me.
11:50:28 <dfeuer> aphocus, I'm not, but I might be able to help anyway.
11:51:19 <dfeuer> aphocus, you should probably put together an lpaste or gist with the code and error message.
11:51:46 <aphocus> dfeuer, yeah just doing that now.
11:51:48 <henk> hey, how do I show the version of "base" I have available on the system?
11:52:27 <Clint> henk: ghc-pkg describe base
11:52:28 <int-e> ghc-pkg list base
11:52:29 <mauke> ghc-pkg list base
11:53:01 <henk> Clint, int-e, mauke: thanks (:
11:53:54 <aphocus> dfeuer, http://lpaste.net/144954
11:55:47 <aphocus> I should say line 51 is line 143 from the error message.
11:56:32 <lyxia> over _y {- no dot -} (+ uniSum)
11:57:02 <aphocus> oh! man I feel dumb now lol
11:57:04 <ski> aphocus : you could also replace all but the first `let' there with three spaces
11:57:40 <aphocus> ski, ahh good point.
11:57:49 <dfeuer> aphocus, you can then shift that big let out of the do.
11:58:17 <dfeuer> let blah blah blah in do blah blah blah.
11:58:29 <dfeuer> Or put them in a where clause.
11:58:35 <dfeuer> Lots of options.
11:59:19 <aphocus> I put them in because they are placeholders for like taking in user interation until I cbf'd adding that support.
11:59:24 * ski would personally avoid those uses of `$'
12:00:31 <aphocus> dfeuer, now my code is saying that (view _y) is a returning an array for functions wtf.
12:00:52 <aphocus> s/for/of/
12:01:31 <dfeuer> aphocus, code + error message is a lot more useful than a description. Update the paste.
12:02:14 <ski> s/update/annotate/
12:02:19 <aphocus> dfeuer, yeah I'm using structured haskell-mode, bit hard to instantly paste it.
12:02:47 <muzzle> is there a tutorial for working with STVector ?
12:03:48 <aphocus> dfeuer, and give me a second because its not even giving me the same error anymore.
12:06:30 <prsteele> muzzle: I couldn't find one that really got into it, but you can get pretty far just by following the types
12:08:03 <aphocus> http://lpaste.net/144954
12:09:22 <aphocus> Body is a V3 (V2 Float)
12:13:20 <aphocus> dfeuer, I don't know where it's getting the V3 Float from.
12:15:41 <dfeuer> aphocus, I would start by writing type signatures for all those bindings; that should get you better error messages. That said, it looks like maybe _y is focusing on something of a different type than you were expecting.
12:16:37 <dfeuer> You can also write type signatures on subexpressions. More type signatures ==> better error messages, as a general rule.
12:17:36 <aphocus> dfeuer, yeah, interestingly I have an almost identical expression in another part of the code which I remember having type issues with months back.
12:18:16 <dfeuer> aphocus, it can also help to replace everything "beyond" the error point with undefined, to avoid confusion.
12:18:34 * hackagebot concurrent-output 1.7.0 - Ungarble output from several threads  https://hackage.haskell.org/package/concurrent-output-1.7.0 (JoeyHess)
12:19:02 <nani___> is Haskell good for something like parsing a binary format and dumping some data from that in a text file, compared to imperative languages? I'm a beginner programmer and I'm just starting with a book so I don't actually know almost anything about the language
12:19:25 <muzzle> prsteele so how can i use (!) on an ST Vector?
12:19:35 <Clint> nani___: sure
12:19:37 <muzzle> it should be possible
12:19:40 <muzzle> i guess
12:19:53 <ski> muzzle : i think you probably can't
12:20:25 <muzzle> ski so how do i acces an element at a given index?
12:20:44 <Kron> how does one totally, completely purge ghc?
12:20:50 <Kron> I'm getting a lot of ghc-pkg check errors
12:21:00 <Kron> but removing .ghc and .cabal while uninstalling ghc and cabal-install don't help
12:21:09 <muzzle> wait
12:21:14 <muzzle> it's read
12:21:17 <muzzle> for mutable vectorw
12:21:21 <muzzle> unexpected
12:21:23 <muzzle> nvm
12:21:40 <dcoutts> Kron: ghc and cabal only store per-user info in .ghc and .cabal, so that is enough to purge their state
12:21:51 <ski> muzzle : `Data.Vector.Mutable.read' ?
12:22:02 <Kron> how do I purge global info?
12:22:08 <Kron> i think something went wrong in my global stuff
12:22:26 <monochrom> when you uninstall ghc, that also uninstalls global stuff
12:22:41 <monochrom> at least for most definitions of "uninstall"
12:22:49 <aweinstock> :t Data.Vector.Mutable.read -- muzzle 
12:22:51 <lambdabot> Control.Monad.Primitive.PrimMonad m => Data.Vector.Mutable.MVector (Control.Monad.Primitive.PrimState m) a -> Int -> m a
12:23:27 <Kron> because when I uninstall and reinstall ghc, the same errors persist
12:24:13 <monochrom> then perhaps the error is meant to happen with even a clean install
12:24:16 <aweinstock> nani___: Data.Binary.Get has a decent interface for parsing binary information
12:24:21 <Kron> http://lpaste.net/4962588325434097664
12:24:38 <Kron> are these supposed to happen on a clean install?
12:25:17 <monochrom> no
12:25:33 <nani___> Clint, aweinstock, thanks! good to know
12:25:51 <Kron> yeah, I did another total purge and clean install
12:25:54 <Kron> same errors
12:26:02 <Kron> it's maintaining some sort of malformed state... somewhere
12:26:31 <henk> How do I debug a "cabal install" error like http://pastie.org/10547220 ? I don’t see any pointer to the reason why it fails …
12:26:47 <dcoutts> Kron: what makes you say that?
12:27:06 <Kron> well, how else can I explain this kind of malformed install?
12:27:43 <dcoutts> Kron: sorry, I didn't see what you said earlier, so I'm missing context
12:27:51 <Kron> ah okay
12:28:00 <monochrom> then the "uninstall" procedure or "purge" procedure or whatever you call it is incomplete. this can happen if this is from a linux distro. yes, most linux distros butcher GHC to this extent to fit their fetish ideologies
12:28:03 <dcoutts> henk: see where it says:
12:28:04 <Kron> well, I'm trying to fix a broken haskell install by purging and reinstalling it
12:28:04 <dcoutts> setup-Simple-Cabal-1.22.4.0-x86_64-linux-ghc-7.10.2: LICENSE: does not exist
12:28:09 <Kron> it's on arch
12:28:22 <Kron> anyway, uninstalling ghc and cabal and then removing .ghc and .cabal don't help me
12:28:28 <Kron> even when I reinstall, it's still malformed
12:28:35 * hackagebot Earley 0.10.1.0 - Parsing all context-free grammars using Earley's algorithm.  https://hackage.haskell.org/package/Earley-0.10.1.0 (OlleFredriksson)
12:28:47 <dcoutts> henk: it's because it's failing to install, because it tries to install the LICENSE file the package specifies. But that file is missing, so installing it fails.
12:28:59 <dcoutts> henk: in other words, it's exactly what the error says
12:29:00 <henk> dcoutts: ARGH, I thought that was just an informative message …
12:29:20 <henk> dcoutts: thanks
12:29:20 <aphocus> :t Repa.sumAllS
12:29:21 <dcoutts> henk: it warns at the configure step, and fails at the install step
12:29:22 <lambdabot> Not in scope: ‘Repa.sumAllS’
12:30:59 <Kron> what happens if I erase /usr/lib/ghc-7.10.2 and then reinstall?
12:31:00 <aphocus> dfeuer, I figured it out, sumAllP is inside a monad.
12:31:15 <dfeuer> aphocus, excellent!
12:31:48 <lmj> I have some mathematical structures that would benefit from (+),(-),(*), however there is no relevant abs or signum. For a while I avoided abusing Num for its operators, but I've eventually seen that it's impractical not to abuse Num. Invented operators detract from readability, and there's no numeric promotions.
12:32:07 <lmj> I wonder what the general attitude is about that. I noticed HaskellForMaths does the same abuse.
12:32:22 <dfeuer> aphocus, learning to wring good error messages from GHC and interpret them is a bit of an art, but it's a good one to learn. One tool that's often useful for that is ScopedTypeVariables, although I don't think that would have been useful in this case.
12:32:56 <monochrom> lmj, the general attitude is resent and inaction :)
12:33:12 <dfeuer> monochrom++
12:33:24 <monochrom> I guess s/resent/resentment/ to make it anoun
12:33:35 <lmj> One can see the problem in Data.Complex, where you can't make complexes out of integers. (Or at least do anything with them.)
12:34:44 <dolio> Yes, it's widely acknowledged that Num is not ideal.
12:34:53 <lmj> Considering the academic background of Haskell, it's surprising that multiplication would be hard-coded to abs and signum.
12:34:54 <dfeuer> I think  + and - should be in AbelianGroup, and * should be in Ring.
12:35:20 <dfeuer> fromInteger belongs somewhere else; not sure where.
12:35:40 <dolio> The problem is that when people start thinking about what a good design would look like, they disappear down a rabbit hole.
12:36:11 <kadoban> Well, it's pretty easy to get better than Num, but a bit hard to say where to stop.
12:36:27 <ski> dfeuer : shouldn't `fromInteger' also be in `Ring' ?
12:36:44 <ski> (or would you prefer `fromInteger' to be injective ?)
12:36:45 <dolio> The other problem is that it'd be very difficult to change Num, because it would break a lot of stuff.
12:38:21 <dolio> So I expect most people want to only change Num for the 'perfect' replacement, but there is no such thing.
12:39:42 <dfeuer> ski, perhaps. One complication is literals; Nat is not a ring.
12:39:52 <aweinstock> is https://github.com/mikeizbicki/subhask a decent step forward from Num?
12:40:36 <ski> dfeuer : yes. a non-negative literal could use `fromNatural'
12:41:09 <dfeuer> ski, yeah, that makes sense.
12:42:03 <dfeuer> ski, oh yeah, I guess you might want  * to be in something weaker like a rng.
12:42:19 <dfeuer> Which would shift fromInteger to Ring.
12:42:58 * ski isn't sure of what shifting dfeuer is talking about
12:43:03 <dfeuer> Er, sorry.
12:43:07 <dfeuer> I expressed that backwards.
12:43:25 <dfeuer> Yes, I think fromInteger in Ring probably makes sense, but * probably should be more primitive.
12:43:29 <aphocus> dfeuer, all that for removing the net velocity. now the system stays on screen :)
12:44:01 <dfeuer> But then you have a bit of a problem with *ordered* rings, because Ord+Ring has all the necessary operations but no laws.
12:44:25 <dfeuer> But we already have that problem, I guess.
12:45:35 <Kron> solved my problem
12:45:42 <Kron> the solution: torch everything in /usr that has "ghc" in its name
12:45:53 <Kron> I went on a merry rampage through my root filesystem and that fixed everything
12:46:14 <Kron> it caches a lot of stuff in there apparently
12:46:39 <Denommus> I finally reached the point where I love monad transformers :-D
12:46:49 <Denommus> I want to produce something in Haskell
12:46:53 <jg_> hi, i have the following type signature 'myFunction :: ConduitM XT.Event o WST ()' where WST () is my monad stack. What does 'o' mean here really?
12:47:10 <jg_> conduitM definition is here http://hackage.haskell.org/package/conduit-1.2.5.1/docs/src/Data-Conduit-Internal-Conduit.html#ConduitM
12:47:35 <jg_> that 'o' isn't really provided in my type signature but it still works?
12:48:25 <dolio> aweinstock: The stuff there uses far too many GHC extensions to even be on the table.
12:48:38 <tdammers> jg_: implicit forall?
12:49:03 <ski> dfeuer : `class (Ord a,Ring a) => OrdRing a'
12:49:12 <ski> (with no operations, only laws)
12:49:36 <dcoutts> Denommus: turn back before it is too late! Or you'll end up suffering like jg_ is currently suffering!
12:49:47 <jg_> :P
12:49:54 <jg_> tdammers: thanks!
12:50:27 <Denommus> dcoutts: I just need to understand parser combinators properly, now
12:50:27 <jg_> so it's the same as 'forall o. ConduitM XT.Event o WST ()' ?
12:50:30 * dcoutts is of the opinion that (to a first approximation) all monad transformer stacks should be hidden behind a newtype wrapper of a specific app-specific monad
12:50:39 <Denommus> I'm finding myself unable to make a tokenizer for Lua in megaparsec
12:50:54 <Denommus> "fora" always gives me the for token, then the identity a token
12:51:00 <Denommus> identity "a"
12:51:02 <sleblanc> what's a function that operates on two lists and that interleaves the elements of both lists?
12:51:08 <dfeuer> ski, that's doable, but somewhat annoying. Inference will not generally give you the type you want, and of course you need the "extra" instance declarations.
12:51:08 <lmj> I have two classes that often appear together in contraints. Is it an accepted practice to make an empty convenience class that holds both?
12:51:24 <dcoutts> Denommus: parsec isn't really designed for making lexers, though it can make simple (inefficient) ones
12:51:29 <Denommus> sleblanc: what do you mean by interleave?
12:51:46 <Denommus> dcoutts: I'm not using parsec, I'm using megaparsec
12:51:54 <dfeuer> lmj, if there's no real relationship, you should use ConstraintKinds instead, and  type ThisConstraint = (ThatConstraint, TheOtherConstraint)
12:51:55 <ski> dfeuer : hm, yes
12:52:01 <Denommus> dcoutts: I do tried to use alex, but megaparsec doesn't really support external tokenizers as of now
12:52:09 <dcoutts> Denommus: ok, but same applies, unless they've added anything special
12:52:12 <sleblanc> Denommus, f a b = [a !! 1, b !! 1, a !! 2, b !! 2, ...] 
12:52:23 <sleblanc> Denommus, oops, meant that to start with !! 0
12:52:31 <dcoutts> Denommus: dunno what they've changed in megaparsec, but parsec works with external lexers just fine
12:52:57 <dcoutts> Denommus: I'd expect megaparsec to keep that ability, so it's worth double checking
12:53:42 <lmj> dfeuer: ok thanks, I'll look into it.
12:53:48 <andrybak> sleblanc f (x:xs) (y:ys) = (x:y:f xs ys) ; f [] [] = []
12:54:16 <sleblanc> andrybak, yeah, I just thought of that too. Is there a built-in that achieves this?
12:54:21 <andrybak> sleblanc hoogle doesn't show anything useful for [a]->[a]->[a] except (++)
12:54:23 <sleblanc> (andrybak, thank you)
12:54:43 <dfeuer> lmj, the empty convenience class is an option though. And it may have some advantages, even. I'm not really sure about the balance.
12:54:48 <jophish> haddock has strange formatting. Breaks between paragraphs are the longest breaks on the page, larger than breaks between different constructors for example
12:55:04 <andrybak> :t intersperse
12:55:06 <lambdabot> a -> [a] -> [a]
12:55:16 <Denommus> sleblanc: you could use concat . transpose
12:55:27 <Denommus> > concat . transpose $ [[1, 2, 3], [4, 5, 6]]
12:55:29 <lambdabot>  [1,4,2,5,3,6]
12:55:52 <jg_> so, in simple terms - what do i need an explicit 'forall' for?
12:55:54 <Denommus> dcoutts: trust me, I've spoken directly to the maintainer
12:56:03 <dcoutts> Denommus: ok, fair enough
12:56:04 <Denommus> dcoutts: it's expected to arrive in the next version
12:56:07 <dcoutts> ok
12:56:15 <dcoutts> good, since it's essential for many uses
12:56:17 <ski> @let infixr 5 /\/; (/\/) :: [a] -> [a] -> [a]; [    ] /\/ ys =     ys; (x:xs) /\/ ys = x : ys /\/ xs
12:56:18 <lambdabot>  Defined.
12:56:24 <ski> sleblanc ^
12:56:42 <dcoutts> Denommus: e.g. cabal's new parser uses alex+parsec
12:57:17 <lyxia> jg_: It's useful to pass polymorphic functions to other functions.
12:57:37 <sleblanc> Denommus, exactly what I needed. thanks!
12:58:14 <sleblanc> ski, nice!
12:58:15 <ski> jg_ : when you want to have a polymorphic value in a data structure. when you want to pass a polymorphic value as an argument to a function. when you want to express an "existential data constructor". when you want to use scoped type variables
12:59:23 <lmj> dfeuer: an empty class is a bit ugly because it needs the corresponding empty instances.
13:00:22 <dfeuer> lmj, it only needs one if you use the right extensions (FlexibleInstances, maybe also UndecidableInstances).  instance (Foo x, Bar x) => Baz x
13:00:48 <lmj> dfeuer: yes I've tried that, but it leads to overlapping instances in my case.
13:00:48 <dfeuer> Actually, you may not need FlexibleInstances. Whatever.
13:01:02 <ski> lmj : if you need something more than both class constraints holding at the same time (e.g. you may want the operations of the two classes to "play nice" with each other, in some sense), then you imho need a new class, with those classes as superclasses
13:01:06 <dfeuer> lmj, it needs to be the *only* instance.
13:01:32 <dfeuer> But what ski said is true too.
13:01:54 <jophish> wow, 7 years old: http://trac.haskell.org/haddock/ticket/43
13:03:03 <Zemyla> Why does the primitive package not have ArrayArrays?
13:04:12 <lmj> dfeuer: ah right, FlexibleInstances would only be applied to the convenience class, which wouldn't affect other classes, right?
13:04:47 <dfeuer> lmj, not sure what that means. FlexibleInstances only expands the instances that GHC will accept. 
13:08:58 <rvxi> anyone one use the frames library?
13:09:07 <rvxi> trying to figure out how to specify an alternative delimiter
13:09:08 <Denommus> dcoutts: besides that, I find alex somewhat confusing
13:09:38 <dcoutts> Denommus: fair enough, it is a little old-school
13:09:42 <Denommus> dcoutts: in OCaml-land, I used sedlex, which was quite simple to use
13:11:06 <Denommus> ok, so `MonadIO m => StateT s m a` is basically an imperative language with a global variable
13:12:08 <dcoutts> Denommus: not merely imperative, you'd get that with just Monad m => StateT s m a, but imperative with full IO effects
13:18:37 * hackagebot HulkImport 0.1.0.3 - Easily bulk import CSV data to SQL Server  https://hackage.haskell.org/package/HulkImport-0.1.0.3 (smobs)
13:29:00 <jp_rider> hi, how do you add constraints to type aliases defined in typeclasses?
13:29:18 <jp_rider> you can find an example here: http://lpaste.net/1848869733143674880
13:34:06 <broma0> is there a good way to do record updates of types with existential constructors? I've seen a few solutions online but can't get this code to compile (it's short): http://lpaste.net/144962
13:35:53 <hexagoxel> jp_rider: you probably should first make master0 non-ambiguous
13:37:03 <jle`> broma0: the problem with withFunc is that _comPrism might not be a prism into the same b as `f`
13:37:29 <jle`> so if i gave it `withFunc putStrLn`, _comPrism might not have been Prism' s String
13:39:23 <broma0> jle`: do you see what im trying to do though? Im essentially trying to provide a default Component so that a user of the lib can easily extend it 
13:39:35 <jle`> broma0: for c, there might be some issues with type inference.  try _comFunc = ((\b -> putStrLn "c0") :: forall a. a -> IO ())
13:40:04 <jle`> oh wait no that shouldn't work
13:41:46 <broma0> jle`: right
13:42:40 <jle`> i feel like c should compile. it still doesn't, even with the explicit type signature?
13:43:05 <lmj> can lambdabot search by type signature?
13:43:34 <ReinH> lmj: use @hoogle or use the actual hoogle
13:43:44 <ReinH> The one on stackage.org is more complete as well
13:43:57 <lmj> k thanks
13:44:58 <broma0> jle`: correct. no compile. i can add the error message if you'd like
13:45:32 <jle`> sure
13:45:51 <jle`> you see why withFunc doesn't work, right?
13:46:44 <broma0> because the 'b' in (b -> IO ()) could be ANY 'b', and not necessarily the 'b' in 'Prism' s b', right?
13:46:53 <jle`> yes
13:47:05 <jle`> btw, does the non-record syntax equivalent work for `c`/
13:47:06 <jle`> ?
13:47:42 <broma0> jle`: i tried that with RecordWildCards but it didnt work.. ill write it out without the wildcard syntax to double check
13:47:44 <jle`> c = case defComponent of Component p _ -> Component p (\_ -> putStrLn "c0") -- ?
13:47:54 <FofG_> I'm new to STM and trying to figure out how to atomically create a Map Text (TChan Text). I currently have `atomically newBroadcastTChan`but now I'd like a map.  Any pointers on how I might go about doing that?
13:48:44 <broma0> jle`: whoa that worked..
13:49:00 <jle`> it might just be record syntax not working then
13:49:23 <broma0> jle`: is there a cleaner way to write that?
13:50:02 <jle`> not that i know of, but you can probably abstract over it
13:51:06 <jle`> sefF :: Component s -> IO () -> Component s; setF comp x = case comp of Component p _ -> Component p (\_ -> x)
13:51:23 <jle`> note that i'm using IO () in place of (forall a. a -> IO ())...i think they're isomorphic
13:51:27 <jle`> up to bottom
13:53:09 <jle`> but if you want, it could be setF :: Component s -> (forall a. a -> IO ()) -> Component s; setF comp x = case comp of Component p _ -> Component p f
13:53:40 * hackagebot path-extra 0.0.2 - Chris Done's path library, enriched with URL-related goodies.  https://hackage.haskell.org/package/path-extra-0.0.2 (athanclark)
13:54:29 <broma0> jle`: I left out an important piece when i simplified my problem down to the one you just solved.. that _comFunc needs to be 'b -> IO b', not just 'b -> IO ()'
13:54:43 <broma0> with that small change we can't use your solution any longer
13:54:56 <broma0>   1 setF :: Component s -> (b -> IO ()) -> Component s
13:54:57 <broma0> 29  setF comp x = case comp of Component p _ -> Component p x
13:55:08 <jle`> that setF won't work, btw
13:55:13 <jle`> it needs to be (forall b. b -> IO ())
13:55:48 <jp_rider> hexagoxel: How do make maser0 non-ambiguous? Shouldn't running `runDB` in the monad transformer constrain the type?
13:55:58 <hackrilege> In Haskell is List a Monad?
13:56:03 <jle`> but yeah, _comFunc :: b -> IO b, you can have it setF :: Component s -> (forall b. b -> IO b) -> Component s
13:56:21 <jle`> which might not be too useful, depending on what you want
13:56:57 <broma0> jle`: still trying to wrap my head around these existentials..
13:56:59 <broma0> thank you
13:57:05 <jle`> hackrilege: it's an instance of Monad, yes
13:57:11 <jle`> broma0: np.  it'll come with time :)
13:57:43 <jle`> once you have a Component s, you have no idea what `b` is, so you can only operate on it with functions that are polymorphic over *all* b
13:57:51 <Zemyla> hackrilege: Yes, it is. return = (:[]), and (>>=) = flip foldMap.
13:58:11 <hackrilege> I thought monads were supposed to represent the pipe line of imperative programming...
13:58:29 <jle`> they can be used to model imperative programs, but that's not "what they're supposed to represent"
13:58:36 <jle`> that's like saying that numbers are supposed to represent football players :)
13:58:45 <jle`> i mean, yes, that's one use for numbers, but...
13:59:17 <hackrilege> Ok, lol
13:59:31 <jle`> if you use numbers for things like counting, or additition, money, etc., nobody can come and tell you "that's not what they're supposed to represent!" :)
13:59:52 <hackrilege> It's a complete misnomer thanks to https://en.m.wikipedia.org/wiki/Monad_(functional_programming)
14:01:08 <jle`> yeah, i'm not a huge fan of the way the article is written...i mean, some of the stuff can be called "technically correct", under the right interpretation/mental gymnastics, but that doesn't mean it's useful or not misleading, heh
14:01:16 <hackrilege> Could you explain the use of foldMap in (>>=)  ?
14:01:34 <ReinH> flip concatMap, actually
14:01:44 <ReinH> :t (>>=)
14:01:47 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:01:48 <ReinH> :t flip concatMap
14:01:49 <hackrilege> Ok that makes more sense
14:01:50 <lambdabot> Foldable t => t a -> (a -> [b]) -> [b]
14:01:51 <broma0> jle`: you were right about that not being terribly useful.. i get a type error trying to extend defcomponent to something with a specific type for 'b'
14:02:09 <hackrilege> What is Foldable?
14:02:11 <ReinH> :t flip concatMap `asAppliedTo` (undefined :: [a])
14:02:12 <lambdabot> [a] -> (a -> [b]) -> [b]
14:02:18 <ReinH> That's the type we care about right now
14:02:33 <ReinH> If m ~ [] then they are the same type.
14:02:36 <jle`> :t flip concatMap `asAppliedTo` []
14:02:38 <lambdabot> [a] -> (a -> [b]) -> [b]
14:02:50 <hackrilege> Nice
14:03:32 <hackrilege> Yet i get the instance. Where does join come in again?
14:03:53 * hackagebot active 0.2.0.7 - Abstractions for animation  https://hackage.haskell.org/package/active-0.2.0.7 (BrentYorgey)
14:04:02 <jle`> join for lists is `concat`
14:04:16 <ReinH> :t \f -> concat . map f
14:04:18 <lambdabot> (a1 -> [a]) -> [a1] -> [a]
14:04:21 <ReinH> :t \f -> join . fmap f
14:04:22 <jle`> concat :: [[a]] -> [a]
14:04:23 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
14:04:44 <ReinH> concatMap is concat and map together, (>>=) is join and fmap together.
14:04:46 <jle`> and it follows all the nice monad laws; concat (fmap concat x) = concat (concat x)
14:04:51 <jle`> s/fmap/map
14:05:33 <ReinH> so: join generalizes concat, fmap generalizes map, return generalizes (\x -> [x]), and (>>=) generalizes concatMap.
14:06:19 <hackrilege> Can i make use of applicative in the same way you just used functor to define the Monad instance methods?
14:06:46 <hackrilege> Return is like pure
14:06:49 <ReinH> pure = return, but that's all Applicative buys you.
14:06:55 <hackrilege> Yes!
14:07:04 <hackrilege> Awesome, thanks
14:07:06 <ReinH> (>>=) requires the extra power of Monad
14:07:15 <hackrilege> concat
14:07:28 <hackrilege> Or, join?
14:07:42 <ReinH> You could define a Monad using return and (>>=) or return, fmap, and join.
14:07:48 <ReinH> Haskell chooses return and (>>=)
14:07:57 <ReinH> but you can recover either from the other.
14:08:03 <ReinH> @src join
14:08:03 <lambdabot> join x = x >>= id
14:08:28 <ReinH> m >>= k = join (fmap k m)
14:09:51 <hackrilege> So if i have fmap already id choose to define join i think...
14:10:13 <lmj> :t \f x y -> uncurry (liftM2 (,)) (x, y) >>= uncurry f
14:10:14 <lambdabot> Monad m => (a -> b1 -> m b) -> m a -> m b1 -> m b
14:10:23 <hackrilege> !!
14:10:37 <lmj> What's a clean version of liftM2 with that little difference?
14:10:37 <pimlu> why is my attempt at memoizing a simple function causing it to hang?
14:10:38 <pimlu> http://hastebin.com/raw/bijiwahefi
14:11:16 <pimlu> the first time I try to use it with an empty map for the memo, it works
14:11:25 <pimlu> and the result gets stored in the map
14:11:26 <dfeuer> There are sometimes efficiency reasons to prefer =<< to (join .) . fmap
14:11:52 <ReinH> pimlu: as an aside, don't use isJust and fromJust: use pattern matching
14:12:05 <Zemyla> dfeuer: I'd say there are almost always efficiency reasons.
14:12:20 <pimlu> oh! that's a good idea
14:12:29 <lmj> liftM2 is (a1 -> a2 -> r) -> m a1 -> m a2 -> m r , whereas I'm looking for (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
14:12:43 <FreeFull> :t \f -> join . fmap f
14:12:44 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
14:12:51 <FreeFull> :t (>>=)
14:12:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:13:28 <ReinH> :t \f x y -> join (liftM2 f x y)
14:13:29 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
14:13:29 <pimlu> but yeah, whenever I try to use isPrime a second time using the stored memo, for any number or any reason, it hangs
14:13:36 <ReinH> lmj: ^
14:13:42 <lmj> ReinH: nice, thanks
14:13:53 <dfeuer> Zemyla, I imagine GHC can optimize sufficiently simple cases (e.g., Maybe and IO) reasonably well, and that fusion rules will take care of [], but in other cases there certainly could be problems.
14:13:55 <hackrilege> How does implementing >>= result in performance increase than defining join?
14:14:13 <hackrilege> Is that what's being said?
14:14:43 <Zemyla> hackrilege: Because fmapping and then joining creates an intermediate structure.
14:14:53 <hackrilege> Hmm
14:15:12 <hackrilege> Of no use?
14:15:25 <dfeuer> Laziness can often ameliorate that, but there will still be extra allocation.
14:15:39 <dfeuer> Except in cases where it can be optimized away.
14:16:20 <hackrilege> Can i see >>= in use on a list in a way which might illustrate this?
14:17:04 <lmj> @pl \f x y -> join (liftM2 f x y)
14:17:05 <lambdabot> ((join .) .) . liftM2
14:17:30 <ReinH> @unpl  ((join .) .) . liftM2
14:17:30 <lambdabot> (\ j o r -> (o >>= \ d -> r >>= \ c -> return (j d c)) >>= \ k -> k)
14:17:33 <ReinH> heh
14:17:58 <hackrilege> How by avoiding creating an intermidiate list of lists is achieved..
14:18:02 <lmj> I wondered why it was called pl, but then I remembered that "pointless" is a synonymous term.
14:18:32 <lmj> (to pointfree)
14:18:41 <jophish> statusfailed: 'partialDiscount' gave me a chuckle, thanks
14:19:09 <dfeuer> For Maybe,   join (fmap f m) = case (case m of {Nothing -> Nothing; Just x -> Just (f x)}) of {Nothing -> Nothing; Just y -> y}
14:19:23 <hackrilege> lmj; where the criticism is in that it infact obfuscates intuition toward type
14:20:12 <ReinH> what criticism?
14:20:26 <dfeuer> Then the case-of-case transformation and so on kick in, and you get   case m of {Nothing -> Nothing; Just x -> f x} and all is well.
14:20:44 <hackrilege> Calling point free "pointless"
14:20:52 <ReinH> pointless literally means "without point"
14:21:01 <ReinH> It's not a criticism
14:21:06 <hackrilege> It's mocking, i heard
14:21:24 <ReinH> It can be used that way, but it isn't necessarily
14:21:38 <kadoban> It's kind of a pun, depending on which meaning you want.
14:21:46 <pimlu> oh, lol, I think it's because I tried to use it the second time like this: let (memo, p) = isPrime memo 13
14:22:04 <pimlu> it works when used correctly
14:22:09 <dfeuer> hackrilege, if you have   join (fmap f xs)  for lists, and it's not optimized, then it will allocate a cons for each element of xs to hold the intermediate result lists.
14:22:30 <pimlu> ReinH: thanks for the tip, it looks a lot nicer now
14:22:36 <hackrilege> So a monad is an applicative functor with join, what is a monoid in this sense?
14:23:23 <dfeuer> It should be optimized, however, because join for lists is concat, and concat is defined in a fancy way that ultimately uses foldr and build, and map is as well, and the foldr in concat will merge with the build in map and they'll both vanish in a puff of smoke.
14:23:31 <ReinH> A semigroup with identity, I guess.
14:24:06 <dfeuer> A monoid can be thought of as either a semigroup with identity or a category with exactly one object. It comes down to the same thing.
14:24:12 <Zemyla> dfeuer: If you're compiling, not if you're making bytecode.
14:24:14 <hackrilege> dfeuer, how do i ensure such an implementation is optimised?
14:24:22 <dfeuer> Zemyla, yes, of course.
14:25:10 <hackrilege> I meant, how is monoid similar to monad?
14:25:20 <Lokathor> when i have a sandbox setup and a binary all built, what's the cabal command to install it to a directory outside my sandbox? Can I do that without rebuilding and it'll just copy over the correct files?
14:26:07 <dfeuer> hackrilege, to really make sure, you have to read through the generated core. The process can be sensitive to the inliner's decisions. You're better off using things like >>=, =<<, concatMap, or (probably most reliably) list comprehension syntax.
14:26:26 <Zemyla> hackrilege: You can write the types of mappend and mempty as (a, a) -> a and () -> a.
14:26:31 <dfeuer> List comprehension syntax will also do the right thing even without optimizations...
14:26:39 <kadoban> Lokathor: Why not just use stack? But in that case usually what I've done is just ln -sf it into ~/bin/
14:26:54 <dfeuer> Anyway, time for me to go back to attempting to learn Snap or something.
14:26:54 <Zemyla> Now imagine you have a type f ~> g = forall x. f x -> g x.
14:27:07 <Lokathor> kadoban, it's stack that i've built
14:27:13 <Zemyla> You can write return and join in the form Identity ~> m and Compose m m ~> m.
14:27:16 <ReinH> dfeuer: fwiw, (>>=) for lists as defined in base depends on list comp desugaring and foldr/build fusion for maximum efficiency
14:27:32 <dfeuer> ReinH, I know. That's because I wrote it that way :-)
14:27:34 <Lokathor> and it is stack that i wish to install
14:27:41 <ReinH> dfeuer: :p
14:27:50 <ReinH> Fair point.
14:28:19 <witt3rd> I'm trying to understand why this works: http://lpaste.net/144964
14:28:40 <witt3rd> how does id give back the right Product X?
14:28:57 <ReinH> hackrilege: a monad is a monoid in a particular way.
14:29:09 <ReinH> This is not related to its relationship with Applicative.
14:29:21 <kadoban> Lokathor: Ah, haha. Once you have it working, I'd probably just build it again actually using stack, unless that takes forever on your hardware. But maybe that's useless, I dunno.
14:29:34 <witt3rd> I understand that Product i j is a phantom type
14:30:07 <Lokathor> kadoban, well it takes the better part of a day because it's got 133 dependencies >_>
14:30:08 <dfeuer> ReinH, I realized that instead of fussing around with moving concatMap from GHC.List to GHC.Base, I could get the same result by using that syntax for (>>=). Thus do notation for lists gets treated (almost?) as well as list comprehension syntax. I wish they were identical, but that seems impossible.
14:30:12 <Lokathor> i coullllld
14:30:35 <micom> hello folks, I prefer to learn from code, any good decent easy for beginners project worth recommendation?
14:31:08 <ReinH> dfeuer: Sure, sure. I just read up on list comp desugaring to make sure I understood what was going on.
14:31:16 <Lokathor> micom, IRC bots are fun. command line games can be interesting. depends on what you want to do really
14:31:20 <ReinH> witt3rd: Well, id P 22 = (id P) 22 = P 22
14:31:27 <ReinH> Perhaps you mean id (P 22)?
14:31:48 <dfeuer> ReinH, that is some seriously hairy code. Did you notice two complete mechanisms for the cases where rules are and are not active?
14:31:57 <ReinH> Also that doesn't look like a valid category.
14:32:03 <micom> Lokathor, good irc, jabber library would be fantastic, there is lot of them, hard to choice proper one for beginner 
14:32:17 <ReinH> dfeuer: Yeah, so now I have to go read that section of SPJ's book to remind myself what "ordinary" desugaring looks like. :)
14:32:39 <lmj> DataKinds would allow me to avoid all this tagging I'm doing, but it requires GHC.TypeLits which says, "The programmer interface for working with type-level naturals should be defined in a separate library."
14:32:41 <ReinH> witt3rd: The `id' in  P a . P b = id $ P (a * b) is similarly useless.
14:32:43 <witt3rd> ReinH: I found this code in a google group :-)  id = P 5 seems like it would return P 5 all the time
14:32:53 <lmj> is DataKinds recommended for general usage?
14:32:56 <ReinH> witt3rd: Yes, if you were using that id. But you aren't
14:33:09 <ReinH> You are using (id P) 22, not id (P 22)
14:33:11 <Lokathor> micom, just make your own if you can't pick one :3
14:33:22 <witt3rd> ReinH: yes, the id $ was spurious
14:33:22 <hackrilege> Dfeuer, im not using lists I'm defining my own monad to use like a list
14:33:38 <zalatovo> is it bad practice to export data constructors from a module?
14:34:00 <ReinH> zalatovo: no.
14:34:06 <zalatovo> I rewrote some of my code a while ago to export similarly named functions but it just seems ugly to me now
14:34:21 <ReinH> witt3rd: This code looks pretty awful. What's the point?
14:34:32 <dfeuer> hackrilege, well, I think we've probably explained why >>= and =<< can have efficiency benefits over join + fmap, and some of the reasons they don't always. It'll be up to you ultimately.
14:34:35 <witt3rd> ReinH: i get the same result either way: (id P) 22 and id (P 22)
14:34:40 <ReinH> Aside from being maximally confusing?
14:34:41 <hackrilege> The thing i have is clearly a monad, I'm not sure if it's a monoid...
14:35:02 <witt3rd> ReinH: ha, well, that's a different story.
14:35:09 <ReinH> witt3rd: Oh, right, you would. Neither are using id :: Product i j
14:35:39 <witt3rd> ReinH: well that would explain it.
14:36:13 <hackrilege> Dfeuer, it sounds like when defining monads, applicative functor definitions should be written in terms of the functions of monad. Is that right?
14:36:30 <witt3rd> ReinH: this was a google groups thread about uses of Category and this was one of the code examples.  I was trying to wrap my head around how it worked
14:37:08 <ReinH> witt3rd: you are using (id :: a -> a) P 10
14:37:17 <witt3rd> ReinH: Haskell Cafe thread: https://groups.google.com/forum/#!topic/haskell-cafe/aLh6BrKvhgw
14:37:36 <ReinH> witt3rd: That looks like an awful example.
14:37:47 <witt3rd> ReinH: how to use the intended id?
14:37:51 <dfeuer> hackrilege, it depends. They should be essentially equivalent (whatever that means in context) to the versions written in those terms. But sometimes there are good reasons to write them otherwise.
14:38:01 <witt3rd> ReinH: ok, well, I'll dismiss it as an anti-pattern :-)
14:38:04 <ReinH> witt3rd: id :: Product () (), for example
14:38:21 <ReinH> It's useless, wrong, and confusing.
14:38:24 <ReinH> So yeah, ignore it.
14:38:42 <witt3rd> ReinH: hah.  ok.  thanks :-)
14:38:45 <hackrilege> What would be a good reason to write them otherwise?
14:38:57 <ReinH> hackrilege: if your Applicative is not a Monad
14:39:07 <dfeuer> hackrilege, sometimes <*> is written to use parallel processing. Sometimes it takes advantage of special knowledge of the "shapes" of the things being combined.
14:39:13 <hackrilege> That would not work reinh
14:40:02 <hackrilege> Yes i will be writing my applicative in parallel, as best i can
14:40:34 <hackrilege> But then perhaps it just enters via >>=
14:40:46 <ReinH> hackrilege: what would not work?
14:41:06 <hackrilege> That a monad that is applicative be not a monad
14:41:26 <ReinH> Well yes, but an applicative can not be a monad
14:41:40 <ReinH> hackrilege: Monad and Monoid are different concepts in Haskell
14:41:46 <ReinH> A type cannot be both
14:42:11 <ReinH> Monads have kind * -> * while Monoids have kind *
14:42:51 <hackrilege> Aha, so is my applicative functor a monad or a monoid, i have join, I'm not sure what I'd need for it to be a monoid
14:43:07 <ReinH> An Applicative with join is a Monad
14:43:10 <ReinH> It cannot be a Monoid
14:43:14 <hackrilege> Oh so if it's a functor it's not a monoid, simple
14:43:43 <hackrilege> Excellent, that kind thing cleared up a lot, thanks
14:43:44 <ReinH> For example, [] is an Applicative. [a] is a Monoid.
14:43:59 <hackrilege> Nooo
14:44:10 <hackrilege> Yes
14:44:22 <dfeuer> hackrilege, for a somewhat unusual example, compare the Applicative instance at https://github.com/haskell/containers/blob/7dfdc33f8cc740036cee5a5e94c5603722d6fd02/Data/Sequence.hs#L218  to the one at https://github.com/haskell/containers/blob/master/Data/Sequence.hs#L275
14:44:26 <ReinH> :k []
14:44:26 <hackrilege> Ok, you applied a type as a parameter
14:44:27 <lambdabot> * -> *
14:44:29 <ReinH> :k [()]
14:44:31 <lambdabot> *
14:44:37 <hackrilege> Yes
14:44:39 <hackrilege> Ok
14:44:39 <johnw> ReinH: between the two can I have an Applicatoid?
14:44:53 <hackrilege> Lol, yes plz
14:44:53 <ReinH> johnw: why not Monoidberg?
14:45:16 <hackrilege> Berg?
14:45:16 <johnw> "Curiously Strong Functors"
14:45:29 <hackrilege> Lol
14:45:36 <ReinH> :k forall a. [a]
14:45:38 <lambdabot> *
14:45:54 <hackrilege> :t forall
14:45:55 <ReinH> hackrilege: an unconvincing futurama joke
14:45:55 <lambdabot>     Not in scope: ‘forall’
14:45:55 <lambdabot>     Perhaps you meant ‘forAll’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
14:46:15 <ReinH> forall is a quantifier, not a type. I probably shouldn't have mentioned it.
14:46:20 <hackrilege> Zoidberg ok...
14:46:40 <hackrilege> So
14:46:57 <hackrilege> What's an applicatoid?
14:47:12 <ReinH> Nothing.
14:47:37 <hackrilege> It can't be done?
14:47:41 <ReinH> johnw: but they're all strong, so it's not very curious.
14:47:44 <ReinH> I don't know what it would mean.
14:48:52 <hackrilege> It would probably be helpful if i cold understand why, your saying i can't have applicative monoids, as they take no type parameter, yet somehow they are monads!?  Or something..
14:49:24 <ReinH> A type can't be both an Applicative and a Monoid because they require different kinds.
14:49:33 <ReinH> A type can (and often is) both an Applicative and a Monad.
14:49:37 <ReinH> s/both/be both
14:49:42 <hackrilege> How can a monoid be anything like a monad without it's type parameter?
14:49:50 <ReinH> What?
14:50:03 <ReinH> A Monoid in Haskell isn't anything like a Monad.
14:50:27 <hackrilege> I was misled earlier
14:52:01 <hackrilege> (ReinH) hackrilege: a monad is a monoid in a particular way.
14:52:14 <ReinH> Yes, that is true. But a Monad is not a Monoid.
14:52:42 <ReinH> The typeclasses in Haskell are restricted versions of the concepts.
14:53:01 <hackrilege> how is it a monad in a particular way?
14:53:30 <hackrilege> Monoid sorry
14:53:33 <ReinH> A monad (in its fully general sense) is a monoid (in its fully general sense) in the category of endofunctors.
14:54:09 <hackrilege> Cool, what's an endofunctor?
14:54:12 <Lokathor> kadoban, alright, sent it building in a screen, 0 / 128 :P
14:54:14 <ReinH> But Monad /= monad and Monoid /= monoid. They are just convenient representations in Haskell.
14:54:20 <Lokathor> i'll check back on it tomrrow I guess
14:54:24 <hackrilege> Oh, shame
14:55:09 <ReinH> Monad is a particular variety of monad, restricted to apply only to Haskell types of kind * -> *.
14:55:13 <kadoban> Lokathor: XD probably not really necesary if it takes that long to build, but I guess it won't hurt anything if you don't mind the waiting.
14:55:23 <ReinH> Monoid is a particular variety of monoid, restricted to apply only to Haskell types of kind *
14:55:24 <kadoban> Lokathor: Sorry I just saw your previous line now.
14:55:29 <hackrilege> So it seems like as oh been using lists and mapM that I'm ok with monads, i see how i can use them. What are monoids for?
14:56:02 <jophish> hackrilege: if you're interested in this stuff I can't recommend this series highly enough: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
14:56:03 <ReinH> Monoid is for things that can be combined together, for which there is a thing that serves as an identity for this combining operation.
14:56:15 <hackrilege> I see exactly what a monoid is now i think thank you
14:56:29 <ReinH> Furthermore, this combining operation must be associative.
14:56:36 <hackrilege> So numbers are monoids?
14:56:47 <ReinH> In at least two ways: addition with 0 and multiplication with 1
14:56:57 <hackrilege> Great
14:57:02 <ReinH> > Sum 1 <> Sum 2
14:57:04 <lambdabot>  Sum {getSum = 3}
14:57:07 <ReinH> > Product 3 <> Product 5
14:57:10 <lambdabot>  Product {getProduct = 15}
14:57:15 <ReinH> > mempty :: Sum Int
14:57:16 <lambdabot>  Sum {getSum = 0}
14:57:24 <hackrilege> Whats an endofuctor?
14:57:40 <dfeuer> A functor from a category to itself.
14:57:49 <Cale> hackrilege: Rather, types of numbers are monoids
14:57:56 <Cale> hackrilege: The numbers themselves are not
14:58:03 <cite-reader> It's a functor from a category back into itself. Which is probably not illuminating at all.
14:58:17 <cite-reader> (Also probably subtly wrong, I'm not a category theorist.)
14:58:21 <Cale> e.g. Integer is a monoid (in at least two ways), but 6 is not.
14:58:34 <ReinH> In order to explain endofunctor, we need to explain functor in its full generality. In order to explain functor, we need to explain what a category is.
14:58:43 <Cale> That's not incorrect, apart from the use of "into" instead of "to" :)
14:58:53 <cite-reader> See, I knew there was something.
14:59:03 <hackrilege> So basically something of type (a->a) how is that more confined than an arrow?
14:59:04 <Cale> (though "into" actually applies to all Haskell Functors)
14:59:10 <Cale> er, no it doesn't
14:59:12 <Cale> :D
14:59:25 <Cale> Well, I guess that depends on how you look at it
14:59:36 <ReinH> into in the sense of?
14:59:39 <Cale> Const doesn't really give you constant functors
14:59:42 <Cale> :D
14:59:45 <ReinH> co-onto?
15:00:02 <Cale> "into" usually means injective
15:00:23 <ReinH> so mono?
15:00:48 <ReinH> monic, w/e
15:00:53 <Cale> mono and injective are subtly different, but "into" is slightly informal, so I can imagine someone using it for monics
15:01:01 <Lokathor> kadoban, well the only other thing it does is run a simple IRC bot
15:01:12 <Lokathor> and it just makes the bot laggy when it's compiling, so not a huge loss
15:01:37 <hackrilege> A category is a collection of objects and arrows which return objects in this collection as domain and codomain
15:02:09 <Cale> hackrilege: The canonical example of a category is the category whose objects are (all) sets, and whose arrows are all functions between those sets.
15:02:29 <ReinH> hackrilege: plus some properties of arrows
15:03:14 <hackrilege> A functor is a datatype with one parameter instantiating fmap correctly
15:03:27 <ReinH> a Functor is "
15:03:41 <hackrilege> Hmmm
15:03:52 <ReinH> A functor is a mapping between categories that preserves the categorical structure
15:03:59 <Cale> hackrilege: and for which for any set A, the identity arrow A -> A is just the identity function, and for which if we have f: B -> C, and g: A -> B, then (f . g): A -> C is defined as the function which for any a in A gives (f . g) a = f (g a)
15:04:19 <Cale> hackrilege: However there are many other fun examples of categories.
15:04:53 <hackrilege> Associativity, identity, composition
15:05:01 <Cale> hackrilege: For almost any logical deductive system, you can define a category whose objects are statements of the logic, and whose arrows are proofs that one statement entails another.
15:05:10 <ReinH> For some of which, arrows look nothing like functions and objects look nothing like sets.
15:05:12 <Cale> (if you're a bit careful about how you define composition)
15:05:41 <hackrilege> OK
15:05:51 <ReinH> You can also define a category out of the real numbers and the relationship <=
15:05:52 <hackrilege> Endofuctors are;
15:06:22 <hackrilege> ?
15:06:32 <ReinH> An endofunctor is a functor from a category to itself.
15:06:39 <hackrilege> Sorry
15:06:43 <hackrilege> We had that
15:06:54 <Cale> A functor F: C -> D consists of two things:
15:07:12 <Cale> An assignment to each object X in C, some object FX in D.
15:07:34 <Cale> and to each arrow a: X -> Y in C, an arrow Fa: FX -> FY in D.
15:08:01 <Cale> These are subject to the constraint that for every X in C, we have F(id_X) = id_(FX), and that F(a . b) = Fa . Fb
15:08:16 <Cale> (whenever a and b are composable arrows)
15:08:42 <ReinH> Which is a formal way to say that a functor preserves identities and composition
15:09:06 <Cale> In Haskell, we encode (some) functors from the category of Haskell types to itself in the language as type constructors
15:09:16 <Cale> The type constructor itself gives the mapping on objects
15:09:22 <Cale> i.e. it's a function from types to types
15:09:31 <ReinH> An endofunctor F: C -> C sends objects in C to (possibly different) objects in C, and arrows in C to (possibly different) arrows in C.
15:09:38 <Cale> Maybe for instance sends the type Integer to the type Maybe Integer
15:09:54 <Cale> and the mapping on arrows is provided by fmap
15:09:55 <Cale> :t fmap
15:09:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:10:02 <hackrilege> So now monads are monoids in the category of endofunctors
15:10:05 <Cale> You can see that as  (a -> b) -> (f a -> f b)
15:10:16 <Cale> hackrilege: That will take an additional day to set up
15:10:27 <Cale> The use of the word "monoid" there is not the usual one
15:10:28 <ReinH> For example, in the category formed by the real numbers and the relation =<, the function \x -> x - 2 is a functor.
15:10:41 <Cale> It's a category theoretical generalisation of the usual notion of monoid
15:10:47 <Cale> Really it should say "monoid objects"
15:11:12 <Cale> also, it's not just the category of endofunctors you have to be aware of, but the fact that this is something called a monoidal category
15:11:33 <Cale> So, there's a bunch of prep to understanding that properly
15:12:12 <hackrilege> I guess monoidal category would be enough
15:12:13 <ReinH> It operates on objects by subtractring 2, and on arrows by subtracting 2 from both the domain and codomain of the arrow.
15:12:15 <Cale> https://en.wikipedia.org/wiki/Monoidal_category gives a definition of a monoidal category
15:12:25 <hackrilege> Great! Thanks
15:12:50 <Cale> Don't be surprised if it takes a bit of work to understand
15:13:19 <Cale> The idea is that we're sort of generalising over the structure that the category of sets has with Cartesian product and a one element set.
15:13:47 <Cale> In the category of sets, there's a natural isomorphism (A x B) x C -> A x (B x C)
15:14:19 <Cale> as well as left and right units -- if I is some one element set, then we have isomorphisms  I x A -> A and A x I -> A
15:14:20 <hackrilege> Is a monad applied to a type a monoid?
15:14:35 <jle`> remember that this is a topic a lot of people spend a semester or two to get to
15:14:41 <jle`> :D
15:14:41 <Cale> In at least one way, but that doesn't fully characterise it.
15:14:55 <ReinH> Cale: really?
15:15:01 <hackrilege> Whats missing?
15:15:09 <ReinH> What is one of the ways?
15:16:10 <Cale> Oh, maybe for some types there's no identity
15:16:12 <ReinH> I'm interpreting that question as: can we write instance Monad m => Monoid (m a). Perhaps that is incorrect?
15:16:14 <Cale> nevermind
15:16:23 <Cale> m () will be a monoid
15:16:42 <Cale> with return () as the identity and (>>) as the multiplication
15:17:09 <Cale> But other types are not going to be so fortunate, because one of your unit laws will fail
15:17:23 <shachaf> m w will be a monoid if w is a monoid
15:17:28 <Cale> that as well
15:17:34 <ReinH> mempty = return mempty and mappend = (>>)?
15:17:43 <hackrilege> Shachaf gold
15:17:45 <Cale> mappend = liftM2 mappend
15:17:52 <ReinH> Ah.
15:17:55 <ReinH> ofc
15:17:57 <hackrilege> Reference?
15:18:09 <Cale> hackrilege: I just explained how to do it :P
15:18:21 <Cale> (along with ReinH)
15:18:41 <hackrilege> I don't understand liftm2
15:18:56 * hackagebot tellbot 0.6.0.5 - IRC tellbot  https://hackage.haskell.org/package/tellbot-0.6.0.5 (DimitriSabadie)
15:18:58 <hackrilege> But if it's just mappend then maybe i do
15:19:05 <Cale> liftM2 f x y = do u <- x; v <- y; return (f u v)
15:19:07 <hackrilege> It's like function composition
15:19:13 <Cale> So
15:19:25 <jle`> it's like function "lifting"
15:19:26 <Cale> liftM2 mappend x y = do u <- x; v <- y; return (mappend u v)
15:19:47 <ReinH> It's like a version of fmap for functions with two arguments.
15:19:50 <Cale> i.e. you just run both computations and combine the results using the monoid multiplication
15:19:54 <shachaf> The m () monoid is just a special case of this one.
15:19:57 <ReinH> and indeed fmap is a.k.a. liftM
15:20:18 <hackrilege> Omg liftm2 is cool
15:20:36 <mjhoy> weird question: does anyone use stack *and* nix?
15:20:47 <ReinH> mjhoy: seems unlikely, but idk
15:20:54 <jle`> liftM2 :: Monad m => (a -> b -> c) -> (m a -> m b -> m c)
15:21:18 <ReinH> hackrilege: btw liftM2 only requires Applicative: liftM2 f x y = f <$> x <*> y
15:21:36 <ReinH> (it's called liftA2 for Applicatives)
15:21:40 <mjhoy> ReinH: my idea is to use nix to develop, and then stack to build a binary i can give to someone (on osx)
15:21:59 <ReinH> mjhoy: you couldn't do both with nix?
15:22:11 <johnw> nix would have annonying references within the /nix/store absolute ptah
15:22:16 <johnw> I think that use of stack sounds legitimate
15:22:16 <ReinH> Ah.
15:22:19 <mjhoy> johnw: yep
15:22:20 <hackrilege> In going to have an applicative monad, which do i use?
15:23:11 <jle`> when writing a function people often like to use the more general thing, so it applies to more
15:23:12 <mjhoy> but i don't want stack to find my nix-installed ghc... or do i? seems complicated.
15:23:29 <ReinH> If you're working with a concrete type, it doesn't matter too much. If you're writing abstract functions, try to use the most general abstraction. e.g., favor fmap over liftM so you can write signatures like Functor f => ... instead of Monad f => ... and it can be used with more things.
15:24:04 <ReinH> s/abstract/polymorphic
15:25:05 <hackrilege> I think most importantly monads can use things defined over applicative, is that correct?
15:25:45 <jle`> yes
15:25:46 <ReinH> hackrilege: Yes, all Monad instances are also Applicative and Functor instances.
15:26:07 <jle`> if i state a property about all triangles in general, that property will be able to apply to any right triangle, for example
15:26:08 <ReinH> (As long as you're using GHC 7.10)
15:26:29 <hackrilege> Write functions in terms of the highest superclass, define all superclass instances in terms of subclass instances
15:28:03 <hackrilege> Ghc needs a non existent language pragma to handle subclass overriding superclass instances
15:29:11 <hackrilege> I.e. i should be able to write a definition of fmap inside an instance apliccative statement
15:30:00 <hackrilege> At the top level, in the class definition of applicative
15:30:35 <hackrilege> How do i write this?
15:30:58 <emmanuel_erc> t
15:31:04 <emmanuel_erc> oops sorry..
15:33:28 <hackrilege> Is there any reason it would be a bad idea?
15:41:46 <mada> how do you ask lambdabot for e.g. the Ord instance for a tuple?
15:54:04 <Lokathor> do cabal and stack build files differnetly in some way? stack seems to be building faster with stack than with cabal
15:54:07 <Lokathor> but it could be in my head
15:54:57 <Lokathor> hackrilege, overriding a function in a subclass, yes that would be a bad idea
15:55:26 <hackrilege> Why?
15:56:07 <Lokathor> each function should have exactly one definition
15:56:13 <hackrilege> I do that, i brute force it by exposing an instance of the superclass defined in terms of the subclass
15:56:34 <hackrilege> The superclass does not provide a definition
15:56:54 <Lokathor> if you define a functor defined in terms of the applicative instance, that's still just 1 definition for the data type
15:57:32 <hackrilege> I would like to do that inside the applicative class definition
15:58:09 <hackrilege> Since it will always be able to provide this, which is the correct implementation
15:58:31 <Lokathor> oh you mean to say that applicative has a method that defaults to fmap?
15:59:27 <hackrilege> No just that the scope of the instance definition extends to that of the superclass
15:59:53 <Lokathor> can you make an example in an lpaste of what you want to write?
16:00:18 <hackrilege> So that it would be a valid place to write a definition of fmap for all applicative instances
16:00:59 <Lokathor> you mean so that you could write just the Applicative for a new data type and it'd know how to infer Functor from it?
16:01:37 <Lokathor> That'd be nice, sure
16:02:58 <Lokathor> I think if you fiddled around you could write something like "insatance Applicative a => Functor a where" and it'd mayyybe let you do that.. ?
16:03:17 <Lokathor> but even if you could do that it'd be strange
16:03:25 <jle`> you can do that, but it's not a good idea
16:08:39 <nchambers> @src Bool
16:08:39 <lambdabot> data Bool = False | True deriving (Eq, Ord)
16:09:17 <Lokathor> pretty simple data type
16:09:44 <jle`> almost as simple as it gets, actually :O
16:09:55 <Lokathor> @src ()
16:09:55 <lambdabot> data () = ()
16:10:36 <jle`> there you go
16:11:36 <jle`> 1 bit of information vs. 0 bits :)
16:12:38 <jle`> i wonder if there's a data type that provides 0.5 bits of information
16:13:16 <jle`> or at least something in between 0 and 1
16:13:46 <hackrilege> Simply that ^ are you sure you need the paste? http://lpaste.net/144967
16:15:07 <nchambers> <Lokathor> pretty simple data type ← I was just curious if it was actually defined like that
16:15:35 <hackrilege> Not all superclass methods can be written in terms of subclass methods but those that can should be done so at the highest level, which is in the class definition of the subclass.
16:15:39 <jle`> nchambers: lambdabot actually doesn't give the "real" definition; it is only a lookup into a text file
16:16:04 <nchambers> ah
16:16:56 <hackrilege> Lokathor, did you see the paste?
16:17:48 <jle`> nchambers: http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Bool.html
16:18:31 <jle`> hackrilege: instance B a => A a doesn't do what you think it does, probably :)
16:18:53 <hackrilege> It does
16:19:16 <hackrilege> It's how I'm forced to write but it works
16:20:28 <hackrilege> And this syntax should be included, namely definition of the superclass methods in the subclass class definition
16:21:26 <hackrilege> Sorry, instantiation of the superclass methods in the the subclass class definition
16:22:07 <hackrilege> I have seen a few requests for this extension
16:22:41 <hackrilege> Does anyone know how to do that?
16:23:00 <hackrilege> Write the extension...
16:23:03 <jle`> GHC matches instances on the instance head
16:23:24 <jle`> so let's say it's looking for an instance for, say, Bool, which is not an instance of B
16:23:34 <hackrilege> So it could also match inside all subclass class definitions
16:23:39 <jle`> it'll see "instance ... => A a", and go, "ah, this is my instance for Bool!"
16:23:55 <jle`> and then it sees the constraint, B a => , and goes, "oh, this can't be right."
16:24:06 <jle`> and throws an error that Bool isn't an instance of B
16:24:46 <jle`> so it'd be impossible to write an instance of A for Bool
16:25:45 <jle`> even if you had instance A Bool somewhere else
16:25:46 <hackrilege> Sorry, can you do that example but with functor applicative and bool?
16:26:00 <hackrilege> A is functor, B is applicative
16:26:29 <jle`> i'll do it with Eq and Ord, if that's ok too
16:26:36 <hackrilege> We have applicative Bools instance, your saying we cannot get a Functor instance?
16:26:50 <jle`> class Eq a => Ord a
16:27:39 <jle`> let's say we wanted to write instance Ord a => Eq a where x /= y = x > y || x < y
16:27:50 <hackrilege> OK
16:28:07 <jle`> but there are a bunch of types that we want Eq instances for, but not Ord instance
16:28:14 <hackrilege> Yep
16:28:29 <jle`> let's say Foo is one such type.  we would write instance Eq Foo where ...
16:28:56 <jle`> but now when we use (==) on Foo, it'll see "instance ... => Eq a where ...", the first one, because Foo matches with `a`
16:29:02 <hackrilege> No
16:29:07 <jle`> and go, "this is the instance i'm going to use!"
16:29:13 <hackrilege> Why!?
16:29:15 <hackrilege> No
16:29:21 <jle`> and then it'll see the constraint, Ord a, and go, "oh, this can't work. error!"
16:29:50 <hackrilege> There is no instance Ord Foo
16:30:04 <jle`> yeah, which is why it'll complain about the error
16:30:14 <jle`> it commits to the instance first, by seeing "Eq a"
16:30:33 <jle`> it matches on the instance head, without looking at the constraints
16:30:33 <hackrilege> Where would it see the ord constraint?
16:30:50 <jle`> after it commits
16:32:13 <hackrilege> So as Ord instantiates Eq, an instance of Eq would have its noon existent Ord instance queried?
16:32:25 <jle`> or at least it'll complain about overlapping instances
16:32:38 <hackrilege> Is it a runtime error because my code compiles
16:33:09 <jle`> what's your code?
16:35:36 <dolio> jle`: ∀r. (r -> r -> Bool) -> r
16:37:29 <jle`> dolio: hm, what are some inhabitants?
16:37:44 <dolio> Dunno.
16:38:09 <dolio> That might be wrong.
16:38:44 <dolio> Maybe ((r -> r -> Bool) -> r) -> r, actually.
16:42:26 <meditans> hi, is there a way to let's say increment by one the maximum element of a list, using lens combinators?
16:42:55 <meditans> (I'm stuck because maximumOf does not return an optics)
16:43:43 <t4nk994> how do i show that if t_1 is alpha equivalent to t_2 then t_2 is also alpha equivalent to t_1 ?
16:43:59 * hackagebot swagger2 0.2 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-0.2 (NickolayKudasov)
16:49:47 <rh0gue> anyone know a good monadic joke?
16:50:35 <hpc> no, but i have an action that can produce some good ones
16:50:46 <cite-reader> *rimshot
16:51:06 <jle`> rh0gue: do you mean a joke involving monads, or a joke that is itself monadic?
16:51:26 <rh0gue> a joke involving monads jle` 
16:52:33 <jle`> a monadic joke would probably be one whhere you could comprehend the deeper meanings and then comprehend the surface meanings, or comprehend the surface meanings and then comprehend the resulting deeper meanings,and the result will be the same
16:53:04 <EvanR> one where any joke about a joke is itself a joke
16:53:21 <EvanR> about whatever the secondary joke is about
16:53:24 <lmj> What do monads and monoids have in common? Monds.
16:53:43 <dmj> > [1,2,3] & upon minimum +~ 1
16:53:45 <lambdabot>  [2,2,3]
16:53:52 <dmj> > [1,2,3] & upon maximum +~ 1
16:53:54 <lambdabot>  [2,2,3]
16:53:57 <dmj> derp
16:54:00 <hackrilege> Sorry i got disconnected
16:54:14 <jle`> dolio: i don't see it :|
16:55:35 <t4nk994> Hey guys. How do i show that if t_1 is alpha equivalent to t_2 then t_2 is also alpha equivalent to t_1 ?
17:02:15 <dolio> jle`: The idea was to conjure up, 'the intersection of all things such that I need two of them to produce a boolean.'
17:02:22 <dolio> But I don't think it's an idea that works.
17:09:40 <johnw> t4nk994: are you asking that in the context of code you're trying to write?  Equivalence relations are symmetric by definition.
17:12:52 <witt3rd> I'm trying to understand Control.Category.  If I understand correctly, it uses PolyKinds so that class Category (cat :: k -> k-> *) and id :: cat a a.  How do I properly inhabit id with my own instance?
17:13:38 <witt3rd> I can't manage to fabricate a data type that will work properly
17:14:49 <EvanR> witt3rd: you implement id by providing a value of type cat a a
17:15:44 <EvanR> first things first your type (cat) needs to take two params
17:16:16 <johnw> and that type needs a constructor for when its two arguments are the same type
17:16:18 <EvanR> second you need to be able to pull out of thin air a value which will work for any type a as the first and second arg
17:16:57 <johnw> http://qi.com/infocloud/shrimps
17:17:01 <johnw> sorry, wrong channel
17:18:37 <witt3rd> EvanR: ah. i think I may have been missing a constructor for the same type.  let me give it a go and I'll be back.  Thanks!
17:24:21 <hackrilege> It appears that foldable is a superclass of monad if >>= is written in terms of concatMap, is that correct?
17:25:36 <Hijiri> hackrilege: concatMap returns list, not the original Foldable
17:25:46 <dmj> hackrilege: list is Foldable as well as Monad, unsure if it would be considered a super class
17:26:04 <hackrilege> Hmm
17:26:23 <hackrilege> I don't want list
17:26:37 <hackrilege> I have a graph
17:26:56 <codebje> everything is a list, from a certain point of view
17:27:08 <EvanR> codebje: no!!
17:27:10 <lethjakman-l> Someone's a list programmer. 
17:27:12 <lethjakman-l> lisp
17:27:13 <hackrilege> Not a simply linked one
17:27:19 <dmj> you could represent a graph as an adjacency list
17:27:20 <Hijiri> functions from the real numbers are not a list
17:28:14 <hackrilege> Graphs can be represented as lists i guess, but i don't think i like that idea. It's more efficient as a tree
17:28:22 <hackrilege> Conceptually
17:28:23 <EvanR> fix ("everything is a "++)
17:28:39 <EvanR> graphs arent trees either
17:28:57 <hackrilege> Mine is a map which is a tree
17:29:02 * hackagebot yesod-raml-mock 0.1.1 - A mock-handler generator library from RAML.  https://hackage.haskell.org/package/yesod-raml-mock-0.1.1 (junjihashimoto)
17:29:04 * hackagebot yesod-raml-bin 0.1.2 - The raml helper executable.  https://hackage.haskell.org/package/yesod-raml-bin-0.1.2 (junjihashimoto)
17:29:32 <dmj> you could also use a matrix
17:29:47 <codebje> you say tree, I hear "nested lists"; you say matrix, I hear "nested lists" :-)
17:30:01 <codebje> ok, not helping, will pipe down
17:30:03 <EvanR> in the haskell sense of list, you cant make a tree that way
17:30:05 <dmj> haskell has arrays :)
17:30:08 <hackrilege> It would be a very sparse matrix
17:30:19 <EvanR> a list however is a degenerate tree
17:30:31 <hackrilege> It's best as a tree anyway it's fine
17:30:59 <codebje> EvanR, data Tree a = Tree a [Tree a], or similar
17:31:07 <EvanR> thats not a list, its a tree
17:31:27 <codebje> ah, you need a certain point of view, that's the get-out-of-jail disclaimer
17:31:51 <dolio> Hopefully none of your future employers are listening.
17:31:56 <hackrilege> Yes so not everything is lists at least, it's pointless to describe a graph as a map stored in a list, map is fastest over the tree representation, i mean Data.Map uses trees
17:32:04 <codebje> dolio, that becomes true the more I speak, right?
17:32:14 <dolio> Yes, I suppose so. :)
17:32:32 <EvanR> yeah the zeroth interview question is if you know the difference between a map and an array
17:32:45 <EvanR> and "no they are both lists" is not the answer ;)
17:33:49 <hackrilege> Anyway, im saying foldable looks like a superclass to monad as applicative and functor also are
17:34:15 <Hijiri> how would you make (e ->) a foldable?
17:34:28 <EvanR> not all monads are foldable-able
17:34:36 <hackrilege> OK
17:34:58 <hackrilege> But foldable applicative functors are monads?
17:35:37 <EvanR> how would you implement join?
17:35:51 <dolio> No.
17:36:12 <hackrilege> Via >>= and concatMap
17:36:31 <EvanR> well you cant just use >>=
17:36:47 <hackrilege> It's written in concatMap
17:37:03 <Hijiri> concatMap uses lists >>=
17:37:12 <EvanR> :t concatMap
17:37:14 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
17:37:25 <hackrilege> Hmm
17:37:44 <EvanR> concatMap for list uses >>= 
17:38:09 <hackrilege> Can i query lambdabot to find this source?
17:38:20 <Welkin> > concat . map (+1) $ [[1],[2],[3]]
17:38:22 <lambdabot>      No instance for (Show a0)
17:38:23 <lambdabot>        arising from a use of ‘show_M699105134712442683616145’
17:38:23 <lambdabot>      The type variable ‘a0’ is ambiguous
17:38:25 <Welkin> er
17:38:33 <dmj> @typ flip concatMap
17:38:34 <lambdabot> Foldable t => t a -> (a -> [b]) -> [b]
17:38:37 <Welkin> > concat . map (map (+1)) $ [[1],[2],[3]]
17:38:39 <lambdabot>  [2,3,4]
17:38:48 <Welkin> I thought concatMap was just concat . map
17:39:01 <Welkin> > concatMap (map (+1)) $ [[1],[2],[3]]
17:39:02 <EvanR> it is for lists
17:39:03 <lambdabot>  [2,3,4]
17:39:04 <hackrilege> No, i mean the implementation of >>= in List
17:40:08 <hackrilege> Id go to Data.List in hackage, but can i get lambdabot to generate a link?
17:41:45 <dmj> hackage: it's flip concatMap 
17:41:48 <dmj> hackrilege: ^
17:42:18 <dmj> auto complete made you 'hackage' :)
17:44:02 * hackagebot patches-vector 0.1.4.3 - Patches (diffs) on vectors: composable, mergeable, and invertible.  https://hackage.haskell.org/package/patches-vector-0.1.4.3 (LiamOConnorDavis)
17:44:26 <hackrilege> Im finding appEndo in Data.List.foldr along with mappend and mempty
17:44:42 <hackrilege> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html#foldMap
17:45:50 <codebje> Endo is the monoid of functions and .
17:45:55 <ryoshu> what's the minimal version of ghc to bootstrap ghc-7.10.2
17:46:10 <codebje> (functions which are endomorphisms, that is, have signature a -> a)
17:47:29 <hackrilege> Hmm, why functions at the heart of list?
17:47:59 <hackrilege> And this crazy foldr definition i linked above?
17:49:08 <hackrilege> Which, by the way, seems to be pretty often used, is that the case?
17:49:32 <ipdwht> Wow, Real World Haskell sucks.
17:49:50 <codebje> is foldr used often?
17:50:14 <P4Titan> Hello, is there a haskell function like scheme that takes a list and a function and passes the elements of the list as args to the fn?
17:50:20 <hackrilege> E.g. vector at its heart uses that definition of fold, which contains a #. I'm not to happy about...
17:50:59 <EvanR> foldr is awesome
17:51:26 <codebje> folds are a mainstay of higher-order programming, so a lot of stuff is built on it
17:51:29 <EvanR> P4Titan: no, that would not type check
17:52:00 <ipdwht> RWH Haskell is written as a pretty good book for reference, but I don't think that is it's purpose...
17:52:19 <codebje> because a lot of stuff is built on it, performance really matters, so #. is an optimisation
17:52:25 <codebje> you can just read it as '.'
17:52:32 <hackrilege> Yes i think concatMap used by >>= for lists uses foldable foldr
17:53:12 <codebje> P4Titan, you could probably have something with a specific length such as `apply :: (a -> b) -> [a] -> b ; apply f [x] = f x ; apply _ _ = error "partial function"`
17:53:22 <hackrilege> So basically this is the definition getting used by all lists as far as i can tell...
17:53:24 <codebje> but partial functions are generally not great to have
17:53:28 <codebje> (imo)
17:53:43 <EvanR> codebje: in which case youd just do a normal function application
17:54:07 <codebje> hackrilege: >>= in ghc prelude is a list comprehension, fwiw
17:54:13 <P4Titan> ok
17:54:16 <P4Titan> thanks tho
17:54:29 <codebje> so while it's semantically concatMap, it's not actually defined that way, because concatMap is in Data.List, not Prelude
17:54:43 <codebje> >>= for []
17:55:20 <hackrilege> I'm confused
17:55:32 <ipdwht> Really, I think Real World Haskell suffers from the same problems I think "Dive into Python" suffers from...
17:56:01 <ipdwht> "Oh, hey, just let me throw everything about the language at you, ask you to do 3 problems here and there, and, oh? You don't know how to program yet? lol it's because you're lazy, you have to work hard."
17:56:32 <hackrilege> I want to derive my foldable instance from >>= and not the other way round?
17:56:48 <ipdwht> Except so far... the Haskell community seems a lot more sympathetic about how hard Haskell is to learn...
17:57:06 <hackrilege> That's because it's awesome
17:57:07 <codebje> >>= is in the Monad type class, so unless you are only deriving foldable from monads, no, you don't want to use >>=
17:57:44 <codebje> haskell is chess
17:57:46 <hackrilege> I have a monad, is foldable a side effect or a requisite?
17:57:52 <codebje> simple rules, complex applications
17:57:55 <codebje> neither
17:58:06 <ipdwht> Except Chess has like 20 rules, Haskell has 200 rules...
17:58:13 <hackrilege> Which do i use to define the other?
17:59:06 <ipdwht> It doesn't help that Real World Haskell just throws 50 rules at you at a time, and expects you to understand how to apply them (let alone distinguish them).
17:59:14 <hackrilege> Who is boss, foldable applicative or monad? Which is the derived instance?
17:59:30 <codebje> all monads are applicatives, all applicatives are functors
17:59:36 <codebje> foldables are orthogonal
18:00:09 <hackrilege> So foldable monad is the required term?
18:00:16 <EvanR> hackrilege: type classes dont form this huge tree of life like in java
18:00:22 <codebje> that's a reasonable term, I think
18:01:09 <hackrilege> Are all foldable applicative monads though...
18:01:16 <dolio> No.
18:01:59 <micahf> hi :)  i'm wondering about how to describe the "traits" pattern in functional language
18:02:14 <codebje> ((,), a) is foldable, and applicative, but not a monad
18:02:33 <hackrilege> But i can define all the monad method instances from foldable applicatives...
18:02:51 <dolio> Doubt it.
18:03:12 <codebje> micahf, what's the "traits" pattern?
18:03:15 <hackrilege> Micahf, im not sure what the traits pattern is
18:03:15 <ipdwht> I think I just realized why programming language books all pretty much suck.
18:03:17 <dolio> At least, not in a way that will satisfy the required axioms.
18:03:31 <hackrilege> !?
18:03:34 <ipdwht> They're only good if you already know how to program in that paradigm.
18:04:01 <micahf> the "traits" pattern is a way of reusing functions between different types of objects
18:04:10 <micahf> it's kind of like "interfaces"
18:04:41 <hackrilege> return = pure; (>>=) = flip concatMap
18:05:02 <EvanR> ipdwht: even then, theyre not that great
18:05:21 <EvanR> hackrilege: type error
18:05:33 <codebje> hackrilege: try to make a monad of ((,), a)
18:05:44 <johnw> Sometimes a good book doesn't just give you knowledge; sometimes it sets the stage for just enough annoyance that when the knowledge comes, it's relevant.
18:05:55 <hackrilege> ...
18:06:06 <micahf> maybe i should just learn haskell, i think it'd help me understand functional programming in a deeper way
18:06:08 <micahf> ;D
18:06:19 <codebje> micahf, type polymorphism
18:06:19 <EvanR> :t flip concatMap
18:06:20 <johnw> micahf: if that's your goal, indeed you should
18:06:20 <lambdabot> Foldable t => t a -> (a -> [b]) -> [b]
18:06:25 <EvanR> :t (>>=)
18:06:26 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:06:38 <micahf> codebje: "type polymorphism" sounds about right
18:06:55 <codebje> micahf: see the definition of concatMap up there, it works for any "t" which is a Foldable, where Foldable defines a bunch of things you can do with a "t"
18:06:59 <codebje> :t (+)
18:07:00 <lambdabot> Num a => a -> a -> a
18:07:02 <ipdwht> micahf:  I'm learning Haskell, now! It's going to teach you a lot more than just functional programming!
18:07:10 <EvanR> hackrilege: your version returns a list
18:07:18 <EvanR> not m
18:07:27 <micahf> well i just think it'd help me code more in tune with the way i think
18:07:37 <micahf> but i want to apply it to javascript
18:07:37 <hackrilege> michahf, i think haskells class definitions are the abstract interface of java!?!?!
18:07:43 <codebje> micahf: addition is defined for any type which is a Num, where being a Num means implementing certain functions and obeying certain axioms
18:07:45 <micahf> because i like the web
18:07:54 <EvanR> hackrilege: nah
18:08:09 <hackrilege> Close?
18:08:14 <EvanR> no
18:08:27 <codebje> micahf: javascript can benefit from understanding many of the concepts in functional programming
18:08:53 <hackrilege> It's abstract in that the type definition is not given an implementation
18:09:12 <codebje> but do beware javascript has an impedance mismatch, such as when you use the Promises monad in JS, the exception handling mechanisms of JS are no longer useful
18:09:39 <micahf> codebje i read that epic discussion that resulted in "fantasyland"
18:09:43 <hackrilege> An interface is an entirely abstract class? Oh i can't remember java, sorry.
18:09:48 <nolraiU> hackrilege: yes, they are close, the big differnce is that the dictionaries aren't attached to an object, and are often decided at compile time.
18:10:02 <ipdwht> I knew some javascript before... but now that I'm learning Haskell, I think going back to Javascript is going to really piss me off. :\
18:10:03 <micahf> it was all about promises
18:10:11 <codebje> hackrilege: an 'interface' is what you get when multiple inheritance scares you; just read it as "abstract class"
18:10:29 <hackrilege> Ok that makes sense
18:10:46 <EvanR> abstract class is pretty confusing terminology for haskell
18:11:18 <codebje> yes, it is :-)
18:11:21 <hackrilege> Foot me that feels a lot like what Haskell's class definition syntax provides, and might be the right thing for micahf, in not sure though
18:11:21 <codebje> not applicable.
18:11:23 <EvanR> hackrilege: you can get the oop interface pattern by using a record type where the members are functions
18:11:32 <hackrilege> Omg
18:11:45 <hackrilege> What's a record type?
18:12:00 <nolraiU> Just a product type.
18:12:01 <codebje> data Foo = Foo { getBar :: String, getBaz :: Int }
18:12:07 <nolraiU> With sugar.
18:12:16 <micahf> hackrilege what's foot me?
18:12:19 <codebje> a syntax for data declarations where the subtypes can be accessed witha  function
18:12:26 <hackrilege> For me, sorry
18:13:00 <EvanR> for stuff like this type classes will most of the time be more klunky
18:13:18 <hackrilege> No, it's the oop paradigm
18:13:24 <EvanR> NO U
18:13:25 <micahf> ah
18:13:34 <codebje> micahf: the general need to have oop's abstract class mechanism is reduced in the presence of higher order functions
18:13:46 <hackrilege> It's very intuitive for some
18:14:02 <codebje> micahf: you can focus on building the data types you need, and there's a whole stack of general purpose functions which will work for them more or less out of the box
18:14:05 <EvanR> its pretty intuitive either way
18:14:07 <micahf> yeah it sounds like types themselves are a lot like traits
18:14:09 <EvanR> just one way is better
18:14:41 <EvanR> types arent like traits
18:14:43 <hackrilege> Pattern matching on datatypes might be worth looking into
18:15:03 <hackrilege> But I'm not really sure what traits are
18:15:38 <codebje> traits are just another term for interfaces for some OO languages other than java
18:15:42 <EvanR> traits is like mixins is like interfaces
18:15:43 <codebje> scala uses the term, eg
18:16:05 <micahf> EvanR: this sounded a lot like traits: "addition is defined for any type which is a Num, where being a Num means implementing certain functions and obeying certain axioms"
18:16:17 <codebje> I think it appears in C++ nomenclature, but C++ is a boundless plain of syntactic oddities
18:16:26 <tzh> i guess both typeclasses and higher-level functions are "like" traits for certain aspects of traits
18:16:29 <hackrilege> He wants class!
18:16:34 <micahf> haha
18:16:35 <EvanR> micahf: well youre back to the idea that interfaces are like type classes (not types)
18:16:55 <EvanR> which i was saying is better done with record types
18:17:16 <hackrilege> Which we didn't get to the bottom of
18:17:53 <hackrilege> What are these record types? Where the members are functions
18:17:57 <codebje> in OO languages, your primary weapon of choice is object-level polymorphism; you'll define abstract interfaces as the call boundaries between bits of code, and implement concrete instances of those interfaces
18:18:12 <micahf> this is a fun discussion
18:18:21 <EvanR> hackrilege: maybe look at a tutorial on records
18:18:24 <codebje> in Haskell, your primary weapon of choice is higher-order programming; you define the types which contain the data you need, and re-use standard functions on them
18:18:42 <Hijiri> using record types like objects is sort of how you do objecty things in C, except you have access to nice-to-use closures and type safety and things, so there is a lot more you can store in the background
18:18:46 <hackrilege> Classes are very powerful in Haskell
18:18:53 <codebje> so where you might define a Value interface in Java with getters on it, in Haskell you'd define a record type
18:19:23 <codebje> you wouldn't try to bundle up behaviour and data together
18:19:30 <hackrilege> Can't you do one in lambdabot?
18:19:45 <codebje> :t data Foo = Foo { getBar :: String, getBaz :: Int }
18:19:46 <EvanR> better lpaste
18:19:47 <lambdabot> parse error on input ‘data’
18:19:49 <codebje> bah
18:20:01 <codebje> let data Foo = Foo { getBar :: String, getBaz :: Int }
18:20:18 <hackrilege> OK, that's a record?
18:20:21 <codebje> that
18:20:25 <EvanR> thats a record
18:20:27 <codebje> Foo is a record
18:20:33 <codebje> > let data Foo = Foo { getBar :: String, getBaz :: Int }
18:20:35 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
18:20:57 <codebje> > let data Foo = Foo { getBar :: String, getBaz :: Int } deriving Show in Foo "hello" 42
18:20:58 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
18:21:01 <hackrilege> That is just a data type
18:21:04 <codebje> yeah, I'm way off
18:21:12 <EvanR> wrong syntax in many ways
18:21:14 <codebje> I thought I could define types for lambdabot but now I'm in let syntax
18:21:21 <codebje> please excuse, have spent morning in java lnad
18:21:31 <hackrilege> Nvm
18:21:39 <codebje> > data Foo = Foo { getBar :: String, getBaz :: Int }
18:21:40 <codebje> :t Foo
18:21:41 <lambdabot>  <hint>:1:1: parse error on input ‘data’
18:21:42 <lambdabot> Not in scope: data constructor ‘Foo’
18:21:44 <codebje> no, it won't let me
18:21:59 <monochrom> record types have always been special cases of data types. since Algol 60.
18:22:23 <hackrilege> That's the big spider off harry potter
18:22:33 <Hijiri> @letlpaste 144971
18:22:33 <lambdabot>  Parse failed: Parse error: virtual }
18:22:36 <caconym> do a lot of people use stack? i'm reading about it now, particularly interested in its dockerizing features
18:22:41 <codebje> anyway, that declaration creates a type called Foo, a type constructor Foo :: String -> Int -> Foo, and two utility functions getBar :: Foo -> String and getBaz :: Foo -> Int
18:23:04 <Hijiri> @let data ThingEater a = Trigger
18:23:06 <lambdabot>  Defined.
18:23:10 <Hijiri> wait no
18:23:17 <Hijiri> @undefine
18:23:17 <lambdabot> Undefined.
18:23:30 <hackrilege> Poor lambdabot
18:23:31 <Hijiri> @let data ThingEater a = Trigger { eat :: a -> (a, ThingEater a) }
18:23:32 <codebje> so ```let eg = Foo "hello" 42 in getBar eg``` would produce "hello"
18:23:32 <lambdabot>  Defined.
18:23:37 <codebje> ahha, @let
18:23:49 <codebje> @let data Foo = Foo { getBar :: String, getBaz :: Int }
18:23:50 <lambdabot>  Defined.
18:23:51 <codebje> :t Foo
18:23:53 <lambdabot> String -> Int -> Foo
18:23:54 <codebje> :t getBar
18:23:56 <lambdabot> Foo -> String
18:24:02 <Hijiri> @let yum :: NumberEater a; yum = const ("Yum!", yum)
18:24:03 <lambdabot>  .L.hs:150:8: Not in scope: type constructor or class ‘NumberEater’
18:24:05 <codebje> > let eg = Foo "hello" 42 in getBar eg
18:24:06 <lambdabot>  "hello"
18:24:09 <codebje> there we go
18:24:18 <Hijiri> @let yum :: ThingEater a; yum = Trigger $ const ("Yum!", yum)
18:24:19 <lambdabot>  .L.hs:151:7:
18:24:19 <lambdabot>      Couldn't match type ‘a’ with ‘[Char]’
18:24:19 <lambdabot>        ‘a’ is a rigid type variable bound by
18:24:20 <hackrilege> Ok
18:24:27 <Hijiri> ok, maybe I should stop
18:24:36 <Hijiri> oh, I defined it differently
18:24:41 <Hijiri> maybe I can just get the lpaste to work
18:24:43 <hackrilege> Yeah it's pretty intense
18:24:45 <codebje> hackrilege: you can also pattern match using the record syntax
18:25:11 <Hijiri> @letlpaste 144971
18:25:11 <lambdabot>  Parse failed: Parse error: virtual }
18:25:23 <hackrilege> Ohhhhh it's the curly braces
18:25:27 <Hijiri> I don't know what that means
18:25:36 <micahf> has anyone seen fantasyland?  in haskell would you implement the structures of fantasyland using "classes"?
18:25:47 <codebje> > let eg = Foo "hello" 42 in let { getBar = a, getBaz = b } = eg in (a, b)
18:25:48 <lambdabot>  <hint>:1:44: parse error on input ‘,’
18:25:50 <codebje> did I get that right?
18:25:51 <codebje> no.
18:25:51 <hackrilege> Right, defining destructors is called record syntax
18:25:54 <monochrom> I have not heard of fantasyland.
18:26:28 <hackrilege> It's next to Disneyland and google land
18:26:53 <Hijiri> @let addNumber x = Trigger $ \y -> (x + y, addNumber (x + y))
18:26:54 <lambdabot>  Defined.
18:26:59 <monochrom> Hijiri: where is NumberEater defined?
18:27:05 <Hijiri> oh
18:27:07 <codebje> https://github.com/fantasyland/fantasy-land
18:27:09 <codebje> that?
18:27:10 <Hijiri> can't believe I missed that
18:27:12 <micahf> yeah
18:27:27 <micahf> this guy named puffnfresh tried to convince the EcmaScript people that promises are monads and should be implemented with that in mind
18:27:44 <EvanR> hackrilege: http://lpaste.net/144972
18:27:49 <codebje> so javascript can say that a monad is just a monoid in the category of endofunctors, too?
18:27:51 <hackrilege> Promises are monads OK
18:27:59 <micahf> and one guy kept saying puffnfresh lived in a fantasy land for that one
18:28:02 <codebje> null/undefined aside, yes
18:28:30 <dolio> I'd rather live in fantasy land than write all my code explicitly in continuation passing style.
18:28:32 <micahf> and basically was trying to quiet him up
18:28:52 <dolio> But apparently I'm in the minority.
18:28:55 <Hijiri> hackrilege: in the non-lpaste version I was defining in here, "ThingEater a" is like an interface with one method that takes an "a" as input and gives an "a" back, then mutates itself (actually just returns the new version)
18:29:10 <EvanR> promises (js version) are the only sane way to basically do normally blocking style IO in js
18:29:12 <monochrom> yes, I would use Haskell type classes for Monoid, Foldable, Functor, etc., of fantasyland. in fact, not just me, but also the people who ordained the standard libraries of Haskell too. find them in the Prelude.
18:29:14 <hackrilege> Ok
18:29:18 <Hijiri> so you would never define any OOP classes that inherit/implement the interface, you just directly construct things that fit it
18:29:36 <micahf> monochrom: cool, that really helps me understand what classes are in FP
18:29:39 <monochrom> however, I would not translated javascript code to Haskell.
18:29:40 <micahf> er, in haskell
18:29:45 <Hijiri> So "addNumber" is like a constructor for a version that just keeps an internal number state, and adds it to your input
18:30:00 <EvanR> hackrilege: see my circle ellipse examplee
18:30:05 <micahf> in haskell classes are more like compositions of functions
18:30:13 <micahf> is ^^^ that fair?
18:30:29 <codebje> EvanR, there's very little blocking IO in JS to start with, Promises escape callback hell with a composable alternative, but it lacks for an ErrorT transformer, and in an imperative language like JS it would still be better to use actors and just block
18:30:31 <Hijiri> instead of keeping that number as a member of some class though, you just pass it in as part of the function
18:30:38 <codebje> but that latter option is not on the cards at all :-)
18:30:41 <hackrilege> I get record syntax, and apparently this is providing better notion of traits because it's more about constructors and destructors than functions on the object?
18:30:41 <monochrom> I don't know. see my http://www.vex.net/~trebla/humour/tautologies.html #0
18:30:52 <micahf> haha
18:31:04 <Hijiri> this isn't particularly about constructors
18:31:10 <EvanR> codebje: there is a lot of IO in js, and the fact that you cant block is what sucks
18:31:16 <Hijiri> so the way to sort of translate an interface to a record would be
18:31:22 <Hijiri> to take all the methods and just put them in the record
18:31:32 <codebje> evanR, very little _blocking_ IO.  lots of IO, yes.
18:31:34 <EvanR> codebje: i dont see how actors will really help that, and this is a horrible place to discuss it
18:31:49 <Hijiri> and when you want to make something an "instance" of the "interface", you just make a function that handles all the things that would be member data in an OOP language as part of the functions
18:31:51 <EvanR> codebje: yeah, IO that would be easier with blocking
18:31:56 <hackrilege> No, only the accessor's should go in the record
18:32:04 <Hijiri> no, mutators go in there too
18:32:12 <codebje> EvanR, agreed
18:32:15 <Hijiri> everything about the interface goes in the record
18:32:16 <micahf> i'm just gonna have to learn haskell
18:32:24 <codebje> micahf: me too, some day
18:32:27 <hackrilege> The other methods providing the interface would go in a class the data type instantiates
18:32:40 <EvanR> codebje: but in js, blocking has come to imply blocking everything in the entire browser / runtime
18:32:46 <Hijiri> are we still talking about the record encoding of interfaces?
18:32:49 <Welkin> micahf: codebje if you are in this channel, how are you *not* learning haskell?
18:32:52 <EvanR> as if blocking your process blocks the entire OS
18:33:10 <EvanR> which obviously shouldnt imply that
18:33:12 <micahf> :)
18:33:12 <tzh> if you want mutators for your records you can just use lenses, but that's a whole other can of worms
18:33:20 <micahf> well i've learned a lot already
18:33:28 <micahf> i was hoping to learn functional programming with javascript
18:33:32 <micahf> but it's so tedious
18:33:38 <Welkin> lol, that won't happen
18:33:50 <Welkin> it is not "functional programming" in any recognizable way
18:33:55 <Welkin> to me at least
18:34:03 <hackrilege> I'm saying if interfaces have mutators, these should be placed in the class definition which the record instantiates, do i have an error?
18:34:06 <codebje> EvanR, lightweight threads with no shared global state is my preferred solution for imperative async, but that's not even on the horizon for JS
18:34:24 <Hijiri> hackrilege: the record doesn't instantiate anything
18:34:25 <Cale> You can try to think in Haskell and program in Javascript, but it will likely be an infuriating experience and you will end up working on GHCJS instead.
18:34:31 <Hijiri> the record is just there, it doesn't need to be in a type class
18:34:41 <hackrilege> ...
18:34:47 <EvanR> hackrilege: yeah you have an error
18:34:56 <Cale> Because why write that disfigured code by hand when you can program a computer to do the disfiguring for you? :)
18:35:00 <tzh> a record is just data; you can make it have functions as data, but then those aren't mutators, they're just stored data that happen to be functions
18:35:03 <micahf> is there a haskell class that plays off of the idea of homomorphism/isomorphism? 
18:35:11 <Hijiri> I meant mutator as in something that gives you the new version
18:35:16 <hackrilege> I thought we were explicitly referring to record as curly braces in a data declaration
18:35:25 <Cale> micahf: Well, homomorphisms between Haskell types are simply functions.
18:35:25 <Hijiri> that's what I'm referring to as record
18:35:30 <hackrilege> Cool
18:35:35 <Cale> micahf: (Haskell-definable functions)
18:35:44 <Hijiri> well not the curly braces in particular, but the whole data type
18:35:55 <hackrilege> Ok
18:35:55 <EvanR> error: Haskell-definable not defined
18:36:03 <Hijiri> it doesn't necessarily have to be written with record syntax either, it's just often convenient
18:36:21 <Cale> micahf: There's probably a type for isomorphisms hanging around somewhere. There's some stuff in lens, but it's going to be a bit weirdly structured to fit into that framework.
18:36:53 <EvanR> an isomorphism would be better with dependent types
18:36:56 <Cale> (isomorphisms as in definable functions with definable inverses)
18:36:59 <hackrilege> Ok, so can we not just call them datatypes? Rather than record, which implies something other that record=datatype
18:37:07 <micahf> hey thanks everyone for entertaining my attempts to make sense of the world
18:37:11 <Hijiri> ok, we can call it data type, then
18:37:13 <micahf> i appreciate it
18:37:17 <Cale> Yeah, it's hard to ensure that the two functions as given really are inverses
18:37:21 <EvanR> hackrilege: record implies exactly records
18:37:27 <EvanR> not something else
18:37:34 <hackrilege> Right
18:37:35 <micahf> i made a "class" called "animorphism"
18:37:37 <EvanR> data types might not be records
18:37:46 <hackrilege> No accessor's
18:37:47 <micahf> based off of the idea of animorphs
18:38:00 <Hijiri> accessors would just be the data you want
18:38:02 <micahf> you supply it with a transformation and its inverse
18:38:04 <dolio> Welkin: All modern javascript is written in continuation passing style, so it can teach you some important ideas about functional programming.
18:38:11 <Hijiri> and you would just put that in the type
18:38:19 <dolio> The secret is to not tell people they're doing it, apparently.
18:38:21 <Hijiri> as part of the data
18:38:49 <Hijiri> you put everything that would be in an interface definition in an OOP language
18:38:49 <EvanR> hopefully js will gain support for special syntax that makes CPS easy to type
18:38:55 <micahf> so if you wanted to wag a human's tail, you could transform it into a dog first, wag the dog's tail, then transform it back into a human, a la animorphs
18:38:59 <Hijiri> except maybe inheritance declarations
18:39:03 <EvanR> perhaps it will look similar to normal C-style syntax
18:39:07 <Hijiri> but all the methods
18:39:08 <micahf> that strikes me as being very functional
18:39:10 <hackrilege> I can define accessor's from pattern matching implicitly, how is record an explicit extension other than syntax?
18:39:12 <codebje> EvanR: isn't that ClojureScript? :-)
18:39:18 <micahf> (maybe nobody besides me has read animorphs)
18:39:22 <Hijiri> extension to what?
18:39:30 <EvanR> we wont talk of clojurescript
18:39:34 <Hijiri> there's nothing special about record syntax
18:39:37 <dolio> EvanR: Maybe you could put 'do' before blocks of CPSed stuff.
18:39:46 <EvanR> yes
18:39:48 <monochrom> is that why it is called animorphism? to transform to/from animals?
18:39:51 <Hijiri> we're just talking about how to do something similar to an interface using records/product types
18:40:16 <micahf> well, there was a series of kids sci fi books where the kids could transform into animals in order to gain special abilities and save the world from evil aliens
18:40:17 <hackrilege> EvanR, is Hijiri contradicting you? I'm confused
18:40:23 <micahf> it was called "animorphs"
18:40:24 <monochrom> can I also have aminorphisms, which means transform to/from aminals? because I love aminals
18:40:27 <EvanR> hackrilege: about what
18:40:39 <hackrilege> (Hijiri) there's nothing special about record syntax
18:40:46 <EvanR> right
18:40:50 <hackrilege> (EvanR) hackrilege: record implies exactly records
18:40:53 <EvanR> you can use product types
18:41:03 <EvanR> but the top here does not include sum types
18:41:15 <micahf> monochrom: is this the kind of thing you would do in haskell? https://github.com/timbresmith/animorphism
18:41:20 <micahf> or is it just silly
18:41:34 <EvanR> topic*
18:42:02 <hackrilege> What are product and sum types?
18:42:15 <EvanR> (a,b) is a product type
18:42:23 <EvanR> Either a b is a sum type
18:42:43 <hackrilege> Hmm
18:42:46 <hackrilege> Ok
18:42:47 <c_wraith> hackrilege: thing about what they do to the number of elements of the type
18:43:11 <codebje> if you think of a type 'a' as being the set of all possible values in that type, then the type (a, b) contains the set of every element of 'a' for every element of 'b' - a cartesian product
18:43:15 <c_wraith> in (a, b), you have |a| * |b| possible values.  In Either a b, you have |a| + |b| possible values
18:43:20 <hackrilege> I can have n^2  of both
18:43:30 <codebje> whereas the type Either a b contains the set of every element of 'a' and every element of 'b', the set union
18:43:31 <monochrom> micahf: I am uncomfortable with the string parameter 'cow'
18:44:06 <EvanR> copy on write?
18:44:29 <c_wraith> You don't write to strings very often in haskell.
18:44:45 <codebje> const cow = Symbol();
18:44:55 <EvanR> animorphs may in fact be attempting to
18:45:04 <micahf> ah, yeah i should change that
18:45:16 <hackrilege> Aha so record syntax has sum type not product type?
18:45:24 <codebje> record syntax is product type
18:45:28 <c_wraith> Record syntax describes a product.
18:45:29 <EvanR> exactly... the opposite
18:45:31 <micahf> or maybe morphToCow()
18:45:34 <hackrilege> Oh, close though
18:45:44 <hackrilege> Awesome
18:45:49 <c_wraith> However, you can have a sum of record constructors. >_>
18:45:55 <EvanR> good job you are getting it
18:45:57 <c_wraith> (don't do that.  It makes your accessors partial)
18:46:15 <codebje> it's a datatype which conveniently creates a few accessor functions to extract values from the type
18:46:16 <EvanR> yeah record sums suck
18:46:25 <codebje> :t Foo
18:46:26 <lambdabot> String -> Int -> Foo
18:46:42 <codebje> given: let data Foo = Foo { getBar :: String, getBaz :: Int }
18:46:52 <EvanR> we covered that for hackrilege already
18:46:58 <tabemann> with records I'm in the habit of creating an abbreviated version of the type name and tacking it onto each record
18:47:12 <codebje> we could just as easily have done: data Foo = Foo String Int; getBar (Foo a _) = a; getBaz (Foo _ a) = a;
18:47:19 <c_wraith> tabemann: it's like the revenge of hungarian notation
18:47:57 <hackrilege> I'm still not sure of i should make monad out foldable my parent instance
18:47:59 <EvanR> intSucc intZero intNeg intAbs ;)
18:48:05 <hackrilege> Or
18:48:09 <tabemann> well I need to do it in my current project because I'm putting *all* my type definitions in one huge module (to allow cycles and like)
18:48:21 <c_wraith> tabemann: just wait until ghc 8!
18:48:21 <EvanR> hackrilege: nah, you cant do that
18:48:55 <tabemann> and there's so many records with similar names that I need to tag them with the type, but at the same time tagging them with the full type name would be way too lengthy (especially since many of my type names are pretty damn long already)
18:49:05 * hackagebot sbv 5.4 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.4 (LeventErkok)
18:49:27 <hackrilege> Why?
18:49:38 <Hijiri> tabemann: a lot of my types have names with two CapitalLetters, so I just use those letters as the prefix
18:49:47 <EvanR> hackrilege: because the types dont match up
18:49:59 <Hijiri> I don't know if that's a good idea though, I will probably forget what td means if it isn't obvious from context
18:50:03 <hackrilege> What's missing?
18:50:13 <EvanR> hackrilege: >>=
18:50:30 <hackrilege> Join = pure
18:50:36 <EvanR> exactly
18:50:37 <monochrom> hmm, are Chinese characters considered capital so that you can use them in type names?
18:50:38 <EvanR> wrong
18:50:43 <hackrilege> Oh
18:51:06 <c_wraith> tabemann: https://mail.haskell.org/pipermail/ghc-devs/2015-November/010340.html suggests you can name fields the same thing in ghc 8.  with an appropriate extension.
18:51:13 <c_wraith> monochrom: ask lambdabot
18:51:18 <Hijiri> > isUpper 人
18:51:20 <lambdabot>  Not in scope: ‘人’
18:51:23 <Hijiri> > isUpper '人'
18:51:24 <lambdabot>  False
18:51:31 <Hijiri> > isLower '人'
18:51:32 <lambdabot>  False
18:51:35 <EvanR> lol
18:51:39 <Hijiri> stuck between two worlds
18:51:49 <EvanR> excluded middle
18:51:55 <monochrom> too bad, so Chinese characters are good for type variables only
18:52:08 <c_wraith> Dunno.  They appear to not be lowercase either.
18:52:14 <monochrom> type G 人 = [人]
18:52:21 <EvanR> monochrom: try it, it might work anyway
18:52:32 <EvanR> would be silly to make that restriction when capital does not apply
18:52:34 <monochrom> I just did in my own ghci. it's ok
18:53:14 <pacak> >  let a ☭ b = a + b in 1 ☭ 3
18:53:15 <lambdabot>  4
18:53:23 <micahf> lol
18:53:34 <tabemann> now, we don't want to go the way of Agda, do we?
18:53:36 <EvanR> they call that "new math"
18:54:15 <EvanR> unicode consortium is a bunch of commies, i knew it
18:54:35 <monochrom> naw, they are a bunch of emojis
18:54:43 <monochrom> or emojies, if you like
18:54:54 <EvanR> i dont
18:54:54 <micahf> former emos
18:54:59 <codebje> CJK is unicameral; not all alphabets have cases
18:55:02 <hackrilege> LiftM = join
18:55:09 <micahf> then they grew up and got real jobs @ unicode consortium
18:55:13 <Hijiri> liftM = fmap
18:55:28 <hackrilege> Oh yeh.. Oops
18:55:43 <monochrom> my favourite emoji is U+1F608 😈 because I am both happy and evil
18:55:57 <codebje> > isUpper '😈'
18:55:59 <lambdabot>  False
18:56:08 <codebje> you can't be happily evil as a type
18:56:19 <tabemann> yes this is what we are wasting our precious unicode codepoint space on - emojis
18:56:27 <monochrom> you can use it for infix operator names
18:56:47 <monochrom> there is also one for banana, if you need it
18:56:48 * tabemann begs to differ on the happily evil part
18:56:50 <EvanR> yes fuck emojis
18:56:59 <codebje> (the real shit with unicode cases is 'i', which doesn't actually have an unambiguous case conversion)
18:57:23 <EvanR> > toUpper 'i'
18:57:25 <lambdabot>  'I'
18:57:29 <tabemann> thanks to Turkish orthography
18:57:37 <codebje> tabemann, exactly
18:57:43 <pacak> monochrom: Like one that replaces ';' with  ';'
18:57:46 <hackrilege> Join= fold concat
18:57:57 <EvanR> map = join fold
18:58:00 <codebje> > toUpper 'ı'
18:58:02 <lambdabot>  'I'
18:58:19 <tabemann> > toLower 'I'
18:58:21 <lambdabot>  'i'
18:58:30 <tabemann> > toLower 'İ'
18:58:31 <lambdabot>  'i'
18:58:32 <hackrilege> EvanR, no way!?
18:58:51 <EvanR> hackrilege: your exercise to verify or disprove
18:59:06 <monochrom> I have a cunning plan. toUpper should use unsafePerformIO and randomization underneath so it can non-deterministically give you a capitalization of i  😈
18:59:22 <nolraiU> :t toUpper
18:59:23 <lambdabot> Char -> Char
18:59:39 <EvanR> � is diamond ? for me
18:59:42 <nolraiU> Whats the character thats getting printed as 'False'?
19:00:00 <hackrilege> Cannot construct infinite type
19:00:36 <EvanR> yes infinite types are not allowed
19:01:03 <hackrilege> :t fold concat
19:01:04 <lambdabot> (Foldable t, Foldable ((->) (t [a]))) => [a]
19:01:08 <codebje> there was an emoji character ~25 lines ago
19:01:21 <codebje> a purple head
19:02:13 <monochrom> yes, it's the evil smile I said I like
19:02:20 <nolraiU> > 24 `div` 3
19:02:20 <Denommus> so, I just realized OOP is just a StateT s IO a, where s is a lens
19:02:22 <lambdabot>  8
19:02:45 <hackrilege> Lol, concat = foldl1 (:)
19:02:57 <EvanR> @src concat
19:02:57 <lambdabot> concat = foldr (++) []
19:03:17 <hackrilege> Man in off sorts today
19:03:19 <EvanR> > foldl1 (:) []
19:03:20 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
19:03:21 <lambdabot>      Expected type: [a] -> [a] -> [a]
19:03:21 <lambdabot>        Actual type: a -> [a] -> [a]
19:03:25 <monochrom> I don't believe that foldl1 (:) cuts it.
19:03:33 <Axman6> Denommus: I don't think that's right - lenses have no state
19:03:49 <Axman6> unless I'm thinking about this wrong
19:03:49 <hackrilege> Anyway join = concat
19:03:56 <Denommus> Axman6: the state isn't in the lens, the state is in StateT
19:04:14 <Denommus> Axman6: the lenses are just a convenient way to access the properties on the state inside the StateT
19:04:26 <Axman6> right, so s isn't a lens, it has lenses?
19:04:31 <EvanR> join [[1,2],[3,4]]
19:04:35 <EvanR> > join [[1,2],[3,4]]
19:04:36 <tabemann> > foldl' (flip (:)) [] [0,1,2,3]
19:04:37 <lambdabot>  [1,2,3,4]
19:04:37 <lambdabot>  [3,2,1,0]
19:04:38 <Denommus> Axman6: s is a lens
19:04:57 <Denommus> Axman6: the StateT s IO a has a lens, which is the hidden state of type s
19:05:26 <hackrilege> Nice
19:05:29 <Denommus> Axman6: sadly, you'll have to manually put and take stuff
19:05:36 <Axman6> I don't think that makes sense...
19:06:01 <EvanR> ReaderT over IO is a "convenient" way to access mutable refs 
19:06:06 <hackrilege> So with cons and fold i have a monad
19:06:20 <EvanR> hackrilege: only for lists
19:06:46 <EvanR> not any monad
19:07:00 <Denommus> Axman6: say, s is (String, String). You'll have a StateT (String, String) IO a. That's the return type of the "methods" of your object
19:07:24 <hackrilege> What class is Cons a method of?
19:07:42 <EvanR> none
19:07:48 <hackrilege> !?
19:07:56 <EvanR> :t (:)
19:07:57 <lambdabot> a -> [a] -> [a]
19:08:00 <Denommus> Axman6: you'll be able to freely take >>= put . set _2 "foo" inside the "methods" of your object
19:08:07 <monochrom> a data constructor is not a class method
19:08:13 <monochrom> at least, name-wise
19:08:20 <hackrilege> Yes, this is good
19:08:21 <Denommus> :t take >>= put . set _2 "foo"
19:08:22 <lambdabot>     No instance for (MonadState s0 ((->) Int))
19:08:22 <lambdabot>       arising from a use of ‘put’
19:08:22 <lambdabot>     In the first argument of ‘(.)’, namely ‘put’
19:08:40 <hackrilege> I get errors about constructors
19:09:22 <monochrom> this is what's wrong with working at the level of "___ is like ___". you start mixing up everything and never getting the approval of the discerning computer.
19:09:32 <hackrilege> I can't seem to pattern match with my own infix functions acting as (:)
19:09:56 <Denommus> Axman6: woops, I said "take", it was "get"
19:10:03 <Denommus> :t get >>= put . set _2 "foo"
19:10:04 <lambdabot> (Field2 s s a [Char], MonadState s m) => m ()
19:10:25 <hackrilege> What is a constructor and how do i define them?
19:10:44 <EvanR> scroll back to the examples
19:10:59 <monochrom> when you define a data type, you define its data constructors alongside.
19:11:20 <monochrom> and that's the only place where you define data constructors.
19:12:14 <hackrilege> Ok
19:12:33 <hackrilege> So i should find (:) defined alongside List
19:12:46 <Denommus> Axman6: gosh, you could even do { x <- liftIO getLine; get >>= put . set _2 x }
19:12:47 <EvanR> @src []
19:12:47 <lambdabot> data [] a = [] | a : [a]
19:13:00 <monochrom> no, not List. []. it's called []. it is not called List.
19:13:35 <qfjp> I've got a (possibly silly) question about category theory
19:14:10 <hackrilege> Hoogle is not helping
19:14:13 <qfjp> is it fair to say that 'Functor' in haskell is really an endofunctor, since fmap requires both categories to be Hask?
19:14:31 <Hijiri> yes
19:14:33 <Denommus> qfjp: yes
19:14:47 <monochrom> absolutely
19:15:37 <tabemann> <hackrilege> I can't seem to pattern match with my own infix functions acting as (:) < that's because they aren't data constructors
19:16:05 <hackrilege> It returns list of a from a and is a constructor of list of a
19:17:07 <hackrilege> So the trick is to define infix data constructors. Wow that intuitive gap was deep and old thanks
19:18:07 <hackrilege> Ok so with fold and a constructor i can define join
19:18:34 <hackrilege> ?
19:20:00 <nshepperd> I guess you could also say that a Functor maps Hask to a subcategory of Hask?
19:20:19 <kadoban> hackrilege: For lists? Yeah.
19:20:31 <shachaf> The image of a Functor isn't the entire category, sure.
19:21:05 <qfjp> but an endofunctor doesn't need to be total, right?
19:21:19 <shachaf> What does it mean for it to be total?
19:22:04 <hackrilege> Kadoban, i meant the constructor of a different datatype
19:22:06 <nolraiU> qfjp: The Functor typeclass is for total ones.
19:22:23 <nshepperd> I think you're thinking of 'surjective'
19:22:48 <nshepperd> mappings are usually total
19:24:15 <glguy`> shachaf: 100% daily value of at least 11 vitamins and minerals
19:24:45 <hackrilege> Kadoban, I'm trying to find a minimal set of classes whose methods are sufficient to provide an instance of monad
19:24:59 <shachaf> glguy`: Oh, I thought those were called complete functors.
19:25:02 <nshepperd> what I meant was, you can consider the subcategory of lists (say) as distinct from Hask itself, and say the list Functor maps Hask to that
19:25:30 <nshepperd> I guess you don't get much mileage out of doing that though, since you can make a subcategory out of any random collection of objects
19:25:42 <shachaf> nshepperd: Of course that functor isn't surjective onto the full subcategory of lists.
19:26:20 <shachaf> (On arrows, that is.)
19:26:36 <dolio> shachaf: Total means there's a left adjoint to the yoneda embedding.
19:26:40 <dolio> :)
19:26:47 <nshepperd> er, list types, I mean
19:27:32 <qfjp> sorry, looks like time warner is giving me trouble
19:28:01 <shachaf> dolio: Yoneda embedding of a functor?
19:28:23 <dolio> No. It's an unrelated definition.
19:28:34 <dolio> A total category is one such that ...
19:29:23 <dolio> Hask is total and cototal.
19:30:07 <qfjp> er, i guess i meant surjective?
19:30:07 <qfjp> but i don't know if thats the right term for morphisms
19:30:32 <hackrilege> So i think i can write an instance of monad for list in terms of a foldable applicative monad
19:30:58 <qfjp> hold on, before I lose connection again
19:31:05 <qfjp> cause it seems like i'm missing most of this conversation
19:31:05 <Lokathor> so when building stack, the stack.cabal has -threaded and -rtsopts
19:31:16 <Lokathor> but will it not run multi-core by default?
19:31:20 <qfjp> would I be correct in assuming that functors in haskell are actually endofunctors?
19:31:28 <Lokathor> isn't the default cores 1 even in a -threaded build?
19:31:43 <hackrilege> Literally there were no posts while your connection was down
19:31:48 <qfjp> oh
19:31:52 <qfjp> well...sorry
19:31:57 <monochrom> :)
19:32:01 <qfjp> :(
19:32:09 <hackrilege> It's cool!
19:32:21 <qfjp> :)
19:32:53 <dolio> Yes, Functors are endofunctors.
19:33:39 <qfjp> so i guess the only way to think about proper functors in haskell would be from subcategory to subcategory
19:33:48 <nshepperd> It's almost circular to define the codomain of your Functor f as the subcategory given by {forall a. f a}, but I think it does carry some useful information since f is normally a type constructor, not an arbitrary type function
19:34:24 <qfjp> okay, that makes sense
19:34:27 <nshepperd> maybe you can notice special properties of f, due to the properties of that subcategory?
19:34:46 <dolio> Codomains and images are not the same thing, though.
19:34:46 <qfjp> im just trying to wrap my head around monads, but I keep getting tripped up by fmap
19:35:04 <qfjp> but if functor is really an endofunctor, i think it makes sense
19:35:41 <hackrilege> In such instances as where a types monad instance csn be written in terms of its methods as a foldable applicative, which should serve as the parent definition, in terms of which the others are written?
19:35:44 <nshepperd> dolio: yes, that's why I say 'define the codomain'
19:36:05 <nolraiU> "so i guess the only way to think about proper functors in haskell would be from subcategory to subcategory" well its from all of Hask to part of Hask.
19:36:08 <dolio> Yes, but codomains are the things that are typically larger than images.
19:36:40 <nolraiU> Its fine to define the codomain as the same as the images.
19:36:49 <qfjp> I know its Hask -> Hask, but if I wanted to visualize a 'proper' functor it might be easier to ignore the larger category
19:36:52 <dolio> And the functor to the category defined by the image of a second functor is a distinct functor.
19:36:57 <qfjp> just to make the connection to category theory
19:37:15 <dolio> Except if they happen to be the same category, perhaps.
19:37:18 <nolraiU> qfjp: what are you having trouble with?
19:37:33 <MarcelineVQ> Lokathor: does it have -with-rtsopts=-N ?
19:37:38 <qfjp> well, the eta/mu definition of monads makes sense to me
19:37:51 <qfjp> but trying to get out the 'sequence' by relating it to bind relies on fmap
19:37:59 <qfjp> x >>= f = join (fmap f x)
19:38:07 <Lokathor> MarcelineVQ, nope, guess they expect you to run the -N yourself
19:38:21 <qfjp> which looks weird to me, since I'm used to writing functors as applying to both objects and morphisms
19:38:23 <Lokathor> i'm gonna adjust the cabal file and rebuild so that i get an auto-multicore stack
19:38:36 <qfjp> so I'm just trying to understand how fmap applies to a categorical functor
19:38:45 <nolraiU> qfjp: fmap is just the functor applying to a morphism.
19:38:50 <Lokathor> ghc-options:    -O2 -Wall -threaded -rtsopts -with-rtsopts=-N
19:38:51 <qfjp> right
19:38:55 <Lokathor> that look correct to everyone else?
19:39:06 <qfjp> I mean, i know that logically, but I still need some time to let it sink in
19:40:04 <qfjp> especially with the connection to bind
19:40:06 <nolraiU> I think you are getting side tracked.
19:40:16 <qfjp> its probable
19:40:45 <hackrilege> Is defining fold in terms of >>= possible?
19:40:48 <shachaf> The arrow mapping part of the functor is the important part.
19:41:06 <hackrilege> Or join
19:42:22 <qfjp> join x = x >>= id
19:42:32 <hackrilege> Boom!
19:42:33 <qfjp> i dont know about fold
19:42:57 <hackrilege> No, the fold bit is really what im after
19:43:50 <hackrilege> I'm not sure how to make a foldable out of a monad
19:44:06 <nolraiU> Is IO foldable?
19:44:10 <qfjp> can you, in general?
19:44:14 <nolraiU> I don't think it is..
19:45:47 <hackrilege> But a foldable applicative is a monad
19:45:54 <nshepperd> fold = unsafePerformIO ;)
19:46:23 <nshepperd> no, you can't write fold for a monad just using the monad functions
19:46:40 <hackrilege> It's also applicative
19:46:52 <hackrilege> Sorry i forgot to mention
19:47:25 <qfjp> alright, i'm gonna stop fighting with my internet connection
19:47:28 <qfjp> thanks for the help though
19:47:38 <qfjp> i'll come back later, if my ISP allows it...
19:47:46 <nshepperd> all monads are applicative
19:48:29 <hackrilege> All foldable applicatives are monads, but not the other way round, correct?
19:48:43 <tzh> hackrilege: https://wiki.haskell.org/wikiupload/d/df/Typeclassopedia-diagram.png this diagram might actually help for once
19:49:20 <rvxi> tzh: what's dotted vs. solid?
19:49:40 <hackrilege> I think it looks like I'm trying to add an arrow?
19:49:51 <Hijiri> hackrilege: ZipList is foldable, applicative, but not monad
19:49:54 <tzh> rvxi: solid line "a -> b" means "all bs are as" and dotted lines are just "some other kind of relationship"
19:50:06 <Hijiri> also data Pair a = Pair a a
19:50:08 <hackrilege> Why isn't it a monad?
19:50:18 <rvxi> 'some other kind of relationship'??
19:50:20 <tzh> e.g., category-theoretical but not encoded into haskell, stuff like that i assume
19:50:21 <nshepperd> I'm not sure you can make a legal monad instance out of foldable and applicative either
19:50:28 <tzh> the labeling is unclear :V
19:50:33 <Hijiri> well I'm not really show how you can show that it's not a monad
19:50:37 <Hijiri> not really sure*
19:50:45 <Hijiri> but there doesn't seem to be a way to make a legal instance
19:51:01 <nolraiU> It breaks the monad rules if you try.
19:51:09 <hackrilege> There is one for list which uses its constructor
19:51:12 <MarcelineVQ> tzh: https://wiki.haskell.org/Typeclassopedia#Introduction
19:51:14 <Hijiri> that is for list
19:51:16 <Hijiri> but not ZipList
19:51:22 <Hijiri> ZipList has a different applicative instance
19:51:26 <MarcelineVQ> oops
19:51:29 <Hijiri> and the monad instance has to match the applicative instance
19:51:35 <rvxi> tzh well then... scratch the 'help for once' part ;-)
19:51:40 <MarcelineVQ> I meant rvxi https://wiki.haskell.org/Typeclassopedia#Introduction
19:51:41 <Hijiri> it might be better to just think about the Pair type I just brought up though
19:51:44 <Hijiri> since it is simpler
19:51:44 <nshepperd> Pair actually is a monad, since it is fixed length
19:51:47 <Hijiri> oh
19:51:48 <nshepperd> as it happens
19:51:53 <Hijiri> alright
19:51:58 <nshepperd> :)
19:52:07 <rvxi> monomorphic restriction question
19:52:10 <Hijiri> how is that defined?
19:52:21 <hackrilege> I'm saying you might find it happens all the time!
19:52:21 <rvxi> dodgy x y = x + y * 10
19:52:27 <nshepperd> join = take the diagonal
19:52:30 <rvxi> oneIsOne = dodgy 1
19:52:35 <rvxi> type of the first function
19:52:35 <hackrilege> A counterexample would be good...
19:52:42 <Hijiri> ok, I see
19:52:54 <Hijiri> hackrilege: well ZipList was mentioned
19:52:58 <nshepperd> it doesn't work for ZipList because the diagonal might have 'holes' in it
19:53:06 <hackrilege> Ok
19:53:06 <rvxi> is Num a => a -> a -> a, but type of OneIsOne is Integer -> Integer
19:53:25 <hackrilege> Can you explain that a bit more?
19:53:30 <rvxi> why does binding 1 to y force the entire expression to be Integer, but the * 10 does not?
19:53:57 <Hijiri> I have to go now, so I can't talk much more
19:54:13 <hackrilege> It's OK, i meant about the holes
19:54:15 <shachaf> rvxi: I don't understand the question. What would you expect and what are you observing?
19:54:33 <rvxi> shachaf ok the function:
19:54:35 <rvxi> shachaf 
19:54:44 <rvxi> dogy x y = x + y * 10
19:54:52 <rvxi> type is Num a => a -> a -> a
19:54:56 <rvxi> this makes sense
19:55:05 <rvxi> partial application:
19:55:07 <rvxi> dodgy 1
19:55:11 <rvxi> type is Integer -> Integer
19:55:13 <monochrom> rvxi: the monomorphism restriction happens only when you define like "varname = ..." i.e. as opposed to "funcname params = ..."
19:55:22 <shachaf> You already identified that this is caused by the monomorphism restriction, so I'm not sure what the question is.
19:55:30 <rvxi> why is the type of
19:55:38 <nshepperd> hackrilege: to obey the monad laws in connection to the Applicative instance, you have to implement join by taking the diagonal
19:55:39 <shachaf> For more examples, try "dodgy = \x y -> x + y * 10" and "oneIsOne x = dodgy 1 x"
19:55:42 <monochrom> so for example "oneIsOne = ..." fits but "f x y = ..." doesn't
19:55:47 <rvxi> dodgy 1 not Num a => a -> a ?
19:56:00 <shachaf> The type of dodgy 1 is Num a => a -> a
19:56:10 <monochrom> screw dodgy 1. look at "oneIsOne ="
19:56:45 <hackrilege> I don't understand, is a ziplist like a matrix, whats the diagonal?
19:56:51 <nshepperd> hackrilege: but because ZipList is variable length, you could have x = ZipList [ZipList [1, 2, 3], ZipList [], ZipList [4, 5, 6]]
19:57:13 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
19:57:13 <nshepperd> hackrilege: join operates on a ZipList of ZipLists, which you can lay out like a matrix
19:57:34 <hackrilege> @src ZipList
19:57:34 <lambdabot> Source not found. Where did you learn to type?
19:57:50 <nshepperd> newtype ZipList a = ZipList [a]
19:58:38 <hackrilege> As they are lists i can use concat
19:58:55 <nshepperd> you can use concat but that won't obey the laws
19:59:00 <hackrilege> Hmm
19:59:12 <hackrilege> This send to be the point
19:59:17 <hackrilege> Seems
19:59:18 <nolraiU> Right then the aplicative and monad instances wont line up.
19:59:24 <nolraiU> *applicative
19:59:54 <rvxi> monochrom so no parameters = restrictive types
19:59:57 <Lokathor> wow i forgot how much longer an -O2 build takes compared to a standard build
20:00:01 <rvxi> any parameters  = non-restrictive types?
20:00:28 <monochrom> I wouldn't say "=".  "myid = \x -> x" is polymorphic just fine.
20:00:32 <nshepperd> hackrilege: here's a simpler example, do you know the Constant functor?
20:01:11 <nshepperd> data Const m a = Const m
20:01:24 <hackrilege> fmap a = id
20:01:58 <monochrom> the monomorphism restriction triggers when many conditionals all become true. one is "not defining a function". but there are more. another is "certain type classes are involved".  IIRC there is one more, "other type classes are not involved".
20:01:59 <nshepperd> so Const has Monoid m => Applicative (Const m), and also an obvious Foldable instance that returns mempty
20:02:26 <monochrom> do not look for a "simple" "rule of thumb" because there is none.
20:02:41 <nshepperd> but there's no legal definition of >>=
20:02:49 <monochrom> and do not abuse "=" for unequal things
20:02:58 <nshepperd> because of the first monad law: return a >>= f
20:03:01 <nshepperd> ≡ 
20:03:19 <nshepperd> er, return a >>= f   =   f a
20:03:46 <dolio> monochrom: The monomorphism restriction triggers as long as any classes are involved. Which classes only affect whether you get defaulting or an error.
20:03:51 <nshepperd> there's no way for that to be true, because return throws away the 'a' immediately
20:03:58 <monochrom> oh oops, yeah
20:04:25 <kristof> Where does all the interesting conversation on programming language research happen?
20:04:28 <dolio> Actually, even that is only true if the types in question are ambiguous.
20:04:49 <Lokathor> kristof, IRC, Mailing lists, published papers
20:04:57 <hackrilege> Awesome
20:05:00 <kristof> Lokathor: forums?
20:05:14 <monochrom> actually I think it does not happen in IRC
20:05:23 <dolio> If you have `foo = \x -> x + 1` and somewhere else have `foo (1.0 :: Double)`, you will get `foo :: Double -> Double`
20:05:28 <kristof> Lokathor: also, published papers are great, but people usually announce their papers, or they circulate around communities by word of mouth
20:05:38 <hackrilege> So foldable monads are totally a thing
20:05:43 <dolio> Even though defaulting would pick Integer -> Integer.
20:05:44 <kristof> I am familiar with Lambda the Ultimate but it just does not seem active or complete enough
20:05:45 <Lokathor> less discussion on IRC, more like getting to know people and spreading word of mouth
20:05:48 <monochrom> yeah, I forgot what I saw when using Parsec etc
20:06:48 <hackrilege> Isnt it? Foldable monads are totally a thing
20:06:57 <monochrom> in fact Foldabe-Traversable-inspired monomorphism restrictions are coming soon too :)
20:07:53 <monochrom> x = foldr (:) []; y = x Nothing
20:08:24 <hackrilege> Actually, i think specifically, monads who's join can be written in terms of fold
20:10:51 <monochrom> are you trying to prove this tautology? "if join can be written in terms of fold, then join can be written in terms of fold"
20:11:47 <hackrilege> No, I'm saying that there is an intersection of foldable and monad
20:12:07 <hackrilege> Perhaps foldable applicative sorry, I'm not sure
20:13:26 <hackrilege> OK i see what your saying
20:15:49 <hackrilege> Perhaps there are no instances where a foldable monads join cannot be written in terms of fold?
20:16:09 <hackrilege> Obeying laws
20:21:05 <c_wraith> hackrilege: Uh.  []
20:21:12 <hackrilege> Does that make sense?
20:21:34 <c_wraith> :t foldMap id
20:21:36 <lambdabot> (Foldable t, Monoid m) => t m -> m
20:21:52 <c_wraith> :t foldMap id [[1,2,3],[4,5,6]]
20:21:53 <lambdabot> Num t => [t]
20:21:57 <c_wraith> > foldMap id [[1,2,3],[4,5,6]]
20:21:59 <lambdabot>  [1,2,3,4,5,6]
20:22:22 <c_wraith> > join [[1,2,3],[4,5,6]]
20:22:23 <lambdabot>  [1,2,3,4,5,6]
20:22:49 <c_wraith> :t foldMap id `asTypeOf` join
20:22:50 <lambdabot> (Monad t, Foldable t, Monoid (t a)) => t (t a) -> t a
20:23:01 <hackrilege> join = foldMap id?
20:23:05 <c_wraith> Seems like that'll happen more than just for []
20:23:14 <c_wraith> For some types
20:23:49 <hackrilege> I'd say when it works that foldable applicative beats monad
20:23:55 <hackrilege> As parent
20:23:56 <c_wraith> > foldMap id (Just (Just ()))
20:23:58 <lambdabot>  Just ()
20:24:46 <hackrilege> Is this cool, i can't tell if this is obvious?
20:25:01 <c_wraith> I'm certain it doesn't always hold
20:26:30 <nolraiU> c_wraith: thats what my intuition says too, but I cant think of an counter example.
20:27:15 <nshepperd> hackrilege: foldable + applicative = monad is not generally true, no
20:27:19 <c_wraith> well, you can always break it with different monoids
20:27:32 <nshepperd> for a start foldable doesn't even have any laws
20:28:35 <Welkin> LAWLESS HOOLIGANS
20:28:37 <nshepperd> 'fold' could just give you mempty every time, which would make it useless for writing a monad instance
20:28:47 <hackrilege> That was not my claim nshepperd
20:29:17 <hackrilege> (hackrilege) Perhaps there are no instances where a foldable monads join cannot be written in terms of fold?
20:29:56 <hackrilege> But i wasn't sure if that even made much sense
20:30:11 <nshepperd> oh well, I don't know
20:30:50 <nshepperd> a Tree monad?
20:31:13 <nshepperd> Folding over a Tree just traverses the leaves, throwing away the shape
20:31:46 <c_wraith> Well, since Foldable lacks laws in the first place, you probably should use Traversable
20:32:33 <hackrilege> The point to me is that it looks like i should only write one instance for foldable applicative monads monad instance in terms of fold etc, and then pass around foldable applicative instead, knowing its monad instance will kick in if it's needed
20:32:47 <TallerGhostWalt> is there some trick to depending on a shared library in cabal repl?
20:32:56 <hackrilege> I shall use traversable if it can do join
20:33:13 <TallerGhostWalt> I have a c library that works fine when I run main from shell but when I cabal repl and run I get a lib not found err
20:33:41 <c_wraith> Traversable is a superclass of Foldable that imposes laws on how it behaves
20:33:44 <kristof> Isn't there a way to write the fmap in terms of bind and join?
20:33:48 <c_wraith> err, subclass
20:34:02 <c_wraith> kristof: yes
20:34:06 <c_wraith> @src liftM
20:34:06 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:34:25 <kristof> Ah, that's right
20:34:28 <c_wraith> oh, guess it needs return too
20:34:39 <kristof> I think I meant bind and return
20:35:07 <kristof> the point being that every Monad instance has a generateable applicative instance, and every applicative instance has a functor instance
20:35:12 <hackrilege> :t bind
20:35:14 <lambdabot>     Not in scope: ‘bind’
20:35:14 <lambdabot>     Perhaps you meant one of these:
20:35:14 <lambdabot>       ‘BS.find’ (imported from Data.ByteString),
20:35:24 <kristof> Is that what hackrilege is talking about?
20:35:29 <c_wraith> hackrilege: bind is just a folk name for (>>=)
20:35:43 <hackrilege> Great!!!
20:35:49 <hackrilege> Finally that thing has a name
20:36:05 <kristof> it's obviously `plunger`
20:36:23 <lethjakman-l> So...I see a :|: in a type signature, is that like an or?
20:36:43 <c_wraith> lethjakman-l: could be.  It's a library-defined type.  Could be anything. :)
20:37:46 <hackrilege> kristof, yes, my problem is when things can be defined in terms of one another and there is ambiguity add to which should be wrapped up in an instance and forgotten.
20:37:50 <monochrom> you will need to read the library doc
20:38:20 <kristof> hackrilege: In terms of each other, or one providing a good instance for another?
20:38:23 <hackrilege> Here it seems monad is the weaker in this sense.
20:39:10 <hackrilege> kristof  sometimes the mapping is not invertable
20:39:11 * hackagebot patches-vector 0.1.4.4 - Patches (diffs) on vectors: composable, mergeable, and invertible.  https://hackage.haskell.org/package/patches-vector-0.1.4.4 (LiamOConnorDavis)
20:39:19 <monochrom> 10 minutes of finding and reading the doc can be saved by 1 minute of guessing wrong followed by throwing away 3 hours of work based on the wrong guess
20:39:38 <lethjakman-l> c_wraith: Oh...
20:39:49 <kristof> hackrilege: Here is a general trick. Write a newtype (Monad m) => MonadW m
20:40:07 <kristof> hackrilege: Then you can write an instance for Applicative and Functor for MonadW
20:40:45 <hackrilege> All applicatives are functors. fmap should obviously be written in terms of applicative
20:40:46 <kristof> hackrilege: It's the trick of using newtypes to "view" bounded datatypes in a different way.
20:41:10 <kristof> hackrilege: ...Except not every Functor is also an Applicative.
20:41:26 <hackrilege> No but the converse is true
20:41:36 <hackrilege> So it's clear how to behave
20:41:50 <kristof> hackrilege: Okay. Well. What you're really asking is "I want to write Functor instances, except when I can write an Applicative instance, in which case I can derive a Functor one."
20:43:28 <nolraiU> Shouldn't there be a way to factor the fmap out of applicative?
20:43:41 <kristof> fmap is not in applicative.
20:43:42 <nolraiU> So that what you right is strictly the extra needed?
20:43:54 <hackrilege> Yes I'm fine with that, and i propose a language extension which apparently isn't going to work to support it, but basically when you instantiate applicative, you should have already written an instance of functor for all applicatives and need not write this again
20:44:08 <lethjakman-l> Hmm, I can't :t (:|:)
20:44:13 <kristof> hackrilege: You can do this with overlapping instances.
20:44:20 <lethjakman-l> It looks a little inappropriate too. 
20:44:20 <nolraiU> I mean how you can change Monad to join instead of bind?
20:44:22 <micahf> wow
20:44:24 <lethjakman-l> Maybe it's just in there to spite me. 
20:44:51 <micahf> i'm realizing that writing functional in javascript requires a lot more dedication than writing in haskell
20:44:54 <nolraiU> :t (:|:)
20:44:55 <lambdabot> Not in scope: data constructor ‘:|:’
20:44:55 <monochrom> clearly, if (:|:) is a type name, then :t (:|:) is wrong. think of ":t Int"
20:44:56 <micahf> in haskell it comes out naturally
20:44:59 <micahf> it's the only way
20:45:08 <micahf> in haskell you are forced to write functional
20:45:22 <micahf> this may seem obvious to you all
20:45:25 <monochrom> instead, use the more general ":info :|:"
20:45:26 <micahf> but to me it's a revelation 
20:45:28 <hackrilege> Good stuff huh
20:45:35 <lethjakman-l> Maybe I'm wrong: (Maybe (Text:|:[(Maybe Value)]))
20:45:44 <lethjakman-l> Is the :|: not independent of type?
20:46:01 <monochrom> I have never heard of the notion "independent of type"
20:46:01 <hackrilege> Plenty equals signs, please enjoy haskell :)
20:46:08 <micahf> :)
20:46:25 <nolraiU> :k (:|:)
20:46:26 <lambdabot>     Not in scope: type constructor or class ‘:|:’
20:46:26 <lambdabot>     Perhaps you meant ‘:~:’ (imported from Data.Typeable)
20:46:29 <lethjakman-l> micahf: have you looked at ramda?
20:46:35 <lethjakman-l> I'ts not perfect...but it's better. 
20:46:39 <micahf> yeah, i've seen ramda
20:46:54 <lethjakman-l> Ooo
20:46:56 <kristof> hackrilege: Rust will get this feature soon as well. Essentially, the idea is that "the most specific instance applies".
20:46:57 <lethjakman-l> :k worked
20:46:58 <lambdabot> Not in scope: type variable ‘worked’
20:47:00 <lethjakman-l> What is that?
20:47:08 <monochrom> kind. every type has a kind.
20:47:09 <micahf> i don't like the R.fn() thing
20:47:10 <lethjakman-l> lol. 
20:47:20 <lethjakman-l> micahf: Yeah, it's not perfect. 
20:47:20 <micahf> but it's still really nice
20:47:23 <lethjakman-l> What about purescript?
20:47:28 <monochrom> but kind tells you almost nothing
20:47:29 <micahf> i'm checking out purescript now
20:47:39 <lethjakman-l> It's a subset of haskell from my understanding. 
20:47:41 <micahf> also checking out haste
20:47:43 <lethjakman-l> Elm is nice too. 
20:47:50 <lethjakman-l> haste seems like it's falling out of favor. 
20:48:13 <hackrilege> The most specific.. No wait the most general suerly
20:48:36 <hackrilege> Ie this works on all functors, not just applicative ones
20:48:38 <micahf> why is haste disfavorable?
20:49:02 <kristof> hackrilege: You can do this with ML functors (not related to Haskell functors) in a more explicit way. Basically, a module contains code, and a functor lets you take one module and produce another one (like a function over modules). So essentially you'd write a functor MakeApplicative(M: MONAD): Applicative that will produce a new module you can import functions from.
20:49:28 <hackrilege> But the functor insurance itself should be in terms of the lowest possible subclass
20:49:41 <lethjakman-l> micahf: not sure, I just hear less about it. 
20:49:42 <kristof> hackrilege: let MaybeApplicative = MakeApplicative(MaybeMonad); MaybeApplicative.pure 2 == Just 2
20:49:48 <lethjakman-l> Probably a bad heuristic. 
20:50:15 <lethjakman-l> I know the nice thing about purescript is semi-readable code. 
20:50:16 <kristof> hackrilege: So you end up having to do things more explicitly, but you get more flexibility. Tradeoffs, tradeoffs.
20:50:18 <Denommus> kristof: ML functors are awesome. Have you seen their work on module implicits?
20:50:29 <lethjakman-l> By code, I mean generated code. 
20:50:30 <kristof> Denommus: I have. I think it's the natural generalization of typeclasses
20:50:55 <Denommus> kristof: I hope it catches on. It's a really awesome concept
20:51:12 <kristof> Denommus: The idea I've realized is this: typeclasses register modules to a type in a lookup table. Multiparameter typeclasses just add more rows to the table.
20:51:33 <kristof> Denommus: So you could generalize the "registration" idea to more than just types.
20:51:41 <hackrilege> If writing a subclass instance, having it automatically satisfy superclass instances is a nice bonus
20:52:58 <kristof> Denommus: for instance, a function f :: (Show a) a -> a -> [Char], when instantiated with a type like [Int], will basically perform a lookup for the module registered to the key [Int] if it exists, and take the function from it
20:58:42 <hackrilege> What is join in terms of foldMap id?
20:59:18 <shachaf> Look. The thing you're trying to do doesn't work.
20:59:18 <kristof> hackrilege: Like I said, you can fake this with a newtype
20:59:41 <shachaf> Monad can't be expressed in terms of Foldable. It won't work.
20:59:48 <hackrilege> Can we make a paste?
20:59:56 <hackrilege> One sec
21:02:57 <Denommus> kristof: yeah
21:03:15 <hackrilege> How does this look? http://lpaste.net/144975
21:04:23 <hackrilege> Sorry there is a typo =>
21:04:37 <hackrilege> Rather than >>=
21:04:45 <kristof> Denommus: Do you think that's useful?
21:04:47 <kristof> Denommus: Probably not
21:06:05 <kristof> hackrilege: That says "Here is a Monad instance for any Applicative, Traversable a." That is not true in general, sorry.
21:06:48 <hackrilege> How do i define a subset?
21:07:06 <kristof> I don't know what you mean.
21:07:12 <kadoban> Monad a => Monad a where …
21:09:26 <kristof> That's a tautology.
21:16:35 <hackrilege> Those Applicative Traversables who are monads http://lpaste.net/144975
21:18:25 <hackrilege> kristof, is that better?
21:19:35 <hackrilege> Obviously it needs fleshing out a bit
21:20:55 <hackrilege> Perhaps without the monad a constraint...
21:22:08 <kristof> hackrilege: Nope, not better.
21:22:20 <kristof> hackrilege: In ATM, you've stated that the instance has to have a Monad instance first.
21:22:32 <kristof> then you go on to write a monad instance for every ATM. But it already has one.
21:22:39 <hackrilege> Yes scrap that, that's a typo
21:22:51 <kristof> Like I said: do a newtype trick.
21:23:08 <hackrilege> Can you edit the paste?
21:23:30 <kristof> newtype ATM a = ATM { getInterior :: a }
21:23:44 <kristof> instance (Monad a) => Monad (ATM a)
21:24:25 <kristof> sorry, I meant: instance (Traversable a, Applicative a) => Monad (ATM a)
21:24:46 <hackrilege> Yeh
21:24:49 <kristof> I don't think that's true at all. Traversables require that a is an applicative, so it's redundant. In any case, you cant make a monad out of every traversable.
21:26:39 <tzh> many of the functions that now have foldable and traversable constraints used to have monad ones, right? `sequence` maybe being the most obvious example. and the reason the foldable and traversable typeclasses were made (afaik) was explicitly because there are things that aren't monads but can still be traversed or folded through
21:26:56 <hackrilege> No but where you can you should provide the instance of Monad strait away, as in we should have a class for traversable monads
21:27:45 <hackrilege> And monads may not be traversable?
21:28:15 <hackrilege> May be not traversable
21:28:52 <hackrilege> Ok
21:29:57 <tzh> hackrilege: what are your goals for this code?
21:30:05 <hackrilege> But there are cases where traversable things are naturally monads because fold defines join. i want to embody this observation into syntax
21:30:31 <tzh> i think "where you can" provide a monad instance, it's usually instanced already (if you're using someone else's type) or you will have to write a specific instance for that type (if you're using your own type)
21:31:35 <tzh> so the things that are traversable and applicatives will probably already have a monad instance specifically, because it's possible for that type, or not have a monad instance, because it's not possible for that type
21:32:04 <hackrilege> At the top level, allowing traversable things (maybe foldable) to have some sort of monad derived from them, perhaps even the laws could be checked at runtime
21:33:51 <hackrilege> I'm defining a new data structure which is a foldable monad, it seems natural to define the monad instance from fold as it wouldn't work the other way round
21:34:10 <hackrilege> Or would it?
21:35:38 <hackrilege> Anyway, it seems the thing I'm defining is quite general and that a class should exist which has monad instance defined in terms of fold
21:36:43 <tzh> if it's possible for that specific data structure to instance Foldable in a way that that `foldMap id` trick would result in a join function that ends up obeying the monad laws, then you should be able to instance Monad using that instance's Foldable functions. but that would not hold for every possible data structure
21:37:18 <tzh> which is why people keep saying that a general `(Foldable a, Applicative a) => Monad a` instance would not work, or would be a bad idea
21:38:13 <hackrilege> To me the concept of join is not like the element wise contraction of fold, though fold enables an implementation of join
21:39:57 <hackrilege> I get its not always possible, but when it is, my instance is available
21:40:44 <hackrilege> And as the whole requisite is that an instance be derivable, then it makes sense to provide that
21:41:52 <hackrilege> Are you making a Monad out of that fold? Yes! Great, you won't need to tell me how.
21:42:50 <tzh> right, but depending on what a type's Foldable instance looks like, you might end up with an automatically-generated Monad instance that breaks the monad laws
21:43:46 <hackrilege> Hey it doesn't work! So, you gave me a dud traversable, here are some functions which will check the laws are satisfied at runtime
21:44:14 * hackagebot JuicyPixels-scale-dct 0.1.1.0 - Scale JuicyPixels images with DCT  https://hackage.haskell.org/package/JuicyPixels-scale-dct-0.1.1.0 (phadej)
21:44:14 <tzh> yeah but that's kind of against the haskell philosophy :V
21:45:07 <hackrilege> So we enforce the implementation of all classes that must satisfy some laws?
21:45:37 <jle`> it's a very important expectation
21:45:48 <tzh> well, that's getting into dependent-types territory, which is... difficult.
21:45:48 <jle`> otherwise the classes are useless
21:46:27 <hackrilege> In which case as foldable had no laws it should just hope that join is basically a fold!? No that's broken n completely
21:46:58 <jle`> it's also not really possible to check most laws at runtime
21:47:07 <jle`> and the idea is that once the instance is "in scope", it's assumed to be valid
21:47:07 <hackrilege> Hmm
21:48:40 <hackrilege> Just so i know, what laws am i ensuring here? a = (>>=) return a
21:49:09 <tzh> https://en.wikipedia.org/wiki/Monad_(functional_programming)#Monad_laws
21:49:12 <hackrilege> Kk
21:50:35 <tzh> for the typeclasses that have laws associated with them, haskell mostly assumes the person doing the class instancing is writing correct code, because it's difficult/impossible for the compiler to do the proving itself
21:52:07 <hackrilege> Can we take list of list of Num and sum as join as an example?
21:52:57 <hackrilege> Are the laws in danger?
21:53:43 <tommd> The laws are always in danger.  Every week some new whipper snapper wants to count statements by incrementing a stateful counter in the definition of (>>=).
21:54:22 <tzh> well, then there's the question of what >>= looks like, if join is Num a => [a] -> a
21:54:23 <hackrilege> Are the laws satisfied?
21:54:27 * glguy has been putting monad laws and applicative laws to work the last couple of days to make using GHC.Generics efficient
21:54:32 <glguy> use all the laws!
21:54:53 <glguy> Violated the laws? My types will break you!
21:56:00 <hackrilege> I can't remember how to write bind in terms of join
21:56:23 <johnw> bind = (join .) . fmap
21:56:36 <johnw> bind x f = join $ fmap f x
21:56:43 <johnw> sorry, missed a flip in the first one
21:56:57 <glguy> Yeah, definitely start with the point-free version when explaining it to someone who doesn't already know how it works :)
21:57:07 <johnw> oh, didn't realize he didn't know how it worked
21:58:46 <hackrilege> @pl bind
21:58:47 <lambdabot> bind
21:58:51 <shachaf> glguy: That's as good a time as any other to start with the point-free version.
21:59:13 <glguy> Oh, Ok.
21:59:16 <hackrilege> @unpl bind
21:59:16 <lambdabot> bind
21:59:21 <tommd> @src bind
21:59:21 <lambdabot> Source not found. Wrong!  You cheating scum!
21:59:28 <hackrilege> Sorry
21:59:45 <tzh> wow lambdabot, harsh
21:59:49 <hackrilege> Yeh
22:00:02 <tommd> No, I think it's fair.  It's totally true.
22:00:19 <lispy> lambdabot is always harshing on our haskell mellow :/
22:00:34 <hackrilege> Rofling
22:02:59 <jle`> haskellmallow sounds like a nice treat
22:03:37 <tommd> My next library, iif it is ok with lispy.
22:05:11 <hackrilege> bind x f = fold1 f x
22:06:22 <hackrilege> This is going badly
22:07:30 <hackrilege> Maybe someone knows how to get the base case
22:14:15 <hackrilege> bind x f = fmap (flip fold f) x
22:14:42 <hackrilege> Closer?
22:14:48 <hackrilege> I'm sorry
22:16:45 <tzh> you should be trying these in ghci, if you're trying to home in on a type that's like >>=
22:17:12 <hackrilege> I was looking for some help in really struggling
22:17:14 <lispy> tommd: fine by me :)
22:22:49 <jle`> hackrilege: you can't implement a meaningful bind generic for all Foldable
22:23:12 <hackrilege> Why not?
22:23:25 <hackrilege> Fold is like join
22:23:28 <jle`> you can't prove that it follows the laws
22:23:46 <jle`> and also, more directly, you can't even get one that typechecks, because Foldable can't return something of the type of the instance
22:24:03 <jle`> note that all of the results of Foldable methods are "not `f a`"
22:24:15 <jle`> you can't return an `f a` with any Foldable thing, generic over all Foldable
22:24:22 <hackrilege> Applicative has pure
22:24:47 <hackrilege> So i can?
22:24:50 <jle`> ah, are you using Applicative too?  then i guess the second argument is less relevant
22:24:56 <jle`> but still, you can't say that it follows the laws
22:25:20 <geppettodivacin> Sorry I'm a bit late to the bind party, but can someone explain the point-free join version that was posted a while back? I can't seem to get it to work in ghci.
22:25:22 <jle`> otherwise you've just implemented a method that has the same type signature as bind, and that you named "bind"...but is not actually amonadic bind
22:25:35 <jle`> *actually a monadic bind
22:25:36 <geppettodivacin> bind = (join .) . fmap
22:25:55 <Axman6> :t (join .) . fmap
22:25:56 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
22:26:00 <hackrilege> Is join = sum violating the laws?
22:26:05 <liste> @unpl (join .) . fmap
22:26:06 <lambdabot> (\ d i -> (fmap d i) >>= \ e -> e)
22:26:34 <jle`> it doesn't even typecheck :|
22:26:42 <nshepperd> :t asum
22:26:43 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
22:27:00 <nshepperd> hackrilege: you could do return = pure; join = asum
22:27:02 <jle`> also if it's a "monadic" join, it has to be polymorphic over all a, f (f a) -> f a
22:27:13 <nshepperd> hackrilege: but there is no guarantee whatsoever that that will obey the laws
22:28:01 <jle`> yeah, it's join in that it typechecks and you superficially named it "join", but that doesn't mean that it's actually a monadic join :)
22:28:20 <hackrilege> join = fmap sum
22:28:28 <jle`> it's like if i implemented subtract x y = x + y.  it typechecks and i called it subtract, but it's not what people talk about when they talk about `subtract`
22:28:49 <jle`> and it doesn't obey laws that subtraction is expected to obey in order to be called "subtraction" in any meaningful way
22:29:17 <jle`> :t fmap sum
22:29:18 <lambdabot> (Functor f, Num b, Foldable t) => f (t b) -> f b
22:29:51 <jle`> only works for Num b, so it's not the typical join for Monad
22:30:07 <jle`> but you can check laws, too.  for join, the laws are `join . join == join . fmap join`
22:30:08 <hackrilege> No but good for lists of lists of numbers
22:30:55 <hackrilege> And sum is just fold (+) 0
22:31:17 <hackrilege> So i should provide an identity at some point
22:32:23 <hackrilege> What's join' ?
22:33:10 <jle`> oh i used those as quotation marks
22:33:19 <hackrilege> Ok
22:33:22 <jle`> "join . join" should be the same as "join . fmap join"
22:33:47 <jle`> but your join . join doesn't really even make sense
22:35:32 <hackrilege> (fmap (fold f z)).(fmap (fold f z))
22:35:37 <MarcelineVQ> hackrilege: you should check out the nicta haskell course if you haven't done it, it's all about that kind of stuff
22:35:57 <hackrilege> Thanks
22:36:01 <jle`> what are f and z?
22:36:06 <MarcelineVQ> @where nicta
22:36:06 <lambdabot> https://github.com/nicta/course
22:37:12 <hackrilege> for Num f can be pluss, z is a base case or zero
22:37:24 <jle`> but, yeah, it's fundamentally impossible to implement a Monad instance generic over all Foldable + Applicative, because Foldable doesn't even have any laws, so you can't make any conclusions/refactorings/proofs from generic Foldable code
22:37:40 <lambda-11235> Wouldn't a foldable, applicative monoid work?
22:37:49 <lambda-11235> join = foldl mappend mempty
22:37:52 <jle`> you can't "prove" that your bind or join is monadic from generic Foldable+Applicative alone
22:38:21 <hackrilege> Foldable is Applicative
22:38:41 <jle`> not all Foldable are Applicative
22:38:51 <jle`> there are actually a lot of Foldable's that aren't :)
22:39:35 <jle`> Map from containers is one that comes to mind
22:39:35 <hackrilege> I can not prove it satisfies the laws, as not all traversables are naturally monads, however some are
22:40:04 <jle`> some are, and some aren't...so there's no reason to write it generic over all Traversable
22:40:11 <hackrilege> Ok again, i was misled earlier
22:40:38 <jle`> might as well write it for that specific type
22:40:43 <hackrilege> I thought traversable was Applicative my bad
22:41:16 <jle`> there's no reason to write bind or join generic over all Foldable/Traversable...just implement it for your specific type
22:41:21 <jle`> then you can prove your laws on that type :)
22:41:49 <hackrilege> I will write of for the type, as an instance traversable monoid monad
22:42:21 <jle`> i mean, write instance Monad Foo where (>>=) = ... (implemented in terms of Traversable and Applicative methods, possibly)
22:42:30 <jle`> it doesn't make any sense to write an instance for *all* Traversable
22:42:36 <jle`> because your methods wouldn't give a Monad for *all* Traversable
22:42:45 <nshepperd> I think it's bad form to write generic instances that don't actually work generically
22:42:48 <hackrilege> Instance (Traversable a) => Monad a where
22:42:56 <jle`> but that's not a true instance
22:43:03 <jle`> because they don't follow the laws
22:43:14 <jle`> one type might follow the laws by coincidence
22:43:20 <jle`> but the instances don't actually follow monad laws
22:43:36 <hackrilege> OK
22:43:36 <jle`> you have something that typechecks, but is useless as a Monad and "is not a Monad", by most reasonable standards of what a monad is
22:44:07 <jle`> it's like writing instance Num Int where (+) = (-); (*) = (^); subtract = (+); fromInteger = -38
22:44:18 <jle`> i mean...yeah, you can write the meaningless instance
22:44:19 <hackrilege> In many cases it would work, so i just guard with a newtype
22:44:38 <jle`> but the newtype instance would also be invalid, too
22:44:50 <jle`> if i did newtype MyInt = MI Int
22:44:56 <nshepperd> 'instance (Foldable m, Alternative m) => Monad m' is possible, but I will consider you a bad person for writing it, because that type signature is a promise to provide a monad instance for all those cases, a promise which is broken
22:45:17 <jle`> and did instance Num MyInt where (MI x) + (MI y) = MI (x - y); fromInteger _ = MI (-38)
22:45:22 <jle`> that would be just as bad as writing the Num for Int
22:45:35 <jle`> the newtype doesn't mean anything in terms of correctness..
22:46:17 <nshepperd> even with a newtype 'instance (Foldable m, Alternative m) => Monad (Wrapper m)' you're still promising a legal monad instance which can't be assured...
22:46:32 <jle`> if i newtyped List, newtype MyList a = MyList [a], and wrote a Monad instance that is completely incorrect and invalid for list/MyList, that still makes it invalid/not correct
22:46:44 <jle`> adding the newtype doesn't make something automatically correct/verified...
22:47:21 <hackrilege> Each time i instantiate MonadFold i expect to have to provide definitions instances for fold and expect that the monad law is provided by a monad instance of MonadFold written in terms of Applicative and Foldable
22:47:58 <jle`> what do you mean?
22:48:41 <jle`> newtype MonadFold m a = MonadFold (m a), and instance (Applicative f, Foldable f) => Monad (MonadFold m) ?
22:49:12 <jle`> er, that should be MonadFold f at the end
22:49:18 <jle`> in this case, it's still very possible to create invalid instances
22:49:22 <nshepperd> you're better off just writing the instance explicitly, I think...
22:49:39 <jle`> a user could write MonadFold (some data type where the fold doesn't give a monad)
22:49:45 <jle`> and then boom, you have an invalid instance
22:50:06 <jle`> if you want to restrict the MonadFold constructor to only types that you pre-verify to be correct/follow the laws...then why not just write normal instances? >_>
22:50:13 <jle`> write normal instances for those types...
22:50:22 <jle`> those specific types
22:50:54 <jle`> if you know that MonadFold Foo will give you a proper Monad, and you restrict your user so that they can only construct `MonadFold Foo`, then why not just implement a Monad instance for Foo, and ignore MonadFold altogether?
22:51:00 <jle`> there's really...no point
22:51:44 <hackrilege> Class (Traversable a, Applicative a) => MonadFold a where (goes on to requst sufficient functions to define instances for Traversable and Applicative. Then gives instances of MonadFold as Applicative, Traversable and Monad, all in terms of the methods of MonadFold
22:52:37 <jle`> you mean instances of Monad in terms of MonadFold?
22:52:46 <hackrilege> Yes
22:53:21 <jle`> and MonadFold "laws" are that the instances all have fold implemented to exactly have the Monad laws satisfied?
22:53:33 <jle`> i don't really see any benefit to this...what does it add?
22:53:35 <hackrilege> Yes
22:53:55 <hackrilege> It adds derived monad instance
22:54:54 <hackrilege> By this rational we would not define functor instances when defining applicative instances, all applicative can instantiate fmap
22:55:47 <jle`> doesn't seem any different than having a method `bindForSomeFoldables :: (Foldable f, Functor f) => f a -> (a -> f b) -> f b`, and doing instance Monad Foo where (>>=) = bindForSomeFoldables
22:56:02 <jle`> and it doesn't seem any different than instance Functor Foo where fmap = liftA
22:56:37 <hackrilege> So i can write instance Applicative a => Functor a where, and never gave to do this again. This should be done after the class definition of Applicative
22:56:41 <jle`> instance Functor Foo where fmap = liftA     -- and this is even guarunteed to follow functor laws!  liftA is fmap for *all* types where it can be defined
22:56:58 <jle`> you still have to write a MonadFoo instance in this case
22:57:00 <jle`> for every tpye
22:57:21 <jle`> also, what if you wanted a definition of fmap that's more performant than liftA/fmap-defined-in-terms-of-Applicative ?
22:57:31 <hackrilege> Exactly, it's a weaker extension of that principle, but as you say, laws can be inherited,  which is nice thanks
22:58:13 <jle`> instance Functor Foo where fmap = liftA is just as much "boilerplate" as your intermediate class suggestion, but is cleaner and doesn't reuqire typeclass magic
22:58:32 <jle`> it doesn't require any compiler magic or meddling with global typeclasses games
22:58:55 <hackrilege> Performant ? So here >>= would be harder to parallelize perhaps then an underlying Fold
22:58:56 <jle`> you don't have to deal with potential overloaded instances
22:59:25 <jle`> and also, you can choose if you want to provide an alternate instance definition that is potentially more performant
22:59:42 <jle`> also, you can choose *what to define* fmap in terms of.  would it be fmap = liftA, or fmap = liftM ?
22:59:51 <jle`> both implementations might have different performance profiles
23:00:13 <jle`> this lets you choose which one, if you wanted to re-use something.  you could even do fmap = fmapDefault
23:00:23 <hackrilege> Brilliant!!
23:00:49 <jle`> fmap can be defined in terms of Traversable, Applicative, or Monad
23:01:01 <jle`> if you wanted "automatic implementation", how would GHC know which one to use?  if a type is all three?
23:01:13 <jle`> how would it know what fmap you wanted to define it as automatically?
23:01:18 <hackrilege> That's the valid criticism, thanks
23:01:27 <jle`> the normal way, instance Functor Foo where fmap = liftA, fmap = liftM, or fmap = fmapDefault, is nice and clean
23:01:41 <shachaf> This conversation has been going on for about five hours now. I suggest that #haskell-overflow is a better place for it.
23:01:53 <jle`> good call :)
23:02:29 <hackrilege> Fortunately that solved it, thanks so much
23:03:29 <jle`> np!
23:10:45 <Fylwind> often I find myself wishing tuple types of different lengths weren't distinct, but rather, it would be nice if they were built recursively from a primitive "pair" type much like how lists are built from cons
23:11:27 <shachaf> This is the reason for HList.
23:14:54 <jle`> there are definitely several libraries on hackage that offer this, and it isn't too tricky to make one yourself from scratch too
23:19:44 <Fylwind> but it would be nice if it was just baked into the language
23:21:40 <cocreature> isn't it even nicer, if the language allows you to implement it in "userspace" instead of baking it in?
23:22:07 <shachaf> There are disadvantages, of course.
23:30:52 <rkv> What other languages like Haskell draw ideas from mathematics?
23:32:57 <cocreature> most languages adapted the idea of addition from mathematics
23:33:41 <Hafydd> Some more creatively than others.
23:38:24 <Fylwind> cocreature: it's not necessarily nicer if everyone ends up using incompatible "userspace" implementations of the same concept
23:38:50 <cocreature> yeah I wasn't trying to be completely serious :)
23:39:08 <Fylwind> and there's always a cost to adding a new library dependency
23:41:51 <Fylwind> there are many things where I feel the gain in convenience doesn't justify the cost of having one more dependency :|
