00:00:00 <ski> it works on specific types
00:00:59 <ski> when an exception is thrown, it has a specific type. when `catch' is called, it is called with `e' being a specific type
00:01:06 <ski> those two types are compared
00:01:32 <nitrix> What's a specific type? I'm familiar with monomorphism, not yours, ski.
00:01:58 <mniip> well yes, what ski has said doesn't make much sense without Typeable
00:02:09 <mniip> as values normally don't have types at runtime
00:02:15 <ski> (and i'm not sure what you think a "monomorphic type" is. also, this probably doesn't help much)
00:03:36 <nitrix> I'm not whithin the context; just trying to extent my vocabulary.
00:03:40 <ski> nitrix : if you call `catch', the context will determine which actual type is used instead of the type variable `e', for that particular call
00:03:57 <ski> e.g. `e' might be `IOException'
00:04:04 <ski> or `ErrorCall'
00:04:17 <zzing> Am I doing something wrong on line 32 of https://gist.github.com/madebyjeffrey/011b70447b87469222bb  the compiler complains about no 'in' with the let.
00:04:54 <ski> (just like if you call `length "potrzebie"', this calling context of `length' will determine `a' in `length :: [a] -> Int' to be `Char')
00:05:09 <ski> nitrix : ok ?
00:06:37 <nitrix> That's called a specific type?
00:06:41 <mniip> [11:01:51] <ski> (and i'm not sure what you think a "monomorphic type" is. also, this probably doesn't help much)
00:06:46 <mniip> a type without Λ?
00:07:04 <ski> (fwiw, to me, `Int',`Either',`forall a. [a]' are all examples of monomorphic types)
00:07:15 <mniip> aka ∀
00:07:34 <nitrix> forall a. [a] is monomorphic?
00:07:37 * hackagebot bson 0.3.2 - BSON documents are JSON-like objects with a standard binary  encoding.  https://hackage.haskell.org/package/bson-0.3.2 (VictorDenisov)
00:07:37 * hackagebot wai-cors 0.2.4 - CORS for WAI  https://hackage.haskell.org/package/wai-cors-0.2.4 (larsk)
00:07:41 <mniip> pedantry :v
00:07:42 <nitrix> Shouldn't it be polymorphic?
00:07:45 <ski> ⌜Λ⌝ is completely different from ⌜∀⌝
00:07:59 <mniip> is it?
00:08:01 <zzing> ^ _ ^
00:08:12 <pingu_> pedantry? In #haskell?!
00:08:25 <ski> nitrix : the kind of `forall a. [a]' is `*'. therefore it is monomorphic
00:08:43 <zzing> :k [a]
00:08:45 <lambdabot> Not in scope: type variable ‘a’
00:08:51 <zzing> :k forall a [a]
00:08:52 <lambdabot> parse error on input ‘[’
00:08:54 <zzing> :k forall a. [a]
00:08:56 <lambdabot> *
00:09:06 <ski> @let newtype Flip f a b = MkFlip (f b a)
00:09:07 <lambdabot>  Defined.
00:09:11 <ski> @kind Flip
00:09:12 <lambdabot> (k -> k1 -> *) -> k1 -> k -> *
00:09:30 <nitrix> ski: I'm not sure I'm following. The fact that it's a type variable should make this polymorphic.
00:09:46 <zzing> Good night my friends. Thank you for assistance.
00:09:49 <ski> the kind of this `Flip' is `forall k k1. (k -> k1 -> *) -> (k1 -> k -> *)'. so it has a kind of shape `forall ...', so `Flip' is a polymorphic type
00:09:55 <mniip> nitrix, a type is only polymorphic when it belongs to multiple kinds
00:10:05 <mniip> according to the pedantic definition of "polymorphic"
00:10:22 <mniip> we've been here before
00:10:30 <nitrix> I see. So what I described instead is parametric polymorphism?
00:10:30 * ski prefers to be able to claim that `length' is polymorphic
00:10:45 <nitrix> And not type/kind(?) polymorphism?
00:10:49 <mniip> however I'm interested in how is Λ different in ∀
00:11:14 <mniip> different from*
00:11:22 <ski> and i don't think it helps to claim that both `length' and `forall a. [a] -> Int' are polymorphic, since that would overload the word "polymorphic" with two completely different meanings
00:11:45 <mniip> is there a term for "forall a. [a] -> Int" then?
00:11:56 <mniip> quantified?
00:12:12 <ski> the sense in which `length' is polymorphic, and the sense in which `Flip' above is polymorphic is, i grant, on two different levels (value level and type level). but the meanings are entirely analogous, apart from that
00:12:22 <ski> mniip : i say "universal"
00:12:37 <mniip> in what way is it universal though
00:12:38 <ski> (or "universally quantified", in full)
00:12:52 <ski> `forall' is a universal quantifier
00:12:54 <mniip> would you call 'Show a => a -> String' universal too?
00:13:01 <ski> (`exists' is an existential quantifier)
00:13:19 <ski> mniip : only if you really meant `forall a. Show a => a -> String' by that
00:13:20 <nitrix> ski: Well, people conveniently figured out names for those. I've heard of parametric polymorphism, so that'd be `length` in this case? The parameters are type variables.
00:13:35 <mniip> okay
00:13:38 <mniip> let me rephrase then
00:14:09 <ski> nitrix : the kind of polymorphic we've been talking about is parametric polymorphism, yes
00:14:15 <mniip> Typeable only works on non-universally-quantified types, and, therefore, catch does too
00:14:20 <ski> (as opposed to inclusion polymorphism)
00:17:35 * hackagebot carettah 0.4.2 - A presentation tool written with Haskell.  https://hackage.haskell.org/package/carettah-0.4.2 (KiwamuOkabe)
00:17:36 <ski> nitrix : in System F, ⌜Λ⌝ in an expression gets a type with ⌜∀⌝. e.g. the type of ⌜Λ α. λ x : α. x⌝ is ⌜∀ α. α → α⌝
00:19:20 <ski> (nitrix : "And not type/kind(?) polymorphism?" -- the type-level polymorphism here was also parametric polymorphism)
00:20:33 <ski> nitrix : see section 1.3 of "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf> for some taxonomy on polymorphism
00:23:21 <nitrix> ski: Thanks.
00:23:51 <ski> (in that paper, ⌜Λ α. λ x : α. x⌝ is written as `all[a] fun(x:a) x'. ⌜∀ α. α → α⌝ is written the same, except `a' instead of ⌜α⌝)
00:24:47 <lamefun> Why did (<*>) go into Prelude but not (<>)?
00:25:01 <pikajude> is that a joke setup?
00:27:23 <anohigisavay> hi. not sure if it's the right place to ask. i never learned compilers and formal language. is it possible to fully define a indentation-sensitive language (e.g. Python) with CFG?
00:28:32 <pyon> anohigisavay: It's possible to decouple the context-sensitivity, and push it into the lexer. :-)
00:29:36 <anohigisavay> pyon: so CFG alone is not possible right?
00:30:08 <pyon> anohigisavay: A CFG can't, by itself, handle Python-style significant whitespace.
00:31:35 <anohigisavay> pyon: thanks man :) 
00:31:59 <pyon> :-)
00:36:00 <mniip> ayy pyon
00:38:34 <pyon> mniip: hai
01:11:44 <runeks> Is it possible to have a list with items of different types if the types are of the same class? I can't get it to work in ghci, but I'm not sure if I'm missing something.
01:15:42 <runeks> I have a function with the following type signature, and I want to use it with the Data.Foldable.foldM function
01:15:45 <runeks> processTx :: Transaction a => ChainState -> a -> Either String ChainState
01:16:04 <lyxia> runeks: something like this https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
01:16:17 <lyxia> (see first example)
01:17:04 <lyxia> you kinda have to wrap it by hand though
01:17:10 <runeks> lyxia: Thanks! I will take a look at that.
01:17:33 <runeks> lyxia: Does it incur a performance penalty?
01:18:38 <ski> runeks : dictionaries for the `Transaction' will have to be bundled with the list elements at run-time
01:18:42 <quuxman> has anybody played with the Tidal library?
01:18:46 <ski> s/will/constraints will/
01:20:32 <runeks> I guess I'll have to run it to find out
01:21:19 <quuxman> almost all the examples use "d1" and I can't find it anywhere in the library
01:21:48 <quuxman> and I get a type error for every pattern string: Couldn't match expected type ‘Pattern String’ with actual type ‘[Char]’
01:22:16 <phadej> quuxman: OverloadedStrings extension not on?
01:23:27 <nomeata> Hi. I’m a bit disappointed: No out-of-the-box library that implements ICMP ping on hackage? 
01:23:33 <quuxman> phadej: ahah, yes, just needed -XOverloadedStrings
01:23:44 <quuxman> but I still can't find d1
01:24:41 <quuxman> is where a way to search for a definition in a list of modules, or all modules installed?
01:25:59 <nomeata> Maybe I’ll abuse the dns package to send out network “pings”
01:35:06 <Ongy> is there a *good* way to write (-1) as a section in haskell? The usual syntax that works with (*1) does not work, because the '-' is read as unary negation instead of the binary subtraction operator
01:36:28 <Ongy> well (+ (-1)) works, but it isn't pretty
01:36:29 <quuxman> Ongy: subtract 1
01:36:42 <Ongy> thx
01:37:01 <Ongy> :t -
01:37:02 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
01:37:08 <Ongy> :t (-)
01:37:09 <lambdabot> Num a => a -> a -> a
01:37:18 <Ongy> :t (-1)
01:37:19 <lambdabot> Num a => a
01:38:37 <MarcelineVQ> There's a few ways but by the time you get to something like `(flip (-)1)` it's best to just start with subtract, for clarity
01:47:44 <ski> Ongy : `subtract 1'
01:47:54 <ski> (oh, quuxman said)
02:45:54 <shock_one> Hi. In Aeson, is it possible to provide a default value which would perform IO (but only when there is no value in JSON)?
02:48:19 <pavonia> Default for what?
02:50:23 <athan> shock_one: Don't think so, json parsing isn't supposed to interact with IO
02:56:02 <shock_one> Thank you, athan.
02:56:21 <athan> np :)
03:12:40 * hackagebot mustache 0.5.1.0 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-0.5.1.0 (justus)
03:21:06 <nshepperd> hello,
03:32:41 * hackagebot agda-snippets-hakyll 0.1 - Literate Agda support using agda-snippets, for Hakyll pages.  https://hackage.haskell.org/package/agda-snippets-hakyll-0.1 (LiamOConnorDavis)
03:32:50 <lamefun> What library to read ZIP archives with?
03:36:02 <Rembane> lamefun: This maybe? https://hackage.haskell.org/package/zip-archive
03:36:44 <lamefun> lazy IO only...
03:40:42 <ocramz> hi all
03:42:20 <ocramz> I'm looking at the Functor instance of `StateT s m`; what does the tilde `~` do, in this case? `fmap f m = StateT $ \ s -> fmap (\ ~(a, s') -> (f a, s')) $ runStateT m s`
03:42:41 * hackagebot agda-snippets-hakyll 0.1.1 - Literate Agda support using agda-snippets, for Hakyll pages.  https://hackage.haskell.org/package/agda-snippets-hakyll-0.1.1 (LiamOConnorDavis)
03:46:02 <ski> ocramz : it's called a "lazy pattern". it delays pattern-matching the value to the pattern inside `~', until a variable bound by that pattern is demanded
03:46:54 <ocramz> ski: thank you
03:47:08 <ocramz> is it standard Hs ?
03:47:26 <ski> yes
03:47:35 <ski> an example use of it is
03:47:37 <ski> @src partition
03:47:37 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
03:47:37 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
03:47:37 <lambdabot>                               | otherwise = (ts, x:fs)
03:47:46 <ski> > (take 4 *** take 4) (partition' even [0 ..])
03:47:47 <lambdabot>      Not in scope: ‘partition'’
03:47:47 <lambdabot>      Perhaps you meant one of these:
03:47:47 <lambdabot>        ‘partition’ (imported from Data.List),
03:47:51 <ski> er
03:47:55 <ski> > (take 4 *** take 4) (partition even [0 ..])
03:47:56 <lambdabot>  ([0,2,4,6],[1,3,5,7])
03:48:16 <ski> (the `take 4 * take 4' part just take the first four elements out of each of the two result lists)
03:48:25 <ski> if you define a variant of it, without `~'
03:48:29 <ski> @let partition' p xs = foldr (select p) ([],[]) xs where select p x (ts,fs) | p x = (x:ts,fs) | otherwise = (ts,x:fs)
03:48:30 <lambdabot>  Defined.
03:48:33 <ski> then you get
03:48:37 <ski> > (take 4 *** take 4) (partition' even [0 ..])
03:48:39 <lambdabot>  (*Exception: stack overflow
03:48:47 <ocramz> uhm
03:48:52 <ski> iow, it doesn't work for infinite lists. using `~' fixes this
03:49:19 <ski> ocramz : if you want to, you could figure out why `~' helps here
03:50:17 <olzhas> Is there any common idiom to check for divisibility in Haskell instead of writing " x `mod` y == 0" all the time?
03:50:35 <ski> using the pattern `~(ts,fs)' here is equivalent to using the pattern `tsfs' and replacing `ts' by `fst tsfs' and `fs' by `snd tsfs'
03:51:48 <ski> olzhas : i don't really think so
03:51:56 <ocramz> ski: I'm processing :)
03:52:01 <ski> (maybe someone has defined a `divides' shorthand for it)
03:52:13 <ocramz> yes I knew (***) from Arrow, very handy
03:52:46 <ski> @src (->) (***)
03:52:46 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
03:52:51 <ski> also happens to use `~' :)
03:53:13 <ski> @src (->) second
03:53:14 <lambdabot> second f = id *** f
03:53:19 <ski> amounts to
03:53:29 <ski>   second f ~(x,y) = (x,f y)
03:53:32 <ski> while otoh
03:53:37 <ski> @src (,) fmap
03:53:38 <lambdabot> fmap f (x,y) = (x, f y)
03:53:44 <ski> doesn't use `~'
03:54:13 <ski> (if it did, then `fmap id undefined' wouldn't be `undefined', but rather `(undefined,undefined)')
03:55:40 <ocramz> ski: I'm not sure I follow here
03:55:42 <ski> ocramz : .. in case the lazy pattern doesn't match, you get a pattern-match failure at run-time, rather than the next equation/branch being tried. so you better make sure the pattern will match, if ever forced
03:56:11 <ski> > case fmap id undefined of (_,_) -> ()
03:56:12 <lambdabot>  *Exception: Prelude.undefined
03:56:17 <ski> > case second id undefined of (_,_) -> ()
03:56:18 <lambdabot>  ()
03:57:34 <ski> in the latter case, since we're not forcing the `x',`y' components of the returned `(x,y)' pair (from `second', ultimately from `(***)'), we're never actually matching the input `undefined' with the pattern `(x,y)' inside the lazy/irrefutable pattern `~(x,y)'
03:59:00 <ocramz> ski: ok, this is making sense now
03:59:20 <ski> `fmap id' is supposed to be the same as `id'
04:02:52 <ski> ocramz : btw, note that that is the `Lazy' version of `StateT' (as opposed to the `Strict' one)
04:03:21 <ocramz> ski: yes, indeed :) so I guess in ST the same instance would be strict?
04:03:47 <ski> there are `Lazy' and `Strict' variants for `ST' as well
04:04:47 <ocramz> and indeed, in Trans.State.Strict, `instance (Functor m) => Functor (StateT s m) where     fmap f m = StateT $ \ s -> fmap (\ (a, s') -> (f a, s')) $ runStateT m s`
04:04:52 <ocramz> strict pattern matching
04:07:13 <ski> ocramz : see "control.monad.state.lazy" in 2010-11-25,2013-02-27 at <http://lpaste.net/41790> and "lazy ST example" in 2012-02-18,2012-05-26,2013-03-29 at <http://lpaste.net/63925>, both by monochrom
04:09:32 <ocramz> but, as a rule, if one is not expecting infinite streams, would strict patterns be fine?
04:10:02 <ocramz> sorry, poorly phrased
04:11:15 <ski> not necessarily. you might be feeding (part of) the output back as (part of) the input, in which case it may be essential to provide a few of the top constructors of the result, before demanding to know the first few top constructors of the input
04:12:31 <ski> and possibly you might also want `~' in some case to get incremental computation. i'm not sure
04:12:58 <ocramz> incremental computation ?
04:13:46 <ski> the idea being that the problem with an infinite stream is that you don't want to wait until you've seen it all, before generating progress
04:14:34 <ocramz> sure
04:14:34 <ski> but that can also apply to a finite, but long, list. you may want to avoid slurping it all into memory, at the same time
04:14:55 <ocramz> pipes and conduits and the like
04:15:26 <ski> so i was figuring that maybe there was a case where using `~' could help with avoiding that. as i said, i'm not sure whether there is such a case or not
04:16:39 <ski> (`foldl' doesn't work on infinite lists because it's tail-recursive, which means it's "bulky", not "incremental" (like `map' is .. and i suppose one could perhaps say `filter' is "semi-incremental"))
04:17:01 <lf94> Is there a way to....have foldl/r increment a variable?
04:17:15 <lf94> calculateHash key = foldl (\b a -> b + (chr a)*31**((length key)-currentChar)) 0 key
04:17:20 <lf94> I need currentChar to increment
04:17:48 <RainBowww> i need penis enlargement  :(
04:17:53 <RainBowww> ups
04:17:55 <ski> lf94 : pass it around as part of the accumulator state ?
04:18:09 <lf94> ski: great idea.
04:18:35 <ski> can `key' be long ?
04:18:40 <RainBowww>  :)
04:19:56 <ocramz> ski: thank you for all these pointers, they will require some meditation
04:20:07 <ski> np
04:20:56 <ski> lf94 : should it be incremented once in each step, or ?
04:21:08 <lf94> yep, it's fine
04:21:17 <lf94> calculateHash key = foldl (\(hash,index) char -> (hash+(ord char)*31^((length key)-index),index+1)) (0,0) key
04:24:42 <ski> lf94 : why not `foldl (\(hash,index) char -> (hash + ord char * 31^index,index - 1)) (0,length key)', then ?
04:25:08 <lf94> well that's going the other way :)
04:25:33 <ski> (decrementing instead of incrementing, avoiding having to subtract it from `length key' each time (`length key' is possibly also recomputed then))
04:25:34 <lf94> removes the need for length key
04:25:48 <lf94> Yeah good suggestion :)
04:26:36 <ski> i suppose `key' isn't of a fixed length, or you wouldn't have used `length' ?
04:26:56 <ski> (actually, no matter)
04:26:57 <lf94> yeah, it isn't
04:53:06 <ocramz> any monad transformer gurus in the house?
04:53:19 * hackagebot clang-pure 0.1.0.0 - Pure C++ code analysis with libclang  https://hackage.haskell.org/package/clang-pure-0.1.0.0 (PatrickChilton)
04:55:56 <chpatrick> ocramz: what do you need?
04:56:17 <ocramz> question: I'd like to model generically the act of initializing a storable datastructure with a Vector of numbers, tracking its lifetime with a bracket and possibly modifying it by copying back to a Mutable Vector, operating on it, freezing it back and copying it to Storable
04:56:27 <ocramz> so I'm fiddling with ResourceT and ReaderT
04:57:20 <chpatrick> ocramz: why not use a mutable storable vector?
04:58:13 <ocramz> well there's two pieces of information I have to track
04:58:34 <ocramz> this FFI resource, which does contain a vector of numbers, and the Haskell-side Vector
04:58:43 <chpatrick> hmm
04:58:44 <ocramz> the FFI resource needs to be explicitly deallocated
04:58:52 <chpatrick> have you considered ForeignPtr?
04:58:53 <ocramz> this is why I like bracket and ResourceT
04:59:04 <chpatrick> then the GC deallocates it for you when it's not needed
04:59:14 <chpatrick> it's more composable imo
04:59:52 <ocramz> the one thing I'm not getting about ForeignPtrs is the FinalizerPtr bit
04:59:57 <ocramz> where to obtain one
05:00:14 <ocramz> I mean, I have the wrapped signature of the C finalizer, let's say `a -> IO ()`
05:00:34 <chpatrick> ocramz: you can use any IO function as a finalizer with Foreign.Concurrent
05:00:53 <ocramz> uhm
05:01:14 <chpatrick> but if the finalizer is already a C function of the form void(foo*) then you can just pass a function pointer to it
05:01:17 <chpatrick> and use regular foreignptrs
05:03:20 <ocramz> chpatrick
05:03:26 <ocramz> thanks :)
05:03:33 <chpatrick> no worries
05:03:46 <ocramz> however this would be the 4th refactor of my FFI internals :/ 
05:03:54 <chpatrick> hehe I've been there
05:04:05 <chpatrick> if you want one more protip, check out inline-c
05:04:13 <chpatrick> it makes FFI type-safe and fun
05:04:32 <ocramz> I'm actually using the latest inline-c
05:04:41 <ocramz> but not all features
05:05:08 <ocramz> there's the vec-ptr antiquoter, f.ex., that I haven't explored
05:06:42 <lpaste_> aphocus pasted “Cabal hell” at http://lpaste.net/144793
05:08:12 <aphocus> Is this because I have ghc 7.10?
05:09:27 <ocramz> chpatrick: could you point me to a decent repo using ForeignPtr that shows what you mean?
05:10:50 <chpatrick> ocramz: is the problem with the finalizerptr?
05:13:08 <ocramz> no, actually there is no problem at that level, I already use mutable vectors as an intermediate form between Hs pure data and the FFI data. My problem is with the enormous amount of replicated code that does more or less the same thing all the time: get configuration and contents, write to Storable; or, copy from Storable
05:13:30 * hackagebot hgrib 0.3.1.0 - Unofficial bindings for GRIB API  https://hackage.haskell.org/package/hgrib-0.3.1.0 (mjakob)
05:13:47 <ocramz> I'm looking for a representation to subsume this mess; hence my original question re. transformers
05:17:28 <hexagoxel> aphocus: actually, that is unmaintained-package-hell :D
05:18:00 <hexagoxel> aphocus: yes, graphics-drawingcombinators depends on a pre-7.10 OpenGL package verison
05:18:33 <hexagoxel> aphocus: i'd guess the highest chance of success with --allow-newer=OpenGL
05:19:09 <aphocus> hexagoxel, thanks will try
05:19:22 <hexagoxel> aphocus: (unless you want to use an older ghc)
05:23:18 <aphocus> hexagoxel, no I don't actually haha, I upgraded to get some 64bit support, a friend was curious if it was faster.
05:26:29 <aphocus> Next step is to get llvm to work without breaking my program.
05:49:20 <joco42> what is the most beginner friendly way to do regexp in haskell?
05:50:20 <Clint> joco42: what do you mean by "do regexp"
05:50:38 <joco42> according to hackage there are gizillion ways to do regexp
05:50:48 <joco42> https://wiki.haskell.org/Regular_expressions
05:51:02 <joco42> Clint:  ^ which one should a newbee chose
05:51:09 <joco42> for some super simple stuff
05:51:18 <joco42> no performance issues
05:52:38 <Clint> they're all pretty messy
05:53:35 <joco42> oh $hit....
05:53:53 <athan> joco42: I've found regex-compat to be easy if you want to write string-based regexes
05:53:59 <joco42> is there some irc wizzdom ?
05:54:07 <athan> joco42: But I've heard regex-applicative is the way-to-go
05:54:17 <joco42> athan: ... ok ... cool, thanks
05:54:20 <joco42> i have a look
05:56:04 <joco42> there is even a video https://vimeo.com/42462403
05:56:05 <joco42> cool
05:58:32 <aphocus> hexagoxel, hey, thanks man, got it working :)
05:58:42 <chpatrick> joco42: haskell has this really cool library called parsec that people usually use instead of regex
05:58:51 <chpatrick> it's a bit more involved but it's definitely worth learning if you have the time
05:59:25 <joco42> chpatrick:  should i really use parsec for a simple regexp?
05:59:35 <chpatrick> joco42: depends on what you're doing
05:59:48 <chpatrick> can you tell me the regex?
06:00:59 <joco42> chpatrick - i try to do this in haskell https://usercontent.irccloud-cdn.com/file/lGZdB7NF/Screen%20Shot%202015-11-07%20at%2016.00.04.png
06:01:06 <hexagoxel> aphocus: great! might be worth adding an issue in graphics-drawingcombinators, especially if it is fixable with a simple bound bump, as it seems to be the case.
06:01:21 <joco42> i have the s=sp... part
06:01:33 <joco42> now i wanna do the  m=re.search part...
06:02:27 <chpatrick> you could do
06:02:41 <chpatrick> one moment
06:04:13 <chpatrick> do { width <- integer; char 'x'; height <- integer }
06:04:27 <chpatrick> that's a parsec parser for the same thing
06:04:32 <chpatrick> no groups etc
06:04:40 <aphocus> hexagoxel, done
06:05:05 <joco42> chpatrick:  hmmm
06:05:28 <dzhus> since when has `in` become an invalid variable name? did it happen in 7.10?
06:05:29 <joco42> interesting
06:05:49 <joco42> chpatrick:  lemme try that
06:12:16 <ahihi> dzhus: it's been a keyword for a long time
06:18:43 <joco42> chpatrick, what am i doing wrong ? https://usercontent.irccloud-cdn.com/file/Od80Zve1/Screen%20Shot%202015-11-07%20at%2016.17.37.png
06:19:42 <chpatrick> joco42: try the new megaparsec package
06:19:54 <joco42> ok, i try
06:20:09 <chpatrick> there it's under Text.Megaparsec
06:22:52 <obadz> dzhus: let x = y IN f x
06:24:56 <joco42> chpatric - it kinda gives this error https://usercontent.irccloud-cdn.com/file/RZ6e34vi/Screen%20Shot%202015-11-07%20at%2016.23.48.png
06:25:35 <joco42> ok flexible contexts needs to be enabled
06:25:46 <joco42> i hope that is ok
06:25:52 <chpatrick> that should work
06:32:27 <joco42> chpatrick, it kind works, but if i have spaces then it stops working... https://usercontent.irccloud-cdn.com/file/dkvHx5ep/Screen%20Shot%202015-11-07%20at%2016.31.25.png
06:33:34 <joco42> i wanna get the width and height from this string https://usercontent.irccloud-cdn.com/file/Xvopbv3h/Screen%20Shot%202015-11-07%20at%2016.32.38.png
06:33:49 <chpatrick> ok, do
06:34:03 <chpatrick> space; width <- ... ; integer; space
06:34:27 <chpatrick> ie; just put it before and after the whole thing
06:34:47 <joco42> ?
06:35:03 <chpatrick> space; width <- integer; char 'x'; height <- integer; space
06:35:05 <joco42> will that deal with the JPEG and such ?
06:35:22 <joco42> i mean... won't be that a problem ?
06:35:26 <chpatrick> ah I see
06:36:05 <obadz> chpatrick: how does one parse a quoted string? "aa\"aaa\\a\"\\\"aaa" ?
06:36:15 <chpatrick> sorry guys I gotta go
06:36:19 <joco42> :)
06:36:23 <chpatrick> look at the megaparsec docs
06:43:58 <joco42> well... back to regexp... parsec some other day....
06:45:03 <obadz> joco42: what are you trying to do?
06:45:23 <joco42> obadz: https://usercontent.irccloud-cdn.com/file/Xvopbv3h/Screen%20Shot%202015-11-07%20at%2016.32.38.png
06:45:44 <joco42> this regexp:
06:45:48 <joco42> https://usercontent.irccloud-cdn.com/file/lGZdB7NF/Screen%20Shot%202015-11-07%20at%2016.00.04.png
06:45:52 <obadz> here's some inspiration:
06:46:04 <joco42> i got this far with parsec:
06:46:12 <obadz> import           Text.XFormat.Read           ((:%:) (..), IntF (..), readf, (%))
06:46:14 <obadz> parseDate :: String -> Either String Time.Day
06:46:16 <obadz> parseDate s = case readf (Int % "/" % Int % "/" % Int) s of
06:46:18 <obadz>                 Just (y :%: _ :%: m :%: _ :%: d) -> Right $ Time.fromGregorian (fromIntegral y) m d
06:46:20 <obadz>                 _                                -> Left  $ "Cannot parse date: " ++ s
06:46:37 <joco42> https://usercontent.irccloud-cdn.com/file/RBWZKW9g/Screen%20Shot%202015-11-07%20at%2016.45.58.png
06:47:06 <joco42> obadz:  is this ? parsec?
06:47:11 <obadz> nope
06:47:17 <obadz> some regexp-inspired lib
06:47:22 <joco42> aham...
06:47:39 <joco42> :)
06:48:03 <obadz> I don't think you need parsec to parse 1 line with 3 symbols..
06:48:44 <obadz> :q
06:48:48 <obadz> oops
06:49:59 <joco42> yeah...
06:50:03 <joco42> i dont thing either
06:50:23 <joco42> it was chpatrick's suggestion...
06:50:57 <joco42> and i was curious about parsec...
06:51:05 <joco42> but it kinda does not work....
06:51:12 <obadz> oh I'm sure it works :)
06:51:19 <joco42> so i just do regexp before the sun goes down....
06:51:37 <joco42> it works if u know how to use it....
06:51:42 <joco42> but i dont
06:51:43 <joco42> yet
06:51:48 <obadz> best way to do regexp in Haskell that I found is what I pasted
06:52:20 <joco42> well - i guess i just go with regex-compat
06:52:26 <joco42> for the time being...
06:56:01 <obadz> found that to be more difficult than what I pasted
06:58:25 <k0ral> Hello
06:59:05 <k0ral> is there a function to have a thread sleep for a precise amount of CPU time ?
06:59:46 <ski> dzhus : afaik, `in's been present from the start. in any case since Haskell98
06:59:47 <hpc> threadDelay
07:00:21 <aphocus> does anyone know where to get a ghc compatible llvm for windows?
07:09:20 <joco42> it seems i want regex-pcre....
07:12:55 <k0ral> hpc: threadDelay doesn't seem to measure CPUTime, but wall time
07:13:20 <hpc> oh, i see
07:13:38 <hpc> what are you using it for?
07:13:54 <hpc> even in C you don't usually need that
07:14:02 <k0ral> hpc: also threadDelay only guarantees that the thread will sleep at least some duration, but it may sleep more
07:15:06 <k0ral> hpc: I'm writing an algorithm that must return a result within some CPU time
07:16:09 <k0ral> hpc: I forked a worked and I want to kill it in case it has consumed its allocated CPU time
07:16:13 <k0ral> a worker*
07:16:56 <k0ral> hpc: so basically I want the main thread to sleep during a fixed CPU time, and kill the worker thread afterwards
07:19:25 <monochrom> that plan is still flawed. at the time the killer thread has been given 10ms of CPU time, you still have no idea how much CPU time has been given to the worker thread.
07:20:46 <k0ral> monochrom: doesn't getCPUTime return the process CPU time, rather than the thread CPU time ?
07:21:02 <monochrom> I don't know. is it relevant?
07:22:19 <k0ral> monochrom: unless I'm mistaken, if the killer thread can measure the total process CPU time = killer thread CPU time + worker thread CPU time, then assuming killer thread CPU time = o(worked thread CPU time), this plan makes sense to me
07:24:02 <monochrom> ok, but then you don't need "sleep for x units of CPU time"
07:24:54 <monochrom> since you have to getCPUTime then check anyway, you may as well "loop: sleep for y units of wall time, getCPUTime, check"
07:25:25 <monochrom> I mean, now that you brought up getCPUTime.
07:28:00 <k0ral> it would be better if I could sleep for y units of CPU time
07:28:09 <monochrom> no, it is worse.
07:28:36 <k0ral> I don't know how much wall time I can afford to sleep
07:29:25 <k0ral> if y is too high, then there's a risk I will have consumed too much CPU time in the process
07:29:55 <k0ral> if y is too low, I will have unnecessarily woken up multiple times before I actually want to kill the worker thread
07:31:21 <monochrom> for the plan "loop: sleep x CPU time, check CPU time", for all x, there exists a scheduling such that when the killer thread wakes up, the worker thread has been given way more than 10ms. (I am making up 10ms as the limit you want on the worker thread.)
07:31:55 <k0ral> the pan is not exactly that
07:32:08 <monochrom> instead, if you use wall time, then the inequality "wall time >= CPU time" helps
07:32:32 <k0ral> it's: "fork worker thread; sleep x CPU time; kill worker thread"
07:32:45 <monochrom> that is even worse than the worst plan
07:32:52 <k0ral> this inegality doesn't hold, since you have multiple cores
07:33:10 <monochrom> well yeah but I am pessimistic
07:33:34 <k0ral> Oo
07:33:55 <monochrom> no, that isn't relevant. one thread doesn't get parallelized over 1000 cores
07:34:45 <k0ral> one thread can spawn new ones, in the end the worker thread may use multiple cores
07:34:58 <monochrom> the inequality is "wall time >= how much CPU time the worker thread has used"
07:35:34 <monochrom> well ok thank you for the problem modification
07:36:08 <k0ral> you assumed more than I said
07:38:55 * hackagebot quantities 0.4.0 - Unit conversion and manipulation library.  https://hackage.haskell.org/package/quantities-0.4.0 (jdreaver)
07:40:00 <k0ral> actually, even withing a single "Haskell" thread, you can parallelize some computations on multiple cores using Control.Parallel
07:40:08 <k0ral> within
07:40:39 <monochrom> you know what, the whole notion of "sleep for x CPU time" is a self-contradiction
07:41:45 <monochrom> ok, but you mean "sleep until all threads have used x CPU time in total".
07:42:06 <monochrom> that would be nice if it existed. I have never heard of it.
07:42:08 <k0ral> sleep until the *process* CPU time has reached some value
07:42:19 <k0ral> ok, good, that's the answer I wanted to hear
07:48:40 <k0ral> side question: I'm reading that there is no guarantee that throwTo (used by killThread) is able to deliver the exception promptly; it means I may actually allow the worker thread to consume extra CPU time; is there an alternative way to kill a thread that guarantee it is done right away ?
07:49:41 <mauke> that sounds very unsafe
07:50:54 <k0ral> I guess this is a naive question
08:03:11 <jaseemabid> I'm fiddling with an app which will do frequent writes to a file. Should I keep a reference to a fileHandle and use that repeatedly or is it alright to open and close each time? Is there a massive performance difference? 
08:03:55 * hackagebot cyclotomic 0.4.4 - A subfield of the complex numbers for exact calculation.  https://hackage.haskell.org/package/cyclotomic-0.4.4 (ScottWalck)
08:04:26 <zzing> Could anyone give a hint as to why I get a complaint about the let on line 32 (missing the 'in') of this? https://gist.github.com/madebyjeffrey/011b70447b87469222bb
08:06:33 <MarcelineVQ> zzing: you might need to align the Nothing and following lines with case
08:07:10 <henk> hi, I’m trying to get lambdabot running and wrote a "online.rc" file according to the example. The bot can connect to the irc server just fine, but does not join a channel. I assume the output means that I have a syntax error or something in the config but can’t figure it out. http://pastie.org/private/jo3yiweauknxkotkkmzmhg shows the online.rc and the output when running lambdabot. Anyone know what
08:07:11 <henk> I’m doing wrong?
08:07:11 <ski> zzing : the remaining body lines of the definition needs to be indented more than the start of it
08:08:04 <int-e> henk: join expects the network name: join /space/home/bf3/bat/src-hs/lambdabot/lambdabot/scripts/online.rc
08:08:07 <int-e> arg
08:08:20 <int-e> henk: join netwichtig:#netwichtig
08:08:33 <zzing> ski, some of the examples here don't do that: https://en.wikibooks.org/wiki/Haskell/do_notation#Returning_values
08:08:55 * hackagebot xmonad-windownames 0.1.0.1 - A library to automatically put named windows into the DynamicLog.  https://hackage.haskell.org/package/xmonad-windownames-0.1.0.1 (plindbe2)
08:09:20 <ski> zzing : i don't see an example there that doesn't do that
08:09:21 <henk> int-e: hrm, yes, I agree: arg … I tried both variants actually and wanted to copy the one with the network name … let me make a new paste with updated info.
08:09:22 <zzing> I wonder if there is a better way to do that function (there is more that comes after, but not written yet)
08:09:55 <zzing> ski, in the nameReturn function it has a let that is aligned with the lines after
08:10:42 <ski> zzing : those trailing lines aren't part of the definition of `full' there
08:11:39 <zzing> ski, I am not sure I am understanding. It defines full and then uses it after. I am defining headings' and wanting to use it after (just not written yet).
08:11:44 <ski> zzing : in your case, all the trailing lines but `pure ()' at the end are supposed to belong to the definition of  heading'  but some of them aren't indented further than the starting `h' in that definition
08:12:07 <ski> it should be :
08:12:07 <zzing> oh, the 'h'?
08:12:12 <ski>   let headings' = case heading_line of
08:12:18 <ski>              
08:12:24 <ski>         Nothing -> error "No header input"
08:12:32 <zzing> ok, that makes sense
08:12:34 <ski>         Just x -> ...
08:12:42 <zzing> It wasn't clear before
08:12:59 <ski> a single `let' there can contain several defining equations
08:13:07 <zzing> yes
08:13:16 <ski> each new defining equation would start at the indentation level that the first one started at
08:13:27 <zzing> ski, would you define that let in this way or do it in another way?
08:13:41 <btcNeverSleeps> just spent 12 hours in Stack / lib dependencies hell trying to make Emacs + haskell-mode + ghc-mod work together.  Pure hell.
08:13:51 <ski> i'm not sure. i haven't seen how you intend to use  headings'  yet
08:14:01 <zzing> fair
08:14:15 <btcNeverSleeps> I'm giving up on Haskell (despite having already used it for a few months) as of now until the tooling improves.  This is just maddening.
08:14:36 <zzing> btcNeverSleeps, have you tried a regular text editor and ghci in a terminal?
08:15:00 <btcNeverSleeps> I've been coding since 20+ years (and using Emacs since that long).  I just give up on Haskell and wait, say, one more year until things improve.
08:15:09 <btcNeverSleeps> zzing: I've tried so many things.  Thought I had it working
08:15:31 * zzing hates emacs
08:15:32 <btcNeverSleeps> zzing: I could complete, even use ghci-ng but then as I started coding...
08:15:47 <mauke> zzing: I think that's a "no"
08:16:06 <int-e> henk: I'll be afk for about half an hour; I can help you later if you still have trouble.
08:16:32 <btcNeverSleeps> first import I added and all hell broke lose.  I thought I was, at last, good to go but no.  Dependencies hell, broken. I'm done with it.  Cya in one year all.
08:16:46 <henk> int-e: http://pastie.org/private/vhxffmpuqjwyotr3cxfww updated
08:17:12 <henk> int-e: It connects fine when I leave out the network-name in front of the channel-name, but then does not autojoin …
08:17:25 <henk> int-e: yeah, sure, thank you (: though I’ll probably be gone later too …
08:26:50 <zzing> I just modified my code, but it has me wondering what error handling options are there. I am using fail right now: https://gist.github.com/madebyjeffrey/8243610d5f640351c964  (line 29 to 38)
08:28:38 * ski thinks it looks a bit strange to see `pure' used with `do'-notation
08:29:07 <zzing> return is a poor name
08:29:32 <zzing> I actually think 'lift' is a little better name because lifts it into the typeclass
08:29:38 <monochrom> it is future-proof for "monad with no return" :)
08:29:39 <ski> and you can, if you want to, remove  headings' <-  and   pure headings'
08:30:07 <henk> gah, when I start plain "lambdabot" and then enter every line in my online.rc (with @ in front), it joins the channel o_O
08:30:11 <zzing> ski, but the return value for fail is m a
08:30:23 <ski> so ?
08:30:39 <zzing> headings' is [Heading]
08:30:43 <zzing> not m [Heading]
08:31:01 <zzing> That would make the values not the same type
08:31:03 <ski> hm, i should have been more clear. i meant only the last  pure headings'
08:31:50 <ski>   do ...
08:31:59 <ski>      headings' <- case ...
08:32:04 <ski>      pure headings'
08:32:07 <ski> is the same as just
08:32:09 <ski>   do ...
08:32:14 <ski>      case ...
08:32:59 <zzing> I have to use headings' afterwards, in an awaitForever
08:33:11 <zzing> showing around line 40 or so
08:33:13 <zzing> in the comment
08:33:19 <ski> inside `processCSV' ?
08:34:26 <zzing> yes, after the headings' <- case ... I am going to be doing  something like     awaitForever (\y -> yield (x,y))
08:34:42 <ski> using  headings'  somethere in there ?
08:34:54 <zzing> yes
08:34:56 <ski> ok
08:35:18 <ski> you could instead pull that later stuff into the `Right' branch .. but you might not prefer that
08:35:39 <monochrom> I would put it inside the Right branch
08:35:48 <zzing> I prefer as flat of functions as possible, if it weren't a matter of having all this I would be doing maybe and either functions
08:36:11 <zzing> glguy was the person who suggested the awaitForever. 
08:36:14 <ski> you'd need fewer temporary variables, if you pulled it in
08:36:16 <zzing> I was going to be using isolate
08:36:18 <monochrom> the flat structure is sometimes a lie.
08:36:27 <zzing> monochrom, I like cake
08:37:00 <monochrom> a cake doesn't lie
08:37:07 <zzing> But the cake could be a lie
08:37:25 <monochrom> no, a cake isn't a lie either
08:37:29 <ski> hm .. i suppose the following wouldn't be possible ?
08:37:31 <ski>   do ...
08:37:40 <ski>      case ... of
08:37:45 <ski>        Nothing -> ...
08:37:54 <ski>        Just x -> do
08:37:59 <ski>      case ... of
08:38:07 <ski>        Left y -> ...
08:38:10 <zzing> monochrom, I was lead to believe that the cake is a lie.
08:38:13 <ski>        Right z -> do
08:38:17 <ski>      ...
08:39:13 <zzing> ski, nested dos don't look nice ;p
08:39:24 * ski str the GHC indentation thing didn't work like this, mixing in deeper nested layout blocks inbetween
08:40:59 <monochrom> yeah, it's illegal
08:41:01 <zzing> monochrom, http://cdn.duelinganalogs.com/comics/2010-11-17.png 
08:41:15 <monochrom> but add explicit {;}s to force it :)
08:42:04 <monochrom> a pie is not a lie either. a pie is a pie. "a pie is a lie" is a typo when trying to state a tautology.
08:42:21 <andromeda-galaxy> I was thinking that it would be fun to do an operating system in haskell sometime (if it really needs some low-level parts, I'd try to use Rust for those) and found Rebekah Leslie's dissertation 
08:42:33 <andromeda-galaxy> Does anyone know if the code for that is available anywhere?
08:42:47 <monochrom> and a lie group is not a lie either
08:42:57 <zzing> eat :: (forall p. Pie p, Consume c) => p -> c ()
08:43:25 <monochrom> you need to put the "forall p." outside the parentheses
08:43:31 <icantsokoban> hey can I get help fixing incorrect identation? I can't fix it
08:43:41 <andromeda-galaxy> (the dissertation is http://pdxscholar.library.pdx.edu/cgi/viewcontent.cgi?article=1498&context=open_access_etds)
08:44:57 <monochrom> icantsokoban: you can post verbatim unabridge complete self-contained code on lpaste.net and ask people to take a look
08:45:37 <zzing> andromeda-galaxy, http://leslier.com    see if you can find an email on here and email the person
08:46:16 <ski> yes, i was thinking about `NondecreasingIndentation', <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs-and-infelicities.html#infelicities-syntax>
08:46:18 <icantsokoban> Can you guys take a look plese? http://lpaste.net/144804
08:46:24 <andromeda-galaxy> zzing: okay, I'll do that... I was just wondering if anyone else knew anything about it
08:47:12 <mauke> icantsokoban: that doesn't even have 11 lines
08:47:33 <icantsokoban> I know right? Something must be wrong
08:47:55 <icantsokoban> oh I forgot to paste the module Main where
08:47:57 <mauke> you pasted the wrong file
08:48:01 <icantsokoban> those are the missing lines
08:48:30 <icantsokoban> @mauke I just didn't paste the "module Main where" line plus the spaces
08:48:30 <lambdabot> Unknown command, try @list
08:48:52 <mauke> yeah, I'm not interested
08:49:01 <mauke> I hate when people do that
08:49:18 <monochrom> icantsokoban: in the very last "if-then", you have no "else".
08:49:53 <monochrom> but yeah I need to explain to you what "verbatim unabridged complete self-contained" means
08:50:22 <henk> int-e: I was trying to use the lambdabot package in debian stable which may be a little broken. Now I’m going to try with a git checkout, but to do cabal build I seem to be missing a lot of depends. I’ll be back with further info/questions probably (: thanks for your help and time!
08:50:51 <monochrom> it means when I put your paste in my file (and cut away the error message you attach, I can do that) and perform a :load, I get the same error message as yours.
08:51:31 <int-e> henk: can you try the hackage one? cabal install lambdabot  in a sandbox, perhaps?
08:51:33 <icantsokoban> monochrom uh thanks :b 
08:53:12 <henk> int-e: sure, will do, but I need to go now. I’ll report how that goes in either a few hours or some time in the next days (:
08:55:53 <monochrom> my fundamental criterion is scientific reproducibiity
08:56:25 <zzing> (and cake)
08:56:49 <zzing> Does lpaste support automatic compilation and such? I
08:57:10 <monochrom> no. it only has automatic hlint nagware
08:57:44 <monochrom> some other pastebin does, but it has its problems, the most significant being: using a very old GHC
09:11:19 <icantsokoban> Hey can anyone look at this please? I need some help... http://lpaste.net/144811
09:12:45 <mauke> hmm. looks like you don't understand what : does
09:13:28 <icantsokoban> maybe I made a mistake mauke, I've been "programming" for almost 10 hours now, pretty tires
09:13:58 <mauke> given that you're getting type errors, I'd say you've definitely made a mistake
09:14:27 <icantsokoban> I am pretty lost here
09:14:41 <icantsokoban> Been experimenting for several hours already :/
09:14:52 <mauke> can you describe what : does?
09:15:49 <icantsokoban> yes
09:16:22 <icantsokoban> [1,2,3] : [4,5,6] : [] = [[1,2,3],[4,5,6]]
09:17:34 <icantsokoban> ' ' : "###" = " ###"
09:18:20 <mauke> can you describe it in english?
09:18:37 <icantsokoban> I think it pairs lists? 
09:18:54 <mauke> what do you mean by "pairs"?
09:18:59 <icantsokoban> or puts lists together in a single list maybe
09:19:08 <mauke> ' ' is not a list
09:19:14 <icantsokoban> it's a char
09:20:16 <icantsokoban> so, why are you asking me this? I know I still make beginner mistakes, but I am indeed a beginner
09:20:46 <mauke> to gauge your level of knowledge
09:20:57 <mauke> and because it's relevant to the type error in your code
09:21:39 <mauke> : takes an element x and a list y and gives you a new list (whose first element is x and the remaining elements are y)
09:21:43 <stephenmac7> Any way to make "and . getZipList $ ZipList [odd, even] <*> ZipList [1]" return False if there are not enough elements in the second list?
09:21:45 <icantsokoban> well mauke I am a beginner and just started studying higher order functions a little time ago
09:21:47 <stephenmac7> ! and . getZipList $ ZipList [odd, even] <*> ZipList [1]
09:21:57 <mauke> in particular, in x : y, y is always a list
09:22:24 <stephenmac7> ...forgot the lambdabot operator...
09:23:23 <mauke> icantsokoban: you get a type error in 'aux (reverse (xs : t)) : x
09:23:35 <mauke> ' because x is not a list but : requires it to be
09:23:50 <icantsokoban> so should I use [] there?
09:24:24 <mauke> what do you want it to do?
09:25:00 <icantsokoban> I want it to keep the last # before it reverses the list and starts working on the other side
09:25:25 <icantsokoban> keep it in the same position as before, that is
09:26:33 <mauke> if by "keep" you mean "append it to the string returned by aux", you can do that with aux (reverse (xs : t)) ++ [x]
09:27:22 <mauke> x is a Char. [x] is the length 1 String (whose only element is x). ++ concatenates two lists (strings are a particular type of list)
09:27:24 <roelof> I just learned to make a function that uses a custom data structure this way ; http://lpaste.net/144813
09:27:30 <icantsokoban> will that make the list go from "   #  ###" to "###  #   "?
09:27:44 <stephenmac7> @run and . getZipList $ ZipList [odd, even] <*> ZipList [1]
09:27:46 <lambdabot>  True
09:27:46 <roelof> Now I wonder how I can take care that only numbers above the zero are used 
09:27:53 <roelof> how can I do this ? 
09:28:35 <mauke> icantsokoban: no, because according to your type signature, the input is a list of strings, not a string (a list of chars)
09:28:47 <mauke> hmm, so the whole thing can't actually work
09:29:03 <icantsokoban> :/
09:29:32 <mauke> aux, as written, has type [String] -> String
09:29:47 <icantsokoban> what do you suggest me to do, if I may ask? I want to turn "###  #  ###" into "  #  #  #   "
09:30:07 <icantsokoban> so basically remove the outer cardinals
09:30:17 <mauke> I don't know what you mean by cardinals
09:30:33 <icantsokoban> #
09:30:39 <icantsokoban> the outer #
09:31:03 <icantsokoban> oh so that has a different name in english? sorry
09:31:12 <mauke> (those are usually called "hash" (or "pound" (but only in america) or "octothorpe" (if you're feeling silly)))
09:31:34 <icantsokoban> haha my bad
09:31:39 <mmachenry> … or Tic Tac Toe board. 
09:31:43 <mauke> the official unicode name is "NUMBER SIGN". huh.
09:33:10 <mauke> roelof: you can't really do that in the type itself. you can make the type abstract and only export restricted constructor functions; search for "smart constructors"
09:33:12 <icantsokoban> so, mauke, what am I doing wrong there and what can I do to make it right? I am not necessarily asking you to do it for me, but I need someone to point me in the right direction
09:34:24 <mauke> I don't understand the spec yet
09:34:57 <mauke> apparently you're replacing some #'s by spaces
09:35:12 <icantsokoban> yes, I am
09:35:18 <icantsokoban> so i can keep the level structure
09:36:04 <icantsokoban> "## # ##" into " # # # " and this way the structure is preserved
09:36:33 <mauke> I don't see how this is valid
09:36:40 <icantsokoban> how so?
09:37:56 <mauke> wouldn't ["######", "###  #", "#    #", "######"] turn into ["######", "  #  #", "#    #", "######"]?
09:38:41 <icantsokoban> and is that not correct?
09:39:11 <mauke> it blows a hole in the left wall
09:39:20 <mauke> now you can just walk out
09:40:25 <icantsokoban> the left wall? you mean "#######"? That is the roof, the level is divided by lines not in columns
09:42:09 <mauke> icantsokoban: http://lpaste.net/144814
09:42:36 <icantsokoban> I see.
09:42:44 <icantsokoban> damn, I don't know
09:43:02 <icantsokoban> I am out of brainjuice
10:13:59 * hackagebot sandman 0.2.0.0 - Manages Cabal sandboxes to avoid rebuilding packages.  https://hackage.haskell.org/package/sandman-0.2.0.0 (abhinav)
10:42:54 <roelof> It this a correct way to make sure numbers under the zero are not allowed : http://lpaste.net/144816
10:45:48 <lyxia> roelof: r < 0    :D
10:46:00 <TheArtist> Hello everybody! I am trying to make an include header parser for C++ source files (like the -MMD flag in Gcc)
10:46:25 <TheArtist> The thing is that when i am recursively parsing to make the list, i need to somehow avoid bidirectional references
10:46:26 <roelof> lyxia:  sorry. I think I do not fully understand what you mean 
10:46:56 <TheArtist> in the headers... That means to store(?) the current searched file list and then pass it on
10:46:59 <lyxia> roelof: I mean it's written n < 0 in your link
10:47:05 <TheArtist> Any recommended ways to do this?
10:47:27 <roelof> lyxia:  oke, I need to be r < 0 
10:47:41 <roelof> lyxia:  but the idea is right 
10:47:50 <lyxia> roelof: right
10:47:52 <lyxia> roelof: it is
10:48:34 <roelof> oke, learned another thing what the book is not telling me and where I was curious about, Thanks lyxia 
10:53:11 <mjhoy> i have a lot of maybe values in a monadic context (e.g. IO), and I have lots of case statements. should I be using liftM ...?
11:01:09 <roelof> Another question.: I tried this isRegular (Triangle s1 s1 s2 )   = True, which should test if the three sides are the same. But it seems to be a problem. Can I solve this with smart constructors or is there a better way ?
11:01:47 <lyxia> roelof: uh are you saying all triangles are equilateral with this?
11:02:30 <roelof> I try to express that , lyxia  
11:02:44 <lyxia> but that's an incorrect statement
11:03:25 <lyxia> also your pattern (Triangle s1 s1 s2) has the same variable twice.
11:03:43 <roelof> lyxia:  I know, I see some error messages so I ask here how I can express that better 
11:04:29 <lyxia> test whether the three sides are equal
11:04:38 <sedeki> i'm trying to call `hint` from c++ code. from what I can see, there are no foreign function exports in the hint package. am I still able to call functions in `hint` ?
11:04:57 <roelof> lyxia:  oke, so another case for a smart constructor
11:05:01 <lyxia> roelof: I don't understand what you are stuck on. Can you be more specific?
11:05:53 <frerich> roelof: When you say 'it seems to be a problem', what makes you think there's a problem? I suppose you get some sort of error message from something -- maybe paste that somewhere for others to draw their conclusions.
11:06:26 <lyxia> mjhoy: MaybeT may help?
11:07:20 <roelof> I solved it this way :  http://lpaste.net/144817 , lyxia  
11:07:27 <roelof> it that what you mean 
11:08:42 <mauke> isRegular (Triangle s1 s2 s3) = s1 == s2 && s2 == s3
11:10:10 <roelof> mauke:  that is I think a better way , thanks 
11:11:20 <jg_> hi all. Today i want to write a function that replaces multiple whitespace/newline characters by just one. What's the right way to go here? Haskell regexps?
11:11:30 <jg_> maybe there's already a library for that sort of stuff?
11:11:33 <mauke> unwords . words
11:12:56 <jg_> doesn't that remove the newlines?
11:13:13 <mauke> yes
11:15:33 <sedeki> anyone? how do I create a shared library of the haskell package `hint` so I can call it from c++ code?
11:20:08 <jg_> so, who knows an easy to use regexp library in haskell?
11:21:12 <keko-2> people don't use regexps very much in haskell
11:21:17 <keko-2> since haskell has parsec
11:21:47 <mauke> also because there are no good regex libraries in haskell
11:22:17 <koomi> regex-applicative has a nice interface
11:23:19 <roelof> Thanks all. Now time for family 
11:23:29 <slacko1256> on machine learning (learning/playing) is hlearn still recomended or are there newer alternatives'
11:23:33 <slacko1256> ?
11:23:33 <jg_> nice, regex-applicative-text it is
11:23:36 <jg_> thanks koomi
11:24:16 <mauke> koomi: that doesn't even look like regexes
11:25:45 <koomi> mauke: in the programming or in the language theoretical sense?
11:25:51 <mjhoy> lyxia: thanks
11:26:26 <mauke> programming
11:26:41 <mauke> is the word "regex" even used in academia?
11:27:27 <chaosmasttter> jg_: You could also use: unlines . filter (not . null) . map (unwords . words) . lines
11:28:26 <koomi> mauke: it's not unheard of
11:29:13 * hackagebot urlpath 3.0.0 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-3.0.0 (athanclark)
11:29:32 <koshmar> hey, if you have something like "f1 (f2 (f3 a)))" , where f1,f2,f3 is functors (aplicative and monads), if I want to change a, is there anything simpler then fmap ( fmap (fmap....?
11:29:57 <frerich> jg_: If you don't like unwords.word because you want to keep some kinds of space characters (e.g. newlines) you can also build something on top of 'groupBy', grouping normal characters and whitespace characters into chunsk and then dropping the whitespace chunks
11:30:47 <jg_> to be honest regex-compat most friendly to me though it uses String instead of Text
11:31:30 <Hijiri> koshmar: you can stick the fmaps together like (fmap.fmap.fmap) f thing
11:31:40 <Hijiri> it isn't much of an upgrade, but you can see it as a cohesive unit that way
11:31:50 <Hijiri> "the thing that fmaps three-levels down"
11:32:23 <geppettodivacin> You could write a function fmap3 for that, if you needed to use it a lot.
11:33:18 <koshmar> well, yeah, I just thought there is some kind of "lift"-type functions for that.
11:34:09 <koshmar> "(fmap.fmap.fmap) f" this is cool I guess
11:35:23 <chaosmasttter> koshmar: if you did build this structrure yourself, you could use Compose from Data.Functor.Compose to build something like this:
11:36:05 <chaosmasttter> Compose f1 (Compose f2 f3) a
11:37:24 <koshmar> thanks
11:37:35 <chaosmasttter> now you can just use fmap to change do this: Compose f1 (Compose f2 f3) a -> Compose f1 (Compose f2 f3) b
11:52:06 <brenma_> Would you guys recomend Programming in Haskell by Graham Hutton as a first time Haskell and FP book?
12:01:03 <aphocus> does anyone here use spacemacs and structured haskell mode?
12:01:40 <ReinH> brenma_: It's pretty good. I personally prefer Thinking Functionally with Haskell by Bird.
12:01:54 <aphocus> I can not for the life of me enter a closing bracket for some god aweful reason.
12:02:37 <ReinH> aphocus: it manages opening and closing brackets for you. If it gets confused, you can force it to add a character with c-q
12:02:59 <ReinH> but generally you shouldn't be editing in a way that leaves dangling brackets around.
12:03:14 <aphocus> ReinH, I'm trying to wrap existing code with some brackets
12:03:34 <aphocus> in otherwords I forget the opening one.
12:04:15 <ReinH> aphocus: () brackets?
12:04:20 <aphocus> yeah
12:04:50 <aphocus> say like 1 / x * y -> 1 / (x * y)
12:05:14 <ReinH> highlight the selection in visual mode and sb
12:05:27 <aphocus> ahh
12:05:37 <ReinH> so if the point is | at 1 / |x * y -> 1, v3wsb
12:05:51 <ReinH> er, you know what I mean
12:06:03 <ReinH> There's also a way to do it with shm's paredit-like features
12:06:21 <aphocus> I'm also getting a weird error when trying to delete the surpirous bracket as well.
12:07:23 <ReinH> aphocus: vx is probably easiest
12:08:39 <aphocus> earlier I installed ghc-mod and thats giving me errors too now :D
12:08:55 <brenma_> ReinH: Why do you like birds book better? I was just reading bitemyapp's blogpost and he does not recomend either of them. He seems to recomend that course first. 
12:11:25 <ReinH> brenma_: Bird's book is based on his earlier Introduction to Functional Programming, which I thought was the best book on functional programming ever written. bitemyapp and I disagree on some things.
12:12:37 <sedeki> can you link to this book?
12:14:24 <brenma_> sedeki: What birds book? http://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird/dp/1107452643
12:16:04 <sleepomeno> I think about using reactive-banana for a web gui using ghcjs. (I have used threepenny-gui and now want a real web application for fun) I found Francium which sounds to be the library I look for. Are there alternatives?
12:17:47 <jophish> is foldl1 strict?
12:18:55 <Juliver_> @help
12:18:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:19:36 <ReinH> josephle: like foldl'? No.
12:20:12 <ReinH> sleepomeno: reflex-dom
12:26:55 <ReinH> Juliver_: ?
12:28:07 <badeleux> yo
12:31:22 <dfeuer> Hurray! It looks like András Kovács and Ørjan Johansen may have solved the safety problem with Data.Constraint.Forall in a way that doesn't totally cripple it. Sweet.
12:31:39 <cite-reader> \o/
12:32:01 <cite-reader> I don't actually know what that implies, but it sounds good!
12:35:08 <tippenein> is there a Faker type library for haskell?
12:35:45 <bennofs> dfeuer: hmm, how is the current version of .Forall unsafe?
12:35:51 <tippenein> oh god, sorry. there's one called 'faker' ,... der
12:36:31 <dfeuer> bennofs, see https://github.com/ekmett/constraints/issues/11 for the whole story.
12:36:35 <Abhishek> Hello everyone, I want to contribute to haskell development for next GSoC. But I don't have any prior development experience. I am an average programmer, and mostly love theory courses and thus took Logic for Computer Science course and read that functional programming languages are more close to these in sense they are declarative and based directly on lambda calculus. So considering I am total newbie in development, I think I sh
12:36:40 <bennofs> dfeuer: cool, thanks
12:36:46 <Abhishek> I have no idea to start working on an open source project etc., where to start with, can someone kindly guide me the path I should take in as much detail as possible? Thanks in advance :)
12:37:07 <joco42> is there any lib that has a function to remove the n-th element of a list?
12:37:30 <mauke> Abhishek: cut off at "I think I sh"
12:38:03 <mauke> joco42: I don't know but you can easily do it yourself with splitAt
12:38:30 <joco42> i just dont want to reinvent the wheel...
12:38:41 <Abhishek> mauke : "I think I should start early for GSoC."
12:38:42 <joco42> mauke:  i have a look
12:39:20 <Abhishek> do text get cut off sometimes in IRC?
12:39:28 <glguy> There is a line length limit
12:40:06 <mauke> Abhishek: there's a maximum message length. some clients automatically split text into two messages, others let it get cut off
12:44:22 <athan> koshmar: Have you seen composition-extra? (warning: self-promo)
12:45:40 <Abhishek> mauke : oh, thanks for the info, can you help me with my query?
12:46:36 <Abhishek> mauke : is there a pm substitute here, so that it doesn't bother others? 
12:47:06 <koshmar> <athan>: nope yet, thanks.
12:47:22 <koshmar> following question http://paste.ofcode.org/ixXhweVEvBr23sdfTQftnE
12:47:23 <koshmar> =)
12:47:38 <mauke> :-(
12:50:14 <glguy> koshmar: let t = Just (Just (Just 1)) in fmap (fmap (fmap succ)) t
12:52:44 <glguy> > let t :: (Maybe `Compose` Maybe `Compose` Maybe) Int; t = pure 1 in pure succ <*> t
12:52:48 <lambdabot>  Compose (Just (Compose (Just (Just 2))))
12:53:06 <glguy> (if the goal is to use applicative operators on nested Applicative instances
12:56:35 <benzrf> do laws guarantee that nested applicative followed by join is the same as join followd by applicative
12:59:03 <muesli4> ls
12:59:09 <muesli4> sry, my bad
12:59:11 <Saizan> Abhishek: it is a good idea to start early, there should still be proposals from last year somewhere and you can get familiar with the projects you might contribute to, maybe you can browse their issue tracker and fix something that's easy, etc..
13:00:10 <Saizan> Abhishek: generally it's good if the potential mentor has some idea of what you are able to do
13:03:42 <prsteele> okay, so removing smarkBorders worked
13:06:22 <Abhishek> saizan : thanks for your time, how can I ask someone to be my mentor? Will someone mentor a totally newbie?
13:08:17 <dbushenko> Abhishek, why not try to take Erik Meher's course on coursera?
13:09:34 * hackagebot urlpath 3.1.0 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-3.1.0 (athanclark)
13:13:30 <lpaste_> lmj pasted “overlap.hs” at http://lpaste.net/144825
13:15:23 <lmj> I understand the overlapping instance, but I don't know why GHC does not complain until it's too late. http://lpaste.net/144825
13:24:34 * hackagebot mongoDB 2.0.9 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  https://hackage.haskell.org/package/mongoDB-2.0.9 (VictorDenisov)
13:26:55 <rvxi> hey
13:28:57 <glguy> lmj: You can read about instance resolution here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#instance-overlap
13:28:57 <glguy> GHC checks instances at resolution time, not definition time
13:34:45 <jophish> Is there a shorthand for () <- foo in a monad comprehension?
13:37:03 <lmj> glguy: thanks, the answer seems to be that errors are reported lazily, but it's not clear why this is the intended behavior. Maybe I'm missing something. If there are snakes on the plane, why let them roam free?
13:38:35 <glguy> There are lots of insane things you might want to do, and for a lot of them it's not clear until resolution time if they are OK
13:39:00 <marcavis> howdy, newbie here; what's a good way to have a function do something if the constructors for both its arguments are the same?
13:39:17 <glguy> so rather than catch some and miss others it just checks at the use-sites
13:39:32 <marcavis> (They're part of a  data  with about a dozen constructors)
13:39:43 <glguy> marcavis: f Con1{} Con1{} = stuff
13:40:08 <glguy> and if you have more constructors you have more cases like that
13:40:25 <glguy> Con1{} is shorthand for Con1 _ _ ... _ for however many parameters you have
13:41:09 <marcavis> glguy: that's interesting to know too, though I was looking for something like...
13:41:29 <marcavis> f (_ arg1 arg2) (_ arg3 arg4) = stuff
13:42:49 <glguy> Nope, nothing like that
13:42:49 <marcavis> ...though not _ since I don't want to ignore them, I want to know if they're the same one
13:42:49 <marcavis> hmmm I see
13:42:58 <glguy> You could derive the function using GHC.Generics, but learning how to do that would take longer than writing out the 13 cases using copy/paste :)
13:44:00 <marcavis> :)
13:44:31 <glguy> I'm still writing that out, though, if you want to s ee it
13:45:01 <lamefun> Is there a good library to read ZIP archives with?
13:46:30 <marcavis> glguy: you're writing that documentation? Sure, though it's likely it'll go over my head, mostly
13:47:10 <lpaste_> glguy pasted “checking for same constructor generically” at http://lpaste.net/144826
13:48:31 <rvxi> can someone have a look at this typeclass equality implementation?
13:48:35 <rvxi> http://lpaste.net/144827
13:48:49 <rvxi> this is an exercise out of Chris Allen's book
13:49:09 <rvxi> it works but I'm getting a warning "Defaulting the following constraint(s) to type ‘()’ ..."
13:49:57 <rvxi> not sure how to get rid of the warning
13:50:52 <glguy> rvxi: You're doing something else. That code doesn't produce that warning on its own
13:51:27 <stephen_> hmm, dependency hell on Arch using haskell-core. . .
13:51:55 <lpaste_> glguy annotated “No title” with “reformatted” at http://lpaste.net/144827#a144828
13:52:57 <Guest81736> why type of types cannot be a type?
13:53:08 <cite-reader> ... what?
13:53:46 <Guest81736> in other words, why can't we have kinds be types?
13:54:00 <rvxi> glguy: yes sorry the warning comes when I try to use the equality check in ghci
13:54:11 <rvxi> glguy: it occurs even if i'm explicit about types
13:55:16 <glguy> rvxi: You're probably not being as explicit as you thought. You'd need (for example)   (Hello 1 :: EitherOr Int Bool) and not (Hello (1 :: Int))
13:55:30 <stephen_> Guest81736: a higher-kinded type provides a kind of meta-interface that all child types inherit
13:55:51 <rvxi> glguy: ah I modified it here http://lpaste.net/144827
13:55:52 <stephen_> or rather they have the structure in common
13:56:08 <rvxi> glguy: but I was only explicit in the argument
13:57:29 <rvxi> glguy: thanks
14:00:14 <vitalij> Did someone try to solve Google Hash Code challanges with Haskell?
14:00:27 <Guest81736> stephen_: didn't understand that
14:01:00 <stephen_> sorry, give me a second, I'll find something 
14:02:15 <stephen_> wikipedia's alright https://en.wikipedia.org/wiki/Kind_%28type_theory%29
14:03:40 <stephen_> this document is from the rust people, written as part of the discussion around integrating HKT with their language -- they're cribbing a lot of things from haskell, and with good reason https://gist.github.com/CMCDragonkai/a5638f50c87d49f815b8
14:05:48 <stephen_> Guest81736: does the gist make some sense?
14:18:28 <Guest81736> so a higher kinded type is a type whose kind is not * ?
14:19:29 <jle`> Guest81736: a higher order function would be something that takes a function as an argument
14:19:36 <Big_G> Does anyone know where I can get a good Haskell hoodie? I found one I really like but it is a tad expensive
14:20:19 <jle`> a higher-kinded type would be something that takes "type functions", * -> *'s, as arguments
14:20:34 <Guest81736> okay
14:21:00 <dfeuer> So something of kind   (* -> *) -> *, for example. 
14:21:11 <Guest81736> but i don't understand why kinds and types have to be on different 'levels'
14:21:27 <dfeuer> newtype Foo f a = Foo (f a)a
14:21:29 <dfeuer> er ...
14:21:31 <dfeuer> newtype Foo f a = Foo (f a)
14:22:01 <dfeuer> Guest81736, they don't necessarily. The current plan is to put kinds and types on the same level.
14:22:11 <dfeuer> In the next version of GHC.
14:22:12 <akfp> how do I get spacemacs to use "stack build" instead of "cabal build"?
14:23:28 <phaazon> hi
14:23:38 <phaazon> I have a question about lazy IO
14:24:17 <cite-reader> Someone here probably has an answer.
14:24:21 <phaazon> http://lpaste.net/3864838093810958336
14:24:22 <phaazon> ok
14:24:32 <phaazon> line 9, you can see a call to createProgram
14:24:34 <phaazon> right?
14:24:40 <phaazon> I have a weird behavior
14:24:42 <phaazon> so
14:24:45 <phaazon> here:
14:24:49 <phaazon> http://lpaste.net/2319441773320994816
14:24:54 <phaazon> if you look closely at the stack
14:24:59 <Guest81736> but if they are on the same level, what benefits will we have then?
14:25:06 <phaazon> we can see that createProgram is called AFTER the untilM function
14:25:10 <phaazon> is that lazy IO?
14:25:53 <phaazon> I don’t understand why I have such a weird behavior
14:28:55 <cite-reader> It looks like OpenGL is complaining about... something. I don't know anything about OpenGL.
14:29:22 <phaazon> cite-reader: yeah, I know 
14:29:30 <phaazon> that’s why I’m using the GHC stack to know what
14:29:35 <phaazon> I’m not interested in that though
14:29:50 <phaazon> I’m interested in the order of executions of functions
14:29:53 <phaazon> which sounds wrong
14:35:05 * hackagebot ttrie 0.1.2.1 - Contention-free STM hash map  https://hackage.haskell.org/package/ttrie-0.1.2.1 (MichaelSchroeder)
14:35:26 <jle`> where the untilM?
14:35:34 <phaazon> in mainLoop
14:36:32 <jle`> lazy IO isn't an inherent part of "haskell"; it's just a part of the way base's readFile, etc. are implemented in particular.  so if createProgram is behaving weirdly, it'd be because of how createProgram is implemented
14:36:48 <phaazon> hm
14:36:49 <phaazon> I see
14:36:56 <phaazon> I need to know more about lazy IO then
14:37:06 <phaazon> because the implementation is not really weird
14:37:09 <jle`> lazy IO can't be thought of as a fundamental property of how execution in haskell works that can be studied all together
14:37:11 <phaazon> it’s actually pretty straight-forward
14:37:26 <jle`> it's just a general word to describe how readFile etc. were chosen to be implemented
14:37:33 <jle`> and is unrelated to laziness in haskell/ghc :)
14:37:55 <phaazon> yeah, I imagine that
14:38:44 <phaazon> jle`: http://lpaste.net/3976320889170952192
14:38:48 <phaazon> ^ that is createProgram
14:39:33 <phaazon> btw I can drop the MultiWayIf here
14:39:35 <phaazon> that’s stupid
14:39:40 <phaazon> I can use when
14:39:47 <jle`> i don't really know how half of those functions work :/
14:40:18 <phaazon> jle`: ok, then, let’s talk about the stack
14:40:26 <phaazon> why is the order of the calls reversed?
14:42:50 <lyxia> Perhaps the bind of the do block createProgram mainLoop belong to force the second argument first?
14:43:10 <lyxia> Where's startup?
14:43:33 <lyxia> what is liftIO lifting to?
14:48:12 <phaazon> lyxia: what do you mean with your block argument?
14:48:14 <phaazon> I don’t get it
14:48:22 <phaazon> liftIO, in which code?
14:48:30 <phaazon> in main?
14:48:39 <phaazon> it lifts to…
14:49:18 <phaazon> type App = ExceptT AppError (ResourceT IO)
14:56:44 <JonReed> Hi, was there some easy way to do the following "[a] -> (a -> -a> -> b) -> [b]", where f is applied to each neighbouring a, to produce b like this:  [a1, a2, a3, a4, ... a(n)] -> [(f a1 a2), (f a2, a3), (f a3 a4)]. So "myFunc (+) [1..10] -> [3,5,7,9,11,13,15,17,19]". I wrote a naive recursive one, but I think there might be some cool one liner out there.
14:58:04 <phaazon> JonReed: wipWith f . tail
14:58:12 <phaazon> zipWith f . tail *
14:58:30 <phaazon> and you have to apply f to the first argument though
14:58:30 <muesli4> wipWith :D
14:58:35 <phaazon> :D
14:58:39 <phaazon> wipwipwip!
15:02:37 <phaazon> jle`: hm
15:02:40 <phaazon> jle`: http://lpaste.net/1671515501106298880
15:02:46 <phaazon> the createProgram has 0 entry
15:03:03 <phaazon> is it there because it’s not really a “call-site” but… a closure?
15:07:07 <phaazon> oh god
15:07:19 <phaazon> I’ve found my issues by looking at the first entries in the call stack
15:08:02 <jle`> congrats :)
15:09:43 <phaazon> debugGL $ glActiveTexture texUnit
15:09:46 <phaazon> with texUnit = 0
15:09:51 <phaazon> that’s not a valid enum
15:09:55 <phaazon> so the InvalidEnum is logical
15:09:57 <phaazon> :)
15:10:32 <JonReed> > zipWith (+) . tail [(1 :: Int)..10]
15:10:34 <lambdabot>      Couldn't match expected type ‘a -> [c]’ with actual type ‘[Int]’
15:10:34 <lambdabot>      Possible cause: ‘tail’ is applied to too many arguments
15:10:34 <lambdabot>      In the second argument of ‘(.)’, namely ‘tail [(1 :: Int) .. 10]’
15:11:22 <phaazon> @let f = zipWith (+) . tail
15:11:24 <lambdabot>  Defined.
15:11:44 <phaazon> oh, sorry, I forgot something
15:11:47 <phaazon> @unlet
15:11:47 <lambdabot>  Define what?
15:12:10 <phaazon> @let f l = zipWith (+) (tail l) l
15:12:11 <lambdabot>  .L.hs:164:1:
15:12:11 <lambdabot>      Multiple declarations of ‘f’
15:12:11 <lambdabot>      Declared at: .L.hs:153:1
15:12:17 <phaazon> @let g l = zipWith (+) (tail l) l
15:12:18 <lambdabot>  Defined.
15:12:24 <phaazon> g [1..5]
15:12:26 <phaazon> > g [1..5]
15:12:28 <lambdabot>      Ambiguous occurrence ‘g’
15:12:28 <lambdabot>      It could refer to either ‘L.g’,
15:12:28 <lambdabot>                               defined at /tmp/mueval20406514341975960378.hs:1...
15:12:32 <phaazon> dammit :D
15:12:33 <MarcelineVQ> :>
15:13:04 <phaazon> > (\x -> zipWith (+) (tail x) x) [1..5]
15:13:05 <lambdabot>  [3,5,7,9]
15:13:22 <JonReed>  :D
15:13:34 <JonReed> phaazon: Thx.
15:13:46 <phaazon> I think you can have the tail thing in another interesting way
15:14:34 <MarcelineVQ> > zipWith (+) <*> tail $ [1..5] -- like this?
15:14:36 <lambdabot>  [3,5,7,9]
15:14:48 <phaazon> nope
15:14:50 <phaazon> like this:
15:15:06 <phaazon> > tail >>= zipWith (+) $ [1..5]
15:15:07 <lambdabot>  [3,5,7,9]
15:15:10 <phaazon> :D
15:15:19 <MarcelineVQ> you madman
15:15:23 <phaazon> I love how functions as monads are crazy :D
15:15:26 <JonReed> My brain is melting
15:16:00 <phaazon> the applicative style is very great as well!
15:16:29 <mniip> :t tail >>= zipWith (+)v
15:16:30 <mniip> :t tail >>= zipWith (+)
15:16:31 <lambdabot>     Couldn't match expected type ‘[[b]]’
15:16:31 <lambdabot>                 with actual type ‘[a0] -> [a0]’
15:16:31 <lambdabot>     Probable cause: ‘tail’ is applied to too few arguments
15:16:32 <lambdabot> Num c => [c] -> [c]
15:16:46 <mniip> oi
15:16:50 <mniip> :t \f -> tail >>= zipWith f
15:16:51 <lambdabot> (a -> a -> c) -> [a] -> [c]
15:16:54 <mniip> aha
15:25:39 <akfp> why does the Foldable.toList instance for HashMap only return the values, while HashMap.toList returns (k,v) tuples? 
15:29:22 <dfeuer> akfp, because the type of toList in Foldable only allows that.
15:29:38 <dfeuer> akfp,  toList :: Foldable f => f a -> [a]
15:30:01 <dfeuer> So    toList :: HashMap k v -> [v]
15:32:52 <dfeuer> akfp, the lens package offers a FoldableWithIndex class specially for you.
15:37:43 <phaazon> 00:25 < akfp> why does the Foldable.toList instance for HashMap only return the  values, while HashMap.toList returns (k,v) tuples? 
15:37:47 <phaazon> because of types!
15:37:55 <phaazon> toList works on Foldble, which is * -> *
15:38:09 <phaazon> so you can only have values in there
15:38:17 <phaazon> keys and values would be * -> * -> *
15:38:25 <phaazon> which is the type of a map, yes
15:38:27 <phaazon> the kind*
15:38:30 <phaazon> :k Map
15:38:31 <lambdabot>     Not in scope: type constructor or class ‘Map’
15:38:31 <lambdabot>     Perhaps you meant ‘M.Map’ (imported from Data.Map)
15:38:35 <phaazon> :k M.Map
15:38:36 <lambdabot> * -> * -> *
15:38:42 <phaazon> :)
15:40:36 <caconym> can anyone comment on whether http://www.stephendiehl.com/posts/haskell_web.html is still good advice? looking to explore libraries in this vein a bit, and the post in question is a few years old..
15:42:38 <caconym> obviously some are obvious like Aeson, but wondering more about the ones I haven't heard of like Clay/JMacro
15:43:53 <keko-2> caconym: have you seen this by the same author? http://dev.stephendiehl.com/hask/
15:44:58 <caconym> indeed, it seems to go into less detail about the sort of webdev-oriented libraries i'm interested in though
15:46:09 <caconym> i'm most curious about generating html/js/css using embedded DSLs and wondering whether the libs in the web article are still considered fresh, and/or whether that sort of approach is even still considered a good practice
15:59:04 <Myll_> i have this function composition: "decodeMessages . parseTree . head", how can i give decodeMessages a second parameter?
16:02:03 <pavonia> Myll_: With function composition still applying to the first parameter?
16:03:08 <Myll_> yes
16:03:28 <pavonia> flip decodeMessage secParam
16:04:40 <pavonia> or more directly (\x -> decodeMessages x secParam)
16:13:56 <rcrcrc> so I've got a typeclass I've written here, with an IO instance, and I'd like to write another instance: http://lpaste.net/144841
16:15:46 <rcrcrc> I'd like the new instance to - instead of getting resources one at a time - find how many 'Resource's are needed, then gets all the 'Resource's needed at once and then batch 'write's all the 'Message's
16:16:36 <rcrcrc> if I didn't need to gather 'Resource's for the 'Message's, it'd be as simple as keeping all 'Message's in a State or Reader monad
16:16:51 <rcrcrc> any advice how I can accomplish this?
16:21:04 <mac10688> If I have newtype Identity a = Identity a. The only way I could make a mappend method for it is to return either the left or right side right?
16:21:34 <pavonia> rcrcrc: Do you want to get the ressources at the time the write is performed?
16:22:54 <rcrcrc> pavonia: anytime befofe the write is performed
16:23:28 <rcrcrc> but batched, so that we're getting all the resources we need at once
16:23:59 <pavonia> So return the ressources as a list
16:24:19 <rcrcrc> so I can just e.g. 'replicateM n (getResource :: IO Resource)'
16:30:02 <pavonia> mac10688: Without further contraints yes
16:30:09 * hackagebot markup 2.0.0 - Abstraction for markup languages  https://hackage.haskell.org/package/markup-2.0.0 (athanclark)
16:30:32 <mac10688> thank you pavonia 
16:48:36 <rcrcrc> like, I'd like to evaluate 'doBlock' in a way that I know how many 'Resources' are needed, then generate them all at once and then actually create the 'Message's
16:51:12 <rcrcrc> I'm also open to having a different type for 'getResource'
16:52:35 <athan> Anyone here fiddle with HLearn?
16:55:30 <rcrcrc> I've tried having a type like 'WriterT (Sum Int) (Reader Message)' but I need to evaluate the Reader before I can get the count from the WriterT
17:05:35 <Myll_> one of my function needs to access something created in another function.. how can i achieve this? http://pastebin.com/hCTrSKDT
17:06:16 <Guest00000>  <mac10688> If I have newtype Identity a = Identity a. The only way I could make a mappend method for it is to return either the left or right side right?
17:06:17 <Guest00000> https://wiki.haskell.org/Unamb ?
17:08:06 <pavonia> Myll_: Use parseTree in this function
17:08:33 <glguy> Myll_: Lines 17 and 18 overlap, 18 will never be used
17:08:48 <mac10688> Thanks Guest00000 I'll try to make sense of that
17:09:04 <glguy> Maybe you meant: decode (x:xs) = decodeMessage (parseTree x) xs
17:11:30 <Myll_> but i don't want to create a new tree on every recursion D:
17:12:15 <Myll_> i just want a big tree with the initial head of the list
17:12:40 <glguy> So far there's no recursion
17:13:15 <Myll_> the line above doesn't call decodeMessage for every x in xs?
17:13:58 <glguy> no
17:14:02 <glguy> (it doesnt')
17:14:21 <glguy> decode and decodeMessage are different
17:15:02 <Myll_> each x in the xs needs to be decoded tho
17:17:43 <pavonia> Myll_: If you want to apply a function to each element of a list, you can use "map"
17:17:45 <glguy> decode (x:xs) = map (decodeMessage (parseTree x) xs)
17:17:58 <glguy> decode (x:xs) = map (decodeMessage (parseTree x)) xs
17:19:48 <Myll_> alright thx, but would this be inefficient, since we're calling parseTree x so many times to do the same thing each time?
17:21:39 <pavonia> Do you know about let-bindings?
17:22:26 <Myll_> like i have this list: ["**B**","1011","1001","1111"]. i need to parse the tree for "**B**", and then use the tree to decode "1011","1001","1111"
17:23:01 <Myll_> with that head being a string representation of the tree
17:23:23 <Myll_> no, don't know about those pavonia 
17:23:29 <Myll_> this is like my first day with haskell
17:23:56 <glguy> Myll_: It doesn't call parseTree x more than once
17:24:27 <Myll_> really, well i guess i have a terrible misunderstanding of this stuff currently
17:24:42 <glguy> That's to be expected if this is your first day
17:26:48 <pavonia> Myll_: https://en.wikibooks.org/wiki/Haskell/More_on_functions#let_and_where_revisited
17:27:32 <pavonia> As glguy mentioned it's not necessary here, but you will certainly need local bindings later
17:29:43 <Gurkenglas> If my main has the form x >>= f, can I vary f from ghci without repeating x?
17:52:50 <henk> int-e: I installed the hackage version of lambdabot. http://pastie.org/private/1q3tw9ztmvzwqehmf8wfg shows my online.rc file and output from running lambdabot. It seems to ignore at least the 'join' command in the online.rc, maybe also the admin command (I don’t know how to tell yet) but can join channels fine in interactive mode.
18:12:27 <OutlawStar> whats the different between a mutable vector that uses an st monad or an IO monad?
18:12:39 <OutlawStar> ie is there any perf implications?
18:13:00 <c_wraith> OutlawStar: IO and ST are the same thing underneath.  The only difference is the interface.
18:13:10 <OutlawStar> ah ok, thanks c_wraith
18:17:47 <jijejke> Can Muslims use haskell?
18:21:29 <lethjakman-l> Has anyone found a odbc driver to use with hdbc on osx?
18:27:50 <keiopa> hello, anyone online
18:27:52 <keiopa> ?
18:28:24 <keiopa> lots of activity...
18:28:31 <jijejke> niggers
18:29:14 --- mode: ChanServ set +o glguy
18:29:15 --- mode: glguy set +b *!*@gateway/web/freenode/ip.81.104.112.74
18:29:15 --- kick: jijejke was kicked by glguy (jijejke)
18:29:28 <keiopa> hey jijejke, are you up for some coding?
18:32:09 <keio> hey need some help, anyone good at haskell?
18:34:08 <dsop> keio: don't ask to ask, just ask
18:34:32 --- mode: glguy set -o glguy
18:40:13 * hackagebot agda-snippets-hakyll 0.1.1.1 - Literate Agda support using agda-snippets, for Hakyll pages.  https://hackage.haskell.org/package/agda-snippets-hakyll-0.1.1.1 (LiamOConnorDavis)
18:40:42 <athan> :t ask
18:40:44 <athan> :v
18:40:44 <lambdabot> MonadReader r m => m r
19:00:14 * hackagebot urlpath 3.1.1 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-3.1.1 (athanclark)
19:00:17 <athan> Is there an instance for `(MonadReader r m, MonadTrans t) => MonadReader r (t m)`? If not, why exactly?
19:01:26 <athan> I wish that automated induction would work for arbitrary MonadTrans's :\
19:01:38 <athan> s/automated/[whatever you think is necessary]
19:05:37 <c_wraith> athan: it doesn't exist because of overlapping
19:06:04 <c_wraith> athan: in particular, it overlaps the ReaderT instance.  Which is bad.
19:06:38 <athan> yow
19:06:44 <athan> thanks c_wraith :)
19:09:02 <rvxi> Q - why doesn't Num imply Ord?
19:09:19 <c_wraith> rvxi: Complex is an instance of Num
19:09:37 <c_wraith> rvxi: But I don't know how to order complex numbers.
19:09:49 <rvxi> ah ok
19:09:52 <c_wraith> :t 1 :+ 0
19:09:53 <lambdabot> Num a => Complex a
19:10:17 <c_wraith> > (1 :+ 0) + (2 :+ 3)
19:10:19 <lambdabot>  3.0 :+ 3.0
19:10:24 <c_wraith> > (1 :+ 0) < (2 :+ 3)
19:10:27 <lambdabot>      No instance for (Num a0) arising from the literal ‘1’
19:10:28 <lambdabot>      The type variable ‘a0’ is ambiguous
19:10:28 <lambdabot>      Note: there are several potential instances:
19:11:35 <rvxi> interesting
19:11:51 <rvxi> i guess this is also related to warnings I get in ghci for things like
19:12:03 <rvxi> 0 < 1
19:12:22 <rvxi> "Warning:     Defaulting the following constraint(s) to type ‘Integer’ ... "
19:12:37 <c_wraith> ghci doesn't give that warning by default..  You must have -Wall (or something like it) enabled
19:13:17 <c_wraith> But yes, it's related.
19:15:07 <rvxi> yes I have warnings on
19:18:57 <rvxi> another question, under what circumstances does :i TypeName show the general typeclass X like class X a => Y a?
19:19:19 <rvxi> for example, :i Ord gives "class Eq a => Ord a where ..."
19:20:13 <rvxi> :i Integer does not.
19:20:14 <rvxi>  Hmmm... I guess one difference is Ord is a typeclass while Integer is a Type
19:20:41 <c_wraith> rvxi: that is the difference, yes
19:21:12 <c_wraith> rvxi: when you have class (Foo a) => Bar a where ..., it means that to be an instance of Bar, it must also be an instance of Foo
19:21:20 <rvxi> So a typeclass can only have one "parent"?
19:21:32 <c_wraith> yes
19:21:34 <c_wraith> Err, no
19:21:35 <c_wraith> Sorry
19:21:50 <c_wraith> A class can have any number of super classes.
19:22:07 <rvxi> any examples?
19:22:18 <rvxi> all the ones I've tried seem to only have one
19:23:07 <OutlawStar> rvxi: https://hackage.haskell.org/package/resourcet-1.1.6/docs/Control-Monad-Trans-Resource.html#t:MonadResource
19:24:02 <tejon_> Wreq question. When I use plain "get", https works fine; when I use getWith and edit the manager to reduce the response timeout, I get TlsNotSupported. It's probably because I'm initializing the wrong kind of manager; but what's the right kind?
19:24:31 <OutlawStar> tejon_ you need to init it with the tls settings
19:25:06 <OutlawStar> https://hackage.haskell.org/package/http-client-tls-0.2.2/docs/Network-HTTP-Client-TLS.html
19:25:12 <c_wraith> tejon_: get url = getWith defaults url
19:25:36 <OutlawStar> or maybe u are using something else... sory bout that
19:26:04 <tejon_> c_wraith, yeah, I can't figure out where defaults is defined.
19:26:24 <c_wraith> tejon_: why bother?  Just modify it.  Don't recreate it.
19:26:27 <tejon_> OutlawStar, that looks promising... does tlsManagerSettings go where I currently have defaultManagerSettings?
19:26:44 <OutlawStar> i think so
19:26:47 <OutlawStar> if i remember correct
19:27:09 <tejon_> c_wraith, Wreqs tutorial doesn't cover that. :P 
19:27:41 <OutlawStar> tlssettings has a default instance, so you can supply that when creating the manager settings which you use to create the manager
19:28:10 <rvxi> outlawstar: nothing in the prelude/standard stuff?
19:28:53 <c_wraith> rvxi: well, Num used to be.  It used to have Show and Eq as parents.  But they got removed.
19:29:10 <OutlawStar> rvxi: look at MonadPlus
19:30:13 <rvxi> c_wraith: interesting, what was the reasoning?
19:30:45 <rvxi> c_wraith: so now "print 3" gives me a warning whereas it previously wouldn't have?
19:31:34 <c_wraith> rvxi: nah, the warning is there either way
19:31:43 <rvxi> λ> :i MonadPlus  <interactive>:1:1: Not in scope: ‘MonadPlus’
19:32:07 <OutlawStar> rvxi: import Control.Monad
19:32:38 <OutlawStar> :t MonadPlus
19:32:40 <lambdabot> Not in scope: data constructor ‘MonadPlus’
19:32:56 <c_wraith> It's a class
19:32:59 <c_wraith> use :i, not :t
19:33:03 <OutlawStar> :i MonadPlus
19:33:13 <OutlawStar> :/
19:34:30 <rvxi> ah
19:38:34 <homovitruvius> question on types: type Repl a = HaskelineT IO a and I could have  a list of functions String->Repl(). Then I had to change the type to type Repl a = forall m . (HasReadFile m) ⇒ HaskelineT m a and now the list is a bit too polymorphic. Is there a way to restrict m to be the same for all elements of the list? I get an error telling me to use ImpredicativeTypes
19:40:39 <glguy> HasReadFile m => [HaskelineT m a]
19:41:57 <rvxi> i'm sure this has been asked a million times, but is there a better solution when you want a function description than opening a browser and googling hackage?
19:42:19 <tejon_> Thanks for the pointers guys, TLS is working and Wreq is no longer creating a new manager on every request (oof).
19:50:53 <saulzar> rvxi, A lot of people use things like hoogle (and hoogle plugins for their text editor). Often I just google hackage though.
19:51:56 <rvxi> saulzar: like helm-hoogle?
19:53:30 <saulzar> rvxi, Probably - not familiar with helm-hoogle
20:01:25 <orion> Hi. I have a file tests/.hlint which must be present in the tarball created by sdist. It is needed by my "hlint" test-suite. What cabal directive should I use to include it?
20:05:27 <tejon_> orion, extra-source-files adds things to the sdist tarball.
20:05:42 <tejon_> Commonly used for changelog, etc.
20:05:56 <orion> But, what if this source file is specific to one test-suite?
20:06:17 <orion> Does it still belong in extra-source-files?
20:09:52 <tejon_> Don't see why not, as long as you're bundling it with the test already. There might be a way to add that flag on the commandline, though you'd be able to find it as quickly as me. Cabal's docs are a labyrinth. :P
20:15:46 * hackagebot urlpath 3.2.0 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-3.2.0 (athanclark)
21:05:48 * hackagebot aeson-yak 0.1.1 - Handle JSON that may or may not be a list, or exist  https://hackage.haskell.org/package/aeson-yak-0.1.1 (tejon)
21:22:38 <athan> So there's Monad{Reader,Writer,State,Logger,Throw,Catch,Mask,Base,BaseControl,Trans,TransControl,Logger} ... am I missing anything else in a common monad stack?
21:24:35 <athan> oop, {...RWS,Error,Cont}
21:26:19 <athan> oh and {IO}
21:27:36 <stevejb> I have an array in the form of type [[Value]], where Value comes from Data.Aeson
21:27:39 <stevejb> In particular
21:27:41 <stevejb> [[Object (fromList [("survey_name", String "survey_A")])], [Object (fromList [("survey_name", String "survey_B")])]]
21:28:05 <stevejb> trying to figure out how to use (lens, prism) to get ["survey_A", "survey_B"] from this
21:31:12 <umib0zu> Does anyone have experience with the State monad? I’ve been trying to get this to work and I’m getting an error in line 10 that there is a pattern match error with (state g). I’m not exactly sure why since I’m new to using state monads. http://pastebin.com/vACF8vdG
21:32:07 <lamefun> is there a some kind of way to emulate convenient multi-stage validation?
21:32:51 <lamefun> eg. function something(value) { if (isBad1(value)) return "Bad (reason 1)"; if (isBad2(value)) return "Bad (reason 2)"; return process(value); }
21:33:13 <lamefun> nvm
21:40:56 <ttt_fff> https://hackage.haskell.org/package/dependent-map-0.2.0.1/docs/Data-Dependent-Map.html <-- anyone have a good tutorial that motivatges DMap ?
21:41:09 <ttt_fff> i.e. (1) without DMap, we have problem X, (2) we can do X, but the solution is ugly, now, (3) we use DMap, and our solution is clean
21:55:49 * hackagebot chatter 0.8.0.1 - A library of simple NLP algorithms.  https://hackage.haskell.org/package/chatter-0.8.0.1 (RoganCreswick)
21:59:30 <geppettodivacin> umib0zu: factGet doesn't return a tuple, it returns a State. That's why it's throwing an error.
21:59:53 <geppettodivacin> I'm not quite sure I can tell from your function what you want to do.
22:01:15 <umib0zu> geppettodivacin: http://pastebin.com/evtdPYcY I ended up fixing it
22:01:57 <umib0zu> this sort of works fine ^^^ but going back to the previous paste, I know it doesn’t return a tuple, but I assumed it would pattern match “state g” over the state monad.
22:02:21 <umib0zu> also I’m just trying to compute factorials with a memoization
22:03:50 <geppettodivacin> Sure, that looks like it'll do it. You could probably clean that up just a bit with do notation.
22:05:35 <umib0zu> geppettodivacin: the second paste works. I’m just trying to figure out why this isn’t pattern matching. http://pastebin.com/vACF8vdG
22:06:01 <geppettodivacin> It's because a State isn't a tuple.
22:06:19 <geppettodivacin> Until you run runState, you don't have a tuple on the right hand side.
22:06:37 <geppettodivacin> That converts it into a tuple, which you can then pattern-match.
22:07:19 <geppettodivacin> Part of the point of State is that you don't actually have to do that kind of bookkeeping, though.
22:07:45 <geppettodivacin> Oh, wait.
22:08:03 <geppettodivacin> So, I misread your code, let me reword that a bit.
22:08:16 <geppettodivacin> state (with a lowercase s) isn't actually a data constructor.
22:08:23 <geppettodivacin> So you can't pattern match on that.
22:09:16 <geppettodivacin> A State is actually a partially-applied function, so that makes State difficult (if not impossible) to actually match on.
22:09:51 <c_wraith> Err.  Why "partially applied"?
22:10:52 <jle`> i guess any function is "partially applied" complied to something that is slightly less applied
22:11:05 <jle`> s/complied/compared
22:12:12 <geppettodivacin> I might have a misunderstanding of State myself. I'm still a bit new at this. c_wraith: How would you describe the way a State stores a value?
22:12:37 <c_wraith> I would say "State is a newtyped function"
22:12:44 <umib0zu> geppettodivacin: that’s odd. I mean… I’m looking at learnyouahaskell which is actually depreciated. In it state is a value constructor.
22:13:04 <c_wraith> umib0zu: yes, but that's not the same as what's in the transformers package
22:13:24 <c_wraith> (it used to be, a long time ago, but then State and StateT were unified)
22:13:26 <geppettodivacin> umib0zu: It's a constructor in that it gives you a State, but it's not a constructor that you can match.
22:13:34 <umib0zu> yeah I noticed. Does the state monad have a value constructor then that I can pattern match on?
22:13:50 <umib0zu> I mean… it is a simple function from what I can see
22:14:04 <jle`> not anymore; there's just the equivalent extracting function
22:14:09 <c_wraith> umib0zu: It's the StateT constructor.  And you can match on it, sure, but that does the exact same thing as runStateT does
22:14:14 <c_wraith> :t runStateT
22:14:15 <lambdabot> StateT s m a -> s -> m (a, s)
22:14:24 <c_wraith> That just gives you the function back.
22:15:05 <umib0zu> why m in the type sig though? I’m actually not familiar with state transformers so I’m trying to avoid it
22:15:17 <tabemann> m is the monad StateT is wrapped around
22:15:24 <jle`> just use `runState` to get back out the function
22:15:41 <jle`> the 'State' "constructor" is abstracted away, so there's nothing to pattern match on
22:16:07 <jle`> :t runState
22:16:08 <lambdabot> State s a -> s -> (a, s)
22:16:33 <jle`> instead of case s of State f -> ..., do let f = runState s in ...
22:16:41 <umib0zu> hm… interesting
22:16:58 <umib0zu> I did end up getting it working by the way. Obviously by not pattern matching http://pastebin.com/mm9GWFjd
22:18:06 <jle`> by the way, you're nesting state/runState there; that's actually sort of the entire "point" of State as a newtype/monad...to abstract over nesting and repeatedly matching on tuples, etc.
22:18:32 <jle`> otherwise you might as well just use normal functions
22:20:33 <lpaste_> geppettodivacin pasted “Factorial With Lookup” at http://lpaste.net/144850
22:20:50 * hackagebot urlpath 3.2.1 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-3.2.1 (athanclark)
22:20:50 <geppettodivacin> umib0zu: You may want to consider a rewrite like that.
22:20:58 <geppettodivacin> ^^
22:21:25 <geppettodivacin> In spite of lpaste telling me I could format it slightly better.
22:22:12 <lpaste_> jle` pasted “With State” at http://lpaste.net/144851
22:22:27 <jle`> ^ umib0zu, with taking advantage of the Monad instance for State
22:22:32 <jle`> oh, geppettodivacin already posted the same thing, heh
22:22:58 <jle`> but yeah, the point is that the entire reason we have a Monad instance is to be able to use bind and do notation etc. to abstract away manually passing around tuples
22:23:36 <jle`> umib0zu: the way you originally wrote it doesn't really take advantage of that, so it's kind of like a useless usage of State, heh.  kind of like trying to use strings to do boolean logic
22:23:47 <jle`> i'm not sure if that was a good analogy
22:23:55 <geppettodivacin> Certainly an interesting one.
22:23:57 <jle`> maybe it's like buying a car but walking everywhere
22:24:13 <geppettodivacin> ^Probably more accurate.
22:24:35 <jle`> or maybe in this case, buying a car and pushing your car everywhere
22:24:45 <jle`> because you still have to deal with the ugliness of newtype unwrapping etc.
22:24:52 <umib0zu> but I do want to update the state. not sure how to do that just yet.
22:25:09 <jle`> did you see my paste? http://lpaste.net/144851
22:25:12 <jle`> you can update it using `modify`
22:25:24 <jle`> or put
22:26:26 <jle`> well, you can modify it using `state` too, modify and put are nice utility functions
22:26:35 <jle`> modify f = state (\s -> ((), f s))
22:26:45 <jle`> put s = state (\_ -> ((), s))
22:28:14 <geppettodivacin> jle`: I'm pretty sure your code doesn't type check quite right. You're getting st, but you really need to be running a lookup on st before the case.
22:28:27 <jle`> ah yeah, i miswrote it
22:28:36 <lpaste_> jle` revised “With State”: “No title” at http://lpaste.net/144851
22:28:51 <jle`> probably should be (n-1)
22:29:12 <shanemikel> just discovered arrows.. looks like a natural way to build a framework for build systems.. been frustrated enough with JS Gulp
22:29:38 <jle`> i had originally written it using `gets` but i'm not sure if `gets` is covered in LYAH
22:30:16 <jle`> shanemikel: arrows are nice :)  in modern haskell most arrow usage has been replaced with abstractions based on Applicative, though
22:31:46 <geppettodivacin> jle`: No, it's not covered in LYAH.
22:32:01 <geppettodivacin> States were the most frustrating part of LYAH because the examples are outdated.
22:34:57 <shanemikel> jle`: have you heard of gulp?  it's essentially part of a set of tools that comprise a stream processing framework mostly used for build systems (using file streams, transformers, and generally splitting/joining/duplicating these streams into and out of various transforms and io sources/sinks) do you think these things lend themselves to applicative, because they sound more like arrow to me.. (I guess using some of the stuff from
22:34:57 <shanemikel> parsec might be possible)
22:35:50 * hackagebot chatter 0.8.0.2 - A library of simple NLP algorithms.  https://hackage.haskell.org/package/chatter-0.8.0.2 (RoganCreswick)
22:35:59 <shanemikel> if so, have any applicative abstractions you'd recommend?
22:36:04 <jle`> sounds a lot like like something you'd tackle in haskell with pipes and conduit
22:36:35 <jle`> which both offer applicative-based; pipes does a lot of abstracts inspired from categories
22:36:39 <jle`> *abstracitons
22:36:49 <jle`> applicative-based interfaces; i can't type today ><
22:37:03 <shanemikel> oh, ok.. so 'conduits' don't come from parsec then
22:38:19 <jle`> ah no, conduits is unrelated to parsec/parser combinators
22:38:56 <shanemikel> cool, thanks
22:41:37 <lpaste_> geppettodivacin revised “Factorial With Lookup”: “Factorial With Lookup” at http://lpaste.net/144850
22:49:59 <geppettodivacin> jle`: I didn't know about the modify function. Do you know if it's possible to use modify with data record syntax?
22:50:22 <jle`> yes, modify just takes any normal function
22:50:32 <jle`> modify (\x -> x { field = newValue })
22:51:01 <jle`> in `transformers`, modify is just a utility function wrapping around state:  modify f = state (\s -> ((), f s))
22:51:05 <jle`> nothing too magical :)
22:51:34 <jle`> you can pass it any function (s -> s); modify :: (s -> s) -> State s (), from transformers land
22:51:52 <geppettodivacin> Oh, that makes sense. Sometimes I forget about lambdas.
22:52:56 <ttt_fff> https://hackage.haskell.org/package/dependent-sum-0.3.2.1/docs/Data-GADT-Show.html
22:53:01 <ttt_fff> what is going on with this module?
22:53:03 <ttt_fff> what does it do?
22:55:29 <tabemann> :hoogle Word8 -> Char
23:09:09 <ReinH> :t chr . fromIntegral
23:09:11 <lambdabot> Integral a => a -> Char
23:09:22 <ReinH> tabemann: ^^
23:10:35 <jle`> ttt_fff: it looks like it provides a typeclass for "show for  *->* things"
23:11:13 <jle`> see the type signature of the equivalent for `show`: `gshow :: GShow t => t a --> String"
23:11:20 <jle`> er, GShow t => t a -> String
23:11:26 <jle`> vs. show :: Show t => t -> String
23:11:50 <ttt_fff> it's implementation makes no sense
23:12:03 <jle`> it's similar to the methods of Show
23:12:17 <jle`> class Show t where showsPrec :: Int -> t -> ShowS
23:12:25 <ttt_fff> wait
23:12:26 <jle`> class GShow t where gshowsPrec :: Int -> t a -> ShowS
23:12:30 <ttt_fff> I was not aware of how class Show worked
23:12:34 <ttt_fff> what is the "Int" for ?
23:12:43 <ttt_fff> okay, I'm going to admit now that I don't know how class Show works
23:12:50 <ttt_fff> GShow is src/Data/GADT/Show.hs
23:12:54 <ttt_fff> where is plain Show implemented ?
23:13:01 <jle`> the documentation for Show is pretty clear :)
23:13:07 <jle`> http://hackage.haskell.org/package/base-4.8.1.0/docs/Text-Show.html#t:Show
23:13:15 <jle`> show is implemented in terms of showsPrec
23:13:41 <ttt_fff> oh, the showsPrece's Int is precedence
23:13:46 <ttt_fff> for when show puts in () 's ?
23:14:39 <ttt_fff> jle`: ^^
23:14:40 <jle`> show x = shows x 0 ""
23:14:50 <jle`> er wait
23:14:56 <jle`> show x = showsPrec 0 x ""
23:15:04 <ttt_fff> yeah, my question is, the "Int" is for precedence right?
23:15:08 <jle`> yes
23:15:08 <ttt_fff> okay, so gshows / gshow makes sense now
23:15:28 <ttt_fff> okay, thanks; 
23:15:30 <jle`> the Show typeclass lets you define a custom `show` definition i guess
23:15:34 <ttt_fff> while you're here, can you help me with src/Data/Some.hs ?
23:15:40 <ttt_fff> there is this weird line as follows:
23:15:42 <ttt_fff> data Some tag where
23:15:48 <ttt_fff>   This :: !(tag t) -> Some tag
23:15:55 <ttt_fff> wtf is the ! in a TYPE SIGNATURE ?
23:16:02 <ttt_fff> This doesn't look like strictness annotation
23:16:12 <jle`> it's syntax for a strict field
23:16:23 <jle`> for example, data Foo = F !Int !int
23:16:28 <ttt_fff> you can put strictness annotations in type signatures?
23:16:29 <ttt_fff> hmm
23:16:37 <jle`> in gadt syntax that'd be data Foo where F :: !Int -> !Int -> Foo
23:16:42 <ttt_fff> okay, now that you put it that way, it makes sense
23:16:43 <ttt_fff> thanks
23:16:56 <jle`> it's a type signature, but it's also for specifying a data type using GADT syntax
23:17:19 <jle`> it's not a normal type signature...it also has special ways for declaring record fields/names
23:17:53 <jle`> data Sum a = Sum { getSum :: a } would be data Sum :: * -> * where Sum :: { getSum :: a } -> Sum a
23:18:09 <ttt_fff> hmm
23:18:18 <ttt_fff> alright, so intuitively, what does "Data.Some" do ?
23:19:07 <jle`> it's a way of abstracting over existential types
23:19:31 <jle`> so instead of saying exists t. Maybe t
23:19:38 <jle`> you can just say Some Maybe
23:20:05 <ttt_fff> okay, so it simplifies Impredicative Types ?
23:20:14 <jle`> you could do data SomeMaybe where SM :: Maybe a -> SomeMaybe
23:20:25 <jle`> not impredicative types
23:20:33 <jle`> do you understand the SomeMaybe type i just gave?
23:20:52 <ttt_fff> no
23:20:54 <ttt_fff> what is the full definition?
23:20:59 <jle`> i just gave it
23:21:09 <jle`> data SomeMaybe :: * where SM :: Maybe a -> SomeMaybe
23:21:31 <jle`> or in non-gadt syntax, data SomeMaybe = forall a. SM (Maybe a)
23:21:57 <jle`> so if you have a `SomeMaybe`, then it means it contains a `Maybe a`, where the `a` is something you don't know...it could be anything
23:22:19 <jle`> @let data SomeMaybe = forall a. SM (Maybe a)
23:22:21 <lambdabot>  Defined.
23:22:44 <jle`> > let mySM = SM (Just 10) in case mySM of SM x -> isJust x
23:22:46 <lambdabot>  True
23:22:57 <jle`> > let mySM = SM Nothing in case mySM of SM x -> isJust x
23:22:59 <lambdabot>  False
23:23:11 <ttt_fff> wait wait
23:23:15 <ttt_fff> data SomeMaybe :: *
23:23:21 <ttt_fff>   where SM :: forall a. Maybe a -> SomeMaybe
23:23:24 <ttt_fff> okay, that I understand.
23:23:27 <jle`> that's GADT syntax, heh, the two definitions are equivalent
23:23:28 <tabemann> I thought putting forall in types was now verboten
23:23:42 <ttt_fff> I'm an idiot, and seeing th eforalls helps me understand what is what.
23:24:05 <jle`> anyways yeah, in that case i explicitly made a data type to make a existential
23:24:16 <jle`> but that SomeMaybe is just `Some Maybe`
23:24:32 <jle`> type SomeMaybe = Some Maybe, from that module
23:24:32 * tabemann was told that existential types were no longer allowed by GHC
23:24:42 <tabemann> no wait I remember
23:24:48 * ttt_fff clearly does not know what the word 'verboten' means
23:24:49 <tabemann> it was class constraints in types that are no longer allowed
23:24:59 <ttt_fff> tabermann: did you get 800/800 on your SAT Verbals?
23:25:10 <tabemann> verboten == forbidden
23:25:30 <ttt_fff> jle`: ahhhh, src/Data/Some.hs is starting to make sense
23:25:40 <ttt_fff> withSome :: Some tag -> (forall a. tag a -> b) -> b
23:25:44 <ttt_fff> withSome (This thing) some = some thing
23:25:47 <ttt_fff> yeah, I understand this
23:25:53 <tabemann> (it's German, but I'm so used to using that I just assume people know what it means)
23:26:02 <jle`> or well, the `This` constructor is the `SM` constructor for SomeMaybe
23:26:13 <ttt_fff> jle`: very nice, thanks for the help
23:26:14 <jle`> but yeah
23:26:16 <jle`> np
23:26:28 <jle`> i still like to make my own explicit existential wrappers though from time to time
23:26:55 <jle`> the nice thing about this Some type is that it gives you "free instances"...i think some libraries with this type even give you more free stuff
23:27:47 <ttt_fff> okay
23:27:50 <ttt_fff> up to DSum now
23:27:58 <jle`> but yeah, withSM (SM x) f = f x      -- would be the equivalent function for our SomeMaybe
23:28:37 <jle`> @let withSM :: SomeMaybe -> (forall a. Maybe a -> b) -> b; withSM (SM x) f = f x
23:28:38 <lambdabot>  Defined.
23:28:45 <jle`> > withSM (SM Nothing) isJust
23:28:48 <lambdabot>  False
23:28:52 <jle`> > withSM (SM (Just "hello")) isJust
23:28:54 <lambdabot>  True
23:29:49 <jle`> > withSM (SM (Just 100)) (length . maybeToList)
23:29:51 <lambdabot>  1
