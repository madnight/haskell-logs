00:00:20 <nullx002> i found this tut useful: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
00:00:33 <Lokathor> ah, yes, that's a pretty solid one
00:00:49 <bernalex> I don't think it's very good. it has too much handwaving.
00:00:59 <nullx002> so i am new to haskell and funtional programming
00:01:19 <nullx002> just trying to have an overview of all
00:01:47 <bernalex> you shouldn't really strive to learn monads in particular. they're just a typeclass. there are many others. all of which are interesting and useful. see <https://wiki.haskell.org/Typeclassopedia>.
00:01:52 <bernalex> @where learnhaskell
00:01:52 <lambdabot> https://github.com/bitemyapp/learnhaskell
00:02:00 <bernalex> ^ is probably a nice place to start with learning haskell.
00:02:50 <Lokathor> bernalex, it is only a single blog post after all
00:02:52 <nullx002> LYHGG
00:03:11 <Lokathor> nullx002, I highly encourage http://www.seas.upenn.edu/~cis194/spring13/lectures.html over just reading LYAH
00:03:11 <nullx002> and real world haskell...
00:03:18 <bernalex> Lokathor: I can name several better single blog posts on monads.
00:03:43 <Lokathor> ah, well tell the rest of the class indeed
00:03:54 <nullx002> LOL
00:03:55 <bernalex> e.g. http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html & http://cdsmith.wordpress.com/2012/04/18/why-do-monads-matter/
00:05:23 <nullx002> hum.. i dont want to learn all of category theory (for now, at least) so i just want an overview of stuff, big picture
00:05:28 <bernalex> philip wadler's comprehending monads is the pretty much the epitome of monad tutorials though. for the more practically inclined, there's SPJ's tacking lthe awkward squad, and SPJ & pw's joint imperative functional programming.
00:06:29 <bernalex> nullx002: the big picture is very, very big. I suggest you follow useful haskell learning material like learnhaskell as linked above. if you want to learn about monads in particular, I just mentioned some very useful papers. I recommend starting with "tackling the awkward squad", as it is in an informal tutorial style.
00:07:03 <nullx002> nobody made a single video on this
00:07:05 <nullx002> strange
00:07:06 <suppi> I can also recommend you could have invented monads. i like that tutorial
00:07:17 <nullx002> i am reading that
00:07:23 <nullx002> it seems less technical than other one
00:07:31 <bernalex> nullx002: videos are very bad in that they take a very long time to convey very little information.
00:07:43 <nullx002> no way...
00:07:48 <nullx002> may be for programming
00:08:01 <Lokathor> bernalex, i think that, particularly in light of 7.10, those other pages (which i admit i haven't read closely in ages) are a little weaker just because they don't work people though the process of building a functor into an applicative into a monad
00:08:03 <suppi> nullx002, do the exercises as well :)
00:08:07 <bernalex> nullx002: there is <https://www.youtube.com/watch?v=ZhuHCtR3xq8> as an example. it takes an hour to watch, and covers maybe a paragraph of philip wadler's comprehending monads.
00:08:24 <quicksilver> bernalex: people are different and learn in different ways
00:08:36 <quicksilver> although personally I also find videos frustrating; many people disagree :)
00:08:44 <nullx002> yes, i like more interactive videos
00:09:07 <Lokathor> I love videos, but their information density is very low
00:09:23 <bernalex> quicksilver: I did not mean that they are frustrating or bad or anything other than they have *low information density*, so as a format it is not very efficient for this type of stuff.
00:09:25 <kadoban> Interactive videos … like throwing stuff at the screen?
00:09:39 <Lokathor> which is funny, because they take up so much file space, since they store so much extra stuff compared to text
00:09:49 <bernalex> quicksilver: note also that I offered this as an explanation to the low count of "monad tutorial videos", nothing more.
00:09:58 <quicksilver> I just read adit.io's functor-applicative-monad tutorial blog for the first time
00:10:04 <nullx002> yes, they take lot of space of google/youtube not my hard drive :D
00:10:05 <quicksilver> admittedly I'm not the target audience
00:10:17 <bernalex> another reason there are few "monad tutorial videos" is likely because it's just monads. it's pretty much just a function.
00:10:20 <quicksilver> but I think it was very good for functor and applicative
00:10:32 <quicksilver> but less good for monad
00:10:42 <quicksilver> the picture analogy didn't scale well to >>=
00:10:42 <nullx002> ok
00:10:58 <quicksilver> I do like 'you could have invented monads' which was linked above.
00:11:16 <bernalex> quicksilver: I dislike handwaving without qualifying that it is indeed handwaving, and informing how the learner can break free from the confines of the restrictive analogue.
00:11:37 <bernalex> that is my main objection to the pictures tutorial.
00:12:26 <nullx002> lol
00:12:28 <bernalex> nullx002: http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html this is related and very practical. it shows how to desugar do syntax into regular >>=, and more.
00:12:48 <nullx002> but why desugar?
00:13:02 <nullx002> sugar looks more clean to eye
00:13:03 <bernalex> nullx002: to understand how do and >>= actually works.
00:13:05 <quicksilver> because if you think do syntax is magical you may find it harder to understand
00:13:14 <quicksilver> and also harder to abstract when you want to do something clever
00:13:20 <quicksilver> when you realise it's just a convenient shorthand for >>=
00:13:21 <nullx002> ok
00:13:38 <quicksilver> then you reduce the problem to understanding >>= which is, after all, just a binary operation
00:13:39 <nullx002> hum... to bit better for beginners like me.
00:13:41 <quicksilver> not magic.
00:13:51 <bernalex> one frequent mistakes newcomers to haskell do in my view is rely on syntax sugar and what they think is an intuition for things, rather than actually understanding the types in a more profound manner.
00:14:15 <bernalex> so when they get an error, they will randomly sprinkle fmaps, change . into $ and vice versa, in the hopes of it "fixing" their code.
00:14:42 <nullx002> right now i am far far away form that...
00:14:51 <nullx002> just few simple 10 line codes
00:15:08 <bernalex> they have the "intuition" that "oh, . doesn't work, must be $ then", rather than understanding the type. that is unfortunate.
00:15:19 <bernalex> nullx002: I am merely explaining why desugaring is a useful exercise.
00:15:53 <nullx002> bernalex: may be you are right but i am not there yet..
00:15:57 <bernalex> nullx002: related is understanding beta-reduction -- arguably the strongest point/main advantage of functional programming. see <http://www.haskellforall.com/2013/12/equational-reasoning.html>.
00:16:06 <kadoban> Ohhh nooo. One of the packages I want to use in my project that I'm trying to convert to GHCJS is cryptohash … which is mostly C wrappers :(
00:16:23 <bernalex> nullx002: you should try to follow the learnhaskell thing I linked above. it links to some very good stuff.
00:16:47 <Lokathor> bernalex, just avoid (.) most of the time :P
00:16:51 <nullx002> ok, thanks for all the links,, it may take a day or two to get through all of that
00:17:05 <nullx002> .P
00:17:12 <nullx002> thanks, all
00:17:14 <nullx002> bye for now
00:17:15 <bernalex> nullx002: it will likely take you a day or two. as in 48 hours of work.
00:17:36 <nullx002> if i like it i learn it fast and hard
00:17:44 <nullx002> or else may take few weeks
00:17:46 <nullx002> or months
00:18:12 <nullx002> anyway thankyou all...
00:18:14 <nullx002> gg
00:18:22 <bernalex> happy hacking.
00:32:21 <kadoban> Anyone know offhand of a pure haskell implementation of RIPEMD-160? Need it for GHCJS usage, so cryptohash is out.
00:46:23 <kadoban> Hah, yes. My project basically works on ghcjs (with fake hashes at the moment). So cool.
00:54:28 <quchen> What are the differences between compiled and interpreted (?) Haskell, as in ghc vs. runghc, when it comes to stuff like threading?
00:54:46 <quicksilver> interpreted ghc has the same thread model as compiled
00:54:58 <quchen> I cannot optimize code in runghc scripts, but that's fine if the program logic is small. What I do need is multithreading, control over the GC, and what not
00:55:07 <quchen> (The use case is Shake)
00:55:11 <quicksilver> in fact, interpreted ghc always uses the fully-threaded RTS
00:55:29 <quchen> quicksilver: So what are the shortcomings of using runghc?
00:55:37 <quicksilver> I think this is one of the unusual things about GHC - the same RTS is used for compiled and interpreted code
00:55:39 <quchen> Are there certain things I cannot do?
00:55:58 <quicksilver> and that RTS is capable of hosting a mixture of compiled and interpreted modules simultaneously
00:56:09 <quicksilver> quchen: optimisation in general and RULES in particular, I think?
00:56:27 <quicksilver> you can always compile stuff you need to be optimised into a compiled module
00:56:32 <quicksilver> and just import it into runghc tho.
00:57:08 <quchen> Sure, but runghc allows me to skip the wrapper (e.g. bash) script to compile-and-run my build system.
00:57:22 <quchen> There are no temporary files, and all those nice things.
01:04:26 * hackagebot lucid 2.9.3 - Clear to write, read and edit DSL for HTML  https://hackage.haskell.org/package/lucid-2.9.3 (ChrisDone)
01:47:15 <faorien> Hello, could you help me with writing Applicative instance of this newtype:      newtype Trampoline m r = Trampoline { bounce :: m (Either (Trampoline m r) r) }
01:48:25 <kqr> why can a modern ghc not compile haskell 98? that is pretty ridiculous IMO
01:49:39 <quicksilver> kqr: because nobody was prepared to do the work? because nobody considered it important enough to do the work? etc
01:50:29 <jle`> faorien: have you got the Functor instance yet?
01:50:55 <faorien> fmap f = Trampoline . fmap (either (Left . (fmap f)) (Right . f)) . bounce
01:51:59 <kqr> quicksilver, is that a lot of work?
01:52:20 <jle`> fmap f (Trampoline mx) = fmap (\e -> case e of Left l -> Left (fmap f l); Right r -> Right (f r)) mx
01:52:39 <jle`> to add points, heh.  er, forgot the constructor
01:52:48 <jle`> what would the type of `pure` be?
01:52:56 <bernalex> that kind of backwards compatibility is death.
01:53:03 <faorien>   pure = Trampoline . fmap Right . pure
01:53:13 <quicksilver> kqr: I don't even know :) It doesn't seem like it shuold be very much, but it would help to have better support for alternate preludes
01:53:37 <jle`> why not pure x = Trampoline (pure (Right x)), or pure = Trampoline . pure . Right, if you don't like points :)
01:53:44 <quicksilver> bernalex: not necessarily; perl5 will happily run code from 20 years ago and perl has certainly not been stagnant.
01:53:47 <jle`> but yeah, that works
01:53:53 <jle`> what would the type of <*> be?
01:54:04 <bernalex> quicksilver: perl has more manpower and interest than haskell.
01:54:08 <quicksilver> bernalex: but it's an effort, and someone needs to value the result enough to put in that effort.
01:54:23 <quicksilver> that is true.
01:54:43 <faorien> jle`, that is where i have a problem... (Trampoline f) <*> (Trampoline v) is a problem when f has  Left inside but v has Right inside
01:54:49 <jle`> what would the type be?
01:54:57 <bernalex> haskell98 is no longer compatible with base. if you want ghc to run with haskell98, fix that package. good luck, lol.
01:55:30 <quicksilver> bernalex: (or devise a good way for GHC to run with an alternate base; I think this is probably the right way)
01:56:05 <jle`> faorien: well, <*> is basically a way to "sequence" actions, so in this case, you can make it short-circuiting
01:56:14 <quicksilver> <*> :: Trampoline m (a ->b) -> Trampoline m a -> Trampoline b ?
01:56:18 <quicksilver> m b
01:56:39 <faorien> so far i have this
01:56:44 <faorien>   (Trampoline f) <*> (Trampoline t) = Trampoline ((fmap h f) <*> t)
01:56:48 <faorien>       h (Right v) = either (Left . (fmap v)) (Right . v)
01:56:52 <faorien>       h (Left g) = either (Left . (g <*>)) ???
01:57:20 <jle`> for this case in particular it's easiest for me to pretend I have a Monad constraint on `m`, and then generalize it to Applicative afterwards
01:57:36 <jle`> Trampoline f <*> Trampoile x = do
01:57:41 <jle`>     f' <- f
01:57:45 <jle`>     case f' of
01:57:47 <jle`> etc.
01:58:01 <faorien> yes, that way I could write it myself as well, but I wondered if I could do it without the Monad constraint on m
01:58:19 <jle`> once you write it with the Monad constraint, I think you can start to generalize
01:58:29 <jle`> because writing it that way sort of gives you an idea of "what's happening"
01:59:03 <jle`> with an intuition that you can take advantage of, hopefully :)
01:59:28 <faorien> jle`, thanks, I'll do a few more attempts
02:01:37 <jle`> and typed holes do help!
02:12:16 <faorien> jle`, I came up with         h (Left g) = either (Left . (g <*>)) (\v -> Left (fmap ($ v) g))     , is it ok or is there some other way of writing it more "nicely" ?
02:13:12 <jle`> if it were me i'd definitely write it out pointfully, heh. but that looks correct from what i can see
02:14:23 <faorien> jle`, thank you very much for your help
02:14:40 <jle`> np, if i was able to help at all, heh
02:18:15 <merijn> tbh, I have no clue what that does written as is
02:18:20 <merijn> Needs more local definitions and names
02:25:08 <ocramz> hi there!
02:30:34 <sternenseemann> hello
02:31:12 <quchen> Readability should be considered part of correctness for all practical purposes.
02:31:32 <quicksilver> I don't think that is a practical notion
02:31:40 <quicksilver> correctness is objectness; readability is subjective.
02:31:47 <quchen> Correctness of something is a property you have to be able to verify. The code above is terrible, I can't read anything.
02:32:18 <quchen> Local definitions can make it not terrible.
02:32:50 <quchen> quicksilver: I guess "correct" and "evidently correct" are good words here.
02:32:59 <quicksilver> ($[]) . appEndo . snd . runWriter
02:33:06 <quicksilver> some people find that unreadable
02:33:11 <quchen> Yes.
02:33:12 <quicksilver> I find it clear and concise.
02:33:17 <quicksilver> subjective.
02:33:19 <merijn> quicksilver: Without a type signature I do, with a type signature it could be readable
02:33:33 <quicksilver> :t ($[]) . appEndo . snd . runWriter
02:33:35 <lambdabot> Writer (Endo [t]) a -> [t]
02:33:41 <quicksilver> conveniently enough it is unambiguously inferrable :P
02:33:49 <merijn> See, now I can see what it's doing
02:34:04 <bernalex> edwardk: ping?
02:34:07 <quicksilver> faorien's code had a type signature, in context
02:34:13 <quicksilver> it's just he pasted one line in here without it :)
02:34:29 <bernalex> edwardk: you're probably asleep... I'll email you.
02:34:40 <quicksilver> it's part of an Applicative instance so there isn't really any doubt about what the type sig of <*> for most haskell readers.
02:35:39 <quicksilver> ($[]) is what happens when you let a monkey (:[]) get too close to a capitalist.
02:36:30 <merijn> Robot monkey, you mean
02:37:16 <quicksilver> perhaps :)
02:39:29 * hackagebot codex 0.4.0.6 - A ctags file generator for cabal project dependencies.  https://hackage.haskell.org/package/codex-0.4.0.6 (aloiscochard)
02:48:03 <Bratishka> Братишки
02:48:07 <Bookman900> Bonjour
02:48:07 <Bratishka> А хаскелл - УГ
02:48:13 <Bratishka> Как вот я сру
02:48:14 <Bratishka> Говном
02:48:18 <Bratishka> А вы его едите
02:48:25 <Bratishka> И называете хацкеллом
02:49:59 <frerich> I suspect this could be a valid Haskell program.
02:50:22 <frerich> Or rather, a valid piece of Haskell code.
02:50:26 <merijn> frerich: No, it's lacking the keywords to define functions, also capital letters means data constructors
02:51:17 <frerich> merijn: Maybe it was a quote from a 'do' blog which merely called some functions with arguments
02:51:24 <frerich> block
02:53:50 <quicksilver> that brings to mind an interesting challenge
02:54:11 <quicksilver> pick a piece of famous poetry or whatever and the devise definitions so that it is a valid haskell 'do' block which does something neat
02:54:35 <frerich> True, but just enclosing it in a multi-line string does not count.
02:54:50 <quicksilver> no it has to be a do block, each line of the poem has to be an action
02:54:57 <quicksilver> no restriction on monad used tho
02:55:32 <quicksilver> to be interesting the poem has to contain a decent number of repeated words
02:56:30 <merijn> Anyone got any tips on how to name the modules of my package if I don't want to claim some generic name? (i.e. I'm writing bindings to a C library Foo, but don't want to just put my package in the Foo name space and stop anyone else from using that...)
02:57:08 * frerich considers 'roses are red \n violets are blue \n my name is dave \n microwave' -- alas, not too much repetition
02:57:16 <merijn> Do we have the entire hackage hierarchy visible somewhere so I can figure out where it'd fit?
02:58:03 <frerich> merijn: There is https://gist.githubusercontent.com/raw/463423/f8458d83b1a7cc26cdbf812747188993e50cd8a2/The%20Haskell%20module%20landscape (found on http://chrisdone.com/posts/haskell-module-landscape )
02:59:35 <Xack> \o
03:00:09 <FPtje> Hey I'm optimising my linter, and I found that I'm searching the lexicon for "bad sequences" in a really silly way (A huge list of bad sequences and Vectors that keep track of things). I figured that what I'm doing is actually some searching kind of parser, like regex, but all the terminals are already haskell types. How should I tackle this?
03:00:26 <Xack> https://gist.github.com/33f874470bc786a9ce51 mind if someone could explain to me as to why i get: https://gist.github.com/068eb600bc2d19c6dd5a
03:00:47 <merijn> FPtje: Parsec can actually parse input other than String/Text if you provide an appropriate Stream instance
03:01:02 <merijn> FPtje: So you could actually make a parsec parser that parses your ADT :)
03:01:03 <FPtje> For reference, the horror of what I'm doing now can be found here: https://github.com/FPtje/GLuaFixer/blob/master/src/GLuaFixer/AG/LexLint.ag#L68 in the badSequences and progressScan functions
03:01:29 <FPtje> merijn I've considered parsec, but I need it to search the whole input and return ALL successful parses.
03:01:57 <merijn> Xack: circle and/or square want a Double
03:02:00 <FPtje> I imagine running the parser starting from every possible token, and then filtering all the successful parses can be very expensive
03:02:04 <merijn> Xack: So GHC is inferring "x :: Double"
03:02:11 <Xack> oh bugger! thanks!
03:02:25 <Xack> i should read the type sigs more, thanks very much merijn :)
03:02:29 <merijn> Xack: However, "mod :: Integral a => a -> a -> a" so it wasn't an integral type (which double obviously isn't)
03:02:34 <merijn> Xack: You probably want
03:02:39 <merijn> @quote monochrom fromIntegral
03:02:39 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
03:02:47 <Xack> haha
03:02:51 <Xack> thanks!
03:03:09 <merijn> > fromIntegral (5 :: Int) :: Complex Double
03:03:11 <lambdabot>  5.0 :+ 0.0
03:04:53 <FPtje> merijn, example of the mechanism would be with the following Lua code: "if table.getn(someTable) then return table.GetLastValue(someTable) end", it should generate warnings for the two calls to table.getn and table.GetLastValue, because both are deprecated
03:05:11 <FPtje> The Lua code is already lexed with Parsec
03:05:42 <ely-se> is there a library similar to naturals that offers Natural a for any Integral a, instead of always using Integer?
03:05:52 <merijn> FPtje: Wouldn't it be easier to have your parser recognise deprecated names and issue warnings during parsing?
03:06:15 <FPtje> merijn no, due to separation of concerns. The lexer is a separate library
03:06:39 <FPtje> the parse too 
03:06:49 <ely-se> I guess I can just use unsigned integers
03:09:03 <quicksilver> unsigned integers are cute
03:09:14 <quicksilver> > (5-10) :: Word8
03:09:16 <lambdabot>  251
03:09:19 <quicksilver> > -1 :: Word16
03:09:21 <ely-se> :p
03:09:21 <lambdabot>  65535
03:10:05 <ely-se> ℕ mod n
03:11:02 <quicksilver> in some respects it's easy to stay correct with signed integers vecause you can actually complain about the negative numbers
03:11:10 <quicksilver> but it all depends what your requirements are
03:13:59 <ely-se> function which is only defined for non-negative numbers
03:15:27 <ely-se> making the function total helps the automatic bug detector (aka type checker), but requires either f :: Int -> Maybe T, or f :: Nat -> T, not f :: Int -> T
03:19:15 <quicksilver> it only helps if you have a good way to propagate that through the rest of the program
03:19:28 <quicksilver> does your program use non-negative numbers everywhere? or only in some places?
03:19:43 <quicksilver> are you prepared to carefully work with mulitple numeric types and convert where conversions are needed
03:19:55 <quicksilver> you need a vision about the total structure of your program to make the right call about a partial function IMO.
03:42:39 <Nahiyan> Hello. I have a small problem... the home or end buttons don't work in the GHCi prompt. is there a solution?
03:44:01 <quchen> ely-se: GHC 7.10 added a Natural type which is exactly what you're asking for: unsigned Integer
03:44:14 <ocramz> Nahiyan: ? what home or end buttons?
03:44:29 <ocramz> ghci is a terminal application
03:44:51 <Nahiyan> I mean, in terminals, if you press home, then your typing position goes back to the start of the prompt
03:45:04 <pavonia> I guess home and end keys are meant
03:45:17 <ocramz> oh yeah sure :D sorry
03:45:35 <ocramz> I use ghci within emacs so I'm C-a and C-e ing all the time
03:45:55 <Nahiyan> hmm
03:46:14 <merijn> quicksilver: Depends on your language
03:46:19 <ocramz> but still, you want an answer. What OS are you using?
03:46:24 <merijn> quicksilver: With C staying correct with signed integers is infinitely hard
03:46:29 <quicksilver> merijn: of course, but I was talking about haskell.
03:46:42 <Nahiyan> linux... arch linux
03:46:42 <quicksilver> Nahiyan: try ctrl-a and ctrl-e?
03:46:49 <Nahiyan> I am using ghci in zsh
03:47:05 <Nahiyan> hmm it works
03:47:23 <Nahiyan> Ctrl-d also deletes a character.
03:47:24 <jameseb> Nahiyan: it may be a problem with your terminal - home and end work in ghci for me
03:47:26 <ocramz> :D
03:47:26 <quicksilver> that's pretty standard keys, works in zsh and bash as well
03:47:32 <Nahiyan> hmm ok
03:47:34 <quicksilver> can't explain why 'Home' and 'End' aren't working tho
03:47:36 <ocramz> terminals are weird
03:47:52 <Nahiyan> yes it's probably a problem with my key bindings. thanks
03:47:53 <merijn> Terminals aren't weird, just archaic and outdated
03:47:54 <bernalex> Nahiyan: uh does home and end work outside fo ghci?
03:48:16 <ocramz> merijn: præcis
03:48:18 <bernalex> merijn: s/Terminals/Software/
03:48:30 <Nahiyan> yes
03:48:37 <bernalex> Nahiyan: do they work if you rlwrap ghci?
03:48:56 <Nahiyan> what do you mean?
03:49:03 <bernalex> Nahiyan: rlwrap ghci
03:49:07 <ocramz> oh yes, rlwrap could be a good idea
03:49:13 <ocramz> I was using it for clisp
03:49:21 <bernalex> you def need it for sbcl, yeah
03:49:50 <merijn> Seems a bit redundant to rlwrap ghci considering haskeline should already provide most those features
03:49:51 <Nahiyan> in ZSH I have to use a keyboard setup builtin to save my keyboard bindings to zsh
03:50:10 <Nahiyan> zkbd
03:50:19 <Nahiyan> it tests what keys are and saves them in
03:50:27 <bernalex> why not just use .zshrc?
03:50:57 <bernalex> merijn: ya i no. but if it works in there the problem might be with ghci somehow rather than just the terminal emulator or shell. idk.
03:51:00 <Nahiyan> I do... the settings that zkbd detects are saved and that is used in my .zshrc file
03:51:21 <Nahiyan> I think zsh adjusts to my home keys but ghci doesn't
03:51:56 <Nahiyan> however i would be grateful if there was a setting so I could use those keys in ghci...
03:52:45 <bernalex> did they work when rlwrapped?
03:52:59 <Nahiyan> I don't know how to rlwrap..
03:53:14 <bernalex> I very recently told you how to do it. "rlwrap ghci".
03:53:21 <Clint> Nahiyan: if you run 'infocmp' does khome acurately describe the sequence your terminal sends when you hit Home?
03:53:28 <Nahiyan> I will install it
03:53:37 <Nahiyan> ok let me check Clint 
03:54:05 <Nahiyan> sorry... rlwrap doesn't work
03:54:43 <Nahiyan> khome=\EOH,
03:55:13 <Nahiyan> my terminal (Konsole) is set to send: \E[1~
03:55:25 <Clint> seems like that might be your problem
03:55:44 <Nahiyan> hmm I have multiple bindings for Home
03:56:22 <Nahiyan> Konsole, for Home+AppCursorKeys-AnyModifier: \EOH
03:56:37 <Fylwind> is there a 'checked' integer conversion in Haskell? (i.e. errors if it's out of range)
03:56:59 <merijn> Fylwind: No, but it'd be pretty simple to define
03:57:17 <merijn> Well, pretty simple depends on exactly which conversion you want to do...
03:57:35 <Fylwind> I feel like the default behavior is a bit unsafe
03:57:37 <merijn> I should be careful what I call simple, considering I fucked it up 3 times trying to fix one bug >.>
03:57:48 <Nahiyan> http://i.imgur.com/t4NE7Rc.png
03:58:06 <merijn> Fylwind: The only real solution is newtype + smart constructor, i.e. "mkEven :: Integer -> Maybe Even" or something like that
03:58:51 <bernalex> the only real solution is obviously to use type-level Peano Numbers.
04:00:34 <Fylwind> merijn: thanks for the suggestion; though I might just use int-cast to avoid reinventing the wheel :)
04:02:47 <Nahiyan> Clint, any ideas on a fix..?
04:06:03 <quicksilver> Nahiyan: either make Konsole behave the way $TERM says it does
04:06:12 <quicksilver> or set $TERM to reflect the way Konsole behaves.
04:06:19 <quicksilver> sadly I don't actually know how to do either of those
04:06:25 <dzhus`> Does JSON/Data.Aeson disallow naked values at top level? (decode (encode 1) :: Maybe Int) gives me Nothing
04:06:27 <quicksilver> but term type definitions exist for a reason!
04:07:27 <quicksilver> dzhus`: well, what about (decode "1" :: Maybe Int) ?
04:07:30 <ChristianS> dzhus`: it does, but only in relatively recent versions
04:07:51 <dzhus`> ChristianS: in recent versions of what?
04:08:01 <ChristianS> dzhus`: aeson
04:08:06 <dzhus`> quicksilver: Nothing :(
04:08:17 <quicksilver> "In aeson 0.8 and earlier, it parsed only object or array types, in conformance with the now-obsolete RFC 4627"
04:08:42 <quicksilver> but that statement is about the top-level 'json' parser
04:08:52 <quicksilver> I didn't think it applied to manual invocations of decode
04:09:04 <quicksilver> dzhus`: decode "[1,2,3]" :: Maybe [Int] ?
04:10:09 <dzhus`> quicksilver: that works
04:10:24 <dzhus`> I'll just use bare toJSON/parseJSON
04:10:30 <ChristianS> dzhus`: what's your aeson version?
04:10:50 <Nahiyan> hmm
04:11:22 <quicksilver> what's the point of Int being an instance of FromJSON if you can't call decode on it?
04:11:26 * quicksilver feelsl ike he is missing something
04:12:18 <dzhus`> ChristianS: aeson-0.8.0.2
04:12:37 <ChristianS> quicksilver: you can decode at as part of a bigger json object, but not (in earlier aeson versions) standalone
04:12:39 <phadej> use aeson-compat ;)
04:12:46 <phadej> aeson-extra, sorry
04:12:59 <quicksilver> ChristianS: OK so you can't use "json" on it, I understand that.
04:12:59 <ChristianS> dzhus`: try aeson-0.10 or later, i think that should fix it
04:13:07 <quicksilver> ChristianS: but why can't you use "decode" on it?
04:13:23 <quicksilver> what is the point of "decode" having the type FromJSON a => ByteString -> Maybe a
04:13:28 <quicksilver> of it doesn't work on all FromJSON types?
04:14:07 <Nahiyan> hey also, how can you undefine a function or definition if you set it with let? like if you want to remove the definition of xs when you used: let xs = ...
04:14:23 <phadej> Nahiyan: why you'd want that?
04:14:28 <ChristianS> well, decode says that it expects a "JSON document" as input
04:14:45 <Nahiyan> I definied a function with pattern matching in the wrong order. so I have to undefine and write it again
04:14:54 <bernalex> Nahiyan: you don't have to undefine it
04:15:02 <Nahiyan> ok what do I do
04:15:05 <phadej> jes, the failure in old aeson is in "ByteString -> m Value" not in "Value -> m a" part
04:15:09 <bernalex> @let value = 1
04:15:11 <lambdabot>  Defined.
04:15:12 <bernalex> > value
04:15:12 <ChristianS> the definition of JSON document has now been relaxed, but traditionally it had to start with { or [ (after optional whitespace)
04:15:14 <lambdabot>  1
04:15:15 <bernalex> @let value = 2
04:15:16 <lambdabot>  .L.hs:155:1:
04:15:17 <lambdabot>      Multiple declarations of ‘value’
04:15:17 <lambdabot>      Declared at: .L.hs:154:1
04:15:17 <bernalex> > value
04:15:18 <lambdabot>  1
04:15:19 <bernalex> oh
04:15:22 <bernalex> lol
04:15:24 <bernalex> lambdabot won't let you do that
04:15:26 <bernalex> but ghci will
04:15:36 <dzhus`> quicksilver: http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html#g:6
04:15:45 <Nahiyan> I know but I defined a pattern-matching function in the wrong order... it fails to work right
04:15:45 <quicksilver> phadej: oh that helps me understand, thanks :)
04:16:03 <bernalex> Nahiyan: just define it in the right order.
04:16:14 <Nahiyan> again? ok
04:16:22 <bernalex> Nahiyan: are you trying to do "f x = 1" and then "f _ = 2" on separate lines?
04:16:31 <bernalex> Nahiyan: because the latter will just make ghci forget about the former
04:16:31 <Nahiyan> yes
04:16:41 <Nahiyan> oh... so that's why it wasn't working
04:16:42 <bernalex> Nahiyan: use semi colons to separate them -- do it on one line.
04:16:48 <Nahiyan> ok thanks
04:16:56 <dzhus`> ChristianS: thanks for the tip re 0.10, will try
04:17:10 <quicksilver> dzhus`: nod thanks :)
04:17:21 * quicksilver understands now
04:17:36 <bernalex> Nahiyan: like this "let f 1 = "one"; f _ = "more than one".
04:17:52 <merijn> I would recommend just not defining things in ghci
04:18:15 <Nahiyan> ok thanks
04:18:16 <Fylwind> hmm does Data.Binary not have a nice way to handle errors … ?
04:18:27 <bernalex> merijn: meh. it's frequently useful.
04:20:11 <merijn> hmmm
04:20:19 <merijn> ok, quick question
04:20:31 <merijn> How do I define a nullary pure function in the FFI?
04:20:38 <merijn> "foo :: CLong"?
04:20:54 <ely-se> interesting
04:21:11 <ely-se> > [ (not a || b) == (a <= b) | a <- [True, False], b <- [True, False] ]
04:21:13 <lambdabot>  [True,True,True,True]
04:21:24 <ely-se> I don't like implication being written "<=" :)
04:21:41 <quicksilver> Fylwind: no
04:21:46 <Fylwind> ely-se: I don't like that either :p
04:21:57 <quicksilver> Fylwind: it's optimised for the use case of fast streaming reading of binary data with a guaranteed format
04:21:57 <Fylwind> quicksilver: that's unfortunate
04:22:05 <quicksilver> Fylwind: i.e. you wrote it yourself or you trust it.
04:22:10 <bernalex> Fylwind: ely-se: what's the problem with that?
04:22:21 <quicksilver> there are other libraries which handle errors better
04:22:25 <quicksilver> like parsec, for example :)
04:22:26 <Fylwind> bernalax: it looks like ⇐
04:22:58 <bernalex> Fylwind: looks like leq to me.
04:23:20 <Fylwind> quicksilver: I think I'm going to go with cereal instead
04:24:14 <Fylwind> quicksilver: I just can't imagine not having error handling being something that's typical in production usage (yeah I know you can still catch 'error' but it's annoying)
04:24:37 * hackagebot combinat 0.2.8.1 - Generate and manipulate various combinatorial objects.  https://hackage.haskell.org/package/combinat-0.2.8.1 (BalazsKomuves)
04:24:54 <quicksilver> Fylwind: well if you're just concerned about top-level errors you have decodeOrFail
04:25:09 <quicksilver> decodeOrFail :: Binary a => ByteString -> Either (ByteString, ByteOffset, String) (ByteString, ByteOffset, a)
04:25:24 <Fylwind> bernalex: it's just that => is ⇒ but somehow <= is not ⇐; just something I find aesthetically inconsistent
04:26:22 <bernalex> well it's <= >=, so I think that's fine.
04:26:45 <quicksilver> I was wrong anyway.
04:26:47 <bernalex> I guess I might actually have preferred =< and >=, but it's not something I feel strongly about.
04:26:50 <quicksilver> Get has a an Alternative instance now!
04:26:54 <quicksilver> so binary can recover from errors
04:27:05 <quicksilver> that's new (FSOV new - sometime in the last 5 years)
04:27:25 <Fylwind> quicksilver: I didn't see that … oops must've been reading out-of-date docs again
04:27:46 <quicksilver> someone told me cereal was being deprecated and binary was the new hotness
04:27:48 <quicksilver> I think.
04:27:57 <Fylwind> yeah I was reading binary-0.5
04:28:11 <Fylwind> well that's a pity because I found 'cereal' to be a cute name :p
04:28:17 <bernalex> quicksilver: what's their differences? I've only used cereal.
04:28:56 <quicksilver> well it used to be that one of the main differences was that binary couldn't recover from errors or handle them
04:29:03 <quicksilver> but that appears to no longer be true
04:29:14 <Fylwind> bernalex: yeah if the programming world were to be rebooted from scratch I would vote for =< hehe, but <= is kind of ingrained now
04:29:19 <merijn> No, the biggest difference was that binary didn't support incremental deserialisation using strict ByteString
04:29:29 <merijn> Since it only supported lazy ByteString as in and output
04:29:44 <merijn> Now that binary supports incremental consumption I default to using binary
04:29:53 <quicksilver> Fylwind: looks like that Alternative instance was added in 0.6
04:29:56 <merijn> There were vague plans to merge the two, afaik
04:30:30 <quicksilver> and decodeOrFail in 0.7
04:30:34 <quicksilver> or between 0.6 and 0.7 at any rate
04:30:38 * Fylwind is just going to pick the library with the most downloads then
04:30:55 <bernalex> Fylwind: have fun using Java ;D
04:31:20 <quicksilver> merijn: by incremental from strict, you mean returning the ByteOffset of unconsumed data?
04:32:00 <merijn> quicksilver: No, I mean having a "runGetIncremental :: Get a -> Decoder a"
04:32:30 <merijn> With "pushChunk :: Decoder a -> ByteString -> Decoder a"
04:32:35 <merijn> Where ByteString is strict
04:32:47 <Fylwind> bernalex: :V
04:32:51 <merijn> Before you only had "runGet :: Get a -> ByteString -> a" which took a lazy ByteString
04:32:59 * quicksilver nods
04:34:38 * hackagebot memoization-utils 0.1.0.1 - Utilities for memoizing functions  https://hackage.haskell.org/package/memoization-utils-0.1.0.1 (yamadapc)
04:39:38 * hackagebot chalmers-lava2000 1.6 - Hardware description EDSL  https://hackage.haskell.org/package/chalmers-lava2000-1.6 (EmilAxelsson)
04:42:04 <merijn> @hoogle Handle -> Ptr CFile
04:42:07 <lambdabot> Foreign.Ptr castFunPtrToPtr :: FunPtr a -> Ptr b
04:42:07 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
04:42:07 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:42:22 <merijn> Anyone know how to get a "Ptr CFile" from a Handle/Fd?
04:44:39 <quicksilver> FFI to fdopen I imagine
04:44:41 <quicksilver> merijn: http://hackage.haskell.org/package/mtp-0.1.1.1/src/Foreign/Handle.hsc
04:44:59 <merijn> quicksilver: Yeah, I just found that :p
04:45:02 <merijn> Brave guy...
04:45:09 <merijn> unsafe calling file functions
04:46:28 <quicksilver> why do you need a FILE* anyway?
04:46:52 <merijn> quicksilver: FFI call to a function wanting a FILE*
04:47:20 <quicksilver> if you're FFIing anyway maybe wrap it C-side
04:47:26 <quicksilver> and call fdopen yourself on the C side :)
04:51:35 <ocramz> hi all
04:51:51 <jophish> It would be really nice if (+) in Num had type a -> b -> Add a b where Add is an associated type in Num
04:52:17 <jophish> Obviously this wouldn't be without problems!
04:53:03 <jophish> but it would mean being able to do things like have Meters x * Seconds y = MeterSeconds (x*y)
04:53:46 <quicksilver> there are many libraries doing type-tagged dimensions, jophish :)
04:53:57 <jophish> quicksilver: well, that's one example
04:54:01 <Azevedo`> \whois taachan
04:54:07 <Azevedo`> lol
04:54:12 <jophish> quicksilver: and they all have to create their own addition operators :D
04:54:25 <jophish> or only check at runtime
04:54:42 <quicksilver> jophish: https://github.com/bjornbm/dimensional-dk
04:54:59 <jophish> I think the issues with using that type outweigh the benefits though
04:55:18 <pavonia> We could also have instances Add Int String then \o/
04:55:21 <ocramz> say I have a pointer to a foreign resource, and can copy arrays of data back and forth via e.g. the Vector.Storable interface. However, I would like to perform as few copies as possible, i.e. only when the resource changes. Question; is there a name for this behaviour?
04:56:07 <benma> about https://tryhaskell.org/
04:56:13 <jophish> pavonia: worth not going it just because of that :)
04:56:32 <benma> how can i import pacakages? like http://hackage.haskell.org/package/mwc-random, for example
04:56:55 <benma> or see a list of available packages
04:56:56 <quicksilver> jophish: anyway first you need a haskell standard with associated types, I guess
04:57:18 <quicksilver> but I can't see myself supporting a type system that fancy for the basic numeric types in the prelud
04:57:29 <quicksilver> it's not like it's hard to make this work with a library
04:58:24 <jophish> quicksilver: I totally agree :)
04:58:44 <merijn> ok, API design question
04:58:48 <jophish> although I think that the numeric hierarchy as it stands is rubbish :/
04:59:09 <merijn> Which do you guys prefer 1) IO exception, 2) "IO (Either Error a)", or 3) "ExceptT Error IO a"?
05:00:28 <jophish> merijn: 2 or 3
05:00:48 <Fylwind> there's an extension that desugars (:: Foo) into (id :: Foo -> Foo) … what is it called again?
05:01:08 <merijn> Fylwind: Is that implemented yet?
05:01:18 <merijn> Fylwind: I saw Lennart propose it, but don't think it exists yet?
05:01:20 <jophish> merijn: how about MonadIO m, MonadError Error m => m a
05:01:29 <Fylwind> merijn: that's what I thought
05:01:47 <jophish> Fylwind: section type annotations or something
05:02:17 <quicksilver> merijn: MonadThrow m, MonadIO m
05:02:26 <quicksilver> merijn: (I dunno; I have the same question really)
05:02:53 <Fylwind> jophish: can't seem to find it on google
05:03:02 <merijn> quicksilver: Then you don't know which errors you should handle
05:03:32 <quicksilver> merijn: yup.
05:03:41 <quicksilver> merijn: I know lots of bad designs but I haven't found one I'm happy on
05:03:55 <quicksilver> some languages which explicitly let you specify sets of throwable exceptions ... don't work great in practice.
05:04:30 <Fylwind> extensible variants! :P (I don't actually know if it'd work in practice, but it's a fun concept)
05:05:25 <jophish> Fylwind: it was an extension augustss was supposed to deliver last year
05:05:56 <jophish> Fylwind: https://ghc.haskell.org/trac/ghc/wiki/SignatureSections
05:06:05 <Fylwind> jophish: ah, thanks for the link!
05:06:28 <jophish> Fylwind: no problem
05:06:54 <ocramz> merijn: are you wrapping a FFI library?
05:07:07 <merijn> ocramz: yeah
05:07:46 <ocramz> so far, I've used IO exceptions for that
05:08:13 <ocramz> but only because I'm not sure about possible recovery paths
05:08:26 <quicksilver> recovery from IO is fine
05:08:52 <quicksilver> the downside is not specifying clearly which error types the function can throw
05:09:21 <Fylwind> jophish: though, they do have explicit type application now … so you could technically write it as id@Foo as well
05:09:39 <Fylwind> (by now I mean HEAD)
05:11:30 <pavonia> In that SignatureSections extension, why does "(:: Bool)" translate to "(Proxy :: Proxy Bool)"?
05:12:23 <jophish> pavonia: looks like an error to me
05:15:10 <ocramz> quicksilver: agree; do you advise formulating separate exception types for memory issues, bad inputs or outputs, etc.?
05:15:39 <quicksilver> I think it depends what you're trying to do.
05:16:17 <ocramz> it always does
05:16:21 <quicksilver> Some libraries by their very nature are almost total and only raelly have one error case 
05:16:31 <quicksilver> like parsing libraries - the only error case is a parse error
05:16:44 <quicksilver> so a simple Either MyErrorType is perfect
05:16:58 <Fylwind> and other libraries can fail in a potentially infinite number of ways :\
05:17:02 <quicksilver> yup
05:17:22 <Fylwind> e.g. anything that involves the filesystem
05:17:54 <Fylwind> POSIX API is actually somewhat decent because they state what the potential errno's are
05:18:11 <Fylwind> Windows API is just awful: none of the functions say in what way they can fail
05:18:41 <pavonia> jophish: I've just read the linked blog entry and it's actually correct, (:: Bool) =  (Bool -> Bool) which unifies with "proxy a"
05:18:42 <ocramz> then, in the latter scenario, having IO exceptions makes sense
05:23:14 <pavonia> > typeRep (undefined :: Proxy Int)
05:23:15 <lambdabot>  Int
05:23:22 <pavonia> > typeRep (undefined :: Int -> Int)
05:23:23 <lambdabot>  Int
05:23:30 <merijn> bah
05:23:38 <merijn> I can only throw IOExceptions using MonadError?
05:23:46 <Fylwind> I don't think so
05:24:09 <jophish> pavonia: oh, neat
05:24:27 <quicksilver> :t throwIO
05:24:28 <lambdabot> Exception e => e -> IO a
05:24:36 <Fylwind> though … I guess if you need the IO monad then your hands are tied
05:24:41 <merijn> quicksilver: I'm not using throwIO
05:24:46 <quicksilver> if you're going to use exceptions you might as well use extensible exceptions
05:25:09 <merijn> quicksilver: I'm not using exceptions, I'm trying to use MonadError...
05:25:42 <Fylwind> I don't think throwError is really useful for exceptions in the IO monad; it's mainly used with Either/Maybe and their transformer variants I think
05:25:57 <merijn> That's whay I want...
05:26:05 <merijn> Hence my annoyance of it not letting me
05:26:42 <quicksilver> so what did you mean by " I can only throw IOExceptions using MonadError?"
05:26:46 * quicksilver doesn't understand the question
05:26:48 <obadz> the first argument to MonadError is the exception type
05:26:51 <Fylwind> > instance MonadError IOException IO
05:26:52 <lambdabot>  <hint>:1:1: parse error on input ‘instance’
05:27:02 <Fylwind> That was not meant for lambdabot, oops
05:27:03 <merijn> quicksilver: http://lpaste.net/144720
05:27:08 <quicksilver> MonadThrow is an extensible-exceptions version of MonadError
05:27:21 <merijn> I don't want extensible-exceptions...
05:27:35 <obadz> merijn: what's your monad stack like?
05:28:17 <Ongy> Hi, I have the type signature "getReboot :: IO a -> IO (Widget b, Widget FocusGroup)", but ghc complains that it cannot match 'b' with <some long type>
05:28:19 <merijn> obadz: I don't have a monad stack, I just have "(MonadError SlurmError m, MonadIO m) => IO CInt -> m ()"
05:28:19 <quicksilver> merijn: that paste doesn't help me much. What is slurmError?
05:28:20 <obadz> apparently your monad implements MonadError IOException so it expects that type of exceptions?
05:28:27 <obadz> oh
05:28:31 <Ongy> I thought with my type signature there should be no restrictions on the type of b
05:28:46 <merijn> quicksilver: "slurmError :: (MonadError SlurmError m, MonadIO m) => CInt -> m a"
05:29:00 <quicksilver> it looks like you are running that code in IO
05:29:07 <quicksilver> not in your custom monad
05:29:11 <obadz> I guess MonadIO implies MonadError IOExceptions?
05:29:15 <merijn> quicksilver: I'm not running it anywhere
05:29:22 <merijn> obadz: That was my question
05:29:32 <obadz> That's beyond my knowledge
05:29:45 <merijn> Which, if so, is incredibly fucking annoying
05:29:59 <merijn> Because then why would I even bother using MonadError
05:30:16 <quicksilver> constraint ‘MonadError SlurmError IO’
05:30:23 <merijn> quicksilver: I'm not running the code and I don't have a custom monad, the code is completely polymorphic
05:30:26 <quicksilver> that error says it has typechecked that do block as IO
05:30:34 <quicksilver> otherwise 'IO' wouldn't arise there
05:30:37 <merijn> quicksilver: That's getting inferred from MonadIO
05:30:39 <quicksilver> no
05:30:44 <quicksilver> MonadIO does not 'infer IO'
05:31:22 <obadz> merijn: did you forget a lift in there maybe?
05:31:31 <quicksilver> I repeat - the tyep checker is saying that it has inferred IO for that do block
05:31:36 <obadz> merijn: leading it to infer that m = IO
05:32:19 <obadz> :t getErrno
05:32:20 <lyxia> Ongy: That looks odd, can you share your code?
05:32:21 <lambdabot> Not in scope: ‘getErrno’
05:32:27 <obadz> getErrno :: IO Errno
05:32:38 <obadz> hence your do block is in IO as quicksilver says
05:33:08 <merijn> obadz: Ah!
05:33:10 <obadz> merijn: replace by liftIO . getErrno
05:33:22 <lpaste_> ongy pasted “No title” at http://lpaste.net/144721
05:33:27 <merijn> Ah, there we go
05:33:56 <Ongy> lyxia: This requires vty-ui, so might not really be a "minimal" example
05:36:12 <lyxia> Ongy: How can b be anything, surely it is constrained to some type somewhere.
05:36:37 <lyxia> Ongy: centered :: Show a => Widget a -> IO (Widget (VCentered (HCentered a))) 
05:37:09 <quicksilver> I think Ongy wants to say "I don't care what this is, let's call it b"
05:37:19 <lyxia> Ah
05:37:21 <quicksilver> which is not what 'b' means to haskell - rather it means "make it work for ALL b"
05:37:33 <Ongy> quicksilver: which is what I want
05:37:42 <lyxia> which?
05:38:15 <Ongy> I don't care which widget type comes out of it, I want the type system to infere that itself
05:38:46 <quicksilver> then leave the signature off :)
05:38:51 <Ongy> since (if I saw it right) the type contains the layout and I would have to change the type signature eacht time I change something in the layout
05:38:53 <lyxia> Or use typeholes I guess
05:39:18 <lyxia> uh, partial types ?
05:39:36 <lyxia> https://ghc.haskell.org/trac/ghc/wiki/PartialTypeSignatures
05:40:28 <lyxia> IO a -> IO (Widget _, Widget _)
05:41:52 <Ongy> ah, -Wall warns on that, but it works like I want it to, thx
05:41:59 <camm1> Hello everyone. I was reading about Haskell Performance but I don't understand the UNPACK pragma. Could someone explain me that, please?
05:42:39 <quicksilver> what do you want to know?
05:43:02 <quicksilver> a very simple explanation might be that instead of storing a pointer you store the actual value
05:43:07 <quicksilver> which saves a little space and time.
05:44:42 * hackagebot latex-formulae-pandoc 0.2.0.0 - Render LaTeX formulae in pandoc documents to images with an actual LaTeX installation  https://hackage.haskell.org/package/latex-formulae-pandoc-0.2.0.0 (LiamOConnorDavis)
05:46:28 <camm1> quicksilver: Why saving the actual value is better than saving a pointer?
05:49:23 <quicksilver> camm1: it saves space and time
05:49:24 <Fylwind> camm1: it means there's one less indirection: you don't have to do one extra step to read its value
05:50:07 <Fylwind> it also reduces the space requirement since now you no longer have to store an extra pointer in memory
05:50:47 <camm1> Ohhh, I get it. Thanks guys, you're awesome.
05:52:01 <Heather_> strange on linux I can't Data.Yaml.decode just right after Data.Yaml.encode - saying yaml is broken :(
05:59:42 * hackagebot latex-formulae-pandoc 0.2.0.1 - Render LaTeX formulae in pandoc documents to images with an actual LaTeX installation  https://hackage.haskell.org/package/latex-formulae-pandoc-0.2.0.1 (LiamOConnorDavis)
06:03:28 <unit73e> Hey. Does haskell support GTK3 or only GTK2?
06:03:50 <ely-se> Yes.
06:04:40 <quicksilver> thre is a gtk3 binding
06:04:45 <quicksilver> I haven't used it.
06:05:13 <unit73e> yeah I did the obvious and searched 'gtk3 haskell'. These obvious things is what I forget to do.
06:05:39 <unit73e> thx
06:05:52 <quicksilver> the gtk2 binding is quite mature and people have bene using it for many years
06:06:06 <quicksilver> I've not heard any specific reports (good or bad) about 3
06:06:12 <quicksilver> (but it is substantially the same code)
06:06:43 <unit73e> indeed, btw what how does gtk2 render its components? opengl? I'm not into the graphical part of linux.
06:08:01 <quicksilver> traditionally it just used a simple software renderer and basic accelerated X
06:08:14 <quicksilver> I think there is some opengl support now but I am not current.
06:08:59 <unit73e> ok thanks.
06:09:43 <quicksilver> ah yes since 3.0 gtk uses cairo for everything, and cairo supports opengl (and quartz and x11 and other things)
06:09:43 * hackagebot yesod-raml 0.2.0 - RAML style route definitions for Yesod  https://hackage.haskell.org/package/yesod-raml-0.2.0 (junjihashimoto)
06:09:45 * hackagebot yesod-raml-docs 0.1.0 - A html documentation generator library for RAML.  https://hackage.haskell.org/package/yesod-raml-docs-0.1.0 (junjihashimoto)
06:09:47 * hackagebot yesod-raml-mock 0.1.0 - A mock-handler generator library from RAML.  https://hackage.haskell.org/package/yesod-raml-mock-0.1.0 (junjihashimoto)
06:09:49 * hackagebot yesod-raml-bin 0.1.0 - The raml helper executable.  https://hackage.haskell.org/package/yesod-raml-bin-0.1.0 (junjihashimoto)
06:12:20 <merijn> ok, I'm a bit confused about the correct syntax of pattern synonyms...
06:12:53 <merijn> I'm trying to define a synonym for a specific value of type CInt but I can't seem to get it to work?
06:22:41 <liste> merijn show us (:
06:24:37 <haskell244> hello,can someone help me with some problems?
06:25:14 <liste> haskell244 go ahead
06:25:26 <haskell244> http://lpaste.net/144722
06:25:28 <potatoe> usually don't ask to ask on irc :)
06:26:13 <danza> homework :(
06:26:23 <ely-se> step 1: perform alpha renaming
06:26:25 <ely-se> step 2: trivial
06:26:32 <liste> haskell244 let c=5+c
06:27:20 <liste> that's 5+5+5+5+5+5+5+... ad infinitum
06:27:30 <liste> > let c=5+c in c
06:27:34 <lambdabot>  mueval-core: Time limit exceeded
06:27:58 <haskell244> there is only 1 definition?
06:28:25 <lyxia> it might terminate with a Peano encoded nat :D
06:28:53 <liste> rename the inner c to c'
06:28:57 <ely-se> it might throw <<loop>>
06:28:59 <quicksilver> lyxia: it wouldn't terminate, but it might be possible to do some computation with it
06:29:09 <quicksilver> like you might be able to prove it was larger than 8
06:29:50 <lyxia> hmm would "be productive" be a better term then?
06:29:53 <quicksilver> yes
06:30:16 <ely-se> > let f = \x -> x in (f 1, f "1")
06:30:18 <lambdabot>  (1,"1")
06:30:38 <ely-se> > (\f -> (f 1, f "1")) (\x -> x)
06:30:41 <lambdabot>      No instance for (Num [Char]) arising from the literal ‘1’
06:30:42 <lambdabot>      In the first argument of ‘f’, namely ‘1’
06:30:42 <lambdabot>      In the expression: f 1
06:30:52 <ely-se> why does it not turn this into a let expression before type checking?
06:31:08 <ely-se> it would allow more correct programs to have their types inferenced
06:32:15 <quicksilver> you can't pass arguments polymorphically in (standard) haskell
06:32:31 <ely-se> that I just observe
06:32:31 <ely-se> d
06:32:35 <quicksilver> this is a limitation of hindley-milner type inference
06:32:56 <quicksilver> just changing it into a let expression doesn't solve that on its own
06:33:05 <quicksilver> you have to change it into a let expression *and* do the substitution
06:33:14 <ely-se> I think one could add a rule that immediately-applied lambdas are transformed into let expressions before type checking.
06:33:16 <quicksilver> at which point you're letting the two cipes of the term be inferred differently
06:33:25 <quicksilver> you don't need to add any rules
06:33:36 <quicksilver> you can just permit it
06:33:41 <quicksilver> but, you will lose the ability to infer types :)
06:33:51 <quicksilver> and that is considered to be a desirable property.
06:34:04 <jophish> How would people check that an example *doesn't* compile
06:34:08 <ely-se> I don't see how. This applies to immediately-applied lambdas only. Not to lambdas that are not the callee of an applicatino expression.
06:34:21 <quicksilver> sure
06:34:27 <quicksilver> you could rewrite immediately applied lambdas
06:34:29 <quicksilver> and that would work fine
06:34:33 <ely-se> ok :)
06:34:37 <quicksilver> but you'd then have made the language inconsistent
06:34:45 <jophish> I can think of turning on deferred type errors and catching the error message
06:34:50 <quicksilver> in the sense that the term would type check differently here (because of the rewriting)
06:34:57 <ely-se> right
06:34:59 <quicksilver> to in a more general context (when it is no longer immediatley applied)
06:36:21 <merijn> liste: Show you what?
06:36:42 <liste> merijn the pattern synonym that didn't work
06:36:53 <merijn> liste: I have a value "foo" of type CInt and I want to make a pattern synonym that matches if the value is equal to "foo"
06:37:56 <ely-se> is "callee" the correct word, by the way, to refer to f in "f x"? maybe "applicatee"?
06:37:59 <merijn> It's literally just "pattern Foo = foo", but that's not allowed
06:38:45 <merijn> The only thing I can think of is "pattern Foo <- ((foo==) -> True)" using ViewPatterns
06:38:52 <merijn> But that seems stupid
06:39:16 <quicksilver> merijn: what happens if you "pattern Foo = foo" ?
06:39:38 <merijn> "Right-hand side of bidirectional pattern synonym cannot be used as an expression"
06:39:48 <quicksilver> oh is foo not a literal?
06:40:05 <quicksilver> patterns have to be constructors (or, for numbers, literals)
06:40:10 <liste> merijn how about "pattern Foo = CInt 42" and "foo = Foo" ?
06:40:21 <quicksilver> if you couldn't write case Bar of foo -> ...
06:40:24 <quicksilver> then foo isn't a pattern
06:40:32 <quicksilver> and therefore you can't define it as a pattern
06:40:36 <merijn> liste: I don't know the value
06:40:42 <merijn> liste: It's a Foreign import
06:40:52 <quicksilver> PatternSynonyms are just macros for patterns
06:41:02 <quicksilver> they don't expand the pattern syntax to allow ==-matching
06:41:06 <merijn> quicksilver: Which is silly, because patterns can already do that
06:41:23 <quicksilver> I don't see why it's silly?
06:41:24 <merijn> quicksilver: Because integers already match using ==
06:41:28 <quicksilver> it's just not what the extension does
06:41:32 <merijn> And so do overloadedlists and overloadedstrings
06:41:38 <quicksilver> it allows you to shorten patterns and nothing else
06:41:43 <quicksilver> it doesn't change what a 'pattern' is
06:42:01 <merijn> quicksilver: It doesn't have to, because we can already pattern match using == in normal haskell...
06:42:17 <quicksilver> only via literals for special cases
06:42:19 <quicksilver> not in general
06:43:05 <quicksilver> I can see why you might want general EqPatterns although there are some issues with them
06:43:17 <quicksilver> but that is not what PatternSynonyms give you, that's all.
06:49:14 <lpaste_> lmj pasted “Twisted.hs” at http://lpaste.net/144726
06:51:18 <lmj> I supposed I am resigned to writing out every instance by hand, but was wondering if there was an extension that could help (http://lpaste.net/144726)
06:52:10 <lmj> In real code I am forwarding every Num operator; so much cut & paste gives me an ugly feeling.
06:53:09 <lmj> And this misses other Num instances that are defined elsewhere.
06:53:10 <mnoonan> what about "instance Num a => Twisted a where twistedMultiply = (*)"?
06:53:45 <hiptobecubic> mnoonan, but then you can't have Twisted's which aren't Nums
06:54:20 <hiptobecubic> or
06:54:25 <hiptobecubic> Wait that's not right :D
06:55:09 <vlatkoB> Shouldn't pattern matching with OverloadedLists work like this?
06:55:09 <vlatkoB>     f :: Text -> [Int]
06:55:09 <vlatkoB>     f (toList -> ('9':_)) = [2,2,2,4]
06:55:09 <vlatkoB>     f ('1':_) = [1,2,2,4]
06:55:09 <vlatkoB> The last one throws "Couldn't match expected type ‘Text’ with actual type ‘[Char]’"
06:55:27 <hiptobecubic> mnoonan, nevermind I was thinking of the constraint on the data side. Your example should work I would think.
06:55:43 <stelleg> does ghc float all the foralls it can up to the top level?
06:56:15 <mnoonan> actually, that reminds me that I have no idea how exactly constraints on instance declarations work.. what if you had "instance Monoid a => Twisted a where twistedMultiply = (<>)" too?
06:56:33 <dino-> I suspect I already know the answer to this, but asking anyway. Is there a way for me to add things (like shell scripts) that `cabal install` will put into the install location's bin directory?
06:56:43 <dino-> Without hacking some Setup.hs
06:57:31 <ely-se> I was thinking about this way of combining phantom types and GADTs to simplify code generation from an AST in a type safe manner.
06:57:36 <ely-se> https://gist.github.com/rightfold/85e2890c4d9078868c43
06:57:42 <ely-se> I'm not sure it'll work. I should try it.
06:57:56 <hiptobecubic> vlatkoB, 'Text' is not a list of 'Char'. Does it have an appropriate instance to provide toList?
06:58:26 <potatoe> hi, beginner here but #haskell-beginners is kinda dead at this time so
06:58:27 <potatoe> http://lpaste.net/8654552301953875968
06:58:48 <potatoe> I'm trying to parse a config file into a type but my do block seems to be wrong
06:58:52 <potatoe> can someone take a look please?
06:59:00 <vlatkoB> hiptobecubic: wiki says that with OverloadedLists "g [x,y,z] =" is treated as "g (toList -> [x,y,z]) ="
06:59:18 <vlatkoB> so the first 'f' is the same as the second
06:59:19 <lmj> thanks, I had once tried FlexibleInstances but ran into problems that I can't remember. This also requires UndecidableInstances.
07:00:21 <dino-> potatoe: I'm wondering if the do needs to go on the line above like: runExceptT $ do
07:00:27 <dino-> Or at least be indented more if it's on the next line
07:00:31 <lmj> So I have to weigh these extensions against cut & paste. Are there any downsides to FlexibleInstances, UndecidableInstances? It sounds a bit scary.
07:00:43 <potatoe> dino- I'll take a shot at that
07:00:47 <hiptobecubic> vlatkoB, ok, but that doesn't fix the problem of there not being a toList function on Text. Is there one?
07:00:50 <dino-> I often stick the `$ do`s at the end of lines like this
07:01:03 <lmj> I can imagine purists who look down upon such things
07:01:25 <quicksilver> lmj: those two are fine
07:01:36 <quicksilver> lmj: it's Overlapping and Incoherent you should avoid
07:02:03 <potatoe> dino- I tried that and then I indented the following lines more
07:02:04 <potatoe> no real use
07:02:10 <quicksilver> Flexible is not controversial at all. Undecidable jsut says "the compiler can't tell if instance resolution will terminate - but if it does, it is typesafe"
07:02:27 <merijn> lmj: UndecidableInstances means that typechecking becomes undecidable (i.e. might not terminate)
07:02:47 <merijn> lmj: So IF ghc finishes compiling everything will be fine, but you might hang GHC at compile time
07:02:48 <potatoe> dino- the block with the cp <- says that cp isn't in scope as well
07:03:16 <vlatkoB> hiptobecubic: the first 'f' is using toList of Text, and compiles with no problem, if second 'f' is commented out
07:03:27 <merijn> potatoe: line 14 is indented 1 space too much
07:03:31 <dino-> potatoe: I think the cp <- and ConfigFile lines need to be indented the same amount.
07:03:32 <hiptobecubic> vlatkoB, ah. In that case I don't know
07:03:38 <merijn> potatoe: So it's parsing it as a line continuation of line 13
07:05:19 <lmj> There is something to be said for portable extension-free code, though GHC seems like a de facto standard nowadays.
07:05:24 <potatoe> merijn dino- thanks, I was following the usual vim indentation guides
07:05:33 <potatoe> I need to read up more on indentation in haskell
07:05:43 <potatoe> 1 space too much is kinda hard to catch since I don't know what I'm doing
07:05:45 <lpaste_> dino- annotated “No title” with “do block parsing” at http://lpaste.net/8654552301953875968#a144727
07:05:47 <potatoe> (as of of now)
07:06:12 <potatoe> dino- yeah I like your formatting more
07:07:06 <ocramz> is there a one-liner for converting between say a `VS.Vector a` and a `V.Vector a`, where VS is Vector.Storable ?
07:07:40 <ocramz> and `a` is Storable too
07:08:37 <quicksilver> stream.unstream was it, ocramz ?
07:08:47 <frerich> I thought there was a 'convert' for that.
07:08:51 <hiptobecubic> vlatkoB, Yeah I don't get it. It certainly doesn't work in ghci, at least. You have to use the view pattern or it monomorphises to [Char].
07:09:14 <ocramz> frerich: in Vector.Generic, yes
07:09:55 <ocramz> so the idea is that since both VS and V are instances of Vector.Generic, I can convert between the two
07:10:12 <quicksilver> no
07:10:14 <lyxia> It's exported in Vector and Vector.Storable
07:10:18 <quicksilver> they're both instances Vector
07:10:48 <quicksilver> convert = unstream . Bundle.reVector . stream -- I was close :)
07:11:02 <vlatkoB> hiptobecubic: I tried with NoMonomorphismRestriction, but still error
07:11:26 <hiptobecubic> vlatkoB, me too. I don't know how it works :(
07:19:34 <lmj> I was afraid that instance Num a => ... would prohibit other more specific instance Num a => ... cases, but it seems OK. I wonder if this might somehow bite me though.
07:20:22 <lmj> Naturally instance Integral a => ... is prohibited
07:20:31 <quicksilver> lmj: instance Num a => Foo a overlaps with all other instances for the class Foo, yes
07:20:51 <quicksilver> lmj: instance Num a => Foo (Bar a) doesn't, it only matches types of the form Bar a
07:23:36 <lyxia> vlatkoB: it just changes how the [ ... ] notation is desugared. ( _ : _ ) is still a pattern for lists.
07:26:28 <stelleg> so this simple rankntypes seems like it should work: http://lpaste.net/144728
07:26:59 <lmj> This rigmarole ultimately stems from Num defining too much. Coupling (*) with abs is such a shame, because non-abs mathematical structures either have to invent their own operators or break the contract with Num with a runtime error, "Hey you used abs. Don't do that!"
07:27:10 <stelleg> even adding a type signature to fails doesn't work though
07:27:14 <quicksilver> lmj: there are lots of such shames, yes.
07:27:15 <lmj> I saw one package that did just that
07:27:27 <quicksilver> lmj: runtime errors are a pragmatic solution for many uses cases
07:27:44 <lmj> it's such a non-Haskell thing to do, though
07:28:54 <quicksilver> it turns out that a correct and fine-grained numeric hierarchy which is still comptuationally efficient is tricky :)
07:29:46 * hackagebot hasql-postgres-options 0.1.5 - An "optparse-applicative" parser for "hasql-postgres"  https://hackage.haskell.org/package/hasql-postgres-options-0.1.5 (NikitaVolkov)
07:30:20 <lmj> For integers we might get away with the taxicab metric for abs, but then there's signum which destroys that hope.
07:32:22 <lyxia> :t (.)
07:32:23 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:32:40 <lyxia> stelleg: (b -> c) and (a -> b) can not unify with forall a. a -> a
07:32:43 <quicksilver> stelleg: inference for rankntypes is hard but I must admit I'm suprised by that
07:32:52 <quicksilver> it's not even the ., lxyia
07:32:53 <lmj> I read through a bit of the "burning bridges" emails but I haven't seen much followup about a Prelude 2.0 for incompatible but sorely needed fixes. Is this a pipe dream or could it eventually happen?
07:33:02 <quicksilver> fails x = id' id' x
07:33:05 <quicksilver> also doesn't work.
07:33:17 <merijn> lmj: Won't happen
07:33:27 <quicksilver> lmj: it could happen, but it will not, unless somebody is going to do the work
07:33:29 <merijn> lmj: There's a few alternative Preludes around and nothing stops you from using them
07:33:32 <quicksilver> and it's a *lot* of work
07:33:40 <merijn> lmj: Yet almost no one does
07:33:54 <lyxia> oh wait I'm getting confused with all these arrows
07:34:11 <stelleg> quicksilver: yeah same, coq has no problem with it even with implicits
07:34:23 <quicksilver> lyxia: that's not the inference they need to make
07:34:31 <stelleg> lyxia: yeah it should  be unifying a b and c with ID
07:34:46 <quicksilver> lyxia: it shouuld unify (b -> c) with ((forall a. a -> a)->(forall a. a -> a))
07:34:53 * hackagebot record-aeson 0.1.1 - Instances of "aeson" classes for the "record" types  https://hackage.haskell.org/package/record-aeson-0.1.1 (NikitaVolkov)
07:34:59 <quicksilver> which is not too controversial
07:36:31 <lyxia> Right
07:36:41 <c_wraith> Not controversial, but instantiating type variables with polymorphic types is not something hindley-milner is designed to handle. 
07:36:57 <vlatkoB> lyxia: thanks, that's it...
07:36:58 <quicksilver> c_wraith: but with RankNTypes it can do it sometimes
07:37:07 <quicksilver> c_wraith: given sufficient type annotations...
07:37:40 <c_wraith> It can so the unification, but only if it's told what the result will be. :) 
07:37:54 <c_wraith> *do
07:38:48 <stelleg> c_wraith: yeah I was just surprised because I thought GHC's unification could generally infer more than say Coq's
07:39:19 <quicksilver> c_wraith: http://lpaste.net/144729
07:39:24 <quicksilver> I did tell it the result!
07:39:27 <quicksilver> unless I got it wrong
07:39:35 <stelleg> yeah I tried that as well
07:39:37 <stelleg> still no go
07:40:14 <quicksilver> error in annotation now
07:41:05 <stelleg> oh I think you want id' $ id' x
07:41:27 <c_wraith> Oh, right. For that to unify, the first use of id' needs to have a type signature telling it that it takes a polymorphic value. 
07:42:12 <c_wraith> Because GHC doesn't ever infer instantiation of a type variable with a polymorphic type. 
07:42:13 <quicksilver> oh, silly
07:42:17 <quicksilver> silly me, that is
07:42:31 <quicksilver> I understand now
07:42:37 <quicksilver> stelleg: id' (id' x) works
07:42:55 <stelleg>  
07:43:00 <quicksilver> stelleg: you can't use (.) or ($) because that would amount to a polymorphic instantiation of (.) or ($)
07:43:07 <quicksilver> although GHC has a hack to make $ work in some cases
07:43:25 <quicksilver> actually you can use $, so this is clearly one of those cases :)
07:43:25 <stelleg> I did not know that, thanks
07:43:34 <quicksilver> it's a special case hack to make runST work
07:43:57 <c_wraith> Well, runST $ do... 
07:44:12 <quicksilver> because people are allergic to parens (I've never understood why (parens are great (don't you all agree?)))
07:44:50 <Hafydd> ((((((((((((I agree.))))))))))))
07:44:55 <frerich> Everyone needs paren(t)s.
07:46:16 <stelleg> so seems like actual use of higher ranked types is pretty limited if type variables can't be bound to them
07:46:58 <c_wraith> They can. They just can't be inferred. :) 
07:47:22 <c_wraith> It honestly isn't an impediment to lots of uses. 
07:47:38 <quicksilver> stelleg: the lens library uses higher rank types thoroughly and in general without it being too annoying
07:48:05 <xivix_> Hey, I've got a question about performance. I'm writing a sortedNub function, as an O(n) nub that works only on sorted lists
07:48:15 <quicksilver> although the design has some specific characteristics, such as often when you use them, you are using them instantiated.
07:48:36 <c_wraith> quicksilver: well.. That's debatable, depending on how you feel about types like ALens which exist specifically to avoid RankNTypes
07:48:42 <Hafydd> xivix_: are you aware that nub is already O(n)?
07:48:43 <xivix_> is "sortedNub = map head . group" any slower than "sortedNub [] = []; sortedNub (x:xs) = x:(sortedNub . dropWhile (== x) $ xs)" ?
07:48:48 <jle`> i usually don't have too many problems with rankn types and the type system.  in the rare cases that they cause trouble, i just add a type signature...which i often do anyways
07:48:54 <xivix_> Hafydd: it says O(n^2) in the docs
07:48:59 <quicksilver> c_wraith: which part is debatable?
07:49:08 <quicksilver> c_wraith: the threshold for 'too' in 'too annoying'?
07:49:32 <jle`> *often already have type signatures
07:49:46 <c_wraith> quicksilver: that it actually uses RankNTypes
07:50:10 <Hafydd> xivix_: oh... for some reason, I thought it only deleted consecutive equal elements. My mistka.e
07:50:30 <Hafydd> (I've written a whole lot of code that uses nub . sort, too... how embarrassing.)
07:50:59 <c_wraith> quicksilver: it uses all sorts of crazy hacks to *avoid* RankNTypes whenever it can. 
07:51:23 <quicksilver> c_wraith: right. Well what is not debatable is that it uses a polymorphic type synonym.
07:51:31 <xivix_> Hafydd, haha, you probably didn't need to run it on too many elements so it's probably fine
07:51:33 <c_wraith> :t cloneLens
07:51:35 <lambdabot> Functor f => ALens s t a b -> (a -> f b) -> s -> f t
07:51:38 <lyxia> xivix_: There is probably no difference.
07:52:13 <quicksilver> c_wraith: and it certainly represents an interesting exploration of the design space of how to avoid actually requiring polymorphism at inference time.
07:52:31 <quicksilver> the ALens trick is particularly ingenious
07:52:47 <shachaf> Using a rank-2 type instantiated is also called a rank-1 type. :-)
07:53:07 <shachaf> quicksilver: It's ingenious for (x -> f y) lenses. It's obvious for profunctor lenses.
07:53:34 <quicksilver> if you say so :)
07:53:42 <quicksilver> ingenious is subjective :)
07:53:49 <xivix_> lyxia, i thought that might be the case in Haskell. it's hard to reason about the cost that the intermediate arrays that "group" produces incur. Since, because of laziness, they may never even be completely allocated
07:53:54 <xivix_> i think
07:54:12 <shachaf> quicksilver: On the other hand, for a symmetric Iso, it's completely impossible.
07:54:32 <quicksilver> c_wraith: but ALens itself is a rank-2 construct, no?
07:54:53 <quicksilver> it just happens to be the kind that GHC can live with, because the polymorphism is guarded behind a constructor
07:55:03 <quicksilver> which is very convenient.
07:55:26 <shachaf> Well, it doesn't have to be.
07:55:50 <shachaf> Calling a polymorphic type hidden inside a newtype higher-rank seems a bit misleading.
07:56:22 <quicksilver> does it? for example, it's not legal haskell98 is it?
07:56:35 <shachaf> It's not.
07:56:36 <quicksilver> and it's not something you'd find in vanilla H-M inference?
07:56:43 <quicksilver> so what would you call it?
07:56:47 <shachaf> Of course.
07:57:08 <shachaf> But it has none of the usual problems of rank-n types.
07:57:17 <shachaf> And it's used all over the place.
07:57:25 <xivix_> what do you all use Haskell for
07:57:47 <shachaf> Anyway ALens = (a -> Context a b b) -> s -> Context a b t
07:57:55 <shachaf> Where Context a b t = (a, b -> t)
07:57:56 <quicksilver> being (1) popular and (2) unproblematic don't seem to be the right criteria for deciding if something is higher rank
07:58:27 <shachaf> Maybe I misunerstood the beginning of the conversation, which I only skimmed.
07:59:06 <quicksilver> shachaf: the context was "hmm RankNTypes don't seem very useful in practice in haskell then" "Well the lens library makes pretty good use of them" "But is the lens lirbary really higher-rank"
07:59:54 * hackagebot airship 0.4.0.0 - A Webmachine-inspired HTTP library  https://hackage.haskell.org/package/airship-0.4.0.0 (reiddraper)
08:00:47 <shachaf> OK.
08:01:08 <lyxia> xivix_: intermediate structures may even be erased entirely by optimizations.
08:02:01 <quicksilver> lyxia: and, since modern machines have such a dramatic mismatch between cache speed and main memory speed, intermediate structures which only ever exist in cache and get GCed in cache may have a much lower cost than you'd imagine.
08:03:38 <xivix_> lyxia, that's pretty nuts actually.
08:03:43 <suppi> I'm interested in going over the docs for this package: https://hackage.haskell.org/package/timeless-0.9.0.1
08:03:49 <suppi> but it seems unavailable
08:03:57 <suppi> how can I read the docs?
08:04:06 <suppi> can I build them on my comp?
08:04:58 <xivix_> suppi, is it possible that docs weren't written for that package?
08:05:03 <quicksilver> there are docs for the 0.8 version
08:05:12 <quicksilver> you can go to the github repo and just browse the source (which has the docs)
08:05:18 <quicksilver> or you can build them locally, indeed
08:07:39 <iurdan> @help
08:07:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:10:57 <suppi> quicksilver, xivix_, thanks. I will try using cabal get and cabal haddock to build the docs locally
08:11:35 <iurdan> @run take 2 [1,2,3]
08:12:16 <lambdabot>  [1,2]
08:13:03 <quicksilver> suppi: or you can set enable-document to true and use cabal install
08:13:10 <quicksilver> enable-documentation
08:13:15 <iurdan> @pl f x = x == x/1
08:13:15 <lambdabot> f = ap (==) (/ 1)
08:13:32 <suppi> quicksilver, thanks, i will try that :)
08:14:34 <quicksilver> suppi: http://dev.stephendiehl.com/hask/#cabal
08:14:53 <quicksilver> at the bottom of that subsection he tells you how to set up your .cabal/config
08:16:15 <suppi> quicksilver, thanks. I will probably still use this reference in 10 years. so much information @_@
08:18:52 <quicksilver> yes it does seem to be very good
08:19:02 <quicksilver> I haven't read the whole thing yet :)
08:23:18 <obadz> Anyone else finds themselves dreaming about Applicatives and Monads?
08:23:31 <obadz> Worsens quality of sleep..
08:25:00 <danza> obadz, it happened to me to dream about code, even before learning Haskell ... and yes, it is not great. Our brain sorts out things during sleep
08:27:11 <danza> this is why i often tried to introduce a nap break in the companies where i worked ... it might lead to enlightenment! :D
08:27:29 <ryan_vw> Do MacBook Pros dream of Applicatives and Monads?
08:27:44 <quicksilver> obadz: https://xkcd.com/224/
08:28:25 <obadz> quicksilver: lol :)
08:29:40 * prsteele realizes he's still connected
08:29:44 <quchen> Is there a better way to fail a build in Shake than using (liftIO . throwIO . ErrorCall :: Action a)?
08:31:37 <prsteele> obadz: sleeping is how I solved most of my abstract algebra assignments
08:32:54 <Rembane> prsteele: So study really hard for a day, and then sleep and then write down the answer?
08:32:59 <jle`> quchen: there's throwIO from monad-base-control, possibly?
08:33:13 <prsteele> Rembane: read the problem, take a nap, write down the answer. repeat
08:33:21 <prsteele> Rembane: didn't always work, but often did
08:33:25 <jle`> er, monad-control
08:33:27 <quchen> jle`: I was more wondering about whether I'm missing something
08:33:44 <quchen> jle`: Explicitly failing a build is a pretty desirable feature, and it surprises me it's so hard to find in Shake
08:33:55 <jle`> good point
08:33:55 <nchambers> a website is telling me to do `cabal sandbox init`... is this equivalent to `cabal init`
08:34:04 <quchen> No
08:34:46 <Rembane> prsteele: Wow. That's a very nice method. I need to teach my brain how to do that.
08:35:07 <prsteele> Rembane: the interesting this is that I'm not the only person I've met that has done this, specifically for that class
08:35:22 <quicksilver> most haskell problems can be solved by 'post on haskell-cafe; have a nap'
08:35:36 <nchambers> quchen: what would be the equivalent then, because I don't have sandbox
08:35:54 <quchen> nchambers: If you have cabal, then you have cabal sandbox init.
08:36:11 <quchen> Unless your Cabal is really old.
08:36:19 <quchen> In that case, you should run `cabal install cabal-install`.
08:36:28 <prsteele> nchambers: from my understanding `cabal sandbox init` is a bit like using a virtualenv in Python, if you've done that
08:36:35 <jle`> there is pretty much nothing similar between cabal sandbox init and cabal init, actually
08:36:56 <jle`> they are not similar in any meaningful way, so...yeah, not equivalent :)
08:36:56 <nchambers> quchen: prsteele ah ok thanks
08:37:44 <jle`> they just happen to look slightly similar lexicographically, but the similarities end there
08:38:18 <suppi> how can I render LHS files?
08:39:16 <prsteele> suppi: like, make them into a PDF?
08:39:36 <suppi> prsteele, or html
08:39:53 <prsteele> suppi: http://www.andres-loeh.de/lhs2tex/ ?
08:40:11 <Rembane> prsteele: It works for me and programming. Stare at a problem for a while, go take a shower, and a solution pops up.
08:40:19 <suppi> prsteele, but then I need to use tex, right? :\
08:40:42 * hackagebot latex-formulae-hakyll 0.1.0.0 - Use actual LaTeX to render formulae inside Hakyll pages  https://hackage.haskell.org/package/latex-formulae-hakyll-0.1.0.0 (LiamOConnorDavis)
08:40:44 <prsteele> suppi: if you wrote in LaTeX notation, yes.
08:41:09 <suppi> prsteele, I didn't write it. I just want to view it
08:41:38 <prsteele> suppi: ah. Does it look like it was written in LaTeX, or a different markup syntax?
08:41:53 <suppi> prsteele, I don't know LaTeX :(
08:42:02 <suppi> prsteele, but, i think so?
08:42:08 <prsteele> suppi: It will have \textbf{commands} like \section{A section}
08:42:16 <suppi> prsteele, then yes.
08:42:43 <prsteele> suppi: then yes, you'll want something that convert LaTeX code to something else
08:43:09 <prsteele> suppi: pandoc might help if you aren't familiar with latex, but I've never used it
08:43:16 <c_wraith> Does pandoc do lhs to him? 
08:43:20 <suppi> prsteele, meh. I'll just read it like plain text. thanks for your help :\
08:43:25 <c_wraith> Err, html
08:43:39 <prsteele> c_wraith: with the lhs2tex headers, maybe, not sure
08:51:18 <nchambers> guys I did cabal install cabal-install but I still can't do cabal sandbox init
08:53:15 <danza> nchambers, maybe your environment it is not correctly set up, so the cabal executable you installed is not picked by your command line
08:53:28 <danza> this might depend a lot on your local set up, there are a lot of variables
08:53:32 <danza> try on a new shell
08:53:36 <nchambers> ok
08:54:27 <nchambers> tried it in dash, still nothing
08:55:13 <danza> nchambers, are you on a Mac? Linux? which version of Cabal?
08:56:08 <quicksilver> I would guess nchambers old cabal is in /usr/bin (or /usr/local/bin)
08:56:13 <quicksilver> and his new one is in his home directory
08:56:19 <quicksilver> and his PATH is preferring the older one therefore
08:56:26 <quicksilver> just a guess tho
08:56:29 <danza> good point, very likely
08:56:44 <nchambers> quicksilver: ooof you're right
08:57:02 <nchambers> I'll just edit my .bashrc to fix this. thanks!
09:09:13 <obadz> http://joelburget.com/data-newtype-instance-class/ => "newtype creates a strict value constructor and type creates a lazy one"
09:09:27 <obadz> Is that right?
09:09:34 <obadz> or does he mean data creates a lazy one?
09:10:00 <jle`> probably means `data`
09:10:04 <jle`> type doesn't make any constructors
09:10:32 <obadz> `type` doesn't change lazy/strict behavior the same way `newtype` doesn't either, does it?
09:11:02 <obadz> in fact, is there any reasons to ever use type rather than newtype (other than convention) ?
09:11:34 <jle`> type is just a lexical alias, more or less
09:11:36 <glguy> They're just different. 'type' is for naming a type, 'newtype' is for making a new type
09:12:36 <Hafydd> obadz: a reason to use type instead of newtype is when you require type equality with the original type.
09:12:40 <Hafydd> e.g. type Name = String
09:12:55 <obadz> Hafydd: yes fair enough
09:13:08 <obadz> and ("aaa" :: [Char]) == ("aaa" :: String)
09:13:19 <jle`> it's also useful as a more meaningful alias
09:13:26 <jle`> in case the long hand is not readable/useful
09:13:30 <jle`> like yeah, [Char] vs String
09:14:06 <jle`> it's useful because bothw ill be treated identically by the type checker
09:17:30 <obadz> it actually annoys me the String vs [Char] thing
09:17:40 <obadz> type inference never gets the one I want
09:17:48 <obadz> maybe String should be a new type
09:18:51 <Peaker> obadz: and it shouldn't be [Char]
09:20:09 <obadz> Peaker: actually that's an even better point
09:20:24 <obadz> linked list of single characters is not a great data structure..
09:20:29 <Welkin> ...
09:20:33 <Welkin> there is Text
09:20:41 <Welkin> String, Text, ByteString
09:20:45 <Welkin> they have different purposes
09:20:58 <obadz> Welkin: there is, but it's not the one we introduce beginners to
09:21:06 <obadz> Welkin: what's the purpose of String?
09:21:27 <opqdonut> it's simple and built from primitives
09:21:40 <opqdonut> having all the list functions work is nice, at least when you're learning the language
09:21:59 <Welkin> it is easy to work with, especially if you don't need Text
09:23:19 <obadz> I'm not questioning [Char]'s right to exist, it's type String = [Char] that's annoying
09:24:20 <obadz> either way it doesn't matter since that's a pretty fundamental change with little to no impact
09:29:24 <jle`> i think it's nice because it lets you state your intent
09:29:37 <ocramz> I'm having a small epiphany by interleaving monad transformers; e.g. with ResourceT and ReaderT one can first write out the skeleton of a program, and then work out the details
09:29:42 <jle`> instead of saying -- i'm using this [Char] as a String
09:29:46 <jle`> you can just say String -> ...
09:30:07 <ocramz> `shortestProgramEver :: MonadResource m => IO a -> (a -> IO ()) -> (t -> a -> m b) -> ReaderT t m b` 
09:33:29 <ocramz> this is so beautiful
10:07:48 <rmrfroot> does anyone have a practical example of category theory usefulness for a non-math person?
10:08:25 <Hafydd> Heh/
10:08:44 <Taneb> rmrfroot: I am not sure such a thing exists
10:09:06 <Taneb> Unless non-math person includes, say, programmers
10:09:17 <Taneb> Which I guess it does
10:09:36 <mnoonan> do you mean ((category theory usefulness) for a non-math person) or (category theory (usefulness for a non-math person))?
10:10:22 <Hafydd> The only reason I can think for a "non-math person" to be interested in CT is because they read about it in relation to Haskell.
10:10:27 <rmrfroot> Taneb: i'm a programmer, using mainly haskell for web dev. i have no background in math, at all. 
10:10:58 <Hafydd> So there's your practical example: it's useful for thinking about Haskell's type system.
10:11:20 <mnoonan> for the latter, assuming generic scientists do not count as "math people", there is https://mitpress.mit.edu/books/category-theory-sciences
10:11:36 <ski> Hafydd : how ?
10:11:38 <jle`> @google bartosz milewski category theory
10:11:41 <lambdabot> http://bartoszmilewski.com/category/category-theory/
10:11:41 <lambdabot> Title: Category Theory | Bartosz Milewski's Programming Cafe
10:11:47 <dolio> It's useful for coming up with types for your programs that might be better than the ones you originally thought of.
10:11:59 <jle`> er, he has a "category theory for programmers" series, rmrfroot 
10:12:58 <Hafydd> ski: by applying intuition and results about categories to Hask, presumably.
10:13:42 <Hafydd> It allows you to write down laws for, say, Monad, and have more confidence that they aren't bullshit.
10:13:49 <jle`> rmrfroot: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
10:14:01 <ski> (i was just wondering if you had anything in particular in mind relating to Haskell's type system, as opposed to thinking about types in general ..)
10:14:23 <rmrfroot> jle`: thanks, that looks really promising
10:14:24 <ski> Hafydd : but that's specifically borrowed from CT in the first place
10:14:37 <Hafydd> ski: yes. What'
10:14:40 <Hafydd> s your point?
10:15:13 <Hafydd> It'
10:15:16 <ski> how does thinking about a few special typeclasses like `Monad' help me to reason about Haskell's type system
10:15:44 <Denommus> hi
10:15:59 <Hafydd> ski: that is thinking about part of Haskell's type system, is it not?
10:16:38 <Hafydd> It would be difficult not to, given that the category in question has types as its objects.
10:16:44 <ski> Hafydd : i don't see it
10:17:00 <ski> i think it's thinking about applying Haskell's type system
10:17:55 <ski> if you were talking about conceiving of functions as morphisms, and functions of type `forall a. F a -> G a' as natural transformations, that would be another thing
10:18:21 <Hafydd> ski: my statement covers all of those.
10:18:57 <Hafydd> Why do you think that the first is excluded from "thinking about Haskell's type system"? The type system is necessarily involved.
10:19:38 <ski> iow, i'd want something that applies to large parts of the type system. not just to a particular encoding of a math (CT) concept in Haskell
10:19:42 <Denommus> guys
10:20:12 <rmrfroot> hey, Denommus
10:20:24 <Hafydd> ski: well, the more general examples are less accessible. I hoped that the audience would be more likely to understand from a simple example.
10:20:36 <Denommus> I'm trying to figure out how to parse tokens produced by alex in megaparsec
10:20:41 <ski> (or, i suppose, at least gave a general reasoning idea wrt to the type system)
10:21:28 <Hafydd> ski: please feel free to suggest a better concrete example.
10:21:32 <Denommus> I have a type LTok = (LToken, AlexPosn)
10:22:04 <Denommus> and my lexer produces a Either (String, AlexPosn) [LTok]
10:23:00 <Hafydd> Are you sure LTok is a good name for (LToken, AlexPosn)?
10:23:09 <Hafydd> It seems like LToken and LTok are indistinguishable.
10:23:15 <Denommus> Hafydd: I'm not, I'm using someone's else lexer
10:23:19 <Hafydd> I see.
10:23:22 <ski> you can learn about type classes (e.g. over types of kind not being `*') without entering into CT-related stuff. and i don't really see how CT helps with understanding the type class `Monad', as an encoding of the CT concept, apart from knowing what it means in CT
10:23:35 <Denommus> anyway, I'd like to parse this [LTok] with megaparsec, but the only function I've seen to parse tokens is token :: MonadParsec s m t => (Int -> SourcePos -> t -> SourcePos) -> (t -> Either [Message] a) -> m a
10:23:51 <Hafydd> ski: as I said, it lets you be more sure that the Monad laws are not bullshit. Do you disagree with that?
10:23:59 <dolio> I think it helps.
10:24:19 <ski> Hafydd : it's like if you said learning group theory, or linear algebra, was useful for thinking about Haskell's type system, only because it's possible to cast concepts from them as (e.g.) type classes `Group' and `VectorSpace'
10:24:20 <Denommus> the first function should calculate the position of the NEXT token, and the second function should match the token
10:24:26 <shersh> Hello everyonve! I'm using mutable vectors as MVector. Does anyonve know how to convert MVector to list? Vector toList don't work :(
10:24:28 <dolio> Knowing what monads are used for in category theory helps understand what they're used for in Haskell in a general way.
10:24:42 <Denommus> and my problem is calculating the position of the next token
10:25:27 <Hafydd> ski: I don't find that analogy apt, because the category-theoretical interpretation of Monad is with respect to Hask, whereas Group or VectorSpace classes would not be related to the type system in any special way.
10:26:00 <dolio> shersh: There's no function that will read a list out of an MVector, to my knowledge. But you could freeze the MVector and then turn the Vector you get into a list.
10:26:30 <Hafydd> I agree that it's not a way of performing external or meta reasoning about the type system.
10:26:30 <ski> dolio : "Knowing .." -- i don't have a problem with that
10:26:45 <ReinH> dolio, shersh: There's toList from Data.Vector.Generic
10:26:59 <dolio> For mutable vectors?
10:27:04 <shersh> ReinH: this code don't work :( http://lpaste.net/6520328669695574016
10:27:58 <ski> Hafydd : i suppose i'm failing to see an explication of the way in which you consider the CT interpretation "of Monad is with respect to Hask", but not with `Group' or `VectorSpace'
10:29:01 <Hafydd> ski: is there a group or a vector space that you believe Haskell's types form? What is the analogue of Hask for these structures?
10:30:12 <phaazon> I think I’ll rewrite my website from scratch in order to migrate from happstack to yesod
10:30:31 <phaazon> I’d love to learn how to write good modern website in Haskell
10:30:34 <phaazon> like, no javascript shit
10:30:37 <phaazon> something good.
10:30:48 <dolio> Modern websites don't use javascript? :)
10:30:48 <josephle> heh
10:30:56 <phaazon> dolio: modern websites programming
10:30:59 <phaazon> I’d rather say
10:31:10 <dfranke> well, you could use ghcjs and avoid actually *writing* javascript.
10:31:17 <phaazon> yeah, that’s what I thought
10:31:27 <josephle> or closure or elm or some other layer above js
10:31:37 <phaazon> elm sounds sexy, yeah
10:31:42 <thimoteus> clojurescript you mean?
10:31:49 <josephle> thimoteus: yes
10:32:08 <stoogenmeyer> phaazon: whats wrong with javascript
10:32:17 <ski> Hafydd : no. i suppose i see `Monad' more as an application of Haskell's type system to encode a CT concept, than as a way to employ CT to understand Haskell's type system
10:32:17 <stoogenmeyer> uhh. actually forget i asked
10:32:38 <thimoteus> hahaha
10:33:31 <ski> Hafydd : if you talked about Yoneda, or covariant vs. contravariant functors, then the picture would be different
10:33:36 <rmrfroot> Hafydd: do you have a small concrete example of using CT for thinking about Haskell types?
10:34:09 <dfranke> On the occasions I build websites I try to make them as static as possible (my blog uses Hakyll) and maybe I'd have a different opinion if I had to build something more complex, but as flawed as JS may be I don't find it so painful to deal with that I'd rather deal with a extra abstraction layer on top of it.
10:34:34 <Cale> ski: Well, it's kind of both isn't it?
10:34:45 <obadz> In haskell is there a way to define a local module within a module (for the purpose of avoiding record name collisions) ?
10:34:48 <Hafydd> ski: I didn't claim that it was an example of "understanding" Haskell's type system. I said it was "thinking about". In what way is ensuring that the Monad laws match the category-theoretical definition for Hask not "thinking about Haskell's type system"?
10:35:20 <Hafydd> As I said before, it's impossible to do this if there's no type system.
10:35:25 <shersh> dolio: could you please write example of code which converts list to Mutable Vector and then back again to list?
10:35:29 <Cale> ski: We've understood something about Haskell's type system (that there exist monads definable on it), and then come back around and actually encoded that in the language.
10:36:31 <olzhas> Newbies question with C exp. How to convert (cast) Bool to Int, i.e., False->0 and True->1?
10:36:59 <ski> Hafydd : sorry for that
10:37:36 <ski> Hafydd : "In what way is .." -- i'd say it's thinking *in* Haskell's type system (and also in CT)
10:38:04 <jameseb> > fromEnum True -- olzhas: I think this is the function you want
10:38:05 <lambdabot>  1
10:38:12 <ski> Hafydd : if you say "thinking about", then i'm imagining considering the system (or at least large swathes of it) as a whole
10:38:30 <jameseb> olzhas: though why do you want to convert Bool to Int?
10:38:47 <Hafydd> ski: that's a point of language on which we apparently differ, then.
10:39:01 <olzhas> jameseb: Awesome. Thanks. (counting)
10:39:42 <jameseb> olzhas: ah, okay. You probably do want fromEnum there then
10:39:43 <ski> i suppose i'm here (perhaps inappropriately) making a difference of considering a system itself, and applying it for some particular task
10:40:07 <stoogenmeyer> does the yoneda lemma has any consequences for real world applications? I am asking an uber noob
10:40:26 <ski> Cale : if they had talked about monads (and not just the type class `Monad' in particular), i think i would have reacted less
10:40:39 <stoogenmeyer> just trying to get a sense of whether results such as this have actual consequences or if they're just something that can be used in other proofs
10:40:56 <stoogenmeyer> *as an
10:40:59 <Cale> That's fair
10:41:12 <rmrfroot> Hafydd: sorry if i'm asking stupid questions. it's just that i have a hard time understanding stuff without a very concrete example.
10:41:52 <mpickering> stoogenmeyer: Yoneda tells us that two different representations are isomorphic so it's useful in the sense that it tells us certain representations are the same without having to do anything
10:42:28 <mpickering> one of these might be more efficient than the other or easier to use for example
10:42:38 <mpickering> I guess that's still not very concrete 
10:44:13 <Denommus> so, no ideas?
10:44:32 <Denommus> I think I'll move to Parsec
10:45:07 <Hafydd> rmrfroot: my opinion seems to be controversial, but I'd consider reasoning about the Monad laws, with respect to Haskell's type system, to be such an application. Monad is a generalisation of a pattern that manifests as "promises" or "futures" in other programming systems. It allows computation to be done on values that exist in a different context than usual, for example on values that don't yet exist but
10:45:13 <Hafydd>  could be computed. The laws are given here: <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/Control-Monad.html#t:Monad>. It's an understanding of Monads in CT that allow one to be confident they're correct.
10:45:19 <Hafydd> rmrfroot: for other example, perhaps ski can tell you more.
10:48:06 <jakob1> Does somebody know how to use the cabal LIBRARY? I need to access the PackageDescription but I only have the GenericPackageDescription.
10:48:06 <jakob1> "Before actually building a package we have to decide on each conditional. Once we've done that we get a PackageDescription."
10:48:06 <jakob1> - https://hackage.haskell.org/package/Cabal-1.22.4.0/docs/Distribution-PackageDescription.html
10:48:06 <jakob1> I don't understand how i "decide on conditionals".
10:48:30 <lmj> In what circumstances does "instance Num a => Foo a..." foul up "instance Foo (Bar a)..."?
10:48:42 <jg_> hi, i have a tuple of three elements. How do i pass those to a function? 
10:49:30 <ski> Hafydd : i'm sorry if i irked you. it was probably just something in your formulation that i got hung up over, and was unable to explicate much further :/
10:49:41 <mpickering> jakob1: Conditionals are decided by a few things I think, which versions of a package you have in your database, user flags etc
10:50:01 <mpickering> in short, resolving conditions isn't easy as you have to provide a lot of environmental information to do it well
10:50:11 <ski> jg_ : we need more context. preferably show some code
10:50:13 <Shockk> jg_: one way you could do it is: let (a, b, c) = tuple in f a b c
10:50:39 <mpickering> lmj: What do you mean by foul up? That instance will match every single type as additional constraints are only checked after matching
10:50:41 <Hafydd> ski: I am not irked, but I cannot see the essential fallacy in what I said that you're trying to point out.
10:51:12 <lmj> mpickering: I should have been more specific: overlapping instance error
10:51:35 <dolio> Hafydd: Here is an example that ski will like better. In Haskell we have covariant functors. Those are things with kind * -> * with some additional structure.
10:51:40 <mpickering> ok - so that is what I just said, the instance will match every single type
10:51:57 <mpickering> you can't say something like "this is an instance for everything which is an instance of Num"
10:52:07 <dolio> There are categories of both such things, and there is an inclusion from the functors category to the mere * -> * category.
10:52:10 <jg_> ski, Shockk: thanks! I used the let destructuring solution
10:52:53 <mpickering> specifically it will match "Bar a" hence why you get an overlapping instance error
10:53:00 <rmrfroot> Hafydd: thanks for that example! i think i have a very abstract understand of if, but i guess i need to read more to actually sit down and use practically. 
10:53:13 <dolio> Hafydd: This inclusion is itself a functor, and it has a left adjoint. Category theory tells you how to construct something that is the adjoint, as Ran Include Id.
10:53:13 <rmrfroot> use it*
10:53:49 <dolio> But you can also write it as: data FF f a = forall e. FF (e -> a) (f e).
10:54:20 <dolio> FF f is always a Functor, even if f isn't (for instance, if f is IORef).
10:54:33 <dolio> And it also fuses calls to fmap.
10:54:56 <dolio> So it's very useful to have FF in your bag of tricks.
10:55:30 <ski> yes, that's more of the kind of things i had in mind
10:55:45 <Hafydd> dolio: a fair example. I fear that it's even less accessible to someone like rmrfroot, however.
10:55:52 <ski> Hafydd : it is
10:56:00 <jakob1> mpickering: thank you. I am trying to extract a simple static information out of the cabal file: the hs-source-dirs
10:56:01 <jakob1> i tried it like this: https://gist.github.com/schoettl/b321baa5002ca48a46c5
10:56:01 <jakob1> is there a way to get this without resolving conditionals, or with minimal effort?
10:56:18 <ski> but then i don't really think understanding CT helps much at all with understanding the basics of the type system
10:56:50 <Hafydd> Yes, I'd agree. It probably isn't a good idea to think too much about it until you know you need it.
10:56:53 <ski> (and i'd count the type class `Monad' as belonging to the basics, here)
10:57:01 <rmrfroot> ski: yeah, i was afraid of that :)
10:57:09 <lmj> mpickering: I'm trying to understand why "instance Foo (Bar a)" compiles in the first place, if any use is an error.
10:57:43 <lmj> It must work under some condition?
11:00:03 <rmrfroot> Hafydd: maybe my first question should have been "is it useful to *try* and learn about CT for a programmer with no formal background?" ^^
11:00:28 <mpickering> the error is that you're not allowed two instances for the same type
11:02:20 <lingxiao> Hey all
11:02:36 <potatoe> I'm trying to read from a database using postgresql-simple, and I'm trying the most common query (select 1) , but the compiler gives me the error
11:02:36 <potatoe> Couldn't match expected type ‘Query’ with actual type ‘[Char]’In the second argument of ‘query_’
11:02:41 <lingxiao> can I ask why get has signature: MonadState s m => m s 
11:02:58 <ski> rmrfroot : it's useful for learning about something fun/cool
11:03:00 <potatoe> my code is     res <- (query_ conn "SELECT 1" :: IO [(Only Int)])
11:03:01 <lingxiao> what does the `m` here stand for?
11:03:03 <potatoe> is this wrong?
11:03:08 <Hafydd> rmrfroot: good question. I would never say it's useless for anyone to try and learn about something, but in the process of doing so properly, you might end up attaining the background that you say you lack.
11:03:11 <ski> lingxiao : "monad"
11:03:13 <lingxiao> any generic monad that implements get?
11:03:33 <ski> lingxiao : any monad which additionally has the state operations. including `get'
11:03:45 <lingxiao> ok so for example Reader could have it correct?
11:03:51 <lingxiao> but what about this? 
11:03:52 <lingxiao> newtype Parser a = P { unP :: StateT String [] a }
11:04:00 <lingxiao> I can construct a parser with (P get)
11:04:01 <MarcelineVQ> rmrfroot: As someone with a similarily basic or missing maths background I can say that reading some basic cat. theory stuff was useful to me for haskell. At the very least you can relate the concepts each use to each other.
11:04:14 <lmj> mpickering: when ghc sees "instance Num a => Foo a" and "instance Foo (Bar a)", shouldn't it know that there are two instances of the same type and give an error?
11:04:33 <mpickering> what happens?
11:04:33 <rmrfroot> ski, Hafydd: good points!
11:04:49 <ski> lingxiao : imho it wouldn't really be very useful with a `MonadState' instance for `Parser' (since, arguably, part of the point of defining it as a separate type is to *restrict* access to the state there)
11:05:25 <rmrfroot> MarcelineVQ: ah, awesome! 
11:05:56 <potatoe> so anyone sees something really wrong with this code?     res <- (query_ conn "SELECT 1" :: IO [(Only Int)])
11:06:17 <lmj> mpickering: there's no error unless one tries to call foo with a Bar.
11:06:22 <ski> rmrfroot : knowing a bit of CT can also help with organizing e.g. group theory (symmetries), linear algebra (vectors and matrices, and beyond), ring theory, topology, &c. in your head .. if you're into that kind of thing
11:06:55 <rmrfroot> potatoe: are you using the OverloadedStrings extension? 
11:07:00 <potatoe> oh I am not
11:07:02 <potatoe> good catch
11:07:57 <potatoe> time to go read up on overloadedstrings
11:08:20 <lingxiao> ski : right so my question was since I can consruct Parser a with (P get)
11:08:32 <lingxiao> get here would have signature :: StateT String [] a right?
11:08:41 <lingxiao> so StateT also implements get?
11:09:47 <lingxiao> I can't where on here: https://hackage.haskell.org/package/mtl-2.2.1
11:10:06 <rmrfroot> ski: ah, interesting!
11:10:51 <lingxiao> actually I can't even find where StateT s m a is defined
11:11:22 <mpickering> lmj: Don't know
11:11:35 <rmrfroot> potatoe: if you're interested in a "in a nutshell / TLDR" explanation i can provide
11:12:11 <potatoe> rmrfroot of course I am
11:13:58 <lingxiao> ping
11:15:46 <lingxiao_> ping
11:16:02 <lingxiao_> so yeah confused about why I can construct an instance of this:
11:16:02 <lingxiao_> newtype Parser a = P { unP :: StateT String [] a }
11:16:09 <lingxiao_> using P get
11:16:15 <lingxiao_> where get :: Monad s m => m s
11:16:32 <nek0> hi there.
11:16:41 <lingxiao_> so I'm assuming this means StateT String [] a, or in general StateT s m a implements get correct
11:16:41 <nek0> Has anyone of you ever worked with acid-state in combination with yesod?
11:16:54 <nek0> I would like to pass mutliple states around, and from what I have read in the Happstack-book, the ReaderT Monad would be best, but I dont know how to wrao it around it. Can anyone here help me?
11:17:39 <lyxia> lingxiao_: StateT is in transformers
11:18:16 <sleblanc> Is there a type evaluation tool (similar to ":t" in GHCI) that can reason about values that are not instantiated?
11:18:36 <lyxia> lingxiao_: and get is in mtl, Control.Monad.State (which reexports Control.Monad.State.Lazy)
11:18:45 <sleblanc> The reason I need this is to reason about types using the Gtk library, but the process of instantiating one of those values is quite complicated, when I don't actually need the value
11:20:12 <lyxia> lingxiao_: There is an instance (MonadState s (StateT s m)), which gives a function get :: Monad m => StateT s m s.
11:20:26 <rmrfroot> potatoe: cool! so, when you normally write `"select 2 + 2"` that has the type `String`. but if you look at the `query_` function it wants the type `Query`. basically there's a typeclass called `IsString` that has a function called `fromString` that `Query` implements to convert a `String` into a `Query`. when you use OverloadedStrings you can write `"select 2 + 2"` instead of `fromString "select 2 + 2"`.
11:20:48 <lyxia> lingxiao_: s = String, m = [], allows get = P get to typecheck.
11:21:02 <potatoe> oh, that is much more clear than the generic explanation that I found, especially when you put it in context of query_ 
11:21:04 <potatoe> thanks a lot rmrfroot 
11:21:09 <lingxiao_> lyxia ok so what is MonadState?
11:21:13 <sleblanc> For example, in a statement such as → :t on (a::TreeView); GHCI tells me that the value 'a' is not in scope, which is accurate, but since ":t" does not evaluate values, I would like to find a way to tell to the :t command to trust me on the inferred type
11:21:14 <lingxiao_> is that a class?
11:21:17 <lyxia> lingxiao_: yes
11:21:41 <lingxiao_> ah and the data type State s a is an instance of that class correct?
11:21:45 <lyxia> lingxiao_: defined in the library mtl, in the module Control.Monad.State
11:21:59 <lyxia> basically yes
11:22:11 <rmrfroot> potatoe: glad i could help :)
11:22:32 <lingxiao_> lyxia ok great thanks!
11:23:29 <quicksilver> sleblanc: in practice to do that I just bind them all locally
11:23:46 <quicksilver> sleblanc: :t \a -> on (a :: TreeView)
11:24:13 <sleblanc> quicksilver, brilliant!
11:24:15 <quicksilver> sleblanc: so you collect at the beginning of the line a lambda-binding for all the spare names
11:24:44 <sleblanc> and then I just have to ignore the "n" first types in the result
11:25:07 <jg_> how do i transform Text into a Conduit producer anyway?
11:25:12 <sleblanc> quicksilver, thanks a lot
11:26:54 <Cale> jg_: Perhaps you're looking for sourceLazy
11:27:02 <Cale> in Data.Conduit.Combinators
11:27:39 <jg_> Cale: how about encode? https://hackage.haskell.org/package/conduit-extra-1.1.9.1/docs/Data-Conduit-Text.html
11:28:02 <Cale> That's a conduit for converting Text into ByteString, as the type indicates.
11:28:40 <Cale> It's not a producer, just something that you might put in the middle of a pipeline.
11:29:02 <jg_> oh
11:31:20 <nek0> hello? anyone?
11:31:45 <dmj`> nek0: check out Data.Acid.Remote
11:32:58 <Qweer> I'm currently going through Learn you a haskell 'book' are there some exersises(doesn't have to be directly related to it) which I can do to verify my understanding is right?
11:34:11 <bendlas> How come that no monad tutorial mentions that monads are basically a typed interface for CPS?
11:34:20 <quicksilver> one of the criticisms people make of lyah is it doesn't have exercises.
11:34:31 <quicksilver> bendlas: because they aren't. That's merely one application.
11:35:00 <quicksilver> also continuations aren't *that* familiar to most people who need monad tutorials so they aren't the introduction most people choose.
11:35:10 <Denommus> bendlas: what's a CPS?
11:35:16 <quicksilver> continuation passing semantics
11:35:23 <bendlas> Denommus: Continuation passing style
11:35:38 <danza> continuation passing something
11:35:40 <bendlas> that's one of the code representations of choice in lisp land
11:35:45 <Denommus> bendlas: that works, until it doesn't. Like monadic parser libraries
11:35:46 <rmrfroot> nek0: couldn't you put the references in your app data type? same place the config, logger and database pool is kept?
11:36:15 <bendlas> but monad parser libraries do allow parsers to be written in CPS
11:36:21 <bendlas> which makes it so powerful
11:36:40 <Denommus> bendlas: that's a good point
11:36:59 <Denommus> bendlas: what about lists?
11:37:05 <bendlas> in fact the unifying semantics of all the monads is, that they are given their continuation by bind
11:37:38 <sleblanc> Is it possible to enable a hidden package without restarting the GHCI REPL?
11:37:39 <Qweer> @quicksilver I don't need exersises which match exactly to the book. I read multiple chapters already so I would just just prefer doing some exercises
11:37:40 <lambdabot> Unknown command, try @list
11:38:14 <Denommus> Qweer: don't use @ in IRC
11:38:45 <danza> bendlas, it seems that you can express continuation passing style as a specific implementation of a monad http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Cont.html
11:38:58 <bendlas> quicksilver: hm, i wrapped my head around CPS pretty quickly, but took endless reiterations to grasp monads and only just now, I made the connection + found it validated here: http://stackoverflow.com/questions/4525919/continuation-passing-style-vs-monads
11:39:25 <quicksilver> Qweer: http://www.cis.upenn.edu/~cis194/lectures.html
11:40:26 <bendlas> danza: true, also with Control.Monad.Cont, you can encode any other monad, see: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
11:40:48 <quicksilver> bendlas: yeah. I don't feel qualified to quite tease that apart.
11:41:02 <quicksilver> bendlas: you're right that bind has a continuation as its right-hand parameter, of course
11:41:14 <Denommus> bendlas: I think people just overcomplicate monads. In Haskell, a monad is simply any type that implements the Monad typeclass and follows some laws
11:41:15 <quicksilver> bendlas: and various stackoverflow reponses hint at a deeper connection
11:41:30 <quicksilver> bendlas: but, say, IO is not somehting you could just go an implement with CPS
11:41:36 <quicksilver> bendlas: there is something 'else' going on there.
11:41:56 <quicksilver> maybe someone else with a clearer head can pinpoint the distinction.
11:42:06 <quicksilver> but if you find CPS a useful way in then that's excellent :)
11:42:26 <bendlas> quicksilver: also, it seems to me that the type constraint of bind to return another monad is there exactly to ensure CPS (i.e. returning something that can take another continuation)
11:43:03 <jg_> Cale: How do i feed strict text into sourceLazy? I only see this fromChunks method in Data.Text.Lazy for doing the conversion
11:43:28 <Cale> jg_: Yeah, just use that I suppose.
11:43:47 <jg_> ah, fromStrict maybe?
11:45:04 <quicksilver> do you just have one strict text jg_ 
11:45:05 <quicksilver> or many?
11:45:15 <quicksilver> bendlas: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html, and the comments on it, are the best I think
11:45:22 <quicksilver> bendlas: especially edwardk 's comment
11:45:23 <bendlas> quicksilver: concerning IO, CPS is used here to decouple the expression of "intended" side effects from their actual scheduling
11:45:27 <jg_> "stuffs" <- that's my 'strict' text :p
11:45:34 <jg_> just one
11:45:39 <quicksilver> jg_: then just yield it?
11:45:47 <quicksilver> sourceOneText t = yield t
11:45:54 <jg_> what is yield?
11:45:54 <quicksilver> sourceOneText :: Source m Text
11:46:03 <bendlas> quicksilver: same as in node-style asynchronous IO
11:46:07 <quicksilver> it's the conduit command to make something available
11:46:23 <quicksilver> it's the fundamental way to make sources
11:46:44 <quicksilver> sorry, sourceOneText :: Text -> Source m Text
11:48:08 <nek0> rmrfroot: I have put it into the App type, but i don't know how to wrap it into ReaderT
11:48:17 <jg_> quicksilver: where is yield defined?
11:48:43 <mjhoy> is anyone here going through cis194 (spring '13) as has been recommended by some? i'm up to week 7, and interested in doing some sort of study group.
11:49:27 <Qweer> mjhoy I'll start today
11:50:42 <quicksilver> jg_: Data.Conduit. We were talkin about conduits right?
11:50:45 <jg_> yes
11:51:04 <quicksilver> yield plays a prominent role in the conduit tutorials
11:51:08 <quicksilver> it's one of the basic things
11:52:51 <ski> bendlas : also see paper "Representing Monads" by Andrzej Filinski in 1994-01 at <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/>, for more on relation between monads and (composable/delimited/sub-) continuations
11:53:29 <mjhoy> Qweer: cool. let me know if you want to discuss the homework problems. mjh@mjhoy.com
11:53:38 <bendlas> ski: cool, thanks!
11:53:59 <jg_> quicksilver: oh? there are many? i've read only that FP complete one by Snoyman...
11:54:15 <ski> bendlas : "Representing Control: A Study of the CPS Transformation" in 1992-12 and "Abstracting Control" in 1990-06 by ibid is also interesting
11:55:10 <ski> (those two latter coauthored with Olivier Danvy, who also has several interesting papers ..)
11:58:06 <Octophore`> when people say "if I could have just one monad it would be Cont which would let me emulate all the others", is that an equivalent statement to the statement that delimited continuations can implement any control flow operator?
12:00:20 <ski> bendlas : .. and perhaps you should read those two latter papers, before the monads one
12:00:32 <bendlas> Octophore`: I think it's to say that the continuation monad is the natural abstraction of the identity monad
12:02:54 <dolio> Octophore`: I think it's similar. But those sorts of statements are subtly wrong anyway.
12:03:09 <phaazon> hey, what is the name of the extension for lambda guards?
12:03:18 <phaazon> \x | x == … -> … | otherwise -> …
12:03:43 <bendlas> ski: thanks for the hints. "Representing Monads" already blew my mind in the Abstract
12:04:57 <Zemyla> Can double-sided pattern matches be inlined?
12:06:11 <lyxia> phaazon: multiwayif come pretty close
12:07:45 <skatenerd> https://gist.github.com/skatenerd/31142f608e01cce4d461
12:07:49 <skatenerd> any ideas?
12:09:16 <lyxia> skatenerd: what's characterization?
12:09:18 <ski> Octophore` : i'm not really sure what "if I could have just one monad it would be Cont which would let me emulate all the others" means
12:09:41 <ski> Zemyla : double-sided ?
12:10:11 <Zemyla> pattern A a <- ... where A a = ...
12:10:59 <lyxia> skatenerd: It looks like some composition using groupBy
12:11:34 <Octophore`> ski: paraphrasing from this https://www.fpcomplete.com/user/dpiponi/the-mother-of-all-monads
12:12:21 <skatenerd> characterization in this case is "head"
12:12:22 <skatenerd> as in,
12:12:25 <ski> Octophore` : yes
12:12:28 <skatenerd> clump the things by their first letter
12:12:41 <skatenerd> except if there's some garbage between to clusters,
12:12:48 <skatenerd> you wind up in separate lists
12:12:59 <ski> Zemyla : dunno :/
12:13:09 <lyxia> skatenerd: use groupBy?
12:14:33 <skatenerd> groupBy will put all of the "a" guys into one list?
12:15:06 <lyxia> well it's not the same type as what you are looking for but you can work from there.
12:15:48 <lyxia> skatenerd: http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html#v:groupBy
12:15:58 <skatenerd> oh jk
12:16:00 <skatenerd> :-)
12:16:26 <behzad-nouri> ;r
12:17:20 <behzad-nouri> does anyone here know how i can make this work?
12:17:20 <behzad-nouri> new :: [a] ->  UArray Int a
12:17:23 <behzad-nouri> new a  = runSTUArray (newArray_ (0, 5))
12:17:30 <skatenerd> well, thanks...
12:19:20 <ski> behzad-nouri : fill the array with the elements of the list, perhaps ?
12:19:50 <ski> (and maybe check the length of the list, before allocating an array ?)
12:20:32 <behzad-nouri> ski: it is a type check error
12:20:55 <behzad-nouri> it just cannot be polymorphic in `a`, i mean this works:
12:20:59 <behzad-nouri> new :: [a] ->  UArray Int Bool
12:20:59 <behzad-nouri> new a  = runSTUArray (newArray_ (0, 5))
12:24:07 <quicksilver> Octophore`: remember that all the monads except can be "emulated in simple code" whatever that means, anyway
12:24:14 <quicksilver> yikes, scrolled up
12:30:55 * hackagebot HListPP 0.2.1 - A preprocessor for HList labelable labels  https://hackage.haskell.org/package/HListPP-0.2.1 (AdamVogt)
12:30:57 <ski> behzad-nouri : fsvo "works"
12:31:18 <ski> behzad-nouri : also, why can't it be polymorphic in `a' ?
12:32:04 <behzad-nouri> ski: i donno, if i knew i was not asking
12:32:32 <ski> your suggested `new' is, in fact, polymorphic
12:34:12 <behzad-nouri> ski: new :: [a] -> UArray Int Bool       works
12:34:25 <behzad-nouri> new :: [a] -> UArray Int a     does not work
12:35:08 <behzad-nouri> with the same function body, i.e.   new a = runSTUArray (newArray_ (0, 5))
12:35:33 <jg_> i find myself repeating the test data setup in hspec for every 'it' block - is there a way to avoid this?
12:37:11 <jg_> code: http://lpaste.net/8823910636325961728
12:37:50 <ski> behzad-nouri : it would have helped if you had supplied the error message
12:38:23 <ski> behzad-nouri : you're using unboxed arrays. currently that means that you must pick a specific element type
12:46:40 <roelof> Anyone who can give feedback on this solution : https://bitbucket.org/roelofwobben/craft-exercises/src/7b8631ebc58cb598f5c0f690e93b03b9d7111169/chapter_5/orderTriple/src/Lib.hs?at=default&fileviewer=file-view-default
12:48:29 <lyxia> jg_: factor the common parts in functions
12:54:47 <lpaste_> behzad-nouri pasted “runSTUArray error” at http://lpaste.net/144757
12:55:41 <behzad-nouri> can anyone help with this runSTUArray error? http://lpaste.net/144757
13:00:47 <c_wraith> behzad-nouri: if you look up a few lines, you'll see ski already did. 
13:01:56 <behzad-nouri> c_wraith: did not
13:02:13 <prsteele> (reading System.Process) "...terminateProcess... should not be used under normal circumstances"
13:02:41 <prsteele> anyone know of a better alternative?
13:04:03 <lpaste_> lyxia revised “hspec”: “jg_” at http://lpaste.net/8823910636325961728
13:05:24 <ChristianS> prsteele: if your process will do the right thing on receiving SIGTERM, terminateProcess should be fine (assuming you're on Unix)
13:06:03 <cite-reader> behzad-nouri: You're trying to use newArray_ to create an unboxed array that's fully-polymorphic in its element type, but it doesn't work that way. (To understand why, think about how you would allocate storage for such a thing.) There needs to be an MArray (STUarray s) e (ST s) instance for every concrete type e you want to use this code with, but your type signature doesn't declare that.
13:07:40 <prsteele> ChristianS: okay, thanks. The setting is I'm writing a program to grade student's programs, and I want to bail if they take longer than, say, 10 seconds to run... so assuming they don't guard against SIGTERM I guess it should be fine
13:08:09 <roelof> no one for a little feedback  ? 
13:08:17 <cite-reader> prsteele: Maaaaybe fire SIGKILL at them instead.
13:09:05 <prsteele> cite-reader: heh, ya that might be reasonable
13:09:15 <prsteele> roelof: what are you looking for? correctness, style...?
13:09:29 <roelof> expecially correctness 
13:09:31 <cite-reader> Also there's probably countermeasures against forkbombing you'll want to look up and implement.
13:10:02 <behzad-nouri> cite-reader: that is absolutely corrrect, but i cannot find the right type-class constraint for this to work
13:10:18 <prsteele> cite-reader: luckily I think I don't have to worry about that (small class, graduate students, running in a VM anyway)
13:10:30 <prsteele> cite-reader: I'm not really accepting arbitrary executables
13:10:59 <cite-reader> prsteele: Okay, good; I just get antsy whenever I see "running student code".
13:11:06 <prsteele> roelof: for correctness, I'd suggest writing some hypothesis tests
13:11:15 <behzad-nouri> cite-reader: in particular adding (MArray (STUArray s) e (ST s)) does not help
13:11:27 <prsteele> roelof: e.g. quickcheck
13:11:36 * cite-reader flashes back to that time the entire class accidentally forkbombed the university infrastructure...
13:11:45 <prsteele> roelof: since it is easy to write isOrdered (a, b, c) = a <= b && b <= c
13:12:05 <prsteele> cite-reader: heh, ya. I figured I'd just fire up a VM for grading and call it a day
13:12:30 <roelof> prsteele:  I did write a lot of quickCheck and Hunit tests 
13:12:33 <cite-reader> behzad-nouri: Looking things up, please hold.
13:13:04 <roelof> what do you mean with isOrdered ? 
13:14:15 <prsteele> roelof: that's a test you could run. prop_ordered = isOrdered . orderTriple
13:14:35 <lyxia> "isOrdered = between" though...
13:15:02 <prsteele> did I miss something obvious?
13:15:14 <roelof> oke, and what do I test with between . orderTriple ? 
13:15:19 <lamefun> Why doesn't Aeson implement overlay-able type parsers?
13:16:00 <lyxia> prsteele: I mean roelof already wrote isOrdered as between, though not optimally.
13:16:13 <prsteele> lyxia: oh okay
13:16:50 <prsteele> roelof: you'd use that as a quickcheck property
13:17:28 <roelof> lyxia:  and how can I rewrite between so it is optimally / 
13:18:33 <prsteele> roelof: there are 3! = 6 ways to order (a, b, c), so I think you should be able to implement this with at most 3 comparisons (since 2^3 = 8)
13:18:52 <lyxia> roelof: get rid of the last comparison.
13:20:42 <ski> behzad-nouri : you'd need the constraint `forall s. MArray (STUArray s) e (ST s)' for that, but you can't use `forall' in constraints currently
13:20:53 <roelof> lyxia:  you mean this part : && x <= z in between ? 
13:21:50 <roelof> prsteele:  you mean rewrite middleNumber with only 3 clauses ? 
13:22:16 <prsteele> roelof: I mean you can probably get all three ordered in one go, rather than selecting the min, then the middle, then the max
13:22:39 <behzad-nouri> ski: so what should i do?
13:22:39 <prsteele> roelof: https://en.wikipedia.org/wiki/Sorting_network#Optimal_sorting_networks
13:23:40 <prsteele> roelof: for example, say you start by computing a <= b. If this is true, you know b is either the middle or largest number
13:23:51 <roelof> prsteele:  oke, I could , the exercise says to use min, middle and max function 
13:24:05 <prsteele> roelof: well then keep doing what you're doing :)
13:24:07 <ski> behzad-nouri : pick a particular element type, i suppose. i don't see a better solution
13:25:29 <roelof> prsteele:  oke, if a < = b then b is the middle or the largest one. So I have to compare it with c which one is bigger. The other one is the middle 
13:25:50 <behzad-nouri> ski: it is part of a data structure, it has to be polymorphic in value type, o.w. would not make sense
13:26:19 <ski> behzad-nouri : afaics, you're out of luck
13:27:20 <roelof> so  lets c is bigger then b is the middle , I only have to compare c and a which one is the largest or the lowest , Am I right ? 
13:28:58 <roelof> no I not. If a < b and b < c then a is the lowest, b is the middle and c is the highest , prsteele  
13:33:24 <prsteele> roelof: yes, If a <= b then b can either be the middle or the highest, we don't know which yet
13:33:31 <prsteele> likewise, a would be the smallest or the middle
13:33:39 <prsteele> c could still be anywhere
13:33:40 <c_wraith> behzad-nouri: if you have to be polymorphic, you can't be unboxed anyway. Lots of types just can't be. 
13:34:31 <c_wraith> behzad-nouri: in which case, the simple solution is remove the U
13:35:57 <roelof> prsteele:  oke, I can try to solve it and make one function which do it all instead of 3 functions. I will do it tomorrow. Its late now. 22:35 in the evening and it's time to sleep 
13:36:27 <prsteele> roelof: you can still use multiple functions, but some should only consider two arguments, maybe. Good luck!
13:36:34 <behzad-nouri> c_wraith: that is not true! u can add unbox/uarray type-class constraint on types
13:37:12 <stephenmac7> If I have a list of values and a list of functions, is there any way to figure out if the functions match any part of the list?
13:37:31 <prsteele> stephenmac7: like, by type?
13:37:36 <stephenmac7> Example: matching [odd, even, even] on some list of numbers
13:37:53 <stephenmac7> No, just whether they return True or False when fed the values
13:37:57 <c_wraith> behzad-nouri: I suppose, if you are looking to support only unboxable types, (and have a really limited structure), you could switch to Vector. Its unboxed interface lets you do what you want. 
13:38:19 <prsteele> zipWith ($) funcs values -- ?
13:38:23 <lyxia> stephenmac7: what do you call "match"
13:38:32 <prsteele> > zipWith ($) [odd, even, even] [1, 2, 3]
13:38:35 <lambdabot>  [True,True,False]
13:38:42 <behzad-nouri> c_wraith: yes, i only want to work with unboxable types
13:38:48 <stephenmac7> Yes, but on any part of the list
13:39:15 <behzad-nouri> c_wraith: i would need to do some mutations with STUArray arrays, that  is why i am using UArrays
13:40:00 <c_wraith> behzad-nouri: Vector has a mutable interface. And its approach to unboxed vectors lets you express the constraint you want. 
13:40:16 <c_wraith> @hackage vector
13:40:16 <lambdabot> http://hackage.haskell.org/package/vector
13:40:26 <prsteele> > map (\f -> any f [1, 2, 3]) [odd, even, even]
13:40:30 <lambdabot>  [True,True,True]
13:40:42 <stephenmac7> lyxia: I mean f [odd, even, even] [5,3,8,7,7,4,4,6] would return True because [7,4,4] satisfies the condition
13:41:18 <c_wraith> stephenmac7: so you want a search. That's an important word to include. 
13:41:52 <stephenmac7> c_wraith: I guess that would be a better word
13:41:56 <athan> Anyone know of a more type-safe URI type than network-uri?
13:42:03 <lyxia> stephenmac7: what happens at the borders, what's f [odd, even, even] [2,2] and f [odd, even, even] [1,2]?
13:42:16 <athan> Query parameters should be a list of pairs, and port should be an Int, imo
13:42:22 <stephenmac7> lyxia: It returns False
13:42:56 <prsteele> stephenmac7: Data.List (tails) might be useful
13:43:18 <c_wraith> athan: -17 is one of my favorite ports. :) 
13:43:49 <athan> c_wraith: Good point. the uri package fits the bill though
13:53:18 <lyxia> > let f fs xs = any (\ys -> and (zipWith ($) fs ys)) (take (length xs - length fs + 1) (tails xs)) in (f [odd, even, even] [1,2,3,4,5,6,7,8,10,11], f [odd, even, even] [1..10]) -- stephenmac7 
13:53:20 <lambdabot>  (True,False)
13:54:42 <stephenmac7> lyxia: Thanks, give me a second to process that
13:57:36 <behzad-nouri> cite-reader: i posted the problem over stackoverflow, in case u can help over there: https://stackoverflow.com/questions/33576274
13:58:14 <jorendorff> I have this situation: https://gist.github.com/jorendorff/d7314961ef112385396d How can I complete the definition of isEmpty?
13:59:16 <jorendorff> I should add to that: I want to be able to raise an error rather than go into an infinite loop.
13:59:47 <c_wraith> behzad-nouri: any particular reason you don't want to just use Vector? 
14:00:42 <jorendorff> If I didn't have to detect loops, it'd be easy, and I bet I could even make it efficient...
14:01:20 <lyxia> jorendorff: if you want to detect loops, then write a sub-function which keeps track of names you've gone through already.
14:01:24 <behzad-nouri> c_wraith: i want to learn how to make this work, if it is possible
14:02:11 <behzad-nouri> c_wraith: also in my use-case i have 2 dimensional arrays, vectors are clumsy with more than 1 dimension
14:02:18 <c_wraith> behzad-nouri: it's not. As ski said, the constraint you'd need to write isn't valid in GHC. But Vector has a different design that lets it work.
14:03:05 <c_wraith> behzad-nouri: and you can use Data.Ix with vector if you want. 
14:03:35 <jorendorff> lyxia: the other thing i'm worried about is cases like Map.fromList [("Goal", Alt (Lit 'x') (Seq (Ref "Goal") (Lit 'x')))]
14:05:35 <mpickering> jorendorff: Is that kind of thing allowed?
14:07:28 <jorendorff> mpickering: what, a haskell program not support recursion?
14:07:46 <mpickering> seems like you could maybe represent non-regular languages like that
14:10:00 <jorendorff> oh, you definitely can, I should not have called this "RegExp" -- it isn't called that in my real program
14:12:50 <lyxia> Regex extensions such as PCRE allow that
14:14:27 <mpickering> ok, so if you add too much power then emptiness becomes undecidable 
14:14:29 <lyxia> jorendorff: Do you mean that keeping a stack of names not sufficient?
14:14:39 <mpickering> not that this is helping your problem :)
14:15:47 <lyxia> jorendorff: Also there are several non-equivalent ways of interpreting such expressions I believe, do you have a more precise definition?
14:15:59 * hackagebot yesod-raml-bin 0.1.1 - The raml helper executable.  https://hackage.haskell.org/package/yesod-raml-bin-0.1.1 (junjihashimoto)
14:17:49 <jorendorff> lyxia: 1) Yes, I think it's not sufficient for that example. 2) I can be more precise
14:19:34 <lyxia> Actually I'm stuck at guessing your definition of the language recognized by an expression.
14:20:03 <jorendorff> lyxia: great, let me try to refine the gist
14:21:12 <m_ryan> can anyone help me with this? how do i get the result one by one? https://github.com/ondrap/geoip2/blob/master/Data/GeoIP2.hs#L122
14:22:36 <jorendorff> lyxia: updated: https://gist.github.com/jorendorff/d7314961ef112385396d
14:22:46 <jorendorff> lyxia: but I fear I may have missed the issue
14:22:50 <jorendorff> I don't know what the problem was exactly
14:23:44 <mpickering> m_ryan: you are going to have to explain some more
14:23:59 <mpickering> it seems the result is always a GeoResult
14:24:07 <lyxia> jorendorff: well I know what all the operators do :3 For example, what does Goal match if it's just Ref Goal ?
14:25:04 <jorendorff> lyxia: That particular case I'd love to detect and treat as an error - it seems to me there's not a unique fixed point
14:25:24 <lyxia> jorendorff: what about   <Goal> = <Goal>|x    or    <Goal> = x|<Goal>
14:25:59 <m_ryan> mpickering: http://lpaste.net/144765, like this
14:26:04 <lyxia> well you can in fact take the "smallest fixed point", or the "greatest fixed point", they are both possible definitions
14:26:14 <lyxia> except that they result in different languages
14:26:24 <lyxia> and there's plenty inbetween.
14:26:51 <jorendorff> yep, understood
14:27:08 <jorendorff> least fixed point would be fine with me but even better would be to detect that there's no unique fixed point and why
14:27:09 <lyxia> So my question was, which of these did you have in mind
14:27:34 <mpickering> So m_ryan, you want to bring into scope all the fields of a GeoResult?
14:27:46 <lyxia> jorendorff: oh if having a unique fixed point is a condition that's fine too :)
14:27:55 <jorendorff> lyxia: great, that's what i really want
14:29:39 <zalatovo> How would I avoid having 2 versions of nearly the exact same data structure? Say in a compiler where I first have a tree without type information, and then one in which each node has a type attached.
14:29:41 <jorendorff> lyxia: I don't think I can detect that condition or answer the `matchesEmptyString` question without basically doing both
14:29:49 <m_ryan> mpickering: yes, i want to set them one by one. in a varaible
14:29:54 <zalatovo> This is not my exact situation, but it's similar enough
14:30:07 <jorendorff> zalatovo: i have that exact problem today, only it's location information
14:30:18 <E4xoi> parametrize
14:31:05 <jorendorff> zalatovo: I ended up just including the source-location information in the tree, always... it kind of sucks
14:31:23 <ski> @where DecoratingStructures
14:31:23 <lambdabot> <http://web.archive.org/web/20051126143527/http://haskell.org/hawiki/DecoratingStructures>
14:31:25 <ski> zalatovo ^
14:31:30 <lpaste_> mpickering revised “No title”: “No title” at http://lpaste.net/144765
14:31:34 <zalatovo> ski: thanks, I'll have a look
14:31:46 <mpickering> m_ryan: see that paste, does that do what you want?
14:34:20 <lyxia> jorendorff: isn't a map of your "RegExp" just a context free grammar?
14:35:01 <jorendorff> lyxia: yes
14:35:36 <lyxia> Oh except that the study of CFG usually takes the lfp.
14:35:39 <m_ryan> mpickering: i update the lpaste. can you check if it is ok.
14:37:00 <mpickering> I updated it again
14:37:04 <mpickering> what do you want to do with that snippet
14:37:20 <mpickering> it would be a type error, I changed it now so it does nothing
14:37:41 <jorendorff> Generally I feel like I've been here before, in Haskell
14:38:05 <jorendorff> I want to compute something for each node in a data structure, the answers are interdependent, and I need to detect cycles
14:38:38 <m_ryan> mpickering: i just want to check the result one by one. if there is a result then i will set it one by one on a variable and do some stuff there.
14:39:04 <mpickering> ok yes, try what is in the paste now. 
14:39:21 <mpickering> I would probably write another function, checkGeoResult :: GeoResult -> ...
14:40:51 <m_ryan> mpickering: can i check if the result is empty?
14:41:34 <mpickering> what does it mean to be empty??
14:41:47 <mpickering> (*just one ? sorry!)
14:41:56 <mpickering> You mean if all the fields are Nothing?
14:42:02 <m_ryan> mpickering: yes
14:42:40 <m_ryan> mpickering: in the lpaste its just a GeoResult. how about Maybe GeoResult is it possible?
14:42:49 <mpickering> sure
14:43:06 <mpickering> maybe it would be better if GeoResult didn't have Maybe fields
14:43:21 <mpickering> and findGeoData returned "Maybe GeoResult"
14:43:37 <m_ryan> mpickering: how can i do that?
14:43:41 <mpickering> I don't know what the combinators are you are using (..? and so on)
14:44:14 <m_ryan> mpickering: you mean dot and question mark?
14:45:27 <mpickering> yes on line 122
14:45:52 <m1dnight_> Is there a more idiomatic to do something like:   do { mybeValue <- someFunction; return $ (Just plainValue) == mybeValue;} ?
14:45:59 <m1dnight_> idiomatic way*
14:46:32 <m1dnight_> i.e., wrapping a plain value in a maybe just to compare
14:47:05 <lyxia> jorendorff: I now think that my initial idea of keeping track of a stack of identifiers is still correct at least for the expressions which you consider valid.
14:47:10 <m_ryan> mpickering: i don't own the git :) so i just do it on a function sorry
14:47:37 <jorendorff> lyxia: thanks for all the clues
14:48:23 <Tuplanolla> Try (plainValue ==) <$> maybeValue, m1dnight_.
14:48:29 <ReinH> mpickering: Uh. read $ show ip2... why?
14:48:52 <mpickering> Not mine, ask m_ryan 
14:49:18 <ReinH> return 'empty for now'... '' is for characters, not strings
14:49:22 <Tuplanolla> If you also want to compare Just _ with Nothing, it's better done separately.
14:50:38 <m_ryan> ReinH: it's just an expression, a note.
14:51:17 <ReinH> m_ryan: it's a syntax error.
14:51:35 <mpickering> m_ryan: You can check if all the fields are Just's but there isn't much point unless you make your own datatype as you will have to unwrap the maybe everytime you use any of the fields
14:53:21 <ReinH> You can pattern match on (GeoResult (M
14:53:23 <ReinH> er
14:53:37 <ReinH> You can pattern match on (GeoResult (Just continent) (Just continentCode) ...)
14:54:24 <m1dnight_> Tuplanolla: thanks, I will try. Just a small remark, how do I google that operator?
14:54:40 <Tuplanolla> You don't, but you can Hoogle it.
14:54:49 <ReinH> Or you can use do syntax in the Maybe monad.
14:54:58 <Tuplanolla> m1dnight_: http://haskell.org/hoogle/?hoogle=%28%3C%24%3E%29
14:55:04 <m_ryan> ReinH: you mean,  (GeoResult (Just continent) (Just continentCode) ...) <- liftIO $ findGeoData geodb "en" ip
14:55:21 <ReinH> Yeah, you could do that. If it doesn't match, it would use the monad's fail implementation.
14:55:27 <ReinH> But that may not be the nicest way to handle failure.
14:55:44 <ReinH> m_ryan: Which fields do you want to check? All of them?
14:56:00 * hackagebot exit-codes 0.1.1.0 - Exit codes as defined by BSD  https://hackage.haskell.org/package/exit-codes-0.1.1.0 (justus)
14:56:24 <m_ryan> ReinH: the continent, country, city
14:56:52 <ReinH> m_ryan: What do you mean "the result one by one"?
14:56:54 <m_ryan> mpickering: yeah
14:56:58 <ReinH> There is only one GeoResult.
14:57:27 <m_ryan> ReinH: one by one means the continent, country, city.
14:57:43 <ReinH> I'm going to guess that you want to handle two cases: 1) where every Maybe is a Just and 2) otherwise?
15:01:33 <gfixler> what is the monoid for functions?
15:01:45 <gfixler> id?
15:01:52 <ReinH> gfixler: It depends.
15:01:57 <ReinH> Are you referring to Endo?
15:02:00 <gfixler> no
15:02:03 <gfixler> just functions
15:02:28 <ReinH> Do you mean the instance Monoid b => Monoid (a -> b) ?
15:02:38 <gfixler> I think so
15:02:44 <ReinH> If the result type is a monoid, it applies the functions and mappends the result.
15:02:51 <gfixler> ah, okay
15:02:58 <ReinH> mempty = const mempty
15:03:05 <ReinH> mappend f g x = f x <> g x
15:03:12 <slightSc1pe> Is reading LYAH and then Real World Haskell really the best path to learning? Are there any books or blog posts that explain the concepts functional programming?
15:03:36 <ReinH> slightSc1pe: Thinking Functionally with Haskell by Richard Bird
15:03:54 <ReinH> is the best book for explaining the concepts of functional programming using haskell
15:04:05 <Cale> There's Graham Hutton's Programming in Haskell, which is a pretty good intro to the language
15:04:37 <slightSc1pe> ReinH: Would you recomend that book before LYAH?
15:04:44 <ReinH> slightSc1pe: I wouldn't recommend LYAH at all.
15:05:01 <slightSc1pe> ReinH: How come? 
15:05:11 <bsmt> haskellbook.com
15:05:27 <ReinH> It lacks exercises, and it is shallow and incomplete.
15:05:28 <bsmt> not finished, but the preview chapters are p good
15:06:15 <ReinH> I don't know of anyone who has finished LYAH and said "Yeah, I think I'm ready to write real programs in Haskell now."
15:06:35 <ReinH> bitemyapp's book looks good (bsmt's link)
15:07:16 <gfixler> I still had to learn a lot of things that were in LYAH after I finished reading LYAH
15:07:34 <gfixler> some I still haven't really gotten in my head a year later
15:07:56 <ReinH> gfixler: I don't think that's uncommon with LYAH :/
15:08:00 <ReinH> So I don't recommend it.
15:08:17 <slightSc1pe> Is bitemyapps stuff on github a book, it looks like small text files. 
15:08:29 <Tuplanolla> I feel like LYaH is more like a tour than a textbook.
15:08:29 <bsmt> no
15:08:30 <ReinH> slightSc1pe: bitemyapps' stuff on github is small text files.
15:08:32 <ReinH> His book is a book.
15:08:46 <gfixler> the only thing that's really worked at all for me for the tougher stuff is just trying to use it for awhile, and asking questions when stumped
15:08:46 <E4xoi> ReinH: if you had previous experience with ocaml, clean and other fps, do you count it?
15:08:51 <bsmt> his github thing is good also, if you like a "choose your own adventure" style
15:08:59 <ReinH> E4xoi: what do you mean?
15:09:13 <E4xoi> for lyah :P
15:09:41 <ReinH> E4xoi: I still can't parse the question, sorry. Count the experience? Count it for what?
15:11:38 <Tuplanolla> Is there a way to detect ambiguous imports without having to use specific symbols? That would help greatly when adding stuff into ~/.ghci.
15:12:13 <kadoban> Anyone know of a RIPEMD-160 implementation in pure haskell? cryptohash doesn't work for me since it's C FFI and I need it to work in GHCJS
15:12:36 <Tritlo> Is there any way to describe to quickCheck the function domain better? I.e., do not use negative integers, only check non empty lists etc.
15:12:48 <ReinH> kadoban: I know most of the crpto in Haskell uses FFI
15:12:51 <ReinH> *crypto
15:13:03 <ReinH> Tritlo: yes, there are newtypes...
15:13:08 <kadoban> Tritlo: Yeah, there's some newtypes that describe that, I forget where they are though. They're in quickcheck for sure though.
15:13:18 <ReinH> Tritlo: e.g., https://hackage.haskell.org/package/QuickCheck-2.8.1/docs/Test-QuickCheck-Modifiers.html
15:13:23 <kadoban> ReinH: Yeah :-/ I only need a couple of hashes. I found SHA256, but not RIPEMD-160 :-/
15:13:51 <Demon_Fox> Which compiler would one need to use for the fastest runtime?
15:14:02 <kadoban> I guess technically I could use a JS implementation, but … that's not really ideal for me, then I can't check it via GHC.
15:14:12 <bsmt> probably the de facto standard and most popular one
15:14:18 <ReinH> kadoban: I am highly dubious about crypto in the browser in any case :/
15:14:25 <Tritlo> ReinH: Alright. Is it possible to define a custom modified? Like, "do not test an empty tree?"
15:14:45 <kadoban> ReinH: Yeah. In my case it's not actually used for a cryptographically secure purpose at all, so it'd be fine. (I know, sounds weird, but it's true)
15:14:52 <ReinH> Tritlo: Yes, look at the source, it will serve as examples.
15:15:01 <ReinH> kadoban: so use SHA1?
15:15:21 <ReinH> or SHA256 if you found one
15:15:29 <kadoban> ReinH: It has to be specific hashes. It's related to bitcoin (it's basically a bitcoin script debugger).
15:15:51 <ReinH> kadoban: Ah. Then you might be SOL.
15:16:12 <kadoban> Worst case I guess I can just find a JS one and figure out how to use that and switch to the C one in GHC.
15:16:17 <ReinH> Demon_Fox: GHC is basically the only Haskell compiler.
15:16:22 <bsmt> RIPEMD shouldn't be much harder to implement than SHA1
15:16:37 <Demon_Fox> ReinH, I'm guessing the rest are interpreters
15:16:39 <kadoban> Naw, it should be pretty easy to implement … but I don't really wanna.
15:16:49 <bsmt> doet
15:17:04 <ReinH> Demon_Fox: There are other compilers, but they are either out of date or proprietary
15:17:18 <bsmt> what are the proprietary haskell compilers?
15:17:32 <kadoban> Plus … I find it kind of morally ambiguous implementing crypto, especially when I know for a fact I don't care if it's secure or not. Then it becomes /super/ dubious releasing it, because someone out there is going to use it, and then … bad news.
15:17:40 <ReinH> bsmt: Haskell compilers that are proprietary.
15:17:48 <ReinH> Standard Chartered has one, for example.
15:18:01 <ReinH> bsmt: oh, "what are the", not "what are", orry
15:18:13 <bsmt> interesting
15:18:33 <ReinH> Demon_Fox: Here's a list, but GHC is the de facto standard and probably fastest as well https://wiki.haskell.org/Implementations
15:19:16 <bsmt> frege could be promising too
15:19:18 <bsmt> if you want to branch out
15:19:23 <Tuplanolla> Keep in mind different backends also perform differently, Demon_Fox.
15:19:30 <cite-reader> kadoban: You can probably do something heinous with Emscripten if you have a lot of time to sink into this.
15:20:18 <kadoban> cite-reader: Heh, that might be an idea if the others don't work. I think I might just look up JS implementations and just have to suck it up and learn how to do JS FFI in GHCJS
15:20:57 <bsmt> on the other hand, a simple hash like ripemd is probably one of the less risky things to do yourself
15:21:42 <bsmt> i mean, if it's serious enough for you to be considering weird side channel vulnerabilities, you need to be getting advice from an expert anyways
15:21:47 <kadoban> Well, there's no risk to me, since it doesn't matter at all for my project if it's secure or not. Maybe I should just do that and put big warnings to everyone not to reuse it.
15:22:03 <Demon_Fox> You could just use crc32
15:22:10 <bsmt> not for what he's doing
15:22:13 <Demon_Fox> It's rather simple to implement
15:22:27 <kadoban> Naw, the hashes I'm using are pre-specified. I need SHA256 and RIPEMD-160.
15:22:44 <bsmt> imo the easiest thing is to just bite the bullet and do it yourself
15:22:53 <bsmt> FFI stuff always leads to tears in my experience
15:23:06 <bsmt> plus you'll learn more :D
15:23:08 <kadoban> Well, the C stuff works great … just not in GHCJS :-/
15:24:47 <jorendorff> lyxia: btw, i'm now convinced you're right! just had to write enough of the code to convince myself...
15:33:40 <Tuplanolla> More generally, are there any import management systems?
15:36:54 <ReinH> import management systems?
15:37:25 <Tuplanolla> I'd like to detect ambiguous imports without having to use specific symbols first. That would help greatly when adding stuff into ~/.ghci.
15:37:40 <Tuplanolla> Organizing imports when they get unwieldy would also be useful sometimes.
15:40:09 <Welkin> Tuplanolla: use the module system
15:40:26 <Welkin> if you frequently have import conflicts, that may be a sign your files are too large
15:41:01 <Welkin> another nice way to avoid that is to use classy-prelude and mono-traversable, which provide generalized versions of the common utilities for String/Text/ByteString
15:44:25 <lyxia> jorendorff: \o/
15:48:06 <Tuplanolla> This classy-prelude seems to be missing lots of things, like Data.Bits, Data.Function and Data.Ord.
15:49:15 <Tuplanolla> I'd still have to put lots of things into ~/.ghci.
15:51:21 <ReinH> Tuplanolla: put things into files instead?
15:51:58 <Tuplanolla> What do you mean?
15:56:24 <ttt_fff> we can do memoization in a pure way
15:56:37 <ttt_fff> however, we can't do memoization with only remembering last 10 items in a pure way, can we ?
15:56:48 <ReinH> Tuplanolla: import things in a file, then load that file
15:56:57 <ReinH> ttt_fff: that isn't memoization
15:57:32 <Tuplanolla> How does that prevent ambiguous imports before I use the symbols or even work conveniently?
15:57:35 <ttt_fff> in haskll, in a pure way, we can do caching where we cache all (arg,value) pairs of a function
15:57:43 <ttt_fff> however we can't do a cache that only remembers the last 10, in a pure way, can we ?
15:57:52 <ReinH> Tuplanolla: You import things in a way that disambiguates
15:58:00 <ReinH> And I guess it's convenient enough to be how everyone uses Haskell
15:58:19 <ReinH> ttt_fff: sure, a list remembers things
15:58:21 <Tuplanolla> For me GHCi is also a calculator and a shell scripting environment.
15:58:27 <Welkin> a list is like an elephant
15:58:40 <ttt_fff> yeah
15:58:43 <ttt_fff> but the the function is no longr pure
15:58:47 <kadoban> ttt_fff: Depends on the definition. And of course you can do it in IO or ST. Even without that … you can do dynamic programming where each value depends on k other previous values, where k is anything you want … or other patterns as well.
15:58:49 <ttt_fff> I want a pure way to do memoization
15:58:58 <monochrom> I too use ghci as a calculator. when I do, I :load Calculator.hs first
15:59:03 <ttt_fff> with lazy tries, we can do memoization in a pure way
15:59:14 <ttt_fff> but if instead of remembering all past arg/value parirs, I only want to remember the last 10, I don't see a pure way to do it
15:59:23 <kadoban> ttt_fff: The usual 'fibs' definition is using memoization, IMO.
15:59:44 * ttt_fff gives up
15:59:44 <monochrom> the benefit is that not only it can import things I want, it also defines extra things I want, such as the ackermann function
16:00:33 <Tuplanolla> How often do you even need that?
16:00:46 <ReinH> That's not the point
16:01:08 <monochrom> I don't need ackermann very often, to be sure
16:01:11 <Tuplanolla> I'd still have to maintain imports the same way I do for ~/.ghci.
16:01:28 <ReinH> Tuplanolla: Yes, you could almost say that you have to "manage" them.
16:01:34 <monochrom> but I need the extended euclidean algorithm more often, and I also have that in my Calculator.hs
16:02:53 <monochrom> I agree I have to maintain my Calculator.hs. but that's misleading wording, as though it eats up 30% of my time or something. no, it's like 5 minutes per year.
16:04:30 <ReinH> You asked for an import management system and your object to "use files" seems to be "but that forces me to manage imports".
16:04:34 <ReinH> *objection
16:05:28 <Tuplanolla> Let's say I import Text.Parsec. I won't know that <|> clashes with something until I load that file into GHCi and try to use it.
16:05:42 <Tuplanolla> That won't change no matter how many files I use.
16:05:57 <ReinH> Yes, you will. Because you will have solved the ambiguity in the file.
16:06:25 <Tuplanolla> Not if I don't use <|> in it.
16:06:25 <ReinH> If two modules export the same identifier then you must at some point make a decision about how to resolve the ambiguity.
16:06:28 <ReinH> Nothiung can do that for you.
16:07:07 <ReinH> So the choice is either do it in an ad hoc way in GHC, do it in a slightly less ad hoc way in .ghci, or do it in a non-ad hoc way in the way the module system was intended to be used: by importing things in files and resolving ambiguities.
16:07:08 <Tuplanolla> Oh, you mean I should reexport those symbols instead. Right.
16:07:19 <monochrom> I tell you what really deserves to be called "need to be maintained"
16:07:59 <monochrom> every week I have to spend 45-60 minutes vacuuming dust in my room
16:08:27 <monochrom> that's like 100000 times more time I need to spend on reviewing my Calculator.hs or my .ghci
16:08:47 <Tuplanolla> You not having this problem isn't helpful, monochrom.
16:08:53 <ReinH> monochrom: your room is dusty.
16:08:56 <monochrom> that is what maintenance means
16:10:25 <Tuplanolla> I guess I can't complain about food either, since someone else is starving.
16:14:06 <lamefun> uhm... is there anything better than Data.Aeson and Data.Yaml for Yaml?
16:14:44 <lamefun> I mean, intended for human use not for network protocols.
16:15:06 <napping> Doesn't PartialTypeSignatures work with InstanceSigs?
16:19:02 <bitemyapp> slightSc1pe: I maintain free and for-pay resources.
16:19:10 <bitemyapp> slightSc1pe: the guide on Github is free stuff, the book is a whole 'nother story.
16:19:16 <bitemyapp> slightSc1pe: haskellbook.com is where the book is located.
16:21:24 <napping> I was reading http://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/ and hoping to abbreviate the InstanceSigs with "Proxy _"
16:26:12 <sm> slightSc1pe: http://learn.hfm.io is another good resource
16:32:39 <isd> So, I have this program: http://pastie.org/private/fm6te9aa5vvbhhknlo77gg
16:33:19 <isd> The file it creates ends up being 256 bytes, no matter how big I make size. If I make size < 256, it makes the file that size. I am confused. Any insights?
16:34:12 <Tuplanolla> You only get [0 .. 255] since that's the maximum range.
16:34:40 <Tuplanolla> Try [0, 0 ..] instead.
16:34:50 <isd> Ah! thanks, that is what I meant.
16:35:20 <isd> works. thanks
16:35:25 <ski> or `repeat 0'
16:35:49 <ski> or, i suppose `replicate size 0' would be more appropriate here
16:53:03 <lamefun> There's Text, is there TrueText?
16:53:04 <haskell359> can someone help me with this error?
16:53:06 <haskell359> GamePart1.hs:4:1:     Failed to load interface for ‘Graphics.UI.GLFW’     Perhaps you meant
16:53:12 <haskell359> here is the code: http://lpaste.net/144775
16:55:52 <c_wraith> lamefun: What would ti be?
16:56:27 <lamefun> IDK, something bloated probably.
16:56:51 <lamefun> Eg. there are characters that combine with the other, so both count as 1 character in text editors.
16:57:24 <haskell359> can someone help me with this error?
16:57:54 <Tuplanolla> Have you installed Gloss, haskell359?
16:58:39 <glguy> Graphics.UI.GLFW isn't from gloss, it's from GLFW-b
16:59:06 <Tuplanolla> Well, that then.
16:59:14 <napping> glguy: is your "gl" the same as in GLFW?
16:59:23 <glguy> no
16:59:36 <glguy> I'm case sensitive
17:01:08 <napping> haskell359: from those two lines it sounds like some kind of package installation or build system thing - how are you trying to compile that?
17:05:29 <haskell359> through ghci
17:05:35 <haskell359> :l filename
17:12:13 <napping> haskell359: sorry, got distracted here. Ok, what's the error message then?
17:14:16 <napping> hmm, I'm not sure GL stuff works properly in ghci
17:14:25 <napping> It's been quite a while since I tried, but I had a lot of trouble
17:16:07 <fayong> I am thinking about buying "Haskell Designs Patterns" by Lemmer
17:16:20 <fayong> does anyone know if it is good?
17:22:50 <ReinH> fayong: Packt is often trash, not sure about that book
17:24:02 <ReinH> Without a free sample or even a table of contents, it's hard to say
17:25:54 <ReinH> I've never heard of the author and he doesn't have any projects on github or packages on package as far as I can tell
17:25:57 <ReinH> so *shrug*
17:26:05 <ReinH> *on hackage
17:34:30 <AbelianGrape> I'm looking for a version of "alternative", except "empty :: a -> f a"
17:34:36 <AbelianGrape> That is to say, you must provide the "a" value
17:34:53 <AbelianGrape> Whereas alternative assumes you have some sort of identity object already
17:35:09 <athan> AbelianGrape: I think you're looking for `pure`
17:35:18 <napping> is that supposed to be a different "a -> f a" than pure?
17:35:35 <AbelianGrape> athan, napping I mean to say that it is *impossible* to implement Alternative's "empty"
17:35:43 <AbelianGrape> Therefore it's not an alternative
17:36:05 <AbelianGrape> I can implement pure just fine, but I need a semigroup operator like <|>
17:36:13 <AbelianGrape> and I can use semigroups, but then I lose <|>
17:36:14 <athan> :s
17:36:20 <AbelianGrape> I guess I could do semigroup + applicative...
17:37:42 <kadoban> semigroup and applicative sounds right to me. In general you can't say that it /can't/ be an instance of Alternative, AFAIK. Maybe with extensions (though I doubt it … I think that breaks fundamental ideas of how typeclasses work).
17:37:45 <fayong> ReinH: there is a free sample there: http://www.slideshare.net/PacktPub/haskell-design-patterns-sample-chapter  
17:38:20 <AbelianGrape> kadoban: I mean that it is impossible to imlement correctly, because there is no constructor that doesn't require an "a" value
17:38:32 <AbelianGrape> I don't need to restrict people from making an instance :)
17:39:09 <kadoban> Okay, just checking.
17:39:12 <AbelianGrape> Alternative assumes there is some sort of empty constructor
17:39:31 <ReinH> fayong: I don't like it
17:40:15 <ReinH> It doesn't even make it through recursion without being incorrect.
17:40:40 <bitemyapp> ReinH: wow.
17:40:51 <ReinH> It basically claims that foldl uses constant space as if it were foldl'
17:41:05 <bitemyapp> yeeeugh
17:41:32 <ReinH> Well, that's exactly what it claims, except it uses explicit recursion rather than foldl
17:42:11 <napping> AbelianGrape: I don't know anything defining a semigroup version of Alternative
17:42:37 <napping> How are you hoping for it to interact with the applicative structure?
17:42:43 <ReinH> It also makes weird statements like "the `length` object" in reference to the *function* length.
17:43:45 <ReinH> Holy crap
17:44:12 <ReinH> bitemyapp: It claims that sum types are an example of ad hoc polymorphism
17:44:15 <ReinH> This book is awful
17:44:49 <AbelianGrape> napping: I actually didn't even want Applicative support. Basically, I'm making "Terminal x", which is just a container for x values. The relevant property is that when "Terminal x" values are combined using "<>", the rightmost terminal value subsumes all other values. If there is no terminal value, the leftmost value is the one that comes out.
17:45:11 <AbelianGrape> It's pretty much exactly the same as "Either x x" under ">>"
17:45:13 <ReinH> bitemyapp: it claims that a mapMaybe f (Just x) = Just (f x); mapMaybe f Nothing = Nothing is an example of ad hoc polymorphism
17:45:26 <ReinH> Note that I don't mean fmap. I mean mapMaybe.
17:45:29 <fayong> ReinH: Ok thank you :)
17:45:45 <napping> wow
17:45:56 <ReinH> Yep, Packt once again releases another crap book with no technical review.
17:46:06 <AbelianGrape> lol
17:46:20 <E4xoi> how is... that... ad-hoc polymorphism?
17:46:42 <napping> semigroup sounds like plenty then
17:46:57 <AbelianGrape> napping: Yeah, that's what I'm using
17:47:00 <E4xoi> I don't even see how any relation between the concept of ad-hoc polymorphism and that function could arise 
17:47:06 <napping> unless you want to work with some libraries or something
17:47:50 <ReinH> Wow. This book is so bad.
17:48:27 <ReinH> It provides an example of the Strategy Pattern from GoF in Haskell that is nothing at all like the Strategy Pattern
17:48:39 <ReinH> And the whole point of this book is apparently to translate GoF patterns to Haskell
17:48:44 <ReinH> you'd think they'd get the first one right
17:49:08 <ski> what book is that ?
17:49:10 <E4xoi> where's the link to that book?
17:49:10 <ReinH> The function it defines isn't even valid. It gets the names of arguments wrong in the body.
17:49:18 <ReinH> http://www.slideshare.net/PacktPub/haskell-design-patterns-sample-chapter
17:49:29 <ReinH> This is what I've come to expect from Packt
17:49:39 <E4xoi> maybe it's a satire? I mean, it doesn't make sense otherwise
17:49:51 <ReinH> It's definitely not a satire. It's just wrong.
17:50:19 <napping> trying to transliterate design patterns is going too far
17:50:44 <AbelianGrape> Did he give an explanation of how monads are like burritos?
17:50:51 <E4xoi> ReinH: (btw, answering the earlier question, "what if you went through LYAH as a way to know Haskell's syntax and its way to deal with certain kinds of patterns you are already familiar with?" :P 
17:51:31 <E4xoi> add a closing ) or remove the first (
17:51:46 <ReinH> E4xoi: I mean, I guess, but I don't know why you would.
17:52:12 <ReinH> napping: I mean, I disagree with the entire premise of the book. But they could at least write examples that parse.
17:53:30 <fayong> that book is on amazon there: http://www.amazon.com/gp/product/178398872X?keywords=haskell%20design%20patternws&qid=1446861165&ref_=sr_1_sc_1&sr=8-1-spell
17:53:53 <bitemyapp> ReinH: tf tf tf
17:53:55 <bitemyapp> ReinH: TF
17:53:58 <bitemyapp> ReinH: tffffffffffffffff
17:54:10 <ReinH> bitemyapp: yeah
17:54:11 <fayong> there is no reviews yet, that's why I thought about asking you guys 
17:54:15 <ReinH> Packt is complete garbage.
17:54:28 <lamefun> Does 'where' work in case cases?
17:54:43 <ReinH> If there's a good Packt book, it's because the author is able to write a good book entirely on their own without any support or techincal review or editing.
17:55:01 <napping> ReinH: Packt is not some kind of self-publishing service?
17:55:12 <ReinH> napping: No, it purports to be a usual publisher.
17:55:27 <ReinH> But they obviously don't do TR and I've heard horror stories about people they approached to write for them.
17:55:47 <E4xoi> I am scared by that book
17:55:58 <ReinH> I seriously hope no one reads that boko.
17:56:00 <ReinH> *book
17:56:48 <napping> I mean, the basic idea of design patterns is to convey reusable solutions to common problems under your local constraints
17:57:01 <napping> going from an OO language to a functional language is such a change in "local constraints"
17:57:16 <ReinH> bitemyapp: Even the not obviously incorrect examples are awful style in a book that purports to be a guide to idiomatic Haskell https://www.dropbox.com/s/2yeqtj6rnlzrtj2/Screenshot%202015-11-06%2017.56.34.png?dl=0
17:57:34 <ReinH> Just use a record, jesus.
17:58:10 <napping> ReinH: I don't think there's any point to continuing to read
17:58:29 <ReinH> The writing is terrible too
17:59:16 <ReinH> napping: try to parse this sentence https://www.dropbox.com/s/1cxiucfr1ft875e/Screenshot%202015-11-06%2017.58.38.png?dl=0
17:59:26 <ReinH> See what I mean about no editing?
18:00:39 <bitemyapp> ReinH: tf
18:00:45 <bitemyapp> ReinH: IO a -> a????
18:01:32 <ReinH> bitemyapp: Oh, right, also that.
18:01:36 <ReinH> I didn't even notice.
18:01:37 <E4xoi> I am ok with IO a -> a there, what if a ~ IO b? it'd be just join!
18:01:38 <ReinH> lmao
18:02:03 <E4xoi> @type join :: (a ~ IO b) => IO a -> a
18:02:05 <lambdabot> IO (IO b) -> IO b
18:02:40 * ski notes this type class has no parameters
18:03:01 <ReinH> ski: Its purpose is to provide the one canonical way to setup and teardown the type
18:03:04 <E4xoi> anyway, that class would be missing the type parameter
18:03:11 <ReinH> Because of course there could only be one possible way you would want to do that
18:03:18 <napping> ReinH: it parses okay with error correction
18:03:21 <ReinH> There couldn't be two or more.
18:03:35 <ReinH> napping: Yes, but that's my point. Error correction should have been done by Packt's editor.
18:03:43 <napping> "enables"/"has the profound effect of enabling" were obviously two versions
18:03:56 <ski> (so it's really `setup :: TemplateAlgorithm => forall a. IO a -> a' (swapped order for emphasis), not `setup :: forall a. TemplateAlgorithm a => IO a -> a')
18:04:45 <ski> ReinH : which type ?
18:04:48 <ReinH> Jesus christ, I think there's a grammar or spelling error in aobut 20% of sentence.
18:05:03 <ReinH> ski: oh god.
18:05:07 <ReinH> ski: OH MY GOD
18:05:14 <ReinH> *about 20% of sentences
18:05:43 <ReinH> I wish I could write a review on Amazon
18:06:57 <napping> can't you?
18:07:43 <ReinH> No, apparently it isn't released on Amazon yet.
18:08:25 <E4xoi> I am still checking for some `this is a satire` label
18:08:29 <E4xoi> it must be somewhere
18:09:05 <ReinH> fayong: TL;DR: Yeah don't buy that book.
18:09:20 <fayong> it is released and reviewable on amazon usa apparently
18:09:43 <fayong> @ReinH I won't, thank you for your help
18:09:43 <lambdabot> Unknown command, try @list
18:09:52 <ReinH> fayong: Not at http://www.amazon.com/Haskell-Design-Patterns-Ryan-Lemmer-ebook/dp/B0148S9GRM
18:10:04 <fayong> ReinH: I won't buy it, thank you for your help
18:10:09 <ReinH> Oh the paperback.
18:10:11 <ski> ReinH : re ad-hoc sum types, which page ?
18:12:27 <ReinH> ski: 15, "Alternatiion-based ad-hoc polymorphism"
18:13:31 <ski> hm. whence came "Alternation-based" ?
18:16:12 <ReinH> ski: That's apparently his name for sum types.
18:16:25 <ReinH> The writing is poor enough that it's hard to say for sure
18:16:54 <ReinH> but the claim that fMaybe is an example of ad-hoc polymorphism seems clear enough
18:16:58 <polyzen> if i'm running `cabal build` and i'm getting a bunch of "Warning: Tab character" errors. is that okay?
18:17:09 <polyzen> s/\./,/
18:17:37 <ReinH> polyzen: Maybe, but it's easy to have indention errors if you use tabs so it's best to use only spaces.
18:18:24 <nshepperd> that typeclass definition there looks like a confused attempt to write a OO 'class'
18:21:21 <ReinH> Well, I left my review, but I can't see the text
18:23:24 <polyzen> ReinH, thank you
18:29:28 <fayong> ReinH: can't see the text either
18:30:08 <fayong> maybe it's moderated
18:30:49 <ReinH> fayong: can you see https://www.amazon.com/review/R1NR8PBX9VP99E/ref=pe_1098610_137716200_cm_rv_eml_rv0_rv ?
18:31:09 * hackagebot path-extra 0.0.0 - Chris Done's path library, enriched with URL-related goodies.  https://hackage.haskell.org/package/path-extra-0.0.0 (athanclark)
18:32:19 <Hijiri> ReinH: I can see it
18:32:49 <ReinH> cool
18:36:10 <fayong> I can see it too noz
18:36:20 <fayong> *now
18:48:41 <Big_G> Does anyone know if any group / progress came out of the spark discussion on the mailing list a while back?
19:08:35 <skatenerd> anybody want to help me with a yak shave
19:08:53 <skatenerd> :-)
19:10:51 <skatenerd> it could be...fun...or something
19:11:08 <c_wraith> I recommend #5 shears
19:11:49 <skatenerd> the thing about computer yak shaves
19:12:00 <skatenerd> is that you dont know if you're going in the right direction.
19:12:02 <skatenerd> with a real yak shave
19:12:06 <skatenerd> you like, can see the hair
19:12:16 <skatenerd> you can see progress as you make it
19:12:22 <skatenerd> it could conceivably be soothing work
19:12:32 <skatenerd> computer yak shaves tho
19:12:34 <skatenerd> it's like
19:12:46 <skatenerd> you fumble in the dark until bam, the yak is suddenly hairless
19:13:34 <zzing> Why is Functor under Data and Applicative under Control?
19:16:10 * hackagebot path-extra 0.0.1 - Chris Done's path library, enriched with URL-related goodies.  https://hackage.haskell.org/package/path-extra-0.0.1 (athanclark)
19:18:31 <skatenerd> Anyway if you want to feel like gouging your eyes out
19:18:39 <skatenerd> https://github.com/bitc/hdevtools/issues/43
19:28:55 <monochrom> vocabulary check: does "strongly normalizing" mean that all reduction paths lead to the same normal form?
19:34:58 <monochrom> I guess not. I need to add confluence. (fortunately, my rewriting system has confluence, too)
19:36:52 <monochrom> my rewriting system comes from this: McCafe sells coffee/tea with stamps, each cup comes with a stamp. you can collect stamps and redeem 7 stamps for 1 cup, which also comes with 1 stamp so you can collect and redeem moar.
19:39:41 <skatenerd> wait what's happening right now
19:39:58 <skatenerd> i'm confused
19:40:07 <monochrom> assume the price for each cup is $1. (renormalize currency to make it so. also stick to one kind of drink and one size so the price is constant.) use the following tuple as your state or term: (how many dollars you still have, how many stamps you have, how many cups of coffee you have drunk)
19:40:47 <monochrom> then the transition goes like (m+1, s, d) -> (m, s+1, d+1) and (m, s+7, d) -> (m, s+1, d+1)
19:41:25 <monochrom> this rewriting system is strongly normalizing and confluent. normal forms look like (0, a number >=0 and <= 6, d)
19:41:26 <glguy> Is your goal to have no money, fewer than 7 stamps, and a caffine high?
19:41:32 <monochrom> yes :)
19:43:30 <monochrom> intuitively we feel that it ought to be confluent and strongly normalizing by thinking of real dollars and stamps. but I wanted to prove it just using arithmetic, not real-world interpretation. (I got it to work.)
19:44:59 <skatenerd> neat
19:47:42 <monochrom> confluence is a big deal to me because we can write various programs to simulate this in various different orders. especially, if you start with m dollars (and 0 stamps, 0 coffee drunk yet), you can first turn all m dollars to m cups plus m stamps first, then keep redeeming the stamps and accumulating coffee. (the road of redemption!)
19:48:24 <sleblanc> monochrom, but you could end up with 3 coffees to drink at the same time, right?
19:48:47 <sleblanc> (or actually "m" cups)
19:48:52 <kadoban> Anyone have good resources to point me towards about FFI, especially JS FFI in GHCJS? I … don't really understand what the hell it means, how it use it, etc.
19:49:32 <monochrom> but here is another way. you can first turn m-1 dollars into (x cups, y stamps), then use the last $1 to add one more cup and one more stamp, then do adjustments.
19:49:42 <greymalkin> grr... ever since installing nix, I can't get zlib (haskell) to find zlib (system). Even though there are headers and libraries in both arch and nix.
19:50:25 <sleblanc> monochrom, wow, I'm thinking it could be used as a DSL for example in load balancing
19:50:48 <monochrom> so those are two ways to simulate the thing. (and there are many others.) how do I prove that they all give the same answer? eventually I realized that I should prove confluence as the middleman. then it is easy to bridge each simulation method as implementing a particular order.
19:53:44 <monochrom> for example the first simulation just uses the path (m, 0, 0) ->...-> (0, m, m) ->...-> normal form. the second simulation just uses the path (m, 0, 0) ->...-> (1, x, y) ->...-> normal form.
19:54:01 <monochrom> then confluence says that they end in the same final state
19:55:25 * ski notes this could be a situation where one could use `promise_equivalent_solutions' in Mercury
19:55:42 <monochrom> I was doing this because earlier today my friends posed the following even harder question: (again assume $1 per bottle of beer)  redeem 2 empty cap-less bottles for 1 beer; the caps are useful too, redeem 4 caps for 1 beer.
19:55:45 <KaneTW> in servant, can you distribute over :<|>? i.e. do something like "user" :<|> ( "self" :> Get '[JSON] User, Capture "id" UserId :> Get '[JSON] User) for /user/self and /user/:id
20:02:26 <sleblanc> readDirStream :: DirStream -> FilePath; returns a new path each time it is applied on the same "ds" value until it reaches the end, when it returns "" repeatedly. How can I apply a function on all FilePath values until a certain value, such as ""?
20:03:24 <sleblanc> right now I have mapM (\ds -> readDirStream ds >>= putStrLn) $ repeat ds; but it never stops
20:09:35 <harwiltz> Hello all. I am making a file manager, and I want the files that I open with it to be decoupled from the terminal (which runs my file manager) meaning I can close my file manager terminal without closing the file that I opened. The only issue is that this breaks when opening a file that uses the terminal, such as a source file in vim. In that case, I would have to wait for the process to terminate. Is there
20:09:37 <harwiltz> a way to deal with this?
20:11:22 <ski> harwiltz : maybe use GNU Screen or something .. but i'm not sure how this has to do with Haskell
20:11:39 <harwiltz> ´ski, alright, I'll look into it. Thanks.
20:13:06 <harwiltz> ski, I think this just might be the solution! Now to figure out how to use it ;)
20:17:59 <harwiltz> ski, I don't think it can actually work unfortunately :( Thanks anyway
20:20:08 <sleblanc> harwiltz, you could make your file manager "re-entrant", i.e. give a special option that makes your file manager run after a certain program is executed, and when you want to open a new file you execve your own file manager + the program that should open the file
20:20:44 <sleblanc> harwiltz, to me it is similar to how XMonad can restart
20:21:32 <harwiltz> sleblanc, sounds cool, but how can that actually be done?
20:26:20 <sleblanc> in POSIX there is "execve", a call that replaces the current process with a new process + arguments
20:27:01 <sleblanc> to run the file manager you fork+execve and wait on the thread in the original process
20:28:04 <harwiltz> sleblanc, so I'm using the System.Posix.Process library. I'm going to be calling the executeFile function (which looks like execve), but how does fork come into play?
20:30:14 <sleblanc> say, your file manager wants to open a file in VIM, you executeFile it, but you want to return to the file manager when it's done, but still want to be able to handle the file manager; you can run execve in a new thread (i.e. fork before) and simply wait on the thread to resume after the new process ends
20:31:44 <harwiltz> sleblanc, I see. I just got executeFile to open the file in vim, and then of course the file manager closed after I quit vim. So do I use the forkProcess function from System.Posix.Process?
20:32:26 <sleblanc> harwiltz, I'm not exactly sure of the mechanics, but it could work
20:33:34 <harwiltz> sleblanc, Thanks. The only thing is, the forkProcess function takes an IO action as a parameter. Do you know where I would get that IO action from?
20:34:24 <sleblanc> harwiltz, my intuition is that the IO action you give is what the forked process will run
20:35:13 <harwiltz> sleblanc, I see, so it would be the executeFile call?
20:35:15 <sleblanc> you could probably just pass it $ do { executeFile … }
20:35:27 <harwiltz> sleblanc, thank you very much.
20:37:22 <sleblanc> you are welcome; if you hit anything, I can help you
20:38:44 <harwiltz> sleblanc, Thanks a lot. I'm actually gonna get to sleep now, but unfortunately it's not working, vim and my file manager just become 'intertwined' and it gets real messy. I appreciate the help though. By any chance, do you know if there's a way to tell if a program is run in the terminal?
20:39:03 <harwiltz> A way to tell using haskell, I mean
20:39:55 <sleblanc> harwiltz, no, you cannot really tell. There are some obvious clues, like with LDD you can see if an app links to X/gtk/etc. but dynamically-loaded library won't show up and an app could be both too (e.g. VLC)
20:40:06 <sleblanc> harwiltz, what are you trying to achieve?
20:41:47 <sleblanc> harwiltz, same as in Windows, where there is no way to tell if an app will spawn a window or if it will instead just appear in the system tray
20:41:50 <harwiltz> sleblanc, well if there was a way to tell, I can call the function callProcess on terminal applications. callProcess waits for a process to terminate, do it doesn't interfere with my file manager when vim is running. And if it isn't a terminal application, I can call spawnProcess, which doesn't wait for the application to finish, so that way I can use the file manager (or close it) without affecting the
20:41:52 <harwiltz> external file
20:42:47 <zzing> Does anyone know why lines from Data.Conduit.Text would limit line length to 2048?
20:42:59 <sleblanc> harwiltz, if I used your file manager, I would expect that if a file opens in gedit, its terminal output would go in the same terminal as the file manager, so I'd prefer it to wait until gedit quits
20:43:02 <harwiltz> Because the problem is that the terminal applications run 'on top' of my file manager, so I can't decouple those. But I particularly want to decouple the ones that don't open in terminal
20:43:49 <harwiltz> sleblanc, Really? I find it very frustrating when using midnight commander, for example, that I have to keep it open and can't open multiple files in one go
20:43:51 <sleblanc> harwiltz, why would you? IMO this would give inconsistent behavior to your FM
20:44:05 <sleblanc> harwiltz, now, that's something else
20:44:15 <harwiltz> sleblanc, what do you mean?
20:44:31 <sleblanc> harwiltz, you could provide two different "open" features: one that opens it in a child fork, the other that disowns the process
20:44:49 <sleblanc> what you are describing is "disowning" a process, that is the parent process is allowed to quit without the child dying
20:45:04 <harwiltz> sleblanc, that's what I was just thinking. But ranger, another file manager, can do it automatically
20:45:20 <sleblanc> harwiltz, I suspect it has hard-coded lists of programs
20:46:16 <harwiltz> sleblanc, that's the conclusion I was just coming to. Well, I guess I'll give the user a choice of the two open options. Thank you so much for the help.
20:49:31 <harwiltz> Goodnight all. Thank you sbleblanc, you've been very helpful.
20:49:48 <sleblanc> harwiltz, welcome, good night
21:56:14 * hackagebot bson 0.3.2 - BSON documents are JSON-like objects with a standard binary  encoding.  https://hackage.haskell.org/package/bson-0.3.2 (VictorDenisov)
22:00:32 <zzing> If I have a conduit of Text separated into lines, and I need to do something special with the first line that must be then paired with the lines afterwards, what would be the best way of doing this?
22:25:53 <homovitruvius> I'm sure it is stupid, but how can I dispatch on the exception type using Control.Exception.catch (or otherwise)? I'd like to handle ExitSuccess specially
22:27:36 <zzing> homovitruvius, write a function that pattern matches on e?
22:50:22 <lyxia> zzing: isn't that the purpose of ResumableSource?
22:50:58 <zzing> lyxia, I was thinking about that. I just ran across another way that should work. I found a blog post that uses isolate: http://www.yesodweb.com/blog/2013/10/core-flaw-pipes-conduit
22:52:11 <lyxia> perhaps even a single await is sufficient
22:53:14 <zzing> Its possible, but getting the value into the next function is not entirely clear. So I am going to try this way, and if it works great - otherwise it will worth another question here.
23:00:02 <lpaste_> glguy pasted “conduit answer?” at http://lpaste.net/144779
23:00:33 <glguy> zzing: How about that?
23:01:12 <zzing> glguy, I could see this working
23:01:37 <zzing> Not sure how for_ works precisely
23:01:49 <zzing> But don't the _ functions drop their output?
23:02:16 <glguy> replace that with :   case mb of Nothing -> return (); Just x -> awaitForever ....
23:02:19 <glguy> same thing
23:02:33 <zzing> glguy, you have given me an idea of how I can improve my design :-)
23:02:51 <glguy> *Demo Data.Conduit.List> runConduit (sourceList [1..10] =$= demo =$= consume)
23:02:51 <glguy> [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10)]
23:03:03 <glguy> That's the most conduit code I've written, so it's possible there's a better way
23:03:21 <zzing> I am producing Header values in the first row, and the rest have to be coupled with the rest. 
23:03:26 <zzing> glguy, you picked it up that quickly?
23:04:20 <glguy> There's a bunch of stream processing libraries, they all have the same high-level pattern
23:04:36 <glguy> the rest is just matching up types
23:04:48 <zzing> One thing I am having trouble with is attoparsec's sepBy just stopping on failure, but not reporting failure - just returning good up until the error
23:05:49 <glguy> Either use parseOnly or parse an endOfFile
23:06:08 <glguy> Oh, parsec calls it: endOfInput
23:06:32 <zzing> I am using parseOnly
23:06:50 <zzing> parseOnly headings
23:06:55 <glguy> OK, you'll still need the endOfInput
23:07:05 <glguy> parseOnly just handles the fact that no more chunks are coming
23:07:11 <glguy> This function does not force a parser to consume all of its input. Instead, any residual input will be discarded. To force a parser to consume all of its input, use something like this:
23:07:21 <zzing> okay
23:07:27 <zzing> okay, that is fair. 
23:11:15 <homovitruvius> zzing: I've tried but the handler passed to Control.Exxception.catch gets an expression of type SomeExpression and I've not been able to go from ExitSuccess to SomeExpression
23:12:34 <zzing> homovitruvius, unfortunately I don't know anything specific about exceptions
23:14:22 <glguy_> Catch can catch any exception type
23:16:17 <homovitruvius> glguy: I can catch it just fine, I just cannot pattern match in order to have different behaviour for ExitSuccess and other exceptions. 
23:17:54 <glguy> Catch it as the type you wanted, not SomeException
23:19:33 <lpaste_> glguy pasted “catching exitsuccess” at http://lpaste.net/144780
23:23:53 <homovitruvius> glguy: thanks, I had a function wrapping catch that had the type SoemException while it should have had a constrained w/ (Exception a)
23:23:58 <lpaste_> glguy annotated “catching exitsuccess” with “alternative” at http://lpaste.net/144780#a144781
23:24:26 <glguy> SomeException is the catch-all type
23:25:30 <glguy> fromException :: Exception e => SomeException -> Maybe e
23:25:47 <glguy> You can use that to attempt to extract a particular exception type from a SomeException
23:27:18 <zzing> glguy, I think I can use your method to make a single conduit and avoid complexity :-)
23:35:28 <zzing> Is there any syntax reason to require the keyword let inside of do notation for binding?
23:38:55 <mniip> question
23:39:12 <mniip> :t catch
23:39:14 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
23:40:07 <mniip> this function determines whether two types (the thrown and the caught exceptions) are the same or not,
23:40:14 <mniip> how come it has a uniform definition over e
23:51:18 * hackagebot wai-cors 0.2.4 - CORS for WAI  https://hackage.haskell.org/package/wai-cors-0.2.4 (larsk)
23:55:09 <ski> mniip : not sure what you're asking ..
23:55:30 <mniip> me neither actually
23:55:37 <ski> mniip : .. but `catch' only catches exceptions of type `e' there
23:55:48 <mniip> i think the question is, how does 'catch' establish that two exception types are differnt
23:56:03 <ski> which two exception types ?
23:56:15 <mniip> the caught and the thrown one
23:56:34 <ski> why would it need to "establish that two exception types are differnt" ?
23:56:44 <ski> (whatever that means)
23:56:59 <mniip> it has to know whether to call the handler or to relay the exception further
23:57:15 <ski> if they are the same, the exception is caught. if not, it's not caught
23:57:16 <u-ou> it just runs the function with the thrown exception as its input (if thrown)
23:58:15 <mniip> ski, how does it knooooooow
23:58:17 <ski> `Typeable' is a superclass of `Exception'
23:59:04 <mniip> u-ou, that was not helpful at all
23:59:29 <mniip> ski, aha, so it only works on monomorphic types?
