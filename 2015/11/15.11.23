00:07:41 * hackagebot git-fmt 0.2.2.0 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.2.2.0 (hjwylde)
00:07:41 * hackagebot bloodhound 0.10.0.0 - ElasticSearch client library for Haskell  https://hackage.haskell.org/package/bloodhound-0.10.0.0 (bitemyapp)
00:34:34 <jgcoded> Hello, I'm getting some really nasty ambiguity errors from ghc. I'm trying to use Parsec's language definition record: http://lpaste.net/145823
00:35:09 <stobix> Is there a nice way to see which classes a type has been instatiated to?
00:35:46 <jle`> stobix: ghci, :i
00:35:53 <stobix> jle`: thanks
00:36:07 <jle`> jgcoded: what are the errors?
00:36:09 <jle`> stobix: np :)
00:37:01 <jgcoded> this is the first 3 lines of the 100 lines monster I'm getting: No instance for (Text.Parsec.Prim.Stream s0 m0 Char)       arising from a use of ‘C.letter’     The type variables ‘s0’, ‘m0’ are ambiguous
00:38:50 * stobix is trying to understand read and friends. Why would ⟪read "3"⟫ give parse errors?
00:39:15 <shachaf> What is its type?
00:39:23 <kadoban> > read "3" :: Int
00:39:26 <lambdabot>  3
00:39:32 <stobix> ah
00:40:01 <kadoban> > read "3" :: [Int]
00:40:03 <lambdabot>  *Exception: Prelude.read: no parse
00:40:31 <kadoban> Was trying to think of a better type that should obviously fail … nothing comes to mind though, haha. But yeah, does that explain it at all?
00:40:47 <stobix> Put simply, we need several sets of numbers, each of which belong to a different number type. ;)
00:41:11 <stobix> kadoban: I got it at the :: Int :)
00:41:17 <kadoban> Ah okay :)
00:42:47 <stobix> Heh. I wonder if I could do something in the lines of <japanese character for the value one> = 1 :: Int, <thaiwanese character for the value one> = 1 :: Float ...
00:43:05 <jle`> anyone know how i can get my natAddition :: (KnownNat a, KnownNat b) => Dict (KnownNat (a + b)) to work hehe
00:43:23 <jle`> when natAddition = undefined, i get that i can't match type (a + b) with (a0 + b0)
00:44:25 <kadoban> stobix: Well, you probably can … but you probably shouldn't. (also, don't they share a character for that?)
00:44:44 <kadoban> stobix: What are you tempted to use that for?
00:45:37 <stobix> kadoban: Not really tempted (strangely enough), but it might save a type casting from time to time. Not that those are in abundance anyways.
00:46:16 <jle`> alternatively, can someone show me why my desired natAddition :: (KnownNat a, KnownNat b) => Dict (KnownNat (a -> b)) is fundamentally impossible?
00:46:25 <jle`> data Dict :: Constraint -> * where Dict :: c => Dict c
00:46:27 <stobix> kadoban: you would've loved the code in which I used Big Greek Letter Sigma as part of a type, and Mathematical Operator Sigma as an operator over the type. ;)
00:46:48 <jle`> er, *KnownNat (a + b)
00:47:13 <hftf> @pl list n (MetaList l) = l !! n
00:47:14 <lambdabot> (line 1, column 22):
00:47:14 <lambdabot> unexpected " "
00:47:14 <lambdabot> expecting operator
00:47:36 <kadoban> stobix: Heh
00:48:02 <jle`> hftf: if you have a constructor w/out some function to access/extract, it's kind of impossible to make it point free heh
00:48:11 <hftf> Ohk
00:48:21 <stobix> kadoban: I actually don't know if the thai and japanese number glyphs are distinct. I do know, however, that I probably could muster up at least two distinct number glyphs for each number from the japanese glyph set alone.
00:48:24 <jle`> because you have to pattern match on the constructor at least
00:48:30 <hftf> jle` How do I know if i have an accessor
00:49:10 <kadoban> stobix: Yeah I wouldn't be surprised. I know there's the weird ones they use for checks at least.
00:49:14 <stobix> (normal number set vs grandiose old manically insanely huge ceremonial number set)
00:49:15 <jle`> if you look on the haddocks, it should tell you if it exports a record accessor, or look for a function that is defined like foo (MetaList l) = l or something
00:49:39 <jle`> then you would want to pl \n ml -> getMetaList l !! n
00:49:43 <hftf> i have https://github.com/jgm/pandoc-types/blob/master/Text/Pandoc/Definition.hs#L90
00:49:54 <hftf> i assume no accessor
00:50:07 <jle`> none from record syntax at least, but you could probably write one
00:50:16 <jle`> your `list` function is partial anyways, so it might not be a good idea to make it point free :p
00:50:20 <hftf> so I guess the lesson is without an accessor, I _have_ to use matching
00:50:25 <stobix> ah, yeah, the check one as well. I don't know if all of those are distinct from the regular ones, though. Might be; IIRC, the point of it is that you should not be able to simply add a line to get from a character to the next. Which is kinda smart.
00:50:28 <jle`> well, you can write your own accessing function
00:50:32 <hftf> right
00:50:36 <stobix> kadoban: --^
00:50:56 <kadoban> stobix: Yeah they might not all be
00:52:37 <stobix> kadoban: heh. apparently, their "0" is still bat shit insanely complicated even in the regular system.
00:53:35 <monochrom> like this? 零
00:54:08 <stobix> yeah
00:54:19 <Rembane> Is it used in the same way as the arabic one?
00:54:52 <stobix> Rembane: nah, since they have symbols for "100", "1000", "10000" among others, "0" rarely needs to be used explicitly
00:55:37 <hftf> and they also explicitly write out 1's digits when using financial numerals
00:56:03 <Rembane> stobix: Ah. Then it is quite alright to have a complicated zero.
00:56:15 <hftf> if you write 1000 using just the 1000 character, then you can sneakily add a digit in front of it
00:56:30 <quchen_> What about 1200?
00:56:42 <quchen_> Is it really a concatenation of number-words and digits?
00:56:48 <hftf> wouldn't that be written 1 1000 2 100
00:57:08 * frerich thinks the new features in GHC 8.0.1 sound really exciting. Proxy is not needed anymore?!
00:57:32 <stobix> quchen_: IIRC, 1 thousand 2 hundred
00:57:51 <stobix> quchen_: like it is spoken, in other words. ;)
00:58:43 <stobix> quchen_: 300000000 is written as 3 "oku".
00:59:06 <stobix> quchen_: One of those formats I can easily parse. ;)
01:01:25 <Xandaros> The only thing making understanding japanese (well, most east-asian) numbers difficult for me is that they use blocks of four instead of three
01:01:50 <Xandaros> ...and I just realised this is not -blah... you guys... :D
01:02:13 <hftf> yeah we should all just use the same block sizes
01:02:19 <hftf> lets go metric, blocks of 10
01:02:54 <Rembane> I was just wondering for how long you would be speaking about numbers in the channel without the -blah-suffix. :D
01:03:27 <stobix> Xandaros: heh. Yeah, I kinda started to get hesitant about continuing chatting... :)
01:04:18 <stobix> Xandaros: also, having a distinct word for 10000 is kinda cool. :)
01:04:45 * stobix now has learned about #haskell-blah
01:06:52 <jle`> omg i just made a natAdd :: Proxy n -> Proxy m -> (forall n' m'. KnownNat (n' + m') => Proxy n' -> Proxy m
01:06:59 <jle`> ' -> a) -> a
01:07:02 <jle`> i feel so evil ;_;
01:07:10 <varaindemian> why f (g (z x)) is equivalent to (f . g . z) x? wasn't suppose to be equivalent to  f.g.z x?
01:07:54 <Xandaros> jle`: What does that even do?
01:08:15 <Xandaros> varaindemian: Application binds strongest, so f.g.z x === f.g.(z x)
01:08:40 <jle`> varaindemian: f (g (z x)) = f ( (g . z) x) = (f . (g . z)) x = (f . g . z) x
01:08:46 <jle`> sort of relies on the fact that (.) is associative
01:08:59 <jle`> er wait, unless the fixity works out that way
01:09:32 <jle`> varaindemian: or to go backwards, (f . (g . z)) x = f ((g . z) x) = f (g (z x))
01:10:17 <jle`> Xandaros: given KnownNat n and KnownNat m, gives you an context in which (n + m) is also a KnownNat
01:10:55 <jle`> oh, i missed the constraint, natAdd :: (KnownNat n, KnownNat m) => Proxy n -> Proxy m -> (forall n' m'. KnownNat (n' + m') => Proxy n' -> Proxy m' -> a) -> a
01:11:17 <Xandaros> I'm getting a bit confused at the double =>
01:12:24 <shachaf> Doesn't that have the same issue?
01:12:46 <shachaf> Assuming you don't just mean you implemented it with undefined.
01:13:16 <jle`> i didn't implement with undefined
01:13:26 <jle`> i used something like the MagicNat trick from reflections
01:16:07 <int-index> Xandaros: => is basically -> with the first argument being implicit (inserted by the constraint solver).
01:16:25 <int-index> So multiple => shouldn't be more confusing than multiple ->
01:17:10 <Xandaros> :k (=>)
01:17:12 <lambdabot> parse error on input ‘=>’
01:17:30 <Xandaros> Yeah, I don't think I get it :D
01:17:45 <int-index> You can't do that only because => isn't exported as a constructor (unlike ->)
01:18:04 <int-index> In some languages -> isn't a constructor either.
01:18:43 <int-index> Lambdabot can't tell you the kind of =>, but I can c:
01:18:52 <int-index> It's `Constraint -> *`
01:19:23 <int-index> where Constraint is the constraint kind (import it from GHC.Exts, turn on {-# LANGUAGE ConstraintKinds #-} to have fun with it)
01:19:52 <Xandaros> I have played around with it, but I don't think I used ConstraintKinds...
01:20:28 <Xandaros> Also, shouldn't it be Constraint -> * -> *?
01:20:45 <int-index> Sure, my bad
01:20:53 <int-index> It's Constraint -> * -> *
01:22:14 <Xandaros> DO I assume correctly that it is right associative and binds weaker than (->)?
01:22:31 <int-index> Yes.
01:22:39 * hackagebot haskdogs 0.4.4 - Generate tags file for Haskell project and its nearest deps  https://hackage.haskell.org/package/haskdogs-0.4.4 (SergeyMironov)
01:22:52 <int-index> It's right associative, but I don't know if it binds weaker.
01:23:29 <int-index> It might have the same fixity.
01:24:56 <int-index> :k forall a . Eq a => a -> Ord a => a
01:24:58 <lambdabot> *
01:25:02 <nshepperd> jle`: you can get rid of the CPSing with (KnownNat n, KnownNat m) => Proxy n -> Proxy m -> Dict (KnownNat (n + m))
01:25:07 <int-index> looks like same fixity
01:25:55 <jle`> oh hey that was me playing around with Dict earlier
01:26:03 <jle`> but i ran into a roadblock
01:26:05 <jle`> thanks
01:26:24 <nshepperd> oh hmm
01:27:29 <lpaste_> jle` pasted “reifyAddition” at http://lpaste.net/145825
01:27:34 <nshepperd> huh, I don't understand why undefined didn't work there
01:27:43 <jle`> here's what i have so far...i'm not sure if reify is the correct word for this
01:27:44 <nshepperd> I did a similar thing by unsafeCoercing a Dict
01:28:23 <jle`> reifyAddition (Proxy :: Proxy 2) (Proxy :: Proxy 3) (\(Proxy :: Proxy n) (Proxy :: Proxy m) -> natVal (Proxy :: Proxy (n + m)))
01:28:25 <jle`>  => 5
01:28:54 <jle`> it'd be nice if i can figure out how to write it using Dict
01:29:50 <lpaste_> nshepperd pasted “multiplication” at http://lpaste.net/145826
01:30:16 <nshepperd> the above is how i did multiplication, at one time
01:31:20 <jle`> oh i was trying to play around to get something like that earlier.
01:31:22 <jle`> do you not do it anymore?
01:32:05 <nshepperd> oh, I just haven't looked at that code for a few months
01:32:09 <nshepperd> should still work
01:32:37 <lpaste_> nshepperd annotated “multiplication” with “multiplication (cleaner)” at http://lpaste.net/145826#a145827
01:33:00 <jle`> this is def much cleaner, ty :)
01:33:03 <jle`> than what i had at least
01:33:32 <nshepperd> :)
01:35:01 <jle`> btw i noticed that (:~:)/Refl has been in base for a while now.  are there plans to move Dict into base too?
01:35:27 <Xandaros> It's in base? o_O
01:35:41 <jle`> since 4.7.0.0 apparently
01:36:51 <nshepperd> huh, I wonder if it's possible to write (KnownNat n, KnownNat m) => Proxy n -> Proxy m -> (KnownNat (n+m) => r) -> r
01:37:19 <nshepperd> that would cut down on the noise of case matching the Dict, at least
01:38:00 <Xandaros> jle`: Can you give me a link to (:~:) on hackage? Can't find it
01:39:01 <jle`> Xandaros: http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Type-Equality.html
01:39:08 <Xandaros> thanks
01:39:28 <jle`> nshepperd: let me know if you find a way :)
01:39:57 <shachaf> nshepperd: Why not e.g. (KnownNat n, KnownNat m) => Proxy n -> Proxy m -> Dict (KnownNat (n+m))?
01:40:18 <shachaf> Or Dict (KnownNat n) -> Dict (KnownNat m) -> Dict (KnownNat (n+m))
01:41:33 <nshepperd> shachaf: yes, that works. but I want to not have to case match on the Dict immediately just to get the constraint in scope
01:44:02 <jle`> oh it looks like it is p simple
01:44:40 <jle`> foo :: Dict (KnownNat n) -> Dict (KnownNat m) -> (KnownNat (n * m) => r) -> r
01:44:52 <jle`> foo x y z = case x %* y of Dict -> z
01:45:01 <jle`> it compiles for me at least :|
01:53:57 <nshepperd> oh cool
01:54:59 <varaindemian> Assuming f, g and h are not bottom, the following equality holds for all f, g and h of the correct type: f. (g . h) = (f . g) . h
01:55:08 <varaindemian> is it true?
01:55:26 <jle`> varaindemian: you can prove it :)
01:55:34 <jle`> using equational reasoning :D
01:55:46 <nshepperd> hey, that'll help a lot to avoid marching 'case' statements actually
01:55:52 <int-index> varaindemian: just expand the definitions and you'll see
01:56:13 <int-index> (.) is easy to expand, really
01:56:25 <nshepperd> foo x y . foo a b :: ((KnownNat (x*y), KnownNat (a*b)) => r) -> r -- they compose!
01:58:43 <jle`> :O
02:04:19 <varaindemian> int-index: how do I expend the definition?
02:09:05 <int-index> varaindemian: f . g = \x -> f (g x)
02:10:11 <Freundlich> varaindemian: In general, if you want to show that two functions are extensionally equal, you show that they return the same results for the same parameters.
02:11:31 <int-index> Freundlich: But he's proving that (.) is associative, there's only one function.
02:12:47 <Freundlich> int-index: No, f . ( g . h ) is a function and (f . g) . h is another.
02:14:20 <int-index> Freundlich: well, if you look at it this way, it's less obvious that intensional equality is sufficient in this case
02:20:23 <Freundlich> int-index: Right...
02:32:49 <varaindemian> why do we use lambda here flip' f = \x y -> f y x if we could simply write flip' f x y = f x y?
02:33:14 <varaindemian> flip' f x y - f y x
02:33:22 <ifesdjeen> @varaindemian because you'd like to delay evaluation, mostly 
02:33:22 <lambdabot> Unknown command, try @list
02:33:27 <varaindemian> flip' f x y = f y x
02:33:40 <jle`> varaindemian: you don't have to, but some people like to do it to show that you typically are calling it with f to return a function
02:33:44 <jle`> it's sort of a self-documenting-code kinda thing
02:34:10 <varaindemian> jle`: so it has to do with partial aplication
02:34:12 <varaindemian> write?
02:34:19 <varaindemian> right?**
02:34:23 <ifesdjeen> e.g., you'd like to create a function that flips the arguments and calls the original function, not return result immediately
02:34:29 <jle`> not really, the two are identical (as long as you provide a type signature)
02:34:45 <quchen_> ifesdjeen: Evaluation order has nothing to do with this.
02:35:09 <quchen_> The only practical difference I can think of is inlining behaviour, since GHC only inlines fully applied functions.
02:35:19 <quicksilver> what ifesdjeen is referring to, I suspect, is this pattern:
02:35:28 <quicksilver> foo f = let g = .... in \x y -> .....
02:35:39 <jle`> i mean, it is not related to the idea of partial application.  it's just a way of saying, "hey, flip', usually we're going to use it as (flip' f), not (flip' f x y).  so just to show this in our style, we're going to write it this way for purely aesthetic purposes."
02:36:00 <jle`> idk i think it's kind of silly, myself
02:36:07 <quicksilver> which lets you share the cost of evaluating 'g' between multiple calls to foo f x y
02:36:11 <quchen_> s/fully applied functions/fully applied definitions/
02:36:25 <quicksilver> as long as you save the partially applied (foo f)
02:36:48 <jle`> it's a way of self-documenting your code to show that you "intend" for people to use it like `flip f` normally, and less like `flip f x y`
02:37:02 <varaindemian> I see
02:40:45 <bgamari-> Anyone have half an hour or so to help the Haskell community?
02:40:55 <bgamari-> #11065 could use some hands
02:40:55 <bgamari-> https://ghc.haskell.org/trac/ghc/ticket/11065
03:27:52 <ReinH> bgamari-: one problem with examples for foldl specifically is that you almost never actually want to use foldl
03:28:48 <bgamari-> ReinH, heh, fair enough but it's okay if the documentation says this
03:28:51 <ReinH> Unless you're very confident in GHC's strictness analysis.
03:29:00 <bgamari-> of course
03:29:07 <bgamari-> which is generally misplaced trust
03:29:50 <ReinH> I mean, I guess foldl ((+) :: Int -> Int -> Int) 0 might be ok
03:30:00 <ReinH> That's about as far as I trust it.
03:30:23 <ReinH> (with optimizations ofc)
03:30:27 <Xandaros> So... what's the problem with foldl that doesn't exist with foldr?
03:30:38 <ReinH> Xandaros: the problem is with foldl instead of foldl'
03:30:51 <ReinH> @where lazy
03:30:52 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
03:31:06 * quchen still hasn't needed foldl
03:31:20 <ReinH> quchen: I can't actually think of any examples that need foldl off hand
03:31:27 <ReinH> but I believe that they exist
03:31:31 <quchen> There are legends of actual uses of foldl, but I haven't heard many
03:31:36 <ReinH> exactly
03:31:46 <quchen> I think I remember one use in Cabal that explicitly mentions "not foldl' here"
03:31:53 <ReinH> nice
03:32:16 <Xandaros> Well, you explicitly used foldl as a bad example. I know about foldl', but why is the left-folding variant special?
03:32:39 <Xandaros> The way I see it, foldr should have the same problems, shouldn't it?
03:32:39 <ReinH> foldr has a similar problem except that (a) it is subject to short-cut fusion and (b) it is often used with guarded recursion
03:32:52 <ReinH> both of which alleviate the problem
03:33:26 <ReinH> or at least make the problem not relevant
03:33:29 <Xandaros> Hmm, I see
03:33:45 <Xandaros> Doesn't that depend on the kind of folable you are working with, though?
03:33:50 <Xandaros> *foldable
03:34:23 <quchen> If you've got a Snoc list, then foldl/foldr are swapped, I guess.
03:35:24 <ReinH> At some point all folds that are optimized via foldr/build fusion are treated like lists whose cons cells are optimized away (deforestaation) so it doesn't matter too much.
03:36:42 <ReinH> (and actually foldl' is done via foldr now anyway
03:36:44 <ReinH> )
03:37:31 <ReinH> And we even have foldr' now
03:37:49 <quchen> Why is it called deforestation?
03:38:07 <ReinH> logging metaphor?
03:38:26 <ReinH> quchen: Because Wadler called it that
03:38:28 <quchen> Logging metaphor? That's a cute name
03:38:39 <ReinH> it eliiminates trees, get it?
03:38:46 <quchen> "So Simon, how did you come up with 'zonking'"? :-)
03:38:46 <ReinH> *eliminates
03:39:00 <frerich> I thought it was related to having a function generate a tree data structure and another one consuming it - and eliminating the intermediate trees is 'deforestation'
03:39:11 <ReinH> lists are just degenerate trees ;)
03:39:16 <quchen> It's a pretty linear tree
03:39:22 <quchen> Just like () is a tree structure
03:39:30 <ReinH> your face is a pretty linear tree
03:39:31 <ReinH> and etc
03:39:31 <quchen> Even Void is a tree I guess
03:39:32 <frerich> It appears that Wadler's paper was indeed called " "Deforestation: transforming programs to eliminate trees""
03:39:55 <ReinH> frerich: it does appear so ;)
03:40:22 <frerich> I suspect I totally didn't get how y'all have been perfectly aware of this. :-{
03:40:52 <ReinH> frerich: no :(
03:41:57 <ReinH> there is no :(, only :)
03:47:44 * hackagebot haskoin-core 0.2.0 - Implementation of the core Bitcoin protocol features.  https://hackage.haskell.org/package/haskoin-core-0.2.0 (PhilippeLaprade)
03:52:15 <SrPx> Would you say that the cost of maintenance of a huge codebase of entirely pure code is smaller than a "normal" codebase consisting of objects/classes that have the power of altering a global state? If yes, how much? Linearly more complex? Up to a constant?
03:52:27 <SrPx> less complex*
03:53:12 <SrPx> Linearly less complex would imply that the cost of maintenance of a pure codebase doesn't scale linearly. That'd be a huge claim, I think, but I'm not sure it is incorrect. 
03:53:50 <liste> my gut says the cost is smaller but I don't have any data
03:54:34 <SrPx> Some kind of study would be really handy, but I don't think it would be easy to measure the effect of something like this.
03:54:44 <liste> and you can't put "[26] liste's gut, 2015-11-23 11:54" in the footer of a paper
03:54:52 <SrPx> hahaha
03:55:41 <ReinH> I mean you *can*
03:55:50 <bergmark> SrPx: there is a paper comparing open source projects in different languages and haskell had the least bugs per some unit they measured
03:55:52 <ReinH> And then other people *can* laugh at you
03:56:35 <SrPx> ReinH: why?
03:56:46 <ReinH> for citing liste in a paper
03:56:58 <SrPx> ah
03:57:19 <SrPx> shame's on them for missing the chance to listen to the voice of enlightenment 
03:57:21 <zebr> when it comes to type theory we can actually cite one's gut quite happily. your gut is based on intuition, and type theory on intuitionistic logic.
03:57:30 <ReinH> intuitively, the complexity of global state increases according to Metcalf's law, but intuition isn't worth much.
03:57:38 <zebr> says you!
03:58:05 <ReinH> zebr: you keep using this word
03:58:26 <SrPx> ReinH: thank you very much for this keyword 
03:58:40 <SrPx> ReinH: I almost like you now 
03:58:52 <ReinH> The feeling is almost mutual
03:58:58 <liste> are my papers so horrible that people get laughed at for citing them T_T (jk)
03:59:06 <ReinH> liste: yes?
03:59:10 <ReinH> also what papers?
03:59:11 <quchen> Tai's paper comes to mind
03:59:42 <quchen> A paper so stupid it's google-able by literally using "tai's paper"
03:59:50 <SrPx> ReinH: so you almost almost like me? That's unfair, I still like you more than you do like me. But I can live with that, I guess. :'(
04:00:11 <liste> ReinH none actually
04:00:15 <ReinH> SrPx: no, I almost almost like you :D
04:00:42 <zebr> ReinH: :)
04:01:30 <SrPx> ReinH: that's what I said.
04:01:41 <ReinH> SrPx: so it is!
04:01:51 <ReinH> Then yes, that.
04:02:26 <SrPx> Have you noticed that frontend buzztechs are coming closer and closer to a purely functional DSL?
04:02:29 <ReinH> You know that thing where humans have a hard time with repeated words? Yeah, that.
04:02:45 * hackagebot haskoin-node 0.2.0 - Implementation of a Bitoin node.  https://hackage.haskell.org/package/haskoin-node-0.2.0 (PhilippeLaprade)
04:02:47 * hackagebot haskoin-wallet 0.2.0 - Implementation of a Bitcoin SPV Wallet with BIP32 and multisig support.  https://hackage.haskell.org/package/haskoin-wallet-0.2.0 (PhilippeLaprade)
04:03:39 <SrPx> jQuery = chaos, backbone = come control with purity, angularjs = isolates state in a single place for a greater good, react = filtres those ideas up introducing a proper data structure for DOM and a diff/patch algorithm to allow you encode arbitrary DOM-manipualting functions
04:03:57 <ReinH> SrPx: the backlash to mutable state is a vicious as it has been slow to arrive.
04:04:28 <ReinH> at least, one can hope
04:04:37 <SrPx> so you'd say I'm correct on this analysis? I could just be seeing things as I'm biased
04:05:07 <ReinH> I'm not sure. I try not to read too much buzzy tech stuff. It makes my head hurt.
04:05:51 <bergmark> the people complaining about angular are the loudest IME :)
04:08:51 <SrPx> bergmark: are them? I don't follow that world beyond what inevitably gets to me. What are they saying?
04:11:45 <bergmark> SrPx: I've never used angular so i think i never found it necessary to remember the complaints :) i think "too much mutability" was one of them. maybe it also has bidirectional bindings? that always sucks
04:14:10 <bergmark> i'm sure jquery is worse if you try to use it like a templating engine, it's really hard to not end up with XSS all over the place
04:15:48 <zomg> I think the state related stuff is just one thing people complain about angular
04:16:11 <zomg> We have a fairly sizable angular codebase at work and it's been fairly smooth sailing, but the state stuff has been a bit problematic on occasion
04:17:07 <zomg> before angular, it used to be a jquery codebase... and the problem with that was state stored in DOM and the code being horrible spaghetti because so much logic was directly on element event handlers and stuff like that :P
04:19:41 <Xandaros> I recently referred to lens as the jquery of haskell. I hope edward doesn't kill me now :D
04:20:43 <luite> he has done so himself
04:21:05 <bergmark> we also had a jquery codebase, but without state in the DOM, using reactiv values instead. It was pretty nice to work with, but like i said, too error-prone
04:21:07 <hpc> one could say jquery is the lens of javascript
04:21:16 <hpc> it's a specialized set of lenses for DOM
04:23:00 <Xandaros> It's going to be interesting to see how lens will handle DuplicateRecordFields in 8.0
04:23:34 <hpc> i just want DuplicateRecordFields
04:23:36 <Xandaros> The lack of that extension was what got me to use lens in the first place, actually
04:24:37 <hpc> i just use data Type = Type {typeValue :: Thing}
04:25:20 <Xandaros> I wrap everything in a call to declareLenses and then use (^.) to access stuff... but that's just me
04:26:40 * hpc spends so little time outside work coding
04:29:56 <SrPx> Sorry, my connection. So, I see. Thanks guys.
04:31:45 <SrPx> Do you happen to have some authority argument I can use when defending the subject of pure programming? For example, famous/successful/important people on tech claiming things on the line of "mutability everywhere is the root of most problems" and pure code is the solution for that
04:32:24 <tdammers> SrPx: you mean your target audience is more likely to listen to authority figures than to reason?
04:32:50 <hpc> https://twitter.com/id_aa_carmack/status/325019679720615936
04:32:54 <hpc> SrPx: ^
04:33:27 <Xandaros> tdammers: Unfortunately, that's often how people are :(
04:33:34 <tdammers> I know
04:33:40 <SrPx> Think of this as a form of citation, it is good to make it clear I'm not taking this out of my mind.
04:40:06 <dhalgren> hi! haven't followed the haskell ecosystem closely for a while -> is smallcheck still frequently used? last hackage update is dec2013, seems long ago
04:43:56 <Xandaros> dhalgren: I have never even heard of that, so I assume no
04:44:57 <Xandaros> I'm not actually doing any proper testing, but if I was, I'd probably use QuickCheck
04:45:38 <bergmark> smallcheck isn't really a replacement for quickcheck
04:46:06 <bergmark> https://www.reddit.com/r/haskell/comments/25aagr/quickcheck2_vs_smallcheck_vs_smartcheck_etc
04:46:44 <dhalgren> hm. thx. y, it was suggested as a complement not a competition to quickcheck. oh well...
04:53:33 <julianleviston> Can anyone help me work out how to get around this issue: Trying to run something that uses Groundhog to connect to a postgresql database from within Hint, and I got the following error (I was using stack with lts-3.7) “This version of GHC is not thread-safe,can't safely run two instances of the interpreter simultaneously”  (I was running it from within GHCi by the way)
04:55:01 <quicksilver> I suspect that message means that you can't use hint from inside that ghci
04:55:28 <julianleviston> Actually nevermind… I updated to lts-3.15 and it works now.
04:55:29 <quicksilver> although I haven't seen it and I don't know what version would not give that erro
04:55:38 <quicksilver> well there you go :)
04:55:46 <julianleviston> quicksilver:  thanks for responding. :)
04:56:56 <julianleviston> It was a bit complex because it was GHCi running Snap running Hint running Groundhog to talk to Postgresql… but thanks.
05:04:07 <yesza> Hey guys, I'm trying to make a method operates on 2 lists. It firstly finds the correct element, and then adds that element to the 2nd list, however I can't work out how to delete said element from the first list
05:04:12 <yesza> Any help much appreciated. 
05:04:29 <h_noob> you can't delete stuff from lists ... 
05:04:54 <h_noob> you can only make a new list w/o the elements you don't want
05:05:02 <julianleviston> yesza: assuming you’re aware Haskell has Lists as data structures that don’t change
05:05:50 <julianleviston> yesza: making a new list without an element is perhaps a bit of an indication you’re using an incorrect data structure or trying to do something perhaps in a way that could be done better… maybe…
05:06:11 <frerich> yesza: Maybe you mean something like http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html#v:partition ?
05:22:54 <varaindemian> is sum a higher-order function?
05:24:34 <julianleviston> varaindemian: does it take a function as an argument?
05:24:35 <julianleviston> :t sum
05:24:37 <lambdabot> (Num a, Foldable t) => t a -> a
05:24:46 <julianleviston> doesn’t appear to…
05:24:53 <julianleviston> varaindemian: so, no.
05:25:24 <julianleviston> varaindemian: why do you ask?
05:25:49 <nmryan> it also doesn't return a function as a result
05:26:19 <int-index> nmryan: returning a function as a result wouldn't make it a HOF, it would make it a curried function
05:26:24 <kras> Hi, question on stack. I have an Alex lexer in my project. stack recognises .x files and is able to build correctly when I do "stack build"
05:26:33 <julianleviston> int-index: what about const?
05:26:45 <kras> but when I do "stack ghci" it complains that it doesn't find the lexer
05:26:58 <kras> how do I make "stack ghci" look for .x
05:27:26 <Xandaros> julianleviston: You can also see const as a function that returns the first argument. Though it is probably more useful partially applied, nothing is preventing you from using it in any way you like
05:27:44 <julianleviston> Xandaros: sure… 
05:28:14 <int-index> julianleviston: hmm. Yeah, that's subtle. `const id` makes `const` a HOF.
05:28:15 <julianleviston> Xandaros: I was just making a point to int-index that const can be viewed as a function that takes a single argument and returns a lambda.
05:28:29 <julianleviston> int-index: sure but const 5 ?
05:28:47 <pavonia> One could argue that a function having an * -> * type variable in it makes it potentially higher-order
05:28:51 <julianleviston> int-index: also, is HOF just a function that takes *or* gives a function as its argument or result? I can’t remember the exact definition
05:29:07 <julianleviston> in any case, sum is definitely not one.
05:29:15 <Xandaros> It needs to take one, I'm pretty sure
05:29:17 <julianleviston> :t msum
05:29:18 <lambdabot> (Foldable t, MonadPlus m) => t (m a) -> m a
05:29:27 <julianleviston> ah ok.
05:29:41 <Xandaros> varaindemian: For examples of higher order functions, take a look at foldr, map and filter
05:29:52 <pavonia> julianleviston: What if you have an instance Foldable ((->) r)
05:30:12 <int-index> julianleviston: according to wiki, it's disputed whether returning a function as a result makes a function higher-order
05:30:21 <int-index> I tend to think that it's not the case
05:30:23 <julianleviston> pavonia:  will sum let you do that?
05:30:26 <julianleviston> :t sum
05:30:31 <lambdabot> (Num a, Foldable t) => t a -> a
05:30:46 <Xandaros> int-index: If we do that, most functions would be considered higher-order. The term would lose its meaning
05:30:53 <varaindemian> julianleviston: well I have some exercises. The other possible responses are: sum is an overloaded function and sum is a polymorphic function (both in the Haskell sense). I have to choose the wrong one
05:32:00 <julianleviston> overloaded… ah I can’t remember what makes a function overloaded… it’s definitely polymorphic becuase of the Num a constraint.
05:32:02 <varaindemian> I understand the higher-order concept but what about overloaded and polymorphic?
05:32:24 <Xandaros> It's definitely polymorphic. What even is an overloaded function? :D
05:32:31 <julianleviston> pavonia: how would you make sum take Foldable ((->) r) ?
05:33:05 <varaindemian> so overloaded is related to polymorphism right?
05:33:17 <julianleviston> Xandaros: overloaded usually means it has many definitions… but that just means it uses a typeclass… so it’s a bit weird. 
05:33:34 <julianleviston> varaindemian:  polymorphic is referring to the “a"
05:33:38 <pavonia> julianleviston: I meant if you'd have such an instance (not sure if there is one), sum could take a function as an argument
05:33:43 <julianleviston> varaindemian: and I think the overloading is referring to the typeclass
05:34:02 <julianleviston> pavonia: but that’s not a function then… is it?
05:34:10 <pavonia> Why not?
05:34:11 <julianleviston> pavonia: it’s a function wrapped Num a :=)
05:34:12 <Xandaros> I could see overloaded being for "member functions", but sum is not one
05:34:21 <julianleviston> pavonia:  for the same reason a list isn’t a function
05:34:27 <julianleviston> pavonia:  even though it actually is. ;-)
05:34:50 <pavonia> f :: Num a -> r -> a is not a funtion?
05:34:53 <julianleviston> Xandaros: Yeah that’d make more sense to me, too… tho it’s a silly term to use in Haskell I reckon.
05:34:57 <pavonia> * =>
05:35:35 <julianleviston> pavonia: ok… fair enough… but how would you use it?
05:35:42 <julianleviston> is ((->) r) foldable?
05:36:00 <varaindemian> The difference between polymorphism and overloading is that
05:36:00 <varaindemian> polymorphism basically means that there is one algorithm for different
05:36:00 <varaindemian> types of operands whereas overloading means that for one symbol there
05:36:00 <varaindemian> are different implementations.
05:36:04 <julianleviston> pavonia: is this valuable?
05:37:02 <Xandaros> varaindemian: So it's a member function. Sum is neither higher-order nor overloaded, then
05:37:16 <julianleviston> Xandaros:  no he has to choose the *wrong* one..
05:37:25 <julianleviston> Xandaros:  so it *IS* overloaded...
05:37:35 <quicksilver> I believe a more standard terminology is that they are both polymorphic
05:37:46 <pavonia> julianleviston: I don't think there is a meaningful instance for Foldable (r ->)
05:37:46 <quicksilver> but one is parametric and the other is ad-hoc
05:37:49 <Xandaros> Actually, yes... sum is a member of Foldable
05:37:51 <julianleviston> Xandaros: given that sum relies on the fact that Num is overloaded?
05:37:52 <Xandaros> did not realise that
05:38:15 <julianleviston> ooh me meither
05:38:33 <varaindemian> julianleviston: wait, there is still the higher-order fucntion option which I think is the wrong one
05:38:44 <Xandaros> Seems a bit silly to me, since it'll probably always be sum = foldr (+), but w/e
05:38:59 <Xandaros> varaindemian: Yes, that is the wrong one
05:39:04 <julianleviston> varaindemian: yeah, pavonia would have you believe that sum is also potentially higher order...
05:39:14 <Xandaros> _potentially_
05:39:16 <julianleviston> varaindemian: depending on which Foldable is used.
05:39:35 <Xandaros> It is not higher-order in general, therefore not higher-order
05:39:51 <julianleviston> which is entirely a fair point… but in practice it’s not used in that way.
05:39:57 <Xandaros> Otherwise you could even say that id is higher-order
05:40:10 <julianleviston> yep.
05:40:28 <quicksilver> id is one of the standard examples of a higher-order function
05:40:34 <julianleviston> Is it requisite that higher order functions SPECIFY that an argument is a function?
05:40:35 <quicksilver> so yes, I would say it is
05:40:50 <quicksilver> it's just in haskell it's not very meaningful to distinguish
05:41:05 <Xandaros> So basically, it's not really well-defined, is it? ...
05:41:06 <julianleviston> or is it enough that its potentially able to be a higher order function?
05:41:43 <julianleviston> Xandaros: this is a pretty silly question they’re asking you.
05:41:47 <julianleviston> oops.
05:41:49 <julianleviston> not you
05:41:53 <julianleviston> varaindemian: ^
05:41:54 <Xandaros> :D
05:42:54 <Xandaros> Well, they probably expect the higher-order one to be the one being checked, but I gotta say... if #haskell starts fighting over it, it's probably not a good question to ask
05:43:00 <julianleviston> This is often a problem when asking theoretical questions in Haskell… so much of it is contentious and semantically equivocational and open to debate and discussion. It’s really good, but sucks until you just go with it.
05:43:50 <julianleviston> :t map
05:43:52 <lambdabot> (a -> b) -> [a] -> [b]
05:44:13 <Xandaros> map is about as obviously higher-order as it gets
05:44:17 <julianleviston> :)
05:45:03 <julianleviston> I guess part of the problem is that Haskell uses curried functions.
05:45:18 <julianleviston> So the definition of function is incredibly inclusive
05:45:35 <julianleviston> which lets us do amazingly cool things, but kind of sucks a bit when you have to define things.
05:45:52 <julianleviston> a function is a mapping between two sets.
05:46:15 <quchen> And even that is debatable :-D
05:46:19 <julianleviston> :)
05:46:21 <julianleviston> is it?
05:47:01 <julianleviston> quchen: how? :) (interested)
05:47:17 * h_noob is very interested in knowing that, too
05:47:37 <h_noob> maybe they mean the bottom thing?
05:47:45 <quchen> I'm only a single person. :-s
05:47:56 <h_noob> :D but a person whose gender I don't know
05:48:02 <h_noob> Hence "they"
05:48:16 <Xandaros> "they" is used as a geneder-neutral pronoun. You'll get used to it :P
05:48:21 <Xandaros> *gender
05:48:54 <julianleviston> I think OED has even accepted it now, too :)
05:49:12 <julianleviston> finally… (I actually thought it was common usage for the last 20 years)
05:49:51 <Xandaros> quchen: But nevermind that, how is it debatable? Seems pretty obvious to me
05:50:14 <julianleviston> Xandaros: probably in the sense that “function”’s semantics are debateable...
05:50:35 <julianleviston> Xandaros: for example, ask a JS person what a function is and you’ll get a much different definition.
05:50:40 <nmryan> a mapping between sets is the set theory notion of function. type theory functions can't always be talked about that way
05:51:32 <Xandaros> As far as I can tell, a type can be seen as a set of all its possible values. And a function is a mapping from one type to another(where another could be the same, obviously)
05:51:37 <julianleviston> nmryan: isn’t that like saying a biological view of a cat is inconsistent with a physics view?
05:52:37 <Xandaros> These sets are actually disjunctive, if you disregard undefined
05:53:09 <frerich> I think in light of all the delicate nomenclature, it's amazing how many interesting and fun things you can do with Haskell without ever bothering to write down a definition of a function, or what constitutes a type or so. :-)
05:53:10 <nmryan> julianleviston: i don't think so. its more like that the word function means different things in different fields. they aren't inconsistent
05:54:09 <quchen> Well sometimes you don't look at sets
05:54:48 <quchen> You can view a morphism as something abstract and primitive without thinking about sets
05:55:34 <julianleviston> frerich: yeah, I agree! :)
05:56:01 <Xandaros> quchen: Sure, but you can always rethink it in terms of sets. It's just a mental model that's different
05:56:55 <yesza> Yo guys, how do you make a filter that checks just the heads of lists of lists?
05:56:56 <julianleviston> quchen: really, if we want to be pedantic about things, nothing is definable… 
05:57:22 <julianleviston> yesza: using a predicate that checks the head of the list passed to it?
05:57:32 <Xandaros> yesza: Are they all guaranteed to _have_ a head? :P
05:57:40 <yesza> yea
05:57:55 <quchen> julianleviston: "nothing is definable" buys you nothing. Thinking about what a "function" could be if you forget about sets is very fruitful.
05:58:01 <julianleviston> filter (\(x:xs) -> check x) xss
05:58:04 <julianleviston> something like that?
05:58:37 <yesza> Would that check just the heads of all of the lists inside said list tho?
05:58:52 <julianleviston> yesza: I think so.. wouldn’t it?
05:59:08 <yesza> I think so as well, but I am a complete haskell rookie
05:59:14 <julianleviston> ahhh ok.
05:59:23 <yesza> and I am probably the worst coder in the world
05:59:47 <julianleviston> yesza: well haskell will help you then! It’s great for both helping you to code better, and also teaching you how to code better :)
05:59:52 <frerich> yesza: Maybe 'filter (check . head)' would be a bit more explicit in how it applies 'check' only to the head of each list. ;-)
06:00:01 <Xandaros> > filter (\x:xs) -> even x) [[1,2,3], [2,3,4], [3,4,5], [4,5,6]]
06:00:03 <lambdabot>  <hint>:1:11: parse error on input ‘:’
06:00:09 <Xandaros> > filter (\(x:xs) -> even x) [[1,2,3], [2,3,4], [3,4,5], [4,5,6]]
06:00:11 <lambdabot>  [[2,3,4],[4,5,6]]
06:00:36 <Xandaros> frerich: That's what I almost posted, but I think using a lambda might be more obvious to a beginner
06:01:18 <julianleviston> Xandaros: :) nice.
06:01:28 <Xandaros> > filter (even . head) [[1,2,3], [2,3,4], [3,4,5], [4,5,6]]
06:01:31 <lambdabot>  [[2,3,4],[4,5,6]]
06:01:35 <yesza> hmm, but how would I make it return only the head then?
06:01:38 <Xandaros> but of course, this is a lot nicer ;)
06:01:48 <yesza> just head (filter) ?
06:01:51 <julianleviston> yesza: use a list comprehension maybe
06:02:00 <julianleviston> yesza: have you seen them?
06:02:12 <yesza> A little, not fluent though
06:02:15 <Xandaros> map head? :P
06:02:18 <julianleviston> yesza: otherwise you’d need a map on it
06:03:06 <julianleviston> [x | (x:_) <- xss, check x]
06:03:09 <julianleviston> something like that I think.
06:04:12 <julianleviston> > [x| (x:_) <- [1..100], even x]
06:04:13 <lambdabot>      No instance for (Show t0)
06:04:13 <lambdabot>        arising from a use of ‘show_M499578609310317660721547’
06:04:13 <lambdabot>      The type variable ‘t0’ is ambiguous
06:04:20 <julianleviston> oh I’m an idiot.
06:05:20 <Xandaros> > map head . filter (even . head) $ [[1,2,3], [2,3,4], [3,4,5], [4,5,6]]
06:05:22 <lambdabot>  [2,4]
06:05:49 <julianleviston> Xandaros: maybe map then filter?
06:05:59 <Xandaros> good point
06:06:15 <Xandaros> > filter even . head $ [[1,2,3], [2,3,4], [3,4,5], [4,5,6]]
06:06:17 <lambdabot>  [2]
06:06:20 <Xandaros> > filter even . map head $ [[1,2,3], [2,3,4], [3,4,5], [4,5,6]]
06:06:22 <lambdabot>  [2,4]
06:06:27 <quchen> > mapMaybe (\xs -> case xs of (x:_) | even x -> Just x; _otherwise -> Nothing) [[1,2,3], [4,5], [6], []]
06:06:29 <lambdabot>  [4,6]
06:06:46 <julianleviston> I still think the comprehension is nicer and easier to understand
06:07:22 <Xandaros> Not a huge fan of list comprehensions tbh
06:07:42 <julianleviston> Xandaros: maybe a do block with a guard instead? ;-)
06:07:52 <Xandaros> I loved them when I first learned about them, but they become difficult to understand rather quickly
06:08:08 <julianleviston> Xandaros: yeah, they’re a tool… pick them when they make sense, I reckon.
06:09:04 <Xandaros> I typically only use list comprehensions for very simple things, otherwise I stick to combnators
06:09:41 <Xandaros> Usually things that scream "set comprehension!!" at you are good condidates for a list comprehension :P
06:10:03 <frerich> List comprehensions are nice when you want to ignore elements which don't satisfy some pattern match. E.g. only working on all Just values or ignoring empty lists or so.
06:10:11 <frerich> > let xss = [[1,2,3],[2,3,4],[3,4,5],[],[4,5,6]] in [xs | xs@(x:_) <- xss, even x]
06:10:13 <lambdabot>  [[2,3,4],[4,5,6]]
06:11:51 <Xandaros> frerich: That's actually a pretty good solution, seeing that it handles the empty-list case, as well
06:12:08 <julianleviston> hey can you flip a let block into a where clause?
06:12:27 <Xandaros> yes, afaik they are synonymous
06:12:36 <julianleviston> kinda.
06:12:53 <opqdonut> unless you have guards
06:13:06 <opqdonut> (you can of course pop the guards into a case inside the let)
06:13:11 <Xandaros> where clauses get desugared to let expressions, I'm pretty sure
06:14:15 <julianleviston> I think it’s pedagogically better to use where clauses for simple one-liners… but I rarely see it done.
06:15:12 <Xandaros> I tend to only use let within do-blocks…
06:16:15 <Xandaros> And even then I wonder whether "<- pure" might be better just because it blends in with the rest (of course, it would probably be less efficient)
06:17:16 <julianleviston> I just meant in here.
06:17:32 <julianleviston> > x + 1 where x = 5
06:17:33 <lambdabot>  <hint>:1:7: parse error on input ‘where’
06:17:40 <julianleviston> > x + 1 ; where x = 5
06:17:41 <lambdabot>  <hint>:1:7: parse error on input ‘;’
06:18:23 <quchen> 'where' isn't an expression, 'let' is
06:18:28 <julianleviston> yes.
06:18:32 <quchen> (or better, "let...in" is)
06:18:33 <julianleviston> which is why I asked before.
06:18:51 <quchen> > let foo = bar where bar = 3 in foo
06:18:52 <lambdabot>  3
06:18:59 <julianleviston> I wish there was a flipped version of let for readability.
06:19:28 <quchen> Hm, in practice 'where' is just that, no?
06:19:52 <julianleviston> I’m talking about in here.
06:19:59 <Xandaros> lambdabot
06:20:07 <julianleviston> indeed.
06:20:22 <quchen> Mabye, but it would be too much work to implement I guess
06:20:23 <aweinsto1k> > let () = () in foo where foo = 42
06:20:25 <lambdabot>  <hint>:1:20: parse error on input ‘where’
06:20:28 <Xandaros> You can call it by name, it doesn't mind
06:20:37 <quicksilver> it's a syntactic structure thing
06:20:49 <julianleviston> huh?
06:20:49 <quicksilver> let is an expression former, where attaches to decls
06:21:06 <julianleviston> It’d just make learning Haskell easier in here, is all.
06:21:09 * quicksilver nods
06:21:21 <quicksilver> yes, I understand your point
06:21:25 <julianleviston> quicksilver: sorry, yes. :)
06:21:36 <julianleviston> quicksilver: syntactic structure thing, indeed… just sugar
06:21:47 <Xandaros> @define x = 5
06:21:50 <lambdabot>  Defined.
06:21:54 <Xandaros> > x + 2
06:21:57 <lambdabot>      Ambiguous occurrence ‘x’
06:21:57 <lambdabot>      It could refer to either ‘L.x’,
06:21:57 <lambdabot>                               defined at /tmp/mueval1194953865894429689.hs:145:1
06:21:59 <julianleviston> cognitive unpacking thing is another way to phrase it.
06:22:05 <Xandaros> :/
06:22:08 <Xandaros> @undefine
06:22:08 <lambdabot> Undefined.
06:22:09 <julianleviston> lol
06:23:53 <Xandaros> @define xsomeval = 5
06:23:54 <lambdabot>  Defined.
06:23:58 <Xandaros> > xsomeval + 2
06:23:59 <lambdabot>  7
06:24:02 <Xandaros> there you go...
06:24:05 <Xandaros> @undefine
06:24:05 <lambdabot> Undefined.
06:24:13 <julianleviston> Xandaros: um… no.
06:24:20 <julianleviston> Xandaros: I know you can define things.
06:24:35 <julianleviston> Xandaros: but that’s not what I meant. It’s fine. You don’t have to solve this problem. It’s not mine.
06:25:02 <Xandaros> Well, the point is to separate test data from the algorithm you want to demonstrate, isn't it?
06:25:15 <julianleviston> Xandaros: no, it’s the order you read a statement in...
06:25:38 <quicksilver> when I was learning I always preferred let to where actually
06:25:42 <julianleviston> let x = 5 in x + 5 is not as easy to parse mentally as x + 5 where x = 5
06:25:45 <Xandaros> Using let..in adds too much noise, especially since the test data comes first, but if you separate it into a whole new message, that problem shouldn't be that prevalent
06:26:04 <quicksilver> julianleviston: that I would subjectively disagree with
06:26:26 <julianleviston> quicksilver: why?
06:26:41 <quicksilver> well it's hard to explain how ones mental proces works
06:26:42 <julianleviston> quicksilver: I don’t think this is subjective. 
06:26:49 <quicksilver> I find the first easier to parse, mentally.
06:27:14 <Xandaros> julianleviston: It's entirely subjective. I personally agree that the where version is easier to read, but people differ
06:27:21 <julianleviston> quicksilver:  one involves you holding a value assignment in your brain (5 AND x), and the second involves only one.
06:27:40 <quicksilver> definition before use is a common style in both computer programs and essays and papers
06:27:49 <quicksilver> the opposite is also common, of course
06:27:56 <julianleviston> x + 5 where x = 5 involves only looking at the result expression, then searching for a value of x...
06:28:15 <julianleviston> quicksilver: yes, but one requires more cognitive load than the other.
06:28:26 <julianleviston> quicksilver: irrespective of what some people find easier.
06:28:33 <quicksilver> I simply disagree
06:28:50 <quicksilver> they both involve thinking 'huh, what's x?'
06:29:10 <julianleviston> quicksilver:  no… the let one involves holding a value for x.
06:29:11 <quicksilver> if you manage to remember it from the first time through, then the let version is faster
06:29:15 <julianleviston> quicksilver:  you can’t do anything else.
06:29:21 <quicksilver> you can
06:29:24 <julianleviston> quicksilver:  at that point… unless you’ve learned a trick.
06:29:28 <quicksilver> you can drop the value for x and then look back for it
06:29:37 <quicksilver> but you may well at least remember that you *saw* a value for x
06:29:45 <julianleviston> quicksilver: in that case you’re reading “around” the structure.
06:30:09 <julianleviston> quicksilver: which implies you’ve learned to do that.
06:30:52 <julianleviston> quicksilver: it’s probably easier to see when there are more variables in play. But it’s fine… we can just disagree.
06:30:53 <lpaste_> akegalj pasted “pattern matching question” at http://lpaste.net/145830
06:31:17 <akegalj> can someone help me with this one http://lpaste.net/145830 ?
06:31:33 <julianleviston> akahn: use a case with a where?
06:31:37 <akegalj> it is trivial, but I have hoped this was working
06:32:08 <johnw> akegalj: just use: patternMatching b = callCommonFunction
06:32:24 <julianleviston> johnw: you’re not really answering his question.
06:32:50 <Xandaros> akegalj: Yeah, you'll probably have to use a case there. Or move the common function to top-level, which may or may not be a bad idea
06:32:51 <akegalj> julianleviston: yes, I can use case with where
06:33:13 <akegalj> Xandaros: johnw julianleviston : oh, thanks. Ill refactor
06:33:19 <akegalj> with case
06:33:29 <Xandaros> It's a bit unfortunate, I agree
06:33:49 <julianleviston> akegalj: you could also use a guard condition and a where. It’s probably exactly what you want
06:34:13 <akegalj> julianleviston: yes, guard will work too
06:34:24 <akegalj> julianleviston: thnks
06:34:26 <julianleviston> akegalj: https://wiki.haskell.org/Pattern_guard
06:34:46 <julianleviston> oh sorry ignore that link
06:35:16 <julianleviston> akegalj: there’s a reference to guards in LYAH here: http://learnyouahaskell.com/syntax-in-functions
06:35:28 <julianleviston> akegalj: and you can use where after that.
06:35:53 <akegalj> julianleviston: thank you :)
06:36:00 <julianleviston> akegalj: there’s an example that starts with the heading “Where!?”
06:41:43 <julianleviston> say what you like about LYAH, it’s very nice to be able to refer to as a set of examples sometimes.
06:43:00 <yogsototh> Hi everyone. I need an advice. I would like to add the ability to cache POST response and persist the cache on disk. Should I use a basic redis cache middelware or and LRU cache and implement the serialization mechanism myself?
06:48:22 <Xandaros> julianleviston: I actually thing LYAH is pretty good. It's certainly great for beginners - more so than RWH, imo
06:48:28 <julianleviston> yogsototh: redis isn’t a disk based store, is it? it’s a DB
06:48:41 <julianleviston> Xandaros: yeah, I think they’re both pretty terrible for beginners, but that’s cool.
06:48:49 <Xandaros> redis is a key-value store
06:49:02 <julianleviston> Xandaros: yeah, but it’s not a disk-based store, is it?
06:49:12 <julianleviston> Xandaros: like… it stores across a network, not on the local disk
06:49:31 <Xandaros> Well... if you run the server locally... :P
06:49:35 <julianleviston> ummm
06:49:47 <julianleviston> Xandaros: that’s like saying mysql is a disk-based store. It’s not.
06:50:05 <Xandaros> redis _is_ commonly used for persistent caches
06:50:23 <Xandaros> (at least according to them - I don't have anything to back this up)
06:50:27 <julianleviston> Xandaros: yes, but he said he wants to persist the cache on disk.
06:50:43 <Xandaros> and redis will do that for you
06:50:52 <julianleviston> omg
06:51:27 <julianleviston> yogsototh: I don’t really understand your question, sorry. What do you mean?
06:53:12 <Xandaros> Looks like redis does not save to disk when it is being used as a cache, though I suppose you can still use it for persistence, but you'll have to do the actual caching yourself
06:54:57 <yogsototh> julianleviston: I need to cache responses from a WAI application.
06:55:10 <ChristianS> Xandaros: usually redis does save to disk; in any case, you can configure it to do so
06:55:13 <julianleviston> yogsototh: what kind of caching? for what reason?
06:55:24 <yogsototh> julianleviston: and I also need the responses to be saved on disk. 
06:55:57 <yogsototh> julianleviston: I need to cache the whole response as bytestring
06:57:06 <julianleviston> yogsototh: ok so if you want to use redis, you can use hedis to negotiate with redis… or something like that… but I’m not entirely sure what the problem is?
06:57:07 <yogsototh> julianleviston: ideally with a TTL
06:57:55 <yogsototh> julianleviston: I need to save the response because these are response from a third party API for which I don't want to ask twice the same request
06:58:27 <julianleviston> So what is your question?
06:58:28 <yogsototh> julianleviston: This is for a reverse proxy
06:59:39 <yogsototh> julianleviston: I just need an advice. Would it be better to use wai-middleware-cache-redis
07:00:09 <julianleviston> ah sorry I’m not going to be much help then. Apologies.
07:00:23 <yogsototh> julianleviston: or to use something like lrucache and code the persistence myself. 
07:00:39 <yogsototh> julianleviston: thanks nonetheless for your time.
07:00:41 <julianleviston> I’m not sure we can answer that for you.
07:01:30 <julianleviston> yogsototh: why not just try the middleware quickly and if it doesnt suit your needs, roll your own
07:01:55 <yogsototh> julianleviston: yes I'll do that first then. Thanks!
07:02:50 * hackagebot AlignmentAlgorithms 0.0.2.1 - Collection of alignment algorithms  https://hackage.haskell.org/package/AlignmentAlgorithms-0.0.2.1 (ChristianHoener)
07:03:46 * frerich chuckles at Brian Kernighan's talk about "strongly-hyped programming languages" :-)
07:04:08 <julianleviston> frerich: hehe why? :)
07:06:14 <Hailey> hi
07:06:23 <Xandaros> frerich: Love the name :D
07:15:36 <c_wraith> What sort of overhead does unamb introduce?
07:15:42 <c_wraith> ... I guess I could just test
07:17:46 <conal> c_wraith: i think the current lub/unamb implementation has a large overhead. i don't know whether it can be implemented efficiently (and correctly, of course) without GHC RTS support.
07:18:16 <julianleviston> OMFG it’s conal
07:18:23 <julianleviston> conal: sorry, big fan. :)
07:18:35 <conal> julianleviston: hi! np. :)
07:19:28 <julianleviston> :D
07:20:23 <Xandaros> conal: Me, too! Can I get an autograph? :D
07:20:47 <conal> :)
07:23:11 <c_wraith> conal: I suspected as much, given that it has to run threads behind the scenes.
07:23:36 <conal> c_wraith: yep
07:24:28 <kras> Hi, question on stack. I have an Alex lexer in my project. stack recognises .x files and is able to build correctly when I do "stack build"
07:24:34 <kras> but when I do "stack ghci" it complains that it doesn't find the lexer
07:24:38 <kras> how do I make "stack ghci" look for .x
07:24:47 <camm1> Hello, everyone. I'm getting an error when I use readParam in snap. The error is the following: A web handler threw an exception. Details: Safe.readNote no parse on "user", readParam failed. I don't know what is the problem. Could you help me please?
07:24:57 <c_wraith> conal: that response was surprisingly prompt.  You must have a highlight on "unamb"
07:25:19 <julianleviston> camm1:  sounds like it couldn’t parse something so threw an exception.
07:25:32 <conal> c_wraith: indeed, i do.
07:25:38 <c_wraith> camm1: Whatever type you're asking it to parse as, that param doesn't parse as that type.
07:25:56 <c_wraith> camm1: if you want better control, you'll have to do more parsing manually.
07:26:58 <julianleviston> the weird thing is, readParam returns a maybe.
07:27:27 <julianleviston> readParam: Read a parameter from request. Be sure it is readable if it's there, or else this will raise an error
07:27:38 <julianleviston> camm1: you probably want readMayParam instead.
07:27:42 <c_wraith> I guess the Maybe is only for if it's absent.
07:27:51 <julianleviston> Try to read a parameter from request. Computation may fail because the param is not there, or because it can't be read
07:28:10 <julianleviston> yeah if it’s not there it’ll fail, not fail the maybe.
07:28:19 <julianleviston> (raise an error)
07:29:10 <radix> kras: I think this might be a known bug: https://github.com/commercialhaskell/stack/issues/1347
07:29:59 <kras> radix: thanks for the info
07:30:16 <radix> kras: though there was a similar bug that was fixed -- make sure you're using the latest version of stack
07:31:45 <julianleviston> I wish Hint was fixed so it let me ctrl-C when I’d run runInterpreter…
07:32:04 <julianleviston> as it stands it hangs my session and I have to force kill the process
07:35:40 <kras> radix: let me try upgrading
07:53:09 <Xandaros> julianleviston: Have you tried ctrl-d?
08:00:44 <Mike57> I'm getting an error installing pdf-toolbox-document via cabal (one of the deps of hoodle) and I can't make sense of the error message. Can anyone help?
08:00:47 <Mike57> https://pastee.org/3bkw4
08:01:23 <dcoutts> Mike57: take a look at the log file it mentions. That has the full compile error message. It's a type error.
08:03:07 <Mike57> dcoutts: I'm afraid I couln't make heads or tails of it (not an H programmer, just an end user).  Seem like a mature package to be failing at that level!
08:03:59 <Xandaros> Mike57: What GHC version are you using?
08:04:54 <Mike57> https://pastee.org/c7g4g
08:05:00 <Mike57> (the full log)
08:05:29 <Mike57> Xandaros: 7.8.4
08:07:52 * hackagebot mida 0.4.6 - Language for algorithmic generation of MIDI files  https://hackage.haskell.org/package/mida-0.4.6 (mrkkrp)
08:11:54 <Xandaros> Mike57: Yep, that should be fixed by upgrading to 7.10.x
08:14:51 <Mike57> Xandaros: great, thanks for that.  Compliling as I type :)
08:15:28 <Xandaros> Mike57: Glad to hear :)
08:16:01 <Xandaros> 7.10 has been out for a while now, why do people still use 7.8? (I actually had a student using 7.6, too…)
08:16:12 <Mike57> gentoo stable
08:16:45 <Xandaros> I'd argue that 7.10 is more stable than 7.8 now :P
08:17:00 <geekosaur> debian derivatives still package 7.6
08:17:14 * geekosaur still has not switched his main desktop to hvr's PPA...
08:17:33 <Xandaros> When was 7.8 released again? About a year ago? …
08:17:53 * hackagebot alga 0.1.0 - Algorithmic automation for various DAWs  https://hackage.haskell.org/package/alga-0.1.0 (mrkkrp)
08:18:22 <Xandaros> nvm, almost 3 years ago
08:18:58 <Mike57> gentoo package maintainers sometimes hold something back because of caution about some dep or the other. 
08:19:39 <Mike57> but its usually not too much bother just to override it
08:20:25 <Xandaros> …and I got annoyed when the arch maintainer didn't package 7.10.2 for a month or two :D
08:20:33 <Xandaros> and I was still using 7.10.1
08:43:13 <julianleviston> Xandaros: sorry - I was AFK… ctrl-d? what does that do?
08:43:28 <julianleviston> end of file?
08:44:28 <julianleviston> I don’t think that would work.
08:44:32 <julianleviston> I’ll try it anyway
08:44:42 <julianleviston> Xandaros: no, it doesn’t work.
08:45:41 <julianleviston> Xandaros: Hint runInterpreter hijacks the sig interrupts… it’s in the documentation. I just wish it wouldn’t. Makes developing a bit of a pain
08:46:23 <quicksilver> don't run hint from ghci then?
08:46:36 <quicksilver> use ghci for testing othe things (individual functions etc)
08:46:43 <quicksilver> but run entire hint sessions in a fresh terminal
08:46:47 <bergmark> Mike57: i'll run that through the matrix builder and fix any incorrect bounds
08:48:17 <julianleviston> quicksilver: makes no difference if it’s run in GHCi or not.
08:48:59 <julianleviston> quicksilver: I’m actually a little worried about what’s going to happen when I want to deploy this app (it’s running in snap).
08:49:39 <quicksilver> maybe I don't understand the question
08:49:45 <quicksilver> why do you need Ctrl-C to work?
08:49:56 <quicksilver> can't you build a 'kill' command in to your interpreter?
08:49:59 <julianleviston> quicksilver: why do you ever need it to work?
08:50:42 <julianleviston> quicksilver: um… it’s running in Snap.
08:50:49 <c_wraith> It's not hint's choice to hijack the interrupt handlers. 
08:50:56 <julianleviston> isn’t it?
08:51:01 <julianleviston> I think it’s GHC’s fault.
08:51:03 <c_wraith> The GHC api actually does it. 
08:51:07 <julianleviston> yep.
08:51:25 <julianleviston> whosever’s fault it is.
08:51:34 <aandy> hi, (newbie question, but not the generic "what's a monad" one). anyone who've seen javascript before, might help me understand if this is way off: i'm working my way through learnyouahaskell back and forth between (applicative) functors, and monads, and this keeps popping up in my head: (ignoring the wrapping context) isn't applicatives and monads *somewhat* like chaining in javascript (or other langs for
08:51:36 <aandy> that matter) / middleware?
08:52:04 <julianleviston> aandy: yeah, something like that.
08:52:06 <aandy> i mean, how monads usually used (of course there doesn't have to be multiple :))
08:52:18 <aandy> julianleviston: ah, great. thank you
08:52:30 <c_wraith> aandy: Applicative and Monad are composition patterns. They give you ways to pit things together. 
08:52:31 <julianleviston> aandy: but monads are programmable and you have much more control over how they work… and thy don’t ONLY do that chaining thing.
08:52:53 <c_wraith> aandy: what being put together means can vary a lot, though. 
08:53:37 <aandy> i see that sort of like "make the interfaces meet each other", with applicative functors and monads being ways to accomplish that
08:54:08 <julianleviston> aandy: best not to try to box monads into any one idea yet. Just keep learning.
08:54:28 <aandy> ok, gotcha :) thanks guys
08:54:30 <julianleviston> aandy: the maybe monad works like this… the list monad works like this… etc
08:54:31 <prsteele> aandy: you might take a look at the Maybe and list monad instances, they provide two very different approaches
08:54:48 <julianleviston> aandy: then you’ll start to develop an intuition.
08:55:04 <c_wraith> aandy: the tricky secret is that they mean no more than their types (and the rules for how they should behave). :) 
08:55:18 <julianleviston> aandy: and you’ll realise the way they work depends on the type of thing they are.
08:55:46 <aandy> looking forward to it already :)
08:56:20 <julianleviston> aandy: I think the important thing to remember is to go from the PROBLEM back to the solution, not the other way around.
08:56:59 <aandy> agreed. the motivation often helps explain why something is the way it is
08:56:59 <prsteele> aandy: e.g. try writing code that composes 3 functions which take in Int and return a Maybe Int, and see how much code you're duplicating
08:58:02 <julianleviston> like for example, dividing by 3 different numbers, and if any of them are 0, you want to return Nothing.
08:59:25 <julianleviston> if you try to do it manually, you’ll “see” the need for something … you’ll wish you had it, and that thing will be a Monad.
08:59:37 <julianleviston> That’s what all those “You could have invented …” tutorials try to do...
09:00:15 <aandy> great examples. i'll give them a go. thanks
09:03:53 <julianleviston> aandy: I really think the path should go: functions, types, typeclasses, higher order functions & combinators, algebraic data types, monoids, semigroups, functors, applicative functors, monads.
09:04:19 <prsteele> aandy: I wrote a lot of Haskell code before bothering to figure out monads
09:04:23 <julianleviston> if you want to learn it “in order”.
09:04:39 <varaindemian> foldr (-) 0 [1, 2, 3, 4] doesn't make smth like  4-0-3-2-1?
09:05:18 <julianleviston> varaindemian: (-) is subtraction.. 
09:05:37 <geekosaur> > foldr (-) 0 [a,b,c,d]
09:05:39 <lambdabot>  a - (b - (c - (d - 0)))
09:05:42 <julianleviston> varaindemian: oh sorry I thought you meant the string . lol
09:06:04 <prsteele> varaindemian: 1 - (2 - (3 - (4 - 0)))
09:07:23 <julianleviston> varaindemian: the r stands for “right-associative”.
09:07:24 <varaindemian> prsteele: so 0-4-3-2-1 is the foldl?
09:07:51 <c_wraith> aandy: I do agree with prsteele. Don't worry about "understanding monad". Just write code. Monad isn't really that important. 
09:07:58 <prsteele> varaindemian: 0 - 1 - 2 - 3 - 4
09:08:26 <julianleviston> c_wraith: tho it does beg the question of how you get to use it if you never see or try to learn it.
09:08:48 <julianleviston> c_wraith: All these things are “good ways to save time if you’ve done it the manual way and want to stop” right? :)
09:09:01 <julianleviston> a.k.a abstractions :)
09:12:38 <fvh> hi everyone! Help me out. I'm using `hslogger` to log my application, but messages duplicated to stdout in addition to file. How can I supress output to stdout? Using simple example from docs
09:21:45 <geekosaur> fvh, see http://hackage.haskell.org/package/hslogger-1.2.9/docs/System-Log-Logger.html#v:removeHandler
09:23:05 <fvh> :geekosaur you mean I need to remove some handler, I've add only one for writing to file, which is working correctly. Doc says by default everything writes to stderr
09:23:15 <fvh> ?
09:23:36 <geekosaur> yes. reading what I limned to you: "The root logger's default handler that writes every message to stderr can be removed by using this function before any handlers have been added to the root logger:"
09:23:48 <geekosaur> (followed by the function call, do  I need to read that as well?)
09:27:54 * hackagebot order-maintenance 0.1.0.0 - Algorithms for the order maintenance problem with a safe  interface  https://hackage.haskell.org/package/order-maintenance-0.1.0.0 (WolfgangJeltsch)
09:29:18 <fvh> geekosaur, ok I'll try, this doesn't seem straightforward because stdout and stderr are different streams
09:29:47 <geekosaur> I would verify that you are actually seeing logging to stdout, then
09:30:05 <geekosaur> because that would be rather unusual, unless you are using it in a context which sends them to the same stream
09:30:40 <geekosaur> (although, unless you redirected it, stdout and stderr will be the same in a shell)
09:32:44 <fvh> wow, this actually helped. Thank you.
09:33:49 <fvh> Is that usual behavior for shell to write both stdout and stderr? I thought it's shell printout only stdout unless I redirect explicitly from stderr
09:34:03 <geekosaur> no, by default stdout and stderr are both the tty
09:34:55 <geekosaur> however they are not tied together in the sense that redirecting one automatically redirects the other
09:35:47 <fvh> hm, ok thanks
09:36:28 <geekosaur> (technically: they are dup()ed filehandles, linked in the kernel but separate from the program's standpoint)
09:39:49 <prsteele> how can I get the source for the standard library, e.g. Data.Map? I can 'view source' via hackage, but that is an HTML page and I'm actually interested in seeing the full directory
09:39:58 <prsteele> (trying to figure out how to structure a package)
09:40:13 <glguy> prsteele: cabal get containers
09:40:23 <geekosaur> if you look at the top of the hackage page, it will tell you the package you want to "cabal get"
09:40:34 <prsteele> 'cabal get', thanks!
09:46:00 <Welkin> has anyone used hakyll with stack?
09:46:13 <Welkin> is there an easier way to run /.site build?
09:46:48 <Welkin> currently I have to use: stack exec -- .stack-work/..{long directory list}../projectname build
09:47:06 <bergmark> --copy-bins ?
09:47:18 <bergmark> puts the exe in ~/.local/bin
09:48:11 <Welkin> bergmark: where do I use that flag?
09:48:14 <Welkin> stack build?
09:48:14 <bergmark> personally i'd probably run it from ghci while developing
09:48:27 <bergmark> Welkin: yeah stack build --copy-bins or stack install
09:52:55 * hackagebot order-maintenance 0.1.1.0 - Algorithms for the order maintenance problem with a safe  interface  https://hackage.haskell.org/package/order-maintenance-0.1.1.0 (WolfgangJeltsch)
10:20:37 <submain> Potentially stupid question, but anyone knows how I lift IO into an ExceptT?
10:21:09 <Hafydd> submain: does liftIO not achieve that?
10:22:04 <dmj> is there a package for generic deriving of Arbitrary instances?
10:22:45 <submain> Hafydd: ah yes, now I see that liftIO has an instance for ExcepT. Duh.
10:22:54 <submain> I'm just really confused by all the types
10:23:48 <Cale> submain: Generally liftIO's job is to turn an IO action into an action of any monad built in terms of IO (which wants to allow that)
10:24:03 <Cale> :t liftIO
10:24:05 <lambdabot> MonadIO m => IO a -> m a
10:25:26 <dmj> why wouldn't Arbitrary have a default generic implementation...
10:25:27 <Cale> Most transformers will implement an instance like  instance MonadIO m => MonadIO (SomethingT m) where liftIO x = lift (liftIO x)
10:25:48 <Cale> dmj: Because it's been around a lot longer than GHC's new generics?
10:26:30 <dmj> Cale: ah, good point, I think it would be a nice addition
10:26:42 <Cale> Default arbitrary and coarbitrary instances would be nice to have
10:26:56 <Cale> (coarbitrary is actually even easier most of the time)
10:26:58 <submain> Cale: awesome, thanks!
10:29:29 <submain> On that note, is there a liftEither to lift either into an ExceptT?
10:30:10 <submain> hoogle doesn't seem to return any results for Either a b -> ExceptT a b
10:30:45 <bergmark> `except :: Either e a -> Except e a'
10:30:46 <dmj> Cale: it seems like there is a Generics support in there, but just for 'shrink'
10:31:00 <submain> nice thanks!
10:31:14 <bergmark> or simply `ExceptT'
10:33:42 <Cale> dmj: I didn't think the default implementation of shrink used generics
10:33:47 <Cale> I thought it was just trivial
10:34:00 * Cale looks
10:34:14 <Cale> oh, cool
10:34:22 <Cale> It does use generics now
10:34:56 <dmj> Cale: interesting how the default arbitrary value = error :)
10:35:09 <dmj> seems like this is an answer, https://hackage.haskell.org/package/basic-sop-0.2.0.0/docs/Generics-SOP-Arbitrary.html
10:35:22 <dmj> but this should be default behavior IMO
10:36:34 <Cale> To be fair, you'd still likely almost always want to override that default eventually to get a better distribution of test cases, but it would be very convenient.
10:37:22 <Cale> (I'm actually a little surprised that they started with shrinking, since that'd be even more tricky to do well generically in many cases)
10:39:13 <dmj> Cale: hm, yes, wonder if it was intentional not to include default generic instances for Arbitrary
10:39:45 <Cale> I think it's probably more important to make it easy to have *some* instance
10:41:27 <dmj> Cale: agreed
10:43:28 <dmj`> Cale: could have arbitrary = gArbitrary defOptions, similar to aeson
10:55:11 <submain> Considering the following:
10:55:16 <submain>  
10:55:17 <submain> test :: ExceptT String IO String
10:55:17 <submain> test = do
10:55:17 <submain>   str <- return $ getLine
10:55:20 <submain>   liftIO $ putStrLn str
10:55:23 <submain>   return str
10:55:43 <submain> str seems to have type IO String. Does that mean that the ExceptT monad doesn't unwrap the IO out of it?
10:56:05 <shachaf> Please use hpaste.org for pastes that are more than two lines long.
10:56:14 <kadoban> submain: I suspect that   a <- return b     never actually makes sense
10:56:25 <sm>  str is a String
10:56:28 <shachaf> do { x <- return y; ... } means the same as "do { let { x = y }; ... }"
10:56:51 <sm> oh..
10:57:00 <shachaf> Also, getLine doesn't contain a wrapped String, so you can't unwrap it. There's no wrapping.
10:57:34 <kadoban> submain: Perhaps something like …   str <- liftIO getLine   -- does that make more sense?
10:57:49 <submain> let me try that
10:58:27 <submain> yep that works - this monad transformer thing is melting my brain.
10:59:27 <dmj`> submain: higher kinded types
10:59:53 <mmachenry> What does everyone think about running the ghc profiler in production code to get information about crashes?
11:00:35 <mmachenry> I'm having spurious issues that are hard to duplicate in dev and considering just always running the production code with profiling enabled. 
11:00:37 <sm> if you can afford the slowdown.. why not
11:00:52 <mmachenry> sm: Do you know the expected slowdown? 
11:01:27 <dmj`> mmachenry: is this on a web server?
11:01:29 <sm> no, I'm going to guess in the range of 2x-10x
11:02:38 <mmachenry> dmj`: No it's a daemon.
11:02:57 * hackagebot HTTP 4000.2.21 - A library for client-side HTTP  https://hackage.haskell.org/package/HTTP-4000.2.21 (GaneshSittampalam)
11:04:52 <sm> mmachenry: lots of verbose logging with Debug.Trace is another route
11:07:04 <Caridorc> Hi, I have got a doubt about manually writing an AST for a simple haskell expression
11:08:23 <Caridorc> The expression is: zipWith ($) . repeat
11:08:54 <Caridorc> My try is: http://pastebin.com/9UBspmbJ
11:10:22 <mauke> Apply (Apply (Var ".") (Apply (Var "zipWith") (Var "$"))) (Var "repeat")
11:12:01 <mmachenry> sm: I'd like to see what's using memory as well I think
11:12:50 <Caridorc> @mauke so tree's can be written in LISP sintax?
11:12:50 <lambdabot> Unknown command, try @list
11:13:16 <mauke> Caridorc: ??
11:13:35 <Caridorc> Can  any sintax tree be written as a LISP program?
11:13:46 <mauke> 1) yes, lisp is all about trees  2) what I wrote isn't valid lisp syntax
11:14:20 <Caridorc> mauke very interesting (2. maybe with a good deal of macros), 
11:14:35 <mauke> it is valid haskell, though
11:14:45 <Caridorc> What does `Var` represent?
11:14:46 <mauke> assuming something like data Expr = Apply Expr Expr | Var String
11:14:55 <mauke> a variable
11:15:23 <Caridorc> aren't functions immutable (that is "constants" not "variables") ?
11:16:29 <c_wraith> Caridorc: a function being a variable just means functions are higher order. 
11:16:36 <mauke> variables are immutable
11:16:43 <mauke> a function is a value
11:16:47 <mauke> category error
11:16:51 <ggole> Immutable doesn't mean 'constant'
11:17:26 <Caridorc> mauke ok so it just was a terminology issue, I considered variablees only things that can `vary`
11:17:53 <sm> mmachenry: there's ekg, but I think you'd have to build your own monitors on top of that
11:18:02 <mauke> > let f x = x + 1 in (f 1, f 2)
11:18:05 <lambdabot>  (2,3)
11:18:12 <mauke> the x there is immutable
11:18:22 <mauke> but it's not a constant
11:18:24 <sm> and I believe you could force a traceback on request, might be useful for spot checks
11:18:33 <c_wraith> Caridorc: I don't think that's it. I think you're not considering that a variable can refer to a function. 
11:18:49 <sm> force a traceback and/or measure the memory footprint of some things
11:19:14 <Caridorc> c_wriath: it sure can! Even in the imperative programmign you can do that (Python)
11:19:31 <Caridorc> x = lambda arg: arg + 1
11:20:15 <Caridorc> so Var in the sintax tree just means that what follows is a primitive value / terminal node ? 
11:20:29 <Shockk> I get around the problem of being confused by calling Haskell things "bindings" or "names" rather than "variables"
11:20:31 <mauke> it means it's an identifier in the source code
11:23:08 <Caridorc> mauke In counting the number of tokens, that is the number of items in the AST, should I also count `Var` ?
11:24:22 <mauke> how do you define "item"?
11:25:38 <Caridorc> mauke  `node` should be more precise (off-topic: WOW, you are giving me so much good help :) thanks)
11:26:21 <mauke> I'd count each Var and each Apply as one node, I guess
11:26:52 <mauke> like, it's a binary tree with leaves tagged Var and branches tagged Apply
11:27:24 <c_wraith> I'd avoid calling anything in the AST a token. Tokens are properties of source. The AST has thrown those things away. 
11:27:31 <Caridorc> so Var "." counts 2?
11:28:33 <mauke> no, 1
11:28:36 <mauke> one Var
11:29:14 <Caridorc> very good
11:32:14 <Caridorc> I thnk I drew the tree correctly (on paper) thanks to your help and lispish tree
11:37:21 <Caridorc> thanks everyone, again and goodbye :)
11:45:39 <dave23> does anybody know of an online payment system(like paypal, braintree...) that has a haskell SDK or is easy to use with haskell?
11:45:51 <dmj`> @package stripe-haskell
11:45:51 <lambdabot> http://hackage.haskell.org/package/stripe-haskell
11:45:54 <dmj`> dave23: ^
11:46:48 <dmj`> paypal you don't want to use, and braintree doesn't have a REST API
11:46:59 <dmj`> paypal owns braintree now though... so their rates might be better
11:48:30 * hackagebot Michelangelo 0.2.2.0 - OpenGL for dummies  https://hackage.haskell.org/package/Michelangelo-0.2.2.0 (SwiftsNamesake)
11:48:43 <dave23> I'm not too keen on paypal anyway, they seem to be a pretty scummy company from what I hear
11:49:07 <dave23> thanks for stripe suggestion, that looks just right on first glance
11:50:24 <prsteele> do people generally need to add '.cabal-sandbox/bin' to their path to get cabal to work properly?
11:50:59 <prsteele> I've installed HTF via cabal, but 'cabal test' fails because it doesn't find '.cabal-sandbox/bin/htfpp' on the path. I figured cabal would know to look in its own sandbox...
11:51:36 <kadoban> prsteele: I probably wouldn't recommend trying to use cabal-install itself in general. But if you're going to, yeah that's a common practice I guess.
11:52:16 <prsteele> kadoban: what would you suggest, then, to get the dependencies my library needs?
11:53:23 <kadoban> prsteele: I /highly/ prefer using 'stack' instead. https://github.com/commercialhaskell/stack
11:58:06 <hsocks> hi, haskell beginner here. looking to integrate a list of (x,y) numbers - anything similar to trapz in matlab, on hackage? I have nonuniformly spaced x values. ekmett's integration library wouldn't magically work for me, would it? :)
11:58:57 <hsocks> a vector of (x,y) numbers actually* not entirely a beginner at least :)
12:02:20 <ClathomasPrime> I have a question about AMP
12:02:31 <prsteele> hsocks: just googling, but does https://hackage.haskell.org/package/integration-0.2.1/docs/Numeric-Integration-TanhSinh.html help?
12:02:47 <prsteele> hsocks: unless that is the one you mentioned
12:02:52 <ClathomasPrime> The full AMP has been implemented in a stable release of GHC, right? 
12:03:09 <ClathomasPrime> How do I update? Or do I have to wait for haskell_platform to catch up?
12:03:16 <ClathomasPrime> I run ubuntu. 
12:03:42 <hsocks> prsteele: that is the library I was referring to from edwardk (ekmett) - it look's like it wants a function, but I only have a vector of values, so I didn't think it was suitable for my usecase, but it's been a while since calculus class
12:04:22 <prsteele> hsocks: are you assuming you are linearly interpolating your points? If so, you could write a function that returns a value based on that interpolation and pass that on
12:05:26 <mnoonan> ClathomasPrime: I installed 7.10.2 via stack on Ubuntu (iirc)
12:06:02 <hsocks> prsteele: to the integration package? I think I see what you mean, but not sure
12:06:29 <ClathomasPrime> mnoonan: oh that's perfect, I have stack. But I tried `stack upgrade` and it seemed to just try and upgrade stack itself
12:06:53 <kadoban> ClathomasPrime: IMO you shouldn't use haskell platform anymore. Delete everything from it, and just let 'stack' install GHC for you.
12:07:21 <kadoban> ClathomasPrime: The version of GHC that stack will install depends on what resolver you use though, it uses whichever one is appropriate.
12:10:04 <ClathomasPrime> kadoban: That's interesting, when did haskell platform become obsolete? With stack?
12:11:50 <kadoban> ClathomasPrime: I haven't thought it was a good idea basically ever. Before stack I used to use cabal-install with manual sandboxes and etc.
12:11:55 <prsteele> kadoban: <checking out stack...> seems reasonable so far. I'm just using it as a drop-in replacment for cabal, any traps to watch out for?
12:12:23 <kadoban> ClathomasPrime: I used it when … I very first started with haskell, and then dropped it when it seemed like it was a pain in the ass to install new stuff without everything breaking.
12:13:05 <kadoban> prsteele: Not specifically really. You should probably read the beginners guide, but it seems like you can 1/2way get by just learning a couple of commands and not really worrying about it too.
12:15:37 <kadoban> prsteele: Only thing I guess I'd mention is that it's still pretty new. So if you see stuff missing, it may actually be missing. It's being developed pretty heavily though, and they're open to patches and suggestions.
12:16:46 <radix> kadoban: it's not a drop-in replacement, it works in a very different way
12:18:07 <ClathomasPrime> I ended up following this tip https://groups.google.com/forum/#!topic/haskell-stack/nHOclE6xIV0
12:18:10 <kadoban> radix: Depends on the definition of "drop in" I guess. I use it for the same purposes in largely the same way.
12:18:58 <radix> just a warning since you can end up very confused if you expect the same commands to behave the same
12:19:10 <kadoban> Ah, yes.
12:19:20 <ClathomasPrime> I still don't fully understand stack. Is that type of thing covered in any specific univerity courses? Or for a more immediate solution, are there any only resources for understanding what typical build tools do?
12:19:30 <radix> I've seen some people get extremely confused when they run `stack install` expecting something like what `cabal install` does
12:20:14 <marble_visions> hi all, i've got a question about partial application and the "." notation: http://pastebin.com/X1Dx8sjW
12:20:17 <radix> anyway, I love stack, just trying to help avoid confusion :){
12:20:58 <prsteele> marble_visions: what is your question?
12:21:00 <marble_visions> this blows up, but if I replace "flatten1 . map . unpack" with "flatten1 . map (unpack )" all is good..
12:21:38 <marble_visions> oh yeah
12:21:38 <prsteele> marble_visions: map takes two arguments
12:21:40 <prsteele> :t map
12:21:42 <lambdabot> (a -> b) -> [a] -> [b]
12:21:48 <marble_visions> sorry, my mistake : (
12:21:57 <marble_visions> of course
12:22:13 <marble_visions> but I just had to ask the channel in order to get it... works every time..
12:22:17 <prsteele> heh
12:22:36 <tailgate> how can I split a string on any non-alphanumeric characters?
12:22:58 <mauke> that sounds like the wrong question
12:23:00 <prsteele> radix: from what I can tell in my five minutes of using stack, 'stack [build|test]' is basically 'cabal install --only-dependencies && cabal [build|test]'?
12:23:02 <kadoban> ClathomasPrime: I'm not entirely sure what you mean I guess. It's not covered specifically in any university course I know about, it's a new tool and that'd be a strange course. There's some documentation you should probably start with, like there's a beginners guide out there somewhere, let us know if you don't see it I could probably find it.
12:23:15 <EvanR> :t breakOn
12:23:17 <lambdabot>     Not in scope: ‘breakOn’
12:23:17 <lambdabot>     Perhaps you meant one of these:
12:23:17 <lambdabot>       ‘break’ (imported from Data.List),
12:23:27 <EvanR> :t break
12:23:28 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
12:23:44 <prsteele> :t split
12:23:45 <lambdabot> Splitter a -> [a] -> [[a]]
12:23:54 <marble_visions> thanks guys! back to the fun stuff :)
12:24:12 <prsteele> I wanted split from Data.Text, but tailgate check out Data.Text
12:24:21 <JagaJaga> Guys, can you suggest me exercises for homework on lens for my students? :)
12:24:27 <tailgate> does that require cabal?
12:25:03 <mauke> :t groupBy ((==) `on` isAlphaNum)
12:25:04 <lambdabot> [Char] -> [[Char]]
12:25:12 <ReinH> tailgate: pretty much everything requires cabal or a cabal replacement (stack)
12:25:23 <mauke> > groupBy ((==) `on` isAlphaNum) "<mauke> that sounds like the wrong question"
12:25:27 <lambdabot>  mueval-core: Time limit exceeded
12:25:42 <tailgate> not allowed to install anything
12:25:59 <dhalgren> even stack requires cabal I gather; replacing just cabal-install, right?
12:26:19 <mauke> > groupBy ((==) `on` isAlphaNum) "<mauke> that sounds like the wrong question"
12:26:21 <lambdabot>  ["<","mauke","> ","that"," ","sounds"," ","like"," ","the"," ","wrong"," ","...
12:26:41 <kadoban> dhalgren: It uses the Cabal library, which is distinct from the cabal-install executable (which is named 'cabal' when you run it).
12:26:51 <dhalgren> ah, fair
12:27:14 <dcoutts> dhalgren, kadoban: though stack solve also uses cabal-install
12:27:16 <dino-_> tailgate: cabal-install defaults to installing things --user, you can't do that in your home dir?
12:27:24 <prsteele> I'm guessing homework
12:27:34 <ReinH> I meant cabal the executable, not Cabal the library :)
12:27:44 <tailgate> Just against work rules
12:27:52 <ClathomasPrime> kadoban: I guess I'm wondering about build tools in general, not just stack. I frequently feel like tutorials for stack assume you know how other build tools work. When I downloaded stack, I had no idea what a sandbox was (I currently only have a faint idea). I feel similarly about package managers.
12:27:54 <dino-> tailgate: tough rules
12:27:55 <prsteele> tailgate: you can always check out the source on hackage/hoogle
12:27:57 <hesiod> Hi, I just can't get my head around this seemingly simple data type definiton (this is about ekmett's linear): Given a Functor f and some type a, how can I have a type that takes both f and a? Basically, I want data SomeType f a = SomeType (f a) (a) so I can later have a SomeType V3 Float
12:28:24 <shachaf> @let data SomeType f a = SomeType (f a) a
12:28:26 <mauke> hesiod: like that
12:28:26 <lambdabot>  Defined.
12:28:32 <shachaf> works for me
12:28:55 <dcoutts> JagaJaga: as an ex instructor for undergrad classes, I'd seriously advise picking a different topic entirely
12:29:00 <hesiod> Hmm
12:30:07 <dcoutts> JagaJaga: there are many interesting and comprehensible things in the Haskell world for students, lens and pipes/conduits are not two of them :-)  imho
12:30:48 <mauke> what if want to make absolutely sure my students will hate haskell?
12:30:56 <JagaJaga> dcoutts: I've already made a lecture about them. Now I need to give them homework..
12:31:02 <prsteele> personally I found having to implement Applicative/Monad instances for types to be an interesting excercise, esp. if you are only given the monad laws and not the word 'Monad'
12:31:07 <dcoutts> JagaJaga: ah, sorry :-)
12:31:13 <dcoutts> mauke: oh that's easy
12:31:13 <monochrom> "data SomeType f a =" this part already allows you to use "SomeType V3 Float"
12:31:31 <monochrom> "= SomeType (f a) a" this part is right or wrong depending on what you use it for.
12:32:06 <JagaJaga> dcoutts: conduits are really cool :(
12:32:22 <monochrom> you can make students hate any topic you choose by carefully pessimistic teaching and evilly difficult exams.
12:32:39 <dmj`> JagaJaga: is the homework on the package lens, or lenses in general
12:32:56 <phaazon> @hoogle MonadThrow
12:32:59 <lambdabot> No results found
12:33:03 <phaazon> @index MonadThrow
12:33:03 <lambdabot> bzzt
12:33:18 <mauke> @where hayoo
12:33:18 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
12:33:19 <phaazon> more useless than lambdabot’s search, doesn’t exist :(
12:33:21 <JagaJaga> dmj`: wll, the lecture was based on lens pkg, so homework can be based on it.
12:33:25 <dcoutts> JagaJaga: then I'd suggest avoiding mixing it with things like state monads. If you've covered traversals then there's lots of practical examples there for selecting/transforming trees, x-path / j-path style things.
12:34:24 <phaazon> hm
12:34:30 <phaazon> MonadThrow, MonadError
12:34:32 <phaazon> look the same to me
12:35:04 <dmj`> JagaJaga: ambitious
12:35:20 <dhalgren> oh, q re dot= (sum .) . zipWith (*)  ; I tried following the types manually, w ghci help: (sum .) :: .. (a->[c])->a->c ; (zipWith (*)) :: .. [c]->[c]-[c] ; (.) :: (b->c)->(a->b)->a->c ; so a in composition is first [c]->[c} from zipWith ; c is last c in (sum .); but then b is, what both (a->[c])->a from (sum .) AND last [c] from zipWith? how does (a->[c])->a unify w just [c] here? or am I doing it totally wrong?
12:35:24 <monochrom> be careful when you guess semantics from "meaningful" names. you will never get what you want.
12:38:08 <JagaJaga> dcoutts: nice, thank you. Any more ideas?
12:39:02 <dcoutts> JagaJaga: or go the other way, rather than useful, strip it right back and get them to implement lens composition using the simple lens representation as getter+setter
12:40:34 <Guest96605> Hello,
12:41:38 <mauke> dhalgren: the type A -> B -> C parses as A -> (B -> C)
12:41:48 <mauke> -> is right associative
12:42:03 <dhalgren> so I am doing it in reverse , damn
12:42:04 <JagaJaga> dcoutts: I did that during my presentation
12:42:11 <dcoutts> ok
12:42:24 <Guest96605> From what I read, last ghc version should use utf8 by default as it is my default encoding on my system. However when I use readfile
12:42:34 <Guest96605> I get strings like soci\'e9t\'e9 instead of société
12:42:41 <Guest96605> What am I doing wrong?
12:43:10 <mauke> what's your code, how are you running it, and how are you inspecting the result?
12:43:11 <dcoutts> JagaJaga: so another practical example is something like config files, where you have sections / subsections. You have record types for each section, but there's lots of lifting going on which fits lenses well...
12:43:33 <JagaJaga> dcoutts: nice!
12:43:43 <JagaJaga> dcoutts: that is what I will do. Thank you.
12:44:10 <dcoutts> JagaJaga: so e.g. each field description has a printer + parser. Now when I want to make a section with many fields, I want a lens per field to connect the record type with the type of each field
12:44:19 <dcoutts> JagaJaga: and similarly all the way up
12:45:06 <dcoutts> JagaJaga: if you want an example of the idea (that doesn't explicitly use lens, but has getters+setters), take a look at cabal-install's config file description modules
12:45:36 <dave23> dmj`: turns out stripe charges you 2%. Can't afford that, its just payment on somebody elses behalf.
12:47:26 <KaneTW> paypal charges, too
12:48:26 <dmj`> dave23: yea, 30 cents + 2.9%. You're incentived to have large payments. Not sure you can get cheaper w/o losing reputability
12:48:36 <dave23> I know nothing of these things, who do they charge? the customer, me, or the merchant?
12:49:13 <KaneTW> paypal charges the merchant
12:49:37 <monochrom> credit cards also charges the merchant. by a percentage. I heard 3%
12:49:56 <dhalgren> mauke: fits perfectly that way ofc, w a in sum being [c] of result and b. at least there's no magic to it as I started to fear :D
12:50:18 <monochrom> interac charages the merchant. but by a constant. I heard < 1 cent, even < 0.1 cent
12:50:29 <nawal_> hi, I'm learning from Learn You a Haskell for Great Good, and have got to the State monad. Due to the change from State s a being a constructor, to having a constructor function state, I'm very confused.
12:50:29 <nawal_> http://pastebin.com/1gpW541f
12:50:50 <nawal_> The first version in the pastebin above works, but the second version gives me Haskellese
12:51:25 <mauke> nawal_: looks like the dreaded monomorphism restriction
12:51:34 <mauke> adding a type signature should fix it
12:51:37 <kadoban> nawal_: Give it a type annocation.
12:51:40 <mauke> or disable the MR
12:51:47 <kadoban> annotation*
12:51:58 <nawal_> That worked
12:52:10 <monochrom> I like the merchants I buy from. I want them to make more money. so I try to use interac more, now that I know interac's cost vs credit card's cost
12:52:27 <dino-> IRTA 'type annoculation'
12:54:08 <dmj`> dave23: is bitcoin an option
12:54:35 <monochrom> interesting, "state" is MonadState-polymorphic. no wonder.
12:54:40 <nawal_> mauke, kadoban I read the haskell wiki on monomorphism restriction, and it makes no sense. *grumbles* thanks for fixing my problem though! :-)
12:54:55 <dave23> monochrom, that looks like just canada though
12:55:32 <dave23> dmj`, would be a nice extra but it sort of has to be usable by everybody
12:55:33 <kadoban> nawal_: Basically it has to pick a concrete type of that, if you don't specify one, and it doesn't know what to pick. (probably technically incorrect, but whatever)
12:55:36 <monochrom> I'm surprised. I thought state was pinned to State
12:56:37 <monochrom> dave23, that is likely true.  P. S. when I tried to type "dave", my fingers typed "save"
12:57:10 <monochrom> many years of use Apple II during childhood leads to some ingrained typing
12:57:12 <nawal_> thanks kadoban :-) While learning, I often write something and then :t to get the type and understand what's going on. It would have helped if I tried the annotation from the version that worked though. Thanks!
12:59:36 <dhalgren> monochrom: colemak actually puts s on the d key :) e is on k though..
13:00:36 <nawal_> Before I dive into Monad transformers, can I ask a general question - if I want State and IO, I can stack a StateT on top of IO. If I need two different variables for my state, e.g. two lists, is the best way to stack two StateT transformers, or can I pack the lists in a tuple or an enclosing list, and use that? What's preferred?
13:01:20 <dave23> well, humble bundle uses stripe so it must be good.
13:01:31 <prsteele> nawal_: for the second, I imagine you would want to make a type that fully encapsulates your state, e.g. data MyState = MyState [a] [b]
13:01:36 <kadoban> nawal_: I'd pack the things into a tuple or a record
13:02:03 <prsteele> nawal_: data MyState a b = MyState [a] [b], rather
13:02:23 <nawal_> prsteele, kadoban, cool :-)
13:03:32 * hackagebot scat 1.1.0.2 - Generates unique passwords for various websites from a single password.  https://hackage.haskell.org/package/scat-1.1.0.2 (RomainEdelmann)
13:03:34 * hackagebot enumerate 0.0.0 - enumerate all the values in a finite type (automatically)  https://hackage.haskell.org/package/enumerate-0.0.0 (sboo)
13:03:36 <dmj`> dave23: I've also heard about 'paymill'
13:04:22 <prsteele> about stack -- should I be keeping stack.yaml under version control, or is that something that can be safely auto-generated from project.cabal ?
13:04:53 <JagaJaga> prsteele: if you have custom things there, so keep it in VCS
13:04:59 <kadoban> prsteele: You should track it.
13:05:06 <JagaJaga> prsteele: but better use Nix ;)
13:05:54 <kadoban> nix solves a different problem than stack, doesn't it?
13:06:11 <dhalgren> JagaJaga: I'm def gonna try it these days; got a machine to reinstall anyhow, and sounds sexy :)
13:06:32 <monochrom> I have a cunning plan. use stack.yaml, nix, and VCS together :)
13:07:24 <prsteele> better question: stack.yaml currently contains nothing but commented out lines. Under what circumstances would it contain something useful?
13:08:08 <kadoban> prsteele: How did you generate it? It usually includes at least a line or two that's not commented out, like the resolver line.
13:08:24 <Welkin> nix is on my list of things to try
13:08:26 <prsteele> kadoban: I literally ran 'stack build' on top of an existing project
13:08:33 <prsteele> kadoban: and... it seemed to work fine
13:08:41 <kadoban> prsteele: 'stack build' doesn't create a stack.yaml
13:09:11 <kadoban> prsteele: 'stack init' maybe? But yeah, look more closely, I suspec there's a couple of lines not commented out, no?
13:10:45 <prsteele> kadoban: ah, ya, there are a few lines that aren't commented out, but they don't seem interesting, e.g. extra-deps: []
13:10:50 <r24y> I've got a problem with Parsec, and it's clear there's something I'm not understanding which is preventing me from solving it
13:11:17 <prsteele> whatever, into git it goes
13:11:28 <kadoban> prsteele: The "resolver" line is probably the most important one. Basically it says succinctly which versions of packages should be used to build the thing, which is good for repeatable builds.
13:11:42 <dhalgren> huge diff between "few boring lines" and "empty" I'd expect
13:11:45 <kadoban> prsteele: Given that, you can have some assurance that someone down the road will have no trouble building your project.
13:11:57 <prsteele> dhalgren: yes, but I meant that I haven't tinkered. All auto-generated
13:12:13 <dhalgren> sure
13:12:41 <prsteele> thanks
13:12:55 <kadoban> prsteele: (which, if you've ever tried to get some old haskell project building, you'll appreciate)
13:13:28 <prsteele> kadoban: yup, that's why I am trying out stack
13:16:29 <r24y> I've got two parsers (commands = command `sepBy` spaces) and (command = commandName >> number `sepBy` spaces) (commandName being a single letter and "number" able to parse a float)
13:17:01 <r24y> it's trying to keep going pulling numbers, but barfs when it hits the next command name
13:17:53 <akegalj> Hey. Can I somehow do `zipWith (+) [1,2] [Just 1, Nothing]` and get [1, Nothing] ?
13:18:18 <akegalj> [2, Nothing]
13:18:38 <akegalj> oh sorry.
13:18:43 <akegalj> [Just 2, Nothing]
13:18:53 <Welkin> you mean (,)?
13:19:21 <Welkin> akegalj: no, because that list is not homogeneous
13:20:16 <akegalj> Welkin: what list? [Just 2, Nothing] is homogeneus
13:20:30 <Welkin> the result is not
13:20:40 <chaosmasttter> > zipWith (fmap . (+)) [1,2] [Just 1, Nothing]
13:20:43 <lambdabot>  [Just 2,Nothing]
13:20:57 <chaosmasttter> akegalj: ^
13:20:59 <hftf> Is there a way to simplify fromMaybe ... (do ... ; Just ...) ?
13:21:00 <Welkin> oh, I didn't see your second comment
13:21:02 <akegalj> Welkin: yes, I misspeled it.
13:21:09 <akegalj> chaosmasttter: thnx
13:23:15 <johnw> hftf: you must mean more than that, because from what you said, the simplification is "..."
13:23:57 <dhalgren> wonder if you could make the literal code akegalj gave work w some odd Num (Maybe a) instance? 
13:24:03 <hftf> Hi johnw, right now I have http://pastie.org/pastes/10576759/text?key=wdrdcsp8zzrbdqcemxijq
13:24:25 <hftf> And I don't know what I'm doing :)
13:24:26 <johnw> hftf: really, never use fromMaybe with M.lookup
13:24:38 <hftf> johnw: Okay, which should I use instead?
13:24:51 <johnw> use case, twice
13:25:05 <johnw> actually, three times it looks like
13:25:09 <mauke> what's wrong with fromMaybe?
13:25:11 <johnw> consider every possibility
13:25:26 <johnw> mauke: does he know for certain that the map will always have "id" in it?
13:25:29 <hftf> It will always succeed
13:25:32 <johnw> ah
13:25:41 <johnw> in that case, you can use M.!
13:25:42 <mauke> johnw: are you thinking of fromJust?
13:25:50 <johnw> mauke: doh, you are so right
13:26:06 <hftf> let me find out what M.! does
13:26:09 <johnw> sorry, hftf, fromMaybe is just fine
13:26:21 <johnw> M.! assumes the key always exists
13:26:29 <hftf> Okay that's a new thing to me, thanks
13:26:42 <johnw> it's like fromJust . M.lookup "id"
13:27:30 <hftf> I have now f = fromMetaInlines . (M.! "id") . fromMetaMap
13:27:35 <hftf> Looks better
13:27:51 <johnw> you know it will always be a MetaLines?
13:28:02 <hftf> Correct
13:28:31 <johnw> ok then
13:28:53 <hftf> So I think for the above function, I know "similars" key is going to exist, I don't have to use lookup either
13:29:01 <hftf> even though that function lookupMeta is provided I can do it myself
13:29:23 <prsteele> stack question -- optparse-applicative: needed (==0.12.0.0), 0.11.0.2 found (latest is 0.12.0.0)
13:29:28 <prsteele> is an error I get
13:29:38 <prsteele> I request 0.12.0.0, and it seems to know that 0.12.0.0 is available...
13:33:36 <lpaste_> r24y pasted “lists-of-lists.hs” at http://lpaste.net/145851
13:34:04 <lpaste_> r24y revised “lists-of-lists.hs”: “No title” at http://lpaste.net/145851
13:39:01 <hftf> I now have http://pastie.org/pastes/10576780/text?key=pqjjsczrrhuvd69v3jlog
13:39:53 <zwaefawef> i just read some portfolios of programmers, especially in the haskell community, my (subjective) conclusion is that one needs a degree in CS to start working in this field?. anyone can comment on this? confirm it? falsify it? 
13:40:19 <Welkin> zwaefawef: where did you read this?
13:40:26 <Ashy> it's generally very helpful to have a degree of either CS or IT in australia
13:40:27 <MarcelineVQ> Which field?
13:40:34 <Ashy> depending on how big the company is
13:40:35 <zwaefawef> i didnt read this literally
13:40:35 <Welkin> zwaefawef: the haskell community is quite diverse
13:40:47 <Welkin> we have people from all over the world of all ages and backgrounds
13:40:50 <hftf> So I assume the type constructors aren't in scope if you only export a type?
13:41:37 <Welkin> zwaefawef: I bet the vast majority of the community does *not* have a CS degree
13:41:38 <hftf> I mean  data Foo = Bar … | Baz …  and I export Foo in my module
13:41:39 <Welkin> I sure don't
13:41:46 <hftf> then Foo gets exported but not Bar or Baz?
13:41:47 <Welkin> or a math degree
13:41:49 <Ashy> it doesn't prove you know what you're doing of course but it proves you can finish something unpleasant with some deadlines 
13:41:50 <zwaefawef> Welkin: or maybe degree in math, or physics
13:42:03 <Ashy> which probably matters most to hiring managers at a certain level
13:42:05 <Welkin> zwaefawef: we have people in high school here
13:42:26 <hftf> Where I'm looking is https://github.com/jgm/pandoc-types/blob/master/Text/Pandoc/Definition.hs#L89 and L35
13:42:34 <Welkin> zwaefawef: we also have grad students and professors, people who work as software developers, freelancers, and more
13:43:07 <tzh> hftf: right, exporting Foo exports only the type; exporting Foo(Bar, Baz) or Foo(..) exports the constructors too
13:43:18 <Ashy> zwaefawef: how old are you? i can recommend going to uni if you're early 20s or less
13:43:27 <Welkin> Ashy: I disagree
13:43:31 <Welkin> skip university
13:43:33 <hftf> tzh:  Is there a way to import them explicitly on the client end?
13:43:33 * hackagebot xlsx 0.1.2 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.1.2 (KirillZaborsky)
13:43:42 <zwaefawef> i will finish school this year
13:43:56 <bergey`> hftf: The line MetaValue(..) exports the constructors of MetaValue
13:44:09 <zwaefawef> Welkin: why skip university?
13:44:14 <Ashy> Welkin: uni was where i made a whole bunch of lifelong adult friends and had the an amazing time
13:44:17 <Welkin> zwaefawef: it's a waste
13:44:20 <hftf> Oh, I see. But I wasn't able to use MetaMap in my function signature
13:44:24 <Ashy> there's more to life than just earning money
13:44:28 <Welkin> I did have fun in uni, but it was not worth the cost
13:44:41 <Welkin> it held me back too
13:44:48 <Welkin> too much busywork nonsense
13:44:54 <Ashy> ah true, it's very expensive in america
13:45:04 <dhalgren> prob depends on the specific country and hiring practices there, Welkin. can be a big deal on the job market however unreasnobly, and free. Welkin
13:45:09 <Welkin> too much focus on grades and exams
13:45:15 <Welkin> not enough on learning
13:45:20 <Ashy> in australia the gov gives you essentially interest free loans and you don't have to pay them back unless you earn a certain amount each year afterwards
13:45:38 <tzh> hftf: MetaMap is a constructor of type MetaValue, not a type itself, so you wouldn't be able to use it in a type signature regardless
13:45:45 <hftf> Oh, that's right
13:46:12 <hftf> So I would have to either use MetaValue in the signature and cover all the cases
13:46:32 <hftf> or hardcode the constructor type as i did
13:46:33 <dhalgren> Ashy: in at least some european countries, there's a quite affordable tuition at worst, cca 500-1000euro/year
13:46:45 <dhalgren> its shitty in consequence though :)
13:46:47 <zwaefawef> how to get an entry to the field then?
13:47:00 <Welkin> zwaefawef: entry to what field?
13:47:03 <Welkin> programming?
13:47:05 <Welkin> anyone can do it
13:47:05 <zwaefawef> yes
13:47:09 <Welkin> just start writing programs
13:47:13 <hftf> you can use your keyboard for data entry into the text field
13:48:18 <Ashy> zwaefawef: cost aside, a uni degree will teach you a lot and combined with some kind of portfolio of your own stuff will greatly increase your hiring chances
13:48:35 <Welkin> Ashy: portfolios don't help
13:48:43 <Welkin> if your goal is to get a job, connections/networking is what you need
13:48:46 <Welkin> nothing else matters
13:48:54 <Welkin> you don't even need to have the actual skills
13:48:54 <Ashy> that too
13:49:23 <Welkin> you can learn anything you need to know when the time comes anyway
13:49:28 <Welkin> that's how it works in the real world
13:49:36 <Welkin> unlike in school where you are held back for no reason at all
13:49:43 <Ashy> but we're trying to encourage a young programmer to discover the joy of programming here, not get them into the corporate grind as efficiently as possible
13:50:04 <Welkin> hm, well then the best way to do that is to find someone you want to build, and build it
13:50:10 <Welkin> like a video game, or a web application
13:50:14 <Welkin> something*
13:50:39 <Welkin> classes will destroy any joy that there may be
13:51:05 <Ashy> i had a different experience at uni then
13:51:48 <zwaefawef> Welki, Ashy what are you both working on now?
13:52:00 <zwaefawef> Welkin, Ashy what are you both working on now?
13:52:04 <Welkin> zwaefawef: I build web applications
13:53:11 <xpilot> hi, has anyone run into "bad interface file" problems when cabal installing?
13:53:34 * hackagebot logger 0.1.0.2 - Fast & extensible logging framework  https://hackage.haskell.org/package/logger-0.1.0.2 (danilo2)
13:53:48 <monochrom> school creates or destroys learning depending on the teaching approach, e.g., "let me take you on a journey" vs "this is a military camp"
13:53:55 <Ashy> zwaefawef: i've quit my job and am about to go on a long term holiday to taiwan haha
13:54:08 <Ashy> but yeah i work on web apps using c# mostly
13:54:25 <Ashy> would love to work with haskell but haven't found anyone in australia using it yet
13:54:36 <dhalgren> its prob most effective to learn anything autodidactically, sure Welkin. But even a poor uni program can be at least a list of references and some resources for reasonably structured learning plans, and perhaps even a reasonably intelectually stimulating environment/group of peers. 
13:56:36 <monochrom> even the presence of grading can create or destroy learning depending on how it is done, e.g., "I'm fine with giving you all A+'s if you happen to all meet my non-moving-target criterion" vs "the university has a policy against more than 10% A+'s"
13:58:19 <hftf> johnw bergey` tzh: thanks for the help.
13:58:22 <monochrom> and yes school is where you seed your network
13:59:06 <dhalgren> I'd never do it if the price was a small fortune and/or debt slavery though..
14:00:11 <monochrom> true, I was in Hong Kong and then in Canada. both places had cheaper university than the US
14:00:30 <monochrom> but not as cheap as Sweden, of course :)
14:00:39 <zwaefawef> do you have to pay for the university there?
14:01:09 <monochrom> yes. but only a small fraction of the true cost. government pays more.
14:02:10 <monochrom> Sweden is government pays all
14:03:17 <bear`> well Sweden can afford to
14:03:34 * hackagebot Michelangelo 0.2.3.0 - OpenGL for dummies  https://hackage.haskell.org/package/Michelangelo-0.2.3.0 (SwiftsNamesake)
14:03:40 <louispan> Is there a way to derive an instance of MonadFree from RandT which is an newtype wrapper around StateT without modifying the source for RandT?
14:03:40 <louispan> RandT currently doesn't derive from MonadFree.
14:03:48 <louispan> http://lpaste.net/145858
14:03:59 <dhalgren> I'd be surprised if price was a significant barrier to say 90%+ of population anywhere in continental europe. Think some german students told me of paying 500euro/year. I've seen up to 100eur/yr. The principle is that at least student that don't flunk years are supposed to get it for free. Otoh, anglosaxon universitied with fat tuitions dominate university rankings so I guess the system might have demerits as well.
14:04:17 <dhalgren> *up to 1000eur/yr
14:05:31 <zwaefawef>  dhalgren: i guess ive read that in germany the "studiengebuehr" (paying for attending university) was abolished
14:06:27 <dhalgren> I believe they mentioned some back-and-forth on that ; it was some years ago...
14:07:09 <Taneb> I'm paying £9000 a year for tuition, but I have a government loan covering that which does not affect my credit rating which I never expect to repay
14:07:25 <monochrom> if you want to look at tuition fee vs student performance, don't forget to look at scholarship offerings as well. that changes everything.
14:07:28 <Welkin> Taneb: lol
14:08:06 <Welkin> Taneb: have fun being hunted down by debt collectors
14:08:28 <jle`> louispan: if MonadRandom exports the RandT constructor, you can use standalone deriving with generalized newtype deriving, i'd think
14:09:04 <Taneb> Welkin, it's taken out of my wages if I choose to work in the UK, I believe
14:09:16 <Taneb> And cleared when I turn 55
14:09:18 <glguy> I don't have the full context, but the financing of education is beyond the topic of #haskell
14:09:18 <jle`> louispan: deriving instance (Functor f, MonadFree f m) => MonadFree f (RandT s m) ... i think that's the syntax
14:09:24 <Ashy> Welkin: america has an incredibly agressive debt system compared to many other western countries
14:09:27 <jle`> i always mess up standalone deriving syntax though
14:09:32 <jle`> also what is going on in this channel
14:09:47 <louispan> jle: I'm not sure what you mean. Do you mean I can create my own newtype wrapper around RandT and deriving from MonadFree?
14:09:50 <Welkin> jle`: talking
14:10:09 <jle`> louispan: no, put that line i wrote in your code and it should derive the MonadFree instance
14:10:20 <jle`> louispan: as long as the RandT constructor is exported
14:10:24 <dhalgren> jle`: sry, wandered wayy offtopic
14:11:04 <jle`> louispan: it might also work if the constructor is not exported...i'm not quite sure :)
14:12:09 <louispan> jle: I'm lost... I can't see your change in http://lpaste.net/145858
14:12:23 <louispan> jle: silly me I see your message above
14:12:57 <lpaste_> jle` annotated “MonadFree instance for RandT” with “MonadFree instance for RandT (annotation)” at http://lpaste.net/145858#a145859
14:13:06 <jle`> there you go :)
14:13:54 <jle`> if it doesn't work it might be because RandT isn't exporting, or that standalone deriving and generalized newtype deriving don't work together that way
14:14:04 <louispan> jle: Thank you, you are awesome. I didn't know about standalone deriving syntax. I'll give it a go when I get home tonight.
14:14:11 <jle`> np!
14:14:19 <Welkin> @where learnhaskell
14:14:19 <lambdabot> https://github.com/bitemyapp/learnhaskell
14:15:37 <statusfailed> Does category theory require set theory?
14:15:46 <dmj`> jle` is pretty awesome, in general
14:16:04 <kaste> no, but it gives you a set of examples, that helps you visualize statusfailed 
14:16:04 <monochrom> no, but can help
14:16:24 <statusfailed> err, sorry, I meant does it rely on the axioms of set theory, i.e. is it built on it?
14:16:29 <monochrom> can also hurt
14:16:36 <monochrom> no
14:16:52 <statusfailed> so it's an alternative foundation of mathematics?
14:17:55 <monochrom> can be, but I don't think many people actually use it as.
14:18:50 <statusfailed> interesting, thanks!
14:28:09 <Adeon> I have a little problem with specifying a dependency in stack.yaml file
14:28:23 <Adeon> the dependency is a haskell project on github
14:28:34 <Adeon> but it's not located in the root of the git repository on github
14:29:14 <Adeon> is there a field I could specify in stack.yaml for a dependency that "please use this subdirectory from this git repository"
14:31:14 <Welkin> Adeon: yes
14:31:46 <Cale> Does stack really care?
14:31:47 <Welkin> Adeon: - location ...
14:31:53 <Welkin> git: ...
14:31:56 <Welkin> commit: ...
14:32:13 <Welkin> subdirs: 
14:32:14 <Adeon> yeah stack cares, it doesn't seem to find it on its own
14:32:18 <Adeon> ooh, subdirs
14:32:19 <Welkin>   - yesod-bin
14:32:21 <Welkin> for example
14:32:24 <Adeon> let me try that
14:32:33 <Cale> Interesting
14:32:38 <Welkin> subdirs is linued up vertically with location
14:32:40 <Cale> I didn't know that stack had anything to do with git
14:32:45 <Welkin> lined*
14:33:35 * hackagebot safecopy 0.9.0 - Binary serialization with version control.  https://hackage.haskell.org/package/safecopy-0.9.0 (JeremyShaw)
14:34:09 <Adeon> it's working
14:34:12 <Adeon> thank you Welkin
14:34:13 <Welkin> Cale: yes, it is quite useful
14:34:33 <Adeon> yeah I only learned recently it can take git dependencies
14:34:46 <Cale> fsvo useful which involves using git more than absolutely necessary
14:34:51 <Cale> ;)
14:35:01 <jle`> new safecopy?
14:35:27 <Welkin> Cale: so you don't need to maintain multiple local copies of some modified library on every machine
14:35:46 <Cale> It makes me so sad that everyone in the Haskell community has slowly moved away from darcs
14:35:48 <Welkin> or for a library you wrote which is not on hackage
14:37:09 <Cale> I have to deal with git on a daily basis for work, and I'm constantly confused by its behaviour and user interface.
14:37:30 <Cale> (at least, whenever I need to do anything other than push or pull)
14:37:48 <Welkin> that is all I do
14:38:00 <Welkin> pull, push, add, commit
14:38:04 <Welkin> I don't even use branches
14:38:14 <kadoban> Welkin: branches are the best part
14:38:56 <Adeon> in my case I just don't care when git works well enough
14:39:03 <Adeon> I'm a functional language enthusiast, not VCS enthusiast!
14:39:19 <Adeon> also company uses git for all projects so there's that as well
14:40:29 <Adeon> I do use xmonad though so maybe the gods of haskell look upon me favorably
14:41:44 <utdemir> Hey. I'm trying to use aeson-lens, but stuck when trying to use indexed traversals. Assume I have json "{ a: 1, b: 2 }" and I want to have [(a, 1), (b, 2)]. Now "json ^@.. members . _Int" works. But what if the values are one level deeper? Why doesn't 'json ^@.. members "value" . _Int' gives me a weird type error?
14:42:20 <utdemir> Sorry, the last code is 'json ^@.. members . key "value" . _Int'.
14:43:35 * hackagebot scientific 0.3.4.3 - Numbers represented using scientific notation  https://hackage.haskell.org/package/scientific-0.3.4.3 (BasVanDijk)
14:44:45 <Cale> Adeon: well, if you like git, that's fine. I just personally find it bewilderingly opaque, and am a bit salty about the extent to which I have to interact with it.
14:46:45 <phaazon> gosh
14:47:35 <phaazon> implementing all the required instances to have (MonadResourceT m,MonadError e m) => m is damned annoying :(
14:47:48 <phaazon> MonadResource*
14:50:56 <phaazon> hm
14:51:05 <phaazon> I guess I should use MonadThrow instead of MonadError
14:51:09 <phaazon> it sounds more flexible
14:51:19 <phaazon> especially because of Rank2Types
14:56:07 <dhalgren> Cale: is it feasable to keep one's code in darcs yet mirror it practically on git(hub)? I know there's an incremental automatic push from darcs to git now, but not the other way around; would taking say a pull req on github be too ackward in such a workflow, or does it say mesh naturally -- say review then apply diff to darcs & push or some such flow? I'm pretty sure medium-sized codebase , for which darcs is supposed to be reasonable,
14:56:07 <dhalgren> is as far as I'll need, and simplicity of the tool's UI appeals to me
14:56:27 <Cale> dhalgren: Yeah, I dunno
14:59:11 <dhalgren> k. anyhow I too am sad about its increasing obscurity.. 
15:02:57 <bernalex> nobody answered me on the MLs, but I wonder if darcs has gotten some proper way of verifying integrity of things? i.e. OpenPGP signing
15:13:38 <dhalgren> bernalex: no idea but to quote their faq:  Darcs gives you a mechanism to sign individual patches (using GPG), but it doesn’t yet support the signing of repositories.
15:14:06 <dhalgren> presuming this is even uptodate that is
15:18:39 <tosun> Why is `cabal test` suppressing the test output?
15:23:12 <Bashmetim> Is anyone here a stack wizard?
15:23:37 * hackagebot linode 0.2.0.0 - Bindings to the Linode API  https://hackage.haskell.org/package/linode-0.2.0.0 (Helkafen)
15:23:39 <LokiSnake> Bashmetim: not sure about wizard status, but plenty to use stack here
15:23:46 <LokiSnake> there's also #haskell-stack
15:24:26 <Bashmetim> oh, that might be more up my ally
15:27:33 <ghobo> Has anyone built session handling for servant-based servers?
15:29:06 <mmachenry> Bashmetim: I suggest just asking a question.
16:18:17 <lpaste_> louispan annotated “MonadFree instance for RandT” with “MonadFree instance for RandT (annotation) (annotation)” at http://lpaste.net/145858#a145861
16:21:03 <louispan> Does anyone know why this particular usage of standalone deriving will fail when a normal instance declaration is ok?
16:21:03 <louispan> I'm playing around with trying to deriving a MonadFree instance for RandT (assuming RandT constructor can be exported).
16:21:03 <louispan> http://lpaste.net/145858#a145861
16:22:17 <louispan> instance (Functor f, MonadFree f m) => MonadFree f (WandT g m)
16:22:17 <louispan> vs
16:22:17 <louispan> deriving instance (Functor f, MonadFree f m) => MonadFree f (WandT g m)
16:23:01 <tommd> Well not every class is deriveable.
16:23:19 <tommd> It takes special compiler machinery to derive classes.
16:23:27 <louispan> Ah, that makes sense. The generic machinery hasn't been implemented for it
16:24:29 <jophish> I have these lines next to one another and I'm sure there's some way to combine the two: let foo = coerce :: [Bar phantom] -> [Bar phantom']; baz = coerce :: (Bar phantom -> Bar phantom) -> Bar phantom' -> Bar phantom'
16:26:59 <louispan> Since I can declare the MonadFree for RandT instance trivially (i.e., no implementation), is it still a sin to declare it in an OrphanInstance, or shall I use newtype wrappers for future safety?
16:27:52 <tommd> It is a sin as it is not composible with any code base that has itself derived or built an instance.
16:28:41 <louispan> Sigh, it's hard to be a good boy.
16:29:37 <jophish> louispan: almost every time the compiler tells me I'm not a good boy it has my best interests at heart
16:29:59 <jophish> although I might only realize that later
16:32:33 <Cale> louispan: Are you writing a library or an application?
16:32:49 <Cale> louispan: Orphan instances are not an issue at all for application code.
16:34:11 <glguy> except when you update your dependencies and someone else provided the same orphan
16:34:32 <louispan> Cale: I'm writing an application. I guess that makes sense. As long as everyone is nice and doesn't have orphaned instances in library code, then application code can have orphaned instances without silently affecting others.
16:34:33 <kadoban> glguy: That's pretty easy to deal with though, in practice.
16:34:53 <glguy> kadoban: if they wrote the same instance as the one you wanted, perhaps
16:34:53 <kadoban> At least it is when there's like … one possible implementation.
16:35:39 <glguy> People like writing orphans for things like To/FromJSON or Binary where that's not necessarily the case
16:52:42 <alexeyzab> :q
16:52:48 <alexeyzab> woops, ignore that
17:08:40 * hackagebot scientific 0.3.4.4 - Numbers represented using scientific notation  https://hackage.haskell.org/package/scientific-0.3.4.4 (BasVanDijk)
17:14:41 <DanC__> what's the normal way to set up quickcheck testing in a .cabal file? I'm getting errors that suggest all the build depends under my main have to be under my test suite too. Is there some way to factor out the common parts?
17:15:11 <dcoutts> DanC__: you can have your testsuite depend on the library, but then it can only access the public api of the library
17:15:40 <DanC__> I should build a library?
17:16:12 <dcoutts> DanC__: it's actually quite common for testsuites to use the source files directly, since that way they can use internal modules, and can even build them differently (e.g. using cpp to expose extra stuff)
17:16:42 <DanC__> this example (nominated from a stack overflow post) seems to repeat all the build dependencies. https://github.com/fatuhoku/haskell-minecraft-tool/blob/master/haskell-minecraft.cabal
17:17:02 <dcoutts> DanC__: right, that's what you have to do if you use the source files directly
17:17:26 <DanC__> I see...
17:17:26 <broma0> anyone familiar with how database connections work? i know how general that is, but im writing a DB-like program and I'm thinking server/client will communicate over a TCP connection, but i'm at a loss for how request/response is modeled over a simple TCP connection
17:18:08 <dcoutts> DanC__: at some point in the future we'll likely add some mechanism to 'include' common settings into multiple components, but 'til then the only mechanism is to use a lib, and you don't want to do that here.
17:18:31 <DanC__> maybe a library is the way to go for me
17:18:45 <DanC__> it's not yet clear to me how to depend on a library
17:26:20 <DanC__> "Perhaps you need to add ‘GenericPretty’ to the build-depends in your .cabal file." er... but... it's already there.
17:26:38 <dcoutts> DanC__: to the right component?
17:27:03 <DanC__> I changed the 1st component from executable to library
17:27:16 <DanC__> and changed other-modules to exposed modules
17:27:20 <DanC__> and pretty much left the rest alone
17:29:18 <DanC__> oh... let's see... the library builds when I take the test suite and executable out.
17:30:09 <dcoutts> DanC__: you can ask cabal to build specific components, cabal build $thething
17:30:13 <dcoutts> to help test that
17:32:32 <DanC__> how do I *not* use the sources directly when I build my test suite?
17:34:19 * DanC__ reads https://www.haskell.org/cabal/users-guide/developing-packages.html ...
17:34:51 <dcoutts> DanC__: have to separate the src dirs, otherwise it always picks up the source version of the module in preference
17:35:03 <DanC__> ah
17:38:37 <DanC__> maybe repeating build-depends isn't so bad after all.
17:38:55 <DanC__> this is a fork of somebody else's code and I'm not sure I want to move stuff around so much
17:39:08 <DanC__> that is: I'm not sure *he* wants stuff moved around so much
17:45:53 <dmwit> Trying to install darcs from Hackage, I get `Error: Could not find module: Version with any suffix`.
17:46:28 <dmwit> Following the suggestion on http://chrisdone.com:10001/browse/haskell/?events_page=334542, I unpacked it and tried running `runhaskell Setup.lhs configure --user` manually, but I get the same error.
17:47:01 <dmwit> dcoutts: Since you've been around in the last few minutes, and you made the suggestion I'm linking to, maybe I can poke you for help. =)
17:50:30 <dcoutts> dmwit: the Setup.lhs generates it
17:50:35 <dcoutts> see generateVersionModule
17:51:29 <dmwit> From what I see, almost every command invokes that, through commonBuildHook.
17:51:37 <dmwit> But when I try to configure using Setup, it still reports that error.
17:51:39 <lamefun> "case ... of Right (number, Text.empty) -> ..." gives "Qualified name in binding position: Text.empty" - why? Text is Eq, it can totally do that match!
17:52:01 <dmwit> lamefun: Because pattern matches don't use Eq.
17:52:17 <dmwit> lamefun: You might like `Right (number, text) | text == Text.empty -> ...`
17:52:19 <lamefun> Why?
17:52:35 <dmwit> How would you implement Eq if pattern matches used it?
17:53:00 <dcoutts> (except integer and string literals which actually do use Eq)
17:53:01 <lamefun> Why do all pattern matches have to use Eq?
17:53:01 <dmwit> (I don't consider "compiler built-in" to be a particularly satisfactory answer to that question.)
17:53:31 <dmwit> Pattern matches simply are not equality comparisons.
17:53:42 * hackagebot persistable-types-HDBC-pg 0.0.1.1 - HDBC Convertible instances and HRR persistable instances of PostgreSQL extended types  https://hackage.haskell.org/package/persistable-types-HDBC-pg-0.0.1.1 (KeiHibino)
17:54:00 <lamefun> eg. (SomeType member1 member2) or even True patterns don't have to use Eq
17:54:17 <koz_> Hi Haskellers! I have the following code, but it throws a gigantic type error and I'm not sure what I'm missing: http://paste.rel4tion.org/120
17:54:21 <dmwit> lamefun: In your example, replace SomeType with (,) and you will understand.
17:54:27 <dcoutts> dmwit: no sure. I cannot reproduce it. It just works for me. Try tracing the generateVersionModule, see when it's being called and where it puts the file
17:54:42 <dcoutts> dmwit: it's supposed to go into dist/build/autogen/
17:54:50 <dcoutts> which is indeed where it gets put for me
17:54:53 <koz_> I wanted children in the record to be a Map mapping String to CTrieNode, but I think I got that down wrong.
17:56:15 <dmwit> dcoutts: Maybe I will try in a sandbox. I'm using the controversial cabal-no-reinstall; perhaps this is an instance of where it matters somehow.
17:56:27 <dmwit> lamefun: I will spend a bit more words on explanation once I get darcs building. Hold tight.
17:56:43 <dcoutts> dmwit: I don't think so. What could matter is using a different dist dir, which is something sandboxes do do.
17:56:48 <DanC__> simpson, I'm really losing trying to use Test.hs
17:57:05 <DanC__> wrong channel... (though true enough...)
17:57:32 <dcoutts> dmwit: ie it might well fail in a sandbox due to not respecting the different dist dir. ie it might always put it into dist/build/autogen/ and not into the one specified by --build-dir, which is what sandboxes use.
17:58:00 <dmwit> dcoutts: oh, dangit
17:58:08 <dmwit> So it will fail for a completely unrelated reason.
17:58:11 <dcoutts> dmwit: btw, not to confuse your explanation to lamefun, but it actually is possible to get ghc to generate an Eq constraint, e.g. \s -> case s of "foo" -> () :: (IsString a, Eq a) => a -> ()
17:58:28 <c_wraith> koz_: it'd help a lot if the paste contained the error.
17:58:35 <lamefun> Can't GHC simply handle "Right (number, Text.empty)" as "Right (number, tmp) | tmp == Text.empty"?
17:58:37 <dmwit> dcoutts: Right. Thanks for keeping me honest.
17:59:01 <dcoutts> lamefun: in principle yes, but that's not how Haskell is defined.
17:59:04 <dmwit> lamefun: It could, but I think it would be brittle; e.g. how would one tell the difference between wanting to bind a name and wanting to do an equality comparison?
17:59:18 <dmwit> lamefun: If your answer is "when it's qualified, do a comparison", then I think that would be very brittle to refactoring.
17:59:33 <shachaf> It's also trickier than you might think to do that.
17:59:44 <dcoutts> what's more plausible is for user-defined constants, which is what the string literal example is about
17:59:44 <shachaf> Even handling "foo x x = ..." as "foo x y | x == y = ..." is tricky.
17:59:51 <shachaf> In the presence of laziness.
18:00:10 <koz_> c_wraith: http://paste.rel4tion.org/121
18:01:01 <barrucadu> koz_: Function application has the highest precedence: null . children u == null . (children u)
18:01:09 <barrucadu> Not (ull . children) u, which is I think what you wanted
18:01:12 <barrucadu> *null
18:01:16 <dmwit> barrucadu: (second highest, after record update -- that's caught me a few times)
18:01:26 <dcoutts> dmwit: yes, looks like it doesn't respect the --builddir flag. So it will actually only work when done as a user wide install, not in a sandbox. But that's odd since the former is exactly where it's not working for you.
18:01:26 <koz_> barrucadu: Thanks!
18:01:45 <koz_> barrucadu: So did I define the Map correctly?
18:01:54 <koz_> It's Map.Map KeyType ValueType?
18:02:11 <barrucadu> Yes, that's right
18:02:42 <dmwit> dcoutts: It is weird. There's a ton of warnings about depending on multiple versions of the same package, but I don't think that should actually be a problem for the configure step, right?
18:02:45 <koz_> OK. I basically started Haskelling today after reading the Wikibook.
18:02:59 <dmwit> dcoutts: I'll try to resolve those warnings anyway and see what happens.
18:04:43 <koz_> barrucadu: What's the easiest way to test for a singleton-list? Pattern-match to (x : []) ?
18:04:53 <barrucadu> Or pattern match [x]
18:05:00 <koz_> barrucadu: OK, that works.
18:08:15 <barrucadu> If you don't need to refer to the value, you can use _ in patterns to mean "don't care". [x] is a pattern for a singleton list, and gives the element the name x. [_] is a pattern for a singleton list which doesn't give the element a name.
18:08:55 <pavonia> Given the following definitions http://lpaste.net/145864 is there a way to allow the user to use getFoo without being able to use the functions from FooC directly?
18:08:59 <dmwit> dcoutts: ugh
18:09:14 <koz_> barrucadu: I'm not sure how to use the type constructor for my CTrieNode type to make a new CTrieNode x that's an exact copy of CTrieNode y, except with a few things changed: http://paste.rel4tion.org/122
18:09:38 <dmwit> dcoutts: Is there a way to tell Setup to use a particular hash package ID? I've now got several parsec-3.1.9's installed, and only one of them will avoid the "depends on different versions of text" warning.
18:11:16 <dmwit> found --dependency
18:12:20 <barrucadu> koz_: Because it's a record, you can use record syntax: CTrieNode { subtreeSize = ..., children = ... }. If you only want to change part of it, you can use record update syntax: foo { field = bar }
18:12:35 <koz_> barrucadu: Perfect, thanks!
18:13:15 <barrucadu> I have to go to bed now, but I'm sure other people will be happy to answer your questions. Good luck!
18:14:00 <koz_> barrucadu: Thanks - I may need it.
18:14:59 <dmwit> dcoutts: Well, --dependency doesn't seem to work anyway.
18:15:23 <dmwit> custom Setup.* -= 1
18:19:51 <koz_> If I wanted to use record update syntax with a structure foo that had a single element i of type Int to make a structure bar where i was 1 greater, how would I phrase this?
18:20:14 <geekosaur> foo { i = foo i + 1 }
18:20:22 <geekosaur> er
18:20:29 <koz_> geekosaur: That easy, huh. Thanks.
18:20:30 <geekosaur> foo { i = i foo+ 1 }
18:20:54 <koz_> Wait, hold on, what's going on there?
18:20:57 <koz_> Why foo+?
18:21:02 <geekosaur> the inner one is just a normal record accessor taking the original one as a parameter
18:21:10 <geekosaur> the original record that is
18:21:19 * geekosaur is ... not doing well tonight, it seems :/
18:21:37 <jle`> we all have those days
18:22:05 <geekosaur> record { field = {- expr which may include getting the original value with a normal `field record` accessor -} }
18:23:07 <geekosaur> I just accidentally removed the space when fixing it...
18:23:32 <geekosaur> (had foo and i reversed)
18:23:34 <dmwit> > lex "foo+"
18:23:36 <lambdabot>  [("foo","+")]
18:23:41 <dmwit> > lex "foo +"
18:23:42 <lambdabot>  [("foo"," +")]
18:24:03 <geekosaur> remember that any field of a record is also a function which takes a record as parameter and returns the value of that field
18:27:04 <Hijiri> :t lex
18:27:05 <lambdabot> ReadS String
18:27:59 <dmwit> Hijiri: Kind of crazy that there's a full-fledged Haskell lexer in the Prelude, ain't it?
18:28:19 <Hijiri> that's in the prelude?
18:28:25 <dmwit> :t Prelude.lex
18:28:26 <lambdabot> ReadS String
18:28:35 <dmwit> :t Prelude.parse
18:28:37 <lambdabot>     Not in scope: ‘Prelude.parse’
18:28:37 <lambdabot>     Perhaps you meant one of these:
18:28:37 <lambdabot>       data constructor ‘Prelude.False’ (imported from Prelude),
18:28:42 <dmwit> too bad =P
18:28:43 * hackagebot exception-hierarchy 0.0.0.1 - Exception type hierarchy with TemplateHaskell  https://hackage.haskell.org/package/exception-hierarchy-0.0.0.1 (YoshikuniJujo)
18:37:27 <koz_> I'm having trouble figuring out how I would write this: http://paste.rel4tion.org/123
18:37:41 <koz_> I keep getting trapped in monad-land.
18:38:57 <dmwit> What is CTrieNode? Also, are you sure `[s : ss]` is really the pattern you want?
18:39:36 <dmwit> (I'm guessing no, based just on naming: note that `s` is not a `String` there, but a `Char`!)
18:40:16 <koz_> dmwit: http://paste.rel4tion.org/124 <- CTrieNode. Also, wait what? My type sig is CTrieNode -> [String] -> CTrieNode.
18:40:29 <dmwit> I'm very aware of your type signature!
18:40:50 <dmwit> So I'm glad you're surprised by my claim, since it means you have a genuine bug. ;-)
18:41:06 <koz_> I'm a bit confused as to how this could arise.
18:41:23 <dmwit> koz_: `(s : ss)` is a pattern that matches a non-empty `[String]`, binding `s` to the head `String` of the list and `ss` to the remaining `String`s.
18:41:38 <koz_> Oh.
18:41:48 <koz_> Then [s : ss] would be?
18:41:52 <dmwit> koz_: `[s : ss]` is a pattern that matches a one-element `[String]`, binding `s` to the head `Char` of that element and `ss` to the remaining `String`.
18:41:59 <koz_> Oh, derp.
18:42:22 <koz_> OK, you're right (s : ss) is what I really wanted.
18:43:27 <koz_> The issue I'm having is that the obvious recursive case off the first guard doesn't even get off the ground because I end up in monad-land from Map.lookup.
18:43:30 <dmwit> koz_: Instead of checking whether `s` is a member of the map, you'd probably do better just looking `s` up in the map to get the (possible) child.
18:43:41 <koz_> And then guard on Nothing?
18:43:44 <dmwit> :t Data.Map.lookup
18:43:45 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
18:44:10 <monochrom> you're only in Maybe land.
18:44:24 <dmwit> koz_: I would pattern match. As in `insertList ctrie (s:ss) = case Map.lookup s (children ctrie) of Nothing -> ...; Just child -> ...`.
18:44:30 <monochrom> and it's rightfully Maybe because what do you do if the lookup is a "not found"?
18:44:44 <koz_> monochrom: Yeah I understand that. 
18:44:44 <Jello_Raptor> Has anyone here used DataKinds for anything interesting? I can't think of a case where I don't end up with some data declarations that exist mainly for their kinds and other data declarations that are actual values. Barring a few basic functors there's nothing I can think of that uses both for a single datatype, and i can't think of anything that will use both the type and value representations of datakinded constructors together. 
18:44:55 <dmwit> monochrom: Well, he has guarded against that possibility. Though I think a pattern match is better than a guard here.
18:45:05 <koz_> dmwit: How would I write this match?
18:45:10 <Hafydd> @let data D = D{ f :: [Int] }
18:45:12 <lambdabot>  Defined.
18:45:19 <dmwit> koz_: I think I just posted some code showing how, didn't I?
18:45:33 <koz_> Oh, whoops. Too much text in chan. Looking now.
18:45:46 <monochrom> ok, then you will need to read my http://www.vex.net/~trebla/haskell/crossroad.xhtml
18:46:32 <dmwit> Jello_Raptor: Why do you consider applications that have some data declarations that exist only for their kinds to be uninteresting?
18:47:08 <koz_> dmwit: Thanks - that helps heaps!
18:47:36 <koz_> monochrom: OK, reading.
18:48:35 <koz_> Is the list length function called length in Haskell?
18:48:42 <monochrom> yes
18:48:58 <Jello_Raptor> dmwit: for the purposes of the question, there's a stack of nice uses cases for that I can think of that are valuable. I just keep on wanting to shuffle between type level constructs and value level constructs, and if that's enabled anywhere, it would be with DataKinds. 
18:50:19 <koz_> Also, if I destructure a list like (s : ss), how can I get a reference to the whole list?
18:50:50 <dmwit> koz_: wholeList@(s:ss)
18:50:52 <Jello_Raptor> dmwit: it's just a turn of phrase basically, meant to allow me to vaguely define a class of applications that I am having trouble being precise about.
18:50:56 <koz_> dmwit: THanks!
18:51:42 <dmwit> Jello_Raptor: Okay. There's a bunch of applications of singletons that I can think of; you might want to poke around for publications of Richard Eisenberg.
18:52:14 <dmwit> Jello_Raptor: Singletons are essentially types which can easily converted to values by virtue of there being only one inhabitant of the type.
18:52:38 <dmwit> (Note that the conversion probably doesn't choose that inhabitant -- just uses it to guide the conversion.)
18:52:52 <Jello_Raptor> dmwit: like the tags for Ether, and the like? 
18:53:36 <dmwit> Jello_Raptor: The common intro example is `data Nat = Z | S Nat`; it's easy to write `lower :: proxy (a :: Nat) -> Nat`.
18:54:08 <koz_> dmwit: I've got this so far - did I do anything insane? http://paste.rel4tion.org/125 <-- this Haskell paster is telling me things I don't get...
18:54:40 <dmwit> koz_: click them
18:55:00 <koz_> Wow...
18:55:08 <koz_> I didn't realize they were clickable!
18:55:17 <dmwit> koz_: I think `Just child -> insert child ss` is probably insane.
18:55:44 <koz_> dmwit: Why is it insane?
18:55:47 <dmwit> koz_: At a guess, you'd rather have something like `ctrie { children = Map.insert s (insert child ss) }`.
18:55:59 <koz_> Yeah, that seems more sane.
18:56:29 <jle`> is there a * -> * -> * kinded Functor typeclass somewhere?  with an fmap :: Functor2 f => (a -> b) -> f i a -> f i b ?
18:56:49 <jle`> oh i meant a k -> * -> *
18:57:39 <koz_> dmwit: Yeah, I get why it's insane now - it wouldn't return properly.
18:59:05 <koz_> dmwit: Thanks for that - I guess the syntactical changes are making me stupid or something. :P
18:59:24 <dmwit> jle`: If it were going to exist in a standard place, I would expect to see it here: https://hackage.haskell.org/package/prelude-extras-0.4.0.2/docs/Prelude-Extras.html
18:59:27 <dmwit> jle`: (but I don't)
18:59:38 <dmwit> koz_: You would have noticed pretty quickly with some testing. =)
18:59:52 <koz_> dmwit: Yeah - that would have been the next step.
19:00:02 <koz_> I also need a more thorough linter than GHC.
19:00:24 <dmwit> hlint exists (and gives output like what you clicked on)
19:00:31 <koz_> I guessed as much.
19:00:42 <koz_> I'm just checking if Flycheck supports it.
19:00:56 <jle`> dmwit: hm there's Functor (f a) => Functor (Lift2 f a)
19:01:00 <greymalkin> Is there a canonical, monadic "do this action only if <condition> is true"?  
19:01:09 <dmwit> :t when
19:01:10 <jle`> er wait, no, that won't work
19:01:11 <lambdabot> Applicative f => Bool -> f () -> f ()
19:01:28 <greymalkin> dmwit: *facepalm* thanks!
19:01:58 <jle`> i guess i'll make my own
19:02:14 <dmwit> jle`: It is a grand Haskell tradition.
19:02:38 <jle`> and the next step is to make a utilities package that has it and leave it to bitrot? :P
19:02:44 <dmwit> jle`: Exactly!
19:02:53 <koz_> jle`: That doesn't seem a Haskell-only tradition.
19:03:00 <koz_> At least not the utilities package + bitrot part.
19:03:03 <dmwit> jle`: Out of curiosity: why do you need to know `fmap2` works for all `i`? (Why doesn't `Functor` work?)
19:03:26 <dmwit> If you don't feel like sating my curiosity, I completely understand.
19:04:10 <koz_> Man, Haskell has *amazing* tooling.
19:04:16 <jle`> dmwit: existentials
19:04:20 <jle`> in a gadt
19:04:28 <dmwit> of course
19:04:45 <jle`> i have a GADT that takes (f :: k -> * -> *) as a parameter and does things with it assuming (f i) is a Functor
19:05:00 <jle`> but i can't write instance Functor (f i) => Functor blah
19:05:08 <jle`> cause i isn't even in the type of blah
19:05:32 <dmwit> Can the `Functor` constraint go on the existential? Or would that be breaking the fourth wall?
19:05:48 <dmwit> s/fourth wall/abstraction boundary/ (couldn't think of the word as I was typing)
19:06:40 <koz_> dmwit: Haskell breaking the fourth wall is an amusing thought.
19:08:46 * hackagebot tateti-tateti 0.1.0.1 - Meta tic-tac-toe ncurses game.  https://hackage.haskell.org/package/tateti-tateti-0.1.0.1 (alvare)
19:11:34 <dmwit> > 9^81
19:11:36 <lambdabot>  196627050475552913618075908526912116283103450944214766927315415537966391196809
19:11:52 <dmwit> Maybe not practical to brute-force solve.
19:12:14 <dmwit> (I guess I should have known that without any calculation, since 2^80 is also given that status by most.)
19:14:35 <koz_> OK, the order for foldr is foldr list base-case lambda?
19:14:39 <koz_> Or is it something else?
19:17:07 <dmwit> :t foldr
19:17:09 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
19:17:13 <dmwit> ...something else
19:17:59 <dmwit> I think it's pretty standard for catamorphism-like functions to put the thing they're destructing last. (Though that's just by convention.)
19:19:14 <ttt_fff> inside a MonadIO, is it posible to setup a "global variable" ?
19:19:29 <ttt_fff> I see "Monad IO m => MonadIO (StateT s m)"
19:19:33 <ttt_fff> but I don't see how do get a global out of this
19:20:03 <dmwit> :t newIORef
19:20:04 <lambdabot>     Not in scope: ‘newIORef’
19:20:05 <lambdabot>     Perhaps you meant ‘newSTRef’ (imported from Data.STRef)
19:20:05 <pavonia> ttt_fff: You can use an IORef or MVar
19:20:19 <ttt_fff> but then I have to "keep the IORef: around right?
19:20:23 <dmwit> Yes.
19:20:28 <ttt_fff> whereas, I'd like to stuff the IORef as a "state" into the MonadIO
19:20:30 <tabemann> the reason for this convention is because it makes more sense to do things that way due to the way partial application works
19:20:47 <ttt_fff> is it possible to do a "x <- newIORef; stuff x as a state into the MonadIO" ?
19:21:07 <dmwit> ttt_fff: You can define a new monad which offers that operation.
19:21:25 <ttt_fff> that's not an option; I'm using a really big and complicated monad which supports MonadIO
19:21:59 <dmwit> `newtype TTT_FFF s m a = TTT_FFF (ReaderT (IORef s) m a); instance MonadState s (TTT_FFF s m) where get = TTT_FFF (ask >>= liftIO . readIORef)`
19:22:14 <dmwit> `MonadIO` doesn't promise *anything* other than `IO` operations.
19:22:53 <dmwit> (oh, forgot `put v = TTT_FFF (ask >>= liftIO . flip writeIORef v)`)
19:23:01 <ttt_fff> dmwit: https://gist.github.com/bfaf0e602e877331d9b7
19:23:09 <ttt_fff> is what I have at my fingertips
19:23:15 <ttt_fff> is your sugestion to "wrap" the existing monad that I have ?
19:23:25 <ttt_fff> so I have this "MonadWidget'"
19:23:31 <dmwit> That's not a monad, but a class.
19:23:49 <ttt_fff> the "m" in taht class is a MOnad
19:23:57 <ttt_fff> or, the "m" in that class is an instance of MonadIO
19:24:06 <ttt_fff> err, sorry, the "h"
19:24:39 <pavonia> MonadRef sound like something that already supports storing data
19:24:58 <ttt_fff> https://gist.github.com/bfaf0e602e877331d9b7
19:25:21 <ttt_fff> https://hackage.haskell.org/package/ref-fd-0.4/docs/Control-Monad-Ref.html
19:25:24 <dmwit> pavonia: MonadRef probably offers ways to create and munge refs, but I doubt it offers a way to "hide" them in the ttt_fff seems to be asking for.
19:25:26 <ttt_fff> seems like we have to "keep the ref around"
19:25:37 <dmwit> Yes. You're not going to get away with avoiding that.
19:25:57 <dmwit> You can keep it around in many ways. But you have to keep it around.
19:26:22 <ttt_fff> dmwit: okay, I am now convinced that I need to either wrap the monad or keep the var around
19:26:25 <ttt_fff> thanks :-)
19:52:41 <jle`> dmwit: i don't like adding ad-hoc constraints like that to my types
19:53:14 <jle`> it sort of mixes the type with like, certain aspects of functionality that aren't too inherent to it
19:53:26 <jle`> what's next, adding Show a, Read a, Typeable a => to the constructors? :)
19:54:11 <jle`> ttt_fff: you can use Reader and IO if you want
19:54:30 <jle`> or (MonadIO m, MonadReader (IORef r m))
19:54:39 <jle`> er, MonadReader (IORef r) m
19:59:35 <pavonia> jle`: What adhoc constraints do you mean?
20:03:00 <jle`> pavonia: to my GADTs
20:03:22 <jle`> er, see the conversation above w/ dmwit for more clarification/context :)
20:04:54 <pavonia> Oh, that was another discussion
20:05:12 <ttt_fff> jle`: yes, readerT is the way to go
20:07:51 <jle`> ttt_fff: you can make your own data type, newtype HasRef r a = HR (IORef r -> IO a), and then have a runHasRef :: HR r a -> r -> IO a; runHasRef r (HR f) = newIORef r >>= f
20:08:49 <rvxi> what do people use for chunking through large files as-needed. Pipes?
20:08:59 <rvxi> Pipes + attoparsec somehow?
20:08:59 <jle`> or you can use ReaderT to avoid having to write your own Functor/Monad/Applicative instancs etc;  runWithRef :: ReaderT (IORef r) a -> r -> IO a; runWithRef r f = newRIORef r >>= runReaderT f
20:09:08 <jle`> i use pipes, a lot of people use conduits
20:09:57 <kadoban> rvxi: conduits or pipes seem to be the answer to that in general
20:10:01 <jle`> *ReaderT (IORef f) IO a
20:11:40 <rvxi> hm spacemacs's default haskell support  doesn't seem to be playing so well with cabal sandboxes...
20:12:35 <rvxi> why on earth is it trying to build cabal when I try to save my source file(!?)
20:28:51 * hackagebot simple 0.11.0 - A minimalist web framework for the WAI server interface  https://hackage.haskell.org/package/simple-0.11.0 (AmitLevy)
20:31:35 <Pamelloes> Is there a function for ensuring a Text has only a specific, limited set of characters in it?
20:32:11 <scshunt> Pamelloes: what do you mean by "ensuring"?
20:33:26 <Pamelloes> scshunt: The function should have a type somewhat remniscent of [Char] -> Text -> Maybe Text—if the Text only contains the specified characters, the function will evaluate to Just input, otherwise it will be Nothing.
20:33:51 * hackagebot http2 1.3.1 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.3.1 (KazuYamamoto)
20:36:29 <Pamelloes> Ah, lens doctests..... Here goes an hour or two of my life.
20:49:57 <rvxi> anyone here using spacemacs?
20:50:07 <bitemyapp> rvxi: tried it for 24 hours, dropped it.
20:50:19 <bitemyapp> rvxi: bcuz: https://github.com/bitemyapp/dotfiles
20:50:52 <rvxi> bitemyapp: you have too many dotfiles?
20:52:09 <rvxi> actually my quesiton isn't really specific to spacemacs. with ghc-mod integration in emacs, it highlights certain lines upon compilation. i have no idea how to figure out why the highlighted lines are highlighted
20:52:23 <rvxi> the code compiles so it's not a compilation error ...
20:53:59 <kadoban> rvxi: Probably going to be pretty hard to guess without an example. Linting errors maybe?
20:54:14 <rvxi> bitemyapp: i've tried it for a few days. so far it seems really promising. I went from vi to emacs, and I always missed  vi's 'composable grammar'. The way the leader key works is also much more discoverable
20:54:59 <rvxi> kadoban: yeah, i'd guess so. i wish I knew how to show the linting error though
20:55:35 <rvxi> it's not like an IDE where i could just mouse over it
20:56:46 <rvxi> well here is one highlighted line:
20:56:47 <rvxi> content <- fmap decompress (B.readFile currFile)
20:57:02 <rvxi> does that look like something that should be hlinted?
20:58:58 <glguy> Not really, no.
20:59:00 <kadoban> Not sure … nothng really comes to mind as bad style in that exactly.
21:12:11 <koz_> I'd like to fold a HashMap's values using Data.HashMap.foldr, but I need to give a starting value, which for me has to be something from the HashMap itself. How can I easily obtain such a value?
21:12:23 <koz_> Should I just toList it instead?
21:12:38 <koz_> Or rather, elems.
21:13:12 <lethjakman-l> If you pass something directly to quickcheck are you just checking that it doesnt' throw an exception when passed the wrong data?
21:13:53 <lethjakman-l> By that, I mean when you're not wrapping hte function with a lambda. 
21:14:40 <pavonia> koz_: Maybe you want foldr1
21:14:52 <koz_> pavonia: Maybe.
21:15:16 <pavonia> :t foldr1
21:15:18 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
21:15:20 <koz_> That actually seems like the right mvoe. Thank pavonia!
21:15:30 <pavonia> No problem
21:15:43 <kadoban> koz_: Keep in mind that foldr1 is problematic if you're ever going to have an empty hashmap of course.
21:16:52 <koz_> Yeah - this situation should not arise.
21:17:13 <koz_> Can lambdabot look up function definitions?
21:17:38 <kadoban> koz_: Not really. It has @src, but … it's full of lies and not very complete.
21:18:00 <koz_> kadoban: OK, never mind then. I guess max is a function?
21:18:08 <kadoban> :t max
21:18:09 <lambdabot> Ord a => a -> a -> a
21:18:10 <koz_> And if so, which typeclasses do I have to implement to call it on my data?
21:18:16 <koz_> OK, that answers both.
21:19:04 <kadoban> :) Yeah, types of most stuff helps a lot, if not there's hoogle, I like the one at http://www.stackage.org/lts-3.15/hoogle?q=max
21:20:25 <koz_> kadoban: OK, thanks.
21:20:32 <koz_> Now I have to figure out how to make my type derive Ord properly.
21:20:37 <Iceland_jack> koz_: It seems you got that you need to implement an 'instance Ord YourType', but you can also have GHC write it for you automatically
21:20:58 <koz_> Iceland_jack: I think I'll roll my own. My type is a fairly involved compound data type.
21:20:59 <Iceland_jack>     data Person = Person String Int deriving (Show, Eq, Ord)
21:21:02 <Iceland_jack> I see
21:21:40 <koz_> Is there an example of a custom implementation of a typeclass somewhere I can look at?
21:21:41 <Iceland_jack> Just making sure, often times an involved data type are not the way to go in Haskell
21:22:00 <koz_> Iceland_jack: Treelike structure with a runtime-modifiable branching factor.
21:22:10 <Iceland_jack> You can use '-ddump-deriv' to see the derived code
21:22:27 <Iceland_jack>     ghci> :set -ddump-deriv
21:22:27 <Iceland_jack>     ghci> data Foo = Bar deriving (Eq, Ord)
21:22:56 <Iceland_jack> You can also Google "instance Ord"
21:23:20 <koz_> Do I need to define Eq as well as Ord?
21:23:23 <Iceland_jack> Yes
21:23:31 <koz_> OK, thanks.
21:25:21 <koz_> :t maximum
21:25:23 <lambdabot> (Ord a, Foldable t) => t a -> a
21:28:14 <koz_> What package should I use for unit testing?
21:28:23 <koz_> I have me some units to test.
21:28:51 <kadoban> koz_: HUnit or hspec seem to be the common ones. You'll want to look at quickcheck too, which isn't exactly unit testing, but it's really cool as hell.
21:29:06 <koz_> kadoban: Thanks - I'll look into those.
21:29:23 <koz_> Could anyone look at my code and tell me if it can be written more idiomatically?
21:29:24 <kadoban> koz_: There's ways to combine all of that, like test-framework or I think tasty is recommended now (so you can use all of the above, and more, without like 5 different test executables)
21:29:31 <koz_> It's ~40 lines.
21:29:43 <Iceland_jack> koz_: I second QuickCheck, if you haven't tried property-based testing you do yourself a favour and check it out
21:29:44 <kadoban> koz_: Did you throw it at 'hlint'? But sure if you post it usually someone will look.
21:30:03 <koz_> kadoban: Yeah, I did. http://paste.rel4tion.org/126
21:30:11 <koz_> I have hlint running in my Emacs via FLycheck.
21:31:04 <kadoban> koz_: Map is probably not an amazing name for a qualified module. I'd use HM or M. (Map is a common type name, so it's going to be a bit confusing).
21:31:15 <koz_> kadoban: HM seems good - I'll change it.
21:32:17 <pavonia> koz_: insert blankNode ["foo"] == insert blankNode ["bar"]?
21:32:34 <kadoban> koz_: Also, a common thing to do is to … add another line like import Data.HashMap.Strict (HashMap), so you can refer to the type without qualifying it. If you want to.
21:32:50 <koz_> pavonia: I only implemented those Eq and Ord to support the greatestSubtree method. I welcome alternatives.
21:32:55 <kadoban> Yeah, those Eq and Ord instances sound a bit funny.
21:33:18 <koz_> kadoban: Yeah - definitely not semantically-sensible. If you guys could suggest an alternative, I'd be most grateful.
21:33:30 <pavonia> koz_: Why not deriving the instances?
21:33:34 <kadoban> koz_: If that was the only reason, don't implement Ord and Eq, just use maximumBy
21:33:43 <koz_> :t maximumBy
21:33:44 <kadoban> Or that.
21:33:45 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
21:33:49 <koz_> kadoban: Yeah, it was the only reason.
21:35:12 <kadoban> > maximumBy (comparing fst) [(5,2), (2,5)]
21:35:16 <lambdabot>  (5,2)
21:35:22 <kadoban> koz_: In case that helps ^
21:35:39 <koz_> Is maximumBy not in Prelude?
21:35:52 <kadoban> Data.List maybe? I forget if it is or not.
21:36:55 <koz_> OK, rewrote that. Here's the new one: http://paste.rel4tion.org/127
21:38:08 <koz_> I get the feeling that lambda is too long somehow.
21:38:14 <kadoban> koz_: I think I'd call CTrieNode just … CTrie, no? blankNode is usually called 'empty'
21:38:23 <koz_> kadoban: Good point.
21:38:33 <kadoban> koz_: Yeah, you can fix it with 'comparing'
21:38:35 <kadoban> :t comparing
21:38:36 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
21:38:47 <kadoban> :t comparing fst
21:38:48 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
21:39:21 <kadoban> koz_: So, consider the type of subtreeSize, along with 'comparing'
21:39:25 <koz_> So would mine be 'comparing children'?
21:39:44 <kadoban> Well, I think you're trying to compare the size, not the children, right?
21:39:59 <koz_> Yeah, that. Derp.
21:40:03 <koz_> So 'comparing subtreeSize?
21:40:11 <kadoban> Yep, sounds good.
21:40:19 <kadoban> I forget where that's from. Might be Data.Ord
21:41:30 <koz_> OK, that gives me a less-than-pleasant error message.
21:41:47 <kadoban> Heh, uh oh.
21:42:56 <koz_> http://paste.rel4tion.org/128 <-- error msg
21:43:09 <kadoban> koz_: What's the code?
21:43:37 <MarcelineVQ> missing parens?
21:43:38 <koz_> kadoban: http://paste.rel4tion.org/129
21:43:53 <koz_> MarcelineVQ: You were right.
21:44:12 <koz_> L.maximumBy (O.comparing subtreeSize) elemList seems OK.
21:45:38 <koz_> Does maximumBy require at least one element like foldr1?
21:46:05 <kadoban> koz_: Yes
21:46:17 <koz_> OK, this means I need a stronger type.
21:46:22 <Iceland_jack> koz_: This is how you figure that out
21:46:25 <Iceland_jack> Two ways
21:46:26 <Iceland_jack> > maximumBy undefined []
21:46:27 <lambdabot>  *Exception: Prelude.foldr1: empty list
21:46:30 <Iceland_jack> (at least)
21:46:43 <Iceland_jack> And
21:46:43 <Iceland_jack> :t maximumBy undefined []
21:46:45 <lambdabot> a
21:46:59 <koz_> Iceland_jack: I see. Thanks.
21:47:31 <MarcelineVQ> a? :>
21:47:34 <kadoban> koz_: One way to fix that is using Maybe, if you're familiar with that.
21:47:34 <Iceland_jack> Yes
21:47:45 <MarcelineVQ> oh type sily me
21:47:47 <Iceland_jack> Intuitively, 'undefined' crashes the moment it is used and since it didn't crash it means "maximumBy _ []" ignores its first argument
21:48:05 <koz_> kadoban: I am familiar with Maybe, at least somewhat.
21:48:40 <Iceland_jack> The second way uses the power of types to answer our question
21:48:59 <Iceland_jack> or parametricity
21:50:03 <koz_> Alrighty, I think I now have a type-related question.
21:50:18 <koz_> My CTrie as it stands has the disadvantage that it'll accept any list of strings, no matter how large or small.
21:50:35 <koz_> I would prefer if it had a 'burned in' length that it took and rejected any that were different.
21:50:50 <koz_> Should I do this by wrapping it in another type, or changing its type to be smarter?
21:51:24 <Iceland_jack> I would tell you, not to bother having the length a part of the type unless it *really* needs to be determined statically
21:51:48 <koz_> Iceland_jack: Alright, if you think so.
21:52:04 <Iceland_jack> and whether it's not good enough to define
21:52:04 <Iceland_jack>     newtype ProperStrings = MkProperStrings [String]
21:52:04 <Iceland_jack> and a function
21:52:04 <Iceland_jack>     checkLength :: [String] -> Maybe PropertStrings
21:52:06 <koz_> Also, quickcheck looks awesome, but I have to read up on it a bit to use it with my code.
21:52:11 <Iceland_jack> And hiding the constructors
21:52:31 <Iceland_jack> Those are called "smart constructors", if you want to look them up
21:52:51 <Iceland_jack> It's very easy now to naturally define a list that tracks its length in the types
21:53:00 <koz_> Iceland_jack: OK, thanks for that.
21:54:06 <Iceland_jack> But all the associated hassle, when you start accepting lists whose length you *don't* know dynamically, you need to use singleton types..., that's my view anyway, but in GHC 8.0 this may change with TypeInType
21:54:22 <Iceland_jack> *you *don't* know statically
21:54:27 <koz_> OK, point taken.
21:54:58 <koz_> To export stuff from my module, do I need to do 'module Foo (bar baz Type)' ?
21:55:32 <Iceland_jack> You need a comma between them, and Type(..) if you want to export all the constructors
21:55:53 <Iceland_jack> @google Haskell module export
21:55:54 <lambdabot> https://www.haskell.org/tutorial/modules.html
21:55:55 <koz_> Ah, ok.
21:56:28 <koz_> OK, time to see if they pass the tests.
21:58:41 <koz_> OK... why can't it see HUnit...
21:58:51 <koz_> I guess I should be using Cabal.
21:59:42 <kadoban> koz_: 'stack' actually probably.
22:00:24 <koz_> kadoban: Oh?
22:00:40 <koz_> Why not Cabal?
22:00:49 <koz_> (Haskell wikibook says Cabal is the build system)
22:00:52 <kadoban> koz_: cabal-install is /very/ funky. https://github.com/commercialhaskell/stack is only a bit funky.
22:01:24 <koz_> OK. I basically fetch packages from my distro (that's how I got HUnit), but my compiler seems to have trouble finding them.
22:01:26 <kadoban> koz_: Lets you skip installing GHC and such as well, which is usually a bonus.
22:02:00 <kadoban> koz_: Most package managers don't have great seletion of haskell packages, and they tend to be really out of date as well.
22:02:13 <kadoban> koz_: Though if it has enough for you, you can go that way for now if you like.
22:02:52 <koz_> kadoban: I'm on Arch, so the selection is plenty-good for me presently.
22:03:09 <selveskii> Hello, I am trying to build a seemingly not so new branch of GHC, wip/gadtpm, which requires filepath < 1.4. But the GHC I currently have is 7.10.2 with filepath 1.4. Is there any way I can use to compile this branch without installing 7.8.3?
22:04:07 <selveskii> I am also using ArchLinux. Anyway, I have tried `cabal install filepath<1.4` (with appropriate quote for shell) but while building gcc-cabal it still reported: At least the following dependencies are missing: filepath >=1 && <1.4
22:11:28 <pdxleif> Any advice for some sort of CI setup that maybe polls hackage (or github?) for new releases, and builds them into system packages?
22:12:14 <pdxleif> Just looking for something to automate building Idris binary packages for Arch (and other Haskell packages, maybe even other OS's) https://github.com/LeifW/Idris-dev/releases
22:23:56 * hackagebot simplest-sqlite 0.0.0.11 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.0.0.11 (YoshikuniJujo)
22:43:56 * hackagebot simplest-sqlite 0.0.0.12 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.0.0.12 (YoshikuniJujo)
23:14:21 <Apollo_16> programmi
23:14:22 <koz_> Huh, apparently it's Test.HUnit...
23:14:28 <Apollo_16> ciao
23:22:52 <koz_> Is there a distinguished type for positive integers in Haskell?
23:23:07 <bitemyapp> koz_: Nat
23:23:13 <koz_> bitemyapp: Thanks!
23:23:15 <bitemyapp> koz_: not very fast tho
23:23:18 <bitemyapp> koz_: just fyi
23:23:31 <koz_> bitemyapp: Where is it imported from?
23:23:31 <bitemyapp> koz_: there are better ways depending on what you need.
23:23:48 <bitemyapp> koz_: http://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-Natural.html
23:23:53 <bitemyapp> that's one implementation
23:23:54 <koz_> bitemyapp: I just want a type representing specifically the set {0, 1, 2, ...}
23:24:01 <bitemyapp> one of the faster ones actually.
23:24:08 <bitemyapp> koz_: then GHC.Natural is what you want, I think.
23:24:21 <koz_> bitemyapp: Thanks!
23:24:36 <bitemyapp> koz_: it'll be faster than rolling your own because it can use the gmp backend.
23:25:31 <koz_> bitemyapp: It seems the code objects to me using length foo as a Natural...
23:25:46 <Iceland_jack> koz_: Check out Natural from Numeric.Natural
23:26:04 <Iceland_jack> never mind, already mentioned
23:27:24 <koz_> Iceland_jack: I assume I need to use fromInteger?
23:28:15 <Iceland_jack> koz_: If you use literals you don't need anything
23:28:15 <Iceland_jack> ghci> import Numeric.Natural
23:28:16 <Iceland_jack> ghci> 0 ∷ Natural
23:28:16 <Iceland_jack> 0
23:28:23 <Iceland_jack> but if you have an Integer, yes
23:28:51 <koz_> :t length
23:28:52 <lambdabot> Foldable t => t a -> Int
23:28:58 <koz_> I actually have an Int.
23:29:03 <Iceland_jack> You need 'fromIntegral'
23:29:09 <koz_> As well?
23:29:10 <Iceland_jack> :t fromIntegral :: Int -> Natural
23:29:12 <lambdabot> Int -> Natural
23:29:25 <Iceland_jack> :t fromIntegral (length undefined) :: Natural
23:29:26 <lambdabot>     No instance for (Foldable t0) arising from a use of ‘length’
23:29:26 <lambdabot>     The type variable ‘t0’ is ambiguous
23:29:26 <lambdabot>     Note: there are several potential instances:
23:29:30 <Iceland_jack> :t fromIntegral (length []) :: Natural
23:29:32 <lambdabot> Natural
23:29:58 <koz_> Thanks!
23:30:03 <Iceland_jack> yw
23:35:51 <akegalj> Hey. Is there any good Haskell <-> Elm bridge that you know of? I ran into elm-bridge (https://hackage.haskell.org/package/elm-bridge) package on hackage. Any experience in Haskell <-> Elm communication?
23:36:07 <koz_> Is there a function that gives me everything in a list but the last element?
23:36:34 <liste> :t init
23:36:36 <lambdabot> [a] -> [a]
23:36:45 <liste> > init [1, 2, 3, 4, 5] -- koz_
23:36:46 <lambdabot>  [1,2,3,4]
23:37:03 <koz_> Neat, thanks!
23:37:05 <liste> > init []
23:37:07 <lambdabot>  *Exception: Prelude.init: empty list
23:37:18 <liste> it's partial though
23:38:07 <liste> not sure what the total equivalent is
23:38:17 <liste> if there even is one
23:38:46 <M2tias> > foldl1 (+) [1..]
23:38:51 <lambdabot>  mueval-core: Time limit exceeded
23:38:57 <M2tias> fancy
23:39:11 <koz_> :t last
23:39:15 <lambdabot> [a] -> a
23:42:46 <liste> > initMay [1,2,3,4,5] -- koz_ this is total
23:42:48 <lambdabot>  Just [1,2,3,4]
23:43:13 <liste> it's in the package called `safe' in a module called `Safe'
23:43:51 <ChristianS> liste: it's the other way around
23:46:24 <liste> ChristianS what do you mean? Hackage says "The safe package" and "Modules: Safe, Safe.Exact, Safe.Foldable"
23:47:09 <ChristianS> liste: sorry, what i meant was: the module called `Safe' is in the package called `safe'
23:47:37 <liste> ChristianS ah, I see, thanks for the correction (:
23:49:10 * hackagebot exception-hierarchy 0.0.0.2 - Exception type hierarchy with TemplateHaskell  https://hackage.haskell.org/package/exception-hierarchy-0.0.0.2 (YoshikuniJujo)
23:49:12 * hackagebot simplest-sqlite 0.0.0.13 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.0.0.13 (YoshikuniJujo)
