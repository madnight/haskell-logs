00:02:17 <Cale> Haskell might not be a terrible choice, but as a beginner, you'll have to expect that your intuition with respect to what will perform well and what won't will frequently be wrong, so it may be an uphill battle in that regard.
00:02:33 <Cale> h_noob: About how many vertices and edges do your graphs have?
00:02:55 <h_noob> Thanks, Cale. It will also help me learn Haskell, since this is something that I really want to get done
00:03:41 <h_noob> These are the graphs from this set of benchmarks: http://networkrepository.com/networks.php
00:03:50 <h_noob> So there are quite a few vertices and edges!
00:04:26 <h_noob> e.g: the first one has 4K vertices and a few million edges
00:05:10 <Cale> That one might still work out in an immutable representation even, using Data.IntMap/Data.IntSet
00:05:33 <Cale> But like, the ones which are up around 261M edges, that's trickier :)
00:05:46 <h_noob> an immutable representation means that for *every* change (say edge deletion) that I want, a copy of the graph gets made?
00:05:58 <tabemann> note that IntSet uses a HAMT, which means that update does not require anywhere near a full copy
00:06:04 <Cale> uh
00:06:13 <Cale> It's a PATRICIA trie
00:06:19 <h_noob> more importantly: will I have to write this representation of the graph myself, or is there an existing library of this sort?
00:06:30 <Cale> There's no hashing involved in IntSet
00:06:51 <Cale> h_noob: But it depends on what you mean by "copy"
00:07:02 <tabemann> there' also Data.HashMap and Data.HashMap.Strict, which do use hashing but do use HAMTs like IntSet
00:07:11 <Cale> Only the nodes which are actually different get stored to form the new structure
00:07:15 <tabemann> HAMT == PATRICIA trie
00:07:32 <Cale> HAMT = Hash array mapped trie
00:07:53 <tabemann> aren't they a case of PATRICIA tries?
00:08:16 * tabemann forgot that IntSet itself doesn't actually use a hash
00:08:20 <Cale> a PATRICIA trie is radix based, and doesn't do any hashing
00:08:45 <h_noob> Cale: a copy is something that would take up proportionally as much space (and time) to make as the original, for my purposes
00:08:56 <Cale> h_noob: then no
00:09:05 <Cale> h_noob: Only the path from the root to the thing which changed
00:09:29 <h_noob> so more like log-sized new space?
00:09:31 <Cale> yeah
00:09:50 <h_noob> that sounds promising!
00:10:25 <Cale> (plus a little bit extra for balance)
00:10:32 <h_noob> ok :)
00:10:47 <Cale> It's worth trying to use Map/IntMap first anyway
00:11:08 <h_noob> will i have to write a graph library using this myself?
00:11:48 <Cale> There are some graph libraries... I wish I could say there was something which was 100% definitively what you should use, but there are a lot of use-cases for graphs
00:12:04 <Cale> There's fgl, whose default representation for graphs uses Data.Map
00:12:19 <Cale> Er, IntMap, rather
00:12:40 <tabemann> I was wondering... since Data.Map is clearly inferior to both IntMap and HashMap
00:13:11 <Cale> In my experience, Map frequently beats HashMap
00:13:16 <Cale> and I do tend to try both
00:13:33 <Cale> Order comparisons can end up cheaper than computing hashes
00:13:46 <tabemann> probably depends on how expensive compare operations are versus how expensive hashing is
00:13:51 <Cale> yeah
00:13:51 <vektorweg1> at least its not too hard to switch midflight. 
00:14:11 <Cale> Yeah, they're almost identical thankfully
00:14:19 <bartavelle> also depends on your insert patterns
00:14:44 <Cale> Anyway, fgl is a bit annoying because its names for things are hard to remember and read
00:14:56 <Cale> But it does implement a fair number of useful algorithms
00:15:49 <tabemann> note that Data.Map uses balanced binary trees whereas Data.HashMap uses HAMTs, so Data.HashMap has a much higher branching factor for its nodes that Data.Map
00:16:22 <Cale> http://hackage.haskell.org/package/fgl-5.5.2.3/docs/Data-Graph-Inductive-Query-DFS.html -- like, the names in this module end up being a little too obnoxiously similar to one another, and while there's some kind of attempt at a convention, it isn't crystal clear
00:16:45 <Cale> But hey, you don't have to implement any of these depth first searches by hand :P
00:20:20 <h_noob> thank you, Cale . I will check out fgl again. I had looked at it once or twice, but got intimidated by the "new" way of defining a graph
00:20:31 <Cale> oh, you can mostly ignore that
00:20:49 <h_noob> :) ok
00:21:14 <Cale> Like, there are some cute folding operations which make you care about contexts and stuff
00:21:27 <h_noob> more generally: do we know why there is no comprehensive graph library (or libraries) in Haskell, unlike, say, Python?
00:22:01 <h_noob> even getting into it first is kind of difficult, because: what is this context they talk about, etc.
00:23:04 <Cale> http://hackage.haskell.org/package/fgl-5.5.2.3/docs/Data-Graph-Inductive-Graph.html#t:Graph -- have a look at this class
00:23:36 <Cale> Ignore the decomposition-producing things for now
00:23:48 <Cale> mkGraph will build you a graph from a list of vertices and a list of edges
00:24:16 <Cale> and then farther down in the module you'll find things like insEdge and delNode and such
00:24:39 <h_noob> thank you! am i misremembering things or was the documentation not so friendly till some time ago?
00:24:57 <Cale> It's quite possible that it was worse
00:25:05 <Cale> Some of the documentation still isn't great here
00:25:15 <h_noob> thanks a lot, Cale, this looks much less intimidating now than i remember from before
00:25:18 <Cale> http://hackage.haskell.org/package/fgl-5.5.2.3/docs/Data-Graph-Inductive-Query-BFS.html
00:25:25 <Cale> has no comments :P
00:28:51 <h_noob> :D
00:31:18 <Cale> I know that part of the problem is that it really is pretty convenient a whole lot of the time just to represent adjacency structures directly with something like Map Vertex (Set Vertex), or whatever variation of that is appropriate to the application.
00:33:18 <Cale> and most applications of graphs have something weird about the graphs they want to work with
00:35:39 <Cale> h_noob: A long while ago, I hacked up an A* search algorithm, and rather than care about how the user wants to represent graphs, I just took all the things I wanted as parameters: http://hackage.haskell.org/package/astar-0.2.1/docs/Data-Graph-AStar.html
00:41:59 <h_noob> :)
01:04:02 <favetelinguis> is there a miniKanren version in haskell that support the extensions of tabled goals and cKanren also?
01:06:45 <bartavelle> (and this astar package is really useful)
01:39:25 <ania123> can one correct me following sentence: "please see filled midterm exam form attached. "
01:39:53 <h_noob> add a "the" between "see" and "filled"
01:40:03 <h_noob> (or an "a", if that is what you meant)
01:42:16 <ania123> like this: "please see the filled midterm exam form attached. "
01:42:17 <ania123> ?
01:42:25 <h_noob> yes
01:42:28 <ania123> thx
01:42:31 <h_noob> yw
01:59:15 <latermuse> what is the best way to tune GHC to use more RAM and less processor? Would adding more generations help with that?
02:00:11 <latermuse> Setting -A really high seems to help, and -c also
02:13:55 * hackagebot git-jump 0.1.0.3 - Move a git branch  https://hackage.haskell.org/package/git-jump-0.1.0.3 (EyalLotem)
02:21:53 <Bjorkn> Hi guys
03:09:52 <bollu> guys, question about callCC
03:09:54 <bollu> :t callCC
03:09:55 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
03:10:17 <bollu> callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a
03:10:27 <bollu> so, when we say x <- callCC $ \k -> ….
03:11:18 <bollu> clearly, x will have type "a"
03:11:31 <bollu> the entire function to callCC must return a type Cont r a
03:11:41 <bollu> but "k" as function takes an a and returns a Cont r b
03:11:57 <bollu> so if I were to write callCC $ \k -> k <some-value-of-type-a>
03:12:16 <bollu> the value that will be returned will have type Cont r b, while the function should return a Cont r a
03:12:47 <dramforever> so far so good
03:12:48 <bollu> so how does calling callCC $ \k -> k <somevalue-type-a> work?
03:13:07 <dramforever> because you get to pick the "b", so you could just as well pick "a"
03:13:09 <bollu> because the return will be Cont r b, but "x" expects a type "a"
03:13:23 <dramforever> s/so//, fix grammar
03:13:27 <latk> Does anyone know if there is a way, in opaleye, to insert or ignore? Other than writing it myself, I mean.
03:13:29 <bollu> okay, what? I'm confused now
03:14:13 <dramforever> > let x = 12 :: Int in [const 4 x, x] -- let's look at this
03:14:13 <bollu> dramforever: what does that mean? you could pick "b" but pick "a" as well?
03:14:15 <lambdabot>  [4,12]
03:14:19 <dramforever> :t const
03:14:21 <lambdabot> a -> b -> a
03:14:29 <dramforever> :t const :: a -> a -> a
03:14:31 <lambdabot> a -> a -> a
03:14:35 <bollu> right, I get that you can specialize a -> b -> a to a -> a -> a
03:14:40 <dramforever> bollu: exactly
03:14:57 <bollu> but, in that case, can you give me an example where you actually use the Cont r b?
03:15:06 <bollu> like, const needs to be a -> b -> a to be able to do things like:
03:15:12 <bollu> > const 1 "qwer"
03:15:14 <lambdabot>  1
03:15:23 <bollu> so why does callCC need the "Cont r b" if we never use the "b" ?
03:16:34 <dramforever> :t forever -- repeats it's argument over and over (btw I kinda hate the name =P)
03:16:35 <lambdabot> Monad m => m a -> m b
03:17:01 <bollu> huh, why does it have a different type then?
03:17:37 <bollu> and why does callCC have a different type? if it never uses the flexibility?
03:18:10 <dramforever> bollu: oh what about this: (if condition then k 2 else return "Some String") >>= something else
03:18:42 <dramforever> this time, the k 2 has to be Cont r String because of the "else" branch
03:19:27 <bollu> dramforever: where's the callCC?
03:19:38 <bollu> callCC $ \k -> (if condition then k 2 else return "Some String") >>= something else
03:19:42 <dramforever> yep
03:19:44 <bollu> was that what you meant?
03:20:15 <bollu> okay, so now, in this: the return "Some string" will have type Cont r String, while (k 2) will have the type of whatever "something else" needs to use
03:20:24 <bollu> because (k 2) will escape into the something else, correct?
03:20:45 <bollu> so how will it typecheck?
03:20:59 <dramforever> because (k 2) will skip the entire rest of the computation and "jump" out to the call to callCC
03:21:19 <dramforever> and (something else) will never even get a chance to do anything
03:21:40 <bollu> the >>= is outside the callCC, right?
03:21:43 <bollu> oohh, wait, it's not
03:22:02 <bollu> a >>= (callCC $ \k -> (if condition then k 2 else return "Some String") >>= something_else_1) >>= something_outside_callCC
03:22:10 <bollu> the (k 2) will go to the something_outside_callCC correct?
03:22:15 <dramforever> yes
03:23:08 <bollu> so, if something_outside_callCC expects a type Int, while the return "Some string" will want a type Cont r String, the *entire* callCC block will have to return (Cont r Int), correct? since something_outside_callCC wants an Int?
03:23:28 <dramforever> yes
03:23:57 <bollu> so the return value of the function passed to callCC is always thrown away? unless you call the "k"?
03:24:14 <bollu> "return value" = "last continuation generated by the monadic block passed to callCC"
03:24:47 <dramforever> bollu: hmm...not quite getting what you mean, but in x <- callCC (return 1) the x gets 1
03:24:56 <dramforever> um, I mean callCC (\k -> return 1)
03:25:02 <bollu> corec
03:28:31 <bollu> but consider this: do x <- callCC (\k -> if True then (k "callCC escape") else return "hello, " >>= (\z -> return z ++ "world")); return x ++ " end";
03:28:34 <bollu> what would this output?
03:28:44 <bollu> IMO it would output "callCC escape end"
03:29:13 <dramforever> I think so, but perhaps test for sure?
03:29:21 <bollu> but if it were `if False`, then it would output "hello world end"?
03:29:33 <dramforever> I think so
03:32:05 <dramforever> bollu: um those ++'s are wrong, but the after correcting that the result is correct
03:32:24 <bollu> why are they wrong?
03:32:30 <bollu> oh, precedence :)
03:33:00 <dramforever> > evalCont (do x <- callCC (\k -> if True then k "callCC escape" else return "hello, " >>= (\z -> return (z ++ "world"))); (return (x ++ " end"));)
03:33:01 <lambdabot>  Not in scope: ‘evalCont’
03:33:11 <dramforever> > runCont (do x <- callCC (\k -> if True then k "callCC escape" else return "hello, " >>= (\z -> return (z ++ "world"))); (return (x ++ " end"));) id
03:33:13 <lambdabot>  "callCC escape end"
03:33:22 <dramforever> runCont (do x <- callCC (\k -> if False then k "callCC escape" else return "hello, " >>= (\z -> return (z ++ "world"))); (return (x ++ " end"));) id
03:33:30 <dramforever> > runCont (do x <- callCC (\k -> if False then k "callCC escape" else return "hello, " >>= (\z -> return (z ++ "world"))); (return (x ++ " end"));) id
03:33:33 <lambdabot>  "hello, world end"
03:34:21 <dramforever> strange wall of text..sorry
03:36:47 <bollu> thanks
03:36:49 <bollu> :)
03:37:04 <bollu> > runCont (do x <- callCC (\k -> if False then k "callCC escape" else return 5 >>= (\z -> return ((show z) ++ "world"))); (return (x ++ " end"));) id
03:37:06 <lambdabot>  "5world end"
03:37:14 <bollu> wow, that is cool
03:40:44 <nani___> curious about this: can I know if some pure function is using unsafePerformIO?
03:43:57 <dramforever> nani___: do you want to run untrusted code?
03:44:00 * hackagebot haxl-amazonka 0.1.0.0 - Simple project template from stack  https://hackage.haskell.org/package/haxl-amazonka-0.1.0.0 (TvH)
03:44:42 <nani___> dramforever, I don't need to, but yes, I was curious if I could run untrusted code easily if I wanted to
03:45:15 <dramforever> I heard about mueval before, maybe you can take a look
03:45:17 <dramforever> @hackage mueval
03:45:17 <lambdabot> http://hackage.haskell.org/package/mueval
03:45:49 <dramforever> nani___: otherwise I don't think there's anything that can tell (unsafePerformIO (return "Hello, world!"))
03:48:22 <nani___> dramforever, thanks, looks really cool.
03:48:33 <dramforever> you're welcome
04:06:52 <loxs> where does the convention of using the variable "xs" comes from?
04:07:11 <dramforever> plural of x
04:08:34 <loxs> oh wow :)
04:19:01 * hackagebot haskell-gi 0.10.1 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.10.1 (inaki)
04:47:28 <gansteed> how can I use a pattern match for list of list? e.g. [[1], [1,2]], how can I match it?
04:50:35 <Geraldus> hi friends!
04:51:01 <oisdk_> gansteed: f ((x:xs):xss) = x
04:51:10 <Geraldus> I'm a stack user, can I install some tools (e.g. darcs) with stack globally?
04:53:26 <gansteed> oisdk_, I want x match [1], xs match [[2]]?
04:55:19 <oisdk_> gansteed: you can just nest the pattern matching
04:55:45 <oisdk_> (\((x:xs):(y:ys):xss) -> (x,ys)) [[1],[1,2]]
04:56:17 <gansteed> thanks
04:56:21 <oisdk_> > (\((x:xs):(y:ys):xss) -> (x,ys)) [[1],[1,2]]
04:56:24 <lambdabot>  (1,[2])
04:59:24 <lpaste_> dramforever pasted “I just implemented a data structure and the result was extremely pleasing .uicai =) (Tl;DR is the first paragraph of the comments))” at http://lpaste.net/145769
05:00:18 <dramforever> yet lpaste seems to envy because it won't show my post...
05:00:56 <lpaste_> dramforever pasted “I just implemented a data structure and the result was extremely pleasing .uicai =) (Tl;DR is the first paragraph of the comments)” at http://lpaste.net/145770
05:01:22 <dramforever> oh wait it's corrected now, ignore that message
05:02:32 <Geraldus> How can I install darcs globally with stack?
05:03:53 <dramforever> Ah, it's called "persistent segment trees", and I found a nice explaination here: http://blog.anudeep2011.com/persistent-segment-trees-explained-with-spoj-problems/
05:04:56 <dramforever> um...wait it doesn't really explain what a segment tree is... =(
05:05:21 <dramforever> perhaps only those somewhat familiar with them like me can understand my joy
05:13:43 <glosoli> any ideas what I could be missing, I have a setup of Emacs Haskell like in https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md and GHC process started, though I still can't jump to definitions such as putStrlLn and etc, it always says "No definition found for
05:27:49 <ph88_> nooooeesss https://www.fpcomplete.com/blog/2015/10/retiring-fphc this is terrible :(
05:28:01 <ph88_> there is no good replacement it think where you can try and share your code online
05:35:57 <jophish> why doesn't quickcheck print the failing testcase on timeout!
05:43:56 <jophish> hmm, it might be failing to generate the testcase actually
06:12:37 <osa1> does anyone know a library for URL manipulation? I need something like filepath's </> but for URLs, it should check if the second URL is absolute etc.
06:16:25 <osa1> I looked at url and network-uri both none of them has this function. (although I think it'd be easy to implement on top of 'url')
06:30:58 <tekkkz> HEllo! Thats my code: http://ix.io/mpv and here is the compile error: http://ix.io/mpw ... i want to get "test" out if the string "[&test]" .. waht did i wrong?
06:32:45 <tekkkz> @bennofs , any ideas?
06:32:45 <lambdabot> Unknown command, try @list
06:33:30 <tekkkz> lambdabot, this shouldnt been a command ;)
06:34:11 <bennofs> tekkkz: the problem is [getBase64 r]: getBase64 r is already of type [Char], so [getBase64 r] would be of type [[Char]]
06:35:03 <tekkkz> bennofs, ofc, fantastic, man, i should have seen this issue by my own ;(
07:01:20 <hexagoxel> is there a common way to separate the different usages of `undefined`? e.g. as a type witness vs as a temporary "make this part compile" thingy.
07:02:21 <roconnor> what's a type witness?
07:02:24 <E4xoi> hexagoxel: use "Proxy" for the type witness? 
07:02:44 <roconnor> Oh
07:04:37 <hexagoxel> E4xoi: only works for the cases where i control the interface. E.g. Foreign.Storable.sizeOf won't work with Proxy.
07:07:12 <roconnor> I usually use (error "TODO") for temporary things.
07:07:42 * hexagoxel notices that typeRep is the Proxy version of typeOf.. neat, some undefined's avoided.
07:08:17 <E4xoi> hexagoxel: well, it's the common way, some places don't use it :P 
07:30:38 <osa1> I'm printing from multiple thread, is there a fast library function to prevent interleaved printing? currently I'm using a MVar () as lock
07:34:38 <dario`> osa1: https://hackage.haskell.org/package/concurrent-output maybe
07:44:10 * hackagebot BiobaseTypes 0.1.1.1 - Collection of types for bioinformatics  https://hackage.haskell.org/package/BiobaseTypes-0.1.1.1 (ChristianHoener)
07:46:16 <meoblast001> http://hackage.haskell.org/package/gl-0.7.7/docs/Graphics-GL-Standard10.html#v:glGetFloatv
07:46:21 <meoblast001> does anyone know how on earth one would use this?
07:46:27 <meoblast001> how could i create a Ptr GLfloat?
07:47:11 <tekkkz> meoblast001, i dont know, but im interested what you do with this library?
07:47:25 <meoblast001> OpenGL library
07:48:30 <CindyLinz> meoblast001: look here~ # https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/Foreign-Marshal-Alloc.html
07:48:59 <meoblast001> thanks :)
07:49:08 <CindyLinz> meoblast001: or here~ # https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/Foreign-Marshal-Array.html
07:51:16 <tekkkz> meoblast001, i know, i meant what are you programming with opengl??
07:51:42 <meoblast001> https://github.com/meoblast001/gl-practice-hs
07:56:23 <pavonia> meoblast001: Any reason you're not using a more high-level binding like OpenGL?
07:57:21 <meoblast001> with OpenGL in Haskell you're choosing between good typing or a complete implementation
07:57:30 <tekkkz> meoblast001, can you show screenshot?
07:58:42 <meoblast001> http://imgur.com/RRaXixL
07:59:34 <tekkkz> kde :/
08:00:37 <CindyLinz> cute!
08:02:12 <dangelov> fst [1,2]
08:02:25 <dangelov> oops, i was tabbed to irrsi, sorry :)
08:09:11 * hackagebot BiobaseXNA 0.9.2.1 - Efficient RNA/DNA representations  https://hackage.haskell.org/package/BiobaseXNA-0.9.2.1 (ChristianHoener)
08:13:27 <tekkkz> Hi! I have such array: "[0,0,76,244]" and I want to convert every element to hex, put all together to one big hex, e.g. 00004CF4 and convert this to dec then. How to do this?
08:19:50 <hexagoxel> why convert to hex in between?
08:19:52 <mauke> > 0x4cf4
08:19:53 <lambdabot>  19700
08:20:05 <mauke> > 76 * 256 + 244
08:20:07 <lambdabot>  19700
08:20:29 <tekkkz> hm explain me this pls
08:20:34 <tekkkz> the calculation you did
08:20:36 <mauke> > foldl' (\z x -> z * 256 + x) 0 [0,0,76,244]
08:20:38 <lambdabot>  19700
08:21:11 <tekkkz> mauke
08:21:20 <tekkkz> explain your foldl' stuff pls
08:21:27 <mauke> no
08:21:27 <tekkkz> im new and have no plan what this is doing
08:21:32 <tekkkz> please
08:22:45 <tekkkz> hexagoxel, can you explain me this please?
08:23:31 <tekkkz> or at least the calculation 76 * 256 + 244 .. why is his working?
08:24:22 <dealpete> you seem a little desperate tekkkz
08:24:50 <dealpete> have you taken a look at http://learnyouahaskell.com/chapters
08:25:08 <tekkkz> yaya
08:25:15 <hexagoxel> the problem seems not at all related to haskell
08:25:39 <tekkkz> but im realtively new and have no plan what he did with foldl', beter: what that is, and i also have no plan why the calculation is valid
08:25:40 <tekkkz> ...
08:26:22 <mauke> ah, german hostmask. I was wondering about that "no plan" :-)
08:26:35 <dealpete> why do you need to know this?
08:26:48 <hexagoxel> tekkkz: firstly your problem. it seems you want to convert a list of bytes into the int whose binary representation consists of these bytes.
08:27:34 <tekkkz> yeah, i have a [Word8] list and want to generate an int from all the hexvalues of the elements combined
08:27:44 <hexagoxel> hex makes no sense, as it is one string representation
08:28:21 <tekkkz> yeah, but i didnt knew that there is an easy and valid calculation like mauke showed already (76 * 256 + 244) but i have no plan why this is valid
08:28:45 <lpaste_> michael pasted “Station example” at http://lpaste.net/145779
08:29:34 <tekkkz> is lpaste_ talking with me?
08:30:38 <student_michael> Hello, I've gotten some code from my teacher, but it won't compile. http://lpaste.net/145779 The reason is the '->' inside the Machine type declaration.
08:31:00 <glosoli> any ideas what I could be missing, I have a setup of Emacs Haskell like in https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md and GHC process started, though I still can't jump to definitions such as putStrlLn and etc, it always says "No definition found for
08:31:05 <mauke> student_michael: probably missing ( )
08:31:18 <student_michael> I'm assuming this is an error, and needs to be Machine ([(a, Int)] -> b) instead, but maybe there is some unknown syntax I don't know about?
08:31:32 <mauke> no
08:32:06 <mauke> the only other syntax I can think of is GADTs, but that would look completely different
08:33:01 <student_michael> @mauke Thanks a lot! I already assumed it should be either Machine [(a, Int)] b or Machine ([(a, Int)] -> b), but I wasn't sure!
08:33:01 <lambdabot> Unknown command, try @list
08:35:47 <student_michael> mauke++
08:36:29 <student_michael> preflex: mauke++
08:38:28 <hexagoxel> tekkkz: maybe the basics help: consider https://en.wikipedia.org/wiki/Binary_number#Binary_counting
08:38:46 <hexagoxel> tekkkz: note that a byte has 8 bits, and 2^8==256
08:39:33 <hexagoxel> it is like the bit-wise calculation, just for whole bytes.
08:40:56 <tekkkz> hexagoxel, yeah, does it means that the calculation is: [1] * 256 + [2] * 256 + .... + [n] where the last is not multiplied?
08:42:13 <hexagoxel> > foldl' (\z x -> z * 256 + x) 0 [0,0,0,1]
08:42:15 <lambdabot>  1
08:42:17 <hexagoxel> > foldl' (\z x -> z * 256 + x) 0 [0,0,1,0]
08:42:19 <lambdabot>  256
08:42:22 <hexagoxel> > foldl' (\z x -> z * 256 + x) 0 [0,1,0,0]
08:42:24 <lambdabot>  65536
08:42:37 <rvxi> really basic question - in the cabal file, where/how do I specify addition a .hs files to include in the project?
08:42:55 <tekkkz> hexagoxel, could you explain me this all please in private?
08:43:39 <hexagoxel> rvxi: you add the module to exposed-modules or other-modules.
08:44:32 <hexagoxel> (presuming the .hs is placed appropriately in the src folder)
08:45:22 <hexagoxel> tekkkz: sorry, no.
08:45:52 <tekkkz> okay, then here, so how is the calculation , not with foldl, the basic calculation working? not as i described i think
08:46:55 <rvxi> hexagoxel: I have two files defining functions in module Main, one of which is Main.hs (this is an executable). In the cabal file I have  "other-modules:       Main"
08:47:14 <rvxi> haxagoxel: however, function from the second file aren't visible when I run "cabal repl"
08:49:09 <hexagoxel> rvxi: haskell has a one-to-one mapping from modules to files. module Foo.Bar.Zoo is in file $src/Foo/Bar/Zoo.hs
08:51:30 <hexagoxel> rvxi: Second.hs "module Second where .." Main.hs "module Main where import Second .."
08:52:58 <rvxi> ah nice seems to work now. I don't have to declare the module corresponding to the Second.hs in the cabal file do I?
08:53:26 <rvxi> cabal repl seems to be able to figure it out without anything explicit  in the yaml file
08:53:28 <hexagoxel> tekkkz: maybe some "binary representation" tutorial helps, e.g. http://learning-about-computers.com/tutorials/binary_and_hexidecimal.shtml
08:54:10 <tekkkz> okay thanks
08:54:56 <hexagoxel> rvxi: you should still add Second to other-modules.
08:56:31 <rvxi> hexagoxel: should I also add Second.hs to extra-source-files? or is that for something else?
08:56:57 <hexagoxel> rvxi: that is not necessary if it is one of other/exposed-modules.
08:57:44 <hexagoxel> (it works already because ghc has some clever discovery, but will break once you install/distribute the package)
09:11:13 <tekkkz> > foldl' (\z x -> z * 256 + x) 0 [0,0,76,244]
09:11:15 <lambdabot>  19700
09:11:37 <bgamari-> ugh, arc lint is a nightmare to debug
09:13:34 <tekkkz> > foldl' (\z x -> z * 256 + x) 0 [1,0,0,0]
09:13:36 <lambdabot>  16777216
09:14:03 <tekkkz> can someone explain me please what the calculation looks like for the example above with [1,0,0,0] ?
09:14:10 <tekkkz> hexagoxel, maybe you please?
09:15:31 <hexagoxel> > foldl' (\z x -> z * 256 + x) 0 [a,b,c,d]
09:15:34 <lambdabot>  (((0 * 256 + a) * 256 + b) * 256 + c) * 256 + d
09:16:19 <osa1> does anyone know what exceptions bytestring's writeFile can throw?
09:17:26 <johnw> osa1: you mean just its synchronous exceptions, or the total set of possible exceptions?
09:19:33 * hackagebot mathgenealogy 1.4.0 - Discover your (academic) ancestors!  https://hackage.haskell.org/package/mathgenealogy-1.4.0 (PeterRobinson)
09:23:09 <rvxi> hexagoxel: thanks
09:25:18 <osa1> johnw: I'm just wondering what happens if I provide an invalid file path or HDD is full etc.
09:29:34 * hackagebot lentil 0.1.7.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.7.0 (fffaaa)
09:50:43 <cjay> is that book still relevant? “The Implementation of Functional Programming Languages” http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
09:53:40 <osa1> cjay: yes. especially great for understanding how lazy evaluation implemented. IIRC the code is in Miranda(?) but it's easy to port to Haskell
09:54:03 <osa1> IIRC I implemented big part of the book in Haskell but I don't remember where my code is.
10:03:53 <harwiltz> Hello, does anyone have any experience with hscurses? 
10:10:15 * hackagebot deepcontrol 0.5.4.1 - A library that provides deep-level programming style or notation on Applicative and Monad  https://hackage.haskell.org/package/deepcontrol-0.5.4.1 (KONISHI_Yohsuke)
10:17:00 <jophish> edwardk: I'd like to use `ad` with a numeric type which doesn't have an instance for Eq. Would you be willing to accept a PR which added `findZero'` and friends which returned an infinite list of converging values and didn't require an Eq instance?
10:24:36 <nani___> newbie question: Functors and Applicatives need the parameter of their constructors to always be able to be a function, right? And if I understand correctly, it can always be a function since datatype contexts are not allowed anymore? If this is the case I'm not confused, otherwise I am :)
10:25:29 <edwardk> jophish: the ' is probably the wrong naming convention, but something that added them in general would be okay
10:25:49 <edwardk> the ' in 'ad' always means 'along with the primal'
10:31:44 <athan> nani___: Your confusion confused me :x
10:32:17 <athan> the parameters to a higher-kinded type, like a Functor or Applicative, can be /anything/
10:32:49 <athan> for something to be a `Maybe a` or a `[a]` means that `a` is a type variable - we can coerce it to be a function, or an `Int`, anything we want
10:33:02 <athan> that's what it means to be purely parametric, or parametric polymorphism
10:33:26 <nani___> Ok, that clears all the confusion I had (I hope!). Thanks athan :)
10:33:42 <athan> :)
10:35:15 <jophish> yeah, I just thought of that, edwardk :)
10:35:28 <jophish> I'll get right to it
10:38:25 <jophish> edwardk: findZeroNoEq seems like the best choice, something else like findZeroNonConverging gives the wrong idea I think
10:38:44 <edwardk> hrmm
10:38:52 <edwardk> well, lets see what the existing naming conventions like that are
10:40:10 <edwardk> maybe findZero0 ? we have some precedent for using the 0 for things padded with 0s at the end
10:40:25 <edwardk> kind of messy naming but short and more or less fits the existing conventions
10:40:51 <jophish> It wouldn't be zero padded for the other functions such as fixedPoint though
10:45:55 <jophish> edwardk: ^
10:46:19 <edwardk> true, and it technically finds the thing that yields 0, so its a bit of a mess
10:46:34 <edwardk> just looking for a nice concise mangling i could add to the docs on the front page
10:46:54 * hackagebot linode 0.1.0.3 - Bindings to the Linode API  https://hackage.haskell.org/package/linode-0.1.0.3 (Helkafen)
10:47:27 <edwardk> its also not quite padded, right? since we can compare for isZero in the ad lifting often even without Eq
10:48:30 <edwardk> oh it uses diffs0
10:48:41 <edwardk> what if we used diffs instead and then explicitly handled the [] case?
10:48:51 <edwardk> that might be better
10:48:59 <jophish> ah, I'd not seen isZero
10:49:05 <edwardk> (even in the normal case)
10:54:38 <jophish> edwardk: Would there be any difference in using diffs there, I'd have thought that there would be enought inlining to be able to optimize it away
10:55:27 <Tekmo__> andreass_: This is @GabrielG439.  You wanted to chat in IRC
10:56:12 <edwardk> maybe it's fine. and i guess the equality constraint is used in 'go' not diffs
10:56:17 <curious_reader> gabriels? what syour nick here?
10:56:50 <darkroom> does anyone know if unpacking a Word8 is faster than the bool data type? 
10:56:51 <athan> Hey everyone. Is there a reason why haddock would reference `Data.Foo.Foo` as a #v:Foo fragment, instead of a #t:Foo?
10:57:24 * hackagebot deepcontrol 0.5.4.2 - A library that provides deep-level programming style or notation on Applicative and Monad  https://hackage.haskell.org/package/deepcontrol-0.5.4.2 (KONISHI_Yohsuke)
10:57:27 <athan> referenced as 'Data.Foo.Foo' I mean
10:58:02 <athan> I do not have a data constructor named `Foo` in Data.Foo, only a type constructor named Foo :\
10:58:29 <hsk4> Is it common to create "state" data structures (using record syntax) in Haskell, as a replacement for an object in OO, when people move from OO to Haskell? Is that the right way to do it? Since we don't have objects in Haskell, that's the only way I can imagine doing things. I just create a state and pass that around a bunch of functions.
10:58:57 <hsk4> so those functions take in a state (plus some other data) and output a new state (plus some other data).
10:59:03 <hsk4> kind of messy
10:59:09 <athan> hsk4: Yeah, we make data types that represent images of some state, then modify that image through successive function calls
10:59:13 <curious_reader> Tekmo__: query ok?
10:59:33 <Tekmo__> curious_reader: Hi
10:59:44 <Rembane> hsk4: If you want to remove some of the messiness you can use the Reader or Writer or State monad.
10:59:48 <athan> statefulness is pretty messy :P
11:00:22 <curious_reader> Tekmo__: chat like this here? or query? its so much text here...
11:00:36 <Tekmo__> curious_reader: What do you mean by query?
11:00:46 <hsk4> ok
11:01:32 <curious_reader> Tekmo__: if you click on my nick on the contact list , we can have private chat "query"
11:01:59 <Tekmo__> Hold on, I'm using irssi
11:02:14 <curious_reader> Tekmo__: I just tried to "query" you there should be another window with my name in your client? or a request or something? you never used that before?
11:03:03 <curious_reader> Tekmo__: im using wbchat.freenode
11:03:07 <Tekmo__> I'll switch to webchat.freenode.net since I'm apparently an IRSSI noob
11:03:12 <Tekmo__> :)
11:03:18 <Tekmo__> I'll be right back
11:04:06 <bitemyapp> Tekmo__: sent you DM on Twattles.
11:09:09 <stoogenmeyer> Hey, I'm looking for anyone who is working on an open-source project in Haskell and is looking for collaborators. I'm a beginner in Haskell but pick on quick and looking to learn and contribute.
11:12:23 <kadoban> stoogenmeyer: I've been looking into doing a bit of work on https://github.com/commercialhaskell/stack , and so far they're very open to contributions.
11:13:12 <stoogenmeyer> kadoban: cool, thanks. Is it simply a matter of picking an issue and submitting a pull request?
11:14:18 <kadoban> stoogenmeyer: Yeah, pretty much. There's some label on issues they have suggesting they're explicitly waiting for a PR, you can look for those specifically. There's also a 'newcomer' label, ones that are likely to be a good place to start for someone not familiar with the project yet.
11:14:45 <stoogenmeyer> kadoban: Great, I'll give it a shot!
11:19:05 <begriffs> I want to make a type AmazingList that is identical to a list but claims that the values in the list have a certain property. What is an idiomatic way to do this? I'm planning to make a function checkAmazing :: [a] -> AmazingList a and then have other functions which only consume AmazingLists.
11:19:26 <begriffs> Oops meant checkAmazing :: [a] -> Maybe (AmazingList a)
11:20:13 <begriffs> I want to enforce that only checkAmazing can produce this type so you can't forge it other ways.
11:22:46 <kadoban> begriffs: Throw it in a module and don't export the AmazingList value constructor, only 'checkAmazing'.
11:23:05 <begriffs> OK, simple enough.
11:23:42 <begriffs> Is there a way to annotate a list with a phantom type or something to say that it is amazing?
11:23:57 <loxs> is there a built-in sort function which I can use in ghci?
11:24:20 <kadoban> loxs: Yeah, it's Data.List.sort
11:24:42 <loxs> oh, thanks
11:42:26 * hackagebot NaturalLanguageAlphabets 0.0.2.0 - Alphabet and word representations  https://hackage.haskell.org/package/NaturalLanguageAlphabets-0.0.2.0 (ChristianHoener)
11:53:37 <Pamelloes> Is there a way to make read-only lenses? Is that even a coherent idea?
11:54:28 <phadej> lenses which can only read? how they differ from regular functions?
11:57:26 <bergey> The lens library defines a type of Getters, which are read-only, but compose as expected with lenses and other optical type.
11:57:27 * hackagebot FormalGrammars 0.2.1.1 - (Context-free) grammars in formal language theory  https://hackage.haskell.org/package/FormalGrammars-0.2.1.1 (ChristianHoener)
11:58:28 <dolio> A read-only lens is a function. :)
11:59:12 <jophish> edwardk: I've opened a PR, I went with NoEq for now but I'd be happy to change it
12:03:56 <muesli4> Has someone built ghc on arm recently? I just want to know how mature it is.
12:09:50 <varaindemian> if curry :: ((a, b) -> c) -> a -> b -> c why isn't its definition curry f = \ (x, y) -> f x y ?
12:10:02 <hpc> @src curry
12:10:02 <lambdabot> curry f x y = f (x, y)
12:10:25 <hpc> what you're thinking of is uncurry
12:10:33 <hpc> in (curry f), f :: (a, b) -> c
12:10:37 <hpc> so it needs to take a tuple
12:10:50 <hpc> and then (curry f) :: a -> b -> c, so it needs to take two more arguments
12:14:48 <varaindemian> hpc: what does it mean when we have these parantheses f (x, y)
12:14:48 <varaindemian> ?
12:16:46 <justin_smith> it's a tuple
12:17:55 <justin_smith> https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Tuple.html
12:19:12 <varaindemian> justin_smith: thx
12:24:58 <Bruuuuuuno> What's the fastest data structure to concatanate? 
12:25:10 <mauke> ()
12:26:06 <platz> Data.DList as O(1) append if you don't need to inspect the intermediate structures
12:26:06 <Bruuuuuuno> I mean something like a list, but faster :p
12:26:18 <Bruuuuuuno> okay thanks
12:27:43 <platz> maybe pre-allocating a mutable vector would be fastest
12:28:17 <platz> but more work/bookkeeping
12:28:41 <Bruuuuuuno> my use case is that I'm building a map of type (MonadPlus m) => Map Int (m a)
12:29:45 <Bruuuuuuno> like that
12:29:55 <Bruuuuuuno> toLookup getKey getValue = Map.fromListWith (mplus) . map (\x-> (getKey x, (return $ getValue x)))
12:32:37 * hackagebot GrammarProducts 0.1.1.1 - Grammar products and higher-dimensional grammars  https://hackage.haskell.org/package/GrammarProducts-0.1.1.1 (ChristianHoener)
12:33:30 <varaindemian> what's the difference between curry (f x y) = f (x,y) and (curry f) x y = f (x,y)? What does (curry f) mean?
12:34:07 <Bruuuuuuno> :t curry
12:34:09 <lambdabot> ((a, b) -> c) -> a -> b -> c
12:34:10 <athan> varaindemian: Spaces associate left
12:34:28 <athan> curry f x y ~ (curry f) x y ~ ((curry f) x) y
12:43:04 <pikajude> on second thought, servant is really not suited for making anything that isn't a REST API
12:43:28 <athan> Check out nested-routes!
12:43:33 <athan> @hackage nested-routes
12:43:33 <lambdabot> http://hackage.haskell.org/package/nested-routes
12:43:43 * athan hides from the self-promo police
12:43:55 <derekv> is (<$>) a generalization of (.) ? seems like I can use (<$>) to the same effect as (.)
12:44:03 <varaindemian> athan: curry f = \ x y -> f (x, y) for me it seems that it takes two arguments one at a time and converts it into a function that takes the arguments as a tuple
12:44:10 <arkeet> derekv: yes
12:44:11 <arkeet> :t (.)
12:44:13 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:44:15 <arkeet> :t fmap
12:44:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:44:24 <arkeet> consider f a = r -> a
12:44:56 <arkeet> (<$> is infix fmap)
12:44:58 <athan> varaindemian: yes :P
12:45:09 <Bruuuuuuno> isn't (>>>) the generation of (.)?
12:45:17 <Bruuuuuuno> *generalization
12:45:22 <arkeet> "the"
12:45:54 <varaindemian> athan: but in the course I'm taking it's exactly the oposite: curry :: ((a, b) -> c) -> a -> b -> c , that converts a function that takes its arguments as a pair into a function that takes its arguments one at a time
12:46:06 <athan> Is there an applicative arrow?
12:46:20 <arkeet> :t uncurry
12:46:21 <lambdabot> (a -> b -> c) -> (a, b) -> c
12:46:27 <arkeet> :t curry
12:46:29 <lambdabot> ((a, b) -> c) -> a -> b -> c
12:47:15 <athan> ahh, ArrowMonad
12:47:43 <varaindemian> athan: I didn't learned about monads
12:47:50 <athan> :t (f >>> (g :: ArrowMonad a b))
12:47:52 <lambdabot>     No instance for (FromExpr (ArrowMonad a1 b))
12:47:52 <lambdabot>       arising from a use of ‘g’
12:47:52 <lambdabot>     In the second argument of ‘(>>>)’, namely ‘(g :: ArrowMonad a b)’
12:47:56 <athan> mer
12:48:00 <varaindemian> haven't***
12:48:25 <athan> You're doing it the right way then :)
12:48:35 <athan> master Applicatives before you jump into Monads, imo
12:48:39 <athan> er wait
12:48:43 <athan> wrong person >.>
12:49:30 <derekv> I went through the LYAH book a year or os ago, but it's hard retaining it when I don't use it daily 
12:49:50 <derekv> Blasting through katas on codewars is helping
12:49:56 <varaindemian> athan: but curry f = \ (x, y) -> f x y seems to be the opposite of its tipe
12:50:24 <varaindemian> curry f = \ x y -> f (x ,y), my bad
12:50:44 <athan> varaindemian: The first version was correct
12:50:52 <athan> curry f = \(x,y) -> f x y
12:50:57 <athan> @src curry
12:50:57 <lambdabot> curry f x y = f (x, y)
12:51:00 <athan> er wait
12:51:03 <athan> my brain is wrong
12:51:10 <varaindemian> athan: well in the exercise it's the opposite...
12:51:15 <varaindemian> yes
12:51:17 <athan> varaindemian: We masque the old version of `f` with the new one
12:51:21 <varaindemian> my brain is wrong as well
12:51:57 <varaindemian> curry f = \ x y -> f (x, y) is the correct one
12:52:15 <varaindemian> athan: which doesn't make any sense for me
12:52:29 <athan> varaindemian: well, think about the type of `f`, the original function
12:52:35 <athan> it's one that takes a tuple as an argument
12:53:16 <athan> in order to "turn it into" one that takes two successive inputs instead, we need to "wrap" `f` with the lambdas, then build our tuple manually and apply it into the original `f`
13:01:43 <varaindemian> athan: then it would make more sense curry f = f (x, y) -> \ x y 
13:01:53 <athan> :|
13:01:55 <athan> nope
13:02:02 <athan> that's not valid haskell syntax
13:02:19 <athan> a lambda expression `\ x y ... n` _must_ be followed by an arrow `->`
13:02:27 <athan> to distinguish name binding from the rest of the expression
13:02:51 <athan> so `\name -> restOfExpression`
13:02:53 <athan> is fine
13:03:21 <athan> or `\x y z -> x + y + z` is fine, because `x + y + z` is an expression, and the lambda binds the names for the variables
13:05:14 <varaindemian> ok. this curry thing is...
13:22:39 * hackagebot hlint 1.9.24 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.24 (NeilMitchell)
13:25:10 <jophish> edwardk: how about findZeroNoTruncate, a bit of a mouthful though
13:28:03 * hackagebot lentil 0.1.7.1 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.7.1 (fffaaa)
13:28:58 <rvxi> getting a bunch of errors with these gpipe demos that look like
13:29:43 <rvxi> "No instance for ..." arising from a use of ‘runContextT/compileShader/etc.' The type variable ‘m0’ is ambiguous
13:35:32 <rvxi> anyone have an idea what the issue might be? This is with ghc 7.10.2
13:38:03 * hackagebot lit 0.1.0.9 - A simple tool for literate programming  https://hackage.haskell.org/package/lit-0.1.0.9 (cdosborn)
13:40:09 <Cale> rvxi: I'd have to see the code.
13:40:40 <rvxi> trying to reproduce hello triangle example:
13:40:41 <rvxi> http://tobbebex.blogspot.se/2015/09/gpu-programming-in-haskell-using-gpipe.html
13:40:52 <rvxi> reinstalled with the latest GPipe
13:41:03 <rvxi> Cale: 2.1.4 and GPipe-GLFW-1.2.1
13:53:10 <Bruuuuuuno> I have some functions like this (Foo a, Bar a, Baz a) => a -> b
13:53:43 <Bruuuuuuno> is there a way to bind Foo Bar and Baz to something else and write (Something a) => a -> b
13:56:52 <muesli4> Bruuuuuuno: https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/constraint-kind.html
14:00:54 <radix> oh, that's cool.
14:03:04 * hackagebot Michelangelo 0.2.0.0 - OpenGL for dummies  https://hackage.haskell.org/package/Michelangelo-0.2.0.0 (SwiftsNamesake)
14:03:20 <Bruuuuuuno> thx
14:05:12 <akegalj> hey. Can I somehow fork a thread (or a process) and tell it can consume max X memory. If it whant's more, then error is thrown. I saw they did something like this in Facebook with Haxl (https://www.reddit.com/r/haskell/comments/3so691/the_road_to_running_haskell_at_facebook_scale/). Can someone point me on this functionality in ghc
14:08:05 * hackagebot swish 0.9.1.5 - A semantic web toolkit.  https://hackage.haskell.org/package/swish-0.9.1.5 (DouglasBurke)
14:09:07 <monochrom> no, I don't think GHC can do that
14:10:15 <akegalj> monochrom: oh, ok. They said they did push to GHC upstream this new functionality. I don't know anything more about this
14:11:21 <geekosaur> akegalj, not per thread (memory is a process limit) but http://hackage.haskell.org/package/restricted-workers/docs/System-Restricted-Limits.html#v:setRLimits
14:11:35 <geekosaur> maybe they added the rlimit syscalls to the unix library
14:12:37 <akegalj> geekosaur: ok, I am going to take a look at that. Thanks
14:13:22 <geekosaur> see also `man 3 setrlimit`
14:13:36 <geekosaur> sorry, section 2 not 3
14:13:47 <geekosaur> `man 2 setrlimit`
14:14:11 <akegalj> opened it. thanks
14:15:57 <geekosaur> (also beware of Linux kernel version; older kernels don't implement all of setrlimit())
14:18:35 <mitchty> right so if you were going to be writing a rest service in haskell would servant/spock be a good choice? (yesod is overkill for my needs, spock looks about perfect, curious what people use)
14:18:38 <dalastboss> if i intend to perform some effectful operation for each element in a list, is "sequence_ $ map f xs
14:18:40 <dalastboss> "
14:18:42 <akegalj> geekosaur: thanks, that is useful. We will probably use this on older kernel. I'll check it
14:18:49 <dalastboss>  the intended way of doing it?
14:19:12 <dalastboss> or is there something along the lines of an iter function
14:19:23 <Rembane> dalastboss: mapM_ is even better.
14:19:29 <Rembane> deavmi_mobile: mapM_ f xs
14:19:32 <Rembane> Meh
14:19:35 <rvxi> mitchty: yesod isn't so bad imo
14:19:40 <Rembane> deavmi_mobile: Sorryy, mischat.
14:19:52 <Rembane> dalastboss: mapM_ f xs
14:20:12 <akegalj> mitchty: servant is great. You should check it (but lots of things are in development, they have added auth just recently). But i highly recomedend to check. Try both.
14:20:15 <mitchty> rvxi not saying its bad just seems overkill for what I have
14:20:55 <dalastboss> understood, thanks
14:21:14 <mitchty> this is mostly a passthrough to a backend daemon, so all it need do really is auth/json stuff/etc...
14:21:50 <mitchty> akegalj will do, i did some spock stuff to test out their auth changes recently, its rather nice
14:22:11 <akegalj> mitchty: I think servant will be good fit for that
14:23:01 <mitchty> akegalj well i'll get a quick prototype of one endpoint up and see what its like, its been on my to try list anyway :)
14:23:27 <mitchty> i'll tackle yesod in march when its too cold to walk outside
14:24:47 <akegalj> mitchty: also check #servant . They are nice guys, really helpfull
14:25:13 <mitchty> akegalj oh yeah, i always forget to look for channels, good call
14:28:05 * hackagebot keera-hails-reactivelenses 0.0.1 - Reactive Haskell on Rails - Lenses applied to Reactive Values  https://hackage.haskell.org/package/keera-hails-reactivelenses-0.0.1 (IvanPerez)
14:30:18 <Jello_Raptor> hmm
14:31:27 <Jello_Raptor> is there some way to figure out the type an expression would evaluate to in the current environment in template haskell? some "Exp -> Q Type" 
14:33:15 <jophish> mokus: Are you about for me to quiz you about the converge package?
14:38:16 * hackagebot servant-JuicyPixels 0.3.0.0 - Servant support for JuicyPixels  https://hackage.haskell.org/package/servant-JuicyPixels-0.3.0.0 (TvH)
14:43:16 * hackagebot Michelangelo 0.2.1.0 - OpenGL for dummies  https://hackage.haskell.org/package/Michelangelo-0.2.1.0 (SwiftsNamesake)
14:48:17 <JagaJaga> Are zippers related to comonads?
14:50:41 <johnw> yes, they are
14:51:46 <johnw> http://stackoverflow.com/questions/25554062/zipper-comonads-generically
14:52:20 <johnw> I believe there are also paper that research the connection
14:58:17 * hackagebot exact-real 0.10.0 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.10.0 (jophish)
15:03:59 <haskell562> Hi there guys. I am beginner to Haskell  and i would like to ask a question regarding head function 
15:04:46 <johnw> ask away
15:04:52 <Iceland_jack> Shoot yo
15:05:09 <haskell562> Thank you . 
15:05:29 <haskell562> head [ (x,y) | x <- [1..9], y <- [1..x] , mod (x+y) 5 == 0]
15:05:39 <haskell562> so i have list that extends from 1 to 9 
15:05:45 <Iceland_jack> Yes
15:05:49 <haskell562> and other list that extends from 1 to the previous list
15:06:03 <haskell562> i am not sure how i come to the answer (3,2) 
15:06:22 <Iceland_jack> Let's first remove the head and the guard "mox (x+y) 5 == 0"
15:06:23 <Iceland_jack> > [ (x,y) | x <- [1..9], y <- [1..x] ]
15:06:25 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5,...
15:06:42 <Iceland_jack> Then you see the order
15:07:07 <haskell562> oh that is so good . Now i understand .. thank you so much :)
15:07:47 <Iceland_jack> You can also try:
15:07:47 <Iceland_jack> > [ (x,y) | x <- [1..9], y <- ['a'..'z'] ]
15:07:49 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(1,'d'),(1,'e'),(1,'f'),(1,'g'),(1,'h'),(1,'i'),(1,...
15:08:00 <Iceland_jack> That makes it way more obvious which one is "slower"
15:08:49 <haskell562> Thank you iceland jack and everyone . This is a great chatroom 
15:10:37 <varaindemian> what does \ x y stand for in curry f = \ x y -> f (x, y)
15:11:17 <pavonia> A function with two parameters x and y
15:12:19 <Axman6> > (\x -> x*x) 7
15:12:20 <lambdabot>  49
15:12:33 <Axman6> > (\x y -> x*x + y) 7 20
15:12:35 <lambdabot>  69
15:12:38 <kadoban> varaindemian: It's syntax for a lambda function.
15:13:29 <varaindemian> and why do we need it there? we could simply type curry f x y = f (x, y)
15:14:45 <varaindemian> how do we read this whole thing? curry f = \ x y -> f (x, y)
15:15:31 <hpc> just to avoid confusion, it's worth mentioning that's the wrong definition of curry
15:15:34 <hpc> @src curry
15:15:34 <lambdabot> curry f x y = f (x, y)
15:15:42 <hpc> oh wait, nvm
15:16:00 <MarcelineVQ> hpc: You thinking of uncurry? :>
15:16:02 * hpc https://media.giphy.com/media/4pMX5rJ4PYAEM/giphy.gif
15:16:06 <varaindemian> yes... it thucking hurts
15:16:15 <varaindemian> I ca not udnerstand it
15:16:18 <geekosaur> varaindemian, that may be there to teach you that those are the same thing?
15:16:28 <geekosaur> and this is how partial application works
15:17:01 <hpc> (in my defense, someone earlier had curry and uncurry reversed)
15:17:29 <varaindemian> hpc: I was that one ahah
15:17:43 <varaindemian> hpc: still have problems at understanding 
15:17:53 <jophish> haha, ghc just told me "error| My brain just exploded"
15:19:54 <varaindemian> so, how do we read this curry f = \ x y -> f (x, y)?
15:20:29 <geekosaur> curry f returns a function that takes teo parameters and produces the result of applying f to a tuple of those parameters
15:20:33 <geekosaur> *two parameters
15:20:55 <detrumi> curry is a function taking one argument (f), returning a new function which takes two arguments
15:22:52 <varaindemian> detrumi: that's all?
15:24:34 <detrumi> varaindemian: Yeah, it's just writing a function as an expression
15:25:35 <d-snp_> varaindemian: are you interested in the curry function, or in the syntax of lambdas in haskell?
15:28:05 <d-snp_> varaindemian: definition of curry in javascript: function curry(f) { return function(x) { return function(y) { return f(x,y); } } }
15:28:09 <varaindemian> d-snp_: it looks like I'm interested in both since they are corelated. I thought I understood lambda
15:29:23 <d-snp_> the syntax of lambda is a bit weird, it's designed with the braces around it, so (\ x y -> x + y)
15:29:37 <d-snp_> the designer though (\ looks a bit like the greek letter l (lambda)
15:29:49 <d-snp_> you'd have to be squinting pretty hard to get that :P
15:30:26 <d-snp_> and of course, now everyone drops the braces, so it's just a lone \
15:30:35 <hpc> i heard the lambda character was going to be ampersand or something like that
15:31:22 <detrumi> hpc: that would look really confusing
15:31:28 <d-snp_> (& x y -> x + y)
15:31:50 <d-snp_> not much more confusing than the \ imo but perhaps also not much clearer :P
15:32:19 <d-snp_> hm at least \ isn't used for anything else right? maybe regexes?
15:32:39 <MarcelineVQ> \"whatever do you mean?\"
15:32:58 <d-snp_> right escapes
15:33:06 <icen> It's quite tempting to just allow lists of patterns followed by -> and a function body, but that probably has awkward parsing edge cases
15:33:12 <d-snp_> varaindemian: did you understand my javascript example? :P
15:33:35 <MarcelineVQ> icen: doesn't pattern guards have exactly that?
15:34:27 <icen> I don't know that extension; it might do, but maybe in a more restricted way
15:34:27 <d-snp_> yes, but they have a fancy sugar with an opening ceremony (case..of)
15:34:36 <d-snp_> or the |
15:34:49 <MarcelineVQ> icen: it's baseline now https://wiki.haskell.org/Pattern_guard
15:34:55 <Cale> d-snp_: It's not with the bracket
15:35:08 <Cale> \ on its own is meant to look like λ
15:35:22 <d-snp_> ah
15:35:24 <d-snp_> ok :D
15:35:56 <icen> MarcelineVQ: ah, thanks.
15:37:27 <varaindemian> d-snp_: unfortunately I don't know java scrip
15:37:32 <varaindemian> script
15:38:44 <d-snp_> that's not unfortunately :D I wish I lived in a world where not knowing javascript was possible :D
15:39:29 <detrumi> curry f = let g x y = f (x, y) in g
15:39:40 <d-snp_> it's like that john lennon song.. imagine there's no javascript, and no php too, imagine all those people.. writing Haskell as one... oh oh..
15:41:01 <varaindemian> d-snp_: is it possible to be totally replaced by some functional programming language?
15:41:19 <Peaker> d-snp_: I don't know (much) Javascript (I don't touch web dev atm)
15:42:26 <rcyr> Why not?
15:42:43 <arw_> varaindemian: theoretically, any programming language can replace any other.
15:43:02 <d-snp_> well that's *very* theoretic :P
15:43:06 <rcyr> Haskell for COBOL!
15:43:59 <arw_> d-snp_: its maybe so theoretic, its practically wrong ;)
15:44:01 <d-snp_> varaindemian: well you might say I'm a dreamer, but I'm not the only one :)
15:44:40 <d-snp_> (as in yes, and I think many people hope that one day all programming is done in Haskell or some other nice fp language)
15:45:50 <arw_> well, up to certain exceptions. I think there won't be a processor directly executing Haskell or any kind of nice language at all.
15:46:25 <arw_> so someone has to create those middle layers between the hardware and the area of niceness above
15:46:59 <cite-reader> We had Lisp machines, once.
15:47:22 <d-snp_> varaindemian: right back at the invention of computer languages, there were two ways of thinking about it, that were shown to be equivalent, one is the functional one, based on "s-expressions", the other the imperative one based on (turing) machines
15:47:23 <rcyr> It's weird how people still seem to think that LISP was a FP language.. :/
15:48:20 <detrumi> d-snp_: Equivalent up to performance?
15:48:25 <rcyr> s-expression? You mean Church's lambda calculus?
15:48:31 <d-snp_> yeah
15:48:43 <d-snp_> I'm not a great historian >_>
15:49:16 <arw_> rcyr, cite-reader: and lisp machine ASM isn't that much nicer. it had typed memory and a few more things, but nothing really nice of the "one could use this every day" kind of niceness.
15:50:14 <rcyr> When you think about it... was Turing the most evil person that ever existed? :P
15:50:20 <cite-reader> No.
15:50:34 <cite-reader> Next case.
15:50:38 <rcyr> :)
15:50:40 <varaindemian> rcyr: that's exactly what I was thinking about lol
15:50:43 <d-snp_> detrumi: no equivalent as in power of expression, i.e. they were both turing complete
15:51:06 <arw_> detrumi: in a certain sense including performance.
15:51:19 <justin_smith> rcyr: if you look at its context, it had a concept of expressions, values, and at least the convention of immutable data remarkably early (1950s) - but by the time the late '70s came around there were definitely more functional alternatives
15:52:00 <arw_> detrumi: you just prove that your language can simulate a turing machine, and theorize your actual universal programs running on that turing machine.
15:52:00 <d-snp_> detrumi: a cool thing about performance though is that if your program has a functional compilation step, like haskell has, there's all sorts of optimizations possible that are harder in imperative style
15:52:05 <monochrom> imagine everyone writing in Haskell... uh oh
15:52:16 <justin_smith> rcyr: which themselves were first implemented in lisp (because that was the easy way to do it)
15:52:35 <rcyr> True that.
15:57:49 <rcyr> What I mean where I was saying that Turing was evil... Would we be living in a world of FP bliss if the turing machine would have never been discovered? :P
15:58:08 <d-snp_> I'm afraid not
15:58:35 <detrumi> At that time, the turing machine simply was the most logical next step
15:58:37 <JagaJaga> Thank you johnw.
15:58:50 <JagaJaga> That's the difference between lens and prisms?
15:58:51 <d-snp_> I don't think any machine has been invented that could run s-expressions with decent performance without first translating it to sequential code
15:59:07 <d-snp_> though perhaps it is because people aren't trying very hard
15:59:47 <arw_> rcyr: I think sequential execution is just the most basic and simple paradigm for building hardware.
16:00:24 <arw_> rcyr: and computing really started from bare hardware with rewirable plug-board-thingies.
16:00:49 <rcyr> Right
16:01:37 <arw_> also, the turing-machine wasn't considered a model to build hardware alike.
16:02:33 <arw_> rather, it was invented as a simplified abstract model to reason about how computing was done 
16:02:55 <arw_> i.e. what hardware or even humans do to do calculations
16:05:01 <d-snp_> I wonder if there's any simplest problem that requires a turing machine to be implemented?
16:05:54 <cite-reader> Good question, actually; is there any intermediate step between "use a pushdown automaton" and "screw it throw a TM at it"?
16:08:10 <d-snp_> so I guess in theory that question would be, is there a problem that can only be expressed in a non-deterministic context-free language right?
16:08:34 <arw_> cite-reader: there is something in between in the chomsky hierarchy: https://en.wikipedia.org/wiki/Chomsky_hierarchy
16:09:05 <arw_> cite-reader: although its a limited variant of a TM
16:09:20 <d-snp_> would the answer be 'a turing machine' ?
16:09:31 <d-snp_> obviously the least you need to implement a turing machine, is a turing machine..
16:10:07 <d-snp_> could anything less complicated than a turing machine require a turing machine to implement?
16:11:13 <muesli4> d-snp: It has to be that way, otherwise your hierarchy would collapse. :)
16:12:08 <detrumi> d-snp_: There's a thing called a universal turing machine, which can simulate an arbitrary turing machine
16:13:33 <arw_> d-snp_: the issue is that your question is too fuzzy. i'm not sure about the "anything" part.
16:14:06 <d-snp_> a program, a solution to a problem
16:14:53 <arw_> d-snp_: but if you just look at machines simulating other machines, then the answer would be "its an equivalence class", so any machine that can only be simulated by a TM has to be a TM.
16:15:05 <arw_> d-snp_: for programs, no.
16:15:33 <justin_smith> d-snp_: trivially false - if you know it doesn't require a turing machine, you can describe a machine weaker than turing's that will calculate the result
16:16:05 <arw_> d-snp_: take the task of calculating pi. you need a TM for that. but an algorithm to calculate PI can't simulate a TM.
16:17:24 <justin_smith> arw_: I'd be fascinated to see proof of those two statements (not that I have any disproof mind you)
16:17:25 <d-snp_> hm
16:17:49 <d-snp_> does calculating pi really need a turing machine?
16:18:28 <Axman6> calculating pi only needs a dart board and an infinite number of darts
16:18:38 <karshan> hey, I'm wondering what are the alternatives to mtl, and are types like WriterT (ReaderT (StateT .... considered a disadvantage due to more boilder plate ?
16:18:49 <d-snp_> :D
16:18:53 <arw_> ok, first for the pi thingy, to answer both your questions: "calculating pi" in that context is just "recognizing the 'language' pi".
16:19:01 <Iceland_jack> Axman6: I have a few in storage if you need 
16:19:47 <d-snp_> is.. Pi non-deterministic and context free? :D
16:20:50 <arw_> pi is not chomsky 1 through 3, because then it would be quite boring :)
16:21:52 <d-snp_> Axman6: I think you'd need the answer to pi just to get the dartboard in the computer ;)
16:22:13 <d-snp_> oh
16:22:14 <Axman6> nah, string can compute lines based on pi trivially
16:22:15 <d-snp_> no you dont
16:22:41 <arw_> d-snp_: sqrt(x^2 + y^2) < r is sufficient.
16:22:44 <rcyr> Hehe, thanks for the interesting answers :)
16:22:48 <d-snp_> yeah
16:29:20 <arw_> justin_smith: for the equivalence class thingy, its just "by definition". 
16:30:19 <justin_smith> oh, right, of course, thanks :)
16:30:36 <arw_> justin_smith: but really its more "i don't know and I haven't heard anything to contradict it"
16:34:31 <jophish> Why is there no UNDECIDABLE pragma to go with the overlapping and incoherent ones?
17:04:12 <obadz> jophish: isn't there?
17:07:12 <ReinH> jophish: there is.
17:07:27 <ReinH> UndecidableInstances
17:07:54 <obadz> there there now :)
17:13:08 <rvxi> question - how do i get "cabal repl" to recognize the .ghci file in a cabal project directory
17:13:09 <rvxi> ?
17:18:35 <harwiltz> Hello, does anyone have any experience with hscurses?
17:21:36 <rvxi> not me
17:22:48 <Gurkenglas> How did joph deduce the term "undecidable" from the terms "overlapping" and "incoherent"? Is there some mathematical theory that's being applied here?
17:26:09 <obadz> Gurkenglas: a category theory of compiler typeclass hacks? :)
17:27:40 <Gurkenglas> Dunno, I just thought that since neither of jophish's and GHC's use of the word "undecidable" can have caused the other, there must have been some third thing that caused both, and am asking for it.
17:28:35 <jophish> ReinH: I can't see it in the ghc docs
17:29:20 <jophish> I meant, one can mark a particular instance as OVERLAPPING, why not the same for UNDECIDABLE
17:31:55 <Thom__> Can I have a function that takes a Num parameter and returns an Integer if the input was an Integral, but returns an error otherwise? I can't come up with any solution for that >.>
17:32:24 <geekosaur> Thom__, no, typeclasses do not give you typecase
17:33:13 <shachaf> Nor classcase.
17:35:15 <Thom__> I'm not sure what you mean, but I would be able to match the constructors of a custom class right? So because Ints and Integers are special it's not possible for them?
17:35:31 <shachaf> Classes don't have constructors.
17:35:46 <Thom__> custom data types*
17:36:00 <shachaf> Int and Integer aren't special.
17:36:23 <shachaf> They're two unrelated types.
17:36:53 <jophish> This might be relevant https://github.com/mikeizbicki/ifcxt#ifcxt
17:37:16 <jophish> however this is somewhat of a trick and there's nearly always a better way of structuring the program
17:37:33 <obadz> Thom__: what is the context of what you are trying to do
17:38:02 <jophish> Thom__: if you want to return an error if the type is not an instance of Integral why not use an Integral constraint?
17:38:07 <jophish> then the error is at compile time!
17:38:58 <obadz> Thom__: where is this data coming from that it's sometime Integral and sometimes not?
17:39:06 <Thom__> I have to process Entries ( data Entry = Text String | Number Integer deriving (Eq, Show) )
17:39:25 <Thom__> and it's a homework with a given type signature
17:39:43 <obadz> well looks like Number is always an Integer
17:39:49 <obadz> so why the uncertainty?
17:40:11 <Thom__> and unluckily that type signature forces the type (Integer -> Integer) for the processing function
17:40:35 <Thom__> omg am i really so blind that I did not see that >.>
17:40:46 <Thom__> thank you, indeed there should be no problem then
17:41:02 <obadz> there you go :)
17:41:19 <Thom__> but now I'm wondering would it be possible if it was not?^^
17:41:31 <obadz> how would it be if it was different?
17:41:41 <obadz> what would be the type of Number?
17:41:48 <Thom__> Num
17:41:55 <Thom__> that was my assumption so far
17:42:13 <obadz> well then Entry would take a type argument a
17:42:57 <obadz> you could pass Number a through any function that takes a Num a => a
17:43:01 <geekosaur> Num is not a type
17:43:04 <obadz> Integral a would be off limit
17:43:10 <Thom__> data Entry = (Num a) => Text String | Number a deriving (Eq, Show)
17:43:12 <Thom__> like this?
17:43:16 <obadz> yes
17:43:21 <obadz> data Entry a
17:44:00 <obadz> hmmm
17:44:12 <obadz> actually I don't think you put the constraint here
17:44:41 <obadz> data Entry a = Text String | Number a deriving (Eq, Show)
17:45:09 <obadz> then presumable your function takes an Entry a would now take a Num a => Entry a
17:45:31 <bloatWare> i found this online
17:45:33 <bloatWare> https://gist.github.com/quchen/5280339
17:45:37 <bloatWare> pretty awesome haha
17:46:03 <Thom__> ok so there's a difference between Integral/Num and Int/Integer?
17:46:54 <Cale> Thom__: They are completely different sorts of things. Integral and Num are type classes, while Int and Integer are types.
17:47:31 <Cale> Integral and Num specify operations which a type may or may not implement, and they can be used to constrain the types over which type variables range
17:47:59 <Cale> Int and Integer are both instances of both of those classes
17:48:51 <Thom__> ah ok
17:49:07 <obadz> bloatWare: mouahahah
17:53:47 <bloatWare> would u guys recommend xmonad for a Haskell newbie?
17:53:57 <heliospan> LOL, I have to write node.js all day, that's part of my motivation to learn haskell, I guess. :/
17:54:15 <heliospan> bloatWare: +1 xmonad
17:55:03 <heliospan> you don't need to know about monads to use xmonad, the configuration file is in haskell, and it's not hard.
18:05:19 <geekosaur> xmonad is a bit of a gateway drug for haskell >.>
18:05:44 <bloatWare> hahaha i'll be looking forward to it
18:06:38 <Digit> :) well said.  ^_^
18:07:31 <lamefun> Oh, the sweet lies of diversitivism... https://github.com/haskell/vector/pull/102
18:07:57 <lamefun> IMO Haskell needs a ONEist vertical of rule (preferably Microsoft).
18:09:22 <lamefun> Or Google.
18:09:44 <ReinH> Are you using real words?
18:12:02 <lamefun> Sadly, English doesn't have words powerful enough to convey the truth. I think it's easy to infer what I mean by the context I think.
18:12:39 <Digit> i imagine diversitism refers to a dogmatic ideology of diversity is good/better/best, above all other considerations.   
18:13:02 <jle`> i cannot even infer from the context what those words are supposed to mean :|
18:13:42 <CoconutCrab> that sounds contradict, 'one dogmagic ideology' that encourage 'diversity'
18:14:01 <Digit> i think "ONEist" refers to fascism and a totalitarian authority dictating how everyone should do things.
18:16:42 <rvxi> is there a good way to display a text progress bar for a map operation?
18:18:04 <Cale> rvxi: If you're willing to replace map with mapM
18:18:19 <rvxi> cale: i am
18:22:34 <Cale> There are various libraries on hackage for actually drawing a progress bar, but the idea is just to write something like   rs <- mapM (\x -> do y <- evaluate (f x); tickProgress; return y) xs  and have this happening in a separate thread (or perhaps as an Async, using the async package)
18:23:20 <Cale> tickProgress will be modifying a progress amount in an IORef or MVar or something, and the other thread which is displaying the progress would read that mutable variable and draw something appropriate.
18:23:46 <Cale> Or maybe you just draw the bar right in the loop and don't bother with the threads
18:24:16 <Cale> (but if you want, e.g. the ability to cancel the operation, maybe threads are nice)
18:24:49 <gridpapermolskin> I am having a heck of a time trying to figure out how to generate a list of normal-distributed values with mwc-random. Is it something with the State monad?
18:32:38 <Cale> gridpapermolskin: just take m = IO
18:32:41 <nmryan> createSystemRandom >>= (replicateM 10 . normal 0 0.5) for example
18:32:50 <nmryan> either in IO or ST s
18:34:03 <gridpapermolskin> nmryan: thanks! I don't understand though... how do the Gen values get passed into each replicated call of "normal"? 
18:34:53 <Cale> I'd probably write  do g <- createSystemRandom; replicateM 10 (normal 0 0.5 g)  which means the very same thing
18:36:31 <gridpapermolskin> Cale: it helps to see it in several styles
18:37:38 <jle`> i don't think any sane person writes createSystemRandom >>= (replicateM 10 . normal 0 0.5)    :|
18:38:01 <Cale> replicateM 10 . normal 0 0.5 =<< createSystemRandom  isn't so bad though
18:38:44 <jle`> yeah that one ain't
18:38:51 <Cale> Well, provided you're discarding the generator
18:39:28 <Cale> You probably ought not to discard the generator though -- you want to create it once and pass it around rather than executing createSystemRandom a whole bunch.
18:39:29 <gridpapermolskin> why though does it use a different generator for each call to normal instead of the producing the same number 10 times?
18:39:35 <Cale> It does not.
18:39:58 <Cale> It updates the generator state which is referred to by the Gen value
18:40:06 <Cale> (which is mutable)
18:40:42 <Cale> Which is rather different from the style of System.Random
18:41:07 <Cale> where the generator states are themselves immutable values that you pass around, and the same state will lead to the same result
18:42:05 <Cale> (or e.g. tf-random also uses that more immutable style)
18:42:47 <nmryan> gridpapermoleskin: once you create your generator, and apply it to normal (like Cale's example first creating the generator g and then passing it to normal) you have a value of type IO Double
18:43:47 <nmryan> and you can replicate it and do what you want. the mutability of the generator (since its in IO) allows it to change when it is used to generate a number, so each time it is evaluated in the value IO [Double] it creates a new number
18:44:21 <Cale> nmryan: Yeah, the thing which is confusing I think is just that 'g' here isn't actually a PRNG state, but rather what is effectively a mutable reference to one.
18:44:34 <gridpapermolskin> okay yeah I was assuming it was like system.random, thanks everyone.
18:44:52 <jle`> an...immutable reference to a mutable value
18:47:15 <Cale> jle`: uh, a mutable reference to an immutable value, unless I'm mistaken...
18:47:38 <Cale> Well, g itself is an immutable value which is one of those mutable references :)
19:09:56 <jle`> yeah i should have put triple question marks after that last statement
19:23:18 <anon25502> Hello #Haskell, I'm working on a small program to learn about data and types, I created a Datatype 'Datest', which includes fields 'a :: String' and 'b :: [String]', but what if the data I receive got something else inside of instead of [String]? I created the type 'Btype = Maybe [String]' for this, but is there a way to replace any incoming data that is not a [String] with an empty list instead?
19:23:24 <lpaste_> anon25502 pasted “learning about types and data” at http://lpaste.net/145806
19:25:39 <bergey> anon25502: Yes, that's possible, but it's hard to be more specific without knowing where your incoming data comes from.
19:25:51 <bollu> guys, two questions
19:26:05 <bergey> If it comes from a Haskell function, you already know its type.
19:26:22 <anon25502> bergy: my incoming data is from json, I'm using the aeson library
19:26:27 <bollu> 1) since every Traversable trivially provides an instance of Functor under the identity Applicative, we can say that "all Traversables are Functors" correct?
19:26:46 <tzh> anon25502: that's not, generally, how types works in haskell. you can do that if you want, but the standard approach would be to define `data Datest type = Datest { a :: type }`, and then build things of type `Datest String` or otherwise (Datest Bool, Datest Int, etc)
19:26:56 <bollu> but since we have 2 different typeclasses, I'm assuming Functor /= Applicative. So could someone give me an example of a Functor that is not a Traversable?
19:27:04 <bollu> Functor /= Traversable**
19:27:59 <jle`> bollu: (->) r is one that comes to mind
19:28:09 <jle`> also IO
19:28:25 <jle`> they're also not Foldables
19:28:33 <bergey> bollu: So something like `fromMaybe [] :: Maybe String -> String` to get empty list if you have a Nothing, and get the list of strings if you have one.
19:28:36 <bollu> also, question 2, I think I've understood continuations / callCC, but I don't know a huge amount of haskell / cat. theory / what have you. Even so, is it cool if I write a blog post or something trying to explain continuations in Haskell? or is it bad form to write about things that you don't understand at a very high level?
19:28:48 <bollu> jle`: ah right, I'd never considered IO
19:28:51 <jle`> bollu: anything where you can't write a meaningful `toList` is not a Foldable
19:28:55 <jle`> so it can't be Traversable
19:29:22 <jle`> and definitely anything that you can't `sequence` is not a Traversable.  there is no IO [a] -> [IO a]
19:29:28 <jle`> er i mean
19:29:35 <bollu> jle`: I love that interpretation of Foldable :) fold isomorphic to fold (:) [] == toList, correct?
19:29:36 <jle`> yeah
19:29:46 <jle`> mhm. but foldr
19:29:53 <bollu> oh right, yeah
19:30:22 <bollu> so, all containers are Functors but not the other way around. Cool
19:30:26 <bollu> and question #2?
19:30:35 <Cale> bollu: I don't think you should need permission to write blog posts :P
19:31:01 <bollu> Cale: I was asking about it being good form :P you know, I remember reading about a lot of people complaining about Monad posts :)
19:31:14 <Cale> bollu: Well, there are lots of bad monad posts, this is true
19:31:49 <f-a> https://hackage.haskell.org/package/lentil-0.1.7.1/reports/1 should I get worried by this report or it's just hackage ghc choking ?
19:32:11 <Cale> You might save yourself future embarrassment by trying to understand things really well before posting.
19:33:34 <bollu> sorry, bad internet :)
19:33:48 <bollu> Cale: yeah, I suppose you're right. You know, only explain things if you well and truly get them
19:34:25 <Cale> bollu: But often just writing things down is a good way to understand them better for your own sake
19:35:05 <Cale> and having other people comment on them and explain if/why you're wrong can be effective as well :)
19:35:07 <anon25502> tzh: Where would b go in this example?
19:35:19 <bollu> true. So, I guess I'll write it down, show it to #haskell and then see if it deserves to go up on the internet or not? :)
19:37:23 <jle`> we might be able to say if we feel it might generate more confusion than it would help, but it still would be a personal opinion, and it is up to you if you want to unleash it to the world or not :)
19:37:33 <tzh> anon25502: i didn't include it just in that snippet, but if you want a value of the same type as your type variable, then you could say `b :: Maybe type`.
19:37:54 <bollu> cool, thanks people :D you guys are awesome
19:38:31 * hackagebot b9 0.5.15 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.15 (SvenHeyll)
19:39:51 <tzh> anon25502: what the type ends up looking like depends a lot on what you're actually trying to do, it's just generally the idiomatic haskell solution isn't going to look like a polymorphic function that takes any type and returns the value if it happens to be a string (which, btw, is `cast` in Data.Typeable)
19:44:54 <solrize> i had a long running (24h) purely computational haskell script, it used around 1400 minutes user cpu, and 5 minutes system cpu... the 5 system minutes seems like a lot given that the script did basically no i/o.  any idea what it was?  garbage collection releasing storage and getting it back?
19:46:14 <anon25502> tzh: In my case I'm trying to read json data, decoding and extracting data from it (using the functions a and b I get from creating Data Datest), this works already, my question is mainly about the scenario in which one part of the incoming json is malformed, but the structure overall is correct, so that instead of reading an error, I'd treat it as empty, for example, this was my thought at least so far
19:48:20 <tzh> anon25502: well, this wouldn't help if you're doing this for a class, but there are already-existing JSON decoders in haskell -- http://hackage.haskell.org/package/json handles that.
19:49:12 <anon25502> tzh: not doing it for a class, only for learning purposes, I'm currently using the aeson library
19:49:57 <anon25502> tzh: so mainly this is a case which should be handled by the library? I guess my overall approach to this was a bit wrong I assume
19:51:22 <anon25502> tzh: Or better said, the library should include tools to handle such a case? I thought of it as a more general/common problem, but as I said, I'm still really new to haskell
19:51:57 <tzh> anon25502: well if you're decoding some JSON data and then trying to find something like a certain key, that can be handled by inspecting your resulting `Value` type, and then that function would be like `Value -> Maybe String`
19:52:31 <tzh> anon25502: and data structures wouldn't really enter into it except for storing the String/Maybe String, and would be build with the result of that function
19:53:05 <anon25502> tzh: Oh ok, so my approach of handling this at data/type level was wrong, I should tackle this problem on function level?
19:55:28 <anon25502> tzh: So I'd define the type as `Maybe [String]`, for example (else the decoding itself would fail), and then let my function handle the case of it not being [String]
19:56:59 <tzh> anon25502: i'm not super familiar with aeson's types, but it seems like what you would want is to use the FromJSON class to do it. that means you'd have to be able to write a function `Value -> Parser a` that does the decoding. aeson itself would error if the json is malformed, and you can either error or return Nothing if you can't parse the actual values into something meaningful
19:58:00 <tzh> anon25502: that being said, if you're just starting off i can see the type for `Parser` being kind of intimidating to use
20:02:26 <tzh> anon25502: the one time i've tried encoding/decoding json i used Text.JSON, which has a somewhat simpler interface that just decodes JSON strings into `JSValue` types, which you can peel apart like any other haskell value, and then the problem is just writing a `JSValue -> {whatever data you want out}` function
20:03:13 <anon25502> tzh: In my normal example in which I read a correct json file I'm reading the file (Bytestring), then use aeson's `decode`, on the result from decoding the json I use `a` or `b`, which gives me correct field as a result of the type I declared in `Datest` (at least the result behaves like I'd expect it to by trying out functions on it)
20:09:01 <anon25502> tzh: Since I declared `instance FromJSON Datest`, I assumed that what I receive from aeson is something of type `Datest` or a list of Datest `[Datest]`, if I got multiply objects in my json
20:11:20 <anon25502> tzh: This works so fard as I intended (even though I still have more reading to do to fully understand), I mainly wanted to know how to handle the "what if" case of an entry being something than expected
20:11:42 <anon25502> tzh: something else*
20:11:51 <tzh> anon25502: what does your code look like currently? that bit you posted didn't include any aeson/fromJSON parts
20:17:48 <Borromakot> Hey all :)  Experienced programmer, novice haskeller.  I'm having a little trouble understanding the purpose of `Endo a` from Data.Monoid.  I provide it a mapping from (a -> a), and then I see `appEndo` that corresponds to calling it.  What is the point?
20:18:04 <anon25502> tzh: ok give me a moment
20:18:52 <jle`> Borromakot: so you can use it with combinators/functions that are polymorphic over all Monoid
20:19:03 <Borromakot> Ah
20:19:18 <Borromakot> because an Endo is a Monoid
20:19:19 <jle`> there are a bunch of useful utility functions and stuff and combinators and libraries that give you functions polymorphic over all Monoid m
20:19:22 <jle`> yeah :)
20:19:24 <jle`> so you get to use it for those
20:19:39 <jle`> that's the main usage...you can always compose functions normally using (.) anyways
20:19:58 <jle`> appEndo (Endo f <> Endo g) is a little silly when you can just do f . g :)
20:19:58 <Borromakot> hmm.
20:20:22 <jle`> it's the same reason most of the newtypes in Data.Monoid exist, btw
20:20:24 <Borromakot> I still have a question, but I'm going to need a second to figure out what it is :D
20:20:33 <tzh> anon25502: i guess if you're using that `derive (Generic)` thing to get a FromJSON instance, you should be able to decode json abstractly, but i don't know exactly how that would line up given the way the type is constructed. it sounds like it depends somewhat on aeson's defaults, and that you can override or change them in the way mentioned here: http://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson.html#g:11
20:20:40 <jle`> like Product, First, Any, etc.
20:21:10 <Borromakot> how are mappend and mempty defined for an Endo though?
20:21:17 <Borromakot> all I see is appEndo
20:21:21 <jle`> none of them are *required* for normal programming, but using them you can throw them into monoid-polymorphic functions so you don't have to write them from scratch, and take advantage of other things with Monoid absractions
20:21:32 <jle`> Borromakot: you can look in the source
20:21:37 <Borromakot> might just be new at reading haskell docs
20:21:43 <jle`> mappend (Endo f) (Endo g) = Endo (f . g)
20:21:47 <jle`> mempty = Endo id
20:21:57 <Borromakot> interesting
20:22:16 <jle`> Borromakot: http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#line-82
20:22:43 <jle`> the anchor doesn't seem to be working for some reason, so you'll have to ctrl+f, heh
20:22:49 <jle`> kind of unfortunate
20:23:08 <Borromakot> its okay, I just found the "show source" button
20:23:11 <jle`> oh wait nvm
20:23:19 <jle`> yeah, that works with the right anchors
20:23:23 <jle`> i clicked the wrong link, heh
20:23:30 <anon25502> tzh: looks like this
20:23:31 <lpaste_> anon25502 pasted “aeson example” at http://lpaste.net/145811
20:24:23 <jle`> Borromakot: in practice Endo is used most often with Monoid-generic functions like `foldMap` and w/ the Applicative/Monad instances for Writer
20:24:52 <Borromakot> yeah, I have an example here showing how foldr could be implemented with foldMap
20:25:00 <Borromakot> foldr f z xs = foldMap (\x -> Endo (f x)) xs                      `appEndo` z
20:25:06 <Borromakot> sorry for the spacing
20:25:21 <Borromakot> ohhhhhhhhh
20:25:22 <jle`> yeah, it's kind of cute
20:25:35 <anon25502> tzh: thank you for the link, so mainly you'd say there is no general approach to something like this, and it depends on the circumstances or the kind of data one is working with? Since I thought it was generally data and type related.
20:25:37 <Borromakot> because foldMap corresponds to composing the folding/mapping function
20:25:45 <Borromakot> function(s)
20:25:49 <jle`> yeah, foldMap maps it and then mappends everything together
20:25:58 <jle`> so here you're specifying that mappending = composition
20:26:07 <Borromakot> interesting
20:26:15 <jle`> ocharles__ has a nice article on using Endo with Writer
20:26:21 <jle`> https://ocharles.org.uk/blog/posts/2013-02-12-quick-dsls-with-endo-writers.html
20:26:33 <tzh> anon25502: well what you want is to decode all well-formed json, but just decodes to an empty Datest if the json happens to not have the right values in it, right?
20:26:34 <Borromakot> Man, I can hoover up programming languages really easily, but haskell is kicking my ass.  Very enjoyable though
20:26:39 <jle`> although i would technically consider it a bit of a do notation hack
20:26:47 <jle`> but the Monoid instance lets the do notation hack work
20:27:30 <jle`> you can technically do something very similar without Endo, but Writer's Monad instance lets you write it in a cute dsl kinda way through do notation abuse
20:27:35 <anon25502> tzh: no, not exactly, I want to decode a well-formed json, my question targets the case in which only a single field in this overall correctly formed json has an unwanted entry
20:27:51 <jle`> but it requires a Monoid instance, so...Endo to the rescue :)
20:28:08 <anon25502> tzh: like if i'd receive json data for a person with name and age in it, but the age field contains a String instead or an Int, for example
20:28:24 <anon25502> tzh: instead of*
20:28:39 <Borromakot> gotcha.
20:28:50 <Borromakot> jle: Thanks for all the help!
20:29:05 <jle`> np!
20:30:26 <jle`> monoids and monads have an intimate relationship in haskell, and every Monoid instance m gives you a corresponding Monad `(,) m` or `Writer m`, so a lot of people take advantage of this to abuse do notation to make cute dsl's
20:31:26 <anon25502> tzh: Or in my small example, I want to read a json with a String, and a list of Strings in it, but of those 2 entries got an Int in it, instead of a String, or I receive a String where a list of Strings is expected
20:33:38 * hackagebot lentil 0.1.8.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.8.0 (fffaaa)
20:35:20 <anon25502> tzh: this is why I kinda thought that the "easiest" solution to simply treat this field as empty, should this happen, so if I receive `1` where my program expects `"something"`, I'd treat it as `""`
20:35:39 <tzh> anon25502: sounds like your problem hinges a lot on the specific way aeson decodes stuff, & i don't know enough about that to give particularly useful advice. seems like aeson does have ways to handle that case, it's just it requires messing around with its parser in ways that are probably pretty complex
20:38:04 <anon25502> tzh: Ok, still thank you very much for your time. So you'd say that there is no general "simple" approach (ignoring the case that I'm reading json data, or using a specific library), to this case?
20:39:41 <c_wraith> anon25502: unlike tzh, I see nothing aeson-specific about your issue
20:39:47 <c_wraith> anon25502: it sounds purely like business logic
20:40:04 <c_wraith> anon25502: You're getting malformed data.  You need to make a business decision about how to handle it.
20:42:37 <Borromakot> is there a way to see what Type classes are implemented for certain types?  Like some ghci command or something.  :t or :k
20:43:45 <pavonia> Borromakot: ":i type" should work
20:43:59 <Borromakot> nice
20:44:01 <Borromakot> thanks :D
20:44:05 <c_wraith> Borromakot: It only shows instances in scope, though
20:44:15 <c_wraith> Borromakot: imports might add additional instances
20:44:19 <Borromakot> I'll keep that in mind.
20:44:59 <c_wraith> Borromakot: it's kind of necessary restriction.  A new module could always add new instances.
20:45:27 <Borromakot> For sure.
20:45:31 <rvxi> is there a shortcut to repeat the last :l
20:45:40 <rvxi> for example instead of ":l Main.hs"
20:45:47 <rvxi> have some shortcut to avoid typing Main.hs?
20:45:49 <tzh> anon25502: i mean in the general case of transforming one kind of data into another kind of data there are lots of different ways to go about doing that. it's just here all that is happening inside aeson's black-box decode function, so if you want the parsing to be more permissive in a certain specific way you need to be able to say that specifically in some fashion
20:46:41 <c_wraith> rvxi: :r
20:46:50 <c_wraith> rvxi: it reloads all interpreted modules
20:47:42 <rvxi> c_wraith: nice
20:56:48 <anon25502> tzh: But it's not that I like to transform data from one type to another, its more like (from function view) "I expect this type of data, and I will do something with this data, if I do not receive the type of data I expect, I will continue to work with a specific case of the type of data I expected instead", like "I expected String, received Int, so I continue with an empty String"
21:00:16 <tzh> anon25502: it's possible to do that with `cast`, in Data.Typeable (http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Typeable.html#g:4), which is just "given any value as any type, evaluate to Nothing if it's not the type we want or Just {original value} if it is".
21:01:31 <tzh> anon25502: but a lot of what idiomatic haskell tries to do is explicitly not that. like, saying "this value is either going to be a String or an Int, and if it's a String do this, and if it's an Int do that"
21:02:36 <tzh> anon25502: rather than accepting things of any type, since if you e.g., accidentally pass some code a function instead of your number-or-string generally you'd like that to be an error instead of something that's silently accepted by the compiler as okay
21:07:14 <anon25502> tzh: Oh ok, I understand, but isn't it in some cases to handle the error instead of rejecting everything? I mean, it's not like I'm accepting this wrong value, it's more like I do not want to accept a value and then treat this value as empty
21:08:04 <anon25502> tzh: in some cases wanted*
21:11:41 <tzh> anon25502: right, but in that case the valid-but-ignorable types are still a pretty small subset of all types. you'd want to accept any possible json value and then ignore it if it's not a string, but that still means there are a bunch of types you wouldn't want to ignore: functions, io values, large datatypes like maps or trees, etc. stuff like that that would solidly be programmer error / represent a bug in the program if the code was ever
21:11:41 <tzh>  written in a way that happened to pass them to that function
21:13:42 * hackagebot newtype-deriving 0.1.3 - Instance derivers for newtype wrappers  https://hackage.haskell.org/package/newtype-deriving-0.1.3 (NikitaVolkov)
21:16:19 <anon25502> tzh: So it would be best approach in my case if I'd define the wrong types which I'm most likely to receive, saying "This is going to be a String or an Int, if it's something else than these two, it's an error, if it's an Int, is not what I wanted, but I will treat it like this, if it's a String, proceed as intended
21:17:27 <tzh> anon25502: right. that's kind of what the `Either` type does, is let you store a value that's potentially of two different types
21:22:37 <anon25502> tzh: Ok this makes sense to me and I assumed this (using `Either` was my first approach). How do I check and handle these different cases? I would think this is done by using `case x of` and `Left` and `Right`
21:22:57 <anon25502> tzh: somehow
21:23:57 <tzh> anon25502: you can use a case to pattern-match on (Left l) and (Right r) where the r/l values become bound to whatever value is stored there
21:24:07 <tzh> anon25502: or you could use `either`
21:24:32 <tzh> @type either
21:24:33 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
21:25:15 <tzh> so if you have Either Int String, and you want the int to turn into "", you'd say `either (const "") id`
21:25:32 <jle`> ah either.  first-class pattern matching
21:28:53 <anon25502> tzh: Aah alright, I'm going to look into those, thank you for your patience.
21:29:26 <tzh> anon25502: oh no problem, sorry i couldn't be more of a help :V
21:30:20 <anon25502> tzh: But there is no construct to build this handling right into the declaration of the data/type itself, is there?
21:32:32 <tzh> anon25502: like have a data type that automatically does that parsing? not really. types are just data; if you want to manipulate data you need a function. you can make it so you can only build a type by calling a function, what's called a "smart constructor", but you still have to write the function
21:34:00 * hackagebot linode 0.1.0.4 - Bindings to the Linode API  https://hackage.haskell.org/package/linode-0.1.0.4 (Helkafen)
21:34:20 <anon25502> tzh: Ok, anyway, thanks. I guess I'm on the right track now.
21:40:41 <lamefun> Why does Haskell have diversitivist package base yet fails to support diversitivism properly?
21:41:58 <cow_2001> imap in haskell?
21:42:49 <kadoban> lamefun: The words in your question don't seem to mean anything concrete, care to explain your complaint more?
21:44:00 <cow_2001> if i want to retrieve emails from gmail, what would be my go to package?
21:44:09 <cow_2001> specifically, their attachments
21:44:21 <lamefun> kadoban, nvm, I'll explain later on reddit
21:45:07 <athan> If you could represent an agent's "beliefs", abstractly, as a join semilattice, where some are at the same level, but a higher increase makes a belief more "radical", and you build a propagator network that represents terrorization of people who aren't as radical as you, what would happen? :P
22:20:18 <monochrom> terrorization sounds terrible :)
22:20:57 <bitemyapp> monochrom: sounds turrible
22:27:16 <jgcoded> Hey guys, I'm trying to use Parsec. I don't know how to fix this error on line 10: http://lpaste.net/145817
22:27:42 <jgcoded> lpaste shows a different error but my GHC shows an error on line 10
22:28:36 <jgcoded> I want to parse a left parenthesis, then an expression, then a right parenthesis
22:29:39 <monochrom> I want to know what error message you got.
22:30:19 <jgcoded> Couldn't match type ‘Char’ with ‘[Char]’     Expected type: ParsecT                      String u Data.Functor.Identity.Identity [Char]       Actual type: ParsecT String u Data.Functor.Identity.Identity Char     In the second argument of ‘(>>)’, namely ‘char ')'’     In the second argument of ‘(<|>)’, namely       ‘(char '(' >> expression >> char ')')’
22:30:29 <jgcoded> sorry for the wall of text
22:31:51 <monochrom> this is going to be many layers of errors
22:32:08 <jgcoded> oh no
22:32:09 <monochrom> number and ident return String. I respect that.
22:32:43 <monochrom> but expression is not going to return String. because you used sepBy
22:33:38 <monochrom> therefore "myParser :: String -> Either ParseError String" is a lie.
22:34:26 <monochrom> now this is not what the current error message says. but the current error message is unfixable without first settling this inconsistency
22:34:32 <jgcoded> Maybe I should get rid of sepBy
22:35:18 <monochrom> if you get rid of sepBy, how are you going to parse "several terms separated by operators"?
22:35:58 <jgcoded> turn it into "a term followed by many +-terms"?
22:36:47 <monochrom> ok, I made a mistake, "String -> Either ParseError String" is not a lie, because you have "*> return "Parsing complete!"" which is right
22:37:27 <jgcoded> ah ok, that means I do know how to use *> !
22:37:46 <monochrom> I guess I should go back to line 10
22:38:13 <monochrom> ident and number have the same type. so you can use <|> on them.
22:38:32 <monochrom> now what is the type of (whatever >> char '(')?
22:38:54 <monochrom> it cannot have the same type as ident and number.
22:39:04 * hackagebot git-fmt 0.2.2.0 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.2.2.0 (hjwylde)
22:39:06 * hackagebot bloodhound 0.10.0.0 - ElasticSearch client library for Haskell  https://hackage.haskell.org/package/bloodhound-0.10.0.0 (bitemyapp)
22:39:11 <monochrom> ident and number return String. char'(' returns Char.
22:39:40 <monochrom> but that is only the symptom not the real problem.
22:39:49 <jgcoded> how come whatever >> char '(' doesn't just concatenate that last parens as part of the string from whatever?
22:39:55 <jgcoded> ok
22:40:23 <monochrom> do you know what >> does? do you even know its type? (its type already says a lot)
22:40:46 <jgcoded> it returns m b
22:41:02 <monochrom> and b=Char today because char'(' has type m Char
22:41:02 <jgcoded> ok that makes sense
22:41:08 <jgcoded> yeah
22:41:15 <monochrom> err, char')'
22:41:58 <monochrom> the real problem appears when you say, "I want to return a string that contains what expression has got". except that expression doesn't give you a String.
22:44:29 <jgcoded> So I need to turn its return to a string or a do something different
22:45:11 <monochrom> yes. if you want expression to give you a string, you have to add your own post-processing of what sepBy gives you
22:45:20 <monochrom> sepBy gives you a list.
22:45:47 <jgcoded> There's totally a haskell function to join up a list
22:45:50 <monochrom> "list of what?"  answer: list of what term returns
22:46:03 <jgcoded> list of strings
22:46:16 <jgcoded> oh wait no
22:46:22 <jgcoded> term also returns a list
22:46:30 <monochrom> "and what does term return?"  answer: it is sepBy factor whatever, so term returns list of what factor returns
22:46:43 <jgcoded> yeah this is getting ugly
22:46:46 <jgcoded> lists of lists
22:47:00 <jgcoded> sepBy sucks
22:47:14 <monochrom> I wouldn't say that
22:48:08 <monochrom> how else could sepBy reasonably structure its answer, if not as a list, in order to be not pointless?
22:49:27 <jgcoded> ok it doesn't suck as much
22:51:24 <monochrom> I don't see why it sucks any tiny bit at all
22:53:28 <monochrom> you seem to be proposing your ideal that, "sepBy number (char ',')", say, should concatenate the individual number strings back to one single string
22:53:45 <borromakot> Still learning haskell - How do I compose a Maybe (Int, Int) from two `Maybe Int`s ?
22:54:01 <monochrom> your ideal seems to be that, for example, if the input is "1,2,3,4", then sepBy should return "1,2,3,4".
22:54:16 <jgcoded> oh that's pretty silly
22:54:22 <monochrom> see?
22:54:53 <monochrom> the only sensible thing to do is break it to ["1", "2,", "3", "4"]
22:54:59 <liste> borromakot one way is do {a <- foo; b <- bar; return (a, b)}
22:55:04 <monochrom> the only sensible thing to do is return a list
22:55:16 <borromakot> ahh, that makes sense.
22:55:41 <borromakot> I don't fully understand how to treat monads in haskell, but I'm getting there :D
22:56:57 <monochrom> you can also write a lot of "case"s
22:58:22 <jgcoded> By cases do you mean more functions?
22:58:43 <jgcoded> or the choice <|>?
22:58:51 <monochrom> it's for borromakot. as lot of case-expressions and pattern matching
22:59:01 <borromakot> :)
23:00:13 <jgcoded> monochrom I think chainl might be what I'm looking for. It returns a single value rather than a list like sepBy
23:00:52 <monochrom> that's fair
23:01:13 <jgcoded> or maybe I should just write another higher level function that goes through the list given to me by sepBy?
23:01:24 <jgcoded> I think that makes more sense
23:02:00 <viktech> woah
23:03:21 <monochrom> do both. they are good exercises.
23:04:01 <jgcoded> haha ok
23:08:38 <jgcoded> ah no a better function is between! It parses stuff in between certain tokens
23:09:01 <monochrom> yes but that still doesn't solve the expression problem
23:25:35 <lamefun> Why is that Haskell doesn't support its de-centralized package mindset well?
23:27:17 <lamefun> eg. Vector doesn't implement Hashable, many things don't implement FromJSON, and if I do it in mine, I risk my program/library breaking if someone else implements that instance.
23:28:06 <liste> that'd mean dependencies between the different packages
23:28:45 <lamefun> yes, every package would depend on FromJSON, FromYAML, FromXML and whatnot.
23:28:54 <Maxdamantus> instances aren't global. They need to be imported to collide, like symbols.
23:29:39 <Maxdamantus> The instance just needs to be visible when instantiating the method.
23:30:02 <kadoban> Maxdamantus: But orphan instances are still a problem, because you can't specifically import or avoid importing them, without skipping the module entirely.
23:30:05 <lamefun> Yes, but if they do, what to do? eg. liba implements Class T and libb implements Class T, I want to use both libraries simultaneously but can't because of conflicting instances
23:30:46 <Maxdamantus> You could, if you were willing to create extra modules.
23:30:55 <Maxdamantus> The problem is what kadoban said.
23:31:33 <nshepperd> you solve that by putting orphan instances in their own module
23:31:37 <Maxdamantus> You don't have the level of control over importing instances that you do other identifiers (import qualified Data.Map as M)
23:31:46 <liste> GHC generics and Template Haskell instance deriving helps a bit in keeping the packages independent
23:33:33 <nshepperd> anyway, the problem here is if two packages want to mention each other some way one of them has to depend on the other
23:33:46 <lamefun> Can I make eg. Hashable for Vector without the risk of stuff breaking int the future because I implemented Hashable for Vector?
23:34:20 <nshepperd> whereas maybe you really want an instance that magically comes into existence _only_ when both packages are imported
23:34:32 <kadoban> lamefun: Not really. But it'd be a pretty easy fix if it does break later, just trash your instance.
23:35:29 <Bashmetim> So, maybe this is an odd question, but can anyone point me to a largeish open-source project written in haskell?
23:35:54 <Bashmetim> I'm looking into doing a benchmark on the effectiveness of different GHC optimizations
23:36:04 <Bashmetim> (for a research project)
23:36:30 <kadoban> Bashmetim: The biggest ones that come to mind would be: xmonad, pandoc, and some of the web frameworks
23:36:34 <jle`> xmonad, pandoc?
23:36:40 <liste> Bashmetim, also GHC itself
23:36:40 <jle`> oh heh we said the same things
23:36:46 <kadoban> Haha
23:37:00 <jle`> yesod is fairly large-ish but it might be harder to benchmark
23:37:27 <Bashmetim> actually, yeah, xmodad and pandoc might be a really good idea
23:37:36 <jle`> mo' dad
23:37:52 <Bashmetim> I was thinking about GHC, but I think compiling it multiple times might *actually* take a million years :)
23:37:58 <jle`> i admit to having difficulties compiling ghc with ghc
23:38:27 <jle`> even though...someone somewhere has to do it, for the greater benefit of humanity
23:38:55 <Bashmetim> God bless their soul
23:42:54 <Bashmetim> Oh man, on the subject -> https://wiki.haskell.org/Frag
