00:07:39 * hackagebot casadi-bindings 2.4.1.2 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-2.4.1.2 (GregHorn)
00:07:39 * hackagebot th-desugar 1.5.5 - Functions to desugar Template Haskell  https://hackage.haskell.org/package/th-desugar-1.5.5 (RichardEisenberg)
01:24:16 <gfixler> how nice is pandoc for making slides?
01:24:30 <gfixler> is pretty much fire-and-forget, or can I get really pretty output?
01:25:09 <gfixler> I'm wondering if Diagrams would work better for me
01:42:36 * hackagebot servant-yaml 0.1.0.0 - Servant support for yaml  https://hackage.haskell.org/package/servant-yaml-0.1.0.0 (phadej)
01:43:27 <jle`> gfixler: it's comparable to latex for slides
01:44:21 <meditans> hi, in the module Control.Lens.Lens, `lens` is defined to have the type
01:44:23 <meditans> lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
01:44:47 <meditans> however, when I query that type, I get the version without synonims
01:44:55 <meditans> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
01:45:48 <meditans> as I'm writing a tool which extracts information from types, is there a way to get the former annotation, for example with Hint?
01:49:18 <meditans> synonyms*
01:57:26 <meditans> is it the presence of ScopedTypeVariables or MultiParamTypeClasses?
01:05:01 <gfixler> jle`: thanks
01:05:17 <gfixler> whoa, time change
01:07:05 <bennofs> meditans: i don't think that's possible
01:07:58 <meditans> bennofs: why in this particular case I'm getting synonyms expanded?
01:08:05 <bennofs> meditans: GHC has some code that tries to preserve type synonyms, but that doesn't always work (and I believe it's not always clear whether it's helpful to expand/not expand a synoym in the output)
01:09:21 <bennofs> meditans: I guess it's because Lens is RankN type synonym.
01:09:30 * bennofs is no ghc expert :p
01:10:03 <bennofs> meditans: note: :i does give the right type 
01:10:56 <meditans> bennofs: oh, thanks for the explanation, and why does :i return the correct one?
01:11:05 <bennofs> idk :p 
01:11:07 <meditans> is it based on haddocks?
01:11:18 <meditans> bennofs: ok, thanks again :)
01:38:46 <jle`> meditans: btw, type synonyms are usually always expanded when you use :t, i think
01:38:54 <jle`> try :t "hello" in ghci and you'll get [Char], not String
01:39:42 <jle`> oh hm, ghci does try to keep let x = "hello" :: String as :t x => String, hm
01:42:18 <cwl> I am using cereal to deserialize some binary of little endian. How can I override the default instances like Int32 Word32 and [a]
01:43:24 <cwl> If I cannot override, I have to wrap every type in a way like newtype Int32LE = I Int32
01:46:03 <srhb> cwl: Why? You can read or write either end first, can't you?
01:46:53 <bennofs> cwl: can't you write your Serialize instance manually, and then just use the functions from: http://hackage.haskell.org/package/cereal-0.4.1.1/docs/Data-Serialize-Get.html#v:getWord16le
01:46:53 <cwl> srhb: The default instance Serialize Int32 is get = getWord32be
01:47:09 <cwl> srhb: I want it to be get = getWord32le
01:47:19 <bennofs> cwl: you don't need to use the Seralize instance for Int32, do you?
01:47:43 <cwl> srhb: If I can override instance, I'll write my instance Serialize Int32 get = getWord32le
01:47:57 <srhb> cwl: You cannot.
01:48:00 <bennofs> cwl: why do you need to use the instance?
01:48:02 <Bynbo7> cwl: just use getWord32le
01:48:02 <Taneb> Why don't you just use getWord32le directly?
01:48:24 <cwl> bennofs: What do you mean by I don't need to use the Serialize instance for Int32?
01:48:44 <Axman6> you can use getWord32le directly
01:48:59 <bennofs> cwl: instead of using get, you can just directly use getWord32le
01:49:05 <Axman6> and it's usually better to do so, because it makes it clear to anyone reading the code that the value is little endian
01:49:21 <Axman6> the parsing code describes the protocol more precisely
01:49:55 <cwl> ByronJohnson: Suppose I have some data type: data Data = { len :: Int32, isGood :: Bool } deriving (Generic, Show)
01:50:16 <cwl> instance Serialize Data
01:50:24 <Axman6> > fromIntegral (maxBound :: Word32) :: Int 32
01:50:25 <jle`> btw, cereal isn't really meant for deserializing data received from outside sources
01:50:29 <lambdabot>  mueval-core: Time limit exceeded
01:50:38 <Axman6> > fromIntegral (maxBound :: Word32) :: Int32
01:50:40 <jle`> it's meant for creating serialization schemes for your data sources and re-reading them
01:50:41 <lambdabot>  -1
01:51:04 <jle`> your best bet for reading external binary specs/formats is attoparsec, for the most part
01:51:05 <Axman6> cwl: use fmap fromIntegral getWord32le
01:51:25 <Axman6> or, as jle`  says, use something designed for parsing binary protocols
01:51:28 <jle`> but for something this simple i would just yeah, write a custom instance for Data
01:51:31 <srhb> jle`: Actually, the Get monad is pretty damn useful for parsing external binary data.
01:51:40 <jle`> instead of relying on the auto-derivation
01:51:51 <jle`> srhb: it's useful, but not it's not what the cereal library was designed for, heh
01:51:51 <cwl> How can I take advantage of the Generic?
01:52:20 <jle`> you can't really gain too much from the auto-derived instance from GEneric in this case if you really want `len` to be encoded as a Word32le
01:52:24 <cwl> My current solution is wrap with newtype, and make new instance of that type, Int32LE for example.
01:52:37 <srhb> cwl: Just implement the instance directly.
01:52:43 <jle`> that's a bit of a hassle compared to just writing your own Serialize instance
01:52:45 <srhb> If you really want it.
01:52:56 <jle`> get = Data <$> (fmap fromINtegral getWord32le) <*> get
01:53:16 <jle`> or get = (\l g -> Data (fromIntegral l) g) <$> getWord32le <*> get
01:53:40 <jle`> but this isn't really how cereal is meant to be used
01:53:43 <cwl> but I have to unwrap it, I am seeking a more convenient way
01:53:53 <jle`> more convenient than the `get` function there?
01:54:10 <jle`> what are you unwrapping?
01:54:28 <cwl> srhb: implement the instance manually is not what I want, I want to deriving Generic and have the instance for free
01:54:40 <srhb> cwl: You can't get that.
01:54:40 <jle`> you can even do it monadically...get = do l <- getWord32le; b <- get; return (Data (fromIntegral l) b)
01:54:54 <jle`> that's not really what the Generic-based auto-deriving instance is for
01:55:17 <jle`> and using newtype wrapping etc. is just going to be a lot of hassle for something that is fairly simple to do normally
01:55:36 <jle`> and again, cereal is meant for cases where you have control over the format, so for Generic, you'd use the same auto-defined `put` as the auto-defined `get`
01:55:57 <jle`> if you're parsing external binary data, that's not what cereal is exactly meant for
01:56:07 <jle`> and i'd recommend something else if things get more complicated
01:56:13 <cwl> jle`: I mean, I want to take the advantage of deriving Generic
01:56:32 <jle`> you can't really, in any nice way
01:56:35 <jle`> it's sort of an abuse of Generic
01:56:43 <jle`> er, an abuse of the auto-derived instance
01:56:53 <cwl> jle`: f1 <- getWord32le; f2 <- getWord32le ...; f20 <- getWord32le ... too boring
01:56:56 <hc> E4xoi: I'll use a continuation monad to solve the problem
01:57:17 <jle`> that's like saying you want to bake a cake, but be able to take advantage of the new car you bought
01:57:22 <jle`> having a new car is nice, but it's not meant for baking cakes
01:57:36 <jle`> and using a car to bake a cake might be an abuse of what a car is meant for
01:57:56 <zomg> you just gotta turn the heater on hot enough and I'm sure it can be accomodated
01:58:10 <jle`> yeah, but don't complain if you find it hard/inconvenient :p
01:58:12 <cwl> jle`: If I can have my own instance of Serialize of Word32, everything is fine.
01:58:20 <zomg> lol
01:58:29 <srhb> cwl: We already explained how to make your own (self-written) instance of Serialize.
01:58:39 <cwl> jle`: But the author has implement it
01:58:46 <srhb> cwl: This is how you should do it but you seem adamant in refusing to do it. :-)
01:58:49 <jle`> you can probably abstract over multiple fields, too
01:58:56 <jle`> you don't have to manually write out twenty lines
01:59:05 <jle`> show us a specific example and we can tell you how to make it nicer :)
01:59:31 <jle`> the reason why there's already an instance for Word32 is because it fits in perfectly with what cereal and the auto-derived instances are designed for
01:59:41 <jle`> they aren't designed to read external binary data formats
02:00:06 <cwl> wait a minute, I'll post it.
02:00:15 <jle`> there is probably a way to write what you want to write in a nicer way, but it doesn't necessarily have to do with Generic/auto-derived instances
02:00:45 <jle`> and if you don't have control over your input data format, you might run into trouble eventually that you can't avoid
02:00:50 <jle`> if you really want to use Cereal
02:01:10 <jle`> cereal just isn't meant for these types of things...it might work in this case, but if things ever get slightly more complicated, you're going to run into a lot of trouble
02:01:23 <jle`> if you really want to parse external binary formats, use a library designed for that, like attoparsec
02:01:45 <jle`> the fact that this "almost fits" with cereal's auto-derived instance in your specific case is a coincidence and a very unstable hack...
02:02:05 <jle`> it almost works, but by accident...and even if it did work, it'd be an abuse/hack
02:02:15 <jle`> and probably not very maintainble :)
02:02:37 <jle`> haskell isn't about finding clever hacks to do things in the least amount of code
02:02:44 <jle`> it's about building robust solutions
02:02:48 * hackagebot car-pool 0.0 - Simple web-server for organizing car-pooling for an event  https://hackage.haskell.org/package/car-pool-0.0 (HenningThielemann)
02:02:51 <jle`> using the appropriate abstractions
02:03:20 <jle`> otherwise we'd all be relying on PHP's "4" + "4" = "8" :)
02:03:24 <u-ou> do haskell people like prolog
02:03:37 <jle`> (it might work in some cases to our advantage, but it might be a bad idea to rely on it...)
02:03:53 <Nachtgespenst> u-ou: Not in general
02:05:21 <jle`> i think it's kind of weird that a lot of haskell promotion is with those cute "elegant" one-liners... haskell.org's front page is guilty of this
02:13:28 * hackagebot car-pool 0.0.0.1 - Simple web-server for organizing car-pooling for an event  https://hackage.haskell.org/package/car-pool-0.0.0.1 (HenningThielemann)
02:13:30 * hackagebot Earley 0.10.0.1 - Parsing all context-free grammars using Earley's algorithm.  https://hackage.haskell.org/package/Earley-0.10.0.1 (phadej)
02:13:38 <SK0> I want to make some simple 2d art, which libraries are currently recommend? I want to write to PNG or a similar format, and I don't it doesn't _have_ to be vector based.
02:15:13 <Nachtgespenst> SK0: JuicyPixels, I guess
02:15:40 <cwl> jle`: http://lpaste.net/144390
02:16:03 <cwl> jle`: You can see many newtype here
02:16:53 <cwl> jle`: I want to both get rid of it and keep the Generic to auto instance Serialize
02:21:38 <rdz_> if I've build something with `stack build` on Ubuntu, where can I find the executable?
02:25:00 <cwl> jle`: are you still here?
02:26:39 <Narfinger> hiho, i want to use forkIO in a happstack handler but i seem to have some type problems, it tells me that i am of type IO a but I need to be of type ServerPartT (IO a)
02:27:48 <Narfinger> i tried using fmap but this seems wrong
02:28:11 <srhb> Narfinger: Sounds like more lift.
02:28:29 * hackagebot tellbot 0.6.0.4 - IRC tellbot  https://hackage.haskell.org/package/tellbot-0.6.0.4 (DimitriSabadie)
02:28:44 <Narfinger> i honestly never got the difference
02:28:57 <srhb> Narfinger: ServerPartT is a monad transformer.
02:29:04 <Narfinger> yes lift is the correct thing
02:29:31 <Narfinger> guess i need to read up on monad transformers
02:29:40 <srhb> Narfinger: You can make IO a actions into ServerPartT IO a actions by using liftIO (theIOa)
02:29:46 <srhb> That's the short story.
02:30:09 <Narfinger> so what is the difference between liftIO and lift?
02:30:43 <srhb> liftIO can lift arbitrarily deep to reach the IO monad in the stack, afair
02:31:01 <srhb> lift simply lifts whatever one level.
02:31:09 <Narfinger> oh ok
02:34:35 <Cale> To put it another way, there's a class MonadIO m where liftIO :: IO t -> m t -- so for monads m which support such an operation, liftIO gives you a way to do whatever is required to turn an IO action into an m action.
02:35:00 <Narfinger> ok
02:35:27 <Cale> class MonadTrans t where lift :: (Monad m) => m a -> t m a
02:36:18 <Cale> Is the class which defines lift. So, when you make some monad transformer t an instance of this class, you specify a way, for any choice of monad m, to turn an m-action into a (t m)-action.
02:37:32 <Cale> When m happens to be IO, this might be the same thing as liftIO, but in other cases, liftIO might be defined by doing a whole bunch of lifts for various transformers, or maybe the monad in question wasn't defined in terms of transformers at all, so liftIO would be defined directly then, and there wouldn't be lift.
02:37:37 <Narfinger> mhhh ithink i need to read up on monad transformers first :)
02:39:10 <Cale> (and in other cases, the monad won't have anything to do with IO and won't be built using transformers, so there will be an instance of neither class)
02:39:47 <Cale> A monad transformer is a bit like a type level function which transforms one monad into another.
02:40:13 <Cale> So if T is some monad transformer, then whenever m is a monad, then so should T m be
02:40:26 <Cale> i.e. we should have an instance Monad m => Monad (T m) where ...
02:40:30 <Narfinger> mhhh ok and why are they needed?
02:40:54 <Cale> and there also ought to be an instance of MonadTrans for T, which allows us to turn m actions into T m actions
02:42:26 <Cale> Well, monads and transformers are never really needed. We just find these patterns showing up, and so we capture and abstract over them so as to be able to write some code once and then be able to reuse it for any monad
02:43:00 <Narfinger> mhhh ok
02:43:13 <Narfinger> i don't know, monads are "easy" to understand because of the maybe example
02:43:23 <Narfinger> what would be a similar example for a monad transformer?
02:43:45 <Cale> Well, are you familiar with how the State monad is implemented?
02:43:51 <Narfinger> no, sorry
02:44:03 * hackagebot cgrep 6.5.10 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.10 (NicolaBonelli)
02:44:09 <Cale> Okay, so let's go over that first, and then we'll look at generalising it to a monad transformer
02:44:20 <MarcelineVQ> oh boy!
02:44:25 <MarcelineVQ> :>
02:45:23 <Cale> So, the idea here is that we want to represent computations which are able to manipulate some "state" of type s, reading and writing it, before resulting in a value of a possibly different type a
02:45:33 <Narfinger> ok
02:46:04 <Cale> A natural way to internally represent such things given that we're working in a functional programming language is as functions of type  s -> (s,a)
02:46:32 <Cale> i.e. functions which take the initial value of the state, and produce a final state, along with the end result
02:46:34 <Narfinger> makes sense
02:46:50 <Cale> So in order that we can write instances, we'll define a newtype:
02:47:02 <Cale> newtype State s a = S (s -> (s,a))
02:47:40 <Narfinger> ok
02:47:45 <Cale> Here we have a constructor S :: (s -> (s,a)) -> State s a
02:48:13 <Cale> and then we also want a way to take an action of type State s a, and some initial value of type s, and produce the final state and result pair...
02:48:22 <Cale> runState :: State s a -> s -> (s,a)
02:48:39 <Cale> which because of our functional choice of representation, this is trivial:
02:48:46 <Cale> runState (S f) s = f s
02:49:15 <Narfinger> ok
02:50:01 <Cale> Now, the idea is we're going to turn this into a monad by implementing return and (>>=), and implement some basic operations for reading and writing the state, so that we needn't ever use S anymore once we're done (though we might keep the option to)
02:50:54 <Cale> Let's start with return :: a -> State s a -- this is a function which takes a value, and produces the State s action which "does nothing" except to, well, return that value as its result
02:51:01 <Cale> return v = ...
02:51:20 <Cale> Well, we don't have many ways to produce something of type State s a yet apart from S, so let's use that:
02:51:25 <Cale> return v = S (...)
02:51:38 <Cale> and S wants a function of type s -> (s,a), so that might as well be a lambda:
02:51:43 <Cale> return v = S (\s -> ...)
02:52:12 <Cale> and so we have v :: a, and s :: s, and we need to produce a pair of type (s,a), so there's really only one option here:
02:52:17 <Cale> return v = S (\s -> (s,v))
02:52:24 <Narfinger> ok
02:52:53 <Cale> So, next, let's take a look at (>>=) :: State s a -> (a -> State s b) -> State s b
02:54:05 <meditans> is there a API to query the haddock types? Or :i?
02:54:07 <Cale> The idea here is that x >>= f will be the action which will first "run" x on the initial state, obtaining some result v (along with a new state), and then run (f v) on the new state, producing the final state and result of that as its own
02:54:16 <meditans> maybe bennofs ^
02:54:18 <Cale> meditans: not as far as I'm aware
02:54:34 <meditans> Cale: thanks!
02:55:03 <Cale> meditans: There might be something internal to Haddock which you could pull out and use if you want to inspect its files.
02:55:06 <bennofs> meditans: you can look into what GHCi does for :i
02:55:28 <Cale> and yeah, there is a GHC API, which GHCi is using to construct what it prints for :i
02:55:54 <Cale> okay, so back to the tutorial...
02:56:06 <Cale> Let's try writing x >>= f
02:56:22 <Narfinger> i tried but something doesn't fit :)
02:56:22 <Cale> x >>= f = S (...) -- again, might as well use the S type constructor
02:56:33 <Cale> x >>= f = S (\s -> ...) -- and again, might as well use a lambda
02:57:05 <Cale> x >>= f = S (\s -> let (s',v) = runState x s ...) -- first we want to run the action x on the initial state s, obtaining some new state s' and result v
02:57:49 <bennofs> meditans: https://downloads.haskell.org/~ghc/7.10.2/docs/html/libraries/ghc-7.10.2/GHC.html#v:getInfo is what GHCi uses
02:57:49 <Cale> x >>= f = S (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' ...) -- then we want to run the action (f v) on the new state s', getting some final state s'' and result w
02:58:19 <Cale> x >>= f = S (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' in (s'',w)) -- finally, those s'' and w are the final state and result of our combined action.
02:58:47 <Cale> We can also simplify this if we wish:
02:59:00 <Cale> x >>= f = S (\s -> let (s',v) = runState x s in runState (f v) s')
02:59:09 <Narfinger> mhhh
02:59:26 <Cale> (since we're just producing the result of runState (f v) s' directly)
03:00:12 <Narfinger> yeah ok
03:00:14 <Cale> The idea here is that x >>= f will be the action which when it's run is first going to run x, then it's going to apply f to whatever the result of x was in order to determine what to run next, and then run that
03:00:38 <Cale> and thread along the changed value of the state
03:00:58 <Cale> okay
03:00:59 <Narfinger> yeah ok
03:01:59 <Cale> So with those definitions we have a monad, but just having the monad operations doesn't give us such an interesting library -- we'd also like to write simple primitive operations for reading and writing the state
03:02:14 <Cale> get :: State s s -- will obtain the present value of the state without changing it
03:02:57 <Cale> put :: s -> State s () -- will, regardless of what its initial state was, have the given value as its final state, and result in an empty tuple
03:03:18 <Narfinger> ok
03:03:37 <Cale> Both of these turn out pretty easy in the end, I can write them for you, or you could try it yourself if you like :)
03:03:59 <Narfinger> mhhh wait a second
03:05:40 <Narfinger> no no idea...
03:05:49 <Cale> okay
03:05:52 <Narfinger> i am slightly confused what we define as state
03:06:00 <Narfinger> is s-> (s,a) the state?
03:06:13 <Cale> our values of type s are the states
03:06:25 <Narfinger> so get is just identity?
03:06:49 <Cale> get = ... -- we want to write something of type State s s here
03:06:51 <mauke> pretty much, yes. but not id itself because that's the wrong type
03:07:29 <Cale> get = S (...) -- we can use the constructor  S :: (s -> (s,a)) -> State s a, and now the blank we have to fill in is a function of type (s -> (s,a))
03:08:16 <Cale> get = S (\s -> ...) -- this function might as well be a lambda, and we now have the initial state s :: s as an argument to this function
03:08:41 <Narfinger> it should be just s but what happens with the a?
03:08:44 <Cale> well, a = s in this case
03:08:52 <Cale> I should have done that unification before
03:08:59 <Cale> because we said that get :: State s s
03:09:05 <Narfinger> oh so State (s-> (s,s))
03:09:23 <Cale> er
03:09:45 <Cale> so we're specialising the type of S to S :: (s -> (s,s)) -> State s s
03:10:07 <Cale> and then our blank in the last line is a pair of type (s,s)
03:10:39 <Cale> which, since we only have available one thing of type s, namely the variable s bound by the lambda, we can only write:
03:10:47 <Cale> get = S (\s -> (s,s))
03:11:02 <Narfinger> yeah that is what i mean, forgot the backslash :)
03:11:25 <Cale> and if you think about it, this is appropriate in meaning as well: the initial state and final state are the same, and the result is the same again as the initial state
03:11:37 <Narfinger> yeah ok
03:11:51 <Cale> put :: s -> State s ()
03:12:28 <Cale> put n = S (\s -> ...)  -- so now we have some new state n, and the initial state s
03:12:53 <Cale> put n = S (\s -> (n,...))  -- our final state should be n
03:12:56 <Narfinger> \s-> (n,s)
03:13:05 <Cale> not quite!
03:13:13 <Cale> put n = S (\s -> (n,()))  -- our result is an empty tuple
03:13:19 <Narfinger> oh ok
03:13:34 <Cale> we could also return the old state as the result
03:14:02 <Narfinger> ok
03:14:13 <Cale> (but that would have a bit of a different type)
03:14:46 <Cale> So, now that we have get and put and the Monad operations, we can actually write anything without using S
03:14:55 <Narfinger> yes
03:16:32 <Cale> Oh, I should note, the mtl and transformers libraries define State monads, but they use the opposite convention I've been using for the pairs
03:16:38 <ggVGc> where can I find a good summary of the main things Haskell gains from being lazy?
03:16:41 <Cale> s -> (a,s) everywhere instead
03:17:01 <Narfinger> oh ok no problem
03:17:05 <Cale> ggVGc: https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf is a good paper about it
03:18:01 <ggVGc> thanks
03:18:03 <Narfinger> so what about monad transformers then?
03:18:04 <Cale> But yeah, the goal was to define a monad transformer
03:18:42 <Cale> Sometimes I insert another section about parsers in here... but it's late. Maybe if you ping me later I can give you that spiel :)
03:18:43 <MarcelineVQ> Cale: before you move on can you write a simple example line of using get and put with bind to avoid using S?
03:18:48 <Cale> Sure
03:18:56 <ggVGc> I am sitting here contemplating why GHC(for example) is such a huge beast, when languages like PureScript and Elm support a large part of what Haskell gives, and have much smaller compilers, and much simpler deployment/runtime
03:19:04 <ggVGc> wonder if it's party because of laziness
03:19:31 <bennofs> ggVGc: GHC also implements lots of type system extensions and has a fairly complex optimizer I believe
03:20:19 <raichoo> ggVGc: The runtime also does a lot more. Multicore stuff, STM etc
03:20:38 <ggVGc> bennofs: but even with those type system extension, it lacks things that i.e Elm has. Specifically records in Elm seem much more powerful to me. And yeah, my thoughts about the laziness is that maybe the optimizer needs to be much better and more complex when the language is lazy
03:20:39 <bennofs> ggVGc: for example, I don't think PureScript/Elm have type families, GADTs, constraint kinds, datakinds, roles, ...
03:20:45 <Cale> Yeah, GHC is a much richer language implementation than those relatively new projects.
03:22:01 <Cale> okay
03:22:03 <Cale> So
03:22:42 <Cale> Suppose we have some function f :: s -> (s,a), and we want to basically write the same computation as S f would be
03:23:06 <Cale> do s <- get; ... -- we can first get the initial state like this
03:23:36 <Cale> do s <- get; let (s',v) = f s -- apply f to the initial state to obtain a final state and result
03:24:10 <Cale> do s <- get; let { (s',v) = f s }; put s' -- set the state to the desired final state s'
03:24:27 <Narfinger> ok
03:24:36 <Cale> do s <- get; let { (s',v) = f s }; put s'; return v -- and produce the desired result as the result of our whole computation
03:24:46 <Narfinger> ok makes sense
03:25:34 <MarcelineVQ> I see
03:26:15 <Cale> (of course, the do-notation turns into a bunch of applications of (>>=))
03:26:22 <Narfinger> yes
03:26:50 <Cale> Okay, so making this into a monad transformer, the idea is going to be that instead of
03:27:01 <Cale> newtype State s a = S (s -> (s,a))
03:27:05 <Cale> we're going to have:
03:27:19 <Cale> newtype StateT s m a = ST (s -> m (s,a))
03:27:45 <Narfinger> mhhh ok
03:27:59 <Cale> that is, instead of functions s -> (s,a), we have functions which produce actions in some monad m, having a pair of final state and result as their result
03:28:32 <Cale> Before, we had: return v = S (\s -> (s,v))
03:29:25 <Cale> Now we pretty much want to do the same thing, but we don't want to construct a pair, we want an m-action which does nothing, but has that pair as its result, which is what return (for m) is for:
03:29:33 <Cale> return v = ST (\s -> return (s,v))
03:30:08 <Cale> note that the returns on the left and right hand sides of the equation are for different instances of Monad
03:30:08 <Narfinger> oh i see
03:30:38 <Cale> I suppose I should say, we're writing an instance like   instance Monad m => Monad (StateT s m)
03:30:53 <Cale> So here,  return :: a -> StateT s m a
03:31:01 <Cale> is what we're implementing
03:31:07 <Cale> and we're allowed to use  return :: a -> m a
03:31:10 <tsoutseki> wow, you know to program in haskell? :o @ Cale 
03:31:19 <Cale> tsoutseki: hm?
03:31:26 <Narfinger> yeah
03:31:30 <Cale> tsoutseki: Is that sarcasm? :)
03:31:34 <tsoutseki> no
03:31:37 <tsoutseki> lol
03:31:54 <Cale> tsoutseki: I'm a professional Haskell programmer
03:32:05 <Cale> tsoutseki: I started learning Haskell around 2001 or so
03:32:12 <tsoutseki> i see then
03:32:51 <MarcelineVQ> tsoutseki: more importantly thank knowing how to program in haskell is that Cale knows how to explain how to program in haskell
03:32:58 <MarcelineVQ> *than knowing
03:33:20 <Cale> Okay, so next stop, let's look at our implementation of (>>=) for State
03:33:31 <Cale> x >>= f = S (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' in (s'',w))
03:34:04 <Cale> Oh, before this, I should do runStateT
03:34:12 <Narfinger> yes
03:34:22 <Cale> runStateT :: StateT s m a -> s -> m (s,a)
03:34:32 <Cale> runStateT (ST f) s = f s
03:34:57 <Cale> again, this is really just unwrapping the data constructor
03:35:04 <Cale> we could even have written
03:35:11 <Cale> runState (S f) = f
03:35:13 <Cale> and
03:35:17 <Cale> runStateT (ST f) = f
03:35:27 <Narfinger> ah yeah i see
03:35:44 <Cale> for this reason, they're often written directly as fields, so that the field extractors serve that purpose:
03:35:56 <Cale> newtype State s a = S { runState :: s -> (s,a) }
03:36:05 <Cale> newtype StateT s m a = S { runStateT :: s -> m (s,a) }
03:36:07 <Narfinger> yeah
03:36:18 <Cale> okay
03:37:08 <Cale> So, now the body of the lambda in here:
03:37:16 <Cale> x >>= f = ST (\s -> ...)
03:37:30 <Cale> is supposed to be an action of type  m (s,b)
03:37:46 <Cale> which is going to first run x on the initial state s
03:37:57 <Cale> obtaining a new state s' and result v
03:38:10 <Cale> x >>= f = ST (\s -> do (s',v) <- runStateT x s; ...)
03:38:41 <Cale> we'll use do-notation in place of let, because now  runStateT x s  is an m-action and we want to follow it up with some more stuff
03:39:05 <Cale> combining it all into a single m-action
03:39:40 <Cale> x >>= f = ST (\s -> do (s',v) <- runStateT x s; (s'',w) <- runStateT (f v) s'; ...) -- just as before, we run the action (f v) on the new state s', getting some final state s'' and result w
03:40:12 <Cale> x >>= f = ST (\s -> do (s',v) <- runStateT x s; (s'',w) <- runStateT (f v) s'; return (s'',w)) -- finally, we return this final state and result as our own
03:40:21 <Narfinger> ok
03:40:32 <Cale> again we can make a similar simplification as before:
03:40:45 <Cale> x >>= f = ST (\s -> do (s',v) <- runStateT x s; runStateT (f v) s')
03:40:49 <Narfinger> makes sense, we essentially do the same thing as in the non monad transformer thing except we need to return and use the different runState functions
03:40:58 <Cale> but this now relies on the monad laws for m
03:41:05 <Cale> yeah
03:41:20 <Cale> So this StateT effectively "adds state to another monad"
03:41:30 <Narfinger> yeah
03:42:08 <Cale> But we're not quite done yet. It would be disingenuous to say that it did that if we didn't have a way to transform any m-action into a (StateT s m)-action
03:42:18 <Cale> So we write
03:42:20 <Narfinger> ok
03:42:32 <Cale> instance MonadTrans (StateT s) where lift = ...
03:42:43 <Cale> Here, we'll define
03:42:55 <Cale> lift :: (Monad m) => m a -> StateT s m a
03:43:57 <Cale> lift x = ST (\s -> ...) -- so we have our action x :: m a, and we want to write something of type StateT s m a... might as well start out the same way as we have been
03:44:34 <Cale> lift x = ST (\s -> do v <- x; ...) -- we can first execute x, obtaining its result v
03:44:48 <Cale> and now we need to return a pair of a final state and result
03:45:12 <Cale> well, we have the initial state s, and we don't want to touch that, just let it be our final state
03:45:25 <Cale> and the result v from running x will be our result
03:45:35 <Cale> lift x = ST (\s -> do v <- x; return (s,v))
03:45:57 <MarcelineVQ> v. cool
03:46:16 <Narfinger> ah ok i see
03:46:18 <Cale> We can also easily modify the definitions of get and put to be StateT actions instead of State
03:46:36 <Cale> (just sticking in some returns)
03:46:40 <Narfinger> yeah
03:47:13 <Cale> So now, since [] (list type constructor) is a monad, we have a weird monad  StateT s [] a
03:47:27 <Cale> internally, values of this type are functions  s -> [(s,a)]
03:48:24 <Narfinger> mhhh ok i need to read up some more but i need to go now
03:48:25 <Cale> This monad turns out to be a simplistic approach to writing a parser library
03:48:30 <Narfinger> thanks for the detailed lesson!
03:48:32 <Cale> if s = String
03:48:48 <Cale> cool, see you!
03:48:56 <Narfinger> see you
03:49:03 <MarcelineVQ> I'd like you to keep going if you have time Cale :>
03:49:31 <Cale> Well, it is very late, and I'm still a bit sick, but I can stay up a little longer
03:49:38 <mauke> I can try to continue
03:49:56 <MarcelineVQ> I've just started using parsers so it's worthwhile
03:50:54 <mauke> so ... should I take over?
03:51:03 <Cale> There's the Dr. Seuss definition of a parser: A parser for things is a function from strings, to lists of pairs of strings and things.
03:51:19 <MarcelineVQ> like reads does
03:51:22 <Cale> If you want to, go for it, I could use the sleep :)
03:51:26 <Cale> yeah, exactly like that
03:51:43 <Cale> and look at what StateT s [] a actions are internally
03:51:51 <Cale> or with s = String
03:51:59 <Cale> that's exactly the same
03:52:35 <mauke> StateT String [] a = String -> [(String, a)]
03:53:18 <Cale> Though everything likes to use the opposite convention from me (though there are structural reasons in Haskell that my convention might be better sometimes)
03:53:37 <Cale> (,) String is a functor
03:53:39 <MarcelineVQ> s,a makes more sense to me too actually
03:53:52 <mauke> a parser is an action that takes the remaining input (state) and returns a list of possible successes (remaining string after consuming whatever, plus a result)
03:54:25 <Cale> In the application, it makes more sense the other way around, because you're eating up the initial portion of the string to produce the result of type a, and the rest of the string
03:54:31 <mauke> failure is represented by an empty list
03:54:39 <Cale> (So it kind of visually makes sense)
03:54:44 <Cale> I'll let mauke do the rest
03:54:48 <Cale> g'night!
03:54:51 <MarcelineVQ> Thank you Cale
03:55:20 <mauke> actually I'm not sure what's unclear at this point
03:55:58 <mauke> you can define your parser combinators like <|> that run both actions on the same input and concatenate their lists of results
03:56:30 <mauke> running parsers in sequence is >>
03:56:54 <jophish> I have a gadt with a constructor of the form Con :: F a -> D a; were F is a closed type family. How can I pattern match on this constructor?
03:57:00 <jophish> Whatever I try, ghc (7.10) is unable to unify F a and F Int (for example)
03:57:04 <jophish> As far as I can tell, this requires injective type families
03:57:34 <MarcelineVQ> I've encountered both those uses in parsec just earlier tonight, and have had a little bit of experience with Parser in nicta, I hadn't considered how state related though
03:57:48 <MarcelineVQ> So that's quite informtive
03:58:11 <mauke> state is more general in that parsers usually don't make up their own input
03:58:24 <mauke> but with 'put' you can switch to a completely different string to parse
03:59:06 * hackagebot geom2d 0.2.2 - package for geometry in euklidean 2d space  https://hackage.haskell.org/package/geom2d-0.2.2 (seppeljordan)
03:59:43 <tesrty> This is the umpth time I've been writing out a question to ask here that ended in me facepalming and emptying my textbox again. Funny how phrasing it as an 'exhaustive' question seems to help a lot.
03:59:57 <jophish> euklidean?
04:02:53 <MarcelineVQ> Thank you as well for your help mauke
04:06:03 <jophish> To simplify my question: I have a type family F a where F Int = Int; F Bool = Bool; I'd like to create a function from F a -> String. What other machinery do I need to do this?
04:20:18 <hexagoxel> jophish: your type family is just a function on the type level, so your question is equivalent to asking "how to implement forall a . a -> String", where you have a compile-time constraint "a \in {Bool, Int}".
04:21:03 <srhb> tesrty: #haskell is a great rubber duck.
04:21:18 <hexagoxel> (with the default solution: use type class)
04:21:31 <jophish> hexagoxel: yup, that's exactly what I've landed on :)
04:43:46 <bennofs> jophish: you need to make a typeclass for that
04:44:17 <bennofs> jophish: class FToString a where foo :: F a -> String; instance FToString Int where foo = show; ...
04:45:01 <E4xoi> hc: oh, ok
04:46:34 <ackthet> where has stack been all my life
04:51:46 <srhb> ackthet: on nixos.org/nix
04:52:38 <ackthet> aren't there goals slightly different?
04:53:09 <dbushenko> if I have a persistent entity (lets say I've got it from JSON request) is it possible not to specify the entity ID?
04:53:19 <srhb> ackthet: Mostly scope, but yes.
04:53:54 <dbushenko> for instance if I create a new entity, I don't have its ID
04:55:30 <srhb> ackthet: It also isn't THAT old, but older than Stack, but it's a pet peeve of mine :P
04:57:43 <ackthet> srhb: why is that?
04:59:19 <srhb> ackthet: I personally feel that nix is a better solution, and that work should have been put into migrating people towards using that by providing better userspace tools for haskell developers, rather than splitting people into a stack camp -- which, while it's a great tool, isn't Nix, and now we probably won't progress towards that in general for a long while.
05:00:12 <srhb> I've mostly resigned to just recommend Stack anyway, though. And occasionally make snide remarks when I can't contain them. :-)
05:00:54 <old_spice> hi guys sorry to interrupt. a quick question:
05:00:54 <ackthet> hehe
05:01:22 <old_spice> is unpackCString#  a valid function identifier?
05:01:34 <old_spice> module Data.Text.Show
05:01:39 <mniip> if and only if MagicHash is set
05:01:46 <old_spice> package "text"
05:01:59 <old_spice> it is.
05:02:04 <old_spice> thank you very much!
05:02:07 <ackthet> srhb: so i have some issues with nix, namely /nix being the default location <_<
05:02:17 <old_spice> I will read on MagicHash
05:02:19 <old_spice> ta
05:02:25 <srhb> old_spice: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html 7.3.2
05:02:26 <roelof> Is someone to give feedback on my solutions :  https://github.com/rwobben/craft/blob/master/chapter_4.hs
05:02:35 <old_spice> cheers srhb!
05:05:20 <srhb> roelof: Quick skim -- try to align things more
05:05:48 <srhb> roelof: For instance in testTwoX and such.
05:06:08 <srhb> roelof: Otherwise it looks decent from a style pov
05:06:33 <roelof> srhb: oke, I thought that stylish-haskell would take care of it 
05:06:54 <srhb> roelof: Nope.
05:06:58 <roelof> but I will look how I can better align things more 
05:07:31 <roelof> srhb:  is then there a better library for that , or can this only be done manually 
05:08:06 <srhb> roelof: I sometimes use emacs' align-regex for big blocks of definitions or guards.
05:08:30 <srhb> roelof: But in general it is a manual thing, where you use your eyes and your common sense to make things look nice and readable.
05:09:22 <roelof> oke, then I have to look how I can align things more 
05:09:31 <roelof> srhb: Thanks for the feedback 
05:09:51 * hackagebot GPipe 2.1.3 - Typesafe functional GPU graphics programming  https://hackage.haskell.org/package/GPipe-2.1.3 (TobiasBexelius)
05:11:13 <Flonk_> roelof: Also, check out the ($) operator, in can save you quite a few parentheses at times :)
05:15:57 <roelof> Flonk_:  I could. but that one is not explained in the book so far. I think its one of the higher functions ?
05:16:41 <Flonk__> geez
05:17:30 <ackthet> srhb: incidentally (and maybe slightly off topic) but do you run nixos?
05:17:37 <srhb> ackthet: I do, yes.
05:17:38 <Flonk__> roelof: it's defined as `f $ x = f x' so it literally doesn't do anything, the cool thing is just that its at the bottom of the order of operations. so e.g. `max (max a b)' could be rewritten as `max $ max a b'
05:17:45 <ackthet> srhb: how is it?
05:17:53 * ackthet spins up a VM
05:17:58 <srhb> ackthet: Great. :) We should move it to #nixos though, if you want to hear more.
05:18:08 <srhb> Or pm.
05:18:37 <Flonk__> roelof: so its for regrouping, one could say
05:18:54 <ackthet> srhb: i moved over 
05:24:30 <icbm> Probably an easy Q.  What's the best thing to do for a func that only makes sense for one constructor of an ADT?  (it is an error otherwise)
05:25:07 <hpc> icbm: do you want a runtime error or a compile-time error?
05:25:34 <icbm> hpc: f _ = undefined gets me a run-time error, so a compile-time error would be nice.
05:26:11 <hpc> your ADT needs to be a GADT then
05:26:39 <hpc> data Foo a where FooInt :: Int -> Foo Int; FooVoid :: Foo (); ...
05:26:54 <hpc> then you can write limitedFoo :: whatever -> Foo Int
05:28:38 <icbm> hpc: So, if I understand:  data T = A X Y | B Y Z  changes to data T where A :: X -> Y -> T; B :: Y -> Z -> T
05:29:39 <hpc> it could, but to be useful you need T to be :: * -> *
05:29:53 <icbm> It's not in my case
05:30:08 <hpc> data T flag where A :: X -> Y -> T SomeFlag; B :: Y -> Z -> T OtherFlag
05:30:29 <jophish> bennofs: thanks. This makes the data definition much nicer now :)
05:30:43 <hpc> can you change it?
05:30:45 <icbm> hpc: Maybe I could synthesize a flag type
05:31:06 <icbm> data Bar = SituationA | SituationB
05:32:10 <icbm> hpc: Thanks for the help, just learned about GADTs 30 min ago, so this will be the first time trying them out. :)
05:32:58 <roelof> Flonk_:  or maybe I can use the point expression more 
05:33:02 <icbm> Everything in Haskell seems to make more sense after I have done it once.
05:34:36 <hpc> icbm: you'd need data SituationA; data SituationB
05:34:57 <icbm> hpc: Ah, makes sense.
05:34:57 <hpc> (and give them constructors if you don't feel like enabling empty data declarations)
05:35:14 <hpc> basically, creating new type information
05:36:45 <icbm> hpc: Thank you, 7am and mind is thoroughly blown.
05:38:55 <roelof> How can I rewriet this by using the point notation : (maxNum, length (filter (== maxNum) els))
05:39:12 <srhb> roelof: What do you mean point notation? With explicit variables?
05:39:20 <srhb> roelof: Or point free (without variables?))
05:39:47 <roelof> srhb:  I mean something like this  function_1 . function_2  
05:40:09 <srhb> length . filter (==maxNum) $ els
05:40:41 <srhb> We call it function composition. length composed with filter (== maxNum)
05:41:03 <roelof> srhb:  oke the ($) is seperating the functions with the argument 
05:41:13 <srhb> Pointfree / pointful refers to no explicit variables / explicit variables
05:41:27 <srhb> roelof: It's equivalent to (length . filter (== maxNum)) els
05:41:59 <srhb> So yes, you can sort of think of it as separating, but it's really just function application with low precedence
05:42:04 <srhb> :t ($)
05:42:08 <lambdabot> (a -> b) -> a -> b
05:43:19 <roelof> srhb:  no explicit is I think difficult for this code :  http://lpaste.net/144400 
05:43:44 <srhb> roelof: It's not really a goal to get rid of points.
05:43:51 <srhb> It may look nice for some very simple things.
05:44:06 <srhb> You can use @pl if you want an autogenerated pointless version.
05:44:40 <roelof> correct, someone said that I could rid of all the () , So I thought  this could be a solution
05:45:08 <srhb> As i've been trying to say, that's an orthogonal issue.
05:45:10 <roelof> srhb:  @pl ?? 
05:45:34 <roelof> orthogonal ??
05:45:50 <srhb> @pl \els maxNum -> (maxNum, filter (== maxNum) els)
05:45:50 <lambdabot> ap (,) . flip (filter . (==))
05:45:53 <srhb> As in different
05:46:11 <mniip> and for a b c -> [a, b, c] you can use
05:46:14 <mniip> (flip (:) .) . flip (:) . return
05:46:34 <srhb> You can get rid of () by using $ often. But this is entirely different from eta reducing (= removing explicit variables)
05:46:58 <roelof> oke, I find those solutions less readable at the moment 
05:46:59 <srhb> eta reduction is taking `f a = b a` and transforming it to `f = b`
05:47:02 <srhb> That is what @pl is
05:47:04 <srhb> roelof: You should.
05:47:31 <roelof> srhb:  what schould I ?
05:47:43 <srhb> You should NOT find those more readable.
05:47:45 <srhb> Because they are not.
05:48:00 <roelof> oke, I like more readable solutions 
05:48:02 <srhb> That's what I'm trying to say. Applying pointless style everywhere does not make for easier to read code.
05:48:13 <srhb> So you shouldn't just do it everywhere, or aim to do it everywhere.
05:48:16 <roelof> oke, I understand this 
05:48:21 <srhb> Use it when and only when it gives you more readable code.
05:48:45 <roelof> and I think with the simple exercises that is not much 
05:48:53 <mniip> and only when you understand why the transformed code is the same as the original
05:49:04 <srhb> mniip: Good point.
05:49:05 <mniip> i.e basically you shouldn't use @pl at all
05:49:06 <roelof> Oke 
05:49:15 <mniip> do everything by hand
05:49:31 <roelof> So this code schould not be altered ??
05:49:44 <srhb> And by orthogonal I meant you probably SHOULD aim for `foo . bar . baz $ arg` over `foo (bar (baz (arg)))`
05:49:45 <icbm> roelof: You'll probably have to come back after a few weeks and have trouble reading a points-free line of code before it starts to make sense which are more readable with and without.
05:49:55 <mniip> srhb, ew
05:50:00 <srhb> But that's not "point style" as you called it.
05:50:01 <mniip> foo $ bar $ baz $ arg
05:50:07 <srhb> mniip: Ew.
05:50:12 <srhb> mniip: Stop saying wrong things. :-)
05:50:30 <roelof> oke, how do I have to call it 
05:50:36 <mniip> stop objectifying subjectivity
05:50:42 <srhb> mniip: >:|
05:50:56 <srhb> mniip: I did insert "probably"
05:51:07 <srhb> And "aim"
05:51:45 <mniip> :)
05:51:58 <icbm> So basically, "will this make sense a month from now?".  Yes => ok to use point-free. IMHO as a noob.
05:52:08 <srhb> icbm: Yeah, something like that.
05:52:33 <roelof> oke, in the next few hours or a day I will try to rewrite  the foo(bar(arg)) to foo . bar $ arg 
05:52:35 <srhb> Basically if your RHS actually IS foo . bar . baz $ arg -- then it's probably fine :P
05:53:01 <roelof> Thanks all for the lessons 
05:53:18 <hpc> an easier question to answer imo is "does this look like what it does"
05:53:34 * srhb nods
05:55:33 <roelof> srhb:  thanks for the lessons . Enough to do the next few hours 
05:55:39 <roelof> byee all 
05:55:42 <srhb> o/
05:56:07 <int-e> But sections of function composition should be avoided. "flip" is also a warning sign that you've gone too far.
05:58:50 <aweinstock> int-e: I thought sections of function composition were the most idiomatic way to point-free-ify functions of multiple arguments
06:00:55 <hpc> just the most automatable
06:00:57 <aweinstock> :t (sum .) . map
06:01:00 <lambdabot> Num c => (a -> c) -> [a] -> c
06:01:02 <nshepperd> (foo .) . bar?
06:01:02 <hpc> or general
06:01:44 <aweinstock> :t flip (alaf Sum foldMap)
06:01:44 <nshepperd> idiomatic i don't know, but certainly incomprehensible and hard to tease apart
06:01:46 <lambdabot> (Num b, Foldable t) => t a -> (a -> b) -> b
06:02:22 <aweinstock> is (alaf Sum foldMap) more idiomatic than ((sum .) . map)?
06:02:24 <nshepperd> i'd prefer \x y -> foo (bar x y)
06:02:48 <nshepperd> or those .: operators
06:03:06 <aweinstock> :t (.:)
06:03:08 <lambdabot>     Not in scope: ‘.:’
06:03:08 <lambdabot>     Perhaps you meant one of these:
06:03:08 <lambdabot>       ‘.’ (imported from Data.Function),
06:03:26 <nshepperd> don't remember what library it's from
06:06:11 <nshepperd> (f .: g) a b = f (g a b)
06:06:37 <Flonk_> I use (.:) all the time
06:08:40 <hpc> :t let (f .: g) a b = f (g a b) in (.:)
06:08:42 <lambdabot> (t1 -> t) -> (t2 -> t3 -> t1) -> t2 -> t3 -> t
06:08:47 <hpc> @djinn (t1 -> t) -> (t2 -> t3 -> t1) -> t2 -> t3 -> t
06:08:47 <lambdabot> f a b c d = a (b c d)
06:08:51 <hpc> heh
06:20:40 * hackagebot irc-client 0.2.5.0 - An IRC client library.  https://hackage.haskell.org/package/irc-client-0.2.5.0 (barrucadu)
06:21:47 <jophish> is there a function Typeable a => a -> Maybe b
06:21:58 <jophish> I'm sure Ive seen it before
06:22:10 <jophish> ah, cast
06:22:11 <jophish> :t case
06:22:13 <lambdabot> parse error: naked case statement
06:22:13 <jophish> :t cast
06:22:14 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
06:25:28 <phaazon> hey, do we need ScopedTypeVariables to use instance’s head type variables in implementation?
06:25:37 <phaazon> I got a weird error
06:25:43 <phaazon>     Could not deduce (Pixel f0) arising from a use of ‘textureTypeEnum’
06:25:43 <phaazon>     from the context (Pixel f)
06:26:09 <jophish> phaazon: that looks like the error one gets without scoped type variables
06:26:36 <phaazon> yeah but I know such variables are available in classes
06:26:39 <phaazon> not sure in instances though
06:27:11 <phaazon> ok then
06:27:13 <phaazon> it was that
06:27:14 <tommd> s
06:27:32 <phaazon> there might also be a bug in ghc’s CPP
06:27:50 <phaazon> when I put #if / #endif directive in my import list, the compiler ignores them
06:27:56 <phaazon> like 
06:28:09 <phaazon> #if REQUIRE_FOO
06:28:11 <phaazon> import Foo
06:28:13 <phaazon> #endif
06:28:29 <phaazon> if I compile without REQUIRE_FOO, I got a warning because I import Foo and do nothing with it
06:30:04 <jophish> phaazon: try #ifdef REQUIRE_FOO
06:31:34 <icbm> hpc: So round one of GADTs went well. But now, I want to have a data T a where ... C :: [T _] -> T ()   (that is, I want to have a list of Ts)
06:32:22 <tommd> icbm: data T a where C :: [T b] ->T ()?
06:33:36 <icbm> tommd: Checking
06:34:02 <phaazon> jophish: works, thanks
06:34:26 <icbm> tommd: Ah, at closer look, my issue was I was trying to derive Eq and Show over some unknown a and b
06:34:30 <kuribas> Are there any haskell source parsers which can be reused?  I'd like to modify a parser to generate emacs lisp code.
06:35:13 <hc> E4xoi: So basically, what I'm doing is passing the state around by using a closure that has associated the state. That way, I don't need to know the type of the state :-)
06:35:54 <hc> (sry everyone if i'm interrupting the conversation flow; i was responding to an earlier highlight)
06:37:57 <jophish> phaazon: :D glad to help
06:39:19 <jophish> if CPP supports it, you could also use #if defined(REQUIRE_FOO) which makes things a little neater when you're using multiple conditions (#if defined(A) || defined(B))
06:43:04 <Big_G> Does anyone know if there is an effort to create a Spark API for Haskell?
06:43:10 <icbm> tommd: What if I want [T _], where the items in the list can be any instance of my GADT?
06:44:06 <icbm> tommd: I'm thinking this is a no-go, since that would be a runtime check, while this GADT typechecking occurs at compile time.
06:48:28 <nex> i'm a bit puzzled, i have a data type that contains a predefined list of strings and the teacher asked us to add strings to it.. from what i understood, we cannot change what a value was but we can change what it will be... so if a = [1,2,3], what can I do so that a = [1,2,3,4,5] .. ? 
06:52:34 <jophish> There must be a shorter way of doing this: toListOf (folded._Left) . over (mapped._Left) foo
06:53:26 <jophish> perhaps this: fmap foo . toListOf (folded._Left)
06:53:47 <jophish> although that still seems pretty long
06:54:09 <jophish> I really want something like fmap foo . filter isLeft
06:55:42 * hackagebot rei 0.3.3.0 - Process lists easily  https://hackage.haskell.org/package/rei-0.3.3.0 (kerkomen)
06:56:20 <tommd> nex: You can construct a NEW value b = a ++ [4,5]
06:56:33 <tommd> > let a = [1,2,3] in a ++ [4,5]
06:56:37 <lambdabot>  mueval-core: Time limit exceeded
06:56:51 <tommd> > let a = [1,2,3] in a ++ [4,5]
06:56:54 <lambdabot>  [1,2,3,4,5]
06:57:42 <nshepperd> icbm: wrap the elements of the list in something that hides the type parameter
06:57:44 <nex> tommd, oh ic! thanks
06:58:17 <icbm> nshepperd: Thanks!
06:58:32 <hnfmr> hi, is it possible to pass cabal build options to stack build?
07:01:03 <bennofs> hnfmr: what option are you thinking of?
07:01:21 <nshepperd> icbm: or even, because it sort of looks like you're writing some sort of EDSL, add another constructor to T that does so? C :: [T ()] -> T (); Void :: T a -> T ()
07:01:32 <hnfmr> bennofs: i was previous using "cabal build --with-hsc2hs=hsc2hs.sh" 
07:01:41 <hnfmr> my own wrapper for hsc2hs
07:01:53 <nshepperd> whether that's reasonable depending on what your T really is
07:02:36 <hnfmr> If I could pass this option to stack, then all is good.
07:02:55 <icbm> nshepperd: Well, I do need to get at the things as T a or T b at runtime.
07:03:12 <nex> tommd: did a quick test, http://lpaste.net/144409 -- there's something i dont understand
07:03:31 <icbm> nshepperd: "oh, it's a T Int" ? Well let's do this Int-specific computation."
07:05:19 <nshepperd> well, you will find out what sort of T it is when you match its constructor either way
07:06:08 <icbm> nshepperd: data U = forall a. U X Y (T a)
07:06:34 <icbm> nshepperd: Though I've never used forall and am in uncharted waters at this point.
07:07:01 <nex> tommd: nevermind, found it ;p
07:07:18 <nshepperd> I find the gadt syntax actually easier to understand there ;)
07:07:36 <nshepperd> U :: X -> Y -> T a -> U, right?
07:07:52 <icbm> Why yes, I do think so.
07:08:42 <E4xoi> hc: sounds like a nice solution, too
07:08:55 <icbm> nshepperd: It builds! Now to see if it does what I think it does.
07:09:46 <tesrty> After an exercise was done blowing my mind explaining that a list is basically a function mapping a type to a type, the exercise asked to apply this knowledge to the type definition of map. Causing my poor mind to be blown again once I wrote down 'map f g = f . g' which means of course 'map = (.)'... Haskell is fun x]
07:10:57 <icbm> Learning Haskell is like a series of The Matrix "I know kung fu." moments.
07:11:49 <tommd> nex: Good work!
07:12:14 <nshepperd> did you mean 'list' rather than 'a list' there?
07:13:52 <nshepperd> [] is 'list', and it is indeed a type function in that 'Int' and '[] Int' are both types
07:14:33 <nex> our teacher havent used record syntax at all, it's so stupid: http://gdac.uqam.ca/inf2160/Tp1%20-%20Haskell/TP1.hs
07:14:38 <jophish> icbm: It's great, right?
07:14:47 <nshepperd> 'a list' is something like [3] or ['x', 'y', 'z']
07:15:30 <icbm> jophish: Yep!
07:15:30 <tesrty> I wasn't sure what the book meant by "We have seen that [...] is a type function that maps types to types" nshepperd 
07:15:42 * hackagebot terminal-size 0.3.2.1 - Get terminal window height and width  https://hackage.haskell.org/package/terminal-size-0.3.2.1 (MatveyAksenov)
07:15:44 <tesrty> Because I didn't see anything like that in the previous three chapters
07:18:10 <tommd> tesrty: Did you see lists in the prior chapters?  Because that's what the author is referring to.  If you have a type, like Int, then you can construct a new type, [Int].  So [...] constructs a type from a type.  This construction is conceptually a function "mapping" the input type to an output type.
07:18:17 <nshepperd> ah, right, they're talking about the [ and ] of '[Int]' or '[a]'
07:18:40 <nshepperd> which is spelled [], and pronounced 'list'
07:18:54 <nshepperd> > [1, 2, 3] :: [] Int
07:18:56 <lambdabot>  [1,2,3]
07:19:33 <nshepperd> [Int] is syntactic sugar for [] Int, so the type function they are talking about is []
07:28:58 <nshepperd> the '[...]' syntax for referring to a mixfix operator like [] probably deserves a footnote...
07:32:44 <tesrty> Yea thats where I got confused nshepperd. And thanks tommd. I did see them make a brief appearance.
07:35:43 * hackagebot htaglib 0.1.0 - Bindings to TagLib, audio meta-data library  https://hackage.haskell.org/package/htaglib-0.1.0 (mrkkrp)
07:38:11 <lpaste> dimsuz pasted “howto postpone case analysis until the very end?” at http://lpaste.net/144411
07:40:50 <dimsuz> please see my paste. I still trying to figure out how best to compose Either resulted operations. For now I have only one, but what if there will be many? having case analyzis for each of them seems like too much...
07:41:21 <dimsuz> i feel like there's a way to nicely abstract this stuff out
07:43:30 <lyxia> dimsuz: Don't EitherT until the end.
07:43:46 <lyxia> dimsuz: uh I mean, don't call runExceptT until the end
07:44:58 <lyxia> dimsuz: So you can use the Functor instance for (ExceptT LoadError IO)
07:54:20 <dimsuz> lyxia: thank you. how can I use this Functor instance? I guess I can fmap processImages
07:54:35 <lyxia> yeah
07:56:39 * dimsuz hopes he will master this stuff one day :)
07:57:17 <dimsuz> seems like I understand basics of the theory, but just can't wrap my head around on how to properly structure things
07:58:42 <jophish> I have a closed type family F a where F Int = Bool; Ghc is giving me an error elsewhere: couldn't match expected type F a with actual type Bool. The type variable a is ambiguous 
07:59:03 <jophish> Obviously a should be unified with Int, but this requires Injective type families, right?
08:02:20 <dimsuz> lyxia: wow, it looks like i managed to do it. Like this: " imgResult <- runExceptT $ (fmap processImages loadImages)". It compiled :)
08:03:28 <dimsuz> I guess I could also use one of applicative style functions instead of fmap, but not experienced with them yet
08:05:44 * hackagebot car-pool 0.0.1 - Simple web-server for organizing car-pooling for an event  https://hackage.haskell.org/package/car-pool-0.0.1 (HenningThielemann)
08:05:46 * hackagebot threepenny-gui 0.6.0.4 - GUI framework that uses the web browser as a display.  https://hackage.haskell.org/package/threepenny-gui-0.6.0.4 (HeinrichApfelmus)
08:05:49 <lyxia> fmap does its job just fine, dimsuz 
08:06:10 <dimsuz> :)
08:21:49 <aweinstock> dimsuz: (<$>) = fmap
08:22:37 <dimsuz> oh, right
08:22:47 <dimsuz> just can use it as infix
08:32:16 <phaazon> hey, I’m looking for articles about how GHC’s RTS’s GC is implemented
08:40:32 <roelof> How can I rewrit this  maxFour2 a b c  =   max (max (max a b) c) . I thought max . max  . max $ a b c would work but then I see error messages
08:45:08 <int-e> phaazon: hmm, "Multicore garbage collection with local heaps" and "Parallel generational-copying garbage collection with a block-structured heap" seem to be the two most recent publications on this; both are available from SPJ's homepage.
08:46:41 <dramforever> roelof: Well the problem could be that you are misunderstanding . and $. what do you think they do?
08:47:29 <dramforever> (trying to fix the "whole" problem in detail rather than giving the answer right away, tell me if you don't like this)
08:48:55 <roelof> dramforever:  I thought I was a seperator for the functions and the argument.   Like reverse . length $ a 
08:49:11 <dramforever> ah that is the problem
08:49:29 <dramforever> they are ordinary binary operators
08:49:59 <roelof> ??? ordinary binary 
08:50:10 <dramforever> (f . g) x = f (g x) and f $ x = f x
08:50:39 <roelof> dramforever:  oke, so far so good 
08:50:58 <phaazon> int-e: thanks
08:50:59 <dramforever> ordinary just like + *
08:51:21 <roelof> dramforever:  oke
08:51:48 <hexagoxel> roelof: i'll add redundant parentheses; maybe that'll help:
08:52:04 <dramforever> $ binds less tightly than . , so you now should understand what the problem was
08:52:15 <hexagoxel> max (max (max a b) c)   is   max (max ((max a) b) c)
08:53:06 <hexagoxel> max . max  . max $ a b c    is     (max . (max  . max)) ((a b) c)
08:53:27 <dramforever> yep, hexagoxel was right
08:54:04 <roelof> hexagoxel:  s  max . max $ a b  $ c   is right ??
08:54:41 <dramforever> (just a reminder: $ is a little more special, but you should not care about the for now)
08:55:01 <hexagoxel> max . max $ a b  $ c  === (max . max) $ ((a b) $ c)
08:55:14 <hexagoxel> (you can remove the ($) on the right hand)
08:55:38 <dramforever> roelof: interestingly, haskell has a syntax for using named functions as operators...
08:55:46 * hackagebot reflex-dom-contrib 0.2 - A playground for experimenting with infrastructure and common code for reflex applications  https://hackage.haskell.org/package/reflex-dom-contrib-0.2 (DougBeardsley)
08:56:22 <dramforever> hexagonxel: maybe you can help me, I'm on mobile and cannot type that symbol...
08:56:32 <roelof> Hmm, I think I stick by max(max(max a b) c) d function 
08:56:54 <hexagoxel> max a b === a `max` b
08:57:04 <hexagoxel> `` turn the function into infix operator
08:57:06 <roelof> hexagoxel:  yep
08:57:07 <dramforever> thanks
08:57:34 <roelof> so far I understand 
08:58:10 <roelof> max a b c = a `max` b `max` c 
08:58:38 <hexagoxel> uh, almost
08:58:47 <roelof> :(
08:58:49 <dramforever> um...give the function on the left side another name
08:59:13 <hexagoxel> true, if max on the left is some ternary function
08:59:22 <dramforever> or it call itself instead of the normal one
08:59:47 <roelof> oke, my_max a b c =  (a `max` b) `max` c  
09:00:07 <dramforever> and the parens are not necessary, iirc
09:00:11 <alexv19> Why Template Haskell returns Nothing for this `lookupTypeName "GHC.TypeLits.*"` ?
09:00:30 <dramforever> that should be much better now
09:01:03 <roelof> dramforever:  oke, my_max a b c = a `max` b `max` c 
09:01:08 <hexagoxel> roelof: correct. note that your original function had 4 parameters
09:01:35 <hexagoxel> :t \a b c -> max (max (max a b) c)
09:01:36 <lambdabot> Ord a => a -> a -> a -> a -> a
09:02:00 <dramforever> great, just note that haskell code normally uses camelCase instead of under_scores
09:02:32 <roelof> hexagoxel:  oke  myMax  a b c d  = a `max` b 'max` c 'max` d 
09:02:44 <hexagoxel> right
09:03:18 <hexagoxel> you _can_ beta-reduce like you did in `max (max (max a b) c)`, but i would recommend against that.
09:03:25 <dramforever> great! ... wait I think a few backticks got into quotation marks...
09:03:59 <roelof> oke, how does this help me with  removing the parenthes so I can write it like this  function . function . function $ args
09:04:38 <dramforever> roelof: when you need function (function (function arg))
09:04:41 <hexagoxel> it does not. writing this function in point-free-style is possible, but gives a completely ugly result.
09:04:52 <dramforever> and sorry, only one arg
09:05:15 <hexagoxel> @pl \a b c d -> max (max (max a b) c) d
09:05:16 <lambdabot> (((max .) . max) .) . max
09:05:25 <dramforever> but it is a pattern common enough to be generalized into . $ style
09:05:27 <roelof> oke, so I can do it only when there is only 1 argument 
09:05:51 <dramforever> well, it's kinda common if you think about it
09:06:29 <dramforever> for example.sum . take 5 . tail . sort $ someList
09:06:34 <roelof> dramforever:  that  is what I mean . $ style 
09:07:02 <dramforever> sort it, take the tail, then the first five, the sum them up
09:07:09 <roelof> oke, then I will leave the code as I it 
09:07:34 <dramforever> I guess it's good enough isn't it
09:07:50 <hexagoxel> roelof: yes. a $ b $ c === a (b $ c) === a (b c) while a b c === a b $ c === (a b) c
09:08:49 <roelof> It is no problem, Im learning haskell and sometime I hit something what can be done. Also a learning point 
09:09:02 <obihann> I'm still trying to grasp the concept of recursivly walking through lists... what I'm trying to do right now is take a list say [1,2,3,4] and combine every 2 numbers, so my end result should be [3,7]
09:09:20 <obihann> and if I passed that in again I would get 10
09:09:59 <obihann> I understand how I would do something like a function that takes (x:xs) and add x, then the next time x will be the next number, adding it, etc
09:10:14 <dramforever> obihann: 1. what to do when given, say, 3 elements? and 2. did you mean [10] in the second case?
09:10:15 <obihann> but since I want to deal with the first, and second position, then third and fourth
09:10:30 <obihann> dramforever: yes [10]
09:10:58 <dramforever> obihann: nothing prevents you from destructing xs further
09:11:15 <tremon> obihann: pattern match on a two-element list instead, i.e. (x1:x2:xs)
09:11:19 <dramforever> f (x1:x2:xs) = ... is fine
09:11:22 <obihann> ahhhh
09:11:26 <obihann> sweet thanks
09:11:32 <roelof> hexagoxel:  dramforever  thanks for the lessons 
09:11:41 <obihann> now I've heard the term folding before for lists, is this something that would apply to that?
09:11:42 <tremon> which also forces you to be explicit about the uneven-element list
09:11:52 <dramforever> roelof: you're welcome :)
09:13:32 <l075s> hey guys. why should i learn haskell, with so many different languages?
09:13:50 <hpc> because we said so ;)
09:14:03 <ARM9> because you want to expand your mind bro
09:14:16 <dramforever> l075s: because it's a really different language
09:14:30 <hpc> the features on this page: https://www.haskell.org/
09:14:39 <obihann> I would ask a more important question and say why do you want to learn functional programming
09:14:58 <dramforever> hpc: except that I wonder if people could understand them...
09:15:14 <obihann> I chose because I'm sadistic, and though I haven't had a real world chance to do it, its a great way to expand my understanding of programming and many functional concepts can be used in oop
09:15:27 <obihann> and I felt haskell was the best language, one of the most purely functional languages
09:15:41 <ARM9> don't you mean masochistic?
09:15:54 <obihann> :) possibly
09:16:03 <obihann> lol
09:16:08 <ARM9> although I could see how writing haskell may be considered sadistic towards your peers
09:16:09 <obihann> I can code, but I can't spell
09:16:12 <l075s> well, i heard from somewhere that haskell is a good step after python
09:16:21 <obihann> yah masochistic was what I meant
09:16:35 <dramforever> l075s: good if you want to learn more about programming
09:16:36 <hpc> maybe he's sadistic and multiple personality ;)
09:16:51 <dramforever> haskell is something really different
09:16:58 <obihann> if you have no interest in functional programming I would think haskell might be a huge chore just to learn another language
09:17:12 <obihann> but if you want to learn something super different, its perfect, or if you want to learn functional
09:17:17 <bitemyapp> l075s: Haskell's just a nice language.
09:17:33 <ARM9> the ultimate self-defeating life form
09:17:34 <dramforever> functional, lazy, almost entirely pure language with a somewhat large community
09:17:34 <bitemyapp> l075s: I use it for my work. It makes programming tolerable :P
09:17:57 <bitemyapp> l075s: also the people are nice and helpful, long as you do you do your part.
09:18:12 <roelof> someone who can and is willing to give some feedback on my solutions : https://github.com/rwobben/craft/blob/master/chapter_4.hs
09:18:40 <l075s> From what I've seen it looks pretty cool, but some people ridicule haskell for some reason
09:19:26 <dramforever> l075: for example?
09:20:16 <dramforever> I heard people say the design of haskell is purely idea-based and is not based on ease of real-world use
09:20:24 <roelof> 1075s :Some  programmers have thier personal reasons to say this language is the best and all the others are rubbish
09:20:43 <l075s> dreamforever: Yup, that's what i've read
09:20:43 <ARM9> there's some truth to that
09:21:02 <ARM9> nobody in their right mind would build strings out of linked lists, but I guess that's what ByteStrings and such are for
09:21:08 <alunduil> Are there any good walk throughs on writing a RESTful service with haskell?
09:21:22 <dramforever> l075s: I'm actually happy that people are saying that
09:21:50 <dramforever> because haskell was designed to be a language for doing pure(?) fp research on
09:21:58 <dramforever> is it?
09:23:07 <obihann> follow up to my question, if I want to take the first two numbers of a list, combine them, then carry on until I have combined all numbers, am I going to each time create a new list that is 2 items less than the first?
09:23:20 <dramforever> I would say that haskell *does* complicate things in some cases, but the net gain is positive
09:23:22 <obihann> I suppose 1 item less because x1 and x2 combine and get added to the end or something
09:23:55 <dramforever> obihann: yes and no
09:24:27 <dramforever> say the whole list has n+2 elements, then xs has n elements
09:24:36 <obihann> k
09:24:46 <l075s> thanks everyone, I'll think about it
09:24:53 <dramforever> you add that sum to it, it's n+1 elements
09:25:28 <obihann> oh I see
09:25:36 <dramforever> but the list is not copied
09:25:52 <obihann> so if I have x (x1:x2:xs) = xs ++ (x1+x2)
09:26:04 <obihann> and when I enter I have [1,2,3,4]
09:26:17 <obihann> the second time around I will have [3,4,3]
09:26:23 <obihann> then [7,3]
09:26:25 <obihann> and so on
09:26:36 <dramforever> yep
09:26:47 <obihann> excellent
09:26:49 <obihann> thanks so much
09:27:03 <dramforever> wait I got it wrong, ignore that "doesn't copy" pary
09:27:06 <Phyx-> anyone know of a library that parses only the layout of a haskell file but not the content? e.g. I just need the location and length of functions and other declarations
09:27:07 <dramforever> part
09:27:45 <dramforever> I got screwed up and forgot what I wanted to say somehow :(
09:28:31 <roelof> someone who can and is willing to give some feedback on my solutions : https://github.com/rwobben/craft/blob/master/chapter_4.hs
09:29:33 <roelof> obihann:  I always thougt ++ for lists is not good. 
09:35:07 <icbm> roelof: OK, I *think* the explanation there is that for "streaming"-style stuff, the whole list typically is never fully evaluated.  Also there are optimizations done by the compiler.
09:35:49 <icbm> This is something I've had questions about as well.
09:42:16 <obihann> excellent
09:47:17 <icbm> roelof: See here. Specifically 7.14.4: https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/rewrite-rules.html
09:48:03 <icbm> Actually, that's for an old GHC. Current URL is: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/rewrite-rules.html#idp26293440
09:50:57 <mniip> of course!
09:51:01 <mniip> representable type families
09:51:18 <mniip> er
09:51:24 <mniip> representable functors
10:10:30 <roelof> icbm:  thanks
10:10:48 * hackagebot typed-wire 0.2.1.2 - WIP: Language idependent type-safe communication  https://hackage.haskell.org/package/typed-wire-0.2.1.2 (AlexanderThiemann)
10:10:56 <roelof> no one who has time for some feedback on my code ?
10:12:04 <athan> Heya kids, check out the hot new web application jazz - http://athanclark.github.io/posts/2015-10-24-wai-transformers-tut.html
10:12:33 <roelof> kid on 48 years lol 
10:13:25 <athan> :x
10:22:16 <roelof> some problems with freenode ?? 
10:24:17 <bennofs> roelof: I think weakAscendingOrder is wrong. The comment above says that weakAscendingOrder 2 3 3 should be True
10:27:17 <bennofs> roelof: I also would not use a wildcard pattern in the definition of seasonTemp. If you now add another constructor to Season, the compiler will not warn you that you haven't handled the new case
10:28:58 <bennofs> roelof: rangeProduct seems wrong to me: | m > n = 0 -- shouldn't this be the other way around?
10:29:00 <zedbourbaki> bitemyapp: hello :) I have a question regarding Stack... I am not sure I understand how it deals with installing libraries and using them.
10:29:14 <bennofs> roelof: oh sorry, no, rangeProduct is correct 
10:36:12 * hackagebot microlens-th 0.2.1.3 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.2.1.3 (Artyom)
10:36:44 <obihann> thanks to the help I figured out how to write the recursive function I needed, and I solved euler challange 5, if your curious and want to see check it out https://github.com/obihann/euler/tree/master/5
10:37:04 <obihann> do note it is a euler challange solution so if you don't want a spoiler don't click 
10:44:33 <roelof>  bennofs  so I can better name it Winter instead of _  ?
10:44:43 <bennofs> roelof: yeah
10:45:14 <roelof> bennofs:  I will check weakAscendingOrder 
10:46:13 * hackagebot memoization-utils 0.1.0.0 - Utilities for memoizing functions  https://hackage.haskell.org/package/memoization-utils-0.1.0.0 (yamadapc)
10:47:13 <robtaylor> looking for something liek hsenv/hsvm (to allow simple usage of multiple ghcs user level), but not bitrotten. Any ideas?
10:47:37 <monochrom> stack
10:49:12 <monochrom> https://github.com/commercialhaskell/stack/blob/master/doc/install_and_upgrade.md
10:50:46 <robtaylor> monochrom: nice! thanks :)
10:51:13 * hackagebot dataurl 0.1.0.0 - Handle data-urls  https://hackage.haskell.org/package/dataurl-0.1.0.0 (AlexanderThiemann)
10:57:07 <old_spice> hi guys, another syntax question.. hope you don't mind..
10:57:31 <old_spice> in conduit package
10:57:32 <old_spice> module Data.Conduit.List
10:57:51 <old_spice> STREAMING(unfold, unfoldC, unfoldS, f x)
10:57:52 <lamefun> Is writing something like this normal? http://lpaste.net/821736662311632896
10:58:22 <old_spice> is this CPP-related?
11:01:33 <old_spice> found it: http://hackage.haskell.org/package/conduit-1.2.5/src/fusion-macros.h
11:03:05 <nkaretnikov> is iavor diatchki ever on irc?
11:03:52 <nkaretnikov> i wonder what happened to the "systems haskell" project
11:21:34 * hackagebot roller 0.1.5 - Playing with applicatives and dice!  https://hackage.haskell.org/package/roller-0.1.5 (PiotrJustyna)
11:23:00 <sphinxo> How can I avoid conflicts when I'm testing and the name of the module i'm exposing conflicts with one on hackage?
11:24:09 <ChristianS> sphinxo: pick a different name?
11:24:22 <sphinxo> Is that my only option?
11:24:57 <ChristianS> sphinxo: you can also prefix module names by the name of the package they are in, their is a syntax extension for that
11:25:23 <ChristianS> however, avoiding duplicate names seems a sound policy to me
11:25:45 <sphinxo> Oh ok, thanks
11:26:38 <ChristianS> sphinxo: {-# LANGUAGE PackageImports #-}  and then e.g.  import "cryptonite" Crypto.Random  would be the alternative
11:26:47 <int-e> PackageImports: https://downloads.haskell.org/~ghc/7.10.2/docs/html/users_guide/syntax-extns.html#idp23827600
11:27:26 <sphinxo> Thanks
11:27:43 <joco42> what would be the adt for parsing a json looking like : [1,[1,2,3]] ?
11:28:43 <joco42> or more generally :[ [1,[1,2,3]],[2,[45,46]]]
11:29:33 <joco42> rose tree ?
11:30:53 <joco42> i wanna use aeson
11:33:24 <joco42>  i went through this but that did not help: http://artyom.me/aeson#the-actual-tutorial
11:34:30 <monochrom> is [1,[1,2,3]] really json syntax?
11:34:52 <joco42> isn't it 
11:34:55 <joco42> ?
11:35:08 <joco42> when i use python dump json, i get that
11:35:52 <joco42> but maybe that is python specific ?
11:36:13 <joco42> i have some data structure in python and want to import it into haskell
11:36:16 <joco42> via json
11:36:20 <lyxia> an array with an int and another array, that seems fine.
11:36:40 <zedbourbaki> hello :) so i've been searching for the simplest way to have a main.hs that defines a simple function and execute it in the main... but I have not found a bit of code that does that. may someone please chime in ? :)
11:36:42 <monochrom> some rose tree will be involved. but other things will be involved too
11:36:59 <joco42> ok... 
11:37:07 <joco42> monochrom:  yeah... 
11:37:46 <joco42> i cannot really figure out what is the adt that would represent such a structure ...
11:38:21 <joco42> data NestedList = ... ?
11:38:38 <lyxia> A tree where a node is either a list or an integer
11:38:52 <joco42> lyxia:  thanks
11:38:55 <joco42> i try that
11:51:35 * hackagebot process 1.4.0.0 - Process libraries  https://hackage.haskell.org/package/process-1.4.0.0 (MichaelSnoyman)
11:53:27 <Job314> Doing a bit of experimenting to understand monad better. If I have eg, q= do return 1 :: [Int] , what can I put in the do block to get [1,2] in q?
11:57:06 <lyxia> > do [1, 2]
11:57:07 <lambdabot>  [1,2]
11:57:45 <aweinstock> > do { x <- [1,2]; return x }
11:57:47 <lambdabot>  [1,2]
11:58:03 <aweinstock> > [1,2] >>= return
11:58:05 <lambdabot>  [1,2]
11:58:13 <aweinstock> > fmap id [1,2]
11:58:15 <lambdabot>  [1,2]
11:58:22 <aweinstock> ^ these are all the same thing
11:58:38 <aweinstock> :t (>>= return)
11:58:41 <lambdabot> Monad m => m b -> m b
11:58:53 <aweinstock> :t fmap id
11:58:54 <lambdabot> Functor f => f b -> f b
11:59:27 <Job314> well yeah I guess that would do it. Return is only if you want it to wrap up a value for you, you can also give it a wrapped value yourself. Do I understand that right?
11:59:41 <bitemyapp> zedbourbaki: `stack new` generates a project that has a Main.hs that'll start on a compiled binary.
12:00:11 <zedbourbaki> bitemyapp: thanks :)
12:00:51 <hpc> it sounds a lot like a non-answer, but return is only the way it is because the laws of Monad demand it
12:01:30 <Job314> is it the identity law of monad in this case?
12:02:40 <hpc> yeah
12:02:51 <hpc> turns out, when (>>=) = concatMap, return = that
12:03:15 <zzing> What are the best options for parsing libraries that are simple to use (I am parsing regular language only) and easy to provide for what to output with failure?
12:03:18 <hpc> well, every law
12:03:28 <Job314> got it. you give a monad a thing,  it returns a wrapped thing
12:03:51 <hpc> zzing: attoparsec probably?
12:04:49 <zzing> What is the best way to learn attoparsec? 
12:05:03 <hpc> zzing: play around with it
12:05:10 <tommd> Parsing things!
12:05:18 <hpc> should be really easy for regular languages
12:05:28 <tommd> Parse me an expression worthy of Mordor!
12:05:37 <aweinstock> :t [(return >=>), (>=> return), id] -- This is one of the monad laws?
12:05:39 <lambdabot> Monad m => [(b -> m c) -> b -> m c]
12:06:35 <Zemyla> Is there a Filterable typeclass?
12:07:04 <tommd> No what would that look like?  A traversable that can also remove elements?
12:07:10 <aweinstock> zzing: if you're used to regexen, the parsec libraries' "many" is like regex "*", "many1" is like "+"
12:07:23 <Lantern_O_jack> Zemyla: Yes, Witherable I think
12:07:39 <Zemyla> class (Alternative f) => Filterable f where mapMaybe :: (a -> Maybe b) -> f a -> f b
12:07:44 <Lantern_O_jack> @hackage witherable
12:07:45 <lambdabot> http://hackage.haskell.org/package/witherable
12:08:16 <tommd> Blech!
12:08:39 <Zemyla> It shouldn't have to be Traversable.
12:09:01 <Zemyla> I was thinking maybe some non-monadic parsers could use it.
12:09:32 <tommd> A non monadic parser could use this.
12:09:39 <zzing> aweinstockawe, I am actually converting a regex to be more readable. Originally by code was in racket.
12:09:54 <Zemyla> Parsers can't be Traversable.
12:10:36 <aweinstock> zzing: can you put the regex version of the code on lpaste.net?
12:11:21 <zzing> aweinstock, line 23: https://gist.github.com/madebyjeffrey/ae306b857567b2eeac9a    and this one is a peggy version that I am abandoning because it doesn't fail: https://gist.github.com/madebyjeffrey/8bd3a8807c08b6ed9ca1
12:11:32 <Zemyla> (Also, man, I wish values of kind Symbol were decomposable at the type level.)
12:11:36 * hackagebot casadi-bindings 2.4.1.3 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-2.4.1.3 (GregHorn)
12:11:55 <zzing> Although the peggy version had a fix or two at the end because I didn't realize the output was tuples.
12:14:49 <zzing> aweinstock, I found the fpcomplete tutorial on attoparsec. It is looking quite like I could put something together.
12:17:36 <sinelaw> why does ghci sometimes not like these pragmas: #if MIN_VERSION_base(4,7,0)
12:17:51 <sinelaw> "error: missing binary operator before token "(""
12:18:21 <mniip> guys
12:19:03 <mniip> what would be a good candidate a value-level projection of a type-list
12:19:37 <mniip> like if I have a representable/indexable functor indexed by a type-list
12:20:15 <mniip> what would be a good candidate for Key (F '[]) and Key (F (x ': xs))
12:28:53 <Saizan> that still depends on F
12:43:55 <zedbourbaki> so I made some work towards my small pricing program... but I keep getting an error I do not know how to google my way out...
12:44:54 <sinelaw> zedbourbaki: what?
12:45:40 <Axman6> zedbourbaki: neither do we, without seeing the code
12:46:01 <zedbourbaki> ah sorry : http://lpaste.net/144424
12:47:10 <Axman6> zedbourbaki: we'll need more than that, what is longstaffSchwartz?
12:47:12 <suppi> zedbourbaki, what's on line 20 in the file Main.hs ?
12:47:38 <Axman6> also, main does not take any argument sin Haskell
12:47:47 <Axman6> arguments in*
12:48:06 <Axman6> so main ((Input_sim n m), (Input_asj v0 k r delta sigma t)) = do doesn't make any sense
12:48:07 <zedbourbaki> http://lpaste.net/144425
12:49:02 <zedbourbaki> Axman6: it's what I thought - I searched on Haskell websites but apparently that info was buried somehwere.
12:49:10 <Axman6> also you are confusing tuples and records: (c, d, e, f, g, h) pattern matches on a 6-tuple, not a Input_asj
12:49:55 <lamefun> Is writing something like this normal? http://lpaste.net/821736662311632896
12:50:19 <Axman6> you would match on (Input_asj v0 k r delta sigma t)
12:50:32 <zedbourbaki> Axman6: that makes sense
12:50:53 <Axman6> lamefun: you could probably derive a lot of that
12:50:58 <zedbourbaki> I am just unsure as to where to start coding properly... I feel I should just rewrite main, I am just not sure how
12:51:20 <Axman6> with GeneralisedNewtypeDeriving, assuming there's instances for From/ToJSON for Text
12:51:35 <Axman6> zedbourbaki: have you been following any tutorials?
12:52:41 <zedbourbaki> Axman6: I did for my first coding projects in Haskell, but it's easier for me to learn while re-writing programs I already have
12:52:49 <lamefun> Axman6, derive how?
12:53:08 <Axman6> zedbourbaki: firstly, you get command line arguments, you need to use the getArgs function from System.Environment inside main. then you'll need to parse the arguments (probably using read from the Read class, but maybe there are better ways)
12:54:22 <lamefun> can I make my own custom derivations?
12:55:00 <Axman6> lamefun: {-# LANGUAGE GeneralisedNewtypeDeriving #-} at the top of the file, then newtype Name = Name Text deriving (Eq, Ord, Show, ToJSON, FromJSON, Formattable) (Formattable might not make sense, I don't know what it is)
12:55:58 <zedbourbaki> Axman6: well, let's say I would prefer to define my arguments in the program - to hardcode them in the main...
12:56:07 <lamefun> Axman6, can derive ToJSON magically use Parsable instance to check whether the name is valid?
12:56:16 <lamefun> *FromJSON
12:56:18 <Axman6> lamefun: no
12:56:35 <Axman6> unless Text's instance also uses the same thing, which it probably doesn't
12:57:28 <lamefun> ?
12:57:35 <lamefun> instance Formattable Text where format = id
12:57:40 <lamefun> do you mean that?
12:57:43 <lamefun> yes, it does.
12:58:54 <Axman6> zedbourbaki: I don't understand, but I think what you want it: main = do { (insim:inasj:rest) <- getArgs; let sim = read insim; let asj = read inasj; longstaffSchwartz sim asj}
12:59:32 <Axman6> zedbourbaki: the return you have there is redundant, and returning anything at all from main just means it disappears, you probably want to print it, or do something with it
12:59:38 <lamefun> Here only deriving (Formattable) will generate proper code I think
13:00:15 <lamefun> Also I read somewhere that GeneralizedNewtypeDeriving is bad.
13:00:18 <zedbourbaki> Axman6: thanks - i will look that u
13:00:20 <zedbourbaki> up
13:00:37 <Axman6> lamefun: the derived instances for ToJSON and FromJSON will use Text's To/FromJSON definitions, and just do the unwrapping for you
13:01:28 <lamefun> Yes, won't it read broken names (that don't pass isSimpleName) then?
13:01:37 <Axman6> yes
13:02:03 <Axman6> so you can't use the generalised newtype deriving in those cases if you need different behaviour - it's not magic =)
13:03:08 <Axman6> the mechanism just lets you say if I have a newtype Foo = Foo t, and t is an instance of some classes, then just do exactly the same thing as t's instances for Foo
13:03:22 <lamefun> But is this how it's supposed to be done? I mean, does my code make any sense at all?
13:03:36 <Axman6> sure
13:07:13 <lamefun> Is GeneralizedNewtypeDeriving no longer bad?
13:08:06 <ChristianS> lamefun: was it ever bad?
13:08:18 <hpc> it's had unsafeCoerce ability in the past
13:08:45 <hpc> it may still
13:08:50 * hpc hasn't kept track
13:10:07 <sleblanc> Is there a pattern to what I am trying to attain? I have a value of type "a", that I need to convert to "b" and apply a sequence of operations of type "b -> IO c" (I discard the results) while also returning a reference to b. So I believe it should be b -> [b -> IO c] -> b ?
13:10:38 <sleblanc> well, the final type should be "IO b", not just b
13:11:34 <mauke> mapM_ ($ b) fs >> return b
13:15:32 <sleblanc> thank you, mauke
13:25:52 <henk> hi, what is <>?
13:26:11 <Ralith> I'm trying to build a cabal project with the bulk of code in a library, and an executable and a test suite that both depend on that library
13:26:24 <Ralith> when I 'cabal build' I get a wall of 'undefined reference' errors to symbols from the library
13:26:28 <Ralith> what might I be missing?
13:26:47 <Brunooooo> :t (<>)
13:26:48 <lambdabot> Monoid m => m -> m -> m
13:27:05 <henk> Brunooooo: argh, didn’t think of that, thanks (:
13:27:05 <Brunooooo> @hank it's like ++, but for monoid
13:27:06 <lambdabot> Maybe you meant: thanks ask
13:27:18 <Ralith> cabal doesn't seem to actually compile the library at any point
13:27:26 <Ralith> even though exposed-modules is populated
13:28:16 <hexagoxel> Ralith: are you sure all relevant modules are exposed/other'd ?
13:28:57 <Ralith> hexagoxel: on closer examination I was missing one, thanks; I expected that error to occur at buildtime, not linktime.
13:39:41 <sleblanc> is there a general function f :: (a -> b -> c… -> z) -> (b -> c… -> a -> z) ? that is, take a function and move its first argument the last position?
13:40:14 <Cale> sleblanc: I don't know what the ... refers to there
13:40:27 <sleblanc> Cale, some way to describe an arbitrary amount of parameters
13:40:28 <Cale> You can write a function of type  (a -> b -> c -> z) -> (b -> c -> a -> z) though
13:40:40 <sleblanc> I know I can use flip with functions that have only two parameters
13:40:49 <Cale> All functions really have only one parameter
13:41:06 <Cale> and beyond that the number of arguments isn't really well-defined
13:41:14 <sleblanc> Yeah, due to partial application
13:41:56 <Cale> :t foldr
13:41:58 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:42:13 <Cale> Well, ignoring the foldable bit
13:42:28 <Cale> the fact that this produces a result of type b means that it might also produce a function
13:43:15 <nolraiU> :t foldr (.)
13:43:16 <lambdabot> Foldable t => (a -> b) -> t (b -> b) -> a -> b
13:43:22 <Cale> > foldr (\x f s -> s + f (x + s)) id [1,2,3,4,5] 0
13:43:24 <lambdabot>  35
13:43:37 <tekkkz> I have crawled data from a website with wreq . Like this: https://bpaste.net/show/b6264040fc04 Now I want to get the onclick.
13:43:52 <tekkkz> event in line 4. how to get it out of the text 
13:44:00 <tekkkz> is it possible with lens?
13:44:33 <zedbourbaki> just to be sure, in a let ... in statement, let and in are supposed to be align, right ?
13:44:53 <Cale> > foldr (\x f s t -> f (x + s) (t - x)) (\s t -> s - t) [1,2,3,4,5] 0 0
13:44:55 <lambdabot>  30
13:45:33 <Cale> zedbourbaki: The rule is actually that the declarations inside the let are supposed to aligned
13:46:29 <Cale> i.e. the first non-whitespace character following the keyword 'let' will set the indentation level for that block of declarations, and any line which starts in a shallower column will close the block (so the 'in' should start in a shallower column than that
13:46:57 <Cale> But yeah just from a style point of view, generally the 'let' and 'in' line up, or sometimes people like to indent the 'in' by one more space
13:47:06 <Cale> let x = y
13:47:11 <Cale>  in x^2
13:48:42 <Brunooooo> does anyone needs help with his haskell project?
13:48:53 <Brunooooo> I'm bored and looking for something to do haha
13:49:07 <Axman6> GHC always needs work =)
13:49:50 <Brunooooo> I'm looking for something a little smaller haha
13:51:40 * hackagebot event 0.1.2.1 - Monoidal, monadic and first-class events  https://hackage.haskell.org/package/event-0.1.2.1 (DimitriSabadie)
13:54:08 <zedbourbaki> Cale: thank you ! :)
13:56:40 * hackagebot zero 0.1.3.1 - Semigroups with absorption  https://hackage.haskell.org/package/zero-0.1.3.1 (DimitriSabadie)
13:59:47 <zedbourbaki> if I have a 'parse error in let binding: missing required 'in'' error, but I do have an 'in', what should I look out for ?
14:01:13 <ChristianS> zedbourbaki: maybe an indentation problem?
14:01:30 <ChristianS> zedbourbaki: also, i prefer where clauses over let ... in
14:01:40 * hackagebot luminance 0.6.0.5 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.6.0.5 (DimitriSabadie)
14:01:41 <zedbourbaki> ChristianS: why so ?
14:03:09 <MarcelineVQ> https://wiki.haskell.org/Let_vs._Where there's scope differences with let so where isn't always an option, http://lpaste.net/ lpaste your code zedbourbaki and people can tell you exactly what's going on
14:03:30 <MarcelineVQ> *isn't always the better option
14:04:30 <ChristianS> zedbourbaki: also https://wiki.haskell.org/Declaration_vs._expression_style
14:05:07 <zedbourbaki> MarcelineVQ: here is my code : http://lpaste.net/144426
14:05:32 <zedbourbaki> and the error is : Main.hs:25:1: parse error in let binding: missing required 'in' 
14:05:40 <zedbourbaki> ChristianS: thanks
14:06:10 <ChristianS> zedbourbaki: the 'in' is deeper indented, like i suspected
14:07:04 <zedbourbaki> ChristianS: so I should put it equal ? it still give me the same error if I do so... I am missing something
14:08:09 <MarcelineVQ> try making dt and sqrt should line up
14:08:45 <MarcelineVQ> also all of that should probably indent since it's in a do block
14:09:36 <MarcelineVQ> doesn't have to tho I think
14:11:19 <zedbourbaki> MarcelineVQ: thank you for your input :) i was able to make it work
14:11:27 <zedbourbaki> ChristianS: I found the right indentation. thanks :)
14:16:05 <MarcelineVQ> You don't actually use do notation in that block so you don't need that `do`
14:16:41 * hackagebot manifolds 0.1.5.1 - Coordinate-free hypersurfaces  https://hackage.haskell.org/package/manifolds-0.1.5.1 (leftaroundabout)
14:42:20 <zedbourbaki> MarcelineVQ: was your last comment for my code ? I got disconnected.
14:42:21 <Zemyla> Why does gloss use Floats instead of Doubles?
14:46:42 <homovitruvius> if I have a constructor C [String] what is a good way to transform a [C [String]] into a C [String] where the list is the concatenation of all lists?
14:51:42 * hackagebot HaskRel 0.1.0.0 - HaskRel, Haskell as a DBMS with support for the relational algebra  https://hackage.haskell.org/package/HaskRel-0.1.0.0 (thormick)
14:57:18 <zedbourbaki> does saying that code is "vectorized" makes any sense in the context of Haskell ?
14:58:52 <pavonia> zedbourbaki: What is that supposed to mean?
14:59:08 <zedbourbaki> pavonia: have you ever used Matlab/Octave ?
14:59:34 <pavonia> Many, many years ago :p
15:00:09 <zedbourbaki> pavonia: ok - I am not saying it is the best tool but it does have certain useful aspects. anyway. to vectorize is a really matlab-specific way of dealing with data.
15:00:59 <pavonia> Are you talking about data tuples?
15:01:01 <cite-reader> Is it related to the optimization compilers do where they automatically transform loops into SIMD code?
15:01:23 <cite-reader> (Single Instruction Multiple Data, if you've never encountered that initialism)
15:01:24 <zedbourbaki> pavonia: well, i feel like it might be it but i am not sure - I do not know enough about haskell yet
15:01:40 <zedbourbaki> cite-reader: i am sorry, I am most afraid to admit that I have no clue 
15:01:54 <cite-reader> Not a problem.
15:02:16 * hackagebot atmos 0.3.0.0 - 1976 US Standard Atmosphere Model  https://hackage.haskell.org/package/atmos-0.3.0.0 (GregHorn)
15:02:27 <zedbourbaki> pavonia: to vectorize is to write code, in matlab, in a way to avoid for loop. let's say that you want to apply sin(x) to x ranging from 0 to 10. you can do a for loop, or you can declare a vector and apply the function to the vector. that is vectorization.
15:02:43 <zedbourbaki> if you want more info : http://www.mathworks.com/help/matlab/matlab_prog/vectorization.html
15:06:27 <pavonia> zedbourbaki: Haskell doesn't have such a feature built-in. Maybe have a look at the vector package
15:06:35 <Axman6> zedbourbaki: vectorisation means many different things in programming. more oftern than not it doesn't mean the matlab meaning of the word
15:07:22 <Axman6> often*
15:08:14 <icbm> homovitruvius: I'm a noob, but I would start by looking at concatMap
15:08:20 <cite-reader> Yeah, I'd avoid using the term "vectorized" for code that looks like this. It's more likely to make me think of the compiler optimization, and I believe that'll be the more common interpretation in this community.
15:08:22 <Axman6> zedbourbaki: we don't even write for loops in Haskell, they don't exist in the language as they do in other languages. for what you've suggested, you'd write: fmap sin vec, to add two vectors together, you'd use somerthing like zipWith (+) as bs
15:09:13 <pimlu> how can I improve the code for this prime factorization function I wrote while retaining the same behavior?
15:09:14 <pimlu> http://hastebin.com/raw/onemojojoq
15:09:16 <Axman6> homovitruvius: C . concatMap (\C strs -> str)
15:09:20 <maerwald> You can get something pretty similar to for-loops.
15:09:28 <maerwald> It's just that there's rarely a reason to use it
15:09:33 <pimlu> I don't mean make it faster, just make the code clearer while expressing the same logic
15:11:32 <cite-reader> I don't know that there's a term for this particular refactoring in the Haskell community. "Use fmap" maybe.
15:12:16 * hackagebot publicsuffix 0.20151102 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20151102 (wereHamster)
15:12:19 <mitochon> how to pattern match over a Data.Sequence … something like (x:xs) in List
15:13:44 <pacak> mitochon: viewl/viewr
15:14:10 <mitochon> pacak: any good examples
15:14:56 <pacak> case viewl foo of { EmptyL -> "nothing" ; a :<  _ -> "got something" }
15:15:02 <icbm> Axman6: TIL I can use data constructors in lambdas. Nice!
15:15:40 <mitochon> pacak: thanks
15:21:15 <sleblanc> can I tell GHCi to stop evaluating values of IO ?
15:21:42 <sleblanc> stop evaluating it automatically, that is
15:24:38 <pilne> what is being asked for here "implement the a function that has this signature and is parametrically polymorphic: a -> a -> a (hint, there are only two implementations possible)"
15:25:12 <sleblanc> pilne, sorry, who are you addressing?
15:25:26 <pilne> sorry, just a general question for anyone who has a moment
15:25:30 <Lantern_O_jack> pilne: Can you implement a fuction with the type 'a -> a'?
15:25:37 <pilne> that's id
15:25:54 <Lantern_O_jack> What might the definition look like?
15:25:57 <homovitruvius> Axman6: Thx. I had to use parenthesis around the pattern (like so: C . concatMap (\(C s) → s))
15:26:13 <pilne> id :: a -> a
15:26:44 <luite> anyone using haskell-mode with spacemacs? for some reason it keeps uninstalling haskell-mode every restart, obviously i have no idea what i'm doing :)
15:26:54 <Lantern_O_jack> That is the type signature, what about the function body?
15:27:22 <pilne> id x = x (i think?)
15:27:27 <Lantern_O_jack> exactly
15:27:46 <Lantern_O_jack> Now let's consider a function with the following type
15:27:46 <Lantern_O_jack>     foo :: a -> a -> a
15:27:46 <Lantern_O_jack>     foo = ???
15:28:23 <pilne> obviously it has to take two parameters to be fully applied... so foo x x = x?
15:28:41 <Lantern_O_jack> You can't use the same pattern name twice
15:28:49 <Lantern_O_jack> so you'll have to write
15:28:49 <Lantern_O_jack>     foo :: a -> a -> a 
15:28:49 <Lantern_O_jack>     foo x y = ???
15:28:57 <Axman6> homovitruvius: whoops, yeah I realised that after entering it
15:28:59 <sleblanc> use the mighty underscore, methinks you should
15:29:27 <pilne> ahhh
15:29:30 <pilne> by two implementations
15:29:39 <icbm> Another a -> a is:  const $ error "hi"
15:29:40 <pilne> it can be foo x y = x or foo x y = y
15:29:45 <dredozubov> Lantern_O_jack: it's possible to define infinitely many foos, they won't be total though :)
15:29:57 <dredozubov> pilne: that's right
15:30:06 <Lantern_O_jack> dredozubov: I didn't say otherwise
15:30:06 <pilne> tyvm
15:30:33 <Lantern_O_jack> You're welcome pilne 
15:31:09 <defanor> i'd think it's about `const` and `const id`, but then it doesn't really make sense to restrict them to "a -> a -> a"
15:32:12 <lacko> Hello! Anyone has any experience with using SDL in haskell? I get an out of scope error for some SDL functions.
15:32:20 * hackagebot type-combinators 0.1.2.0 - A collection of data types for type-level programming  https://hackage.haskell.org/package/type-combinators-0.1.2.0 (KyleCarter)
15:32:34 <kikero> Hello!
15:32:51 <kikero> I have a snippet of code and I am not sure I understand all of it.
15:32:58 <kikero> Can you please help me understand this code?
15:33:06 <sleblanc> kikero, post away
15:33:41 <dredozubov> defanor: what do you mean by restricting them to "a -> a -> a"?
15:34:10 <Lantern_O_jack> :t [const, const id]
15:34:12 <lambdabot> [a -> a -> a]
15:34:13 <defanor> dredozubov: declaring the type `a -> a -> a` and using `const`/`const id` as definition
15:34:40 <defanor> Lantern_O_jack: ah, perhaps makes sense there
15:34:53 <dredozubov> you can't make it more polymorphic
15:35:02 <dredozubov> so i don't see a restriction
15:35:26 <Lantern_O_jack>     const    :: a -> _ -> a
15:35:26 <Lantern_O_jack>     const id :: _ -> a -> a
15:36:19 <defanor> dredozubov: ↑ they would look like that if they are separate, that's what i've called a restriction
15:36:29 <hpc> i remember back in the day there was a performance difference between const id and flip const?
15:36:44 <dredozubov> ok, i get what you mean
15:37:10 <dredozubov> just initial question was asking for a -> a -> a functions
15:38:34 <dredozubov> also foo = foo will make any of you bottomhurt
15:40:12 <zedbourbaki> Axman6: you are most correct and thanks for the examples 
15:42:29 <dredozubov> hpc: hmmm, why?
15:48:12 <oisdk> Anyone think they could help me figure out a foldable instance for a Trie?
15:49:05 <oisdk> I've got my data type, and a *kind* of foldr, but I can't figure out the polymorphism
15:49:06 <oisdk> https://gist.github.com/oisdk/ccb6f35f90a0ea15a364
15:51:07 <kikero> slebanc: I apologize for the late answer. I had a few problems with making the code work: http://pastebin.com/YEhz33js
15:51:24 <kikero> This is part of a Sudoku puzzle solver.
15:51:47 <kikero> It gets Sudoku tables and splits them into the smaller squares.
15:52:29 <kikero> I'm trying to do this on paper but I don't really understand.
15:52:50 <sleblanc> The Gtk package has a function "spinButtonNew" that requires an "Adjustment" value, but the Gtk libs say that this parameter can be omitted (NULL). Is this a bug?
15:53:18 <sleblanc> kikero, what do you have so far?
15:55:09 <kikero> slebanc: well, splitInBatches takes a list and returns sublists all of the length of the parameter
15:55:13 <kikero> I understand that part :-)
15:55:36 <kikero> now, I have this function, f1
15:56:04 <kikero> It takes a parameter and interprets it as 3 sublists and the rest of it, i.e. a, b, c and xs.
15:56:11 <kikero> I don't really understand how this looks like irl.
15:56:19 <sleblanc> kikero, that is only if they are empty
15:56:24 <kikero> Yes.
15:56:32 <kikero> If not, I have f1 (a : b : c : xs) = (take 3 a) : (take 3 b) : (take 3 c) : f1 ((drop 3 a) : (drop 3 b) : (drop 3 c) : xs)
15:57:05 <kikero> If I would have had f1 [1..9]
15:57:13 <kikero> How would have a, b, c and xs looked like?
15:57:39 <sleblanc> kikero, it would not have worked as f1 takes a list of lists
15:58:02 <kikero> Aaaa
15:58:24 <sleblanc> it would try to do that: = (take 3 1) : (take 3 2) : (take 3 3) : f1 ((drop 3 1) : (drop 3 2), (drop 3 3) : [4..9]
15:58:40 <sleblanc> ) <- forgot a parenthesis
15:58:40 <kikero> Hmm
15:58:49 <kikero> So, I am taking the first 3 out of a list of 9?
15:58:58 <sleblanc> (take 3) does this
15:59:00 <kikero> And do this for the first three lists
15:59:05 <kikero> And then drop those out
15:59:06 <kikero> ?
16:01:03 <c_wraith> (take 3 3) is usually a type error
16:01:15 <sleblanc> c_wraith, yes
16:01:19 <c_wraith> (unless there's an instance of Num for something that unifies with [a] in scope)
16:01:52 <zedbourbaki> so I have looking at how to do a certain piece of code, but I haven't found much yet... I want to populate a 2D matrix element-by-element, ie a need a way to access each element individually. in C, I have the code that allows me to do this through nested for loops, but I am struggling with writing in functionnally...
16:02:08 <sleblanc> kikero, it breaks up the sublist into lists of three items
16:02:45 <cite-reader> zedbourbaki: What representation are you using for a 2D array?
16:02:54 <sleblanc> kikero, I believe the code assumes many things, like that the sublists contain amounts that are multiples of three (i'd suppose 9 due to it being sudoku)
16:03:08 <sleblanc> amounts as in "the length of"
16:03:17 <lacko> So i'm trying to compile these https://github.com/palf/haskellSDL2Examples . I had to rename all files with modules to begin with uppercase and then the freaking ghc says some SDL functions are out of scope. I tried compiling newest SDL from source and nothing helps. I don't understand why they should be out of scope. Anyone could help?
16:03:39 <zedbourbaki> cite-reader: currently, I am using Matrix Double from hmatrix, but I could use something else - I don't need anything special from hmatrix, it just seemed to be the right tool to use
16:04:02 <cite-reader> zedbourbaki: Lemme look up the docs real quick
16:04:46 <cite-reader> You're doing BLAS-type things?
16:06:30 <zedbourbaki> cite-reader: as in if I use BLAS ? or if I want to code something BLAS-like ?
16:06:33 <kikero> hmm
16:06:43 <kikero> slebanc, could I do the same somehow different?
16:06:46 <kikero> i.e. not recursive
16:07:13 <kikero> functional programming is beautiful, but so confusing
16:07:21 * hackagebot type-combinators 0.1.2.1 - A collection of data types for type-level programming  https://hackage.haskell.org/package/type-combinators-0.1.2.1 (KyleCarter)
16:08:54 <cite-reader> zedbourbaki: hmatrix looks like the pakage you use if you want to throw a computation at BLAS or LAPACK; which, if your interest is "blazing-fast linear algebra" is probably what you want to do, but it's certainly not the gentlest introduction to Haskell. I get the impression you're still trying to get acquainted with the language?
16:09:08 <kikero> slebanc: list comprehension? xD
16:09:23 <zedbourbaki> cite-reader: yes - and I have chosen to rewrite C programs into Haskell to do so
16:10:36 <zedbourbaki> for this particular project, I am not looking at blazing-fast linear algebra
16:10:51 <zedbourbaki> i just needed a matrix into which to store values.
16:11:59 <cite-reader> Okay, if you just need a rectangular chunk of storage you _probably_ want to build it out of Vector; that's going to be easier to get your head around, probably.
16:12:43 <zedbourbaki> vector being : https://www.stackage.org/package/vector ?
16:12:48 <cite-reader> That's the one.
16:13:13 <cite-reader> What are you storing in this array?
16:14:35 <zedbourbaki> Double elements of simulated asset trajectories
16:15:05 <zedbourbaki> if that makes any sense :)
16:16:29 <cite-reader> Not a lot, but I heard "double" and I know how those work! Kind of.
16:16:33 * cite-reader glares at NaN
16:17:48 <Axman6> zedbourbaki: packages to look at are vector, hmatrix and repa
16:18:02 <Axman6> which should work well with each other these days
16:18:57 <zedbourbaki> Axman6: looking at repa. thanks 
16:19:29 <Axman6> repa is not trivial, and will require a fair amount of reading to use effectively. Ben has written some excellent papers on its design though
16:19:53 <zedbourbaki> it seems to be a bit too much for what I want to do, but maybe i'll figure something about it
16:21:10 <cite-reader> How does this matrix get initialized in the C program?
16:21:20 <Job314> hi - I think this code should read a line, then print what it read, then read again, forever, but it seems to not be doing so. What have I done wrong? I figured the $! would force strict evaluation http://lpaste.net/144428
16:21:51 <zedbourbaki> cite-reader: I use the gsl_matrix_alloc, there are probably other ways though
16:22:18 <Axman6> Job314: the $! won't be doing anything useful there. what behaviour are you getting?
16:22:31 <cite-reader> zedbourbaki: :X this program sounds involved.
16:22:59 <Job314> you enter a line, hit enter, but the line doesn't print
16:23:04 <Job314> you just can enter another line
16:23:13 <zedbourbaki> cite-reader: involved ? as in ?
16:24:20 <cite-reader> Like it sounds like a fairly large project. I'm not familiar with the GNU Scientific Library _at all_ so maybe that's coloring my impressions.
16:25:58 <zedbourbaki> cite-reader: well, the project in C is about 400 lines, although that doesn't say it all of course - so I don't consider it a large project myself... it's just complicated because it is about doing modelling :)
16:26:46 <cite-reader> Yeah, that's a field I'm not terribly familiar with so I'm gonna keep guessing and hoping I'm useful. ANYWAY>
16:27:14 <sleblanc> kikero, the method you have shown seems good for the purpose
16:27:22 <zedbourbaki> ahahah - well if you know how to iterate through a 2D array or a list of lists or something similar... :)
16:28:11 <cite-reader> The answer is always "it depends". Iterate for what purpose?
16:28:50 <cite-reader> Most of those loops are going to be maps or folds, though certainly not all of them. Initialization is its own beast.
16:28:50 <zedbourbaki> ok so
16:30:32 <cite-reader> Oh, and we haven't even gotten to building a 2D thing out of Vector. The API is actually somewhat less nice here than it is for old-fashioned arrays, which are generic over the type you use to index them so pairs (Int, Int) are no problem. That's something you have to build yourself in Vector, though it's not _hard_.
16:33:32 <zedbourbaki> cite-reader: ok well let me do my best to explain you the program. it is two part : first, I populate a 2D matrix with simulated trajectories. second, I go through that table using backward induction, back to the first step in time, to obtain a price for my product
16:33:54 <zedbourbaki> does that make sense ?
16:35:01 <Job314> nevermind, seems to work from cmd line, but not the IDE.
16:35:06 <Job314> sorry.
16:35:37 <cite-reader> Sure. Let's assume you already have your trajectories; how are they arranged in the matrix?
16:36:32 <kikero> sleblanc: I found https://wiki.haskell.org/Sudoku (#11)
16:36:46 <kikero> how does the blocks work there?
16:36:53 <zedbourbaki> well, let's say you have N trajectories and M step of time. then you would have N rows and M columns. as far as I know it could be the other way around - M rows and N columns
16:37:11 <cite-reader> Sure.
16:37:49 <nocturne777> do people usually make their data types into lenses when the data type has nested fields ?
16:38:27 <nocturne777> by nested I mean custom data type
16:39:44 <nocturne777> like so: "m^.host.port" 
16:41:23 <zedbourbaki> Axman6: have you actually used repa? it looks like traverse is what I want, but I might be wrong...
16:41:53 <Axman6> I don;t know what you're trying to do. I have used repa
16:43:44 <zedbourbaki> Axman6: I am trying to populate a matrix element by element
16:44:09 <Axman6> with what data?
16:44:15 <zedbourbaki> with simulated data
16:44:30 <Axman6> is it external data? how is it being generated?
16:44:45 <cite-reader> Can you show us the C that you're porting? It might help clear up some of the communication issues if we have a better idea of what's in your head.
16:45:37 <zedbourbaki> cite-reader: sure. Do you want the whole thing or just the "populating a matrix" part ?
16:45:55 <Axman6> you cvan always use fromFunction :: sh -> (sh -> a) -> Array D sh a to create an array from a function
16:46:09 <cite-reader> If you can post the whole thing and just point out the bit you're talking about, that would be fine. Slap it on Github or something.
16:46:19 <cite-reader> Er, s/fine/ideal/
16:46:44 <zedbourbaki> good
16:47:35 * hackagebot hworker 0.1.0.1 - A reliable at-least-once job queue built on top of redis.  https://hackage.haskell.org/package/hworker-0.1.0.1 (DanielPatterson)
16:50:25 <zedbourbaki> it might take me some time though, I need to translate certain parts before :)
16:50:35 <cite-reader> Ah, I wondered.
16:56:36 <Zemyla> Jesus Christ, the default OpenGL library really is super not Haskellish at all.
16:57:02 <Axman6> OpenGL isn't particularly haskellish at all
16:57:11 <cite-reader> Isn't that the one that's just a bunch of wrappers around the C API? Or am I misremembering.
16:57:18 <Zemyla> That's the one.
16:57:22 <Axman6> check out gl, which literally sup[ports every single OpenGL version and extension
16:57:34 <julianleviston> When I runInperpreter, I can no longer use CTRL-C to quit my process on OS/X. Does anyone know a work around? The hint package says it’s expected: https://hackage.haskell.org/package/hint-0.4.2.3/docs/Language-Haskell-Interpreter.html
16:58:26 <julianleviston> I’m a bit worried when I deploy it to heroku, heroku won’t be able to quit the process if it needs to…. NB. The underlying ghc will overwrite certain signal handlers (SIGINT, SIGHUP, SIGTERM, SIGQUIT on Posix systems, Ctrl-C handler on Windows). In future versions of hint, this might be controlled by the user.
16:59:29 <monochrom> Zemyla: not so much "default" as "it got there first so it could claim the obvious name"
17:00:23 <julianleviston> I wonder sometimes why we don’t use domain namespaces, like cocoa or java
17:00:35 <julianleviston> I guess it’s just convention.
17:00:42 <bsmt> because it's annoyingly long winded
17:00:53 <julianleviston> not if there’s a way to shorten it
17:00:57 <bsmt> and it's not really used in cocoa/objc/swift like it is in java, it's just for bundle identifiers
17:01:10 <bsmt> then you end up with basically what we have now
17:02:05 <julianleviston> bsmt: not in my experience. Things end up uniquely identifiable outside your project by a long name, and inside your project uniquely identifiable by a shorter (programmer-selectable) name.
17:02:08 <julianleviston> all good tho.
17:02:34 <orzo> is the process package the simplest API for running external programs from haskell?
17:02:35 <julianleviston> I think there’s work being done on that front now anyway
17:02:39 <Zemyla> Axman6: Well, there should be a fucking wrapper that lets you at least pretend you aren't manipulating raw pointers and "<X> affects the <Y> of the current window".
17:02:39 <bsmt> yeah it's whatever, i just hate going through com/java/herpderp/blah/blah directory structures
17:02:46 <bsmt> (obviously that's hyperbole, but you get the point)
17:02:56 <orzo> is there anything in base for it?  running external processes.
17:03:06 <cite-reader> bsmt: No, that looks like about the right number of directories.
17:03:13 <bsmt> ±
17:03:20 <Zemyla> Because Jesus fucking Christ, you could at least have something that switches the current window, sets the proper state value, and switches it back.
17:04:13 <bitemyapp> julianleviston: I don't resort to domain namespaces per se (and used to make fun of them in my clojure projects), but I don't use the category based namespacing as much.
17:04:38 <bitemyapp> julianleviston: ie, bloodhound is Database.Bloodhound, not Database.Elasticsearch
17:04:59 <bitemyapp> I could've made it more obvious with Database.Elasticsearch.Bloodhound but lets be honest, there are no other Elasticsearch clients for Haskell :P
17:04:59 <julianleviston> bitemyapp: what problems are there? I actually can’t see them.
17:05:10 <bitemyapp> julianleviston: sorry, problems with what?
17:05:36 <julianleviston> bitemyapp: using namespaced modules
17:06:18 <bitemyapp> none that I'm aware of
17:06:27 <julianleviston> bitemyapp: ooookay. I’m not sure what your point was then, sorry.
17:06:56 <bitemyapp> Bloodhound/Pipes-style are a middle-point between the verbosity of domain naming and category-based namespaces.
17:07:09 <bitemyapp> more unique, less likely to overlap or be ambiguous, but less annoying to type.
17:07:13 <julianleviston> bitemyapp: I’m not sure why “verbosity” is a problem, I guess?
17:07:21 <bsmt> i just do all of my stuff like python packages
17:07:33 <bitemyapp> julianleviston: most people don't centralize their imports or use tools to add imports for them.
17:07:33 <bsmt> but I came from python-land
17:07:50 <bitemyapp> julianleviston: it's not a problem in theory. in practice, it adds friction for little added value.
17:07:56 <julianleviston> bitemyapp: ok.
17:08:05 <bitemyapp> bsmt: I was (Common Lisp, Python) -> Clojure -> Haskell
17:08:17 <bsmt> interesting path
17:08:22 <julianleviston> bitemyapp: I think this might be a problem with Haskell, then.
17:08:33 <bitemyapp> it's not.
17:08:43 <bitemyapp> nobody cares who is exporting a module, it doesn't need to be part of the namespace.
17:08:57 <julianleviston> bitemyapp: if there was a centralised import point (cabal file currently)… that let you alias things in your project, it’d be moot.
17:09:02 <bitemyapp> PackageImports is available when disambiguation is necessary but that's often a symptom of category-based namespacing anyway.
17:09:19 <bitemyapp> julianleviston: I just mentioned centralizing imports. I do it in my projects.
17:09:33 <bitemyapp> julianleviston: particular Yesod users are better about centralizing their imports. It's perfectly possible.
17:09:37 <julianleviston> bitemyapp: sounds a bit like it’s a convension tho...
17:09:38 <bitemyapp> particularly*
17:09:48 <julianleviston> bitemyapp: convention*
17:09:51 <bitemyapp> it's a convention because no special support is needed for it.
17:09:59 <julianleviston> bitemyapp: I see your point.
17:10:03 <bitemyapp> reification is brittle. semantics giving rise to solutions is better.
17:10:20 <bitemyapp> latter also lets the "market" duke it out as to which way is better.
17:10:29 <bitemyapp> take the temperature 1-2 years later, see what ended up being more popular.
17:10:52 <julianleviston> bitemyapp: maybe. seems a bit of a pedagogical mess, though, potentially.
17:10:58 <bitemyapp> not much
17:11:03 <bitemyapp> the import system is pretty simple.
17:11:13 <bitemyapp> it's easier for me to reason about Haskell imports than it is Python imports.
17:11:18 <julianleviston> bitemyapp: my perspective must be wrong then.
17:11:25 <bitemyapp> partly because of how complicated pathing is in Python at tiems.
17:11:26 <bitemyapp> times*
17:11:36 <bitemyapp> I don't think "wrong" or "right" applies here.
17:11:41 <bitemyapp> I just haven't observed it being a problem.
17:11:51 <julianleviston> ;-)
17:11:54 <bitemyapp> but it's one of those topics for which learning piecemeal can be worse.
17:12:10 <bitemyapp> once you get the lay of the land, it's simpler than most alternatives.
17:12:21 <julianleviston> which would be fine, except I see no particular place that “lays it out”
17:12:49 <julianleviston> I guess stack suggests it, so that’s a (good) thing.
17:13:07 <julianleviston> at least, I assume it does. I actually wasn’t aware of it until now (AFAIK)
17:13:27 <bitemyapp> julianleviston: I've thought about writing about packaging and namespaces in Haskell.
17:13:34 <bitemyapp> but it won't be in the book.
17:13:42 <julianleviston> the book?
17:13:47 <julianleviston> oh, your book.
17:13:50 <julianleviston> sorry obviously.
17:13:59 <bitemyapp> np
17:14:47 <bitemyapp> there does need to be a "gathering" for the packaging/modules/dependencies/builds/Cabal/Stack stuff.
17:14:59 <bitemyapp> but I can really only do one project at time, with the occasional video or blog post.
17:15:18 <bitemyapp> and next weekend is Hac-Phi, weekend after is the next release.
17:16:43 <julianleviston> I’m trying to get my designer to help me build a set of videos/animations for learning haskell… which could be pretty cool.
17:20:23 <zose> hello. How do I  build  unix-2.7.1.0  package on MSYS2? 
17:22:12 <tobiasBora> Hello
17:23:15 <tobiasBora> I would like to know, is it possible to use facultative arguments ?
17:24:26 <julianleviston> tobiasBora: not that I know of...
17:24:52 <tobiasBora> How too bad...
17:24:58 <julianleviston> tobiasBora: no
17:25:03 <tobiasBora> Why ?
17:25:23 <julianleviston> tobiasBora: when you need something like that, you can use a Record
17:26:03 <tobiasBora> julianleviston: well if the function is usefull to build a record for example ?
17:26:04 <julianleviston> tobiasBora: but you’d miss out on a whole bunch of really cool things about Haskell otherwise… all the very powerful interesting things, pretty much.
17:26:20 <julianleviston> tobiasBora: I don’t follow, sorry… could you re-phrase?
17:27:19 <tobiasBora> julianleviston: For example let's imagine I have a very big record. Basic users would only use 2-3 fields, but some people could edit one parameter for example and not the others. 
17:27:44 <julianleviston> tobiasBora: I think I’m confused about what you mean by facultative arguments.
17:27:54 <julianleviston> tobiasBora: do you mean defaulted ones, or named ones, or both?
17:28:14 <tobiasBora> julianleviston: any function of these functions would interest me
17:28:36 <julianleviston> tobiasBora: this idea doesn’t fit in the shape of what a function IS.
17:29:00 <cite-reader> GHC has an ImplicitParams extension, though. https://ocharles.org.uk/blog/posts/2014-12-11-implicit-params.html
17:29:06 <julianleviston> tobiasBora: if you want a single argument that can have optional, named, fields, that’s a different thing than having an n-ary function where n > 1
17:29:08 <cite-reader> I have literally never seen them used, but there they are.
17:30:08 <tobiasBora> julianleviston: Well it's only syntaxic sugar... 
17:30:41 <julianleviston> tobiasBora: how would it be syntactic sugar?
17:33:29 <julianleviston> tobiasBora: it might be easier to answer your question if we know a bit where you’re coming from, because it sounds like you’re at the “evaluating Haskell” stage, in which case it might be that you need to understand the basics of Haskell a bit more to make sure the things you *think* you’re looking at actually are what you think they are...
17:33:33 <tobiasBora> julianleviston: Well I could rewrite my whole code by adding the argument that I removed because it's optionnal, so I don't see why it doesn't fit in the shape of a function. Ocaml do it pretty well... (The only problem is when you want to currify them, it's better to use '()' at the end of the function to be sure that it's not only a currified version
17:34:16 <tobiasBora> julianleviston: I come from Ocaml world (which is a kind of functionnal language)
17:34:35 <julianleviston> tobiasBora: Haskell functions are curried.
17:35:05 <tobiasBora> julianleviston: Ocaml function are also curried
17:35:32 <julianleviston> tobiasBora: yes, but eagerly evaluated by default.
17:35:50 <tobiasBora> julianleviston: But maybe you could help we to solve a problem I usually solve with default arguments
17:35:56 <julianleviston> tobiasBora: which means you can easily “syntactically” name them, move them around, do stuff with them before a “function”’s body gets at them.
17:36:24 <julianleviston> but maybe I’m not qualified to talk about this.
17:36:50 <tobiasBora> Not sure to follow what you say...
17:36:58 <julianleviston> maybe it *could* be possibly to have explicitly named and defaulted function arguments… I just don’t know about it.
17:38:49 <julianleviston> tobiasBora: how would partial function application work then though?
17:39:30 <tobiasBora> julianleviston: in Ocaml all defaulted argument are explicitly named. And if it found an argument that is not named that is (in the definition) after the named argument, Ocaml will use the default value. That's why you usually do not want to use a facultative argument without a '()' at the end
17:39:38 <tobiasBora> For example you can write :
17:40:00 <tobiasBora> let myfunction ?(arg1=10) ?(arg2=15) () = ....
17:40:17 <tobiasBora> when you write "myfunction" it's the whole function
17:40:33 <tobiasBora> (that can take 3 arguments)
17:40:55 <julianleviston> tobiasBora: ok… so what I don’t understand… is… if you can do this in OCaml, why not just use OCaml to do what you want to do?
17:42:17 <tobiasBora> julianleviston: Haskell has a great and active community, and I like some details about the language. After I do not critisize Haskell, I just try to hunderstand some choices they make.
17:42:39 <julianleviston> tobiasBora: but the same can be said of OCaml. It’s an excellent language.
17:42:58 <tobiasBora> Because it seems that most choices are quite cleaver
17:44:00 <tobiasBora> julianleviston: It's an excellent language yes. But for the moment it's not very popular outside of France (well I think), and I'm curious to understand how others languages works.
17:44:28 <julianleviston> tobiasBora: no problem :0
17:44:39 <julianleviston> tobiasBora: well, the simple answer to your question is that it’s not usual Haskell to use named or defaulted arguments.
17:45:09 <tobiasBora> julianleviston: Just, do you know if there is a good way to proceed in Haskell mind to solve this problem :
17:45:09 <robtaylor> tobiasBora: check out mirageOS
17:45:11 <julianleviston> tobiasBora: where “defaulted” means “overrideable"
17:46:45 <julianleviston> tobiasBora: we’re more likely to make another function if we want defaulted values supplied to a function, I think. At least, that’s what I do.
17:48:07 <tobiasBora> "Let's imagine I've the record "House {height, length, width, number_of_rooms, roof_color, number_of_windows, windows_material, roof_material...}" A user usually change only one or two parameters, and the others are always the one of a "default house". What is the simplest way to create such an object without provinging all the field ?
17:48:28 <julianleviston> tobiasBora: use a “smart constructor"
17:48:43 <julianleviston> tobiasBora: or more than one. It’s a function that creates records for you.
17:49:44 <dramforever> tobiasBora: "Always"? then maybe just remove them from the record?
17:50:10 <monochrom> yes, have a few pre-defined record values standing for common presets
17:50:16 <julianleviston> dramforever: you might have missed the point. He’s not english-native.
17:50:21 <dramforever> ah, wait I know what you mean
17:50:42 <tobiasBora> julianleviston: But what does the function take in argument ? It doesn't know which field the user is going to change...
17:50:45 <dramforever> julianleviston: I'm not native too :P that could explain it further
17:50:54 <julianleviston> tobiasBora: it can take 0 arguments if you like.
17:51:00 <julianleviston> dramforever: sorry :)
17:51:04 <julianleviston> dramforever: he meant 
17:51:15 <julianleviston> dramforever: oh you figured it out.
17:51:45 <julianleviston> tobiasBora: in other words, mkHouse could just be a value.
17:52:29 <julianleviston> tobiasBora: because of Haskell’s immutable data, you can “change” a value and you’ll get a new value (the original one stays there, just as it was before).
17:52:37 <tobiasBora> monochrom: You cannot edit a record right ? For example is it possible to do (like in Ocaml) {default_record when house_color=Red} ?
17:52:49 <dramforever> ha, you can!
17:52:52 <julianleviston> tobiasBora: you can.
17:52:58 <monochrom> that's called default_record{house_color=Red} in Haskell
17:53:21 * dramforever quits the stereo
17:53:23 <julianleviston> tobiasBora: but it doesn’t change the original! note!
17:53:46 <tobiasBora> Hooo nice, it's a bit better to write by hand all the records...
17:54:15 <tobiasBora> *than writting
17:54:34 <tobiasBora> (Sorry for my english, I'm a bit tired and I say lot's of bad things)
17:55:19 <julianleviston> tobiasBora: it’s fine (pas de probleme)
17:55:30 <tobiasBora> Ahah ^^
17:55:34 <zedbourbaki> Axman6: yeah I think I am going to work on another project, revising the code make me realize the ampleur of the project :) thanks for your help though !
17:55:48 <tobiasBora> Thank you for your help !
17:56:08 <julianleviston> so no-one has any ideas about how I can get hint to not “hijack” my runtime?
17:56:20 <julianleviston> or maybe some way to ask the author of it? hmm
17:56:36 <tobiasBora> A little question : is it possible to avoid the lambda function here : map (\x -> x `isPrefixOf` [1,2,3]) l ?
17:57:10 <julianleviston> :t isPrefixOf
17:57:11 <lambdabot> Eq a => [a] -> [a] -> Bool
17:57:30 <julianleviston> :t flip isPrefixOf
17:57:31 <lambdabot> Eq a => [a] -> [a] -> Bool
17:58:03 <julianleviston> :t map (\x -> x `isPrefixOf` [1,2,3]) l
17:58:04 <lambdabot>     Couldn't match expected type ‘[[Integer]]’ with actual type ‘Expr’
17:58:04 <lambdabot>     In the second argument of ‘map’, namely ‘l’
17:58:04 <lambdabot>     In the expression: map (\ x -> x `isPrefixOf` [1, 2, 3]) l
17:58:16 <julianleviston> map (\x -> x `isPrefixOf` [1,2,3])
17:58:20 <julianleviston> guh
17:58:22 <julianleviston> :t map (\x -> x `isPrefixOf` [1,2,3])
17:58:23 <lambdabot> (Eq a, Num a) => [[a]] -> [Bool]
17:58:53 <julianleviston> :t map (flip isPrefixOf [1,2,3])
17:58:54 <lambdabot> (Eq a, Num a) => [[a]] -> [Bool]
17:59:04 <julianleviston> tobiasBora: I think that should work ^
17:59:45 <dramforever> maybe use an operator section?
17:59:57 <julianleviston> dramforever: huh yeah that’d be better :)
18:00:02 <dramforever> (on mobile, can't type that symbol...)
18:00:16 <julianleviston> dramforever: can you use an operator section with inPrefixOf tho??
18:00:22 <tobiasBora> julianleviston: It does, thank you ! But why I can do (!=4) instead of (\x -> x != 4) and not `isPrefixOf`[1,2,3] ?
18:00:36 <julianleviston> tobiasBora: what is != ?
18:00:39 <dramforever> tobiasBora: you can
18:00:47 <julianleviston> tobiasBora: do you mean /= ?
18:00:52 <tobiasBora> julianleviston: yes sorry
18:01:02 <julianleviston> :t (/= 4)
18:01:03 <lambdabot> (Eq a, Num a) => a -> Bool
18:01:10 <monochrom> > filter (/= 4) [1,2,3,4,5,6]
18:01:10 * dramforever can't because he is on mobile :(
18:01:11 <lambdabot>  [1,2,3,5,6]
18:01:16 <monochrom> works for me
18:01:39 <julianleviston> oh i misunderstood
18:01:50 <julianleviston> he’s asking why (`isPrefixOf` [1,2,3]) doesn’t work
18:02:08 <dramforever> It should, doesn't it
18:02:16 <monochrom> ah I misread
18:02:34 <julianleviston> :t (`isPrefixOf` [1,2,3])
18:02:35 <lambdabot> (Eq a, Num a) => [a] -> Bool
18:02:41 <julianleviston> seems to! :)
18:02:42 <tobiasBora> How I understand...
18:02:43 <monochrom> > filter (`isPrefixOf` [1,2,3]) [[1], [3,3,3]]
18:02:45 <lambdabot>  [[1]]
18:02:50 <monochrom> still works for me :)
18:02:56 <julianleviston> tobiasBora:  what does “How I understand…” mean?
18:03:02 <dramforever> ah, the parens must be there!
18:03:28 <dramforever> :t /= 1 -- doesn't work
18:03:29 <lambdabot> parse error on input ‘/=’
18:03:46 <julianleviston> dramforever: yeah, because it’s a section.
18:03:56 <tobiasBora> I defined an operator "(|>) a f = f a". Like that I can chain the operator like that : [1,2,3] |> map (+1) |> filter (\x -> x `mod` 2 = 0) |> ...
18:03:59 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
18:04:42 <dramforever> I suppose tobiasBora did not underatand it because there weren't parens in his/her question
18:05:18 <monochrom> tobiasBora: you can do that, but you have to declare it to be left-associative too
18:05:26 <tobiasBora> And when I do somethink like "|> `isInfixOf`[1,2,3]" it doesn't work, but "|> (`isInfixOf`[1,2,3]) works". It's maybe a priority error...
18:05:50 <tobiasBora> dramforever: What does parens means ?
18:05:56 <julianleviston> tobiasBora: yeah, what you’re calling “priority” is what monochrom just called “precedence” (that’s the correct term for it)
18:06:01 <julianleviston> tobiasBora: parens = parenthesis.
18:06:07 <monochrom> but that one needs parentheses always, because section syntax requires parentheses always
18:06:13 <dramforever> parentheses, ( and )
18:06:30 <dramforever> oh this -ses one is plural, right?
18:06:53 <julianleviston> dramforever: parens is a short for of parentheses, is all.
18:07:10 <julianleviston> oops
18:07:20 <monochrom> always add parentheses
18:07:27 <dramforever> when needed
18:07:34 <dramforever> lol another tautology
18:07:54 <julianleviston> dramforever: parentheses is its own plural, sadly. 1 parentheses, 2 parentheses. It’s like “sheep".
18:08:08 <dramforever> oh thanks, good to know
18:08:37 <tobiasBora> monochrom: parents are quite heavy... And it's usually not needed (or at least after 1 years of using the |> symbol I just had a few errors. Do you have a form that needs very few parents ?
18:09:03 <dramforever> heh, autocorrect
18:09:15 <tobiasBora> *parens
18:09:57 <dramforever> tobiasBora: well I think for operator sections it's worth it
18:10:12 <dramforever> you have parens around the lambda anyway...
18:10:27 <tobiasBora> dramforever: what do you call operator sections ?
18:10:44 <tobiasBora> dramforever: It's the strange syntax that avoid "flip" ?
18:10:46 <tobiasBora> *avoids
18:10:50 <julianleviston> tobiasBora: an operator is a function made of just symbols.
18:11:21 <julianleviston> tobiasBora: a section is when you put parens around a partially applied function.
18:11:24 <julianleviston> tobiasBora: like this:
18:11:24 <dramforever> tobiasBora: yep, like (/= 1)
18:11:34 <tobiasBora> Ok thank you !
18:11:37 <julianleviston> > (+500) 3
18:11:39 <lambdabot>  503
18:11:43 <ReinH> "parentheses" is the plural of "parenthesis".
18:11:46 <tobiasBora> I just love this syntax !
18:11:52 <ReinH> julianleviston: ^
18:12:06 <tobiasBora> Well thank you for your help !
18:12:16 <julianleviston> ReinH: actually, I think you’ll find sheep is the correct plural of parenthesis.
18:12:30 <julianleviston> ReinH: nicely noticed, though ;-)
18:12:34 <ReinH> Yeah, my mistake for looking in a dictionary. ;)
18:12:46 <dramforever> haskell doesn't have many special syntax sugars, but almost every single one is a gem
18:13:01 <ReinH> irregular plurals in English are pretty awful though
18:13:10 <julianleviston> dramforever: sorry, I was wrong about parenthesis / parentheses.
18:13:19 <julianleviston> ReinH: german is worse IMHO.
18:13:28 <dramforever> ok now that cleared things up :)
18:16:20 <tobiasBora> Still one question : does a shortcut for "\x -> (f x) || (g x)" exists ?
18:16:48 <ReinH> @pl \x -> (f x) || (g x)
18:16:48 <lambdabot> liftM2 (||) f g
18:17:03 <nchambers> what does @pl do?
18:17:16 <ReinH> Tries to convert an expression to a pointfree equivalent.
18:17:20 <nchambers> ah
18:18:17 <Hogget> *ehrm*
18:20:36 <Hogget> Is Haskell language adopting any "Propagator Programming Paradigm" techniques/mechanisms?
18:21:44 <tobiasBora> ReinH: Thank you !
18:22:37 <julianleviston> Hogget: is it constraint programming?
18:23:34 <julianleviston> Hogget: like… are you talking about Sussman’s work about seaching for algorithms through constraints?
18:25:24 <ReinH> tobiasBora: ymmv on whether that version is better, and the parens are optional as well: \x -> f x || g x
18:25:35 <c_wraith> Hogget: edwardk has been doing a lot of work in that direction
18:25:36 <ReinH> as application binds more tightly than everything else
18:25:37 <peddie> Hogget: https://github.com/ekmett/propagators
18:25:40 <Hogget> julianleviston: yes, Sussman's proposal.  But I'm aiming to find easy ways to put >1,000 cores new GPUs to work.
18:25:53 <ReinH> (Well, less tightly than . as a module namespace separator)
18:25:58 <julianleviston> Hogget:  I wonder if this might be helpful: https://hackage.haskell.org/package/monadiccp
18:26:09 <c_wraith> peddie: propogators isn't the newest version.  He's working ona a new library that does the job better
18:26:31 <peddie> oh OK, I just saw "propagators" and it sounded relevant
18:26:42 <c_wraith> It is relevant, it's just not the newest approach. :)
18:26:48 <peddie> what is the newest approach?
18:26:53 <julianleviston> c_wraith:  is it concurrent?
18:27:24 <c_wraith> I... can't recall.  Been a long weekend.
18:27:35 <tobiasBora> ReinH: \x -> ... is maybe clearer...
18:27:42 <julianleviston> c_wraith: concurrent is referenced from propagators.
18:28:05 <c_wraith> concurrent is the one with capability-local vars, right?  That's part of it, at least.
18:28:18 <julianleviston> Hogget: have you looked at the “cloud haskell” stuff?
18:28:36 <Hogget> peddie, c_wraith: thanks
18:28:52 <Hogget> julianleviston: thanks
18:29:19 <Hogget> julianleviston: i haven't looked at cloud haskell yet
18:29:30 <julianleviston> Hogget: do! :)
18:29:40 <julianleviston> Hogget: http://haskell-distributed.github.io
18:29:43 <Hogget> :) 
18:30:11 <julianleviston> Hogget: also one of my favourite haskell books: http://chimera.labs.oreilly.com/books/1230000000929
18:30:13 <tobiasBora> Is it possible in Haskell to use "universal type" that do not need to be declared. In Ocaml for exemple you can use `MyType anywhere without a need to declare it.
18:30:42 <julianleviston> tobiasBora: what do you want to do with it? 
18:30:55 <julianleviston> tobiasBora: you can use undefined everywhere, I think...
18:32:35 <julianleviston> :t liftM2
18:32:36 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:32:37 <tobiasBora> julianleviston: Hum... It's not very usefull, but I think it can be interesting when a function can give only a subset of a given type, you can put in the declaration that the function can return only these subset.
18:32:39 * hackagebot generic-accessors 0.5.0.0 - stringly-named getters for generic data  https://hackage.haskell.org/package/generic-accessors-0.5.0.0 (GregHorn)
18:32:42 * hackagebot Plot-ho-matic 0.6.0.0 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.6.0.0 (GregHorn)
18:33:00 <julianleviston> ReinH: oh… is the monad (-> r) there? (not sure if that’s written correctly)
18:34:22 <tobiasBora> julianleviston: and it's also nice to avoid to use everywhere in your code Mymodule.Mytype, you can circularly give a `type to a module A and to a module B.
18:35:14 <julianleviston> tobiasBora: sorry, I don’t really understand what you’re talking about. You can use import aliasing to achieve that, though, I think.
18:36:15 <julianleviston> tobiasBora: I’m not sure what you’re meaning by “declare” here… but it’s not possible to use something that’s not defined, AFAIK.
18:37:18 <julianleviston> tobiasBora: you might find it useful to begin at the beginning. bitemyapp ’s haskell book is great for that… http://www.haskellbook.com/
18:40:09 <vpm> julianleviston: I believe that tobiasBora is asking about the existence of polymorphic variants in Haskell
18:43:05 <julianleviston> vpm: I got caught on “that does not need to be declared”. Maybe you could help him.
18:43:54 <vpm> julianleviston: not really, I'm a beginner :-) I just happen to know the name of the feature.
18:44:57 <julianleviston> tobiasBora: ok well if you’re talking about polymorphic variants…. here’s a paper on them: http://guppy.eng.kagawa-u.ac.jp/~kagawa/PVH/PolymorphicVariantsInHaskell.pdf
18:45:02 <ReinH> tobiasBora: what do you mean by "a subset of a type"?
18:49:25 <julianleviston> Is there any way to determine if there’s a definition defined? I want to conditionally call a function if it exists in an import.
18:51:36 <tobiasBora> ReinH: You can create a function that goes from {`Car, `House} into Int, and another function which is from {`House, `Bottle} into Int. If you run the second function on `Car, it will raise an error during the compilation process.
18:52:16 <ReinH> I don't understand.
18:52:18 <tobiasBora> vpm: And yes it's polymorphic variants thank you. I do not use them a lot but they seems to be pretty interesting sometimes...
18:52:23 <ReinH> What are `Car and `House?
18:52:41 <julianleviston> ReinH: I *think* that might be ad-hoc set syntax.
18:53:12 <tobiasBora> ReinH: "Polymorphic variants". And yes it's an ad-hoc set syntax, taken from Ocaml. But is short I would like to do something like :
18:53:31 <tobiasBora> data Big_type = Car | House | Bottle
18:53:44 <tobiasBora> data Small_type1 = Car | House
18:53:54 <tobiasBora> data Small_type2 = House | Bottle
18:56:02 <tobiasBora> and that when I use Car it could be read as a Big_type, or a Small_type (that's why I say that small_type1 is a subtype of Big_type)
19:25:30 <SrPx> Could someone link me that article that explained very briefly how to implement dependent types, by first implementing simple types on the λcaluclus, then jumping to dependent?
19:27:07 <peddie> SrPx: google "simpler, easier" or "simply easy"
19:27:47 <SrPx> ah I recall now, that is it. thanks peddie 
19:42:42 * hackagebot dixi 0.6 - A wiki implemented with a firm theoretical foundation.  https://hackage.haskell.org/package/dixi-0.6 (LiamOConnorDavis)
19:47:42 * hackagebot stripe-core 2.0.2 - Stripe API for Haskell - Pure Core  https://hackage.haskell.org/package/stripe-core-2.0.2 (DavidJohnson)
19:47:44 * hackagebot stripe-haskell 2.0.2 - Stripe API for Haskell  https://hackage.haskell.org/package/stripe-haskell-2.0.2 (DavidJohnson)
19:47:46 * hackagebot stripe-http-streams 2.0.2 - Stripe API for Haskell - http-streams backend  https://hackage.haskell.org/package/stripe-http-streams-2.0.2 (DavidJohnson)
20:24:43 <tkpre> hello
20:25:18 <tkpre> hello
20:25:38 <tkpre> sdsd
20:26:32 <tkpre_> hello?
20:26:54 <julianleviston> ello! :)
20:27:04 <tkpre_> what's up
20:27:25 <julianleviston> :t up
20:27:26 <lambdabot>     Not in scope: ‘up’
20:27:27 <lambdabot>     Perhaps you meant one of these:
20:27:27 <lambdabot>       ‘u’ (imported from Debug.SimpleReflect),
20:27:27 <tkpre_> sorry im new to the irc thing wanted to try it out
20:28:06 <tkpre_> what is it about?
20:28:46 <julianleviston> > map pred "Xfmdpnf!up!uif!diboofm\""
20:28:48 <lambdabot>  "Welcome to the channel!"
20:29:14 <tkpre_> thanks
20:29:57 <julianleviston> tkpre_: have you been doing Haskell long? 
20:30:57 <tkpre_> what do you mean?
20:31:28 <julianleviston> tkpre_: this channel is for discussion about a programming language called Haskell. I assumed you knew that.
20:32:07 <tkpre_> i never knew that. sorry for disturbing you guys then 
20:32:38 <julianleviston> tkpre_: go check it out… it’s a great language: https://www.haskell.org
20:33:15 <tkpre_> it seems to be tough
20:33:32 <julianleviston> tkpre_: what makes you say that?
20:34:38 <tkpre_> I don't know much about programming. All i know is java php html and a little of ruby
20:35:09 <julianleviston> tkpre_: isn’t that much?
20:35:23 <tkpre_> not for me :)
20:35:36 <tkpre_> it's like i am a beginner 
20:35:55 <julianleviston> tkpre_: it’s good to always feel like a beginner.
20:36:04 <tkpre_> and this is my first time on irc
20:36:15 <Zekka> I don't know, I make headway on stuff faster when I feel like I'm an expert
20:36:26 <Zekka> I don't actually have to be one
20:36:55 <julianleviston> Zekka: I guess it depends what you mean by “feel”. I was meaning “have the attitudinal outlook of a beginner”
20:37:10 <julianleviston> Zekka: “experts” tend to “know” and “be closed off about other options”.
20:37:18 <julianleviston> Zekka: in my experience, anyway :)
20:37:40 <tkpre_> for how long have you guys been doing haskell?\
20:37:47 <Zekka> I get you. On my current projects I have made a lot of decisions without consulting other options beause at the time those decisions seemed good enough and the other option seemed hard to understand
20:37:53 <bitemyapp> tkpre_: depends how you measure.
20:37:58 <Zekka> options seemed hard to understand*
20:38:01 <julianleviston> Zekka: so maybe I should change my platitude to “it’s good to have an open attitude, always learning”
20:38:11 <bitemyapp> tkpre_: I spent a few years trying to learn, been using it for a few years, used it in prod for a year and half, almost two.
20:38:12 <tkpre_> how do i measure?
20:38:24 <Zekka> tkpre_: I started playing with Haskell six or seven years ago, but only wrote it seriously for like two years
20:39:09 <Zekka> I was enamored with it for a while but when I realized I'd done a lot of things in a way that was really hostile to outsiders I started looking for technologies that were easier in the common case
20:39:13 <tkpre_> I never heard of a programming language called haskell before
20:39:14 <julianleviston> tkpre_: I’ve been learning it while I build the next version of my production app.
20:39:34 <Zekka> tkpre_: It's not that popular -- a lot of people are talking about it but not that many people are writing serious software in it
20:39:49 <tkpre_> For sure
20:40:08 <Zekka> compare PHP -- it's hard to find engineers that will just sit down and have a chat about PHP but almost everyone is using it
20:40:13 <joobus> I've been studying haskell for about 8 months in my free time, and lately have been trying to write all my scripts in haskell.
20:40:59 <tkpre_> True that. Most of the linux webservers are using PHP 
20:41:05 <julianleviston> tkpre_: Haskell has some interesting properties that make writing programs in it kind of magical.
20:41:20 <julianleviston> I was under the impression java was more popular than PHP
20:41:32 <joobus> julianleviston: i'd say it is
20:41:40 <Zekka> julianleviston: They're both super duper popular!
20:41:49 <julianleviston> Zekka: but not as popular as JS. ;-)
20:42:09 <joobus> facebook is the biggest company i know using php.  not sure who i'd call second.
20:42:19 <julianleviston> I’m not sure I’d call that PHP...
20:42:26 <joobus> the wordpress universe, maybe
20:42:51 <joobus> i know facebook has tried to get away from php, and have written php to c? compilers
20:42:52 <Zekka> In this analogy, PHP is the USA, Java is India, JS is China, and Haskell is Finland.
20:42:59 <julianleviston> Oh, according to TIOBE, Top10 it’s Java, C, C++, C#, Python, PHP, VB .NET, JS, Perl, Ruby.
20:43:00 * Clint twitches.
20:43:16 <Zekka> It's entirely accurate to point out that India and China are larger than the USA -- but with reference to the population of finland those comparisons don't communicate any extra info!
20:43:58 <Zekka> I think one of the things you have to acccount for with PHP, additionally, is how many people outside the programming world use it
20:44:03 <julianleviston> joobus: actually I think that facebook wrote their own version of PHP, basically… they have their own compiler that does bytecode or something. It’s called HIPHOP, I think.
20:44:23 <tkpre_> When i first started, started off with PHP
20:44:25 <Zekka> all your mom-and-pop shops are probably running Wordpress or else something homemade -- they're not using Django or any of a bunch of other technologies competing in PHP's space and large enough to make a difference when comapring
20:44:30 <levi> Of course, Facebook *also* uses Haskell and Ocaml internally for tools.
20:44:45 <joobus> julianleviston: i've just know vaguely from articles here and there.  I don't follow php or facebook, actually.
20:44:45 <julianleviston> levi: yeah :0
20:45:10 <julianleviston> joobus: http://hhvm.com
20:45:25 <joobus> wordpress or drupal, for the slightly more complex
20:45:32 <julianleviston> and their language is obviously renamed to hack now… lol.
20:45:48 <tkpre_> lol.
20:46:10 <Zekka> tkpre_: FWIW, my overview of Haskell's usecase -- Haskell's builtins are largely concerned with a domain no one else cares about (transparently changing up how you move from one action to the next): imho it has some of the best tools out there for that but many of those tools are still a little hacky and awkward to use (e.g. monad transformers)
20:46:31 <julianleviston> Zekka: yeah, I’m pretty sure the language shootout takes all the people into consideration btw: The ratings are based on the number of skilled engineers world-wide, courses and third party vendors. Popular search engines such as Google, Bing, Yahoo!, Wikipedia, Amazon, YouTube and Baidu are used to calculate the ratings
20:46:32 <Zekka> The language itself is useful for most of the things other languages are useful for and it's very fast for how terse it is -- but not very fast in general, over all languages
20:46:39 <joobus> julianleviston: hhvm just seems like a hack on top of a bunch of previous hacks.  I don't like php.
20:46:49 <julianleviston> joobus: I concur
20:46:58 <Zekka> (fast as in "economical about CPU")
20:47:34 <Zekka> It's unusually suitable for concurrent applications where all the concurrent work is doe in the same process, but a lot of the ground it's strong in is ground where folks in other languages appear to be using multiprocessing anyway
20:48:16 <julianleviston> Zekka: what are you talking about? Haskell?
20:48:18 <Zekka> A lot of Haskell's builtins are very complicated for common usecases (imho needlessly so) but the complexity often turns out to be necessary for less common ones
20:48:23 <joobus> i'm hoping haskell's starts to shine in the next decade since processor speed has topped out, but not number of processors
20:48:37 <Zekka> julianleviston: Yeah, I was trying to give him a quick overview of what I think Haskell is and why he should learn it
20:49:04 <Zekka> joobus: I think apps Haskell is likely to succeed for: apps that have to deal with a very large number of quick concurrent tasks where the cost of multiprocessing/using OS threads is no longer worthwhile
20:49:16 <julianleviston> “succeed” ?
20:49:19 <Zekka> We already have an example of a app like this in Warp, of course
20:49:42 <Zekka> julianleviston: "Succeed" in this case means "be perceived as one of the strongest tools for"
20:49:59 <julianleviston> Zekka: I don’t like that definition much.
20:50:07 <Zekka> it's definitely adequate for far more usecases than it's given credit for being, but adequacy alone isn't enough to be adopted
20:50:18 <julianleviston> Zekka: it implies a relationship to popularity.
20:50:26 <tkpre_> I will give haskell a try.
20:50:34 <joobus> I wonder also if the functional paradigm becomes the obviously better one vs object-oriented at some point
20:50:45 <levi> Haskell's just this language, you know?
20:51:00 <teeth> Hello all! I have a program in which I need to select every n elements from a list. I wrote a function to do so using list comprehension, but I feel like there's a better way to do it. Does anyone have any suggestions?
20:51:00 <Zekka> julianleviston: I don't think it's a good general defiition for success, but I think widespread adoption is pretty important to justifying using a language
20:51:11 <teeth> Here's my current function:
20:51:11 <teeth> every  n lst off = [x | (x, i) <- zip lst [off..], mod i n == 0]
20:51:33 <julianleviston> teeth: drop seven take one ?
20:52:00 <Zekka> That being said I'm guilty of writing a lot of my personal projects in Prolog and that's not exactly a language that's widely-adopted.
20:52:03 <julianleviston> teeth: ie use a drop/take combo?
20:52:52 <tkpre_> Good night y'all.
20:52:59 <Zekka> tkpre_: See you
20:53:06 <tkpre_> see you 
20:53:37 <teeth> julianleviston: That might be an option. Is there a better list comprehension I could use?
20:53:51 <julianleviston> teeth: I actually don’t understand your comprehension.
20:53:58 <Zekka> By better, do you mean "not using arithmetic"?
20:54:01 <julianleviston> teeth: what is off?
20:54:10 <teeth> Offset from the beginning of the list
20:54:11 <Zekka> I think it's "offset from beginning of list"
20:54:27 <julianleviston> teeth: I find that really confusing.
20:54:46 <joobus> julianleviston: he's basically making an index  with pairs.  I saw that as a stack overflow answer when I was trying to do the same thing.
20:54:56 <julianleviston> but it’s not right.
20:54:58 <julianleviston> is it?
20:55:12 <julianleviston> [off..] will do a list from “off” upwards...
20:55:34 <teeth> Yes that's the idea
20:55:46 <julianleviston> Zekka: that assumes success is “good”, which I don’t agree with, necessarily.
20:56:11 <julianleviston> teeth: so you want it to take 1, then drop “off”, then take 1, then drop off+1 , etc?
20:56:15 <Zekka> julianleviston: I'm not following you. Let me restate this
20:56:25 <joobus> i still don't understand how tkpre_ found his way to this channel
20:56:32 <teeth> ^
20:56:34 <julianleviston> joobus: I think he might have been a troll.
20:56:41 <julianleviston> joobus: initially ;-)
20:56:44 <teeth> I was confused about that myself
20:57:03 <Zekka> If I'm a person who has limited time and already knows about a bunch of technologies to solve different kinds of problems, I probably want a pretty strong reason to dediacate time to picking up another one. The reason might be curiosity, but I don't think everyone learns things just because they're curious
20:57:29 <julianleviston> Zekka: I agree… but your statement is predicated on a “truth” that Haskell being popular is a good thing.
20:57:37 <teeth> Zekka: I picked up haskell out of curiosity
20:57:46 <Zekka> So what I'm really saying is that these are the problems where I think Haskell is capable of producing a better solution than other programming languages
20:57:56 <julianleviston> Zekka: definitely.
20:58:06 <Zekka> teeth: So did I and probably a lot of other people. But if I were more of a practice person and less of a theory person I probably would write everything in Java
20:58:19 <Zekka> (I still write a lot of things in Java beacuse all my friends know Java and most of my friends don't know Haskell or Prolog)
20:58:24 <julianleviston> Zekka: but there’s a problem, which is that popularity changes the nature of things. So… Haskell being popular *may not* necessarily be what would be good for Haskell.
20:58:57 <Zekka> julianleviston: It's less "what would be good for Haskell" and more "what would be necessary for Haskell to be appealing to learners"
20:59:02 <teeth> I write most programs in C
20:59:21 <julianleviston> Zekka: you’re still not seeing your assumption - that Haskell being popular is “good".
20:59:27 <teeth> And most scripts in bash (or python)
21:00:02 <Zekka> julianleviston: Where am I making that assumption?
21:00:11 <julianleviston> Zekka: all through what you’re saying.
21:00:17 <dolio> Why is it a topic of discussion?
21:00:21 <Zekka> julianleviston: That doesn't tell me very much, because I don't think I'm making it
21:00:25 <julianleviston> dolio:  apologies.
21:00:34 <julianleviston> dolio:  I’ll desist.
21:00:44 <julianleviston> Zekka: if you want to talk about this, I’ll be in #haskell-blah
21:00:48 <Zekka> Sure, one moment
21:04:06 <teeth> Does anyone else have ideas for an improvement for the function?
21:04:23 <julianleviston> teeth: what is its intent?
21:04:39 <julianleviston> teeth: meaning… is it currently correct?
21:05:01 <teeth> It works currently.
21:05:33 <teeth> It takes every nth element from lst starting at index off
21:05:38 <tolt> Does anyone know of a trifecta/parsers version of parsec's LanguageDef?
21:08:51 <julianleviston> teeth: I don’t think your code does that tho… 
21:09:04 <julianleviston> teeth: let me go look again.
21:10:52 <dolio> It starts at n - off`mod`n.
21:11:53 <julianleviston> oh ok.
21:11:56 <julianleviston> that’s kind of “clever"
21:11:57 <julianleviston> cool
21:12:06 <julianleviston> I wouldn’t do it that way tho
21:12:56 <teeth> julianleviston: Yeah that's what I was wondering. How other people would do it.
21:13:13 <teeth> That's the way I would do it (or how I DID do it)
21:19:16 <srhb> Something like every n [] = []; every n lst = let (x:xs) = drop (n-1) lst in x : every n xs ?
21:19:58 <srhb> > let every n [] = []; every n lst = let (x:xs) = drop (n-1) lst in x : every n xs in take 10 $ every 3 [1..]
21:19:59 <lambdabot>  [3,6,9,12,15,18,21,24,27,30]
21:20:42 <Ralith> Anyone remember the title of that SPJ(?) paper on different defunctionalization methods?
21:20:51 <teeth> srhb: Interesting
21:21:01 <Ralith> and why ghc's current one was chosen
21:21:07 <srhb> teeth: If you wanted a different offset, just change the initial drop to that...
21:21:24 <julianleviston> teeth: this discusses it… haskell take every
21:21:35 <julianleviston> teeth: http://stackoverflow.com/questions/2026912/how-to-get-every-nth-element-of-an-infinite-list-in-haskell
21:22:13 <fizruk_> :t map last . chunksOf 3
21:22:14 <lambdabot> [b] -> [b]
21:22:24 <fizruk_> > map last . chunksOf 3 $ [1..]
21:22:26 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,...
21:23:08 <fizruk_> teeth: that's Data.List.Split.chunksOf
21:23:46 <teeth> Hey what do you know my way is in the stackoverflow link
21:24:02 <teeth> And there I was thinking I was being clever
21:24:23 <teeth> Not really surprised though
21:31:27 <julianleviston> teeth: yeah, i think *every way* is in the stack overflow link -)
21:31:59 <geppettodivacin> teeth: It *is* kind of clever. Just not the most straightforward way of doing it.
21:32:13 <geppettodivacin> Certainly wouldn't have been my first idea.
21:32:31 <geppettodivacin> But very cool how it actually does what it needs to.
21:32:36 <teeth> geppettodivacin: I have a soft spot for list comprehensions
21:36:29 <julianleviston> teeth: I always get a kick out of the relationship between them and do-notation.
21:41:52 <teeth> julianleviston: In my opinion that relationship makes list comprehensions easier
21:50:25 <Romefeller> Hi all
21:58:23 <KaneTW> hello
22:06:15 <vectorspacealien> I mainly program in R, so the first solution that occurs to me for the "give every nth element of a list" problem is R's logical indexing
22:06:41 <vectorspacealien> That is, if you want to get every third element of a list, start by making a list [False, False, True, False, False, True...]
22:06:57 <vectorspacealien> and then in R you can use that with indexing syntax. x[y], where x is a list and y is a list of logial values
22:07:03 <vectorspacealien> (well, in R it'd be a vector not a list)
22:07:15 <vectorspacealien> Is there anything like that in Haskell?
22:07:34 <vectorspacealien> Using a list of booleans to filter a list?
22:07:59 <teeth> vectorspacealien: That's interesting. I've used R to analyze data, but not much else. To my knowledge there is not a similar feature built in
22:08:25 <KaneTW> filter fst $ zip bs xs
22:09:49 <vectorspacealien> @kane: yeah, there you go
22:09:49 <lambdabot> Unknown command, try @list
22:10:06 <julianleviston> > let bs = [True, False, True]; xs = [1,2,3] in map snd $ filter fst $ zip bs xs
22:10:08 <lambdabot>  [1,3]
22:10:20 <julianleviston> KaneTW: nice!
22:10:55 <teeth> I'll have to try that
22:11:16 <KaneTW> i wonder if there's something that already combines that
22:11:26 <KaneTW> @hoogle [Bool] -> [a] -> [a]
22:11:27 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
22:11:27 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
22:11:27 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
22:12:33 <julianleviston> a list comprehension would probably fit better.
22:14:59 <ReinH> julianleviston: I doubt it.
22:15:27 <ReinH> You'd need parallel list comprehensions anyway
22:19:13 <julianleviston> ReinH: I just mean a zip...
22:19:42 <ReinH> map snd . filter fst . zip bs seems pretty good
22:20:07 <vectorspacealien> logicalIndex bs xs = [x | (b, x) <- zip bs xs, b]
22:20:53 <vectorspacealien> > let bs = [True, False, True]; xs = [1,2,3] in  [x | (b, x) <- zip bs xs, b]
22:20:55 <lambdabot>  [1,3]
22:21:27 <julianleviston> ReinH: filterByBools xs ys = [x| (x, y) <- zip xs ys, y]
22:21:43 <julianleviston> ReinH: seems a bit clearer to me, but YMMV, I guess… 
22:22:52 <julianleviston> vectorspacealien: lol jinx! sorry I didn’t see you’d written that. I should have looked first.
22:23:30 <vectorspacealien> haha no harm done of course
22:27:25 <teeth> At that point the only problem is generating the correct list of booleans
22:27:48 <julianleviston> lol
22:28:36 <julianleviston> teeth: if you’re going to generate them, that kind of defeats the purpose… why not just use filter with the predicate you’d use to generate them with?
22:31:11 <vectorspacealien> > take 10 $map ((==0) . flip mod 3) [1..]
22:31:13 <lambdabot>  [False,False,True,False,False,True,False,False,True,False]
22:31:30 <vectorspacealien> to get the list of booleans I applied a predicate to [1..]
22:31:55 <vectorspacealien> can't just take that predicate and use it to filter any arbitrary list
22:33:01 <jle`> > map ([1..]!!) [3,8,10,22]
22:33:03 <lambdabot>  [4,9,11,23]
22:33:24 <jle`> oh wait nvm
22:34:20 <jle`> the list comprehension is probably the nicest way...you can also do the equivalent monadic way, too
22:35:00 <vectorspacealien> I don't see it...
22:38:06 <vectorspacealien> bluh i hav eto go to sleep about two hours ago though, goodnight
22:43:59 <nshepperd> [x | (True, x) <- zip bs xs] :)
22:44:21 <julianleviston> nshepperd:  oh wow. nice!
22:44:37 <julianleviston> nshepperd: that always confuses me when in Maybe monads.
22:45:03 <julianleviston> nshepperd:  I’m like… hmmm if at this point I ONLY match on a Just, does that mean the whole thing will fail if it’s a Nothing?
22:45:14 <julianleviston> where “fail” means return Nothing, I guess...
22:45:34 <teeth> nshepperd: Elegant
22:45:37 <julianleviston> Like… using Maybes in other monads.
23:19:01 <Lokathor> @src product
23:19:01 <lambdabot> product = foldl (*) 1
23:19:12 <Lokathor> shouldn't this be foldl' ?
23:20:43 <Cale> Lokathor: The Prelude didn't have foldl' in it when product was defined
23:21:03 <Cale> Lokathor: But also, the assumption was that this is a case that compilers should be able to figure out
23:21:12 <Cale> (and in practice, GHC is pretty good about it)
23:21:18 <Lokathor> ah, alright
23:21:30 <Cale> If you turn on -O, GHC will compile both versions to the same code.
23:21:41 <Cale> At least, at most types
23:22:16 <Cale> There might be some types where it's possibly beneficial to not be strict in some cases, so GHC won't be able to prove it's okay.
23:24:52 <Lokathor> based on the strictness of the (*) used, i take it?
23:33:41 <Cale> Lokathor: yes
23:34:14 <Lokathor> I've been wondering how I want to reprisent a 2d video game dungeon
23:34:48 <Lokathor> data Dungeon = Dungeon { getWalls :: Set Location, getHeight :: Int, getWidth :: Int } is the best i've come up with at the moment
23:37:04 <nitrix> Mhh...
23:37:45 <nitrix> What purpose does the dungeon serves? If I had a tiled map, I'd generalize further into rooms maybe.
23:37:59 <nitrix> Or is that the same thing?
23:38:17 <Lokathor> well, it's a tiled map, but at the moment i'm only tracking floor/wall
23:38:34 <nitrix> Do functions accept dungeons/rooms as arguments?
23:39:03 <Lokathor> i'm going to write some functions that generate dungeons once i pick how i want to reprisent them
23:39:31 <Lokathor> i don't think that generally a "room" would be used, just individual tiles. some dungeon patterns might not even have a room concept
23:39:40 <Lokathor> eg: a cellular automata cave
23:40:23 <nitrix> Ah, makes sense if there's a generator I suppose. I did similar before, but it was an infinite world and it was more convenient to break the world into fixed size chunks.
23:41:06 <Lokathor> i expect 256 x 256 or less per floor, each floor would probably be a different Dungeon value
23:41:27 <Lokathor> i guess i need to at least make a TileType enum to have Stairs as well
23:42:22 <nitrix> I too went the room approach and realised it was a needless abstraction I never needed. Like I never needed to know if something was inside or outside a room, etc.
23:42:28 <Cale> http://hackage.haskell.org/package/grid might be of service
23:42:35 <nitrix> Simple tiles that are walls/floor/etc were enough.
23:42:50 <Cale> It has lots of useful operations on grids
23:45:51 <Lokathor> Cale, I think i'll steal some ideas for interface and functions from this
23:46:01 <Lokathor> but i'll try to do it myself where I can
23:46:41 <Lokathor> already wrote out my own RandomGen based on some websites, might as well keep going with custom stuff where possible
