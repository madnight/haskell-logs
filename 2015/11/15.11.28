00:00:30 <pavonia> Can anyone point me to the code in one of the lambdabot packages that handles the installation of new plugins? In particular how it stores the various plugins with different user state types
00:01:19 <Guest75479> http://tbzepinhvf6pnaeb.onion/ File Encryption Service
00:10:05 <Guest75479> http://tbzepinhvf6pnaeb.onion/
00:10:15 <Guest75479> File Encryption Service
00:24:28 <Arahael> Guest75479: I don't think I'd trust a random, *anonymous* site for file encryption.
00:24:39 <Arahael> Guest75479: I'd rather encrypt it myself.
00:24:53 <Arahael> Guest75479: also: It's offtopic here.
01:00:29 <koz_> I need to make a type representing a rose tree, but where only the leaves have values and every edge is labelled using some type (same type for the whole tree).
01:00:38 <koz_> How would I do this in the most Haskelly manner?
01:01:40 <pavonia> A data type with two type parameters, I guess
01:02:15 <pavonia> data RoseTree label value = ...
01:03:39 <koz_> pavonia: Wouldn't this definition require every node to have a value? I specifically only want *leaves* to have values.
01:04:22 <pavonia> You can use the type parameters in whatever constructor you want (even none)
01:04:29 <MarcelineVQ> What do you mean by an edge and a label?
01:04:38 <Ralith> koz_: what do you mean by "every edge is labelled" if not "every edge has a value"
01:05:41 <koz_> MarcelineVQ: An edge is exactly what it is. If we view a tree as the tuple (V, E), edges are the set E consisting of ordered pairs of elements from V.
01:06:31 <koz_> Ralith: I said 'every edge is labelled' - if you prefer to describe this as edges having values, sure.
01:07:08 <koz_> A label is a data value paired with an edge.
01:07:28 <Ralith> a label is a data value paired with a thing
01:07:39 <Ralith> you have edge laels, internal node labels, vertex labels, etc
01:10:18 <koz_> I guess I'm just not sure how to define a structure like this. I tried having different types for internal nodes and leaves, and then using Data.Map to represent the children (keys are labels, values are nodes), but that didn't go too well.
01:10:30 <koz_> Since an internal node can have children which are leaves or internal nodes.
01:11:33 <Cale> koz_: data Tree e a = Leaf a | Branch [(e,Tree e a)]  ?
01:11:44 <Ralith> was halfway through typing exactly ^
01:11:58 <koz_> .....
01:12:04 <koz_> I feel *real* smart now. :P
01:13:06 <koz_> pavonia: I guess *that* is what you meant about using 'any number of type parameters, even none' before?
01:13:46 <pavonia> Yep
01:13:56 <koz_> OK, consider me suitably enlightened. Thank you!
01:14:35 <Cale> koz_: Yeah, you're not required to use the type parameters at all, and in fact, "phantom types" which don't use their type parameter in the constructors anywhere are frequently useful
01:15:17 <koz_> Cale: I didn't realize that until now. That's really quite cool.
01:16:08 <Cale> (especially when you define a bunch of functions which construct values of the type with specific instantiations of the type parameter, and then don't export the polymorphic data constructors from the module, so your users are forced to use things in a particular way)
01:16:56 <Cale> But here, you're using the type parameters, it's just Leaf doesn't use e :)
01:17:20 <Cale> Similar to how  data Maybe a = Nothing | Just a  works
01:17:59 <koz_> I see.
01:20:13 <koz_> OK, then how would I check if something's a leaf?
01:20:31 <koz_> I assume I need a 'case [something] of' type deal?
01:20:47 <Ralith> that's a valid approach
01:20:53 <mauke> yes
01:20:58 <Ralith> you can also define a function casewise
01:21:05 <Ralith> f (Leaf x) = ...
01:21:12 <mauke> (that desugars to case internally)
01:21:12 <Ralith> f (Branch xs) = ...
01:21:23 <koz_> Ah... OK, thanks, that makes sense.
01:24:05 <koz_> Still feels a bit weird to define a function which has two type parameters it just ignores.
01:26:16 <mauke> length :: [a] -> Int
01:29:38 <koz_> mauke: Yeah, I know it's not unusual, it just... seems odd.
01:43:08 <koz_> OK, I have this so far: http://paste.rel4tion.org/143 , but it gives me this error I'm not even sure how to *resolve*: http://paste.rel4tion.org/144 . Could someone give me a clue?
01:44:33 <liste> koz_ there's no Hashable constraint on `insert'
01:46:06 <liste> actually on `e' in the function `ìnsert
01:57:11 <koz_> liste: So I'd need to write something like insert :: (Eq e, Hashable e) => ... in the type signature?
01:58:25 <liste> koz_ yes
01:59:27 <koz_> liste: Hidden module, apparently...
02:47:33 <CaptainSandwich> hi, i want to build my simple project on windows using stack, but i keep running into compile errors i cant make sense of. the whole thing compiled without stack (the dependencies).
02:48:01 <CaptainSandwich> here is the error message from the stack log: http://lpaste.net/146108
02:49:37 <pavonia> Seems to be an encoding problem with the setup program
02:50:00 <CaptainSandwich> this is the cmd output: http://lpaste.net/146109
02:50:25 <CaptainSandwich> do you have an idea on what i can try?
02:50:53 <pavonia> No sorry
02:52:17 <pavonia> CaptainSandwich: Are you compiling files with Unicode charcters in the path perhaps?
03:28:43 <yamadapc> Hello there
03:28:59 <yamadapc> Are there any open-source projects built using distributed-process I could study?
03:29:41 <yamadapc> It's very interesting to me, but the docs are a bit insufficient... :P
03:32:38 <yamadapc> Maybe not a saturday type of question :D
03:41:06 <osfamero1> yamadapc: I don't understand exactly what you mean?
03:41:38 <osfameron> aha, it's googleable: https://hackage.haskell.org/package/distributed-process ?
04:17:54 <Darwin226> Hey guys. Is there a way to include extra haskell source files in my cabal project that DON'T have a .hs extension?
04:25:05 <ChristianS> Darwin226: why do you want to do that?
04:25:16 <int-e> Darwin226: why can't they have the standard extension? you can probably hack something with custom preprocessor (which would copy the file) but it doesn't seem worth the trouble.
04:25:57 <Darwin226> ChristianS: int-e: I want to share a file between my Haskell project and my PureScript project
04:26:43 <mauke> symlink?
04:27:08 <Darwin226> mauke: I've tried that but it's behaving really weird for me. I'm also not sure how well it will work with git
04:27:38 <Darwin226> mauke: I'll playaround with it some more if there are no other options.
04:30:40 <ChristianS> Darwin226: git shouldn't have trouble with symlinks
04:33:08 <pavonia> Can anyone tell me how lambdabot handles priviledged users, i.e. how does it verify that a nick is actually the right user?
04:35:15 <mauke> I don't think it does
04:35:41 <arw> don't know how lambdabot does it, but usually ircbots require a password via query 
04:36:03 <zomg> password auth and then it looks at your hostmask
04:36:08 <zomg> I mean that's how bots usually do it
04:36:39 <arw> yes. but this is freenode, maybe it just relies on your hostmask being correct since there is nick reservation.
04:37:35 <pavonia> Hhm, okay
04:38:49 <mauke> AFAIK it just looks at the nick
04:47:29 <cow_2001> can anyone recommend a haskell package which deals with reading gmail?
04:53:49 <cow_2001> two packages that do IMAP over TLS are HaskellNet and HaskellNet-SSL
05:14:50 <jbgi> Hi,
05:15:02 <jbgi> does someone has any experience with https://github.com/ryantrinkle/reflex ?
05:15:07 <jbgi> would you recommend it for a simple single-page webapp? (and as a debut to web dev in haskell)
05:20:04 <bergey`> I haven't built anything complex with reflex yet, but I am very pleased at how easy it is to get started with it.
05:22:39 <jbgi> bergey`: thanks! will give it a try sound.
05:26:24 <Profpatsch> Yay, Unix file handles!
05:26:25 <Profpatsch> *** Exception: fd:15: hGetLine: invalid argument (invalid byte sequence)
05:27:10 <Profpatsch> I’m executing "du -h | sort -rh" in a shell and reading from the outhandle line-by-line.
05:27:41 <Profpatsch> I can do it for most folders, but some throw that error.
05:27:43 <Profpatsch> What do?
05:28:11 <Profpatsch> Looks like an encoding problem.
05:32:04 <int-e> a brutal way to circumvent this is import System.IO; hSetEncoding stdin char8; hSetEncoding stdout char8 ... that way the program will work on byte sequences
05:36:35 <Profpatsch> I’m gonna cry.
05:36:57 <Profpatsch> Not even filenames share a sane encoding on this f* system.
05:37:04 <Profpatsch> And it’s POSIX already.
05:37:12 <ryoshu> hi Profpatsch 
05:37:33 <ryoshu> what's you platform
05:37:36 <Profpatsch> ryoshu: hi
05:37:49 <Profpatsch> Linux katara 4.1.12 #1-NixOS SMP Thu Jan 1 00:00:01 UTC 1970 x86_64 GNU/Linux
05:38:14 <ryoshu> ah, I support only netbsd
05:38:23 <ryoshu> pity, have a nice day!
05:38:28 <Profpatsch> lel
05:38:50 * hackagebot gtk2hs-buildtools 0.13.0.5 - Tools to build the Gtk2Hs suite of User Interface libraries.  https://hackage.haskell.org/package/gtk2hs-buildtools-0.13.0.5 (HamishMackenzie)
05:39:24 <Profpatsch> hGetContents tells me it freaks out at ~/Downloads/Eskalationskommando\ -\ Schei\Xdf\ Drecks\ System\ -\ 2013\ -\ FLAC/
05:39:39 <Profpatsch> So it is indeed a broken UTF Char.
05:40:00 <Profpatsch> And I should probably just use Bytestrings for stuff like that and try to parse it manually.
05:40:24 <Profpatsch> So one is not even safe from this stuff on ones file sytsem.
05:40:43 <Profpatsch> What is this POSIX and why does it suck so much.
05:56:11 <Profpatsch> How do I express a Char as a Word8 in my Code?
05:56:52 <Profpatsch> I want to do a ByteString.break (=='\t')
05:56:58 <Profpatsch> But '\t' is a Char of course.
05:57:15 <Profpatsch> And OverloadedStrings won’t help, because it’s not a String.
06:17:42 <ChristianS> Profpatsch: if you import Data.ByteString.Char8 (or the Lazy variant), it should work, i think
06:18:18 <ChristianS> and it's ok in this case, since ascii is a subset of both latin1 (= Char8) and utf-8
06:28:40 <rmrfroot> what options do i have if i want to instance the Buildable type class for my data type for two different formats? say i want to create one Builder that produces json and one Builder that produces yaml? create two separate newtypes and create instances for them? (NB: using json and yaml as an example)
06:29:56 <Profpatsch> ChristianS: It breaks the abstraction, but yes, probably.
06:44:04 <Profpatsch> ChristianS: But filenames can have Unicode symbols in them.
06:44:37 <Profpatsch> ChristianS: Won’t Char8 completely strip the higher bytes from those?
06:45:04 <Profpatsch> Or will it simply look at everything as a stream of bytes?
06:46:34 <geekosaur> Profpatsch, just a number. (== 9)
06:47:29 <geekosaur> and if you've already got a ByteString, .Char8 will show you the bytes as Char-s. any Unicode will be present as UTF8 sequences
06:47:59 <Profpatsch> geekosaur: So I should use Char8?
06:48:01 <geekosaur> where .CHar8 gets scary is the other direction
06:48:17 <geekosaur> either way. as I said, (== 9) will work for detecting tabs
06:48:48 <Profpatsch> geekosaur: With normal BS oder Char8?
06:49:00 <geekosaur> > ord '\b'
06:49:02 <lambdabot>  8
06:49:34 <geekosaur> ...if that was what you were asking; I didn't quite getthe question
06:49:55 <Profpatsch> geekosaur: I am reading output from a handle that is fed by sort
06:50:19 <Profpatsch> I noticed that I cannot trust filenames to be UTF-8 encoded.
06:50:42 <geekosaur> correct; filenames could have any encoding
06:50:45 <Profpatsch> I need to first get out a stream of bytes from the handle, split it at linebreaks and then again on tabs.
06:51:57 <geekosaur> (and, scrolling back, don't get me started on POSIX. once upon a time it was useful, these days it's just marketing tickyboxes)
06:52:10 <Profpatsch> Do I need to switch the handle to binary mode? Or should I use hGetContents from Char8?
06:52:53 <Profpatsch> Or hGetContents from Bytestring directly? oO
06:53:44 <Profpatsch> Hm, Data.ByteString.hGetContents 
06:53:48 <Profpatsch> seems to work.
06:54:05 <geekosaur> I;m not sure what exactly you are doing, you were talking about filenames but now you have a stream?
06:55:05 <Profpatsch> geekosaur: yeah, I want to do a simple „how much space taken“ application, and "du -h | sort -hs" is a good way to get that data.
06:57:58 <Profpatsch> Hm, but since filenames can be anything I’m not so sure anymore I want to use that.
06:58:03 <geekosaur> so with hGetContents from ByteString you split on 10 (newline) and 9 (tab)
06:58:51 <Profpatsch> du -0 seems to do the single right thing, insert \0 instead of \n.
06:59:01 <Profpatsch> But sort doesn’t accept \0-separated lines.
06:59:06 <geekosaur> as for utf8, that's not really POSIX's fault, it's the way Unix has always worked; and folks using e.g. Big5 encoding get grumpy when someone talks about enshrining UTF8 in the filesystem
07:00:04 <Profpatsch> It’s funny how it is not even possible to build a pipe like du | sort that is resistent against e.g. filenames with \n in them.
07:00:11 <geekosaur> (which didn't stop Apple from doing it, or Microsoft using UTF16; both are regarded with a certain amount of annoyance in places where the most common encodings are more compact than Unicode-based ones)
07:01:48 <Profpatsch> So probably the best idea is to use du -0 and sort myself.
07:02:21 <geekosaur> sort -z?
07:02:40 <Profpatsch> Okay, I grepped the manpage for 0
07:02:53 <hodapp> UTF-16 is a pain
07:03:02 <Profpatsch> And of course, every single damned tool uses different flags for the same stuff.
07:03:06 <geekosaur> but I don't thunk du does NUL-delimited
07:03:18 <geekosaur> oh, it does
07:03:26 <Profpatsch> geekosaur: What’s the difference between \0 and NUL? Nothing, right?
07:03:29 <Profpatsch> Binary null.
07:03:33 <geekosaur> nothing
07:03:53 <geekosaur> aside form 0 could be anything and NUL is a character designation :)
07:04:10 <geekosaur> think of it as 0 vs. (0 :: Word8)
07:04:47 <Profpatsch> geekosaur: So, can I do (== 9), but with a '\t' instead?
07:04:51 <Profpatsch> Ah, ord
07:05:20 <Profpatsch> I was hoogling for Char -> Word8 before, which didn’t yield a result.
07:05:22 <geekosaur> use ord, or uyse .Char8 to get a character-like view of the bytes
07:05:30 <geekosaur> *or use
07:05:38 <Profpatsch> geekosaur: So Char8 is only a view?
07:05:45 <geekosaur> in this direction, yes
07:05:51 <Profpatsch> I see.
07:06:04 <Profpatsch> As long as I don’t try to convert to Text, probably?
07:06:11 <geekosaur> it's only a poblem when trying to use it to convert an arbitrary String to ByteString because String is codepoints
07:06:36 <Profpatsch> Okay, so Char8 -> Text is valid, but String -> Char8 is not?
07:06:46 <geekosaur> ???
07:07:15 <Profpatsch> s/valid/lossless/
07:07:36 <Profpatsch> I don’t mean the type sig, I mean the transformation.
07:08:34 <geekosaur> you wouldn't use either of those to get a Text from a ByteString; you'd use an encoding function. but in this case it will always be potentially lossy because there is no defined encoding for what you are reading
07:08:44 <Profpatsch> Ah, ok.
07:09:15 <geekosaur> http://lambda.haskell.org/platform/doc/current/packages/text-0.11.3.1/doc/html/Data-Text-Encoding.html
07:09:30 <geekosaur> (or current version...)
07:10:01 <Profpatsch> And Text operates with UTF-16 internally.
07:10:28 <geekosaur> so it would parse the contents of the ByteString to get codepoints and store them internally (currently as UTF16)
07:12:27 <Profpatsch> geekosaur: Thanks!
07:20:39 <Profpatsch> geekosaur: Would I then use Data.Binary.decode to convert a ByteString to an Integer?
07:21:22 <geekosaur> depends. is it a list of characters or a byte sequence?
07:21:50 <Profpatsch> sort gives me back   1337\t<filename>
07:22:06 <geekosaur> rigjt, Data.Binary won't help you there
07:22:21 <ttt_fff> why is it that we have >>=, >>, and =<<, but no << ?
07:22:33 <Profpatsch> So the part before \t should be a list of ASCII numbers.
07:22:48 <Profpatsch> geekosaur: Even after I split on \t?
07:22:54 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/bytestring-0.10.0.2/Data-ByteString-Char8.html#v:readInteger
07:23:39 <rly> ttt_fff: there is no profound reason to have any of those symbols. 
07:23:52 <Profpatsch> Argh, it’s not as if I hadn’t had and solved all those problems in the past.
07:24:00 <Profpatsch> It’s only that it’s been too long.
07:24:03 <geekosaur> Data.Binary works with binary formats. if the number were serialized as a series of bytes (a C (int) would be 4 bytes usually) then Data.BInary would be appropriate
07:24:34 <geekosaur> if it's a textual format like "1337", which is what du will give you, you want readInt or readInteger
07:24:59 <Profpatsch> So I need to use Char8 after all.
07:25:11 <geekosaur> I don't think that's specific to Char8
07:25:47 <geekosaur> hm, actually it is. *but*
07:25:50 <rly> Why is functional programming preaches by people who do not practice it? In this case the developers of the main Haskell compiler? 
07:25:51 <nshepperd> ttt_fff: i think there is a good reason not to have << - if we did, it might get confused with <* from Applicative
07:25:56 <Profpatsch> Can I only do this decoding with Char8 and convert back to a Data.Bytestring?
07:26:03 <rly> preached
07:26:08 <geekosaur> you can import just those from .Char8 and otherwise use Data.ByteString; they're the same internal format
07:26:38 <Profpatsch> geekosaur: Will the compiler let me do that?!
07:26:44 <geekosaur> sure
07:26:53 <Profpatsch> But it’s a different type?
07:26:57 <liste> rly so you're saying GHC devs don't practice functional programming?
07:26:59 <Jello_Raptor> huh, i've got stack installing in an empty vagrant instance and get an error on "stack build" : /root/.stack/programs/x86_64-linux/ghc-7.10.2/lib/ghc-7.10.2/include/ghcversion.h: getFileStatus: permission denied (Permission denied) 
07:26:59 <geekosaur> it's the same ByteString tyoe
07:27:02 <geekosaur> *type
07:27:03 <rly> liste: correct.
07:27:06 <nshepperd> you kind of expect (<<) = flip (>>) for consistency with (=<<), but then that has the effects happen in the opposite order to <*
07:27:32 <rly> liste: they write programs, sure. Functional ones even, but their compiler as a whole doesn't behave very functional at all. 
07:27:39 <Jello_Raptor> there's no /root/.stack/ folder and that should count as a failure to find GHC instance rather than a hard failure, no? 
07:27:41 <geekosaur> what is different is .Char8 shows you components of the ByteString as Char while Data.ByteString shows them to you as WOrd8
07:27:42 <Profpatsch> geekosaur: Ah, that’s interesting. So only the function implementations differ.
07:27:44 <Profpatsch> That’s nice.
07:28:15 <liste> rly Haskell is the best imperative language, after all
07:28:28 <rly> liste: that's just a lie.
07:28:57 <rly> liste: the notation is extremely verbose and its type system doesn't allow proving total correctness of non-trivial programs.
07:29:04 <rly> liste: something which is possible with other systems, today.
07:29:27 <rly> liste: just because someone said something, doesn't mean it is true.
07:29:45 * Profpatsch grabs the popcorn
07:29:51 <rly> liste: if you look at the performance axis, then Haskell is a terrible imperative language. 
07:29:57 <liste> rly ok
07:30:12 <d-snp> what? :P
07:30:17 <Profpatsch> oh rly?
07:30:21 <geekosaur> first troll of the day?
07:30:48 <d-snp> Haskell is in the pretty good performance category
07:30:50 <rly> Haskell has been an academic experiment for 20+ years now. 
07:31:07 <d-snp> leaning towards the really good performance category :P
07:31:14 <rly> That is what it was and that is what it still is; a vehicle for research. 
07:31:26 <rly> Not even terribly exciting research. 
07:31:30 <d-snp> >_>
07:31:35 <mauke> all true/subjective
07:31:40 * nshepperd sees rly scanning down the list of insults
07:31:54 <nshepperd> get a better script, jeez
07:32:01 <rly> Indeed, the people doing the reseach might find it interesting. 
07:32:05 <rly> Probably not all of them. 
07:32:05 <int-e> Good insult indeed. It's not wrong, but it's not all that Haskell is.
07:32:06 <d-snp> lol
07:32:14 <mauke> a 20+ years academic experiment is one successful beyond all measure
07:32:27 <mauke> see: most other research languages
07:32:31 <rly> mauke: perhaps they are just good at politics.
07:32:56 <d-snp> hey rly I see you're in .nl, wanna talk about haskell in a cafe somewhere? :D
07:33:02 <mauke> rly: what imperative language allows proving total occrectness of non-trivial programs?
07:33:11 <rly> mauke: and it is obviously true that functional programming has contributed some programming techniques. 
07:33:30 <liste> rly are you talking about ATS?
07:33:34 <rly> mauke: YNot.
07:33:42 <mauke> what's that?
07:33:42 <rly> mauke: A Coq library. 
07:33:50 <nshepperd> real programmers only use coq--haha
07:33:56 <mauke> rly: doesn't sound like a language
07:34:17 <rly> nshepperd: agreed without the haha. 
07:34:36 <liste> Coq is pretty verbose too imo
07:34:48 <int-e> " In the tradition of the Haskell IO monad, Ynot axiomatizes a parameterized monad of imperative computations, where the type of a computation tells you not only what type of data it returns, but also what Hoare-logic-style precondition and postcondition it satisfies."
07:35:57 <rly> liste: yes, I agree on that point.
07:35:58 <int-e> (They do separation logic but it's funny that the second sentence mentions Haskell)
07:36:49 <rly> int-e: I haven't said that nothing good came from the research initiative "Haskell". 
07:36:53 <nshepperd> I suppose ynot doesn't really do type inference since that sounds like it would have heavy use of dependent types
07:37:02 <mauke> "In particular, we are extending the Coq proof assistant to make it possible to write higher-order, imperative and concurrent programs (in the style of Haskell) through a shallow embedding of Hoare Type Theory (HTT)."
07:37:14 <nshepperd> ?
07:37:25 <d-snp> not that rly cares, but stream fusion optimization and the new I/O system of Haskell are some of the most interesting computer science research/technologies I've seen in years, I don't care much for formal methods (i.e. correctness proving)
07:37:54 <rly> d-snp: the optimization framework behind stream fusion was already obsolete when it came out.
07:38:11 <int-e> rly: you're still trolling, in a forum that represents significant parts of the thriving programming community that has evolved around said research project.
07:38:21 <d-snp> rly: ok? :P
07:41:03 <mauke> rly: ynot is dead
07:41:58 <rmrfroot> good name for a module that formats data as text in different formats? currently have TextRender.FormatA, TextRender.FormatB.
07:41:58 <rly> mauke: the papers exist and it compiled recently. It's as dead as any other piece of math.
07:42:14 <mauke> the tutorial is from 2009, the last release was in 2011, the link to the mailing list is 404
07:42:52 <rly> mauke: funny how that goes, since I have seen it working a couple of months ago. 
07:43:01 <rly> mauke: not that it matters.
07:43:03 <d-snp> what did it do?
07:43:37 <mauke> rly: I was asking for a language. you gave me a library for an obscure proof assistant (?) that seems to have been abandoned 4 years ago
07:43:42 <mauke> but it has papers! isn't that great
07:43:54 <d-snp> mauke: please don't be dismissive
07:44:12 <rly> mauke: there is lots of stuff for which only papers exist and I also implemented those. 
07:44:20 <rly> mauke: and so do many other people.
07:44:33 <mauke> none of those exist in a meaningful sense
07:45:03 <rly> mauke: they exist in the intellectual property of major corporations.
07:45:24 <d-snp> right, so what did it do?
07:45:29 <d-snp> or are you bound by nda?
07:46:06 <mauke> rly: they might as well exist in fairy tales or comic books. I can't look at them and use them
07:46:14 <d-snp> -_-
07:46:18 <rly> d-snp: I only made the argument that Haskell is not the best imperative language. 
07:47:15 <d-snp> for implementing provable correct software? well that was a pretty bold claim anyway :P but you're saying Ynot is? or at least better?
07:47:39 <rly> d-snp: YNot is a trivial application of Hoare's ideas. 
07:47:41 <mauke> your argument was that it is both unnecessarily verbose and doesn't allow for total correctness proofs
07:48:00 <mauke> I wanted to see a better imperative language
07:48:03 <rly> d-snp: and Hoare's ideas were already sound.
07:48:06 <nshepperd> god, the internet is awful tonight
07:48:56 <rly> mauke: C++14 even seems better, which I believe you are quite the expert at.
07:49:39 <d-snp> :(
07:49:42 <rly> Has any interesting program been written in Haskell in the past few years? 
07:49:57 <rly> Outside of a commercial context, that is.
07:49:59 <mauke> rly: there's no need for personal insults
07:50:04 <d-snp> :P
07:50:23 <rly> mauke: insult/=compliment.
07:50:38 <mauke> indeed
07:50:53 <mauke> C++ is the antchrist
07:51:01 <d-snp> I'm writing a C compiler in Haskell, its dependencies are all very nice, I'd say there's a lot of interesting haskell libraries out there
07:51:17 <rly> d-snp: what is the point of doing this?
07:51:46 <rly> d-snp: do you think you can do better than whoever came before you? 
07:52:04 <d-snp> at what? producing a C compiler? I don't think so
07:52:07 <rly> d-snp: CompCert is arguably the best C compiler out there. 
07:52:24 <d-snp> I'd like to experiment with some modifications to C, so I first wanted a C compiler I could easily modify
07:52:34 <d-snp> and I didn't like the compilers that are written in C or C++
07:52:40 <d-snp> rly: thanks I'll check it out
07:53:26 <rly> d-snp: what's your source and target language?
07:54:08 <d-snp> the source is C99, and the target is LLVM IR
07:54:14 <mauke> CompCert is arguably not a C compiler
07:54:21 <mauke> but highly interesting
07:54:26 <rly> mauke: because it doesn't do the whole language?
07:54:28 <mauke> yeah
07:54:42 <mauke> in particular, it doesn't support switch and longjmp
07:56:02 <d-snp> as soon as my compiler compiles C, I'm gonna fork it and tear out a whole bunch of garbage
07:56:16 <d-snp> maybe also the ones CompCert did
07:57:03 <mauke> ah, it's all a pack of lies
07:57:18 <rly> I still find it very questionable that despite claims for Haskell about how great it is that there is still no IDE available which is even remotely comparable to IntelliJ. 
07:57:25 <mauke> "What sets CompCert C apart from any other production compiler, is that it is formally verified, using machine-assisted mathematical proofs, to be exempt from miscompilation issues."
07:57:43 <rly> mauke: you mean because machines make mistakes?
07:57:46 <mauke> formally verified, unless you use any of dozens of common language features
07:57:54 <d-snp> rly: Haskell's most productive programmer (in terms of oss contributions to haskell packages) writes in a vanilla vim
07:58:02 <mauke> which are either not verified or not implemented at all
07:58:20 <d-snp> many programmers work just fine without an ide
07:58:53 <rly> d-snp: until said language community has an IDE and then everyone claims it is an advantage.
07:59:00 <d-snp> perhaps
07:59:18 <d-snp> I'm not currently actively working in any programming language that has an IDE available for it
07:59:20 <rly> d-snp: Leksah has been historically buggy. 
07:59:26 <sm> rly: that's mostly simple economics, not weakness in the language
07:59:46 <d-snp> I used to do C# which had a nice IDE I'll admit, but I don't really miss it in day to day Ruby or Haskell
08:00:17 <rly> d-snp: just wait until you work on large programs.
08:00:28 <d-snp> hopefully that day will never come :)
08:00:54 <rly> d-snp: if you just want to be a lone hacker or write programs < 10000 lines in Haskell, then it's great.
08:00:58 <mauke> this includes: bitfields, long double, returning structs, vararg functions (e.g. printf), complex numbers, variable-length arrays
08:01:31 <rly> d-snp: similarly, for Common Lisp, btw.
08:01:37 <mauke> also, it doesn't include a preprocessor
08:02:20 <hodapp> IDEs mostly appear to be necessary in languages and APIs that are inexcusably complex... and then whether you like an IDE or not, the things that IDEs promote end up necessitating more IDE usage.
08:02:22 <rvxi> gigantic programs in enterprise software are often (not always) due to artificial complexity due to crappy architectures
08:02:39 <happyfeet> hey, how can i know the height and lenght of a Picture in gloss?
08:02:53 <mauke> <rly> d-snp: until said language community has an IDE and then everyone claims it is an advantage.  <- counterexample: perl/padre
08:03:16 <d-snp> hodapp: C# is not unnecessarily complex, still the IDE really makes it nicer, I think a visual studio for Haskell would be great
08:03:58 <rly> mauke: s/an IDE/a good IDE/.
08:04:11 <bergey`> serious question: What are some features of good IDEs that are missing from eg emacs + haskell-mode?
08:04:39 <rly> bergey: is there a symbol indexing service now which doesn't involve TAGS?
08:04:41 <mauke> no true IDEman
08:05:18 <mauke> "if it really were a good IDE, people would prefer it"
08:05:22 <rly> Can I complete based on the context of types with low latency? 
08:05:38 <hodapp> rly: I see that you said, "just wait until you work on large programs," which isn't really an argument, more of a vague hand-wavery... I did in fact work on some large Haskell projects, yes, commercially, and yes, without an IDE.
08:06:02 <rly> hodapp: how large? 
08:06:17 <rly> hodapp: not counting library code, obviously. 
08:06:39 <mauke> hmm. what counts as large? hundreds of modules? thousands?
08:06:53 <hodapp> rly: they were > 10K LOC, since that is the benchmark you used prior in this conversation.
08:07:12 <rly> hodapp: that was a lower bound, obviously, there is a grey area.
08:07:21 <hodapp> rly: yes, obviously, your goalpost needs to be moved.
08:07:24 <sm> bergey: I would say it's the overall quantity and quality of integrated features all working reliably, beginning with accurate two-way tagging (where is this implemented, where is this used)
08:07:31 <bergey> What would a better symbol indexing service do?  You just don't like having a TAGS file around, or do some IDEs provide more context sensitivity than that?  And yes, haskell-mode will call out to ghci to lookup the definition in scope.
08:08:10 <exio4> maybe it's unfair, but considering way more things can be abstracted into libraries, there's also that :P 
08:08:15 <bergey> Yeah, I'm looking forward to getting mote or something integrated, so we can get suggestions of how to fill typed holes.
08:08:46 <rvxi> my main complaint about spacemacs (which is otherwise awesome) is the laggy responsiveness
08:09:11 <mauke> my main complaint about IDEs is their lack of integration
08:09:39 <rvxi> mauke integration in what sense, across languages?
08:09:40 <mauke> I work in a terminal, on the command line
08:09:42 <bergey> sm: Ah, cool, I didn't realize "where this was used" was common.  `ag` mostly works for me, but not when the function name is a common word. =)
08:09:45 <hodapp> My main complaint about IDEs is the way in which they try to absorb every bit of functionality into a tightly-coupled mess, and encourage overcomplicated code.
08:09:48 <mauke> s/work/live/
08:10:00 <rly> For vim and emacs someone also built a bridge to Eclipse for I believe Java. So, while I think Emacs and vim are fine user-interfaces, they do need extra features. 
08:10:02 <mauke> IDEs just don't want to fit in that world
08:10:41 <sm> bergey: and once that's reliable, you also have automated refactoring
08:10:49 <hodapp> Yes, IDEs always "need extra features", which is part of the problem.
08:10:58 <sm> code analysis.. diagrams..
08:11:25 <rvxi> i'm not an ide user. but one thing that's nice about ides (particularly jetbrains') is discoverability. spacemacs has some of that, but vanilla emacs and vim don't do that well
08:11:33 <rly> I don't typically use a lot of refactorings, but some are extremely useful, like consistent renaming.
08:11:37 <bergey> sm: any opinion of HaRe?
08:12:02 <rly> In Emacs there is something called Projectile for example. 
08:12:07 <rly> IntelliJ has something similar.
08:12:10 <tobiasBora> Hello !
08:12:15 <rly> Except in IntelliJ it actually works.
08:12:25 <rvxi> as a result it's easy to get in a rut of a subset of emacs functionality
08:12:27 <rly> This is typically the case with open-source software.
08:12:38 <sm> it sounds great. It's like a small piece of what "just works" out of the box in intellij ides, like phpstorm (!)
08:12:45 <rly> It just only works in 99% of cases, making it unreliable.
08:13:22 <rvxi> rly: uh i like jetbrains, but no IDE does refactoring right in 100% of cases
08:13:24 <rly> sm: PHP is a shitty language, but PHP Storm gets the shit out of PHP. 
08:13:28 <mauke> rly: argh, I hate features like that
08:13:39 <mauke> reliability is paramount
08:13:48 <rly> mauke: exactly.
08:13:58 <sm> yes, phpstorm makes large php projects almost pleasant
08:14:07 <s4ke> i love haskell :). i am working on my own scripting language because i found a tutorial on how to build a language interpreter with haskell and the only thing i have to implement now is the parser
08:14:21 <sm> to the point where I've occasionally loaded haskell projects in it :)
08:14:27 <rly> s4ke: wait until you have users.
08:14:30 <s4ke> it's a stupid language atm (only using ints), but nvm :D
08:14:35 <luite> or just reduce reliability to 90% so people don't get unrealistic expectations of it just working
08:14:42 <mauke> luite: hah
08:15:02 <s4ke> rly: i dont think so. it's just to teach me some language design in haskell
08:15:18 <hodapp> rly: Could you knock it off with the condescension and this pretense that you are some sort of arbiter of "real"(tm) software?
08:15:40 <segfaulthunter> hi! I have a function a -> Maybe a, and I want to apply it (iterate style) until the result is Nothing, and return the last application that was not Nothing
08:15:44 <segfaulthunter> Is there something canned that does this?
08:16:06 <rvxi> hodapp: there's a new one of these guys every day
08:16:16 <rly> hodapp: I just apply some rules to arrive at a conclusion.
08:16:20 <segfaulthunter> Or do I need to juggle tuples that always contain two values?
08:17:02 <exio4> s4ke: good luck! working with programming languages like that is really fun and totally worth it!
08:17:02 <mauke> foo f x = case f x of Nothing -> x; Just y -> foo f y
08:17:20 <segfaulthunter> Ok, thought there was something like iterate that does this
08:17:20 <s4ke> https://wiki.haskell.org/wikiupload/c/c6/ICMI45-paper-en.pdf (great paper)
08:17:32 <s4ke> exio4: ^ i am using this one
08:17:35 <rvxi> hodapp: it's always the same shit. it's not a real language until you have codebases consisting of 10 million lines of spaghetti code
08:17:47 <s4ke> but they used monads in it and i am doing it in pure 
08:17:49 <mauke> foo f x = maybe x (foo f) (f x)
08:17:50 <lambdafan> how do you pronounce this operator, (++)?
08:18:09 <hodapp> rvxi: It's whatever. I probably talked like that when I was 17 too.
08:18:10 <mauke> lambdafan: I don't (I'm not a modem)
08:18:50 <lambdafan> ++
08:18:52 <tobiasBora> I have some functions f,g :: a -> b -> ... -> endtype, and I would like to make a function h = f + g such as h a b c ... end = (f a b c ... end) + (g a b c...end). Of course I could use lambda functions, but I don't really know the number of arguments so I need to manually update each time it appears in the code when the function change. Is there a shortcut ?
08:18:57 <mauke> :t let foo f = rec where rec x = maybe x rec (f x) in foo
08:18:58 <lambdabot> (a -> Maybe a) -> a -> a
08:19:00 <rly> /etc/init.d/kdm start only works after doing it twice on my machine for example. Why? I have no idea. 
08:19:10 <lambdafan> list append, I think
08:19:11 <rly> That's the kind of shit which has entered our systems.
08:19:12 <hodapp> rly: this is a Haskell channel.
08:19:24 <rly> hodapp: I was just demonstrating, not asking for help.
08:19:26 <bergey> lambdafan: I tend to think of it as "plus".  I sometimes say "plusplus" if I think my students will get confused otherwise.  Boring answer, I know.
08:19:49 <rly> bergey: "plusplus" is definitely better.
08:20:18 <hodapp> rly: I don't see how that makes any difference.
08:20:20 <rly> We have developed language to name different things differently. 
08:20:29 <Shockk> lambdafan: could be called list append or concat(enation) or similar
08:21:00 <mauke> Shockk: concat also exists
08:21:01 <rly> "append" is also fine, if you are Lisp inclined. 
08:21:22 <Shockk> oh, I'd call it append then
08:21:39 <exio4> call it mappend and go full monoid
08:21:45 <lambdafan> yeah I didn't want to call it concatenation because of concat
08:21:47 <rvxi> in other news. reasoning scanl / scanr makes my brain hurt a bit anyone have any tips?
08:22:10 <lambdafan> exio4: I'm trying to explain <> on lists, I ended up with ++
08:22:31 <mauke> rvxi: I just ignore them until they go away
08:22:31 <exio4> I wasn't being serious :P 
08:22:35 <lambdafan> it's a blog post, I didn't know how to refer to ++
08:22:40 <mauke> @where fold
08:22:40 <lambdabot> I know nothing about fold.
08:22:48 <rvxi> mauke: lol
08:22:50 <CaptainSandwich> hey, i have trouble diagnosing the problem i have with stack on windows. i can't compile/install any packages, always throwing an error like http://lpaste.net/146108.
08:23:48 <int-index> How do I use `makeLenses` with a `data instance`? `declareLenses` work, but not for recursive types
08:24:18 <rvxi> even toy examples I have to think about, like, fibs = 1 : scanl (+) fibs
08:26:36 <quchen> rvxi: That's not a toy example.
08:26:50 <quchen> rvxi: It's short and uses a special property of the Fibonacci numbers that's not immediately obvious.
08:27:20 <hodapp> quchen: what property's that?
08:27:37 <rvxi> quchen: well that's comforting :) still is the first example in this book though
08:27:50 <mauke> > scanl f z [a, b, c, d]
08:27:52 <lambdabot>  [z,f z a,f (f z a) b,f (f (f z a) b) c,f (f (f (f z a) b) c) d]
08:27:58 <c_wraith> seems like the only property it depends on is f n = f (n - 1) + f (n - 2)
08:28:33 <mauke> it's a trace of the foldl values as you go through the list
08:28:44 <quchen> Σ [F_1 … F_n] + 1 = F_(n+2) -- hodapp, rvxi  
08:29:00 <quchen>  https://upload.wikimedia.org/math/0/f/3/0f334d25d675c071d32d071b923be90b.png
08:29:27 <c_wraith> quchen: isn't that just.. restating the definition a bit?
08:29:40 <hodapp> restating a definition can still make for non-obvious properties
08:29:46 <quchen> c_wraith: Not more than any theorem restates the axioms a bit ;-)
08:29:56 <hodapp> a whole lot of math is just 'restating the definition a bit' :P
08:30:27 <quchen> c_wraith: Quick, where's the offset of 1 from
08:30:51 <c_wraith> It's F_0
08:30:55 <c_wraith> :P
08:31:28 <quchen> F_0 is 0 in the definition used there
08:31:39 <quchen> https://en.wikipedia.org/wiki/Fibonacci_number
08:31:43 <quchen> At least if the article is consistent
08:32:18 <rvxi> scans and folds are already sort of like  syntactic sugar for recursion, the two layers of recursion is hard for me to think about..
08:32:55 <c_wraith> rvxi: they're something more (or less) than syntactic sugar - they intentionally restrict possible behavior.
08:33:07 <c_wraith> rvxi: they're an application of the principle of least power.
08:33:09 <mauke> > foldl (+) 0 []
08:33:11 <lambdabot>  0
08:34:28 <c_wraith> rvxi: The principle of least power is really important for quickly understanding code.  If you see a construct using arbitrary recursion (or fix, which is the same thing), it requires much closer reading than a function using a fold.
08:34:50 <rvxi> c_wraith ok i'm fine with that and i definitely buy that principle
08:35:03 <c_wraith> rvxi: then it's just a matter of practice. :)
08:35:22 <rvxi> c_wraith still find it hard to reason when there's recursive call within a scan though
08:35:27 <c_wraith> > fix $ (0:) . scanl 1 (+)
08:35:29 <lambdabot>      No instance for (Typeable a0)
08:35:29 <lambdabot>        arising from a use of ‘show_M30800438462933349312007’
08:35:29 <lambdabot>      In the expression:
08:35:36 <mauke> function first
08:35:45 <c_wraith> pfft, 1 is totally a function
08:35:48 <c_wraith> > fix $ (0:) . scanl (+) 1
08:35:50 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:36:05 <hodapp> I need to get better about applying that 'principle of least power' thing when it comes to recursion...
08:36:07 <c_wraith> There.  I factored the recursion out via a function that's.. exactly as powerful as recursion.
08:38:21 <c_wraith> rvxi: don't worry, it's actually hard even with practice.
08:39:30 <rvxi> is it true that foldl = foldr iff the function is commutative?
08:39:40 <c_wraith> denotationally, yes
08:39:55 <exio4> modulo infinite lists :P 
08:40:10 <c_wraith> Operationally, the two functions can have vastly different runtimes
08:41:00 <c_wraith> rvxi: sometimes, code is just *$&#ing complicated even if it's short.  :)
08:41:07 <rvxi> ok that was my intuition but i haven't seen it made explicit in tutorials..
08:41:09 <c_wraith> rvxi: I wrote http://lpaste.net/102101 and I don't understand it anymore. :)
08:42:04 <c_wraith> rvxi: err.  http://lpaste.net/revision/114261 is the correct version.
08:43:26 <rvxi> c_wraith that's comforting. working through chris's book. i've already done most of cis194, so I breezed through chapters 1-8 but chapters 9-10 (lists and folding) are a bit slower.
08:44:34 <c_wraith> rvxi: here's my favorite example for understanding foldr...   foldr (\c r -> if c == ' ' and null r then "" else c : r) ""
08:44:56 <c_wraith> rvxi: That has a lot of subtlety in it.  :)
08:46:35 <c_wraith> err.  It also has a type error
08:46:57 <c_wraith> :t foldr (\c r -> if c == ' ' && null r then "" else c : r) "" -- rvxi
08:46:58 <lambdabot> Foldable t => t Char -> [Char]
08:49:10 <Octophore> are the sets of branches ordered in a rose tree?
08:52:21 <rvxi> huh that's weird
08:53:06 <rvxi> not sure how that works. seems like you'd hit the else case for whitespace since the null r condition isn't satisfied.
08:53:09 <rvxi> c_wraith
08:53:48 <c_wraith> rvxi: it depends on the laziness of &&
08:54:15 <c_wraith> rvxi: most notably that foldr is as lazy as possible for that function.  It works fine on infinite lists, so long as all strings of spaces are finite.
08:54:52 <rvxi> c_wraith ahh that's kindof terrifying.
08:55:25 <c_wraith> rvxi: I spent a couple months thinking about that example every now and then.  I eventually understood it. :)
08:56:44 <rvxi> c_wraith but i'm trying to see how the laziness matters. say i have "as__ "
08:57:01 <rvxi> (two spaces at the end ... something about my irc client isn't letting me do space space quote)
08:57:25 <c_wraith> > foldr (\c r -> if c == ' ' && null r then "" else c : r) "" (cycle "1 2 ")
08:57:27 <lambdabot>  "1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2...
08:57:53 <c_wraith> rvxi: if && wasn't lazy, that example wouldn't work.
08:58:17 <rvxi> hm maybee i'll come back to this example later when i can wrap my head around easier examples
09:13:57 * hackagebot language-lua 0.8.1 - Lua parser and pretty-printer  https://hackage.haskell.org/package/language-lua-0.8.1 (OmerAgacan)
09:14:01 <tobiasBora> It's not possible to write something like :
09:14:03 <tobiasBora> ghci> let f a b = a+b
09:14:05 <tobiasBora> ghci> let g a b = a*b
09:14:07 <tobiasBora> ghci> let h = f + g
09:14:13 <tobiasBora> without explicitly write :
09:14:24 <tobiasBora> let h a b = (f a b) + (g a b) ?
09:15:23 <Clint> @pl \a b -> (f a b) + (g a b)
09:15:23 <lambdabot> ap (ap . ((+) .) . f) g
09:17:34 <Ankhers> What package should I be using for parsing CSV data?
09:18:56 <cow_2001> Ankhers: good question! you might find something good with conduit-csv (or is it csv-conduit?)
09:19:24 <Ankhers> cow_2001: Thanks. I will take a look.
09:19:31 <cow_2001> Ankhers: please tell me how it went
09:19:44 <Ankhers> Will do.
09:19:44 <cow_2001> Ankhers: i have to deal with CSV as well
09:21:20 <rvxi> i deal with CSVs too
09:21:54 <rvxi> ankhers cow_2001 i'm still trying to figure out the right substitute for pandas/data frame workflows
09:22:09 <cow_2001> omg ikr?!
09:22:13 <Ankhers> pandas?
09:22:31 <cow_2001> it's a python library
09:22:41 <Ankhers> ah. I didn't really use python.
09:22:48 <cow_2001> deals with tables
09:23:14 <rvxi> i've done mostly r and some python
09:23:20 <rvxi> cow_2001 i've heard good things about Frames
09:23:46 <rvxi> cow_2001 it seems a bit heavyweight with the template haskell usage, but maybe it's worth it
09:24:34 <rvxi> cow_2001 unfortunately there's not that much documentation on it either
09:25:32 <hodapp> rvxi: I've been wanting to migrate some of my NumPy/SciPy usage into Haskell too; I've used Pandas but not much
09:25:37 <hodapp> I need to learn HaskellR
09:26:15 <rvxi> hodapp: i think we're in a similar boat. i've got haskellR up and running but haven't done much beyond that. also tried rlang-qq but that seems like more of a band-aid
09:28:40 <rvxi> i use dplyr a lot in R. it's probably not the be-all-end-all, but there has to be a good way to handle these  use ases in haskell
09:28:56 <rvxi> cases
09:29:01 <hodapp> in my case it's just lack of effort
09:29:07 <hodapp> I was using NumPy/OpenCV in Python for a class
09:29:37 <rvxi> yeah
09:29:43 <rvxi> + the massive ecosystem is convenient
09:29:47 <hodapp> and a little bit of matplotlib, Pandas, NumPy, and SciPy for some analysis at work
09:30:07 <rvxi> yeah that sounds familiar
09:30:39 <rvxi> i think haskell makes for a better glue code language than python, but the bindings/ecosystem have a ways to go.
09:31:16 <hodapp> Python definitely seems to be a decent glue language but I've not really tried to do it in Python
09:31:33 <rvxi> solution seems to be either to co-opt (as in haskellR) or build from scratch (numerical haskell)
09:31:51 <hodapp> http://www.renci.org/wp-content/pub/tutorials/BeautifulCode.pdf is however a good write-up on using Haskell here
09:32:10 <rvxi> hodapp: i think python (and R for that matter)  _seems_ like a good glue language at first glance, but I think it's ultimately a bad thing for the field
09:32:48 <hodapp> er, rather, I've not tried to do it in *Haskell*, not Python
09:33:29 <rvxi> there are some fundamental flaws in how data science is practiced http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43146.pdf and i think a big part of that is because of these glue code architectures people do in python and R
09:33:40 * hodapp reads...
09:34:04 <lpaste> d-snp pasted “how to debug” at http://lpaste.net/146117
09:34:21 <d-snp> hey guys, I just made something buggy
09:34:25 <d-snp> in pure code
09:34:45 <d-snp> I bet I could find the bug if I tried, but I wonder what the right debugging strategy in general is for something like this
09:35:02 <d-snp> I expect there to be a long ass list putted to the console, instead, nothing at all
09:35:09 <d-snp> so dependantStrings is empty
09:35:25 <d-snp> what'd you do?
09:35:33 <hodapp> has it any sub-functions you may inspect separately?
09:36:03 <d-snp> yeah, buildDependantsCounts, it has some private sub functions as well
09:36:46 <hodapp> you may want to see about pulling those out, if possible, to test separately
09:36:49 <monochrom> does dependantsCounts have the content you want?
09:36:55 <singpolyma> I have an intentional infinite loop in IO (it's a thread that blocks reading a TChan, does something, and then continues) however if it goes through a pass without changing the state at all, then GHC throws <<loop>> at me...
09:37:29 <rvxi> hodapp: i've seen that beautifulcode thing. seems out of date though (would be nice to see a newer version with gpipe)
09:38:01 <monochrom> (and that would be the first question I would ask myself, if I wrote that code. hell, if I wrote that code, I would ask that question way earlier.)
09:38:11 <d-snp> monochrom: Got dependantsCounts: fromList []
09:38:17 <d-snp> so no, it seems to be empty
09:38:46 <d-snp> so you'd go back and look at every intermediate step
09:38:53 <d-snp> perhaps using Debug.Trace?
09:39:23 <monochrom> inside buildDependantsCounts, I would ask "does packages have the content I want?" etc
09:40:28 <monochrom> "how do *you* debug your Haskell code?" is a frequently asked question.
09:40:44 <monochrom> today I think I finally know how to articulate how I have always done it.
09:40:48 <hodapp> I have on occasion used Debug.Trace but it's rare I've needed it
09:41:48 <monochrom> every time I add a subexpression, I debug that immediately. so it's almost trivial. I don't wait until I have finished 100 lines, even 10 lines, before starting to debug.
09:41:50 <quchen> Mostly I just look at the code.
09:42:32 <monochrom> someone should coin a fancy name like Continuous Debugging (CD) for what I do
09:42:43 <hodapp> monochrom :P
09:42:53 <monochrom> and make it sound like a big deal like "best practice" etc
09:42:53 <d-snp> ok, I'm gonna find the bug, I'll report back in a minute :P
09:43:00 <cite-reader> REPL-driven development? That's close anyway.
09:43:10 <hodapp> "dependency injection"
09:43:17 <Jello_Raptor> hmm, is there a haskell datastructure that can map multiple (distinct) keys to specific values? 
09:43:17 <hodapp> cite-reader: you need to throw the word "dynamic" in there at least twice
09:43:20 <hodapp> none of this REPL crap
09:43:33 <quchen> Jello_Raptor: A Map?
09:43:47 <quchen> A Bimap if you want to be able to remove values
09:44:23 <Jello_Raptor> quchen: with the caveat that I can choose to change a value for every key which points to it, or for just one specific key
09:45:26 <Jello_Raptor> somethin with the semantics of `Map [k] v` but with search functions for individual keys in the list 
09:45:28 <quchen> Wait, that bimap suggestion was nonsense
09:45:45 <quchen> Map (Set k) v?
09:46:34 <Jello_Raptor> quchen: yeah, but if there's something which does the wrapping or provides the utility functions without me having to redefine them 
09:47:17 <d-snp> alright, seems like dependencies are always empty
09:48:02 <singpolyma> this is a simplified example of my problem: http://lpaste.net/146119
09:49:54 <singpolyma> I have used this pattern before, but never had it throw NonTermination at me before
09:50:43 <singpolyma> I guess I could use forever with StateT, but I shouldn't have to :P
09:50:46 <d-snp> ok seems like my code was correct in spirit, but the contract is not what I expected, buildDepends is always empty, instead the dependencies are located somewhere else in the object
09:50:49 <monochrom> it's likely you have elided away the cause
09:51:16 <singpolyma> monochrom: I can paste the whole, it's not too long
09:52:17 <singpolyma> http://lpaste.net/146122
09:52:34 <monochrom> is there any thread that writes to some?
09:53:22 <singpolyma> monochrom: yeah, two different threads.  one that writes a TimerExpire every second, and another that writes actual data
09:53:45 <singpolyma> the NonTermination is throwing on the second time a TimerExpire comes through when no data has come in yet
09:54:55 <singpolyma> I can see how passing the same argument would look like a NonTermination, but it's all in IO... other things can happen depending on what comes in the TChan
09:55:05 <monochrom> you have a binding that goes as, under a suitable circumstance, "let (done, cont) = (mempty, cont)", or rather, "let cont = cont"
09:55:30 <singpolyma> monochrom: oh.  good catch
09:55:46 <singpolyma> that's a typo, and probably my issue
09:55:48 <singpolyma> thanks
09:57:33 <singpolyma> monochrom: working now, thanks!
09:58:20 <monochrom> you're welcome
10:05:28 <CaptainSandwich> "Setting codepage to UTF-8 (65001) to ensure correct output from GHC
10:05:31 <CaptainSandwich> sorry
10:06:14 <CaptainSandwich> can someone help me with this: http://lpaste.net/146124 ? I dont know why i suddenly cant build any packages anymore.
10:32:56 <tobiasBora> Clint: Thank you. Well it's not really clearer like that, and it still depends on the number of arguments ^^ Well I'll keep using variables.
10:33:17 <tobiasBora> @pl \a b c -> (f a b c) + (g a b c)
10:33:17 <lambdabot> ap (ap . (liftM2 (+) .) . f) g
10:33:34 <tobiasBora> @pl \a b c d -> (f a b c d) + (g a b c d)
10:33:34 <lambdabot> ap (ap . (liftM2 (liftM2 (+)) .) . f) g
10:35:24 <pavolzetor> what would you use to store pixels which can be mutated? Array.ST?
10:38:24 <happyfeet> any1 knows how to solve this error I am getting when i use ghci (related to Gloss): http://lpaste.net/4360391029581414400
10:39:38 <happyfeet> i really do not have any idea why it happens
11:09:00 * hackagebot exact-pi 0.4.1.0 - Exact rational multiples of pi (and integer powers of pi)  https://hackage.haskell.org/package/exact-pi-0.4.1.0 (dmcclean)
11:39:01 * hackagebot event 0.1.3 - Monoidal, monadic and first-class events  https://hackage.haskell.org/package/event-0.1.3 (DimitriSabadie)
11:40:51 <hsk3> Is anyone writing a new Haskell book? Like a sequel to LYAH, but something more recent and better than Real World Haskell (which is just painful).
11:41:00 <hsk3> Step 1: Write that book. Step 2: Profit.
11:42:21 <hodapp> bitemyapp is writing a Haskell book.
11:42:46 <hsk3> cool
11:42:46 <hsk3> bitemyapp: got info on that?
11:44:07 <demize> hsk3: http://haskellbook.com/
11:45:25 <hsk3> Looks sort of like an alternative to LYAH. Not a more advanced sequel type of thing.
11:45:25 <hsk3> But I love the idea! I always like learning the same things from a different perspective. Always learn something new!
11:49:41 <ozzloy> i just used cabal install shellcheck and then tried shellcheck, but i get "bash: shellcheck: command not found".  where did shellcheck go?
11:50:16 <lspitzner> ozzloy: ~/.cabal/bin/shellcheck, probably
11:56:50 <ozzloy> cool, is it customary to add ~/.cabal/bin/ to path?
11:57:05 <ozzloy> lspitzner, thanks!
11:57:30 <lspitzner> ozzloy: yes
11:59:17 <lspitzner> ozzloy: most people run into this when they upgrade by `cabal install cabal-install`ing and wonder why `cabal` still is still old version (because new one not on path :)
12:00:07 <sm> stack does well here, by checking $PATH and warning after an install
12:01:24 <ozzloy> what about ln -s ~/bin ~/.cabal/bin ?
12:02:13 <alexeyzab1> hsk3: glad I am not the only who thinks Real World Haskell is painful
12:02:42 <hsk3> alexeyzab1: :)
12:03:19 <hsk3> i really tried to like it, but after spending too much time on a fucking JSON interpreter you get pissed off
12:03:31 <hsk3> (that chapter was a mess)
12:03:48 <alexeyzab1> i bet
12:03:50 <hsk3> LYAH is the best book ever
12:04:00 <alexeyzab1> Yeah, LYAH is quite enjoyable
12:04:53 <alexeyzab1> I am still going through upenn cs194 and every time I read a recommended reading chapter of RW Haskell I get nauseous
12:05:06 <hsk3> hehe
12:05:37 <hsk3> the sad thing is that it has so much info i wanna learn about! if only someone would take that same info and package it more nicely!!
12:05:43 <hsk3> lots of info there that LYAH doesn't have
12:05:47 <alexeyzab1> But at the same time I feel like if I skip it I will have problems later on
12:05:51 <alexeyzab1> Exactly
12:06:04 <alexeyzab1> If only it didn't feel so...ugh
12:06:35 <alexeyzab1> I bet it's the beetle on the cover that's doing this
12:06:45 <alexeyzab1> Damn you, O'Reilly
12:07:49 <hsk3> :)
12:24:32 * hackagebot mdapi 1 - Haskell interface to Fedora's mdapi  https://hackage.haskell.org/package/mdapi-1 (RickyElrod)
12:26:33 <monochrom> research shows that putting perfume on a Haskell book increases sale by 29%
12:26:59 <alexeyzab1> does the kind of perfume matter?
12:27:20 <monochrom> more funding is needed for that followup research
12:27:27 <alexeyzab1> as always
12:29:37 <mniip> monochrom, are you sure you aren't looking at the correlation in the wrong way?
12:29:48 <mniip> maybe it's sales that cause perfume?
12:33:13 <monochrom> sure, the perfume is there before purchase happens
12:34:00 <monochrom> research shows that a time machine would uproot all causality arguments based on chronology
12:36:35 <Profpatsch> Again somewhat basic stuff, but how to Integer -> Text?
12:37:06 <Profpatsch> There has to be something better than pack.show
12:37:46 <Profpatsch> Or is there some nice printf Syntax that outputs Text?
12:40:16 <Profpatsch> Hm, formatting looks good.
12:40:22 <johnw> what kind of "better" do you want?
12:40:52 <monochrom> I only know of Data.Text.Lazy.Builder.Int. but then you may not want Lazy or Builder
12:41:13 <Profpatsch> johnw: I dunno, that looks kind of like a hack. Why go over String?
12:41:27 <johnw> Profpatsch: define intToText = pack . show, and don't think about it
12:41:37 <johnw> when it becomes a problem, think about it :)
12:41:52 <Profpatsch> johnw: Mkay. :)
12:42:13 <Profpatsch> I’m still searching for a Haskell editor that does automatic imports.
12:42:27 <Profpatsch> Of the kind where it asks when a function is ambiguous.
12:42:43 <johnw> ghc-mod will let you auto-import when it can't find a function
12:42:58 <johnw> i.e., it suggests a list of candidate module names, and then inserts the "import" for you
12:42:59 <Profpatsch> And that searches in my cabal file for dependencies. And from a list of often-used libraries.
12:43:27 <Profpatsch> johnw: Hm, does ghc-mod work on Nixos? I think it didn’t some months ago.
12:43:48 <Profpatsch> I have high hopes for that IDE backend project.
12:44:12 <johnw> I don't know, it breaks too often for me to keep up with its present status
12:49:33 * hackagebot benchpress 0.2.2.7 - Micro-benchmarking with detailed statistics.  https://hackage.haskell.org/package/benchpress-0.2.2.7 (willsewell)
12:49:59 <Profpatsch> Ah, nice, ghc-mode works with nixos now.
12:57:53 <segfaulthunter> hi! i have written a thing (theorem prover) and want to support two different logics. to switch from one to the other i need to change two functions of many used in the computation, and plumbing them through all function calls seems a bit silly. is there any recommended way of doing that?
12:59:34 * hackagebot safecopy 0.9.0.1 - Binary serialization with version control.  https://hackage.haskell.org/package/safecopy-0.9.0.1 (JeremyShaw)
13:07:41 <mauke> segfaulthunter: I haven't used it myself, but your question reminds me of a paper I read: http://okmij.org/ftp/Haskell/tr-15-04.pdf
13:08:24 <mauke> see also https://www.fpcomplete.com/user/thoughtpolice/using-reflection , which is an introduction to the reflection package (which implements the ideas from that paper)
13:08:24 <segfaulthunter> i was thinking of the thing in lisp where you can locally override the global context, but that does not seem to exist
13:08:32 <segfaulthunter> cool, will look
13:08:58 <mauke> warning: we're going to teleport values through the type system
13:09:11 <segfaulthunter> what's the worst that could happen?
13:09:34 * hackagebot acid-state 0.14.0 - Add ACID guarantees to any serializable Haskell data structure.  https://hackage.haskell.org/package/acid-state-0.14.0 (JeremyShaw)
13:14:26 <Profpatsch> segfaulthunter: How about a simple Reader monad?
13:15:25 <Profpatsch> Or representing our computation as a deep, typed datastructure and using lenses to exchange parts on demand?
13:15:31 <Profpatsch> *your
13:15:45 <Profpatsch> there’s something under my 'y' key~
13:17:16 <Profpatsch> e.g. you build your proofs not out of functions, but out of data types which you then evaluate in a second step.
13:17:25 <Profpatsch> And you can use different logics to evaluate it
13:17:36 <Profpatsch> Would be my take.
13:24:34 * hackagebot file-modules 0.1.1.0 - Takes a Haskell source-code file and outputs its modules.  https://hackage.haskell.org/package/file-modules-0.1.1.0 (yamadapc)
13:25:30 <fractalsea> An a library I want to check the user supplies a positive Int in an argument of a function that returns an IO action. What should I do if the user supplies a zero or negative Int? I wont’ want to return a Maybe value, so should I use `error`, `throwIO` or `fail`, or is there something nicer?
13:27:01 <zachk> fractalsea: you could use a condtional statement and just return Nothing or a<-IO action ; return (Just a)
13:27:28 <exio4> fractalsea: you might want to use a Word instead of an Int
13:27:31 <mauke> if passing a negative argument indicates a bug in the caller, I'd probably use error
13:28:44 <fractalsea> zachk, I would really rather not use Maybe because it’s annoying for the caller having to handle it since they “know” the input is correct (basically just a config value)
13:28:54 <fractalsea> exio4, true although it doesn’t help with 0
13:29:14 <exio4> oh, right
13:29:15 <fractalsea> mauke, hmm OK; is there any reason that is prederable to throwIO?
13:29:29 <zachk> yea if you know it's correct then just use error "this should never happen"
13:29:42 <fractalsea> exio4, but yes I agree it would be great to have it compiler checked, but I want to stick to standard types.
13:29:55 <exio4> fractalsea: if it is in IO, you might want to make your own exception (if it is a `possible` situation), if it is not, error "the impossible happened"
13:30:06 <fractalsea> zachk, OK, that seems to be the consensus :)
13:30:56 <mauke> fractalsea: throwIO would build a "real" IO action, just one that throws an exception when executed
13:31:05 <mauke> error just goes "screw you"
13:31:18 <fractalsea> exio4, it is in IO so that’s a possibility
13:31:27 <segfaulthunter> thanks will look into these things
13:31:31 <fractalsea> mauke, I see
13:31:39 <zachk> would error terminate the whole program, or just the thread it's called in?
13:32:22 <fractalsea> Thanks for your help all
13:32:44 <zachk> not a problem :D
13:33:33 <mauke> zachk: thread, I think
13:33:36 <mauke> @src error
13:33:36 <lambdabot> error s = throw (ErrorCall s)
13:34:00 <mauke> @src exitWith
13:34:01 <lambdabot> Source not found. Are you on drugs?
13:35:05 <DigitalKiwi> is learnyouahaskell a good choice
13:35:51 <mauke> some people say no. I think they recommend instead:
13:35:52 <mauke> @where learn
13:35:53 <lambdabot> https://github.com/bitemyapp/learnhaskell | http://www.seas.upenn.edu/%7Ecis194/spring13/index.html | https://github.com/NICTA/course/
13:38:32 <DigitalKiwi> huh
13:38:41 <DigitalKiwi> I know about the NICTA one but the others are new
13:38:42 <DigitalKiwi> thanks
13:42:03 <ga2arch> hi, are there any known problems about using the HashTable inside the hashtables package, inside the stm monad exploiting unsafeIOToSTM for stuff like insertion, lookup and deletion ?   
13:44:02 <ga2arch> insertion, lookup and deletion "should" be idempotent for an hashtable right ?
13:45:17 * hackagebot file-modules 0.1.2.0 - Takes a Haskell source-code file and outputs its modules.  https://hackage.haskell.org/package/file-modules-0.1.2.0 (yamadapc)
13:50:17 * hackagebot file-modules 0.1.2.1 - Takes a Haskell source-code file and outputs its modules.  https://hackage.haskell.org/package/file-modules-0.1.2.1 (yamadapc)
13:55:17 * hackagebot package-description-remote 0.1.1.1 - Fetches a 'GenericPackageDescription' from Hackage  https://hackage.haskell.org/package/package-description-remote-0.1.1.1 (yamadapc)
14:00:18 * hackagebot package-description-remote 0.2.0.0 - Fetches a 'GenericPackageDescription' from Hackage  https://hackage.haskell.org/package/package-description-remote-0.2.0.0 (yamadapc)
14:00:37 <segfaulthunter> Profpatsch, hm, that also sounds a bit complicated
14:17:00 <testetest> hello
14:19:22 <lethjakman-l> So, I have a unix timestamp that seems to be in 1/1,000,000 second format. Does anyone know how to parse that using Data.Time.Format?
14:20:31 <hpc> as in millionths of seconds since 1970?
14:20:39 <hpc> what an odd format
14:20:50 <lethjakman-l> hpc: I think that's the format. And I agree. 
14:20:54 <lethjakman-l> Maybe it's not...
14:20:56 <lethjakman-l> 1413734565550047
14:21:00 <lethjakman-l> That's the time. 
14:21:12 <hpc> my gut reaction would be to quotRem and do something with the pair
14:21:23 <lethjakman-l> I got it from a google api, and that seems to be what it is, but I'm not positive that's correct. 
14:21:31 <hpc> :t quotRem
14:21:32 <lambdabot> Integral a => a -> a -> (a, a)
14:22:10 <lethjakman-l> What is that?
14:27:00 <thimoteus> > quotRem 15 2
14:27:02 <lambdabot>  (7,1)
14:28:21 <hpc> lethjakman-l: quotient-remainder
14:28:56 <hpc> the platonic ideal of integer division
14:33:16 <lethjakman-l> How do you convert a Int to a [Char]?
14:33:56 <geekosaur> erm. do you mean digits, or a binary representation?
14:34:32 <geekosaur> show for the first, see Data.BInary for the second (but I think that gets you a ByteString, which is more correct than [Char])
14:37:08 <lethjakman-l> geekosaur: I have a Int from quotRem that I need to be a [Char] for parseTimeOrError
14:37:23 <geekosaur> then you probably want show
14:37:38 <geekosaur> > show 1774283
14:37:40 <lambdabot>  "1774283"
14:38:35 <lethjakman-l> Ahhh, I always forget about that. 
14:38:39 <lethjakman-l> Is there a better name for show?
14:38:50 <Clint> a better name?
14:39:10 <lethjakman-l> I find the name "show" unintuitive since I'm usually using it to convert to a [Char]
14:39:14 <lethjakman-l> Or...I'm misunderstanding something
14:39:18 <animated> i’m looking for a Haskell tutor in the Pacific Time Zone - anyone know where I coud find one? 
14:39:50 <Clint> lethjakman-l: you'd prefer representAsString?
14:39:58 <lethjakman-l> toString maybe
14:40:26 <Clint> toString is used by other things
14:40:45 <lethjakman-l> Gotcha
14:40:58 <geekosaur> you do know that [Char] is exactly the same as String?
14:40:58 <lethjakman-l> Just a thought. 
14:41:03 <lethjakman-l> Yes
14:41:10 <lethjakman-l> I used to do a bit of C++, I'm assuming it's similar. 
14:41:15 <lethjakman-l> ?
14:41:55 <hpc> i think you're confused
14:42:04 <hpc> in C++, char* and string are different
14:42:04 <lethjakman-l> Ok. What am I confused about?
14:42:11 <hpc> in haskell, [Char] and String are the same type
14:42:19 <lethjakman-l> Oh. 
14:42:20 <hpc> String is an alias
14:42:31 <lethjakman-l> That makes sense. 
14:42:40 <rcyr> See String as a typedef for a char[] :P
14:42:42 <lethjakman-l> Maybe I'm remembering wrong. 
14:43:09 <geekosaur> I'm not sure what the confusion here is either...
14:44:01 <hpc> geekosaur: i read one of the lines above as C++ having a string type that's an alias for char list (which isn't the case
14:44:25 <geekosaur> I meant lethjakman-l's confustion that made show look like the wrong thiong
14:44:31 <geekosaur> *confusion, wrong thing
14:44:35 <geekosaur> sigh, typing
14:44:49 <lethjakman-l> I just always forget to use show to convert things to string is all. 
14:44:57 * geekosaur managed to write that as "typoing" at first, which was apropos >.>
14:45:06 <lethjakman-l> hpc: You're right, String is a class that wraps char []
14:45:41 <lethjakman-l> It makes sense that String is a typedef of char[]
14:45:43 <lethjakman-l> Thank you. 
14:46:31 <hpc> lethjakman-l: yeah, just making sure because messing up one of the "first" concepts will alter your understanding of the entire rest of the language ;)
14:47:55 <lethjakman-l> hpc: Thanks :)
14:49:40 <demize> (Except that it's a singly linked list instead of an array)
14:49:43 <lethjakman-l> So, is using where vs let more of a personal preference, or is there a place where you should use where vs let?
14:50:14 <lethjakman-l> Because I think I tend to prefer where, but I'm not sure if that's a bad practice. 
14:50:17 <hpc> lethjakman-l: mostly personal preference, and there's a bit of an art to it
14:50:54 <hpc> let-in puts definitions first, which works nicely when they're just as important as what's in the in-clause
14:51:06 <hpc> where puts definitions at the bottom, so it draws attention to how they're used
14:51:16 <hpc> ideal use of where would be
14:51:27 <hpc> foo = some very easy to read thing where definitions
14:51:37 <rvx1> is there a good way to "see" how folds can be used to enumerate combinations?
14:51:44 <hpc> so you see the big picture, then drill down on lower lines
14:52:01 <lethjakman-l> hpc: I think I've come to like that style more than the let-in style. 
14:53:09 <rvx1> working on this exercise of writing a fold function that enumerates all 3 letter combinations form two sets of letters
14:56:44 <lethjakman-l> Ok, this is probably me not remembering what to google, but isn't there a way to comma separate numbers or something?
14:56:48 <lethjakman-l> Like 1,000,000?
14:58:43 <hpc> probably printf
14:59:41 <mauke> I don't think printf can do that
15:00:38 <mgsloan> sum (zipWith (*) (map (10^) [0,3..]) (reverse (Data.Generics.Schemes.listify (const True :: Integer -> Bool) (1,000,000))))
15:00:39 <mauke> I'd expect to find that operation in some locale library because conventions differ so much
15:07:34 <athan> Is there a Setup.hs generator? Or is it supposed to be more technically involved?
15:08:46 <mauke> ... generator? it's just a static file for most libraries
15:09:09 <athan> mauke: I'm just not sure what it should do entirely, it looks something like a build script
15:10:20 * hackagebot wai-middleware-content-type 0.0.3.3 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.0.3.3 (athanclark)
15:10:23 <mauke> oh, interesting. there's a "cabal init" command that generates it for you
15:11:51 <mauke> Setup.hs: import Distribution.Simple; main = defaultMain
15:12:06 <mauke> https://www.haskell.org/cabal/users-guide/
15:24:42 <rvx1> how can i express this: myZip x y = (head x, head y) : (myZip (tail x) (tail y))
15:24:47 <rvx1> using x:xs y:ys ?
15:24:56 <rvx1> seem to be getting some parser errors when i try to do it
15:25:33 <geekosaur> (x:xs) (y:ys)
15:26:44 <rvx1> that works, I guess : precedence was too low
15:27:33 <geekosaur> it has the same precedence it does in expressions, where x:xs y:ys would mean [x,(xs y),ys]
15:29:00 <mauke> rather, myZip x : xs y : ys parses as (myZip x) : ((xs y) : ys)
15:29:09 <mauke> this is why I put spaces around :
15:31:49 <larion>  /topic
15:32:59 <larion> oops sry :)
15:35:23 <rvx1> ok here's my solutions http://lpaste.net/146129
15:50:43 <j_e}o_0[W\-> ohai
15:51:04 <rvx1> hi j_e}o_0[W\-
15:51:30 <j_e}o_0[W\-> I wanna write a simple haskell script, that when run from the source directory prints version from .cabal file in it.
15:51:37 <j_e}o_0[W\-> whats the best way to do that?
15:52:04 <j_e}o_0[W\-> by script I mean a file with #!/usr/bin/runhaskell as the first line
15:56:02 <hexagoxel> j_e}o_0[W\-: why do you need that?
15:56:27 <j_e}o_0[W\-> hexagoxel: to use as an rpm package version
15:56:44 <j_e}o_0[W\-> I don't wanna manually enter the version in two different places
15:57:30 <j_e}o_0[W\-> the idea to use grep and cut occured to me, yes
15:57:44 <hexagoxel> j_e}o_0[W\-: do you have the package compiled at that point?
15:58:01 <hexagoxel> because there is the auto-generated Paths_.. module containing the version
15:58:13 <j_e}o_0[W\-> hexagoxel: yup, thought about that already
15:58:20 <j_e}o_0[W\-> but this approach doesn't work
15:58:52 <hexagoxel> j_e}o_0[W\-: otherwise i guess there is the Cabal interface
15:58:54 <j_e}o_0[W\-> i want to pass the version parameter to rpmbuild, which then reads the rpm spec file and calls cabal
16:00:22 <j_e}o_0[W\-> hexagoxel: do you mean cabal-the-library?
16:00:30 <hexagoxel> j_e}o_0[W\-: yes. maybe https://github.com/haskell/cabal/blob/master/Cabal/Distribution/PackageDescription/Parse.hs#L567
16:02:17 <j_e}o_0[W\-> yup, that seems to be it
16:02:20 <j_e}o_0[W\-> thanks, hexagoxel 
16:02:54 <hexagoxel> j_e}o_0[W\-: sorry for questioning the exact requirements :p
16:20:52 * hackagebot wai-middleware-content-type 0.0.4 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.0.4 (athanclark)
16:37:32 <athan> Is there a `traverse` for Alternative, like `asum . fmap f`?
17:27:05 <Xeironis_> I programmed a simple Game GUI in Haskell in OpenGL. Now I want the GameWorld to evolve independently from the GUI. Is calling the GUI with forkIO and then altering the world in the main thread the right way to go about this?
17:28:14 <Xeironis_> Apparently I'm so used to CamelCase now that I use it for normal words... -.-
17:31:12 <Arahael> Xeironis_: ThatIsACommonIssueWhyIsItAProblem? ;)
17:32:28 <Xeironis_> I didn't say it's a problem :p
17:32:48 <Arahael> +1 :)
17:33:02 <noodleman04> http://pastebin.com/Q6MpRc6j why is this giving me a parse error
17:34:25 <Xeironis_> noodleman04: you need parentheses around the p:ps
17:35:08 <Adeon> is there a library that slightly abstracts version numbers with sensisble Ord instances and some basic parsing
17:35:17 <Adeon> I don't need to parse existing versions
17:35:34 <noodleman04> right, thanks Xeironis_ 
17:36:56 <Cale> Adeon: well, there's http://hackage.haskell.org/package/Cabal-1.22.4.0/docs/Distribution-Version.html
17:37:03 <Cale> Adeon: might be overkill for what you want
17:37:22 <Adeon> yeah ideally it would be a super simple library
17:37:28 <Adeon> versioning is not exactly super complex
17:38:02 <Adeon> okay it can be complex when I look at the documentation of that file
17:45:19 <Adeon> I went for a simple (Int, Int) tuple
17:45:46 <Adeon> enough for what I need
17:56:22 * hackagebot file-modules 0.1.2.2 - Takes a Haskell source-code file and outputs its modules.  https://hackage.haskell.org/package/file-modules-0.1.2.2 (yamadapc)
18:22:25 <DarwinElf> I'm trying to install a Haskell program. It used to have no dependencies. Now it has about 14. on GNU/Linux (Slackware) I did 'cabal install' followed by the names of the dependencies. Then there was some output showing it seemed to have installed them. Then I did 'Setup configure' for the program Setup I had built, and it's still saying it doesn't have any of the dependencies. What did I do wrong?
18:22:49 <geekosaur> add --user
18:23:09 <geekosaur> cabal installs to the user db by default. running Setup manually only looks at global db by default
18:23:20 <geekosaur> alternatively, say "cabal install" without a package name
18:23:28 <geekosaur> (asusming it has a .cabal fuile)
18:25:14 <DarwinElf> the program is 'kevin' (IRC plug-in for deviantART.com chat) by pikajude on Github.com. Ok, I'll try what you said, though it's still not clear to me at this point... guess I'll have to read about cabal
18:25:28 <pikajude> oh, uh
18:25:29 <pikajude> hi
18:25:36 <pikajude> sorry, that package is super old
18:25:40 <DarwinElf> hi; are you still on deviantART?
18:25:45 <pikajude> no
18:25:47 <pikajude> was briefly
18:28:09 <DarwinElf> I did 'cabal --user install', then got a lot of output mentioning conflicts and ending with 'Backjump limit reached (change with --max-backjumps)'
18:28:30 <DarwinElf> well, 'cabal --user install' followed by dependencies, also the other option of just 'cabal install'
18:30:32 <geekosaur> for an old package that seems likely; it probably needs older versions of a bunch of things that just installed against newer versions
18:31:11 <DarwinElf> ok, I don't need Haskell for anything else; is there a way to force the older versions?
18:31:25 <arzig> so, I understand there is a definition for Monoid a => Monoid (Maybe a), but I seem to get counter-intuitive behavior out of things like Just 1 <> Just 2 == Just 2. What's happening?
18:33:39 <geekosaur> find an installer for an older ghc / platform?
18:34:21 <geekosaur> probably platform if "it used to have no dependencies"
18:37:48 <DarwinElf> I don't know what platform means in this case
18:38:02 <Adeon> how do I silence a warning about unused record field without putting underscore in front of it
18:38:04 <DarwinElf> but I'm going to compile an older ghc
18:40:33 <Adeon> I use the `Read` instance on it that I read from a file so GHC is actually wrong about it not being used
18:41:50 <ksf> stack fails on my box apparently because /run/user/<UID> has insufficient capacity to unpack the whole of ghc.
18:42:23 <ksf> leaving the question of whether 800M of ram aren't enough to map into there, how do I tell it to unpack somewhere else? like /tmp?
18:45:22 <geekosaur> try export TMPDIR=/some/big/dir
18:45:42 <DarwinElf> what happens to abandoned Haskell projects? I don't want to have to use webchat, but I might not have the knowledge to update the 'kevin' program if it needs updating
18:45:55 <ksf> hww is that supposed to be set to /run/user?
18:46:03 <geekosaur> generally they languish unless adopted by someone else
18:46:11 <ksf> I'm not up to date with all that newfangled stuff.
18:46:18 <geekosaur> ksf, I've seen that on some newer systems
18:46:38 <geekosaur> presumably some security thing
18:46:42 <demize> It's generally not set to anything at all.
18:47:14 <ksf> /tmp/stack-setup30192/ghc-7.10.2/configure: utils/ghc-pwd/dist-install/build/tmp/ghc-pwd-bindist: /bin/bash: bad interpreter: No such file or directory
18:47:21 <ksf> now we're getting into nixos territory.
18:47:55 <geekosaur> that one looks like it needs a newer glibc / ld-linux.so
18:48:09 <ksf> no, it needs /bin/bash.
18:48:29 <ksf> the only thing in my /bin is sh.
18:48:51 <geekosaur> well.
18:49:06 <ksf> WHICH IS 100% POSIX
18:49:30 <ksf> ...as there's also /usr/bin/env
18:49:35 <ksf> that's enough to find everything.
18:50:24 <geekosaur> I think you get to complain in #ghc about that one (or on ghc's trac)
18:50:56 <ksf> nixos just recently got native stackage support, I guess I should use that instead.
18:51:53 <gibbers> hey, so I'm learning haskell right now and I have a question. If strings are just lists of characters and lists are pretty much linked lists, wouldn't that be a waste of memory?
18:51:56 <ksf> geekosaur, the usual approach is to just patch the file, replacing interpreter paths (whether script or elf) is a thing nix does all the time.
18:52:37 <gibbers> that's at least 4 bytes to store like one char
18:52:54 <geekosaur> it's far more than 4 bytes...
18:52:58 <ksf> gibbers, not necessarily so (because the lists don't necessarily exist in memory), but there's libraries such as Text to use when it would be a waste.
18:53:08 <geekosaur> and yes, it's very inefficient. that said, fusion ca make the whole thing go away
18:54:05 <nh4clo4> What are prime functions? I'm having a hard time understanding them
18:54:11 <geekosaur> otherwise, the only thing it has going for it is convenience and that for sufficiently short strings it's probably got better actual performance than Text or ByteString due to higher overhead in those
18:55:56 <gibbers> if it's so inefficient, why make it the default handling of strings?
18:57:09 <ksf> oh, there seems to be another way: have the right ghc version installed so stack doesn't install its own.
18:57:44 <geekosaur> should I repeat the last thing I said? but I suspect the big reason is the sheer number of programs that would break if String were changed to be an alias for Text instead of for [Char]
18:58:06 <nitrix> Because it makes sense from a type-level point of view. [Char] for a String is perfectly well-reasoned and comes with overhead you'd imagine from it.
18:58:07 <geekosaur> that said, breaking everything possible seems to be a recent goal of the community so maybe you should propose it
18:59:51 <nitrix> I guess it could be a good opportunity to revisit `head` and other partial functions.
19:01:01 <nitrix> You'd need a strong and well reasoned proposal to pull it out, though.
19:05:52 <Lokathor> isn't there some name for weighted random distributions
19:06:03 <Lokathor> named after some mathimatican
19:06:32 <nitrix> The immediate problem that I see is that you cannot treat your string as an array. You loose on the generalization it offers, like take, head and such. On the other hand, if that's taken care of by a new function from the Text module, head could now return a Maybe without being too much a pain in the butt to use.
19:06:53 <gibbers> I was just curious, I figured there was a good reason but it wasn't obvious
19:07:50 <nitrix> gibbers: The short answer is "tradeoffs in usability".
19:09:34 <buckmaster> hey, really random question on documentation. Why is (>>=) defined with forall? https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html#v:-62--62--61-
19:10:20 <buckmaster> ugh, that trailing dash broke the link on my reader at least. Here's the source directly: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#%3E%3E%3D
19:16:17 <geekosaur> pedantry, I guess; it's redundant and it's clearly not using ScopedTypeVariables
19:17:42 <nitrix> buckmaster: I was suspecting ScopedTypeVariable was enabled but no, only ExplicitQuantification.
19:17:49 <buckmaster> that's what I figured... it made me :c a little bit because suddenly I had to check the source to see if something fancy was going on. I can't imagine what a beginner would do coming across that :p
19:18:15 <nitrix> Maybe it's an API guarantee that it wont break in the future?
19:20:39 <tosun> What's the best practice to fix an orphan instance?
19:21:31 <ksf> decide on whether to put the instance with the datatype or class.
19:21:41 <ksf> one of the two.
19:22:02 <ksf> also, I need more ram.
19:29:16 <bb010g> ksf: http://downloadmoreram.com
19:45:24 <Pamelloes> How does this work:
19:45:25 <Pamelloes> @pl \x -> f x (g x)
19:45:25 <lambdabot> ap f g
19:46:21 <athan> What would you call a function that does something like this: `(t -> Maybe a) -> [t] -> ([a],[t])`, where the result is the prefix of `[t]`s matched so far, and the rest that hasn't yet?
19:48:48 <buckmaster> @athan what do you mean
19:48:48 <lambdabot> Unknown command, try @list
19:48:53 <buckmaster> 'matched so far'?
19:49:01 <buckmaster> whoops, IRC syntax :p
19:51:00 <athan> buckmaster: Haha, well, something that appies a predicate to individual elements, and recursing naturally over the input list, we collect the successful results so far, appending to the right on that list
19:51:26 <athan> so it's a fold, but _until_ that predicate is falsified (or the whole list succeeds)
19:51:47 <buckmaster> oh, I see
19:52:00 <buckmaster> so it's sort of like a takeWhile
19:52:12 <emmanuel_erc> kTm?r257
19:52:20 <athan> buckmaster: Yeah exactly!
19:52:31 <buckmaster> takeWhileJustWithLeftovers? :p
19:52:54 <tzh> it sounds a lot like a `reads` where you specify the reading function. but probably `readWith` would be a pretty ambiguous name
19:53:02 <athan> :)
19:53:16 <athan> tzh: Ahh okay!
19:54:16 <buckmaster> it's also a bit like a split ;P
19:54:48 <tzh> athan: the difference being `reads` only parses a single thing and returns the unparsed suffix, whereas your function parses a bunch of things
19:55:32 <MarcelineVQ> you could call it parseMaybe :>
19:55:38 <athan> tzh: Yeah, it accumulates each matched element
19:55:44 <athan> hah!
19:56:14 <athan> I was thinking `matchUntil`
19:56:43 <athan> or Til :s
19:57:53 <DarwinElf> so, I installed an older GHC. Then all the dependencies were still newer instead of older as someone had claimed this would solve... then how do I set it up to get the older ones? (like about 2012-7-22)
20:02:06 <geekosaur> right, pick a random ghc and it is guaranteed to be old enough?
20:02:28 <geekosaur> I hae no idea what you are building or how old a ghc you would need for it
20:03:11 <DarwinElf> I already said I'm building kevin
20:03:29 <DarwinElf> I picked GHC for my OS closest after the last release of kevin
20:04:19 <DarwinElf> it's: https://github.com/pikajude/kevin
20:07:18 <DarwinElf> the dependencies are HTTP ==4000.2.*, MonadCatchIO-mtl ==0.3.*, attoparsec ==0.10.*, bytestring ==0.9.*, containers ==0.4.*, cprng-aes ==0.2.*, data-lens ==2.10.*, data-lens-template ==2.1.*, mtl ==2.1.*, network ==2.3.*, regex-pcre-builtin ==0.94.*, stm ==2.3.*, text ==0.11.*, tls ==0.9.*, tls-extra ==0.4.* (which also seem to have loads more dependencies)
20:08:53 <geekosaur> actually that repo has a cabal file with very few versions filled in; if most of those are just what it tried, then it may well have mismatches or etc.
20:10:17 <Clint> DarwinElf: tls-extra got folded into tls so that's why it's trying to force old versions of things
20:10:41 <Clint> if you're lucky you can just drop that from the .cabal file and it'll magically work
20:12:53 <DarwinElf> neat
20:13:52 <DarwinElf> I'm trying that now, but saw something about 'upper bounds' on dependencies, like if it uses '==' instead of maybe '>=', which I tried but hadn't changed anything... but I'll see if this works without the old tls-extra
20:26:44 <ryantrinkle> any recommendations for how to keep two datastructures in sync over a network?
20:26:44 <Clint> DarwinElf: looks to me like you're going to need some more effort than that.. maybe pikajude can help you out
20:27:13 <ryantrinkle> i was looking at increments (https://hackage.haskell.org/package/increments), but it looks like i would need to change the (big) datastructure, then recover the diff
20:28:19 <DarwinElf> I don't know; I think he doesn't work on the kevin software anymore
20:44:46 <DarwinElf> yeah, I tried what you said, Clint, and 'Setup configure' still says most dependencies are missing... so I'm stuck on what to do next and hopefully the old maintainer could still help
20:52:35 <Lokathor> i hate SO MUCH that breakOn leaves the thing you broke on at the start of the second result
20:56:26 <KaneTW> why
20:56:33 <KaneTW> that's how i'd expect it to happen
20:57:13 * hackagebot packdeps 0.4.2 - Check your cabal packages for lagging dependencies.  https://hackage.haskell.org/package/packdeps-0.4.2 (MichaelSnoyman)
20:57:17 <Lokathor> ugh, but i want it to not include what i just broke by
20:57:57 <DarwinElf> pikajude, so, any chance you could still tell me what I'd have to do to compile the apparently final release of 'kevin'?
20:58:21 <KaneTW> > break (=='a') "rirurarero" & _2 %~ tail
20:58:22 <lambdabot>  ("rirur","rero")
20:58:36 <KaneTW> (note: partial)
20:59:43 <Lokathor> KaneTW, i want breakOn though
20:59:49 <KaneTW> :t breakOn
20:59:50 <lambdabot>     Not in scope: ‘breakOn’
20:59:50 <lambdabot>     Perhaps you meant one of these:
20:59:50 <lambdabot>       ‘break’ (imported from Data.List),
20:59:56 <Lokathor> :t T.breakOn
20:59:57 <lambdabot> Not in scope: ‘T.breakOn’
21:00:03 <KaneTW> can you link it in hoogle
21:00:07 <Lokathor> :t Data.Text.breakOn
21:00:08 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text -> (Data.Text.Internal.Text, Data.Text.Internal.Text)
21:00:20 <Lokathor> i just wrote it myself
21:00:35 <EveningTea> Greetings
21:00:54 <KaneTW> > break "a" "rirurarero" & _2 %~ Data.Text.tail
21:00:55 <KaneTW> eh
21:00:56 <lambdabot>      Not in scope: ‘Data.Text.tail’
21:00:56 <lambdabot>      Perhaps you meant one of these:
21:00:56 <lambdabot>        ‘Data.List.tail’ (imported from Data.List),
21:01:02 <KaneTW> > Data.Text.breakOn "a" "rirurarero" & _2 %~ Data.Text.tail
21:01:04 <lambdabot>  Not in scope: ‘Data.Text.breakOn’    Not in scope: ‘Data.Text.tail’
21:01:04 <lambdabot>      Perhaps you meant one of these:
21:01:04 <lambdabot>        ‘Data.List.tail’ (imported from Data.List),
21:01:12 <KaneTW> i guess it's not in scope
21:01:19 <Lokathor> KaneTW, even if lambdabot accepted that properly, it wouldn't work for multi-char breaks
21:01:24 <KaneTW> true
21:01:40 <lpaste> Lokathor pasted “No title” at http://lpaste.net/146134
21:03:31 <rui> \exit
21:03:33 <rui> \quit
21:06:57 <EveningTea> I've a question re' a bit of code I've been playing with: http://lpaste.net/1936432867789766656
21:08:16 <EveningTea> When using Maybe instead of [] as my applicative/monoid for try', GHC suddenly demands a (Monoid a) constraint specification on the matchLongest function. I simply can't deduce why it is demanding this, particularly since it has no objections to [] instead of Maybe..
21:09:41 <EveningTea> Does anyone have some insight as to *why* GHC believes a Monoid a constraint is required?
21:10:16 <KaneTW> the default maybe applicative requires monoid
21:10:27 <KaneTW> lists can just be concatenated together
21:10:43 <Lokathor> whereas Maybe is concatinated only if the contents are concatinated
21:10:51 <KaneTW> there's First/Last
21:11:03 <KaneTW> which picks the first non-Nothing orthe last non-Nothing Maybe
21:11:30 <EveningTea> ah.
21:12:04 <KaneTW> > Just 1 <> Just 5
21:12:06 <lambdabot>      No instance for (Show a0)
21:12:06 <lambdabot>        arising from a use of ‘show_M418595689729038747114693’
21:12:06 <lambdabot>      The type variable ‘a0’ is ambiguous
21:12:11 <samba1> I'm getting out of memory (requested 2097152 bytes)
21:12:12 <KaneTW> > Just (Sum 1) <> Just (Sum 5)
21:12:14 <lambdabot>  Just (Sum {getSum = 6})
21:12:15 <samba1> 2 megs is not that much memory
21:12:26 <samba1> what could the problem be? free shows plenty of free memory
21:12:29 <EveningTea> <insert grumbling about bad GHC error msgs>
21:12:40 <EveningTea> I thank you for the insight
21:14:39 <EveningTea> In retrospect I probably don't want the Monoid constraint, but rather something that's mempty without implying Monoid (since that doesn't work for Maybe a w/o Monoid a).. Time to go looking for that...
21:15:35 <MarcelineVQ> id ?
21:17:54 <pavonia> samba1: That's probably the amount of memory it tires to allocate before it fails. Have you checked how much it uses in total?
21:21:15 <samba1> pavonia: I don't know how, since it crashes, running with +RTS doesn't give me any output
21:24:18 <pavonia> samba1: What system are you on?
21:24:50 <samba1> ubuntu
21:27:15 * hackagebot wai-websockets 3.0.0.7 - Provide a bridge between WAI and the websockets package.  https://hackage.haskell.org/package/wai-websockets-3.0.0.7 (MichaelSnoyman)
21:28:01 <samba1> related question, I guess - is there a way to profile just a single function, so that I can give it a big, deepseqed data structure as input and just get the stas for that function itself (not counting the huge datastructure that comes from outside)
21:28:56 <pavonia> I think you can use ps for the whole process, but I'm not familiar with unix systems
21:30:01 <samba1> oh, yeah, well ps of course
21:30:08 <samba1> it must be using more mem, in any event, you're right
21:30:32 <samba1> it's so hard to figure out how to stream things like vectors to avoid that
21:32:15 * hackagebot git-fmt 0.3.0.3 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.3.0.3 (hjwylde)
21:44:29 <Lokathor> classic problem: IRC doesn't specify an encoding
21:44:43 <Lokathor> but it does specify that it uses specific characters such as space, and \r\n to delimit lines
21:44:46 <Lokathor> ugh
21:48:07 <tabemann> how I handle that in my code is that I use Data.ByteString.Char8 for parsing IRC protocol data, and Data.Text.Encoding for converting the actual user data between UTF8 ByteStrings and Text
21:52:52 <geekosaur> ...except when the coding is some iso8859
21:53:21 <Arahael> tabemann: doesn't chat8 strip the high bit?
21:53:24 <Arahael> *char8
21:53:50 <geekosaur> no, it strips the bits above the 8th
21:54:07 <Arahael> cool.
21:54:20 <geekosaur> so if it sees U+2422 you get U+22
21:54:40 <Arahael> easy :)
21:56:40 <tabemann> well when I'm using Data.ByteString.Char8 I'm intentionally using the data as a series of octets
21:57:15 <tabemann> and I'm only using it for data that is defined at the byte level in the IRC protocol
22:17:06 <pikajude> DarwinElf: i could take some time and try to get it to compile with newer libraries
22:18:15 <DarwinElf> that'd be cool if you could... I use deviantART main chat occasionally and have been trying to start a channel, so I used to be logged in there all the time for a year or few until kevin 0.8 stopped working
22:18:21 <pikajude> oh ok
22:18:28 <pikajude> did they change the protocol again?
22:18:56 <pikajude> give me a few minutes, i have to build cabal2nix which requires lens, and the doctests take 25 minutes
22:21:37 <Lokathor> what I decided on is to read the bytes in, decode them to Text (utf8), check for \r\n, if it's there pull off as many messages as are available and store the rest, and if it's not there just store that
22:21:51 <Pamelloes> pikajude: Your computer is fast. The doctests always take me well over an hour...
22:22:15 <Lokathor> because the server isn't supposed to send more than 512 bytes at a time or whatever, but i guess sometimes it does
22:22:41 <Lokathor> so you have to carefully manage when you and don't have a complete line, and store the incomplete lines for the next read
22:23:31 <Lokathor> https://github.com/Lokathor/haizod/blob/master/src/Main.hs#L63
22:23:47 <Pamelloes> Haskell code is really dense. My entire project is just under 1500 lines of code whereas a similar amount of code in another language would probably be ten times that.
22:24:13 <Lokathor> Pamelloes, I've also noted that same thing. Not sure if it's good or bad in the end, but I think good
22:24:30 <pikajude> Pamelloes: I have the late 2014 MBP
22:26:54 <Pamelloes> pikajude: I have the late 2010 iMac. Shockingly, the newer models perform better! :D
22:27:58 * Arahael has the early 2015 mbp, though doesn't know how quickly it would do those doctests.
22:28:19 <pikajude> i would hazard a guess it depends on the CPU
22:28:27 <Arahael> 13", mind you.  The 15" is supposed to be faster.
22:28:30 <pikajude> doctests take so long because they have to spawn a new GHC process ~2000 times
22:28:36 <Pamelloes> Yeah...
22:28:40 <Pamelloes> It's pretty terrible.
22:28:42 <pikajude> but i don't know what that depends on. CPU? disk speed?
22:29:06 <Arahael> The 2015 models are very, very fast for disk speed. (At least, for a laptop)
22:29:17 <Arahael> Nearly double the speed of 2014.
22:29:32 <Lokathor> sorry, what are "doctests"?
22:30:19 <Pamelloes> Lokathor: If you look at lens' documentation it has a ton of example lines of code. The doctests are where it goes through and compiles every single one to make sure they check out.
22:30:34 <lethjakman-l> I have a memory that there's a nice way to do maybe case statements in one line...I think it was a symbol or something. Does that ring a bell to anyone?
22:30:48 <Lokathor> lethjakman-l, do you mean with a ;
22:30:57 <lethjakman-l> Lokathor: No. 
22:31:13 <lethjakman-l> I think it's closer to fromMaybe, but that doesn't seem right. 
22:31:41 <Lokathor> :t maybe
22:31:42 <lambdabot> b -> (a -> b) -> Maybe a -> b
22:33:37 <Pamelloes> Oh! I realized why I have so few lines of code—I haven't written any documentation.
22:33:59 <Pamelloes> I should really figure out how to write hackage style documentation one of these days...
22:34:00 <Lokathor> always key
22:34:07 <Lokathor> do you mean haddock?
22:34:19 <Pamelloes> Yeah
22:34:29 <Pamelloes> When I get tired, all my prepositions get mixed up/
22:34:38 <Lokathor> https://www.haskell.org/haddock/doc/html/markup.html
22:35:01 <Pamelloes> Lokathor: Cool! Thanks :)
22:35:09 <Lokathor> basics, use comment blocks above functions starting with -- | foo instead of just -- foo.
22:35:25 <Lokathor> or {- | foo -} if you like multi-line style
22:35:38 <Lokathor> sorry, {-| foo -}
22:36:19 <Lokathor> then you can get fancy with linking to other data types and stuff using special markup
22:47:54 <bb010g> I think this is officially the weirdest looking code I've ever unironically written: `(flip . (((.).(.)).))`
22:49:13 <cow_2001> bb010g: you're a monster
22:49:26 <bb010g> In case you're curious:
22:49:46 <cow_2001> @pointful (flip . (((.).(.)).))
22:49:46 <lambdabot> (\ m b c f i -> m c (b f i))
22:49:58 <bb010g> (thanks, forgot the command name)
22:50:09 <cow_2001> ♥ bb010g ♥
22:50:09 <bb010g> You can even extend it.
22:50:30 <Pamelloes> ((.).(.)) -- Who? Who?
22:50:44 <bb010g> @pointful (flip . ((((.).(.)).(.)).))
22:50:44 <lambdabot> (\ p b c f i l -> p c (b f i l))
22:50:49 <cow_2001> god
22:51:28 <Pamelloes> Oh I see, you have an extra . after the owl. That's why there are two parameters to the first function :)
22:51:38 <cow_2001> everyone should use lambdabot's pointful engine to avoid unholy abominations such as these
22:51:46 <Pamelloes> ^
22:52:15 <cow_2001> @pointless (\ p b c f i l -> p c (b f i l))
22:52:15 <lambdabot> flip . (((.) . (.) . (.)) .)
22:52:22 <cow_2001> D:<
22:52:26 <bb010g> cow_2001: Don't worry; I'm sticking it away in a helper function family
22:52:28 <cow_2001> this is so pointless
22:53:18 <bb010g> So it makes more sense in context.
22:53:31 <Pamelloes> @pl \a b c d -> a + b + c + d -- Hooray for monstrosities :)
22:53:31 <lambdabot> ((((+) .) . (+)) .) . (+)
22:53:50 <cow_2001> my imagination fails me. what kind of context makes this pointless function pointful?
22:54:40 <bb010g> cow_2001: I'm tossing around some arguments in default nested constructors for a Telegram bot API library.
22:54:50 <cow_2001> telegram bot :|
22:54:56 <bb010g> I'll drop the link after I push to GitHub.
22:55:08 <cow_2001> cool! thanks!
22:55:22 <bb010g> Servant's proving to be nice to work with, as advertised.
22:55:58 <Pamelloes> bb010g: What makes the pl version better in conext than the pointful version?
22:58:37 <bb010g> Pamelloes: Family of {1,2,3} arg versions that are pointful, and this is better looking and actually easier to deal with in definition of those.
22:59:08 <Pamelloes> Ah, that makes sense.
23:22:19 * hackagebot huckleberry 0.9.0.1 - IchigoJam BASIC expressed in Haskell.  https://hackage.haskell.org/package/huckleberry-0.9.0.1 (tkmsm)
23:34:26 <nocturne777> Is it a bad practice to have a side-effect in the smart constructor code ?
23:35:44 <bb010g> nocturne777: Probably. Example?
23:38:04 <lpaste> nocturne777 pasted “smart constructor with side-effect” at http://lpaste.net/146135
23:38:28 <nocturne777> bb010g: that's one example I have
23:39:41 <jle`> nocturne777: i don't think it's bad practice
23:39:49 <jle`> it's very common for smart constructors to return `Maybe`
23:40:15 <jle`> if it does IO, I probably wouldn't consider it a "smart constructor"...i'd consider it a constructing action/allocation
23:40:23 <jle`> sort of like newIORef :: a -> IO (IORef a)
23:40:50 <jle`> you can think of that as a "construction" of an IORef, that happens as an allocation or something in IO
23:42:49 <pavonia> We should call these "not-so-smart constructors"
23:43:36 <jle`> "initializer" might be a nice word too
23:45:02 <bb010g> Although `newIORef x >> f` should be equivalent to `f`, save for garbage collection & friends
23:45:05 <jle`> a nice (?) thing about haskell is that initializers/constructors that do things in IO are signified in the type :)
23:45:48 <jle`> bb010g: yeah; my point is that the "constructor/construction" of an IORef can only be done in IO; there's no meaningful `a -> IORef a`, only `a -> IO (IORef a)`
23:45:50 <lpaste> nocturne777 revised “smart constructor with side-effect”: “added aeson code” at http://lpaste.net/146135
23:46:12 <bb010g> nocturne777's constructor only modifies entropy
23:46:46 <jle`> it grabs a UUID from the runtime
23:47:05 <nocturne777> the thing with this constructor is that I had a hard time getting it to be decoded by aeson
23:47:40 <nocturne777> I couldn't get it to work with aeson, actually
23:47:58 <bb010g> I think the fact that they're pretty well independent makes them constructors and not full operations that happen to generate an instance
23:48:38 <jle`> nocturne777: yeah, aeson expects 'pure' decoders that don't do IO
23:48:55 <jle`> one thing you can do is to make a NewAccount type without a UUID, and then make a type that wraps a UUID with an account type
23:49:16 <jle`> so decode the json into the uuid-less data type --- which is what the json ecodes, anyway
23:49:23 <jle`> and then fetch a uuid to tag on to the type
23:49:44 <jle`> it might be weird that the parsing of a JSON object would do IO
23:49:44 <bb010g> nocturne777: Just lift the decoder into IO
23:50:23 <bb010g> Also, where's JSON.removePrefix defined?
23:51:13 <lpaste> nocturne777 revised “smart constructor with side-effect”: “No title” at http://lpaste.net/146135
23:51:28 <nocturne777> bb010g: it is my own util function, just added to to the paste
23:52:08 <jle`> i feel like adding a UUID to data that isn't a part of the json is outside of the scope of what the json conversion is supposed tod
23:52:10 <jle`> *to do
23:52:30 <jle`> so maybe converting it into a data w/out the UUID, and then using your initializer to complete it with a UUID would make sense
23:53:20 <bb010g> jle`++
23:53:36 <nocturne777> jle`: yeah, I agree with you. 
23:53:46 <nocturne777> it looks a bit confusing 
23:54:10 <jle`> yeah, it does add the extra complexity/overhead of creating a second data type when one would do
23:54:16 <jle`> well, you can do this one trick i've been doing
23:54:30 <jle`> i'm not sure if it's a good practice but i've been using it a lot recently
23:54:31 <bb010g> You don't want the act of looking at a value to do IO in general
23:56:06 <nocturne777> jle`: what is that trick?
23:56:17 <jle`> actually i started typing it out but i think i'm going to put it in a paste
23:58:34 <nocturne777> also, in my data type, I have primitive types like Text and such. should I instead convert those fields to something like newtype UserName = Username Text ?
23:59:14 <nocturne777> or would that be overkill?
