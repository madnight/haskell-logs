00:03:30 <danmulvey> hello!
00:10:08 <liste> hellp danmulvey!
00:10:13 <liste> hello*
00:17:39 <ppfs> hi
00:19:06 <ppfs> I'm trying to install hsqml via cabal (on fedora) but get the error "setup: The pkg-config package Qt5Core version >=5.0 && <6.0 is required but it could not be found.". Any idea what's wrong ?
00:20:37 <liste> ppfs do you have qt5 installed on your system?
00:21:06 <ppfs> liste: yes, and I think I have developpement versions too
00:21:20 <ppfs> but I'm not really sure exactly what is what
00:26:48 <ppfs> (wait, maybe I haven't installed everything needed)
00:32:43 <ppfs> I've got the packages named "qt5-qtbase", "qt5-qtbase-common", "qt5-qtbase-devel", and some more. That should be enough, no?
00:34:16 <Freundlich> ppfs: On my system, the providing package is called qtcore.
00:35:04 <Freundlich> What cabal is looking for is probably /usr/lib/pkgconfig/QtCore5.pc - Look for a package on your system that provides that.
00:35:58 <ppfs> mmh, If I undestand correctly, qtcore is covered by qt-devel, so it should work
00:39:43 <ppfs> but I actually don't have this file, Freundlich
00:40:20 <Freundlich> ppfs: Maybe an oversight by the package maintainer, maybe it's in a different package?
00:41:06 * hackagebot git-fmt 0.2.1.0 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.2.1.0 (hjwylde)
00:45:04 <ppfs> I don't know, `dnf provides "*QtCore*"` lists qt-devel as providing such a file
00:46:23 * hackagebot Hoed 0.3.1 - Lightweight algorithmic debugging.  https://hackage.haskell.org/package/Hoed-0.3.1 (faddegon)
00:49:12 <Xack> currently fiddling with shake and right now and am wondering why https://gist.github.com/zackp30/469234db1c83b3ef65a3 (error included) is happening
00:51:23 * hackagebot linux-inotify 0.3.0.0 - Thinner binding to the Linux Kernel's inotify interface  https://hackage.haskell.org/package/linux-inotify-0.3.0.0 (LeonSmith)
00:58:24 <ppfs> anyway, thanaks Freundlich/liste
01:11:34 * nomeata misses something akin to GHC’s Bag data structure in base, i.e. something to replace lists when you need structure-sharing concatenation, but also a length operation (which rules out dlists)
01:12:31 <quicksilver> nomeata: Seq?
01:15:03 <nomeata> quicksilver: possibly, but it’s probably confusing to the audience when I start explaining stuff by looking at the heap
01:15:08 <nomeata> (I have specific requirements)
01:15:18 * quicksilver nods
01:15:26 <quicksilver> yes fingertrees are subtle
01:15:28 <nomeata> I guess I can roll my own for the sake of the talk, or just go with lists
01:15:29 <quicksilver> if you haven't studied them
01:15:52 <quicksilver> I can see the practical appeal of bag although it's a kind of non-universal mess of special cases :)
01:16:09 <nomeata> Maybe it is even helpful to see how "... length x1 ... x1 ++ x2" causes two copies of x1 to appear on the heap.
01:18:27 <dxvxb> -> [Warning:  .ghci is writable by someone else, ignoring...]
01:19:21 <dxvxb> i have all the permissions.. how does it want it to be...
01:19:42 <dxvxb> i cant load .ghci files from anywhere...
01:20:08 <ben> too many permissions?
01:20:42 <dxvxb> you mean i should'nt have write permissions :P
01:21:03 <ben> you should, other users shouldn't, evidently
01:21:24 <liste> ls -l .ghci should show something like rw-r--r--
01:22:59 <liste> or, preferably, rw--------
01:23:24 <dxvxb> umm, thanks :|
01:23:33 <liste> why the :| ?
01:24:24 <liste> chmod go-w .ghci should fix it
01:25:23 <dxvxb> yeah :)
01:26:13 <dxvxb> and, its giving warning for the directory too !!
01:27:49 <dxvxb> why that? i am using the haskell NICTA Course... those interactive problems..
01:30:16 <merijn> dxvxb: Because .ghci can execute arbitrary IO
01:30:39 <merijn> dxvxb: If your home directory is writable by everyone any user could overwrite the file with "rm -rf /" to delete everything on your disk
01:31:15 <merijn> dxvxb: It's a massive security hole to have your .ghci writable by other users (not to mention your $HOME being writable being even huger security hole)
01:41:14 <dxvxb> merijn: okay, thanks. actually its writable for those who are in my group, (group with users name, that linux create)... there's nobody else in it, but its showing warning as it should.. thanks..
02:02:40 <Saizan> nomeata: oh, you have some kind of heap visualization thing?
02:05:12 <nomeata> Saizan: see ghc-heap-view resp. ghc-vis: http://felsin9.de/nnis/ghc-vis/
02:06:02 <nomeata> A bit flakey sometimes, but helpful for teaching and talks
02:06:09 <zenzike_> perhaps I'm being blind here, but is there a pure interface to quickcheck? Ie something that can run checks but not in IO?
02:09:32 <quicksilver> doubtful. It needs random numbers to run the checks.
02:09:54 <merijn> quicksilver: It could let you run purely if you provide a seed
02:10:08 <Saizan> nomeata: oh, so you wouldn't try to use it to make sense of e.g. space leaks in a long-running program?
02:10:35 <quicksilver> merijn: it could, couldn't it
02:11:08 <quicksilver> merijn: although its timeout stuff needs IO too
02:11:18 <nomeata> Saizan: might be tricky. For that, you might use http://hackage.haskell.org/package/ghc-heap-view-0.5.4/docs/GHC-AssertNF.html
02:12:30 <quicksilver> and it has other ways to add IO hooks to properties
02:13:18 <gfixler1> does haskell have a call stack?
02:13:31 <quicksilver> gfixler1: no, but an haskell implementation might use one
02:13:39 <gfixler1> quicksilver: okay, I didn't think it did
02:13:51 <gfixler1> it doesn't jive for me with the expression-replacement model
02:13:52 <quicksilver> GHC doesn't use a call stack for recursive function calls but it does use one - effectively - for reducing nested thunks.
02:13:54 <gfixler1> like-for-like and all that
02:14:16 <gfixler1> under the hood I imagine there's a stack, but in the haskell model itself, I couldn't see it
02:14:43 <merijn> gfixler1: If you wanna get really nitty-gritty on how GHC (roughly) does it, there is a "pattern match" stack, rather than a call stack
02:14:47 <quicksilver> Saizan, nomeata : for making sense of long-running programs it would be awesome to visualise the entire heap as dots and lines, and let you zoom into a ghc-vis like view
02:14:52 <gfixler1> merijn: neat!
02:15:04 <merijn> gfixler1: In practice GHC compiles all function calls to straight up jumps (i.e. all calls are "tail calls")
02:15:23 <merijn> gfixler1: For an excellent intro consider reading http://research.microsoft.com/apps/pubs/default.aspx?id=67083
02:15:47 <gfixler1> merijn: that one is on my list :)
02:16:03 <gfixler1> merijn: I've been reading SPJ's book
02:16:15 <gfixler1> (and too many other things)
02:16:44 <quicksilver> I wonder if using the stuff ghc-heap-view has you can find out how recently a node in the heap graph was touched by the program
02:16:49 <quicksilver> colour coding old vs new data would be nice
02:17:22 <gfixler1> I was thinking that the lack of a call stack doesn't mean you couldn't have a call history
02:17:44 <merijn> gfixler1: It doesn't, but it does make it trickier
02:17:59 <quicksilver> gfixler1: recent GHCs have the ability to pass something like a call stack around for debugging
02:18:01 <gfixler1> merijn: laziness and parallelism?
02:18:12 <quicksilver> it's a runtime cost though - because it's actually constructing something it wouldn't normally bother to construct.
02:18:23 <gfixler1> sure
02:19:14 <quicksilver> https://ghc.haskell.org/trac/ghc/wiki/ExplicitCallStack/ImplicitLocations
02:19:19 <quicksilver> that is approximately what they implemented
02:19:35 <quicksilver> one of the problems with articles on the GHC wiki is you're never sure if changes were made during implementation :/
02:20:06 <merijn> quicksilver: True, but #ghc and ghc-devs are very responsive when you ask, so that helps
02:23:30 <quicksilver> yes.
02:23:39 <quicksilver> ghc-devs are made entirely of awesome.
02:35:41 <Xack> currently fiddling with shake and right now and am wondering why https://gist.github.com/zackp30/469234db1c83b3ef65a3 (error included) is happening
02:42:40 <quchen> Xack: I don't understand the error either, but the code looks like you're trying to write an IO action to a file, which you cannot do.
02:43:17 <Xack> oh
02:43:18 <Xack> heh
02:44:40 <Xack> okay, fixed, thanks quchen :)
02:53:54 <int-e> oh one of those errors... when matching [Char] to IO a, ghc for some reason decided to first check whether a = Char
02:55:41 <quchen> int-e: Huh? Sounds like a bug.
02:56:14 <quchen> :t [undefined :: IO Int, undefined :: Maybe Char]
02:56:16 <lambdabot>     Couldn't match expected type ‘IO Int’ with actual type ‘Maybe Char’
02:56:16 <lambdabot>     In the expression: undefined :: Maybe Char
02:56:16 <lambdabot>     In the expression: [undefined :: IO Int, undefined :: Maybe Char]
02:56:22 <quchen> :t [undefined :: IO Int, undefined :: [Char]]
02:56:24 <lambdabot>     Couldn't match expected type ‘IO Int’ with actual type ‘[Char]’
02:56:24 <lambdabot>     In the expression: undefined :: [Char]
02:56:24 <lambdabot>     In the expression: [undefined :: IO Int, undefined :: [Char]]
02:56:29 <quchen> Looks correct here
02:56:56 <phadej> IO a ~ [] Char, reasonable to check whether a ~ Char first
02:57:27 <phadej> though, totally arbitrary of course
02:57:32 <phadej> choice
02:57:37 <int-e> sorry, that was a guess which may be wrong... the truth can be found by enabling tracing for the type checker
02:57:49 <quchen> Exactly, and the compiler should give the best arbitrary choice for the user
02:57:56 <quchen> And GHC does, in my experience
02:58:22 <quchen> So that's why I'm guessing this is a phenomenon from a bug we haven't found yet
02:58:50 <phadej> quchen, int-e: you have show the code :)
02:59:40 <phadej> I remember seeing GHC giving me something like that when there are polymorphic functions involved
02:59:59 <phadej> so it matches f a with g Char, and only later f with IO and g with []
03:01:59 * hackagebot stylish-haskell 0.5.14.4 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.5.14.4 (JasperVanDerJeugt)
03:08:02 <Jinxit> if I have a data structure containing native haskell functions, can I somehow make a DSL for creating that tree? doesn't matter if it's at run or compile time
03:08:21 <Jinxit> as opposed to writing some nestled unreadable expression
03:19:20 <Guest298> Hello
03:19:37 <suppi> hi
03:19:59 <Guest298> Maybe not the right place but figured, briliant programmers must have a solution to the ERR_CONNECTION_RESET problem
03:20:40 <tzaeru> try... re-establishing connection after that? 8)
03:21:06 <Guest298> Tried many things but seems a hard one
03:21:54 <tzaeru> I'm not fully sure what your context exactly is here
03:22:01 <Guest298> apperently Facebook, Google are not affected generaly https
03:22:05 <tzaeru> a lot of things can pop out an error message with "ERR_CONNECTION_RESET"..
03:22:12 <Guest298> Bowsing the web
03:22:34 <tzaeru> oh.
03:22:37 <Guest298> Browsing and not getting any page just error reset or empty 
03:22:44 <tzaeru> tried restarting your router?
03:24:34 <Guest298> Ya, but when this happened (not sure if it's related) I had like few mobile wifi and was swaping the sim in few of them
03:25:05 <Guest298> Also, noticed this sheild appearing (in Chrome) saying the webpage trying to laod unsafe scripts even though it's like Gmail /Google
03:25:12 <anks> How do i display heap profile in stack project?
03:26:10 <Guest298> Tried to use wget to downlaod a page since I can't browse but got connection reset by peers
03:27:28 <Guest298> Can't browse this maybe they have a solution http://www.pcappspot.com/err-connection-reset-error-fixed/
03:32:16 <Guest298> Hello?
03:32:34 <tzaeru> hai
03:32:39 <Guest298> Also, getting the same with my localhost (Wamp)
03:32:49 <tzaeru> well, beyond restarting your router, I know nothing.
03:32:51 <tzaeru> ^_^
03:34:00 <Guest298> Well, can you browse that website ans see what they say :)?
03:34:52 <frerich> Can you guys please take that to a private chat or so? Imagine you're sitting at a Haskell talk with 1500+ people in the audience and you guys are sitting on stage discussing wget :-}
03:35:44 <Xandaros> There IS #haskell-blah :P
03:36:13 <Guest298> LOL
03:36:37 <Guest298> Haskell programmers have extra mind powers so this shouldbe easy to resolve 
03:37:18 <agocorona> anyone know how file IO is implemented in ghcjs?
03:40:50 <dredozubov> agocorona: try asking luite on #ghcjs
03:41:02 <dredozubov> it's your best bet to find the answer find and accurate :)
03:41:13 <dredozubov> fast and accurate*
03:42:21 <agocorona> dredozubov:  i did, but he sometimes sleep a bit ;)
03:42:37 <dredozubov> it happens :)
04:14:47 <unrar> boo
04:24:08 <Myrl-saki> Who here uses haskell with vim?
04:24:46 <jeltsch> Myrl-saki: Me.
04:25:06 <Myrl-saki> jeltsch: What plugin allows you to print out the type of a function?
04:29:49 <sdegutis> Is it common to run a Haskell web app via `ghci` so that parts of it can be live-reloaded at runtime?
04:30:24 <unrar> Is there a wiki page with a lot of examples of haskell-powered software?
04:30:32 <quicksilver> sdegutis: no.
04:30:38 <quicksilver> sdegutis: I would say that is probably unheard of.
04:31:29 <sdegutis> quicksilver: So the norm is to recompile the web app and scp it and restart it?
04:31:33 <merijn> unrar: Probably, but I dunno where it'd be. The 4 biggest/most famous projects that come to mind would be: xmonad, pandoc, ghc, and haxl (the facebook library)
04:32:15 <unrar> somehow i can only visualize using Haskell for something related to numeric programming/math/stats or whatever
04:33:06 <merijn> unrar: I dunno why, I'd say haskell is most suited for things like parsers/text analysis and concurrent/server stye applications
04:33:27 <quicksilver> sdegutis: if you want dynamic features, there are projects like 'dyre' and 'plugins'
04:35:20 <jle`> sdegutis: ghci doesn't do live-reloading, does it?
04:35:32 <jle`> reloading anything requires shutting everything down i thought
04:38:37 <merijn> jle`: Correct
04:39:06 <sdegutis> Oh.
04:40:22 <frerich> Myrl-saki: I use hdevtools for that (I configured it so that I can press <leader>t on some expression and vim prints the type of the expression. Typing it repeatedly gives the type of the enclosing expression)
04:40:28 <quicksilver> it will leave threads running, I think?
04:40:34 <quicksilver> but they will not be able to interact with new code
04:40:38 <quicksilver> they'll have old code and old types?
04:40:59 <Myrl-saki> frerich: Ah, thanks.
04:43:20 <jophish> What could explain the output I'm getting from criterion in these reports: http://lon.eso.me.uk/report1.html http://lon.eso.me.uk/report2.html
04:43:27 <jophish> my first thought is garbage collection
04:43:48 <jophish> If that's the case, what does it mean?
04:44:04 <f-a> I am trying to write this in haskell programmingpraxis.com/2015/11/17/file-reversal/ (tl;dr: write the lines of a file from last line up, file is too big to be held in memory). I was thinking of using handles and work my way up, but I don't know how to position an handle to the EOF (or at least, I haven't found it in System.IO).
04:44:19 <jophish> report2 is even more strange
04:45:41 <merijn> f-a: hSeek :: Handle -> SeekMode -> Integer -> IO ()
04:46:22 <quicksilver> jophish: no idea what your code does? But yes if you are remarking on apparently inconsistent timings when applying a pure function to a full NF value
04:46:30 <quicksilver> jophish: then it essentially must be GC.
04:46:35 <f-a> thanks merijn 
04:56:36 <jophish> quicksilver: I thought as much, but it's nice to have it confirmed by you
04:58:52 <quicksilver> jophish: ther other thing it could be is applying a pure function to a thunk
04:59:01 <quicksilver> jophish: and not realising there was still work to do to rpoduce the thunk
04:59:15 <quicksilver> but of course that shouldn't vary between multiple runs of criterion.
04:59:40 <quicksilver> also, of course, on a multiuser machine if you're close to cache limits, you might find in some runs another process pushed you out of cache and you had a page fault
04:59:59 <quicksilver> or even worse you got swappde
05:17:49 <nani___> it seems that, on typeclassopedia, all the links to documentation are dead...
05:19:40 <liste> nani___ https://wiki.haskell.org/Typeclassopedia this one?
05:19:50 <nani___> liste yes
05:20:21 <nani___> for example, CTRL+F for "Prelude", the first occurence
05:22:51 <liste> seems it misses the version number, this one works: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/Control-Monad.html
05:31:41 <quicksilver> not having a version number is supposed to link you to the latest version
05:31:52 <benzrf> ghci consistently takes ~5s to get running on a cold start
05:31:54 <benzrf> is this normal
05:32:00 <quicksilver> for example
05:32:00 <quicksilver> https://hackage.haskell.org/package/base/docs/Data-List.html
05:32:03 <quicksilver> should work
05:32:11 <quicksilver> (but it will redirect you to 4.8.1.00
05:32:30 <liste> quicksilver does it mean that ghc docs are broken?
05:32:55 <quicksilver> liste: I think downloads.haskell.org/~ghc is the not the best place to link to?
05:32:59 <benzrf> also, even when warmed up, it takes about 0.25s to start, vs (e.g.) python's 0.04s
05:33:00 <quicksilver> hackage is better.
05:33:25 <quicksilver> benzrf: "cold start" is hard for anyone to compare timings. It depends how slow your hard disk is and so on.
05:33:37 <benzrf> i guess my hard disk is super slow c:
05:33:57 <quicksilver> benzrf: warm start is essentially instant to my eyes but could be 100-200ms
05:34:29 <merijn> benzrf: Time to buy an SSD! :p
05:34:33 <liste> quicksilver so it'd be better to link the typeclassopedia docs to hackage?
05:34:52 <quicksilver> liste: that would seem better to me.
05:54:26 <fazky> @pl \f g x y -> f (x ++ g x) (g y)
05:54:26 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
05:59:51 <anks>  Why can't i define this type?: type OrderedList a = forall b. Ord b => [(b,a)]
06:00:23 <merijn> anks: Works if you add an existential newtype
06:00:26 <merijn> afaik
06:01:32 <anks> could you provide correct syntax ?
06:01:35 <merijn> anks: i.e. "newtype OrderedList a = OL (forall b . Ord b => [(b, a)])"
06:01:42 <anks> :D
06:01:53 <merijn> Although I doubt that's a very useful type, why do you need it?
06:01:58 <Myrl-saki> Guys.
06:02:15 <anks> i was just curious it it is possible to construct such a type
06:02:37 <Myrl-saki> If something is I/O intensive, how should I test if it terminates?
06:02:43 <anks> thanks
06:03:06 <merijn> Myrl-saki: In what sense?
06:03:19 <Myrl-saki> Well, it's not I/O intensive.
06:03:35 <Myrl-saki> merijn: How do I force evaluate it?
06:03:54 <merijn> Myrl-saki: IO (with some exceptions) is not lazy, so there's no need to
06:04:21 <Myrl-saki> I mean.
06:04:24 <Myrl-saki> It's not part of I/O.
06:05:23 <Myrl-saki> merijn: I edited the code a bit, and it's safe to say that it's too slow.
06:05:39 <Myrl-saki> In other words, I fucked up. :D
06:05:45 <merijn> Myrl-saki: Which code?
06:05:55 <Myrl-saki> merijn: The code I'm making.
06:06:19 <Myrl-saki> Bad data structure.
06:11:35 <quicksilver> what anks first wrote should be legal with Rank2Types, no?
06:12:04 <merijn> quicksilver: You couldn't use it in many places because it'd be Impredicative without the Existential
06:12:20 <bernalex> what are some good and simple examples to demonstrate Monoid m => a -> m for foldMap?
06:13:06 <Myrl-saki> "The isPrefixOf function takes two lists and returns True iff the first list is a prefix of the second."
06:13:06 <merijn> bernalex: Sum?
06:13:09 <Myrl-saki> Totally informative lol
06:13:10 <E4xoi> Sum . length ? 
06:13:12 <quicksilver> merijn: of course.
06:13:15 <merijn> > foldMap Sum [1..10]
06:13:17 <lambdabot>  Sum {getSum = 55}
06:13:30 <bernalex> merijn: that seems to be the most commonly used example
06:13:36 <nshepperd> the only total value of 'forall b. Ord b => [(b,a)]' is []
06:13:47 <Myrl-saki> fold ["a", "b"]
06:13:52 <Myrl-saki> > fold ["a", "b"]
06:13:53 <lambdabot>  "ab"
06:14:07 <eikke> :t fold
06:14:09 <nshepperd> exists b. would be more useful
06:14:09 <lambdabot> (Foldable t, Monoid m) => t m -> m
06:15:07 <Myrl-saki> Hmmm
06:15:16 <bernalex> :info Sum
06:15:20 <bernalex> @info Sum
06:15:20 <lambdabot> Sum
06:15:45 <bernalex> thank you, lambdabot. you are ever so helpful.
06:16:08 <merijn> No one ever remembers lambdabot has no info :p
06:16:32 <bernalex> doesn't it?
06:16:35 <bernalex> @info sum
06:16:36 <lambdabot> sum
06:16:38 <merijn> No, never has
06:16:40 <bernalex> @info lolwtf
06:16:40 <lambdabot> lolwtf
06:16:43 <bernalex> right.
06:16:45 <merijn> info autocorrects to echo
06:16:46 <bernalex> @src Sum
06:16:46 <lambdabot> Source not found. Are you on drugs?
06:16:51 <merijn> Or something like that
06:17:01 <merijn> "newtype Sum a = Sum { getSum :: a }"
06:17:19 <bernalex> I'm actually looking for where it is defined :p
06:17:26 <merijn> Data.Monoid, afaik
06:17:44 <bernalex> right you are
06:19:56 <quicksilver> bernalex: don't ask us, ask hoogle - http://hoogle.haskell.org/?hoogle=Sum
06:19:58 <quicksilver> (or hayoo)
06:20:22 <bernalex> I used hoogle for it.
06:23:47 <quicksilver> > foldMap (\a -> (Sum 1, Sum a, Sum (a*a))) [2,2,1,2,4,2,8]
06:23:49 <lambdabot>  (Sum {getSum = 7},Sum {getSum = 21},Sum {getSum = 97})
06:24:04 <quicksilver> bernalex: ^^ calculate count, sum and square-sum (statistical moments) in a single pass
06:25:41 <bernalex> quicksilver: that's neat
06:25:53 <Myrl-saki> Welp, I need some backtracking.
06:25:55 <Myrl-saki> List monad to the rescue?
06:31:41 <Myrl-saki> Ugh.
06:37:12 <jophish> hmm, It's odd that [(n!) | n <- [0..]] is just as fast as scanl' (*) 1 [1..], where (!) n = product [2..n]
06:37:57 <jophish> I wonder if ghc is optimizing the former to run in linear time
06:42:18 <ttt_fff> is there a trivial way to tell ghc "build a gigantic binary for me which statically links everything you need" -- because we're going to move you to another linux machine, and need you to run there? (i..e machine it runs on != machine it was developed on)
06:44:34 <echo-area> Does -static work that way?
06:44:44 <mauke> that's the default
06:44:54 <mauke> except for libgmp IIRC
06:45:19 <bartavelle> why exactly is my church-encoded parser slightly faster than something like Parser a = Parser (ByteString -> Maybe (a, ByteString) ?
06:45:31 <bartavelle> attoparsec uses the same trick, but I don't know why it results in faster code
06:47:09 * hackagebot data-layer 1.0.3 - Data layering utilities. Layer is a data-type which wrapps other one, but keeping additional information. If you want to access content of simple newtype object, use Lens.Wrapper instead.  https://hackage.haskell.org/package/data-layer-1.0.3 (danilo2)
07:02:09 * hackagebot simplest-sqlite 0.0.0.1 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.0.0.1 (YoshikuniJujo)
07:04:00 <S11001001> bartavelle: I'm not sure, but wouldn't be the first time. Control.Monad.Free.Church is the cheapest free monad representation in the free package
07:04:24 <merijn> I think it's due to church encoding doing less allocation?
07:04:33 <merijn> i.e. it's basically manual way to achieve fusion?
07:05:33 <bartavelle> yeah I thought about the "less allocation" theory, but I don't really have the heart to understand the core
07:05:40 <bartavelle> I suppose this makes sense
07:06:48 <Myrl-saki> @pl (\x y -> (Set.fromList x, Set.fromList y))
07:06:48 <lambdabot> (. Set.fromList) . (,) . Set.fromList
07:06:54 <Myrl-saki> Holy shit, that's ugly.
07:07:09 * hackagebot simplest-sqlite 0.0.0.2 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.0.0.2 (YoshikuniJujo)
07:08:11 <Myrl-saki> (\x -> (Set.fromList x, Set.fromList x)
07:08:14 <Myrl-saki> @pl (\x -> (Set.fromList x, Set.fromList x)
07:08:15 <lambdabot> (line 1, column 40):
07:08:15 <lambdabot> unexpected end of input
07:08:15 <lambdabot> expecting variable, "(", operator or ")"
07:08:19 <Myrl-saki> @pl (\x -> (Set.fromList x, Set.fromList x))
07:08:19 <lambdabot> liftM2 (,) Set.fromList Set.fromList
07:08:29 <opqdonut> Myrl-saki: how about just fromList *** fromList
07:08:48 <bartavelle> Myrl-saki, look at the operators in Control.Arrow
07:08:54 <bartavelle> what opqdonut said
07:09:33 <Myrl-saki> opqdonut: Ah, right.
07:09:53 <dududuedu> \exit
07:12:10 * hackagebot simplest-sqlite 0.0.0.3 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.0.0.3 (YoshikuniJujo)
07:12:38 <keiopa> hi guys, i have a project for school that i need to finish and i'm new to haskell... i need a hand in this work, if anyone could help me out i'd be appreciated =)
07:13:27 <rom1504> doing haskell in school, that's surprising
07:14:26 <Myrl-saki> rom1504: I agree, and I'm very jealous.
07:15:00 <keiopa> don't be mean xD
07:16:29 <Dodek> if by "school", a university is meant, then it's not really that surprising
07:16:59 <Myrl-saki> Dodek: Still pretty surprising.
07:17:06 <Myrl-saki> Dodek: Since after all, Java is the one true savior.
07:17:10 * hackagebot diversity 0.7.1.1 - Return the diversity at each position by default for all sequences in a fasta file  https://hackage.haskell.org/package/diversity-0.7.1.1 (GregorySchwartz)
07:17:44 <mauke> keiopa: if you don't ask a question, you're not going to get much help
07:18:38 <keiopa> i was used to imperative programing and now i'm working and studying and i can't keep up with all classes, u see my point of standing here, beside that, the project is for 2 and i'm working alone so...yes, i need some help
07:19:37 <Dodek> Myrl-saki: nah, not really.
07:20:21 <Dodek> i mean, my university was indeed pretty exceptional, as almost every class used different language
07:20:52 <Dodek> but most good universities expose students to other paradigms, so some haskell/ocaml/erlang/scheme exposure is not really unexpected
07:21:10 <Myrl-saki> Dodek: That's intereszting.
07:21:20 <keiopa> by any chance did u hav 12 difrent clases?
07:21:21 <mauke> hungarian detected
07:27:10 * hackagebot simplest-sqlite 0.0.0.4 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.0.0.4 (YoshikuniJujo)
07:28:57 <Myrl-saki> :t (\xs -> (Set.fromList xs, Set.fromList $ map ((,) =<< length) xs))
07:28:59 <lambdabot>     Not in scope: ‘Set.fromList’
07:28:59 <lambdabot>     Perhaps you meant one of these:
07:28:59 <lambdabot>       ‘Seq.fromList’ (imported from Data.Sequence),
07:29:06 <Myrl-saki> @pl (\xs -> (Set.fromList xs, Set.fromList $ map ((,) =<< length) xs))
07:29:06 <lambdabot> liftM2 (,) Set.fromList (Set.fromList . map ((,) =<< length))
07:29:17 <Myrl-saki> Eh....
07:29:31 <Myrl-saki> No `join` hacks or anything?
07:29:54 * Myrl-saki shrugs
07:30:49 <frerich> I think if you start with '(,) =<< length' there's nowhere you can go.
07:30:53 <KaneTW> :t S.fromList &&& S.fromList (map ((,) =<< length))
07:30:55 <lambdabot>     Couldn't match type ‘S.Set’ with ‘(->) [a]’
07:30:55 <lambdabot>     Expected type: [a] -> c'
07:30:55 <lambdabot>       Actual type: S.Set c'
07:31:35 <KaneTW> :t S.fromList &&& S.fromList . map ((,) =<< length)
07:31:37 <lambdabot> (Ord (t a), Foldable t) => [t a] -> (S.Set (t a), S.Set (Int, t a))
07:31:40 <KaneTW> that?
07:31:59 <KaneTW> hm, no
07:32:00 <Myrl-saki> KaneTW: No way to make S.fromList into one?
07:32:01 <KaneTW> or maybe
07:33:25 <KaneTW> :t (id &&&)
07:33:26 <lambdabot> (c -> c') -> c -> (c, c')
07:35:05 <KaneTW> :t S.fromList . id &&& map ((,) =<< length)
07:35:06 <lambdabot> (Ord (t a), Foldable t) => [t a] -> (S.Set (t a), [(Int, t a)])
07:35:21 <KaneTW> hold on, wrong precedence
07:35:26 <KaneTW> :t S.fromList . (id &&& map ((,) =<< length))
07:35:29 <lambdabot>     Couldn't match type ‘([t a1], [(Int, t a1)])’ with ‘[a]’
07:35:30 <lambdabot>     Expected type: [t a1] -> [a]
07:35:30 <lambdabot>       Actual type: [t a1] -> ([t a1], [(Int, t a1)])
07:35:36 <KaneTW> rip
07:35:39 <mauke> .
07:37:49 <S11001001> keiopa: In general, people are happy to help out with specific questions, as mauke pointed out.  But people are unwilling to make an open-ended commitment to helping with a project in general; that's potentially a big, unvaluable time investment.  Here's what I think will work best: continue working on the project.  When you have a specific question about
07:37:50 <S11001001> Haskell's behavior in some particular case, or how to solve a specific issue, break it into a little self-contained piece of code and post it on lpaste.net/new/haskell, and share that with this channel, along with your question.
07:38:24 <Myrl-saki> Hahaha... damn. Coffee's good.
07:39:28 <KaneTW> i should go amke some
07:39:55 <KaneTW> i can't find a way to make S.fromList into one
07:40:17 <S11001001> KaneTW: you want it at different element types right?
07:40:18 <keiopa> ok <S11001001> i'll do my best =)
07:40:19 <Myrl-saki> KaneTW: :)
07:40:22 <SrPx> Seriously, how are you supposed to learn type theory / category theory, when for each concept you do not understand and go look for a definition, that definition is a pile of at least a dozen other concepts you do not understand, and so on?
07:40:25 <Myrl-saki> KaneTW: Good luck.
07:40:48 <Myrl-saki> SrPx: Well, you recursively do that, until you get a concept that you understand. :P
07:40:51 <SrPx> Is there ever a point where you google something like "infinity groupoid", read the explanation and actually understand it, and can then proceed with the text you was reading? "In category theory, a branch of mathematics, an ∞-groupoid (also called Kan complex) is a fibrant object in the category of simplicial sets (with the standard model structure). It is an ∞-category generalization of a groupoid, a category in which every mor
07:41:34 <KaneTW> SrPx: dunno, i've had a good experience with types and programming languages for learning about type systems (it's more practical than pure type theory books, though)
07:41:50 <icen> Wikipedia is never the starting point for mathematics; it's always in the language someone familiar with the subject would use.
07:42:07 <KaneTW> get a good book and read it
07:42:11 <icen> I've found that getting a good introductory textbook helps an awful lot
07:42:34 <S11001001> KaneTW: so the problem is that the combinator that can expand S.fromList at two types is rank-2; that stuff won't be inferred, you have to write it yourself, and specific to the type expansions you're trying to get
07:42:42 <icen> Since it could be seen as the 'base case' of your recursive understanding
07:42:51 <KaneTW> S11001001: yes
07:44:19 <S11001001> dup :: (c a, c b) => (forall i. c i => i -> f i) -> (a -> f a) -> (b -> f b)
07:44:39 <S11001001> er, tuple not -> at the end
07:46:47 <KaneTW> with
07:46:48 <KaneTW> :t mapTuple
07:46:49 <lambdabot> (forall a. [a] -> S.Set a) -> ([b], [c]) -> (S.Set b, S.Set c)
07:47:03 <KaneTW> it still fails because it's missing an ord context
07:47:11 <johnw> SrPx: read http://www.sandiego.edu/~shulman/papers/synhott.pdf
07:47:34 <KaneTW> oh right
07:47:36 <KaneTW> :t S.fromList
07:47:38 <lambdabot> Ord a => [a] -> S.Set a
07:47:40 <KaneTW> ?undef
07:47:40 <lambdabot> Undefined.
07:48:41 <KaneTW> ?let mapTuple :: (Ord b, Ord c) => (forall a. Ord a => [a] -> S.Set a) -> ([b], [c]) -> (S.Set b, S.Set c); mapTuple f (x,y) = (f x, f y)
07:48:42 <lambdabot>  Defined.
07:48:52 <KaneTW> :t id &&& map ((,) =<< length) >>> mapTuple S.fromList
07:48:53 <lambdabot> (Ord (t a), Foldable t) => [t a] -> (S.Set (t a), S.Set (Int, t a))
07:48:56 <KaneTW> yay
07:55:44 <SrPx> "Now, at the turn of the 21st century, a new theory has emerged to challenge the foundational ascendancy of sets." interesting I talk to many math teachers and nobody seems to even know what category theory is about :P
07:56:11 <SrPx> much less HoTT, of course
07:56:12 <jeltsch> How can I use unboxed pair syntax? -XMagicHask doesn’t seem to enable itd.
07:56:24 <jeltsch> Hask → Hash, itd → it
07:59:00 <mauke> jeltsch: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/primitives.html#unboxed-tuples
07:59:17 <jeltsch> mauke: Thanks.
08:00:20 <johnw> unboxed tuples makes me think there should be an unboxing video on YouTube or something
08:02:12 * hackagebot simplest-sqlite 0.0.0.5 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.0.0.5 (YoshikuniJujo)
08:13:12 <mnoonan> am I crazy, or does the literature on types use "structural subtyping" to mean two exactly opposite things?
08:13:49 <mnoonan> one being { L_i : t_i } <: { L'_j : t'_j } when L_i are a subset of L'j with t_i = t_j
08:14:17 <mnoonan> and the other begin { L_i : t_i } <: { L_i : t'_i } (note no j) with t_i <: t'_i?
08:14:20 <mnoonan> *being
08:15:43 <titusg> I'm trying to install stack on ubuntu. Added the repository, reloaded but still there is no stack package available...any ideas?
08:17:53 <bartavelle> titusg, did you "apt-get update" ? if so, do you see the fpcomplete repo in the list of downloaded things ?
08:18:10 <titusg> yes and yes
08:18:10 <bartavelle> if it is not, it means you didn't properly set the source.list file
08:18:15 <bartavelle> with no errors ?
08:18:19 <titusg> yep
08:18:32 <titusg> confusing...
08:20:03 <keiopa> hey, i had a txt file with a extension i don't recall what it was that i used to load in my prog by using "ghc sokoban.hs "filename.extension"" and i'd get the output from the program runing that file....anyone has a clue for the extension i could use to get this going?
08:20:06 <titusg> can't reach http://download.fpcomplete.com/ubuntu/trusty either...
08:20:14 <titusg> in a browser that is
08:21:03 <titusg> oh actually, I can but I get a 404: The specified key does not exist. Key: ubuntu/trusty
08:23:51 <keiopa> "warning: ignoring unrecognised input 'mapa.txt'
08:27:41 <elazul> hello, I have a question about typeclasses: I am trying to understand the instance of "Functor" of the function-type-constructor (->), written as "instance Functor ((->) e) where fmap = ." . My question is about the "e" in the definition. Do I understand it correctly, that I should read this definition as "for all e, (->) e is an instance of the typeclass Functor"?
08:27:50 <geekosaur> keiopa, I wonder if you're actually looking for runghc instead of ghc?
08:28:15 <elazul> In other words: I am actually defining a family of instances, parameterized by "e"?
08:31:39 <keiopa> Yay! not working 100% yet but it's starting to kick :D
08:31:49 <keiopa> ty geekosaur>
08:39:42 <anks> is there sthing like composition for fmap? f n = a <$> b n  --->   f = a <?> b 
08:40:20 <keiopa> can anyone tell me why the file isn't loading to the program but the prog is working?  http://i.imgur.com/hfptWU5.png
08:40:30 <keiopa> sry but i'm new at this
08:40:45 <quicksilver> anks: (fmap a) . b
08:41:37 <quicksilver> elazul: not really, no.
08:42:06 <quicksilver> elazul: or, well yes but it's a special family
08:42:13 * hackagebot haskell-gi-base 0.10 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.10 (inaki)
08:42:15 * hackagebot haskell-gi 0.10 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.10 (inaki)
08:42:17 * hackagebot gi-atk 0.2.16.10 - Atk bindings  https://hackage.haskell.org/package/gi-atk-0.2.16.10 (inaki)
08:42:19 * hackagebot gi-cairo 0.1.14.10 - cairo bindings  https://hackage.haskell.org/package/gi-cairo-0.1.14.10 (inaki)
08:42:26 <quicksilver> elazul: it's a family in which every instance is 'the same' : a "parametric" familiy.
08:42:28 <orion> Hey, anyone familiar with shake and custom cabal builders?
08:43:45 <anks> keiopa: i dont know why isnt loading but i notice that you can replace your divide function with cleaner definition: divide = show . divide2
08:43:49 <elazul> quicksilver: thanks! can the implementation be dependent upon the parameter in a family?
08:44:44 <quicksilver> elazul: no.
08:44:57 <quicksilver> elazul: that's exactly what I meant by it being parametric. It can't depend on that parameter.
08:45:23 <quicksilver> just like "length :: [a] -> Int" is in a sense a family of functions, but actually it's only one function. It can't depend on a.
08:46:10 <keiopa> can anyone see why the map.mp isn't being loaded to the compiled program? http://i.imgur.com/GpHnuNy.png --> image of code and output
08:46:48 <quicksilver> keiopa: because you don't have any code to load files.
08:46:56 <quicksilver> interact does not load files
08:47:03 <quicksilver> interact reads STDIN
08:47:08 <quicksilver> perhaps you meant to use
08:47:14 <quicksilver> runghc sokointro.hs < mapa.mp
08:47:44 <keiopa> tnk u sir =D
08:48:22 <keiopa> quicksilver i think i lov you :D
08:48:46 <elazul> quicksilver: Ah, ok. Is this understanding correct: if there's type- variables in the instance line, haskell will regard the implementation as a family indexed by the types, but the implementation may not depend on these parameters (and the implementation is in some sense the same for all instances)?
08:50:03 <quicksilver> elazul: yes.
08:50:08 <quicksilver> elazul: just like functions, really
08:50:32 <quicksilver> makeOneElementList :: a -> [a]; makeOneElementList x = [x]
08:50:33 <elazul> quicksilver: thx so much :)
08:58:13 * hackagebot gi-gdk 0.3.16.10 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-0.3.16.10 (inaki)
08:58:16 * hackagebot gi-gdkpixbuf 0.2.31.10 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-0.2.31.10 (inaki)
08:58:18 * hackagebot gi-gio 0.2.44.10 - Gio bindings  https://hackage.haskell.org/package/gi-gio-0.2.44.10 (inaki)
08:58:19 * hackagebot gi-glib 0.2.44.10 - GLib bindings  https://hackage.haskell.org/package/gi-glib-0.2.44.10 (inaki)
08:58:22 * hackagebot gi-gobject 0.2.44.10 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-0.2.44.10 (inaki)
09:03:23 * hackagebot gi-gtk 0.3.16.10 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-0.3.16.10 (inaki)
09:03:26 * hackagebot gi-javascriptcore 0.2.4.10 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-0.2.4.10 (inaki)
09:03:27 * hackagebot gi-notify 0.2.31.10 - Notify bindings  https://hackage.haskell.org/package/gi-notify-0.2.31.10 (inaki)
09:03:30 * hackagebot gi-pango 0.1.36.10 - Pango bindings  https://hackage.haskell.org/package/gi-pango-0.1.36.10 (inaki)
09:03:32 * hackagebot gi-soup 0.2.50.10 - Soup bindings  https://hackage.haskell.org/package/gi-soup-0.2.50.10 (inaki)
09:08:34 * hackagebot gi-vte 0.0.40.10 - Vte bindings  https://hackage.haskell.org/package/gi-vte-0.0.40.10 (inaki)
09:08:36 * hackagebot gi-webkit 0.2.4.10 - WebKit bindings  https://hackage.haskell.org/package/gi-webkit-0.2.4.10 (inaki)
09:08:38 * hackagebot simplest-sqlite 0.0.0.6 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.0.0.6 (YoshikuniJujo)
09:17:07 <lpsmith> Hmm,  I don't suppose anybody has an opinion on https://hackage.haskell.org/package/linux-inotify-0.3.0.0/docs/System-Linux-Inotify.html#v:getEvent
09:17:32 <lpsmith> Specifically, the behavior of getEvent versus getEventNonblocking on closed inotify descriptors.
09:19:33 <lpsmith> I'm kinda wondering if getEventNonblocking should throw an exception instead of returning Nothing.
09:23:24 <frankier> Is it actually possible to get Data.Binary.Get with Control.Monad.Trans.Except? When I try I get an exception like The second argument of ‘ExceptT’ should have kind ‘* -> *’ but ‘Get MyFoo’ has kind ‘*’
09:24:40 <glguy> ExceptT e Get MyFoo, not ExceptT e (Get MyFoo)
09:25:26 <frankier> Oh. Oops! Cheers
09:28:15 * hackagebot simplest-sqlite 0.0.0.7 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.0.0.7 (YoshikuniJujo)
09:33:44 <SrPx> "An ∞-groupoid is just a fibrant object in the category of simplical sets." I just noticed that is isomorphic to that "monad is just a monoid" statement. Is that a running joke among geniuses or something?
09:34:23 <keiopa> and back again...
09:34:41 <tommd> Welcome back.  We all where wondering when you'd get here.
09:35:19 <SrPx> Me? Heh
09:35:34 <keiopa> =,= 
09:35:55 <keiopa> i'm trying my best not to disturb a lot =P
09:38:15 * hackagebot linearscan 1.0.0 - Linear scan register allocator, formally verified in Coq  https://hackage.haskell.org/package/linearscan-1.0.0 (JohnWiegley)
09:38:17 * hackagebot linearscan-hoopl 1.0.0 - Makes it easy to use the linearscan register allocator with Hoopl  https://hackage.haskell.org/package/linearscan-hoopl-1.0.0 (JohnWiegley)
09:38:45 <keiopa> so, after prog up and runing "sokointro.hs" now i got the task one done as well... "t1.hs" is it possible to combine these two? sokointro gets a input and gives me a ([String],[String]) now i want to get that ([String],[String]) and run it in t1.hs....can anyone help me out?
09:42:04 <keiopa> looks like this http://i.imgur.com/QDWnnMC.png
09:43:52 <tommd> I think people need to update https://wiki.haskell.org/Haskell_user_locations - it was made/last touched back in the 2007 hay days.
09:44:06 <tommd> Phrased another way - who are all you people!
09:44:57 <keiopa> better "visualization" http://i.imgur.com/DW1YUMz.png
09:48:16 * hackagebot stack 0.1.8.0 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-0.1.8.0 (borsboom)
09:50:06 <keiopa> anyone?
09:50:57 <SrPx> keiopa: hey you're brazilian aren't you?
09:51:16 <SrPx> keiopa: no, portuguese
09:51:18 <keiopa> u were close but no...i'm portuguese
09:51:22 <bergmark> tommd: haskellers is more up to date http://www.haskellers.com/ (has irc names too)
09:51:52 <keiopa> SrPx why do ou ask?
09:52:15 <SrPx> keiopa: just wondered from reading portuguese words on your code (I don't know how to help, though)
09:52:16 <kadoban> Data.ByteString.Char8 is the devil.
09:52:59 <keiopa> kk, np i will keep hitting the keys =P
09:53:57 <keiopa> if my knowledge in portuguese is helpfull in anyway just ping me :)
09:56:29 <Welkin> kadoban: it is useful if you know you only need ascii
09:57:32 <kadoban> Welkin: In which case it's what, like a minor premature optimization over just using Text?
10:07:54 <phaazon> hm
10:08:04 <phaazon> Network.Socket.listen doesn’t block; is that normal?
10:08:23 <phaazon> I guess it’s the accept function that should block
10:08:41 <geekosaur> listen just sets the queue size and registers interest in incoming connections
10:08:55 <orion> What does 'ANN' stand for (on the mailing list)?
10:08:59 <johnw> Announce
10:09:13 <phaazon> geekosaur: ok, thanks
10:09:25 <orion> When you publish a package, should/can you post it to the haskell@haskell.org list?
10:09:58 <johnw> orion: I'd think so; my question was whether I should post it to libraries@, but since that's what other people were doing...
10:13:08 <phaazon> ok it works, thanks!
10:13:42 <quicksilver> libraries@ is for discussing the core libraries
10:14:04 <quicksilver> haskell and haskell-cafe are both used to announce library uploads
10:14:09 <quicksilver> although many packages don't announce at all :( :(
10:15:08 <kritzcreek> How would I add a State part to the example in https://hackage.haskell.org/package/freer <- Should I add get and put primitives to my algebra or can I mix in the Freer State implementation?
10:15:40 <kritzcreek> doesn't necessarily need to be freer I would be fine with using free if that makes it easier
10:25:02 <phaazon> hm
10:25:11 <phaazon> I want to be able to send (Binary a) => a through sockets
10:25:17 <phaazon> so, I end up with ByteString
10:25:22 <phaazon> how should I pass that to my socket?
10:26:34 <phaazon> hm, usAsCString, I guess
10:38:46 <m1dnight_> Is there an easy way to force value to be  a certain typeconstructor? I have a datatype "Type" which has a lot of dataconstructors. Each typecheck function has to test to make sure a type is correct. E.g., `do typ <- typeCheck f ; case typ of (Type1 x) -> do ... ; _ -> fail "wrong type supplied" }`
10:38:56 <m1dnight_> Is there a cleaner way to write that? It causes a lot of horrible indentation levels
10:40:07 <m1dnight_> Is there a cleaner way to write that? It causes a lot of horrible indentation levels
10:40:10 <m1dnight_> (sorry about that)
10:42:27 <Welkin> m1dnight_: make them all different types then
10:42:55 <m1dnight_> Hm, that would make it more verbose in another way :> I thought about that before.
10:43:03 <aweinstock> m1dnight_: what type is "x" in that example? just make a function that operates on that
10:43:15 <Welkin> you are confusing the terms type and data constructor
10:43:37 <m1dnight_> oh sorry
10:48:24 <Xandaros> When using cabal repl in my project, it autoloads one of the modules, but does not load any other ones, even though I specified them in exposed-modules. How can I automatically bring other modules into scope?
10:48:44 <dcoutts> Xandaros: this is for an exe I presume?
10:48:50 <Xandaros> library
10:49:32 <dcoutts> Xandaros: are you sure they're not all loaded? you can switch module focus with :m
10:49:56 <Xandaros> Yes, they are loaded, but I want to have multiple modules in scope when I launch repl
10:50:13 <dcoutts> use :m
10:50:56 <Xandaros> Well, I tried putting that into my .ghci, but it tries to execute that before it loads the modules...
10:51:36 <dcoutts> Xandaros: what does :show modules say after you start up?  might have to paste it
10:52:06 <dcoutts> I mean hpaste or whatever
10:53:10 <Xandaros> http://lpaste.net/145662
10:53:21 <Xandaros> Like I said - loads just fine, but I want them to be in scope automatically
10:53:58 <Xandaros> In particular, I want Network.Coap.CoapServer in scope, since it contains a function to start a test server, but I'd also like Data.Coap to test individual functions
10:55:20 <Xandaros> Changing the order of the exposed-modules field does change which module gets loaded automatically, so I changed that to the more important module, but I'd like to have all non-internal modules at my disposal
10:55:31 <Xandaros> Even if I have to specify them manually
11:02:15 <dcoutts> Xandaros: so it shows *Data.Coap>  meaning lots of them, though I can't find which ghci command shows which ones that actually is
11:02:40 <dcoutts> Xandaros: I'm not sure there's a lot we can do about this, this is the standard ghci behaviour when we just call ghci $all-the-modules
11:04:58 <hexagoxel> Xandaros: it seems to be possible to put into .ghci the following: ":load Foo.Bar\nimport Foo.Bar"
11:05:34 <hexagoxel> Xandaros: then `Foo.Bar` will be imported _in addition_ to what would be automatically imported otherwise.
11:10:37 <monochrom> I would write one file that imports the modules you want. I would :load that file.
11:12:58 <monochrom> at any rate, GHC user's guide sections 2.2 and 2.4 have all information you need
11:13:02 <dcoutts> Xandaros: so we worked out what the * means, it means you're "inside" that module, and can see all of its internal functions, not just its exports
11:13:50 <Xandaros> dcoutts: yes, it does. it means it's interpreted
11:13:58 <dcoutts> Xandaros: no, not just that
11:14:36 <dcoutts> but it's true you can only get that mode when in interpreted mode
11:20:22 <orion> dcoutts: Hey, do you have a few minutes to spare?
11:34:00 <athan> Is there a way to do substring queries with persistent?
11:36:58 <KaneTW> what do you mean? `LIKE`?
11:38:02 <Reiser> If I have an Either a b, but don't care about what the error is, is it a bad idea to simply convert this to a Maybe?
11:38:21 <Reiser> And for that matter, how can I do that, right now I have a small utility function doing it because I didn't see anything in Prelude
11:39:14 <magneticduck> Reiser: http://hayoo.fh-wedel.de/?query=Either+a+b+-%3E+Maybe+b
11:39:24 <magneticduck> and no, it's not really a bad idea per-se
11:39:29 <magneticduck> as long as the semantics are correct
11:39:57 <Reiser> Ah, I was using hoogle on the haskell site, I guess It's out of date
11:40:11 <KaneTW> hoogle only searches base libraries i believe
11:40:29 <Reiser> Oh, oh yeah I see so I wasn't wrong, there's nothing in the Prelude, I need the errors package
11:40:34 <Reiser> That's kind of a shame
11:40:57 <Reiser> Alright, thanks magneticduck
11:41:13 <Clint> the errors package is good stuff
11:42:11 <Reiser> I'll give it a look over
11:49:00 <ReinH> Reiser: The stackage hoogle also works well https://www.stackage.org/lts-3.14/hoogle?q=Either+a+b+-%3E+Maybe+b
11:49:47 <Reiser> Thanks for the tip, I didn't realise how gimped I've been all this time
11:49:51 <Reiser> I had no idea there were other hoogles
11:50:59 <merijn> You can build a local hoogle indexing everything you have installed locally too :)
12:03:13 <quicksilver> :t either (const Nothing) Just
12:03:15 <lambdabot> Either b a -> Maybe a
12:03:23 <quicksilver> :t preview (_Right)
12:03:25 <lambdabot> MonadReader (Either c a) m => m (Maybe a)
12:06:06 <KaneTW> :t preview (_Right) :: Either b a -> Maybe a
12:06:07 <lambdabot> Either b a -> Maybe a
12:11:12 <ReinH> Er, you don't need those parens...
12:12:02 <monochrom> dibblego! I just saw what you did to your email address on http://hackage.haskell.org/package/validation :)
12:13:02 <Reiser> quicksilver, just how bad a beating should I expect from you if I go and actually drop that in the middle of my function
12:15:11 <ReinH> monochrom: clever
12:15:12 <merijn> Reiser: Those are pretty benign and acceptable, the beatings don't come out until you start using partial functions
12:22:30 <kaidelong> Reiser: I would say it is a bad idea insofar as you can be agnostic over if it is a Maybe or Either in that case anyway
12:24:12 <kaidelong> in particular, you could use Control.Monad.Catch
12:24:36 <kaidelong> although that only works if the left type implements Exception
12:28:22 * hackagebot linux-inotify 0.3.0.1 - Thinner binding to the Linux Kernel's inotify interface  https://hackage.haskell.org/package/linux-inotify-0.3.0.1 (LeonSmith)
12:29:30 <kaidelong> the basic impulse is that before converting between concrete types, see if you can be polymorphic in them
12:30:02 <frerich> My attempts to make colleagues consider the benefits of Haskell finally gave some results! One of them managed to drop a whole load of JUnit tests simply by using more adequate types to reduce the set of possible values being passed to functions. :-)
12:30:12 * frerich scratches one for the good guys
12:32:07 <Reiser> kaidelong, let me see if I follow what you're saying, right now I just have a decode from cereal where I don't care if the decoding fails, and want the function to fit into my Maybe monadic code
12:32:40 <Reiser> Or rather, I don't care if OR why it fails
12:35:37 <ReinH> Well, I think you care *if* it fails.
12:36:08 <Reiser> Yeah fair enough, I'm being a little too general, but I mean it in the sense that, this is a function that runs in a loop processing messages
12:36:38 <Reiser> The messages it fails to process aren't a problem, so I care if it fails and explodes, but I don't care if it fails in the I'll carry on drinking my coffee sense
12:37:50 <dibblego> monochrom: stops spammers :)
12:37:51 <ReinH> Why not write a function from the Either to the action you want to process it with? e.g. either (\_ -> return ()) process =<< decode
12:38:16 <ReinH> or either logFailure process =<< decode, or w/e
12:39:41 <Reiser> I'm mostly doing this to learn Haskell, so I need to think about how that'll fit right now but
12:39:52 <Reiser> I don't want to log the failures
12:40:01 <ReinH> Ok, so the former
12:40:18 <Reiser> Right, but I'm not sure how to fit that into my function consisting of a bunch of Maybe steps
12:40:37 <arkeet> :t either (\_ -> return ()) ?process
12:40:39 <lambdabot> (Monad m, ?process::b -> m ()) => Either a b -> m ()
12:40:48 <Reiser> Ah
12:40:55 <arkeet> :t mapM_ ?process
12:40:57 <lambdabot> (Monad m, Foldable t, ?process::a -> m b) => t a -> m ()
12:41:06 <Reiser> Ok the type makes that way more obvious
12:41:37 <ReinH> Ah. If you're already in the Maybe monad then you probably just want hush.
12:41:54 <Copperis> what does the "?" add?
12:42:13 <Reiser> ReinH, that's more or less what I wanted at the start but I'm doubting my design after this conversation
12:42:41 <Reiser> All my steps fit cleanly into the Maybe monad until I want to decode which, also can fail but I don't care where in the Maybe monad I fail, or why
12:42:53 <Reiser> I really just want to throw away the error information and fail like I would if it was Maybe
12:43:01 <ReinH> Ok, then use hush.
12:44:20 <Reiser> errors package it is then
12:46:45 <ReinH> Or just define it yourself if you want.
12:47:28 <mmachenry> Is there a better way to list the type classes that another type class depends on rather than using lambdabot for @src?
12:48:23 * hackagebot bimaps 0.0.0.3 - bijections with multiple implementations.  https://hackage.haskell.org/package/bimaps-0.0.0.3 (ChristianHoener)
12:50:15 <frerich> mmachenry: I use ':i' in ghci for that.
12:51:43 <_m_ryan> hi how do i use readMay on case?
12:51:59 <mmachenry> frerich: ":i Num" for example does not tell me that in order to define a Num I need to have my type be Eq and Show first.
12:52:55 <mmachenry> Whereas...
12:53:00 <mmachenry> @src Num
12:53:00 <lambdabot> class  (Eq a, Show a) => Num a  where
12:53:00 <lambdabot>     (+), (-), (*)       :: a -> a -> a
12:53:00 <lambdabot>     negate, abs, signum :: a -> a
12:53:00 <lambdabot>     fromInteger         :: Integer -> a
12:53:11 <mmachenry> That gives me the eq and show
12:53:42 <mmachenry> Both tell me the member functions. :i tells me instances that exist in the prelude where as @src does not.
12:54:04 <dolio> That is not true anymore.
12:58:23 * hackagebot ADPfusion 0.5.0.0 - Efficient, high-level dynamic programming.  https://hackage.haskell.org/package/ADPfusion-0.5.0.0 (ChristianHoener)
13:11:35 <frerich> mmachenry: As dolio mentioned, you don't actually need to instantiate Eq and Show to get Num. OTOH, I think that if you have a reasonably recent ghci then you can try ':i Monad' to see that you need Applicative first.
13:12:05 --- mode: ChanServ set -q *!*@gateway/web/freenode/ip.31.3.244.59
13:19:02 <orion> Why is stackage nightly falling behind?
13:28:43 <mgsloan> orion: Good question, I've let people know.  Could be that there haven't been any package updates, but I doubt that's true for the last 3 days
13:28:59 <orion> mgsloan: Thanks.
13:32:05 <mmachenry> dolio: Is the @src in lambdabot old?
13:32:32 <Welkin> mmachenry: it isn't even real
13:32:36 <Welkin> it is hard-coded
13:32:54 <Welkin> instead, use hayoo or look in hackage directly
13:33:06 <Welkin> (or hoogle, for anything included in the platform)
13:33:22 <dolio> It's just a database of stuff taken from various sources.
13:33:42 <dolio> Some GHC source from some point in the past. Some Haskell 98 report definitions.
13:34:27 <dolio> Probably hasn't been updated in years.
13:35:12 <mmachenry> I see.
13:40:31 <marble_visions> hi all, I can't figure out why I am getting this error: http://pastebin.com/GUcbp8qK
13:41:14 <johnw> marble_visions: there are a few things wrong here
13:41:15 <marble_visions> to my understanding, I should get a new [Char], a.k.a. a String, with a newline character appended after each character
13:41:22 <johnw> map takes a function as its first parameter, not a string
13:41:38 <johnw> what were you expecting the result to be?
13:41:59 <frerich> marble_visions: Also, if you map a function over a list of Chars, the function will be applied to each char. You cannot apply '++ "\n"' to a char though (since (++) expects both arguments to be lists)
13:42:52 <marble_visions> johnw: oops, my fault: http://pastebin.com/5raeD1DE
13:43:24 <marble_visions> frerich: johnw: very helpful, thanks! :)
13:44:27 <johnw> now the function is of the wrong type, which makes me wonder what output you'd like to see
13:44:31 <johnw> frerich gave the reason
13:44:59 <Welkin> marble_visions: unlines
13:46:27 <marble_visions> Welkin: thanks, I was trying to implement my own as an exercise
13:46:53 <marble_visions> johnw: i want to get the CLI arguments and display them each on a line
13:47:19 <johnw> mapM_ putStrLn args
13:49:07 <marble_visions> ooh nice
13:50:58 <marble_visions> thanks all! going back to the exercises :)
14:10:47 <akfp3> how do I specify, in servant-client a POST that returns 200 OK with an empty body?
14:16:50 <akfp3> is there a data type for which aeson's encode returns ""?
14:18:03 <Cale> akfp3: Hopefully not.
14:18:26 <Cale> akfp3: That's not a valid JSON structure.
14:18:27 <monochrom> is that even legal JSON?
14:19:50 <hpc> top-level json needs to be a list or a dict
14:20:00 <hpc> (or whatever json calls it)
14:20:09 <mauke> s/list/array/; s/dict/object/; :-)
14:20:23 <monochrom> is {} a legal object?
14:20:24 <akfp3> I'm trying to represent a servant-client API that returns an empty response.  I'm not really interested in the json.
14:20:28 <hpc> monochrom: yes
14:20:31 <monochrom> nice
14:20:37 <Cale> akfp3: Use Null?
14:20:53 <akfp3> Cale: that renders as "null"
14:20:58 <Cale> Yes.
14:21:22 <johnw> or '[]
14:21:27 <Cale> If you're producing JSON, you have to produce something.
14:21:38 <monochrom> what do the non-empty reponses look like? perhaps from there you can extrapolate and design an elegant syntax for the empty response
14:21:39 <Cale> The empty string certainly isn't valid JSON
14:21:57 <johnw> isn't Post '[JSON] () what you want?
14:22:16 <Cale> (I don't know anything about servant)
14:22:48 <akfp3> johnw: that's what I tried, but servant then wants the server to respond with 204, not 200 with an empty body.
14:23:09 <bergmark> < hpc> top-level json needs to be a list or a dict -- not according to the latest rfc
14:23:23 <johnw> well, 204 means "no content", doesn't it?
14:23:42 <akfp3> johnw: yes, but 200 with empty body is also legal.
14:24:16 <hpc> bergmark: when did that change?
14:24:48 <johnw> I'm not sure how to "hack" servant to do things beyond its conventions
14:24:51 <Cale> Is there a problem with giving 204?
14:24:59 <Cale> That's still a successful code
14:25:06 <akfp3> Cale: yes, it's not my service.
14:25:14 <Cale> It seems more appropriate than 200 if there's an empty body
14:25:52 <bam365> johnw: are you the author of gitlib?
14:26:05 <johnw> bam365: I am
14:27:20 <bam365> johnw: if I get the Commit for the first commit in the repo, should commitParents for that commit be an empty list?
14:27:42 <johnw> yes, it should
14:28:25 <bam365> johnw: hrm, my program hangs when I do length . commitParents on that commit
14:28:41 <johnw> using gitlib-libgit2 as the backend?
14:28:48 <bam365> yes
14:28:53 <johnw> let me check
14:29:08 <Welkin> Cale: 204 is perfectly acceptable
14:29:12 <Welkin> 2xx means success
14:30:20 <johnw> bam365: you up for inserting some print statements?
14:30:28 <bam365> sure
14:30:31 <johnw> bam365: also, let's continue this in #gitlib
14:30:41 <bam365> ok
14:31:52 <Welkin> Cale: I often use `sendResponseStatus status200 ("" :: Value)`
14:43:29 * hackagebot hackager 1.3.0.1 - Hackage testing tool  https://hackage.haskell.org/package/hackager-1.3.0.1 (DavidTerei)
14:46:19 <frerich> johnw: I think it's kind of scary how deeply you are involved in many different projects, e.g. emacs, Haskell, Boost. I first head of you in the C++ context, later Haskell - and now via emacs. You are kind of omnipresent.
14:46:40 <frerich> Everytime I google to check whether "is it *that" John Wiegley?"
14:47:03 <hpc> TIL johnw is a big deal
14:47:42 <monochrom> wait til johnw gets his hands on PHP :)
14:48:18 <hpc> he can get his hands on acme-php any day :D
14:48:19 <Ralith> isn't that what happened to bos
14:50:10 <hpc> i wish i could keep up with the 1500 people in this channel
14:50:19 <hpc> #haskell-gossip anyone? ;)
14:51:31 <monochrom> will it talk about who is dating who? :)
14:53:43 <veyn> What is (>>) in a monad?
14:54:05 <monochrom> "x >> y" is defined as "x >>= \_ -> y"
14:56:15 <samba1> is there a way to perform something on the Left of an Either buried within a transformer stack, e.g. (e -> e2) -> StateT a (EitherT e m) r -> StateT a (EitherT e2 m) r
14:56:37 <samba1> I thought maybe using first from bifunctors and some shoving, but no luck
14:58:15 <nocturne777> I am writing REST-based services in Haskell with Snap. Could anyone of you give me some guidance as to how to organize files ?
14:58:46 <nocturne777> like do most of you have seperate files for data access layer and business layer
14:59:30 <nocturne777> I feel like not following that cliche approach that is common in Java application development
15:00:17 <ski> samba1 : do you need to change the type ?
15:01:05 <samba1> ski: yes
15:03:02 <samba1> I want to turn the (potential) Left into a more general Left (e.g. take a data Err1 = A | B | C and turn it into data Err2 = D | E | AnErr1 Err1)
15:03:24 <ski> samba1 : and you're using the `EitherT' package ?
15:04:06 <ski> something along the lines of
15:04:11 <samba1> I'm using Control.Monad.Trans.Either from the either package (indirectly, a library I'm using is giving me back values of EitherT)
15:04:21 <ski> @hoogle mapWriter
15:04:21 <lambdabot> Control.Monad.Trans.Writer.Lazy mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b
15:04:21 <lambdabot> Control.Monad.Trans.Writer.Strict mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b
15:04:21 <lambdabot> Control.Monad.Writer.Lazy mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b
15:04:27 <Clint> samba1: you might want to use ExceptT instead now
15:04:30 <ski> but for `EitherT', would be helpful here
15:04:37 <samba1> Oh, there is a bimapEitherT in that package
15:05:06 <samba1> Clint: I'm using servant, so the choice is made for me already
15:05:12 <Clint> ah
15:06:48 <samba1> so, bimapEitherT f id would work, except I need to get under StateT first
15:07:02 <ski> samba1 : you can use `hoist' in `mmorph' to get under it
15:07:03 <samba1> without running it, since I need to still be in that State
15:07:18 <ski> @hackage mmorph
15:07:18 <lambdabot> http://hackage.haskell.org/package/mmorph
15:11:54 <samba1> alright, that's working... in general this is very hard, though, to take a stack with some Either in it and add more ways of failure
15:12:07 <samba1> every single one has to be specially recast
15:12:39 <veyn> State is a monad, right?..
15:12:50 <shachaf> State s is a monad.
15:14:32 <Cale> (for each type s)
15:15:07 <shachaf> Well, I meant for some specific type s that I didn't tell you about.
15:15:15 <shachaf> But it also works for every other type s.
15:15:48 <glguy> secrets don't make friends
15:16:01 <glguy> Which type was it?
15:16:29 <shachaf> Look, glguy.
15:16:37 <shachaf> It's the same s that runST uses.
15:16:50 <shachaf> But I can't just give that away.
15:17:35 <glguy> Maybe you should let it loose, it always seems like it's trying to escape
15:18:05 <shachaf> Over my (rigid, skolem) dead body.
15:18:56 <dolio> We can tell you if you'll sign an NDA.
15:22:54 <shachaf> Someone pointed out that if f(x) = 1/(1-x), f^3 = id
15:23:12 <shachaf> Does that mean that a = [[[a]]] in some sense?
15:23:40 <shachaf> Some sort of seven tree thing?
15:24:12 <dolio> f^3?
15:24:26 <shachaf> f(f(f(x))) = x
15:24:37 <dolio> Right. My skepticism was that it works out that way.
15:24:54 <glguy> http://www.wolframalpha.com/input/?i=1%2F%281-%281%2F%281-%281%2F%281-x%29%29%29%29%29
15:24:59 <glguy> Wolframalpha confirms it
15:28:43 <dolio> Darn fractions messing up my intuitions about things being positive or negative by cubing the coefficient.
15:28:43 * hackagebot simplest-sqlite 0.0.0.8 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.0.0.8 (YoshikuniJujo)
15:29:15 <ezyang> Is there a more canonical name for FailingWriter mentioned here: http://comonad.com/reader/2012/abstracting-with-applicatives/ 
15:30:04 <dolio> It's actually not id, though. It's id with a hole at 0.
15:30:19 <Cale> One thing which messes with directly interpreting this combinatorially is that 1 - 1/(1-x) is not an invertible power series
15:30:23 <dolio> And 1.
15:30:41 <Cale> (in the ring of formal power series)
15:31:15 <dolio> So presumably [[[Bool]]] = Bool, but [[[()]]] /= ().
15:31:27 <Cale> heh
15:31:27 <glguy> [f 1, f (1/0), f 0] ==> [Infinity,-0.0,1.0]
15:31:53 <Cale> Yeah, x there isn't meant to be a real number :P
15:32:48 <Cale> (though you can try to interpret things like that, you quickly start having to worry about how things converge)
15:33:26 <arkeet> glguy: right, and a mobius transformation is uniquely determined by what it does to 3 points so.
15:33:34 <arkeet> m\"obius
15:33:40 <Cale> After all, 1/(1-2) is fine, but sum over k >= 0 of 2^k is not.
15:33:52 <arkeet> if it cycles 3 points then f^3 = id is obvious.
15:34:20 <arkeet> hm.
15:36:13 <arkeet> shachaf: the seven trees thing is just
15:37:01 <arkeet> a bijection between trees and 7-tuples of trees.
15:37:13 <arkeet> not between trees and trees of (trees of ...)
15:37:21 <arkeet> but hmm.
15:53:57 * hackagebot simplest-sqlite 0.0.0.9 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.0.0.9 (YoshikuniJujo)
15:56:50 <phaazon> woah
15:57:01 <phaazon> AllowAmbiguousTypes
15:57:03 <phaazon> what is that :(
15:57:25 <phaazon> load :: (Cache k r m,Load e k m a,To a r,MonadError e m,MonadIO m,Ord k) => Key k a -> m a
15:57:29 <phaazon> this is my type
15:57:34 <phaazon> GHC thinks it’s ambiguous
15:57:35 <phaazon> why?
15:57:43 <phaazon> oh
15:57:45 <phaazon> nevermind
15:57:48 <phaazon> I guess I know why
15:57:59 <phaazon> because I need functional dependencies
15:58:01 <phaazon> to reach r
16:00:33 <ezyang> Hmm, it would be nice if there were an applicative version of unless/when 
16:00:53 <Pamelloes> Is there a way to lock a TVar (i.e. prevent another thread from interacting with it)?
16:00:54 <dolio> Can't we just generalize the types?
16:00:59 <dolio> Now?
16:01:21 <ezyang> dolio: With AMP, we should be able to! Maybe I should file a request 
16:01:40 <ezyang> Pamelloes: STM does not support any sort of pessimistic concurrency at the moment 
16:01:42 <johnw> yes, please do
16:01:59 <ezyang> ugh, now I have to go through and find all the other combinators that can be generalized 
16:03:36 <Cale> Pamelloes: Perhaps you're looking for TMVar?
16:04:01 <ezyang> Cale: That doesn't lock in the traditional sense though :^) 
16:04:06 <Cale> right
16:04:20 <johnw> Pamelloes: 'atomically' ensure that every thread sees the TVar in a consistent state, why do you need to "lock"?
16:04:42 <ezyang> johnw: Fairness! 
16:04:55 <johnw> then behold, I offer you, MVars
16:05:30 <phaazon> gosh I don’t get it.
16:06:11 <Pamelloes> I'm working on a scheduler where there is a shared list of tasks that various threads can manipulate. However, when the tasks are being executed, I need to prevent them from being modified.
16:06:40 <Pamelloes> I was thinking of having a TVar [Task], which works great for manipulation of tasks, but I'm not sure what to do about actually running the task.
16:06:41 <phaazon> http://lpaste.net/145693
16:06:53 <phaazon> error in the below
16:06:56 <phaazon> I don’t get it :/
16:07:03 <phaazon> to me there’s no ambiguity
16:07:08 <phaazon> all type variables are reachable
16:08:30 <dolio> phaazon: You don't have m -> k r for dropCache, or k -> r me for cached.
16:09:03 <phaazon> what ?
16:09:12 <phaazon> ah
16:09:13 <phaazon> yeah
16:09:15 <phaazon> :–’
16:09:54 <Pamelloes> On second thought, I don't actually need to lock the list—rescheduling a task can be done before execution.
16:10:11 <Pamelloes> Well, I guess I don't have a problem—I was just overthinking things. :)
16:11:18 <ezyang> Huh, what's the difference between traverse and mapM 
16:12:19 <arkeet> :t traverse
16:12:21 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:12:21 <arkeet> :t mapM
16:12:23 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
16:16:49 <geekosaur> mapM -> traverse has already been raised a few times, iirc
16:19:21 <ezyang> oh! guard/rwhen/unless re already on Applicative 
16:19:31 <ezyang> I was just looking at too old docs haha 
16:20:31 <shachaf> arkeet: hi
16:20:41 <ezyang> Oh, reviewing Control.Monad, it looks like anything that had an 'm' in it has been kept as a Monad 
16:20:44 <arkeet> shachaf: hi
16:21:03 <ezyang> ...ap is Monad?! 
16:21:04 <shachaf> I was away but now I'm less away but it looks like you didn't say much.
16:21:18 <shachaf> ezyang: Presumably it's so that you can define instance Applicative F where (<*>) = ap
16:21:24 <shachaf> Like liftA and fmapDefault
16:21:59 <ezyang> oh makes sense 
16:22:12 <johnw> ezyang: ap was always to Monad what <*> was to Applicative, before AMP
16:22:23 <ezyang> OK, nvm 
16:22:47 <ezyang> then it looks like the only possible candidate for generalizing is forever and replicateM but I'm not going to lose sleep on that 
16:22:56 <ezyang> But this will be annoying until GHC bootstraps off of AMP haha 
16:28:12 <pikajude> i've always liked yesod, but i feel like there are probably lighter-weight frameworks around, aren't there?
16:28:28 <pikajude> all i've found is servant but it seems to be specifically designed for APIs
16:29:19 <johnw> yesod is likely the heaviest weight possible framework available
16:29:23 <johnw> so yeah, there are lighter ones
16:29:26 <tzh> pikajude: there's happstack
16:29:26 <frerich> pikajude: I like Scotty
16:29:27 <johnw> scotty, snap, happstack, etc.
16:29:43 <pikajude> ok i'll have to look at all of them
16:29:59 <frerich> pikajude: No. You'll only have to look at Scotty. ;->
16:30:06 <pikajude> scotty is too small. that's an easy choice
16:30:21 <johnw> then servant, snap or happstack
16:30:21 <pikajude> i tried snap before, but it was lacking a couple features yesod has (which i'm assuming all of these frameworks will do)
16:30:38 <pikajude> servant looks cute, and i might pick it instead
16:31:07 <pikajude> debatably legitimate fire alarm going off at work. i'll see you all later
16:31:28 <alpounet> pikajude: servant is not specific to APIs (as in webservice APIs), but it's younger so there isn't yet integration for all possible templating solutions 
16:35:10 <veyn> I seem to be having a bit of trouble with Read
16:35:35 <veyn> it's saying read is not a (visable) method of Read
16:35:55 <mauke> correct
16:36:13 <veyn> well...
16:36:17 <monochrom> find the documentation of Read for real to see what methods belong to Read
16:37:04 <mauke> read is a plain function (a wrapper around readsPrec)
16:38:25 <monochrom> at ghci you can also ":info Read" and see
16:38:45 <monochrom> but the doc page is probably better and say a bit more
16:40:17 <c_wraith>   Older GHC really makes me :(
16:40:58 <monochrom> you don't like newer GHC?
16:41:13 <monochrom> oh, you don't like older GHC
16:41:45 <monochrom> then there are two choices. don't work with older GHC. work with older GHC but demand a lot of money
16:43:28 <c_wraith> Where's the "force everyone else to upgrade" option?
16:43:41 <monochrom> that is under "don't work with older GHC"
16:44:37 <monochrom> make a stand. get across the message that your happiness is a lot of money. beat it into the thick skulls of people who rip you off.
16:44:48 <monochrom> s/is a lot/is worth a lot/
16:47:15 <c_wraith> Ultimately, I would judge that impractical in this case.  I want to contribute code to open libraries that works on 7.10, but is incredibly unwiedly to make work with other versions of GHC the library has decided to support.
16:47:28 <c_wraith> I think that means I am the people who rip me off.
16:48:19 <monochrom> yes, first you have to convinced yourself that you will only do "either what you like for free, or what you dislike for a large sum"
16:49:14 <monochrom> because, you know, by the time you spell out the exact wording "do what I dislike for free", it's downright masochist
16:49:58 <c_wraith> everyone loves hasochism.
16:58:26 <ezyang> There needs to be an applicative zipWith :/ 
16:59:00 <shachaf> Do you mean something other than liftA2?
16:59:02 <MarcelineVQ> liftA2?
16:59:46 <ezyang> yeah, I want an applicative effect in the zipping function 
17:00:11 <shachaf> Oh, something that you might call zipWithA.
17:00:15 <pavonia> > liftA2 (+) [1,2,3] [4,5,6]
17:00:18 <lambdabot>  [5,6,7,6,7,8,7,8,9]
17:00:25 <ezyang> shachaf: righto 
17:01:16 <shachaf> So just sequenceA (zipWith f xs ys)?
17:01:34 <ezyang> oh yes, that'd work 
17:13:25 <ania123> hi all
17:13:40 <bitemyapp> ania123: hi
17:14:00 * hackagebot rei 0.3.4.0 - Process lists easily  https://hackage.haskell.org/package/rei-0.3.4.0 (kerkomen)
17:14:37 <ania123> bitemyapp: are u a bot?
17:14:47 <Xe> ania123: shhhh
17:15:18 <Xe> don't feed into the robot uprising
17:15:29 <Xe> ania123: please don't pm me without asking
17:16:00 <ania123> may i?
17:25:24 <Welkin> ania123: yes, bitemyapp is our resident bot
17:25:43 <Welkin> it can do tricks if you give it the right commands
17:26:02 <ania123> can he/she dance?
17:26:04 <Welkin> in fact
17:26:07 <Welkin> we are all bots
17:26:13 <Welkin> you are the only human
17:26:26 <Welkin> your life is just an elaborate experiment
17:26:43 <Welkin> you are the star of your own television series
17:26:48 <Welkin> but it's not what you think
17:26:53 <ania123> :)
17:26:58 <Welkin> it is for our own robot entertainment
17:27:02 <Welkin> silly humans
17:27:12 <Welkin> or rather, human, since you are the only one
17:27:13 <hpc> twist: we are the televisions
17:27:29 <Welkin> when you die, your species will cease to exist
17:27:43 <ania123> robots never dies
17:27:51 <ania123> welkinn is a robot
17:27:54 <ania123> ------------
17:27:56 <Welkin> precisely
17:27:57 <ania123> conclude 
17:28:41 <ania123> hpc: hi
17:39:43 <pikajude> hmm, happstack is deprecated!
17:39:45 <pikajude> servant it is
17:40:56 <ania123> could one help me to formulate question in clear way: Write quicksort algorithm. Follow the algorithm execution step by step to sort the list [2,7,5,3] in decreasing order.
17:41:23 <bitemyapp> Welkin: I am bot-in-chief.
17:41:28 <bitemyapp> Welkin: I am also bear.
17:42:11 <pikajude> you can't really quicksort in haskell
17:42:39 <alunduil> pikajude, why not?  quicksort has an elegant recursive definition that seems to work in Haskell.
17:42:39 <ania123> it is not related to haskell... i want to ask students to write it in pseudocode
17:43:08 <ania123> i need just to check english and also whether it is clear
17:43:11 <Welkin> pikajude: you can, but not idiomatically
17:43:11 <pikajude> alunduil: you can't swap items in a list in haskell in a reasonable fashion
17:43:22 <pikajude> well, you can't swap items in a list at all, as far as i know
17:43:26 <Welkin> quicksort uses in-place sorting on arrays
17:43:27 <alunduil> pikajude, but you can reconstruct the list from the reordered stack.
17:43:35 <pikajude> but quicksort doesn't work that way
17:43:59 <alunduil> pikajude, that's right.  I'm thinking of another one.  Sorry for the noise.
17:43:59 <pikajude> deconstruction and reconstruction of the input is not quicksort
17:44:04 <pikajude> it's ok
17:44:17 <ania123>  Write quicksort algorithm. Follow the algorithm execution step by step to sort the list [2,7,5,3] in the decreasing order.
17:44:22 <ania123> is it clear?
17:44:31 <ania123> are articles used correct way?
17:44:39 <ania123> can one check it please?
17:44:49 <Welkin> the most idiomatic (and most beautiful in my opinion) sorting algorithm for haskell (and any functional language) is the merge sort
17:44:54 <Welkin> bottom-up merge sort
17:45:35 <pikajude> any attempt to sort a list in haskell is made more difficult by the fact that it's a linked list
17:46:03 <ania123> can one help me?
17:46:18 <Welkin> ania123: write a merge sort instead
17:46:31 <ania123> merge is easy
17:46:54 <ania123>  Write quicksort algorithm. Follow the algorithm execution step by step to sort the list [2,7,5,3] in the decreasing order.
17:46:54 <Welkin> for a quicksort you need to use mutable arrays, not lists
17:46:59 <ania123> here statement is clear?
17:47:03 <ania123> and english is ok?
17:47:26 <Welkin> ania123: this really isn't the place to get help with your english
17:47:53 <ania123>  Write quicksort algorithm. Follow the algorithm execution step by step to sort the array {2,7,5,3} in the decreasing order.
17:47:56 <ania123> like this?
17:48:34 <ania123> Welkin: here majority of ppl are english native speaker... so
17:48:34 <mniip> ania123, try ##english
17:48:46 <mniip> majority? doubt it
17:48:55 <chaoxu1> hi guys, newbie here, if I'm wondering how to use `where` for local variable only for `then` clause. I'd like that not seen by `else` clasue
17:49:18 <mniip> chaoxu1, can't
17:49:22 <E4xoi> chaoxu1: you can use a let instead
17:49:28 <mniip> where clauses are bound to declaratinos
17:49:43 <chaoxu1> i see, thanks
17:55:28 <athan> Hi everyone. Is there a `many1` for Alternative? Or maybe, at least Aeson? :\
17:59:14 <ski> athan : do you mean `some' ?
18:54:20 <bobajett> Hello. I am coming from a Perl background where Im used to going to CPAN to really quickly grasp how to use a module from its "Synopsis" section.
18:54:28 <bobajett> Being a newbie when I go to a hackage page, such as: https://hackage.haskell.org/package/mysql-simple
18:54:32 <bobajett> I don't know how to find how to use a package? There is no synopsis?
18:54:35 <bobajett> Do I have to understand how to use a package from look at the code in the "Modules" section on Hackage?
18:55:43 <Xe> usually they will have examples in the repo and test code
18:57:08 <Cale> bobajett: If you click on the top module there
18:57:12 <mniip> bobajett, well there appears to be one main module, Database.MySQL.Simple
18:57:15 <Cale> "Database.MySQL.Simple"
18:57:17 <mniip> if you click on it
18:57:19 <Cale> then there's some examples
18:57:21 <mniip> you will see documentation
18:57:33 <Cale> https://hackage.haskell.org/package/mysql-simple-0.2.2.5/docs/Database-MySQL-Simple.html
18:57:52 <bobajett> ah ok. Got it. So is there a convention - is that the convention? To have the top module document how to use a package?
18:58:07 <mniip> not really no
18:58:08 <Cale> Not all packages have great documentation of course, but the better ones will have some documentation somewhere
18:58:21 <mniip> thing is
18:58:30 <mniip> most packages export core functionality in some package
18:58:42 <Cale> Or if you're really lucky, they will be such that you don't even really need documentation because the types tell you everything you need to know.
18:58:54 <mniip> and it's usually very easy to deduce how to do something from the documented functions you have
18:59:06 <Cale> (But not every package can be so lucky)
18:59:50 <bobajett> I guess what Im pining for is that it would have been so nice if there was a Perl/"Synopsis" like convention. It makes it sooo easy to grasp how to use a package in like 2 minutes. :-)
19:00:06 <Cale> Well, in any case it still tends to be nice to have something -- usually things which implement simple data structures and the like can give information about complexity.
19:00:48 <bobajett> We should have a measure for reducing cognitive-complexity in learning how to use a package :-)
19:01:08 <Cale> Well, the main thing which reduces the cognitive complexity of using new code in Haskell is types.
19:01:21 <Cale> Types are the most important documentation because it's checked by the compiler
19:01:24 <bobajett> that makes sense.
19:01:40 <Cale> and they tell you how everything is supposed to fit together if they're designed well
19:02:13 <Cale> You can start from something which sounds like it accomplishes the task you want to perform, and then look at its arguments, and work out how to get values of those types recursively
19:02:49 <Cale> and just sort out how to use the entire library pretty quickly
19:03:10 <Cale> Depending on how well the types are designed
19:04:16 <Cale> If it seems like there isn't a way to get a thing that you're looking for, remember to pay attention to the list of instances below the documentation for data types.
19:04:18 <bobajett> thanks Cale - that explanation did light a bulb in my head! I see now how reading a Perl synopsis is more free form "ok what kind of parameters does their API consume, which are optional?" and reading a well typed Haskell API helps you fill in some blanks and some are filled in by the compiler.
19:04:45 <Cale> Occasionally you'll find that something happens to be an instance of Num or something, which you're meant to use to get values of that type :)
19:05:18 <bobajett> reading Haskell documentation imprints a bit of type-checking in your head!
19:07:45 <Xandaros> I have a ByteString containing between 0 and 4 bytes and I'd like to convert it to a Word32. Any ideas? The bytes are in big endian - an empty least would mean 0
19:08:11 <Xandaros> I'm using the binary package, but it doesn't seem to offer much help in this particular case
19:12:25 <pavonia> Xandaros: What determines the number of bytes to read?
19:13:03 <Xandaros> The length of the packet they arrive in
19:14:17 <geekosaur> I hope you aren't planning to do this over TCP, or you have your own packet protocol on top
19:14:40 <Xandaros> It's UDP, actually. But that aside, it's not my own protocol
19:14:50 <Xandaros> Just implementing it (CoAP)
19:15:56 <Cale> https://hackage.haskell.org/package/binary-0.7.6.1/docs/Data-Binary-Get.html#v:getWord32le
19:16:14 <Cale> (or similar with -be for big endian
19:16:15 <Cale> )
19:16:24 <Xandaros> In particular, this is about the options. I have the option number, so I know what kind of payload it has and the length
19:16:43 <Xandaros> Cale: If only it was that easy... "Not enough bytes!" for anything less than 4 bytes
19:16:49 <Cale> ahhh
19:17:23 <Cale> So you read a count of the number of bytes first?
19:17:36 <Cale> Is that itself a byte? Or bitflags, or what?
19:17:46 <pavonia> Can't you just get the bytes from the ByteString and fold them into a number?
19:18:05 <Xandaros> Well, it's... complicated. But I do parse that already, I put them in a datastructure containing the option number, the length and the payload
19:18:40 <Xandaros> Of course, I can just get the length of the payload from the length of the list containing it, but I'm storing it anyway
19:18:44 <Cale> oh, I see
19:19:00 <Cale> That's interesting, I didn't think that any protocols did that
19:19:22 <Cale> They tend to just be "whatever, here's a packet, it might not be aligned to anything"
19:19:36 <Xandaros> Well, it's meant for constrained devices communicating over low-bandwidth, lossy networks
19:19:56 <Xandaros> So it tries to compress everything down as far as possible
19:20:06 <Xandaros> Makes it rather annoying to parse, though :/
19:20:31 <Cale> yeah, maybe your best bet is just to BS.unpack
19:20:41 <Cale> and then case analysis on the list of up to 4 bytes?
19:20:53 <Cale> If you already have the appropriate list
19:21:03 <Cale> or rather the appropriate bytestring
19:21:11 <Cale> So it would look like
19:23:23 <Xandaros> https://github.com/Xandaros/coap/blob/master/src/Data/Coap/Types.hs#L53
19:23:38 <Xandaros> Things have changed a bit since I last pushed, but that is the data structure I have
19:24:12 <Xandaros> Which reminds me... I should probably commit the stuff I've done
19:25:53 <Cale> @let foo :: [Word8] -> Word32; foo [] = 0; foo [x] = fromIntegral x; foo [x,y] = x + y `shL` 8; foo [x,y,z] = x + y `shL` 8 + z `shL` 16; foo [x,y,z,w] = x + y `shL` 8 + z `shL` 16 + w `shL` 24; foo _ = error "too long!"; infixl 6 `shL`; x `shL` n = fromIntegral x `shiftL` n
19:25:55 <lambdabot>  Defined.
19:26:18 <Cale> (Maybe you don't want to use error, unless you're really certain that the list will *never* be longer.)
19:26:55 <Cale> You can also write it recursively, but for this kind of thing, sometimes unrolling like this can help GHC do a better job of inlining.
19:27:30 <Pamelloes> Is there a way to interrupt a sleeping thread but not bother a running thread?
19:27:33 <Xandaros> Yeah, I suppose I can do that
19:27:40 <Cale> oh, that should also be 7 not 6
19:27:41 <Cale> hah
19:27:56 <Cale> I'm not sure if it makes a difference
19:28:14 <Xandaros> I'm going to need the same for 0-2, though. Just used 0-4 because it was the largest
19:28:19 <Xandaros> +as an example
19:28:28 <Cale> oh, it does
19:28:29 <Cale> haha
19:29:02 <Cale> @undefine
19:29:02 <lambdabot> Undefined.
19:29:10 <Cale> @let foo :: [Word8] -> Word32; foo [] = 0; foo [x] = fromIntegral x; foo [x,y] = fromIntegral x + y `shL` 8; foo [x,y,z] = fromIntegral x + y `shL` 8 + z `shL` 16; foo [x,y,z,w] = fromIntegral x + y `shL` 8 + z `shL` 16 + w `shL` 24; foo _ = error "too long!"; infixl 7 `shL`; x `shL` n = fromIntegral x `shiftL` n
19:29:12 <lambdabot>  Defined.
19:29:19 <Cale> > foo [1,0,0,0]
19:29:21 <lambdabot>  1
19:29:25 <Cale> > foo [0,0,0,1]
19:29:27 <lambdabot>  16777216
19:29:45 <Cale> > foo [255,255,255]
19:29:46 <lambdabot>  16777215
19:30:04 <Cale> This might exist somewhere too
19:30:13 <Cale> I think the crypto libraries need operations like this often
19:30:38 <geekosaur> isn't that the opposite? (that is, little endian)
19:31:08 <Xandaros> Yeah, well. I think I will just implement it like that. If I make the return type polymorphic, I can use the same for Word16, too
19:31:21 <Xandaros> And yes, I do need big endian, but that's easy enough to switch up :P
19:34:10 <harwiltz> hello, I am trying to make a function that takes a FilePath and 'formats' it, for example, it would replace every space character by '\ '. But if I add '\\' to the FilePath, it adds both slashes, rather than one.
19:34:42 <geekosaur> I'm betting you're using show (directly or indirectly) to test
19:34:49 <geekosaur> use putStrLn
19:34:57 <harwiltz> I'll show you my code
19:35:07 <geekosaur> (or, perhaps your formatting function should just be show :)
19:35:23 <Xandaros> That's how I interpreted it
19:35:30 <harwiltz> geekosaur, I was actually thinking that, but then it wouldn't add the slashes
19:36:13 <jasonx2> > "hi \\ "
19:36:15 <lambdabot>  "hi \\ "
19:36:18 <jasonx2> > show "hi \\ "
19:36:19 <lambdabot>  "\"hi \\\\ \""
19:36:28 <jasonx2> > show it
19:36:29 <lambdabot>      Not in scope: ‘it’
19:36:30 <lambdabot>      Perhaps you meant one of these:
19:36:30 <lambdabot>        ‘id’ (imported from Data.Function),
19:36:37 <lpaste_> geekosaur pasted “show vs. raw” at http://lpaste.net/145699
19:36:44 <harwiltz> makeProperDirectory :: FilePath -> FilePath
19:36:46 <harwiltz> makeProperDirectory [] = []
19:36:48 <harwiltz> makeProperDirectory (x:xs) =
19:36:50 <harwiltz>     if x == ' ' then ['\\'] ++ [' ']  ++ (makeProperDirectory xs)
19:36:52 <harwiltz>     else if x == '\'' then "\\'" ++ (makeProperDirectory xs)
19:36:54 <harwiltz>     else if x == '[' then "\\[" ++ (makeProperDirectory xs)
19:36:55 <geekosaur> don't paste into the channel
19:36:56 <harwiltz>     else if x == ']' then "\\]" ++ (makeProperDirectory xs)
19:36:58 <harwiltz>     else [x] ++ (makeProperDirectory xs)y
19:36:58 <geekosaur> use lpaste.net
19:37:00 <harwiltz> why doesn't that work?
19:37:11 <harwiltz> geekosaur, sorry, never heard of that. I'll check it out.
19:37:32 <geekosaur> alos see my paste above to see what happens when you look at the reuslt with show instead of directly
19:37:41 <Xandaros> lpaste, bpaste, hpaste, pastebin, hastebin, ... :P
19:37:47 <geekosaur> (note that ghci will use show unless you use putStrLn or similar)
19:37:56 <geekosaur> (making it look like all your backslashes are doubled)
19:38:07 <emmanuel_erc> hello there everyone!
19:38:14 <harwiltz> But I don't call putStrLn on it
19:38:21 <geekosaur> sigh.
19:38:34 <geekosaur> no, you're calling show (directly or indirectly) and seeing extra backslashes
19:38:43 <geekosaur> putStrLn is not stripping backslashes. show *adds* them
19:39:02 <geekosaur> and again, ghci uses show by default
19:39:04 <harwiltz> I get that, but still my function isn't working. I am testing it in my file manager
19:39:24 <harwiltz> And the file names aren't being formatted properly because my file manipulations don't work
19:39:33 <harwiltz> And that only occurs in directories that have spaces
19:41:19 <harwiltz> For example, if I try to rename a file in my file manager, it works perfectly unless that file is in a directory that has spaces or commas in its path
19:41:38 <geekosaur> actually, I disbelieve that is your function
19:41:43 <geekosaur> because it will always error out
19:42:03 <harwiltz> What do you mean?
19:42:03 <geekosaur> oh, nemmind, since I had to grab it from noisy irc I missed a line
19:42:22 <geekosaur> this is another reason why you should use a pastebin, nobody can use your code without a lot of work editing it dowen
19:43:15 <harwiltz> geekosaur, from now on that's what I'll do. 
19:43:24 <lpaste_> geekosaur pasted “makeProperDirectory looks fine here” at http://lpaste.net/145700
19:43:41 <geekosaur> also, I think if your file manager can't handle spaces, it needs to be shot
19:44:00 <harwiltz> I am making the file manager. That's why I'm trying to get it to handle the spaces.
19:46:59 <geekosaur> see http://lpaste.net/145700 it is doing the right thing
19:53:11 <Xandaros> Cale: Well, assuming I don't get longer payloads than expected, it works now. I'll put payload length checking as an issue and call it a day, I think... (5 am for me, heh)
19:53:45 <Cale> Yeah, at some point you might want to replace that with a Maybe result
19:53:54 <Cale> Or Either String
19:54:20 <Xandaros> No, I need to drop the option into the "unknown options" list
19:55:20 * hackagebot git-fmt 0.1.0.3 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.1.0.3 (hjwylde)
19:55:32 <Xandaros> Most of the parser is in an Either String, though. That's just for diagnostics, though. Malformed packets are supposed to be ignored
19:56:08 <Xandaros> Unknown options are either ignored (least significant bit 0) or cause the request to fail and a "Bad Option" response (least significant bit 1)
19:56:16 <Xandaros> The standard is a bit weird at times^^
20:00:20 * hackagebot git-fmt 0.2.0.1 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.2.0.1 (hjwylde)
20:08:39 <tabemann> why didn't I use OverloadedStrings before
20:15:45 * hackagebot MonadRandom 0.4.1 - Random-number generation monad.  https://hackage.haskell.org/package/MonadRandom-0.4.1 (BrentYorgey)
20:20:45 * hackagebot markdown-unlit 0.4.0 - Literate Haskell support for Markdown  https://hackage.haskell.org/package/markdown-unlit-0.4.0 (SimonHengel)
20:21:49 <trustisimportant> hi brothers
20:23:00 <trustisimportant> is it posible to enter this chanel with tor?
20:25:03 <Pamelloes> How can I turn Map a (Maybe b) into Map a b, dropping all entries with a value of Nothing?
20:25:33 <trustisimportant> Guys Iḿ looking for friends, is that posible in this chanel>?
20:25:45 * hackagebot git-fmt 0.2.1.1 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.2.1.1 (hjwylde)
20:26:26 <athan> Pamelloes: Check out catMaybes
20:26:33 <athan> the generalized form is in Data.Witherable :)
20:27:24 <athan> tabemann: |:
20:27:32 <ski> Pamelloes : where did you got the `Map a (Maybe b)' from ?
20:29:53 <Cale> trustisimportant: If you're looking for friends to talk about the programming language Haskell, then yeah
20:30:18 <Cale> trustisimportant: If you are a Haskeller and would like to talk about random other stuff, then maybe try #haskell-blah
20:30:46 <Pamelloes> ski: I used mapAccumWithKey on a (Map a b) with a function that outputs a Maybe b when the entry should be removed.
20:31:23 <trustisimportant> @cale, to be honest my trust in the humans has been gone
20:31:23 <lambdabot> Unknown command, try @list
20:31:32 <trustisimportant> do you guys experience the same?
20:31:48 <trustisimportant> I have been repeatedly cheated, 
20:31:51 <glguy> trustisimportant: Please try to stay on topic
20:31:55 <trustisimportant> sorry
20:32:32 <tabemann> back
20:32:39 <ski> @type Data.Map.mapMaybe id  -- Pamelloes, i think you can use this
20:32:41 <lambdabot> M.Map k (Maybe b) -> M.Map k b
20:32:53 <tabemann> athan: yeah, I went back through my code deleting many instances of T.pack
20:33:12 <athan> tabemann: :||| how do you not know this
20:33:15 <athan> did*
20:33:32 <athan> @type Data.Witherable.catMaybes
20:33:33 <lambdabot> Not in scope: ‘Data.Witherable.catMaybes’
20:33:36 <athan> :(
20:33:49 <athan> @type Data.Map.catMaybes
20:33:50 <lambdabot>     Not in scope: ‘Data.Map.catMaybes’
20:33:50 <lambdabot>     Perhaps you meant ‘Data.Maybe.catMaybes’ (imported from Data.Maybe)
20:33:50 <Pamelloes> ski: Awesome. Now I don't need another dependency!
20:34:05 <Pamelloes> My project has waaaay to many dependencies, already...
20:34:09 <athan> sorry Pamelloes
20:34:12 <tabemann> athan: I knew about it, but for some reason I didn't bother to use it
20:34:26 <Pamelloes> athan: What for?
20:34:40 <athan> tabemann: I still don't know how to use PatternSynonyms or w/e >.>
20:34:59 <athan> Pamelloes: Suggesting the extra dep solution
20:35:31 <Pamelloes> hehe, no problem—it's a valid solution and that library looks like it might come in handy at some point :)
20:36:30 <athan> you could also `fmap fromJust . filter isJust`
20:46:36 <tabemann> okay, this is going to make changing the license of my program a pain...
20:46:54 <tabemann> well not much of a pain, an annoyance really
20:47:44 * tabemann wishes there were a standard license header for source files under BSD3, so he didn't have to include the entire text of the BSD3 license verbatim in each source file
20:47:57 <Pamelloes> Is there a way to cause a thread to stop sleeping (from threadDelay)
20:48:34 <Pamelloes> tabemann: You should probably set up a s script to maintain license headers.
20:48:45 <tabemann> send the thread an exception, and then catch the exception within the thread, IIRC
20:49:40 <tabemann> there's probably something that already implements this, so you don't have to implement it yourself
20:50:39 <Pamelloes> tabemann: Right, but if the thread isn't sleeping the exception will still interrupt it—I only want to interrupt the thread if its sleeping.
20:55:36 <tabemann> I'd suggest writing to an MVar before threadDelay signaling readiness for the exception, and writing to the MVar again to signal non-readiness for the exception, and wrap the writes to the MVar and the threadDelay with catch
20:56:16 <tabemann> and before you send the thread an exception check the MVar
20:56:43 <Pamelloes> That's a great idea :)
20:57:59 <tabemann> actually there's one little thing
20:58:31 <tabemann> it should be implemented this way:
20:58:54 <tabemann> in the thread doing the thread delay do, within catch:
20:59:14 <tabemann> putMVar ourMVar ()
20:59:24 <tabemann> threadDelay ourTIme
20:59:35 <tabemann> takeMVar ourMVar
20:59:44 <tabemann> and on the thread-sending side:
20:59:54 <tabemann> tryTakeMVar ourMVar
21:00:08 <tabemann> and if that returns Just ()
21:00:28 <tabemann> then send the exception
21:00:55 <tabemann> the advantage to this solution is
21:00:59 <tabemann> it avoids a race condition
21:01:25 <tabemann> where one has checked the MVar, but the thread to be sent the exception already has left the catch before you send the exception
21:01:34 <tabemann> because by taking the MVar
21:02:05 <tabemann> you are forcing the thread being sent the exception to wait at takeMVar ourMVar
21:02:36 <Pamelloes> Oh, I see.
21:02:40 <Pamelloes> That's really clever.
21:03:36 <emmanuel_erc> hello there pamelloes!
21:03:36 <tabemann> also there's no need to put the () back into the MVar with putMVar, because the "default" state of the MVar here is to be empty
21:04:54 <tabemann> (concurrent programming is hard. as you see here, it is easy to get this one subtly wrong, introducing race conditions)
21:04:58 <nshepperd_> you could spawn a third thread that does nothing but 'threadDelay x >> putMVar ourMVar ()', and then wait on the mvar with 'readMVar ourMVar'; so then you would just tryPutMVar to signal an early wakeup
21:05:35 <nshepperd_> beginning with an empty mvar
21:05:48 * hackagebot lift-generics 0.1 - GHC.Generics-based Language.Haskell.TH.Syntax.lift implementation  https://hackage.haskell.org/package/lift-generics-0.1 (ryanglscott)
21:06:23 <Pamelloes> nshepperd_: Clean up would be messy, though.
21:08:59 <nshepperd_> would it? well I guess if the signalling threads died you would be blocked forever
21:09:00 <tabemann> nshepperd_'s solution avoid sending exceptions
21:09:26 <Pamelloes> emmanuel_erc: Hello! :)
21:09:30 <tabemann> except I'd make that threadDelay x >> tryPutMVar ourMVar ()
21:09:57 <tabemann> or otherwise if you signaled an early wake up by doing tryPutTMVar ourMVar (), the delay thread would not wait forever
21:10:18 <nshepperd_> i think it'll be killed from 'blocked forever on mvar' but tryPutMVar is better anyway, yeah
21:10:39 <Pamelloes> But you still have the issue that the sleep started with an empty mvar and ends with a filled one.
21:11:09 <nshepperd_> oh, oops, I meant takeMVar there
21:11:25 <nshepperd_> yeah, you empty it when you wake up
21:11:50 <Pamelloes> Oh I see.
21:12:13 <tabemann> this solution avoids the possibility of subtle bugs
21:12:43 <nshepperd_> but I don't think it should matter anyway as long as you use tryPut
21:12:49 <Pamelloes> But say you sleep for 10 seconds. 5 seconds in you send an interrupt, the thread does some work (say 1 second) and goes back to sleeping for another 10 seconds.
21:13:16 <Pamelloes> Only the original sleep thread is still running, so four seconds into the new sleep it completes its task and interrupts the second sleep early.
21:13:53 <Pamelloes> To solve this, at the end of the sleep, you need to kill the third thread to ensure that it isn't still going.
21:14:01 <nshepperd_> oh, I imagined that you would create all of this anew if you sleep again
21:14:08 <tabemann> you create a new MVar each time
21:14:16 <tabemann> and you create a new timer thread each time
21:15:00 <tabemann> that way, if something is interrupted early, you just let the timer thread keep on running, and you discard the MVar
21:15:09 <Pamelloes> Hm.
21:15:52 <Pamelloes> The issue for my situation is that the threads that issue the early interrupt are completely independent from the sleeping thread. There's no way to send out a new MVar each time the thread sleeps.
21:15:57 <tabemann> trying to reuse the timer thread and the MVar will result in a substantially more complex, and bug-prone implementation
21:16:33 <tabemann> simple
21:16:40 <tabemann> you put the MVar in another MVar
21:16:49 <Pamelloes> huh
21:16:57 <tabemann> each time you change the MVar inside the outside MVar
21:18:05 <tabemann> and the interrupting thread is passed the outside MVar, and does takeMVar to get the inside MVar, does tryPutMVar on the inside MVar, and does putMVar to put the inside MVar back in the outside MVar
21:18:58 <Pamelloes> Would it be better to use a TVar instead of the outer MVar?
21:19:15 <tabemann> whereas the delay thread is only passed the inside MVar, which changes each time a new delay thread is created
21:20:26 <tabemann> you could use STM here, except MVars are faster than STM, and have more predictable scheduling behavior
21:21:58 <Pamelloes> Oh I see, the outer MVar is empty normally, but filled when sleeping. So after sleeping I would do I tryTakeMVar to clear the outer MVar. And on the interrupting thread, there is no need to put the inside MVar back,
21:23:02 <tabemann> that'd be one way to do it
21:25:12 <nshepperd_> it might actually be easier to use a semaphore inside, rather than an MVar
21:25:33 <nshepperd_> Control.Concurrent.QSem
21:25:52 <nshepperd_> sleepInfo :: MVar QSem
21:26:09 <Pamelloes> How does a semaphore work?
21:26:44 <nshepperd_> it's just an integer >= 0
21:26:57 <nshepperd_> the two options are "wait for it to go above 0" and "increment by 1"
21:27:17 <nshepperd_> so you create it with 0
21:27:28 <nshepperd_> and then wait on the semaphore on the sleeping thread
21:27:30 <Pamelloes> Oh cool, that's nice and simple :)
21:27:42 <nshepperd_> then increment the semaphore in any thread that wants to wake it up
21:27:53 <nshepperd_> (the timer thread & interrupting thread)
21:34:49 <athan> What would you call a function that.. un-concats, by some fixed amount? Like `group :: Int -> [a] -> [[a]]`, which gathers the first `n` together, then the second `n` in size
21:34:54 <athan> sorry if this is vague
21:35:12 <geekosaur> :t chunksOf
21:35:14 <athan> I need the list to be grouped adjacently in sizes of `n`
21:35:14 <lambdabot> Int -> [e] -> [[e]]
21:35:15 <athan> ah!
21:35:21 <athan> thank you geekosaur
21:35:57 <athan> geekosaur: Do you happen to know if there is one for vector?
21:36:20 <geekosaur> not offhand. that one is in Data.List.Split
21:36:55 <athan> hmm, okay. Might as well just turn it into a list. Thanks again
21:38:37 <tabemann> it shouldn't be hard to implement one for Vector using Data.Vector.splitAt
21:39:16 <tabemann> note that this does not involve copying
22:06:23 <nshepperd_> Pamelloes: oh, that's "wait for it to go above 0, then decrement" to prevent future confusion
22:06:46 <Pamelloes> OK :)
22:21:49 <deception1> Hi I am currently learning haskell by following "Real world haskell" there I read the following statement "we can create reliable code quickly, and easily refactor it in response to changing requirements."[http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html#id528487] but previously I heard haskell requires upfront designing how can they possibly co exist. 
22:25:01 <pharaun> you can upfront design and have that turn into a pile of goo, and then refactor it in response to changing requirements
22:25:04 <pharaun> ;P
22:25:59 <pharaun> it just depends on problem domain but i find that usually i can think a bit then dive right in
22:26:02 <pharaun> and change things on the go
22:26:11 <pharaun> some other devs probably prefer to think/explore a bit more then code
22:26:35 <pharaun> so it varies by devs but yeah rwh is accurate in that i find it easy to make reliable code and refactor in a easy way
22:29:17 <deception1> pharaun: thanks :)
22:32:17 <jle`> deception1: haskell development usually lends itself to thinking about things before you type things out, but it makes the actual typing time a bit faster too
22:33:27 <jle`> deception1: like, if something in another program took you 1 hour to develop by just typing away... in haskell, it wouldn't be like 1 hour of thinking, then 1 hour of typing
22:33:43 <jle`> deception1: it'd be like 30 minutes of thinking and 10 minutes of typing (exaggeration, but you get the point :) )
22:34:22 <Cale> deception1: It's not like any such statement can be taken as an absolute
22:34:32 <jle`> deception1: also, another big thing that that statement is making is that once you have fully working haskell code that you quickly prototyped, it's very easy to refactor safely later on
22:34:36 <jle`> (that's probably the "main point")
22:34:57 <jle`> haskell code, no matter what path you took to develop it to get there, is much easier to refactor when requirements change later down the line
22:35:05 <jle`> and much safer
22:35:43 <Cale> Than most languages people actually use anyway :)
22:36:19 <Cale> It's really nice to be able to make a change to some fundamental type and have the compiler tell you all the things you need to change as a result.
22:36:35 <Cale> In a dynamically typed language, that kind of refactoring can be a major ordeal.
22:37:05 <jle`> this is the real benefit of haskell to me...and it's not something you can really make someone appreciate by giving a cute little code golf snippet, unfortunately
22:37:43 <mjrosenb> I take it import renaming doesn't happen recursively
22:38:07 <mjrosenb> e.g. import qualified Foo as F; import qualified Foo.Bar; I can't reference F.Bar?
22:39:14 <shachaf> mjrosenb: Right. "Foo.Bar" is just a name of a module, it's not made up of the parts "Foo" and "Bar".
22:39:34 <shachaf> Except GHC will look at Foo/Bar.hs to find the file containing that module.
22:39:38 <mjrosenb> that feels silly.
22:46:14 <jle`> is there any typeclass or pattern Something that gives you foo :: Something f => (a -> b) -> (b -> a) -> (f a -> f b) ?  like you can turn an (f a -> f b) iff you provide both (a -> b) and (b -> a)
22:46:37 <kras> Hi everyone,
22:47:03 <kras> I get an error when I try to include alex in the build dependenceis, cannot satisfy -package alex-3.1.4
22:47:16 <kras> can anyone please help?
22:47:32 <glguy> alex goes in your build-tools: section
22:48:19 <glguy> https://github.com/glguy/config-value/blob/master/config-value.cabal#L41
22:49:16 <kras> glguy: thank you, resolved
22:51:11 <kras> I am using stack, do you know if it recognises .x extension?
22:51:21 <kras> as an alex input?
22:55:52 * hackagebot buffon 0.1.0.0 - An implementation of Buffon machines.  https://hackage.haskell.org/package/buffon-0.1.0.0 (DerekElkins)
22:59:05 <vektorweg1> which lib to pick for relational data?
23:22:17 <jle`> hi all, anyone familiar with the ad library?  if i have an AD s (Forward a) -> AD s (Forward a), i can get its derivative by using diff
23:22:29 <jle`> er, get its derivative as an (a -> a)
23:22:46 <jle`> is there any way i can cheaply get the "original" (a -> a), before the derivative?
23:23:00 <jle`> it looks like diff' gives you an a -> (a, a), with the result and the result of the derivative
23:23:12 <jle`> does this come at any extra cost if i don't need the derivative?
23:23:53 <dooznoo> hi folks, just starting out with haskell, when I write my own replicate' function why does the type signature look like 
23:23:55 <dooznoo> replicate' :: (Num i, Ord i) => i -> a -> [a]
23:24:15 <dooznoo> Why does i need the Ord typeClass
23:24:26 <dooznoo> it should be for any type right?
23:24:38 <jle`> dooznoo: how do you implement replicate' ?
23:24:38 <nitrix> :t replicate
23:24:40 <lambdabot> Int -> a -> [a]
23:24:55 <dooznoo> replicate' n x 	| (n <= 0) = [] 	| otherwise = x:replicate' (n-1) x
23:25:00 <jle`> dooznoo: in your implementation, do you ever use > or < on n?
23:25:08 <jle`> ah, it looks like you do
23:25:15 <jle`> you compare n to 0, n <= 0
23:25:16 <dooznoo> but thats  on n right
23:25:29 <dooznoo> why does i need it?
23:25:37 <jle`> i is the type of n
23:25:38 <kadoban> dooznoo: the variable 'n' is of type 'i' in that type signature.
23:25:45 <jle`> n is your first value, and its type is i
23:25:50 <nitrix> Well, if you use > or < on n, then Haskell infers that the type needs to be one that's orderable.
23:25:53 <jle`> *the name of the first parameter
23:26:20 <kadoban> dooznoo: The things in the list don't need to be Num or Ord instances. Only 'n' needs to be.
23:26:25 <dooznoo> ah yes...!!!
23:26:27 <jle`> replicate' :: i -> a -> [a] means that it can take a value of any type i, a value of any type a, and give you a list of values of that type a
23:26:41 <jle`> so your replicate' takes n and x... n :: i, and x :: a
23:26:48 <nitrix> replicate' n x = take n $ repeat x
23:26:58 <dooznoo> understood
23:27:03 <jle`> dooznoo: whatever type n is, it has to be Num and Ord
23:27:05 <dooznoo> should have looked carefully!
23:27:08 <dooznoo> thanks
23:27:11 <jle`> np!
23:28:09 <nitrix> My implementation is probably the most straightforward and ideal, but it requires a minimal understanding of lazyness.
23:28:50 <deception1> Thanks Cale and jle` :)
23:56:05 * hackagebot simplest-sqlite 0.0.0.10 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.0.0.10 (YoshikuniJujo)
