00:00:49 <jle`> shanemikel: unnecessary parentheses are often fine, when dealing with lots of operators :)  but if you're using a lot of different operators in the same expression then you might want to consider splitting it up
00:01:13 <jle`> also, install `hlint`, or find some way to integreate hlint or ghc-mod into your workflow :)
00:01:21 <jle`> to get automatic recommendations about parentheses
00:05:28 <frerich> shanemikel: I learned a lot from just having hlint integrated into my editor, and from watching ski in this channel point out unnecessary parenthesis. It's kind of his pet peeve. :-)
00:07:10 * hackagebot HulkImport 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/HulkImport-0.1.0.0 (smobs)
00:07:30 <shanemikel> okay.  now that you mention it, splitting things up brings another issue.  sometimes I find myself defining a function that uses an inner looping function (usually to do some tail recursion for the sake of the signature).. in this scenario, I'm defining the inner function within a where block, where I've also computed the initial value for the extra data to be passed, and the inner function tends to require its own where block.  I
00:07:30 <shanemikel> know if it were to get to one more level of nested function, I would definitely find a way to abstract, but even 2 levels is a bit ugly
00:07:40 * hackagebot oidc-client 0.2.0.0 - OpenID Connect 1.0 library for RP  https://hackage.haskell.org/package/oidc-client-0.2.0.0 (ShoKuroda)
00:07:40 * hackagebot HulkImport 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/HulkImport-0.1.0.0 (smobs)
00:08:01 <jle`> shanemikel: i've done 2 level where blocks before...but in this case, maybe it'd help to post a specific example
00:08:07 <jle`> maybe there's something else you can do that is tricky to see?
00:10:45 <shanemikel> well, I don't want to embarrass myself :), but I guess what I'm asking, are there any nice style guides (structural, not about rediculous things like whitespace)
00:11:44 <nitrix> shanemikel: Whitespaces are somewhat significant in Haskell.
00:12:35 <jle`> shanemikel: hlint played the role of my style guide when i was starting haskell, heh
00:12:36 <pikajude> almost all of them!!
00:13:02 <shanemikel> right, syntactically, but I'm referring to style guides for other languages that obsess over trivial details like if you write your loops like this for(...){ or for(...) {
00:13:04 <pikajude> sorry, that was useless. stylish-haskell is nice to use, and has a vim plugiN!
00:13:06 <jle`> if you're using emacs, there's also chrisdone's various emacs stuff that re-formats your haskell in an extensible way
00:13:28 <pikajude> shanemikel: oh, like if you use spaces or not
00:13:58 <pikajude> there's kind of a wide range of haskell coding styles
00:14:12 <pikajude> which i guess indicates we have no authoritative style guide
00:14:55 <shanemikel> maybe style is the wrong word.. ahh, I guess I'll just pick the stuff up with some more time anyway
00:15:46 <pikajude> do you have any specific cases you're concerned about?
00:18:06 <Lokathor> shanemikel, here's a basic style guide: you can leave type signatures off your functions but please don't actually do that in code you commit :3
00:19:05 <shanemikel> I could give you an example of something I've already decided on (where similar compositional tips might be helpful).. for instance, I've decided that it's clearer to make recursive calls in the definition line, or guard clauses than it is in a where clause
00:22:03 <Lokathor> could you make an lpaste of that?
00:25:04 <shanemikel> http://lpaste.net/8685285550325760000 is the example using the style I've deemed more clear, and http://lpaste.net/377437100292702208 is the one that's less clear.. but it is more meaningful in a more complicated function of course
00:26:36 <shanemikel> it'd be cool if lpaste had a diff paste feature
00:26:52 <shanemikel> or a visual diff, rather
00:27:35 <Lokathor> ah, yes, first : lsort rest
00:27:39 <Lokathor> that's easier to follow
00:28:38 <Lokathor> though, if you want to sort lists of lists... this is a very excessive way to do it in haskell
00:29:01 <shanemikel> right, that was in the 99 Prolog problems I've been following
00:29:23 <shanemikel> I'm basically using that as an example of the type of guide I'm looking for (compositional tips)
00:30:41 <shanemikel> from here https://wiki.haskell.org/99_questions
00:39:30 <Lokathor> i can say, if you read the Haskell Programming book
00:39:36 <Lokathor> don't use it as a style guide
00:39:50 <Lokathor> the limits of putting things in a book only give you 60 chars per line
00:40:00 <Lokathor> which causes you to write very funny looking code some of the time
00:40:23 <Lokathor> amazing book otherwise
00:42:30 <tdammers> 60 chars per line builds character
00:42:36 <tdammers> pun intended
00:48:18 <shanemikel> is that haskellbook.com?
00:49:36 <shanemikel> Lokathor
00:50:40 <MarcelineVQ> shanemikel: yes
00:51:00 <Lokathor> ah, yes
00:51:07 <Lokathor> quality book, and more to come
01:20:29 <phadej> What problems there might be when defining instance like (MonadTime m, MonadTrans t, Monad (t m)) => MonadTime (t m)
01:20:32 <phadej> from http://hackage.haskell.org/package/monad-time-0.1/docs/Control-Monad-Time.html
01:22:34 <vev> Expanding the collective human mind! Come join us on #libreidea and help develop this project >> http://www.libreidea.org/
01:22:34 <vev> we need new voluntary devs to help us on this project >> http://www.libreidea.org/Collaborative_keywords_mixing_project
01:39:10 <ReinH> shanemikel: I guess I should point out that lsort is very inefficient.
01:39:51 <ReinH> :t sortOn length
01:39:53 <lambdabot> Foldable t => [t a] -> [t a]
01:39:54 <ReinH> would be more efficient
01:42:13 <Zemyla> Hmm. hasn't is basically a Lens version of null, right?
01:44:17 <ChristianS> is there something like Data.Text.replace that works on bytestrings instead of texts?
01:45:16 <trubart8> Is it possible with a .cabal file depend on two libraries that both provide a module with the same name and namespace, e.g. Foo.Bar ?
01:45:23 <shanemikel> I know about sortOn, and I've implemented a version of it with the same signature, however, I don't have it in my Data.List (maybe too old? i'm on ubuntu).  Other than using a library abstraction, do you have any insights into how it could be improved
01:46:23 <merijn> shanemikel: By using sortBy + comparing
01:46:30 <merijn> :t sortBy (comparing length)
01:46:32 <lambdabot> Foldable t => [t a] -> [t a]
01:47:04 <shanemikel> :t length
01:47:05 <lambdabot> Foldable t => t a -> Int
01:47:17 <shanemikel> :t comparing
01:47:19 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
01:47:45 * hackagebot argon 0.3.2.0 - Measure your code's complexity  https://hackage.haskell.org/package/argon-0.3.2.0 (rubik)
01:48:05 <quicksilver> vev: if I'm not mistaken, you keep advertising that
01:48:21 <merijn> quicksilver: He is
01:48:52 <quicksilver> vev: please don't. It's not contributing to the channel. Find other ways to advertise your project, however worthwhile it may be.
01:49:17 <vev> quicksilver: oui ty, you re nice
01:49:45 <vev> libreidea is using haskell btw
01:50:42 <shanemikel> ok, thanks, but it's easy for me to discover new library functions. what I'm having trouble with atm (in that regard), is reasoning about when execution takes place.. ReinH are you saying it's inefficient because haskell recalculates the 'shortest' on every call?
01:55:21 <tdammers> shanemikel: reasoning about evaluation order can be tricky in haskell
01:55:55 <tdammers> execution order should usually be obvious though, as long as it doesn't depend on evaluation order
02:04:45 <shanemikel> are there any cool profiling tools with guis (like for visualizing what pieces of a collection are in memory, or whatever).. or for tracking evaluation order in a program?
02:07:40 <quicksilver> yes although though sometimes they are fiddly to build because they depend on specific GHC versions
02:07:51 <quicksilver> https://hackage.haskell.org/package/ghc-vis springs to mind
02:08:12 <quicksilver> http://felsin9.de/nnis/ghc-vis/#interactive_usage
02:08:57 <quicksilver> what ghc-vis proves is that the actual reality is a bit more subtle and detailed than the approximation I hold in my head :)
02:09:03 <mimi_vx> stackage is down ?
02:10:17 <shanemikel> great!  That's a pleasant surprise
02:10:21 <shanemikel> thanks quicksilver 
02:14:53 <merijn> hmm
02:15:17 <merijn> I'm getting stupid warnings from GHC..
02:15:44 <merijn> "Pattern match(es) are non-exhaustive In an equation for 'piType': Patterns not matched:"
02:15:53 <merijn> (Yes, the list of unmatched patterns is empty)
02:18:33 <Fylwind> hm, I'm getting a bunch of "Could not specialise imported function" warnings for functions that I didn't define
02:18:41 <Fylwind> in GHC HEAD, that is
02:28:24 <ReinH> @src sortBy
02:28:24 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
02:28:32 <ReinH> Is that correct?
02:28:35 <ReinH> hmm
02:29:05 <ReinH> No, thank goodness.
02:31:47 <ReinH> merijn: sortOn does a schwartzian transform on sortBy, so it should be more efficient than using sortBy (comparing length) directly
02:32:05 <ReinH> merijn: Specifically I used sortOn to ensure that the length of each sublist was only calcuated once.
02:32:31 <ReinH> @src sortOn
02:32:31 <lambdabot> Source not found. Where did you learn to type?
02:32:41 <ReinH> sortOn f = map snd . sortBy (comparing fst) . map (\x -> let y = f x in y `seq` (y, x))
02:32:44 <merijn> ReinH: I don't know where sortOn is from
02:32:50 <ReinH> merijn: new base
02:32:52 <ReinH> Data.List
02:32:59 <ReinH> https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html#v:sortOn
02:33:16 <shanemikel> yeah, ReinH, I actually remember reading that now
02:33:24 <ReinH> shanemikel: calculating all the lengths first before sorting is more efficient
02:34:00 <ReinH> also the use of filter is inefficient, but perhaps not as inefficient as one might expect.
02:34:05 <ReinH> since it is lazy
02:34:22 <ReinH> but still less efficient than not filtering at all
02:36:13 <Heather> in stack.yaml can I specify extra-deps with "greater or qual"?
02:37:10 <Heather> I see, allow-newer: true should be case
02:39:11 <quicksilver> ReinH: I don't think it's obvious that the schwartzian transform is more efficient
02:39:34 <quicksilver> ReinH: it depends on the relative costs of the function 'f' and the book-keeping with the tuples.
02:39:44 <Heather> no  allow-newer doesn't work :(
02:40:00 <quicksilver> I believe that for some f sortBy (comparing`on`f) will be faster
02:40:05 <quicksilver> compare`on`
02:40:45 <ReinH> quicksilver: it's a good enough tradeoff to be used by sortOn, at least.
02:41:15 * quicksilver nods
02:41:18 <ReinH> quicksilver: and I wouldn't expect length to be one of those cheaper functions
02:41:31 <quicksilver> unless your lists are mostly rather short.
02:41:36 <ReinH> except perhaps on a pathologically long list of pathologically short lists. ;)
02:41:42 <quicksilver> yeah.
02:41:46 <ReinH> er, short list of short lists
02:42:11 <ReinH> since the number of times length is called grows asymptotically
02:42:46 <ReinH> quicksilver: anyway I wonder if there are non-patholigical cases where sortBy (comparing f) is faster than sortOn f, fsvo pathological
02:42:53 <ReinH> quicksilver: but your point is well taken
02:43:07 <quicksilver> ReinH: "compare`on`fst" springs to mind
02:43:22 <ReinH> quicksilver: or "id"
02:43:22 <quicksilver> since that gets used again inside sortOn :)
02:43:35 <quicksilver> but compare`on`(tuple accessor) is quite common
02:43:35 <quicksilver> IMO
02:43:55 <quicksilver> would be interesting to test with a more complex accessor.
02:44:16 <shanemikel> for ghc-vis, it looks like I've got everything built without errors, but when I type :vis in ghci, it doesn't do anything.. I'm guessing that's because ghci needs to be set with a plugin path or somethign?
02:44:30 <ReinH> quicksilver: also it trades memory for time ofc
02:44:33 <ReinH> s/memory/space
02:45:29 <kriztw> shanemikel: there is a :script command you have to run
02:45:30 <ReinH> but I suppose it must be better frequently enough to be used by sortOn. Either that or someone just assumed that it would be better, but that doesn't seem like the gHC way. ;)
02:45:53 <kriztw> shanemikel: for me it got printed at the end of the install
02:46:18 <merijn> ReinH: I imagine most comparison are straightforward indirections where recomputing is cheaper than allocating space for the result
02:46:28 <merijn> ReinH: like "sortBy fst", etc.
02:47:47 * hackagebot eternal 0.1.3 - everything breaking the Fairbairn threshold  https://hackage.haskell.org/package/eternal-0.1.3 (Heather)
02:47:58 <ReinH> merijn: perhaps, but why then sortOn?
02:48:04 <quicksilver> ReinH: I think it's just up to the user to work out which is faster (or benchmark) if they care; after all Data.Llist provides both.
02:48:14 <ReinH> Sure.
02:48:20 <quicksilver> ReinH: for those cases where f is really quite expensive :)
02:48:24 <ReinH> I used it specifically in this case because of length.
02:48:28 <quicksilver> agreeed.
02:57:35 <shanemikel> kriztw: shit, nothing printed for me.. do you have it in your .ghci maybe?
02:57:46 <shanemikel> apologies for explitive
02:57:54 <linman32> have bug with stack
02:57:54 <linman32> The following package identifiers were not found in your indices: ghc-7.10.2
02:58:10 <linman32> anyone know what that is?
02:58:57 <kriztw> shanemikel: here, you have to change up the path, and it assumes it is installed through stack
02:59:01 <kriztw> shanemikel: :script /home/kris/haskell/ghc-vis/ghc-vis-0.7.2.7/.stack-work/install/x86_64-linux/lts-2.22/7.8.4/share/x86_64-linux-ghc-7.8.4/ghc-vis-0.7.2.7/ghci
03:00:06 <shanemikel> sweet, thanks
03:02:03 <linman32> wow. turns out ghc-mod package name is not "ghc" as stated on site
03:02:03 <linman32> http://www.mew.org/~kazu/proj/ghc-mod/en/preparation.html
03:02:22 <linman32> it is "ghc-mod"
03:03:37 <linman32> haha deleted compiler (named ghc too) accidently. then stack and cabal.....
03:06:57 <int-e> linman32: 'package' is ambiguous there; the *melpa* package name is ghc.
03:09:37 <jophish> darn, it doesn't look like it's possible to return the result of a type family application from a GADT
03:09:45 <shanemikel> how does haskell recycle memory allocation?
03:10:06 <linman32> int-e: this is true
03:10:19 <jophish> type family F a where F Int = Foo; data Foo where Foo :: Int -> F Int; for example
03:11:58 <jophish> Every time I bump into someting like this it's for a good reason, but why disallow this when it's well formed
03:12:53 <SrPx> Hello, this ReadP parser is exponential. http://lpaste.net/144512 any idea why?
03:13:47 <YellowOnion> could someone help understand applicative more, I'm trying to rewrite \a -> a+a point free style
03:14:16 <SrPx> I wish we had something like ReadP that couldn't go exponential... I'm not sure when/how this happens
03:17:06 <shanemikel> YellowOnion: (*2)
03:17:10 <tdammers> YellowOnion: follow the types
03:17:17 <tdammers> :t (<$>)
03:17:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:17:25 <tdammers> :t (<*>)
03:17:27 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:18:14 <YellowOnion> tdammers, what do you think I'm trying to do :P
03:18:17 <tdammers> haha
03:18:31 <YellowOnion> shanemikel, that doesn't help me with applicative.
03:18:32 <tdammers> the shortcut is this pattern:
03:18:38 <tdammers> f <$> a <*> b
03:18:57 <shanemikel> point-free style and applicative are two separate issues
03:19:00 <tdammers> where f is a pure function, a and b are arguments wrapped in the relevant applicative functor
03:21:50 <YellowOnion> tdammers, shanemikel, I'm trying to understand how the deduplication works in this: http://stackoverflow.com/questions/12659951/how-does-this-piece-of-obfuscated-haskell-code-work
03:25:33 <YellowOnion> > ((+) <*> id) 1
03:25:35 <lambdabot>  2
03:26:38 <shanemikel> I'm still new, but I've come to understand Applicative as a sort-of curry friendly functor
03:27:45 <cocreature> YellowOnion: that uses the applicative instance of ((->) a)
03:27:56 <cocreature> try specializing the type of (<*>)
03:27:59 <cocreature> :t (<*>)
03:28:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:28:23 <cocreature> now replace the f
03:29:34 <shanemikel> that is, you can fmap a pure function over a functor, where you can apply a functor containing functions to a functor containing arguments
03:30:03 <cocreature> YellowOnion: the implementation might help too https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#line-617
03:31:21 <shanemikel> I've been learning about these things from lyah, but, honestly, I would think trying to understand intentionally unreadable code is not conducive to your understanding the concepts..
03:31:39 <YellowOnion> cocreature, thanks
03:32:33 <hpc> shanemikel: exactly
03:32:59 <hpc> even most "educational" code operates on too many concepts at the same time
03:33:16 <hpc> or tries to be brief and only ends up deviating from good coding style
03:33:32 <merijn> pffft, just learn haskell by implementing a Haskell compiler! ;)
03:33:47 <hpc> that only works in lisp
03:33:50 <merijn> (Incidentally, that's not as stupid an idea as it sounds.)
03:34:03 <hpc> (eval (print (read-line)))
03:34:14 <quicksilver> instructions unclear, accidentally built dependently typed languaeg
03:34:14 <hpc> er, or whatever
03:34:29 <merijn> hpc: I disagree, if you start from a lambda calculus interpreter and incrementally add features it's actually pretty doable AND educational, imo
03:34:38 <merijn> Although it requires a certain kind of personality :)
03:34:40 <hpc> yeah, that was a bit of a joke ;)
03:34:43 <quicksilver> I think hpc was making a cheap joke, merijn :)
03:34:46 <merijn> quicksilver: I know that feel :p
03:35:08 <quicksilver> writing compilers is great (or interpreters too) but it only teaches you about one side of a language
03:35:10 <merijn> I think my current compiler is actually accidentally dependently typed... >.>
03:35:13 <hpc> learning by generalizing is a good approach to more formulaic things anyway
03:35:29 <hpc> i wouldn't consider it a good approach for haskell as a whole, but bits and pieces are good
03:35:36 <merijn> Because the paper wasn't clear on how to to avoid that :p
03:35:37 <quicksilver> you can see the effect of this in haskell, since the only thing[1] SPJ uses haskell for is to write haskell compilers
03:35:44 <hpc> independently deriving Monad ((->) a), for instance
03:35:44 <quicksilver> [1] well not quite, but nearly.
03:36:03 <merijn> quicksilver: Same goes for Lennart :p
03:36:17 <merijn> He even wrote a haskell compiler so he could use haskell to write haskell compilers!
03:36:34 <quicksilver> yes.
03:36:53 <shanemikel> with the type system and everything, I was starting to think that haskell had a compiler amongst the more complicated of them
03:37:05 <quicksilver> in some ways it does, shanemikel 
03:37:09 <merijn> shanemikel: Yes and no
03:37:22 <merijn> shanemikel: Writing a compiler that produces code as good as GHC is pretty hard
03:37:33 <quicksilver> although the actual code generation is much more complicated in old, well-developed C/C++ compilers
03:37:41 <merijn> shanemikel: Writing a compiler that turns haskell (without extensions) into executable code is pretty simple
03:37:43 <hpc> much of ghc's complexity comes from the amount of research that went into it
03:37:52 <quicksilver> the complexity of GHC is more up the front end (type checking and inferencing, etc)
03:37:59 <hpc> 10 lines of ghc could take years of research
03:38:09 * hackagebot keera-posture 0.2.2 - Get notifications when your sitting posture is inappropriate.  https://hackage.haskell.org/package/keera-posture-0.2.2 (IvanPerez)
03:38:11 <hpc> and then another 500 could just be some IO gunk that anyone could write
03:38:49 <merijn> shanemikel: For people willing to dive into books/papers as background reading I'd say you don't need more than beginner-intermediate haskell to write a haskell compiler (assuming you're already a programmer and not completely new to programming)
03:39:08 <hpc> (plus the organizational complexity of being a compiler, and of being open-source, and being just a large project in general)
03:39:29 <hpc> but you don't need everything understood to start diving in
03:46:31 <jophish> What alternatives do I have for returning the result of a type family application in a GADT constructor?
03:46:35 <jophish> type family F a where F Int = Foo; data Foo where Foo :: Int -> F Int; for example
03:47:20 <merijn> Hell, my own "compiler" (well, interpreter, I guess) is only 1400 lines to implement a lazy language with a bunch more complex type features than haskell. And most of that code is boilerplate for traversing/printing my ASTs :p
03:47:42 <quicksilver> jophish: make it Foo Int (i.e. use the index of the GADT)
03:47:49 <quicksilver> jophish: and then provide a function Foo Int -> F Int ?
03:48:02 <quicksilver> jophish: or, presumably, Foo a -> F a
03:48:22 <jophish> I'm trying to represent a language which doesn't have currying, so my actual code is more like: data Expression (a :: MZType) -> * where App :: Function as ret -> ExpandFunction (Map Expression as) (Expression ret)
03:48:25 <quicksilver> merijn: Control.Lens.Plated
03:49:12 <jophish> where ExpandFunction [a,b,c] r = a -> b -> c -> r
03:50:01 <jophish> quicksilver: sorry, it seems as though I simplified my example too much
03:50:55 <jophish> What I'm doing for binary functions works really well: BinFunction a b c -> Expression a -> Expression b -> Expression c
03:51:10 <jophish> but it would be nice to generalize this
03:51:14 <quicksilver> jophish: well I don't entirely understand your example, but the point is that GADTs allow you to pretend something is uniform (parametric) even when it isn't
03:51:27 <quicksilver> jophish: whilst type families you can't even pretend are parametric
03:51:33 <quicksilver> but you can 'wrap' a type family inside a GADT
03:51:50 <quicksilver> and then 'interpret' it with interpret :: GADT a -> Fam a
03:52:12 <quicksilver> at least I believe that is right :)
03:52:41 <E4xoi> that constructor doesn't make sense, it'd have to be Foo (TF a b) and then it wouldn't kind check
03:53:05 <lpaste> jophish pasted “No title” at http://lpaste.net/144514
03:53:21 <jophish> This is what I'm trying to use at the moment
03:53:41 <jophish> quicksilver: I think I see what you're getting at
03:54:20 <jang> join #nltk
03:56:27 <jophish> quicksilver: the problem with wrapping it like that is that I'd have to make (Function as r) have kind MiniZincType
03:56:41 <jophish> I'll have a think. This might work if I could prevent it being exposed to the user :)
04:00:15 <breadmonster> Hey guys.
04:00:30 <liste> hi breadmonster
04:00:48 <breadmonster> What 's up?
04:04:52 <breadmonster> liste: do you know a lot about lens?
04:05:51 <liste> breadmonster depends on what "a lot" means
04:05:59 <liste> but a bit, yes
04:06:00 <breadmonster> liste: Like what goes on underneath?
04:06:13 <breadmonster> I want to figure out how it works, it's been way too long.
04:06:17 <quicksilver> this seems like a "just ask" case?
04:06:24 <quicksilver> there are certainly some people here who know some things about lens.
04:06:54 <breadmonster> quicksilver: Oh I presumed they would be afk.
04:07:02 <breadmonster> What's the fastest way to pick up lens?
04:07:06 <breadmonster> and understand how it works?
04:07:12 <breadmonster> Short of going through the code?
04:08:05 <liste> breadmonster http://twanvl.nl/blog/haskell/cps-functional-references
04:08:23 <pavonia> I guess going through the code is one of the worst ways to learn it :p
04:10:30 <quicksilver> can you be more precise at what level of understanding you're after ? :)
04:11:10 <breadmonster> quicksilver: Umm, sorry about that.
04:11:12 <quicksilver> the blog post that liste just linked gives you an intro to the representation using a polymorphic Functor
04:11:33 <quicksilver> actually using it a bit is also helpful (maybe you've already done that)
04:11:35 <breadmonster> quicksilver: Sure, I'd like something comprehensive.
04:12:02 <quicksilver> edwardk's blogs on comonad.com cover some ground
04:12:27 <breadmonster> quicksilver: In that blog post, I have no idea what fstF is.
04:12:48 <merijn> I like edward's lens on youtube
04:12:50 <merijn> @where lens
04:12:50 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
04:12:53 <merijn> That one
04:13:31 <quicksilver> breadmonster: fstF is the lens that selects the first field of a pair
04:13:40 <quicksilver> in the 'lens' package it's given the name _1
04:13:54 <quicksilver> and 'get' is called 'view'
04:14:02 <quicksilver> > view _1 (123,"hey")
04:14:04 <lambdabot>  123
04:14:20 <quicksilver> "where fstF is a functional reference to the first element of a pair"
04:14:22 <obadz> > view _1 (12, 34, 56)
04:14:24 <lambdabot>  12
04:14:42 <quicksilver> yes, _1 is more polymorphic than fstF but I think it's the best we have to hand.
04:14:51 <obadz> any template haskell or just typeclass hackery?
04:15:01 <quicksilver> obadz: to do which part?
04:15:43 <obadz> handle tuple of any size
04:15:44 <liste> and if you replace Functor with other classes you get other optics
04:15:54 <liste> with Applicative you get traversals
04:16:22 <quicksilver> obadz: it's just a typeclass
04:16:27 <pavonia> > view _1 "abc"
04:16:29 <lambdabot>      No instance for (Show a0)
04:16:29 <lambdabot>        arising from a use of ‘show_M63179375799204281954306’
04:16:29 <lambdabot>      The type variable ‘a0’ is ambiguous
04:16:35 <quicksilver> obadz: (there might be TH to automate deriving of it but that's just a detail)
04:17:02 <pavonia> > view _1 "abc" :: Char
04:17:04 <lambdabot>      No instance for (Field1 [Char] [Char] Char Char)
04:17:04 <lambdabot>        arising from a use of ‘_1’
04:17:04 <lambdabot>      In the first argument of ‘view’, namely ‘_1’
04:17:52 <quicksilver> he's gone :(
04:18:17 <quicksilver> I guess the fastest way to pick up lens we could offer wasn't fast enough.
04:18:28 <pavonia> Heh
04:19:09 <quicksilver> liste: just replacing Functor isn't enough
04:19:24 <quicksilver> liste: I mean, that's enough to get Traversals but to get more you need to replace the (->) too
04:38:53 <quicksilver> > preview _head "abc"
04:38:55 <lambdabot>  Just 'a'
04:39:13 <obadz> So am looking for a function MonadError a m => Either a b -> m b
04:39:28 <obadz> Hoogle suggests this eitherToMonadError but it's in a package called "MissingH"
04:39:49 <quicksilver> it is simple enough to write "either throwError return"
04:39:52 <obadz> looks like a package that doesn't have a single purpose..
04:40:00 <obadz> quicksilver: ha, thx
04:40:17 <quicksilver> I think this is what mmonad calls a 'hoist'
04:47:49 <quicksilver> no it's not
04:48:35 <quicksilver> hoist generalize could be given the type (Monad m) => EitherT a Identity b -> EitherT a m b
04:48:47 <quicksilver> which is unfortunately just one case of what you asked for
04:50:20 <lpaste> mniip pasted “wat” at http://lpaste.net/144515
04:53:19 <quicksilver> you have more than one GHC around and haddock is seeing a different one to your shell
04:53:25 <quicksilver> I guess
04:55:17 <mniip> I seem to have multiple directories in /usr/lib64/ghc-* , probably deinstallation leftovers. However only one of them has /bin/
04:55:27 <mniip> and that is the reported and used version
05:04:41 <Heather> Hello GhcMod\Types.hs:372:10-39: No instance nor default method for class operation put - what does it mean?
05:06:12 <merijn> mniip: Where is cabal coming from? i.e. where in your path is it?
05:06:43 <mniip> /usr/local/bin/cabal
05:06:45 <Cale> Heather: It probably means that there's an instance of MonadState which failed to define the put operation.
05:07:04 <merijn> Cale: Or Serialize/Binary :p
05:07:11 <Cale> true, it could be that also
05:07:29 <Heather> Cale is it possible to resolve? those messages are very annoying
05:07:36 <Cale> It's hard to tell without a complete error message and source code :)
05:07:48 <Cale> Heather: It could be resolved by defining the put operation somehow.
05:08:00 <Heather> Cale it happens when you run ghc-mod on ghc-mod :)
05:08:15 <Cale> It's really just a warning
05:08:28 <mniip> merijn, wait
05:08:34 <Cale> If the put operation never gets used, then the program will still run fine.
05:08:36 <mniip> the cabal binary is not shipped with the 'cabal' package/
05:08:37 <Heather> Cale yes but my editor runs ghc-mod on every hs file and shows me all the warnings :)
05:08:58 <Heather> Cale I will be fine even making it quiet just for me
05:09:37 <Cale> Heather: What code is around line 372 of that file?
05:10:08 <Heather> also my editor is crushing periodically even more often than kdevelop XD
05:10:14 <Cale> Heather: If you just want to shut it up, you can write something like  put = error "no definition of put"
05:10:19 <merijn> mniip: The cabal binary is from the cabal-install package, not the Cabal package (which is what ships with GHC)
05:10:39 <Heather> Cale: instance Serialize CabalHelper.Programs
05:10:42 <merijn> mniip: Perhaps you built +installed cabal-install with another GHC before undeleting and that cabal binary is still in your path
05:10:43 <mniip> aha
05:10:49 <Cale> yeah, okay, so it is Serialize
05:10:56 <merijn> s/undeleting/deleting
05:11:24 <mniip> yes that seems to be the problem
05:11:27 <Heather> Cale it should be implemented inside cabal-helper then ghc-mod should be rebuild
05:11:28 <Cale> adding a bogus definition for put will quiet it down for now, though if you're working on the code, you might rather have the warning to remind you to write a proper instance
05:11:29 <mniip> reinstalling cabal-install now
05:11:46 <Cale> oh, wait
05:11:51 <Cale> Is that a runtime error?
05:12:00 <Cale> Like, from the code which you're looking at?
05:12:07 <Heather> Cale it's message from ghc-mod
05:12:10 <Cale> Or just a warning from compiling that code
05:12:22 <Cale> and ghc-mod doesn't crash on you?
05:12:27 <Cale> Or it does?
05:12:52 <Cale> It should crash if it's running into that as a runtime error.
05:13:16 <Cale> (as it will if you write my bogus definition there, only it'll result in a different error message)
05:13:23 <Heather> Cale it fails with this error: Haskell-ghc-mod: ghc-mod check F.....\Helper.hs failed with error code 1 ghc-mod: Language\Haskell\GhcMod\Types.hs:372:10-39: No instance nor default method for class operation put
05:13:31 <Cale> You'll need a proper definition of put for that type.
05:13:52 <Heather> Cale for CabalHelper.Program?
05:13:55 <Cale> yeah
05:14:16 <Cale> The message means that put was used at that type, but nobody bothered to define it.
05:14:36 <Cale> I was thinking originally that you were just getting the corresponding compile-time warning
05:14:54 <Cale> But if you're getting that at runtime, you really need the instance.
05:15:54 <mniip> merijn, woohoo it worked
05:17:02 <merijn> mniip: \o/
05:17:56 <Heather> Cale I've found Programs
05:19:16 <Heather> damn my editor is dieng on startup mandatory now :)
05:21:08 <Heather> I see it's because something ate all memory on my windows again...
05:21:46 <orion> When using pipes-network, how do I take any old ordinary ByteString and shove it in to a Consumer?
05:21:48 <mniip> what's a good name for a type sum, that isn't a commonly used word and isn't a Prelude identifier
05:22:57 <frerich> Conglomerate
05:23:14 <mniip> I'll also need a similar name for type product
05:23:27 <mniip> I could go with coproduct and cosum but that's just silly
05:25:51 <roelof> Hello, I have some code which needs a lot of quickCheck and Hunit code. Is there a way I can put all the Hunit tests together and split the quickCheck test in groups 
05:30:23 <frerich> roelof: I heard good things about https://hackage.haskell.org/package/tasty
05:33:30 <Tritlo> Hey, I'm getting a SQL error on Stackage, is it down?
05:33:54 <Tritlo> "SQLite3 returned ErrorIO while attempting to perform prepare "PRAGMA journal_mode=WAL;": disk I/O error"
05:34:03 <roelof> frerich:  can I also make another layout with it.  I like more the output as shown here : https://batterseapower.github.io/test-framework/
05:34:06 <mniip> hmm
05:34:28 <mniip> how do I explain that when we're iterating over 2 values, one is the "inner" and the other is the "outer" iteratee
05:34:54 <frerich> roelof: I don't know - but if you like the output of test-framework, why not use it? :-)
05:35:48 <roelof> I can do that. Can I somewere check if test-framework is still up-to-date and maintained 
05:36:28 <roelof> oops, that page links to a git repo last updated in 2013, not good 
05:37:52 <Heather> lol windows defender ate 2gb ram and was growing so I was forcing it to stop and I can use my editor again
05:46:58 <roelof> frerich:  thanks, I will look into both 
05:47:16 <nshepperd> must have been trying to defend windows against the user
05:53:03 <roelof> Tritlo:  if you mean this one : https://www.stackage.org/   here no problem at all 
05:53:20 <Tritlo> roelof: https://www.stackage.org/lts
05:53:27 <Tritlo> roelof: I get the error here
05:54:30 <roelof> Tritlo:  correct, here the same error 
05:56:35 <TRManderson> can anyone explain the Applicative instance for (r ->)?
05:57:28 <Ankhers> TRManderson: Do you understand other Applicative's?
05:57:39 <TRManderson> I think mostly?
05:57:48 <TRManderson> assume yes, if I'm confused I'll say
05:58:36 <mniip> anyone wanna do some review :o https://github.com/mniip/finite-typelits
05:58:50 <quicksilver> (r ->) is an applicative where every action is a function, and they are all given the same value (the same 'r')
05:59:29 <eze> is there any gsoc 2016 posible mentor online?
05:59:39 <mniip> there's a reason it's called the environment monad (applicative)
05:59:43 <quicksilver> > sequenceA [reverse,("foo"++)] "bar"
05:59:45 <lambdabot>  ["rab","foobar"]
05:59:56 <aweinstock> :t [(\f g x -> f x (g x)), (<*>)]
05:59:57 <lambdabot> [(t -> a -> b) -> (t -> a) -> t -> b]
06:00:28 <TRManderson> ty
06:00:30 <aweinstock> :t [pure, const]
06:00:32 <lambdabot> [a -> b -> a]
06:13:41 <mniip> is there a way to make haddock generate hyperlinks to a specific location instead of file:///usr/share/doc
06:17:11 <bennofs> mniip: --html-location perhaps?
06:17:38 <KaneTW> can you specify CHECK constraints in persistent's model dsl
06:17:49 <KaneTW> CHECK startTime < endTime or so
06:17:50 <mniip> bennofs, that's not an option
06:18:03 <bennofs> mniip: oh, it's a cabal haddock option
06:19:01 <bartavelle> KaneTW, I don't think you can have arbitrary constraint in the TH part
06:20:24 <KaneTW> shame, would be nice to keep that invariant in the model
06:20:36 <bartavelle> constraints are not really part of the model though
06:20:47 <bartavelle> they are generated by mkMigrate based on data from the model
06:21:15 <bartavelle> there is a worse problem IMO: constraints are not fully generated if you separate your model in several modules
06:23:52 <KaneTW> well i'd like my type to enforce that constraint once dependent haskell appens, but that's not going to happen for a year or more
06:24:00 <KaneTW> i'm just thinking a bit ahead
06:24:14 <ggVGc> why are data constructors not namespaced to their type?
06:24:47 <merijn> ggVGc: How would you know which constructor was being used in an expression?
06:24:50 <bartavelle> KaneTW, you can probably already enforce these invariants in other ways (if you assume you will only touch the DB with your Haskell library)
06:25:10 <KaneTW> bartavelle: yeah
06:25:23 <merijn> ggVGc: e.g. what is the type of the expression "Foo"?
06:25:54 <quicksilver> ggVGc: they can be if you make the choice to define one type per module :)
06:26:30 <ggVGc> merijn: hm? All I mean is that instead of doing data ShapeType = ShapeTypeA|ShapeTypeB, we'd do ShapeType=A|B, and refer to it as ShapeType.A, or similar
06:27:01 <ggVGc> quicksilver: yeah, I know, but that's not really useful in practice
06:27:08 <quicksilver> I thikn the answer to your question ggVGc is "no good reason, but some people like it this way"
06:27:11 <merijn> ggVGc: Because that's the utterly obnoxious in C++ and Rust do it
06:27:17 <bartavelle> ggVGc, it would suck for many use cases, such as symbolic constructors
06:27:17 <quicksilver> it's an essentially arbitrary choice as far as I know.
06:27:20 <ggVGc> why is it obnoxious?
06:27:37 <merijn> ggVGc: Because it makes all my code 5000 characters long with a lot of redundancy
06:27:47 <ggVGc> isn't it less redundancy?
06:27:49 <merijn> And if I want to namespace it, I'll just use qualified imports
06:27:52 <bartavelle> ggVGc, (a List.: b List.: c List.: d List.: List.[]) :)
06:28:06 <merijn> ggVGc: No, because 95% of the time I don't prefix my constructors with a shared section
06:28:14 <merijn> ggVGc: And with your solution that can't work
06:28:32 <merijn> ggVGc: We'd have "Either::Left" and "Either::Right" like in C++/Rust everywhere
06:28:46 * hackagebot latex-formulae-image 0.1.0.0 - A library for rendering LaTeX formulae as images using an actual LaTeX installation  https://hackage.haskell.org/package/latex-formulae-image-0.1.0.0 (LiamOConnorDavis)
06:28:48 * hackagebot latex-formulae-pandoc 0.1.0.0 - Render LaTeX formulae in pandoc documents to images with an actual LaTeX installation  https://hackage.haskell.org/package/latex-formulae-pandoc-0.1.0.0 (LiamOConnorDavis)
06:28:52 <merijn> case foo of Maybe::Just x -> ??; Maybe::Nothing -> ?", etc
06:28:57 <ggVGc> merijn: but we already have functionality for importing thins into current namespace, so if you wanted that you'd just import the type constructors? Like "using" in C++
06:28:58 <merijn> See how this quickly becomes noisy?
06:29:34 <merijn> Shrug
06:29:50 <ggVGc> I'm not really arguing anything. Just pondered a thought
06:29:59 <merijn> I find the haskell default of moving things into a separate file and then importing qualified when I need to a more convenient default than the other way around
06:30:06 <ggVGc> But I do see a lot of shared prefix stuff on type constructors in haskell code
06:30:17 <merijn> As I find myself needing the qualification a lot less than the other way around
06:31:52 <quicksilver> it would be nice to have more fluidity in our ability to manage namespaces
06:31:57 <ggVGc> another question. What is the prefered implementation for when I want a T Int, where the Int is in a certain range? It would be nice with something like Ada's range types, but somehow statically enforced. I guess that requires dependent types?
06:32:10 <quicksilver> to create small ones just to put a namespace around two types
06:32:16 <quicksilver> and rename / remap them arbitrarily.
06:32:31 <quicksilver> ggVGc: use a smart constructor.
06:32:34 <bartavelle> ggVGc, "smart constructors", ie. you hide the T constructor and give access to it with functions that might fail, or a prism
06:32:34 <ggVGc> quicksilver: yeah, I've never been fond of the "One module per file" mentality that many languages have, including haskell
06:32:39 <quicksilver> or merijn's $(valid) stuff.
06:32:42 <merijn> ggVGc: Newtype wrapper with unexported constructor and "smart" constructor (i.e. "mkFoo :: Int -> Maybe Foo")
06:32:45 <frerich> ggVGc: If the range is not too big (maybe six elements?) then a plain enumeration would do. otherwise, some sort of smart constructor is common
06:32:56 <ggVGc> thanks
06:33:06 <merijn> ggVGc: And yes, go try my TH validation thing :p
06:33:49 * hackagebot latex-formulae-image 0.1.0.1 - A library for rendering LaTeX formulae as images using an actual LaTeX installation  https://hackage.haskell.org/package/latex-formulae-image-0.1.0.1 (LiamOConnorDavis)
06:34:05 <ggVGc> I'm actually writing Elm right now, so not sure how much of this advice will carry over. But it's good to know for when I'm writing haskell too
06:35:07 <mniip> woohoo I mastered haddocks
06:35:28 <mniip> https://rawgit.com/mniip/finite-typelits/docs/dist/doc/html/finite-typelits/
06:35:33 <mniip> hyperlinked to haddock and github!
06:35:51 <ggVGc> frerich: by that you mean an ADT deriving Enum right?
06:36:01 <jophish> Is there a type family Map (f :: a -> b) (xs :: [a]) :: [b] defined anywhere or should I just put it in myself?
06:36:10 <frerich> ggVGc: No (but you could do that). Just 'data T = One | Two | Three | Four'.
06:36:38 <ggVGc> frerich: but with a normal ADT like that, I I'l have to write the T->Int mapping myself right?
06:37:02 <mniip> ggVGc, :o that's exactly what I am working on
06:37:06 <mniip> except it's written in haskell
06:37:07 <bartavelle> ggVGc, if you derive Enum you have (partial) helper functions
06:37:14 <frerich> ggVGc: Yeah (if you need that, then you could derive Enum indeed to get fromEnum)
06:38:15 <ggVGc> mniip: range types? Or ADT with automatic T->Int ?
06:38:29 <mniip> a [0 .. n) range type
06:38:43 <ggVGc> cool
06:38:52 <bartavelle> (there is also liquid haskell that uses an external solver to check that kind of properties btw)
06:38:57 <mniip> ggVGc, https://rawgit.com/mniip/finite-typelits/docs/dist/doc/html/finite-typelits/Data-Finite.html#t:Finite
06:39:08 <ggVGc> mniip: will it be able to be statically checked? Or will it be runtime checked like Ada's range types(as far as I understand them)
06:39:26 <mniip> yeah no, it's runtime-checked at construction type
06:39:34 <ggVGc> yeah, but that's fair
06:39:38 <mniip> er
06:39:40 <mniip> at construction time
06:39:47 <mniip> however there are some nice functions available
06:40:17 <mniip> for example, add :: Finite n -> Finite m -> Finite (n + m) 
06:40:37 <mniip> that doesn't do any runtime checks
06:49:10 * hackagebot latex-formulae-pandoc 0.1.0.1 - Render LaTeX formulae in pandoc documents to images with an actual LaTeX installation  https://hackage.haskell.org/package/latex-formulae-pandoc-0.1.0.1 (LiamOConnorDavis)
06:53:28 <jophish> s
07:05:46 * Xandaros votes to change the default error message when encountering an undefined to not include the word "Exception"
07:05:54 <roelof> Is test framework still maintained ? 
07:06:02 <merijn> Xandaros: Why?
07:06:13 <Xandaros> Because it is misleading
07:06:21 <merijn> Xandaros: Why?
07:06:43 <merijn> I don't agree with that statement
07:07:01 <Xandaros> Well, it's not an Exception, is it? Sure, it's an exceptional state, but not a "catchable" exception that haskell does have
07:07:08 <merijn> Sure it is
07:07:29 <Xandaros> You can catch bottoms? ...
07:07:42 <merijn> The only problem is that since they're not using "throwIO" laziness can cause them to escape your catch/handler block
07:07:56 <merijn> You can catch undefined/error
07:08:01 <lesh_> Hi, I've been set an assignment to implement various functions using foldr, but we haven't really been given any guidance. I only ask because I am completely lost and confused.
07:08:17 <lesh_> I need to implement group with foldr. Where would I start
07:08:22 <merijn> Since "undefined =  error "Prelude.undefined""
07:08:32 <merijn> and "error s = raise# (errorCallException s)"
07:08:36 <lesh_> group [1,2,2,3,4,4,4,5] = [[1], [2,2], [3], [4,4,4], [5]] for example
07:08:55 <nshepperd> you can indeed catch them. even if it is discouraged to do so
07:09:00 <Xandaros> merijn: Alight, then. Point taken
07:09:18 <quicksilver> I'm with Xandaros there
07:09:36 <dave23> lesh_ you can have a tuple as a result of your fold
07:09:42 <Xandaros> quicksilver: Well, I just joined the other camp. Sorry :P
07:09:48 <quicksilver> merijn has pointed something out about the GHC implementation, but it's pretty specific and AFAIK not guaranteed (is it even documenteD?)
07:09:53 <dave23> so in the tuple you have both the current item and the result list
07:09:56 <mniip> haddock: internal error: topDeclElem UnhelpfulSpan
07:09:57 <roelof> lesh_:  maybe use filter to filter out the numbers 
07:09:58 <mniip> well played
07:10:18 <merijn> Well, if it were up to me we'd remove unchecked exceptions from the language entirely, but while we have them, we might as well catch undefined
07:10:18 <quicksilver> however
07:10:27 <merijn> quicksilver: The report just says undefined is bottom
07:10:38 <Xandaros> undefined = undefined
07:10:40 <quicksilver> they are called exceptions in the GHC papers which explain the feature
07:10:40 <Xandaros> done
07:10:41 <merijn> And GHC's exceptions are a form of bottom, so it's perfectly fine
07:11:10 <quicksilver> I don't think it's semantically wise to unify exceptions with bottom.
07:11:22 <quicksilver> because exceptions which you can throw and catch in various monads
07:11:33 <quicksilver> are clearly a well-behaved notion (and certainly don't involve _|_)
07:11:42 <merijn> quicksilver: eh...bottom is the only sane semantics for unchecked exceptions
07:11:45 <lesh_> so far I have got group xs = foldr f [] xs
07:11:50 <quicksilver> merijn: for sure
07:11:52 <merijn> Anything else would ruin your denotational semantics
07:11:54 <lesh_> just need to define f such that it works
07:11:59 <quicksilver> merijn: but it's not the right semantics for throwIO/catchIO
07:12:05 <merijn> Sure it is
07:12:09 <Ankhers> Xandaros: That would just infinitely call itself.
07:12:15 <quicksilver> no, because then they aren't a proper instance of MonadThrow
07:12:16 <mniip> oh
07:12:18 <Xandaros> lesh_: Currently designing an assignment sheet. I'm going to steal that idea :)
07:12:19 <merijn> IO doesn't have a denotational semantics
07:12:20 <quicksilver> or whatever you want to call it.
07:12:22 <mniip> I forgot to give a type signature
07:12:24 <lesh_> which I am having trouble with
07:12:55 <quicksilver> IO hasn't had its semantics written down but that isn't a blank cheque to make it arbitrarily bad
07:13:04 <quicksilver> we should still strive to make it consistent and well-behaved.
07:13:08 <lesh_> Xandaros: Please make sure you give them adequate guidance lol. Its like week 3 of haskell and nothing has been explained properly
07:13:16 <lesh_> i'm wholly lost
07:13:17 <merijn> quicksilver: If you want the elaborate explanation about why IO is terrible, talk to Conal :)
07:13:29 * hodapp tackles the awkward squad
07:13:32 <quicksilver> I don't imagine I need to hear it merijn :)
07:13:51 <quicksilver> although there is always more to learn.
07:13:52 <Xandaros> lesh_: I shall trry my best :D
07:14:01 <merijn> balls...
07:14:12 <merijn> I can't figure out how to prevent recursion in my types...
07:14:18 <lesh_> can anyone give me some pointers where to go from group xs = foldr f [] xs
07:14:29 <lesh_> I don't even know where to start with f
07:14:33 <Xandaros> I do think bottom should be a catchable exception (though it should then be guaranteed to work) - it's one of the few cases where I agree with exceptions
07:14:53 <roelof> lesh_:  look here : http://stackoverflow.com/questions/33423243/haskell-group-list-elements-with-foldr-function
07:15:14 * impure_hate is looking for an example of YAML usage
07:15:14 <lesh_> roelof: lol thats another student from my couse haha thanks
07:15:36 <Xandaros> lesh_: It usually helps me to think about the types first. If you got that down, things start getting easier ;)
07:15:37 <tdammers> Xandaros: what about infinite recursions?
07:16:04 <roelof> Any users of Test plaform here ? 
07:16:39 <Xandaros> tdammers: Depends. If it's one where GHC currently spouts <<loop>> back at you, then... maybe. Otherwise, no
07:17:25 <tdammers> Xandaros: the reason why I'm saying that is because making all bottoms catchable amounts to solving the halting problem
07:17:25 <merijn> Xandaros: I'm actually trying to implement checked exceptions for a lazy System F_ω so you can do things like catch bottom :)
07:17:47 <merijn> Except, my implementation of System F_ω is still buggy :p
07:17:48 <tdammers> Xandaros: but catching the trivial cases still sounds terribly useful to me
07:17:55 <Xandaros> tdammers: All we need to do is solve the halting problem, then
07:18:23 <merijn> Although I don't think anyone will want to alter GHC to the extent of ripping out unchecked exceptions and adding checked ones...
07:18:32 <merijn> Given the amount of hate over AMP :p
07:18:43 <Xandaros> Seriously, though. I think exceptions should be for exactly these kinds of things. NOT for file not found or common stuff like that. Should be exceptional...
07:18:52 <mniip> I wonder how hard would it be to add turtle-hare loop search into GHC
07:19:46 <lesh_> roelof: Yeah that makes sense but I want to write it such that it isn't just a blatant copy of that. Kinda hard now i've seen one way to do it
07:19:53 <quicksilver> Xandaros: why? it's just a convenient flow control concept.
07:20:05 <Xandaros> quicksilver: Either is your friend
07:20:08 <roelof> lesh_:  sorry for that 
07:20:12 <quicksilver> what you should be careful of is unifying the convenient flow control concept with something which breaks your denotational semantics.
07:20:23 <quicksilver> Xandaros: yes, and 'Either' is exceptions. There is no difference.
07:20:25 <tdammers> merijn: there was no way of getting out of the AMP situation without stepping on any toes
07:20:29 <lesh_> roelof: :P no worries you were helpful
07:20:38 <lesh_> thanks
07:20:39 <quicksilver> Xandaros: http://hackage.haskell.org/package/exceptions-0.4/docs/Control-Monad-Catch.html
07:20:53 <Xandaros> quicksilver: The difference is that you are "forced" to handle Either, yet an actual exception is just a bottom
07:21:13 <roelof> lesh_:  YW 
07:21:21 <mniip> ~ * e SomeException 
07:21:23 <mniip> <3 haddock
07:21:23 <quicksilver> Xandaros: well if you choose to define exception that way, sure.
07:21:43 <quicksilver> Xandaros: but normal IO Exceptions are not best viewed as _|_.
07:21:52 <ggVGc> I had a thought while out on a drive just now. Wouldn't it be nice if we could go "From this point in the code, make sure runtime errors can never happen".
07:21:58 <ggVGc> maybe it's already possible somehow?
07:22:11 <Xandaros> catch?
07:22:14 <merijn> ggVGc: You'll want to look into total languages
07:22:20 <Xandaros> oh, I see
07:22:36 <ggVGc> so you could have construction and setup at some part, where exceptions can happen, but from that oint on the compiler should be able to say "now nothing can error"
07:22:49 <hodapp> merijn: like what, Agda and Coq?
07:22:52 <ggVGc> merijn: yeah, but I don't want the whole language to be total
07:22:54 <roelof> Any users of Test plaform here ? 
07:23:17 <Xandaros> A totality checker for haskell might be nice
07:23:21 <E4xoi> ggVGc: Idris?
07:23:36 <merijn> hodapp: Or Idris + totality checker?
07:23:39 <ggVGc> merijn: what triggered it is you saying "They are runtime checked at creation". And I feel, runtime errors while constructing things can be okay, but from that construction on you should be able to have a fully type checked rogram without runtime exceptions
07:23:46 <quicksilver> Xandaros: http://community.haskell.org/~ndm/catch/
07:24:02 <hodapp> merijn: Humm, I suppose
07:24:04 <E4xoi> idris does have a totality checker
07:24:14 <merijn> ggVGc: "They are runtime checked at creation" <- in which context did I say this?
07:24:18 <E4xoi> it is really primitive right now though
07:24:26 <ggVGc> merijn: about your range type implementation
07:24:28 <ggVGc> maybe I misunderstood
07:24:43 <merijn> ggVGc: Ah, the "mkFoo :: Int -> Maybe Foo" thing you mean?
07:24:47 <ggVGc> yea
07:24:57 <merijn> ggVGc: I agree, that's why I wrote: https://hackage.haskell.org/package/validated-literals :p
07:25:15 <merijn> ggVGc: That will perform the the check at compiletime using TH :p
07:25:51 <ggVGc> yeah, that's nice
07:25:58 <merijn> Because "case mkFoo 5 of Nothing -> error "ugh...this failure should be checked at compile time..."; Just x -> ??" is annoying :p
07:26:33 <roelof> Two questions : Can I use Test Framework with Stack and is  Test Framework still maintained ? 
07:26:35 <ggVGc> merijn: yep, everytime I see an application of "error" I get a funny feeling of something not being optimal
07:28:24 <ggVGc> I wonder if TH could be adapted to also work with Elm somehow
07:28:32 <ggVGc> since Elm shares a lot of the core Haskell syntax
07:28:46 <tdammers> ggVGc: the use case for error, IMO, is pretty much like that for exit() in C
07:28:56 <merijn> ggVGc: That's more of a "can anyone be bothered to implement it in the compiler?" kind of issue
07:29:06 <lesh_> OK I've been told to make a Sudoku solver. there is some guidance, but not enough for me to understand what to do
07:29:07 <ggVGc> merijn: right, but I wonder how much work it would be
07:29:12 <tdammers> ggVGc: "everything went so horribly wrong that the only reasonable thing to do is die loudly"
07:29:13 <merijn> ggVGc: There's no theoretical reason why you couldn't have "Template Elm"
07:29:36 <lesh_> I need a function that returns True if a sudoku is finished (although valid doesn't matter).
07:29:46 <lesh_> Is this as simple as making sure that none of the cells are empty?
07:29:47 <ggVGc> merijn: yeah, but it would be nice if Template Elm and Template Haskell shared a big core implementation
07:30:25 <merijn> ggVGc: That's really not possible, something like Template Haskell is completely compiler specific
07:30:30 <tdammers> ggVGc: I think the best way to go about this would be to implement Template Elm separately, but following the TH API
07:30:37 <merijn> We can't even share Template Haskell implementations between GHC versions...
07:30:42 <ggVGc> oh
07:30:50 <ggVGc> didn't know it was that bound together
07:30:54 <ggVGc> never actually used TH personally
07:30:57 <tdammers> the alternative would be to take Haskell AST and translate it into Elm AST before inserting it into the compilation
07:31:00 <hodapp> sometimes, TH scares me.
07:31:01 <ggVGc> just used libraries using TH
07:31:06 <merijn> hodapp: Why?
07:31:09 <tdammers> but that would amount to a Haskell -> Elm transpilr
07:31:14 <hodapp> I DON'T KNOW
07:31:14 <ggVGc> tdammers: yeah, something like that is what I was thinking about
07:31:31 * merijn kicks tdammers for using the world transpiler
07:31:36 <c_wraith> Huh.  I'm looking at how Data.Map and Data.Set foldMap.  There was a lot of work done to avoid mempty showing up.
07:32:02 <quicksilver> c_wraith: well nested cases are ugly but cheap :)
07:32:02 <ggVGc> tdammers: but how much work would that actually be? The core of haskell is pretty small right? I.e there are two compilation stages as far as I understand. And the lower one is quite simple compared to the first stage
07:32:22 <merijn> hodapp: TH is just "using Haskell to generate an AST of haskell code"
07:32:33 <hodapp> yeah, I know, I've written a bit
07:32:50 <merijn> There's nothing particularly morally objectionable about it
07:33:04 <lesh_> valid puzzle = all (unique . filter lone) (rows puzzle)
07:33:14 <lesh_> i need to define rows
07:33:30 <tdammers> ggVGc: a lot of work I suppose
07:34:02 <ggVGc> I dunno...
07:34:24 <c_wraith> It's not really all that much work, I guess.  It's just remarkably effective for a simple check.
07:34:30 <ggVGc> Haskell core(System FC) seems very similar to what's currently available in ELM, so I think it would be reasonable to do a translation
07:34:52 <tdammers> ggVGc: the problem is that the languages don't map exactly
07:35:02 <ggVGc> yeah..
07:35:06 <ggVGc> the biggest issue being laziness
07:35:13 <ggVGc> which I guess will mess up the whole thing a lot
07:35:44 <tdammers> so my guess is it'll be a lot easier just exposing the existing Elm AST to a template library that works like TH
07:35:46 <ggVGc> I still keep asking myself if laziness is a good or bad thing for haskell
07:36:16 <merijn> ggVGc: The problem with TH is not the core, but that it needs to be able to support all of Haskell's syntactic sugar
07:39:03 <roelof> Two questions : Can I use Test Framework with Stack and is  Test Framework still maintained ? 
07:39:11 * hackagebot hfsevents 0.1.6 - File/folder watching for OS X  https://hackage.haskell.org/package/hfsevents-0.1.6 (LuiteStegeman)
07:39:16 <tdammers> ggVGc: considering how Haskell is basically an experiment in "let's see how far we can get if we make our language pure and transparently default to lazy evaluation", I would say, good thin
07:39:18 <tdammers> g
07:42:17 <ggVGc> tdammers: yeah, okay, for haskell it's good. Because it's a valid experiment. But I'm not sure if lazy-by-default is actually more useful than eager. It's interesting playing around in Elm now, since it's practically a simpler Haskell, but eager
07:42:58 <mniip> guys do you think this pkg is ready for hackage https://rawgit.com/mniip/finite-typelits/docs/dist/doc/html/finite-typelits/
07:43:07 <ggVGc> I'm leaning towards eager-by-default with annotation for making certain functions lazy, is the best way
07:43:11 <merijn> I should really at some point just write an essay on "why lazy is the best default", because I'm too lazy (ha!) to keep saying it :p
07:43:24 <ggVGc> merijn: I'd read it
07:43:59 <ggVGc> I'm very much on the fence, but also don't understand enough of a lazy-by-default context to judge well. I don't have much haskell exerience yet
07:44:23 <merijn> ggVGc: Imagine you have a long pipeline of maps/folds (all strict) that you are applying to some long list. If you decide you want to lazily stream those you have to go back and add annotations to every single intermediate function to make it work as expected (i.e. streaming instead of eating up all your memory)
07:44:52 <merijn> Whereas most problems caused by laziness like the memory leaks you get with foldl can be solved locally, i.e. a single annotation in the one place it can occur
07:45:12 <Kaligule> I have a program which works if stdin is terminal, but not when I pipe something to the program. (Details here https://github.com/jtdaugherty/brick/issues/21 ). Does someone know how to solve this in a haskell way (without a bash wrapper)?
07:45:20 <merijn> The short summary is "it's easier to selectively add strictness and get the desired result than it is to selectively add laziness"
07:45:29 <ggVGc> merijn: hm, fair, but which one is easier/harder to find out?
07:45:53 <Tekkkz> Hello! I bought these two books: https://www.packtpub.com/big-data-and-business-intelligence/learning-haskell-data-analysis and https://www.packtpub.com/big-data-and-business-intelligence/haskell-data-analysis-cookbook ... can you give me a tip which i should start and read first?
07:45:59 <hodapp> merijn: please write that essay; I would gladly read it, and probably proofread it. Whether you ask me to or not.
07:46:03 <ggVGc> from what I understand, laziness-bugs often show up far away from where that strictness annotation should be
07:47:01 <c_wraith> quicksilver: it's not actually using a nested case.  It just special-cases subtrees of size 1
07:48:18 <roelof> Two questions : Can I use Test Framework with Stack and is  Test Framework still maintained ? 
07:49:11 <Tekkkz> srhb and bennofs : any ideas?
07:49:15 <Ankhers> roelof: It looks at least somewhat active. The last commit to the project was in September.
07:49:58 <Tekkkz> Ankhers: you an idea?
07:50:32 <roelof> oke, I in doubt to use Test framework or tasty , Ankhers 
07:50:40 <quicksilver> c_wraith: hmm I thought I remembered the Map/Set source being full of 2-depth cases all over
07:50:40 <Ankhers> roelof: As for using it with Stack, I cannot think of a reason it would not work. Stack uses the same library as cabal-install.
07:50:52 <Ankhers> Tekkkz: I have not read either book.
07:50:53 <quicksilver> c_wraith: just not for this example perhaps :)
07:51:17 <Tekkkz> Ankhers: but any idea from the title or description with which i should start?
07:51:33 <c_wraith> quicksilver: well, I'm sure the balancing algorithms do that.  But foldMap is simpler than balancing a tree. :)
07:51:40 <roelof> Ankhers:  oke, in the readme there is only mentioned about test-framework stand alone 
07:52:22 <Ankhers> Tekkkz: How familiar are you with Haskell?
07:52:30 <Tekkkz> im relatively new
07:52:48 <Ankhers> It may be better to start with a book / course to learn Haskell.
07:52:55 <Tekkkz> ya
07:52:59 <Tekkkz> im currently in one course
07:53:00 <Tekkkz> its ok
07:53:05 <Ankhers> @where haskellbook
07:53:06 <lambdabot> I know nothing about haskellbook.
07:53:14 <Tekkkz> but im ready for that books i linked
07:53:21 <Ankhers> @where learnhaskell
07:53:21 <lambdabot> https://github.com/bitemyapp/learnhaskell
07:53:23 <Ankhers> that one
07:53:29 <Tekkkz> ya
07:53:31 <Tekkkz> im doing it
07:53:38 <Ankhers> Which part are you on?
07:54:12 <Tekkkz> nearly done with Yorgey's cis194 course
07:54:52 <quicksilver> byorgey++
07:54:59 <Tekkkz> ??
07:54:59 <Lokathor> Tekkkz, between the two books you linked, i'd guess you should read the cookbook second once you're ready for the subject
07:55:14 <Tekkkz> so what does "cookbook" means?
07:55:17 <Tekkkz> ^^
07:55:20 <byorgey> =)
07:55:42 <Ankhers> Tekkkz: I was about to say the same as Lokathor. The cookbook I believe would assume some knowledge of data analysis.
07:55:46 <Tekkkz> byorgey: its yours?
07:56:01 <Tekkkz> Ankhers: okay thanks . i also had this idea
07:56:02 <Lokathor> a programming cookbook is usually like, "here's a common problem, and here's a small solution outline for it"
07:56:09 <Tekkkz> ahh ok
07:56:14 <Tekkkz> like a cookbook :D
07:56:15 <Ankhers> CIS194 is byorgey 's course.
07:56:22 <Tekkkz> cool
07:56:25 <Tekkkz> hello byorgey
07:56:28 <Lokathor> so the other book would probably give a better background overall
07:56:35 <byorgey> hi Tekkkz =)
07:56:46 <Tekkkz> im new :D you help me a lot with your course
07:56:58 <byorgey> Tekkkz: very glad to hear you found it helpful!
07:57:21 <Tekkkz> okay gguys, tahnks for all, im away now, cu
07:57:27 <Ankhers> good luck
07:58:09 <roelof> byorgey:  how many chapters of Craft do you need to do before I can do your course ? 
07:59:08 <byorgey> roelof: I am not familiar with Craft.  My course is designed to start from zero, so in theory you don't need any of it, but YMMV.
07:59:44 <byorgey> "start from zero" is obviously a lie, since there are always assumptions about what is taken for granted and what is explained.
07:59:54 <roelof> YMMV ??? I tried CIS194 earlier but got stuck on week 2 . 
08:00:22 <Ankhers> roelof: Did you read the suggested text?
08:00:24 <byorgey> roelof: sorry to hear that. what was it you got stuck on?
08:00:35 <Lokathor> roelof, i'd give it another try now that you're up to chap 5 in your other book
08:00:45 <mniip> moo
08:01:17 <roelof> Lokathor:  oke,chapter 5  I just begon with it 
08:01:45 <Lokathor> a lot of the time with beginner's haskell, you get stuck on how different things can be
08:01:47 <roelof> byorgey:  the idea how a tree works in Haskell. I could not make a image of it 
08:02:50 <roelof> Lokathor:  do I need to finisch chapter 5 or make now the transition 
08:03:12 <Lokathor> well either way. doesn't have to be super formal
08:03:25 <Lokathor> it all kinda goes into a big melting pot of haskell ideas
08:04:12 * hackagebot finite-typelits 0.1.0.0 - A type inhabited by finitely many values, indexed by type-level naturals.  https://hackage.haskell.org/package/finite-typelits-0.1.0.0 (mniip)
08:04:14 <jophish> I have a HList with elements all of type forall a. Foo a. I have a function toInt :: forall a. Foo a -> Int. I'm sure there must be a way to use the machinery in HList to go from my HList to [Int]
08:04:14 * hackagebot keera-posture 0.2.3 - Get notifications when your sitting posture is inappropriate.  https://hackage.haskell.org/package/keera-posture-0.2.3 (IvanPerez)
08:04:31 <roelof> Lokathor:  correct and craft is al more about testing with QuickTest and Hunit then learn new things 
08:08:05 <mpickering> Can someone please explain the comment on "phantom" in "contravariant" - "by the time you factor in the laws of each of those classes, it can't actually use it's argument in any meaningful capacity." 
08:08:43 <roelof> byorgey:  no github where I can clone all the code for it. I mean for this one : http://www.seas.upenn.edu/~cis194/spring13/lectures.html
08:09:01 <mniip> mpickering, a functor that is both covariant and contravariant has to support both fmap and contramap
08:10:29 <mpickering> so if f is both covariant and contravariant, the argument is that it must not look at the value, otherwise one of the instances wouldn't be law abiding 
08:10:59 <mniip> if f is both co and contravariant, 'f a' doesn't contain any 'a'
08:11:10 <mpickering> hence the name phantom
08:11:14 <quchen_> Sounds hard enough to write fmap and contramap even, regardless of the laws
08:12:04 <mniip> consider
08:12:05 <mniip> :t contramap (const id) . fmap const
08:12:07 <lambdabot> (Functor f, Contravariant f) => f a -> f b
08:12:36 <mniip> that only makes sense if f is phantom
08:12:44 <mniip> or rather, if f's argument is phantom
08:13:30 <mpickering> I understand that but I was wondering specifically about the comment about the laws
08:13:53 <mniip> well
08:14:19 <roelof> byorgey:  ping 
08:14:21 <mniip> laws require that both fmap and contramap preserve the structure
08:14:33 <mniip> therefore their composition also preserves the structure
08:14:34 <quicksilver> jophish: if your list has elements all of the same type (exists a . Foo a) you didn't really need an HList at all
08:14:54 <quicksilver> jophish: you could just data SomeFoo = forall a . Foo a and [SomeFoo]
08:14:56 <jophish> This still seems to want a homogeneous list: hMapOut (foo :: forall a. Foo a -> Int)myList
08:15:03 <mniip> this, in combination with existence of 'f a -> f b', requires that 'f a' doesn't contain 'a'
08:15:07 <quicksilver> jophish: (and then the translation to [Int] is easy)
08:15:10 <mniip> if we disregard the laws,
08:15:10 <jophish> quicksilver: It's not all the same type, some are Foo Int and other Foo Bool
08:15:23 <quicksilver> jophish: (exists a  . Foo a)
08:15:28 <jophish> sorry, just reread that :)
08:15:32 <mniip> :t (>> [])
08:15:34 <lambdabot> [a] -> [b]
08:15:44 <mniip> but that doesn't preserve the structure
08:16:41 <jophish> quicksilver: I can try to brings things back down to regular lists, but I think they're needed elsewhere
08:17:44 <jophish> quicksilver: I use Foo's parameter for typechecking elsewhere, so if I made them all (exists a. Foo a) then I'd lose that information
08:18:04 * quicksilver nods
08:18:32 <mniip> wow
08:18:41 <mniip> docs generate really qiuckly now
08:18:57 <jophish> quicksilver: looking at the HList source it seems as though Show is implemented with a custom typeclass, so I think I'll have to do the same
08:19:40 <jophish> otherwise the show implementation would just be "H[" ++ concat (hMapOut show l) ++ "]" -- or something
08:20:00 <jophish> Thanks quicksilver for listening :D
08:24:14 * hackagebot git-annex 5.20151102.1 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-5.20151102.1 (JoeyHess)
08:24:42 <zzing> Can anyone suggest the best way to be introduced to the conduit package?
08:26:46 <quicksilver> zzing: I found this a helpful overview : pcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview
08:26:55 <quicksilver> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview
08:27:04 <quicksilver> although it's very slightly out of date I think
08:27:10 <merijn> jophish: You can do Show for something HList like fairly simply
08:27:53 <merijn> jophish: For example, see here: https://gist.github.com/merijn/dc00bc7cebd6df012c5e#file-gistfile1-hs-L13-L21
08:28:01 <zzing> quicksilver, thank you.
08:30:24 <zzing> I have this large (150mb) csv file that I am parsing with cassava, and after ten minutes didn't terminate (yet?) and was taking about 3gb of memory. So I figure something like conduit might provide an easier method of going through it.  (existing source if anyone is interested: https://gist.github.com/madebyjeffrey/bfec336253e546ca4676 )
08:31:14 <quicksilver> well cassava has its own incremental parser
08:31:51 <dmj``> @package pipes-csv
08:31:51 <lambdabot> http://hackage.haskell.org/package/pipes-csv
08:32:13 <quicksilver> but yes that is the typical use case of conduit and pipes
08:32:34 <zzing> Now I hear pipes and conduit in the same breath a few places. 
08:33:06 <c_wraith> They have the same purpose, but a bit different designs 
08:33:07 <srhb> zzing: Two different approaches to the same problem.
08:33:50 <srhb> You could also hear enumerators or iteratees.
08:33:53 <zzing> Has any particular one become "the one" to use or otherwise have a larger following?
08:34:02 <srhb> Though those describe the concept rather than implementation, I think.
08:34:22 <srhb> zzing: Conduit has a large following by virtue of being in the internals of Yesod. Whatever that may mean for your choice.
08:34:30 <dmj`> io-streams is another player too
08:34:35 <srhb> Ah, yes, forgot that one.
08:34:44 <dmj`> pipes are bidirectional, I don't think conduits are
08:35:31 <dmj`> data ConduitM i o m r
08:35:35 <dmj`> data Proxy a' a b' b m r
08:36:11 <zzing> When I see types like that I think   data MessyTypes a b c d e f g h i j k l m n o p q r s t u v w x y z
08:36:12 <merijn> Personally I find pipes more elegant and with a more orthogonal interface than conduits
08:36:40 <merijn> i.e. pipes-safe and pipes-concurrency and pipes-parse are nicely seperate libraries that tie nicely into pipes
08:36:51 <zzing> Does pipes have an equivalent to conduit-extra?
08:36:52 <dmj`> wish ghci retained the type synonyms, makes the learning curve steeper
08:36:59 <merijn> zzing: I think conduit and pipes have an interoperability library now
08:37:01 <srhb> zzing: You shouldn't, just learn what each parameter means :-)
08:37:10 <merijn> zzing: No clue what conduit-extra is
08:37:11 <bitemyapp> I'd say the biggest advantage to pipes is that if you start thrashing on Pipes, it's easier to escape the type tetris than conduit.
08:37:19 <dmj`> zzing: pipes has a lot of supporting packages
08:37:31 <bitemyapp> this is not what I would expect, given the difference in the types, but I suspect it's a byproduct of other parts of the API design.
08:37:41 <bitemyapp> biggest advantage for a new person anyway, I suppose.
08:37:48 <zzing> conduit-extra ties in stuff like attoparsec for example.
08:38:10 <dmj`> @package pipes-attoparsec
08:38:11 <lambdabot> http://hackage.haskell.org/package/pipes-attoparsec
08:38:28 <bitemyapp> I need to pick pipes-distributed back up.
08:41:05 <nshepperd> i prefer conduit, but there's no real rational reason I can articulate for that
08:41:54 <zzing> The one thing I find difficult to deal with in these methods for dealing with streaming data is when I need do something special with the first item. For example, the header in my csv file has to be decoded and used with every line that comes after it. 
08:41:58 <bennofs> conduit is more pragmatic, while pipes is more idealistic.
08:43:54 * hodapp frantically takes notes on this whole discussion.
08:44:17 <quicksilver> zzing: that particular issue shouldn't be a problem with either
08:45:13 <quicksilver> they both let you write sequential code (in a monad) so you can easily "do this then that"
08:45:27 <quicksilver> and they both allow you to "sideways compose" those bits of sequential code
08:45:56 <quicksilver> so it's like "this part" is getting the input which is the output of the "the part to the left"; and handing its output out to be hte input of "the part on the right"
08:46:49 <zzing> What I have been doing in my current source is to process the head, and zip the head and other rows together
08:48:21 <hodapp> http://www.cse.chalmers.se/~hallgren/Papers/hallgren.pdf - How relevant is this paper as a reference on fundeps, given that it's almost 15 years old?
08:53:27 <dmj`> hodapp: this might be more relevant, https://ocharles.org.uk/blog/posts/2014-12-14-functional-dependencies.html
08:53:35 <hodapp> dmj`: thanks, will look
08:54:08 <hodapp> those older Haskell papers have varying levels of dust about them
08:54:22 <quicksilver> fundeps haven't actually changed
08:54:27 <quicksilver> (as far as I can remember)
08:54:41 <gpampara-> I§
08:55:00 <quicksilver> but TIL that ocharles__ has done a 24 days of GHC extension, so that's great. Thanks dmj`.
08:55:36 <hodapp> quicksilver: fundeps might not have changed, but other things might have
08:55:47 <hodapp> and the explanation might not make as much sense
08:58:32 * quicksilver nods
08:58:55 <quicksilver> yup. Although the core type system (haskell98 + MPTCs + fundeps) has been very stable
09:05:53 <dedbox> pl \x -> (x + 1) * (x + 2)
09:06:43 <Ferdirand> @pl \x -> (x + 1) * (x + 2)
09:06:44 <lambdabot> liftM2 (*) (1 +) (2 +)
09:08:02 <Jinxit> is that really better though?
09:08:05 <dedbox> @pl \x -> (x + 1) * (x + 2)
09:08:05 <lambdabot> liftM2 (*) (1 +) (2 +)
09:09:10 <kadoban> Jinxit: Not terrifically, unless you're used to ((->) r)'s Applicative instance
09:09:24 <orion> What's the most concise way to construct an Aeson Object? I can't use "object [ ... ]" because that returns a Value, not an Object,.
09:10:03 <dedbox> Thanks!
09:11:11 <glguy> orion: type Object = HashMap Text Value
09:11:31 <glguy> orion: So just using methods from Data.HashMap.Lazy with Text keys and Value values
09:11:31 <dedbox> @pl \x -> x + x * 2
09:11:32 <lambdabot> ap (+) (2 *)
09:12:27 <glguy> dedbox: You can play with lambdabot in /msg
09:12:41 <orion> glguy: Ah, I see.
09:15:32 <dedbox> glguy ok
09:19:16 * hackagebot grouped-list 0.2.1.0 - Grouped lists. Equal consecutive elements are grouped.  https://hackage.haskell.org/package/grouped-list-0.2.1.0 (DanielDiaz)
09:32:32 <emmanuel_erc> hello there everyone!
09:33:04 <epta> emmanuel_erc: hey! :)
09:40:12 <jophish> merijn: yeah, it's not too hard to do myself. I was hoping that there was some machinery in HList itself to make that a little easier
09:42:24 <Zemyla> Why don't more opaque types contain Coercions that are proofs the types inside can be coerced?
09:43:07 <Zemyla> Like, say Attoparsec has something along the lines of parserCoercion :: (Coercible a b) => Coercion (Parser a) (Parser b).
09:43:59 <ttt_fff> how does haskell snap (or other frameworks) compare with https://news.ycombinator.com/item?id=10500488 ?
09:45:59 <kadoban> ttt_fff: Well, I assume other frameworks have figured out that using JS on the client-side to convert a template into HTML isn't a good idea for one.
09:49:20 <MasseR> ttt_fff: A good question. I'm not sure if there have been such large scale efforts to replicate similar case
09:56:44 <hodapp> hmm, I am now in the dubious position of needing to generate a function whose arity depends on a list of types (e.g. '[Foo, Bar, Baz] to Foo -> Bar -> Baz -> r)
09:57:11 <MasseR> hodapp: I wrote something similar a couple of days ago
09:57:24 <MasseR> servant-style typesafe routing with url-printer
09:58:26 <hodapp> MasseR: this is something for the Ivory library, which encodes C procedure types in Haskell types
09:59:14 <hodapp> with a construct like '[Uint8, Uint16] ':-> () for void f(uint8_t, uint16_t), for instance
09:59:52 <hodapp> if you want to implement the above, you'd have something like: proc "foo" $ \arg1 arg2 -> body $ do ...
10:00:00 <MasseR> I'm winging it but something like this:
10:00:01 <hodapp> where arg1 is the Uint8 value, arg2 is the Uint16 value
10:00:07 <MasseR> class Variant a where
10:00:12 <MasseR>   type X a
10:00:19 <mmachenry> What's the easiest way to handle a cabal package's dependency being broken when I want to install that package?
10:00:24 <voronoi_potato> cabal is exhausting :(
10:00:31 <MasseR>   proc :: Proxy a -> X a
10:00:43 <voronoi_potato> mmachenry: having a similar struggle mmachenry 
10:01:57 <emmanuel_erc> hi epta!
10:02:12 <mmachenry> voronoi_potato: Yeah I agree. Hopefully it'll be replaced by Stack or something in the general use of Haskell.
10:02:16 <jle`> mmachenry: the typical thing i do is nuke everything :|
10:02:33 <mmachenry> jle`: Well.. I think that what's on Hackage is broken
10:02:35 <hodapp> MasseR: hmm, how does one then use 'proc'?
10:02:37 <jle`> that's the "simplest", by some definition of simple
10:02:44 <jle`> oh, ah
10:05:06 <orion> Is it an anti-pattern to write a function like "mkFooPipe :: MVar X -> Pipe ... IO ()" such that when the pipe terminates, the MVar is filled?
10:06:21 <orion> I basically have this pipeline: "runEffect $ socket-incoming >-> deserialize >-> perform-cryptographic-handshake >-> serialize >-> socket-outgoing" and I want to be able to get a cryptographic context out of the handshake.
10:08:06 <lifter> orion: why might that be an anti-pattern?
10:08:15 <MasseR> hodapp: sorry, `proc :: Monad m => Proxy a -> m (X a) -> m ()` or something like that
10:08:45 <orion> lifter: No idea. I've never used Pipes before today so I am not sure what makes sense and what doesn't.
10:09:11 <MasseR> When you are in your induction step, you modify the X type to take ie. Int variable and in the implementation you have something like 'proc _ f = \x -> proc rest (f x)`
10:09:59 <lifter> orion: oh I see. I tried to learn the pipes library and got some traction before I figured out that it wasn't the right tool for my particular problem. Only thing I might recommend is that you look into maybe using the async library if you have to spawn a thread and wait for it's result
10:10:33 <orion> I see, ok.
10:10:35 <lifter> someone who knows pipes better might be better able to answer your question
10:10:37 <hodapp> MasseR: I was just about to say that a similar technique - turning (a1 -> a0) to (a2 -> (a1 -> a0)) by adding one argument - seems like it'd work :P
10:11:50 <MasseR> hodapp: :). And in your base case you either return the new function or invoke it
10:12:20 <hodapp> MasseR: sounds good. It's always the former for me because the function's just modeling what happens at C runtime
10:14:18 * hackagebot keera-hails-reactivevalues 0.2.0.1 - Haskell on Rails - Reactive Values  https://hackage.haskell.org/package/keera-hails-reactivevalues-0.2.0.1 (IvanPerez)
10:14:20 * hackagebot keera-hails-reactivevalues 0.2.0.2 - Haskell on Rails - Reactive Values  https://hackage.haskell.org/package/keera-hails-reactivevalues-0.2.0.2 (IvanPerez)
10:14:39 <emmanuel_erc> What would you guys say is the hardest part of learning Haskell?
10:15:15 <zomg> the math words used to describe how everything works =)
10:15:37 <c_wraith> emmanuel_erc: learning how to derive meaning from type signatures. 
10:15:53 <tulcod> emmanuel_erc: there is no One Manual for things. people refer to all kinds of documents, making it rather difficult to find your way around
10:15:59 <tulcod> even though the actual material can be very good
10:16:03 <c_wraith> emmanuel_erc: especially when extensions get involved. 
10:17:00 <ttt_fff> is there a stufy of haskell web servers + how many websckets they can handle?
10:17:12 <Hafydd> emmanuel_erc: perhaps coming to fully appreciate with the extreme level of abstraction involved in some of the concepts, like (as a relatively mundane example) Monads.
10:17:14 <tulcod> emmanuel_erc: also, another difficult thing is that you will find that you have been wrong about programming your entire life. that can be a psychological blow. :)
10:17:50 <lifter> emmanuel_erc: the hardest part is throwing away large amounts of code as you learn there are better ways to do things, and you really need to start over now that you know.
10:17:55 <Hafydd> (This is also why so many people feel compelled to try to explain them, and subsequently fail because they themselves do no understand them and/or they don't know how to communicate.)
10:19:09 <lifter> emmanuel_erc: the hardest thing for me was throwing away weeks of code because I realized I needed an entirely different monad transformer stack for my app
10:19:34 <emmanuel_erc> that's painful lifter
10:20:02 <lifter> yeah but I find it happens when I learn a new language
10:20:17 <tulcod> (this also happens in other languages. though usually it's not clear that it is better, so you end up forking projects all over. in haskell, it's usually pretty clear that some abstraction is clearly better)
10:21:09 <lifter> when I first learned C++ and OOP, I had to write a lot of bad code before I could learn how to write good code; same thing w/ Haskell and FP
10:21:35 <emmanuel_erc> That means I am probably writing  bad code, I am only 8 months into Haskell
10:22:16 <voronoi_potato> bad code that works is often good enough emmanuel_erc, just keep cleaning :P
10:22:45 <lifter> yeah when you learn a new trick you could go back and look at what you've already written and see if you can apply it thru some refactoring
10:23:20 <voronoi_potato> I honestly wanted to work on a thing today but I can't figure out cabal and hoped that sandboxes would make things easy
10:24:56 <voronoi_potato> I am starting to think things would be easier without any package manager :(
10:25:28 <emmanuel_erc> I am starting to get the idea that optimizing Haskell code is very tricky.
10:25:37 <emmanuel_erc> Do you guys have any generic pointers?
10:25:43 <tulcod> voronoi_potato: [ obligatory "cabal is not a package manager" comment ]
10:25:47 <voronoi_potato> sure
10:25:50 <c_wraith> voronoi_potato: wipe your global package dB. Then use a sandbox. 
10:26:10 <tulcod> emmanuel_erc: profilers
10:26:20 <hodapp> this is why I use stack I guess
10:26:23 <tulcod> emmanuel_erc: also https://xkcd.com/138/
10:26:25 <lifter> emmanuel_erc: check out the latest Haskell Cast episode
10:26:50 <emmanuel_erc> Nice xkcd...
10:26:59 <emmanuel_erc> I am in a programming chat
10:27:03 <voronoi_potato> I thought I did wipe my global package db but I'm unsure
10:27:16 <voronoi_potato> and I think sandbox persisted
10:27:17 <emmanuel_erc> I'll check that out.
10:28:43 <tulcod> hodapp: to what degree does stack replace cabal? do i need to add .stack files to all my projects? or does it reuse the cabal env for the actual package building?
10:29:07 <tulcod> hodapp: iow, is cabal a dependency of stack?
10:29:11 <hodapp> It reuses cabal for much of the building.
10:29:43 <kadoban> tulcod: It replaced cabal-install completely. It uses the Cabal library internally. You still need .cabal files for a project, usually. You also need a stack.yaml file, which is generally pretty short.
10:30:08 <tulcod> kadoban: is stack.yaml a global file?
10:30:27 <kadoban> tulcod: per-project, usually, though there is a global one for when you're not in a specific project.
10:30:51 <tulcod> well i mean, is this a file I should start adding to all projects i'm writing?
10:30:59 <tulcod> or is it more like a sandbox specification?
10:31:23 <tulcod> would you find stack.yaml in the git repo of a project?
10:31:23 <kadoban> tulcod: Yes, you should be adding it to all of your projects. You can try, after the project is set up, just 'stack init' and see what it gives you, often that's enough.
10:32:02 <kadoban> Yep
10:32:10 <tulcod> cheers
10:50:40 <mniip> aargh
10:50:43 <mniip> goddamn typelits
10:59:12 <destsk> Hello - why does checking the type of (\f -> f f) give me an error? (I only know that it's got to do with the type inference algorithm)
11:00:56 <srhb> destsk: What do you think the type of f should be?
11:02:10 <destsk> srhb: Well, one type could be a -> a, right?
11:02:23 <destsk> Because (id id) is typeable
11:02:32 <srhb> destsk: How do you unify a with a -> a ?
11:02:34 <srhb> (same a)
11:02:41 <destsk> Oh, I see
11:03:13 <destsk> Is that the same for (\f -> (f True) : (f []))?
11:03:26 <destsk> Thanks for answering srhb!
11:03:38 <srhb> Bool /~ [a]
11:03:44 <srhb> That's one thing at least
11:03:46 <breadmonster> destsk: I think that'll result in a type error.
11:04:30 <destsk> Right, sorry, I confused this with another example
11:04:37 <destsk> Thanks srhb breadmonster 
11:05:48 <mniip> [22:02:50] <destsk> Is that the same for (\f -> (f True) : (f []))?
11:05:51 <mniip> actually no
11:05:59 <mniip> that one is typeable under Rank2Types
11:06:34 <jle`> destsk: id id is typeable, but that's because the two id's have difeferent types
11:07:17 <destsk> jle`: is there any way I can check that in ghci?
11:07:21 <destsk> I see what you mean though
11:07:23 <srhb> destsk: _ id
11:07:44 <jle`> destsk: (id `asTypeOf` _) (id `asTypeOf` _) should work
11:07:47 <srhb> Actually, that just substantiates it
11:07:51 <jle`> ghci will tell you the types of both
11:07:54 <srhb> Yeah, what jle` said :-)
11:08:38 <destsk> awesome, thanks!
11:08:40 <jle`> on mine it says that one is (a -> a) -> a -> a, and the other is a -> a
11:08:54 <jle`> you need a sufficiently recent version of ghc, though (like within the past few years)
11:09:11 <bitemyapp> jle`: congrats btw :)
11:09:22 <jle`> oh haha ty
11:09:39 <jle`> now i just need to make sure it is properly promoted here so it has enough students to be worth keeping open v.v
11:09:48 <jle`> small school problems
11:10:06 <bitemyapp> jle`: what school?
11:10:19 <jle`> chapman university
11:10:28 <bitemyapp> jle`: I could make an FB campaign to target CS majors at Chapman :P
11:10:42 <jle`> in Orange County, california
11:11:05 <jle`> haha let them know if you know any.  i'm probably going to email cs faculty to tell their students and stuff.
11:11:12 <Unhammer> if I put library-profiling:true in my cabal.config, will it make things slower when I compile my executable without -prof?
11:11:31 <bitemyapp> jle`: no I mean like an ad campaign :P
11:11:36 <Unhammer> or does it make extra copies of things sort of
11:12:52 <jle`> bitemyapp: haha. if you want :P  that's something i hadn't thought of lol
11:13:09 <jle`> utilizing facebook's evil for good
11:13:31 <bitemyapp> jle`: I work in ad-tech, so when I need a break from writing the book I think of cute things to do with ad campaigns.
11:13:43 <bitemyapp> jle`: e.g. our adwords campaign targeting searches about OCaml
11:14:02 <jle`> haha
11:14:23 <bitemyapp> jle`: the Reddit campaign I tested also targeted /r/ocaml
11:14:27 <bitemyapp> and /r/sml
11:14:48 <jophish> What are the precedences of => and -> ? infixr 1 and 2 respectively?
11:16:23 <jle`> bitemyapp: there's a whole world out there @.@
11:17:37 <srhb> jophish: I don't think you can really talk about them in those terms.
11:19:41 <jophish> srhb: I'm writing a little dsl for another language and have defined type operators --> and ==> (doing the same job as the haskell ones). What fixites should I settle on :)
11:21:11 <breadmonster> :info (>>=)
11:22:10 <srhb> jophish: I suppose you can think of (->) as infixr 0
11:22:20 <mniip> hmm
11:22:20 <srhb> jophish: I'm not sure we can even talk about fixity with =>
11:23:07 <mniip> how would one implement KnownNat n => p 0 -> (forall k. KnownNat k => p k -> p (k + 1)) -> p n
11:23:13 <jophish> srhb: one is able to do thinkgs like: Num a => Show a => a -> b
11:23:15 <jle`> fixity does associate
11:23:47 <jle`> i mean, => does have a fixity of sorts
11:23:49 <mniip> in particular, how do I witness that a particular KnownNat is either 0 or 1 + n
11:23:57 <jle`> because of things like that, yeah
11:24:06 <mniip> for 0 you could use sameNat, but what about the other one
11:24:17 <srhb> jophish: For the record: https://git.haskell.org/ghc.git/commitdiff/0721e552b863c28ffb5920c70b208947831c3dc2
11:24:21 * hackagebot HulkImport 0.1.0.1 - Easily bulk import CSV data to SQL Server  https://hackage.haskell.org/package/HulkImport-0.1.0.1 (smobs)
11:25:09 <jle`> mniip: this is something where i am tempted to use unsafeCoerce
11:25:15 <mniip> yes but
11:25:28 <mniip> there's got to be a better way
11:25:51 <jle`> ^ that is me at 3am every time i do something with TypeLits
11:26:04 <jle`> s/do/try to do
11:26:48 <mniip> or actually
11:27:03 <mniip> KnownNat n => p 0 -> p (1 + k) -> p n
11:27:09 <mniip> this is what I need
11:39:46 <tdammers> ggVGc: it's a tradeoff, but I'd say as long as purity is a given, lazy evaluation as an optimization strategy is the sane default for most things
11:40:20 <tdammers> ggVGc: laziness combined with uncontrolled side effects is kind of a train wreck though
11:42:55 <ReinH> tdammers: so is strictness.
11:43:14 <monochrom> no one really combines laziness with effects.
11:43:20 <ReinH> jle`: o/
11:43:41 <bitemyapp> monochrom: there was that one evil scheme
11:43:45 <ReinH> jle`: protip: don't write code when you're drunk or sleep deprived ;)
11:43:49 <monochrom> but see http://lpaste.net/77374
11:43:53 <voronoi_potato> I thought i'd try yi out, but I can't get it to build lol
11:44:06 <ReinH> voronoi_potato: try leksah?
11:44:10 <ReinH> It's maintained.
11:44:23 <ReinH> I got a demo at ICFP this year, it's looking pretty good.
11:44:38 <tdammers> ReinH: IMO purity is a much much bigger deal than laziness
11:44:49 <ReinH> tdammers: Yes, that's my point as well. :)
11:44:51 <voronoi_potato> yeah but that's not terminal based :/
11:45:02 <ReinH> voronoi_potato: Ah. Fair point.
11:45:06 <ReinH> voronoi_potato: vim or emacs?
11:45:39 <ReinH> tdammers: uncontrolled side effects are a train wreck, full stop.
11:45:40 <voronoi_potato> yeah that's what I'm falling back on, but I was excited about yi, sad that it's not being kept up so well
11:46:13 <ReinH> tdammers: The real difference for me is whether the language controls them or forces the developer to try to control them.
11:46:16 <jophish> Cool beans, thanks srhb and jle` 
11:46:33 <voronoi_potato> I moved away from vim because viml is no bueno, elisp is a good bit better than viml but still missing some major aspects
11:46:58 <voronoi_potato> kinda feels like building real world projects with legos
11:47:10 <jophish> I think I'll have to go with infixr 1 --> and infixr 0 ==> though
11:47:27 <tdammers> ReinH: agree. And in this regard, the way Haskell handles laziness/strictness isn't ideal either
11:48:41 <mniip>     Could not deduce ((n1 <=? n) ~ 'True)
11:48:41 <mniip>     from the context (n ~ (n1 + 1))
11:48:43 <mniip> aaaaaaaaaaaaa
11:51:51 <jophish> voronoi_potato: you might want to check out neovim, the plugin story for other languages is a lot better
11:52:20 <jophish> mniip: what are you playing with there?
11:52:53 <tdammers> I find vim pretty much completely sufficient
11:53:05 <tdammers> my trick is not trying to turn it into an IDE
11:53:16 <mniip> jophish, typelits are the worst
11:53:40 <jophish> mniip: how about all that smt solver stuff which was being talked about?
11:54:22 * hackagebot tagged 0.8.2 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  https://hackage.haskell.org/package/tagged-0.8.2 (EdwardKmett)
11:55:14 <jophish> ^ that's my change :D
11:55:28 <hodapp> haskell 98 phantom types? huh
11:55:36 <kadoban> Anyone know specifically why test-framework-smallcheck is deprecated? Did the dev just get tired of it, or? It seems weird that that stuff is deprecated, but test-framework itself works great. I don't want to switch to tasty just over that.
11:55:46 <jophish> hodapp: just a version bump on template-haskell
11:56:00 <hodapp> jophish: uh, that's for TH?
11:56:07 <hodapp> s/uh/oh/
11:56:10 <hodapp> dvorak :)
11:56:40 <jophish> kadoban: as far as I know, the maintainer just stopped maintaining test-framework
11:56:50 <jophish> kadoban: tasty is pretty cool though
11:57:36 <jophish> hodapp: just raising the upper version limit for ghc 7.11
11:58:47 <hodapp> jophish: I'm just curious as to why that Haskell 98 stuff is there but I suppose some folks still use Haskell98 only or Haskell98 and only a handful of extensions
11:59:01 <kadoban> jophish: Are you sure? It looks basically maintained. It builds and works with newest GHC, and it has a maintainer … "Libraries List", isn't that the group that does all of the important haskell libraries?
11:59:22 * hackagebot concurrent-output 1.3.0 - Ungarble output from several threads  https://hackage.haskell.org/package/concurrent-output-1.3.0 (JoeyHess)
12:00:26 <anoe> Hello, I do not understand my bug here : http://lpaste.net/144532
12:00:40 <anoe> (using Data.Csv, cassava)
12:02:45 <kadoban> jophish: Well, maybe I should just use tasty anyway for new stuff, it looks like it supports basically all of the same stuff anyway. Thanks for the answer.
12:05:12 <palo_> hey, any tips how to find haskellers in a particular city (except meetup.com)?
12:05:17 <jophish> hodapp: no idea, all I know is that it wasn't building with 7.11 :)
12:05:31 <no5> hello, i am kind of new to haskell and i have a question. i have a function f :: Int -> Int -> Int -> Int, why does (flip . f) flip the 1st and 3rd argument? thanks
12:06:19 <jophish> kadoban: this is where I got that info from: http://documentup.com/feuerbach/tasty#background
12:06:42 <hodapp> jophish: fair enough
12:07:08 <hodapp> palo_: find yourself to the nearest vaguely related meetup (say, functional programming) and ask them?
12:07:32 <kadoban> jophish: Ah, interesting. Oh huh I didn't notice it was the same guy from test-framework-smallcheck.
12:08:19 <koala_man> > let f = (,,) in (flip . f) 1 2 3
12:08:20 <lambdabot>  (1,3,2)
12:09:06 <palo_> hodapp: i've done that (scala meetup) but not that many positive hits on haskell .. :)
12:09:20 <no5> yes, you are right, i mean why doesnt it flip the first two
12:24:26 * hackagebot cql 3.0.6 - Cassandra CQL binary protocol.  https://hackage.haskell.org/package/cql-3.0.6 (ToralfWittner)
12:29:27 * hackagebot distributed-static 0.3.3.0 - Compositional, type-safe, polymorphic static values and closures  https://hackage.haskell.org/package/distributed-static-0.3.3.0 (MathieuBoespflug)
12:34:08 <vektor> how come maxBound defaults to () when not given a type?
12:35:49 <vektor> that is... in ghci at least.
12:40:00 <kadoban> vektor: I'm not sure the real answer, but my guess would be that it's because it's funny.
12:41:50 <vektor> Hmm... My guess would've been that ghci checks a list of type for positive match and the first in that list happens to be ()
12:42:05 <vektor> *list of types
12:42:31 <vektor> whereas GHC will shout at you if the type can't be derived with certainty.
12:43:04 <kadoban> vektor: That's not exactly true. GHC has defaults as well, it just doesn't have as many as ghci.
12:43:12 <mniip> vektor, yes, it's called monomorphism restriction and defaulting
12:43:41 <mniip> the defaulting order is, specificly, (), Integer, Double
12:43:43 <mniip> unless overridden
12:43:55 <bernalex> vektor: try ":set -XMonomorphismRestriction" in ghci first.
13:01:30 <haskeller_novice> hi, I have found a code that traverse directory to find files, but I stumble against this infix operator <\> that I don't know
13:01:49 <haskeller_novice> what module should I import to use it, and what is it about ?
13:02:26 <kadoban> haskeller_novice: Are you sure it's not </> ?
13:02:41 <haskeller_novice> the code in question is in stackoverflow: http://stackoverflow.com/a/23822913/356440    I imported Control.Monad, but that's not sufficient
13:03:19 <hodapp> Everyone be nice to johnw. He's the new Emacs maintainer now.
13:05:12 <kadoban> haskeller_novice: It's from the filepath package, System.FilePath module.
13:05:33 <haskeller_novice> many thx, i'm gonna look at it right now
13:05:43 <m_ryan> hi what is the best library of haskell for getting the ip and location of a user? thank you
13:11:15 <voronoi_potato> location?
13:11:50 <voronoi_potato> ip based location can be way off
13:11:58 <voronoi_potato> typically is way off
13:12:34 <Ferdirand> i'm guessing the question is "is there a library to query a GeoIP database in the maxmind format" or something
13:15:43 <m_ryan> GeoIP yes something like that..
13:16:11 <osfameron> oooo, I'm using a GeoIP library for a project (but in Perl...)
13:16:54 <m_ryan> how about in pure haskell?
13:17:00 <osfameron> well, google throws up https://hackage.haskell.org/package/hs-GeoIP
13:18:24 <m_ryan> yes i saw it also. any other suggestion base on your experience?
13:20:24 <osfameron> the MaxMind GeoIP stuff is good, so it's certainly worth trying.  The MaxMind guy I know did say that I should use GeoIP*2* though instead
13:20:45 <osfameron> e.g. if you follow the haskell docs link through to http://dev.maxmind.com/geoip/legacy/geolite/ you'll see that it says this is the legacy format
13:21:08 <osfameron> which might eventually be an issue
13:21:30 <m_ryan> thank you :)
13:21:52 <osfameron> (the Perl library does support the new format, but this is the wrong channel to try to convince you to use that :-)
13:22:18 <sm> go on, give it a shot
13:22:33 <osfameron> :-)
13:22:33 <emmanuel_erc> hello there everyone
13:23:06 <osfameron> oh, and googling for "haskell geoip2" does throw up https://hackage.haskell.org/package/geoip2
13:23:17 <osfameron> so I suspect the Perl thing is going to be a hard sell ;-)
13:26:16 <m_ryan> im not familiar with perl :)
13:26:45 <sm> hodapp: woah!!
13:42:29 <tommd> @tell edwardk Are you still planning on making an interior points method for AD?
13:42:29 <lambdabot> Consider it noted.
13:47:08 <joobus> is servant the new hotness in haskell web interfaces?
13:48:19 <cite-reader> From what I've seen.
13:48:38 <joobus> it certainly has better documentation than snap, for instance
13:51:53 <alpounet> joobus: servant dev here. being one of the youngest it certainly is talked about a lot these days, and probably is attractive because of the free client functions and what not. there are still a few dark corners and we make breaking releases so it's not super stable yet. so really it depends on how hard you want its features and how ready you are to deal with the few quirks and the breakage =)
13:53:24 <joobus> alpounet: good to know.  I read your docs and they were a lot more straightforward than writing a custom snap monad
13:53:36 <cite-reader> alpounet: Do you have a plan for reaching stability, or is it still in the "we don't have any idea how long these things will take" phase?
13:54:02 <bitemyapp> I wonder if lens is considered stable ;)
13:55:32 <nerdsville> I have a question, why does drop not really drop elements from a list? or am I missing something http://lpaste.net/144538
13:56:06 <alpounet> joobus: thanks! we're certainly trying to compensate the "describe APIs at the type level" aspect by having a decent tutorial. and the overall approach is radically different, so that simple stuffs are reasonably easy to write. OTOH we don't provide as many things out of the box and we don't want to be as opinionated as the others -- the fact that the DSL is extensible is precisely because we want to let
13:56:08 <alpounet> folks "customize" the framework to suit their needs and tastes.
13:56:19 <pikajude> nerdsville: i don't understand your question
13:56:22 <joobus> nerdsville: what didn't work?
13:56:26 <pikajude> nerdsville: do you mean, why l isn't getting any shorter?
13:56:34 <nerdsville> yeah
13:56:43 <pikajude> data structures in haskell are not modifiable
13:57:04 <lifter> no assignment is hapenning
13:57:07 <nerdsville> ah I see now
13:57:11 <nerdsville> thank you! :)
13:57:51 <joobus> alpounet: I do like your approach.
13:58:03 <alpounet> cite-reader: yeah, we kind of have a plan, but I can't say it'll happen really soon. for example, folks are developping snap and happstack backends right now, which prompts us to think about making the whole server bit less wai-dependent, etc. but we're fixing quirks in every release so hopefully things will stabilize as we go! =)
13:58:49 <mniip> how can I get a type-witness of a Nat being nonzero?
14:00:07 <old_spice> data B where
14:00:11 <old_spice>     B :: NFData a => a -> B
14:00:24 <old_spice> this is from text package
14:00:53 <old_spice> why not type?
14:01:23 <old_spice> is there a constructor in this construct?
14:02:04 <old_spice> module Benchmarks.Pure
14:02:33 <cite-reader> I'm not sure what your question is. Is this your first time encountering GADT syntax?
14:02:33 <c_wraith> old_spice: that's an existential encoded as a GADT
14:03:15 <old_spice> well I am used to seeing data constructs as this:
14:03:22 <old_spice> data A = A Int
14:03:26 <Denommus> anyone got reflex-0.3 and reflex-dom-0.2 to work with stack?
14:04:01 <old_spice> I am not sure is data B where B:: ... fits in here
14:04:03 <mniip> old_spice, B contains something that is an NFData
14:04:22 <mniip> it's like saying data B = B (forall a. NFData a => a)
14:04:26 <old_spice> isn't NFData a constraint?
14:04:33 <c_wraith> old_spice: it's GADT syntax. More verbose, but more expressive. 
14:04:53 <mniip> old_spice, it is
14:05:25 <luigy> Denommus I gave it a try... maybe you find it helpful https://github.com/luigy/try-stack-reflex
14:05:28 <mniip> so if you pattern match on B, like case of B x -> {...}
14:05:39 <mniip> in that scope you will know that x is an NFData
14:05:47 <mniip> but you won't know what it actually is
14:06:19 <old_spice> is it covered in Real World Haskell book?
14:08:06 <mniip> I don't think GADTs are quite old enough to be covered in RWH?
14:08:14 <old_spice> ahh ok
14:08:16 <old_spice> https://en.wikibooks.org/wiki/Haskell/GADT
14:08:30 <old_spice> data Expr a where
14:08:31 <old_spice>     I   :: Int  -> Expr Int
14:09:01 <old_spice> so how is it different from class?
14:09:09 <mniip> eh?
14:09:18 <old_spice> I mean, class defines function signatures
14:09:32 <mniip> a GADT has no instances?
14:09:45 <c_wraith> I is a constructor there, not an abstract specification. 
14:10:01 <mniip> haskell syntax tends to be very similar to itself, really
14:10:28 <old_spice> why not use a type instead?
14:10:48 <old_spice> what extra data gives us?
14:10:59 <old_spice> what extra functionality "data" gives us?
14:11:23 <mniip> you wouldn't declare Expr using your regular tools
14:11:26 <c_wraith> It gives you a type with constructors allocated at runtime. 
14:11:55 <c_wraith> "type" doesn't give you constructors. 
14:12:23 <cite-reader> "data" mints an entirely new type, which cannot be confused with any other type. "type" merely allows you to rename a type you already have, but Haskell doesn't distinguish the original and your new alias.
14:12:23 <old_spice> why would we need a constructor for a constrained function signature?
14:12:26 <mniip> old_spice, I don't think you quite understand the point of GADTs
14:12:40 <mniip> a constrained function signature?
14:12:45 <mniip> it's not a function signature
14:12:49 <mniip> it's a constructor declaration
14:13:17 <old_spice> ok, I think I get part of it:
14:13:26 <old_spice> type A = Int -> Bool
14:13:33 <old_spice> data G where
14:13:45 <old_spice>    A :: Int -> Bool
14:13:51 <old_spice>    G :: Int -> Bool
14:14:04 <old_spice> and 
14:14:10 <old_spice> data H where
14:14:14 <c_wraith> That's illegal. Constructors of the type G must return a value of type G
14:14:20 <mniip> "data G where A :: Int -> Bool" is not valid
14:14:23 <old_spice>    H :: Int -> Bool
14:14:29 <old_spice> sorry, typo
14:14:45 <mniip> typo?
14:15:08 <old_spice> so by using data we distinguish between 
14:15:25 <old_spice> G and H
14:15:33 <old_spice> data Expr a where
14:15:33 <old_spice>     I   :: Int  -> Expr Int
14:15:33 <old_spice>     B   :: Bool -> Expr Bool
14:16:00 <old_spice> we may use different ctors with Expr a
14:16:02 <old_spice> ok
14:16:04 <old_spice> sorry
14:16:14 <old_spice> I did not use Haskell for a few months
14:16:15 <c_wraith> old_spice: this is a bit complex to explain. It'd be easier if you slowed down a bit. :) 
14:16:21 <mniip> do you understand the difference between data and type?
14:16:21 <old_spice> got sidetracked
14:16:24 <old_spice> yes
14:16:29 <mniip> like
14:16:31 <mniip> regular data
14:16:35 <mniip> not generalized
14:16:39 <old_spice> yes, I understand parts
14:16:41 <old_spice> :)
14:16:42 <mniip> good
14:16:52 <old_spice> just did not use Haskell for a few months, that's all
14:16:54 <mniip> now the point of GADT is
14:16:55 <old_spice> ;)
14:16:59 <mniip> when we say
14:17:06 <mniip> data Maybe a = Nothing | Just a
14:17:09 <mniip> we declare two constructors
14:17:14 <mniip> Just :: a -> Maybe a
14:17:15 <old_spice> mniip 
14:17:16 <mniip> Nothing :: Maybe a
14:17:22 <old_spice> yes, I read a few Haskell books
14:17:32 <old_spice> just got confused by the syntax
14:18:04 <mniip> ...
14:18:04 <old_spice> I worked on a Java program
14:18:12 <old_spice> for the past few months
14:18:44 <old_spice> the simpler syntax is fine
14:18:49 <tommd> old_spice: You only need to nod.  No one here assumes you didn't know just because mniip explained something - it's just good to lay the foundation in the explaination, regardless of if the particular person knows.
14:19:10 <tommd> (also I find it helpful when I'm the one explaining, but that might jsut be me)
14:19:14 <old_spice> ta tommd
14:19:36 <mniip> well, old_spice has clearly shown that they don't want an explanation, yet I still don't think they understood the idea
14:19:49 * hackagebot qed 0.0 - Simple prover  https://hackage.haskell.org/package/qed-0.0 (NeilMitchell)
14:19:51 <old_spice> I just feel impolite if someone is trying to explain something I believe to understand
14:20:15 <old_spice> impolite on my part
14:20:25 <old_spice> I mean, it feels like I waste their time
14:20:50 <mniip> I was not explaining how Maybe works
14:21:03 <mniip> I was trying to transition from ADTs to GADTs using Maybe as an example
14:21:09 <old_spice> ah ok
14:21:12 <old_spice> go on..
14:21:34 <old_spice> sorry what's ADT?
14:21:42 <Ferdirand> relevant question: does it make sense to define a GADT which has no type arguments ?
14:21:49 <tommd> Algebraic Data Type - like Maybe, for example.
14:21:49 <sinelaw> say you have a grammar: var := "x"; expr := var | expr expr, and a parser that always returns all the possible parsings. if you give it "x" you'll get as the first result 'var', but if you give it an invalid string, say "y", it will loop indefinitely on the "exp exp" recursion. how do you go about preventing that?
14:22:29 <sinelaw> if you parsers can be Eq or Ord, you can check that you're not recursing on the same stream position; but if they aren't, I can't see a way out
14:22:33 <mniip> Ferdirand, yes for existential quantification
14:23:40 <Ferdirand> oh. Well I don't grok existential quantification yet, but that is good to know
14:24:30 <mniip> Ferdirand, exactly the B type up there
14:25:08 <old_spice> can ADT be polymorphic?
14:25:20 <hodapp> ADT as in algebraic data type?
14:25:59 <old_spice> from wiki the difference between ADT and GADT seems to be polymorphism, no?
14:26:22 <hodapp> What sort of polymorphism are you talking about?
14:26:31 <hodapp> You can parametrize an ADT over whatever type parameters you want
14:26:38 <old_spice> right
14:26:41 <Ferdirand> mniip: ah, well, guess I used existentials already without knowing then. Awesome.
14:26:57 <old_spice> so in wiki
14:27:16 <old_spice> ADT: data Expr = I Int 
14:27:37 <old_spice> Phantom: data Expr a = I Int
14:27:59 <old_spice> GADT: data Expr a where
14:27:59 <old_spice>     I   :: Int  -> Expr Int
14:28:13 <sinelaw> data Expr a = E a  -- also a non-GADT type, but it's polymorphic
14:28:48 <old_spice> so GADT must come with a signature?
14:29:04 <old_spice> a ctor and a signature?
14:29:11 <old_spice> then we get GADT?
14:29:21 <old_spice> vs ADT
14:29:32 <sinelaw> old_spice: if using the GADT syntax, you can have a non-GADT type: data Expr a where E :: Some -> Types -> Here -> Or -> a -> E a
14:29:48 <sinelaw> like: E :: a -> E a, I :: Int -> E a, etc...
14:30:12 <sinelaw> sorry I meant:
14:30:18 <sinelaw> like: E :: a -> Expr a, I :: Int -> Expr a, etc...
14:30:23 <old_spice> but from wiki it seems that this is GADT
14:30:24 <sinelaw> but the result of each constructor must be the same as the left hand side, "Expr a"
14:30:43 <old_spice> https://en.wikibooks.org/wiki/Haskell/GADT
14:30:56 <sinelaw> old_spice: it's GADT syntax, yes, but it still isn't a GADT 
14:31:04 <sinelaw> I'm using it to explain the difference
14:31:37 <old_spice> would you show a GADT which certainly isn't ADT,  please?
14:31:48 <sinelaw> so: data Expr a where I :: Int -> Expr a, E :: a -> Expr a -- this isn't a GADT because all constructors return "Expr a"
14:31:57 <sinelaw> however:
14:32:15 <sinelaw> data Expr a where I :: Int -> Expr Int, E :: a -> Expr a -- this IS a GADT because NOT all constructors return "Expr a"
14:32:27 <sinelaw> you have Expr Int there
14:32:37 <old_spice> ok I got it
14:33:12 <old_spice> thank you guys
14:33:22 <sinelaw> np
14:34:05 <shachaf> "GADT" is a syntax.
14:34:09 <obadz> is there a way to write >>= purely in terms of return and join (but not fmap) ? if so, please don't tell me what way that is..
14:34:15 <shachaf> Every type can be expressed as a GADT or not as a GADT.
14:34:27 <shachaf> It has nothing to do with the type itself, only with how you write the definition.
14:35:19 <sinelaw> shachaf: but that syntax enables writing types not expressible by the older syntax
14:35:48 <shachaf> Every type you can write in GHC with the GADT syntax you can write without the GADT syntax.
14:36:42 <old_spice> but then we'd need to define different data types, no?
14:37:23 <shachaf> I don't understand.
14:37:24 <old_spice> or can we squeeze every GADT into one ADT?
14:38:15 <dolio> That doesn't mean that certain types aren't inherently "GADTs" in the sense that there was a notion of algebraic types and a more generalized class of them that are now expressible in various ways.
14:38:17 <old_spice> well I understood that GADT allows polymorphic signatures with different return types, no?
14:39:04 <Saizan> old_spice: say, data Expr a where I :: Int -> Expr Int can be written as data Expr a = (a ~ Int) => I Int 
14:39:29 <shachaf> dolio: Sure, I guess you can call every type that uses existentials and so on a GADT if you want to.
14:39:41 <dolio> I wouldn't call existentials GADTs.
14:40:19 <dolio> But that might just be me.
14:40:37 <shachaf> GHC uses "existential" to mean endowments as well as quantifiers.
14:41:00 <shachaf> Or at least it gets turned on by the same extension.
14:41:04 <dolio> I don't tailor my use of terminology to what GHC does.
14:41:32 <shachaf> Fair enough.
14:42:03 <shachaf> I don't know what "GADT" really means but every use of it that I've seen has involved a different syntax.
14:42:08 <nerdsville> is there a way to use ranges in haskell to accumulate all special chars
14:42:23 <dolio> It means indexed inductive types with large indices.
14:42:41 <cite-reader> nerdsville: to the best of my knowledge, "special char" is ill-defined. What are you trying to do?
14:43:26 <dolio> At least, that is one way you could specify the difference from normal ADTs.
14:43:39 <dolio> Normal meaning inductive types, rather than inductive families.
14:44:15 <nerdsville> retrieve all characters which are not letters or numbers, technically I could do [c | c <- list, not( elem c ['a'..'z']), not ( elem c ['A'..'Z'] ), not ( elem c ['0'..'9'])] 
14:44:20 <nerdsville> But is there a better way
14:45:14 <sinelaw> nerdsville: Data.Char.is...
14:45:26 <sinelaw> nerdsville: http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Char.html
14:45:27 <old_spice> are special chars = non-ascii?
14:45:30 <cite-reader> There's isAlphaNum, but uh why do you want it?
14:45:38 <mpickering> What is the intuition behind the contravariant constraint on Control.Lens.Fold 
14:46:06 <nerdsville> I am just trying different things, I am completely new to haskell so I am trying to do as many things as I can think of 
14:46:32 <old_spice> http://stackoverflow.com/questions/3001177/how-do-i-grep-for-all-non-ascii-characters-in-unix
14:46:40 <old_spice> [\x80-\xFF]
14:47:40 <linman32> how long does HaRe take to install? i'm using stack install HaRe, but it does not finish the build phase
14:47:58 <mpickering> does not finish, as in hangs or?
14:48:15 <linman32> it seems to hang. even after 3 or 4 minutes
14:48:24 <mpickering> you can ask alanz on #haskell-refactorer, if I remember right there is one module which takes ages to build 
14:48:31 <mpickering> right that doesn't seem like too long
14:48:45 <mpickering> so far the focus is on making it work rather than optimising build time
14:49:11 <nkaretnikov> edwardk: yo, got a question about 'rounding'.  why was it abandoned?
14:49:39 <linman32> mpickering: thanks. i'll try being more patient first ;)
14:50:29 <nkaretnikov> edwardk: is 'fixed-precision' supposed to be its successor?
14:51:12 <mpickering> linman32: let us know how it goes for you :)
14:51:20 <mpickering> (using HaRe that is)
14:56:23 <sinelaw> since ghc can detect loops, should we be able to write: if x == _|_ ?
14:56:36 <sinelaw> or something to that effect
14:57:24 <c_wraith> sinelaw: GHC can detect when evaluating an expression depends on the result of evaluating that expression.. Not arbitrary loops. 
14:58:17 <sinelaw> c_wraith: well, I'm interested specifically in that kind
14:58:28 <nerdsville> sinelaw couldn't you use elem? I am new to this 
14:58:34 <nerdsville> elem c list
14:58:49 <nerdsville> elem x list rather
14:59:35 <old_spice> what hackage packages contain most varied, complicated yet proper Haskell syntax?
14:59:35 <old_spice> or large & many files in one package
14:59:37 <old_spice> ?
14:59:44 <old_spice> any favourites?
15:00:48 <sinelaw> nerdsville: data N = Z | S N, then: x = S x
15:00:54 <old_spice> .. "some of" most, not necessarily "the" most
15:01:07 <sinelaw> I'd like my evaluator of "N" values to detect "x" and abort
15:01:41 <sinelaw> if N is an instance of Eq, no problem
15:01:56 <nerdsville> oh lol this is wayyy over my head right now
15:02:04 <nerdsville> I just thought it looked similar to a list comprehension
15:03:18 <sinelaw> actually even with Eq instance that's a problem.
15:03:40 <sinelaw> c_wraith: any idea how to detect that 'x' is infinite in that example?
15:05:03 <c_wraith> sinelaw: that's not an infinite computational loop. It's just a circular linked list. 
15:05:36 <c_wraith> sinelaw: it violates referential transparency to be able to detect that it's circular. 
15:06:18 <c_wraith> sinelaw: if you want to do it anyway, look into reallyUnsafePointerEquality
15:06:34 <sinelaw> ah. no, not that way :)
15:09:39 <wearenotdeadyet> could someone tell me what is wrong with this? http://pastebin.com/bV7vQ19q
15:09:50 <wearenotdeadyet> Not my code, trying to understand the compiler error
15:10:42 <cite-reader> I don't have that library at hand, what's the error?
15:11:00 <old_spice> IOUArray should there be space?
15:11:08 <old_spice> IO UArray
15:11:22 <wearenotdeadyet> http://pastebin.com/GVYPHk9z
15:11:30 <c_wraith> wearenotdeadyet: in general, when asking about compiler errors, include the error in the a comment in the code. 
15:11:44 <sinelaw> c_wraith: ok, practically speaking if I have: eval :: N -> Maybe Integer, I'd like it to return Nothing if the value is cyclic. 
15:12:05 <Hafydd> An IOUArray is a type specialised to hold multiple official acknowledgements of debt.
15:12:16 <old_spice> ah got it. cheers
15:12:32 <Welkin> new_spice
15:12:43 <old_spice> :)
15:12:44 <nerdsville> LOL @Hafydd
15:12:52 <c_wraith> wearenotdeadyet: GLInt doesn't have the necessary instances to be put in an unboxed array. 
15:14:30 <c_wraith> sinelaw: no way to do that in the general case. I can make versions that are computationally undecidable. 
15:14:34 <wearenotdeadyet> c_wraith: ok, help me out here (still learning haskell) - I tried to do some research on my own, it looked like writeArray was defined for certain argument types, one where there is a glint is not one of them...is that what you mean?
15:14:36 <Welkin> STDArray
15:14:41 <Hafydd> Hahaha.
15:14:57 <nrolland> anyone know the name of that haskell game on the web where you need to compose blocks which uses isometric.js 
15:15:07 <nerdsville> I am new to haskell too, I just laughed at Hafydd's play on words :)
15:15:27 <Welkin> nrolland: never heard of it
15:15:54 <c_wraith> wearenotdeadyet: it's an artifact of the way IOUArray is implemented. It needs code for every type that you can put in the array, and no one ever wrote that code for GLInt
15:16:27 <Welkin> wait, unboxed arrays in IO?
15:16:28 <Welkin> haha
15:16:45 <wearenotdeadyet> c_wraith: I...see.... I figured I had to stick gli2i = fromIntegral :: GLint -> Int in there somewhere....
15:16:46 <Welkin> I thought Hafydd added the U
15:17:10 <lpaste> emmanuel_erc pasted “Critique? Find distances between all pairs of points.” at http://lpaste.net/144540
15:17:19 * wearenotdeadyet not actually even sure what gli2i is, looks like a template to me
15:17:55 <nrolland> ok its http://david-peter.de/cube-composer/
15:18:32 <sinelaw> c_wraith: using type-level nats, we can have our non-cyclic list type (:) :: a -> List n a -> List (n+1) a
15:18:39 <sinelaw> (pseudo-syntax)
15:18:45 <nrolland> ah its in purescript not haskell
15:19:12 <sinelaw> then: x = 1 : x will not compile
15:19:23 <c_wraith> sinelaw: yeah, that works because all types must be finite at compile time. 
15:19:44 <c_wraith> sinelaw: values don't have that restriction. 
15:22:38 <sinelaw> c_wraith: isn't it because n ~ (n + 1) can't type check? not infinite types
15:23:53 <sinelaw> hmm, is TypeFamilies enabled it allows it
15:24:23 <c_wraith> Until you try to use it with any concrete type. 
15:25:00 <sinelaw> I assume
15:25:44 <wearenotdeadyet> c_wraith: ok I think I see the issue, I will show the full source and what I think the solution is
15:26:09 <sinelaw> c_wraith: I see why you say infinite types
15:26:15 <wearenotdeadyet> http://hackage.haskell.org/package/frag-1.1.2/src/src/Curves.hs
15:26:17 <wearenotdeadyet> is the source
15:26:51 <wearenotdeadyet> end of that file, the writeIndicies is a function which takes a mutable array and a tuple of int,glint
15:27:21 <wearenotdeadyet> I need to change the type to not Glint and do a conversion in the code above it (where writeIndices is used)?
15:27:54 <wearenotdeadyet> how close/far off am i?
15:28:29 <c_wraith> wearenotdeadyet: that sounds close, but I'm having trouble opening that file on my phone. :) 
15:28:36 <wearenotdeadyet> heh, ok
15:28:56 <sfdebug> hi
15:29:15 <nerdsville> Any recommendations to improve this code? I am following the 99 haskell problems and was recreating the last function in the haskell language as the first problem suggests http://lpaste.net/144542 
15:29:53 * hackagebot ciphersaber2 0.1.0.0 - Implementation of CipherSaber2 RC4 cryptography.  https://hackage.haskell.org/package/ciphersaber2-0.1.0.0 (BartonMassey)
15:31:04 <sfdebug> i'm a programmer that use imperative languages like php, javascript, C etc... e never coded in a functional language... i would like to learn a new language and so i thought about to learn some language with a "new paradigm"... does anyone here code in these languages i said or other non functional languages and see some thing good in learn haskell to improve programming in other languages?
15:33:15 <sm> sfdebug: yes
15:33:15 <bergey> Absolutely.  Many of the programming styles that are idiomatic in Haskell transfer well to other languages.
15:33:23 <Rembane> sfdebug: I think this guide is really nice: https://github.com/bitemyapp/learnhaskell
15:33:32 <sm> you'll notice this happening quite quickly
15:33:45 <wearenotdeadyet> sfdebug: learning to think a new way is never a bad thing
15:33:48 <cite-reader> sfdebug: Absolutely. I used to do PHP for a living; learning Haskell greatly improved the way I think about problems and how to construct programs. Similarly, learning OCaml's module language changed the way I think about objects in other languages.
15:34:03 <wearenotdeadyet> sfdebug: I'm just learning Haskell too :)
15:35:50 <sfdebug> wow, thanks dudes! i thought i wasn't received any response, but, the haskell comunity as i can see is very cool :)
15:36:36 <wearenotdeadyet> cite-reader: oooh, OCaml is purely module based?
15:36:52 <wearenotdeadyet> i.e. it does module injection?
15:37:09 <cite-reader> If you're talking about functors, yes.
15:37:42 <cite-reader> (Functors mean something different in MLs; they're modules parameterized by other modules.)
15:39:22 <wearenotdeadyet> cite-reader: that's what I meant
15:40:17 <cite-reader> Then yeah, it's a major feature. It's also what makes Mirage OS go, and I think that's one of the coolest projects out there right now.
15:40:24 <nerdsville> Haskell is so high level I have trouble wrapping my head around everything lol
15:43:24 <Welkin> nerdsville: you will get used to it
15:43:40 <Welkin> it's not high level enough really
15:44:14 <Welkin> what I see as the goal of programming is to have computers turn very high level natural language descriptions into programs
15:44:32 <nerdsville> yeah, I am definitely trying, I love the language and I can't explain why, but the problem with me is I want to understand everything and I get headaches trying to haha
15:44:59 <cite-reader> I'm pretty sure "let me talk to the compiler and it does what I meant" is AI-complete.
15:45:06 <Welkin> cite-reader: :)
15:45:24 <cite-reader> If we get there, then mission accomplished I guess.
15:45:43 <Welkin> we may need to use biological computers
15:45:58 <Cale> I dunno man
15:46:01 <Welkin> instead of von neumann silicon systems
15:46:31 <Cale> I think we tend to want things which are ultimately too specific to express entirely in natural language.
15:46:48 <Cale> At least, it becomes more cumbersome than using a better notation.
15:46:53 <Cale> Natural language kind of sucks.
15:47:02 <nerdsville> Generalizing problems seems to be very important in haskell
15:47:04 <Welkin> true, natural language is imprecise
15:47:06 <Lokathor> compiles that hang
15:47:07 <Lokathor> woo
15:47:13 <Welkin> math is much more precise
15:47:18 <nerdsville> yeah
15:47:24 <cite-reader> Have a computer program simulate a software developer, put us all out of a job.
15:47:28 <hpc> non-gmo organic language
15:47:46 <Welkin> cite-reader: in the future there will be no jobs
15:47:50 <Welkin> it is inevitable
15:47:51 <Cale> But yeah, we are figuring out what the cortex is doing
15:48:03 <nerdsville> That is even better, then we can program as a hobby entirely :D
15:48:04 <nerdsville> lol
15:48:35 <cite-reader> Well sure but it's at least partly a question of how much life sucks for people before that adjustment's been made, right?
15:49:23 <nerdsville> Sometimes running my own company and dealing with customers that don't understand the work I do is frustrating 
15:49:37 <nerdsville> Especially since I work along 99% of the time 
15:49:41 <nerdsville> alone
15:49:50 <Welkin> nerdsville: consulting?
15:49:54 <Lokathor> awh man, i guess i can't use -threaded to compile
15:50:26 <nerdsville> Welkin: kind of I suppose, I have an LLC, I basically do web hosting and development
15:50:31 <nerdsville> I don't really consult much
15:50:40 <nerdsville> I ask for requirements from the client
15:50:46 <Welkin> nerdsville: yes, being a developer-for-hire is painful
15:51:06 <nerdsville> It drives me crazy, I work 80 hours a week by myself
15:51:13 <nerdsville> Constant work but not much appreciation
15:51:16 <Welkin> nerdsville: did that, moved on :O!
15:51:25 <nerdsville> How though
15:51:36 <Welkin> nerdsville: let's take this to #haskell-blah
15:51:43 <nerdsville> ok one sec
15:59:27 * wearenotdeadyet *sighs*
15:59:37 <wearenotdeadyet> well I think I need to giveup on making this program go
16:00:15 <wearenotdeadyet> I was looking for a good example OpenGL program in haskell to learn/hack on, the one I picked seems to be too old/broken
16:00:24 <wearenotdeadyet> suggestions?
16:02:51 <mniip> how can I get a type-witness of a Nat being nonzero?
16:05:22 * hackagebot nullary 0.1.0.0 - A package for working with nullary type classes.  https://hackage.haskell.org/package/nullary-0.1.0.0 (DerekElkins)
16:09:15 <Eduard_Munteanu> mniip, often you can work with n + 1 instead of n
16:11:46 <mniip> Eduard_Munteanu, not in this case
16:14:38 <Eduard_Munteanu> mniip, well, you could use   data NonZero n where NonZero :: Sing n -> NonZero (n + 1)   then
16:15:53 * Eduard_Munteanu might not be uptodate on typelits
16:16:17 <emmanuel_erc> Does anyone here actually use yi?
16:17:45 <lpaste> mniip pasted “typelits” at http://lpaste.net/144544
16:17:49 <mniip> Eduard_Munteanu, consider this
16:18:35 <Eduard_Munteanu> mniip, ok
16:19:27 <mniip> Eduard_Munteanu, how would one generate such vectors
16:19:32 <mniip> for example
16:19:39 <mniip> pure :: e -> Vector n e
16:21:12 <Eduard_Munteanu> mniip, well, if you want it list-like, then you want   pure :: e -> Vector 1 e
16:23:28 <mniip> Eduard_Munteanu, of course not
16:23:33 <mniip> I mean quite literally
16:23:39 <mniip> pure :: e -> Vector n e
16:24:30 <mniip> there is an obvious solution to this
16:24:47 <Eduard_Munteanu> mniip, you could define it as repeat n, but I'm unsure that's still an applicative
16:24:57 <mniip> pure x = result where result = if isZeroLength result then N else x ::: pure x
16:25:08 <mniip> but
16:25:14 <mniip> that doesn't typecheck
16:26:04 <mniip> Eduard_Munteanu, uh, consider data Quad a = Quad a a a a
16:26:11 <mniip> does that make an applicative
16:27:13 <obadz> is there a way to write >>= purely in terms of return and join (but not fmap) ? if so, please don't tell me what way that is..
16:27:24 <mniip> obadz, yes
16:27:30 <obadz> mniip: thx :)
16:27:33 <mniip> oh, without fmap?
16:27:34 <Eduard_Munteanu> mniip, with ScopedTypeVariables, you could do   pure :: e -> Vector n e; pure = case n of { ... } where n :: Sing n; n = sing
16:27:35 <mniip> lemme see
16:27:41 <shachaf> There is not.
16:27:42 <obadz> mniip: yes without fma
16:27:43 <obadz> p
16:27:47 <nshepperd> mniip: pattern match on a singleton of that number?
16:27:53 <obadz> shachaf: thx
16:28:05 <obadz> I can be at peace now
16:28:32 <mniip> nshepperd, hmm?
16:28:44 <mniip> where do I find the singletons
16:28:53 <nshepperd> what Eduard_Munteanu said, pretty much
16:29:18 <mniip> yes, but
16:29:23 <mniip> *where* do I find the singletons
16:29:51 <nshepperd> oh, you are using typelits?
16:30:07 <mniip> yes
16:30:13 <zzing> Has anyone made a performant non-traditional database in haskell?
16:30:41 <obadz> zzing: what's a non traditional database?
16:31:39 <zzing> obadz, anything done before or after RDBMS' rise to prominence. 
16:31:50 <zzing> Sorry I should have said non-relational.
16:32:31 <nshepperd> hmm, looks like there aren't peano singletons built in
16:32:51 <nshepperd> might have to create them unsafely
16:33:27 <obadz> ild one :)
16:33:28 <mniip> nnnnoooooo
16:33:31 <obadz> zzing: I don't know of one but I'd love to have a simple AP replicated key-value store with some indexing and an auditable transaction log if you're going to build one :)
16:33:39 <mniip> unsafecoercing gadts D:
16:34:04 <zzing> obadz, my needs are kind of 'graphy' but could be done with a column store.
16:34:37 <nshepperd> well actually you can maybe use sameNat to prove that it is the right singleton
16:34:44 <mniip> no
16:34:45 <nshepperd> when creating it
16:34:57 <mniip> you can use sameNat to figure out type equality
16:35:02 <mniip> doesn't help with type inequality
16:35:12 <zzing> I had considered the idea of using a triple store, but my relations need some extra data, and a lot of queries would be projections best done on partitioned data.
16:35:14 <mniip> hmm
16:35:21 <mniip> I have an idea for a package now
16:35:42 <mniip> a collection of witnesses and singletons for typelits, making typelits finally not useless
16:35:47 <nshepperd> yes, I mean you can use it instead of unsafeCoerce
16:36:42 <nshepperd> maybe
16:40:55 <Eduard_Munteanu> mniip, nshepperd, how about...  data ToPeano n where Z :: ToPeano 0; S :: ToPeano n -> ToPeano (n + 1)   ?
16:41:14 <mniip> right
16:41:31 <mniip> but then you need a typeclass to generate this singleton
16:41:41 <mniip> er rather
16:41:42 <mniip> witness
16:43:14 <c_wraith> A type family is sufficient to convert a type lit to a piano natural 
16:44:06 <mniip> c_wraith, I'd like to hear more about it
16:44:06 <Eduard_Munteanu> What about   toPeano :: Sing n -> ToPeano n; toPeano (SingNat 0) = Z; toPeano (SingNat _) = S (toPeano sing)
16:44:12 <c_wraith> .. A type level peano natural, that is. 
16:44:18 <mniip> yes
16:44:23 <mniip> but that's not the thing we're looking for
16:44:38 <mniip> we're demoting types into type-indexed values
16:44:50 <Eduard_Munteanu> Wait, nevermind, that can't work for arbitrary n.
16:45:15 <c_wraith> Are you strongly against using KnownNat? 
16:45:23 <mniip> c_wraith, how does it help exactly
16:45:45 * hackagebot SDL-mixer 0.6.2.0 - Binding to libSDL_mixer  https://hackage.haskell.org/package/SDL-mixer-0.6.2.0 (fffaaa)
16:45:52 <c_wraith> I'm just looking for constraints. 
16:47:58 <Cale> A piano natural would be Nat King Cole.
16:48:03 <mniip> Eduard_Munteanu, besides peano I'm also thinking of n-ary representations
16:48:43 <mniip> data Binary n where One :: Binary 1; X2 :: Binary n -> Binary (2 * n); X2P1 :: Binary n -> Binary (2 * n + 1)
16:49:07 <mniip> hmm
16:49:12 <mniip> this needs Finite singletons
16:49:37 <Eduard_Munteanu> LOL, Cale 
16:50:59 <Eduard_Munteanu> @remember Cale A piano natural would be Nat King Cole.
16:50:59 <lambdabot> I will never forget.
16:52:32 <orion> I want to have a function which, in its definition, says something like "let foo = ... :: Foo a b c", but none of the arguments, nor the return result depend on a, b, or c. Is this possible?
16:53:08 <Eduard_Munteanu> orion, yes
16:54:11 <Eduard_Munteanu> orion, data Trivial a = Trivial; trivial :: Trivial a; trivial = Trivial
16:54:17 <mniip> @let moo x = let foo = undefined :: Either l r in x
16:54:19 <lambdabot>  Defined.
16:54:20 <mniip> :t moo
16:54:21 <lambdabot> t -> t
16:54:26 <mniip> did I understand your request correctly
16:55:21 <MarcelineVQ> Is that useful?
16:58:23 <lpaste> nshepperd pasted “SNat” at http://lpaste.net/144547
16:58:44 <nshepperd> seems possible
16:59:27 <nshepperd> but I used unsafeCoerce there because I'm not really sure how to... existentialise 'go'
16:59:37 <nshepperd> or whatever to make it sameNattable
17:01:21 <zzing> Is it possible to estimate how much memory certain structures would take up? For example, if I had something like data Type = Type Int   or even Type a b  where you know what a and b are. Further, when you put them in something like a Vector, list or Seq?
17:02:05 <shachaf> It is possible.
17:02:19 <cite-reader> You can get a good estimate. There's a chapter in Parallel and Concurrent Programming in Haskell with details.
17:02:24 <shachaf> I saw some slides once that had reasonable heuristics.
17:02:58 <cite-reader> I think that's where I saw it anyway.
17:03:02 <zzing> How good is that book? I notice it is from 2013.
17:03:24 <cite-reader> Pretty excellent. Things don't change _that_ fast.
17:07:53 <cite-reader> Hm. My memory seems to be faulty; I found the bit where Simon talks about how thunks are arranged abstractly, but I don't see the "this part takes a word, that part takes another word" that I thought I remembered.
17:08:06 <cite-reader> Might have been a kmett blog.
17:08:12 <shachaf> I remember slides in a Stanford class.
17:08:18 <shachaf> http://cs240h.stanford.edu/
17:08:21 <shachaf> Seems to be gone, though.
17:10:38 <synergistics> What's the difference between lifting and decorating a function generally. Are they comparabe? 
17:10:54 <synergistics> comparable*
17:11:21 <shachaf> Those are your words. You tell us.
17:15:07 <synergistics> Well I know that decorating is like giving a function a specific use case, making a general function work into a specific context. Lifting seems to be similar. 
17:17:05 <synergistics> shachaf: And these are definite concepts, not my words. 
17:17:40 <shachaf> You're the first person to say "decorating a function" in here.
17:17:54 <cite-reader> I haven't seen "decorating" used for a function, I think ever. Data structures, sure.
17:18:45 <synergistics> Does "decorator function" make more sense? 
17:19:25 <shachaf> If you're reading a word in a context in which you don't understand it, you can ask about that context.
17:19:46 <shachaf> No use in asking about a word in itself.
17:20:37 <zzing> synergistics, do you have a code example of these things you ask about?
17:21:44 <zzing> Could this person be referring to https://wiki.haskell.org/Function_decoration_pattern
17:23:25 <lamefun> Haskell feels kind of unpolished to me so far...
17:23:35 <rcyr> Compared to?
17:23:48 <cite-reader> Oh boy. /me retreats into flame-proof bunker
17:24:21 <kadoban> cite-reader: #haskell doesn't really care, we're pretty flame-less here.
17:24:55 <lamefun> Well, IDK...
17:26:08 <zzing> lamefun, do you have any specific concerns?
17:26:30 <lamefun> This, for instance: https://www.reddit.com/r/haskell/comments/3rdceq/monomorphism_restriction_error_message/cwnkyqp
17:27:25 <tabemann> the monomorphism restriction isn't exactly the best design, but it was put in to cover a case where otherwise Haskell would have very non-obvious and non-optimal performance
17:27:43 <tabemann> I think there's a way to turn off the monomorphism restriction these days, actualy
17:27:45 <tabemann> *actually
17:27:47 <lamefun> I don't have anything against it.
17:27:56 <kadoban> lamefun: It doesn't come up very often, and has a couple of pretty easy fixes thankfully. But yes it's not ideal.
17:29:15 <tabemann> umm just from looking at your examples
17:29:21 <tabemann> it is obvious why those don't compile
17:30:16 <tabemann> e.g. unless "exp" takes, say, Foo a => a -> Bool, and A, B, and C all have instances for Foo, there's no way it could work
17:30:41 <tabemann> remember, Haskell is strongly statically typed
17:30:47 <lamefun> they have
17:30:57 <nshepperd> I have literally never had a problem that NoMonomorphismRestriction would have solved
17:31:27 <tabemann> you don't even have to think about the monomorphism restriction as long as you specify types for all your top-level definitions
17:31:44 <nshepperd> because, if I'm using a polymorphic temporary definition, I write down its type for clarity
17:33:43 <nshepperd> which happens pretty rarely anyway
17:34:52 <isovector> evening. I'm trying to get a Lens r r [r] [r] without the constraint (Monoid r)
17:34:52 <lamefun> tabemann, A B C all have instances of Foo, but obvious "refactoring" I posted in my comment will make the code fail to compile: http://lpaste.net/6545906759016382464
17:35:21 <isovector> from what I understand, the Monoid constraint is for doing traversals over the list, but I've got a guaranteed use case of only ever using one
17:35:56 <isovector> Lens [r] [r] r r, sorry
17:36:21 <lamefun> fail to compile with an unintelligible error message
17:38:29 <kadoban> lamefun: In case you don't already know, the usual way to fix monomorphism restriction errors is to give an explicit type signature to whatever.
17:41:57 <tabemann> type signatures might as well be mandatory for top-level definitions in Haskell
17:42:30 <tabemann> I didn't know the monomorphism restriction applied to name-bindings in where clauses though
17:48:28 <M-davidar> ugh, i hate the monomorphism restriction
17:48:38 <M-davidar> especially when it gets applied to functions
18:05:50 * hackagebot messagepack 0.5.1 - Serialize instance for Message Pack Object  https://hackage.haskell.org/package/messagepack-0.5.1 (rodrigosetti)
18:14:16 <bb010g> Woo! Over 1500 people are here!
18:15:16 <lethjakman-l> When does a let not need an "in"?
18:15:39 <lethjakman-l> bb010g: that's all well and good...but it's not over 9000. 
18:17:09 <bb010g> lethjakman-l: I'm pretty sure it always does, even inline.
18:18:05 <lethjakman-l> bb010g: https://gist.github.com/lethjakman/e60ea8540596b30fd694
18:18:12 <lethjakman-l> This is the example I'm looking at. 
18:18:20 <lethjakman-l> I keep seeing things like this, and it's a bit confusing. 
18:18:34 <bb010g> Just a sec, checking the Report.
18:18:43 <lethjakman-l> Report?
18:21:31 <bb010g> lethjakman-l: Normal let expressions require `in` (https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-440003.12), `let` in do expressions declare pure values (https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14).
18:21:42 <bb010g> Haskell Report.
18:21:42 <lethjakman-l> Also, another issue I'm having. How does record wildcards work with the return value? Does it just populate it with all of the fields that have been declared in the monad or something? 
18:22:06 <bb010g> MWE?
18:22:25 <lethjakman-l> MWE?
18:22:36 <lethjakman-l> ahhhhh, the do would make more sense. 
18:23:00 <bb010g> Minimum Working Example
18:24:30 <lethjakman-l> bb010g: https://gist.github.com/lethjakman/69281b8bf077ed322539
18:25:31 <lethjakman-l> bb010g: So, the worker.hs should work. I also added the person one, because that's the one I'm actually trying to understand, but I haven't been able to get it to work for some reason. 
18:28:21 <bb010g> worker.hs does work?
18:30:47 <bb010g> lethjakman-l: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#record-wildcards
18:30:52 * hackagebot messagepack-rpc 0.5.1 - Message Pack RPC over TCP  https://hackage.haskell.org/package/messagepack-rpc-0.5.1 (rodrigosetti)
18:31:16 <bb010g> > The expansion is purely syntactic, so the record wildcard expression refers to the nearest enclosing variables that are spelled the same as the omitted field names.
18:31:17 <lambdabot>  <hint>:1:34: parse error on input ‘,’
18:37:13 <dzhus> Can I tell stack *not* to build an executable in of the extra-deps packages?
18:37:46 <sfdebug> hi, i'm trying to define a function on GHCi with something like sum x y = x + y, but when i do this, i received this message: "<interactive>:24:9: parse error on input `='", does anyone has any idea what be?
18:37:49 <dzhus> here's the error I get when I add concurrent-dns-cache to my stack.yaml in extra-deps: http://dpaste.com/3H4S21T
18:39:20 <lethjakman-l> bb010g: Oh...
18:39:24 <lethjakman-l> I must have missed that part. 
18:39:28 <lethjakman-l> THank you. 
18:41:27 <mniip> sfdebug, use 'let sum x y = ...'
18:41:47 <sfdebug> mniip, thanks dude! :)
19:01:26 <lethjakman-l> Is there an easy pretty way to escape strings in haskell?
19:01:38 <lethjakman-l> I have a string that will have a lot of double quotes
19:02:57 <anohigisavay> hi
19:03:47 <anohigisavay> i have a src/Game.hs file to unittest. i put my tests in testsuite/Tests/Game.hs
19:04:14 <anohigisavay> how can i import things from the src/Game.hs?
19:05:00 <anohigisavay> the entrypoint is testsuite/RunTests.hs
19:05:13 <kadoban> anohigisavay: What's in your .cabal file?
19:06:46 <anohigisavay> kadoban: http://lpaste.net/144551
19:06:57 <bb010g> lethjakman-l: http://hackage.haskell.org/package/raw-strings-qq
19:07:51 <mgsloan> dzhus: That's strange that you're getting that error, concurrent-dns-cache seems to have a pretty ordinary cabal file.
19:08:53 <kadoban> anohigisavay: You should have a 'library' section that exposes the Game module, or whatever you want. Then the test-suite should depend on the library, and then you can import it.
19:09:05 <lethjakman-l> bb010g: ohhh. I saw this in yesod!
19:09:11 <lethjakman-l> bb010g: thank you for all of your help. 
19:09:29 <mgsloan> dzhus: You cannot currently disable building executables for extra-deps
19:09:46 <mgsloan> Please open an issue about it if you need that
19:11:20 <kadoban> Does anyone know the correct invocation of stack to get it working with ghcjs projects? I see in the v0.1.6.0 release notes that '"stack setup" now supports building and booting GHCJS from source tarball', but I seem to be missing … how to get it to do that. And does that mean it'll work with ghcjs projects now, or … is that just a first step, or?
19:11:30 <kadoban> I see a bunch of stuff in the issues about progress, but it's hard to tell what's what.
19:12:25 <mgsloan> kadoban: Does this clear things up? https://github.com/commercialhaskell/stack/wiki/Stack-&-GHCJS
19:12:32 <bb010g> lethjakman-l: No problem. Remember, search is always your friend. I just searched for "haskell raw strings" on that last one. :)
19:13:16 <kadoban> mgsloan: Sweet, looks like what I was looking for. Thanks!
19:13:17 <lethjakman-l> bb010g: ahh, I didn't do raw search. I was looking for stuff more to the effect of "haskell escape strings many quotes"
19:14:16 <anohigisavay> kadoban: that did it. thanks :)
19:15:10 <bb010g> lethjakman-l: Ahh. Yeah, raw strings are a relatively common concept, for those times when you just want to type (almost) anything and just let it be.
19:15:37 <anohigisavay> kadoban: but doesn't it look strange to add the package itself to build-depends for the testsuite?
19:15:55 <sleblanc> Is there a common pattern that I am reinventing here? [((a -> Bool), b)] -> a -> Maybe b, that is, a function that takes a list of predicates+values, a value to dispatch to the predicate, and the value b if the predicate is True?
19:15:56 <kadoban> anohigisavay: Kinda, but it's really common.
19:16:42 <kadoban> Cool, ghcjs seems to be building *fingers crossed*
19:16:47 <sleblanc> In practice, "a" is a String
19:19:11 <kadoban> sleblanc: So you have potentially many (a -> Bool, b) pairs, but only zero or one output 'b's. How does it pick? The first one, if there is one?
19:19:32 <sleblanc> kadoban, yeah, first predicate match is good enough
19:20:51 <sleblanc> kadoban, I could use a map with computed values, but I like the flexibility of using predicate functions
19:21:41 <kadoban> sleblanc: I don't know that it's really a common pattern exactly, but …
19:21:45 <kadoban> :t \xs a -> lookup True . map (first ($ a)) $ xs
19:21:46 <lambdabot> [(a -> Bool, b)] -> a -> Maybe b
19:21:49 <kadoban> That, I guess?
19:23:54 <lethjakman-l> kadoban: Just out of curiosity, did you look into elm or purescript when you picked ghcjs?
19:24:23 <kadoban> lethjakman-l: Not really. I'm more interested in trying to reuse code I already wrote in a JS context, if it works well.
19:24:31 <lethjakman-l> Ahhh ok. 
19:24:49 <lethjakman-l> Very cool :) I was just curious because I've been playing with elm and purescript recently. 
19:25:20 <kadoban> I don't really know much about either, but they both sound fairly interesting from what little I've heard.
19:25:34 <kadoban> Though I kind of suspect that elm will annoy me because it's missing stuff haskell has.
19:25:56 <lethjakman-l> kadoban: I've felt the same way. I like how well it promotes frp for the web though. 
19:26:00 <lethjakman-l> I can see it having its uses. 
19:30:59 <tabemann> opinion question
19:31:34 <sleblanc> kadoban, it worked! I wonder what `first` does, though
19:31:37 <tabemann> in my IRC client I'm integrating a plugin facility, to allow runtime patching of the IRC client
19:32:05 <tabemann> should I allow the user to specify an entry point to plugins at the time they are patched, or should I just have one entry point that is saved somewhere in a configuration file?
19:36:44 <mgsloan> anohigisavay: If you think that's strange, consider that test-suites can be depend on libraries that depend on the library defined in the same package
19:38:07 <sleblanc> tabemann, your thing made me thought of an IRCMonad, how powerful would that be!
19:38:22 <sleblanc> (analogy to XMonad)
19:40:57 <tabemann> it's different from XMonad, though, because I'm doing runtime plugins rather than a startup-time recompilation
19:41:41 <tabemann> so one doesn't need to shut down one's IRC client if one wants to add more functionality to it
19:41:56 <sleblanc> tabemann, unless you manage to bootstrap the current state
19:42:29 <kadoban> sleblanc: It applies a function to the first element in a Bifunctor, if that helps. http://haddock.stackage.org/lts-3.12/base-4.8.1.0/Data-Bifunctor.html
19:42:29 <sleblanc> XMonad does it: when you recompile+restart it, the placement of windows is still remembered
19:42:54 <tabemann> sleblanc: the problem here is that I maintain connections with IRC servers
19:43:09 <tabemann> the connections would be lost if I had to restart the client
19:43:29 <sleblanc> tabemann, it might be tricky, but I am pretty sure that forking allows you to "transfer" open sockets to the child application
19:43:51 <sleblanc> tabemann, you would have to encode much of the state of the connection though, to be able to pick up from it
19:44:10 <tabemann> one way or another, it's simpler this way
19:44:15 <pavonia> tabemann: How do you switch to the new code while the program is running?
19:44:36 <sleblanc> I dunno, hot-swapping code sounds dangerous (and fun)
19:44:48 <tabemann> pavonia: System.Plugins.Make and System.Eval.Haskell
19:44:57 <thoughtpolice> You can use the 'dyne' library to do this in the same manner XMonad does it, which should work just as well for X connections as it does for any other socket.
19:45:18 <tabemann> the only catch is that for this to work, the client has to be compiled with some *interesting* command line options
19:45:38 <tabemann> but I've got a proof-of-concept already written and tested for the plugin functionality
19:46:31 <tabemann> sleblanc: actually I figured out how to make hot-swapping of code type-safe
19:46:34 <vektorweg1> an object with a bit higher density than water can still swim on water, when the electrical attraction of object material and water is lower than the attraction of water to water. right?
19:46:56 <tabemann> there's System.Plugins.Load, but that isn't type-safe
19:47:24 <sleblanc> vektorweg1, wrong channel, maybe?
19:47:50 <sleblanc> vektorweg1, I am not a physics buff, but I'd say that surface tension contributes a lot to this phenomenon
19:47:51 <tabemann> but by using System.Eval.Haskell, I can make it so that the plugin will fail to load with a type error if the plugin's entry point has the wrong type rather than potentially crashing as with System.Plugins.Load
19:48:01 <vektorweg1> sleblanc: well, no one answered in #physics, so i ask somewhere else. :p
19:48:24 <sleblanc> vektorweg1, for instance, a leaf will float on water until you push on it, then it sinks
19:49:06 <tabemann> anyways
19:49:15 <sleblanc> tabemann, that's interesting stuff, did it take long to figure out?
19:50:00 <vektorweg1> sleblanc: yep. electrical attraction is the reason for surface tension. i'm pretty sure about it, but i wish someone could just say that the statement is fairly true.
19:50:10 <tabemann> it didn't take that long, the hardest part was figuring out the GHC options necessary to get it all to work
19:50:19 <tabemann> which are *not* documented in Hackage
19:50:59 <sleblanc> vektorweg1, you could ask around on physics.stackexchange.com
19:51:32 <tabemann> anyways, if I do things the XMonad way, I can't support multiple simultaneous plugins without tearing them *all* down to install/change any of them
19:51:58 <tabemann> and I'll need to figure out some way to serialize the *entire* client state, even if I can transfer connections to the child process
19:52:08 <tabemann> well
19:52:32 <tabemann> this way there won't really be a way to turn off a plugin except if the plugin has a programmed-in facility to allow being torn down
19:52:52 <tabemann> but there will be a way of adding more plugins without needing to tear down the preexisting ones
19:53:56 <sleblanc> tabemann, you could enforce a means for plugins to have serializable/recoverable state, and use message passing as the means to interact between plugin and core, allowing you to distribute plugins as dynamic libraries; just an idea
19:56:43 <tabemann> the thing is that I intend to make it relatively easy for people to write scripts, and requiring them to write a whole facility for serialization/deserialization would be a pain
19:59:37 <codebje> tabemann, https://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson-TH.html ?
20:00:07 <codebje> https://hackage.haskell.org/package/binary-derive ?
20:00:28 <codebje> (binary-derive seems dead)
20:00:47 <codebje> ah, folded into binary
20:00:57 <tabemann> codebje:?
20:02:06 <codebje> tabemann, auto-derivation of serialisation
20:02:12 <tabemann> that's not the problem
20:02:27 <tabemann> the problem is that there's state all over the place, and systems of interconnections between servers
20:03:17 <tabemann> turning state into bits is the easy part
20:06:54 <codebje> can you reduce the size of the state that needs to be passed around?
20:07:24 <codebje> do plugins need access to sockets directly, or can they communicate via the main code?
20:08:06 <tabemann> the plugins would usually connect to a server which acts as an intermediary between everything else and the corresponding connection server, which in turn talks to the socket
20:08:25 <codebje> so plugins here are separate processes?
20:08:39 <codebje> (ala the original CGI interface)
20:08:49 <tabemann> the plugins might talk instead to another layer which acts to abstract away channels and users, which in turn talk to the connection intermediary layer which talks to the connection layer
20:09:14 <tabemann> no, these are all thread operating in the same memory space, communicating with STM and message-passing layered on top of STM
20:09:25 <codebje> righto
20:09:48 <tabemann> likewise the plugins will likely talk to a layer that abstracts away communication with the user, which in turn talks to the actual UI implementation
20:10:13 <tabemann> and will likely talk to a layer that acts to dispatch user commands to different components of the system
20:11:02 <tabemann> and all these layers have their own state
20:11:35 <tabemann> so serialization and deserialization is not merely turning a data structure into bits and then turning the bits back into a data structure
20:12:38 <codebje> to make sure I have the right context here, you're writing an IRC client which supports plugins?
20:12:38 <tabemann> it is a matter of messaging to all these layers to turn their state into bits, somehow encoding the interconnections between them all, and then again taking this bits, and using them to start all these layers back up again, recreating all their interconnections
20:12:44 <tabemann> yes
20:12:57 <codebje> those layers are your core code, which shouldn't need to restart, right?
20:13:13 <tabemann> codebje: I would have to restart them if I did things as in XMonad
20:13:24 <codebje> can you try to define the plugin API such that the plugins can expose pure functions?
20:13:47 <codebje> eg, "given server message X, give me an IRCAction response"
20:14:01 <codebje> or are you expecting to make plugins which can get down to a much lower level?
20:14:12 <tabemann> plugins can interact with all parts of the system
20:14:29 <tabemann> with some exceptions, like e.g. they cannot directly send data on sockets
20:14:39 * mniip is yet to find a perfect language for writing irc bots
20:14:50 <codebje> so it's not state you want to expose to all plugins, so much as functionality?
20:14:57 <tabemann> yes
20:16:00 <tabemann> the only reason why I was talking about state is if i did things the XMonad way, because then if i wanted to add a plugin I would have to shut down and start up again all the other plugins
20:16:14 <codebje> (I don't know how XMonad works :-)
20:18:07 <tabemann> well how XMonad works is that when you change your Haskell code, you have to restart XMonad because it literally recompiles XMonad to do so, but XMonad remembers its state over restarts
20:18:28 <codebje> yeah, not really what you want
20:18:41 <tabemann> whereas what I am working on is based on dynamic compilation and loading of plugin code
20:19:09 <mniip> tabemann, abandon this idea before you follow my footsteps o-o
20:19:20 <sleblanc> codebje, some more background: XMonad is configured with a ".hs" file that the xmonad binary knows how to compile. When you ask XMonad to restart, it will serialize its state and pass it along to the next instance
20:19:50 <codebje> sleblanc, the first time I heard about XMonad, it was as a "tiny Haskell program with an enormous Haskell configuration file" :-)
20:20:01 <tabemann> mniip: why?
20:20:18 <mniip> tabemann, the GHC dynamic compilation API is scary
20:20:32 <tabemann> mniip: I already have a working proof of concept for that
20:20:32 <sleblanc> mniip, does it eat babies for breakfast?
20:20:35 <mniip> type/value reconstruction especially so
20:21:14 <mniip> tabemann, how many times are you evaluating dummy statements
20:21:48 <tabemann> ?
20:22:08 <mniip> pastebin your proof of concept?
20:26:30 <lpaste> tabemann pasted “EvalTest” at http://lpaste.net/144552
20:28:55 <mniip> yes that's right
20:28:59 <mniip> evaluating dummy statements
20:29:05 <mniip> something I tried to avoid
20:29:36 <tabemann> the problem is that it's much easier to be type-safe that way than with using System.Plugins.Load
20:30:24 <tabemann> because with System.Eval.Haskell, if the plugin does not conform to the required type, it just outputs a type error
20:30:35 <tabemann> with System.Plugins.Load, if outputs garbage and/or crashes
20:34:21 <pavonia> mniip: What is a dummy statement in that code?
20:34:52 <tabemann> TestLoad.testLoad :: Int -> Int
20:35:57 * hackagebot concurrent-output 1.4.0 - Ungarble output from several threads  https://hackage.haskell.org/package/concurrent-output-1.4.0 (JoeyHess)
20:36:25 <pavonia> tabemann: I don't understand. Isn't this the dynamically loaded function?
20:37:04 <tabemann> this is an expression that evaluates to the dynamically loaded function
20:37:22 <tabemann> the purpose of it is to force the dynamically loaded function to have the specified type
20:40:27 <pavonia> tabemann: But isn't testLoad the function eval_ returns?
20:41:25 <tabemann> pavonia: yes
20:41:46 <tabemann> the problem is that eval_ can't enforce the type of what it returns
20:42:19 <HoloIRCUser> I love feet.
20:42:22 <tabemann> so we need to create an expression that specifically enforces that type, so if the type is incorrect the evaluated expression won't even compile
22:14:55 <lf94> OK lets start some 1am conversation
22:15:27 <lf94> Someone explain something super useful, but really abstract
22:16:45 <shalom> I had a question about an error I was facing -- could someone tell me what I am doing wrong in this esqueleto statement? http://lpaste.net/144555
22:27:41 <jle`> shalom: do you have the code too?
22:28:24 <shalom> http://lpaste.net/144556
22:32:56 <Gurkenglas> shalom, what is E.? Can you paste your whole .hs file?
22:33:10 <shalom> one sec
22:33:35 <shalom> here you go
22:33:36 <shalom> http://lpaste.net/144556
23:05:57 <SK0> Is there a way to go from any Fractional/Num to say, a Double?
23:06:01 * hackagebot htaglib 0.1.1 - Bindings to TagLib, audio meta-data library  https://hackage.haskell.org/package/htaglib-0.1.1 (mrkkrp)
23:06:48 <pavonia> :t realToFrac
23:06:50 <lambdabot> (Fractional b, Real a) => a -> b
23:07:15 <SK0> :S cheers
23:07:42 <pavonia> That's the opposite direction, though
23:08:09 <SK0> yeah, noticed
23:32:46 <l0p3n> Hello haskellers! I have a function that is supposed to add parenthesis to sin/cos expressions. The problem is that it doesn't work. I was wondering if someone could give me some hints on how to solve it. Here's the code for it http://lpaste.net/144558 Thanks in advnace!
23:35:50 <liste> l0p3n shouldn't line 20 end (convert' as (n-1))? I figured `n' is the current parenthesis depth
23:36:02 * hackagebot versions 1.0.0 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-1.0.0 (fosskers)
23:36:54 <liste> that doesn't solve the problem though
23:39:18 <shiona> I'm trying to learn haskell GUI programming and chose FRP and reactive-banana-wx as the platform. I would like to have a function that returns an individually functioning widget that I can just plug in to the main frame. Is it possible and if, is there any example code?
23:42:00 <l0p3n> liste: That's correct it's the recursion depth. I'll try what you suggested...
23:42:10 <l0p3n> *parenthesis depth
23:43:27 <wearenotdeadyet> haskell gui programming is a thing?
23:45:38 <wearenotdeadyet> I should think that...given how stateful gui programming is...and how anti-state (besides the Monad) haskell is...the very fact that all haskell gui programming is done in C++ would be a major tip off that its not a thing...
23:47:38 <wearenotdeadyet> i.e. the major OO languages all have native gui toolkits (qt, wx, gtk, tk, delphi, swing), but the functional ones dont....
23:48:32 <wearenotdeadyet> shiona: nevertheless if you can figure out how to express a gui as a set of mathematical equations, that would interesting to see :)
23:49:12 <shiona> wearenotdeadyet: https://wiki.haskell.org/Reactive-banana "FRP offers an elegant and concise way to express interactive programs such as graphical user interfaces, animations, computer music or robot controllers. In particular, it promises to avoid the spaghetti code that is all too common in traditional approaches to GUI programming."
23:50:11 <wearenotdeadyet> shiona: ok, but that doesn't quite count - you're using WX, and a library binding for that
23:50:18 <wearenotdeadyet> so its just C++
23:50:28 <wearenotdeadyet> analagous to Javascript + HTML or something
23:50:55 <Hijiri> doesn't count as what, GUI programming?
23:51:22 <wearenotdeadyet> Hijiri: its not native code...
23:52:07 <wearenotdeadyet> The best Haskell can ever be in such a situation is just a scripting language.
23:52:27 <Hijiri> I wasn't asking the question rhetorically
23:52:36 <cizra> I'm not sure this is true, but I wish it were: Haskell would be a better C++ due to type safety.
23:52:58 <Hijiri> Haskell doesn't have the same level of control over low-level details
23:53:20 <Hijiri> Rust might be closer to "better C++ due to type safety (and memory safety and other things)"
23:53:23 <wearenotdeadyet> Hiriji: express widgets and their properties as haskell functions (which actually create and maintain those widgets) and I'd say that it is 'gui programming'
23:53:35 <wearenotdeadyet> Hijiri: at best, like I said, its just scripting
23:53:59 <Hijiri> I think you are defining these terms a bit weirdly
23:54:02 <wearenotdeadyet> languages like Javascript are capable of things like this
23:54:10 <Hijiri> I would say "gui programming" is "programming GUIs"
23:54:45 <wearenotdeadyet> Hijiri: eh...not really. You can build user interfaces but that's different to wanting to learn to build guis...
23:54:48 <MarcelineVQ> I don't understand. Doesn't wx rely on lower level libraries to interact with the OS windowing/input as well
23:55:18 <Hijiri> isn't building GUIs programming GUIs?
23:55:26 <Hijiri> or do you mean writing a GUI framework or something?
23:55:29 <MarcelineVQ> At what level does one stop 'counting'
23:55:53 <Hijiri> asm
23:56:52 <wearenotdeadyet> Hijiri: no - you can write a gui in nothing but JS and Canvas (see gtk re-implemented in Javascript) - you can construct the actual widgets, and subclass them etc...I don't think you can do anything similar in Haskell - you have to still build your user interface separate to your application, and then merely all your haskell program does is interface with that? Am I incorrect?
23:57:00 <kadoban> wearenotdeadyet: So building user interfaces that are graphical is different from building GUIs? O.o
23:57:06 <jasabella> hi
23:57:56 <kadoban> wearenotdeadyet: You could do that in JS, but nobody does. They use the DOM traditionally.
23:58:14 <Hijiri> wearenotdeadyet: Does using external libraries count as building it separate to your application?
23:58:16 <wearenotdeadyet> kadoban: actually, they do - see jQuery et. all
23:58:35 <kadoban> wearenotdeadyet: jquery mostly functions on the DOM
23:58:44 <Hijiri> Do you mean constructing a GUI library? Or just using one?
23:58:52 <wearenotdeadyet> kadoban: sure, but they compose widgets
23:58:59 <wearenotdeadyet> using nothing but JS and DOM
23:59:05 <wearenotdeadyet> is that possible with haskell?
23:59:15 <wearenotdeadyet> I think you probably have to use some sort of gui builder
23:59:19 <MarcelineVQ> None of these comparisons make any sense :(
23:59:22 <kadoban> wearenotdeadyet: … the DOM is not haskell, it's using an underlying thing that's implemented outside of JS.
23:59:31 <kadoban> s/is not haskell/is not JS/
23:59:54 <Hijiri> If javascript and canvas counts, then surely compiling haskell to canvas-using javascript code using GHCJS would count
