00:00:43 <jle`> mhm np.  the monadic version is the same...bindRand is abstracted as (>>=), returnRand is abstracted as return...there's also some syntactic sugar for do notation that i'm not sure if elm has or not
00:02:36 <ggVGc> no, Elm is pretty primitive in the monads/syntactic sugar department. But I find that's actually quite nice because it forces me to really understand the concepts of haskell
00:02:36 <jle`> Lokathor: there's a Monad instance defined for ((->) Person), though
00:02:54 <ggVGc> I've only written a little bit of haskell before, but I'm learning more about it by using a less powerful version
00:02:57 <jle`> i'm pretty sure it's in Prelude
00:03:06 <jle`> lambdabot has it at least
00:03:23 <jle`> > (do { x <- (+2); y <- (*4); return (x + y) }) 10
00:03:25 <lambdabot>  52
00:04:28 <Lokathor> huh
00:04:30 <Lokathor> well alright then
00:04:48 <jle`> it's basically Reader w/o the newtype wrapper
00:05:04 <Lokathor> so the Monad ((->) r) instance applies even though Reader is a newtype?
00:06:13 <jle`> well Reader never has anything to do with it
00:06:18 <jle`> Reader isn't even mentioned in the definition
00:06:30 <jle`> there's just an instance in base
00:06:31 <Lokathor> oh, hmm, true
00:07:00 <jle`> instance Monad ((->) r) where return = const; bind f g x = g (f x) x
00:07:10 <jle`> er, s/bind/(>>=)
00:07:30 <jle`> and voila you have a monad instance you can use
00:07:39 * hackagebot foscam-filename 0.0.4 - Foscam File format  https://hackage.haskell.org/package/foscam-filename-0.0.4 (TonyMorris)
00:07:39 * hackagebot foscam-directory 0.0.4 - Foscam File format  https://hackage.haskell.org/package/foscam-directory-0.0.4 (TonyMorris)
00:21:42 <Lokathor> bind f g x = g (f x) x    f >>= g x = g (f x) x     f >>= g = (g . f)  ?
00:21:45 <Lokathor> that looks correct
00:21:57 <Lokathor> wait no
00:22:02 <Lokathor> one too few x
00:24:08 <Maxdamantus> The second one can be fixed with some parentheses.
00:24:15 <FireFly> Hmm, g (f x) x huh. Interesting
00:24:18 <Maxdamantus> The third one needs join.
00:24:49 <jle`> :t \f g x -> g (f x) x
00:24:51 <lambdabot> (r2 -> r1) -> (r1 -> r2 -> r) -> r2 -> r
00:25:00 <jle`> looks like the right type signature to me?
00:25:38 <jle`> (f >>= g) x = g (f x) x
00:26:21 <jle`> but it's definitely not (g . f)
00:27:04 <Lokathor> right
00:27:28 <Lokathor> trying to do Monad for Reader
00:27:32 <Lokathor> having a bit of a roadblock
00:27:42 <Lokathor> the outline given is     (Reader ra) >>= aRb = Reader $ \r -> 
00:28:17 <jle`> does typed holes help?
00:28:22 <mauke> what are the types of all the variables?
00:28:42 <Maxdamantus> :t let f >>+ g = join (g . f) in (>>+) `asTypeOf` (>>=)
00:28:43 <lambdabot> (a1 -> b) -> (b -> a1 -> a) -> a1 -> a
00:28:48 <Lokathor> mauke, (>>=) :: Reader r a -> (a -> Reader r b) -> Reader r b, pretty much what you expect for bind
00:29:04 <mauke> Lokathor: not >>=
00:29:12 <mauke> that's a method you're implementing, so the type is fixed
00:29:21 <Lokathor> which variables did you mean then?
00:29:22 <jle`> Maxdamantus: yeah, it makse sense because (f >>= g) = join (fmap g f) = join (g . f)
00:29:27 <mauke> Lokathor: ra, aRb, r
00:29:53 <Lokathor> oh, sorry, newtype Reader r a = Reader { runReader :: r -> a }
00:29:58 <mauke> ???
00:30:11 <mauke> I don't see how that's going to help you
00:30:12 <Lokathor> so ra :: r -> a, aRb :: a -> Reader r b,
00:30:17 <mauke> ah
00:30:45 <Lokathor> Maxdamantus, while I trust that you are correct, I think that's not the intended answer
00:31:17 <jle`> Lokathor: have you tried playing around with typed holes? i think a situation like this would be a good poster child for their usefulness
01:13:41 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
01:13:41 --- topic: set by quicksilver!~jules@roobarb.crazydogs.org on [Wed Oct 07 07:39:49 2015]
01:14:05 <frerich> So I kind of like the TypeScript/Flow approach, I think you get a long of 'bang for the buck'.
01:14:31 <danza> it is still very different, in comparison with working with Haskell
01:15:03 <danza> i think that nowadays, most people are trying to invest in GHCJS in order to make developing with Javascript less miserable
01:15:34 <frerich> I think there's a tendency to consider JavaScript the assembly language of browsers.
01:15:42 <frerich> I'm not in that camp though. :-)
01:15:59 <tdammers> one important advantage of the Flow approach IMO is the ability to gradually transition
01:16:03 <tdammers> both projects and developers
01:16:26 <tdammers> a seasoned JS developer will have little trouble adapting to flow, but in order to be productive with ghcjs, you have to learn Haskell
01:16:47 <danza> i see "have to learn Haskell" as an advantage, not a drawback
01:17:25 <frerich> Maybe if you're willing (or permitted) to work on a project yourself or if you can freely choose your peers :-}
01:18:12 <danza> every good software architecture should allow integration of smaller projects, where you are free to use whichever technology you like more
01:18:20 <danza> different tools for different tasks
01:18:22 <hc> speaking of javascript; i noticed, javascript's callbacks are not so unlike monads in a way... you call a function and must process the result in yet another function, from which you call another function and so forth...
01:18:50 <ReinH> promises can be given a monad interface in a language that can make sense of such a thing
01:18:55 <ReinH> as in, not javascript
01:19:00 <danza> yeah besides that being untyped, you can get an elephant where you were expecting a mouse
01:19:16 <hc> yeah, sure :)
01:19:33 <hc> i just mean the principle of having to unwrap something inside a fucntion and never get it out of that function 
01:20:10 <danza> people say that Javascript is "functional" ... this is kind of true, but making sense of runtime errors when you use higher-order functions in untyped Javascript is ... not fun
01:20:14 <hc> i know that theoretically, you could in js by using global variables or referencing a list that was created outside, but ...
01:20:32 <hc> i'm not saying i prefer javascript over haskell ;)
01:21:09 <danza> hc that is called continuation-passing style in other (lisp) languages
01:21:17 <tdammers> "is functional" requires context
01:21:18 <danza> which is affine to monads, yes
01:21:32 <jle`> javascript is "functional", but functional has a wide variety of meanings and manifestations
01:21:41 <tdammers> by the most lenient definition, even C is functional
01:21:55 <hc> C is functional unless your compiler is broken, in which case it is non-functional *g*
01:22:02 <tdammers> and by the most strict ones, even Haskell might not qualify
01:22:29 <jle`> but sometimes i divide "functional languages" into two broad categories...lispy functional (which derives power from metaprogramming) and smly functional (power from type system)
01:22:37 * hackagebot stack-hpc-coveralls 0.0.1.0 - Initial project template from stack  https://hackage.haskell.org/package/stack-hpc-coveralls-0.0.1.0 (rubik)
01:22:43 <danza> tdammers, where is Haskell "not functional"?
01:23:20 <tdammers> danza: bottoms, mainly
01:23:27 <danza> ah, i see
01:23:36 <tdammers> danza: the argument being that partial functions aren't functions
01:23:42 <jle`> under a strict definition haskell definitely doesn't qualify because it's specifically non-strict
01:24:17 <Hafydd> Is there an example of a language that doesn't have bottom (i.e. non-termination)?
01:24:17 <danza> tdammers, can you do a simple example?
01:24:31 * frerich heard that the JavaScript author(s) were actually Lisp persons but then a manager told them to use a C'ish syntax for marketing reasons. Maybe the same manager which then proceeded to vote for 'JavaScript' instead of ECMAScript.
01:24:35 <tdammers> Hafydd: I don't think there's a practical one, except maybe for non-TC languages
01:24:53 <tdammers> danza: `head` is a textbook one
01:24:54 <jle`> i heard that agda's type system disallowed general recursion in a way that would get rid of most bottoms?
01:24:55 <tdammers> :t head
01:24:56 <lambdabot> [a] -> a
01:25:09 <tdammers> > head []
01:25:11 <lambdabot>  *Exception: Prelude.head: empty list
01:25:23 <danza> the problem here is the function being partial
01:25:31 <tdammers> yes
01:25:50 <tdammers> and this particular example is easy to fix, but a generic totality checker is really really hard
01:25:57 <jle`> yes, and some people don't include partial functions in their definition of what a function is
01:26:02 <danza> hum
01:26:05 <danza> makes sense
01:26:06 <jle`> generic totality checker = impossible?
01:26:12 <tdammers> jle`: you mean, mathematicians?
01:26:22 <danza> there is a totality checker in ghc, i think
01:26:30 <tdammers> also, yes, AFAIK a generic totality checker is impossible, unless you impose certain restrictions on your language
01:26:54 <tdammers> (a 100% fool proof one, that is)
01:27:00 <jle`> if you could analyze a program without executing it and tell me in finite time whether or not it would be total
01:27:06 <jle`> then
01:27:09 <jle`> you've broken tcs
01:27:44 <jle`> (a program in a sufficiently powerful language like haskell, at least)
01:28:05 <tdammers> I have a hunch that turing completeness has something to do with it ;)
01:29:00 <jle`> hault me if i'm wrong
01:29:39 <jle`> *halt
01:29:55 <danza> seems that you can enable some kind of totality check in ghc with -Wall https://blogs.janestreet.com/what-do-haskellers-have-against-exhaustiveness/#comment-132
01:30:44 <tdammers> yes, but it won't catch everything
01:31:11 <danza> a partial function will have a partial pattern match, right?
01:31:26 <Freundlich> Totality is more difficult than the halting problem (which is undecidable). Even if you could solve the halting problem you still couldn't solve the totality problem. Intuitively, you would have to answer the halting problem "an infinite number of times".
01:31:50 <jle`> danza: what about a function like `reverse`, which isn't defined for [1..] ?
01:32:07 <jle`> danza: reverse has exhaustive pattern matches still
01:32:08 <Freundlich> There might be a shortcut to testing all of these individually, but there isn't.
01:32:30 <danza> Freundlich, i see
01:32:46 <danza> jle`, i don't know, that case seems different to me
01:32:55 <danza> that function is total, it is just not terminating
01:33:13 <jle`> what is reverse [1..], then?
01:33:17 <jle`> is it defined?
01:33:25 <danza> not terminating
01:33:48 <jle`> from a denotative perspective
01:33:54 <dibblego> fsvo reverse
01:34:02 <danza> might be defined if infinite is a valid symbol
01:34:11 <danza> might be defined if infinite is a value
01:34:17 <jle`> okay, so what is the definition if 'infinite is a value'?
01:34:39 <Freundlich> danza: If you do that you pretty much destroy the denotational model.
01:34:49 <danza> oh, Infinity is a value in Haskell
01:35:01 <jle`> there isn't any sensible answer to what reverse [1..] should be, denotatively
01:35:10 <dibblego> > let go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []; reversel xs = go xs (reverse xs) in length . take 3 . reversel . reversel
01:35:11 <liste> > Infinity
01:35:12 <lambdabot>      No instance for (Typeable a0)
01:35:12 <lambdabot>        arising from a use of ‘show_M559348086101561918728803’
01:35:12 <lambdabot>      In the expression:
01:35:13 <lambdabot>      Not in scope: data constructor ‘Infinity’
01:35:13 <lambdabot>      Perhaps you meant variable ‘infinity’ (imported from Data.Number.Natural)
01:35:21 <danza> > 1/0
01:35:24 <lambdabot>  Infinity
01:35:37 <jle`> so how would having (1/0) be a value help you define what reverse [1..] should be?
01:35:48 <dibblego> > let go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []; reversel xs = go xs (reverse xs) in length . take 3 . reversel . reversel $ [1..]
01:35:50 <lambdabot>  3
01:35:59 <jle`> :p
01:36:19 <liste> isn't Infinity theoretically an infinite number of values?
01:36:20 <danza> > take 3 . reverse . reverse [1..]
01:36:22 <lambdabot>      Couldn't match expected type ‘a -> [a1]’
01:36:22 <lambdabot>                  with actual type ‘[Integer]’
01:36:22 <lambdabot>      Possible cause: ‘reverse’ is applied to too many arguments
01:36:38 <danza> > take 3 . reverse . reverse $ [1..]
01:36:43 <liste> > (1/0) == (2/0)
01:36:43 <lambdabot>  mueval-core: Time limit exceeded
01:36:48 <lambdabot>  mueval-core: Time limit exceeded
01:36:58 <liste> or is that just NaN
01:37:09 <jle`> if you consider "[1..]" to represent the infinite list/sequence of integers starting from 1, and 'reverse' to be a function that takes a list and returns the reverse, `reverse [1..]` is effectively undefined
01:37:49 <jle`> so reverse is not total; it's partial
01:37:50 <dibblego> the above function meets that definition and the answer is defined
01:38:02 <danza> dibblego, what is `reversel`?
01:38:03 <Freundlich> If the denotation of reverse wasn't partial, then the denotation would be wrong.
01:38:14 <dibblego> danza: it reverses a list, including infinite ones
01:38:15 <danza> ah okay saw that
01:38:21 <danza> wow
01:38:40 <Freundlich> Wrong in a sense of that there would be denotations for cases where the operational semantics are undefined.
01:38:56 <Freundlich> We could make the denotation of everything total, but we don't want to.
01:40:22 <danza> Freundlich, isn't the case of `reverse` different from a missing case in a pattern match?
01:40:42 <danza> like in `head`?
01:40:53 <Freundlich> They are undefined for "different reasons" but they are both "the same" undefined.
01:41:11 <danza> hum ... one is an exception, the other is not terminating
01:41:24 <jle`> danza: likewise, what is `last [1..]`?  last [1..10] is defined, last [1..100] is defined.  but last [1..], is that defined?
01:41:29 <danza> i have the feeling that it would be easier to statically detect the exception
01:41:33 <jle`> (for unbounded integers)
01:41:59 <jle`> you might be able to statically detect some partial functions as being partial
01:42:06 <jle`> but you can't detect all of them in general
01:42:20 <frerich> dibblego: Isn't using 'length' there kind of cheating? 'take 3 . reversel . reversel $ [1..]' does not terminate for me at least.
01:42:37 <jle`> danza: `last` here isn't a function in the traditional sense of the word function, because it's undefined for a bunch of possible inputs
01:42:53 <dibblego> frerich: not sure why it is cheating
01:43:14 <dibblego> take 3 will evaluate the spine
01:43:26 <danza> jle`, interesting, thanks :)
01:44:01 <danza> so i guess that a language getting this right would be more pedantic
01:44:15 <frerich> dibblego: A reverse function which only gives me the list in reverse but won't let me figure out what those elements are doesn't seem very useful. :-}
01:44:23 <danza> you would have Maybe as a result of head and last
01:44:36 <Freundlich> danza: The reverse also means that you can detect some total functions as being total but you will always miss some.
01:44:40 <ben> but then what would the result type of fromJust be :(
01:44:44 <dibblego> frerich: it is useful to demonstrate that one can reverse an infinite list
01:45:03 <jle`> danza: even if `last` returned Maybe, it'll still be undefined for `last [1..]`
01:45:23 <danza> true ...
01:45:30 <jle`> at least, depending on how it's defined
01:46:27 <Freundlich> We do similar things with type systems: You can't statically detect if a type error will occur at runtime.
01:46:31 <frerich> dibblego: I guess I had a different idea of what it means to reverse a list. I thought that it implies that you can actually do something with the head of the resulting (reversed) list. Not a very precise description, I guess. :-]
01:47:06 <dibblego> reverse [1,2,let f = f in f]
01:47:19 <dibblego> what are you going to do with that head?
01:47:22 <Freundlich> So in order to ensure type safety at runtime we have to also forbid programs that don't have type runtime type errors in them.
01:49:02 <danza> Freundlich, that is very interesting ... anyway i will leave that topic for another day ... value level is already difficult to grasp :)
01:49:04 <danza> so do other languages manage to be "more functional" because of their strict semantics, which enable easier totality checking? you can't have an infinite list with strict evaluation, right?
01:50:25 <jle`> whoa whoa hold on.  adding laziness increases the amount of total functions, not decreases
01:51:03 <jle`> going from non-strict to strict decreases* totality          *or has the same amount of
01:51:51 <Freundlich> It might still be true that it's easier to check.
01:51:53 <jle`> functions like `const 1`, which used to be total, is no longer total in a strict language
01:52:03 <frerich> dibblego: Not much, of course. I think I'm out of my league here, I feel a bit weak on the terminology. :-} My gut feeling (ahem) was that not being able to evaluate the head of a list is because it's value is undefined is something different han not being able to evaluate the head of a list because you never actually get the head of a list (which is what my idea of reversing an infinite list is/was). :-}
01:52:27 <jle`> Freundlich: ah yeah, i missed the point of the sentiment entirely
01:52:33 <jle`> sorry all
01:53:27 <danza> tdammers started the conversation saying that Haskell is "non functional" in some sense, and somebody mentioned strictness, and then we started talking about totality
01:53:48 <danza> this is why i am linking laziness an partial functions, as the examples had infinite lists
01:53:54 <danza> but maybe i am wrong
01:54:52 <Freundlich> jle` is right that strictness forces more cases to be undefined.
01:55:07 <indigo945> exactly, I can do, say, let a = last [1,2..] just fine
01:55:11 <Freundlich> Which essentially says that f(undefined) = undefined
01:55:15 <indigo945> I just shouldn't evaluate it
01:55:52 <danza> Freundlich, ?
01:55:57 * frerich wonders why his laptop got so warm only to realize that he had some 'reverse infinite list' experiment running in a different terminal :-)
01:56:04 <danza> :D
01:56:04 <jle`> haha
01:56:38 <Freundlich> danza: A function f is called strict if f(undefined) = undefined. If you force every function to be strict, you get "more undefined". That's what a non-lazy does.
01:56:52 <Freundlich> *non-lazy language
01:57:11 <danza> how do you write `f(undefined)` in Haskell?
01:57:11 <ben> \_ -> undefined is strict?
01:57:45 <mniip> it is
01:57:57 <mniip> danza, literally 'f undefined'
01:58:30 <danza> > undefined
01:58:32 <lambdabot>  *Exception: Prelude.undefined
01:58:57 <danza> > id undefined
01:58:59 <lambdabot>  *Exception: Prelude.undefined
02:01:03 <danza> `id undefined` returns undefined, so it is strict in the definition you gave, Freundlich 
02:01:16 <Freundlich> Yes.
02:01:26 <danza> but ... being an Haskell function, it should be lazy
02:02:28 <radon27> indigo945: if a = last [1,2..]  Is there anything that I can actually do with a?
02:02:51 <indigo945> radon27: everything you want, actually, as long as you don't force it
02:03:08 <indigo945> i.e. yes you can, but it is of no use whatsoever
02:03:32 <danza> > take 10 $ [1,2..] -- radon27 
02:03:33 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
02:03:34 <Freundlich> danza: It is lazy. If you don't evaluate (id undefined) you don't get undefined. You can embed the expression into something else.
02:04:03 <jle`> radon27: const 1 a = 1, for instance
02:04:08 <Freundlich> danza: Laziness gives you the ability to write non-strict functions if you "don't use the argument" in some cases.
02:04:33 <ben> but i don't use the argument in \_ -> undefined and you're saying it's strict :((
02:05:00 <frerich> danza: Indeed 'id x = x' is strict. Just like 'succ x = x + 1'.
02:05:15 <danza> i think that the problem is that Haskell can't tell that the result is `undefined` before evaluating?
02:05:18 <indigo945> > const 5 $ last [1,2..]
02:05:19 <Freundlich> ben: Yes, the "use the argument" analogy falls apart in this special case.
02:05:20 <lambdabot>  5
02:05:26 <indigo945> heh.
02:06:58 <indigo945> reading the yampa source code is fun
02:07:04 <danza> alright ... i am quite confused ... i think that i should study the topic of bottoms, totality and lazy evaluation at some points. thanks you all for the nice conversation! :)
02:07:10 <indigo945> most of the comments are just "!!! Untested optimization !!!"
02:07:19 <danza> ugh
02:07:54 <ben> danza: good luck getting to the bottom of it!
02:07:59 <danza> :D
02:08:07 <danza> learning never terminates!
02:08:40 <Freundlich> danza: The thing is that some terms come from "mathematical functions", while others come from "program evaluation".
02:09:37 <Freundlich> Strictness is a property of functions while laziness is a property of program evaluation. How they relate to each other can be pretty tricky.
02:09:52 <danza> uh?
02:10:04 <Freundlich> I mean, if you want to know all the details...
02:10:23 <danza> i thought that strictness and laziness where the opposite of each other ...
02:10:53 <Freundlich> I think it's a good start to differentiate things at this very high level.
02:11:01 <Freundlich> No, you can't really compare these two things directly.
02:11:33 <danza> is there a "program evaluation" strictness, different from the "property of functions" strictness?
02:12:58 <Freundlich> Non lazy evaluation always makes every function you implement strict.
02:14:38 <mauke[o}> > (map sum . iterate (liftA2 (zipWith (+)) (0 :) ((++ [0]) . zipWith (*) [1 ..]))) [1]
02:14:41 <lambdabot>  [1,2,5,15,52,203,877,4140,21147,115975,678570,4213597,27644437,190899322,138...
02:14:46 <mauke[o}> @oeis 1 2 5 15 52
02:14:50 <lambdabot>  Bell or exponential numbers: number of ways to partition a set of n labeled ...
02:15:05 <quicksilver> it doesn't help that people do not use the words consistently
02:15:14 <quicksilver> you will see people use lazy to mean the oppposite of strict
02:15:29 <danza> yes ... usually i always read ... strict versus lazy
02:15:33 <quicksilver> but you will see other people (or the same people in a different circumstance) to contrast the difference between lazy and non-strict
02:16:32 <danza> alright, then let me formulate my original question again: would non-laziness enable better totality checking?
02:16:39 <quicksilver> no
02:16:46 <danza> :D okay
02:17:09 <quicksilver> the easy parts of totality checking are easy
02:17:16 <mniip> totality checking is undecidable in general
02:17:16 <quicksilver> and the hard parts are impossible 
02:17:30 <danza> cool :)
02:17:42 <mniip> any language that has support for non-total computations is subject to halting problem
02:17:47 <tdammers> so I guess the art is to decide where to stop
02:18:03 <danza> so to wrap up, tdammers, it seems that Haskell could not be more "functional" than this :)
02:18:19 <tdammers> danza: not without sacrificing TC
02:19:00 <mniip> yeah
02:19:11 <mniip> turing completeness implies halting problem
02:19:46 <indigo945> and for that matter, even without turing completeness it's really hard to automatically prove totality
02:20:49 <immersion> Is there a common function that combines [Maybe a] into a single Maybe a using some combinator (a -> a -> a)? Here's the implementation I'm looking for: http://lpaste.net/145561
02:21:18 <mauke[o}> :t catMaybes
02:21:19 <lambdabot> [Maybe a] -> [a]
02:23:01 <mauke[o}> :t \xs -> case catMaybes xs of [] -> Nothing; x : xs -> Just (foldr f x xs)
02:23:02 <lambdabot> (Show a, FromExpr a) => [Maybe a] -> Maybe a
02:23:08 <mauke[o}> :t \f xs -> case catMaybes xs of [] -> Nothing; x : xs -> Just (foldr f x xs)
02:23:09 <lambdabot> (a -> a -> a) -> [Maybe a] -> Maybe a
02:23:16 <quicksilver> immersion: well you can first sequence them to give Maybe [a]
02:23:33 <mauke[o}> quicksilver: that will abort on Nothing
02:23:38 <quicksilver> oh
02:23:43 <immersion> Right, I want to keep Justs
02:23:58 <quicksilver> ah yes mauke[o} is on the right track
02:24:15 <quicksilver> I'll just observe that if you can define (a -> a -> a) as the action of a Monoid on a
02:24:19 <quicksilver> then what you want is mconcat
02:24:49 <immersion> mauke[o}: Thanks, that's a better alternative
02:25:28 <immersion> quicksilver: I thought of that as well, but I would rather not introduce a new Monoid instance
02:25:37 <mauke[o}> :t mconcat :: (Monoid a) => [Maybe a] -> Maybe a
02:25:40 <lambdabot> Monoid a => [Maybe a] -> Maybe a
02:25:56 <MarcelineVQ> also msum I think
02:26:44 <indigo945> :t (join . headMay . filter isJust)
02:26:46 <lambdabot> Not in scope: ‘headMay’
02:26:50 <indigo945> meh, it's in Safe
02:27:03 <mniip> :t \f -> fmap (uncurry $ foldr f) . uncons . catMaybes
02:27:04 <lambdabot> (a -> a -> a) -> [Maybe a] -> Maybe a
02:27:46 <mniip> :t (. uncons . catMaybes) . fmap . uncurry . foldr
02:27:48 <lambdabot> (b -> b -> b) -> [Maybe b] -> Maybe b
02:28:08 <Komanda> i love the shit out of darcs; but i have webdesigners/frontend developers on my team that have osx and need a gui 
02:29:48 <zomg> as a front end developer I find your comment offensive!
02:30:03 <indigo945> what's so nice about darcs? anything that makes it much better than hg?
02:30:06 <zomg> I joke, but yeah, some frontend devs love their little GUIs =)
02:30:26 <Komanda> when gui's are well designed they are great
02:30:54 <Komanda> indigo945: https://en.wikibooks.org/wiki/Understanding_Darcs/Patch_theory
02:31:02 <Komanda> darcs theory of patches is brilliant
02:31:56 <Komanda> gonna test th  git<> darcs bridge; so they perhaps can use git + gitgui and then automatically export<>import from darcs; native gui would be better though cuz i'm not sure if this will  work reliably 
02:32:04 <zomg> tbh any dev worth their salt should be capable of using the terminal at least after telling them the basic commands :)
02:32:45 <zomg> I mean much of the modern frontend stuff is already using terminal (ie. a variety of nodejs based tools and npm)
02:34:26 <quicksilver> immersion: well, it depends if you think the monoid instance is interesting independently. There is always this kind of trick:
02:34:29 <quicksilver> >  fmap getSum . mconcat . (fmap.fmap$Sum) $ [Just 1, Just 2, Nothing, Just 3]
02:34:31 <lambdabot>  Just 6
02:35:15 <immersion> Yeah something like that would work
02:35:24 <quicksilver> although if what you really have is a semigroup then you have 'Option',
02:35:26 <indigo945> meh, darcs appear to employ a lot of effort on a non-issue
02:35:32 <mniip> hmm
02:35:32 <mniip> is there a free monoid datatype
02:35:42 <mniip> it would fit here perfectly
02:35:51 <indigo945> I guess it's nice maths and all, but I just want my tools to work, and since hg does anyway, that doesn't win me over
02:36:02 <quicksilver> hg, git, bzr and darcs all work.
02:36:29 <immersion> quicksilver: Do you have any links to Option? I can't seem to find it.
02:36:29 <quicksilver> the biggest *practical* reason to choose between the four is tooling and experience I think.
02:36:42 <immersion> Is Option just Maybe with a different Monoid instance?
02:37:05 <quicksilver> immersion: yes
02:37:15 <quicksilver> immersion: its Maybe with its monoid instance built off a semigroup
02:37:19 <quicksilver> not an monoid
02:37:30 <quicksilver> "Semigroup a => Monoid (Option a)"
02:37:38 <quicksilver> "Ideally, this type would not exist at all and we would just fix the Monoid instance of Maybe"
02:37:47 <Komanda> indigo945: https://www.youtube.com/watch?v=iOGmwA5yBn0
02:37:54 <Komanda> you don't get it
02:37:59 <Komanda> watch that video 
02:39:40 <immersion> quicksilver: Gotcha. I don't even need associativity, so I think a Magma would work just fine.
02:40:21 <quicksilver> in practice nothing complains if your semigroup or monoid isn't really associative
02:40:30 <quicksilver> you just get nondeterministic results from foldMap
02:40:55 <immersion> I basically have Maybe Constraint; data Constraint = Conjunction Type Type | ...
02:42:16 <indigo945> Komanda: oh, I see, that's actually really nice -- "automatic branching" essentially
03:00:27 <saulzar__> Does anyone know how to run a criterion benchmark such that the setup environment is run from scratch each time? It seems that it creates one environment for many runs 
03:01:19 <saulzar__> I need to somehow benchmark by re-creating the environment each run (rather than re-use it several times)
03:12:34 <lyxia> saulzar__: Does that mean the creation of the environment should be part of the benchmark?
03:13:45 <saulzar__> lyxia, I want to exclude the setup costs from timing
03:14:19 <saulzar__> lyxia, But I'm using mutable state, so I can't use the same environment twice ..
03:14:34 <lyxia> hmmm
03:14:38 <lyxia> tricky
03:14:59 <saulzar__> I think I'm going to have to dig in and modify the code, seems like a thing lots of people would need though.
03:15:40 <saulzar__> Perhaps not, given it's Haskell - pure testing doesn't necessarily need such a thing.
03:17:29 <lyxia> What about benchmarking the whole system setup+computation and then benchmark the setup phase and take the different?
03:17:32 <lyxia> ce
03:17:54 <saulzar__> Hmm
03:18:20 <jophish> wouldn't it be nice if fixities had a partial orderin
03:19:16 <mauke[o}> doesn't perl6 do that?
03:19:32 <saulzar__> I guess that works, though it feels unsatisfying :)
03:19:47 <lyxia> saulzar__: Or break the setup phase in two
03:20:21 <lyxia> saulzar__: The first half does the expensive operation (reading big files, preprocessing, whatever) and puts the result in some pure record
03:20:36 <frankier> Hey everyone, I'm trying to deserialise a header using the binary packages's Get monad. My in first attempt I used the do notation, but it seemed there might be a more DRY way using the monad composition operators. The code is here: http://lpaste.net/145563 - the problem with my attempt is I need to put a return into Header after all the arguments have been applied (if that makes any sense). Can anyone give me any hints about 
03:20:36 <frankier> which operators might allow me to write a version where the arguments to Header just "fall in place"?
03:20:54 <lyxia> saulzar__: the second half puts this record in whatever mutable references you need for the rest of the code, this shouldn't take long
03:20:56 <jophish> mauke[o}: ooh, nice
03:21:46 <lyxia> saulzar__: then wrap this second half and the rest of the computation in a single function "Record -> IO Result" which is what you will be benchmarking.
03:22:02 <mniip> frankier, Header <$> (fromIntegral <$> getWord16be) <*> (fromIntegral <$> getWord16be) <*> (fromIntegral <$> getWord16be)
03:22:45 <mauke[o}> getWord16beAsInt = fromIntegral <$> getWord16be
03:23:11 <mauke[o}> Header <$> getWord16beAsInt <*> getWord16beAsInt <*> getWord16beAsInt
03:23:14 <pi3r> Any recognized wisdom for how to name non-exported/private functions in Haskell ? 
03:23:18 <mniip> ^
03:23:46 <mauke[o}> also decide whether the last one should be Word16 or Word32
03:23:53 <mniip> pi3r, something you would understand in a month
03:24:52 <mauke[o}> frankier: your second version would need (return . Header) =<< ..., I think
03:25:52 <saulzar__> lyxia, Hm - that'd be nice, unfortunately my setup costs and creating the mutable references are all kind of tied together due to the way I've written my test framework. I'm generating a sequence of events to feed to a FRP framework, so there's no expensive operation as such... sometimes it still costs more than the actual benchmark 
03:26:12 <saulzar__> lyxia, If I chose a different way of testing/benchmarking I could sort things out..
03:26:16 <lyxia> pi3r: The same way you would do it if you were to export it
03:27:11 <lyxia> saulzar__: I see, that's unfortunate.
03:27:31 <frankier> mniip, mauke[o}, Very cool - just need to internalise those signature. Thanks.
03:28:35 <frankier> mauke[o}, That second one doesn't seem to work I think the return comes "too late" if you get my meaning, but the Applicative stuff seems to work fine
03:29:35 <saulzar__> lyxia, My benchmarks are tests (against a pure model), and vv. so it's quite handy, but the way the pure model works is it needs the event occurances up front and there can be a lot of them..
03:32:27 <saulzar__> I see why criterion operates this way, it runs repeated evaluations in order to make sure that the measurement cost doesn't dominate the execution cost
03:32:59 * hackagebot termplot 0.1.0.0 - Plot time series in your terminal using commands stdout  https://hackage.haskell.org/package/termplot-0.1.0.0 (jimenezrick)
03:33:16 <saulzar__> If there's a setup/teardown then it can't simply run 100 iterations between start/stop timer..
03:35:22 <saulzar__> Though, it could use your method lyxia using differences
03:51:50 <jophish> :( there doesn't seem to be a function for dividing an Integer by a power of two 
03:52:03 <lyxia> saulzar__: What would happen if you reuse the same environment? I mean if it doesn't crash perhaps you can still benchmark it on the assumption that it does the same kind of operation anyway.
03:52:40 <lyxia> jophish: Data.Bits?
03:53:12 * hackagebot hlint 1.9.23 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.23 (NeilMitchell)
03:53:18 <jophish> lyxia: yeah, that was the first place I looked, no dice though
03:53:58 <saulzar__> lyxia, For some things it's okay, for other stateful things it's kind of annoying. In fact for most things I can live with it. Think I'll do the differences approach. 
03:54:40 <lyxia> jophish: I mean, dividing by a power of two is a bit shift. Is that not what you are looking for?
03:54:43 <jophish> > (-1 :: Integer) `shiftR` 1 -- lyxia 
03:54:45 <lambdabot>  -1
03:54:53 <lyxia> ah
03:54:58 <jophish> yeah, it's a pain
03:55:20 <mauke[o}> why are you dividing negative integers?
03:55:48 <lyxia> jophish: but it's still the floor of the quotient
03:56:36 <quicksilver> what would like you -1 divded by 2 to be?
03:56:42 <jophish> mauke[o}: I'd like to truncate a rational where the denominator is a power of two
03:56:42 <quicksilver> 0?
03:56:45 <jophish> quicksilver: 0
03:57:27 <merijn> jophish: If youre working with rationals, why not use Ratio instead of bitshifting Integer?
03:57:59 <mauke[o}> > truncate (-0.5 :: Rational)
03:58:01 <lambdabot>  0
03:58:12 <lyxia> saulzar__: Ok. I was just saying whatever went through my mind. Good luck.
03:58:35 <saulzar__> lyxia, Cheers for talking it through with me :)
03:58:43 <jophish> merijn: I don't have a Ratio to hand in this code
04:00:54 <jophish> > (-1) `div` 2
04:00:57 <lambdabot>  -1
04:01:00 <jophish> ?
04:01:20 <jophish> that's very odd
04:03:23 <mauke[o}> > (-1) `quot` 2
04:03:25 <lambdabot>  0
04:03:46 <jophish> ah of course
04:03:48 <merijn> jophish: Why is that odd? What would you expect integer division to return?
04:03:55 <nshepperd> `div` rounds towards negative infinity, i think
04:04:22 <jophish> merijn: I suppose I assumed that div rounded towards zero
04:04:58 <merijn> jophish: One of those common confusions, the same with almost no one expecting round to use banker's rounding :p
04:05:45 <jophish> merijn: hmm, rounding biased towards evens seems sensible to me
04:05:57 <mauke[o}> > printf "%.0f %.0f" 1.5 2.5 :: String
04:05:59 <lambdabot>  "2 2"
04:06:51 <merijn> jophish: Sure, it's sensible when you THINK about it. It's even the default rounding specified by IEEE754
04:07:02 <guaraqe> hello! how would you proceed do extract the first n eigenvectors of a symmetric, non-sparse matrix? the problem is that it is 30000x30000 and hmatrix calculates all of them before giving just the ones I want
04:07:11 <merijn> jophish: But the average unthinking person expects "middle school 0.5 rounds up" rounding :)
04:11:25 <jacereda> Hi. Is it possible to use cabal to build an executable from C sources without wrapping it in a .hs?
04:12:18 <merijn> jacereda: I'm assuming you want something like a C main file that calls out to your haskell?
04:12:27 <jacereda> something like 'main-is: hello.c'
04:12:43 <merijn> jacereda: In fact, that works
04:12:49 <merijn> jacereda: See my minimal example here: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
04:13:03 <jacereda> merijn: cool, thanks
04:13:13 * hackagebot shellmate 0.2 - Simple interface for shell scripting in Haskell.  https://hackage.haskell.org/package/shellmate-0.2 (AntonEkblad)
04:15:47 <jacereda> merijn: hmmm, that still builds a haskell module... this is just a standalone executable that will be exec()d by another program, it is just that I want it to be easilly installable via stack
04:16:14 <merijn> jacereda: Might be easier/better to do that as a seperate hook?
04:16:32 <merijn> jacereda: You can have cabal call arbitrary code during the build
04:16:44 <merijn> Including just calling make/autotools to build your C executable
04:17:06 <apriori> guampa, https://en.wikipedia.org/wiki/Eigenvalue_algorithm#Iterative_algorithms .. I don't really recall which one I once used. but it gave you the EV in sorted orde, iteratively
04:17:13 <apriori> ops,
04:17:16 <apriori> I meant guaraqe 
04:18:57 <guaraqe> apriori: Ok, so the best is to code it myself? I was hoping to maybe have a solution out of the box, but it's ok :) Thanks!
04:19:11 <jacereda> merijn: and how can I do that? Via Setup.hs?
04:19:34 <apriori> guaraqe, frankly, I wouldn't know right now. guess you have to search hackage and github
04:20:06 <merijn> jacereda: Yeah, write a custom Setup.hs and add hooks, the cabal user guide is a good starting point for how to write hooks
04:20:22 <guaraqe> apriori: I found one that seems nice, called eigen, but that curiously has no eigenvector functionality
04:20:42 <jacereda> merijn: great, thanks
04:20:58 <apriori> guaraqe, I know eigen as a quite sophisticated C++ library (yes, and I rarely say that)
04:22:04 <guaraqe> apriori: yes, there are bindings for these, but it seems they are not complete, and I'm too much in a hurry to learn C++ on the fly, but it indeed seems nice
04:23:03 <apriori> guaraqe, that was by no means a recommendation for using c++ :P .. while you might benefit from popular libraries, you will shoot yourself in the foot amazingly fast, effectively killing your productivity bonus.
04:24:22 <guaraqe> apriori: haha, I avoid that as much as possible... I started with C in the university in fact, I just met haskell one year ago and finally started liking to program
04:24:45 <apriori> guaraqe, hehe, no big surprise here :)
04:24:56 <guaraqe> apriori: but I would like to know more if not to make bindings for fellow haskellers
04:25:39 <z16> C++ is very different from C though... although it still offers quite a few ways to shoot yourself in various appendages
04:25:47 <z16> But not nearly as much as C
04:26:00 <z16> C basically hands you a shotgun and a blindfold
04:26:18 <apriori> z16, and C++? a rocket launcher or a nuke?
04:26:24 <apriori> nah, just kidding
04:27:14 <z16> Also, I wouldn't call C++'s library infrastructure "good" just because it's "popular"
04:27:23 <apriori> z16, you got my point though
04:27:25 <z16> C++ has a lot of libraries of very varying degrees of quality
04:27:32 <z16> Yeah
04:27:36 <z16> Just agreeing with you even more
04:27:38 <apriori> some stuff you simply need to implement yourself in haskell, because it's simply not there
04:28:11 <apriori> on the other hand, the stuff that is usually there, is of much better quality (at least in my opinion)
04:28:13 * hackagebot cabal-helper 0.6.2.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.6.2.0 (DanielG)
04:28:31 <z16> Generally, yes
04:28:39 <guaraqe> for numerical analysis it is hard to not use binding to C, fortran, C++ stuff...
04:28:40 <jophish> I've found the library availability far better in haskell than in c++
04:28:40 <mauke[o}> "But not nearly as much as C" <- I am physically unable to comprehend thought processes like this
04:29:11 <apriori> mauke[o}, depends on perception bias applied :P
04:29:21 <z16> C++ has a few really amazing libraries, but they are few and far between (Eigen is pretty good, Spirit is awesome)
04:29:27 <merijn> mauke[o}: Well, I disagree that C++ is any safer than C, C++11/C++14 do remove the need to use many of the dangerous bits
04:29:30 <apriori> jophish, depends highly on your area of problems
04:29:31 <z16> But even Boost, which is popularly praised, contains 97.3% junk
04:29:38 <jophish> c++ might be safer in terms of the type system, but there are so many more ways to shoot oneself in terms of writing terrible code
04:29:44 <merijn> mauke[o}: So it's certainly possible to write modern C++ in a way that is much safer than writing modern C
04:30:07 <apriori> what did I start here :)
04:30:09 * mauke[o} relocates to #haskell-blah
04:30:22 <merijn> apriori: Group therapy :p
04:30:28 <apriori> haha
04:30:31 <mauke[o}> not to be confused with group theory
04:30:34 <z16> C++ is unsafe by default, but you can use a safe subset of it
04:30:42 <z16> The one that does not intersect with its C feature set
04:30:50 <apriori> mauke[o}, thank you, I just fell off my chair.
04:31:21 <z16> Haskell is safe by default... you have to try to actually hurt yourself or others
04:31:26 <z16> And you have to try really hard
04:31:34 <apriori> z16 -> #haskell-blah
04:31:54 <z16> Actually, z16 -> back to work
04:51:42 <aweinstock> :t Unsafe.Coerce.unsafeCoerce -- z16
04:51:43 <lambdabot> a -> b
04:52:05 <aweinstock> :t Foreign.Storable.Poke
04:52:06 <bernalex> is there a way for me to derive something in a different file to the type?
04:52:07 <lambdabot>     Not in scope: data constructor ‘Foreign.Storable.Poke’
04:52:09 <aweinstock> :t Foreign.Storable.poke
04:52:11 <lambdabot> Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> a -> IO ()
04:52:31 <aweinstock> :t Foreign.Ptr.plusPtr
04:52:31 <bernalex> my usecase: I have a tutorial datatype, and I want to check that the implementation is correct. so in Tests.hs I basically want to derive Functor and Foldable for the type that's defined in the Lesson.hs.
04:52:32 <lambdabot> GHC.Ptr.Ptr a -> Int -> GHC.Ptr.Ptr b
04:53:05 <mauke[o}> bernalex: 'deriving instance ...'
04:53:15 * hackagebot derive 2.5.23 - A program and library to derive instances for data types  https://hackage.haskell.org/package/derive-2.5.23 (NeilMitchell)
04:53:20 <aweinstock> {-# LANGUAGE StandaloneDeriving #-}
04:53:23 <bernalex> mauke[o}: sorry how does that work?
04:53:37 <mauke[o}> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/deriving.html#stand-alone-deriving
04:53:40 <bernalex> aweinstock: hmm I think I've used that before. I'll have to read the guide
04:56:09 <bernalex> will this work even when I have an instance in Lesson?
04:56:26 <mauke[o}> no
04:56:31 <bernalex> data Foo... instance Functor Foo where ... is already in Lesson, but I want to derive the correct one in Tests to check them against each other
04:56:48 <bernalex> I guess I could use a newtype CorrectFoo and derive Functor for that, or something
04:56:57 <mauke[o}> no, you can't
04:57:09 <bernalex> wat? why can't I?
04:57:12 <mauke[o}> deriving through a newtype just exposes the original instances
04:57:39 <bernalex> oh, ok a new adt and a conversion function then
04:57:48 <mauke[o}> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/deriving.html#newtype-deriving
04:57:54 <mauke[o}> yeah, you'd have to clone the type
05:13:25 <SrPx> Is there any database for Haskell which allows one to keep as close to the language as possible. Ideally it would just provide a clean solution for persistence, with reliability, performance, replicability etc., but allow the queries to be made on haskell itself.
05:14:12 <tdammers> SrPx: I think acid-state would fit that bill
05:14:25 <merijn> acid-state isn't replicable
05:14:30 <tdammers> right
05:14:42 <merijn> Also, I disagree that acid-state is a database
05:15:04 <merijn> But if you simply want to persist state and query it in haskell then acid-state is good
05:16:20 <tdammers> good points
05:16:38 <SrPx> Hmm nice to know, thanks :)
05:17:15 <tdammers> I'm kind of pondering a reactive-style persistence thing, sort of like an event database
05:17:15 <SrPx> No replicability is however a problem. I thought there would be some kind of mongo-like database, except for ADTs not JSON, and using Haskell not JavaScript?
05:17:19 <lonokhov> Haxl qustion:  if I have something like   traverse (fetchA >=> fetchB) [1,2,3,4], fill it batch 'fetchA' on all 1,2,3,4? As I understand it, it should.
05:17:46 <tdammers> I'd still want it language-agnostic, at least as far as the interface is concerned
05:18:22 <merijn> I still recommend SQLite as "default" database for people who need an actual database
05:19:16 <tsani> I've got a conduit Source that emits data at irregular times and I'd like to chunk the data by time interval with a Conduit. I can't figure out how to do that chunking however.
05:19:34 <tdammers> heh - my default choice is postgres
05:19:47 <merijn> tdammers: Requires setting up and adminning a server, though
05:19:58 <merijn> tdammers: And SQLite can handle most "normal" workloads just fine
05:20:14 <tdammers> yes, but the critical mass for postgres being the lesser hassle is really small
05:20:44 <tdammers> I mean, I have a postgres server running on every one of my dev environments anyway
05:20:51 <quicksilver> I recommend SQLite to people who are unlikely to respond well to haskell of setting up and maintaining a daemon
05:21:03 <quicksilver> but postgresql is just unambiguously better in every way
05:21:07 <quicksilver> haha
05:21:16 <quicksilver> s/haskell/the hassle/
05:21:29 <merijn> quicksilver: Not in the "now I have to setup a server first" way :p
05:21:32 <tdammers> sqlite is better if you need to ship a complete bundle with hassle-free installation requirements
05:22:23 <quicksilver> right.
05:22:27 <keko-2> https://hackage.haskell.org/package/esqueleto-2.4.1/docs/Database-Esqueleto.html
05:22:28 <tdammers> most of what I do is server-side web stuff though, so there's little benefit in that for me
05:23:50 <SrPx> Yea but ideally I'd like to remove the need of writing queries in a separate language (SQL). Maybe a functional interface to MongoDB? Generics could be used to encode ADTs to/from BSON. Your interaction with the DB could be limited to loading/storing the save data to memory. And lazy structures would mean you only actually read from disk by demand.
05:24:01 <SrPx> Something like that would be epic...
05:24:14 <merijn> Don't use MongoDB :(
05:24:25 <merijn> MongoDB is terrible engineering by incompetent people :\
05:24:35 <SrPx> It was just an example, when you have the interface it doesn't mean what database you use. merijn 
05:24:38 <ben> Would you also remove the step where the db engine goes and rewrites your query into an execution plan that is more involved than stepping through a ton of lists over and over?
05:24:57 <merijn> ben: That doesn't sound very webscale to me...
05:25:26 <quicksilver> SrPx: soundsl ike you're looking for acid-state
05:25:36 <SrPx> Like, "main = do { storedData <- loadAllDataFromWhateverDB; print $ sum (data^.foo.bar) }" <-- only touches `foo.bar`, the rest of the DB isn't read from disk due to laziness
05:25:44 <SrPx> quicksilver: okay maybe that's it
05:25:47 <quicksilver> that wouldn't be laziness
05:25:53 <quicksilver> that would be interleaved IO
05:26:05 <SrPx> quicksilver: what do you mean?
05:26:32 <quicksilver> laziness is when a pure function - which inherently has side-effects - is calculated only on demand
05:26:38 <quicksilver> on when parts of the result are demanded.
05:26:52 <quicksilver> If fetching from disk or network is being done on demand that is no longer a pure computation
05:27:00 <quicksilver> missing word 'no' there :P
05:27:05 * quicksilver types to fast, thinks too slow.
05:27:54 <quicksilver> the point about laziness is it is deterministic and preserves semantics
05:28:03 <SrPx> I know, but the point is laziness could be used to load the whole database at once, and only read the disk when the data is needed (by having something like `seq` except for disk-reading interleaved with the data, which is triggered at demand?)
05:28:04 <quicksilver> IO-on-demand is not deterministic
05:28:22 <quicksilver> absolutely. I don't dispute that what you ask is possible
05:28:24 <merijn> SrPx: The magic you want is called "mmap :)
05:28:30 <quicksilver> I'm just objecting to the word 'laziness' here
05:28:31 <SrPx> quicksilver: I know, I know.
05:28:47 <quicksilver> which is pedantic of me, but I personally think it's an important thing to be pedantic about.
05:28:56 <merijn> mmap lets you do exactly this, loading data and only reading from disk on demand, although most database also do this anyway
05:28:59 <SrPx> quicksilver: but laziness is necessary for that, no? Otherwise how would haskell know that I want specifically "foo.bar" when I write "dbData^.foo.bar"?
05:29:11 <merijn> mmap <3
05:29:15 <SrPx> I mean, without laziness, the line "dbData <- loadData" would load everything, not just a thunk. I don't know?
05:29:23 <quicksilver> no, it could just return a handle
05:29:27 <SrPx> merijn: thanks for the keyword
05:29:37 <quicksilver> and foo.bar could 'formulate a query'
05:29:45 <SrPx> quicksilver: but you would be able to treat it like an actual Haskell value?
05:29:49 <quicksilver> or a search path or a byte offset
05:29:53 <frerich> merijn: I think every operating system does that either way. When you launch e.g. a 300MB executable, you don't actually read 300MB from disk but the OS only pages in the parts you access.
05:30:01 <quicksilver> yes, but it wouldn't be ^. from lens
05:30:06 <quicksilver> it would be in some IO-bound monad
05:30:49 <merijn> frerich: Yes, executable are paged on demand
05:31:07 <merijn> frerich: But normally if you call read(2) it will read all that data from disk directly
05:31:22 <SrPx> quicksilver: but that is not what I want because you'd need every kind of special treatment for your data :( I want it to work exactly like a Haskell value.
05:31:33 <quicksilver> sure
05:31:44 <quicksilver> doing IO on demand masked behind a pure haskell value is a well-rehearsed trick
05:31:46 <SrPx> quicksilver: for example: "dbData <- loadData :: IO [Int]; print $ dbData !! 1000". On this case, the database data is just a list of int, and I want it to read only one of those values from DB. But I used "dbData" as if it was an usual haskell list.
05:31:47 <SrPx> Is that possible?
05:31:53 <quicksilver> I think it's a terrible idea
05:32:00 <quicksilver> but it's in the standard library and some people lovei t.
05:32:05 <SrPx> why? :(
05:32:05 <quicksilver> getContents.
05:32:35 <quicksilver> https://mail.haskell.org/pipermail/haskell-cafe/2007-March/023073.html
05:32:37 <frerich> merijn: Hm, not sure. I somehow thought it's much like malloc(), which lets you allocate gigabytes of memory (even more than you have available) and get away with it, because the memory is not committed
05:32:48 <frerich> merijn: Anyway, offtopic :)
05:32:50 <quicksilver> is a reference to "Why?" from a few years ago
05:32:57 <exio> SrPx: the problem with lazy io
05:33:20 <saulzar__> Lazy IO used to be a very popular idea until people realised it was actually very unsafe..
05:33:33 * hackagebot hoogle 4.2.43 - Haskell API Search  https://hackage.haskell.org/package/hoogle-4.2.43 (NeilMitchell)
05:33:34 <SrPx> It is ? :(
05:33:41 <saulzar__> e.g. you can't handle exceptions resulting from the IO proplerly, because they can happen _anywhere_
05:34:00 <exio> it is handy for a throwaway code though
05:34:08 <merijn> frerich: malloc overcommit is OS dependent
05:34:15 <exio> s/a t/t/
05:34:16 <merijn> frerich: Linux will always overcommit
05:34:33 <merijn> frerich: BSD generally only ever overcommits around 10-20% before returning NULL from malloc
05:34:57 <SrPx> Okay, I agree with that, but I also think if you are careful enough you shouldn't get an exception from IO at all...
05:35:11 <merijn> SrPx: That's not possible
05:35:24 <merijn> Hell, you can't even open a file without guaranteeing no exceptions :p
05:36:06 <nshepperd> what kind of monster would malloc gigabytes of memory then only use a small fraction of it? that's like lying to the pager
05:36:27 <SrPx> merijn: what if you keep a server that handles the file? Only a single process opens it and your IO is done by communicating to that server?
05:36:52 <SrPx> I.e. you don't even know that server is using a file or whatever it wants to store the data. It just has the responsibility of storing and serving it...
05:36:54 <merijn> nshepperd: malloc I'm not sure, but mmap? All the time :D
05:37:59 <SrPx> Actually that's what would happen, we're not talking about file IO, we're talking about IO from a DB server. It *should* guarantee that there is no exception. That's the point no?
05:38:34 * hackagebot cgrep 6.5.13 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.13 (NicolaBonelli)
05:38:36 * hackagebot free-concurrent 0.1.0.0 - Free monads suitable for concurrent computation  https://hackage.haskell.org/package/free-concurrent-0.1.0.0 (srijs)
05:39:00 <merijn> SrPx: Oh?
05:39:11 <nomeata> The Foldable ((,) a) instance just caused a lot of confusion here. I wonder if it was a good idea to include that one – or are there important use cases that I’m not aware of?
05:39:11 <merijn> SrPx: Whoops, connection lost/database server crashed. Now what?
05:39:38 <frerich> nshepperd: I think you answered the question yourself: it permits (and gives a plausible argument in favor of) writing bad software. :-]
05:40:40 <SrPx> Dunno just have a standard way to proceed... "data <- loadDBData exceptionHandler" ... 
05:41:48 <phadej>  /wg 25
05:41:51 <phadej> eh
05:41:54 <SrPx> If IO exceptions is the problem such a marvelous feature has, is it really a problem without solution?
05:42:02 <SrPx> The only problem *
05:43:19 <mauke[o}> the other problem is that file descriptors are a scarce resource
05:43:36 <mauke[o}> you probably want control over when they're closed
05:44:08 <SrPx> but I'm not talking about file, the IO is with a DB
05:44:25 <SrPx> the DB handles files (or not) the way it wants
05:44:47 <sbrg> SrPx: you still might want to close the handle to your database
05:44:51 <mauke[o}> all IO is done over file descriptors
05:45:17 * SrPx shrugs
05:45:20 <ben> can't you keep mmap'd regions around after the file goes away
05:45:20 <sbrg> SrPx: and re "You shouldn't get an exception from IO at all", .. you can't control that
05:45:45 <SrPx> okay I'll just accept this wonderful idea is bad because you told me so, but what is the next best idea after it?
05:45:59 <merijn> ben: No, FSOV no
05:46:28 <merijn> ben: You can remove the file, but, like deleting any other open file the file won't ACTUALLY be removed by the OS until the last file descriptor closes it
05:46:41 <ben> sorry, i meant the file descriptor goes away
05:47:00 <ben> p = mmap(... fd ...); close(fd); happily do io through p
05:47:06 <merijn> ben: That works
05:47:19 <merijn> ben: I know this, because my current code does exactly that
05:47:21 <ben> :D
05:48:31 <SrPx> How do *you* do it? Are you all writing SQL queries like a normal language would do?
05:48:48 <merijn> I just don't use databases :p
05:49:00 <mauke[o}> I don't use Haskell
05:49:37 <frankier> Is there a function with a type signature like (I checked Hoogle already) m b -> (m b -> Bool) -> m a -> m [a] which works like replicateM but will execute my predicate to decide when to terminate?
05:49:56 <frerich> frankier: I'd look whether monad-loops has something like that.
05:50:01 <bernalex> I use persistent, esqueleto, etc. it works well.
05:50:36 <quicksilver> I would be very surprised if you want (m b -> Bool), frankier
05:51:18 <quicksilver> m Bool -> m a -> m [a] I could understand
05:51:19 <frankier> frerich, quicksilver, Yep looks like whileM/untilM was what I was looking for
05:51:38 <quicksilver> and (a -> m Bool) -> m a -> m [a]
05:51:51 <SrPx> merijn: what do you do to persist data?
05:52:18 <merijn> SrPx: Files
05:52:47 <SrPx> merijn: and you read everything to/from memory when your app loads?
05:52:49 <frankier> quicksilver, You're right. I think I have some sort of itchy feeling that I always want to get to unwrapped values - not sure why
05:52:59 <merijn> SrPx: Depends on what I'm doing, but yes
05:53:05 <SrPx> merijn: that will probably not work very well if you have 20gb worth of client data 
05:53:20 <merijn> SrPx: That's why I use mmap
05:53:27 <SrPx> when you do you'd probably have to write code to read/write to/from disk, and that's a haskeller's nightmare, isn't it?
05:53:30 <SrPx> merijn: let me see
05:53:31 <merijn> Manipulate the data on disk
05:54:37 <SrPx> merijn: wait that looks exactly like what I was describing and you told me was bad
05:54:53 <sedeki> is (>>=) left or right associative?
05:55:06 <KaneTW> :i (>>=)
05:55:14 <merijn> sedeki: Use :i in ghci
05:55:36 <sedeki> it says infixl 1 >>=
05:55:42 <quicksilver> sedeki: its arguments are not the same type
05:55:42 <sedeki> does this mean left-assoc?
05:55:47 <sbrg> yes
05:55:50 <quicksilver> sedeki: there is only one way it can sensibly associate
05:55:58 <sedeki> yes it is, just wanted to confirm
05:56:16 <merijn> sedeki: infixl is left, infixr is right, the number is the precedence (0 is lowest, 9 is highest)
05:56:33 <merijn> (function application having precedence 10 and record syntax precedence 11)
05:57:39 <sedeki> oh ok. thanks
06:05:30 <quicksilver> @hoogle equating
06:05:32 <lambdabot> No results found
06:07:13 <lonokhov> if anyone cares: In Haxl `traverse (fetchA >=> fetchB) [1,2,3,4]` will batch both fetchA and fetchB. tested on spherical cows.
06:13:35 * hackagebot cayley-dickson 0.2.0.0 - Complex numbers, quaternions, octonions, sedenions, etc.  https://hackage.haskell.org/package/cayley-dickson-0.2.0.0 (lmj)
06:15:25 <shersh> Hello everyone! I'm interested, what is the best way to check if length of some list is smaller then some value? It seems rather inefficint got write `length xs < threshold` because xs can have big length an threshold could be very small. It seems logical to write `length $ take threshold xs < threshold` or maybe better. And approach with only taking lentgh don't work on infinite lists. Is there better ways in Haskell?
06:16:20 <merijn> shersh: How about "null $ drop threshold largeList"?
06:17:06 <shersh> merijn: yeah, this is better, because requires only one traversal :)
06:24:02 * hackagebot BenchmarkHistory 0.0.0.2 - Benchmark functions with history  https://hackage.haskell.org/package/BenchmarkHistory-0.0.0.2 (ChristianHoener)
06:29:02 * hackagebot libgraph 1.7 - Store and manipulate data in a graph.  https://hackage.haskell.org/package/libgraph-1.7 (faddegon)
06:30:32 <merijn> Weeaboos ruin everything associated with anime and manga >.<
06:30:38 <merijn> whoops, wrong channels
06:31:34 <bernalex> everyone complaining about weeabos ever: "people are having fun the wrong way QQ"
06:33:34 <m1dnight_> Does anyone know how I can use HUnit to assert the equality of two IO actions? I have an Eq instance for T, and I want to test `IO T == IO T`
06:33:45 <mauke[o}> impossible
06:33:57 <m1dnight_> Im getting the error "No instance for (Eq (IO T)) arising from a use of H.assertEquAL"
06:34:19 <mauke[o}> one of them might be 'fail "lol bye" :: IO T'
06:35:12 <mauke[o}> and the other is 'forever (hPutStr stderr "\a")'
06:35:26 <m1dnight_> Hrm.
06:36:03 <m1dnight_> HUnit should handle errors. so i think there has to be a way
06:36:12 <lyxia> did you mean to compare the results of the two IO actions instead?
06:36:35 <m1dnight_> Well, I have an evaluator, which is of type `eval :: String -> IO Expression`
06:36:45 <m1dnight_> I want to evaluate two strings and compare their Expression
06:36:56 <lyxia> that's different from comparing IO Expressions
06:37:12 <m1dnight_> Yes, but you can't simply get the value into a pure function, can you?
06:37:15 <lyxia> liftM2 (==) (eval test1) (eval test2)
06:37:22 <lyxia> :t liftM2 (==)
06:37:23 <lambdabot> (Eq a, Monad m) => m a -> m a -> m Bool
06:37:37 <lyxia> indeed
06:37:43 <m1dnight_> then I should somehow tell assertEqual to use my comparator function instead
06:38:09 <opqdonut> well then use assertBool
06:38:24 <m1dnight_> oh
06:38:29 <m1dnight_> that is a way too.
06:38:31 <opqdonut> so: do a <- test1; b <- test2; assertBool (areEqual a b)
06:38:36 <opqdonut> or something like that
06:38:40 <m1dnight_> yeah I understand
06:38:43 <m1dnight_> makes perfect sense :D
06:38:45 <m1dnight_> thanks
06:41:43 <orion> Does anyone know how to specify libraries that need to be linked in when using a custom cabal builder?
06:41:53 <orion> I'm getting this error: dist/setup/setup.hs:2:8: Could not find module ‘Development.Shake’
06:41:55 <orion> I'm not sure how to tell cabal to include the shake library.
06:42:34 <orion> I've already listed it in the build-depends section of the library, but I'm not sure if that's correct.
06:44:12 <merijn> orion: Unfortunately cabal doesn't yet support separate dependencies for Setup.hs
06:44:19 <orion> :(
06:44:24 <merijn> orion: AFAIK it should be getting that soon
06:44:56 <orion> `cabal build` fails every time I try to run it, despite shake being installed in the sandboxDo you know of a way to work around this?
06:45:43 <merijn> orion: Try asking dcoutts in #hackage
06:46:32 <orion> Alright. Would switching to stackage help with this, or probably not yet?
06:47:11 <merijn> No clue
06:49:01 <bernalex> name some relevant unis for people who want to use haskell (or FP at least) for a phd (in programming languages or applied functional programming)
06:50:18 <Grisha> Hi everyone
06:50:34 <Grisha> I'm trying to use Data.VectorSpace
06:50:51 <Grisha> the class definition has an associated type Scalar:
06:51:10 <Grisha> class AdditiveGroup v => VectorSpace v where
06:51:10 <Grisha>   type Scalar v :: *
06:51:40 <Grisha> whereas I understand that you need scalars to define a vector space, how is this definition of the class to be read?
06:52:54 <mauke[o}> if you want to define an instance of VectorSpace, you first need to define an instance of AdditiveGroup, then define Scalar
06:53:26 <merijn> Grisha: It's an "associated type", that basically means the instance will be written as "instance VectorSpace Foo where Scalar Foo = Int" and the Scalar's used by the VectorSPace functions will be Int
06:54:22 <mauke[o}> inb4 "not injective"
06:55:20 <Grisha> merijn, can I do smth like newtype Vec2 = (Double, Double); instance VectorSpace Vec2 where Scalar Vec2 = Double?
06:55:42 <merijn> Grisha: Yes
06:55:48 <mauke[o}> yes, except data Vec2 = Vec2 Double Double
06:55:55 <mauke[o}> or newtype Vec2 = Vec2 (Double, Double)
06:56:01 <merijn> Grisha: That's precisely the goal of "type Scalar v :: *""
06:56:18 <Grisha> merijn, thanks a lot
06:56:29 <merijn> Grisha: Consult the GHC documentation on (associated) type families for details
06:56:48 <Grisha> mauke[o}, thanks a lot, I had newtype in my version
06:57:24 <Grisha> merijn, thanks for naming the keywords
06:57:33 <Grisha> I'm still a newbie^3
06:58:03 <mauke[o}> possibly even data Vec2 = Vec2 !Double !Double
06:58:32 <Grisha> mauke[o}, why strict?
06:59:03 * hackagebot cryptonite 0.9 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.9 (VincentHanquez)
06:59:51 <Grisha> mauke[o}, merijn do you know any simple implementations of VectorSpace for n-tuples of Double?
07:00:20 <mauke[o}> depends on the application. just a random idea
07:00:23 <dxvxb> how do you install your haskell libraries on linux, via cabal or stack?   i see there is not every library is available via dist. package managers...
07:04:04 * hackagebot th-lift 0.7.5 - Derive Template Haskell's Lift class for datatypes.  https://hackage.haskell.org/package/th-lift-0.7.5 (MathieuBoespflug)
07:04:53 <dxvxb> also, i have used stack in windows and there is no option for searching packages....  can someone tell me why? it can do hell lot of other things..
07:05:24 <dxvxb> only !search...
07:05:57 <dxvxb> or what the hell i am missing...!! HELP?
07:09:10 <jeltsch> dxvxb: I use cabal-install.
07:09:42 <Ankhers> dxvxb: What do you mean by searching packages?
07:09:59 <Ankhers> dxvxb: Do you mean list the packages that are installed, or list the packages you can install?
07:10:06 <Ankhers> s/list/search
07:10:32 <dxvxb> Ankhers:  list of packages that we can install.
07:11:57 <Ankhers> dxvxb: http://www.stackage.org/ is the list of packages that stack can install by default. Though, you can install anything that is on Hackage.
07:12:24 <dxvxb> jeltsch: yeah that comes with the it... but i was wondering if i should use stack for some good reasons...
07:12:39 <Ankhers> dxvxb: Though, I believe you are confusing stack with a package manager, which it is not. It is a build tool.
07:13:44 <dxvxb> Ankhers: so its ONLY a build tool?
07:14:27 <Ankhers> dxvxb: That is its main focus, yes. It is a build tool that knows how to download packages. It is not a package manager.
07:15:14 <dxvxb> oh yeah thats. thanks... only write what you need in that yaml file. sorry :)
07:15:36 <Ankhers> dxvxb: Haskell, to my knowledge, does not a package manager similar to `yum' or `apt'.
07:16:51 <danza> many Haskellers use Nix, though
07:16:53 <dxvxb> Ankhers:  what? you mean does not have a ....?
07:17:07 <mauke[o}> yes
07:17:44 <danza> Ankhers, no language has package managers like Yum and Apt, just because they are not language specific, but system specific
07:18:48 <dxvxb> Ankhers: cabal isnt one? it lets you list the available items...
07:19:30 <nshepperd> cabal is as much a package manager as gem or pip
07:19:40 <Ankhers> dxvxb: cabal-install is similar to stack in that it is a build tool that knows how to download packages.
07:20:20 <jeltsch> dxvxb: I cannot comment on stack, since I have never really looked at it.
07:20:43 <nshepperd> saying it's not a package manager is more of an excuse for not being able to uninstall packages than anything meaningful, imo
07:23:14 <dxvxb> jeltsch: neither should i, i think, as right now i am just learnin it and dont need to have duplicate packages floating around... it gets too big with haskell libs..
07:24:14 <Ankhers> dxvxb: stack will not install duplicate packages.
07:28:10 <dxvxb> Ankhers:  okay, i dont know, it was around 2gigs with only yesod and diagrams installed (hask & packages)...
07:28:38 <Ankhers> dxvxb: What is "it"?
07:29:00 <pie_> so ive heard things like the haskell books are outdated or somehting
07:29:08 <pie_> how does one actually go about learning haskell then?
07:29:13 <dxvxb> the directory... well leave it.
07:29:17 <Ankhers> @where learnhaskell
07:29:17 <lambdabot> https://github.com/bitemyapp/learnhaskell
07:29:18 <pie_> is there something like the python guide?
07:29:49 <Ankhers> pie_: I am using that. 
07:29:52 <kadoban> pie_: https://github.com/bitemyapp/learnhaskell and you could try http://haskellbook.com/ that one is definitely not out of date, in fact it's still being finished at the moment.
07:30:12 <pie_> thanks \o/
07:30:20 <Ankhers> dxvxb: stack does not install anything into the directory you are in.
07:31:08 <Ankhers> dxvxb: What version of stack are you using? `stack --version'
07:31:43 <pie_> i quite like pythons guide so something like that would be awesome ;)
07:31:57 <Ankhers> pie_: Which guide is that?
07:32:13 <pie_> assuming it would be feasible for haskell. the python docs are fricken great. anyway, idk what im talking about, so ill just get started on haskell :P
07:32:17 <dxvxb> umm, i have a question, how can we get String data friom IO String?? or we cant??
07:33:12 <pie_> https://docs.python.org/3/tutorial/index.html
07:33:21 <kadoban> dxvxb: No, you can't. Instead, whatever you were planning on doing with the String, do it in a 'do' block that pulls from that value. The result will then be IO Whatever, and inside the 'do' block you can pretend you're using the String value normally.
07:33:25 <dxvxb> Ankhers: i have changed to linux now...
07:33:30 <mauke[o}> dxvxb: you can't really, but you'd use >>= to "push" your computation into IO
07:33:59 <mauke[o}> i.e. instead of pulling values out, push your operations in
07:34:40 <kadoban> So something like: blah = do {s <- theIoString; print (s ++ s)}      then blah will be type IO (), an IO action. Or you can have a different kind of result too (but always IO /something/)
07:35:13 <avidlearner> @pl \xs n -> take n xs ==> flip take
07:35:13 <lambdabot> flip flip (flip take) . ((==>) .) . flip take
07:35:21 <mauke[o}> or with >>=: theIoString >>= \s -> print (s ++ s)
07:35:39 <Zekka|Sigfig> avidlearner: Standard caveat: if you actually write code like that expect your pals to very pissed!
07:35:45 <dxvxb> okay. thanks...
07:35:50 <Zekka|Sigfig> to be very pissed*
07:36:02 <kadoban> dxvxb: Once you're comfortable with that, there's cute combinators to make it much quicker, but … I'd start with that.
07:38:03 <dxvxb> kadoban:  yeah, i am just starting to get it.. maybe.. :P  thanks.
07:39:06 * hackagebot ofx 0.4.0.4 - Parser for OFX data  https://hackage.haskell.org/package/ofx-0.4.0.4 (OmariNorman)
07:39:49 <Zekka|Sigfig> Oh cool! I didn’t know there was a Haskell OFX package
07:40:06 <Zekka|Sigfig> More dudes need to implement OFX, it’s a hellion
07:42:59 <pie_> what does this "haskell platform" do?
07:43:20 <Lokathor> pie_, it's an "all in one" type of install
07:43:25 <pie_> ah.
07:43:37 <pie_> there is some "stack" that is also spoken of as an easier alternative
07:43:48 <Lokathor> less people are using it these days I think, installing stack and using that to get GHC is a lot better most of the time
07:43:54 <Zekka|Sigfig> “stack” is a program that helps you compile Haskell code
07:44:28 <Lokathor> Zekka|Sigfig, it also will download a correc GHC for your project's build needs
07:49:06 <pie_> man, the committee really seems to like their haskell platform download page... (@ mailing list thread linked on github)
07:51:41 <Lokathor> particularly on windows it was the best way to get haskell without being fiddly for a while
07:54:06 * hackagebot generic-deriving 1.9.0 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.9.0 (ryanglscott)
07:54:22 <sm_> Zekka|Sigfig: what would you use OFX for ?
07:54:46 <Zekka|Sigfig> sm: I work on finance software, OFX is the standard interchange
07:54:51 <Zekka|Sigfig> interchange format*
07:55:05 <Zekka|Sigfig> although IMHO the hard parts of OFX are the requirements it imposes on service providers to model
07:55:25 <sm> Zekka|Sigfig: I'd like to add it to the hledger accounting tool, but I haven't seen any demand
07:55:41 <Zekka|Sigfig> sm: I would probably not use it for that personally
07:56:08 <sm> it would be for easier import of bank data, basically
08:19:05 <joco42> is there lot of c++ in this? after reading the preface i got discouridged... 
08:19:08 <joco42> http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
08:19:35 <joco42> the preface said that the code examples will be in c++
08:20:03 <joco42> should i keep reading on even if i don't know c++ ?
08:20:25 <dave23> how do I use the result of a monadic action more than once without running it again?
08:20:35 <Zekka|Sigfig> joco42: I’m going to guess that he’ll use templates and it’ll get confusing, but I haven’t read it
08:20:48 <Zekka|Sigfig> dave23: If you only bind once, you can still use the value you got from binding that first time
08:20:53 <ARM9> looking at a few chapters of part 2 there's no c++ in sight
08:21:05 <Zekka|Sigfig> This is allowed: x <- act; putStrLn x; putStrLn x
08:21:06 <geekosaur> dave23, with do notation you use <-, with >>= you capture with \name -> ...
08:21:33 <dave23> thanks, I knew it was something obvious
08:21:55 <joco42> ARM9: oh well so only part 2 is useful... 
08:22:44 <mauke[o}> joco42: what
08:23:54 <joco42> well it seems that he has haskell+ c++
08:24:08 <ARM9> looks like a lot of examples use haskell and then he draws parallels with c++
08:24:12 <joco42> so i try to not read the c++ part
08:24:59 <joco42> maybe it will make sense if i only read the haskell examples, otherwise seems like a fine website
08:25:17 <mauke[o}> joco42: I just skimmed 60% of part one and there's not a lot of c++
08:25:23 <joco42> mauke[o}: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
08:25:41 <mauke[o}> it would be faster to just check yourself instead of worrying
08:25:43 <anks> any ideas on why this parser parses only 1 "frame" even if there are many identical side by side in binary file? https://gist.github.com/adamczykm/172031432e06ee58403d
08:25:43 <joco42> yeah, it seems bearable... 
08:26:22 <anks> its attoparsec's parsers
08:26:38 <anks> *these are
08:26:41 <joco42> i thought that 50% of people here already went through it so i thought it is easier to ask... 
08:27:02 <joco42> i am such a newbee
08:28:54 <geekosaur> you don't need to know category theory to use haskell
08:30:24 <tulcod> you don't need to use haskell to learn category theory
08:30:44 <Copperis> you don't need to understand music to fix cd players
08:31:03 <icen> joco42: if you're after the category theory, you can happily ignore both the c++ and the haskell; it's there to make the rest look less scary
08:31:12 <anks> any ideas on why this parser parses only 1 "frame" even if there are many identical side by side in binary file? https://gist.github.com/adamczykm/172031432e06ee58403d . What am I missing? :(
08:31:32 <icen> Personally, I'm soothed by the haskell. C++ terrifies me
08:33:08 <Aberdare> apologies for newbie questions, but how can I have a data type with multiple constructors and I want to be able to use both the data type and its constructors within the same function definition...
08:33:08 <Hi-Angel> joco42, to be honest bartosz's articles aren't that great. I'd recommend you to read «Category Theory for Scientists» — that's what I personally read. But some time before, these articles of Bartosz was just the thing, that made my interest in Haskell ☺
08:33:18 <mauke[o}> Aberdare: example?
08:33:58 <lyxia> anks: Uhm I don't see anything wrong with this. Can you paste it all?
08:33:59 <Aberdare> so f Type a b = [Type a b, Type (a+1) b]
08:34:09 <Aberdare> if that makes sense as a silly example
08:34:18 <Aberdare> but I want to eliminate reconstructing Type a b
08:34:19 <mauke[o}> Aberdare: no, Type is undefined
08:34:34 <Zekka|Sigfig> Oh wait, I think I see what you’re asking
08:34:36 <Aberdare> sorry, that's just a placeholder, say MyType
08:34:36 <Walther> Best ways of producing graphics from Haskell? Basically just throwing polygons/vertices/shaders around
08:34:53 <mauke[o}> Aberdare: f x@(Constr a b) = [x, Constr (a+1) b]
08:34:53 <Zekka|Sigfig> Would this satisfy you? f x@(Type a b) = [x, Type a + 1 b]
08:34:59 <Aberdare> I want to have f a = [a, Type (??? + 1) ???]
08:34:59 <Zekka|Sigfig> er, (a + 1)*
08:35:04 <hackrilege> i am in dismay. i learned about TVar, but becuase atomoically does not work with unsafePerformIO, i cant query a TVar to create a non IO update function, which should just read the IO state
08:35:11 <Aberdare> I don't know how to do the ??? bits
08:35:23 <hackrilege> Walther. im using GLUT atm
08:35:28 <Aberdare> Zekka|Sigfig: that's the one I think, thanks!
08:35:36 <mauke[o}> Aberdare: alternatively: data Type = Constr { field1, field2 :: Int }; f x = [x, x{ field1 = field1 x + 1 }]
08:35:37 <Aberdare> I haven't come across that yet so I need to do some reading
08:35:45 <mauke[o}> but that also gets annoying
08:35:51 <mauke[o}> and then you get into lenses :-)
08:35:57 <Zekka|Sigfig> Aberdare: FWIW in this analogy: x is a value of some type, Type is a constructor for that type
08:36:02 <anks> lyxia, maybe there is something wrong with reloading source files in ghci.. This may cause this strange behavior, im checking it, atm
08:36:03 <Walther> hackrilege: huh, neat!
08:36:13 <hackrilege> also try GLFW
08:36:26 <Zekka|Sigfig> mauke’s right, and lenses could probably get you even shorter code, but imho they’re a very sledgehammery tool for small programs
08:36:32 <hackrilege> cabal install glut-examples
08:36:41 <joco42> Hi-Angel: ok, cool, i have that book actually... 
08:36:45 <Aberdare> oh ok thanks, I'm using a lot of the wrong terminology I'm sure, I'm super super new
08:37:39 <joco42> icen: i like the haskell part in there... makes it look less scary
08:37:48 <mauke[o}> data A = B Int Int | C | D String   -- in something like this, A is a type. B, C, D are (data) constructors
08:38:25 <joco42> and the guy is as a physicist... kinda like me, so maybe that helps...
08:38:25 <jle`> hackrilege: wait, why would you need TVars to work with unsafePerformIO>
08:38:31 <Zekka|Sigfig> (there’s another kind of constructor called a type constructor but you probably don’t need to know about them yet)
08:38:45 <mauke[o}> you could even argue that A is a nullary type constructor
08:39:04 <Walther> on another note, are there ghc flags for reducing the binary size?
08:39:20 <mauke[o}> but in general we only talk about type constructors when considering kinds other than *
08:39:29 <Walther> that wouls optimoze out stuff that isn't needed
08:39:37 <Walther> grr mobile keyboard
08:39:39 <Zekka|Sigfig> Walther: The best thing you can probably do is dynamically link, the Haskell runtime’s kind of big
08:39:49 <Zekka|Sigfig> I don’t know if ghc additionally supports tree shaking or anything
08:39:53 <Walther> hm
08:40:13 <hackrilege> jle' because the function im wanting to hack into wants a (float -> world0 -> world0) type. i have a TVar a and an a -> world0
08:41:05 <hackrilege> ill have to rewrite the method play of glut otherwise....
08:41:13 <hackrilege> its the central method
08:42:30 <anks> lyxia: parseOnly (many' frameParser) , if frameParser fails it loops :|, if it succeed it doesnt try to pare another frame .. Wtf?
08:43:37 <hackrilege> at each frame it applies a modification function to the thing its visualising. i cant infer the 3d graph from the 2d image, so i pass in an atomically changing TVar and would like to make the (float -> world -> world) = \ _ _ -> atomically $ readTVar tvarInScope
08:43:42 <stoogenmeyer> hey guys, I've defined a type Priority = Int and then I would like to implement Monoid for it, but I get an error for Duplicate instance declaration
08:43:46 <stoogenmeyer> what gives?
08:44:35 <Freundlich> stoogenmeyer: The common way to get out of this is to use a newtype.
08:44:40 <hackrilege> = \ _ _ -> unsafePerformIO $ atomically $ readTVar tvarInScope would be required
08:44:40 <KaneTW> you need a newtype, not a type
08:44:54 <KaneTW> a type is just an alias
08:45:06 <KaneTW> a newtype is treated like a different data type at runtime but compiles without any overhead
08:45:14 <KaneTW> uh
08:45:15 <hackrilege> does that make sense jle'?
08:45:16 <KaneTW> at compile time
08:45:49 <quchen_> stoogenmeyer: Maybe this helps explain the differences: https://github.com/quchen/articles/blob/master/fbut.md#data-newtype-type
08:45:56 <darkroom> does anyone know is ghc-mod 5.4 is supported by syntastic? I am pretty sure it isnt because when i updated syntastic stopped working :/ any known fixes?
08:49:09 <stoogenmeyer> thanks guys
08:50:15 <ARM9> darkroom https://github.com/scrooloose/syntastic/issues/1576 first issue on the github page
08:51:38 <darkroom> :w
08:51:44 <darkroom> lol sorry in tmux
08:55:03 <jle`> KaneTW: newtypes are treated like the same time at runtime, not different
08:55:09 <jle`> treated differently at compile time :)
08:56:47 <KaneTW> jle`: i typo'd
08:56:59 <KaneTW> corrected myself after
08:57:05 <jle`> oh, i see it now :)
08:57:08 <stoogenmeyer> so just to clarify, I use `newtype Priority = Int`. Should that work?
08:57:19 <jle`> stoogenmeyer: not like you want it to
08:57:20 <KaneTW> you need to do newtype Priority = Priority Int
08:58:23 <stoogenmeyer> hmm.. and that broke the rest of the program (-:
08:59:34 <stoogenmeyer> so if I had something like `leaf :: a -> Tree Size a` and constructor `leaf a = Leaf 1 a`
08:59:45 <stoogenmeyer> should it now become `leaf a = Leaf (Size 1) a`?
08:59:46 <hackrilege> is there something like atomically readTVar i can use with unsafePerformIO?
09:00:23 <mauke[o}> stoogenmeyer: yes, unless you define a Num instance for Size
09:00:31 <mauke[o}> (which can be derived automatically)
09:00:53 <hackrilege> in this example i am simply reading, not modifying the TVar
09:01:24 <hackrilege> atomically constrains me to the IO monad which I think is unnesacary
09:01:35 <jle`> hackrilege: such a thing wouldn't really make too much sense, because you have a function that returns a different value based on when it's evaluated
09:01:51 <hackrilege> ah ok
09:02:02 <hackrilege> not that it makes an effect, but that it does see one
09:02:41 <hackrilege> ok i delve into glut.
09:02:42 <hackrilege> thanks
09:03:19 <lpaste_> nani___ pasted “Exercise 3” at http://lpaste.net/145576
09:03:29 <hackrilege> what about the non IO based STM moad stuff, isnt that not IO?
09:04:25 <mauke[o}> hackrilege: the only way to run STM stuff is atomically :: STM a -> IO a
09:04:32 <mauke[o}> which is badly named and should probably be runSTM
09:04:41 <hackrilege> https://hackage.haskell.org/package/stm-2.4.4/docs/Control-Concurrent-STM-TVar.html#v:newTVarIO
09:04:57 <hackrilege> ah ok
09:04:59 <hackrilege> thanks
09:06:10 <nani___> Ignore the paste, sorry
09:08:02 <pavonia> nani___: Note that Show is not meant for pretty printing
09:10:47 <hackrilege> hmm, thats really annoying, i cant make instances of things using TVar as all the output types are bundled up in io
09:11:11 <nani___> pavonia: what is it meant for? I am following the third exercise here: http://www.seas.upenn.edu/~cis194/hw/04-typeclasses.pdf (I saw this course recommended in this channel yesterday)
09:11:36 <Cale> hackrilege: You can make them as the results of IO actions
09:11:55 <Cale> (or likely STM actions)
09:12:10 <hackrilege> im not sure i understand... i certainly cant make them instances of show or functor as i would like
09:12:19 <Cale> oh, instances in that sense
09:12:22 <Cale> Well, yeah
09:12:39 <Cale> It's just not a Functor, and there's nothing you could meaningfully show...
09:12:59 <hackrilege> i have a thing which requires that it returns an image type, i can only give it an IO image. ill have to change the glut library as i cant use unsafeperformIO to make the hack...
09:13:08 <pavonia> nani___: It's usually meant to product actual Haskell code such that read . show == id
09:13:13 <hackrilege> i could show the current state
09:13:19 <hackrilege> how is that not meaningfull?
09:13:33 <Cale> hackrilege: no you couldn't
09:13:44 <Cale> hackrilege: show :: a -> String
09:13:58 <hackrilege> i could perform atomically . readTVar in a forked thread
09:14:00 <jeltsch> Cale: His point was that it would be a meaningful operation, which Haskell forbids.
09:14:06 <jeltsch> I think, at least.
09:14:07 <Cale> so in this instance, it would be like  show :: TVar a -> String
09:14:16 <hackrilege> yeh
09:14:29 <jeltsch> hackrilege: It would be meaningful in a sense to show the state, but this is not what show is for.
09:14:30 <Cale> So it would have to produce a String that was independent of the contents of the TVar
09:14:32 <hackrilege> instance Show (TVar MyType) where
09:15:04 <jeltsch> hackrilege: The show function is for turning values, which do not have mutable state, into string representations.
09:15:06 <Cale> You could perhaps in some implementations show the location of the TVar in memory, however garbage collection would even make that impossible.
09:15:10 <jle`> you'd also want show x to return the same string for the same x, no matter when it's evaluated
09:15:23 <hackrilege> i dont see at all why its type bing TVar a -> String rather than a -> String means the string cannot depend on the contents of the a
09:15:39 <Zekka|Sigfig> Cale: It would also violate one group of args -> one return val
09:15:40 <Cale> hackrilege: show is a function
09:15:49 <Cale> If you give it the same TVar, it has to give you the same String
09:15:52 <Zekka|Sigfig> show x would be effectively a fixed string plus a random value
09:15:58 <Cale> no matter how many times you do that
09:16:25 <Cale> Right?
09:16:28 <hackrilege> jle' no! i would expect it to change depending on when its evaluated. i can show you my notes, no matter how many i have written...
09:16:42 <jle`> but that's not what a function is
09:16:53 <Zekka|Sigfig> hackrilege: Strictly you *can* do this, but it violates the expectations of Haskell
09:16:59 <Cale> A function A -> B assigns to each value of type A, a single value of type B
09:17:12 <Zekka|Sigfig> Haskell expects your functions not to rely on side effects
09:17:14 <Cale> That's basically the definition of what a function is
09:17:18 <Cale> right?
09:17:35 <Zekka|Sigfig> You can still get away with this but it’s not idiomatic and there’s no guarantee that compiler optimizations won’t break your code
09:17:39 <Cale> So a function TVar a -> String would have to assign to each TVar a, some particular String
09:17:45 <hackrilege> its a function of time...
09:17:50 <mauke[o}> Zekka|Sigfig: you can't really do this
09:17:56 <Cale> Not unless you have a time argument
09:17:57 <jle`> almost everything in haskell, and most of GHC's optimizations, assume that functions behave in a way that "f x" will return the same value for the same x every time
09:18:02 <hackrilege> i do have a time argument
09:18:06 <Cale> It's not UTCTime -> TVar a -> String
09:18:07 <jle`> hackrilege: so, you mean f :: Time -> TVar a -> String ?
09:18:14 <Cale> It's just TVar a -> String
09:18:28 <jeltsch> hackrilege: If it was a function of time, you would have to pass the time explicitly as an argument. Otherwise, it would not be a function of time. ;-) 
09:18:33 <EvanR> functions are time are awesome, just pass the time in as a parameter
09:18:44 <mauke[o}> s/are/of/
09:18:45 <Zekka|Sigfig> mauke[o}: You can do it if you cheat with features like unsafePerformIO
09:18:56 <EvanR> this has greatly benefited me code IRL (not haskell)
09:18:59 <mauke[o}> Zekka|Sigfig: that doesn't affect the function itself, just the result
09:19:00 <mauke[o}> I think
09:19:02 <Cale> Zekka|Sigfig: Please don't confuse the issue
09:19:08 <hackrilege> well the animation increments the time variable internally within glut, and really i dont need it, i just need something to call it periodically, so the time variable has been removed from this local scope, but since it is present i can use it
09:19:16 <Zekka|Sigfig> Cale: Yeah, I’ll not mention that
09:19:30 <Cale> unsafePerformIO exists, but it isn't a reasonable answer to the confusion that hackrilege is having
09:19:33 <EvanR> hackrilege: it sounds like youre trying to get closer to FRP
09:19:46 <EvanR> not c++ in haskell
09:19:51 <hackrilege> its ok, but unsafePerformIO specifically will not work here because of how the messages are transfered by TVar
09:20:05 <jle`> it also won't work because you can't rely on it to behave meaningfully
09:20:15 <jle`> because GHC optimizations, how things are evaluated, etc.
09:20:24 <jle`> it's not supposed to make sense
09:20:26 <indigo945> that feeling when Control.Lens's template haskell lens constructor results in a syntax error
09:20:27 <EvanR> whats wrong with Show a => TVar a -> IO String ?
09:20:28 <jle`> that's why it's "unsafe" :)
09:20:31 <hackrilege> the thing is its not frp! im not interacting with the process, just overseeing it
09:20:43 <Cale> hackrilege: What's actually going on?
09:20:54 <EvanR> hackrilege: thats the O in IO
09:21:05 <EvanR> overseeing ;)
09:21:24 <Cale> I missed the whole beginning of this discussion?
09:21:29 <Cale> er, no (?)
09:21:34 <hackrilege> glut uses a function play, it takes a function which modifies the datatype it is displaying. i cant do that, as this datatype cannot be used to infer that which generated it.
09:21:34 <EvanR> i did, thats for sure
09:21:36 <jle`> yeah, this is likely an XY problem...there's probably a really simple solution, but you're more focused on fixing a problem in your doomed implementation
09:21:55 <hackrilege> basically i have a 3d graph and the picture is a 2d representation from which the 3d representation cannot be deduced
09:22:16 <hackrilege> i would like instead to provide a method which queries a TVar
09:22:28 <EvanR> why not use IO ?
09:22:36 <hackrilege> rather than making a new image from the old one, a new one is generated from the constantly changing 3d graph in the TVar
09:22:47 <Cale> Which glut library? http://hackage.haskell.org/package/GLUT-2.7.0.3/docs/Graphics-UI-GLUT.html ?
09:22:49 <indigo945> can you have GHC show the template haskell output?
09:22:54 <hackrilege> EvanR, there is another process continually modifying the 3d graph
09:22:56 <indigo945> I want to inspect this syntax error
09:22:57 <luite> indigo945: -ddump-splices
09:22:59 <indigo945> thanks
09:23:14 <Cale> I don't see play
09:23:16 <luite> oh wait, that's the input i think
09:23:21 <hackrilege> play is hard to find
09:23:24 <luite> or perhaps not
09:23:26 <Cale> uhhh
09:23:27 <luite> no it's the output
09:23:35 <hackrilege> i can get it in :t in ghci
09:23:42 <hackrilege> but not on hackage or hoogle
09:23:52 <hackrilege> ill dig about a bit more for you 1 sec
09:23:53 <Cale> Are you sure it's from GLUT then?
09:23:55 <mauke[o}> hackrilege: what does :info say about it?
09:23:56 <Cale> :info play
09:23:56 <hackrilege> yeh
09:24:00 <Cale> and see where it's defined
09:24:15 <jle`> hackrilege: there might be a problem in that glut does optimizations/assumes that your function behaves like an actual function, too. most libraries use equational reasoning to refactor and re-optimize code, but all of that is only valid when functions behave like real functions.  that's why unsafePerformIO is a bad idea in general here, even if it's not for TVar
09:24:22 <hackrilege> gloss.interface.pure.game
09:24:29 <hackrilege> graphics.
09:24:40 <mauke[o}> hackrilege: what does :info say about it?
09:24:41 <Cale> oh
09:24:57 <hackrilege> https://hackage.haskell.org/package/gloss-1.8.2.2/docs/Graphics-Gloss-Interface-Pure-Game.html
09:25:12 <Zekka|Sigfig> hackrilege: FWIW I get the impression that, depending on how attached you are to this architecture, you may want to use another language
09:25:15 <Cale> So, why aren't you using Graphics.Gloss.Interface.IO.Game?
09:25:18 <hackrilege> (Float -> world -> world) 
09:25:18 <hackrilege> A function to step the world one iteration.
09:25:25 <Cale> http://hackage.haskell.org/package/gloss-1.9.4.1/docs/Graphics-Gloss-Interface-IO-Game.html
09:25:28 <hackrilege> i am using that module sorry, my miustake
09:25:33 <Zekka|Sigfig> nothing wrong with wanting to use functions that depend on side effects but it’s not something Haskell is designed to be good at
09:25:41 <hackrilege> oh IO game, i didnt see that
09:25:44 <mauke[o}> Cale: haha
09:25:44 <hackrilege> cool
09:25:45 <jle`> haskell is good at functions that depend on side effects :O
09:25:46 <Cale> If you want to do IO in the functions which update the world, then you use that.
09:25:56 <hackrilege> lol,
09:25:57 <Zekka|Sigfig> jle`: It’s good at functions that depend on *effects*!
09:26:01 <hackrilege> AWESOME!!!
09:26:04 <hackrilege> thanks
09:26:06 <Zekka|Sigfig> But not on side effects, you have to do all this bureaucracy to account for them
09:26:28 <hackrilege> thats a real *doh* moment
09:27:14 <hackrilege> a problem when brute forcing minimal wrappers to libraries rather than learning their contents
09:28:46 <jle`> any moment where you are thinking of reaching for unsafePerformIO, 99% of the time it's a sign that something way up the line is messed up ;)
09:29:46 <mauke[o}> unsafePerformIO is for stuff that's morally pure but can't be proved in haskell's type system
09:30:01 <jle`> it's hard to realize the extent of the depravity of unsafePerformIO and how differently it really is than what you think it is
09:30:18 <Zekka|Sigfig> jle`: When I’m *real* tempted to use unsafePerformIO I usually decide “maybe I shouldn’t be working in haskell"
09:30:19 <jle`> especially if you think of it as just a way to execute arbitrary IO in an otherwise pure function
09:30:28 <Zekka|Sigfig> minding that I understand most of the alternatives to unsafePerformIO so I rarely get to thatp oint
09:30:49 <Zekka|Sigfig> It’s probably a different story if you don’t understand how effects work in Haskell
09:31:20 <hackrilege> yeh i came on here as soon as unsafePerformIO started appearing in the documentation of readTVar
09:31:58 <Welkin> I still don't know where unsafePerformIO would be used
09:31:58 <hackrilege> thanks for clearing it up. the fault was with my understanding of GLUT, thats why i was unsure.
09:32:02 <Welkin> never encountered it
09:32:17 <hackrilege> :t unsafePerformIO . return 3
09:32:18 <lambdabot> Not in scope: ‘unsafePerformIO’
09:32:22 <jle`> oops :| i might consider that a problem with the documentation
09:32:40 <hackrilege> yes i would i linked it above
09:32:52 <hackrilege> its a confusing stsatement, ill bring the link down 1 sec
09:32:59 <jesuishaskell> Hello
09:33:03 <Zekka|Sigfig> Welkin: Usually what annoys me into not using Haskell is knowing how I would do some side effect without unsafePerformIO and deciding “that’s a needlessly huge refactor and I don’t see how I would have known to plan for that”
09:33:05 <jle`> also maybe a reference to the IO version of gloss's game might be nice in gloss's docs
09:33:06 <Welkin> hello jesushaskell
09:33:24 <hackrilege> https://hackage.haskell.org/package/stm-2.4.4/docs/Control-Concurrent-STM-TVar.html#v:newTVarIO
09:33:38 <jesuishaskell> It's jesuis not Jesus
09:34:03 <jesuishaskell> I'm just a simple guy
09:34:08 <jle`> yeah, i'm continually baffled by what perceived audience the documentation for most haskell libraries is writte for
09:34:12 <jle`> *written
09:34:32 <quchen> jle`: That would be the typechecker.
09:34:32 <hackrilege> ...
09:34:55 <jle`> see 
09:34:58 <jle`> http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Bifunctor.html
09:35:17 <jle`> "Formally, the class Bifunctor represents a bifunctor from Hask -> Hask. Intuitively it is a bifunctor where both the first and second arguments are covariant."
09:35:25 <jle`> what sort of audience is that supposed to be written for
09:35:30 <jle`> people who are familiar with category theory?
09:35:36 <jle`> people who already know what a bifunctor is?
09:35:37 <hackrilege> jle' its writtend for edk
09:35:39 <quchen> jle`: Edward's audience. :-)
09:35:41 <glguy> jle`: Apparently I'm the target audience.
09:35:44 <mnoonan> exactly the sort of person who would be looking at a module called Data.Bifunctor?
09:35:52 <Welkin> jle`: rofl, that was in a twitter rant
09:36:05 <jle`> mnoonan: if that's the case, it definitely misses 90% of that audience
09:36:13 <glguy> jle`: Between the types and the description of the methods and the laws it seems pretty complete
09:36:42 <jle`> it's definitely a complete description
09:36:46 <jle`> 100% accurate
09:36:53 <quchen> glguy: "The Functor class is used for types that can be mapped over. Instances of Functor should satisfy the following laws:"
09:37:00 <hackrilege> but you need only click a link on that page to see true documanation prowess http://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Tuple.html#t:-40--44--44--44--41-
09:37:03 <mnoonan> Are you just expecting more motivation?
09:37:08 <quchen> There's quite a difference in the style of the docs.
09:37:17 <glguy> quchen: OK
09:38:05 <quchen> glguy: Maybe a sentence like "Bifunctor is like Functor but with two parts instead of one" might even things out.
09:38:16 <quchen> Maybe for the "intuitively" section.
09:38:34 <hackrilege> the problem with using words such as covarient, namely anything requiring specific knowledge, is that its not actually informative. it seems strange to have to spell that out... its supposed to be a resource for people who *dont* know what it does
09:38:51 <quchen> I'm sure Edward would be open to patches. It's just that nobody seems to be bothered enough.
09:39:20 <glguy> I've been reading too much Python documentation the last couple days to be sympathetic to having flowery documentation that uses lots of words and doesn't really tell you any specific about what things actually do
09:39:27 <quchen> hackrilege: Those terms have a precise meaning, and that meaning is useful to some.
09:39:46 <quchen> hackrilege: A profunctor for example is like a bifunctor, only that it's contravariant in its first component.
09:39:50 <jle`> you definitely don't need a PhD to understand it, and it's definitely understandable if you know what to look up and research, but it's just kind of not really expressing awareness of the most effective way to reach most of its audience.  i'm not talking about bifunctor in particular; i'm referring to a general trend in the old school haskell libary docs :)
09:40:04 <quchen> hackrilege: If I had not known what a profunctor was but only a bifunctor, I would understand profunctor now.
09:40:34 <hackrilege> if you knew what i bifunctor was you would read the documentation and go "yeh, thats right" - i guess it does point the user to the correct resource though, the terminology they need to understand before they can use the library. but the specific problem with lens is that at no point does it let you know that you dont need to use it at all and you 
09:40:34 <hackrilege> just keep getting sucked further down this rabbit whole. also it defines may unnsacary classes in an arguably non canonical way
09:41:08 <quchen> "Clowns to the left, jokers to the right"
09:41:11 <quchen> ಠ_ಠ 
09:41:15 <jle`> are you suggesting libraries warn users, "you might not need this library"? :P
09:41:35 <Zekka|Sigfig> jle`: I think it’s valid to say that!
09:41:43 <jle`> i feel like almost every library would have this warning then :O
09:41:44 <jle`> except for base
09:41:50 <quchen> jle`: And pipes!
09:41:56 <orion> Pipes are amazing.
09:41:58 <quchen> And Shake!
09:42:07 <Zekka|Sigfig> Let’s say there’s an interchange format called “JSON But From Hell” — it’s like json but a million times worse in every way
09:42:13 <quchen> And lots of others I don't remember right now. But there are many with good docs as well.
09:42:19 <Zekka|Sigfig> But it also supports *sets* instead of arrays, oh my gosh!!!
09:42:19 <jle`> there is a nonzero possibility that you might not need pipes
09:42:27 <hackrilege> when i investigate a library to see if i want to use it, i need to be able to understand the documentation
09:42:31 <jle`> oh, you're referring to audience-aware documentation
09:42:35 <jle`> yeah, pipes is great :)
09:42:44 <hackrilege> with lens it literally took me 2 months to understand why i didnt need it
09:42:47 <bite> Hello
09:42:50 <Zekka|Sigfig> As the author of “JSON But From Hell” it would be my duty to encourage people not to use it and explain that I only wrote my library because I needed to interoperate with someone else’s system
09:42:55 <bite> I'm looking for friends
09:43:03 <jle`> we can be your haskell friends :)
09:43:06 <mnoonan> Maybe some small examples to show intended use (also acting as a "do I need to use this?" filter?)
09:43:17 <Zekka|Sigfig> (incidentally “JSON But From Hell” is a thinly veiled analogy for XML)
09:43:21 <bite> You're nice
09:43:28 <dmj> bite: haskell can do that
09:43:33 <hackrilege> if you cant explain to me what your library does...
09:43:36 <quchen> mnoonan: Gabriel Gonzalez has a nice lens tutorial module (that wasn't merged into lens for reasons)
09:43:43 <p`> hi guys is python better than haskell
09:43:51 <quchen> mnoonan: Since he's the king of Haskell documentation, have a look at it :-)
09:43:53 <bite> How do I make an operator infix?
09:44:06 <hackrilege> surround it with parenthesis
09:44:14 <glguy> No, that makes it "prefix"
09:44:17 <mnoonan> I think lens might be exceptional in this discussion, but I will :)
09:44:18 <jle`> operators are by default infix
09:44:21 <geekosaur> bite, in what sense? you can use a alphanumeric function as infix by wrapping in ``
09:44:24 <hackrilege> oh, oops
09:44:27 <bite> It doesn't work
09:44:28 <Zekka|Sigfig> p`: It’s probably easier to write a lot of quick and dirty apps in Python for stuff like web scraping, etc
09:44:29 <geekosaur> you cannot declare one to always be infix
09:44:29 <bite> Oh ok
09:44:36 <quchen> > 1 `elem` [1,2,3,4]
09:44:38 <lambdabot>  True
09:44:44 <bite> Like  `kiss`?
09:44:44 <kadoban> p`: Probably not really a useful question. Languages tend to be better in certain areas, worse in others.
09:44:46 <hackrilege> no way, web scraping in haskell is the easyes
09:44:53 <quchen> Peyton `Simon` Jones
09:44:56 <kadoban> p`: Learn a few of them, see what they're good at, see what they're not.
09:45:10 <Zekka|Sigfig> But IMHO Python is way more prone to throwing unanticipated errors in common usecases like manipulating unicode text, so even for quick-and-dirty apps I tend to av oid it
09:45:16 <bite> Is Moran here?
09:45:19 <jle`> p`: i'm not sure if "better" is a word you can use meaningfully here.  they're both good in their own ways
09:45:22 <bite> Miran
09:45:24 <Zekka|Sigfig> (I hear py3 fixes a lot of this)
09:45:43 <hackrilege> less talk about python please
09:46:49 <mnoonan> what about some sick python from a Haskeller? http://dev.stephendiehl.com/numpile/
09:47:07 <p`> ok thank you all you guys seem to be more experienced bye
09:47:17 <kadoban> Odd
09:47:22 <Zekka|Sigfig> I guess now he has his answer
09:47:47 <quchen> This very conversation happence at least once a week.
09:47:58 <quchen> s/ce/s/
09:48:06 <bite> Where is Poochie?
09:48:18 <Welkin> who is poochie?
09:48:35 <Welkin> bite, the cousin of bitemyapp 
09:49:04 <bite> https://simpsonswiki.com/wiki/File:Poochie.png
09:49:43 <glguy> bite: This channel is specifically for discussion about Haskell programming
09:50:00 <bite> Ah ok sorry
09:50:05 <isd> Is there a module somewhere that provides access to the contsants in limits.h? I'm specifically interested in PATH_MAX.
09:50:09 <bite> I was on the wrong tab
09:50:18 <Zekka|Sigfig> bite: #haskell-blah is a little more off-topic of course
09:50:41 <Welkin> Zekka|Sigfig: you traitor
09:50:42 <bite> Thank you
09:55:16 <hackrilege> trolls...
09:57:12 <hackrilege> do we have a resuorce for cannoncaly orderings of patterns such as (.).(.)?
09:57:22 <hackrilege> :t (.).(.)
09:57:24 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:58:02 <hackrilege> or classes of simple resucrsion schemes?
09:59:13 <quchen> hackrilege: If you understand the (r ->) Functor, then the boobs operator is simply fmap.fmap
09:59:37 <hackrilege> i think normally its called the tripple nipple
10:00:26 <hackrilege> there are lots of ways to flip and reuse arguments. many cases i cant write pointfree
10:00:50 <glguy> In those cases you shouldn't write things point free
10:01:00 <hackrilege> sometimes pointfree is nesacary like when trying to use >>= rather than a do block
10:01:26 <hackrilege> i guess thats why they introduced the do block
10:01:29 <glguy> If a do block is needed you should sue it
10:01:30 <glguy> use it
10:01:36 <glguy> point free isn't the goal
10:01:54 <hackrilege> says who?
10:02:05 <hackrilege> i mean, specifically, its my goal
10:02:18 <hackrilege> thats actually exactly what i was asking about...
10:02:23 <Denommus> quchen: ... that simplifies a lot (.)
10:02:30 <Denommus> quchen: any (.) composition, in fact
10:02:52 <lpaste_> lysgaard pasted “Is it possible to traverse a tree using Lenses?” at http://lpaste.net/145577
10:02:56 <hackrilege> "how do i" - "dont"
10:03:03 <Denommus> quchen: (but treating functions as functors is usually very unreadable)
10:03:16 <glguy> You asked if there was a canonical source for code obfuscation operations. I don't think there is
10:03:22 <hackrilege> ok thanks
10:03:31 <hackrilege> what about recursion schemes?
10:04:23 <glguy> lysgaard: Have you seen this module? http://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Plated.html
10:04:54 <glguy> lysgaard: This module has a lot of tools for working with recursive data-types like your Expr tree
10:07:28 <lysgaard> glguy: Yeah I have seen it, but I am struggeling with all the new concepts of lenses and plated. So currently I don't understand how I can acchieve what I want.
10:08:59 <lysgaard> glguy: Take the example `instance Plated Expr` in the documentation. I don't get what it does, for me it looks almost like `fmap`.
10:09:44 <glguy> There's a  lot of stuff written about it in the class definition. Is there a question about the text I could answer?
10:11:00 <augur> how can we characterize the difference between   data Nat = Zero | Suc Nat   and   data Tree = Leaf | Branch Tree Tree   given that they're isomorphic
10:11:38 <lysgaard> glguy: What does "A Plated type is one where we know how to extract its immediate self-similar children." mean? Specifically what defines a "self-similar children"?
10:11:49 <hackrilege> there exists a mapping between them, as there is a mapping between 1 and 2d indexes
10:12:15 <glguy> lysgaard: same type
10:12:21 <hackrilege> its countable, so its isomorphic to the ints
10:12:24 <lyxia> augur: isomorphic in what sense
10:12:40 <hackrilege> but a k tree is topalogically distinct from the natural numbers
10:12:46 <lysgaard> glguy: Ah, that makes sense :)
10:12:47 <augur> lyxia: in the usual sense :)
10:13:01 <lpaste_> glguy annotated “Is it possible to traverse a tree using Lenses?” with “Is it possible to traverse a tree using Lenses? (annotation)” at http://lpaste.net/145577#a145579
10:13:24 <augur> lyxia: there's a function   f :: Nat -> Tree   and   g :: Tree -> Nat   such that   f.g = id   and   g.f = id
10:13:26 <dmj> isItPossibleWithLenses = const True
10:13:28 <glguy> lysgaard: Here's the shortest way to do what you wanted. You can use the SYB appraoch via the DAta typeclass
10:13:37 <hackrilege> like i say, there exists a mapping from the natural numbers, thats the isomorphism, its a bijection between both sets, any will do, saying there exists a bijection to the natural numbers is the same is saying its countable, or isomorphic to the natural numbers
10:14:09 <augur> hackrilege: elaborate on the topological distinctions you envision?
10:14:09 <mnoonan> "isomorphic" implies more structure than you probably indend.
10:14:13 * hackagebot exact-real 0.8.0.0 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.8.0.0 (jophish)
10:14:25 <hackrilege> its branched
10:14:31 <augur> mnoonan: it implies exactly the structure i intend!
10:14:45 <lyxia> haha
10:14:53 <hackrilege> each ellement has more than 2 neighbours unlike the natural numbers
10:15:05 <hackrilege> that sufficient?
10:15:24 <augur> hackrilege: ok but what are we talking about besides saying "well look, there's two daughter nodes inside branches!"
10:15:36 <hackrilege> thats all we are saying
10:15:58 <hackrilege> there isnt much to go off with just those 2 data structure definitions, thats about the only difference
10:16:08 <augur> because in some sense that just means that i there's a function   b :: (Tree,Tree) -> Tree   and   unB :: Tree -> Maybe (Tree,Tree)   with relevant properties
10:16:16 <augur> but thats entirely true of Nat as well
10:17:00 <hackrilege> you can order all tuples, they are countable. but they are distinct from the natural numbers, the opperations which transform them into each other are more varied than pluss and multiply over the natural numbers
10:17:03 <lyxia> if you stop ignoring bottoms something might break
10:17:27 <lyxia> what about infinite trees
10:17:45 <augur> lyxia: forget bottom, strict semantics only :)
10:18:00 <lyxia> Pfff
10:18:01 <augur> hackrilege: except any operation on one can be turned into an operation on the other b/c of the isomorphism
10:18:06 <hackrilege> data Tree a = Leaf a | [Tree a]
10:18:18 <lysgaard> glguy: Wooh, that is quite magical. Where is the template function from?
10:18:19 <lyxia> Agda programmers...
10:18:29 <augur> lyxia: no!
10:18:39 <augur> lyxia: just  {-# LANGUAGE Strict #-}  programmers :)
10:19:05 <glguy> lysgaard: Data.Data.Lens
10:19:18 <hackrilege> hmm, so you say to be distinct there has to be a pole, or a torus or some such. im not great at topology tbh
10:19:43 <augur> hackrilege: im not saying anything like that
10:19:43 <shachaf> If data-lens had a similar library, it would be in Data.Lens.Data.
10:20:04 <hackrilege> ok, well thats as best as i can do...
10:20:05 <augur> im just saying they're iso, so talking about what operations exist wont work
10:20:14 <hackrilege> kk
10:20:24 <hackrilege> i just thought about dot with vectors
10:20:38 <hackrilege> its like a different grop opperator for the inner product
10:20:43 <hackrilege> group
10:20:52 <lyxia> augur: how about counting the number of bytes to write an addition function
10:21:34 <hackrilege> ok what about this, the size opperation acting on the natural numbers is not degenerate, but for vectors it is
10:22:24 <hackrilege> so in this example, depth down the binary tree would be the same for many nodes
10:22:34 <hackrilege> unlike the natural numbers
10:23:22 <hackrilege> to make the isomporphism you have to introduce a new type of metric keeping track of the left right path down branches
10:23:35 <augur> hackrilege: if you give me any function on Nat's, i can turn it into a function on an isomorphic type
10:23:58 <hackrilege> true, but im saying you have to introduce a new metric
10:24:13 <hackrilege> left right path makes little sense in Nats
10:24:36 <augur> i dont know what that means
10:25:29 <augur> if A and B are isomorphic types by   iso :: A -> B   and you have a function  f :: B -> C   then i can simply compose  f.iso :: A -> C   to get the equivalent on A
10:26:05 <hackrilege> tree === int, however (size inta) /= (size intb) => (f inta) /= (f intb), however (size veca) /= (size vecb) /=> (f veca) /= (f vecb)
10:26:18 <hackrilege> see
10:26:21 <hackrilege> ?
10:26:32 <johannes__> hi there. I'm stuck with homework. I have boiled down the problem to the fact that I'm unable to write a function that takes a string as an argument and returns it. Something like this: http://piratepad.net/2N1SPLrZFQ it works with lists containing one char (ret ['a']), but I get an error with a larger string (ret ['a','b']) ("Non-exhaustive patterns in function"). I must be misunderstanding something fundamentally... I'd be thank
10:26:36 <augur> i dont know what that means, hackrilege
10:27:15 <trix> johannes__: you're matching on a list with one thing in it
10:27:26 <mnoonan> hackrilege: Like I said, you're assuming there is some kind of structure that functions are supposed to be preserving; augur isn't. So you're stuck (by these rules).
10:27:30 <hackrilege> . /=> reads as "does not imply that"
10:27:32 <johannes__> ain't I just returning it?
10:27:35 <glguy> johannes__: the pattern  [c]   matches lists with one element and names that element   c
10:27:35 <trix> johannes__: pattern matching syntax for lists isn't the same as the type signature
10:27:47 <glguy> [c,d] matches lists with two elements
10:27:52 <augur> mnoonan: if there's some extra notion of structure that one could use, i'd be curious to know what it is
10:27:55 <trix> johannes__: you need `ret xs = xs` to match the entire list
10:28:08 <mnoonan> the constructors, for one thing
10:28:13 <hackrilege> yeh
10:28:14 <augur> mnoonan: im not saying there can't be, but it's not clear to me what it could be given the isomorphism
10:28:23 <augur> mnoonan: "constructors"
10:28:28 <johannes__> trixtrix, glguy I think I get it. I'll try it out...
10:28:48 <mnoonan> by that, I guess I mean to define those types as F-algebras.
10:28:53 <augur> mnoonan: i forgot to tell you that secretly, i implement the constructors for Tree by using the isomorphism :)
10:29:20 <lysgaard> glguy: This is really cool. Ok, let's say I would like to traverse all Ids in an Expr, but also output the depth of the Id in the Expr-tree. Would that be possible in an easy manner?
10:29:31 <mnoonan> the problem is the other way: you can't implement your isomorphism as an isomorphism between F-algebras
10:30:03 <lysgaard> glguy: Something with the type `idsWithDepth :: Expr -> [(Id,Int)]`
10:30:15 <augur> mnoonan: thats true, the F-algebras arent isomorphic
10:30:35 <augur> NatF X = 1 + X    TreeF X = 1 + X*X
10:30:51 <mnoonan> so as F-algebras, Nats != Tree != (Tree, Tree) != ... (but obviously Tree == Tree^7)
10:31:06 <johannes__> trix, glguy, I understand. I wasn't picking up the list, I was doing a match on it... thank you!
10:31:27 <trix> johannes__: np
10:31:28 <augur> mnoonan: ahh yeah i vaguely recall some blogpost about  Tree == Tree^7
10:31:29 <augur> where was that
10:32:10 <mnoonan> "7 trees in one" paper: http://arxiv.org/abs/math/9405205
10:32:44 <mnoonan> there are some on the n-category cafe, too
10:33:58 <hackrilege> all languages are turing equivilant to a turing machine opperating on a 1d tape...
10:34:31 <trix> johannes__: alternatively you could do `ret = id`
10:34:35 <hackrilege> there are the load balanced trees of Data.Map
10:35:13 <augur> mnoonan: one thing ive considered as relevant to the distinction is that for Tree, the case view function   viewTree :: Tree -> Maybe (Tree,Tree)   is O(1) while for the Nat version, it's i think more complex
10:35:47 <augur> but i dont like operational notions like that :\
10:35:56 <hackrilege> http://dl.acm.org/citation.cfm?id=804906
10:35:58 <Cale> mnoonan: I love the coin-game proof of that result
10:36:28 <mnoonan> augur: I wonder if the operational notion could be connected to the F-algebra view. It seems like you'd be counting constructors and pattern matches, yeah?
10:36:51 <mnoonan> Cale: agreed!
10:36:57 <augur> http://blog.sigfpe.com/2007/09/arboreal-isomorphisms-from-nuclear.html
10:37:07 <augur> is that the coin-game one, Cale?
10:37:53 <Cale> yeah... I used to have a nice diagram of a shortest solution
10:37:56 <augur> mnoonan: to do the iso? maybe. its a kind of gross iso, tbh
10:37:58 <Cale> Let's see if I can dig it up
10:38:34 <Cale> no :(
10:38:44 <augur> my main curiosity about this is that it **feels** like the space of, say, Nat, vs (Nat,Nat), vs Tree  have different structures, and in particular, the first two have *dimensional* structure while the second doesnt
10:38:56 <Cale> The link looks like it's a link to my old share directory on the machine whose hard drive died
10:39:24 <augur> which i suppose means i should probably be considering orderings as well
10:39:50 <augur> but even on their own it seems like it ought to be possible to see them as substantively different
10:40:29 <augur> hackrilege's intuition that trees have a certain *structure* is exactly what i want to be able to conclude, but it's not clear to me how that really ought to be true
10:41:28 <augur> and i think the isomorphism means they both have the same induction principles?
10:42:08 <augur> NatInd : (P : Nat -> Set) -> P zero -> ((n : Nat) -> P n -> P (suc n)) -> (m : Nat) -> P m
10:43:46 <augur> NatInd' : (P : Nat -> Set) -> P (treeToNat pseudoZero) -> ((t : Tree) -> P (treeToNat t) -> P (treeToNat (pseudoSuc t))) -> (r : Tree) -> P (treeToNat r)
10:44:14 <augur> i _think_ that will definitely exist, because of the iso, and the converse TreeInd as well
10:44:24 <augur> so saying something about induction principles probably also wont work so well?
10:48:14 <hackrilege> is this what your after? https://en.wikipedia.org/wiki/Cardinality
10:48:28 <augur> no, the cardinality of both sets is the same :P
10:49:21 <mnoonan> since we're talking about programs, I assume your iso isn't a ZFC set kind of function. What category are you programming in?
10:49:31 <hackrilege> no
10:49:34 <hackrilege> "Cantor introduced the cardinal numbers, and showed that (according to his bijection-based definition of size) some infinite sets are greater than others. The smallest infinite cardinality is that of the natural numbers (\aleph_0)."
10:50:05 <hackrilege> the cardinality of both sets is different
10:50:37 <augur> hackrilege: no they're not. both have cardinality aleph_0 precisely because they're isomorphic
10:50:59 <hackrilege> no
10:50:59 <augur> just like |N and |N*|N are both cardinality aleph_0
10:51:02 <augur> yes hackrilege
10:51:11 <hackrilege> .... *cries*
10:51:13 <augur> this is how cardinality works
10:51:37 <hackrilege> so how do we get biger infinities with greater cardinallity?
10:51:48 <augur> hackrilege: the classic example of that is |N vs |R
10:52:02 <augur> |N and |R have different cardinalities because there is no bijection between them and yet both are infinite
10:52:06 <hackrilege> or N and (N*N)
10:52:09 <augur> no
10:52:13 <Denommus> could you guys criticize my code? https://github.com/Denommus/MtgCardsBot
10:52:14 <Zekka|Sigfig> hackrilege: I have a fun challenge for you!
10:52:16 <augur> there is a bijection between N and N*N
10:52:29 <hackrilege> there is a bijection between N and R
10:52:34 <Zekka|Sigfig> Find a mapping that can get me a natural number from any arbitrary real number
10:52:42 <Zekka|Sigfig> (and back)
10:52:45 <hackrilege> just keep deviding by 2
10:52:50 <hackrilege> next
10:52:59 <Denommus> I'm wondering whether I made a good decision on using a Reader everywhere instead of passing the environment explicitly to the functions that need it
10:53:02 <Zekka|Sigfig> hackrilege: Can you state that a little precisely?
10:53:05 <Zekka|Sigfig> a little more precisely*
10:53:13 <augur> hackrilege: nope! doesnt work
10:53:21 <Zekka|Sigfig> If I start with 8, I can’t get to pi by doing that
10:53:29 <Zekka|Sigfig> and if I start with pi I certainly can’t get to 8 by doubling it
10:53:34 <augur> hackrilege: you may be thinking of N and Q, where Q is the rational numbers
10:53:43 <Zekka|Sigfig> or, well, to any natural number
10:53:43 <hackrilege> no
10:53:45 <augur> but R is the set of REALS and there's no iso between R and N
10:54:13 <Freundlich> Instead of R you can also think of all total functions N -> N
10:54:13 <Zekka|Sigfig> If you keep doubling pi you will still have plenty of decimal places left to go no matter how many times you do it
10:54:19 <augur> hackrilege: you might want to read the page you linked to , since it discusses all of these examples :)
10:54:21 <Freundlich> Maybe that is more intuitive.
10:54:38 <hackrilege> e^int
10:55:06 <augur> mnoonan: back to your question
10:55:16 <Freundlich> N*N are just pairs of natural numbers while a function N -> N needs to map infinitely many N, so one object of this domain is a "lot more complicated" than a simple pair.
10:55:54 <Zekka|Sigfig> A function N -> N is a set containing an infinite number of NxN pairs, right?
10:55:55 <hackrilege> f(eZ) = sum (n in Z) sin (n*ez)
10:55:55 <augur> mnoonan: the isomorphism doesnt really matter, but there's a relatively canonical enumeration of the trees that can give you the iso
10:56:12 <Zekka|Sigfig> Specifically, it has a pair for every N that can go on the left side?
10:57:01 <Freundlich> Zekka|Sigfig: Yes.
10:57:44 <hackrilege> god damnit R is not countable
10:57:57 <augur> hackrilege: no, it's not
10:58:01 <hackrilege> argh
10:58:09 <hackrilege> that was a trick question
10:58:23 <hackrilege> id have thought you would at least give me a countable set, this example proves nothing!!
10:58:30 <hackrilege> we are considering countable things here
10:58:34 <c_wraith> That's OK. You can count all the useful values in R. :) 
10:58:42 <hackrilege> ...
10:58:46 <hackrilege> you mean Q
10:59:01 <monochrom> you can reject all uncomputable reals. then you have a countable set remaining.
10:59:16 <monochrom> and a few philosophers seriously do that.
10:59:38 <shachaf> I've never seen an uncomputable real.
10:59:41 <c_wraith> No, I mean if you define "useful" as "values ever used in a computation", then that set is countable. 
10:59:41 <hackrilege> uncomputable!? cool
10:59:56 <augur> hackrilege: who's considering countable things?
11:00:00 <hackrilege> i guess you would need to order the generating opperations
11:00:09 <mnoonan> augur: I wonder about that, though.. say you are working in a total language. Can you actually implement that enumeration and prove the result is total?
11:00:31 <patt> Hey people, I am having a "non-exhaustive pattern" error, could anyone, please, take a look? Thanks! :) http://lpaste.net/145582
11:00:32 <hackrilege> augur the original question was to distinguish between the set of all tuples and the natural numbers, i surgest they have differing cardinality
11:01:01 <hackrilege> they are certainly both countable, R was a real distraction
11:01:07 <monochrom> patt: which function?
11:01:21 <patt> auxCoorDots
11:01:30 <augur> mnoonan: i believe so. its a good question tho
11:01:39 <augur> hackrilege: they dont have different cardinalities.
11:01:46 <hackrilege> normally it means the data type can attain a value you have not pattern matched for patt
11:01:48 <monochrom> ok, I guess you're missing "auxCoorDots npontos [] l c = ???"
11:02:23 <patt> monochrom let me test :)
11:02:41 <Hijiri> hackrilege: I'm taking an RA class right now, and there's a theorem that countable union of countable sets are countable
11:02:56 <Hijiri> so th set of all tuples would be countable (and thus have the same cardinality)
11:03:06 <hackrilege> what about this? https://en.wikipedia.org/wiki/Order_type
11:03:34 <hackrilege> all countable things have the same cardinallity?
11:03:45 <nmeum> Hey, Int derives from the Num type class, right? So basically everywhere where I can return a Num I should be able to return an Int too, right? This somehow doesn't seem to be the case in this small example http://sprunge.us/cHSA why is that?
11:03:49 <hackrilege> i didnt think that was the case..
11:03:52 <monochrom> all infinite countable things have the same cardinality
11:04:13 <Hijiri> hackrilege: the definition of countability is that you can have a bijection between them and the naturals
11:04:17 <hackrilege> so what distinguishes tuples and nats?
11:04:25 <Hijiri> the intuition of "countable" is you can eventually get to any value, if you count high enough
11:04:35 <hackrilege> i know what is countable, it seems i wanst sure what was cardinal
11:04:41 <monochrom> cardinality isn't meant to distinguish N from NxN
11:04:48 <hackrilege> what does though?
11:04:58 <Zekka|Sigfig> hackrilege: You can write any tuple as a natural number and vice versa, being clear
11:05:00 <monochrom> just as body weight is not meant to distinguish you from me
11:05:02 <Zekka|Sigfig> just ask Cantor
11:05:21 <hackrilege> i rang huim but he just said wazzzzzzaaaaaaa for ages
11:05:25 <monochrom> set equality distinguishes N from NxN
11:05:35 <monochrom> just as personal identity distinguishes you from me
11:05:37 <augur> hackrilege: what distinguishes them is precisely the point of the question :)
11:05:54 <Zekka|Sigfig> You could probably prove a lot of things for ’N’ that you could prove for ‘NxN’ if you filter in huge amounts of pointless math verbiage
11:05:59 <hackrilege> "set equality", this is our answer, whoever was asking
11:06:03 <monochrom> identity theft is how you can make you indistinguishable from me
11:06:06 <patt> nah, doesn't work. Now it is giving me a wrong answer so it must be another problem with my function.
11:06:12 <augur> monochrom: <3
11:06:22 <monochrom> fortunately, there is no set equality theft.
11:06:31 <hackrilege> lol
11:07:11 <monochrom> but set bijection gets really close
11:07:25 <hackrilege> "i think that set is wearing a fake moustache"
11:08:26 <augur> monochrom: im really tempted to say that there's something inherently computational in the difference between Nat and Tree
11:09:13 <augur> that feels like the only thing that makes sense as a reliable way to distinguish isomorphic sets -- what computations they make easy vs which they make hard
11:09:26 <hackrilege> set equality just requires both sets contain each other...
11:09:32 <nmeum> Hey, Int is an instance of the Num type class, right? So basically everywhere where I can return a Num I should be able to return an Int too, right? This somehow doesn't seem to be the case in this small example http://sprunge.us/cHSA why is that?
11:09:48 <augur> nmeum: no
11:09:49 <Cale> mnoonan, augur: A couple proofs: http://i.imgur.com/l8qhs61.png
11:09:57 <augur> nmeum: everywhere you need a Num, you can supply an Int
11:10:07 <augur> nmeum: and everywhere you return an Int, its ok to return a Num
11:10:26 <hackrilege> supplying a Double to a function asking for an Int isnt going to work even thought they are both Nums
11:10:28 <nmeum> augur: but I cannot return an Int where a Num is expected?
11:10:34 <augur> nmeum: right!
11:10:36 <carglass-rep> hi
11:11:03 <hackrilege> hi
11:11:29 <nmeum> augur: but why is this the case? Seems very confusing to me…
11:11:40 <tzh> nmeum: specifically, a `Num a => a` value doesn't mean "any type in Num", it means "potentially every type in Num"
11:12:17 <hackrilege> a num is something with some opperations like + over them. ints cannot be devided. fractional things can. but they can both be multiplied, or retrieved from an Int, so theyhave Num instances
11:12:27 <augur> nmeum: because Num isnt a type, its a constraint, so your subtyping intuitions dont work like you expect
11:12:33 <tzh> nmeum: so if you're returning a value in Num it has to be polymorphic: maybe Int, maybe Integer, maybe Float, etc etc for any possible type instanced to Num
11:12:46 <nmeum> yeah, got it now
11:12:47 <nmeum> thank
11:12:48 <nmeum> s
11:13:03 <augur> nmeum: Num a => ... -> a   isnt saying you're return some Num or other, but rather it's saying for any choice of a, provided a is a Num, you can give back an a
11:13:13 <hackrilege> "i asked for an  Int, not a Double" - "oh, sorry i thought you just wanted any Num"
11:13:30 <augur> nmeum: so if i pick a = Real, you cant return an Int because Int's arent Real's
11:13:44 <hackrilege> :t sum
11:13:45 <nmeum> yeah
11:13:46 <lambdabot> (Num a, Foldable t) => t a -> a
11:13:56 <augur> noooo foldable D:
11:13:59 <augur> dreadful
11:14:09 <monochrom> Num a => [a] -> a
11:14:09 <augur> Cale: pretty :)
11:14:51 <hackrilege> :t (+1)
11:14:52 <lambdabot> Num a => a -> a
11:15:23 <hackrilege> :t floor
11:15:24 <lambdabot> (Integral b, RealFrac a) => a -> b
11:15:30 <hackrilege> erg...
11:16:25 <Cale> mnoonan, augur: Could there be a proof which avoids ever stacking two coins (i.e. one in which the coefficients of all the polynomials are only ever 0 or 1)?
11:16:26 <monochrom> because floor wants you to use it like floor (5.4 :: Double) :: Int
11:16:36 <augur> Cale: ahh you know, the phrase "natural isomorphism" comes up in discussions on 7Ti1, and thats probably the important thing there
11:16:53 <augur> that might be why T ~ N is not so interesting
11:17:11 <augur> but, T ~ T^7 is still missing the distinctions in some sense
11:17:12 <augur> anyway
11:17:24 <augur> i should keep reading these just to get the intuitions
11:17:38 <Cale> I feel like the answer is probably "no", but I'm not sure how to approach proving that.
11:18:01 <hackrilege> obviously we can reorder sets to make strange accessor generators, which are basically orderings. i think we have a unique ordering and thats about it
11:18:06 <monochrom> what is T again? set of binary trees?
11:18:10 <Cale> yeah
11:18:36 <hackrilege> convert the int to binary, this is the left right path of your binary tree
11:18:44 <Cale> and T is in bijection with 1 + T^2, because every tree is either the empty tree, or it is a root with two subtrees
11:19:12 <hackrilege> i think the natural number are more of a linked list though
11:19:22 <hackrilege> they have succ and pred defined
11:19:29 <monochrom> bijection is usually unhelpful because it can violate all kinds of properties you subjective (and rightfully) want to preserve.
11:19:34 <hackrilege> but tree nodes may have arbritrary neighbours
11:19:55 <Cale> Well, this bijection actually preserves lots of stuff. :)
11:19:58 <monochrom> when you look at N you also have in mind an order e.g. 0 < 1 < 2...
11:19:58 <hackrilege> basically it flattens the tree
11:20:37 <augur> monochrom: orderings are somewhat arbitrary tho
11:20:39 <monochrom> and when you look at T you also have in mind some kind of prefix order or subtree order
11:20:48 <hackrilege> yeh, but there is a second dimensionality to our ordering labels. we must be able to say e.g. (1,0) > (0,1)
11:20:58 <augur> i mean, there are some orderings which are "natural" to us humans, but of course, math
11:21:05 <augur> Cale: what does it preserve??
11:21:06 <hackrilege> despite size (1,0) = size (0,1)
11:21:25 <augur> hackrilege: i dont know what this size nonsense is that you're talking about
11:21:27 <hackrilege> we do not order by size but by accessor chain
11:21:40 <augur> hackrilege: we can order by whatever we want
11:22:04 <Cale> augur: Well, it's additively weight preserving: if the weight of a tree is the number of vertices it has, and the weight of a tuple is the sum of the weights of its elements, then these bijections preserve weight.
11:22:13 <hackrilege> augur, size nonsense!? its how we order the ints, but not how we order tuples, it captures our destinction
11:22:23 <Cale> augur: So, the generating series for T will be the same as the generating series for T^7
11:22:58 <Cale> (with respect to this additive definition of weight)
11:22:59 <hackrilege> im saying the ints are ordered by size, the tuples CANNOT be
11:23:11 <augur> hackrilege: sure they can, fsvo "size"
11:23:18 <hackrilege> the additional ordering requisit is the destinction in my mind
11:23:27 <augur> sizeOfTuple t = sizeOfInt (iso t)
11:23:59 <hackrilege> size defined in terms of vector dot product ala pythagorus
11:24:17 * hackagebot wai-app-static 3.1.3 - WAI application for static serving  https://hackage.haskell.org/package/wai-app-static-3.1.3 (MichaelSnoyman)
11:24:19 * hackagebot generic-xmlpickler 0.1.0.4 - Generic generation of HXT XmlPickler instances using GHC Generics.  https://hackage.haskell.org/package/generic-xmlpickler-0.1.0.4 (AdamBergmark)
11:24:22 <hackrilege> its the inner product of the vector space
11:24:38 <augur> hackrilege: you can pick arbitrary functions to make the argument "work" but i can reject so arbitrary choices
11:24:46 <hackrilege> its a degenerate mapping from the vectors to the real numbers
11:25:00 <hackrilege> because of this degeneracy we require an additional label
11:26:19 <hackrilege> i cant say, keep going in the x direction, as i will never stop and start to count the vectors of y component >0
11:26:53 <hackrilege> so the counting proceadure takes the trivial metric and then breaks the degeneracy with an additional label
11:28:27 <hackrilege> also, since the proceadure is systematic, there are fewer of these than permutations on the set
11:28:52 <bennofs> Is there a way to get GHC to stream-fusion a list comprehension? It seems that right now, "[Arrow d c | d <- allDirections, c <- [False,True]]
11:28:58 <bennofs> does not fuse with a foldl'
11:29:07 <bennofs> (with GHC 7.10)
11:30:08 <hackrilege> there would be as many "distinct" subsets of a countable set of a particular property as there are permutations with a particular symmetry.
11:31:00 <hackrilege> e.g. binary trees are symetric under left right swap.
11:31:42 <hackrilege> no such symetry exists over the natural numbers
11:32:18 <hackrilege> as its contents have a gcd of 1
11:32:48 <hackrilege> i guess thats enough spam...
11:40:07 <indigo945> Couldn't match type `Identity'
11:40:07 <indigo945>                   with `transformers-0.3.0.0:Data.Functor.Identity.Identity'
11:40:07 <indigo945>     When using functional dependencies...
11:40:11 <indigo945> They're the same type
11:40:16 <indigo945> Has anybody had that problem before?
11:40:45 <monochrom> that sounds like you possess two versions of transformers and both are used
11:41:09 <monochrom> get rid of the one that did not come with GHC
11:41:49 <indigo945> I'll try, thanks
11:42:50 <indigo945> meh, if I try ghc-pkg unregister I get warnings about a myriad of packages that would be broken
11:43:04 <monochrom> get rid of them, too
11:43:09 <indigo945> :/
11:43:28 <monochrom> rebuild them but make sure they use the transformer that comes with GHC
11:43:52 <bergmark> indigo945: i'm guessing you aren't using a sandbox? they exist for a reason :-)
11:43:58 <monochrom> because if you allow two versions to live together, you will run into the same problem later again
11:44:14 <monochrom> sandbox will not help because transformers comes with GHC therefore global
11:44:30 <monochrom> sandbox cannot possible shield global packages. base is there.
11:44:34 <bergmark> now i remember i never used cabal sandboxes for anything serious
11:44:36 <indigo945> is there a way of automatically rebuilding all those packages?
11:44:38 <bergmark> long live cabal-dev
11:45:32 <hexagoxel> i thought a sandbox would at least ensure that only one version of a package was visible at a time.
11:48:09 <hexagoxel> so they _would_ help. but i am not completely certain atm.
11:51:34 <monochrom> I think that is called "freezing" instead
11:51:36 <indigo945> when I try to reinstall netwire 4, it just asks for transformer-0.3 again
11:52:07 <hexagoxel> monochrom: no, i was not thinking of that
11:53:14 <bitemyapp> glguy: what's the IRC channel for the client?
11:53:25 <bitemyapp> glguy: I logged out in glirc (socket error) and forgot it.
11:53:35 <geekosaur> hexagoxel, ghc can't really ensure that sensibly. stack does it... by beating ghc over the head (basically building its own "global" package db and forcing ghc to use that, which is actually somewhat difficult in non-recent ghc)
11:59:09 <dolio> cabal sandboxes do not allow you to have two versions of the same package installed. So they would prevent you from installing two versions of transformers, and since you presumably aren't going to remove the global one, it would prevent installing a second copy of transformers, I believe.
11:59:36 <dolio> That is probably what hexagoxel is talking about.
11:59:45 <hexagoxel> but cabal should still choose a consistent set, even if ghc can see more.
12:00:34 <indigo945> the problem appears to be that netwire 4 expects Identity to be in Control.Functor.Identity, but in recent versions of transformers it resides in Data.Functor.Identity
12:00:35 <hexagoxel> no wait, the same sandbox can have two versions of the same sandbox -for the same ghc version- installed without a problem
12:00:43 <indigo945> so I kind of need the old version for it to compile
12:01:56 <hexagoxel> dolio: only when configuring (looking up the actual set passed explicitly to ghc) it only accepts a consistent one.
12:02:33 <Xack> \o
12:03:53 <happyfeet> how can I make a "getChar" do an action automatically and do not wait for the 'enter'
12:04:11 <monochrom> netwire 5 doesn't request transformers 0.3
12:04:18 * hackagebot exact-real 0.8.0.2 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.8.0.2 (jophish)
12:04:20 * hackagebot shellmate 0.2.1 - Simple interface for shell scripting in Haskell.  https://hackage.haskell.org/package/shellmate-0.2.1 (AntonEkblad)
12:05:10 <hexagoxel> i still wonder how you manage to actually use two versions of a package if in a sandbox
12:06:03 <Xack> currently fiddling with shake and right now and am wondering why https://gist.github.com/zackp30/469234db1c83b3ef65a3 (error included) is happening
12:06:08 <Xack> very new to haskell :)
12:06:17 <geekosaur> in general, you don't. and you can't, notbecause of the sandbox but because you'll run into link time conflicts
12:06:22 <geekosaur> multiply defined symbols
12:09:37 <hexagoxel> geekosaur: yeah, i mean how to reach a state where these error can occur :)
12:09:58 <monochrom> happyfeet: before I answer, I want to know why: will this getChar stay as part of your UI in production? or will this getChar read from a file in production but right now you're just testing with console?
12:12:00 <lysgaard> glguy: I try using your suggested way of retrieveing the Ids of my Expr-tree, but when I do `answer return myExpr` it returns the top level expression that has an Id. I would like to have a list of all the Ids in the subtrees as well. Am I using `answer` the wrong way?
12:40:37 <circ-user-SSrdz> hey im relative new to haskell, do you know a nice example of a 2 Player console game written in haskell?
12:43:26 <maerwald> I want to write inline haskell in every language, so when someone tells me I should code stuff in php, I just do it in haskell instead and pretend it's php :D
12:52:08 <Denommus> servant's documentation generation is amazing
12:54:03 <augur> anyone interesting in program synthesis from examples? Cale maybe?
12:54:15 <augur> program induction, really
12:55:07 <mauke> http://blog.plover.com/prog/unfinished-projects.html twingler
12:55:21 <augur> mauke: o.o
12:56:14 <augur> mauke: who's that for
12:56:17 <mauke> you
12:56:37 <augur> oh :D
12:56:41 <augur> is that your page, mauke?
12:56:44 <monochrom> yeah, scroll down to the "twingler" section
12:56:54 <monochrom> no, it's Mark Dominus's
12:57:03 <augur> well how do i know mauke /= mark dominus? :P
12:57:13 <Clint> because
12:57:25 <monochrom> the same way I know Cale is not augur
12:57:40 <augur> yes but do you know whether augur =?= darryl mcadams?
12:57:51 <monochrom> it is not going to be 100% certainty if that's what you're looking for
12:58:04 <jle`> i cannot fathom a world where people have names different than their irc handles
12:58:22 <augur> jle`: if only!
12:58:26 <monochrom> who the hell is darryl mcadams anyway?
12:58:30 <augur> monochrom: :(
12:58:32 <augur> me!
12:58:43 <monochrom> ok, then I didn't know before, but now I know
12:58:46 * augur is sad
12:58:55 <mauke> jle`: whatever you say, mr. justice league of europe
12:58:59 <augur> according to some, i'm shoe guy on twitter
12:59:00 <augur> lol
12:59:05 <jle`> it's okay augur i knew you were darrel mcadams
12:59:18 <augur> jle`: im definitely not darrel mcadams that guys a poser
13:00:19 <mauke> augur: mark dominus has been seen online as mjd and yrnlry
13:00:38 <mauke> wait, that's wrong
13:00:46 <mauke> it's yrlnry
13:01:05 <mnoonan> What word or phrase would you use to describe the relationship between a constrained type scheme (say, Eq a => [a]) an a particular instance (say, [Int])?  Just "X instantiates Y"?
13:01:10 <monochrom> onoes, yrlnry sometimes come to this channel
13:01:55 <augur> mnoonan:   [Int]  is an instance of  Eq a => [a]
13:02:11 <jle`> wouldn't people say [Int] is an instance of Eq ?
13:02:21 <mnoonan> Normally yes, but I'm trying to write a caption :)
13:02:34 <jle`> (that was in reference to augur )
13:02:35 <monochrom> all of the above, plus: [Int] is a special case of Eq a => [a]
13:02:38 <jle`> i have seen instantiates before
13:02:42 <augur> jle`: that's also true :)
13:02:44 <dolio> Subtype.
13:02:50 <augur> instantiates might be a better way to say it, too
13:02:57 <monochrom> "subtype" is heretic here!
13:02:58 <mnoonan> so something more like "A foo, instantiating the type scheme in figure bar"
13:03:11 <augur> dolio: you mean   Eq a => [a]   is a subtype of   [Int]   
13:03:12 <augur> ?
13:03:51 <mnoonan> definitely can't say subtype, since that is used to mean something else in this paper.
13:03:52 <jle`> mnoonan: yeah, i'd say in that case that a is instantiated to Int, or specialized to Int
13:04:05 <augur> specialized is nice
13:04:14 <jle`> monomorphized
13:04:17 <augur> [Int]   is a specialization of   Eq a => [a]   is quite nice
13:04:21 <jle`> monomorphialization
13:04:46 <mnoonan> jle`: the obvious choice. doesn't quite fit the caption length, sadly.
13:04:58 <monochrom> monoization
13:05:05 <jle`> people often say that return :: a -> IO a, m specialized to IO
13:05:26 <mnoonan> "specializing" fits nicely, thanks!
13:27:05 <stoogenmeyer> hey guys, I'm trying to understand - in the following code snippet, if I continue giving the program strings, will I eventually reach a stack overflow? http://pastebin.com/mS5vjhX5
13:28:22 <jle`> stoogenmeyer: what makes you think so?
13:28:57 <jle`> haskell doesn't use a "callstack" like most other languages do
13:29:01 <stoogenmeyer> jle`: If it keeps recursing, don't previous function calls stay on the stack?
13:29:03 <stoogenmeyer> oh ok..
13:29:14 <stoogenmeyer> that's what I was wondering - so what happens in this case?
13:29:25 <jle`> it should be able to do all of this in constant space, if the GC does its job
13:29:46 <mauke> this isn't even a function call
13:29:50 <mauke> main isn't a function
13:31:38 <ChristianS> mauke: not?
13:31:54 <mauke> main :: IO ()
13:32:39 <xdmt0> @free fmap :: (a -> b) -> F a -> F b
13:32:39 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
13:33:18 <xdmt0> @free f :: (a -> x -> x) -> x -> x
13:33:19 <lambdabot> (forall x. h . k x = p (g x) . h) => h . f k = f p . h
13:35:16 <tzh> mauke: that seems to be conflating the mathematical sense of 'function' with the programmatic. certainly it's a bound name you can evaluate to perform operations, even if it doesn't take any arguments
13:35:29 <xdmt0> @free f :: (Int -> x -> x) -> x -> x
13:35:30 <lambdabot> (forall x. g . h x = k x . g) => g . f h = f k . g
13:36:33 <augur> tzh: the programmatic sense of function is something with the type  A -> B   for some A and B
13:36:57 <mauke> tzh: evaluating main does not perform operations
13:37:36 <tzh> augur: so in C would you say a function `void foo ()` is not _really_ a function?
13:38:36 <augur> tzh: it's risky to speak of C, but if i were forced to I would say that that has the corresponding type   foo :: () -> IO ()   in haskell
13:38:40 <augur> so it's definitely a function
13:38:46 <dolio> It probably isn't a function.
13:39:06 <augur> dolio: sure it is, you just need to use the right monadic semantics x3
13:39:06 <mauke> tzh: I would use the C meaning of "function", so it is one
13:39:19 <mauke> but in Haskell I talk about Haskell functions
13:39:27 <Zemyla> augur: Wouldn't it have the type IO () instead?
13:39:31 <augur> what mauke said
13:40:15 <augur> Zemyla: because it's not an IO action that's executed right away. you still have to call it. whereas   printf("Foo")   is an   IO ()
13:40:31 <augur> or whatever the C version is
13:40:54 <dolio> C has plenty of bad terminology choices, too, so referencing it probably won't win many favors.
13:41:01 <augur> that too
13:41:02 <tzh> i mean if you're saying anything with a -> in the type is a function, then i suppose main isn't a function, but that seems like a somewhat unusual definition given what "function" is generally meant to mean within programming languages, even if it holds strictly to what "function" means in math contexts
13:41:21 <mauke> tzh: there is no general meaning of "function" within programming languages
13:41:34 <mauke> it only appears that way because most languages are C
13:41:45 <eikke> tzh: main is a value of type IO () (which I often call 'action')
13:41:58 <augur> tzh: its exactly whats meant within programming languages, actually!
13:42:18 <mauke> augur: I disagree because IO () actions aren't executed right away either
13:42:22 <augur> tzh: modulo the fact that most PLs dont have types so you cant strictly talk about it, but
13:42:29 <augur> mauke: details details :)
13:42:52 <mauke> void foo(void); corresponds to foo :: IO () in Haskell
13:43:01 <mauke> printf("Foo"); doesn't exist in Haskell
13:43:29 <mauke> the FFI agrees with the IO () part :-)
13:43:40 <ReinH> tzh: If you want to understand Haskell, comparing the use of terminology with C won't get you very far.
13:43:52 <augur> the problem with these correspondences is that C doesnt really have a level at which you can talk about functions w/o calling them
13:44:01 <augur> except maybe to get addresses to them??
13:44:02 <ReinH> C++ has functors, but you won't understand anything about Functor by refering to them.
13:44:34 <eikke> augur: and pass them around, yeah
13:44:34 <augur> anyway, forget C, its rubbish!
13:44:40 <mauke> augur: in C, main has type int (*)(int, char **), so you can talk about that
13:44:44 <mauke> or rather
13:44:52 <mauke> main evaluates to that type
13:44:58 <augur> x_x
13:45:01 <mauke> its actual type is int (int, char **)
13:45:02 <eikke> augur: disagree. not rubbish, but (nowadays) a rather limited domain where it excells
13:45:39 <cite-reader> Transforming raw pointers to security advisories, as fast as possible?
13:45:47 <jophish> I'm trying to get ghci to load the object files compiled by `cabal build`. I've got '-dynamic' and '-odir src' as options to ghc but ghci's still interpreting the modules
13:46:09 <monochrom> I wouldn't say C is rubbish. but I agree to forget C for a moment when learning Haskell. in fact I recommend forgetting everything else for a moment when learning anything.
13:47:26 <augur> i am prone to overstatement for dramatic effect
13:47:53 <monochrom> jophish: you will also need "-idir src" for ghci
13:48:08 <johnw> C is my DSL for writing assembly language
13:48:11 <monochrom> actually it's called "-isrc"
13:48:14 <eikke> johnw: +1
13:48:16 <dolio> It is rubbish. Just people mistake there not being any non-rubbish in its niche for it not being rubbish. :)
13:48:18 <jophish> monochrom: I'm launching it with `cabal repl`
13:48:28 <monochrom> then I don't know
13:48:33 <dolio> Instead of considering that there could be non-rubbish there. :)
13:48:50 <eikke> almost the only time I use C nowadays is to write some SIMD intrinsics stuff (or at work ssometimes :-P)
13:49:34 <augur> dolio: lmfao
13:49:53 <augur> johnw: Haskell is my DSL for writing assembly language
13:51:02 * eikke hasn't used Windows for ages, but now has for the first time a Haskell package of his that's CI'ed on Windows as well, thanks to AppVeyor and Stack
13:51:14 <eikke> took a while to get this to work, but: jay! victory!
13:51:37 <jophish> eikke: do you have a config to share?
13:53:22 <eikke> jophish: Result here (there are links to the repo on top, which contains all configs and such): https://ci.appveyor.com/project/NicolasT/reedsolomon/build/1.0.41
13:54:17 <ReinH> dolio: how rubish do you think rust is?
13:54:23 <ReinH> and how close to C's niche?
13:56:49 <koshmar> I understand simple one: " f <=< g = \x -> g x >>= f " , could you please comment on this: " f <=< g = (=<<) f . g "  I do not reallly understand this one... is this ((=<<) f ) . g ?
13:57:05 <mauke> @unpl (=<<) f . g
13:57:05 <lambdabot> (\ c -> (g c) >>= f)
13:57:29 <mauke> koshmar: yes
13:57:46 <mauke> function call syntax binds tighter than infix operator syntax
13:59:40 * hackagebot cacophony 0.4.0 - A library implementing the Noise protocol.  https://hackage.haskell.org/package/cacophony-0.4.0 (jgalt)
14:00:41 <orion> aww yis
14:03:58 <dart> hi 
14:04:02 <tommd> hi
14:04:49 <dart> what is the difference between python coroutines (async/await) and the haskell "green" threads with forkIO, which one is more performant ? 
14:05:21 <johnw> would a performance difference be suffiience to change your implementation language?
14:05:25 <johnw> sufficient
14:05:40 <mauke> my guess would be haskell but I've never used async/await
14:05:58 <johnw> I ask because even if we knew the answer to that question, what would it matter?
14:06:05 <mauke> how well does python cope with a million "threads"?
14:06:09 <tommd> Could we get a meaningless toy benchmark of 100K async/await commands to complain about.
14:06:16 <dart> no i'm more curious about what are the differences 
14:06:25 <dart> between the two approaches 
14:06:30 <pikajude> does python still have GIL?
14:06:33 <eikke> dart: and how do you define 'performant', and are you aware even with coroutines in python you're stuck with the GIL, and ...
14:06:47 <pikajude> if it does, GHC does at least give you multiple cores
14:06:50 <eikke> dart: they're totally different,, believe me
14:07:10 <pikajude> GHC's green threads are Quite Good™ as far as lightweight goes
14:07:21 <kadoban> pikajude: cpython does
14:07:28 <pikajude> oh, ok
14:07:45 <dart> eikke: i sure believe you, i know what coroutines are, what i don't know is how they relate to haskell threads
14:08:06 <mauke> haskell threads are ... threads
14:08:12 <pikajude> well, they can be
14:08:42 <eikke> dart: performance is more about how they're scheduled and such rather than 'how they relate', no?
14:08:51 <dolio> ReinH: I don't know much about it really. I assume it's better in various ways.
14:09:48 <dolio> It would probably be my candidate for people doing the right thing.
14:09:52 <ReinH> dolio: affine types are actually pretty nice in practice
14:10:09 <dart> eikke: yes, i think
14:10:31 <ReinH> dolio: they even have parser combinator libraries now, although they aren't as nice to work with as ours
14:11:43 <lpaste_> mkaito pasted “Cabal error” at http://lpaste.net/865113491244056576
14:12:09 <mkaito> cabal can't seem to update. not sure what the problem is, though. the error message is less than helpful.
14:14:40 * hackagebot haskdogs 0.4.0 - Generate tags file for Haskell project and its nearest deps  https://hackage.haskell.org/package/haskdogs-0.4.0 (SergeyMironov)
14:15:04 <dcoutts> mkaito: are you using an http proxy?
14:16:03 <glguy> "does not exist" would make sense to be for the hostname failing to resolve
14:16:12 <dcoutts> mkaito: so with the version of cabal you've got, when the network is down then you get that error
14:16:27 <mkaito> I'm pretty sure the network is up.
14:16:28 <dcoutts> with the latest version it instead say: cabal: Couldn't establish HTTP connection.
14:16:43 <dcoutts> mkaito: it can be a dns resolver error
14:17:27 <dcoutts> or indeed any other reason that causes it to fail to establish an http connection
14:19:37 <glguy> Oh, "connection refused" as the same exception as the hostname failing to resolve
14:19:41 * hackagebot haskdogs 0.4.1 - Generate tags file for Haskell project and its nearest deps  https://hackage.haskell.org/package/haskdogs-0.4.1 (SergeyMironov)
14:21:30 <Zemyla> Man, if you read the source for libraries like bytestring or attoparsec, you can see how thin the gossamer of immutability is sometimes.
14:22:44 <monochrom> I read GHC-generated asm code and it is thin all the time, not just sometimes
14:23:28 <monochrom> every time lazy evaluation happens, there is mutation.
14:23:42 <monochrom> and lazy evaluation happens all the time, not just sometimes.
14:23:45 * glguy faints
14:24:57 <kadoban> Soo … here's a question: the output from ghc-pkg info and such commands, what's the encoding? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html#installed-pkg-info
14:25:11 <kadoban> UTF8? ASCII? unspecified?
14:26:33 <geekosaur> it should be controlled by your locale, defaulting to ISO8859-1
14:27:16 <geekosaur> if you have a UTF8 locale (most modern systems should default to this, at least for GUI logins) then it will be a UTF8 encoding
14:27:44 <kadoban> Hmmm. You pretty sure? Any chance it's documented anywhere?
14:28:37 <geekosaur> reasonably sure. but I am making an assumption, namely that it does the same thing ghc itself does and that it's using ghc's runtime to do it
14:28:37 <geekosaur> (since they are, or were last I checked, written themselves in Haskell)
14:29:09 <kadoban> Okay, thanks. That's way more than an answer than I expected :) I'll … go with that assumption and see how it works out.
14:29:19 <geekosaur> actually they'd pretty much ahve to be in Haskell because package stuff is using the Cabal library
14:29:20 <kadoban> way more of an answer*
14:30:20 <geekosaur> while I am guessing, people have run into bugs during the transition from the old iso8859 output stuff to the locale-aware stuff, especially when the package db had utf8 text in it
14:31:14 <dcoutts> geekosaur: I'd have to double check, but I think we made ghc-pkg and Cabal always use utf8 for the package registration files
14:31:15 <geekosaur> in any case, I dooubt it's specifically documented
14:31:27 <dcoutts> and other tools like haddock inputs
14:31:39 <kadoban> Yeah I'm a bit lost in the woods at the moment trying to mess with this stuff XD I appreciate the answer
14:31:49 <geekosaur> dcoutts, I phrased that poorly. you use utf8 in them but the contents do not always have characters extending beyond a single byte
14:32:33 <geekosaur> and during the cutover to the new output system there were occasional glitches when someone installed a package with a character in its description outside the 1-byte range and their locale was set to something neither utf8 nor iso8859-1
14:32:47 <geekosaur> and then showed up here trying to figure out why ghc-pkg was erroring on them
14:33:30 <dcoutts> geekosaur: yes, and we fixed that by not using local encoding, but always using utf8 irrespective
14:34:00 <kadoban> dcoutts: Oh really? That'd at least make my job a tiny bit easier.
14:34:11 <geekosaur> oh, you meant always utf8 on output, not always utf8 within the db itself. (what you said was slightly ambiguous)
14:34:25 <geekosaur> (I would have expected always utf8 in the db...)
14:34:41 <dcoutts> kadoban: yes, I just checked the code again, ghc-pkg register/dump always use utf8. It's considered to be part of the file format these days.
14:35:01 <kadoban> dcoutts: Hah, excellent. Thanks. Thanks again geekosaur too
14:35:08 <dcoutts> geekosaur: within the db it's just String, encoded via binary
14:35:17 <dcoutts> on disk encoded via binary
14:35:26 <geekosaur> right
14:36:15 <dcoutts> kadoban: and similarly, .cabal files are utf8
14:37:25 <kadoban> Cool. Yeah I'm trying to parse the output of ghc-pkg and a couple of other things, that makes it a bunch easier. *nukes all the ByteString*
14:41:47 <dcoutts> kadoban: you know you can use Cabal to look at the output of ghc-pkg
14:42:53 <dcoutts> kadoban: HcPkg.dump :: HcPkgInfo -> Verbosity -> PackageDB -> IO [InstalledPackageInfo]
14:43:00 <aisqwe> where can I read the GHC.Base implementations that are written in C?
14:43:14 <dcoutts> aisqwe: grab the source, look in cbits/
14:43:36 <kadoban> dcoutts: Wellll. I don't know much. I'm trying to mess with 'stack' to get it to better handle some cases with unicode input that it currently doesn't. That sounds like a good tip though, I'll try to work out … why it's not doing that.
14:44:42 * hackagebot haskdogs 0.4.2 - Generate tags file for Haskell project and its nearest deps  https://hackage.haskell.org/package/haskdogs-0.4.2 (SergeyMironov)
14:44:42 <aisqwe> dcoutts: there is no cbits/ in the github page!?
14:45:09 <dcoutts> kadoban: or if that funciton isn't what you want, the parser is there too, presumably stack uses that at least.
14:46:20 <kadoban> I know it uses Cabal in general, for some reason this specific part doesn't seem to at all though, it's just … manually calling ghc-pkg. I'll probably have to ask around, see if anyone knows why that'd be.
14:46:35 <aisqwe> dcoutts: nvm i think i found it
14:46:50 <dcoutts> aisqwe: https://git.haskell.org/ghc.git/tree/HEAD:/libraries/base/cbits
14:46:56 <Lokathor> "stack upgrade", getting lts-3.7, caching build plan, Progress: 0/129, ...oh my
14:47:08 <Lokathor> poor little single core machine
14:47:21 <aisqwe> dcoutts: thanks, are all the ghc.base codes there?
14:48:22 <dcoutts> aisqwe: not sure what you mean exactly, but that's where the base package is. it's mostly self-contained, with some bits in ghc-prim
14:55:06 <Franciman> Hello
14:55:29 <lpaste_> d-snp pasted “Generator in reverse” at http://lpaste.net/145602
14:55:37 <d-snp> hey guys, I feel super silly now.. could it be my monad is being run in reverse or is trace just messing with my head?
14:55:43 <d-snp> see above paste ^
14:57:00 <Franciman> hello f-a
14:57:30 <d-snp> oh hm
14:58:40 <Lokathor> d-snp, it sure looks like it's tracing in reverse >_> which is odd seeming
14:59:06 <jophish> hmm, how would you name a function which takes a Floating input and returns (exp x, exp (-x))
14:59:12 <jophish> expPlusMinus
14:59:34 <d-snp> Lokathor: the code is also in reverse, those "Non function extern: " messages, those are from the generateExternFunctions function, so the trace seems to be accurate
14:59:45 <ReinH> jophish: what have you tried?
15:00:21 <jophish> ReinH: expPlusMinus is the best I've come up with
15:00:28 <ReinH> jophish: oh, *name*.
15:00:38 <Pamelloes> What kinds of xml parsers are there in haskell?
15:01:09 <monochrom> (exp x, exp (-x)) is a hyperbolic trig pair because you can add them to get sinh, subtract to get cosh. (or is it the other way round?)
15:01:11 <jophish> ReinH: I'm sad you think so lowly of my skills!
15:01:31 <d-snp> :P
15:01:43 <Franciman> Hey italian haskellers, if you are interested join #haskell.it it's a group of italian people interested in haskell
15:01:48 <ReinH> jophish: it's best not to assume, but it's also best to read things properly...
15:07:42 <d-snp> anyone that could help me explain why this monad is run in reverse?
15:07:56 <d-snp> http://lpaste.net/145602
15:08:46 <d-snp> it should be sort of impossible right?
15:09:41 <d-snp> should I just assume it's not true and look somewhere else for why it thinks _IO_marker isn't defined?
15:09:54 <cite-reader> Does the order of prints change if you use traceM?
15:10:06 <glguy> it's probably a lazy state monad
15:10:19 <glguy> or something built similarly
15:11:17 <d-snp> hm I didn't know about traceM
15:11:32 <d-snp> no difference though
15:12:14 <glguy> d-snp: That's perfectly normal for a lazy state monad, and lazy functions in general
15:12:48 <d-snp> ok, but I definitely need the types to be generated before the functions are generated
15:12:49 <monochrom> http://lpaste.net/41790/ shows you an example where even without trace you already know that something has to be backwards
15:13:19 <monochrom> and http://lpaste.net/63925 is where things are beyond simplistic "forward vs backward"
15:13:23 <d-snp> does it detect that generateTypedef touches the type definitions and orders them?
15:14:38 <glguy> d-snp: the effect on the state runs "forward", but the earliest lines are only evaluated because the later lines depend on them
15:14:47 <mkaito> so what can interfere with cabal's DNS resolution? because the rest of my system does not have any issues.
15:15:33 <d-snp> glguy: right, and because the trace is executed outside of the state monad it doesn't necessarily flow forward with it
15:15:44 <dcoutts> mkaito: if you want to debug it further, cabal unpack cabal-install; cd cabal-install-x.y; edit Main.hs to remove topHandler and rebuild
15:16:53 <mkaito> cabal-install was installed through system package manager as a binary.
15:16:58 <dcoutts> mkaito: btw, I've also seen reports with this symptom where rebuilding made it go away, for reasons unclear. perhaps they had a borked binary
15:17:19 <mkaito> I've tried two different binaries (from two different repos), and both have the same issue.
15:17:25 <dcoutts> e.g. static linking on linux doesn't work well with host resolution
15:17:39 <mkaito> there's a thread on the arch linux boards saying switching away from systemd-resolved fixes it, which makes no sense to me.
15:17:47 <dcoutts> which is a glibc issue
15:18:01 <dcoutts> mkaito: is you cabal dynamically linked?
15:18:08 <dcoutts> you/your
15:18:31 <mkaito> I'm not sure. Any way to check?
15:18:35 <dcoutts> file, or ldd
15:18:49 <mkaito> yes, dynamically linked.
15:19:01 <cite-reader> Usually you have to go out of your way to get static binaries, so that would have been a bit of a shock.
15:19:45 <mkaito> so I'm looking at manually getting the source of cabal-install, removing topHandler from Main.hs and building that through cabal.
15:19:53 <dcoutts> mkaito: well, if rebuilding it makes it work, that'd also be an interesting data point for debugging what is going on
15:20:33 <dcoutts> mkaito: topHandler is the thing that's mangling the exception error message here
15:20:33 <monochrom> I fear that you now have a bit of a boostrapping problem
15:20:47 <mkaito> probably. cabal can't update itself.
15:21:23 <monochrom> you can use a web browser to visit hackage and download a tarball
15:21:28 <mkaito> just did
15:21:53 <monochrom> if all its dependencies are already installed previously, then that's pretty much it.
15:22:27 <mkaito> nope
15:22:30 <mkaito> this is a clean system
15:23:02 <mkaito> that's a lot of dependencies I'd have to manually install
15:23:06 <monochrom> then the tarball contains a bootstrap.sh which will use wget or something to download the dependencies
15:23:13 <mkaito> oh that's handy
15:23:59 <mkaito> it's compiling
15:25:24 <mkaito> rebuilding did not fix the issue, but now at least it's telling me that getAddrInfo is where it's breaking. which just tells me that it's indeed a DNS issue.
15:26:27 <mkaito> this is worth linking: https://bbs.archlinux.org/viewtopic.php?id=199747
15:27:04 <mkaito> this looks like it's going to be a pain to debug
15:27:16 <mkaito> but I'm happy to try, as long as I get some help :P
15:29:43 * hackagebot RANSAC 0.1.0.2 - The RANSAC algorithm for parameter estimation.  https://hackage.haskell.org/package/RANSAC-0.1.0.2 (AnthonyCowley)
15:30:03 <hwanzike> hallo, newbie question. why doesn't the following work? `fmap whatever Nothing`
15:30:15 <cite-reader> Define "doesn't work"?
15:30:29 <Iceland_jack> hwanzike: It should work if whatever has the right type
15:30:31 <Iceland_jack> :t \whatever -> fmap whatever Nothing
15:30:32 <lambdabot> (a -> b) -> Maybe b
15:30:42 <Iceland_jack> > fmap show (Just 42)
15:30:45 <lambdabot>  Just "42"
15:30:46 <Iceland_jack> > fmap show Nothing
15:30:46 <hwanzike> well, it whines cause it can't figure out the type of Nothing
15:30:48 <lambdabot>  Nothing
15:30:49 <mniip> :t fmap ?whatever Nothing
15:30:51 <monochrom> yeah, what is the type of whatever
15:30:51 <lambdabot> (?whatever::a -> b) => Maybe b
15:31:02 <hwanzike> like, it shouldn't need to right?
15:31:11 <pikajude> why not
15:31:16 <mniip> hwanzike, post your full code and the error you get
15:31:20 <monochrom> you know, that depends on the rest of your code
15:31:27 <Iceland_jack> what monochrom said, depends
15:31:37 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
15:31:59 <hwanzike> well, here's the line that makes Maybe a an instance of Functor: fmap f Nothing = Nothing
15:32:07 <pikajude> the question is why GHC can't just infer that the Nothing is whatever you need it to be, right?
15:32:10 <hwanzike> doesn't seem to depend on f at all
15:32:34 <hwanzike> pikajude: yea
15:32:50 <monochrom> are you looking for a debate?
15:32:57 <hwanzike> like, if i do `fmap succ Nothing` it'll fail cause it can't tell what type Nothing is
15:33:35 <mniip> ah
15:33:41 <mniip> monomorphism restriction my old friend
15:33:53 <pikajude> that's not it, is it?
15:34:00 <pikajude> even if you disable monomorphism restriction you still can't do that
15:34:03 <cite-reader> The type level doesn't know you used Nothing; all it knows is there's a term of type Maybe a and it needs to unify that a with something, but it can't figure out what.
15:34:10 <pikajude> because there's not a compile-time guarantee that `Nothing' isn't actually Just something
15:34:12 <pikajude> it's just Maybe a
15:34:18 <pikajude> and it needs to be told what `a' is
15:34:25 <monochrom> @type fmap succ Nothing
15:34:26 <Iceland_jack> :t fmap succ :: Enum a => Maybe a -> Maybe a
15:34:26 <lambdabot> Enum b => Maybe b
15:34:28 <lambdabot> Enum a => Maybe a -> Maybe a
15:34:47 <monochrom> it is unknown which instance of Enum you want
15:34:49 <Iceland_jack> Even though you apply 'fmap succ' to a Nothing, GHC still needs to know which Enum you're talking about
15:34:57 <monochrom> > fmap succ Nothing
15:34:59 <lambdabot>  Nothing
15:35:08 <pikajude> > case fmap succ Nothing of { Nothing -> ???; Just x -> ???; }
15:35:09 <hwanzike> ze heck
15:35:10 <lambdabot>  <hint>:1:40: parse error on input ‘???’
15:35:21 <monochrom> but lambdabot's > has a lot of defaulting. (it chooses () for b)
15:35:25 <pikajude> whoops
15:35:26 <hwanzike> ah ok
15:35:28 <pikajude> i didn't mean to type >
15:35:50 <hwanzike> > fmap succ (Nothing :: Maybe Int)
15:35:52 <lambdabot>  Nothing
15:35:59 <Iceland_jack>     fmap (succ :: Int   -> Int)
15:36:00 <Iceland_jack> is a very different function than
15:36:00 <Iceland_jack>     fmap (succ :: Float -> Float)
15:37:21 <hwanzike> ok so the thing is, it's trying to determine which succ it needs, even though it won't really call it
15:37:57 <monochrom> that's what a typechecker does. it checks types without thinking "but wait will I really run this code?"
15:37:59 <Iceland_jack> Yes, it needs to know the types (static) even though it's not needed at run-time (dynamic)
15:38:15 <monochrom> it is why typechecking, even type inference, is computable to begin with
15:39:15 <monochrom> if it has to worry about "but wait will anyone run it? seriously?" then you may as well go back to untyped languages so you always give it a spin
15:39:39 <hwanzike> mmmmmmmm yea that makes sense
15:40:07 <monochrom> and some people do go back to python because precisely of that
15:40:35 <cite-reader> You could always turn on -fdefer-type-errors.
15:40:39 <hwanzike> well.. untyped languages have a few advantages after all..
15:40:46 <Iceland_jack> hwanzike: Most of the time it's no problem at all, this is mostly an issue in one-liners where there isn't enough context to determine the actual type
15:41:32 <hwanzike> Iceland_jack: you're right that this one liner is dumb and would probably not appear on the wild on its own. hadn't thought about it
15:41:56 <Iceland_jack> It's common with the "read" function where
15:41:56 <Iceland_jack>     read "True"
15:41:56 <Iceland_jack> is very ambiguous: do you want a Bool or a Float
15:41:56 <Iceland_jack>     read :: String -> Bool
15:41:59 <Iceland_jack>     read :: String -> Float
15:42:02 <Iceland_jack>  
15:42:37 <Iceland_jack> While in actual code you might use it like this
15:42:37 <Iceland_jack>     if read "True" then ... else ...
15:42:37 <Iceland_jack> and then GHC gathers from context that it must be Bool
15:43:39 <Iceland_jack> hwanzike: Think of it in terms of "information lost" versus "information needed"
15:44:02 <Iceland_jack> By doing 'show True' you throw away type information
15:44:36 <Iceland_jack> With 'read "True"' you need to provide the type information
15:45:02 <hwanzike> True
15:45:42 <Iceland_jack> This is one reason why parametric polymorphism is so great, look at the const function
15:45:42 <Iceland_jack>     const :: a -> b -> a
15:45:42 <Iceland_jack>     const x y = x
15:46:33 <Iceland_jack> 'y' is chucked away, and its type can be any type
15:46:43 <Iceland_jack> Which is why you can write:
15:46:43 <Iceland_jack> :t const 'a' undefined
15:46:44 <lambdabot> Char
15:47:16 <monochrom> const 'x' Nothing would be where you won't get an error. no decision on type class instance is required
15:47:26 <arianvp> Been spending all night working on an CQRS framework with domain testing 
15:47:39 <arianvp> I feel so OOP http://lpaste.net/4776006652514009088
15:47:52 <mniip> yeah, in "const 'a' undefined", "undefined" assumes the type Any
15:47:56 <Iceland_jack> arianvp: I've been modeling subtyping for the last week, that has been fun
15:48:12 <Iceland_jack> Craziest data type specification I've ever had in Haskell
15:48:43 <arianvp> sweet
15:48:46 <benzrf> hmmm
15:49:35 <mkaito> no luck messing with system DNS settings. cabal still doesn't want to resolve hackage. everything else on my system works just fine. what does haskell's http library do different?
15:49:55 <benzrf> if you made a GADT for ASTs such that a representation of a value appears in its type, could you use that to do HOAS for a dependently typed language?
15:50:20 <benzrf> oops sorry i forgot that mental masturbation goes to -blah
15:50:42 <arianvp> thanks for reminding me about -blah
15:51:01 <hwanzike> mkaito: what OS?
15:51:04 <mkaito> arch linux
15:51:15 <dcoutts> mkaito: so you rebuilt it and no luck?
15:51:45 <dcoutts> mkaito: the http lib uses the network lib, which is what does the dns resolution, by calling standard C functions
15:51:55 <mkaito> that's weird
15:51:59 <mkaito> yeah I rebuilt
15:52:01 <mkaito> removed topHandler
15:52:15 <mkaito> cabal: getAddrInfo: does not exist (Name or service not known)
15:52:19 <mkaito> so yeah, it's a DNS issue
15:53:18 <mkaito> ... not like that actually helps me. because the rest of the system has zero issues with dns resolution.
15:54:08 <dcoutts> mkaito: two things I'd try: rebuilding network lib, and ftracing to see the call into the C lib or kernel for the addr info
15:54:32 <mkaito> I'm not sure how to do either of those things.
15:54:37 <hwanzike> if you dig that same host it works?
15:56:33 <lpaste_> mkaito pasted “dns resolution” at http://lpaste.net/3785462390896721920
15:58:27 <jophish> wouldn't it be great to be able to write template haskell in RULES, for example: "div pow 2" forall x. x / y = x `shiftR` z where z = log2 x; True = isPow2 y
15:58:30 <jophish> or something like that
15:58:38 <jophish> template haskell was the wrong phrase
15:58:42 <jophish> compile time haskell
15:59:13 <jophish> It would save me writing 7 different rules and missing the ones above 64
15:59:35 <jophish> I suppose it would be necessary to determine if y could be calculated at compile time
15:59:53 <jophish> although that could always be left up to the rule writer
16:11:03 <jophish> Also, it would be nice to be able to mark a funciton as commutative and not have to write every rule twice
16:11:31 <mgsloan> jophish: You could use TH to generate the RULES pragmas
16:12:10 <mkaito> this might not be the best possible medium to get help on that DNS stuff. Can I ask for help anywhere else? I'm sorry to need so much hand holding.
16:13:13 <dc___> Hi -- what's the idiomatic way of reading, e.g. 3 integers from stdin ?
16:13:14 <jophish> mkaito: you might have more luck in #haskell-infrastructure
16:13:20 <dc___> as in:
16:13:22 <dc___> 1 2 3
16:13:29 <geekosaur> "host"/"dig" is not always the best way to test this stuff, because they test DNS directly --- not your system's resolver, which may be complicated by nsswitch, caching (nscd), etc.
16:13:40 <jophish> mgsloan: ah, I'd not considered that
16:13:47 <mkaito> that's interesting
16:13:47 <jophish> I'll give it a try!
16:14:08 <geekosaur> well, they can be helpful in diagnosis when they work but other programs don't, you can narrow where the problem is down a bit. but they're not guaranteed to do the same thing
16:14:19 <mkaito> alright
16:14:35 <mkaito> sticking point is the same, though. things like curl, firefox, irc client work fine.
16:14:45 * hackagebot hashtables 1.2.1.0 - Mutable hash tables in the ST monad  https://hackage.haskell.org/package/hashtables-1.2.1.0 (GregoryCollins)
16:15:26 <geekosaur> ("getent hosts hostname") is the equivalent to "host" for testing what normal programs see, fwiw. acknowleding that something else must be up here...)
16:16:03 <mkaito> getent hosts hackage.haskell.org works
16:16:06 * geekosaur would probably be resorting to strace at this point, but this is probably not a good tool for most people
16:16:41 <mkaito> well guess I'm reading strace then
16:17:11 <geekosaur> as I just said, not really a good tool for most people. and I probably pull it out earlier than most people do
16:17:33 <geekosaur> (it's not exactly friendly)
16:17:48 <mkaito> I'm not afraid of low level gore :P but strace IS a little over my head
16:18:00 <mkaito> would you like a pastie?
16:18:21 <sm> if you just squint your eyes a bit.. 
16:18:23 <johnw> mkaito: strace = every call into the kernel from your user process
16:18:43 <mkaito> yeah I know. I just meant that I have a hard time getting any useful data from it personally.
16:19:07 <johnw> usually I just look for arguments I recognize, calls that shouldn't be there, and return codes
16:20:05 <lpaste_> mkaito pasted “strace cabal update” at http://lpaste.net/619689026907013120
16:20:09 <mkaito> there, in case you can make more sense of it than me
16:21:53 <geekosaur> mrrrrrrrr
16:22:02 <geekosaur> that hosts file...
16:22:18 <mkaito> ah yeah
16:22:19 <mkaito> :P
16:22:24 <geekosaur> I understand the desire to block ads, but if any of those sites are fronted by cloudflare, you may have shot yourself in the foot
16:22:34 <mkaito> that's a pretty good point
16:22:58 <mkaito> I use cloudfront myself in production, though. Haven't noticed any trouble. So maybe I'm lucky.
16:23:10 <mkaito> I can clean the hosts file out just to test this though
16:23:18 <geekosaur> (maybe. usually not since you'd only find that if the top level name resolved ot a CNAME, which it shouldn't vbecause it's being forced to 0.0.0.0)
16:23:28 <geekosaur> well, you;d see it elsewhere as well, I;d think
16:23:35 <mkaito> likely
16:23:39 <mkaito> I spent most of my life on the net.
16:24:08 <geekosaur> but I like to remove variables like that when diagnosing, just because it makes tracking problems down harder. you can swap it back in after
16:24:22 <athan> Hi gang. With aeson, is there any way to accept any Object as parseable, as a [(String, String)] pair of values?
16:24:24 <mkaito> sorted, posting new strace pastie
16:24:30 <sm> geekosaur: how would setting null IP addresses for ad servers cause problems accessing the main site ?
16:24:38 <mkaito> dns cache
16:25:10 <lpaste_> mkaito pasted “strace cabal update take 2” at http://lpaste.net/2150979098543915008
16:25:27 <geekosaur> iiiii.... why is this consulting dbus on a hostname lookupo
16:25:35 <sm> hackage uses cloudflare or something similar, right ?
16:25:36 <geekosaur> linux. pfeh.
16:25:37 <mkaito> probably systemd-resolved
16:25:47 <mkaito> systemd loves them some dbus
16:27:01 <geekosaur> yeh, it's in the libresolv part of the nsswitch lookup
16:27:12 <geekosaur> and it's apparently failing to look up for some reason
16:27:28 <mkaito> would you like an strace of curl opening the same address, for comparison?
16:28:04 <geekosaur> oh heck
16:28:18 <geekosaur> it stops that dbus stuff on a SIGVTALRM
16:28:35 <mkaito> I've never even seen that signal before O_O
16:28:40 <geekosaur> can you try running that with: cabal update +RTS -V0
16:29:07 <geekosaur> don;t need to strace it
16:29:18 <mkaito> > cabal: Most RTS options are disabled. Link with -rtsopts to enable them.
16:29:20 <lambdabot>  <hint>:1:73:
16:29:20 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
16:29:23 <geekosaur> crud
16:29:42 <geekosaur> have to build it yourself with rtsopts enabled :(
16:29:51 <mkaito> cabal-install?
16:29:55 <mkaito> or network?
16:30:04 <geekosaur> cabal-install
16:30:11 <mkaito> alright give me a minute
16:30:19 <mkaito> where are the build flags?
16:30:24 <dcoutts> mkaito: cabal-install. which you built manually already, so just build again with --ghc-options=-rtsopts
16:30:56 <mkaito> doing so
16:31:19 <geekosaur> sm: it "shouldn't", I just like to reduce complications / extra variables when trying to track stuff like this down
16:31:31 <geekosaur> but I think strace actually fingered the real problem here
16:31:45 <mkaito> cabal-install rebuilt
16:31:46 <mkaito> ❯ cabal update +RTS -V0                 
16:31:48 <mkaito> Downloading the latest package list from hackage.haskell.org
16:31:52 <mkaito> that takes 6 seconds now
16:31:56 <mkaito> and then no further output
16:32:17 <geekosaur> that would be expected behavior
16:32:48 <mkaito> so what does that mean? :P
16:32:50 <geekosaur> so, it's the runtime GC/profiling tick aborting the host lookup when it talks to systemd-resolvd
16:32:55 <mkaito> I see
16:33:05 <mkaito> is that a bug somewhere in the stack?
16:33:11 <dcoutts> I'd call that a bug in systemd-resolvd
16:33:33 <geekosaur> well, in libnss_resolv when using systemd-resolvd, or maybe in the dbus library
16:33:36 <dcoutts> the call should be restartable
16:33:45 <dcoutts> syscall that is
16:33:49 <geekosaur> it is restartable, it just doesn;t restart it; it treats it as an error
16:34:14 <mkaito> that's a lot of debugging way over my head -_-
16:34:27 <mkaito> and I can't just submit vague half empty bug reports to everything :P
16:34:28 <geekosaur> (actually alarm signals don't generally auto-restart; they are missing a check for EINTR)
16:34:59 <geekosaur> (since one of the points of alarm signals is to interrupt things that could take a long time)
16:35:53 <geekosaur> mkaito: so, I would say the dbus library needs to check for EINTR returns from dbus reads and retry. right now it's aborting instead
16:36:40 <geekosaur> ...this could be complicated if they are using alarms themselves for timeouts; in that case, it'd need to distinguish between their expected timeout and the unexpected one from the ghc runtime's SIGVTALRM
16:36:50 <mkaito> shouldn't this be happening on pretty much any dns query?
16:36:51 <cmears> athan, do you mean to take a string like "{\"a\":\"b\",\"c\":\"d\"}" and get an Object?
16:36:56 <geekosaur> (normal timeouts are SIGALRM)
16:36:58 <jophish> Sometimes I really want the operators in Num to be of type :: a -> b -> Plus a b
16:37:13 <geekosaur> mkaito, how many dns queries are you doing from Haskell?
16:37:24 <mkaito> from haskell, just cabal.
16:37:27 <athan> cmears: I actually figured it out; an `Object` is just a synonym for a HashMap, which already has an instance
16:37:32 <geekosaur> something like curl won't see this, the C runtime doesn't have a SIGVTALRM tick like this
16:37:38 <mkaito> I see
16:37:40 <athan> I just needed to delete the known keys I already had to get the rest of them :)
16:37:53 <cmears> athan, right, I was just going to suggest "decode" (:
16:38:03 <athan> >.>
16:38:24 <dcoutts> mkaito: yes, any Haskell getNameAddr user
16:38:26 <sm> I have done cabal update on a machine running systemd. But it's a vps, probably no usb errors..
16:38:55 <dcoutts> mkaito: erm getAddrInfo
16:39:02 <geekosaur> it's not just "running systemd", it also has to be using the dbus-based DNS cache systemd can optionally provide
16:39:18 <sm> ahh
16:39:25 <sm> well: geekosaur++, strace++ !
16:39:43 <mkaito> which it seems to be doing by default on arch
16:39:46 * hackagebot diagrams-svg 1.3.1.9 - SVG backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-svg-1.3.1.9 (jeffreyrosenbluth)
16:39:48 <jophish> Is anyone attending s-repls tomorrow?
16:39:58 <mkaito> I set up systemd-networkd to manage my network because it was convenient and already installed
16:40:57 <mkaito> wine was actually also having trouble a while ago with this
16:41:04 <mkaito> which solved itself by downgrading systemd
16:41:59 <geekosaur> strace is pretty clear here, actually: the dbus communication aborts and it goes on to the next NSS module, right after the SIGVTALRM triggers and EINTR passed back up
16:42:42 <mkaito> well dbus is not exactly rock solid, but I didn't think it was quite that flaky
16:43:02 <geekosaur> I wonder if there's a way to make their libnss_resolve skip looking in dbus's cache as a temporary workaround
16:43:16 <geekosaur> mkaito, this kind of error is actually pretty common
16:43:36 <geekosaur> people just don't think about what system calls can produce EINTR and require restarts
16:44:00 <geekosaur> I helped someone diagnose another of these in a C program last week
16:44:47 * hackagebot diagrams-haddock 0.3.0.9 - Preprocessor for embedding diagrams in Haddock documentation  https://hackage.haskell.org/package/diagrams-haddock-0.3.0.9 (jeffreyrosenbluth)
16:44:55 <mkaito> I see
16:45:59 <geekosaur> most of the time, programs don't do this kind of thing, so EINTR-related issues can fly under the radar for years before someone tries to use the library in a program which has lots of short-period alarms and it breaks
16:46:29 <mkaito> I'm not entirely sure how the dbus folks would think about "haskell has an issue with dns" :P
16:46:40 <geekosaur> (in fact, the C program I diagnosed last week had this happening in glibc!)
16:47:33 <arw> geekosaur: try to edit /etc/nsswitch.conf, maybe it'll help if you remove mdns and similarly obscure stuff
16:47:40 <geekosaur> mdns isn;t the issue
16:47:55 <geekosaur> mdns is just what it tries next after this. it's libnss_resolve... which you really do not want to disable
16:48:04 <arw> hm, right.
16:48:41 <geekosaur> mkaito, in any case, keep that strace with the SIGVTALRM, that's the smoking gun and if their programmers are at all competent they should recognize it immediately
16:48:59 <geekosaur> and the fact that disabling SIGVTALRM (that was the +RTS -V0) made it work
16:51:06 <mkaito> adding glibc's dns resolver to nsswitch.conf did in fact solve my issue
16:51:15 <mkaito> now, where do I report this
16:52:19 <geekosaur> I'm not actually sure. I could argue for dbus, or for the systemd libnss_resolve that is using dbus lookups, but I don't really know which one is appropriate. probably start with the latter
16:52:34 <geekosaur> they can decide whether they should be handling the EINTR or if dbus should be
16:52:47 <mkaito> roger
16:52:57 <geekosaur> (I'd have to sit down and examine the code for both, and probably talk to the devs...)
16:53:56 <mkaito> https://github.com/systemd/systemd/issues/1692
16:54:00 <mkaito> does that look like the same thing?
16:54:42 <geekosaur> not the same, no. that's about failure to connect at all; in this case, it just needs to retry dbus reads when one returns EINTR
17:00:31 <mkaito> https://github.com/systemd/systemd/issues/1965
17:00:36 <mkaito> shortest bug report I've ever written
17:00:38 <mkaito> but whatever
17:02:51 <mkaito> thanks for the help geekosaur :)
17:13:57 <geekosaur> Expanding a bit (I helped the oriEx
17:14:04 <geekosaur> whooops
17:14:30 * geekosaur notes his window focus is not being shown properly... oops
17:14:39 <MarcelineVQ> shut it down, they know!
17:14:48 * hackagebot free-concurrent 0.1.0.1 - Free monads suitable for concurrent computation  https://hackage.haskell.org/package/free-concurrent-0.1.0.1 (srijs)
17:17:54 <geekosaur> probably my own fault for having so many experimental hacks in my xmonad config >.>
17:19:30 <Lokathor> when ghci says (0.02 secs, 2,506,264 bytes) and such after an expression is evaluated, I get that the 0.02 secs is how long it took
17:19:42 <Lokathor> what is the bytes value? is that bytes allocated?
17:20:22 <geekosaur> yes. note that ghci does not optimize
17:20:58 <geekosaur> compiled code often can optimize away allocations
17:22:24 <geekosaur> (not just ghci; it's the bytecode backend, also used by Template Haskell, hint, and a few other things, that doesn't know how to optimize)
17:23:46 <Lokathor> the only time i'd be excessively concerned with allocations is on my raspberry pi
17:24:14 <Lokathor> i mostly figured it was allocated, but just wanted to check
17:25:00 <stephen_> I love stack so much
17:25:49 <geekosaur> also note that bytes allocated does not mean that much space was used; if something is GCd and then reused in an allocation, that counter records it as a "new" allocation
17:26:41 <c_wraith> A high allocation rate that never makes it out of the nursery is usually ok.
17:26:43 <Lokathor> does GC often run during a ghci expression, or is it usually deferred to after the expression finishes?
17:26:50 <Lokathor> or is it one of those "it depends" things?
17:28:24 <c_wraith> GC runs in 2 cases.
17:28:52 <c_wraith> The first case is if a generation runs out of space.  Stuff only gets promoted out of the nursery when it's collected, so it's really "when the nursery runs out of space"
17:29:11 <c_wraith> The second case is when the idle GC is enabled, which it is by default.
17:29:46 <c_wraith> The idle GC runs if no haskell threads have performed any work in something like 100 milliseconds.  The exact value is tunable.
17:29:53 <c_wraith> I suppose there is a third option.  The GC can run when you tell it to, programatically.
17:30:23 <Lokathor> ah, yes, i remember a program that had a big button you could press to force a JVM collection
17:30:45 <Lokathor> never seemed to help much, the JVM GC seems smart enough on its own. I expect GHC's is similar
17:32:44 <c_wraith> It can help if you have predictable idle periods
17:32:53 <c_wraith> But it doesn't help much other than that.
17:34:14 <Lokathor> sortave a "runGC; sleep 10000;" situation?
17:35:44 <paaavo> Hey! Anyone familiar with Aeson?
17:36:06 <dmj> paaavo: sure
17:36:48 <paaavo> So I have something like this "data MyThing = MyThing String deriving (Show, Generic)", and I use the automatic encode/decode generation that uses generics.
17:37:58 <paaavo> But I haven't been able to figure out what I need to give to decode to get it to decode. It doesn't even seem to be able to decode what itself encodes to. A "decode (encode (MyThing "Hello, World!"))" gives me a Nothing.
17:39:11 <dmj> paaavo: if you have a single constructor, I'd use a newtype, and then you'll get access to generalized newtype deriving
17:39:28 <dmj> newtype MyThing = MyThing String deriving (Show, ToJSON, FromJSON)
17:39:48 <dmj> you won't need to do 'instance ToJSON MyThing', since it's a newtype
17:40:16 <dmj> then you should be able to \x -> decode (encode (MyThing "foo")) == Just x
17:40:29 <dmj> :t toJSON 
17:40:30 <lambdabot> Not in scope: ‘toJSON’
17:40:55 <dmj> paaavo: the default encoding of that would be a 'String :: Value'
17:41:15 <mkaito> geekosaur: thanks for posting on the bug report :)
17:42:06 <geekosaur> I expect I'll have to do more explaining once they respond to it, since I have some idea of what's actually going on. I kinda fear it will turn into finger-pointing between Poettering and the dbus devs over whose responsibility to handle it >.>
17:42:18 <mkaito> probably
17:42:38 <mkaito> in the meantime, at least I get to play around with snap instead of waiting for poettering to pull his finger out of where you know.
17:42:42 <mkaito> so thanks a lot :)
17:43:04 <dmj> paaavo: also, use 'eitherDecode', it's helpful for understanding 'why' something isn't decoding 
17:43:34 <gfixler> is there any efficient way to ask for system time, or the current running time?
17:43:46 <geekosaur> (it's not the responsibility of the ghc devs; this is happening down deep inside the resolver code, application code has not a lot of control there and does have a fair expectation that this should be handled automatically)
17:43:55 <paaavo> The newtype works. Thanks! And especially thanks for 'eitherDecode', I've been doing that myself. I really should read the docs better :)
17:44:38 <geekosaur> come to think of it, I think the other place I ran into this *was* dbus. I'd have to review last week's IRC logs. but it sounds a lot like dbus just doesn't deal with EINTR in all the places it should...
17:44:42 <gfixler> system.time is deprecated
17:44:55 <geekosaur> Data.Time
17:45:16 <_m_ryan> can anyone help me with my problem. about prelude parse. http://lpaste.net/145604
17:45:23 <gfixler> geekosaur: it doesn't have ClockTime, though :(
17:45:24 <geekosaur> more specifically http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/time-1.4.0.1/Data-Time-Clock-POSIX.html
17:45:54 <gfixler> POSIX won't work on Windows, will it?
17:46:24 <gfixler> ah, I see this in the source: FILETIME ft <- System.Win32.Time.getSystemTimeAsFileTime
17:46:27 <gfixler> looks like it will
17:46:31 <dmj> paaavo: use generics for as much of it as you can, sounds like you're on the right path
17:48:01 <geekosaur> let ip = read $ show ip2 :: IP
17:48:02 <m_ryan> can anyone help me with my problem. about prelude parse. http://lpaste.net/145604
17:48:26 <geekosaur> that's your problem; what were you trying to do there, and does this IP type have sensible Show and Read instances?
17:48:49 <geekosaur> hm, actuallu I presume we don;'t care about the Show instance
17:48:57 <geekosaur> but I bet the read instance expects a constructor...
17:49:13 <geekosaur> (line 15 in your paste)
17:49:52 * hackagebot sbp 0.51.5 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.51.5 (mookerji)
17:52:18 <pavonia> Isn't the problem here that it's using the Show String instance?
17:54:23 <pavonia> m_ryan: What's the type of lookupHandler?
17:54:52 * hackagebot sbp 0.51.6 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.51.6 (mookerji)
17:55:11 <geekosaur> hm, wonder if it's trying to convert a Text or ByteString to String that way?
17:55:21 <geekosaur> (that would be quite wrong...)
17:56:57 <pavonia> Yeah, not sure what library he's using. Yesod has lookupHeader :: MonadHandler m => CI ByteString -> m (Maybe ByteString)
18:44:02 <Lokathor> so i want to write my own Arbitrary instance for QuickCheck
18:44:28 <Lokathor> to make a value of my type I just need any two Word64
18:44:55 <Clint> Lokathor: do that then
18:45:22 <Lokathor> well i'm not quite sure... what i use to do that
18:45:32 <Lokathor> arbitrary :: Gen a
18:46:32 <Lokathor> something like, arbitrary = do { w1 <- generate; w2 <- generate; return mkThing w1 w2 } ?
18:46:55 <Lokathor> but generate makes IO a values
18:47:17 <Clint> Lokathor: Lokathor use 'arbitrary', not 'generate'
18:47:53 <Lokathor> hmm
18:48:34 <mjhoy> the only time i think moving away from boston was a bad idea, is when a boston haskell video pops up.
18:48:51 <dmj> Lokathor: instance Arbitrary (Word64, Word64) where arbitrary = liftA2 (,) arbitrary arbitrary
18:49:07 <Lokathor> oh you use other things arbitrary function
18:49:08 <Lokathor> okay
19:00:02 <mjrosenb> oh god
19:00:07 <mjrosenb> I upgraded reactive-banana
19:00:14 <mjrosenb> and now everything is different
19:00:25 <mjrosenb> like the function names are the same
19:00:32 <mjrosenb> but they types are /totally/ different.
19:01:25 <Lokathor> rolldy :: (RandomGen g) => Int -> State g Int
19:01:37 <Lokathor> i have this function, and i want to test it with a thing that's an Arbitrary instance
19:01:56 <Lokathor> how might i fenangle it to take in a specific subtype
19:02:14 <Lokathor> so i have to write out the thing as a declared function with a signature instead of a lambda?
19:10:20 * hackagebot pipes-cacophony 0.1.2 - Pipes for Noise-secured network connections.  https://hackage.haskell.org/package/pipes-cacophony-0.1.2 (jgalt)
19:13:25 <wyvern> How does Haskell (GHC in particular, I suppose, if it matters) handle Unicode? Like, what is a Char in Unicode parlance? A UTF-16 code unit, or an abstract Unicode code point, or what?
19:14:36 <Lokathor> The character type Char is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) characters (see http://www.unicode.org/ for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type Char.
19:14:41 <Lokathor> https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Char.html
19:17:25 <wyvern> Ah, thanks!
19:17:49 <Ralith> wyvern: a Char is a Unicode scalar value, I'm pretty sure
19:18:37 <wyvern> I'm just learning haskell; figured I might port one of my existing libraries to it (which does some UTF-8 wrangling) as an exercise.
19:19:03 <pavonia> > (minBound :: Char, maxBound :: Char)
19:19:05 <lambdabot>  ('\NUL','\1114111')
19:19:52 <wyvern> interesting, it's '\NUL' not '\0'?
19:20:14 <pavonia> > '\NUL' == '\0'
19:20:16 <lambdabot>  True
19:20:22 <geekosaur> the Show instance prefers the alpha mappinsg when possible
19:20:37 <wyvern> ah, ok.
19:20:46 <lpaste_> Lokathor pasted “Not sure why I'm getting a type error” at http://lpaste.net/145614
19:25:17 <Lokathor> so usually QuickCheck can pick the right types, and I'm not clear why it's picking the wrong type here
19:27:06 <pavonia> Lokathor: execState has the same result type as the second parameter, so it tries to match the types of "gen" and "result"
19:28:21 <Lokathor> oh did i really write Exec when I meant Eval
19:28:24 <Lokathor> ugh
19:34:22 <Lokathor> alright, that's sorted
19:36:06 <Lokathor> so I've got a number of functions that take a RandomGen, and I'd like to run them each on the three types of RandomGen available to me (StdGen from random, and PCGen32 and PCGen64 from my library)
19:36:51 <Lokathor> is there some magic that lets me do this without writing out the tests three times?
19:43:55 <dmj`> Lokathor: you can write a function constrained by RandomGen, and then pass those values in. 
19:44:33 <Lokathor> like RandomGen g => g -> Spec  ?
19:46:23 <dmj`> sure, or you might be able to use a heterogenous list via existential quantification
19:47:00 <dmj`> data Randos = forall a . RandonGen a => Randos [a]
19:47:38 <Lokathor> well if I make each test as a (g -> Property) function, then I can at least call those more general functions
19:48:47 <dmj`> sure
19:53:41 <ttt_fff> if "a" == "a" && 2 == 3 then ... else ... // does this mean that to even support typeclasses, we need atleast rank-2 types?
19:53:58 <ttt_fff> since we need the "==" to be forall a. Eq a => a -> a -> Bool, rather than String -> String -> Bool or Int -> Int -> Bool ?
20:01:25 <lpaste_> Lokathor pasted “This seems to work dmj`” at http://lpaste.net/145618
20:02:10 <geekosaur> ttt_fff, no, it means that such functions carry around an extra parameter (it's not an accident that (context =>) looks a lot like (type ->)
20:03:00 <Lokathor> typeclasses work (in GHC at least) with secret dictionaries of functions that get passed around and accessed at the right times
20:04:02 <dmj`> Lokathor: nice
20:07:12 <Pamelloes> If I'm in a MaybeT, is there a way to unbox Maybe a into a?
20:07:24 <Pamelloes> (i.e. switching the whole block into Nothing if a is Nothing)
20:07:44 <Pamelloes> (("i.e." was totally unnecessary :/))
20:11:50 <dmj`> Pamelloes: you can still pattern match on Maybes with let in MaybeT blocks. runMaybeT $ do { let x = Just 4; case x of Nothing -> liftIO (print 3); Just y -> return (); lookup 4 [(4,[])] >>= return }
20:13:11 <Pamelloes> dmj`: I actually wanted liftMaybe :: Maybe a -> MaybeT m a, which I've just written after figuring out that's what I wanted :)
20:17:23 <dmj`> Pamelloes: oh, thought you wanted to unbox, instead of wrap up
20:18:17 <dolio> exit
20:18:29 <Pamelloes> dmj`: I wanted to unbox the (Maybe a) within the MaybeT: runMaybeT $ do { unboxed <- liftMaybe maybeVal; ... }
20:21:31 <dmj`> Pamelloes: just use return
20:21:32 <dmj`> λ: runMaybeT $ return (Just 4) >>= return
20:21:33 <dmj`> Just (Just 4)
20:22:43 <Pamelloes> Hm?
20:23:07 <Pamelloes> > runMaybeT $ return (Just 4) >> return 7
20:23:10 <lambdabot>  Not in scope: ‘runMaybeT’
20:23:12 <dmj`> in your example
20:23:26 <dmj`> runMaybeT $ do { unboxed <- return maybeVal; ... }
20:23:33 <nshepperd> "unbox" as in get access to the 'a' inside the 'Maybe a', I think
20:24:04 <Pamelloes> nshepperd: Yep, that's what I meant. What term should I use instead of unbox?
20:25:56 <nshepperd> not sure
20:28:21 <nolraiU> This is maybe not the right place to ask this, but is there a name for proofs that are either inductive or coinductive without changing form?
20:28:33 <nolraiU> Or I guess I mean algorithems?
20:40:54 * hackagebot git-fmt 0.2.0.0 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.2.0.0 (hjwylde)
20:43:33 <Jinxit> if I want to design a data structure which includes (amongst other things) haskell functions as leaves, what are my options for actually putting the thing together?
20:45:23 <dmj`> data Tree a = Leaf (a -> a) | Node a (Tree a) (Tree a)
20:45:41 <Jinxit> sorry, question was badly posed
20:46:09 <Jinxit> I want to then create a tree without having to write Node () (Node () (Node .....
20:46:39 <Jinxit> I want like a DSL for constructing the tree
20:49:13 <lethjakman-l> Hey, so I have a datatype: data ParticipantGroup = UserGroup [Text] | NamedUsers [NamedUser] deriving (Show)
20:49:23 <lethjakman-l> I want to extract all of the values constructed with NamedUsers
20:49:25 <lethjakman-l> Is that possible?
20:49:40 <lethjakman-l> Well, I mean, I think I can do it with a case, but is there a nifty function built for this?
20:50:38 <dmj`> lethjakman-l: so you have a [ UserGroup ]
20:50:45 <dmj`> er, [ ParticipantGroup ]
20:51:05 <lethjakman-l> dmj`: Yes
20:51:09 <lethjakman-l> That's exactly what I have. 
20:51:10 <Lokathor> if you use Ctrl+C to kill a test running with "stack test" that's gone into an infinite loop on accident, it seems that stack shuts down and you get your console back, but the test.exe process itself isn't actually killed off
20:51:49 <Lokathor> seems like a bug
20:52:03 <Lokathor> or maybe it's a natural result of cmd.exe weirdness
20:53:46 <dmj`> lethjakman-l: so your type looks like this:
20:53:57 <dmj`> @def data A = B [Int] | C [Int]
20:53:59 <lambdabot>  Defined.
20:54:21 <dmj`> @def as = [ C [1,2,3], C [4,5,6] ]
20:54:22 <lambdabot>  Defined.
20:54:25 <lethjakman-l> More or less, except one's a string, and the other is a nested data structure. 
20:54:41 <dmj`> > join [ cs | C cs <- as ]
20:54:44 <lambdabot>  [1,2,3,4,5,6]
20:55:00 <dmj`> voila
20:55:17 <lethjakman-l> I love it, but I don't think I know those square brackets
20:55:20 <lethjakman-l> How is that working?
20:55:25 <lethjakman-l> Monad..
20:55:29 <dmj`> lethjakman-l: it's really syntactic sugar, since lists are a monad =)
20:55:30 <dmj`> yes
20:55:36 <lethjakman-l> Oh
20:55:37 <lethjakman-l> Ok
20:55:42 <lethjakman-l> And the |?
20:56:01 <lethjakman-l> I feel like I've seen it, but I can't place a name to it. 
20:56:10 <dmj`> > join $ do { C cs <- as; return cs }
20:56:12 <lambdabot>  [1,2,3,4,5,6]
20:56:27 <dmj`> lethjakman-l: that's just like 'return'
20:56:49 <lethjakman-l> So, can I | 20 at the end of a statement?
20:56:57 <dmj`> lethjakman-l: you can also use filtering as more syntactic sugar inside the list (or use let's in the list
20:57:38 <dmj`> lethjakman-l: at the end of which statement?
20:58:12 <dmj`> > join [ cs | C cs <- as, map even xs ]
20:58:16 <lambdabot>  mueval-core: Time limit exceeded
20:58:22 <dmj`> > join [ cs | C cs <- as, map even cs ]
20:58:24 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘[Bool]’
20:58:24 <lambdabot>      In the expression: map even cs
20:58:24 <lambdabot>      In a stmt of a list comprehension: map even cs
20:58:36 <dmj`> > join [ cs | C cs <- as, any even cs ]
20:58:38 <lambdabot>  [1,2,3,4,5,6]
20:58:49 <dmj`> the point is you can use a predicate
20:59:09 <dmj`> lethjakman-l: you mean use a constant like 20? 
20:59:29 <MarcelineVQ> lethjakman-l: https://wiki.haskell.org/List_comprehension
20:59:36 <dmj`> > sum [ 1 | C cs <- as ]
20:59:37 <lethjakman-l> Wait. 
20:59:38 <lambdabot>  2
20:59:39 <lethjakman-l> I did know about those!
20:59:50 <lethjakman-l> Wow, I just haven't used them since I first read LYAH
20:59:58 <dmj`> > sum [ 1 + y | C cs <- as, let y = 1 ]
21:00:00 <lambdabot>  4
21:00:03 <lethjakman-l> dmj`: I did mean | 20
21:00:05 <lethjakman-l> I think this makes senes
21:00:13 <lethjakman-l> dmj` MarcelineVQ 
21:00:15 <lethjakman-l> Thank you!
21:00:32 <dmj`> lethjakman-l: it's handy in aeson when using `object`
21:01:03 <lethjakman-l> dmj`: Funny, this is being used with aeson
21:01:03 <dmj`> object $ [ "id" .= (1 :: Int) ] ++ [ "extra" .= (2 :: Int) | False ]
21:01:16 <lethjakman-l> Sweet!
21:01:17 <dmj`> > [ 4 | False ]
21:01:19 <lambdabot>  []
21:01:28 <dmj`> yea, johnw showed me that trick
21:01:31 <lethjakman-l> I completely forgot about those, and they're so handy. 
21:01:45 <dmj`> yea
21:02:43 <lethjakman-l> So, in aeson you're just using that to filter out values that are false, right?
21:02:46 <dmj`> lethjakman-l: using overloaded lists is nice too, so if you want the performance of vector, but with the interface / feel of using lists
21:02:49 <lethjakman-l> extra doesn't get populated because of the false?
21:02:53 <dmj`> lethjakman-l: yea, based on any condition
21:03:01 <dmj`> lethjakman-l: exactly
21:03:02 <lethjakman-l> what do you mean by overloaded lists?
21:03:19 <dmj`> @typ [ (1, "hey") ] :: Map Int String
21:03:20 <lambdabot>     Not in scope: type constructor or class ‘Map’
21:03:20 <lambdabot>     Perhaps you meant ‘M.Map’ (imported from Data.Map)
21:03:24 <dmj`> @typ [ (1, "hey") ] :: M.Map Int String
21:03:26 <lambdabot>     Couldn't match expected type ‘M.Map Int String’
21:03:26 <lambdabot>                 with actual type ‘[(Integer, [Char])]’
21:03:26 <lambdabot>     In the expression: [(1, "hey")] :: M.Map Int String
21:03:49 <dmj`> lethjakman-l: lambdabot doesn't have it on, but with that extension enabled, you can treat things like maps, vectors, sets, as if they were lists
21:04:07 <dmj`> similar to how overloaded strings let's you treat any string like Text / ByteString
21:04:17 <lethjakman-l> Ooooo
21:04:21 <lethjakman-l> That's awesome. 
21:04:32 <lethjakman-l> When those run it just runs the converter as needed behinds the scenes, right?
21:04:37 <lethjakman-l> So it can be kinda slow after being compiled?
21:04:53 <lethjakman-l> Or is that a bad assumption?
21:05:46 <dmj`> It's just sugar, it won't have impact on runtime performance, it's still a Map
21:06:28 <lethjakman-l> Makes sense. 
21:06:30 <dmj`> lethjakman-l: it's convenience to get around calling toList / fromList everywhere
21:06:53 <lethjakman-l> gotcha
21:06:57 <lethjakman-l> I agree, that seems better. 
21:07:36 <dmj`> it's just a class w/ an associated type family, type Item i
21:18:09 <Lokathor> if a (State g a) is forced to not return a value is there any particular difference between error and fail ?
21:22:43 <polyaletheia> Is there a profunctor equivalent of "(***) :: a b c -> a b' c' -> a (b, b') (c, c')"?
21:23:13 <polyaletheia> I have a type that's a profunctor but not an Arrow.
21:23:18 <polyaletheia> But it can do this.
21:23:45 <polyaletheia> Hoogle didn't find anything.
21:26:21 <Lokathor> polyaletheia, hoogle is sadly incomplete at times
21:26:29 <Lokathor> though i don't know of anything to help you in this case
21:26:44 <polyaletheia> Well, it just might not exist.
21:29:58 <Lokathor> likely
21:57:00 <dpwright> I'm trying to use the "github" package on hackage to query the github API, in particular user information: https://hackage.haskell.org/package/github-0.13.2/docs/Github-Data-Definitions.html#t:DetailedOwner
21:57:11 <dpwright> it uses Aeson in order to decode the returned JSON
21:57:33 <dpwright> but for certain fields, the github API returns a string called "null", which FromJSON then fails to decode
21:58:04 <dpwright> for example, here's my user info: https://api.github.com/users/dpwright -- the "hireable" field is "null"
21:58:40 <dpwright> I'd like to be able to interpret this, for example as False in the case of a boolean or the empty string in the case of "bio" or similar
21:58:51 <dpwright> or as Nothing in the case of a Maybe
21:59:03 <Lokathor> sounds like you'd need to write a custom fromJSON instance?
21:59:22 <dpwright> my question is -- should this be easy enough to do, and will I have to hack the github package to do it?
21:59:41 <Lokathor> does the github package already have its own FromJSON defined?
21:59:55 <Lokathor> if so, you might have to hack the github package :/
22:00:52 <dpwright> it does: https://hackage.haskell.org/package/github-0.13.2/docs/src/Github-Data.html
22:01:51 <borromakot> Is this a good place to ask beginner level questions?  I'm an experienced programmer, but new to haskell.
22:02:21 <Lokathor> borromakot, here is good, there's also a #haskell-beginners that's friendly as well
22:02:51 <Pamelloes> join is a pretty nifty function :)
22:02:52 <Cale> (but this channel is also for beginners)
22:03:01 <borromakot> I'll ask this here, and then switch over to there :D
22:03:16 <borromakot> How can I destructure a data type in a pattern match?
22:03:20 <Cale> I hate the #haskell-beginners' name just because it makes people think that this isn't an appropriate channel for beginners
22:03:49 <borromakot> e.g : type Point = (Rational, Rational)
22:04:00 <dpwright> is "null" a standard thing in JSON?
22:04:18 <Lokathor> borromakot, usually you use the constructor you used to build it up. so you'd do something like, getPointX (x,y) = x
22:04:32 <Lokathor> since (,) is how you made the Point
22:04:41 <Cale> borromakot: So you could  case pt of (x,y) -> ...  or if you're defining a function Point -> ..., you could write something like   f (x,y) = ...
22:05:02 <borromakot> Trying now
22:05:03 <Lokathor> record types are a little different, but similar idea
22:05:22 <borromakot> yeah, actually, what I'm doing is this one : `data Line  = Ln (Rational, Rational)`
22:05:32 <borromakot> and I'm trying to match `Line (x1, y1)`
22:05:56 <Lokathor> oh, you should match Ln not Line
22:06:02 <Lokathor> since Ln is the data constructor there
22:06:19 <borromakot> Doh!
22:06:26 <Lokathor> getX (Ln (x,y)) = x
22:06:56 <Lokathor> you also have to put parens if it's got a space in it, so that GHC doesn't get confused
22:07:47 <Lokathor> dpwright, looks like the FromJSON for github is using (.:?) which should already be returning a Maybe a
22:07:56 <dpwright> these values are maybe values obtained with `.:?`, which it feels like Aeson should interpret Nothing in the case of null
22:08:11 <dpwright> interpret as*
22:08:35 <dpwright> but as far as I can tell, it's interpreting it as having the field and then not being able to convert it to bool
22:09:31 <Lokathor> (.:?) says "The result is Nothing if the key is not present, or empty if the value cannot be converted to the desired type."
22:10:02 <Lokathor> so i guess it depends on what the "empty" value is in the situation?
22:11:02 <liste> :t empty
22:11:05 <lambdabot> Alternative f => f a
22:11:25 <liste> Lokathor I think it means that
22:11:54 <Lokathor> yeah, sorry, the hyperlink doesn't paste into IRC :P
22:12:07 <Lokathor> but in the docs it's a hyperlink to that definition
22:17:28 <dpwright> Lokathor: thanks
22:18:09 <dpwright> yeah, pretty sure Bool doesn't have an Alternative instance... 
22:18:50 <dpwright> kinda surprised the JSON Null type, which is represented in Aeson as Null, is treated differently from the key not being present
22:19:10 <dpwright> I guess it *is* different, but it feels like you'd usually want (.:?) to treat those two things as the same
22:19:56 <Lokathor> you could do the Evil Thing and give Bool an orphan Alternative instance where empty = False
22:20:13 <Lokathor> but that would probably be bad in a cleanlyness sense
22:20:44 <dpwright> I don't think I could, because it's the wrong kind
22:21:23 <neuroserpens> Has anyone here ever tried ajhc? Do you recommend it?
22:21:55 <Lokathor> oh right, because it comes from Applicative
22:22:17 <dpwright> right
22:22:35 <liste> neuroserpens http://ajhc.metasepi.org/ <-- the first paragraph
22:23:04 <neuroserpens> liste: o shit
22:23:19 <neuroserpens> liste: alright lol. jhc then... is it good?
22:23:31 <dpwright> https://github.com/bos/aeson/issues/287 <-- looks relevant
22:23:50 <dpwright> (to my aeson null issue... not to ajhc, sorry)
22:28:40 <paaavo> Hey. I'm back with some more problems with Aeson.
22:28:56 <Lokathor> a theme tonight
22:30:31 <paaavo> When I start up "ghci -XOverloadedStrings", import Data.Aeson, and do a "eitherDecode "\"Hello\"" :: Either String String", I get what I want, which is "Right "Hello"". But when I do the same, but within a "stack ghci --ghc-options -XOverloadedStrings" within my project, I get "Left "Failed reading: satisfy"".
22:30:41 <paaavo> What could be causing that?
22:31:22 <paaavo> Something with stack, or could my project somehow mess with how Aeson works, even if I don't import any modules?
22:32:03 <geekosaur> ghci doesn't use a sandbox; stack always uses a sandbox. which means you might have different versions of aeson in each
22:32:37 <paaavo> How do I check what the versions of each are?
22:33:03 <dpwright> Sure enough, switching to Aeson 0.9.0.1 fixed my problem
22:34:02 <dpwright> also changing all the lines like 'o .:? "hireable"' to read 'o .:? "hireable" .!= Nothing' in the github package would also work
22:34:08 <dpwright> but for now I'll just use the older Aeson
22:34:15 <dpwright> thanks Lokathor, liste!
22:36:46 <geekosaur> sorry, I'm not ignoring you, I want to doublecheck stack but my local network is doing this charming thing where established connections are fine but SYN packets are dropped x.x
22:37:17 <geekosaur> (I don;t have it installed on this machine. it's also got an ancient ghc...)
22:37:28 <paaavo> Looks like stackage has 0.8.0.2, and my cabal install version is 0.9.0.1.
22:37:53 <paaavo> I'll see if I can get stack to install the newer version, and see if that helps.
22:45:23 <paaavo> New Aeson version fixed it. Thanks, geekosaur!
