00:03:35 <soorya> Hey guys, I've just finished the Learn you a haskell tutorial. I'm now looking for some small haskell projects to work on. Any suggestions?
00:03:59 <christi> soorya: https://projecteuler.net
00:04:00 <jle`> nocturne777: i usually use type synonyms for things like that, unless it becomes really important to newtype
00:04:12 <jle`> hm, i wouldn't consider project euler a helpful resource for haskell projects to work on
00:04:16 <jle`> they don't really help you learn how to program
00:04:35 <jle`> they help you learn how to solve obscure math problems.  which is fun, but might be sort of the opposite of what you want if you want to learn how to work on a real world project
00:05:04 <soorya> I've done project euler problems using python. I'm looking more for an application to build
00:05:37 <jle`> some people go into web projects, or also maybe command line utilities?  i made a small blog.  command line hangman is also a cute project some people recommend
00:06:19 <nocturne777> web projects are helpful
00:06:46 <soorya> haha, nice. I'd like to do a web based one.
00:06:46 <soorya> Any frameworks in mind? 
00:07:16 <nocturne777> before that I also wrote a small text based game to do something without having to learn any extra libraries
00:07:35 <nocturne777> soorya: I like Snap framework
00:08:01 * hackagebot huckleberry 0.9.0.1 - IchigoJam BASIC expressed in Haskell.  https://hackage.haskell.org/package/huckleberry-0.9.0.1 (tkmsm)
00:08:03 * hackagebot git-fmt 0.3.1.0 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.3.1.0 (hjwylde)
00:08:58 <MarcelineVQ> nocturne777: if you're looking at web projects check out servant when you have a chance, it's quite neat
00:10:29 <jle`> soorya: actually, one thing a lot of people suggest is, "do what your next programming project would have been in another language, but do it in haskell"
00:10:36 <jle`> or, "re-write your old programming projects in other languages in haskell"
00:10:46 <jle`> one benefit is that you get to see how concepts translate, and you also don't have to learn a whole new domain
00:10:58 <Lokathor> soorya, clearly you should re-implement nethack in haskell
00:11:00 <jle`> also, you get to see how haskell benefits *all* aspects of programming
00:11:12 <jle`> and not just certain things that people usually say are "haskell killer apps"
00:13:22 <bb010g> soorya: Spock and Servant are neat
00:13:26 <soorya> Thanks for the suggestions, guys. Snap seems really neat.
00:14:02 <lpaste> jle` pasted “type-safe optional fields” at http://lpaste.net/146138
00:14:14 <jle`> ^^ i've been doing both of these now, nocturne777 
00:14:18 <ongy> what's the prefered way to write tests for a cabal package?
00:14:21 <jle`> i'm not sure if they're actually good idea,s but they've worked for me :)
00:14:24 <bb010g> jle`: Isn't someone doing a Haskell dungeon crawler?
00:14:44 <jle`> if you're doing games, try heading over to #haskell-game
00:14:50 <ongy> the documentation suggests the detailed-0.9 interface, but that's just the interface, is there a nice suit that can be used with this interface?
00:15:14 <jle`> yeah i think there are a few people toying with haskell rogue likes.  it's actaully been a tricky problem to nail in a non-imperative way
00:15:24 <jle`> i gave it an effort
00:15:50 <jle`> but!
00:15:55 <jle`> it's perfectly okay to write imperative haskell code
00:16:00 <jle`> and haskell is really good at writing imperative code
00:16:18 <jle`> an imperatively written roguelike in haskell is surprisingly delightful
00:16:38 <MarcelineVQ> Take it farther, use haskell to write your game in c.
00:17:08 <bb010g> Yeah, people need to remember that more often. Yes, it may not the the greatest thing ever, but it's still nice.
00:17:15 <soorya> MarcelineVQ : How would one do that?
00:17:52 <bb010g> MarcelineVQ: Resurrect Pugs and write your game in Perl 6 in Haskell
00:17:53 <MarcelineVQ> soorya: A wonderful question that I don't have an answer for, I bet other people here have good suggestions though
00:18:46 <bb010g> http://hackage.haskell.org/package/copilot
00:19:13 <nocturne777> jle`: when declaring smart constructs, we also not expose the data constructor itself. but in this case, we might have to type out the accessors ourselves. to get the accessers auto-generated in this case, do you think it is a good idea to use lenses?
00:19:36 <bb010g> http://hackage.haskell.org/package/language-objc
00:23:50 <lpaste> jle` revised “type-safe optional fields”: “No title” at http://lpaste.net/146138
00:24:07 <jle`> ^ a third method using servant-style data families.  again, not sure if this is a good idea yet :)
00:24:18 <jle`> nocturne777: in which case do you mean?
00:24:33 <jle`> s/data families/type families
00:25:15 <jle`> in the third method you lose the ability to pattern match, but you only have one constructor
00:25:25 <nocturne777> jle`: in the case of smart constructors where we only expose the constructor function and accessors
00:25:33 <jle`> oh ah
00:25:52 <jle`> yeah, one thing people use with lenses is to create future-proof constructors and accessors
00:26:14 <jle`> expose your constructors and accessors as lenses only, and you can feel free to vary the actual structure of your data type
00:26:27 <jle`> and then adjust your constructing/accessing lenses accordingly
00:27:11 <jle`> i feel like the smart constructor pattern is also captured nicely in the idea of a Prism
00:27:22 <jle`> but i don't have the confidence/authority to say this for sure
00:27:45 <jle`> actually wait, i'm wrong i think, i was mixing two ideas together
00:30:50 <gfixler1> I finally understand https://en.wikipedia.org/wiki/Up_to
00:30:53 <nocturne777> jle`: I think thse methods would work if the number of varying fields is one or two, but if it is more than two, it can get very unwieldy
00:31:12 <gfixler1> when people say "Up to X", they're probably just saying "modulo X"
00:31:18 <jle`> nocturne777: you mean, besides UUID?
00:31:25 <nocturne777> jle`: yeap
00:31:41 <nocturne777> In my case I am also getting the current time from the system
00:31:54 <jle`> maybe instead of UUID, you can parameterized on "fully initialized"
00:32:07 <jle`> data InitState = UnInitted | Initted
00:32:25 <jle`> and then have one constructor with all of the unitted "raw json" data, and one constructor with the expected fully initted data
00:32:50 <nocturne777> jle`: I think that sounds better and simpler
00:33:16 <jle`> i meant that in, that's the same thing as was described in the pastes
00:34:08 <jle`> method #2 is sort of roughly the same as having two data types instead of two constructors; the nice thing is that you get "three data types for free" with the GADTs
00:34:46 <bb010g> gfixler1: Any progress on the editor?
00:34:54 <nocturne777> I thought with your last example you meant something like: data NewAccount = UnInittedNewAccount{...} | InittedNewAccount{...}
00:34:54 <gfixler1> bb010g: yeah, almost done!
00:35:16 <bb010g> Is it on your GitHub?
00:35:23 <jle`> instead of creating a NewAccountUnInit type, a NewAccountInit type, and an (Either NewAccountUnInit NewAccountInit) type, you get all of them at once --- they are, respectively, NewAccount UnInit, NewAccountInit, and NewAccount a
00:35:27 <gfixler1> bb010g: where almost done = haven't begun
00:35:34 <buckmaster> soorya: if you're going web, consider starting off with no framework, just sit on WAI. Its API is really small and nice
00:35:42 <buckmaster> though I guess some may consider it a framework already :p
00:36:08 <jle`> nocturne777: yeah, i meant, as a modification of the second example, data NewAccount where UnInitedNewAccount {..} -> NewAccount UnInitted; InittedNewAccount {..} -> NewAccountInitted
00:36:17 <bb010g> WAI + Spock is nice too if you want simple.
00:36:19 <jle`> s/NewAccountInitted/NewAccount Initted
00:37:09 <jle`> it's functionally identical to having two separate data types -- NewAccountUnInitted and NewAccountUnInitted, and Either NewAccountInitted NewAccountInitted.  Except now you get all three for the price of one :)
00:38:03 <jle`> you'd be writing JSON instances for `NewAccount UnInitted`, and then providing a function `initAccount :: NewAccount UnInitted -> IO (NewAccountinitted)`
00:38:16 <jle`> er, initAccount :: NewAccount UnInit -> IO (NewAccount Init)
00:39:01 <jle`> now all of your functions that expect an initialized account will take NewAccount Init.  and all of your functions that are supposed to be able to handle both cases can take NewAccount a
00:39:17 <jle`> (and take advantage of good ol' fashioned pattern matching, too)
00:41:45 <nocturne777> jle`: hmm, that sounds neat actually.
00:42:13 <nocturne777> I need to digest the bit about GADT as I have never used them before
00:44:28 <nocturne777> jle`: I am getting this error: Constructors NewAccountNoID and NewAccountID have a common field  newAccUserName but have different result types
00:44:49 <nocturne777> I wanted to play with that seconds example
00:45:17 <lpaste> jle` pasted “GADT account sketch” at http://lpaste.net/146140
00:45:40 <jle`> ^ nocturne777: that's the second example expanded with what i just said in a nicer format
00:46:06 <jle`> hm ah, i guess with GADTs they don't let constructors share field names
00:48:10 <jle`> if you want, you can pull all the extra initializable stuff to its own data type with two constructors, and have it be a field in the NewAccount constructor.  but, at that point it might become less clearly more useful than the old fashioned make-three-data-types approach
00:49:05 <jle`> this is a case where, if you don't mind cute sugar tricks like RecordWildCards, having your only accessors be in the form of lenses is useful :)
00:49:44 <jle`> as in, ditching record syntax altogether and using lenses for all your accessors.  which i understand is not always the most ideal
00:50:20 <nocturne777> hmm I see
00:51:35 <jle`> a lot of people *do* go full-lens though
00:51:47 <jle`> because constructors and records are not future-proof
00:52:08 <jle`> and going full-lens for everything is nice...you just lose cute things like RecordWildCards
00:52:50 <jle`> but it has been said that too much sugar can lead to toothache :)
00:56:54 <nocturne777> jle`: I don't understand why we need GADTs for this. maybe is it because I have no experience with them yet.
00:57:26 <jle`> you need GADT's because it's the only way to make the type of your data dependent on the constructor you use
00:57:44 <nocturne777> but why would something like this wouldn't work: data NewAccount = UnInitNewAccount {newName :: Text} | InitNewAccount {newName :: Text, newId :: UUID}
00:57:59 <jle`> because in the GADT version, the type of what you produce depends on your constructor
00:58:06 <jle`> the UnInitNewAccount creates a NewAccount UnInit
00:58:13 <jle`> the InitNewAccount creates a NewAccount Init
00:58:31 <jle`> those are two separate types, and can't be interchanged
00:58:50 <jle`> you can't use a NewAccount UnInit where a function is expecting a NewAccount Init
00:59:31 <jle`> it's almost *as if* you had created two types: data NewAccountUnInit = UnInitNewAccount { .. }, and data NewAccountInit = InitNewAccount { .. }
00:59:48 <jle`> if a function is expecting a NewAccountInit, you can't pass it a NewAccountUnInit
01:00:34 <jle`> it's actually more or less identical to the two-data-types approach.  only you sort of get a nice way to write functions polymorphic over both cases...like the `isInit` function i included in the last example
01:02:19 <nocturne777> jle`: with the version I just pasted you can provide the wrong parameter to the function (e.g., UnInitNewAccount instead of InitNewAccount), but the type checking is moved to the pattern matching
01:02:44 <jle`> where is the paste?
01:02:50 <CitizenNine> Join ##COTW 
01:03:17 <nocturne777> jle`:  data NewAccount = UnInitNewAccount {newName :: Text} | InitNewAccount {newName :: Text, newId :: UUID}
01:03:36 <jle`> ah, yes
01:03:49 <jle`> the checking is moved from compile-time to run-time
01:04:43 <jle`> if your function is only meant to handle initialized NewAccounts, then GHC will verify that you will only ever pass in initilaized NewAccounts, and you doin't have to handle the case where it's un-initialized
01:05:07 <jle`> but with the non-GADT way, your functions also have to handle the uninitialized case, because it can only determine at run-time
01:05:11 <jle`> using pattern matching
01:05:15 <nocturne777> yeap
01:06:49 <jle`> like i said, the goal is to get the same sort of type-safety as you would have as if you had created two completely unrelated data types -- one for an initialized newaccount, and one for an uninitialized one.  except now it's more convenient because they're merged into one type
01:07:05 <nocturne777> jle`: you were saying that I might have to give up the record syntax in this case and use lenses instead. but from what I am aware, we cannot have lens functions with the same name either
01:07:17 <jle`> what do you mean?
01:07:37 <jle`> newName :: Lens (NewAccount a) Text
01:07:53 <nocturne777> oh I see
01:07:57 <jle`> newName f (UnInitNewAccount s) = UnInitNewAccount <$> f s
01:08:14 <jle`> newName f (InitAccount i s) = InitAccount i <$> f s
01:08:59 <jle`> admittedly writing them by hand is a bit of a pain, heh :|
01:09:42 <jle`> but idk about you i find some sort of serene joy/peace from writing traversals/lenses by hand
01:09:59 <nocturne777> hopefully, I won't have to do that a lot
01:10:04 <jle`> ...this is the first time i've admitted this out loud, i'm not sure if anybody agrees with me
01:10:18 <jle`> writing traversals by hand is an eerily calming activity
01:10:37 <Lokathor> well any slow and obvious activity can be calming, usually
01:11:17 <nocturne777> :)
01:11:35 <jle`> but yeah, this would be considered a "con" of this method...except, if you consider "future proofing", this is something that you would have had to have done eventually, anyways, at some point or another, if you ever decide to change the structure of your data type but provide the same lenses.  but whether or not this is important depends on the scope of your project
01:12:29 <jle`> sometimes going for extreme levels of infrastructure might be bad if you know that the project will never get to a level where you'd need it
01:12:55 <nocturne777> anyway, I gotta go to bed now :). thanks a lot for your help, jle` 
01:13:15 <jle`> np! and like i said this is just a couple of things i've been trying
01:13:47 <jle`> there's always method #1 too, which is fairly cheap, and you can get auto-derived lenses too
01:13:49 <jle`> oh they're gone
01:57:44 <pavonia> Why is there no type-level $ operator? :S
02:12:43 <mauke> @let type f $ x = f x
02:12:44 <lambdabot>  Defined.
02:12:59 <mauke> > Nothing :: Maybe $ Int
02:13:00 <lambdabot>  Nothing
02:18:48 <pavonia> > undefined :: IO $ Either String Int
02:18:49 <lambdabot>  <IO (Either [Char] Int)>
02:19:17 <pavonia> Nice, I didn't know you can have these operators
02:19:46 <pavonia> So only data constructors have to start with a colon?
02:25:36 <s4ke> hi
02:25:49 <s4ke> can someone help me with the functor implementation of a monadtransformer?
02:26:08 <s4ke> damn wrong question :D
02:26:14 <s4ke> i need the functor instance for this newtype Op m a = Op { runOp :: Stack -> m (a, Stack, String) }
02:26:52 <s4ke> this shouldnt be that hard, i know, but the types are somewhat weird... 
02:27:21 <s4ke> i have something along the lines of this Op $ \stack -> [dunno what goes here]
02:28:09 <mpickering> something like (fmap f (Op m)) = Op \stack -> let (a, stack', s) = m stack in (f a, stack', s)
02:28:41 <mpickering> you should try using type holes to help yourself out! they are very useful
02:28:45 <jle`> s4ke: have you tried playing with typed holes?
02:28:57 <s4ke> no
02:29:03 <jle`> they def help here :)
02:29:13 <jle`> oops mpickering just mentioned it right before me
02:29:43 <mpickering> So you might start out with "fmap f (Op m)) = Op (\stack -> _)"
02:29:46 <pavonia> Don't you need a constraint for m here?
02:30:14 <mpickering> it will tell you that the hole should have type m (b Stack, String) and the types of a few things in scope
02:31:16 <s4ke> ah cool stuff.:)
02:31:31 <s4ke> btw mpickering: your statement was not correct at least thats what my compiler told me
02:31:51 <jle`> but yeah, you're going to eventually need a Functor constraint at least, on m
02:32:12 <mpickering> yes, what I wrote wasn;t quite right but you can try and work it out now :)
02:32:25 <s4ke> ok thx :)
02:32:28 <mpickering> jle`'s hint should be useful
02:32:32 <jle`> at one point you're going to have an `m (a, Stack, String)`, and then you're going to need to turn it into an `m (b, Stack, String)`, and you have an (a -> b) at your disposal
02:32:37 <jle`> so, fmap to the rescue :)
02:32:40 <s4ke> i have a monad constraint
02:32:58 <jle`> a Monad constraint is also going to work too, but it's a bit arbitrarily limiting
02:33:14 <jle`> but yeah, trying it with a Monad constraint is a nice first step too :)
02:33:24 <s4ke> ok
02:33:45 <s4ke> damn. i really have to start working on my real projects. but trying to fix my haskell program is so much more fun
02:33:56 <jle`> i say limiting because there are lots of things that are Functors and not Monads, but it'd still be nice to have a Functor instance for `Op m` for m's that are just Functors/Applicatives
02:34:11 <jle`> if you constrain it over Monad, it won't work for all the useful m's
02:34:34 <jle`> (it will work for most of them you'll run into in practice, admittedly)
02:35:12 <echo-area> Has GHC supported specifying `type` declarations injective now?
02:35:16 <s4ke> so, the "m stack" part what does it do exactly
02:35:16 <jle`> still, writing it specifically for Monad and then refactoring it later to work for all Functor is definitely a common route too
02:35:47 <s4ke> because i have a hunch that "(a, stack', s) = m stack" is not completely correct
02:35:50 <jle`> s4ke: it applies the function `m` to the value `stack
02:35:57 <jle`> even though you do'nt get a tuple in response
02:36:00 <jle`> that's why it doesn't quite work
02:36:10 <s4ke> but m is the internal functor
02:36:11 <jle`> also, `m` might not be the best name for a function, heh
02:36:18 <jle`> are you sure?
02:36:21 <s4ke> yes
02:36:30 <jle`> it's a bit confusing because the same letter is used for the type, and also for the value
02:36:34 <jle`> fmap f (Op m) = ...
02:36:42 <s4ke> ah 
02:36:43 <jle`> m is a function here of type Stack -> m (a, Stack, String)
02:36:44 <s4ke> damn it :D
02:36:54 <jle`> yeah, it wouldn't have been my first choice for the name of a function, heh
02:37:20 <jle`> try fmap f o = Op $ \stack -> _
02:37:23 <jle`> that's a nice place to start
02:37:33 <jle`> for fmap f op = Op $ \stack -> _
02:37:49 <jle`> ghc will tell you that _ should be of type `m (b, Stack, String)`
02:38:48 <s4ke> hmm. if i run "o stack" i get m (a, Stack, String)
02:38:57 <s4ke> how do i write that as a let statement
02:38:59 <jle`> you probably mean `runOp o stack`
02:39:06 <jle`> i wouldn't write that as a let statement here
02:39:12 <jle`> your final result is m (b, Stack, String)
02:39:17 <jle`> and you're constraining over Monads
02:39:22 <jle`> so one nice thing is you can use do notation :)
02:39:29 <jle`> fmap f o = Op $ \stack -> do
02:39:39 <jle`>     (x, stck, str) <- runOp o stack
02:39:55 <jle`> x :: a, and you happen to have a very nice (a -> b) function at your disposal :)
02:39:57 <s4ke> but the tuple is no monad
02:40:19 <jle`> runOp o stack :: m (a, Stack, String)
02:40:23 <jle`> the do block is in the `m` Monad
02:40:27 <jle`> not the tuple
02:40:28 <s4ke> ah yeah
02:40:30 <s4ke> ...
02:40:31 <s4ke> right
02:40:43 <jle`> and the final result should be m (b, Stack, String)
02:41:06 <jle`> and you have a very nice Stack you can use -- stck.  and a very nice String you can use -- str.  and you don't have a `b`, but you have an `a` and a `a -> b`
02:41:26 <jle`> btw, this is basically what using typed holes will tell you :)
02:41:30 <s4ke> well, the next statement then is (f x, stack, str) ?
02:41:34 <jle`> quite
02:41:37 <jle`> *close
02:41:49 <jle`> but that's (b, stack, str).  but you want m (b, stack, str)
02:42:01 <s4ke> return
02:42:04 <jle`> (GHC will also tell you this.  i should probably be letting you figure out how to listen to the compiler :) )
02:42:22 <s4ke> hey, works :D
02:42:24 <s4ke> thanks :)
02:42:29 <jle`> np!
02:42:51 <jle`> i would also consider trying to re-write it without do notation, to see if you can get with just a Functor constraint :)
02:42:56 <s4ke> and now i need to do this for applicative as well, but i guess i will try the _ usages
02:43:06 <s4ke> jle` yep
02:43:34 <s4ke> how can i write that then? my main problem is that i dont know how i express the m without the do noation
02:43:36 <s4ke> notation
02:43:46 <jle`> yeah.  if you had started off with what i said first, GHC would basically tell you: m (b, Stack, String) needed.  you have an `Op m a`, a `Op m a -> Stack -> m (a, Stack, String)`, a `Stack`, and an `a -> b`
02:44:02 <arianvp> kosmikus: Weren't you here this week?
02:44:13 <jle`> s4ke: well, once you have `runOp op stack`, you have a `m (a, Stack, String)`
02:44:25 <arianvp> I mean. Aren't you here next week?
02:44:31 <jle`> you can "fmap" over that, to get an `m (b, Stack, String)` :)
02:44:48 <s4ke> ah man...
02:44:55 <jle`> fmap an `(a, Stack, String) -> (b, Stack, String)` function over it.
02:45:05 <jle`> you can probably write one using pattern matching
02:45:19 <s4ke> ah i tried to use fmap on its own
02:45:26 <s4ke> and was puzzled why it didnt work
02:45:28 <jle`> fmap (\(x,stck,str) -> (f x, stck, str)) (runOp op stack)
02:45:36 <s4ke> well, that makes the case easier :D
02:46:05 <jle`> you *should* also be able to do the Applicative instance with only an Applicative constraint
02:46:15 <jle`> but admittedly it's a bit trickier than the Functor instance
02:46:19 <jle`> but i believe in you :)
02:46:49 <s4ke> you helped me a bunch thanks :)
02:47:03 <jle`> start with a Monad constraint first if the Applicative one is difficult; the Monad version with do notation works itself very similarly to the Functor instance
02:47:06 <jle`> np!
02:47:12 <s4ke> but i guess i will have to call it a day for haskell. got other stuff to do next :D
02:47:32 <jle`> have fun!
02:47:41 <s4ke> i guess i will need to read up more on the exact meaning of the aplicative functions first
02:47:45 <s4ke> i guess that will help me 
02:48:58 <s4ke> ah well. seems like i already had the rest :D
02:49:12 <s4ke> the only thing missing was the functor instance
02:49:28 <jle`> well
02:49:48 <jle`> if you want, you can implement the Monad instance first
02:50:01 <jle`> and then write instance Applicative (Op m) where pure = return; (<*>) = ap
02:50:16 <jle`> that way you get the Applicative instance without doing any extra thought
02:50:25 <jle`> you could have also done Functor this way too; instance Functor (Op m) where fmap = liftM
02:50:43 <jle`> liftM is fmap defined in terms of (>>=) and return; ap is (<*>) defined in terms of (>>=) and return
02:50:50 <s4ke> fmap = liftM didnt work for some reason
02:50:52 <jle`> but kudos for toughing it out :)
02:51:01 <jle`> yeah, it'll require a Monad constraint on `m`
02:51:13 <jle`> because liftM uses (>>=) and `return` to implement an fmap
02:51:39 <s4ke> quick question (i guess i will not work today :D:D)
02:51:49 <jle`> if you're doing "real world haskell", then it might be okay to just leave it as this and then go on to doing the rest of your application
02:51:56 <arianvp> woops wrong chat
02:52:12 <jle`> you might pay a slight price in efficiency, because a well tuned Functor instance will usually be better than `liftM` from the Monad instance
02:52:13 <s4ke> i want to know the language, real world is for suckers
02:52:22 <jle`> haha, okay then
02:52:23 <s4ke> :D
02:52:27 <jle`> :D
02:58:52 <s4ke> every applicative is a functor right?
02:59:44 <jle`> yes, every instance of Applicative is also an instance of Functor
03:00:11 <s4ke> so a pure implementation using only Applicative will use fmap right?
03:00:57 <jle`> not necessarily
03:01:03 <jle`> you *can* use fmap
03:01:23 <jle`> but, consider:
03:01:29 <jle`> instance Applicative Maybe where pure x = Just x
03:02:03 <jle`> instance Applicative [] where pure x = [x]
03:02:54 <jle`> fmap probably wouldn't be very useful in an implementation for `pure`, considering that, in a parametrically polymorphic setting, you use fmap to "change" type parameters
03:02:57 <s4ke> Op $ \stack -> (a, stack, "")
03:03:02 <s4ke> not quite
03:03:05 <jle`> close
03:03:07 <jle`> what does GHC tell you?
03:03:37 <jle`> btw, i recommend against using `a` for both your type variable and your function's argument name, heh
03:03:43 <s4ke> pure a = Op $ \stack -> (a, stack, _): found holw with type (a, Stack, String)
03:04:34 <jle`> oh that's definitely not a helpful suggestion, heh
03:04:36 <jle`> oops
03:04:50 <jle`> pure x = Op $ \stack -> (a, stack, "")   -- what error does this give you?
03:05:18 <s4ke> couldnt match expected type (a, Stack, String) with [Char]
03:05:42 <jle`> oh wow that's an awful error
03:05:49 <s4ke> yep :D
03:05:52 <jle`> i'm sorry
03:05:54 <jle`> :(
03:06:02 <s4ke> for what?
03:06:10 <jle`> anyways, the problem is that you have an (a, Stack, String), but you need an `m (a, Stack, String)`
03:06:23 <jle`> that the error is so bizarrely unhelpful.  you've hit a really obscure edge case, heh
03:06:30 <s4ke> hah
03:06:31 <s4ke> got it
03:06:32 <s4ke> prue
03:06:32 <s4ke> :D
03:06:33 <s4ke> pure
03:06:38 <s4ke> pure x = Op $ \stack -> pure (x, stack, "")
03:06:42 <jle`> in this case everything sort of came together to give an unbelievably coincidentally awful error message
03:06:54 <jle`> like, all of the pieces fit together to create the perfect storm
03:07:19 <s4ke> if i have a applicative that is wrapped in my applicative i obviously have to use its pure at some point
03:07:40 <jle`> the problem was that it saw that `(x, stack, "")`, and it took its type to be `(,,) a Stack String`
03:08:17 <s4ke> only <*> left :D
03:08:18 <jle`> it tried to match `((,,) a Stack) String` with `m (a, Stack, String)`, and matched the `m` with `(,,) a Stack`.  so then it tried to match (a, Stack, String) with String
03:08:29 <jle`> this is the first time i've seen an error message like this, heh
03:08:38 <s4ke> i am good at producing these
03:08:56 <jle`> good talent to have :)
03:09:08 <s4ke> :D
03:09:33 <jle`> if you're not comfortable with reasoning in terms of (<*>) yet, you can always do it with do notation first, and then consider how to do it using (<*>)
03:09:52 <s4ke> i want to learn how to reason in <*>
03:09:58 <jle`> i honestly don't like thinking in terms of <*>
03:10:04 <jle`> i like thinking in terms of `liftA2`
03:10:12 <s4ke> whats that?
03:10:13 <jle`> liftA2 is the true primitive of Applicative to me, heh
03:10:27 <jle`> liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
03:10:40 <jle`> if you have an `f a` and an `f b`, you can "squish" them together with an (a -> b -> c) function
03:10:42 <jle`> to get an `f c`
03:10:51 <jle`> this is the true spirit of Applicative, to me
03:11:04 <jle`> being able to squish together f a's and f b's
03:11:07 <s4ke> well <*> is a level above that right?
03:11:14 <jle`> not quite; they're equivalent
03:11:27 <s4ke> huh
03:11:32 <gfixler1> no one ever talks about how <$>, <*>, and =<< are all just fancy forms of $
03:12:09 <jle`> (<*>) = liftA2 ($), and liftA2 f x y = pure f <*> x <*> y
03:12:33 <jle`> thinking of (=<<) as a fancy ($) works well for implementing Monad instances
03:13:06 <s4ke> i think i know how to implement them with >>=
03:13:12 <jle`> but in terms of Appliative instances, liftA2 is the easiest thing for me to imagine
03:13:17 <jle`> in terms of what my instance would even mean
03:13:21 <gfixler1> jle`: I can see that
03:13:56 <jle`> i usually mentally implement liftA2, heh, when I write my Applicative instances
03:14:06 <s4ke> where does liftA2 lie?
03:14:08 <gfixler1> > Just (*) <*> Just 3 <*> Just 2
03:14:09 <lambdabot>  Just 6
03:14:15 <jle`> and then inline f = ($)
03:14:23 <jle`> s4ke: it's in Control.Applicative
03:14:52 <gfixler1> > [id,const "foo",reverse] <*> ["bar","baz","quux"]
03:14:53 <lambdabot>  ["bar","baz","quux","foo","foo","foo","rab","zab","xuuq"]
03:15:00 <jle`> but yeah, you can't really implement liftA2 directly, so you're stuck with implenting <*>, so, might as well also grow an intuition for it
03:15:33 <gfixler1> jle`: I've been fighting to, so now I think it takes about on the level of <*> for me
03:15:42 <gfixler1> I mean liftA2 and <*> are similar in difficulty for me now
03:16:14 <s4ke> <*> f fx = _ gives me Op m b
03:16:31 <jle`> try opF <*> opX = Op $ \stack -> _
03:16:42 <gfixler1> > ((*) <*> (const 3) <*> (+5)) 2
03:16:43 <lambdabot>      Occurs check: cannot construct the infinite type: a0 ~ a0 -> b
03:16:43 <lambdabot>      Expected type: (a0 -> b) -> a0
03:16:43 <lambdabot>        Actual type: a0 -> a0
03:16:46 <gfixler1> aww
03:17:02 <gfixler1> I guess I'm not the master of <*> yet
03:17:09 <jle`> s4ke: in your case, you're dealing with a state kinda type, where every `Op a` represents a stateful "action" that produces an `a`
03:17:24 <jle`> s4ke: for these sorts of types, <*> represents the idea of "sequencing" two actions together
03:17:37 <s4ke> hence "sequential application"
03:17:45 <s4ke> but if i look at the type it just is weird
03:17:53 <s4ke> f (a -> b) in my case is what?
03:18:01 <jle`> opF <*> opX means, "do opF, then do opX, and the result is the function you got from opF applied to the function you got from opX"
03:18:02 <gfixler1> sequencing? In my applicative?
03:18:22 <jle`> sequencing isn't Applicatives in general, but it's a way to describe the action of <*> on this particular type
03:18:32 <jle`> s4ke: f (a -> b) here is an Op that "produces" an (a -> b) when it is run
03:18:41 * gfixler1 withdraws his objection
03:19:09 <jle`> s4ke: how about this --- liftA2 f opX opY means, "do opX, then do opY...and return `f` applied to the values of both"
03:19:28 <jle`> do them one after the other, and "combine" their results with `f`
03:19:54 <gfixler1> oh, duh
03:20:00 <gfixler1> > ((const (*)) <*> (const 3) <*> (+5)) 2
03:20:01 <lambdabot>  21
03:20:04 <jle`> so, (<*>) = liftA2 ($).  opF <*> opX is "do opF, and do opX.  combine their results by applying the function you got from opF to the value you got from opX"
03:20:09 * gfixler1 is now the master of <*>
03:20:49 <s4ke> yeah. but that doesnt really help me when implementing <*> from scratch
03:20:52 <s4ke> right?
03:20:56 <jle`> sort of
03:21:10 <jle`> you can now think about, how to "execute" opF, then how to "execute" opX
03:21:46 <jle`> and then return the function you got from opF to the value you got from opX
03:22:00 <jle`> to me, this is a lot easier to think about in terms of do notation
03:22:11 <s4ke> but with f ( a -> b) -> f a -> f b what are the types of opF and opX?
03:22:13 <jle`> but i do have to go to sleep :)  good luck the rest of your haskell journey
03:22:20 <s4ke> hmm ok
03:22:24 <s4ke> good night
03:22:32 <jle`> (<*>) :: Op m (a -> b) -> Op m a -> Op m b
03:23:09 <jle`> given an Op m (a -> b) and an Op m a, sequence the two Op's together and return something from the results of the two :)
03:23:31 <jle`> this is doable with only an Applicative constraint, but it's a lot easier with a Monad constraint
03:23:38 <jle`> to think through on a first draft, at least
03:23:55 <gfixler1> jle`: do you think of sequence as fancy application?
03:24:08 <gfixler1> i.e. application where the elements are wrapped/in a context?
03:24:39 <jle`> in this sense, (<*>) is sort of a sequence-then-apply
03:25:02 <gfixler1> :t sequence
03:25:04 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
03:25:05 <jle`> for this particular Applicative instance
03:25:08 <gfixler1> like that sequence?
03:25:22 <jle`> not like that sequence...the colloquial word for "do this, then do that afterwards"
03:25:25 <jle`> more closer to this:
03:25:27 <jle`> :t (*>)
03:25:29 <lambdabot> Applicative f => f a -> f b -> f b
03:25:29 <gfixler1> ah, okay
03:25:51 <gfixler1> yay, semantics
03:26:31 <jle`> yeah heh, names are weird
03:26:46 <jle`> i'm using sequence here in the same way that you use "short-circuit" to describe the Monad instance for Maybe
03:27:02 <jle`> a word to describe what the function does for a specific concrete type
03:27:22 <jle`> it is a bit unfortunate then that there happens to be an actual function called "sequence" in prelude :)
03:27:27 <gfixler1> :)
03:27:39 <gfixler1> and seq
03:27:50 <jle`> mhm, heh
03:27:59 <gfixler1> let's go with "sequins"
03:28:01 <jle`> some people refer to (*>) as "andThen"
03:28:13 <gfixler1> yeah, I think I do that
03:28:26 <s4ke> do i need pure in <*>?
03:28:37 <jle`> you need `return` if you're doing it with do notation
03:28:41 <jle`> or `pure`, yeah
03:28:43 <s4ke> (<*>) (Op f) (Op x) = Op $ \stack -> _
03:28:55 <gfixler1> how's that monad-of-no-return thing coming along?
03:29:04 <jle`> Op f <*> Op x = .. is a little cleaner, i think :)
03:30:31 <s4ke> type holes are great
03:34:38 <_Vi> 1. What does `[  ] mean? 2. How do I search for this without asking questions? I tried googlling "haskell `[", "haskell backtick square brackets", hoogling `[ but didn't find anything.
03:35:24 <pavonia> I't built-in syntax for lists
03:35:45 <pavonia> Oh, wait
03:35:54 <_Vi> I though it's just [], without the backtick.
03:36:11 <pavonia> Where does the backtick come from?
03:36:35 <ARM9> can you provide more context?
03:36:40 <_Vi> It's in source code snippet that use some LANGUAGE extension (I don't know which).
03:36:47 <MarcelineVQ> DataKinds?
03:36:57 <ARM9> as in, post actual code
03:37:24 <pavonia> But DataKinds uses apostrophes, no?
03:37:30 <MarcelineVQ> yes '
03:37:36 <_Vi> I've seen it in presentation, but don't remember the actual code. Maybe it's about some certain web framework.
03:37:42 <ChristianS> _Vi: i've seen '[...], which is a list at the type level (using DataKinds, i suppose). but that's a straight apostrophe, not a backtick.
03:38:36 <_Vi> The main question isn't about backtick-sqbrackets itself, but about how to search for strange Haskell combinations of special characters when Hoogle fails?
03:38:51 <_Vi> (I've asked about it and they answered that maybe it's some Template Haskell thing)
03:39:17 <ARM9> try stackage
03:39:18 <ChristianS> _Vi: well, asking in this channel is probably your best guess
03:39:30 <phadej> the haddock renders typelevel lists as `[Foo, Bar]`
03:39:33 <phadej> I don't know why
03:39:43 <jle`> _Vi: probably the GHC manual or Haskell report.  if it's syntax then that'd sort of be like asking for what "=>" means
03:39:51 <_Vi> The backtick was only on the left side, not on the right.
03:39:56 <jle`> Hoogle isn't really going to help you with =>
03:40:49 <jle`> or like, asking what { means
03:41:07 <_Vi> Should documentation spell all combinations of special characters as words when defining them first time (like "equal sign, more than" for "=>") to be googlable?
03:41:28 <s4ke> Op f <*> Op x : do i run x first?
03:41:35 <s4ke> or f ?
03:41:39 <jle`> perhaps; or maybe there should be some sort of nice haskell syntax reference
03:41:49 <jle`> s4ke: traditionally we run Op f first
03:42:11 <s4ke> Op f <*> Op x = Op $ \stack -> pure (x _, stack, "")
03:42:19 <jle`> and i'm guessing if Op has a monad instance, then running Op f first is the only way to make your Applicative instance match up with `ap` for your Monad instance
03:42:21 <_Vi> jle`, Preferably exhaustively covering all {#LANGUAGE} extensions.
03:42:29 <phadej> _Vi: just show the code where it used
03:42:40 <phadej> _Vi: someone will know for sure
03:43:15 <jle`> yeah, but "ask someone" shouldn't be the only possible answer in terms of things to do when you want to look up an aspect of syntax
03:43:37 <phadej> well, then we can fix that "error" instance
03:43:50 <jle`> it's definitely one way to do it, but it might be worth looking into providing other ways
03:43:51 <phadej> and not try shoot everywhere :)
03:44:14 <_Vi> I don't have the code. It was on presentation slides I've seen in person. `[ was in code snippets, but weren't explained. The presentation partially dealt with "Servant" framework.
03:44:34 <phadej> jkarnis boston haskell?
03:45:04 <jle`> if it's servant then it's most likely '[..., not `[..
03:45:06 <s4ke> jle`: quick question, i dont seem to get it... Op f <*> Op x = Op $ \stack -> pure (x _ , stack, "") what is the "_" here then
03:45:15 <s4ke> it needs a stack
03:45:21 <s4ke> but how do i get it from Op f
03:45:21 <jle`> s4ke: yeah, you have a stack, `stack`
03:45:28 <jle`> well
03:45:33 <jle`> you can get a `stack` from f :)
03:45:43 <jle`> f :: Stack -> m (a -> b, Stack, String)
03:45:45 <_Vi> Can ' be mistakenly turned into ` by typesetting?
03:45:45 <jle`> :O
03:45:50 <jle`> very possibly
03:46:03 <s4ke> where expression?
03:46:09 <jle`> some typesetting systems do it automatically.  not into `, but a curly quote
03:46:13 <jle`> s4ke: do notation, binding
03:46:24 <s4ke> well i want to do it without monad
03:46:26 <jle`> Op f <*> Op x = Op $ \stack -> do
03:46:28 <s4ke> thats the problem :D
03:46:38 <jle`>     (ff, stck, "") <- f stack
03:46:44 <jle`> er, (ff, stck, str) <- f stack
03:46:50 <jle`> i chose very bad variable names v.v
03:47:04 <jle`> okay, the easiest way to understand what this instance "does" is with Monad
03:47:15 <jle`> implementing it with only APplicative is possible, but it might not aid your understanding
03:47:34 <jle`> hm
03:47:48 <jle`> actually, is it possible to do this with only Applicative?
03:47:56 <jle`> ah, it actually might not be
03:48:09 <jle`> it might not be possible to do this with only an Applicative constraint
03:48:13 <jle`> hm
03:49:23 <jle`> s4ke: yeah, perhaps I've misled you.  i'm sorry.  it might not be possible to do this with only an Applicative constraint.  it's a bit late and i'm heading to bed, but i suspect you might actually need the full on Monad constraint :|
03:49:39 <gfixler1> I just went through the Servant pages on hackage - I see '[JSON] and similar, but not where it's coming from
03:49:40 <s4ke> jle` no need to feel sorry :D
03:49:53 <_Vi> Remembered: it was't a presentation, but a "livecoding" session. Presenter was using some special Emacs that renders lambdas, null sets, triple = and so on. Maybe it also "converts" ' into `?..
03:50:05 <s4ke> in do notation i guess that's rather simple
03:50:34 <jle`> _Vi: that is also another possibility.  it would be up to the presenter then to clarify, though
03:50:37 <gfixler1> _Vi: could be some smart-quotes thing, or just the font
03:50:46 <gfixler1> https://hackage.haskell.org/package/servant-0.4.4.5/docs/Servant-API-Get.html
03:50:53 <gfixler1> one example of '[JSON]
03:51:18 <_Vi> Yes, it looked like this, but with skewed quote instead of straight.
03:55:49 <gfixler1> _Vi: http://stackoverflow.com/questions/33406235/understanding-haskell-type-level-literals
03:56:08 <gfixler1> http://stackoverflow.com/a/33406538/955926
03:57:13 <gfixler1> so yes, MarcelineVQ and ChristianS were right - DataKinds
03:57:51 <_Vi> Thanks. The main carryout: "don't bother searching more about Haskell's strange characters if initial search returned nothing, just ask straight at #haskell". 
03:58:03 <gfixler1> _Vi: we do have some tools problems
03:58:22 <gfixler1> I blame it on way too much category theory left to uncover, and it being too much fun for most people
04:00:18 <s4ke> yeah. got it :)
04:00:23 <s4ke>     Op f <*> Op x = Op $ \stack -> do (y, stack', str) <- f stack
04:00:24 <s4ke>                                       (a, stack'', str) <- x stack'
04:00:24 <s4ke>                                       return (y a, stack'', str)
04:01:58 <s4ke> jle`: if youre still here, is that correct?
04:03:08 <s4ke>     Op f <*> Op x = Op $ \stack -> do (y, stack', str1) <- f stack
04:03:09 <s4ke>                                       (a, stack'', str2) <- x stack'
04:03:09 <s4ke>                                       return (y a, stack'', str1 ++ str2)
04:03:53 <ChristianS> s4ke: don't paste into the channel, use a pastesite
04:04:06 <s4ke> kk sry
04:04:17 <exio4> try to move the applicative laws 
04:05:59 <exio4> er, prove* :P
04:33:45 <ARM9> what are valid comments in a happy grammar? -- and {--} ?
04:58:33 <abbe_> hi
04:59:19 <abbe_> when using Parsec in applicative mode, is it possible to update its state depending on the parsed data ?
05:02:21 <abbe_> basically trying to do equivalent of: runParser ((string "foo") >>= modifyState . DL.cons)
05:02:37 <abbe_> which I don't think is possible in Applicative style parsing
05:03:37 <abbe_> because of lack of a (>>=) like function in Applicative interface
05:04:22 <abbe_> Please correct me, if I'm wrong.
05:04:27 <mauke> string "foo" *> modifyState (DL.cons "foo")
05:04:41 <abbe_> hmm
05:06:29 <abbe_> mauke: sorry, '(string "foo")' is just a  simplest example I could think of (apparently I failed), but it could be (many $ noneOf ":") in its place
05:31:04 <Xeironis_> I've written a simple 2D game renderer in OpenGL in Haskell and now want to alter the game world separately from the renderer. Is calling the renderer with forkIO the right way to do this? I've tried it and so far, I can only get the main thread OR the rendering thread to run, but never both (if I don't sleep in the main thread, it only runs the main thread, if I sleep for more than ~25000 us, it only runs
05:31:05 <Xeironis_> the rendering thread)
05:35:34 <silver> ghc -threaded? ./game +RTS -N?
05:43:47 * hackagebot conduit 1.2.6 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.2.6 (MichaelSnoyman)
05:48:47 * hackagebot hackage-mirror 0.1.1.1 - Simple mirroring utility for Hackage  https://hackage.haskell.org/package/hackage-mirror-0.1.1.1 (MichaelSnoyman)
05:51:10 <Xeironis_> silver: threaded slihtmly changes the time the main thread has to sleep to make a difference, but that's it. -N doesn't make any difference
05:51:24 <Xeironis_> s/slightmly/slightly
05:53:52 <Xeironis_> (-N2 that is)
05:58:46 <silver> well threaded tells ghc to compile in multithreaded runtime, and +RTS -N tells runtime to use multiple cores, if it doesn't help then something's wrong with your code (locking, opengl issues etc.)
05:59:03 <silver> https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Concurrent.html
05:59:11 <silver> Therefore, some libraries (OpenGL, for example) will not work from a thread created using forkIO. They work fine in threads created using forkOS or when called from main or from a foreign export.
06:01:05 <Xeironis_> Ah, thank you, I'll experiment with that
06:04:04 <wedens> how can I use connection pooling with postgresql-simple?
06:19:25 <ChristianS> wedens: use the resource-pool package and set up a Pool Connection, works excellent
06:25:13 <anks> hi, does Pipes' 'await' fails on empty input ?
06:32:14 <ARM9> http://vpaste.net/xOyFD
06:32:45 <ARM9> any idea why I'm getting this error when building a second time after changing some source?
06:33:56 <wedens> ChristianS: thanks. what will happen with connection on network failure? (I'm using postgresql-simple the first time)
06:33:57 <ARM9> there's obviously only one Lexer.hs
06:33:58 <bergmark> ARM9: i think it's because you are passing that file twice
06:34:16 <ARM9> oooh
06:34:24 <ARM9> nvm it's a makefile error, thanks for pointing that out
06:34:36 <ARM9> the error message with duplicate Lexer.hs threw me off
06:34:50 <ChristianS> wedens: no idea, i guess you'll get some kind of error.
06:48:58 * hackagebot protocol-buffers 2.1.8 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.1.8 (k_bx)
06:49:01 * hackagebot protocol-buffers-descriptor 2.1.8 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.1.8 (k_bx)
06:49:02 * hackagebot hprotoc 2.1.8 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/hprotoc-2.1.8 (k_bx)
06:58:40 <hsk3> http://www.wired.com/2015/09/facebooks-new-anti-spam-system-hints-future-coding/
06:58:54 <hsk3> The thing is: Biilmann no longer uses Haskell. It’s not entirely practical. Not enough people know how to use it, and this is unlikely to change. “Haskell is like a programming language from an alternate future that is never going to happen,” he says. “It solves all these problems it promises to solve. But it’s so different that there is no chance it will become common.”
06:58:57 <hsk3> Your opinions?
07:00:54 <ChristianS> hsk3: oh, the facebook spam filtering team has abandoned haskell? didn't know that...
07:01:09 <hsk3> ChristianS: no, this is some other guy
07:01:11 <hsk3> not at facebook
07:01:32 <hsk3> fb is still with it afaik
07:01:40 <OutlawStar> they are
07:08:16 <geekosaur> always gonna be someone with that opinion, usually someone terrified of change or that they might have to actually learn something
07:08:51 <hsk3> yeah..
07:33:21 <Twey> Is there an XMPP library on Hackage somewhere that supports XEP-0060 (pub/sub)?
07:40:49 <ww> hrmph. i don't do any haskell coding for a few months, and i have to rebuild everything because cabal's gotten all confused
07:43:30 <sm> ww: yes. This is less of a problem with stack 
07:43:59 <ww> i may try that...
07:44:00 * hackagebot publicsuffix 0.20151129 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20151129 (wereHamster)
07:45:20 <ww> at least cabal outright refuses to install anything outside of a sandbox now...
07:59:01 * hackagebot OpenGLRaw 2.6.1.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-2.6.1.0 (SvenPanne)
08:00:33 <hsk3> Someone here using Stack on OS X El Capitan?
08:09:01 * hackagebot yaml 0.8.15.2 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.15.2 (MichaelSnoyman)
08:09:33 <ww> stack-0.1.5.0 failed during the building phase. The exception was:
08:09:47 <ww>     Couldn't match expected type ‘Control.Retry.RetryStatus -> IO a0’
08:09:47 <ww>                 with actual type ‘IO ()’
08:09:50 <ww> grrr...
08:13:44 <sm> hsk3: yes
08:13:56 <sm> ww how come you're not using the current 0.1.8.0 release ?
08:14:01 * hackagebot resourcet 1.1.7 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.1.7 (MichaelSnoyman)
08:14:21 <ww> sm: simply "cabal install stack"
08:14:54 <sm> I would cabal update first, then
08:15:10 <ww> i did, of course.
08:15:18 <sm> it's also in homebrew (haskell-stack)
08:15:37 <sm> oh sorry.. mixing you up with hsk3
08:16:21 <ww> rm -rf ~/.cabal ~/.cabal-sandbox ~/.ghc; rehash; cabal install cabal-install; rehash; cabal sandbox init; cabal install stack
08:16:25 <ww> *boom*
08:16:27 <sm> ww: hmm, then it seems cabal automatically picked an older version, probably because you're not in a fresh package db. 
08:16:28 <hsk3> sm: you on el cap?
08:16:34 <sm> hsk3: yes
08:16:50 <hsk3> sm: is there any way to get stack working without disabling system integrity protection?
08:16:54 <hsk3> i don't wanna reduce my system's security..
08:17:22 <sm> hsk3: hmm I remember reading about that but not having to actually do it.. maybe I blotted it out
08:17:44 <hsk3> sm: so it didn't matter in the end?
08:18:10 <sm> hsk3: try installing without disabling it
08:18:16 <hsk3> ok
08:19:32 <ww> sm: well, cabal update after removing the various directories ought to have done that...
08:19:58 <ww> unless it is unhappy with running ghc 7.8.3
08:20:31 <noodleman02> what function would i need for this job http://pastebin.com/Zvqw9BJZ
08:20:56 <sm> ww: "cabal install stack-0.1.8.0" should give more definite info
08:24:01 <cocreature> noodleman02: "filter (\[(a,b),(c,d)] -> b == d && abs (a-c) == 1) . replicateM 2"comes pretty close for the horizontal case
08:24:08 <cocreature> you need to filter duplicates after that
08:24:18 <ww> sm: it seems to boil down to needing a new version of template haskell that requires a new version of base:
08:24:21 <ww> rejecting: template-haskell-2.10.0.0 (conflict:
08:24:24 <ww> base==4.7.0.1/installed-1a5..., template-haskell => base==4.8.*)
08:25:16 <sm> ww: there's also binaries for most platforms
08:26:06 <ww> sm: i generally avoid binaries
08:26:17 <sm> fair enough
08:26:32 <sm> maybe also installing ghc 7.10 is a quick fix then
08:26:58 <ww> that's starting to make stack look like not worth the trouble...
08:27:57 <rvx1> 7.10 seems to break quite a few things in general
08:28:54 <rvx1> why not bite the bullet ... that's not stack's fault.
08:29:11 <sm> ok, it's your call. But I remember all the repetitive time spent puzzling out cabal solver/package db issues 
08:29:37 <ww> rvx1: because i want to be able to build the software in several different environments, not all of which i have root on
08:29:47 <ww> so i could get this working on my laptop no doubt.
08:29:55 <ww> but at work/school it'd be a big hassle.
08:30:35 <ww> and expecting people to be able to repeatably duplicate things is a bit much if they have to go to a lot of trouble setting up the environment just right
08:30:45 <ww> that's supposed to be the problem stack solves, right?
08:30:50 <rvx1> fwiw i'm still using cabal for my own stuff. but that's because my learning time is already used up from learning haskell itself.
08:32:20 <rvx1> ww: up to you of course, i haven't run into these problems with stack. it's worked pretty much out of the box so far
08:33:41 <sm> ww: stack 0.1.6.0+ does seem to require ghc 7.10, but only indirectly because of template-haskell as you say. This seems like a bug the stack team would fix (either making it 7.8 compatible or indicating it explicitly with the base lower bound)
08:34:53 <rvx1> can someone explain why [] has both a kind and a type
08:35:08 <rvx1> in the sense that I can do :k [] and :t []
08:35:47 <rvx1> while most values seem to only have a type (for example, i can't do :k 3)
08:36:15 <sm> ww: also, it's a bug if stack 0.1.5.0 fails to compile. I'd report both 
08:37:55 <sm> http://matrix.hackage.haskell.org/package/stack#GHC-7.8/stack-0.1.5.0 shows the same issue, so it's not just you. stack seems to not build with GHC 7.8
08:39:53 <sm> actually that page shows that 0.1.2.0 did. So you could cabal install stack-0.1.2.0, but that might be too old/unsupported to be worth the trouble
08:40:39 <hsk3> sm: seems to work fine
08:40:54 <hsk3> without disabling the protection
08:41:07 <sm> good
08:41:39 <nkaretnikov> has anyone tried building lighthouse recently?
08:41:42 <hsk3> what does "stack exec" do? i don't see a binary anywhere
08:42:12 <hsk3> but something is executed
08:42:18 <sm> runs a command in context of the stack package db 
08:42:41 <ww> hmmm
08:44:04 <rvx1> what was the metacommand trick with :l to reload the previously loaded module?
08:44:13 <nkaretnikov> :r?
08:44:21 <brisbin> rvx1: those are two []'s. it's kind of like data Box a = Box { unBox :: a }, :k Box, :t Box
08:44:24 <nkaretnikov> there's :h in ghci
08:44:58 <hsk3> sm: but where does the binary go after running "stack build"?
08:45:21 <sm> hsk3: stack exec which EXE to see it
08:45:39 <ww> requiring 7.10 is a bit aggressive... lots of operating system distributions won't ship that by default for a while yet...
08:45:41 <sm> stack exec `which EXE` runs it in place
08:46:04 <ww> i mean ed.ac.uk just moved to 7.8 this autumn...
08:46:14 <sm> ww: I suspect they'll agree with you and fix it
08:46:40 * ww tries to dig out the right contact information...
08:46:45 <rvx1> nkaretnikov - :r thanks
08:46:52 <sm> hsk3: or, stack install to copy it to ~/.local/bin
08:46:55 <nkaretnikov> rvx1: np
08:47:28 <sm> ww: https://github.com/commercialhaskell/stack/issues
08:47:58 <hsk3> sm: thanks
08:52:20 <rvx1> anyone use spacemacs? running into an annoying issue in interactive mode where go-to-beginning-of-line (0) puts the cursor behind the prompt.
08:52:54 * ww has been meaning to try spacemacs
08:53:08 <ww> but perhaps just one newfangled thing for today ;)
08:53:38 <rvx1> ww it's mostly awesome, i say that as a prior vim user, then emacs user of about 6 years
08:54:14 <rvx1> ww the only thing that bugs me is that I wish it felt less laggy
08:54:43 <nkaretnikov> rvx1: they have a gitter chat
08:54:53 <rvx1> ww but it's certainly a breath of fresh air after feeling like my emacs configuration was a monolithic  glued together kluge
08:55:44 <Xeironis_> get currentWindow returns a Maybe Window: mapM_ (postRedisplay . pure) =<< get currentWindow   I don't suppose there's an elegant way to get rid of the pure? it just seems so redundant, because I'm taking the Window out of the Maybe context and then putting it right back in
08:56:18 <Xeironis_> (I forgot to say, postRedisplay also takes a Maybe Window)
08:57:46 <ww> rvx1: historically, emacs has always felt a bit laggy. maybe they thought that with moore's law it was getting too responsive?
08:58:01 * ww (has been using emacs since the 90s)
08:58:50 <geekosaur> :t (<=<)
08:58:51 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
08:59:32 <rvx1> ww i like the modal "language" using the leader key. but it would be more fluid if there was no latency. i guess elisp has it's performance limitaitons ... or they may need to optimize it a bit.
09:00:06 <rvx1> ww but overall I feel like it's worth it. besides you can still "speak" the keypresses as fast as you want and it will catch up.
09:02:49 * ww wonders if it would work well with voice control...
09:03:07 <ww> (help relieve rsi)
09:15:56 <ww> ok https://github.com/commercialhaskell/stack/issues/1450
09:16:47 <jdove> any devs ever listed their app on here
09:16:47 <FireFly> It would--there's a talk by someone who uses emacs via voice control, IIRC it's modal and not entirely unlike vi's commands
09:16:59 <jdove> ?
09:17:35 <ww> FireFly: i would love that
09:17:44 <c_wraith> jdove: all packages published to hackage get a notification here, so.. yes. :)
09:18:02 <FireFly> ww: https://www.youtube.com/watch?v=8SkdfdXWYaI
09:18:47 <jdove> c_wraith got ya.. thanks
09:20:06 <c_wraith> jdove: if you want feedback or to publicize something you've done, that's acceptable too.  So long as you're not spamming. :)
09:21:54 <jdove> c_wraith cool thanks
09:22:34 <jdove> c_wraith I got a rev 1 version of a web app
09:23:06 <jdove> angularjs bootstrap
09:24:49 <jdove> c_wraith feel free to check it out.. feedback much appreciated crowdsens.com
09:26:10 <jdove> c_wraith keep in mind.. it's just me and one other dude part time
09:26:53 <c_wraith> jdove: I do wonder what that has to do with haskell.  Usually that's expected. :)
09:27:12 <jdove> baiduspider is alittle out of control wouldn't you say?
09:27:48 <jdove> will block it soon enough
09:31:41 <jdove> c_wraith I value haskell developer opinions over others? 
09:32:26 <ww> FireFly: we need good voice recognition software!
09:32:58 <c_wraith> jdove: ah.  In that case, #haskell-blah might be a more appropriate channel.  Still lots of haskell devs, but the expectation that things are related to haskell is dropped. :)
09:33:00 <ww> this is an even more brilliant way to procrastinate than trying to install stack :P
09:33:28 <jdove> c_wraith got ya.. no ur right.. I'm in the wrong room.. thanks though
09:33:52 <jdove> c_wraith actually.. what would be the best room for app feedback?
09:33:52 <c_wraith> jdove: no worries.  It's fine to ask these things. :)
09:34:01 <c_wraith> jdove: I have no idea on that one.
09:34:11 <jdove> c_wraith np
09:50:33 <sm> how easy is it to set up a haskell toolchain on openbsd ?
09:52:44 <ww> sm: i generally have no problem with freebsd, but it's a little different...
09:53:02 <sm> not easy at all, as far as I can see
09:53:17 <c_wraith> just file a bug on stack, and make it their problem
09:53:50 <sm> someone did already, it seems a bit complicated (https://github.com/commercialhaskell/stack/issues/416)
10:04:05 * hackagebot persistent 2.2.3 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.2.3 (GregWeber)
10:21:53 <bollu> I want to parse using haskell
10:21:56 <bollu> what library do I pick?
10:22:05 <bollu> (I have a context-free-ish grammar)
10:22:26 <bollu> but, well, I'd like to generate really nice error mesages preferable
10:22:29 <bollu> preferably*
10:22:33 <roconnor> Parsec is the standard parsing library.
10:22:47 <roconnor> I'm not sure it is still the best.
10:22:51 <ARM9> Happy comes with the haskell platform
10:23:00 <bollu> um, but what's the "best"? :)
10:23:03 <ARM9> otherwise it's just a cabal install away
10:23:06 <bollu> I heard trifecta is pretty good?
10:23:33 <roconnor> I've heard good things about trifecta too, but I've never used it.
10:23:38 <ARM9> if you want a combinator Attoparsec might be worth checking out too
10:23:51 <bollu> what does it mean to "want a combinator"?
10:23:59 <ARM9> parser combinator, which is what the ones you've mentioned are
10:24:03 <ARM9> as opposed to parser generators
10:24:05 <roconnor> My understanding was taht Attoparsec was for parsing on-line things like network protocols
10:24:07 <ARM9> (happy being one of the latter)
10:24:30 <bollu> ah
10:24:43 <bollu> wait, a parser geneator is like yacc I'm guessing?
10:24:55 <roconnor> yes,  Happy is like yacc.
10:24:57 <bollu> while a parser combinator is the "usual" parser combinators?
10:25:13 <bollu> roconnor: so it uses template Haskell to generate haskell code?
10:25:27 <roconnor> bollu: more like yacc than that.
10:25:35 <ARM9> happy is a compiler compiler, it generates haskell code for the parser
10:25:39 <roconnor> I think it uses Haskell to generate Haskell code.
10:26:07 <ARM9> you feed it a grammar and it outputs a haskell source file
10:26:13 <geekosaur> trifecta's supposed to be particularly good at error messages
10:26:27 <roconnor> bollu: If I were starting a parsing project, I'd probably take trifecta for a spin.  However, no one was ever fried for using Parsec.
10:26:52 <bollu> cool, I think I'll use trifecta
10:27:12 <geekosaur> also IIRC there was a fork of parsec that improved its errors and there was a push to get them merged back in
10:29:06 * hackagebot c2hs 0.27.1 - C->Haskell FFI tool that gives some cross-language type safety  https://hackage.haskell.org/package/c2hs-0.27.1 (IanRoss)
10:29:33 <geekosaur> http://hackage.haskell.org/package/megaparsec
10:31:42 <bb010g> The parsec fork is megaparsec
11:04:17 <Patient0> I have two numbers which are expresses as the list of their prime factors
11:04:23 <Patient0> so I have written this function
11:04:32 <Patient0> ys ++ (xs \\ ys)
11:04:38 <Patient0> sorry
11:04:38 <Patient0> lcmPrimes :: [Integer] -> [Integer] -> [Integer] lcmPrimes xs ys = ys ++ (xs \\ ys)
11:05:47 <Patient0> lcmPrimes is not doing the same thing as "union" - but I have this feeling that there's probably some name for the concept of (ys ++ (xs \\ ys))
11:06:24 <Patient0> does anyone know of an alternative implementation of ys ++ (xs \\ ys) ?i.e. is there already a standard Haskell function that does this?
11:07:11 <roconnor> nothing better comes to mind.
11:08:45 <roconnor> Patient0: If the lists are sorted you could make a more effecient merging function yourself.
11:09:55 <Patient0> roconnor: thanks...  in this case actually the lists are pretty small
11:10:09 <roconnor> I would stick to what you have.
11:36:07 <sm> ww: I see your stack issue got fixed, good job
11:38:40 <Xeironis_> http://hackage.haskell.org/package/array-0.5.1.0/docs/src/Data.Array.IO.html has a really nice html representation of haskell source code. Does anyone know what tool they used to create this?
11:41:06 <zxtx> Hello, I'm wondering, what are the preferred tools for writing higher-level documentation?
11:41:37 <zxtx> Like if I want to write overviews or tutorials for my library, should I also use Haddock?
11:42:25 <sm> zxtx: I think most people would say no, and prefer markdown
11:43:05 <zxtx> sm, so I would just write markdown and use hakyll?
11:43:34 <sm> that's pretty common (and what I do). But of course there are drawbacks. More complexity for you
11:45:28 <sm> and a greater distance from your source code and haddocks, and you can't use doctest (though, adding a pandoc filter for that seems not hard)
11:46:22 <sm> but editing and previewing markdown is a lot nicer than haddock
11:46:50 <sm> and gives more control (tables, html, code highlighting..)
11:47:46 <zxtx> As I see it, I should use haddock for API Docs, and for per-module documentation, but for things like overviews, tutorials and manuals it feels like I could go with sphinx or really anything
11:49:44 <sm> that's how I see it too
11:50:00 <sm> I think being able to generate man pages is also desirable
11:50:24 <sm> pandoc has support for that
11:50:30 <zxtx> oh interesting
11:51:17 <sm> from markdown, I mean. But who knows, the mighty pandoc might generate web pages and man pages from haddock too
11:52:12 <zxtx> I assumed you meant markdown
11:56:52 <cocreature> Xeironis_: that’s the new (unreleased) haddock version
11:57:24 <cocreature> Xeironis_: if your version supports that you can use --hyperlinked-source to activate it
11:59:07 <kyren> hello, I'm looking for a way to show images conveniently from a ghci prompt
11:59:36 <Rembane> kyren: This might do what you want to: https://github.com/gibiansky/IHaskell
11:59:40 <kyren> or, ideally, control some kind of drawable context that's running in a different thread
12:00:24 <kyren> I ended up there when googling around, maybe I don't understand all of what IHaskell does though?
12:01:10 <kyren> I know I could just generate a png and I can figure that out obviously, I was looking for more of something like gnuplot, where I can show a popup image of something I'm generating.. maybe what I'm asking for doesn't make too much sense
12:02:03 <kyren> I even got so far as running a SDL context via forkIO, and sending it screen data from an MVar, but I did not have ANY luck with ghci.. something deep inside SDL gets deeply confused (on OS X at least)
12:03:05 <kyren> oh, you know you're right, it looks like IHaskell does what I want, now that I read more closely.. I'll try it out!
12:04:13 * hackagebot JuicyPixels 3.2.6.3 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.2.6.3 (VincentBerthoux)
12:05:51 <Rembane> kyren: Good luck!
12:07:14 <suppi> kyren, good luck! sounds cool :)
12:07:35 <kyren> thanks for pointing me at JuicyPixels as well
12:10:40 <nkaretnikov> in aeson, how do i compose a number of ToJSON instances?  Value is not a Monoid nor a Semigroup.  do i need to abuse Data.Data for that?
12:10:41 <kyren> it looks like, if I'm understanding this correctly, that I can use IHaskell and then there's a module to make IHaskell understand how to display JuicyPixels types.  If so that would be.. quite cool
12:19:52 <bb010g> nkaretnikov: Context? I think I've done something similar.
12:20:14 <nkaretnikov> bb010g: i sec
12:20:15 <nkaretnikov> 1*
12:21:26 <nkaretnikov> bb010g: basically, i have several types that are also used in a record.  i want to define a ToJSON instance for the said record such that it reuses ToJSON instances of the types
12:21:33 <nkaretnikov> bb010g: and i see no way to do it properly
12:21:43 <bb010g> Are you using Data.Aeson.TH?
12:21:49 <nkaretnikov> no
12:21:54 <nkaretnikov> i'm writing them by hand
12:22:06 <nkaretnikov> since i need an extra validation layer
12:22:17 <bb010g> `(o .: "foo") >>= toJSON`
12:22:24 <bb010g> :t (.:)
12:22:25 <lambdabot>     Not in scope: ‘.:’
12:22:25 <lambdabot>     Perhaps you meant one of these:
12:22:25 <lambdabot>       ‘.’ (imported from Data.Function),
12:22:46 <nkaretnikov> don't worry, let me look it up in the haddocks
12:22:51 <bb010g> Play around with the types in ghci and see why that works
12:23:03 <nkaretnikov> bb010g: wait
12:23:10 <nkaretnikov> bb010g: that's not what i want
12:23:27 <nkaretnikov> the resulting type will be Parser a
12:23:33 <nkaretnikov> and i need Value for toJSON
12:23:47 <bb010g> Sorry, s/toJSON/parseJSON
12:23:50 <nkaretnikov> are you confusing ToJSON and FromJSON?
12:24:52 <nkaretnikov> bb010g: again, the resulting type is Parser a
12:24:54 <nkaretnikov> which won't work
12:25:01 <bb010g> `\o -> (o .: "foo") >>= parseJSON :: FromJSON b => Object -> Parser b`
12:25:26 <bb010g> Oh, ToJSON. Sorry.
12:25:36 <nkaretnikov> bb010g: yes, please re-read what i just wrote
12:26:15 <nkaretnikov> i want something like this:
12:26:55 <nkaretnikov> toJSON MyRecord {..} = mconcat [ toJSON field1, ... toJSON fieldN ]
12:27:09 <nkaretnikov> this doesn't work because Value is not a Monoid
12:27:21 <nkaretnikov> neither it is a Semigroup, so i can't use <>
12:27:43 <nkaretnikov> neither it's a Monad nor an Applicative
12:27:52 <nkaretnikov> the only solution i see is to pattern match by hand
12:27:55 <nkaretnikov> with case
12:27:58 <nkaretnikov> which is terrible
12:28:31 <bb010g> Oh. No. You're making an Object o :: Value?
12:29:10 <nkaretnikov> yes
12:29:21 <nkaretnikov> my plan is to get to HashMaps and concat that
12:29:27 <nkaretnikov> since HashMaps are monoids
12:29:37 <bb010g> Yeah. That sounds good. Here's a bit of my code:
12:29:40 <nkaretnikov> then wrap it into an Object again
12:30:20 <bb010g> This actually is for a wrapper around another ADT, but just ignore the union. https://www.irccloud.com/pastebin/mSbUrCSJ/
12:30:52 * nkaretnikov looks
12:32:05 <nkaretnikov> bb010g: this is slightly different compared to what i need, but i got the idea
12:32:14 <nkaretnikov> thanks for your help
12:32:49 <bb010g> NP
12:34:15 * hackagebot OpenGL 2.13.1.1 - A binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGL-2.13.1.1 (SvenPanne)
12:37:58 <Xeironis_> cocreature: awesome, thank you
12:49:25 <L8D> how can I use stack to start a ghci repl for a package that hasn't built yet?
12:50:06 <L8D> I want to use ghci to edit and fix the type errors in a package, but whenever I run "stack ghci" it says "cannot satisfy -package rest-core"
12:50:10 <L8D> where rest-core is the package I want to load up in my repl
13:02:20 <sm> L8D: you'd better get at least stack build --dry-run working first
13:28:23 <DarwinElf> pikajude, so did you get kevin to compile?
13:39:44 <lpaste> nocturne777 pasted “lenses ~” at http://lpaste.net/146178
13:40:10 <nocturne777> what does that (~) do there ?
13:40:15 <nocturne777> I know it's a lens setter
13:40:25 <nocturne777> but I am bit confused by seeing it used like that
13:40:38 <quchen> That tilde has nothing to do with lens.
13:40:42 <quchen> It's an irrefutable pattern.
13:41:31 <quchen> The set operator from lens is (.~), and it's an ordinary infix operator. Irrefutable patterns are a Haskell language feature.
13:43:24 <nocturne777> quchen: this irrefutable pattern sound like a documentation thingie
13:43:50 <quchen> No, it changes pattern matching behaviour, it's not for documentation
13:45:03 <geekosaur> it makes a pattern match lazy instead of strict
13:47:07 <nocturne777> geekosaur: I don't understand why the author used an irrefutable pattern in such simple and obvious code
13:51:19 <monochrom> 1. who is the author?  2. have you asked them?
14:23:48 <glguy> nocturne777: Using an irrefutable pattern to get the desired lazy match has no conflict with "simple and obvious"
14:24:42 <nocturne777> glguy: I think the author used it in this case to defer evaluation
14:24:53 <glguy> That's what it's used for in every case
14:25:41 <glguy> For a while all of the automatically generated lenses (via makeLenses) used irrefutable patterns
14:25:48 <glguy> and you can turn it on now as an option
14:26:33 <glguy> > set _1 True (set _2 False undefined) :: (Bool,Bool)
14:26:35 <lambdabot>  (True,False)
14:26:53 <glguy> It enables stuff like this
14:29:50 <jle`> sometimes people use lazy pattern matches to force the path for case statements
14:30:02 <jle`> if they are sure that there is only one constructor that will ever be passed in
14:30:22 <jle`> they do it to replace manually _ -> error "hey", i guess
14:30:32 <jle`> but in this case yeah it's being used to defer evaluation
14:30:46 <jle`> ~ is like the anti-! :3
15:09:20 * hackagebot morte 1.4.0 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.4.0 (GabrielGonzalez)
15:12:05 <monochrom> this is strange. morte is a library representing a lambda calculus. why does it depend on http-client and http-client-tls?
15:14:55 <statusfailed> monochrom: It has a feature where you can reference code remotely by a URL
15:15:11 <statusfailed> monochrom: syntactically those are a # followed by a URL I think
15:16:34 <pharaun> ah
15:17:22 <statusfailed> monochrom: Tekmo has a cool talk on it somewhere, trying to find it
15:17:42 <monochrom> nice. that's safer than what I was worrying. "it is a typed lambda calculus extended with a 'catpicz' combinator that has the side effect of downloading a cat picture from the web"
15:18:00 <statusfailed> monochrom: :D
15:18:21 <statusfailed> monochrom: here it is! http://www.haskellforall.com/2015/05/the-internet-of-code.html
15:20:50 <suppi> statusfailed, http://begriffs.com/posts/2015-10-16-internet-of-code.html
15:21:10 <suppi> i love the video begriffs host
15:21:20 <statusfailed> suppi: that's the one!! thanks
15:21:29 <suppi> monochrom, that sounds like a cute combinator
15:22:19 <geekosaur> these days it wouldn't surprise me much >.>
15:43:18 <lingxiao> I'd like to write a function that flips a biased coin
15:43:33 <lingxiao> is there some library I should look at that does this already?
15:44:02 <lingxiao> ie, flipWith 0.7   would flip a bent coin where the prob of Head is 7/10
16:04:40 <bernalex> lingxiao: you can just do that with the list monad.
16:04:48 <lingxiao> how so?
16:05:32 <bernalex> data Coin = Head | Tail
16:05:38 <bernalex> then a function to pick at random
16:05:48 <bernalex> or rather a value
16:05:56 <bernalex> [Head, Tail]
16:06:19 <bernalex> hm. give me a second.
16:06:27 <mniip> data In = Init | Last
16:08:48 <lingxiao> bernalex k thanks!
16:08:54 <glguy> lingxiao: pick a random number, decide on a threshold in the range you're picking between. if it's above that threshold you have one outcome otherwise the other
16:09:07 <bernalex> lingxiao: flipWith x y = replicate x Head ++ replicate y Tail
16:09:24 <glguy> You don't need to involve lists at all
16:09:30 <bernalex> no of course you don't.
16:11:26 <lingxiao> glguy that's very smart thanks!
16:12:11 <bernalex> lingxiao: oops g2g, but you could just use a random number & a threshold like glguy says. just get the random number and use it with: flip x y | x > y = Head | otherwise = Tail, or whatever.
16:12:12 <lingxiao> glguy if I do randomR (1,100) s   where s <- newStdGen
16:12:36 <lingxiao> I would need to have that random number correct?
16:12:48 <lingxiao> as in pass in s as a parameter ...
16:12:56 <RandomGuy> hello
16:13:04 <bernalex> lingxiao: yes
16:13:07 <lingxiao> I was hoping the function would be self contained and effect free
16:13:10 <lingxiao> but it doesn't seem possible correct
16:13:33 <bernalex> @let f x y | x > y = "head" | otherwise = "tail"
16:13:34 <lambdabot>  .L.hs:145:7:
16:13:34 <lambdabot>      Ambiguous occurrence ‘f’
16:13:34 <lambdabot>      It could refer to either ‘L.f’, defined at .L.hs:158:1
16:13:39 <bernalex> @let flipCoin x y | x > y = "head" | otherwise = "tail"
16:13:41 <lambdabot>  Defined.
16:13:50 <lingxiao> even in bernalex I would need to pick some int from 1 to 100
16:14:05 <lingxiao> in this case let flipCoin x y | x > y = "head" | otherwise = "tail"
16:14:24 <lingxiao> what's x and y?
16:14:40 <lingxiao> say coin is biased with prob (heads) = 0.7
16:14:41 <bernalex> > flipCoin 50 <$> (fst <$> randomR (1,100) <$> newStdGen)
16:14:43 <lambdabot>  <IO [Char]>
16:14:56 <bernalex> lambdabot: can't do it here because random is IO so lambdabot can't show it, but try it in ghci.
16:15:08 <bernalex> > flipCoin 70 <$> (fst <$> randomR (1,100) <$> newStdGen) -- in your case
16:15:12 <lambdabot>  <IO [Char]>
16:15:38 <bernalex> ehm lingxiao that was for you not lambdabot of course :]
16:15:38 <RandomGuy> im new in haskell... i have defined a list data type like this: List a = Empty | Cons a (List a). How can i derive Show so i cant get a representation like this ex: {1, 2, 3, 4} ????
16:15:43 <bernalex> but yeah really g2g, hope that helped!
16:16:04 <lingxiao> bernalex great thanks!
16:16:07 <bernalex> RandomGuy: you can't derive that -- will have to write it yourself, sorry!
16:16:13 <bernalex> ok really gone now bike :]
16:16:45 <RandomGuy> bernalex: i already tried it but i cant make it to show exactly like i want :/
16:17:39 <lingxiao> Yup something like insatace Show a => Show (List a) where show Nil = {}; show (Cons a xs) = "{" ++ show a ++ ", " ++ show xs ++ "}"
16:17:42 <lingxiao> oopse i meant show Nil = "{}"
16:18:58 <RandomGuy> lingxiao: that prints "{}" on the end of every list :/
16:19:13 <geekosaur> intercalate might be better since that will produce {x,} and ... that
16:19:28 <glguy> RandomGuy: Then write a function that doesn't put {} on there and use that
16:19:43 <geekosaur> right, intercalate won;'t work here derp
16:20:12 <RandomGuy> glguy: if only i could make that lol
16:21:03 <glguy> RandomGuy: Where are you stuck?
16:21:54 <glguy> ?lpaste
16:21:54 <lambdabot> Haskell pastebin: http://lpaste.net/
16:24:23 * hackagebot relational-query 0.6.4.0 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.6.4.0 (KeiHibino)
16:24:29 <lpaste> RandomGuy pasted “list” at http://lpaste.net/146184
16:24:30 <lingxiao> give me a sec glguy 
16:25:18 <lingxiao> http://lpaste.net/146185
16:25:39 <RandomGuy> glguy: well i wrote it like this: http://lpaste.net/146184 but it gives something like {1{2{3{}}}}
16:26:11 <lingxiao> RandomGuy http://lpaste.net/146185
16:26:30 <lingxiao> opse glguy sorry I meant to ping randomGu
16:26:47 <lingxiao> so the key is you need an inner loop over the items in List a
16:26:57 <lingxiao> then pre and append the curly brace
16:28:33 <RandomGuy> lingxias: thats exactly it :) thank you
16:29:15 <RandomGuy> lingxiao: thats exactly it :) thanks alot man
16:29:56 <lingxiao> yup np!
17:34:55 * hackagebot yesod-auth 1.4.11 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.4.11 (GregWeber)
18:00:18 <mmachenry> Is there a library function somewhere that will give me "[Either a b] -> Either a [b]"
18:00:49 <peddie> :t sequence
18:00:51 <shachaf> sequence
18:00:51 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
18:01:00 <mmachenry> Basically I want to do something like fold (>>=) and get the first a….
18:01:03 <mmachenry> Reading
18:01:39 <mmachenry> Perfect, thanks guys.
18:01:51 <mmachenry> Why doesn't Hoogle come up with that?
18:02:04 <monochrom> this version of sequence is new
18:02:20 <mmachenry> Oh, rock on. So I can maybe expect to see that later?
18:02:30 <Pamelloes> Is (Either a) a monad?
18:02:34 <monochrom> ah, but the old version of sequence should match. I don't know.
18:03:01 <kadoban> Pamelloes: Yes
18:03:03 <monochrom> I don't actually hear that Hoogle gets updated.
18:04:09 <Arahael> I heard that there is a significantly newer hoogle out there.
18:04:21 <Ralith> mmachenry: what was your hoogle query?
18:04:27 <geekosaur> fpcomplete's
18:04:29 <Pamelloes> Huh. I guess it is.
18:04:32 <geekosaur> @where hoogle
18:04:32 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
18:04:33 <Pamelloes> "Left l >>= _ = Left l" seems a bit destructive. I would
18:05:38 <Pamelloes> On second thought, Left l >>= _ = Left l makes more sense.
18:07:05 <monochrom> you don't have a total choice.
18:07:29 <monochrom> err, you don't have a total alternative.
18:08:24 <jle`> mmachenry: there's also the stackage hoogle, which is nice too
18:08:35 <jle`> and the 'beta hoogle' at http://hoogle.haskell.org
18:10:31 <jle`> it's been decided that the official hoogle wouldn't be updated until the new hoogle release (v 5.0) is finished...so when v5.0 comes out we can expect to see the official hoogle updated, too
18:10:45 <monochrom> eek
18:10:46 <jle`> but until then i've been using beta hoogle, stackage hoogle, or fpcomplete hoogle heh
18:11:08 <jle`> and everyone loves hayoo too
18:11:12 <mmachenry> jle`: Thanks.
18:12:02 <jle`> np!
18:12:07 * monochrom feels that it is like saying "wait until LaTeX 3 comes out". where LaTeX 3 has been in the making for 15 years or something and is still beyond the horizon.
18:12:32 <jle`> yeah, admittedly i'm not holding my breath for the new hoogle release, heh
18:14:11 <jle`> this is the last neil has mentioned this, on february this year -- http://neilmitchell.blogspot.com/2015/02/why-is-hoogle-index-so-out-of-date.html
18:14:58 <jle`> keep in mind that at the time the post was written, the index was already pretty out of date, heh
18:15:23 <jle`> (...which i guess could have been inferred from the title of the post)
18:15:33 <Adeon> I likee hayoo..but I think neither of them is good
18:15:38 <jle`> neil is a busy man though
18:16:21 <Adeon> hayoo tends to return lots of results from packages I'm not interested in
18:16:24 <Adeon> not sure if that's solvable easily
18:27:43 <nkaretnikov> Adeon: you could try running your own local hoogle, but that never worked for me
18:28:00 <nkaretnikov> meaning that i couldn't get it to build
18:28:35 <nkaretnikov> iirc, building the database required a huge amount of memory
18:29:20 <Adeon> I have 32 gigabytes because I'm too susceptible to flashy amazon suggestions offering me to buy another memory stick
18:30:00 <nkaretnikov> it required 8 gigs iirc, so you're good :)
18:30:57 <demize> I wanted to put 32 in my laptop, but the mobo could only handle 16
18:44:59 * hackagebot foscam-directory 0.0.5 - Foscam File format  https://hackage.haskell.org/package/foscam-directory-0.0.5 (TonyMorris)
18:49:46 <Arahael> So, I'm using stack, for a haskell *script*.
18:50:22 * hackagebot streaming-wai 0.1.0 - Streaming Wai utilities  https://hackage.haskell.org/package/streaming-wai-0.1.0 (WilliamCasarin)
18:50:31 <Arahael> Ie, #!/usr/bin/env stack and all that.  However, it always outputs some lines from stack relating to the environment, and the name of the resolver. How do I avoid that?
18:51:11 <Arahael> I'm using: -- stack --resolver=lts-3.15 runghc
18:58:18 <hackrilege> Can someone take a look at this for me? lpaste.net/146187
18:59:26 <hackrilege> I need to make A into a datatype
19:00:25 <haskell958> Hi all, Can anyone tell me the difference between [forall a.a] and forall a.[a]
19:01:20 <dmwit_> hackrilege: type A a = a -> a -- ?
19:01:42 <dmwit> haskell958: `forall a. [a]` says: you pick a type, and I will give you a list with elements of that type.
19:01:58 <dmwit> haskell958: `[forall a. a]` says: I will give you a list; then, for each element, pick a type, and I will give you a value of that type.
19:02:00 <kadoban> Arahael: There's an issue that mentions that, which doesn't appear to have a resolution. So … you can't currently, AFAIK, but soon it should be the default behavior.
19:02:10 <hackrilege> ?
19:02:13 <kadoban> Arahael: https://github.com/commercialhaskell/stack/issues/1394 if you're curious (though most of it isn't about that)
19:03:03 <haskell958> Okay, I'm on the page for existential types of haskell wiki https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types and they both come up as a list of bottoms
19:03:44 <hackrilege> If a is expensive to make instances for but we can easily instantiate b, that's what i was using it to do, buy there were some crazy proxy types so it has to be a data structure.
19:04:08 <haskell958> they state that the forall is an intersection of all the types and so forall a.a is bottom since bottom is common in all types
19:04:35 <hackrilege> Makes sense
19:05:03 <Arahael> kadoban: Thanks. :)
19:05:15 <hackrilege> The only list of a forall a is list of bottoms
19:05:34 <dmwit> `forall a. a` is not bottom; it is inhabited by bottom (and nothing else).
19:05:42 <hackrilege> Kk
19:05:45 <dmwit> `[forall a. a]` has `[]` as an inhabitant, which is not bottom.
19:05:50 <Arahael> kadoban: Actually, perhaps I can; that issue mentions --verbosity silent  Is that supported today?
19:05:50 <dmwit> `forall a. [a]` has the same
19:06:18 <hackrilege> It includes nothing?
19:06:41 <hackrilege> Is that what bottom is?
19:07:04 <dmwit> Bottom is a denotation for terms that do not reduce to a value.
19:07:15 <dmwit> (Like infinite loops, terms that get stuck, or exceptions.)
19:07:17 <haskell958> `forall a. a` is saying what element is in all types?
19:07:20 <kadoban> Arahael: Ah, hmm … yeah I'd imagine that'd work. It's currently an option at least, though I don't know for sure that it squelches the message you mention.
19:07:33 <kadoban> (should)
19:07:50 <haskell958> its saying for all a give me back an a
19:07:51 <haskell958> ?
19:07:59 <haskell958> and a is bottom because its present in all types
19:08:12 <haskell958> i think right?
19:08:49 <dmwit> `forall a. a` says "you pick a type, and I will give you a value of that type".
19:09:01 <dmwit> `a` is not bottom; `a` is a type (variable). Bottom is a denotation of a term.
19:09:03 <hackrilege> apparently both bottom and empty list are there
19:09:19 <dmwit> However, bottom is an inhabitant of every type.
19:09:41 <haskell958> i see. 
19:09:57 <hackrilege> How is  empty list of type a?
19:10:16 <dmwit> It isn't.
19:10:20 <Arahael> kadoban: I'll give it a play tonight. :)
19:10:31 <hackrilege> So it's not in that set?
19:10:37 <dmwit> `[] :: [forall a. a]` would be okay, if `[forall a. a]` were a type that existed in Haskell.
19:10:54 <dmwit> `[] :: forall a. [a]` is also okay in Haskell, though it has some implicit bits in more exciting languages.
19:11:20 <hackrilege> So the difference is that one is OK in Haskell!?
19:11:35 <dmwit> No, the difference is as I outlined above.
19:11:50 <dmwit> The fact that one is allowed in Haskell and the other isn't is a shallow fact; the difference I outlined above is a deep fact.
19:12:09 <hackrilege> I thought you said they contained the same things?
19:12:13 <Arahael> kadoban: Actually, it does indeed squelch the messages.
19:12:20 <kadoban> Arahael: Nice
19:12:20 <Arahael> kadoban: Thanks. :)
19:12:25 <dmwit> I never said that, no.
19:13:53 <hackrilege> I thought both contained only empty lust and bottom, sorry, i have become confused I'll back out
19:14:15 <Arahael> Hmm. A list of lust.
19:16:17 <dmwit> Well.
19:16:29 <dmwit> In Haskell, where type abstraction is silent, the difference between them is admittedly quite subtle.
19:16:29 <haskell958> Can I think of existential types as a union of types such that some function can take one of those types and make it something else?
19:17:03 <dmwit> That sounds reasonable enough.
19:19:35 <haskell958> so for my existential type, I have to implement all the functions that would work on the types that I want?
19:19:58 <haskell958> so if I wanted bool, int, and string in my existential types
19:20:25 <haskell958> I would have to make 3 separate functions that operates on each of those?
19:20:50 <dmwit> right
19:30:25 * hackagebot foscam-directory 0.0.6 - Foscam File format  https://hackage.haskell.org/package/foscam-directory-0.0.6 (TonyMorris)
20:36:02 <haskell958> Im trying to understand this piece of code http://lpaste.net/146191 from https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types Can someone help me annotate it?
20:41:08 <jle`> haskell958: your first annotation is sort of innacurate
20:41:35 <jle`> to construct a Pair a b, you need to provide an `(a -> b -> c) -> c`
20:41:49 <jle`> this isn't a function that takes an a and a b and produces a c...in some ways, it's the "opposite"
20:42:01 <jle`> it's a function that *uses* an (a -> b -> c) to create a `c`
20:42:56 <jle`> you don't give Pair an (a -> b -> c)...you give Pair a function that *uses* an (a -> b -> c) to create a c
20:43:15 <jle`> your second comment, runPair is the record accessor for Pair
20:43:29 <jle`> sort of like data Identity a = Identity { runIdentity :: a }, if you're familiar with Identity
20:43:39 <jle`> or data Sum a = Sum { getSum :: a }, if you're familiar with Sum
20:43:49 <pavonia> Is GHC adding this function automatically?
20:43:49 <jle`> record syntax is usually introduced fairly early in most haskell courses :)
20:44:33 <jle`> pavonia: is that directed to me?
20:44:38 <haskell958> is record syntax defined by the programmer?
20:44:44 <jle`> record syntax is a part of Haskell
20:44:47 <pavonia> Whoever can answer :p
20:45:15 <jle`> so like, if I made a data type `data Person = Person String Int`, which is a person with a name and an age
20:45:33 <jle`> i could get the person's name as getName :: Person -> String; getName (Person name _) = name
20:45:36 <pavonia> jle`: What I mean is, there's no accessor function defined in the code, yet it seems to appear in GHCi
20:45:56 <Pamelloes> "Pair" os a weird type.... It seems needlessly convoluted.
20:45:56 <jle`> or you could write data Person = Person { getName :: String, getAge :: Int }
20:46:19 <haskell958> okay so
20:46:31 <jle`> but yes, the name of the record is provided by the programmer
20:46:37 <jle`> i named it "getName" there
20:46:45 <jle`> there's no way GHC would invent a name for a record for you automatically
20:46:47 <haskell958> runPair is I get the function that produces the c?
20:46:55 <bb010g> How long until GHC 8 drops? I want the new accessors now. :)
20:47:22 <jle`> haskell958: runPair :: Pair a b -> (a -> b -> c) -> c
20:47:33 <chreekat> Where do I go to learn about autogenerated files like Paths_foo.hs ?
20:48:07 <jle`> haskell958: runPair on a Pair will take a function (a -> b -> c) and give you a c.
20:48:22 <jle`> haskell958: i think a part of the confusion might be on the polymrophic types.  fixing a and b might make it a bit easier to understand
20:48:53 <jle`> think of, say, Pair Int Bool
20:49:14 <jle`> or data PairIntBool = PIB { runPairIntBool :: forall c. (Int -> Bool -> c) -> c }
20:49:41 <jle`> try to implement a function that has the type (Int -> Bool -> c) -> c
20:50:03 <jle`> and things might start making sense
20:50:19 <haskell958> okay and c can be anything
20:50:19 <haskell958> ?
20:50:22 <haskell958> any type
20:50:26 <jle`> it has to be polymorphic
20:50:30 <jle`> so you can't choose a specific c
20:50:36 <jle`> you have to write it so that it works for any c
20:50:50 <jle`> so, defining foo :: (Int -> Bool -> String) -> String is not allowed :)
20:51:00 <jle`> define foo :: (Int -> Bool -> c) -> c
20:51:16 <jle`> foo f = ...?
20:51:19 <haskell958> I see so it has to return a value that is a member of all those types?
20:51:40 <jle`> it has to return a value that is the same type as the return value of the function given
20:51:54 <jle`> so, if i gave foo an (Int -> Bool -> String), it'd have to return a String
20:52:00 <jle`> think about it using typed holes
20:52:08 <jle`> foo f = f _ _
20:52:22 <jle`> (there is really only one thing you can do...you have to apply f to two values.  an Int and a Bool)
20:52:47 <Pamelloes> Well, undefined
20:52:54 <haskell958> oh. okay. so because I don't know what c is but I know what f gives me
20:52:57 <haskell958> I just return f
20:53:03 <haskell958> foo f = f
20:53:04 <haskell958> ?
20:53:04 <jle`> well, you have a way to get a `c` using f
20:53:08 <jle`> no, that doesn't typecheck
20:53:22 <jle`> you just wrote a foo :: (Int -> Bool -> a) -> Int -> Bool -> a
20:53:40 <jle`> what do you need to give `f` to get a `c` ?
20:53:56 <jle`> if I have an (Int -> Bool -> c), how can I get a `c` from it?
20:53:57 <haskell958> an int and bool
20:54:02 <jle`> mhm
20:54:07 <jle`> so, any ol' Int and Bool will work
20:54:12 <jle`> foo f = f 5 True
20:54:22 <jle`> that typechecks :)
20:54:34 <jle`> the idea is that that `foo` is "equivalent" to an (Int, Bool)
20:54:58 <jle`> or well, that foo i just wrote is "equivalent" to (5, True)
20:55:58 <haskell958> okay.. so for this makePair a b = Pair $ \f -> f a b 
20:56:06 <jle`> so, if I wanted to "construct" the tuple (5, True), i'd do Pair (\f -> f 5 True)
20:56:19 <jle`> if i wanted to "construct" the tuple (100, False), i'd do Pair (\f -> f 100 False)
20:57:11 <jle`> now, what are some things you might like to do with tuples?  well...you'd like to be able to project out of them.  it'd be nice to have a fst :: Pair a b -> a, and a snd :: Pair a b -> b
20:57:30 <jle`> and, you already wrote these, it looks like :)
20:57:53 <jle`> fst (Pair g) = g (\x y -> x), snd (Pair g) = g (\x y -> y)
20:58:30 <haskell958> cool cool.
20:58:32 <jle`> it'd also be nice to write a Pair a b -> (a, b) function
20:58:35 <jle`> can you think of what it'd be?
20:59:05 <haskell958> what is (a,b)?
20:59:11 <haskell958> \x y -> (x,y)
20:59:12 <haskell958> ?
20:59:16 <jle`> yes
20:59:22 <jle`> the (a, b) is the tuple that the Pair represents
21:00:10 <haskell958> cool cool. I have a small hangup on the makePair function
21:00:10 <jle`> you can think of a function `(Int -> Bool -> c) -> c` as something that has to 'contain' an Int and Bool somehow.  it's impossible to write a `(Int -> Bool -> c) -> c` without "giving" an Int and Bool.  with foo above, we had to use 5 and True
21:01:41 <haskell958> so the function already has the first 2 arguments?
21:01:49 <jle`> it's definitely possible to write an `(Int -> Bool -> String) -> String` without providing some sort of Int and Bool.  you can write baz _ = "hello".  but writing an `(Int -> Bool -> c) -> c`?  there isn't any way you can get around "providing" an Int and Bool somehow
21:01:57 <jle`> for what, makePair?
21:02:14 <jle`> yeah, what the function "contains" is the Int and Bool to apply to the `f` given
21:02:48 <haskell958> so for makePair a b = Pair $ \f -> f a b I get a function that contains the a and the b?
21:03:14 <jle`> yeah, the Pair holds a function that "knows" a and b
21:03:27 <haskell958> ah. 
21:03:29 <jle`> and essentially, a and b are the fst and snd fields of the tuple it encodes
21:04:00 <jle`> it's also really weird using a and b as both the type variables and the function arguments v.v
21:04:07 <jle`> makePair x y = Pair (\f -> f x y)
21:04:40 <haskell958> okay okay. 
21:04:42 <jle`> so, above, we had foo = Pair (\f -> f 5 True)
21:04:51 <jle`> and we could write myOtherTuple = Pair (\f -> f 100 False)
21:05:05 <jle`> or myThirdTuple = Pair (\f -> f (-9) True)
21:05:23 <jle`> makePair is a way to abstract over this
21:05:52 <jle`> makePair x y = Pair (\f -> f x y), so foo = makePair 5 True, myOtherTuple = makePair 100 False, myThirdTupole = makePair (-9) True
21:05:54 <jle`> etc.
21:06:54 <haskell958> oh okay. thx a lot.
21:07:13 <jle`> np
21:07:46 <jle`> haskell958: to me, the key to using/grokking existentials is understanding the implications of parametric polymorphism
21:08:27 <haskell958> Okay I know polmorphism is a value that can take on multiple types?
21:09:05 <haskell958> I was thinking that existentials are just a way to union some types together so that you can run some function on them that you know works for those types
21:09:06 <haskell958> ?
21:09:30 <jle`> parametric polymorphism is the idea that whatever function you give has to be implemented uniformly over *all* possible types
21:09:48 <jle`> so whatever function you give has to handle all of the potential inputs with the same implementation
21:11:38 <jle`> for example, in `data ShowBox = forall s. Show s => SB s`, from the article...the only way you can ever *handle* or use a value in a ShowBox is with a function that works uniformly over *all* possible showable s's
21:12:06 <jle`> so you can't, for example, do case myShowBox of SB x -> x + 3
21:12:42 <jle`> (even if you know that you put an Int in there originally)
21:14:43 <jle`> this is why a value of type `ShowBox` is equivalent to a value of type Show s => (s -> c) -> c
21:18:12 <ttt_fff> is there a shorter way to wite (\ x y -> liftIO $ f x y) ?
21:18:20 <ttt_fff> something like liftIO2 f
21:20:01 <pavonia> :t (liftIO .) . f
21:20:02 <lambdabot> (Show a, Show a1, MonadIO m, FromExpr (IO a2)) => a -> a1 -> m a2
21:20:49 <ttt_fff> I'm not sure I like this.
21:20:54 <ttt_fff> Though it's definitely impressive.
21:21:23 <pavonia> There are packages that define nice operators like (.:) for this class of functions
21:21:53 <bb010g> First push for telegram-bot for Haskell: https://github.com/bb010g/telegram-bot I'd appreciate any code review.
21:21:56 <jle`> i recommend against using the (f .) . g pattern in real code :)
21:22:36 <jle`> people sometimes define (.:), but i think that it's hard to beat the readability of the pointful form
21:23:10 <jle`> congrats bb010g :)
21:23:16 <ttt_fff> jle`: by commense I agree with you; but the question was "how to make this shorter" not "how to make this more readable", so pavonia technically wins
21:24:56 <pavonia> Actually, I define (.:) in most of my code because I need that quite often
21:25:34 <bb010g> I'm pretty happy with this bit; it's a containing ADT that can ToJSON and FromJSON like it was flat: https://github.com/bb010g/telegram-bot/blob/master/src/Network/TelegramBot/Methods.hs#L69-L106
21:30:34 * hackagebot opencog-atomspace 0.1.0.0 - Haskell Bindings for the AtomSpace.  https://hackage.haskell.org/package/opencog-atomspace-0.1.0.0 (romanT)
21:35:34 * hackagebot stable-marriage 0.1.0.0 - algorithms around stable marriage  https://hackage.haskell.org/package/stable-marriage-0.1.0.0 (KatsutoshiItoh)
21:39:35 <pharaun> now that's a curious package ^
21:40:11 <pharaun> not much doc in readme
21:40:14 <Pamelloes> Weird.
21:42:46 <sm> bb010g: in your readme, you could mention what the telegram bot api and telegram are
21:44:08 <bb010g> sm: Yeah, I'll put more there. That was a 15-second file so I could push something
21:44:27 <bb010g> Also, smeg, my APIToken
21:45:47 <bb010g> I need to make that pull from a separate file
21:49:08 <Pamelloes> Telegram can only support groups of 200 people. Looks like IRC is not in danger :)
21:49:22 <bb010g> Supergroups are up to 1000 now
21:49:29 <bb010g> Or 2000, I forget
21:49:36 <Pamelloes> Still....
21:49:42 <Pamelloes> :/
21:50:00 <bb010g> Yeah, 1000. Good for most IRC channels, but not #haskell yet. :D
21:50:08 <Pamelloes> :)
21:50:24 <Pamelloes> IRC is still better, of course. (not biased at all)
21:50:34 * hackagebot success 0.2.1 - A version of Either specialised for encoding of success or failure  https://hackage.haskell.org/package/success-0.2.1 (NikitaVolkov)
21:53:18 <bb010g> haskellbook.com may just have one of the better chapter names: "Monad (SPOOKY? No.)"
21:55:35 * hackagebot streaming-wai 0.1.1 - Streaming Wai utilities  https://hackage.haskell.org/package/streaming-wai-0.1.1 (WilliamCasarin)
22:05:35 * hackagebot success 0.2.1.1 - A version of Either specialised for encoding of success or failure  https://hackage.haskell.org/package/success-0.2.1.1 (NikitaVolkov)
22:10:43 <pavonia> "The types and functions are trivial and self-descriptive, hence this sentence is the sole documentation you get on them." :S
22:11:49 <bitemyapp> pavonia: where'd you find that?
22:12:12 <pavonia> In the last link hackagebot posted
22:12:53 <pavonia> It's not quite clear to me what "Left Nothing" denotes in "asEither :: Success a b -> Either (Maybe a) b"
22:12:57 <jle`> i don't quite agree with the sentiment v.v
22:13:29 <jle`> this package's documentation *might* just be a shining example of what's wrong with haskell's documenting culture v.v
22:13:39 <bitemyapp> jle`: the type doesn't really make sense.
22:13:48 <bitemyapp> jle`: it's specializing Left to 'Maybe a'
22:14:09 <jle`> i meant that i do'nt agree with the documentation's statement that the types and functions are self-documenting...there should be some actual documentation v.v
22:14:25 <bitemyapp> I kinda get what he's getting at, but I don't think it's more useful than ordinary Either.
22:14:35 <jle`> well, the point is to give Either an Alternative instance
22:14:41 <bitemyapp> there's no real reason to favor putting Maybe in the Left anyway, when you realize that Right can represent failure too.
22:14:43 <jle`> i think it's p useful
22:14:49 <bitemyapp> ah there
22:14:50 <jle`> but some documentation would help
22:15:04 <jle`> the whole point is that empty = Left Nothing
22:15:04 <bitemyapp> jle`: 'a'-less Left.
22:15:08 <jle`> yeah
22:15:18 <bitemyapp> kinda funny.
22:15:31 <bitemyapp> Trying to remember if I've wanted Alternative/MonadPlus for Either in the past.
22:15:47 <jle`> i've remembered reaching for it but having it not be there
22:15:50 <bitemyapp> seems like it could be a couple combinators instead.
22:15:58 <bitemyapp> first :: Either e a -> Either e a -> Either e a
22:16:06 <bitemyapp> last :: Either e a -> Either e a -> Either e a
22:16:13 <pavonia> What is Left Nothing then, an error without error message?
22:16:21 <jle`> yeah, but the whole point of giving it an instance is to be able to use it with Alternative-polymorphic functions
22:16:21 <bitemyapp> Left "lol" `first` Right 1 = Right 1
22:16:29 <jle`> so you can throw it into functions written over all Alternative's
22:16:38 <bitemyapp> well
22:16:54 <bitemyapp> I kinda wanted an example of Alternative and MonadPlus that wasn't parsers for the Parsers chapter anyway
22:16:58 <bitemyapp> guess I got my wish.
22:17:13 <jle`> Maybe and List are probably good examples heh
22:17:32 <bitemyapp> jle`: latter isn't very easy for new people to use.
22:17:50 <bitemyapp> jle`: former will seem redundant with the other Monoid types.
22:18:03 <bitemyapp> (some/many are treacherous)
22:18:11 <jle`> being able to be used with the Alternative-polymorphic functions is a nice advantage :)
22:18:21 <bitemyapp> I guess.
22:18:32 <jle`> i feel like i have heard talks about instance Monoid e => Alternative (Either e), but i can't remember if it was definitely lawful or not
22:19:42 <jle`> pavonia: it's basically data Success e a = Empty | ErrorWith e | SucceedWith a, so yeah
22:20:49 <bitemyapp> jle`: SOP form makes it more clear in this case, I think.
22:21:01 <jle`> i actually do feel like Monoid e => Alternative (Either e) is valid.
22:21:21 <jle`> not sure about MonadPlus though, but nobody can decide on MonadPlus laws anyway :3
22:21:51 <bitemyapp> jle`: this ties into my issue with Alternative and MonadPlus
22:22:05 <bitemyapp> jle`: they're only getting brought up as a generalization of some stuff you might want to do with parsers, as far as the book is concerned.
22:22:25 <bitemyapp> jle`: they are going to be hard to distinguish from "something other than the default Monoid with some other stuff thrown in"
22:22:42 <bitemyapp> jle`: then there's the laws
22:22:51 <jle`> at its heart Alternative is basically a Monoid instance for a * -> *-kinded type
22:22:56 <jle`> and nothing more
22:22:57 <bitemyapp> right
22:22:59 <bitemyapp> which is my point
22:23:04 <jle`> MonadPlus gives you some extra structure with respect to (>>=) though
22:24:16 <jle`> people like to think it forms a near semiring of some sort
22:24:40 <bitemyapp> jle`: *squints*
22:24:45 <bitemyapp> jle`: not without assuming a Monoid.
22:25:07 <jle`> the addition is mplus and the multiplication is (>>=)
22:25:17 <bitemyapp> jle`: oh you mean Alternative + MonadPlus?
22:25:29 <jle`> MonadPlus sort of implies Alternative heh
22:25:29 <bitemyapp> woops, just MonadPlus
22:26:08 <jle`> but yeah, MonadPlus is said to add extra structure on top of the monoid action of <|> and turns it into a near-semiring w.r.t. (>>=) as multiplcation
22:26:12 <bitemyapp> (>>=) would be multiplication plus some function application noise you don't care about.
22:26:23 <bitemyapp> we've already talked about the monoid bits of Monad a little in the book.
22:26:31 <bitemyapp> we talked about the monoid bits of Applicative _extensively_
22:27:30 <jle`> the idea is that 0 * x = x, (x + y) * z = x * z + y * z
22:27:53 <bitemyapp> Ya
22:28:18 <jle`> er sorry, 0 * x = 0
22:28:32 <jle`> so you can talk about MonadPlus as giving "absorbtion laws".  mzero >>= x = mzero, necessarily
22:28:47 <jle`> and that idea "distributes" over <|>
22:28:49 <bitemyapp> absorption
22:28:52 <bitemyapp> I think
22:29:42 <jle`> so (mzero <|> x) >>= y = (mzero >>= y) <|> (x >>= y) = mzero <|> (x >>= y) = x >>= y
22:29:49 <jle`> idk
22:30:06 <jle`> it makes for nice reasoning about how to "stop" evaluation of things and what failure "means" in a monadic context
22:30:14 <jle`> what failure means with respect to (>>=)
22:30:56 * hackagebot SWMMoutGetMB 0.1.1.0 - A parser for SWMM 5 binary .OUT files  https://hackage.haskell.org/package/SWMMoutGetMB-0.1.1.0 (siddhanathan)
22:30:58 * hackagebot cereal-conduit 0.7.2.4 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  https://hackage.haskell.org/package/cereal-conduit-0.7.2.4 (MichaelSnoyman)
22:31:11 <jle`> but yeah, a big problem with this formulation is that most MonadPlus instances don't follow these laws
22:31:13 <jle`> s/most/many
22:31:24 <jle`> so, MonadPlus becomes sort of a "uuughhh just abstract it however you want"
22:31:41 <bitemyapp> jle`: thus why I'm a bit grumpy about the typeclasses.
22:31:46 <bitemyapp> or at least MonadPlus.
22:32:22 <jle`> yeah.  but well, we want *some* sort of laws about MonadPlus, because otherwise `guard` is pretty useless
22:32:41 <jle`> at least, using guard polymorphically
22:33:29 <jle`> although i guess guard w/ sequence/(*>) is sometimes useful.  but most people use guard with >>=
22:34:22 <jle`> (guard on the right hand side)
22:35:04 <jle`> but who uses guard polymorphically anyways!
22:35:06 <jle`> nobody :O
22:35:56 * hackagebot conduit-extra 1.1.9.2 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.1.9.2 (MichaelSnoyman)
22:36:32 <jle`> maybe there really is no point for MonadPlus then.  if you never need to reason polymorphically with functions like `guard`, the laws don't add much.  the best MonadPlus can be said to encapsulate is some vague ill-defined intuition of sequencing after failure
22:37:19 <jle`> i want to believe that nobody writes code polymorphic over all (Alternative m, Monad m)
22:37:25 <bitemyapp> jle`: welcome to the pit of despair.
22:38:26 <jle`> well, one advantage that Alternative has over just "another Monoid" is that it requires that the instance be polymorphic over the applied type
22:39:02 <bitemyapp> what takes advantage of that?
22:39:03 <jle`> so if you write <|> for Maybe, you're not allowed to constrain on the a in `Maybe a` being a Monoid, like with the default Monoid instance
22:39:09 <bitemyapp> I mean, it's an advantage if that is what you mean
22:39:21 <bitemyapp> oh right
22:39:40 <bitemyapp> jle`: that sorta shunts Monoid into "conjunction" and Alternative into disjunction doesn't it?
22:39:45 <bitemyapp> jle`: since you can't ask for "more Monoid"?
22:40:28 <jle`> not sure enough on how you're using conjunction/disjunction to be able to meaningfully reply, sorry
22:40:51 <bitemyapp> multiplication/addition
22:40:55 <bitemyapp> and/or
22:40:56 * hackagebot SWMMoutGetMB 0.1.1.1 - A parser for SWMM 5 binary .OUT files  https://hackage.haskell.org/package/SWMMoutGetMB-0.1.1.1 (siddhanathan)
22:41:14 <bitemyapp> Monoid a => Monoid (Maybe a) ~ 'and' (combining the a values)
22:41:23 <bitemyapp> Alternative (Maybe a) ~ 'or' (pick one)
22:41:26 <bitemyapp> jle`: ^^
22:41:37 <jle`> but yeah, the "monoid action" with respect to <|> can be said to have some gauruntees on its implementation
22:41:59 <jle`> sort of.  well, the Monoid instance could definitely have been (<>) = (<|>)
22:42:11 <jle`> but that just makes the world a little less nice
22:42:44 <bitemyapp> jle`: yes but the point is that the Alternative addresses a strictly smaller universe of possibilities than the Monoid
22:42:53 <jle`> yeah
22:42:58 <bitemyapp> jle`: and that the possibilities that seem to be eliminated categorically are of the "and" variety.
22:43:34 <jle`> agree with the first statement but i can't conclude on how this generalizes to other types in general
22:43:41 <bitemyapp> I offer no proof.
22:43:47 <jle`> because the Alternative instance for [] is (++)
22:43:47 <bitemyapp> Just noticing that it precludes.
22:43:56 <jle`> er, (<|>) for [] is (++)
22:44:06 <bitemyapp> (++) doesn't read as "and" to me.
22:44:25 <bitemyapp> it's taking advantage of something specific to list which doesn't fit into the conj/disj duality
22:45:15 <jle`> i don't think i see how it generalizes, but i haven't put too much thought into it :)
22:46:01 <Axman6> (++) is definitely disjunction right?
22:46:42 <Axman6> I mean, with [] being the non-determinism monad, then "the result" is the results of the first list or the results of the second list
22:47:05 <Axman6> lists represent "this or this or this or..."
22:48:06 <shachaf> Or "this and this and this and..."
22:50:22 * Axman6 probably hasn't followed enough of the convo
22:52:43 <bitemyapp> Axman6: Cons data constructor is a product.
22:52:56 <bitemyapp> Axman6: so you've got a hill to climb if you want to argue that it represents disjunction.
22:53:12 <bitemyapp> Axman6: you could argue a _fold_ of a list represents choice and thus disjunction, but that's different from the datatype itself.
22:53:33 <bitemyapp> ie, a function that picks element(s) based on some criteria.
23:46:04 * hackagebot binary-parser 0.5.0.1 - A highly-efficient but limited parser API specialised for bytestrings  https://hackage.haskell.org/package/binary-parser-0.5.0.1 (NikitaVolkov)
23:51:05 * hackagebot HTTP 4000.2.22 - A library for client-side HTTP  https://hackage.haskell.org/package/HTTP-4000.2.22 (GaneshSittampalam)
