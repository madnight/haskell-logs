00:00:10 <wearenotdeadyet> Hijiri: if that's even possible
00:00:12 <Hijiri> it is
00:00:14 <wearenotdeadyet> the complication to JS, sure
00:00:24 <wearenotdeadyet> getting Haskell to create widgets on Canvas?
00:00:25 <kadoban> It just exists. In the same way, most widget libraries aren't really implemented in whatever language they're used in. Nobody likes doing the underlying widget stuff, it's pretty tedious. So there's a library implemented in C or C++ or something, and used in like 20 different languages.
00:00:27 <wearenotdeadyet> Don't know about that
00:00:30 <Hijiri> ghcjs is the name of a haskell-to-javascript compiler
00:00:35 <kadoban> Haskell isn't particularly special about that.
00:00:44 <liste> jasabella hi
00:01:09 <kadoban> wearenotdeadyet: You could certainly do that if you wanted to, but I'm not terribly sure what it would prove or be useful for.
00:01:12 * hackagebot zerobin 1.1.1 - Post to 0bin services  https://hackage.haskell.org/package/zerobin-1.1.1 (ip1981)
00:01:30 <wearenotdeadyet> kadoban: so your argument is that its too 'tedious', ok, fine, but I'm saying I don't know that Haskell *can* implement a widget library
00:01:40 <wearenotdeadyet> without extending the haskell language, at least
00:02:07 <Hijiri> the FFI is enough to do it
00:02:10 <wearenotdeadyet> I'm still learning/understanding Haskell, from what I know though it doesn't seem like it could
00:02:10 <MarcelineVQ> kadoban: Do you know a good resource for learning arrows?
00:02:11 <kadoban> wearenotdeadyet: It can as much as most other languages can.
00:02:32 <Hijiri> If you really wanted to, you could use SDL for rendering, and build your widget library on top of that
00:02:47 <kadoban> MarcelineVQ: Not really, I don't understand them much beyond what the individual parts kinda do. I mostly only know it as a cute tuple library, before I knew about Bifunctor.
00:02:49 <wearenotdeadyet> Hijiri: no, I'd want something in Haskell that didn't use SDL at all
00:03:00 <Hijiri> why
00:03:01 <wearenotdeadyet> why not just write the driver in Haskell
00:03:12 <Hijiri> all those other libraries are built on top of C/C++ libraries
00:03:14 <Hijiri> do they not count eitehr
00:03:36 <wearenotdeadyet> https://wiki.haskell.org/Foreign_Function_Interface <- This FFI?
00:03:47 <Hijiri> yes
00:03:49 <MarcelineVQ> kadoban: Fair enough, and in that case do you know a resource for bifunctor? I'll have a look at them now in case they're pretty obvious 
00:03:51 <wearenotdeadyet> so, its foreign, therefore it doesn't count...
00:03:59 <Hijiri> you're not using a foreign widget library
00:03:59 <liste> the system calls are C/asm anyway...
00:04:11 <kadoban> MarcelineVQ: They're pretty obvious. It's like Functor but with two instead of one.
00:04:14 <Hijiri> any language that isn't C has to go through C anyway to show anything
00:04:28 <wearenotdeadyet> no...
00:04:29 <Hijiri> or machine code
00:04:41 <wearenotdeadyet> anything has to go through machine code...that's fine
00:04:51 <wearenotdeadyet> haskell compiles to machine code, no?
00:05:06 <Hijiri> yes
00:05:34 <wearenotdeadyet> The question is whether or not haskell is capable of emmitting machine code capable of producing a functional driver for e.g. your screen
00:05:52 <Hijiri> So is the question whether you can inline asm in haskell, in order to do very low level things?
00:05:58 <kadoban> Now we're talking about drivers? O.o I thought this started as GUIs?
00:06:17 <wearenotdeadyet> kadoban: well, drivers are stateful, so are gui toolkits
00:06:29 <kadoban> So are my pants.
00:06:33 <Hijiri> you can write stateful programs in haskell
00:06:41 <wearenotdeadyet> the original question is knowing how to write those programs in haskell
00:06:55 <Hijiri> There are lots of ways of managing state in haskell
00:07:14 <wearenotdeadyet> calling it 'low level' is a poor/stupid excuse for why a language can't do something
00:07:34 <liste> wearenotdeadyet Metasepi used to write device drivers in Haskell, but they switched to ATS
00:07:49 <wearenotdeadyet> liste: interesting
00:07:58 <liste> because Haskell isn't really suitable for kernel programming
00:08:15 <wearenotdeadyet> liste: that's what I suspected
00:08:32 <liste> but that's mostly because it's garbage collected
00:08:38 <wearenotdeadyet> hmm
00:09:00 <wearenotdeadyet> I mean Haskell is great and all but it almost seems like you're main competitor is Matlab, Mathematica, et. all
00:09:03 <wearenotdeadyet> your*
00:09:10 <liste> wearenotdeadyet not at all
00:09:24 <liste> Haskell isn't very good for numerics
00:09:26 <cocreature> so because we can't do kernel programming we can only do CAS
00:09:30 <Hijiri> matlab/mathematica are not for general programming
00:09:32 <kadoban> wearenotdeadyet: ? That's a pretty bizarre choice of competitors.
00:09:40 <wearenotdeadyet> liste: what IS is it good at then?
00:09:44 * wearenotdeadyet is puzzled
00:09:49 <liste> wearenotdeadyet almost anything else but kernel programming
00:10:00 <kadoban> It's a general programming language, useful for the same things as C++, python, Java, lisps, etc.
00:10:03 <liste> Java, C#, Python, Ruby etc... also aren't good for kernel programming
00:10:32 <wearenotdeadyet> Java isn't good for kernel programming when it isn't the kernel...
00:10:51 <kadoban> Huh?
00:10:51 <wearenotdeadyet> its ok when your chip has an embedded VM
00:10:57 <Hijiri> I don't think you could write a widget library in straight Java either
00:11:04 <Hijiri> The reason you have swing is because it's provided by the libraries
00:11:07 <wearenotdeadyet> Hijiri: AWT?
00:11:14 <Hijiri> If haskell had GUIs built in then obviously haskell would have GUI too
00:11:22 <liste> there's not much choices for kernel programming: C, C++, Ada, Rust, ATS maybe
00:11:28 <Hijiri> but you couldn't built a new widget library "from scratch" in Java
00:11:34 <wearenotdeadyet> Pascal, Delphi
00:11:42 <wearenotdeadyet> Ada
00:11:45 <wearenotdeadyet> (I think)
00:11:47 <wearenotdeadyet> Ocaml?
00:11:58 <liste> ocaml is GC too (afaik?)
00:12:12 <cocreature> awt relies on the netaive window apis provided by the platform afaik
00:12:30 <kadoban> AWT is not all java, it calls into something lower level that's part of the platform, yeah.
00:12:44 <kadoban> The same way most GUI stuff in basically any high level language is going to do.
00:13:16 <wearenotdeadyet> kadoban: but the reason it does that isn't I think because it couldn't if it had access, but because the host operating system wouldn't let it...not that it couldn't
00:13:52 <wearenotdeadyet> If you gave the JVM access to the vga memory bank it would have no problem doing the graphics entirely itself
00:14:13 <kadoban> wearenotdeadyet: That doesn't seem to make any sense. How in java would you be making your own GUI library from scratch? What would that even look like? What would it be calling down to at the lowest level?
00:14:28 <kadoban> wearenotdeadyet: Ah I see. Haskell could do the same of course if you give it the same access.
00:14:53 <wearenotdeadyet> kadoban: ok. I'd be interested to see what it would look like, like I said. :)
00:14:58 <Hijiri> it seems odd that something only qualifies as GUI programming if you do it full stack starting at the driver level
00:15:16 <kadoban> It's a really weird implicit definition, yeah.
00:15:24 <wearenotdeadyet> Hijiri: its more a question of how not where
00:15:44 <wearenotdeadyet> the driver stuff I brought up because the answer "delegate to someone else" isn't very satisfying
00:15:45 <Hijiri> If you don't start at the driver level you have to use intermediate libraries
00:15:51 <Hijiri> that is a fact
00:16:05 <Hijiri> (the intermediate library could be the driver)
00:16:13 * hackagebot zerobin 1.2.0 - Post to 0bin services  https://hackage.haskell.org/package/zerobin-1.2.0 (ip1981)
00:16:23 <Hijiri> so if you don't delegate to anyone else at all, you necessarily start there
00:16:29 <wearenotdeadyet> "yes, we can do everything, except not really because we don't have that ability" vs "yes, we can do everything, except not because we don't have code running with those permissions"
00:16:54 <Hijiri> I thought this was about writing GUIs, not about doing everything?
00:17:05 <wearenotdeadyet> everything necessary for building a gui
00:17:10 <cocreature> if you want to do everything throw away your os
00:17:11 <cizra> Hijiri: By that logic, C++ or C can't do everything either. At least some bootloading parts are assembler.
00:17:13 <kadoban> wearenotdeadyet: I don't understand the comparison of those quotes. What is that supposed to be summarizing?
00:17:39 <wearenotdeadyet> kadoban: I'm trying to illustrate my question
00:17:43 <wearenotdeadyet> ability vs permission
00:17:57 <kadoban> wearenotdeadyet: Okay, be more verbose about the question maybe? I don't understand.
00:17:58 <liste> wearenotdeadyet you sure can do kernel code in Haskell (Metasepi did), but it isn't practical
00:17:58 <Hijiri> I think I want to stand back and remark that it doesn't really matter if you need to go through C to do something
00:18:12 <Hijiri> Because you get it done anyway, and you can wrap it up in a nice haskelly interface
00:18:27 <Hijiri> And it doesn't make your GUI worse in any quantifiable way
00:18:29 <liste> right tools for the job n'all
00:18:54 <wearenotdeadyet> liste: ok, so that would be the answer 'no, Haskell is not good at those types of jobs'
00:19:02 <kadoban> Hijiri: Indeed. Also that's exactly what's done in like, every high level language I know of (or the needed GUI stuff is just implemented as part of the language, meaning it's in C or something anyway).
00:19:10 <wearenotdeadyet> even if it IS capable of it
00:19:12 <kadoban> wearenotdeadyet: At kernel programming? Not really, no.
00:19:19 <wearenotdeadyet> kadoban: or at building guis
00:19:21 <liste> wearenotdeadyet it's bad for low-level graphics, but good for high-level widget libraries
00:19:27 <wearenotdeadyet> without using another library
00:19:30 <kadoban> wearenotdeadyet: It's fine for building GUIs.
00:19:41 <cizra> Can you write shared libs, linkable by other languages, in Haskell?
00:19:52 <wearenotdeadyet> kadoban: ok, so is there a library that uses e.g. SDL that creates widgets, in Haskell?
00:19:59 <kadoban> wearenotdeadyet: You're kind of making some weird distinction that doesn't exist. By your reasoning, nothing is good at GUIs except … C I guess? Maybe? Which is a ridiculously conclusion.
00:20:21 <cocreature> https://hackage.haskell.org/package/sdl2
00:20:25 <kadoban> Even then it doesn't make any sense. Even the GUI libraries in low-level languages mostly just call into OS stuff, so …
00:20:35 <wearenotdeadyet> cocreature: that's a binding to SDL, not a widget library
00:20:40 <cocreature> fair enough
00:20:48 <Hijiri> I thought this was about whether it was possible
00:21:03 <wearenotdeadyet> It sounds like again, the answer is 'no, Haskell is not good at building gui libraries"
00:21:06 <kadoban> wearenotdeadyet: I don't know of one, because like I said it'd be tedious and why? And what would it prove exactly?
00:21:10 <Hijiri> You can draw stuff to the screen, you can have data representing the things you want to draw
00:21:15 <Hijiri> what else do you need for a widget library?
00:21:26 <wearenotdeadyet> Hijiri: buttons, menus, whole host of things
00:21:46 <wearenotdeadyet> How would you implement Drag n Drop in haskell?
00:21:53 <Hijiri> using SDL?
00:22:18 <wearenotdeadyet> Hijiri: so you think it would be relatively easy using SDL?
00:22:28 <Hijiri> do you mean dragging elements in the thing, or do you mean draggin a file or something from another window
00:22:52 <Hijiri> I don't think it would be much harder than writing a widget library in any other language
00:22:54 <wearenotdeadyet> Dragging in general, either between windows in your toolkit, or as a tie in to the host OS
00:23:20 <wearenotdeadyet> Hijiri: ok, so, that's fine, you think it wouldn't be much harder than in any other language
00:23:33 <wearenotdeadyet> I'm still interested to see how that would work. :)
00:23:46 <wearenotdeadyet> Like I said saying 'its tedious' is a horrible excuse.
00:23:51 <Hijiri> I'm not interested enough to go out and write it
00:24:02 <kadoban> wearenotdeadyet: It's not an excuse, I'm not sure why you think it's an excuse, or what it's excusing.
00:24:11 <wearenotdeadyet> Hijiri: so that sounds like maybe its not that easy
00:24:21 <Hijiri> I'm not intersted in writing a widget library in any language at all
00:24:37 <wearenotdeadyet> Or maybe you're just not a good person to ask about it then. ;)
00:24:59 <Hijiri> Who would be a good person to ask about it?
00:25:01 <MarcelineVQ> how far is this goalpost gonna slide
00:26:09 <wearenotdeadyet> MarcelineVQ: I don't think its sliding: " I should think that...given how stateful gui programming is...and how anti-state (besides the Monad) haskell is...the very fact that all haskell gui programming is done in C++ would be a major tip off that its not a thing..." <- my original comment
00:26:24 <wearenotdeadyet> I haven't heard anything to contradict what I was saying here.
00:26:44 <wearenotdeadyet> Hijiri: maybe Metasepi would be good to ask
00:26:56 <kadoban> wearenotdeadyet: Haskell GUI programming isn't done in C++. It uses libraries which are then exposed in the language, /like happens in every language/.
00:27:07 <MarcelineVQ> That question has bene answered quite nicely thogh, but it wasn't the answer you wanted
00:27:49 <Hijiri> I think in any case the GUI/graphics libraries Haskell hooks into would be C more often than C++, since that's what the FFI provides for
00:28:07 <wearenotdeadyet> MarcelineVQ: I'm not sure what gave you that impression, my question has been answered, it sounds like in confirmation of what I already heard...
00:28:23 <wearenotdeadyet> Haskell doesn't do gui programming, just it uses the FFI
00:28:31 <wearenotdeadyet> its not well suited for that
00:28:33 <Hijiri> what is gui programming again?
00:28:37 <Hijiri> graphics drivers?
00:28:40 <MarcelineVQ> If it did then it's just because that's what you're wanting to hear
00:29:02 <wearenotdeadyet> MarcelineVQ: are you sure you're not hearing your own bias?
00:29:03 <Hijiri> Why does using the FFI disqualify from it being GUI programming?
00:29:20 <pyon> What's the difference between `do { x <- rpar foo ; y <- rpar bar ; rseq x ; rseq y; return (x,y) }` and `(,) <$> rseq a <*> rseq b` ?
00:29:22 <liste> Swing uses FFI too. is Swing programming not GUI programming?
00:29:54 <Hijiri> pyon: The first one evaluates x and y in parallel
00:29:57 <wearenotdeadyet> Hijiri: if A provides B, which provides C, and Haskell uses C, but does not provide C, then it doesn't qualify as providing C
00:29:58 <Hijiri> the second does not
00:30:08 <pyon> Mmm...
00:30:16 <wearenotdeadyet> if B provides C, and Haskell provides B, then it qualifies as providing C
00:30:24 <wearenotdeadyet> this is pretty simple
00:30:44 <Hijiri> when is "gui programming" providing something?
00:31:00 <kadoban> wearenotdeadyet: You explicitly contrasted with JS, mentioning canvas. Canvas isn't implemented in JS, it's implemented in the browser which is C or C++ usually. The DOM is also not implemented in JS. How is this not a double standard?
00:31:06 <flounders> I think by GUI he means graphical toolkits like GTK or Qt.
00:31:08 <liste> gui programming /= low level graphics code, it's that simple
00:31:09 <Hijiri> What do you need to provide to qualify as GUI programming
00:31:13 <wearenotdeadyet> flounders: yes
00:31:25 <wearenotdeadyet> there is no haskelwidgets
00:31:33 <wearenotdeadyet> just bindings to widgets other people wrote
00:32:22 <Hijiri> You said earlier that you didn't mean writing GUI frameworks
00:32:29 <Hijiri> Did you change your mind?
00:32:29 <kadoban> wearenotdeadyet: jquery, which you mentioned before as a contrasting example is /exactly/ bindings to widgets that other people wrote.
00:32:39 <wearenotdeadyet> Hijiri: can you quote me saying that?
00:32:41 <liste> wearenotdeadyet http://www.altocumulus.org/Fudgets/snapshots.html
00:32:46 <wearenotdeadyet> I don't think I did.
00:32:49 <wearenotdeadyet> Maybe you are confused.
00:33:16 <Hijiri> http://lpaste.net/144560
00:33:17 <wearenotdeadyet> liste: nice! thanks :)
00:33:19 <pyon> Is there any way to use applicative combinators (<$>, <*>, etc.) to indicate that multiple subcomputations can be done in parallel?
00:33:21 <liste> that's a widget library implemented on libx11(?) (just like gtk/qt)
00:33:26 <pyon> `do` notation is kinda verbose. :-|
00:33:46 <Hijiri> ^ wearenotdeadyet 
00:34:32 <wearenotdeadyet> Hijiri: for someone who's not very knowledgeable about gui's you seem to have spent a lot of time arguing about them...that suggests to me that you are taking some sort of offense to the suggestion haskell isn't good at doing something...that's fine. Just an observation though. :)
00:34:32 <Hijiri> or maybe you were responding to the earlier question of whether programming GUIs is GUI programming
00:35:00 <wearenotdeadyet> not very knowledgeable, or not very interested
00:35:02 <wearenotdeadyet> on of the two
00:35:04 <wearenotdeadyet> one*
00:35:31 <Hijiri> wearenotdeadyet: If I disagree with someone and think I have a valid argument, I'm inclined to argue
00:36:02 <Hijiri> and you still haven't clarified about earlier
00:36:08 <wearenotdeadyet> And yet you failed to make a very good argument.
00:36:09 <liste> wearenotdeadyet why reinvent the wheel? Qt/GTK/WxWidgets are already there, so it's less work to provide bindings for them
00:36:27 <liste> than write a whole widget library from scratch
00:36:31 <wearenotdeadyet> liste: why do I have to care whether I reinvent the wheel...
00:36:44 <kadoban> wearenotdeadyet: You don't. Reinvent away.
00:36:46 <wearenotdeadyet> its about knowing whether something can do something, no about 're-inventing whweels'
00:37:00 <wearenotdeadyet> can do something well*
00:37:53 <tzaeru> no reason to not write a simple GUI widget library if one wanted to. it's easy enough to do for fun.
00:37:57 <wearenotdeadyet> that sort of 'argument' makes me very suspicious...it sounds a lot like hand waving, not to mention that it doesn't actually prove any point...
00:38:08 <tzaeru> or.. "fun"
00:38:44 <wearenotdeadyet> Hijiri: I'm not altogether sure what you wanted me to clarify
00:39:34 <Hijiri> It seemed as though you were saying earlier that GUI programming /= writing GUI frameworks
00:39:48 <liste> wearenotdeadyet that's just the reason there's no full Haskell widget toolkits. even though Haskell can do it well, it's a lot of work, and no reason to do it.
00:40:56 <wearenotdeadyet> liste: and that's an answer (backed up by some proof). Thank you for the example, I'll look into it. :)
00:41:49 <liste> in '91-'96 GTK/Qt weren't really there, and that's the reason for Fudgets
00:42:43 <wearenotdeadyet> liste: still there's potentially the argument that Fudgets wasn't really easy to extend, because of the language it was written in, which is why its in a state of disrepair.
00:42:55 <wearenotdeadyet> Not saying that's true, but it could be.
00:47:24 <liste> ...or it could be because the funding for Fudgets stopped
00:47:35 <wearenotdeadyet> Like I said, I didn't say that was true.
00:48:04 <wearenotdeadyet> When you are being scientific it is good to be open to all the possibilities.
00:49:17 <liste> IMO that's a problem with Haskell, many projects are for PhD theses/dissertations, and the development stops after the paper is published
00:50:00 <flounders> Funding seems to be a problem for FOSS in general.
01:00:00 <Guest36189> can someone explain me how to define head without using parentheses? I tried head xs:_ = head xs
01:00:05 <Guest36189> and it doesn t work
01:00:37 <Guest36189> I know the correct syntax would be head (x:_) = x
01:01:32 <Hijiri> case statement?
01:01:45 <kadoban> Guest36189: Why not just use parenthesis?
01:01:54 <Hijiri> > let head xs = case xs of x:_ -> x in head [1,2,3]
01:01:57 <lambdabot>  1
01:03:33 <Guest36189> Hijiri: thank you
01:32:27 <ReinH> flounders: especially for things like documentation and support.
01:35:46 <flounders> ReinH: Who ever solves that problem is probably going to be as famous as Torvalds and Stallman.
01:36:06 <dibblego> head = foldr const
01:38:39 <pyon> dibblego: foldr1 perhaps?
01:38:50 <dibblego> ew
01:39:07 <pyon> I mean, foldr is total, const is total, you can't get a partial function out of that. :-|
01:39:09 <dibblego> I assume head is safe due to moral correctness
01:40:20 <dibblego> fast & loose reasoning 4 eva
01:40:40 <quicksilver> :t foldr const
01:40:41 <lambdabot> Foldable t => b -> t b -> b
01:40:53 <quicksilver> it's a version which lets you provide your own null case
01:41:16 * hackagebot HulkImport 0.1.0.2 - Easily bulk import CSV data to SQL Server  https://hackage.haskell.org/package/HulkImport-0.1.0.2 (smobs)
01:41:22 <quicksilver> so you can foldr const (error "< dibblego> ew")
01:41:23 <quicksilver> if you like
01:41:37 <dibblego> NO!
01:41:42 <pyon> dibblego: safeHead = Data.Monoid.getFirst . Data.Foldable.fold
01:42:11 <pyon> No, wait.
01:43:21 <dibblego> head = _Cons . _1
01:43:43 <pyon> dibblego: safeHead = Data.Monoid.getFirst . Data.Foldable.fold . map (First. Just) -- fix'd
01:44:04 <pyon> Err, First . Just -- space needed after First
01:44:37 <dibblego> that's listToMaybe
01:45:40 <pyon> dibblego: And what exactly should safeHead do, if not listToMaybe?
01:46:14 <dibblego> just sayin
01:46:23 <dibblego> > [1,2,3] ^? _Cons . _1
01:46:26 <lambdabot>  Just 1
01:46:30 <dibblego> > [] ^? _Cons . _1
01:46:32 <lambdabot>  Nothing
01:46:53 <pyon> Ah, cute. :-)
01:47:11 <dibblego> ! _Cons . _1 %~ (+1) $ [10,20,30]
01:47:19 <dibblego> > _Cons . _1 %~ (+1) $ [10,20,30]
01:47:21 <lambdabot>  [11,20,30]
01:47:25 <dibblego> > _Cons . _1 %~ (+1) $ []
01:47:27 <lambdabot>  []
01:47:50 <dibblego> head = _Cons._1 -- includes getter and setter
01:55:09 <quicksilver> it's called _head
01:55:11 <quicksilver> but yes :)
01:55:30 <quicksilver> > _head %~ (*5) $ [10,20,30]
01:55:33 <lambdabot>  [50,20,30]
01:57:15 <solrize> apt-get install ghc on debian 8.1 arm linux didn't install ghci -- is that an intentional thing?
01:58:20 <solrize> hmm it's split out into a separate package for ghc 7.8
01:58:29 <solrize> but the repo has 7.6 and etc
01:58:38 <solrize> it's late i'll mess with it more some other time.  thanks
02:14:46 <dsop> If am fairly new to haskell and I am trying to use QuickCheck. I am creating instances of Arbitrary, however I need to create an  instance of (Maybe a). What's the best way to achieve writing such a instnace of arbitrary?
02:17:45 <Guest36189> why do I have to use open parentheses for safetail (_:xs) = xs instead pf rectangular ones?
02:18:27 <pavonia> dsop: Isn't there already such an instance?
02:19:01 <pavonia> Guest36189: square brackets denote lists
02:19:52 <ent> [_:xs] would be of type [[a]] and you probably want [a]
02:20:23 <Guest36189> ent: I see
02:20:24 <pavonia> dsop: There's Arbitrary a => Arbitrary (Maybe a)
02:21:39 <dsop> pavonia: yes. Let me rephrase my problem: I have a type Universe. I generate it via a function universeMaybe, which returns Maybe Universe. I want to use taht one inside quickcheck
02:22:02 <dsop> pavonia: there is a high possibility i am doing something terrible wrong and don't know why
02:23:51 <pavonia> dsop: What do you want to do with the Maybe Universe value?
02:25:12 <Guest36189> isn't there something like python tutor but for haskell? http://www.pythontutor.com/
02:26:18 <dsop> pavonia: either just return values that are just from arbitrary (can't figure out how to that either) or use it inside a property
02:26:27 <pavonia> Guest36189: tryhaskell.org maybe
02:27:08 <ent> python tutor seems to be a debugger with visualizations, not just an online repl
02:27:13 <Guest36189> pavonia: that doesn't show all the steps the program is going through
02:27:15 <ent> pretty cool, actually
02:27:33 <dsop> pavonia: if i caould so something like suchThat isJust (universeMaybe ...) that'll be good enough but that requires me to get a Gen (MaybE Universe) somehow
02:27:39 <Guest36189> ent: ye, I learned alot from it
02:28:50 <pavonia> dsop: Do you have an Arbitrary instance for Universe?
02:29:37 <dsop> pavonia: http://lpaste.net/5320550115566419968
02:30:18 <dsop> pavonia: no i don't because the type creation can fail, so the only way to get a type is universeMaybe, you can do fromJust . universeMaybe that but that can throw an exception
02:31:22 <dsop> pavonia: it's basically a more complicated type taht checks some assumptions about whatever you want to add and then either returns Nothing if it failed or Just
02:31:41 <dsop> pavonia: i mean that desing might already be the probelm, again fairly new to haskell, not sure if that's the right way or not
02:33:06 <pavonia> dsop: I'm not really familiar with QuickCheck but you can write an instance for Maybe Universe only that returns only legal values of this type
02:33:39 <ent> Guest36189: I don't think there is anything for haskell with visualizations that nice but ghc does have a debugge
02:33:42 <ent> r
02:33:46 <ent> Guest36189: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html
02:34:11 <dsop> pavonia: k thx. I'll probably go with my recursive version. Works but doesn't look nice. I appeciate the help :)
02:34:17 <pavonia> dsop: Or maybe that would lead to overlapping instances, so better stick with the Universe instance directly
03:03:15 <zawefwef> lets say: in ghci ive spawned a rogue process (eg with forkIO $ forever $ print $ replicate 100 'a') is there any way to kill it without killing the whole ghci process? thank you!
03:04:59 <Hafydd> zawefwef: forkIO returns a ThreadId. Use it with killThread :: ThreadId -> IO ().]
03:05:10 <roelof> Anyone who is using a test framework when you have a lot of tests ?
03:08:42 <zawefwef> Hafydd: is there an other way, something like sending it a special signal?
03:10:13 <Hafydd> zawefwef: there is throwTo :: Exception e => ThreadId -> e -> IO ().
03:10:36 <Hafydd> I don't know of a way to do it without knowing the ThreadId, if that's what you want.
03:10:51 <roelof> How do you experts keep track of a code which has many tests ? 
03:11:35 <zawefwef> i would like to do it from the shell
03:14:57 <zawefwef> Hafydd: i will use the killThread function. that also works for me. thank you!
03:17:53 <Hafydd> zawefwef: that's unlikely to be feasible, then, because forkIO spawns a lightweight thread. Any exit signal you send to the GHCi process would do nothing (if it's SIGINT) or terminate the whole process.
03:18:30 <Hafydd> Note: a lightweight thread does not correspond to a particular operating system thread.
03:19:25 <Hafydd> As for terminating a true thread, e.g. spawned with forkOS, I don't think you could use a signal to do that; but there is probably some hack.
03:19:41 <quchen> forkOS is also not an operating system thread.
03:20:35 <cow_2001> how do i deal with a bunch of `a -> Either b c` functions? there's Control.Monad.Except which i don't get how to use
03:20:47 <quchen> It's forkIO, but with the guarantee that the stuff running on it will be thread local.
03:21:21 <jameseb> cow_2001: what do you mean "deal with"?
03:21:30 <Hafydd> quchen: do you believe it's feasible for that to be done without spawning an OS thread?
03:21:48 <E4xoi> cow_2001: >>= ?
03:22:26 <E4xoi> cow_2001: or >=>, I don't know what you exactly want
03:23:09 <cow_2001> i currently use: let new = case f a of { Left e -> error e; Right b -> b }
03:23:16 <cow_2001> or somesuch
03:23:44 <mauke\{0}> :t either error id
03:23:45 <lambdabot> Either [Char] c -> c
03:23:53 <cow_2001> oh.
03:24:08 <mauke\{0}> but why are you using error?
03:24:16 * cow_2001 shrugs
03:24:27 <jameseb> cow_2001: is there a specific reason you want it to error?
03:24:54 <cow_2001> it's code used to load an image file and convert it into another format
03:25:35 <cow_2001> the library functions i use are `a -> Either b c`
03:25:55 <cow_2001> what happens if the type of `b` here is not String?
03:26:08 <quchen> Hafydd: I should investigate that a bit more before answering. :-)
03:27:05 <jameseb> cow_2001: b has to be String for your current code to work
03:28:03 <cow_2001> yeah, error takes a String
03:28:26 <Guest36189> this syntax looks confusing
03:28:30 <Guest36189> a && b = if a then if b then True else False else False
03:28:47 <Guest36189> it's a new definitia for &&
03:28:57 <mauke\{0}> that's because it is confusing
03:29:18 <E4xoi> if b then True else False is just b
03:32:33 <quchen> Guest36189: Pattern matching would be much less confusing.
03:32:53 <cow_2001> mauke\{0}: thanks!
03:33:05 <cow_2001> either cleaned up my code
03:33:51 <cow_2001> but I don't understand how to use Control.Monad.Except
03:34:27 <E4xoi> cow_2001: which library are you using?
03:36:16 <quchen> Hafydd: The documentation doesn't seem to hint that there is a new OS thread for each forkOS. What it does guarantee is that forkOS'd threads will always be scheduled onto the same OS worker thread.
03:36:27 <quchen> forkIO on the other hand is just scheduled to any free thread.
03:37:05 <cow_2001> E4xoi: gloss, bmp and JuicyPixels
03:37:20 <E4xoi> cow_2001: oh, ok
03:39:09 <Gurkenglas> cow_2001, if you have a bunch of (a -> Either b a) function and want to compose them, that's what (>=>) does for the Either monad.
03:40:46 <cow_2001> :t (>=>)
03:40:48 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
03:40:53 <cow_2001> ah
03:41:55 <Gurkenglas> :t (<=<) -- Closer to .
03:41:57 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
03:42:03 <Hafydd> quchen: but for that to be possible, there has to be a unique OS thread for each thread: suppose two such threads were assigned the same OS thread, then they both performed foreign IO at once. However, it's true that killing this thread perhaps won't (cleanly) kill the corresponding Haskell thread.
03:42:36 <quchen> Hafydd: Why can't you schedule all bound threads onto the same OS thread?
03:42:52 <quchen> I mean they would have to take turns, yes
03:43:18 <quchen> And killing that OS thread would make Haskell crash
03:43:25 <quchen> But still, it should be feasible
03:44:12 <Hafydd> quchen: because that could cause a deadlock with two threads each performing a foreign call an expecting to do it concurrently with the other.
03:44:51 <Hafydd> quchen: well, if you mean scheduling the Haskell execution, then that's possible.
03:48:03 <roelof> How do you experts keep track of a code which has many tests ? 
03:48:56 <quchen> I don't understand the question.
03:49:19 <mauke\{0}> with a telescope
03:49:29 <quchen> Hafydd: Hm, I'm just a bit careful with saying things the docs don't mention, and I can't find anything about spawning a new OS thread.
03:49:57 <quchen> The guarantee I'm interested in on the Haskell side is that it'll always be the same thread, and the rest is up to the RTS.
03:51:46 <Hafydd> quchen: I'm basing this on <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/Control-Concurrent.html#boundthreads> and on the logical argument given above; I wouldn't use it to advise on something that's supposed to work in the long term, of course.
03:52:24 <Hafydd> quchen: and, yes, perhaps it doesn't involve the /spawning/ of a new OS thread.
04:03:36 <joco42> what does linting mean ?
04:03:52 <joco42> is it code beutifier ?
04:03:57 <phadej> no
04:04:03 <phadej> it's static checker
04:05:11 <phadej> generically, lint or a linter is any tool that flags suspicious usage in software written in any computer language.
04:05:58 <joco42> does lint compile the code?
04:06:10 <mauke\{0}> the original lint was for C because old C didn't have typed function parameters (among other things)
04:07:10 <joco42> i mean, does HLint contain ghc?
04:07:17 <quchen> no
04:07:18 <phadej> no
04:07:37 <joco42> so HLint does not catch some compilation errors....
04:07:41 <joco42> right?
04:07:44 <quchen> xes
04:07:51 <mauke\{0}> it's not meant to catch compilation errors, generally
04:07:55 <phadej> it wouldn't make sense as you could use ghc for that :)
04:08:03 <joco42> ok, cool, thanks... 
04:08:27 <joco42> this page is kinda helpful too http://community.haskell.org/~ndm/darcs/hlint/hlint.htm
04:08:29 <phadej> IIRC you can run ghc without producing objects, to speedup iteration cycle
04:08:38 <statusfailed> I have a type `newtype S = S { unS :: a }`, and I want to make ( (a -> String) -> S a ) an instance of a class
04:08:41 <statusfailed> what's the syntax for that?
04:09:00 <statusfailed> this doesn't work: "instance FooClass ( (a -> String) -> S a )" because that function has kind * instead of * -> *
04:09:02 <blueonyx> hi, how to tell ghci i want to continue my expression in the next line? like \ for bash
04:09:10 <joco42> thanks for the info ...
04:09:20 <joco42> phadej and mauke\{0}  
04:09:33 <mauke\{0}> :{ IIRC
04:09:40 <quchen> statusfailed: You can only make type constructors instances of things, not arbitrary types.
04:09:55 <quchen> You can write instances for S, but not for "String -> S -> Bool" for example.
04:09:57 <mauke\{0}> statusfailed: 'a' is not in scope in that newtype definition
04:10:14 <mauke\{0}> quchen: not even with FlexibleInstances?
04:10:16 <phadej> blueonyx: have you tried :m +x
04:10:17 <quicksilver> statusfailed: sounds like you actually meant you want to make newtype SS a = SS ( ( a -> String) -> S a ) an instance
04:10:26 <phadej> blueonyx: sorry, :set +m
04:10:27 <quicksilver> the point is precisely the kind error
04:10:43 <statusfailed> quicksilver: ah yeah I think that's what I want
04:11:14 <quchen> mauke\{0}: Maybe. I'm never sure what FlexibleInstances allows you to do exactly. In this case it would be an instance for (->) with crazy arguments.
04:11:19 <quicksilver> Functor is of kind * -> * so you do indeed have to express what you want as a thing of kind * -> *
04:11:40 <blueonyx> phadej: ah thanks
04:11:48 <statusfailed> I was confused by this: http://okmij.org/ftp/tagless-final/course/PushNegF.hs
04:12:04 <statusfailed> in which there is this instance: instance ExpSYM repr => ExpSYM (Ctx -> repr) where
04:12:16 <phadej> blueonyx: http://stackoverflow.com/questions/2846050/how-to-define-a-function-in-ghci-across-multiple-lines you probably need to use let to make ghci wait for more input
04:12:32 <statusfailed> and now I'm confused again
04:13:23 <statusfailed> The only difference I can see is that "repr" is not a concrete type
04:13:36 <statusfailed> I guess that's enough ?
04:14:21 <quicksilver> ExpSYM is a class of kind * though
04:14:21 <statusfailed> oh and oleg's repr has no type associated with it
04:14:23 <statusfailed> dweee
04:14:30 <quicksilver> repr is just a type variable there
04:14:34 <quicksilver> it could be 'a'
04:14:36 <statusfailed> right, not a kind
04:14:36 <statusfailed> ok
04:14:39 <statusfailed> thanks :-)
04:14:45 <statusfailed> err, not a * -> * I mean
04:17:42 <merijn> statusfailed: Allow me to inject my usual pedantry that "concrete type" is an ill-defined term and thus only makes conversations more confusing
04:18:28 <quchen> merijn: How so? Isn't a concrete type simply one of kind *?
04:18:51 <quicksilver> quchen: is 'a' a concrete type? :)
04:18:58 <quicksilver> what about [a] ?
04:19:04 <merijn> quchen: Some people say any monomorphic type, others any type of kind * and yet again others say a monomorphic type of kind *
04:19:05 <statusfailed> merijn: ^ now I see what you mean :-)
04:19:16 <statusfailed> I was about to ask the exact same questions, he he
04:19:22 <quicksilver> some people say if it doesn't have kind * it's not even a type
04:19:24 <merijn> Better just use monomorphic, kind *, etc. explicitly
04:19:32 <merijn> quicksilver: Those people are objectively wrong
04:19:37 <quicksilver> terminology is great, we all get to make up our own.
04:19:49 <statusfailed> quicksilver: just like standards!
04:20:03 <quicksilver> well standards are normally made up by other people.
04:20:08 <quicksilver> but the effect is similar.
04:20:18 <statusfailed> unless it's OAuth
04:23:18 * hodapp tries to remember to not use the term 'concrete type'.
04:34:37 <roelof> How do you experts keep track of a code which has many tests ?  
04:35:00 <mauke\{0}> roelof: could you stop spamming, please?
04:35:38 <RainBowww> can i spam can i spam too
04:36:29 <roelof> mauke\{0}:  im just "spamming" because I do not get a answer to my question 
04:36:37 <mauke\{0}> roelof: yes, you did
04:36:41 <mauke\{0}> you just ignored it
04:37:40 <roelof> mauke\{0}:  oke, then I missed it. I will reread this conversation to find the answer 
04:37:50 <mauke\{0}> <quchen> I don't understand the question.
04:37:57 <roelof> I apolize for spamming then ? 
04:38:04 <mauke\{0}> <mauke\{0}> with a telescope
04:38:29 <RainBowww> Every time i see Maybe i hear Enrique Iglesias plz help :(
04:38:51 <mauke\{0}> RainBowww: https://www.youtube.com/watch?v=fWNaR-rxAic
04:39:07 <RainBowww> noooooo
04:39:08 <RainBowww> XD
04:39:20 <roelof> quchen:  what I mean is I have some big code which has some 20 test. Do you experts then use a test-framework or just using QuickCheck and Hunit 
04:39:49 <mauke\{0}> what do you count as a "test"?
04:39:59 <mauke\{0}> because 20 sounds like a very small number
04:41:08 <roelof> Every QuickCheck test for a property or a Hunit test is one test for me 
04:43:22 <mauke\{0}> wait, I thought QuickCheck and HUnit were test frameworks
04:44:14 <bernalex> they are.
04:44:20 <roelof> mauke\{0}:  I mean with test frameworks more Test Framework or Tasty 
04:47:44 <mauke\{0}> ok, I've never done any testing in haskell, but 20 tests is tiny
04:48:16 <merijn> mauke\{0}: Still more tests than every single piece of academic code I've ever seen :p
04:48:25 <merijn> Even if you combine them :p
04:48:54 <bernalex> merijn: yell at the profs :p
04:49:02 <mauke\{0}> the project I'm working on now (not haskell) has more than 100,000 individual tests
04:50:09 <merijn> bernalex: And at myself... :p
04:50:37 <bernalex> hell, my teeny tiny "intro to the basics of fp" module had some 80 tests. quickcheck makes it very easy to write tests.
04:50:53 <merijn> Any recommendations for simplest line editing library if I want a commandline type dealio?
04:51:21 <mauke\{0}> I have a pretty simple data manipulation module on CPAN. it's undertested, but it still has 73 tests
04:51:22 <merijn> haskeline?
04:51:33 <mauke\{0}> merijn: yeah, that would be my first try
04:51:52 <bernalex> merijn: at work I tend to follow this semi-rigidly: write a test that shows what functionality I want. write the necessary types out (as type signatures in the src). write the haddocks that describe how the function denotes. then write the function.
04:52:20 <bernalex> I feel like I need to spend more time on denotational semantics in there (between types and actually writing the code) though.
04:52:25 <merijn> I write GPU kernels (fixpoint ones too, so results can differ) and my other work project is a lambda calculus compiler (which is heavily in flux)
04:52:45 <merijn> Both are a pain to test beyond "run something and check if the results are what I expect"
04:52:47 <flux> so lambda calculus compiler for the gpu? cool ;-)
04:53:06 <roelof> oke, thanks for the help 
04:53:22 <merijn> flux: No, that'd be doomed to be useless
04:53:36 <flux> merijn, yet a lambda calculus compiler is useful? must be I suppose :)
04:53:38 <quicksilver> bernalex: IMO that process only works when you have a clear idea of what is possible and what the right API is.
04:53:56 <bernalex> quicksilver: I disagree. I use this process to find out exactly that.
04:54:18 <quicksilver> sometimes I need to experiment to work out the best types
04:54:20 <merijn> flux: I do research, a lambda calculus compiler is useful if you use it to prototype type system things :)
04:55:00 <bernalex> for me, some of the main purposes of writing a denotational semantics, is to 1. figure out what I truly am woring with/want, and 2. experiment with different ways of getting there before settling on an operational semantics that compliments my denotational semantics nicely. 
04:57:00 <merijn> flux: Also, learning how to write compiles is probably the most useful thing you can learn to understand programming :p
04:57:21 <merijn> Once you know how to write compilers, every problem looks like a programming language :p
04:57:54 <hodapp> I guess that's better than every problem looking like a class or an object
04:58:04 <flux> well yes, that's suitable for research, but perhaps not for corporate endeavours :)
04:58:34 <flux> well, unless you're in the business of (say) formal proving
04:58:56 <merijn> flux: Tell that to Carter and his team doing compiler development at JP Morgan ;)
04:58:58 <quicksilver> lots of much more pedestrian "corporate" projects could be solved by writing a compiler
04:59:09 <quicksilver> or designing an EDSL which lets you use an existing compiler as a compiler.
04:59:16 <quicksilver> (and indeed this does happen)
04:59:19 <merijn> quicksilver: Exactly
04:59:42 <hodapp> I didn't need to write a compiler.
04:59:47 <merijn> There's two solutions to "this business problem requires 100k lines of boilerplate" 1) throw interns at it 2) write a compiler to generate the boilerplate :p
04:59:52 <hodapp> So I wrote a compiler and then realized that I wrote a compiler later.
05:00:15 <mauke\{0}> merijn: 3) eclipse
05:00:19 <quicksilver> #include <folklore/bugridden_commonlisp>
05:00:40 <merijn> hodapp: :p
05:00:59 <bernalex> who do you pm about spamflooding in freenode again?
05:01:09 <bernalex> tsoutseki is probably spamming a lot of you guys too
05:01:12 <mauke\{0}> #freenode?
05:01:18 <bernalex> maybe they'll be kickbanned before I can be bothered
05:01:32 <hodapp> The issue I ran into at the last job is that the 'compiler' they made started to envelope every other component of the system, and it was a very hacky, kludgey compiler
05:01:49 <hodapp> and then when you had ugly code that had to interface with this, the natural solution was to bring that ugly code into the compiler too
05:01:51 <tsoutseki> bernalex, nah
05:01:53 <tsoutseki> bernalex, it was an accident
05:02:37 <flux> merijn, compiler writing has its commercial uses, but lambda calculus compiler writing little less so ;)
05:02:55 <hodapp> Ehh?
05:03:10 <flux> for example, working in a software subcontractor firm, even I have worked on a compiler (webcl verification), but it's the only project I've heard of here.
05:03:40 <hodapp> If the full state of what is commercially viable is only what I have heard of, then software is doomed.
05:04:21 <flux> hodapp, would you say lambda calculus compiler writing is involved is more than 1%. of software projects?
05:04:30 <flux> (s/is more/in more/)
05:04:59 <hodapp> I have no idea. If that's what they're implementing, and they just don't realize it, then perhaps.
05:05:39 <hodapp> I'm not sure why an exact percentage value of such an amorphous blob of comparison is relevant.
05:05:55 <mauke\{0}> I wrote a compiler once and realized that really shitty type inference is trivial to implement
05:06:17 <hodapp> mauke\{0}: really shitty type inference?
05:07:09 <bernalex> infer (Ty x) = MkInt x `except` error "Couldn't infer :'("
05:07:35 <mauke\{0}> no unification. concrete types only. final destination.
05:09:32 <mauke\{0}> basically, it collects type information as it goes, and it never goes back to revise anything. the main thing it cares about is variable types because it targets C so it needs to know what to declare
05:10:12 <mauke\{0}> the type of an expression can be computed because the types of all variables are known beforehand
05:10:47 <mauke\{0}> the type of a variable is derived from the initializer expression, or (if missing) by a really ad-hoc lookahead scan that may or may not fail
05:11:36 <ggole> What about arguments? They have no initializing expression.
05:12:04 <mauke\{0}> heh
05:12:49 <mauke\{0}> the language has some interesting features that turn out to be hacks on top of hacks, like the ability to "rewind" back to a previous saved state in the program, including the full call stack
05:12:55 <mauke\{0}> or polymorphic functions
05:13:29 <ggole> Sounds like call/cc
05:13:30 <mauke\{0}> all "functions" are inlined. recursion is not allowed. it's effectively macros
05:13:41 <ggole> ...never mind
05:13:55 <mauke\{0}> every instantiation of a function is type checked independently, at the point where the arguments are available
05:14:23 <mauke\{0}> "rewind" is just goto, because at the C level it's all one function
05:15:43 <mauke\{0}> function foo(x) { return x; }  var y = foo(42);  // turns into: var _tmp = 42; var y = _tmp;
05:20:16 <merijn> Anyone know if there's some package that can generate haskeline completions from a set of words?
05:42:04 * hackagebot rdf4h 1.3.5 - A library for RDF processing in Haskell  https://hackage.haskell.org/package/rdf4h-1.3.5 (RobStewart)
05:42:06 * hackagebot typed-wire 0.2.1.3 - WIP: Language idependent type-safe communication  https://hackage.haskell.org/package/typed-wire-0.2.1.3 (AlexanderThiemann)
05:49:07 <mniip> hmm
05:49:22 <mniip> there is no good way to represent zero-based naturals in binary is there
05:50:01 <mniip> like, if I say data N = One | Times2 N | Times2Plus1 N
05:50:11 <mniip> it would be isomorphic to the natural number set
05:50:46 <mniip> or rather, each number would have a unique representation and every number would be represented
05:51:19 <merijn> mniip: It's not isomorphic, as you don't have a mapping for zero ;)
05:51:45 <ggole> mniip: are you concerned about having zeros of different lengths?
05:52:43 <mniip> merijn, it's obvious that if I mention zero-based naturals, then by default naturals are one-based
05:52:48 <mniip> ggole, exactly that
05:53:26 <frerich> mniip: Maybe something like 'data N = Zero | Pow2 Int | Sum N N'?
05:54:20 <merijn> mniip: "zero-based naturals" "by default naturals are one-based" <- that seems like a gross abuse of terminology
05:54:54 <mniip> I'll just call them N and N_0 :P
05:55:09 <ggole> Erm, if you can represent one-based naturals exactly then surely it's trivial to represent that plus one more number exactly
05:55:22 <ggole> Although it'll be an annoying special case
05:55:29 <TheOnionKnight_> data N = Zero | DoublePlusOne N | DoublePlusTwo N has a unique representation for each value and isn't too hard to work with.
05:57:10 * frerich only now gets what's meant by 'unique representation' ahem
05:58:23 <nshepperd> TheOnionKnight_: that looks familiar...
05:58:58 <tdammers> if I remember my Math classes correctly, 0 is not a natural number
05:59:31 <nshepperd> edwardk mentioned a binary numeral system with digits 0, 1 and 2 in passing in some talk, something to do with skew heaps?
05:59:59 <mniip> N and N_0 have their own advantages
06:00:04 <mniip> and it's hard to say which one is better
06:00:05 <nshepperd> tdammers: your math classes lied. turns out people disagree about conventions
06:00:16 <mniip> and which one should be the default
06:00:42 <merijn> tdammers: Wut
06:00:47 <bernalex> tdammers: both non-negative and positive integers are called natural numbers. the systems where 0 are a part of natural numbers are sometimes called "whole numbers" rather than natural numbers.
06:01:00 <merijn> bernalex: 0 is positive, heathen!
06:01:09 <ggole> "skew binary numbers"?
06:01:16 <bernalex> merijn: no.
06:01:20 <ggole> I think Okasaki's book goes into those
06:01:26 <ggole> Don't recall the details.
06:01:32 <nshepperd> yeah, that was it
06:02:00 <bernalex> see http://mathworld.wolfram.com/NaturalNumber.html
06:02:05 <merijn> > isNegativeZero 0 -- IEEE754 says so!
06:02:07 <lambdabot>  False
06:02:35 <quicksilver> > isNegativeZero (-1*0)
06:02:36 <lambdabot>  True
06:03:07 <bernalex> merijn: I was talking about maths texts, not IEEE754.
06:03:22 <nshepperd> well, IEEE754 also includes infinity and NaN, so it's pretty much drunk
06:03:24 <tdammers> nshepperd: yeah, I figured
06:03:37 <tdammers> suppose this was for didactic reasons
06:03:39 <nshepperd> signed 0 is a hack to get around not having infinitesimals
06:03:47 <mniip> I wonder what's lim_x->nan sin(x)
06:03:50 <ggole> "In skew binary numbers, the weight wi of the ith digit is 2^i+1 - 1, rather than 2^i as in ordinary binary numbers. Digits may be 0, 1, or 2..."
06:03:56 <tdammers> something about farmers counting sheep or something
06:04:05 <tdammers> also, historically, positive integers predate zero
06:04:18 <nshepperd> yeah looks like skew binary numbers aren't really what's happening here
06:04:36 <ggole> Mmm.
06:04:45 <nshepperd> though it might be fun to try make a haskell data type out of them anyway
06:05:17 <kras> Hi, I am trying to read in a file from command line, I have the following http://lpaste.net/144576
06:05:37 <kras> stack exec hverilog < filename
06:06:04 <kras> it doesn't print the result not it complains about the error
06:06:16 <kras> why is this? Any hints appreciated
06:07:04 * hackagebot parsec-trace 0.0.0.2 - Add a hierarchical trace to Parsec parsers.  https://hackage.haskell.org/package/parsec-trace-0.0.0.2 (sleepomeno)
06:11:39 <anks> I'm parsing bytestring with attoparsec. What i want to accomplish is to try parse with chosen parser and if it fails, drop one byte and try again with what is left. How should i approach that?
06:12:55 <impure_hate> anks: try first_parser <|> parser_matching_one_byte *> fallback_parser
06:13:10 <merijn> hmmm
06:13:30 <merijn> user error (The package 'posix-pty' requires Cabal library version -any && >=1.10 but no suitable version is installed.)
06:13:37 <merijn> That error makes no sense to me?
06:13:38 <anks> impure_hate: thanks 
06:13:40 <anks> :)
06:13:44 <merijn> Why wouldn't it be able to find Cabal?
06:13:48 <impure_hate> what is the idiom to apply multiple functions to single input producing multiple outputs?
06:14:00 <quicksilver> impure_hate: sequence
06:14:13 <impure_hate> ah
06:14:17 <quicksilver> > sequence [(*2),(+4),(*3)] 5
06:14:19 <lambdabot>  [10,9,15]
06:14:25 <impure_hate> thanks!
06:14:28 <quicksilver> np
06:14:41 <dcoutts> merijn: and do you have the Cabal lib installed?
06:14:50 <KaneTW> alternatively, 
06:15:02 <merijn> dcoutts: I'm doing "cabal install --dependencies-only" should it just install anything missing?
06:15:02 <KaneTW> > map ($5) [(*2),(+4),(*3)]
06:15:03 <bergey`> merijn: When I've gotten that error, it usually means there was some other error earlier.  For example, trying to reinstall ghc to match a different version of transformers.
06:15:05 <lambdabot>  [10,9,15]
06:15:35 <impure_hate> KaneTW: interesting :) sequence looks a bit more readable though
06:15:35 <merijn> I just added one package to the cabal file in my sandbox and that new package is unable to install due to Cabal being missing, supposedly...
06:15:40 <KaneTW> yes
06:15:43 <dcoutts> merijn: current cabal-install doesn't deal with the implicit dependencies of Setup.hs scripts. (Though the new dev branch does)
06:15:45 <KaneTW> i prefer sequence too
06:16:06 <merijn> dcoutts: So the problem is the sandbox not having Cabal installed because nothing needs it?
06:16:11 <dcoutts> merijn: but it sounds like it's missing from your user env too. It doesn't just look in the sandbox.
06:17:00 <merijn> dcoutts: I'm not sure why my user-env wouldn't have cabal? I'm having no issue installing things outside of the sandbox...
06:17:44 <dcoutts> merijn: ok, but does it actually have the Cabal lib? (and usable, according to ghc-pkg list, ie not with broken deps)
06:18:23 <merijn> Apparently not...odd
06:18:56 <dcoutts> merijn: if you're using a slightly older version of cabal-install, then it needs external Cabal lib when doing parallel builds, not just for custom Setup.hs.
06:19:44 <dcoutts> merijn: so quick workaround would be -j1. But if the package uses a custom Setup.hs then it does need Cabal lib installed.
06:19:45 <anks> impure_hate: what about this one: it tries to parse skipping one byte on failure til it suceeds 
06:20:14 <dcoutts> merijn: and yes, this will be fixed to install setup deps automatically (this works now in the nix-local-build branch)
06:21:22 <merijn> -j1 worked, although I'm still confused why this didn't work but other installs did...
06:22:46 <impure_hate> anks: hmm. not sure about that one
06:23:02 <quicksilver> anks: just the same thing as before but recursive
06:23:12 <impure_hate> ^^ :)
06:23:24 <anks> nice synchro
06:23:54 <quicksilver> anks: real_parser = try (first_parse) <|> match_one_token *> real_parser
06:24:15 <anks> yup, i got it once you said recursive, thanks!
06:26:21 <Guest36189> does this function f :: (a -> a) -> a  takes a pair of arguments?
06:26:29 <Guest36189> take*
06:26:42 <quicksilver> no, just one
06:26:57 <quicksilver> argument has type (a -> a); return is type a
06:28:06 <Guest36189> quicksilver: so that means it takes a function as its argument or takes two arguments one at a time?
06:28:18 <quicksilver> it takes a function as its argument
06:29:22 <Guest36189> quicksilver: thank you
06:29:38 <quicksilver> an example of this general scheme would be "applyTwiceToZero :: (Int -> Int) -> Int; applyTwiceToZero f = f (f 0)
06:29:58 <quicksilver> that takes one parameter `f`, which is a function, and applies `f` to zero and then, again, to the result.
06:30:17 <quchen> Guest36189: That's the type of `fix`, also known as the Y combinator. It's not exactly a beginner-friendly function to use.
06:30:27 <quchen> But you can still talk about what the type means, of course.
06:31:07 <quicksilver> quchen: that's why I instantiated to some specifc `a` where I could make a more beginner-friendly example of the concept :)
06:31:37 <quchen> quicksilver: Sure, I just wanted to make sure he didn't get caught up in trying to understand what it's for and why it's useful and how it works at this sage. :-)
06:34:49 <lpaste> merijn pasted “How to unsuck?” at http://lpaste.net/144578
06:35:01 <aweinstock> > fix (1:)
06:35:01 <merijn> Any suggestions on how to refactor that into something less ugly?
06:35:02 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
06:38:24 <Profpatsch> merijn: flip (maybe (outputStr $ prettyString_ val)) (liftIO $ createPty stdInput) $ <just-part>
06:38:27 <Profpatsch> :)
06:38:29 <Ankhers> merijn: do you know about the `maybe' function? 
06:38:35 <Ankhers> Or what Profpatsch said.
06:38:44 <Profpatsch> But that’s very ugly, too.
06:38:45 <merijn> ...
06:38:58 <merijn> I was about to say, are you going to suggest that is *less* ugly?
06:39:08 <merijn> I tried maybe, but it doesn't work out in a nice way either
06:39:09 <Ankhers> I was just thinking that the maybe function would prevent the case.
06:39:26 <merijn> I tried working MaybeT into it, but that just made things worse too
06:39:38 <Profpatsch> merijn: You could try combining it with (.)
06:41:57 <impure_hate> what's easier to work with when developing DSL with parsec - ADT or records? 
06:42:07 <quicksilver> merijn: you could pre-lift createPty and ptyDimensions, if you use them often in MonadIO
06:42:22 <merijn> quicksilver: This is the only place I use them
06:42:29 <impure_hate> what do people prefer in such case. when there's need for a bit of transformations and pretty printing
06:43:01 <quicksilver> merijn: I would, probably prefer ">>= maybe"
06:43:07 <quicksilver> because it avoids having the name 'pty'
06:43:11 <quicksilver> which doesn't really have a good name
06:43:24 <quicksilver> but I don't have any other good suggestions
06:43:28 <merijn> quicksilver: Me too, but that didn't quite work out with the argument types :\
06:44:07 <quicksilver> :t maybe
06:44:09 <lambdabot> b -> (a -> b) -> Maybe a -> b
06:44:59 <Profpatsch> merijn: why is ptyDimensions in Io?
06:45:17 <merijn> Profpatsch: C FFI call + pointer mutation
06:45:21 <Profpatsch> The name sounds like it could be a pure function to me.
06:45:42 <quicksilver> liftIO (createPty stdInput) >>= maybe (outputStr $ prettyString_ val) (\pty' -> do x <- fst . liftIO . ptyDimensons $ pty'; outputStr $ prettyString x val)
06:45:51 <merijn> Profpatsch: It really can't, because the dimensions of a pty can change so you can't cache them inside the Pty datatype
06:45:57 <quicksilver> should type check unless I read it wrong
06:46:24 <merijn> quicksilver: Sure, but that's pretty ugly too :p
06:46:42 <quicksilver> I'd put it on four lines
06:46:46 <Profpatsch> It’s the same thing, but implicit and on one line. :)
06:46:50 <quicksilver> and I think it's *slightly* better than what you had.
06:46:59 <quicksilver> mostly because of not having to name 'pty'
06:47:08 <quicksilver> but I agree it is not substantially different
06:47:20 <Profpatsch> quicksilver: Well, you do have the name pty' …
06:47:28 <smaudet> What am I doing wrong? http://pastebin.com/nxyUwDRb
06:47:30 <quicksilver> yes but in the original he had pty and pty'
06:47:35 <quicksilver> with different types, no less
06:47:36 <Profpatsch> Oh, right.
06:47:45 <smaudet> I'm trying to scope the first where block for the second...
06:48:13 <Profpatsch> smaudet: There is only one where block.
06:48:25 <quicksilver> you can nest where blocks if you like
06:48:30 <quicksilver> but that would be the wrong thing to do here
06:48:43 <smaudet> quicksilver: what would be preferable then?
06:48:45 <quicksilver> if you nested that where block it would only be scoped to 'r33'
06:48:54 <quicksilver> just inline the second where block with the first
06:49:07 <quicksilver> so it's one big where block with 19 definitions
06:49:37 <quicksilver> btw, don't write f2gf(xf), write f2gf xf
06:49:38 <quicksilver> :)
06:49:46 <quicksilver> (but that doesn't matter)
06:50:08 <quicksilver> if you introduce a where block with an explicit {
06:50:14 <quicksilver> are you not obliged to use explicit ; as well?
06:50:21 * quicksilver never uses {} so he's not sure
06:50:42 <Profpatsch> Looks like smaudet is coming from parensworld :)
06:51:09 <smaudet> Profpatsch: well the indentation rules are confusing
06:51:12 <Profpatsch> Where people still think more parens makes a better program. :)
06:51:17 <Profpatsch> smaudet: I agree.
06:51:19 <smaudet> parents is unambiguous
06:51:23 <smaudet> parens*
06:51:33 <quicksilver> indentation is also unambiguous :)
06:51:44 <Profpatsch> smaudet: But it’s basically always: If it’s a new block, ident.
06:51:48 <smaudet> quicksilver: not in this case it wasn't, not when I'm trying to figure out why my where block isn't working
06:51:53 <quicksilver> so, I think your error comes from not putting a ; after the r00 = foo ;
06:52:02 <arw> quicksilver: only of you don't use copy&paste, put it on a website or similar
06:52:06 * hackagebot network-transport-inmemory 0.5.1 - In-memory instantiation of Network.Transport  https://hackage.haskell.org/package/network-transport-inmemory-0.5.1 (AlexanderVershilov)
06:52:07 <quicksilver> indentation is never ambiguous in any way
06:52:15 <quicksilver> humans may find it hard to understand
06:52:19 <quicksilver> but that's not "ambiguous"
06:52:20 <arw> quicksilver: also, tabwidth.
06:52:21 <quicksilver> that's just humans.
06:52:34 <Profpatsch> quicksilver: He did say confusing, not ambiguous.
06:52:54 <Profpatsch> But {} is just a bad indentation anyway.
06:53:26 <Profpatsch> Because that is inherently a lot harder to understand by humans I’d argue.
06:53:56 <quicksilver> anyway the point isn't to argue about indentation or braces, the point is to get smaudet's code working
06:54:09 <smaudet> quicksilver: no, its more than just humans, when you throw in bad plugins that think they know how to indent your code (but can't) and lack of knowledge of how the language treats indentation, its completely unreadable.
06:54:13 <zzing> > foldl' (\a b -> a * 10 + b) 0 [1 1 0]    -- why does this fail?
06:54:15 <lambdabot>      Could not deduce (Num a0)
06:54:15 <lambdabot>      from the context (Num b, Num a, Num a2, Num (a -> a2 -> b))
06:54:15 <lambdabot>        bound by the inferred type for ‘e_1100110’:
06:54:32 <Profpatsch> But we’ve been trained with the crappy way of {}, which were originally only introduced because of mechanical necessity.
06:54:33 <smaudet> indentation is nice if you have pep8 or something
06:54:34 <smaudet> otherwise its horrible
06:54:35 <quicksilver> zzing: because the syntax for lists involves ,
06:54:49 <zzing> That would do it.
06:54:52 <quicksilver> > foldl' (\a b -> a * 10 + b) 0 [1,1,0]
06:54:54 <lambdabot>  110
06:55:15 <smaudet> Profpatsch: I can use indentation just fine, suffice it to say it was getting in my way to solving my real problem
06:55:31 <zzing> Thank you. Is this method as an alternative to read (read "110" :: Int)      a decent one?
06:55:32 <Profpatsch> smaudet: I’ve seen haskell with 2–4 spaces, it’s never been more horrible than C-code.
06:55:38 <quicksilver> smaudet: yes well broken software can indeed break lots of things :)
06:55:54 <smaudet> hence the superiority of unambiguous {}
06:56:08 <Profpatsch> Or any imperative code for that matter.
06:56:22 <Profpatsch> smaudet: As quicksilver said, indentation is unambiguous.
06:56:26 <quicksilver> your argument makes some sense, smaudet, just don't use the word 'ambiguous'
06:56:33 <quicksilver> there is nothing ambiguous about indentation at all
06:56:36 <Profpatsch> If it was not, the compiler wouldn’t notice.
06:56:41 <quicksilver> but it may confuse people and, indeed, buggy software
06:57:08 <smaudet> quicksilver: then say 'unambigous to the haskell compiler'
06:57:35 <vincenz> QQ: I really liked the article by Andres Loh on mini-servant. I do have a high-level design question. Why do most people nowadays model their domain as separate types (e.g. data Get (a:: *)) instead of separate constructors in a type (data Request a = Get a | ... )
06:57:46 <Profpatsch> It is also not ambiguous to people, at most confusing.
06:57:47 <quicksilver> I'm not sure htis conversation is the best way for either of us to spend our time.
06:57:49 <Profpatsch> :)
06:58:19 <Profpatsch> smaudet: Don’t worry, you’ll be indoctrined sooner or later.
06:58:34 <smaudet> Profpatsch: like I said, I can use indentation just fine
06:58:35 <Profpatsch> indoctrinized?
06:58:45 <quicksilver> vincenz: so you can give more precise types to functions, perhaps?
06:58:46 <Profpatsch> sorry for derailing.
06:58:49 <smaudet> quit trying to preach
06:58:53 <smaudet> its failing, pretty hard
06:58:54 <vincenz> quicksilver: how do you then combine those ?
07:00:15 <zzing> vincenz, People use separate types for that?
07:00:18 <quicksilver> vincenz: with data Request a = Get (Get a) | ... ;)
07:00:51 <vincenz> quicksilver: good point
07:01:06 <magneticduck> uh seems like people are discussing schools of thought in indentation
07:01:09 <vincenz> quicksilver: I did see this as a typical thing lately. I remember 4-5 years ago, people modeled at the data-constructor level, now they model at the type-constructor level
07:01:09 <bernalex> smaudet: one thing ydiw is using pastebin. ffr, please use lpaste.net as per /topic. :)
07:01:27 <smaudet> ...
07:01:34 <quicksilver> vincenz: still that was only a suggestion. I don't *actually* know the answer.
07:01:40 <smaudet> you guys are looking pretty bad right now
07:01:43 <quicksilver> smaudet: anyhow, did that fix your issue? was it the ;?
07:01:44 <vincenz> quicksilver: it makes sense
07:01:45 <bernalex> pastebin doesn't even let me access the file because they are afraid of Tor or something.
07:01:50 <smaudet> quicksilver: not sure
07:02:43 <smaudet> quicksilver: yeah no its still barfing
07:03:00 <smaudet> like I said, all I've gotten is uppety remarks about how I'm sharing code and indenting it, no help
07:03:11 <vincenz> What is the difference between 'k' and '*' in data (a::k) :> (b::*)
07:03:13 <smaudet> uppety and IMO stupid remarks*
07:03:15 <dukerutledge> Has anyone else noticed that `-main-is` is busted for `runhaskell` and `runghc`?
07:03:15 <magneticduck> any support for my use of 7 six-per-em unicode spaces per indentation level?
07:03:18 <quicksilver> smaudet: that's not true. My immediate responses were two actual suggestions.
07:03:23 <magneticduck> I think it's a good compromise
07:03:29 <smaudet> quicksilver: ok, you're better than some others
07:03:31 <vincenz> magneticduck: cool name
07:03:33 <quicksilver> smaudet: only then did I allow myself to get diverted into a discussion about indentation.
07:03:41 <bernalex> smaudet: we already have /topic about what pastebin service to use. you chose not to use it nonetheless. that's OK, but I cannot even access the file on that service. so I mentioned the one we prefer in this channel.
07:03:47 <quicksilver> smaudet: you can paste the code again and the new error?
07:03:52 <smaudet> bernalex: yeah great, what's done is done
07:03:55 <smaudet> quiet
07:04:14 <bernalex> smaudet: there are people here trying to help you. if you behave in an antagonistic manner, people will not want to help you. which is too bad, because the people in here genuinely care about newcomers, and very much want to help them.
07:04:35 <smaudet> bernalex: if they behave in an antagonistic manner they should not be surprised when I return in kind
07:04:42 <smaudet> quicksilver: same error...
07:04:47 <smaudet> trying various semicolons
07:04:49 <bernalex> smaudet: could you try pasting the new code (with your amendments), with the error?
07:04:53 <merijn> vincenz: k can be any kind
07:04:59 <vincenz> merijn: and *?
07:05:07 <merijn> vincenz: * is a specific kind
07:05:13 <bernalex> smaudet: preferably the code exactly as you are trying to run it, so that we can see what line the compiler is complaining about.
07:05:15 <vincenz> merijn: what kidn of specific kind?
07:05:25 <merijn> vincenz: Specifically, * is the kind of types that can contain values
07:05:43 <merijn> i.e. "Int :: *", "Maybe Bool :: *", but "Maybe :: * -> *"
07:05:43 <vincenz> merijn: so data F a= .... 'F' can fit into a 'k' but only 'F Char' can fit into a '*'?
07:05:46 <bernalex> smaudet: fwiw, saying "please use lpaste" is not entirely antagonistic. if you perceived it that way, I apologise for the miscommunication.
07:05:51 <merijn> vincenz: Right
07:05:54 <vincenz> merijn: ty
07:05:59 <vincenz> merijn: its' weird that * is the more specific one :)
07:06:03 <vincenz> syntactically
07:06:37 <vincenz> merijn: is there any value in specifying such? Why not simply say 'data a :> b'
07:06:58 <quicksilver> smaudet: I can't compile your code, of course, because it relies on stuff I don't have locally. But I made a simple test and to me it seems your error comes from missing out the ;
07:08:20 <lpaste> quicksilver pasted “parse error on = example” at http://lpaste.net/144583
07:08:31 <quicksilver> smaudet: an example of what I meant
07:08:40 <merijn> vincenz: Well, normally GHC infers the correct kind for a parameter (i.e. "data Foo f = Foo (f Int)" infers "f :: * -> *"), but if the parameter is not in the right hand side GHC can't infer the kind and defaults to *
07:09:02 <merijn> vincenz: So if you want to allow different/multiple kinds you have to explicitly annotate so to tell GHC that "this is fine"
07:09:32 <vincenz> merijn: secondly, why do such typical API-designs never have data-constructors? 
07:09:55 <merijn> vincenz: What do you mean?
07:10:25 <vincenz> merijn: for context: http://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/
07:10:40 <vincenz> merijn: 'data Get (a :: *) '
07:10:48 <vincenz> I'm taking this article, but I've seen that pattern in more places
07:11:41 <quicksilver> because it is only used on the type level
07:11:58 <quicksilver> he's defining the primitives of a language he will use to build type-level terms
07:12:04 <merijn> vincenz: Yeah, they're basically programming on the type level :)
07:12:12 <quicksilver> it has no runtime representation
07:12:16 <vincenz> quicksilver: but in the end your program has to deal with values, no?
07:12:20 <quicksilver> yes indeed
07:12:25 <merijn> So by not having a value constructor you avoid accidentally creating values
07:12:27 <quicksilver> these things are only used to program clever type constraints
07:12:33 <quicksilver> and things like that
07:12:52 <merijn> This is a rather complex example to start your exploration of this kinda stuff with, though
07:13:02 <smaudet> quicksilver: thanks, seems like I had to add semicolons to all lines - next question, why? Is it because I added {}?
07:13:11 <quicksilver> smaudet: yes.
07:13:22 <smaudet> *sigh*
07:13:25 <quicksilver> the choice is (1) use indentation (2) use {} and ;
07:13:47 <quicksilver> there isn't a third choice (perhaps you could imagine (3) use {} and newlines, but that isn't one of the options)
07:13:53 <vincenz> quicksilver: pointless :)
07:14:01 <ggVGc> does anyone know a vim/emacs plugin or other tool that would let me generate a case statement given an ADT name?
07:14:02 <quicksilver> vincenz: in the most precise sense, yes
07:14:05 <statusfailed> In this file: http://hackage.haskell.org/package/warp-3.1.8/docs/src/Network-Wai-Handler-Warp-Settings.html#defaultSettings
07:14:10 <vincenz> quicksilver: as third choice, I mean :D
07:14:13 <statusfailed> what does "settingsHost = "*4"" mean ?
07:14:44 <statusfailed> I would have thought that would be something like "localhost" or "0.0.0.0"
07:15:09 <quicksilver> is that an encoding for "IPv4 wildcard" ? maybe?
07:15:11 <quicksilver> I'm only guessing.
07:15:25 <vincenz> merijn: one thing is that kind-expressions are rather limiting. You can't easily express stuff like: "Only capture or string to the left of :>"
07:15:34 <statusfailed> quicksilver: Ahh, found it in the docs- it means '*4 means HostIPv4'
07:15:41 <statusfailed> does that mean anything to you? haha
07:15:45 <quicksilver> some systems use "*" for wildcard binds, e.g.
07:15:48 <vincenz> merijn: or would one do sometihng like data (Allowed (a::*) => a) ?
07:15:51 <quicksilver> tcp4       0      0  *.3000                 *.*                    LISTEN
07:15:57 <vincenz> merijn: or would one do sometihng like data (Allowed (a::*) => a) :> (b::k)
07:16:05 <quicksilver> meaning, I have a server bound to listen on port 3000 any local IP
07:16:12 <merijn> vincenz: I'll show you some standalone examples of DataKinds abuse like this
07:16:17 <vincenz> merijn: ty
07:16:39 <merijn> The most straightforward one is a heterogeneous list: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
07:16:45 <statusfailed> quicksilver: Hmm OK
07:16:48 <quicksilver> in the C tradition it's called INADDR_ANY
07:17:05 <merijn> A bit further we can do things like "indexing lists that must be less than 3 long": https://gist.github.com/merijn/39dc86e345e87276c523
07:17:32 <vincenz> merijn: [*] seems like new syntax
07:17:36 <merijn> vincenz: And if you wanna go crazy "disallow a specific type for a type variable": https://gist.github.com/merijn/6130082
07:17:45 <ggVGc> or maybe a better question, what are the best/most popular tools helper tools for writing haskell, providing intelligent snippets etc. Are there any such tools?
07:17:58 <merijn> vincenz: That's DataKinds, DataKinds creates a type level version of every value constructor
07:18:13 <merijn> vincenz: So [*] is a type level list containing types of kind *
07:18:20 <merijn> i.e. "[Bool, Char, Int]"
07:18:22 <quicksilver> there are a few such tools, ggVGc, and I've never had the impression that any of them is that popular.
07:18:26 <vincenz> merijn: yep, is that a recent thing?
07:18:34 <merijn> vincenz: 7.6 or 7.8?
07:18:37 <ggVGc> quicksilver: could you point me towards any of them?
07:18:39 <quchen> '[*], no?
07:18:49 <merijn> quchen: ' is only needed when ambiguous
07:19:08 <merijn> i.e. '[Int] (because [Int] could be either * or [*])
07:19:16 <quicksilver> ggVGc: https://github.com/polypus74/HSnippets
07:19:24 <ggVGc> thanks
07:19:45 <vincenz> merijn: I don't see why you need DataKinds, according to the article that's only for type-level strings
07:19:50 <vincenz> which you don't seem to use
07:19:54 <quicksilver> ggVGc: also browse https://wiki.haskell.org/IDEs
07:20:16 <merijn> vincenz: Not just that, DataKinds creates a type level version of EVERY constructor
07:20:23 <vincenz> oih
07:20:25 <vincenz> oic*
07:20:29 <shapr> smaudet: be nice
07:20:30 <merijn> vincenz: Note line 15
07:20:38 <Profpatsch> smaudet: I’m sorry if it sounded like preaching. The comments about indentation where meant to be made with a big irony sign.
07:20:40 <merijn> vincenz: Where I use ':' (list constructor) on types
07:20:52 <vincenz> merijn: yep :)
07:20:53 <Profpatsch> Because syntax really is the thing that matters least in the end.
07:20:55 <vincenz> merijn: that's cray :)
07:21:05 <shapr> vincenz: salut!
07:21:08 <merijn> vincenz: or line 14 where I use the empty list constructor '[]
07:21:13 <statusfailed> woahh, you can have one program binding to 127.0.0.1:8000 and another to [::1]:8000
07:21:16 <statusfailed> crazy town!
07:21:22 <vincenz> merijn: why the need for ' in '[]?
07:21:22 <kosmikus> vincenz: haven't followed the entire discussion. but the actual answer to your original question is that separate datatypes are "open", whereas datakinds are closed.
07:21:24 <vincenz> shapr: salut
07:21:30 <merijn> vincenz: Because [] is ambiguous
07:21:34 <merijn> :k []
07:21:35 <lambdabot> * -> *
07:21:38 <merijn> :k '[]
07:21:39 <lambdabot> [k]
07:21:44 <statusfailed> quicksilver: thanks btw, solved the mystery :-)
07:22:04 <vincenz> kosmikus: when you say datakinds, you mean data-constructors?
07:22:06 <statusfailed> curl localhost != curl 127.0.0.1 because there was already something running on the ipv4 addr
07:22:10 <merijn> [] is either the list type constructor (as in "[] Int") or the empty type level list
07:22:16 <vincenz> merijn: makes sense
07:22:27 <kosmikus> vincenz: promoted data constructors, yes
07:22:51 <vincenz> kosmikus: oh I wasn't even thinking about that :) But that's interesting
07:23:02 <kosmikus> vincenz: for servant specifically, one design goal is that the language should be open for external extension
07:23:28 <kosmikus> vincenz: the trade-off is being discussed in the paper, but not in the blog post
07:23:34 <vincenz> kosmikus: I was talking more simply at the value-level using data-constructors, not using datakins, cause then I didn't know about them yet, merijn just taught me
07:24:25 <vincenz> :k Fix
07:24:26 <lambdabot> Not in scope: type constructor or class ‘Fix’
07:24:41 <kosmikus> vincenz: oh, so your question was more about value-level vs type-level?
07:24:45 <vincenz> kosmikus: right
07:25:19 <vincenz> kosmikus: compare 6 year ago libraries with today, people are doing much more at the type-level from my limited point-of-view.
07:25:22 <kosmikus> vincenz: oh, well, then the answer in the case of servant is that we want the API to be a type, so that conformance with the API can be statically checked.
07:25:27 <vincenz> kosmikus: to the point there's not even values attached to the types
07:26:05 <kosmikus> vincenz: true. there's much more type-level stuff these days. but that's also because GHC allows more than it used to.
07:26:29 <smaudet> quicksilver: I just assumed it would work similar to python, i.e. indentation with optional ';'
07:26:37 <shapr> I want first class types.
07:26:45 <kosmikus> shapr: use Idris or Agda :)
07:26:53 <shapr> good suggestion :-)
07:27:14 <vincenz> is 7.6.3 way behind? 
07:27:23 <quchen> Yes.
07:28:00 <quchen> vincenz: You can see the release dates here: https://www.haskell.org/ghc/
07:28:29 <Guest36189> why is the type of this definition --- e9 [x, y] = (x, True) --- [t] -> (t, Bool) instead of [a,b] -> (a, Bool)
07:28:33 <Guest36189> ?
07:28:42 <vincenz> quchen: I use haskell-platform and it seems to be stuck on 7.6.3 for me
07:28:50 <quicksilver> smaudet: well there is that too. If you don't use {} you can still use an optional semicolon
07:28:54 <quchen> vincenz: From your repo's package manager?
07:28:59 <vincenz> quchen: yes
07:29:00 <quchen> distro's, I mean
07:29:01 <smaudet> quicksilver: I see
07:29:09 <quicksilver> smaudet: but if you *do* use {} then you are saying 'I want explicit ;'
07:29:11 <shapr> Guest36189: list items all have the same type
07:29:19 <umib0zu> any haskeller’s heading to the Boston meetup tonight?
07:29:24 <smaudet> quicksilver: what is the reasoning behind that, I wonder?
07:29:39 <Guest36189> shapr: damn, thx
07:29:39 <smaudet> ; or \n should be able to parse distinct statements....
07:29:41 <quicksilver> smaudet: "do foo ; bar" is fine, though, and lets oyu put two things on one line if you ever wanted to
07:29:47 <quchen> Those are usually pretty outdated, yes. I mean 7.6 is usable, but 7.8 got some really nice usability features (namely typed holes) which are helpful at every stage of your Haskell journey.
07:29:50 <quicksilver> or let x=1;y=2 in ...
07:29:53 <quchen> vincenz: ^^
07:30:11 <quchen> Current release is 7.10, with 8.0 approaching earlier next year.
07:30:27 <quicksilver> smaudet: I think the reasoning is to allow people to have some way to access a mode where whitespace is not significant
07:30:36 <quicksilver> smaudet: so you can break long statements over multiple lines
07:30:46 <smaudet> Profpatsch: apology accepted, although it was mostly the 'smaudet: Don’t worry, you’ll be indoctrined sooner or later.' that really got you off on the wrong foot
07:30:57 <quchen> vincenz: You can download a current Haskell Platform release here: https://www.haskell.org/platform/#linux-generic
07:31:03 <quicksilver> IIRC this is a problem in python - in some cases you can't do a continuation line because the parser assumes you must have finished
07:31:05 <vincenz> quchen: ty
07:31:13 <quicksilver> I could have remember that wrong though, I've never written more than a few lines python.
07:31:13 <quchen> vincenz: Or you could just install Cabal and GHC yourself, and ignore the Platform. That's what I'm doing.
07:31:33 <vincenz> quchen: I always screw that up
07:31:36 <quicksilver> however - I dont' actually know the reasoning. I always use layout myself.
07:31:41 <vincenz> quchen: specifically the cabal part
07:31:41 <kosmikus> quchen, vincenz: typed holes are indeed amazing. they're the best new Haskell/GHC feature in years :)
07:32:23 <quchen> kosmikus: The next really cool thing would be placeholders in types, like Agda's "_"
07:33:03 <quchen> We can abuse holes in types by switching off the warnings to get similar behaviour, but that's not exactly clean. :-|
07:33:07 <kosmikus> quchen: you mean PartialTypeSignatures ?
07:33:50 <quchen> Yes, but with syntax that reflects their difference compared to holes
07:33:59 <quchen> Agda has ? and _, Haskell has _ and _
07:34:15 <quicksilver> ^_^
07:34:18 <quchen> One means "I'm lazy you go infer that", the other one is "help me fill this"
07:34:26 <cheater> i guess it's like a <- foo and not using a vs _ <- foo
07:34:46 <lpaste> hwanzike pasted “explode list” at http://lpaste.net/144586
07:34:47 <quchen> Was it augur who gave up lobbying for the syntax change? I don't remember.
07:35:21 <quchen> Well, who was lobbying for the syntax change, which then did not happen, unfortunately. So then he gave up.
07:35:29 <kosmikus> quchen: right. I haven't looked much at the actual implementation of partial type signatures yet. But I agree there's an important semantic difference between _ and ?.
07:35:33 <vincenz> quchen: seems typed holes don't support inference? So you can't do more typeful undefined programming?
07:35:33 <opqdonut> quchen: which change?
07:36:16 <quchen> opqdonut: giving holes different syntax than partial types
07:36:21 <opqdonut> right
07:36:38 <pavonia> hwanzike: Use span/break for splitting the string
07:38:01 <hwanzike> pavonia: whats the difference between those?
07:38:24 <quchen> kosmikus: And in particular, I'd like to have holes in types so I can gradually grow my type. Using "_" for both makes one way of using a "hole" impossible.
07:38:33 <vincenz> kosmikus: so with this servant api. Is the itnention that there's some sort of 'class Serializable a' similar to 'Show a' to parse/unparse the response-types/captures in the url?
07:38:50 <vincenz> kosmikus: or is that orthogonal?
07:39:39 <kosmikus> quchen: well, I'd say _ now allows you to have holes in types. it doesn't really allow you to have partial type signatures, because you have to manually disable warnings.
07:39:48 <kosmikus> quchen: so incremental development is fine :)
07:39:49 <pavonia> hwanzike: One splits before and one after the first occurence
07:39:58 <ocramz> hi all
07:40:14 <phadej> poucet: yes there are, `ToText` `FromText` in current servant (AFAIK the name will change to be more Http oriented)
07:40:31 <quchen> kosmikus: Did you see the talk about extensible effects in London? That one screamed "give me partial type sigs". I'd like to also have that capability.
07:41:02 <quchen> It would also help presentation of complicated things a lot, so there's not only development but also teaching.
07:41:03 <kosmikus> poucet: right, for Captures, there's FromText / ToText, for request bodies and responses, there are content types.
07:41:22 <kosmikus> poucet: content types are specified using a type-level list and go with their own class.
07:41:23 <pavonia> hwanzike: No, span splits afer the *last* occurence
07:41:30 <phadej> quchen: I'm afraid how much GHC could actaully infer in higher-order types
07:41:55 <kosmikus> quchen: I certainly agree that it would be good to have partial type signatures that you can use in shipped code.
07:42:00 <lpaste> hwanzike annotated “explode list” with “explode list (annotation)” at http://lpaste.net/144586#a144588
07:42:11 <kosmikus> quchen: for slides, the current solution is good enough, I'd say. you don't see the warnings there :)
07:43:12 <kosmikus> poucet: actually, I notice that the blog post incorrectly says that Servant uses content types for captures.
07:43:22 <kosmikus> poucet: I'll fix that.
07:43:47 <mniip> should 'explode []' really be []
07:43:48 <phadej> quchen: also, if types get scared you should abstract, to make them prettier. That's what we do when we get scary terms.
07:43:53 <mniip> imo it should be [[]]
07:44:20 <ocramz> I'd like to generalize Managed (`newtype Managed a = Managed { runMng :: forall r . (a -> IO r) -> IO r}`) to settings where the callback return type might be different from the `run` return type
07:44:28 <quchen> phadej: Abstraction is what gets you these types.
07:44:51 <hwanzike> pavonia: how can i go around the empty list thing there when using break?
07:45:27 <pavonia> Use a case expression
07:45:34 <hwanzike> i wanted to avoid that :(
07:45:50 <ocramz> e.g. `newtype Managed2 a r1 r2 = Mg2 { runMng2 :: forall r1 r2 . (a -> IO r1) -> IO r2}`  : some callbacks can return `(a , CInt)`, whereas others only a CInt, and the overall return type could be `IO ()`
07:46:29 <lpaste> mniip annotated “explode list” with “explode list (annotation) (annotation)” at http://lpaste.net/144586#a144589
07:50:51 <augur> quchen: yes
07:51:29 <augur> quchen: what raises this issue again?
07:51:54 <quchen> augur: Holes vs partial type sigs?
07:52:00 <augur> yea
07:53:25 <quchen> augur: I'd like to A) be able to have the compiler help me fill in holes, and B) leave away complicated or irrelevant stuff in type signatures and have the compiler just infer what I left out.
07:53:41 <augur> :)
07:53:42 <quchen> Or am I misunderstanding the question?
07:53:57 <quchen> I'm confused.
07:54:04 <augur> so i take it youre trying to do this but GHC's conflation is causing problems
07:54:34 <quchen> I'm not trying to do anything, I just saw people talking about holes in types and my blood pressure raised ;-)
07:59:40 <poucet> typed holes are for debugging purposeS? Not for more specific undefined-style-programming?
08:01:02 <merijn> Typed holes are great for undefined style programming
08:01:14 <poucet> but accoridng to docs they don't unify same-named holes?
08:01:24 <merijn> poucet: So?
08:01:52 <poucet> merijn: so if I'm doing undefined-style prorgamming and I know this piece over here will have the same type as that piece over there, but I don't have the implementation for it yet, how would I go about that? Regular variables?
08:02:24 <nitrix> poucet: _ doesn't replace the type system.
08:02:39 <merijn> poucet: "foo :: Foo; foo = _"?
08:07:31 <quicksilver> yes but there is no way of introducing a top-scope type name
08:07:48 <quicksilver> this is a natural thing to want after you've started wanting holes
08:07:54 <quicksilver> you go from Foo ? -> Bar
08:08:05 <quicksilver> to Foo something_I_will_use_again -> Bar
08:08:14 <quicksilver> so you can define elsewhere in the same scope
08:08:23 <quicksilver> [something_I_will_use_again]
08:08:36 <quicksilver> you're saying "GHC please infer this for me but these two bits are the same"
08:08:51 <quicksilver> you can sort-of do this with ScopeTypeVariables in local scopes.
08:09:20 <mniip> eh
08:09:30 <mniip> why do scoped type variables even exist
08:09:39 <mniip> you can always just drag the type variables around by yourself
08:09:53 <poucet> mniip: not in where clauses
08:10:02 <mniip> elaborate
08:10:09 <poucet> foo :: a -> b -> c
08:10:10 <poucet> foo = ...
08:10:15 <poucet> where x :: b -> b
08:10:20 <poucet> those b's are not the same unfortunately
08:10:31 <mniip> yes but
08:10:32 <nawal_> Hi, How do I do function polymorphism in Haskell? http://pastebin.com/FQgJbiXN
08:10:55 <quicksilver> nawal_: we call that 'overloading'
08:10:55 <mniip> \a b -> x `asTypeOf` ((undefined :: b -> (b -> b)) b)
08:11:03 <mniip> now x has the same type as b
08:11:05 <mniip> or rather
08:11:06 <nawal_> It claims there are multiple declarations - I was hoping it would simply tell from the type signatures
08:11:15 <mniip> has the same b in its type
08:11:20 <quicksilver> mniip: yup, everything you can do with ScopedTypeVariables you can do with asTypeOf and similar tricks.
08:11:26 <hodapp> :t asTypeOf
08:11:28 <lambdabot> a -> a -> a
08:11:29 <quicksilver> it's still convenient though
08:11:35 <nawal_> quicksilver, Aha
08:11:35 <glguy> except write the types of things on declarations
08:11:40 <poucet> mniip: interesting though quite verbose :)
08:11:47 <mniip> poucet, I used this trick recently
08:11:58 <quicksilver> glguy: sorry; you can always enforce the constraint you want
08:12:05 <quicksilver> glguy: but you dont' get the documentation side, no.
08:12:11 <elfeck> hi, is there a way to get the currentTime in the blaze-html monad?
08:12:18 <quicksilver> nawal_: you have to make a typeclass to overload things.
08:12:25 <mniip> poucet, see https://hackage.haskell.org/package/finite-typelits-0.1.0.0/docs/src/Data-Finite.html#packFinite
08:12:25 <stepcut> I have an assoc list [(String, String)] that I am using to lookup values. There are only 5 entries in the list, and will probably never have more than 6 or 7. Obviously, a Map would have a slightly faster lookup time.. but there is also the time required to build the Map. Though in my case the map will usually be a CAF. So perhaps I only pay that price once.
08:12:30 <elfeck> i.e. now <- getCurrentTime
08:13:12 <mniip> poucet, I'm using 'fromJust result' even though it could be a Nothing
08:13:18 <mniip> that's because I'm not actually using the value
08:13:23 <mniip> just dragging its type
08:14:05 <quchen> mniip: Proxy might be a cleaner way to do this rather than undefined values.
08:14:25 <mniip> quchen, a proxy-ific way is defined 5 lines below :P
08:14:43 <quchen> mniip: Woops. Didn't look at the link :-)
08:15:03 <hongminhee> hi #haskellers, i have a question
08:15:22 <hongminhee> is this channel good to ask haskell questions?
08:15:25 <mniip> there is also this
08:15:27 <mniip> https://github.com/mniip/finite-typelits/blob/master/src/Data/Finite.hs#L204-L210
08:15:39 <tdammers> hongminhee: yes. that's why it's called #haskell ;D
08:15:41 <frerich> hongminhee: Yes it is
08:15:42 <Zekka|Sigfig> hongminhee: It’s probably better than most other channels
08:15:44 <mniip> hongminhee, yes, what else would the purpose be
08:15:49 <Zekka|Sigfig> We’re very dedicated to the jazz works of Jeffrey Haskell here
08:16:04 <hongminhee> thank you guys
08:16:25 <elfeck> anyone can help me with this: is there a way to get the currentTime in the blaze-html monad?
08:16:38 <mniip> Zekka|Sigfig, oh, I had no idea who haskell is, I was here for the curry :)
08:16:44 <elfeck> something like liftIO but for html-monad thing
08:16:54 <hongminhee> i want to contrain string values to contain only allowed characters.  would it be possible using types?
08:17:03 <hodapp> Well, I find it very clever how the developers of Ivory both embedded a C function signature inside of a type, and also used typeclasses & fundeps to enforce basically a type-level mapping between C function signatures and corresponding Haskell function types
08:17:13 * hackagebot hfmt 0.0.1.0 - Haskell source code formatter  https://hackage.haskell.org/package/hfmt-0.0.1.0 (danielstiner)
08:17:19 <glguy> elfeck: Is the type you're asking about "MarkupM"?
08:17:21 <mniip> hongminhee, uh probably not
08:17:23 <hodapp> however long it took me to understand it since they didn't document it -_-
08:17:37 <Zekka|Sigfig> hongminhee: IMHO you have two good options
08:17:54 <elfeck> glguy: yes I suppose so
08:17:59 <Zekka|Sigfig> You could write a function that checks if the string matches and if so, gives you that string wrapped in a newtype
08:18:13 <Zekka|Sigfig> newtype LegitString = LegitString String
08:18:28 <mniip> that would be a smart constructor
08:18:33 <glguy> elfeck: No, that type woudln't support getting the current time
08:18:38 <elfeck> shit
08:18:43 <Zekka|Sigfig> legitString s = if somePred s then Just (LegitString s) else Nothing
08:18:50 <elfeck> so I have to dragg it 
08:18:51 <hongminhee> so LegitString constructor shouldn't be exported?
08:19:04 <mniip> hongminhee, yes
08:19:04 <tdammers> elfeck: the problem with this is that MarkupM isn't a monad transformer, and doesn't implement MonadIO
08:19:06 <Zekka|Sigfig> You could also use a type other than Char to represent characters in the string, or a smart constructor for your characters
08:19:11 <Zekka|Sigfig> hongminhee: Yeah, that’s the idea
08:19:17 <tdammers> elfeck: so you can neither wrap it around IO, nor liftIO into it
08:19:33 <hongminhee> haha, actually i had considered the latter way
08:19:33 <tdammers> elfeck: I wrote this thing to remedy that: http://hackage.haskell.org/package/tamper
08:19:35 <Zekka|Sigfig> Post-compilation you would have the same representation as with just strings, but pre-compilation you get errors if people don’t use your smart constructor
08:20:01 <tdammers> elfeck: downside is that it's not actually Blaze, so it won't work with anything that's supposed to complement Blaze proper
08:20:03 <Zekka|Sigfig> You still can’t guarantee no one will pass something into your smart constructor that *they* expected to work, but won’t actually work
08:20:18 <hongminhee> Thank you for saving me  :-)
08:20:26 <Zekka|Sigfig> So you may end up passing a Maybe around that you didn’t want
08:20:46 <tdammers> elfeck: it's probably a better idea to just bite the bullet and get the time from outside the MarkupM monad
08:20:53 <elfeck> tdammers: Thanks for the info. I will just drag the curretTime in from a IO context
08:20:55 <elfeck> yes
08:21:16 <Zekka|Sigfig> hongminhee: Best of luck, dude!
08:21:25 <quicksilver> tdammers: "triggering database queries from within a template" *shudder* :)
08:21:56 <tdammers> tee hee
08:22:35 <tdammers> but then, it depends what kind of realm your database is supposed to represent, and what kind of application you're building
08:22:46 * quicksilver nods
08:23:15 <quicksilver> I've been writing and maintaining web apps for so long that the suggestion of resource-intensive side-effects triggered from the template file gives me hives
08:23:21 <quicksilver> but there are times and places, no doubt.
08:23:40 <Zekka|Sigfig> quicksilver: What if the templates are dynamic? Like, let’s say we let the user supply them...
08:24:04 <tdammers> well, sometimes this is cleaner (and faster) than hitting the database on every request to pull in data that is only needed on a few occasions
08:24:15 * quicksilver nods
08:24:39 <Zekka|Sigfig> tdammers: I think it’s cool so long as there’s an upper bound on how many effects there are, and that upper bound is cool with you!
08:27:30 <obadz> f :: Typeable a => (TypeRep, Maybe a)
08:27:38 <obadz> f = (typeOf . fromJust $ y, y) where y = Nothing
08:27:46 <obadz> What's wrong with this?
08:27:55 <obadz> I get error: Could not deduce (Typeable a0) arising from a use of ‘typeOf’
08:28:34 <obadz> what is this a0 type variable and shouldn't it be just a ?
08:28:57 <quicksilver> you where-bound it
08:29:02 <quicksilver> so it's polymorphic
08:29:16 <quicksilver> y has type forall b . Maybe b
08:29:26 <glguy> You can do: case Nothing of y -> ...
08:29:40 <quicksilver> or you can do ScopedTypeVariables
08:29:51 <quicksilver> and annotate y :: a
08:30:01 <quicksilver> although once you go ScopedTypeVariables you don't really need it
08:30:08 <fractalsea> In my code I have a lot of with* functions that wrap error handling functions like `bracket`. The problem is that in my code I end up with “staircase” of these functions with my code getting increasingly indented. Is there a good way of avoiding this?
08:30:11 <quicksilver> since you can do typeOf (undefined :: a)
08:30:25 <quchen> fractalsea: YES! Cont! :-)
08:30:38 <quicksilver> fractalsea: choose not to indent them?
08:30:45 <quicksilver> no need to indent nested functions, generally
08:30:55 <obadz> quicksilver: ScopedTypeVariables doesn't fix it
08:31:00 <quchen> You have functions like "(a -> m r) -> m r" all over the place. Put them into a list, and sequence for Cont will do your un-staircasing :-D
08:31:03 <obadz> quicksilver: with or without annotation
08:31:05 <fractalsea> quchen: hmm I’ve never used that before, I thought it could be a potential solution. Will look into it
08:31:06 <glguy> quicksilver: Better than typeOf undefined is the typeRep function
08:31:15 <glguy> since you can pass it a proxy argument that isn't undefined
08:31:29 <quicksilver> unless they are actually withFoo $ \x -> do withBar $ \y -> do ... and the do blocks force stairstep indentation
08:31:38 <quicksilver> agreed glguy 
08:31:43 <quicksilver> just exploring the possibilities
08:31:54 <fractalsea> quicksilver:: hmm I guess. I do like to keep as consistent as code style as possible though]
08:31:55 <quchen> fractalsea: It's the best casual use of Cont that I know :-)
08:32:10 <quicksilver> obadz: ScopedTypeVariables should solve it. 
08:32:18 <quicksilver> obadz: you do need to put 'forall' in your type sig though
08:32:34 <quicksilver> glguy: also depends which version of Data.Typeable obadz is using, no?
08:32:38 <quicksilver> they changed.
08:32:39 <fractalsea> Thanks
08:32:53 <quicksilver> fractalsea: I consistently dont' indented nested applications of $
08:33:04 <quicksilver> $ is no more reason to indent than + or <>
08:33:05 <obadz> quicksilver: works with forall, thanks.
08:33:07 <quicksilver> it's just an operator.
08:33:13 <tdammers> I consistently don't nest $
08:33:17 <quicksilver> I agree it's worth being consistent.
08:33:27 <quicksilver> tdammers: the only time I nest $ is that "withFoo... withBar" idiom
08:33:38 <tdammers> heh, yeah
08:33:45 <tdammers> but I tend to go the . route anyway for that
08:33:48 <quicksilver> (and that is the case fractalsea is talking about)
08:33:50 <hodapp> what counts as nesting $?
08:33:53 <tdammers> withFoo . withBar $ do theThing
08:34:03 <quicksilver> doesn't work for lambdas tho
08:34:06 <hodapp> foo $ bar $ baz $ quux arg ?
08:34:12 <quicksilver> withFoo $ \x -> withBar $ \y -> ...
08:34:27 <tdammers> oh, that
08:34:29 <tdammers> yes
08:34:36 <quicksilver> and it doesn't work if you have a non-trivial 'do' at the middle level either
08:34:47 <quicksilver> that is the kind of thiing fractalsea is asking about you see.
08:34:56 <fractalsea> yeah, makes sense
08:35:05 <tdammers> I'd indent the do block
08:35:11 <tdammers> not because of $, but because of do
08:41:13 <c_wraith> Doesn't ContT flatten the with... idiom? 
08:42:09 <glguy> It does
08:42:29 <fractalsea> Yeah I just tried restructuring the code with ContT. It is quite nice, but it does feel a bit heavywait in order to solve a code style issue
08:42:32 * hackagebot agda-snippets 2.4.2.4 - Render just the Agda snippets of a literate Agda file to HTML  https://hackage.haskell.org/package/agda-snippets-2.4.2.4 (LiamOConnorDavis)
08:42:34 * hackagebot fn 0.1.4.0 - A functional web framework.  https://hackage.haskell.org/package/fn-0.1.4.0 (DanielPatterson)
08:44:48 <c_wraith> It's not executionally heavyweight.. If only someone made a restricted ContT for only this use case. :) 
08:45:16 <c_wraith> (I don't think you actually can restrict it like that) 
08:50:05 <glguy> You don't need to expose the final result type like in ContT because you don't need the ability to capture the current continuation for later, Codensity is closer what what is needed for the with pattern
08:50:06 <glguy> http://hackage.haskell.org/package/kan-extensions-4.2.3/docs/Control-Monad-Codensity.html
08:50:36 <kras> Hi, I am trying to read in a file from command line, I have the following http://lpaste.net/144576
08:50:45 <kras> it doesn't print the result not it complains about the error
08:50:51 <kras> stack exec hverilog < filename
08:51:09 <glguy> kras: That means it's probably parsing to 'Right []'
08:51:09 <kras>  Any hints appreciated
08:51:11 <glguy> and printing no lines
08:51:45 <kras> glguy: when I test interactively in ghci 
08:51:58 <kras> it seems to be parsing correctly
08:52:12 <c_wraith> I was just looking at Codensity. It seemed a little weird, where the `a' appears. 
08:52:33 * hackagebot roller 0.1.6 - Playing with applicatives and dice!  https://hackage.haskell.org/package/roller-0.1.6 (PiotrJustyna)
08:53:19 <c_wraith> I don't think it lets you bind away the with pattern, because the bind gives you back the "wrong" type. 
08:57:50 <lpaste> glguy pasted “codensity for with pattern” at http://lpaste.net/144595
08:58:25 <glguy> c_wraith: That's not what you meant?
08:58:54 <quicksilver> :t Foreign.Storable.alloca
08:58:56 <lambdabot> Not in scope: ‘Foreign.Storable.alloca’
08:59:21 <quicksilver> alloca :: Storable a => (Ptr a -> IO b) -> IO b
09:00:37 <c_wraith> Hmm. Seems I always get myself turned around with continuations 
09:00:53 <jophish> Is there ever a case for not using MonadIO?
09:01:00 <quicksilver> that is a beautiful thing that glguy has pasted
09:01:18 <quicksilver> not least for hte apparently incomprehensibly ungrammatical "codensity for with pattern"
09:02:53 <c_wraith> jophish: it doesn't really work in negative position. 
09:03:49 <Trinity_> hello? 
09:05:14 <c_wraith> jophish: the simplest example of MonadIO breaking down is something like catch
09:05:34 <jophish> c_wraith: oh, I think I see
09:07:33 * hackagebot servant-swagger 0.0.0.0 - Swagger  https://hackage.haskell.org/package/servant-swagger-0.0.0.0 (DavidJohnson)
09:07:37 <c_wraith> glguy: I am amused your example didn't use withFile instead of alloca
09:09:13 <glguy> c_wraith: I went with something that had no other arguments
09:09:23 <glguy> but withFile would have made for a fine example, too
09:09:36 <Trinity_> what is this channel about? 
09:09:54 <prsteele> Trinity_: The Haskell programming language
09:10:31 <Trinity_> sounds complicated 
09:11:37 <c_wraith> Nah. Just unfamiliar to most. 
09:11:45 <impure_hate> is there a library for graph (or AST) manipulation?
09:12:00 <impure_hate> I think I saw one few weeks ago but can't find it now
09:12:08 <prsteele> https://hackage.haskell.org/package/fgl ?
09:12:11 <dmj`> Trinity_: http://haskell.org
09:12:12 <c_wraith> impure_hate: fgl for general graphs 
09:12:39 <voronoi_potato> Trinity_: lol how did you get here?
09:13:22 <Trinity_> I Google matrix and Google said freenode haskell
09:13:23 <c_wraith> voronoi_potato: this channel is in freenode's top 10 largest 
09:13:44 <voronoi_potato> Trinity_: nice, you're close enough
09:14:37 <voronoi_potato> if neo did exist he'd be in the chat
09:14:44 <impure_hate> :D
09:15:21 <c_wraith> New theory: Neo was based on edwardk, but made more realistic. 
09:15:51 <impure_hate> and for AST transforms is there a better way then pattern matching and replacing things with recursive functions?
09:17:04 <c_wraith> impure_hate: there are lots of things specifically designed for ASTs. I just have never used any of them. 
09:17:28 <impure_hate> I see a repetitive pattern in my code - writting stuff like 'tranform (Block a b):xs = (AnotherBlock a b):xs' 
09:17:49 <impure_hate> so I guess someone already solved it more elegantly then this :)
09:18:00 <impure_hate> than..
09:18:37 <c_wraith> You can certainly factor out recursive traversals. The tricky part is doing it well. :) 
09:18:42 <impure_hate> :)
09:19:16 <impure_hate> I'm wondering if I should switch to records + lenses for these things
09:19:17 <c_wraith> There are lots of libraries for that. Choosing which one to use is still an art. 
09:19:30 <impure_hate> or just stick with complex ADT
09:19:48 <impure_hate> yeah. choosing libraries is difficult, especially for a newcomer like me
09:20:18 <c_wraith> The more advanced stuff in lens is certainly one option. Things like Plated make tree traversals really nice. 
09:20:18 <impure_hate> what makes it even more difficult is the lack of examples for some libraries
09:23:11 <c_wraith> I like lens as a toolkit for data manipulation, but it definitely takes a lot of practice to think in terms of its approach. 
09:23:29 <impure_hate> hehe, Plated has some examples but it's not any clearer how to use it or what it actually does after reading them :D
09:24:44 <prsteele> I wish more libraries shipped with a Tutorial module, e.g. https://hackage.haskell.org/package/HTF-0.13.1.0/docs/Test-Framework-Tutorial.html
09:24:58 <impure_hate> I guess I'll stick with basics now, adding more stuff later when it becomes clear what I need 
09:25:07 <impure_hate> prsteele: exactly!
09:25:58 <impure_hate> I'm glad for every blogpost that's discussing one of the less documented libraries
09:26:25 <c_wraith> I just never want haskell docs to look like ruby, which doesn't bother documenting how anything works, and just give a couple examples instead. 
09:26:52 * hodapp cargo-cults c_wraith
09:28:08 <lpaste> hwanzike pasted “explode v2” at http://lpaste.net/6807542190865121280
09:28:09 <impure_hate> c_wraith: neither extreme is good :)
09:29:09 <hwanzike> can someone explain the warnings on that paste?
09:29:28 <hodapp> impure_hate: discussing less-documented libraries is what I have been trying to do with Atom & Ivory, albeit usually I try to do pull requests first to the maintainers, and add some docs there
09:30:25 <lpaste> hwanzike annotated “explode v2” with “explode v2 (annotation)” at http://lpaste.net/6807542190865121280#a144596
09:30:25 <c_wraith> hwanzike: those come from hlint, which talks about style issues
09:30:36 <impure_hate> hodapp: much appreciated :)
09:30:42 <hwanzike> ok i fixed some, the one on line 2 i don't get
09:30:57 <hwanzike> where and why does it want me to use ":" ?
09:31:12 <c_wraith> :t (:) 
09:31:13 <lambdabot> a -> [a] -> [a]
09:31:14 <obadz> Is there an easy way to derive Hashable instances? Data.Hashable.Generic looks like it still requires spelling out an instance
09:31:44 <hwanzike> c_wraith: so just replace [first] with first:[] ?
09:31:56 <prsteele> hwanzike: maybe [first] ++ -> first : ?
09:32:20 <hwanzike> ah that makes more sense, instead of concatenating lists, create a single one on the fly
09:32:29 <obadz> typechecker seems happy if I just write instance Hashable MyType
09:33:05 * hackagebot versions 1.0.1 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-1.0.1 (fosskers)
09:33:07 * hackagebot exact-pi 0.3.0.0 - Exact rational multiples of pi (and integer powers of pi)  https://hackage.haskell.org/package/exact-pi-0.3.0.0 (dmcclean)
09:33:09 <c_wraith> obadz: yes, that's how Generic instances worm. 
09:33:12 <c_wraith> ... Work
09:33:17 <obadz> c_wraith: thx
09:33:24 <hwanzike> c_wraith prsteele thanks!
09:33:25 <obadz> c_wraith: why can't we use deriving ?
09:34:09 <c_wraith> obadz: you can with the proper extension enabled, but I've never used that extension. 
09:34:43 <c_wraith> obadz: it's new. Added specifically to unify all the different ways of using automatic instances. 
09:35:11 <obadz> c_wraith: DeriveAnyClass ?
09:35:15 <obadz> looks like it works.
09:35:23 <c_wraith> Sounds right. 
09:35:32 <obadz> kewl
09:35:37 <hodapp> did Haskell have any notion of 'kind' circa 2000? I'm reading this paper and the only thing 'above' types that it mentions is typeclasses.
09:35:42 <obadz> new toy :)
09:37:04 <merijn> hodapp: Probably, the notion of kinds in type theory dramatically predates haskell, so
09:37:09 <c_wraith> hodapp: technically, haskell doesn't have any idea of kind. It's just one possible mechanism to make sense of type constructors. 
09:37:47 <merijn> hodapp: But kinds aren't always relevant to the topic discussed
09:37:51 <c_wraith> hodapp: you'll note that all explicit mentions of kinds require extensions
09:38:23 <levi> Kinds are mentioned in the Haskell98 Report, but they're purely an implicit thing.
09:38:24 <shiona> is there any better place to find help with reactive-banana(-wx)
09:38:49 <hodapp> The paper is discussing typeclasses as a way to 'organize' types, in the same sense that types are to 'organize' values.
09:39:04 <merijn> hodapp: Which paper?
09:39:30 <hodapp> merijn: http://www.cse.chalmers.se/~hallgren/Papers/hallgren.pdf
09:40:19 <Trinity_> white paper 
09:41:21 <merijn> hodapp: Ah, but this paper is not discussing just "plain" typeclasses
09:41:50 <merijn> hodapp: In the context of FunDeps we're basically talking "type level prolog" (as opposed to the "type level lambda calculus" you get with type families)
09:42:17 * hodapp ponders 'type level prolog' vs. 'type level lambda calculus'
09:43:17 <merijn> hodapp: With multiparam typeclasses + fundeps, GHCs constraint solver is pretty much (if not exactly) equivalent to a prolog implementation (albeit and inconvenient and verbose one)
09:44:20 <hodapp> merijn: good to know. I'd heard something similar (that Haskell's type checker basically includes Prolog) but had not heard that level of detail on it
09:44:27 <obadz> Is it good practice to include the typeRep of something in its Hash?
09:44:40 <obadz> Feels that otherwise the probability of collisions goes up..
09:44:58 <merijn> hodapp: Actually, the first line of the abstract also mentions this :)
09:45:01 <luigy> merijn can  you recommend a paper that shows this a bit more in depth?
09:45:10 <merijn> hodapp: "This paper illustrates how Haskell's type lass system an be used"
09:45:28 <merijn> "to express computation"
09:45:33 <hodapp> merijn: that doesn't tell me it's expressing Prolog-ish computations
09:45:45 <merijn> luigy: The printed version of "Fun with Functional Dependencies" paper
09:46:11 <hodapp> I linked to the draft version above
09:46:14 <merijn> hodapp: True, but prolog is basically just a constraint solver, which is what the typechecker has to do to solve typeclass constraints
09:46:43 <hodapp> merijn: that's hardly saying it in the first line of the abstract :P
09:47:40 <merijn> hodapp: So in this context the section 2 (where I'm guessing this "typeclasses are like types" claim is made) is trying to draw parallels between computation done using terms and described by types, and computation done using types and described by typeclass constraints
09:47:58 <hodapp> merijn: yeah, I'm reading that now
09:48:17 <hodapp> merijn: have you any good references on type families being more like type-level lambda calculus?
09:48:47 <merijn> hodapp: Well, that one is fairly straightforward, type families give you type level functions and that's really all you need ;)
09:48:59 <merijn> hodapp: You have type level functions, recursion and application
09:49:19 <merijn> The "Fun with Type Functions" paper is a very readable and good intro to type families, imo
09:49:26 <hodapp> I'll check it out
09:49:28 <merijn> Certainly easier to grok than the FunDeps stuff, imo
09:49:55 <merijn> I prefer type families to FunDeps, but they have worse inference, but if like me you annotate everything anyway, who cares? :)
09:50:12 <hodapp> Oleg, SPJ, & Shan? That paper?
09:50:58 <hodapp> http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
09:51:50 <merijn> Yeah
09:52:19 <merijn> And with the closed type families we have since 7.8 you can even use type level pattern matching for even more abuse! :>
09:52:31 <hodapp> O_O
09:52:47 <merijn> My favourite example being https://gist.github.com/merijn/6130082
09:52:50 <hodapp> what is it with type-level computations and using terms based around 'abuse' and 'masochism' to refer o_O
09:52:55 <hodapp> like the Hasochism paper
09:53:56 <merijn> hodapp: Because it's so much simpler in dependently typed languages
09:54:13 <merijn> hodapp: Like, 90% of the stuff described in these papers is trivial and straightforward when you have dependent types
09:54:29 <merijn> The masochism comes from trying to bend Haskell's type system to support stuff it wasn't designed for
09:54:35 <hodapp> hmmmmm
09:54:50 <hodapp> I should look at "Type-Level Instant Insanity" in TMR 8 too
09:55:04 <merijn> hodapp: If you look at the type families paper and then have a glance at, say, Agda and Idris you'll see it's so much simpler
09:55:55 <merijn> hodapp: Here's a good example of how simple it is in Idris: https://www.youtube.com/watch?v=fVBck2Zngjo
09:56:02 <merijn> Type safe printf
09:56:11 <hodapp> I've worked a bit with Coq but have never taken a dependently-typed thing I wrote there, and tried to see how to shoehorn it into Haskell
09:56:27 <hodapp> but nonetheless, I'm trying to understand existing shoehorning that I see in code
09:56:59 <merijn> hodapp: Here is some shoehorning: https://gist.github.com/merijn/39dc86e345e87276c523
09:57:17 <hodapp> as if I needed more :P
09:57:52 <merijn> hodapp: Now imagine you want to index that Vector with an Int, you'd have to somehow obtain an appropriate "Index n" from an Int, but writing "Int -> Index n" is not very sensible in haskell
09:58:03 <merijn> hodapp: Yeah, but this is a small standalone example
09:58:53 <merijn> hodapp: Now you end up needing existentials, singletons, etc. just to shoehorn "Int -> Index SomeNat" and a separate typeclass to somehow index using SomeNat, etc.
09:59:17 <merijn> hodapp: Whereas in Idris or Agda you'd just write "{n : Int } -> Index n" and call it a day
09:59:51 <merijn> (or "Pi (n : Int) . Index n" or whatever other convention you wanna use for Pi types)
09:59:51 <luigy> merijn thanks! nice shares! 
10:00:32 <merijn> Anyhoo, time to go
10:02:31 <hodapp> merijn: thanks for the explanation
10:03:07 * hackagebot sync-mht 0.3.8.0 - Fast incremental file transfer using Merkle-Hash-Trees  https://hackage.haskell.org/package/sync-mht-0.3.8.0 (emink)
10:09:41 <fresheyeball> hello haskellers
10:10:47 <hodapp> hiya
10:10:55 <prsteele> Hello
10:11:12 <marchelzo> what exactly does it mean when your program quits and prints <<loop>>?
10:12:11 <prsteele> marchelzo: the runtime was able to determine that you are caught in an infinite loop
10:12:21 <marchelzo> that's odd
10:12:23 <prsteele> marchelzo: not all such loops can be detected
10:12:58 <marchelzo> I wonder if anyone could help me understand why I am caught in an infinite loop: http://sprunge.us/PAcX?haskell
10:13:36 <marchelzo> I must be using Data.Function.Memoize.memoize incorrectly, because it worked before I tried memoizing it.
10:13:55 <hodapp> the runtime detects (some) infinite loops?
10:14:38 <prsteele> I was going to ask, does it work if you remove memoization?
10:14:48 <kadoban> hodapp: It does. Sometimes you'll see <<loop>> or whatever it looks like.
10:14:54 <marchelzo> I'll double check.
10:14:58 <hodapp> I did not know that.
10:15:10 <kadoban> I'm not sure under what circumstances though, it doesn't come up much.
10:15:18 <prsteele> hodapp: simplest I can come up with is "main = main"
10:15:30 <prsteele> hodapp: it compiles, and if run prints "nameofprog: <<loop>>"
10:15:38 <marchelzo> >.< I must have broken something else while making it memoized.
10:16:31 <hodapp> I have run into a couple infinite loops that usually were my fault for shadowing some name with an inferred type, and somehow not ending up with a type error
10:19:01 <prsteele> marchelzo: where do you use the 's' parameter in go?
10:20:12 <prsteele> marchelzo: it seems you only use it in s + n. Without figuring out what you're solving, it seems like you just keep calling go (k, s) with larger and larger s values?
10:22:59 <marchelzo> prsteele: no, because n can be negative
10:23:24 <marchelzo> and go stops when k = 1 regardless of s
10:24:17 <prsteele> ah, missed (1, _) pattern
10:25:02 <fresheyeball> I have a question that might be dumb
10:25:15 <fresheyeball> but is there any difference between Unit and Top?
10:25:32 <fresheyeball> type theory wise
10:25:41 <fresheyeball> T = () 
10:25:42 <fresheyeball> ?
10:27:17 <marchelzo> Unit is inhabited by a single value
10:27:23 <marchelzo> Top is inhabited by every value
10:27:35 <asdsadsa> hey guys.. I'm just learning - `let x = (subtract 3)`, then `x 2` will equal -1, what if I want the arguments flipped? so `x 2` will give me 1
10:27:37 <Welkin> Top?
10:27:45 <Welkin> never heard of it
10:28:07 <asdsadsa> let x n = (subtract n 3) will work, but can I do it without the `n`?
10:28:08 * hackagebot validate-input 0.4.0.0 - Input validation combinator library  https://hackage.haskell.org/package/validate-input-0.4.0.0 (AlexanderThiemann)
10:28:10 * hackagebot argon 0.4.0.0 - Measure your code's complexity  https://hackage.haskell.org/package/argon-0.4.0.0 (rubik)
10:28:12 <lyxia> asdsadsa: let x = (3 -)
10:28:28 <lyxia> asdsadsa: let x = flip subtract 3
10:28:46 <lyxia> asdsadsa: let x = (-) 3
10:28:49 <asdsadsa> oh sweet.. ok thank you
10:28:55 <lyxia> :)
10:29:08 <fraq4415> looking at the source code of GHC.IO.Handle.Text, it appears that putStr/putStrLn lock stdout and therefore when executed from different threads, their output will not be interleaved
10:29:12 <fraq4415> is that corrent?
10:29:19 <fraq4415> *corect
10:33:24 <mniip> lyxia, asdsadsa, (`subtract` 3)
10:33:34 <fresheyeball> Welkin the Top type
10:33:45 <fresheyeball> the opposite of (forall a. a)
10:39:14 <bobvh> hi there, got a question (fp101x student)
10:39:21 <bobvh> if a function has type
10:39:24 <bobvh> f :: (a -> a) -> a
10:39:38 <bobvh> i can´t see how to write one
10:39:51 <shachaf> You can only do it with recursion.
10:40:17 <fraq4415> fix from Data.Function
10:40:45 <bobvh> if i understand well, it takes a some function and return a type a value.. 
10:40:49 <bobvh> ok will check that
10:41:51 <mnoonan> bobvn: returns a type a value or fails to terminate :)
10:41:56 <bobvh> ok thanks for the fix tip
10:43:22 <levi> fresheyeball: A type system doesn't necessarily have a Top. If it does, it's definitely not Unit. The Top type unifies with the types of all possible terms. It's usually associated with type systems that have a subtyping relation on types.
10:43:51 <bobvh> reading up on fix...
10:44:06 <prsteele> bobvh: let fix f = f (fix f); f (const 1)
10:44:11 <prsteele> bobvh: that returns 1
10:46:22 <prsteele> bobvh: https://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
10:46:43 <bobvh> was reading that :)
10:47:03 <poucet> kosmikus: still around?
10:49:21 <fresheyeball> so... Bottom is in Haskell
10:49:26 <fresheyeball> why not Top?
10:50:13 <Cale> fresheyeball: Generally types have a "unique" least-defined value, but many incomparable maximally-defined values.
10:50:17 <marchelzo> I thought forall a. a _was_ top?
10:50:33 <fresheyeball> thats bottom
10:50:53 <quchen> Bottom is any value of that type.
10:51:02 <marchelzo> ah, I see
10:51:02 <Cale> fresheyeball: In fact, the fact that undefined is really a unique bottom to the definedness ordering for Haskell is a slight lie: we're identifying it with  let x = x in x  and  error "u broke it"
10:51:08 <fresheyeball> oh nice distinction 
10:51:17 <marchelzo> Void is also bottom, then?
10:51:19 <levi> There's a type-level bottom as well as a value-level bottom.
10:51:29 <levi> They're different things.
10:51:40 <quchen> Void isn't bottom. A value of type Void is necessarily bottom.
10:52:01 <marchelzo> So what is the type-level bottom?
10:52:20 <poucet> Why would one choose to use 'data Proxy a = Proxy' and pass that to some function 'foo :: SomeClass a => Proxy a -> b -> c'  vs simply: "foo :: SomeClass a => a -> b -> c' and pass in as first argument (undefined :: MyType)
10:52:38 <Cale> marchelzo: In a type system with subtyping, it would be a type which was a subtype of every other type.
10:53:08 <shachaf> "bottom" is something that might be defined for a partial order. Before you can say what bottom is, you have to define your partial order.
10:53:17 <Ferdirand> poucet: because you have a guarantee that the program won't blow up if someone tries to match over the Proxy ?
10:53:19 <shachaf> You might also generalize it and talk about the initial value in a category.
10:53:20 <thoughtpolice> poucet: Safety, so you can't accidentally evaluate the 'undefined' when you're passing that value around.
10:53:32 <Cale> Haskell doesn't really have subtyping. You can talk about a partial ordering induced by unification though, in which case there is no bottom type in Haskell.
10:53:46 <shachaf> poucet: Because undefined is an inelegant hack. You're not trying to pass a value to the function, you're trying to pass a type. Proxy is the most direct way you can do that.
10:53:53 <poucet> Thanks!
10:53:57 <shachaf> poucet: Another reason is that a might not have kind *.
10:54:16 <shachaf> "Proxy Maybe -> ..." is no problem, "Maybe -> ..." is an error.
10:54:29 <poucet> shachaf: ah interesting :)
10:54:42 <poucet> but if you write 'data Proxy a = Proxy' isn't a kinded to '*' by default?
10:54:56 <shachaf> Without PolyKinds, yes.
10:54:56 <poucet> would you have to write data Proxy (a :: k) = Proxy ?
10:55:02 <shachaf> No.
10:55:26 <Cale> In general, if you have some set S, and a partial order <= on S, then a bottom element (if it exists) is an element m such that for all x in S, we have m <= x
10:55:27 <shachaf> But of course you don't have to use the type Proxy in particular (in fact you shouldn't).
10:55:39 <hodapp> I'm not aware of too many languages that *do* have subtyping, and still try to do some sort of strong & static typing
10:55:50 <poucet> hodapp: ocaml
10:55:58 <kosmikus> poucet: yeah, somewhat around ...
10:55:59 <marchelzo> Cale: I see
10:56:01 <hodapp> poucet: yeah, OCaml seemed to have one form thereof
10:56:06 <hodapp> Scala I suppose does too
10:56:16 <poucet> kosmikus: Seems my question was answered :D
10:56:24 <Cale> When a bottom element exists, we usually write an upside down T for it (usually rendered in ascii as _|_), in the same way that we typically use the symbol 0 to refer to the additive identity.
10:56:39 <kosmikus> poucet: about Proxy?
10:56:40 <levi> Scala, on the other hand, does have a subtype relation on object types. 'Any' is the Top of the Scala class hierarchy.
10:56:42 <poucet> kosmikus: yep
10:56:51 <kosmikus> poucet: ok, good :)
10:57:09 <poucet> hodapp: afaicr, subtyping in o'caml always required a lot of explicit casting to make it work
10:57:10 <Cale> Well, it's not quite typographically an upside down T, it's a bit stylised, in the same way as the element-of relation isn't usually an epsilon any more)
10:57:40 <shachaf> Cale: It's an upside-down not quite T, though.
10:57:46 <Cale> yeah
10:57:48 <Cale> heheh
10:58:07 <fresheyeball> ok one more question 
10:58:08 <Cale> The corresponding stylised T is used for top
10:58:09 * hackagebot keera-hails-reactivevalues 0.2.2.0 - Haskell on Rails - Reactive Values  https://hackage.haskell.org/package/keera-hails-reactivevalues-0.2.2.0 (IvanPerez)
10:58:19 <fresheyeball> I'm trying to use Database.Persist 
10:58:34 <fresheyeball> and it works fine until I want fields to use newtypes
10:58:48 <fresheyeball> for example
10:58:56 <fresheyeball> newtype Password = Password Text
10:59:00 <fresheyeball> No instance for (PersistFieldSql Password)
10:59:05 <kosmikus> poucet: just read up. shachaf explained it better that I could have anyway. I have nothing to add.
10:59:15 <fresheyeball> anyone know how to get around this?
10:59:29 <Zekka|Sigfig> fresheyeball: I’m not familiar with that particular library, but have you tried using generalizednewtypederiving to derive PersistFieldSql?
10:59:38 <Zekka|Sigfig> I’m assuming Text instantiates PersistFieldSql already
10:59:58 <Zekka|Sigfig> If you don’t like extensions you can instantiate it yourself, of course, but that extension is very benign
11:00:00 <poucet> kosmikus: yep, thank you
11:00:20 <Cale> Yeah, you'll get a different result that way from if you use the Template Haskell stuff to actually make a table for Password in your database.
11:01:18 <Cale> I don't actually know persistent very well, but I'm using groundhog at work and that's similar.
11:02:14 <shachaf> poucet: To clarify, you can write "foo :: SomeClass a => proxy a -> b -> c", instead of using "Proxy"
11:02:15 <Cale> I believe both libraries have some TH quasiquoter which uses yaml syntax to specify configuration about how your Haskell datatypes are encoded, in cases where there are some tweaks to be made.
11:02:41 <shachaf> poucet: Then the consumer can pass Proxy or another type of their choice.
11:02:42 <bobvh> okay, so ´fix (\x -> 1)´ terminates
11:03:49 <levi> fresheyeball: So, if you want to look at a type system with a subtyping relation and Top/Bottom elements, the Scala type system is an example.
11:03:51 <poucet> shachaf: what is the type 'proxy'
11:03:58 <shachaf> Whatever type you want.
11:04:08 <poucet> shachaf: but it's lower case, so not specified
11:04:08 <shachaf> For example, it could be Proxy.
11:04:15 <shachaf> Or Maybe.
11:04:22 <fresheyeball> crazy
11:04:38 <fresheyeball> the case for scala from type theory is more compelling than I realized
11:04:55 <levi> fresheyeball: If you do an image search for the scala type hierarchy, you can see the lattice structure.
11:04:56 <poucet> shachaf: what if the proxy is a type class that loses typing informaton, like the Server in the example http://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/
11:05:04 <poucet> s/type class/type family
11:05:06 <dgpratt> are there any basic hackage statistics to be had?
11:06:00 <Cale> fresheyeball: Oh, you might also be able to use derivePersistField, though that might be less efficient, since it'll use the Show and Read instances.
11:09:10 <kosmikus> poucet: you cannot match type families with type variables
11:10:16 <fresheyeball> how about newtype deriving?
11:10:39 <poucet> kosmikus: now or ever?
11:10:49 <shachaf> Ever.
11:11:00 <shachaf> It has to be injective to be used like this.
11:11:54 <fresheyeball> I've never used newtype deriving, how could I use it to derive PersistFieldSql
11:11:56 <fresheyeball> ??
11:12:15 <poucet> shachaf: like this: https://ghc.haskell.org/trac/ghc/wiki/InjectiveTypeFamilies ?
11:12:24 * poucet is way out of his depth
11:12:47 <shachaf> Maybe injective type families like described there could do it.
11:12:59 <kosmikus> poucet: I don't think you will be able to match like this even with an injective type family.
11:13:03 <poucet> oh right, if it's injective then you should be figure out the full-type 'a' becaus
11:13:10 <poucet> because it's injective
11:13:41 <kosmikus> datatypes are not just injective. they really have the property that "f a" uniquely determines both "f" and "a".
11:14:04 <poucet> kosmikus: but presumably an injective type family 'x a' uniquely determines a?
11:14:08 <poucet> is that not sufficient
11:14:12 <shachaf> kosmikus: Do you need to uniquely determine f?
11:14:17 <poucet> ^
11:14:22 <kosmikus> but even with injective type families, you can have "type family T1 Char = Int" and "type family T2 Bool = Int"
11:14:30 <kosmikus> now match "Int ~ f a"
11:14:35 <kosmikus> what then?
11:14:45 <poucet> kosmikus: That is not injective, is it?
11:14:55 <kosmikus> what's not injective?
11:14:59 <poucet> oh wait, you're right
11:16:13 <shachaf> Oh, sure, if you write "proxy a" I wouldn't expect that to just work.
11:16:34 <shachaf> But if you write "Server a -> ..." it might work if there was a guarantee that Server is injective. But I wouldn't especially expect it to.
11:16:38 * poucet wonders why injective type families are useful
11:17:43 <Zemyla> Okay, I've got a weird question.
11:18:22 <Zemyla> data Pair a = Pair a a is an Applicative and a Monad, but it also has two distinct possible Comonad implementations.
11:18:58 <Zemyla> If extract (Pair a b) = a, then you have duplicate (Pair a b) = Pair (Pair a b) (Pair b ?).
11:19:10 <Zemyla> And ? can legally be either a or b.
11:19:23 <shachaf> I find that difficult to believe.
11:20:08 <Zemyla> shachaf: ? = b is equivalent to the -> comonad over either All or Any, and ? = a is equivalent to the -> comonad over Xor.
11:20:52 <shachaf> Hmm.
11:21:09 <Zemyla> Is there any reason to favor one over the other?
11:21:41 <shachaf> OK, fair enough, now I find it less difficult to believe.
11:23:38 <Zemyla> Is there any reason to favor one over the other?
11:32:19 <dolio> I'm sure there are reasons for preferring each.
11:33:09 <dolio> But you need to decide which reasons you like.
11:34:11 <poucet> is Symbol a kind?
11:34:27 <dmj`> poucet: yes
11:35:11 <poucet> dmj`: Can you declare your own kinds as well?
11:35:22 <Zemyla> dolio: Honestly, I think I prefer ? = a, so both functions in extend get both values.
11:36:15 <dolio> It also gives you an identity matrix if you duplicate Pair 1 0.
11:36:18 <dolio> So that's nice.
11:36:26 <dmj`> poucet: you can, but you have to do so with the DataKinds extension enabled 
11:36:51 <dmj`> there might be an extension to declare kinds with the keyword 'kind'
11:38:15 <shalom> I have a list of Persistent Entities, what would be a good way of grouping them by a common value? For instance the type would look like Entity Transaction { occouredAt: UTCTime, userId: 10, bankId: 5 } -- I in the end would want something like Date { occouredAt: UTCTime, numTransactions: 10 }
11:38:18 <poucet> dmj`: I guess I don't inderstand why you would need to use it here: 'instance (KnownSymbol s, HasServer r) => HasServer ((s :: Symbol) :> r) where'.  Seems that either using (s :: Symbol) or "KnownSymbol s" 
11:38:31 <poucet> dmj`: abstractly it seems like you're saying the same thing twie
11:38:32 <poucet> twice
11:39:00 <dmj`> pucilowski: you shouldn't have to, where do you see this code? KnownSymbol is a class that all types of kind Symbol implement
11:39:03 <dmj`> poucet: ^
11:39:16 <poucet> dmj`: http://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/
11:39:54 <dmj`> poucet: that's just being explicit, and most likely done in the name of pedagogy, it isn't 'wrong'
11:40:38 <shachaf> poucet: (s :: Symbol) doesn't tell you that (KnownSymbol s).
11:40:40 <poucet> dmj`: how do you declare a type to be of that given kind?
11:40:53 <dmj`> poucet: class KnownSymbol (n :: Symbol) where, is what the source states
11:41:19 <poucet> dmj`: so instance KnownSymbol Foo  means (Foo :: Symbol) ?
11:41:29 <dmj`> poucet: data (a :: Symbol) :> b, is one contrived example
11:42:36 <poucet> dmj`: so you can't say "this type Foo is of my kind Bar"
11:43:35 <dmj`> poucet: you can, with KindSignatures
11:44:08 <dmj`> you'll need to enable DataKinds to promote your types to kinds, and then do something like (Bar  :: Foo)
11:49:27 * hodapp reads some of the scrollback about Scala...
11:49:50 <hodapp> one of these days I'll understand the relation between record subtyping, row polymorphism, and subtyping in general
11:57:40 <statusfailed> f you've got laziness problems I feel bad for you son, I've got 99 problems but *** Exception: Prelude.undefined
11:57:54 <hodapp> wut.
11:58:00 <statusfailed> nothing
11:58:09 <lpaste> statusfailed pasted “GADT woes” at http://lpaste.net/144605
11:58:17 <statusfailed> ^ can any GADT master help me with this?
11:58:38 <statusfailed> I want to add an "Eq" term that will work for any "t", but the "UEq" term commented out causes the "deriving instance Eq" to fail
11:58:41 <statusfailed> not sure why!
11:59:04 <shachaf> Maybe GHC can tell you why.
11:59:21 <shachaf> Sometimes it prints error messages when it detects errors. It's a pretty useful feature.
11:59:24 <statusfailed> haha
12:00:00 <statusfailed> it does do that! you are right. I don't understand the error though, and it's in the generated code for the derived instance
12:00:24 <dolio> statusfailed: How would it know that the types in that case are Eq?
12:01:24 <shachaf> You know the error but don't understand it, and I understand the error but don't know it.
12:01:28 <dolio> Oh, I guess it doesn't matter.
12:01:42 <statusfailed> shachaf: hang on :p
12:02:20 <lpaste> statusfailed annotated “GADT woes” with “GADT woes (annotation)” at http://lpaste.net/144605#a144606
12:02:34 <statusfailed> shachaf: I will add the -ddump-deriv in a sec 
12:02:39 <erik____> I've got a stackage question. the latest nightly has xmonad-0.11.1 and utf8-string-1.0.1.1 which are incompatible. Isn't that supposed to not happen?
12:03:57 <dolio> Oh right.
12:04:15 <dolio> statusfailed: You don't need to paste the -ddump-deriv code.
12:04:21 <statusfailed> dolio: oh ok
12:04:34 <sm> erik____: I think stackage doesn't guarantee total compatibility, if they don't compile a bug report is in order
12:04:58 <dolio> Think about the 'UEq t1 t2 == UEq t3 t4' case.
12:05:47 <dolio> It's going to try `t1 == t3`.
12:05:47 <phaazon> I’m starting to learn django (python) because we use that at work (new job), and I’m feeling amazed by how the migrations are created; does happstack have such a thing?
12:05:58 <phaazon> creating migrations for databases from models?
12:06:04 <dolio> But those aren't the same type.
12:06:29 <sm> phaazon: I think only persistent does it
12:06:29 <dolio> When you use BEq and DEq, they are guaranteed to be the same type.
12:06:48 <sm> which I'm sure you can use with happstack
12:07:02 <phaazon> persisent?
12:07:07 <phaazon> sounds good
12:07:10 <statusfailed> dolio: ahh I think I get you
12:07:21 <sm> phaazon: yes, check out the yesod book
12:07:27 <phaazon> hm
12:07:31 <dolio> statusfailed: So, to write the decision procedure, you instead need to write: myEq :: Term t a -> Term u a -> Bool
12:07:36 <phaazon> should I try to learn yesod?
12:07:41 <phaazon> my website is written with happstack
12:07:44 <dolio> And then use it at the more specific type.
12:08:29 <sm> yesod is good. But if you like happstack, maybe look for docs on integrating persistent with it first
12:08:37 <statusfailed> dolio: Then I would be allowing ill-typed terms in the object language, right?
12:09:17 <statusfailed> dolio: I want to prevent construction of a term comparing two terms of different types
12:09:28 <phaazon> sm: I mean
12:09:33 <phaazon> is yesod better than happstack?
12:09:34 <dolio> This isn't the term. It's the equality decision procedure on terms.
12:09:38 <phaazon> because I really like happstack :)
12:09:45 <phaazon> but never gave a try at yesod though
12:10:33 <statusfailed> dolio: right- so by allowing the equality decision procedure on terms to be generated, I'm also allowing ill-typed terms: if I write "Eq :: Term t a -> Term u a -> Bool", that permits the term "Eq (BLit False) (DLit 0.0) "
12:10:34 <dolio> statusfailed: I mean you write that function, and then do 'instance Eq (Term t a) where (==) = myEq'.
12:10:42 <sm> phaazon: you can get started quickly, so I'd say it certainly worth a try
12:11:14 <dolio> statusfailed: Do you mean UEq?
12:11:51 <statusfailed> dolio: yes, sorry
12:11:57 <dolio> How would it allow that?
12:12:01 <dolio> It's just a function.
12:12:38 <dolio> You don't change the UEq constructor. You have to change the decision procedure's type.
12:12:58 <statusfailed> dolio: oh I see! Sorry I misunderstood!
12:13:00 <dolio> The type of (==) is too narrow.
12:13:25 <statusfailed> Right, OK
12:15:55 <statusfailed> dolio: Oh neat, so I still get typechecking because the GADT forbids constructing "bad" terms, so myEq can ignore types, and just look at terms
12:16:27 <statusfailed> ... maybe
12:16:56 <dolio> Yeah, your terms don't have any information that depends on the type, so (==) wouldn't do anything with the information anyway.
12:17:20 <dolio> So you can write something that compares terms even if the types don't match.
12:17:51 <dolio> And then you can of course decide to use it only when the types do match, which is what (==) will do.
12:18:14 * hackagebot exact-pi 0.3.1.0 - Exact rational multiples of pi (and integer powers of pi)  https://hackage.haskell.org/package/exact-pi-0.3.1.0 (dmcclean)
12:18:36 <dolio> But even if the type of the whole expression matches, there are corresponding subterms that may not be known to match.
12:18:47 <dolio> Which caused your original problem.
12:18:52 <sinelaw> can I use higher-kinded type synonyms instances?
12:23:28 <statusfailed> dolio: thanks! :-)
12:23:50 <acro> hi
12:24:10 <acro> is there any way to use a function on ghci in a file
12:24:13 <acro> ?
12:24:25 <acro> like so
12:24:44 <acro> prelude> sort file.txt
12:26:55 <kadoban> acro: Not really, you have to write a bit more code to tell it what exactly to do. Like … what should that even do? Sort all of the characters? Sort by line?
12:27:26 <SLi> Does anybody know about the fixed-length vector packages? Which should I use? I'm thinking about writing code to process chess-like positions, but for an NxN board, so I'd like to have a homogenous (NxN)-tuple, or a fixed NxN length vector type. And I'd really like to have the safety that comes from not handling lists.
12:28:00 <SLi> fixed-vector at least seems quite recent.
12:29:11 <acro> what i said was and exemple, but thanks anyway kadoban 
12:29:59 <kadoban> acro: I assumed it was just an example. The question was supposed to rhetorically show you that there's several possible things that could do, and that it's not clear what one you'd want, without writing more code.
12:30:20 <kuribas> SLi: why not use a 2D array?
12:31:56 <SLi> kuribas: I don't think I can get the same type safety with that that I would get with a NxN tuple; it can contain more or less elements than it should (and some position might be missing). I think, at least with Data.Array.
12:33:00 <SLi> Hm, maybe I'm confused, maybe there is really an int-indexed array hidden somewhere. 
12:33:19 <kuribas> How are you going to index tuples?
12:33:38 <kuribas> You'll loose type safety anyway when indexing.
12:33:39 <Ankhers> SLi: When you say an NxN tuple, do you mean embedded tuples? Something like ((1.1,1.2),(2.1,2.2))?
12:34:22 <kuribas> unless you use Maybe...
12:35:32 <SLi> Well, it could be a tuple of length N*N. I guess the idea would have to be to avoid indexing them in general, but where that needs to be done, sure, it loses type safety (but still less than a list of lists for example, since a n-tuple is guaranteed to have n elements!).
12:36:10 <SLi> Most of the stuff I think could be done with functions that return a Maybe-wrapped square relative to some other square.
12:36:21 <SLi> Hmmh.
12:37:27 <Juliver> Hello, any recommendation as of the best editor/ide for haskell on Mac OSX ?
12:38:03 <Ankhers> Juliver: Best is very subjective.
12:38:16 <kadoban> Juliver: Whatever decent editor you like. vim, emacs, maybe sublime, atom, probably others.
12:38:25 <Ankhers> Juliver: Though, I believe Emacs and vim some up most often as suggestions.
12:38:40 <Ankhers> Juliver: Leksah is an IDE built in Haskell for Haskell.
12:39:06 <kadoban> Juliver: As long as it has syntax highlighting and the ability to use spaces instead of tabs nicely, it shouldn't matter. You'll want to keep a terminal window open also with ghci in it probably, and/or other tools.
12:39:18 <MrMetric> Does anyone know of an image library I can use to read an image, run a function to mutate each pixel, and write the modified image? I am trying to use JuicyPixels, but the types are confusing and I can't even get it to compile.
12:39:27 <Juliver> thanks!
12:39:59 <Ankhers> MrMetric: I believe JuicyPixels is considered one of the best in Haskell at the moment. What exactly are you having issues with?
12:40:33 <Ankhers> MrMetric: Disclaimer, I've never done image manipulation in Haskell.
12:41:16 <MrMetric> Ankhers: The readImage function returns a 'Maybe String DynamicImage', but the functions to get the image dimensions and data need an Image type
12:42:03 <MrMetric> I just want to do something like: read a png to imageData, 'map myFunction imageData', and write imageData to a new png
12:42:16 <MrMetric> Where each element in imageData is a pixel
12:42:54 <Ankhers> readImage returns `IO (Either String DynamicImage)'
12:42:58 <Juliver> Ankhers: did you ever work with Leksah? do you recommend it?
12:43:19 <Ankhers> Juliver: Unfortunately I've only gone so far as opening it a couple times. Never actually used it.
12:43:43 <MrMetric> Ankhers: and the library's functions don't use that type
12:44:17 <Juliver> Ankhers: thanks. 
12:45:01 <MrMetric> I'd like to note that I found it very easy to make what I want in C++ (and the code is shorter), so I assume I'm doing something horribly wrong
12:45:25 <Ankhers> MrMetric: What part of that type does JuicyPixels not use?
12:45:50 <danza> i am looking at the doc, you can get a DynamicImage from an Image http://hackage.haskell.org/package/JuicyPixels-3.2.6.2/docs/Codec-Picture.html#t:DynamicImage
12:46:00 <danza> would not know how to go in the other direction though
12:46:01 <MrMetric> Ankhers: When I try to use imageWidth, it says: Couldn't match expected type ‘Codec.Picture.Types.Image a1’ with actual type ‘Either String Codec.Picture.Types.DynamicImage’
12:46:27 <Ankhers> MrMetric: because imageWidth is a field on the Image type. Not on the DynamicImage type.
12:46:35 <MrMetric> danza: I looked at that and didn't see anything useful
12:46:44 <MrMetric> Ankhers: What does 'is a field on' mean?
12:47:00 <MrMetric> And I know it doesn't take the DynamicImage type. That's my problem.
12:47:03 <Ankhers> MrMetric: Are you familiar with Haskell Records?
12:47:12 <MrMetric> Ankhers: No
12:47:59 <Ankhers> They are essentially getters / setters for a given type.
12:48:00 <Ankhers> https://hackage.haskell.org/package/JuicyPixels-3.2.6.2/docs/Codec-Picture-Types.html#g:2
12:48:06 <kadoban> MrMetric: Look down at the bottom, kinda starting with dynamicMap. Is one of those what you want? https://hackage.haskell.org/package/JuicyPixels-3.2.6.2/docs/Codec-Picture-Types.html
12:48:12 <MrMetric> Ankhers: I learned some of the language in February, stopped because I was wasting too much time wrestling with the types (and the performance issues), and just started again the other day because I want to learn functional programming
12:48:33 <Ankhers> MrMetric: What language(s) do you know?
12:49:11 <MrMetric> Ankhers: I am mainly familiar with C, C++, Java, PHP (regrettably), JavaScript, Python, and Pascal, to varying levels
12:49:34 <MrMetric> Ankhers: I usually use C++ or Python
12:50:21 <Ankhers> MrMetric: https://hackage.haskell.org/package/JuicyPixels-3.2.6.2/docs/Codec-Picture.html#t:DynamicImage
12:50:38 <Ankhers> When you do a `readImage'
12:50:50 <reactormonk> Got a Maybe X, would like an X with a default value for X.
12:51:07 <Ankhers> You will get either an error (the String), or a DynamicImage.
12:51:16 <Ankhers> :t maybe -- reactormonk 
12:51:16 <reactormonk> Can't seem to find a function at https://wiki.haskell.org/Maybe
12:51:17 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:51:49 <Ankhers> > maybe 1 id (Just 5) -- reactormonk 
12:51:51 <lambdabot>  5
12:51:54 <Ankhers> > maybe 1 id (Nothing) -- reactormonk 
12:51:56 <lambdabot>  1
12:52:03 <Zekka|Sigfig> reactormonk: fromMaybe also works IIRC
12:52:05 <MrMetric> Ankhers: The C++ lib I use just throws an exception. Is there a function I can use to make JuicyPixels do that instead?
12:52:07 <Zekka|Sigfig> > fromMaybe 1 (Nothing)
12:52:09 <lambdabot>  1
12:52:18 <MrMetric> Ankhers: I want the program to exit if there is an error anyway
12:52:21 <Ankhers> Zekka|Sigfig: That is even better.
12:52:35 <Ankhers> MrMetric: Are you familiar with the `Either' type?
12:52:38 <reactormonk> Zekka|Sigfig, neat, thanks.
12:52:38 <Zekka|Sigfig> you can probably see that fromMaybe is just a specialization of maybe, of course
12:52:41 <MrMetric> Ankhers: No
12:53:30 <Ankhers> MrMetric: `Either' has two constructors. `Left' and `Right'.
12:53:45 <kadoban> :t flip maybe id
12:53:45 <reactormonk> Zekka|Sigfig, yeah, now I do.
12:53:46 <lambdabot> b -> Maybe b -> b
12:53:49 <Ankhers> MrMetric: It will only ever return one of the two constructors. Never both.
12:53:52 <MrMetric> Ankhers: What is the definition of 'constructor' in this context?
12:54:00 <MrMetric> Return a constructor?
12:54:15 <Ankhers> MrMetric: Return a value with that constructor.
12:54:18 <Zekka|Sigfig> MrMetric: The constructors of a data type are the basic functions that get you from values that go into the type to values in the type
12:54:21 <Zekka|Sigfig> > Just 1
12:54:21 <MrMetric> I am familiar with 'constructor' only in an object-oriented context, like C++ or Java
12:54:22 <lambdabot>  Just 1
12:54:26 <Ankhers> :t Left "Foo" -- MrMetric 
12:54:28 <lambdabot> Either [Char] b
12:54:29 <Zekka|Sigfig> Just is a constructor for Maybe
12:54:35 <Ankhers> :t Right 1 -- MrMetric 
12:54:36 <lambdabot> Num b => Either a b
12:54:49 <Zekka|Sigfig> Instead of ‘Just’ and ‘Nothing’ you have ‘Left’ and ‘Right'
12:55:16 <Ankhers> Left is generally used for returning an error. Right is used for the actual value.
12:55:41 <Ankhers> MrMetric: So, when you do a readImage, you will get either a Left or Right value.
12:56:57 <MrMetric> Ankhers: So how can I made it print the error and exit if there is an error, and otherwise ignore that and just give me the image?
12:57:56 <Ankhers> MrMetric: http://lpaste.net/144609
12:58:11 <Ankhers> I didn't try to compile that, but it should (hopefully) work.
12:58:41 <danza> Ankhers, on the right there i see a DynamicImage. How to go from a DynamicImage to an Image?
12:59:12 <MrMetric> Ankhers: I was thinking something like 'readImageOrExit', and in your paste, is 'undefined' where I'd put a function I want to run?
12:59:15 <Ankhers> danza: based on https://hackage.haskell.org/package/JuicyPixels-3.2.6.2/docs/Codec-Picture.html#t:DynamicImage you would just have to check the constructor.
12:59:40 <danza> check? you mean pattern match?
12:59:48 <danza> or case analysis?
13:01:41 <Ankhers> MrMetric: where `undefined' is, `img' will be the DynamicImage. You will still need to get the Image type out of it.
13:02:01 <MrMetric> Ankhers: How can I get the Image from it?
13:02:26 <kadoban> MrMetric: The only way I directly see to get an Image from a DynamicImage would be to pattern match every constructor, which would kinda suck.
13:02:44 <MrMetric> I want it to be Image PixelRGB8, regardless of the file format
13:02:46 <kadoban> MrMetric: There seems to be at least a few ways to directly use a DynamicImage though. I suspect I'm not seeing them all too.
13:03:18 <danza> maybe the idea is to work directly on DynamicImages with some lens magic https://hackage.haskell.org/package/JuicyPixels-3.2.6.2/docs/Codec-Picture.html#t:Traversal
13:05:09 <Ankhers> danza: For starting out, pattern matching is probably simpler.
13:05:17 <c_wraith> Liking haskell makes you hate things. Science says so. http://varianceexplained.org/r/polarizing-technologies/
13:05:34 <Ankhers> c_wraith: I saw that.
13:05:36 <danza> Ankhers, but pattern matching that is super tedious
13:05:53 <danza> c_wraith, ah, cool :D
13:06:02 <MrMetric> c_wraith: I don't know about that, but using Haskell is making me hate the type checker :P
13:06:06 <Ankhers> c_wraith: I don't necessarily disagree though. Since starting Haskell, I have fallen out of love with Ruby (Don't tell anyone I work with)
13:06:39 <danza> Ankhers, you lucky ... since starting Haskell, i can't appreciate anything else
13:06:49 <Ankhers> danza: It sure is, but probably a lot less mental overhead than trying to understand lenses. Especially when you are just learning Haskell like MrMetric 
13:07:04 <danza> there has to be an easier way though
13:07:13 <Ankhers> danza: I still enjoy other languages, just not as much as Haskell.
13:07:35 <Ankhers> I've been wanting to do something with both Rust and D. I just never have the time.
13:07:42 <MrMetric> Ankhers: If it helps, I can guarantee my input image is always in 8-bit RGB format
13:07:47 <danza> Ankhers, yea i misread that ... i read "fallen *in*" love instead that "*out* love" ... same here ... kind of a curse
13:08:17 <Ankhers> MrMetric: Just try doing a case on the constructor for that, and you will have the Image type to play with.
13:09:13 <Ankhers> MrMetric: Though, it is possible that if JuicyPixels returns something else, your program could crash because of a non-exhaustive search.
13:09:41 <MrMetric> Ankhers: That's okay, it's just a toy program for myself
13:11:03 <mnoonan> MrMetric: you can even combine the pattern matching with the previous one: http://lpaste.net/144609
13:11:33 <mnoonan> (but you should add another case to catch the bad format)
13:12:09 <MrMetric> mnoonan: Right now, I'm trying to make a readImageOrExit function (but it won't compile, of course)
13:19:07 <prsteele> anyone have any experience with Data.Vector? In particular I'm interested in figuring out if/when fusion can happen
13:20:12 <prsteele> e.g. I'm pretty sure something like `V.minimum (generatingFunction z)` will be O(1) memory, but would `(V.minimum x, V.maximum x) where x = someGeneratingFunction z`?
13:20:48 <c_wraith> The latter will almost certainly not fuse
13:21:11 <cocreature> I'm playing around with pattern synonyms and was trying to make a bidrectional pattern synonym for working with integers representing bools (I have this because of C ffi), however I'm getting a parse error http://lpaste.net/144614
13:21:18 <cocreature> both lines separate work fine
13:21:44 <c_wraith> Unless GHC introduces a Common Subexpression Introduction "optimization".
13:21:55 <prsteele> c_wraith: in that case, should I actually write out two expressions? Assuming I'm more worried about space than time
13:22:02 <prsteele> rather, time due to allocations that time from additions
13:22:17 <prsteele> (Fully aware this might be premature optimization)
13:23:47 * hackagebot concurrent-output 1.5.0 - Ungarble output from several threads  https://hackage.haskell.org/package/concurrent-output-1.5.0 (JoeyHess)
13:24:44 <c_wraith> prsteele: if you're worried about that, yes. Though benchmarking should be your final arbiter. :) have you used criterion? It's great. 
13:25:13 <prsteele> c_wraith: I'm used it a bit, and I definitely will *when this is done*. Not yet working well enough to do meaningful speed tests, haha
13:25:46 <prsteele> c_wraith: this is just the first time using Vector, so I don't have intuition for how I should be writing expressions. For now, readability wins
13:51:16 <dolio> prsteele: The most important thing is that fusion can only happen within a series of function calls.
13:52:24 <dolio> `foo (bar (baz x))` may fuse foo with bar with baz. `let y = baz x ; z = bar y in foo z` cannot fuse these things, unless inlining occurs.
13:57:50 <anks> u
13:58:02 <anks> "Couldn't match type ‘ByteString’ with ‘Data.ByteString.Internal.ByteString’" ..
13:58:34 <anks> importing one from Data.Attoparsec.ByteString.Lazy and second Data.ByteString.Lazy (ByteString)
13:58:52 <anks> why don't they match
13:58:54 <hpc> lazy bytestrings are a list of chunks (which are strict bytestrings)
13:59:02 * hackagebot servant-cassava 0.4.4.5 - Servant CSV content-type for cassava  https://hackage.haskell.org/package/servant-cassava-0.4.4.5 (jkarni)
13:59:11 <hpc> you'll need to straighten out your imports and decide which to use
13:59:16 <hpc> or convert between them
13:59:48 <anks> okay, can i convert lazy to strict ?
14:00:04 <anks> tbh i dont see where i am using strict one
14:00:07 <hpc> @hoogle chunks
14:00:09 <lambdabot> package chunks
14:00:10 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
14:00:10 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
14:00:14 <hpc> uh
14:00:19 <hpc> :t fromChunks
14:00:20 <lambdabot>     Not in scope: ‘fromChunks’
14:00:20 <lambdabot>     Perhaps you meant one of these:
14:00:20 <lambdabot>       ‘BSLC.fromChunks’ (imported from Data.ByteString.Lazy.Char8),
14:00:41 <anks> :t BSLC.fromChunks
14:00:43 <lambdabot> [BSC.ByteString] -> BSLC.ByteString
14:00:50 <hpc> yeah, fromChunks and toChunks
14:01:52 <anks> okay, ill try this
14:01:52 <anks> thanks!
14:28:32 <sleblanc> Can the Haskell lexer in Parsec parse floating point numbers with optional leading negative sign? (-)
14:33:24 <Lokathor> i don't recall if there's a builtin for tht
14:33:31 <Lokathor> but i know you can build it yourself of course
14:34:00 <sleblanc> I'm just getting my hands dirty with parsec, first time using it. Is there a way I can combine it with, I think, an optional char '-
14:34:03 <sleblanc> ' ?
14:34:21 <Lokathor> let me get my notes..
14:35:12 <Lokathor> https://github.com/Lokathor/fbmessageparse/blob/master/src/Main.hs was the most recent parsec thing i did
14:35:42 <sleblanc> (side note: I really like the shift of mentality from regex to parsec)
14:39:10 <Lokathor> optionMaybe :: Stream s m t => ParsecT s u m a -> ParsecT s u m (Maybe a)
14:39:15 <Lokathor> optionMaybe p tries to apply parser p. If p fails without consuming input, it return Nothing, otherwise it returns Just the value returned by p.
14:39:39 <Lokathor> I think that's what you're looking for, then you get either Just '-' (negative values) or Nothing (positive values)
14:42:51 <frontendloader> I need to make a function that returns void, how?
14:43:02 <sleblanc> frontend: ()
14:43:25 <sleblanc> frontendloader, are you talking about void in the C way?
14:43:33 <frontendloader> ya function that doesn't return anything
14:43:37 <sleblanc> just return ()
14:43:54 <sleblanc> that's the closest you get in Haskell to "Nothing at all"
14:44:24 <sleblanc> frontendloader, this is assuming that your function has side-effects, otherwise your function is useless
14:44:56 <Guest21550> hello everyone?
14:45:23 <danza> hi Guest21550 
14:45:24 <frontendloader> just need to update some fields in another object thats all
14:45:57 <sleblanc> frontendloader, how do you return the object? Haskell has no global state
14:46:37 <frontendloader> I don't want to return it, just change it thats all
14:47:28 <sleblanc> frontendloader, the point is that functions in Haskell have no side-effect. If you apply a function on an object, the object is not modified. You have to explicitly assign a result of a function to a new name in order to use it
14:47:29 <Lokathor> frontendloader, you have to return the new updated version and work with that from then on.
14:47:47 <Guest21550> do we have a library which provides GetT / PutT or something similar?
14:48:13 <sleblanc> frontendloader, for instance, if your function adds 1 to a field in your object, you would call that function "adds1toField :: Object -> Int -> Object" and work from the object it returns
14:48:43 <Lokathor> frontendloader, imagine the following, duplicateList :: [a] -> [a]; duplicateList xs = xs ++ xs   you can't have it be [a] -> () instead, because the (++) operator doesn't destroy the old list
14:48:43 <karl> hello, is this a good place to ask a question about building GHC?
14:48:53 <danza> Guest21550, what would that mean? GetT or PutT? can you point us to a similar library?
14:49:11 <c_wraith> karl: #ghc is better for that
14:49:14 <sleblanc> frontendloader, in a sense, when you are used to functions in C taking references to objects and modifying those in-place, in Haskell it's the opposite: all functions are, by analogy to C, pass-by-value and return-by-value
14:49:22 <Guest21550> danza: a transformer version of Get / Put
14:49:26 <Denommus> is there an alex-mode for Emacs?
14:52:05 <Guest21550> oops GetM / PutM i mean
14:53:19 <sleblanc> frontendloader, I suppose you are using data types with fields; a common pattern is this (e.g.):  add1toField thing = Thing { field = (field thing) + 1 }
14:53:43 <Lokathor> Guest21550, wouldn't those have to be specific to a monad? I'm not sure there'd be a "place" to store an arbitrary value within an arbitrary monad
14:53:58 <sleblanc> frontendloader, oops, my bad, that was add1toField thing = Thing { field = (field thing) + 1 }
14:54:05 <sleblanc> dammit! add1toField thing = thing { field = (field thing) + 1 }
14:54:56 <danza> Guest21550, i ignore what are you talking about, maybe something related to http://hackage.haskell.org/package/data-accessor-mtl-0.2.0.4/docs/Data-Accessor-Monad-MTL-State.html?
14:57:25 <varaindemian> what kind of music do you guys listen to when coding? soundcloud links are welcome :D
14:57:44 <sLite> mostly nasty metal
14:57:57 <danza> for something more relaxing https://www.youtube.com/watch?v=SdH5h0l_in0
14:58:02 <sleblanc> varaindemian, old rock stuff, like Zappa and Captain Beefheart
14:59:07 <Cale> Snarky Puppy https://www.youtube.com/watch?v=eZBlRkF0-to
14:59:15 <varaindemian> sleblanc: niceu. Now I'm listening to this https://soundcloud.com/remilambertofficial/remi-lambert-golden-vibes-l-november-tape
14:59:52 <sleblanc> danza, thanks for the link, beautiful music
15:00:37 <Guest21550> Builder is monoid, and PutM is essentially a Writer Builder, right? so PutT would be WriterT Builder
15:00:53 <varaindemian> also, that Puppy thing sounds great
15:01:02 <harwiltz> Hello all. Is there a way to tell with Haskell, or with Linux, if a certain executable has a CLI or GUI?
15:01:32 <Cale> run it?
15:01:33 <MarcelineVQ> without passing something to it?
15:01:40 <MarcelineVQ> most stuff on linux you can pass --help to
15:01:40 <sleblanc> harwiltz, in general, you can't
15:02:15 <sleblanc> harwiltz, you may guess it by checking the list of libraries it links to and spot out obvious stuff like X or GTK, but many apps are able to run in command-line without spawning a GUI (e.g. VLC)
15:02:40 <harwiltz> Ok... Because I'm making a file manager and I want the opened files to be decoupled from the terminal, but if the file opens in a CLI program like vim for example, I can't run nohup
15:02:51 <shiona> was it objdump or what that did list libraries that will dynamically load? Wouldn't that be a good bet
15:03:09 <danza> sleblanc, you are welcome, in the list of my recently liked videos you can find a lot of long albums of relaxing electronic music https://www.youtube.com/channel/UCSi2rTt8Wuaikjfqejpv7NQ ... along with some Haskell videos :D
15:04:05 <sleblanc> harwiltz, IMO this is not a concern you should address. the freedesktop standard allows the user to specify "favoriteTerminal -e /usr/bin/vim filename..." as their favorite editor
15:04:51 <sleblanc> harwiltz, otherwise, anything you might attempt to do could frustrate a user. What if my favorite editor is "to spawn a new tab in my currently running Vim editor on workspace 2 of Xmonad"? Not something you can account for
15:04:53 <harwiltz> sleblanc, yes, but I would need to know in advance if I need to open the program in a terminal or not unfortunately...
15:05:13 <sleblanc> harwiltz, just use xdg-open, it takes care of that, while considering the users' preferences
15:05:27 <harwiltz> sleblanc, xdg-open? Never heard of that. Sounds promising though
15:05:56 <sleblanc> harwiltz, it's a freedesktop standard (the folks behind many things, including systemd and X)
15:06:17 <varaindemian> why does this thing ---[x | x <- [1, 2, 3], y <- [1..x]]--- work?
15:06:42 <sleblanc> varaindemian, because List is a monad!
15:06:49 <harwiltz> sleblanc, so I would do (in haskell) something like createProcess (proc "xdg-open" [fileName])
15:06:51 <sleblanc> (I think that's the reason)
15:07:16 <Cale> sleblanc: It doesn't need to be a monad for list comprehensions to do their thing
15:07:16 <varaindemian> sleblanc: I do not understand why there is a list
15:07:18 <sleblanc> harwiltz, I believe so
15:07:28 <danza> > [x | x <- [1, 2, 3], y <- [1..x]]
15:07:29 <lambdabot>  [1,2,2,3,3,3]
15:07:36 <varaindemian> I mean the y***
15:07:37 <Cale> varaindemian: well, that's a list comprehension
15:07:51 <harwiltz> sleblanc, thanks a lot, I will try that out. Too bad I just wrote an entire list for matching different filetypes to various programs hahaha
15:07:55 <Cale> varaindemian: try replacing the x before the | with (x,y) instead, so you can see the values of y
15:08:15 <danza> > [x,y | x <- [1, 2, 3], y <- [1..x]]
15:08:17 <lambdabot>  <hint>:1:6: parse error on input ‘|’
15:08:25 <Cale> varaindemian: they're still being selected even if they don't become part of the result, and they influence the number of times each x will occur
15:08:27 <danza> > [(x,y) | x <- [1, 2, 3], y <- [1..x]]
15:08:28 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
15:08:41 <sleblanc> harwiltz, don't scrap that list, it could be your base for user preferences in their config file (override system-defined .desktop file associations)
15:08:46 <Walther> in 41
15:09:04 <Walther> /win 41, disregard
15:09:28 <varaindemian> Cale: but how excatly do they influence the result?
15:09:48 <Cale> > map fst [(x,y) | x <- [1, 2, 3], y <- [1..x]]
15:09:49 <lambdabot>  [1,2,2,3,3,3]
15:09:53 <Cale> > map fst [x | x <- [1, 2, 3], y <- [1..x]]
15:09:55 <lambdabot>      Could not deduce (Enum (b, b0))
15:09:55 <lambdabot>      from the context (Enum (b, b1), Num (b, b1))
15:09:55 <lambdabot>        bound by the inferred type for ‘e_11231’:
15:09:57 <Cale> oops
15:10:00 <Cale> > [x | x <- [1, 2, 3], y <- [1..x]]
15:10:01 <lambdabot>  [1,2,2,3,3,3]
15:10:15 <harwiltz> sleblanc, Yeah I was actually thinking that. Thanks a lot for the help. I just tested a few xdg-opens in my terminal and so far it looks pretty good. Going to try coding it soon
15:10:36 <Cale> i.e. x is selected from the list [1,2,3], then y is selected from the list [1..x], and then for each pair of x and y, the result x goes into the list
15:10:58 <shiona> harwiltz: it's not perfect, heck it's not even good, but you can start with 'objdump -T binary | grep -E "X11|wx|gtk|qt|GL"'
15:11:00 <danza> interesting, i had expected `y` to be just ignored
15:11:14 <Cale> Well, it might matter
15:11:22 <Cale> What if there's no way to select such a y?
15:11:37 <harwiltz> shiona, thats for checking if its CLI?
15:11:44 <Cale> (i.e. the list y is being selected from might be empty if the expression were a little different
15:11:45 <Cale> )
15:11:58 <harwiltz> sleblanc, do you know why xdg-open tries opening source files in firefox? And do you know how I can change that?
15:12:23 <Cale> > [x | x <- [1..10], y <- if even x then [] else [()]]
15:12:25 <lambdabot>  [1,3,5,7,9]
15:12:33 <shiona> harwiltz: if that prints something then the program most likely at least has some gui it can run
15:12:58 <varaindemian> Cale: very well explained
15:13:04 <varaindemian> thank you
15:13:04 <Cale> > [x | x <- [1..10], y <- if even x then [] else [1..x]]
15:13:05 <lambdabot>  [1,3,3,3,5,5,5,5,5,7,7,7,7,7,7,7,9,9,9,9,9,9,9,9,9]
15:13:09 <harwiltz> shiona, thats cool. I think for now I'm going to try xdg-open but if that doesn't work I'll try out your method
15:13:30 <Cale> > [y | x <- [1..10], y <- if even x then [] else [1..x]]
15:13:32 <lambdabot>  [1,1,2,3,1,2,3,4,5,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,9]
15:13:37 <shiona> ok
15:13:51 <sleblanc> harwiltz, associations are defined in /usr/share/applications and can be overridden in $HOME/.local/share/applications
15:14:04 <harwiltz> sleblanc, thanks
15:14:51 <orion> Are there any functions which can help reduce code duplication here?: http://lpaste.net/7404084036991188992
15:15:48 <sleblanc> harwiltz, for instance, firefox says it will handle 'text/html', 'application/xhtml+xml' and a bunch others. If no other app says it can handle text/html, then firefox will open it. Not sure about precedence if two apps claim they can handle the same mimetype
15:15:50 <orion> (Without writing one of course)
15:16:01 <Denommus> how do you guys create lexers in Haskell? Alex itself?
15:16:15 <harwiltz> sleblanc, thanks a lot. I'm trying to fix it now
15:16:18 <Denommus> if so, how do I match a multiline comment?
15:17:42 <sleblanc> harwiltz, "xdg-mime" can give you info on file associations: "xdg-mime query default 'text/html'" → userapp-Firefox….desktop
15:19:30 <varaindemian> Does this equation The equation xs = 1 : [x + 1 | x <- xs] define anything?
15:19:39 <harwiltz> sleblanc, cool, thanks a lot! Gonna go eat dinner now and hopefully get this worked out immediately after that. Thanks for the help. Goodnight everyone
15:19:59 <danza> > xs = 1 : [x + 1 | x <- xs]
15:20:00 <lambdabot>  <hint>:1:4: parse error on input ‘=’
15:20:10 <danza> > let xs = 1 : [x + 1 | x <- xs]
15:20:12 <lambdabot>  <no location info>:
15:20:12 <lambdabot>      not an expression: ‘let xs = 1 : [x + 1 | x <- xs]’
15:20:26 <kadoban> > let xs = 1 : [x + 1 | x <- xs] in xs
15:20:30 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:21:18 <danza> i thought that lambdabot worked as ghci
15:21:40 <kadoban> Not really.
15:22:01 <E4xoi> it works in its own way :P
15:23:05 <kadoban> ghci is some fairly insane pretend 'do' block that always confused the crap out of me. lambdabot just evaluates expressions and tries to print them. It also has special commonds to add some definitions to a holding file basically.
15:23:07 <varaindemian> kadoban: why did you add in xs?
15:23:31 <Cale> varaindemian: In order to make it a complete expression
15:23:33 <kadoban> varaindemian: Because it needs to be an expression for lambdabot to do anything with it.
15:23:40 <Cale> let <declarations> in <expression>
15:24:11 <danza> this is more elegant, but it prevents you from declaring variables, right?
15:24:22 <Cale> @let xs = 1 : [x + 1 | x <- xs]
15:24:23 <lambdabot>  Defined.
15:24:28 <danza> aha
15:24:30 <Cale> There's a special command for defining things
15:24:36 <Cale> > xs
15:24:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:24:40 <Cale> @undefine
15:24:40 <lambdabot> Undefined.
15:25:04 <kadoban> danza: It requires you to be explicit when you're declaring them, yeah.
15:25:13 <kadoban> And you have to use that special syntax.
15:32:31 <Guest21550> > undefined
15:32:33 <lambdabot>  *Exception: Prelude.undefined
15:32:54 <Guest21550> > let x = x in x
15:32:58 <lambdabot>  mueval-core: Time limit exceeded
15:33:54 <danza> in a perfect world that would not be a runtime error
15:35:59 <nchambers> > let 1 = 2 in 3 + 4
15:36:01 <lambdabot>  7
15:36:48 <Denommus> alex is so weird...
15:37:21 <Guest21550> > let 1 = 0 in 5 * 1
15:37:23 <lambdabot>  5
15:38:08 <danza> \o-
15:38:22 <danza> \o/
15:38:40 <danza> so glad you can't redefine 1  :D
15:38:46 <triliyn> Guest21550: I think that's treated as a pattern match where 1 is a constructor
15:39:23 <triliyn> And nothing ever requests that the pattern match be attempted, so it's not because of lazy evaluation
15:39:42 <Denommus> can I make a lexer in parsec?
15:39:49 <triliyn> > let Just x = (Nothing :: Maybe Int) in 5
15:39:51 <lambdabot>  5
15:40:00 <triliyn> > let Just x = (Nothing :: Maybe Int) in x
15:40:02 <lambdabot>  *Exception: <interactive>:3:5-35: Irrefutable pattern failed for pattern Just x
15:41:00 <Guest21550> > let !1 = 0 in 2
15:41:02 <lambdabot>  *Exception: <interactive>:3:5-10: Non-exhaustive patterns in pattern binding
15:42:30 <triliyn> > let one@1 = 0 in one
15:42:32 <lambdabot>  *Exception: <interactive>:3:5-13: Irrefutable pattern failed for pattern one@1
16:01:44 <koshmar> which cis194 is better to follow? (2013 , 2015 or diferent?)
16:02:31 <MarcelineVQ> I see 2013 reccomended more than 2015, I've not done 15 though so​ I can't say personally
16:09:34 <kadoban> koshmar: spring 2013. The other versions don't teach the same concepts, they skip a lot.
16:10:39 <koshmar> thanks. that is a good news for me)
16:16:39 <sLite> well
16:16:49 <sLite> ups, wrong channel
16:19:08 * hackagebot th-orphans 0.13.0 - Orphan instances for TH datatypes  https://hackage.haskell.org/package/th-orphans-0.13.0 (MichaelSloan)
16:28:07 <danza> hey, would anyone know how to run a function `a -> IO ()` within this monad https://github.com/ghcjs/ghcjs-dom/blob/master/src/GHCJS/DOM/EventM.hs#L78 ? this would imply converting from IO to EventM i guess
16:28:43 <lyxia> fmap lift
16:29:19 <danza> simply that? great! i will try it
16:29:36 <c_wraith> That's a sneaky fmap
16:30:17 <danza> :t fmap lift
16:30:18 <lambdabot> (Monad m, Functor f, MonadTrans t) => f (m a) -> f (t m a)
16:31:27 <arkeet> I don't understand the t parameter to EventM
16:31:39 <lyxia> :t (lift .) -- the same with the Functor instance you are looking for
16:31:41 <lambdabot> (Monad m, MonadTrans t) => (a -> m a1) -> a -> t m a1
16:31:55 <arkeet> anyway, lift :: IO () -> ReaderT e IO ()
16:32:28 <arkeet> or liftIO, if you prefer.
16:32:47 <c_wraith> I didn't even know you could define a type alias with unused type variables. 
16:33:19 <danza> hey thanks all, i will try to wrap my head around these :D
16:34:21 <harwiltz> sleblanc, Do you know how to set the default application for xdg-open to vim? It has no .desktop file.
16:34:42 <c_wraith> arkeet: if I'm thinking about it properly, the only thing you can do with that type variable is use it for haddocks? 
16:42:41 <danza> whew, types collide!
16:43:22 <Romefeller> Hi all
16:43:22 <danza> anyway, you put me back on track ... i will find the right combination :)
16:45:19 <danza> hi Romefeller 
16:45:30 <Romefeller> Hey danza 
16:59:07 <tobiasBora> Hello !
16:59:26 <tobiasBora> I'm trying to use webdriver haskell implementation, however I have some trouble to find the functions.
16:59:54 <tobiasBora> For example the code
17:00:03 <tobiasBora> import Test.WebDriver
17:00:11 <tobiasBora> main = do openPage "..."
17:00:23 <tobiasBora> works, but I can't find this function with Hoogle
17:00:47 <Denommus> guys
17:00:48 <tobiasBora> (And I did "hoogle data all" after install)
17:01:04 <tobiasBora> (I do "hoogle openPage" to find it)
17:01:11 <Denommus> forget it
17:01:16 <tobiasBora> Does anyone knows why I can't find it in hoogle ?
17:01:35 <tobiasBora> Denommus: you mean ?
17:02:19 <codebje> http://hackage.haskell.org/package/webdriver-0.8.0.3/docs/Test-WebDriver-Commands.html
17:02:32 <codebje> I don't understand what hoogle indexes and what it does not, but google indexes all
17:04:09 <tobiasBora> codebje: Hum indeed... I don't know what I did not to find them ! But if anyone has a solution for hoogle I would be happy to hear it !
17:04:15 <tobiasBora> codebje: Thank you !
17:04:29 <tobiasBora> By the way, this causes an other problem of comprehension for me
17:05:14 <tobiasBora> I just did "import Test.Webdriver" in my script. So why does the Test.WebDriver.Command is also loaded, but Test.WebDriver.Commands.Wait isn't ?
17:09:28 <tobiasBora> A funny think : hoogle waitWhile +webdriver gives me a result, but hoogle waitWhile doesn't ! Can I say "look everywhere" ?
17:10:58 <kadoban> tobiasBora: I don't think so. You can use another hoogle though. I like the one on stackage's website.
17:11:42 <lamefun> http://lpaste.net/4623583520218939392 - is this a good idea?
17:15:09 <Denommus> gosh
17:15:18 <Denommus> I guess megaparsec has a bug
17:15:26 <Denommus> a pretty straighforward parser is breaking
17:16:04 <bitemyapp> Denommus: report it yo :)
17:16:35 <Denommus> bitemyapp: I'm afraid of being my own mistake
17:17:16 <bitemyapp> Denommus: report it anyway
17:17:21 <Denommus> bitemyapp: this is the parser in question: https://gist.github.com/Denommus/68602a8716673fc6ef72
17:17:24 <bitemyapp> Denommus: or give me the repro and I'll reporti t.
17:17:36 <bitemyapp> I need example parsers for the book anywy.
17:17:37 <bitemyapp> anyway*
17:17:55 <Denommus> bitemyapp: when I run `runParser reserved "" "for"`, I get an error
17:18:09 <Denommus> and I expected a Right For
17:18:42 <c_wraith> Denommus: I'm not sure that's a bug
17:18:48 <bitemyapp> I'm not either.
17:18:54 <c_wraith> Denommus: if it works the same way as Parsec, that's just standard non-backtracking
17:19:06 <Denommus> ... and that's why I was afraid to report a bug
17:19:09 <Denommus> what's the problem?
17:19:39 <c_wraith> non-backtracking parsers commit to a branch as soon as they consumer any input
17:20:00 <c_wraith> So the "false" branch consumes the 'f', and then the branch is committed
17:20:21 <c_wraith> But after the 'f', the next character doesn't match.  So it's a parse failure.
17:20:31 <glguy> parseTest (string "abc" <|> string "asdf") "asdf"
17:21:59 <Denommus> c_wraith: ... so what should I do?
17:22:50 <c_wraith> Denommus: in Parsec, there's a combinator named (try) that introduces backtracking points..  If anything in the parser being tried fails, it backtracks to the state it was in when try was used, and then is considered to have failed (and usually the next alternative is tried, if there is one)
17:23:20 <Denommus> I guess megaparsec also has a try
17:23:25 <Denommus> let me... try
17:23:29 <c_wraith> hah :)
17:23:44 <tobiasBora> kadoban: Thank you ! If I could know how to do it in my local hoogle it would be great !
17:27:06 <c_wraith> I really think non-backtracking parser combinator libraries should provide sequence-matching combinators for this specific case.
17:28:15 <c_wraith> something like...  matchSequence [("foo", return Foo), "(for", someOtherParser)]
17:28:43 <c_wraith> And then it could build a prefix tree ahead of time, so that no backtracking is needed
17:29:17 <sm> I use a choice' = choice . map try
17:31:23 <sm> polyparse backtracks by default - what's that like ?
17:32:29 <Denommus> I think I'll read more on parser combinators before trying to write a lexer in one...
17:34:12 * hackagebot aur 4.0.2 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-4.0.2 (fosskers)
17:36:22 <c_wraith> sm: usually fine, but sometimes I worry about the overhead of try when what you're doing could be rewritten to a form that doesn't use try
17:37:32 <sm> c_wraith: polyparse docs say you just add some commit points when you find it's inefficient, and that this is more predictable and easier than what we do with parsec
17:39:52 <c_wraith> I mean, heck.  A list of things to match(potentially with common prefixes) can be converted to a compressed trie.  And it's not even very hard!
17:43:50 <Denommus> c_wraith: another doubt: how do I avoid "fora" parsing to [For, Name "a"]? I want it to parse [Name "fora"]
17:44:28 <mniip> Denommus, you need a tokenizer
17:44:43 <mniip> well, you can get away without one
17:44:52 <mniip> but a tokenizer could solve your problems
17:45:13 <Denommus> mniip: I'm actually trying to write a tokenizer in megaparsec
17:45:37 <mniip> megaparsec
17:45:41 <mniip> is that a new thing
17:46:24 <Denommus> mniip: I'm not sure whether it's new or not, but someone recommended me over parsec. Nevertheless, it's similar to parsec
17:47:29 <mniip> ah yes
17:47:31 <mniip> 2 months
17:49:08 <c_wraith> exponential in the worst case.  :)
17:49:31 <c_wraith> But it's really pleasant to use as long as you avoid the exponential cases.
17:53:04 <hackal> Hello, I am playing with custom datatypes. I am making a function which checks if certain constructor is used as argument and return bool http://lpaste.net/144623 how ever I can handle when the correct constructor is used but I am not sure on the other constructors.
17:53:24 <Denommus> mniip: would it be easier to just write a tokenizer in alex?
17:56:48 <Ralith> hackal: you have the right general idea, except you can't use a wildcard in the head of a pattern like that; replace (_ _ _) with _
17:57:13 <Ralith> imagine if you had multiple other data constructors which took different numbers of arguments; how would you know how many other wildcards to use?
17:59:18 <hackal> True, thank you
18:00:09 <jophish> Is there a reason why default doesn't allow defaults of kinds other than *?
18:02:24 <hackal> is there a way to get values from constructors in list comprehension? lets say [Orange "Name" 10, Orange "Name2" 12] and I need to get the int values
18:03:52 <tabemann> is Orange a constructor for a sum type or not
18:04:12 <tabemann> actually
18:04:57 <jophish> > dara Orange = Orange String Int; [i | o <- [Orange "name" 10, Orange "name2" 12], Orange _ i = o]
18:04:59 <lambdabot>  <hint>:1:13: parse error on input ‘=’
18:05:28 <c_wraith> jophish: default is about values.  only types with kind * can have values.
18:06:48 <jophish> c_wraith: so I have a dsl for a small langauge, one of the types in the language is 'Int with kind MZType. Often when writing in my dsl I run into ambiguous types along the lines of (Expression a) where a is ambiguous and has kind MZType. Putting default(Expression 'Int) doesn't seem to help
18:15:01 <bb010g> How come there's `<**> = flip <*>`, but no `<$$> = flip <$>`?
18:21:01 <Romefeller> :t flip fmap
18:21:02 <lambdabot> Functor f => f a -> (a -> b) -> f b
18:21:51 <Romefeller> :t flip
18:21:52 <lambdabot> (a -> b -> c) -> b -> a -> c
18:24:11 <mada> I'm making a remote call using Haxr and it's supposed to return a tuple, sort of (String, [(String, Value)]) where value is string or int depending on the key
18:24:29 <mada> but I can't specify its return type and it doesn't seem to be able to parse the result.
18:25:34 <hackal> Please could you help me debug non-exhaustive patterns error here http://lpaste.net/144625 I am not sure if I see why I am getting the error
18:26:54 <glguy> hackal: You only handled the Apple case, not the Orange one
18:28:00 <glguy> hackal: Also, instead of x == True, you can just write: x
18:28:20 <hackal> oh, thank you very much
18:28:43 <glguy> If you read the error message again it probably even mentioned that Orange was the unhandled case
18:28:49 <lpaste> JulianLeviston annotated “No title” with “No title (annotation)” at http://lpaste.net/144625#a144626
18:29:09 <glguy> julianleviston: No, that's not quite right
18:30:01 <glguy> either: g _ = False, or g Orange{} = False or g (Orange _ _) = False
18:30:56 <julianleviston> oh… and you can’t do g _ = False either, or can you?
18:31:08 <lpaste> JulianLeviston revised “No title (annotation)”: “No title” at http://lpaste.net/144626
18:31:10 <julianleviston> like this?
18:31:22 <glguy> No, g _ = False is fine (and is the first alternative I wrote)
18:31:38 <julianleviston> Oh sorry I didn’t notice you’d written anything.
18:31:51 <julianleviston> oh yeah, there. guh.
18:31:52 <julianleviston> sorry :)
18:34:33 <julianleviston> I’ll try to be better next time.
18:34:49 <glguy> heh, no need to apologize or whatever, just pointing it out :)
18:34:57 <emmanuel_erc> hello!
18:35:06 <julianleviston> glguy: I was apologising for myself more than anything. I need to be better.
18:35:16 <julianleviston> emmanuel_erc: hiya
18:35:53 <emmanuel_erc> I think I'm may be getting the hang of laziness in Haskell.
18:36:02 <emmanuel_erc> hi there julianleviston!!
18:37:26 <julianleviston> why is there OldList ? base-4.8.1.0:Data.OldList.genericTake
18:38:41 <ReinH> julianleviston: see the docs https://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-OldList.html
18:39:32 <julianleviston> lol @ page not found - https://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-List.html
18:39:59 <julianleviston> @ReinH thanks.
18:39:59 <lambdabot> Unknown command, try @list
18:45:33 <mada> Ah, turns out there's a Value datatype for these variable return types
18:50:45 <julianleviston> Is this a stupid way to do this? let mainRouterAndIdM = L.find (\(_, (Block {blockName = Just "MainRouter"})) -> True) allBlocks
18:51:07 <julianleviston> I feel a little dirty doing it that way because I don’t have all cases specified in the pattern match.
18:52:35 <julianleviston> also the True feels kind of redundant. Is there a better way?
18:56:44 <tommd> julianleviston: any ((==) Just "MainRouter" . blockName . snd) ?
18:57:37 <tommd> julianleviston: Oh, is `blockName` partial?
18:57:51 <julianleviston> tommd: um… I don’t know what that means.
18:57:55 <tommd> Because `Block` is one of many constructors, that's what you're talking about, right?
18:58:05 <julianleviston> tommd: blockName isn’t the only field in the Block DT
18:58:16 <julianleviston> No they’re only blocks in that List.
18:58:28 <julianleviston> :t any
18:58:29 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
18:59:03 <tommd> julianleviston: A parital function is one that is not defined for all values in its domain.
18:59:08 <julianleviston> my function returns a Maybe Block.
18:59:13 <julianleviston> tommd: yes I know.
18:59:16 <tommd> julianleviston: for example, 'head' will throw an error on the empty list.
18:59:23 <julianleviston> tommd: yes. I know.
18:59:45 <tommd> So when I asked if `blockName` is partial I was asking if there are any values of the same type that do not havea `blockName` field.
18:59:46 <julianleviston> tommd: blockName is an automatically generated field accessor function of the Block constructor.
19:00:04 <julianleviston> tommd: I don’t understand that.
19:00:38 <tommd> julianleviston: data Foo = Block { blockName :: String ... } | OtherConstructor { otherFields :: String }
19:00:47 <julianleviston> tommd: oh… are you asking if the data type is a sum datatype some of which don’t have that field?
19:00:48 <tommd> Are there "OtehrConstructor"s?
19:00:51 <julianleviston> tommd: right. Sorry.
19:00:55 <julianleviston> tommd: no. It’s total then.
19:01:07 <tommd> julianleviston: Great, then the function I presented should be total as well.
19:01:12 <julianleviston> tommd: it’s just a product datatype.
19:01:17 <tommd> OK.
19:01:20 <julianleviston> tommd: yes but it returns a Bool.
19:01:51 <julianleviston> tommd: mine returns a Maybe Block.
19:01:53 <tommd> Do`h, I must have totally missed what you were going for, sorry.
19:02:01 <julianleviston> tommd: let me give you the type.
19:02:48 <tommd> I see.  Nothing wrong with your solution.
19:02:51 <julianleviston> tommd: L.find (\(_, (Block {blockName = Just "MainRouter"})) -> True) :: Foldable t => t (t1, Block) -> Maybe (t1, Block)
19:03:16 <tommd> I usually use filter and listToMaybe, because I find it readable and for some reason dislike `find` - but that's just be being weird.
19:03:18 <julianleviston> tommd: ok… just feels ugly to me. Like… there should be a way to just pass a “match” as a first class thing
19:03:32 <tommd> findBy?
19:03:40 <julianleviston> :t findBy
19:03:41 <lambdabot>     Not in scope: ‘findBy’
19:03:41 <lambdabot>     Perhaps you meant one of these:
19:03:41 <lambdabot>       ‘findOf’ (imported from Control.Lens),
19:04:00 <tommd> No, just saying that notionally that is what you desire.
19:04:13 <julianleviston> tommd: um… yeah I spose!
19:04:20 <KaneTW> :t lookupBy
19:04:21 <lambdabot>     Not in scope: ‘lookupBy’
19:04:21 <lambdabot>     Perhaps you meant one of these:
19:04:21 <lambdabot>       ‘lookup’ (imported from Data.List),
19:05:54 <julianleviston> I guess this is better: let mainRouterAndIdM = L.find (\(_, b) -> blockName b == Just "MainRouter") allBlocks
19:06:19 <tommd> julianleviston: find ((==) Just "MainRouter" . blockName . snd) is probably the best you will get.  ANything more is going to have to have built-in knowledge of your type.
19:06:24 <tommd> I just don't see it existing.
19:06:57 <julianleviston> tommd: that find is really ugly.
19:07:06 <julianleviston> tommd: obviously only to my aesthetic.
19:07:47 <julianleviston> tommd: thanks for your help!
19:08:04 <tommd> julianleviston: Helper functions make things more readable.  isNamed s = maybe False (s ==) . blockName ; find (isNamed "MainRouter" . snd)
19:09:26 <julianleviston> Makes me sad Haskell has no “ad hoc modules”
19:09:37 <julianleviston> I hate that.
19:10:48 <sleblanc> julianleviston, what's a ad-hoc module ?
19:10:50 <julianleviston> Use case is “having 3 helper functions that are identically named that have different contexts”. You end up polluting your names… which works out kind of amusingly. blockIsNamed customerIsNamed etc.
19:11:08 <julianleviston> sleblanc: the ability to create a module inside another module scoped within a section of the file?
19:11:33 <sleblanc> Oh, I get it
19:11:35 <julianleviston> sleblanc: otherwise I just have to create another separate file (even though it isn’t useful outside of the module I’m in)
19:11:47 <julianleviston> it’s not really a limitation of Haskell. It’s a limitation of GHC
19:12:31 <julianleviston> That one feature would make all my haskell an order nicer.
19:14:52 <sleblanc> julianleviston, there could be a build tool that would split the main file into their respective modules at build time; it could hook itself to cabal. I am not sure how complicated that would be, though
19:15:09 <sleblanc> julianleviston, I am thinking of how c2hs processes "chs" files
19:15:09 <julianleviston> sleblanc: yeah, it’s all good. Haskell is already amazingly awesome :)
19:16:15 <sleblanc> Similar to how there are "lhs" files (literate Haskell), there could be "mmhs" files (multi-module Haskell)
19:19:29 <Bruuuuno> what is the overhead of implementing a typeclass in a datatype?
19:20:23 <tommd> julianleviston: You don't have to polute the namespace though.  There are where blocks and explicit module exports.  I know it doesn't make up for not having Coq style modules though :-(
19:20:26 <julianleviston> sleblanc: or it could just work it out ;-)
19:20:35 <sleblanc> Bruuuuno, I don't know, but you could look at the Haskell Core output to see what it adds
19:21:16 <julianleviston> tommd: yeah, but where blocks don’t span multiple potentaiily discontiguous functions...
19:21:25 <sleblanc> Bruuuuno, I am generalizing, but most of the Haskell features only add compile-time overhead, not runtime, as I believe that most type information is erased in the final executable
19:21:27 <julianleviston> tommd: I love where blocks :) but they’re really only function-scope.
19:22:17 <julianleviston> tommd: I don’t know how explicit module exports would help… and I don’t really know what Coq-style modules are.
19:22:31 <julianleviston> tommd: I really want Haskell’s Modules to just be functions.
19:22:45 <sleblanc> In general, does adding strictness to a Haskell program give more hints to the compiler regarding optimizations, inlining and specialization of functions?
19:23:05 <tommd> module Foo (funciton1, type1, ...) where -- that is an explicit export list, julianleviston
19:23:27 <tommd> So importing the Foo module will only bring into scope those symbols explicitly exported (at most)
19:24:40 <sleblanc> I suppose that my question could be phrased otherwise: can GHC automatically detect places where strictness will give additional performance at runtime? If not, is there a mechanism akin to profiling actual execution of the program (in a two-pass compilation process) that can give such hints to the compiler?
19:25:54 <dfeuer> Is it just me, or is Yesod kind of ridiculously complicated, with somewhat byzantine documentation?
19:26:09 <julianleviston> dfeuer: I agree with that.
19:26:23 <julianleviston> dfeuer: it’s the price you pay for things being “simpler at the beginning”.
19:26:23 <dfeuer> Hrmmm.
19:26:41 <dfeuer> julianleviston, I'm not even seeing the beginning where things are simpler.
19:26:44 <lethjakman-l> So...how does a haskell know to separate the lense functions?
19:26:49 <lethjakman-l> Like ^._2._2.to
19:27:11 <julianleviston> tommd: yeah, I didn’t really know that helps that particular predicament, but that’s fine (the exports - I knew what they did).
19:27:35 <dfeuer> lethjakman-l, ^. and . are just operators, like + and *.
19:28:03 <dfeuer> foo^._2._2.to is the same as  foo ^. _2 . _2 . to
19:28:24 <lethjakman-l> dfeuer: does ^. have a name?
19:28:27 <lethjakman-l> That makes sense!
19:28:31 <dfeuer> lethjakman-l, no idea, sorry.
19:28:36 <lethjakman-l> That's ok. 
19:28:41 <lethjakman-l> Does it mean something specific in normal haskell?
19:28:49 <sleblanc> lethjakman-l, wow, that's some unreadable line of code
19:29:07 <lethjakman-l> sleblanc: It's in the lens readme. 
19:29:07 <dfeuer> lethjakman-l, actually, it probably does have a name... there's a non-operator version that has some name or other...
19:29:09 <Ralith> dfeuer: isn't ^. view?
19:29:10 <lethjakman-l> Don't blame me!
19:29:33 <lethjakman-l> That's the thing I can't stand. Finding names for these weird symbol combinations. 
19:29:33 <dfeuer> Ralith, I know very little about lens. It has a rather large vocabulary and quite a lot of types...
19:29:37 <lethjakman-l> I guess it's the same thing as with math though. 
19:29:50 <julianleviston> lethjakman-l:  I used to hate the names thing too
19:29:50 <sleblanc> lethjakman-l, the main thing GHC has to take care of regarding the period is for when you use module names, so if you put spaces around dots it makes the intent clear whether you want composition or just module namespacing
19:30:04 <julianleviston> lethjakman-l:  but… don’t worry about it. When are you ever going to vocalise it?
19:30:09 <Ralith> dfeuer: it is. Also, lens is awesome, use it.
19:30:20 <julianleviston> lethjakman-l:  ^. you can just say “carat-dot” for, right? That’s obviously what it’s called.
19:30:30 <julianleviston> just like ~. can be called “tilde-dot"
19:30:35 <dfeuer> Ralith, I've been learning bits and pieces on and off. Some aspects are pretty hard to grok.
19:30:35 <lethjakman-l> julianleviston: Use that hash dot sqliggly operator please. 
19:30:46 <lethjakman-l> I miss the spermy operator from rails...
19:30:51 <lethjakman-l> ~>
19:30:58 <julianleviston> lethjakman-l: what is that for?
19:31:07 <julianleviston> lethjakman-l: I think Haskell has that somewhere btw.
19:31:09 <sleblanc> lethjakman-l, or the C "goes to" operator (-->)
19:31:09 <lethjakman-l> sleblanc: I agree, that would be more clear
19:31:23 <lethjakman-l> julianleviston: versioning in bundler. 
19:31:38 <lethjakman-l> It tells you "about this version"
19:31:45 <julianleviston> lethjakman-l: oh… right. I thought you meant in actual rails, not bundler.
19:31:46 <lethjakman-l> It can float up on the minor version, but not down. 
19:31:56 <lethjakman-l> julianleviston: oh, no. 
19:31:57 <sleblanc> for (int i = 10; i --> 0; ) { … }
19:32:02 <julianleviston> :t (~>)
19:32:03 <lambdabot>     Not in scope: ‘~>’
19:32:03 <lambdabot>     Perhaps you meant one of these:
19:32:03 <lambdabot>       data constructor ‘Seq.:>’ (imported from Data.Sequence),
19:32:10 <lethjakman-l> lol
19:32:21 <julianleviston> hm I was sure we had that.
19:32:28 <julianleviston> but hoogle doesn’t have a clue.
19:32:33 <lethjakman-l> We need it. 
19:32:41 <julianleviston> lethjakman-l: to mean what? define it.
19:32:57 <lethjakman-l> julianleviston: I'm just saying we need the spermy operator. 
19:33:01 <lethjakman-l> It needs to duplicate things. 
19:33:30 <julianleviston> lethjakman-l: we only have the lens operators becaues EK defined them ;-) 
19:34:03 <lethjakman-l> I guess I could probably define something...
19:37:21 <julianleviston> OMG post foldable traversable, this is mapM’s sig: mapM :: (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
19:37:23 <julianleviston> LOL!
19:37:37 <julianleviston> I mean obviously it’s that… but...
19:38:02 <julianleviston> Is there a quick way I can specialise the type to list?
19:38:13 <julianleviston> so I can see the type signature for MapM where t is List ?
19:39:38 <Ralith> sed 's/t/List/g'
19:39:41 <orion> I am encrypting and decrypting data received on a socket. Under what conditions will I want to use lazy bytestrings for the unsecured data, and when will I want strict bytestring?
19:39:53 <julianleviston> Ralith: damn.
19:40:46 <Bruuuuno> okay thank sleblanc
19:40:50 <julianleviston> Ralith: It’s Monad m => (a -> m b) -> [a] -> m [b] 
19:41:01 <julianleviston> Ralith: I just have to do it in my head, is all. Oh well.
19:41:32 <Ralith> does that pose a problem
19:41:33 <julianleviston> … and everyone knows head is not total! (guh haskell jokes)
19:42:24 <julianleviston> Ralith: it’s not a big problem at all - it’s a super tiny problem, but it *IS* a problem.
19:42:55 <sleblanc> Bruuuuno, don't hesitate to ask your question again in about 12 or so hours, so that a bigger audience sees it (timezones)
19:43:22 <julianleviston> sleblanc: are there more people here in 12 hours?
19:43:44 <Bruuuuno> haha I'm at work in 12 hours so I can't really be there lol
19:44:59 <sleblanc> Bruuuuno, aw, what a shame (no offense :-) )
19:45:37 <Bruuuuno> I'm trying to convert my team to haskell, but they seems not really into it lol
19:45:43 <sleblanc> julianleviston, the americans will wake up
19:45:53 <sleblanc> (most of)
19:48:32 <lethjakman-l> sleblanc: is there a lot of haskell over seas?
19:48:39 <lethjakman-l> I keep hearing people in podcasts talking about it. 
19:49:03 <sleblanc> lethjakman-l, I'm in Canada. I don't hear much about Haskell around me though, so I can only provide a single opinion
19:49:13 <lethjakman-l> sleblanc: Fair enough. 
19:49:16 <Romefeller> im from Brazil
19:49:17 <lethjakman-l> Do you like canada?
19:49:22 <lethjakman-l> Romefeller: how does haskell look there?
19:49:27 <sleblanc> It's good
19:49:28 <lethjakman-l> I'm seeing it pick up in conferences and stuff here. 
19:49:38 <Romefeller> lethjakman-l: little
19:49:46 <lethjakman-l> People are starting to know what it is.
19:49:59 <sleblanc> lethjakman-l, I'm self-employed, and I use Haskell cuz' I like it
19:50:07 <lethjakman-l> sleblanc: ahhh, contractor?
19:50:16 <lethjakman-l> Are you having a hard time convincing your clients that haskell is a good option
19:50:18 <Romefeller> lethjakman-l: Im teaching in my community college. My students like, i guess.
19:50:18 <lethjakman-l> ?
19:50:24 <sleblanc> lethjakman-l, could say that. I also work on my own stuff
19:50:26 <lethjakman-l> Romefeller: Ahhh, very cool
19:50:30 <lethjakman-l> sleblanc: nice. 
19:50:48 <lethjakman-l> sleblanc: I've been thinking about going off on my own. 
19:51:00 <lethjakman-l> Yesod seems like a good web framework. 
19:51:03 <lethjakman-l> Less testing than rails. 
19:51:12 <julianleviston> lethjakman-l: what?
19:51:24 <lethjakman-l> julianleviston: What's the question?
19:51:26 <sleblanc> lethjakman-l, my clients don't care much for the technology powering what I do. They get an end-product and the source, but the source is out of principle, in a "here's how I don't plan on f***ing you in the ***"
19:51:30 <Romefeller> lethjakman-l: Im doing websites with Yesod. I have one client. He dont care about programming languages.
19:51:39 <Romefeller> sleblanc: exactly
19:51:50 <lethjakman-l> sleblanc: what's your explination? 
19:52:05 <sleblanc> lethjakman-l, on why I use Haskell? Clients don't ask, so I don't tell.
19:52:11 <lethjakman-l> These people don't care about if you disappear?
19:52:19 <Romefeller> sleblanc: Yeah
19:52:22 <sleblanc> lethjakman-l, hang on, what?
19:52:35 <lethjakman-l> if you disappear, they have to find someone to maintain the project. 
19:52:35 <Romefeller> lethjakman-l: what country do you live?
19:52:40 <lethjakman-l> Romefeller: US. 
19:52:46 <julianleviston> sleblanc: he’s talking about the “can you find haskell programmers” problem.
19:52:55 <sleblanc> lethjakman-l, that's right, but I believe it's a fallacy
19:52:55 <lethjakman-l> julianleviston: Yes, sorry. 
19:52:57 <lethjakman-l> I'm distracted. 
19:53:10 <lethjakman-l> sleblanc: I don't know if it is or it isn't. That's what I'm curious about. 
19:53:19 <Romefeller> Im trying to train people
19:53:19 <sleblanc> namely that people who pick up on your work will almost always start from scratch, no matter which language you did it in
19:53:37 <sleblanc> IMO documentation matters FAR MORE than the actual code
19:53:40 <Romefeller> People get scared about math. But they love type safety
19:53:43 <lethjakman-l> sleblanc: That does happen a lot. 
19:53:51 <sleblanc> code should be a reflection of the documentation
19:53:57 <lethjakman-l> Romefeller: I want a book that starts with haskell and teaches you math within haskell...
19:54:00 <julianleviston> Romefeller: why *do* people get scared of math?
19:54:14 <lethjakman-l> julianleviston: bad teaching.
19:54:17 <Romefeller> julianleviston: Functor stuff scared them
19:54:27 <julianleviston> lethjakman-l: Haskell itself does that.
19:54:32 <lethjakman-l> julianleviston: It causes a lot of anxiety, which reacts in similar places in the brain as pain. 
19:54:45 <lethjakman-l> julianleviston: I've noticed I've learned more math from it, but I want to take it a step farther. 
19:54:50 <julianleviston> I don’t see why it makes people scared.
19:54:53 <lethjakman-l> Haskell has made me consider getting a degree in mathematics.
19:55:09 <sleblanc> I have to admit that I did not use Haskell in many projects already, since I am only starting, but Python isn't necessarily the most popular language around here, (C# and Java are; "enterprise, lol") but I keep using it and my clients don't seem to care
19:55:18 <julianleviston> lethjakman-l: accreditation has little to do with skill
19:55:19 <lethjakman-l> julianleviston: throw a bunch of symbols at people and say "this will affect the rest of your life" and it will tend to scare them. 
19:55:23 <lethjakman-l> Especially if it doesn't come naturally. 
19:55:35 <sleblanc> lethjakman-l, you have a point
19:55:36 <Romefeller> julianleviston: We have a weak math courses here
19:55:42 <lethjakman-l> julianleviston: Well. That's a part of the debate in my head. I've been going through Khan Academy. I just know I need to know more math. 
19:55:49 <sleblanc> When I picked up Haskell, at first, I was like "omg, categories are cool"
19:55:50 <julianleviston> lethjakman-l: sounds to me like the problem is lack of self-reliance at its core, then.
19:56:07 <julianleviston> lethjakman-l: khan academie is pretty darn rudimentary.
19:56:42 <Romefeller> My math degree helped me to go on into haskell smoothly
19:56:47 <lethjakman-l> julianleviston:Do you have a better recommendation?
19:56:49 <sleblanc> I keep asking myself why schools don't focus more on new mathematical concepts. if kids can't add numbers, but know about monomorphisms and monads, so be it!
19:57:01 <sleblanc> (tongue-in-cheek)
19:57:07 <julianleviston> lethjakman-l: nope.
19:57:11 <lethjakman-l> Lol. 
19:57:24 <lethjakman-l> Well I have that, and books. I just know I need to learn more, so I'm doing it how I know how to. 
19:58:11 <sleblanc> I picked up Steve Awodey's book on category theory. I don't understand most of what's written in it, yet, but I know I'll pick it up in a few months and understand most of it in an instant.
19:58:23 <sleblanc> (most is an exaggeration)
19:58:24 <lethjakman-l> sleblanc: I'll have to take a look at it. 
19:58:45 <Romefeller> sleblanc: You dont need to be a pro in category theory to advance in haskell
19:58:51 <sleblanc> lethjakman-l, I'm not much of a math buff, so I can't tell you if it's wrong or right, but it's very well written and high quality
19:59:01 <lethjakman-l> sleblanc: I was at a conference a few months ago and a speaker was talking about mentoring. 
19:59:11 <lethjakman-l> ANd I asked the question "Can you mentor more than one person at a time"
19:59:18 <lethjakman-l> and the answer was a resounding "No!"
19:59:23 <sleblanc> Romefeller, of course, I know this already! But Haskell got me started on category theory and I am since fascinated by it
19:59:32 <lethjakman-l> But...that's how our school systems work. 
19:59:41 <shanemikel> Because schools do everything they can to get people to hate math.  essentially spending your first decade and a half on basic algebra and arithmetic, what other goal could there be?
19:59:43 <Romefeller> sleblanc: Thats true
19:59:47 <lethjakman-l> People come from different backgrounds, with different natural strengths. 
19:59:50 <lethjakman-l> It doesn't work...
20:00:04 <lethjakman-l> sleblanc: I agree. 
20:00:08 <sleblanc> lethjakman-l, I'd say it's not a categorical "no" (hehe, categories), but the more students you have, the harder it is to keep track of everyone, I'll give this to you
20:00:28 <julianleviston> I think the worst thing about education is when it’s pulled away from pragmatics.
20:00:34 <lethjakman-l> Well, you can't get great results I guess. 
20:00:35 <Romefeller> I have a lot of students. Some don't know math basics, such associative law
20:00:46 <Romefeller> I spent a whole hour talking about associativity
20:00:56 <sleblanc> I mean, if you compare it to piano lessons, a teacher might have many pupils, but if this is the case, I agree that none of them will end up becoming the new piano prodige if that student stays with this mentor
20:00:57 <Romefeller> and another about composition
20:01:00 <lethjakman-l> Romefeller: Oh man...
20:01:24 <Romefeller> Programming in Haskell is hard, teachinh is a lot harder
20:01:29 <Romefeller> teaching*
20:01:37 <julianleviston> meh.
20:01:47 <sleblanc> You know, I'm the kind of person that would argue that teaching maths based on base-10 is counter-productive ;-)
20:02:23 <lethjakman-l> sleblanc: I'm curious about that...
20:02:45 <shanemikel> i honestly think it's better to move forward than get stuck in a rut.  it just makes it hard on  people that might be inclined to be interested
20:03:45 <Romefeller> They liked Yesod (beacuse its more practical). 
20:03:48 <sleblanc> lethjakman-l, to me, binary is the universal base, and we should get fluent with it. This includes natural powers of it, such as base-16 (hexadecimal), and even base-8 (octal), but surprisingly it does not include base-10 (decimal)
20:03:54 <Romefeller> Types aside of course
20:04:17 <julianleviston> Romefeller: I disagree that programming is hard in Haskell… same with teaching.
20:04:18 <lethjakman-l> sleblanc: you know why we count by 10, right?
20:04:18 * hackagebot servant-swagger 0.0.0.1 - Swagger  https://hackage.haskell.org/package/servant-swagger-0.0.0.1 (DavidJohnson)
20:04:22 <sleblanc> I think that the reason that decimal is prevalent is mostly due to the fact that we have ten fingers, but that is kind of arbitrary
20:04:31 <julianleviston> Romefeller: mind you I probably haven’t done enough of either to have any valuable opinion.
20:04:43 <lethjakman-l> sleblanc: that's exactly it. 
20:04:43 <shanemikel> I'm pretty sure there is more to it.. but I can't think of it right now
20:04:51 <Romefeller> julianleviston: I teach haskell. 
20:04:59 <sleblanc> lethjakman-l, if we had to communicate with aliens from another galaxy, what number system do you think we would use?
20:05:13 <sleblanc> Romefeller, thank you!
20:05:14 <julianleviston> Romefeller: I know.
20:05:23 <lethjakman-l> sleblanc: it may not even be a number system in the sense that we currently understand. 
20:05:32 <lethjakman-l> I'm a strong believer that we may be wrong with everything, and just haven't figured it out yet. 
20:05:55 <lethjakman-l> Everything we have is a "close enough". Let's keep working with it until we figure out something better. 
20:06:01 <Romefeller> julianleviston: Im saying hard in comparsion with PHP lol
20:06:10 <Romefeller> or other languages
20:06:11 <julianleviston> lethjakman-l: we absolutely are. For starters, we base everything on True/False.
20:06:18 <julianleviston> Romefeller: yeah, I don’t agree with that.
20:06:24 <shanemikel> well, another reason we don't use base 2, is because it takes up to much space to writer
20:06:26 <Romefeller> julianleviston: why?
20:06:52 <julianleviston> Romefeller: numerous reasons. The first one is the concept of “time” that is baked into imperative languages.
20:07:16 <julianleviston> Romefeller: all imperative languages have an implicit context of sequential, exclusively-locked computation.
20:07:39 <sleblanc> lethjakman-l, for once, I think that the decimal system is something we got wrong from the start, but stayed with it in some sort of "well, we have so much knowledge based on that already"
20:07:50 <julianleviston> Romefeller: and it’s not the way “the universe” works around us… so it’s very unnatural. You have to learn that to use PHP / C / Java / C#, ruby / smalltalk
20:08:20 <julianleviston> Romefeller: it’s also no longer an accurate picture of the way computers work!
20:08:45 <sleblanc> Romefeller, well, when you think about it, if you try to define global state in mathematical terms, it gets so much damn complicated, when compared to Haskell that forbids state at all
20:08:49 <Romefeller> julianleviston: Looking in that way
20:09:04 <lethjakman-l> sleblanc: I agree, but I'm not sure that 8 is the right number. That may just work well with the current computer systems we have. 
20:09:09 <julianleviston> Romefeller: it’s only “simpler” conceptually because traditonally we personify computers and say ‘the computer now adds this number to that number” etc.
20:09:21 <Romefeller> sleblanc: I dont like state. Thats why im here
20:09:54 <sleblanc> lethjakman-l, IMO "2" is the universal system, but "8" and "16" are the most convenient, because they happen to be powers of 2 and are relatively easy to work with
20:09:56 <lethjakman-l> Romefeller: Oh god...mutating state. It's the worst part of my job. 
20:10:23 <sleblanc> lethjakman-l, relatively easy due to their size. "4" would be too small, "32" too big.
20:10:28 <tabemann> what I do at work is all about state state and more state
20:10:31 <Romefeller> julianleviston: I gave a talk about haskell here. The crowd was the newcomers (they are into programming 101, imperative of course)
20:10:32 <lethjakman-l> sleblanc: fair enough. I've heard quantum computing has fuzzy inbetween numbers though. 
20:10:36 <lethjakman-l> How does it work then?
20:10:38 <julianleviston> sleblanc: “2” is only the universal system if you’re talking about logical things.
20:11:03 <lethjakman-l> yeah...and analog. 
20:11:03 <Romefeller> julianleviston: I solved a exam question of programming 101 with haskell with two lines
20:11:20 <Romefeller> julianleviston: They loved
20:11:26 <lethjakman-l> Romefeller: You should make a slide. That could be interesting. to show around the office. 
20:11:49 <Romefeller> julianleviston: But teaching it, in a classe is no easy task
20:11:53 <Romefeller> class
20:12:03 <lethjakman-l> I think haskell would be easier as a newcomer, no?
20:12:08 <sleblanc> julianleviston, I am making assumptions, due to being neither a physicist nor a mathematician, but most civilizations out there that are advanced enough will have at some point and time in their existence, devised a computer based out of logic gates and binary components, hence the base-2 reference. It's just conjecture though
20:12:14 <julianleviston> Romefeller: that has nothing to do with Teaching, though, really… does it?
20:12:15 <Romefeller> lethjakman-l: maybe
20:12:19 <lethjakman-l> I think it's harder to me because I'm so used to the concepts from languages like Ruby and PHP. 
20:12:33 <Romefeller> julianleviston: Maybe im a bad teacher lol
20:12:48 <julianleviston> Romefeller: no, classroom teaching is idiotic, is all.
20:12:54 <shanemikel> php is a language?
20:13:00 <lethjakman-l> shanemikel: shhh
20:13:06 <julianleviston> shanemikel: what would you call it?
20:13:08 <Romefeller> shanemikel: for non-programmers yes
20:13:25 <lethjakman-l> It's actually not the worst language. 
20:13:32 <julianleviston> sleblanc: well, any “civilisation” looking through base-2 glasses actually can’t see anything outside of base-2… fascinatingly.
20:13:32 <lethjakman-l> It has some idiotic syntax, but once you're past that...it's ok. 
20:13:39 <lethjakman-l> I'd rather write PHP than Java most of the time. 
20:13:44 <shanemikel> hieroglyphic maybe
20:13:52 <sleblanc> julianleviston, thank you for the perspective :-)
20:14:06 <julianleviston> sleblanc: sorry :)
20:14:09 <lethjakman-l> I suppose it's the same perspective business people would have of us. 
20:14:17 <Romefeller> you guys are from US?
20:14:21 <julianleviston> AUS
20:14:23 <lethjakman-l> base 2 looks stupid to non-programmers because they don't have to understand the same concepts. 
20:14:26 <lethjakman-l> US. 
20:14:26 <sleblanc> shanemikel, oh you
20:14:36 <lethjakman-l> ASL ;)
20:14:39 <julianleviston> lol
20:14:41 <Romefeller> julianleviston: my dream is visit AUS. 
20:14:53 <lethjakman-l> julianleviston: do you see some crazy spiders?
20:14:59 <julianleviston> lethjakman-l:  yes.
20:15:00 <lethjakman-l> Also, how do you feel about squirrels?
20:15:09 <julianleviston> we don’t have them.
20:15:20 <lethjakman-l> I know, are they weird to you?
20:15:24 <julianleviston> no
20:15:24 <sleblanc> lethjakman-l, yet, I was explaining to a bunch of 12-year olds how to do math in binary, and they got it in a few minutes. Try that with something like base-17; I bet you'll get a headache
20:15:26 <lethjakman-l> Another question. 
20:15:27 <julianleviston> they’re squirrels.
20:15:32 <lethjakman-l> Do you ever ride in a kangaroo's pocket?
20:15:49 <Romefeller> sleblanc: I have students that dont understand it. Sadly.
20:15:51 <julianleviston> lethjakman-l:  given that they’re about 30 cms across, no.
20:15:57 <julianleviston> lethjakman-l: we have these tho: https://en.wikipedia.org/wiki/Common_brushtail_possum
20:15:58 <sleblanc> Romefeller, :-(
20:16:14 <lethjakman-l> it's so cute!
20:16:19 <lethjakman-l> Can you ship me one?
20:16:22 <julianleviston> but deadly.
20:16:31 <lethjakman-l> julianleviston: Good guard animals?
20:16:32 <julianleviston> well, they can scratch you really deeply.
20:16:38 <julianleviston> lethjakman-l: they’re wild.
20:16:41 <lethjakman-l> Don't you have those aye aye things?
20:16:53 <julianleviston> lethjakman-l:  there are two that regularly come and eat our cat’s food… so annoying.
20:17:03 <shanemikel> base-2 occurs naturally in many ways, but it's not the only base that does.. sex is quadratic, for instance, obviously circuts.. but base-3 could be the magic system for other reasons
20:17:13 <lethjakman-l> sleblanc: I've heard base 9 is actually pretty good. 
20:17:17 <lethjakman-l> I haven't tried it though. 
20:17:40 <lethjakman-l> Maybe you need to change systems for each problem. 
20:17:43 <lethjakman-l> julianleviston: ugh...
20:17:51 <julianleviston> I wonder what base-prime would be like.
20:18:02 <julianleviston> clearly that makes no sense.
20:18:25 <lethjakman-l> julianleviston: that we know of...
20:18:35 <lethjakman-l> dun dun dunnn
20:18:43 <julianleviston> lethjakman-l: (to a true/false system, it definitely makes no sense)
20:18:47 <sleblanc> lethjakman-l, interesting!
20:19:04 <lethjakman-l> julianleviston: I can accept that. 
20:19:12 <julianleviston> lethjakman-l: I also can.
20:19:26 <lethjakman-l> Until you throw maybe in there ;)
20:19:34 <shanemikel> this room is chatty tonight
20:19:37 <lethjakman-l> it is. 
20:19:38 <julianleviston> sorry.
20:19:41 <julianleviston> I’ll be quiet
20:19:42 <lethjakman-l> I like it. 
20:20:39 <lethjakman-l> Anyway, off to be productive
20:20:41 <lethjakman-l> Thank you people!
20:20:42 <sleblanc> lethjakman-l, also, we keep thinking in binary and its multiples of two, (2, 4, 8, 16…)  but what about the multiples of three?
20:20:44 <Romefeller> what degree you guys have?
20:21:00 <lethjakman-l> Romefeller: None
20:21:11 <sleblanc> Romefeller, almost-bachelor in electronics engineering (dropped out)
20:21:20 <Romefeller> nice.
20:21:31 <tabemann> compsci
20:21:35 <Romefeller> too expensive right?
20:21:38 <sleblanc> I probably have an honorary degree in reading Wikipedia, though
20:21:46 <Romefeller> sleblanc: hahaha
20:21:59 <sleblanc> Romefeller, no, actually education in Canada (Québec) isn't that pricey, when compared to the rest of the world
20:22:01 <eacameron> How do you insert an HTML comment tag with Lucid?
20:22:31 <Romefeller> sleblanc: Brazil has a lot of free degrees
20:22:39 <Romefeller> I have two
20:22:46 <Romefeller> and i have spent 0
20:23:11 <sleblanc> To me it was a mix of the student community turning me off and the fact that I constantly thought there was so much more pertinent/useful/whatever stuff to do than going to school. 
20:23:43 <sleblanc> Romefeller, here, society tends to shun or disapprove of people "spending too much time (years) at school"
20:23:55 <julianleviston> eacameron: I’m not sure you can?
20:23:55 <Romefeller> sleblanc: why?
20:24:15 <sleblanc> they call them "pelleteux de nuages" (roughly: people who shovel clouds)
20:24:32 <tabemann> here in the US getting a degree is practically mandatory if you plan on having a job above mcdonald's
20:24:49 <sleblanc> Romefeller, I'd say the closest you get to this is "an idealist, not a realist"
20:24:59 <Romefeller> sleblanc: Brazlians, in general, dont like to work, so... 
20:25:05 <eacameron> julianleviston: :( I need it for adding IE support
20:25:30 <julianleviston> eacameron: I wonder if you couldn’t add your own
20:26:04 <Romefeller> sleblanc: Do you work with programming?
20:26:08 <julianleviston> eacameron: there seems to be a function called makeElementNoEnd
20:26:16 <julianleviston> eacameron: https://github.com/chrisdone/lucid/blob/master/src/Lucid/Html5.hs
20:26:25 <julianleviston> eacameron: check out how they define DOCTYPE, line 18.
20:26:44 <eacameron> julianleviston: Good call; also https://github.com/chrisdone/lucid/issues/27
20:27:03 <julianleviston> eacameron: oh that’s the author of Scotty.
20:27:39 <julianleviston> eacameron: I guess the syntax is a bit different than other tags. Hm.
20:28:43 <julianleviston> eacameron: is it better than Blaze?
20:29:03 <sleblanc> Romefeller, yup. I mostly set up automated systems and stuff that don't require degrees in maths
20:29:19 <julianleviston> eacameron: I’ll need ot use something similar to it quite soon, I think… 
20:29:21 <eacameron> julianleviston: chrisdone has a post about it; unless blaze has changed significantly since he wrote lucid, I'm going with "yes"
20:30:51 <julianleviston> eacameron: I wonder if it integrates at all with reflex / reflex-dom, or if that’s a separate issue entirely.
20:31:09 <julianleviston> it seems like reinventing the wheel a bit to not use the same model of tagging.
20:32:02 <eacameron> julianleviston: Ha, I hope to use Reflex-dom as well. Reflex-dom is doing a ton more than Lucid, so I'm not surprised the designs aren't terribly similar.
20:33:03 <julianleviston> eacameron:  yeah, but I’m actually going to need to use it as well - but am going to want a common / translatable model of tagging.
20:33:10 <julianleviston> I really like snap’s take on templating.
20:33:18 <julianleviston> tho it can be complex to think about.
20:34:34 <eacameron> julianleviston: I'm fairly confident that reflex-dom and lucid play very different roles in an app. I suppose you could compile lucid-generated pages in GHCJS, but I don't think it would work correctly. On the client you really want something that's going to manipulate the DOM, not generate HTML verbatim.
20:36:03 <eacameron> julianleviston: I'm not a web dev pro, but I *feel* like templating langs are crutches for folks that don't have good stories for EDSLs...
20:36:36 <eacameron> julianleviston: I keep thinking of Jinja and Python. Debugging is a nightmare!
20:37:31 <julianleviston> eacameron: Yeah, it’s the semantics (model) I’m interested in having in common, not the actual tags or templates. I’m interested in the DOM-semantics.
20:38:06 <eacameron> julianleviston Common between what? Server and client?
20:38:42 <julianleviston> eacameron: something like that. 
20:40:14 <julianleviston> eacameron: I say “something like that” because the content needs to be clothed in different things depending on the context. But yeah, basically the model of “this thing is inside a paragraph” which rendered into HTML in most contexts as a P tag, with a set of attributes.
20:40:58 <julianleviston> eacameron: the thing that would be common is a way of telling either Lucid or reflex-dom “what it is” in DOM-terms… in a general way.
20:41:23 <julianleviston> I’m sure I’ll work something out when I get there.
20:41:36 <eacameron> julianleviston: Interesting. Makes sense. So what you're after is something a bit more abstract than HTML in particular.
20:42:30 <julianleviston> eacameron: ah, no.. I know what you’re thinking there, and I *do* want that, but that’s just my application’s model of the content. I want a general way to explain to “whatever the presentation code is” the DOM semantics of the output.
20:42:42 <julianleviston> eacameron: so kind of a shim between my content and the presentation layer. 
20:43:55 <julianleviston> eacameron: the presentation for a server-side “app” involves req/resp pairs to interact, whereas the GHCJS/Reflex version would be much more immediate, but with the same “semantics”.
20:43:58 <eacameron> julianleviston: Neat. Beats me how you'll pull off something that both reflex-dom and lucid can equally handle!
20:44:29 <julianleviston> eacameron: hehe well, like I said, I’ll find out when I get to that point. :) It’ll be fun :)
20:44:58 <eacameron> julianleviston: Yes that will be interesting...
20:45:27 <julianleviston> eacameron: first I’ve got to work out this module system to finish off my routing. Client/server data/code sharing is proving VERY fun :)
20:45:43 <eacameron> julianleviston Always has.
20:45:57 <julianleviston> eacameron: oh are you putting your code in your DB too?
20:47:13 <eacameron> julianleviston: No...I'm not really *doing* anything yet... ;)
20:47:23 <julianleviston> eacameron: ah ok
21:32:41 <kadoban> Can anyone point me to anything about why ErrorT is bad and what exact semantic difference there is in ExceptT? Is ExceptT basically the only choice anyone would move to from ErrorT? I have some old code using ErrorT and trying to figure out what to do with it.
21:35:20 <glguy> The difference is in how 'fail' is implemented
21:35:52 <glguy> ErrorT catches the fail and ExceptT passes it through to the underlying Monad instance
21:36:14 <glguy> You should use which ever one has the behavior you expect
21:36:49 <kadoban> Isn't ErrorT deprecated and to-be-nuked? Can I really keep using it?
21:37:25 <glguy> It'll just have to be added to transformers-compat if it gets removed from transformers one day
21:37:39 <glguy> It's simply a different type, it'd be dumb to remove it in favor of ExceptT
21:38:12 <kadoban> I'm using mtl I believe … not sure if that changes anything? I guess it's the same-ish? I can't remember why I used mtl for this … probably just flipped a coin.
22:29:50 <orion> Is cabal.config (from stackage) supposed to be included in packages uploaded to hackage?
22:35:46 <ReinH> kadoban: mtl is based on transformers
22:36:05 <bitemyapp> kadoban: mtl is based on witchcraft, don't listen to him
22:36:26 <kadoban> Haha
22:36:46 <bitemyapp> okay, I have a flight. I should pretend to get ready.
22:36:54 * bitemyapp pretends to /part
22:37:07 <kadoban> Isn't one of them basically recommended, and the other kinda old and semifugly or something? I remember I was told to use transformers for new stuff I though.
22:37:10 <kadoban> thought*
22:37:45 <bitemyapp> kadoban: I like mtl-style.
22:37:52 <kadoban> Ah
22:38:21 <bitemyapp> I usually say "mtl-style" because it's as much about making your own classes and picking through the various options as anything else.
22:38:22 <kadoban> I should really look into what exactly the difference is. I might be knowledgeable now to make a real choice.
22:38:24 <bitemyapp> Depends on what you want to do.
22:38:35 <kadoban> knowledgeable enough*
22:38:51 <bitemyapp> https://github.com/bitemyapp/bloodhound/blob/master/src/Database/Bloodhound/Types.hs#L281-L282
22:39:10 <bitemyapp> From: http://hackage.haskell.org/package/mtl I most often use Reader
22:39:29 <bitemyapp> kadoban: Can pick through https://github.com/ekmett/quine/tree/master/src/Quine for ideas as well.
22:41:05 <kadoban> Thanks
22:41:23 <kadoban> Have a nice flight :)
22:41:24 <nitrix> bitemyapp: I have a personal question for you.
22:41:42 <nitrix> bitemyapp: Were you using emacs before getting serious with Haskell?
22:41:49 <bitemyapp> yes
22:41:58 <bitemyapp> but it would've pushed me over the edge if I hadn't
22:42:15 <bitemyapp> nitrix: what's the question beneath the question?
22:42:35 <bitemyapp> nitrix: https://github.com/bitemyapp/dotfiles to get some idea, that repo is a modernization of an old tarball I kept kicking around.
22:42:49 <bitemyapp> nitrix: and that's 2,334 commits going back 4+ years
22:42:59 <nitrix> bitemyapp: That's precisely what I'm looking at.
22:43:16 <bitemyapp> is this a way to figure out how old I am? :P
22:43:39 <nitrix> I'm trying to figure out the workflow of the influential names I know, you, the lens guy, etc, and emacs just keeps re-appearing, over and over and over.
22:44:05 <nitrix> I'm a vim user, but I'm not religious, so you can immagine how it poke my curiosity.
22:44:10 <bitemyapp> I'm influential? God help us all
22:44:27 <bitemyapp> if I have influence then I should be convincing you people to write Haskell in 'ed'
22:45:00 <bitemyapp> nitrix: I take it you don't currently use Emacs?
22:45:04 <nitrix> Well, now you're getting on my nerves.
22:45:12 <bitemyapp> nitrix: also I think Ed uses vim, not Emacs.
22:45:26 <bitemyapp> ReinH: do I have that right? He uses vim right?
22:47:07 <bitemyapp> nitrix: my personal reasons for Emacs come down to preferring modelessness (statelessness-by-default in a sense) and the better (IMO, YMMV) programmability
22:47:24 <sleblanc> Coming from a Vim user, I do have to say that things look nice on the other side of the fence: decent scripting language (Guile), better handling of windows and buffers, built-in package manager.
22:47:51 <bitemyapp> nitrix: I "know" vim in some sense but I'm not fluent in it and the plugin ecosystem made me unhappy. Figured if I liked vim enough I could use evil.
22:47:55 <sleblanc> scratch that, it uses Emacs Lisp, not Guile/Scheme
22:48:02 <bitemyapp> yeah.
22:48:21 <ent> bitemyapp: not sure if it's fair to call emacs modeless with all those modes
22:48:32 <bitemyapp> ent: I'm talking about editing modality
22:48:46 <bitemyapp> nitrix: nothing at all wrong with vim. Arguably the haskell stuff for vim is more stable right now anyway :P
22:48:52 <bitemyapp> less magical, but also more stable.
22:57:13 <ReinH> bitemyapp: yeah, he uses vim
23:10:39 <bernalex> ed = kmett? he uses vim; without any plug-ins because he's a madman.
23:11:25 <bernalex> you need to appreciate that edward writes haskell in a way that feels alien to many others.
23:11:42 <glguy> Writing Haskell with Vim without any Haskell plugins is fairly standard
23:12:01 <bernalex> I don't think he even has syntax highlighting.
23:12:13 <shanemikel> that's a bit extreme
23:12:27 <srhb> Less extreme than the people not using fixed-width fonts. :-)
23:12:35 <bernalex> the way he writes code seems to be to think up the types and then implement *every possible instance* for them, and then afterwards remove the ones he doesn't need. he finds writing out the instances gives him key insights in how his types really work.
23:13:36 <bernalex> tbf one can't argue with the results. :]
23:15:36 <shanemikel> is there a terminal, ide, or editor that uses variable-width fonts?
23:16:19 <srhb> shanemikel: Most of them can?
23:16:31 <srhb> shanemikel: It's usually the font choice, not the terminal, ide or editor.
23:16:34 <kadoban> shanemikel: notepad XD
23:17:42 <shanemikel> I remember trying var-width fonts in my terminal before, with buggy results.. also, wtf is notepad?
23:17:48 <bernalex> bonus points if you are mixing tabs and spaces for indentation of your variable-width font.
23:17:59 <bernalex> shanemikel: like nano for windows
23:19:22 <kadoban> It's some ancient text editor that microsoft wrote in 1990, hasn't updated since, but they still include it in every windows version I saw.
23:19:28 <kadoban> It's … beyond terrible.
23:20:50 <shanemikel> hmm, if 90 is ancient, what is unix?
23:21:14 <shanemikel> vim, emacs, linux, haskell even
23:25:02 <shanemikel> anyway, it's not like gnome doesn't ship with gedit
23:28:33 <shanemikel> one of the reasons I'm trying haskell out, it occurred to me If I *need* completion to be even marginally efficient in a language, it's not a great language
23:29:12 <shanemikel> not to mention code generation
23:45:40 <bb010g> How do I get stack to update a cabal dependency?
23:46:32 <mgsloan> bb010g: As in use a newer version of a package?
23:47:15 <bb010g> mgsloan: Yeah. It's complaining that I need >=4.0.2, 4.0.0 found, 4.0.2 latest
23:47:36 <bb010g> (It went from 4.0.0 latest to 4.0.2 after a cabal update)
23:48:58 <mgsloan> https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md#curated-package-sets
23:50:06 <bb010g> mgsloan: Thank you. I'm sleepy and stupid and wanting to get this done. :)
23:58:23 <bb010g> Wheee, first part of refactoring & clean up done: https://github.com/aurapm/aura/pull/371
23:58:31 * bb010g is going to bed now
23:59:02 <bb010g> Sorry, wrong channel. :(
