00:05:35 <akfp2> pharaun: that was simple!  thanks!
00:06:43 <pharaun> np
00:07:49 <Lokathor> what's the name for when you have an operator with one arg applied, like (*2)
00:07:56 <Lokathor> isn't that a "slice" or some other special name?
00:08:04 <jle`> section
00:08:10 <Lokathor> ah ha
00:11:23 <saulzar_> Anyone know anything about compiling with RTS debugging? If I use -debug I get "/usr/bin/ld: cannot find -lHSrts_debug_p"
00:14:24 <saulzar_> Nevermind, seems it can compile as long as it's not both profiling and debug
00:15:49 <Lokathor> :t (+) <$> (*2) <*> (+10)
00:15:51 <lambdabot> Num b => b -> b
00:15:56 <Lokathor> :t (*2) <*> (+10)
00:15:58 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> b
00:15:58 <lambdabot>     Expected type: (a -> b) -> a
00:15:59 <lambdabot>       Actual type: a -> a
00:16:05 <Lokathor> what gives here?
00:19:00 <tzh> Lokathor: the top one is `((+) <$> (*2)) <*> (+10)`, not `(+) <$> ((*2) <*> (+10))`
00:19:26 <Lokathor> oh it's a prescedence thing
00:20:11 <Lokathor> or.. an associative thing?
00:23:21 <kadoban> Lokathor: Associativity I guess. They're both infixl 4
00:23:27 <tzh> they're both the same precedence and both left-associative, so you read them from the left (and sections appearing on the right of a chain of <*>s frequently aren't valid expressions all by themselves)
00:24:57 <Lokathor> :info ($)
00:25:04 <Lokathor> awh :/
00:25:33 <Lokathor> alright, infixr 0
00:25:38 <Lokathor> well okay then
00:27:03 <jle`> you can think of it as pure (+) <*> (*2) <*> (+10)
00:38:35 <cow_2001> if I know at compile time what keys I will be using for this here (someMap :: Map String a), can I statically check for typos in the literal Strings I use throughout the code?
00:39:02 <mauke[o}> wouldn't that be a record?
00:39:06 <cow_2001> another solution would be using a really freakin' big record
00:39:08 <cow_2001> yes
00:39:33 <jle`> you can use Map w/ a type with a bunch of constructors
00:39:50 <Lokathor> jle`, to me that dosen't make too much more sense :P
00:39:59 <cow_2001> the thing is, I have a bunch of image assets I want to use for my really shitty game I am writing
00:40:16 <jle`> Lokathor: it helps with typos :O
00:40:39 <jle`> also with a Map, some fields might not be filled.  so it'd be a little cleaner than a record with a bunch of Maybe's maybe
00:40:53 <cow_2001> jle`: omg. that's a pretty cool idea.
00:41:11 <Lokathor> jle`, sorry, i meant your example with pure (+) and so on didn't make much more sense to me
00:42:58 <jle`> Lokathor: oh ah.  i guess it is kind of like, f <*> x <*> y <*> z corresponds to ((f x) y) z
00:43:06 <jle`> ((f <*> x) <*> y) <*> z
00:43:22 <jle`> sort of drawing an analogy between <*> and "space"/" "/function application
00:43:49 <jle`> except instead of (a -> b -> c), a, b, and c, it's f (a -> b -> c), f a, f b, f c
00:44:05 <jle`> "<*>" basically fills the same role as the function application operator/space
00:45:58 <Lokathor> :t pure
00:46:00 <lambdabot> Applicative f => a -> f a
00:46:11 <Lokathor> oh right, pure is return
00:46:14 <Lokathor> one tier down
00:47:06 <kadoban> In other words, if you have 'f x y', there's no real reason that 'x y' should make sense on its own. Similar for   f <$> x <*> y    
00:47:40 <jle`> yeah, i just used <*> to keep a uniformity to have them all be the 'same' operator, like f x y
00:47:49 <Lokathor> well sure
00:48:06 <jle`> f x y is (f x) y, so f <*> x <*> y is (f <*> x) <*> y.  f <*> (x <*> y) would be like f (x y)
00:48:09 <Lokathor> however, one guide that i'd read somewhere (i forget where) had drawn a parallel between $ and <$>
00:48:36 <jle`> i've drawn that parallel before in a blog post too
00:48:49 <Lokathor> and, putStr $ "foo" ++ "bar", well that does make sense if you have just the "foo" ++ "bar" part
00:48:55 <jle`> but <*> also has a strong claim for parallel of "<*>"
00:48:57 <Lokathor> which is the source of the confusion
00:49:07 <jle`> ah yeah
00:49:13 <jle`> i can see how that can lead to the confusion
00:50:16 <varaindemian> The most common use case with flip is calling it with just the function parameter and then passing the resulting function on to a map or a filter. So use lambdas in this way when you want to make it explicit that your function is mainly meant to be partially applied and passed on to a function as a parameter. What does calling it with JUST function parameter mean? Can I see and example of this?
00:51:15 <jle`> slightly misleading
00:51:47 <doofin> hi
00:51:54 <jle`> but i think it means using `flip f` for a function f, to turn it into f "with arguments switched"
00:52:21 <kadoban> I belive it's being contrasted with: flip f somearg
00:52:37 <mauke[o}> flip f = \x y -> f y x
00:52:51 <varaindemian> jle`:     flip' f = \x y -> f y x  
00:52:51 <varaindemian> Even though that's the same as writing flip' f x y = f y x, we make it obvious that this will be used for producing a new function most of the time. The most common use case with flip is calling it with just the function parameter and then passing the resulting function on to a map or a filter. So use lambdas in this way when you want to make it explicit that your function is mainly meant to be parti
00:52:58 <varaindemian> ally applied and passed on to a function as a parameter.
00:53:05 <doofin> I am learning ghc , there is some code using ghc api to make a working ghc compiler
00:53:15 <doofin> ghcmake = defaultErrorHandler defaultFatalMessager defaultFlushOut $ do   runGhc (Just GP.libdir) $ do     dflags <- getSessionDynFlags     setSessionDynFlags dflags     target <- guessTarget targetFile Nothing     setTargets [target]     load LoadAllTargets
00:53:34 <doofin> but i can not see where comes the parsed haskell ast?
00:57:03 <varaindemian> anyone can explain me the most common use case with flip? An example maybe..
01:03:48 <merijn> varaindemian: For me usually something like runStateT
01:03:52 <merijn> :t runStateT
01:03:53 <lambdabot> StateT s m a -> s -> m (a, s)
01:04:25 <merijn> varaindemian: I want to provide the initial state 's' first and write the StateT block second, so I can do "flip runStateT initial $ do { code here }"
01:05:02 <merijn> varaindemian: Usually flip is used when the argument order doesn't quite match what you want when composing stuff
01:05:17 <jle`> i use it sometimes with compare
01:05:28 <jle`> > sortBy compare [1..10]
01:05:33 <lambdabot>  mueval-core: Time limit exceeded
01:05:37 <merijn> oh, yeah
01:05:58 <merijn> That's a neat trick :)
01:06:01 <jle`> um
01:06:08 <merijn> > sortBy compare [1..10] -- smacks lambdabot
01:06:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
01:06:19 <merijn> > sortBy (flip compare) [1..10]
01:06:20 <jle`> > sortBy (flip compare) [1..10]
01:06:21 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
01:06:22 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
01:06:34 <merijn> varaindemian: Instant reverse sorting ;)
01:07:12 <jle`> it's equiv to sortBy (\x y -> compare y x), so it'll give "reverse comparisons"
01:07:51 <jle`> but in real life i often just use it with giving one extra argument.  so i use (flip f x) a lot
01:08:05 <jle`> > map (subtract 10) [1,5,2,6,9]
01:08:07 <lambdabot>  [-9,-5,-8,-4,-1]
01:08:09 <jle`> > map (flip subtract 10) [1,5,2,6,9]
01:08:11 <lambdabot>  [9,5,8,4,1]
01:08:35 <jle`> this is where hlint would nag me to use map (`subtract` 10)
01:09:06 <mauke[o}> > map (10 -) [1,5,2,6,9]
01:09:08 <lambdabot>  [9,5,8,4,1]
01:09:34 <mauke[o}> subtract = flip (-)
01:10:42 <emmanuel_erc> hello
01:12:45 <emmanuel_erc>  Are any of you familiar with the fgl library?
01:13:04 <emmanuel_erc> (fgl -> the functional graph library)
01:36:47 <botter> Hi. How do I save my ghci terminal's defined functions to a file?
01:36:57 <botter> I wrote some functions in ghci, i mean
01:41:15 <Kristler> botter: Copying them to a *.hs file would be one option
01:41:25 <botter> Like manually copy-pasting?
01:41:28 <botter> There's no way to save state?
01:42:04 <Kristler> Couldn't say, I've never attempted that before
01:42:10 <botter> interesting
01:42:40 <jle`> not all state is necessarily saveable, either, in a meaningful way
01:43:11 <botter> this is a pain
01:43:16 <botter> there has to be a better way
01:44:00 <jle`> would be a nice gsoc project, actually?  to be able to suspend and resume ghci sessions, to the extent where it would make sense?
01:44:04 <mjrosenb> I'm confused, I have a library, which builds when I run 'cabal build' in its directory+sandbox, but when I try to install it into a different sandbox, it says it can't find some modules
01:44:05 <jle`> hm
01:44:43 <botter> i can't copy paste because i got carried away and did a lot of stuff in ghci without saving to a file
01:44:47 <mjrosenb> jle`: so bash has this awesome feature, which ghc could probably trivially implement
01:44:50 <botter> and there's error messages, terminal output, etc. in between
01:45:03 <mjrosenb> namely, the key combo C-x C-e
01:46:16 <mjrosenb> botter: I usually do stuff in emacs, then ask emacs to send my current buffer over to ghci, so I always have it in an editor first, then in the repl.
01:46:20 <jle`> i mean, suspend/reload from a file, heh
01:46:32 <jle`> some sort of file representing the state of the environment
01:47:26 <emmanuel_erc> Are any of you familiar with the fgl library?
01:48:47 <mjrosenb> jle`: would it just stick everything inside a main function, and in a do block?
01:49:28 <jle`> i don't really know if it's even meaningful to do
01:51:59 <mjrosenb> anyhow, why would ghc complain about missing modules in one directory, but not another?
01:52:35 <mjrosenb> Preprocessing library reactive-banana-sdl2-0.1.0.0...
01:52:55 <mjrosenb> is it trying to build the documentation there, or just some other preprocessing?
02:20:10 <mjrosenb> huh, I'm guessing it isn't normal to have .cabal-sandbox/lib/arch/foo-hash1 and .cabal-sandbox/arch/foo-hash2
02:39:16 <m1dnight_> Is it possible to pass arguments via cabal run? I can run the binary file with `./binfile -repl` for example, but cabal does not accept this.
02:40:50 <geekosaur> m1dnight_, you need a -- to stop cabal from reading parameters gnu-style
02:40:57 <geekosaur> cabal exec -- program --option
02:41:44 <geekosaur> (the downside of gnu-style options being anywhere is when you have a program running another program given as a parameter)
02:42:43 <m1dnight_> aha! wonderful
02:42:47 <m1dnight_> thanks geekosaur 
02:42:54 <m1dnight_> (TIL that is called gnu-style)
02:43:15 <geekosaur> well, POSIX wants all options before non-options. GNU introduced the put-them-anywhere
03:08:06 <anohigisavay> This leaves the
03:08:07 <anohigisavay> beginner thinking that monads are a way of dropping into a pseudo-imperative
03:08:09 <anohigisavay> language inside of code and further fuels that misconception that specific
03:08:10 <anohigisavay> instances like IO are monads in their full generality.
03:08:19 <anohigisavay> sorry i'm not a native english speaker
03:08:30 <anohigisavay> what does the IO part of the sentence mean?
03:09:09 <liste> @type putStrLn
03:09:10 <lambdabot> String -> IO ()
03:09:30 <liste> that IO there, the type of actions that use input and output
03:09:45 <ben> the sentence is complaining that people think a specific monad (like IO) is the same thing as "monads in general"
03:10:13 * hackagebot foscam-filename 0.0.3 - Foscam File format  https://hackage.haskell.org/package/foscam-filename-0.0.3 (TonyMorris)
03:10:15 * hackagebot foscam-directory 0.0.3 - Foscam File format  https://hackage.haskell.org/package/foscam-directory-0.0.3 (TonyMorris)
03:10:24 <anohigisavay> ben: cool. thanks :)
03:10:39 <anohigisavay> liste: thank you too :) i didn't make myself clear
03:11:52 <Acru> hey, why does this loop indefinitely in haskell?
03:12:00 <Acru> https://gist.github.com/Acru2015/efaf4328f351d7703b51
03:12:16 <Acru> shouldnt haskell be able to wirk with the stream of builder?
03:12:53 <pavonia> What is "this"?
03:13:34 <quicksilver> haskell is excellent at working with streams
03:13:57 <quicksilver> but your 'existsInList x builder' will necessarily inspect the entire builder
03:14:03 <quicksilver> before its finished being built
03:14:17 <quicksilver> I suspect you only really wanted to inspect the entries so far.
03:14:31 <Acru> yes
03:14:39 <Acru> how would I do this?
03:14:45 <quicksilver> list comprehensions don't give you any access to the "list as built so far"
03:15:05 <quicksilver> I'd just rewrite as a simple recursion
03:17:18 <pavonia> Acru: Also, "length foo > 0" should be replaced by "not (null foo)"
03:17:48 <pavonia> > length [1..] > 0
03:17:52 <lambdabot>  mueval-core: Time limit exceeded
03:18:00 <pavonia> > not (null [1..])
03:18:02 <lambdabot>  True
03:18:18 <frerich> pavonia: Well in that particular case, you could juse use 'elem' of course.
03:18:23 <Acru> oh, thank you
03:18:29 <Acru> ok
03:18:44 <pavonia> frerich: Right
03:19:42 <Myrl-saki> Is there a way to build a program with static allocation?
03:20:02 <Myrl-saki> Say, give it a .bss size of 1M, and that's its memory pool.
03:20:13 * hackagebot cgrep 6.5.11 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.11 (NicolaBonelli)
03:20:27 <Myrl-saki> (In GHC.)
03:21:51 <quicksilver> Myrl-saki: I'm not sure about exactly how memory is allocated, but you can certainly fix the size of the heap
03:22:03 <quicksilver> you get pretty bad performance once you get close to heap exhaustion though
03:22:16 <quicksilver> it will keep GC'ing over and over and over trying to squeeze the last bits in
03:22:41 <Myrl-saki> quicksilver: ofc.
03:23:50 <Myrl-saki> I asked that question since I want to know if, hypothetically, it's possible to implement mmap in GHC.
03:29:36 <quicksilver> I doubt it
03:29:43 <quicksilver> but it's easy enough to *use* mmap in GHC
03:30:12 <Myrl-saki> quicksilver: What exactly do you mean by "use"?
03:31:59 <quicksilver> link to one of the libraries which is a haskell binding to mmap
03:32:04 <quicksilver> or write your own binding
03:32:24 <Myrl-saki> Ah.
03:32:47 <Myrl-saki> quicksilver: But why would you do that? :(
03:32:48 <quicksilver> bytestring-mmap, hmatrix-mmap, vector-mmap, etc
03:33:00 <quicksilver> well it's a useful pattern for sparse file access
03:33:24 <quicksilver> and it can be useful if all you want to do with that data is pass it straight to some other API (like OpenGL/OpenCL)
03:33:59 <Myrl-saki> FFS.
03:34:09 <Myrl-saki> quicksilver: True.
03:34:22 <Myrl-saki> Ugh.... my hard drive's dead again.
03:34:24 <Myrl-saki> brb.
03:38:24 <merijn> Hell, just using mmap manually is pretty easy
03:38:45 <merijn> Myrl-saki: Also, mmap is a system call, so it cannot possiblye be implemented "in GHC" unless you implement a full OS :)
03:39:08 <merijn> The things mmap does fundamentally require builtin support from the OS
03:39:42 <merijn> Myrl-saki: Also, the static memory pool is certainly possible, if you've sufficiently hacky
03:40:00 <merijn> You can just link a 1MB zeroed space into your binary and access it via a pointer
03:40:24 <merijn> Myrl-saki: Note that the FFI is perfectly happy to let you do all sorts of dirty pointer manipulation, as long as it's IO
03:43:05 <Myrl-saki> merijn: ofc.
03:43:10 <Myrl-saki> merijn: That's the plan.
03:43:21 <Myrl-saki> (Make an OS.)
03:43:28 <mauke[o}> given 「data Tree = Leaf | Branch Tree Tree」 and an integer n, is there a well known method of enumerating all trees with n leaves?
03:44:56 <merijn> Myrl-saki: There's no conceptual problem with doing so in haskell, but as-is the current runtime isn't very well suited to this kinda stuff
03:45:20 <merijn> Myrl-saki: There's House and HaLVM which run haskell on bare metal and Xen respectively
03:46:24 <merijn> mauke[o}: Sounds like something involving list monad and dynamic programming?
03:46:40 <Geraldus> Hi friends!
03:47:13 <merijn> mauke[o}: (iow, I don't think there's a well known method besides the straight forward recursive one)
03:48:26 <mauke[o}> > let blergh 1 = [LLeaf]; blergh n = [ x | t <- [1 .. n `div` 2], l <- blergh t, r <- blergh (n - t), x <- LBranch l r : [LBranch r l | t + t /= n] ] in blergh 3
03:48:28 <lambdabot>  [LBranch LLeaf (LBranch LLeaf LLeaf),LBranch (LBranch LLeaf LLeaf) LLeaf]
03:48:31 <mauke[o}> that looks horribly inefficient
03:49:09 <Geraldus> I have a list of messages which I want to convert to Html and concat everything.  I write: `concatMap toHtml ms`.  It works as expected, but HLint suggests me to replace `concatMap` with `(=<<)`.  I can't understand it
03:49:36 <merijn> mauke[o}: That's why I said dynamic programming
03:49:38 <mauke[o}> toHtml =<< ms, but I don't see why
03:49:50 <quicksilver> Geraldus: it just happens that the =<< instance for [] is concatMap
03:49:58 <quicksilver> I don't particularly agree with HLint on this one
03:50:06 <merijn> memoise the list of all 3 leave branches and generate the list of 4s by enumerating all combinations of numbers of leaves that sum to 4
03:50:09 <quicksilver> I find concatMap is a nicely named function and it's easier to read.
03:50:43 <merijn> mauke[o}: recomputing all n-1 leaf trees is going to be very inefficient, yes
03:50:57 <mauke[o}> I bet there's an algorithm that doesn't just use blind caching
03:51:47 <quicksilver> there is an algorithm which simple counts them, I think
03:51:57 <quicksilver> there is a direct encoding plus an enumeration
03:52:20 <quicksilver> I can't tell you what it is, though :(
03:53:28 <Geraldus> quicksilver: yeah, concatMap is very descriptive
03:53:58 <Geraldus> quicksilver: anyway, just for learning, how can I replace concatMap with =<< ?
03:54:26 <mauke[o}> catalan numbers are related
03:55:11 <quicksilver> Geraldus: (=<<) toHtml ms
03:55:22 <quicksilver> Geraldus: or, toHtml =<< ms
03:55:23 <mauke[o}> > map (length . blergh) [1 .. 6]
03:55:27 <lambdabot>  Not in scope: ‘blergh’
03:55:28 <quicksilver> or, ms >>= toHtml
03:55:51 <Geraldus> the issue, that I have tested both approaches already and it gives me compilation error
03:56:11 <mauke[o}> then you did it wrong
03:56:13 <quicksilver> interesting. Can yo paste the code + error?
03:58:18 <Geraldus> setMessage ((=<<) toHtml ms):  Couldn't match type ‘[]’ with ‘MarkupM’. Expected type: Text, Actual type: [Text]
03:59:18 <Myrl-saki> Text.concat?
03:59:22 <Myrl-saki> :t Text.concat
03:59:24 <lambdabot> Not in scope: ‘Text.concat’
03:59:27 <Myrl-saki> :t T.concat
03:59:29 <lambdabot>     Not in scope: ‘T.concat’
03:59:29 <lambdabot>     Perhaps you meant one of these:
03:59:29 <lambdabot>       ‘F.concat’ (imported from Data.Foldable),
03:59:32 <Myrl-saki> Hmmm
03:59:43 <Myrl-saki> :t Data.Text.Concat
03:59:44 <lambdabot>     Not in scope: data constructor ‘Data.Text.Concat’
03:59:44 <lambdabot>     Perhaps you meant variable ‘Data.List.concat’ (imported from Data.List)
03:59:44 <mauke[o}> Geraldus: ah, which concatMap is this?
04:00:01 <Myrl-saki> Oh right...
04:00:06 <Myrl-saki> Text is a monoid, right?
04:00:11 <quicksilver> if it was Data.Text.concatMap then HLint was utterly wrong in its advice :)
04:00:45 <Myrl-saki> :t Data.Text.concatMap
04:00:48 <lambdabot> (Char -> Data.Text.Internal.Text) -> Data.Text.Internal.Text -> Data.Text.Internal.Text
04:01:01 <Myrl-saki> Is `concatMap return` == concat?
04:01:05 <Myrl-saki> Or `concatMap id`?
04:01:26 <merijn> Myrl-saki: Only when talking about a different concatMap :p
04:01:30 <saulzar_> :t concatMap return
04:01:32 <lambdabot> Foldable t => t b -> [b]
04:01:44 <mauke[o}> concatMap return ~ id
04:01:44 <Myrl-saki> merijn: ofc.
04:01:55 <mauke[o}> concatMap id ~ concat
04:01:57 <Myrl-saki> mauke[o}: Ah, right.
04:02:25 <Myrl-saki> The first monad rule, IIRC?
04:02:29 <Myrl-saki> `concatMap return ~ id
04:02:44 <nshepperd> :t concatMap
04:02:45 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
04:02:54 <Myrl-saki> :t (>>=)
04:02:56 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:03:02 <saulzar_> :t (>>= return)
04:03:04 <lambdabot> Monad m => m b -> m b
04:03:21 <saulzar_> So, for lists - yes :)
04:03:31 <Geraldus> well, I don't know what concatMap is exactly used, but it seems, that it is from Data.Text (modules are imported via Import module provided by Yesod's scaffold)
04:04:01 <Myrl-saki> Actually, the second rule.
04:04:07 <nshepperd> Geraldus: what is the type of ms and toHtml?
04:04:24 <mauke[o}> Geraldus: then hlint is wrong
04:04:54 <Geraldus> toHtml is from Text.Blaze.Html toHtml :: ToMarkup a => a -> Html
04:05:10 <Geraldus> ms :: [Text]
04:05:55 <Geraldus> mauke[o}: ok, good to know.  It confused me
04:06:18 <Geraldus> thank you all, friends! 
04:06:36 <Geraldus> Have a nice day (evening)!
04:07:03 <nshepperd> right, (=<<) won't work there, because it expects the input and output to be f something, with the same f
04:07:21 <nshepperd> whereas here one is a list and the other is a Html..
04:07:44 <nshepperd> foldMap works though!
04:09:17 <nshepperd> that hlint must be a left-over from the days when concatMap :: (a -> [b]) -> [a] -> [b]
04:09:59 <nshepperd> which /was/ a strict subtype of the type of (=<<)
04:11:28 <quicksilver> HLint needs access to proper qualified type names if it's going to give hints like that :)
04:11:40 <quicksilver> then again, I disagree with this hint even when correctly typed.
04:11:41 <nshepperd> but now concatMap lives in a weird partially generalised in-between land, where it takes arbitrary foldables as input but only lists as output...
04:16:40 <merijn> :t concatMap
04:16:41 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
04:16:52 <merijn> The generalised version would be
04:16:54 <merijn> :t foldMap
04:16:56 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
04:18:57 <quicksilver> I think foldMap is the 'better' name so it's fine for that to be th egeneral one and concatMap can hold onto the legacy type
04:19:02 <quicksilver> :t concat
04:19:04 <lambdabot> Foldable t => t [a] -> [a]
04:19:13 <quicksilver> concat is 'about lists'
04:19:26 <quicksilver> :t mconcat
04:19:28 <lambdabot> Monoid a => [a] -> a
04:19:39 <quicksilver> mconcat is the odd one, in many ways, but that's circularity for you.
04:21:01 <guest2225> Is there anyway to save a Gloss animation? 
04:21:51 <quicksilver> no, guest2225, but it should work with standard screencast type software?
04:22:57 <guest2225> unfortunately, every screencast software that I try is producing a choppy video no matter what suggested setttings I use
04:23:09 <quicksilver> http://mazzo.li/posts/graph-drawing.html
04:23:14 <quicksilver> ^^ this guy produced a nice one :)
04:24:04 <guest2225> Thanks, indeed it is a nice one. I hvae seen it before, but do you know if he used a screencast software?
04:24:47 <quicksilver> guest2225: well it looks like he's using VLC, no?
04:24:51 <quicksilver> watch the first couple of seconds
04:25:25 <guest2225> I tried VLC too and it is the sme problem...the video is appearing choppy...I am using XMonad as the window manager, but that should not make a difference right?
04:25:39 <quicksilver> I wouldn't think so
04:25:50 <quicksilver> I would say something about your graphics card and your drivers
04:25:51 <guest2225> I tried changing the frame rate,  compression / no-compression...nothing works...
04:25:55 <quicksilver> but honestly I have no idea :(
04:26:22 <guest2225> strangely enough all the other videos work fine....but thanks for trying :)
04:27:49 <guest2225> Is there anyway to pipe the output from gloss into some software like vlc or something?
04:34:39 <quicksilver> no, because gloss is outputting to opengl
04:35:06 <quicksilver> unless opengl drivers exist with built-in recording, which is not inconceivable but I have no knowledge of such a thing.
04:36:30 <quicksilver> apparently thre is this things, guest2225 - https://github.com/nullkey/glc/wiki
04:36:35 <guest2225> oh thanks...there seems to be a software called glc which may be worth trying.
04:36:39 <quicksilver> which I found out about from here - http://askubuntu.com/questions/182944/how-can-i-record-an-opengl-game-in-ubuntu
04:36:42 <quicksilver> :)
04:36:48 <guest2225> oh thanks ! Indeed I was looking at the same link!
04:36:57 <guest2225> I will give that a try
04:36:59 <guest2225> :)
04:37:02 <guest2225> thakns a lot
04:37:10 <quicksilver> synchronicity via google
04:37:36 <quicksilver> probably google can monitor people who simultaneously google relatively obscrue things and deduce that they are in the same chatroom or similar.
04:38:27 <evrs> evrs: /quit
04:38:35 <guest2225> :)
04:43:47 <freepal> guys, we have a haskell exam coming up soon and we can take any materials we like in to the exam with us on a USB, you got any advice on what'd be helpful?
04:45:37 <Hafydd> freepal: what Haskell implementation are you using?
04:46:11 <freepal> haskell 2010 (we use GHC)
04:46:47 <derdon> freepal: hoogle and hlint may be useful
04:46:53 <freepal> I'm going to try and find a way to download all of hoogle so I have functions at a search
04:46:55 <Myrl-saki> derdon: ++
04:47:43 <Hafydd> freepal: if you don't have the Haskell platform library documentation on the machines, you should take that. You might also find the Haskell report useful (although you probably have a problem if you're looking that up in an exam).
04:48:16 <statusfailed> freepal: what kind of content will it cover?
04:49:17 <freepal> list comprehenshion, recursion, higher order functions, lambda function, algebraic data types, expression trees, abstract types, typeclasses, IO and monads
04:49:40 <ttt_fff> so https://ocharles.org.uk/blog/posts/2014-12-09-recursive-do.html is pretty cool
04:49:49 <statusfailed> Hmm, sounds like you probably won't be really using many libraries?
04:49:52 <ttt_fff> the rosetree example really makes laziness shine
04:50:23 <freepal> yeah I don't think so, it's more to test general understanding
04:50:39 <freepal> ill probably just download hoogle and then take a pdf of a textbook for if I need it
04:50:46 <Rembane> freepal: Create at least one working code example for each concept and bring them.
04:56:36 <merijn> freepal: Bring Typeclassopedia?
04:57:17 <freepal> good idea, thanks
04:57:44 <freepal> I can't find a way to download hoogle which is a shame
04:58:53 <Clint> felixsch__: apt-get install hoogle
04:58:54 <Clint> er
04:58:59 * Clint sighs.
05:05:18 * hackagebot haskell-src-exts 1.17.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  https://hackage.haskell.org/package/haskell-src-exts-1.17.0 (PeterJonsson)
05:15:41 <Blaap> Was wondering if anyone could help me out :) I'm writing a parser, but got stuck on how to parse a time string which is formatted HHMMSS. I wrote separate parsers for hour minute and second
05:15:52 <Blaap> parseHour :: Parser Char Hour      //     parseHour = Hour <$> integer
05:16:05 <quicksilver> yup, that's wrong :)
05:16:09 <Blaap> But I need to parse 2 integers into that parser, got no luck
05:16:12 <Blaap> ya :(
05:16:22 <quicksilver> presumabgly that will 'eat all the numbers'
05:16:25 <quicksilver> you only want to eat 2
05:16:29 <quicksilver> if you see what I mean
05:16:31 <Blaap> exactly
05:16:40 <quicksilver> what is the definition of 'integer' ?
05:16:43 <Blaap> second eats 1, minute eats 1, hour eats the rest
05:17:08 <Blaap> Let me check, its from the librabry I'm using
05:17:46 <Blaap> integer = token int
05:18:15 <ttt_fff> when using RecursiveDo, is there any disadvantage of using "mdo" instead of "do/rec"
05:18:35 <quicksilver> ah, ok, so this is problem Blaap :(
05:18:42 <quicksilver> 'token' will always grab all the ints it can
05:19:00 <quicksilver> so I don't think you can use that
05:19:13 <quicksilver> you should just grab precisely two chars directly
05:19:48 <Blaap> Any hints on how to do that? Most of my tries resulted in type errors
05:20:03 <quicksilver> is this parsec?
05:20:06 <Blaap> kind lost here, parsers are completely new for me and I'm still settling in
05:20:09 <Blaap> parselib
05:20:12 <Blaap> http://hackage.haskell.org/package/HARM-0.1.3/docs/src/Arm-ParseLib.html
05:20:45 <quicksilver> ok you have a parser called 'digit'
05:20:51 <quicksilver> which will fetch exactly one
05:21:10 <quicksilver> so "digit >> digit" will parse two
05:21:26 * frerich thinks that's very pretty (simplistic?) code!
05:21:46 <quicksilver> Blaap: does that make sense?
05:21:56 <quicksilver> then the remaining question is how to turn 2 Chars into an Int
05:21:59 <saulzar_> ttt_fff, yeah - you can have 'rec' for a small section, and access binds in that section in the non 'rec' part after
05:22:19 <Blaap> It does, but the type of digit is Char
05:22:20 <quicksilver> > read ['5','4'] :: Int
05:22:22 <lambdabot>  54
05:22:38 <anks> Hi, is there a function similar to group but grouping not only neighbouring items but from whole list? like this: groupby (==) [1,2,3,4,1,2,3] --> [[1,1],[2,2],[3,3],[4]]?
05:22:51 <Blaap> Let me try that, interesting!
05:22:52 <quicksilver> anks: sort it first.
05:23:07 <quicksilver> Blaap: I can show you how to stick those together but I'm not sure how big hints you're after :)
05:23:18 <anks> well, i will eventually ;], but its (O(nlogn) ;]
05:23:29 <quicksilver> anks: the question you have asked for is O(nlogn)
05:23:38 <deepfire> good day, folks!
05:23:41 <quicksilver> it amounts to sorting in the end
05:24:16 <deepfire> a TH question:  how can I operate on unbound names within a haskell TH quotation?
05:25:12 <deepfire> i.e. I want the user to provide a top-level TH call and supply it a quotation with names he/she desires
05:25:21 <anks> i see some kind of optimisation O(k*n) where k < logN, but its not really worth it, thanks quicksilver
05:25:37 <quicksilver> anks: bucket sort :) it's still a sort!
05:25:49 <anks> right ;]
05:26:04 <deepfire> ..and I want to use these names, to make types, fill in data structures, etc.
05:26:09 <quicksilver> anks: edwardk has a good (but very long) presentation on how to do productive linear time streaming of arbitrary ADTs
05:26:59 <anks> oh, maybe that's why i thought it's possible, i've seen it some time ago.
05:27:02 <frerich> deepfire: Can you give an example? You want the users to invoke your TH function like 'makeTHFunction [|\x -> x > y|]' or so?
05:27:11 <frerich> s/make/my/
05:27:43 <anks> thanks again, ill take a look
05:27:47 <Blaap> okay quicksilver, I'm not sure how to stick this together
05:28:22 <deepfire> frerich,  th_type_data_definer [| MyYetToBeDefinedType |]
05:28:57 <frerich> deepfire: I.e. you want to pass a reference to a type to your TH function and then your TH code generates some Haskell based on the given type?
05:29:15 <deepfire> frerich, almost -- I also want the type to be defined as well
05:29:15 <quicksilver> Blaap: ok, have you see do notation?
05:29:40 <quicksilver> Blaap: e.g. do { dig1 <- digit ; dig2 <- digit ; .... }
05:29:48 <deepfire> frerich: i.e. the TH expansion will define both the type and its uses
05:30:02 <frerich> deepfire: Hmm, then I think you may have to pass a 'Name' value to your TH function and generate that Name via 'newName'
05:30:21 <deepfire> frerich, how is that supposed to face the user?
05:31:02 <deepfire> frerich, exposing TH calls to the user.. sort of defeats the idea behind DSL
05:31:06 <frerich> deepfire: Via a String maybe, i.e. 'myTHFunction "SomeTypeToBeDefined"'
05:31:17 <frerich> deepfire: In your TH code you can then use 'newName' with the given string
05:31:19 <Blaap> and then I should combine dig1 with dig2 to an integer in a let?
05:31:47 <deepfire> frerich, that appears a bit.. underwhelming.. : -/
05:31:48 <frerich> deepfire: I'm not sure, sorry - in my past experiments I always referenced existing types, e.g. people would do 'data D = D' and then my function is invoked like "makeSomething ''D"
05:32:05 <frerich> deepfire: How so?
05:32:06 <deepfire> frerich, I understand, yes..
05:32:31 <frerich> deepfire: You want to pass the name of a type which is yet to be defined, right? A String doesn't seem that far-fetched to me.
05:32:56 <Blaap> quicksilver: http://lpaste.net/4667370119096172544
05:32:57 <Blaap> awesome :)
05:33:02 <Blaap> seems to work like a charm!
05:33:08 <deepfire> frerich, it means that the DSL will look somewhat unlike pure Haskell..
05:33:23 <Blaap> thank you!
05:33:32 <quicksilver> Blaap: perfect.
05:33:44 <quicksilver> Blaap: possibly rather than using 'read' it looks nicer to use
05:33:48 <frerich> deepfire: I just checked, I did just that in one of my projects - I pass the (optional) name of a function to be defined as a String, e.g. http://hackage.haskell.org/package/catamorphism-0.5.1.0/docs/Data-Morphism-Cata.html
05:34:03 <quicksilver> 10 * digitToInt dig1 + digitToInt dig2
05:34:15 <deepfire> frerich, basically, I cannot implement something that looks and feels like native keywords of Haskell -- 'data', 'class', etc
05:34:24 <Blaap> ah yes, probably lots faster as well
05:34:39 <deepfire> frerich, I see..
05:34:40 <quicksilver> deepfire: the 'standard' trick is to put the whole data definition on the splice/quotation
05:34:56 <quicksilver> [blah| data Foo = blah |]
05:35:02 <frerich> deepfire: I suppose that is a matter of finding the right quasi-quoter
05:36:05 <deepfire> quicksilver, interesting..
05:36:36 <quicksilver> deepfire: in fact, maybe I should simply say "the standard trick is to use a quasiquoter"
05:36:40 <quicksilver> not just a splice
05:36:49 <quicksilver> then you can make up whatever syntax you want inside the splice
05:36:58 <quicksilver> including invoking a haskell parser or writing your own parser
05:37:40 <quicksilver> Blaap: I presume ParseHour and ParseMinute look the same; just to point out you can refactor the dpulicated code :)
05:37:57 <Blaap> yea, and i have more for year month and day
05:38:06 <Blaap> I wrote a take2Digits function
05:38:12 <deepfire> quicksilver: can I invoke the haskell parser from my quasiquoter, but not have the problems with free variables?
05:38:17 <quicksilver> call it 'parseTwoDigits :: Parser Char Int"
05:38:26 <Blaap> :)
05:38:31 <quicksilver> deepfire: yes because the haskell *parser* doesn't care about that
05:38:42 <quicksilver> deepfire: but you can't, for example, check the types of anything, becaues it hasn't been type checked yet.
05:39:04 <deepfire> quicksilver, it's supposed to be purely generative, so that's not a problem for me
05:39:47 <Blaap> I now have take2Digits and take4Digits helper functions. I guess there's no magic haskell trick to combine these to "take_n_digits" function?
05:40:09 <deepfire> quicksilver, frerich, thanks a lot!
05:40:16 <Blaap> ie let the amount of do statement vary on n
05:42:12 <deepfire> quicksilver, is there a place where I can steal the implementation of the full-blown quasiquoter for the purposes of trimming it down for myself?
05:43:28 <deepfire> where "full-blown" is the thing that handles [e||]
05:44:59 <anks> how do i sort list by data constructors? do i need to write function converting it to something 'orderable' ?
05:46:25 <geekosaur> had you considered deriving Ord for your data type?
05:46:39 <frerich> anks: You could use 'sortBy' with a custom comparison function, yes
05:46:49 <quicksilver> Blaap: certainly there is. no magic required :)
05:47:05 <quicksilver> Blaap: digits <- replicateM n digit
05:47:40 <Hafydd> Blaap: you're correct. It's impossible to take an odd number of digits by only taking even numbers of digits.
05:49:00 <Hi-Angel> I'm wonder, in what language the Haskell garbage collector is written? It couldn't be the Haskell because then GC would require GC too, which in turn would require GC, ad infinitum, isn't it?
05:49:15 <Shockk> I think it's written in C--
05:49:17 <anks> geekosaur: thanks.. that was simple :], frerich: i was aware of this solution, thanks though!
05:49:34 <quicksilver> Hi-Angel: the haskell RTS (including GC) is written mostly in Cmm
05:49:45 <quicksilver> with some assembly
05:49:50 <merijn> quicksilver: C, not Cmm
05:50:14 <Hi-Angel> Okay, thanks.
05:50:16 <quicksilver> ah it's mostly C 
05:50:19 <quicksilver> there is some Cmm merijn 
05:50:22 <merijn> Hi-Angel: The RTS is mostly written in C, including the GC, but there's no theoretical reason you couldn't extend the compiler with GC primitives and implement the runtime in Haskell
05:50:22 <geekosaur> it would be possible to define a subset of Haskell that doesn't require GC; it hasn't been done though
05:50:36 <merijn> geekosaur: You could also built GC into the compiler
05:50:44 <Shockk> hmm where did I read about part of it being written in C--? I can't remember now
05:50:58 <quicksilver> the GC itself appears to be mostly / all C
05:51:01 <quicksilver> Hi-Angel: https://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Rts
05:51:10 <Blaap> quicksilver: Excellent. Love how short haskell can be if done right
05:51:15 <merijn> Hi-Angel: THe main reason the runtime is in C are: 1) it's more easily portable to new platforms 2) the current one works and performs well, so why reinvent it?
05:51:50 <merijn> Shockk: C-- was supposed to be the new "low level portable assembly", but after initial buzz the standard mostly died and the GHC dialect is the only big thing still using it, I think?
05:51:58 <merijn> Shockk: LLVM kinda stole most of the potential users
05:52:17 <Shockk> ahh
05:52:22 <quicksilver> Hi-Angel: https://phabricator.haskell.org/diffusion/GHC/browse/master/rts/sm/GC.c
05:52:29 <quicksilver> Blaap: :)
05:52:40 <aweinstock> does (case ... of ...) codegen to something that does no allocations?
05:52:48 <Hi-Angel> Thank you!
05:52:48 <merijn> Shockk: Cmm specifically refers to the C-- dialect used in GHC
05:52:58 <merijn> aweinstock: That depends on the ... :p
05:53:02 <quicksilver> Blaap: haskell really shines at abstracting out patterns in code some of which other languages find hard
05:53:04 <Shockk> oh it has dialects?
05:53:20 <Shockk> dialect(s)*
05:53:31 <aweinstock> merijn: assuming neither ... does allocations, case ... of ... does no additional allocations?
05:53:35 <merijn> aweinstock: Suppose I write "case f x of ..." clearly I would allocate a thunk for "f x" first and then force the thunk while matching
05:53:50 <quicksilver> well it has two, really. "standard" C-- and GHC's Cmm
05:53:57 <merijn> aweinstock: Evaluating a thunk in the first ... part might do additional allocation
05:54:27 <merijn> aweinstock: If you're curious about codegen for lazy functional languages, there's an excellent paper ;)
05:54:30 <Blaap> quicksilver: Agreed, I did a C# project a while ago and it drove me nuts after being used to the polymorphism of haskell
05:54:49 <aweinstock> merijn: which paper?
05:55:00 <merijn> aweinstock: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
05:55:17 <merijn> aweinstock: It's a bit out of date with the state of the art in GHC, but it's a great starting point for the basics
05:55:25 <aweinstock> :t GHC.Prim.newByteArray#
05:55:27 <lambdabot> GHC.Prim.Int# -> GHC.Prim.State# d -> (# GHC.Prim.State# d, GHC.Prim.MutableByteArray# d #)
05:55:31 <Blaap> quicksilver: I only wish there would be some commercial IDE aiding in some type-auto-completion to kickstart getting to know the language
05:55:43 <merijn> aweinstock: And the followup: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.134.9317&rep=rep1&type=pdf
05:55:59 <quicksilver> Blaap: well it would be much nicer if it was a non-commercial IDE :P
05:56:06 <quicksilver> Blaap: but there is a fundamental issue here
05:56:23 <quicksilver> it might be a coincidence but Java and C#'s left-to-right deferencing is perfect for auto-completion
05:56:39 <Blaap> quicksilver: I've accepted that every now and then i need to pay for shiny things ;)
05:56:40 <quicksilver> haskell code is not necessarily usefully type inferrable when you're half-way through a line.
05:56:45 <merijn> aweinstock: Theat first paper first defines STG (which is basically a simplified Core) and then defines how to compile STG to a C/assembly
05:57:41 <Blaap> Yea i see. But maybe a smarter compiler then?
05:58:04 <Blaap> once that can hint me more in possible fixes, i dunno really...
05:59:05 <aweinstock> merijn: regarding " no theoretical reason you couldn't extend the compiler with GC primitives and implement the runtime in Haskell", would that probably end up looking like nested (case ... of ...) with some sort of unsafeAllocateMemory# ?
05:59:24 <Blaap> I bought "Haksell for mac" a few weeks ago which really helped me. It has a "playground" which is not much more than GHCi which keeps in sync with your code, but that already helped a lot. I could test my code for type corectness a lot quicker
05:59:51 <merijn> aweinstock: Just take the assembly produced by the current GC functions, put them in the compiler and introduce dedicated primitives for them? :p
06:01:01 <aweinstock> merijn: that sounds less maintainable than the current solution
06:01:13 <merijn> aweinstock: Oh, sure
06:01:32 <merijn> aweinstock: I'm just pointing out that it's POSSIBLE, not saying it's a good investment of development resources :)
06:02:00 <merijn> aweinstock: But people tend to say things like "We need C because you couldn't build Haskell on bare metal!" which is just nonsense
06:02:20 <merijn> There's no theoretical (or practical, for that matter) you couldn't write a bare metal language that had GC
06:02:28 <merijn> It's just a lot of work
06:02:51 <absence> is mapMaybe the closest to a combination of map and filter in the common libraries?
06:03:03 <merijn> :t mapMaybe
06:03:04 <lambdabot> (a -> Maybe b) -> [a] -> [b]
06:04:02 <aweinstock> merijn: could the runtime mostly be written with a strict version of the functions in Foreign.Storable?
06:04:25 <quicksilver> absence: not quite sure what you're after, but concatMap and foldMap are also in that space
06:04:53 <merijn> aweinstock: I'm not sure what's in Foreign.Storable, so I can't really say
06:04:56 <aweinstock> peek/poke of Word8's seems to me to be most of what's associated with C that's not commonly associated with haskell
06:05:06 <merijn> aweinstock: Sure
06:05:10 <aweinstock> :t Foreign.Storable.poke
06:05:11 <lambdabot> Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> a -> IO ()
06:05:21 <anks> is sortBy stable?
06:05:29 <quicksilver> anks: I believe so.
06:05:38 <merijn> aweinstock: But even just things like "newByteArray#" already lets you allocate mutable raw memory
06:05:55 <anks> thanks
06:05:59 <quicksilver> > sortBy (\a b -> EQ) "hello anks"
06:06:01 <lambdabot>  "hello anks"
06:06:07 <quicksilver> anks: 1 example proves it, right?
06:06:07 <aweinstock> :t GHC.Prim.writeWord8OffAddr#
06:06:09 <lambdabot> GHC.Prim.Addr# -> GHC.Prim.Int# -> GHC.Prim.Word# -> GHC.Prim.State# d -> GHC.Prim.State# d
06:06:19 <anks> gosh, you're quick 
06:06:30 <aweinstock> merijn: newByteArray# allocates non-GC memory? i.e. malloc?
06:06:41 <merijn> aweinstock: newByteArray# is GCed
06:07:03 <merijn> But malloc is hardly magic
06:07:36 <aweinstock> merijn: I know (I've written heap metadata exploits)
06:07:48 <quicksilver> anks: "The sort function implements a stable sorting algorithm. It is a special case of sortBy"
06:07:54 <quicksilver> anks: so the docs say it is stable
06:08:08 <absence> quicksilver: i have a list that i want to both filter and map
06:08:35 <bergmark> @type mapMaybe
06:08:36 <anks> right, sorry I overlooked it
06:08:37 <lambdabot> (a -> Maybe b) -> [a] -> [b]
06:08:42 <merijn> absence: You could just do "[f x | x <- xs, p x]" where 'f' is your map function and 'p' your filter?
06:09:09 <quicksilver> absence: just do foo = filter p . map f 
06:09:55 <M2tias> use fold!
06:10:15 <absence> quicksilver: p and f drill into data structures to fetch the values they need. it's more readable if i can combine them
06:10:35 <absence> mapMaybe will do the job, was just curious about other alternatives
06:10:37 <quicksilver> absence: then it sounds like mapMaybe is exactly what you need :)
06:10:39 <aweinstock> merijn: does haskell's GC call into glibc malloc, or does it do it's own thing with mmap/sbrk/etc?
06:11:10 <absence> sometimes haskell has more general functions that surprise me by doing the same thing
06:11:13 <merijn> aweinstock: Well I doubt it calls glibc, presumably you mean libc?
06:11:28 <absence> and i love to learn about them :)
06:11:29 <merijn> aweinstock: I don't know, tbh? Time to investigate the runtime system? :p
06:11:51 <aweinstock> merijn: possibly
06:12:09 <M2tias> absence: yeah, I've been doing codewars now and everytime there's a solution with something new that basicly does what I did, but shorter
06:14:55 <aweinstock> merijn: newPinnedByteArray# creates an allocation that the GC can't move, which feels a step lower-level
06:15:41 <quicksilver> absence: concatMap is, in a sense, a generalisation of mapMaybe, with the additional abiilty to return more than 1 item for each
06:16:21 <merijn> aweinstock: That relates to how the GC works in GHC, i.e. we don't bother tracking what dies and regaining free space. Instead simply copy all live data to a new part of memory, then throwaway the entire old heap. The result is that allocation is always just bumping the heap pointer (i.e. SUPER cheap)
06:16:26 <quicksilver> absence: (and working on any foldable) and once you've accepted that, foldMap generalises it to any monoid.
06:16:32 <quicksilver> absence: but for what you want, mapMaybe seems fine.
06:16:33 <merijn> aweinstock: But this stuff is covered in the STG paper I linked earlier :)
06:17:21 <_wordsarewind_> what is the purpose of the bar and function type in type class definitions? example: class (ContextA a, ContextB b) => TypeClass a b | a -> b where ...
06:17:35 <_wordsarewind_> sorry if it's a silly question, I just couldn't figure it out...
06:17:56 <merijn> _wordsarewind_: Look up the Functional Dependencies extension in the GHC user guide
06:25:43 <mpickering> what is the syntax for the tested-with field in a cabal file
06:27:11 <mpickering> ah I see now, GHC == ***
06:31:43 <aweinstock> merijn: in the STG paper, page 12, it mentions using "black-hole" pointers to detect a subset of infinite loops, but when I tried (let f x = f x in f ()) in ghci, it just hung; do you have an example for which the detection triggers?
06:31:53 <hackal> Hello, I am doing an exercise and I am stuck. I have custom datatype with two functions which work with the datatype. I was able to write one function but I am stuck at writing the second one which should do exact opposite of the first one. Please could you point me in right direction? Thanks http://lpaste.net/145494
06:32:12 <merijn> aweinstock: Try compiling using ghc instead of ghci? That usually works better
06:33:37 <robtaylor> hmm, i have a cabal with build-type:Configure and I can see it runs ./configure, but it doesn't seem to be doing a 'make', what might I be doing wrong?
06:35:22 * hackagebot sync-mht 0.3.8.3 - Fast incremental file transfer using Merkle-Hash-Trees  https://hackage.haskell.org/package/sync-mht-0.3.8.3 (emink)
06:35:36 <quicksilver> hackal: so, join works right but you can't write 'split' ?
06:37:14 <aweinstock> merijn: tried it with `main = print (let f x = f x in f () :: ())` in test.hs, `ghc -O2 test.hs && ./test`, got `test: <<loop>>` (i.e. it worked)
06:37:26 <hackal> quicksilver: yes, I did start to write split where you should do something for each thing from command but. The something should be putting it in a list. However I am not sure how to do that.
06:37:34 <aweinstock> (but strangely, not without -O2)
06:38:21 <quicksilver> hackal: so, split has to produce, for every command, a 'list' of commands
06:38:40 <deepfire> quicksilver, do you know where one can find the source of the full-blown quasiquoter used by [e|..|]?
06:38:55 <quicksilver> hackal: what should it do in the 'Go' case?
06:39:00 <quicksilver> hackal: can you describe it in words?
06:39:15 <quicksilver> deepfire: try the DB libraries? opaleye or persistent or something?
06:39:30 <hackal> quicksilver: yes, you can chain the commands like this. "split (Go 3 :#: Turn 4 :#: Go 7)"
06:39:41 <quicksilver> hackal: sure. but that's not what I asked.
06:39:48 <hackal> quicksilver: so this should return [Go 3, Turn 4, Go 7]
06:39:55 <quicksilver> hackal: ok right
06:40:01 <quicksilver> hackal: but what about split (Go 3) ?
06:40:11 <hackal> [Go 3]
06:40:21 <quicksilver> hackal: so that's easy? why didn' you just write that? :)
06:40:22 * hackagebot sized-vector 1.4.3.0 - Size-parameterized vector types and functions.  https://hackage.haskell.org/package/sized-vector-1.4.3.0 (HiromiIshii)
06:40:31 <merijn> aweinstock: blackholing etc. is very optimisation dependent
06:40:50 <merijn> aweinstock: If GHC decides to lift out a certain allocation it suddenly might no longer blackhole
06:41:00 <deepfire> quicksilver: no, I mean the built-in quasiquoter, because I don't want to stray far from Haskell -- I merely need to turn off the latter stages of processing -- those which give me the "Not in scope" errors..
06:41:14 <quicksilver> deepfire: there isn't a built-in quasiquoter afaik.
06:41:19 <hackal> quicksilver: I could do it for single commands but I do not know how to do it for chained commands using :#:. Such as "split (Go 3 :#: Turn 4 :#: Go 7)"
06:41:22 <quicksilver> you have to invoke a haskell parsing library
06:41:36 <quicksilver> hackal: ok but the code you pasted didn't even have it for basic commands :)
06:41:43 <deepfire> quicksilver: oh, I see.. and those libraries you listed do exactly that?
06:41:52 <quicksilver> yeah I think they use haskell-src-exts
06:41:54 <quicksilver> I'm not sure.
06:41:58 <quicksilver> I haven't looked :)
06:42:06 <deepfire> quicksilver: thank you!
06:42:29 <quicksilver> hackal: so can you explain in words what you think split (c1 :#: c2) should do?
06:42:40 <deepfire> you saved me a whole lot of time.. I'd be wading through GHC sources in the search for the thing that handles [e|..|]
06:44:53 <hackal> quicksilver: it should return list. [c1, c2]
06:45:09 <quicksilver> hackal: ok well you could just do that :) why didn't you?
06:45:20 <quicksilver> there is actually something wrong with that but split, it would at least compile and type check
06:46:46 <hackal> quicksilver: I made and annotation http://lpaste.net/145494. Thank you very much for help!!!
06:47:06 <quicksilver> hackal: excellent :) 
06:47:23 <quicksilver> hackal: however, what if 'c1' was also a compound command?
06:47:41 <quicksilver> hackal: it never will be if it comes from your 'join' because your join only ever puts compound parts in the "right leg"
06:47:52 <quicksilver> but some other code might generate compounds on either leg I suppose
06:49:12 <hackal> quicksilver: you are right, I need to do check for c1 too. For example on this my current code fails "split ((Go 3 :#: Turn 4) :#: (Sit :#: Go 7))"
06:50:05 <quicksilver> hackal: yes
06:50:09 <hackal> quicksilver: so doing "split (c1 :#: c2) = split c1 ++ split c2" fixes the problem
06:50:12 <quicksilver> yup!
06:50:17 <quicksilver> great :)
06:50:23 <hackal> thanks again
06:50:26 <quicksilver> np
06:55:44 * hackagebot ghc-session 0.1.1.0 - Simplified GHC API  https://hackage.haskell.org/package/ghc-session-0.1.1.0 (PiotrMlodawski)
06:58:56 <mpickering> Is there a way to upload a package candidate with stack?
06:59:14 <absence> quicksilver: thanks, i see how foldMap fits in now that you pointed out it's the list monoid rather than maybe :)
07:00:36 <Blaap> quicksilver
07:00:40 <Blaap> whup
07:00:52 <Blaap> nvm, copy paste error :p
07:00:55 <benzrf> is there some kind of function like "f b x = if b then x else mempty"
07:01:27 <benzrf> alternatively, is there a better idiom for doing the same kind of thing as "if opt: stuff += 'some string'"
07:02:08 <benzrf> rn my idea is to use: stuff <> f opt "some string"
07:03:27 <mpickering> I don't think so in general for monoids
07:03:50 <byorgey> for the list monoid in particular you can write  [ b | x ]
07:06:15 * hackagebot servant-pandoc 0.4.1.2 - Use Pandoc to render servant API documentation  https://hackage.haskell.org/package/servant-pandoc-0.4.1.2 (mpickering)
07:12:31 <absence> byorgey: doesn't it use monadplus or something rather than monoid?
07:12:57 <byorgey> absence: yes, that's why it doesn't work for monoids in general.
07:13:41 <benzrf> :|
07:14:08 <benzrf> so whats a nice way to append something to a string if a given boolean is true?
07:14:26 <byorgey> benzrf: well, strings are lists, so ...
07:14:47 <byorgey> stuff <> [ "some string" | opt ]
07:15:08 <byorgey> I just realized I should have written [ x | b ] before instead of [ b | x ]
07:15:14 <benzrf> 2 things:
07:15:17 <benzrf> 1. that doesnt work
07:15:26 <benzrf> > "hello" <> [ " world" | True]
07:15:28 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
07:15:28 <lambdabot>      In the expression: " world"
07:15:28 <lambdabot>      In the second argument of ‘(<>)’, namely ‘[" world" | True]’
07:15:28 <byorgey> oh, right, sorry, that's a list of lists
07:15:36 <benzrf> 2. i'm actually using Text not String, my bad
07:15:41 <bennofs> benzrf: stuff <> mconcat [ "some string" | opt ]
07:16:01 <benzrf> bennofs: ok at that point i think i'll just use 'if opt then "some string" else ""'
07:16:04 <bennofs> benzrf: alternatively, use stuff <> bool mempty "some string" opt
07:16:21 <bennofs> bool from Data.Bool (I think it requires GHC 7.8/10?)
07:16:24 * benzrf writes a custom function
07:16:57 <bennofs> ("some string" *> guard opt) :)
07:17:05 <bennofs> > "some string" <* guard False
07:17:08 <lambdabot>  ""
07:17:08 <bennofs> > "some string" <* guard True
07:17:11 <lambdabot>  "some string"
07:17:20 <bennofs> many ways
07:17:21 <benzrf> doesnt work for Text though
07:17:27 <bennofs> oh, oops, right
07:17:35 <benzrf> i just wrote a <>? (c, b) = if c then a <> b else a
07:17:46 <benzrf> it's just a Turtle script, nbd
07:18:57 <luite>  /win 3
07:18:58 <bennofs> benzrf: I would find mwhen x a = if x then a else mempty more useful :)
07:19:07 <luite> erm
07:26:42 <quicksilver> byorgey: have you ever used diagrams or similar to visualized an algorithm running?
07:27:40 <absence> :t guard
07:27:41 <lambdabot> Alternative f => Bool -> f ()
07:27:48 <byorgey> quicksilver: I have used it to visualize the process of an algorithm, yes
07:27:52 <byorgey> but not *while* it was running
07:28:03 <byorgey> I'm not sure if that's what you mean
07:28:12 <quicksilver> byorgey: *nod* it feels a bit frustating how much you need to 'unpick' an algorithm to make it visualisable
07:28:13 <benzrf> whaaa
07:28:19 <benzrf> :t mconcat
07:28:21 <lambdabot> Monoid a => [a] -> a
07:28:23 <benzrf> ^ ???
07:28:34 <benzrf> does FTP not apply here?
07:28:41 <quicksilver> you can have this beautiful small haskell solution to a problem
07:28:51 <byorgey> benzrf: mconcat is a method of the Monoid class
07:28:59 <quicksilver> but to visualise it's progress you have to pull it apart into something one-step
07:29:03 <byorgey> quicksilver: yes, I know exactly what you mean
07:29:09 <absence> :t fold
07:29:10 <lambdabot> (Foldable t, Monoid m) => t m -> m
07:29:11 <quicksilver> so you can grab the data structures after each step and draw a picture of them.
07:29:21 <byorgey> right.
07:29:41 <absence> benzrf: i guess not since there's already fold
07:29:41 <benzrf> absence: i feel like that should be in the prelude
07:29:53 <byorgey> quicksilver: it might be possible to use something like  http://hackage.haskell.org/package/hood  to "cheat" and get the intermediate values without picking the algorithm apart
07:29:56 <byorgey> I haven't tried that yet
07:30:01 <absence> yeah..
07:30:15 <quicksilver> byorgey: nod although you might see too much :)
07:30:29 <quicksilver> byorgey: you might see all kinds of GHC implementation details which weren' the point you were hoping to illustrate
07:30:40 <pie_> anyone have any experience with any of the haskell FPGA DSLs?
07:30:44 <byorgey> yes, possibly
07:31:51 <robtaylor> pie_: no experience, but have heard of one, can try dig it out. I'm currently working on a CPS->RTL generator in haskell.
07:32:01 <byorgey> quicksilver: perhaps what we really want is a source -> source translation that can break apart an algorithm into a one-step process that can yield a stream of intermediate results
07:32:20 <quicksilver> byorgey: nod
07:32:39 <benzrf> is there ExitCode -> Bool
07:32:42 <robtaylor> pie_: http://www.clash-lang.org/
07:32:46 <quicksilver> byorgey: often it's a recusive call and the 'intermediate results' are the recursively used parameters
07:32:47 <byorgey> it should be doable, though probably to make it truly useful would require a lot of work
07:32:54 <byorgey> right
07:33:30 <pie_> robtaylor: i somehow missed that, thanks.
07:33:39 <byorgey> you can pretty mechanically do a CPS conversion sort of thing
07:34:04 <hackal> is there a way to make one dimensional array from two dimensional array? For example [[1,2],[1,2]] to [1,2,1,2]
07:34:07 <byorgey> and then make a wrapper that alternately yields the intermediate results and then runs the next step of the continuation
07:34:27 <byorgey> hackal: concat
07:35:16 <byorgey> hackal: also, those are lists, not arrays (the difference is that "array" typically implies fast random access, which lists do not have)
07:35:25 <pie_> robtaylor: im new to FPGAs and im new to haskell, does that project practically work?
07:35:52 <pie_> (i dont actually intend to start using that without learning haskell first, i dont think i even could :P)
07:35:53 <hackal> byorgey: yes for a while I forgot. They are lists. I am used to arrays from JS
07:36:12 <robtaylor> pie_: no idea, i haven't had time to look at it. I'm currenly working on https://github.com/balangs/eTeak
07:36:29 <pie_> ok, thanks though. :)
07:36:42 <robtaylor> pie_: heh, yah, i'm starting to get my head around haskell, and its not trivial. Not sure I like it ;)
07:37:08 <robtaylor> pie_: I'm looking to make a way to use goroutines for programming FPGAs
07:37:44 <pie_> goroutine? :P
07:41:40 * hackagebot prologue 1.0.5 - Better, more general Prelude exporting common utilities.  https://hackage.haskell.org/package/prologue-1.0.5 (danilo2)
07:41:45 <benzrf> robtaylor: this is haskell, not go
07:41:50 <benzrf> why're you using goroutines
07:41:53 <benzrf> :>
07:43:22 <flavi0> heyo. i want to get into haskell :) 1. which would be the standard/preferred interpreter for linux systems? 2. is there an introductory good tutorial or online textbook preferrably using haskell 2010?
07:43:43 <hackal> 1 + 1
07:43:58 <hackal> sorry how can you compile simple code in chat?
07:44:34 <Ankhers> > 1 + 1
07:44:36 <lambdabot>  2
07:44:39 <Ankhers> hackal: ^^
07:44:59 <orion> I have a C
07:45:06 <ww> flavi0: ghc (ghci for interactive-mode)
07:45:10 <merijn> flavi0: GHCi (which ships with GHC)
07:45:20 * ww high-fives merijn 
07:46:17 <flavi0> :)
07:46:22 <flavi0> thanks you two
07:47:27 <jeltsch> flavi0: http://learnyouahaskell.com/
07:47:40 <hackal> which higher order function applies infix functions between elements of list? I need to do something like this [[1],[2],[3,4]] to [1] ++ [2] ++ [3,4] and return [1,2,3,4]
07:47:46 <sm> see also https://www.haskell.org/documentation and http://haskellbook.com
07:47:58 <orion> I have a C++ library which contains a C wrapper. How do I instruct cabal to use g++ for those cpp files?
07:48:00 <Zekka|Sigfig> hackal: You probably want fold
07:48:03 <robtaylor> benzrf: i'm using haskell to make a tool for go users. go figure ;)
07:48:09 <merijn> hackal: That's fold
07:48:19 <merijn> hackal: Or in this very specific case: concat
07:48:25 <Zekka|Sigfig> > foldr (+) [] [1, 2, 3]
07:48:28 <lambdabot>      No instance for (Show t0)
07:48:28 <lambdabot>        arising from a use of ‘show_M756031075736894013813087’
07:48:28 <lambdabot>      The type variable ‘t0’ is ambiguous
07:48:29 <merijn> :t concat [[1],[2],[3,4]]
07:48:31 <lambdabot> Num a => [a]
07:48:35 <merijn> eh
07:48:36 <ARM9> > foldl1 (++) [[1],[2],[3,4]]
07:48:38 <merijn> > concat [[1],[2],[3,4]]
07:48:38 <Ankhers> > concat [[1],[2,3],[4]]
07:48:39 <lambdabot>  [1,2,3,4]
07:48:40 <lambdabot>  [1,2,3,4]
07:48:41 <lambdabot>  [1,2,3,4]
07:48:50 <Zekka|Sigfig> er, did I really just try to add a list to a number?
07:48:52 <Ankhers> too many cooks
07:48:55 <ARM9> concat would be the pragmatic solution
07:48:58 <Zekka|Sigfig> > foldr (+) 0 [1, 2, 3]
07:48:59 <robtaylor> pie_: go has a pretty nice encoding of CAR Hoare's CPS model, called goroutines.
07:49:00 <johnw> orion: if all else fails, a custom builder can be used
07:49:02 <lambdabot>  mueval-core: Time limit exceeded
07:49:10 <sm> bitemyapp: it will be nice when haskellbook is included on https://www.haskell.org/documentation
07:49:25 <hackal> thank you very much
07:49:41 <Ankhers> > foldl (+) 0 [1,2,3] -- Zekka|Sigfig
07:49:44 <lambdabot>  6
07:49:51 <pie_> robtaylor: youre in a haskell channel writing goroutines for balsa xD
07:50:01 <Ankhers> Zekka|Sigfig: When summing, you want strict evaluation.
07:50:10 <Zekka|Sigfig> Ankhers: But for small lists, why does it make a difference whether I use foldr or foldl? (+) is commutative, right?
07:50:32 <Zekka|Sigfig> Well, it’s associative, which is probably more important
07:50:37 <SX> Hello everyone!
07:50:49 <Ankhers> Zekka|Sigfig: Unfortunately, I do not know enough to answer that. Someone smarter than I should be able to answer.
07:50:50 <jeltsch> SX: Hi! :- )
07:51:02 <Zekka|Sigfig> > foldr (+) 0 [1, 2, 3]
07:51:05 <lambdabot>  6
07:51:24 <robtaylor> pie_: welcome to my crazy world =)
07:51:30 <Zekka|Sigfig> I’m doing (1 + (2 + (3 + 0))), pretty sure you’re doing (((1 + 2) + 3) + 0)
07:51:49 <SX> If you don't mind, could you please tell me if it's right or not to use closure like this: https://github.com/SimpleX91/snmp-client/blob/develop/src/Network/Snmp/Client/Simple/Community.hs
07:51:55 <pie_> robtaylor: you seem to have better luck than i do with my crazy ideas :P
07:51:55 <mauke[o}> > foldr (+) 0 [1, 2, 3] :: Expr
07:51:58 <lambdabot>  1 + (2 + (3 + 0))
07:52:05 <robtaylor> pie_: if you're interested (!) we hangout in #balsa in rocket.chat
07:52:17 <pie_> whats balsa like?
07:52:22 <Zekka|Sigfig> SX: That’s a pretty big source file, what part are you saking about?
07:52:30 <Ankhers> > foldl (+) 0 [1,2,3] :: Expr
07:52:34 <lambdabot>  0 + 1 + 2 + 3
07:52:46 <robtaylor> pie_: like go, but different
07:52:50 <SX> Zekka|Sigfig: communityClient func
07:53:04 <pie_> well i dont know go either heh
07:53:15 <Zekka|Sigfig> Nothing leaps out at me as wrong there
07:53:36 <robtaylor> pie_: me neither very well. I'll shortly be rewriting some balsa examples in go to get a good feel
07:53:45 <SX> Zekka|Sigfig: I've split user api from implementation this way
07:54:17 <varaindemian> sum . replicate 5 . max 6.7 $ 8.9 Isn't this translated to smth like sum . replicate 5 . max 6.7 ($ 8.9)
07:54:20 <varaindemian> ?
07:56:51 <orion> johnw: You mean adding a build hook to Setup.lhs?
07:57:10 <johnw> orion: exactly, and then use Shake
07:59:16 <flavi0> jeltsch, sm: thank you!
07:59:43 <orion> johnw: I've never heard of shake. Do you know of any tutorials for doing this?
08:01:13 <johnw> I'm pretty sure that there are some good shake tutorials already on the web.  It's a pretty capable build system lets you write your build rules directly in Haskell
08:02:44 <orion> Oh, I meant for the glue linking cabal to shake, not shake itself.
08:03:00 <johnw>  oh, you want a tutorial for creating custom builds
08:03:13 <johnw> I don't have a good example of that handy, because the time that I did it for C++ was under contract
08:03:53 <robtaylor> orion: I had some luck with judious code searches on github
08:04:24 <robtaylor> orion: i just did some horrible things to have some parts of a project built with autotools..
08:04:31 <merijn> johnw: Be happy, at least that means your horrific C++ abuse isn't available on the web :p
08:05:15 <johnw> true enough
08:05:23 <johnw> and it was for doing SOAP authentication too
08:05:48 <merijn> johnw: Poor you :p
08:05:56 <merijn> I just do horrific template voodoo
08:06:14 <robtaylor> johnw: that sounds horrifying
08:06:15 <johnw> I'm writing a Boost.Spirit parser today, I hope that counts as voodoo
08:07:45 <merijn> johnw: Dunno, haven't to use much beyond Boost.Math :p
08:11:00 <bollu> johnw: I'm still hung up on callCC
08:11:04 <bollu> :t replicateM
08:11:05 <lambdabot> Monad m => Int -> m a -> m [a]
08:11:17 <johnw> bollu: yeah, you've only been at it a few days
08:11:38 <bitemyapp> sm: hrm. I should do something about that.
08:11:47 <bollu> johnw: how would replicateM interact with ContT ?
08:12:04 <hodapp> orion: are you trying to do something with Shake?
08:12:19 <johnw> bollu: not sure I understand; the same as it does with any Monad?
08:12:30 <bollu> I've been trying to use replicateM to "double"  the effect of the "k" paramter to callCC (in the sense of x <- callCC $ \k-> replicateM 10 (k "") 
08:12:38 <bollu> but I clearly don't understand callCC :P
08:12:44 <bollu> since it seems to have 0 effect
08:12:56 <orion> hodapp: By johnw's suggestion, yes. I have a C++ library with a C wrapper that I need to call from Haskell. I want to have cabal build the C++ portion of the library automatically.
08:13:00 <johnw> so, the (k "") exits the Cont block
08:13:09 <johnw> so replicateM 10 (k "") == k "" there
08:13:27 <orion> hodapp: johnw's suggestion was to use a custom builder (which I'm trying to determine how to create) along with shake.
08:13:34 <bollu> johnw: why?
08:13:50 <johnw> bollu: it's the next step in the computation
08:13:52 <bollu> (I don't think I understand the interaction between replicateM and Cont as a monad)
08:13:54 <johnw> and that next step ends the action
08:14:03 <johnw> Cont as a monad is nothing special
08:14:10 <johnw> if you never use callCC, it's equivalent to using Identity
08:14:18 <johnw> (or something along the lines of callCC)
08:14:18 <bollu> what specifically is the "next step in the computation" ?
08:14:23 * frerich thought Boost.Spirit was a test suite for exercising a compiler's support for operator overloading
08:14:24 <johnw> that's the "k"
08:14:35 <johnw> just keep trying other examples for a while, and reading articles on the web
08:14:46 <hackrilege_> Hi! today im hacking a glut example. it is a viewer which calls a function which modifies the state of the image. hawever, this image state is a compressed version of the whole system (it is a 2d slice), i dont want the viewer to call the function which modifies the state anyway, id prefer the thing that does to pass the result to the viewer. I was
08:14:46 <hackrilege_>  thinking perhaps this is what IORef is for. Iv never used that, but maybe it is the correct way to be able to check the contents of another threads memory state?
08:14:51 <johnw> I think we might be at the limit of IRC to convey intuition
08:15:09 <johnw> frerich: the bonus is that it's exactly that as well :-)
08:15:29 <bollu> I guess you're right about the intuition bit :) And honestly, I think I just need to keep messing with this until I grok it :P
08:16:09 <bollu> johnw: can you construct an "interesting" callCC example for me with only Cont and not ContT? or is that not possible?
08:16:54 <johnw> bollu: read http://blog.ezyang.com/2010/02/nested-loops-and-continuation/
08:17:22 <hackrilege_> can i use IORef to perform cross thread communication? if so, is that the best way?
08:17:30 <johnw> ignore the "print" if you want it to be Cont intsead of ContT
08:17:44 <johnw> hackrilege_: better to use a TVar in most cases, in my opinion
08:17:50 <merijn> hackrilege_: Sure
08:17:53 <bollu> thanks :)
08:18:04 <merijn> hackrilege_: "Best" depends on definition
08:18:31 <hackrilege_> im not sure what considerations go into deciding what is best in this context
08:18:55 <merijn> hackrilege_: It depends on what kind of cross thread communication you want to do
08:19:51 <hackrilege_> basically just ask "hey, its been one 3oth of a second, i need a new frame to animate, what is your state? (is returned a list of coordinates)"
08:21:17 <hackrilege_> i guess a to forkIO [1..] and get the other thread to quiry the process to see how far it has counted...
08:21:28 <hackrilege_> toy*
08:21:41 * hackagebot container 1.0 - Containers abstraction and utilities.  https://hackage.haskell.org/package/container-1.0 (danilo2)
08:22:03 <bollu> question: is there an easy way to parallelise an fmap operation? (like, some kind of a 1-liner)
08:22:35 <merijn> bollu: Maybe, IO or just "regular" code?
08:23:08 <hackrilege_> merijn, did that help?
08:23:11 <merijn> bollu: For IO look into the async library, for "regular" pure code look at Control.Parallel.Strategies
08:23:21 <bollu> merijn: regular code mostly
08:23:37 <bennofs> Is it possible to pass a flag to cabal only for the non-profiling version?
08:23:50 <merijn> hackrilege_: And what if you miss an update? Do you basically want to only read the "latest" state for your frame and skip any frames you missed?
08:23:59 <dcoutts> bennofs: yes, by also specifying ghc-prof-options
08:24:02 <bennofs> I would like to use -ddump-simpl -ddump-to-file to dump core, but it's currently overwritten when compiling the prof version
08:24:37 <hackrilege_> yes skip all missing frames. i guess they would be garbage collected, at least i hope so as they will be gb's per timestep...
08:24:40 <bennofs> dcoutts: oh, so on the command line, can I use --ghc-options="foo" and --ghc-prof-options="bar", and "bar" overwrites "foo"?
08:24:53 <dcoutts> bennofs: ie specify ghc-options: $normal $special, and ghc-prof-options: $normal
08:25:11 <merijn> acomminos: Then just using an IORef where one thread reads and the other writes should be the cheapest/simplest way, I think
08:25:11 <dcoutts> bennofs: actually I'm not sure there is a command line equivalent
08:25:14 <hackrilege_> so perhaps [1..] is confusing i think i mean iterate (+1) 0
08:25:56 <dcoutts> bennofs: the command line is just a generic "pass these options to this exe every time" mechanism. It doesn't know anything about the particular programs or context. It's purely the equiv of using a wrapper script.
08:26:09 <hackrilege_> so id like to provide a method such as iterate' that will return a type which i guess will be IO, which I can query from the other thread
08:26:41 <c_wraith> Hackri
08:27:16 <hackrilege_> could we get an example of this in action?
08:27:20 <c_wraith> hackrilege_: do you want an IO action to query the current value from another thread? 
08:27:27 <hackrilege_> no
08:27:29 <fosterite> how do I find the latest stackage lts with a certain base version?
08:27:49 <bennofs> dcoutts: aw, that means I have to put these in the .cabal. Well, probably not too bad in this case, since it's an application which is never going to be on hackage, and generating these files doesn't do any harm
08:28:02 <hackrilege_> no frp. its all deterministic. i dont need the effects of IO, so i guess it should just be some funky Monad
08:28:07 <dcoutts> bennofs: yes, it's a bit of a hack, sorry.
08:28:19 <c_wraith> fosterite: well, the version of base is always pinned to the version of GHC... 
08:28:27 <dcoutts> bennofs: otherwise you can build just the prof or just the normal
08:28:38 <dcoutts> bennofs: and/or one then the other
08:28:40 <bennofs> dcoutts: how does that work for a lib?
08:28:46 <fosterite> c_wraith: is there a way to search lts versions by GHC version?
08:29:05 <dcoutts> bennofs: --disable-library-vanilla --enable-library-profiling    or other similar combos
08:29:20 <c_wraith> fosterite: no idea. I don't much like the way stack works, so I don't use it 
08:29:20 <bennofs> dcoutts: ah, that means I have to reconfigure
08:29:40 <Ankhers> c_wraith: Can I ask why you do not like about how stack works?
08:29:59 <Ankhers> s/why/what
08:30:06 <bennofs> dcoutts: btw, it seems that the ghc-options get passed to ghc even for a prof build
08:30:19 <hackrilege_> does anyone know if this "how many times has this infinite loop been called" example has been treated in an example somewhere in haskell?
08:30:33 <hackrilege_> like, a link
08:30:41 <dcoutts> bennofs: iirc, they get passed to both, but the ghc-prof-options (if present) override
08:31:03 <bennofs> dcoutts: ah, unfortunately, there doesn't seem to be a -dno-dump-simpl flag to disable -ddump-simpl again :(
08:31:25 <bollu> why is there no parFilter?
08:31:33 <hackrilege_> could someone work through it with me?
08:31:41 <dcoutts> bennofs: oh ok so I'm misremembering. I thought it would not pass the ghc-options if the ghc-prof-options were specified at all. Ok. sorry.
08:32:39 <c_wraith> Ankhers: stack feels like a poor workaround to a problem I don't have. I can solve my own problems, and I'd rather not give up flexibility and control to do it. 
08:33:42 <Ankhers> c_wraith: What kind of flexibility and control do you lose? (Sorry if this is a dumb question, I do not really have experience with it)
08:34:20 <c_wraith> Ankhers: the ability to use whatever package versions you want. 
08:34:41 <bollu> why can't I filter in parallel using Control.Parallel.Strategies?
08:34:43 <Ankhers> c_wraith: Fair enough. I have had that issue with stack. Thanks for the information.
08:34:56 <pyon> How do I reimplement `Data.List.permutations` so that, given `instance Ord Foo`, and `xs :: [Foo]`, with `xs == sort xs`, then `permutations xs == sort (permutations xs)` ?
08:35:32 <bennofs> dcoutts: Ah, I just found -ddump-file-prefix. Perhaps I can use that to make the prof version have a different prefix! :)
08:35:35 <quicksilver> > permutations [1,2,3]
08:35:38 <lambdabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
08:35:39 <varaindemian> difference between `all` and `and` functions?
08:35:40 <dcoutts> c_wraith: can I get you to beta test the nix-local-build branch of cabal-install? :-)
08:35:44 <byorgey> pyon: so you want the permutations in lexicographic order?
08:35:46 <dcoutts> bennofs: cunning!
08:36:00 <pyon> byorgey: Yep!
08:36:06 <dcoutts> c_wraith: ok, more accurately, alpha test
08:36:42 * hackagebot hindent 4.5.7 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-4.5.7 (ChrisDone)
08:36:43 <c_wraith> dcoutts: I don't use anything nix. Though I probably should. Also, I'm far from a computer I can even test on right now. :) 
08:36:58 <dcoutts> c_wraith: oh sorry, the name is just because we're stealing nix ideas
08:37:12 <dcoutts> it's just cabal-install, not nix
08:37:25 <byorgey> pyon: one way is to write a function  select :: [a] -> [(a,[a])]  which makes all possible selections from a list, in order, e.g.   select [1,2,3] = [(1,[2,3]), (2,[1,3]), (3,[1,2])]
08:37:38 <c_wraith> dcoutts: oh, so it's like Janrain's build tool, keeping everything installed at once? 
08:37:44 <varaindemian> ?
08:37:47 <byorgey> pyon: then given a list, take the selections and for each one recursively generate permutations of the remaining elements
08:38:00 <pyon> byorgey: That much is easy: `zipWith3 foo <$> id <*> inits <*> tail.tails`.
08:38:11 <pyon> Where `foo x ys zs = (x, ys ++ zs)`.
08:38:15 <c_wraith> dcoutts: I would like to test that out, 
08:38:37 <dcoutts> c_wraith: I'm not aware of that to compare, but it uses the nix idea of a store, so yes it has full sharing of built packages between environments. So a bit like sandboxes but full sharing and less explicit setup.
08:38:50 <byorgey> pyon: nice
08:39:09 <byorgey> pyon: so does what I said after that make sense?
08:39:13 <dcoutts> c_wraith: and other nice things, like never having to re-run steps that obviously ought to have been re-run. stateless ui
08:39:35 <pyon> byorgey: Kind of... Processing it. :-)
08:40:19 <pyon> byorgey: I mean, intuitively it makes perfect sense. I want to recursively permute `ys ++ zs`. I'm just trying to see how to translate it to code.
08:40:41 <pyon> Recursively permute `ys ++ zs`, and then `fmap (x:)`.
08:40:51 <FireFly> varaindemian: well, how do their types differ?
08:40:57 <byorgey> pyon: A list comprehension actually works really well here
08:41:10 <pyon> Ah!
08:41:19 <byorgey> pyon: what you said works too (and is equivalent)
08:41:22 <pie_> this looks pretty interesting and its relatively recent too http://begriffs.com/posts/2015-06-28-haskell-to-hardware.html
08:42:11 * hackagebot amazonka-core 1.3.5.1 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.3.5.1 (BrendanHay)
08:42:13 * hackagebot amazonka 1.3.5.1 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.3.5.1 (BrendanHay)
08:42:15 * hackagebot amazonka-test 1.3.5.1 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.3.5.1 (BrendanHay)
08:46:31 <Ankhers> hackrilege_: http://lpaste.net/145503
08:47:11 * hackagebot cgrep 6.5.12 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.12 (NicolaBonelli)
08:49:25 <Ankhers> hackrilege_: Let me know if you have any questions about that.
08:49:52 <hackrilege_> Ankhers, awesome! thanks
08:50:14 <infandum> What is faster (and more standard): pattern matching (isVowel 'A' = True; isVowel 'B' = False; etc) or list searching (isVowel = flip elem "AEIOU")?
08:50:17 <hackrilege_> i was just trying to put one together, give me a sec ill check it
08:50:46 <hackrilege_> :t automatically
08:50:47 <lambdabot> Not in scope: ‘automatically’
08:50:59 <Ankhers> :t atomically
08:51:00 <hackrilege_> :t atomically
08:51:01 <lambdabot> Not in scope: ‘atomically’
08:51:02 <lambdabot> Not in scope: ‘atomically’
08:51:03 <quicksilver> infandum: pattern matching may be faster but I'd use list searching anyway.
08:51:28 <hackrilege_> what is atomically?
08:51:30 <infandum> quicksilver: Does one have an increased memory usage?
08:51:31 <quicksilver> infandum: when you have found out that it is a CPU bottleneck for your application you can experiment with other approaches :)
08:51:33 <Ankhers> STM a -> IO a -- hackrilege_
08:51:37 <hackrilege_> thanks
08:51:44 <Ankhers> https://hackage.haskell.org/package/stm/docs/Control-Monad-STM.html
08:51:47 <orion> When I try to compile my package with this customer builder, shake fails: http://lpaste.net/1934575556427251712 Does anyone know why? (Error is in paste)
08:51:47 <infandum> quicksilver: OK, good idea
08:52:56 <hackrilege_> i have a question about this unsafePerformIO stuff. im not sure since i do not wish to interact with the process, simply read it, im not sure if i need the efectual nature of the IO monad, is that correct?
08:53:33 <c_wraith> hackrilege_: if the value changes over time, that's wrong. 
08:54:07 <dcoutts> hackrilege_: I've not been following the discussion, but if you're not sure what you're doing, then using unsafePerformIO is wrong
08:54:11 <hackrilege_> its just (+1) its not like we cant predict what its going to do. its not dependant on inputs
08:54:14 <dcoutts> as is using unsafePerformIO in an application
08:54:23 <c_wraith> hackrilege_: like saying you don't need an IO action  to get the current time, because you're only going to read it. 
08:54:45 <hackrilege_> i dont want to use unsafe, just i would like to not have to use IO at any point unless it makes sense that i need to
08:55:15 <hackrilege_> which for me was at the point when it could not be predicted at compile time the outcome of the computation
08:55:19 <deepfire> what is a good example of a Haskell-parsing TH quasiquoter?
08:55:35 <tnks> Enum assumes there's always a valid succ and pred.  Is there something like Enum that doesn't assume a circular structure?
08:55:38 <c_wraith> hackrilege_: if you have multiple threads operating concurrently, it makes sense to need IO to communicate between them. 
08:55:46 <Ankhers> hackrilege_: The example I gave you did not use unsafePerformIO. What are you attempting to do that you think may need it?
08:55:56 <merijn> tnks: Where'd you get the idea that Enum is circular?
08:56:18 <merijn> tnks: The report explicitly states calling succ on the max value of a bounded Enum is bottom
08:56:23 <merijn> > succ (maxBound :: Int)
08:56:25 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
08:56:49 <hackrilege_> http://zvon.org/other/haskell/Outputprelude/Bounded_c.html
08:57:11 * hackagebot fasta 0.10.1.0 - A simple, mindless parser for fasta files.  https://hackage.haskell.org/package/fasta-0.10.1.0 (GregorySchwartz)
08:57:11 <tnks> merijn: ah, The Report. . . seems like a sloppy way to do things, though.
08:57:36 <tnks> does someone know of a type class without partials?  Otherwise I'm inclined to make my own.
08:57:51 <byorgey> hackrilege_: zvon.org is super, super out of date
08:58:03 <hackrilege_> yeh lol sry
08:59:40 <byorgey> tnks: I think most people would agree that Enum is ugly and poorly-designed
09:00:03 <byorgey> I do not know of a better replacement
09:00:49 <tnks> byorgey: okay, good to know, I just hate reinventing things so basic only to find out someone's figured it out nicely already.
09:01:51 <mpickering> Did something change in CPP processing between 7.6 and 7.8?
09:02:11 * hackagebot simple-session 0.10.1.0 - Cookie-based session management for the Simple web framework  https://hackage.haskell.org/package/simple-session-0.10.1.0 (AmitLevy)
09:02:39 <geekosaur> on os x by any chance?
09:02:44 <pyon> byorgey: So, this is what I have now: http://lpaste.net/145504 - I have no idea how I'd shorten this with a list comprehension, though. :-|
09:04:11 <mpickering> well my travis builds are complaining about lexical errors on 7.6 but not 7.8
09:04:29 <mpickering> https://travis-ci.org/mpickering/haskell-src-exts
09:05:05 <bitemyapp> mpickering: exciting that new releases are happening though :)
09:05:11 <drw77> When defining both a library and an executable file in a single cabal file (the executable simply exercises the functionality of the library), is it necessary to duplicate the build-depends section for each, or is there a syntax for telling cabal that the executable depends on the library?
09:05:31 <bitemyapp> mpickering: I know you're busy, but could I ask a question about haskell-srx-exts?
09:05:37 <mpickering> go on
09:05:44 <dcoutts> drw77: yes, you have two options: you can make the exe depend on the lib, or you can have the exe pick up the source files directly.
09:06:27 <drw77> dcoutts: i'd like to make the exe depend on the lib, but I can't see how to "name" the lib
09:06:42 <dcoutts> drw77: if you want to make the exe depend on the lib you need to say so in the build-depends and you need to arrange things so that the exe doesn't just pick up the source files directly, by separating the dirs and using hs-src-dirs to say where to look
09:06:55 <lpaste_> byorgey annotated “permutations” with “permutations (annotation)” at http://lpaste.net/145504#a145506
09:07:07 <byorgey> pyon: ^^^ here's my version
09:07:11 * hackagebot simple-session 0.10.1.1 - Cookie-based session management for the Simple web framework  https://hackage.haskell.org/package/simple-session-0.10.1.1 (AmitLevy)
09:07:12 <pyon> byorgey: Thanks, checking. :-)
09:07:46 <pyon> byorgey: Oh, of course! Thanks!
09:07:54 <byorgey> sure!
09:09:18 <byorgey> pyon: the key is to separate concerns, so select just returns a list of pairs.  This also makes select more generally useful.  In your version the 'bar' function does the selection and then immediately applies 'foo' to it
09:09:40 <byorgey> and 'foo' calls 'qux', which calls 'bar', so you have three mutually recursive functions tangled up
09:09:49 <byorgey> it's no problem for Haskell of course but makes it hard to refactor.
09:10:12 <bitemyapp> mpickering: what's the positioning of haskell-src-exts WRT GHC API?
09:10:22 <bitemyapp> mpickering: are you trying to be more universal? more stable? easier to use?
09:10:30 <bitemyapp> mpickering: more embeddable?
09:10:35 <Myrl-saki> @pl (\x ys zs -> (x, ys ++ zs))
09:10:35 <lambdabot> (. (++)) . (.) . (,)
09:10:38 <Myrl-saki> lol
09:10:41 <Myrl-saki> sweet jesus.
09:10:50 <bollu> johnw: ping, are you around?
09:11:38 <bollu> > let k = \num -> do y <- callCC $ \k -> if num > 10 then (k 0) else return (num + 1); return y in runCont k 1
09:11:40 <lambdabot>      Couldn't match type ‘Integer -> m0 Integer’
09:11:40 <lambdabot>                     with ‘ContT r Identity a0’
09:11:40 <lambdabot>      Expected type: Cont r a0
09:11:44 <drw77> dcoutts: I think I understand that concept, but have failed to get it working...I've looked at some of the "famously good" examples for guidance, but I think I'm getting lost in their complexity.  Do you know of a super simple example that I might be able to get my head around it?
09:12:00 <bollu> > let k = \num -> do y <- callCC $ \k -> if num > 10 then (k 0) else return (num + 1); return y in runCont (k 1)
09:12:01 <mpickering> well I think that people should use the GHC API if they can, the problem with depending on the GHC API is that most people support 3 versions of GHC which for anything non-trivial means lots of CPP.
09:12:02 <lambdabot>      No instance for (Typeable r0)
09:12:02 <lambdabot>        arising from a use of ‘show_M237487740686595733214388’
09:12:02 <lambdabot>      In the expression:
09:12:12 <mpickering> you don't have that problem with haskell-src-exts
09:12:18 <robtaylor> orion: having any luck with shake+cabal?
09:12:19 <bollu> > let k = \num -> do y <- callCC $ \k -> if num > 10 then (k 0) else return (num + 1); return y in runCont (k 1) id
09:12:20 <lambdabot>  2
09:12:42 <bollu> > let k = \num -> do y <- callCC $ \k -> if num > 10 then (k 0) else return (num + 1); return y in map (\x -> runCont (k x) id) [1..12]
09:12:44 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,0,0]
09:12:59 <glguy> bollu: You can play with lambdabot in /msg
09:13:06 <dcoutts> drw77: put your exe Main.hs (and any other files used only by the exe) in a subdir, and specify hs-source-dirs: theexe/  and of course specify build-depends: thelib, for whatever the lib is called
09:13:19 <pyon> byorgey: Yeah. I noticed that. I should've just used `zip3` instead of `zipWith3 something`. :-)
09:13:31 <lpaste_> byorgey annotated “permutations” with “permutations (annotation) (annotation)” at http://lpaste.net/145504#a145508
09:13:33 <mpickering> I talked for a bit with Simon and Neil about moving the GHC parser out into a separate package which would solve that problem
09:13:33 <bollu> glguy: sorry for spamming :) I wanted to explain what is happening to johnw/someone else who is okay with hearing me out on broken explanations :P
09:13:48 <byorgey> ^^^ for the record, here is another standard way to implement 'select'
09:13:50 <bollu> could someone hear my explanation for the behaviour of the code I wrote and tell me if I grokked it?
09:14:02 <johnw> bollu: hi
09:14:06 <pyon> byorgey: Ah!
09:14:07 <glguy> bollu: If you have questions about code it's better to format the code nicely and put it on lpaste
09:14:08 <mpickering> that would be better but the GHC AST has so much stuff in it so that package would be very big and make ghc dev harder
09:14:15 <johnw> yes, pastie pastie
09:14:35 <bollu> oh, will do!
09:16:17 <pyon> byorgey: Whoa, `select2` is pretty. Using both `inits` and `tails` indeed seems too heavy-handed.
09:16:37 <pyon> byorgey: And the use of (++) reinforces that.
09:17:10 <deepfire> is there a better way to parse Haskell (for the purpose of writing TH quasiquoter) than haskell-src-exts?
09:17:12 * hackagebot tateti-tateti 0.1.0.0 - Meta tic-tac-toe ncurses game.  https://hackage.haskell.org/package/tateti-tateti-0.1.0.0 (alvare)
09:18:30 <pyon> byorgey: Thank you! :-)
09:18:45 <mpickering> deepfire: Better in what sense? The best way is to use the GHC API
09:19:10 <Zemyla> Hmm, am I the only one who would tokenize a list before parsing it in Parsec, so I don't have to worry anywhere near as much about backtracking?
09:19:14 <deepfire> mpickering, is there a gentle intro for that?
09:19:26 <mpickering> haskell-src-exts might be sufficient for what you want though
09:19:30 <deepfire> mpickering, or, barring that, a not-so-gentle one?
09:19:52 <lpaste_> bollu pasted “cont-playground.hs” at http://lpaste.net/145510
09:20:08 <mpickering> deepfire: https://github.com/alanz/ghc-exactprint/blob/master/src/Language/Haskell/GHC/ExactPrint/Parsers.hs
09:20:14 <mpickering> You see how to there
09:20:32 <deepfire> mpickering, basically I want to have a variation on the very standard [e|...|]  -- but one, that wouldn't throw Not-In-Scope at unbound names -- which are, indeed, to be introduced by the very expansion of the form
09:20:34 <mpickering> but haskell-src-exts might be sufficient and it should work for most programs as of today
09:20:37 <johnw> bollu: what's the question?
09:20:56 <mpickering> I don't know anything about template haskell so can't comment sorry
09:21:01 <drw77> dcoutts: HA! my intuition was backwards...I've been trying to put the lib in a subdir and the exe in the root.  I reversed that as you described, and everything is working as I had hoped.  Thanks for your help.
09:21:07 <bollu> johnw: no real question, I wanted to explain what is happening to see if I understood it right
09:21:10 <deepfire> mpickering: I see, thank you!
09:21:16 <johnw> go for it
09:21:37 <dcoutts> drw77: that will also work, you just need them in separate dirs.
09:22:07 <dcoutts> drw77: and of course the hs-source-dirs field has to reflect how you've arranged things
09:22:38 <bollu> johnw: so, what's happening is that when x <- callCC $ \k -> … is called, the "k" represents the "short circuit" that I can use to kill the rest of the computation. i.e, calling (k <someval>) will cause the entire process to return <someval>
09:23:36 <johnw> I think so, based on my understanding of what you mean
09:23:54 <johnw> calling k leaves the callCC block and enters the 'return' after, after binding x
09:24:26 <johnw> "falling off the end" of the callCC block accomplishes the same thing
09:24:39 <johnw> so your return (num + 1) in this case is the same thing as k (num + 1)
09:25:04 <johnw> I think, let me verify that
09:25:14 <bollu> hmm
09:26:37 <johnw> you should really use trace on these examples
09:26:40 <bollu> okay, I assumed that calling "k" would exit the entire do block
09:26:42 <bollu> what does trace do?
09:26:44 <bollu> :t trace
09:26:45 <lambdabot> Not in scope: ‘trace’
09:26:49 <johnw> Debug.Trace.trace
09:27:30 <johnw> for example: https://gist.github.com/441fe854709757ad76f3
09:27:32 <bollu> isn't that a hole in the type system? :O I can print without IO?
09:27:39 <johnw> you'll see that "5" is printed in both cases
09:27:45 <johnw> yeah, it uses unsafePerformIO behind the scenes
09:27:55 <dart> hi 
09:27:58 <geekosaur> semiprincipled use of unsafePerformIO, yeh
09:28:23 <johnw> "k" only "short-circuits" the Cont block returned from callCC; it doesn't short-circuit the enclosing Cont action that calls it
09:28:52 <johnw> anyway, using trace on more examples will make it clearer
09:29:31 <bollu> johnw: yeah, now I realize what I was screwing up. so, basically, if you callCC, and you call the continuation that was passed to you with a value (i.e, k 0), then the entire return continuation will have the same value that you passed, right?
09:29:53 <bollu> I also need better names :) 
09:30:25 <johnw> the result value of "callCC ..." is either the value passed to 'k', or the value returned from that action
09:30:32 <dart> I'm playing with wai and http/2.0 server pushes, is something like this correct to keep the connection open and send a push every two seconds ? http://lpaste.net/145514
09:31:10 <johnw> bollu: and so, one common idiom for callCC, to allow for "early exit", looks like this:
09:31:30 <johnw> foo = callCC $ \exit -> do .....    <call exit with a value to short-circuit foo>
09:32:04 <bollu> huh, yeah, exit seems like a nice name for what it does
09:32:18 <johnw> 'k' is for (k)ontinuation :)
09:32:31 <bollu> johnw: now, remember you told me that you have *control* over the rest of the computation and you can, say, execute it twice or something? how does that work?
09:32:40 <bollu> johnw: oh, d'oh :) I feel stupid now
09:32:56 <johnw> so, you can pass any value to 'k' of type a
09:33:08 <bitemyapp> mpickering: that was helpful, thank you!
09:33:11 <johnw> so the argument to k could bundle up k itself :)
09:33:27 <johnw> and then the code outside the callCC block could call it again, and reiterate what it just did after the callCC block
09:33:51 <johnw> you can't just say 'k k' though, as that leads to an infinite type
09:34:00 <bollu> johnw: what do you mean by "the argument to k could bundle up k itself"?
09:34:10 <johnw> bollu: this is really a very advanced topic in using callCC
09:34:16 <bollu> right, so I was trying to use replicateM to fuse Cont monads together
09:34:26 <bollu> johnw: oh, so I should get a hang of the basics first?
09:34:33 <johnw> yes, definitely
09:35:35 <johnw> bollu: http://stackoverflow.com/questions/5193876/goto-in-haskell-can-anyone-explain-this-seemingly-insane-effect-of-continuation
09:35:44 <johnw> that URL is for when you find your sanity boring
09:35:49 <bollu> "seemingly insane" :P
09:36:45 <monochrom> my http://www.vex.net/~trebla/haskell/cont-monad.xhtml is better
09:36:54 <johnw> but this technique (or something roughly akin to it) is used by continuation-based streaming frameworks; by passing around the continuation as a value, they can defer resumption of the stream until the user is ready
09:37:45 <bollu> johnw: is this the whole "reinversion of control" thing?
09:38:49 <johnw> http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
09:38:54 <johnw> there is a lot of literature about this in the Scheme world
09:38:57 <dart> johnw: may i ask what is the difference between continuations and delimited-continuations and when one is better than the other ? 
09:39:23 <nani___> from learn you a haskell "This is like saying that we want to make all types of the form Maybe something an instance of Eq. We actually could have written (Maybe something), but we usually opt for single letters to be true to the Haskell style."
09:39:26 <dolio> Delimited continuations are always better. :)
09:39:39 <johnw> https://www.reddit.com/r/compsci/comments/20g6h2/whats_the_difference_between_a_continuation/
09:39:49 <johnw> http://stackoverflow.com/questions/6058959/difference-between-delimited-and-undelimited-continuations
09:40:03 <johnw> at some point, all roads lead to Oleg
09:40:06 <dart> johnw: thanks 
09:40:09 <bollu> down the rabbit hole again
09:40:11 <bollu> what's Oleg?
09:40:24 <johnw> you'll find him soon enough :)
09:40:37 <johnw> he's the end boss of the continuations game
09:40:50 <nani___> I am understanding everything in the book so far, but i think this one letter thing is tangling up my brain... I don't know if that even makes sense or if it gets better with time, I think it's the only problem I have so far
09:40:58 <bollu> wow, that's a lot he's written
09:41:21 <bollu> I feel so stupid most of the time when I sit down to learn haskell :)
09:42:18 <dolio> Why is 'something' better than 'a'? It just seems like more visual noise to me.
09:42:31 <dolio> Makes my eyes glaze over more.
09:42:34 <dmj> bollu: http://okmij.org/ftp/
09:42:34 <nani___> dolio, you're right, in this example it does nothing useful
09:43:18 <bollu> dmj: holy mother of god that is so much stuff
09:43:32 <nani___> in this it does though: treeElem x (Node a left right)
09:43:43 <Cale> nani___: You should find that pretty much all one-letter variables are bound within a short distance of all their usage sites.
09:44:08 <dmj> bollu: that's all Oleg :)
09:44:43 <Cale> nani___: In which case, you shouldn't need a better name, because the definition is staring at you. Also, these variables often refer to, for instance, values of a completely unknown type.
09:44:51 <Cale> So it's hard to give them a better name.
09:46:09 <nani___> mmm makes sense, thanks
09:46:15 <Cale> So, just from context there, I would guess that treeElem was a function that tries to determine if some value occurs in a binary search tree.
09:46:24 <monochrom> dolio: it gets better. 'foo' is also better than 'a'
09:46:30 <bollu> I've been trying to teach a friend of mine Haskell, and I don't know how/when to introduce typeclasses
09:46:41 <Cale> Here, x would be the value being searched for, and (Node a left right) is the tree we're searching through.
09:46:44 <dolio> monochrom: It is?
09:46:47 <bollu> like, do I show it to him immediately? do I explain Enums and Records first?
09:46:56 <Cale> So a is the value at the root of the tree, and left and right are its left and right subtrees
09:47:01 <monochrom> at the root I think programmers hate math and develop an allergy to single-letter names
09:47:18 <nani___> Cale, you are right
09:47:31 <nani___> monochrom, I like math but I'm a bit slow :)
09:47:44 <nani___> (and I will read the rest of the discussion but I need to go afk now :( )
09:47:48 <johnw> bollu: teach functions, ADTs and case matching first
09:47:50 <dolio> But math is just programming. :)
09:48:06 <johnw> start with the concrete before getting into the higher abstractions
09:48:31 <johnw> higher-order functions and lambdas alone deserve a lot of time and thought before getting to type classes, in my opinion
09:48:35 <monochrom> they religiously seek "meaningful" names; and when that fails, multiple-letter names so at least "it is a word"
09:48:37 <bollu> johnw: hm, but I can't show a lot of the "interesting: haskell bits
09:48:52 <johnw> bollu: but do they want to learn Haskell, or be impressed by Haskell?
09:48:52 <bollu> johnw: in my experience, people understand partial application easily
09:49:00 <bollu> johnw: good point :)
09:49:21 <merijn> monochrom: Really? Thinking of names is my least favourite thing about programming :\
09:49:35 <bollu> johnw: well, they don't know what to *expect* from haskell, so I think that maybe I'm trying to rush towards the cool bits
09:50:37 <johnw> then they'll expect it to be complex and hard to understand, I bet :)
09:50:47 <dolio> Yeah, thinking of names is hard. We have some code that broke in 7.10 because you can no longer use TH to generate definitions with illegal names (like 'class'), and I haven't fixed it yet because I have to come up with new names.
09:51:30 <bollu> johnw: :) hm, so you're right. I'll go slow and steady
09:51:46 <dolio> It's many times harder than complying with all the other changes in 7.10 and beyond. :)
09:52:07 <bollu> johnw: what I find hardest to convey is that the type signature "a", "b", etc are happening at the type level, while the function level "a", "b", .. are happening at the value level. My friend trips a lot on that
09:52:50 <Ankhers> bollu: This is anecdotal, but I believe it is better to show people the familiar. Show someone something boring that they can do in any other language. That will help prevent the notion that Haskell is hard and complex and can only be used by someone with a PhD is maths / CS.
09:53:24 <bollu> Ankhers: hm, yeah, that is fair.
09:53:39 <bollu> he seemed most impressed so far with global type inference :P
09:54:54 <Ankhers> I'm not in a teaching environment, so I cannot say that is 100% true. But it is generally how I show people Haskell that think it is scary.
10:06:29 <mpickering> Anyone have any ideas why CPP might fail with 7.4 and 7.6 but work find wth 7.8 and 7.10
10:10:47 <geekosaur> mpickering, on what platform?
10:12:12 <mpickering> whatever travis uses
10:12:14 * hackagebot dynobud 1.9.1.0 - your dynamic optimization buddy  https://hackage.haskell.org/package/dynobud-1.9.1.0 (GregHorn)
10:13:46 <Denommus> I've noticed stack can watch for file modification
10:14:30 <Denommus> is there a way for it to watch my files, interrupt the executable process, rebuild, and then restart the executable?
10:21:04 <breadmonster> Hey guys.
10:22:44 <tag> breadmonster, hey buddy
10:24:42 <pantsman-> hi
10:25:29 <suppi> hi breadmonster 
10:39:03 <bennofs> Wow, -dsuppress-uniques makes GHC core sooo much more readable! Why is not enabled by -dsuppress-all?!
10:40:11 <bennofs> Oh, I guess I should read the source code for reasons: https://github.com/ghc/ghc/blob/c61759d5917996a10b06a286eb5b776e4069e35c/compiler/main/DynFlags.hs#L2446-L2448
10:41:10 <P4Titan> Hello all, I have a data type Triplet a = Triplet a a a. I have this type implement functor and applicative to unite previous types I had of Vector and Color, each holding 3 same types internally. What would be the best way to retain the pattern matching and constructing of Vector and Color while on the inside have Triplet be their engine?
10:41:44 <mpickering> using a pattern synonym maybe
10:41:56 <P4Titan> what is that?
10:42:13 <mpickering> I don't have time to explain sorry, maybe someone else will
10:42:18 <mpickering> it is an extension to GHC
10:42:26 <P4Titan> I have type Vector = Triplet Double, but that retains neither pattern matching nor constructors
10:42:29 <P4Titan> ok
10:42:34 <P4Titan> I'll search it up
10:42:49 <mpickering> have "type Vector = Triplet Double"
10:43:02 <mpickering> and "pattern Vector a b  c = Triplet a b c"
10:43:08 <P4Titan> ok
10:43:10 <P4Titan> ty
10:43:30 <mpickering> but best to have a look at the manual
10:43:37 <P4Titan> will do
10:47:08 <bennofs> Anyone else ever wanted the following feature in cabal? Generate two binaries for each executable, where one is linked against the profiling version of a haskell library and the other is linked against the non-prof version. This would be extremly useful for benchmarks. Right now, I always need to switch back and forth between the two versions (requiring me to run configure again), since the profiling skews
10:47:10 <bennofs> benchmark results
10:47:42 <bennofs> or perhaps just compile benchmarks always in non-prof way as well?
10:52:12 <P4Titan> Regarding my pattern synonym question for Vector, how would retaining data Something = Something {v1 :: Vector}
10:57:20 * hackagebot incremental-parser 0.2.4 - Generic parser library capable of providing partial results from partial input.  https://hackage.haskell.org/package/incremental-parser-0.2.4 (MarioBlazevic)
11:05:56 <dustmote> bennofs: wouldn't it be better just to always build your dev versions with profiling turned on, and then have your distribution script build with optimization & no profiling?
11:06:31 <bennofs> dustmote: well, I want to do this while improving performance. Use the prof version to find bottlenecks, use the non-prof version to verify if a change improved perf
11:06:38 <bennofs> and repeat :)
11:06:41 <pie_> aw shet https://github.com/conal/lambda-ccc 
11:06:53 <pie_> this is the code wrt to the talk i linked, apparently it generates verilog
11:09:09 <dustmote> bennofs: perhaps i'm incorrect, but i've worked under the assumption that perf adds a small constant factor to execution time -> a measurable improvement in the perf version will translate to a measurable improvement in the non-perf version
11:10:10 <bennofs> dustmote: well, I don't think that is true in general. Some optimizations will only lead to improvements in the prof versions, since the call centre a) blocks a few optimizations GHC already does and b) introduce some additional costs for function calls etc
11:11:27 <dolio> Also building your profiling version with optimizations can easily lead to incomprehensible output.
11:13:56 <bennofs> dolio: oh really? I haven't had that experience. Also, profiling without optimization is even worse IMO, since that way you might end optimizing things that ghc can already optimize by itself
11:14:30 <dustmote> i'd assume optimizations and profiling aren't in the same bulid..
11:14:54 <dustmote> though i wouldn't want to waste time optimizing things that ghc optimizes..
11:14:58 <dustmote> hm.
11:16:05 <dolio> bennofs: I'm pretty sure I've had GHC move around cost centers and such when optimizations are on.
11:16:12 <dolio> Maybe it's gotten better about that.
11:16:20 <dolio> Or, the reporting for cost centers.
11:16:36 <bennofs> dolio: I thought GHC disables floating-out etc through cost centres. At least that's what I've read
11:16:49 <bennofs> perhaps that was different in the past, yeah
11:16:54 <dolio> I don't remember the specifics, as it was a while ago.
11:17:10 <dolio> I just remember the profiling output not making much sense in some example I had.
11:20:56 <mniip> what should I use to get subsecond precision time in haskell
11:21:43 <mniip> preferably microsecond, to match up with threadSleep
11:24:43 <phadej> mniip: getCurrentTime has pico precision at its best
11:25:07 <mniip> I don't need pico :v
11:25:14 <indigo945> Hi! I'm teaching myself FRP and am wondering why the collection switches (par, rpSwitch and friends) are missing from newer versions of Netwire
11:25:16 <mniip> I need something that would be compatible with threadSleep
11:25:20 <indigo945> What were they replaced with?
11:25:21 <mniip> er
11:25:23 <mniip> threadDelay
11:26:09 <phadej> mniip: the conversion from NominalDiffTime (difference of two UTCTime) shouldn't be hard to convert to whatever threadDelay takes
11:29:38 <tommd> It isn't hard.  "floor" for example...
11:34:11 <glguy> (\duration -> floor (duration * 1000000 {- µs/s -} )) :: NominalDiffTime -> Int
11:39:30 <ell> Hi
11:39:48 <jle`> hi ell
11:40:06 <jle`> did you know that you are related to superman
11:40:37 <ell> superman?
11:41:23 <jle`> yeah, kal ell
11:42:05 <ell> I don't know anything about superman besides the fact that he's neither a bird nor a plane :p
11:49:16 <ell> Okay
11:49:28 <ell> so can someone help me to print "1" with this? https://dpaste.de/3YiW
11:49:32 <ell> It's only 5 lines or so
11:49:46 <ell> but I have some fundamental knowledge gap 
11:50:31 <orion> Does anyone know how to specify libraries that need to be linked in when using a custom cabal builder?
11:50:32 <tzh> add1 returns a value, but you're ignoring it and reusing the x you bound to 0
11:50:33 <Ralith> ell: "IO Int" does not mean "mutable Int"
11:50:42 <Ralith> it means "IO action which returns an Int"
11:50:47 <Ankhers> ell: http://lpaste.net/145517
11:50:48 <Ralith> produces an*
11:50:59 <orion> I'm getting this error: dist/setup/setup.hs:2:8: Could not find module ‘Development.Shake’
11:51:24 <orion> I'm not sure how to tell cabal to include the shake library.
11:52:33 <Ankhers> ell: In Haskell, variables are immutable by default. That means you are unable to change the value it is holding once it is set.
11:52:36 <fresheyeball> ell: you can't, not that way
11:52:45 <ell> I can't mutate the variable?
11:52:52 <ell> man
11:52:52 <Ankhers> ell: So `add1' does not change the value that x holds.
11:52:58 <Ankhers> ell: You can, just not in that way.
11:53:02 <ell> How about with MVar?
11:53:02 <fresheyeball> ell: haskell does not have mutable variables
11:53:16 <Ankhers> fresheyeball: Yes it does. It just is not the default.
11:53:24 <fresheyeball> check out IOREF
11:53:47 <fresheyeball> @Ankhers I am pretty sure it does not have mutable variables
11:53:48 <lambdabot> Unknown command, try @list
11:53:53 <tmax6> hmm good to know
11:54:12 <fresheyeball> Ankhers: how do I make a mutable variable in haskell
11:54:13 <fresheyeball> ??
11:54:43 <Ankhers> fresheyeball: As you said, IORef
11:54:45 <Welkin> fresheyeball: IORef
11:54:55 <Welkin> fresheyeball: or MVar/TVar
11:55:10 <fresheyeball> Welkin IORef is NOT a mutable variable
11:55:16 <Welkin> fresheyeball: it is
11:55:21 <MarcelineVQ> is there conflation happening between variables and values
11:55:24 <Welkin> it is a mutable value
11:55:27 <fresheyeball> no, its mutable state
11:55:34 <Welkin> there are no variables in haskell
11:55:42 <fresheyeball> mutable state =/= mutable variables
11:55:48 <Welkin> only mathematical variables as function parameters
11:56:16 <fresheyeball> if IORef was a mutable variable, then it would violate reference transparency. 
11:56:23 <Welkin> nope
11:56:41 <fresheyeball> mutable variables are a language feature, mutable state is anther thing
11:56:56 <Welkin> fresheyeball: I don't understand what point you are trying to make
11:57:11 <Welkin> or if you are just bored
11:57:40 <fresheyeball> that haskell is not immutable by default, and then has a way of accessing mutable variables 
11:58:04 <KaneTW> i think he's saying that IORef is not the same as references in ML
11:58:21 <fresheyeball> F# is immutable by default, but has a `language keyword` called `mutable`
11:58:36 <fresheyeball> that allows you to reassign a variable to something different 
11:58:48 <fresheyeball> this is fundamentally different from a language perspective than IORef
11:58:53 <KaneTW> yup
11:58:54 <fresheyeball> where the value is wrapped in a monad
11:59:11 <johnw> "the value is wrapped in a monad" <-- does not compute
11:59:11 <fresheyeball> and referential transparency is maintained
11:59:35 <fresheyeball> IORef is a value that is not every directly accessible 
11:59:39 <fresheyeball> since IO is not a comonad
11:59:58 <KaneTW> SML/Ocaml have `ref`, which is why they require value restriction or something similar
12:01:05 <fresheyeball> you can't just get at the value, you have to use >>= or do notation 
12:03:02 <akfp2> wouldn't it make sense to have a lambda-case where there was an implicit <akfp2> using stack, how can I patch a specific package, say servant-client?
12:03:02 <akfp2>         I want to add some debug message.                               [08:54]
12:03:02 <akfp2> *** besenwesen (~besenwese@unaffiliated/besenwesen) has quit: Quit: ☠
12:03:02 <akfp2> *** radens (~kronquii@osuosl/staff/muricula) has left channel #haskell:
12:03:06 <akfp2>     "WeeChat 1.0.1"
12:03:09 <akfp2> *** Itkovian (~Itkovian@zorspro.ugent.be) has joined channel #haskell
12:03:12 <akfp2> *** kritzcreek (uid114400@gateway/web/irccloud.com/x-vtnglbbfmdyunxbl) has
12:03:16 <akfp2>     joined channel #haskell                                             [08:55]
12:03:16 <akfp2> *** Laserbear (~Laserbear@c-73-223-160-142.hsd1.ca.comcast.net) has quit:
12:03:19 <akfp2>     Remote host closed the connection
12:03:23 <akfp2> *** Laserbear (~Laserbear@c-73-223-160-142.hsd1.ca.comcast.net) has joined
12:03:23 --- mode: ChanServ set +o dolio
12:03:25 --- kick: akfp2 was kicked by dolio (akfp2)
12:03:31 --- mode: dolio set -o dolio
12:04:57 <akfp2> I am thinking that I want a lambda-case with a default match that ends up as empty, mzero, or mempty.  Unfortunately there is no typeclass unifying empty, mzero, and mempty (I think).  Does this make sense?
12:06:28 <ell> I need to use IORef then?
12:06:43 <ell> meh I don't know how I can achieve what I want
12:06:49 <ell> I'll tell you what I want to achieve
12:07:21 <Welkin> there are always a million ways to do something
12:07:28 <Welkin> choose what is best given your situation
12:08:44 <ell> Okay, so I have a GLUT window
12:08:50 <ell> in the display callback some rendering is done
12:09:06 <ell> I want to update state between rendering frames
12:09:28 <indigo945> ell: newState <- func oldState, then recurse on your main loop
12:10:51 <ell> recurse on my main loop?
12:11:01 <ell> as in call the display function inside the display function?
12:11:11 <ell> I'm not sure if that works because I think at the end of the display function the buffers are swapped
12:11:18 <ell> but I'll have a look
12:11:48 <Welkin> ell: why is your rendering at all tiedto your state update?
12:11:51 <Welkin> they should be independent
12:13:15 <ell> Well, I haven't written any code yet
12:13:21 <ell> I agree that they *should* be independent
12:13:50 <Welkin> if you have not written anything yet, why are you asking questions?
12:14:01 <Welkin> start exploring your options by writing the program
12:14:06 <indigo945> ell: like that http://ideone.com/yUfQPf
12:14:08 <ell> Well, I have some code
12:14:09 <Welkin> just write the minimal thing that does what you want and go from there
12:14:10 <ell> but no stateful code
12:14:11 <tzh> ell: iirc the GLUT bindings are fairly explicitly designed w/ the expectation that you use some kind of mutable variable (or value, depending on how pedantic you're feeling) to pass state around
12:14:26 <indigo945> Welkin: I think ell doesn't have any idea on how to get there tbh, so let's be nice here
12:14:27 <tzh> since basically every callback is just `IO ()`, which leaves you little other option
12:14:35 <ell> I'm just not sure where to go from there 
12:14:42 <ell> thank you I'll check out that link
12:15:09 <Welkin> it doesn't need to be mutable state
12:15:14 <Welkin> especially if you are just learning
12:15:28 <Welkin> you can have a main loop that takes the inputs and the current state as parameters
12:15:47 <indigo945> I agree, but to FP newbs it's hard to convey that they don't need state -- for that matter, that's what my example code does
12:15:49 <Welkin> then it calculates a new state and calls itself with the updated state and new inputs
12:16:24 <suppi> ell, what are you trying to do with your code?
12:16:51 <tzh> Welkin: the GLUT bindings manage the main loop and periodically call programmer-provided callback functions that are all `IO ()`, so manually doing the recursion isn't even an option
12:17:12 <ell> suppi: I want to draw a line that moves upwards one pixel every frame
12:17:35 <Welkin> why use glut?
12:17:40 <tzh> (which is why i don't use the GLUT bindings since that's... really not a great setup for idiomatic haskell code)
12:17:41 <Welkin> sounds like that is your problem
12:17:50 <indigo945> ell: yeah I think you should use something like gloss
12:17:51 <ell> Welkin: It's part of the assignment
12:17:53 <Welkin> I would use SDL
12:17:58 <ell> I don't have a choice unfortunately :S
12:17:59 <indigo945> It's more FRP and easier to get for beginners
12:18:01 <Welkin> super easy to set up
12:18:02 <indigo945> oh, I see
12:18:13 <ell> Apparently mainLoop takes a MonadIO
12:18:23 <suppi> ell what does your current code looks like?
12:18:24 <ell> I ought to be able to put something stateful inside there, right?
12:19:42 <tzh> i think what i did in that kind of situation was generate some STM value in main, and then write update/render functions that took a stm value and returned IO (), so i could pass around state that way
12:19:57 <tzh> it's kind of ungainly but it worked at the time! :V
12:20:12 <loxs> I am hugely confused as to which package manager to use (already have stack), how to install ghc (already have it for stack, but I don't know how to make it work system wide). I am an emacs user and I'd like to setup that as well. Is there some tutorial for newbies? I'm using mac os
12:21:25 <ell> suppi: I realise how absurd this sounds (seeing as I'm asking for help) but I'm not allowed to provide code :S
12:21:27 <Welkin> loxs: stack and cabal are not package managers
12:21:40 <ell> here is the gist of it: https://dpaste.de/4uNT
12:21:43 <loxs> Welkin, right, that probably proves as to how confused I am :)
12:21:55 <Welkin> loxs: all you need to get started are to either use stack to install cabal-install and ghc, or manually install ghc and cabal-install
12:22:00 <suppi> ell, are you forced to learn haskell or something? :) how are you learning?
12:22:26 <Welkin> loxs: if you don't use stack, then you must use cabal sandboxes (or else pay the price)
12:23:03 <ell> suppi: I am enjoying learning haskell, it is mandatory but I would do it if it weren't anyway
12:23:05 <Welkin> loxs: after using stack now for a couple months, it seems that it is the way to go for new users (and experienced users) most of the time
12:23:20 <ell> I've just never used the GLUT library before and monads are still new to me
12:23:36 <ell> The only way I know how to do state is with recursion like welkin suggested initially
12:23:42 <suppi> ell, is there anything in specific that we can help clear up with the concepts?
12:23:44 <frontendloader> an ERP system in haskell called HERPES
12:23:45 <loxs> Welkin, why do I need cabal-install?
12:24:39 <Welkin> loxs: hm, actually I don't know if you need it with stack, but for yesod you need it
12:24:42 <ell> suppi: yes there is - IO () represents something which performs an IO action and returns nothing, right?
12:25:00 <suppi> ell, returns (). basically, yes.
12:25:30 <loxs> Welkin, it'll be some time till I start writing web stuff... for now I just want to do simple exercises and make emacs work with haskell
12:25:45 <ell> suppi: It seems that IO is everywhere - even places where no IO takes place, this confuses me :S
12:25:49 <Welkin> loxs: just use melpa to install haskell-mode
12:25:54 <suppi> ell, actually, IO () is a something that returns () and may also do something else when executed
12:26:06 <Ankhers> loxs: There is a haskell-mode (https://github.com/haskell/haskell-mode) which is quite handy.
12:26:11 <tzh> ell: the various low-level gl bindings for haskell are really weird and kind of jarring compared to the way people are "supposed" to write haskell, which is part of why this specific thing is such a challenge. in the gl bindings a `IO ()` type usually means "this is a call to a gl function in a C lib somewhere"
12:26:12 <ell> like here for instance: https://goo.gl/qP92o0
12:26:51 <ell> tzh: Hmm I see
12:27:05 <tzh> ell: in that case it's because you're expected to provide some io that doesn't return a result (hence the ()) but does do a bunch of IO side-effects (i.e., rendering)
12:27:17 <mniip> how do I do 'bracket' in MonadIO?
12:27:18 <suppi> ell, well, you can think of IO () as an recipe
12:27:48 <suppi> ell, "this is something that returns () and may do some additional things when run"
12:28:32 <ell> tzh: It would be nice if I could return a new state that I can read next time
12:28:53 <fresheyeball> ell: you could use the State Monad
12:29:03 <tzh> ell: well ideally you'd be doing your updating somewhere other than the rendering function
12:29:04 <suppi> ell, you can use IORef
12:29:32 <ell> tzh: where should I do my updating?
12:29:36 <ell> I agree that in the render function isn't good
12:29:43 <robtaylor> hrm, is stack broken for lts-2.22 ?
12:30:16 <Welkin> robtaylor: that sounds very old
12:30:17 <tzh> ell: with the glut bindings... i don't know if provide any kind of automated updating callback, but there, if they do.
12:30:22 <suppi> https://wiki.haskell.org/OpenGLTutorial1 this might help ell
12:30:32 <robtaylor> Welkin: its ghc 7.8.4
12:30:39 <tzh> ell: although you did say you wanted to make a thing that changed "every frame", so maybe for this doing the updating in the rendering function would be fine
12:30:55 <suppi> ell,  or this https://wiki.haskell.org/OpenGLTutorial2
12:31:01 <Welkin> robtaylor: well, I have had problems with stackage in the past, not recently though
12:31:12 <ell> tzh: well, not necessarily every frame
12:31:16 <ell> I should have said "over time"
12:32:30 <tzh> ell: one of the things you can do is write your display function as `display :: TVar GameState -> IO ()`, and then generate a tvar in main and give that to the callback
12:32:33 <tzh> http://hackage.haskell.org/package/stm-2.4.4/docs/Control-Concurrent-STM-TVar.html
12:32:55 <suppi> specifically this might help https://wiki.haskell.org/OpenGLTutorial2#Animation
12:33:30 <tzh> yeah that link suppi posted has it: 
12:33:32 <tzh>   angle <- newIORef 0.0
12:33:32 <tzh>   displayCallback $= display angle
12:33:57 <tzh> lets you pass some mutable state to the display callback, by using a mutable variable
12:34:01 <robtaylor> appears that stack is passing 'exe:<executable name>' to cabal setup (1.18.1.5) and it doesn't like that
12:34:38 <dcoutts> robtaylor: that's odd, since that is the syntax that cabal/setup build accepts
12:34:58 <ell> Isn't using IORef frowned upon?
12:35:08 <ell> or is it not possible to avoid bad code using the GLUT bindings
12:35:10 <ell> ?
12:35:45 <robtaylor> dcoutts: setup: Unrecognised flags: exe:aschem, exe:eTeak, exe:eTeak-runtime
12:35:49 <suppi> ell, as far as I can see from looking at it right now, GLUT is based around callbacks
12:36:01 <robtaylor> dcoutts: --  While building package eTeak-0.4 using:
12:36:05 <suppi> ell, I don't really see how you can escape mutable state when using callbacks
12:36:07 <tzh> mostly the latter. the GL/GLUT bindings are basically a direct transliteration from C to haskell, so they're very very heavy into mutating the global GL machine to achieve your goals
12:36:10 <robtaylor> dcoutts: /home/robtaylor/projects/reconfigure.io/eTeak/.stack-work/dist/x86_64-linux/Cabal-1.18.1.5/setup/setup --builddir=.stack-work/dist/x86_64-linux/Cabal-1.18.1.5/ build exe:aschem exe:eTeak exe:eTeak-runtime --ghc-options " -ddump-hi -ddump-to-file"
12:36:37 <akfp2`> how do you rate-limit your servant-client APIs?
12:36:49 <tzh> this isn't ideomatic haskell, but it's basically what you gotta do. there are some higher-level graphics libraries around that i think abstract some of that away, but i don't think many of them are that "production-ready" currently
12:36:55 <suppi> ell, so yeah, this is not idiomatic haskell, but if you can't really escape using glut you don't have much choice
12:37:23 * hackagebot envy 1.1.0.0 - An environmentally friendly way to deal with environment variables  https://hackage.haskell.org/package/envy-1.1.0.0 (DavidJohnson)
12:37:25 * hackagebot hsimport 0.7 - A command line program for extending the import list of a Haskell source file.  https://hackage.haskell.org/package/hsimport-0.7 (DanielTrstenjak)
12:37:31 <ell> Okay cool
12:37:33 <ell> thanks very much
12:37:35 <ell> I'll try it out
12:37:39 <suppi> ell, good luck
12:37:43 <Welkin> akfp2`: ask in #servant
12:38:06 <robtaylor> dcoutts: any ideas? :)
12:38:58 <dmj> akfp2: you do so with middleware, not a servant thing per se
12:39:01 <Ankhers> robtaylor: In the future, that may be better placed into a paste.
12:39:06 <dmj> @package wai-middleware-throttle
12:39:06 <lambdabot> http://hackage.haskell.org/package/wai-middleware-throttle
12:39:10 <dmj> akfp2: ^
12:39:32 <dcoutts> robtaylor: trying a couple things. setup build reports a different error message when I try that syntax (that the components are unknown)
12:39:49 <robtaylor> Ankhers: ack
12:40:09 <dmj> akfp2: so let app = serve api handlers in run port (throttle def throttler app)
12:40:37 <robtaylor> dcoutts: ah, I think this might be a CustomBuild issue. I've just realised I've seen something like this before
12:41:23 <loxs> LYAH seems to be about ghci 6.8.2 and I have 7.10.2. Will I run into troubles and should I downgrade?
12:41:41 <albertus1> i don't think so
12:42:13 <albertus1> (though i only read lyah without actually trying out the examples)
12:42:45 <dcoutts> robtaylor: sorry, out of ideas, except if you can check what args actually get passed, in case there's some escaping oddity.
12:42:53 <Welkin> loxs: LYAH doesn't have any great example anyway
12:43:05 <dcoutts> robtaylor: with that version of Cabal, I can only get sensible error messages out, not that flags one.
12:43:08 <albertus1> it's about the concepts, and all of them are still very valid
12:43:16 <loxs> Welkin, is there a better tutorial?
12:43:35 <Welkin> robtaylor: do you have cabal-install already installed and on your path? that can cause problems
12:43:45 <Welkin> loxs: the cis course
12:43:51 <Welkin> @where learnhaskell -- loxs 
12:43:51 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:43:57 <Welkin> and others
12:44:20 <joco42> why does ghc have no stack trace ?
12:44:35 <joco42> and what is the approx in https://www.reddit.com/r/haskell/comments/2fwwx3/how_to_get_approx_stack_traces_with_profiled/ ?
12:44:40 <joco42> why approx ?
12:44:57 <robtaylor> Welkin: doesnt seem so
12:45:13 <Welkin> haskell doesn't have a call stack
12:45:44 <edwardk> Welkin: sure it does, it just doesn't look like what you expect
12:46:01 <Welkin> hello edwardk 
12:46:14 <albertus1> as long as you compile your haskell into the von-neumann architecture, it will most likely have a call-stack
12:46:36 <joco42> i mean.... why ?
12:46:38 <robtaylor> dcoutts: thanks :) it appears that running 'setup build' with anything causes an error. I've seen something before in a bug or stackoverflow where a custombuild causes issues with the passing of the command line. just got to find it again!
12:46:46 <Welkin> I never investigated it myself, but I have always been told that there is no call stack, only a stack for placing unmatched patterns
12:46:54 <dcoutts> robtaylor: ah ok
12:46:59 <joco42> is it 1) lazyness 2) tail call optimization or what ?
12:47:06 <edwardk> albertus1: ghc actually has its own stacks, it doesn't use the c stack for much of anything, but the stack follows the flow of what i demanding what, not what calls what in the surface language. it is demand driven, but very much connected to the syntactic flow of your code at all
12:47:13 <robtaylor> dcoutts: https://github.com/haskell/cabal/issues/2375 :)
12:47:32 <edwardk> er what is demanding what
12:47:32 <albertus1> i'm not thinking of c anyway, i'm thinking cpu directives
12:47:38 <dolio> No, it doesn't have a "call stack".
12:48:14 <edwardk> albertus1: ghc basically leaves the CPUs stack pointer alone, and just jumps to new instruction sequences
12:48:14 <robtaylor> dcoutts: bugger, doesn't seem like there's a workaround though :/
12:48:27 <dcoutts> robtaylor: except to use a later Cabal lib version
12:48:30 <joco42> say i have a chain of functions super=f .g . h . j .k . l . m . n . o 
12:48:36 <joco42> then i apply super to 1
12:48:37 <geekosaur> joco42, as I tried to tell you the last time you asked this, it is non-strict evaluation. your code may not actually run until somewhere completely different, so even if you could get a "normal" stack trace it would be completely meaningless
12:49:08 <joco42> so what is https://www.reddit.com/r/haskell/comments/2fwwx3/how_to_get_approx_stack_traces_with_profiled/ giving then geekosaur  and what will ghc 8 give then _
12:49:10 <joco42> _
12:49:23 <joco42> ?
12:49:24 <joco42> :)
12:49:24 <edwardk> a c-- expression typically ends with possibly modifying the "haskell stack" and then a jump to another sequence of instructions.
12:50:06 <dolio> It's not just to do with lazy evaluation, either.
12:50:13 <joco42> https://phabricator.haskell.org/D861
12:50:22 <joco42> geekosaur:  ^
12:50:24 <geekosaur> joco42, ghc 8 is adding a hidden ("implicit parameter" mechanism to carry the stack trace around to where it is actually used. 7.10 actually has part of that in place already. 7.8 is abusing profiling information, which you can do now... but in part it works because profiled code behaves differently
12:50:50 <dolio> Any good functional language will eliminate tail calls, so the "call stack" will have less information than a language like Java.
12:51:00 <dolio> What lazy evaluation does is make all calls tail calls.
12:51:10 <joco42> geekosaur:  but the profiled code does the same thing as a non profiled or not ?
12:51:11 <edwardk> in other news, this unagi-chan stuff looks interesting. i was just building something similar but not as smart
12:51:32 <geekosaur> joco42, some optimizations do not happen, and it's doing extra accounting
12:51:38 <edwardk> https://hackage.haskell.org/package/unagi-chan
12:52:08 <joco42> geekosaur:  yeah, but aside from that it is the same algorithm right ?
12:52:34 <akfp2`> thanks!  but I need it for servant-client, not wai
12:52:55 <akfp2`> dmj: ^^
12:52:56 <dolio> Any good OO language will also eliminate tail calls, too, of course. There just aren't many of them.
12:53:22 <arw> sounds like 'no true scotsman' ;)
12:53:46 <tdammers> OO and whether or not TCO is useful are orthogonal
12:53:51 <joco42> geekosaur:  so if the stack trace is meaningless then why are people working hard to get one into ghc 8 ?
12:53:58 <lyxia> Is there an "or pattern" extension somewhere ? f (C1 a b|C2 a b) = g a b
12:54:06 <edwardk> joco42: because not everyone agrees ;)
12:54:17 <joco42> oh....
12:54:18 <joco42> me
12:54:19 <joco42> y
12:54:25 <geekosaur> joco42, I said the "normal" ("naive" really) stack trace
12:54:27 <Ankhers> lyxia: Alternative
12:54:35 <dolio> I don't agree that they're orthogonal.
12:54:46 <edwardk> the naive stack trace is useful for figuring out what you wrote that did the bad thing
12:54:48 <geekosaur> as I *also* said, ghc 8 is carrying around extra information behind your back to make a somewha5t more meaningful stack trace
12:55:07 <lyxia> Ankhers: Sorry?
12:55:27 <dolio> But that probably isn't relevant to this channel.
12:56:04 <Ankhers> lyxia: I think you are asking about the Alternative typeclass.
12:56:13 <Ankhers> lyxia: Unless I misunderstood the question.
12:56:16 <robtaylor> dcoutts: thanks! 'stack setup 7.8.4 --upgrade-cabal' did the job
12:56:20 <geekosaur> (specifically, it's passing an "implicit parameter" to functions to keep track of it, when a naive stack trace would lose it)
12:56:24 <joco42> geekosaur:  so how are naive and non naive stack traces differ ? for example for super= f .g .h , super applied to 1
12:56:48 <joco42> geekosaur:  you just unswered what i asked....
12:56:52 <joco42> at the same time
12:58:12 <lyxia> Ankhers: I'm asking about a certain kind of pattern. Given "data T a b = C1 a b | C2 a b | ...", and for some reason you want to define a function which behaves the same on C1 and C2, you must currently write f (C1 a b) = g a b ; f (C2 a b) = g a b, which leads to some amount of duplicated code.
12:58:14 <geekosaur> anyway the point is that part of that may actually *happen* at a completely different point and be a pointer sitting in an evaluation stack otherwise. you'd never see that with a stack trace. the implicit parameter mechanism would track that
12:58:26 <joco42> so, then https://phabricator.haskell.org/D861 is the same as https://www.reddit.com/r/haskell/comments/2fwwx3/how_to_get_approx_stack_traces_with_profiled/ ?
12:58:37 <geekosaur> no
12:59:17 <geekosaur> you can abuse profiling information, at considerable expense, right now. the implicit parameter stuff is not as expensive and works without enabling profiling
12:59:17 <joco42> but in terms of stack trace produced?
12:59:37 <joco42> i mean modulo performance
12:59:37 <geekosaur> and should be able to provide more information; I believe it has source information, for example
12:59:41 <geekosaur> (file/line)
12:59:43 <joco42> hmm
12:59:44 <joco42> ok
12:59:45 <joco42> nice
12:59:59 <geekosaur> whereas profiling can only give you a name, and sometimes that name won't be meaningful
13:00:09 <joco42> ok
13:00:10 <geekosaur> (lambdas don't have names)
13:00:12 <akfp2`> is there a stack channel? "stack ghci" give me (on OS X): clang: error: cannot specify -o when generating multiple output files
13:00:55 <ell> thanks for all the help guys, time to sleep for me
13:01:34 <joco42> geekosaur:  thanks , that is enlightening
13:01:38 <joco42> info
13:01:50 <joco42> off to sleep, talk later
13:02:21 <Ankhers> lyxia: something like http://lpaste.net/145519 ?
13:03:15 <lyxia> Ankhers: Yeah that's another solution, but it doesn't cover all use-cases.
13:03:24 <lyxia> Like nested or-patterns
13:03:51 <lyxia> I mean, what if some alternative is made of several constructors
13:05:03 <Ankhers> lyxia: Unfortunately, I am unsure about that. Someone else may have some ideas.
13:06:55 <akfp2`> scala has PartialFunction.  Would it make sense to have some lambda-case syntax based on Monoid/Alternative/MonadPlus that injects a default case? Like (\case of Just a -> Just a) Nothing evaluate to Nothing?  Desugaring as (\x -> case x of Just a -> Just a; _ -> mempty) Nothing
13:08:30 <Welkin> akfp2`: maybe id id
13:09:40 <akfp2`> Welkin: the point is to be able to pattern match on something and default on the rest.
13:10:06 <lyxia> OCaml has or-patterns, they come into use occasionally, and I am surprised that I never heard of such a feature in Haskell, although I'm sure it has been asked about before.
13:10:29 <akfp2`> in scala:  mylist.map({case Foo a => a}) you don't need to care about the non-Foos.
13:11:51 <Welkin> akfp2`: then use _ for the default
13:12:17 <Welkin> explicit is better than implicit
13:12:21 <Welkin> you must match all patterns
13:15:12 <akfp2`> Welkin: I don't need to match them all if there's a well defined "default" and a way to "lift", then there's a reasonable desugaring where everything I match will be "lifted", and everything not matched will be "default"ed.
13:15:24 <lyxia> If a case is left out, it's hard to tell whether it is intentional or not.
13:19:35 <lyxia> I'm not sure what becomes of the tradeoff if you have special syntax for it though.
13:22:19 <dolio> The first question is why it should have anything to do specifically with lambda case.
13:22:31 <lyxia> akfp2`: doesn't that amount to composing fmap with a safe accessor function (returning Maybe)?
13:26:02 <Walther> > let readInts = map read $ words readLn
13:26:05 <lambdabot>  <no location info>:
13:26:05 <lambdabot>      not an expression: ‘let readInts = map read $ words readLn’
13:32:25 * hackagebot functor-utils 1.0 - Collection of functor utilities, providing handy operators, like generalization of (.).  https://hackage.haskell.org/package/functor-utils-1.0 (danilo2)
13:37:52 <akfp2`> (\pcase of Foo a -> a)  desugaring into  (\x -> case x of Foo a -> pure a; _ -> empty).  This seems similar to being able to write \x -> [a | Foo a <- x], but I don't see any generalization of pattern matches in the generalized list comprehensions in the ghc docs.
13:38:54 <Walther> having problems with input parsing in haskell, probably some simple mistake: http://walther.guru/temp/sort.hs
13:38:55 <Peaker> LambdaCase seems more fundamental than ordinary case..  IMO more sensible to say: case x of ..  desugars into (\case ...) x
13:40:49 <geekosaur> Peaker, probably, but as LambdaCase is by far the newer *and* not yet standardized...
13:40:54 <lyxia> akfp2`: define "unFoo (Foo a) = Just a ; unFoo _ = Nothing" once and for all, and then if you have a function which is supposed to work only with Foos and return Nothing otherwise, it's just fmap f . unFoo for some f.
13:41:11 <bam365> Walther: line 6 should be fmap (map read . words) readLn
13:41:14 <geekosaur> Walther, you can;t treat an IO value like a value
13:41:41 <geekosaur> that, yes. or use (>>=) to pretend you're operating on a value
13:41:41 <bitemyapp> Walther: (because it's not a value)
13:41:44 <Peaker> \x case Foo ...       could also desugar into  \x -> \case Foo ...      (similarly to \x y desugaring into \x -> \y -> ...
13:41:50 <Peaker> (was a bit surprised it didn't, today)
13:41:52 <bitemyapp> or rather, it's not the value you think it is.
13:41:59 <bitemyapp> IO String is a value, but it's not a String value.
13:42:20 <Walther> geekosaur: how?
13:42:23 <P4Titan`> Hello all, is there a way to get this working. GHC complains of multiple declarations of `Vector`. newtype VectorType = Vector (Triplet Double)
13:42:23 <P4Titan`> pattern Vector a b c = Vector (Triplet a b c)
13:42:36 <Walther> the >>= / bind version, that is
13:42:48 <tommd> So is 'Vector' a pattern or a constructor?
13:42:50 <tommd> Both!
13:43:02 <frerich> Yes!
13:43:06 <P4Titan`> ye
13:43:09 <tommd> Name one of them something else.
13:43:10 <geekosaur> readLn >>= \l -> (l is your "normal value" here. but you must put things back in IO with "return" when done)
13:43:21 <geekosaur> the fmap solution is better though in this case
13:43:49 <geekosaur> because `xxx >>= return (whatever)` is a bit of a code smell (same as fmap whatever xxx)
13:44:01 <typedeph> forgive my ignorance but must you always parse a string in Haskell to read an Int? is there no way to read an Int like c++'s cin >> someIntVar
13:44:02 <P4Titan`> The idea is that I centralize a Vector implementation under a Triplet data type, but I want to retain Vector as the type and constructor as it would be if Vector were implemented alone
13:44:35 <Walther> P4Titan`: i think for that the reasoning is there is no way for a user to input an int
13:44:45 <Walther> all the input is written text
13:44:57 <P4Titan`> umm :D
13:45:00 <Walther> which kinda makes sense, but makes some things a bit difficul
13:45:01 <frerich> typedeph: You can read a String and an Int with 'readLn' the same way, e.g. 'readLn >>= \x -> print (x + 1)' will print the number you enter plus one.
13:45:51 <P4Titan`> lol, I got it working!
13:45:55 <P4Titan`> newtype Vector = VectorType (Triplet Double)
13:45:55 <P4Titan`>     deriving (Show, Eq)
13:45:55 <P4Titan`> pattern Vector a b c = VectorType (Triplet a b c)
13:45:57 <frerich> typedeph: readLn actually yields a value of type 'IO a' where 'a' is some type instantiating the 'Read' class (i.e. 'readLn :: Read a => IO a'). So it's polymorphic and the type you get depends on what you do with it.
13:45:58 <P4Titan`> so nice!
13:46:00 <typedeph> frerich: that assumes that the entire line is but an int
13:46:28 <Walther> geekosaur: with the fmap version, i get "sort.hs: user error (Prelude.readIO: no parse)
13:46:43 <typedeph> what if the line consisted of an Int followed by a word
13:47:08 <bam365> Walther: you should probably just be doing getLine instead of readLn in this case, since you're parsing it out as a string anyway
13:47:10 <frerich> typedeph: Then you could use 'reads' instead.
13:47:26 * hackagebot lens-utils 1.0 - Collection of missing lens utilities.  https://hackage.haskell.org/package/lens-utils-1.0 (danilo2)
13:48:10 <geekosaur> typedeph, as a meta-remark, you will find that Haskellers kinda don't like things that smell of "duck typing". C++'s >> being willing to magically convert stuff is a bit smelly in that regard
13:48:26 <akfp2`> [ e | p <- e ]  desugars as e >>= \p -> [ e |], but it could desugar to something like e >>= (\x -> case x of p -> [ e|]; _ -> empty) when p is a pattern
13:48:26 <geekosaur> (in general, C and C++ are considered to be far too willing to magically convert things)
13:49:09 <typedeph> I agree, I'm still getting used to the Haskell way of thinking
13:49:21 <geekosaur> Walther, actually you don't want readLn there because it's already doing a "read" --- and not in the way you'd prefer
13:49:32 <geekosaur> use getLine instead
13:49:43 <typedeph> so then you must always parse a line
13:50:09 <typedeph> style sscanf in C
13:50:13 <geekosaur> if you use readLn then you'd want to skip the extra stuff and provide an input list that looks like: [1, 2, 3]
13:50:29 <geekosaur> (i.e. it would expect vaguely Haskellish syntax, not a space-separated list)
13:51:00 <typedeph> I have an overly verbose piece of code for reading
13:51:03 <geekosaur> using readLn *with* the extra stuff means you'd need to wrap it in quotes, so the readLn would strip the quotes off and then the list would be converted by the fmap
13:51:04 <typedeph> Int Int\n
13:51:08 <Walther> geekosaur: even that would be fine in this usecase, i wouldn't mind. As long as I would have an easy way to get a list of ints from stdin into a list of ints (or a IO list of ints) to haskell side
13:51:10 <typedeph> Int Int Int Int.....
13:51:32 <typedeph> where the first line is two variables
13:51:34 <Walther> the vaguely haskellish syntax of having to input [1, 2] and so on
13:51:35 <typedeph> and the last is an array
13:51:44 <typedeph> list*
13:51:47 <typedeph> my bad
13:52:11 <typedeph> for the first line I have
13:52:12 <bam365> Walther: fmap (map read . words) getLine   -- fairly easy, no?
13:52:35 <typedeph> I start with
13:52:51 <typedeph> [fLine, sLine] <- sequence[getLine, getLine]
13:53:01 <typedeph> forgot the space
13:53:08 <Walther> bam365: echo "4 3 2 1" | runhaskell sort.hs
13:53:08 <Walther> [[],[],[],[]]
13:54:03 <typedeph> let [n, k] = [readInteger $ head $ words fLine, readInteger $ head $ tail $ words sLine]
13:54:16 <typedeph> where readInteger s = read s :: Integer
13:55:03 <typedeph> I think already its overly verbose and can be more concise I'm sure
13:55:26 <frerich> typedeph: You could also use 'let [n, k] = map read (words sLine)'
13:56:11 <frerich> typedeph: Obviously you're putting error handling aside for the moment, i.e. you assume well-formed input.
13:56:20 <bam365> Walther: the code I gave should parse that correctly as IO [4, 3, 2, 1] .. maybe sort is wrong?
13:57:16 <Walther> found the error, yeah
13:57:17 <Walther> thanks
13:57:22 <typedeph> I get a parse error
13:57:57 <typedeph> eliminating all code but that and a return
13:58:04 <phaazon> hey, I’m trying to dig in Network.Socket
13:58:04 <typedeph> I get the error I had before defining readInteger
13:58:15 <frerich> typedeph: Try adding ':: [Integer]' at the end (in case type inference needs some prodding)
13:58:19 <typedeph> No instance for (Read t0) arising from a use of ‘read’
13:58:19 <typedeph> The type variable ‘t0’ is ambiguous
13:58:33 <phaazon> the SockAddrInet type ctor expects a « network byte order » Int: how should I set that?
13:58:56 <typedeph> ah
13:59:44 <frerich> typedeph: Very often, the types of things can be deduced based on how you use the values (e.g. 'n' and 'k') here. But not always.
13:59:55 <typedeph> before I tried doing map (read :: Integer) $ words sLine
13:59:58 <typedeph> and it didn't work
14:00:59 <typedeph> now of course using a map would make it fail assuming the line had more than 2 integers correct?
14:01:17 <typedeph> nonexhaustive pattern matching I would assume
14:01:22 <lyxia> read :: String -> Integer
14:02:13 <frerich> typedeph: Not the map, but the pattern match, yes. For what it's worth, you could combine the getLine call and that parsing by writing '[n, k] <- fmap (map read . words) getLine :: IO [Integer]' (that last ':: IO [Integer]' is again only needed if the type of n and k cannot be inferred)
14:02:26 * hackagebot container 1.0.1 - Containers abstraction and utilities.  https://hackage.haskell.org/package/container-1.0.1 (danilo2)
14:02:33 <typedeph> thank you lyxia
14:02:51 <typedeph> I failed to recognize the proper type specification
14:04:14 <typedeph> ok
14:05:20 <typedeph> your fmapping the IO monad (once again sorry total newbie)
14:05:51 <frerich> typedeph: For what it's worth, note that you do not specify a type if you do something with 'n' and 'k' which forces their type. Like, 'print n' is ambiguous but 'print (n + k)' or 'print (n == length "boing")' is not.
14:06:24 <frerich> Actually, I don't get why 'n + k' makes it infer 'Integer' for me instead of 'Num a'...
14:06:49 <typedeph> could be a float
14:06:50 <cite-reader> Are you in GHCI? I smell defaulting.
14:06:51 * frerich wonders whether this is related to how a specific type is inferred for global definitions...
14:07:14 <typedeph> nvm I just affirmed what you thought
14:07:18 <frerich> cite-reader: First I was, but I get the same in ghc.
14:07:35 <cite-reader> Huh, I guess I don't know the default rules as well as I thought then.
14:07:37 <cite-reader> Oh well.
14:07:37 <frerich> I thought it would go for 'Num a' and still complain.
14:08:47 <frerich> typedeph: but yeah, the 'fmap' application applies the function 'map read . words' to the 'IO String' represented by getLine and thus yields an 'IO [Integer, Integer]'.
14:09:04 <typedeph> What is the proper term for :: TypeExpr
14:10:44 <frerich> I always called it 'type specifier' but maybe I took that term from c++ heh
14:10:55 <Welkin> a type annotation
14:10:55 <rem_> Type annotation / type signature? 
14:10:59 <Welkin> or a type declaration
14:11:04 <typedeph> awesome
14:11:05 <Welkin> or a type signature
14:11:11 <typedeph> I guess I'll stick with type annotation
14:11:32 <frerich> Now I'm curious, /me goes looking it up
14:11:51 <Welkin> typedeph: typically, it is an annotation if it is inline
14:12:14 <jasonmay> if you find a central glossary for these, I'd love to see it!
14:12:17 <Welkin> if it is for a top-level declaration, we call it a type declaration/signature
14:12:32 <typedeph> yea I wanted to know the inline
14:12:39 <typedeph> type specification
14:12:46 <typedeph> annotation sounds right
14:12:50 <dolio> Ascription is a good word.
14:13:56 <rem_> Hi all, this is my first time using freenode so please be gentle if I says  something bad... I'm looking for an example where the Aeson library's strict parser performs significantly differently from the lazy version. Does anyone have experience with that? 
14:14:00 <typedeph> love this conciseness, didn't think I'd be able to get this in Monadic parts as well
14:14:52 <hexagoxel> frerich: for defaulting to happen, a numeric constraint is necessary (at least by 2010)
14:15:36 <akfp2`> where do I report issues on stackage.com?
14:15:43 <akfp2`> stackage.org
14:17:11 <typedeph> wow
14:18:04 <typedeph> thanks guys, that fixed my understanding on reading values
14:18:26 <kadoban> akfp2`: What kind of issues? I'd just send them to … support@fpcomplete.com I guess?
14:18:40 <kadoban> akfp2`: https://www.fpcomplete.com/page/support
14:19:46 <Walther> Still having some type issues - http://walther.guru/temp/sort.hs
14:24:07 <johnw> Walther: always add type signatures
14:24:20 <bergmark> akfp2`: some issue tracker, what kind of issue is it?
14:25:11 <kadoban> Walther: Well … parMap looks like the first argument is supposed to be a "Strategy a". print . rseq couldn't really possibly be that.
14:25:11 <lyxia> Walther: parMap returns a list but main is expected to be an IO action
14:25:38 <Walther> refresh, i did some edits
14:25:42 <kadoban> Walther: Also, rseq doesn't appear to be a function, so 'print . rseq' doesn't seem to make any sense.
14:26:05 <Walther> yeah, already fixed that error, i had bundled the print at the wrong place
14:27:05 <kadoban> Oh okay.
14:27:45 <Walther> basically i want to sort the lists in parallel and print in whichever order
14:28:00 <Walther> as long as all the lists get sorted and printed
14:28:05 <lyxia> Walther: Also there is a difference between evaluation and execution. parMap will evaluate the print actions without executing them.
14:28:35 <Walther> ah. I need another wrapper; parMap can evaluate the sorts but not execute prints
14:29:01 <Walther> hmm. can i "map do print" or something silly like that
14:29:05 <lyxia> If you want to print "in whatever order" you need Concurrency rather than Parallelism.
14:29:54 <synergistics> If you think of code and data as seperate things for a second, is a monad a function or data to be used by a function?
14:32:44 <frerich> synergistics: Well the functions which are part of monads (bind and return) clearly are functions. You could also call the things which 'return' and 'bind' 'monadic values'. I think there's no sensible answer really.
14:33:21 <frerich> synergistics: So I'm tempted to say 'Neither' or 'Your question cannot be answered because it's based on incorrect assumptions.' :-]
14:33:53 <Welkin> SYNERGIZE
14:34:14 <Welkin> we have an infiltrator here
14:34:22 <Cale> synergistics: A monad is a type level function, i.e. a function which accepts a type, and produces another type. For instance, Maybe sends the type Integer to the type Maybe Integer
14:35:08 <Cale> synergistics: It is equipped with some value-level functions, namely return and (>>=), which then are required to satisfy some additional properties
14:35:39 <Cale> But yeah, with the usual terminology, IO is a monad, but getLine is not.
14:36:21 <Cale> Or Maybe is a monad, but Just 6 is not.
14:41:39 <P4Titan`> Hi again! Why does this occur: ‘sum’ is not a (visible) method of class ‘DFold.Foldable’
14:42:22 <glguy> P4Titan`: Because you're using a version of base older than 4.8, perhaps
14:42:45 <P4Titan`> ok
14:44:14 <kadoban> Is DFold a thing, or was that a typo?
14:46:32 <P4Titan`> it is Data.Foldable qualified
14:46:57 <kadoban> Oh
15:02:28 * hackagebot purescript 0.7.6.1 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.7.6.1 (PhilFreeman)
15:02:53 <ReinH> johnw: Is the best way to learn NixOS / nixpkgs to read the manuals? Are there other good resources?
15:03:12 <ReinH> johnw: btw congrats on your new "job" :)
15:03:32 <johnw> ReinH: thanks!  I'd suggest starting with blog articles written about Nix, then ask questions in #nixos.  The manuals are not really for users yet.
15:03:49 <akfp2`>  bergmark:  I posted on the G+ community instead.  Also, there's no feedback button on either fpcomplete.com nor stackage.org so public feedback on G+ seems like the preferred channel.
15:04:44 <ReinH> johnw: Ok, that was sort of my feeling about the manuals as well.
15:04:58 <ReinH> johnw: Also now I can officially bug you with all of my emacs questions and you are duty bound to answer right? ;)
15:05:29 <johnw> ReinH: yeah, but in #emacs :)
15:05:36 <ReinH> ofc
15:05:43 <johnw> but sure, ask away, anytime
15:07:01 <glguy> akfp2`: The front page of stackage.org has a section about where to report issues
15:07:35 <glguy> "and report issues about Stackage itself here and issues about stackage.org here"
15:10:24 <glguy> akfp2`: The reason that "runEitherT" doesn't show up is that hoogle doesn't index record field accessors in general. That's not specific to stackage
15:12:02 <Welkin> but hayoo does
15:12:03 <Welkin> http://hayoo.fh-wedel.de/?query=runEitherT
15:32:29 * hackagebot hsx-jmacro 7.3.7 - hsp+jmacro support  https://hackage.haskell.org/package/hsx-jmacro-7.3.7 (JeremyShaw)
15:39:40 <happyfeet> hey, i have a "main.hs" file and i want it to show the output of "program.hs"
15:39:44 <happyfeet> how can i do that?
15:42:35 <happyfeet> any tips?
15:42:41 <mniip> elaborate?
15:43:24 <happyfeet> i have a "main.hs" and basically i want it to show the output of the "program.hs" when it receives "file.in"
15:44:11 <cite-reader> So... you want to run "program.hs" as a subprogram?
15:45:32 <happyfeet> yes cite-reader
15:46:54 <cite-reader> I think you want System.Process, in the "process" package.
15:47:24 <cite-reader> I haven't had to do this in Haskell, so I'm not sure if there's anything nicer.
15:47:29 * hackagebot OrderedBits 0.0.0.3 - Efficient ordered (by popcount) enumeration of bits  https://hackage.haskell.org/package/OrderedBits-0.0.0.3 (ChristianHoener)
15:48:48 <meditans> is it possible to have a datatype parametrized over kind [*]?
15:49:39 <c_wraith> meditans: isn't that one of the first examples of DataKinds you see everywhere? 
15:51:48 <meditans> c_wraith: I thought ghci was complaining, but it doesn't now
15:51:59 <meditans> yes, that was the strange part
15:52:51 <meditans> c_wraith: oh, ok, the error was generated by:
15:53:01 <meditans> deriving instance (Show a) => Show (HyperRelation a)
15:53:26 <meditans> where HyperRelation is parametrized over [*] 
15:53:48 <c_wraith> Oh. Yeah, derived instances tend to break down. 
15:55:51 <meditans> I could take a detour around the problem with UndecidableInstances (so does ghci say)
15:56:01 <meditans> is this a thing I want to avoid?
15:56:27 <c_wraith> No, that extension is pretty harmless. 
15:56:30 <ion> happyfeet: Given module Program in Program.hs, you could “import Program” in Main and invoke whatever it exports.
15:56:48 <synergistics> Cale: So is storing methods on the data you're using a functional OK? Pretty much, can types have their own methods?
15:57:30 * hackagebot data-construction 1.0 - Data construction abstractions including Constructor, Destructor, Maker, Destroyer, Producer and Consumer.  https://hackage.haskell.org/package/data-construction-1.0 (danilo2)
15:57:41 <c_wraith> synergistics: eh. The functions belong to the value, not the type. 
15:58:39 <synergistics> Then a value can be or have multiple functions that exist on it? And the type specifies those?
15:58:41 <Cale> synergistics: You don't attach methods to types. You can make and use records of functions to more or less do OO designs in Haskell, and it works well. You quickly find out that subtyping is overrated when your "objects" are simply collections of methods, and the type of an object only really specifies what methods there are and their types.
15:59:14 <Cale> This is what I consider to be a huge mistake that most typed OO languages make: tying the implementations of the methods to classes, which are the types of objects.
16:00:11 <synergistics> Records of functions, can you explain that?
16:00:50 <Cale> I just mean making a data type with a single constructor having a bunch of fields that have (usually mostly) function types
16:01:21 <kadoban> synergistics: data Blah = Blah {f :: SomeType -> Int, g :: SomeType -> Char, h :: Char -> SomeType, etc.}
16:01:39 <kadoban> Usually more imaginitive/useful/sane functions instead though.
16:01:58 <Cale> and maybe the results of those functions are IO actions, if you like
16:02:41 <Cale> also in the pure encoding of OO, you're quite likely to have functions which produce new values of type Blah, per kadoban's example
16:02:53 <Cale> So like, you might have:
16:03:00 <mpickering> geekosaur: My problem was that  {-# was followed by a non-breaking space
16:03:22 <geekosaur> whoops
16:03:31 * geekosaur rebinds his keyboard to avoid things like that
16:04:27 * mpickering doesn't know the key combination to insert a non-breaking space
16:05:34 <Cale> synergistics: So maybe you have something like: data AnimationObject = AO { draw :: Drawing, timeStep :: DeltaTime -> AnimationObject, handleInput :: InputEvent -> AnimationObject }
16:05:53 <synergistics> kadoban: I see
16:06:05 <synergistics> Cale: Yea
16:06:45 <synergistics> Is there a church encoding for something like that? I might play around and try to make one and see how mine compares.
16:07:32 <Cale> and then maybe you have something like   bullet position velocity = AO { draw = circle 0.1 position, timeStep = \dt -> bullet (position ^+^ dt * velocity) velocity, handleInput = ... }
16:08:00 * hackagebot data-layer 1.0.2 - Data layering utilities. Layer is a data-type which wrapps other one, but keeping additional information. If you want to access content of simple newtype object, use Lens.Wrapper instead.  https://hackage.haskell.org/package/data-layer-1.0.2 (danilo2)
16:08:02 * hackagebot prologue 1.0.6 - Better, more general Prelude exporting common utilities.  https://hackage.haskell.org/package/prologue-1.0.6 (danilo2)
16:08:03 <Cale> and here, the "position" and "velocity" arguments to this function which is building the record act like "private members"
16:08:54 <Welkin> better yet, use frp and just take the integral of the acceleration to get the velocity, and the integral of the velocity to get the position
16:09:41 <Hijiri> in this case it would be better to just do initial_position + velocity * time
16:09:46 <Hijiri> to avoid euclidean errors
16:10:02 <Hijiri> well better in some sense, it'll be more accurate and faster
16:10:10 <Hijiri> actually not sure about faster
16:10:23 <Hijiri> repeated adding might win out if multiplication is expensive enough and the frp machinery is cheap enough
16:10:24 <geekosaur> mpickering, alt-space I think
16:10:27 <Cale> Yeah, sometimes FRP systems will have some built in ways to manipulate signals like that. I've actually come to think that the ability to do that sort of integration is somewhat orthogonal to what FRP systems are really about.
16:10:45 <geekosaur> also see https://twitter.com/peterritchie/status/534011965132120064?lang=en :p
16:10:56 <Cale> Yeah, obviously though, you probably want to use a smarter integrator in a real program :P
16:11:03 <Cale> regardless of how you do it
16:11:08 <nani___> this is a stupid question, and I will learn the answer myself in a few days and how it actually works, I don't know enough of the language to understand it now yet. Can someone tell me how to just dump the result of an expression in ghci to a file instead of just printing it?
16:11:22 <Cale> and it'll almost never be really that simple, because my "bullet" doesn't interact with anything else
16:11:42 <arkeet> :t writeFile
16:11:43 <lambdabot> FilePath -> String -> IO ()
16:12:02 <Cale> nani___: something like   writeFile "foo.txt" (show x)   ought to work
16:12:05 <arkeet> :t writeFile "output" $ show (1 + 2)
16:12:06 <lambdabot> IO ()
16:12:14 <nani___> wow, that was easy :) thanks!
16:12:16 <Hijiri> I was thinking of next time I want to do integration, to implement runge-kutta method or something
16:12:23 <arkeet> or you could pipe/tee ghci to a file, if that's more what you want.
16:12:34 <Hijiri> like make it take a Behavior (derivative function)
16:12:44 <Hijiri> but then it's not really composable
16:13:00 <Hijiri> like you can't do integrate (integrate blah)
16:13:47 <Hijiri> hm, also it doesn't work nicely with anything that's not differentiable everywhere
16:14:12 <Hijiri> which is bad for games since you might want something that becomes stationary after travelling at a constant speed
16:14:43 <Cale> The tricky thing about giving time in an FRP system the kind of geometric content required to do integration at a fundamental level is that if you can sample behaviours not just at the current time, but at any time, you need to be able to store them in a way which often becomes prohibitive, and deal with the fact that there may be points in time at which evaluating a Behaviour will temporarily diverge because those tim
16:14:43 <Cale> es are in the future.
16:16:22 <Walther> heh, computers are fast. http://walther.guru/parallel-haskell
16:16:24 <Cale> These days, I tend to think of Behaviours as being things which always have a value when you find a way to look at them, but in order to look at them, you need an Event to occur.
16:17:19 <Cale> So while they might conceptually be changing continuously, you might not be able to do things like slowing them down or speeding them up by a factor
16:17:52 <Cale> and you might not actually be able to watch every change that conceptually occurs -- the observation might be implemented by polling some external system
16:18:11 <Hijiri> maybe the way I would go is store the last n values to do a n-degree taylor approximation
16:18:18 <Hijiri> that could work in constant space, and you could compose it
16:18:25 <Cale> yeah
16:18:52 <Cale> Or have a Behaviour which at any point in time is a local polynomial
16:21:13 <Cale> Sometimes that can work for collision detection -- you might compute that there's a collision at some point in the future, and have some way (from outside the FRP system, but perhaps built on top of it as an additional layer) to turn that into an Event firing in the future, but maybe something happens to switch that polynomial out for a different one and the next time for the event to fire will change before it happens.
16:33:30 * hackagebot typed-spreadsheet 1.0.1 - Typed and composable spreadsheets  https://hackage.haskell.org/package/typed-spreadsheet-1.0.1 (GabrielGonzalez)
16:33:33 * hackagebot OrderedBits 0.0.1.0 - Efficient ordered (by popcount) enumeration of bits  https://hackage.haskell.org/package/OrderedBits-0.0.1.0 (ChristianHoener)
16:33:35 * hackagebot relational-query 0.6.3.0 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.6.3.0 (KeiHibino)
16:44:47 <Guest383> I'd like to do compare in haskell between two lists
16:45:11 <lethjakman-l> Guest383: Then do it!
16:45:13 <lethjakman-l> ;)
16:45:22 <lethjakman-l> Look at Data.List
16:45:30 <Guest383> funny
16:45:37 <lethjakman-l> I know, I'm a clever guy. 
16:45:58 <Guest383> I am new in haskell 
16:46:01 <Guest383> need hint 
16:46:43 <Cale> Guest383: We'd be happy to help you, but it's hard to know what you want to do without more information?
16:47:54 <lethjakman-l> Guest383: https://stackoverflow.com/questions/15319136/how-to-compare-two-lists-in-haskell Is that what you want? 
16:48:32 <aweinstock> :t compare
16:48:33 <lambdabot> Ord a => a -> a -> Ordering
16:48:34 <Guest383> for ex: [1,2,3] [2,3,4] false, but [1,2,3] [1,2,3] true
16:48:43 <aweinstock> :t (==)
16:48:44 <lambdabot> Eq a => a -> a -> Bool
16:48:59 <aweinstock> Guest383: you probably want ==
16:49:07 <Cale> > [1,2,3] == [2,3,4]
16:49:09 <lambdabot>  False
16:49:13 <Cale> > [1,2,3] == [1,2,3]
16:49:15 <lambdabot>  True
16:49:30 <Guest383> yes 
16:51:09 <lispy> list equality in haskell is undecidable!
16:51:27 <lispy> (although, it's usually fine)
16:51:47 <lispy> > [1..] == [1..]
16:51:51 <lambdabot>  mueval-core: Time limit exceeded
16:52:05 <lethjakman-l> lispy: why's that?
16:52:35 <lispy> lethjakman-l: I'm being some what facetious. The point I wanted to make is simply that haskell lists might not end
16:52:48 <lispy> So if you compare them you might not know when to stop
16:52:49 <lethjakman-l> Oh. That makes sense. 
16:53:02 <lethjakman-l> Yeah, if it's an infinite list there would be a problem. 
16:53:13 <Walther> > [1..10] == [1..]
16:53:15 <lambdabot>  False
16:53:17 <Walther> hm
16:53:41 <lethjakman-l> Technically it is false though...
16:53:45 <Walther> presumably it stops at [] == 11
16:53:53 <lethjakman-l> One is an infinite list, the other isn't. 
16:54:00 <Walther> because [1..10] is afaik 1:2:3...10:[]
16:54:08 <Guest383> so how you coding that 
16:54:09 <Guest383> ? 
16:54:10 <lispy> The problematic case is when they are equal for a prefix of unbounded length
16:55:41 <Guest383> ??
16:55:49 <Guest383> how you coding this ? 
16:56:06 <tzh> Guest383: lists have an Eq instance, so just using == to compare them like any other value will work
16:56:21 <tzh> well, lists have an Eq instance if they are made up of values that have an Eq instance
16:58:25 <aweinstock> instance (Eq a) => Eq [a] where [] == [] = True; (x:xs) == (y:ys) = x == y && xs == ys
16:58:44 <aweinstock> ^ or something like that
16:59:10 <aweinstock> probably needs extra clauses for [] vs (:)
16:59:42 <aweinstock> instance Eq a => Eq [a] where [] == [] = True; (x:xs) == (y:ys) = x == y && xs == ys; _ == _ = False -- this probably handles the rest of the things
17:00:12 <codebje> ghc-pkg: streamingProcess: runInteractiveProcess: pipe: resource exhausted (Too many open files)
17:00:15 <codebje> that one's new on me
17:00:28 <Guest383> I need recursive way 
17:00:56 <aweinstock> Guest383: mine is recursive (the (xs == ys) part)
17:01:43 <aweinstock> :t all
17:01:45 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
17:01:53 <aweinstock> :t and
17:01:55 <lambdabot> Foldable t => t Bool -> Bool
17:02:02 <aweinstock> :t and . zipWith (==)
17:02:03 <lambdabot>     Couldn't match type ‘[Bool]’ with ‘Bool’
17:02:03 <lambdabot>     Expected type: [a] -> [a] -> Bool
17:02:03 <lambdabot>       Actual type: [a] -> [a] -> [Bool]
17:02:15 <aweinstock> :t (and .) . zipWith (==)
17:02:16 <lambdabot> Eq a => [a] -> [a] -> Bool
17:02:18 <shachaf> all, any :: [a] -> Cont Bool a
17:02:44 <Guest383> I think all of it is worng 
17:02:50 <aweinstock> shachaf: that's a tad obfuscated, I think
17:02:59 <aweinstock> @unmtl Cont Bool a
17:02:59 <lambdabot> (a -> Bool) -> Bool
17:03:11 <shachaf> Is it obfuscated or is it insightful?
17:03:47 <aweinstock> shachaf: that's a tough question
17:06:59 <Guest383> nobody know it 
17:07:07 <Guest383> that's wired 
17:07:13 <Guest383> anyway, thanks 
17:07:19 <Guest383> for trying 
17:08:29 <tzh> Guest383: do you mean you want list equality that works on nested lists?
17:08:49 <Guest383> yup 
17:09:04 <Guest383> exactly 
17:09:59 <Guest383> recursive way.
17:10:01 <tzh> Guest383: unless you're comparing two lists of different levels of nestedness ([1,2,3] vs. [[2,3],[4,5]]) then a plain == should still work, since the Eq instance is recursive
17:10:40 <mgsloan>  /me is guessing Guest383 is looking for the definition for (==) on lists for homework
17:11:07 <Guest383> no I know the def (==) 
17:11:22 <Guest383> don't say somthing I did not say it 
17:11:24 <mgsloan> Cool cool nvm then
17:13:21 <shadowdao> I wish I could have had Haskell homework.
17:13:31 <shadowdao> Instead it was Java.  =(
17:14:03 <shadowdao> Although we did do some C.
17:23:32 * hackagebot haskell-tor 0.1.0.0 - A Haskell Tor Node  https://hackage.haskell.org/package/haskell-tor-0.1.0.0 (AdamWick)
17:28:33 * hackagebot relational-schemas 0.1.1.0 - RDBMSs' schema templates for relational-query  https://hackage.haskell.org/package/relational-schemas-0.1.1.0 (KeiHibino)
17:58:34 * hackagebot PrimitiveArray 0.7.0.0 - Efficient multidimensional arrays  https://hackage.haskell.org/package/PrimitiveArray-0.7.0.0 (ChristianHoener)
17:59:19 <_m_ryan> anyone any suggestion about my code: http://lpaste.net/145534
18:01:43 <cite-reader> What closes geodb? Feels like you want a withGeoDB.
18:02:23 <KaneTW> `let ip = read $ show ip2 :: IP`
18:02:32 <KaneTW> this looks weird
18:02:42 <cite-reader> Yeah that makes me feel itchy. Is there not a more direct way?
18:03:13 <Ralith> that is terrifying
18:03:26 <KaneTW> _m_ryan: :t getGeoStateAds  please
18:03:34 * hackagebot relational-query-HDBC 0.3.1.0 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.3.1.0 (KeiHibino)
18:03:36 <KaneTW> the return is likely superfluous
18:04:57 <Ralith> _m_ryan: at the very least, use T.unpack and reads
18:23:37 * hackagebot postgresql-typed 0.4.2.2 - A PostgreSQL access library with compile-time SQL type inference  https://hackage.haskell.org/package/postgresql-typed-0.4.2.2 (DylanSimon)
18:46:23 <ReinH> Is there a nicer way to do, e.g., bindM2 f ma mb = do { a <- ma; b <- mb; f a b } (and especially to generalize like https://gist.github.com/reinh/41e99292283e2d77cb96)?
18:47:33 <Axman6> liftA2?
18:48:56 <Axman6> ReinH: also f <$> ma <*> mb and g <$> ma <*> mb <*> mc
18:49:20 <dmj> :t \f a b c -> f <$> a <*> b <*> c
18:49:21 <lambdabot> Applicative f => (a2 -> a1 -> a -> b) -> f a2 -> f a1 -> f a -> f b
18:49:23 <kadoban> :t liftA2
18:49:25 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
18:49:32 <kadoban> Axman6: Not exactly the same.
18:49:57 <glguy> ReinH: No, not really
18:50:01 <Axman6> it is now, since all monads are also applicatives
18:50:28 <kadoban> Axman6: (a -> b -> *m* c)
18:50:40 <Axman6> oh, brainfart
18:51:02 <Axman6> join =)
18:51:10 <glguy> No, you said "nicer" :)
18:51:30 <kadoban> Yeah, join could help.
18:52:04 <Axman6> join $ g <$> ma <*> mb <*> mc
18:54:01 <orion> Is it good practice for datatypes within a library to derive from NFData whenever possible?
18:54:13 <Pamelloes> :t ((.).(.)) join liftA2
18:54:14 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f b)
18:54:14 <lambdabot>     Expected type: (a1 -> b -> a) -> f a1 -> f b -> f b -> a
18:54:15 <lambdabot>       Actual type: (a1 -> b -> a) -> f a1 -> f b -> f a
18:54:40 <Pamelloes> :t ((.).(.)).(.) join liftA2
18:54:41 <lambdabot> Applicative f => (a2 -> a2 -> c) -> (a -> a1 -> f a2) -> a -> a1 -> f c
18:54:48 <Pamelloes> ...
18:55:11 <Pamelloes> Whatever. Either way you wind up with a three eyed owl out front.
18:55:12 <Enigmagic> that looks useful
18:55:22 <Pamelloes> :t ((.).(.).(.)) join liftA2
18:55:23 <lambdabot> Monad m => (a1 -> b -> m a) -> m a1 -> m b -> m a
18:55:28 <Pamelloes> There we go :)
19:20:52 <ReinH> Axman6: no, I don't want Applicative.
19:22:22 <ReinH> Yeah, join works.
19:25:15 <dfeuer> orion, if you're exporting something, and it isn't made of functions, it should probably have an NFData instance.
19:25:47 <dfeuer> If it is made of functions, meh.....
19:27:46 <orion> So, almost every library "should" depend on deepseq?
19:28:54 * hackagebot typed-spreadsheet 1.1.0 - Typed and composable spreadsheets  https://hackage.haskell.org/package/typed-spreadsheet-1.1.0 (GabrielGonzalez)
19:30:37 <dfeuer> orion, different people will probably have different views, but I'd say ... probably.
19:31:12 <dfeuer> orion, OTOH, there are some types that are really not likely to be deepseqed, so ... eh.
19:31:43 <dfeuer> I could be spouting nonsense; I think I'm a bit sick.
19:39:29 <frankBloHole> howdy
19:39:41 <tommd> > reverse "howdy"
19:39:43 <lambdabot>  "ydwoh"
19:40:24 <frankBloHole> woah
19:40:28 <frankBloHole> this is a next level place
19:50:00 <Big_G> > (reverse . reverse) "Howdy!"
19:50:02 <lambdabot>  "Howdy!"
19:58:59 * hackagebot digit 0.1.2 - A data-type representing digits 0-9 and other combinations  https://hackage.haskell.org/package/digit-0.1.2 (TonyMorris)
20:09:30 * hackagebot total-maps 1.0.0.3 - Dense and sparse total maps.  https://hackage.haskell.org/package/total-maps-1.0.0.3 (pawel834)
20:12:37 <orion> When using Criterion, is there a way to prevent it from catching exceptions so that I can handle it personally?
20:33:37 <orion> Solved: I just used $!! on the result *inside* the code passed to Control.Exception.handle.
20:42:37 <vektorweg1> is the record update notation working for tuples? 
20:42:56 <lispy> vektorweg1: nope
20:43:34 <lispy> at least not in GHC. Hugs had trex and I'm not sure what all that entails
20:44:30 <lispy> Your best bet for tuples is lens
20:53:22 <vektorweg1> thanks.
21:03:29 <jle`> ReinH: i like do notation on the rare occasions that that comes up
21:03:47 <jle`> i feel like things like this is what do notation is best at
21:45:11 <Pamelloes> Is there a way to have GHC optimize for space over speed?
21:49:33 <KaneTW> not afaik
21:50:03 <KaneTW> if you have space constraints haskell is usually not the right language anyway
21:50:20 <Pamelloes> Yeah....
21:51:00 <KaneTW> you could use something like ivory 
21:51:06 <KaneTW> but that's a different thing
21:51:31 <Pamelloes> ivory?
21:51:57 <KaneTW> http://ivorylang.org/ivory-introduction.html edsl in haskell for systems programming
21:53:03 <Pamelloes> Cool! I'm not doing systems programming, but that looks like an interesting project,
21:53:23 <KaneTW> yeah
21:53:41 <Cale> Yeah, using Haskell as a metalanguage to write one-shot compilers that just compute and emit the program you're interested in is a pretty cool technique in general.
21:54:22 <Pamelloes> Web servers are expensive for a college kid with no income.
21:54:35 <Cale> Similar projects include Atom, which was used to program realtime software for microcontrollers in hybrid hydraulic vehicles
21:54:56 <Cale> and, while it's OCaml rather than Haskell, FFTW can be seen as sort of in the same vein
21:55:23 <Cale> (It's an OCaml program which computes a C program for computing fast Fourier transforms)
22:09:38 * hackagebot foscam-filename 0.0.4 - Foscam File format  https://hackage.haskell.org/package/foscam-filename-0.0.4 (TonyMorris)
22:09:40 * hackagebot foscam-directory 0.0.4 - Foscam File format  https://hackage.haskell.org/package/foscam-directory-0.0.4 (TonyMorris)
23:26:54 <ggVGc> Could someone help me figure out this reasoning? I'm trying to understand this problem in the general sense. https://gist.github.com/f968ce8f3aa39e68d689
23:27:04 <ggVGc> what is it I actually want to do?
23:29:48 <jle`> ggVGc: what type do you want makeCards to be?
23:32:15 <ggVGc> jle`: same ias it is. I.e Seed-> [Card]. But I want a general solution to "I have a function that returns a tuple of (valueIneed, valueForNextApplication), and generate a list of values
23:33:02 <jle`> ah
23:33:10 <ggVGc> oh, sorry, that's snd should be fst
23:33:24 <jle`> so your function is (Seed -> (a, Seed))
23:33:38 <jle`> er, your input is
23:33:42 <frerich> ggVGc: A more general note - I suspect that, in principle, it could be that makeCards yields the same card four times. If you're working on some sort of card game then it may be easier to defined something like 'allCards :: [Card]', then shuffle that (random-shuffle has functions for that) and then take the first four cards.
23:33:48 <ggVGc> I don't lnow if I'm thinking about this corectly
23:33:52 <ggVGc> but I can't ge tmy head around it in a good way
23:33:53 <jle`> so your function might be (Seed -> (a, Seed)) -> Seed -> [a]
23:33:56 <jle`> or, even better (!)
23:34:06 <jle`> (Seed -> (a, Seed)) -> Seed -> ([a], Seed)
23:34:16 <jle`> and you can retrieve the seed at the end
23:34:52 <jle`> you might have fun with a type synonym: type Rand a = Seed -> (a, Seed)
23:35:00 <jle`> so foo :: Rand a -> Rand [a]
23:35:28 <jle`> "give me a geneartor of a's, and i'll return a generator of [a]'s"
23:36:00 <jle`> :t replicateM 4
23:36:02 <lambdabot> Monad m => m a -> m [a]
23:36:04 <jle`> hm...
23:36:56 <ggVGc> frerich: that's not completely correct. makeRandomCard generates a random version of an ADT, conceptually from an infinite set, so not like a common card game where there's a deck
23:37:41 <jle`> ggVGc: but yeah, if you let type Rand a = Seed -> (a, Seed), then you can think of a "Rand Int", for example, as a function that takes a seed and returns an Int and a new seed
23:37:43 <ggVGc> jle`: yeah, but it doesn't feel optimal to keep pairs of (seed, value) only to throw away all seeds
23:37:56 <frerich> ggVGc: Ok, *then* you might like http://hackage.haskell.org/package/random-derive-0.1.0.0/docs/System-Random-TH.html :-)
23:37:59 <jle`> it's useful because you can chain them in general, and use the same seed
23:38:08 <jle`> er, chain the seeds
23:38:25 <jle`> for example, what if you wanted to make two random decks?
23:38:41 <jle`> you can use the final seed of one to be the initial seed of the next
23:39:11 <jle`> there are a lot of instances where you can "chain" seeds, and having all of your functions fit a general pattern helps with working with them in an generic way
23:39:22 <jle`> you don't throw away all the seeds, btw...you use all of them, except for the final one
23:39:42 <ggVGc> sure, that's why I care about keeping the seed around, but putting them all into a list pf tuples, and then throwing all intermediate seeds away with another pass, doesn't seem optimal to me
23:39:56 <jle`> you're not throwing any intermediate seeds away
23:40:08 <ggVGc> is there no function for "Keep this evolving state around, and use it to spit ut a list of other values"
23:40:11 <jle`> you're using all of them :)
23:40:23 <jle`> that's basically what i'm getting at here, heh
23:40:42 <jle`> `s -> (a, s)` is a general pattern for chaining mutations on a state
23:40:43 <frerich> ggVGc: If you define a Random instance (which is trivial if you already have Enum and Bounded) then you can use the 'randoms' function, i.e. you get 'makeCards seed = take 4 . randoms . mkStdGen seed'
23:41:41 <ggVGc> hm, okay
23:41:44 <frerich> ggVGc: Isn't what you're describing the State monad? :-)
23:42:46 <frerich> ggVGc: I first thought you explicitely didn't want to use State, but now I'm not so sure anymore. I think the 'Using state monad to carry random generator seed around' thing is a pretty common example, see e.g. http://stackoverflow.com/questions/1956518/state-monad-sequences-of-random-numbers-and-monadic-code
23:44:33 <ggVGc> I guess it is. I am actually currently doing this in Elm, partly to get a better grasp of what the more advanced features in Haskell actually implement
23:44:45 <ggVGc> but yeah, I also suspect the state monad is essentially what I'm talking about
23:44:56 <ggVGc> thanks
23:49:05 <Gurkenglas> :t au (iso runState state) traverse . repeat
23:49:07 <lambdabot> (s -> (b, s)) -> s -> ([b], s)
23:49:35 <Gurkenglas> > (au (iso runState state) traverse . repeat) (\x -> (x, x+1)) 0
23:49:37 <lambdabot>  ([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
23:50:35 <jle`> ggVGc: added an example using State, and an example with explicit functions instead of do notation/Monad typeclass
23:54:11 <jle`> ggVGc: the basic idea is abstracting away the let's and pattern matchings
23:54:17 <jle`> with the higher order funtion bindRand
23:54:22 <Lokathor> ghci seems to be letting me use do notation with an Applicative that doesn't have a defined Monad instance
23:54:47 <Lokathor> does it just figure out a default monad somehow? or do i have applicative-do enabled without realizing it or something?
23:55:32 <jle`> Lokathor: can you give an example/instructions to reproduce?
23:56:30 <ggVGc> jle`: hm, added an example where?
23:56:33 <lpaste_> Lokathor pasted “slightly long because of newtype stuff, my apologies” at http://lpaste.net/145557
23:56:34 <ggVGc> oh, on the gist?
23:56:52 <ggVGc> jle`: thanks!
23:57:12 <Lokathor> jle`, getDogRM is using do-notation, but without Monad defined for it
23:57:17 <ggVGc> I think I'm gonna try implementing the state monad behaviour in Elm. That'll clear this up for me
23:57:28 <ggVGc> frerich: thanks for that SO post, it's exactly what I needed to get started I think
23:57:46 <ggVGc> jle`: ah, cool this manual binds example is very helpful
