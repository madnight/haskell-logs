00:18:53 <vkt> Anyone know how would I go about constructing a list comprehension where the output function is a list of variable length? [x1...xn]?
00:21:28 * hackagebot friday-scale-dct 1.0.0.0 - Scale Friday images with DCT  https://hackage.haskell.org/package/friday-scale-dct-1.0.0.0 (AlexMason)
00:21:30 * hackagebot friday-scale-dct 1.0.0.1 - Scale Friday images with DCT  https://hackage.haskell.org/package/friday-scale-dct-1.0.0.1 (AlexMason)
00:24:26 <Hafydd> > let n = 10 in [x^2 | x <- [1..n]] -- vkt
00:24:27 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
00:26:00 <Hafydd> (I don't know what you mean by "the output function".)
00:31:41 <vkt> Hafydd: The part before the pipe [x1,..,xn | where x1 <- bla, x2 <- bla etc]
00:34:21 <vkt> bashing my head in trying to create a list of lists [x1,..xn] where xi is element of [1...j]
00:35:23 <vkt> a list of lists, with length n containing all possible combinations of the values 1-x
00:35:34 <vkt> 1 through x*
00:37:49 <Axman6> > let f n = [[l..h] | l <- [1..n], h <- [l..n]] in f 3
00:37:51 <lambdabot>  [[1],[1,2],[1,2,3],[2],[2,3],[3]]
00:37:59 <Axman6> vkt: ^^?
00:38:05 <Axman6> > let f n = [[l..h] | l <- [1..n], h <- [l..n]] in f 5
00:38:07 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[2],[2,3],[2,3,4],[2,3,4,5],[3],[3,...
00:38:46 <vkt> interesting didnt know [l..h] would work 
00:39:00 <vkt> at all, that gives me something more to experiment with
00:40:31 <Hafydd> vkt: I don't think you can implement what you're trying to do with a list comprehension in a non-trivial way (i.e., if you were to express it using a list comprehension, there would be a simpler way without the list comprehension).
00:41:21 <vkt> Hafydd: I was beginning to think so 
00:42:55 <Hafydd> You can do something like this, however:
00:42:57 <Hafydd> > let n = 3 in map concat $ sequence [[[], [x]] | x <- [1..n]]
00:42:59 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
00:44:06 <vkt> Ill try fiddeling with some recursions and loops
00:44:24 <Hafydd> > [l | xs <- [[],[1]], ys <- [[],[2]], zs <- [[],[3]], let l = xs++ys++zs, not (null l)] -- or this
00:44:26 <lambdabot>  [[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
00:46:06 <Hafydd> (But using recursion is indeed probably the better way to implement this function.)
00:59:25 <hc> hi there
00:59:42 <hc> is there an existing data type like this: data AllSome a = All | Some [a] ?
01:00:38 <hc> to be used for example when defining access permissions... [a] can be a list of permissions
01:00:57 <Hafydd> hc: would Some [True, False] and Some [False, True] have the same meaning as All :: AllSome Bool?
01:02:10 <hc> yes it would
01:02:33 <hc> (as long as Bool is not expanded eventually (which is unlikely in the case of Bool))
01:03:31 <Hafydd> Maybe you should instead just represent a Set of permissions disallowed; then "all permission" is Set.empty/
01:03:36 <Hafydd> *Set.empty.
01:04:30 <hc> So when a new permission is "created", everyone that's not explicitly blacklisted will get it?
01:04:31 <Hafydd> I don't know the answer to your original question, but I know there isn't such a type in the standard Haskell platform libraries.
01:04:38 <hc> Okay, thanks
01:05:44 <Hafydd> hc: if it's possible for the meaning of your type to change in that way, then I suppose that might not be a good representation.
01:06:47 <wedens> when I use postgresql-simple with resource-pool, how can I implement attempt to reconnect when connection becomes broken?
01:12:54 <bergmark> wedens: here's our retry code using those libraries https://github.com/silkapp/silk-opaleye/blob/master/src/Silk/Opaleye/Transaction.hs#L117
01:13:02 <bergmark> ->work
01:14:08 <ChristianS> wedens: we init the pool as follows: createPool createConn close 1 60 100
01:14:30 <ChristianS> wedens: broken connections are not an issue for us since since app and db run on the same host
01:14:35 <wedens> brennie: thanks. I'm re-reading doc to reasource-pool  and for withResource it says "If the action throws an exception of any type, the resource is destroyed, and not returned to the pool."
01:15:00 <wedens> ChristianS: db can die even on localhost ;)
01:16:20 <wedens> bergmark: so, exception policy in withResource is not enough to handle all cases?
01:17:03 <ChristianS> wedens: postgres never dies! (i hope)
01:24:18 <hc> wedens: i think the case in the documentation refers to the "user" of the connection crashing, in which case the connection may be inside a transaction... so it must be closed
01:24:37 <hc> however, when the connection becomes unusable for other reasons (i.e., postgres being restarted), it is not detected
01:25:13 <hc> i have some code here that uses worker threads that share a postgres connection pool... if a connection is faulty, the process crashes and is restarted by a supervisor (like in erlang ;p)
01:25:18 <hc> this may not help in all cases, though
01:26:51 <hc> My suggestion would be to expand withResource to take another IO fucntion as a parameter that performs a "NOP" operation and if that function crashes, create a new connection and remove the old one from the pool
01:29:34 <wedens> hc: thanks
01:44:13 <bollu> are there any tutorials for using trifecta?
01:48:24 <merijn> bollu: Not really, but it's not as tricky as it first appears. I've got some trifecta using code you can look at
01:48:46 <merijn> bollu: Check out Lexer.hs and Parser.hs in https://github.com/merijn/lambda-except
01:49:19 <bollu> thank you :)
01:49:28 <bollu> merijn: I've never used a proper parser-combinator library
01:49:33 <bollu> anything I should be aware of?
01:49:48 <bollu> Also, for some reason, I feel uneasy using them - it feels too much like "magic" :P
01:49:53 <merijn> bollu: Most of the actual parsing stuff from trifecta is in
01:49:56 <merijn> @hackage parsers
01:49:56 <lambdabot> http://hackage.haskell.org/package/parsers
01:50:14 <merijn> Which, incidentally works for attoparsec and parsec too
01:51:00 <bollu> merijn: ooh, TupleSections is tasty :) and thanks for the pointer
01:51:17 <merijn> bollu: tbh, implementing a basic parser-combinator library is actually pretty easy. Making it fast is the hard bit, not too much magic, tbh
01:51:49 <bollu> merijn: really? hm, I should write my own once I'm comfortable with Trifecta then
01:51:57 <bollu> merijn: where do I start reading the code from?
01:52:07 <merijn> > (,'x',,True,,,) Nothing 1 (Right 'c') () -- people never seem to know how awesome TupleSections is
01:52:08 <lambdabot>      No instance for (Typeable t0)
01:52:08 <lambdabot>        arising from a use of ‘show_M36405366180138000527146’
01:52:08 <lambdabot>      In the expression:
01:52:10 <merijn> aww
01:52:29 <merijn> oh, whoops
01:52:34 <merijn> > (,'x',,True,,) Nothing 1 (Right 'c') () -- people never seem to know how awesome TupleSections is
01:52:36 <lambdabot>  (Nothing,'x',1,True,Right 'c',())
01:52:43 <bollu> yupp, it seems awesome
01:53:03 <bollu> I love parallel list comprehensions as well
01:53:15 <merijn> bollu: Lexer.hs defines a newtype around the Parser type from trifecta, then it defines TokenParsing + some generic combinators
01:53:15 <bollu> > [(x, y) | x <- [1..10], y <- [10..100]]
01:53:17 <lambdabot>  [(1,10),(1,11),(1,12),(1,13),(1,14),(1,15),(1,16),(1,17),(1,18),(1,19),(1,20...
01:53:29 <bollu> > [(x, y) | x <- [1..10] | y <- [10..100]]
01:53:30 <lambdabot>  [(1,10),(2,11),(3,12),(4,13),(5,14),(6,15),(7,16),(8,17),(9,18),(10,19)]
01:53:39 <bollu> merijn: ooh, alright. I'll take a look
01:53:44 <merijn> bollu: The actual parser is in Parser.hs (obviously), which looks mostly identical to how you'd write it in parsec/attoparsec
01:53:46 <bollu> merijn: why is the Lexer a prser?
01:54:13 <merijn> I'm not actually doing much lexing
01:54:36 <merijn> It's mostly just dealing with whitespace/layout/indentation
01:54:42 <bollu> you can deriving Applicative?
01:54:44 <merijn> I couldn't be arsed to think off a better name
01:54:46 <bollu> how do you ensure uniqueness?
01:54:52 <merijn> bollu: GeneralizedNewtypeDeriving
01:54:52 <bollu> hahaha, alright
01:55:06 <bollu> whoa, hm
01:55:14 <merijn> bollu: It basically means "the applicative is the same as the one I'm wrapping with my newtype"
01:55:18 <bollu> ah
01:55:22 <bollu> oh, that I've seen :)
01:55:41 <bollu> I thought it was like "deriving Functor/Show/..." that automatically writes the Functor instance
01:55:51 <merijn> bollu: Avoids having to define "instance Applicative Foo where (Foo f) <*> (Foo x) = Foo (f <*> x)", etc.
01:56:40 <bollu> newtype Parser a = Parser (StateT ([Error], [Int]) Tri.Parser a)
01:56:44 <bollu> that's a daunting type :P
01:57:03 <bollu> the StateT is being applied to..? 
01:57:15 <merijn> bollu: "Tri.Parser" is the parser from trifecta
01:57:32 <merijn> bollu: i.e. it's just a trifecta parser wrapped in StateT to keep track of errors/indentation
01:58:20 <bollu> oh, because the parser is monadic you can use StateT on it?
01:58:20 <bollu> neat
01:59:08 <Tehnix> Is there anything special about `_` in for example `do _ <- return 1; print 2`? Or is it just pure convention to mark not used arguments. I'm wondering since the compiler warns about it, but ignores it if it's assigned to _
01:59:31 <merijn> Tehnix: The report explicitly defines _ as a throwaway wildcard
01:59:37 <bollu> but, that's.. super cool/weird. You treat the parser as a monad and then use the State monad around it? so you create new types of Parser (a, ([Error], [Int])) during "state stepping"?
02:00:00 <merijn> Tehnix: Which means that it is special in the sense that "foo x x = ...." is an error (double binding), but "foo _ _ = ..." is not
02:01:00 <Tehnix> merjin: ah, the haskell 98 report? I guess I'm thinking more in the sense of GHC, like if it doesn't "store" anything in it, so nothing is allocated
02:01:14 <merijn> bollu: The trifecta parser is a monad, and thus it's perfectly sensible to use it as the base monad for a monad transformer like sTateT
02:02:02 <merijn> Tehnix: Haskell 2010 defines "Matching the wildcard pattern _ against any value always succeeds, and no binding is done." <- this would imply GHC generates no allocation either
02:02:42 <bollu> merijn: right, but it's a pattern that I haven't seen before
02:02:44 <merijn> @unmtl StateT ([Error], [Int]) Parser a
02:02:44 <lambdabot> [Error] -> [Int] -> Parser (a, [Error], [Int])
02:02:50 <bollu> to think of a parser as a monad is new to me :)
02:03:25 <merijn> hmmm, looks like unmtl is broken
02:03:51 <Tehnix> merjin: thanks!
02:04:51 <merijn> bollu: line 122-131 show the ident combinator checking/storing indentation and line 82-87 show the 'indent' combinator using it
02:05:19 <merijn> eh s/indent/nesting
02:07:26 <bollu> merijn: thank you :)
02:14:22 <padre_angolano> merijn: I'm looking at Lexer.hs, where does 'try' comes from? Is it Control.Exception or ...?
02:15:22 <bollu> :t try
02:15:23 <lambdabot> Exception e => IO a -> IO (Either e a)
02:16:08 <padre_angolano> looks like another try :-)
02:20:54 <merijn> padre_angolano: https://hackage.haskell.org/package/parsers-0.12.3/docs/Text-Parser-Combinators.html#v:try
02:21:15 <merijn> padre_angolano: It's just backtracking try, like parsec
02:21:32 * hackagebot alex 3.1.6 - Alex is a tool for generating lexical analysers in Haskell  https://hackage.haskell.org/package/alex-3.1.6 (SimonMarlow)
02:21:35 <padre_angolano> merijn: thanks!
02:49:32 <padre_angolano> merijn: in 'newtype Parser a ... deriving (Alternative, Applicative, ...)', does is derive from StateT, from Tri.Parser or from both? E. g. both StateT and Tri.Parser are Applicative...
02:50:20 <merijn> padre_angolano: It derives the alternative instance of "StateT s (Tri.Parser)"
02:51:50 <merijn> padre_angolano: Note that "StateT s (Tri.Parser) a" is a single type, and GHC just transparently uses the instances for that. GHC doesn't inspect "all types inside and arbitrarily pick stuff"
02:52:09 <merijn> padre_angolano: But StateT's Alternative instance uses the underlying MonadPlus instance of Tri.Parser
02:52:28 <merijn> (i.e. StateT is only Alternative if the underlying monad is MonadPlus)
02:53:14 <padre_angolano> merijn: and what about Applicative. Both StateT and Tri.Parser are Applicative, right? Would such 'deriving' work if only one of them were Applicative?
02:53:47 <bollu> padre_angolano: for StateT to work, the type you pass ir (in this case, Tri.Parser) has to be a monad
02:53:53 <bollu> since it's a monad transfomer stack
02:53:55 <merijn> padre_angolano: Your question doesn't make sense, because you are, for some reason, picking the type apart and looking at individual pieces
02:54:12 <bollu> so yeah, it wouldn't work unless the Tri.Parser had a monad (and applicative) instance
02:54:34 <merijn> padre_angolano: See the instance list here: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html#v:StateT
02:54:51 <bollu> merijn: well, I think the question is well formed. As in "where does the applicative instance come from?, and what would happen if Tri.Parser doesn't have an applicative instance"?
02:55:27 <padre_angolano> right, I'm just not getting where 'deriving Applicative' derives the instance from StateT or Tri.Parser
02:55:56 <padre_angolano> or both :-)
02:56:33 <bollu> padre_angolano: the Applicative instance of StateT uses the Applicative of the monad you pass the StateT
02:56:59 <padre_angolano> bollu: yes, I know that...
02:57:01 <bollu> and in this case, the StateT is being passed the Tri.Parser monad (/applicative)
02:57:06 <bollu> so, in the  "deriving"
02:57:23 <bollu> since you're creating a newtype over (StateT ([Error], [Int]) Tri.Parser a)
02:57:38 <bollu> it will use the Applicative of the (StateT ([Error], [Int]) Tri.Parser a))
02:57:49 <bollu> to write applicative instances for Parser
02:58:03 <bollu> which is of "StateT s m a "
02:58:14 <Black-Wolf> um padre a brincar Ã  programaÃ§Ã£o?
02:58:16 <bollu> did that help? :)
02:58:47 <padre_angolano> Black-Wolf: porque nao? :-)
02:59:24 <Black-Wolf> achei engraÃ§ado sÃ³ isso ;)
02:59:45 <Black-Wolf> n Ã© mto comum ver padres a programar lol
03:00:06 <padre_angolano> bollu: almost, but not exactly. If I don't use 'deriving' and want to write the Applicative instance for Parser by hand, do I base it on instance Applicative for StateT or for Tri.Parser?
03:00:21 <padre_angolano> bollu: probably I just should try and do it to understand :-)
03:00:44 <padre_angolano> Black-Wolf: :-)
03:00:49 <bollu> padre_angolano: you'll be using StateT, because the Parser wraps the (StateT s m a ) type 
03:01:59 <padre_angolano> bollu: OK, so for Applicative, 'deriving' somehow rewrites the instance Applicative StateT, right?
03:03:17 <bollu> padre_angolano: it doesn't rewrite it, it simply "unwraps the StateT", does the usual applicative instance stuff and then "wraps" it again
03:03:22 <bollu> so it's very mechanical to write i
03:03:24 <bollu> write*
03:03:48 <bollu> it's literally taking the "StateT" out of the Parser, using the StateT applicative instance, and then wrapping the result back in Parser
03:04:14 <padre_angolano> bollu: OK. So it seems that 'deriving' automatically derives from StateT's instances...
03:04:40 <bollu> yes, it does
03:04:52 <padre_angolano> bollu: but in the same 'deriving' clause we have CharParsing, and StateT does not have CharParsing instance. Only Tri.Parser does :-(
03:06:07 <padre_angolano> so it seems like 'deriving' gets the instances from Tri.Parser rather than StateT
03:06:13 <bollu> padre_angolano: I think that is possible because of the way the larger type (StateT s m a) is constructed. because the type (StateT s m a) has the "m" information (which is the Tri.Parser) type, you can derive instances for CharParsing as well would be my guess. My knowledge ends here :) merijn: am I even close to right?
03:09:34 <padre_angolano> those monad transormers are a hard thing to grap for me :-(
03:09:39 <padre_angolano> grasp
03:11:50 <joco42> is there a way to create "MyInt a" in Haskell and make it behave the same way as Int ? so that i can create typesafe MyInt KiloMeters , MyInt Miles, etc ?
03:12:02 <liste> joco42 check out the Num typeclass
03:12:03 <joco42> and then use MyInt as if it were Int ?
03:12:23 <joco42> yeah, what I want is to do this automatically...
03:12:32 <joco42> without reimplementing the wheel :)
03:12:54 <liste> joco https://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#t:Num
03:13:08 <liste> with GeneralizedNewtypeDeriving you can derive it automatically
03:13:11 <joco42> something like in Scala : MyInt extends Int with Kilometer
03:13:14 <joco42> hmm
03:13:15 <joco42> yeah?
03:13:18 <joco42> really?
03:13:41 <liste> @let data MyInt = MyInt Int deriving (Show, Num)
03:13:42 <lambdabot>  .L.hs:157:28:
03:13:42 <lambdabot>      Can't make a derived instance of ‘Num MyInt’:
03:13:42 <lambdabot>        ‘Num’ is not a derivable class
03:13:50 <joco42> oh...
03:13:58 <liste> lambdabot doesn't have that extension on
03:13:59 <joco42> but with extension?
03:14:01 <joco42> cool
03:14:02 <joco42> nice
03:14:03 <joco42> thanks
03:14:30 <joco42> very cool
03:14:33 <liste> @let newtype MyInt = MyInt Int deriving (Show, Num) -- forgot the newtype
03:14:34 <lambdabot>  .L.hs:157:31:
03:14:34 <lambdabot>      Can't make a derived instance of ‘Num MyInt’:
03:14:34 <lambdabot>        ‘Num’ is not a derivable class
03:14:43 <liste> with data it doesn't work
03:14:52 <joco42> ok
03:14:55 <joco42> need to try this
03:15:17 <joco42> i even wonder if there is already a library for these kind of things?
03:15:30 <joco42> i remember seeing something like that a few months ago...
03:15:36 <joco42> something with phantom types....
03:15:45 <joco42> by Kmett?
03:15:49 <joco42> not sure...
03:31:52 <phaazon> holy shit
03:31:58 <phaazon> MonadFix sounds so great!
03:32:04 <phaazon> but sounds so cryptic as well
03:32:23 <phaazon> mdo { p <- newIORef (Node 0 r); r <- newIORef (Node 0 p) }
03:32:24 <phaazon> huhu
03:33:05 <phaazon> I wonder how it’s implemented
03:33:36 <capisce> it's just syntactic sugar
03:34:16 <merijn> padre_angolano: You're mistaken, StateT *does* have a CharParsing instance
03:34:29 <merijn> padre_angolano: See the instances defined here: https://hackage.haskell.org/package/parsers-0.12.3/docs/Text-Parser-Char.html
03:34:37 <phaazon> capisce: yeah, but to what?
03:35:05 <phaazon> mfix \r -> mfix $ \p -> newIORef (Node 0 ?)
03:35:10 <phaazon> something like that?
03:35:21 <lyxia> it's not sugar
03:35:43 <phaazon> I think I’d need to see the implementation of MonadFix for IO
03:35:49 <phaazon> or for a simple monad
03:36:02 <phaazon> for instance, I don’t get how we can use that for Maybe
03:36:18 <lyxia> I mean for IO you can't define it within Haskell
03:36:38 <phaazon> hm
03:36:58 <phaazon> for Maybe I don’t get how we can “escape the loop”
03:38:17 <merijn> lyxia: Huh, why not?
03:38:17 <lyxia> merijn: Hmmm, was that wrong?
03:38:26 <merijn> lyxia: I'm not 100% sure, but I don't immediately see why one couldn't define monadfix for IO in haskell?
03:39:08 <merijn> Well, I guess it depends on whether you consider "unsafeInterleaveIO" haskell or not
03:40:23 <padre_angolano> merijn: oh, now everything is clear, thank you. I didn't expect that parsers create new instances of StateT that's why I was so puzzled as to where 'deriving' gets them from
03:41:54 <lyxia> ah, indeed. Well somehow I thought it had to be *more* compiler magic than unsafe*IO so I stand corrected.
04:38:22 <quicksilver> doesn't monadfix for IO let you do something evil with polymorphic IORefs?
04:38:26 * quicksilver isn't sure
04:38:42 <merijn> quicksilver: In what way?
04:39:08 <breadmonster> Hey merijn 
04:41:47 * hackagebot cereal-conduit 0.7.2.5 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  https://hackage.haskell.org/package/cereal-conduit-0.7.2.5 (MichaelSnoyman)
04:47:30 <rubiconn> hello
04:47:45 <rubiconn> why isn't this working ?
04:47:46 <rubiconn> main = func lista
04:47:46 <rubiconn> lista = [1,2,3,4,5,6]
04:47:46 <rubiconn> func x = filter even x 
04:47:59 <rubiconn> ? ? ? ?
04:48:06 <liste> rubiconn main is of wrong type
04:48:20 <rubiconn>     Couldn't match expected type `IO t0' with actual type `[Integer]'
04:48:21 <liste> it should be an IO action, not a list
04:48:31 <liste> :t print
04:48:32 <lambdabot> Show a => a -> IO ()
04:48:42 <liste> :t print `asAppliedTo` [1,2,3]
04:48:43 <lambdabot> (Num t, Show t) => [t] -> IO ()
04:48:49 <breadmonster> hello rubiconn 
04:48:53 <rubiconn> hello breadmonster 
04:48:56 <rubiconn> hello liste 
04:49:02 <liste> hello ):
04:49:03 <liste> (:
04:49:10 <breadmonster> Okay, uhh what are you doing?
04:49:11 <rubiconn> ok 
04:49:23 <breadmonster> Or rather what are you planning on doing?
04:49:27 <rubiconn> breadmonster, well i've been through the lambda calculus, got the gist of it 
04:49:40 <rubiconn> and now trying to get to start writing haskell code fluently 
04:49:46 <liste> rubiconn try "main = print (func lista)"
04:49:50 <rubiconn> i am just experimenting
04:50:13 <rubiconn> yup 
04:50:15 <rubiconn> that works
04:50:16 <rubiconn> so main 
04:50:21 <rubiconn> having a IO type 
04:50:36 <rubiconn> doesn't know  what to do when everything reduces to a value in it
04:50:41 <rubiconn> and not an IO action 
04:50:45 <rubiconn> thanks guys
04:50:46 <rubiconn> noted 
04:53:04 <rubiconn> also first time i tried to do the even filter using recursivity and guards
04:54:00 <rubiconn> and at some point i had : | lista!!n % 2 == 0 = putStrLn "even" ; func x n-1
04:54:03 <rubiconn> and it didn't work 
04:54:05 <rubiconn> :(
04:54:44 <rubiconn> i had to put putStrLn "even" ; func x n-1 in an exp with "let in" and use the "do" thingie 
04:55:39 <rubiconn> so you can't have more than one statements in a guard ?
04:55:55 <liste> rubiconn there's no statements in Haskell
04:56:14 <liste> and you can't really do putStrLn everywhere
04:56:24 <rubiconn> yeah
04:56:29 <rubiconn> because sideffects
04:56:31 <liste> for debugging, you can use Debug.Trace.trace
04:56:35 <rubiconn> ensuring no side effects
05:03:56 <rubiconn> i am pissed because i can do this 
05:03:57 <rubiconn> func x =
05:03:58 <rubiconn>         let 
05:03:58 <rubiconn>         y = x + 1
05:03:58 <rubiconn>         in
05:03:58 <rubiconn>         y + 1
05:04:21 <ChristianS> rubiconn: don't paste into the channel
05:04:26 <rubiconn> and not this
05:04:27 <rubiconn> func x =
05:04:27 <rubiconn>         y = x + 1
05:04:28 <rubiconn>         y + 1
05:04:31 <liste> @paste -- rubiconn
05:04:31 <lambdabot> Haskell pastebin: http://lpaste.net/
05:04:35 <rubiconn> oh 
05:04:38 <rubiconn> sorry guys
05:04:51 <rubiconn> so haskell has no statements 
05:04:56 <liste> yep
05:05:00 <rubiconn> just expressions that reduce
05:05:10 <rubiconn> everything is a huge ass expression
05:05:15 <rubiconn> abstraction and application
05:06:36 <rubiconn> also it took me some time to understand monads
05:07:05 <rubiconn> until i found this http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
05:08:00 <rubiconn> and this https://www.youtube.com/watch?v=ZhuHCtR3xq8
05:09:01 <dhalgren`> ugh what is that?
05:09:09 <dhalgren`> hm
05:09:11 <dhalgren`> nvm
05:09:42 <dhalgren`> pressed some key, an article (don't fear the monad?) appeared inline w this chat window. bizzare
05:10:20 <dhalgren`> I think there were some conflicts in the original haskell committiee over those syntax styles -- there's some article around I believe by SPJ on the birth of the language, quoting a resignation letter early on by some guy dissatisfied with, I think over adding the expression-style syntax
05:18:02 <Unhammer> can hsc2hs refer to C functions made by "#define" statements?
05:18:04 <Unhammer>  int bar(int, int, char);
05:18:06 <Unhammer> #define FOOBAR(x,y)         bar((x), (y), FOO);
05:18:14 <Unhammer> foreign import ccall unsafe "sybdb.h DBSETLPWD"
05:18:43 <Unhammer> or, with my example, foreign import ccall unsafe "foo.h FOOBAR"  :)
05:19:00 <Unhammer> that just gives "can't find label"
05:20:21 <merijn> Unhammer: That's because CPP macros don't exist in the compiled binary and thus can't be linked with
05:20:26 <liste> Unhammer those are macros, not functions. they just perform text replacement in C source files
05:20:31 <merijn> Unhammer: However, GHC's CApiFFI lets you access macros
05:20:52 <merijn> (by auto generating C wrappers, compiling those and then linking those into your code)
05:21:29 <Unhammer> aha
05:21:40 <merijn> Consult GHC manual for details, etc.
05:22:50 <Unhammer> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi.html#ffi-capi seems to be what I'm after
05:22:56 <Unhammer> thanks merijn, liste
05:27:49 <liste> yw (:
05:29:21 <sleepynate> is there a ghc extension that allows hugs-like patterns on the left, i.e. "derp (n+1) = derp' n"
05:29:55 <merijn> sleepynate: You're looking for NPlusKPatterns, but they are widely considered terrible, hence why they were removed in Haskell2010
05:30:14 <Unhammer> although https://ghc.haskell.org/trac/ghc/ticket/7388 :(
05:31:04 <rubiconn> npluskpatterns ?
05:31:06 <rubiconn> hugs ?
05:31:18 <sleepynate> merijn: yea it looks gross, i just got a hugs file from somebody and don't want to fix it manually
05:31:47 <sleepynate> rubiconn: hugs is another implementation of haskell98 that plays a little more fast and loose
05:32:11 <rubiconn> sleepynate, ok
05:32:18 <rubiconn> googling nkpluspatterns
05:32:47 <merijn> sleepynate: To be fair, NPlusKPatterns were in Haskell98
05:32:48 <maerwald> so, it's not possible to specify build flags for cabal dependencies?
05:33:08 <merijn> maerwald: Correct. Flags should be able to change the external interface
05:33:19 <maerwald> that's a really huge fail
05:37:02 * hackagebot dixi 0.6.0.2 - A wiki implemented with a firm theoretical foundation.  https://hackage.haskell.org/package/dixi-0.6.0.2 (LiamOConnorDavis)
05:37:13 <sleepynate> lol. found on SO - "For people who still want to use the n+k-pattern (I'm looking at you, Erik Meijer),"
05:38:02 <rubiconn> so any of you have full time haskell jobs 
05:38:02 <rubiconn> ?
05:38:30 <bergmark> a big part of my job is haskell at least :)~
05:39:25 <rubiconn> bergmark, cool 
05:40:02 <rubiconn> bergmark, what exactly do you do ?
05:40:09 <Unhammer> rubiconn,  part time haskell job at the moment :)
05:40:28 <Unhammer> or, part of job
05:40:32 <rubiconn> where i am there are no haskell jobs 
05:41:08 <rubiconn> and also where i am python/java/sysadmins are payed more than embedded developers
05:41:08 <rubiconn> :(
05:41:09 <bergmark> rubiconn: i work at www.silk.co
05:41:49 <Myrl-saki> @pl (\x acc -> f x : acc)
05:41:49 <lambdabot> (:) . f
05:41:57 <Myrl-saki> Oh cool. My hunch was correct.
05:41:57 <rubiconn> bergmark, what is that ?
05:43:38 <bergmark> rubiconn: it's a platform for organizing and visualizing data collections, github for data, kind of ;-)
05:44:15 <rubiconn> bergmark, give me an example
05:44:47 <merijn> bergmark: Remote?
05:45:30 <rubiconn> bergmark, uhm, interesting 
05:46:19 <rubiconn> visually beautifying data 
05:47:14 <merijn> ugh...I hate it when I wanna know how to compute something and I only find a formula with no clues as to why I should believe it's correctness...
05:47:40 <rubiconn> merijn, formula for ... ?
05:48:00 <merijn> oh, hmmm, wrong channel :p
05:48:06 <bollu> merijn: what are you playing with?
05:48:10 <merijn> For converting linear indices (i.e. integrals) into indices into a triangular matrix
05:48:37 <bollu> merijn: which channel were you going to post that on? -_^ 
05:48:39 <merijn> I found this answer http://stackoverflow.com/a/27088560/496149 but I have no context for why it works :p
05:48:41 <bollu> and.. what are you up to with that?
05:48:44 <bergmark> rubiconn: this is a nice one, bellingcat tracking russian military vehicles https://bellingcat-vehicles.silk.co/
05:48:49 <merijn> bollu: -blah
05:49:10 <merijn> bollu: Generating uniform random triangular matrix indices without repeats
05:49:18 <rubiconn> bergmark, woah
05:49:37 <bergmark> merijn: no remote, but aren't you in amsterdam as well? :)
05:50:16 <merijn> bergmark: Yes, I was checking how many haskellers there are in Amsterdam :p
05:50:16 <merijn> bergmark: Are you going to NL-FP?
05:50:54 <bollu> merijn: what's -blah?
05:51:41 <merijn> bollu: #haskell-blah
05:51:56 <bollu> ohh
05:51:57 <bollu> TIL
05:52:08 <bergmark> merijn: not this year i think, 8 hours of presentations is a bit too much for me...
05:56:27 <phaazon> may you guys show me an example of mfix with lists?
05:56:29 <phaazon> I really don’t get it
06:06:45 <merijn> :t mfix
06:06:46 <lambdabot> MonadFix m => (a -> m a) -> m a
06:07:03 * hackagebot tripLL 0.1.0.0 - A very simple triple store  https://hackage.haskell.org/package/tripLL-0.1.0.0 (apho)
06:07:41 <merijn> I think it's just basically concatMap with it's own output as input
06:16:10 <rubiconn> https://www.youtube.com/watch?v=UwRRMn9k5AA
06:16:39 <roconnor> > take 5 $ map (take 2) $ mfix (\l -> map (:l) [0..])
06:16:40 <lambdabot>  [[0,0],[1,1],[2,2],[3,3],[4,4]]
06:21:30 <roconnor> > take 5 $ map (take 5) $ mfix (\l -> map (:l) [0..])
06:21:32 <lambdabot>  [[0,0,0,0,0],[1,1,1,1,1],[2,2,2,2,2],[3,3,3,3,3],[4,4,4,4,4]]
06:24:22 <roconnor> in this case mfix (\l -> ...) the l parameter is bound to the value of the nth position in the output ... um when you are computing the nth output.
06:25:54 <roconnor> I was confused by mfix for a long time.  I don't think the list monad is a particularly illuminating example.
06:26:38 <roconnor> I wrote an article in the monad reader when I did finally learn about monadic fixpoints: https://www.haskell.org/wikiupload/1/14/TMR-Issue6.pdf
06:30:53 <Xandaros> roconnor: Moved onto my "to-read" list - thanks :)
06:32:04 * hackagebot names-th 0.2.0.1 - Manipulate name strings for TH  https://hackage.haskell.org/package/names-th-0.2.0.1 (KeiHibino)
06:33:46 <merijn> mfix is one of those things I only understand when I need to use it
06:34:14 <phaazon> merijn: I read “when I’m drunk”
06:34:15 <phaazon> :))
06:34:26 <lingxiao> hey all 
06:34:26 <lingxiao> when i declare a counter, ie let x = 0
06:34:29 <lingxiao> I'm using logn bits right?
06:34:36 <phaazon> I think it’s a powerful tool I’d like to understand how to use
06:34:37 <lingxiao> or is it unclear?
06:34:44 <phaazon> long bits?
06:35:25 <merijn> lingxiao: I don't understand the question
06:35:41 <phaazon> or log(n) bits, ? :D
06:35:43 <merijn> phaazon: I think it helps to first study fix if you haven't yet
06:35:52 <lingxiao> I'm essentially asking how much space it takes to represent an Int
06:36:06 <lingxiao> phaazon yeah log(n) haha
06:36:11 <merijn> lingxiao: Architecure and implementation dependent
06:36:20 <merijn> On 64bit GHC 64 bits
06:36:30 <phaazon> merijn: I know fix pretty well
06:36:43 <phaazon> I use it in my FRP framework
06:36:45 <phaazon> like
06:37:00 <phaazon> fix $ \b -> Behavior $ \t -> pure (f t,b)
06:37:09 <lingxiao> merijn sorry let me clarify, suppose i want to count up to n using my counter
06:37:29 <geppettodivacin> lingxiao: Are you thinking of the Integer type, as opposed to the Int type?
06:37:42 <merijn> Int is fixed width
06:37:49 <merijn> So the bits used is constant
06:37:55 <Ankhers> lingxiao: Haskell variables are immutable.
06:37:59 <lingxiao> geppettodivacin and merijn actually I had no idea
06:38:31 <lingxiao> Ankhers could you expand on tthe consequence of that
06:38:32 <lingxiao> ?
06:39:25 <Ankhers> lingxiao: Once you do something like `let x = 0', you cannot change the value of `x'.
06:41:25 <lingxiao> Ankhers so how is Integer different?
06:41:29 <lingxiao> it's mutable?
06:41:48 <geppettodivacin> lingxiao: No, but it uses a variable number of bits to store it.
06:41:49 <Ankhers> lingxiao: No. By default, all values are immutable within Haskell.
06:42:19 <geppettodivacin> So, an Integer can hold an arbitrary-sized integer, like Java's BigInteger.
06:42:36 <geppettodivacin> But, like any other type, x still cannot change.
06:43:28 <geppettodivacin> So, depending on the implementation, I would think `let x = 2 ^ 1000 :: Integer would take approximately 1000 bits to store, although there is probably a bit of overhead for record-keeping.
06:44:01 <geppettodivacin> But, correct me if I'm wrong, it should still be on the order of O(log n).
06:44:52 <lingxiao> geppettodivacin and somethiing like x = 2 ^ 1000 :: Int would still take 64 bits?
06:44:58 <lingxiao> though when I do that in ghci I get x = 0
06:45:10 <lingxiao> as opposed to some maxBound on Int
06:45:47 <geppettodivacin> > 2 ^ 1001 :: Int
06:45:49 <lambdabot>  0
06:45:56 <geppettodivacin> > 2 ^ 1001 + 1 :: Int
06:45:56 <geekosaur> it uses machine operations, so if they overflow you get what the hardware produces
06:45:58 <lambdabot>  1
06:46:07 <geekosaur> not something that detects overflow
06:46:37 <geppettodivacin> > 3 ^ 1001 :: Int
06:46:39 <lambdabot>  163179016665764195
06:47:17 <geppettodivacin> It just happens that large powers of 2 overflow nicely to 0.
06:47:59 <lingxiao> geppettodivacin ahh i see, thanks boy i never knew :(  
06:48:01 <geppettodivacin> Bit-wise, it would be stored 1000000000000000000... and it would truncate the front 0.
06:48:10 <geppettodivacin> ^front 1
06:48:21 <geppettodivacin> And quite a few 0s.
06:48:45 <lingxiao> that's 1 followed by 63 zeros correct?
06:48:51 <lingxiao> or no?
06:49:15 <geppettodivacin> No, it's 1 followed by n zeros. But it will be truncated to be only 64 0s in the end.
06:49:20 <geppettodivacin> Which is why the answer is 0.
06:49:48 <Xandaros> 2^1000 = 1 followed by 999 zeroes. If you store it as Int, you will be left with the last 64 bits, which are all 0
06:49:54 <JazzyEagle> Hello all, I had an odd question for you...  I want to write a program in Haskell, and someone recommended to me a particular communication format called OCA, but the issue I'm concerned with is that OCA is based on Objects from an OOP, and thus what are being sent around are Serializable Objects.  Does anyone know if Haskell can work with these, or do I need to choose an OOP language?
06:50:41 <geekosaur> JSON is serialized "objects" but it works fine in Haskell
06:51:07 <JazzyEagle> geekosaur: Yeah, but I believe this one would be in a binary format...
06:51:13 <geppettodivacin> JazzyEagle: Have you checked out the binary package?
06:51:27 <lingxiao> geppettodivacin Xandaros thanks1
06:51:27 <JazzyEagle> geppettodivacin: What binary package are you referring to?
06:51:37 <geekosaur> @hackage binary
06:51:38 <lambdabot> http://hackage.haskell.org/package/binary
06:51:40 <geekosaur> ^ tat one
06:51:46 <JazzyEagle> Ahhh, no.  Let me look at it.
06:51:50 <lingxiao> now suppose I want to rescrict myself to log log n bits ...
06:52:05 * hackagebot cayley-dickson 0.3.0.0 - Complex numbers, quaternions, octonions, sedenions, etc.  https://hackage.haskell.org/package/cayley-dickson-0.3.0.0 (lmj)
06:52:11 <geppettodivacin> lingxiao: What are you trying to do with these Integers?
06:52:18 <lingxiao> increment them
06:52:21 <lingxiao> and that's it
06:52:40 <lingxiao> i'm implementing Morris's algoirthm
06:52:50 <frerich> JazzyEagle: 'Objects' in the 'data structure' sense are usually just records, i.e. collections of fields. That will work just fine with Haskell.
06:52:51 <geppettodivacin> You can't increment any value in Haskell, unless you're using a data type like MVar which explicitly allows mutation.
06:53:24 <JazzyEagle> frerich: Ok.  Makes sense.  I'll look into this further as an option, then.  Thank you very much!!
06:54:00 <lingxiao> geppettodivacin so suppose I want to just declare a big number n in log log n bits
06:54:07 <geppettodivacin> lingxiao: You'll probably need some type of recursive algorithm.
06:54:19 <lingxiao> could you elaborate?
06:55:08 <geppettodivacin> Instead of declaring a variable and stepping through a loop, changing it, you'll call a single function and it will call itself, kind of like a loop.
06:55:17 <Xandaros> lingxiao: Unless you are doing things with threads, you don't want MVars.
06:55:28 <geppettodivacin> Each new caller will pass a different value for your variable.
06:56:34 <Ankhers> lingxiao: http://lpaste.net/146203 -- contrived example, but still recursive.
06:57:41 <lingxiao> Ankhers so incrementToTen is a bit like ..
06:57:49 <lingxiao> incrementToTenList [] = []
06:59:07 <lingxiao> or err nvm the point is you're modifying that n?
07:00:00 <Ankhers> lingxiao: `n' is not being modified. It is getting called with a different value. I'm not sure that is the best way to put it. Someone feel free to correct me.
07:00:02 <lingxiao> i'ts a bit like recursively building upa  list?
07:00:15 <lingxiao> yeah someone please clarify
07:01:01 <lingxiao> so suppose we call incrementToTen 5 
07:01:24 <lingxiao> do we have :   (..(5 + 1) + 1) + 1 + 1 + 1) ?
07:01:59 <lingxiao> but the inner (x + 1) is never explicitly used right?
07:02:13 <lingxiao> so do we just have (..(5 + 1) + 1) + 1 + 1 + 1) as a thunk?
07:02:27 <lingxiao> and then discarded when we see incrementToTen 10 = 10
07:02:37 <geppettodivacin> You don't need the leading ...
07:02:51 <geppettodivacin> Or, oh, for parens.
07:02:51 <lingxiao> see the value for n is not called for in that statement
07:02:53 <geppettodivacin> Yes.
07:03:18 <lingxiao> geppettodivacin so is the function building upa  thunk then?
07:03:24 <lingxiao> so what's the space of that?
07:03:30 <geppettodivacin> Until it is needed, I think yes.
07:03:40 <lingxiao> so acutally it's never needed
07:03:49 <geppettodivacin> If you print it, it is.
07:03:53 <lingxiao> so we have a space leak if we want to do  buildUpToOnBillion
07:03:57 <petems> hi folks, I’ve been installing ghc with brew for aprox 1h30 mins now. I’m on a fairly ok spec’d Macbook Pro, am I missing something or will it normmally take this long?
07:03:59 <lingxiao> until then that is
07:05:06 <frerich> petems: Does it actually compile GHC? Last time I installed GHC via homebrew, it just poured a binary.
07:05:58 <lpaste> geppettodivacin revised “No title”: “Strict Increment” at http://lpaste.net/146203
07:06:07 <petems> frerich: Right now it’s doing a bunch of what look like ghc-stage commands
07:06:15 <petems> Look something like this: 
07:06:17 <petems> "inplace/bin/ghc-stage1" -hisuf hi -osuf  o -hcsuf hc -static  -H32m -O    -this-package-key prett_7UQTOB05U7lIYPkFOVraeR -hide-all-packages -i -ilibraries/pretty/src -ilibraries/pretty/dist-install/build -ilibraries/pretty/dist-install/build/autogen -Ilibraries/pretty/dist-install/build -Ilibraries/pretty/dist-install/build/autogen -Ilibraries/pretty/.
07:06:27 <petems> Damn, shoulda pastebinned that, sorry! :(
07:06:33 <geppettodivacin> lingxiao: I believe that paste should avoid the thunks by calculating it.
07:06:45 <geppettodivacin> ^calculating it as you go.
07:06:48 <frerich> petems: That looks like it's building stuff from source.
07:07:26 <petems> frerich: ah, Im assuming that takes a while?
07:07:32 <geppettodivacin> I'm kind of new to using seq for performance things, so that may be a bit off, but that's the idea of shrinking space. If you need a single, strict value, you want to calculate values as you go.
07:07:38 <petems> gcc was like an hour or so from homebrew...
07:08:17 <frerich> petems: I guess it does. I never built GHC from source. :-}
07:08:46 <petems> frerich: is there a faster way to do it? Are there pre-built binaries for haskel?
07:08:58 <frerich> petems: Sure, plenty of them.
07:09:04 <petems> For OSX?
07:09:12 <frerich> petems: Yep
07:09:16 <lingxiao> geppettodivacin  so I should foce evaluate it correct?
07:09:28 <lingxiao> even so does that satisfy log log n requirements?
07:10:46 <petems> frerich: cool, I’ll try that :) I just wanted touse spellcheck which requires haskal, compiling it from source seems a little OTT :)
07:12:11 <frerich> petems: For what it's worth, I use https://ghcformacosx.github.io/
07:12:31 * hackagebot packman 0.3.0 - Serialization library for GHC  https://hackage.haskell.org/package/packman-0.3.0 (JostBerthold)
07:12:39 <petems> frerich: ooh, nice, thanks :)
07:13:09 <merijn> I always use either GHC binaries or ghcformacosx, yeah
07:14:14 <lingxiao> how do I build a StdGen type?
07:14:21 <lingxiao> I see there's mkStdGen :: Int -> StdGen
07:14:36 <lingxiao> but I'm a bit hesitant to just do ... ie mkStdGen 1 in my code
07:15:19 <lingxiao> there's newStdGen
07:15:23 <lingxiao> but that's IO stdGen
07:17:09 <lingxiao> I could call next a bunch of times
07:17:20 <lingxiao> but who knows lol ... so what's a robust way of doing it?
07:17:58 <c_wraith> lingxiao: what's your concern?  StdGen isn't a CPRNG.
07:18:00 <Ankhers> lingxiao: What is wrong with `newStdGen'?
07:18:10 <c_wraith> lingxiao: so newStdGen is as good as anything
07:18:15 <lingxiao> sorry what's CPRNG?
07:18:41 <c_wraith> err, CSPRNG
07:18:46 <lingxiao> I want to delcare type of form (Bool,Double,StdGen) as opposed to IO (Bool,Double,StdGen)
07:18:55 <c_wraith> Cryptographically-secure pseudo-random number generator
07:19:33 <c_wraith> lingxiao: then purity means that you'll always get the same StdGen
07:20:15 <Ismael> Hi. I'm trying to compile fenfire and I 100% new with ghc's toolkit. I'm having a «Could not find module ‘Data.HashTable’»  error and I can't fivgure out how to fix it.
07:20:15 <Ismael> I'm using ghc-7.8.4-45.fc22.x86_64 (Fedora22) and this is the output: http://pastebin.centos.org/36561/
07:20:15 <Ismael> Which package should I install? 
07:20:19 <lingxiao> c_wraith: yeah I guess once I run this (Bool,Double,StdGen) it'll be an IO (Bool,Double,StGen) right?
07:21:22 <Ankhers> lingxiao: What do you mean by `run' that tuple?
07:21:54 <lingxiao> suppose (Bool,Double,StdGen) is a coin = (head, probOfHead, stdGen)
07:21:59 <lingxiao> then running it means flipping the coin
07:22:09 <c_wraith> lingxiao: try using functions instead.
07:22:15 <lingxiao> and maybe getting back (tail, probOfHead, stdGen')
07:22:19 <lingxiao> c_wraith: how so?
07:22:25 <c_wraith> lingxiao: StdGen -> (Bool, Double, StdGen)
07:22:45 <c_wraith> lingxiao: then you don't care where the StdGen comes from.  You just use it.
07:22:55 <lingxiao> so for datatype I have type Coin = StdGen -> (Coin_,Prob, StdGen)
07:22:56 <geekosaur> Ismael, I think that got deprecated years ago (we prefer the stuff in unordered-containers which is faster than the old HashTable)
07:22:59 <lingxiao> as opposed to type Coin = IO (Coin_,Prob, StdGen)
07:23:04 <lingxiao> correct?
07:23:36 <c_wraith> lingxiao: I'm sort of confused why you're packaging all of that together.
07:23:38 * geekosaur looking to see if there's any convenient references for rewriting, since the old HashTable doesn't seem to be there
07:23:50 <c_wraith> lingxiao: I mean, the probability seems like it should be input.
07:24:29 <c_wraith> lingxiao: and packaging the StdGen with the coin doesn't make a lot of sense to me.
07:24:54 <lingxiao> c_wraith that's what I did to begin with
07:24:56 <Ismael> geekosaur: I'm trying to follow this instructions: https://github.com/timthelion/fenfire/blob/master/RESURECTION-NOTES.md
07:25:18 <Ismael> geekosaur: maybe fenfire is getting outdated
07:25:19 <lingxiao> but I want to declare a coin with a fixed prob(head) and then just `flip` it repeatly
07:25:19 <c_wraith> lingxiao: Seems more like you want something like..  type Coin = Double ;  flip :: Coin -> StdGen -> (Bool, StdGen)
07:25:35 <lingxiao> using some function flipC :: Coin -> Coin
07:26:06 <lingxiao> the new coin then get's passed to the next call of the function
07:26:31 <geekosaur> yes, more things have changed since then (it talks about ghc 7.4, current is 7.10, HashTable was deprecated but still present back then)
07:26:34 <c_wraith> lingxiao: that's..  Just not really good design in haskell.  It's mixing concerns together instead of isolating them.
07:27:24 <lingxiao> c_wraith so I had this originally
07:27:24 <lingxiao> http://lpaste.net/146206
07:27:28 <lingxiao> which is more separate
07:27:29 <geekosaur> Ismael, http://hackage.haskell.org/package/unordered-containers-0.2.5.1/docs/Data-HashMap-Lazy.html is what you'd replace HashTable uses with
07:27:37 <lingxiao> I didn't like the type signatures so I was trying to clean it up a bit
07:28:25 <Ismael> geekosaur: I know 0% haskell programming, is it just substitute one call for another or code should be ported too?
07:28:26 <geekosaur> I'm actually a little surprised the package uses HashTable, the old stuff was annoying to use and really slow
07:28:35 <geekosaur> code probably needs to be ported
07:28:49 <Ismael> damn
07:28:50 <c_wraith> lingxiao: Yeah, that makes things more complicated than they need to be.
07:28:58 <geekosaur> you might try contacting timthelion via github
07:29:04 <c_wraith> lingxiao: I have to run though.  Can't comment further now.
07:29:21 <lingxiao> ok great thanks!
07:29:30 <lingxiao> could someone else chime in as well  ? :)
07:29:50 <geekosaur> also I'd say that's not "getting" outdated, it is very outdated at this point
07:30:16 <geekosaur> I noted a few "TODO fix this!" in that page you linked; the previous update was apparently incomplete. That's not a good sign
07:32:29 <Ismael> geekosaur: hehe, fenfire seems to be near to abandoned these days :-/
07:32:56 <Ismael> Any suggestion to install the outdated package? 
07:32:58 <geekosaur> I don't think timthelion is even active any more, so "abandoned" is probably right
07:33:16 * geekosaur is headed into daily standup, sorry
07:34:47 <Ismael> thanks anyway
07:39:24 <mnoonan> lingxiao: as a first approximation, things you want to do to a coin should have signatures like "Coin -> (somthing)", and properties of the coin should end up in the data constructor.
07:39:52 <mnoonan> so if the only property of interest is how biased the coin is, you probably want "data Coin = Coin Double"
07:40:24 <lingxiao> mnoonan yeah I was trying to do that and also puttting a stdGen in it..
07:40:40 <lingxiao> but c_wraith said it was mixing concerns and his thought seemed wise
07:40:58 <mnoonan> well, the stdGen doesn't need to be stuck in the coin, right?
07:42:17 <lingxiao> for a bit I was convinced that I wanted a function of form flip :: Coin -> Coin
07:42:30 <lingxiao> without taking in a StdGen as a parameter ... hence the though
07:42:32 * hackagebot syntactic 3.1 - Generic representation and manipulation of abstract syntax  https://hackage.haskell.org/package/syntactic-3.1 (EmilAxelsson)
07:42:32 <lingxiao> thought*
07:43:34 <mnoonan> flip :: Coin -> Coin only really makes sense if you're thinking of "what side is showing?" as an important property of the coin that you want to maintain over time
07:44:25 <mnoonan> if you're thinking of flipping as just producing a random value *using* a coin, flip :: Coin -> Random Bool makes more sense
07:44:41 <lingxiao> sorry what's Random Bool?
07:45:05 <mnoonan> I meant it informally, but Random T could just be another way of saying StdGen -> (T, StdGen)
07:45:26 <mnoonan> give it a generator, get back a value and the modified generator
07:46:48 <lingxiao> see that's the thing the type signature doen'st look very "symetrical" if that makes any sense at all
07:47:27 <mnoonan> well.. it isn't :)  What kind of symmetry are you expecting?
07:47:39 <lingxiao> Coin -> Coin LOLOL
07:47:55 <lingxiao> but honestly it's not thatimportant, just a dead avenue of thought I suppose
07:48:38 <leshpack> hi
07:49:43 <leshpack> Having a bit of trouble with one of my assignments. Spent ages trying this, but i suck at haskell and my lectures are kinda useless, so I need to ask here tbh
07:50:09 <leshpack> I need a function rep to run another function n times
07:50:13 <leshpack> yes i am that bad
07:51:04 <frerich> leshpack: What do you envision the type of your 'rep' function to be?
07:51:11 <frerich> (Maybe it's even given already as part of the assignment?)
07:51:26 <lingxiao> mnoonan does it make sense if I throw away the old generator?
07:51:36 <lingxiao> I could use a new one on each toss right?
07:51:49 <leshpack> See this is the thing, I'm not entirely sure frerich
07:51:59 <leshpack> It will be rep n, so it will start with Int
07:52:18 <frerich> leshpack: So you have 'rep :: Int -> ...' already. :-)
07:52:22 <mnoonan> lingxiao: You'd be losing some randomness.. it would be like re-seeding your generator before every call to random() in C/C++
07:52:33 <frerich> leshpack: Do you know the 'map' function already?
07:52:56 <leshpack> well I need it to repeat a Command custom type n times
07:53:15 <leshpack> Rt 120.0 :> Fd 1.0
07:53:22 <leshpack> It's for controlling a "turtle"
07:53:28 <lingxiao> mnoonan: i  hate to split hairs here but I have now a function:
07:53:28 <lingxiao> toss :: StdGen -> Coin -> (Coin,StdGen)
07:53:35 <leshpack> Turn right 120 degrees, forward 1 unit etc
07:53:39 <leshpack> which is of type command
07:53:46 <lingxiao> and look if I just uncurry it I get toss :: (Coin,StdGen) -> (Coin,StdGen) !!!
07:54:06 <frerich> leshpack: Can you give a sample usage of your 'rep' function, i.e. "If I call like this, then I expect that"? It may be that you can think of a type based on that.
07:54:06 <mnoonan> lingxiao: true :)
07:54:11 <lingxiao> where Coin = ( Head | Tail,  Double)
07:54:27 <lingxiao> so I wanted Coin = (Head | Tail, Double, StdGen)
07:54:29 <lingxiao> haha ..
07:55:00 <leshpack> so rep is going to be part of polygon n
07:55:14 <leshpack> the result of polygon n is an n-sided polygon with sides of length 1. The following code should display a hexagon, with the turtle facing up at the end.
07:55:35 <rubiconn> hello 
07:55:37 <leshpack> So polygon 3 should call Rt 120.0 :> Fd 1.0  three times
07:55:37 <rubiconn> so ... 
07:55:53 <lingxiao> mnoonan 
07:56:10 <lingxiao> if I want to use mkStdGen to make a generator, does it matter what int i use?
07:56:24 <lingxiao> or should I "burn it in" with a bunch of next?
07:56:54 <rubiconn> actually what the difference between a functor and a moand, i see none ?
07:57:08 <rubiconn> actually what is the difference between a functor and a moand, i see none ?
07:57:10 <leshpack> So I tried this for now, just to get the angle part working frerichpolygon :: Int -> Double -> Command
07:57:10 <leshpack> polygon n = (Rt (360.0/(fromIntegral(n)) :> Fd 1.0))
07:57:48 <leshpack> But the compiler isn't happy and I can't work out why (I'm really not very good at this sorry)
07:58:39 <kadoban> lingxiao: Why not just use newStdGen? Yes in general it matters very much what you seed your random number generator with.
07:59:03 <lingxiao> kadoban because I want to have a datatype of form (Head | Tail, Double, StdGen)
07:59:36 <kadoban> lingxiao: So?
08:00:09 <lingxiao> and I want to construct an instance of it using function:   coin :: Double -> (Head | Tail, Double, StdGen)
08:00:15 <lingxiao> can't do that with newStdGen
08:00:20 <leshpack> frerich: are you still here man? :)
08:00:46 <lingxiao> but I could if i do coin :: Double -> StdGen -> (Head | Tail, Double, StdGen) I suppose
08:01:08 <frerich> leshpack: Yes, I thought you are still typing. I didn't see the answer to the "Can you give a sample usage of your 'rep' function?" question yet. :-)
08:01:20 <kadoban> lingxiao: Well, make it coin :: Double -> IO (Head | Tail, Double, StdGen) ?
08:01:27 <rubiconn> ok, so a functor applies a function to a wrapped value, an applicative applies a wrapped function to a wrapped value, and a monad applies a wrapped value to a function that returns a wrapped value , is there more to say ?
08:01:32 <leshpack> Oh sorry I typed a lot up there but didn't "tag" you
08:01:38 <lingxiao> dont like IO haha
08:01:43 <leshpack> frerich: ^^
08:01:51 <frerich> leshpack: No worries, I saw it :-)
08:03:25 <tailgate> Are there code examples of using Data.Map in a custom type? I'm having trouble finding one.
08:04:40 <rubiconn> anyone care to talk with noob like me >
08:04:41 <rubiconn> ?
08:05:52 <frerich> leshpack: Uh, so... I saw your 'polygon' definition but I don't quite see how that relates to your 'rep' question. Do you want to apply 'polygon' repeatedly? At this point, the best comments I can offer is to look at the 'replicate' function :-}
08:06:54 <leshpack> frerich: Yes I want the command on the right hand side of polygon to be called n times.
08:07:22 <leshpack> frerich: Presumably with something like polygon n = rep (Rt (360.0/(fromIntegral(n)) :> Fd 1.0))
08:07:34 <merijn> tailgate: What's the problem with "just using it"?
08:08:01 <tailgate> Can't figure out the syntax
08:08:16 <tailgate> so, examples would be nice
08:08:23 <merijn> tailgate: Do you know how to use, for example, Maybe in a custom type?
08:08:25 <frerich> leshpack: So '(Rt (360.0/(fromIntegral(n)) :> Fd 1.0))' is a command which first turns right and then moves forward, i.e. it's a composite command - and commands can be combined using ':>'?
08:08:25 <leshpack> frerich: but the thing is that polygon doesn't even compile in the current state because I have no idea what damn type it is. The custom command type my lecturer made is confusing me
08:08:33 <tailgate> merijn: no
08:08:39 <leshpack> frerich: Yes exactly :D
08:08:46 <tailgate> is Maybe a real type? I thought learn you a haskell just made it up
08:09:09 <merijn> tailgate: Why wouldn't it be? It's used everywhere
08:09:14 <leshpack> frerich: I tried Int -> Double -> Command but I get Couldn't match expected type `Command'
08:09:14 <leshpack>                 with actual type `Double -> Command'
08:09:14 <leshpack>     In the return type of a call of `polygon'
08:09:14 <leshpack>     Probable cause: `polygon' is applied to too few arguments
08:09:31 <tailgate> I don't use haskell much
08:09:45 <tailgate> so idk
08:10:17 <frerich> leshpack: Well if you change the type signature, you probably also want to change your definition (that's what the error message means in your case). However, you can deduce it step by step
08:10:40 <tailgate> like, how do I make it use Map.fromList when the type gets constructed?
08:10:56 <tailgate> also, I want to restrict the map to (String, Fractional a)
08:11:22 <frerich> leshpack: You can just check what type ':>' has (because polygon supposedly returns the same thing as :>) and what type 'fromIntegral' has (because the type of the argument of fromIntegral is also the type of the argument of polygon)
08:11:58 <leshpack> frerich: data Command
08:11:58 <leshpack>   = Fd Double
08:11:58 <leshpack>   | Bk Double
08:11:58 <leshpack>   | Lt Double
08:11:58 <leshpack>   | Rt Double
08:11:58 <leshpack>   | Go Command
08:11:58 <leshpack>   | Command :> Command
08:11:59 <leshpack>   deriving Show
08:12:09 <leshpack> Should be command right?
08:12:20 <hrnz> o.O
08:12:21 <frerich> leshpack: In general (given that there are 1400+ people in this channel) it's more polite to rather paste to code e.g. lpaste.net
08:12:29 <leshpack> oops sorry
08:13:11 <frerich> leshpack: But yeah. That means that ':>' is applied to two 'Command' values and yields a new Command value. So you know that 'polygon' will yield a Command value.
08:13:39 <frerich> leshpack: So you could try 'polygon :: Int -> Command' as a type
08:14:25 <leshpack> frerich: Sadly I then get this http://lpaste.net/146215
08:14:49 <Zekka|Sigfig> tailgate: I’ve missed the beginning of your question but based on what I’ve read, it sounds like your goal is to a) constrain a constructor using a typeclass and b) make the constructor call an arbitrary function on the input? (so the list people feed in gets turned into a map)
08:15:22 <tailgate> Zekka|Sigfig: yes. I was hoping I could find an example
08:15:26 <Zekka|Sigfig> If so, you can accomplish just a using GADTs and both a and b by using a function instead of a constructor. (the latter is more idiomatic)
08:15:42 <frerich> leshpack: If you look closely at that error message, you might notice something funny.
08:15:52 <tailgate> Zekka|Sigfig: I don't know what you just said
08:15:56 <frerich> leshpack: See what your compiler considers the first argument of 'Rt' to be.
08:15:58 <mnoonan> lingxiao: here are some of the options as code: http://lpaste.net/146216
08:16:15 <leshpack> frerich: Oh yes its the whole line
08:16:16 <Zekka|Sigfig> Tailgate: example of my first idea (if I remember my gadt syntax right): data MyNum a where Num a => a
08:16:28 <frerich> leshpack: Yep!
08:16:32 <Zekka|Sigfig> er, Num a => a -> MyNum a :: Constructor1
08:16:36 <lingxiao> mnoonan great it looks good tahnks!!
08:17:18 <Zekka|Sigfig> GADTs are kind of an obscure feature and require a language extension, so they’re not that popular, but they do give you a guarantee that the polymorphic type has a certain typeclass, and they don’t break pattern-matching
08:17:49 <Zekka|Sigfig> The more common pattern (this is what the stdlib does with e.g. rationals) is to define a function that wraps your constructor, and then let other people use that function but hide the constructor. (this breaks pattern matching)
08:17:57 <merijn> Zekka|Sigfig: Wut...not that popular?
08:18:02 <mnoonan> lingxiao: note many instances of the pick-a-random-biased-face pattern in the where clauses, suggesting this is probably the fundamental operation after all :)
08:18:05 <merijn> GADTs are like the best extension since sliced bread...
08:18:15 <merijn> Well, maybe RankNTypes is...but it's close!
08:18:20 <frerich> No, LambdaCase is.
08:18:22 <Zekka|Sigfig> data MyNum a = Constructor1 a; myNum :: Num a => a -> MyNum a; myNum = Constructor1
08:18:24 <tailgate> hmm, what is the extension? not shown here https://en.wikibooks.org/wiki/Haskell/GADT
08:18:32 <Zekka|Sigfig> merijn: Really? I didn’t realize it was so popular
08:18:32 <merijn> frerich: LambdaCase but not that amazing
08:18:44 <frerich> merijn: Sorry you're all wrong, go away. LambdaCase is teh best.
08:18:49 <merijn> Zekka|Sigfig: I can't remember the last non-trivial haskell code I wrote without GADTs :p
08:18:50 <lingxiao> mnoonan you mean the expression:    face = if r < bias then Heads else Tails 
08:19:02 <merijn> frerich: lambdacase doesn't let me write things I couldn't otherwise write
08:19:20 <frerich> merijn: Right, but it's amazing
08:19:30 <mnoonan> lingxiao: yeah, along with the "(r, gen') = random gen" line
08:19:33 <Zekka|Sigfig> merijn: Whoa! I apparently got my GADT type annotation completely backwards. Don’t trust me with remembering stuff I don’t use!
08:19:41 <leshpack> frerich: Cool I fixed it thanks! Now it draws the appropriate line
08:19:42 <tailgate> okay...
08:19:49 <leshpack> frerich: But still only one line :P
08:19:58 <Zekka|Sigfig> this is the correct version: data MyNum a where Constructor1 :: Num a => a -> MyNum a
08:20:26 <lingxiao> mnoonan: yup! an unrleated question
08:20:38 <lingxiao> if I toss two sequence of coins using the same newStdGen
08:20:44 <lingxiao> the sequence should be differnt right?
08:20:47 <Zekka|Sigfig> merijn: FWIW I tend to try to avoid advanced typesystem features, even though I understand some of the ones I’m avoiding pretty well
08:21:03 <lingxiao> assuming the each toss use the previous toss's stdGen
08:21:07 <merijn> Zekka|Sigfig: Why do you try to avoid them? :)
08:21:12 <Zekka|Sigfig> Probably the reason they don’t tend to filter into my code is that a lot of the trivial cases of GADTs can be written without GADTs if you don’t mind losing pattern matching
08:21:31 <Zekka|Sigfig> merijn: Because I don’t like writing code that’s likely to be hard for other people to understand
08:22:06 <mnoonan> lingxiao: as long as you keep threading the generator resulting from one toss into the next toss, yes
08:22:11 <leshpack> frerich:so now i need to modify it so that rep is included
08:22:13 <frerich> leshpack: Right. So what you want is to do that repeatedly. You could split this problem into two parts: 1. Generate a list of commands (i.e. a value of type '[Command]') which is made of some Command repeated N times and 2. Joining the elements of that list using your :> function to yield one big Command.
08:22:13 <merijn> Zekka|Sigfig: That describes 80% of the code I write >.>
08:22:22 <Zekka|Sigfig> Most of the othe rprogrammers I hang out with are not primarily Haskell programmers (a lot of them aren’t Haskell programmers at all) so lately I try not to write code that I think will confuse them
08:22:24 <mnoonan> including at the start of tossing the coin2 sequence
08:22:32 <Zekka|Sigfig> (this usually means not using haskell of course, which I’m OK with)
08:22:36 <leshpack> frerich: OK that's a good idea
08:23:18 <frerich> leshpack: With that description, you can already devise funciton types. E.g. 'replicateCommand :: Int -> Command -> [Command]' and 'merge :: [Command] -> Command'
08:23:23 <ij> It's said that parsec is good at some specific type of parsing. (predictive, I think) But can parse all sorts of grammars, yes? I don't know much about formal grammar.
08:23:57 <Zekka|Sigfig> merijn: FWIW I should disclaim, I haven’t written a serious Haskell app in ~2yr
08:24:00 <merijn> ij: It can't parse Left-recursive grammars
08:24:11 <merijn> ij: Well depending on your definition of "can't"
08:24:16 <lingxiao> mnoonan: great thanks!
08:24:22 <ij> What's yours?
08:24:38 <merijn> ij: You can transform left-recursive into right-recursive grammars mechanically and since there's no parser generator for parsec...
08:24:39 <frerich> leshpack: If you had those two functions implemented, then you could do something like 'merge (replicateCommand 5 (polygon 2))' which does 'polygon 2' five times and merges that into one single command.
08:24:49 <Zekka|Sigfig> Nowadays I write a lot of toy and example programs in it though.
08:25:10 <merijn> ij: So it depends whether you only consider parsec implementations that are straightforward translations of your grammar or not
08:25:29 <mnoonan> lingxiao: just think of newStdGen as giving you an infinite list of values, and random acts like "random gen = (head gen, tail gen)".  Obviously not literally true, but it gives you the right intuition.
08:25:43 <Zekka|Sigfig> merijn: Doesn’t Parsec have a ‘left-associatively grouped version of x parser’ combinator? I haven’t used that in a while either
08:26:04 <leshpack> well frerich n is going to be the same for polygon and repCom, so I have something like this atm: polygon n = merge (replicateCommand (Rt (360.0/(fromIntegral(n))) :> Fd 1.0))
08:26:15 <leshpack> and frerich replicateCommand n f = replicate n f
08:26:43 <frerich> leshpack: Right (and in your example you probably meant to write 'polygon n = merge (replicateCommand n (Rt...'
08:26:49 <Zekka|Sigfig> Seems like that gets you most common cases of left-recursive grammars (I don’t know if it gets you all of them right offhand)
08:26:58 <merijn> Zekka|Sigfig: Sure
08:27:03 <leshpack> frerich: Yes I did :) ty
08:27:12 <merijn> Like I said, you can mechanically translate left-recursive into right-recursive
08:27:30 <frerich> leshpack: I guess since you already noticed that 'replicateCommand' is actually 'replicate', we can just use the latter right away. That leaves us with the 'merge' function.
08:27:45 <ij> merijn, Does that stem from the fact that it's a monadic parser?
08:27:54 <merijn> ij: ?
08:27:59 <merijn> ij: Does what stem from that?
08:28:23 <ij> The fact that it can't parse left-recursive grammars without trickery.
08:28:28 <leshpack> frerich: simple matter of intercalate right?
08:28:45 <merijn> ij: No, it stems from the fact that parsec basically produces a recursive descent parser
08:28:58 <merijn> as opposed to say, a shift-reduce one like lex&yacc
08:29:03 <merijn> (or alex&happy)
08:29:53 <frerich> leshpack: Remember the type our 'merge' function needs to have? I don''t think 'intercalate' fits the bill (neither does 'intersperse' in case you want to suggest that). There's a very basic Haskell function which processes the elements of a list one by one, combining them into a new value (hint: this job is often called 'folding' a list) :-)
08:33:24 <leshpack> frerich: ah ok i need to use foldr?
08:33:31 <frerich> leshpack: Sounds good!
08:33:48 <frerich> leshpack: I recently read 'The Martian' so I'm inclined to say that you're "typechecking the sh!t out of it"
08:34:55 <frerich> leshpack: For what it's worth, there's a variation of 'foldr' called 'foldr1' which only works on non-empty lists. Chances are you like that better. With 'foldr' you need to make up your mind what Command to return if there's an empty list (e.g. if somebody calls 'polygon 0', what happens?)
08:35:18 <frerich> With 'foldr1', you just throw your hands up in the air and define that case to be 'whatever'.
08:36:12 <lostman> hi folks. has anyone ever seen this error message: "Could not resolve file /home/ben/ghc-7.10.2/rts/Linker.c"?
08:36:35 <leshpack> frerich: so I have a list of commands that I need to join with foldr1, putting ":>" in between each one.
08:36:43 <leshpack> So I can use the (++) I guess?
08:37:32 <Zekka|Sigfig> If you pass foldr1 a list that’s too short, you will die!!!!!!
08:37:38 <frerich> leshpack: Not quite. Remember that the [a,b,c] notation is shorthand for 'a:(b:(c:[]))'. I.e. the (:) function is used to prepend some element to a (possibly empty) list.
08:37:55 <Zekka|Sigfig> leshpack: Can you give a sample of your desired input and desired output?
08:38:22 <Zekka|Sigfig> Is it like this? myF [“tac”, “cat”] == “tac :> cat”
08:38:45 <leshpack> yes Zekka|Sigfig
08:39:01 <frerich> leshpack: So e.g. [Fd 1.0, Fd 1.0, Fd 1.0] is the same as '(Fd 1.0) : ((Fd 1.0) : ((Fd 1.0) : []))) (I hope I got those closing ')' right). You can think of 'foldr' as replacing all occurences of ':' with some custom function 'f'.
08:39:18 <Zekka|Sigfig> OK. Well, foldr1 (\x y -> x ++ y) [“tac”, “cat”] == “taccat”
08:39:39 <Zekka|Sigfig> You will probably want to start with that and see if you can use a better joining function to get you what you really want
08:39:43 <bollu> > foldr1 (++) ["a", "b", "c"]
08:39:44 <lambdabot>  "abc"
08:41:48 <vektorweg1> > fold mappend ["a", "b", "c"]
08:41:49 <lambdabot>      No instance for (Foldable ((->) [[Char]]))
08:41:49 <lambdabot>        arising from a use of ‘fold’
08:41:49 <lambdabot>      In the expression: fold mappend ["a", "b", "c"]
08:42:20 <Ankhers> :t fold
08:42:21 <lambdabot> (Foldable t, Monoid m) => t m -> m
08:42:32 <vektorweg1> uh right.
08:42:41 <Zekka|Sigfig> > fold [“a”, “b”, “c”]
08:42:43 <lambdabot>  <hint>:1:7: lexical error at character '\8220'
08:42:47 <Zekka|Sigfig> oh screw my smartquotes
08:42:53 <Zekka|Sigfig> > fold ["a", "b", "c"]
08:42:55 <lambdabot>  "abc"
08:44:04 <leshpack> i dont know i'm lost :/
08:44:20 <leshpack> cant think of a function to put :> in between
08:44:24 <leshpack> not one that works anyway
08:44:44 <Zekka|Sigfig> leshpack: If you have two strings, how do you put “ :> “ between them? 
08:45:21 <Zekka|Sigfig> let putItBetween s1 s2 = ???
08:46:00 <leshpack> im sorry i don't know
08:46:46 <frerich> leshpack: Consider the type of 'foldr1' for lists: (a -> a -> a) -> [a] -> a; if you now pass your (:>) function as the first argument...
08:46:52 <Zekka|Sigfig> leshpack: How do you put two strings right next to each other?
08:47:05 <Zekka|Sigfig> let rightNextToEachOther s1 s2 = ???
08:47:16 <Zekka|Sigfig> (maintaining that rightNextToEachOther “abc” “def” = “abcdef”)
08:48:20 <frerich> leshpack: You could also play with what e.g. 'foldr1 (+)' or 'foldr1 (*)' or 'foldr1 (&&)' do to get an idea of what the function does.
08:48:34 <bollu> guys, any tips on dealing with monad transformer stacks?
08:48:38 <bollu> the types keep tripping me up
08:49:56 <Zekka|Sigfig> bollu: My big takeaways have been: they’re kind of a pain, don’t use mtl and multiple instances of the same monad transformer at the same time, if you use mtl and define a homemade monad type try to make that the base monad, and try not to put ST in your stack
08:50:14 <bollu> Zekka|Sigfig: ST == StateT?
08:50:21 <bollu> zebr: thanks :) and that helps
08:50:26 <Zekka|Sigfig> bollu: Nope, ST is ST
08:50:39 <bollu> Zekka|Sigfig: oh, I don't know what ST is. do tell?
08:51:08 <Zekka|Sigfig> bollu: It’s a monad with a particularly confusing typesig that lets you define truly mutable variables (in a way that doesn’t break purity expectations)
08:51:25 <bollu> Zekka|Sigfig: so it's a performance thing?
08:51:29 <bollu> Zekka|Sigfig: while being pure?
08:51:34 <Zekka|Sigfig> it’s sort of like IO/IORefs but you don’t get arbitrary side effects too
08:52:08 <Zekka|Sigfig> bollu: It’s occasionally neater to write some code with it — it’s hard to exactly simulate it with StateT although you can simulate it with StateT and a lot of rough edges — but it’s mostly a performance thing
08:52:26 <bollu> oh
08:52:27 <bollu> hm
08:52:28 <Zekka|Sigfig> (I shouldn’t say StateT but just State)
08:53:09 <bollu> Zekka|Sigfig: does ST live in GHC, or in Haskell?
08:53:19 <bollu> Zekka|Sigfig: as in, is it a compiler thing or a language thing?
08:53:30 <Zekka|Sigfig> bollu: AFAIK it’s specified as a language thing but I don’t know the details
08:54:56 <geekosaur> STRef requires some GC support, I think, but most of the magic is in the type system
08:57:11 <leshpack> frerich: I just can't get it to work :/
08:57:12 <merijn> ST and IO are actually both specialisations of a more general version of ST which is what GHC uses internally to implement IO and ST
08:57:22 <luite> right, STRef (and IORef) require the GC to be able to deal with variables that can be mutated after creation, which requires some bookkeeping in a generational GC (since updating may result in references pointing from an older generation to a newer one)
08:57:23 <merijn> See the "Lazy Functional State Threads" paper on the details
08:57:34 * hackagebot elm-init 1.0.1.1 - Set up basic structure for an elm project  https://hackage.haskell.org/package/elm-init-1.0.1.1 (justus)
08:58:14 <leshpack> Sorry I'm being REALLY thick
08:58:30 <Zekka|Sigfig> leshpack: To start with, how do you join two strings?
08:58:45 <Zekka|Sigfig> (?) “abc” “def” == “abcdef”
08:59:21 <luite> so ST lives in Haskell, but some things that use it, like MutVar# (the primitive underlying IORef and STRef) are special GHC things
09:00:08 <frerich> leshpack: Have a look at the type of 'foldr1 (:>)'
09:00:30 <Zekka|Sigfig> frerich: Did you mean (:>) there?
09:00:46 <frerich> Zekka|Sigfig: Yes
09:00:48 <Zekka|Sigfig> Because I didn’t think there was an stdlib function that did that
09:00:58 <Zekka|Sigfig> :t foldr1 (:>)
09:00:59 <lambdabot>     Not in scope: data constructor ‘:>’
09:00:59 <lambdabot>     Perhaps you meant one of these:
09:00:59 <lambdabot>       ‘Seq.:>’ (imported from Data.Sequence),
09:01:09 <frerich> Zekka|Sigfig: It's a function leshpack defined himself.
09:03:06 * frerich gotta run
09:06:38 <Blaap> Kinda of haskell-unrelated, but is there anyone with experience with Optimization problems? I´m having some difficulties formulating a problem :(
09:06:59 <Blaap> would be greatly appreciated :)
09:13:37 <mnoonan> Blaap: what kind of optimization?
09:14:50 <Blaap> mnoonan: The case is about an oil refinery which has various types of crude oil that get mixed into final products
09:40:19 <beekeeper> I just started learning Haskell. I'm just blown away with how awesome it is having come from a C,C++,python,JS background. coding a raytracer as a learning project
09:41:50 <dfrey> Is there an existing standard function or a mor idiomatic way to define this:  combine c f1 f2 = \x -> (f1 x) `c` (f2 x)
09:42:56 <dfrey> Basically I want to use this to define a new function which will combine the results of two other functions
09:42:57 <hc> beekeeper: yay
09:43:01 <bergmark> @type show *** round
09:43:02 <lambdabot> (Integral c', RealFrac b', Show b) => (b, b') -> (String, c')
09:43:16 <bergmark> @type show &&& round -- i mean
09:43:17 <lambdabot> (Integral c', RealFrac b, Show b) => b -> (String, c')
09:43:28 <hc> dfrey: can you show some example code?
09:43:47 <glguy> dfrey: liftA2 does that used at the (->)r type
09:44:25 <glguy> though it's generally clearer to write that out than to obfuscate code with reader tricks
09:45:01 <dfrey> hc for instance: let inRange = combine (&&) (> 5) (< 10)
09:45:31 <hc> dfrey: i think mapM might do what you want
09:46:39 <gfixler1> dfrey: it's almost `on`, but you have two different functions
09:46:42 <gfixler1> :t on
09:46:43 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
09:46:54 <gfixler1> and only one x
09:46:59 <glguy> :t liftA2 (&&) (> 5) (< 10)
09:47:00 <lambdabot> (Num a, Ord a) => a -> Bool
09:48:09 <dfrey> It would appear that liftA2 does what I want.
09:48:18 <dfrey> Thanks for the ideas
09:49:33 <Denommus> dfrey: liftA* work in general because functions are applicative functors :-)
09:50:10 <beekeeper> am I right in saying that using 'data' to define a 3-Vector type won't allow me to use the normal arithmetic operatory functions on my vectors?
09:52:17 <ReinH> beekeeper: the normal arithmetic functions work on Num instances
09:52:23 <ReinH> :t (+)
09:52:24 <lambdabot> Num a => a -> a -> a
09:52:36 * hackagebot cayley-dickson 0.3.1.0 - Complex numbers, quaternions, octonions, sedenions, etc.  https://hackage.haskell.org/package/cayley-dickson-0.3.1.0 (lmj)
09:53:37 <ReinH> So if your type isn't a Num instance, those methods won't be defined for it.
09:53:48 <ReinH> Well, most of them do.
09:53:51 <ReinH> :t (/)
09:53:52 <lambdabot> Fractional a => a -> a -> a
09:53:54 <ReinH> But not all.
09:53:57 <beekeeper> hmm
09:54:14 <ReinH> But the same applies for Fractional, etc.
09:54:59 <beekeeper> i'm doing something dumb. my vectors are deriving (Show, Eq, Ord), but adding Num 
09:55:04 <beekeeper> isn't permitted
09:55:15 <ReinH> Num isn't derivable.
09:59:46 <ChristianS> beekeeper: you have to define your Num instance explicitly
09:59:48 <Cale> beekeeper: You'll have to write the Num instance yourself, specifying what (+), (*), fromInteger etc. do for your vectors
10:01:02 <Cale> Usually people avoid that, since multiplication, while possible to define in a sensible way, is an awkward operation to actually use.
10:01:07 <beekeeper> ah cool, it can be done. I haven't learned much of the class system yet. haskell is too much fun so I skip ahead to coding :)
10:01:53 <mnoonan> funny that the cayley-dickson package got updated in the middle of this conversation
10:01:55 <Cale> (componentwise multiplication of vectors is not a very nice operation)
10:02:09 <Cale> Yeah, hah
10:04:15 <beekeeper> is there a reason function operator overloading doesn't exist (like C++)?
10:04:38 <beekeeper> besides making partial function application ambiguous in some cases I guess
10:06:08 <Cale> beekeeper: Uh, you mean like overloading whitespace?
10:06:26 <Cale> Or what?
10:06:35 <Cale> I'm not sure what function operator overloading is
10:06:47 <mnoonan> I might be wrong, but I think if you allow function overloading then type inference has to proceed by guessing and backtracking
10:06:54 <beekeeper> I mean you have the same function defined multiple times with different argument types and numbers
10:07:02 <Cale> Oh, just ad-hoc polymorphism
10:07:13 <Cale> Yeah, we don't have that because type classes are better
10:07:16 <mnoonan> e.g. f :: Int -> Bool and f :: String -> Bool, then you are going to have trouble inferring a type on x in  "f x"
10:07:45 <Ankhers> type classes + polymorphism.
10:07:46 <Cale> You can of course define a class in that case:
10:08:11 <Cale> class HasPredicate t where f :: t -> Bool
10:08:31 <Cale> instance HasPredicate Int where f = ...
10:08:35 <Cale> instance HasPredicate String where f = ...
10:09:10 <Cale> and then f's general type becomes  f :: (HasPredicate t) => t -> Bool
10:09:34 <Cale> and things which simply *use* f can become polymorphic if they don't need to pick a specific t
10:09:55 <ReinH> beekeeper: (skipping ahead to coding is not a bad idea at all)
10:10:36 <beekeeper> yeah it's a fun way. I'm constantly impressed that once something compiled, like 99% of the time it does what you want. i've never had that experience with other langauges
10:10:57 <Cale> beekeeper: Yeah, and it scales too
10:11:28 <Cale> beekeeper: I just finished making hundreds of changes throughout thousands of lines of code, most of which I don't understand, and the code is actually working.
10:11:55 <beekeeper> I work with python mostly. consequently I'm used to code being horribly brittle unless you have a very comprehensive test suite :/
10:12:34 <bergmark> yeah same here, i refactor tons of stuff without trying to understand it :-)
10:22:38 * hackagebot userid 0.1.2.2 - A library which provides the UserId type and useful instances for web development  https://hackage.haskell.org/package/userid-0.1.2.2 (JeremyShaw)
10:35:34 <juanpablo__> Say I have a function "(IO a -> IO a)" and a transformer "MonadWriterT [Int] IO a". How do I lift my function into "MonadWriterT [Int] IO a -> MonadWriterT [Int] IO a"?
10:37:16 <Sindriava> Hi! Say I want to use clang / gcc from Haskell. Is there a better way to do it than invoking shell commands?
10:37:38 <Cale> juanpablo__: That's not really easy/well-defined
10:38:43 <Cale> juanpablo__: You can run the WriterT [Int] IO a with an empty list, and then use liftIO or something
10:38:52 <Sindriava> juanpablo__: I'm not sure that's possible to do in general
10:38:53 <Cale> juanpablo__: But that might not have the meaning you want
10:39:34 <juanpablo__> But is it possible in the context of a WriterT [Int] IO?
10:40:16 <juanpablo__> Cale: any links to documentation where I might learn more about this?
10:41:17 <Sindriava> Actually, isn't MonadWriterT [Int] a functor?
10:41:23 <Sindriava> Should be, right?
10:41:55 <Hijiri> it doesn't have the correct kind
10:42:12 <Cale> MonadWriterT isn't what it's called anyway
10:42:38 * hackagebot clckwrks 0.23.12 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.23.12 (JeremyShaw)
10:42:40 <Sindriava> oh yeah
10:42:48 <Cale> WriterT w m is a functor, whenever m is
10:43:07 <Cale> oh cool, a new clckwrks release
10:43:10 <juanpablo__> yes, but fmap is not what I want right?
10:43:16 <Cale> juanpablo__: that is right
10:43:39 <Cale> juanpablo__: This is why I generally caution people away from designs involving monad transformers over IO
10:43:42 <Sindriava> Cale: Yeah, thanks for that correction, I got confused for a second
10:43:44 <Cale> Sometimes, it's the right thing
10:43:50 <Cale> But you pay a good deal for it
10:44:05 <Cale> (for the first monad transformer you use)
10:44:17 <Sindriava> juanpablo__: You might be better off describing what you're trying to solve, rather than the issue you encountered when solving it
10:44:36 <juanpablo__> Cale: but the same issue with persist if it was WriterT [Int] Identity, right?
10:45:07 <Cale> Well, lifting functions Identity a -> Identity b is significantly easier
10:45:14 <Sindriava> juanpablo__: Chances are, there's a more idiomatic and different solution that can be applied ^^
10:45:20 <Cale> Because that's really (a -> b) in disguise
10:45:23 <juanpablo__> I'm running an arbitrary number of database queries and I need to know how many rows each query affected
10:45:26 <Cale> and fmap does what you want then
10:45:44 <juanpablo__> Each computation produces a WriterT [Int] IO
10:46:05 <Cale> juanpablo__: Maybe consider making a counter IORef, and just using modifyIORef
10:46:06 <juanpablo__> I do a `tell` to save the number of rows affected
10:46:23 <Cale> Rather than using a completely different monad
10:46:24 <juanpablo__> Cale: that's not exactly what I expected lol
10:46:39 <juanpablo__> Is it an IORef really the most elegant solution here?
10:46:53 <Sindriava> juanpablo__: what does the IO a → IO a do in your case?
10:47:04 <juanpablo__> Sindriava: wraps the IO in a transaction
10:47:04 <Cale> juanpablo__: If it makes you unhappy, you can wrap it up so that you have a function (Int -> IO ()) which you pass down to the things which are doing the queries
10:47:22 <Cale> and they just run that action (which secretly increments the IORef)
10:47:32 <Cale> You're already in IO, you might as well use what it offers
10:47:50 <juanpablo__> yeah, sounds super dirty tho
10:48:09 <Cale> I dunno
10:48:41 <juanpablo__> I wonder if there's a nicer way to do this :(
10:48:43 <Cale> WriterT [Int] IO has strictly more stuff in it than IO
10:49:27 <Cale> If you want to avoid the possibility of doing arbitrary IO in this code
10:49:35 <Cale> There are a bunch of approaches you could take
10:49:54 <juanpablo__> I'm already doing IO with the database, but a writer sounds like the perfect solution here
10:49:58 <Cale> One is to make a record type which is parameterised over a choice of monad, and defines all the effectful things you will need
10:50:36 <juanpablo__> Is there any paper or link showing how lifting a function into an arbitrary transformer is ill-defined?
10:50:45 <Cale> data DBOps m = DBOps { incRowsTouched :: Int -> m (); ... }
10:51:12 <Cale> and then you can write functions with types that look like   (Monad m) => DBOps m -> m Result
10:51:37 <Cale> and which use the set of operations which you've given yourself, but won't be able to use other things
10:52:02 <Cale> (Does that make sense?)
10:53:04 <Cale> Perhaps you could even write something of type  DBOps (WriterT [Int] IO)  which used tell in order to implement incRowsTouched
10:53:20 <Cale> but you could just as easily construct a  DBOps IO  which used an IORef.
10:53:31 <frontendloader> nothing out there for generating haskell code from a wsdl?
10:54:15 <Cale> juanpablo__: I'm not sure it's worth a paper. It's just... there's not necessarily a way to run a monad transformer without additional data.
10:54:30 <Cale> juanpablo__: and even if there is, that's not necessarily what you want to do
10:54:43 <Cale> juanpablo__: (depends on your application though)
10:54:58 <juanpablo__> I mean, you automatically have `pure` in a monad transformer
10:55:08 <Cale> You have lift
10:55:09 <Cale> :t lift
10:55:10 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
10:55:11 <juanpablo__> I just want to thread the extra data during the function application
10:55:14 <juanpablo__> yes, I have lift
10:55:16 <Cale> but there's nothing going the other way
10:55:30 <Cale> There's no generic  t m a -> m a  which doesn't lose information
10:55:37 <juanpablo__> and "lift . withTransaction" works
10:57:39 <Cale> If you have a function of type IO () -> IO (), and you want to turn it into  WriterT [Int] IO () -> WriterT [Int] IO (), well, that sounds like you want the resulting WriterT [Int] IO () action to, whenever it uses its argument, have the resulting lists of Ints included in the overall log.
10:57:50 <Cale> However, that's immediately difficult
10:58:47 <Cale> because the IO () -> IO () doesn't know you want to do this
10:58:57 <Cale> It's a black box
10:59:28 <juanpablo__> I wonder if monad-control could be of use here
11:00:22 <Cale> You may be able to rig up an IO action to pass to it which does runWriterT on the input WriterT [Int] IO (), and then writes the resulting log to an IORef (mappending it), and then afterward, you read the IORef and you tell the combined logs
11:00:46 <Cale> But this involved a bunch of stuff which is specific to both IO and WriterT
11:01:12 <Cale> Maybe monad-control could help you, but if this is already challenging... :D
11:01:14 <juanpablo__> yeah, there's no way to have a general function for it
11:01:26 <juanpablo__> I could use monad-control, but then I'd have two problems
11:01:46 <Cale> yeah, pretty much
11:01:48 <Cale> hahaha
11:02:39 * hackagebot cuda 0.7.0.0 - FFI binding to the CUDA interface for programming NVIDIA GPUs  https://hackage.haskell.org/package/cuda-0.7.0.0 (TrevorMcDonell)
11:05:24 <Cale> juanpablo__: another thing that I generally try to avoid is naked monad transformers hanging around -- if you're writing BlahT anywhere other than inside a newtype declaration, it's worth considering whether you a) really need the monad transformer, and b) if so, whether you can form a nice module which uses it to define a specific monad that you'll use, along with enough operations that you don't have to explicitly li
11:05:24 <Cale> ft things from outside the module
11:06:10 <juanpablo__> Cale: I have type synonym (itssomething)
11:06:12 <juanpablo__> lol
11:06:31 <Cale> That doesn't exactly solve your problem of what to do with  IO () -> IO ()  things, but it forces you to confront that problem early.
11:07:43 <takaci> I'm new to haskell and I was doing the CIS194 problems, I found a solution to problem 1 on the third homework which I didn't really understand. State represents a map of variables names (Strings) to values (Ints), but I don't get why extend is written with four arguments? http://lpaste.net/146226
11:08:42 <takaci> What is the type of y?
11:08:50 <mnoonan> the y is the first argument to the final State in extend's signature
11:08:56 <Cale> takaci: Well, if you substitute State for String -> Int
11:09:18 <Cale> takaci: then you have  extend :: (String -> Int) -> String -> Int -> String -> Int
11:09:27 <deam> how do I rewrite this to show an array of every number instead of the final one? https://gyazo.com/6b169828ebdde66c0572e0805c9f15bd
11:09:35 <juanpablo__> takaci: expand the type synonym :)
11:09:47 <takaci> Ahh okay, but then surely extend returns an Int instead of a State?
11:10:08 <Cale> takaci: The right hand side of the equation is indeed an Int
11:10:24 <OverCoder> Why should I learn #haskell?
11:10:49 <mnoonan> it's exactly equivalent to writing "extend s x v = \y -> if x == y then v else s y"
11:10:50 <Cale> takaci: But it's a bit of a funny question which type it really returns, because functions of multiple arguments in haskell are really functions of a single argument which produce a function as their result
11:11:14 <takaci> mnoonan: Thanks! That clears it up a lot for me
11:11:45 <Cale> OverCoder: Because you're dissatisfied with the programming languages that you already know, or you're a beginner to programming who wants to start out on a very solid theoretical foundation.
11:11:49 <takaci> Cale: This is currying right?
11:12:08 <deam> someone?
11:12:29 <Cale> takaci: Well, currying is the process of converting functions which take tuples into functions of this sort, but you can say that functions in Haskell are "already curried" in some sense
11:12:45 <Cale> deam: sure...
11:13:04 <deam> Cale: help please :(
11:13:21 <Cale> deam: are you looking for   map fib [0..]  ?
11:13:43 <Cale> deam: There are much faster implementations of fib which simply compute that list directly
11:13:45 <deam> hmm I'll try it out
11:13:49 <Cale> deam: for example
11:14:05 <Cale> lucas n m = n : lucas m (n+m)
11:14:10 <Cale> fibs = lucas 0 1
11:15:29 <deam> what
11:15:36 <Cale> This is faster because it avoids a lot of recomputation -- the naive version of fib you have there will compute exponentially many applications of fib
11:15:45 <deam> ohh
11:16:05 <deam> that's why it took forever to calculate 100
11:16:22 <Cale> So, lucas n m is the list which starts with n, and continues with the list lucas m (n+m)
11:16:41 <Cale> So we have:
11:16:45 <deam> what's the ":"
11:16:57 <Cale> Ah, you're really just starting out then :D
11:17:08 <deam> yes haha
11:17:08 <Cale> : sticks an element on the beginning of a list
11:17:14 <deam> oh I see
11:17:20 <Cale> In Haskell, every list is either the empty list []
11:17:39 <Cale> or it is a nonempty list formed as (x:xs) from an initial element x, and another list xs
11:17:47 <Cale> > 1 : [2,3,4,5]
11:17:49 <lambdabot>  [1,2,3,4,5]
11:18:00 <deam> yes
11:18:13 <Cale> In fact, [1,2,3,4,5] is syntax sugar for 1 : (2 : (3 : (4 : (5 : []))))
11:18:36 <Cale> So yeah
11:18:57 <Cale> We can unfold this equation a few times to see a bit of what lucas does:
11:19:29 <Cale> lucas n m = n : lucas m (n+m) = n : (m : lucas (n+m) ((n+m)+m))
11:20:16 <Cale> = n : m : (n+m) : lucas ((n+m)+m) (((n+m)+m) + (n+m))
11:21:01 <deam> hmm
11:21:08 <Cale> when I unfold it like this, it's less obvious why it's actually more efficient -- a lot of these addition expressions (like every occurrence of n+m here) are actually references the same structure in memory and evaluating the addition will evaluate them all
11:21:08 <deam> trying to use this in #purescript
11:21:35 <Cale> But that's an implementation detail we don't need to worry about when just getting a handle on what the result is
11:21:53 <Cale> So, this looks like a piece of the Fibonacci sequence, yeah?
11:22:21 <deam> yes..
11:22:41 <Cale> So, yeah, when we plug in the real starting numbers for the Fibonacci sequence, we'll get the whole thing
11:23:02 <Cale> lucas 0 1
11:23:04 <Cale> = 0 : lucas 1 (0+1)
11:23:24 <Cale> = 0 : 1 : lucas (0+1) ((0+1)+1)
11:23:31 <Cale> = 0 : 1 : lucas 1 2
11:23:43 <Cale> = 0 : 1 : 1 : lucas 2 (2 + 1)
11:23:49 <Cale> = 0 : 1 : 1 : lucas 2 3
11:23:54 <deam> wat
11:24:00 <deam> will it give me an infinite list?
11:24:04 <Cale> yes
11:24:47 <Cale> (I'm just randomly doing evaluations and substituting in the definition of lucas there, like highschool algebra plugging in a definition)
11:24:47 <deam> how do I stop it?
11:24:56 <Cale> Ctrl-C will stop it
11:25:05 <Cale> Or you can apply a function like  take 100
11:25:13 <Cale> to get the first 100 elements of the list
11:25:17 <deam> ah I see
11:25:35 <deam> is lucas the fastest way?
11:25:37 <Cale> Or just use the list somehow, and more elements will be computed as you need them
11:25:51 <Cale> There are faster, but you start needing real mathematics :D
11:26:05 <Vomit_> Hi, I have a binary data parsing question. I've got a binary file composed of 0xFFFFFFFF markers that I want to skip (or use to find byte synchronisation) and data packets of 17 16-bit words
11:26:08 <deam> oh, I'll wrap my head around this first
11:26:12 <deam> thanks for your help Cale
11:26:34 <Vomit_> I've written a parser using attoparsec that works but spent a lot of time getting it to run on a 100+ MB file without overrunning memory.
11:27:03 <Cale> https://wiki.haskell.org/The_Fibonacci_sequence#Fastest_Fib_in_the_West -- the syntax highlighter seems to have screwed up since this was written, but yeah, here's a fancy version
11:27:27 <Vomit_> My end result is another file, so I don't actually need all of the parsed result in memory at once. Just packet by packet translated into some ASCII representation in the destination file
11:27:45 <deam> Cale: seems advanced :S
11:28:01 <Cale> deam: Yeah, it's not obvious :D
11:28:18 <Cale> deam: There's another mindbender version:
11:28:24 <Vomit_> In the end I have a recurive parse function that tries to apply a parser that returns ([Packet], remainingbytestring)
11:28:30 <Cale> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
11:29:06 <Cale> zipWith f xs ys will take the lists xs and ys and combine corresponding elements using the function f, to produce a list of the result
11:29:07 <Cale> s
11:29:10 <Vomit_> every iteration I parse as many packets as I can find until I hit a 0xFFFFFFFF marker, then in the next recursive iteration I parse the remaining string (lazy bytestring)
11:29:45 <deam> Cale: I can't follow yet..
11:29:47 <Cale> i.e.  zipWith f [a0,a1,a2,...] [b0,b1,b2,...] = [f a0 b0, f a1 b1, ...]
11:29:51 <zipper> Is there a haskell channel where we test irc bots?
11:29:56 <zipper> I can't remember clearly.
11:30:21 <Vomit_> in each iteration I also print out the ascii representation of the [Packet] to stdout
11:30:25 <Xeironis_> almost all online syntax highlighting I've seen of Haskell gets confused with apostrophes...
11:30:29 <Xeironis_> zipper: /query lambdabot
11:30:37 <Xeironis_> oh
11:30:38 <Vomit_> It works but I have the impression that this manual outer loop is just a way of showing that I'm missing a way to tell the parser to be lazy and work in a stream fashion.
11:30:48 <Xeironis_> sorry, read your question wrong
11:30:55 <Cale> Vomit_: okay, that sounds kinda reasonable... when you say that it returns the remaining bytestring, do you mean it does so explicitly, or just because that's what attoparsec already gives you
11:30:56 <geekosaur> | grep -v ' \*  '
11:30:57 <zipper> Xeironis_: Not to test this bot. To test a bot I wrote in haskell.
11:30:58 <geekosaur> whoops
11:31:31 <justin_smith> zipper: you can join any made-up channel name, and I think there's something like #bot-test too
11:31:35 <Vomit_> There should be some way to tell the parser that it can stop worrying about backtracking once the output has been produced
11:32:58 <Vomit_> Right now the piecemeal parsing is really a way to ensure that I pull out as many [Packet] as I can, so I can print their representation, forget about the already parsed part, then continue parsing the remaining string.
11:33:12 <deam> Cale: I'll have to pass this one
11:34:22 <Vomit_> Is attoparsec the wrong way to go and it is inherently insisting on having potential backtracking points literally everywhere until it sees the entire multimegabyte input string?
11:34:29 <Cale> Vomit_: Yeah, I believe the thing to do is to run your parser for one packet many times (using one of the few ways attoparsec gives you for running a parser at the top level)
11:34:48 <Cale> attoparsec will give you the remainder of the string along with the result
11:35:12 <Cale> and you get the first packet's result immediately and can decide if you want to parse another packet
11:35:35 <Cale> and that way there's no potential backtracking between packets
11:35:46 <Cale> because you're actually running separate parsers
11:36:08 <Vomit_> well actually I didn't find such a parsing function, in the end I wrote a single shot parser that does 0-or-more markers, followed by 0 or more packets, followed by an explicit return of the remaining unparsed data using (hold on, checking)
11:36:26 <Cale> ah, okay
11:36:53 <Vomit_> takeLazyByteString
11:37:18 <Vomit_> so my parser is type Parser ([Packet], ByteString)
11:37:26 <Cale> You usually want to do the chunking from outside the Parser
11:37:38 <Cale> For most network-protocol-y stuff anyway
11:37:55 <Cale> It's just easier to get right in my experience
11:38:16 <Vomit_> with something like do {skipMany marker ; pkts <- many packet; remainder <- takeLazyByteString ; return (pkts, remainder) }
11:38:17 <Cale> So you apply parse to a Parser Packet, and your initial ByteString
11:38:25 <Cale> yeah, don't do that
11:38:28 <Vomit_> :)
11:38:36 <Cale> It's already going to give you the rest of the bytestring when you run the parser
11:38:57 <Cale> (using parse, or parseWith)
11:39:05 <Vomit_> actually I didn't find that function, only a parse function that returns success, partial or failure
11:39:06 <hsk3> Is someone here using Stack? Question: Is the resulting binary from "stack build" ALWAYS completely standalone, and is "stack exec foo-exe" just executing that standalone binary and doing nothing else magical?
11:39:20 <Vomit_> but partial returns a continuation function, not the actual remaining string
11:39:24 <Cale> Vomit_: You'll note that the Done case in IResult has the remainder of the ByteString
11:39:27 <Vomit_> and no access to interim parse results
11:39:46 <Cale> Vomit_: Yeah, Partial will mean that you parsed half a packet
11:39:58 <Vomit_> yes the Done case, but by that time I've parsed the multi100MB file and I get an out of memory error because I haven't printed anything yet
11:40:07 <Cale> Vomit_: Which means, if you're writing a network thing, that you need to wait for another TCP packet or whatever
11:40:19 <Cale> no, you don't put the entire 100MB file in
11:40:30 <Vomit_> Actually I'm running from file to file, so I don't need input file suspension
11:40:40 <Vomit_> on the contrary I would require interim output results
11:40:41 <Cale> Or rather, you don't expect a single parse to eat the whole 100MB
11:40:53 <Vomit_> but from the point of view of the parser, that's a chicken and egg problem
11:41:13 <Vomit_> because it won't know if it would like to backtrack later if it should hit a dead end in the future
11:41:14 <Cale> Maybe I need to know something more about your problem to say for sure
11:41:39 <Vomit_> so I'm somehow looking for a way to hint the parser to commit to a particular path and forget about backtracking
11:41:54 <Cale> But in basically any case where it makes sense to get some output without reading the entire file...
11:42:08 <Cale> you can run a parser which only looks for a single "chunk"
11:42:12 <Vomit_> so the interim parser output could already be produced and therefore free memory once it is printed to the output file
11:42:31 <Cale> and then when it gives Done remainingString chunkResult
11:42:40 <Vomit_> well that's whay I'm doing, with chunks ending when it has done one iteration of skipMany markers + many Packets
11:43:04 <Cale> Your problem is that you're eating the entire file inside the parser
11:43:15 <Vomit_> it somehow feels unidiomatic because I'm pulling the parser apart and writing my own "combinator" i.e. infinite loop
11:43:20 <Cale> which will I believe end up resulting in converting the whole thing into a strict ByteString
11:43:29 <Cale> At least if I recall correctly...
11:43:38 <Vomit_> I'm using the lazy bytestring variant of the parser
11:43:52 <Vomit_> http://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-ByteString-Lazy.html
11:44:38 <Cale> Yeah, it looks like it produces a Lazy bytestring, but there was some reason that attoparsec liked to convert the part of the string it was operating on to a strict bytestring... my memory here is a bit hazy
11:44:40 <Vomit_> there's a cryptic hint on the strict packagehttp://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-ByteString.html
11:44:57 <Vomit_> (checking)
11:45:40 <Cale> and in any case, you're sort of forcing the entire parse to succeed or fail before any part of the result is really available
11:46:22 <Cale> Because if it's all in one parser, then the very end of the parse might fail, and then it wasn't supposed to have produced any partial output.
11:47:09 <Vomit_> exactly, that's what I concluded and why I decided to de the chunking loop externally
11:47:12 <Cale> So if you really want to stream things, you have to make the point at which it succeeds or fails earlier
11:47:22 <Cale> than the point at which you've consumed all the input
11:47:40 <Cale> yeah
11:47:46 <Vomit_> I can't find that cryptic remark anymore, it was something to the extent that streaming could be done using the conventional pipes mechanism
11:48:05 <Cale> Oh, maybe something to do with pipes-attoparsec
11:48:06 <Vomit_> but I haven't ever used conduits/pipes so I'm not familiar
11:48:21 <Cale> I avoid them whenever I can
11:48:25 <Vomit_> :)
11:49:00 <Vomit_> i's a bit reassuring to hear that my approach wasn't totally unidiomatic, so I'll just stick with it :)
11:49:02 <Cale> (they're a really machines which are good at what they do, but it's a lot of machinery to pull in for most applications)
11:49:29 <Cale> Yeah, just try using the remainder of the output that attoparsec already provides when you run the parser
11:49:37 <ReinH> At least pipes has somewhat less conceptual machinery, given its simpler design (imo)
11:49:49 <Cale> The Done constructor will hold the remainder along with the result
11:50:15 <Cale> (and you probably don't really need to worry about Partial and can treat that like failure, if you're reading from a file)
11:50:30 <Vomit_> Yes, and as I don't want that to occur after hundreds of MB I need to chunk the input
11:50:47 <Vomit_> but I can't just chunk it like with "lines" because it is not simple to demarcate
11:51:02 <Cale> Well, I'm saying you chunk it using your parser
11:51:06 <Vomit_> so I chunked it in runs of {markers*packets*}
11:51:17 <Cale> So you parse one marker, say
11:51:18 <Vomit_> => seems acceptabke
11:51:44 <Vomit_> I skip as many markers as I find (don't need them) and then parse as many packets as I can until I hit a marker
11:51:44 <Cale> and run that parser over and over on the remainder of the input you got from the previous run
11:52:18 <Vomit_> then I get the packets from the parser, print their represnetation to a file, then parse the remaining input (starting with the markers that stopped the previous parse)
11:52:21 <Cale> But don't use takeLazyByteString
11:52:42 <Vomit_> Oh yes I see, use the Done itself
11:52:48 <Cale> right!
11:52:59 <Vomit_> thx, I will try that!
11:53:08 <hsk3> Is someone here using Stack? Question: Is the resulting binary from "stack build" ALWAYS completely standalone, and is "stack exec foo-exe" just executing that standalone binary and doing nothing else magical?
11:54:20 <Cale> hsk3: I don't really know because I haven't used Stack, but if it's like most Haskell stuff, it will typically be standalone with respect to Haskell libraries (unless you went out of your way to turn on dynamic linking), but maybe not with respect to C libraries.
11:54:35 <hsk3> Cale: ok thanks
11:57:41 * hackagebot list-zip-def 0.1.0.0 - Provides zips where the combining doesn't stop premature, but instead uses default elements.  https://hackage.haskell.org/package/list-zip-def-0.1.0.0 (muesli4)
12:13:43 <akegalj> hey. How to create an instance of FromJSON in aeson for nested values. I would like to read   {"person" : {"age" : 1}}    into    data A = A { age :: Int }  . This I have so far: parseJSON (Object v) = A <$> v .: "person"    , but how to get age from person?
12:17:55 * hackagebot bbi 0.1.0 - Tools for reading Big Binary Indexed files, e.g., bigBed, bigWig  https://hackage.haskell.org/package/bbi-0.1.0 (kaizhang)
12:21:08 <sm> hsk3: what Cale said, and: stack exec just runs the executable, but also sets some env vars like GHC_PACKAGE_PATH, HASKELL_DIST_DIR, HASKELL_PACKAGE_SANDBOXES, HASKELL_PACKAGE_SANDBOX, STACK_EXE, and prepends the stack bin dirs to PATH.
12:21:26 <sm> (your executable probably won't care about these things)
12:21:44 <hsk3> sm: ok cool, thanks
12:22:03 <hsk3> sm: so i can always just grab that executable and do what i want with it and move it where i want and run it like any other unix program
12:22:10 <hsk3> ?
12:22:24 <hsk3> the one in the ./stack-work
12:22:25 <akegalj> ok I found the answer
12:22:30 <sm> yes, for some value of "always" :)
12:22:55 * hackagebot bioinformatics-toolkit 0.1.0 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.1.0 (kaizhang)
12:22:58 <sm> you can move it anywhere on your current system, but maybe not ship it to users and expect it to always work on theirs
12:23:42 <hsk3> sm: well, if it's the exact same OS (or later OS) it should work right?
12:23:57 <hsk3> later version of the same OS, i mean
12:24:11 <hsk3> and same cpu arch
12:24:14 <sm> and architecture - yes, I would say so, except eventually there'll be some upgrade that breaks something
12:24:55 <hsk3> ok
12:25:32 <sm> I think some folks have shown you can build more robust truly self-contained/fully-static executables, with effort
12:25:59 <shapr> neat, 15 year anniversary of #haskell is 42 weeks away
12:26:08 <shapr> I think the current founder should throw a party.
12:26:36 <hsk3> sm: who?
12:26:58 * sm doesn't remember
12:29:08 <monochrom> 42 weeks is almost a year
12:29:52 <c_wraith> monochrom: good parties take time to plan. 
12:30:12 <shapr> yeah, it should be a really good party
12:30:24 <sm> with cake!
12:31:27 <shapr> should have it someplace that's easy for people to visit
12:31:35 <shapr> boston?
12:32:09 <OverCoder> Guys, seriously, what is there in Haskell that isn't in C++ or Java?
12:32:35 <OverCoder> Every expert programmer points his finger at me and tells me to learn Haskell, why would I
12:35:30 <Phyx-> lol, Boston is easy?
12:36:41 <hrnz> OverCoder: nothing in haskell is like anything in c++ or java.
12:36:59 <OverCoder> hrnz, Ah,
12:37:25 <OverCoder> hrnz, I like discovering and learning new stuff, so would you think this would be joyful to me? (and useful ofc)
12:39:39 <exio4> OverCoder: at worst, it'll help you think about problems in different ways than what you're probably used to 
12:39:47 <Phyx-> To be perfectly honest, the only reason I learned Haskell was because it was thought at the university. The reason I kept learning was because of how learning it made me think differently about problems
12:40:39 <Phyx-> The type system and certain class of problems are just solved much nicer in functional languages imho.
12:40:51 <OverCoder> 03> New way of thinking
12:41:04 <OverCoder> 03> Do stuff in an entirely other way
12:41:18 <OverCoder> Alright alright, I think it's the right moment to get started
12:41:22 * OverCoder goes to learn Haskell
12:41:26 <hrnz> \o/
12:42:21 * Phyx- actually absolutely hated Haskell when he first got it
12:42:22 <suppi> OverCoder, https://github.com/bitemyapp/learnhaskell or www.haskellbook.com (I haven't read it but it gets many good reviews)
12:43:42 * OverCoder hugs suppi
12:43:44 <OverCoder> Thanks
12:44:29 <suppi> good luck and have fun :)
12:51:19 <Xeironis_> is lyah still a thing that people recommend?
12:52:22 <zachk> personally, I liked programming in haskell by graham hutton, if you are just beginning, clears up the syntax alot
12:52:55 <Ankhers> Xeironis_: I see it recommended sometimes. But it does not have any examples. So it is generally not considered a very good learning resource.
12:53:44 <Xeironis_> I see, that makes sense. I liked it.
12:57:51 <Ankhers> I enjoyed reading it, but I did not pick up very much from it compared to other resources I used.
12:58:20 <hsk3> Xeironis_: a new book i heard of recently is http://haskellbook.com
12:58:29 <hsk3> i read lyah and loved it, but this will be my next one!
12:58:38 <hsk3> an alternative book for beginners, but with a lot more stuff
12:58:41 * hackagebot wai-middleware-verbs 0.1.0 - Route different middleware responses based on the incoming HTTP verb.  https://hackage.haskell.org/package/wai-middleware-verbs-0.1.0 (athanclark)
12:58:42 * hackagebot wai-middleware-content-type 0.1.0 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.1.0 (athanclark)
12:58:43 <hsk3> great sequel potentially
12:58:44 * hackagebot vault 0.3.0.5 - a persistent store for values of arbitrary types  https://hackage.haskell.org/package/vault-0.3.0.5 (HeinrichApfelmus)
12:59:48 <Xeironis_> Looks promising
13:01:06 <Xeironis_> oh wow, the sample has 73 pages, that's nice
13:01:34 <hsk3> yeah
13:01:47 <Ankhers> Book currently has over 1000 pages I believe.
13:01:55 <Ankhers> I have only read the first couple chapters.
13:02:21 <suppi> Ankhers, read it as well, it was fun but I couldn't write haskell after finishing it.
13:02:26 <suppi> (lyah)
13:02:54 <Ankhers> I believe that is the experience of most people that read LYAH.
13:03:10 <hsk3> my experience as well!
13:03:21 <hsk3> it was a great book, and i learned a lot, but i couldn't do shit lol
13:03:24 <Xeironis_> I don't remember... it was so long ago...
13:03:43 <Xeironis_> like more than 2 years. My memory ain't good enough for that
13:03:49 <suppi> hsk3, this is pretty common experience as far as i saw
13:03:54 <hsk3> hehe
13:04:03 <OverCoder> What is stateless programming like?
13:04:15 <suppi> OverCoder, pretty cool actually
13:04:32 <mmaruseacph2> Stateless programming is concurrency heaven or close to it
13:04:55 <tailgate> I'd like to have a type that contains a Data.Map (String, Fractional) - what does the syntax for that look like?
13:04:56 <OverCoder> Like, I used to do concurrency stuff with C/C++ and Java, how can it be different here?
13:04:59 <suppi> OverCoder, it has many benefits. I recommend trying it to see for yourself
13:05:05 <OverCoder> Ah OK
13:05:12 <suppi> OverCoder, did you use locks and stuff?
13:05:17 <OverCoder> Nope
13:05:29 <exio4> how did you avoid data races? 
13:05:45 <suppi> OverCoder, so what did you do to make sure you don't change the same thing twice without control?
13:06:01 <OverCoder> Using 'synchronized' keyword in functions
13:06:12 <OverCoder> synchronized functions are only called once
13:06:39 <OverCoder> so things like: setObject(obj) can only be called once at a time
13:06:59 <cite-reader> So, you used implicit mutexes.
13:07:01 <OverCoder> (Maybe I misunderstood stuff? let me read the web again)
13:07:02 <Ankhers> OverCoder: What if you called two functions that mutated a single variable?
13:07:12 <Xeironis_> tailgate: I think you want Fractional a => Data.Map String a, if I'm understanding correctly
13:07:15 <tdammers> OverCoder: that doesn't always prevent race conditions
13:07:17 <Hafydd> tailgate: what would it mean for a type to "contain" Map (String, Fractional) :: * -> *?
13:07:23 <OverCoder> Ankhers, It breaks, I mean, I haven't tried actually
13:07:33 <suppi> what if one function from a syncronized context call another and the same thing happens at the same time from the other direction?
13:07:51 <OverCoder> I also haven't tried/ I don't know
13:08:02 * OverCoder has to read the moar
13:08:14 <tdammers> suppi: I believe one of the function calls blocks until the other finishes
13:08:18 <suppi> OverCoder, after you learn some haskell, definitely read "Parallel and Concurrent Prorgramming in Haskell" :)
13:08:32 * OverCoder hugs everyone
13:08:38 <suppi> tdammers, and releases the lock?
13:08:52 <tdammers> suppi: no, it blocks on acquiring the lock :D
13:09:03 <tailgate> Xeironis_: thanks
13:09:05 <tdammers> suppi: and I believe it'll hold on to the outer lock
13:09:09 <suppi> because if f needs g and g needs f and both are locked we are out of l(o)uck  :)
13:09:14 <tdammers> yep
13:09:24 <suppi> g2g, bye for now :)
13:09:29 <tdammers> that's why I said "that doesn't always prevent race conditions"
13:10:27 * OverCoder 's mind scatters a more about locks and stuff, oh boy, I definitely missed big chunk around that
13:10:29 <suppi> tdammers, yes :)
13:10:38 <OverCoder> I mean, I need to learn more, how crap
13:10:54 <Cale> OverCoder: One big difference about Haskell is that there is a clear separation between evaluation of expressions (i.e. turning expressions into values), and execution of IO actions (which may have effects, including memory effects)
13:10:59 <suppi> also: running a function on a list of arguments is as simple as: parMap f list
13:11:01 <suppi> bye :)
13:11:35 <OverCoder> Cale, ah, so, for example, Haskell doesn't have something like, variables? (or those whose are stored in RAM?)
13:11:42 <Cale> OverCoder: Two threads may evaluate the same expression and are guaranteed pretty much every time to get the same result (unless there's some incorrect usage of low-level hackery going on).
13:12:06 <Cale> But executing the same IO action multiple times may produce different results.
13:12:10 <tdammers> OverCoder: it does, but if you want them to be mutable, you need to jump through a few hoops, and those hoops make sure you're not mutating anything when you shouldn't
13:12:13 <OverCoder> Ah, alright then
13:12:27 <Cale> So, the things which manipulate mutable references are all IO actions
13:12:35 <tdammers> OverCoder: one way of getting mutable variables is through IORefs, but those require IO actions to access them
13:12:40 <Cale> There's a lot of stuff you can do in Haskell without resorting to IO actions though
13:12:57 <Cale> So, things are closer to being automatically thread safe by default
13:13:07 <OverCoder> Ah alright, now I got it
13:13:40 <OverCoder> Great explanation, better than wiki :p
13:18:41 * hackagebot postgresql-binary 0.7.4.1 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.7.4.1 (NikitaVolkov)
13:18:43 * hackagebot Cabal 1.22.5.0 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-1.22.5.0 (ryant)
13:46:07 <joel135> How do I do this? [1,2,3]*[4,5,6]=[4,10,18]
13:46:26 <Xeironis_> > zipwWith (*) [1,2,3] [4,10,18]
13:46:27 <lambdabot>      Not in scope: ‘zipwWith’
13:46:27 <lambdabot>      Perhaps you meant one of these:
13:46:27 <lambdabot>        ‘zipWith’ (imported from Data.List),
13:46:30 <OverCoder> joel135, Open a calculator
13:46:31 * OverCoder hides
13:46:33 <Xeironis_> > zipWith (*) [1,2,3] [4,10,18]
13:46:35 <lambdabot>  [4,20,54]
13:46:45 <Xeironis_> err
13:46:51 <Xeironis_> oops
13:46:59 <Xeironis_> > zipWith (*) [1,2,3] [4,5,6]
13:47:01 <lambdabot>  [4,10,18]
13:47:15 <joel135> Thanks! :)
13:47:19 <Xeironis_> welcome
13:50:02 <dgpratt> just curious, is there anything representable with tuples that is not equivalently representable with HLists?
13:50:30 <Cale> HLists are basically just nested tuples :P
13:50:41 <geekosaur> it's more he other way, you can't extend a tuple but you can extend an HList
13:50:43 <geekosaur> etc.
13:51:02 <dgpratt> could Haskell or a similar language have based tuples on an HList-like structure?
13:51:26 <dgpratt> it seems like there'd be some advantages
13:51:54 <geekosaur> also disadvantages (ever seena  type error involving HList?)
13:51:57 <Cale> It could have, but have you looked at the definition of HList?
13:52:07 <Cale> and yeah, the type errors ugh
13:52:10 <dgpratt> it's quite terrifying, I grant you :D
13:52:30 <dgpratt> but then so is Lens :D
13:52:31 <Cale> If you're going to do that, just build extensible records into the language
13:52:45 <Cale> like what Ermine does
13:52:55 <Cale> It'll end up a lot nicer
13:53:29 <dgpratt> I kinda missed some of the details, but it seems Elm nerfed their extensible records in the most recent version, did they not?
13:53:30 <Cale> HList basically does that as a library using a couple Olegs worth of hideous type level hackery
13:54:40 <Cale> The scary part is that it's actually nicer now than it used to be
13:54:54 <Cale> since it has DataKinds
13:56:34 <dgpratt> Elm 0.16 removes "record field addition and deletion"
13:57:30 <bitemyapp> >couple Olegs worth
13:57:31 <dgpratt> thought it quite interesting that they were motivated to actually remove it as a language feature
13:57:40 <donut2d> Newbie here: What's the name of the package I should add to my .cabal "build-depends" field to be able to import "Network.HTTP.Base"?
13:58:10 <Denommus> finally managed to compile a project with reflex-dom on stack
13:58:42 <MarcelineVQ> donut2d: http://hackage.haskell.org/package/HTTP https://www.haskell.org/hoogle/?hoogle=Network.HTTP.Base
13:59:34 <donut2d> MarcelineVQ: Thanks. I had the name, didn't realize it was case-sensitive?
14:00:59 <Cale> Yeah, package names are case sensitive
14:01:05 <Cale> Pretty much everything is case sensitive
14:01:15 <donut2d> Good to know. Thanks!
14:10:40 <joel135> Can you help me make this compile? http://lpaste.net/146239
14:11:24 <joel135> The problem lies at the third nested "where". It is supposed to be visible in the definitions of u and v.
14:13:24 <Xeironis_> why not just put nz into the second where?
14:13:35 <Xeironis_> or rather, why not just put everything into the first where?
14:13:44 <Xeironis_> ^ joel135 
14:13:57 <geekosaur> joel135, the scope of the second where is the definition of v
14:14:17 <joel135> Hm, I didn't think about that. And yet I just read that order does not matter in haskell except for in "do" clauses. Thank you!
14:14:21 <geekosaur> and yes, you should just collapse those all togther than trying to be fancy
14:14:26 <geekosaur> it's not order, it's scope
14:14:33 <Sonarpulse> does doctest not work with implicit params?
14:14:41 <geekosaur> where scopes to a definition. in this case the definition is that of "v"
14:14:43 <Sonarpulse> I am getting a parse error on => after implicit param
14:15:24 <geekosaur> so at the least you want to put nz in the same clause as u and v
14:19:15 <happyfeet> hey, how ca i make a: function :: a -> a  
14:19:31 <Denommus> :t id
14:19:32 <lambdabot> a -> a
14:19:33 <happyfeet> but in the middle make it perform a "callcommand"
14:19:34 <monochrom> "function x = x"
14:19:41 <monochrom> cannot
14:19:58 <Denommus> happyfeet: "call command"?
14:20:14 <joel135> I can't use just one where because the definitions of u, v, nz depend on i, j which are arguments of f. So I'll use two where's.
14:20:20 <DarwinElf> pikajude, so did you try recompiling kevin? I have an intermittent connection and no logs, so I couldn't see earlier
14:20:30 <padre_angolano> I just learned about 'data T = forall a . T a'. What can I do with a value of such a type? It seems that I cannot pattern match it, e. g. 'case T 'a' of T 'a' -> 1' doesn't work :-)
14:20:46 <happyfeet> Denomnus basically a "do XXXX"
14:20:51 <happyfeet> https://hackage.haskell.org/package/process-1.4.1.0/docs/System-Process.html
14:21:22 <Denommus> happyfeet: I'm not sure I understand what you want to do
14:21:23 <monochrom> padre_angolano: I wonder where you learned that from, such that that place doesn't go on to show example usages
14:21:28 <pikajude> sorry DarwinElf, i have been swamped
14:21:30 <happyfeet> for exemple : function a = do callCommand "something"
14:21:32 <happyfeet> and return an a
14:21:33 <pikajude> i have a few minutes to try it right now
14:21:35 <Denommus> happyfeet: you want a pure function to spawn a new process?
14:21:42 <Denommus> happyfeet: that's impossible
14:21:57 <Xeironis_> joel135: You could if you gave i and j as arguments to u and v, but yes, otherwise you have to use two
14:21:57 <happyfeet> is there any way around this?
14:21:59 <Denommus> happyfeet: what you CAN do is putting it under IO
14:22:11 <Denommus> happyfeet: making it an impure function :P
14:22:21 <happyfeet> can you explain that?? :)
14:22:30 <Cale> happyfeet: A function of type a -> a can't do anything apart from looping forever, throwing an exception that kills the program, or producing the input value as the output
14:22:32 <monochrom> https://wiki.haskell.org/Existential_type is one place showing how to write useful existential types
14:22:40 <Cale> happyfeet: Those are the only possibilities
14:23:00 <padre_angolano> monochrom: I bumped into a similar construction when reading Control.Exception docs, where there is 'forall e . Exception e => Handler (e -> IO a)' :-)
14:23:02 <Cale> happyfeet: If you want the program to actually have some other effect, you'll want to produce an IO action.
14:23:05 <Xeironis_> (*cough* unsafePerformIO *cough*) :p
14:23:23 <Cale> happyfeet: i.e. write a function of type  a -> IO a
14:23:23 <cite-reader> unsafePerformIO will just make happyfeet sadder than they already are.
14:23:28 <Xeironis_> true
14:23:38 <happyfeet> Xeironis I have tried that but I still have error with the input that is not IO
14:23:41 <geekosaur> Haskell is a pure functional language. This means you can't have arbitrary hidden side effects. (or if you cheat as someone just hinted, the compiler is free to pretend you didn't and Bad Things usually result)
14:23:42 <monochrom> ok, "forall e . Exception e => Handler (e -> IO a)" is more usable than "forall a. T a"
14:23:59 <Cale> which takes a value of type a, and produces a result which is an IO action that when executed, will have the effect that you want before returning the given value as its result
14:24:01 <Denommus> happyfeet: function a = do { callCommand "foo"; return a }
14:24:19 <Denommus> happyfeet: or even `function a = callCommand "foo" >> return a`
14:24:20 <padre_angolano> monochrom: right, then I went ahead and created a similar type of my own :-)
14:24:27 <nathyong> hey all, I have a small coding problem that I want to see implemented in Haskell
14:24:34 <nathyong> http://lpaste.net/146241
14:24:48 <KaneTW> Cale: if we're going that way, we can just do f :: a -> a; f x = unsafePerformIO $ (launchMissiles True) >> return x
14:24:50 <Denommus> happyfeet: return "wraps" a pure value into IO
14:24:50 <Cale> More precisely, it's *evaluation of expressions* which can't have additional side effects. Execution of IO actions may have arbitrary effects, and that's how we split things up.
14:24:52 <nathyong> I feel like there should be a better way to do this than with ++ and concat+zip
14:25:02 <Cale> KaneTW: huh?
14:25:05 <Denommus> happyfeet: (that's technically incorrect, but enough for you to solve your problem)
14:25:58 <monochrom> padre_angolano: the link I posted above has usable examples. it also begins with a link to GHC documentation, which also contains motivation and examples. you should read both.
14:26:11 <KaneTW> Cale: since you started listing "loop forever, throw an exception"
14:26:14 <padre_angolano> monochrom: thanks for the link
14:26:16 <Denommus> happyfeet: to be more precise, saying "return" wraps a pure value into IO is technically incorrect. Not my solution
14:26:29 <Cale> KaneTW: those two things are _|_
14:26:31 <KaneTW> yeah
14:27:07 <Cale> KaneTW: Basically, I was rephrasing the statement that if f :: a -> a, then f x is either x or _|_
14:27:40 <Cale> Nothing unsafePerformIO-ish here.
14:28:04 <nathyong> http://lpaste.net/146242 <- what I have at the moment
14:28:05 <KaneTW> ya all i wanted to add is that you can do more (bad w/r/t purity) things if you allow unsafePerformIO
14:28:17 <monochrom> you need a really stretchy slippery-cliff argument to justify leaping from bottom to unsafePerformIO
14:28:46 * hackagebot bytes 0.15.1 - Sharing code for serialization between binary and cereal  https://hackage.haskell.org/package/bytes-0.15.1 (EdwardKmett)
14:28:48 * hackagebot log-domain 0.10.3.1 - Log-domain arithmetic  https://hackage.haskell.org/package/log-domain-0.10.3.1 (EdwardKmett)
14:29:01 <Xeironis_> It seems to me as though throwing an error isn't really pure, while looping forever is
14:29:06 <happyfeet> Denommus: i get this trying your solution http://lpaste.net/146243
14:29:14 <KaneTW> well they both make the type system unsound so i guess they're kind of related in my brain
14:29:19 <geekosaur> throwing the error is pure. *catching* it isn't
14:29:29 <Xeironis_> I see
14:29:31 <Xeironis_> sort of
14:29:34 <KaneTW> unsound as a logic that is
14:29:36 <monochrom> "since it's going to crash, it may as well take advantage of Cyber Monday offers and buy a new laptop online before it crashes"?
14:29:38 <Peaker> Does "cabal install record" send ghc into an infinite loop (at least when profiling for libs is enabled)?
14:29:48 <KaneTW> good idea
14:29:56 <padre_angolano> monochrom: from what I already read, it seems that without additional type constraints, 'forall a . T a' results in a completely useless type?
14:30:04 <monochrom> yes
14:30:27 <Denommus> happyfeet: tell me, if you have getLine (which gives you a IO String), and you want to pass its result into a function that takes String (let's say, (++"foo")), what do you do?
14:30:37 <padre_angolano> monochrom: so, it's possible to create them and impossible to use, and that's intended? funny :-)
14:30:54 <monochrom> more usable examples go like "forall a. T a (a -> a)" or "forall a. T a (a -> Int)" or "forall a. Useful_Typeclass_Here a => a" etc
14:30:55 <sm>   -- exi
14:31:02 <Peaker> "record" made quite a commotion back when it was released, so it is annoying that it is not actually installable!
14:31:11 <KaneTW> but yeah my argument is quite slippery slopey
14:31:24 <geekosaur> well, the intent is that you do something to be able to use it, namely constraints on a. but there *is* a use for that exact construct; see the ST monad
14:31:34 <KaneTW> assuming bottom and id as the only possible definitions is reasonable
14:31:47 <geekosaur> where it gives you a type witness that nothing referring to that type can ever escape
14:32:01 <Denommus> happyfeet: do you know?
14:32:01 <geekosaur> (because it can't be given a type)
14:32:15 <monochrom> the intention is to specify a language construct such that useful things are allowed and the specification is simple.
14:32:22 <happyfeet> inp <- getLine ; putStrLn (inp ++ "foo")  
14:32:29 <happyfeet> Denommus ?
14:32:44 <sm> using wreq, I can set a timeout as in the example at http://hackage.haskell.org/package/wreq-0.4.0.0/docs/Network-Wreq.html#g:12 , but if I use a session (Network.Wreq.Session.getWith) the timeout is ignored - why is that ?
14:32:53 <padre_angolano> monochrom: I see, thanks
14:32:55 <Denommus> happyfeet: yes. Now, the function I sent you also produces a IO <something>
14:33:02 <monochrom> since the specification has to be simple (more precisely, uniform, orthogonal, straightforward, ... all nice things), it is not going to bother outlaw useless things.
14:33:06 <pikajude> DarwinElf: which problems did you have exactly? i notice i'm depending on tls-extra here, which is out of date
14:33:09 <Denommus> happyfeet: so, if you want to use its result in a function that takes <something>, what should you do?
14:33:46 * hackagebot wai-transformers 0.0.4 - Simple parameterization of Wai's Application type  https://hackage.haskell.org/package/wai-transformers-0.0.4 (athanclark)
14:34:04 <happyfeet> Denommus , no idea.. sry :/
14:34:23 <Denommus> happyfeet: how come you don't have idea, if you just did that with IO String?
14:34:39 <Xeironis_> <
14:34:41 <Xeironis_> whoops
14:34:43 <Xeironis_> sorry
14:35:08 <happyfeet> Denommus: putStrLn a ? :/
14:36:03 <Denommus> happyfeet: the point is not the putStrLn :P
14:36:26 <Denommus> happyfeet: the point is that, by doing "foo <- bar", you take the result of an IO action into a variable that isn't IO
14:36:43 <Denommus> happyfeet: like: x <- getLine -- now x is a String
14:37:59 <happyfeet> Denommus: m <- mapa; return m ??? sry I am new to haskell xb
14:38:42 <Denommus> happyfeet: yes, that's an example, although "x <- foo; return x" is exactly the same thing as "foo"
14:38:59 <Denommus> happyfeet: nevertheless, you're starting to get the idea
14:39:07 * hackagebot approximate 0.2.2.3 - Approximate discrete values and numbers  https://hackage.haskell.org/package/approximate-0.2.2.3 (EdwardKmett)
14:39:09 <happyfeet> so how do I do it?
14:40:02 <Denommus> happyfeet: I don't know what you're doing, you didn't show any code at all. But instead of using your function directly, you extract the result from it
14:44:07 * hackagebot hyperloglog 0.4.0.4 - An approximate streaming (constant space) unique object counter  https://hackage.haskell.org/package/hyperloglog-0.4.0.4 (EdwardKmett)
14:45:25 <happyfeet> Denommus basically i am doing a simple game
14:45:48 <happyfeet> and I am restringe in the type of that function that has to be ":: Event -> Mapa -> Mapa"
14:45:59 <happyfeet> in order for it to work correctly
14:46:16 <dpwright> is anybody particularly knowledgeable about spock / wai middleware here?  Or is there a channel I'd be better to head to?
14:47:38 <dpwright> I'm trying to set up some routes based on the hostname and struggling... vhosts from wai-extras looks like exactly what I need, except that it works with a list of Applications and Spock returns an (IO Application), and I'm really not sure if it's valid to run all those (IO Application)s and then pass the results all into vhosts....
14:48:08 <learn_haskell> why list [1, [2]] gives error
14:48:22 <happyfeet> learn_haskell
14:48:35 <happyfeet> all elements in the list must be in the same type
14:48:38 <monochrom> because it doesn't make up its mind what its type is
14:49:02 <happyfeet> if you want to have 2 types you can do this: (1,[2])
14:49:06 <DarwinElf> pikajude, well when I do 'cabal-install' followed by the dependencies, then something says they're still all not there... like some older version of them is needed
14:49:14 <happyfeet> which is a tuple not a list
14:49:28 <DarwinElf> someone said remove 'tls-extra' because it's in tls. I did that, still had problems with the rest
14:49:51 <pikajude> oh, ok
14:50:02 <pikajude> brb
14:50:37 <Clint> pikajude: it needs to be updated for the String->Text change in damnpacket and then some tlsctx stuff
14:50:43 <pikajude> ok
14:52:40 <learn_haskell> haskell uses pattern matching which is just like prolog right ? or is there any difference ?
14:53:36 <Xeironis_> prolog has unification, haskell doesn't
14:54:06 <Xeironis_> so if you have the same variable name in a pattern twice, haskell won't unify them
14:54:23 <Xeironis_> instead you'll get an error
14:54:37 * hackagebot happstack-authenticate 2.3.1 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.3.1 (JeremyShaw)
14:59:37 * hackagebot happstack-hsp 7.3.7 - Support for using HSP templates in Happstack  https://hackage.haskell.org/package/happstack-hsp-7.3.7 (JeremyShaw)
14:59:49 <Arahael> What's "unification"?
15:00:27 <Arahael> Is that an implicit guard where the pattern match variables with the same name are required to be the same value? (Rather than an error as it would be in Haskell?)
15:00:29 <Xeironis_> Arahael: checking whether two terms are equivalent
15:00:58 <Xeironis_> unification is for much more than just the same variable name in patterns
15:01:13 <Arahael> So, same variable name must be just one trivial case?
15:01:24 <Xeironis_> yes
15:01:30 <Arahael> That's pretty cool.
15:01:44 <Xeironis_> it's essentially what prolog is based on
15:01:57 <Arahael> I really should give that a look - once I've learnt Haskell.
15:02:17 <Arahael> Another language I'm interested in, is forth.
15:03:54 <Xeironis_> I've looked at that a little bit
15:14:00 <Arahael> Xeironis_: It's simplicity is intruging - what I find fascinating, is how by restricting an API, you can get more versatility out of it.
15:17:00 <Xeironis_> that certainly sounds counter intuitive
15:19:41 * hackagebot happstack-foundation 0.5.9 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  https://hackage.haskell.org/package/happstack-foundation-0.5.9 (JeremyShaw)
15:29:46 * hackagebot happstack-jmacro 7.0.11 - Support for using JMacro with Happstack  https://hackage.haskell.org/package/happstack-jmacro-7.0.11 (JeremyShaw)
15:34:46 * hackagebot pinboard 0.9.2 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.2 (jonschoning)
15:39:46 * hackagebot list-zip-def 0.1.0.1 - Provides zips where the combining doesn't stop premature, but instead uses default values.  https://hackage.haskell.org/package/list-zip-def-0.1.0.1 (muesli4)
15:44:09 <dpwright> follow-up in case anybody stumbles across the log having a similar problem to mine, `vhostA hs def = vhost <$> sequenceA (map sequenceA hs) <*> def` defines an applicative version of `vhost` from wai-extra which you can use to switch between spock apps based on hostname
15:49:46 * hackagebot happstack-clientsession 7.3.1 - client-side session data  https://hackage.haskell.org/package/happstack-clientsession-7.3.1 (JeremyShaw)
15:54:48 <learn_haskell> other than pattern matching
15:55:01 <learn_haskell> what is other difference we can figure out about haskell and prolog
15:57:06 <Cale> learn_haskell: Pretty much... everything?
15:57:18 <Cale> Haskell and Prolog are not very similar
15:58:11 <learn_haskell> so all we have difference about pattern matching in haskell and prolog is about only unification ?
15:58:15 <hodapp> Errr, other than pattern matching, and Haskell's type system solving similar problems to Prolog when fundeps are involved... what other *similarities* can you find between them?
15:59:01 <cite-reader> Turing completeness!
15:59:23 <Xeironis_> the implementation of certain relations in prolog is often very similar to the equivalent functions in haskell (like map or reverse for example)
15:59:24 <jle`> there is almost nothing similar between haskell and prolog heh.  people usually edit both using text editors? :)
15:59:43 <Xeironis_> but they are still relations and not functions
16:03:09 <Cale> Type class hackery in Haskell is a fair amount like writing Prolog.
16:03:30 <Cale> ah, yeah, hodapp mentioned that
16:32:20 <Ankhers> I'm trying to use csv-conduit to parse my CSV file into a list of my custom type A. For some reason I cannot figure it out. I have written an instance of FromNamedRecord for my type A, but am unsure how to actually do the conversion. Has anyone used the library that would be able to help me out?
16:39:48 * hackagebot clckwrks-cli 0.2.16 - a command-line interface for adminstrating some aspects of clckwrks  https://hackage.haskell.org/package/clckwrks-cli-0.2.16 (JeremyShaw)
17:04:02 <pavolzetor> hi, should I report a bug if GHC gives one page error for just having accumulator and value swapped in foldr?
17:06:29 <MarcelineVQ> what's the error and the code causing it
17:13:14 <BBuf_M> цц
17:13:21 <kgadek> I'm here just to thank whole team from FP Complete (no sarcasm, I'm really thankful) for fixing this braindamage that is called cabal-install & hackage… Not only I'm de facto forced to use stackage to do any work. Yesterday a project built successfully (I'm using LTS), today it did not. Fuck, I'm provisioning clean system EVERY TIME so no, there is no "something changed in the system". Frankly, I do not want to waste any more time on
17:13:21 <kgadek>  this shit. Recently, all my fixes look like "ok, use stack/stackage". And it works, today it was "enable the mirror from FPCo". I do *NOT* want nor have time to wonder which package broke today and why. Blind "use stackage" works. FFS… </rant> If anyone wants to follow, I was building `stack` from tag v0.1.8.0 @ LTS-3.15 on FreeBSD.
17:20:49 <et8> anyone good with Rasterific? wondering why my code is sooo slowww
17:30:52 <echo-area> Hi.  I see in haskell2010 that function type has kind * -> * -> *.  When I tried this definition: let id' :: forall (a :: *). a -> a; id' x = x, it could be used on e.g. (+).  Does this mean `*` ~ `* -> * -> *` for the invocation?
17:30:59 <dealpete> :t coerce
17:31:01 <lambdabot> (Functor f, Contravariant f) => f a -> f b
17:33:09 <geekosaur> echo-area, "a" there can unify with any type
17:33:20 <hpc> :t (+)
17:33:21 <lambdabot> Num a => a -> a -> a
17:33:25 <hpc> :k Num a => a -> a -> a
17:33:26 <lambdabot> *
17:33:30 <hpc> there's your answer
17:33:36 <hpc> (->) is being given arguments
17:33:38 <hpc> specifically, a
17:34:36 <echo-area> hpc: Oh, you mean (->) has kind * -> * -> *, but rather a concrete function type
17:34:50 <hpc> (->) :: * -> * -> *
17:34:57 <hpc> but forall a. (a -> a) :: *
17:35:11 <hpc> it's a whole thing
17:35:24 <echo-area> I see.  Thank you
17:35:35 <hpc> it's too late in the day for me to explain why forall works that way, but there's probably good resources somewhere
17:35:55 <hpc> id have to think about it to remember and i am fresh out of brainpower ;)
18:06:04 <pavolzetor> ((*2) <> (*3)) 10 :: Sum Int
18:06:09 <pavolzetor> how does this work?
18:09:18 <pavolzetor> especially how is it possible to supply only one argument
18:23:44 <Ankhers> :t ((*2) <> (*3))
18:23:45 <lambdabot> (Num a, Monoid a) => a -> a
18:24:13 <Ankhers> :t (<>)
18:24:14 <lambdabot> Monoid m => m -> m -> m
18:27:23 <Jinxit> if I want a DSL (compile-time is fine) inside haskell which can call native haskell functions, is template haskell the best option?
18:27:31 <solirc> Sonarpulse: https://github.com/sol/doctest#using-ghc-extensions
18:28:21 <dmj> Jinxit: could use a free monad too
18:28:51 <Jinxit> oh perfect, that's my next question
18:28:55 <Jinxit> what makes free monads cool?
18:29:12 <Jinxit> I've just been vaguely hearing people talk about them
18:29:24 <c_wraith> Jinxit: if you want to be able to call haskell functions, an embedded DSL is the best bet. And free Monad are an easy way to build them. 
18:29:35 <Jinxit> I like easy
18:30:04 <Jinxit> can I write my DSL in a separate file or does it go together with my haskell code?
18:30:40 <dmj> Jinxit: it goes together with your haskell code, it is haskell code as well
18:30:43 <c_wraith> Jinxit: with an embedded DSL, it's all haskell code, arranged however you like. 
18:31:17 <Jinxit> okay
18:32:06 <dmj> Jinxit: here's a good article on them: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
18:32:14 <Jinxit> thanks, I'll go read up
18:33:53 <c_wraith> Jinxit: a slightly different interface to the same ideas is provided by operational, as described at http://apfelmus.nfshost.com/articles/operational-monad.html 
18:37:37 <Jinxit> c_wraith: this still is haskell though - preferably I'd be able to use some other syntax
18:37:48 <Jinxit> I'd want to*
18:38:06 <Jinxit> unless I'm misunderstanding something
18:38:38 <zachk> :q
18:38:43 <zachk> oops :D good night
18:38:55 <c_wraith> It is still haskell.  That's the easiest way to integrate with other haskell code. :) 
18:40:06 <Jinxit> hmm
18:40:07 <c_wraith> If you want some other syntax, you're headed in the direction of building your own full parser,whether you embed it with quasi quotes or put it in external files. 
18:40:22 <dmj> Jinxit: you might be thinking of a quasi-quoting DSL. Where you specify a String value (be it json / yaml / etc.) and it generates haskell. This too is a DSL
18:40:55 <echo-area> Is WordX guaranteed to be size of X?
18:41:10 <Jinxit> my specific target is behaviour trees, so basically I want to describe trees that call haskell functions
18:41:26 <echo-area> (X bits, that is)
18:42:22 <Jinxit> quasi quotes == template haskell?
18:46:01 <dmj> yea, but it takes a string
18:46:11 <dmj> http://quasimal.com/posts/2012-05-25-quasitext-and-quasiquoting.html
18:46:21 <ReinH> bitemyapp: ping
18:46:53 <njksdf> Reading a book on type theory, it says 'in simply-typed lambda calculus there is no self-application', but this seems false because you can do something like (id id), what am I missing?
18:46:57 <njksdf> :t id id
18:46:58 <lambdabot> a -> a
18:48:58 <dmwit> njksdf: You can't do `id id`.
18:49:20 <dmwit> njksdf: You can do `(\x -> x) (\x -> x)`, but you cannot do `let id = \x -> x in id id`.
18:49:57 <dmwit> njksdf: (`a -> a` is not a simple type)
18:50:12 <njksdf> Huh?
18:50:34 <dolio> It's only a simple type schema.
18:50:59 <njksdf> You mean, because the 'a' are placeholders not actual types?
18:51:02 <dmwit> njksdf: The type of `\x -> x` in STLC is not `a -> a`. It can be given types like `Int -> Int` or `(Int -> Int) -> Int -> Int` -- but only one at a time.
18:51:29 <dmwit> njksdf: Pretty much, yes, though the technical term for placeholder in this case is type variable. =)
18:51:35 <dolio> That's what I'm saying.
18:51:40 <njksdf> ah okay
18:51:57 <njksdf> so 'a -> a' is not a type even though it can represent a specific function?
18:51:57 <dolio> Importantly it's a metavariable.
18:52:30 <njksdf> '\x -> x' would have a class of types?
18:52:35 <dmwit> njksdf: `a -> a` is a type in Haskell, but it is not a *simple* type in the sense of simply-typed lambda calculus.
18:52:45 <dmwit> njksdf: `\x -> x` can be given many types, yes.
18:53:07 <njksdf> Ah, okay. I see, thanks.
18:53:08 <dmwit> njksdf: I'm not sure what "it [`a -> a`] can represent a specific function" means, so I don't know how to answer that part of your question.
18:53:25 <dmwit> njksdf: In general, typing relations are *relations* -- many-to-many.
18:53:30 <njksdf> dmwit: because '\x -> x' is a function right?
18:53:34 <njksdf> you dont even need to type it
18:53:41 <njksdf> but it has 'some' type
18:54:25 <dmwit> You don't need to type it?
18:54:28 <njksdf> Or I guess it doesn't have a type until its used
18:54:30 <dmwit> What does that mean?
18:54:54 <njksdf> dmwit: well you can represent the id function without instantiating 'a' to any type
18:54:59 <dmwit> I don't think "it doesn't have a type until it's used" is a useful way to think of this.
18:55:16 <dmwit> Typing is a relation -- in general, many-to-many -- between terms and types.
18:55:26 <dmwit> Well, between typing environments, terms, and types.
18:55:53 <njksdf> A term can have multiple types?
18:55:57 <dmwit> njksdf: In STLC, you cannot give `\x -> x` the type `a -> a`.
18:56:02 <dmwit> njksdf: Yes, definitely.
18:56:26 <njksdf> dmwit: is the 'term can have multiple types' a part of simply-typed lc?
18:56:29 <dmwit> njksdf: `a -> a` is just not a member of the type language of STLC. It's *not a type* in the sense of STLC system.
18:56:40 <dmwit> njksdf: Absolutely.
18:57:05 <njksdf> What about the 'Uniqueness of Types Lemma'
18:57:14 <dmwit> njksdf: `\x -> x :: Int -> Int` and `\x -> x :: Bool -> Bool` are both provable typing judgments in STLC (using an empty typing environment).
18:58:00 <dmwit> Ah, well, it depends on your STLC, I guess. Probably in your system `\x -> x` isn't even a term (but rather `\(x :: Int) -> x` or something similar).
18:58:30 <dmwit> (There are many ways to present STLC.)
18:59:05 <njksdf> ah okay, I guess I should just read on lol
18:59:15 <dmwit> But yes, in general, if your system has unique types, that is a deep fact that must be proved -- not something inherent in the "typing" notation.
18:59:50 <njksdf> I think it was proved somewhere above, but I dont care enough to check lol
19:00:04 <dmwit> e.g. in Haskell the deep fact is about most general types rather than unique ones.
19:00:15 <dmwit> And if you throw in GADTs, you even lose that. =)
19:00:33 <njksdf> I think that may be because Haskell has a more sophisticated system than STLC
19:00:38 <dmwit> Yes, definitely.
19:01:57 <dmwit> Anyway, my point is that the default is that a term can have many types.
19:02:18 <njksdf> Oh yeah that makes sense
19:02:33 <dmwit> If your system does not behave that way, it's an interesting fact that requires careful proof; you don't start from "one term, one type", you arrive there.
19:03:28 <njksdf> dmwit: ah the 'Uniqueness of Types' lemma says that a term can only have one type in the same context
19:04:18 <dmwit> I bet if you look at the syntax of terms, you'll see several places where things are annotated with their type, to preserve this property.
19:04:25 <dmwit> e.g. in the syntax of lambdas.
19:05:13 <njksdf> dmwit: yeah, but all of the STLC examples in this book are annotated with types
19:05:16 * roconnor wonders if he should pull out his agda implementation of the STLC.
19:05:51 <njksdf> I think the 'same context clause' makes sense
19:06:26 <njksdf> > id 1
19:06:28 <lambdabot>  1
19:06:40 <dmwit> Well, read on. You can grok the subtleties of Church-style and Curry-style LCs later. =)
19:06:57 <njksdf> > (let id = (\x -> x) (\x -> x) in id id 1)
19:06:58 <lambdabot>  1
19:07:10 <njksdf> okay :)
19:07:24 <rkaippully> Is there a way to do meta-programming other than TemplateHaskell?
19:07:42 <dmwit> rkaippully: Sure. But you're not going to like it...
19:07:58 <njksdf> rkaippully: generate haskell code and then compile it lol
19:07:59 <roconnor> dmwit: doest in involve CPP and make files?
19:08:04 <rkaippully> :)
19:08:14 <dmwit> roconnor: If you want!
19:08:18 <rkaippully> Hmm.. that's what I thought
19:08:19 <njksdf> or generate haskell code using a program and then insert it into your code
19:09:09 <rkaippully> I am trying to get all the field names and their types of a record (or an ADT in general)
19:09:15 <njksdf> I wonder if the need for metaprogramming shows a lack of something in a language?
19:09:30 <dmwit> rkaippully: You might like Generic or the various Scrap-Your-Boilerplate knockoffs.
19:09:56 * hackagebot wai-middleware-content-type 0.1.0.1 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.1.0.1 (athanclark)
19:10:10 <Arahael> imho, such approaches result in your functions expecting too much data.
19:10:15 <dmwit> As I recall the paper about Generic was quite readable.
19:10:23 <geekosaur> njksdf, I'm not sure it does, except in some Gödelian sense
19:10:29 <Arahael> If a type contains x, y, and z, but the function only needs 'y' to work, why does it need x and z?
19:10:51 <rkaippully> Generics give me the structure based on a value, but I need it from a type.
19:11:23 <rkaippully> So if a type has multiple data constructors, I need to map through all of them.
19:11:44 <geekosaur> Typeable?\
19:12:10 <dmwit> uh
19:12:16 <dmwit> Are you sure Generics do not give you that?
19:12:46 <rkaippully> geekosaur: May be. I have just started looking into Typeable. 
19:13:01 <dmwit> I don't think Typeable really gives you the right thing.
19:13:05 <geekosaur> actually I think Data.Data gives you some better access
19:13:25 <dmj> rkaippully: multiple data constructors could mean sums or products so (:*:) or (:+:)
19:13:55 <geekosaur> which is indeed generics
19:14:08 <geekosaur> there's more than one way to use them...
19:14:47 <dmwit> rkaippully: Rep gives you the mapping from a Generic to a standardized (and small) set of type constructors.
19:14:57 <dmwit> ...for sums, products, etc.
19:15:04 <rkaippully> Here is what I mean
19:15:07 <rkaippully> let r = from (undefined :: Either a b)
19:15:30 <rkaippully> unM1 r gives *** Exception: Prelude.undefined
19:16:07 <rkaippully> So I will not be able to look at constructors without constructing a value of type Either
19:16:38 <rkaippully> And if I use "Left" or "Right", I will get only that constructor from Generics.
19:16:44 <dmwit> I do not believe your "I will not be able to ..." follows from the evidence presented before that claim.
19:18:06 <rkaippully> Ok, can you show me an example to get both the constructors from an undefined value, I have been breaking my head for a couple of hours now.
19:18:17 <rkaippully> May be I am missing something simple.
19:18:38 <dmj> rkaippully: Can you show us more code, and tell us more about what you're trying to do, is Either a b. I don't think you have to use undefined. The generic instance for Arbitrary doesn't have to 
19:18:51 <dmj> is Either a b, the type you're trying to provide a generic implementation for?
19:18:53 <dmj> *
19:20:02 <rkaippully> Here is what I am trying to do. Let us say I have a type - say Either String Int.
19:20:34 <rkaippully> I want to print all it's constructors and their argument types.
19:21:08 <rkaippully> So for example, a list such as [["Left", "String"], ["Right", "Int"]]
19:22:17 <geekosaur> > Data.Typeable.typeOf (undefined :: Either String Int)
19:22:18 <lambdabot>  Either [Char] Int
19:22:27 <geekosaur> although no constructors there, I think you can get those
19:22:43 <glguy> We could do it with GHC.Generics
19:22:58 <dmj> rkaippully: you'll need an inhabitant, at least for GHC.Generics (AFAIK), since GHC.Generics.selName is used on M1, and S1 is a typedef for it
19:23:10 <dmj> glguy: tell us more =) 
19:23:58 <dmj> glguy: wouldn't selName require an M1 value?
19:24:01 <geekosaur> hm, no, thisdoesn't give data constrs
19:24:40 * geekosaur would find this easier if his local notwork weren't bouncing around like a bungee diver
19:25:02 <dmj> 'notwork' ha :) 
19:25:25 <rkaippully> I think lenses solves a similar problem using TH.
19:25:44 * dmj thinks glguy is writing a simple example
19:26:11 <dmwit> I'm trying, too, though glguy has much more experience with Generic.
19:26:17 <geekosaur> > Data.Data.dataTypeOf (undefined :: Either String Int)
19:26:19 <lambdabot>  DataType {tycon = "Prelude.Either", datarep = AlgRep [Left,Right]}
19:28:32 <dmj> dmwit, rkaippully: one 'hack' is to put a constraint on Arbitrary
19:29:13 <dmj> fmap to <$> from =<< (generate arbitrary :: IO MyType)
19:29:45 <dmwit> Using `Arbitrary` for this is the kind of thing I would classify as a wat.
19:30:32 <dmj> dmwit: if it's not a sum type sure, if it's generic serialization and you arbitrarily create a deserializer from a sum that could be problematic
19:30:57 <dmwit> Who said anything about serialization or deserialization?
19:31:09 <dmwit> And why would those need `Arbitrary` anyway?
19:31:19 <dmj> no one, it's just an example of how that could go wrong
19:31:29 <dmj> dmwit: because selName needs to be applied to an M1
19:31:34 <glguy> I'd do an example but there's competition for my attention at home. I can do one later if no one else does. It's probably not going to beat geekosaur's syb line
19:32:11 <dmj> glguy: before you go :) how could we use selName w/o a value here?
19:32:30 <glguy> proxy argument
19:32:34 <rkaippully> Thanks folks, I think I need to explore Data.Data more
19:32:37 <dmwit> That question smells like an X/Y problem.
19:32:41 * dmj vies for glguy's attention
19:34:03 <geekosaur> see also dataTypeConstrs and constrType to take that DataType value apart and get internal types
19:34:31 <geekosaur> basically it's all there, it's the machinery that makes what you think of as the normal generics machinery work
19:42:08 <dealpete> @pl \x -> x
19:42:08 <lambdabot> id
19:42:12 <dealpete> @pl \x -> x + 1
19:42:12 <lambdabot> (1 +)
19:42:35 <dealpete> @pl \x y -> (x * y) `mod` 100
19:42:35 <lambdabot> flip flip 100 . (mod .) . (*)
19:43:16 <lpaste> dmwit pasted “No title” at http://lpaste.net/146259
19:43:37 <dmwit> rkaippully: My clunky proof-of-concept to show you can get the types needed for each constructor.
19:46:55 <Xeironis_> how interesting that @pl knows about the commutativity of (+)
19:47:21 <Xeironis_> seems like a useless thing to include
19:48:33 <Xeironis_> although, nevermind, I suppose it's relatively easy to come up with terms that can be made shorter that way
19:54:17 <ReinH> bitemyapp: how the hell do you build reflex-dom?
19:56:59 <dmj> dmwit: nice, but can you do it with selName? 
20:05:01 * hackagebot webapp 0.0.1 - Haskell web scaffolding using Scotty, WAI, and Warp  https://hackage.haskell.org/package/webapp-0.0.1 (natesymer)
20:05:55 <lpaste> glguy annotated “No title” with “No title (annotation)” at http://lpaste.net/146259#a146262
20:06:13 <glguy> that's a mess :)
20:06:26 <dmj> glguy: you couldn't resist
20:06:51 <bitemyapp> ReinH: magic!
20:06:59 <dmj> glguy: why not `selName` ?
20:07:05 <bitemyapp> ReinH: Do you use Stack?
20:07:31 <glguy_> What about selName?
20:07:44 <glguy_> I haven't been following chat if the problem changed
20:08:48 <glguy_> selName works exactly like conName
20:10:01 * hackagebot webapp 0.0.2 - Haskell web scaffolding using Scotty, WAI, and Warp  https://hackage.haskell.org/package/webapp-0.0.2 (natesymer)
20:15:04 <dmj> glguy_: ah I see
20:16:06 <dmj> selName $ M1 Proxy :: Selector s => Proxy (S1 s (K1 i a))
20:17:20 <dmj> of sorts
20:25:02 * hackagebot haskell-tor 0.1.2 - A Haskell Tor Node  https://hackage.haskell.org/package/haskell-tor-0.1.2 (AdamWick)
20:27:26 <Phagus> I need help installing xmonad on Archlinux
20:27:33 <Phagus> I'm getting a slew of errors like this: xmonad-0.11.1: Warning: haddock-interfaces: /usr/share/doc/x86_64-linux-ghc-7.10.2/xmonad-0.11.1/html/xmonad.haddock doesn't exist or isn't a file
20:27:42 <Phagus> Are these files not even being build by ghc?
20:27:55 <glguy_> That's not an error
20:28:49 <Phagus> What is it?
20:29:32 <geekosaur> it's a warning, as indicated by "Warning:"
20:29:47 <geekosaur> it is checking for generated documentation but you didn't enable documentation building
20:30:02 <geekosaur> (programmer documentation, not user docs)
20:33:28 <geekosaur> are you getting other messages than those? (Id' imagine not, since if it got that far then building/installing worked)
20:37:10 <Phagus> A lot of errors
20:37:42 <geekosaur> @paste full log
20:37:42 <lambdabot> Haskell pastebin: http://lpaste.net/
20:37:50 <geekosaur> don't paste directly into IRC
20:38:01 <Phagus> The install documentation isn't very clear...
20:40:39 <Phagus> Let me play around with it a bit more
20:55:03 * hackagebot opencog-atomspace 0.1.0.1 - Haskell Bindings for the AtomSpace.  https://hackage.haskell.org/package/opencog-atomspace-0.1.0.1 (romanT)
21:24:37 <tippenein> Warning: haddock-interfaces: $HOME/.stack/snapshots/x86_64-osx/lts-3.2/7.10.2/doc/blaze-markup-0.7.0.2/blaze-markup.haddock doesn't exist or isn't a file
21:25:03 <tippenein> why is a haddock error halting my build?
21:26:19 <tippenein> woah, same question. apologies
21:35:05 * hackagebot dejafu 0.2.0.0 - Overloadable primitives for testable, potentially non-deterministic, concurrency.  https://hackage.haskell.org/package/dejafu-0.2.0.0 (barrucadu)
21:35:07 * hackagebot hunit-dejafu 0.2.0.0 - Deja Fu support for the HUnit test framework.  https://hackage.haskell.org/package/hunit-dejafu-0.2.0.0 (barrucadu)
21:35:09 * hackagebot tasty-dejafu 0.2.0.0 - Deja Fu support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-dejafu-0.2.0.0 (barrucadu)
21:38:20 <phyl729> given a base b and integer n, represent n in base b and then negate and subtract one from the exponents on b in the representation. e.g for base=3  14 => 1*3^2 + 1*3^1 + 2*3^0  =>  1*3^(-3) + 1*3^(-2) + 2*3^(-1) = 22/27   I feel like there's an elegant way to express that, but don't know how.
21:41:18 <pavonia> phyl729: Do you mean express this as a data type?
21:43:08 <phyl729> I think I only need the resulting number, but what do you mean express as a data type?
21:43:39 <pavonia> I'm just not sure what you're asking for
21:44:25 <phyl729> a function that takes b and n and spits out the number I described
21:45:05 * hackagebot async-dejafu 0.1.0.0 - Run MonadConc operations asynchronously and wait for their results.  https://hackage.haskell.org/package/async-dejafu-0.1.0.0 (barrucadu)
21:47:35 <pavonia> Take the remainder to base b, divide by b, and do that until only zero is left to get a list of factors with their exponents. Then you can simply transform the exponentens as explained, and fold the list back into a number
21:50:13 <phyl729> I was hoping for something like iterate/until but with a type of (a->(a,b)) -> a -> [b]
21:50:38 <pavonia> :t unfold
21:50:40 <lambdabot>     Not in scope: ‘unfold’
21:50:40 <lambdabot>     Perhaps you meant one of these:
21:50:40 <lambdabot>       ‘BS.unfoldr’ (imported from Data.ByteString),
21:51:08 <pavonia> :t unfoldr
21:51:09 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
21:51:25 <phyl729> perfect
21:51:40 <phyl729> thanks pavonia 
21:51:46 <pavonia> No problem
22:22:02 <narff> please help me understand this functor: fmap (* 2) (+ 5) 2 
22:24:33 <liste> narff that expression is using the Functor instance of (->) a
22:24:46 <liste> which is just composition
22:29:21 <narff> liste, thanks, I forgot about instance Functor ((->) r)
22:31:03 <liste> narff yw (:
22:32:33 <quater-nyan> Can the free applicative be defined using the trick from the “Reflection without Remorse” paper?
23:30:09 * hackagebot pgdl 8.4 - simply download a video (or a file) from a webpage and xdg-open it.  https://hackage.haskell.org/package/pgdl-8.4 (sifmelcara)
23:45:02 <lol__> hello?
23:45:12 <pacak> lol__: o/
23:45:45 <lol__> Starting to learn Haskell with Learn You A Haskell
23:46:25 <pacak> That's a nice book for beginners, but might be a tiny bit outdated.
23:46:37 <lol__> What do you suggest?
23:47:09 <pacak> https://github.com/bitemyapp/learnhaskell - I think this one is something current.
23:47:19 <frerich> lol__: Any book is going to be outdated quickly, Haskell moves quite fast. So I wouldn't worry too much.
23:47:21 <pacak> But feel free to stick with LYAH and ask questions here.
23:48:02 <liste> I learned from Real World Haskell and that's even more outdated (I think?)
23:48:10 <lol__> Alright, awesome. Thanks!
23:48:42 <frerich> liste: So did I, yeah - and even if you keep the outdated stuff out, there's still a ton of useful things to learn. :-)
23:48:45 <pacak> liste: It's even more outdated now.
23:49:25 <lol__> Huh, I thought Haskell would be like be similar to Racket in terms of syntax. Like (+ 1 2) as opposed to 1 + 2
23:50:10 <pacak> > (+) 1 2
23:50:12 <lambdabot>  3
23:50:26 <pacak> It can if you want it to be.
23:50:27 <frerich> lol__: Functions which don't start with a letter (e.g. '+') are infix by default, i.e. you can write either '1 + 2' or '(+) 1 2'. You can make an 'ordinary' function infix using backticks, i.e. 'f 1 2' and '1 `f` 2'
23:51:15 <pacak> > let (☭) = (+) in 1 ☭ 2
23:51:16 <lambdabot>  3
23:51:27 <lol__> huh... interesting 
23:51:51 <lol__> and what exactly is an infix
23:52:03 <liste> lol__ operator that's between its operands
23:52:17 <liste> prefix = before operands, postfix = after operands
23:53:10 <lol__> I see, makes sense.
23:53:15 <eklavya> would like to see a postfix language hehehehe
23:53:21 <liste> eklavya RPN calculators
23:53:22 <lol__> Is there any purpose to making an ordinary function infix?
23:53:34 <liste> lol__ sometimes readability
23:54:00 <eklavya> that would just mess with my mind :D
23:54:03 <pacak> > filter odd [1..10]
23:54:05 <lambdabot>  [1,3,5,7,9]
23:54:08 <pacak> > odd `filter` [1..10]
23:54:10 <lambdabot>  [1,3,5,7,9]
23:54:25 <lol__> First one seems easier to read
23:54:26 <liste> eklavya also I think Forth is postfix
23:54:34 <eklavya> !!
23:54:36 <lol__> map add1 [1...10]
23:54:53 <pacak> lol__: >
23:56:08 <zoku> > printf ":QUIT\r\n"
23:56:09 <lambdabot>      No instance for (Show a0)
23:56:09 <lambdabot>        arising from a use of ‘show_M97804762599643201827138’
23:56:09 <lambdabot>      The type variable ‘a0’ is ambiguous
23:56:12 <subjz> hey
23:56:46 <lol__> map (add 1) [1...10]
23:56:51 <zoku> > printf ":MSG #haskell YARR\r\n"
23:56:53 <lambdabot>      No instance for (Show a0)
23:56:53 <lambdabot>        arising from a use of ‘show_M160162403651765522327182’
23:56:53 <lambdabot>      The type variable ‘a0’ is ambiguous
23:56:57 <liste> lol__ you need > before the expression
23:57:06 <liste> also I don't think there's a function named `add'
23:57:23 <lol__> >map (add 1) [1...10]
23:57:23 <subjz> is there anyone who can tell me my Facebook name of profile name ( I'm not showing any challenge but I just want to find out how good you guys are
23:57:24 <zoku> > map (+1) [1...10]
23:57:26 <lambdabot>      Could not deduce (Num (Over p f c0 c0 a b))
23:57:26 <lambdabot>      from the context (Num (Over p f s t a b),
23:57:26 <lambdabot>                        Num (Over p f c c a b),
23:57:36 <subjz> 1,9is there anyone who can tell me my Facebook name of profile name ( I'm not showing any challenge but I just want to find out how good you guys are
23:57:39 <zoku> > map (1+) [1...10]
23:57:41 <lambdabot>      Could not deduce (Num (Over p f c0 c0 a b))
23:57:41 <lambdabot>      from the context (Num (Over p f s t a b),
23:57:41 <lambdabot>                        Num (Over p f c c a b),
23:57:57 <lol__> > map (add 1) [1...10]
23:57:58 <lambdabot>      Not in scope: ‘add’
23:57:58 <lambdabot>      Perhaps you meant one of these:
23:57:58 <lambdabot>        ‘and’ (imported from Data.List), ‘odd’ (imported from Prelude),
23:58:08 <frerich> subjz: This channel is about the Haskell programming language.
23:58:15 <zoku> > let add = (+)
23:58:17 <lambdabot>  <no location info>: not an expression: ‘let add = (+)’
23:58:22 <liste> zoku @let
23:58:32 <zoku> @let add = (+)
23:58:33 <lambdabot>  Defined.
23:58:37 <zoku> thanks liste 
23:58:41 <liste> yw (:
23:58:44 <zoku> try now lol__ 
23:59:01 <liste> though the Over stuff seems cryptic...
23:59:05 <subjz> ok sorry to disturb you guys... I had no idea about it 
23:59:11 <lol__> > map (add 1) [1..10]
23:59:12 <liste> is there some weird defaulting rules?
23:59:13 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
23:59:16 <lol__> yesss
23:59:24 <lol__> thanks guys
23:59:28 <zoku> lol__: that won't work ordinarily however
23:59:32 <zoku> since there is no "add" function
23:59:48 <zoku> > map ((+) 1) [1..10]
23:59:50 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
