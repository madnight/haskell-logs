00:06:01 <varaindemian> can someone tell me how do I turn a string ("Chris") into upper case string using list comprehension (without using ---map toUpper "Chris"----)?
00:06:40 <masse> [toUpper c | c <- "Chris"]
00:09:48 <Lokathor> varaindemian, that's operationally equivalent to using map though
00:10:20 <varaindemian> Lokathor: isn't there any other mode?
00:10:38 <jle`> i'm guessing that the restriction comes from a course/class/homework prompt?
00:10:44 <jle`> in which case, that's probably what they want, heh
00:10:59 <MasseR> Mode?
00:11:05 <Lokathor> well, "perform an operation on every element of the list" is a map even if you don't *call* it a map. yeah if it's a homework thing use what masse said
00:11:28 <jle`> yeah, it's a map without using the pre-defined function in Prelude called "map"
00:11:29 <jle`> heh
00:11:31 <varaindemian> it's not a homework thing
00:11:36 <varaindemian> I was just wondering
00:11:58 <jle`> you can do it using pattern matching explicitly
00:12:03 <jle`> on the list constructors
00:12:13 <Lokathor> yeah
00:12:15 <Lokathor> @src map
00:12:16 <lambdabot> map _ []     = []
00:12:16 <lambdabot> map f (x:xs) = f x : map f xs
00:12:34 <jle`> > let allUpper [] = []; allUpper (c:cs) = toUpper c : allUpper cs in allUpper "Chris"
00:12:36 <lambdabot>  "CHRIS"
00:12:56 <jle`> but yeah, that's still a "map"...just without using the pre-defined function called "map"
00:13:20 <jle`> both `map toUpper "Chris"` and `allUpper "Chris"` should compile to the same code, anyways
00:13:27 <jle`> er, the same program
00:15:22 <jle`> (this is basically inlining the definition of `map`)
00:23:49 <saulzar_> I finally thought I'd learn vim - so I installed haskell-vim-now and now try to type check my file and it gives me "syntastic: warning: checker ghc_mod is not available"  -  tried setting the debug flag g:syntastic_debug = 3, and it doesn't seem to give me anything enlightening.  ghc-mod is reporting 5.4 and ghc 7.10.2. Anyone have any ideas?
00:26:42 <Lokathor> if it can't find a thing, but you can find a thing, i think it's looking in the wrong place
00:26:51 <Lokathor> perhaps there's a way to set the PATH differently?
00:28:22 * hackagebot patches-vector 0.1.4.1 - Patches (diffs) on vectors: composable, mergeable, and invertible.  https://hackage.haskell.org/package/patches-vector-0.1.4.1 (LiamOConnorDavis)
00:28:23 * hackagebot dixi 0.6.0.1 - A wiki implemented with a firm theoretical foundation.  https://hackage.haskell.org/package/dixi-0.6.0.1 (LiamOConnorDavis)
00:28:41 <seanparsons> saulzar_: Are you using a graphical vim by any chance? I've definitely had issues with the PATH setting that gvim was using, because it wasn't seeing my bash profile.
00:28:57 <saulzar_> Lokathor, yeah. The stack script which comes with haskell-vim-now puts it in .local/bin so I put that in my path..
00:29:21 <saulzar_> seanparsons, Nope - using it in X but in the terminal..
00:29:49 <saulzar_> wonder if I can get it to tell me what the path it's using is
00:31:32 <varaindemian> thank you
00:34:48 <saulzar_> It even looks like there's something it's put in .vimrc to add that path .. let $PATH = $PATH . ':' . expand("~/.local/bin")
00:38:23 * hackagebot patches-vector 0.1.4.2 - Patches (diffs) on vectors: composable, mergeable, and invertible.  https://hackage.haskell.org/package/patches-vector-0.1.4.2 (LiamOConnorDavis)
00:46:32 <jle`> Path is a groupoid but has a Monoid instance
00:46:34 <jle`> how scary
00:46:56 <jle`> *Patch
00:47:26 <Lokathor> so if i have a small file of totally legal haskell code that can reliably crash GHC 7.8.4 on ARM
00:47:54 <Lokathor> who would i go about submitting that to as like... a bug report thing i guess
00:48:30 * hackagebot haskell-exp-parser 0.1.1 - Simple parser parser from Haskell to TemplateHaskell expressions  https://hackage.haskell.org/package/haskell-exp-parser-0.1.1 (EmilAxelsson)
00:49:00 <nitrix> Lokathor: https://ghc.haskell.org/trac/ghc
00:49:03 <Lokathor> https://github.com/Lokathor/cis194/blob/master/JoinList.hs   using Empty +++ Empty will crash it with an "Illegal Instruction" message
00:49:43 <nitrix> Lokathor: Fourth link, "Report a bug".
00:50:16 <Lokathor> i will... leave this in a tab for tomorrow i think
00:54:35 <nitrix> Lokathor: Can you try creating a datatype, deriving Eq and doing any comparison with == ?
00:54:54 <Lokathor> no problem
00:55:48 <Lokathor> works
00:55:57 <Lokathor> *JoinList> TestInt 3 == TestInt 5
00:55:57 <Lokathor> False
00:59:28 <MarcelineVQ> all these parens
00:59:51 <Lokathor> they don't need to be around (Empty) i guess, but whatever
00:59:59 <nitrix> Lokathor: This seems like it has been fixed on 7.11 from reading the tickets.
01:00:17 <nitrix> Don't quote me on that, but it's worth trying.
01:00:36 <Lokathor> oh good :/  now... to somehow compile that onto a raspberry pi
01:01:07 <Lokathor> compiling a compiler is always the worst thing to attempt
01:01:41 <Lokathor> nitrix, what ticket are you looking at?
01:03:38 <nitrix> Lokathor: I started from a similar issue https://ghc.haskell.org/trac/ghc/ticket/10375 and worked up to https://ghc.haskell.org/trac/ghc/ticket/10969 which seems to be the culprit of all sorts of things.
01:07:35 <Lokathor> hmm
01:07:37 <Lokathor> yes
01:08:05 <Lokathor> if i compile it (and give it some type annotations in the process), it works
01:08:16 <Lokathor> main = print $ ((Empty +++ Empty) :: JoinList [Int] Int)
01:08:18 <Lokathor> prints out Empty
01:08:31 * hackagebot tttool 1.5.0.1 - Working with files for the Tiptoi® pen  https://hackage.haskell.org/package/tttool-1.5.0.1 (JoachimBreitner)
01:10:07 <Lokathor> well, now... I still need to try and get ghc 7.10 somehow
01:13:30 <tdammers> Lokathor: which OS?
01:13:40 <Lokathor> raspbian
01:13:44 <Lokathor> which is basically debian
01:13:44 <tdammers> ah.
01:14:01 <Lokathor> i'm sure i can get it from debian armhf experiemental and figure it out
01:14:05 <tdammers> well, yes, except that it runs on the rpi's weird ARM architecture
01:14:26 <Lokathor> it's an rpi2 though, so normal debian armhf also works
01:14:31 <tdammers> ah, right
01:15:58 <grouph> Hi. I have a type which must only represents items from Zero to Ten. Is there something less boring than "data MyNumber = Zero | One | Two | Three | ..."
01:16:31 <tdammers> normally I'd recommend just installing the binary GHC distribution rather than debian packages, but I don't know if an armhf build exists
01:16:38 <Lokathor> grouph, you can make a newtype MyThing = MyThing Int   and then use a constructor that rejects out of bounds values
01:17:05 <Lokathor> tdammers, it seems it does, but i have to be sure i'm using llvm 3.5
01:17:08 <tdammers> there's this: https://www.haskell.org/ghc/download_ghc_7_10_2#linux_armv7
01:17:14 <Lokathor> yeah
01:17:25 <Lokathor> probably not a 2am sort of project to start tinkering with
01:17:26 <grouph> Lokathor: (by constructor, you mean, a function which builds MyThing ? I cannot directly overload the "MyThing" constructor ?)
01:17:31 <tdammers> haha no
01:17:57 <merijn> Well, technically you can! :p
01:18:06 <Lokathor> grouph, ah, yes, you'd have a function such as, mkThing a | a >= 0 && <= 10 = MyThing a
01:18:24 <tdammers> anyway, in my experience, having distro packages installed kind of locks you into that GHC version; having multiple GHC's installed side by side really only works well if you install somewhat manually
01:18:27 <Lokathor> and then you'd just use that function to build your values
01:18:47 <grouph> Lokathor: That's a solution, however how does I enforce "compiletime" checking of the values ?
01:18:52 <Cale> You don't.
01:18:57 <merijn> Cale: You do!
01:19:00 <merijn> Cale: https://hackage.haskell.org/package/validated-literals ;)
01:19:18 <Cale> Okay, you don't in ordinary practical programs written in Haskell.
01:19:27 <Cale> :)
01:19:31 <Lokathor> grouph, it would check each time you build a value, not just once at compile time
01:19:32 <tdammers> use TH!
01:19:36 <nitrix> Does arm has stack? Sounds like it'd be easy this way.
01:19:37 <Cale> You can sort of do it in a variety of ways
01:19:46 <grouph> merijn: thanks for the pointer ;) Lokathor: thank you too.
01:19:54 <Lokathor> nitrix, a blog post claims it can can be built
01:19:58 <Cale> But it's really something that you want a dependent type system for
01:20:11 <tdammers> seriously though, using template haskell to define a limited-range pseudo-integer enum type doesn't sound too wild to me
01:20:30 <Cale> and while Haskell is on good days able to fake a dependent type system, telling people to go down that road will likely lead them into painful situations
01:20:46 <Cale> (because we don't really have dependent types)
01:20:48 <Lokathor> grouph, https://github.com/Lokathor/sharecart1000-hs/blob/master/src/Data/Word10.hs i did a thing like this the other day
01:20:50 <merijn> grouph: Basically I had the same annoyance, where I had a wrapper that was "mkEven :: Int -> Maybe Even" (for example) and when I wrote "mkEven 2" I'd still have to deal with the Maybe case even though that obviously can't ever happen (and if it does, you should fix the source)
01:21:25 <merijn> grouph: The library I linked just has a typeclass plus some Template Haskell functions that will check and do the conversion at compile time (or check and redo the conversion at runtime if the efficient way isn't possible)
01:21:56 <merijn> grouph: If you find anything unclear in the docs, lemme know, I'm not sure how much details beginners need to use this
01:22:03 <frerich> Pascal had these nice 'subrange' types where you could say 'Type MyThing = 0..10;'.
01:22:16 <Cale> grouph: In a dependently typed language, you can have a type, depending on values x and y, whose values represent proofs that x < y
01:22:24 <merijn> frerich: The technical term for that is "refinement types" :)
01:22:25 <tdammers> Pascal had quite a few nice things that somehow got lost
01:22:41 <merijn> frerich: Liquid Haskell can do things like that
01:22:43 <frerich> merijn: Ah, interesting, thanks! :-)
01:22:54 <grouph> merijn: from what I have read, it is clear ;) (But I don't really understand what is a beginner in Haskell, I had no problem at all with Monad but I'm still stuck at creating a correct parser with Parsec, so perhaps I'm a weird beginner ;)
01:22:55 <Cale> grouph: and you can do things like pair up a value with a proof that it is less than 10
01:23:22 <tdammers> grouph: Monads are way simpler than a Parsec parser
01:23:25 <teeth> Cale: I've never used a dependently typed language. That sounds nice.
01:23:43 <merijn> teeth: Coq, Agda and Idris are the places to look
01:23:44 <tdammers> grouph: the main reason why people have such trouble with monads is basically prejudice
01:24:02 <grouph> Cale: that's looks nice, actually I was suprrised that Haskell does not work like that ;(
01:24:17 <merijn> teeth: Idris is the most "practical" one in that it's aimed at being a programming language and the target audience of the writers is "haskell programmers", Coq and Agda are more traditional theorem provers
01:24:22 <Cale> grouph: Haskell only has types which depend on other types
01:24:27 <Lokathor> the quesiton becomes, will ARM stack pull in the right GHC when it does the setup?
01:24:28 <Lokathor> hmm
01:24:49 <Cale> grouph: For example you can have a binary tree datatype which depends on the type of elements stored in the branch nodes.
01:25:12 <merijn> teeth: See also, the excellent (free) Software Foundations book on proving program properties in Coq
01:25:32 <teeth> merijn: Thanks! Will do
01:25:45 <Cale> grouph: But having types which depend on values is much more subtle. As soon as you have types depending on values, you end up wanting to do computation at the type level.
01:26:09 <merijn> @where sf
01:26:09 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,SjÃ¶berg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
01:26:09 <lambdabot> assistant."
01:26:12 <merijn> teeth: That one
01:26:14 <nitrix> Hi, is there an alternative to pattern matching? Say a functional language couldn't go that route, what options are left?
01:26:26 <tdammers> nitrix: conditionals?
01:26:34 <Cale> grouph: If you have, say, a type of lists of length n, then you'll want an append operation which takes a list of length n, and a list of length m, and produces a list of length n + m
01:26:39 <Lokathor> nitrix, insanity
01:26:52 <tdammers> nitrix: you'd have to make equality comparison more magical though
01:26:53 <nitrix> tdammers: You're thinking automatically generated helper functions like isTypeA ?
01:27:06 <Cale> grouph: and then as part of getting the definition of that to type check, you'll probably need to know that for any n, you have n + 0 = n
01:27:11 <tdammers> nitrix: depends what you want to match on
01:27:11 <Lokathor> nitrix, for a functional language without pattern matching, look to Scheme or other Lisp variant
01:27:23 <Cale> grouph: which might require an inductive proof
01:27:32 <tdammers> Lokathor: I think calling Lisp a "functional" programming language is a bit of a stretch
01:27:54 <Cale> or, well, if you write the append the right way around, you might avoid that problem
01:28:04 <tdammers> Lokathor: it's possible to make a Lisp that is functional, but none of the real-world Lisps I've seen deserve the name
01:28:14 <Cale> But the precise way that + was defined will matter
01:28:22 <tdammers> (not any more than, say, JavaScript, anyway)
01:28:28 <teeth> So if I were to write a function that takes the arguments x and y, and I wanted to check at compile time that y < x what would be the easiest way to do that?
01:28:44 <Cale> So it introduces a lot of trickiness, at the same time as a great deal of expressiveness.
01:28:45 <Lokathor> tdammers, you can go two thirds of a Scheme book before apologizing profusely for an entire page and saying "now we'll introduce this dsetructive assignment operator, and i'm sorry again"
01:28:47 <merijn> teeth: Template Haskell and/or Liquid Haskell
01:28:50 <nitrix> tdammers: Mind if I present the problem to you? I'm fiddling with a forth/joy/cat toy concatenative language.
01:28:58 <frerich> grouph: I once wrote a silly little TH exercise which lets you define 'smart constructors' very easily (easily enough for me to actually do it...): http://hackage.haskell.org/package/smartconstructor
01:29:03 <Cale> teeth: In a dependently typed language?
01:29:15 <grouph> frerich: thank you ;)
01:29:27 <frerich> grouph: That lets you write 'newtype MyThing = MyThing Int;' and then 'makeSmartCtor defaultOptions ''Mything [|(`elem` [0..10])|]"
01:29:27 <teeth> merijn: I've heard of Liquid Haskell but I haven't heard of Template Haskell
01:29:34 <teeth> And I haven't looked into either
01:29:57 <tdammers> Lokathor: the thing is, Lisps tend to not have functions, only procedures. You can make procedures that are pure, but this is only through programmer discipline, the compiler won't help you, and if you call any procedure that isn't pure, there will be absolutely no indication of it
01:29:58 <merijn> teeth: Template Haskell is basically executing haskell code at compile time to produce a Haskell AST that then gets compiled in the final program
01:29:59 <nitrix> tdammers: I want to introduce algebraic data types, but the concatenative aspect is making it complicated as function application is essentially composition.
01:30:11 <nitrix> tdammers: There's no room in the syntax to allow it :/
01:30:21 <merijn> teeth: i.e. it's basically a macro/template language, but the macro language is ALSO haskell :)
01:31:04 <merijn> teeth: Liquid Haskell is a research project that takes haskell source code and uses a SAT solver to check whether more complicated typing restrictions/proofs can be statically verified
01:31:06 <Lokathor> tdammers, i think that haskell is a really high bar to hold every other language to. Erlang is impure at any given moment, but it'd be pretty silly to insist that it's not functional as a result
01:31:23 <tdammers> nitrix: heh, don't know if I'm your guy... just thinking that if you build things like conditionals and equality comparison into the core language, you'll have the usual use cases for pattern matching covered, mostly
01:32:10 <tdammers> Lokathor: I think in order to qualify as a FP language, one should have functions in the language, no?
01:32:19 <tdammers> Lokathor: and "function" implies "pure"
01:32:42 <varaindemian> length' [] = 0  
01:32:43 <varaindemian> length' (_:xs) = 1 + length' xs
01:32:46 <frerich> tdammers: 'function' implies 'pure' only in Haskell (and math, I guess) land though.
01:32:50 <Lokathor> so basically only Haskell then
01:32:54 <varaindemian> I do not understand how (_:xs) acts like "splitting" the head from the tail. We know that if we use 1:[2,3] is like adding one to the list, not taking it appart 
01:33:15 <grouph> Lokathor: I guess every languages sucks in a way. Haskell appears to sucks less in many way, but for example, I can easilly do a part of what you called "dependent type" in C++
01:33:28 <tdammers> frerich: that's what "function" originally meant; it's a bit of a shame that some early proglangs took the name and sloppily applied it to mean "subroutine" or "procedure"
01:33:34 <grouph> varaindemian: it is pattern matching. (:) is a constructor, and can be used both way. a) To build, b) to "unbuild"
01:33:41 <Lokathor> varaindemian, the (_:xs) part "unpacks" the list head and tail, then doesn't evaluate the head
01:33:53 <grouph> varaindemian: depending on if it is on the right side or left side of an expression.
01:34:21 <tdammers> frerich: but in my book, "functional programming" means "program in terms of functions", and "functions" in this context means pretty much the same thing as in Math
01:34:47 <tdammers> grouph: C++ has type-level integers...
01:34:53 <Lokathor> tdammers, your book is overly exclusive methinks :3
01:34:59 <Lokathor> but goodnight all
01:35:02 <grouph> tdammers: (yes ;)
01:35:11 <tdammers> Lokathor: I just value precise language, is all.
01:35:16 <merijn> Lokathor: It doesn't evaluate the tail either :p
01:35:35 <varaindemian> grouph: Now I get it, thx. Where can I read more about the constructors and the position
01:35:36 <Lokathor> merijn, it evaluates the spine of the tail, just not the elements
01:35:51 <merijn> Lokathor: No it doesn't, it only evaluates the first :
01:36:20 <Lokathor> well, yes, i should say, length' will have evaluated the spine of the tail by the end
01:36:21 <grouph> varaindemian: have a look at "learnyouahaskell.com".
01:36:24 <merijn> Lokathor: If it evaluated the spine of the tail it'd walk the (potentially infinite) entire tail of the list
01:36:56 <grouph> varaindemian: (I highly sugest reading it two or three time, with a pause of some time between the reading.  ;)
01:37:14 <varaindemian> grouph: hehe I took the code from there..
01:37:42 <varaindemian> grouph: but it lacks of exercises
01:37:52 <varaindemian> only very good exemples
01:38:15 <Lokathor> grouph, learnyouahaskell is a poor book on its own i think
01:38:22 <Lokathor> try here http://www.seas.upenn.edu/~cis194/spring13/lectures.html
01:38:32 * hackagebot git-jump 0.1.0.0 - Move a git branch  https://hackage.haskell.org/package/git-jump-0.1.0.0 (EyalLotem)
01:40:42 <rhz> Anyone have a Hidden Markov Model library written in Haskell that works with latest GHC?
01:41:25 <varaindemian> Lokathor: is that a more comprehensive course available all time? I'll stick to learnyouhaskell and then I'll give it a shot
01:41:25 <grouph> Lokathor: I think that it depends on how you learn. From my point of view, I thought that LYAH was too long, with too much examples. I learned more in "what i wish i knew when learning haskell" ;) But some people likes stuff less condensed and with more examples ;)
01:41:40 <MasseR> rhz: "Works with latest GHC", out of curiosity, what does ghc has to do with it?
01:42:11 <rhz> well the HMM cabal package doesn't build with latest GHC
01:44:17 <tdammers> it's not a lot of code, shouldn't be hard to fix
01:45:29 <tdammers> turns out, it's strictly only a matter of disambiguating `sum`
01:48:31 <grouph> merijn: thank you for your validated-literals package. That's really nice and this is perhaps the first example of TH that does'nt melt my brain. However that's sad that we cannot hide the TH logic (i.e. the $$(validXXX) inside the constructor.
01:48:44 <tdammers> actually, it looks like the constraint on the logfloat package is too lenient
01:49:25 <tdammers> which isn't surprising since it doesn't specify any version constraints at all
01:50:27 <rhz> tdammers, there seems to be a bunch of other errors as well
01:50:54 <tdammers> yeah, the problem is that logfloat > 0.13, which builds cleanly on ghc 7.10, isn't API compatible with < 0.13
01:51:47 <tdammers> so my guess is that hmm was written against some older version, but that version doesn't compile on GHC 7.10
01:51:58 <tdammers> which means hmm would have to be rewritten to target the newer API
01:52:02 <aleator> Quick question: + ~= Mappend, map ~= Functor, zip ~= Applicative, concatMap ~= Monad, ?? ~= Traversable?
01:54:25 <rhz> tdammers, the Logfloat package builds on GHC 7.10
01:54:59 <rhz> oh i see what your saying
01:55:03 <tdammers> rhz: yes, it does. 0.13, that is. But HMM doesn't build against 0.13.
01:55:05 <rhz> nevermind
01:55:07 <tdammers> :D
01:55:13 <quicksilver> aleator: "traverse" or, if you like "mapM"
01:55:22 <tdammers> maybe you can contact the HMM author about it?
01:56:28 <rhz> I did. He no longer maintains the code. Apparently Henning Thielemann has a version that won't work until GHC 8 is released.
01:56:50 <bezirg> hi, I want to generate a NOINLINE pragma inside TemplateHaskell code. But I cannot figure out what are the correct arguments passed to pragInlD :: ... -> DecQ   . It resides there: https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH.html#g:41     . Anyone can explain?  I cannot understand the arguments RuleMatch and Phases
01:57:32 <tdammers> rhz: so the entire package is kind of unmaintained then?
01:57:38 <rhz> yes
01:57:42 <tdammers> pity.
01:59:45 <cptnsandwich> hi, can i make ghc use less memory during compilation? I had trouble building packages (albeit on an arm board)
02:01:22 <aleator> quicksilver: Hmm.. Naturally, but I was looking for some basic list processing op. I think transpose is the closest match, but that is pretty non-intuitive.
02:01:26 <teeth> cptnsandwich: You can use ulimit
02:02:25 <selckin> will it not just crash when hitting the limit?
02:04:03 <merijn> teeth: That doesn't make GHC use less memory...
02:05:07 <cptnsandwich> selckin: yes, it crashes. but i dont get a built package
02:05:10 <merijn> cptnsandwich: You can try some of the RTS flags to limit the memory usage, but in general GHC doesn't handle low memory environments very well
02:06:11 <teeth> cptnsandwich: How much memory do you want to limit it to?
02:07:50 <cptnsandwich> teeth: i have about 800 mb of free memorz
02:08:07 <teeth> cptnsandwich: You should be able to do $ ulimit -Sv 800000; ghc ...
02:08:24 <merijn> teeth: How does that help?
02:08:30 <cptnsandwich> one workaround for cabal installs was to do a dry run and then loop over the packages building them one at a time
02:08:32 <merijn> teeth: That just means allocation will fail and GHC crashes
02:08:56 <teeth> True
02:09:02 <teeth> It'll just kill the process
02:10:52 <trubert9> I've installed a package with `stack install` locally. When I then go to another project on my machine that depends on this library, and do `stack install`, stack seems to be looking on hackage for the other library, rather than the one I've just registered with `stack install`.
02:10:57 <cptnsandwich> merijn: one problem is that google results always talk about runtime memory.
02:11:22 <trubert9> Is there a way to tell stack to first of all look locally for registered packages, before going off to hackage to look for it?
02:12:48 <rhz> tdammers, looks like there is another HMM package that does build. learning-hmm
02:15:26 <merijn> cptnsandwich: That still works, GHC is just another haskell program, so all the runtime system limits can be applied to GHC itself too
02:15:39 <merijn> cptnsandwich: (i.e. the maximum heap size option, etc.)
02:16:49 <quicksilver> they can be applied but they wno't necessarily make it succeed if it actually needs that memory :)
02:16:58 <quicksilver> there is only so far you can go by making the GC more aggressive
02:17:10 <teeth> cptnsandwich: You could do $ wget -O limit https://raw.githubusercontent.com/pshved/timeout/master/timeout; chmod +x limit
02:17:38 <teeth> Then do ./limit -m 800000 ghc ...
02:17:39 <bernalex> would anyone be interested in getting a haskell track going at FOSDEM?
02:18:45 <bernalex> I just saw the tracks for 2016 announced, and again, no Haskell. we should amend that for 2017!
02:20:01 <MarcelineVQ> What is a track?
02:20:26 <bernalex> well, I mean devroom, really.
02:38:34 <varaindemian> grouph: How did you go through learnyouhaskell.com, just reading it 2-3 times?
02:39:12 <madjar> Hello there
02:40:21 <Ferdirand> :t and . (zipWith (<=) `ap` tail)
02:40:22 <madjar> What do people use to do C ffi these days ? (I have to confess I'm a bit overwhelmed by the amount of options)
02:40:23 <lambdabot> Ord a => [a] -> Bool
02:41:02 <liste> @hackage inline-c -- madjar this is cool if it suits your use-case
02:41:02 <lambdabot> http://hackage.haskell.org/package/inline-c -- madjar this is cool if it suits your use-case
02:41:09 <Ferdirand> how come hoogle doesn't find anything equivalent in the standard lib ?
02:41:42 <Ferdirand> :t (==) `ap` sort
02:41:43 <lambdabot> Ord a => [a] -> Bool
02:41:47 <merijn> madjar: It depends what you wanna do
02:42:05 <Ferdirand> is it because sort asymptotics are considered good enough ?
02:42:12 <merijn> madjar: i.e. do you need to mutate non-primitive C values (i.e. structs) from Haskell or not?
02:42:22 <madjar> It's the kind of library that gives you a handle to something, with which you can call stuff
02:42:31 <madjar> And I don't think I need to mutate structs
02:42:48 <merijn> madjar: Oh, then I'd just straight up use the FFI without any packages conversions, whatever
02:43:08 <merijn> madjar: If all you need is like ints and pointers to call to C it's pretty straightforward
02:43:26 <madjar> merijn: I also get some structs back
02:43:50 <merijn> madjar: Structs or pointers to structs?
02:44:00 <madjar> arrays of structs :)
02:44:09 <madjar> (so, pointers)
02:44:18 <merijn> madjar: Ok, then no problem
02:44:51 <merijn> madjar: I'd recommend starting with chapter 8 of the Haskell Report for the exact details on the FFI. If you're semi-comfortable with C itself and linking everything should be pretty obvious
02:45:01 <merijn> @where report
02:45:01 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
02:45:55 <madjar> merijn: Oooh, thanks ! I've read the ffi chapter from "Real World Haskell", so I'm not starting from scratch.
02:46:05 <madjar> merijn, liste : Thanks a lot !
02:47:02 <merijn> madjar: I forgot how helpful RWH was, but the report was pretty enlightening (but then I do/did a lot of C/C++, so all I needed to know was how GHC interacts with the C linking stuff I'm used to)
02:47:37 <vektor> https://hackage.haskell.org/package/rosezipper-0.2/docs/Data-Tree-Zipper.html - am I missing something or are isLeaf and hasChildren the same thing?
02:48:18 <cocreature> vektor: well they're the opposite, see https://hackage.haskell.org/package/rosezipper-0.2/docs/src/Data-Tree-Zipper.html#hasChildren
02:48:22 <cocreature> so not the same thing but close
02:48:29 <cocreature> it's probably just there for convenience
02:49:24 <vektor> Ahh, ok. Their source codes look significantly different though, so I was wondering.
02:49:39 <vektor>  isLeaf loc = null (subForest (tree loc))
02:49:52 <cocreature> hasChildren loc = not (isLeaf loc)
02:49:54 <vektor>  hasChildren loc = not (isLeaf loc)
02:50:11 <madjar> merijn: oh, by the way, is there a tool to generate that bunch of "foreign import" from the header file for me ?
02:50:12 <cocreature> that's what I meant by opposite
02:50:22 <cocreature> if it has children it is not a leaf and the other way around
02:50:45 <vektor> But yeah. Now that you mention it I see that one is the exact(?) logical opposite of the other, but essentially they seemed to test for the same thing.
02:51:03 <merijn> madjar: There are several, personally I prefer to handwrite them to be sure (although I've only used like 10-15 external functions max, if it's more than that some tooling might be preferable)
02:51:18 <madjar> merijn: okay :)
02:51:24 <merijn> madjar: Mostly because a lot of said tools for generating foreign imports seem to always overcomplicate my life and build process
02:51:35 <merijn> Whereas writing them by hand is like 5 minutes of easy work
02:56:15 <vev_>  we are voluntary on #libreidea and we re looking for a dev to help in this project >> http://www.libreidea.org/Collaborative_keywords_mixing_project
02:56:39 <vev_> our dev is german and he needs someone to work on the core
03:02:05 <vev_> omg open people are on haskell
03:03:34 * hackagebot git-jump 0.1.0.1 - Move a git branch  https://hackage.haskell.org/package/git-jump-0.1.0.1 (EyalLotem)
03:05:52 <ely-se> Is there a package that offers wrappers for System.IO functions that don't use exceptions to signal errors?
03:09:25 <vektor> is there a way to write stuff like "do a <- somefunc; someotherFunc a" that doesn't involve do?
03:09:51 <hpc> somefunc >>= someotherFunc
03:09:51 <tdammers> vektor: somefunc >>= someotherFunc
03:10:07 <hpc> or to be more explicit in the conversion from do-notation, somefunc >>= \a -> someotherFunc a
03:12:34 <grouph> varaindemian: it depends on you. For me it was simple, I read it once, trying every new concepts on small projects aside. Then I started to work with haskell for a few days on more complex projects, than read it again, then another few days, than I read it again. For example, the first time, I got the syntax and many things, but I totally missed the "Applicative" syntax and its uses.
03:12:37 <vev_> is there others germans devs??
03:14:00 <ChristianS> vev_: ja
03:14:34 <Jinxit> are there actually people who actively develop and can't speak english?
03:14:48 <grouph> varaindemian: the problem with haskell (and all other langages) is that you can do everything with a small tiny subset of the language, then understand a core concept and rewrite everything. As an exemple, I wrote parts of a ray tracer (used in the industry) in haskell without even knowing about monad.
03:15:04 <vev_> ChristianS: my dev is german and prog in haskell, maybe you have spare time too?
03:15:25 <vektor> Not sure if that quite applies to my case. I left out some details: do a <- func t i p; otherFunc a ts
03:15:39 <vektor> vev_: Jawohl
03:15:41 <tdammers> Jinxit: I hear there are, but I have a hard time imagining it myself
03:15:54 <ChristianS> vev_: spare time? hm, don't think so.
03:16:03 <vev_> too bad
03:16:18 <jameseb> vektor: func t i p >>= flip otherFunc ts
03:16:49 <vev_> vektor: have you spare time
03:16:56 <Jinxit> tdammers: I wonder, do they name their variables in their native tongue? feels so backwards to me
03:17:15 <tdammers> Jinxit: I've seen that, yes, and it's positively terrible
03:17:21 <vektor> vev_: Barely
03:17:28 <Jinxit> vev_: I don't think asking random germans if they have spare time to work on your project is a good way to recruit people
03:17:37 <Jinxit> most people have their own projects they want to work on
03:17:40 <vektor> jameseb: That sounds good. Thanks. Never know when to use flip.
03:17:51 <ely-se> I consider any code with non-English identifiers bad.
03:17:55 <vektor> Jinxit: exactly. Make me WANT to do it.
03:18:06 <tdammers> if (gebruikerNummer == dezeGebruiker.nummer) { print(gebruiker.naam); } else { print("Verkeerde gebruiker!"); }
03:18:08 <vev_> yes; hope you ll see the project, cause who knows
03:18:25 <vektor> ely-se: How many languages do you speak? AS in, real world languages.
03:18:29 <ely-se> two
03:18:35 * hackagebot git-jump 0.1.0.2 - Move a git branch  https://hackage.haskell.org/package/git-jump-0.1.0.2 (EyalLotem)
03:18:36 <jameseb> vektor: if you find you need flip too often it may be better to rewrite the function with a different argument order
03:18:38 <tdammers> ely-se: occasionally, it makes sense to call culture-specific things by their in-culture names
03:19:06 <Jinxit> I speak roughly three languages and I agree with ely-se 
03:19:17 <tdammers> ely-se: e.g., when you're dealing with gov't stuff, and you're handling things that are well-defined within the country itself, but there is no agreed-upon / natural English translation
03:19:22 <vektor> jameseb: This is a function that is only called in one place, ever. Might as well be in a hidden namespace. And yes, thus that refactoring would apply, but I doubt it'd be worth it.
03:19:23 <Jinxit> I mean of course if there is no corresponding word sure
03:19:45 <ely-se> yeah perhaps
03:20:03 <grouph> (In french we are doing the opposite of your issue, we translate english technical words to french nonsense and we are teaching this in school ;)
03:20:26 <vektor> ely-se: Yeah, in general I agree. Then again, if you're collaborating with people who're less fluent in english.... I've had to comment in german back in HS because the other people on the project couldn't quite follow.
03:21:10 <ely-se> grouph: my Java teacher complained my code was in English. Never attended again
03:21:17 <vektor> grouph: Happens here too occasionally. But most people are reasonable enough to mostly use the english words, even teachers who're kinda required to use the german words.
03:21:31 <Jinxit> ely-se: I would just hand in code in spanish or something
03:21:36 <Jinxit> google translate if you must
03:21:40 <ely-se> lol :p
03:22:17 <grouph> ely-se: I failed a network course because I never attended the course, and during the final test I was not able to understand anything on the test (because they use the french version of what I know in english ;)
03:23:23 <ely-se> I speak English more fluently than Dutch these days
03:23:34 <ely-se> I hardly use the latter anymore
03:30:41 <vektor> worst kind of language related failure: Casual Umlaut in a comment. 
03:31:01 <vektor> Compiler will throw it's hands in the air and shout at you for giving it funny letters.
03:37:29 <zalatovo> Does it make sense to have several StateT in a monad transformer stack? Each StateT level provides a separate set of services
03:38:00 <quicksilver> it makes logical sense but you'll have to write your own useful combinators to get at the different states
03:38:17 <quicksilver> and if you want to use the MonadState class
03:38:50 <zalatovo> quicksilver: right, I'm planning to simply provide a useful interface without direct access with put and get
03:38:56 <quicksilver> yes
03:39:12 <pavonia> It can make sense if you want to re-use diferent layers of your stack
03:39:27 <quicksilver> you should ask yourself the quesiton "Why is StateT s1 StateT s2 StateT s3 better than StateT (s1,s2,s3)?"
03:39:35 <quicksilver> but there are possible answers to that question.
03:40:03 <zalatovo> quicksilver: In my case I think it makes sense to separate the functionality and not keep all the state in one place
03:40:24 <quicksilver> that doesn't sound like a good enough reason on its own :)
03:40:38 <quicksilver> (s1,s2,s3) isn't really any more in the same place than the compose state monad
03:40:56 <quicksilver> it's about how you re-use parts of it, as pavonia said.
03:43:13 <zalatovo> I could make it a bit more concrete: what I have a type checking monad that needs to maintain an environment mapping from names to types and such, and I also need a state monad which maintains which variables have been allocated in stack frames
03:45:35 <zalatovo> quicksilver: So then using the StateT (s1,s2,s3) I would keep all the state in one tuple, and then simply pattern match to get the parts of the state I want out of it?
03:49:25 <Axman6> zalatovo: I'd use a record and lenses to interract with the different state components
03:50:03 <Axman6> so instead of (_,s2,_) <- get, you could use s2 <- gets s2lens
03:55:55 <quicksilver> zalatovo: well you could provide the same "useful interface without direct access to put and get" that you suggested before
03:56:21 <quicksilver> you'd just use (snd . get) instead of (lift get) to implement s2get, or whatever
03:56:30 <quicksilver> the difference would be pretty minor
04:01:59 <cptnsandwich> -quit
04:05:55 <vev_> we are looking for dev with spare time /pm me please
04:07:20 <vektor> Can anyone sanity-check the code I just wrote? https://github.com/vektordev/GP/blob/master/src/GRPPool.hs#L99-L152
04:11:33 <merijn> vektor: Needs less if/then and more local definitions
04:11:39 <merijn> (i.e. where and/or let)
04:11:50 <pacak> vektor: Not very readable.
04:11:53 <merijn> And fromJust is never a good sign
04:12:51 <apankiv> hello everyone. is someone who worked with hoopl online?
04:13:05 <bernalex> apankiv: better to just ask
04:13:07 <nomeata> Hi. Iâm looking for a word: âProducts to tuples as ? to lists.â
04:13:56 <nomeata> In other words: How do you call the set of lists where all elements are from some set or type.
04:14:03 <liste> list is basically a sum of products
04:14:11 <liste> x + xx + xxx + xxxx + xxxxx + ....
04:14:13 <nomeata> I know
04:14:17 <liste> plus 1
04:14:26 <nomeata> but is there a good word for that?
04:14:39 <merijn> nomeata: Can you clarify what you mean by "set of lists where all elements are from some set or type"?
04:14:46 <merijn> What's wring with "sum of products"?
04:14:48 <merijn> wrong
04:15:05 <nomeata> Because itâs too weak; you also need recursion to get lists.
04:15:40 <nomeata> âBase types like () and Int have property foo; tuples, sums and ? of foo types are themselves foo types.â
04:16:15 <lpaste> merijn pasted âRefactor zipperCreateLocalâ at http://lpaste.net/144444
04:16:25 <merijn> vektor: See that paste for an example
04:16:31 <nomeata> Currently, I write âlistsâ, assuming that the reader will under stand that as âthe types of listsâ, but it isnât fully precise wording.
04:16:36 <merijn> vektor: "if isNothing foo" is basically always wrong
04:16:46 <merijn> vektor: You should use case/of for that sort of thing
04:17:10 <merijn> vektor: That eliminates the need of using "fromJust" and avoids doing the "path $ label tree" computation multiple times
04:17:51 <tdammers> merijn: except when "is this a Nothing or not" is strictly the only thing you're interested in
04:18:06 <merijn> tdammers: Even then it's poor form
04:18:14 * merijn mumbles something about boolean blindness
04:18:33 <merijn> "case foo of Nothing -> ??; Just _ -> ??" is still safer and clearer
04:18:46 <bernalex> usually if you have Maybe a and only care if it's Nothing, you're doing something fundamentally wrong somewhere.
04:19:09 <bernalex> & I agree that the case is clearer. and easier to extend/change in the future.
04:19:10 <tdammers> agree
04:19:44 <vektor> merijn: that looks really good. I guess something similar can be applied to the stuff in zipperCreateAll.
04:20:06 <merijn> vektor: Basically almost everywhere where you're using "if isFoo" in the original cose
04:20:55 <merijn> vektor: Makes it easier to see if you missed a case too
04:22:35 <vektor> merijn: Yeah, I guess I can bind lowerRec and leftRec using not IfThenElse, but fromMaybe instead.
04:25:01 <quicksilver> on the other hand, a 'maybe' or 'fromMaybe' where one branch is unreachable may be worse than fromJust
04:25:24 <quicksilver> unreachable code misleads the reader. (Unless the unreachable code is of the form <<error "this can't happen">>)
04:30:14 * frerich remembers the trouble he had computing unreachable code in Tcl programs and wonders whether hpc can do that..
04:30:26 <frerich> Without it, all your percentages are somewhat dubious. :-}
04:31:02 <hpc> i don't do tcl
04:31:28 <frerich> hpc: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/hpc.html says you do code coverage though!
04:31:35 <frerich> So it must be true.
04:31:40 <tdammers> "unreachable" is kind of relative
04:32:07 <frerich> tdammers: How so?
04:32:16 <tdammers> frerich: depends on context
04:32:30 <tdammers> you can, for example, take an expression that contains an unreachable branch
04:32:46 <tdammers> say, `case True of { False -> blah; True -> foo }`
04:33:03 <tdammers> and factor it out into a function
04:33:20 <tdammers> and then within the scope of that factored-out function, the code is no longer fundamentally unreachable
04:33:34 <tdammers> but within the context of the entire application, or even just the containing module, it may still be
04:34:09 <tdammers> pizza b = case b of { False -> blah; True -> foo } -- now the blah branch is reachable
04:34:33 <frerich> tdammers: Right, at this point you use data flow analysis
04:34:36 <tdammers> yes
04:34:45 <tdammers> or maybe you don't and just consider that code reachable
04:34:50 <frerich> tdammers: but I don't see the "relative" part. Either you can show that it's unreachable, or you cannot.  :-)
04:34:56 <tdammers> with the consequence that you include the "unreachable" branch in your tests
04:35:11 <tdammers> unreachable *from where*
04:35:16 <frerich> from anywhere
04:35:33 <frerich> Is it possible that any path in the control flow graph reaches some particular code segment.
04:35:44 <tdammers> so, full program analysis
04:35:54 <mauke\stdClass> yes, if you overflow a stack variable correctly
04:36:32 <frerich> tdammers: In your particular case, yes. In an imperative language, you have a lot of other caes though, e.g. 'int f() { return 3; return 4; }'
04:36:58 <tdammers> frerich: I would argue that we have similar things in Haskell
04:37:26 <tdammers> case items of { xs -> "a"; x:xs -> "b" }
04:37:51 <mauke\stdClass> do { fail "a"; fail "b" }
04:38:05 <tdammers> error "lol" >> print "ya"
04:38:09 <tdammers> :x
04:38:12 <frerich> tdammers: Maybe, yeah. My day time job is to work on tools which (among other things) compute code coverage of C++/C#/Tcl programs and it's quite amazing how much unreachable code you have in bigger projects. E.g. if you have 'void f(bool b) { if (b) { return 2; } else { return 3; } return 5 }'
04:38:27 <apankiv> did my IRC client just fail sending messages?
04:38:43 <mauke\stdClass> see /topic for channel logs
04:38:45 <tdammers> it's certainly easier to accidentally produce unreachable code in imperative-style programming
04:39:21 <mauke\stdClass> I've written a toy brainfuck compiler with toy dead code elimination :-)
04:39:28 <frerich> tdammers: One (well, we) usually generate CFGs out of the AST and with that you can often identify unreachable code even without dataflow analysis, e.g. if all branches of a conditional cause a jump.
04:39:57 <frerich> tdammers: With Java, it's really amazing how often it happens that everything throws an exception :-}
04:39:59 <tdammers> frerich: ofc. I meant it's easier to accidentally write unreachable code in, say, C#, than in Haskell
04:40:23 <frerich> tdammers: Oh, yeah. Maybe. I'd need to think about that, to be honest but my gut feeling is that I agree with you. :-)
04:41:02 <tdammers> my hunch here is that side effects are the main culprit
04:43:54 <jasonkuhrt> Assuming that foldr const 0 [1..5] expands to ((const 1 (const 2 (const 3 (const 4 (const 5 0))))) then I do not understand the last-position zero in the scanr result
04:44:30 <mauke\stdClass> @src scanr
04:44:30 <lambdabot> scanr _ q0 []     =  [q0]
04:44:30 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
04:44:30 <lambdabot>     where qs@(q:_) = scanr f q0 xs
04:44:50 <apankiv> still, I am seeking for possibility of changing datatypes (like FwdPass, BwdPass) in /compiler/cmm/Hoopl/Dataflow.hs but I didn't find their definitions in GHC. am I missing something obvious?
04:45:22 <Jinxit> what's that @ syntax?
04:45:28 <mauke\stdClass> aliasing
04:47:00 <Jinxit> ah, neat
04:51:41 <jasonkuhrt> mauke\stdClass: Thanks
04:54:22 <zennist> Any haskellers in London?
04:54:36 <silver> yes, but not me
04:54:48 <zennist> If someone knows any job that makes use of haskell (and do cool things), please let me know...
04:55:04 <zennist> I'm so tired of being interviewed for writing python (and actually writing python in a job) now...
04:55:11 <tdammers> zennist: most haskell jobs are in finance and stuff like that
04:55:38 <zennist> tdammers: right, problem is, I think I took a deep look into finance in London, and most companies are still using python
04:55:52 <zennist> some Scala, Go, Ocaml, but not many
04:55:59 <zennist> haskell: not known any yet
04:56:54 <tdammers> ofc
04:57:35 <tdammers> there's functionaljobs.com
04:57:39 <CoconutCrab> there is a online fashion company I know that uses Haskell, but I heard the business isn't going very well 
04:57:48 <CoconutCrab> after switching to haskell
04:57:54 <tdammers> And this: https://www.fpcomplete.com/business/haskell-industry/
04:58:45 <tdammers> and this: http://industry.haskell.org/partners
04:58:49 <zennist> CoconutCrab: I was just about to ask if the lack of haskell adoption means either a). haskell is not really good for business b). haskell can be good for business, but it requires too much effort (both from individual developers and companies perspective)
04:59:20 <zennist> thanks tdammers, taking a look now
04:59:25 <tdammers> zennist: it means that investing in a technology like Haskell is only viable if you can afford to rely on long-term benefits
04:59:44 <CoconutCrab> zennist: IMO one problem with Haskell is gathering enough programmers, here at least 
04:59:47 <CoconutCrab> chicken & egg
04:59:51 <hodapp> zennist: or (c) that language adoption actually tells you very little
05:00:00 <hodapp> about the language itself
05:00:01 <tdammers> zennist: Python, for example, makes it easy to attract a relatively large number of programmers in a short time frame; they might not be excellent, but at least you'll find a lot
05:01:09 <E4xoi> the problem comes when you have to mantain code though
05:01:44 <hodapp> that is a problem regardless of language
05:02:17 <E4xoi> switching from ocaml to haskell doesn't look worth it, tbh
05:02:28 <zennist> for python, that can be particularly difficult - if we measure the ratio of the cost of writing to the cost of maintaining, I would argue python is one of the worst languages
05:02:45 <tdammers> zennist: definitely
05:02:49 <hodapp> zennist: few empirical studies appear to exist over this
05:02:58 <zennist> too un-restrictive in terms of paradigms it accepts + dynamic typing + lack of dedication to any one paradigm
05:03:03 <hodapp> zennist: I'm only aware of folks like Les Hatton having actually tried
05:03:24 <tdammers> it appears to me though, that it's really mostly a matter of matching thinkers with languages
05:03:51 <tdammers> empirical vs. inductive, if you will
05:03:55 <vev_>  we are voluntary on #libreidea and we re looking for a dev to help in this project >> http://www.libreidea.org/Collaborative_keywords_mixing_project
05:04:15 <tdammers> the trial-and-error approach, a.k.a., "let's experiment and see what works and what doesn't"
05:04:45 <tdammers> vs. the deep-analysis approach, a.k.a., "let's get to the bottom of this and gain some thorough understanding"
05:05:04 <hodapp> tdammers: the latter is pretty much meaningless if it has no data to agree with it
05:05:40 <tdammers> hodapp: that's not quite what I meant. Maybe "inductive" isn't the right word
05:06:20 <hodapp> tdammers: both kinds of analysis are very rare
05:06:30 <tdammers> to illustrate; some people would say that something "works" when they have tried it 100 times, and it produced the expected result every time
05:07:08 <hodapp> tdammers: Les Hatton also attempted to model, based on models of memory and how humans make mistakes, expected error rate under certain program parameters (module size, number of modules)
05:07:43 <tdammers> this kind of stuff is really hard to research properly
05:08:02 <zennist> I would be so happy if there is a cool company that builds upon haskell
05:08:34 <zennist> i.e. making haskell truly relevant and not feeling like one thing to only 'brag' about when I talk to people
05:09:04 <tdammers> haskell is already quite relevant
05:09:13 <ob_> from your keyboard to the internet's ears
05:09:30 <tdammers> just not in the sense you're envisioning
05:09:55 <tdammers> one important claim to fame is how it influences other, more mainstream languages
05:10:15 <tdammers> e.g., C# borrows a lot from Haskell
05:10:50 <tdammers> Haskell is also an important playground for CS theory, which paves the way for new concepts and problem solving approaches
05:11:16 <ob_> true.
05:11:51 <hodapp> tdammers: right now, I'd merely settle for it being researched *at all*
05:11:54 <tdammers> Haskell also plays an important niche role in companies like Facebook, where it is used for secondary work - tooling, analysis, you name it
05:12:12 <tdammers> hodapp: hah, yeah... also a hot iron if you ask me
05:12:38 <CoconutCrab> zennist: I write Scala for food, and I learn Haskell to improve my mind
05:12:41 <tdammers> hodapp: my theory is that you need to match programmers with languages
05:13:00 <hodapp> that's fine, if you're going to measure it
05:13:09 <CoconutCrab> honestly though, I haven't been able to impress anyone with my (quite limited) knowledge of haskell.. 
05:13:16 <tdammers> hodapp: that's kind of the problem though: how?
05:13:35 <tdammers> hodapp: none of the things we're interested here can be quantified in an unproblematic way
05:13:38 <zennist> CoconutCrab: yours is probably a more realistic kind of experience I can aim for too
05:13:57 <tdammers> hodapp: code quality, code volume, defect rate, performance, developer quality, etc.
05:14:04 <hodapp> tdammers: if it's unquantifiable, then in what sense is it a 'theory'?
05:14:05 <CoconutCrab> people always comment that I use too many loops my code, just because scala use "for" as the keyword for flatmap chaining
05:14:09 <CoconutCrab> do notation*
05:14:18 <E4xoi> most programmers I have meet IRL consider an algorithm correct if it works for 'corner cases and some value in the middle'
05:14:28 <zennist> although I feel that Haskell can be so different from other languages even its functional siblings e.g., Scala wouldn't teach much about it in the other direction
05:14:40 <tdammers> hodapp: point in case
05:14:54 <zennist> so if I want to improve my Haskell from my work - I'm kinda out of choices
05:15:35 <hodapp> tdammers: the analysis I've seen looked primarily at rates of errors in the code, amount of developer time required to find those errors, and amount of developer time required to *fix* them
05:15:46 <tdammers> hodapp: hmhm
05:15:54 <tdammers> hodapp: at least those are observable
05:16:00 <E4xoi> hodapp: do you have any links?
05:16:03 <tdammers> hodapp: quantification may be problematic or somewhat inaccurate though
05:16:10 <aweinstock> E4xoi: as opposed to proving its output to have some properties?
05:16:25 <hodapp> tdammers: and I'm aware of one extensive analysis here over a large codebase with much accumulated history, and the most that that one found is that object-oriented C++ sucked compared with procedural C under those metrics
05:16:28 <CoconutCrab> zennist: which language are you using?
05:16:41 <hodapp> E4xoi: check "Does OO Sync With How We Think?" from Les Hatton, for one
05:16:51 <zennist> for work, it's primarily go and python; but I do my casual stuff in haskell
05:16:57 <tdammers> hodapp: object-oriented C++ is kind of a worst-of-both-worlds thing, so that doesn't surprise me
05:17:12 <tdammers> hodapp: would be interesting how, say, C# or Java would fare
05:17:23 <hodapp> tdammers: he was trying to test the claim that OOP produced better code and he admitted himself at the end that he didn't know if his results actually said much about OOP
05:17:34 <tdammers> yeah, that's what I'd gatehr
05:17:44 <hodapp> I think he also had some data on the error rate of code and found that the strongest predictor was simply the number of lines of executable code
05:17:47 <tdammers> there's so much foot-shooting potential in C++ that has nothing to do with OOP itself
05:18:04 <hodapp> and that, yes, cyclomatic complexity *also* tells you this, but it doesn't tell you it any better, and LOC is easier
05:18:10 <E4xoi> aweinstock: that's insanely complicated in an imperative program vs a fp program
05:18:12 <tdammers> hehe
05:18:17 <hodapp> http://www.leshatton.org/Documents/TAIC2008-29-08-2008.pdf here we go
05:18:23 <tdammers> so we should all start golfing our code then?
05:18:41 <hodapp> tdammers: well, I can't recall the exactly LOC definition he used
05:18:58 <tdammers> hmm
05:19:22 <tdammers> maybe counting syntactic units would work better
05:19:33 <tdammers> for some definition of syntactic unit
05:19:54 <hodapp> tdammers: the plot he has on slide 17 is just executable lines, and mostly it shows a very strong correlation
05:20:14 <tdammers> hodapp: doesn't surprise me
05:20:18 <Nikotiini> Then APL would be the safest language
05:20:36 <tdammers> hodapp: but let's not forget that C and C++ are *very* similar
05:20:40 <hodapp> Nikotiini: This is a statistical measure, not a bulletproof mathematical law.
05:21:04 <RlyDontKnow> tdammers: for very big values of very
05:21:08 <hodapp> tdammers: for whatever reason, procedural C fared much better
05:21:39 <tdammers> hodapp: my guess would be that fewer LOC -> more code to keep in the programmer's working memory at once -> easier to reason about
05:21:40 <hodapp> tdammers: both in terms of lower error rate, and in terms of those errors being 'shallower' and easier to fix
05:21:47 <hodapp> tdammers: the LOC were about the same here IIRC
05:21:52 <tdammers> oh
05:22:02 <aweinstock> E4xoi: what's your standard for algorithm correctness? (Your quote about 'corner cases and some value in the middle' makes it sound like you have higher standards)
05:22:08 <hodapp> tdammers: oh, but in general, you're right - I think he talks about it in those slides
05:22:38 <tobiasBora> Hello !
05:22:49 <tdammers> I mean, it's common wisdom that finding a bug in a 10 LOC snippet is trivial, 100 LOC is possible, 10000 LOC is insane
05:22:49 <aweinstock> E4xoi: (for personal projects, the farthest I go is fuzzing things with quickCheck)
05:23:27 <tdammers> aweinstock: I like the "obviously correct" rule
05:23:31 <hodapp> tdammers: slide 21 says he found it proportional to x ln x, where x = executable LOC
05:23:44 <tobiasBora> I would like to know if there is a function like sortWith but to get the maximum ? For example maxWith :: (Ord b) => (a -> b) -> [a] -> a ?
05:23:53 <hodapp> and I think he actually derived a reason why x ln x seemed plausible too
05:24:22 <frerich> tobiasBora: Maybe you mean 'maximumBy'?
05:24:24 <tdammers> something about juggling dependencies I guess?
05:24:28 <E4xoi> aweinstock: I normally either write code and hope it works if it doesn't I rewrite or try to keep the code too obvious, offloading as much as I can to the type system
05:25:23 <tobiasBora> frerich: How I could use it yes... (it's a big more heavy to write but it's better than nothing)
05:25:29 <hodapp> tdammers: Dunno, just read the slides a bit :P
05:25:56 <tobiasBora> frerich: Thank you !
05:26:04 <aweinstock> E4xoi: does "offloading to the type system" refer to things like avoiding partial functions and using ADTs, or going farther in the direction of dependently-typed-theorem-proving?
05:26:28 <aweinstock> ADTs = Algebraic, not Abstract, in that question
05:27:02 <hodapp> E4xoi: there is the usual design quote of there being two ways to design a system: so simple that it has obviously no errors, and so complicated that no errors are obvious :)
05:27:15 <aweinstock> :t maximumBy -- tobiasBora 
05:27:16 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
05:27:22 <E4xoi> aweinstock: both, GADTs, DataKinds and TypeFamilies give you painful but nice guarantes if you want to :P
05:27:32 <tdammers> hodapp: IIRC there was a study that compared the performance of teams with various self-selected tech stacks and found that they all performed about the same, regardless of technology
05:27:43 <E4xoi> hodapp: yeah, heard of it!
05:27:44 <vektor> tdammers: Well, finding *any one* bug in 10000 LoC should be easier than finding any one bug in 100 LoC.
05:28:25 <hodapp> tdammers: I seem to recall that Brooks had something like that there, but that what he found was that the number of LOC per time was about the same, regardless of language
05:28:33 <aweinstock> > maximumBy (compare `on` length) ["this", "is", "a", "list", "of", "strings"]
05:28:34 <lambdabot>  "strings"
05:28:44 <aweinstock> > minimumBy (compare `on` length) ["this", "is", "a", "list", "of", "strings"]
05:28:45 <lambdabot>  "a"
05:28:50 <tdammers> hodapp: that too, yes
05:29:18 <aweinstock> :t (compare `on`)
05:29:20 <lambdabot> Ord a1 => (a -> a1) -> a -> a -> Ordering
05:29:49 <aweinstock> :t let maxWith f xs = maximumBy (compare `on` f) xs in maxWith
05:29:51 <lambdabot> (Ord a1, Foldable t) => (a -> a1) -> t a -> a
05:30:15 <aweinstock> tobiasBora: ^ the above is more directly what you asked for
05:30:30 <maerwald> is there a useful gtk high-level library yet or should I just go with the low-level bindings (done that before)?
05:31:23 <tdammers> hodapp: I'd be interested in a study where you measure a 2x2 matrix of "dynamic vs. static programmers" and "dynamic vs. static languages"
05:31:46 <tdammers> hodapp: see whether forcing a Haskell programmer into Python yields worse results than forcing a Python programmer into Haskell
05:32:04 <tdammers> hodapp: and how large the difference between a good programmer/language match and a bad one is
05:32:15 <Xandaros> tdammers: Could be interesting. We are rather spoiled by Haskell, aren't we? ^^
05:33:00 <tdammers> Xandaros: totally. I have these younger colleagues here who think Clojure is the food of the gods, and to me it feels a bit like a less robust Python
05:33:19 <E4xoi> tdammers: if the haskell programmer is anything like me, he'll fail really bad <_<
05:33:20 <Xandaros> I was forced to use Lua for a while. I ended up making my own type checking at initial runtime...
05:33:30 <hodapp> tdammers: I've seen some static vs. dynamic studies but they mostly used the 'bad' statically-typed languages
05:33:38 <Xandaros> Well, pseudo-typechecking
05:34:00 <hodapp> Xandaros: erg, I embedded Lua into the application at my last job once to mess around, intending that it be used for scripting and perhaps a REPL
05:34:13 <tdammers> hodapp: that's another problem, but I think one could solve that by having programmers self-select languages
05:34:14 <hodapp> Xandaros: the dev team rapidly decided that it should be used for mission-critical stuff
05:34:33 <hodapp> tdammers: well, they did, it just so happens that they self-selected the crappy languages
05:34:46 <teeth> hodapp: Like which languages?
05:34:48 <hodapp> tdammers: which is probably why the dynamically-typed solutions won out in this test (IIRC)
05:34:50 <Xandaros> hodapp: Yeah... I want to see Haskell as an embeddable scripting language. We should make it happen
05:35:06 <tdammers> that's an important lesson to learn: assume that anything you write is going to be put into production, and it will stay there much longer than you can imagine right now
05:35:27 <hodapp> Xandaros: the issue here was more that they threw Lua into an environment where dynamically-typed & interpreted really was not the way to go
05:35:37 <aweinstock> tdammers: I participated in a programming competition yesterday, expected to use haskell (since the previous times, the organization had used a platform that supported it), but they changed to a different platform, so I ended up using python. I won 2nd place
05:35:39 <hodapp> and that was at the end up a multi-hour data pipeline, which made testing hell
05:35:58 <hodapp> you'd start a test in the morning, find out at lunch that you had a type error somewhere in the code
05:36:17 <hodapp> start another after, find out hours later that you had mangled a variable name somewhere
05:36:19 <E4xoi> aweinstock: did you know Python before learning Haskell? 
05:36:36 <aweinstock> tdammers: insert standard disclaimer about "plural of anecdotes is not data"
05:36:36 <tdammers> hodapp: I think there's a wide "worst of both worlds" range languages - too static for really benefitting from the dynamic approach, but too limited in their type system's expressiveness to make up for it
05:36:45 <hodapp> Xandaros: you are not the first person I've heard suggest that.
05:36:48 <Xandaros> hodapp: I know what you mean. I have no idea how people can work like that
05:36:56 <tdammers> aweinstock: that's a nice way of putting it
05:37:08 <hodapp> Xandaros: I poked a bit with trying to do type inference in Lua and it got too hairy
05:37:18 <hodapp> they poked a bit with trying to do "real" OOP in Lua and it didn't actually help anything
05:37:25 <danilo2> Hello guys! is there anywhere in Haskell a new type definition which makes functions in a monad a monoid ? 
05:37:26 <aweinstock> E4xoi: I think I started with python around a year before I started with haskell, but I started with C a few years before that
05:37:30 <Xandaros> hodapp: Yeah, it was not pretty. Can't recommend it
05:37:47 <maerwald> there is also #haskell-blah ;)
05:37:51 <hodapp> if they had left Lua to *actual* scripting, it would have been fine
05:38:07 <hodapp> if they had used a statically-typed language instead, it would have been fine
05:38:15 <hodapp> le sigh
05:38:39 <hodapp> Xandaros: I'll dig in my notes and find who else was interested in the Haskell-for-scripting thing.
05:38:58 <tdammers> hum
05:38:58 <E4xoi> aweinstock: that explains it, I learnt Haskell and then tried Python and it felt like masochism, otoh, my C skills improved (which I knew before)
05:39:07 <danilo2> I'm making about something similar to Endo but for monadic operations (https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Monoid.html#t:Endo)
05:39:16 <tdammers> for scripting, I'd actually like to see a language with Haskell-like syntax, but more dynamically typed
05:39:41 <E4xoi> danilo2: they already are
05:39:52 <danilo2> E4xoi: great! where? :D
05:40:06 <tdammers> OTOH, scripting should mostly be the realm of problems that aren't very hard, so it's probably better to aim for maximum familiarity for the relevant programmers
05:40:08 <E4xoi> danilo2: there is a Monad instance for (->) r in base
05:40:20 <E4xoi> Prelude*
05:40:28 <danilo2> E4xoi: I'm not taking about monad instance for (->) I want (a -> m b) to be a Monoid
05:40:44 <Xandaros> tdammers: At the same time, sometimes people sript whole games (look at garry's mod)
05:40:53 <hodapp> tdammers: I'm interested more in the static typing part, because I feel like 90% of the time when I deal with bugs in scripts it's things buried really deep that type checking should have caught
05:40:57 <danilo2> E4xoi: look at the link I've provided
05:41:15 <hodapp> tdammers: and if it's "easy" stuff they may not be likely to try to do run-time sanity checks and type-checks, or document things properly
05:41:21 <tdammers> hodapp: at that point, I usually switch from "scripting" to "programming"
05:41:49 <hodapp> tdammers: the fact that it's buried deep doesn't mean it's buried deep in the script itself
05:41:49 <E4xoi> danilo2: I understand, didn't look for one myself though
05:41:49 <tdammers> i.e., I factor out the workhorse part to a real programming language and just have a bit of script around it to drive it
05:42:44 <zomg> hodapp: as someone who works with javascript all day, I can definitely agree about bugs in scripts being possible to catch by type checks
05:43:08 <hodapp> zomg: well, Google tried to give us some static typing here with Dart and it seemed to go basically nowhere
05:43:09 <zomg> as an added bonus, we use mongodb, so not even our database is consistently typed
05:43:09 <maerwald> is there a useful gtk high-level library yet or should I just go with the low-level bindings (done that before)?
05:43:15 <teeth> I feel sorry for you
05:43:50 <danilo2> maerwald: d you have to use gtk ?
05:43:55 <zomg> hodapp: the closest thing I've seen to javascript with types that actually works and is production quality is TypeScript
05:44:01 <maerwald> danilo2: I want to.
05:44:06 <danilo2> maerwald: I'll go with qtquick bindings (they are working really good in hs)
05:44:11 <maerwald> no thanks
05:44:20 <danilo2> maerwald: out of curious - why ?
05:44:25 <danza> zomg, also Purescript is not bad
05:44:35 <maerwald> I don't like qt
05:44:36 <hodapp> didn't TypeScript merge into some other Googly thing?
05:44:37 <zomg> danza: sure but I wouldn't really call that "javascript with types" :)
05:44:40 <danza> zomg, you might want to know that Mongo is flawed by design
05:44:50 <hodapp> danza: why's Mongo flawed by design?
05:44:59 <maerwald> guys, are you still ontopic?
05:45:22 <danza> don't worry maerwald, we stop it here
05:45:26 <zomg> mongo has some replication issue which can lose data... but yeah, we know it's not perfect. Wasn't my choice, I'm advocating replacing it with Postgre
05:45:26 <danza> zomg, https://aphyr.com/posts/322-call-me-maybe-mongodb-stale-reads
05:45:44 <saulzar_> danilo2, Maybe you'd find this interesting http://stackoverflow.com/questions/32935812/why-isnt-kleisli-an-instance-of-monoid
05:45:51 <danilo2> maerwald: Yous to add few cents - you don't have to use any QT-code, the bindings allow you for haskell like experience. Another possibility would be to use web view and GHCJS with canvas utilities (in fact we are going exactly this way) - I'm just looking for most platform independent solution
05:46:15 <hodapp> danilo2: have you done Qt in Haskell?
05:46:18 <maerwald> don't really want to be platform independent, it should be a gtk gui
05:46:37 <hodapp> danilo2: I used to use Qt professionally (C++) but I've not really touched it since leaving that job, so I'm curious
05:46:50 <maerwald> I've used the gtk bindings before... but they are just low level bindings, so your code is barely abstract
05:46:51 <mniip> what a dilemma
05:47:06 <hodapp> hmmmm
05:47:10 <danilo2> saulzar_: Yes, it is indeed. Ad I knew about it, that there is no single good solution form making mooned for kleisli arrows, and because of that I was looking for a new type wrapper for that. Thanks for the link! :)
05:47:22 <hodapp> agocorona needs to hurry up and finish his holy grail of UI programming stuff!
05:47:55 <danilo2> hod app: personally not, but people in the company I'm working it did it. Still it was not a huge project, because we've switched to webgl
05:48:17 <hodapp> danilo2: still Haskell-based?
05:48:22 <danilo2> of course
05:48:22 <danilo2> :)
05:48:32 <danilo2> hod app: everything we do is in haskell
05:48:32 <hodapp> danilo2: what's WebGL like there?
05:48:49 <hodapp> is it hsqml for qt quick too?
05:48:51 <Wizek> Hey! cabal is telling me that I need to run cofigure manually when I try to `cabal run`, since both ghc (7.4->7.8) and cabal (1.18 -> 1.20) has changed. Which is very stange considering this is on a fresh linux install where I've only installed ghc-7.8.4 and cabal 1.20, and afaik the other versions are not even present on the system. Running `cabal configure` finishes without errors and then the error persists. Why is cabal telling me this? W
05:48:51 <Wizek> hat could I do to fix it?
05:49:22 <hodapp> h-squeamel? h-s-QML? h-s-queeml? blah pronunciation
05:49:25 <aweinstock> danilo2: instance Monad m => Monoid (a -> m b) where mempty = return; mappend = (>=>) -- does this work?
05:49:40 <danilo2> hmm, we've created our own bindings - we want to release them as open source libraries in a while. GHCJS is working really fine. The bindings I've told you about allow you to create "processing - like" experience - functional style of shapes definition with automatic GLSL shaders generation. Its pretty fun to use and its working really fast
05:49:43 <tdammers> Wizek: my guess is that you copied the project over from elsewhere, or maybe you have some of cabal's intermediate files in source control
05:49:47 <mniip> aweinstock, no
05:49:58 <mniip> Monoids are unindexed
05:50:03 <hodapp> danilo2: I'd really like to see that if it's open sourced
05:50:22 <danilo2> aweinstock: of course, but thats not what I want. Look at the link provided by saulzar_ - we cannot define such instance (and it has a type error by the way) 
05:50:34 <maerwald> also, grapefruit as a high-level UI library doesn't sound like a good idea, since it's still on version 0.1 and the wiki says there will be a major rewrite
05:50:42 <maerwald> so I'd probably get lots of API breakage in the future
05:50:44 <danilo2> aweinstock: but I'm looking for new type wrapper. I'll do it by myself I think. I know that this are 2 lines of code, but I love purity :)
05:51:31 <danilo2> hod app: here is a screenshot in action:
05:51:34 <danilo2> http://www.nodelab.io
05:51:44 <danilo2> hod app: ^^^
05:51:55 <saulzar_> Oooh, pretty
05:52:05 <danilo2> fuck, my dictionary "fixes" your name hodapp :P 
05:52:29 <danilo2> glad you like it :)
05:52:32 <Wizek> tdammers, I've done a `cabal get reactive-banana-wx-1.0.0.0; cd reactive-banana-wx-1.0.0.0; cabal install`, so AFAICT neither copying (apart from getting from hackage) nor source control is involved 
05:52:39 <saulzar_> This is rendered using WebGL?
05:52:51 <danilo2> yep
05:53:15 <saulzar_> How come WebGL and not just SVG for that kind of thing?
05:53:41 <danilo2> saulzar_: with automatic GLSL generation and optimisation, wise distance field - based shaders, peel - resolution undefended antialiasing and a lot of great stuff under the hood :)
05:53:57 <saulzar_> Fonts would be a pain though, right?
05:53:59 <danilo2> saulzar_: WEBGL is much faster fora great amount of objects
05:54:27 <danilo2> saulzar_: no, we render fonts using SDF - based shader, so we've got smooth scaling and very, very crisps fonts even in big zoom
05:54:36 <danilo2> saulzar_: just like QTQuick does under the hood
05:54:42 <saulzar_> Impressive
05:55:28 <danilo2> saulzar_: I'm glad you like it! :) We are open sourcing as much as we can , so I think this library will be in package this month. (I hope so)
05:55:53 <saulzar_> Cool - it sounds like effectively a vector graphics renderer in WebGL?
05:56:40 <danilo2> some kind of. In fact we define basic shapes, a bool algebra and type classes that know how to translate shape bool algebra to shaders
05:58:25 <tobiasBora> aweinstock: Ohhh yes I forgot the `on` function !
05:59:01 <frerich> tobiasBora: There's also a tiny alias which might make things a tad nicer, called "comparing".
05:59:50 <tobiasBora> frerich: In which module is it ?
06:00:03 <frerich> tobiasBora: It's also in Data.Ord
06:00:26 <quicksilver> it's a small step from learning `comparing` to learning `on`
06:00:34 <quicksilver> and then you never want `comparing` again
06:01:12 <frerich> Yeah everyone seems to think that but somehow I still think 'groupBy (equating length)' or 'sortBy (comparing length)' looks neat. :-)
06:01:30 <frerich> It's silly.
06:01:33 <lpaste> narendraj9 pasted âNo titleâ at http://lpaste.net/144454
06:01:39 <narendraj9> I am trying to parse JSON arrays, I don't know why this parser fails when there is a space before ']' and succeeds otherwise.
06:01:47 <narendraj9> Can someone please explain?
06:02:19 <YellowOnion> could I get some tips on improving my code? http://codepad.org/mru1IMO1
06:02:26 <quicksilver> narendraj9: because 'sepBy' is only consuming the spaces *between* items
06:02:34 <quicksilver> narendraj9: not spaces at the end (or indeed beginnin) of the list
06:02:54 <narendraj9> quicksilver: Let me paste the definition of parseToken too.
06:03:01 <maerwald> YellowOnion: I was about to say "delete it", but you are obviously not serious about it ;)
06:03:10 <aweinstock> :t equating
06:03:12 <lambdabot> Not in scope: âequatingâ
06:03:18 <aweinstock> :t ((==) `on`)
06:03:19 <lambdabot> Eq a1 => (a -> a1) -> a -> a -> Bool
06:03:20 <frerich> YellowOnion: I do wonder in which way you want to 'improve' it. :-)
06:03:31 <YellowOnion> :D
06:03:51 <narendraj9> quicksilver: Shouldn't parseToken consume that space?
06:03:56 <Xandaros> Looks like eprfect Lisp to me
06:04:12 <quicksilver> narendraj9: erm did ou show me parseToken yet?
06:04:27 <quicksilver> I refreshed paste but see nothing new
06:04:34 <narendraj9> quicksilver: Oh. I pasted it. But didn't select the channel. Sorry.
06:04:43 <narendraj9> quicksilver: http://lpaste.net/144455
06:04:59 <aweinstock> YellowOnion: what does that do? is it deliberately obfuscated?
06:05:20 <YellowOnion> aweinstock, yeah, it prints Hello World, as shown down below.
06:05:27 <quicksilver> hmm
06:05:38 <aweinstock> YellowOnion: ah
06:05:50 <quicksilver> I have to run, narendraj9; some sample input might help
06:06:01 <aweinstock> YellowOnion: I'd suggest (main = putStrLn "Hello World") ;)
06:06:45 <narendraj9> quicksilver: parse parseArray "array" [1,2,3 ]" 
06:07:02 <narendraj9> quicksilver: This fails. While (parse parseArray "array" [1,2,3]") works.
06:07:10 <aweinstock> > (otherwise, fromEnum otherwise) -- I thought otherwise was syntactic sugar before seeing this
06:07:12 <lambdabot>  (True,1)
06:07:33 <narendraj9> quicksilver: I think "[1,2,3 ]" should parse correctly.
06:07:36 <aweinstock> > join (+) $ fromEnum otherwise
06:07:38 <lambdabot>  2
06:07:43 <Xandaros> YellowOnion: It should be intuitive for lisp people. Looks just as legible to me :D
06:07:52 <aweinstock> :t replicateM (+)
06:07:53 <lambdabot>     Couldn't match expected type âIntâ
06:07:54 <lambdabot>                 with actual type âInteger -> Integer -> Integerâ
06:07:54 <lambdabot>     Probable cause: â(+)â is applied to too few arguments
06:07:59 <aweinstock> :t flip replicateM (+)
06:08:00 <lambdabot> Num a => Int -> a -> [a -> a]
06:08:24 <aweinstock> :t replicateM 5 (+) =<< join (+)
06:08:25 <lambdabot>     Couldn't match expected type â[[a]]â
06:08:25 <lambdabot>                 with actual type âInteger -> Integer -> Integerâ
06:08:25 <lambdabot>     Probable cause: â(+)â is applied to too few arguments
06:09:01 <YellowOnion> > take 10 $ fix$(<$>)<$>(:)<*>((<$>((:[{- JÃ¶rÃ° -}])<$>))(=<<)<$>(*)<$>(>>=)(+)($))$1
06:09:03 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
06:09:52 <hodapp> danilo2: neat! thank you!
06:09:54 <aweinstock> :t mfix (+) 1
06:09:55 <lambdabot> Num a => a
06:09:57 <aweinstock> > mfix (+) 1
06:10:01 <lambdabot>  mueval-core: Time limit exceeded
06:10:20 <YellowOnion> I saw a post on reddit yesterday using a bunch of lambda's got me curious about doing something with high-order functions
06:10:41 <Romefeller> nice YellowOnion 
06:14:01 <tobiasBora> When ghc see a function that take in parameter an integer and a function, if I do "f 15 my_fct; f 15 my_fct", will ghc evaluate "f 15 my_fct" twice or not ?
06:14:05 <YellowOnion> Ahh found it: https://benkurtovic.com/2014/06/01/obfuscating-hello-world.html
06:14:40 <E4xoi> YellowOnion: that is brainfuck compiles to haskell
06:14:46 <jophish> Is there any package with a function from Nats to n-tuples?
06:14:47 <E4xoi> compiled*
06:15:04 <jophish> where Foo 2 a = (a,a)
06:15:23 <narendraj9> quicksilver: Strange right?
06:15:37 <c_wraith> jophish: hmm.  There's no recursive structure to that, so it's just going to be a big list of special cases.
06:15:46 <c_wraith> jophish: I can see why you'd want an existing package.
06:15:48 <jophish> c_wraith: yeah, that's what I thought
06:16:12 <jophish> It might even work the other way round with injective type families
06:16:40 <c_wraith> It certainly could be made an injective family, but it's partial both ways..
06:16:42 <jophish> perhaps I should just live with nested tuples
06:17:28 <c_wraith> Since maximum tuple size makes it partial if the Nat is too big, and (a, b) can't go backwards.
06:17:57 <jophish> The base problem I'm trying to solve it to create a data (kind) type for variable types in a language I'm writing a dsl for. so at the moment I have Type = Int | Bool | Array Nat Type
06:18:05 <jophish> where Nat is the rank of the array
06:18:23 <jophish> c_wraith: probably best to keep it one way then
06:18:51 <mniip> jophish, interestingly I'm looking for a similar thing
06:19:01 <mniip> except I need a GADT with multidirectional inference
06:19:03 <jophish> annoyingly the target language differentiates between arrays of rank 2 and an array of arrays of rank 1
06:19:22 <jophish> mniip: yeah, I've got that working really nicely for the expression type
06:19:36 <jophish> But data Expression :: Type -> *
06:19:59 <jophish> to stop people doing things like: Expression Float (The language doesn't have floats)
06:20:14 <mniip> some constructor C such that C (undefined :: t, undefined :: t') :: C 2 t
06:20:16 <mniip> and t ~ t'
06:20:33 <mniip> I almost made it work, but there is one problem
06:20:35 <mniip> empty tuples
06:20:50 <mniip> make mptc fundep coverage conditions fail
06:21:27 <jophish> mniip: can you special case them?
06:21:31 <mniip> not really
06:21:47 <mniip> this needs some edwardk
06:21:48 <jophish> or perhaps make your own unit type taking a dyummy parameter?
06:22:02 <mniip> dummy parameters won't help
06:22:26 <mniip> imagine class Tuple t (l :: Nat) e | t -> l e, l e -> t
06:22:33 <mniip> for example Tuple (e, e) 2 e
06:22:48 <jophish> oh I see now
06:22:49 <jophish> of course
06:22:59 <mniip> but I can't say Tuple () 0 e
06:23:04 <mniip> because () doesn't determine e
06:25:34 * hodapp really tries to figure out what a CoconutCrab is...
06:26:52 <jophish> Perhaps I'll allow nested arrays in the haskell side of things, and translate them to arrays of higher rank when writing out the source
06:27:04 <mniip> hodapp, that's a double co
06:27:09 <mniip> it's just a nutcrab
06:27:24 <jophish> never change, #haskell
06:27:24 <hodapp> mniip: *slow clap*
06:27:25 <quicksilver> narendraj9: and what is the error?
06:28:17 <mauke\stdClass> you're a nut! you're crazy in the coconut!
06:28:38 <mniip> mauke\stdClass, you're coconuts
06:30:00 <roelof> Could I test multiple properties with QuickCheck ? 
06:30:10 <jophish> roelof: why ever not?
06:30:55 <roelof> jophish:  I only see examples of single properties 
06:32:29 <jophish> roelof: here's an example of running multiple quickcheck/smallcheck/hunit tests with tasty http://documentup.com/feuerbach/tasty
06:32:48 <roelof> not where the max and the count of the max is being tested 
06:34:08 <roelof> jophish:  thanks, I will look at the examples 
06:34:56 <danilo2> mini: If you want to do something like that make a nested type class, so the upper layer doesn't have the funds and lower layer does. The upper layer redirects to lower layer when it is not an empty tuple, do you see the point ?
06:34:56 <tekkkz> Hello! How can I parse a website as text (crawled, works already) so I get all the "<a href..." links into a list? How to do that and is Lens useful for that?
06:34:59 <jophish> roelof: tasty is a pretty cool way to organize lots of tests
06:35:08 <danilo2> mniip ^^^
06:35:37 <jophish> tekkkz: I used hxt for that, it takes a little bit of getting used to though
06:35:42 <mniip> danilo2, hmm
06:35:52 <jophish> there's also tagsoup I think which is a little easier to jump in to
06:35:55 <mniip> but will the inference be strong enough?
06:35:59 <roelof> I see it,  but still not a example of multiple properties of 1 list as the max and the count of that max-value of a list 
06:36:05 <srhb> tekkkz: The cheap and simple way is to tagsoup and filter the tags with regular list operations.
06:36:14 <roelof> I think I will use Hunit only 
06:36:32 <tekkkz> hm so can you give me please some more information about the simplest method for that?
06:36:39 <jophish> roelof: I don't quite understand what you're after
06:37:04 <Xandaros> I tried tagsoup and it is quite literally what it sounds like. A soup of tags. Should be enough for that use case, though
06:37:11 <jophish> tekkkz: here's a small tutorial on tagsoup http://community.haskell.org/~ndm/darcs/tagsoup/tagsoup.htm
06:37:22 <roelof> jophish:  I have a function which finds the max value in that list and how many times that value that value is on that list. 
06:37:36 <roelof> Example  [ 1 , 1 , 2] gives ( 1 , 2) 
06:38:03 <roelof> [ 1 , 1 , 1 ) gives (1 , 3) 
06:38:04 <srhb> tekkkz: map (your tag to text function . filter (~== TagOpen (your tag specification)) . parseTags $ yourSoupyString
06:38:32 <srhb> tekkkz: That's the gist of it...
06:39:48 <roelof> jophish:  is it now clear ? 
06:42:56 <jophish> roelof: so you want a test like (\xs -> let (n, m) = (count n xs, maximum xs) in (n, m) === roelof's_function xs)
06:44:08 <jophish> I think it would be nicer to test these properties one at a time though
06:44:32 <roelof> oke, that looks like it . The only things is that I did not have learned to use lamdas 
06:45:14 <roelof> jophish:  oke, but does not change the data in each test of QuickTest ? 
06:45:15 <jophish> (\xs -> let (_, m) = roelof'sFunction xs in maxmimum xs === m) and (\xs -> let (n, m) = roelof'sFunction xs in count m xs === n)
06:45:40 <quicksilver> toListOf (deep (name "a") . attr "href")
06:45:47 <quicksilver> is the xml-lens way to do tekkkz's question
06:46:33 <jophish> roelof: quickcheck will run this check over many different random lists
06:46:50 <jophish> or each check over many different random lists
06:47:04 <roelof> That is what I mean 
06:47:53 <lamefun> is there a function to remove duplicates from list?
06:47:58 <jophish> lamefun: nub
06:48:09 <merijn> Nub is terrible and quadratic, though
06:48:25 <merijn> If you have an Ord instance you're better of doing S.toList . S.fromList
06:48:26 <lamefun> excellent name for a function...
06:48:31 <tdammers> round-trip through hashmap
06:48:40 <jophish> or numb'la better yet nubOrd
06:48:41 <tdammers> hashset*
06:48:44 <mauke\stdClass> > nub [0 ..]
06:48:45 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:48:48 <carp_> Hello guys. I learned of haskell after John Carmacks quakecon speech the other year. I gave haskell a crack, working (halfway) through 'learn you a haskell for great good' tutorial. Before that I have only done 6 months of python. I would like to know how things have developed since then. Is haskell in a better shape than it was this time last year for making 2d games?
06:48:54 <roelof> jophish:  thanks, till I have learned lamdas in the Craft book I stick with Hunit for this exercise 
06:48:55 <jophish> lamefun: *
06:50:00 <ARM9> carp_ I don't think the language has changed much, there might be more/improved libraries (bindings for sdl, opengl etc.). what were you having issues with?
06:50:45 <jophish> merijn: how does nubOrd compare to toList.fromList?
06:53:10 <lamefun> merijn, does S.toList . S.fromList lose item order?
06:53:41 <merijn> lamefun: Oh, yeah it does
06:53:56 <merijn> jophish: Where is nubOrd from?
06:54:11 <jophish> Data.List.Extra
06:54:11 <danilo2> mniip: The inference will be as strong as it could be. You cannot have constrain a -> b that doesn't satisfy liberate coverage condition unless you use DysfunctionalDependencies (which you do not want to enable, trust me). 
06:54:18 <jophish> in the "extra" package
06:54:37 <jophish> I thought there was another version floating around, but I can't seem to find it
06:54:44 <carp_> ARM9: i wasnt having problems but i am worried about the small amount of developers, no official haskell forum, stuff like that. Since john carmacks speech, have there been lots of companies starting to make games with haskell? I know of one studio that had a hit game recently, and have started on a 2nd game which is using haskell. But thats only 1 small company, with a successful game behind them
06:54:52 <jophish> "extra" seems to be pretty big
06:54:56 <danilo2> mniip: Look, you want to tell type checker it should infer the right side WHENEVER possible. It is not possible with empty tuple, so this case you should exclude from the inference, and it is pure and the best solution you can go with
06:55:17 <mniip> danilo2, will C((),()) derive C 2 ()
06:55:50 <danilo2> if you enable DysfunctionalDependencies the right side will be inferred polimorphically, BUT! After the first inference GHC will cache the result and infer it the same way with other types too. It has some use cases, but in my life I met only one such use case and because of that I've made this extension
06:56:02 <mauke\stdClass> carp_: what language has an official forum?
06:56:03 <danilo2> mniip: of coursE!
06:56:18 <danilo2> GHC will se that it is NOT empty tuple, so it will redirect to the second layer
06:56:55 <danilo2> mniip: If you want to have pretty types just wrap it in nice type families on top, but yes, it is the way you want to go
06:57:20 <carp_> mauke\stdClass: Ah is it like that? Is there an unofficial haskell forum for getting help with problems?
06:57:25 <danilo2> mniip try it, If it will not work, give me code example and I'll love to look at it
06:57:39 <danilo2> I've got to go home in 30 minutes, but then grab me at my mail or whatever
06:58:07 <danilo2> mniip you can find my mail in any commit in my libraries in hackage
06:58:15 <mauke\stdClass> carp_: huh?
06:59:10 <carp_> mauke\stdClass: is there a forum where haskell users can post questions if they are having problems, and are likely to get good help?
06:59:33 <merijn> carp_: The haskell subreddit?
06:59:52 <mauke\stdClass> carp_: this channel
07:00:05 <mauke\stdClass> carp_: the mailing list, stackoverflow
07:00:47 <jophish> the haskellquestions subreddit too
07:01:51 <carp_> mauke\stdClass: righto. Its one of the worries for me, from embracing haskell as I know it is very small in comparison to other languages.
07:02:40 <jophish> carp_: this channel is one of the largest on freenode
07:03:02 <carp_> I am still a beginner enough in all programming languages that I dont really care if I use haskell or not, I am not competent enough to fully comprehend advantages and disadvantages of the languages themselves
07:03:02 <emmanuel_erc> good morning (EST over here) haskell
07:03:18 <tdammers> carp_: Haskell is relatively small, but the quality standards are high
07:03:35 <tdammers> carp_: 100 average haskellers will be more helpful than 100 average pythonistas
07:04:32 <carp_> awesome
07:09:06 * hackagebot carray 0.1.6 - A C-compatible array library.  https://hackage.haskell.org/package/carray-0.1.6 (HenningThielemann)
07:16:39 <tekkkz> I'm using tagsoup now, but: I have crawled website now and want to apply the haskellHitCount function to my problem: https://bpaste.net/show/fa45e16dde69 i want to get the url of the 4th line's link, you know what I mean?
07:22:20 <emmanuel_erc> hello there!
07:22:42 <emmanuel_erc> (BRB)
07:38:48 <pfukkk> hello'
07:38:55 <tkpre> yo whats up
07:46:11 <lamefun> Why don't I have to prefix functions in 'instance .. where' with module name if I import qualified?
07:47:41 <lesh_> Hi
07:47:43 <quchen_> lamefun: The function's scope can be inferred from the type
07:47:58 <orion> How can I tell hackage to run unit tests on my package?
07:48:05 <quchen_> lamefun: There can only ever be one "show" for "Foobar", for example, so you don't need to say "Foobar.show" in the instance
07:48:17 <lesh_> I have a university assignment which I need some help with. Obviously I just want a few pointers, not the whole thing done for me
07:48:23 <concept3d> so I have this haskell sockets server , I want to convert it to a daemon/service how should I do this ?
07:48:24 <lamefun> then why if I just import SomeModule (SomeClass) then it will complain about missing functions?
07:48:42 <lesh_> I need a function such that the result of bundle 3 [1 .. 10] should be:  [[1,2,3],[4,5,6],[7,8,9],[10]]
07:48:43 <lamefun> makes zero sense to me...
07:48:54 <quicksilver> > chunksOf 3 [1..10]
07:48:55 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
07:49:06 <lesh_> quicksilver: rofl seriously?
07:49:10 <quicksilver> :)
07:49:16 <jophish>  lamefun you need to import SomeClass(..) to import it's members 
07:49:19 <jophish> its*
07:49:20 <quicksilver> it may be that your assignemtn wants you to write it yourself tho
07:49:36 <lesh_> quicksilver: Yeah it comes just after a lecture on foldr so perhaps they want it involving that
07:49:39 <lamefun> jophish, then the members will go to main scope
07:49:50 <jophish> lamefun: import qualified thn
07:49:52 <jophish> then*
07:49:56 <lamefun> this makes no sense...
07:50:06 <jophish> how so?
07:50:16 <quchen_> lesh_: Use splitAt repeatedly
07:50:23 <lamefun> if I import qualified I don't have to prefix the names with module name
07:50:41 <quchen_> lamefun: Example code plese
07:50:43 <lesh_> quchen_: Cheers ill take a look
07:50:59 <jophish> lamefun: import qualified Data.List(foldl') as L
07:51:08 <jophish> then you can use L.foldl'
07:52:01 <lesh_> > splitAt 5 [1 .. 10]
07:52:02 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
07:52:05 <Cale> lamefun: You mean the functions that you're defining? The class methods?
07:52:08 <lesh_> > splitAt 3 [1 .. 10]
07:52:10 <lambdabot>  ([1,2,3],[4,5,6,7,8,9,10])
07:52:46 <nshepperd> lamefun: if the names are in scope that probably means the class is already in scope from a different import
07:52:54 <nshepperd> or from prelude I guess
07:52:56 <aweinstock> > (\n xs -> foldr (\x (m, a, b) -> if m < n then (m+1, x:a, b) else (0, [], a:b)) (0, [], []) xs) 3 [1..10]
07:52:58 <lambdabot>  (2,[1,2],[[4,5,6],[8,9,10]])
07:53:15 <mrd> > map (flip splitAt [1..]) [1..]
07:53:16 <lambdabot>  [([1],[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
07:53:57 <lesh_> I don't know how to continue though
07:54:30 <jophish> lesh_: you want to use splitAt on the remainder list again
07:54:35 <lamefun> http://lpaste.net/7144277977742704640
07:54:38 <lamefun> magic?
07:54:38 <jophish> until you have nothing left
07:55:44 <Cale> > (\n xs -> foldr (\x f m a b -> if m < n then f (m+1) (x:a) b else f 0 [] (a:b)) (\m a b -> (m,a,b)) xs 0 [] []) 3 [1..10] -- backwards ver. ;)
07:55:46 <lambdabot>  (2,[10,9],[[7,6,5],[3,2,1]])
07:56:10 <breadmonster> Anyone got good reads on typeclass magic?
07:56:14 <jophish> lamefun: because you still have an unqualified import for Class(Class)
07:56:15 <nshepperd> oh, you're talking about the lhs in an instance definition
07:57:23 <lamefun> jophish, ?
07:57:35 <Cale> lamefun: It's smart enough to know which doSomething you mean from the fact that you're defining an instance of Class
07:57:57 <Cale> It could only be one thing: the method of the class that you're actually defining
07:58:20 <nshepperd> lamefun: I think restricted imports are sort of doing double duty here as a weak permisions system
07:58:23 <Cale> Nevermind that qualified names aren't even allowed in the names of things being declared, as far as I'm aware at least.
07:58:25 <lamefun> Why does it need a qualified import then?
07:58:37 <Cale> It... doesn't?
07:58:38 <aweinstock> Cale: is that the foldl-in-terms-of-foldr trick?
07:58:43 <Cale> You just need to import the class *somehow*
07:58:52 <Cale> it doesn't have to be a qualified import
07:58:56 <lamefun> Cale, http://lpaste.net/7144277977742704640 - comment qualified import --> it stops working.
07:59:27 <Cale> oh, I see, you didn't import the entire class, just its type level name
07:59:36 <Cale> use  import Class (Class(..))
07:59:43 <nshepperd> lamefun: in that, if module Class did not expose doSomething, that would mean that other modules aren't "allowed" to implement that operation for the class
07:59:45 <Cale> to import the methods of the class as well
07:59:51 <lamefun> then the names will go to my module scope, I don't want that
08:00:04 <nshepperd> lamefun: presumably a restricted import is having the same effect
08:00:07 <Cale> This is more confusing than it ought to be because you've named multiple things Class.
08:00:28 <Cale> Well, fine then, use the qualified import.
08:00:55 <nshepperd> importing the operation itself by any method (even qualified) means that you're "allowed" to use it in an instance def
08:01:01 <Cale> You're not allowed to qualify the name of something you're defining though.
08:01:03 <Cale> ever.
08:01:04 <lamefun> But why do I need that? Doesn't it already know what module does the class come from?
08:01:06 <nshepperd> because it is in scope somewhere
08:01:25 <Cale> lamefun: Because the thing isn't in scope at all, since you never imported it.
08:01:52 <Cale> I guess it is a little confusing that it's possible to do that
08:02:03 <Cale> Maybe importing a class should always just import its methods
08:02:05 <lamefun> But when I import qualified with name C, the names get magically imported to 'instance .. where' scope.
08:02:25 <lamefun> Why can't it do just that without needing the qualified import?
08:02:35 <Cale> Can you use the names on the right hand side unqualified?
08:02:40 <Cale> I don't think you should be able to...
08:03:19 <nshepperd> lamefun: because permissions
08:03:40 <nshepperd> the names aren't really in scope, it's just permitting you to use them on the lhs
08:04:39 <roelof> I have this function and want to test it this way but I see error messages : http://lpaste.net/144462
08:04:50 <roelof> what am I doing wrong ? 
08:05:15 <Cale> https://www.haskell.org/onlinereport/syntax-iso.html
08:05:21 <Cale> lamefun: ^^
08:06:35 <Cale> lamefun: You'll see that the body of a class is a cdecls, and a cdecl is either gendecl or (funlhs | var) rhs, in this case, you'll likely be using the funlhs branch
08:07:15 <Cale> funlhs can be a bunch of stuff, but the only likely relevant one is the first,  var apat {apat}
08:07:53 <Cale> in particular, if you look at what var is, it's basically either an unqualified identifier or parenthesised operator
08:08:04 <Cale> var	->	varid | ( varsym )
08:08:23 <Cale> varid	->	(small {small | large | digit | ' })<reservedid>
08:08:25 <lamefun> Cale, "Can you use the names on the right hand side unqualified?" - no, but why do I need to import qualified if I don't need to use the methods RHS?
08:08:52 <Cale> lamefun: You literally cannot ever put a qualified name in the place where you're expecting to put one according to the syntax of the language
08:09:21 <lesh__> Hi I'm having an output issue
08:09:33 <Cale> There's no room in the syntax for qualified names on the left hand side of equations (except inside guards)
08:09:47 <srhb> lesh__: From your description, I will gueesss..... hSetBuffering!
08:09:49 <Cale> Oh, and I suppose in patterns
08:10:00 <Cale> the constructors may be qualified
08:10:03 <roelof> someone who can help me ? 
08:10:09 <lesh__> *Sudoku> putStr "\948" ***       Exception: <stdout>: hPutChar: invalid argument (invalid character)
08:10:19 <Cale> But the thing you're defining is never ever qualified
08:10:31 <lesh__> Any nonstandard character gives that error
08:10:37 <lpaste> jonashw pasted âcabal install (unsatisfied constraints)â at http://lpaste.net/144463
08:10:49 <lpaste> jonashw pasted âcabal install (unsatisfied constraints)â at http://lpaste.net/144464
08:10:59 <Cale> lesh__: import System.IO
08:10:59 <srhb> roelof: With what?
08:11:06 <Cale> lesh__: hGetEncoding stdout
08:11:10 <roelof> I have this function and want to test it this way but I see error messages : http://lpaste.net/144462
08:11:12 <Cale> lesh__: what does it say?
08:11:35 <lamefun> But is there a deep reason why I need to 'import qualified Class as C' for the 'instance Class Int' to work?
08:11:37 <Philonous> I'm trying to install double-conversion, but the install script complains about missing a missing libstdc++, but according to the package manager libstc++6 is installed. Any idea what I'm doing wrong? 
08:11:59 <lesh__> Just ANSI_X3.4-1968
08:12:03 <srhb> roelof: `(length . filter (== max) $ [x,y]))` is not an Integral a => a
08:12:07 <lesh__> Cale: ^
08:12:22 <srhb> roelof: Woops, sorry.
08:12:25 <srhb> roelof: Misread.
08:12:28 <Cale> lesh__: Yeah, that's why. Apparently \948 isn't a character in ANSI_X3.4-1968
08:12:39 <jophish> roelof: propMaxOccurs has been given the type (a -> a -> a) -> (a -> a -> a) -> Bool somewhere
08:12:43 <lesh__> My lecturer gave me a skeleton code to fill out
08:12:47 <Cale> (which is basically just another name for ASCII)
08:12:52 <lesh__> Which included this character â  among others
08:12:56 <lesh__> that's causing the issue
08:13:06 <lamefun> Because I never ever use anything from that qualified import yet when I delete it the code won't compile...
08:13:07 <Cale> (a minor variation on it)
08:13:07 <roelof> srhb:  can happen 
08:13:18 <nshepperd> lamefun: if you could use those names on the lhs without ever importing them by any method you would be able to write bad instances for types that shouldn't instances of certain classes
08:13:24 <jonashw> hey all... having trouble with a cabal package I'm working on... I added a dependency (HCodecs >= 0.5) and then used that library in some new code.  It works great when developing (the package installed) but I get an error when I run `cabal build`: "unsatisfied constraints".  See the result of `cabal install -v3` here: http://lpaste.net/144464.  How do I fix this?
08:13:28 <Cale> lesh__: The default encoding is set based on your system locale. Which OS are you using?
08:13:38 <roelof> jophish:  and how can I figure out ? 
08:13:51 <lesh__> Cale: ChromeOS with GNOME installed alongside it
08:13:55 <lesh__> I think its based off Ubuntu 12.04
08:13:59 <lamefun> nshepperd, for example?
08:14:06 <jophish> roelof: change the type declaraion of propMaxOccurs to Integer -> Integer -> Bool
08:14:15 <Cale> lesh__: It's pretty uncommon not to see "Just UTF-8" there on anything linux-like these days, but it's possible
08:14:27 <jophish> it's bound on line 35 of chapter_5.hs
08:14:48 <Cale> lesh__: what does  echo $LANG  tell you in the terminal before you load ghci?
08:14:58 <nshepperd> lamefun: I speak of classes that involve unsafe stuff like Typeable and, i dunno, type equality
08:15:09 <lesh__> Cale: Blank line :/
08:15:14 <emmanuel_erc> have any of you guys worked with the fgl library before?
08:15:39 <nshepperd> lamefun: i'm there are some good reasons to prevent instance-writing
08:16:12 <Cale> lesh__: try something like  export LANG=en_US.UTF-8
08:16:22 <Cale> and then load ghci and see if it's better
08:16:32 <srhb> roelof: Unless you've redefined max, you have an error in the definition of propMaxOccurs
08:16:38 <srhb> roelof: filter (== max)
08:16:39 <nshepperd> at least, to prevent you from writing such instances without importing Data.Stuff.Class.Internal
08:16:40 <srhb> :t max
08:16:41 <lambdabot> Ord a => a -> a -> a
08:16:53 <hexagoxel> jonashw: the output does not contain the error (?)
08:16:54 <nshepperd> which would export the relevant class methods
08:17:08 <Cale> lesh__: basically, your environment isn't telling ghci that unicode is okay to use, so it's being careful and only allowing ascii.
08:17:26 <jonashw> hexagoxel: last line ("Failed to install Bang-0.1.1.1")
08:17:38 <lesh__> Cale: well it doesn't quit now, but every unknown character is a questionmark
08:17:47 <lamefun> nshepperd, do you mean I can write instances for classes that don't export their functions?
08:18:24 <roelof> srhb:  you are right , the variable max is not filled with something
08:18:25 <Cale> lesh__: Okay, so also your terminal doesn't support unicode
08:18:32 <srhb> roelof: It also looks like you're simply inlining your definition of maxOccurs in propMaxOccurs, which makes the test useless.
08:18:35 <srhb> roelof: No, it is. It's a function
08:18:44 <srhb> > max 4 2
08:18:45 <lambdabot>  4
08:18:50 <srhb> roelof: Hence the problem.
08:19:00 <roelof> srhb:  exaclty
08:19:19 <Cale> lesh__: oh, try and force things by doing  hSetEncoding stdout utf8
08:19:22 <hexagoxel> jonashw: i do not understand. you say you get an error on `cabal build`, but you provide the output for `cabal install`? and the output does not contain "unsatisfied" even.
08:19:31 <Cale> lesh__: but it should already be UTF-8
08:19:56 <Cale> (you can check with hGetEncoding, if it says Just UTF-8, then that isn't the issue
08:19:56 <Cale> )
08:20:35 <Cale> lesh__: Which terminal is it?
08:20:38 <Cale> gnome-terminal?
08:20:44 <lesh__> Cale: Pantheon Terminal
08:20:46 <Cale> (that'd be a little surprising)
08:20:49 <Cale> hm
08:20:55 <lesh__> ill try gnome
08:21:05 <nshepperd> lamefun: yeah. at least with the current implementation, I imagine it's treated similarly to exclude a function on the export side vs the import side
08:21:30 <Cale> Surely that would support utf-8 characters, I'd expect
08:21:44 <Cale> But maybe it's misconfigured, or maybe I'm forgetting something which is required
08:21:49 <nshepperd> It's simplest to just say "permission = having the thing imported"
08:22:15 <Cale> oh, wow, maybe it doesn't
08:22:23 <Cale> Seems like people are complaining about that?
08:22:40 * roelof is giving up to make a test function which can test if the maxium is found on 2 integers and count how many times that value is used 
08:22:46 <lesh__> Cale:  Which should I use?
08:22:48 <srhb> roelof: But I still want to stress the point that even if you fix that issue, the test is worth nothing. You're essentially saying propFoo x = f x == f x
08:22:58 <Cale> lesh__: try gnome-terminal if you have it
08:23:22 <lesh__> Cale: Yeah it didn't work
08:23:26 <Cale> hmm
08:23:29 <srhb> roelof: If that were untrue, you'd have broken referential transparency.
08:23:30 <Cale> Yeah, maybe that's not it
08:24:09 <roelof> broken referential transparency 
08:24:11 <roelof> ?
08:24:24 <srhb> roelof: As in, substituting in the body of a function for its name gives you a different result.
08:24:27 <srhb> roelof: That Would Be Bad.
08:24:29 <lesh__> Cale: so as long as the code works for the lecturer, even if i see question marks, its ok right?
08:24:46 <Cale> lesh__: well, maybe :)
08:24:59 <Cale> lesh__: you might be seeing the wrong question marks :P
08:25:22 <srhb> roelof: More clearly, propFoo x = let f y = (2 + y) in 2 + x == f x
08:25:24 <Cale> oh!
08:25:40 <Cale> lesh__: apparently many terminals need to be *started* with that locale set in order to allow unicode
08:25:54 <roelof> srhb:  oke, then I stop with some Hunit tests  
08:26:23 <roelof> that one is already tell me that the function works with what I expected 
08:26:49 <lesh__> Cale: How would I do that
08:26:51 <Cale> lesh__: so maybe try adding  export LANG=en_US.UTF-8  (or whatever UTF-8 locale you want) in your .profile
08:27:17 <Cale> or perhaps there's some more appropriate way to set the locale in ChromeOS which I wouldn't know
08:27:34 <roelof> srhb:  again thanks 
08:27:38 <srhb> roelof: Sure thing.
08:28:06 <Cale> lesh__: and then log in again and see if it helps
08:28:07 <roelof> srhb:  so QuickTest is not such a handy tool 
08:28:16 <srhb> roelof: Yes it is. Just not for what you're using it for.
08:28:32 <Cale> lesh__: you should see echo $LANG say the right thing from when you start the terminal in the first place then.
08:28:42 <quicksilver> you can try to think of other properties which are not just copy-pasting hte implementaiotn, roelof 
08:28:51 <srhb> roelof: There is no need to try and "prove" (make plausible) referential transparency in Haskell -- it's a language feature. 
08:29:18 <quicksilver> for example you can check if passed the same number twice it returns 2 
08:29:25 <quicksilver> and that would maek a decent qc property
08:29:25 <roelof> oke, learning point , learn when to use QuickTest and when not. I think that is the purpose of the first exercises of this chapter 
08:29:28 <lesh__> OK Cale I'll do that
08:29:44 <lesh__> In the meantime, can you test the code to see if it works anyway?
08:29:49 <Cale> ok
08:29:56 <Cale> (if it's one file :P)
08:29:59 <lesh__> http://paste.ubuntu.com/13083255/ : just do ghci Sudoku, then type sudoku easy
08:30:51 <srhb> roelof: Nah, testing things comes way, way later.
08:30:57 <roelof> I can test if the highest number is not higher then all the parameters and I can check that the count is not higher then the number of parameters .Is that what you mean, srhb 
08:31:02 <srhb> roelof: (I say without checking the book at all, but it should!)
08:31:13 <Cale> yes, that appears to work
08:31:37 <roelof> srhb:  QuickCheck and Hunit are mentioned in chapter 4 
08:31:44 <roelof> very quick 
08:31:57 <srhb> roelof: I don't think that's what I mean, no. I mean that testing language properties is a waste of time, unless you're debugging GHC. :)
08:32:28 <lesh__> Cale: Cheers
08:32:43 <lesh__> I'll just ignore all these issues for now then since it will work anyway
08:32:49 <roelof> oke, I agree but the author says on every exercise , make tests to see if the code is  working 
08:32:50 <lesh__> Deadline is too soon to be faffing with UTF8
08:32:59 <lesh__> thanks very much, you've been very helpful :)
08:34:06 <srhb> roelof: Alright. I guess I just think the payoff is too low that early on. Do as you like, and follow quicksilvers advice for designing QC tests. :)
08:34:06 <Cale> lesh__: Well, when you do, let me know if it worked :)
08:34:47 <roelof> oke, and where can I find his advice ? srhb  
08:35:00 <srhb> roelof: Scroll up slightly. In this channel.
08:35:33 <roelof> oke, found it 
08:35:42 <roelof> oke, found it 
08:36:15 <roelof> I can test if the highest number is not higher then all the parameters and I can check that the count is not higher then the number of parameters . quicksilver 
08:37:22 <roelof> srhb:  thanks again 
08:39:09 <vev_> !help
08:39:26 <vev_> !help lamdabot
08:40:00 <ggole> @help
08:40:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:40:22 <srhb> vev_: You can chat privately to it, too.
08:40:39 <vev_> k ty
08:45:37 <roelof> quicksilver:  ping
08:45:46 <quicksilver> hello
08:45:54 <roelof> I can test if the highest number is not higher then all the parameters and I can check that the count is not higher then the number of parameters . quicksilver 
08:46:09 <roelof> is that what you meant 
08:46:13 <quicksilver> the number of parameters is 2
08:46:23 <quicksilver> that's not variable is it?
08:46:49 <roelof> nope, so the count can never be greater then 2 
08:46:57 <quicksilver> I meant test \x -> maxOccurs x x = (x,2)
08:47:12 <quicksilver> because you always get (x,2) if you suppoly the sama parameter twice
08:47:15 <quicksilver> irrespective of x
08:47:26 <quicksilver> and that's exactly what quickcheck does well (tries it for various x)
08:47:42 <quicksilver> soryy: == not = there.
08:47:45 <roelof> correct, if x /= y then you get a answer zero 
08:48:33 <roelof> and I can test if the max found is not greater then both parameters 
08:48:41 <srhb> roelof: Er.. What?
08:49:03 <srhb> roelof: Shouldn't the answer be 1 if x /= y ?
08:49:25 <srhb> Well, (x,1)
08:49:29 <roelof> sorry my fault, srhb  you are right 
08:49:40 <srhb> or (y,1) -- whichever
08:50:14 <quicksilver> you can test, perhaps, \x -> maxOccurs (x+1) x == (x+1,1)
08:50:19 <quicksilver> since x+1 is always greater than x
08:50:29 <quicksilver> and different from x
08:50:43 <roelof> oke, so 3 tests , one two xx which will make (x,2) , one x and y which will be (x,1) or (y,1) 
08:50:46 <quicksilver> if you test this on Double it may find counterexamples :)
08:50:54 <srhb> quicksilver: Or Int, even.
08:51:00 <roelof> he, I do not have to test the counter, it's already tested then 
08:51:07 <quicksilver> srhb: true :)
08:52:04 <roelof> thanks for the tip and the way of thinking . Still have to have a lot of practice to make this my own 
08:54:34 <roelof> srhb:  quicksilver  both thanks for the lesson 
08:57:11 <lostman> is there anyone around familiar with servant? I'm trying to use servant-client to write bindings to an API that uses OPTIONS HTTP method and it looks like servant doesn't support it. Is it possible to add new methods without hacking the internals?
08:57:34 <waressearcher2> is there haskell offtopic channel ?
08:57:54 <srhb> waressearcher2: #haskell-blah
08:58:09 <srhb> lostman: You may want to try #servant if you haven't already
08:58:34 <lostman> haven't yet! didn't know there's a separate channel
08:58:42 <srhb> lostman: And it's quite active, too. :)
08:59:45 <ttt_fff> at the current time, is https://wiki.haskell.org/Cloud_Haskell only distributed messaging or does it also handle (1) supervision trees and (2) error handling?
09:02:54 <obadz> I'm running a webserver using Network.Wai.Handler.Warp.run => are the various calls to my application potentially running on different threads?
09:04:10 <obadz> and the corrolary question: can I share state between my applications?
09:06:38 <obadz> well I'm sure I can, but what's the best way.. STM ?
09:06:49 <srhb> obadz: iirc each connection gets a new lightweight thread
09:07:08 <srhb> obadz: You can use any of the regular methods for sharing state between them. MVars, IOref, ...
09:07:51 <obadz> srhb: I see, thx
09:12:09 <__uu__> is there any opencv3 binding for haskell now? It seems hopencv and easyVision only support early version of opencv2
09:14:10 * hackagebot git-annex 5.20151102 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-5.20151102 (JoeyHess)
09:17:38 <obadz> should I be using ExceptT coming from Control.Monad.Except (mtl) or Control.Monad.Trans.Except (transformers)
09:18:13 <phadej> it's the same
09:18:28 <obadz> one has throwE but not the other
09:19:08 <phadej> obadz: mtl uses throwError from MonadError
09:19:40 <phadej> obadz: http://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-Error-Class.html#line-116
09:20:13 <obadz> is there a preferred way?
09:20:34 <jophish> I'm writing a package which wraps another (non-haskell) project
09:20:57 <jophish> This project uses major and minor versioning, and I'd like to represent this in my project's versions
09:22:01 <jophish> but if I dedicate the first two indices of my wrapper's version to be the wrapped projects version, I'm only left with minor versions for my project, which are typically used to represent non-breaking changes only
09:23:01 <jophish> Other packages such as llvm-general-pure seem to do it this way
09:24:25 <emmanuel_erc> have any of you guys worked with the fgl (Inductive Graph) package before?
09:24:51 <fizbin> Yes, I have.
09:25:03 <emmanuel_erc> cool
09:25:21 <emmanuel_erc> Can I ask you a question about it then?
09:25:56 <fizbin> Sure. Admittedly, I haven't used the "algorithms" subpackage. And within the past month or so I've gotten very annoyed at some performance-unfriendly code patterns that nothing warns you about.
09:26:34 <emmanuel_erc> Oh, I having a performance related issue. Hopefully, it can be resolved.
09:26:58 <fizbin> Ah! Okay, so here's the big things I've learned, performance-wise:
09:27:25 <fizbin> 1) Make sure you're using the PatriciaTree implementation of Gr.
09:27:37 <emmanuel_erc> ok
09:28:13 <fizbin> 2) If you're doing something over a large number of nodes or edges, by very wary of calling G.context (where "G" is Data.Graph.Inductive.Graph)
09:28:45 <fizbin> Many things call G.context behind your back - G.inn, G.outs, G.neighbors, etc.
09:29:01 <fizbin> G.succ is the thing I was calling in a loop.
09:29:03 <emmanuel_erc> I am calling buildGr
09:29:12 <fizbin> Repeatedly?
09:29:34 <emmanuel_erc> well I call it once with an input size of 1600 contexts
09:29:57 <emmanuel_erc> but I notice a huge performance dip as the garbage collector starts doing a lot of work.
09:33:07 <fizbin> emmanuel_erc: Is it feasible to rework your code so that you call G.mkGraph instead of buildGr ?
09:33:38 <emmanuel_erc> Yes it is. I am building a very simple graph
09:35:16 <fizbin> I strongly suspect that'll be much faster.
09:35:41 <emmanuel_erc> and I am assuming that mkGraph will call the correct implementation given the right type annotation.
09:35:43 <emmanuel_erc> ?
09:59:12 * hackagebot keera-hails-reactivelenses 0.0.0.1 - Haskell on Gtk rails - Lenses applied to Reactive Values  https://hackage.haskell.org/package/keera-hails-reactivelenses-0.0.0.1 (IvanPerez)
10:00:27 <Ankhers> There appears to be three Haskell positions in this months who's hiring on HN.
10:05:55 <danza> Ankhers, links?
10:07:04 <Ankhers> https://news.ycombinator.com/item?id=10492086 -- danza
10:08:00 <danza> Ankhers, thanks!
10:08:07 <Ankhers> danza: No problem.
10:10:51 <danza> wow that is an uncomfortable way to post job offers! do people keep appending job offers there the whole month?
10:12:36 <bbeachr> When using the Parsec library, is it generally considered better to parse whitespace as it comes, or to remove it before the parsing stage ?
10:12:51 <bbeachr> ie, going straight to syntax rather than tokenising first
10:17:11 <danza> bbeachr, i guess that it depends on whether space is meaningful or not in your language?
10:17:30 <bbeachr> AH, forgive me, The space is being ignored at all points
10:20:13 <fizbin> emmanuel_erc: sorry, got distracted by $WORK. Yes, mkGraph calls the correct implementation depending on the return type expected. This feature of Haskell - dispatch based on return type - is one of the hardest things to get used to with Haskell.
10:23:56 <fizbin> So you don't need to annotate the function that calls mkGraph to make it work only with PatriciaTree - you can annotate the thing that calls that, or the thing that calls that to be explicitly the PatriciaTree.Gr type.
10:25:05 <obadz> SomeMonadT Identity a is generally the same as SomeMonad a, right ?
10:26:03 <ReinH> obadz: usually
10:26:50 <Ankhers> danza: Not really. Usually only today. But a post like that happens every month.
10:28:02 <obadz> I have a typeclass who's member instances need to be able to read a Map, possibly return an Error and sometimes add 1 value to the hash map
10:28:09 <obadz> is it better to have this type signature:
10:28:54 <obadz> Monad m => a -> Map k v -> ExceptT String m (b, Maybe (k, v)) 
10:28:57 <obadz> or something like
10:29:18 <obadz> Monad m => a -> ExceptT String (ReaderT (Map k v) m) (b, Maybe (k, v)) 
10:29:56 <obadz> and should I try to use the MaybeT monad for the Maybe (k, v) part ?
10:30:42 <amf> is there a good way to represent do replicateM at least n times? i want to combine that with System.Timeout.timeout
10:31:58 <danza> Ankhers, great link! too bad that most require to be onsite ... the successful Haskell dev should do his/her career flying from Singapore to the States and then to Europe, in order to catch opportunities :D
10:32:00 <phadej> obadz: you don't want to use mtl typeclasses?
10:32:17 <obadz> phadej: first I hear of this. what are they?
10:33:03 <phadej> (MonadError String m, MonadReader (Map k v) m) => a -> (b, Maybe (k, v))
10:33:51 <obadz> shouldn't there be an m on the right ?
10:33:56 <Ankhers> danza: Only a couple months ago it was hard to find Haskell work. The number of jobs have been increasing. I'm sure the remote Haskell jobs will eventually start cropping up.
10:34:00 <phadej> obadz: yep
10:34:04 <obadz> I guess why not
10:34:12 <obadz> are they order dependent ?
10:34:19 <Ankhers> danza: I have seen a couple of them.
10:35:08 <obadz> phadej: but what is the concrete type of m going to be? a transformer stack ?
10:35:11 <danza> Ankhers, only a couple of months ago? Seriously? things are changing so quickly? that's great news! \o/
10:35:59 <Ankhers> danza: Instead of a couple months, lets say towards the beginning of the year. Either way, the number of available Haskell positions have been increasing.
10:36:22 <phadej> obadz: for example.
10:36:55 <obadz> phadej: so any monadtransformer type class that contains a ReaderT somewhere in the stack is all of the sudden a member of MonadReader ?
10:37:02 <phadej> obadz: or hand crafted monad
10:37:15 <phadej> obadz: or effect handler free monad magic
10:37:19 <phadej> or ...
10:37:20 <phadej> :)
10:37:45 <obadz> I'm sure the possibilities are limitless, but my brain has very concrete limits ;-)
10:38:32 <humanoyd> I have a function `(a -> b -> m c)` and two values `m a` and `m b`...what is the most elegant way to get `m c`?
10:39:57 <phadej> obadz: the point is that you could instantiate it with both of your functions
10:40:58 <phadej> or at least you have more possibilities
10:41:11 <glguy> humanoyd: do x <- ma; y <- mb; mc x y    -- There isn't a single function that does that
10:41:19 <glguy> that is defined in base, at least
10:41:29 <phadej> IIRC EitherT and ReaderT commute - for example
10:41:57 <zomg> humanoyd: if you can use a function (a -> b -> c) then you could use liftM2 to get m a -> m b -> m c
10:42:13 <humanoyd> glguy: Okay, thanks...that is what I'm doing...I just thought there would be something more applicative-ly like mc <$$> m a <*> m b
10:42:32 <phadej> join (f <$> ma <*> mb)
10:42:40 <humanoyd> zomg: yeah, thanks, unfortunately it's `a -> b -> m c`
10:43:11 <glguy> humanoyd: There's no way to define a generic operator like your <$$> to do this,
10:43:38 <glguy> You have to indicate that you're done at the "end" with something like join to do it that way
10:43:50 <glguy> and you end up with something messier than just using do
10:44:06 <obadz> phadej: I guess a custom monad makes sense
10:44:57 <phadej> glguy: imho, join isn't that messy. And e.g. for some monads it might matter (before ApplicativeDo)
10:45:33 <glguy> What might matter?
10:46:25 <mniip> hmm
10:46:37 <mniip> symbolic constructor names always start with : , right?
10:47:00 <phadej> glguy: if the expression has two binds or just one
10:47:32 <phadej> mniip: infix constructors, yes. : is like capital operator-character
10:47:40 <phadej> uppercase*
10:48:29 <glguy> phadej: If there was a performance difference between the two you'd need to know about it for that very specific monad instance
10:48:46 <glguy> but you wouldn't write the code like that in general
10:49:10 <glguy> the two expressions are the same up to the laws of the two classes
10:49:30 <phadej> they are same equationally, but don't need to be operationally
10:49:31 <mniip> trying to come up with a name the constructors of a length-indexed list
10:49:41 <humanoyd> phadej: glguy What we be `more idiomatic`? join or do?
10:49:45 <glguy> do
10:50:14 <mniip> ??? :: Vector 0 e
10:50:14 <mniip> ??? :: e -> Vector n e -> Vector (n + 1) e
10:50:29 <obadz> phadej: something like this: data MyMonad a = MyMonad (M.Map String String -> Either String (a, Maybe (String, String))) ?
10:50:29 <phadej> mniip: :::
10:50:55 <obadz> then I can implement Monad, MonadError and MonadReader
10:51:03 <phadej> obadz: use newtype, otherwise it will work.
10:51:15 <obadz> phadej: what's the advantage of newtype?
10:51:41 <phadej> obadz: Great question: http://stackoverflow.com/questions/5889696/difference-between-data-and-newtype-in-haskell
10:51:57 <humanoyd> thanks
10:52:17 <obadz> phadej: thanks
10:52:40 <obadz> phadej: sounds like mostly performance and a few sprinkles of strictness?
10:52:51 <phadej> glguy, humanoyd: i still find join version readable in this case. I'd judge whether i could come with good names for intermediate variables
10:53:33 <phadej> obadz: yes. But as you don't need additional box, is better not to have it
10:54:05 <phadej> obadz: in fact if you look how ReaderT, WriterT, and many other transformers are defined, they are newtypes
10:55:52 <phadej> obadz: I don't have personal preference, at some point big stacks get too complicated, and explicit function signature is easier to understand. On the other hand you loose GeneralizedNewtypeDeriving
10:56:44 <phadej> i.e. instances "for free"
10:57:16 <phadej> so for me mtl typeclasses are the rescue, as you could say "I want my monad to be able to do those things"
10:57:28 <phadej> and then worry later if I can actually build such monad :)
10:58:01 <phadej> maybe it's famous "over generalising". Maybe not.
11:00:32 <jophish> D: I want to write a quasiquoter taking a string which could contain |]
11:04:43 <ocramz> @lpaste
11:04:44 <lambdabot> Haskell pastebin: http://lpaste.net/
11:05:17 <lpaste> ocramz pasted âhiding a state updateâ at http://lpaste.net/144475
11:06:40 <ocramz> ^ is this correct? I have a `Vec` datastructure that's a synonym for a Storable, and would like to dereference it, create a modified copy, and copy this back into the Storable; problem is, other threads might use the pointer
11:06:58 <ocramz> (Vec is a distributed datastructure, shared over MPI)
11:07:37 <ocramz> so I hid the state update in a `runST`, which in turn is in a do block
11:07:41 <ocramz> is this sensible?
11:08:12 <maerwald> oh jesus, glib is still broken
11:08:16 <maerwald> since half a year or what
11:09:14 * hackagebot yesod-paginator 0.10.0 - A pagination approach for yesod  https://hackage.haskell.org/package/yesod-paginator-0.10.0 (PatrickBrisbin)
11:10:17 <CptnSandwich> how do i find what causes a "no match in record selector" error?
11:14:05 <maerwald> so, glib for gtk2 is broken... but you cannot switch to gtk3 and hope the newer glib will not screw up, because glade is not updated for gtk3
11:14:46 <aweinstock> ocramz: I might be missing something, but isn't (\f x -> runST $ do { s <- newSTRef x; writeSTRef s (f x); readSTRef s}) just equivalent to (\f x -> f x)
11:16:16 <Ankhers> CptnSandwich: I believe it is because you have a data type that is using records, where two different constructors share the same record name. You are using a record function on a constructor that does not have that record.
11:16:20 <ReinH> @src ($)
11:16:21 <lambdabot> f $ x = f x
11:16:51 <aweinstock> ocramz: and therefore, (modifyV v f = vecRestoreVector v =<< fmap f (vecGetVector v))
11:16:55 <CptnSandwich> Ankhers: So that might just be an import problem? It only happens at runtime
11:17:19 <ReinH> CptnSandwich: Are you using a sum type of records with fields?
11:17:44 <ReinH> e.g. data Foo = One { one :: Int } | Two { two :: Int }
11:17:45 <Ankhers> data Foo = Foo { func1 :: String, func2 :: String } | Bar { func1 :: String } -- CptnSandwich You are calling `func2` on a `Bar` here.
11:18:05 <infandum> I'm trying to figure out haskellr. How do you convert an R value to a Haskell value? So in H, x <- [r| 3 + 3 |] would give me an object in memory, but how do I convert that to :t x :: Double or whatnot so I can use it in haskell?
11:18:37 <CptnSandwich> Ankhers: i'll check.
11:21:12 <mniip> is there a finite number type indexed by typelits?
11:22:45 <Cale> infandum: I don't know anything about haskellr, but maybe if you told me the type of [r| 3 + 3 |], I could tell you
11:25:44 <infandum> Cale: I'm a afraid it's a bit more complicated than a normal conversion. It's a SomeSEXP Control.Memory.Region.G value
11:25:54 <Cale> infandum: oh, apparently there is something called hexp
11:25:58 <infandum> Cale: I know it has to do with hexp view patterns somehow, but nothing I tried worked
11:26:00 <infandum> yea
11:26:04 <Cale> which is supposed to let you do something like that
11:26:27 <infandum> I'm having trouble with that is the issue
11:26:36 <Cale> oh, you don't really need the view patterns
11:26:47 <Cale> You can just use a case expression if you like
11:26:49 <infandum> it's giving a type error with SEXP s a and the SomeSEXP Control.Memory.Region.G
11:27:08 <Cale> case hexp x of
11:28:30 <CptnSandwich> Ankhers: i think i found it. there is an algebraic data type in hinotify that sometimes has the field i am accessing and sometimes not. annoying
11:28:30 <infandum> Cale: Yeah, the case hexp x of isn't working either because of the type error
11:28:43 <Cale> er...
11:28:54 <infandum> expects SEXP s0 a0 but actually SomeSEXP Control.Memory.Region.G
11:28:57 <Cale> Well, it's really hard for me to help when I can't find the haddock documentation
11:29:01 <infandum> yeah same haha
11:29:10 <infandum> they refer to it but it seems to be missing
11:29:16 * hackagebot cereal 0.5.0.0 - A binary serialization library  https://hackage.haskell.org/package/cereal-0.5.0.0 (TrevorElliott)
11:29:27 <infandum> which is a shame because the library has SO MUCH POTENTIAL
11:30:05 <infandum> I can get everything to work from Haskell -> R, but now R -> Haskell which kinda ruins the point--I would just be using R the whole time then
11:31:25 <eze> I am looking foward to participate in GSoC 2016 and I would like to get involve in some project under the umbrella of haskell.org. Is any posible mentor online?
11:34:15 * hackagebot tld 0.2.0.0 - This project separates subdomains, domains, and top-level-domains from URLs.  https://hackage.haskell.org/package/tld-0.2.0.0 (jp_rider)
11:36:03 <Zakkor> Hey there. Trying to set up emacs for haskell development, I installed haskell-mode and ghc-mod, but ghc-mod just won't work. When i run M-x ghc-debug it says "Autoloading failed to define funciton ghc-debug". any ideas?
11:37:29 <Zakkor> also, here's my init.el: http://lpaste.net/144476
11:40:46 <maerwald> anyone able to install glib or gtk2hs?
11:40:49 <tekkkz> Hello!
11:44:40 <tekkkz> Can someone help:  i want to crawl an url of a website. for that im using tagsoup but i dont know how to extract the url of the a tag. I mean i got it already but how to gfets its url now? if anyone wants to help say so i give some more info
11:44:58 <mniip> is there a finite number type indexed by typelits?
11:45:15 <Zemyla> Is there a way I can have a top-level ByteArray whose input is preinitialized? Like how, in C, you can create an initialized array just by saying const int x[] = {1, 2, 3}?
11:45:38 <mniip> Zemyla, ByteArray# ?
11:45:53 <Zemyla> mniip: Yes, but you have to load the data in programatically.
11:46:25 <Zemyla> I want something where the data comes from, like, a DATA segment in the final executable.
11:47:47 <tekkkz> How to get the href url out of that: https://bpaste.net/show/c6abb7342fd6
11:48:53 <Ankhers> :t lookup -- tekkkz 
11:48:55 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
11:49:02 <Ankhers> Might be helpful.
11:49:23 <Ankhers> I don't know if there is something built into tagsoup.
11:50:01 <tekkkz> Ankhers, i dont understand your solution,im new, so waht must i do?
11:50:42 <CptnSandwich> Ankhers: boy, what a shit library. thanks for your help
11:51:16 <Ankhers> tekkkz: You have a list of tags. I'm assuming you want to only look at the ones that are anchor tags. You can use a filter to accomplish that. Then, you will have a list of anchor tags that you can go through and turn into href values.
11:51:43 <Ankhers> CptnSandwich: I was confused for a moment. I thought I suggested a bad library to you.
11:51:50 <tekkkz> ahh yaya
11:52:29 <Ankhers> > lookup "href" [("href", "/path/to/whatever"),("div", "something")]
11:52:30 <lambdabot>  Just "/path/to/whatever"
11:52:45 <Ankhers> :t filter
11:52:46 <CptnSandwich> Ankhers: no no, hinotify just has a very weird API, but I somehow made it work with conduit :)
11:52:46 <lambdabot> (a -> Bool) -> [a] -> [a]
11:53:02 <Ankhers> > filter even [1,2,3,4,5]
11:53:04 <lambdabot>  [2,4]
11:53:14 <Ankhers> tekkkz: Do you understand that basic idea?
11:53:17 <mniip> Zemyla, let's see
11:53:18 <aweinstock> Zemyla: there's probably a way to hack it together with template haskell, FFI mmap, and linker scripts
11:53:30 <Ankhers> CptnSandwich: Good to hear.
11:53:48 <tekkkz> Ankhers, i think so
11:54:13 <Ankhers> tekkkz: Cool. Give it a shot to see if you can get it working. Feel free to ask more questions if you cannot get it.
11:56:46 <jdreaver> Hey, if I create a bunch of lenses automatically using makeFields'', is there a way to document the resulting lenses using Haddocks?
11:57:10 <mniip> Zemyla, the closest I got is for it to allocate an array and fill it up in one cmm block
11:57:19 <aweinstock> Zemyla: how close to what you want does OverloadedStrings + strict bytestrings get you?
11:57:31 <jdreaver> Put another way, is there a way to use Haddock to document auto-generated functions from Template Haskell?
11:58:38 <mniip> Zemyla, oh of course
11:59:02 <mniip> > :t "hello"#
11:59:02 <mniip> Addr#
11:59:03 <lambdabot>  <hint>:1:1: parse error on input â:â
12:02:37 <roelof> what do your experts think of http://lpaste.net/144473 
12:02:42 <jdreaver> Actually, I think this ticket implies I can't: https://ghc.haskell.org/trac/ghc/ticket/5467
12:03:47 <aweinstock> mniip: with ("foo"# :: Addr#), what are the contents of the memory locations if there are unicode characters in the string literal? or is that just not allowed?
12:03:59 <mniip> hold on I need to check where is the string
12:04:39 <mniip> (gdb) info symbol 0x48ac60
12:04:39 <mniip> _IO_stdin_used in section .rodata
12:05:24 <mniip> oops
12:05:37 <mniip> 8 bytes later
12:05:43 <mniip> c2Sz_str in section .rodata
12:06:47 <mniip> aweinstock,     primitive string literal must contain only characters <= '\xFF'
12:06:51 <mniip> quoth ghc
12:08:23 <aweinstock> > let x = Addr "hello"# in mapM (\i -> chr . fromIntegral <$> (readOffAddr x i :: IO Word8)) [0..5]
12:08:25 <lambdabot>  Not in scope: data constructor âAddrâNot in scope: âreadOffAddrâ
12:10:15 <tekkkz> how to use tagsoup's fromAttrib to get the first href of this https://bpaste.net/show/c6abb7342fd6
12:10:16 <tekkkz> ?
12:11:09 <orion> Is network-simple generally less performant than doing things manually?
12:16:25 <roelof> Nobody who wants to look if my tests are allright or if I forget something in the tests ? http://lpaste.net/144473 
12:19:17 * hackagebot haskell-gi-base 0.8 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.8 (inaki)
12:24:17 * hackagebot haskell-gi 0.8 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.8 (inaki)
12:26:18 <tetek> hi, I wrote my first script in haskell, credit card validation, can someone take a look and check what could be done better? https://gist.github.com/tetek/a69c2dc4ea48c3a0f822
12:31:01 <Ankhers> tetek: Was this done for CIS194?
12:31:07 <aweinstock> tetek: divMod gives both div and mod at once
12:31:28 <aweinstock> > 123 `divMod` 10
12:31:29 <lambdabot>  (12,3)
12:31:33 <cite-reader> tetek: I'm pretty sure foldr (++) [] = concat, which I think would be more clear.
12:31:54 <tetek> @Ankhers yes, but I'm not the student there
12:31:54 <lambdabot> Unknown command, try @list
12:31:58 <nkaretnikov> what's a proper way to create a value of type Ptr?
12:32:04 <aweinstock> :t [sum . sum, sum . concat]
12:32:05 <lambdabot> (Num c, Num [c], Foldable t) => [t [c] -> c]
12:32:10 <nkaretnikov> e.g., if i need to read from a particular Address
12:32:26 <nkaretnikov> Addr# lacks a value constructor
12:32:35 <aweinstock> cite-reader: I'm fairly sure (sum . sum) and (sum . concat) do the same thing, and (sum . sum) does it more efficiently
12:32:53 <cite-reader> Good point.
12:33:01 <tetek> @cite-reader thx @aweinstock thx
12:33:01 <lambdabot> Unknown command, try @list
12:33:46 <aweinstock> also using (++ [b]) to append at the end of a list is inefficient (an O(n) copy)
12:34:17 * hackagebot gi-glib 0.2.44.8 - GLib bindings  https://hackage.haskell.org/package/gi-glib-0.2.44.8 (inaki)
12:34:19 <aweinstock> :t (`divMod` 10)
12:34:20 * hackagebot gi-atk 0.2.16.8 - Atk bindings  https://hackage.haskell.org/package/gi-atk-0.2.16.8 (inaki)
12:34:21 <lambdabot> Integral a => a -> (a, a)
12:34:34 <tetek> aweinstock so what's the other way?
12:34:53 <aweinstock> probably something with foldr and (:), but I'm still thinking it through
12:36:10 <tetek> btw I think I could have wrote "toDigitsRev = reverse . toDigits" instead of toDigitsRev a = reverse $ toDigits a
12:36:27 <Ankhers> tetek: Indeed you can.
12:36:36 <aweinstock> > let toDigits a = let (c,b) = a `divMod` 10 in toDigits c ++ [b] in toDigits 12345678
12:36:38 <lambdabot>  *Exception: stack overflow
12:37:04 <aweinstock> > let toDigits a = let (c,b) = a `divMod` 10 in toDigits c ++ [b] in take 10 $ toDigits 12345678
12:37:06 <lambdabot>  *Exception: stack overflow
12:37:39 <aweinstock> yeah, that doesn't even run as is (it's missing a check for c == 0, I think)
12:37:58 <aweinstock> > let toDigits a = let (c,b) = a `divMod` 10 in if c == 0 then [] else toDigits c ++ [b] in toDigits 12345678
12:38:00 <lambdabot>  [2,3,4,5,6,7,8]
12:38:41 <aweinstock> > let toDigits a = let (c,b) = a `divMod` 10 in (if c == 0 then [] else toDigits c) ++ [b] in toDigits 12345678
12:38:43 <lambdabot>  [1,2,3,4,5,6,7,8]
12:40:06 <mniip> what are the recommended settings for tabulation in vim when working with haskell?
12:40:35 <mniip> I mean less obvious ones like sw, ts, and sts?
12:43:38 <maerwald> gio-0.13.1.0 failed during the configure step. The exception was: ExitFailure (-11) <- such a useful error message
12:43:42 <kadoban> mniip: I have all of those set to 4, and expandtab set. You can probably go less than 4, I dunno. I've seen 2 before.
12:45:26 <emmanuel_erc> hey there haskellIRC
12:45:42 <emmanuel_erc> I think I have a space leak and this is my first tim debugging one.
12:45:51 <emmanuel_erc> Could you lend a helping hand?
12:46:51 * roelof gets the feeling he is ignored 
12:46:54 <maerwald> haskell gui libraries are really in terrible shape
12:47:18 <emmanuel_erc> roelof, are you talking about yourself?
12:47:47 <emmanuel_erc> (I'm sorry if that seems like a strange question...)
12:48:19 <emmanuel_erc> how so maerwald?
12:48:21 <roelof> no, about the channel. I ask several times a question but no answer , emmanuel_erc 
12:48:40 <maerwald> emmanuel_erc: half of them need hacks to build, then half of the rest still doesn't build
12:49:15 <emmanuel_erc> ah, I've only messed around with Chart (which doesn't really count I guess). I wouldn't really know at this point.
12:49:21 <Jello_Raptor> hmm, I keep on finding myself in situations where I have some ADT (think the AST for a language, or a binary tree type) and I want to instrument every node in that structure with some additional data (like file and line number for the construct, or current depth in the tree respectively). I keep on having to define the type with the extra parameter, and possibly a newtype with an appropriate functor instance. Is there a better way 
12:49:21 <Jello_Raptor> to do this? 
12:49:23 <tetek> cite-reader aweinstock, thanks for advices, updated code: https://gist.github.com/tetek/a69c2dc4ea48c3a0f822  (sum . sum) wouldn't compile wheras sum . concat works 
12:49:41 <maerwald> emmanuel_erc: and the cabal error message is completely useless, as always
12:50:18 * hackagebot gi-cairo 0.1.14.8 - cairo bindings  https://hackage.haskell.org/package/gi-cairo-0.1.14.8 (inaki)
12:50:19 * hackagebot gi-gdk 0.3.16.8 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-0.3.16.8 (inaki)
12:50:21 * hackagebot gi-gdkpixbuf 0.2.31.8 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-0.2.31.8 (inaki)
12:50:23 * hackagebot gi-gio 0.2.44.8 - Gio bindings  https://hackage.haskell.org/package/gi-gio-0.2.44.8 (inaki)
12:50:26 * hackagebot gi-gobject 0.2.44.8 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-0.2.44.8 (inaki)
12:50:48 <ryantrinkle> does anyone know if it's OK to use the TemplateHaskell extension on ARM, as long as you don't use any splices?
12:51:04 <lpaste> emmanuel_erc pasted âPotetial Space Leak (selectK, selects K neighbors, and has been tested)â at http://lpaste.net/144477
12:51:43 <emmanuel_erc> (BRB)
12:52:02 <emmanuel_erc> nvm
12:52:03 <emmanuel_erc> back
12:52:23 <kazagistar> roelof: last time I see you in the chat log you had a conversation of some kind?
12:53:26 <roelof> nope, I asked several times to give feedback on a code.  
12:53:33 <hexagoxel> maerwald: have you applied the -j1 trick to get better error messages?
12:53:44 <mgsloan> ryantrinkle: Hey! Not sure, but if that turns out to not work, you can put the LANGUAGE pragma in a CPP #if (but the CPP LANGUAGE pragma must come before it) 
12:53:45 <aweinstock> tetek: toDigitsRev a = b : if c == 0 then [] else toDigits c where (c,b) = a `divMod` 10; toDigits = reverse . toDigitsRev
12:54:01 <emmanuel_erc> You have to have good timing roelof.
12:54:05 <emmanuel_erc> At least that is what I have found.
12:54:27 <maerwald> hexagoxel: that doesn't add any useful error messages
12:54:37 <aweinstock> err, toDigitsRev a = b : if c == 0 then [] else toDigitsRev c where (c,b) = a `divMod` 10
12:54:39 <maerwald> it's the same nonsensival "ExitFailure (-11)"
12:54:46 <roelof> I asked about 3 quarters ago on this channel 
12:54:52 <ryantrinkle> mgsloan: that makes sense; i'm just trying to ensure that reflex works on ARM, and i think it *should*, but i'd rather not refactor my quoted expressions into raw AppE VarE, etc. if i can avoid it :)
12:55:08 <kazagistar> Jello_Raptor: you can make the annotated type a "wrapper" for your data type. Or go down the rabbit hole and use something like Fix
12:55:14 <emmanuel_erc> roelof: What counts as a "quarter" of time?
12:55:22 <roelof> 15 minutes 
12:55:27 <emmanuel_erc> I see
12:55:28 * hackagebot gi-gtk 0.3.16.8 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-0.3.16.8 (inaki)
12:55:29 * hackagebot gi-javascriptcore 0.2.4.8 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-0.2.4.8 (inaki)
12:55:31 * hackagebot gi-notify 0.2.31.8 - Notify bindings  https://hackage.haskell.org/package/gi-notify-0.2.31.8 (inaki)
12:55:34 * hackagebot gi-pango 0.1.36.8 - Pango bindings  https://hackage.haskell.org/package/gi-pango-0.1.36.8 (inaki)
12:55:36 * hackagebot gi-soup 0.2.50.8 - Soup bindings  https://hackage.haskell.org/package/gi-soup-0.2.50.8 (inaki)
12:55:43 <emmanuel_erc> does anyone mind taking a look at the code I just pasted.
12:55:54 <emmanuel_erc> (I  try to keep my pastes relatively small.)
12:56:04 <aweinstock> tetek: also, try replacing concat with (map sum)
12:56:40 <roelof> emmanuel_erc:  oke, but it was a big exercise. so sorry for the big past 
12:56:41 <tetek> ok, thanks for help!
12:57:07 <emmanuel_erc> roelof: How about this. let me take a look at your last paste
12:57:26 <emmanuel_erc> maybe I can say something useful.
12:57:36 <roelof> emmanuel_erc:  that would be fine 
12:58:08 <emmanuel_erc> Is this it? http://lpaste.net/144473
12:58:35 <emmanuel_erc> So what are you asking about?
12:59:20 <roelof> emmanuel_erc:  yep, that is the right paste
13:00:38 * hackagebot gi-vte 0.0.40.8 - Vte bindings  https://hackage.haskell.org/package/gi-vte-0.0.40.8 (inaki)
13:00:40 * hackagebot gi-webkit 0.2.4.8 - WebKit bindings  https://hackage.haskell.org/package/gi-webkit-0.2.4.8 (inaki)
13:00:42 * hackagebot haskell-gi-base 0.9 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.9 (inaki)
13:00:44 * hackagebot haskell-gi 0.9 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.9 (inaki)
13:01:32 <emmanuel_erc> roelof: I don't know what I should be looking for.
13:02:25 <maerwald> deployment is what breaks the fun of haskell, really
13:04:00 <sternenseemann> is there binary number notation in haskell?
13:04:10 <sternenseemann> 0b1001011 seems not to work :(
13:04:20 <monochrom> no, there isn't
13:05:06 <sternenseemann> monochrom: okay, meh.
13:05:25 <monochrom> a bit unfortunate
13:05:31 <kazagistar> sternenseemann: the best option is probably { binary "1001011" }. Yes, its runtime, but you only pay the cost once per literal.
13:05:35 <dolio> I thought someone was implementing it.
13:05:39 * hackagebot gi-glib 0.2.44.9 - GLib bindings  https://hackage.haskell.org/package/gi-glib-0.2.44.9 (inaki)
13:05:41 * hackagebot gi-atk 0.2.16.9 - Atk bindings  https://hackage.haskell.org/package/gi-atk-0.2.16.9 (inaki)
13:05:43 * hackagebot smsaero 0.4 - SMSAero API and HTTP client based on servant library.  https://hackage.haskell.org/package/smsaero-0.4 (NickolayKudasov)
13:06:17 <monochrom> bring out the big hammer and go template-haskell :)
13:07:07 <sleblanc> kazagistar, since it's a constant, can't it be optimized-out at compile time?
13:07:26 <dolio> It's in GHC 7.10.
13:07:30 <dolio> -XBinaryLiterals
13:07:37 <monochrom> w00t nice
13:10:33 <kazagistar> sleblanc: possibly, but I assume the compiler can only do so much "evaluating arbitrary expressions at compile time" since it needs to be careful around non-termination and such
13:10:59 <roelof> emmanuel_erc:  is it good code, could i make more tests ?
13:11:09 <kazagistar> but I'm certainly no GHC expert
13:13:53 <emmanuel_erc> roelof: Why are you writing this code?
13:15:01 <hexagoxel> maerwald: and the verbose output? what system is this on?
13:15:09 <Jello_Raptor> kazagistar: how would Fix help me? convert "Expr = Val Int | Plus Expr Expr" into "Expr e = Val Int | Plus e e" with "fix Expr" for the normal version and (i have no idea how to actually express this) "data AExpr a = AExpr a (Expr (AExpr a))" for the augmented version? 
13:15:35 <maerwald> hexagoxel: I already tried verbose output, it fails during linking stage without further messages
13:16:56 <maerwald> I already have one gtk project I only try to build once a year, because of the pain it involves
13:17:24 <maerwald> I guess I really should give up on GUI programming in haskell
13:18:12 <Ankhers> maerwald: Have you tried using stack instead of cabal? (I'm sorry if this has already been mentioned)
13:18:13 <sleblanc> kazagistar, in compiler theory, constant folding is the first 
13:18:21 <maerwald> Ankhers: yes, stack made it worse
13:18:38 <Ankhers> weird.
13:18:49 <maerwald> using stack I cannot build my project _anywhere_ ...with cabal sandboxes, I can build it 1 out of 10 times
13:19:02 <Ankhers> Let me take a quick look at my scrollback. I recently played with the haskell GTK bindings.
13:19:04 <sleblanc> kazagistar, (cont'd) operation that is usually performed, as it easy to perform, safe, and usually gives a (slight) performance benefit
13:19:58 <kazagistar> sleblanc: fair enough. but the binary function is gunna have a loop inside it, which if I made a mistake, could be non-terminating
13:19:59 <mgsloan> maerwald: Well at least it's deterministic ;)
13:20:11 <sleblanc> kazagistar, I'd assume there's a way to signal to the compiler that the "binary" function can be optimized out, but I am no expert either
13:20:16 <sleblanc> kazagistar, that's right
13:21:04 <Ankhers> maerwald: I'm not really seeing much information. Aside from useless errors. I'm going to assume you have gtk3 installed on your machine?
13:21:06 <sleblanc> kazagistar, but a hard-coded string is deterministic, therefore if you can prove that the function will return on fixed-length string, you are allowed to perform such an optimization without affecting the result of the operation
13:21:11 * hackagebot gi-gobject 0.2.44.9 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-0.2.44.9 (inaki)
13:21:13 * hackagebot gi-javascriptcore 0.2.4.9 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-0.2.4.9 (inaki)
13:21:15 * hackagebot gi-cairo 0.1.14.9 - cairo bindings  https://hackage.haskell.org/package/gi-cairo-0.1.14.9 (inaki)
13:21:17 * hackagebot gi-gdk 0.3.16.9 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-0.3.16.9 (inaki)
13:21:19 * hackagebot gi-gdkpixbuf 0.2.31.9 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-0.2.31.9 (inaki)
13:21:51 <maerwald> version constraints to make stuff build have to be INSIDE the package cabal definition (everything else is a build system bug), not be implicit in some stack bundle
13:22:23 <sleblanc> kazagistar, do you know what module provides the "binary" function?
13:22:37 <maerwald> Ankhers: I'm not seeing more information than you do, it's just "ExitFailure (-11)"
13:22:43 <mgsloan> maerwald: That is how stack works too, stack checks version constraints
13:23:12 <kazagistar> sleblanc: there isn't one, I made it up as pseudocode. In any case, it is "user provided" and would have no special treatment from the compiler
13:23:28 <maerwald> mgsloan: it doesn't necessarily improve the library ecosystem if stuff only builds if I use a stack bundle. This is a problem of library maintainers not properly checking their dependencies
13:23:34 <roelof> emmanuel_erc:  because it was a exercise of the craft of functional programming 
13:23:49 <Ankhers> maerwald: But do you have the gtk3 C library installed on your machine?
13:23:54 <maerwald> sure
13:23:56 <sphinxo> Hi, i'm new to haskell and i'm trying to solve something that I don't know how to describe.  
13:24:00 <sleblanc> kazagistar, oh! sorry, for a moment I thought there were such a function! My bad
13:24:31 <sphinxo> I'm writing a Bf interpreter and the part of code that I need help with is here http://lpaste.net/144481
13:25:12 <Ankhers> maerwald: I'm going to assume that was to my question, and it means yes.
13:25:15 <sphinxo> Also it would be nice to know what the question I should of asked was
13:25:44 <kadoban> sphinxo: What's the question on that code?
13:25:55 <kazagistar> Jello_Raptor: Annotated a = Anno Data a; AExpr a = Annotated (Expr a); FExpr = Fix AExpr;
13:26:07 <Ankhers> maerwald: When you try to install the gtk3 haskell library is when you are getting the ExitCode -11?
13:26:21 * hackagebot sdl2-compositor 1.2 - image compositing with sdl2 - declarative style  https://hackage.haskell.org/package/sdl2-compositor-1.2 (seppeljordan)
13:26:22 <Ankhers> maerwald: What OS are you on?
13:26:23 * hackagebot gi-gio 0.2.44.9 - Gio bindings  https://hackage.haskell.org/package/gi-gio-0.2.44.9 (inaki)
13:26:25 * hackagebot gi-gtk 0.3.16.9 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-0.3.16.9 (inaki)
13:26:27 * hackagebot gi-pango 0.1.36.9 - Pango bindings  https://hackage.haskell.org/package/gi-pango-0.1.36.9 (inaki)
13:26:29 * hackagebot gi-notify 0.2.31.9 - Notify bindings  https://hackage.haskell.org/package/gi-notify-0.2.31.9 (inaki)
13:26:36 <sphinxo> Well It is not working because i'm passing an Instruction type where I should be parsing [Instruction]
13:27:33 <kadoban> Ah, indeed.
13:27:58 <sphinxo> s/parsing/passing
13:27:59 <bergey> sphinxo: I have two thoughts.  The first is you don't need IO in eval', and the next change will be easier if you first remove IO from the type, and remove return from the values.
13:28:10 <maerwald> Ankhers: linux. And it already happens for gtk3 dependencies such as gio/cairo/glib
13:28:14 <kadoban> sphinxo: Is IO actually going to be used at some point? Currently it's not.
13:29:05 <sphinxo> hmm
13:29:30 <sphinxo> ahh yes :)
13:30:10 <sphinxo> Now that i've done that how do I get it to work?
13:30:11 <bergey> The second is what you just said - you need to call eval' repeatedly with the next instruction and the Tape from previous call.  I'd use the foldl function.  You may need to change the order of arguments to eval'.
13:30:18 <sphinxo> Ahh ok
13:30:51 <Ankhers> maerwald: Do you have the dev headers installed as well? On Ubuntu, that would be libgtk-3-dev
13:30:59 <bergey> Ask again if you have trouble figuring out foldl. =)
13:31:26 <sphinxo> Ok thanks bergey
13:31:31 * hackagebot gi-soup 0.2.50.9 - Soup bindings  https://hackage.haskell.org/package/gi-soup-0.2.50.9 (inaki)
13:31:33 * hackagebot gi-vte 0.0.40.9 - Vte bindings  https://hackage.haskell.org/package/gi-vte-0.0.40.9 (inaki)
13:31:35 * hackagebot gi-webkit 0.2.4.9 - WebKit bindings  https://hackage.haskell.org/package/gi-webkit-0.2.4.9 (inaki)
13:33:00 <roelof> emmanuel_erc:  still here and seen my last answer to your question ?
13:33:25 <maerwald> Ankhers: I don't use binary distros
13:33:36 <maerwald> so the haders are _always_ installed
13:36:26 <Ankhers> maerwald: It may be worth posting something on the projects ticket tracker.
13:36:37 <roelof> maerwald:  which distro do you use then ?
13:37:29 <Ankhers> maerwald: Unfortunately I am not overly familiar with the project. I'm just making guesses. Someone more involved in the project should be able to help.
13:37:31 <maerwald> I'll rather just stop using haskell gtk bindings and tell people to do the same. It's not really the first time the whole depgraph breaks.
13:40:27 <sphinxo> bergey: I seem to struggling with foldl, this is what I have so far
13:40:30 <sphinxo> foldl eval' (repeat 0, 0, repeat 0) instructions 
13:41:21 <dibblego> @google explain list folds to yourself
13:41:22 <lambdabot> http://functionaltalks.org/2013/06/19/tony-morris-explain-list-folds-to-yourself/
13:41:23 <lambdabot> Title: Tony Morris: Explain List Folds to Yourself â FunctionalTalks.org
13:42:15 <reducedleft> dibblego: that article is pure gold
13:42:32 <eze> I am looking foward to participate in GSoC 2016 and I would like to get involved in some project under the umbrella of haskell.org. Is any posible mentor online or project sugestion?
13:42:46 <sphinxo> thanks dibblego 
13:42:47 <reducedleft> referring to your twitter post
13:43:07 <reducedleft> your list folds video is also gold (not sarcasticly) :D
13:43:27 <bergey> sphinxo: Looks good so far.  foldl expects a function whose first argument is the same type as its result.
13:45:12 <sphinxo> it seems to be erroring
13:45:31 <sphinxo> http://lpaste.net/144484
13:45:50 <sphinxo> Have I got the type annotation wrong?
13:46:14 <sphinxo> hmm
13:47:30 <sphinxo> this is the current version: http://lpaste.net/144485
13:47:54 <sphinxo> I think it's the fact that eval' takes an instruction followed by the tape
13:48:20 <sphinxo> I think i've got
13:48:22 <sphinxo> it
13:48:49 <kadoban> sphinxo: foldl is :: (b -> a -> b) -> â¦     eval' is a -> b -> b
13:49:25 <rhz> I'm having lots of problems trying to read in a file containing unicode characters. What is the recommended way to do this?
13:50:07 <shachaf> To read a file? Maybe something like readFile.
13:50:39 <rhz> tried that but got this hGetContents: invalid argument (invalid byte sequence)
13:51:03 <cite-reader> Ah, an encoding problem.
13:51:08 <sphinxo> Could someone give me some feedback on this? http://lpaste.net/144487
13:51:09 <kadoban> rhz: What are "unicode characters" in a file? What encoding is it in?
13:51:27 <cite-reader> I suggest prayer, followed by a good hard look at Data.Text.Encoding.
13:52:52 <rhz> I don't know what encoding it is. It has non ASCII characters like this Ã¼
13:53:14 <kadoban> rhz: If you don't know, how could your code possibly figure it out?
13:53:29 <rhz> It's either UTF8 or UTF16
13:53:34 <Axman6> reading it in as a bytestring then trying to convert it to Text using Data.Text.Encoding is the best way to go
13:53:52 <glguy> Figure out what encoding it is and then you can read it using that encoding
13:54:08 <glguy> Handles support various encodings and other libraries like 'text' can, too
13:54:18 <monochrom> rhz: is it possible to post the file somewhere so other people can analyze it for encoding?
13:54:29 <Axman6> rhz: also, try running `file` on the file to find out its encoding
13:54:36 <Lantern_O_jack> rhz: you can use chardet(1)
13:55:00 <rhz> ISO-8859 English text
13:55:29 <monochrom> then that's possibly iso-latin-1 aka iso-8859-1
13:55:55 <cite-reader> OR, it might be CP-1252, depending on whether that tool thinks those encodings are the same or not.
13:55:57 <AbelianGrape> If I'm using DataKinds and I have a kind e.g. "data Foo = A | B | C", is there a function of the type "demote :: Proxy (a :: Foo) -> (Foo :: *)"?
13:56:29 <glguy> System.IO has hSetEncoding and latin1 in it
13:56:30 * hackagebot sdl2-compositor 1.2.0.1 - image compositing with sdl2 - declarative style  https://hackage.haskell.org/package/sdl2-compositor-1.2.0.1 (seppeljordan)
13:56:35 <monochrom> yeah, encoding-guessing is a heuristic guessing game. you will never be sure, unless the author swears on it
13:57:21 <monochrom> there is no such thing as "the file itself determines its encoding"
13:57:27 <AbelianGrape> I guess I can just write a typeclass, but this seems like something people might want to do 
13:57:41 <cite-reader> And depending on where the file came from, it might have been accidentally processed as raw bytes and doesn't actually make sense as any single encoding. Fun!
13:58:03 <cite-reader> (This was the worst part of working in a PHP shop and I don't miss it.)
13:59:34 <rhz> cool got it now. thanks
14:00:48 <monochrom> to some extent, the unix philosophy blew it. before unix, other OSes attached much metadata to files. the unix creators instead boasted of their simply philosophy "a file is just a sequence of bytes, no metadata". (recall that even filenames are attached to something else rather than to the files.)
14:01:32 <monochrom> the downside is that now you don't have a metadata place to remember "this file uses Atari's 1980s encoding"
14:04:19 <orion> I'm using aeson-pipes and friends to decode JSON over a raw TCP socket. How do I prevent an attack where the adversary does something like: {"foo": "xxxxxx.... <-- where they send hundreds of MB of text?
14:04:56 <ttt_fff> orion: you can put a layer in front of it, say elixir; which parses the json, makes sure it's of the correct ize, then pass it to haskell
14:05:01 <AbelianGrape> orion: do you manually read from the socket, or does aeson-pipes abstract that away?
14:05:10 <orion> AbelianGrape: The latter.
14:05:28 <orion> It's actually pipes-network reading from the socket.
14:05:43 <frerich> dibblego: That's a very nice talk, thanks for the link! Earlier today I tried to convince a Java-minded colleague of the beauty of fold/reduce/accumulate, explaining how it can be the base of an amazing range of seemingly unrelated functions. I'd forward your video to him. :-)
14:06:26 <AbelianGrape> orion: Hmm. Do you ever call e.g. fromSocket, or does the aeson-pipes lib call that for you?
14:07:22 <jophish> AbelianGrape: you might be looking for the singletons package
14:07:52 <orion> AbelianGrape: let producer = fromSocketTimeout 4000000 s 4096 :: Producer' ByteString IO ()
14:08:04 <broma0> anyone familiar with ghcjs-vdom? I need some help with input elements..
14:09:28 <AbelianGrape> orion: I haven't used pipes except in toy examples, but couldn't you write a Pipe that counts the total number of bytes that has flown through it and kill the connection if it exceeds the limit?
14:09:43 <AbelianGrape> And then wrap that around producer
14:10:27 <orion> AbelianGrape: Perhaps.
14:11:31 * hackagebot buffer-builder-aeson 0.1.0.1 - Serialize Aeson values with Data.BufferBuilder  https://hackage.haskell.org/package/buffer-builder-aeson-0.1.0.1 (afriesen)
14:12:56 <richardiii> anyone else notice that haskell-cafe stores passwords in plain text and also sends an email out with it in plain text
14:13:43 <richardiii> ah, i guess it gives a warning in small text on the page
14:13:46 <richardiii> still seems bad
14:14:22 <cite-reader> Pretty much all mailing list software does this, as far as I know; I'm not sure if anyone is working on fixing it or not.
14:14:42 <monochrom> I know about the password in email, but I disabled "resend my password monthly" long ago so I no longer care
14:15:13 <monochrom> but I don't know how you know it stores passwords in plain text
14:15:55 <kadoban> Well, it's either in plain text or something that can be converted to plain text at whim. Otherwise, how do those emails get sent out?
14:15:58 <richardiii> monochrom: Well its an assumption, since it is willing to send them in emails
14:15:58 <Shockk> richardiii probably means not irreversibly hashed
14:16:11 <cite-reader> It's the same thing, to within a small epsillon.
14:16:17 <monochrom> ah, I see
14:16:31 * hackagebot error-analyze 0.0.1 - Parse ghc and cabal error messages and give their causes for easier resolution  https://hackage.haskell.org/package/error-analyze-0.0.1 (JeanPhilippeMoresmau)
14:16:31 <richardiii> not salted/hashed
14:16:33 * hackagebot buffer-builder-aeson 0.2.0.4 - Serialize Aeson values with Data.BufferBuilder  https://hackage.haskell.org/package/buffer-builder-aeson-0.2.0.4 (afriesen)
14:16:40 <richardiii> not salted or hashed
14:16:43 <richardiii> i assume
14:16:52 <richardiii> might be encrypted if we are lucky
14:17:12 <richardiii> cite-reader: Yeah, I assume its the same software for a lot of mailing lists
14:17:18 <bitemyapp> richardiii: it is. I replied on the ml.
14:17:25 <cite-reader> Irregular reminder that you shouldn't be building salted hashes yourself; use bcrypt or scrypt. Argon2 eventually, but the code is still rather immature.
14:17:47 <kadoban> If it's sending them as plain text, or has the ability to â¦ it's obviously not some kind of hashing scheme.
14:19:55 <Shockk> an interesting experiment to try would be to store the password encrypted with the public part of someone's PGP key and send it to them monthly and their mail client would decrypt it 
14:20:09 <Shockk> that would remove the ability to easily log in over the web though
14:20:26 <cite-reader> Obviously the solution is X.509 client certs, then. </notserious>
14:21:27 <reducedleft> just curious does hlint support this via some option? http://pastebin.com/GehGqU9d
14:21:42 <richardiii> bitemyapp: I am stupid a emails the wrong thing
14:21:49 <richardiii> and emailed*
14:23:00 <kadoban> Shockk: I have no godly idea what the point of emailing someone their password every month is anyway.
14:23:09 <richardiii> Im just wondering why an mailing list needs a password at all
14:23:12 <kadoban> Shockk: So starting there might be a good idea.
14:23:19 <Shockk> kadoban: true lol
14:23:41 <cite-reader> Presumably, some lone programmer in the 80s-ish throught it sounded neat and nobody ever cleaned up the code.
14:23:49 <richardiii> lol
14:24:00 <cite-reader> This is where most of the Internet came from, I'm pretty sure.
14:26:09 <obadz> do I have to write an Applicative instance to write a Monad one?
14:26:17 <obadz> or can the compiler write it from >>= ?
14:27:17 <ReinH> obadz: you can use return and ap
14:27:55 <glguy> If you define pure in the Applicative instance you can omit return from your Monad instance as of 7.10
14:28:26 <obadz> glguy: can I not write an Applicative instance at all ?
14:28:31 <glguy> no
14:28:51 <obadz> for every Monad instance *written* there most be an Applicative instance written ?
14:29:31 <orion> So, it just occurred to me that every connection I accept() is run in a new thread. Is there a way to somehow kill threads that exist for longer than a specified period of time?
14:29:39 <obadz> I don't understand, shouldn't a default implementation implementing <*> in terms of >>= kick in?
14:31:05 <jle`> obadz: it has to be explicitly stated...although there is a default implementation of <*> in terms of >>= that people can use if they're lazy
14:31:10 <glguy> There's a way to do something like that using the "default method signatures" extension, but Applicative isn't defined using that extension
14:31:16 <ReinH> There is no *default* implementation of (<*>) in terms of (>>=).
14:31:29 <jle`> instance Applicative Foo where pure = return; (<*>) = ap
14:31:38 <jle`> is a valid instance when you already have a Monad instance
14:31:39 <obadz> ReinH: why not?
14:31:56 <jle`> but having it be "automatically used" is a bit of a messy situation...and might not be as useful/clean/simple as you think :)
14:32:12 <obadz> jle`: ah ok, I hadn't realized ap was defined in terms of >>= ?
14:32:14 <emmanuel_erc> hello there haskellers
14:32:23 <richardiii> hi
14:32:27 <jle`> bbee: yeah, it's defined in terms of (>>=) and return
14:32:29 <obadz> jle`: I thought ap = <*>
14:32:31 <jle`> er, obadz , sorry
14:32:36 <obadz> ok cool, thx
14:32:58 <emmanuel_erc> I pasted this (http://lpaste.net/144477) a couple of hours... it seems like there are more people around here. Would anyone mind taking a look?
14:33:00 <jle`> ap these days serves the same role as `liftM`, `liftA`, etc..an easy way to define instances using more specialized versions
14:33:11 <jle`> instance Functor Foo where fmap = liftM works too, if you already have a Monad instance written
14:33:35 <jle`> usually people write Functor instances first, then Applicative instances, then Monad instances...writing them speciically for your type often helps performance
14:33:38 <richardiii> I dont mean to spam this if its already been posted, but i think this is a great idea https://www.indiegogo.com/projects/haskell-web-development-a-freely-available-book/x/12639618#/
14:34:00 <jle`> but for the lazy, you can just write a Monad instance and let the Functor/Applicative instance be written using the 'pre-written' functions implemented in terms of >>= and return
14:34:40 <jle`> (you still have to explicitly write instance Functor Foo where fmap = liftM, though)
14:35:09 <jle`> or if you've already written an Applicative instance and are too lazy to write fmap manually, instance Functor Foo where fmap = liftA
14:35:20 <obadz> yup I get it now
14:36:03 <obadz> I guess an instance Monad m => Applicative m where ... would have to be overlappable
14:36:13 <obadz> and I understand why that's not acceptable
14:36:17 <obadz> makes sense now.
14:36:25 <jle`> you can write it, and GHC will let you compile it
14:36:32 <jle`> but it'll make most code pretty useless, heh
14:36:41 <jle`> typeclasses are weird like thzt
14:39:30 <obadz> so if you have a State Monad in you wrote the Functor instance of State using liftM, would you lose the state?
14:40:00 <jle`> well, for a lawful Monad instance, fmap = liftM would be equivalent to whatever manual fmap you write
14:40:23 <jle`> (if you're manually writing instances for a State type)
14:40:47 <jle`> if your manually written fmap and liftM differ in behavior, you have a lot of explaining to do
14:41:06 <obadz> hmmm I guess my bind must be wrong
14:42:10 <mniip> how do you do instance comments in haddock again?
14:42:12 <obadz> but if x :: State a b and f :: b -> State a b, x >>= f would lose the a contained in x no?
14:42:37 <jle`> mniip: i think it's just the same ol' -- |, right before the instance
14:42:58 <jle`> obadz: f can do whatever it wants, it's a function
14:43:08 <jle`> er, arbitrary function
14:43:13 <jle`> it can choose to drop/ignore the state
14:43:48 <jle`> `f _ = put 'a'` would be an example where x >>= f would result in an action whose final state ignored the final state of x
14:43:49 <obadz> jle`: but f only has b as an input
14:44:10 <jle`> f does, but `State s a` has an `s` as input
14:44:19 <jle`> you can reach for it using `get`
14:44:42 <obadz> jle`: how would you write an "identity" f ?
14:45:02 <monochrom> I don't understand the question
14:45:08 <jle`> an identity in what sense? where x >>= f = x ?
14:45:15 <obadz> yes
14:45:35 <Axman6> hey.. I know what that f is...
14:45:39 <jle`> f = return would work
14:46:06 <jle`> or, if you don't have a Monad instance already, it would depend on what State type you're using
14:46:27 <jle`> if you're using data State s a = State (\s -> (a, s)), then you can do `f x = State (\s -> (x, s))`
14:46:33 <monochrom> it is also Applicative's pure
14:46:53 <jle`> but there are bunches of ways you can encode a State type with such a Monad instance
14:46:57 <obadz> didn't realize the State monad contained a function
14:47:00 <obadz> that probably clears it up
14:47:07 <obadz> I thought it was just essentially a tuple
14:47:09 <jle`> there are bunches of ways to encode the "State monad"
14:47:27 <bitemyapp> jle`: I prefer to do so with toothpicks, glue, and wild gesticulation.
14:47:29 <jle`> but the common one, used in transformers and most tutorials, is more or less State s a = State (s -> (a, s))
14:47:30 <mniip> hmm
14:47:43 <mniip> can't figure out a good comment for weaken :: Finite n -> Finite (n + 1)
14:47:44 <obadz> ok then I get it
14:47:54 <obadz> thanks jle` 
14:47:57 <jle`> np.
14:47:58 <bitemyapp> mniip: why is it called weaken?
14:48:22 <obadz> but now if I want to write a Monad that has 1 bit of state, 1 reader feature, and can throw exceptions
14:48:25 <mniip> because it weakens the inhabitability criterion?
14:48:29 <obadz> does that mean I need 3 nested functions?
14:48:36 <mniip> I guess
14:48:38 <monochrom> use a set of size at-most-n as a set of size at-most-n+1
14:48:47 <mniip> I borrowed the notation from data-fin, and it kind of made sense
14:48:59 <jle`> obadz: if you want to generalize the (s -> (a, s)) encoding, you can do something like (r -> s -> Either (a, s))
14:49:04 <shachaf> I don't think it needs a comment.
14:49:08 <mniip> monochrom, Finite is not a set though, it's a number...
14:49:09 <obadz> or do I mean a function like \ readerState, writableState -> Either e a in there?
14:49:21 <jle`> er, (r -> s -> Either e (a, s))
14:49:22 <monochrom> ok, s/set/number/
14:49:23 <jle`> that's one way to do it
14:49:26 <mniip> shachaf, there's another function with an identical signature though
14:49:27 <mniip> so
14:49:29 <obadz> jle`: ah yes
14:49:39 <shachaf> Why?
14:49:50 <mniip> they do different things
14:50:01 <obadz> jle`: thx again
14:50:08 <jle`> there's also the ADT-style encoding of State, where you have data State s a = Put s (State s a) | Get (s -> State s a) | Pure a
14:50:12 <mniip> one "adds" a number at the end, another "adds" a number in the beginning, shifting everything upwards
14:50:24 <jle`> obadz: in which case, you can add your other reader and error stuff as a part of the ADT
14:51:05 <jle`> obadz: data MyType r s e a = Put s (MyType r s e a) | Ask (r -> MyType r s e a) | Get (s -> MyType r s e a) | Error e | Pure a
14:51:09 <obadz> maybe I should just define my type as a transformer stack. Not sure I have the skills to design my own fancy monad yet ;-)
14:51:42 <jle`> you probably do...for the ADT-style encodings, it's actually pretty hard to define >>= and return incorrectly, heh
14:52:10 <obadz> yeah ADT style will make more sense to me I think
14:53:01 <obadz> are the different encodings like Endo and lists ?
14:53:17 <jle`> another way is to "factor out" the explicit recursion and the Pure constructor by using Free, which more or less encapsulates exactly this
14:54:17 <jle`> data MyTypeF r s e f a = = Put s (f a) | Ask (r -> f a) | Get (s -> f a) | Error e
14:54:44 <obadz> are there simplications I can make if: (a) my monad reads from an immutable variable that can never be changed and (b) it returns at most 1 bit of writable state (or maybe nothing) ?
14:54:44 <jle`> and then you your original MyType r s e a is `Free (MyTypeF r s e)`
14:54:48 <jle`> it's kind of cute i guess
14:56:13 <jle`> what happens when you try to >>= on something which has an 'empty' state?  would your "get" always be `Maybe s`?
14:56:58 <obadz> well the readable state and the writable states are disjoint
14:57:02 <obadz> writable is a maybe
14:57:14 <obadz> it will be writton only once, or never
14:57:24 <obadz> readable state cannot be touched, but maybe read many times
14:58:00 <jle`> any reason why you can't just use `Maybe s` as your state, instead of `s`?
14:58:08 <obadz> can I write a Monad instance for data MyType a = (readableStuff, Maybe writeableType, a) ?
14:59:10 <jle`> how about (r -> Maybe s -> (a, Maybe s)) ?
14:59:11 <obadz> jle`: I can, but curious If I need all the functions in the type definition given that the monad never writes stuff to itself that it needs to pull out again (until final run)
14:59:24 <jle`> which is also just ReaderT r (State (Maybe s)) a
14:59:52 <obadz> I think I want ReaterT r (Writer w) a
15:00:08 <obadz> r -> (a, Maybe s) ?
15:01:32 <jle`> maybe, but Writer is just State where the only way you can interact with it is using (<>)
15:01:33 * hackagebot lens-action 0.2.0.2 - Monadic Getters and Folds  https://hackage.haskell.org/package/lens-action-0.2.0.2 (EricMertens)
15:02:12 <obadz> doh!
15:02:15 <obadz> runWriter $ (return 3 :: Writer String Int)
15:02:22 <obadz> (3, "") !!!
15:02:52 <obadz> jle`: ha you've just preemptively answered my question
15:04:02 <obadz> didn't realize Writer was based on Monoid
15:04:04 <obadz> learning so much today
15:05:04 <jle`> Writer w a is commonly implemented as (a, w)
15:05:19 <bitemyapp> obadz: (though you'll usually want to use State with mappend rather than actually using Writer, fyi)
15:05:20 <jle`> > pure 3 :: (Int, String)
15:05:22 <lambdabot>      No instance for (Monoid Int) arising from a use of âpureâ
15:05:22 <lambdabot>      In the expression: pure 3 :: (Int, String)    No instance for (Num Strin...
15:05:22 <lambdabot>      In the first argument of âpureâ, namely â3â
15:05:24 <Cale> Writer can be lazier than State though.
15:05:40 <obadz> I don't have a Monoid instance for my writeable state so I guess I can't use Writer
15:06:00 <obadz> bitemyapp: why is that?
15:06:01 <Cale> In particular, it's possible to get infinite structures out of a Writer which is a trick you can't pull with State.
15:06:08 <Cale> (incrementally)
15:08:26 <obadz> jle`: wait so the Applicative instance for Monoid m => (m, s) is a writer monad?
15:09:11 <obadz> really I should say a Writer <period>
15:09:43 <jle`> yes, and teh Functor instance too :)
15:09:49 <bitemyapp> obadz: Applicative is a good example of this.
15:09:51 <jle`> > pure 3 :: (String, Int)
15:09:53 <lambdabot>  ("",3)
15:10:00 <bitemyapp> jle`: well, the Functor doesn't exhibit the writer-y part.
15:10:03 <jle`> the Monad instance isn't in Prelude for some reason...
15:10:19 <monochrom> Cale: does this count? http://lpaste.net/41790/
15:10:28 <jle`> bitemyapp: it's identical to the Writery treatment
15:10:28 <bitemyapp> obadz: Applicative brings out the "Writer" because w/ Applicatives, whatever parts of the structure that aren't mapped by the Functor bit, are going to be monoidal.
15:10:42 <bitemyapp> @ty (<*>)
15:10:44 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:10:50 <jle`> Writer is "data with a tagged value", which represents the Functor instance for tuples pretty well to me
15:11:03 <bitemyapp> obadz: it's all well and good to map the (a -> b) over the 'a' in the f a, but you have two bits of 'f' structure you need to combine.
15:11:16 <jle`> > pure succ <*> ("hello", 3)
15:11:18 <lambdabot>  ("hello",4)
15:11:26 <bitemyapp> obadz: the Monoid m => in Writer is delegating to your choice of Monoid for the unmapped part.
15:11:39 <obadz> > ("b", (+ 4)) <*> ("a", 3)
15:11:41 <lambdabot>  ("ba",7)
15:11:42 <obadz> I get it
15:11:56 <jle`> Writer could really have been called "tagged", but there's only one way to implement Applicative and Monad for it
15:11:58 <obadz> it's cool.
15:12:07 <shachaf> There are many ways.
15:12:18 <jle`> ah, yeah
15:12:42 <jle`> i was totally wrong there
15:13:09 <obadz> shachaf: sits in the dark waiting for one of the advanced members of this channel to slip. then he pounces ;-)
15:13:17 <shachaf> Huh?
15:13:26 <obadz> s/://
15:14:28 <shachaf> The "advanced members" have probably left this channel a long time ago.
15:14:50 <obadz> shachaf: just pointing out that you were mostly quiet during the convo but pounced to correct jle`'s mistake. Of course it's probably not funny after an explanation ;-)
15:15:10 <jle`> i'm still noob tho ;_;
15:15:16 <shachaf> It wasn't funny before the explanation either.
15:15:17 <obadz> shachaf: it's relative, jle` is very advanced compared to me
15:15:31 <mniip> knowledge of haskell has no limit
15:15:33 <shachaf> I don't pay too much attention to this channel. Probably more than I should.
15:15:39 <mniip> an unbounded set
15:16:03 <obadz> jle`: when does noob status end with haskell?
15:16:09 <mniip> never :)
15:16:24 <jle`> ^^
15:16:28 <Shockk> an infinite number of times
15:16:30 <obadz> it's like trying to catch the tail of [1..] ;-)
15:16:35 <mniip> well once you surpass edward maybe
15:16:39 <mniip> but how many people have done that
15:16:48 <Adeon> use a helicopter
15:17:21 <bitemyapp> The elite worship probably isn't going to help anyone
15:17:30 <bitemyapp> and will probably serve to intimidate new people
15:17:57 <obadz> agreed. so let's label jle` as advanced. makes me feel less stupid.
15:18:28 <mniip> there needs to be a haskell knowledge score :)
15:19:21 <Lokathor> i thought it was funny
15:19:29 <obadz> mniip: you can attach it to people but it has to be monoidal so it can be passed around ;-)
15:19:54 <obadz> (I'll stop with the bad humor)
15:20:14 <mniip> if you were talking about the writer applicative, yeah, that was pretty bad
15:20:39 <Shockk> the way I see it (i.e. the way it was for me at least), the progression of knowledge in Haskell, in order, is
15:20:47 <bitemyapp> obadz: here's an exercise straight from my book.
15:21:01 <Shockk> > cycle ["understanding of monads"]
15:21:02 <lambdabot>  ["understanding of monads","understanding of monads","understanding of monad...
15:21:04 <bitemyapp> well, h/o, let me check
15:22:00 <mniip> Shockk, well, I don't know, I only understood monads once
15:22:25 <bitemyapp> obadz: yeah here we go. Try writing applicative instances for: Identity a = Identity a; Two a b = Two a b; Three a b c = Three a b c; Three' a b = Three' a a b
15:22:36 <Shockk> is kind of a play on the fact that I thought I understood monads once and then I thought I understood them more fully, and etc
15:22:38 <bitemyapp> obadz: you'll should see a pattern.
15:22:45 <bitemyapp> you should*
15:22:47 <mniip> Shockk, yeah I figured
15:22:57 <bitemyapp> I think I'm remembering those from the right chapter anyway.
15:23:10 <mniip> the same happened between me and vector spaces and linear maps
15:23:33 <mniip> to the point of everything making sense and being so well aligned
15:23:35 <jophish> hmm, I don't think this has a solution but I'll ask anyway. I'm writing a dsl for a language and there's a particular kind of statement (finalStatement) which is only allowed to appear once. I'd really like to restrict the user at compile time to only having one of these statements. The other statements in this language are just expressions inside my monad but if I make finalStatement a function in this m
15:23:40 <Lokathor> is there a standard funciton, rotations :: [a] -> [[a]] that takes a finite list and returns an infinite list of the successive rotations of the input list?
15:23:40 <jophish> onad people could call it as many times as they like. The expressions are all tagged at the type level to stop them escaping their scope, so I can't require the user to generate this statement outside the monad computation. The only real option I can think of is to use some kind of indexed monad, but that seems a little cumbersome.
15:24:10 <mniip> jophish, yeah I thought of indexed monads too
15:24:26 <jophish> Ideally the module would be Module [NonFinalStatement] FinalStatement
15:24:51 <mniip> FinalStatement?
15:24:56 <mniip> not Maybe FinalStatement?
15:25:10 <jophish> mniip: oh right, it has to appear exactly once
15:25:24 <mniip> hmm
15:25:25 <obadz> bitemyapp: functorish in the last type variable and monoidal in the rest. Is there more to it?
15:25:37 <mniip> this reminds me of lua
15:25:50 <mniip> where return has to be the last statement in the block
15:26:18 <bitemyapp> obadz: nope, that's it :)
15:26:29 <obadz> bitemyapp: it's a cool excercise though!
15:26:29 <jophish> mniip: I thought of having some fancy "pure" for returning this statement from the computation, so the dsl usage would result in MyDSLMonad FinalStatement. But this special pure function would strip the type level tags
15:26:34 * hackagebot purescript 0.7.5.4 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.7.5.4 (PhilFreeman)
15:26:46 <bitemyapp> obadz: yeah there's a sequence like that in the end of the applicative chapter in the book.
15:27:00 <bitemyapp> obadz: we could use more reviewers, think it'd be something you'd be up for?
15:27:14 <shachaf> Lokathor: No standard function.
15:27:19 <bitemyapp> obadz: we're about to send out Reader for review and that you've been learning this stuff recently is helpful.
15:27:49 <obadz> Lokathor: tails . repeat or something like that
15:30:32 <mniip> Lokathor, \xs -> map (zipWith (const id) xs) $ tails $ cycle xs
15:30:59 <Lokathor> > take 3 $ (\xs -> map (zipWith (const id) xs) $ tails $ cycle xs) "abcd"
15:31:01 <lambdabot>  ["abcd","bcda","cdab"]
15:31:04 <Lokathor> fancy
15:31:19 <ReynoldsM> How is everyone doing today?
15:31:57 <mniip> :t (map . zipWith (const id)) <*> (tails . cycle)
15:31:58 <lambdabot> [b] -> [[b]]
15:31:59 <mniip> Lokathor, ^
15:32:31 <Lokathor> that's the same thing but PL?
15:32:39 <mniip> yes
15:32:55 <obadz> I wrote mine like this:
15:32:58 <jle`> not a single point in sight :o
15:33:05 <obadz> > let f = \ l -> map (map snd . zip l) . tails . cycle $ l in take 5 $ f [1,2,3]
15:33:06 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2],[1,2,3],[2,3,1]]
15:33:38 <obadz> I guess zipWith (const id) is cleaner
15:34:02 <Lokathor> i will put the first version in my notes
15:34:11 <Lokathor> that tie-interceptor operator is still a little dodgy to me
15:34:24 <mniip> tie-interceptor?
15:34:38 <Lokathor> the <*> looks like a TIE Interceptor
15:34:39 <obadz> yeah the Applicative instance of (a ->) is black magic...
15:34:42 <mniip> ah
15:34:45 <jle`> f <*> g = \x -> f x (g x), but yeah, definitely not something i'd use in real code
15:34:59 <mniip> I always remember Sfgx=fx(gx)
15:36:38 <Lokathor> what's the S
15:38:04 <mniip> Lokathor, google ski calculus
15:38:04 <obadz> Lokathor: it's from this: http://people.cs.uchicago.edu/~odonnell/Teacher/Lectures/Formal_Organization_of_Knowledge/Examples/combinator_calculus/
15:38:09 <jophish> @quote zip`ap`tail
15:38:09 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
15:38:47 <obadz> Lokathor: useful if you ever want to play pointsfree golf ;-)
15:38:53 <mniip> that just pairs each element with the next one
15:39:04 <mniip> obadz, bahahah pointfree golf
15:39:06 <mniip> watch
15:39:14 <shachaf> Time for some sneakiness.
15:39:16 <shachaf> @where sneaky
15:39:17 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
15:39:20 <mniip> @pl \x y z t -> t z y x
15:39:20 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
15:39:21 <shachaf> @where sneaky2
15:39:21 <lambdabot> lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []
15:40:31 <Lokathor> this SKI stuff is too much for me today
15:41:12 <mniip> Lokathor, it's simple
15:41:24 <mniip> (\x -> f g) = S (\x -> f) (\x -> g)
15:41:32 <Lokathor> things are always much simpler to people that already know them
15:41:35 <mniip> (\x -> y) = K y
15:41:35 <monochrom> ski calculus helps you find the optimal path of skiing from hill top to hill bottom
15:41:54 <Lokathor> i use A* instead
15:43:39 <Lokathor> mniip, are those left hand sides... supposed to be pattern matches?
15:44:14 <shachaf> Yes, but incomplete.
15:44:36 <mniip> kinda
15:44:51 <shachaf> (\x -> x) = I
15:45:27 <shachaf> You need to be a bit careful about free variables and expressions vs. variables to make those into pattern matches.
15:45:30 <mniip> (\x -> y) | not (occurs x y) = K y
15:45:32 <mniip> (\x -> f g) = S (\x -> f) (\x -> g)
15:45:41 <mniip> (\x -> x') | x == x' = I
15:47:14 <vektorweg1> why is there no -fwarn-spaces ?
15:47:32 <mniip> because ghc devs are evil people biased against tabs
15:48:13 <vektorweg1> i guess so.
15:49:03 <Lokathor> i only type with tabs
15:49:07 <mniip> I used to put {-# OPTIONS_GHC -fno-warn-tabs #-} in every file, but then just gave up and set expandtab in haskell's ftplugin
15:49:14 <Lokathor> and i indent four \t for subexpressions
15:51:31 <hpc> import Acme.Bleach; $(bleach "                                           ")
15:53:32 <vektorweg1> i added -fno-warn-tabs in my ide. so as long as i don't work outside of the ide, i'm safe. gives me creeps to run in this annoying issue sometimes again.
15:54:25 <vektorweg1> *thinking about to
15:55:25 <kadoban> vektorweg1: When a coding style thing is so ingrained in the community that it has a warning against it, it's a bit insane to fight against it. Especially when it's so easy to avoid. There's like no downside to just using spaces in a good text editor?
15:56:41 <Lokathor> some people don't have good text editors, oooooo~
15:56:56 <monochrom> I think you're looking for a political issue where there is only a technical issue.
15:57:10 <hpc> use nano for a week and every editor becomes good
15:57:47 <hpc> the reason for the warning is that tab behavior in haskell is very specific
15:57:53 <vektorweg1> kadoban: but the next guy to me like 8 spaces instead of 3 spaces indentation. how to fix that, if not with tabs? 
15:57:54 <hpc> and runs contrary to the behavior of most editors
15:57:54 <monochrom> most editors default to "use tab as much as possible" and unfortunately at the same time "but you customize how tab is displayed!"
15:58:07 <ReinH> Also the behavior of spaces is not surprising, so there's no need to warn about it.
15:58:31 <Wizek> @hoogle Shell a -> IO [a]
15:58:33 <lambdabot> Warning: Unknown type Shell
15:58:34 <lambdabot> Prelude repeat :: a -> [a]
15:58:34 <lambdabot> Data.List repeat :: a -> [a]
15:58:36 <hpc> indentation affects semantics, so having tab rendering that is different from the report's spec renders bugs invisible
15:58:40 <monochrom> the problem is that if you do customize how tab is displayed, your display easily deviates from what Haskell 2010 says about how tabs are interpreted.
15:59:08 <monochrom> and this becomes a problem because Haskell is a layout-sensitive language
15:59:14 <kadoban> vektorweg1: tabs don't fix it. Haskell assumes they're 8 space tabs, and if not you'll get errors eventually.
15:59:22 <hpc> additionally, there's rendering environments where tabs CANNOT be configured
15:59:31 <hpc> like a web browser
15:59:38 <Wizek> Anyone knows how I could convert a Turtle.Shell of `a`s into a list of `a`s?
15:59:41 <monochrom> your editor will display no layout errors but every standard-compliant compiler will see tons of layout errors.
15:59:50 <hpc> if your browser of choice renders tab literals differently, you're boned
15:59:56 <kadoban> vektorweg1: And also, you fix that by coordinating like adults and picking a style to use for shared code.
15:59:58 <hpc> i don't even know what browsers do with tabs
16:00:07 <vektorweg1> kadoban: when i use tabs for everything, i really don't notice how ghc is handling it internally.
16:00:08 <jophish> mniip: regarding that FinalStatement thing, I think what I'll do is expose a safe version using a monad indexed on whether this statement has been issued or not, and an "unsafe" version where it can be issues any number of times. If people want to play with rebindable syntax to get the safety they'll be able to
16:00:26 <kadoban> vektorweg1: Well, you will eventually.
16:00:39 <monochrom> but the ill editor behaviour is popular and ingrained. we spent ten years telling this to beginners and we concluded that it is hopeless.
16:01:10 <monochrom> the next best thing is to add a warning to compilers
16:02:31 <hpc> it's worth noting that you've completely tied yourself to your ide, to a degree even greater than java for instance
16:02:46 <vektorweg1> monochrom: true. but there should be an option to either warn for tabs and for spaces. 
16:02:51 <hpc> java will at least look the same in another editor, and you can run ant by hand
16:04:48 <vektorweg1> hpc: i don't get it.
16:05:26 <hpc> vektorweg1: suppose you decide to write a quick patch for your code
16:05:43 <hpc> vektorweg1: fortunately, it's on github, so you can do it from the website on your phone
16:05:49 <hpc> vektorweg1: maybe you're about to board a plane
16:06:15 <hpc> vektorweg1: so you go to github, click edit next to the file, and now you can't type tabs because it moves you to the submit button
16:06:53 <kadoban> vektorweg1: You understand that haskell has whitespace layout rules? And that haskell assumes that your tabs are 8 spaces, and if not you'll be seeing code that looks fine, but the code will actually have errors in it?
16:06:58 <hpc> or you open the file on another machine somewhere and now tab inserts spaces
16:07:10 <vektorweg1> hpc: thats a problem of github then. because you can today in web capture tab.
16:07:10 <hpc> but only 4 of them
16:07:22 <hpc> vektorweg1: you can, but you shouldn't
16:07:28 <lspitzner> hpc: so because github editor being crappy is a reason for ghc being crappy?
16:07:36 <ReinH> vektorweg1: why should there be an option to warn about spaces?
16:07:41 <kadoban> vektorweg1: So either you don't use tabs, or you do and everyone has to have their tabstops set at 8, which is pretty huge compared to most people's preferences.
16:08:15 <arkeet> kadoban: those are not the only two options.
16:08:24 <kadoban> arkeet: What other options are there?
16:08:37 <arkeet> http://dmwit.com/tabs/
16:08:38 <ReinH> What would that warning say? "warning: Uou appear to be using spaces for indentation. That's fine. Carry on."?
16:08:43 <ReinH> s/Uou/You
16:08:49 <lspitzner> there should be an option to warn about spaces because the important thing is consistency, not spaces vs tabs.
16:08:54 <vektorweg1> ReinH: exactly.
16:09:06 <arkeet> I just use spaces though.
16:09:27 <monochrom> vektorweg1, tab is ambiguous (thanks to most editors), space is not ambiguous. there is nothing to be warned about spaces.
16:10:05 <hpc> vektorweg1: what do you do when you want to align something that's not a multiple of your tabstop?
16:10:17 <arkeet> spaces.
16:10:19 <hpc> (because haskell is not an indented language, it's a layout language)
16:10:32 <lspitzner> but if you want to use tabs, using _spaces_ is the bad thing that you want a warning for.
16:10:37 <kadoban> arkeet: Okay, apparently some insanity based on visible whitespace is also possibly an option. I'll â¦ not keep that in mind, sorry.
16:10:58 <arkeet> kadoban: it seems reasonable, but I can understand that a lot of people (including me) would not be interested.
16:10:58 <hpc> what happens when you get multiple contributors?
16:11:01 <vektorweg1> monochrom: as lspitzner said, its about consistency. either you go spaces or tabs. 
16:11:15 <vektorweg1> monochrom: and this gives safety.
16:11:19 <ReinH> vektorweg1: It's not (just) about consistency.
16:11:23 <ReinH> Using tabs only doesn't give safety.
16:11:26 <lspitzner> stop arguing that tool x has problems with tabs. they clearly are supported, they have a certain advantage over spaces.
16:11:47 <hpc> what happens when another contributor uses 2-space tabs for alignment, then in 4-space tabs it looks terrible
16:12:05 <arkeet> don't use tabs for alignment.
16:12:13 <hpc> arkeet: you have to though
16:12:16 <arkeet> you do?
16:12:16 <hpc> arkeet: or it's inconsistent
16:12:27 <ReinH> Tabs cause problems, so there is a warning about using tabs. Spaces don't cause problems, so there is no warning about spaces. What else is there to discuss?
16:12:30 <hpc> vektorweg1 suggests we warn when spaces are used
16:12:34 <arkeet> oh.
16:12:38 <arkeet> don't do that.
16:13:27 <vektorweg1> arkeet: why not?
16:13:32 <hpc> vektorweg1: put bluntly, it sounds like you have never ever encountered any "big code"
16:13:47 <hpc> vektorweg1: code that's been touched by thousands of people across 10+ years
16:14:18 <lspitzner> hpc: oh man, ad hominem? that is the best argument you have?
16:14:32 <ReinH> That is not ad hominem.
16:14:35 <shachaf> I recommend the whole tab/space discussion stop now.
16:14:36 <MarcelineVQ> That's not what's happenning here <_<
16:15:04 <ReinH> Ad hominem would be something like "your face is funny looking therefore tabs are superior".
16:15:13 <vektorweg1> hpc: thats right and when i never going to coding on "big code", why should i use tools for coding on big code?
16:15:16 <phaazon> hey, is there paper / essays about âWhat if memory was designed to help functional programmingâ? That is, a complete different allocation system that would cause creating huge thunks of memory, wouldnât require a GC, etcâ¦
16:15:18 <lspitzner> ReinH: off topic
16:15:21 <phaazon> papers*
16:15:23 <phaazon> are there*
16:15:37 <ReinH> lspitzner: I'm responding to *you*.
16:15:56 <phaazon> my gosh my sentence has no sense :D
16:15:58 <phaazon> I hope you got it
16:16:02 <phaazon> I can reformulate though
16:16:44 <hpc> phaazon: there may be bits and pieces of what you're after in the reduceron
16:16:53 <phaazon> oh
16:16:54 <aaronm04> phaazon: I think the imperative programming style more closely fits how hardwore (including memory) actually works
16:16:55 <phaazon> reduceron
16:16:55 <hpc> but that was more CPU-focused, so not sure how it does memory
16:17:00 <phaazon> Iâve already been told that here
16:17:12 <phaazon> aaronm04: yeah
16:17:17 <phaazon> thatâs why Iâm asking that
16:17:18 <ggVGc> what's the benefit of having it/then/else as language syntax rather than normal functions?
16:17:22 <aaronm04> ah ok, sorry
16:17:29 <phaazon> Iâm looking for some hm
16:17:29 <phaazon> essays
16:17:37 <phaazon> about what it would be if we had such hardware
16:17:37 <hpc> it's tricky to give a good answer because of how thoroughly ghc has optimized for existing memory designs
16:17:43 <phaazon> that would not be side-effects based, and so on
16:17:56 <Hijiri> ggVGc: it can be mixfix
16:18:05 <MarcelineVQ> ggVGc: just succinctness in one liners, that I've seen
16:18:12 <Hijiri> unless you define your language to allow defining mixfix operators in general
16:18:21 <hpc> maybe something about cache levels being tied to scope and some weird laziness stuff
16:18:26 <hpc> but i can't think of any specific materials
16:18:52 <hpc> ggVGc: parsing, mostly
16:18:59 <phaazon> hpc: interesting
16:19:19 <hpc> ggVGc: defining a mixfix version of "then" would either have you writing if p `then` t `else` f
16:19:26 <hpc> which, imagine the hilarity of missing those backticks
16:19:29 <phaazon> nowadays, a lot of people â most of them donât know FPL â think that Haskell / OCaml / whatever FP is slow
16:19:34 <hpc> or you'd be writing p ? t : f
16:19:37 <ggVGc> hpc: why is it easier to parse a special construct rather than just have normal functions as we already do?
16:19:40 <phaazon> because it has to create a lot of objects, which is kinda true
16:19:40 <hpc> which already has to change because of (:)
16:19:43 <ggVGc> well, yeah, true
16:19:47 <ggVGc> so it's just for looks basically
16:19:52 <hpc> or you add mixfix to haskell
16:19:58 <hpc> which would be pretty damn cool
16:20:27 <ggVGc> I mean, to me "if" is just a Maybe
16:20:34 <ggVGc> and then is just a pattern match
16:20:36 <aaronm04> phaazon: I imagine you would have features like 1) tag bits in words to indicate whether or not it's a pointer, and 2) you couldn't convert arbitrary data to/from this pointer type, 3) the hardware would keep track of sizes of objects, and whether they are still alive
16:20:38 <hpc> but a major parsing complication and wouldn't be universally picked up by libraries until it becomes report spec
16:20:41 <aaronm04> basically, just GC in hardware
16:20:55 <hpc> you would need the extension at the call site in addition to at definition site
16:21:06 <hpc> so the extension leaks into everything
16:21:08 <stepcut> if you have DataKinds enabled and do, data Foo = Bar | Baz | Beep, is there some function like, toFoo :: (ToFoo (foo :: Foo)) => Proxy foo -> Foo
16:21:10 <phaazon> aaronm04: well, what makes a program written in FPL slow?
16:21:15 <phaazon> if not memory allocation?
16:21:26 <stepcut> that is.. some way to go from a type to a value.. similar to natVal..
16:21:35 <mutantmell> :src toCaseFold
16:21:39 <mutantmell> @src toCaseFold
16:21:39 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:21:40 <hpc> ggVGc: obviously, if-then-else isn't required for haskell to work as a language
16:21:58 <aaronm04> phaazon: besides memory management? probably boxing and unboxing
16:22:01 <hpc> ggVGc: and it's discouraged anyway due to boolean blindness
16:22:03 <ggVGc> phaazon: what's funny to me is that hardware is actually more "FP" in nature than software. In hardware everything is signals and data flows
16:22:07 <mutantmell> @src Data.Text.toCaseFold
16:22:07 <lambdabot> Source not found. Maybe if you used more than just two fingers...
16:22:09 <hpc> ggVGc: but it's expected
16:22:19 <phaazon> ggVGc: hm
16:22:22 <phaazon> yeah, well
16:22:27 <phaazon> hardware is also about segments
16:22:36 <hexagoxel> ReinH: so? my point was that hand-waving about "big code" is a rather weak argument, if it matches your definition of ad-hominem or not.
16:22:37 <phaazon> and cases in which you have values you can access through adresses
16:22:41 <phaazon> which is very imperative
16:22:56 <ggVGc> I'm just saying, to me haskell is in a sense closer to VHDL than to i.e C
16:23:03 <hpc> hexagoxel: lack of experience in a field affected by policy change is a valid argument
16:23:06 <phaazon> VHDL ?
16:23:14 <ggVGc> hardware description language
16:23:25 <ggVGc> i.e for actually designing hardware citcuits
16:23:28 <ggVGc> circuits*
16:23:35 <hpc> (the v stands for "vroom")
16:23:49 <phaazon> hpc: like the cars?
16:23:51 <phaazon> vroom vroo
16:23:54 <hpc> :)
16:23:57 <phaazon> :)
16:24:13 <aaronm04> ggVGc: but consider that in hardware, all data has a place, whereas there is no concept of "place" in FP
16:24:25 <phaazon> I wonder how ST is implemented
16:24:29 <ggVGc> sure, it's obviously not a direct map
16:24:41 <hpc> phaazon: it's IO
16:24:47 <ReinH> hexagoxel: I can only respond to what you said, not what you meant to say.
16:24:49 <ggVGc> but FP is conceptually more similar to hardware design than it is to imperative programming, imo
16:24:51 <hpc> phaazon: ghc's dirty secret is that the whole language is impure
16:25:01 <hpc> so IO and ST can have the same linearity-imposing implementation
16:25:05 <hexagoxel> hpc: wait, what? i should use spaces _because i have no experience_ ?
16:25:09 <phaazon> hpc: PrimMonad, you mean
16:25:10 <hpc> and one type just doesn't get the dirty operations
16:25:31 <phaazon> hpc: Iâve always wondered
16:25:37 <phaazon> when doing something like
16:25:38 <phaazon> readIORef
16:25:51 <phaazon> is it like a dereference in C?
16:25:54 <hpc> hexagoxel: perhaps i should have said "you don't understand the implications in ${this environment}"
16:25:56 <phaazon> like, *x
16:26:03 <hexagoxel> ReinH: well if you cannot decipher the part of what i say that is on-topic, i suggest you simply refrain from responding.
16:26:27 <hpc> phaazon: more or less
16:26:29 <ggVGc> aaronm04: also, not sure I agree. In order to model memory in hardware, you literally make a signal loop. How is that much different from a recursive function?
16:26:35 <ReinH> hexagoxel: I can't read your mind, is more like it. And you don't get to decide whether I respond or not.
16:26:36 <hpc> it shares a decent amount of semantics
16:26:48 <hpc> there's some bonus thread-safety to IORef, just off the top of my head
16:26:49 <phaazon> I guess the *x would be more Storable.peek
16:26:53 <hpc> there's probably other subtleties
16:26:58 <hpc> oh, and no pointer arithmetic
16:27:07 <aaronm04> ggVGc: I think that's at a lower level than the level I was describing
16:27:14 <phaazon> hpc: with IORef/STRef? yeah
16:27:29 <aaronm04> it's analogous to how you can have imperative-like code implemented in FP
16:27:49 <hpc> obviously, (*x) is an effectful operation because what the world decides to do will govern the value you get out of the pointer
16:28:00 <hpc> and it can invisibly change when x isn't around
16:28:10 <aaronm04> so in hardware, the very lowest level is functional, but at the next higher level of abstraction, you have imperative-like behavior
16:28:48 <ggVGc> aaronm04: I just think, if we make a CPU where the core concepts are no longer memory/program pointers, and instead the base is signal paths and processor units. Then we actually have a CPU architecthure that's closer to how hardware works at the lowest level, and also fitting to FP
16:28:57 <hpc> phaazon: STRef is the reason why ST is an imperative escape valve to begin with ;)
16:29:04 <hpc> it's the very goal of ST
16:29:09 <phaazon> yeah
16:29:18 <ggVGc> instead of compiling our FP code to data storages, we could compile it to vitual signal paths
16:29:22 <phaazon> I like to see ST like a way to perform some âsaneâ side-effect
16:29:25 <phaazon> for optimization purposes
16:29:40 <hpc> imo there's worse things to do than reference manipulation in haskell
16:29:47 <hexagoxel> ReinH: i suggested. i will stop replying to your word-bending now.
16:30:07 <ggVGc> aaronm04: why do we need the imperative level of abstraction?
16:30:21 <ggVGc> why not map functional transformation paths to hardware signal paths directly
16:30:33 <aaronm04> we probably don't; I guess it's tradition
16:30:37 <ggVGc> right
16:30:38 <ReinH> hexagoxel: Surely you could decipher the part of what I said that is relevant to your suggestion.
16:30:48 <hpc> GUYS! since graph reduction is a no-op anyway, we can surely create an infinitely fast functional CPU
16:30:52 <hpc> someone get on that right away
16:31:06 <hpc> then we won't even need memory
16:31:09 <hpc> we can compress it all
16:31:17 <ReinH> hexagoxel: if not then I suppose you should take your own advice.
16:31:42 <glguy> ReinH hexagoxel: Whatever you're talking about, please stop doing it here
16:32:23 <ReinH> glguy: sounds good.
16:32:26 <aaronm04> ggVGc: this sounds a little bit like the neuromorphic architectures I read about a while back
16:32:40 <ggVGc> never heard of that
16:32:54 <ggVGc> but I'm pretty sure "functional hardware" exists in many places
16:32:57 <ggVGc> for specialised use
16:33:04 <aaronm04> the idea is that they build chips to be like the brain
16:33:39 <aaronm04> consider that neurons don't store their data in any kind of memory; instead, it's a continuous stream of inputs -> decision to fire or not
16:33:57 <ggVGc> right
16:33:59 <ggVGc> neural networks
16:34:40 <aaronm04> so neuromorphic architectures are primarily intended to run neural networks really fast, because they avoid the load/store from/to memory cycle
16:34:53 <ggVGc> but yeah, that's the gist of what I feel. I've been doing some FRP recently, and if you just see your program as a sequence of transformations with a certain amount of signal inputs going through it, that should be mappable to hardware in a better way than through modelling data etc.
16:34:58 <ggVGc> but maybe not
16:35:03 <ggVGc> I've only done very little hardware desing
16:35:15 <ggVGc> made a digital synth,and it took me a week to get it to play anything
16:35:36 <ggVGc> would be interesting to model a "functional CPU"
16:36:00 <ggVGc> I'm not sure exaclty what "map virtual signal paths to hardware signals" means in practice
16:36:30 <aaronm04> sounds like you have your work cut out for you ;)
16:36:46 <ggVGc> in the end you'd need "computation units" anyway, and they'd probably be best implemented like our current CPUs..
16:37:15 <ggVGc> I think I'm too much 2in the box" of von neuman arch to see the light
16:39:29 <aaronm04> see if you can get your hands on an FPGA
16:43:31 <ggVGc> aaronm04: that's what I used for my digital synth. But yeah, don't have one now. There are some open source boards now though, and I've spoken to some people in #hardware who say it's not too hard to get a general super cheap FPGA running with various chinese ripoff programmers
16:43:47 <ggVGc> don't really have time for hardware experiments though..
16:44:00 <ggVGc> already have this pile of PICs and stuff lying around on my shelf
16:44:30 <ggVGc> pretty sure Intel or IBM will build a great FP-geared CPU within 10 years
16:44:45 <ggVGc> or already have..
16:45:19 <ggVGc> aaronm04: found this btw, https://www.cs.york.ac.uk/fp/reduceron/
16:48:23 <aaronm04> I have to go; good luck :)
16:49:45 <hpc> okay, i really hate to keep this one going, but i actually had a better idea on tabs/spaces
16:50:19 <hpc> instead of tabs being 8-stop, require the exact sequence of tabs and spaces to be the same on all lines of the same level
16:51:25 <hpc> it's still not perfect, but is less wide open to terribleness than openly using tabs
16:52:22 <jophish> D: Why is intercalate on lists instead of any monoid
16:52:34 <FreeFull> What's the reason for the (^^) operator again?
16:52:44 <glguy> negative powers
16:52:50 <FreeFull> Ah
16:52:51 <kadoban> :t (^^)
16:52:52 <lambdabot> (Fractional a, Integral b) => a -> b -> a
16:52:53 <jophish> :t mconcat . intersperse
16:52:54 <lambdabot>     Couldn't match type â[a] -> [a]â with â[c]â
16:52:54 <lambdabot>     Expected type: a -> [c]
16:52:54 <lambdabot>       Actual type: a -> [a] -> [a]
16:53:07 <jophish> :t mconcat . intersperse _
16:53:08 <lambdabot>     Found hole â_â with type: c
16:53:08 <lambdabot>     Where: âcâ is a rigid type variable bound by
16:53:08 <lambdabot>                the inferred type of it :: [c] -> c at <interactive>:1:1
16:53:48 <Lokathor> hpc you're just describing python :P
16:54:00 <Lokathor> and even in python there's the same war
16:54:37 <hpc> oh good, so it's still a terrible idea
16:54:39 * hpc is relieved
16:55:32 <Lokathor> there's a PEP that says "always use 4 spaces to indent", but as long as each block indents to the same depth and has more indents than the last, the interpreter will accept it. there's a warning if you mix them and stuff though
16:56:04 <Lokathor>  \t x += 1
16:56:05 <Lokathor> woo
16:56:50 <Cale> hpc: I'd rather just say "no tabs are allowed ever"
16:57:13 <Cale> hpc: It's easy and forces people to be consistent with each other.
16:57:30 <Cale> after all, we don't allow vertical tab characters, why allow horizontal ones?
16:57:53 <hpc> Cale: we should sponsor a proposal for a unicode diagonal tab
16:57:56 <hpc> and use those exclusively
16:58:52 <Cale> 60 DEGREE TABULATION
16:59:14 <kadoban> Negative tabulation. "this line is /even more/ important than everything else."
16:59:31 <hpc> the erotic font-fiction: 50 stops of tab
16:59:39 <hpc> imaginary tabs
16:59:42 <hpc> z-tabs
16:59:47 <hpc> fibonacci stops
16:59:48 <Cale> EXPONENTIAL SPIRAL TABULATION
17:00:06 <hpc> we could have em-tabs and en-tabs
17:00:56 <hpc> /topic Welcome to #bad-ideas | Today: microwaved bananas
17:01:05 <Cale> ONE TWIP TABULATION
17:01:18 <kadoban> I think the one that's most sane so far is fib stops, that'd actually be cool.
17:01:21 <Cale> It's 1/20th of 1 point
17:01:28 <Cale> which is 1/1440 of an inch
17:06:09 <vektorweg1> -fwarn-ztabs
17:06:57 <hpc> you're thinking too small
17:07:02 <hpc> -fwarn-euclidean-layout
17:07:10 <vektorweg1> :D
17:08:52 <enolan> is there a way to get the ghci debugger's :list to output more than 3 lines of context?
17:15:39 <jophish> Why does IsList have a toList function :(
17:16:07 <stepcut> :)
17:19:01 <jophish> in fact, every time I've tried to use a class with a to.* member it's been a pain, for example toRational
17:19:29 <jophish> the first one especially though, since we have Foldable
17:19:32 <glguy> jophish: It has toList to support patternmatching on list literals for IsList types
17:19:53 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#overloaded-lists
17:20:00 <glguy> (I cheated and looked at the documentation)
17:20:35 <jophish> ah, I suppose that makes sense
17:21:11 <jophish> although I'm not sure why a separate class couldn't have been required for pattern matching
17:37:08 <mac10688> I'm working with stack. When I run "stack ghci" it always opens up my library modules. I want it to open up my tests file, that's in my tests folder. Anyone know of a way to do this?
17:37:41 <mac10688> I tried opening the test file with just bare ghci but it can't resolve Test.QuickCheck, and I know that stack can resolve that
17:42:08 <mac10688> ah, nvm. I just let it open the Lib module and then :l ../test/Test.hs
17:44:02 <mgsloan> mac10688: You can have it load up your test via "stack ghci :my-test-suite-name"
17:45:17 <mac10688> perfect! thanks mgsloan. things just got smoother
17:45:33 <mac10688> so I guess I know what TARGET means now
17:57:21 <haskellsucks69> hey guys
17:59:03 <haskellsucks69> hi 
17:59:06 <haskellsucks69> hello people
17:59:33 <haskellsucks69> yall niggas suck d
18:01:26 <finlay> Question: does anyone know where I can find a Binary Instance for UTCTime (from time)(
18:01:29 <finlay> ?
18:03:57 <finlay> wow, there are a lot of people in here
18:04:06 * finlay wonders if there is a better place to ask questions
18:04:48 * SiIky is sure there are lots of places to ask questions
18:05:09 <SiIky> but one cant compare or know of all of them so one cant know if this is really the best
18:06:09 <finlay> deep
18:06:39 <SiIky> thx
18:06:41 <codebje> finlay, there probably is not such an instance, because declaring the instance outside the time package would be an orphan instance
18:06:48 <finlay> okay
18:06:52 <bergey> How about http://hackage.haskell.org/package/binary-orphans
18:07:29 <finlay> bergey: thanks!
18:07:31 <finlay> thats it
18:07:40 <codebje> hah, ok then :-)
18:07:43 <finlay> I just knew it would live somewhere
18:08:28 <finlay> thank you #haskell, you rock
18:10:29 <ragone> Not sure where to ask this, but I want to improve my general programming/CS knowledge, even when I am not coding. Can anyone recommend a product (podcast, webcast, puzzle, software) that you use ~everyday? > Intermediate level
18:11:07 <Lokathor> Functional Geekery
18:11:18 <Lokathor> but it's less haskell and more Clojure and Scala and Erlang
18:11:58 <codebje> you can learn lots from clojure and scala and erlang
18:12:24 <ragone> That's alright, I'm here to expand my horizon
18:12:25 <codebje> erlang teaches a fantastic model of parallelism, clojure teaches the power of homoiconicity, scala teaches how to cock up language design
18:12:54 <finlay> I like reading papers. There a few good collections out there, such as https://github.com/beerendlauwers/haskell-papers-ereader
18:12:59 <bitemyapp> codebje: Erlang is more about resilience and independent in a dist-sys context than parallelism.
18:13:12 <bitemyapp> codebje: the Erlang VM wasn't even multi-threaded until '06 IIRC
18:13:14 <codebje> yeah, but I never got that far, I only got as far as actors and the independent GC model :-)
18:13:17 <finlay> Simon
18:13:32 <bitemyapp> codebje: GHC RTS (and research therein) is arguably more focused on concurrency and parallelism
18:13:34 <finlay> Simon M's concurrent programming book is excelent too
18:13:41 <ragone> Lokathor: Functional Geekery looks interesting!
18:14:48 <ragone> finlay: note to myself.. read more research papers, good advice!
18:14:50 <ca`> ragone: have you gone through The Structure and Interpretation of Computer Programming?
18:15:07 <Lokathor> codebje, http://chimera.labs.oreilly.com/books/1230000000929/index.html as well, if you haven't read it yet
18:15:09 <bitemyapp> ragone: exercises.
18:15:14 <Lokathor> touches on an actor model
18:15:14 <bitemyapp> ragone: have you learnt Haskell yet?
18:15:41 <codebje> bitemyapp, do you have a starting point for exploring ghc rts?
18:15:42 <Lokathor> and ragone, i'd also say to read that book if you haven't yet
18:15:51 <codebje> lokathor, on my to-read list :-)
18:16:02 <bitemyapp> codebje: Marlow's book.
18:16:18 <ragone> ca`: No I haven't, thanks! I'll note that down
18:16:19 <codebje> bitemyapp, thanks
18:16:21 <bitemyapp> codebje: I'll touch some stuff in my book later, but Marlow's is really the best choice for GHC RTS / conc / par
18:16:26 <Lokathor> codebje, i read it at work on breaks mostly, quality stuff
18:16:45 <codebje> I quit driving to work to gain an hour every day on the train to read more
18:16:56 <ragone> bitemyapp: I have, but still more confident in OOP though
18:18:04 <bitemyapp> ragone: how strong are you on Monoid/Functor/Applicative/Monad?
18:19:24 <stephen_> ragone: Here's the MIT press page https://mitpress.mit.edu/sicp/
18:21:13 <ragone> bitemyapp: not very
18:21:30 <codebje> I like http://www.sicpdistilled.com/ as a taken on sicp
18:22:26 <bitemyapp> ragone: well, my book is written for people that want to solidify their understanding of programming as well as Haskell
18:22:35 <bitemyapp> ragone: there's a free sample on the site: http://haskellbook.com/
18:22:47 <bitemyapp> ragone: could kill two birds with one stone perhaps? :)
18:23:21 <ragone> stephen_: great thanks!
18:24:18 <codebje> oh, and cis194
18:24:33 <mniip> so, can I get some code review, while my ghc is compiling
18:24:37 <mniip> https://github.com/mniip/finite-typelits
18:25:12 <ragone> bitemyapp: 73 page sample, awesome! I'll start reading tonight
18:26:11 <bitemyapp> ragone: cheers :)
18:26:29 <ragone> thanks for all your suggestions!
18:26:31 <bitemyapp> ragone: be aware it's just intro, second, third chapter.
18:26:34 <ragone> great advice
18:26:49 <bitemyapp> ragone: we didn't include the first chapter JSYK. Let me know what you think whether you decide to get the book or not please :)
18:27:13 <ragone> bitemyapp: I will!
18:27:21 <codebje> mniip, "initial commit" has a heck of a lot of stuff in it :-)
18:27:40 <mniip> codebje, should've split up :P
18:28:17 <codebje> (I just assume you either pruned a richer history, or like to live dangerously)
18:28:38 <mniip> there was not a history
18:28:45 <mniip> I wrote all of this tonight
18:31:25 <codebje> can't really comment on the code, but figuring out what "result = if x < natVal result && x >= 0" does was informative
18:34:06 <codebje> any reason why `strengthen` isn't written in terms of `strengthenN` ?
18:34:51 <codebje> ah, I think I see - `strengthen` doesn't need explicit typing of the difference
18:35:10 <mniip> the constraints are slightly different
18:37:09 <codebje> why doesn't sub strengthen the Finite?  and isn't it possible for it to return Left?
18:37:16 <codebje> oh, left _0_
18:37:18 <codebje> nevermind that part
18:38:27 <xkfngs> Is 'Learn You a Haskell' still a good introduction to the language? If not what is a proper intro? Thanks.
18:40:13 <Lokathor> "GHC on ARM is pretty well established at this point"
18:40:16 <Lokathor> ha ha ha
18:40:26 <Welkin> @where learnhaskell -- xkfngs 
18:40:27 <lambdabot> https://github.com/bitemyapp/learnhaskell
18:40:39 <pavonia> @where cis194
18:40:39 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
18:40:56 <Lokathor> xkfngs, cis94 is what you want, but it will have you read some chapters from LYAH as well
18:41:07 <xkfngs> thanks!
18:41:09 <Lokathor> but those extra explanations and extra homeworks are what's key
18:41:22 <Lokathor> LYAH on its own will fail you, because it doesn't have any homeworks
18:41:30 <xkfngs> I've dabbled in the language just a tad in the past. Most of my functional programming knowledge comes from clisp.
18:42:03 <Romefeller> Hi all
18:42:19 <dmj`> Romefeller: Hi
18:42:21 <mniip> codebje, hmm?
18:42:25 <mniip> n - 0 = Right n
18:42:29 <mniip> 0 - m = Left m
18:42:30 <Romefeller> dmj`:  Hi!
18:44:09 <Welkin> Lokathor: fuck homeworks
18:44:23 <Lokathor> :<
18:44:44 <dmj`> Lokathor: haskell homework?
18:46:02 <Lokathor> there once was a lisp guy who insisted that you read the entire spec of Common Lisp before you try to write a single line of it yourself.
18:46:07 <Romefeller> homework is better than exams
18:46:08 <Lokathor> odd one
18:46:10 <witt3rd> is it possible to use Data.Set as a key to a Map (needs Ord)?
18:46:27 <Lokathor> don't think Data.Set has Ord, so no
18:47:17 <Welkin> Romefeller: no exams either
18:47:30 <Welkin> just build real projects that you are interested in
18:48:12 <Romefeller> Welkin:  I teach. Here in my county i cant do that. Because people likes to cheat.
18:48:29 <witt3rd> that's what I thought.  Just wondering if there was a clever hack.  (Ord a) => Set a, so could likely implement Ord on Set, no?
18:49:03 <mniip> anyone else willing to do code review :oo
18:49:04 <mniip> :o
18:49:16 <Romefeller> Welkin: I grade, 50% Exams, 20% HW and 30% Projects
18:49:18 <codebje> yeah, sorry, most of your code is still beyond me :)
18:49:32 <mniip> witt3rd, sure you can
18:49:51 <mniip> instance Ord a => Ord (Set a) where compare x y = compare (toList x) (toList y)
18:50:08 <mniip> it's going to have bad complexity though
18:50:39 <witt3rd> sweet!  that's ok (complexity).  this is just academic stuff :-)
18:50:55 <witt3rd> thanks!  I'll give it a go
18:56:31 <Hijiri> 2/disconnect
18:56:54 <mniip> sounds like prolog
19:13:48 <MrMetric> Hello. Haven't joined this chat since February.
19:13:56 <bitemyapp> MrMetric: welcome back!
19:14:37 <MrMetric> :]
19:15:20 <Jello_Raptor> hmm, there's got to be a haskelly design pattern for this. I keep finding myself with some ADT A, and then wanting to transform it into some ADT B which is just A with some missing constructors. I've either got to declare two identical data structures, mappings and transformations that I just have to keep in sync, or define ADT A and trust that my transformations give me elements that are in subset of ADT A that is ADT B. 
19:16:32 <julianleviston> Jello_Raptor: I think we were talking about this yesterdayâ¦ 
19:16:51 <Jello_Raptor> Like how the template haskell AST has that "This is an infix operator, but without precedence information. The compiler will just sort it out later." thing. 
19:16:51 <MrMetric> I'm trying to define a % b in GHCi, and gives an error when the function is called
19:16:57 <lpaste> MrMetric pasted âGHCi modulus errorâ at http://lpaste.net/144501
19:16:59 <bitemyapp> Jello_Raptor: A -> Maybe B
19:17:01 <julianleviston> Jello_Raptor: http://guppy.eng.kagawa-u.ac.jp/~kagawa/PVH/PolymorphicVariantsInHaskell.pdf
19:17:08 <MrMetric> Could I get any advice on this?
19:17:11 <bitemyapp> Jello_Raptor: B -> WhateverBWasMissing -> A
19:17:14 <julianleviston> Jello_Raptor: I might be barking up the wrong tree there.
19:17:18 <Romefeller> MrMetric: (%) = mod
19:17:30 <bitemyapp> julianleviston: that's way more complicated than is necessary
19:17:51 <julianleviston> bitemyapp: like I said - barking up the wrong tree is totally possible :) Iâll let you deal. :)
19:17:56 <MrMetric> Romefeller: ???
19:17:58 <bitemyapp> Jello_Raptor: that pair of functions suffices for most use-cases. Can get more specific if you post code.
19:19:11 <julianleviston> :t (%)
19:19:13 <lambdabot> Integral a => a -> a -> Ratio a
19:19:26 <julianleviston> MrMetric: itâs a function.
19:19:46 <bitemyapp> MrMetric: it's an infix function, called an operator.
19:20:13 <julianleviston> MrMetric: are you attempting to define % as a new function?
19:20:31 <MrMetric> julianleviston: Yes
19:20:33 <Jello_Raptor> bitemyapp: I already use the "A -> Maybe B" as a verification step when i've defined two separate ADTs, and "isB :: A -> Bool" when I'm just using one data type. But neither of those are really satisfying :/ 
19:20:34 <julianleviston> MrMetric: â¦ because if so, you canât unless you hide it.
19:20:42 <Romefeller> hide it
19:20:45 <MrMetric> I tried to use it before that, and it said 'Not in scope'
19:20:53 <MrMetric> So it was not already defined
19:20:59 <Jello_Raptor> bitemyapp: there
19:21:08 <bitemyapp> Jello_Raptor: there what?
19:21:14 <Jello_Raptor> bitemyapp: hit enter early 
19:21:20 <nshepperd> julianleviston: (%) is not in prelude
19:21:26 <nshepperd> there's no need to hide anything
19:21:26 <julianleviston> ah ok
19:21:36 <MrMetric> I just want to know what I'm doing wrong in the definition
19:22:02 <julianleviston> sorry Iâm an idiot!
19:22:15 <MrMetric> I haven't used Haskell since February (my program ran faster in C++)
19:22:59 <julianleviston> MrMetric: possibly because you need to tell it if itâsa n Integer, Int or Word you mean when you say 4 % 2 (ie is 4 an Int, Integer or Word?)
19:23:04 <mstone> Hi. Beginner's question. A tiny program that reads two space-separated numbers from console and prints their sum: http://pastebin.com/WZqt0eky
19:23:21 <mstone> Why is the type of 'one' and 'two' inferred to be Integer?
19:23:46 <julianleviston> mstone: because youâre using (+) on them?
19:23:51 <mstone> The only thing that I see as restricting their type is applying (+) on them
19:24:01 <mstone> But (+) restricts to Num, not Integer
19:24:09 <julianleviston> mstone: true.
19:24:11 <nshepperd> MrMetric: assuming you want this thing to work on integer types, that method doesn't quite work
19:24:49 <MrMetric> nshepperd: Could you explain?
19:25:05 <nshepperd> MrMetric: (/) is true division, and doesn't exist for integer types
19:25:07 <nshepperd> :t (/)
19:25:10 <lambdabot> Fractional a => a -> a -> a
19:25:27 <MrMetric> It says my definition's type is:
19:25:29 <MrMetric> (%) :: (Integral a, RealFrac a) => a -> a -> a
19:25:49 <Axman6> that doesn't look right
19:25:53 <Jello_Raptor> bitemyapp: there's the simple "data Expr = Binop Operator Expr Expr | UnassociatedBinop Operator Expr Expr | Val Int" for A, with B as the same thing without the UnassociatedBinop constructor. We could turn B into some machine code easily, but turning a B into an A means we need to correctly associate all of the UnassociatedBinop elements into Binop elements based on the operator's associativity rule.  
19:26:02 <nshepperd> yeah, so there isn't anything that is both Integral and Fractional
19:26:03 <MrMetric> Are integer and fraction supposed to go together like that?
19:26:10 <Axman6> actually, is (%) a function you're defining?
19:26:20 <Jello_Raptor> where turning an A into a B means we ... *
19:26:21 <MrMetric> I pasted it above, yes
19:26:21 <julianleviston> Axman6:  it is.
19:26:27 <MrMetric> http://lpaste.net/144501
19:26:32 <Axman6> right, ok, don't mind me =)
19:26:42 <nshepperd> :t floor -- also, floor turns a fractional type into an integral type
19:26:43 <lambdabot> (Integral b, RealFrac a) => a -> b
19:27:10 <MrMetric> Hmm, so I'd use fromIntegral?
19:27:29 <julianleviston> @hoogle fromList
19:27:31 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
19:27:32 <lambdabot> Data.IntMap.Strict fromList :: [(Key, a)] -> IntMap a
19:27:32 <lambdabot> Data.IntMap.Lazy fromList :: [(Key, a)] -> IntMap a
19:27:52 <Lokathor> http://lpaste.net/144502 :(
19:28:00 <julianleviston> hm
19:28:02 <Lokathor> no stack on raspberry pi for now, it seems
19:28:11 <bitemyapp> Jello_Raptor: why do you have to associate to go from B -> A? Wouldn't it already be associated if it was B?
19:28:18 <bitemyapp> Jello_Raptor: what's wrong with A -> Maybe B?
19:28:32 <nshepperd> MrMetric: sure, you can use fromIntegral to turn your values into floating point, and then round to turn them back afterward
19:29:24 <MrMetric> nshepperd: I tried it, and it gave me 4 % 3 = 0.9999999999999998
19:29:32 <MrMetric> Is there a not-IEEE-float option?
19:29:34 <MrMetric> I hate that crap
19:29:53 <nshepperd> yes, there is a way to do this without using fractional types at all
19:30:01 <julianleviston> MrMetric: do you mean big decimal or something?
19:30:07 <MrMetric> julianleviston: Yes
19:30:20 <MrMetric> Like the arbitrary-precision integers Haskell has
19:30:27 <Shockk> you can use Rational which is a type alias for Ratio Integer
19:31:01 <MrMetric> Shockk: now it says 1 % 1 is the answer
19:32:04 <Shockk> hmm, what do you want to do with the result?
19:32:08 <Jello_Raptor> bitemyapp: because I need to define B as a new data structure with new constructors and keep everything in sync manually. This is especially true when I have an A, with overlapping but different subset ADTs B C and D all of which have specific non-subset relationships with each other ... 
19:32:11 <nshepperd> MrMetric: you use 'round' to turn it back to an int
19:32:15 <nshepperd> but look
19:32:24 <MrMetric> nshepperd: I don't want to do that. I want the exact answer.
19:32:27 <nshepperd> '((a / b) - floor (a / b)) * b'
19:32:37 <Jello_Raptor> bitemyapp: it just gets painful quickly :/ 
19:32:48 <nshepperd> 'a - floor (a / b) * b' -- distributive law
19:33:09 <nshepperd> now 'floor (a/b)' is just floor division, which exists for integer types
19:33:12 <nshepperd> it's called div
19:33:13 <nshepperd> :t div
19:33:14 <lambdabot> Integral a => a -> a -> a
19:33:39 <nshepperd> 'a - (a `div` b) * b'
19:34:06 <MrMetric> But what if I want to pass fractional values to it?
19:34:34 <julianleviston> MrMetric: you might need to define what you mean by âfractional"
19:34:41 <MrMetric> At least that shorter definition reduces the float error (thanks, I forgot about that)
19:34:43 <bitemyapp> Jello_Raptor: well, I have many possibilities for ameliorating this.
19:34:55 <MrMetric> julianleviston: a float, but without the inaccuracy
19:35:03 <bitemyapp> Jello_Raptor: one is to extract what they have in common to a single type, then add the extra case as a one-off w/ Either
19:35:09 <Axman6> MrMetric: there are several options for exact arithmetic in Haskell. have a look at the numeric package, which gives you CReal. edwardk wrote something else for extended precision arithmetic too
19:35:25 <julianleviston> MrMetric: what about the financial packages?
19:35:35 <bitemyapp> Jello_Raptor: you're not being too precise about where the pain is coming from, but I would guess it's pattern matching. I use kit to avoid having to fuss with any of that (lens, prisms) but I don't know if it's something you'd be able to wield yet or not.
19:35:38 <MrMetric> Axman6: doesn't it have a native type, like the arbitrary-precision integers?
19:35:45 <nshepperd> hmm, I don't know if there is any floor division operator that works for all numbers
19:35:52 <julianleviston> Data.Decimal ?
19:35:58 <bitemyapp> Jello_Raptor: isB seems pretty tedious to me. I wouldn't boolean check stuff like that.
19:36:00 <MrMetric> juliavleviston: I'm not doing finances. I just want exact math.
19:36:03 <nshepperd> MrMetric: Rational is exact for Rational numbers
19:36:17 <julianleviston> MrMetric: Finance needs exact mathâ¦ Data.Decimal ?
19:36:24 <MrMetric> nshepperd: Well, can I make it output those in normal notation?
19:36:31 <MrMetric> It said 1 % 1, but I want 1 or 1.0
19:36:32 <bitemyapp> julianleviston: it's what we use at work.
19:36:58 <nshepperd> what do you mean 'output'
19:37:01 <julianleviston> bitemyapp: yeah, Data.Decimal? was my question to him âWhy not use this?â :)
19:37:01 * hackagebot concurrent-output 1.2.0 - Ungarble output from several threads  https://hackage.haskell.org/package/concurrent-output-1.2.0 (JoeyHess)
19:37:03 * hackagebot quick-schema 0.1.0.0 - Slimmed down json schema language and validator  https://hackage.haskell.org/package/quick-schema-0.1.0.0 (benweitzman)
19:37:07 <nshepperd> 1%1 is the Rational value of 1
19:37:25 <nshepperd> MrMetric: if you want to print it in decimal notation, there are functions to do that
19:37:25 <bitemyapp> julianleviston: just offering support.
19:37:27 <MrMetric> Yes, but it says 1 % 1. I want it to say 1 or 1.0. Or, for 1 % 2, I want 0.5 instead.
19:37:30 <julianleviston> bitemyapp: <3
19:37:34 <nshepperd> i think
19:37:35 <Shockk> MrMetric means to output a Rational 1%2 as 0.5
19:37:37 <MrMetric> Or 1/2
19:37:54 <Shockk> without converting it to a floating point number first
19:38:01 <Jello_Raptor> bitemyapp: I was futzing with the Control.Lens.TH to ease the pain a bit lately :P it's helping, but I keeping on hitting cases where I can't express what I want within the haskell type system. 
19:38:05 <MrMetric> I could use the Rational type for the calculations, as long as I can make it output properly
19:38:59 <MrMetric> I will Bing it
19:41:18 <julianleviston> bitemyapp: thnx 4 email.
19:41:39 <saulzar_> MrMetric, http://stackoverflow.com/questions/30931369/how-to-convert-a-rational-into-a-pretty-string
19:42:15 <MrMetric> saulzar_: Thanks
19:43:01 <joeyh> bitemyapp: the crazy thing about https://github.com/yaronn/wopr is the pseudo-graphics.. But, my crazy idea is to make concurrent-output support regions with content of STM Text, and get regions to auto-update when the values the STM transaction read change. I think it would allow writing a interactive console spreadsheet in around 100 lines of code.
19:43:11 <MrMetric> And thanks other people, too :]
19:43:49 <nshepperd> I suppose you can do fromRational :: Rational -> Double and then print the latter
19:44:34 <MrMetric> nshepperd: But that has limited precision
19:44:35 <nshepperd> if you don't want to print with notation for repeating digits it'll be an approximate display anyway
19:44:40 <Jello_Raptor> bitemyapp: between makeLenses and shenanigans with transforming "data Foo = Bar | Buzz | Beep" into "class IsFoo where .. ; instance Bar ... ; instance Buzz ... " I can keep the same constructors around, but i need to transform everything else in ways that make it harder to understand what I'm doing. 
19:45:22 <nshepperd> do you really need unlimited precision for printing?
19:45:31 <Jello_Raptor> well, I can keep the same "constructors" around, because all my constructors have been transformed into lenses
19:45:36 <MrMetric> nshepperd: No, just more than 15 digits
19:46:03 <bitemyapp> joeyh: sweet medium switch
19:46:24 <Jello_Raptor> bitemyapp: i think i might just want dependent haskell <_<' 
19:46:24 <bitemyapp> joeyh: have you seen the spreadsheets-are-comonads stuff?
19:46:33 <bitemyapp> Jello_Raptor: it's more grief than it's worth
19:46:46 <bitemyapp> Jello_Raptor: you want to ignore details, not meticulous detail where they do and do not occur.
19:47:20 <bitemyapp> joeyh: STM container -> Region is a really good idea. I just wish I wasn't so bad at figuring out text-mode UIs :P
19:49:21 <Jello_Raptor> bitemyapp: for the moment yes. I really want it to not be though >_> 
19:50:01 <joeyh> I have seen the spreadsheet that used fix or whatever for a one-time calculation. Pretty cool
19:50:06 <bitemyapp> joeyh: actually, this could help with a dream project idea I've always wanted to work on.
19:50:52 <joeyh> well, a console spreadsheet UI is trivial, just pop up a grid of Regions, let the user arrow around and enter text
19:54:53 <Jello_Raptor> join #pbsideachannel
19:55:51 <levi> joeyh: You know, xterm has a couple of graphical modes built-in if you compile it with the right options, including a cool emulation of a TEK vector display.
19:58:33 <levi> joeyh: http://phk.freebsd.dk/AducLoran/animation2.gif
20:00:32 <joeyh> I wrote haskell code that diffs lines containing ansi escapes today. Close enough to TEK for me ;)
20:07:02 * hackagebot streaming 0.1.2.2 - an elementary streaming prelude and a general monad transformer for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.2.2 (MichaelThompson)
20:07:51 <julianleviston> I donât spose anyone can help me with my exciting problem of how to get runInterpreter from Hint to stop hijacking my Sigs?
20:09:53 <haskell471> Hi, I don't really get why the type of (zip <*>) is ([a] -> [b]) -> [a] -> [(a, b)]
20:10:06 <julianleviston> :t zip
20:10:08 <lambdabot> [a] -> [b] -> [(a, b)]
20:10:19 <julianleviston> :t (<*>)
20:10:20 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:10:42 <julianleviston> haskell471: whatâs the f there?
20:11:04 <haskell471> I guess is the list monad
20:11:12 <julianleviston> haskell471: no, itâs the list applicative.
20:11:20 <julianleviston> haskell471: see it says âApplicative f"
20:11:38 <haskell471> ya, but the type is f (a -> b), not (f a -> f b)
20:11:59 <julianleviston> haskell471: it is.
20:12:02 * hackagebot streaming-bytestring 0.1.2.2 - effectful byte steams, or: bytestring io done right.  https://hackage.haskell.org/package/streaming-bytestring-0.1.2.2 (MichaelThompson)
20:12:08 <julianleviston> :t (zip <*>)
20:12:10 <lambdabot> ([a] -> [b]) -> [a] -> [(a, b)]
20:12:41 <julianleviston> so what does zip take?
20:12:42 <haskell471> oh so f (a->b) and (f a -> f b) is the same thing?
20:12:46 <haskell471> a list
20:12:50 <haskell471> 2 list
20:13:04 <julianleviston> :t zip
20:13:06 <lambdabot> [a] -> [b] -> [(a, b)]
20:14:30 <dibblego> it's the reader applicative
20:14:34 <dibblego> not list
20:14:36 <julianleviston> haskell471: no I donât think f (a -> b) is the same as f a -> f b
20:14:48 <dibblego> all functions in Haskell take one argument
20:14:52 <julianleviston> oh then I donât know what Iâm talking about and Iâll be quiet.
20:15:10 <julianleviston> haskell471: sorry for muddying your water.
20:15:36 <pavonia> :t (<*>) `asAppliedTo` (undefined :: a -> b -> c)
20:15:37 <lambdabot> (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
20:16:48 <haskell471> if zip is the first argument, then f (a -> b) == [c] -> ([d] -> [(c,d)])
20:17:05 <jle`> yes
20:17:25 <jle`> so we can start matching things up
20:17:36 <haskell471> but how to get f?
20:17:51 <jle`> f (a -> b) ~ [c] -> ([d] -> [(c, d)])
20:18:09 <jle`> rewrite (->) it in prefix form, and you get
20:18:27 <jle`> f (a -> b) ~ ((->) [c]) ([d] -> [(c, d)])
20:18:31 <jle`> so f ~ (->) [c]
20:20:01 <jle`> and a ~ [d]
20:20:05 <jle`> b ~ [(c, d)]
20:20:37 <jle`> f matches up with ((->) [c]), a matches up with [d], and b matches up with [(c,d)], etc.
20:20:50 <julianleviston> God. I know nothing.
20:21:03 <julianleviston> well, I have a lot to learn.
20:21:20 <jle`> you're trying to fit f (a -> b) with ((->) [c]) ([d] -> [(c, d)])
20:21:33 <jle`> and you can look at it visually... a is [d], b is [(c, d)], and f is ((->) [c])
20:21:40 <Romefeller> julianleviston: No one knows nothing. You are better than a PHP programmer for sure lol
20:22:02 <jle`> it's the only way it can "match up".  or, to be more technical, it's how they unify
20:22:19 <Romefeller> every
20:26:11 <haskell471> since zip = f (a -> b), I can remove it, so I only have to find f a -> f b,  ((->) [c]) [d]) -> ((->) [c]) [(c,d)]) == ([c] -> [d]) -> [c] -> [(c,d)]
20:26:14 <haskell471> woaah
20:27:58 <haskell471> thanks guys!
20:29:37 <julianleviston> jle`: thanks.
20:29:52 <julianleviston> dibblego: also thanks.
20:32:03 * hackagebot pcre-light 0.4.0.4 - Portable regex library for Perl 5 compatible regular expressions  https://hackage.haskell.org/package/pcre-light-0.4.0.4 (DanielDiaz)
20:37:03 * hackagebot streaming-utils 0.1.2.2 - http, attoparsec, pipes and conduit utilities for the streaming libraries  https://hackage.haskell.org/package/streaming-utils-0.1.2.2 (MichaelThompson)
20:47:07 <haskell471> applying the same method on (head <*>) give a weird result, I don't get why it's compile 
20:47:10 <haskell471> :t head
20:47:11 <lambdabot> [a] -> a
20:47:39 <haskell471> f (a -> b) == [c] -> c 
20:47:50 <haskell471> f == (-> [c])
20:47:54 <haskell471> a == c
20:48:02 <haskell471> b == ???
20:48:31 <pavonia> c ~ a -> b
20:48:50 <haskell471> why?
20:50:17 <kadoban> :t (<*>)
20:50:18 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:51:04 <haskell471> wait, since we already have f == ((->) [c]), (a->b) == c
20:52:06 <haskell471> so f == ((->) [a->b])
20:52:37 <mniip> no why
20:52:41 <mniip> head <*> is a type error
20:52:52 <haskell471> :t (head <*>)
20:52:53 <lambdabot> ([a -> b] -> a) -> [a -> b] -> b
20:53:06 <haskell471> f a == [a->b] -> a
20:53:20 <haskell471> f b == [a ->b] -> b
20:54:11 <mniip> ...
20:54:16 <mniip> oh
20:54:22 <mniip> sorry, dumb me
20:54:44 <Myrl> pfft
20:54:57 <haskell471> I had the same reaction as you like 10 minutes ago hahaha
20:55:00 <mniip> in my defence, it's 8 am
20:55:08 <mniip> 8 am in the evening
20:55:41 <mniip> so yeah, if head :: [c] -> c, and ap :: f (a -> b) -> f a -> f b
20:56:07 <mniip> then 'ap head' implies f (a -> b) ~ [c] -> c
20:56:17 <mniip> f ~ (->) [c]
20:56:25 <mniip> a -> b ~ c
20:56:30 <mniip> right
20:57:19 <mniip> eliminating c, we get ap head :: ([a -> b] -> a) -> ([a -> b] -> b)
21:01:30 <mniip> Myrl, wanna look at some fancy stuff
21:04:47 <Myrl> mniip: ye, sure.
21:04:49 <Myrl> mniip: show meh.
21:05:02 <mniip> Myrl, https://github.com/mniip/finite-typelits
21:05:05 <smudkavi> Hey, so Iâve had a few courses in scheme and have done quite a bit of C, python and Java/Scala programming. What would be the appropriate place to jump into haskell? (Iâve just picke dup learn you a haskell and strated from the beginning but wanted to know if I should fast forward to any part of it?)
21:07:37 <dford> Hello I am trying to use alex in my project, and things are working fine by using cabal. But if I try to use inbuild function of alex like 'begin' 'andBegin' the compilation fails
21:08:00 <mniip> oh for real
21:08:02 <Myrl> mniip: I'm lost.
21:08:04 <dford> I checked the Lexer.hs file and it does not contain any definition of 'begin' 'andBegin'
21:08:07 <mniip> you're going to emerge ghc for the third time now
21:08:57 <dford> anyone has idea what might be wrong?
21:09:27 <mniip> Myrl, hmm?
21:09:58 <Myrl> mniip: Too busy ASMing.
21:11:01 <KaneTW> smudkavi: haskellbook.com is what i recommend
21:11:06 <KaneTW> if you want free resources,
21:11:08 <KaneTW> @where learnhaskell
21:11:08 <lambdabot> https://github.com/bitemyapp/learnhaskell
21:11:30 <mniip> Myrl, can you asm do the category of linear spaces
21:11:44 <KaneTW> i don't really recommend fast forwarding too much
21:11:53 <smudkavi> KaneTW: Thanks, Iâll check it out
21:12:08 <mniip> your*
21:12:08 <KaneTW> there are some details here and there in allen's haskell book that i wish i had known when i was learning haskell
21:17:04 * hackagebot range-set-list 0.1.1.0 - Memory efficient sets with continuous ranges of elements.  https://hackage.haskell.org/package/range-set-list-0.1.1.0 (phadej)
21:17:09 <Myrl> mniip: =-=
21:22:35 <lethjakman-l> So, when you use RecordWildCards to construct, it takes all the above variables and shoves them into the object you're constructing, right?
21:22:38 <lethjakman-l> How do I skip one?
21:25:11 <julianleviston> I have a Request value (from Snap.Core) and Iâd like to coerce it to a string and back into a Request objectâ¦ but the âdefaultâ Show instance seems to be â¦ well, kind of âhuman pretty-printedââ¦ what is a good way to coerce it through string? Should I use an intermediate proxy data type or something?
21:26:00 <Axman6> lethjakman-l: what do you mean by "skip one"?
21:26:07 <julianleviston> FWIW this is the API: https://hackage.haskell.org/package/snap-core-0.9.8.0/docs/Snap-Core.html#t:Request
21:26:46 <julianleviston> ohâ¦ it doesnât have a Read instance. 
21:26:59 <Axman6> julianleviston: coerce is not the right word :P 
21:27:08 <julianleviston> Axman6: what word would you use?
21:27:08 <Axman6> why do you need it as a string?
21:27:16 <julianleviston> Axman6:  I donât.
21:27:50 <julianleviston> Axman6: I have it in one environment (Snap server) and I want to put it into another one (GHC/Hint Interpreter code context)
21:27:52 <Axman6> convert or transform, coerce more often than not means keeping the representation and using it as a new type
21:28:04 <julianleviston> ah sorry
21:28:14 <julianleviston> I donât want to convert it or transform it
21:28:34 <Axman6> there might be ways to do it with generics or something, do you know what classes it is an instance of?
21:28:36 <julianleviston> I want to dehydrate/rehydrate it.
21:28:58 <julianleviston> I have the types in both envsâ¦ 
21:29:08 <julianleviston> the thing I want to move is some data of that type.
21:29:46 <Axman6> I don't understand
21:29:48 <julianleviston> I have to have some way to transfer itâ¦ and through string is my current best wayâ¦ maybe I should use Aeson instead.
21:30:17 <julianleviston> Axman6: the same way show/read roundtripping works on an Integer, for example.
21:30:29 <Axman6> right
21:30:30 <julianleviston> Axman6:  do you understand?
21:30:50 <Axman6> I understand that part, but not how the GHC API is involved
21:30:50 <julianleviston> Request -> String then String -> Request
21:30:55 <julianleviston> Axman6:  ok.
21:31:03 <julianleviston> Axman6:  soâ¦ I have a web app written in snap
21:31:03 <sleblanc> Have a MyTypeDehydrator implement read and show?
21:31:07 <Axman6> yes
21:31:29 <julianleviston> Axman6:  it also hosts a Hint interpreter monad that evaluates code from string data read from a DB.
21:32:38 <julianleviston> Axman6:  I want to âtransmitâ the Request data to the execution/evaluation context within which the interpreter runs the code it gets from the database.
21:32:58 <julianleviston> Axman6: I can do it pretty easily if I just send parts of the Request, so perhaps I should stick to that.
21:33:44 <julianleviston> Axman6:  Iâve looked at the Request data type, and itâs farily huge and involves all kinds of things I donât really need. All I really need is the host, context path, query params and perhaps eventually the cookie info.
21:34:17 <julianleviston> Axman6: I think I answered my own question :)
21:34:22 <julianleviston> Axman6: thanks :)
21:35:18 <julianleviston> sleblanc: oh I missed that. sorry. Would that just take a request and then pull the pieces I need out and then â¦ oh thatâs  a great idea. Yay :)
21:35:37 <Axman6> 'welcome =)
21:35:45 <julianleviston> thanks both.
21:39:19 <kqr> is there a reason Control.Lens.at works the way it does? I expect to be able to do myMap ^? at "person" . at "name" but this appears to not be how `at` is used
21:40:42 <kqr> where myMap is a Map String (Map String String)
21:40:50 <kqr> or whatever
21:42:05 <Axman6> you probably need at "foo" . _Just . at "bar" by the looks of it
21:42:05 * hackagebot oidc-client 0.2.0.0 - OpenID Connect 1.0 library for RP  https://hackage.haskell.org/package/oidc-client-0.2.0.0 (ShoKuroda)
21:42:22 <kqr> yeah, that'd probably work but it's not what I want
21:42:47 <kqr> feels like lens should be able to do nested access in maps in a clean way
21:42:51 <Axman6> I agree, you might be able to use ix instead
21:43:08 <kqr> didn't quite get it to work with ix either, but that might be my inexperience with it
22:07:10 <Lokathor> it seems like the "it just works" vibe of stack is less stack and more the lts system it uses
22:07:30 <Lokathor> and that cabal + a cabal.config for a given lts would be essentially the same thing
22:08:09 <julianleviston> Lokathor: yeah sometimes a âtoolâ is just good PR around a convention and wrapperingâ¦
22:08:30 <Lokathor> alright
22:08:44 <Lokathor> well that little project bit is done... on to the work of bug reporting
22:09:01 <Lokathor> ghc gave me this earlier, http://lpaste.net/144502
22:09:15 <Lokathor> but it's for 7.8 so i don't know if i should bother to report it
22:10:14 <mgsloan> There are a number of ways stack's "it just works" vibe goes beyond using cabal with stackage.  Off the top of my head:
22:10:37 <mgsloan> 1) It enusres the right GHC version is installed, and if it isn't, "stack setup" can install it for you
22:11:03 <mgsloan> 2) It never complains about breaking packages, because it always unregisters old local packages
22:11:27 <mgsloan> 3) It doesn't require you to do a "configure" step, instead it knows when it needs to configure
22:12:21 <bitemyapp> @karma+ mgsloan
22:12:21 <lambdabot> mgsloan's karma raised to 5.
22:12:25 <julianleviston> mgsloan: sorry, didnât mean to trivialize stack. I think my experience of Haskell would be terrible without it.
22:12:28 <linman32> how does one install structured-haskell-mode for emacs with stack? is it any different from a cabal installation?
22:12:59 <Lokathor> i'm also not saying to not use stack
22:13:37 <mgsloan> Yup yup, I'm just explaining that the "just works" goes deeper :)
22:14:33 <Lokathor> however
22:15:03 <kadoban> Lokathor: Before I moved to 'stack', I was actually using stackage and cabal-install. It's a /huge/ improvement going to 'stack'. So much less tedious having GHC installed for me and not having to manage sandboxes manually. It's also hugely less compiling since stack is better at tracking when it can reuse a sandbox than I ever could safely be.
22:15:13 <Lokathor> consider that (with a sandbox of course) if you're using a LTS then you're not likely intalling a package more than once
22:15:19 <kadoban> It'll be even better as stack improves, as it quickly seems to be doing.
22:15:33 <Lokathor> more than once per sandbox that is
22:15:39 <bitemyapp> Lokathor: that's not true true in my experience.
22:15:51 <bitemyapp> Lokathor: even within a single project, I would occasionally get into weird states that would require nuking my sandbox.
22:16:04 <bitemyapp> Lokathor: now I'm reinstalling _everything_ all over again. That has never happened to me w/ Stack.
22:16:09 <bitemyapp> not true in my*
22:16:14 <bitemyapp> don't know why I repeated 'true'
22:16:22 <bitemyapp> my production grammars must be buggy.
22:16:27 <Lokathor> true true != false true
22:16:43 <kadoban> Indeed, the weekly "nuke it all and start again" part gets really tedious.
22:17:08 * Lokathor goes back to lamenting haskell's general poor showing in the ARM realm
22:17:20 <bitemyapp> sandboxes made things more likely to just work in a fresh build, it didn't eliminate the nuke cycle.
22:17:27 <bitemyapp> it _reduced_ it
22:17:31 <bitemyapp> but didn't eliminate it.
22:17:41 <bitemyapp> I can't say exactly why. seemed like something slightly different each time.
22:19:41 <linman32> are emacs modes installed any differently with stack? e.g. structured haskell mode
22:21:14 <kadoban> Yeah I could never figure out exactly why my setup always got all messed up. Sometimes simple user error of course, but other times it'd just be a mystery. Basically it's just too fragile.
22:21:18 <mgsloan> linman32: Stack doesn't have much to do with the elisp side of things.  "stack install structured-haskell-mode" to install it using your global config
22:22:24 <witt3rd> foo :: S.Set a -> S.Set b -> Bool
22:22:25 <witt3rd> foo a b = a == b
22:22:28 <witt3rd> why can't i compare two sets that _may_ have different types? 
22:23:25 <jle`> witt3rd: what would (==) be implemented as?
22:23:27 <pavonia> Because (==)'s typ doesn't let you do that
22:23:37 <linman32> mgsloan: thanks
22:24:12 <witt3rd> when a and b are, say, both Int, then why wouldn't this be legal?
22:24:48 <kadoban> witt3rd: Because the type system is there to /ensure/ what you're doing makes sense, not that it kinda, sorta /might/ make sense sometimes.
22:25:26 <kadoban> (not that it always does or can, but that's the goal anyway)
22:25:30 <witt3rd> i would expect this to fail if the types didn't match, but to be ok if the types did
22:25:35 <liste> witt3rd you can do that with Typeable
22:25:50 <jle`> witt3rd: you can actually specify that invariant in your type signature
22:25:57 <jle`> "this will work if the types don't match, but it will work if they do"
22:26:05 <jle`> watch this: foo :: Set a -> Set a -> Bool
22:26:13 <jle`> now it'll only compile if you call `foo` with two sets of the same type :)
22:26:41 <witt3rd> hmmm :-)
22:26:43 <Lokathor> recall the type of (==) to begin with
22:26:46 <Lokathor> :t (==)
22:26:47 <lambdabot> Eq a => a -> a -> Bool
22:26:50 <jle`> witt3rd: "Set a -> Set b -> Bool" means "give me a Set of any type and a Set of any other type, and I'll give you a Bool"
22:27:01 <jle`> witt3rd: so it has to be callable with any a, any b
22:27:16 <jle`> Set a -> Set a -> Bool means, "Give me a Set of any type a and a Set of the same type a, and I'll give you a Bool"
22:27:31 <jle`> the two type signatures mean tow different things and give you two different compile-time guaruntees
22:27:56 <jle`> foo a b = a == b doesn't jive with what Set a -> Set b -> Bool "means"
22:28:09 <liste> witt3rd but you don't even need to compare two sets with different types, because you need they're not equal
22:28:09 <jle`> what it says, as a type signature
22:28:10 <kadoban> Well said.
22:28:21 <witt3rd> ok, I understand.  Let me reformulate my problem.  thanks!
22:28:27 <liste> unless you define two empty sets of different types be equal
22:29:01 <Lokathor> i did it, i wrote a whole bug ticket
22:36:11 <witt3rd> I might have Set Int and Set String, in which case this operation should fail.  But in another case I might have Set Int and Set Int, in which case I need to do the set comparison.  Is there a way I can test these things?
22:36:38 <liste> witt3rd it doesn't even compile if you have Set Int and Set String
22:36:50 <liste> if the type is Set a -> Set a -> Bool
22:37:01 <liste> so no need to test
22:38:02 <pavonia> witt3rd: Are Int and String the only set types that might occur?
22:38:48 <witt3rd> no, they might be any two types.  if the types don't match, then this is not a valid operation.  if the types do match, then it might be a valid operation if they are the same sets
22:39:15 <liste> > (fromList [1,2] :: S.Set Int) == (fromList "ab" :: S.Set Char) -- doesn't compile
22:39:18 <lambdabot>      Couldn't match type âCharâ with âIntâ
22:39:18 <lambdabot>      Expected type: S.Set Int
22:39:18 <lambdabot>        Actual type: S.Set Char
22:39:31 <pavonia> witt3rd: What should happen if the types don't match?
22:39:47 <witt3rd> my function returns a Maybe, so Nothing
22:41:33 <pavonia> You can probably do it with some type class hackery
22:41:43 <liste> witt3rd you can use Typeable and `cast', but you should make it a compile time error if possible
22:41:49 <kadoban> witt3rd: That's kind of something you'd do in a dynamically typed language. IIUC you can do it via something like Typeable or whatever actually makes sense, but â¦ you shouldn't.
22:41:52 <liste> is it possible to make it a compile time error?
22:42:41 <witt3rd> think of a generic composition operation
22:43:12 <witt3rd> a -> b, b -> c == a -> c
22:43:27 <witt3rd> this only works when the b's are the same
22:43:42 <witt3rd> but those arrows are general maps
22:44:05 <witt3rd> so it could map from Int to Char, Char to String
22:44:21 <liste> @type (.)
22:44:22 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:45:00 <jle`> witt3rd: the way you usually specify that a function won't compile if types don't match is by using the same type variable
22:45:24 <jle`> it sounds like you might have an XY problem here
22:45:43 <witt3rd> so it could map from Int to Char, Char to String
22:45:55 <witt3rd> (oops)
22:46:52 <witt3rd> I did actually do that (use the same type variable) -- perhaps I've messed something up there
22:47:17 <witt3rd> (I clearly didn't do it in my toy example)
22:50:03 <witt3rd> ok.  that was the right answer.  use the same type variable.  I had them swapped in my actual code.  thanks all!
23:59:40 <shanemikel> one thing I'm having minor troubles with is the application of infix functions, mixed with others, as well as prefix functions.. that is, I find myself adding unnecessary parenthesis all over the place because It's not that intuitive
23:59:57 <shanemikel> precedence, that is
