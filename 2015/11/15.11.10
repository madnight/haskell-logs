00:00:07 <nchambers> > data Foo = Foo Float Float
00:00:08 <lambdabot>  <hint>:1:1: parse error on input ‘data’
00:00:55 <nchambers>     data Person = Person String String Int Float String String deriving (Show)  -- why is Person at the beginning of the = sign? I understand what it does on the left side, but not the right side
00:01:13 <shachaf> They are two different Persons
00:01:24 <cocreature> nchambers: on the right hand side it's the data constructor on the left hand side it's the type
00:01:24 <shachaf> data X = Y String Int
00:01:39 <shachaf> That means that (Y "foo" 5) is a value with type X.
00:02:00 <nchambers> hrmmm... ok
00:02:07 <shachaf> oops, bad string
00:05:07 <nchambers> ok, then let me ask this... I have in my source file `data State = NONE | WS | CMT | WRD | NMBR | STR | SYM deriving (Enum, Eq, Show)` which works as I expected to (I treated it like one would an enum in C). Why does it not need a data constructor
00:05:32 <cocreature> NONE, WS, … are data constructors
00:05:35 <shachaf> It has seven data constructors.
00:05:38 <cocreature> they just don't take any arguments
00:05:52 <nchambers> *lightbulb*
00:06:06 <nchambers> thanks guys!
00:41:17 <sedeki> hello all. I'm wondering why there must be a "monad" type constructor in the definition of a monad. why isn't just the bind function enough?
00:42:09 <liste> sedeki you mean the typeclass?
00:42:14 <liste> Monad ?
00:42:31 <sedeki> https://en.wikibooks.org/wiki/Haskell/Understanding_monads#Definition
00:42:34 <sedeki> type constructor
00:42:56 <liste> ahh, m
00:43:49 <liste> technically you could define a bind for each specific monad, but then you couldn't use the same symbol for all
00:43:52 <quicksilver> sedeki: really it's just there to help type inference by giving a uniform structure
00:43:57 <liste> (or the same identifier actually)
00:44:21 <liste> bindMaybe, bindList, bindIdentity, bindReader etc...
00:44:33 <sedeki> quicksilver: yeah that makes sense
00:44:34 <quicksilver> if you didn't have a type constructor, what would the signature of bind be, exactly?
00:44:36 <sedeki> yeah
00:44:39 <quicksilver> :t (>>=)
00:44:41 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:45:05 <sedeki> i mean, "m a" is a type right?
00:45:14 <sedeki> why not just "a"
00:45:23 <quicksilver> because it's not just "a"
00:45:49 <sedeki> what do you mean by uniform structure?
00:45:50 <quicksilver> it's something more than a, in general
00:45:52 <sedeki> exactly
00:46:11 <quicksilver> you have two, things >>= and return
00:46:16 <quicksilver> you need to be able to talk about their types
00:46:18 <quicksilver> :t return
00:46:20 <lambdabot> Monad m => a -> m a
00:47:56 <quicksilver> you could have return :: a -> x and (>>=) :: x -> (a -> y) -> y
00:48:21 <quicksilver> but you'd also need to have a story to explain that x was "related to a" somehow, and y was "related to some b, not mentioned"
00:48:34 <quicksilver> the type constructor is a choice of how to model that.
00:49:23 <jle`> there are definitely a bunch of monads, but you need a "type constructor" for the Monad typeclass
00:49:41 <jle`> it's not a part of the definition of what a monad is; it's a part of how the Monad typeclass works
00:51:03 <quicksilver> jle`: the relationship between 'a' and 'x' is very much a part of a definition of what a monad is. Forcing it to actually be a type constructor is a Haskell limitation but there has to be *some* association of types going on.
00:53:13 <frerich> sedeki: In Haskell, a type constructor is a natural way to express that two types are related, e.g. in 'a -> Maybe a' you're saying that it's the same type 'a' in both cases. In other languages (say, JavaScript) you might just write 'function bind(v, f) { ... }' so the relation between what 'v' is and what 'f' does are much more implicit. But they are still there.
00:54:34 <frerich> sedeki: I.e. the relationship between the value 'v' and the argument taken by 'f' is very essential to monads. The fact that -- in Haskell -- this is expressed used type constructors is just because it's a nice way to express this relationship.
00:58:32 <sedeki> quicksilver, frerich: hmm yeah.
00:58:45 <sedeki> these things sort of answered my questions.
01:15:58 <kgorelov> Hello there. I've encountered a problem using xmonad 0.11.1 (xmonad installed from cabal, Xorg 1.17.1, ubuntu 14.04 lts). Xmonad seems to swallow mod-slash key combination, so that I can't use it in emacs anymore. Instead of receiving meta-slash, Emacs window (well, any X window in fact) receives a FocusOut event. Has anyone faced this problem?
01:40:10 <esg> any suggestions for a package implementing c library bindings for studying good practices?
01:47:35 <quicksilver> kgorelov: there is an xmonad channel, I think. 
01:49:18 <pavonia> esg: gtk perhaps
01:50:23 <esg> pavonia: thanks, i'll have a look.
01:55:05 <quicksilver> well gtk had a lot of particular issues to deal with
01:55:07 <quicksilver> massive API
01:55:18 <quicksilver> unusual C object system
01:55:26 <quicksilver> they wrote a bunch of tools
01:55:32 <quicksilver> it's not the most typical FFI :)
01:56:34 <tdammers> gtk is one of those projects that stubbornly insisted on implementing a special-purpose higher-level language as an EDSL within C
01:56:52 <bartavelle> esg, bindings with interpreters (at least lua, python or ruby exist), because they would show you how to interopt with both sides
01:56:54 <kgorelov> This channel was mentioned on the xmonad web site, that's why I came here. Now I see the xmonad channel in the channel list, thanks.
01:56:55 <bartavelle> might be complex thouhg
01:58:05 <Saki-saki> Why is sum not defined as `getSum . foldMap Sum` ?
01:58:55 <kqr> Saki-saki, performance reasons, I suspect
01:59:30 <Saki-saki> kqr: Theoretically, that should be faster.
02:00:20 <quicksilver> Saki-saki: it is.
02:00:23 <Saki-saki> kqr: foldl/r is not parallelizable. Monoid fold is.
02:00:25 <quicksilver> well, pretty damn close.
02:00:33 <quicksilver> sum = getSum #. foldMap Sum
02:00:39 <quicksilver> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html#sum
02:00:42 <Saki-saki> quicksilver: Holy cow.
02:00:48 <Saki-saki> quicksilver: :o
02:01:08 <Saki-saki> quicksilver: I'm quite shocked that I actually said something reasonable for once.
02:01:23 <quicksilver> Monoid fold is not parallel for any Foldable instance in base :)
02:01:28 <quicksilver> certainly not for lists.
02:01:42 <quicksilver> but that defintion certainly has some elegance
02:01:53 <Saki-saki> quicksilver: What does #. do?
02:02:01 <Saki-saki> It says something about coercion.
02:02:10 <quicksilver> Saki-saki: it cheats and uses Data.Coerce but has the same meaning as .
02:02:15 <kqr> holy crap List.sum is defined in terms of foldl? nice.
02:02:48 <Saki-saki> quicksilver: Still a better choice than foldl/r though.
02:03:15 <Saki-saki> quicksilver: Also, it can be parallel.
02:03:17 <kqr> also I just realised hackage haddock sources use all kinds of hyperlinking and stuff. that's beautiful
02:03:19 <Saki-saki> Even for lists.
02:03:21 <quicksilver> tdammers: I haven' tlooked closely I must admit but many C libraries are horrible because they don't use proper data structures. The GTK team made a good choice to step back and build a proper, modern, data structure framework for their code. I'm sure there are places where they made the wrong call.
02:03:32 <quicksilver> Saki-saki: it can, but then it stops being maximally lazy
02:03:35 <quicksilver> it's hard to win :)
02:03:42 <Saki-saki> quicksilver: True. :s
02:03:48 <quicksilver> I mean, it's hard to decide a 1-size-fits-all approach which is always the best.
02:03:53 <quicksilver> s/hard/impossible/;
02:04:34 <Saki-saki> quicksilver: Well, we can just define fold for lists with foldl/foldr anyway.
02:04:34 <tdammers> quicksilver: oh, what they did is pretty solid, I'm not questioning that
02:04:41 <Saki-saki> quicksilver: Doesn't really matter.
02:04:52 <tdammers> quicksilver: I'm just thinking that in hindsight, using an actual higher-level language may have been the better choice
02:05:11 <tdammers> quicksilver: but then, Qt did that, and look what we got :x
02:05:25 <Saki-saki> quicksilver: Thanks by the way.
02:06:02 <quicksilver> tdammers: ah yes. Well there was no appropriate higher-level language for building a reliable portable library to be used from {C and other languages}
02:06:17 <quicksilver> tdammers: to some extent that is still true :( 
02:06:44 <tdammers> quicksilver: agree.
02:09:24 <nani___> tdammers what's wrong with qt?
02:09:59 <esg> bartavelle: will look, lua at least is not too immense, so the bindings might be possible to grok
02:12:33 <bartavelle> also the hslua package is self-contained (it embarks a C LUA implementation)
02:12:58 <Saki-saki> bartavelle: embarks?
02:13:03 <Saki-saki> esg: Lua is awesome. :D
02:13:42 <bartavelle> the C LUA interpreter is part of the package and built with cabal
02:13:54 <Saki-saki> A statically-typed, strongly-typed Lua with 0-indexing would probably be my favorite imperative language.
02:13:58 <Saki-saki> bartavelle: Also, it's Lua, not LUA.
02:14:03 <statusfailed> jophish: :D
02:14:17 <bartavelle> I stand corrected
02:14:57 <Saki-saki> quicksilver: Also, why #. rather than just .?
02:15:56 <quicksilver> Saki-saki: it's an optimisation to avoid actually doing any work
02:16:08 <quicksilver> Sum Int and Int are actually the same representation in memory
02:16:14 <quicksilver> so 'getSum' should do nothing at all, at runtime
02:16:23 <quicksilver> but in some cases that doesn't work right
02:16:33 <Saki-saki> quicksilver: I see.
02:16:34 <quicksilver> so GHC has a class called 'Coercible' for things which are actually the same
02:16:46 <quicksilver> and .# is using Coercible to make sure it does nothing.
02:28:07 <Heather> Xandaros en taro Adon
02:35:21 <Heather> seems like there is weak situation with aeson/yaml
02:35:41 <Heather> .:? means actually that option is optional and it reflects as Maybe
02:36:03 <Heather> but when you write Maybe to config file then there should no be such column at all
02:36:13 <Heather> however column is creating with null value
02:36:26 <Heather> and then this .:? fails in reading it
02:37:10 <Heather> e.g. - it's Maybe but Maybe because column may not exist at all, not because there could be null, null brings fault
02:37:19 <Xandaros> It should be able to read it, if it is null... you might want to report that
02:37:38 <Xandaros> Also, "en taro Adon"?
02:37:50 <Heather> Xandaros yes, Adun, not Adon, typo )
02:38:02 <Xandaros> no clue
02:39:06 <Heather> Xandaros I've packaged and tested this behavior on your project https://github.com/Heather/gentoo-heather/commit/a97fbce2507f38a03653d3a5faff2022ca43b109
02:39:53 <Heather> Xandaros tool fails when second option is present but null
02:40:30 <Heather> Xandaros what is rate limit? :)
02:41:13 <tdammers> starcraft reference
02:41:24 <Xandaros> GitHub doesn't want you to poll five times a second, so they send you a number of seconds till you are allowed to poll again
02:41:30 <Xandaros> They don't enforce it, but I stick to it
02:41:32 <tdammers> "en taro Adún" is a protoss idiom
02:41:59 <tdammers> Heather: is this still the "it works on Windows but not Linux" thing?
02:42:02 <Xandaros> I have it default to 60 seconds, since that seems to be what they usually send back
02:42:03 <Heather> it's just "hello"
02:42:22 <Heather> tdammers didn't tested on windows so far
02:42:40 <Heather> Xandaros config takes seconds?
02:43:05 <Xandaros> It's not in the config. Config only has token and timeout
02:44:02 <Heather> I see
02:44:08 <tdammers> anyway, how did you create your ToJSON instance?
02:44:47 <tdammers> IIRC there are options you can set to leave out Nothings entirely vs. having them produce NULLs
02:45:07 <Xandaros> Mine doesn't actually have one. But I assume the ToJSON instance of Maybe produces the nulls
02:46:05 <tdammers> yes, that's what the ToJSON instance for Maybe does
02:46:09 <Heather> tdammers same way as normal with .=
02:46:21 <Heather> tdammers maybe there is special case for ToJSON?
02:46:24 <Heather> and maybies
02:46:41 <tdammers> there is an option to deriveToJSON that you can use
02:46:55 <tdammers> such that record fields that are Maybes aren't added to the JSON object when their value is Nothing
02:47:33 <Heather> tdammers I need it to fix this problem :/ just can't find it
02:47:38 <tdammers> http://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson-TH.html
02:47:54 <tdammers> `omitNothingFields`
02:47:59 <Xandaros> I do think it should be able to understand null as Nothing, though
02:48:01 <Bugdet> How is this expression "\(T : * -> * -> * -> *) -> ..." desugared in Morte? I do not understand, because "*" and arrow (->) aren't part of the grammar of Term. There is just: Const, Var, Lam, Pi, App
02:48:07 <tdammers> Xandaros: why not?
02:48:13 <tdammers> nm
02:48:14 <tdammers> misread
02:49:51 <Heather> Xandaros yes, it will be just workaround over bug in my opinion or at least omitNothing should be default True
02:50:06 <Heather> Xandaros however currently I want to apply this workaround
02:51:06 <Xandaros> Yeah, well. omitNothing false is a fine default imo, it just needs to be able to read it back in again. Missing value and value set to null should be treated the same. (Not sure if it actually says that in the standard, but that's how I understand null)
02:52:31 <Xandaros> Nope, it doesn't describe the meaning of null at all
02:52:53 <tdammers> the standard doesn't care
02:53:29 <tdammers> but as far as JSON semantics go, "absence of a key in an object" and "key in an object pointing to the NULL value" are not the same thing
03:03:25 * hvr actually relies on that difference sometimes
03:03:58 <quicksilver> have to admit I'd have expect omitNothingFields to be True by default. I very rarely see JSON using 'null' for something useful
03:04:14 <hvr> ...but makes life a bit harder for ppl writing JavaScript
03:04:59 <hvr> as those often don't differentiate properly those two different states
03:05:05 <quicksilver> but if the derived instance can't round trip that does just sound broken
03:05:13 <tdammers> javascript is a bit weird that way
03:05:32 <tdammers> in that it has two different notions of "no value given" - null, and undefined
03:05:50 <Heather> hm.... it's harder to do with yaml
03:07:06 <Fylwind> Twitter made some weird change where their statuses would return certain fields with 'null' instead of omitting them … which broke the twitter-types library on Hackage as the status would fail to parse
03:08:36 <lmj> DataKinds is convenient because it removes the need for tagging, however I wonder if it's meant for general use. One needs to import GHC.TypeLits and propagate KnownNat around. It seems like KnownNat prevents quickCheck testing, or at least easy testing.
03:11:45 <quicksilver> it's experimental
03:12:00 <quicksilver> things like "the best way to use quickCheck testing with it" are part of the experiment
03:12:05 <quicksilver> and if you use it, you're part of the experiment too :)
03:15:39 <rmrfroot> does anyone have a good strategy for writing hspec tests that makes sure given json text could be decoded into expected data type?
03:18:46 <lmj> uploading something to hackage that has "import GHC.TypeLits" seems questionable. On the other hand integer types are super convenient and clean up the code.
03:19:42 <lmj> I'm still balancing the trade-offs in my mind.
03:21:18 <eikke> lmj: why would it be questionable to put something using typelits on hackage?!
03:26:11 <nshepperd> I would venture that most packages on hackage are non-portable
03:28:26 <nshepperd> ghc has a lot of advantages over the haskell report still
03:29:14 <lmj> eikke: it seems likely to break at some point, being dependent upon GHC internals. The typelit documentation indicates that it's still a work in progress.
03:30:10 <eikke> lmj: then fix your 'base' bounds in the cabal file?
03:31:23 <lmj> eikke: well saying something like base == 4.8 carries its own set of problems.
03:32:44 <Heather> fixed!
03:33:29 <Heather> weak but this is fixing problem with nulls https://github.com/Heather/Sharingan/commit/bc0cf584b59d4daffb1a18df27bdb10ab2adf87d
03:40:26 <rmrfroot> what's the pragma called that allows something like this: `type Endpoint a = EitherT ServantErr IO a`
03:41:28 <ski> not seeing why you'd need a pragma for that ..
03:42:39 <rmrfroot> ski: nvm, i spelt `Endpoint` wrong when i was using it in my function :P
04:05:04 <KaneTW> servant is cool
04:15:01 <rmrfroot> KaneTW: yeah :) 
04:44:51 <SX> Hi!
04:45:00 <Heather_> рш
04:45:03 <SX> Tell me please, what to use for GUI apps?
04:45:09 <Heather_> gtk2hs
04:45:31 <SX> What about keera hails? Is it good?
04:45:56 <Heather_> SX never heard about it :)
04:48:56 <SX> Heather_ https://github.com/keera-studios/keera-hails/
04:54:45 <Rc43> I forgot, what's the name of profiling lib for Haskell?
04:55:04 <Rc43> It provides report as js page
04:55:09 <MasseR> criterion?
04:55:47 <Rc43> Masser, yep! Thanks, tried to google it but bouldn't find
05:11:38 * hackagebot swagger2 0.3 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-0.3 (NickolayKudasov)
05:11:40 * hackagebot glicko 0.1.0.0 - Haskell implementation of Glicko-2  https://hackage.haskell.org/package/glicko-0.1.0.0 (rprecenth)
05:16:50 * hackagebot ad 4.3 - Automatic Differentiation  https://hackage.haskell.org/package/ad-4.3 (EdwardKmett)
05:19:56 <JagaJaga> What's the best way to write this? `my_eithers abs = abs >>= \(a, b) -> [Left a, Right b]`
05:21:31 <quicksilver> I think that's a case I'd write a list comprehension for
05:21:50 * hackagebot constraints 0.6 - Constraint manipulation  https://hackage.haskell.org/package/constraints-0.6 (EdwardKmett)
05:22:04 <quicksilver> [ s | (a,b) <- abs, s <- [Left a, Right b] ]
05:22:32 <JagaJaga> quicksilver: yeah, but the task was to write without that :)
05:22:39 <quicksilver> oh :)
05:22:42 <quicksilver> then I'd use concatMap
05:22:50 <quicksilver> which is just >>= with a more familiar name :)
05:22:51 <frerich> That's cheating! :-)
05:23:01 <mauke`pwd`> my_eithers = concatMap (\(a, b) -> [Left a, Right b])
05:23:07 <quicksilver> as mauke`pwd`.
05:23:35 <JagaJaga> mauke`pwd`: quicksilver: that's the same indeed :) Thank you guys/
05:24:08 <mauke`pwd`> :t sequence [Left . fst, Right . snd]
05:24:10 <lambdabot> (a, b) -> [Either a b]
05:24:27 <mauke`pwd`> :t concatMap (sequence [Left . fst, Right . snd])
05:24:28 <lambdabot> Foldable t => t (a, b) -> [Either a b]
05:24:56 <JagaJaga> mauke`pwd`: that's awesome, thank you!
05:25:07 <mauke`pwd`> nah, just basic obfuscation
05:32:31 * hackagebot hindent 4.5.5 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-4.5.5 (ChrisDone)
05:40:18 <quicksilver> :t foldMap (pure . Left . fst <> pure . Right . snd)
05:40:19 <lambdabot> (Applicative f, Foldable t, Monoid (f (Either a b))) => t (a, b) -> f (Either a b)
05:40:22 <zzing> For your amusement: "All my friends are monads": http://i.imgur.com/gxcPXtJ.png
05:47:31 * hackagebot aeson-extra 0.2.2.0 - Extra goodies for aeson  https://hackage.haskell.org/package/aeson-extra-0.2.2.0 (phadej)
05:54:28 <breadmonster> Hey guys.
06:07:42 <hasenov> hello, i am trying to implement inputCheckboxes with blaze according to the following post: http://stackoverflow.com/questions/6436238/list-of-checkboxes-with-digestive-functors/6437488#6437488
06:08:34 <hasenov> looks like some time ago, blaze functions have changed, and inputCheckBox was changed to inputCheckbox, and its parameters have changed as well
06:09:27 <hasenov> so im no longer able to use "fmap maybeStr (inputCheckBox False) <++ label str"
06:10:19 <hasenov> previous definition of inputCheckBox was 
06:10:23 <hasenov> inputCheckBox :: (Monad m, Functor m, FormInput i f) => Bool -> Form m i e BlazeFormHtml Bool
06:10:37 <hasenov> now inputCheckbox is
06:10:49 <hasenov> inputCheckbox :: Text -> View Html -> Html
06:11:09 <hasenov> so I'm not sure how to make it work
06:11:41 <roelof> <roelof> How can I change this function http://lpaste.net/144984 so it returns a bool instead of a [bool] 
06:13:17 <quicksilver> :t let isPrime n = [ if x /= 1 || x /= n then  n `rem` x == 0 else  n `rem` x == 1 | x <- [ 1 .. n]]
06:13:19 <lambdabot> <no location info>:
06:13:19 <lambdabot>     not an expression: ‘let isPrime n = [ if x /= 1 || x /= n then  n `rem` x == 0 else  n `rem` x == 1 | x <- [ 1 .. n]]’
06:13:22 <quicksilver> :t let isPrime n = [ if x /= 1 || x /= n then  n `rem` x == 0 else  n `rem` x == 1 | x <- [ 1 .. n]] in isPrime
06:13:23 <lambdabot> Integral a => a -> [Bool]
06:13:44 <quicksilver> roelof: how could taht return a single bool?
06:14:38 <roelof> Oke, so it returns for every number a bool. back to thinking how to solve this 
06:27:33 <roelof> quicksilver:  Found the right answer after some trying and looking at the output : isPrime n =  length [ x | x <- [ 1 .. n],  n `rem` x == 0 ]  == 2 
06:29:20 <quicksilver> that is a reasonable way, yes. obviously not a very fast way to find a bunch of primes :)
06:37:33 * hackagebot bbdb 0.5 - Ability to read, write, and examine BBDB files  https://hackage.haskell.org/package/bbdb-0.5 (HenryLaxen)
06:54:59 <roelof>  quicksilver  is there a faster way that uses list comphresion then ? 
06:55:15 <quicksilver> I don't know what you are trying to do, roelof.
06:55:42 <quicksilver> There are many faster ways to calculate primes, and the fastest way to check primality is generally to first calculate all primes up to sqrt(n)
06:56:06 <roelof> I have to make a function which checks if a number is a prime but I have to use list comprehension 
06:56:15 <quicksilver> well that that's fine.
06:56:25 <quicksilver> I mena, your solution is fine.
06:56:42 <roelof> quicksilver:  so I can stop the recursion at the sqrt of  n ? 
06:58:51 <quicksilver> you can, although you will find that sqrt(n) is not an integer and you'll need to do some appropriate rounding
06:59:32 <roelof> quicksilver:  thanks for the info 
07:02:09 <tdammers> you don't need to round if instead you check whether the square of the current candidate is larger than the target
07:12:36 <JagaJaga> Are there any haskell tools to compare haskell source codes? I need to find out who was cheating among my students..
07:15:25 <broma0> is there an existing typeclass somewhere that captures this relationship between a & b? 
07:15:28 <broma0> class Derivable a b where get :: a -> Maybe b set :: b -> a -> a
07:15:49 <bergmark> broma0: probably in lens...
07:15:56 <broma0> bergmark: that's what i was thinking
07:16:06 <broma0> haven't found it though. It looks like a prism
07:24:53 <haskell659> how can I stop long running program in cabal repl without hitting Ctrl+C which throws me out of REPL
07:25:31 <dcoutts> haskell659: if you can use the latest cabal-install, I think the ctl-c issue doesn't occur
07:26:25 <jophish> Is there a way to get pandon to write plain text stripping all formatting. For example at the moment it transforms the html <strong>hello</strong> to HELLO
07:27:00 <broma0> a prism without the 'review' functionality.. does it exist in lens? I need a typeclass between A and B that allows me to 'get :: a -> Maybe b' and 'set :: b -> a -> a'.
07:27:07 <haskell659> dcoutts: I am using cabal-install version 1.22.6.0
07:27:14 <dcoutts> haskell659: and ghc version?
07:27:31 <haskell659> dcoutts: 7.10.2
07:27:49 <dcoutts> haskell659: ok, never mind, it's not the problem I was thinking it was.
07:28:10 <haskell659> dcoutts: ah, thanks anyways :)
07:29:01 <dcoutts> haskell659: it used to be impossible to handle ctl-c properly with System.Process, and cabal-install inherited that problem, but that's fixed in ghc 7.8 and newer cabal, so I don't know why that's happening now.
07:29:06 <MarcelineVQ> JagaJaga: as something really basic you could run diff on a cartesian list of pairs of their source files and find the files which are least different. That approach might even work better over time because the less a student 'gets' the exercises the more of an exact copy the'll probably end up with when cheating. It's a bit of a tough problem, for you or a tool, because haskell code is so nice that the right appraches end up 
07:29:06 <MarcelineVQ> pretty similair. Do you really need to find cheaters though?
07:29:54 <dcoutts> haskell659: assuming your cabal-install itself was definitely built using 7.8 or 7.10
07:30:14 <haskell659> dcoutts: I am pretty sure it is. 
07:30:24 <dcoutts> haskell659: cabal +RTS --info  will tell you
07:31:10 <kuribas> does anyone think semantic support for haskell in emacs would be useful?
07:31:19 <haskell659> dcoutts: yes, 7.10.2
07:31:48 <haskell659> dcoutts: I am not alone facing this problem FWIW
07:32:07 <quicksilver> broma0: a prism without review is a traversal
07:32:09 <haskell659> dcoutts: one of my team member also faced the same
07:32:10 <broma0> kuribas: not that the youtube community is a good sample population, but i've seen/heard about more haskellers using vim
07:32:20 <dcoutts> haskell659: then perhaps you can help track it down
07:32:21 <broma0> quicksilver: really?
07:32:40 <broma0> quicksilver: thanks
07:32:45 <haskell659> dcoutts: I will try it, sure!
07:34:02 <quicksilver> > [1,2,3] ^? _head
07:34:04 <lambdabot>  Just 1
07:34:10 <quicksilver> broma0: for example
07:34:35 <benzrf> broma0: think of optics as having sets of capabilities
07:34:51 <benzrf> broma0: when you compose them, capabilities may be lost if there's no sensible way to derive new ones for the composed optic
07:35:08 <benzrf> broma0: think of 'lens' and 'prism' etc as just particular collections of capabilities
07:35:20 <broma0> benzrf: hmm, thank you for that way of thinking about it.. thats different than what ive heard before. Makes sens
07:35:29 <benzrf> broma0: well, it's not 100% correct necessarily
07:35:33 <benzrf> i think im missing laws, for example
07:35:49 <benzrf> broma0: but it's helpful when using the library
07:35:53 <broma0> benzrf: i understand your point though, its a good & simple way to think about it
07:36:26 <broma0> quicksilver: benzrf: so in my case of 'get :: a -> Maybe b, set :: b -> a -> a', what would the typeclass between a & b be?
07:36:34 <kuribas> broma0: it's a tie: https://www.reddit.com/r/haskell/comments/3c5383/development_tools_survey_results/
07:36:37 <broma0> without inventing my own 'derivable'
07:36:49 <benzrf> broma0: typeclass?
07:36:57 <benzrf> do you mean, what kind of optic would have those capaibilties?
07:37:04 <quicksilver> broma0: are you sure you want a typeclass?
07:37:30 <benzrf> broma0: a "Traversal' a b" does that if it has only one target
07:37:36 <broma0> i have a function : 'myfunc :: Derivable a b => a -> b -> IO'
07:37:38 <benzrf> broma0: the term for this is 'affine traversal'
07:37:58 <broma0> and i'd like to use an existing typeclass for the relationship so that it ties in nicely with the rest of my lens code
07:38:07 <dcoutts> haskell659: ok found the bug
07:38:24 <broma0> benzrf: you're just full of info 
07:38:27 <broma0> benzrf: thanks
07:38:31 <haskell659> dcoutts: quite quick :) what is that?
07:38:36 <benzrf> np
07:38:40 <dcoutts> haskell659: I can point it out so you can try writing a fix and send a patch
07:38:55 <haskell659> dcoutts: okay, will try it
07:39:00 <dcoutts> haskell659: in the Cabal lib, in Distribution.Simple.Utils
07:39:01 <benzrf> broma0: wait, crap
07:39:09 <broma0> benzrf: oh boy
07:39:12 <benzrf> broma0: i meant "at most one target", sorr
07:39:15 <benzrf> *sorry
07:39:25 <dcoutts> haskell659: see rawSystemExitWithEnv and rawSystemIOWithEnv. The first uses Process.delegate_ctlc = True. The second does not.
07:39:30 <benzrf> broma0: otherwise that's just a lens :)
07:39:31 <JagaJaga> MarcelineVQ: That's what I do now (running diff)..
07:40:03 <haskell659> dcoutts: ah
07:40:27 <benzrf> broma0: do note that the properties of traversals mean that if 'get x = Nothing', then 'set someB x = x'
07:40:38 <dcoutts> haskell659: now on the face of it that's sensible, in the first case we're clearly running the program in the foreground so we should delegate ctl-c handling, while in the latter case we're obviously running it in the background (since we optionally capture stdout etc)
07:41:06 <benzrf> broma0: if you have a different kind of behavior in mind, your type signatures should be different if you want to be using optics
07:41:16 <dcoutts> haskell659: the problem is that Distribution.Simple.Program.Run, we call the one that uses the background mode
07:41:31 <broma0> benzrf: that's exactly the behavior i want. i'm still looking for a way to use what you've told me to replace 'Derivable a b' in 'myfunc :: Derivable a b => a -> b -> IO ()'
07:41:57 <benzrf> broma0: myfunc :: Traversal' a b -> a -> b -> IO ()
07:42:01 <dcoutts> haskell659: and we do that because that one takes an optional cwd, where as rawSystemExitWithEnv does not.
07:43:06 <benzrf> broma0: then myfunc t a b = ...preview t a...
07:43:17 <haskell659> dcoutts: oh, what if it does. how much is it's usage?
07:43:26 <dcoutts> haskell659: so I think the fix is this: extend rawSystemExitWithEnv with a mcwd :: Maybe FilePath  param, just like rawSystemIOWithEnv, and then switch runProgramInvocation over to use that
07:43:49 <broma0> benzrf: yeah... but now i have an extra argument.. but i guess that's the point of lens - first class types for these things
07:44:00 <Ankhers> kk
07:44:05 <Ankhers> miss...
07:44:27 <haskell659> dcoutts: okay, thanks for detailed explanation
07:44:28 <benzrf> broma0: rightr
07:44:43 <dcoutts> haskell659: so give that a go, see if it works, and then if so send in a pull request
07:45:04 <dcoutts> haskell659: and if you need help, ask in #hackage
07:45:41 <haskell659> dcoutts: sure, thanks!
07:45:52 <benzrf> broma0: 'traverse' as in the 'Traversable' typeclass is generally a valid traversal; if myfunc is meant to operate on Traversable types, that could work
07:47:40 <broma0> benzrf: so the idea is that i have a type 'Component a b' that has a list of 'SubComponent b' inside of it. SubComponent is 'forall c. Derivable b c => SubComponent (Component b c)'
07:48:08 <quicksilver> I'm really concerned that a type-class like that is a bad idea
07:49:03 <broma0> quicksilver: talking to me? any suggestions?
07:49:03 <benzrf> broma0: ok this seems kind of complicated
07:49:12 <benzrf> broma0: i think we might have an XY problem here
07:49:39 <broma0> XY problem?
07:49:41 <benzrf> (also i need to get to work for class pretty soon)
07:49:48 <benzrf> @where xy
07:49:49 <lambdabot> I know nothing about xy.
07:49:53 <benzrf> @where xy-problem
07:49:53 <lambdabot> I know nothing about xy-problem.
07:49:55 <benzrf> :|
07:50:00 <broma0> benzrf: ill look it up
07:50:00 <benzrf> 1 sec
07:50:14 <broma0> ahhh
07:50:21 <benzrf> @learn xy as http://xyproblem.info/
07:50:22 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
07:50:24 <broma0> ha, yeah probably a case of the XY problem!
07:50:24 <benzrf> wha
07:51:12 <benzrf> @where+ xy http://xyproblem.info/
07:51:12 <lambdabot> Done.
07:51:34 <benzrf> broma0: what is the use case for this monstrosity of a type?
07:52:11 <benzrf> (when i say monstrosity i just mean 'it is really complicated', which could be necessary but is often a red flag)
07:52:35 * hackagebot glicko 0.1.1.0 - Glicko-2 implementation in Haskell.  https://hackage.haskell.org/package/glicko-0.1.1.0 (rprecenth)
07:53:49 <kuribas> is it possible to do the layout rule at the lexing phase?
07:54:05 <broma0> benzrf: im writing a library wrapping ghcjs-vdom for writing single page web-applications in haskell using ghcjs. The idea is that you have a big ol' data type, and map components to sections of that data type using the derivable class. So if i have App { appA :: A, appB :: B } I might have a (Component App App), a (Component App A), and a (Component App B). The library needs to know how to update App when
07:54:11 <broma0>  A or B get updated.
07:54:14 <broma0> benzrf: spark notes version
07:54:52 <broma0> benzrf: you could imagine that i'd also have a Component A C and Component B D
07:55:25 <benzrf> whoa
07:55:29 <benzrf> are you trying to make angular?
07:55:40 <broma0> benzrf: not entirely. more like a lightweight version of Om
07:55:48 <benzrf> i dont know what om is :')
07:55:50 <broma0> but Om is for ClojureScript and i dont like 'Hom'
07:56:00 <broma0> ClojureScript wrapper for REact.js
07:56:18 <benzrf> if you dont like Hom then why are you using haskell, it's all full of category crap
07:56:21 <benzrf> *rimshot*
07:56:58 <quicksilver> I'm sure you don't want a typeclass Derivable
07:57:09 <quicksilver> you just want something like Component, but composable
07:57:14 <benzrf> yeah
07:57:23 <quicksilver> ComponentOrSubComponent App D
07:57:24 <benzrf> broma0: typeclasses are *very often* the wrong approach
07:57:44 <quicksilver> "ComponentOrSubComponent" might simply be Traversable'
07:58:03 <quicksilver> if Deriveable only has the methods you pasted earlier, then Traversable' is sufficient
07:58:15 <benzrf> broma0: they are kind of like OOP class inheritance, in that they work very well for the stdlib and certain specific applications, but can easily make your code much worse if you misapply them in a sensible-seeming way
07:58:48 <benzrf> broma0: can you articulate exactly what your library needs to know about the App type?
07:59:01 <benzrf> in terms of human knowledge
07:59:47 <broma0> benzrf: before the english, here's the tiny library core as of now http://lpaste.net/144991
08:00:20 <broma0> benzrf: it needs to know how to get B from it, so that it can run a component of type Component App B
08:00:27 <broma0> benzrf: that probably isnt the answer you need....
08:00:39 <quicksilver> definitely sounds like Traversable' to me
08:01:18 <benzrf> broma0: sorry i would really love to help you but ive been delaying on doing my work for class and i really need to get to it :|
08:01:29 <broma0> benzrf: get to it! thank you for your help.
08:01:32 <benzrf> no problem
08:01:41 <benzrf> broma0: i'd be happy to resume talking about this later if you still need any help
08:01:44 <benzrf> see you!
08:01:54 <broma0> benzrf: ill ping you if you're on
08:02:49 <broma0> quicksilver: did you happen to check out my lpaste? I'm thinking you're right, but i dont know how to replace Derivable with your idea in my simple code
08:05:41 <quicksilver> will look in a sec
08:05:46 <broma0> quicksilver: thank you, sir
08:10:13 <quicksilver> broma0: what is the 'a' in Component a b?
08:10:16 <quicksilver> it doesn't seem to be used
08:11:04 <broma0> quicksilver: ha, wow i guess just a remnant of previous iterations
08:11:29 <quicksilver> since  the only thing runComponent does with its `a` parameter is call get on it
08:11:40 <quicksilver> then runComponent might as well have the type Component b -> b -> IO ()
08:15:55 <quicksilver> or Maybe b
08:16:36 <broma0> quicksilver: 'runComponent :: Component b -> Maybe b -> IO ()' ?
08:17:15 <quicksilver> yes. Assume we are simplifying the 'Component' type since it wasn't mentioning 'a' any more
08:17:27 <quicksilver> and instead of passing the 'a' and using a Deriveable a b context
08:17:35 <quicksilver> we just go straight to the Maybe b
08:17:36 * hackagebot haskell-src-meta 0.6.0.12 - Parse source to template-haskell abstract syntax.  https://hackage.haskell.org/package/haskell-src-meta-0.6.0.12 (GeoffreyMainland)
08:17:43 <quicksilver> but there is probably more context I don't see :)
08:28:58 <nitrix> Hi, how would someone use a module like this? https://hackage.haskell.org/package/pure-io-0.2.0/docs/PureIO.html
08:29:30 <nitrix> By manually hiding functions from Prelude; or does that package has a magical way to do that? (overwriting definitions)
08:30:49 <nitrix> import Prelude()   import PureIO ?
08:31:07 <bergmark> yes, or import pure io qualified
08:31:42 <bergmark> there's also the NoImplicitPrelude pragma, and you could also use something like http://hackage.haskell.org/package/base-noprelude
08:32:27 <roelof> what is the reason that before line2 and line3 there is a space : http://lpaste.net/144993
08:32:37 * hackagebot dsp 0.2.3.1 - Haskell Digital Signal Processing  https://hackage.haskell.org/package/dsp-0.2.3.1 (HenningThielemann)
08:32:55 <quicksilver> roelof: because unwords puts spaces in
08:33:12 <quicksilver> > unwords ["hi","there","roelof"]
08:33:14 <lambdabot>  "hi there roelof"
08:33:57 <roelof> quicksilver:  oke, so I can better use interspece then ? 
08:34:24 <roelof> > interspece ["hi", "there"] 
08:34:26 <lambdabot>      Not in scope: ‘interspece’
08:34:26 <lambdabot>      Perhaps you meant one of these:
08:34:26 <lambdabot>        ‘BS.intersperse’ (imported from Data.ByteString),
08:34:44 <roelof> > intersperse ["hi", "there"] 
08:34:46 <lambdabot>  <[[[Char]]] -> [[[Char]]]>
08:34:47 <quicksilver> roelof: onSeparateLines = unlines ?
08:35:03 <quicksilver> > concat ["hi","there"]
08:35:05 <lambdabot>  "hithere"
08:35:11 <quicksilver> > unlines ["hi","there"]
08:35:12 <roelof> > unlines ["hi", "there"] 
08:35:13 <lambdabot>  "hi\nthere\n"
08:35:14 <lambdabot>  "hi\nthere\n"
08:36:15 <roelof> quicksilver:  thanks again and again 
08:36:31 <HypeSystem> On Morte, is this: "forall (Succ : Nat -> Nat) -> ..." the same as this: "forall (Succ : (forall (* : Nat) -> Nat)) -> ..." ?
08:36:55 <HypeSystem> Replace "*" by a "x" ... *
08:37:03 <quicksilver> roelof: np :)
08:38:40 <roelof> one question . When I want to print a string I use PrintStrLn , when I want to print a outcome of a function which produces otherwise then a string I use print $ 
08:38:40 <eric____> Just want to say hi
08:38:54 <roelof> Is there one print command where I can print both 
08:39:07 <ski> roelof, no
08:39:14 <ski> `print' also works on strings
08:39:39 <ski> but it won't behave the same as `putStrLn' (by design)
08:40:39 <anks> is there a function to fork a list into n lists? so that list [a,b,c,d,e,f,..] will become [[a,d,..],[b,e,..],[c,f...]]?
08:41:18 <quicksilver> > chunksOf 3 [1,2,3,4,5,6,7,8,9,0]
08:41:19 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[0]]
08:41:21 <quicksilver> > transpose $ chunksOf 3 [1,2,3,4,5,6,7,8,9,0]
08:41:23 <lambdabot>  [[1,4,7,0],[2,5,8],[3,6,9]]
08:41:50 <quicksilver> anks: ^^
08:42:31 <anks> quicksilver, thanks!
08:43:22 <geppettodivacin> I am constantly amazed by simple solutions like that.
08:43:33 <roelof> ski:  you are right. I can make the error message again 
08:44:18 <quicksilver> geppettodivacin: that is one of my favourite.
08:45:09 <anks> quicksilver: there's but one problem, theres is no such function as chunks of ;]
08:45:25 <geppettodivacin> anks: It's in Data.List.
08:45:34 <MarcelineVQ> I'm more amazed that quicksilver was able to grasp the full problem instantly
08:45:38 <quicksilver> @hoogle chunksOf
08:45:39 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
08:45:40 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
08:45:42 <anks> <interactive>:1:19-26:
08:45:42 <anks>     Module ‘Data.List’ does not export ‘chunksOf’
08:45:43 <anks>  
08:45:46 <quicksilver> MarcelineVQ: I'd seen it before.
08:45:50 <quicksilver> hmm
08:46:04 <geppettodivacin> Or, Data.Text?
08:46:04 <MarcelineVQ> quicksilver: that was feynman's trick too
08:46:17 <quicksilver> Data.List.Split, actually
08:46:23 <anks> lol
08:46:24 <haskell659> dcoutts: apparently both uses Process.delegate_ctlc = True. second uses a utility function `createProcessWithEnv`. I realised this while I changed Run.hs to use extended rawSystemExitWithEnv, and it still did not work
08:47:09 <anks> thanks!
08:47:11 <dcoutts> haskell659: oh, I may have been looking at a slightly older version of the code, lets see...
08:47:40 <quicksilver> if you don't have `split` installed, then chunksOf n = takeWhile (not.null) . map (take n) . iterate (drop n) 
08:47:46 <geppettodivacin> Does anyone know why 'flip join' typechecks?
08:47:48 <geppettodivacin> :t flip join
08:47:50 <lambdabot> b -> (b -> b -> c) -> c
08:47:54 <quicksilver> :t join
08:47:56 <lambdabot> Monad m => m (m a) -> m a
08:48:05 <quicksilver> unification
08:48:12 <quicksilver> flip choosees the 'right' Monad
08:48:15 <quicksilver> to make join have the right form
08:48:35 <ski>   m = (b ->)
08:48:55 <geppettodivacin> So basically, m(m a) is turned into m -> m a?
08:49:23 <dcoutts> haskell659: mm yes ok, odd.
08:49:45 <ski> `m (m a) -> m a' becomes `(b ->) ((b ->) a) -> (b ->) a', iow `(b -> b -> a) -> (b -> a)'
08:50:40 <dcoutts> haskell659: well, one sanity check to try would be this: make a simple standalone Main program that just invokes ghci using System.Process.createProcess and that sets delegate_ctlc and check that that works (also have to use waitForProcess of course)
08:50:55 <haskell659> dcoutts: apparently I just noticed it only happens with our main project, does work on other projects :/
08:51:08 <dcoutts> haskell659: uggg, really?
08:51:21 <dcoutts> that'll be annoying to track down
08:51:30 <geppettodivacin> ski: That's a strange phenomenon. It also makes for the weirdness of (flip . flip $ join) doesn't equal (join).
08:51:34 <dcoutts> haskell659: ok, try running ghci on it's own, not via cabal
08:51:41 <haskell659> dcoutts: yeah
08:51:43 <haskell659> dcoutts: 
08:51:52 <quicksilver> geppettodivacin: you don't need to invoke a type class example to see that
08:51:57 <quicksilver> :t id
08:51:58 <lambdabot> a -> a
08:51:59 <dcoutts> haskell659: so run cabal repl -v, copy the command line where it invokes ghc --interactive
08:52:05 <quicksilver> :t flip (flip id)
08:52:06 <lambdabot> (b -> c) -> b -> c
08:52:18 <geppettodivacin> I wouldn't have guessed you could flip id at all.
08:52:21 <dcoutts> haskell659: then run that directly, see if ctl-c is working there
08:52:23 <ski> @type (flip . flip) join :: (a -> a -> c) -> (a -> c)
08:52:24 <lambdabot> (a -> a -> c) -> a -> c
08:52:25 <ski> @type join :: (a -> a -> c) -> (a -> c)
08:52:27 <lambdabot> (a -> a -> c) -> a -> c
08:52:28 <quicksilver> geppettodivacin: it is an interesting property of the way polymorphism works
08:52:35 <roelof> What is better for joining strings ++ or the join command ? 
08:52:40 <haskell659> dcoutts: okay, trying that ou
08:52:41 <quicksilver> applying functions can make the type more specific
08:52:42 <ski> geppettodivacin : they are equal, it's just that `join' is more general
08:52:45 <quicksilver> that's basically what unification means
08:53:07 <dcoutts> haskell659: ought to be possible to narrow it down. If that works, and still doesn't when invoked by cabal repl, then there's other things to try
08:53:55 <ski> geppettodivacin : `join' used as having type `(a -> a -> c) -> (a -> c)', is equal to `(flip . flip) join'
08:54:14 <mauke`pwd`> :t [join, flip (flip join)]
08:54:15 <lambdabot> [(b -> b -> a) -> b -> a]
08:54:21 <ski> (.. well, at least if we ignore using `seq' or `!'-patterns)
08:55:31 <haskell659> dcoutts: yeah it works. it doesn't throw me out
08:55:42 <geppettodivacin> :t id
08:55:43 <lambdabot> a -> a
08:55:45 <broma0> where's the identity traversal in lens?
08:55:59 <quicksilver> broma0: it is literally 'id'
08:56:05 <quicksilver> by some amazing magic :)
08:56:05 <dcoutts> haskell659: in that case, can try what I was suggesting a moment ago, to make a standalone Main that uses createProcess
08:56:13 <quicksilver> the identity function is the identity traversal
08:56:17 <broma0> quicksilver: oh yeah.. prelude's id right? 
08:56:20 <quicksilver> yup
08:56:24 <dcoutts> haskell659: but again using the big command line you just tried manually
08:56:26 <broma0> quicksilver: whoa
08:56:34 <geppettodivacin> So, (flip id) assumes that the first argument is (a -> b)?
08:56:38 <quicksilver> broma0: *FX: head explodes*
08:56:42 <haskell659> dcoutts: yeah, thanks for bearing with me :)
08:56:44 <broma0> quicksilver: nailed it.
08:56:57 <quicksilver> geppettodivacin: (flip id) unifies id's type with a -> b -> c
08:57:09 <dcoutts> haskell659: and then depending on whether that works or not, can narrow down by making the test Main be closer and closer to the code used in Cabal, e.g. copy in createProcessWithEnv etc
08:57:52 <geppettodivacin> Note to self: type checking is weird. And wonderful.
08:58:24 <quicksilver> geppettodivacin: so we unify (a -> b -> c), the type that flip requires, with (d -> d), the type that id provides.
08:58:34 <quicksilver> deliberately choosing different variables.
08:58:48 <quicksilver> (a -> b -> c) is actually (a -> (b -> c))
08:58:56 <quicksilver> so the 'top constructor' matches: it is ->
08:59:13 <quicksilver> from the left of the ->, we derive the equation d = a
08:59:24 <quicksilver> from the right of the -> we derive d = b -> c
08:59:46 <geppettodivacin> So, a = b -> c
09:00:41 <geppettodivacin> So, (flip id) :: b -> (b -> c) -> c.
09:00:44 <quicksilver> yup
09:00:46 <quicksilver> and yup
09:00:49 <quicksilver> :t flip id
09:00:51 <lambdabot> b -> (b -> c) -> c
09:00:59 <quicksilver> geppettodivacin wins the golden lambda.
09:01:00 <geppettodivacin> That's neat. Also takes a lot of thought to work out.
09:02:38 * hackagebot envy 0.3.1.2 - An environmentally friendly way to deal with environment variables  https://hackage.haskell.org/package/envy-0.3.1.2 (DavidJohnson)
09:03:09 <varaindemian> Can someone explain me how does this work? zipWith (zipWith (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]
09:04:08 <mauke`pwd`> what's unclear?
09:04:36 <johnw> envy is a cute name for that library
09:04:48 <quicksilver> johnw: you just wish you'd thought of it first :P
09:04:56 <johnw> indeed I do
09:05:08 <mauke`pwd`> are you envious of the name
09:05:14 <johnw> indeed I am
09:10:55 <haskell659> dcoutts: yeah, that works as well
09:11:24 <dcoutts> haskell659: how far did you go so far, copying the Cabal Utils code
09:11:28 <haskell659> dcoutts: I will try to drill down tomorrow
09:11:40 <dcoutts> haskell659: ok, thanks, much appreciated
09:11:50 <haskell659> dcoutts: I just tried with one option - delegate cotrl c
09:11:55 <dcoutts> ok
09:12:27 <haskell659> dcoutts: createProcess $ (proc "ghci" []) { delegate_ctlc = True }, will try to make it alike cabal lib. 
09:12:38 * hackagebot lucid 2.9.4 - Clear to write, read and edit DSL for HTML  https://hackage.haskell.org/package/lucid-2.9.4 (ChrisDone)
09:13:34 <haskell659> dcoutts: thanks for all help. I will put a pull request in case I will be able to reproduce it. good night
09:13:46 <dcoutts> haskell659: thanks!
09:37:50 <jle`> varaindemian: zipWith takes an (a -> b -> c) and turns it into an [a] -> [b] -> [c]
09:37:51 <tippenein_> I'm looking for a concise way to handle DB interaction in haskell. Persistent seemed nice but I don't want to rely on TH to generate my types. Postgres-simple is "too simple" in the sense that I have to build up the same boilerplate for each project. Do most people just abstract away *-simple's boilerplate into their own libraries that I don't know about?
09:37:59 <jle`> varaindemian: here, you're doing zipWith twice, on (*)
09:38:17 <jle`> varaindemian: so zipWith (*) gives you a [Int] -> [Int] -> [Int]
09:38:22 <bergmark> tippenein_: we use opaleye and are very happy with it
09:38:34 <jle`> varaindemian: zipWith (zipWith (*)) gives you an [[Int]] -> [[Int]] -> [[Int]]
09:38:58 <tippenein_> bergmark:  ah yesss! That is mature enough for sufficiently complex schemas?
09:39:10 <tippenein_> bergmark: also, Migrations? postgresql-simple-migrations?
09:40:09 <BabyMac> Hello :) Can anyone help me.. I am a senior at BT for Dental Assisting!
09:41:39 <bergmark> tippenein_: we could use it to model everything in our current schema. We couldn't do that with persistent which was one reason we didn't stay with persistent.
09:42:07 <dmj> BabyMac: Hi, how can we assist you?
09:42:32 <bergmark> tippenein_: no migrations to my knowledge, we already had a system in place for it so we just make sure to update the opaleye representation when we change the schema, hasn't caused us any issues yet :-)
09:45:46 <caconym> opaleye looks awesome, this lurker thanks bergmark 
09:45:59 <caconym> was looking for something like this a while ago
09:47:39 * hackagebot tasty-html 0.4.1.1 - Render tasty output to HTML  https://hackage.haskell.org/package/tasty-html-0.4.1.1 (RomanCheplyaka)
09:50:42 <tippenein_> thanks bergmark . You, random person on irc, have increased my faith in opaleye
09:51:08 <tippenein_> oh, heh. I see your name on the backup maintainers list ;)
09:51:27 <luigy> also this looks like improves opaleye https://github.com/k0001/opaleye-sot/tree/master
09:51:38 <luigy> the blogpost is nice read as well
09:53:23 <quicksilver> opaleye scares me because I know how hard it is to write complete (or if not complete, extensive) SQL abstraction layers
09:53:28 <quicksilver> and it looks young
09:53:32 <quicksilver> I really want to try it though
10:02:19 <frerich> Does it use the term 'tisch' to deal with tables? Oops.
10:04:28 <bergmark> tippenein_: well... i'm on the backup maintainer list because we chose to use the library :)
10:19:14 <haskell740> Hello everyone! When I'm using mutable arrays inside ST monad, haskell compilier requires from me to write type of new array as :: ST s (STUArray s Int Int). My question: what this `s` means and why there should be the same `s` in array and ST?
10:19:43 <quicksilver> `s` is a clever trick with the type system to keep you honest
10:19:59 <quicksilver> it is what stops you using an STRef or an STArray after they have been destroyed
10:20:05 <quicksilver> or from the wrong ST block
10:21:10 <haskell740> quicksilver: so there is no 'state' which is passed through all execution? It just compiler requirement which guarantees correct execution?
10:22:56 <quicksilver> correct.
10:23:19 <quicksilver> under the hood it is using mutation
10:23:36 <quicksilver> but the type guarantees that running an 'ST' action can have no visible side-effects
10:23:40 <quicksilver> so it is a pure computation
10:26:39 <haskell740> quicksilver: Thanks!
10:28:03 <Denommus> quicksilver: is ST similar to StateT?
10:28:54 <Zekka|Sigfig> Denommus: Not particularly
10:29:07 <Zekka|Sigfig> it doesn’t provide most of the operations of StateT
10:29:44 <yitz> Denommus: the types STRef a -> ST s b and StateT a IO b are isomorphic
10:30:42 <yitz> wait maybe just State a b.
10:30:49 <Zekka|Sigfig> yitz: Really? How do I write lift (putStrLn “Hello, world!”) as an STRef a -> ST s b?
10:30:51 <yitz> i wrote out the proof once, a long time ago
10:30:56 <yitz> yeah
10:31:05 <Zekka|Sigfig> I get your intuition though.
10:31:29 <Zekka|Sigfig> If you limit yourself to just one STRef and keep an implicit reference to it, then you get something similar to State
10:32:07 <Zekka|Sigfig> Likewise you can badly simulate ST by keeping State of a container type that can store values of whatever you want refs to
10:32:44 <yitz> the operational characteristics are different, but they are semantically isomorphic.
10:33:09 <aoli> @help
10:33:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:33:28 <aoli> @pl evalS s `catchError` (\exc -> do {assign x (Val exc); evalS h})
10:33:28 <lambdabot> (line 1, column 34):
10:33:28 <lambdabot> unexpected "{"
10:33:28 <lambdabot> expecting variable, "(", operator or ")"
10:33:30 <Zekka|Sigfig> (meaning that you can write a simulation that will typecheck against existing code and have the same output, but it probably won’t perform as well for ordinary usecases)
10:34:18 <aoli> @pl (\exc -> do {assign x (Val exc); evalS h})
10:34:18 <lambdabot> (line 1, column 13):
10:34:18 <lambdabot> unexpected "{"
10:34:18 <lambdabot> expecting variable, "(", operator or ")"
10:34:50 <aoli> @pl \exc -> do {assign x (Val exc); evalS h}
10:34:51 <lambdabot> (line 1, column 12):
10:34:51 <lambdabot> unexpected '{'
10:34:51 <lambdabot> expecting variable, "(", operator or end of input
10:35:15 <yitz> aoli i don't think @pl understands do notation
10:35:33 <Zekka|Sigfig> @pl \exc -> assign x (Val exc) >> evalS h
10:35:33 <lambdabot> (>> evalS h) . assign x . Val
10:36:35 <yitz> @. pl undo \exc -> do {assign x (Val exc); evalS h}
10:36:35 <lambdabot> (>> evalS h) . assign x . Val
10:40:13 <kynan_> how do i profile a dependency of my cabal executable? i want to see how much using linear for my vector math costs me.
10:40:49 <kynan_> i'm using fprof-auto so at least i get to see the contribution of all the functions in my own code, but how can i add linear to this?
10:43:52 * hackagebot urlpath 4.0.0 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-4.0.0 (athanclark)
10:50:59 <m_ryan> hi everyon im back to impickerin and ReinH sory just back my net today :)
10:51:40 <m_ryan> hi mean to impickering
10:53:23 <ReinH> kynan_: You need to enable library profiling. Unfortunately, it is disabled by default.
10:53:36 <ReinH> @google cabal of cabal
10:53:38 <lambdabot> https://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
10:53:49 <ReinH> ^ Explains some config options you might want to change for cabal.
10:54:02 <ReinH> If you're using stack I believe it is enabled by default(?)
10:58:42 <crutcher> I've been gone for a few years, and I've got time to get serious again.
10:59:12 <crutcher> But now I'm facing this question, everything I want to do, there's multiple ways, and lots of existing arguments about which one.
10:59:23 <crutcher> For example, matricies.
10:59:45 <crutcher> So, I'm wondering if there's a place where the current discussion on at least the big questions are collated
10:59:57 <ReinH> crutcher: possibly stackoverflow
11:00:00 <crutcher> Which random number libs to use. Which arrays.
11:00:11 <ReinH> Hmm, not for "which library" questions
11:00:40 <Denommus> this is very out of touch, even from a free software POV, coming from RMS O.o http://ergoemacs.org/misc/Richard_Stallman_whats_magit_emacs_community_problem_2015.html
11:01:07 <ReinH> Denommus: and also off topic here
11:01:33 <crutcher> I recently left Google after 10 years, and we had an internal Dev Guide, which was indexed by "what do you want to do", and then cross linked to the tech available to do those things, and the discussion about which ones were prefered.
11:01:34 <monochrom> "which random number lib to use" will be rightfully answered by "depends on what you use random numbers for", e.g., crytopgraphical? monte carlo simulation?
11:02:00 <Denommus> ReinH: sorry, I meant to send it to #emacs
11:02:04 <Denommus> ReinH: wrong channel XD
11:02:16 <crutcher> sure, but If I do that research, the work gets lots and the next person has to do it too.
11:02:23 <monochrom> to a less extent, "which matrix lib to use" suffers the same indeterminism too. just less.
11:02:26 <crutcher> I'm not sure I'm up to speed enough to start that doc
11:02:29 <kynan_> ReinH how do i do that? i did cabal configure --enable-library-profiling --enable-executable-profiling. also, I'm using nixos, so i set all my haskell packages to enableLibraryProfiling as well
11:03:54 <monochrom> well yeah someone ought to write a comprehensive report eh?
11:04:05 <ReinH> kynan_: Then I am unsure.
11:04:08 <monochrom> and do it for free eh?
11:04:35 <crutcher> monochrom: well, maybe not. it just has to hit some marginal utility, and be publicly editable. Presumably we could put it on the Wiki
11:04:38 <ReinH> monochrom: Well, the community already does that, to an extent.
11:05:10 <crutcher> monochrom: well, thanks. I'm not up to speed enough again to start on that, but I've got LOTS of time, so if I hit some crossover point, I'll give it a shot.
11:05:20 <ReinH> monochrom: What's that thing that gets published relatively frequently that includes information about new and updated libraries?
11:05:26 <kynan_> ReinH is that method expected to make library function show up in your .prof? that's the part i don't have working yet.
11:05:37 <ReinH> kynan_: I thought so. How are you profiling?
11:05:45 <monochrom> hackagebot
11:05:47 <ReinH> Are you using -fprof-auto?
11:05:56 <kynan_> i have fprof-auto set in my project
11:06:02 <ReinH> monochrom: No, this is long form
11:06:08 <kynan_> do i need to set that inside linear as well?
11:06:09 <monochrom> I forgot
11:06:15 <ReinH> monochrom: me too :)
11:06:19 <ReinH> kynan_: I don't think so.
11:06:32 <monochrom> the next thing I would guess is Haskell Weekly News
11:06:37 <ReinH> It is surprisingly hard to google for
11:06:46 <ReinH> monochrom: which is mostly irc quites and top reddit submissions :/
11:06:50 <monochrom> and then the next guess after that is haskell-cafe
11:06:50 <ReinH> *quotes
11:07:27 <crutcher> monochrom: I guess I could just put up "The Haskell Dev Guide" on the wiki, and put almost any nonsense in it, and community rage at my inaccuracies would induce corrections
11:07:49 <monochrom> chrisdone has an automatic feed but it is not exactly library news, it's a union of many news sources on many topics
11:07:56 <megamac12> has anyone experience with emacs haskell-interactive-mode? I can't get the session running M-x haskell-interactive-bring -> "Symbol's function definition is void: haskell-session-lookup"
11:08:02 <ReinH> crutcher: Any such wiki page would be almost immediately obsolete
11:08:26 <ReinH> And if you think it would be kept up-to-date then you must not have much experience with wikis that are not wikipedia ;)
11:08:43 <monochrom> I don't worry about obsoletion. empirically it is not too bad.
11:08:53 * hackagebot markup 3.0.0 - Abstraction for HTML-embedded content  https://hackage.haskell.org/package/markup-3.0.0 (athanclark)
11:08:55 <crutcher> ReinH: I don't really agree. You're trying to lock down the stable part of the echo system. Sure, there will be updates, but people aren't replacing their core libs that quickly.
11:09:35 <crutcher> ReinH: it's really a matter of getting past the bootstrap utility.
11:09:37 <kadoban> echo system XD
11:10:07 <crutcher> Anyway, I'm looking for random numbers for sampling from high dimensional distributions. Any pointers?
11:10:18 <monochrom> empirically, the biggest problem with wikis is people are too polite to delete things that need to be deleted, and too excited to omit things that need to be omitted. a wiki page becomes an incoherent bunch of going off tangents.
11:10:38 <monochrom> only wikipedia evades that problem by very heavily organized moderation
11:11:33 <monochrom> e.g., "if no citation shows up in X months, we will delete this claim"
11:11:46 <monochrom> no other wikis do this
11:12:10 <crutcher> monochrom: python, with it's "batteries included" approach has a comprehensive doc over the system libraries, which is somewhat organized by topic.
11:12:23 <monochrom> so all other wikis become potlucks of what the authors are excited about, as opposed to what the readers really need
11:12:29 <crutcher> It isn't amazing
11:13:27 <quicksilver> yitz: STRef a -> ST s b being isomorphic to State a b odesn't look right; the former type gives you no way to extract the `a` whereas the latter does
11:14:14 * hackagebot urlpath 4.0.0.1 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-4.0.0.1 (athanclark)
11:14:43 <ReinH> "potlucks of what the authors are excited about" basically sums up the internet
11:15:25 <kadoban> ReinH: Where "excited" usually means … *cough* physically.
11:15:33 <yitz> quicksilver: why is a <- readSTRef st different than a <- get ?
11:15:35 <monochrom> well yeah but no one has an expectation of on-topic-ness and organization on the whole internet
11:15:36 <ReinH> awkward
11:15:55 <ReinH> monochrom: I wasn't disagreeing with you
11:16:15 <monochrom> if I read your personal blog, I know you're going to talk about whatever you like and jump topics however you like
11:16:17 <sm> wikis need editors, but most of them can get by with even one such person working consistently - like the original wikiwikiweb
11:16:19 <ReinH> :t readSTRef
11:16:20 <lambdabot> STRef s a -> ST s a
11:16:32 <sm> crutcher: I like the sound of that Dev Guide
11:16:51 <ReinH> yitz: The issue isn't readSTRef, it's runState and similar.
11:16:53 <monochrom> but if I read a topical wiki, or if anyone reads a topical wiki, the expectation of coherence and relevance is, shall we say, expected.
11:17:33 <crutcher> well yeah, a dev guide has an editorial position
11:17:36 <crutcher> it's normative
11:17:44 <crutcher> you don't get that without editors
11:17:54 <sm> yes it's not just edited.. it's curated
11:18:14 <crutcher> sm: depends what you mean by "editor", but sure.
11:18:30 <sm> yes, "editor" could mean that
11:18:58 <yitz> runState x y ~> \st -> runST (writeSTRef st y >> x)
11:19:09 <sm> it's more than just cleaning the spam and indexing the new pages in a wiki
11:19:14 * hackagebot webpage 0.0.4 - Organized and simple web page scaffold for blaze and lucid  https://hackage.haskell.org/package/webpage-0.0.4 (athanclark)
11:19:14 <yitz> ah wait that's evalState
11:19:30 <crutcher> so, I've got time ... but I'm not a valid curator in the haskell community. I've never been central enough to it. I could try and do something in the space, but I wouldn't feel comfortable throwing things up on the wiki
11:20:31 <athan> muahahaha. My web development packages are evolving.
11:20:35 <sm> crutcher: you could prototype it on github, or your own gitit instance 
11:20:36 <yitz> runState x y ~> \st -> runST (do {writeSTRef st y; result <- x; z <- readSTRef st; return (result, z)})
11:21:01 <sm> arguably if you drop it into the main haskell wiki, it'll never be round
11:21:04 <sm> er, found
11:21:15 <shalom> Howdy
11:22:01 <crutcher> sm: I'm concerned about dropping it on the wiki and maybe running out of steam on it. A health dev guide should live on the wiki
11:22:26 <crutcher> But there's a lot of work between here and there. At least I can keep some notes. Maybe something will come of that.
11:23:01 <sm> step one is to survey the many past attempts, probably
11:27:15 <quicksilver> yitz: yeah sorry I thought about it and now I see :) thanks!
11:28:16 <sm> which I guess https://www.haskell.org/documentation has done pretty nicely
11:30:11 <sm> crutcher: but of all of them, I've never seen one organised in the way you said
11:46:21 <foofoo_> hi!
11:46:33 <foofoo_> I'm having a problem with 'type hierarchies'
11:46:51 <foofoo_> let's say I have a data type foo = A | B
11:47:28 <foofoo_> and another type bar = XX foo | foo 
11:47:50 <EvanR> its case sensitive so data Foo = A | B
11:47:57 <foofoo_> now I construct a value of type foo
11:48:06 <foofoo_> (yeah, sorry about that, I'll have an example as well)
11:48:20 <EvanR> data Bar = XX Foo | Foo, in which case Foo is now two different things
11:48:41 <EvanR> Foo is a type and also a term with type Bar
11:48:43 <foofoo_> hold, on, here's the paste:
11:48:49 <foofoo_> http://lpaste.net/6886568712938192896
11:49:07 <EvanR> yeah N is confusingly two different things
11:49:09 <foofoo_> concretely, the issue is that I would like to have 'three' the type Z
11:49:15 <foofoo_> so it's shadowed?
11:49:21 <EvanR> no its two differnt namespaces
11:49:28 <foofoo_> i.e. I can't reference existing types in a type constructor?
11:49:42 <EvanR> you can, but it might not be what you think
11:49:47 <foofoo_> ok
11:49:53 <foofoo_> so how do I solve this problem?
11:50:09 <EvanR> data N = Zero | Succ N makes sense
11:50:22 <EvanR> so what are you trying to do with Z
11:50:23 <foofoo_> yes
11:50:31 <foofoo_> I want to create Z by referring to N
11:50:36 <EvanR> Minus N | Plus N ?
11:50:44 <foofoo_> so that I can express negative values by referring to an existing type
11:51:17 <foofoo_> a missing 'Minus' is supposed to imply positive numbers
11:51:31 <EvanR> well every variant needs a constructor
11:51:43 <EvanR> in your case you called it N, which is not the type N
11:52:06 <EvanR> N would be a nullary constructor of type Z
11:52:23 <EvanR> N :: Z
11:52:53 <EvanR> you can do Minus N | Plus N, now N is talking about the type
11:53:11 <foofoo_> ah, so I need a constructor if I reference a type, but not if I create a new type (like with N)?
11:53:34 <EvanR> in data N = Zero | Succ N, you still are listing two constructors
11:53:50 <EvanR> Zero just doesnt have any fields
11:53:52 <foofoo_> you're right
11:54:18 <EvanR> so you accidentally did the same thing with data Z = N, N has no fields
11:54:23 <gwm_> Can someone explain me how to solve some definitions using Coq? Such as Definition c02 : (A -> C) -> (B -> A) -> (B -> C) :=
11:54:36 <gwm_> Thought I'd ask here since it's similar to Haskell, can't get my head around it
11:55:05 <foofoo_> but then I'm trapped because I would have to define negative and positive zero
11:55:11 <foofoo_> since I need a constructor
11:55:12 <EvanR> well you had that before
11:55:19 <EvanR> two zeros
11:55:25 <EvanR> i mean, in your head
11:55:38 <foofoo_> zero and minus zero
11:55:39 <foofoo_> right
11:55:49 <EvanR> you can get around it by defining a type of positive numbers
11:56:02 <foofoo_> but that is N
11:56:07 <EvanR> and doing Minus Positive | Plus N
11:56:21 <EvanR> N is not positive numbers only
11:57:01 <EvanR> there are other representations for Z
11:57:12 <foofoo_> in my definition N is just for positive numbers, and zero
11:57:25 <EvanR> right
11:57:47 <EvanR> there exists an N which is not positive
11:58:43 <foofoo_> Zero
11:59:07 <EvanR> you can live with two zeros (which should compare equal in your operations) or you can redesign your Z type
11:59:15 * hackagebot postgresql-typed 0.4.2.1 - A PostgreSQL access library with compile-time SQL type inference  https://hackage.haskell.org/package/postgresql-typed-0.4.2.1 (DylanSimon)
11:59:16 <reuben364> gwm_: Isn't that just composition. I have dabbled in Idris but not Coq.
12:00:16 <gwm_> reuben364: yeah. for instance i got (A -> B -> C) -> (B -> A -> C) := := fun f => fun b => fun a => f a b.
12:00:47 <gwm_> rly new to this sort of stuff, i think i just need it explained in plain english
12:01:14 <EvanR> foofoo_: ex. data Z = Plus P | Zero | Minus P. ex. data Z = Zero | Succ Z | Pred Z
12:01:21 <EvanR> you can also do binary numbers
12:01:50 <foofoo_> binary numbers?
12:02:40 <EvanR> data Bin = I Bin | O Bin | One
12:02:48 <EvanR> that will give you positive binary numbers
12:02:49 <reuben364> gwm_: c02 would be fun f => fun g => g (f a)
12:03:46 <gwm_> reuben364: where's a in the environment?
12:03:54 <reuben364> woops
12:04:19 <reuben364> woops
12:05:04 <reuben364> fun f => fun g => fun a => g (f a)
12:05:59 <reuben364> a : B
12:06:00 <reuben364> f a : A
12:06:00 <reuben364> g (f a) : C
12:06:29 <gwm_> it's not having it :/
12:06:38 <gwm_> The term "a" has type "B" while it is expected to have type "A".
12:07:07 <EvanR> foofoo_: Bin is more efficient than something like N
12:07:16 <EvanR> for arithmetic
12:08:12 <foofoo_> EvanR: I'm just playing around with the Haskell type system, so efficiency is not really a concern right now ;)
12:08:53 <reuben364> gwm_: Sorry, I'm being stupid. XD
12:08:53 <reuben364> f (g a)
12:09:04 <reuben364> a : B
12:09:14 <reuben364> g : B -> A
12:09:21 <reuben364> g a : A
12:09:31 <EvanR> foofoo_: you can also check out GADTs which let you introduce some extra constraints for your constructors using the type system
12:09:41 <reuben364> f : A -> C
12:09:42 <EvanR> foofoo_: and also the GADT syntax might be easier to understand
12:09:53 <reuben364> f (g a) : C
12:09:56 <foofoo_> EvanR: I'll have a look. thanks!
12:10:33 <gwm_> reuben364: thanks alot! i'll try get my head around that now :P
12:13:03 <gwm_> reuben364: could you explain to me how f (g a) = c?
12:13:28 <gwm_> i understand why f is a->c, g is b->a and a is b
12:14:14 <reuben364> to avoid confusion say : instead of = as they have different meanings
12:14:27 <EvanR> (A -> C) -> (B -> A) -> (B -> C)
12:14:31 <EvanR> :t (.)
12:14:32 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:14:39 <EvanR> :t flip (.)
12:14:41 <lambdabot> (a -> b) -> (b -> c) -> a -> c
12:15:00 <hunteriam> i need to store 4-length lists of numbers or characters, and compare two of these very very fast
12:15:06 <hunteriam> what data type would you guys reccomend?
12:15:07 <EvanR> both are easier to read than gwm_ original
12:15:20 <EvanR> hunteriam: vector?
12:15:31 <hunteriam> how fast is vector compared to IntMap?
12:15:41 <EvanR> 6mph
12:15:50 <hunteriam> for comparison
12:15:50 <EvanR> IntMap is overkill for this
12:16:10 <EvanR> often youll see data V4 a = V4 !a !a !a !a
12:16:23 <EvanR> actually just use that
12:16:44 <reuben364> gwm_: Let's go with EvenRs suggestion (A -> B) -> (B -> C) -> (A -> C)
12:16:55 <hunteriam> So my goal is to find the shortest path between two of these V4s on a graph
12:17:02 <hunteriam> where two nodes are connected if they have a difference of 1
12:17:14 <shalom> Could someone help me understand why this error occours -- only on the filter method?
12:17:15 <shalom> http://lpaste.net/145003
12:17:16 <hunteriam> what data structure should i use for the graph?
12:17:32 <EvanR> minimum spanning tree?
12:17:37 <hunteriam> also what language extension do I need for bangs?
12:17:45 <EvanR> none for that
12:17:47 <hunteriam> EvanR: is there a built in implementation or a good library
12:17:52 <EvanR> for ! on patterns you need BangPatterns
12:18:07 <reuben364> so
12:18:08 <reuben364> f : (A -> B)
12:18:08 <reuben364> g : (B -> C)
12:18:08 <reuben364> a : A
12:18:09 <reuben364> that is clear right?
12:18:09 <reuben364> a : (
12:18:21 <gwm_> yeah
12:18:52 <reuben364> so f is a function that takes a value of type A and returns a B
12:18:58 <gwm_> yes
12:19:00 <EvanR> hunteriam: A* algorithm also might be worth looking at
12:19:07 <reuben364> so f a : B
12:19:10 <hunteriam> Thanks EvanR 
12:19:21 <EvanR> for searching points in space like V4... theres BSTs
12:19:26 <EvanR> er
12:19:28 <EvanR> BSPs
12:19:50 <hunteriam> EvanR: is !Int == Int?
12:20:17 <reuben364> gwm_?
12:20:18 <EvanR> data Foo = Foo !Int means the Int will be evaluated to WHNF when Foo is constructed
12:20:28 <EvanR> which means NF for Ints
12:20:42 <gwm_> yeah.
12:21:09 <EvanR> for primitives like Int you want to do that to speed things up and take up less space
12:21:31 <EvanR> sometimes its done for you via turning on optimizations
12:21:35 <reuben364> and g is a function that takes a value of type B and returns a value of type C
12:21:56 <gwm_> yes
12:22:10 <reuben364> so g (f a) : C
12:22:21 <EvanR> @src (.)
12:22:22 <lambdabot> (f . g) x = f (g x)
12:22:31 <gwm_> i see.
12:22:44 <gwm_> g takes f a (b) and returns c
12:22:45 <gwm_> okay
12:22:59 <gwm_> i think the main part i'm a little confused with
12:23:11 <gwm_> is if f : a -> b
12:23:23 <gwm_> and a : A
12:23:39 <gwm_> oh nevermind
12:23:44 <gwm_> i get it aha
12:23:45 <gwm_> thanks.
12:24:12 <reuben364> np
12:24:45 * hackagebot tasty-silver 3.1.8 - A fancy test runner, including support for golden tests.  https://hackage.haskell.org/package/tasty-silver-3.1.8 (PhilippHausmann)
12:24:48 * hackagebot ascii-progress 0.3.0.0 - A simple progress bar for the console.  https://hackage.haskell.org/package/ascii-progress-0.3.0.0 (yamadapc)
12:27:46 <Copperis> @hoogle m a -> a
12:27:49 <lambdabot> Language.Haskell.TH.Syntax Q :: (forall m. Quasi m => m a) -> Q a
12:27:49 <lambdabot> Test.QuickCheck.Modifiers getBlind :: Blind a -> a
12:27:49 <lambdabot> Test.QuickCheck getBlind :: Blind a -> a
12:29:36 <ReinH> Copperis: ?
12:29:46 * hackagebot ascii-progress 0.3.0.1 - A simple progress bar for the console.  https://hackage.haskell.org/package/ascii-progress-0.3.0.1 (yamadapc)
12:30:08 <Copperis> ReinH, wrapping my mind around monads
12:30:15 <ReinH> There is no Monad m => m a -> a
12:30:23 <merijn> ReinH: I'm betting money on 'looking for "IO a -> a"'
12:30:48 <EvanR> copure :: CoMonad w => w a -> a
12:30:58 <ReinH> :t extract
12:31:00 <lambdabot> Not in scope: ‘extract’
12:31:02 <ReinH> wah wah
12:31:14 <merijn> :t Control.Comonad.extract --?
12:31:15 <lambdabot> Control.Comonad.Comonad w => w a -> a
12:31:17 <EvanR> :t Control.Co
12:31:18 <EvanR> yeah
12:31:19 <lambdabot> Not in scope: data constructor ‘Control.Co’
12:31:43 <EvanR> there is only OI a -> a
12:32:04 <qfjp> oi vey?
12:32:59 <ReinH> hunteriam: Cale wrote an A* library that would be instructive, I think.
12:33:04 <ReinH> @hackage astar
12:33:04 <lambdabot> http://hackage.haskell.org/package/astar
12:34:57 <gwm_> reuben364: what about with ((A -> C) -> C) -> (A -> B) -> ((B -> C) -> C) ?
12:35:06 <ReinH> Cale: Oh, I didn't realize you wrote https://hackage.haskell.org/package/nymphaea. I can use this to demonstrate that my encoding is terminal and draw pretty things! :)
12:35:14 <gwm_> i can't see how i get A on it's own to use as an argument?
12:35:40 <ReinH> gwm_, reuben364: Are you discussing Idris?
12:35:57 <reuben364> ReinH: gwm is learning Coq
12:36:02 <gwm_> ^
12:36:07 <Ankhers> How can I map `mapM_' run in parallel?
12:36:08 <ReinH> Oh, Coq. Would you do so in #haskell-blah?
12:36:22 <reuben364> Okay
12:36:52 <merijn> reuben364, gwm_: I assume you know about Software Foundations, then? Not sure whether it's the best intro for actually learning Coq, but I thought it was very well written
12:37:08 <EvanR> or #coq
12:37:37 <gwm_> reuben364: what channel?
12:37:44 <reuben364> haskell-blah
12:40:39 <Cale> ReinH: Yeah, it was really Paolo's project, but I helped out a bunch, and realised some things about how L-system expansion could be generalised over a choice of monad through some discussion that we had about nondeterministic L-systems
12:41:31 <ReinH> Cale: A choice of functor, even, via cofree coiteration :)
12:41:36 <Cale> ReinH: I noticed that the nondeterministic L-system expansion code we'd written using the list monad had nothing special about the list monad in it -- it was only in the fact that you had a list of rules on the right hand sides of the production.
12:42:07 <Cale> By replacing that with a random generation monad, we could efficiently pick an expansion at random
12:42:15 <ReinH> :)
12:42:27 <Cale> We did use bind though, iirc.
12:42:30 <ReinH> random generation is comonadic as well though, right?
12:42:44 <Cale> I think you're referring to another dimension in which this can all be generalised
12:42:50 <ReinH> Ah. Perhaps.
12:42:55 <ReinH> There are a few of them.
12:42:56 <Cale> i.e. we were operating on strings
12:43:05 <Cale> but that could be changed
12:43:39 <ReinH> Right. A deterministic L-system is a stream of strings, a non-deterministic L-system is a (rose) tree of strings.
12:43:48 <ReinH> So you have Cofree Identity and Cofree []
12:44:06 <Cale> Oh, okay
12:44:15 <ReinH> so if you give me a Functor f => String -> f String, I can use f to supply the choice of determinacy.
12:44:30 <ReinH> and coiter to do the work for me
12:46:21 <Copperis> you can do "Maybe a -> a". So the monad type/interface/structure doesn't forbid from extending it to support such stuff. Cool.
12:46:35 <ReinH> And if you generalize String to Monad m => m a, you get data LSystem f m a = LSystem { axiom :: m a, rules :: a -> f (m a) }, which ensures that you can't do funny stuff with the string, you have to operate uniformly over the m a using the rules.
12:46:45 <EvanR> Maybe a -> a is broken
12:46:56 <cite-reader> Copperis: Careful, you're venturing into partiality. People will frown at you.
12:47:26 <Copperis> cite-reader, I don't know, what's partiality?
12:47:27 <EvanR> Maybe a -> a is a lemon type
12:47:33 <ReinH> Cale: so parametricity helps limit the space of possible solutions for applying the l-system.
12:47:46 <EvanR> Copperis: not total
12:48:05 <ReinH> (of course in reality you would always be instantiating at m ~ [] and a ~ Char, afaik)
12:48:24 <cite-reader> By which we mean that on some inputs, you don't get an a back. You'll get an impure exception, or a loop, or some other behavior that makes you sad.
12:48:41 <Cale> Well, if people are annoyed about partial functions, there's also a function (Integer -> a) -> a
12:49:01 <Cale> which takes a computation in the (->) Integer monad, and produces a result
12:49:15 <ReinH> Cale: so your choices for stepping the system are basically: coiter (apply the rules zero or more times). I wish I could get it to one or more, but I think that requires linear types?
12:49:30 <ReinH> At least one or more would have the same fixed point.
12:51:16 <ReinH> Cale: but stepping becomes basically ``coiter bind'' with some constructing and destructing of the LSystem time.
12:51:21 <ReinH> s/time/type
12:52:02 <ReinH> er, coiter (bind rules)
12:52:26 <ReinH> Anyway I think it's a nice representation
12:55:57 <yogle> is there a way to make all functions of IntSet work with a newtype'd Int without manually wrapping all of them?
12:58:40 <cite-reader> yogle: I serously doubt it.
12:59:47 * hackagebot ad 4.3.1 - Automatic Differentiation  https://hackage.haskell.org/package/ad-4.3.1 (EdwardKmett)
13:06:40 <EvanR> yogle: such is the burden of using newtypes
13:07:05 <EvanR> you get extra checking and extra typing to make sure you are doing what you said
13:09:27 <yogle> EvanR: Data.Coerce can do nice stuff with simple newtypes, so I hoped this could also be done in more complex scenarios
13:09:45 <orzo> Hey, I seem to be inventing an idiom in my code in order to use the "where" keyword more often.  I'm writing "case () of _ ->" in front of an expression just so that I can give it a local where clause.  I'm looking for opinions on this style. 
13:10:57 <merijn> orzo: Why not use guards?
13:11:05 <merijn> orzo: where clauses scope over guards
13:11:24 <orzo> merijn: well, context is within a do block, var <- case () of _ -> ...
13:11:24 <merijn> orzo: Do you have some example code?
13:11:42 <orzo> uh, i could paste if you insist
13:12:08 <merijn> orzo: What's stopping you from move the entire "case () of _" into a where clause?
13:12:50 <orzo> well i tried var <- do ... where
13:13:02 <orzo> but the where ended the outer do block instead of the inner one
13:13:09 <merijn> That won't work, no
13:13:19 <ski> (merijn : perhaps they'd need to parameterize on free nonlocals ..)
13:13:22 <merijn> But you can have where clauses attached to definitions in where clauses if you want
13:13:35 <merijn> ski: Maybe, but then you could just use let?
13:13:47 <orzo> i don't see how that helps me
13:13:49 <merijn> I dislike let a lot, but seems a lot easier than this
13:14:09 <merijn> I guess I just don't see how "case () of _" makes sense?
13:14:11 <ski> ("in order to use the \"where\" keyword more often" specified `where', not `let' :|)
13:14:17 <orzo> so your opinion is just go with let rather than case () o f_
13:14:26 <merijn> orzo: Yes
13:14:32 * ski would prefer `case () of ()', fwiw
13:14:59 <orzo> ski, you preer case () of () to case () of _.  But what about the let question?
13:15:01 <merijn> orzo: I advocate for where over let whenever possible, but this case () of seems needlessly confusing
13:15:04 <orzo> s/preer/prefer/
13:15:17 <ski> orzo : i dunno. i haven't seen the code in question yet
13:15:29 <orzo> merijn: right, but if it becomes idiom, then it's not a big deal
13:15:46 <orzo> maybe better would be a syntax that lets us use where more liberally
13:16:35 <merijn> I don't think so, that'd make the grammar a lot more complex
13:16:39 <orzo> okay, i'm going to go ahead and paste a code snippet
13:18:06 <lpaste_> orzo pasted “case/let style question.” at http://lpaste.net/145007
13:18:19 <orzo> see my paste, line 7
13:19:02 <merijn> That's indented so awfully much :(
13:19:13 <orzo> the where?
13:19:41 <orzo> we all have uber widescreens now, but i suppose i could start the case further left on the next line
13:19:47 * hackagebot ascii-progress 0.3.1.0 - A simple progress bar for the console.  https://hackage.haskell.org/package/ascii-progress-0.3.1.0 (yamadapc)
13:20:06 <merijn> orzo: I have a widescreen, but it has 2-4 terminals side-by-side
13:20:24 <orzo> okay
13:20:43 <orzo> well, your opinion is reaffirmed, i take it?
13:20:44 <lpaste_> merijn annotated “case/let style question.” with “case/let style question. (why not this?)” at http://lpaste.net/145007#a145008
13:21:16 <orzo> okay
13:21:27 <orzo> that's more conventional for me too
13:21:39 <orzo> i just felt unsatisfied with it i guess
13:21:49 <orzo> what do you think, ski?
13:22:13 <ski>   scenarios <- fmap catMaybes . forM fs $ \f -> do
13:22:18 <ski>     fn <- getDataFileName $ resolve name
13:22:20 <ski>     (Just . parseScenario) `liftM` readFile fn `catch` skip
13:22:51 <orzo> ah
13:23:00 <ski> you still need to define (or unfold) `resolve',`skip'. but this way might be nicer
13:23:02 <orzo> you just reproduced exactly an earlier incarnation
13:23:15 <ski> perhaps you prefer naming `parse', though
13:23:31 <orzo> right, not exactly, I had all those things inline instead of defined
13:24:03 <orzo> i preer naming those things
13:24:10 <orzo> my code felt too dense before
13:24:42 <orzo> what if you had to vote between my version and merijn's version, which would you prefer?
13:25:42 <orzo> i see merijn has a mistake as he forgot to delete "_ ->"
13:25:51 <orzo> but you get the idea
13:26:10 <merijn> whoops
13:26:12 <ski> orzo : merijn's is ok. however, `parse',`resolve',`skip' could also be defined in a where
13:26:39 <ski> (but perhaps you don't like if it's too far aware from the use of them)
13:27:19 <ski> orzo : if you insist on keeping your version, i'd at least reindent it like
13:27:21 <ski>   scenarios <- case () of
13:27:28 <ski>     _ -> catMaybes `fmap` mapM parse fs
13:27:32 <ski>       where
13:27:39 <ski>       parse name = ...
13:27:42 <ski>       ...
13:27:57 <ski> (to avoid some rightward drift)
13:31:19 <orzo> ya
13:31:32 <orzo> everything has drawbacks though
13:32:09 <orzo> i wanted the "catMaybes `fmap` mapM parse fs" as close to the variable "scenarios <-" as possible
13:35:08 <orzo> i think a syntax extension is called for :P
13:37:26 * ski isn't sure what extension orzo would be wanting here
13:37:58 <athan> What would be a good name of a function that removes a prefix or a suffix of matching elements between two lists?
13:38:08 <athan> Something like `removePrefix :: [a] -> [a] -> [a]`?
13:38:28 <orzo> matching elements?
13:38:33 <athan> I think `wither` might be around this idea, or if there's a zipWith that can destroy elements, on `(==)`
13:38:39 <athan> orzo: Yes
13:39:02 <orzo> i think an example might be more clear
13:39:04 <athan> I'm wondering if this could be expanded like Applicative is over Functor
13:40:08 <mauke> stripPrefix
13:40:45 <orzo> yeah, stripPrefix is better than wither
13:40:48 <athan> thanks mauke
13:40:55 <orzo> wither sounds nice, but stripPrefix is easier to guess
13:41:05 <yitz> orzo want mapMaybeM
13:41:09 <athan> orzo: Yeah, I'm wondering what properties there are
13:41:19 <mauke> :t stripPrefix
13:41:20 <athan> and how they could parallel with `filterWithKey` or something
13:41:20 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
13:41:31 <athan> mauke: Only if they match?
13:41:40 <athan> or the prefix exists I mean
13:42:19 <orzo>  Not in scope: ‘mapMaybeM’
13:42:57 <yitz> orzo: you just defined it above.
13:43:12 <yitz> @type mapMaybe
13:43:13 <lambdabot> (a -> Maybe b) -> [a] -> [b]
13:43:39 <yitz> orzo: your function does that, but inside a monad:
13:44:00 <yitz> @type \parse fs -> catMaybes `fmap` mapM parse fs
13:44:01 <lambdabot> Monad f => (a1 -> f (Maybe a)) -> [a1] -> f [a]
13:44:15 <witt3rd> (Category Theory noob here): In the category of Hask, I understand that objects are types and arrows are functions.  I see how this makes sense for 1-ary functions, but what about n-ary functions?  Are they just types. too, because of currying?  Or is this modeled as some powerset of types to convert n-ary to 1-ary?
13:44:30 <johnw> yes, because of currying
13:44:37 <athan> What about `stripPrefix` for ByteString?
13:44:39 <yitz> orzo: just like mapM is map but inside a monad, and filterM, etc.
13:46:33 <witt3rd> johnw: thanks.
13:49:49 * hackagebot ascii-progress 0.3.2.0 - A simple progress bar for the console.  https://hackage.haskell.org/package/ascii-progress-0.3.2.0 (yamadapc)
13:50:39 <Cale> witt3rd: yeah, there's a bit more structure than your average category because functions A -> B are not only arrows from the object A to the object B, but also are themselves a type, and so there's also an object (A -> B)
13:51:19 <witt3rd> Cale: ah cool.
13:51:21 <Cale> witt3rd: usually category theoretical contexts will refer to the object (A -> B) using the notation B^A
13:51:43 <Cale> See the definition of an exponential object
13:52:01 <witt3rd> Cale: thanks!  ok, will do
13:52:50 <Denommus> is there a better tutorial for alex than the official documentation?
13:53:06 <Denommus> or even better, is there a better lexer generator?
13:53:56 <mmachenry> Denommus: I use Parsec and the Lexer tools associated with it. I like it a lot and it's pretty popular. 
13:54:21 <mmachenry> What are you trying to parse? 
13:54:25 <Denommus> mmachenry: Lua
13:54:49 * hackagebot aeson-parsec-picky 0.1.0.0 - Alternative JSON parser based on Parsec and Aeson  https://hackage.haskell.org/package/aeson-parsec-picky-0.1.0.0 (MatejKollar)
13:55:09 <mmachenry> Denommus: Check out Text.Parsec.Expr, Text.Parsec.Language, Text.Parsec.Token, and Text.ParsecCombinators.Parsec. 
13:56:03 <mmachenry> Denommus:  https://wiki.haskell.org/Parsing_a_simple_imperative_language
13:56:09 <mmachenry> That example uses all of them. 
13:56:43 <orzo> do you guys often use foldr to buid functions that are immediately applied so that the foldr appears to take one more aditional argument?
13:56:44 <Denommus> mmachenry: I wish I could use megaparsec instead of parsec. It looks a better library in general
13:56:55 <mmachenry> I don't know it.
13:57:03 <mmachenry> Why can't you use it?
13:57:17 <orzo> it's a recuring pattern in my code and I'm not satisfied with the readibility of it
13:57:51 <yitz> orzo: yes that is a common technique. why don't you think it's readable?
13:57:56 <Cale> orzo: I do it, but not very often
13:58:11 <Cale> It's handy if you want some additional state during the fold
13:58:18 <Cale> Though I'm sure you already know this
13:58:27 <orzo> it's not readible because there's a lot of positional arguments on fold and people expect fold's last argument to be a list
13:59:02 <Cale> Well, it might be a little confusing if you're being implicit about the last few arguments.
13:59:06 <Denommus> mmachenry: lack of as much tutorial as parsec, mostly XD
13:59:12 <Cale> Or there aren't enough type signatures around
14:00:24 <yitz> orzo: i do it more often with maybe, like: maybe id (:) mElt list
14:00:26 <mmachenry> Denommus: Parsec has been good to me. I suggest trying it and seeing how it goes.
14:10:36 <luite> what's a good way to check which packages in a package db are older than the latest version on hackage?
14:13:57 <glguy> I run: GhcPkgUtils outdated
14:14:27 <glguy> https://github.com/glguy/GhcPkgUtils
14:14:50 * hackagebot casadi-bindings 2.4.1.4 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-2.4.1.4 (GregHorn)
14:14:51 <glguy> it can also do recursive unregistration which is handy when it's time to update
14:18:10 <luite> glguy: ah i can't use that, I just want to check from time to time whether I should update submodules in ghcjs-boot :)
14:19:37 <glguy> It wouldn't be much work to have it look at a particular package-db instead of the User one
14:21:13 <luite> glguy: oh it needs to look in the global package db. but it complains about the ghcjs version being older than 6.4 (it's 0.2.0), how does it determine the outdated packages?
14:21:38 <glguy> https://github.com/glguy/GhcPkgUtils/blob/master/InstalledPackages.hs
14:21:55 <glguy> asks Cabal
14:22:46 <luite> oh right, it has to supply the equivalent of --ghcjs to configure then
14:22:54 <glguy> There's an older version that calls 'ghc-pkg' directly
14:23:51 <glguy> I figured out just enough of how Cabal does that stuff to write what's in that module
14:26:43 <lwm> hmmm ... I am having a tough time writing the body of a function with two Maybe a parameters
14:26:46 <lwm> https://gist.github.com/lwm/47c578b179dc07e11561
14:26:48 <lwm> anyone got a hint?
14:30:09 <tommd> lwm: Well, what should happen when either mood or tense are Nothing?
14:30:16 <tommd> Just pattern match and handle each case.
14:30:47 <lwm> OK, when either mood or tense are Nothing, I would just give a default value
14:30:50 <tommd> verbDetail verb (Just m) Nothing =??? ; verBdetail verb Nothing (Just t) = ??? ; verbDetail v (Just a) (Just b) = >???
14:30:53 <lwm> so I should just use `case x of`
14:31:12 <tommd> Or just have a few top level pattern matches and forget the case.
14:31:17 <lwm> ah, I see. I will try that
14:31:30 <tommd> verbDetail v (Just m) (Just t) = ??? ; verbDetail _ _ _ = default
14:32:03 <ReinH> Cale: I'm going to try to combine our LSystem work and see if I can get anything interesting out of varying the "determinacy" parameter.
14:32:37 <Cale> ReinH: I've thought that there might be something interesting from putting a continuation monad in there :)
14:32:42 <ReinH> oh?
14:32:44 <ReinH> Go on!
14:32:53 <ReinH> in where specifically?
14:33:33 <ReinH> Cale: I thought about https://hackage.haskell.org/package/comonad-random-0.1.2/docs/Control-Comonad-Random.html for randomization
14:33:44 <Cale> i.e. the right hand side of each rule is in Cont r String rather than [String] or Rand String, or whatever.
14:34:10 <ReinH> Ah, ok. What, er, what would that do?
14:35:12 <Cale> Good question! I'm thinking you could have some symbol which gets (some part of?) the current continuation
14:35:18 <Cale> and does something with that
14:35:33 <ReinH> I am intrigued.
14:35:39 <Cale> I'm not sure exactly
14:35:49 <Cale> It was a vague thought at the time and it still is
14:36:02 <ReinH> Ok! Well, I'll write up what I have and maybe it'll spark some more ideas.
14:36:28 <Cale> But it would probably be worth trying some simple things with the operations in various monads
14:36:35 <Cale> Like, you could have L-systems with state easily
14:37:02 <Cale> and maybe put in some productions which increment and decrement a state counter
14:37:21 <Cale> and some other production whose outcome depends on it
14:39:18 <ReinH> Right.
14:42:09 <lwm> tommd: thanks, that seems to be getting me on the right direction
14:42:17 <tommd> lwm: Glad to help.
14:42:56 <ReinH> Cale: btw I also used the diagrams turtle drawing stuff pretty easily
14:43:19 <shalom> anyone have any good examples of testing Scotty APIs? I'm searching but coming up empty.
14:43:32 <lwm> I pass those Maybe a values like tense/mood to another function which has a type signature without Maybe in it
14:43:57 <lwm> I get a type error ... do I need to change my type signatures all the way down the line for any function that accepts a value of Maybe a ?
14:44:18 <ReinH> lwm: What do you want to do when it's a Nothing?
14:44:29 <pyon> Is there any package with the same functions as Data.List, but with less Boolean blindness issues?
14:44:40 <lwm> tense would equal some string, a default
14:45:13 <frerich> Does anybody know of Haskell packages which perform some sort of source code analysis given a tree, e.g. dead code analysis for a control flow graph or unused values for a data flow graph or something like that?
14:45:21 <pyon> For instance, I think `span` should have type `(a -> Either b c) -> [a] -> ([c], Maybe (b, [a]))`.
14:45:45 <SrPx> Is anyone willing to take the challenge of explaining dependent type system for a (potentially stupid) human being like me? http://stackoverflow.com/questions/33641027/what-is-a-brief-but-complete-explanation-on-how-a-pure-dependent-type-system-ope
14:45:52 <tommd> lwm: Could you paste?
14:45:54 <tommd> @where paste
14:45:54 <lambdabot> Haskell pastebin: http://lpaste.net/
14:46:23 <tommd> lwm: After pattern matching the (Just x :: Maybe a), x is of type 'a'.
14:46:32 <tommd> So you should not need to "push" the Maybe type to lower levels.
14:46:59 <Cale> pyon: That would be annoying in probably 99% of the cases where you want span :)
14:47:12 <ReinH> SrPx: They are covered in Advanced Topics in Types and Programming Languages.
14:47:31 <varaindemian> jle`: where can I see a detailed version of that?
14:47:55 <SrPx> ReinH: I'll take a look and feedback in a min, but is the format friendly ?
14:48:15 <ReinH> SrPx: Well, it assumes familiarity with type systems in general, of the sort obtained by working through TaPL.
14:48:32 <lwm> tommd: right, that is what I thought
14:48:34 <lwm> tommd: http://lpaste.net/145010
14:48:45 <ReinH> And it isn't written by Pierce, only edited, so the quality varies, but I think the dependent types chapter is pretty good.
14:48:49 <ReinH> And TaPL is worth working through anyway.
14:49:08 <ReinH> :t span
14:49:09 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
14:49:17 <tommd> lwm: You failed to pattern match in line 6 - leaving 'tense' and 'mood' as 'Maybe Tense' and 'Maybe Mood'.
14:49:26 <tommd> Delete line 6
14:49:53 <lwm> tommd: oh right. perfect.
14:49:54 <ReinH> pyon: (a -> 2) -> [a] -> ([a], [a]) is exactly the right type signature, for some value of 2. Bool happens to be a convenient one.
14:50:14 <ReinH> (2 being any type with 2 (non-bottom) inhabitants)
14:50:19 <Cale> I mean, there are other types you could consider if we had a dependent type system
14:50:22 <SrPx> If TaPL is the book with a chapter about Java, I think I tried reading that book, but I couldn't follow it because it was mostly about proofs that I really didn't understand nor was interested enough to try understanding.
14:50:25 <ReinH> Cale: sure
14:50:51 <pyon> Cale: At least it could be `(a -> Maybe b) -> [a] -> ([b], [a])`
14:50:53 <lwm> tommd: ace, things work now.
14:50:56 <ReinH> SrPx: Well, the topics in TaPL are prerequisites for dependent types.
14:51:28 <ReinH> pyon: That's an interesting function, but it it isn't span.
14:51:37 <ReinH> s/it it/it
14:51:42 <pyon> ReinH: Let's say I have `f :: a -> Maybe b`, and want to split [a] into ([b], [a]). Doing this with the existing `span` function requires using isJust and fromJust. Uglee. :-|
14:52:10 <ReinH> pyon: Well yes, span isn't the right function for that. span is the right function when you want to split an [a] into ([a], [a])
14:52:21 <SrPx> Why would it be, ReinH? I see the implementation of pure type system is really short, so it shouldn't need a whole book explaining it? All I need is a brief explanation and some examples of the operational mechanics
14:53:02 <ReinH> SrPx: Well, why don't you try the dependent types section of ATiTAPL and use it as a forcing function to read whatever you need to from TaPL to keep up?
14:53:33 <ReinH> I'm sure you're correct that you don't need all of TaPL, but I can't tell you which parts you may or may not need.
14:53:56 <tommd> SrPx: Why do you think the implementations are short? Have you implemented 'Inside-Out'?  It's complex as heck.
14:54:35 <ReinH> If you're asking for "operational semantics" of dependent types then I'm quite sure you need to study more.
14:54:37 <hexagoxel> can a library be BSD3-licensed when its dependency is under GPL ?
14:54:45 <pyon> ReinH: Probably only needs the parts on parametric polymorphism and type operators (chapters 22-25 and 29-30).
14:55:30 <SrPx> tommd: I'm talking about the pure type system, with annotations, no inference. As far as I know it takes a few changes from the simply typed lambda calculus and is even simpler in some aspects.
14:55:44 <ReinH> hexagoxel: I'm pretty sure it cannot. GPL "infects" any things that depend on it. Sorry for using a biased word, but I mean it in a neutral way.
14:55:56 <Cale> I don't see why not though, unless it includes a significant amount of content from its dependency directly.
14:56:15 <Cale> It wouldn't infringe on the copyright of the other work, and so the licensing of that work wouldn't matter.
14:56:31 <ReinH> Cale: That's not how GPL works, afai understand.
14:56:46 <ReinH> The whole point of GPL is to "infect" things that use GPL-licensed works in this way.
14:56:54 <hexagoxel> well, interesting. i should inform the storablevector maintainers :D
14:57:02 <Cale> It infects *derivative works*
14:57:17 <Cale> I don't think just having a library as a dependency makes you a derivative work of the library.
14:57:38 <mniip> yes
14:57:41 <mniip> linking exception
14:58:37 <Clint> hexagoxel: the source can be
14:59:08 <Tertain> I thought it has to be licensed as GPL if it statically links a GPL library.
14:59:11 <ReinH> GPL doesn't have a linking exception per se. You would need an explicitly *modified* GPL that includes a linking exception.
14:59:29 <hexagoxel> Clint: true
14:59:34 <ReinH> (https://en.wikipedia.org/wiki/GPL_linking_exception)
14:59:51 * hackagebot pandoc-crossref 0.1.5.6 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.5.6 (lierdakil)
14:59:53 * hackagebot bank-holiday-usa 0.0.1 - A library for determining US bank holidays  https://hackage.haskell.org/package/bank-holiday-usa-0.0.1 (tippenein)
14:59:54 <Clint> which is typically what one licenses on Hackage
15:00:01 <Cale> I don't think modifying the GPL could have any effect on the question legally.
15:00:07 <ReinH> Clint: what do you mean?
15:00:19 <yogle> i thought the LGPL allows linking
15:00:21 <ReinH> Cale: I'm saying that the straight up GPL license does not have a linking exception.
15:00:27 <ReinH> The LGPL allows linking because it has such an exception.
15:00:32 <Cale> Because the GPL is a license to use something when it would otherwise be disallowed by copyright law.
15:00:48 <yogle> maybe you can distribute your libarry in source form
15:01:04 <ReinH> Works that link to GPL must also be GPL licensed unless the version of GPL used specifically has a linking exception.
15:01:06 <Cale> For example, I think it's okay for a BSD licensed library to link to a completely proprietary library
15:01:10 <yogle> but as soon as you ship binaries, everything needs to be GPL or compatible
15:01:18 <Cale> (or program)
15:01:32 <ReinH> Cale: They can link to whatever they want, the question is can they be *distributed*?
15:01:47 <Cale> and you could distribute your BSD licensed code
15:01:56 <ReinH> No, you couldn't. Not under the terms of the GPL.
15:01:56 <Cale> You couldn't distribute the proprietary code.
15:02:05 <yogle> ReinH: distributed in binary or source code?
15:02:05 <Cale> Let's forget about the GPL for a moment
15:02:08 <ReinH> Ok.
15:02:16 <ReinH> yogle: Yes.
15:02:21 <ReinH> They are the same.
15:02:23 <Cale> Let's instead consider what you could do when you have no license whatsoever to the code that you're linking to
15:02:27 <Clint> ReinH: i mean that hackage isn't distributing binaries
15:02:34 <Cale> GPL only *gives* you rights
15:02:43 <Cale> It can't legally take away your rights
15:02:54 <ReinH> Cale: I see what you're saying.
15:03:02 <ReinH> But what is the actual situation for the library in question?
15:03:49 <ReinH> I think it's somewhat of a grey area. Does depending on another library that a dependecy-management tool (e.g., Cabal) installs constitute distributing that library?
15:03:53 <hexagoxel> hackage probably should include a all-transitive-dependency-licenses when looking at a package, in addition to the source-license
15:04:01 <yogle> GPL gives you rights only under certain conditions
15:04:12 <hexagoxel> because that is what you will be interested in, in the end.
15:04:14 <yogle> you must offer it to your users under the same conditions
15:04:29 <Cale> As a case in point, GHC, which is BSD licensed, links to GMP, which is GPL'ed.
15:04:57 <tommd> yogle: Well, GPL gives you rights under the same conditions as the US constitution. You must be the audience intended for the rights to apply.  In the case of GPL the users are the rights holders.
15:04:58 <Cale> It could do so even if GMP were proprietary
15:05:14 <Clint> Cale: no, it's LGPL'd
15:05:23 <Cale> Many many Windows programs, even open source ones, link to Microsoft proprietary libraries.
15:05:28 <ReinH> I think pragmatically it's Schroedinger's license until a suit is brought to determine its legality, and that is unlikely to happen.
15:05:49 <tommd> Can we get that as a cabal option for the license field?
15:05:50 <Cale> They don't need a license to link to those, only to be distributed with them.
15:06:37 <Cale> If the libraries, e.g. come with Windows, so that there's no need to distribute the libraries to the user of the BSD-licensed code, then everything is fine.
15:06:56 <yogle> at least in the open source world, libraries are often intentionally put under LGPL to not infect the rest of the code
15:07:16 <ReinH> Cale: I see what you're saying, and I agree, although in the end what matters is whether a judge agrees. I wonder if there's any case law.
15:07:51 <cite-reader> Does anyone here know a lawyer we can nerd-snipe with this?
15:08:07 <ReinH> Heh. I'm sure you can nerd snipe them for $300/h all you want.
15:08:10 <yogle> ReinH: i heard that at least for the GPL 2.0 there is case law
15:08:29 <ReinH> Or whatever they're charging these days
15:08:38 <ReinH> I wonder if we've strayed a bit too far off topic at this point, though?
15:09:13 <Cale> If you want to distribute a program which *contains* GPL-licensed code, then the GPL applies to you.
15:09:29 <Cale> If you expect your users to obtain the GPL-licensed code from elsewhere, then it does not.
15:09:53 <ReinH> Cale: Yes, I understand.
15:15:15 <ReinH> Cale: Ok, here's something from SFLC https://www.softwarefreedom.org/resources/2007/gpl-non-gpl-collaboration.html
15:15:21 <ReinH> That's probably about as definitive as you can get
15:15:44 <ReinH> Not exactly the question at hand though :/
15:16:15 <Cale> yeah, this is about including GPL'd code into a project
15:16:43 <Cale> (which makes sense because that's a situation in which the GPL will actually take effect, when the project is distributed)
15:17:04 <Cale> If copyright law doesn't apply, then the GPL doesn't apply :P
15:18:26 <hexagoxel> it would also make sense to add some new field to packages that describes the licenses of dependencies. e.g. in case you depend on some non-haskell library under a specific license.
15:19:22 <hexagoxel> optional, and without any guarantees of correctness, of course.
15:20:36 <hexagoxel> (or was this discussion closed as off-topic? i hope this is ok, as my suggestions targets the haskell infrastructure)
15:24:17 <Clint> hexagoxel: in theory things like spdx were to do stuff like that for you
15:27:47 <hunteriam> guys i need a pointer for this problem
15:27:53 <hunteriam> so were in a 4d vector space
15:28:04 <hunteriam> and we have a bunch of points in the vector space
15:28:11 <hunteriam> we want to go from the origin to a given point
15:28:15 <hunteriam> by finding a path through the points
15:28:20 <hunteriam> but we can only move on one axis at a time
15:28:26 <hunteriam> for each step on the path
15:28:51 <hunteriam> i imagine theres a good way of solving this that im not familiar with
15:29:32 <ReinH> hunteriam: just set up the edges between points in your graph correctly
15:29:51 <hunteriam> and then do a dfs or bfs?
15:29:54 <hunteriam> or a* or something?
15:29:56 <ReinH> You can look at the grid package for inspiration.
15:30:07 <hunteriam> im curious if theres a way to construct my graph quickly
15:30:21 <ReinH> In that situation you can do what grid does to find the shorteset path a bit more quickly
15:30:36 <hunteriam> ill take a look at it
15:30:55 <hunteriam> if ive got a list of the points, im not sure how i can organize them or go through them to build this graph extra quickly
15:31:03 <hunteriam> id imagine there exists some way though
15:35:43 <hunteriam> ReinH: im not seeing the connection to grid, since I don't know how many neighbours each node can have
15:37:23 <ReinH> hunteriam: that's how grid works too
15:37:49 <ReinH> Hmm, actually you're right, sorry.
15:38:04 <ReinH> @hackage astar
15:38:04 <lambdabot> http://hackage.haskell.org/package/astar
15:38:30 <ReinH> hunteriam: you can consider how you might phrase your problem in the terms that aStar wants.
15:44:41 <hunteriam> Does anyone have any suggestions on how to quickly get a list of 4D vectors into a graph where two vectors are connected if only one axis is different between them
15:44:44 <hunteriam> axis value
15:44:46 <hunteriam> i mean
15:46:07 <begriffs> I've got some code that uses getPOSIXTime and I'd like to test it with hspec. To do so I would need to fake the system time in the test. How can I do this?
15:47:05 <MarcelineVQ> You could hide getPOSIXTime in your imports and implement your own that just spits out the same value you want every time
15:47:19 <cheater> begriffs: you could use a free monad.
15:48:11 <begriffs> For context the code is inside a web server (for testing the expiration of web tokens). If possible I would like to do mock the time as part of a full feature test, where the client (hspec) sends a token, then time fast forwards, then the token fails a second time.
15:48:22 <ReinH> begriffs: The simpler solution is the separate things such that you can pass a specific time in that you create yourself in the places you need to test
15:49:10 <begriffs> ReinH: then just unit test those separate functions?
15:49:37 <ReinH> yeah
15:50:02 <FofG> Trying to do a pattern match inside of a do block, something like someMaybe <- foo; case someMaybe of Just bla -> do $ ...
15:50:12 <begriffs> OK. Is it actually possible to mock the system time, even if it's not advisable?
15:50:30 <FofG> but getting "parse error in pattern, possibly caused by a missing 'do'?"
15:51:14 <pavonia> FofG: Could you paste the full case expression?
15:51:19 <kadoban> FofG: lpaste the code
15:52:12 <FofG> sure, sorry
15:52:14 <FofG> one sec
15:52:52 <FofG> http://lpaste.net/5092372543378030592
15:53:09 <nex> how can I get the current year as an "Integer" ? (or convert an Integer so I can substract 2 years)
15:53:43 <pavonia> FofG: I guess the $ after "do" is the problem
15:54:10 <FofG> oh weird, dunno why I added that 
15:54:12 <FofG> thanks
15:55:28 <pavonia> nex: Have a look at to/fromGregorian from Data.Time.Calendar
16:06:57 <gfixler> I've been playing with some Coord -> a ideas I picked up in a couple of conal talks
16:07:19 <gfixler> but I'm running into some seemingly very unoptimized situations
16:07:37 <jophish> 1/quit
16:07:59 <gfixler> for example, bezier curves - every coordinate in the infinite plane now needs to be checked for nearness to every curve
16:08:35 <gfixler> or in an animation, an explosion would need every flying piece of shrapnel checked from every coordinate
16:08:56 <gfixler> bounding boxes and such can help, but it still feels like a potentially huge amount of work
16:10:14 <gfixler> from the other direction, I have a very finite number of objects to render
16:11:16 <nex> pavonia, uh, i tried many things, i just cant convert io int(year) to int .. im trying to get current year as integer (not io int)
16:12:09 <pavonia> toGregorian gives the year as Integer
16:16:07 <pavonia> nex: Wait, are you saying you want to convert IO Int to Int?
16:16:36 <ReinH> I wonder if they expect to deal with the year 9223372036854775808
16:17:38 <nex> pavonia, i know its a bad idea but my function is receiving an Integer (year) and I want to substract current year and return an integer
16:18:12 <pavonia> nex: And what's the problem with that?
16:18:55 <ReinH> You can only use IO Int (or IO Integer) inside an IO action, like with do notation in main.
16:19:33 <ReinH> Well, you can use IO Int anywhere, you can only use the Int inside an IO action.
16:20:52 <shachaf> There is no Int.
16:22:22 <bitemyapp> (succ (ReinH ^. wellActuallyCoefficient)) == (shachaf ^. wellActuallyCoefficient)
16:29:57 <hunteriam> hey guys
16:30:12 <johnw> hunteriam: hi
16:30:46 <hunteriam> i have a 4d vector space where i can only move between points if they're different on one axis
16:30:57 <hunteriam> and i need to implement path finding on this space
16:31:06 <hunteriam> im looking for fresh ideas on how this could be done well
16:31:17 <hunteriam> if it helps, the space is fixed in size
16:31:28 <cramp33> Can >>= be generalized to take a function of two args on its rhs?
16:31:35 <hunteriam> or i guess you could say the field is 26 dimensional
16:32:22 <cramp33> iow, I'd like a point-free way of doing do { x1 <- a1; x2 <- a2; f x1 x2 }
16:33:15 <pavonia> @@ @pl @undo do { x1 <- a1; x2 <- a2; f x1 x2 }
16:33:15 <lambdabot>  (a2 >>=) . f =<< a1
16:33:41 <cramp33> thx, pavonia
16:33:49 <hunteriam> is there a more efficient way of writing (filter f list, filter q list ...) when i know the results from filter f list cannot be in filter q list
16:34:08 <pavonia> cramp33: Not a very nice way, though
16:34:13 <hunteriam> i mean is partition f list more efficient, and is there a neat way to repeat partitions on the fail set?
16:34:20 <ReinH> cramp33: liftM2
16:34:39 <cramp33> ReinH: tried that, comes close but no cigar.
16:35:04 <ReinH> Ah, you need to join afterwards
16:35:49 <ReinH> (filter f &&& id) (filter q list)
16:36:09 <pavonia> :t (join .) . liftM2
16:36:11 <lambdabot>     Occurs check: cannot construct the infinite type: m ~ (->) (m a2)
16:36:11 <lambdabot>     Expected type: (a1 -> a2 -> a) -> m a1 -> m a2 -> m a2 -> a
16:36:11 <lambdabot>       Actual type: (a1 -> a2 -> a) -> m a1 -> m a2 -> m a
16:36:20 <pavonia> :t ((join .) .) . liftM2
16:36:21 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
16:45:53 <hunteriam> why isnt zip/zipwith implemented as Traversable
16:45:56 <hunteriam> instead of as List
16:46:04 <hunteriam> I;d really like having those functions right now ;_;
16:50:57 <johnw> how would that work
16:51:35 <johnw> you might want http://hackage.haskell.org/package/these
16:59:58 * hackagebot monoid-extras 0.4.0.3 - Various extra monoid-related definitions and utilities  https://hackage.haskell.org/package/monoid-extras-0.4.0.3 (bergey)
17:00:00 * hackagebot dual-tree 0.2.0.8 - Rose trees with cached and accumulating monoidal annotations  https://hackage.haskell.org/package/dual-tree-0.2.0.8 (bergey)
17:02:25 <shalom> What does with mean in this context?
17:02:27 <shalom> spec :: Spec
17:02:27 <shalom> spec = with app $ do
17:02:47 <dfeuer> Hackage seems to have its character encoding configured wrong. It seems to be serving up Haskell source as some Windows encoding instead of UTF-8.
17:02:53 <dfeuer> Who's in charge of that?
17:02:58 <dfeuer> Shalom, shalom.
17:03:08 <shalom> Shalom :)
17:03:15 <dfeuer> shalom, I can't say for sure, but it kind of looks like Snap?
17:03:36 <shalom> It's from here -- https://github.com/hspec/hspec-wai --wai testing
17:03:59 <dfeuer> Ah. I guess with is from WAI, and used by Snap, or something.
17:04:15 <shalom> Ah. :(
17:04:17 <shalom> Hm.
17:04:32 <dfeuer> I don't actually know quite what it does, but you should be able to dig it up in the WAI package.
17:04:39 <shalom> For sure :)
17:05:03 * hackagebot diagrams-core 1.3.0.4 - Core libraries for diagrams EDSL  https://hackage.haskell.org/package/diagrams-core-1.3.0.4 (bergey)
17:05:05 * dfeuer goes to try to do that now.
17:05:05 * hackagebot active 0.2.0.8 - Abstractions for animation  https://hackage.haskell.org/package/active-0.2.0.8 (bergey)
17:05:07 * hackagebot diagrams-lib 1.3.0.8 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.3.0.8 (bergey)
17:05:18 <shalom> What I was initially trying to do is write tests for a Scotty application, but couldn't really find many resources
17:05:42 <dfeuer> Nope, not WAI.
17:05:46 <dfeuer> Let's check hoogle.
17:06:17 <dfeuer> ARGH. Lots and lots of options.
17:06:27 <shalom> lol
17:06:58 <dfeuer> shalom, I found it.
17:07:12 <shalom> yay :)
17:07:19 <dfeuer> It's actually in hspec-wai itself.  https://github.com/hspec/hspec-wai/blob/master/src/Test/Hspec/Wai.hs#L53
17:08:50 <dfeuer> shalom, `before` is from Test.Hspec. http://haddock.stackage.org/lts-3.13/hspec-2.1.10/Test-Hspec.html#v:before
17:09:30 <shalom> Ah, so basically take any type of io object and run the methods over it to produce Spec?
17:10:04 * hackagebot diagrams-contrib 1.3.0.8 - Collection of user contributions to diagrams EDSL  https://hackage.haskell.org/package/diagrams-contrib-1.3.0.8 (bergey)
17:10:06 * hackagebot diagrams-postscript 1.3.0.4 - Postscript backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-postscript-1.3.0.4 (bergey)
17:10:08 * hackagebot diagrams-svg 1.3.1.7 - SVG backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-svg-1.3.1.7 (bergey)
17:10:09 <shalom> sorry, im really new to haskell
17:11:12 <varaindemian> Can anyone explain this to me? filter' p = foldr (\x acc -> if p x then x : acc else acc) []  
17:11:32 <varaindemian> Why isn't foldl instead of foldr?
17:11:55 <Axman6> try it out - foldl wou;d give a reversed list
17:12:25 <dfeuer> shalom, uh, sorry. I don't actually know HSpec :P
17:12:35 <Axman6> > foldl (\acc x -> if even x then x : acc else acc) [1..10]
17:12:37 <lambdabot>      No instance for (Typeable t0)
17:12:37 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
17:12:37 <lambdabot>        arising from a use of ‘show_M49165311237596837545404’
17:12:40 <shalom> Sugar :) is okay
17:12:41 <Axman6> > foldl (\acc x -> if even x then x : acc else acc) [] [1..10]
17:12:43 <lambdabot>  [10,8,6,4,2]
17:13:06 <shalom> Mostly just having the issue of instantiating Scotty in two different ways - one IO () and the other IO Application
17:13:14 <shalom> not sure how to do it
17:13:43 <varaindemian> Axman6: I see. thx
17:14:15 <Axman6> varaindemian: remember that the function passed to foldr replaces the (:) in lists
17:16:47 <dfeuer> shalom, I happen also to be attempting to figure out how to use (any) Haskell web framework.
17:17:04 <dfeuer> They seem as inscrutable as all the other web frameworks :/
17:17:12 <shalom> haha
17:17:41 <EvanR> its the web man
17:17:45 <shalom> They are, but the language is whats killing me
17:17:52 <EvanR> dont try to understand it, just let to flow like water
17:17:54 <dfeuer> Oh, the language is the easy part.
17:18:03 <dfeuer> :P
17:18:06 <shalom> heh
17:18:19 <shalom> I'm coming from JavaScript so web's not too bad
17:18:20 <EvanR> ever tried ur-web
17:18:28 <dfeuer> It's really a lot like learning a foreign language. Grammar's not so bad, but the vocabulary... damn...
17:18:45 <cite-reader> Ur/Web has, hands down, the fanciest types I've ever seen.
17:18:45 <dfeuer> Grammar ~= language; vocabulary ~= libraries.
17:18:58 <EvanR> yes
17:18:58 <varaindemian> Axman6: and this one head' = foldr1 (\x _ -> x) 
17:19:02 <varaindemian> ?
17:19:16 <dfeuer> EvanR, is that a Haskell package, or some other language?
17:19:23 <EvanR> its some other language
17:19:53 <dfeuer> By Chlipala? Is this a giant custom type system for web programming?
17:20:24 <EvanR> yeah
17:20:30 <EvanR> with databases (tm)
17:20:42 <dfeuer> o.O
17:21:06 <cite-reader> Here's an actual type signature from Ur: val fold : K --> tf :: ({K} -> Type)
17:21:06 <cite-reader>           -> (nm :: Name -> v :: K -> r :: {K} -> [[nm] ~ r] =>
17:21:06 <cite-reader>               tf r -> tf ([nm = v] ++ r))
17:21:06 <cite-reader>           -> tf []
17:21:06 <cite-reader>           -> r ::: {K} -> folder r -> tf r
17:21:24 <EvanR> dont ever try to reinvent the web with fancy types, its been done ;)
17:21:27 <dfeuer> That's crazy.
17:21:42 <dfeuer> That doesn't look so usable.
17:21:56 <EvanR> hopefully that signature is all you have to do and the rest is derived somehow
17:22:10 <EvanR> but thats probably expecting too much ;)
17:22:16 <cite-reader> To be fair, that's the primitive combinator for type-based metaprogramming, if I recall correctly.
17:22:19 <cite-reader> Still.
17:22:20 <johnw> Ur/web was demoed at ICFP, there is code that looks a lot nicer than that
17:22:38 <johnw> I can pick out pathological examples in any language you don't know that could scare you
17:23:06 <EvanR> i aint scurd
17:23:54 <scshunt> cite-reader: is Ur dependently typed?
17:24:12 <dfeuer> johnw, also any language I do know.
17:24:17 <johnw> lol
17:25:02 <cite-reader> I don't remember. I think it is.
17:25:15 <dfeuer> Haskell: the lens library, or iteratees, or pipes. Scheme: iteratees, or batshit code made of macros and continuations by Oleg.
17:28:57 <homovitruvius> is there a way to have haddock highlight correctly files w/ UnicodeSyntax?
17:29:11 <lethjakman-l> Is there a way to get the package or file something was defined in?
17:29:25 <lethjakman-l> I have a function (:|:) I'm having issues understanding. 
17:30:01 <shalom> Cool figured it out --
17:30:19 <shalom> Ended up splitting the handler part out from the application part
17:30:49 <shalom> so instantiate `scotty 3000 handlers` as well as scottyApp handlers`
17:31:57 <lethjakman-l> Ooo
17:31:59 <lethjakman-l> :info
17:35:05 * hackagebot sbv 5.5 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.5 (LeventErkok)
17:35:07 * hackagebot wai-app-static 3.1.2 - WAI application for static serving  https://hackage.haskell.org/package/wai-app-static-3.1.2 (MichaelSnoyman)
17:35:32 <mjrosenb> lethjakman-l: :|: isn't a function.
17:37:46 <EvanR> (:|:) could be a function
17:40:42 <mgsloan> It'd need to be a data type or data constructor, since it starts with :
17:40:58 <EvanR> :t (:+)
17:40:59 <lambdabot> a -> a -> Complex a
17:41:13 <EvanR> even if its a ctor... still a function
17:41:26 <mgsloan> True, but not just any function
17:41:27 <homovitruvius> re. haddock, it seems fine w/ chrome, just messed up w/ conkeror, so I'm good sorry for the noise
17:41:37 <EvanR> a function by any other name!
17:41:41 <mjrosenb> well, it is at the very least a function that is trivial to understand.
17:42:12 <mjrosenb> homovitruvius: you may want to check it out in firefox, since it also uses the gecko engine.
17:42:56 <mgsloan> I suppose pattern synonyms might let you make (:|:) be any function, not 100% sure though, I haven't yet used those much
17:43:08 <EvanR> > let (:::) = const in 3 ::: 4
17:43:10 <lambdabot>  Not in scope: data constructor ‘:::’Not in scope: data constructor ‘:::’
17:43:21 <EvanR> blast
17:47:52 <hunteriam> https://www.irccloud.com/pastebin/mjEDZV0j/
17:47:57 <hunteriam> can anyone explain this?
17:48:41 <mjrosenb> hunteriam: sure: you can't instantiate a type class with one of its variables filled in
17:48:50 <mjrosenb> hunteriam: it needs to be polymorphic.
17:48:57 <hunteriam> why is that?
17:49:03 <hunteriam> like as a design deciscion
17:49:52 <homovitruvius> mjrosenb: yes firefox is the same as conkeror.
17:52:31 <EvanR> hunteriam: its actualy possible, but you have to use an extension
17:52:58 <EvanR> however, to show V4 Int in a custom way, you should use a custom function
17:53:03 <EvanR> Show isn't for that
18:02:26 <lethjakman-l> mjrosenb: It's a kind, right?
18:02:58 <lethjakman-l> So. I'm not in a monad, but I want to pipe a value into functions from left to right, isn't there a way to do that?
18:03:27 <lethjakman-l> Like you would with bash
18:03:33 <lethjakman-l> cat blah.hs | fun1 | fun2
18:08:53 <Javran> how can I flip an Ord instance, any approach better than wrapping it in newtype?
18:10:46 <tzh> Javran: flip as in reverse the way it compares? Data.Ord has a Down wrapper that does that
18:11:37 <Javran> tzh: ah thanks, exactly what I want xD
18:11:46 <hunteriam> im wracking my brain here, can you write a Traversable instance for data V4 a = V4 a a a a
18:11:52 <hunteriam> I cant think of a way to do it
18:16:25 <hunteriam> figured it out, for the curious:
18:16:48 <hunteriam> traverse f (V4 a b c d) = V4 <$> f a <*> f b <*> f c <*> f d
18:17:23 <Iceland_jack> hunteriam: You can ask GHC to derive it for you
18:17:28 <hunteriam> how 
18:18:03 <Iceland_jack> You enable DeriveTraversable by placing {-# LANGUAGE DeriveTraversable #-} at the top of your source file or by entering the following into GHCi:
18:18:04 <Iceland_jack>     ghci> :set -XDeriveTraversable
18:18:27 <Iceland_jack> and and DeriveFunctor and DeriveFoldable, and then:
18:18:27 <Iceland_jack>     data V4 a = V4 a a a a deriving (Functor, Foldable, Traversable)
18:18:28 <jophish> hunteriam: you'll need to have a Functor and Foldable instance too
18:18:30 <Iceland_jack> yes
18:19:37 <jophish> lethjakman-l: you can use the (&) operator for left to right function "piping"
18:19:44 <jophish> :i (&)
18:20:14 <Iceland_jack> hunteriam: You can also enable ":set -ddump-deriv"
18:20:19 <hunteriam> cool stuff
18:20:21 <hunteriam> very interesting things
18:20:23 <hunteriam> thanks
18:20:29 <Iceland_jack> in e.g. GHCi, and then it will print the definition
18:21:02 <Iceland_jack> This is the definition for 'traverse', lol
18:21:02 <Iceland_jack>     Data.Traversable.traverse f_a9QZ (Ghci17.V4 a1_a9R0 a2_a9R1 a3_a9R2 a4_a9R3) = (GHC.Base.<*>) ((GHC.Base.<*>) ((GHC.Base.<*>) (GHC.Base.fmap Ghci17.V4 (f_a9QZ a1_a9R0)) (f_a9QZ a2_a9R1)) (f_a9QZ a3_a9R2)) (f_a9QZ a4_a9R3) 
18:22:58 <Iceland_jack> Cleaned up, kind of
18:22:59 <Iceland_jack>     traverse f_a9QZ (V4 a1_a9R0 a2_a9R1 a3_a9R2 a4_a9R3) 
18:22:59 <Iceland_jack>       = (<*>) ((<*>) ((<*>) (fmap V4 (f_a9QZ a1_a9R0)) (f_a9QZ a2_a9R1)) (f_a9QZ a3_a9R2)) (f_a9QZ a4_a9R3) 
18:32:00 <mac10688> Is there a way to install third party libraries with stack without having a project and cabal file setup? For instance, I have 1 haskell file that I'm using to test functions with and learn haskell. But I want to use Data.Universe and another package
18:32:16 <mac10688> how can I load those packages into my ghci, when I load  the single haskell file?
18:37:00 <mgsloan> https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md#ghcrunghc
18:37:33 <mac10688> mgsloan, reading
18:37:36 <mgsloan> "stack ghci" also takes the --package flag, so you can do "stack ghci --package universe"
18:43:29 <mac10688> thanks mgsloan , I'm going to looking over this now to see how all this works. I tried the stack ghci --package universe but it told me I needed more dependencies. it looks like I need to add them to my file.
18:44:41 <mgsloan> Welcome!  Yeah, it looks like universe is only in stackage nightly - http://www.stackage.org/package/universe
18:45:04 <mgsloan> So you could do "stack ghci --resolver nightly-2015-11-10 --package universe"
19:06:47 <lethjakman-l> jophish: I don't have & apparently. What do I need to import?
19:06:51 <mac10688> mgsloan, that did the trick. Just had to add QuickCheck in there too. Thank you very much!
19:10:58 <mgsloan> mac10688: Welcome!
19:16:04 <roconnor> Has stdgen changed in the last 5 years?
19:25:35 <Hijiri> roconnor: I think there is work going on right now to get a better random generator into random
19:26:46 <roconnor> 5 years ago I said to myself; I'll used a fixed random number seed for stdgen; that way my results would be reproducable.
19:26:54 <roconnor> fast-forward to today
19:27:21 <roconnor> I get different results. ... did I screw something up, or has stdgen changed (facepalm)
19:27:29 <roconnor> I should have used mersenne twister.
19:31:07 <Cale> roconnor: I imagine that StdGen has changed...
19:33:13 <Cale> Compare http://hackage.haskell.org/package/random-1.1/docs/src/System-Random.html and http://hackage.haskell.org/package/random-1.0.0.0/docs/src/System-Random.html
19:34:04 <roconnor> oh, maybe I can use an old version of random.
19:34:32 <Cale> yeah
19:35:39 <Cale> In some ways, given that it has changed, it's sad that it hasn't changed a whole lot more
19:35:57 <roconnor> I reran with GHC 6.12.3 and got my original results.
19:42:57 <hunteriam> is there a version of mappend for maybe such that mappend' (Just [1]) Nothing = Nothing
19:43:01 <hunteriam> instead of Just [1]
19:43:35 <Hijiri> there is the Last newtype
19:43:53 <glguy`> > liftA2 mappend (Just [1]) Nothing
19:43:55 <lambdabot>  Nothing
19:44:04 <hunteriam> can you explain what you did glguy
19:44:05 <Hijiri> wait
19:44:07 <Hijiri> I'm dumb
19:44:09 <Hijiri> sorry
19:44:44 <hunteriam> is that because of the Maybe applicative instance?
19:45:07 <c_wraith> yes
19:45:40 * hackagebot yesod-transloadit 0.5.0.0 - Transloadit support for Yesod  https://hackage.haskell.org/package/yesod-transloadit-0.5.0.0 (boblong)
19:45:52 <hunteriam> what a strange concept
19:46:47 <roconnor> hmm using random-1.0.0.2 under a modern GHC doesn't yeild my original results.
19:48:45 <roconnor> never should have used IO.
19:58:20 <Lokathor> i've finally got a working GHC, stack, and cabal on raspberry pi
19:58:30 <Lokathor> and i don't even know what i'd want to try and make it run
20:00:34 <jle`> hunteriam: if you don't care about the items inside in case of two Just's, you can use <|>
20:00:49 <hunteriam> i do care unfortunately
20:00:53 <hunteriam> thanks tho
20:01:00 <hunteriam> the liftA2 seems to work
20:03:03 <roconnor> Lokathor: really?  With template haskell and all?
20:03:18 <jle`> oh wait not <|>, i meant <* or *>
20:03:20 <roconnor> ghci?
20:04:36 <roconnor> Lokathor: If I had a working ghc on my raspberry pi I would write a dbus interface to omxplayer
20:05:02 <Lokathor> roconnor, i dunno. So far I used cabal from the repo and 7.10.3-rc1 to build stack, then used that stack to rebuild and install stack, then used that to install a fresh cabal
20:05:46 <Lokathor> it's a rpi2, so the arm build of 7.10.3-rc1 worked fresh out of the box. The raspberry pi 1 series wouldn't work with it i think
20:05:56 <roconnor> ahh
20:06:00 <roconnor> ;(
20:06:22 <Lokathor> raspbian has an old buggy GHC in the repo :/
20:06:55 <Lokathor> but C or Erlang might be better for you on rpi
20:07:54 <gfixler> Lokathor: program Jarvis into it, and mount it to your chest
20:08:01 <gfixler> and put some LEDs on it
20:08:22 <Lokathor> i'm only starting out on how to ust STM and persist
20:08:29 <Lokathor> i think Jarvis is a little above me :3
20:09:06 <roconnor> ghc 7.0.4 reproduces my old results!
20:09:24 <gfixler> Lokathor: you don't have to program Jarvis, just one of his predecessors
20:09:33 <gfixler> you just have to make him good enough to be able to make his replacement
20:10:09 <Lokathor> %goats
20:10:09 <pixiebot> https://www.youtube.com/results?search_query=goats
20:10:15 <Lokathor> how about that :3
20:10:32 <gfixler> that'll do
20:10:38 <gfixler> where do all these bots come from?
20:11:26 <Lokathor> what else will a low power, low-ish CPU, very slow disk speed device be used for?
20:11:47 <gfixler> ballistics
20:12:02 <Lokathor> get an rpi to calculate ballistics?
20:12:21 <gfixler> they would have killed for one of those in the 30s
20:12:49 <Lokathor> they would even have killed for one of these in the 90s :P
20:12:53 <gfixler> hehe
20:13:12 <gfixler> Project Raspberry - trying to build a pi before Hitler can
20:14:19 <roconnor> I'm imagining using an rpi to calculate blastics by shoving it into a cannon and firing it and seeing where it lands.
20:14:38 <gfixler> :)
20:18:14 <codygman> I want a function from ProcessId -> Bool that tells me if a given process id is running on my system. I can't find a findProcess function in unix or process libraries.
20:18:50 <codygman> Actually I'm looking for a ProcessId -> Maybe ProcessHandle
20:20:17 <Hijiri> I don't know if it exists, but it would probably have to be ProcessId -> IO (Maybe ProcessHandle)
20:20:52 <codygman> Hijiri: Right, it would of course do IO ;)
20:21:45 <codygman> for linux I guess I could just get all the directory names in /proc lol
20:21:45 <glguy_> What are you planning to do with the process handle? Wait?
20:22:09 <codygman> glguy_: yes ;)
20:22:11 <Hijiri> maybe getProcess
20:22:14 <Hijiri> sorry
20:22:21 <Hijiri> getProcessStatus would at least give you the Bool functionality
20:22:28 <Hijiri> I don't know though, I haven't used it
20:23:16 <codygman> getProcessStatus seems like it might work for my purposes
20:23:17 <glguy_> Codygman, you can only wait on your children afaik. You should already have the process handle from when you created the process
20:23:37 <codygman> glguy_: I won't have created it, I'm trying to make a debugger
20:24:24 <codygman> though I know very little about it, so perhaps a debugger has to launch a child process first?
20:25:00 <glguy_> I don't know what the interface is for attaching to a running process
20:28:20 <codygman> I should have read the ptrace binding docs (err code) better: https://github.com/maurer/ptrace/blob/master/src/System/PTrace.hs#L156
20:29:28 <codygman> whoops, wrong link.. for the curious: https://github.com/maurer/ptrace/blob/master/src/System/PTrace.hs#L244
20:30:42 * hackagebot typed-spreadsheet 1.0.0 - Typed and composable spreadsheets  https://hackage.haskell.org/package/typed-spreadsheet-1.0.0 (GabrielGonzalez)
21:10:18 <hunteriam> when i try and `stack build` i get stuck on `configuring package-name-0.1.0.0
21:10:25 <hunteriam> not a clue what to do
21:12:21 <kadoban> hunteriam: Try with --verbose or something, see what it's doing?
21:12:57 <hunteriam> kadoban: it gets to a ghc call and then output stops
21:13:11 <hunteriam> is there any wayto make it run ghc and cabal with verbosity too?
21:14:31 <kadoban> hunteriam: Is it really hung? How long did you let it try? Though I don't think that should usually take much time …
21:14:45 <hunteriam> kadoban: its still going
21:14:52 <hunteriam> no output
21:14:58 <hunteriam> unusually hung for ghc imo
21:15:18 <kadoban> Not really sure, maybe someone else will know better. Sounds odd.
21:15:28 <hunteriam> ;_;
21:18:21 <hunteriam> stack wont build anything i ask ittoo
21:18:27 <hunteriam> even in new fresh directories
21:19:00 <hunteriam> stack ghci is fine though
21:19:11 <hunteriam> anyway to nuke my ghc/cabal install and have stack reinstall it for me?
21:21:47 <kadoban> hunteriam: Yeah, how did you install them?
21:22:21 <kadoban> hunteriam: If through your package manager, use that to uninstall them. Otherwise, maybe they're in ~/.cabal and ~/.ghc , you can just delete (or move) those directories.
21:23:34 <zipper> j nairobilug
22:25:45 * hackagebot latex-formulae-pandoc 0.2.0.2 - Render LaTeX formulae in pandoc documents to images with an actual LaTeX installation  https://hackage.haskell.org/package/latex-formulae-pandoc-0.2.0.2 (LiamOConnorDavis)
22:35:46 * hackagebot relational-query 0.6.1.0 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.6.1.0 (KeiHibino)
22:55:49 * hackagebot Spock 0.10.0.1 - Another Haskell web framework for rapid development  https://hackage.haskell.org/package/Spock-0.10.0.1 (AlexanderThiemann)
23:15:50 * hackagebot relational-query-HDBC 0.2.0.0 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.2.0.0 (KeiHibino)
