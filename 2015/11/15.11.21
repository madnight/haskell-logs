00:07:41 * hackagebot buffon 0.1.0.0 - An implementation of Buffon machines.  https://hackage.haskell.org/package/buffon-0.1.0.0 (DerekElkins)
00:07:41 * hackagebot simplest-sqlite 0.0.0.10 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.0.0.10 (YoshikuniJujo)
00:37:59 * hackagebot text-postgresql 0.0.1.0 - Parser and Printer of PostgreSQL extended types  https://hackage.haskell.org/package/text-postgresql-0.0.1.0 (KeiHibino)
00:38:01 * hackagebot persistable-types-HDBC-pg 0.0.1.0 - HDBC Convertible instances and HRR persistable instances of PostgreSQL extended types  https://hackage.haskell.org/package/persistable-types-HDBC-pg-0.0.1.0 (KeiHibino)
00:43:00 * hackagebot relational-schemas 0.1.2.0 - RDBMSs' schema templates for relational-query  https://hackage.haskell.org/package/relational-schemas-0.1.2.0 (KeiHibino)
01:33:01 * hackagebot linode 0.1.0.0 - Bindings to the Linode API  https://hackage.haskell.org/package/linode-0.1.0.0 (Helkafen)
02:25:53 <matheus23> anyone had this issue as well: https://github.com/commercialhaskell/stack/issues/976
02:25:54 <matheus23> ?
02:36:08 <lpil> Hello guys. I installed a package globally with `stack install hlint`, how might I remove this package?
02:48:37 * hackagebot amazonka-core 1.3.6 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.3.6 (BrendanHay)
02:48:39 * hackagebot amazonka 1.3.6 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.3.6 (BrendanHay)
02:48:41 * hackagebot amazonka-test 1.3.6 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.3.6 (BrendanHay)
02:48:43 * hackagebot amazonka-config 1.3.6 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.3.6 (BrendanHay)
02:48:45 * hackagebot amazonka-sns 1.3.6 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.3.6 (BrendanHay)
02:53:47 * hackagebot amazonka-ecs 1.3.6 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.3.6 (BrendanHay)
02:53:49 * hackagebot amazonka-sqs 1.3.6 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.3.6 (BrendanHay)
02:58:15 <some0ne> hi
02:58:26 <some0ne> i'm trying to understand continuation
02:58:45 <some0ne> i think i understand what they are, but i can''t grasp what does callCC do
02:59:08 * hackagebot amazonka-glacier 1.3.6 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.3.6 (BrendanHay)
02:59:10 * hackagebot amazonka-cloudhsm 1.3.6 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.3.6 (BrendanHay)
02:59:12 * hackagebot amazonka-dynamodb 1.3.6 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.3.6 (BrendanHay)
02:59:14 * hackagebot amazonka-datapipeline 1.3.6 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.3.6 (BrendanHay)
02:59:16 * hackagebot amazonka-iam 1.3.6 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.3.6 (BrendanHay)
03:04:13 <jeltsch> some0ne: callCC gives you access to the current continuation.
03:04:18 * hackagebot amazonka-kinesis-firehose 1.3.6 - Amazon Kinesis Firehose SDK.  https://hackage.haskell.org/package/amazonka-kinesis-firehose-1.3.6 (BrendanHay)
03:04:20 * hackagebot amazonka-route53-domains 1.3.6 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.3.6 (BrendanHay)
03:04:21 <jeltsch> :t callCC
03:04:22 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
03:04:22 * hackagebot amazonka-directconnect 1.3.6 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.3.6 (BrendanHay)
03:04:24 * hackagebot amazonka-elasticsearch 1.3.6 - Amazon Elasticsearch Service SDK.  https://hackage.haskell.org/package/amazonka-elasticsearch-1.3.6 (BrendanHay)
03:04:26 * hackagebot amazonka-devicefarm 1.3.6 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.3.6 (BrendanHay)
03:05:01 <jeltsch> some0ne: callCC (\ continuation -> computationThatDependsOnContinuation)
03:05:24 <some0ne> for example: https://gist.github.com/anonymous/38ef3d488a442ab8b2bc
03:05:38 <jeltsch> some0ne: This performs the computationThatDependsOnContinuation, but this computation can use the continuation.
03:06:20 <jeltsch> So you provide a computation that depends on a continuation, and callCC makes sure that your computation gets run with the actual continuation in place.
03:06:37 <jeltsch> It is essentially a way to provide you with the current continuation.
03:07:12 <jeltsch> So why don’t we just have a function getCurrentContinuation :: MonadCont m => (a -> m b) or so?
03:07:36 <jeltsch> Well, because then the continuation you would get would be the computation that follows the call to getCurrentContinuation.
03:07:57 <jeltsch> However, you want the continuation to be the computation that follows some of your code.
03:08:21 <latk> If I have a record type that has loads of fields, one of which is Something x, is there a way I can pattern match on only that field?
03:08:41 <latk> (so I can extract the x)
03:08:45 <some0ne> i think my main issue is that i don't understand where the continuation come from (is it the next instruction, argument of the runCont etc... ?)
03:08:51 <jeltsch> With callCC, you provide the argument of type (a -> m b) -> m a, and you get the continuation that follows exactly this computation.
03:09:11 <jeltsch> some0ne: It is everything that follows your call to callCC.
03:09:24 <rmrfroot> i'm using orgmode-parse to parse org-mode documents, now i would like to print those documents back to plain text. i know `Show` only should be used for debug printing data, so what type class is more suitable to create instances of?
03:09:26 <some0ne> but what is callcc is the last instruction ?
03:09:28 * hackagebot amazonka-cognito-sync 1.3.6 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.3.6 (BrendanHay)
03:09:30 * hackagebot amazonka-elb 1.3.6 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.3.6 (BrendanHay)
03:09:32 * hackagebot amazonka-cloudformation 1.3.6 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.3.6 (BrendanHay)
03:09:34 <some0ne> *if
03:09:34 * hackagebot amazonka-sts 1.3.6 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.3.6 (BrendanHay)
03:09:45 <jeltsch> In the end, you are running the continuation with runCont, and the continuation is everything until the end of what you run with runCont.
03:10:28 <jeltsch> some0ne: If callCC is the last instruction, then the continuation is empty, that is, it does nothing.
03:11:20 <some0ne> hum okay
03:11:35 <jeltsch> Again, the continuation is not the next instruction (it is not even clear what the granularity for such atomic(?) instructions would be).
03:11:36 <some0ne> i will try reading again the papers, i think with your explanation it should be better ;)
03:12:01 <jeltsch> some0ne: The continuation is everything until the end (of what you run with runCont).
03:12:23 <jeltsch> some0ne: Glad that it helped. :-)  I agree that continuations are difficult to grasp at first.
03:12:30 <some0ne> :D
03:12:49 <jeltsch> But actually, the trick how callCC “returns” the continuation is also used elsewhere.
03:13:07 <jeltsch> I mean that it does not really return the continuation, but calls some user-supplied code with it.
03:14:16 <rmrfroot> i guess i'll try the `pretty` library to print the data
03:19:15 <keiopa> good morning!
03:20:32 <jeltsch> keiopa: Are you based in America or are you a late bird? ;-) 
03:21:38 * hackagebot amazonka-autoscaling 1.3.6 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.3.6 (BrendanHay)
03:21:40 * hackagebot amazonka-kinesis 1.3.6 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.3.6 (BrendanHay)
03:21:42 * hackagebot amazonka-kms 1.3.6 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.3.6 (BrendanHay)
03:21:44 * hackagebot amazonka-cloudsearch-domains 1.3.6 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.3.6 (BrendanHay)
03:21:46 * hackagebot amazonka-cloudwatch 1.3.6 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.3.6 (BrendanHay)
03:24:18 <some0ne> jeltsch: https://gist.github.com/anonymous/e398cfdaf051049eb6d8 can you explain me why example2CCC' does not work as i expect ?
03:26:48 * hackagebot amazonka-iot-dataplane 1.3.6 - Amazon IoT Data Plane SDK.  https://hackage.haskell.org/package/amazonka-iot-dataplane-1.3.6 (BrendanHay)
03:26:50 * hackagebot amazonka-cloudtrail 1.3.6 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.3.6 (BrendanHay)
03:26:52 * hackagebot amazonka-elasticache 1.3.6 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.3.6 (BrendanHay)
03:26:54 * hackagebot amazonka-waf 1.3.6 - Amazon WAF SDK.  https://hackage.haskell.org/package/amazonka-waf-1.3.6 (BrendanHay)
03:26:56 * hackagebot amazonka-importexport 1.3.6 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.3.6 (BrendanHay)
03:31:16 <Geraldus> Hi friends!
03:31:58 * hackagebot amazonka-s3 1.3.6 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.3.6 (BrendanHay)
03:32:00 * hackagebot amazonka-swf 1.3.6 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.3.6 (BrendanHay)
03:32:02 * hackagebot amazonka-sdb 1.3.6 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.3.6 (BrendanHay)
03:32:04 * hackagebot amazonka-codecommit 1.3.6 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.3.6 (BrendanHay)
03:32:06 * hackagebot amazonka-codedeploy 1.3.6 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.3.6 (BrendanHay)
03:32:15 <Geraldus> I have a UTCTime value given by getCurrentTime.  How can I increase this value by 3 months?  There is `addUTCTime`, the problem is how to produce NominalDiffTime value.
03:33:25 <jeltsch> some0ne: Honestly, I don’t understand it. The second line of the do block in example2 should print nothing, I would say. Unfortunately, I cannot look at this further now, as I have to leave.
03:34:11 <some0ne> ok no problem, thnaks ;)
03:34:51 <jeltsch> some0ne: I would look at the definition of callCC in the library sources, manually evaluate your example expression, and see what comes out of this.
03:34:58 <happyfeet> hey I have this: "c <- getChar" how can I make it receive an "UP ARROW" ? like, how can i put "c='up_arrow'"
03:35:07 <keiopa> jeltsch << no my friend, the other side of the world...
03:37:08 * hackagebot amazonka-cloudfront 1.3.6 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.3.6 (BrendanHay)
03:37:10 * hackagebot amazonka-efs 1.3.6 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.3.6 (BrendanHay)
03:37:12 * hackagebot amazonka-codepipeline 1.3.6 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.3.6 (BrendanHay)
03:37:14 * hackagebot amazonka-elasticbeanstalk 1.3.6 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.3.6 (BrendanHay)
03:37:17 * hackagebot amazonka-apigateway 1.3.6 - Amazon API Gateway SDK.  https://hackage.haskell.org/package/amazonka-apigateway-1.3.6 (BrendanHay)
03:37:53 <Geraldus> ok, this is quite simple: (toEnum . fromEnum . secondsToDiffTime $ secondsIn3Months) :: NominalDiffTime
03:42:19 * hackagebot amazonka-ses 1.3.6 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.3.6 (BrendanHay)
03:42:21 * hackagebot amazonka-support 1.3.6 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.3.6 (BrendanHay)
03:42:23 * hackagebot amazonka-dynamodb-streams 1.3.6 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.3.6 (BrendanHay)
03:42:25 * hackagebot amazonka-redshift 1.3.6 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.3.6 (BrendanHay)
03:42:27 * hackagebot amazonka-opsworks 1.3.6 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.3.6 (BrendanHay)
03:42:58 <jeltsch> keiopa: Other side? What do you mean? South America? This would be also America.
03:44:38 <keiopa> something like europe
03:45:35 <jeltsch> keiopa: Hmm, I’m in Europe as well, but it’s definitely not morning. So late bird? ;-) 
03:45:49 <keiopa> 11.45 it's am
03:45:55 <icen> Technically, it's still the morning here in GMT :P
03:46:03 <keiopa> xD
03:47:29 * hackagebot amazonka-emr 1.3.6 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.3.6 (BrendanHay)
03:47:31 * hackagebot amazonka-cognito-identity 1.3.6 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.3.6 (BrendanHay)
03:47:33 * hackagebot amazonka-ssm 1.3.6 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.3.6 (BrendanHay)
03:47:35 * hackagebot amazonka-ml 1.3.6 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.3.6 (BrendanHay)
03:47:37 * hackagebot amazonka-workspaces 1.3.6 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.3.6 (BrendanHay)
03:47:51 <jeltsch> keiopa, icen: Ah, I see. In English you say morning until right before 12. It’s different with the German “Guten Morgen!”, which is reserved for earlier times only.
03:49:09 <icen> You'd usually still be quite tongue in cheek to say "good morning" at 11:45, though :P
03:50:03 <Geraldus> How can I calculate nth root of Double value?
03:50:58 <jeltsch> > 10.0 ^^ (1 / 5)
03:51:00 <lambdabot>      Could not deduce (Integral b0) arising from a use of ‘^^’
03:51:00 <lambdabot>      from the context (Fractional a)
03:51:00 <lambdabot>        bound by the inferred type of it :: Fractional a => a
03:51:08 <jeltsch> > 10.0 ** (1 / 5)
03:51:10 <lambdabot>  1.5848931924611136
03:51:42 <Geraldus> jeltsch: thank you )
03:51:43 <jeltsch> Geraldus: See above. Use (**) for exponentiation with a Double exponent.
03:52:39 * hackagebot amazonka-inspector 1.3.6 - Amazon Inspector SDK.  https://hackage.haskell.org/package/amazonka-inspector-1.3.6 (BrendanHay)
03:52:41 * hackagebot amazonka-rds 1.3.6 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.3.6 (BrendanHay)
03:52:43 * hackagebot amazonka-iot 1.3.6 - Amazon IoT SDK.  https://hackage.haskell.org/package/amazonka-iot-1.3.6 (BrendanHay)
03:52:45 * hackagebot amazonka-ds 1.3.6 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.3.6 (BrendanHay)
03:52:47 * hackagebot amazonka-cloudwatch-logs 1.3.6 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.3.6 (BrendanHay)
03:57:49 * hackagebot amazonka-route53 1.3.6 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.3.6 (BrendanHay)
03:57:51 * hackagebot amazonka-cloudsearch 1.3.6 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.3.6 (BrendanHay)
03:57:53 * hackagebot amazonka-storagegateway 1.3.6 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.3.6 (BrendanHay)
03:57:55 * hackagebot amazonka-ec2 1.3.6 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.3.6 (BrendanHay)
03:57:57 * hackagebot amazonka-marketplace-analytics 1.3.6 - Amazon Marketplace Commerce Analytics SDK.  https://hackage.haskell.org/package/amazonka-marketplace-analytics-1.3.6 (BrendanHay)
03:59:41 <keiopa> <icen> : if u define and ask haskell, even now, he would tell you it's good morning (11:59)
04:02:59 * hackagebot amazonka-elastictranscoder 1.3.6 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.3.6 (BrendanHay)
04:03:01 * hackagebot amazonka-lambda 1.3.6 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.3.6 (BrendanHay)
04:12:10 * hackagebot contravariant-extras 0.2 - Extras for the "contravariant" package  https://hackage.haskell.org/package/contravariant-extras-0.2 (NikitaVolkov)
04:32:11 * hackagebot contravariant-extras 0.3 - Extras for the "contravariant" package  https://hackage.haskell.org/package/contravariant-extras-0.3 (NikitaVolkov)
04:47:12 * hackagebot bimaps 0.0.0.4 - bijections with multiple implementations.  https://hackage.haskell.org/package/bimaps-0.0.0.4 (ChristianHoener)
05:37:27 * hackagebot exact-real 0.9.0 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.9.0 (jophish)
06:25:56 <latk> which configuration file reader do people tend to use? there seem to be quite a few
06:26:43 <hc> i use Data.Configurator
06:26:45 <Rembane> Just plain yaml-files and the yaml package. https://hackage.haskell.org/package/yaml
06:27:03 <hc> Data.Configurator can read config files as you're used to under unix, plus it automatically reloads them when changed
07:29:50 <anks> why m has to be monad for (MaybeT m) to be applicative??
07:32:14 <bennofs> anks: MaybeT is a newtype over m (Maybe a). How would you implement (<*>) :: m (Maybe (a -> b)) -> m (Maybe a) -> m (Maybe b) if m is only Applicative? Keep in mind that a <*> b does not run the effects of b if a is a nothing for MaybeT
07:32:48 <niez> hi, I'm using postgresql-simple, in my database I have a column with type: numeric(10,2), what would be the corresponding Haskell type?
07:34:46 <anks> bennofs: https://gist.github.com/7088004c977c0fcf21e3 ? does break applicative laws?
07:35:28 <bennofs> anks: return Nothing <*> lift (print 42) should not print 42
07:35:42 <bennofs> anks: with your version, it does
07:36:08 <bennofs> (it should not print Nothing because that's what `ap` does, and if there is a Monad, the Applicative should behave like `ap`)
07:37:22 <anks> ok, thanks!
07:42:37 <anks> bennofs, actually it didnt typecheck ;p
07:57:57 <anks> bennofs: -- Since many Applicative instances define (<*>) = ap, we
07:57:57 <anks>               -- cannot define ap = (<*>)
07:58:35 <anks> ap IS <*>, so if it is possible to define ap, it has to be possible to define <*>
07:58:42 <anks> am I wrong?
08:02:19 <geekosaur> Monad, and therefore ap, predate Applicative by a couple of decades
08:02:40 <geekosaur> @src ap
08:02:40 <lambdabot> ap = liftM2 id
08:02:50 <nani___> I'm studying Haskell and I want to read some good (possibly not too complicated) code to see how things are actually done. Any idea about what project I might look at?
08:03:08 <anks> geekosaur, could you take a look at my orignal question?
08:03:28 <hpc> nani___: pandoc should be good
08:03:51 <nani___> hpc and it looks really cool too! Thanks :)
08:04:10 <indigo945> Hey. I'm trying to build something involving SDL2 2.1.0 using stack, but it fails because SDL2 1.3.1 is already installed
08:04:18 <indigo945> How can I ignore or unregister the existing library?
08:04:48 <anks> It was, why m has to be Monad for MaybeT m to be an Applicative?
08:05:41 <geekosaur> anks, you seem to have a misunderstanding somewhere. possibly because you're trying to think through things logically in terms of how they *should* be related, but because Applicative is fairly recent things are *not* related that way
08:06:35 <anks> the argument of bennofs was that it should print
08:06:37 <geekosaur> in particular, Applicative only became a prerequisite for Monad in the most recent version of base, so there are a lot of reverse relationships where Applicative is derived "after the fact"
08:06:51 <geekosaur> what?
08:07:06 <geekosaur> [21 15:35] <bennofs> anks: return Nothing <*> lift (print 42) should not print 42
08:07:12 <anks> inded
08:07:14 <anks> should not*
08:07:46 <anks> but it does on both implementations..
08:08:15 <anks> my (>>=) implementation is identical to prelude's
08:08:55 <anks> and with (<*>) = ap it bahaves in the same way as with my implementation using only m's <*>
08:09:10 <anks> for the given example
08:10:32 <geekosaur> the point of not defining it that way is that it's risky, because many monads back-form <*> from ap
08:10:46 <geekosaur> so it's a bad idea to develop that habit
08:11:17 <geekosaur> again, this is because Applicative came much later, not because it makes logical or mathematical sense
08:13:25 <anks> well, i might be a little dumb today, but I still dont understand why (Applicative m) restriction is worse than (Monad m) restriction .. :(
08:15:36 <Ferdirand> anks: within existential types, you mean ?
08:16:09 <Ferdirand> or actually no, it's an orthogonal issue
08:16:43 <anks> No, let me start from the beginning. I have implemented an Applicative for (MaybeT m) using only (Applicative m) restriction
08:17:48 <anks> but, on hackage it's implemented using (Monad m) restriction, and then bennofs told me my implementation is incorrect
08:18:37 <lmj> is there a consensus on whether base >= 4.7 && < 5 is better than base >= 4.7? It seems the majority of packages have "&& < 5"  but that doesn't imply that it's better.
08:19:23 <lmj> I suppose it depends upon what the plan for 5 is.
08:20:07 <hpc> it's always better to have an upper bound on compatibility
08:20:10 <dolio> anks: They do different things.
08:20:25 <hpc> the transition from 4 to 5 implies api changes
08:20:33 <anks> dolio: could you elaborate ?
08:20:44 <anks> further
08:20:51 <dolio> bennofs gave an example.
08:21:12 <dolio> return Nothing <*> lift (print 42)
08:21:29 <dolio> In the implementation using Monad, that doesn't print anything.
08:21:38 <dolio> In the one using Applicative, it does.
08:22:14 <anks> actually both does :|
08:22:42 <hpc> :t return Nothing <*> lift (print 42)
08:22:44 <lambdabot>     Couldn't match expected type ‘() -> b’ with actual type ‘Maybe a0’
08:22:44 <lambdabot>     In the first argument of ‘return’, namely ‘Nothing’
08:22:44 <lambdabot>     In the first argument of ‘(<*>)’, namely ‘return Nothing’
08:22:55 <rmrfroot> what's the opposite of "infix"? "outfix"? i'm naming a function that strips surrounding line breaks from a text :P
08:23:08 <anks> :t MaybeT $ return Nothing <*> lift (print 42)
08:23:09 <lambdabot>     Not in scope: data constructor ‘MaybeT’
08:23:09 <lambdabot>     Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
08:23:11 <hpc> circumfix
08:23:21 <rmrfroot> hpc: ah, thanks :)
08:24:14 <opqdonut> rmrfroot: functions like that are often called "strip" or "trim"
08:24:44 <dolio> anks: Maybe it's the opposite case, then. I'm not sure how MaybeT implements (<*>). But the Monad one can short circuit on one side when there's a nothing and not execute any part of the other side.
08:25:49 <rmrfroot> opqdonut: alright, maybe that's a better naming convention!
08:25:53 <dolio> To be correct it should be the left side short circuiting, I believe.
08:25:59 <dolio> Otherwise it won't match ap.
08:26:18 <dolio> And the version that doesn't short circuit can't be extended to a Monad, I think.
08:26:19 <anks> ok
08:26:33 <anks> i see it now ..
08:26:51 <anks> it indeed do not shortcircuit
08:28:49 <anks> damn haskell is hard  :]
08:29:55 <hpc> well, math is hard
08:30:19 <hpc> haskell's much easier when you avoid the mathy bits ;)
08:30:52 <greymalkin> I use emacs -- is there a simple command that lines up things like imports, etc? I see this columnar style used in a lot of production code, but my thumbs are starting to get tired of hitting the spacebar to line up, e.g. function calls within a list.
08:31:28 <cocreature> greymalkin: C-c C-.
08:31:41 <rmrfroot> anyone know if there is something like `Eq` that can show the difference between what you are comparing? say i have 2 large trees that i'm comparing and i want to see what in those trees are different.
08:32:11 <greymalkin> cocreature: What command do you have that bound to? (it does nothing for me)
08:32:23 <hpc> rmrfroot: what data structure would express the difference?
08:32:37 <geekosaur> greymalkin, there are multiple indentation modules in haskell-mode
08:32:56 <hpc> rmrfroot: (this probably doesn't exist, but maybe something similar enough exists)
08:33:01 <geekosaur> https://github.com/haskell/haskell-mode/wiki/Indentation
08:33:22 <cocreature> greymalkin: haskell-mode-format-imports
08:33:50 <harwiltz> Hello, does anyone have any experience with hscurses?
08:35:45 <rmrfroot> hpc: alright, well i'm looking at the types in orgmode-parse. i see they derive `Show` and `Eq`, so i thought maybe something exists that can print two document trees and show what makes them different. 
08:36:26 <hpc> rmrfroot: i mean like
08:36:33 <hpc> the difference between an Int and an Int is an Int
08:36:44 <hpc> but what's the difference between True and False?
08:37:00 <hpc> that kind of thing
08:37:05 <hpc> what's the difference between two trees?
08:37:20 <cocreature> there is specific stuff, like https://hackage.haskell.org/package/patches-vector but as hpc explained, you can’t really generalize that
08:39:28 <cocreature> searching for “diff” on hackage gives a long list of packages that might help
08:41:53 <harwiltz> Hello, does anyone here have any experience with hscurses?
08:45:26 <geekosaur> mrr, missed them
08:46:02 <geekosaur> @tell harwitz curses tends to be a bit of a disaster, and wrapping it in Haskell doesn't help. we tend to recommend vty-ui instead. that said, what is your issue?
08:46:02 <lambdabot> Consider it noted.
08:51:06 <rmrfroot> hpc, cocreature: i was thinking you traverse both trees at the same time, and then when you encounter a node that exists in tree A but not in tree B you print "node not found", or something similar. something like this: http://lpaste.net/145732
08:51:42 <rmrfroot> the output would be for debugging purposes only
08:53:32 <hpc> actually, i bet you could add that functionality generically in a way that transforms data types written in terms of Free
08:53:41 <hpc> (which is not very many types)
08:55:10 <rmrfroot> hpc: awesome! have not used or heard anything about Free monads, but i'll look into it. thanks for the advice
09:00:13 <hpc> rmrfroot: it won't be useful for you, but it could be an interesting library
09:00:33 <hpc> maybe for automatic revision control or something
09:00:42 <hpc> or an undo stack
09:01:38 <redxaxder> geekosaur: its harwilz, not harwitz
09:01:48 <geekosaur> bleh
09:01:49 <redxaxder> harwiltz
09:02:09 <geekosaur> @tell harwiltz curses tends to be a bit of a disaster, and wrapping it in Haskell doesn't help. we tend to recommend vty-ui instead. that said, what is your issue?
09:02:09 <lambdabot> Consider it noted.
09:02:52 <latk> I've not been following haskell news for a while; does anyone know what happened to overloadedrecordfields ?
09:03:45 <geekosaur> afaik still scheduled for ghc8
09:04:01 <redxaxder> https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1#LandedinHEAD
09:04:33 <latk> hmm, okay
09:05:02 <latk> thanks!
09:05:53 <redxaxder> looks like complete support for orf isn't done yet
09:05:59 <redxaxder> but might still get written in time?
09:06:36 <redxaxder> oh, it says the type class part probably wont make ghc 8
09:10:50 <Jayce> Hey, I've been trying to install the friday/friday-DevIL package via cabal on Windows and I'm running into a dependency issue.
09:11:05 <Jayce> It's probably something daft, but after some Googling, I still can't quite make the ends meet.
09:11:50 <dmj> Jayce: what's the error
09:12:26 <Jayce> At the end of running "cabal install friday-devil", I get a "Missing C Library: IL"
09:12:53 <Jayce> It looks similar to something others have encountered, I'm still stuck after trying some of the solutions.
09:13:14 <Jayce> I thought it might be something path related.
09:14:13 <monochrom> Friday was yesterday. perhaps today you should use saturday-evil instead :)
09:14:35 <geekosaur> you have http://openil.sourceforge.net/download.php installed?
09:15:23 <Jayce> Yes, as far as I can tell, the 32 bit version.
09:15:48 <Jayce> I also tried specifying that dir explicitly. Maybe.. I should grab the 64 bit version as well?
09:17:17 <jamesfordummies> :bn
09:18:25 <latk> Is it possible to somehow derive a generic instance for an imported datatype ?
09:19:03 <dmj> latk: deriving instance Generic MyType ... might work
09:19:14 <dmj> might cause an orphan
09:21:25 <dmj> Jayce: had a similiar issue with HsOpenSSL on windows, you might need to specify where certain libraries are located
09:21:25 <latk> dmj: Seems to work, though I do get orphan warnings. Not really anything I can do about that though, I assume?
09:21:33 <dmj> Jayce: like --extra-include-dirs="c:/OpenSSL-Win64/include" --extra-lib-dirs="c:/OpenSSL-Win64"
09:21:51 <dmj> latk: you can newtype the custom type you imported
09:22:12 <Jayce> Ah, I tried each of those, but not both at the same time.
09:23:45 <Jayce> Still getting the error, is it possible the "IL" library isn't anything included in the DeVIL download?
09:25:18 <Jayce> Nothing stands out in the cabal file oO
09:26:00 <arun-2556> hi
09:28:23 <Pamelloes> Using (,,) feels weird.
09:28:24 <Pamelloes> Kind of dirty..
09:32:39 <hpc> Pamelloes: as it should ;)
09:34:05 <Pamelloes> hpc: I looked at my code and realized it would be better to use (,) (a,b) instead and all is right with the world again :)
09:35:15 <Pamelloes> (well maybe not all... but my code is better!)
09:42:07 <ski> Pamelloes : why ?
09:42:46 <Pamelloes> ski: Because (,,) is gross. But also, in context, ((a,b),c) actually makes way more sense.
09:44:25 <ski> ok
09:44:59 <Pamelloes> Is there an infinity value?
09:47:09 <favetelinguis> are there any extensions like ProbLog2 in Haskell?
09:47:41 <kras> Hi, I am trying to use Alex with Parsec, 
09:48:02 <kras> How do I pass SourcePos from Alex to Parsec
09:48:16 <kras> is this AlexPosn?
09:49:52 <glguy_> You write a conversion function
09:50:10 <glguy_> The source position type from Alex can vary
09:51:50 <kras> glguy_: I have token_posn function defined for each data constructor of Token like token_posn (Rparen p) = p
09:52:18 <kras> how do I use this function?
09:54:34 <glguy_> You'll use it in concert with a function "AlexPosn -> SourcePos" that you'll write as the argument to token: http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Prim.html#v:token
09:55:44 <tosun> `→` looks too tiny when using `UnicodeSyntax`. Is there a font which enhances the typesetting for that?
09:55:57 <tosun> Same case with `⇒`
09:57:06 <hpc> use -> and =>?
09:57:30 <hpc> it's an inherent problem of monospace fonts
09:57:41 <hpc> (in that they are monospace and thus every character is the same width)
09:59:46 <zebr> except 漢字
10:00:39 <volothamp> Hey guys, I wrote simple program and I'd like to document it using markdown, so that it can be seen on github
10:00:52 <volothamp> I found this project which seems really interesting, but it also seems quite dead https://ghc.haskell.org/trac/ghc/wiki/LiterateMarkdown
10:01:00 <bollu> johnw: I understand how Cont works :) when you call the "k" of the callCC $ \k -> …, the k continues to the next statement in the *external* do block escaping the entire callCC block left, correct?
10:01:12 <volothamp> what do you think? Are there any alternatives?
10:02:01 <volothamp> The CS194 used the old literate Haskell style, but it's not as readable as Markdown
10:02:23 <monochrom> bollu: yes
10:02:30 <bollu> monochrom: awesome!
10:02:47 <bollu> monochrom: now I need to understand how the types of callCC line up to achieve this magic :P
10:03:09 <bollu> monochrom: it seems so weird, that the callCC block is somehow "propogating" forward through the external monad (>>=)
10:03:13 <monochrom> "callCC (\k -> ...)  >>=  yyy"  the k is a way you can proceed to yyy
10:03:14 <kras> glguy_: thanks for the hint, I will try again
10:03:33 <bollu> yeah, but I don't know how the (>>=) allows the k to proceed to the yyy
10:03:43 <bollu> I think it's a weird line-the-types-up-and-see-the-magic thing?
10:03:49 <hpc> specifically, k is the action "drop the current continuation and replace it with yyy"
10:03:52 <bollu> or is there an intuitive explanation?
10:03:56 <monochrom> >>= alone doesn't. but you are combining callCC with >>=
10:03:58 <bollu> hpc: yes, but how does that work out?
10:04:04 <bollu> yeah, but.. why?
10:04:05 <bollu> :t callCC
10:04:07 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
10:04:13 <bollu> :t (>>=)
10:04:15 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:04:29 <hpc> this is one of the rare times i would say look at the implementation first
10:04:38 <hpc> even though it's even messier than the type
10:04:45 <bollu> hpc: I *have* implemented callCC myself by type-filling
10:04:47 <mjrosenb> does anyone understand why in Reactive.Banana, the type of unions went from ([Event a] -> Event a) to [Event (a->a)] -> Event (a->a)
10:04:53 <bollu> but I sure as hell don't understand the implementation
10:04:58 <mjrosenb> and how I'm supposed to use this new method?
10:04:59 <hpc> bollu: take it apart
10:05:15 <hpc> find the part that is "replace the continuation" and name that replaceContinuation or whatever
10:05:26 <monochrom> you will have to analyze the code you wrote. think in terms of continuation-passing style.
10:05:28 <hpc> etc
10:05:39 <bollu> hpc: I'll try :) now that I understand how to use callCC, I think reading the implementation will make more sense
10:05:50 <bollu> i.e, compare what the implementation does to how it behaves
10:05:57 <monochrom> yeah
10:06:18 <hpc> honestly, just implementing callCC without inspecting it after is useless
10:06:35 <hpc> because it's one of those things that can be solved with just djinn
10:06:40 <bollu> thanks a lot guys! 
10:06:55 <bollu> hpc: djinn = the thing that you can give types to and it finds the impl?
10:06:55 <hpc> (which is neat in and of itself, but not for learning)
10:06:58 <bollu> how does that work anyway?
10:06:58 <hpc> yeah
10:07:04 <hpc> complicated ;)
10:07:07 <bollu> :)
10:07:11 <ljs> Since when compiling the Main module which does not export `main` results in compilation error?
10:07:22 <hpc> but suffice it to say callCC is the unique value of its type
10:07:32 <bollu> hm
10:07:35 <monochrom> it works by being limited in the diversity of the types it understands
10:07:36 <bollu> that is pretty cool
10:07:55 <ljs> say module X () where main = ...
10:07:56 <hpc> anyway welcome to the Cont club
10:08:04 <bollu> 	xD
10:08:17 <bollu> is understand how Cont works a rite of passage? :P
10:08:24 <hpc> it's one of them
10:08:32 <ski> bollu,johnw : iirc, you can't define `shift',`reset' with `callCC' (while not using `cont'/`ContT' nor `runCont',`runContT')
10:08:35 <bollu> ooh, what are the others?
10:08:40 <ski> (leftover comment from last time)
10:08:41 <hpc> Cont combines a few brutally hard things to get in your head all at once
10:08:56 <bollu> ski: interesting, that was for delimited continuations right?
10:09:00 <hpc> completing the Functor/Applicative/Monad hierarchy is another
10:09:08 <bollu> hpc: done with that :)
10:09:16 <bollu> what's my next target supposed to be?
10:09:22 <hpc> there's not an official list or anything ;)
10:09:30 <bollu> learn enough cat. theory to understand a ekemett post? ;)
10:09:36 <hpc> focus on Cont for now and then move to the next thing you don't understand
10:09:42 <monochrom> ski: I somewhat don't believe it. my recollection is you have to add a mutable cell.
10:09:51 <wyvern> newb q, just playing with list comprehensions vs map, filter, etc. Given the hokey task of squaring ints, I can do that with [x^2 | x <- [1..5]]. I can do it with map and a lambda, but to do it without a lambda, map (flip (^) 2) [1..3] is the best I've come up with. Can I do that more tidily?
10:10:01 <ski> bollu : `shift'&`reset' are for delimited/functional/composable/sub- continuations, yes
10:10:09 <bollu> hpc: hm, I think next would be probably… arrows? though I "understand" them, i don't appreciate them
10:10:25 <bollu> or, or, maybe Yoneda or Codensity or something like that
10:10:45 <monochrom> Codensity
10:10:56 <monochrom> definitely Codensity
10:10:57 <hpc> i'd skip arrows
10:11:01 <ski> monochrom : well, you certainly need a mutable cell in addition to the "no end result" continuations, a la Scheme and SML/NJ, to get delimited ones
10:11:07 <hpc> there's more interesting ways to enter the world of classes with multiple parameters
10:11:16 <bollu> monochrom: why Codensity over Yoneda?
10:11:25 <ski> monochrom : however, `Cont' tries to simulate such, by functions
10:11:47 <ski> (so the picture could a priori perhaps be different)
10:12:06 <monochrom> but if you avoid runCont and cont, you're back to "no end result"
10:12:17 <ski> (hence i added the restriction of not using .. exactly :)
10:12:24 <bollu> :info Codensity
10:13:00 <bollu> wyvern: try map (^2) [1..5]?
10:13:04 <ski>   newtype Codensity f a = MkCodensity (forall b. (a -> f b) -> f b)
10:13:15 <wyvern> bollu: wouldn't that be 2^1, 2^2, etc
10:13:22 <monochrom> Codensity is similar to Cont. this is why I suggest it.
10:13:50 <ski> @src ContT
10:13:50 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
10:13:50 <bollu> > map (^2) [1..3]
10:13:52 <lambdabot>  [1,4,9]
10:14:04 <wyvern> yeah I can see that it *isn't* the powers of two but I don't see why :)
10:14:10 <bollu> ooh, interesting, What's Codensity trying to abstract out?
10:14:19 <ski> bollu : btw, you understand CPS already, yes ?
10:14:26 <bollu> ski: I suppose so 
10:14:28 <ski> (otherwise, you could work on that)
10:14:29 <monochrom> map (2^) [1..3] is the powers of 2
10:14:43 <bollu> ski: I don't know how to do the goto-label thing using Cont
10:14:51 <wyvern> oh, (^2) with infix-style ^ means it expects the "first" param?
10:14:56 <bollu> ski: as in, I don't know how to simulate yield
10:14:57 <ski> bollu : you could try understanding how to implement backtracking, with two-level CPS, perhaps
10:15:00 <bollu> wyvern: yep
10:15:02 <monochrom> [2^1, 2^2, 2^3] = [(2^) 1, (2^) 2, (2^) 3] = map (2^) [1,2,3]
10:15:04 <wyvern> but ((^) 2) would be powers of 2?
10:15:09 <bollu> ski: yeah, tat I probably should
10:15:09 <monochrom> yes
10:15:12 <wyvern> aha!
10:15:14 <wyvern> thanks.
10:15:25 <bollu> wyvern: you can write ((^)2) as just (2^)
10:15:34 <ski> bollu : not sure what you mean by "simulate `yield'"
10:15:37 <bollu> > map (2^) [1..5]
10:15:39 <lambdabot>  [2,4,8,16,32]
10:15:41 <wyvern> Didn't realize that curried infix things worked that way.
10:15:55 <hpc> sections work both ways
10:15:59 <bollu> ski: like, the way "yield" works in say, python to create generators
10:16:19 <monochrom> another example: a:b = (a :) b = (: b) a
10:16:41 <wyvern> = ((:) a b) ?
10:16:45 <monochrom> yes
10:16:53 <ski> wyvern : `(/) x y' is `x / y'. the former is really `((/) x) y', so therefore plain `(/) x' is `(x /)', so that `(/) x y' is `(x /) y' is still `x / y'
10:16:53 <mauke> ((:) a) b
10:17:03 <mmaruseacph2> https://www.haskell.org/communities/11-2015/html/report.html <- HCAR 29 is up
10:17:17 <ski> wyvern : and `(/ y) x' is `x / y', of course
10:17:33 <wyvern> ok, got it. thanks
10:18:25 <ski> wyvern : iirc, `(x /)' will actually be `\y -> x / y', and not `(/) x' itself (may matter for sharing), for symmetry with `(/ y)' being `flip (/) y' being `\x -> x / y'
10:18:34 <ski> (perhaps someone can confirm)
10:18:43 <monochrom> yes
10:19:00 <monochrom> it doesn't matter for sharing. it matters for seq.
10:19:30 <hpc> > (`undefined` 5) `seq` 8
10:19:33 <lambdabot>  8
10:19:42 <monochrom> very old GHC did (/) x for a long time.
10:19:45 <bollu> :t seq
10:19:47 <lambdabot> a -> b -> b
10:19:56 <bollu> :t (>>)
10:19:57 <lambdabot> Monad m => m a -> m b -> m b
10:20:11 <bollu> :t const
10:20:11 <monochrom> then one day someone read the Haskell Report and noticed "wait a second, it says \y -> x/y here!"
10:20:12 <lambdabot> a -> b -> a
10:20:37 <monochrom> and the GHC devs went "oh shit, now we have to change our compiler"
10:20:42 <bollu> what's the difference between seq and (flip const) ?
10:20:52 <hpc> > undefined `seq` ()
10:20:54 <lambdabot>  *Exception: Prelude.undefined
10:21:00 <hpc> > (flip const) undefined ()
10:21:02 <ski> monochrom : hm, so `(... /)' will be `let x = ... in \y -> x / y' (`x' not free in `...') ? and similarly for `(/ ...)' ?
10:21:02 <lambdabot>  ()
10:21:27 <bollu> oh, so seq in some sense evaluates the lhs and then drops it?
10:21:32 <bollu> how does that get implemented?
10:21:38 <hpc> magic
10:21:45 <geekosaur> it's a compiler builtin
10:21:49 <bollu> intrinsic?
10:21:51 <bollu> hm
10:22:08 <bollu> I'll bet that seq breaks some nice math rules
10:22:13 <bollu> doesn't it?
10:22:19 <hpc> or it's written in terms of compiler internals in a way that's compiler specific
10:22:22 <hpc> or something
10:22:23 <ski> relying on `seq' for behaviour (rather than performance) is possibly a bad idea
10:22:25 <hpc> bollu: you have no idea
10:22:38 <bollu> hpc: do tell :P
10:22:56 <Taneb> bollu: GHC can reorder a `seq` b to b `seq` a `seq` b
10:23:05 <hpc> bollu: it'd take too long for me, i have to go soon
10:23:18 <ski> (Haskell itself only specifies the denotational semantics of `seq'. implementations are left to provide operational semantics)
10:23:22 <bollu> hpc: hm, alright
10:23:34 <bollu> Taneb: but.. why would GHC choose to do that?
10:23:42 <Taneb> It's sometimes more efficient
10:23:43 <monochrom> ski: no no. the seq issue is this. define "binop = \a -> undefined". seq (binop 3) () bottoms. seq (3 `binop`) () = seq (\y -> binop 3 y) () doesn't bottom.
10:23:56 <Taneb> And also not relevant here, I didn't read enough far back, sorry
10:23:59 <bollu> ski: I've never learnt this formally, but.. denotational = "what it should behave like" while operational = "how it works"?
10:24:24 <ski> denotational is roughly "answers / (observable) behaviour"
10:24:38 <monochrom> in fact, don't define binop. the same thing can be demo'ed by a pun on seq itself.
10:24:42 <bollu> I should learn semantics but I have no idea where to start :(
10:24:44 <hpc> a very rough understanding would be "denotational = behavior when used", "operational = definition"
10:24:57 <ski> (where time take, memory used, joules generated, are expressly not counted among the observable behaviour)
10:25:11 <monochrom> hmm no, the pun on seq fails. define binop.
10:25:27 <ski> monochrom : i know. my question was about sharing
10:25:38 <monochrom> I don't think the sharing is different
10:26:14 <ski> bollu : while operational is *how* we get to the answer (which include time and memory spent)
10:26:21 <ski> monochrom : different from what ?
10:26:45 <monochrom> I don't think (f x) vs (x `f`) differ in sharing
10:26:57 <bollu> ski: where should I learn semantics from?
10:27:32 <ski> monochrom : with a naive by-need evaluator, `2 * 2' in `(2 * 2 +)' would get reevaluated, in case it expands to `\y -> 2 * 2 + y', but not if it expands to `let x = 2 * 2 in \y -> x + y'
10:27:38 <monochrom> (f x) is exactly one pointer to f and one pointer to x.  (\y -> f x y) is exactly one pointer to f and one pointer to x
10:29:18 <ski> monochrom : `(2 * 2 +)' and `(+ 2 * 2)' could not differ in sharing in (at least) two ways : (a) expanding to `\y -> 2 * 2 + y' resp. `\x -> x + 2 * 2'; or (b) expanding to `let x = 2 * 2 in \y -> x + y' resp. `let y = 2 * 2 in \x -> x + y'
10:29:19 <monochrom> ((+) (2*2)) expands to let x = 2*2 in (+) x
10:30:08 <ski> iow, i'm not talking about the `(+) (...)' case, i'm talking about a comparision of the left and right section case
10:31:40 <ski> (probably i should have noticed earlier you seemed to be constrasting the left (or is it right) section with the application variant)
10:42:41 * hackagebot cayley-dickson 0.2.1.0 - Complex numbers, quaternions, octonions, sedenions, etc.  https://hackage.haskell.org/package/cayley-dickson-0.2.1.0 (lmj)
10:45:25 <tobiasBora> Hello !
10:45:30 <Bez_> > 3 / 0
10:45:33 <lambdabot>  Infinity
10:47:41 <tobiasBora> I have a little problem that I would like to solve as efficiency as possible : I have a list (l : ['a]), two functions (f{1,2} : 'a -> 'b), and an element (x : 'a). I would like that if x in in l, then I apply f2, else f1.
10:48:13 <tobiasBora> I could do something like (\x -> if x `elem` l then f2 x else f1 x)
10:48:33 <tobiasBora> However the list l will be the same for the whole program
10:49:17 <tobiasBora> so it's pretty long to always browse the whole list.
10:49:24 <tobiasBora> Do you have a better structure ?
10:49:39 <Bez_> ahm
10:49:49 <Bez_> I'm pretty sure there is
10:49:54 <tobiasBora> (note that 'a is an enumeration)
10:50:17 <tobiasBora> I though about Data.Map (equivalent of hash table in functionnal language right ?)
10:50:49 <ski> tobiasBora : maybe make a "serious curry" version of `elem' ?
10:51:04 <ski> (or for `Map', if you prefer)
10:51:14 <tobiasBora> ski: What is a serious curry ?
10:51:46 <ski> a curried function that actually does some serious/nontrivial work between getting its arguments (at least between two of them)
10:52:17 <ski> so that that work will be done once and shared, between a partial application that is further applied many times
10:52:31 <tobiasBora> ski: Oh yes, I think it's the thing I want. But the question is what is the nontrivial work I should do.
10:52:38 <ski> (one can think of this as "compiling" the input structure to a more suitable output)
10:53:28 <ski> tobiasBora : in your case, the nontrivial work would be traversing the list (or `Map') (so that it can possibly be GCed) .. and maybe some extra analysis on the elements/associations of the list/`Map'
10:53:58 <ski> given
10:54:11 <monochrom> f = \x -> if length (replicate 40 x) == 40 then \y -> x+y else \y -> x-y
10:54:14 <tobiasBora> GCed ?
10:54:17 <ski>   elem _  [    ] = False
10:54:32 <ski>   elem a0 (a:as) = a0 == a || elem a0 as
10:54:38 <ski> tobiasBora : Garbage-Collected
10:54:39 <bergmark> tobiasBora: Data.Map uses Ord for ordering, and Data.HashMap (from unordered-containers) uses hashing
10:54:42 <ski> you can make
10:54:55 <ski>   flipElem [    ] = \_ -> False
10:55:23 <ski>   flipElem (a:as) = \a0 -> a0 == a || flipElem_as a0
10:55:25 <ski>     where
10:55:26 <tobiasBora> bergmark: For a small structure (something like 7 elements) which one is the better one to use ? Is hash the value takes more than reading the whole list it's not interesting...
10:55:31 <ski>     flipElem_as = flipElem as
10:56:27 <kadoban> tobiasBora: When you have something that small, it generally doesn't matter at all what data structure you use.
10:56:34 <tobiasBora> ski: Here the lazy functionalities of haskell will perform the evaluation only one ???
10:57:05 <ski> (you can write this as using `foldr'. possibly you can also use a fold for the `Map' case)
10:57:10 <ski> @hoogle (k -> a -> r -> r) -> r -> Map k a -> r
10:57:11 <lambdabot> Data.Map.Lazy foldrWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b
10:57:11 <lambdabot> Data.Map.Strict foldrWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b
10:57:11 <lambdabot> Data.Map.Lazy foldrWithKey' :: (k -> a -> b -> b) -> b -> Map k a -> b
10:57:15 <tobiasBora> kadoban: Even when you do millions of reads on it ?
10:57:40 <ski> tobiasBora : yes, at least with a naive by-need evaluation (barring improvement/optimization)
10:57:42 * hackagebot path 0.5.3 - Path  https://hackage.haskell.org/package/path-0.5.3 (ChrisDone)
10:58:13 <kadoban> tobiasBora: millions? Yeah probably still doesn't matter.
10:59:01 <ski> (of course, the "compiled" version this gets will presumably still traverse closure structures at run-time .. unless there's something like a JIT or RTCG underneath)
10:59:58 <tobiasBora> kadoban: Ok. (well it's between 10^8 to 10^14 I think)
11:00:41 <tobiasBora> ski: Will it traverse once (at first run) or lot's of times ?
11:00:53 <ski> the former
11:01:38 <tobiasBora> ski: Well once isn't important. Thank you !
11:02:18 <tobiasBora> I should really try to understand the lazy part of haskell in deep...
11:03:36 <ski> tobiasBora : in the `Map' case, are you checking keys or value or both ?
11:03:46 <Bez_> yep it's absolutely worth it
11:04:47 <tobiasBora> Bez_: If you have some good and deep documentation, understandable by a new personn in lazy world, I would be happy to see it !
11:05:44 <tobiasBora> ski: Well I would simulate my ending function that gives to 'a a 'b value, and the map would be Map 'a 'b.
11:05:45 <Bez_> actually, I got to understand it through some nice discussions in our local functional community
11:06:21 <monochrom> try my www.vex.net/~trebla/haskell/lazy.xhtml and someone else's https://hackhands.com/guide-lazy-evaluation-haskell/
11:06:44 <tobiasBora> Bez_: Sadly in France Ocaml is more common than Haskell, and lazyness isn't famous in Ocaml.
11:06:50 <Bez_> So, well, I can try to explain, and I guess it would take some time, but I'm about to get home in a few minutes, so I can start at least
11:07:48 <Bez_> Oh there's people saying OCaml would be quite nice here actually, but haven't been able to get a deep look at it
11:08:02 <Bez_> yet
11:08:20 <Bez_> I plan to do so another time xD
11:08:21 <tobiasBora> monochrom: Great thank you !
11:08:58 <tobiasBora> Bez_: Ocaml is really nice also. But a bit simpler than Haskell in concept ;)
11:09:22 <tobiasBora> Bez_: Well actually I have to go right now, so it doesn't matter ;) Maybe next time !
11:09:48 <tobiasBora> Thank you all of you for your help, I think I love the Haskell community !
11:10:11 <Bez_> well then, have a nice day tobiasBora ^^
11:10:30 <Bez_> sure, you're welcome :)
11:11:22 <tekkkz> hello! I want to install "qt" , im on archlinux, and it says at cabal install qt that something, e.g. "qtc_core" and more, is missing ... how to get this?
11:11:23 <ski> tobiasBora : for `Map', i'd suggest trying `foldMap' or `foldMapWithKey' over the fold -right or -left versions. the former might be more efficient, depending on what you do exactly. your monoid will be `e -> Any', i think, where `e' is the element type you're looking for
11:12:05 <geekosaur> tekkkz, qt is a binding, you need the OS's devel libraries for qt
11:12:15 <geekosaur> using pacman or w/e
11:12:23 <tekkkz> yeah, apcman
11:12:25 <tekkkz> *pacman
11:12:31 <tobiasBora> ski: Ok thank you, I'll try it, thank you !
11:12:32 <tekkkz> but which packages do i have to install?
11:14:44 <geekosaur> https://wiki.archlinux.org/index.php/Qt
11:15:26 <ski> tobiasBora : fwiw, RTCG stands for Run-Time Code Generation (like in staged/meta- programming, partial evaluation), and JIT for Just-In-Time (compilation) (made more wellknown by JVM implementations)
11:15:39 * geekosaur is not an Arch user and can't help much, actuallt
11:16:32 <tekkkz> geekosaur, i dont get what i need ...
11:16:42 <wyvern> is GHC only ahead of time or does it have any runtime components other than GC?
11:17:16 <geekosaur> tekkkz, as I just said, I'm not an Arch user and can't actually help much
11:17:43 * hackagebot MemoTrie 0.6.4 - Trie-based memo functions  https://hackage.haskell.org/package/MemoTrie-0.6.4 (ConalElliott)
11:29:59 <indigo945_> does stack expect me to add every single dependency that lens has to my stack.yaml so that it can build my project?
11:32:20 <bitemyapp> indigo945: no
11:32:38 <bitemyapp> indigo945: that's a little strange though.
11:32:53 <bitemyapp> indigo945: if you post your project to github or bitbucket, I could pull it down and finish the stack.yaml for you in a jiffy.
11:33:09 <indigo945> I'd rather know the process of finishing it myself
11:33:27 <bitemyapp> that's good, but I can't do a lot without at least seeing it.
11:34:00 <indigo945> I'll construct a minimal example
11:34:11 <bitemyapp> indigo945: sounds like you already know what you're doing, but in case you need it, you could skim the Stack tutorial video my coauthor and I made: https://www.youtube.com/watch?v=sRonIB8ZStw
11:34:40 <indigo945> bitemyapp: actually I'm pretty sure I don't, so thanks, I'll give it a watch before continuing to pester you :)
11:35:06 <bitemyapp> indigo945: it's pretty long, but we go through a lot. There's bookmarks if you need to jump around the video.
11:37:32 <frite> is haskell available fo r the raspberry pi?
11:37:36 <hexagoxel> tekkkz: did you follow the INSTALL instructions?
11:42:44 <tekkkz> hexagoxel, yeah, i have installed "qt"
11:48:32 <hexagoxel> tekkkz: https://github.com/keera-studios/hsQt/blob/master/INSTALL.md contains more than that (?)
11:51:12 <tekkkz> hexagoxel, i need to install opengl via cabal first or what?
11:52:43 <hexagoxel> i don't know what exactly. but a good first step probably is trying to follow those instructions and see if they work at least. then you can see what needs to be adapted for your project / can be omitted.
11:53:54 <hexagoxel> hint: it seems not to work (directly) with ghc-7.10.2
12:07:45 * hackagebot tasty-fail-fast 0.0.1 - Adds the ability to fail a tasty test suite on first test failure  https://hackage.haskell.org/package/tasty-fail-fast-0.0.1 (MichaelXavier)
12:22:56 * hackagebot urlpath 5.0.0.1 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-5.0.0.1 (athanclark)
12:24:57 <tekkkz> hexagoxel, ghc-pkg: cannot find package haskell98 ... so waht now?
12:26:50 <hexagoxel> `cabal install haskell98`, try again? (i have no idea)
12:29:42 <tekkkz> nope, package not found
12:30:16 <hsk3> I abandoned Haskell a while back because I got frustrated when I couldn't create a data structure with components and refer to those components from within the structure's "namespace". For instance, in C I can have a Point struct and then do point.x and point.y to get the x and y coords. But in Haskell, I'd have x and y functions polluting the global namespace.
12:30:16 <hsk3> Was this a valid concern or was I missing something?
12:30:48 <mauke> s/global/local/
12:31:31 <tekkkz> how to exit cabal sandbox?
12:31:59 <jle`> hsk3: honestly to me it feels pretty superficial
12:32:31 <jle`> it's more of an aesthetic thing, and having it outweigh the entire body of benefits/good things about haskell?
12:32:51 <jle`> but how important that is to you is a personal opinion i guess
12:32:53 <hexagoxel> tekkkz: in what sense did you "enter" the sandbox?
12:33:21 <jle`> these days people get around it by calling it pointX, pointY, etc., which is admittedly a bit of a hack; there are proposals to ammend haskell to allow things like this to be nicer
12:33:23 <tekkkz> cabal sandbox init
12:33:33 <cdk> hsk3: if Point is defined in a module, then you can import the module qualified and have the namespacing you want
12:33:43 <jle`> it's not an ideal situation at the moment, but to me it again feels aesthetic and minor
12:33:48 <hexagoxel> tekkkz: 1) go to different directory 2) cabal sandbox delete
12:34:18 <hsk3> jle`: well, i ended up abandoning haskell for apple's new hyped language swift and was really excited about it, but now i've run into swift's generic ugliness (the same <T,U,V> ugliness we have in C++) and now I'm longing to move back to Haskell's beautiful type system!
12:34:25 <hsk3> So it's a trade-off I guess!!!!!!
12:34:42 <jle`> it feels weird to reject an entire language with great benefits just because of a small thing, and then going back to another language with everything *worse*, but without that small bad thing
12:35:09 <hsk3> lol yeah, i'm not sure what i was thinking... :S
12:35:10 <mauke> small/big is in the eye of the beer holder
12:35:15 <tekkkz> hexagoxel, seems to not work ... i cant install haskell98, dependency error ..
12:35:37 <jle`> like if a choice brings you improvements in 100 areas and a regression in 1, abandoning it for something with 100 regressions and 1 improvement seems a little silly to me
12:35:39 <hsk3> cdk: good point
12:35:42 <jle`> but yes, it's definitely in the eye of the beholder
12:35:44 <hsk3> :D
12:35:51 <hexagoxel> tekkkz: and you are using ghc-7.10, right? that's what i hinted above..
12:36:16 <hsk3> I have another question. Is Haskell slow in "debug" mode? (not optimized). Since Haskell relies a lot on optimizations to be fast.
12:36:23 <hsk3> I'd expect it to be dead slow in debug mode
12:36:32 <hsk3> (like Swift is)
12:36:41 <hexagoxel> but you still could try using ghc-7.8
12:36:51 <tekkkz> hexagoxel, so it is not working with current version?
12:36:58 <tekkkz> nah i dont want to downgrade
12:37:10 <tekkkz> i need to accept that qt is "outdated" right?
12:37:16 <mauke> hsk3: what's debug mode?
12:37:39 <hsk3> mauke: reducing optimizations to allow debugging
12:37:54 <mauke> what's debugging?
12:37:57 <hsk3> lol
12:37:59 <hsk3> wtf?
12:38:23 <jle`> what sort of debugging are you talking about?
12:38:33 <hexagoxel> tekkkz: yeah, it seems so to me. maybe file an issue or ask the maintainers somewhere; there maybe a quick solution. i did run into the exact same issue.
12:38:38 <jle`> a decent part of haskell debugging happens at compile-time, so optimizations/no optimizations doesn't really matter
12:38:54 <dmj> jle`:++
12:38:59 <koshmar> how to ask bot to convers something to pointfree style?
12:39:01 <hsk3> good point..
12:39:06 <mauke> koshmar: @pl
12:39:14 <koshmar> thx
12:39:22 <jle`> and at run-time, the story is a bit weird because haskell doesn't quite have a call stack, so i'm really sure how optimizations or lack of would help
12:39:42 <jle`> (that's an honest "i'm not sure", as in, i relaly don't know :O )
12:40:01 <hsk3> Okay, another point that's been on my mind. Is the lack of Haskell IDE a cause for concern? That's another reason why I abanonded Haskell. In Swift, I could use Apple Xcode to do coding, which is a nice IDE. Should the idea of using a plain text editor with Haskell bother me? Your thoughts?
12:40:20 <hsk3> you know, code completion, colors, etc.
12:40:23 <hsk3> across files
12:40:34 <jle`> hopefully you're not editing haskell with a plain text editor :p
12:40:55 <jle`> most people dev haskell in an environment with code completion and syntax highligting, yes
12:41:08 <jle`> and automatic indentation etc
12:41:38 <jle`> i use vim :D  but a lot of people use sublime, emacs, etc.
12:42:25 <hsk3> ok i see
12:46:52 <d-snp> wtf, this is seriously a line in some code I'm reading: return . return . return $ return ()
12:47:08 <meoblast001> is there a general haskell style guide?
12:47:08 <d-snp> worse.. that's the last line in a do block that starts: return $ do
12:48:06 <meoblast001> lol
12:48:55 <d-snp> meoblast001: I don't think so, but there's a couple of haskell programmers you could code like
12:49:05 <meoblast001> hmm
12:49:17 <meoblast001> i'm trying to figure out where my "where" should go
12:49:21 <meoblast001> indented once forward, or not
12:49:34 <kadoban> meoblast001: What 'hlint' says is probably a decent start, though I don't think it has an opinion on that.
12:49:56 <d-snp> well don't ask me, people basically think I'm the devil, because I use tab indentation, but I indent where once
12:50:04 <d-snp> so the where block is indented twice
12:50:23 <d-snp> but afaik the general haskell style is to indent where *half*
12:50:33 <d-snp> which if you ask me is crazy talk, but yeah :P
13:28:01 <hexagoxel> d-snp: what are the involved monads?
13:32:08 <koshmar> how come?
13:32:15 <koshmar> @pl f x = (x,x)
13:32:15 <lambdabot> f = join (,)
13:33:42 <Ferdirand> koshmar: reader monad
13:34:41 <Iceland_jack> 'join' in the reader monad acts as if it were
13:34:42 <Iceland_jack>     join :: (r -> r -> a) -> (r -> a)
13:34:42 <Iceland_jack>     join f x = f x x
13:35:02 <hexagoxel> koshmar: `instance Monad ((->) r)` http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#line-614
13:35:19 <koshmar> thx) 
13:35:48 <koshmar> neat
13:39:12 <osa1> does anyone know a tool/library for downloading the whole hackage documentation? I don't want a local hackage mirror or anything like that, I just need all the docs offline.
13:45:26 <keiopa> good night, anyone could help with a func? learning haskell here =)
13:45:39 <newsham> good evening.  sure
13:45:57 <newsham> ("good night" usually means going to sleep)
13:46:45 <hsk5> Conceptually, how does Haskell GUI programming work? I have a hard time imagining such a thing because there are no such things as "objects" in haskell. There are no "things". There cannot be such a thing as a window object for us to act on (even if there is one visible right there on the screen).
13:46:48 <hsk5> So how would it work?
13:47:39 <jle`> you describe your gui
13:47:46 <jle`> in denotative terms
13:47:49 <jle`> and then it exists
13:47:58 <keiopa> don't hit me just yet xD , so, i'm on a stdin/stdout "protocol" that has been take care... now i need to take a [string] and run the index looking for "#" and deleting "#" that are redundant
13:48:00 * hackagebot tasty-tap 0.0.3 - TAP (Test Anything Protocol) Version 13 formatter for tasty  https://hackage.haskell.org/package/tasty-tap-0.0.3 (MichaelXavier)
13:48:07 <jle`> (a library takes your denotation and renders it)
13:48:21 <jle`> and there are definitely "things" in haskell..
13:48:38 <jle`> what do you think 1, True, [2,3,4], "hello", and (* 3) are?
13:48:43 <hsk5> jle`: but they are not things that stick around in memory. they're more like things you pass into funcs to get other things
13:48:52 <newsham> keiopa: do you need to write the functiont o find the character yourself
13:48:53 <hsk5> even though a window sticks around on screen
13:48:56 <hsk5> see what i mean?
13:48:57 <newsham> or can you use standard libraries?
13:49:21 <jle`> you can definitely construct a value that *represents* something that sticks around on a screen
13:49:26 <newsham> i guess you'd prob be best off just writing it all in this case
13:49:47 <newsham> keiopa: are you familiar with how to recurse on lists?
13:49:48 <jle`> and then have a library turn that representation into reality
13:50:11 <jle`> haskell is good at representing interactions, representing changes in state
13:50:19 <jle`> representing denotative ideas and concepts
13:51:42 <hsk5> ah, interesting
13:51:44 <hsk5> thanks
13:51:47 <hsk5> nice cognition
13:51:48 <jle`> when you describe your GUI in english
13:51:54 <keiopa> <newsham> i need to write the func it should be something like func :: [String] -> [String]; func [] = []; func (x:xs) =  then i should test the "x" for the head of the "xs" but i'm hitting my head in here xD 
13:52:12 <jle`> hsk5: when you describe your GUI and design it, you don't actually work with a magical floating GUI in front of you
13:52:29 <jle`> hsk5: you work with trying to describe what goes where, the nature of itneraction between certain elements, etc.
13:52:46 <newsham> keiopa: you're going to have to consider two different cases for non-empty lists.  one where the first character happens to be '#' and one where the first character is not
13:52:52 <hsk5> yeah
13:53:02 <newsham> and for the case when the first char is '#' you'll have to handle two cases.
13:53:15 <newsham> does that make sense?
13:53:26 <keiopa> ...processing....
13:53:28 <keiopa> xD
13:53:48 <jle`> hsk5: when you're envisioning your GUI/describing it to someone, you don't say, "okay, and this one flips this pointer on this architecture, which triggers this process on this OS, which..."
13:53:53 <keiopa> yea
13:54:18 <newsham> what do you do if you have (x:xs) and the first character isn't '#' ?
13:54:30 <keiopa> but i can isolate the case in guards inside the func (x:xs)
13:55:02 <keiopa> i error the line of the sdtin
13:55:09 <keiopa> stdin*
13:55:29 <newsham> you have a function String -> String,   so writing to stdout is not an option
13:55:55 <keiopa> hmmmm?
13:55:57 <newsham> your problem statement was "remove redundant '#' characters in the string"
13:56:23 <newsham> so if you have a character that is not '#' in the input string, you probably want that to be part of your output string, right?
13:56:56 <keiopa> no, in that case i error the line of the input and end the execution
13:57:46 <newsham> that sounds different than what you described earlier:
13:57:47 <newsham> [11:47] < keiopa> don't hit me just yet xD , so, i'm on a stdin/stdout "protocol" that has been take care... now i need  to take a [string] and run the index looking for "#" and deleting "#" that are redundant
13:57:49 <keiopa> http://i.imgur.com/mBDWict.png something like that
13:58:14 <keiopa> yes i know what i wrote :)
13:58:31 <keiopa> i may not have been as explicit as i wanted to :s
13:59:03 <newsham> if you have the possibility to error, then "String -> String" doesnt sound like the right type.
13:59:16 <newsham> now you might need something like "String -> Maybe String"    or some other type that encodes an error condition
14:01:38 <newsham> maybe a good way to start would be to write out a few examples of how you expect your function to behave.
14:01:41 <keiopa> i get the input from a file, then i read lines and eliminate the redundant "#" ( I'm sorry but now i remmeber that in this phase in wont have anything else but valid char's so the error i spoke earlier is not a case)
14:02:13 <newsham> like:  f "foo ## bar" == "foo # bar"
14:02:33 <keiopa> yes
14:02:37 <newsham> then you can try to make your function that will do that
14:03:03 <keiopa> i am :S
14:03:22 <newsham> if that example is correct, then what would    f ('f':"oo ## bar") do ?
14:04:05 <newsham> and what would   f ('o':"o ## bar") and   ('o':" ## bar") and ('#':"# bar") etc..
14:12:28 <Lokathor> with hsc files, i have "#{enum CChar, CChar, ..." and later "#{enum CShort, , ..."
14:12:44 <Lokathor> did i just totally mess up the second entry and it compiles anyway?
14:12:51 <Lokathor> or is there a differnence i forgot about?
14:13:03 <Lokathor> (Haven't touched this codebase in about 6 months)
14:24:27 <ackthet> slightly off topic maybe but how many people here use haskell in their jobs?
14:26:23 <keiopa> university teachers?
14:26:24 <keiopa> xD
14:26:41 <bergmark> i do! 1-0 :)~
14:27:03 <keiopa> and there you have...an university teacher...
14:27:04 <ackthet> bergmark: can you say where you work and how much of what you do is haskell?
14:29:33 <bergmark> ackthet: www.silk.co , the majority of our backend is haskell (incl a graph database), haskell perhaps 40% of our code (guessing)
14:29:44 <ackthet> awesome!
14:30:12 <ackthet> i now a number of big names use haskell despite keiopa's joking
14:31:37 <keiopa> hey...just a joke...
14:38:06 * hackagebot ghc-exactprint 0.5.0.0 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.5.0.0 (mpickering)
14:38:29 <Lokathor> FB uses haskell
14:39:10 <Lokathor> alright but now my FFI question: How does one declare that a haskell module will use a public variable from a C .h file?
14:39:50 <Lokathor> eg, curses.h declares "stdscr" of type "WINDOW *", and I have a type for Window
14:41:14 <geekosaur> capi? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi.html#ffi-capi
14:41:58 <geekosaur> otherwise you need to write shims, since ghc doesn't generally go through C any more
14:42:20 <Lokathor> hmm
14:43:41 <Lokathor> looks like I want foreign import capi "curses.h value COLOR_PAIRS" color_pairs :: CInt
14:43:43 <Lokathor> and similar
14:44:07 <kaol> I can tell haskell is a great language when I patch others' code and it isn't even painful.
14:45:17 <keiopa> anyone avaiable to teamspeak? about haskell ofc
14:45:50 <Lokathor> hmm, wait, geekosaur it looks like this sort of thing is for constants
14:46:57 <conal> Is QuickCheck broken for Double & Float? The following hangs for me in GHC 7.8.2 and QuickCheck-2.8.1: quickCheck (== 0.0)
14:47:20 <reuben364> keiopa: what for, just discussion?
14:48:05 <geekosaur> conal, I'm not aware of any breakage aside from the usual Double/Float breakage
14:48:21 <conal> Seems to be a problem with shrinking:  *** Failed!   C-c C-cException while printing status message: 'user interrupt' (after 2 tests and 126 shrinks)
14:48:23 <keiopa> <reuben364> it's about a task i need to do
14:48:35 <conal> I get the "Failed!" immediately, and then nothing.
14:48:39 <conal> geekosaur: thx
14:56:53 <conal> oh, wow. this quickcheck test hangs when in a shell in emacs but works fine in a terminal window.
14:58:07 * hackagebot refact 0.3.0.2 - Specify refactorings to perform with apply-refact  https://hackage.haskell.org/package/refact-0.3.0.2 (mpickering)
15:03:07 * hackagebot apply-refact 0.1.0.0 - Perform refactorings specified by the refact library.  https://hackage.haskell.org/package/apply-refact-0.1.0.0 (mpickering)
15:06:21 <mpickering> how long does it take for the hackage index to update?
15:08:55 <bergmark> mpickering: i think the cdn cache is invalidated every 5 min
15:10:15 <athan> Hay guys, my web server's codebase is only 1179 lines, and it's a RESTful address book - persistent-backed, and allows for JSON/CSV/Url-Encoded formatting, and has really nice error handling
15:10:17 <athan> it's super duper
15:13:34 <jc1> Hey, is anyone available to help?
15:13:41 <dmj> jc1: yea
15:13:53 <cite-reader> I can email you a rate card. </joke>
15:14:18 <jc1> So I'm going to type out a question then, it's quite long :/
15:14:37 <dmj> jc1: if it's really long lpaste.net might be better
15:14:55 <geekosaur> might be a good idea. irc has a relatively short message length limit
15:15:23 <dmj> @where paste
15:15:23 <lambdabot> Haskell pastebin: http://lpaste.net/
15:15:32 <jc1> Okay, but it's not code, so that'll be fine, right?
15:15:53 <geekosaur> sure
15:16:20 * geekosaur uses lpaste for a lot of stuff including random program output unrelated to haskell
15:16:39 <jc1> http://lpaste.net/1000527466420240384
15:16:48 <jc1> This is the question :)
15:18:22 <dmj> jc1: what is a foundation
15:19:15 <jc1> It's a list of 4 empty lists which will fill up with the items/cards starting at 'Ace' and going up to 'King'.
15:19:58 <jc1> Thing is, I can't iterate through the guards, so it just goes over the first item again and again. 
15:21:26 <dmj> jc1: if you know you're only going to have 4 empty lists maybe a tuple might be a better representation
15:23:12 <jc1> Well it sort of have to be done this way, because if that list is inputted, it should return as: [[(Ace,Hearts)],[(Ace,Spades),(Two,Spades),[],[]]
15:26:06 <dmj> jc1: can you paste your code
15:26:22 <jc1> Any way to pm you it?
15:27:11 <dmj> jc1: I'd just paste on lpaste.net, this way others could help
15:28:54 <jc1> Thing is, if someone posts it online, and I submit it, then it could be seen as copied code :/
15:31:43 <dmj> jc1: is this homework?
15:34:38 <jc1> Yeah
15:36:19 <Lokathor> #define KEY_MAX		0777		/* Maximum key value is 0633 */
15:36:25 <Lokathor> *sigh*
15:36:44 <dmj> jc1: Ok, when you say 'iterate over the tail' of the list, how do you mean. Can you paste an example of the input / output of that scenario
15:40:32 <geekosaur> curses, foiled again?
15:44:53 <jc1> Sorry, give me 2 minutes to type it out :)
15:45:44 <Iceland_jack> "typing it out", aka how Haskellers fight
15:46:22 <pavonia> Are there any guidelines when to re-export whole modules? I'm writing a package that enhances the functionality of another package. Would it be better to export the original modules here with the new ones?
15:46:41 <jc1> http://lpaste.net/1000527466420240384
15:49:49 <emerald123> Guys I type [1, [2]] in ghci , i am curious why I get error.
15:49:59 <dmj> jc1: you want to go from [(a,b)] -> [[(a,b)]] ?
15:50:06 <emerald123> <interactive>:6:1:     No instance for (Num [t0]) arising from a use of ‘it’     In a stmt of an interactive GHCi command: print it
15:50:12 <Iceland_jack> emerald123: all elements of the list must have the same type
15:50:16 <emerald123> No just typed it 
15:50:19 <dmj> jc1: It's unclear what constitutes 'valid' in this scenario
15:50:32 <Iceland_jack> You can write [1, 2] or [[1], [2,3]] or [[1], [2]] 
15:50:38 <Iceland_jack> but not [1, [2]]
15:51:05 <emerald123> What makes it unclear in case of [1, [2]] ? 
15:51:29 <emerald123> I read somewhere about variables being polymorphic in haskell
15:51:47 <pavonia> emerald123: What would be the type of that expression?
15:51:59 <Iceland_jack> emerald123: Do you understand
15:51:59 <Iceland_jack> > 1 :: Int
15:52:01 <lambdabot>  1
15:52:09 <emerald123> Prelude> :type [1,[2]] [1,[2]] :: (Num [t], Num t) => [[t]]
15:52:18 <emerald123> Just typed into compiler
15:52:25 <Iceland_jack> emerald123: Yes, assuming that lists are numbers
15:52:25 <Iceland_jack>  
15:52:28 <Iceland_jack> but lists aren't numbers
15:52:45 <emerald123> So is error because of 1 or because of [2] ?
15:52:57 <emerald123> SInce 1 is an integer might belong to Num class
15:53:02 <Iceland_jack> Either one :-)
15:53:02 <tekkkz> Hello! How can I get , with a function, he letters/numbers between "[&" ... and ... "]" out of such string: [&AgGqtgAA] ?
15:53:05 <cite-reader> Because of trying to use both of them at once.
15:53:15 <pavonia> emerald123: What type *do you expect* this expression to have?
15:53:26 <emerald123> How does compiler decide which one is the error at like 1 or [2] ?
15:53:39 <emerald123> I just want to test lists to enhance my understanding 
15:54:02 <emerald123> I am reading learn you a good haskell and currently am on lists chapter 
15:54:05 <dmj> > reverse . drop 1 . reverse . drop 2 $ "[&AgGqtgAA]"
15:54:07 <lambdabot>  "AgGqtgAA"
15:54:15 <Iceland_jack> > drop 2 (init "[&AgGqtgAA]")
15:54:17 <lambdabot>  "AgGqtgAA"
15:54:25 <emerald123> But sort of hard to find out this error root cause
15:54:36 <emerald123> Like I am unable to debug the error too
15:55:07 <Iceland_jack> emerald123: This error has to do with several things, explore lists with characters before you explore them with numbers is my advice.
15:55:10 <Iceland_jack> > ['a', 'b']
15:55:12 <lambdabot>  "ab"
15:55:18 <dmj> > let ('[':'&':xs) = "[&AgGqtgAA]" in init xs
15:55:20 <lambdabot>  "AgGqtgAA"
15:55:25 <Iceland_jack> While ['a', ['b']] will fail
15:55:33 <Iceland_jack> [True, [False]] will also fail
15:55:36 <emerald123> What you mean is compiler sees 1 , thinks it is a list of integers (assume int belong to num class) , then expects next element to be of same type ?
15:55:51 <Iceland_jack> emerald123: Not in that order, but basically
15:56:00 <emerald123> But finds it to be a list of integers and lists do not match with integers , so type error ?
15:56:05 <Iceland_jack> the compiler sees "[2]" and knows that the elements of the list must be a list of numbers
15:56:39 <emerald123> yeah so it is right ?
15:56:53 <Iceland_jack> it knows that '1' and '[2]' must have the same type, because numbers are overloaded GHC assumes you know better and that '1' must be a list of numbers just like '[2]'
15:56:55 <emerald123> Only that the next element is not a list of numbers but just a number
15:57:34 <emerald123> okay , so it sees [2] first , then infers 1 shouldn't belong to list but [1] could belong right ?
15:58:00 <emerald123> so it evaluates lists from right to left ?
15:58:05 <Iceland_jack> It doesn't see [2] first, not that it matters here
15:58:25 <emerald123> so what should I understand from this compiler error ?
15:58:34 <emerald123> that can help me understand lists too
15:58:48 <emerald123> and reason out as to why the error happens if at all
15:58:56 <Iceland_jack> I suggest to focus on lists of Char ['a', 'b'] and Bool [True, True, False]
15:59:25 <Iceland_jack> hopefully someone else can provide you with a more satisfying answer
15:59:44 <emerald123> I hope too
15:59:59 <emerald123> I am so curious and interested in finding an answer to this error :)
16:00:04 <pavonia> The fact that number literals in Haskell are overloaded just adds extra confusion here
16:00:13 <emerald123> yeah ...
16:00:23 <Iceland_jack> There is strictly speaking no error
16:00:25 <emerald123> I cannot think how compiler thinks basically
16:00:32 <pavonia> > [1 :: Int, [2 :: Int]]
16:00:34 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘[Int]’
16:00:34 <lambdabot>      In the expression: [2 :: Int]
16:00:34 <lambdabot>      In the expression: [1 :: Int, [2 :: Int]]
16:02:07 <Iceland_jack> Getting into the actual issue requires explaining type classes, I'm not sure it will help
16:02:07 <pavonia> emerald123: ^ Does that error make more sense?
16:02:12 <jc1> Dont worry about it, I'm havin trouble explaining it, and need sleep xD Thanks for putting up with me though :P
16:02:38 <emerald123> yeah it does 
16:02:55 <emerald123> like it explains what I thought was maybe right ?
16:03:10 <emerald123> like integer and [integer] are not the same type :)
16:03:21 <emerald123> so unification error can I say ?
16:03:23 <Iceland_jack> Yes
16:03:35 <Iceland_jack> Yes, you get the same complaint by using Char and Bool without needing the type annotations
16:03:35 <emerald123> I borrowed unify from prolog lol
16:03:39 <Iceland_jack> > ['a', ['b']]
16:03:40 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
16:03:40 <lambdabot>      In the expression: ['b']
16:03:40 <lambdabot>      In the expression: ['a', ['b']]
16:03:50 <Iceland_jack> > [True, [False, True, True]]
16:03:52 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘[Bool]’
16:03:52 <lambdabot>      In the expression: [False, True, True]
16:03:52 <lambdabot>      In the expression: [True, [False, True, True]]
16:04:20 <emerald123> so I can safely say , lists expect elements to be of same type 
16:04:23 <Iceland_jack> yes.
16:04:25 <emerald123> hence the error 
16:04:32 <emerald123> since rules aren't followed
16:04:37 <Iceland_jack> Since a String is just a list of Char's, you can write "abc" as ['a', 'b', 'c']
16:04:45 <Iceland_jack> so this will also fail:
16:04:46 <Iceland_jack> > ['a', "abc"]
16:04:47 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
16:04:47 <lambdabot>      In the expression: "abc"
16:04:47 <lambdabot>      In the expression: ['a', "abc"]
16:04:53 <emerald123> I liked this chat group a lottt !!! 
16:04:58 <emerald123> thanks friends :)
16:04:59 <tekkkz> why at http://ix.io/mpb error: http://ix.io/mpc ?
16:05:45 <emerald123> Can anybody suggest me if there are any similar groups for prolog , scheme , erlang ? (At the moment , I am focused on haskell though )
16:05:59 <crtstuff> emerald123: #scheme exists
16:06:24 <crtstuff> emerald123: rule of thumb; if the language has more than 1 user, try #<language> as a channel name
16:06:25 <emerald123> Can I be added to that permanently without having to login all the time ? Even this one ?
16:06:28 <geekosaur> there are channels for most programming languages. I will note that #haskell is rather famous for its hospitality though
16:06:58 <emerald123> yeah I liked the hospitality and I meant by similar groups with similar hospitality 
16:07:01 <Iceland_jack> > [1,2,3] :: [Int]
16:07:03 <lambdabot>  [1,2,3]
16:07:07 <Iceland_jack> > [[1,2], [3]] :: [[Int]]
16:07:09 <lambdabot>  [[1,2],[3]]
16:07:30 <Iceland_jack> > [[[1],[2]], [[3], [], [4,5,6]]] :: [[[Int]]]
16:07:32 <lambdabot>  [[[1],[2]],[[3],[],[4,5,6]]]
16:10:19 <emerald123> now I am thinking if its possible to have a binary tree where node is a tuple (string , float) key -> string float -> leaf like say (name,grade) is a node in a tree ... 
16:10:29 <emerald123> or how to make one in haskell ?
16:10:38 <emerald123> a tuple based binary tree 
16:10:49 <emerald123> with leaf giving me grades i.e. float
16:10:59 <emerald123> and ordered on names i.e. string
16:11:07 <emerald123> seems complicated to me as a beginner
16:16:28 <t7>  @hoogle (a -> Maybe a) -> a -> a
16:16:34 <t7> @hoogle (a -> Maybe a) -> a -> a
16:16:36 <lambdabot> Data.IntMap.Strict updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
16:16:36 <lambdabot> Data.IntMap.Lazy updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
16:16:36 <lambdabot> Data.IntMap.Strict updateMin :: (a -> Maybe a) -> IntMap a -> IntMap a
16:17:12 <Iceland_jack> @djinn (a -> Maybe a) -> a -> a
16:17:13 <lambdabot> f a b =
16:17:13 <lambdabot>     case a b of
16:17:13 <lambdabot>     Nothing -> b
16:17:13 <lambdabot>     Just c -> c
16:18:17 <t7> :t \a b -> b :: (a -> Maybe a) -> a -> a
16:18:18 <lambdabot>     Couldn't match expected type ‘(a1 -> Maybe a1) -> a1 -> a1’
16:18:18 <lambdabot>                 with actual type ‘r1’
16:18:18 <lambdabot>       because type variable ‘a1’ would escape its scope
16:18:32 <t7> :t (\a b -> b) :: (a -> Maybe a) -> a -> a
16:18:34 <lambdabot> (a -> Maybe a) -> a -> a
16:18:44 <shachaf> Better to use /msg for this.
16:19:08 <Cale> emerald123: I can't parse your question very well, but you can define all different kinds of binary trees in Haskell using data declarations.
16:19:14 <t7> i thought you /ignore'd me ?
16:19:33 <emerald123> dattype Name = String          type Grade = Float          type NameGrade = (Name, Grade)          data Tree a b            = Empty              | Leaf a b              | Node (Tree a b) a (Tree a b)
16:19:42 <emerald123> I define types
16:19:48 <emerald123> name grade being a tuple
16:20:14 <emerald123> I want to make a function that get grade from node matching name 
16:20:27 <emerald123> leafleaf contain grades
16:21:03 <emerald123> want to use add function to add node (name,grade) to tree at correct position as per ordering based on name
16:21:20 <emerald123> ddoes that help ? :)
16:21:49 <emerald123> sorry m on way to home ..
16:21:59 <emerald123> so can reply after an hour
16:22:05 <icen> Well, consider that a binary tree can be defined as: data Tree a = Leaf a | Branch (Tree a) a (Tree a), and then you can build your tree over (String, Float) pairs, ordering (during construction) on the strings
16:22:05 <emerald123> samrocks39@gmail.com 
16:22:29 <emerald123> I don't know how to thats the issue
16:22:41 <emerald123> searched online but that didn't help me
16:22:54 <icen> Well, what have you tried?
16:23:05 <emerald123> no good resources if I want to make a tree based on tuples
16:23:25 <emerald123> most online resources talk on a node being an int or a single element
16:23:37 <icen> There's no issue of replacing the 'a' in my Tree datatype with (String, Float) - a tuple is a single type
16:24:02 <emerald123> I could talk with you further after an hour or so ... driving on way to home... feel free to email me any doubts ... love this chat forum ... bye
16:24:06 <icen> If you wanted even more, larger tuples, or lists, or any other datatype can be put as the value at each node of the tree.
16:27:36 <rribeiro> Hello all. I'm developing a EDSL and I would like to overload character literals, like numeric literals and string literals can be overloaded. Is there a way to do this?
16:28:24 <aweinstock> rribeiro: if you implement Num, you get overloaded numeric literals for free (via fromInteger)
16:29:03 <aweinstock> rribeiro: and the OverloadedStrings language extension lets you use string literals for your type if you instance FromString
16:29:41 <rribeiro> aweinstock: Yes, I know it. But I'd like to overload character literals... like this: I'll write 'c' and ghc will understand it as CExp 'c'
16:30:51 <rribeiro> aweinstock: Is there a way to do overloading of character literals?
16:35:48 <geekosaur> not currently
16:35:56 <geekosaur> (none planned that I am aware of)
16:54:00 <mpickering> Are there any big haskell events in europe before zurihack? 
16:55:52 <solrize> @hoogle parMap
16:55:53 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
17:04:06 <Nikhil_learn_has> hi are you guys also trying to learn haskell ?
17:05:44 <solrize> hi Nikhil_learn_has lots of haskell users here.  if you have a question go ahead and ask
17:06:04 <shachaf> If only I could learn Haskell.
17:06:52 <dmj> shachaf: :)
17:10:04 <geekosaur> shachaf, first you must unlearn it
17:11:18 <dmj> shachaf: eating burritos accelerates the learning process 
17:11:28 <mniip> shachaf, the fool thinks himself to be wise
17:11:34 <mniip> :)
17:11:50 <shachaf> I'm not sure what that means.
17:11:59 <mniip> well it's a saying
17:13:20 <homovitruvius> emacs is emacs and ghc is ghc, but why my haskell input mode convert many things (. to ∘ for instance) that UnicodeSyntax doesn't understand? any easy fix on either side (emacs or ghc)?
17:13:33 <mniip> it's pretty naive to think that you've learned everything
17:16:02 <pavonia> homovitruvius: You could import a module that defines functions to work with this syntax
17:16:14 <shachaf> I don't think I've learned everything.
17:17:35 <pavonia> homovitruvius: Also, I think UnicodeSyntax only defines Unicode symbols for special tokens, not for all functions
17:17:54 <homovitruvius> pavonia: for some things yes (and I think there're modules on hackage), but some are syntax that can be redefined. I think is the case for ∘ which has a char class that cannot be an identifier
17:17:56 <geekosaur> only for the things that can't be done with normal binds
17:18:15 * hackagebot network-msg 0.7 - Recvmsg and sendmsg bindings.  https://hackage.haskell.org/package/network-msg-0.7 (sickmind)
17:18:40 <pavonia> > let (∘) = (.) in (*2) ∘ succ $ 10
17:18:42 <lambdabot>  22
17:18:54 <pavonia> homovitruvius: ^ Seems to work fine
17:19:57 <pavonia> And that's also in the base-unicode-symbols package
17:20:56 <homovitruvius> pavonia: thanks, I'll check again. Do you know if ghci would have problems with those? 
17:21:16 <pavonia> No, I don't
17:25:20 <jle`> fumieval: any reason why Chipped doesn't have a Monad instance? I can't see why it'd be useful over MaybeT, but... the monad exists
17:41:58 <FlyingChicken> /join #emacs
17:41:58 <FlyingChicken>  
17:46:52 <Lokathor> so curses uses a lot of void* values in some of the calls
17:47:06 <Lokathor> but it also specifically doesn't use them, they're just for future compatibility possibilities
17:47:25 <Lokathor> so in haskell when i'm setting up the FFI, can I just pass in a Ptr CInt instead and have it work out?
17:47:50 <Lokathor> a stack exchange i saw said to use Ptr (), but that's not "Storable" I guess, so you can't use alloca with it
17:56:00 <hackrilege> How  can i insert opperations between those of a recursion relation?
17:58:19 * hackagebot prefix-units 0.2.0 - A basic library for SI/binary prefix units  https://hackage.haskell.org/package/prefix-units-0.2.0 (IustinPop)
17:59:23 <hackrilege> > let f x = x:(f x) in f 0
17:59:24 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
18:01:07 <hackrilege> I can opperate on this after defining in to alter elements, but how could i change what it would see as x at some point?
18:01:48 <hackrilege> Assuming i cant change f
18:03:32 <arkeet> what do you mean.
18:04:01 <arkeet> what result do you wnat
18:04:10 <hackrilege> So it would say [0,0,0,0,0,0,0,1,1,1,1....
18:04:32 <arkeet> given what input?
18:04:39 <hackrilege> Maybe i specify the index of the alteration
18:04:39 <Cale> > replicate 7 0 ++ repeat 1
18:04:41 <lambdabot>  [0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:05:12 <hackrilege> So actually i want to interact with repeat
18:05:44 <arkeet> > let f g i x = x : f g (i+1) (g i x) in f (\i x -> if i == 7 then 1 else x) 0 0
18:05:46 <lambdabot>  [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:05:55 <arkeet> close enough
18:05:56 <Cale> > map (\k -> if k > 7 then 1 else 0) [0..]
18:05:58 <lambdabot>  [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:06:16 <arkeet> probably should make that strict in i
18:06:25 <hackrilege> (interfere repeat (7,1)) 0
18:06:34 <Cale> interfere?
18:07:05 <hackrilege> Thats the function im defining
18:07:48 <hackrilege> Maybe not quite like that but certainly not map
18:08:01 <Cale> interfere f (0,x) y = f x; interfere f (n,x) y = y : interfere f (n-1,x) y  ?
18:08:19 <Cale> I don't know
18:08:28 <Cale> It's not clear to me what you're really after
18:08:40 <Cale> I mean, you know how to construct the list that you want :P
18:10:03 <Cale> Generally if you want to do things based on the index of elements in a list
18:10:14 <Cale> the correct idiom to use is to first zip [0..] the list
18:10:25 <Cale> > zip [0..] (repeat 'a')
18:10:28 <lambdabot>  [(0,'a'),(1,'a'),(2,'a'),(3,'a'),(4,'a'),(5,'a'),(6,'a'),(7,'a'),(8,'a'),(9,...
18:10:40 <hackrilege> Not to  alter created elements. To create a different ellement to be used inside the recursion
18:10:40 <Cale> > zip [0..] "hello, world!"
18:10:42 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,','),(6,' '),(7,'w'),(8,'o'),(9,...
18:10:46 <hackrilege> No
18:10:52 <Cale> Then you can do things which depend on the index
18:10:53 <hackrilege> No indexing
18:11:36 <Cale> Then what was the 7?
18:12:22 <hackrilege> Some way of saying when to alter the  function. But it could be clock time
18:12:31 <Cale> no it couldn't
18:12:44 <Cale> Expression evaluation can't depend on clock time
18:12:55 <athan> Hey guys, I ran into my first parsing woe, with aeson - why does `many (one <|> or <|> another)` cause an infinite loop?
18:13:23 <athan> or really, an infinite loop if there can be one or more of those things parsed in the text?
18:13:24 <Cale> athan: is one of your branches recursive?
18:13:33 <hackrilege> Monads are fine
18:13:37 <athan> Cale: No, it shouldn't be
18:13:46 <Cale> Then I dunno
18:13:54 <athan> Cale: Here one second, sorry :\
18:14:24 <hackrilege> I can use monads
18:14:46 <Cale> hackrilege: I still don't know what you want
18:14:57 <dmj> athan: many is recursive
18:14:58 <Cale> hackrilege: What are you trying to compute?
18:14:59 <athan> http://lpaste.net/145752#line17
18:15:24 <athan> dmj: But... :(
18:15:32 <athan> if it fails on the first attempt, then the parser is fine
18:15:57 <hackrilege> A list of 0 or 1 changing once per second
18:16:08 <athan> hmm, maybe it's because I'm manipulating the parsable object
18:16:18 <Cale> hackrilege: I don't understand what that means
18:16:40 <Cale> hackrilege: You want the elements of the list to be functions of the current time?
18:17:08 <hackrilege> Repeat 0 for 1 seccond append repeat 1 for one seccond.
18:17:25 <Lokathor> alright
18:17:26 <Cale> The elements of the list don't occur at a particular time
18:17:27 <Cale> It's a list
18:17:33 <Cale> It exists independently of time
18:17:37 <Lokathor> my curses FFI module supports input, output, and colored output
18:17:40 <Lokathor> seems pretty good
18:18:20 <Cale> If you want something which represents things occurring at particular times, then you want some other data structure which is not a list or anything like it
18:18:50 <hackrilege> I could run a function which tells me if there are an even or odd number of seconds in ghe current time
18:19:09 <Cale> Perhaps if you were using an FRP system, you might have an Event t Integer, which fired once per second, with alternately the values 0 and 1
18:19:43 <Cale> (or something like that)
18:19:47 <Cale> But that's not a list :P
18:20:00 <hackrilege> I want to alter the recursivly defined function  repeat to generate altetnate elements
18:20:14 <Cale> okay
18:20:23 <Cale> > cycle [0,1]
18:20:26 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
18:20:42 <hackrilege> You used a different function
18:20:51 <arkeet> > let f g x = x : f g (g x) in f (1 -) 0
18:20:52 <Cale> Yeah, you can look up how cycle is defined
18:20:53 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
18:21:01 <hackrilege> You should have used repeat
18:21:04 <Cale> Or maybe iterate
18:21:10 <arkeet> also see earlier for a similar thing to get access to the index
18:21:15 <Cale> repeat does nothing more than repeat a single element
18:21:20 <arkeet> also the thing I wrote is just iterate
18:21:28 <Cale> You're not going to get a list which has different elements in it by using repeat
18:21:52 <hackrilege> Repeat is recursivly defined. I wish to access that chain
18:21:59 <Cale> What's a chain?
18:22:13 <arkeet> repeat is repeat. if you want to change what it does, write your own.
18:22:13 <hackrilege> Recursive calls
18:22:20 <Cale> "calls" aren't even a thing
18:22:31 <hackrilege> Ok guys
18:22:41 <Cale> Functions don't get called in Haskell, they're applied.
18:22:52 <hackrilege> Pardon me
18:23:06 <Cale> and function application isn't something you can interfere with -- the compiler removes many function applications through optimisation and inlining
18:23:21 <hackrilege> You dont understsnd what im saying?
18:23:39 <Cale> I mean, maybe I kind of do, but it seems really confused.
18:23:49 <hackrilege> It seems you do but you want to tell me the problem i face
18:23:55 <dmj> hackrilege: what would accessing a recursive chain look like
18:24:00 <Cale> I don't 100% understand what you want
18:24:05 <Cale> Maybe we should back off
18:24:12 <Cale> and you should tell us which program you're trying to write
18:24:16 <hackrilege> No its cool
18:24:19 <Cale> and then we can suggest a design that would work
18:24:38 <hackrilege> We just did that
18:24:43 <Cale> because it seems like you're asking for things that are based on a mistaken idea about what would be the solution to a problem
18:24:51 <hackrilege> No
18:24:55 <Cale> What do you want your program to do when it is run?
18:24:58 <hackrilege> I understand fine
18:25:01 <Cale> (that is, from the terminal)
18:25:24 <Cale> http://xyproblem.info/
18:25:49 <hackrilege> Its a function which takes a non terminating recursion and interfetes with the arguments its encounteting
18:26:00 <Cale> This is impossible
18:26:03 <hackrilege> Interferes
18:26:10 <Cale> Don't even try to do that
18:26:14 <Cale> it isn't possible
18:26:25 <hackrilege> Nothings imposible
18:26:47 <hackrilege> How do i do it?
18:26:52 --- mode: ChanServ set +o Cale
18:27:13 <dmj> hackrilege: you mean like filter an infinite list?
18:27:23 <dmj> > take 5 $ filter even [0..]
18:27:25 <lambdabot>  [0,2,4,6,8]
18:27:41 <hackrilege> No that opperates on the ellements after the are generated
18:27:53 <Cale> hackrilege: what do you mean "after"?
18:27:58 <Cale> > filter even [0..]
18:28:00 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
18:28:01 <athan> How should I use the "rest" of the object data available in a parser's result? (in Aeson, in my case)
18:28:14 <Cale> ^^ does that generate infinitely many elements in memory and then start to filter them?
18:28:16 <Cale> No.
18:28:32 <athan> I'm currently trying to mapM a simple `return` statement, across all the key/value pairs right now, after deleting the ones I don't want :\
18:28:37 <hackrilege> It asks if 1 is even
18:28:50 <hackrilege> It shouldnt
18:28:51 <athan> and I think this borks aeson's Data.ByteString.Lazy foundation for decoding :\
18:28:57 <Cale> > [0,2..]
18:28:58 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
18:29:05 <Cale> ^^ perhaps you'd prefer this?
18:29:17 <Cale> > iterate (+2) 0
18:29:18 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
18:29:38 <hackrilege> No here 2 is suppled initially
18:30:02 <Cale> Well, the function to obtain the subsequent element from the previous is supplied
18:30:07 <Cale> and an initial element
18:30:25 <Cale> and the list consists of the values [x, f x, f (f x), ...]
18:30:33 <hackrilege> I might not know that 2 until later, and id like list to be genrrating with some other number until then
18:30:44 <Cale> Can't.
18:30:56 <Cale> A list has a definite value.
18:31:00 <hackrilege> No more surgestions that are not io!
18:31:18 <momma> what does "later" mean here, hackrilege ? later compared to what?
18:31:41 <hackrilege> Unix time
18:32:00 <hackrilege> Oh no sorry
18:33:38 <hackrilege> I mean the recursion relation is defined in terms of passing arguments to itself. I want to access these arguments and change them. So after interaction the recursion will return differently
18:35:31 <geekosaur> sounds like you deliberately want to introduce impurity into a pure expression. you are working in the wrong language
18:35:34 <geekosaur> for that
18:35:35 <Cale> hackrilege: Well, you could define instead of a list, an IO action which gets a value
18:36:01 <Cale> hackrilege: and base that value both on the current time and, e.g. the previous value
18:36:13 <hackrilege> Its an artifact. Im not chosing to have to do this
18:36:15 <Cale> hackrilege: But that would have type IO Integer rather than [Integer]
18:36:17 <Cale> of course
18:36:18 <shachaf> This seems like a good time to move to #haskell-overflow, if the conversation is to continue.
18:37:07 <hackrilege> Its not something i can answer
18:37:40 <Cale> hackrilege: I'll write you one if you like
18:39:00 <pavonia> Are there any guidelines when to re-export whole modules? I'm writing a package that enhances the functionality of another package. Would it be better to export the original modules here with the new ones?
18:39:12 <hackrilege> Can you msg me that @ breaks my client
18:41:30 <lpaste_> Cale pasted “how to make something which changes” at http://lpaste.net/145753
18:41:34 <Cale> hackrilege: ^^
18:41:43 --- mode: Cale set -o Cale
18:42:11 <Cale> hackrilege: to try it, open it in ghci and type   t <- mkTimer 5
18:42:27 <hackrilege> Nvm
18:42:29 <Cale> and then enter  t  repeatedly in order to check on it
18:42:42 <Cale> after 5 seconds, it will change from False to True
18:43:26 <Cale> heh, the 'if' there is indeed very redundant
18:43:31 <Cale> I was originally going to use 0 and 1
18:43:45 <athan> I figured it out, you can't mess with the representation of the parsed data while parsing, because the structure being built may not be strictly allocated
18:43:45 <athan> wewe
18:43:55 <hackrilege> Ok nvm im sorry
18:43:57 <lpaste_> Cale revised “how to make something which changes”: “No title” at http://lpaste.net/145753
18:44:14 <Cale> hackrilege: Does that example make sense?
18:44:54 <hackrilege> Its completely an asside and the convo has already been kicked
18:45:06 <Cale> hackrilege: I disagree that it's an aside
18:45:14 <hackrilege> Nvm
18:45:42 <Cale> This seems to be the kind of thing that you're after -- you can obtain a sequence of values from the resulting IO action
18:45:53 <Cale> which switches from 0 to 1 at a particular clock time
18:46:15 <Cale> (in this case, whichever clock time is dt seconds after the time at which mkTimer is executed)
18:47:35 <Cale> You can execute the resulting action repeatedly, and collect the results into a list even
18:48:02 <hackrilege> Cale im sorry
18:48:04 <Cale> like  do t <- mkTimer 1; xs <- replicateM 1000000 t; print xs
18:48:30 <Cale> It's okay
18:48:48 <Cale> I'm just trying to understand what you're trying to accomplish
18:49:05 <Cale> If it's highly dependent on the clock time, I think this is likely the correct approach.
18:49:12 <hackrilege> No we got kicked i cant reply and its really far from what im after
18:49:14 <Cale> Or at least, something similar to this
18:49:25 <Cale> Hm? You're not kicked.
18:49:30 <Cale> I'm certainly not kicked :P
18:49:59 <geekosaur> I feel like what they want to do is tweak internal parameters of something from outside
18:50:10 <hackrilege> Yes
18:50:15 <geekosaur> without knowing what that something is, much less whether it provides access
18:50:16 <geekosaur> and, no
18:50:22 <Cale> If that's the case, then perhaps creating an IORef is appropriate
18:50:37 <Cale> Here, I'll extend the example
18:50:59 <geekosaur> those insides might not even exist, depending on how the compiler optimized it
18:51:06 <hackrilege> Its instentanious the recursive genetation of an infinite set. I want to change it as it grows
18:51:33 <hackrilege> I guess you have to unroll thunks or something
18:51:46 <Cale> You won't want to use a list
18:51:51 <Cale> use IO actions instead
18:52:01 <hackrilege> Any monadic beast
18:52:02 <Cale> to represent your sequences of values
18:53:09 <hackrilege> Its like a monadic sequence i wish to alter. But its a recursion
18:53:31 <hackrilege> If it was in a list i could intersperse
18:54:16 <hackrilege> But a list of constructing opperations not the fully evaluated list
18:54:48 <hackrilege> The opperators could depend on the altered values
18:55:31 <hackrilege> Does that make sense?
18:55:47 <lpaste_> Cale pasted “updateable counter” at http://lpaste.net/145755
18:55:53 <Cale> ^^ have a look at this
18:55:59 <osa1> does anyone know how async's mapConcurrently works? if I map a list of 10k elements does it spawn 10k threads at once or does it use a thread pool or something like that ?
18:56:06 <Cale> So if you run   c <- mkCounter
18:56:12 <Cale> and then you run  c  repeatedly
18:56:20 <Cale> you should see that it gives you successive integers
18:56:25 <Cale> yeah?
18:57:04 <Cale> mkDeltaCounter  is similar, but instead of just giving you a way to step the counter, you can also tweak the current value by any amount, using the function that it gives
18:57:09 <Cale> So e.g.
18:57:17 <Cale> (step,tweak) <- mkDeltaCounter
18:57:19 <Cale> step
18:57:19 <Cale> step
18:57:20 <Cale> step
18:57:25 <Cale> tweak (-2)
18:57:33 <Cale> You can try something like that in ghci
18:58:14 <Cale> osa1: I believe it just starts threads for all of them
18:58:35 <Cale> osa1: Those threads are scheduled by the N:M thread scheduler as usual
18:58:48 <hackrilege> > fix (:0) 0
18:58:49 <lambdabot>      Couldn't match type ‘[a0 -> t]’ with ‘a0 -> t’
18:58:50 <lambdabot>      Expected type: (a0 -> t) -> a0 -> t
18:58:50 <lambdabot>        Actual type: (a0 -> t) -> [a0 -> t]
18:58:50 <Cale> They don't correspond to OS threads
18:58:54 <hackrilege> Oops
18:59:34 <hackrilege> You have a constructor and a tweaker
18:59:38 <hackrilege> Nice
18:59:45 <athan> Hey guys I have a prollem: http://stackoverflow.com/questions/33851142/parsing-the-rest-of-an-aeson-object :(
19:00:37 <osa1> Cale: do you know a similar library that does it using a pool? my map function will send a HTTP request and I don't want to send 10k requests at once, I should be able to set a limit.
19:01:56 <Cale> osa1: I'm not sure, but you might find this usefulhttp://hackage.haskell.org/package/SafeSemaphore-0.10.1/docs/Control-Concurrent-MSem.html
19:01:58 <Cale> oops
19:02:02 <Cale> http://hackage.haskell.org/package/SafeSemaphore-0.10.1/docs/Control-Concurrent-MSem.html
19:02:56 <hackrilege> Say i was growing hair, i am recursivly defined about my end point and am rapidly approaching infinite length, but the speed of propegation of information of force are faster than the growth so it blows about in the wind
19:03:14 <momma> o ... k
19:03:37 <Cale> ^^ what momma said
19:04:27 <hackrilege> You need to access the growing end of a recursive growth
19:04:50 <Cale> hackrilege: Note that you can write recursive IO actions which use the things that I defined for you
19:05:08 <hackrilege> Your example is good
19:05:15 <Cale> hackrilege: e.g. make a counter, and then repeatedly step it
19:05:16 <hackrilege> But without recursion
19:05:27 <Cale> yeah, I didn't do the recursive part, just the effectful part
19:05:49 <hackrilege> Exactly not lots of applications of a function
19:05:55 <Cale> the recursive part isn't so bad though, try it
19:06:19 <osa1> oh there's a very simple solution I think. mapM (async f) (partition n lst) or something like that
19:06:22 <hackrilege> Its the only bit i had a problem with
19:06:46 <cdk> sounds like hackrilege wants something like `data Auto a b = Auto (a -> IO (b, Auto a b))` that uses user input to alter the behaviour of the Auto
19:06:56 <cdk> or I could be way off, it's pretty unclear
19:07:03 <Cale> Maybe, but that's way fancier than I think he even wants
19:07:09 <cdk> yes probably
19:07:13 <Cale> I was just thinking he wants to write:
19:07:58 <Cale> foo = do c <- mkCounter; let { loop = do n <- c; print n; loop }; loop
19:08:05 <Cale> something like that
19:08:27 * geekosaur thinking it's like an Icon generator, and introspection could change the internal variables of the generator.
19:08:32 <geekosaur> except I don't think Icon has introspection
19:08:40 <geekosaur> (didn't last time I checked, at least)
19:09:17 <geekosaur> ...and if I needed to do that I'd make it a coroutine instead and use @'s ability to pass values to the current state of the coroutine to activate it
19:10:44 <hackrilege> So i fork io i repeat the ioref and alter it in another thread?
19:11:09 <hackrilege> It is work?
19:12:43 <hackrilege> That should work right?
19:14:49 <hackrilege> Is repeatedly stepping a counter. Collecting those step opperations into a list before applying them seqentially. Is this different from doing it recursivly?
19:17:17 <hackrilege> f (0 : (1 : (2 : ..... =
19:19:15 <hackrilege> See?
19:19:42 <hackrilege> Thanks though ok
19:28:32 <stevejb> Hello, I have some data of type [Value] where Value is from Data.Aeson.Types. An example would be [Number 1.447540916765e12,String "binary_a1",String "str1"]
19:28:54 <stevejb> In particular, I have an array of these, so type is [[Value]]
19:29:11 <stevejb> how do I extract the first number from all of these?
19:29:51 <momma> pattern match?
19:30:21 <stevejb> In theory, I should be able to convert this into [(Int, Text, Text)]. I think I should be able to do it with lenses somehow, but I am not exactly sure.
19:30:39 <pavonia> You could use a list comprehension
19:34:35 <stevejb> yeah I suppose I could pattern match. I have been looking at the lens / aeson tutorial and it seems like there is a way to do it with that. But, I am not sure.
19:35:11 <h_noob> do you want to do it with lens, or do you just want to do it?
20:00:51 <athan> Guys I really need help with this if you can spare the time: http://stackoverflow.com/questions/33851142/parsing-the-rest-of-an-aeson-object
20:01:01 <athan> I have no idea why it's breaking so badly
20:01:31 <athan> It won't perform `many` lookups on known keys, nor will it correctly retrieve "the rest" of the object, minus a few keys
20:01:39 <athan> and I've tried a handful of implementations
20:02:03 <athan> by "won't perform `many`", I mean to say that the whole parser borks and space leaks
20:03:40 <athan> I'm guessing I actually need to fold both stages into one stage, using Either, then use `many` as an outer-most thing? :s
20:05:07 <athan> I might as well just deconstruct the hashmap manually, actually
20:05:19 <athan> because failure is impossible
20:05:22 <athan> B|
20:12:47 <osa1> does anyone know if there's a way to get downloaded source in hxt's readDocument?
20:22:18 <VeryVegas> Hi all ! Anyone specializing in premium themes ( WP ) ? 
20:23:13 <dmj> VeryVegas: this is a channel about programming in Haskell (http://haskell.org)
20:25:13 <VeryVegas> okay thanks
20:26:06 <h_noob> you are probably looking for #wordpress , VeryVegas 
20:26:33 <VeryVegas> k sounds perfect
20:28:32 * hackagebot linode 0.1.0.2 - Bindings to the Linode API  https://hackage.haskell.org/package/linode-0.1.0.2 (Helkafen)
20:33:04 <Chobbes> Does anything explain the reasoning behind calling them "type families?"
20:33:45 <h_noob> what is an example of a type family, Chobbes ?
20:34:18 <cdk> is there a wiki page for the "completely new core language" mentioned in the GHC section here: https://www.haskell.org/communities/11-2015/html/report.html
20:36:35 <cdk> found it: https://phabricator.haskell.org/D808 , https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell/Phase1
20:36:43 <Chobbes> h_noob: it's an extension which lets you define functions at the type level.
20:37:09 <h_noob> functions at the type level?
20:37:17 <justin_smith> https://wiki.haskell.org/GHC/Type_families
20:37:20 <Chobbes> h_noob: https://wiki.haskell.org/GHC/Type_families#What_are_type_families.3F I guess the term comes from type theory.
20:37:31 <h_noob> ah ok. thank you, justin_smith and Chobbes 
20:38:49 <justin_smith> Chobbes: that same link says the reasoning comes from math / type theory. I assume if you find some info on type theory you might find out how indexed type families got their name?
20:39:32 <Chobbes> h_noob: yeah, it's probably not something you should "depth-first-search" your way into learning if you're very new to Haskell. You will likely encounter a problem where they will help, though, and then they'll make a lot more sense.
20:39:50 <h_noob> thanks, Chobbes 
20:41:56 <justin_smith> Chobbes: this might help? http://math.stackexchange.com/questions/35462/what-is-the-difference-between-family-and-set interesting question
20:42:19 <Chobbes> h_noob: no problem! It's something that makes most sense when you hit something that you need it for. Otherwise it falls into "why would you want to do that?" territory.
20:43:21 <h_noob> ok
20:43:31 <Chobbes> justin_smith: checking it out, thanks. I figured it was a math term, but I was having difficulty searching for "family".
21:09:51 <sportanova> has anyone had any luck getting stack to work with haskell-mode / ghc-mod?
21:09:59 <sportanova> i keep getting: cl-ecase failed: stack-ghci, (ghci quote cabal-repl quote cabal-ghci quote)
21:12:07 <bitemyapp> sportanova: some have, but I haven't done it myself.
21:12:22 <athan> woo hoo! I fixed the parser!
21:12:24 <bitemyapp> I use flycheck mode with Stack instead of ghc-mod.
21:12:30 <athan> Turns out you have to rtfm before you can use it :\
21:13:35 <sportanova> bitemyapp: i'll have to look into that. suddenly my ghc-mod doesn't do error highlighting or type info anymore - driving me insane
21:15:20 <Aearnus> Hey, I'm having a little problem with running commands with haskell 
21:15:29 <sportanova> @bitemyapp does it show type info?
21:15:29 <lambdabot> Unknown command, try @list
21:15:41 <sportanova> bitemyapp: does it show type info?
21:16:05 <Aearnus> I need to run a command and get the output of it, but it seems that using `readProcess` always gives back an empty string
21:16:50 <Aearnus> Whereas using `spawnCommand` can run the command (but I can't get the output of it) 
21:16:57 <bitemyapp> sportanova: not really
21:20:08 <sportanova> oh dear
21:20:28 <pyon> How should I go about implementing this abstract data type? It's like a priority queue, where the keys are tagged with monoidal values. If two keys collide, they are merged by `mappend`ing the tags. If the tag becomes `mempty`, the key is removed from the heap. Of course, this means that it must be decidable whether a tag is `mempty`.
21:23:26 <Cale> pyon: Perhaps use PSQueue
21:23:47 <pyon> Oh, this already exists? Great!
21:23:55 <Cale> Not exactly
21:24:04 <Cale> PSQueue is a priority search queue
21:24:16 <pyon> Ah.
21:24:40 <Cale> It might require an Ord instance you don't have though, I dunno
21:25:25 <Cale> insertWith :: (Ord k, Ord p) => (p -> p -> p) -> k -> p -> PSQ k p -> PSQ k p
21:25:29 <Cale> So,
21:25:38 <pyon> Mmm.
21:25:47 <Cale> insertWith mappend :: (Ord k, Ord p, Monoid p) => k -> p -> PSQ k p -> PSQ k p
21:25:54 <pyon> I'm not really requiring the monoidal tags to provide an Ord instance.
21:26:15 <pyon> Although, for now, this will do, because right now I need integer tags.
21:26:17 <pyon> :-)
21:27:07 <pyon> Cale: So... thanks!
21:27:13 <Cale> no problem
21:27:27 <Cale> actually, wait, maybe you wanted to mappend the k's?
21:27:45 <pyon> If keys collide, I want to mappend the tags.
21:28:10 <Cale> ah, yeah, so the priorities get mappended, basically
21:28:48 <pyon> Wait, wait. I'm calling the priorities “keys”.
21:29:06 <pyon> Okay, I'll use different words: priorities and tags.
21:29:30 <pyon> The priority type is Ord, the tag type is a Monoid.
21:30:19 <Cale> Oh, what if you just used a Map?
21:30:27 <Cale> Map Priority Tag
21:30:45 <Cale> and then insertWith mappend
21:30:52 <Cale> Map has minView and stuff
21:30:53 <pyon> I was hoping for O(1) findMin.
21:30:57 <pyon> Oh.
21:31:29 <pyon> Oh, right, minView does the trick! :-)
21:31:41 <pyon> I had no idea Map had this. Normally, map implementations don't provide this.
21:32:00 <Cale> Well, it's log time, but whatever, log time is constant time :P
21:32:05 <pyon> Heh. :-)
21:33:24 <Cale> IntMap will get you constant time ;)
21:33:50 <pyon> Only works if the keys are ints, which in my case they aren't, sadly.
21:35:53 <pyon> Cale: Thanks. :-)
22:03:41 * hackagebot wai-middleware-content-type 0.0.3.2 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.0.3.2 (athanclark)
22:18:45 * hackagebot wai-middleware-verbs 0.0.5 - Route different middleware responses based on the incoming HTTP verb.  https://hackage.haskell.org/package/wai-middleware-verbs-0.0.5 (athanclark)
22:18:47 * hackagebot postgresql-error-codes 1 - PostgreSQL error codes  https://hackage.haskell.org/package/postgresql-error-codes-1 (NikitaVolkov)
22:39:01 <vektorweg1> any idea which lib to use for typesafe relational data? i looked at ixset, but it didn't convince me. i don't care about performance, it should be easy to use and pure.
22:41:06 <Hijiri> ixset-typed?
22:41:51 <vektorweg1> Hijiri: uh. good point. i'll check that.
22:42:09 <Hijiri> I haven't looked at it much, so I can't really vouch for it, but it exists
22:45:02 <vektorweg1> maybe someone can recommend me a good formal logic lib. it should be close enough to relational data.
22:52:48 <Mojonandha> hi
22:53:44 <Digit> hi. wild question/suggestion:  anyone considered making a functional package manager (like guix) in haskell?  :)
23:00:13 <wally1337> Does anyone here have much experience with running  an sql query against say an ms sql db with haskell and loading the columns in to say a vector- is this even possible with Haskell and its functional paradigm?
23:03:12 <oscar> hey can someone help me out real quick? im new to haskell
23:03:32 <oscar> anyone here?
23:03:59 <shachaf> Only about a thousand people.
23:04:12 <shachaf> But no one will help you if you don't ask your question.
23:05:19 <oscar> Okay, let me type it up concisely
23:05:26 <oscar> Thank shachaf! 
23:06:06 <oscar> so delta = st -> Char -> (st,Char) and I'm defining a new delta2 = st -> Char -> (st, Maybe Char)
23:06:06 <thimoteus> don't ask to ask, just ask!
23:06:43 <oscar> delta2 = (st, out) -> Char -> (st, Maybe Char)
23:06:59 <oscar> how do I define delta2 (st, out) = delta st
23:09:03 <oscar> So basically trying to convert the second part Char into a Maybe Char
23:09:53 <oscar> I tried doing something like: "delta2 (state, Just output) = (state2, Just output2) where (state2, output2) = delta state" but that didn't work
23:18:25 <solrize> i can't make any sense of that question.  can you put more of the code on lpaste.net ?
23:19:30 <solrize> oscar
23:19:54 <solrize> wally1337, there are lots of haskell sql interfaces, look on hackage.org/packages iirc
23:19:55 <bartavelle> oscar, if you use '=' as '::', it wouldn't work because delta2 doesn't take a single argument taht is a tuple, but two arguments. Also the second argument isn't a "Maybe a"
23:19:58 <solrize> hackage.haskell.org
23:22:53 <oscar> solrize bartavelle: http://lpaste.net/6584517033243705344
23:26:18 <bartavelle> oscar, oh this is dense :/
23:26:29 <solrize> oscar, looking but that code is incredibly ugly and confusing.  what are you trying to do?
23:27:19 <bartavelle> what solrize said, also both functions won't type check
23:27:25 <oscar> solrize, bartavelle: thimoteus just helped me fix it! Thanks guys!!!!!!
23:27:33 <solrize> hm ok
23:27:37 <oscar> You guys are all awesome!
23:27:44 <solrize> glad it's taken care of :)
23:37:17 <wally1337> I'd uhh just like to share this wonderful resource: http://book.realworldhaskell.org/ 
23:41:26 <jgcoded> ^ I just finished the parsec chapter of that book, it was excellent
23:46:38 <h_noob> is Haskell a good choice to deal with Big Data? In particular, I would like to test some (simple) algorithms on large graphs, where said algorithms (in the imperative model) involve modifying the graph a lot. Is Haskell a good choice of language for this?
23:58:39 <bartavelle> you probably should not write the same algorithm, but if you need in-place modification you can have it through the ST monad (or other IO stuff)
23:59:21 <h_noob> thanks, bartavelle . do you know if there are graph libraries in Haskell which do in-place modification behind the scenes?
