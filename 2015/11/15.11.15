00:07:40 * hackagebot pandoc-citeproc 0.8.1.3 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.8.1.3 (JohnMacFarlane)
00:07:40 * hackagebot aivika 4.3.1 - A multi-paradigm simulation library  https://hackage.haskell.org/package/aivika-4.3.1 (DavidSorokin)
00:19:19 <gamegoblin> Is there a way to view code after template haskell has been spliced in?
00:22:37 <mniip> -ddump-splices ?
00:26:26 <gamegoblin> mniip: can I use that with cabal build?
00:29:49 <gamegoblin> Is anyone else getting cert errors for haskell.org?
00:33:13 <davidar> gamegoblin: yeah, looks like the cert just expired :/
00:40:03 <Xack> gamegoblin: yup, getting cert errors here as well
00:40:46 <rmrfroot> gamegoblin: heh, just joined the channel to ask that very question :P
00:44:54 <jle`> they're working on it :D
00:49:54 <sgronblo> it works for me now
00:50:26 <gamegoblin> I love writing template haskell that expands to like 1000+ lines of special cases
00:52:57 <rmrfroot> is there a function like `liftM`/`fmap` that has something like `(a -> m b) -> m a -> m b` ?
00:53:49 <gamegoblin> :t (=<<)
00:53:50 <lambdabot> Monad m => (a -> m b) -> m a -> m b
00:53:55 <gamegoblin> rmrfroot: ^
00:54:32 <gamegoblin> > print =<< return "hello world"
00:54:34 <lambdabot>  <IO ()>
00:55:02 <gamegoblin> errr… better example
00:55:45 <rmrfroot> gamegoblin: sorry, my explanation sucked :P say I have a function that returns `IO (Maybe a)` and I want to have something like `>>=` that allows me to apply a function that also returns `IO (Maybe a)` when the input is Just
00:55:45 <gamegoblin> let f x = Just (x+2) in       f <<= Just 5
00:56:18 <gamegoblin> fmap . fmap
00:56:21 <gamegoblin> fmap twice
00:56:37 <suppi> > return . Just =<< [1,2,3]
00:56:39 <lambdabot>  [Just 1,Just 2,Just 3]
00:56:46 <gamegoblin> liftM . fmap would also do it
00:56:54 <gamegoblin> but you only need fmap . fmap
00:57:15 <gamegoblin> since Maybe is also a Monad, liftM . liftM would also work ;)
00:57:22 <gamegoblin> but fmap . fmap is the most general, I think
00:57:23 <rmrfroot> gamegoblin: ah, ok :) thanks
00:57:53 <gamegoblin> fmap (fmap (+2)), for example, would add 2 to an IO (Maybe Int)
00:57:58 <gamegoblin> (if the Maybe was Just)
00:58:18 <rmrfroot> gamegoblin: awesome!
01:00:46 <rmrfroot> gamegoblin: how would i approach the problem if i want to do IO actions if the input is Just?
01:01:24 <gamegoblin> rmrfroot: can you give an example of what you’d like to do (make up syntax or functions if you need)
01:02:08 <rmrfroot> gamegoblin: say i have a database call a `ID -> IO (Maybe Item)` and i then want to chain that with another database call `Item -> IO (Maybe Item2)`?
01:02:46 <gamegoblin> rmrfroot: and you only want to make the second call if the first one succeeds?
01:02:54 <rmrfroot> gamegoblin: exactly!
01:03:57 <gamegoblin> rmrfroot: sounds like you want the maybeT monad transformer
01:03:59 <rmrfroot> right now i have something like `firstCall >>= \itemm -> case item of ...`
01:04:10 <gamegoblin> rmrfroot: are you familiar with monad transformers?
01:04:39 <rmrfroot> gamegoblin: no, but this is a good time as any to learn, i guess :)
01:05:08 <gamegoblin> Search around for MaybeT monad transformer, let me know if you run into issues. It’s exactly what you want. It lets you combine Maybe semantics with another monad, such as IO
01:06:46 <jle`> MaybeT IO a is basically a newtype wrapper around IO (Maybe a) that gives you a (>>=) :: IO (Maybe a) -> (a -> IO (Maybe b)) -> IO (Maybe b), with short circuiting
01:08:32 <nchambers> with https://github.com/begriffs/haskell-vim-now what haskell linter is it talking about?
01:09:25 <cocreature> do we have a different linter than hlint?
01:09:41 <nchambers> oh is that the defacto one/
01:09:43 <nchambers> *??
01:09:52 <cocreature> I think so
01:10:03 <nchambers> thanks
01:16:56 <rmrfroot> thanks gamegoblin and jle` :)
01:27:37 * hackagebot yesod-csp 0.1.1.0 - Add CSP headers to Yesod apps  https://hackage.haskell.org/package/yesod-csp-0.1.1.0 (boblong)
01:29:19 <nchambers> :t delete
01:29:20 <lambdabot> Eq a => a -> [a] -> [a]
02:02:55 <t0by> Sorry, silly question: why 1:2:3:[] = [1,2,3] but 1:2:3... doesn't?
02:04:29 <cocreature> tommd: what are the dots supposed to mean?
02:04:37 <cocreature> eh ^ t0by
02:06:00 <t0by> cocreature, according to ze manual, "prepend".
02:06:39 <ReinH_> tommd: no, "...'
02:06:43 <ReinH_> er, t0by
02:06:46 <t0by> poor tommd 
02:07:03 <t0by> oh, nothing, they are plain english
02:07:13 <ReinH_> 1:2:3:... doesn't equal anything
02:07:15 <t0by> but "1:2:3"   ... doesn't?
02:07:20 <ReinH_> 1:2:3 is a type error
02:07:30 <t0by> ReinH_, why is it?
02:07:34 <ReinH_> :t (:)
02:07:36 <lambdabot> a -> [a] -> [a]
02:07:42 <ReinH_> the rhs of : must be a list
02:07:43 <ReinH_> 3 is not a list
02:07:46 <t0by> ooooh, (:) with brackets.
02:07:53 <t0by> ooooh.
02:07:54 <ReinH_> No.
02:07:59 <t0by> Okay. Thanks.
02:07:59 <ReinH_> The brackets have nothing to do with it
02:08:18 <t0by> ReinH_, no, I mean, when I typed :t : in my ghci it didn't work for me, as I was missing ()
02:08:24 <ReinH_> Ah. Right.
02:08:33 <ReinH_> () around infix operators turns them into expressions
02:08:42 <t0by> Thank you!
02:08:45 <ReinH_> np
02:16:08 <rmrfroot> anyone familiar with esqueleto EDSL?
02:26:28 <pavonia> rmrfroot: It's better to just ask your actual question
02:29:46 <Peaker> The Async library keeps a "ThreadId" around even when the thread completed.. This seems to be very leaky behavior!
02:30:28 <Peaker> Anyone knows whether this is intentional? I wonder if it's worth creating a pull request to complicate the representation of "Async a" to be something like (IORef (Either ThreadId (Either SomeException a))) instead of a plain ThreadId
02:31:33 <Peaker> (ThreadId keeps the potentially large stack alive.. Perhaps even the references in that stack keep even more stuff alive on the heap?)
02:31:51 <Peaker> (Or maybe when the thread completes, the stack is unwounded, and only the stack buffer itself is leaked?)
02:43:30 <aanastasov> Is it possible to return the first Just of a list without writing a function for that by myself?
02:44:17 <aanastasov> And return Nothing if no Just is present.
02:44:22 <shachaf> Are you asking if a function already exists to do that?
02:44:39 <Peaker> > asum [Nothing, Just 5, Just 6]
02:44:40 <lambdabot>  Just 5
02:44:43 <aanastasov> Ideally.
02:44:55 <shachaf> The answer is yes, and it's called asum (or msum).
02:45:37 <aanastasov> I guess this is going to be lazy, and not evaluate anything after the first Just?
02:45:51 <Peaker> asum = foldr (<|>) empty -- the Alternative instance of Maybe is like the Monoid instance of (First)
02:46:00 <bennofs> > asum [Just 4, undefined]
02:46:01 <lambdabot>  Just 4
02:46:09 <bennofs> > asum (Just 4 : undefined)
02:46:11 <lambdabot>  Just 4
02:46:14 <bennofs> seems to be lazy enough
02:46:42 <aanastasov> Thanks!
03:34:16 <rmrfroot> pavonia: yeah, you're right :)
03:45:29 <rmrfroot> i'm trying to create a function with `DiffTime -> (Int, Int)` where `DiffTime` is from Data.Time.Clock and `(Int, Int)` is (hour, minute). problem is i don't really know where to start to convert the `DiffTime` to a `Double` so i can carry out the calculations. any hints?
03:49:54 <pavonia> rmrfroot: You can use realToFrac
03:51:16 <rmrfroot> pavonia: ah, ok! thanks :)
03:52:41 * hackagebot ghc-exactprint 0.4.2.0 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.4.2.0 (AlanZimmerman)
03:56:44 <rmrfroot> pavonia: after i have performed the calculations, how would i convert the `Fractional a` to `Int`?
03:57:28 <pavonia> round or floor
03:59:12 <pavonia> rmrfroot: If you are only interested in the integral part of the DiffTime, you can also use properFraction directly
04:00:56 <rmrfroot> pavonia: aahhh, perfect! thanks
04:08:05 <phaazon> hey, I’d like to create a thread and be able to kill it whenever I want
04:08:15 <phaazon> if I read correctly, forkIO can’t create such a thread right?
04:08:30 <phaazon> because the thread discards the ThreadKilled signal
04:11:42 <Profpatsch> Shouldn’t this work: class Foo a where
04:11:53 <Profpatsch>   fun :: a
04:12:11 <Profpatsch> instance Foo (Double, Double) where
04:12:17 <Profpatsch>   fun = (1,2)
04:12:37 <Profpatsch> I get:     Illegal instance declaration for
04:12:40 <Profpatsch>       ‘Colorscheme (Double, Double, Double)’
04:12:42 <Profpatsch>       (All instance types must be of the form (T a1 ... an)
04:12:56 <Profpatsch> But (Double, Double) is of kind *
04:13:01 <phaazon> Profpatsch: FlexibleInstances
04:13:41 <Profpatsch> phaazon: Why is that not active by default? It looks like a trivial thing you need often.
04:13:53 <phaazon> I don’t know, and I agree with that
04:13:58 <phaazon> that’s the case for a lot of extensions
04:14:14 <phaazon> FlexibleContexts, TupleSections, KindSignatures, MultiWayIf, …
04:15:23 <pavonia> Wasn't there an option to enable the most common extensions in GHC?
04:15:25 <Profpatsch> So I could write (Double, a), but not the trivial case (Double, Double)?
04:15:34 <Profpatsch> That seems strange.
04:16:38 <phaazon> Profpatsch: well
04:16:52 <phaazon> @let class Foo a where { fun :: a }
04:16:53 <pavonia> (Double, a) isn't of the form T a1 ... an either
04:16:54 <lambdabot>  Defined.
04:17:13 <phaazon> @let instance Foo (Double,Double) where { fun = (1,2) }
04:17:14 <lambdabot>  Defined.
04:17:18 <phaazon> works fine.
04:17:27 <phaazon> > fun :: (Doubl,Double)
04:17:29 <lambdabot>      Ambiguous occurrence ‘fun’
04:17:29 <lambdabot>      It could refer to either ‘L.fun’,
04:17:29 <lambdabot>                               defined at /tmp/mueval1376710097927612902.hs:178:9
04:17:30 <phaazon> > fun :: (Double,Double)
04:17:32 <lambdabot>      Ambiguous occurrence ‘fun’
04:17:32 <lambdabot>      It could refer to either ‘L.fun’,
04:17:32 <lambdabot>                               defined at /tmp/mueval1376710097927612902.hs:178:9
04:17:38 <phaazon> haha dammit .D
04:17:44 <phaazon> > Foo.fun :: (Double,Double)
04:17:45 <lambdabot>  Not in scope: ‘Foo.fun’
04:17:53 <phaazon> ok, fuck it :))))
04:18:13 <Profpatsch> Anyway.
04:18:20 <phaazon> @unlet
04:18:21 <lambdabot>  Define what?
04:18:33 <phaazon> @undefine
04:18:33 <lambdabot> Undefined.
04:18:58 <Profpatsch> I’m always suspicious when GHC asks me to enable lang exts, because I think I have probably made a trivial error.
04:19:14 <Profpatsch> This is the second time I actually needed one.
04:19:19 <phaazon> Profpatsch: I think modern Haskell requires a hella extensions
04:19:53 <phaazon> like GADTs, FunctionalDependencies, DataKinds, PolyKinds, ScopedTypeVariables, Derive*, etc.
04:20:08 <phaazon> GeneralizedNewtypeDeriving
04:22:43 <mntmn> hi, newbie problem: i'm trying to use "stack setup" (on debian 8) but i get Preparing to download ghc-7.10.2 ...TlsExceptionHostPort (HandshakeFailed (Error_Protocol ("certificate has unknown CA",True,UnknownCa))) "www.haskell.org" 443
04:22:52 <Taneb> phaazon, that's a lot more true of the kind of library that, for example, edwardk writes, than the average program
04:23:05 <phaazon> Taneb: what do you mean?
04:23:10 <phaazon> ah
04:23:11 <phaazon> well
04:23:17 <phaazon> I do write such code on a daily basis though
04:23:19 <mntmn> which is weird, i even tried manually adding GlobalSign certs but my system seems to have them
04:23:23 <phaazon> I need all those extensions each day
04:23:33 <Taneb> I think you have quite a skewed view, then
04:23:41 <phaazon> I might, indeed :)
04:23:48 <phaazon> Taneb: the thing is
04:23:52 <phaazon> if they were enabled by default
04:24:04 <phaazon> that wouln’t impact the newcomers or people who don’t require them
04:24:11 <phaazon> because there’s no side-effects enabling most of them
04:24:17 <pavonia> Sometimes you can also tell from the name it asks for: "flexible" instances doesn't sound bad, "overlapping" is more suspicious, but you should be concerned if it asks for "incoherent" instances :p
04:24:17 <phaazon> -s
04:24:35 <phaazon> pavonia: I don’t like overlapping instances
04:24:36 <phaazon> that’s vicious
04:24:49 <phaazon> it’s like that extension that I found stupid
04:24:53 <pavonia> Is it?
04:24:53 <phaazon> EmptyTypeClasses
04:24:56 <Taneb> phaazon, that doesn't necessarily mean they need to be on by default
04:24:56 <phaazon> or something like that
04:25:05 <phaazon> Taneb: why?
04:25:13 <phaazon> pavonia: EmptyTypeClasses and ImplicitParameters
04:25:19 <phaazon> I avoid those
04:25:24 <phaazon> I actually never use them
04:25:26 <Taneb> It just means there's no harm in adding them
04:25:39 <Taneb> Haskell 2010, with no language extensions, is a very nice language
04:25:45 <mntmn> ah, sorry for bothering you, it's a known certificate chain problem https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=787281
04:25:51 <phaazon> Taneb: it lacks a lot of things though
04:26:04 <phaazon> I don’t know how I could write my programs without, for instance, ScopedTypeVariables
04:26:07 <phaazon> or Rank2Types
04:26:11 <phaazon> or ExistentialQuantification
04:27:10 <Taneb> I've never actually used ExistentalQuantification
04:27:21 <Taneb> And only rarely needed ScopedTypeVariables
04:27:38 <phaazon> Taneb: in luminance, I write a lot of type-driven code
04:27:40 <phaazon> so I need the latter
04:27:50 <phaazon> the former is useful for other problems :)
04:27:51 <Taneb> Type-driven code is the exception, not the rule :P
04:28:09 <phaazon> Taneb: yeah, but type-driven gives you a lot of guarantees
04:28:15 <phaazon> so I tend to use it extensively
04:41:50 <concept3d> if I am using  the maybe monad how can I know where it returned Nothing
04:42:22 <fendor> an debugger can help
04:42:30 <fendor> a debugger
04:42:41 <Taneb> concept3d, you could replace it with the Either String monad
04:43:11 <Taneb> So instead of Nothing, you put Left "this is why I am failing"
04:43:35 <concept3d> I thought that Either is the only way. So thanks for confirming
04:43:46 <concept3d> is there any other way ?
04:47:25 <Taneb> concept3d, I can't think of any sensible way that isn't essentially the same as using Either
04:48:51 <concept3d> Thanks
05:17:08 <anks> Hello. So i've got this problem with type matching. eegBands function returns CsvSpec Word, and the other ones CsvSpec Int16, https://gist.github.com/anonymous/0038753cc1fd1b285319 . How should I approach this in general?
05:17:42 <ocramz> hi all
05:19:45 <ocramz> anyone here uses `ad` ? what minimal instances should a custom type provide in order to be differentiable? I see `grad` works with lists, so does it work with general Functors, or Traversables?
05:19:45 <phaazon> hey
05:19:56 <phaazon> I’m trying to send information to a thread through IORef
05:20:08 <phaazon> (I know it’s not the best thing for concurrency, but that’s not the problem yet)
05:20:38 <phaazon> so, when I forkIO, I just do something like a forever loop in the thread, reading the IORef (which type is IORef (IO ()) and execute the given action)
05:20:48 <phaazon> when I try to pass actions to the thread, like
05:20:53 <lyxia> anks: convert Int16 to Word or Word to Int16?
05:20:56 <phaazon> writeIORef ref $ putStrLn "lol"
05:21:05 <phaazon> the thread doesn’t seem to execute the action :(
05:21:07 <phaazon> any idea?
05:21:54 <anks> lyxia: that would be my guess, I am wondering though if there is some kind of general approach how to solve such problems
05:21:57 <ocramz> phaazon: I think we need the whole snippet
05:22:04 <phaazon> yep, here it is:
05:22:27 <phaazon> ocramz: http://lpaste.net/1864023442915852288
05:23:21 <nshepperd> ocramz: Traversable, according to the docs
05:25:41 <nshepperd> the actual number type has to be one of the mode data types (Reverse s Float) or whatever
05:25:59 <nshepperd> ocramz: https://hackage.haskell.org/package/ad-4.3/docs/Numeric-AD.html
05:27:18 <ocramz> nshepperd: thank you
05:28:33 <ocramz> nshepperd: I'm a bit worried by the funny constraint in the function to be diff'ed, but I guess the existential quantification serves to avoid mixing partial derivative
05:28:33 <ocramz> s
05:29:09 <ocramz> and, Proxy types are still magic to me 
05:34:23 <nshepperd> it also works if your function works for any numeric type, which is easier to remember
05:35:01 <nshepperd> like 'f :: Num a => [a] -> a'
05:44:32 <ocramz> nshepperd: yes, indeed :)
05:48:58 <ocramz> also, a clarification: in `mono-traversable` we find this remark: "some commonly used data types (i.e., ByteString and Text) do not allow for instances of typeclasses like Functor and Foldable, since they are monomorphic structures. This module allows both monomorphic and polymorphic data types to be instances of the same typeclasses." -- does this mean that otherwise one would need a separate, monomorphic instance, for Vector Int, Ve
05:49:15 <ocramz> *instance of Traversable
05:49:18 <phaazon> ocramz: no idea for my issue?
05:50:09 <ocramz> phaazon: erm, I looked at it but I can't figure it out..
05:50:20 <phaazon> :/
05:51:09 <phaazon> maybe it’s something liked to how the values are created
05:51:13 <phaazon> like, IO are thread-bound?
05:51:30 <phaazon> that’s very unlikely though
05:54:10 <ocramz> phaazon: have you read Marlow's book already?
05:54:20 <phaazon> hm?
05:54:32 <ocramz> Parallel and Concurrent Programming in Hs
05:54:37 <phaazon> ah
05:54:38 <phaazon> no
05:54:40 <ocramz> do it
05:54:41 <phaazon> I haven’t
05:54:47 <ocramz> freely available online
05:55:18 <phaazon> ok, I am then :D
05:56:41 <exio4> phaazon: "readIORef" is the problem
05:57:14 <exio4> phaazon: readIORef :: IORef a -> IO a , a ~ IO b, you need either a join or { x <- readIORef ref ; x } 
05:57:22 <exio4> phaazon: I guess, let me try first
05:59:13 <exio4> yes, that fixed it
05:59:21 <exio4> phaazon: ^ there, found the issue :P 
06:12:45 * hackagebot pandoc-placetable 0.3 - Pandoc filter to include CSV files  https://hackage.haskell.org/package/pandoc-placetable-0.3 (mb21)
06:14:41 <phaazon> exio4: hm
06:14:46 <phaazon> I’ll try that, thanks
06:14:52 <phaazon> a join though?
06:15:05 <phaazon> oh because of IO (IO ())
06:15:06 <phaazon> right
06:16:04 <phaazon> yeah, it works!
06:16:05 <phaazon> thanks!
06:22:45 * hackagebot handa-opengl 0.1.6.1 - Utility functions for OpenGL and GLUT  https://hackage.haskell.org/package/handa-opengl-0.1.6.1 (BrianBush)
06:37:46 * hackagebot persistent 2.2.2.1 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.2.2.1 (GregWeber)
06:47:26 <zipper> Hello, anybody home?
06:47:30 <sedeki> yes
06:48:07 <zipper> So I noticed the typechecker doesn't let me use the same uh value names in different record types.
06:48:13 <zipper> Let me demonstrate http://lpaste.net/1896623026376540160
06:48:47 <zipper> I can't have debit and credit both use organisation, purpose and so forth.
06:49:00 <zipper> Am I missing something? I don't see why this is the case.
06:49:01 <m1dnight_> That is true
06:51:11 <zipper> m1dnight_: I don't see why that's the case.
06:51:46 <bennofs> Wow, the diagrams package is simply awesome. Anyone who hasn't seen that package yet should take a look at this documentation: http://projects.haskell.org/diagrams/doc/quickstart.html.
06:52:37 <geekosaur> zipper, because they are also defined as functions (purpose :: Credit -> Text)
06:53:15 <geekosaur> this is what got lens packages started...
06:53:29 <zipper> geekosaur: Oh yeah that totally makes sense.
06:53:55 <geekosaur> also, note that ghc 8 is supposed to include a new field mechanism that will help with this
06:54:15 <geekosaur> (more or less, a miniature lens mechanism built into the compiler with the ability to integrate with more complete lens packages)
06:54:22 <mniip> yeah it will include automatically generated typeclassesful functions
06:54:50 <mniip> Has "purpose" a b => a -> b
06:54:54 <zipper> geekosaur: I haven't looked at the lens package. I've been afraid of it for a while. Should I be afraid?
06:54:55 <mniip> or something
06:55:22 <geekosaur> zipper, there's more than just lens. you could start with something simpler like fclabels (iirc the first lens package)
06:55:23 <mniip> with 'instance Has "purpose" Credit Text' and stuff
06:55:34 <bennofs> zipper: if you want to start simpler, try lens-family. It's compatible with lens (underlying types are the same), but doesn't generalize as much
06:56:00 <geekosaur> but I'd not be too afraid of lens, really. it has a lot of stuff in it but you can just use the record stuff
06:57:46 * hackagebot bson 0.3.2.1 - BSON documents are JSON-like objects with a standard binary  encoding.  https://hackage.haskell.org/package/bson-0.3.2.1 (GregWeber)
07:03:15 <latermuse> are there any haskell parsers that support inline replacement of matches?
07:03:55 <Clint> what
07:04:56 <mniip> like s/// ?
07:05:00 <latermuse> yeah
07:05:13 <latermuse> like s/// but without using regex
07:06:28 <mniip> I believer you can do that with any monadic parsing combinator library
07:06:32 <mniip> believe
07:06:55 <latermuse> really? 
07:07:02 <latermuse> I was not able to get it to work in parsec
07:07:09 <latermuse> or attoparsec
07:07:51 <ben> What does "inline" mean here?
07:08:20 <latermuse> ben: being able to change the input text directly in one pass without making copies of the data
07:08:31 <latermuse> for all matches of the parser
07:08:36 <latermuse> basically just s///
07:11:56 <mniip> gsub f p = liftA2 (++) (fmap concat $ liftA2 (++) (manyTill anyChar p) $ fmap f p) $ many anyChar
07:11:59 <mniip> latermuse, ^
07:12:47 * hackagebot persistent-postgresql 2.2.1.1 - Backend for the persistent library using postgresql.  https://hackage.haskell.org/package/persistent-postgresql-2.2.1.1 (GregWeber)
07:13:03 <mniip> takes a function, and a parser (that is supposed to return a string), and returns a parser that returns the original string with matches of the parser replaced according to the function
07:13:09 <latermuse> mniip: woah..
07:13:50 <latermuse> thats beautiful
07:14:18 <latermuse> thanks so much
07:16:42 <latermuse> mniip the parser master
07:17:47 * hackagebot diagrams-haddock 0.3.0.8 - Preprocessor for embedding diagrams in Haddock documentation  https://hackage.haskell.org/package/diagrams-haddock-0.3.0.8 (bergey)
07:18:15 <mniip> aw stop it
07:28:31 <dramforever> So...I'm posting this over and over again, but does anyone know about a quick guide on using structured-haskell-mode? It seems that SHM doesn't like the way I use it. And no, the README didn't really help.
07:32:48 * hackagebot geodetics 0.0.4 - Terrestrial coordinate systems and geodetic calculations.  https://hackage.haskell.org/package/geodetics-0.0.4 (PaulJohnson)
08:10:39 <jeltsch> I cannot access http://www.haskell.org/.
08:10:59 <jeltsch> Firefox says that this site uses HTTP Strict Transport Security, so that a switch to HTTPS is mandatory.
08:11:28 <jeltsch> However, haskell.org uses an invalid security certificate (sec_error_unknown_issuer) .
08:11:36 <jeltsch> Anyone else expecting this problem?
08:11:55 <ben> https works fine for me
08:12:12 <ben> cert fingerprint F3:13:84:3C:4B:B1:36:E8:1B:85:E5:0F:94:83:43:47:94:60:65:A9:92:02:33:3C:8C:9A:14:2C:26:A9:EB:67 here
08:14:19 <jeltsch> ben: Hmm, Firefox does not show me certificate information. It somehow treats https://www.haskell.org/ as if it did not use SSL.
08:16:06 <maerwald> firefox ssl code is somewhat broken, try a different browser
08:16:12 <ben> I'm on firefox :(
08:16:23 <maerwald> e.g. if you use the same tab, it doesn't reread the certificate properly
08:16:39 <maerwald> it's all broken
08:17:04 * geekosaur just launched firefox on linux, loaded up https://www.haskell.org, and got sec_error_unknown_issuer
08:17:12 <geekosaur> does firefox have issues with globalsign?
08:17:27 <ben> my firefox must have been taken over by globalsign! :(
08:17:45 <jeltsch>  If I test with openssl s_client, I get the message “Verify return code: 21 (unable to verify the first certificate)”.
08:17:58 <jeltsch> So it is probably not just a Firefox issue.
08:21:49 <ion> https://www.ssllabs.com/ssltest/analyze.html?d=haskell.org&latest
08:22:55 <geekosaur> o.O
08:23:20 <geekosaur> "The server supports only older protocols, but not the current best TLS 1.2. Grade capped to C." ...but chrome claims it's using TLS 1.2
08:24:29 <jophish> What happpens if I have a dependency on package A and B, A in turn has a dependency on package C with a flag enabled and B has a dependency on package C too but with the flag disabled
08:24:45 <jophish> I presume this wouldn't be buildable
08:25:34 <geekosaur> oh, I see, that's the server haskell.org that redirects to www.haskell.org
08:26:11 <jophish> I have a package in which I define quickcheck Arbitrary instances, but I don't wan't to inflict a quickcheck dependency on users who won't use it
08:26:14 <geekosaur> and it looks like the problem is we need to send an extra intermediate certificate'
08:26:29 <geekosaur> "GlobalSign Domain Validation CA - SHA256 - G2"
08:27:21 <geekosaur> jophish: I don't think the build stuff tracks flags, so you'd get an error from ghc (or possibly ld) attempting to build instead of an error from cabal/stack trying to find a build plan
08:28:22 <phaazon> hey, is forkIO named that way whilst it creates threads and not processes?
08:28:23 <jophish> oh, that's surprising
08:28:43 <jophish> The "optional dependency" story is so depressing
08:28:44 <latermuse> is there a haskell library that can link all url's in a file? example: "hello world http://foo.com https://google.com" will become "hello world <a href=\"http://foo.com\">http://foo.com</a> <a href=\"https://google.com\">https://google.com</a>"
08:29:04 <jophish> latermuse: pandoc might do that if you ask it nicely
08:29:34 <geekosaur> phaazon, forkIO / forkOS vs. forkProcess. I don't know why they reused "fork" for threads
08:30:28 <phaazon> thanks
08:30:40 <jeltsch> @hoogle Applicative f => f a -> f b -> f (a, b)
08:30:42 <lambdabot> Data.ByteString.Builder.Prim (>*<) :: Monoidal f => f a -> f b -> f (a, b)
08:30:42 <lambdabot> Data.Sequence zip :: Seq a -> Seq b -> Seq (a, b)
08:30:42 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
08:31:10 <jeltsch> Hmm, this one is missing in Control.Applicative. It is such a fundamental operation.
08:31:44 <mniip> jeltsch, it's a part of an alternative definition of applicative
08:31:51 <latermuse> jophish: pandoc is pretty massive, could you give me a hint about which module to look in for that?
08:32:20 <jeltsch> mniip: You mean defining Applicative by pure, fmap, and this function? Yes, this is why I was saying it is fundamental.
08:32:25 <jophish> jeltsch: how about `(,) <$> foo <*> bar`
08:32:29 <latermuse> Do I need to make my own reader for that?
08:32:36 <jophish> err, ignore me
08:32:42 <mniip> jeltsch, no
08:32:53 <jeltsch> mniip: What do
08:32:57 <jeltsch>  you mean then?
08:33:03 <mniip> unit :: f ()
08:33:08 <mniip> outer :: f a -> f b -> f (a, b)
08:33:10 <jophish> latermuse: I'm not sure, but it might work just reading that as plain text or markdown and writing it as html
08:33:14 <jeltsch> Oh yes, unit and this function.
08:33:20 <jophish> I've never tried it though
08:33:25 <jeltsch> mniip: And, of course, fmap.
08:33:34 <mniip> fmap is implied
08:33:41 <latermuse> ah I see, thanks ill try that
08:34:05 <dramforever> Does anyone know about a quick guide on using structured-haskell-mode? It seems that SHM doesn't like the way I use it. And no, the README didn't really help.
08:34:08 <jeltsch> mniip: True, but with pure and (<*>), you can also derive fmap, but with this alternative implementation, you need it (if only via the superclass).
08:34:26 <jophish> latermuse: I've got pandoc in ghci at the moment, give me a second and I'll test it for you
08:34:32 <dramforever> mniip: oh and hey there =) busy term this year, but I finally got some time to play with code
08:35:04 <latermuse> jophish: Fabulous. I also have pandoc open in ghci, but cannot conflagurate the proper runes to achieve the desired result
08:35:44 <jophish> latermuse: something like: writeHtml def <$> readPlain def "http://example.com"
08:35:54 <mniip> dramforever, hmm?
08:36:03 <mniip> you talking about kmp stuff?
08:36:19 <dramforever> mniip: um...long time no see :)
08:36:24 <mniip> yeah
08:36:28 <mniip> kinda
08:37:57 * hackagebot idris 0.9.20.1 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.9.20.1 (EdwinBrady)
08:38:39 <mniip> dramforever, I have since renamed the package
08:38:50 <mniip> because it was much closer to KMP than to Z
08:39:02 <mniip> @hackage functional-kmp
08:39:03 <lambdabot> http://hackage.haskell.org/package/functional-kmp
08:40:06 <latermuse> jophish: there is no readPlain or anything similar to that in pandoc
08:40:15 <mniip> dramforever, oh and tests \o/
08:40:37 <dramforever> looks great!
08:40:42 <mniip> dramforever, https://github.com/mniip/functional-kmp/blob/master/test/Test.hs
08:43:42 <jophish> latermuse: oh, sorry I assumed there was a readPlain because there's a writePlain
08:43:49 <jophish> you could try readMarkdown
08:44:50 <latermuse> markdown assumes ()[] url pattern I believe
08:44:58 <latermuse> []() maybe
08:45:12 <latermuse> or perhaps I need to make my own reader, but that just brings me back to parsing
08:45:25 <jophish> latermuse: ok, sorry that didn't work out
08:45:46 <latermuse> no problem, thanks for the help
08:45:58 <latermuse> Im really trying to avoid using regex for this, but it seems thats the only way
08:46:25 <latermuse> Actually I already made a funciton that does this, but the complexity is terrible and it takes forever to complete
08:46:31 <jophish> latermuse: yeah, regex url parsing is much harder than it seems
08:47:23 <latermuse> I did it with attoparsec and its completely eating my machine's processing power right now
08:47:48 <latermuse> its first parsing for urls in the text, then it iterates over each url and does a find/replace
08:47:53 <latermuse> terrible complexity
08:48:09 <latermuse> I want to find a way that will do it in one pass
08:48:28 <latermuse> maybe I can write a parser to do it by hand without attoparsec even
08:48:31 <geekosaur> readRST?
08:48:38 <jophish> latermuse: I've got a really simple regex replace package in the pipeline which might be useful for that
08:48:43 <latermuse> but thats going to turn into some write-only function that cant be maintained at all
08:49:05 <jophish> I think url form a regular language, so it should be possible in linear time
08:49:20 <jophish> urls*
08:49:24 <latermuse> yes, it should be possible in linear time, and actually I have an implementation of that in C
08:49:42 <latermuse> but getitng it to work linearly in haskell is a bit harder
08:50:07 <dramforever> anyone familiar with structured-haskell-mode here? (shortening the question over time...)
08:50:16 <jophish> latermuse: I'd use some nice regex library like regex-tdfa
08:50:30 <latermuse> geekosaur: you are god
08:50:42 <geekosaur> hardly
08:50:51 <latermuse> readRST def "http://example.com\n"
08:50:52 <latermuse> works
08:50:54 <latermuse> fantastic!
08:51:14 <jophish> ah, glad it's working for you, latermuse 
08:51:24 <latermuse> thanks a lot jophish, thanks geekosaur
08:51:31 <latermuse> this should relieve the load on my poor poor server :D
08:51:32 <jophish> no problem latermuse 
08:52:07 <latermuse> im on a mission to achieve 10 million page views per minute
08:52:26 <jophish> latermuse: the server performace is the least of your worries in that case
08:52:53 <latermuse> ive already got the page views
08:52:53 <latermuse> running on a C program, and im porting it to haskell
08:52:53 <latermuse> so the server performance is my major worry
08:53:43 <jophish> latermuse: google gets 2,000,000 searches a minute
08:54:03 <latermuse> my website is google size
08:54:28 <latermuse> top 20 in world for traffic
08:54:31 <jophish> gosh, I hope haskell works out for you!
08:54:38 <latermuse> anyways, thanks for the help you guys, gotta keep hacking :)
08:54:42 <jophish> bye
08:55:17 <latermuse> haskell has worked out for me in backend processes, but this is the first try at getting haskell running on the front end
08:55:33 <latermuse> users want low latency and something that never breaks
08:55:50 <latermuse> anyways, talk to you guys later
08:55:55 <latermuse> thanks again
08:56:50 <jophish> where do you think latermuse works?
08:58:19 <sm_> Hackage, Inc. In the future.
08:58:27 <dramforever> jophish: bing?
08:59:02 <jophish> dramforever: when I was working there I never heard anything about people using Haskell
08:59:16 <dramforever> hmm...who knows
08:59:36 <jophish> sm_: I'm not sure about that
08:59:43 <SrPx> How do you usually search on the literature for algorithms on functional data structures? For example, I'm looking for a data structure that allows parallel addition on natural numbers, but I have no idea how I'd look for a paper implementing that for functional structures. Googling is too polluted with unrelated things..
08:59:44 <jophish> if he had a time machine why would he be concerned about latency?
09:01:59 <triliyn> SrPx: if you're specifically looking for papers, have you heard of google scholar? https://scholar.google.com/
09:02:23 <SrPx> Yes, that's what I'm talking about. I've tried many queries: "functional parallel addition" "parallel addition algebraic datatypes" and so on, no luck
09:02:57 <SrPx> There are even results for multiplying CUDA matrices in parallel on the first page. Nothing to do with what I want, at all.
09:03:28 <monochrom> perhaps there is no such paper
09:05:15 <SrPx> I find that unlikely, that sounds too fundamental for nobody to have bothered with yet?
09:11:23 <tulcod> SrPx: do you mean a data structure that somehow represents two natural numbers, and two such "pairs" can be added in one operation?
09:12:08 <SrPx> tulcod: exactly, and on which the representation of a natural number takes logarithmic space
09:12:09 <tulcod> SrPx: (out of interest, if that is what you are looking for, why are you interested in the parallelism)
09:12:36 <SrPx> tulcod: basically curiosity 
09:13:16 <tulcod> SrPx: potential food for thought: try instead looking at the natural numbers with infinity. the defining property of what you are looking for is that four numbers can be added pairwise, even if one or more of them is infinity
09:13:24 <SrPx> (without logarithmic space, you could use just "data Nat = Add Nat Nat | One | zero", on which addition obviously takes O(1), but it uses O(N) spae
09:14:05 <SrPx> tulcod: hmm interesting, I'll give it a try, but why? :)
09:14:36 <tulcod> SrPx: well (1 + infty , 3 + 4) never computes the second component in the "stupid" data structure
09:14:44 <tulcod> cause it gets stuck on the first
09:16:49 <tulcod> SrPx: but it should also be able to compute (1 + 2 , infty + 4), so swapping around variables doesn't actually fix anything
09:16:57 * SrPx is thinking
09:18:29 <tulcod> SrPx: (the natural numbers with infinity are defined coinductively, not inductively)
09:18:54 <tulcod> (so the following definition is wrong: data CoNat = Zero | Suc CoNat | Infty)
09:18:54 <SrPx> can you remind me the implementation? tulcod 
09:19:55 <tulcod> well I guess here you can exploit partiality of haskell
09:20:01 <tulcod> infinity = Succ infinity
09:20:44 <SrPx> okay but that uses the inductive definition
09:20:56 <tulcod> SrPx: right, so i guess you can just look at the regular Natural data type, and write infinity = Succ infinity
09:21:05 <tulcod> note that you cannot "test" if something is infinite. that is undecidable.
09:21:22 <tulcod> (it is semidecidable whether a number is finite)
09:22:24 <tulcod> SrPx: and then you want to implement addition for pairs of such Naturals such that the finiteness of the left component is independent of the right component, and vice versa
09:23:17 <SrPx> tulcod: okay that is simple
09:23:18 <tulcod> SrPx: alternatively, reimplement Natural as a sequence of Bools, and interpret a 1 at index i as 2^i. that gives you logarithmic storage
09:23:31 <tulcod> interpret a true* at index i
09:23:46 <tulcod> sequence == list here
09:24:00 <SrPx> tulcod: add (Succ a) (Succ b) = (Succ (Succ (add a b))); add (Succ a) Zero = Succ a; add (Zero (Succ a) = Succ a
09:24:08 <tulcod> actually no that will give many different infinities
09:24:28 <tulcod> and makes it completely undecidable whether a number is finite
09:24:53 <tulcod> SrPx: ah but what about addig pairs of such numbers?
09:25:09 <SrPx> wait
09:25:25 <tulcod> add' : (Natural, Natural) -> (Natural, Natural) -> (Natural, Natural)
09:25:28 <SrPx> you mean adding ((a,b),(c,d))? 
09:25:30 <tulcod> yes
09:25:43 <tulcod> "adding in parallel"
09:25:47 <SrPx> ah I see
09:26:31 <SrPx> Okay, in that case you can use a continuation passing style to pass a thread from a to b, then from b to c, then from c to d, then back to a, and so on
09:27:23 <tulcod> SrPx: well yeah, but the point is that you will need to add several things in parallel. you can't first add a and c. (or a and b)
09:28:39 <SrPx> okay proceed
09:28:51 <tulcod> no this is all i have to contribute :P
09:29:04 <tulcod> i mean. I guess CPS could help you here. i believe you.
09:29:39 <tulcod> and i'm sure you can find some fancy way to get logarithmic storage efficiency for these objects
09:31:05 <SrPx> I think CPS does parallel addition perfectly fine on the unary case
09:31:16 <SrPx> but it wouldn't work for any logarithm representation I can think of
09:34:16 <SrPx> To be more precise, I was thinking some kind of a tree with a map from/to natural numbers, on which a binary `add` operation was O(N)
09:36:52 <tulcod> SrPx: another idea: write down 4 natural numbers, add them in parallel. think about how you did it. translate to code. victory. rule the world.
09:37:34 <reactormonk> How do I construct [(IO a, b)] -> IO [(a, b)] ?
09:38:36 <lingxiao> http://lpaste.net/145318
09:38:47 <monochrom> unzip, sequence, zip
09:38:59 <lingxiao> http://lpaste.net/145318
09:39:04 <monochrom> alternatively, write your own recursion
09:39:38 <lingxiao> not sure why it does not type check
09:40:03 <lingxiao> in the line fmap g (C f) = C $ \c -> f (\a -> c (f a)) 
09:40:14 <lingxiao> c should have :: b -> Action
09:40:27 <lingxiao> f :: (a -> Action) -> Action
09:40:57 <lingxiao> ergo (\a -> c (f a)) should be of type :: a -> Action
09:41:20 <lingxiao> and it does because f a has type b, and c (f a) has type Action
09:42:43 <lingxiao> ah ok nevermind!!
09:42:49 <lingxiao> used f when I should have used g
10:04:36 <reactormonk> What's the correct syntax for (b -> d) -> (a, b, c) -> (a, d, c) ?
10:05:02 <monochrom> that's already correct syntax
10:05:22 <geekosaur> could you clarify the question a bit? not sure what you're asking for
10:06:42 <tommd> f :: (b -> d) -> (a,b,c) -> (a,d,c) ; f g input = error "Add function definition here"
10:06:46 <tommd> reactormonk: ^^^
10:07:02 <reactormonk> tommd, yeah, I'm not sure about how to write the function definition.
10:07:36 <tommd> reactormonk: That's what I was guessing.  So this function takes two arguments - can I see your intial attempt?
10:07:36 <geekosaur> there might be something arrowy that could do it, I'd just deconstruct the tuple and build a new one
10:07:38 <tommd> @where paste
10:07:38 <lambdabot> Haskell pastebin: http://lpaste.net/
10:07:56 <reactormonk> geekosaur, oke, should work.
10:45:54 <nkaretnikov> a colleague asked me this question, not sure how to even start answering it: "what will happen if a haskell web server receives two http requests at the same time?"  the server is just a hypothetical haskell web server, could be the one written in scotty or yesod.
10:47:21 <athan> nkaretnikov: concurrency ftw
10:47:23 <exio4> just guessing, the thread that receives http requests isn't parallel, it'll process a single request, start a new thread, and then process the second one? 
10:47:57 <nkaretnikov> how do i get a concrete answer?
10:48:01 <glguy> nkaretnikov: It depends on how you've written the web server. One thread can be accepting connections and spawning new "green" threads to handle each request
10:48:14 <glguy> or you could have a single thread that handled the requests in series
10:48:24 <glguy> and the second request could block while the first was being processed
10:48:31 * hackagebot language-puppet 1.1.4.1 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.1.4.1 (SimonMarechal)
10:48:38 <glguy> You can specify how large of a queue for pending requests you want per socket
10:49:56 <parsnip> hmm, got an error from `where bmi = weight / height ^ 2; (skinny, normal, fat,) = (18.5, 25.0, 30.0)`, illegal tuple section. 
10:50:08 <nkaretnikov> parsnip: you have an extra comma
10:50:12 <nkaretnikov> after fat
10:50:12 <glguy> parsnip: remove the trailing comma
10:50:35 <parsnip> sorry! 
10:51:30 <geekosaur> there are languages where you can do that, but as you saw Haskell parses that as a tuple section (a partial function you can apply to something else to produce a tuple, in this case one with 4 elements)
10:51:56 <geekosaur> ...nbut you actually have to enable that with an extension, because tuple sections are not yet part of the standard
10:52:39 <geekosaur> remember that a tuple is not a list; it has a fixed length
10:53:00 <geekosaur> :t (,,,)
10:53:01 <lambdabot> a -> b -> c -> d -> (a, b, c, d)
10:54:01 <nkaretnikov> glguy: do you know any examples off-hand?
10:54:25 <glguy> nkaretnikov: Of webservers?
10:54:35 <geekosaur> nkaretnikov, the concrete answer will be different based on what framework you use
10:54:38 <nkaretnikov> glguy: of how it's done
10:54:46 <nkaretnikov> glguy: like, how's it done in warp, etc.?
10:56:26 <glguy> nkaretnikov: There's lots of code on hackage.haskell.org. You might look at warp or snap-server or just search for HTTP on the package list
10:56:53 <glguy> creating a new green thread per request is pretty standard and fits with GHC's IO runtime well
10:57:33 <geekosaur> http://www.aosabook.org/en/posa/warp.html talks about the various ways you can do it and how warp in particular does it
10:57:58 <nkaretnikov> oh cool
10:58:01 <nkaretnikov> let me see
11:00:52 <athan> ugh, I don't think the urlencoded library is correct
11:01:23 <athan> couldn't query strings just have valueless entries? Like `foo?key=val&key2&key3=val`?
11:01:29 <Cale> Yeah, it might feel weird at first to create threads just to express the idea of waiting on multiple things at once, but it shouldn't :)
11:01:36 <ChristianS> athan: yes
11:01:55 <athan> ChristianS: -.- greeeeeat
11:02:05 <athan> mer
11:08:36 <liste_> athan yes they can
11:09:46 <athan> liste: I thought so :\ so I'm guessing the standard way to parse x-www-urlencoded / percent-encoded data is through Network.HTTP.Base.urlDecode, then do manual `+` escaping and `=` breaking afterward?
11:20:11 <gamegoblin> Is tuple pattern matching constant time? Say I have a 64-tuple, and I make a 64 case function to extract the nth element. Is that constant time, or does it need to linearly check cases?
11:20:21 <gamegoblin> (for GHC specifically)
11:20:54 <ggole> You don't need a 64-case function for that?
11:21:14 <ggole> Or do you mean that n is a runtime value?
11:21:30 <gamegoblin> ggole: yes, n is a runtime value
11:21:43 <gamegoblin> ggole: so my function is like getElem64Tuple
11:21:51 <ggole> Ah, ok
11:21:55 <gamegoblin> ggole: you give it N and your tuple, it returns Nth element
11:22:05 <gamegoblin> (using template haskell to generate this monster, of course :P)
11:22:16 <ggole> Surely you should use an array for this.
11:22:39 <gamegoblin> ggole: I was interested because with a tuple I have a size guarantee
11:22:45 <gamegoblin> Somewhat interested for ideological type-safe reasons
11:22:50 <gamegoblin> I’ll probably wind up using a Vector
11:22:54 <Pamelloes> What combination of functions do I need to make Maybe (IO (Maybe a)) -> IO (Maybe a)?
11:22:56 <edwardk> phaazon: i wound up needing NullaryTypeClasses just today
11:22:56 <gamegoblin> But now I’m curious about the tuple semantics
11:23:29 <ggole> That's a bit of an odd motivation, but OK
11:24:02 <gamegoblin> Pamelloes: fromMaybe (return Nothing)
11:24:31 <gamegoblin> Pamelloes: assuming I have interpreted your goal correctly. 
11:25:05 <Pamelloes> gamegoblin: That's what I'm looking for :)
11:37:22 <nitrix> How idiomatic is it to explicitly list all the things imported from imports?
11:37:30 <nitrix> e.g. import Web.Scotty (scotty, middleware, get, notFound, html, redirect, text)
11:38:30 <nitrix> I'm working with Clay and Blaze too, whose have clashing names, so I figured it'd be easier to keep track of what is which. Originally, I had them qualified, but then I moved those to their respective module so it isn't as confusing.
11:38:54 <nitrix> I'm still thinking of keeping the explicit imports unless someone says it's really unecessary :/
11:39:26 <geekosaur> there are two styles there, some explicitly list only when needed, others always do so
11:39:36 <glguy> There's nothing wrong with explicit import lists. They're more work for you to maintain but they help readers of the code to figure out where definitions come from
11:39:43 <geekosaur> there are arguments for both
11:39:46 <rvxi> hello
11:40:05 <liste> hello rvxi
11:40:31 <glguy> and they're more resilient to future library versions that might introduce a new definition that could clash with something else in your module
11:41:09 <rvxi> nitrix: you're using ghcjs?
11:41:21 <nitrix> rvxi: nah.
11:41:33 <Peaker> The "Async" type in the Async library holds a ThreadId, when it should probably hold a Weakref to a ThreadId. Does anyone know why?
11:41:50 <rvxi> server side only? still looking for the right javascript solution...
11:42:25 <Peaker> Open import lists choose short-term convenience over long-term readability and buildability
11:42:36 <nitrix> rvxi: Have you looked at haquery?
11:42:54 <shemale_magic> is haskell way better than python?
11:43:02 <Peaker> ghc -ddump-minimal-imports should get nice UI integration
11:43:10 <nitrix> shemale_magic: Depends on your definition of better.
11:43:37 <nitrix> shemale_magic: Which aspect are you interested in?
11:44:04 <rvxi> nitrix: no. i'm not attached to legacy stuff. aiming to do more stuff like D3 visualization, FRP based interaction..
11:44:04 <shemale_magic> writing better shorter programs faster
11:44:12 <shemale_magic> making lots of money
11:44:26 <rvxi> shemale_magic: by that definition probably no, at least not in the short term
11:44:43 <nitrix> shemale_magic: I'm afraid there's no strong correlation between Haskell and money made.
11:44:58 <shemale_magic> how about better shorter programs written faster
11:45:36 <nitrix> It takes an initial time investment to get to that point.
11:45:39 <rvxi> shemale_magic: haskell is more compelling in the medium to long game. more robust systems, better designs for the ecosystems. but in the short term, the ecosystem isn't there yet compared to python
11:46:15 <monochrom> I think "better shorter written faster" is a contradiction. what they said about "good, cheap, fast: pick two"
11:46:35 <rvxi> getting rich - i think your skillset will be better positioned in 10 years, but it's not a get rich quick solution.
11:47:00 <rvxi> monochrom: java programmers say that a lot. but i think part of the appeal of haskell is that... you may not have to
11:47:20 <monochrom> and yeah, to make a lot of money, go for an MBA instead
11:47:39 <rvxi> monochrom: i think of FP & type systems as a form of automation for the stuff that wastes time in other languages
11:48:02 <shemale_magic> hmmm
11:48:02 <rvxi> (particularly languages like python =P)
11:48:10 <shemale_magic> mba?
11:48:13 <monochrom> ah, but you will spend your time on understanding lazy evaluation
11:48:21 <shemale_magic> cant beat em join em
11:48:27 <parsnip> shemale_magic: business degree
11:48:33 <nitrix> Today I refactored 5000 lines of Haskell code and it compiled flawlessly with no errors and passed the tests.
11:48:35 <shemale_magic> become empty suit
11:49:18 <rvxi> monochrom: that's a one time cost. writing tons of unit tests to substitute for a type system is forever...
11:49:37 <monochrom> if you want to make a lot of money, you have to give up programming. after all, both Larry Wall and Mark Zuckerberg did. Bill Gates too. and Steve Jobs didn't even start.
11:49:42 <rvxi> shemale_magic: how old are you?
11:50:47 <monochrom> no, after you have learned lazy evaluation, you will still be spending time per program to predict each program's time and space
11:51:04 <monochrom> and it is still more than python programs, per program
11:51:25 <rvxi> monochrom: what do you mean by predicting each program's time and space?
11:51:39 <monochrom> there are also other fronts on which you spend more time thinking, per program, when using Haskell
11:51:50 --- mode: ChanServ set +o mauke
11:51:51 --- mode: mauke set +b *!*@209-6-212-33.c3-0.bkl-ubr1.sbo-bkl.ma.cable.rcn.com
11:51:53 <monochrom> predicting how much time and space a program will use
11:51:57 --- kick: shemale_magic was kicked by mauke (ban evasion)
11:53:42 <rvxi> i see what you mean. i think on the whole though there's more cognitive effort to load up  python program reasoning than haskell program reasoning  beyond a certain degree of complexity.
11:53:55 <rvxi> (assuming programs in boath programs are doing the same task)
11:53:56 <Peaker> monochrom: sounds like a very uncompelling case for Haskell :) I suppose you also hold beliefs in the other direction?
11:53:56 <monochrom> on the bright side, the extra time you spend buys you better correctness
11:53:58 --- mode: mauke set -o mauke
11:54:34 <rvxi> also, be happy strict haskell just got released :-)
11:54:40 <Peaker> monochrom: IME, Python and Haskell take roughly the same amount of time to implement small things yet the Haskell will be more robust/correct (I've actually measured this for a few tiny projects)
11:54:44 <rvxi> haven't tried it myself though
11:54:57 <nitrix> rvxi: Embrace the lazyness :X
11:55:55 <rvxi> nitrix: lazy in the spine, strict in the leaves, isn't that the saying? i haven't done anything large/performance-sensitive enough to worry about that though..
11:55:55 <parsnip> is there something like Python's jinja2 template filler for Haskell? 
11:56:51 <Peaker> Does anyone know what the effect of holding onto a ThreadId (of a dead thread) is, in terms of memory use? I know it'll leak the stack space -- but will the stack space still contain live references to other objects, or does the thread being dead mean the stack is fully unwound?
11:57:06 <rvxi> i will say though, there's so much momentum behind python for data science. it's sad, will be another generation of programmers before people wise up...
11:57:54 <monochrom> Peaker: to a large extent, when I feel that the asker is a troll, I do the opposite of what Cale does: I say why Haskell is so undesirable, even why programming altogether is so undesirable
11:58:16 <nitrix> C++11 and the new Java are borrowing couple aspects from FP already; you'd think people would start to get an interest for those by now.
11:58:39 <rvxi> nitrix: some do. i partially came by way of c++11
11:58:59 <nitrix> Ah sweet.
11:59:03 <rvxi> nitrix: also, bartosz must be converting at least a couple dozen people in his talks :)
11:59:11 <rcyr> Hehe, Haskell is the path to C++ template metaprogramming enlightenment
11:59:20 <t4nk146> how can i make this type instance of monad http://pastebin.com/VKG9bd9G
11:59:36 <Cale> fwiw, even though I tend to give people a lot of rope to hang themselves with, I probably wouldn't generally expect any kind of reasonable discussion to take place with someone who was trolling with the nick "shemale_magic"
11:59:53 <nitrix> t4nk146: Have you looked at typed holes?
12:00:26 <nitrix> I know it helped me a great deal when implementing instances as a beginner.
12:00:32 <rvxi> rcyr: i think the concurrency/parallel/async story is more compelling. the vast majority of C++ programmers avoid TMP (except for trivial applications in the STL) for its esoteric-ness and painful compile times.
12:00:36 <t4nk146> i dont know about type holes
12:00:43 <mauke> @unmtl StateT Int Maybe a
12:00:43 <lambdabot> Int -> Maybe (a, Int)
12:01:16 <rcyr> rvxi: Hehe, you're probably right :)
12:02:14 <nitrix> Yeah that Timeout type reminds me of StateT.
12:05:45 <t4nk146> its supposed to used with a function that updates state at each recursive call, to check if supplied n is greater than returned state, and return Nothing or Just that value
12:06:43 <t4nk146> oh  i pasted that function as well
12:10:19 <zipper> Hey I was looking at this post on reddit and it advocates using newtype over type. I really don't see how type is inefficient and I think it's really easy to use especially if I don't want to add the typing overhead of the newtype's data constructor.
12:10:30 <zipper> https://www.reddit.com/r/haskell/comments/3sq913/ask_rhaskell_type_vs_newtype_as_it_applies_to/
12:12:19 <zipper> Plus I lose typeclass instances.
12:14:09 <zipper> WOW I wonder where everyone is.
12:14:26 <rvxi> hello zipper
12:14:39 <monochrom> to be sure, type is just as efficient
12:15:12 <monochrom> ah, I see one circumstance where newtype is inefficient
12:15:25 <monochrom> but even then I would still use newtype
12:16:01 <monochrom> but I really don't have any interest in discussing reddit
12:16:15 <monochrom> or twitter. or facebook
12:19:58 <zipper> monochrom: No I saw it on reddit
12:20:06 <zipper> and I really do like to use type.
12:20:32 <zipper> I'm not convinced that type is evil. I don't want to lose all the instances.
12:20:48 <zipper> Especially if I want to property test the thing.
12:21:20 <monochrom> I agree that nothing is evil
12:24:37 <zipper> I just don't see why newtype is so much better than type.
12:25:44 <monochrom> both statements "newtype is better than type for all things" and "type is better than newtype for all things" are going to be false. you understand that?
12:29:43 <zipper> monochrom: Yes I do but the conversation there implied that newtype is better.
12:29:58 <monochrom> then the conversation is BS
12:31:30 <monochrom> how often do reddit people use empirical data to support objectively measurable statements?
12:31:56 <monochrom> as opposed to using essay-writing contests?
12:32:57 <monochrom> do you believe a conclusion drawn on reddit just because the supporting evidence is an essay that would receive an A+ from an English teacher who knows English very well but nothing about the subject matter?
12:33:14 <monochrom> in fact, nevermind "believe". do you even give a dime?
12:33:25 <monochrom> I certainly don't.
12:35:25 <dmwit> zipper: I glanced briefly and didn't see anyone claiming type is less efficient.
12:35:41 <glguy> monochrom: Do you happen to have any empirical data on how often people do that?
12:35:52 <dmwit> (In fact, I don't see the string "effi" or "fast" anywhere on the page.)
12:35:55 <monochrom> no. but I am asking.
12:37:38 <monochrom> you can say, "don't be a weasel, you're clearly stating a rhetorical question"
12:38:26 <monochrom> yes, I admit it's a rhetorical question, I have already made up my mind based on very infrequency sampling. but I admit it's very infrequent.
12:39:17 <monochrom> however, you can always take my rhetorical question as a suggestion for a new direction, and start investigating yourself for your own good.
12:39:25 <zipper> dmwit: The first two?
12:39:57 <zipper> monochrom: Thanks
12:40:14 <zipper> I just don't want people reading my code to think it's bad.
12:40:55 <dmwit> zipper: There are several sort orders. Are the first two for you written by /u/sambocyn and /u/dagit?
12:41:22 <zipper> In other news, I'm looking for a type to represent a year. That is a 4 digit integer.
12:41:46 <monochrom> ah, but "people" is not a homogeneous consensus. "people" keep dividing into incompatible groups
12:42:33 <zipper> dmwit: Yes but it really doesn't matter, just that public opinion is skewed towards favouring newtypes.
12:42:48 <dmwit> zipper: The `time` package uses `Integer` for years. "Good enough for `time`" is pretty strong praise when it comes to handling dates/times.
12:42:48 <monochrom> in fact, "people" are ready to judge your code based on your choice of language only
12:43:02 <Saizan> monochrom: what about giving your two cents on when you prefer to use newtype vs. type instead of going meta like that?
12:43:16 <dmwit> zipper: My reading of those two comments doesn't include anything about efficiency.
12:43:42 <monochrom> Saizan, do you want to hear it? no one has really asked.
12:44:07 <MarcelineVQ> monochrom: I want to hear it
12:44:16 <zipper> monochrom: That's what I was asking.
12:44:19 <zipper> :D
12:44:25 <zipper> I wanted to know the why
12:44:31 <zipper> or when
12:44:40 <Saizan> monochrom: well, zipper kinda did, or at least brought some points on why he prefers type and wonders if there are valid counterpoints
12:46:07 <monochrom> in the short term, type is very convenient. in the long term, it is a leaky abstraction waiting to happen. or even worse, it is a failure in making up your mind "should it be an abstraction or not?" waiting to happen.
12:47:07 <orion> Is there syntactic sugar for "foo (x bar) (y bar)" so that I don't have to repeat "bar"?
12:47:39 <monochrom> but there is an exception. lens's "type Lens s t a b = forall Functor f. (a -> f b) -> (s -> f t)" is really better off as type because it enjoys (.). wrapping it in a newtype would suck.
12:47:58 <Iceland_jack> orion: 
12:47:58 <Iceland_jack> @pl \foo x y bar -> foo (x bar) (y bar)
12:47:58 <lambdabot> liftM2
12:48:22 <zipper> monochrom: For example I am making a financial thing. There are a lot of integers flying around. If I keep using them as ints they'll confuse me. So I have type synonyms such as Salary, Deduction, Allowance and so forth. Do you still think that is a leaky abstraction?
12:48:38 <monochrom> on the other front, the newtype wrapping can cause inefficiency when you will do "map Newtype_wrapper [a, b, c]". but recently GHC is doing things to eliminate that. one day it will not matter
12:50:07 * glguy is against using type synonyms as documentation, adding documentation to the arguments of functions is better for that
12:50:25 <glguy> with type synonyms as documentation I have to memorize all your type synonyms and what operations you expect them to use
12:50:35 <monochrom> is it even intended to be an abstraction?
12:50:57 <zipper> Not an abstraction more of documentation.
12:50:58 <fizruk> zipper: I would newtype Money, if you have multiple currencies, I would probably also use a phantom type parameter for that
12:51:06 <zipper> To help me know what I'm doing,.
12:51:20 <zipper> fizruk: Just one currency.
12:51:30 <glguy> I prefer to see type synonyms used to naming patterns in types rather than defining things to be treated as distinct types
12:52:05 <fizruk> zipper: + what glguy said about documentation
12:52:08 <monochrom> I sympathize with this use, given ghci's current feature and lack of
12:52:25 <zipper> fizruk: See I would have newtype Salary = Salary Int and I'd have to keep writing Salary 1000 when I want to create a salary value. That would be too much overhead. I'd rather use Ints as they are.
12:52:38 <fizruk> zipper: deriving (Num)
12:52:49 <monochrom> in ghci you can just ":type adjust" and get "Salary -> Deduction -> Salary" and you at once know the parameter order
12:52:56 <fizruk> zipper: with {-# LANGUAGE GeneralizedNewtypeDeriving #-}
12:53:59 <monochrom> whereas if you did it the ideal way, put it in docs and stick to Int, ":type adjust" would only tell you "Int -> Int -> Int". and you would have to hop over to a bloody web browser to read the doc. that would suck.
12:54:29 <glguy> There's a handy tool I used to use for getting the documentation in GHCi
12:54:39 <zipper> Yeah, monochrom and I wouldn't know which comes first the deduction or the salary.
12:54:40 <monochrom> one day, when ghci can finally display docs, you would not have this dilemma.
12:54:55 <liste> > let qux Foobar{bar=bar, baz=baz} in qux (Foobar 4 5) -- orion
12:54:57 <lambdabot>  <hint>:1:34: parse error on input ‘in’
12:55:06 <fizruk> zipper: you can still have `type Salary = Money` if you want
12:55:07 <liste> > let qux Foobar{bar=bar, baz=baz} = bar + baz in qux (Foobar 4 5) -- orion
12:55:08 <lambdabot>      ‘baz’ is not a (visible) field of constructor ‘Foobar’
12:55:19 <liste> orion you get the idea
12:55:29 <monochrom> meanwhile, manatee is an "IDE" that contains an editor, a web browser, and an irc client, precisely because of this :)
12:55:31 <glguy> http://hackage.haskell.org/package/haskell-docs
12:55:42 <liste> there's also -XNamedFieldPuns
12:56:05 <dmwit> glguy: oh, hey, neat
12:56:12 <monochrom> and now here is an answer to Saizan on why I went meta and spent more time there.
12:56:37 <monochrom> what I myself think of type and newtype doesn't bloody hell matter to zipper's application
12:57:02 <dmwit> glguy: This uses the user-installed haddocks?
12:57:26 <glguy> afaik
12:57:32 <bitemyapp> zipper: hey buddy
12:57:43 <zipper> fizruk: I haven't looked at GeneralizedNewtypeDeriving yet but I think that will solve my issue with deriving typeclasses of the newtype I create. However there's the overhead of creating a new value where I keep typing the data constructor, I guess I can live with that but I'd rather not.
12:57:47 <zipper> bitemyapp: Hello
12:58:04 <monochrom> instead, the meta position --- have faith in the merits and demirits you can measure, for your purpose, do not care abour reddit BS debates --- is the important one worth spending time on, and is the actually productive one.
12:58:14 <fizruk> zipper: Num instance should solve that
12:58:24 <bitemyapp> zipper: so what's up?
12:58:25 <fizruk> zipper: e.g. 123 :: Money will work
12:58:30 <dmwit> zipper: fizruk's language-lawyering point there was that 1000 can be given the type Salary if Salary has a Num instance. So no (explicit) constructor needed.
12:58:52 <dmwit> zipper: Of course, if you have something that's an Int and not a Salary, you'll still need to wrap it.
12:59:04 <dmwit> But 1000 is not (necessarily) an Int. ;-)
12:59:21 <zipper> bitemyapp: I think I have to go backa and replace all my type synonyms with newtypes.
12:59:28 <dmwit> Whoa, this is a new one: "cabal: InstallPlan: internal error: configured package depends on a non-library package"
12:59:37 <Saizan> monochrom: uh? oh come on, other programmers' experiences and knowledge are pretty important for these decisions. also, what would you actually measure here?
13:00:01 <zipper> dmwit: Yeah you shouldn't include executables in your depends.
13:00:25 <fizruk> zipper: I don't think that would be nice experience, since you won't be able to manipulate Salary, Deduction and Allowance with a simple arithmetic, you would have to unwrap all newtypes
13:00:38 <bitemyapp> zipper: well, you don't _have_ to, but it might be useful for type-safety.
13:00:48 <bitemyapp> zipper: did you make a mistake and mix up two different types somewhere?
13:00:50 <dmwit> Does chrisdone hang around here?
13:00:55 <bitemyapp> dmwit: not often
13:01:31 <fizruk> zipper: I think Salary, Deduction and Allowance should all have one type, probably newtype Money = Money Int
13:01:49 <zipper> bitemyapp: Not at all I just landed on an interesing question on reddit. https://www.reddit.com/r/haskell/comments/3sq913/ask_rhaskell_type_vs_newtype_as_it_applies_to/
13:02:08 <bitemyapp> zipper: well, I tend to use newtypes, not type synonyms.
13:02:20 <dmwit> fizruk: I'm not so sure Money is a good replacement for Salary, for the same reason Point and Vector are kind of different.
13:02:23 <bitemyapp> zipper: but I don't mind doing the work to make them nice to use.
13:02:57 <bitemyapp> zipper: Cf. https://github.com/bitemyapp/bloodhound/blob/master/src/Database/Bloodhound/Types.hs#L632-L774
13:03:12 <dmwit> glguy: Seems haddock is not a library any more. Makes haskell-docs hard to install!
13:03:28 <fizruk> dmwit: probably not exactly Money, but I imagine his types are used in a simple arithmetic with each other
13:04:11 <dmwit> Ah, the github repo claims to have a fix.
13:04:16 <fizruk> dmwit: btw I think Point and Vector are just type synonyms for the same reason I would make Salary, Deduction and Allowance type synonyms to Money
13:05:06 <dmwit> Many libraries make an explicit choice to have separate newtypes for Point and Vector. More on the rational here: http://math.ucr.edu/home/baez/torsors.html
13:05:13 <dmwit> s/rational/rationale/
13:05:47 <zipper> fizruk: Yeah I want to do simple arithmetic
13:06:17 <zipper> fizruk: Yeah but with newtypes I don't have to keep unwrapping. It does maintain it's type underneath.
13:06:56 <zipper> Arrgghhhhhh this is something only I can help myself with by reading more.
13:06:59 <fizruk> zipper: I have assumed you're mixing Salary, Deduction and Allowance in that arithmetic
13:07:36 <zipper> fizruk: Yes and many other ints given names to better document them.
13:08:12 <fizruk> zipper: because if you do, you can't do `salary - deduction + allowance` when you newtype everything
13:10:40 <zipper> fizruk: Why can't I?
13:10:49 <fizruk> :t (+)
13:10:51 <lambdabot> Num a => a -> a -> a
13:10:56 <fizruk> zipper: that's why ^
13:11:38 <fizruk> zipper: if salary :: Salary and allowance :: Allowance, you can't do salary + allowance (assuming Salary and Allowance and distinct newtypes)
13:14:28 <dmwit> Hum. ":doc +" -> "Addition of type-level naturals."
13:15:11 <fizruk> sort of true)
13:15:49 <dmwit> Yes, just worrying. If I remember this thing exists, I'm sure I'm going to get confused some day when it gives me a type-level doc and I wanted the term-level one (or vice versa).
13:16:07 <dmwit> Seems their :def suggestion could use a bit of work, too.
13:16:17 <dmwit> e.g. :doc <> is particularly unhelpful.
13:16:46 <sjfloat> Is there a chance that www.haskell.org's cert just expired?
13:17:00 <zipper> fizruk: I have to read on it on my own to know exactly what I need.
13:17:17 <sjfloat> my chrome's ok with it, but stack and wget no so much
13:18:24 <zipper> A type to represent a financial year.
13:18:31 <zipper> *?
13:18:41 <dmwit> I would steal my types from
13:18:42 <dmwit> ?hackage time
13:18:43 <lambdabot> http://hackage.haskell.org/package/time
13:19:12 <zipper> dmwit: I thought of doing that but a fiscal year is a range of a month and day.
13:19:38 <dmwit> Oh? Okay; I admit I know little about fiscal/financial years.
13:19:44 <dmwit> What does "range" mean here?
13:20:39 <zipper> Well a fiscal year is something like: 1 Aug to 31 July
13:20:53 <zipper> dmwit: ^
13:20:53 <dmwit> Can it just be 1 Aug?
13:21:04 <zipper> No, it has a start and end.
13:21:22 <dmwit> Okay. Perhaps just a pair of dates then.
13:21:30 <zipper> or I can add 12 months to it or 365 days. Just seems safer that way.
13:21:49 <zipper> When I know the start and end beforehand.
13:21:50 <dmwit> Perhaps put them in a record with descriptive names for the two parts.
13:22:52 <zipper> dmwit: I was thinking of using a tuple but a record is much better.
13:22:53 <orb_> Hi.  Does anyone know why curl (and by extension stack) doesn't like https://www.haskell.org/ 's certificate?
13:23:11 <thoughtpolice> This is a current problem with the SSL renewal, sorry
13:23:14 <thoughtpolice> orb_: ^^
13:23:18 <dmwit> zipper: For the components, I guess I would probably use Data.Time.Calendar.Day.
13:23:22 <sjfloat> orb_: I was just have that same trouble
13:23:29 <orb_> Oh, thanks.
13:23:33 <thoughtpolice> I'm on it now, I hope to have it fixed soon.
13:23:35 <orb_> Will it by hours or years to fix this?
13:23:39 <thoughtpolice> (Whenever my wifi stops acting up)
13:23:54 <sjfloat> orb_: believes in estimates :_
13:23:58 <sjfloat> :)
13:24:07 <orb_> (Ie I just want to have know the order of magnitude of the order of magnitudes estimate.)
13:24:16 <orb_> ;)
13:24:24 <orb_> Thanks for looking into it!
13:24:29 <sjfloat> Yes, as do I
13:24:41 <dmwit> > 10^10/365/24/60
13:24:43 <lambdabot>  19025.87519025875
13:25:15 <dmwit> So, yeah, I wouldn't be surprised if the correct order of magnitude of order of magnitudes is 1, i.e. somewhere between one minute and 19000 years
13:25:26 <thoughtpolice> The weird thing is the new cert for https://haskell.org actually works fine. www. doesn't though
13:25:31 <orb_> thoughtpolice: if you have connectivity problems, mosh beats ssh.
13:25:40 <thoughtpolice> (Don't ask, it's one of the weird ass things with our infrastructure we need to fix)
13:25:46 <sjfloat> thoughtpolice: I don't envy you
13:25:57 <orb_> Chrome also like https://www.haskell.org/, but curl doesn.t
13:26:02 <thoughtpolice> Oh, I've been a mosh user since the first release. :) The wifi problem is more 'the wifi does not work'
13:26:12 <sjfloat> right, chrome's OK
13:26:19 <thoughtpolice> Which mosh can't fix. Anyway, I hope to fix it soon, let me see...
13:26:24 <sjfloat> It's stack that's giving me grief
13:27:08 <orb_> sjfloat: And stack's using curl, I believe.
13:27:11 <fizruk> dmwit: torsors look interesting, I have never heard of them before, thank you for sharing!
13:27:12 <zipper> thoughtpolice: Which country?
13:27:32 <dmwit> fizruk: =)
13:28:19 <sjfloat> orb_: I could neither confirm nor deny
13:28:25 * frerich reads about 'maximum (1024, 0)' vs. 'maximum (0, 1024)' and chuckles
13:28:50 <koshmar> there is System.Random and there is Control.Monad.Random. I am a bit confused, what are there difference and what to choose, why there are two options...
13:29:37 <dmwit> System.Random provides an algorithm for generating pseudo-random sequences. MonadRandom offers a nice interface for using that algorithm to create structured pseudo-random data.
13:30:11 <dmwit> (This is a first approximation of the truth.)
13:30:27 <koshmar> what is better to choose?
13:30:32 <dmwit> mu!
13:30:32 <orb_> Have people actually investigated spliting random generators more?
13:30:42 <glguy> thoughtpolice: as a datapoint, my curl and stack are perfectly happy with the new certificate (didn't read much backlog, might not be helpful)
13:30:44 <orb_> Splitting.
13:30:45 <dmwit> orb_: I don't think so.
13:31:04 <geekosaur> it will depend on whether you have the intermediate certificate in your local certificate data store
13:31:04 <orion> Hey, does anyone know why I'm getting a type error here?: http://lpaste.net/3031658775334354944
13:31:08 <thoughtpolice> There was a paper on using cryptographic hashing for deriving splittable psuedo random generators
13:31:09 <hpc> koshmar: whichever one does what you need
13:31:12 <thoughtpolice> From ICFP 2013 I think
13:31:27 <geekosaur> chrome does; apparently some certificate stores for use with curl do; firefox doesn't
13:31:29 <thoughtpolice> http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf
13:31:57 <orb_> dmwit: it seems logically the right thing for (lazily( creating tree-like structures or computations, and practically it would have made our monte carlo simulations so much easier to parallelize in my last job.
13:32:08 <fizruk> orion: missing forall in type and ScopedTypeVariables?
13:32:15 <geekosaur> orion, the fact tht you're using :: HandshakeState c d h makes me think ... yes
13:32:34 <geekosaur> tyou're assuming those came from the sifgnature. they don't, they;re completely new type variables and will not match each other or the signature
13:32:36 <hpc> koshmar: that'll likely end up being System.Random, unless you're using lots of transformers and want the flatness of MonadRandom
13:33:18 <geekosaur> ScopedTypeVariables extension and declaring those as scoped with a forall in the top level type signature will give you what you are expecting
13:33:19 <fizruk> orion: wait, c and h are used only in constraints, I don't think GHC will be able to disambiguate those
13:33:40 <geekosaur> mm, maybe
13:34:10 <geekosaur> yeh, I don't see where it would be able to figure those out
13:34:27 <fizruk> orion: so I suspect you need to tell also where those come from with, e.g. Proxy, or specify them to be some particular types
13:34:44 <geekosaur> unless it can somehow get that from the type of noiseNNIHS / noiseNNIRS and the type HandshakeKeys d
13:35:07 <fizruk> orion: or maybe you are just missing some parameters parametric in c and h :)
13:36:41 <sjfloat> thoughtpolice: if it matters (and I doubt it does) my docker builds on docker hub are also having the cert problem
13:36:58 <sjfloat> that's actually what tipped me off
13:38:32 <dmwit> orion: Probably instead of typeclasses for Cipher and Hash, you just want data types for them.
13:39:28 <dmwit> e.g. instead of `class Cipher c where type Key c; enc :: k -> c -> Bytes -> Bytes` or something you would write `data Cipher k where Cipher { enc :: k -> Bytes -> Bytes }`.
13:39:57 <dmwit> uh
13:40:11 <dmwit> `data Cipher k = Cipher { enc :: k -> Bytes -> Bytes }`, I mean.
13:43:17 <orion> dmwit: Unfortunately that's not something I can do.
13:43:50 <orion> If I change the type signature to mkHandshakeProp :: forall c d h. (Cipher c, Curve d, Hash h) I get "Could not deduce (Cipher c0) from the context (Cipher c, Curve d, Hash h)"
13:44:15 <glguy> orion: Are you trying to use scoped type variables?
13:44:24 <geekosaur> did you enable the ScopedTypeVariables extension?
13:44:44 <orion> It's enabled.
13:45:13 <geekosaur> then the problem is that it doesn't know enough to combine them, as fizruk and I tried to explain
13:46:20 <geekosaur> you do not provide enough type information for it to confirm that they will be the expected types, so it must assume they aren't
13:46:30 <fizruk> a bit strange though that c0 is not c, but must be for the same reason
13:46:47 <geekosaur> it's generating a new type variable because it doesn't have enough information to unify them
13:47:09 <fizruk> I thought forall should unify them
13:47:24 <geekosaur> no
13:47:45 <fizruk> well logically it should, no?
13:48:04 <geekosaur> forall makes the type variables c, d, h available. it cannot help with the fact that noiseNNIHS and noiseNNIRS do not take them as parameters in any visibl;e way, only return a type using them
13:48:34 <geekosaur> all the ocmpiler can do is assume they are not unifiable with the c, d, h in scope
13:48:50 <orion> Here's my overall goal: In my unit tests I find myself repeating a lot of code often. I want to generalize the functions. Here is what I'm working with: http://lpaste.net/8092974801037033472
13:49:07 <geekosaur> because those are the only places those type variables are used
13:49:20 <geekosaur> well, c and h
13:49:35 <geekosaur> d has additional uses and probably can be unified. c and h are dangling
13:49:52 <orion> My goal is to be able to specify the types in the 'tests' function, that way I don't have to copy and paste large chunks of code, one for each type.
13:50:51 <fizruk> geekosaur: well, noiseNNIHS and noiseNNIRS do receive c and h implicitly with the whole function that's what forall does — it is kind of an explicit type lambda
13:50:52 <orion> I'm working with three parameters here: Cipher, Curve, and Hash. I want to unit test every combination of them, but I don't want to copy/paste huge chunks of code and do a find/replace for the types.
13:51:04 <geekosaur> HandshakeState isn't defined there
13:51:56 <orion> http://hackage.haskell.org/package/cacophony-0.3.0/docs/Crypto-Noise-Handshake.html#t:HandshakeState
13:52:00 <orion> HandshakeState ^
13:52:06 <geekosaur> fizruk, um? they are not implicit parameters, the only way those functions "receive" them is via the expected type. there still isn't enough information though, from what I can see
13:52:10 <glguy> Have we already covered using proxys to pass the types in?
13:53:19 <fizruk> orion: shouldn't you use ihs rhs instead of defining nni nnr ?
13:53:38 <lysgaard> Is it possible to use the Lens library to map over a certain field of a certain variant in a recursive ADT where the field is not present in the leafs of the ADT?
13:53:51 <orion> fizruk: No. There's ~20 different handshake types.
13:54:11 <orion> NN, KN, NK, ...
13:54:28 <fizruk> orion: then you probably need to pass c and h via Proxy to mkHandshakeProp
13:55:01 <fizruk> orion: mkHandshakeProp :: forall c d h. Proxy c -> Proxy h -> <the rest of your type>
13:55:07 <thoughtpolice> Yay
13:55:22 <orion> What if I changed the definition of HandshakeType to "data HandshakeType c d h = ..." ?
13:55:25 <fizruk> orion: mkHandshakeProp _ _ ht hks _ = <your definition as is>
13:55:32 <thoughtpolice> orb_: OK, I figured out what was wrong, so I have to keep updating the certs. Should be easy now though.
13:55:44 <thoughtpolice> orb_: Can you make sure exactly what domain name stack fails on? That would be really useful
13:55:48 <fizruk> orion: that should also work, I think
13:55:51 <thoughtpolice> So I can go ahead and make sure it's fixed first.
13:56:28 <orb_> thoughtpolice: Looking at it.
13:56:41 <thoughtpolice> www.haskell.org should be good now, FWIW
13:56:43 <thoughtpolice> If you curl -v it
13:56:56 <lpaste> glguy pasted “for orion” at http://lpaste.net/145328
13:56:56 <orb_> stack no longer complains.
13:57:08 <thoughtpolice> Well, that's good :)
13:57:10 <glguy> orion: You could do a version what I just pasted to test all of your 3 type classs
13:57:15 <glguy> at every combination of instances
13:57:24 <orb_> Earlier on, it was (if memory serves right) www.haskell.org
13:57:42 <glguy> orion: You'll just need to add proxy arguments to your test case for the ambiguous types
13:57:50 <fizruk> geekosaur: here the only way x receives type is via the expected type: f :: forall a. IsString a => a -> Int; f = length x where x = "hello" :: a
13:57:59 <thoughtpolice> orb_: Great.
13:58:08 <orb_> thoughtpolice: Thanks for fixing it!
13:58:23 <orion> glguy: Very interesting.
13:58:31 <lpaste> Lokathor pasted “No title” at http://lpaste.net/145329
13:58:33 <sjfloat> thoughtpolice: thanks! verfied with wget 
13:58:36 * hackagebot geo-uk 0.1.0.0 - High precision conversion between GPS and UK Grid  https://hackage.haskell.org/package/geo-uk-0.1.0.0 (tolysz)
13:58:46 <Lokathor> what is this error message trying to tell me?
13:58:53 <fizruk> geekosaur: the only thing connecting a in f's type and a in x's type is the forall, those types are not *unified*, they are the same type variable brought to scope by the forall
13:58:58 <Lokathor> the Saw and Expected values seem the same to me
13:59:03 <fizruk> geekosaur: please correct me if I am wrong :)
13:59:28 <thoughtpolice> sjfloat: Great, thanks.
13:59:36 <sjfloat> trying stack now
14:00:07 <sjfloat> yep! looks good
14:00:15 <sjfloat> thoughtpolice: thanks again!
14:00:19 <thoughtpolice> np
14:00:36 <thoughtpolice> Also, Chrome can go to hell for not caring about intermediate certs.
14:00:56 <glguy> You mean having them preloaded?
14:00:58 <fizruk> geekosaur: and if I am right, that is the reason I was surprised with c0 being a separate variable (not c)
14:02:35 <thoughtpolice> I mean, I guess? The thing is, if most other things are going to fail on it, it seems almost a bit 'deceptive' to give the allusion it 'works'. Even though deception is clearly not the intention (rather it's to be less error prone, as this exercise shows).
14:02:59 <dmwit> Lokathor: capitalization
14:03:52 <orb_> thoughtpolice: I happen to work for Google at the moment.  Is there anything I should forward to the Chrome team?
14:03:53 <Lokathor> dmwit, ah, damn
14:04:09 <glguy> thoughtpolice: Perhaps they do it to pin them as a security feature?
14:05:12 <thoughtpolice> orb_: No, I'm just being my usual grumpy self. :) I mean, I have no suggestions to fix and at a glance it's really a security UI problem that's a bit hard to pin down.
14:05:20 <orb_> OK.
14:05:54 <thoughtpolice> Because if a site doesn't serve an intermediate, that's not necessarily wrong if it's preloaded. But if it's not there, do you just continue like nothing was wrong or give some indication? Users don't understand all the dimensions and complexity involved so I can understand why Chrome does this.
14:06:14 <thoughtpolice> I'm just grumpy because I tested it with Chrome and nothing else, so it deceived me a bit. So really I'm sort of to blame :P
14:06:52 <thoughtpolice> glguy: Yes, I'd imagine it's something like that. I'm sure there's a good reason involved, they take that stuff seriously.
14:07:45 <thoughtpolice> In any case, next time I'll just add curl to the top of the checklist when we renew next year.
14:07:46 <thoughtpolice> :)
14:08:05 <geekosaur> the ssl test postd earlier noted that it could verify it by downloading the intermediate cert itself
14:08:17 <geekosaur> perhaps chrome is also doing that but most browsers don't?
14:08:52 <begriffs> Anyone know how to reinstall my package dependencies in Stack so that they have profiling information enabled?
14:09:44 <begriffs> Enabled profiling in my app and when running "stack build" it complains about each dependency: "Perhaps you haven't installed the profiling libraries for package [foo]"
14:10:39 <kadoban> begriffs: How have you enabled profiling in your app? With the flags to 'stack build' ?
14:10:50 <begriffs> Nevermind it was only a stackoverflow search away...doh. http://stackoverflow.com/a/32130002
14:11:23 <begriffs> Which means I probably don't have to even modify the ghc-options in my cabal file. Pretty cool.
14:13:37 * hackagebot geo-uk 0.1.0.1 - High precision conversion between GPS and UK Grid  https://hackage.haskell.org/package/geo-uk-0.1.0.1 (tolysz)
14:14:10 <Zemyla> Oh, edwardk, I found someone who came up with a much faster encoding of free applicatives than is currently in the free package. Should I submit an issue, or try and submit a pull request with the new modules for the package?
14:17:07 <tommd> thoughtpolice: You're thinking of the paper behind the tf-random package.
14:17:16 <thoughtpolice> Yep
14:17:23 <thoughtpolice> It's a good paper, I enjoyed the presentation at ICFP
14:19:07 <nissimlavy> thoughtpolice: link to paper?
14:19:25 <thoughtpolice> http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf
14:20:09 <nissimlavy> Thank you
14:21:31 <glguy> Zemyla: If you're in the market for a free applicative type you might check out the type called 'Boggle' here: http://www.galois.com/~emertens/generic-traverse-0.1-docs/Boggle.html
14:21:43 <glguy> Zemyla: It's an "optimizing" free applicative
14:21:50 <bitemyapp> glguy: optimizing?
14:21:59 <bitemyapp> glguy: like codensity or something else?
14:22:15 <glguy> like that but a bit more
14:22:36 <glguy> eliminates pures where it can, fuses fmaps to a single one if one is needed, reassociates the <*>s
14:23:15 <Zemyla> No, it's even better. It's Church-encoded, and doesn't have to retraverse its Aps.
14:23:25 <Zemyla> http://www.eyrie.org/~zednenem/2013/06/freeapp-2
14:23:29 <glguy> Zemyla: this one doesn't retraverse
14:23:37 * hackagebot pandoc 1.15.2 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.15.2 (JohnMacFarlane)
14:26:44 <glguy> Zemyla: Mine is specifically designed to not be recursive so that it inlines away. The link you shared is quite interesting to me, thanks :)
14:26:46 <Zemyla> And it's fairly trivial to extend the technique there to include Alternatives, including left reassociation of them.
14:27:19 <glguy> I'm using it to simplify applicative computations generated with GHC.Generics to enable the generics to inline away
14:27:26 <glguy> where they otherwise could not
14:27:39 <Zemyla> In the type C2, add the constraint (Monoid z) to the forall.
14:32:49 <glguy> The representation compiles away so you're left to the equivalent of the hand-written expressions, it's been fun to play with
14:35:31 <eikke> hvr: trying to get a repo with TravisCI to work, using your GHC PPA. Problem: Travis is Precise based, I'm using your GHC 7.10.2 packages, my packages uses LLVM, the Travis env seems to have LLVM 3.4 installed, and compilation fails badly. Any prior experience or pointers?
14:51:48 <orb_> Can stack ask for non-Haskell dependencies?
14:57:54 <Pamelloes> Is there an Alternative instance for (a -> Alternative b)?
14:59:01 <jle`> Pamelloes: do you mean Alternative f => (a -> f b) ?
15:00:08 <Pamelloes> I'm not quite sure.... I have two functions (ByteString -> Maybe Text) that I would like to combine the results per <|>
15:00:19 <lyxia> Alternative m => Alternative (ReaderT r m) exists
15:00:34 <Taneb> :t liftA2 (<|>)
15:00:38 <lambdabot> (Applicative f, Alternative f1) => f (f1 a) -> f (f1 a) -> f (f1 a)
15:00:41 <Zemyla> Pamelloes: http://hackage.haskell.org/package/transformers-0.4.3.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT
15:01:04 <Taneb> :t liftA2 (<|>) :: (ByteString -> Maybe Text) -> (ByteString -> Maybe Text) (ByteString -> Maybe Text)
15:01:05 <lambdabot>     Not in scope: type constructor or class ‘ByteString’
15:01:06 <lambdabot>     Perhaps you meant one of these:
15:01:06 <lambdabot>       ‘BSC.ByteString’ (imported from Data.ByteString.Char8),
15:01:15 <jle`> ReaderT r m a is a newtype wrapper over r -> m a, and it does have an Alternative instance if m is alternative
15:01:23 <Taneb> :t liftA2 (<|>) :: (a -> Maybe b) -> (a -> Maybe b) -> (a -> Maybe b)
15:01:25 <lambdabot> (a -> Maybe b) -> (a -> Maybe b) -> a -> Maybe b
15:01:37 <Taneb> Pamelloes, you could liftA2 (<|> function1 function2
15:01:38 <jle`> but yeah, using a newtype wrapper just to get an Alternative instance imight be a bit overkill here
15:01:53 <Pamelloes> Taneb: That looks like what I'm looking for :)
15:01:59 <jle`> potentially relying on typeclasses when normal ol' functions can be just what you need
15:02:13 <jle`> :t \fs -> asum . sequence fs
15:02:15 <lambdabot> (Traversable t, Alternative f) => t (a -> f a1) -> a -> f a1
15:02:24 <jle`> :t \fs -> asum . sequence fs :: [a -> Maybe b] -> a -> Maybe b
15:02:25 <lambdabot>     Couldn't match expected type ‘t0 ([a1 -> Maybe b1]
15:02:25 <lambdabot>                                       -> a1 -> Maybe b1)’
15:02:25 <lambdabot>                 with actual type ‘r’
15:02:51 <jle`> :t (\fs -> asum . sequence fs) :: [a -> Maybe b] -> a -> Maybe b
15:02:51 <Zemyla> jle`: It's important for central typeclasses like Alternative.
15:02:53 <lambdabot> [a -> Maybe b] -> a -> Maybe b
15:02:59 <jle`> Zemyla: what is important?
15:03:09 <jle`> having ReaderT is useful because you can use Alternative combinators yeah
15:03:12 <jle`> but sometimes it's not worth the hassle
15:03:15 <jle`> when you can just use normal functions
15:03:47 <jle`> with the ReaderT newtype wrapper, you can use (<|>) instead of liftA2 (<|>)
15:03:53 <jle`> if you do a lot of <|>'s, then yeah, it's useful
15:03:59 <jle`> but if you only do it once, it's probably not worth the hassle :)
15:04:06 <jle`> that's like doing:
15:04:09 <jle`> > Sum 1 <> Sum 2
15:04:11 <lambdabot>  Sum {getSum = 3}
15:04:11 <jle`> instead of
15:04:13 <jle`> > 1 + 2
15:04:15 <lambdabot>  3
15:04:26 <jle`> i mean...you can.  but in most cases it's simpler to just use +
15:08:44 <Pamelloes> There's no monoid  instance for Either :(
15:09:46 <Pamelloes> On second thought, I guess it makes sense.
15:10:19 <Zemyla> Pamelloes: That's because what would mempty be?
15:10:57 <begriffs> I'm profiling my program with +RTS -h but it appears to collect information for only a fraction of a second. How do I get the profiler to continue recording information?
15:11:59 <pavonia> And what mappend?
15:11:59 <Zemyla> glguy: I figured out how to extend the C2 free applicative to being a free alternative.
15:19:08 * hackagebot clanki 1.2.6 - Command-line spaced-repetition software  https://hackage.haskell.org/package/clanki-1.2.6 (marcusbuffett)
15:19:20 <Pamelloes> I'm getting an error " Unexpected semi-colons in conditional" and then citing a line of my code where the compiler has inserted a semicolon but there is none in the actual source.
15:19:25 <Pamelloes> What's going on?
15:19:51 <geekosaur> do syntax + indentation mismatch; that's what would lead to inserted semicolons
15:19:56 <geekosaur> @paste your code?
15:19:56 <lambdabot> Haskell pastebin: http://lpaste.net/
15:21:15 <geekosaur> (let syntax also does semicolon insertion)
15:22:02 <geekosaur> basically layout desugars to uses of { ; } and if you get your indentation wrong it will mis-insert a ; and then complain about the error. there are probably better ways to report it...
15:23:04 <lpaste> Pamelloes pasted “Semicolon Issue” at http://lpaste.net/145333
15:23:27 <Pamelloes> There's my code (more or less). The issue is in the if/then line.
15:24:03 <geekosaur> ok, the problem there is that it is inserting a ; before the else because it is at the same indentation level as the if
15:24:38 <Pamelloes> Yep, that fixed it :)
15:24:57 <Pamelloes> Thanks!
15:25:05 <geekosaur> this is a fairly common "gotcha" with if-then-else in do
15:25:47 <glguy> There's even an extension in GHC to change it
15:27:42 <orion> glguy: I appreciate your help earlier. This is my solution: https://github.com/centromere/cacophony/blob/master/tests/Handshakes.hs
15:38:07 <glguy> orion: You might add an upper bound on your cryptonite dependency, you don't appear to support 0.8 (latest)
15:40:12 <nissimlavy> I’m a bit new to Haskell development. Do you guys have a recommended editor/IDE, possibly with code formatting?
15:43:32 <Hafydd> notepad, lol
15:43:41 <Pamelloes> vim :)
15:44:09 * hackagebot yesod-transloadit 0.6.0.0 - Transloadit support for Yesod  https://hackage.haskell.org/package/yesod-transloadit-0.6.0.0 (boblong)
15:44:14 <nissimlavy> I use vim but since I’m pretty new to the language, I’m not quite sure on formatting. Is there some styleguide?
15:46:01 <derekv> so if I do "let x = 1" and then ":t x", I get Num a => a, but Num isn't really a concrete type... it seems I can get an int or a float out of x now depending on context
15:54:09 * hackagebot yesod-transloadit 0.7.0.0 - Transloadit support for Yesod  https://hackage.haskell.org/package/yesod-transloadit-0.7.0.0 (boblong)
15:54:53 <geekosaur> derekv, that's what "Num a => a" means; it can be any type that has a Num instance defined
15:55:38 <geekosaur> (note that the compiler wraps a numeric literal in fromRational or fromInteger depending on whether it has a decimal point or not)
15:57:46 <orion> glguy: Indeed. Unfortunately my PR's have yet to be accepted.
15:58:13 <orion> I really wish Vincent would accept them and release a version soon.
15:58:24 <derekv> geekosaur: I see, thanks.  I don't know why, buy I'm finding doing basic arithmetic stuff not allways as easy as initially expected. Mostly around all the numeric types and finding the right functions (even with hoogle)
15:58:31 <lpaste> glguy pasted “for orion” at http://lpaste.net/145335
15:58:52 <glguy> orion: That version cuts out some of the duplication
15:58:53 <geekosaur> derekv, it could be worse without this; you'd need to use the right version of addition for the type
15:59:04 <derekv> (doesn't help when I try to use mod as an infix without backquotes)
15:59:09 <orion> glguy: Nice! Thank you.
15:59:19 <geekosaur> but because of the Num typeclass, (+) can pick the right one itself instead of forcing you to do it
15:59:50 <geekosaur> div is admittedly something of a special case, but it was adjudged to be bad to have one variant of (/) produce fractions and another silently drop them
16:00:52 <derekv> geekosaur: right... but it's not really coercion like you see in other languages, I don't think.  Trying to get an feel for it still 
16:02:12 <geekosaur> right; Haskell doesn't do either implicit coercion or casting, if you want a different type you must explicitly call a function to do it. (the handling of numeric literals being the special case there, but again forcing you to annotate your literals with types to do anything at all was considered Bad)
16:02:30 <lmj> does hlint warn about superfluous constraints? I realize one might want to overconstrain, but sometimes there is dead weight, such as having Floating and Fractional.
16:02:49 <lmj> I can't build src-exts currently so can't test it
16:03:33 <geekosaur> hlint only does things it can work out from syntax; types are mostly beyond it
16:04:23 <glguy> lmj: GHC-HEAD can warn about redundant constraints. I don't think 7.10 does, though
16:04:33 <geekosaur> (this means there are some screw cases where it thinks you should use something else, but because of types you need to do it the way you are)
16:04:45 <lmj> k thanks
16:04:48 <rvxi_> has anyone tried ghc strict yet?
16:11:47 <lmj> When was the last time haskell-src-exts compiled? There are some pretty old google hits on this error I have.
16:11:59 <lmj> (needed for hlint)
16:12:14 <carter_cloud> Ralith: you mentioned raft?
16:12:19 <carter_cloud> iddn't see the pring
16:14:51 <glguy> lmj: The current version compiles on the current GHC with current dependencies
16:15:07 <glguy> Maybe you're trying an older version or against older deps
16:15:32 <geekosaur> you probably want to use the one from its github repo, not from hackage
16:15:33 <lmj> glguy: I'm running a freshly compiled ghc-7.10.2 with brand new cabal
16:15:42 <geekosaur> which was last updated last year
16:16:01 <geekosaur> (the hackage one, that is; most recent commit to the repo seems to have been 16 hours ago)
16:16:02 <glguy> 1.16.0.1 (latest) builds for me, you might post the error you're getting
16:20:56 <lmj> src-exts error http://lpaste.net/145338
16:21:12 <glguy> lmj: Update your happy
16:26:01 <lmj> glguy: this is a fresh cabal tree; maybe yours works because it's older? I have happy-1.19.5 (latest).
16:26:17 <lmj> I reinstalled happy to verify, got the same error
16:26:31 <geekosaur> you should check $PATH
16:26:55 <glguy> lmj: You're still getting the happy error, start with geekosaur's suggestion
16:27:07 <geekosaur> since cabal will install happy to ~/.cabal/bin or Windows / OS X equivalent, and if that's not on your $PATH then it will still find the old one
16:27:50 <lmj> geekosaur: ah thanks, 'which happy' gives me an old /usr/bin/happy, not the newest
16:29:10 * hackagebot MemoTrie 0.6.3 - Trie-based memo functions  https://hackage.haskell.org/package/MemoTrie-0.6.3 (ConalElliott)
16:31:52 <lmj> I hope the long term goal is to use happy as a library instead going through an exe, which is a bit fragile.
16:32:03 <Ralith> carter_cloud: what?
16:32:33 <carter_cloud> saw mention in scrollback about the raft thing i did a while ago
16:32:38 <carter_cloud> i should make the github repo public
16:32:45 <carter_cloud> its not terribly useful though
16:33:11 <lpaste> tippenein pasted “libHSexceptions compilation error” at http://lpaste.net/145339
16:34:10 <tippenein> anyone have insight on this build error? I think it has something to do with my upgrade to El Capitan, but that's only because what I'm building worked before the "upgrade"
16:35:50 <glguy> tippenein: Looks like the dynamic library is missing, so you might have to reinstall it. YOu make take a look at the output of "ghc-pkg check" to see how bad things are
16:36:57 <glguy> make/might
16:37:16 <geekosaur> I don't think so? it's using the @rpath stuff, and IIRC the Platform had some bugs in how it was doing that on OS X
16:42:47 <tippenein> geekosaur: that sounds familiar to the problems i had with ruby libs as well
16:46:47 <lmj> The latest happy version is in my path, which I verfied via "happy --version" => Happy Version 1.19.5 Copyright... Unfortunately it's still the same error. Maybe cabal is somehow still getting the old happy?
16:49:21 <glguy_> That or is not reprocessing the .y file
16:54:11 <Zemyla> I'm looking at uu-parsinglib, and it really doesn't feel like Haskell at all when I'm looking at it.
16:58:40 <lmj> is there an option to "ghc-pkg check" that will make ghc unregister/forget packages that are broken?
16:58:43 <bind> small question (newb) question; within monads, is there a common concept for branching/conditions or the like? I mean for example that the kind of computation to be executed depends on the outcome of a previous one. (I would guess so ... but you never know)
17:00:17 <pavonia> bind: There are if and case expressions
17:01:42 <Hafydd> The property of allowing "the kind of computation to be executed depends on the outcome of the previous one" is what distinguishes Monad from Applicative.
17:01:51 <Cale> bind: Think about what (>>=) means: x >>= f is the computation which when executed, will first execute x, and then if the result of x is v, it will then execute f v. (Of course, the meaning of "execute" and "then" somewhat depends on the choice of monad)
17:02:09 <Cale> bind: So essentially f gets to determine what to do next, based on the result of x
17:03:00 <bind> thank you and case and if for example can branch the flow. I see :)
17:03:23 <Cale> yeah
17:03:33 <bind> great
17:03:47 <bind> thank you pavonia, Hafydd and Cale 
17:03:48 <Cale> In do-notation, you might write something like   do v <- foo; case v of ...
17:05:32 <lmj> bind: the Maybe monad might be illuminative (assuming that's a word)
17:06:21 <Hafydd> It will be illuminating... maybe.
17:06:57 <glguy> illuminative came up with I right clicks on "look up word" at least
17:09:50 <abbe> hi
17:10:41 <abbe> With Network.HTTP module loaded, in ghci, when I do: (simpleHTTP (getRequest "http://localhost:81/")) >>= (\r -> case r of Left _ -> putStrLn "Error"; Right _ -> putStrLn "Alright!")
17:10:53 <abbe> I get: *** Exception: connect: does not exist (Connection refused)
17:11:27 <bind> glguy: it is a word actually .. illuminative seems to describe nouns, while illuminating describes verbs
17:11:59 <abbe> I was hoping to get the error in "Left _"
17:12:32 <bind> I will have a look lmj 
17:12:35 <glguy> abbe: You can use Control.Exception.try to get the IOException in a Left
17:14:12 <abbe> glguy: but as per Network.HTTP documentation, "simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))", and "type Result a = Either ConnError a"
17:16:16 <abbe> so my question shouldn't this already be handled by library
17:17:44 <xpilot> anyone know why type-level strings aren't represented as type level lists of type-level chars?
17:18:02 <Zemyla> xpilot: No idea. I've been asking that oo.
17:19:51 <xpilot> I understand why type-level nats might not be represented by the standard unary Nat = Z | S Nat (you can do the conversion yourself at any rate)
17:20:11 <xpilot> but value-level strings are just [Char]...
17:20:37 <hasenov> hello, I have a string coming in as Text that has double quotes around it, and I want to get rid of those double quotes with Data.Text's dropAround
17:20:47 <hasenov> i have this:
17:21:20 <hasenov> dropAround (\a -> a == '"') myText
17:21:47 <hasenov> and its not dropping the double quotes at the beginning and the end
17:22:08 <abbe> maybe the library doesn't put connect() code in the exception handler block :/
17:22:14 <hasenov> is there something im doing wrong?
17:22:47 <glguy> abbe: That'd be a reasonable assumption to make, and you might want to file an issue about it on GitHub, but it's not how it works at the moment
17:23:13 <hexagoxel> hasenov: "dropAround p t returns the substring remaining after dropping characters that ____fail____ the predicate p"
17:23:17 <abbe> thanks for checking, glguy
17:24:12 * hackagebot th-cas 0.1.0 - Compile-time CAS(Computer Algebra System)  https://hackage.haskell.org/package/th-cas-0.1.0 (junjihashimoto)
17:28:06 <MarcelineVQ> hasenov: dropAround (=='"') "\"\"bl\"efdsg\"\"\"" gives "bl\"efdsg", it's dropping all the " at the edges for me
17:30:26 <hasenov> MarcelineVQ: yeah, i guess its working as a literal string, when typed into ghci, for some reason it doesnt work when I get the Text from a Post parameter in Spock web framework
17:30:45 <hasenov> MarcelineVQ: thats pretty much what I want to do, lol
17:31:31 <hasenov> i guess i could just use drop  and  dropEnd but makes it more messy
17:34:12 * hackagebot xcffib 0.4.0 - A cffi-based python binding for X  https://hackage.haskell.org/package/xcffib-0.4.0 (TychoAndersen)
17:34:44 <hexagoxel> hasenov: oh sorry, it seems i quoted wrong documentation; i did not check :/
17:35:29 <hexagoxel> is that documentation correct? what do you say, rest of chat?
17:37:26 <codebje> hm, meijier claimed in an fp101 lecture that [a] is idiomatic for 0 or 1 values rather than Maybe a
17:37:35 <codebje> have I been doing it wrong, or is this just a bit out of context?
17:37:50 <hasenov> hexagoxel: yeah, i was confused by it too
17:38:16 <hasenov> but then strip is defined as "dropAround isSpace"
17:39:13 <hasenov> hexagoxel: so It should read  returns the substring remaining after dropping characters that pass the predicate p, i think
17:39:25 <hexagoxel> hasenov: are you sure your input contains the '"', and it is not merely an artefact of printing?
17:40:01 <hexagoxel> what is Text.head yourRawText ?
17:41:00 <hasenov> hexagoxel: well, i am using (show myText) so I can print it out using putStrLn
17:41:30 <hexagoxel> > show (pack "abc")
17:41:31 <lambdabot>      Not in scope: ‘pack’
17:41:31 <lambdabot>      Perhaps you meant one of these:
17:41:32 <lambdabot>        ‘BS.pack’ (imported from Data.ByteString),
17:41:36 <hexagoxel> > show (T.pack "abc")
17:41:38 <lambdabot>      Not in scope: ‘T.pack’
17:41:38 <lambdabot>      Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
17:41:41 <hexagoxel> > show (Text.pack "abc")
17:41:43 <lambdabot>  Not in scope: ‘Text.pack’
17:42:12 <hexagoxel> grr
17:42:16 <hexagoxel> anyway, use unpack
17:42:25 <hexagoxel> show adds '"' around
17:42:32 <hexagoxel> hasenov: ^
17:45:25 <hexagoxel> or use Data.Text.IO.putStrLn
17:47:55 <hasenov> hexagoxel: thanks, i think thats what i was doing wrong, I did a show to convert it to String
17:50:25 <david__> Haskell begginer here, can anyone explain me why curry id has type curry  a -> b -> (a, b) ?
17:50:44 <hexagoxel> :t curry
17:50:45 <lambdabot> ((a, b) -> c) -> a -> b -> c
17:51:36 <david__> but type of id isn't (a,b) -> a
17:52:00 <david__> that's why im confused
17:52:11 <hexagoxel> if the "first parameter" `(a,b) -> c` should unify with id's type "d -> d", you get d==c==(a,b)
17:53:06 <hexagoxel> (i applied an offset to the type variable in `d -> d`, to avoid the double binding
17:53:13 <MarcelineVQ> :t id (,)
17:53:14 <lambdabot> a -> b -> (a, b)
17:53:47 <hexagoxel> david__: the types don't need to be equal, they just need to unify
17:53:57 <hexagoxel> and they do
17:55:59 <hexagoxel> david__: effectively, in `curry id` there is `id :: (a,b) -> (a,b)` and `curry :: ((a,b) -> (a,b)) -> a -> b -> (a,b)`
17:56:22 <hexagoxel> note that the types have merely gotten a bit more specific.
17:56:30 <david__> ahhh
17:56:34 <david__> i got it 
17:57:04 <david__> thanks
17:57:08 <hexagoxel> yw
17:59:03 <cow_2001> using Map makes everything dynamic again with no static analysis :(
18:00:05 <hexagoxel> only if your values are Dynamics..
18:01:43 <hexagoxel> (`Data.Dynamic`s)
18:05:01 <lambda-11235> \away
18:09:13 * hackagebot tuple-hlist 0.2.0.1 - Functions to convert between tuples and HLists.  https://hackage.haskell.org/package/tuple-hlist-0.2.0.1 (NicolasDudebout)
18:11:29 <Zemyla> Dynamic's type could be written as Dynamic (forall x. (forall a. (Typeable a) => a -> x) -> x), correct?
18:17:05 <hexagoxel> Zemyla: i think you are right. Only then, the user would have to unsafeCoerce to do anything useful.
18:17:09 <fread2281> Zemyla, internally it's different, but yes
18:17:38 <Zemyla> hexagoxel: fromDyn (Dynamic m) = m cast
18:17:56 <Zemyla> Though that type doesn't really allow dynApply. :V
18:18:09 <shachaf> Yes, Dynamic could be an existential Typeable, and that's an encoding of an existential.
18:18:32 <hexagoxel> Zemyla: oh indeed, i forgot about cast :/
18:19:01 <Zemyla> I mean, that's like the primary reason to use Typeable.
18:28:05 <jfjhh> haskell noob question: is there a way to combine these scans into one?
18:28:08 <jfjhh> scanl1 (+) . scanl1 (\acc x -> (* acc) . recip $ x) $ 1:[1..]
18:29:11 <jle`> on a slightly unrelated note, (* acc) . recip $ x is the oddest way i've ever seen someone write recip x * acc
18:29:29 <glguy> recip x * acc, aka   acc/x
18:29:47 <bitemyapp> jle`: aaahhahahaha
18:29:50 <bitemyapp> jle`: glorious.
18:29:56 <glguy> (\acc x -> acc/x)? (/)
18:29:58 <bitemyapp> jle`: good to see the spirit of Perl resides.
18:29:59 <jle`> glguy's simplification was even better, heh
18:31:05 <jle`> jfjhh: i feel like it's possible, but you'll have to think of the combined algorithm on your own more or less
18:31:24 <jle`> there are some libraries that represent scans as "first class objects" that can be combined and squished into combined single-pass scans
18:31:31 <jle`> but that might be overkill here
18:32:17 <shachaf> > scanl1 f . scanl1 g $ [a,b,c,d]
18:32:18 <lambdabot>  [a,f a (g a b),f (f a (g a b)) (g (g a b) c),f (f (f a (g a b)) (g (g a b) c...
18:33:09 <shachaf> Looks to me like two scans are the clearest way to express that.
18:33:19 <jfjhh> alright, thanks guys
18:35:02 <glguy> scanl1 (+) (scanl (/) 1 [1..])     is nice, but probably doesn't have enough operators (yes, I know jfjhh left)
18:40:05 <pavonia> When you have a module that exports everything in it (so doesn't have an export list), does it also export the class functions from the imported modules?
18:40:56 <glguy> what happened when you tried?
18:41:34 <pavonia> It seems it does, but I'm not sure
18:46:43 <pavonia> My "problem" is I can use (<$>) in my code though I don't import Control.Applicative
18:47:20 <glguy> <$> is in Prelude as of base-4.8
18:47:42 <pavonia> I'm using an older base version
18:48:02 <jle`> (<$>) is also not a class function
18:48:57 <pavonia> Oh, right. That makes it even more confusing
18:49:40 <parsnip> is there a prototypical example of ma -> (a -> mb) -> mb in mathematics? 
18:50:07 <parsnip> y'know something simple, like +
18:51:46 <mniip> parsnip, 'm a' is not very widely discussed outside category theory, I believe
18:52:13 <mniip> I mean
18:52:23 <mniip> m is a functor and all that
18:52:47 <geekosaur> pavonia, some other modules do (or used to) export it for convenience
18:52:59 <pdxleif> The Kleisli variant looks more lika monoid
18:53:02 <fread2281> what if we define whitespace (function application) as a mixfix operator? would that work?
18:53:03 <parsnip> determinant is a functor i think. 
18:53:18 <pdxleif> (a -> m b) -> (b -> m c) -> a -> m c
18:54:39 <mniip> is determinant a functor?
18:54:40 <fread2281> it seems surprising, but I'm having trouble generating a counterexample
18:54:41 <pavonia> geekosaur: Yeah, I guess that's it
18:56:45 <jle`> parsnip: i guess maybe you can think of monadic join as the diagonal of a matrix
18:57:00 <jle`> but you typically don't consider matrices as vectors of vectors in math, i don't think
18:58:41 <jle`> you can turn any f : a -> a -> b into g : a -> b, by taking g(x) = f(x,x)
18:59:10 <jle`> and people do this a couple times...
19:00:18 <nshepperd> ooh, determinant is a functor
19:01:17 <parsnip> maybe like, `a` could be a matrix A, and `ma` could be like, (A, det A). 
19:01:32 <nshepperd> mapping finite vector spaces to the field F, and matrix M to (*|M|)
19:02:09 <nshepperd> I mean (\x -> x * |M|)
19:05:17 <nshepperd> seems unlikely to be a monad though
19:15:31 <ryoshu> hi
19:15:41 <ryoshu> I just built ghc-7.10.2 for netbsd amd64
19:15:48 <ryoshu> how to test whether it works
19:16:50 <ryoshu> chieftec$ uname -a
19:16:50 <ryoshu> NetBSD chieftec 7.99.21 NetBSD 7.99.21 (GENERIC) #0: Mon Nov  2 03:08:39 UTC 2015  root@chieftec:/tmp/netbsd-tmp/sys/arch/amd64/compile/GENERIC amd64
19:16:53 <ryoshu> chieftec$ ghci --version
19:16:55 <ryoshu> The Glorious Glasgow Haskell Compilation System, version 7.10.2
19:16:58 <ryoshu> chieftec$ ghci           
19:17:00 <ryoshu> GHCi, version 7.10.2: http://www.haskell.org/ghc/  :? for help
19:17:03 <ryoshu> Prelude> 
19:20:47 <pavonia> Looks like it does
19:36:51 <voltz> Hey, Has anyone ever gotten the "hdevtools : hdevtools is not an executable!" when installing GHC-mod?
19:36:58 <voltz> Any idea how to fix it?
19:39:00 <kadoban> voltz: That sounds odd. hdevtools is a totally different tool than ghc-mod AFAIK.
19:39:25 <voltz> Ahh jesus I meant hdevtooks, Not ghc-mod..
19:39:31 <voltz> tools*
19:39:49 <kadoban> voltz: How are you installing it?
19:40:14 <voltz> Followed the recommendation on the Git page, Pathogen.
19:41:01 <kadoban> voltz: Oh, so you're installing the vim plugin? Have you installed the actual hdevtools executable though?
19:41:18 <voltz> Uhh.... yeah That would probably help....
19:41:28 <voltz> Sorry
19:41:43 <kadoban> No worries. It's kind of confusing, but yeah the plugin just uses the executable.
19:43:00 <voltz> Ok, just used Cabal to install it, Still the same error in Vim. Any ideas?
19:45:24 <kadoban> voltz: Is it on your path? I forget where cabal installs stuff.
19:45:57 <voltz> I honestly don't know. ,-,
19:46:42 <kadoban> voltz: What does 'which hdevtools' output?
19:47:13 <voltz> Definitely Not in the path, command not found
19:47:50 * geekosaur would guess that it went looking for the program and found a directory
19:47:56 <kadoban> voltz: Hmm, what OS is this? Usually that just outputs nothing if it's not found, so I wonder if you have 'which' or not.
19:48:05 <voltz> Ubuntu
19:48:07 <kadoban> Oh, that's a good guess.
19:48:26 <voltz> Wait no, I'm running Debian on my server..
19:48:35 <voltz> Ubuntu desktop.
19:49:00 <kadoban> Well, close enough. Every linux has 'which' AFAIK. geekosaur's guess seems like a good one. I'm not sure how to figure that out exactly though.
19:49:33 <geekosaur> check each path element to see if it has a directory named hdevtools, possibly due to a thinko somewhere
19:49:34 <geekosaur> hm
19:49:34 <voltz> "which"?
19:50:41 <geekosaur> oIFS="$IFS"; IFS=:; for d in $PATH; do test -e "$d/hdevtools" && ls -ld "$d/hdevtools"; done; IFS="$oIFS"
19:53:29 <geekosaur> also: it is possible that some linux doesn't have "which". all of them will have "type" because it's POSIX-mandated
19:53:55 <geekosaur> (it's also more reliable since if "which" is not a shell builtin, it can lie)
19:54:01 <lethjakman-l> Is there a time when bytestring is better than Text?
19:54:17 <geekosaur> network streams are octet streams == ByteString
19:54:53 <geekosaur> if you want to get Text from such, you will probably be separating it from framing that is not guaranteed to be UTF8 and converting just that part
19:55:10 <geekosaur> also you do not want to use Text with binary files
19:55:17 <lethjakman-l> Ahhh
19:55:30 <lethjakman-l> So, is Text kind of a layer ontop of Bytestring?
19:55:33 <geekosaur> no
19:56:22 <lethjakman-l> Ok
19:56:26 <geekosaur> if you go low enough level they have similar implementations, but last I checked Text was internally UTF16 (works in terms of 16-bit words instead of bytes)
19:56:36 <lethjakman-l> Gotcha
19:56:40 <lethjakman-l> That makes sense, thank you :)
19:58:39 <lethjakman-l> It's good to see haskell.org has a new SSL cert. 
19:59:55 <lethjakman-l> Does anyone know of a way to tell aeson "Only parse this if you have to" besides leaving it out of the parser/data structures? 
20:00:13 <lethjakman-l> I'm looking to speed it up for a pretty big text file. 
20:03:33 <echo-area> http://www.haskellforall.com/2012/12/the-continuation-monad.html  <--  Which course teaches the type algebra shown in this post?
20:10:47 <voltz> Ok, So I found where cabal was installing things, Added it to the path, but still the same error.
20:11:09 <echo-area> Found one at http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
20:12:06 <voltz> Kadoban : I can run hdevtools in the terminal.
20:14:29 <Imaspy> @pl groupBy (\x y -> isAlphaNum x && isAlphaNum y)
20:14:29 <lambdabot> groupBy ((. isAlphaNum) . (&&) . isAlphaNum)
20:15:10 <Cale> echo-area: That kind of connection is obvious if you know any one of a number of different things... it comes up in algebraic combinatorics, it comes up via category theory, obviously type theory courses might include it...
20:19:52 <echo-area> Cale: Sadly I have not learned any one of them, and I needed a systematic introduction.  Such books are in my reading list but I do not reach yet :(
20:20:15 <kadoban> voltz: And you're still getting that error?
20:21:08 <Imaspy> :t (&&) `on` isAlphaNum
20:21:10 <lambdabot> Char -> Char -> Bool
20:21:51 <Imaspy> Is there a single thing Haskellers didn't think about, gosh.
20:22:11 <Imaspy> The combinators are so great.
20:22:55 <echo-area> Cale: Thanks anyway
20:23:33 <Cale> echo-area: Well, I'm not exactly sure where to point you first...
20:25:21 <voltz> Yes, Kadoban
20:25:54 <echo-area> Cale: Then I start with a random point and use a heuristic approach :)
20:26:25 <Cale> echo-area: Yeah, especially if your main goal is programming, it's best to stay close to Haskell and just learn things as you need them.
20:58:41 <cow_2001> why wouldn't:(gameTime .~ time) $ (player %~ moveCharacter time) $ game
20:58:53 <cow_2001> update the gameTime field of game?
20:59:20 <cow_2001> it just keeps the time at the first value it sets
21:14:19 * hackagebot pinch 0.1.0.0 - An alternative implementation of Thrift for Haskell.  https://hackage.haskell.org/package/pinch-0.1.0.0 (abhinav)
21:35:08 <cow_2001> ooooh
21:35:18 <cow_2001> i'm so stupid
21:35:26 <cow_2001> it's not time
21:35:30 <cow_2001> it's dtime
21:35:32 <cow_2001> ~_~
21:52:54 <solatis> is there a pretty haskell library for unit conversions? as in, convert gb to mb, etc?
22:00:01 <KaneTW> solatis: there's a whole type-level system for it, but i don't know how active it is
22:00:03 <KaneTW> oen sec
22:00:17 <solatis> right
22:00:39 <KaneTW> hackage is being silly
22:00:52 <solatis> as it always is
22:04:48 <KaneTW> there's `quantities` and a bunch of other stuff but it's term-level
22:04:51 * hackagebot pinch 0.1.0.1 - An alternative implementation of Thrift for Haskell.  https://hackage.haskell.org/package/pinch-0.1.0.1 (abhinav)
22:04:53 * hackagebot git-fmt 0.1.0.0 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.1.0.0 (hjwylde)
22:04:55 * hackagebot git-fmt 0.1.0.1 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.1.0.1 (hjwylde)
22:04:57 * hackagebot git-fmt 0.1.0.2 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.1.0.2 (hjwylde)
22:05:14 <solatis> k
22:05:15 <KaneTW> and `unittyped` and `uom-plugin` as type-level libs (latter being a ghc plugin)
22:05:19 <solatis> i'll take a look
22:05:32 <Hafydd> Those were some fast updates.
22:10:11 <bb010g> Should I `stack install xmonad` instead of installing my repo's xmonad?
22:25:13 <KaneTW> generally yes
22:29:51 * hackagebot patches-vector 0.1.5.0 - Patches (diffs) on vectors: composable, mergeable, and invertible.  https://hackage.haskell.org/package/patches-vector-0.1.5.0 (LiamOConnorDavis)
22:49:35 <veyn> :t read.reverse.show
22:49:37 <lambdabot> (Read c, Show a) => a -> c
22:50:53 <veyn> :t show.reverse.read
22:50:54 <lambdabot> String -> String
22:51:40 <kosc> How can I avoid floating-point numbers error in haskell? (Something like this: 0.4 - 0.3 /= 0.1)
22:52:05 <veyn> Use Reals
22:53:45 <glguy> > 0.4 - 0.3 :: Rational
22:53:47 <lambdabot>  1 % 10
22:54:44 <veyn> :i (.)
22:55:07 <glguy> :i only works in GHCi
22:55:08 <liste> veyn lambdabot can't :i
22:55:15 <liste> and @info is useless
22:55:18 <veyn> Yeh
22:55:21 <veyn> Ok
22:56:03 <glguy> veyn: You can experiment with lambdabot in private message: /msg
22:56:29 <veyn> Yeah, I was really just checking if my GHCi was wrong..
22:56:41 <liste> what did it say?
22:56:44 <veyn> Or rather if there was a discrepancy.
22:57:48 <veyn> Oh.. That's interesting..
22:58:08 <veyn> reverse.show.read :: String -> [Char]
22:59:46 <liste> String is a synonym for [Char]
23:00:20 <veyn> I know, It's interesting that it's inconsistent.
23:10:00 <kosc> Help, please http://lpaste.net/145352
23:10:31 <glguy> kosc: Fractional isn't a type constructor, it's a constraint
23:10:54 <opqdonut> kosc: "Ratio Int" might be what you want
23:11:02 <glguy> No, you never ever want Ratio Int
23:11:10 <opqdonut> gah, Rational
23:11:19 <opqdonut> never can remember these
23:11:57 <veyn> Why should we never use it, glguy?
23:11:59 <glguy> The only time to use Ratio Int in particular is when you want to demonstrate the fun ways it breaks :)
23:12:06 <kosc> Rational Int instead of Fractional?
23:12:15 <glguy> Just "Rational"
23:12:16 <opqdonut> kosc: just "Rational" instead of "Fractional"
23:12:34 <glguy> veyn: It very easily overflows the numerator or denominator portions
23:12:34 <kosc> Ok
23:12:47 <veyn> kk
23:12:48 <glguy> so there are lots of values that you get the wrong answer for when you try to compare them
23:12:52 <glguy> or multiply, or whatever
23:13:31 <glguy> type Rational = Ratio Integer
23:13:34 <glguy> so you don't have that problem
23:14:54 <glguy> Normal Ints can overflow, but it's somewhat straightforward to reason about when that might happen and at what scales
23:15:16 <veyn> Where can I find docs on infix/l/r
23:15:38 <glguy> What aspect? How to write them in your own file?
23:17:12 <glguy> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820004.4.2
23:18:05 <nitrix> Does hackage has an offline version?
23:18:14 <nitrix> I'm sick of relying on it and it being constantly down.
23:18:38 <nitrix> Also; any chance they add CloudFlare to it or similar?
23:18:52 <srhb> nitrix: There's a mirroring tool somewhere in the wild.
23:19:07 <glguy`> If it's constant down for you you might have an issue with your network
23:19:36 <glguy`> You can install documentation locally when you install a package
23:19:42 <nitrix> glguy`: A network issue that only manifest itself for hackage?
23:19:56 <nitrix> I'll try to traceroute next time.
23:21:52 <nitrix> glguy`: I mean, I would even donate for more/better servers. I know I'm not the first one experience problems with it. (I still feel CloudFlare is the easier option though).
23:22:03 <nitrix> experience -> experiencing.
23:24:10 <nitrix> Is it worth bringing up on the mailinglist?
23:25:48 <edwardk> zemyla: re faster free applicatives, sending me a pull request or just an issue with a summary on free would probably be best
23:25:58 <srhb> nitrix: The infrastructure one? Sure, you can.
23:26:06 <Zemyla> Okay.
23:29:53 * hackagebot success 0.2 - A version of Either specialised for encoding of success or failure  https://hackage.haskell.org/package/success-0.2 (NikitaVolkov)
23:29:58 <fread2281> is there a library for backtracking LVars/MVars/IORefs/similar with fork?
23:31:27 <nitrix> It seems hackage already use CF. Yeah now that's worth investigating :P
23:33:31 <fread2281> or any mutable vars with a blocking read
23:34:20 <Zemyla> edwardk: Submitted an issue with links.
23:34:28 <Zemyla> The links have benchmarks.
23:35:22 <srhb> nitrix: I've not had problems with Hackage for months, really, except that one outage. Everything seems mostly fine after the major overhaul.
23:38:45 <nitrix> srhb: I'll debug further next time. I used to think it was normal because everyone was complaining about it; now it truly is curious.
23:52:38 <jle`> solatis: there was a neat one that just showed up on reddit :O
