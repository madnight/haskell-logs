00:07:41 * hackagebot Spock 0.10.0.1 - Another Haskell web framework for rapid development  https://hackage.haskell.org/package/Spock-0.10.0.1 (AlexanderThiemann)
00:07:41 * hackagebot relational-query-HDBC 0.2.0.0 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.2.0.0 (KeiHibino)
00:18:17 <quicksilver> wow, another typed haskell frontend to relational queries
00:32:37 * hackagebot relational-query-HDBC 0.2.0.1 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.2.0.1 (KeiHibino)
00:52:38 * hackagebot names-th 0.2.0.0 - Manipulate name strings for TH  https://hackage.haskell.org/package/names-th-0.2.0.0 (KeiHibino)
01:32:39 * hackagebot uu-tc 2015.1.1 - Haskell 98 parser combintors for INFOB3TC at Utrecht University  https://hackage.haskell.org/package/uu-tc-2015.1.1 (joaopizani)
02:13:46 <jpcooper> morning
02:20:16 <liste> morning
02:23:16 * hackagebot Lambdajudge 1.0.0.0 - A library to easily host Haskell based programming competitions  https://hackage.haskell.org/package/Lambdajudge-1.0.0.0 (ankitku)
02:53:59 <henk> hi, is there any simple way (i.e. not editing the source) to make lambdabot not shorten URLs with tinyurl automatically? In my channel this is considered leakage of more or less private information …
02:55:28 <quicksilver> it's been a long long time since I looked at lambdabot but isn't that just a plugin you can install or not install?
02:55:51 <quicksilver> http://stackoverflow.com/questions/33648942/haskell-conduit-from-process-capturing-both-stdout-and-stderr
02:56:01 <quicksilver> sorr that's just an example URL to test lambdabot 
02:56:12 <quicksilver> henk: seems to be off in this channel, for example :) I thought it was.
02:58:47 <jbracker> Does anybody here have experience using the effect-monad package?
02:58:54 <henk> quicksilver: ideally I’d like to keep the plugin but switch off the automatism of shortening the url.
02:59:59 <quicksilver> henk: to be clear, this is your own lambdabot instance?
03:00:04 <henk> quicksilver: yes
03:02:04 <quicksilver> looking at the source, the answer to your question would seem to be no
03:02:05 <quicksilver> https://github.com/lambdabot/lambdabot/blob/master/lambdabot-reference-plugins/src/Lambdabot/Plugin/Reference/Url.hs
03:02:38 <quicksilver> you can use the 'ignoredStrings' to make it ignore some URLs completely
03:02:40 <henk> quicksilver: ok, I came to the same result, but I’m a haskell-noob, so I wanted to ask … thank you (:
03:02:49 <quicksilver> but, that will disable the title display as well as the tinyurling
03:02:52 <mniip> there is also @url-off
03:03:01 <quicksilver> it doesn't seem possible to disable one without disabling other
03:03:08 <quicksilver> it would be a trivial edit to the source tho
03:06:11 <henk> mniip: I went with that now … there is another bot doing that already anyway (:
03:07:01 <henk> though AFAICT both rbot (in ruby) and lambdabot seem to fail with some things: rbot with UTF-8 in the title or body or something, lambdabot doesn’t seem to like https-links
03:10:51 <Xandaros> lambdabot can't do a lot of things it should. I also want to log a channel, but have the bot in two. I don't think you can do that without edits, either :(
03:16:02 <arbelos> How is it that I can do   let f ~(x,y) = 1 in f undefined   , but not    let f ~(x,y) = 1 in f 2   ?
03:16:24 <mauke`pwd`> because type error?
03:16:46 <mauke`pwd`> you'd need some Num instance for tuples
03:20:01 <arbelos> oh right.. wait
03:21:52 <arbelos> there is some example I can't remember where I found it.. this was not what I was thinking of
03:22:28 <quicksilver> in fact you can do that, although you can't use it without the instance
03:22:36 <quicksilver> :t let f ~(x,y) = 1 in f 2 in f
03:22:38 <lambdabot> parse error on input ‘in’
03:22:48 <quicksilver> :t let f ~(x,y) = 1 in f 2 
03:22:49 <lambdabot>     Could not deduce (Num (t0, t1)) arising from the literal ‘2’
03:22:49 <lambdabot>     from the context (Num a)
03:22:49 <lambdabot>       bound by the inferred type of it :: Num a => a at <interactive>:1:1
03:22:54 * quicksilver thinks
03:23:30 <quicksilver> oh, the constraint has to be resolved because it's not propagated out into the result type
03:23:33 <quicksilver> I forgot that
03:23:35 <quicksilver> :t let f ~(x,y) = 1 in f 
03:23:37 <lambdabot> Num a => (t, t1) -> a
03:44:25 <nani___> just checking if I understand correctly: if I do cabal sandbox init && cabal install euterpea, nothing at all will change at the system level, right? Everything it needs to install or change, it will do inside the directory I'm in, and in any other directory, everything will stay the same?
03:44:44 <dcoutts> nani___: right
04:00:02 <roelof> Hello, I have to give a string a fixed width using list comprehension. How can I make this list comprehension work even if the string is already processed 
04:01:16 <liste> roelof show us what you've got
04:02:32 <roelof> liste:  right now I have this ; pushRight s = [ x  | x <- s , 4 - (length x) == 1 ] but I learned that I cannot check the length of the outcome dynamically 
04:04:08 <pavonia> roelof: What are you trying to do exactly?
04:06:40 <roelof> pavonia:  I try to make a function which makes all the string a fixed length. let's say we have "hello" and we want a fixed length of 7 the outcome will be "  hello" 
04:06:42 <bernalex> I feel like the typeclassopedia doesn't do a good enough job at explaining why applicative functors are *useful*. does anyone know any good exercises for this?
04:08:24 <pavonia> roelof: I don't think you can do that onl with a list comprehension
04:09:15 <roelof> oke, then I find it wierd that this is a exercise of a chapter about list comprehension 
04:09:50 <pavonia> Do you have a link to that exercise?
04:10:22 <roelof> No, but I can make a paste of it 
04:10:57 <pavonia> The problem is, you cannot add more elements to the output list than the input list has, unless you have a second list to work on
04:11:35 <roelof> oke, here is the exact text 
04:12:36 <roelof> pavonia:  so two generators ? 
04:13:07 <pavonia> Not sure, could you show the textß
04:13:09 <pavonia> ?
04:13:49 <roelof> pavonia:  which text do you need. I already give a link to the orginal text of the exercise 
04:14:08 <pavonia> I don't see any links
04:14:34 <roelof> sorry , you are right. Here is the link : http://lpaste.net/145024
04:15:32 <pavonia> Well, it doesn't say anything about using list comprehensions
04:16:39 <roelof> no, but the exercises are under a lot of text which explains list comprehension 
04:17:12 <roelof> o, for me its a exercise which on one way or the other needs it 
04:18:43 <pavonia> Hhm, I think list comprehensions would make a solution unnecessarily difficult, I can't even think of something off hand
04:18:51 <merijn> roelof: I dunno how to do it using list comprehensions, but it's fairly easy to generate all strings of length 7
04:19:08 <merijn> > replicateM 7 [(minBound :: Char)..maxBound]
04:19:10 <lambdabot>  ["\NUL\NUL\NUL\NUL\NUL\NUL\NUL","\NUL\NUL\NUL\NUL\NUL\NUL\SOH","\NUL\NUL\NUL...
04:19:20 <merijn> Of course most of those Strings are fairly boring :p
04:19:53 <roelof> or just replicate 3 " " ++ string 
04:20:19 <roelof> > replicate 3 " " + "hello" 
04:20:21 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
04:20:21 <lambdabot>      Expected type: [[Char]]
04:20:21 <lambdabot>        Actual type: [Char]
04:20:49 <merijn> Yoou probably meant
04:21:09 <merijn> Actually, no I can't infer what you meant from that
04:21:34 <mauke`pwd`> > replicate 3 ' ' ++ "hello"
04:21:35 <lambdabot>  "   hello"
04:21:37 <roelof> I tried to join a couple of spaces with a string 
04:21:58 <quicksilver> roelof: I do not think you are expected to answer that question with a list comprehension
04:22:03 <merijn> Oh
04:22:09 <merijn> I misread the question, I think
04:22:24 <merijn> You were wanting to pad strings?
04:22:58 <roelof> quicksilver:  oke, still wierd that this is a exercise where the former exercises could all be solved with list comprehension 
04:23:15 <roelof> merijn: pad ?? 
04:23:21 <quicksilver> perhaps
04:23:26 <quicksilver> I don't have any context roelof :)
04:23:38 <quicksilver> maybe they asked enough list comp questions and this one is a lead-in to something else
04:23:51 <quicksilver> maybe it's a lead-in to a list comp question a few questions donw
04:23:54 <quicksilver> who knows?
04:26:53 <roelof> I did some google and found this : http://lpaste.net/145025 . I think thats the solution I was looking for 
04:32:17 <roelof> Thanks all for the time and patience 
04:34:06 <roelof> > [ print x | x <- [ 1 .. 5]] 
04:34:08 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>]
04:34:52 <roelof> hmm, that is not the way the outcome of every run can be printed 
04:35:05 <mauke`pwd`> > [ x | x <- [ 1 .. 5]]
04:35:07 <lambdabot>  [1,2,3,4,5]
04:37:59 <quicksilver> roelof: you can do sequence [ print x | x  <- [1 .. 5] ]
04:38:09 <quicksilver> sequence combines a list of IO actions into a big one which runs them all
04:38:24 <quicksilver> in GHCi that will get actually run, since GHCi executes IO actions
04:38:50 <roelof> mauke`pwd`:   I know that , I have to make a sort of table which produces the fibb numbers like this :  http://lpaste.net/145028
04:42:52 <roelof> or I have to make two list comprehensions one for calculating and puts them in tuples and one later to print it 
04:53:11 <merijn> I need a fast way to answer the question "how well does large dataset X fit distribution Y?", any suggestions. A lot of stuff references R, but R is pretty god awful in terms of speed
04:59:06 <JonReed> Is there a function in the base package that returns mean/average of a list? Does not seem to be.
04:59:31 <merijn> I don't think so?
05:04:09 <quicksilver> > uncurry (/) . (both %~ getSum) $ foldMap (\x -> (Sum x, Sum 1)) [1,2,3,4,5,6::Double]
05:04:11 <lambdabot>  3.5
05:04:22 <merijn> quicksilver: That will suck for long lists, though
05:04:35 <merijn> oh, wait, the sum trick might not
05:04:55 <merijn> That's a nice trick actually
05:05:23 <merijn> hmm
05:05:32 <quicksilver> I think it will build big thunks in both halves of the tuple
05:05:41 <merijn> oh, Sum is not strict?
05:05:48 <quicksilver> Sum is a newtype
05:05:51 <quicksilver> it isn't anything.
05:06:16 <quicksilver> the point is that tuples aren't strict and foldMap isn't strict, I guess
05:06:26 <mauke`pwd`> :t foldMap
05:06:27 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
05:06:41 <mauke`pwd`> fun
05:08:50 <quicksilver> actually newtypes are strict, of course
05:08:54 <quicksilver> silly thing to say, sorry
05:09:22 <quicksilver> but the problem here is either/both the lazyness of tuples and the algorithm used by foldMap
05:09:46 <quicksilver> although foldMap works for Prelude.sum so -- I don't know? Maybe it's just the tuple?
05:09:50 <merijn> Isn't laziness of + an issue?
05:09:56 <merijn> I don't think sum is strict either?
05:10:01 <quicksilver> what makes you think (+) is lazy?
05:10:06 <quicksilver> > 3 + undefined :: Int
05:10:19 <lambdabot>  mueval: ExitFailure 1
05:10:25 * quicksilver blinks
05:10:28 <quicksilver> > 3 + undefined :: Int
05:10:30 <lambdabot>  *Exception: Prelude.undefined
05:10:49 <opqdonut> that's a bad examples as you're forcing the thunk
05:10:51 <merijn> Maybe lazy is not the word I'm trying to use
05:10:56 <merijn> opqdonut++
05:10:58 <opqdonut> > seq (3 + undefined) ()
05:10:59 <merijn> Yeah, what he means
05:11:00 <lambdabot>  *Exception: Prelude.undefined
05:11:17 <quicksilver> what does he mean?
05:11:35 <merijn> quicksilver: The fact that + builds a large set of thunks until the result is forced
05:11:39 <quicksilver> what else does strict mean, except f _|_ is _|_
05:11:45 <merijn> Which I guess is a property of foldMap
05:11:48 <quicksilver> that's nothing to do with +
05:11:56 <quicksilver> that's to do with the way + is called
05:12:29 <opqdonut> the problem with quicksilver's avg is the fact that (,) is lazy
05:12:50 <opqdonut> or rather the (+) for the (,) instance
05:13:09 <opqdonut> > seq ((Sum 3, Sum 1) + (Sum 5, Sum undefined)) ()
05:13:11 <lambdabot>      No instance for (Num a0) arising from the literal ‘3’
05:13:11 <lambdabot>      The type variable ‘a0’ is ambiguous
05:13:11 <lambdabot>      Note: there are several potential instances:
05:13:23 <opqdonut> gah
05:13:31 <merijn> opqdonut: You want mappend
05:13:44 <opqdonut> > let a :: Int; a = 1; seq ((Sum a, Sum a) `mappend` (Sum a, Sum undefined)) ()
05:13:45 <lambdabot>  <hint>:1:78:
05:13:45 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
05:13:53 <opqdonut> > let a :: Int; a = 1 in seq ((Sum a, Sum a) `mappend` (Sum a, Sum undefined)) ()
05:13:55 <lambdabot>  ()
05:13:56 <opqdonut> gah
05:13:58 <opqdonut> there
05:14:22 <opqdonut> it wouldn't help even if foldMap was strict, though
05:16:14 <quicksilver> > (Sum 3 `mappend` Sum undefined) `seq` ()
05:16:16 <lambdabot>  *Exception: Prelude.undefined
05:16:26 <quicksilver> so the problem is mappend for (,)
05:16:28 <opqdonut> yep
05:16:40 <quicksilver> but it's not wrong for mappend to be lazy for (,)
05:16:43 <opqdonut> indeed
05:16:46 <quicksilver> that's in line with the way tuples are generally used in haskell
05:16:47 <opqdonut> > (foldl' (\(a,b) _ -> (a+1,b+1)) (undefined,0) [1,2,3,4]) `seq` True
05:16:49 <lambdabot>  True
05:17:08 <opqdonut> > (foldl' (\a _ -> a+1) undefined [1,2,3,4]) `seq` True
05:17:09 <lambdabot>  *Exception: Prelude.undefined
05:17:35 <mada> (foldl' (07\(a,b) _ 07-> (a07+041,b07+041)) (undefined,040) [041,042,043,044]) 07`seq` True
05:17:37 <opqdonut> I sometimes define my own strict pair type and then use a fold
05:17:39 <mada> nice.
05:18:00 <quicksilver> > (foldMap (\a -> Sum a) [1,2,3,undefined])
05:18:01 <lambdabot>  Sum {getSum = *Exception: Prelude.undefined
05:18:02 <mada> glguy: does irc-core have a command to delete buffers/windows?
05:18:12 <quicksilver> > (foldMap (\a -> Sum a) [1,2,3,undefined]) `seq` True
05:18:14 <lambdabot>  *Exception: Prelude.undefined
05:18:19 <quicksilver> that doesn't really prove anything
05:18:37 <quicksilver> on the one hand, mappend is too lazy anyway and will definitely build thunks
05:18:59 <quicksilver> but on the other hand I have suspicion that foldMap for lists won't behave as nicely as foldl' in terms of forcing things as it goes along
05:19:08 <quicksilver> but I don't immediately see how to prove that
05:19:24 <opqdonut> the only way to prove it is to compare memory profiles
05:19:43 <opqdonut> or at least the only straightforward way :)
05:22:36 <SneakySnake> http://lpaste.net/145031 <- How can I force the evaluation of `op`, so the user gets notified immediately if he enters an invalid operator?
05:24:30 <quchen> SneakySnake: add `return $! op` after the let block
05:24:54 <quchen> Or use BangPatterns to force the op, "let !op = ..." instead of "let op = ..."
05:25:16 <quchen> Or have a look at `evaluate`, which is the usual way of doing (return $!)
05:25:23 <opqdonut> SneakySnake: the cleanest solution would be to have op :: Maybe Op
05:25:49 <SneakySnake> Hmm, this is a lot of information, I'm new to Haskell, hi!
05:25:50 <opqdonut> SneakySnake: and then add a "when (isNothing op) do putStrLn "you dun goofed up"; ..."
05:25:54 <merijn> SneakySnake, opqdonut: Or alternatively use "return Add" for the success case and "throwIO InvalidOperatorException"
05:26:13 <opqdonut> actually, merijn's idea is even better than mine
05:26:29 <merijn> You probably want to use Text.Read.readMaybe instead of "read" too
05:26:30 <opqdonut> you can just print and exit instead of throw, of course
05:26:54 <SneakySnake> Thanks for the tips, I'll try and process them.
05:29:50 <lpaste_> merijn annotated “No title” with “No title (annotation)” at http://lpaste.net/145031#a145032
05:29:57 <merijn> SneakySnake: See that annotation
05:30:46 <SneakySnake> Hmm, don't know about the >> operator
05:31:07 <merijn> SneakySnake: Now you might wanna the repeated "case of" thing out into a separate combinator "try :: (a -> Maybe b) -> IO a -> IO b; try f act = do { result <- act; case f result of Nothing -> exitFailure; Just x -> return x }"
05:31:12 <merijn> :t (>>)
05:31:13 <lambdabot> Monad m => m a -> m b -> m b
05:31:27 <merijn> SneakySnake: "do { foo; bar }" is the same as "foo >> bar"
05:31:57 <merijn> SneakySnake: I always recommend reading and knowing the desugaring rules of do-notation: https://en.wikibooks.org/wiki/Haskell/do_notation
05:32:39 <SneakySnake> All right, thanks for all the information! It will take a while to ... take it all in.
05:37:08 <SneakySnake> Perhaps I'm in over my head here, still haven't learned most of the basics, and I already want to do I/O. I'm too used of being able to write hello worlds and other "interactive" things while I'm learning a language.
05:38:26 <magneticduck> SneakySnake: ghci is interactive
05:38:29 <magneticduck> that's what the 'i' isfor
05:38:45 <SneakySnake> Yeah, what I mean is that I want the program I write to be interactive
05:38:52 <SneakySnake> Like make a simple game
05:38:56 <SneakySnake> But that's out of the question for now
05:39:06 <SneakySnake> A game has lots of side effects
05:39:26 <magneticduck> um not necessarily
05:39:36 <magneticduck> do you mean state?
05:39:39 <magneticduck> because we can have state
05:39:40 <SneakySnake> Yeah, that's what I mean
05:42:26 <SneakySnake> How I imagine the usual game loop is reading input, mutating the state, then writing output
05:53:28 <Xandaros> SneakySnake: Well, you can pass around the game state as parameters and "return" the modified state. Or use the state monad which abstracts that very concept :P
05:53:59 <Xandaros> There's also frp, which is more "functional-ish", but can be a bit daunting at first
05:54:30 <merijn> What do you mean "functional-ISH"? Given that FRP has a denotational semantics, it's hard to be more functional than that...
05:56:19 <SneakySnake> Is there any recommended book for learning Haskell? I was reading Learn You a Haskell, but I was getting a bit bored. I want to write "real" applications as soon as possible. I see Real World Haskell being linked on the paste site. I might look into it.
05:56:35 <Clint> it's pretty outdated
05:56:42 <merijn> SneakySnake: https://github.com/bitemyapp/learnhaskell ?
05:57:40 <Xandaros> merijn: Well, yes. But you could argue that monads are also very functional. I was just saying that frp does not feel as imperative, without paying any heed to actual definitions
05:58:23 <SneakySnake> I guess I should head over to #haskell-beginners, since I'm a beginner.
05:58:29 <Xandaros> SneakySnake: I suggest just finding yourself some projects to do and just start doing it :P
05:58:33 <merijn> SneakySnake: Beginners questions are fine here
05:59:09 <Xandaros> You can learn quite a bit just by using other peoples libraries
06:04:14 <Fylwind> SneakySnake: you can write the game loop part as a function that takes some input, the old game state, and then returns a new game state
06:04:32 <SneakySnake> Yeah, that's true.
06:08:44 <Fylwind> SneakySnake: the usual way to write I/O "loops" in Haskell is by recursion, e.g. myLoop counter = do { print 1; myLoop (counter + 1) }. there are other more abbreviated ways of course (using Foldable/Traversable) but those may be more difficult to grasp at first
06:09:03 <Fylwind> I meant to say "print counter", not "print 1", oh well
06:11:02 <merijn> Fylwind: I would usually use StateT over IO + forever instead, but yeah
06:13:42 <quicksilver> there are so many different ways :/
06:13:47 <Fylwind> merijn: certainly you can, but that would require knowing monad transformers :P
06:13:54 <quicksilver> I find it helps to teach the recursive way that Fylwind showed first
06:13:59 <merijn> sure
06:14:10 <quicksilver> before showing that recursion patterns can be factored out into reusable combinators
06:14:11 <SneakySnake> Crap. I ran out of RAM by foolishly messing around and doing huge calculations with an Integer.
06:14:55 <Fylwind> SneakySnake: If you're using a *nix you can try 'ulimit -v 1000000' to restrict all child process of that terminal to 1GB of virtual mem (each)
06:15:16 <SneakySnake> Or I'll just restrict myself from doing stupid things :p
06:15:21 <merijn> Why would you limit virtual memory? :(
06:15:53 <merijn> That breaks so many useful tricks that aren't actually memory intensive
06:16:21 <Fylwind> merijn: to avoid runaway bugs like that; I've bitten myself a couple times with some Haskell program I wrote that ate all the memory and eventually swapping my computer to death
06:16:42 <merijn> Fylwind: It will also break anything doing things like mmapping large files, etc.
06:16:43 <Fylwind> merijn: it's not something you use in production, but when debugging/testing code it helps; feel free to use 4GB if you have plenty to spare :P
06:16:53 <quicksilver> merijn: doing it one terminal while you are trying stuff is hardly giving up the ability to use it ever again :P
06:17:02 <SneakySnake> I have magic sysrq activated for cases where my computer crawls to a halt
06:17:22 <merijn> quicksilver: I often consume substantially more than 1GB virtual mem while working
06:17:26 <Fylwind> merijn: it's for your _own_ program so presumably you know how much mem you need
06:17:52 <Fylwind> it's very rare I do anything that intensive in Haskell
06:18:02 <merijn> Fylwind: The thing is that virtual memory is only partially correlated with ACTUAL memory and therefore not indicative of the memory pressure your program is creating
06:18:18 <quicksilver> merijn: so do I. But Fylwind's suggestion was not targetted at either of us.
06:18:36 <Fylwind> merijn: I never said it was an exact measurement, or flawless; it was just a failsafe
06:18:44 <merijn> quicksilver: My point is that if you go and limit memory, limit actualy memory, not virtual
06:19:32 <merijn> i.e. "ulimit -m" rather than "ulimit -v", because then things like mmaping will still work as normal
06:19:37 <Fylwind> merijn: ah
06:19:55 <potatoe`> I was installing ghc-mod on my laptop and then I had to close the lid to take it home, and after that it didn't seem like it was compiling so I killed it and started it again
06:20:08 <potatoe`> now its stuck at building again with 0% CPU use
06:20:11 <potatoe`> can I force rebuild?
06:20:19 <merijn> potatoe`: "cabal clean"?
06:20:30 <potatoe> merijn says no .cabal file (I was installing it globally)
06:20:41 <merijn> ah...hmmm
06:20:48 <Fylwind> can you look at the process tree and see what it's stuck on?
06:20:53 <augur> sclv: hey. i just replied to your comment in the subreddit. im curious what you think
06:21:34 <Fylwind> or better yet, just 'cabal get ghc-mod' and then build it locally and see where it get stuck on (the verbosity -v flag may be of use)
06:23:37 <potatoe> merijn I found where it was storing the temp build files and wiped it
06:23:41 <potatoe> let me see if it works this time
06:33:43 <Ferdirand> YAY! just gained key insight into lens! 
06:33:49 <Ferdirand> (just wanted to share my happiness)
06:35:14 <merijn> Ferdirand: \o/
06:36:58 <Xandaros> Ferdirand: I read a lens tutorial on fpcomplete like 5 times. I still have not used prisms and stuff, only normal lenses, but I think I could, should the need arise :D
06:37:19 <Ferdirand> enlightenment came from trying to write lens :: Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t (without peeking at the source)
06:37:30 <quicksilver> Ferdirand++
06:38:20 <dmj> enlightenment 
06:38:23 <potatoe> merijn no use
06:38:27 <potatoe> its stuck at configuring now
06:38:49 <merijn> potatoe: Try pinging dcoutts in #hackage
06:38:58 <potatoe> alright
06:43:40 <quicksilver> Ferdirand: I didn't find that *that* enlightening, because to write that you just join up the dots in the only way you can and use fmap once :) but if it worked for you then \o/
06:44:14 <roelof> how can I make this work : http://lpaste.net/145034
06:44:47 <roelof> list comprehension are the most difficult subject I studied so far 
06:44:59 <Ferdirand> quicksilver: okay, fair enough. The point was, I understood how it worked without looking at the types
06:45:01 <quicksilver> roelof: that list comprehension returns a list of strings, not a string.
06:45:25 <Ferdirand> I was stuck seeing the setter as something which carves a value out of a structure to replace it
06:45:38 <Ferdirand> but the opposite point of view makes sense
06:45:45 <quicksilver> Ferdirand: for me the interesting moment was choosing various different Functors and trying out common lenses (e.g. _1) on those functors
06:45:51 <quicksilver> and seeing what effect popped out
06:46:16 <quicksilver> roelof: do you see why? list comprehensions always return lists.
06:46:28 <Ferdirand> in that i'm extracting all the data that the getter disregards, and applying again after the value has been transformed
06:46:45 <quicksilver> Ferdirand: *nod*
06:47:43 <roelof> I know that list comprehension return list. but changing the definition to fibTable :: Integer -> [String]  does not make it work. Still a lot of error messages 
06:48:26 <quicksilver> roelof: oh your definition of fibs is simply syntactically incorrect.
06:48:31 <quicksilver> I didn't see that at first glance.
06:48:39 <quicksilver> "|" is a notation for boolean guards
06:49:04 <quicksilver> you should simply have the three equations for fibs
06:49:29 <Fylwind> most enlightening thing I learned from lens was the realisation that lenses have nearly the same type signature as 'traverse'
06:49:32 <roelof> oke, then I messed up recursion and boolean guards in my head 
06:49:40 <lpaste_> quicksilver annotated “No title” with “No title (annotation)” at http://lpaste.net/145034#a145035
06:49:51 <quicksilver> Fylwind: yes!
06:49:58 <quicksilver> roelof: annotation shows the fix
06:50:16 <quicksilver> roelof: not sure why you mention recursion. This syntax has nothing to do with whether the function is recursive or not
06:50:30 <quicksilver> it's just how you specify functions with multiple equations
06:50:49 <quicksilver> f 0 = "none"; f 1 = "one"; f _ = "many"
06:50:52 <roelof> quicksilver:  I thought fibs was a recursive function to calculate the outcome 
06:50:57 <quicksilver> roelof: it is!
06:51:15 <quicksilver> roelof: but that fact that it is recursive is totally unrelated to the presence of multiple equations or guards
06:52:05 <roelof> oke
06:52:36 <Fylwind> eventually I realised the reason it took me so long to grok lenses was because I never had a good understanding of Foldable/Traversable
06:53:11 <roelof> quicksilver:  still errors : http://lpaste.net/145037
06:54:55 <quicksilver> roelof: ok that's a really confusing error but your actual problem is that the second paramter to 'zip' is a number
06:55:03 <quicksilver> the second paramter to zip is supposed to be a list
06:55:06 <quicksilver> which list did you want it to be?
06:55:42 <roelof> the list containing the fibs number 
06:59:26 <roelof> quicksilver:  I try to make something like this : http://lpaste.net/145038
06:59:34 <quicksilver> ah
06:59:41 <quicksilver> but your fibs function doesn't generate a list of fibs numbers
06:59:47 <quicksilver> it just generates the nth number
07:00:35 <roelof> oke, so the fibs needs also be a list comprehension with all the fib numbers 
07:01:25 <quicksilver> it doens't *need* to be a list comprehensions
07:01:33 <quicksilver> list comprehensions aren't the only way to make lists
07:01:39 <quicksilver> and they're not normally the best way either :)
07:01:46 <quicksilver> they're just a need notation for certain things.
07:02:45 <quicksilver> you _could_ keep your existing fibs function and change your list comp
07:02:52 <roelof> oke, I just thought this way because the whole chapter is about list comprehension 
07:02:53 <quicksilver> then you wouldn't be using 'zip' any more
07:03:00 <quicksilver> not quite sure what your goals are tho
07:03:52 <roelof> quicksilver:  oke, I will think how to do that 
07:16:27 <frerich> Did anybody here ever do something with Hoopl? I wonder whether it would be a good foundation to build some sort of static code analysis tool on.
07:17:11 <roelof> quicksilver: Can you help me one more time : http://lpaste.net/145039
07:21:22 <quicksilver> roelof: well, what type do *you* think [ y | y <- (map fibs [1..n]) ] has ?
07:23:40 <roelof> quicksilver:  I hope a list 
07:25:06 <roelof> found it. I had to change to this : fibTable :: Integer -> [Integer]
07:26:16 <quicksilver> right
07:27:42 <frerich> Granted, even thought the error message '    No instance for (Num Char) arising from a use of ‘fibs’ ' makes sense if you have a type inference machine built into your brain, it's not immediately helpful.
07:28:17 <quicksilver> yeah this is the worst thing about num overloading
07:28:47 <quicksilver> most type errors involving numbers turn into constraint errors in a different bit of code :(
07:29:15 <quicksilver> haskell is a really hard language to give good error messages
07:30:49 <frerich> Yeah. I understand that it helps to use type signatures liberally, but even when you have very little code (as in roelof's example) it's sometimes quite sobering to see the rate at which what ghc thinks is going on in your code diverges from what your brain thinks is going on. I.e. two lines down and suddenly the two of you have *totally* different ideas of the types of values being shuffled around.
07:31:41 <frerich> Especially when you have supposedly 'descriptive' identifiers which tend to lead your synapses taking wrong turns.
07:32:51 <roelof> oke, now I can calculate all the outcomes with this : http://lpaste.net/145041. Now I have to find out how I can make it work so the output is a tuple containing a number and the outcome of the  fibs function 
07:35:30 <quicksilver> right
07:35:44 <quicksilver> it's kind of obvious to me, but I assume you don't want me to just tell you
07:36:01 <quicksilver> *HINT* - on the left of the |, where you currently have y, you can write a tuple
07:36:07 <quicksilver> ( <something>, <something else> )
07:36:16 <quicksilver> the two somethings don't have to be just variable names, they can be any expression.
07:37:44 <roelof> yes, and I cannot do [(x,y) |x <- [ 1 .. n] ,  y <- map fibs [1..n] ] because I then get to much answers 
07:39:14 <roelof> and  [(n,y) |x <- n ,  y <- map fibs [1..n] ] gives every time a 5 
07:40:05 <frerich> roelof: The 'fibs' call doesn't *need* to be at the right of the '|'...
07:41:09 <frerich> roelof: If you change the stuff at the left side of the '|', you will probably also have to think about the type of your list again, i.e. whether you may need to adjust the function type in the first line.
07:45:54 <roelof> frerich:  found it, http://lpaste.net/145042
07:46:22 <frerich> I gave it away, didn't I? :-(
07:46:40 <roelof> now I have to find out how I can "convert" the (x,y) to a x\ty string 
07:46:56 <quicksilver> don't convert it
07:46:59 <quicksilver> just write that instead :)
08:04:32 <FofG> What's the syntax for importing a single constructor for a given type?
08:05:00 <obadz> Type(Constructor)
08:05:16 <FofG> e.g. import Data.Aeson (toJSON, Value(Object))?
08:05:41 <Mikie> roleof, let fibs = 0:1:zipWith (+) fibs (tail fibs)
08:06:32 <quchen> roelof: Pattern matching! let (x,y) = stuff in ...\t...
08:06:56 <quchen> > let (x,y) = (2, 10) in x*y
08:06:58 <lambdabot>  20
08:07:22 <quicksilver> neither of those is the answer roelof is looking for :)
08:07:52 <quicksilver> I did point out an hour or so ago that a list comp wasn't going to be the best answer but for learning purposes it's the answer he wishes to understand.
08:09:10 <opn> http://lpaste.net/145043
08:09:19 <opn> ^ how can I make the Shape instance for Circle work?
08:10:55 <mauke`pwd`> find out if there's a conversion function from/to Floating
08:13:37 <Taneb> :t (**)
08:13:38 <lambdabot> Floating a => a -> a -> a
08:13:42 <Taneb> :t pi
08:13:43 <lambdabot> Floating a => a
08:14:13 <mauke`pwd`> whatYouNeed :: (Floating a, Floating b) => a -> b
08:14:16 <opn> mauke`pwd`: not sure I understand what you mean, like some function (Floating a, Floating b) => a -> b?
08:15:17 <quicksilver> realToFrac is the generic conversion function
08:15:25 <quicksilver> not sure if the superclasses work out off-hand
08:15:27 <mauke`pwd`> :t realToFrac
08:15:29 <lambdabot> (Fractional b, Real a) => a -> b
08:15:37 <mauke`pwd`> no, requires Real input
08:16:10 <quicksilver> :t \r -> pi * r ** 2
08:16:11 <lambdabot> Floating a => a -> a
08:16:58 <quicksilver> the problem, opn, is that your Shape class promises it can produce area in *any* instance of Floating
08:17:17 <quicksilver> not necessarily the same one as your Circle is using
08:17:20 <mauke`pwd`> r is basically existential, the result is universal
08:17:58 <opn> mauke`pwd`: that's kind of what I thought, so can I use existential quantification to solve this?
08:18:00 <roelof> quicksilver:  I was hoping this would work : fibTable n = [ show (x) ++ "\t" ++ show( fibs x) | x <- [ 1 .. n]  ] but I see this error : http://lpaste.net/145045
08:18:14 <roelof> I find this a very frustating error 
08:19:16 <mauke`pwd`> opn: that's an interesting idea ...
08:19:43 <mauke`pwd`> class Shape s where { area :: s -> (forall f. (Floating f) => f -> a) -> a }
08:20:02 <prsteele> roelof: can you paste your code too?
08:20:33 <quicksilver> roelof: well we're back to your very first error, except the rest of the code is fixed
08:20:42 <quicksilver> roelof: that is returning [String] not String
08:20:58 <quicksilver> a lot of these errors you have had would be solved by removing the type signature and compiling
08:21:06 <quicksilver> you could then check the types and think about why it's right
08:21:57 <tommd> roelof: Stated another way, the code you stated is perfectly fine - your error is elsewhere.  You must have given an incorrect type signature.  You can ask GHC to explcitly give you the infered type via `fibTables :: _`
08:23:03 <tommd> > let fibs = undefined in let fibTable n = [ show (x) ++ "\t" ++ show( fibs x) | x <- [ 1 .. n]  ] :: _ in ()
08:23:05 <lambdabot>      Found hole ‘_’ with type: [[Char]]
08:23:05 <lambdabot>      To use the inferred type, enable PartialTypeSignatures
08:23:05 <lambdabot>      Relevant bindings include
08:23:28 <opn> mauke`pwd`: I tried that (also had to enable RankNTypes), but it still doesn't like my Circle instance...do I need to do something extra with the definition of are in the instance?
08:23:38 <tommd> > let fibs = undefined in let fibTable = (\n -> [ show (x) ++ "\t" ++ show( fibs x) | x <- [ 1 .. n]  ]) :: _ in ()
08:23:40 <lambdabot>      Found hole ‘_’ with type: a -> [[Char]]
08:23:40 <lambdabot>      Where: ‘a’ is a rigid type variable bound by
08:23:40 <lambdabot>                 the inferred type of
08:24:50 <mauke`pwd`> opn: I don't think your Shape class makes sense
08:25:41 <opn> mauke`pwd`: I think you're right
08:26:06 <mada> ghci can't load one of filemanip's modules: Illegal datatype context (use DatatypeContexts): Ix a =>
08:26:13 <mada> what's that about?
08:26:38 <quicksilver> sounds like a conflict between two different Ix to me
08:27:14 <opn> the problem I have with all of these type system extensions is that they're explained in a language that I don't understand
08:27:42 <opn> can anyone recommend a resource for someone completely uninitiated to understand the formalisms that are used in these explanations?
08:27:44 <roelof> quicksilver:  finnaly solved this way : http://lpaste.net/145048
08:27:57 <opn> Benjamin Pierce's book on type systems looks like it might be good..
08:28:00 <quicksilver> roelof: yup :)
08:29:18 <Zekka|Sigfig> opn: Just remember after you’ve learned all there is to know about crazy type system extensions that a not-insignificant proportion of your code’s users won’t be able to understand them either!
08:29:18 <roelof> quicksilver:  thanks, sometimes Haskell is no fun till you have solved a difficult challenge :) 
08:30:00 <mada> the line in question is the following datatype declaration:  data Ix a => SRange a = SRange [a] [(a, a)]
08:30:03 <opn> Zekka|Sigfig: heh, that might be so, but I'd at least like to understand them myself :)
08:30:06 <mada> in https://github.com/bos/filemanip/blob/master/System/FilePath/GlobPattern.hs#L59
08:30:17 <Zekka|Sigfig> I usually go out of my way to avoid things that I think will confuse other people
08:30:38 <Zekka|Sigfig> Minding that I’m probably more paranoid than average about that
08:31:07 <Zekka|Sigfig> You know how it goes, be liberal about what you can interpret but strict about what you put out
08:31:45 <roelof> quicksilver:  now hopefully a nice chapter how to make a sort of loan system. The book is finnaly at a point you have to make a "real" world programm :) 
08:40:17 <phaazon> hey, is there any people interested in making ghc’s output colorized?
08:40:40 <phaazon> I’d love to contribute and write such a change (with a flag to disable it, of course, for terminals that don’t support colors)
08:40:53 <phaazon> pretty all compilers have that, and it’s handy
08:40:57 <phaazon> even g++ has it! 
08:42:56 <Fylwind> phaazon: I'd love to too, but (a) I still haven't found the time for it :(  (b) when I tried coming up with a concrete design I got overwhelmed with decisions and bikeshedding
08:43:40 <Fylwind> phaazon: I'd love to see it happen though, but I know it's not gonna happen with just wishful thinking
08:44:14 <opn> FWIW, I think I found a way to express what I was trying to express with a multi-param type class: http://lpaste.net/145049
08:55:06 <Mikie> actually have no idea why it doesn't work without the second parameter; what's the difference?
08:56:30 <eikke> anyone ever used Criterion stand-alone? As in, write a custom benchmark tool (not using defaultMain and such) which takes some values from command line, runs a benchmark through criterion, then gets its results, does some calculations on them (e.g. turn execution time into throughput) and write out results?
09:01:47 <Quenty> Is there a better way  to define this?
09:01:50 <Quenty> suffix str = [str] ++ suffix(drop 1 str)
09:01:50 <Quenty> print (take 4 (suffix "test"))
09:01:58 <Quenty> I know there's got to be a better way to define this
09:02:15 <mauke`pwd`> > tails "test"
09:02:17 <lambdabot>  ["test","est","st","t",""]
09:02:18 <obadz> Quenty: tails
09:02:24 <Quenty> ?
09:02:27 <Quenty> oh.
09:02:31 <Quenty> -__-
09:02:41 <Quenty> If I was going to not use tails, how would I do it?
09:02:55 <obadz> nottails = tails
09:02:58 <obadz> then use nottails
09:03:04 <prsteele> @src tails
09:03:04 <lambdabot> tails []         = [[]]
09:03:04 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
09:03:40 <Quenty> I'm so out of my field right now
09:03:51 <ww> > boum "test"
09:03:53 <lambdabot>  Not in scope: ‘boum’
09:03:55 <ww> shame
09:04:05 <Quenty> Is xxs a parameter?
09:04:19 <prsteele> xxs is the name of the full argument that is being pattern matched via (_, xs)
09:04:35 <obadz> tails is exactly your suffix function
09:04:54 <Quenty> Yeah. I'm trying to understand how to write it now. :p
09:04:56 <obadz> Quenty: why aren't you happy with the way you've implemented it?
09:05:03 <obadz> Quenty: you've already written it.
09:05:55 <Quenty> The end goal is to learn. :p
09:06:25 <prsteele> Quenty: https://en.wikibooks.org/wiki/Haskell/Pattern_matching#As-patterns
09:06:26 <Quenty> >tail "abc"
09:06:34 <ww> the difference, i think, is that suffix will keep appending empty lists on the end forever
09:06:36 <Quenty> > tails "abc"
09:06:38 <lambdabot>  ["abc","bc","c",""]
09:06:51 <Quenty> ww: It does.
09:07:16 <ww> because it doesn't have a "what do i do with an empty list"
09:07:50 <Quenty> I tried to define that, and it didn't like my length method
09:07:52 <Quenty> where
09:08:12 <prsteele> Quenty: there should be no particular reason to use length. Pattern match against the empty list 
09:08:12 <Quenty> | (length str > 0) = ...
09:08:18 <prsteele> @src tails
09:08:18 <lambdabot> tails []         = [[]]
09:08:18 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
09:08:21 <obadz> > takeWhile (/= []) $ iterate (drop 1) "test"
09:08:22 <lambdabot>  ["test","est","st","t"]
09:08:24 <Quenty> | [] = [[]]
09:08:27 <Quenty> oh. ok.
09:08:34 <prsteele> Quenty: that first line "tails [] = [[]]" guards against the empty list
09:08:45 <Quenty> Where 
09:08:55 <Quenty> tails(x:xs) is a pattern
09:08:59 <Quenty> er...
09:09:13 <prsteele> Quenty: "tails [] = [[]]" says if you pass [] to tails, evaluate to [[]]
09:09:28 <prsteele> Quenty: it is fine for a function to have multiple patterns. Tails has 2 patterns
09:09:28 <Quenty> Yep. That makes sense.
09:09:50 <Quenty> The second pattern is xss@(_:xs)
09:09:53 <Quenty> where we don't care about _
09:09:56 <prsteele> Quenty: [] matches the empty list, while xxs@(_:xs) will match against non-empty lists
09:10:03 <Quenty> Can I do
09:10:24 <Quenty> tails aab@(_:ab) = abb : tails ab
09:10:36 <ww> (_:xs) matches non-empty lists because of the :
09:10:40 <mauke`pwd`> no, abb is not in scope
09:10:54 <ww> unless that was a typeo...
09:11:02 <mitu> https://github.com/tumist/echo # This is minimal code to reproduce a behaviour with "cabal run" that took me a while to figure out. Would you consider this a bug?
09:11:09 <Quenty> Typo
09:11:39 <ww> @src tails
09:11:40 <lambdabot> tails []         = [[]]
09:11:40 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
09:11:46 <Quenty> So this appends to xss the parameter xs
09:12:00 <ww> so that's exactly the second line that'you've written there with different variable names
09:12:07 <prsteele> xxs refers to _:xs, whatever _ happens to be
09:12:39 <tommd> I'm mildly frustrated by the AD package's descent function not actually decending.  If any maintainers are here and up for discussing the issue I'd be happy to learn the guts and contribute.
09:12:43 <ww> another, clumsier, way to write it would be:
09:12:55 <ww> tails (x:xs) = (x:xs) : tails xs
09:13:15 <Quenty> Right.
09:13:23 <Quenty> > 4 : []
09:13:25 <lambdabot>  [4]
09:13:34 <Quenty> > [4] : []
09:13:35 <lambdabot>  [[4]]
09:14:14 <ww> tommd: not a maintainer, but interested because i soon will have to use that...
09:14:34 <darveter> > iterate tail [1,2,3,4]
09:14:35 <lambdabot>  [[1,2,3,4],[2,3,4],[3,4],[4],[],*Exception: Prelude.tail: empty list
09:14:37 <DanC__> bless me father, it's been many months since my last attempt to get cabal working.
09:14:50 <DanC__> cabal: At least the following dependencies are missing:
09:14:50 <DanC__> GenericPretty ==1.2.*,
09:14:51 <DanC__> etc.
09:14:59 <DanC__> I'm trying to build https://github.com/monte-language/masque
09:15:06 <tommd> ww: I'm talking about issue #45, so it is already reported.  I'm just willing to invest time to fix the issue myself and would prefer to have a guided tour of the algorithm first.
09:15:06 <Zekka|Sigfig> darveter: ‘tails’ will do the same without crashing after the last list
09:15:10 <ww> DanC__ of #swig?
09:15:13 <darveter> > takeWhile (not.null) $ iterate tail [1,2,3,4]
09:15:14 <Zekka|Sigfig> Oh wait! You were told!
09:15:15 <lambdabot>  [[1,2,3,4],[2,3,4],[3,4],[4]]
09:15:18 <DanC__> ww, the same
09:15:24 <ww> hello!
09:15:25 <Zekka|Sigfig> Never mind, I am a bad helper
09:15:26 <darveter> Zekka: exactly
09:15:31 <DanC__> hi
09:16:16 <hexagoxel> mitu: depends.. `cabal exec` shows the same behaviour already, and i strongly assume it is on purpose.
09:16:32 <Cale> DanC__: try just  "cabal install"  from the directory containing the .cabal file
09:16:32 <hexagoxel> mitu: e.g. cabal exec -- sh -c "echo $PATH"
09:16:38 <DanC__> cabal told me to `cabal update` and then to `cabal install cabal-install` but my symptoms persist.
09:16:48 <hexagoxel> mitu: versus just echo $PATH
09:17:10 <ww> DanC__: are you running it in a sandbox? first i'd blow away the current sandbox and try from the beginning
09:17:23 <DanC__> cabal: Could not resolve dependencies: ...
09:17:39 <roelof> Last question of the day : Is this good haskell (makeLoan dBase pers bk = [ (pers,bk) ] ++ dBase ) I read somehow to ++ needs to be avoided because of perfomance 
09:17:40 <hexagoxel> mitu: at the least it could be considered a documentation bug..
09:17:49 <ww> cabal version?
09:17:51 <DanC__> I don't know if I'm running in a sandbox. I did `git clone` and then followed the readme instructions: `cabal configure`, `cabal build`
09:18:10 <DanC__> $ cabal --version
09:18:10 <DanC__> cabal-install version 1.22.6.0
09:18:10 <DanC__> using version 1.22.3.0 of the Cabal library
09:18:20 <ww> DanC__: that's not a sandbox, that'll all go in your ~/.cabal directory
09:18:25 <GLM> Is anyone here familiar with the STM library? I was wondering how your can use it with databases as it looks like those would have to use unsafeIO
09:18:36 <ww> the first instruction (nowadays) should probably be "cabal sandbox init ."
09:18:50 <DanC__> should I undo anything 1st?
09:19:06 <DanC__> cabal: Unknown 'sandbox' subcommand: init .
09:19:17 <ww> you might remove, or move out of the way your ~/.cabal if it's got its knickers in a twist.66
09:19:19 <kadoban> ww: The first instruction should be to just use 'stack' ;)
09:19:26 <triliyn> roelof: ++ is fine if you know the list on the left is short. In fact, your expression trivially reduces to (pers, bk) : dBase and should have roughly the same performance characteristics
09:19:32 <threeclub> Hi
09:19:46 <ww> DanC__: no "." my mistake
09:19:48 <tommd> GLM: Indeed, don't call external databases from within the STM monad.
09:19:53 <darveter> Zekka: "‘tails’ will do the same" is what I meant by "exactly" 
09:19:59 <kadoban> Though I dunno how stack does on older GHCs, like 7.6 or whatever base 4.6 is.
09:20:00 <tommd> GLM: There is an unsafeIOtoSTM operation, but it is... unsafe.
09:20:08 <DanC__> I seem to remember some bogeymen live in ~/.ghc/ too, so: `rm -rf ~/.cabal/ ~/.ghc/`
09:20:14 <ww> yeah
09:20:23 <DanC__> I have nix installed; maybe I can start from that somehow?
09:20:58 <roelof> triliyn:  and how can I do the best for big lists ? 
09:21:00 <GLM> tommd:That was the thing I was referring to. It seems like the point of STM is lost on me then. Most of my concurrency needs revolve around cases like banks for withdraw, insert cases
09:21:12 <DanC__> with ~/.cabal gone, I'm down to cabal-install version 1.18.0.5 (from Ubuntu, I suppose)
09:21:49 <ww> so, cabal update first
09:21:58 <ww> then cabal install cabal
09:22:07 <ww> should get you a recent one in ~/.cabal/bin
09:22:20 <ww> with everything clean
09:22:39 <mitu> hexagoxel: thanks for looking at it. I'll just call it a gotcha. In the repo I linked it's quite obvious that the program is restarting, but I ran in to this in another project where it wasn't as obvious
09:23:02 * ww does similarly, i've been in c++ land the past couple of months *shudder*
09:23:07 <triliyn> If you're recursing with a big list on the left, you can build up the list backward and then reverse it at the end
09:23:16 <tommd> GLM: STM is great... when STM is great for your use case.  For example, if you have multiple threads that operate over more than one haskell reference (MVar, IORef, etc) then you can instead have those threads operate on TVars and worry less about locking issues.
09:23:19 <DanC__> Building Cabal-1.22.4.0...
09:23:27 <threeclub> From LYHFGG:
09:23:27 <threeclub> Why is
09:23:27 <threeclub> lucky :: (Integral a) => a -> String  
09:23:27 <threeclub> lucky 7 = "LUCKY NUMBER SEVEN!"
09:23:30 <threeclub> OK, and
09:23:33 <threeclub> lucky :: (Num a) => a -> String  
09:23:36 <threeclub> lucky 7 = "LUCKY NUMBER SEVEN!"
09:23:40 <threeclub> Is not. Thanks
09:23:52 <GLM> tommd:What would I use in the database case then?
09:24:01 <triliyn> roelof: or there are also difference lists, which (hand-waving a bit) basically accumulate all the appends you want to do and then do them all at once
09:24:09 <tommd> GLM: However, you want to interact with a database, presumabely getting query results and taking actions. Naturally the GHC RTS has no control over the external world.
09:24:28 <tommd> GLM: Well, many databases have a concept of transactions, no?
09:24:36 <roelof> triliyn:  oke, so for big lists use [elem : list]   
09:24:48 <kadoban> DanC__: Unless you're in love with cabal, I'd recommend switching to the 'stack' tool. It's not going to be a magic fix on that project because it's not already configured for 'stack', and it's using an old GHC, but I still would think it'll be better. At least you don't have to worry about fun sandboxes and stuff, and you get to skip the "wipe everything out and start again" routine every couple of weeks.
09:24:49 <ww> DanC__: basically the only thing i keep in ~/.cabal is a recent version of cabal + dependencies, everything else i put in sandboxes
09:25:03 <tommd> GLM: Otherwise you will need some sort of DB manager in your program that deconflicts things.  Perhaps this manager can benefit from STM, but that depends a lot on your program's architecture.
09:25:06 <GLM> tommd:They do but if I want to make two conflicting transactions at the same time, I might want behavior similar to STM
09:25:42 <ww> tommd: "Seriously, this gradientDescent code was not intended for serious use" <- good to know!
09:25:49 <DanC__> I think I'll keep stack on my todo list for just a bit longer
09:26:03 <tommd> ww: Yep,  I learned that there too.
09:26:12 <DanC__> Installed cabal-install-1.22.6.0
09:26:20 <tommd> ww: So I then switched to conjugated GD... which performs incorrectly.
09:26:38 <DanC__> so... now `cabal sandbox init`?
09:26:41 <tommd> So no I am stuck fixing, making my own, or hoping.  I don't like the "hoping" option, so I am selecting option 1.
09:26:43 <GLM> tommd:Would that manager just have a variable for each table in the DB and retry when it can't access it?
09:27:00 <ww> i think, from the sound of it, gradientDescent means "steepest descent" which is not particularly good anywyas
09:27:01 <triliyn> roelof: not sure what you mean by that. As an expression, that is basically the same as [[elem] ++ list]
09:27:04 <ww> DanC__: yep
09:27:13 <triliyn> which is to say, it returns a list of lists
09:27:24 <mauke`pwd`> threeclub: probably missing an Eq constraint on 'a'
09:27:35 <DanC__> is `cabal configure` still relevant?
09:27:36 <mauke`pwd`> :t let lucky 7 = "..." in lucky
09:27:37 <lambdabot> (Eq a, Num a) => a -> [Char]
09:27:49 <DanC__> in https://www.haskell.org/cabal/users-guide/installing-packages.html I see cabal install --only-dependencies
09:28:39 <mauke`pwd`> threeclub: Integral requires Real requires Ord requires Eq, so it's implicit there
09:28:46 <DanC__> `cabal install --only-dependencies` loses with rejecting: base-4.7.0.1/installed-1a5... (conflict: masque => base>=4.6 &&
09:28:46 <DanC__> <4.7)
09:28:54 <ww> DanC__: yes. for working with source code as opposed to installing for production use, --only-dependencies and then build
09:29:39 <ww> DanC__: so, too old...
09:29:51 * ww scrolls up to find the thing DanC__ is trying to build
09:30:04 <DanC__> https://github.com/monte-language/masque
09:30:41 <kadoban> DanC__: You're using the wrong version of GHC. You need one in the 7.6.x range to match that base.
09:31:03 <kadoban> DanC__: Or you can try changing the .cabal and seeing if it'll work in newer. No idea how likely that is.
09:31:04 <ww> DanC__: what breaks if you remove the upper constraint on base?
09:31:18 <ww> ah, what kadoban says
09:31:35 <DanC__> I seem to have ghc 7.8.3
09:31:43 <dcoutts> DanC__: that says masque cannot be installed because it requires a different base version
09:32:00 <dcoutts> DanC__: if you want to make it work with your ghc version then yo
09:32:09 <dcoutts> then you'll need to edit the package
09:32:17 <threeclub> mauke`pwd`: Thanks!
09:32:24 <ww> masque.cabal in particular
09:32:26 * DanC__ tries removing the upper constraint...
09:32:27 <dcoutts> DanC__: possibly just relaxing the constraint, but more likely also some code tweaks
09:32:43 <DanC__> `cabal install --only-dependencies` is happier now...
09:32:47 <Ryth> Hey guys.. I got a question.. I got a function: (test x = f x / 100) where f returns an integer. I want test to return a Double but I´m getting the following error: Couldn´t match excepted type ´Double´ with actual type ´Int´. How do I solve this? Does Haskell have some type of casting?
09:33:10 <Ryth> expected*
09:33:27 <hexagoxel> :exf Int -> Double
09:33:28 <exferenceBot> realToFrac
09:33:28 <exferenceBot> fromIntegral
09:33:29 * DanC__ saw realToFrac used for that sort of thing
09:34:03 <ww> or fromIntegral
09:34:29 <ww> or, easier
09:34:33 <ww> > 100 :: Double
09:34:34 <lambdabot>  100.0
09:34:35 <kadoban> Ryth: So there's no real casting, per-se, there's just functions with the correct type to convert for you, essentially.
09:34:50 <Ryth> ah, I see
09:34:58 <Ryth> will try it out, thanks
09:35:48 <max3> can someone tell me why this doesn't work: foldl (++) [] [1,2,3]
09:36:35 <max3> can someone tell me why this doesn't work: foldl (++) [] [1,2,3]
09:36:49 <Hafydd> max3: I didn't hear you the first two times. Could you say that again?
09:37:04 <Hafydd> max3: because (++) operates on lists, but you've supplied a list of numbers.
09:37:04 <max3> can someone tell me why this doesn't work: foldl (++) [] [1,2,3]
09:37:24 <kadoban> max3: What do you expect it to do?
09:37:26 <max3> is a list of numbers not a list?
09:37:34 <max3> act as the identity 
09:37:47 <kadoban> max3: (++) operates on two lists. You're essentially asking for  [] ++ 1
09:37:47 <Hafydd> max3: no, but the function supplied to foldl operates on the list elements, which in this case are numbers.
09:37:53 <kadoban> :t foldl
09:37:56 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
09:37:56 <max3> ah
09:37:57 <max3> right
09:37:59 <max3> gotcha
09:38:23 <hexagoxel> > foldl (++) [] _
09:38:25 <lambdabot>      Found hole ‘_’ with type: t0 [a]
09:38:25 <lambdabot>      Where: ‘t0’ is an ambiguous type variable
09:38:25 <lambdabot>             ‘a’ is a rigid type variable bound by
09:38:27 <prsteele> > foldl (++) [] [[1], [2], [3]]
09:38:28 <lambdabot>  [1,2,3]
09:38:32 <max3> i guess i need a lambda to really make that work
09:38:56 <Hafydd> You don't need a lambda to write down the identity function.
09:39:00 <Hafydd> > id [1,2,3]
09:39:02 <lambdabot>  [1,2,3]
09:39:07 <max3> unless there's some function i don't know about that does [] `f` 1
09:39:18 <max3> it's an exercise in foldl
09:39:23 <prsteele> foldr (:) [] [1, 2, 3]
09:39:30 <max3> i wanted parity with foldr
09:39:34 <max3> using foldl
09:39:46 <Hafydd> > foldl (flip (:)) [] [1,2,3]
09:39:48 <lambdabot>  [3,2,1]
09:40:15 <max3> is there no function f that does [] `f` 1 -> [1]
09:40:47 <kadoban> :t flip (:)
09:40:49 <lambdabot> [a] -> a -> [a]
09:40:55 <kadoban> max3: That ^
09:41:16 <kadoban> max3: But it's not going to lead you to solving the equation    foldl f [] === id
09:41:43 <DanC__> ok... I got it to build... but now I can't load it into emacs inferior haskell; the interpreter doesn't seem to see the sandbox
09:41:45 * DanC__ googles...
09:42:01 <max3> kadoban: because it reverse the list
09:42:32 <kadoban> max3: Yes.
09:42:57 <max3> foldl (\acc x -> acc ++ [x]) [] === id
09:43:24 <Hafydd> max3: in that case, using a lambda expression is about as good as you can get; alternatively, you could use:
09:43:27 <Hafydd> > foldl ((. pure) . (++)) [] [1,2,3]
09:43:29 <lambdabot>  [1,2,3]
09:43:51 <max3> what is pure?
09:44:01 <prsteele> :t pure
09:44:01 <kadoban> :t pure :: a -> [a]
09:44:03 <lambdabot> Applicative f => a -> f a
09:44:03 <Hafydd> For lists, pure x = [x].
09:44:03 <lambdabot> a -> [a]
09:44:05 <prsteele> > pure 1 :: [Int]
09:44:06 <lambdabot>  [1]
09:44:26 <kadoban> So it's (\x -> [x])
09:44:35 <Hafydd> Yes, or (:[]), if you prefer.
09:44:36 <kadoban> Aka (:[])
09:44:54 <kadoban> But those are fugly, so 'pure' is nice, even though it's more polymorphic than it needs to be.
09:45:29 <orion> Is anyone else extremely annoyed/disappointed that crypto-api and cryptonite don't provide abstractions for variable output length hashes?
09:45:31 <max3> is pure not in prelude?
09:45:39 <Hafydd> (++) is also "more polymorphic than it needs to be" for operating on lists of ints.
09:45:45 <tommd> orion: Not me ;-)
09:45:46 <prsteele> max3 it is in 7.10, at least
09:45:50 <kadoban> max3: It's in Control.Applicative in GHC < 7.10
09:46:00 <dmj> is there a boolean typeclass? if I had newtype IsDeleted = IsDeleted Bool, would be nice to call 'not (x :: IsDeleted)' instead of manual unwrapping
09:46:02 <max3> ah i'm using hugs (don't kill me i know)
09:46:03 <prsteele> max3 you could use return instead
09:46:18 <prsteele> > return 1 :: [Int]
09:46:19 <lambdabot>  [1]
09:46:24 <orion> tommd: https://github.com/haskell-crypto/cryptonite/issues/44 <-- I was very disappointed to read this.
09:46:27 <tommd> orion: Do you actually think someone would use the API with a variable output length hash?  Very few users of the API exist in the first place.  Even fewer users exist for variable lenght hashes.
09:46:32 <kadoban> max3: Well, Control.Applicative probably exists, I think. But wow, hugs? Weird.
09:46:45 <tommd> orion: Who wants a generalization of a class of variable length hashes?  (besides you)
09:46:59 <max3> why would i ever need to use `id` ?
09:47:02 <orion> My friend Mike.
09:47:06 <max3> just wondering
09:47:11 <orion> And his dog.
09:47:24 <kadoban> max3: In cases where you have a higher-order function that takes a function, but you don't actually need one.
09:47:24 <prsteele> max3: you wouldn't unless you are working inside a higher level abstraction
09:47:37 <max3> kadoban: ah right
09:47:47 * DanC__ upgrades haskell-mode... wins!
09:47:51 <tommd> max3: For function application.
09:47:58 <max3> yes
09:48:05 <max3> okay thanks for all the help
09:48:35 <tommd> orion: In the case of crypto-api, there is no way to make the same API for a variable length hash.
09:48:51 <tommd> One of the features of the API is the ability to query the digest type for the length.  
09:49:16 <tommd> It would then have to return an ADT with possibly a range of lengths, which would be cludgy, at best, for the majority of users.
09:49:26 <orion> Right, that means the abstraction is wrong.
09:49:48 <tommd> orion: No, I'd say you are wanting the tail to wag the dog. The abstraction speaks to the majority of uses, not the corner case use.
09:50:21 <ww> DanC__: yay!
09:50:26 <tommd> Nothing prevents someone from making and using a variable length hash.  I can't think of an instance where you want a function to be polymorphic over a set of variable length hashes..
09:50:46 <DanC__> well... but the new haskell mode doesn't have the "find definition" thingy that started me on this journey
09:50:58 <tommd> But if you can then there could be another class VarHash and we could have class VarHash c d => Hash c d where ...
09:51:01 <orion> tommd: I think I should just write my own blake2 library then. :p
09:51:56 <tommd> orion: That or include it in an existing library but don't rely solely on the class-based interface.
09:54:31 <orion> tommd: The sad part is that because it doesn't fit in to the crypto-api typeclass, I can't make use of the HMAC faculties it provides.
09:56:14 <tommd> orion: Ah, I see.  So you want a variable length HMAC too?  Odd, seeing as Blake2 (and all SHA3 finalists) don't really need HMAC.
09:56:24 <tommd> orion: At any rate, notice HMAC is really easy to write.
09:56:58 <tommd> For example, one can translate HMAC into a higher order function that doesn't use classes.  That should be simple.
10:02:19 <tommd> orion: My reading of Blake2 is that it is NOT a traditional variable length hash.
10:02:33 <tommd> Notice "RETURN first "nn" bytes from little-endian word array h[]"
10:02:38 <ww> DanC__: so it was a gratuitous version constraint?
10:02:54 <tommd> So the hash does not change with intended output length - it is just a truncation.
10:03:22 * hackagebot nested-routes 6.1.0 - Declarative, compositional Wai responses  https://hackage.haskell.org/package/nested-routes-6.1.0 (athanclark)
10:03:22 <tommd> This means you can implement for the maximum value of 'nn' and take what you want from the front in most uses.
10:04:03 <tommd> orion: This is doable because the value 'nn' has a finite maximum.
10:05:44 <stoogenmeyer> morning peeps
10:10:51 <tommd> orion: Ah, I am wrong I see.  I forget 'nn' was included in the actual computation.  Shucks.
10:13:22 <stoogenmeyer> I'm trying to run quickCheck and can't figure out why it's failing.. does anyone mind taking a quick look? https://gist.github.com/rikonor/9e3a7172e2148354cc50
10:16:11 <nfk> it's time to begin work on my bachelor's thesis and i'm trying to decide between 3 languages - haskell, lisp (smalltalk/closure?) and ruby; the solution will be solving linear constraints which is simle enough even trivial.. until it gets to thousands of such constraints that all need to be satisfied and i'm wondering how suited haskell is for such task
10:18:02 <tommd> nfk: I'd say quite suitable.  Writing satisfiability solvers is great fun and Haskell abstracts out many headaches.
10:18:22 <tommd> If you don't want to write the SAT solver then you can just leverage one (or many) using SBV or other libraries.
10:18:35 <nfk> sbv?
10:18:40 <tommd> @hackage sbv
10:18:40 <lambdabot> http://hackage.haskell.org/package/sbv
10:19:06 <tommd> nfk: You could also use cryptol, but that isn't general purpose and I'm unclear about all your requirements.
10:20:31 <nfk> tommd, i guess in this case i can be more specific, it's for my unis lecture planning
10:20:53 <nfk> starting with students picking B part courses down to there being a free computer lab if required
10:21:49 <nfk> it seems so easy it's mind boggling that there's 4 previous attempts (one included me as part of a sophomore team)
10:22:09 <nfk> or rather, sophomore bunch, you can't call that mayham a team
10:25:09 <aweinstock> nfk: if it has to scale, haskell is probably a good bet, since you can easily play with algorithms, and then fine-tune them
10:25:59 <aweinstock> (the same applies to common-lisp regarding fine-grained performance tuning, but not to smalltalk/clojure/ruby without having to write some C FFI stuff
10:26:21 <nfk> it's for faculty so something like 1000-2000 students, tens of rooms and probably tens of lecturers
10:28:36 <nfk> speaking of the devil, how well it works on windows and interoperates with .NET? the current studies management system which does not do lecture planning or even non-standart study plans (so few premade B part course choices only) is written in .NET and i'm not even sure if there's source code available or if it can be edited
10:28:51 <tommd> nfk: But what technical problems are being solved?  Do we need IO like networking or just to encode logical problems and obtain satisfying assignments?
10:29:41 <nfk> tommd, there's probably gonna be network IO to get dependencies between courses from an interuni system which, hopefully, is open enough and the rest is local to uni/faculty
10:29:43 <tommd> Interact with .NET?  What monster are you talking about now?  If you must interact with .NET then either 1. Pick a .net language or 2. Define an IPC (such as UDP + json).
10:29:58 <nfk> oh, and students will of course be picking B part courses online
10:30:00 <nfk> naturally
10:30:28 <tommd> Oh oh, I get it.  You are trying to solve a scheduling problem with students, rooms, lectures, etc!  OK!
10:30:53 <nfk> tommd, that's a good question, basically last time i checked the development was outsourced and i'm not sure if uni even has the source code
10:30:53 <tommd> So that is the problem and the solutions should be "Easy" to extract into the wider university system.
10:31:30 <nfk> tommd, yeah, even just having to retype it manually would probably save days and sanity
10:31:39 <tommd> OK, I'd use Haskell, make a symbolic version of your constraints, and call SBV.  SBV will give you a model (a "solution" to your problem) or tell you no solution exists.
10:31:45 <nfk> as currently the entire planning process is manual
10:34:11 <nfk>  tommd, thanks for the pointers, i'll look around and see what kind of a proof of concept i can hack together
10:49:52 <shinka> I always assumed TCO was part of the Haskell language, but it is? In short, is TCO an optimization that is guaranteed by the standard in some precise circumstances?
10:50:23 <mauke`pwd`> haskell doesn't have a call stack
10:50:46 <prsteele> shinka: laziness makes it so we often don't care about not being tail recursive
10:52:20 <shinka> Yeah, I know, but I wanted to know if it was part of the standard, if it was part of the language or just an optimization some compilers do.
10:52:50 <mauke`pwd`> there is no call stack
10:52:52 <jophish> Are either Bas or Roel van Dijk here?
10:55:40 <Zekka|Sigfig> > foldl (+) 0 [1..60000]
10:55:42 <lambdabot>  <hint>:1:11: lexical error at character '\FS'
10:56:19 <Zekka|Sigfig> hm, anyone know what that means?
10:56:26 <quicksilver> yes
10:56:32 <quicksilver> you typed something funny before the 0
10:56:35 <prsteele> > foldl (+) 0 [1..10]
10:56:36 <lambdabot>  55
10:56:50 <Zekka|Sigfig> > foldl (+) 0 [1..100000]
10:56:52 <lambdabot>  5000050000
10:57:03 <quicksilver> \FS, U+001C, file separator
10:57:03 <Zekka|Sigfig> Hm. I seem to remember if you feed it a large enough input range it will throw a fun error
10:57:12 <prsteele> Zekka|Sigfig: if you can't see it in your editor/client, you had a non-printable char before 0
10:57:15 <Zekka|Sigfig> > foldl (+) 0 [1..10000000]
10:57:19 <lambdabot>  mueval-core: Time limit exceeded
10:57:21 <prsteele> shows up as ^\0 on my screen
10:57:24 <Jello_Raptor_> If I'm wiriting a quasi quoter, is there some way to get the location of the string in a source file for error messages? 
10:57:28 <Jello_Raptor_> writing* 
10:57:29 <Zekka|Sigfig> prsteele: Looks like there’s something funny about my client then
10:57:45 <Zekka|Sigfig> because I hadn’t copy-pasted, but instead entered my code directly
10:57:54 <prsteele> Zekka|Sigfig: well its a non-printable char. I'm using IRC within Emacs, so it just displays it the way any non-printable char is displayed
10:58:08 <prsteele> ah
10:58:16 <quicksilver> > chr( ord 'a' + ord '\FS' - 1)
10:58:18 <lambdabot>  '|'
10:58:19 <Zekka|Sigfig> prsteele: Yeah, I get you. I’m just saying that it looks like for some reason my client autoatically introduced it.
10:58:28 <quicksilver> it was ctrl-| otherwise known as crtl-\
10:58:29 <prsteele> yup
10:58:43 <Zekka|Sigfig> It’s colloquy, some funky Mac client I don’t trust.
11:11:14 <roelof> when I want to use a template engine with Servant, What is the best and safest one to make a page like this : Hello, what is the best template engine to make a page like this : https://laboutique.lemonstand.com/
11:16:03 <zomg> I think "best" largely depends on what you're after
11:16:22 <roelof> zomg:  a safe site 
11:16:27 <zomg> blaze-html is a nice HTML EDSL, there's also more HTML-like ones like Hamlet
11:16:44 <zomg> I don't really know what "a safe site" means in this instance... you mean one where you don't have security exploits?
11:17:36 <roelof> zomg:  exactly , I mean one with the lowest change on xss and sql exploits 
11:18:22 <zomg> Well, any templating engine which escapes values by default would be a good first step, but you need to take care with your client side scripting and backend code as well
11:18:36 <zomg> There's also stuff like CSRF which you would need to safeguard against when using forms
11:18:47 <roelof> correct, I know 
11:19:24 <roelof> and there are a lot of choices , so I want to ask the experts here
11:19:50 <zomg> tbh any template engine can be used as long as you know how it works so you know what you need to do to keep things safe :)
11:19:52 <DanC__> how can I tell which module a type was imported from?
11:21:24 <roelof> zomg:  oke, then I have to google on which one is the most tutorials so I can figure out how the engine works 
11:22:06 <zomg> roelof: usually it's enough to know if it escapes values or not when you output them, and how it does that, so you know where the values can be used safely
11:22:17 <zomg> (which is generally mentioned in the docs)
11:22:40 <roelof> oke, then I will try some and look which one fits the best for me 
11:26:21 <quicksilver> DanC__: :info
11:26:47 <DanC__> Top level: Not in scope: data constructor ‘Typeable’
11:27:48 <DanC__> I suppose it's a typeclass, not a type
11:27:55 <quicksilver> :info works on those two
11:28:01 <quicksilver> I mean, those too :)
11:28:09 <quicksilver> :info works on type, typeclasses and constructors
11:28:19 <quicksilver> it must not be imported in your ghci session
11:28:27 <quicksilver> you can also try hoogle
11:28:27 <shachaf> quicksilver: Yep, it works on those three.
11:28:43 <quicksilver> shachaf: quite :)
11:28:59 <quicksilver> DanC__: https://www.haskell.org/hoogle/?hoogle=Typeable
11:29:02 <DanC__> I can do `:i Pattern` where Pattern is defined in the module I'm working with...
11:29:07 <shachaf> But DanC__'s error message suggests using :t rather than :i
11:29:23 <DanC__> well, I'd rather not use hoogle; I'd rather follow-my-nose thru the code
11:29:37 <quicksilver> that's true, that error message is a :T error
11:29:43 <quicksilver> the :i error doesn't mention data constructors
11:30:15 <DanC__> how do I get all of this modules' imports in scope in my ghci session?
11:31:03 * DanC__ reads https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/interactive-evaluation.html#ghci-scope ...
11:31:10 <quicksilver> if you load your .hs file
11:31:16 <quicksilver> then all its imports will be in scope
11:31:46 <quicksilver> I use C-c C-l to load the current file into ghci, which is an emacs haskell-mode thing, but other things exist for other editors
11:32:24 <DanC__> I'm using emacs...
11:32:32 <DanC__> but C-c C-l complains...
11:33:26 * hackagebot th-kinds-fork 0.2 - Automated kind inference in Template Haskell.  https://hackage.haskell.org/package/th-kinds-fork-0.2 (DavidFox)
11:33:28 * hackagebot urlpath 4.1.0 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-4.1.0 (athanclark)
11:33:29 <DanC__> "Run C-h f haskell-mode for instruction how to set up Haskell interaction mode". hm...
11:34:08 <DanC__> ok...
11:34:55 <DanC__> Defined in ‘Data.Typeable.Internal’
11:35:14 <johnw>  is there anyone here who is interested in becoming the new maintainer for the Haskell Platform, by chance?
11:35:23 <shachaf> :i will tell you where something was defined, not where it was imported from.
11:35:24 <DanC__> which is not imported. :-/
11:35:34 <shachaf> I think I filed a bug once asking for the latter to be printed.
11:35:38 <shachaf> But I don't remember.
11:36:00 <DanC__> learning to navigate haskell code is quite a challenge. for this tiny brain, anyway
11:37:25 <DanC__> I'm trying to move a data type decl out of a module into a smaller module, and I'm trying to figure out how many of the imports need to come along with it.
11:38:07 <DanC__> maybe in this case it's {-# LANGUAGE DeriveDataTypeable #-}
11:38:23 <prsteele> DanC__: trial and error is how I'd go about it. Just move it to a new module, compile, and see what errors crop up
11:39:04 <DanC__> er... there are 12 imports. so... 12 factorial trials?
11:39:57 <ReinH> DanC__: No. 12 or less trials.
11:39:57 <c_wraith> No, order doesn't matter, so only 2^12
11:39:59 <prsteele> DanC__: presumably the compiler would complain about certain types not being present in the new module?
11:40:32 <c_wraith> But really, less than 12. Just add things the compiler tells you are missing. 
11:40:33 <prsteele> but each import should either eliminate an error, or not
11:41:03 <ReinH> Assuming that GHC is able to detect all of the missing pragas, it will just tell you about each one after you add the previous one, in whatever order it detects them in.
11:41:08 <lvella> hi, I want to handle a list of temporal data, i.e. I peridically retrieve the data from a web service and go on processing it, but I am not sure how to do it in a functional way
11:41:11 <ReinH> *pragmas
11:41:12 <prsteele> add them all, and compile with -fwarn-unused-imports ?
11:41:13 <DanC__> suppose it complains about type T1; how does that help me figure out which of the 12?
11:41:42 <ReinH> prsteele: I always compile with Wall
11:41:59 <ReinH> That would work too
11:42:07 <DanC__> Wall sounds promising...
11:42:14 <lvella> I thought of writing a function that takes an infinite list, and then figure out to build that ever growing list via IO monad
11:42:21 <DanC__> I'm not sure how to compile just one file...
11:42:34 <DanC__> what I'd really like is for flycheck to color the bad ones
11:42:36 <ReinH> DanC__: You will often see errors that suggest a specific missing pragmas.
11:42:52 <ReinH> It'll color the unused ones.
11:43:20 <lvella> but that would not be that useful if my infinite list handling function doesn't have side effects of its own
11:43:31 <DanC__> flycheck can't find Control.Lens; I suppose it doesn't grok my cabal sandbox
11:43:50 <c_wraith> lvella: you can do that with unsafeInterleaveIO, but that's often unsatisfying. 
11:43:51 <ReinH> lvella: Perhaps you want to use a channel? It's hard to say.
11:44:03 * DanC__ reviews https://github.com/flycheck/flycheck/issues/293
11:44:45 <c_wraith> lvella: it's much more likely that what you want is something like pipes or conduits. Things that are designed for streaming with effects. 
11:45:16 <ReinH> DanC__: flycheck-ghc should Just Work with cabal sandboxes.
11:45:48 <DanC__> I wonder if I'm using flycheck-ghs; suggestions on how to tell?
11:45:50 <lvella_> channels and conduits
11:46:03 <lvella_> something went wrong with my connection
11:47:34 <DanC__> flycheck-ghc seems to be chosen
11:48:29 <tippenein> do the haddock generators on hackage just _not_ work?
11:48:36 <DanC__> is there a cabal command to compile just one file?
11:48:39 * hackagebot mtl-unleashed 0.6.1 - MTL classes without the functional dependency  https://hackage.haskell.org/package/mtl-unleashed-0.6.1 (DavidFox)
11:48:57 <augur> sclv: \o/
11:49:18 <augur> sclv: i'm glad my musings about calculating haskell programs wasnt too weird :)
11:49:56 <tippenein> I would use ekmett's script for manually uploading haddocks, but cabal is entirely broken due to El Capitan being an enormous shit pile
11:51:35 <hexagoxel> DanC__: cabal exec -- ghc Foo.hs
11:52:36 <DanC__> thanks... that's a step in the right direction...
11:53:39 * hackagebot th-context 0.23 - Test instance context  https://hackage.haskell.org/package/th-context-0.23 (DavidFox)
11:58:07 <ReinH> tippenein: I don't have any problems on El Capitan.
11:58:24 <ReinH> So I suspect that your anger is misplaced.
12:00:02 <bsmt> also 0 problems on 10.11
12:00:43 <bsmt> i've disabled SIP, but I don't think that would affect cabal at all
12:10:27 <jophish> is ndmitchell ever around?
12:11:52 <bitemyapp> jophish: not often
12:11:59 <bitemyapp> jophish: use ircbrowse to check.
12:14:42 <sleblanc> how come Hoogle will sometimes miss results? e.g. it did not return Data.Monoid as a result: https://www.haskell.org/hoogle/?hoogle=%3C%3E
12:19:24 <jophish> bitemyapp: thanks for pointing me to ircbrowse, very cool!
12:22:46 <bitemyapp> jophish: np
12:24:28 <nitrix> Is there a library similar to IntMap that works on Integer instead?
12:27:38 <prsteele> is there a way to hide _foo in "data Foo = Foo { _foo :: Int}" while not hiding the Foo constructor?
12:27:50 <prsteele> when I'm importing from another module?
12:28:09 <mniip> nitrix, Integer doesn't have the nice properties that Int has
12:28:29 <scshunt> prsteele: import Module (Foo(..))
12:28:50 <nitrix> mniip: I'm not following. All it needs is being orderable.
12:28:59 <prsteele> scshunt: import Module *hiding* (Foo(..)) ?
12:29:08 <mniip> nitrix, that's just Map
12:29:18 <mniip> IntMap is much more restrictive than that
12:29:42 <scshunt> prsteele: no
12:29:57 <scshunt> prsteele: Foo is the type name, Foo(..) or Foo(Foo) will import the constructors
12:30:05 <scshunt> _foo is a global name and so it's imported/exported like any other
12:31:19 <mniip> nitrix, for IntMap you need Num and Bits
12:31:34 <mniip> and those need to be really efficient if you want any performance improvement over Map
12:31:48 <monochrom> prsteele: I think "import F (Foo(Foo))" works. I just tried.
12:32:39 <monochrom> and "import F (Foo(..))" will get you _foo too, contrary to unempirically tested claims
12:33:40 <prsteele> monochrom: I ended up just "import Foo hiding (Foo(..)); import qualifed Foo as Bar"
12:33:46 <prsteele> monochrom: and sprinked a few Bar.'s around
12:33:48 <monochrom> if you prefer hiding, "import F hiding (_foo)" can do
12:34:30 <prsteele> monochrom: ya, unfortunately there are a *lot* of things I want to hide. I have two data decls with a dozen record accessors each of the same name in two different modules...
12:34:40 <monochrom> I do not understand "hiding (Foo(..))". it looks like anti-cancer drugs and radiation to me
12:34:50 <prsteele> something tells me I want lens, but I have never used them
12:36:15 <monochrom> if you have 50 things to import and 50 things not to import, there is no escape from listing 50 names. you only get to choose which side you list.
12:36:51 <prsteele> monochrom: yup, which is why is imported unqualified hiding that constructor, then imported that constructor qualified. I'll live with the qualifications
12:38:13 <monochrom> you said you have 2 type names and a dozen field names. do you also have a dozen constructor names?
12:38:56 <prsteele> monochrom: Just one constructor
12:39:01 <prsteele> with many fields
12:39:20 <monochrom> because if what you have are 2 type names, 4 constructor names, and 12 field names, then "import F (T1(C1, C2), T2(C3, C4))" gets the job done with only 6 names
12:40:39 <prsteele> hey that worked. "import Module hiding (Foo(..)); import Module (Foo(Foo))"
12:40:46 <prsteele> brings in everything *but* the record accessors
12:40:53 <prsteele> perfect
12:41:09 <monochrom> yeah that's much better
12:41:50 <prsteele> the module system is a pain (for me) in Haskell, but it is a solve once and forget type problem
12:45:09 <prsteele> monochrom: thanks
12:45:54 <monochrom> you're welcome
12:52:26 <peppe084> ciao
12:52:28 <peppe084> !list
12:52:28 <monochrom> peppe084: http://hackage.haskell.org/packages/
12:53:34 <quicksilver> jophish: ndmitchell is still active in the community but I've not seen him on IRC much for years
12:53:41 * hackagebot cql 3.0.7 - Cassandra CQL binary protocol.  https://hackage.haskell.org/package/cql-3.0.7 (ToralfWittner)
12:56:54 <jophish> quicksilver: that's ok, I can't remember what I wanted to ask him now anyway :)
13:03:09 <tommd> Yay, cql continues to live.
13:14:24 <Jello_Raptor_> hmm, are there higher kinded analogues of Functor? something like "data Foo (f :: * -> *) = Foo {Radius :: f Float, loc :: f Point, name :: f String}" possibly instantiated as "Foo ID" (so there's no instrumentation) or "Foo (,SourcePos)" (so now every element is a tuple that contains where the particular field is specified in the original shape definition file), along with the boilerplate that allows you to check whether (f :: * 
13:14:24 <Jello_Raptor_> -> *) preserves and allows you to change the original data? maybe you'd have a "Foo ZipList" to represent a set of circles or "Foo Maybe" to represent a partially specified circle. 
13:14:49 * Jello_Raptor_ isn't entirely sure where he's going with this idea ... 
13:15:33 <Jello_Raptor_> also that example could be better :P but you lot can figure it out. 
13:18:31 <Jello_Raptor_> My actual use case only needs "Foo Id" and "Foo (,SourcePos)" so I've just gone ahead and defined "Foo a = Foo {bar :: (Int,a), buzz :: (String,a)" with an instance of fmap to let me convert between "Foo SourcePos" and "Foo ()" and use things reasonably
13:18:35 <Jello_Raptor_> but even so.
13:19:06 <Jello_Raptor_> if there's a more powerful version of the same pattern it would be cool to know about. (likely too unwoedly to use for my current project) 
13:19:25 <quicksilver> Jello_Raptor_: there is no problem with having a higher kinded parameter to a data type like that.
13:19:33 <quicksilver> I'm not sure what you mean by 'higher-kinded functor'.
13:19:51 <quicksilver> but the thing you describe is certainly useful you have
13:20:11 <quicksilver> the Identity functor is called Identity not Id.
13:21:57 <mada> how can I tell stack test which module to test? `% stack test Course.Functor` doesn't work
13:22:05 <Jello_Raptor_> quicksilver: that's the missing bit, I want some way to say "f :: * -> *" preserves the original datatype in there somewhere, and boilerplate (probably lens based) that lets me work on fields in "Foo Identity" "Foo (,SourcePos)" and "Foo Maybe" independent of the wrappers   
13:22:23 <jophish> Jello_Raptor_: something like instance Functor f => Functor (Foo f a) where ...
13:22:29 <TheArtist> Hello guys! How do i do thread syncronization in haskell?
13:22:51 <tommd> TheArtist: Well an MVar suffices.
13:23:05 <TheArtist> this works like a mutex?
13:23:17 <tommd> Yes, one that carries a value.
13:23:32 <tommd> So just stuff () in it (or use an actual mutex, but MVars are convenient)
13:23:34 <sphinxo> How can I composite a function that returns an either to a function that takes the eithers right hand side?
13:23:42 * hackagebot tttool 1.5.1 - Working with files for the Tiptoi pen  https://hackage.haskell.org/package/tttool-1.5.1 (JoachimBreitner)
13:23:57 <tommd> :type either
13:24:04 <tommd> @type either
13:24:05 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
13:24:08 <TheArtist> tommd: Thanks! i'll check it out
13:24:50 <kadoban> sphinxo: The Functor instance can be useful there (of Either e)
13:26:02 <Jello_Raptor_> jophish: hmm, that works, the only missing bit is some way to turn "Foo Maybe" into "Foo Identity" according to some rule, but that would require a function that "forall a. Maybe a -> a". I'm not sure whether that would work in the general case. 
13:26:50 * Jello_Raptor_ should probably just try it
13:27:08 <quicksilver> Jello_Raptor_: well if you have a 'Functor Morphism'
13:27:16 <quicksilver> forall a . f a -> g a
13:27:18 <tommd> With programming that is usually the right atitude.  Not so much with civil engineering.
13:27:24 <quicksilver> then you can certainly 'map that'
13:27:32 <quicksilver> to take Foo f to Foo g
13:27:45 <quicksilver> perhaps that's what you meant by higher-order functor
13:28:02 <quicksilver> your 'Functor morphism' for Maybe -> Identity would have to be fromJust
13:28:11 <quicksilver> and that might make you feel queasy
13:28:15 <quicksilver> but it's what you're asking for?
13:28:42 <sphinxo> hmm, so what would be the correct way for these 2 functions?
13:28:50 <sphinxo> parseBF :: String -> Either ParseError Program
13:28:56 <sphinxo> and
13:28:59 <sphinxo> evalBF :: Program -> Either Tape EvalError
13:29:12 <quicksilver> fmap evalBF . parseBF
13:29:13 <sphinxo> actually the last one:
13:29:17 <sphinxo> evalBF :: Program -> Tape
13:29:39 <quicksilver> the fmap evalBF . parseBF :: String -> Either ParseError Tape
13:30:27 <quicksilver> this is what kadoban meant by 'the Functor instance of Either e'
13:30:32 <Jello_Raptor_> quicksilver: Yeah, but I'm not sure what the class that captures things like "Foo" would be, nor am I sure what the lenses/acessors would be typed as.
13:31:36 <quicksilver> Jello_Raptor_: I don't think you need a type class for what you're trying to do.
13:32:06 <quicksilver> at least, I haven't understood the generality you're looking for
13:32:24 <quicksilver> it's rather like https://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html
13:32:30 <sphinxo> How can I declare new error types?
13:32:32 <quicksilver> except that is specifically monads
13:33:20 <tommd> sphinxo: data SomeErrorType = Error1 | Error2 | ...
13:33:30 <sphinxo> Thanks
13:34:28 <tommd> Oh, did that actually answer your question?  I thought you'd come back with more specific requirements like exceptions or something.
13:35:24 <quicksilver> Jello_Raptor_: https://hackage.haskell.org/package/natural-transformation-0.2/docs/Control-Transformation.html
13:35:28 <quicksilver> Jello_Raptor_: I think that's what you have
13:39:50 <TheArtist> Any ideas how to avoid name collisions? I really keep hitting on lint warnings about shadowing global names in local definitions
13:40:51 <kadoban> TheArtist: Use more descriptive global names?
13:41:41 <TheArtist> well, i'm trying my best... But i usually hit on these with the names of the accessors in the records
13:42:29 <TheArtist> it would really be more helpful if the record accessors had some kind of pattern like SomeType.itsAccessor
13:42:38 <tabemann> what I do is put an abbreviated version of the type name at the start of each accessor
13:42:40 <TheArtist> yeah, i know too much of bad OOP style
13:48:50 <sphinxo> Could someone help me with this? http://lpaste.net/145062
13:49:23 <sphinxo> I would like the contents of the file to be passed to parseBF
13:50:26 <glguy> sphinxo: Do the same thing you did with getArgs, name the result of readFile filename with a <-
13:51:04 <pyrtsa> sleblanc: Spotted your question about poor results in the online Hoogle tool. It's been bugging me too, but I learned just now that there's a better version in https://www.stackage.org/lts/hoogle
13:51:11 <Lokathor> data HaskellSrcType = NumLit | StrLit | CharLit | ReservedWord | Import | Pragma | Comment | Haddock | Constructor | Binding | Operator deriving (Eq, Show)
13:51:28 <Lokathor> Did i forget any major category?
13:52:14 <sphinxo> how do I pass that value into the parseBF?
13:52:14 <kadoban> Lokathor: mobule Blah where …
13:52:56 <Lokathor> Ah, hmm, good point. Not quite a reserved word
13:53:09 <glguy> sphinxo: Same way you applied readFile to filename you can apply parseBF to the file contents
13:53:31 <monochrom> what is the type of parseBF?
13:53:46 <sleblanc> pyrtsa, I agree that stackage gives better results, but I believe that stackage does not have all the packages that hoogle has
13:54:16 <Lokathor> Sleblanc, hoogle is quite incomplete actually. Did you mean Hackage?
13:54:43 <pyrtsa> sleblanc: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ looks like a very limited list.
13:54:45 <kadoban> sleblanc: hackage's hoogle doesn't give you results from pretty much any packages, unless you know what package you're looking in. So in practice the stackage one is just more useful.
13:54:55 <jophish> quicksilver: instead of using fromJust it might be better to 'traverse' (Foo Maybe a) to get (Maybe (Foo Identity a))
13:55:03 <sphinxo> monochrom: parseBF :: String -> Either ParseError Program
13:55:58 <sleblanc> Lokathor, they both do not give very good results: https://hackage.haskell.org/packages/search?terms=%3C%3E https://www.haskell.org/hoogle/?hoogle=%3C%3E
13:56:11 <sphinxo> I'd like to do something like http://lpaste.net/145065
13:56:31 <sleblanc> Lokathor, when compared to Stackage, that is. http://www.stackage.org/lts-3.13/hoogle?q=%3C%3E
13:56:57 <monochrom> what is the type of evalBF? I think now I need to know it too. also, after that, there will be one more question.
13:57:14 <sphinxo> evalBF :: Program -> Tape
13:57:38 <sleblanc> https://www.stackage.org/lts-3.13/hoogle?q=gtk3 this gives no result, however https://www.stackage.org/lts-3.13/hoogle?q=gtk will, but the actual gtk package is listed as the 9th entry
13:57:42 <monochrom> ok, suppose "evalBF blahblah" works. you get something of type Tape. what do you want to do with it?
13:58:15 <sphinxo> Print it?
13:58:33 <monochrom> now I know all I need
13:58:57 <quicksilver> jophish: yes definitely.
13:59:19 <quicksilver> jophish: I don't know what 'traverse' that is, in general. Clearly I could write it by hand for Jello_Raptor_'s specific type.
13:59:40 <quicksilver> jophish: you can also 'traverse' Foo IORef a to get IO (Foo Identity a) where you look up all the IORefs, etc.
13:59:42 <lpaste_> monochrom annotated “No title” with “No title (annotation)” at http://lpaste.net/145065#a145066
13:59:46 <monochrom> like that
14:00:25 <jophish> quicksilver: yeah, I've been thinking about it. traverse' :: Traversable t => Foo t a -> t (Foo Identity a)
14:01:04 <sphinxo> Thanks monochrom 
14:01:39 <jophish> but that obviously doens't work with IORef
14:02:02 <sphinxo> How can I print something that looks like (repeat 0, 0, repeat 0)?
14:02:30 <jophish> but perhaps with fmap' readIORef where fmap' :: (f a -> g a) -> Foo f a -> Foo g a
14:02:34 <monochrom> first you have to solve the halting problem
14:02:39 <jophish> which is exactly where we started
14:02:40 <quicksilver> jophish: you don't need a traversable constrain
14:02:45 <sphinxo> ok brb monochrom 
14:02:51 <quicksilver> jophish: it's just
14:03:11 <monochrom> that is worth @remember :)
14:03:23 <quicksilver> traverse' :: Applicative t => (forall a . f a -> t (g a)) -> Foo f -> t (Foo g)
14:03:39 <c_wraith> monochrom: I can do that.. Just need a busy beaver oracle 
14:03:46 <sphinxo> say I have a type that looks like ([Int], Int, [Int])
14:03:54 <baweaver> beaver?
14:04:09 * baweaver should probably limit that highlight to ruby
14:04:16 <quicksilver> jophish: and it basically writes it self using the constructor and <$> and <*>, just like a normal 'traverse' does
14:04:16 <sphinxo> How can I print the center value and the last of the first array and the first of the last array?
14:04:41 <quicksilver> sphinxo: (\(ls,c,rs) -> (last l, c, head r)) ?
14:04:51 <jophish> quicksilver: you're quite right
14:04:56 <sphinxo> Thanks quicksilver 
14:05:03 <quicksilver> or, printthem (ls,c,rs) = print (last ls) >> print c >> print (head rs)
14:05:07 <quicksilver> if you actually want to print.
14:08:53 <z99z> Hi, is this a tail recurisve function?http://pastebin.com/jp2NR9YS
14:09:27 <monochrom> no
14:09:44 <c_wraith> z99z: has anyone explained that tail recursion isn't that useful in haskell? 
14:09:48 <z99z> Aha, otherwise I'm struggling to understand how exactly it works :/
14:10:36 <monochrom> tail or not, to understand recursive code, it is best to think in terms of induction proofs. it is worse to hand-execute yourself.
14:11:09 <monochrom> tongue-in-cheek reason: the computer has spent its life executing all kinds of recursive code. it has yet to understand anything.
14:11:12 <z99z> Once you call the where clause, what happens to the head, x? That's confusing me a little. Sorry, I'm new to Haskell
14:12:21 <monochrom> I do not think there is such a thing as "call the wehre clause".
14:13:09 <z99z> You know what I'm trying to say
14:13:24 <z99z> No?
14:13:26 <frerich> z99z: When splitAt is called with n /= 0 and a non-empty list, the 'x' (the head of the list) is prepended to the first tuple element
14:13:46 <monochrom> but you can pretend the code to read like this instead: ... else (x : fst (splitAt (n - 1) xs), snd (splitAt (n - 1) xs) )
14:13:56 <monochrom> no, I don't know what you're trying to say.
14:14:13 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #10
14:15:30 <sphinxo> monochrom: How would I not print anything at all?
14:15:41 <z99z> Thanks monochrom, that makes sense. But when it hits splitAt 0 does it create a tuple ([], (x:xs)) then?
14:15:54 <monochrom> yes
14:16:06 <monochrom> use "return ()" to not print, in fact do nothing
14:16:42 <z99z> How do we get rid of the [] though, I mean, doing x:([],(y:ys)) doesn't return ([x], (y:ys)), does it??
14:16:56 <sphinxo> monochrom: I still want to run evalBF
14:17:00 <monochrom> but no one is doing x:([],(y:ys))
14:17:53 <jophish> z99z: instead of thinking about the code execution as "hitting" different points, think about your program being a graph of expressions which is reduced when it's run
14:18:39 <z99z> jophish: What do you mean? 
14:19:55 <mniip> expression folding
14:20:06 <jophish> z99z: here's a page talking about it: https://en.wikibooks.org/wiki/Haskell/Graph_reduction
14:20:32 <monochrom> sphinxo: then I will need to know your purpose of running evalBF, if the purpose is not to print part or all of the answer eventually. do you do it to observe time spent? do you do it to observe memory spent? do you do it to observe electricity spent? do you do it to observe heat produced?
14:20:43 <z99z> Thanks jophish, so essentially just reduction of the program?
14:21:20 <jophish> z99z: exactly, it's a much more useful way of thinking about haskell program execution
14:21:21 <mniip> kinda but instead of being an expression tree the program is an expression graph
14:22:06 <mniip> let x = y * y in x + x
14:22:16 <mniip> reduces to 'y * y + y * y', but those y*y are the same
14:22:22 <monochrom> "tree vs graph" is only because you don't want to recompute "splitAt (n-1) xs" twice.
14:22:34 <mniip> "reducing" one automatically will do the same to the other
14:22:57 <sphinxo> monochrom: How could I observe time spent?
14:23:07 <monochrom> so in fact until you care about how much time and memory is spent, you actually don't care about "it is actually a graph". you can just do algebra and allow yourself re-computing things.
14:23:21 <dgpratt> just thought of a code editor feature I'd like to have: some visualization of the block structure under the cursor
14:23:41 <mniip> block structure as in?
14:23:51 <TheArtist> Any function to take a bool and a list and return the list on true or the empty list on false?
14:23:56 <dgpratt> indentation, grouping, whatever you call it
14:24:02 <mniip> layout
14:24:05 <dgpratt> that
14:24:18 <mniip> I think there was a vim plugin for that
14:24:22 <mniip> with colored tabs or something
14:24:30 <monochrom> sphinxo: my first approximate would be "evaluate (evalBF program)". but it is only a first approximation. it may or may not compute a lot of things. it depends on the implementation of evalBF.
14:24:39 <sphinxo> monochrom: Here is the full code http://lpaste.net/145067
14:24:42 <monochrom> "evaluate" is from Control.Exception
14:24:51 <mniip> :t bool []
14:24:52 <lambdabot> [t] -> Bool -> [t]
14:24:55 <mniip> TheArtist, ^
14:25:13 <TheArtist> wow nice one
14:25:34 <mniip> that might or might not be the wrong function
14:25:43 <mniip> :t bool [] "moo" True
14:25:44 <lambdabot> [Char]
14:25:47 <mniip> > bool [] "moo" True
14:25:48 <lambdabot>  "moo"
14:25:54 <mniip> yes it is the right one
14:26:10 <sphinxo> I'm not too worried about execution time monochrom 
14:26:13 <monochrom> ok, I think "evaluate (evalBF program)" is close enough for this
14:26:23 <mniip> evaluate $ force $ evalBF program ?
14:26:29 <mniip> (NFData)
14:26:40 <monochrom> mniip, two infinite lists are involved, you don't want to go that extreme
14:27:19 <mniip> ah
14:28:07 <monochrom> you have to carefully consider and decide, on a logically consistent answer, of "what do I want out of computing evalBF program, and yet not print any part of its answer?"
14:28:19 <monochrom> and put emphasis on "logically consistent"
14:29:18 <sphinxo> hmm I was thinking that as part of evalBF output would be printed
14:29:54 <monochrom> when you look at the type "Program -> Tape" you already know that no printing will happen
14:30:23 <monochrom> and if you reply "but ghci prints", then it's because ghci is a bloody REPL
14:30:45 <sphinxo> ahh, true, getting used to pure functions
14:31:25 <monochrom> and I say "bloody" because it is bloody. every feature you add to a REPL to make it more convenient means you deviate more away from standard behaviour, e.g., behaviour from compiled programs
14:31:49 <sphinxo> hmm, what do you suggest I do?
14:31:53 <monochrom> at the end, this conclusion is inevitable: whenever the REPL differs from compiled programs, the REPL is wrong.
14:32:19 <monochrom> the corollary is that the REPL loses its status as a reliable test platform
14:32:40 <pharaun> i use it as a way to explore things
14:32:42 <monochrom> to print an answer, use explicit "print" or "putStrLn"
14:32:47 <frerich> Hmm, I just read that "(\xs -> head xs + last xs) [1..n]" runs in constant space but "(\xs -> last xs + head xs) [1..n]" runs in linear space. Is that since (+) is strict in both its arguments and evaluates the left argument first, the first version does 'head' first and then, while evaluating 'last' it can garbage collect the list as it traverses it?
14:32:48 <cramp33> Is there already a name for \f x -> f x >> return x  ?
14:32:49 <pharaun> but when i want to test, i encode it into a unit test or quicktest
14:32:54 <pharaun> i avoid manual tests
14:33:04 <frerich> And in the second case, 'last' is evaluated first but nothing can be garbage collected because of 'head' referencing xs still?
14:33:39 <sinelaw> aaah, so happy can also get into infinite recursion? :_(
14:33:45 <monochrom> pharaun, I don't see a scientific difference between "test" and "explore". getting reliable test results is an important part of reliable, scientific exploration.
14:34:16 <monochrom> during scientific exploration you're gonna do a lot of tests
14:34:31 <monochrom> if the test results are lying, you're exploring a false reality
14:34:47 <pharaun> ahh fair
14:35:03 <pharaun> i just usually end up having to rerun bunch of things in my exploration
14:35:13 <pharaun> so i just put them into unit tests and then iterate from there on the thing
14:35:18 <pharaun> (re repl)
14:36:03 <tomjagua1paw> quicksilver: FYI, Opaleye has extensive automated testing with quickcheck: https://github.com/tomjaguarpaw/haskell-opaleye/blob/master/Test/QuickCheck.hs
14:36:19 <quicksilver> tomjagua1paw: nice!
14:36:30 <quicksilver> tomjagua1paw: I wasn't intended to impune correctness
14:36:44 <quicksilver> tomjagua1paw: I was speculating more about completeness; SQL is big and abstracting it is hard.
14:37:22 <Myll_> what's the diff between => and ->?
14:37:43 <quicksilver> Myll_: => separates a context ffrom a type
14:37:50 <quicksilver> Myll_: -> constructs the type of functions.
14:37:50 <monochrom> => is a delimiter separate type-class constraints from the rest of the type
14:38:03 <monochrom> -> indicates a function type
14:38:16 <monochrom> the difference is one horizontal stroke
14:38:45 <monochrom> s/separate/separating/
14:38:52 <tomjagua1paw> Would you say the difference is -?
14:38:57 <monochrom> yeah!
14:40:25 <Myll_> sorry, what does it mean to separate a context from a type?
14:42:20 <tzh> in something like `Num a => a -> a` the thing on the right of the => is the type (a -> a) and the thing on the left is a constraint on that type (Num a).
14:42:34 <monochrom> do you already know type classes?
14:43:06 <monochrom> if you don't then you will have to learn type classes before you're ready for this
14:43:10 <Myll_> tzh thanks!
14:43:12 <linduxed> hey guys
14:43:27 <Myll_> monochrom numbers, bools, char, etc?
14:43:41 <linduxed> is there a name for the programming language feature of the "where" keyword that we have in haskell?
14:43:45 * hackagebot wai-routing 0.12.2 - Declarative routing for WAI.  https://hackage.haskell.org/package/wai-routing-0.12.2 (ToralfWittner)
14:43:57 <linduxed> basically the ability to say a bunch of stuff, then actually implement it further down?
14:43:58 <monochrom> no
14:44:39 <linduxed> :-/
14:44:45 <z99z> monochrom sorry I still don't really understand why it works to say add the head of (x:xs) to xs', xs'' and then define that as something else???
14:44:50 <monochrom> I just mean no to Myll_
14:45:28 <Myll_> i probably know what it is, i just am not great with programming vocabulary
14:45:51 <monochrom> but Bool and Char are not type classes
14:46:02 <Myll_> alright
14:47:10 <EvanR> linduxed: where is just syntactic sugar for let
14:47:18 <tzh> linduxed: i don't think so? i mean they're called where clauses but generally they're just a slightly different way of declaring/defining values
14:47:35 <EvanR> the feature is "let"
14:47:38 <EvanR> recursive let
14:48:36 <monochrom> linduxed: there are two independent, orthogonal names, because you are looking at a combination of two independent, orthogonal ideas. one is "local definition" or "local binding", but it doesn't talk about order. the other is "forward reference", but it doesn't talk about locality.
14:49:54 <monochrom> at the end Haskell people just say "where" for the combination
14:50:23 <monochrom> e.g., "I will put it in a 'where'"
14:51:37 <linduxed> monochrom: right, i know the last part about how Haskell people talk about it, it's just that i was wondering if there was some name that i could mention, would i be looking for this in another language
14:51:54 <ackthet> anybody using HaTeX?
14:52:10 <linduxed> monochrom: i think "forward reference for a local definition" is good enough
14:52:24 <monochrom> unfortunately it is not a groundbreakingly great idea that drove someone to give it a cool name
14:55:12 <pavonia> ackthet: It's better to just ask your actual question, not if anybody uses this or knows that
14:55:32 <ackthet> pavonia: that was my actual question 
14:56:40 <jophish> ackthet: it's had 233 downloads in the past 30 days, so some people must be using it
14:57:09 <ackthet> interesting, i'm considering trying it out
14:58:01 <ackthet> seems to see pretty active updates too
14:58:11 * ackthet tries
14:58:34 <ackthet> jophish: maybe its 1 person installing it on 233 machines :P
14:59:28 <monochrom> that will mean 1 person using it in anger
15:18:47 * hackagebot flat-maybe 0.1.0.0 - Strict Maybe without space and indirection overhead  https://hackage.haskell.org/package/flat-maybe-0.1.0.0 (AndrasKovacs)
15:43:48 * hackagebot luminance 0.7 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.7 (DimitriSabadie)
15:47:54 <Lokathor> my haskell binary is about 3mb on a program that just prints out the contents of the current directory
15:48:10 <Lokathor> is that all required runtime or is there a utility that can cut it down some?
15:48:48 * hackagebot luminance-samples 0.7 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.7 (DimitriSabadie)
15:50:43 <pingu_> Lokathor: that sounds about right to me.
15:51:23 <dgpratt> probably getting in way over my head, but I have a project I want to tackle that involves computer vision...and of course I'd love to use Haskell for this project as well
15:51:41 <dgpratt> does anyone know, is OpenCV the state-of-the-art for publicly available CV libraries?
15:51:42 <pingu_> Lokathor: you can try stripping and making sure everything is dynamic where possible
15:52:43 <pingu_> Lokathor: actually that might be a little big.
15:57:20 <Lokathor> pingu_, is strip... a unix utility? or something ghc provides? I'm on windows is the thing
16:01:07 <johnw> strip is usually something your compiler's link tools provides
16:01:21 <johnw> it's in binutils on Linux
16:02:11 <Lokathor> hmmm
16:02:37 <Lokathor> perhaps no such thing exists on windows then
16:03:48 <pavonia> MinGw probably has it
16:04:34 <pavonia> Yes
16:07:12 <arw> dgpratt: i guess so, since our CV guys always only want openCV, and regular updates for that. but I'm only the admin installing stuff, I have no clue about CV
16:07:42 <dgpratt> ok, thanks for the input, arw
16:08:22 <arw> dgpratt: tbh, they also always want matlab, but afaik thats more for trying things out and quick visualizations.
16:14:50 <Lokathor> now where did stack stash my mingw then i guess
16:16:49 <Lokathor> awh man i don't appear to have strip in the msys2 that stack pulled in
16:21:15 <lmj> I'm about to submit to hackage for the first time, and was wondering if someone could glance at my module to spot obvious technical problems like module naming etc. If I'm doing something obviously stupid then I'd be nice to avoid having that enshrined on the server for eternity. https://gist.github.com/lmj/a292b0a0ee772b94a2a1
16:21:36 <mniip> 1) why is your code on gist
16:23:45 <lmj> mniip: no particular reason
16:23:45 <Lokathor> lmj, 1) I'd like to see more Haddock, but I'd always like to see more Haddock. Perhaps it's all already obvious if you know the math involved
16:24:45 <lmj> Lokathor: more documentation? I've labeled everything except some redundant stuff
16:25:15 <athan> lmj: Haddock is a standard, to generate the HTML documentation straight from a module :)
16:25:34 <lmj> athan: of course, I've been generating the html to review
16:25:37 <Lokathor> yeah I guess it's one of those things where if I knew the math involved it'd all be super obvious
16:25:41 <lmj> I'm using haddock markup
16:25:48 <athan> lmj: Have you heard of lpaste?
16:25:52 <athan> oh okay
16:26:16 <lmj> athan: yes, I was using lpaste earlier here. Just happened to use gist this time.
16:26:33 <athan> this is awesome I think
16:27:02 <lmj> If you've ever woken up with the urge to take the cosine of a million-dimensional algebra ...
16:27:32 <athan> :)
16:27:35 * athan claps
16:28:04 <lmj> there was a time when I used integer-level types via DataKinds, but ultimately went with tags.
16:28:06 <athan> I am not as disciplined to actually ask people >.> I riddle Hackage with wasted version numbers because of it :\
16:28:16 <athan> rittle*
16:28:42 <Lokathor> the secret is to never submit to hackage, only github :P
16:32:59 <tommd> Then stack comes along and lets people depend on your package anyway.  How mean.
16:34:42 <Lokathor> if my junk on github gets into stackage though, it's part of the lts system, and so whatever
16:34:50 <Lokathor> I trust lts to get it right
16:36:00 <Welkin> Lokathor: stop putting your junk where it doesn't belong!
16:36:12 <Welkin> too much junk in yer trunk
16:36:13 <Lokathor> :O
16:36:27 <MarcelineVQ> oh snap
16:37:08 <Lokathor> Welkin, https://github.com/Lokathor/ls-hs/blob/master/src/Main.hs here you can go replace your system's copy of ls now
16:37:15 <Lokathor> you didn't need command line options did you?
16:37:39 <hackrilege> What is the name is the class which provides methods to insert an element, delete it, or retrieve it?
16:38:10 <Welkin> hackrilege: MonadState?
16:38:12 <Lokathor> hackrilege, Set is probably what you're looking for
16:39:11 <hackrilege> I guess a set from maths has these methods, but perhaps there is a superclass, what is monadState?
16:39:55 <hackrilege> No, sorry, I'll go find that out, brb, thanks
16:40:08 <hunteriam> hey guys
16:40:18 <hunteriam> whats the best way to nuke my cabal/ghc and have stack reinstall it all for me
16:40:28 <hunteriam> because it appears to have become unsalvageable
16:40:33 <hunteriam> at least to my pedestrian eyes
16:41:10 <Welkin> hunteriam: stack install --install-ghc
16:41:25 <Welkin> er
16:41:25 <hunteriam> cabal is broken too, not just ghc, will this fix that?
16:41:30 <Welkin> hunteriam: stack install cabal-install --install-ghc
16:41:44 <hunteriam> does it matter where i run that?
16:41:52 <Lokathor> hunteriam, nope
16:41:54 <Adeon> shouldn't
16:41:57 <hunteriam> thanks
16:42:20 <Lokathor> well, if you're in a directory with a project it might get confused, but probably will be fine
16:42:23 <hunteriam> giving it a try, hope it goes well!
16:42:27 <hackrilege> Yeh, set is not a class, though it doors provide those methods on a nice way
16:42:53 <hackrilege> I have need to define such a class
16:43:04 <Lokathor> hackrilege, can you explain the need for a class?
16:43:05 <hunteriam> yea, its not happening, theres a problem with cabals attempt at configuring things, ill post the log in the following
16:43:29 <Lokathor> hunteriam, well stack shouldn't be using cabal to install ghc >_>
16:43:49 <hunteriam> https://www.irccloud.com/pastebin/2BZ9ohAo/error
16:43:51 <xsdaa> Hey, I want to write a function with the following with the following type signature: function :: (alpha -> beta) -> Maybe alpha -> Maybe beta I've already found some ways to do it, but I'm confused why I can't do it with function f x = (x >>= (f.return))
16:44:01 <hunteriam> Lokathor: stack install cabal-install gets stuck configuring the first package
16:44:28 <hunteriam> it tries to configure mtl and stalls eternally
16:44:35 <fosterite> xsdaa: fmap?
16:44:39 <glguy> xsdaa: You've got your (.) turned aroun
16:44:40 <Welkin> hunteriam: remove cabal from your path
16:44:52 <Welkin> and let stack install it
16:44:55 <hunteriam> kk
16:44:57 <fosterite> :t \f x -> x >>= (return . f)
16:44:58 <lambdabot> Monad m => (a -> b) -> m a -> m b
16:45:13 <hackrilege> Lokathor, im testing several different representations which provide these methods. Instantiating a superclass would allow me to write functions that will be automatically directed to the relevant instance depending on which representation is being used
16:45:15 <xsdaa> :O ok thanks!
16:46:43 <Lokathor> hackrilege, interesting idea. If you had to make your own typeclass, you might call it "Collection"
16:46:54 <Lokathor> and then make instances for Collection Set and Collection List
16:46:59 <fosterite> :t \f x -> x >>= (f . return)
16:47:00 <lambdabot> (Monad m, Monad m1) => (m1 a -> m b) -> m a -> m b
16:47:21 <fosterite> that's odd
16:47:39 <hackrilege> Yeh that's what i did, i wondered if it was an existing class
16:48:30 <hackrilege> monadState seems almost correct, but i cant see a delete method
16:48:57 <Lokathor> hackrilege, what was the error you got?
16:49:17 <hackrilege> There was no error, it works fine
16:50:03 <fosterite> oh, it's because return is unconstrained so it's basically Identity, so it's just >>=
16:50:51 <mniip> hmm, what would be the most haskell-esque way to find whether a list contains an element satisfying a predicate?
16:50:57 <mniip> I have like 20 implementations in mind but
16:51:02 <hackrilege> It's as if i redefined functor, i would rather import it to make out visible to functions over functors
16:51:23 <mniip> null $ filter probably?
16:51:25 <cite-reader> :t any
16:51:26 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
16:51:29 <mniip> oh yes
16:51:33 <mniip> totally forgot about it
16:51:38 <hackrilege> :t elem
16:51:39 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
16:51:59 <MarcelineVQ> that's the right track hackrilege but he wants to supply a predicate
16:53:12 <dalastboss> hey guys, ML programmer here trying to learn a little haskell. Something that's confusing me is I've read that by making I/O monadic it allows
16:53:23 <dalastboss> side effects to occur in a purely functional way
16:53:43 <dalastboss> but what I don't get is, can't you still use the I/O monad to violate referential transparency?
16:53:48 <Welkin> mniip: filter
16:54:00 <mniip> Welkin, any
16:54:12 <Welkin> mniip: yes, just read that :P
16:54:15 <hackrilege> @src any
16:54:15 <lambdabot> any p = or . map p
16:54:23 <Welkin> dalastboss: no
16:54:33 <Welkin> dalastboss: read the paper on lazy functional state threads to learn why
16:54:35 <athan> dalastboss: Well, you can see IO as a state thread, but for a large class of computations
16:54:50 <Welkin> every access to the "real world" is done inside a state thread
16:54:55 <MarcelineVQ> @let myElem x = any (==x)
16:54:57 <lambdabot>  Defined.
16:55:02 <athan> so it's hard to know that the IO work you do is domain-specific, because of how general the concept of I/O is
16:55:23 <MarcelineVQ> > myElem 1 [4,2,1] -- hackrilege :D
16:55:26 <lambdabot>  True
16:55:38 <hackrilege> Cool
16:55:47 <Welkin> dalastboss: http://research.microsoft.com/en-us/um/people/simonpj/papers/lazy-functional-state-threads.ps.Z
16:56:33 <hackrilege> Can we take about monadState? I don't understand get... It just makes information appear!?
16:56:41 <Welkin> dalastboss: that is one of the best papers I have read
16:56:41 <dalastboss> Welkin: will take a look, thanks
16:56:44 <hackrilege> I mean it takes no arguments
16:56:48 <Welkin> it taught me a lot about how haskell works
16:57:00 <tommd> hackrilege: Sure it does, the arguments are just hidden.
16:57:06 <tommd> @src StateT
16:57:06 <lambdabot> Source not found. It can only be attributed to human error.
16:57:07 <athan> dalastboss: There's also unsafePerformIO, which violates the type system to achieve sneaky things
16:57:20 <hackrilege> Lamdabot is calm
16:57:21 <dalastboss> right
16:57:25 <lmj> The hackage upload page is asking me to select a file to upload, but I haven't logged in yet, and I don't see where to log in. I made an account a few days ago but have since deleted cookies, etc.
16:57:32 <slurpee_> how can i fix this error? "Not in scope: type constructor or class `Node'" http://hastebin.com/dicagovaho.hs
16:57:42 <mniip> athan, it doesn't strictly violate the typesystem
16:57:46 <mniip> just the referential transparency
16:57:53 <Welkin> slurpee_: import the type constuctor
16:58:13 <mniip> lmj, pick a file first
16:58:19 <mniip> login is the next step
16:58:30 <tommd> lmj: Try to upload something ...
16:58:33 <hackrilege> No no, you should write Tree, not Node
16:58:44 <lmj> mniip: ok thanks, I was hoping that was the case. Half-afraid it was messed
16:58:49 <hackrilege> Node is a constructor
16:58:50 <athan> mniip: well.........
16:59:01 <Welkin> slurpee_: oh, you are using a data constructor as a type
16:59:06 <hackrilege> Welkin, that was a bad guess..
16:59:06 <Welkin> change Node to Tree a
16:59:15 <slurpee_> ok
16:59:23 <athan> it violates the sense that type inference should give us theorems that make sense, right?
16:59:24 <mniip> or were you specifically referencing the coerce-through-ioref hack?
16:59:29 * Welkin slaps hackrilege around with a rotten swedish fish
16:59:29 <lvella> hi, can you recommend some book or manual or tutorial of haskell for non programmers (to someone learning as its first programming language?)
16:59:34 <athan> meh
17:00:06 <athan> mniip: I think that part, thank you :)
17:00:11 <Welkin> @where learnhaskell -- lvella 
17:00:12 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:00:14 <hackrilege> Art of functional programming is a purity good book
17:00:18 <tommd> lvella: Haskell School of Music
17:00:39 <kadoban> lvella: https://github.com/bitemyapp/learnhaskell has some good advice, or there's a book in progress by the author of that page you could check out too: http://haskellbook.com/ it sounds good and I've heard good things, but I don't have a copy yet.
17:00:42 <slurpee_> Welkin, why do i have to write 'Tree a' and not just 'Tree'?
17:00:58 <kadoban> lvella: I suspect the second option is better, but I'm not sure.
17:01:08 <Welkin> slurpee_: because Tree a is a type
17:01:12 <lvella> thank you
17:01:16 <Welkin> slurpee_: Tree is a type constructor
17:01:27 <tobiasBora> Hello !
17:01:40 <slurpee_> okay
17:01:41 <Welkin> Tree :: * -> *, Tree a :: *
17:01:42 <hackrilege> Slurpee Tree requires a type parameter, a tree of what exactly? A Tree of a
17:02:01 <tobiasBora> I would like to know if there is a mapi function ? (like map but the function takes in parameter the index)
17:02:02 <Welkin> a type has kind *
17:02:22 <mniip> athan, \x -> let i = unsafePerformIO $ newIORef undefined in unsafePerformIO $ writeIORef i x >> readIORef i
17:03:12 <Lokathor> welp
17:03:13 <Welkin> tobiasBora: zip [1..]
17:03:23 <hackrilege> tobiasBora, its easy to write using zip
17:03:25 <Lokathor> stack can work a lot of magic, but it can't get gtk2hs setup on windows
17:03:25 <Welkin> then you can map over each pair
17:03:29 <Lokathor> at least not on its own
17:03:30 <tobiasBora> Welkin: Thank you !
17:03:54 <hackrilege> But there is such a function
17:04:09 <hackrilege> Data.Map has one
17:04:25 <hackrilege> Im sure there are many others
17:05:44 <hunteriam> i just removed cabal and ghc from my path and tried to stack install cabal-install --install-ghc
17:05:50 <tobiasBora> And do you have a way to do zip for 3 lists ?
17:05:56 <hunteriam> and it appears to have hung on step 8/12, configure network-uri
17:06:01 <Lokathor> hunteriam, try "stack setup"
17:06:03 <Lokathor> just on its own
17:06:16 <hunteriam> should i cancel the stack install first?
17:06:26 <Lokathor> well let it try and finish
17:06:40 <hunteriam> how long should i wait before `stack setup`?
17:06:47 <hunteriam> been maybe 10-20 minutes?
17:06:57 <Lokathor> oh my, yes just kill that then
17:07:00 <Lokathor> that's way too long
17:07:13 <Lokathor> also, do you have a recent version of stack?
17:07:26 <Lokathor> latest stable release is 1.6
17:07:32 <Lokathor> er, 0.1.6 i guess
17:07:47 <hunteriam> ah, no, im on 0.1.4
17:08:03 <hunteriam> i was intimidated by the update process
17:08:10 <hunteriam> since stack --upgrade didnt work for me
17:08:24 <fosterite> tobiasBora: there are several n-way zip libraries around
17:08:26 <Lokathor> well, delete that, delete your .stack and all your cabal and ghc stuff, and just download the newest release for your system fresh
17:08:28 <Welkin> hunteriam: compile a new version of stack and try again
17:08:29 <hackrilege> :t Data.IntMap.insertLookupWithKey
17:08:31 <lambdabot> (IS.Key -> a -> a -> a) -> IS.Key -> a -> IM.IntMap a -> (Maybe a, IM.IntMap a)
17:08:51 <fosterite> :t imap
17:08:53 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
17:08:57 <tobiasBora> fosterite: I found zip3, it should be enough
17:09:04 <Lokathor> then start with "stack setup" and try "stack exec ghci" once that's done, and it should open up a ghci terminal if things went fine
17:09:17 <hackrilege> Awesome fosterite!!
17:09:32 <Lokathor> Welkin, part of the problem is that they can't seem to compile anything at the moment
17:10:01 <hackrilege> FunctorWithIndex, great stuff
17:10:11 <kadoban> hunteriam: There's binaries for most stuff, that's really the easiest way to go.
17:10:28 <hackrilege> Perhaps thats the class i was after before...
17:10:31 <fosterite> you have to drag in lens for it, I haven't looked for other indexed functor ecosystems
17:10:38 <fosterite> oh, keyed or keys or something
17:11:35 <hackal> Hello, I am doing exercises for my lectures. However I am stuck on the first exercise and I am unable to continue further. Please could you help me and tell me what I am doing wrong? https://gist.github.com/hackal/d33e1da0a99cafbd574e the gist has 2 files.
17:11:57 <slurpee_> how do i instantiate a new Node correctly? i get error "Couldn't match expected type with actual type". lines 10 and 11: http://hastebin.com/ipupoqofal.hs
17:13:51 * hackagebot cayley-dickson 0.1.0.0 - Complex numbers, quaternions, octonions, sedenions, etc.  https://hackage.haskell.org/package/cayley-dickson-0.1.0.0 (lmj)
17:14:09 <Hafydd> slurpee_: Node x l r or Node{ value=x, left=l, right=r }. See the definitions of function application and record syntax in the Haskell report.
17:14:15 <hackrilege> It takes three arguments, you provide a tripple, which is one slurpee_
17:14:15 <Lokathor> slurpee_, Node a "-1" "-1"
17:14:20 <tzh> slurpee_: you want `Node x "-1" "-1"`, not `Node(x, "-1", "-1")`. also, "-1" isn't of type Tree a, so that still wouldn't compile
17:14:27 <Hafydd> slurpee_: note, however, that in your example "-1" is not a valid Tree, unless you're using OverloadedStrings.
17:15:12 <Hafydd> (Also note that (x, "-1", "-1") constructs a 3-tuple.)
17:15:30 <cite-reader> hackal: You've got a bunch of type aliases, and then _one_ newtype that's causing a problem.
17:15:44 <hackrilege> And yor tree should contain values or branches not both i guess
17:16:09 <lmj> hackage warning: "Exposed modules use unallocated top-level names: Math". This may be the reason why haddock was not generated at the hackage website
17:16:18 <Lokathor> hackrilege, the tree data type itself seems fine
17:16:29 <hackrilege> Ok, no you have the null, it's fine.
17:16:34 <cite-reader> hackal: Do you know how to unwrap the newtype to get at the data inside?
17:17:03 <hackal> cite-reader: I think I am starting to see where my problem is. testDB, variable on which I test my function, has fromList inside. That means it changes it to Keymap datatype. So when I test my functions I need to do (toList testDB)
17:17:04 <slurpee_> ok thx guys
17:18:11 <cite-reader> hackal: 👍
17:18:24 <hackal> cite-reader: thanks for help
17:18:55 <lmj> How can I convince hackage to generate haddock? https://hackage.haskell.org/package/cayley-dickson-0.1.0.0 did not create a link to the module -- is it because of the "Exposed modules use unallocated top-level names: Math"?
17:20:00 <lmj> Is there anything wrong with https://github.com/lmj/cayley-dickson/blob/master/cayley-dickson.cabal ?
17:20:32 <glguy> lmj: you'll have to wait longer than 5 minutes for the doc builder to get to your package
17:20:59 <lmj> glguy: ok thanks, but do you understand the warning?
17:20:59 <glguy> If you want docs faster you'll need to upload them yourself
17:21:13 <glguy> Yeah, it's not related to your docs not being around
17:21:20 <lmj> k thanks again
17:23:05 <slurpee_> Hafydd, the value in Node should always be Char. how should i change my data structure to reflect that?
17:23:42 <johnw> does anyone know of an algorithm for taking the difference of two directed graphs?
17:23:50 <Hafydd> slurpee_: data Tree = Empty | Node{ value :: Char, left :: Tree, right :: Tree }.
17:23:52 <slurpee_> value :: Char a?
17:24:11 <slurpee_> okay
17:24:27 <Hafydd> slurpee_: alternatively, type CharTree = Tree Char, using your existing definition.
17:24:27 <slurpee_> why don't u include the a's?
17:24:39 <Hafydd> slurpee_: if the type is always Char, there's no need for a type variable.
17:25:05 <Hafydd> (i.e. your type is now completely monomorphic.)
17:25:14 <slurpee_> shouldn't you have data Tree a =
17:25:23 <slurpee_> because Tree could be Empty or Node
17:25:32 <Hafydd> slurpee_: no. Why do you imagine that requires a type variable 'a'?
17:26:00 <slurpee_> i don't know, it could be more than 1 type
17:26:20 <athan> How do I make monospaced text in haddock, without it trying to cross-reference?
17:26:56 <Hafydd> slurpee_: there's only one type; it just has two different constructors. A type variable is only used when the data type represents a type function that can be instantiated with other types.
17:27:52 <Hafydd> slurpee_: I hope you realise that in your original definition, 'a' is a type variable representing the type of the element held inside nodes.
17:28:13 <kyfho> so haskell looks nice
17:28:29 <kyfho> I think software at my current job is really inefficien
17:29:21 <kyfho> why dont robots do all the work?
17:29:25 <kyfho> bankers? wanting slaves?
17:29:36 <ackthet> f
17:29:46 <ackthet> sorry, cats <_<
17:29:47 <infandum> How do I troubleshoot ""relocation R_X86_64_PC32 against symbol 'stuff here_closure' can not be used when making a shared object; recompile with -fPIC. /usr/bin/ld: final link failed: Bad value. collect2: error: ld returned 1 exit status
17:30:13 <infandum> stack ghci works fine and it loads but stack install causes that error
17:30:26 <hunteriam> guys i need to delete this file because its the problem file:  C:\Users\thepr\AppData\Roaming\stack\setup-exe-cache\setup-Simple-Cabal-1.22.4.0-x86_64-windows-ghc-7.10.2.exe 
17:30:32 <hunteriam> but i cant because its in use AT STARTUP
17:30:34 <hunteriam> how is that possible?
17:30:42 <hunteriam> I restatrted and it still says its in use
17:31:33 <infandum> I should also mention that it's just this specific project, not others. It's using HaskellR (H)
17:31:53 <infandum> which is probably why it's talking about R_X86_64
17:31:55 <infandum> I assume
17:34:03 <infandum> hunteriam: Can you kill it?
17:34:53 <lmj> glguy: is the "unallocated top-level names" warning a bug? Math.* modules already exist, so isn't "Math" "allocated"?
17:35:44 <glguy> No, "allocated" just means that someone decided that it was allocated or not. Things don't become allocated when someone else starts using it
17:36:00 <glguy> they become allocated when the people running hackage decide that they are
17:36:14 <lmj> ok thanks
17:36:15 <Enigmagic> hunteriam: https://technet.microsoft.com/en-us/sysinternals/processexplorer.aspx
17:37:28 <tobiasBora> I don't really understand how does the let/where works in list comprehension... Do you have a way to use them in order to get this (which has an error for the moment) : [ (x-y) `mod` 12 == 7 && (x'-y') `mod` 12 == 7
17:37:30 <tobiasBora>                  | a <- l, b <- l, (x,x') = a, (y,y') = b, a /= b]
17:37:45 <Enigmagic> hunteriam: it may be in use for various reasons (assuming the process isn't running), like perhaps some antivirus software is installed..
17:38:17 <tobiasBora> Oh... I used <- instead of = and it seems to compile...
17:38:44 <mniip> can I haddock-link to a $section of a module
17:38:53 * hackagebot markup 3.1.0 - Abstraction for HTML-embedded content  https://hackage.haskell.org/package/markup-3.1.0 (athanclark)
17:39:34 <tobiasBora> Hum no in fact <- doesn't works
17:39:36 <tobiasBora> *work
17:40:20 <athan> tobiasBora: <- is for monads, = is for pure code
17:41:12 <tobiasBora> athan: Hum... But if = is for pure code, why (x,x') = a doesn't compile ?
17:41:38 <athan> tobiasBora: Well, does `a :: (something, anotherthing)`?
17:41:49 <athan> or is `a :: m (something, anotherthing)`?
17:41:56 <athan> because the `m` is crucial
17:42:04 <mniip> I mean if I include a -- $section in the export list
17:42:12 <mniip> it does seem to generate an id for the section
17:42:16 <mniip> however how would I hyperlink that
17:44:17 <tobiasBora> athan: a is 'a :: (Int, Int)
17:44:47 <athan> tobiasBora: Oh, well then that `let (x,x') = a` should pattern match then
17:45:22 <athan> but, that also means that if you're using that `let` in a do-statement, then `x` and `x'` are both pure, and not monadic
17:47:13 <Lokathor> i accidentally built some packages in stack's database with -Wall
17:47:23 <Lokathor> and now it won't stop warning about a bunch of junk
17:47:38 <Lokathor> how sad
17:48:06 <kyfho> huh?
17:48:22 <kyfho> computers are too much work
17:48:24 <kyfho> lol
17:48:30 <Lokathor> well that's all i can figure, because it won't stop throwing warnings every time something builds
17:48:35 <Lokathor> and it didn't a few days ago
17:51:06 <mniip> hackage pls sthap
17:51:24 <hackrilege> :t get
17:51:25 <lambdabot> MonadState s m => m s
17:51:49 <hackrilege> Can someone show me this in use?
17:51:55 <hunteriam> guys stack install cabal-install gets stuck on downloading stm
17:52:06 <hunteriam> ive tried uninstalling and reinstalling
17:52:33 <hackrilege> What's the error?
17:52:43 <infandum> ALSO, it turns out that on my arch installation it works, on my ubuntu 14.04 installation it does not
17:52:44 <athan> mniip: stop what?
17:52:51 <mniip> it was lagging severily
17:53:28 <hunteriam> https://www.irccloud.com/pastebin/wjJOXDCI/
17:53:30 <tzh> > runState (do { a <- get; return $ a + a}) 5
17:53:31 <lambdabot>  (10,5)
17:53:54 * hackagebot functional-kmp 0.1.0.0 - KMP implemented on haskell's built-in cons-cell-based lists.  https://hackage.haskell.org/package/functional-kmp-0.1.0.0 (mniip)
17:53:56 <hackrilege> omg
17:53:59 <hunteriam> @hackrilege no visible error, just stalls on the execution of old times setup
17:53:59 <lambdabot> Unknown command, try @list
17:54:16 <mniip> aww no docs
17:54:22 <hackrilege> Lol
17:54:45 <hackrilege> It some ninja stuff
17:54:50 <athan> mniip: I noticed too :\ there's a large lag every time I upload now
17:54:54 <athan> or try to change version constraints
17:55:57 <dmj> is there a generics package for QuickCheck
17:57:42 <Jello_Raptor_> :/ so I have a language I'm trying to parse with Parsec, and I created a typeclass for every type in the ast that specifies a "class Parsable a where parser :: ParserT s () Identity a". Now all of the instances basically look like "<Constructor for AST component> <$> parser <*> parser <*> parser" 
17:57:43 <dmj> I couldn't find one
17:57:51 <hackrilege> Hmmm can you use get outside do notation?
17:58:20 <Jello_Raptor_> which is kinda annoying 
17:58:20 <dmj> hackrilege, you mean like `get` from Control.Monad.State ?
17:58:48 <hackrilege> :t get
17:58:49 <lambdabot> MonadState s m => m s
17:58:58 <hackrilege> That one
17:59:14 <dmj> @def result = (+1) <$> get
17:59:15 <lambdabot>  Defined.
17:59:20 <dmj> @typ result
17:59:21 <lambdabot> (Num b, MonadState b f) => f b
17:59:28 <hunteriam> can anyone help me troubleshoot my installation problems?
17:59:28 <dmj> no do notation in sight !
17:59:34 <hackrilege> Cool
17:59:41 <hackrilege> Thanks
18:00:05 <hackrilege> What does it do?
18:00:49 <dmj> it returns your state, but adds one to it before it does
18:00:50 <Welkin> hackrilege: it does whatever you want it to do
18:01:11 <mniip> guys
18:01:12 <hackrilege> The same thing as get but applying (+1) with pure
18:01:20 <mniip> I need my package to have tests
18:01:22 <mniip> suggestions?
18:01:24 <Welkin> mniip: guiz
18:01:33 <dmj> mniip: hspec
18:01:39 <Welkin> mniip: get it tested for all the common STDs
18:01:56 <Bruuuuuno> :t get
18:01:57 <lambdabot> MonadState s m => m s
18:01:59 <Welkin> make sure you also get the rabies shot
18:02:02 <hackrilege> As it has the same type as get it Dee's not help me
18:02:26 <Welkin> I have heard criterion recommended before
18:02:36 <hackrilege> That's for benchmarks
18:02:57 <tzh> > runState (get >>= (\a -> return $ a + a)) 5
18:02:59 <lambdabot>  (10,5)
18:02:59 <slurpee_> i'm confused by this error :( http://hastebin.com/efopizuxoh.hs
18:03:20 <Welkin> I never find myself using the state monad
18:03:36 <Welkin> if I am using any kind of mutable state, it is stored in a database anyway
18:04:29 <hackrilege> Slurpee_ youvhave applied an argument x to createTree, you should you have
18:04:47 <hackrilege> You should not have
18:04:57 <Hafydd> slurpee_: what resource(s) are you using to learn Haskell?
18:05:23 <slurpee_> hackrilege, why? i want the first line of input to go into createTree
18:05:39 <hackrilege> He is brute forcing it like a champ. Ghc is all you need
18:06:10 <hackrilege> But then its a tree not a tree constructor
18:06:14 <Hafydd> Unfortunately, it seems like they need people in #haskell to spoonfeed them, too.
18:06:23 <slurpee_> Hafydd, i watched Derek Banas' tutorial on youtube
18:07:08 <hackrilege> Hey im wrong oops, ill check again, sorru
18:07:41 <hackrilege> Oh, your maping over a string
18:07:43 <Hafydd> slurpee_: the problem seems to be that your "map (decodeMessage (createTree x)) xs" give a list of strings, but you've given the type "decode :: [String] -> String".
18:08:12 <Hafydd> So one of those is wrong.
18:08:51 <hackrilege> Just remove map
18:09:17 <Hafydd> That wouldn't fix it.
18:09:59 <hackrilege> I think it would...
18:10:18 <__uu__> Hi, I have a question off the target
18:10:25 <hackrilege> What was the map doing?
18:10:25 <Hafydd> My guess is that you want "decode :: [String] -> String", then: "main = interact (unlines . decode . words)".
18:10:42 <__uu__> what is the difference of compose and combine in meaning?
18:10:49 <Hafydd> hackrilege: it was mapping over the [String] that decode take as its first argument.
18:11:02 <Hafydd> (Its tail.)
18:11:20 <hackrilege> It takes a String...
18:11:35 <Hafydd> hackrilege: do you see "decode :: [String] -> String"?
18:11:55 <slurpee_> the words feeds a [String] to decode, correct?
18:12:03 <Hafydd> Yes.
18:12:21 <slurpee_> createTree x supplies the head of that list to createTree?
18:12:33 <hackrilege> Fold?
18:12:54 <pavonia> __uu__: In what context?
18:13:02 <Hafydd> slurpee_: yes; for each element after the head, the head itself is used as the first argument to createTree.
18:13:11 <__uu__> pavonia: in literature
18:13:18 <slurpee_> yes that's intended
18:13:25 <tippenein> Anyone know about stack commands being killed while populating index cache? Is there a proper channel to ask this question?
18:13:31 <tippenein> Populating index cache ...[1]    21562 killed     stack setup
18:13:34 <Hafydd> slurpee_: right, so I maintain my earlier suggestion: <Hafydd> My guess is that you want "decode :: [String] -> String", then: "main = interact (unlines . decode . words)".
18:13:51 <Hafydd> Oh, er...
18:13:51 <__uu__> I am describing a system which consists of several parts (in both physics and algorithm)
18:14:01 <hackrilege> And use fold not map
18:14:02 <Hafydd> slurpee_: I mean "decode :: [String] -> [String]"
18:14:13 <hackrilege> Ok, that would be map
18:14:54 <slurpee_> ok Hafydd, yea that makes sense
18:16:07 <pavonia> __uu__: "compose" in Haskell usually mean putting functions together to geth more complex functions, not sure what "combine" is used for
18:16:19 <mgsloan> tippenein: I haven't seen that before.  Are you pressing Ctrl-c?
18:16:24 <hackrilege> If you want to you can fold them together with decodeMessage. Try replacing map with foldl1
18:16:28 <c_wraith> pavonia: geth?  kill them!!
18:16:37 <pavonia> *get :S
18:17:00 <mgsloan> tippenein: How about posting an issue to the stack issue tracker or mailinglist?
18:17:06 <slurpee_> i think map does what i want
18:17:34 <tippenein> mgsloan: I think that's what I'll do because searching around I don't see anything of the sort happening to other people
18:18:07 <tippenein> mgsloan: I'm not ctrl-c'ing but I'm trying to get a better idea of what kind of commands it does this on
18:20:58 <mgsloan> Could be that it's running out of memory
18:28:27 <chanch> ?src ($)
18:28:27 <lambdabot> f $ x = f x
18:29:13 <tippenein> mgsloan: that's a good guess actually. It's a small VPS
18:40:45 <glguy> mada: Still there?
18:42:04 <glguy> ?tell mada You can remove a "window" from glirc using the /clear command
18:42:04 <lambdabot> Consider it noted.
19:05:06 <orion> If I have a C function which initializes a struct (identically every time), is it OK to use unsafePerformIO, or does the fact that I'm creating the ForeignPtr with mallocForeignPtr mean I should not use unsafePerformIO?
19:12:56 <Enigmagic> orion: if you're using ForeignPtrs then you most likely do not want to use unsafePerformIO
19:14:23 <mniip> is there an indexOf :: Eq a => [a] -> [a] -> Maybe Int function somewhere in base?
19:16:43 <mniip> apparently not
19:22:54 <orion> Enigmagic: I see.
19:35:58 <Bruuuuuno> ?src map
19:35:58 <lambdabot> map _ []     = []
19:35:58 <lambdabot> map f (x:xs) = f x : map f xs
19:36:08 <Bruuuuuno> woah that's awesome
19:36:54 <diginet> is anyone here familiar with FEAT (Functional Enumeration of Algebraic Types)? I'm a bit confused as to how it works
19:37:21 <Lokathor> mniip, so you want to give a list and a sublist and see where the sublist starts, if it does?
19:38:31 <mniip> yeah
19:38:45 <mniip> it's okay if such a function doesn't exist though
19:38:48 <hunteriam> is there a hashmap with O(1) access, insertion, and deletion in haskell?
19:39:06 <mniip> hunteriam, such a hashmap is impossible
19:39:27 <slurpee_> how can i write a 'getVal' function for my Node 'object'? http://hastebin.com/oqizuxoyot.hs
19:39:27 <mniip> no languages have O(1) hashmaps
19:39:55 <hunteriam> they have average case O(1) hashmaps
19:40:00 <glguy> diginet: I don't know about that package, but if you're interested in enumerating values you might find this cool
19:40:00 <glguy> http://www.galois.com/~emertens/generic-traverse-0.1-docs/Boggle-Enum.html
19:40:26 <hunteriam> does haskell?
19:40:29 <glguy> It's a demo for using GHC generics to do it where the generics representations compile away
19:40:31 <hunteriam> cause I'd like to use one if possible
19:40:42 <jle`> hunteriam: not totes sure, but have you looked at HashMap from unordered-containers?
19:41:05 <hunteriam> ill look
19:41:25 <hunteriam> well its a hashmap but they dont talk about performance!
19:41:41 <kyfho> anyone doing web sites in haskkell?
19:41:48 <kyfho> happstack looks awesome
19:42:04 <hunteriam> nevermind it does
19:42:07 <kadoban> kyfho: Quite a few. There's a somewhat surprising number of good web stuff in haskell.
19:42:14 <hunteriam> but its O(log n) unfortunately
19:42:43 <kyfho> whats best way to learn programming and haskkel?
19:43:17 <Hijiri> it's O(1) if you restrict the hashmap to the size of your memory
19:43:32 <kadoban> kyfho: https://github.com/bitemyapp/learnhaskell has some good advice, or there's a book in progress by the author of that page you could check out too: http://haskellbook.com/ it sounds good and I've heard good things, but I don't have a copy yet.
19:43:49 <lpaste_> Lokathor pasted “mniip, it exists now :3” at http://lpaste.net/145074
19:44:06 <mniip> it's not in base though
19:44:06 <stephen_> kyfho: hakyll is nice for static sites
19:44:24 <Lokathor> well, it's not IN base, but it only depends on base
19:44:38 <Ashy> kyfho: also be patient while you're learning, you're not going to make a new facebook in a week or a new call of duty etc
19:45:01 <mniip> it "is identical to Data.List.isInfixOf" $ property $ \as bs -> isInfixOf as bs == Data.List.isInfixOf as bs
19:45:06 <mniip> see the kind of stuff I have in mind?
19:45:34 <kyfho> :(
19:46:02 <Lokathor> mniip, uh, actually i don't >_>
19:46:06 <diginet> glguy: hey, sorry just saw your message. That looks interesting, thanks. In a more general sense, I'm trying to figure out a way to map productions of a context-free grammar to the natural numbers, someone suggested FEAT, but I'll take a look at that too
19:46:22 <mniip> Lokathor, I'm writing tests for an implementation of indexOf
19:47:51 <glguy> diginet: If you were to express your grammar as a datatype you could enumerate a list of all the members of it and the index of a tree in that list would be it's mapping
19:48:03 <glguy> but that wouldn't help you to figure out which index was which tree
19:48:06 <glguy> other than to search
19:48:18 <diginet> glguy: hmm
19:48:35 <diginet> glguy: well, I had already planned the first part (to use FEAT), but let me think...
19:48:47 <glguy> I'm not trying to convince you to switch by any means :)
19:48:53 <stoogenmeyer> @pl \f g x y -> f (x ++ g x) (g y)
19:48:53 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
19:48:59 <diginet> glguy: no no I know, but the easier the solution, the better :P
19:49:57 <slurpee_> i feel so retarded using this language
19:50:20 <mniip> slurpee_, the feeling never goes away :)
19:50:35 <mniip> it's okay
19:55:33 <shnkr> lol... i feel the same slurpee_ 
20:06:13 <Lokathor> haskell can be an ask hell
20:06:36 <Bruuuuuno> oooooooh
20:07:36 <mniip> yeah we already talked about this :)
20:07:51 <mniip> someone should make a blog named askhell with the most twisted usages of haskell one could imagine
20:08:35 <mniip> so
20:08:47 <mniip> anyone wanna test my test
20:08:48 <mniip> s
20:09:53 <mniip> I wrote some fun test stuff stuff testing fun
20:10:55 <mniip> https://github.com/mniip/functional-kmp/blob/master/test/Test.hs
20:13:59 * hackagebot Lambdajudge 1.0.0.1 - A library to easily host Haskell based programming competitions  https://hackage.haskell.org/package/Lambdajudge-1.0.0.1 (ankitku)
20:29:22 * hackagebot Lambdajudge 1.0.0.2 - A library to easily host Haskell based programming competitions  https://hackage.haskell.org/package/Lambdajudge-1.0.0.2 (ankitku)
20:36:36 <orion> If I am creating an instance of Storable for a C struct whose largest element is "uint32_t h[8];", is it correct to specify the alignment as "alignment (undefined :: Word32) * 8"
20:40:35 <tolt> Does anyone have experience with github.com/acowley/roshask? I'm unable to subscribe to a topic with it
21:02:20 <glguy> orion: No. See https://wiki.haskell.org/FFICookBook#Working_with_structs
21:11:25 <orion> glguy: Ah. Why does the alignment function use offsetof() on a struct beginning with char x__, as opposed to the struct itself?: #let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
21:12:00 <glguy> because that char has size 1
21:12:14 <glguy> so whatever offset the type you're interested in is at will be it's alignment
21:12:22 <glguy> if it was the first thing its offset would be 0
21:12:42 <orion> Oh! Indeed. Clever.
21:13:13 <glguy> Alignments on x86_64 won't be more than 16
21:13:15 <u_> i couldn't instal something with cabal so i tried stack
21:13:18 <u_> brew install stack
21:13:21 <u_> and now stack won't install 
21:13:33 <u_> just hangs on make
21:15:03 <tommd> u_: You could just install the latest stack from their bindist.
21:15:45 <glguy> Having problems with stack? You should try stack.
21:16:07 <tommd> lol, no.  I'm saying you can get stack from a source other than brew and that might avoid the issue.
21:16:20 <tommd> Silly glguy, brew is for everyone besides stack.
21:16:22 <glguy> My interpretation is funnier
21:16:24 <u_> i wonder how many random utilities out there are called stack
21:17:56 <u_> well i ran brew install haskell-stack again
21:17:59 <u_> without changing anything
21:18:00 <u_> and it worked
21:19:55 <orion> glguy: I'm writing bindings for a hashing library. Given the same inputs, the output should /always/ be the same. Enigmagic said to me, "if you're using ForeignPtrs then you most likely do not want to use unsafePerformIO". Do you agree? Does this mean that I can never use my hashing functions in pure code?
21:22:32 <codebje> orion, does the _sequence_ of operation matter?
21:23:15 <codebje> if the hashing library only depends on its input parameters and not, say, some memory dereferenced by the input parameters, unsafePerformIO is probably OK
21:23:40 <codebje> but if the library reads memory dereferenced from a pointer, lazy evaluation might mean things happen in a different order to what you expect
21:23:50 <glguy> You also wouldn't want to modify the memory if that's going on
21:24:06 <tommd> orion: This is for your Blake2 bindings?
21:24:11 <orion> tommd: Yes.
21:24:19 <tommd> orion: And the pointers are from some sort of bytestring like container?
21:25:11 <orion> codebje: So, assuming that there are three operations defined: initialize(state, ...), update(state, ...), and finalize(state, ...), you're asking me if it's wrong to, say, call finalize before before update, correct?
21:25:17 <codebje> yes
21:25:22 <orion> Yes, that would be bad.
21:25:47 <codebje> then you probably do not want to use unsafePerformIO :-)
21:25:51 <orion> hah, ok
21:26:11 <tommd> orion: Are you mutating the state?  The way this has been handled in the past is to create a copy of the state before calling a mutating function such as `update`.  In this manner your operations are still pure, returning a new value instead of mutating and old one.
21:26:39 <tommd> Hashing, even calling out to C for hashing, is done all the time and does not need to live in IO.
21:26:39 <orion> State is mutated upon calling update and finalize.
21:26:52 <glguy> You can do more than one thing per unsafePerformIO, you don't need one for initialize and one for update
21:26:54 <tommd> SO create a new context and pass the new context to those functions.
21:27:13 <glguy> If one call allocates a new context, inits it, updates it, and finializes it, then you're fine
21:27:35 <orion> glguy: What you're describing is the C function: int blake2s( uint8_t *out, const void *in, const void *key, const uint8_t outlen, const uint64_t inlen, uint8_t keylen );
21:27:40 <tommd> Yes, or as glguy is saying (I think) you can perform all the operations under the covers and have hash = unsafePIO $ init >=> update >=> final
21:27:48 <tommd> yep
21:27:59 <orion> I think unsafePerformIO is safe there, because there is only ever a single operation.
21:29:17 <tommd> It's not about the number of operations.
21:29:41 <tommd> It's about observability and determinism.
21:30:23 <orion> If there's only one operation/call to C, then by codebje's logic, the sequence doesn't matter (since there is no sequence), and thus unsafePerformIO is OK.
21:30:31 <codebje> if you had just update as a function, calling it twice with the same argument wouldn't mean the same thing as calling it once
21:30:45 <codebje> sequencing is _one_ reason to be worried about unsafePerformIO, not the only reason
21:30:49 <tommd> codebje: You are assuming something in that statement.
21:30:56 <kadoban> So … cabal package names. Are they ASCII? Can you have unicode in them? Not really sure. Looking at a thing in 'stack' dealing with them and kind of confused which they're supposed to be.
21:31:03 <codebje> I am assuming update() modifies its state, yes
21:31:05 <tommd> codebje:  He could indeed have `update :: Context -> Bytes -> Context`.
21:31:17 <tommd> Right, which I am discouraging in favor of a new state.
21:31:29 <codebje> tommd, yes, I'm also assuming that this is in the absence of a copying mechanism for the state
21:31:44 <orion> codebje / tommd: unsafePerformIO $ init >=> update >=> final is exactly the same as the single C call int blake2s( uint8_t *out, const void *in, ...)
21:31:48 <tommd> Bad assumption.  Hash contexts are easy to copy.
21:31:58 <tommd> orion: Yep, agreed.
21:33:00 <orion> tommd: What function might I look at to copy state?
21:33:17 <tommd> Well that depends on how you have it structured, but usually... memcpy.
21:33:49 * glguy copies hash contexts by hand with paper and pencil
21:33:52 <orion> Foreign.Marshal.Utils?
21:34:18 <tommd> orion: You could do it in C (a wrapper, I assume, around existing functions) and pass the new pointer back, then associate a new finalizer.
21:34:38 <tommd> orion: Or you could copy in Haskell and pass the new context in to C land.
21:34:52 <codebje> :t copyBytes
21:34:54 <lambdabot> Not in scope: ‘copyBytes’
21:35:21 <orion> tommd: I'd prefer the latter.
21:35:26 <tommd> Great
21:35:27 <codebje> :t Foreign.Marshal.Utils.copyBytes
21:35:29 <lambdabot> GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> Int -> IO ()
21:36:07 <tommd> So long as the structure is flat you can just copyBytes, as codebje is showing.
21:36:31 <tommd> Be aware of alignment and the actual structure size when allocating.
21:36:59 <orion> I am using hsc2hs to calculate the size and alignment.
21:37:26 * tommd nods
21:40:33 <runeks> How many times will longString be stored in memory in this map? Data.Map.Strict.fromList $ zip [0,1..] (replicate 1000 longString) where longString = "Long string, which -- preferably -- shouldn't be stored in memory multiple times."  ?
21:41:28 <jle`> @src replicate
21:41:29 <lambdabot> replicate n x = take n (repeat x)
21:41:34 <jle`> @src repeat
21:41:34 <lambdabot> repeat x = xs where xs = x : xs
21:41:50 <jle`> runeks: presumably only once
21:41:57 <jle`> if we're talking about ghc
21:42:40 <runeks> jle`:  GHC.DataSize.recursiveSize says multiple times, but I'm not sure it's the correct tool to measure that.
21:42:53 <jle`> :o
21:43:04 <runeks> 66376 for that map it says
21:43:07 <runeks> bytes
21:43:56 <runeks> But again, I'm not sure if that's really accurate.
21:44:00 <jle`> that might be from the map structure itself, but i feel like it shouldn't be using 60 bytes per node
21:44:42 <runeks> jle`: As far as I can see, if the value is immutable anyway, why ever store it more than once, if you know it's the same value?
21:44:54 <glguy> It's storing it once
21:45:00 <jle`> it wouldn't make sense to store it more than once
21:45:08 <runeks> I wouldn't think so either
21:45:09 <jle`> it stores multiple references to the same address in memory
21:45:24 <jle`> Map doesn't directly store values, it stores references
21:45:56 <runeks> jle`: I guess that's what I wanted to know.
21:46:15 <jle`> and assuming replicicate/repeat is implemented sensibly, it'd just be implemented a list of pointers to the same address
21:46:24 <jle`> you can do some testing with Debug.Trace, maybe
21:47:03 <jle`> longString = "hey" `trace` "long string, which ... " should fire off a trace whenever longString is being evaluated
21:47:51 <glguy> > 81 * 8 + 1000 * (3*8 + 3*8 + 8 + 8)
21:47:53 <lambdabot>  64648
21:47:54 <glguy> It's something like this
21:47:59 <jle`> if you try to print out the list (mapM_ putStrLn, maybe), and it only fires "hey" once, then that means that longString is stored once and the evaluation is triggered once
21:48:40 <glguy> 81 character string, each character is a cons cell (8*3 bytes), and there you have 1000 more cons, 1000 more tuple, 1000 Int
21:49:16 <glguy> > 81 * (4*8) + 1000 * (3*8 + 3*8 + 8 + 8)
21:49:18 <lambdabot>  66592
21:49:23 <glguy> There we go, that's closer
21:49:40 <runeks> jle`:  "hey" is only printed out once for recursiveSize $!! m. Good :)
21:49:53 <emmanuel_erc> hello
21:50:36 <jle`> it is possible that GHC decides for some reason to inline the definition of longString
21:50:37 <runeks> where m is the map in question
21:51:12 <jle`> you can force it to by providing an inline pragma ... {-# INLINE longString #-}
21:51:23 <jle`> but...i'm not sure if that makes a difference
21:51:48 <jle`> if it inlines it to one level it'll get replicate 1000 "my long string", which still stores it only once
21:51:54 <glguy> There's no way it's storing 1000 copies of an 81 character string in 66k bytes, so it's obviously not duplicating it
21:52:20 <jle`> it'd be interesting to see if it's possible to get GHC to do weird inlining things in a way that it does store 1000 copies
21:52:23 <jle`> emmanuel_erc: hi! :D
22:10:41 * hackagebot relational-query 0.6.2.0 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.6.2.0 (KeiHibino)
22:30:42 * hackagebot relational-query-HDBC 0.2.0.2 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.2.0.2 (KeiHibino)
22:37:32 <platz> seems like accelerate-cuda should have more downloads.. maybe GPU bound tasks are somewhat hard to come by
22:51:22 <codebje> runeks: necromancy on the topic, but a core dump suggests ghc 7.10.2 makes *4* copies of that string with that expression
22:51:56 <codebje> $ grep -c 'Long string, which -- preferably --' core.19535
22:51:57 <codebje> 4
23:32:49 <glguy_> That wouldn't be a Haskell String bit the static literal it was initialized from
23:35:37 <Juliver_> Hello all. I recently started learning Haskell after years of "imperative only". I got really excited but still have some concerns as of "can I do everything with haskell"? Then I saw: http://prog21.dadgum.com/23.html which got me disenchanted. Will "purity" mean that I will be facing such challenges as described there when doing a real-world project of considerable size with Haskell?
23:37:06 <liste> Juliver_ you sure can have mutable state in Haskell
23:37:34 <liste> so don't sweat it (:
23:37:59 <jle`> yeah, i use mutable state all the time
23:38:09 <Juliver_> liste: thanks - can you point me to how this is done?
23:38:23 <jle`> also, a lot of the "pain" of haskell does come from trying to approach problems from other domains in the asme style of approach (ie, a "game loop" approach)
23:38:36 <jle`> which may or may not be the best way to describe your game
23:38:49 <jle`> directly translating programs is *possible* in Haskell, but not necessarily the best way to go
23:39:09 <liste> Juliver_ there's a lot of facilities for that, IOVar, MVar, TVar, IOArray, STArray... but listen to jle`, there's other ways to structure your game too
23:39:29 <Juliver_> jle`: yep. I already picked up on that by the little I played with it, and the years of experience moving from different approaches throughout the years.
23:39:55 <jle`> but it definitely depends on your project too, a lot of "real-world" things are naturally expressed with destructive state and fun stuff like that
23:40:01 <jle`> at least until someone figures out a nicer way
23:40:49 <liste> s/IOVar/IORef/
23:40:53 <liste> https://en.wikibooks.org/wiki/Haskell/Mutable_objects
23:41:53 <jle`> but one thing haskell is great at is program generation, so it's also definitely possible to isolate the part of your problem that requires state/mutable variables, and then wrap it in a nice denotative/declarative mini-language so you can state your logic purely as well
23:43:05 <jle`> but yeah, it's also a general haskell principle to separate your stateless logic from the effectful parts so it restricts what you have to "worry" about, in terms of state, when writing different aspects of your code
23:57:18 <aramiscd> > 3 + 3
23:57:19 <lambdabot>  6
23:59:29 <foobarfoofoo> > 4 + 4
23:59:31 <lambdabot>  8
