00:00:49 <ThreeOfEight> oh?
00:01:12 <ThreeOfEight> but they should at least be such that if the lhs terminates, the rhs terminates as well
00:01:49 <ThreeOfEight> and as a person coming from theorem proving, "obviously sound" is something I use with great care
00:02:07 <quicksilver> ThreeOfEight: yes, they only improve things :)
00:02:12 <quicksilver> in the technical sense of improve
00:02:15 <ThreeOfEight> I've formalised several algorithms and proofs and found severe mistakes in almost any of them
00:02:25 <ThreeOfEight> *all of them
00:02:29 <quicksilver> they might accidentally make a non-terminating algorithm terminate
00:04:55 <quicksilver> the thing is people have a tendency to think in the language without _|_ and prove stuff in the language without _|_
00:05:13 <quicksilver> some people, anyway. Me, for one.
00:05:50 <ThreeOfEight> Me, too. Logics with a notion of undefinedness are a huge pain to work with.
00:06:35 <ThreeOfEight> And if you have a total logic, you can still do pretty much everything you want to do (but always have to prove termination)
00:06:50 <ThreeOfEight> but if you want to have laziness, a total logic is not a good choice
00:07:37 * hackagebot Lambdajudge 1.0.0.4 - A library to easily host Haskell based programming competitions  https://hackage.haskell.org/package/Lambdajudge-1.0.0.4 (ankitku)
00:07:37 * hackagebot versions 1.0.2 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-1.0.2 (fosskers)
00:09:05 <quicksilver> ThreeOfEight: anyhow I think the most useful answer to your question is "there is no unified summary or unified treatment of all this stuff". In fact I'm not even sure there is a unified *list* of all the RULES.
00:09:46 <ThreeOfEight> Hm. There might be a nice thesis in this.
00:10:01 <ThreeOfEight> Formal verification of GHC rewrite rules
00:10:23 <ThreeOfEight> but I'm pretty sure someone did just that for List Fusion already
00:10:37 <quicksilver> yes, various individual parts have been treated in academic papers
00:11:06 <ThreeOfEight> ah, Brian Huffman did it, yes
00:11:28 <quicksilver> https://wiki.haskell.org/Correctness_of_short_cut_fusion has links to various papers on shortcut fusion
00:11:58 <ThreeOfEight> okay, so does anyone know formal proofs?
00:12:15 <quicksilver> there are some in those references
00:12:26 <quicksilver> see also https://www.cs.ox.ac.uk/ralf.hinze/publications/IFL10.pdf and the 'related work' section of that paper.
00:13:37 <shlomo> Is there a function foldM1 :: (a -> a -> Maybe a) -> [a] -> Maybe a ? Or a similar one I can use?
00:14:01 <shlomo> I mean foldM1 :: (a -> a -> Maybe a) -> [Maybe a] -> Maybe a
00:14:02 <ThreeOfEight> quicksilver: by "formal" I mean "in an interactive theorem prover"
00:14:11 <ThreeOfEight> like Isabelle, Coq, HOL4, HOL Light, …
00:14:16 <quicksilver> that's a quirky definition of formal :)
00:14:36 <ThreeOfEight> not when you work in my area
00:14:41 <ThreeOfEight> everything else is just ink on paper :P
00:14:52 <quicksilver> I used to work in your area.
00:15:17 <quicksilver> a proof in a theorem prover can contain bugs in the assumptions and inference rules
00:15:27 <quicksilver> which is pretty much the same as a proof written in english :)
00:15:34 <ThreeOfEight> not really
00:15:35 <quicksilver> you can make the case that they're easier to spot.
00:15:40 <quicksilver> shlomo: foldM?
00:15:42 <ThreeOfEight> the error margin is orders of magnitude lower
00:16:04 <quicksilver> for some kinds of proof for some kinds of problem, definitely.
00:18:11 <shlomo> quicksilver: I need one which doesn't take an initial value
00:18:21 <shlomo> (accumulator)
00:19:25 <quicksilver> shlomo: steal the first item of your list and use that? :)
00:20:06 <quicksilver> :t \list fun -> foldM fun (head list) (tail list)
00:20:07 <lambdabot> Monad m => [a] -> (a -> a -> m a) -> m a
00:20:21 <quicksilver> :t \fun list -> foldM fun (head list) (tail list)
00:20:22 <lambdabot> Monad m => (a -> a -> m a) -> [a] -> m a
00:20:37 <ReinH> shlomo: No, but you can write foldM1 _ [] = error "empty list"l foldM1 f (x:xs) = foldM f x xs
00:20:51 <ReinH> s/"list"l/"list";
00:20:54 <shlomo> quicksilver: the items are of type a, not Maybe a
00:21:49 <ReinH> shlomo: his/my types are strictly more general, but compatible with what you want.
00:22:13 <ReinH> Oh, you have a list of [Maybe a]?
00:22:18 <ReinH> That's not what foldM does...
00:22:24 <quicksilver> shlomo: isnt the type I gave exactly what you asked for?
00:22:27 * quicksilver scrolls up
00:22:43 <quicksilver> < shlomo> Is there a function foldM1 :: (a -> a -> Maybe a) -> [a] ->  Maybe a ?
00:22:44 <ReinH> quicksilver: I am confused since they said that the list has elements of type a and also of type Maybe a
00:22:54 <quicksilver> :t \fun list -> foldM fun (head list) (tail list)
00:22:55 <lambdabot> Monad m => (a -> a -> m a) -> [a] -> m a
00:23:02 <quicksilver> shlomo: ^^ that is what you asked for.
00:23:06 <ReinH> quicksilver: then they said "I mean foldM1 :: (a -> a -> Maybe a) -> [Maybe a] -> Maybe a"
00:23:11 <quicksilver> oh
00:23:27 <quicksilver> I should read both :)
00:23:36 <ReinH> So if they want something like foldM, they want one of ours.
00:23:45 <ReinH> If they want something called foldM1 that is not like foldM then they want something else
00:23:48 <ReinH> I'm not sure what.
00:23:51 <quicksilver> shlomo: just sequence your [Maybe a] first
00:23:57 <quicksilver> that will force out the Nothings
00:24:04 <ReinH> Perhaps that.
00:24:27 <quicksilver> :t \fun list -> let seqqed = sequence list in foldM fun (head seqqed) (tail seqqed)
00:24:28 <lambdabot> (Monad m, Traversable t) => (t a -> t a -> m (t a)) -> t [a] -> m (t a)
00:24:36 <quicksilver> nope
00:24:45 <ReinH> catMaybes would be more specific
00:24:57 <quicksilver> oh maybe he wants catmaybes
00:25:00 <quicksilver> but I doubt it
00:25:07 <quicksilver> you woudl expect a single nothing to kill it all?
00:25:09 <ReinH> but if they want foldM1 : foldM  :: foldl1 :: foldl then they want one of ours
00:25:21 * ReinH shrugs
00:25:38 <ReinH> quicksilver: well you said "force out the Nothings" so I was going by what you said, not what you said. ;)
00:25:41 <quicksilver> :t \fun list -> sequence list >>= \l -> foldM fun (head l) (tail l)
00:25:42 <lambdabot> Monad m => (a -> a -> m a) -> [m a] -> m a
00:25:48 <quicksilver> possibly that.
00:27:36 <ReinH> Well, it's one of them
00:27:43 <ReinH> Only shlomo knows for sure
00:28:19 <ReinH> I mean, it could be something else, but I think you've listed all the reasonable ones.
00:29:33 <shlomo> ReinH quicksilver : Here's what I'm trying to do: https://gist.github.com/anonymous/98dd8cfb5821c10f50e9
00:34:39 <shlomo> ReinH: the last one you wrote it good for me
00:34:45 <shlomo> thanks all
00:35:30 <ReinH> shlomo: it is? Because that isn't a foldM...
00:36:39 <shlomo> ReinH: yes, it's not really a foldM. I got confused.
00:42:03 <ReinH> I think the one you're looking for is foldM1 merge <=< sequence
00:42:26 <ReinH> using one of the original foldM1 definitions
00:42:27 <quicksilver> which is what my one does
00:42:39 <ReinH> yep
00:42:52 <quicksilver> looks nicer with <=< tho :)
00:42:57 <ReinH> :)
01:27:39 * hackagebot hindent 4.5.6 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-4.5.6 (ChrisDone)
01:56:10 <kqr> is it possible to, using lenses, pick out the second item in a fold?
01:58:17 <quicksilver> kqr: yes
01:58:18 <kqr> s/lenses/optics/
01:58:29 <quicksilver> ix 1
01:58:53 <kqr> hm I thought that'd be it but sec
01:58:54 <quicksilver> > "abcde" ^? folded . ix 1
01:58:56 <lambdabot>      No instance for (Ixed Char) arising from a use of ‘ix’
01:58:56 <lambdabot>      In the second argument of ‘(.)’, namely ‘ix 1’
01:58:56 <lambdabot>      In the second argument of ‘(^?)’, namely ‘folded . ix 1’
01:59:01 <kqr> yeah exactly
01:59:05 <quicksilver> > "abcde" ^? ix 1
01:59:05 <kqr> that's what I get too
01:59:06 <lambdabot>  Just 'b'
01:59:25 <quicksilver> what's your actual fold?
01:59:48 <kqr> it's from https://hackage.haskell.org/package/taggy-lens-0.1.2/docs/Text-Taggy-Lens.html#v:allNamed
01:59:52 <kqr> the return value of that thing
02:03:05 <quicksilver> > ifindOf (folded) (\i _ -> i == 1) "abcde"
02:03:07 <lambdabot>  Just 'b'
02:03:18 <quicksilver> seems like there ought to be a slightly easier way I must say
02:03:22 <quicksilver> but that works
02:03:32 <trix> has anyone interviewed for a regular software engineering job using Haskell?
02:03:33 <kqr> haha
02:03:39 <apriori> hello guys. would someone be so kind to tell me how to write a data declaration of form "data $(name) a = $(name)" in quotation form using template haskell?
02:04:23 <kqr> quicksilver, if I want to do that I could also just do toList on the thing and (!!1), right?
02:04:31 <quicksilver> kqr: that will crash if it doesn't exist, but yes
02:04:32 <apriori> I can't for my life find out what exact constructors I have to call on the quoted "name". also a runQ on a simple [| data Test a = Test |] doesn't really help me to properly identify the gaps
02:04:47 <quicksilver> > elementOf folded 1 "abcde"
02:04:49 <lambdabot>      Couldn't match type ‘[]’ with ‘p0 a’
02:04:49 <lambdabot>      Expected type: p0 a (f a)
02:04:49 <lambdabot>        Actual type: [Char]
02:04:58 <quicksilver> > "abcde" ^? elementOf folded 1 
02:05:00 <lambdabot>  Just 'b'
02:05:07 <quicksilver> kqr: ^^ there you go, that's the way :)
02:06:05 <quicksilver> it's better than just using (!!) because (a) it returns maybe and (b) if your fold was actually a traversal, this way is settable too
02:06:32 <quicksilver> > "abcde" & elementOf traversed 1 .~ 'X'
02:06:33 <lambdabot>  "aXcde"
02:08:07 <kqr> quicksilver, I get a pretty scary-looking type error: http://lpaste.net/1123164274668077056
02:09:48 <quicksilver> kqr: lens type errors always scare me :)
02:11:00 <quicksilver> kqr: it would help to see your code, but you should be doing `markup ^? elementOf (html . allNamed (whatever)) 1
02:11:06 <quicksilver> something like that
02:11:08 <kqr> ahaa
02:11:29 <quicksilver> have you seen xml-lens, by the way?
02:11:40 <kqr> no
02:11:45 <quicksilver> myself I hadn't seen taggy-lens before today
02:11:46 <kqr> well, maybe? but I haven't used it, no
02:11:48 <quicksilver> maybe taggy-lens is great :)
02:11:53 <kqr> haha I don't know
02:11:59 <apriori> no one knowing some template haskell here? :(
02:11:59 <quicksilver> but xml-lens certainly worked for me for a few things I tried
02:12:00 <kqr> I've used it successfully once before so I defaulted to it now
02:12:06 <quicksilver> apriori: sorry, not me
02:12:13 <apriori> ok, ty anyway
02:13:18 <frerich> Ok this may sound really stupid, but: what are useful functions which are useful for any Monoid, i.e. functions of type 'Monoid m => ...'? I understand that a *lot* of things can be viewed as monoids but so far the reason *why* doing so is useful, e.g. how it lets me reuse code or so, escapes me.
02:13:32 <quicksilver> frerich: foldMap
02:13:50 <quicksilver> foldMap is the only reason that Monoids are useful
02:14:08 <quicksilver> dually, the existence of interesting Monoids is the only reason foldMap is useful
02:14:19 <frerich> quicksilver: Ah... never heard of that before, and it has exactly the kind of type I was thinking of. That's the *only* reason that Monoids are useful (at least in terms of reusing code)?
02:14:32 <quicksilver> I am indulging in hyperbole, of course
02:14:44 <quicksilver> but there is a fundamental truth in there somewhere
02:14:50 <frerich> Of course. *cough*
02:14:54 <quicksilver> foldMap is basically everything you can do with monoids
02:14:56 <apriori> ^^
02:15:02 <quicksilver> given a suitably general notion of 'fold'
02:15:07 <quicksilver> hence - really - foldMapOf
02:15:11 <quicksilver> :t foldMapOf
02:15:12 <lambdabot> Profunctor p => Accessing p r s a -> p a r -> s -> r
02:15:16 <quicksilver> haha
02:15:20 <apriori> uff
02:15:27 <frerich> Now it's all clear!
02:15:31 <apriori> totally :)
02:15:42 <quicksilver> foldMapOf :: Monoid r => Fold s a       -> (a -> r) -> s -> r
02:15:54 <quicksilver> given that you build up any old Fold over a structure 's'
02:15:58 <quicksilver> using the combinators in the lens library
02:16:06 <quicksilver> then foldMapOf really is *everything* you want to do with Monoids.
02:16:28 <quicksilver> frerich: it's like map/reduce, I guess
02:16:34 <quicksilver> if you want to be web 2.0 about it
02:16:54 <frerich> Excellent, so I will leverage foldMap to improve ROI via SaaS
02:17:00 <quicksilver> you've got it
02:17:07 <quicksilver> frerich++ # understands Monoids
02:17:54 <apriori> I wonder how much the haskell community, or in general the functional programming community laughed when map/reduce beame "popular"
02:18:02 <apriori> *became
02:19:32 <quicksilver> frerich: I struggled with Monoids too. There is a real duality - you need (1) interesting Monoid instances and (2) interesting examples of folds
02:19:43 <quicksilver> in order to convince yourself that the idea holds water.
02:19:46 <quicksilver> well, I did.
02:20:02 <frerich> Yeah. I just stared at the 'foldMap' type and tried to think of an example. My first thing which typechecks:
02:20:08 <frerich> > foldMap Just ["foo", "bar"]
02:20:09 <lambdabot>  Just "foobar"
02:20:15 <frerich> Now I just need an investor and then I'm good for the IPO.
02:20:40 <quicksilver> if the Monoid instance for Data.Map was mappend = unionWith mappend
02:20:57 <quicksilver> then that would be a fairly good one; you can use that with nested maps to merge hierarchical structures
02:21:36 <quicksilver> see my stackoverflow answer http://stackoverflow.com/a/33656332/2239956
02:21:54 <quicksilver> although I wrote it out with unionWith (unionWith (++)) because the Monoid instance is wrong.
02:22:49 <frerich> Hm, I see. The 'map' part would be applying 'Just' (which works because Maybe a is a Monoid) to every element of the list (which is a foldable) and the  'reduce' part is the folding via mappend (in this case, mappend Just values).
02:23:04 <apriori> I'm not exactly a theoretical expert. but the notion that there is only one monoid instance seems weird to me
02:23:19 <frerich> apriori: I think in many cases there are multiple plausible instances, so people newtype a lot.
02:23:55 <frerich> apriori: You only need a) a 'zero' value and b) some function which takes two values of type 'a' and then produces a new value of the same type. And that b) part is actually what I like somehow: you give tow Monoid values and you get a new one. It's nicely recursive.
02:24:03 <apriori> frerich, thing is.. I think the issue is, that monoid loses all connection to its underlying binary operation.
02:24:43 <apriori> in a way sometimes Monoid op a would be useful.. but why have monoid at all then?
02:24:54 <quicksilver> apriori: it's a very fair question
02:25:03 <frerich> Hm yeah, maybe. I read about Monoid and somebody (Gabriel Gonzalez, I think?) pointed out how neat it is but I leaned back and though "And this makes my program nicer... how?" :-}
02:25:19 <quicksilver> the answer is (IMO) that there really is one *best* monoid for quite a few types
02:25:49 <quicksilver> and for the ones where there isn't, the newtype trick is remarkably useful even if inelegant
02:25:56 <apriori> for *simple* data types that might work
02:26:20 <quicksilver> take a look at https://hackage.haskell.org/package/monoid-extras
02:26:21 <apriori> but.. plz don't hang me.. what about bare numbers? one could consider them a monoid under +, - and what not
02:26:29 <quicksilver> apriori: sure, and we have the newtype trick
02:26:36 <quicksilver> I agree it's inelegant but it does work
02:26:39 <apriori> yeah, as frerich said
02:27:29 <apriori> quicksilver, hm, lacks doc for latest version - weird.
02:27:35 <quicksilver> just been uploaded
02:27:37 <quicksilver> docs not built yet
02:27:39 <apriori> ah, ok
02:27:39 <quicksilver> try version before :)
02:27:46 <apriori> I did, ty.
02:27:48 <quicksilver> > foldMapOf (folded._2) Sum [("foo",1),("bar",2),("baz",5)]
02:27:50 <lambdabot>  Sum {getSum = 8}
02:28:16 <quicksilver> > foldOf (folded._1) [("foo",1),("bar",2),("baz",5)]
02:28:17 <lambdabot>  "foobarbaz"
02:28:38 <quicksilver> `diagrams` is a good package to read the source of to find interesting monoid uses
02:28:44 <obadz> :t folded
02:28:45 <lambdabot> (Applicative f1, Foldable f, Indexable Int p, Contravariant f1) => p a (f1 a) -> f a -> f1 (f a)
02:28:52 <obadz> guaaaaaaaah
02:29:01 <quicksilver> byorgey wrote that package I pasted above 
02:29:10 <quicksilver> to contain the monoid instances he'd found useful in `diagrams`
02:29:33 <apriori> quicksilver, frerich: actually, newtype isn't too bad, since we got generalized newtype deriving.
02:29:43 <quicksilver> obadz: "folded" is the standard fold, the same one you get from the Foldable class
02:29:57 <obadz> :t Data.Foldable.fold
02:29:58 <lambdabot> (Foldable t, Monoid m) => t m -> m
02:30:04 <obadz> looks a bit simpler :)
02:30:32 <apriori> meanwhile, did someone with knowledge about basic template haskell in quotation form join? :)
02:31:11 <apriori> btw, are there any official plans to streamline prelude more?
02:31:24 <f-a> ever got puzzled by ghc type errors? I have just been shown this by a friend xD https://twitter.com/volothamp/status/665103096381579264 
02:31:30 <apriori> like e.g. get rid of fmap, make map = fmap, fold demand foldable etc. 
02:31:52 <apriori> f-a, wtf
02:33:02 <f-a> my exact same reaction apriori :þ
02:34:08 <kqr> apriori, theoretically, what determines a monoid is the type of the value *and* the associative operator. in Haskell we can only dispatch on the type of the value, hence newtypes to give the compiler a hint about which operator we want
02:34:36 <apriori> that was more or less my understanding of it.
02:34:54 <obadz> apriori: fold demands foldable afaik. we should balance our quest for perfection with changes that break backward compatibility..
02:35:11 <apriori> dispatching on the operation type is of course ambiguous 
02:36:24 <apriori> obadz, as long as haskell community doesn't follow the spirit of c++ in which trash is pretty much never being tidied up, I'm fine with that :)
02:38:53 <apriori> let me repost my question: would someone be so kind to tell me how to write a data declaration of form "data $(name) a = $(name)" in quotation form using template haskell?
02:40:39 <apriori> alternatively, giving me a pointer here or there and how to find how to in general identify the gaps in e.g. a partial declaration, say something like [| data $(whathere) |] would help. thing is, I've no real clue what is expected syntactically if I leave out some parts of the declaration and want to fill them with a variable Name
02:41:07 <apriori> motivation is readability. I don't really consider manual AST construction all that readable.
02:43:31 <obadz> apriori: https://skillsmatter.com/skillscasts/6739-park-bench-discussion go to the 3m30s mark
02:45:08 <apriori> obadz, ty - watching.
02:49:51 <apriori> obadz, yup, solid explanations. what I meant more, is.. rather break some stuff early than later. because later one might not even have any realistic chance for it anymore.
02:50:19 <obadz> apriori: I feel that way too.. but it doesn't really work that way. If you break stuff early, there will be no later..
02:50:37 <obadz> apriori: at least that's jtibell's argument
02:51:20 <obadz> apriori: no bigco will be able to defend maintaing a large codebase in a language that has a trackrecord of breaking changes
02:51:30 <quicksilver> frerich: let me try it this way: if one looks an imperative algorithm which takes the form of a loop which goes over some input and builds up some intermediate structures and condenses them to some results, then such can generally be expressed as a foldr.
02:51:43 <obadz> apriori: apparently python3 is a good example to ponder
02:51:54 <frerich> quicksilver: Right
02:51:58 <apriori> obadz, yeah, that was a major fuck up
02:52:01 <quicksilver> frerich: the first argument of the 'foldr' (the function) will sometimes turn out to be a pretty complicated thing
02:52:13 <obadz> apriori: I don't really have an opinion / horse in this race, but johan's points must be considered
02:52:29 <quicksilver> frerich: with the transformation of the imperative program's "state" into some accumulating data structure
02:52:35 <apriori> obadz, ohm, would you mind telling me who that is of that group? I don't know the persons involved
02:52:46 <frerich> quicksilver: Indeed, I noticed this myself, too.
02:53:00 <quicksilver> frerich: sometimes you can compose a complicated monoid instance such that the entire function just becomes `mappend`
02:53:10 <quicksilver> frerich: and the whole thing just becomes a foldMap
02:53:23 <quicksilver> the monoid structure becomes a rather 'declarative' formulation of the problem
02:53:37 <quicksilver> and the solution has a much more declarative == easy to reason about and elegant looking nature.
02:53:42 <quicksilver> that's when Monoids work well.
02:53:50 <frerich> Hm..
02:54:08 <quicksilver> I'm not saying every such imperative loop admits a nice-looking factoring this way
02:54:18 <quicksilver> but when it does work, it is nice - and that is when Monoids work well.
02:54:54 <apriori> obadz, going for non standardized libs is a way, but then interop between them will become hell on earth.
02:56:09 <quicksilver> a combination of having good natural instances for [], Maybe, Map and having a composable language of newtypes, gives us a declarative way of expressing these loops.
02:56:17 <quicksilver> s/loops/Monoid instances/
02:56:48 <obadz> apriori: he was in the 2nd seat from the left
02:57:07 <obadz> apriori: but he didn't voice his point much on that particular video
02:57:20 <apriori> obadz, oh, ok
03:01:17 <quicksilver> frerich: seems like a good topic for a blog post, some good practice Monoid algorithsm
03:03:39 <quicksilver> practical
03:03:48 <obadz> apriori: the point was still mentionned, just not by him
03:03:55 <apriori> obadz, yup.
03:04:18 <apriori> obadz, good and informative video. ty very much for the link.
03:04:21 <frerich> quicksilver: I'd certainly appreciate some motivation on why abstracting something as generic as Monoid is useful.
03:07:41 <obadz> apriori: yvw
03:08:05 <quicksilver> frerich: recognising it is more important than abstracting it
03:08:25 <quicksilver> frerich: but the typeclass mechanism does let us compose Monoid instances
03:08:59 <quicksilver> composition is always a win
03:09:22 <quicksilver> you could do without the typeclass system - but then you'd need names for all the composition operators.
03:10:56 <quicksilver> > foldMap (second Sum) [("foo",1),("bar",4),("baz",9)]
03:10:57 <lambdabot>  ("foobarbaz",Sum {getSum = 14})
03:11:05 <quicksilver> using (++) on the left and (+) on the right.
03:12:29 <quicksilver> you can do things like calculate all the statistical moments in a single pass
03:12:40 <quicksilver> doing multiple things in one pass is one of the motivations, I think
03:13:30 <quicksilver> > foldMap (\a -> (Sum 1,Sum a,Sum (a*a))) [3,4,5,4]
03:13:32 <lambdabot>  (Sum {getSum = 4},Sum {getSum = 16},Sum {getSum = 66})
03:13:44 * quicksilver wonders if any of these is making any sense to frerich as motivation :)
03:14:13 <frerich> quicksilver: Well it's an interesting perspective which I never assumed before. So maybe the fascination eventually manifests as motivation. ;-)
03:14:26 <quicksilver> :)
03:14:31 <quicksilver> fascination is hte very best motivation
03:14:39 <frerich> quicksilver: My initial reaction was always 'Well I can also do that with foldr' but then I actually wrote it and it was indeed more 'noisy',losing the 'declarative' part.
03:15:28 <frerich> FWIW, so far the only nice example I knew for Monoids was the 'combining multiple orderings' thing.
03:15:44 <quicksilver> that's cute, certainly
03:15:47 <frerich> but that always seemed to be a single pearl in a sea of trivialities
03:16:22 <Xandaros> I don't use monoids that often, but conceptually I think they are amazing. (Also semigroups)
03:17:42 <frerich> quicksilver: I think it's interesting to select the operations which you perform in a pass over some foldable by chosing the right Monoid instance, e.g. via Sum.
03:18:11 <quicksilver> frerich: yes. And it's interseting that you can combine multiple operations using the Monoid instance for tuples
03:18:45 <quicksilver> frerich: nad you can collect results in various ways using the Monoid instances for Set, Map, and list
03:18:53 <quicksilver> (if only Set and Map didn't have the wrong instances ;P )
03:19:30 <frerich> Indeed. I'm trying to think of code I may have written where being aware of this idea might have been beneficial. I first thought of the 'rle = map (head &&& length) . group . sort' definition but now see that it's not quite the same thing because it lacks the 'fold' part.
03:19:41 <frerich> It just reminded me a bit of that, this 'perform more than one thing per element'
03:21:52 <frerich> Ah, now I remember, a long time ago I read some blog about different ways to compute the mean value (something like 'mean xs = sum xs / length xs') and advantages/disadvantages of different ways to define this function.
03:23:25 <nani___> Is "learn you a haskell", "write yourself a scheme" correct english? I've never heard anything like this and this is the dumbest question lol
03:23:51 <quicksilver> nani___: learn you a haskell is not correct english, no. It's a joke.
03:24:03 <quicksilver> nani___: that book uses bad grammar for comic effect :)
03:24:13 <nani___> quicksilver ahah ok
03:24:37 <quicksilver> "write yourself a scheme" *is* correct english as long as you believe that "there are many schemes and this is just one"
03:24:49 <quicksilver> it's using 'scheme' to mean 'scheme implementation'
03:25:03 <quicksilver> and "write yourself a scheme implementation" is unargubaly correct grammar.
03:25:06 <quicksilver> unlike my spelling.
03:25:16 * frerich looks at his 'mean xs = let (Sum x, Sum n) = foldMap (\x -> (Sum x, Sum 1)) xs in x / n' and is not sure anymore whether he improved anything :-}
03:25:38 <quicksilver> frerich: not really, no. It shines more in more complex examples I think.
03:27:16 <quicksilver> frerich: except in the technical sense that you're only doing one traversal now?
03:27:30 <quicksilver> but on the other hand you do have a strictness problem now :(
03:27:42 <quicksilver> which I do not know, off hand, how to solve
03:27:55 <frerich> Yeah right. But the 'why', i.e. why is it only a single traversal, is a bit more hidden now than it would have been with a plain 'foldr', I think. Or maybe that's just for me, because this idea is new to me.
03:29:04 <quicksilver> well foldMap is always only a single traversal
03:29:07 <frerich> quicksilver: Do you know other interesting uses of foldMap where the foldable is not a list?
03:29:29 <quicksilver> frerich: well, foldMapOf, sure
03:29:41 <frerich> Ah, you mentioned that earlier, let me look it up again...
03:29:55 <quicksilver> it uses a `Fold s a` from lens
03:30:01 <quicksilver> insteead of a Foldable instance
03:32:30 <quicksilver> something like foldMapOf (\n -> M.singleton n (Sum 1)) (root . entire . attribute "name")
03:33:00 <quicksilver> would (with the right Monoid instance for Map) traverse an entire XML document and count the number of occurrences of each "name" attribute.
03:33:21 <quicksilver> I wonder if those parameters are the right way around
03:33:46 <quicksilver> no they aren't.
03:34:11 <quicksilver> foldMapOf (root . entire . attribute "name") (\n -> M.singleton n (Sum 1))
03:34:55 <quicksilver> if we had, instead, an ADT for haskell source, something similar would calculate the number of times an identifier was used.
03:39:05 <nshepperd_> if you're going to combine folds like that you probably want to use a strict pair
03:39:34 <nshepperd_> data P a b = P !a !b
03:40:26 <quicksilver> nshepperd_: does that help enough?
03:40:40 <quicksilver> nshepperd_: don't we also have the problem that foldMap isn't foldl' ?
03:40:48 <quicksilver> nshepperd_: it doesn't force its accumulator like foldl's
03:40:50 <nshepperd_> although I think foldMap actually does a right associated fold and you really want to make it a foldl to run in constant space...
03:41:17 <quicksilver> foldMap is associated however the Foldable instance wants
03:41:47 <quicksilver> I feel sure edwardk or glguy or shachaf has thought about this though.
03:42:58 <fendor> Test
03:43:03 <nshepperd_> maybe there ought to be a foldMap' that associates things better for strictness
03:45:38 <nshepperd_> you can reassociate the underlying operators with the right monoid (some kind of continuation i think)
03:46:29 <nshepperd_> but you don't know which way is efficient for the data structure..
03:47:08 <quicksilver> nshepperd_: it's not *just* the association though
03:47:23 <quicksilver> nshepperd_: it's the combination of association plus repeatedly forcing the accumulator
03:47:27 <quicksilver> (that foldl' does)
03:47:29 <nshepperd_> you have to put seq in the right place too
03:47:32 <nshepperd_> yeah
03:47:41 <quicksilver> but on the other hand, sometimes you want the right fold
03:47:50 <quicksilver> when you are producing a list instead of a summary value
03:47:55 <quicksilver> and you want to consume it as you traverse
03:48:02 <quicksilver> then the right fold is exactly the right thing.
03:55:40 <nshepperd_> package foldl has a nice applicative interface to combining folds, btw. so you can write something like 'average = (/) <$> sum <*> length'
03:56:11 <nshepperd_> and the result is calculated strictly and in constant space
03:56:20 <quicksilver> that is interesting
03:56:25 <merijn> nshepperd_: Traverses the list twice, though
03:56:58 <nshepperd_> no, it expands into a single fold with a strict pair accumulator
03:57:11 <merijn> oh, that's a different length/sum than normal?
03:57:17 <quicksilver> yes
03:57:34 <nshepperd_> yeah, should have specified there maybe :>
03:57:35 <quicksilver> I wonder if you can convert from the lens fold type to that fold type
03:58:18 <frerich> merijn: I think it's sum/length from Control.Foldl
03:58:36 <nshepperd_> well it's a bit confusing because while these packages both use the word 'fold' for this they mean approximately opposite things
03:58:50 <quicksilver> are they really oppposite?
03:58:54 <nshepperd_> in the foldl package 'Fold' means a sink for values
03:58:58 <quicksilver> oh they are
03:59:06 <nshepperd_> while I understood Lens.Fold to be about sources :)
03:59:44 <quicksilver> I dunno about opposite, but different
03:59:53 <quicksilver> this Fold only specifies the effect on elements
04:00:06 <quicksilver> it doesn't talk about how you generate those elements from a container
04:00:29 <quicksilver> so in fact you could run these Folds on the 'output' of a Control.Lens.Fold
04:01:50 <nshepperd_> yep
04:02:32 <quicksilver> Control.Foldl.fold applies it to a "Foldable"
04:02:54 <quicksilver> by using Foldable.foldr
04:03:23 <quicksilver> but you could use Control.Lens.foldrOf to apply it to a Control.Lens.Fold
04:03:31 <quicksilver> this is very interesting thank you for mentioning this nshepperd_ 
04:04:18 <quicksilver> this is also one of the notions that always baffles me
04:04:34 <quicksilver> it's a package about strict left folds and the way you apply a 'strict left fold' to a Foldable is... with foldr.
04:04:50 <quicksilver> I feel I have an important conceptual gap here.
04:10:14 <quicksilver> nshepperd_: see also http://hackage.haskell.org/package/folds-0.6.3/docs/Data-Fold.html
04:10:33 <quicksilver> nshepperd_: apparently edwardk's L' is Control.Foldl.Fold
04:13:27 <nshepperd_> anything you can do with a list, you can do with foldr
04:13:41 <nshepperd_> in this case, i think it involves continuations
04:16:26 <quicksilver> do we need a family of strict tuple types
04:16:49 <quicksilver> data S4 a b c d = S4 !a !b !c !d etc
04:17:06 <quicksilver> such that "strict (a,b,c,d) = S4 a b c d"
04:17:57 <quicksilver> then I can write foldMap (strict . \a -> (1, Sum a, Sum (a*a)))
04:18:12 * hackagebot open-typerep 0.3.3 - Open type representations and dynamic types  https://hackage.haskell.org/package/open-typerep-0.3.3 (EmilAxelsson)
04:30:36 <slomo> quicksilver: Data.NF seems close to that
04:32:10 <nani___> does haskell design mean that for some problems, if you don't write ideomatic code, you will run slowly? (not that it actually matters to me, and I still don't know almost anything about the language, but I'm curious)
04:32:21 <quicksilver> slomo: well, it's a wrapper which forces deepseq everywhere
04:32:35 <quicksilver> slomo: it's not the same but hmm yes, it might work :)
04:32:58 <quicksilver> well it would work.
04:33:05 <quicksilver> sometimes that might be too-much strictness though
04:33:17 <quicksilver> nani___: no.
04:33:34 <quicksilver> nani___: like all languages, if you write it in some ways it will be slower than others
04:33:46 <quicksilver> nani___: not all the idiomatic ways are necessarily the fastest ways :(
04:34:05 <quicksilver> nani___: although many people consider it an objective to work out how to write code which is simultaneously idiomatic and fast
04:35:36 <quicksilver> slomo: NF doesn't have a Monoid instance, although clearly one could write one
04:44:35 <roelof> I have to find the sum on the numbers of this list: codeIndex2 = [ ("Fish Fingers" , 121),("Nappies" , 1010),("Orange Jelly", 56),("Hula Hoops", 21),("Hula Hoops (Giant)", 133),("Dry Sherry, lit", 540)]
04:44:59 <rom1504> ok, do it
04:45:18 <roelof> I would think to use a list comprehension to make a list with only the numbers and then use the sum function. Is there a better way ? 
04:45:20 <quicksilver> this is quite natural using a list comprehension, roelof 
04:45:28 <quicksilver> yes that is a natural way
04:45:46 <eikke> :t sum . map snd
04:45:47 <lambdabot> Num c => [(a, c)] -> c
04:46:24 <quicksilver> > sumOf (folded._2) [ ("Fish Fingers" , 121),("Nappies" , 1010),("Orange Jelly", 56),("Hula Hoops", 21),("Hula Hoops (Giant)", 133),("Dry Sherry, lit", 540)]
04:46:36 <lambdabot>  188
04:46:54 <quicksilver> erm
04:47:01 <eikke> quicksilver: lens for this, seriously? :P
04:47:03 <quicksilver> did lambdabot say 188?
04:47:14 <quicksilver> because that is not the right answer.
04:47:15 <eikke> hehe, strange indeed
04:48:09 <eikke> :t sumOf (folded . _2)
04:48:10 <lambdabot> (Num b, Foldable f, Field2 a a b b) => f a -> b
04:48:22 <quicksilver> seems a poor decision to buy your dry sherry lit - it might all have burned away before you get home.
04:52:04 <roelof> quicksilver:  this is the right answer when we format it a little bit : "Total....................18.81"
04:52:32 <quicksilver> yes, I know
04:52:38 <quicksilver> I don't understand how lambdabot got that wrong
04:52:42 <quicksilver> think it lost a byte somehow
04:52:47 <quicksilver> > sumOf (folded._2) [ ("Fish Fingers" , 121),("Nappies" , 1010),("Orange Jelly", 56),("Hula Hoops", 21),("Hula Hoops (Giant)", 133),("Dry Sherry, lit", 540)]
04:52:49 <lambdabot>  1881
04:52:53 <quicksilver> disconcerting.
04:54:03 <apriori> I would definitively pick "sum . map snd" on this one
04:54:08 <apriori> lens is total overkill here
04:54:18 <eikke> +1
04:54:19 <quicksilver> it was not a recommendation to use lens
04:54:35 <quicksilver> I was avoiding giving roelof a direct answer because he's working through exercises
04:54:38 <eikke> s/map/fmap/
04:54:38 <quicksilver> so I gave him a hint
04:54:43 <mada> Can ghci's :m qualify a module?
04:54:45 <apriori> ah, well..  :)
04:54:50 <quicksilver> the lens answer was a curios
04:54:51 <quicksilver> ity
04:54:52 <mada> like.. :m +Data.Set as S
04:55:00 <quicksilver> mada: import qualified Data.Set as S
04:55:02 <apriori> made, why not direct "import..."
04:55:12 <mada> quicksilver: ok thanks
04:55:21 <quicksilver> I know for the last two days roelof has been working on list comprehensions
04:55:26 <quicksilver> so I nudged him that way :)
04:55:27 <mada> is there a difference between :m and import in ghci?
04:55:38 <quicksilver> I don't think so, mada 
04:55:42 <apriori> quicksilver, to make him learn on his own.. good thing. I didn't know :)
04:55:43 <quicksilver> :m is the old way
04:55:51 <mada> ah ok
04:55:55 <quicksilver> import is 'relatively' new
04:55:56 <apriori> I pretty much never use :m :P
04:56:06 <quicksilver> older tutorials will mention :m because import didn't used to work in ghci
04:56:51 <nomeata> Is something wrong with my browser, or does https://www.haskell.org/report/mono/2010 really have no table of contents?
04:57:55 <apriori> nomeata, for me it doesn't either
04:58:05 <apriori> kinda bad, given how huge that page is
04:58:08 <nomeata> right
04:58:34 <nomeata> Guess I’ll report it on https://github.com/haskell-infra/hl/issues
04:58:43 <bergey> The one-page-per-section version has a TOC =/
04:58:53 <nomeata> or does someone here feel like creating a pull request?
05:06:43 <merijn> Any numerical/randomness experts? I need to generate K *unique*, uniform randomly distributed values in the range 0 to N. So far I've been keeping a set and iterating until it has K entries, but as K becomes a larger fraction of N the number of duplicates increases...
05:08:01 <flux> merijn, how about encryption algorithms?
05:08:23 <apriori> merijn, flux: e.g. strong hashes
05:08:32 <flux> not hashes, as they don't guarantee uniqueness?
05:08:33 <quicksilver> merijn: can't you generate n1 from [0..N], n2 from [0..N]/n1, n3 from [0..N]/{n1,2} ? 
05:08:46 <apriori> flux they don't guarantee.. but make them extremely unlikely
05:08:52 <flux> but with encryption you have a 1:1 mapping
05:08:53 <merijn> quicksilver: That is very slow
05:09:00 <quicksilver> which part is slow?
05:09:02 <merijn> quicksilver: Keep in mind K is in the order of millions
05:09:14 <apriori> ouch
05:09:36 <merijn> quicksilver: The repeated building of [0..N] and removing one element
05:09:45 <quicksilver> generate K random numbers in the ranges [0..N],[0..N-1],[0..N-2],....,[0..N-K+1]
05:10:00 <ChristianS> merijn: maybe generate [0..N], shuffle that list, and take the first K elements
05:10:05 <merijn> quicksilver: That does not disallow repeats
05:10:14 <quicksilver> merijn: yes it does, I've encoded them away
05:10:28 <quicksilver> there are 0..N-1 possibilities for your second number
05:10:35 <merijn> quicksilver: Eh, I mean it does allow repeats
05:10:47 <quicksilver> the N-1 possibilities for n2 are
05:10:59 <quicksilver> [0..n1) u (n1..N]
05:11:10 <quicksilver> which is a set of size [0..N-1]
05:11:23 <merijn> ChristianS: Building a structure of N values is prohibitively expensive
05:11:24 <quicksilver> so I generated a single random number in the right range
05:11:31 <quicksilver> and then you nudge it into place
05:11:56 <quicksilver> by the time you get to the end you have K nudges to do
05:12:06 <merijn> quicksilver: hmmm, I need to think whether that'll work
05:12:14 <quicksilver> but at least you're only generating K random numbers
05:12:44 <merijn> quicksilver: Actually, that's a pretty smart idea
05:13:06 <merijn> wait, no, I don't think you can get away with K nudges
05:13:27 <merijn> You need to keep track of every selection so far
05:13:33 <quicksilver> yes
05:13:37 <quicksilver> that's inevitable
05:13:39 <merijn> so by the time you get to number K you have K-1 nudges
05:13:55 <quicksilver> any algorithm will in some form store enough information to remember the selections so far
05:14:02 <merijn> So it depends on whether I can think of an efficient way to do the nudges
05:14:06 <quicksilver> you may be able to devise a clever data structure which does that efficiently
05:14:29 <quicksilver> but at point M in the algorithm
05:14:42 <quicksilver> you have an M-set {n0,...,nM} of numbers already chosen
05:14:45 <merijn> That's still going to be O(n^2) then :\
05:14:50 <quicksilver> and it's ordered
05:14:54 <quicksilver> O(K^2) yes
05:15:05 <merijn> Which might still be more efficient than the number of collisions, I guess...
05:15:24 <merijn> I was hoping someone had already invented a generator for this...I can't be the first to need this
05:16:25 <ChristianS> quicksilver: what do you mean by "nudge"?
05:18:53 <quicksilver> ChristianS: (+1) if it's above the number
05:18:58 <quicksilver> nothing if it's below
05:19:43 <xcrimson> problem is that u need to check if your number was previously taken. what if you just "remove" that number from selection.
05:20:03 <xcrimson> so it cannot be taken twice at all
05:20:05 <ChristianS> quaestor1: but won't that screw up the randomness? if x is already selected, the probability that x+1 will be selected would rise (due to nudging).
05:20:14 <merijn> xcrimson: That's hard to do without generating the entire candidate set of values, which is not feasible for large data sets
05:20:30 <merijn> ChristianS: No, because you shrink the range by 1
05:20:52 <merijn> You're just treating "0..(X-1)" as "0..X with n removed"
05:20:57 <xcrimson> i would go with entire candidate set
05:21:05 <xcrimson> memory is cheap
05:21:18 <merijn> xcrimson: That really doesn't work when the entire candidate set is 1,000,000,000,000 64bit ints or more
05:21:23 <ChristianS> merijn: ah, ok
05:21:42 <xcrimson> ah i see
05:21:44 <merijn> xcrimson: Memory is only cheap when you're working on small problems :)
05:22:47 <xcrimson> if problem is big it is hard to come up with a solution better than O^2 :(
05:22:55 <merijn> That's about a few TB by my calculations, which is just a bit bigger than my RAM :p
05:23:25 <merijn> So the question becomes when does n^2 become cheaper than the collisions from birthday paradox...
05:23:43 <xcrimson> kind of
05:24:22 <merijn> There's some PRNG that based on modulo multiplication that guarantee no repeats, but I'm not sure whether they're randomness quality is good enough
05:24:50 <xcrimson> ^2 is a bit pessimistic really. there are better algorythms to search for an item in a list.
05:25:07 <xcrimson> some of them are much faster actually.
05:25:59 <quicksilver> I think my approach is O(NK)
05:26:04 <cchalmers> merijn: I know of http://www.pcg-random.org/using-pcg-cpp.html#insecure-generators, but it's only for certain periods
05:26:39 <quicksilver> if you just check if you've already seen the value and regenerate
05:26:45 <quicksilver> then checking is O(log K)
05:27:06 <nshepperd_> merijn: you might be able to derive an efficient solution using the binomial coefficient
05:27:14 <quicksilver> and the average number of regenerations is O(N^2/K)
05:27:18 <merijn> quicksilver: The cost there is not the checking
05:27:34 <merijn> quicksilver: But the fact that collisions become increasingly likely for larger K
05:27:41 <nshepperd_> merijn: I mean, you can at least count the number of possibilities with or without element 1 and choose it with that probability
05:27:44 <quicksilver> erm
05:27:48 <quicksilver> O(NK/N) I mean
05:27:48 <nshepperd_> and then recurse
05:27:59 <quicksilver> what
05:28:04 <merijn> quicksilver: NK/N is K :p
05:28:08 <quicksilver> the avergage number of collisions is O(K) yes :)
05:28:17 <quicksilver> so if you keep a Set and check for collisions
05:28:30 <quicksilver> gah
05:28:32 <quicksilver> all wrong
05:28:40 <quicksilver> my approach is O(K^2)
05:28:52 <quicksilver> if you check for collisions it is O(KKlogK)
05:28:53 <quicksilver> which is worse!
05:29:11 <quicksilver> I don't think you can do asymptotically better than O(K^2)
05:31:48 <xcrimson> u can make a list of booleans to store which ints was taken
05:32:49 <nshepperd_> ooh yes: m <- uniform (0, (n `choose` k) - 1); then return the mth subset
05:33:01 <nshepperd_> you can calculate the mth subset by counting
05:33:37 <quicksilver> but m choose k is a staggeringly large number, nshepperd_ 
05:33:48 <quicksilver> it might be unfeasible to compute
05:34:08 <quicksilver> or it might just be most efficient thing to do is to compute it :)
05:34:28 <quicksilver> probably merely computing NcK is O(K^2) work.
05:34:30 <merijn> quicksilver: Someone suggest doing a partial Fisher-Yates on a sparse set, so I need to investigate how the hell this works
05:34:38 <quicksilver> merijn: ok, no idea ;)
05:34:39 <merijn> Which looks like it might be linear
05:34:52 <quicksilver> I actually don't believe this is possible in less than O(K^2)
05:34:55 <quicksilver> will be interested if you can
05:35:19 <merijn> well, I guess it's O(K * log K)
05:35:22 <nshepperd_> is it?
05:35:29 <merijn> Since it has log K lookup for map data structure
05:35:48 <merijn> https://ideone.com/vGVNrR (C++ trigger warning :p)
05:36:35 <nshepperd_> oh well (n C k) has roughly proportional to n digits i guess
05:38:02 <quicksilver> nshepperd_: calculating n C k is apparently O(k^4) :(
05:38:24 <quicksilver> oh hang on I misread
05:38:48 <nshepperd_> hmm, closer to k digits i think
05:40:46 <quicksilver> nshepperd_: yeah you're right it's O(KlogK)
05:40:54 <xcrimson> when there is is 1,000,000,000,000 64bit ints and 99% of them are taken u still need to keep list of taken ints somewhere I guess.
05:41:22 <quicksilver> nshepperd_: it's O(K) if you ignore the fact that operations on large integers are not O(1).
05:41:38 <quicksilver> nshepperd_: if you accept that operations on large integers are actually O(log N) then it's O(KlogK)
05:42:56 <quicksilver> so simply calculating nCk is O(KlogK) and then generating the random number is O(logK) and then doing the 'counting' to find which permutation you have selected I don't know, but it sounds like it is O(KlogK)
05:43:12 <quicksilver> so perhaps there is a counting method in logK space and O(KlogK) time
05:43:45 <quicksilver> but it could be O(K(logK)^X) for some X perhaps
05:45:20 <merijn> xcrimson: With that percentage I'd be screwed anyway
05:45:24 <nshepperd_> oh, i didn't know you could calculate n C k so efficiently
05:45:35 <merijn> xcrimson: The real problem with this is the birthday paradox
05:45:57 <quicksilver> nshepperd_: I'm not entirely convinced you can. This paper says you can though http://delab.csd.auth.gr/papers/SBI02m.pdf
05:47:05 <nshepperd_> you need (n-1 C k-1) and (n-1 C k) at each stage to decide whether you should keep or drop the current number
05:50:25 <nshepperd_> maybe this method is not good with n ~ 1 trillion, since it iterates from 1 to n...
05:50:49 <nshepperd_> oh, actually, maybe you can do a kind of binary search to skip ahead through n
05:57:04 <sleblanc> Is there an extension that will add prefixes to data record accessors? e.g. I have data Thing = Thing { a :: A, b :: B }, the functions become "thingA" and "thingB"
05:57:53 <tommd> merijn: The first suggestion, using a block cipher, requries constant memory.  I don't see why that doesn't suffice.
05:58:56 <lyxia> merijn: Keep a set of generated keys and once its size goes above N/2 keep the complement instead?
05:59:10 <BratwurstBoi> Hola, primitives!
05:59:26 <tommd> 1) Construct a block cipher of block size `ceiling(lg2 (|domain|))` (or use FPE).  2) Run cipher in CTR mode 3) Drop any output outside your range.
05:59:35 <tommd> merijn: ^^
06:00:01 <tommd> Constant space, good amortized performance.
06:00:21 <merijn> lyxia: The problem is not the storage of the set of keys
06:00:25 <liste> sleblanc you can achieve that with template haskell, maybe someone's already done it
06:00:34 <merijn> lyxia: The problem is that as the set grows you keep generating more and more duplicates
06:00:41 <merijn> lyxia: Thus slowing down the generation
06:00:49 <sleblanc> liste, thanks for the tip
06:00:52 <merijn> But I think this partial sparse Fisher-Yates might work
06:01:07 <apriori> sleblanc, what exactly is known?
06:01:17 <merijn> Seems to be O(K log K) complexity and O(K) storage
06:01:19 <tommd> So you use a generation mechanism that is bijective, ensuring you never repeat output so long as you don't repeat inputs.  Then you just feed inputs in in lexicographic order from some zero.
06:02:50 <sleblanc> apriori, convenience; it's a way to avoid name clashes when you define multiple record types with similar field names, imagine someThingA and someOtherThingA
06:04:12 <apriori> sleblanc, I know that. still, my question was more, what names etc. are known and which are to be filled..  say e.g. you want a template haskell routine that asks for a record type name and field names and generates everything
06:04:29 <lyxia> merijn: I mean, when you have the set of keys you have not produced yet, there's a set datastructure such that you can just pick a random element directly from it in O(log (N-K))
06:04:41 <lyxia> (uniformly distributed)
06:04:58 <apriori> sleblanc, it's all doable, a bit painful though. I could try to guide you through it (albeit, I'm a noob in TH a well.. just successfully generated a ton of data declarations and instance declarations)
06:05:03 <roelof> quicksilver:  what do you think about this code : http://lpaste.net/145171
06:05:22 <lyxia> merijn: and the switching is so that at the beginning you don't start with O(N) storage if you only needed a small number of keys.
06:06:16 <sleblanc> apriori, ha! Thanks for the help! I don't really have time to work on it right now, I'll do it by hand for now, but I guess it could be a good TH exercise for a total newb like me, too
06:07:00 <apriori> sleblanc, ok. thing is, you gonna use ghci a lot to rebuild an AST by example. 
06:07:12 <sleblanc> apriori, my idea is to simply prepend the record's type name to every accessor function, in camelCase
06:08:15 <apriori> wasn't there something like overloaded field accessors? or was it postponed?
06:08:45 <apriori> I vaguely remember that once being a planned feature
06:08:53 <sleblanc> apriori, or maybe even automatically create stand-alone submodules, and include the submodules in the parent module, so that the original names can also be retained as aliases. That would also get around the issue of name clashes nicely
06:09:07 <quicksilver> apriori: yes, planned for GHC 8 or soon after
06:09:10 <sleblanc> apriori, yes, there is
06:09:13 <quicksilver> apriori: it's a really terrible terrible idea
06:09:17 <quicksilver> apriori: but we're getting it anyway :)
06:09:35 <apriori> quicksilver, it kind of introduces function overloading through the backdoor, I guess
06:09:51 <quicksilver> it reuses implicits
06:10:00 <quicksilver> which are a widely despised (and unused) extension
06:10:07 <sleblanc> apriori, https://ghc.haskell.org/trac/ghc/wiki/Records
06:10:09 <apriori> sleblanc, check the cabal package "vector". it does pretty much something like that. given a template it generates new haskell code in the build process to cover instances for both Double and Float
06:10:11 <quicksilver> they're kind of like typeclasses without the typeclass
06:10:38 <quicksilver> hopefully I will be proved wrong and people will find a way to use it which is lovely :)
06:10:42 <merijn> I'd say they're typeclasses without the name
06:10:43 <apriori> sleblanc, I know the issue.. has hit me several times already as well :)
06:10:46 <quicksilver> you don't *really* know until lots of people have tried it
06:10:52 <merijn> They're pretty identical to typeclasses, tbh
06:10:57 <merijn> Down to the way they're compiled
06:11:15 <quicksilver> the way they are compiled is the most similar part
06:11:21 <quicksilver> the semantics is just odd
06:11:40 <merijn> quicksilver: Why?
06:11:58 <apriori> quicksilver, could you elaborate on them being a bad idea?
06:12:24 <quicksilver> erm... there isn't enouhg room in the margin?
06:12:51 <quicksilver> I don't have time to attempt an explanation now. The "let" syntax used to bind implicit parameters was non-composable in a way which is surprising to haskell users
06:12:55 <quicksilver> and made code hard to reason about.
06:13:30 <quicksilver> roelof: I didn't look very deeply but it looks good. The only thing which jumped to mind is that you implement the code to pad to a fixed length with '.' twice.
06:13:51 <quicksilver> roelof: and that code is identical to `padL` except `padL` uses '0'
06:14:02 <quicksilver> roelof: so you could factor that out and save a bit of code.
06:14:32 <apriori> sleblanc, all it actually does is use the template and CPP and some ugly defines to replace text
06:14:38 <roelof> correct, the code for formatLine and formatCode are almost idential except for the variables and the text I use 
06:15:49 <roelof> he, that the code was idential to lpad I see it because you said. I will look if I can make one function of it 
06:16:14 <apriori> ok, ty anyway, quicksilver 
06:17:54 <quicksilver> apriori: my concern about record overloading is that I very much want every term (subexpression) to have a principle type and to be able to refactor code by naming subexpressions, and I am concerned that careless ad-hoc overloading needlessly breaks that property and leads to code which is harder to abstract and compose.
06:18:02 <quicksilver> I will be delighted to be wrong.
06:18:27 <quicksilver> currently the lens library offers all the tools I need to overload record fields when I choose to without requiring any compiler support.
06:19:25 <apriori> well, I don't really know.
06:20:04 <apriori> I didn't have to refactor that much yet.. using haskell mainly for hobby/weird projects. not productively or anything (I'd love to, but you know managers :P)
06:22:15 <merijn> Well, carter is hiring haskellers ;)
06:22:49 * raichoo uses Haskell at work.
06:22:59 <apriori> merijn, on the other hand I wouldn't like to base my living location etc. around my wish to use haskell at work, either.
06:23:14 <quicksilver> haskell already fails to have the refactoring properties in some cases, incidentally
06:23:27 <quicksilver> [f a, f b, f c] is not always replaceable with map f [a,b,c]
06:23:35 <quicksilver> but one would like not to make it worse :)
06:23:45 <merijn> quicksilver: Damn predicativity!
06:24:00 <quicksilver> indeed.
06:24:00 <apriori> only thing I did so far (semi-productively),  was use for my thesis at my work. my colleges were kind of pissed, but I didn't give a shit. productivity sky rocketed compared to java (context: genetic bin packing algoriths)
06:24:17 <Jinxit> quicksilver: when is it not?
06:24:18 <nshepperd_> oh, I thought they were going to go the route of data Foo { foo :: Int }  ==> 'foo :: Has "foo" s => Lens' s (Element s "foo")' with appropriate instance
06:24:20 <KaneTW> thesis at work?
06:24:24 <nshepperd_> or something along those lines
06:24:38 <KaneTW> quicksilver: what's an example when that doesn't hold? something with undefined?
06:24:43 <nshepperd_> would be horrible for type inference i suppose
06:24:58 <quicksilver> KaneTW, Jinxit : try [show 'a', show 0, show True]
06:25:08 <apriori> KaneTW, yes, collaboratively with the university. 
06:25:22 <KaneTW> ohhh
06:25:58 <quicksilver> and it's not *really* about lists being homogenous either
06:26:32 <quicksilver> because you also can't do ('a',True) & both %~ show
06:26:42 <quicksilver> for (show 'a', show True)
06:27:03 <apriori> raichoo, lucky you :)
06:32:29 <apriori> quicksilver, if I get you right. issue is "f" might be a typeclass function, therefore "overloaded" with the result type of the list element type but arbitrary input type - correct?
06:33:01 <KaneTW> the forall quantifier is in a different place
06:33:36 <quicksilver> apriori: the issue is that functions can't pass polymorphic parameters in a truly polymorphic way
06:34:14 <quicksilver> as soon as you pass 'show' to a function like map or over, you somehow commit to either *keeping* it polymorphic, or only using it at one type
06:34:21 <quicksilver> you can't, e.g., use it at several types.
06:34:37 <Zemyla> Is there such a thing as a factory pattern for Haskell like there is for Java?
06:34:51 <apriori> that was how I kind of understood it. one commits to an instance selection at one point
06:34:53 <quicksilver> some people say "polymorphism isn't first class"
06:35:02 <quicksilver> apriori: funnily enough it's not about instance selection
06:35:13 <apriori> quicksilver, then I still don't get it :)
06:35:14 <quicksilver> this issue arises with parametric polymorphism too
06:35:42 <quicksilver> :t let applyToBoth f (a,b) = (f a, f b) in applyToBoth
06:35:43 <lambdabot> (t -> t1) -> (t, t) -> (t1, t1)
06:35:59 <quicksilver> apriori: ^^ do you see that forced a and b to be the same type
06:36:11 <quicksilver> you might hope that applyToBoth id ('a',True)
06:36:15 <apriori> yes
06:36:18 <quicksilver> would work, and give you (id 'a', id True)
06:36:20 <quicksilver> but it won't.
06:36:29 <quicksilver> so even plain polymorphism like 'id' has this problem.
06:36:37 <quicksilver> it's probably more common to *notice* it with typeclasses
06:36:40 <quicksilver> but it happens without them, too :)
06:36:51 <apriori> quicksilver, ok, ty :)
06:36:55 <quicksilver> GHC has something called RankNTypes which lets you do this
06:37:01 <quicksilver> but it is hard to use correctly
06:37:06 <quicksilver> requiring a lot of type annotations.
06:37:41 <merijn> It's not hard to use correctly and it doesn't require a lot of annotations either
06:37:47 <quicksilver> haha.
06:38:02 <quicksilver> ok, well I was imprecise.
06:38:02 <merijn> In fact, it only ever requires annotations on the actual RankN function
06:38:04 <apriori> quicksilver, merijn: hard/easy is highly subjective - don't forget that :)
06:38:46 <quicksilver> merijn: show us how to write a version of `map` which will take any polymorphic function as an input then?
06:38:53 <merijn> apriori: RankN doesn't change anything about how anything works, in fact it's often counterintuitive that some things *don't* work without RankN
06:39:15 <merijn> The simplest example is usually
06:39:29 <merijn> :t let f (x, y) = (f x, f y) in f
06:39:30 <lambdabot>     Occurs check: cannot construct the infinite type: t6 ~ (t6, t7)
06:39:30 <lambdabot>     Relevant bindings include
06:39:30 <lambdabot>       f :: (t4, t5) -> (t6, t7) (bound at <interactive>:1:5)
06:39:37 <merijn> eh whoops
06:39:44 <merijn> :t let apply f (x, y) = (f x, f y) in apply
06:39:45 <lambdabot> (t -> t1) -> (t, t) -> (t1, t1)
06:39:58 <merijn> That magically requires both tuple elements to be the same
06:40:08 <quicksilver> we just did that one merijn  :)
06:40:15 <merijn> oh, whoops :p
06:40:18 <apriori> yup, higher up
06:40:30 <quicksilver> now, show us how to write the fully Rank-N version of apply
06:40:39 <quicksilver> which works with both monomorphic and polymorphic f
06:40:49 <merijn> I dunno if lambdabot has RankN enabled, but
06:41:36 <merijn> :t let apply :: (forall a . a -> b) -> (x, y) -> (b, b); apply f (x, y) = (f x, f y) in apply
06:41:38 <lambdabot> (forall a. a -> b) -> (x, y) -> (b, b)
06:41:50 <apriori> :set
06:41:50 <merijn> > let apply :: (forall a . a -> b) -> (x, y) -> (b, b); apply f (x, y) = (f x, f y) in apply show (1, True)
06:41:51 <lambdabot>      No instance for (Show a) arising from a use of ‘show’
06:41:52 <lambdabot>      Possible fix:
06:41:52 <lambdabot>        add (Show a) to the context of
06:42:49 <merijn> Oh, right, that doesn't make a lot of sense since the only funciton "(forall a . a -> b)" returns bottom :p
06:43:08 <merijn> > let applyShow :: (forall a . Show a => a -> b) -> (x, y) -> (b, b); apply f (x, y) = (f x, f y) in apply show (1, True)
06:43:09 <lambdabot>      The type signature for ‘applyShow’ lacks an accompanying binding
06:43:26 <merijn> > let apply :: (forall a . Show a => a -> b) -> (x, y) -> (b, b); apply f (x, y) = (f x, f y) in apply show (1, True)
06:43:27 <lambdabot>      No instance for (Show x) arising from a use of ‘f’
06:43:28 <lambdabot>      Possible fix:
06:43:28 <lambdabot>        add (Show x) to the context of
06:43:48 <merijn> I should test before spamming here >.>
06:43:53 <quicksilver> no, there are things unifying with your first type; (const 'z') unifies with it.
06:43:56 <KaneTW> > let apply :: (forall a. Show a => a -> String) -> (x, y) -> (String, String); apply f (x,y) = (f x, f y) in apply show (1, 'a')
06:43:58 <lambdabot>      No instance for (Show x) arising from a use of ‘f’
06:43:58 <lambdabot>      Possible fix:
06:43:58 <lambdabot>        add (Show x) to the context of
06:44:02 <KaneTW> huh.
06:44:10 <merijn> KaneTW: Now Show constraint on x and y
06:44:14 <merijn> s/Now/No
06:44:15 <KaneTW> oh, right
06:44:35 <merijn> > let apply :: (forall a . a -> b) -> (x, y) -> (b, b); apply f (x, y) = (f x, f y) in apply (const 'c') (1, True)
06:44:37 <KaneTW> > let apply :: Show x => Show y => (forall a. Show a => a -> String) -> (x, y) -> (String, String); apply f (x,y) = (f x, f y) in apply show (1, 'a')
06:44:37 <lambdabot>  ('c','c')
06:44:38 <lambdabot>  ("1","'a'")
06:44:42 <merijn> But quicksilver is Right
06:44:49 <merijn> const 'c' works
06:45:03 <quicksilver> merijn: ok, but I want to be able to use (const 'c') and also (id)
06:45:11 <merijn> quicksilver: id makes no sense
06:45:16 <quicksilver> yes it does
06:45:26 <quicksilver> > (const 'c' 1, const 'c' True)
06:45:28 <lambdabot>  ('c','c')
06:45:32 <quicksilver> > (id 1, id True)
06:45:34 <lambdabot>  (1,True)
06:45:39 <merijn> quicksilver: In RankN it makes no sense
06:45:51 <quicksilver> const 'c' and id are both valid substitutions for f
06:45:53 <lpaste_> lambdafan pasted “Do I need To Write An Instance for Assertable Here?” at http://lpaste.net/145172
06:45:56 <quicksilver> and in an untyped language it makes sense.
06:46:00 <merijn> quicksilver: Because those two applications are different
06:46:08 <quicksilver> and *that* is what I mean by RankNTypes being hard to use :)
06:46:26 <apriori> interesting example :)
06:46:37 <quicksilver> you need annotations and it's hard to find an annotation which unifies with everything you want to do
06:46:45 <quicksilver> and it's not always possible without re-stating the question
06:46:50 <quicksilver> so actually RankN isn't so much better.
06:46:56 <KaneTW> which is also why type inference is undecidable for rankn
06:46:58 <KaneTW> :v
06:47:07 <lpaste_> lambdafan revised “Do I need To Write An Instance for Assertable Here?”: “No title” at http://lpaste.net/145172
06:47:07 <merijn> KaneTW: It's decidable for Rank2, though
06:47:16 <merijn> KaneTW: So all the current examples can be inferred
06:47:28 <KaneTW> huh
06:47:30 <KaneTW> it is
06:47:39 <KaneTW> does ghc implement it?
06:47:48 <merijn> KaneTW: No, because it is fiendishly difficult
06:47:56 <KaneTW> haha
06:48:07 <merijn> KaneTW: It's the main reason why there's seperate Rank2 and RankN extensions in case someone is ever masochistic enough
06:48:10 <KaneTW> so, for practical purposes it's undecidbale?
06:48:16 <KaneTW> or is it just difficult to implement
06:48:38 <lambdafan> also, Stack Overflow bounty if anyone is interested http://stackoverflow.com/questions/33613120/reactive-banana-1-0-0-unit-testing-in-the-momentio-monad
06:48:49 <merijn> KaneTW: Tricky to implement and complicated, and most people are perfectly happy annotating so it's a substantial engineering effort for little practical gain
06:49:28 <merijn> KaneTW: As in, the proof/implementation was like 34 pages. If you compare that two inference for ordinary haskell (probably descriable in like 2-3 pages) that's a hard sell :)
06:49:35 <merijn> s/two/to
06:50:25 <griotspeak> Hello
06:50:48 <quicksilver> so apply f (x,y) = (f x, f y) admits the most general type apply :: (a -> b AND c -> d) -> (a,b) -> (c,d)
06:50:56 <quicksilver> but that's not rank-2 or rank-N
06:51:23 <quicksilver> and there are useful (FSOV useful!) examples with different rank-N types
06:51:41 <griotspeak> What are the commonly used analytics and crash reporting libraries for Haskell as a backend?
06:51:47 <griotspeak> web backend
06:52:07 <quicksilver> including apply :: (forall x . x -> d) -> (a,b) -> (d,d)
06:52:19 <fendor> :t print
06:52:20 <lambdabot> Show a => a -> IO ()
06:52:25 <quicksilver> and apply :: (forall x . x -> x) -> (a,b) -> (a,b)
06:52:34 <fendor> :t forall
06:52:35 <lambdabot>     Not in scope: ‘forall’
06:52:35 <lambdabot>     Perhaps you meant ‘forAll’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
06:52:39 <lambdafan> griotspeak : I recommend asking Haskell-Cafe mailing list
06:52:42 <quicksilver> and apply :: (forall x . x -> [x]) -> (a,b) -> ([a],[b])
06:52:49 <quicksilver> and many many more.
06:52:50 <griotspeak> thanks
06:54:07 <apriori> Zemyla, you might wanna repeat that. I guess it got totally lost in the latest "fun" here :)
06:59:04 <roelof> quicksilver:  you mean something like this : http://lpaste.net/145175
07:02:33 <nani___> I'm looking at a random wiki page ( https://wiki.haskell.org/Monad/ST ) and it looks like the formatting breaks with '... that doesn't seem good
07:02:57 <quicksilver> I've noticed that weirdness nani___ 
07:03:14 <quicksilver> roelof: much better :)
07:03:36 <roelof> quicksilver:  so I get a 6 out of 10  :) 
07:10:44 <parsnip> hmm, can't yank with C-y in ghci
07:12:00 <quicksilver> merijn: so how about this revised statement "Unfortunately, although GHC has a RankNTypes extension which allows these examples individually, the most general type you'd want isn't in Rank-N and therfore you still need multiple copies of the same code annotated differently"
07:12:02 <Ankhers> parsnip: You could if you started ghci within emacs.
07:15:42 <parsnip> Ankhers: that's actually where my adventure started. C-y is passed by ansi-term to ghci, so it closes. 
07:15:53 <pothepanda> hi, im relatively new to haskell, can anyone explain why on function definition the type of uncurry is (a -> b -> c) -> ((a, b) -> c) while on ghci it is (a -> b -> c) -> (a, b) -> c 
07:16:32 <nomeata> pothepanda: The arrow -> associates to the right, so in general, instead of a -> (b -> c), you can write a -> b -> c
07:16:34 <divVerent> @pl \ l -> sum l / length l
07:16:34 <lambdabot> liftM2 (/) sum length
07:16:44 <parsnip> but if i C-j to change mode, that helps. 
07:16:50 <divVerent> oh right, it's just the different return types of sum and length
07:17:15 <quicksilver> parsnip: don't use ansi-term, use interactive haskell mode
07:18:31 <parsnip> quicksilver: but will i need a buffer? i just want to do some quick lines. 
07:18:39 <parsnip> *associated buffer
07:19:27 <parsnip> i do have interactive-haskell-mode setup for .hs buffers. 
07:19:36 <pothepanda> nomeata, okey i understand that, but whats the difference stated in those two definitions ?
07:19:47 <parsnip> via (add-hook 'haskell-mode-hook (lambda () (haskell-indentation-mode) (interactive-haskell-mode)))
07:20:07 <quicksilver> parsnip: maybe I have the name wrong; but you don't need a haskell buffer no
07:20:12 <quicksilver> parsnip: just M-x run-haskell
07:20:17 <quicksilver> and you get an interaction buffer
07:20:36 <nomeata> pothepanda: none!
07:20:54 <nomeata> pothepanda: both things that you wrote are slightly different ways to write the same type
07:20:54 <parsnip> quicksilver: aha, perfect, thank you! j
07:21:02 <pothepanda> nomeata, so uncurry returns a function or the result of uncurrying the function ?
07:21:50 <nomeata> pothepanda: that depends on how many things you pass to it: "uncurry f" returns a function taking a tuple. "uncurry f (a,b)" returns the result of applying that function to the given tuple.
07:22:07 <pothepanda> that clarifies it for me thanks :D
07:22:21 <nomeata> you’re welcome
07:24:09 <lamefun> Is there a file path library that works directly with Text?
07:24:39 <darkroom> does anyone know if ghc-mod works with stack yet? I can use vim to code because I keep getting cabal errors :(
07:26:38 <bollu> I don't understand how to write the Functor instance for Cont
07:26:41 <bollu> it's so.. opaque
07:26:46 <bollu> and I'm not able to let the types guide me :(
07:26:50 <bollu> could someone help me out?
07:27:13 <bollu> like, help me understand the "spirit" of fmap over Cont?
07:28:15 <quicksilver> bollu: Cont r a is (a -> r) -> r, right?
07:28:31 <bollu> yes
07:28:33 <quicksilver> so, it's a function which I give (a -> r) , it will give me 'r'
07:28:43 <bollu> yep, since it "has" the a in the closure
07:28:49 <quicksilver> you can pretend it has a way to calculate an 'a' which for reasons of its own it is keep secret
07:29:06 <quicksilver> but it is prepared to use it when I give it functions (a -> r) to calculate
07:29:14 <bollu> okay, so far so good
07:29:22 <quicksilver> (it's really not very secret because I can pass it `id` but this is just an analogy)
07:29:49 <bollu> yeah, but if you want to pass "id", the continuation is forced to have type Cont i i, right?
07:29:50 <quicksilver> so, to get from (Cont r a) to (Cont r b)
07:29:56 <quicksilver> bollu: yes
07:30:22 <quicksilver> we have to teach it how to work on functions of type (b -> r)
07:30:23 <bollu> so doesn't that make it useless? like, if I pass id once, then I can't run anything else past the continuation, right?
07:30:33 <quicksilver> it was already happy to work on functions of type (a -> r)
07:30:37 <bollu> okay, yeah
07:30:41 <quicksilver> and now I want to teach it to work with (b -> r)
07:30:59 <quicksilver> well, given (a -> b) which is what fmap has to work with
07:31:10 <quicksilver> what can we show it how to do with (a ->b) and (b -> r) ?
07:43:04 <bollu> quicksilver: sorry, my laptop froze and I got disconnected
07:43:11 <bollu> right, so we need to teach it to accept (b -> r)
07:43:32 <quicksilver> yes
07:43:35 <bollu> but the problem is we don't *have* the "a" to make the "a" to "b" and then pass the "b" to (b -> r)
07:43:40 <quicksilver> we don't
07:43:46 <quicksilver> but we do have an (a->b)
07:43:48 <quicksilver> and even without an a
07:43:55 <quicksilver> what can we do with (a->b) and (b->r) ?
07:44:16 <bollu> um, compose them?
07:44:37 <quicksilver> right
07:44:39 <quicksilver> which makes?
07:44:49 <bollu> a -> r
07:44:51 <quicksilver> yes
07:44:53 <bollu> (a -> r)
07:45:03 <quicksilver> and the Cont r a we started with *already* knew what to do with an (a->r)
07:45:05 <bollu> which was the original Cont's function?
07:45:10 <bollu> argh, there are three moving parts here
07:45:11 <quicksilver> and now we have one to give it
07:45:16 <bollu> right
07:45:24 <quicksilver> and get an `r` out
07:45:36 <bollu> yes, so now what do we do with the `r`?
07:45:40 <quicksilver> which is what we wanted! So, we built a Cont r b out of a Cont r a and an (a->b)
07:45:46 <bollu> oh wait, what?
07:45:47 <quicksilver> that's our result
07:45:52 <bollu> hm
07:45:55 <quicksilver> we were trying to implement the type (b -> r) -> r
07:45:57 <bollu> yes
07:46:02 <quicksilver> so we need to make an `r` and now we have one
07:46:04 <quicksilver> job done.
07:46:27 <bollu> what we need: (b -> r) -> r. what we have: 1. (a -> r) -> r | 2. (a -> b)
07:46:39 <quicksilver> yes
07:46:51 <bollu> where did you get (b -> r) from?
07:46:58 <quicksilver> that's how you make functions
07:47:08 <quicksilver> to make an Int -> Char you're allowed to 'get' an Int to 'make' a Char
07:47:24 <quicksilver> so, to make a (b->r) -> r you're allowed to 'get' a (b->r) and make a `r`
07:48:16 <bollu> right, so I'm given a 3. (b -> r), and I already have 1. (a -> r) -> r) and 2. (a -> b). So I compose (a -> b) with (b -> r) to get (a -> r) and then pass it to ((a -> r) -> r) ?
07:48:26 <quicksilver> yes
07:48:42 <bollu> hm, I never considered the "getting the (b -> r)" part :) thanks, that was the missing link
07:48:48 <quicksilver> np
07:48:49 <bollu> I'll go back and try to implement it
07:50:19 <bollu> quicksilver: I'm also having trouble naming things
07:50:29 <bollu> what do I name the three functions that I have if I have a function that uses them?
07:50:52 <bollu> like, what do you name the parameter ((a -> r) -> r)?
07:50:56 <bollu> I can't think of a nice name at all
07:50:58 <ben> f
07:51:10 <bollu> then what about (a -> b) and (b -> r)?
07:51:13 <E4xoi> f, g, h
07:51:14 <bollu> f g h ? :P
07:51:19 <bollu> oh, cmon guys.
07:51:25 <bollu> there has to be nicer names?
07:51:31 <ben> i'd also accept f' and f''
07:51:38 * frerich always thought 'a' stood for 'argument' and 'r' for 'result'
07:51:44 <bollu> huh, I see
07:51:47 <bollu> frerich: that makes sense
07:52:27 <frerich> bollu: I don't know whether it's true, I just always read it like that. :-}
07:52:48 <bollu> frerich: even so, It's a great mnemonic
07:54:06 <quicksilver> bollu: if you're deliberately trying to make it clear, why not call them ContAR, aToB and bToR, respectively
07:54:13 <bollu> thanks :)
07:54:36 <quicksilver> the traditional name for the (b->r) part is k
07:54:41 <quicksilver> kontinuation
07:54:49 <bollu> hahaha, that is cute
07:54:59 <bollu> I've seen "s" as well somewhere, I think?
07:56:35 <bollu> if you flip the arguments the Cont (that is, Cont a r), then that will be isomoprhic to (->), right?
07:56:47 <bollu> like, try to write instances for that type
07:58:58 <bollu> why can't I give type signatures when creating instances?
08:00:35 <lpaste_> apriori pasted “inference weirdness” at http://lpaste.net/145177
08:00:41 <apriori> hey guys, a type inference question..
08:01:20 <apriori> why can't the type inference find an instance that satisfies both (Bits a) and (FiniteBits a)
08:01:28 <apriori> although these are exactly the constraints.
08:01:37 <quicksilver> because that's not how it works
08:01:41 <apriori> I see zerobits has : Bits a => a
08:01:51 <quicksilver> it doesn't exhaustively search both and look for solutions.
08:02:07 <quicksilver> instread you have written something which promise it works for any `a` which satisfies both
08:02:13 <apriori> ok.. so I guess the only way is to provide a dummy value externally?
08:02:55 <quicksilver> I don't see what's wrong with what you have?
08:03:08 <quicksilver> the "Bits" is redundant but does that matter?
08:03:20 <apriori> hm
08:03:46 <apriori> yeah, well, the function is of course a simplified variant of something
08:04:01 <quicksilver> hmm indeed it doesn't work
08:04:03 <quicksilver> looking at it
08:04:09 <apriori> I got the function working with a type of : (FiniteBits a, Bits a) => a -> [a]
08:04:16 <apriori> but that demands a dummy value
08:04:29 <quicksilver> you shouldn't need that
08:04:41 <apriori> I'd love to get it of it - because its ugly.
08:04:46 <quicksilver> oh
08:04:57 <quicksilver> it doesn't know your two uses of zeroBits are the 'same' zeroBits
08:05:06 <quicksilver> in isolation they might be two different types
08:05:28 <Myll> is it possible to create a stack data structure in haskell?
08:05:54 <srhb> Myll: Yes, in any number of ways. One easy way is to use the list type, since it already supports the stack operations by definition.
08:06:01 <srhb> The _usual_ stack operations.
08:06:04 <roelof> Can someone help me figure out what must be the xxx in formatlines ( linenr 34). I have figured out that its needed the output of makeBill but if I fill that in I see a message that barcode is not known 
08:06:08 <apriori> quicksilver, so, I guess the dummy val is needed? :(
08:06:11 <quicksilver> apriori: no
08:06:19 <roelof> here the code : http://lpaste.net/145179
08:06:24 <quicksilver> apriori: the simplest thing to do is probably add "z = zeroBits" to the end of your where clause
08:06:43 <quicksilver> apriori: and then replace the two uses of zeroBits with z
08:06:43 <Myll> srhb ok ty
08:06:50 <quicksilver> that forces both uses of zeroBits to be 'the same'
08:07:08 <quicksilver> although I feel a bit dirty because it only works because monomorphism restriction :)
08:07:13 <apriori> quicksilver, got it.. now I wonder, whether i get the same working on the more complex function
08:07:20 <quicksilver> the other way would be to use ScopedTypeVariables and annotate explicitly
08:07:30 <srhb> roelof: You seem to have forgotten the argument to the function.
08:07:42 <srhb> roelof: It's in the signature, but you haven't named it, so referring to it is very hard indeed.
08:08:02 <roelof> srhb:   sorry I do not see what you mean 
08:08:20 * hackagebot lol 0.1.0.0 - A library for lattice cryptography.  https://hackage.haskell.org/package/lol-0.1.0.0 (crockeea)
08:08:21 <srhb> roelof: formatLines :: [(Name, Price)] -> String, but then you have formatLines = ...
08:08:27 <bollu> if I have Cont a r, why can't I create instance Show a => Show(Cont a a)?
08:08:36 <srhb> roelof: Where's the listy argument?
08:08:42 <bollu> apparently type variables have to be distinct? why?
08:08:45 <cchalmers> apriori: something like testFunc = f zeroBits where f a = replicate (finiteBitSize a) a
08:08:46 <apriori> quicksilver, thank you. I will look into that
08:09:17 <roelof> oke , and the list is the output of makeBill barcode 
08:09:31 <srhb> roelof: From the perspective of this function, it doesn't matter.
08:09:31 <roelof> srhb:  is that what you trying to say 
08:10:26 <srhb> roelof: No, I'm saying: You have defined a function that takes a [(Name,Price)] as argument. You want to use that argument as the xxx in your code.
08:10:32 <srhb> roelof: But you haven't named it, so you can't refer to it.
08:10:40 <srhb> roelof: Why not formatLines mylist = ...
08:11:39 <roelof> oke, that is what I also say, and somehow the list is provided by makeBill 
08:12:06 <srhb> roelof: I've not even looked at that, since makeBill doesn't seem to use formatLines in any way.
08:12:06 <Nahiyan> hello. I have a question
08:12:27 <Nahiyan> I'm trying to use Prelude.significand but it's not giving the answer I wanted
08:12:42 <srhb> :t significand
08:12:43 <lambdabot> RealFloat a => a -> a
08:12:45 <srhb> TIL.
08:12:55 <roelof> srhb:   no, makeBill makes a list of (name, prices) from the list of barcodes 
08:13:05 <apriori> time to go for me. bb guys.
08:13:12 <roelof> and that list is needed by formatLines 
08:13:13 <srhb> roelof: I don't see how that matters from the perspective of formatLines
08:13:15 <srhb> OK.
08:13:20 <srhb> But you're still not using the function
08:13:23 <srhb> Two separate issues.
08:13:27 <Nahiyan> I have a number n = 12345. I want a function to give me e.g. 1.2345, where 12345 = 1.2345 * 10^exponent
08:13:44 <Nahiyan> I don't need the exponent but I wanted the significand 1.2345
08:13:57 <Nahiyan> can I do this somehow with the significand function?
08:14:11 <bollu> quicksilver: now, what's the explanation for Applicative on Cont?
08:14:25 <bollu> --(<*>) :: Cont r (a -> b) -> Cont r a -> Cont r b is utterly un-enlightening :(
08:15:33 <bollu> wait, so you have 1. (a -> r) -> r, 2. (((a -> b) -> r) -> r), 3. (b -> r)
08:15:45 <bollu> that is a lot of type juggling to do
08:16:02 <bollu> and you're expected to give a ((b -> r) -> r)
08:16:12 <bollu> "(((a -> b) -> r) -> r)" is..
08:16:26 <johnw> bollu: implement it!
08:16:40 <bollu> johnw: I'll try, I guess :P so, implement first and inspect later?
08:16:46 <johnw> bollu: except for needing to use a lot of lambdas, such a type is a lot easier to write than it is to think about
08:17:00 <johnw> s/write/implement
08:17:14 <bollu> right, lemme have dinner and try it
08:17:29 <bollu> my god, continuations have to be the hardest thing I've encountered in Haskell so far, except for lenses
08:17:34 <johnw> Cont is CPS-transformation, which means it's just a fancy way of handling function results. In a way, you're just juggling things around; it doesn't add any new functionality, just some new flexibility
08:18:04 <bollu> but I remember reading somewhere that Cont is the most "fundamental" monad in some sense?
08:18:06 <lmj> Does a hackage bot eventually run tests on each package, or is that only done for packages that have passed a security inspection?
08:18:12 <bollu> since you can implement other monads over Cont
08:18:12 <bollu> ?
08:18:48 <lmj> i.e., the NotTried state in build reports
08:19:16 <johnw> bollu: it's true, but I wouldn't think about that detail so hard just yet
08:19:28 <bollu> johnw: very well :)
08:23:21 * hackagebot cayley-dickson 0.1.3.0 - Complex numbers, quaternions, octonions, sedenions, etc.  https://hackage.haskell.org/package/cayley-dickson-0.1.3.0 (lmj)
08:28:01 <johnw> bollu: if it helps, (forall r. a -> Cont r b) is isomorphic to (a -> b). Cont is a function abstraction, which is why it's so fundamental. The reason you'd want such an abstraction is that it refies "the rest of the composition" as a value.  That is, given f . g . h, there is no way for f's implementation to "refer to" g . h. It can only work with the value returned from g . h.  But f >=> g >=> h, using the Cont monad, f can use callCC
08:28:02 <johnw> to get a reference to "g >=> h", and then call and recall g >=> h as often and whenever it wants.
08:28:52 <johnw> (my fish operator is backwards there, but I hope you still get the general idea)
08:29:25 <bollu> johnw: so the "point" of a continuation is to be able to explicitly refer to the "rest of the computation" and use it?
08:29:34 <johnw> Cont exposes the machinery of composition to the user
08:29:39 <johnw> yes!!
08:29:47 <johnw> that's is exactly what a continuation *is*
08:29:52 <johnw> it's the next step in the composition, as a value
08:30:25 <bollu> johnw: so, in Cont r a { f :: (a -> r) -> r},  *which* part is the "next step in the composition"?
08:30:33 <johnw> the function (a -> r)
08:31:13 <johnw> that (a -> r) takes an a that the action promises to provide, and passes it to a function that will wrap up the computation and provide an r
08:31:17 <bollu> hm, so since the f *receives* (a -> r) as a parameter, it is free to use (a -> r) as it pleases?
08:31:28 <johnw> yes
08:31:41 <johnw> it can call it anytime it wants an r, or it can not call it at all
08:32:02 <johnw> (although, doing so means getting an r by some other means)
08:32:36 <bollu> johnw: slick. I think I see what you're getting at
08:32:36 <johnw> again, working it through with examples is much easier than prose
08:33:54 <bollu> what happens in LISP where you (I think) have continuations with no types? what if my (a -> r) doesn't return an `r` but an `r'` or something? as in, what protects the continuation from screwing up?
08:34:08 <bollu> s/no types/dynamically types
08:34:11 <bollu> typed*
08:34:23 <johnw> in that case, r is mono-typed, and so it can any value
08:34:33 <johnw> whether that's a screw up or not depends on your program
08:35:46 <bollu> johnw: :) clever
08:36:18 <johnw> time for breakfast now; try implementing callCC yourself without looking up how it's done in the base libraries.  Don't be dismayed if it takes many hours the first time.  That's what it took me.  Thinking through the pain should bring a lot of clarity.
08:36:33 <srhb> Nahiyan: I'm not sure I understand the function
08:36:45 <Nahiyan> basically take any number n = 11242
08:36:54 <bollu> johnw: I don't think I understand callCC well enough tbh, to even write the type
08:36:59 <Nahiyan> which in scientific notation should be 1.1242
08:37:02 <srhb> Nahiyan: Just to be clear, you want something like \n -> n / 10^(gcd 10 n - 1) ?
08:37:10 <Nahiyan> which in scientific notation should be 1.1242 * 10^4
08:37:10 <srhb> But expressed with significand?
08:37:17 <Nahiyan> and return just 1.1242
08:37:21 <Nahiyan> hmm
08:37:38 <srhb> > 11242 / 10^(gcd 10 11242 - 1)
08:37:39 <johnw> bollu: the ability to write callCC is the soul of Cont
08:37:40 <lambdabot>  1124.2
08:37:52 <Nahiyan> mhm
08:37:54 <srhb> Clearly not
08:37:55 <Nahiyan> hmm
08:38:02 <johnw> callCC :: ((a -> ContT r m b) -> ContT r m a) -> ContT r m a
08:38:17 <srhb> Oh, my thinking with gcd is wrong.
08:38:19 <bollu> wait, so there's a continuation transformer? >_< my god
08:38:24 <johnw> oh, sorry
08:38:32 <johnw> callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a
08:38:34 <bollu> johnw: can I write the kid version with no "m" first?
08:38:35 <johnw> do that one first
08:38:37 <bollu> thank you
08:38:54 <Nahiyan> but the problem is that I need to do this with floating point/rational/real numbers as well like 1124.2 -> 1.1242
08:39:03 <Nahiyan> so mod/gcd etc. cannot be used
08:39:18 <johnw> this is really worth puzzling through, even if it takes days or weeks; CPS transformation is a fundamental tool of functional programming, and pops up in many places that at first blush have nothing to do with Cont
08:39:32 <srhb> Nahiyan: I think you need an iterative approach to find the highest 10 divisor, but I'm sketchy on the maths.
08:39:35 <johnw> bye
08:39:44 <bollu> bye :) and thanks for the hep
08:39:46 <bollu> help*
08:40:09 <Nahiyan> ok
08:41:00 <Nahiyan> hmm I found one it's eas
08:41:03 <Nahiyan> y
08:41:08 <Nahiyan> let sig x = if x >= 10.0 then sig (x/10.0) else x
08:41:15 <Nahiyan> thanks
08:51:22 <ocramz> hi all
08:52:16 <ocramz> in a typeclass declaration, what does it mean to enclose a default implementation in a `#ifndef HLINT` block?
08:53:35 <srhb> ocramz: Nothing, it's not Haskell, but a preprocessor directive. When preprocessed it will only choose that block if HLINT is not defined.
08:56:37 <ocramz> srhb: I thought so, but I still don't see the connection. Does HLint provide extra type annotations when it's present?
08:57:23 <srhb> I don't know.
08:58:42 <hexagoxel> ocramz: well probably the #if-guarded part causes some hlint warning, which are thus suppressed.
09:00:30 <ocramz> hexagoxel: now I got it, thank you
09:09:09 <glguy> The problem is that hlint can't parse the "default" syntax and just falls down
09:11:14 <TheArtist> I have a path "foo/bar/zar/jar/har" and a function takeDirectory1 that with that path as input keeps "foo" . How can i use that function to take "foo/bar/zar" ?
09:14:44 <mambo> Hi, if anyone is familiar with parsec and have free time, so here is example html parser: https://www.fpcomplete.com/project/144967/Bf0Q9URMkO
09:15:39 <srhb> TheArtist: What does "keeps" mean?
09:15:53 <TheArtist> outputs
09:16:08 <srhb> TheArtist: It sounds like your function takes that whole String and returns back only "foo" -- in which case it cannot do what you want.
09:16:15 <srhb> TheArtist: If instead it also returned the rest...
09:16:32 <TheArtist> yep thats exactly what it does.
09:16:34 <mambo> it starts of with try.. but try behaves unexpectedly and "eats" '<' symbol
09:17:10 <srhb> mambo: The page is a 404 here.
09:17:29 <TheArtist> srhb: Is there a standard function that would do what i want?
09:19:08 <mambo> sorry, it seems already removed, hre is a new link https://www.fpcomplete.com/project/144989/ODzZ032oCj
09:19:11 <srhb> TheArtist: Standard -- I don't think so. But the directory or filepath packages both look helpful. Or you could roll yout own.
09:19:31 <TheArtist> srhb: Ok, i'll check it out
09:21:10 <srhb> mambo: Does the try succeed?
09:21:38 <mambo> it seems not, you can run it right there
09:23:24 * hackagebot sneathlane-haste 2 - A compositional web UI library, which draws to a Canvas element  https://hackage.haskell.org/package/sneathlane-haste-2 (JasonPriestley)
09:23:26 * hackagebot treersec 1 - Structure Editing Combinators  https://hackage.haskell.org/package/treersec-1 (JasonPriestley)
09:29:48 <srhb> mambo: You're misread the option docs I guess
09:29:59 <srhb> wHm no.
09:30:02 <srhb> Nevermind
09:32:07 <orion> What's the status of HaLVM? Is it dead?
09:35:56 <ironChicken> given that the igraph bindings on hackage are broken (libigraph's API has changed since they were written), does anyone have any suggestions for haskell libraries that implemented graphs with weighted edges?
09:36:46 <ironChicken> and does the author of igraph hang out here, by any chance?
09:38:24 * hackagebot opaleye-trans 0.3.0 - A monad transformer for Opaleye  https://hackage.haskell.org/package/opaleye-trans-0.3.0 (wraithm)
09:41:54 <glguy> orion: HaLVM is under active development
09:42:03 <orion> Nice. :)
09:48:02 <kurt11> how do I see the code for a specific typeclass to learn how it works
09:48:23 <glguy> There are source code links in the documentation
09:48:24 <kurt11> In other words, I want to see the basic source declaration for a given typeclass.
09:49:49 <monochrom> use :info on the type or the type class. it will tell you the instance you want is defined in which module. then find that module's source code.
10:00:22 <Myll> i'm not sure why my call to createTree has the wrong arguments, line11: http://hastebin.com/puweliguso.hs
10:00:49 <srhb> Myll: Precedence. You want to pattern match on (x:xs) etc.
10:01:18 <srhb> Myll: (x:xs) (y:ys) (Node v l r)
10:01:38 <srhb> Myll: Those are three arguments. Your version... I think it has 8. :-)
10:02:11 <Myll> oh.. in my brain it looks like 3 arguments
10:02:13 <srhb> Myll: There are other problems too, though.
10:02:14 <Myll> lol
10:02:45 <srhb> For instance, the pattern match on (Node v l r) is not a list.
10:02:46 <Myll> x:xs is just a list, why doesn't it count as 1 argument?
10:03:07 <Myll> oh, i don't know anything about pattern matching
10:03:51 <Cale> Myll: createTree x:xs y:ys Node (v l r)  means   (createTree x) : (xs y) : (ys Node (v l r))
10:03:59 <Cale> or to add even more parens...
10:04:14 <Cale> (createTree x) : ((xs y) : ((ys Node) ((v l) r)))
10:04:30 <Myll> well shit lol
10:04:57 <Cale> Function application always binds tighter than any infix operator
10:05:11 <srhb> Myll: And third, the last line, `createTree $ ...` is `createTree (...)` -- so here you're only applying the function to one argument.
10:05:33 <Cale> If there's only one thing you remember about precedence in Haskell, that would be the thing to keep in mind (and it's not even technically about operator precedence)
10:05:38 <srhb> Myll: I'm also pretty sure you don't mean to wrap the Node in yet another list in the second line.
10:06:04 <srhb> Myll: (even then, you've only given it two arguments there.)
10:06:17 <srhb> or no. Lots more. Missed an ending brace.
10:06:30 <srhb> You're also applying ys to (Node ...)
10:06:36 <srhb> And ys is not a function.
10:06:42 <srhb> Perhaps we should start over from line one :-)
10:08:01 <stoogenmeyer> hey, do import statements have to be at the top of a file?
10:08:22 <srhb> Myll: I would also advocate an approach where you don't actually just mash things into the program unless it actually makes sense. To do that, once you've fixed the first line of the definition, we can fill out the rest with `undefined` and check if it compiles. :)
10:08:47 <srhb> Myll: But let's start with the arguments?
10:08:57 <Cale> stoogenmeyer: yes
10:09:01 <roelof> How can I improve this : http://lpaste.net/145187 . IM not happy with the fact that I use a function call three times to the same function in diiferent functions ? 
10:09:30 <Myll> my line11 looks like this now: createTree xs [(Node x Empty Empty)]++[y]++ys (Node v l r)
10:09:40 <Cale> roelof: Define  something = formatPence . makeTotal . makeBill  ?
10:09:50 <srhb> Myll: Scrap all those lines and replace them with ... = undefined
10:10:21 <srhb> Myll: Actually, perhaps we should move this to PM so we don't spam the channel. If you want to?
10:10:41 <monochrom> don't worry, this is not spamming
10:10:45 <srhb> OK :)
10:11:57 <srhb> Myll: How does your argument line look now?
10:12:59 <srhb> Oh well.
10:13:03 <breadmonster> hey guys.
10:13:06 <breadmonster> what's up srhb?
10:13:40 <srhb> Nothing much, a person just left/dropped in the middle of unsolicited advise :-)
10:13:59 <breadmonster> Haha okay.
10:14:10 <Cale> Hey breadmonster, I saw you sent me a message the other day while I was quite busy. I'm still fairly busy, but if you leave me an actual question or something, I'll try to respond while waiting for the compiler :)
10:23:27 * hackagebot graphmod 1.2.7 - Present the module dependencies of a program as a "dot" graph.  https://hackage.haskell.org/package/graphmod-1.2.7 (IavorDiatchki)
10:27:50 <roelof> Cale : you mean change the main to what you said ? 
10:27:59 <Cale> roelof: huh?
10:28:20 <roelof> Cale : roelof: Define  something = formatPence . makeTotal . makeBill  ? 
10:28:22 <Cale> roelof: I was just saying, if you want to reduce repetition, define a function
10:28:35 <Cale> and then use that function instead of the repeated expression
10:28:41 <stoogenmeyer> Could anyone critique the following piece of code? I feel that it is very inefficient and not really utilizing haskell being lazy.. https://gist.github.com/rikonor/60607168a50933d0d106 thank you
10:29:32 <roelof> oke, Then I have to find out how I can put the outcome of makeBill in a variable that I can use. Any tips ? Cale 
10:30:05 <Cale> let x = makeBill barCodes in ... use x ...
10:30:06 <Cale> ?
10:30:24 <Cale> Or equivalently, stick a where declaration on the thing you're defining?
10:31:12 <roelof> oke, but then makebill is still several times called to make the same output again 
10:31:30 <roelof> or do we misunderstood each other 
10:32:34 <Cale> I don't understand, if you don't want to compute it multiple times, then compute it once, and pass the result to where you need it.
10:33:27 * hackagebot retry 0.7 - Retry combinators for monadic actions that may fail  https://hackage.haskell.org/package/retry-0.7 (MichaelXavier)
10:36:08 <roelof> Cale : that is what I try to find out. How to make the outcome of the Makebill function global and I do not see how I can do that with a let .. in function 
10:36:24 <Cale> You... don't make it global
10:36:38 <Cale> Well, I suppose since barCodes is constant you could
10:36:57 <Cale> theBill = makeBill barCodes
10:37:16 <roelof> barcodes is constant and that is why the outcome of makeBill is also constant 
10:37:57 <roelof> and when I can change this formatTotal n = "Total" ++ padL (lineLength - length "Total") '.' (formatPence (makeTotal (makeBill barCodes))) ++ "\n"
10:38:19 <roelof> to formatTotal n = "Total" ++ padL (lineLength - length "Total") '.' (formatPence (makeTotal theBill ) ++ "\n" 
10:40:59 <helpmeobi1> what is the easiest way to write e commerce sites in haskell?
10:41:01 <helpmeobi1> :)
10:41:04 <helpmeobi1> super easy
10:41:08 <helpmeobi1> everything abstracted
10:41:12 <helpmeobi1> to a few levlers
10:41:15 <helpmeobi1> levers
10:41:33 <nchambers> pay someone to do it for you
10:42:35 <roelof> helpmeobi1:  that is one of the projects Im will try to make when I more familiar with haskell 
10:43:50 <srhb> helpmeobi1: I don't know what a few levers is, but I suspect nothing that close exists.
10:52:19 <roelof> helpmeobi1:  any idea what for framework ? 
10:52:46 <lpaste_> tzh pasted “for stoogenmeyer” at http://lpaste.net/145192
10:53:08 <tzh> ...which isn't really a "critique" of your existing code as such, but hopefully it'll be somewhat helpful
10:54:36 <bollu> oh my god, trying to write the applicative instance for Cont r a is torture :(
10:54:41 <bollu> I think I'll have to sleep on it
10:56:08 <shachaf> It's not that terrible. Even djinn can do it.
10:56:23 <monochrom> haha, easier said than done
10:56:39 <t4nk119> hello, does anyone known how can i haskell run on my mac version 10.5.8 
10:56:44 <bollu> shachaf: really? o_O
10:56:52 <t4nk119> yes
10:57:14 <bollu> monochrom: I'm struggling to understand wtf is supposed to happen. I'm trying to wrap my head around how the cont function and the cont value should interact
10:57:24 <bollu> "let the types guide you" isn't helping :(
10:57:33 <bollu> but I want to do it by myself since johnw asked me to
10:57:39 <shachaf> I guess your problem is with e.g. ((a -> r) -> r) -> ((b -> r) -> r) -> (a -> b -> r) -> r ?
10:57:58 <gfixler1> t4nk119: you mean runhaskell?
10:58:06 <bollu> apCont :: (((a -> b) -> r) -> r) -> ((a -> r) -> r) -> (b -> r) -> r
10:58:09 <srhb> t4nk119: Or GHC?
10:58:36 <helpmeobi1> hmm'
10:59:00 <t4nk119> i can't find haskellplatform for mein mac version
10:59:08 <t4nk119> *my
10:59:23 <lispy> t4nk119: el capitan?
10:59:32 <t4nk119> ?
10:59:37 <shachaf> System 7?
10:59:40 <lispy> t4nk119: what is your mac version?
10:59:55 <t4nk119> 10.5.8
11:00:27 <lispy> t4nk119: Sorry, I don't know how to help
11:01:07 <glguy> 10.5 is from 2007. You probably aren't going to find any recent GHC builds targetting that
11:01:26 <gfixler1> 10.5.8 is Leopard, I think, which is 2009
11:01:35 <orion> Is there a way to instruct cabal to only export certain C symbols? For example, if I have a C function "bar" which is called by the C function "mypackage_foo", I only want "mypackage_foo" exported and not "bar" to avoid name clashes.
11:01:36 <t4nk119> i just start study computer science and my first programming language is haskell... 
11:01:43 <glguy> Mac OS X v10.5 "Leopard" was released on October 26, 2007.
11:01:43 <t4nk119> yes it's 2009
11:01:44 <srhb> t4nk119: There are some Leopard GHCs in the wild, but you're not going to have an easy time with such an old OS X
11:01:46 <glguy> -- wikiepdia
11:01:59 <gfixler1> glguy: 10.5.8 is 2009
11:02:03 <srhb> t4nk119: Easiest bet might be to take one of those, but be aware that a lot of things have changed since then.
11:02:24 <srhb> t4nk119: To the point where you might be better off just getting a virtual machine with Linux running it :)
11:02:34 <gfixler1> docker instance?
11:02:37 <srhb> Yeah.
11:03:12 <srhb> I genuinely think that will bring the least amount of pain. :)
11:04:43 <t4nk119> ok, i will do my research on that, thank you! 
11:05:21 <srhb> Although if you're not familiar with Docker, maybe Virtualbox or something is simpler. :)
11:06:08 <t4nk119> i think i've heard about Virtualbox...
11:06:51 <srhb> t4nk119: Just to be clear, what I'm advising is running Linux in a virtual box, to install GHC/Haskell platform. Just so you don't get disappointed when there's a bit of work involved. :-)
11:07:32 <lispy> Finding a version of virtual box to run on osx 10.5.8 might be a challenge (dunno, haven't looked)
11:07:45 <srhb> I hadn't even considered that. ._.
11:08:21 <lispy> If upgrading to a newer version of OSX is possible, that would be the path of least resistance
11:09:09 <lispy> QEMU is another option that it likely to work well with older OSX, but it's less user friendly.
11:09:15 <t4nk119> like this? http://www.oldapps.com/mac/virtualbox.php
11:09:34 <lispy> t4nk119: cool
11:10:08 <t4nk119> i dont think i can upgrade.. i have a powerbook G4
11:10:13 <warbo> hello, does anyone know a template-haskell 2.10 equivalent of 2.9's ClassP? I'm looking at some code with "ClassP foo [bar]", and it seems Pred (of which ClassP was a constructor) has been replaced with Type, but I can't see if there's a straightforward alternative to ClassP (e.g. "ConstraintT" takes no arguments)
11:10:18 <srhb> Indeed, that will be hard.
11:10:43 <t4nk119> doing my best... 
11:11:09 <srhb> t4nk119: No doubt. :) You could also consider running it on a vps somewhere and just doing the work via ssh.
11:11:19 <srhb> t4nk119: If that's an option. :)
11:15:49 <t4nk119> yes, thats possible too, but my internetspeed is very slow at home, and i dont want to end up staying at uni every day till late
11:23:52 <warbo> after some experimentation, it seems that I may need to use something like: ForallT [PlainTV bar] [AppT (ConT foo) (VarT bar)]
11:24:07 <t4nk119> "You can use GHCi (an interactive Haskell mode) and the ghc compiler from your new prompt." if i understand right, i don't need to download haskell extra with virtualbox?
11:25:40 <ReinH> Where are you reading that?
11:26:01 <t4nk119> https://www.fpcomplete.com/page/haskell-eval-vm under usage
11:26:53 <t4nk119> installation of virtualbox 4.3.14 just failed
11:32:00 <lpaste_> lambdafan revised “Do I need To Write An Instance for Assertable Here?”: “Possible path to solution or dead end” at http://lpaste.net/145172
11:48:04 <_m_ryan> hi, how can i case the two var?
11:48:20 <_m_ryan> i mean two variable at the same time
11:48:29 <fizruk> _m_ryan: use tuples
11:49:16 <fizruk> > let (x, y) = (1, 2) in case (x, y) of (1, 2) -> "hey"
11:49:17 <lambdabot>  "hey"
11:53:35 <stoogenmeyer> if I define a new class type, for example `class Listable a` with a method such as `toList :: a -> [Int]`.
11:54:16 <stoogenmeyer> I then try to implement toList for [Int], so I do `instance Listable [Int]` and set `toList = id`
11:54:33 <hexagoxel> meh, there is no `instance Binary (Proxy a)` ?
11:54:53 <stoogenmeyer> but I get a complaint from ghc: `Illegal instance declaration for ‘Listable [Int]’`
11:55:05 <_m_ryan> thank fizruk :)
11:55:37 <stoogenmeyer> I'm following http://www.seas.upenn.edu/~cis194/spring13/lectures/05-type-classes.html which does exactly that.. so why doesn't it work?
11:56:14 <fizruk> stoogenmeyer: you might need FlexibleInstances, the complete error message should tell you that
11:56:26 <stoogenmeyer> it does
11:56:57 <fizruk> so you should turn it on with either {-# LANGUAGE FlexibleInstances #-} or -XFlexibleInstances
11:56:58 <stoogenmeyer> does the need for a circumvention mean that this is not something that is usually done?
11:57:42 <fizruk> FlexibleInstances is a harmless extension which is widely used
11:57:53 <stoogenmeyer> cool thanks.. works
11:57:57 <stoogenmeyer> I used the first option
11:58:12 <stoogenmeyer> how would I do it with the second? for the first I just added it at the beginning of the file
11:59:01 <fizruk> the second is a flag you can pass to ghc in command line
11:59:22 <fizruk> I think most people use LANGUAGE pragma
11:59:35 <fizruk> but in GHCi you will use flag like this:
11:59:44 <fizruk> :set -XFlexibleInstances
12:01:15 <orion> Does anyone know how to prevent GHC from exporting the symbols of a C file?
12:06:26 <stephenmac7> Hey, I'm having an issue with finding an approach to parsing the format described here: https://github.com/Doublevil/JmdictFurigana to get a type of [(String, Maybe String)]. Does anyone have any suggestions?
12:10:52 <lyxia> stephenmac7: why Maybe String?
12:11:20 <lyxia> Instead of (at least) [(String, String, String)]
12:11:25 <stephenmac7> lyxia: Some parts of the "kanji reading" (the part before the first pipe) have no corresponding reading
12:12:51 <stephenmac7> So, for the first example, I'd like to get [("頑", Just "がん"), ("張", Just "ば"), ("る", Nothing)]
12:13:10 <lyxia> ah you mean that type for every entry?
12:13:21 <lyxia> I was thinking the type would represent the whole file
12:13:40 <stephenmac7> Oh, no. For each entry. Sorry I wasn't specific enough :(
12:20:23 <stephenmac7> lyxia: Now that I think about it, I might have better luck with a more specific question.
12:21:14 <lyxia> Indeed
12:23:31 * hackagebot pandoc-citeproc 0.8.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.8.1 (JohnMacFarlane)
12:23:53 <ReinH> stephenmac7: Why Maybe String? Why not empty string?
12:24:08 <mjhoy> I want to move from two maybe values to a Maybe (a,b) ... am I missing an obvious function?
12:24:55 <stephenmac7> ReinH: TBH, no particular reason. I thought it might represent it better.
12:25:02 <ReinH> case pair of (Just a, Just b) -> Just (a,b); _ -> Nothing
12:25:19 <ReinH> I don't know of an existing function
12:26:09 <tzh> mjhoy: `\a b -> (,) <$> a <*> b` maybe?
12:26:31 <lyxia> liftM2 (,)
12:27:26 <fizruk> :t liftA2 (,)
12:27:28 <lambdabot> Applicative f => f a -> f b -> f (a, b)
12:27:35 <ReinH> Oh, you dont start with a pair. Right. liftA2 (,)
12:27:35 <mjhoy> lyxia: ah, that's what i'm looking for. thanks
12:29:22 <fizruk> :t Data.Bitraversable.bisequence
12:29:23 <lambdabot> (Monad m, Data.Bitraversable.Bitraversable t) => t (m a) (m b) -> m (t a b)
12:29:59 <fizruk> > Data.Bitraversable.bisequence (Maybe "hello", Maybe "world")
12:30:01 <lambdabot>      Not in scope: ‘Data.Bitraversable.bisequence’
12:30:01 <lambdabot>      Perhaps you meant one of these:
12:30:01 <lambdabot>        ‘Data.Traversable.sequence’ (imported from Data.Traversable),
12:31:32 <platz> :t \f z xs -> foldr (liftM2 f) (return z) xs
12:31:33 <lambdabot> (Monad m, Foldable t) => (a1 -> a2 -> a2) -> a2 -> t (m a1) -> m a2
12:31:38 <platz> do a function in base generalize this?
12:32:06 <platz> foldM or sequenceA are different
12:33:59 <fizruk> :t fmap foldr . traverse
12:34:01 <lambdabot> (Foldable t, Traversable ((->) b)) => (a1 -> a -> b) -> (b -> a1) -> b -> t a -> b
12:35:35 <fizruk> :t \f z -> fmap (foldr f z) . sequence
12:35:36 <lambdabot> (Monad f, Traversable t) => (a -> b -> b) -> b -> t (f a) -> f b
12:38:00 <platz> that is a bit cleaner
12:41:18 <fizruk> :t \f z -> foldr (liftA2 f) (pure z)
12:41:19 <lambdabot> (Applicative f, Foldable t) => (a -> b -> b) -> b -> t (f a) -> f b
12:41:35 <fizruk> platz: I think this is what you need ^
12:42:46 <joco42> what can i do in this situation ? https://usercontent.irccloud-cdn.com/file/35EJ1vP2/Screen%20Shot%202015-11-13%20at%2022.41.31.png
12:42:48 <platz> yeah only applicative's constraints are req'd, otherwise it's almost the same thing I had
12:43:15 <platz> really just noting that this doesn't appear to be common enough to be a library somewhere
12:43:17 <joco42> case of ?
12:43:23 <fizruk> platz: Applicative is less restrictive than Monad, so you kind of win :)
12:43:39 <joco42> is case the only way i can use where in multiple functions?
12:44:00 <fizruk> joco42: sounds like you could use a template engine
12:44:43 <platz> fizruk: it's just sequence with the concrete functions lifted out
12:44:46 <platz> @src sequence
12:44:46 <lambdabot> sequence []     = return []
12:44:46 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:44:46 <lambdabot> --OR
12:44:46 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:45:00 <lyxia> joco42: that or define vt at the top-level
12:45:44 <lyxia> :t sequenceA -- platz 
12:45:45 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
12:45:51 <fizruk> platz: sorry, I don't follow
12:46:14 <fizruk> platz: how is foldr a sequence?
12:46:23 <joco42> lyxia:  this works :
12:46:33 <joco42> https://usercontent.irccloud-cdn.com/file/VgGRFjE7/Screen%20Shot%202015-11-13%20at%2022.45.41.png
12:46:56 <joco42> fizruk:  like TH ?
12:46:57 <platz> fizruk: look at the definition of sequence and you tell me ;)
12:47:06 <lyxia> Consider using http://lpaste.net, joco42 
12:47:26 <fizruk> platz: well, what you want is a foldr combined with sequence
12:47:28 <joco42> lyxia:  yeah... its not so easy... for ´
12:47:32 <joco42> me
12:47:44 <joco42> tmux inside remote terminal...
12:47:46 <fizruk> platz: that's why my first attempt was fmap (foldr f z) . sequence
12:47:49 <joco42> emacs....
12:47:55 <stephenmac7> Okay, so I'm back with a more specific question. As mentioned earlier, I'm trying to read the format found at https://github.com/Doublevil/JmdictFurigana into something nicer.
12:48:00 <joco42> not so easy to copy from there...
12:48:27 <stephenmac7> I currently have this code: http://lpaste.net/145199 but can't figure out how to approach the toFurigana function
12:48:42 <lyxia> joco42: I'd rather use a case here, since you're giving two names to the same thing here (printSvg = psvg)
12:48:50 <fizruk> joco42: no, like https://hackage.haskell.org/package/hastache
12:49:19 <stephenmac7> The issue is that not all pieces parts of the kanji string have a corresponding reading
12:49:29 <fizruk> joco42: that or some XML library
12:50:06 <fizruk> joco42: unless this is the only place in your code where you write XML with simple strings
12:50:12 <joco42> fizruk:  yeah... stg to think about.....
12:50:32 <platz> yeah basically
12:50:41 <platz> :t \cata -> fmap cata . sequence
12:50:43 <lambdabot> (Monad f, Traversable t) => (t a -> b) -> t (f a) -> f b
12:50:51 <lyxia> stephenmac7: I'd write a recursive function matching on the list of patterns.
12:50:55 <joco42> maybe i refactor if it starts to get unwildly....
12:51:22 <helpmeobi1> yeah
12:51:23 <helpmeobi1> yeahhhhhh
12:51:25 <helpmeobi1> yeahhh
12:51:31 <helpmeobi1> recfactor it baby
12:51:34 <helpmeobi1> yeaeaheahh
12:54:23 <stephenmac7> lyxia: How would you go about collecting the result?
12:55:29 <stephenmac7> The thing is that there might be stuff in the middle of the string that has no corresponding ranged reading
13:12:05 <lpaste_> lyxia revised “No title”: “to stephenmac7” at http://lpaste.net/145199
13:15:58 <koshmar> hey, I've encountered the clean lang which is very similar to haskell.... but some claim that it is faster.... is there any link which clarify the matter, because I've encoubtered some different answers .... maybe you have some thoughts?
13:16:40 <bitemyapp> koshmar: well, faster would be a bit hard to prove these days.
13:16:55 <koshmar> yes....
13:17:02 <bitemyapp> koshmar: given vector and a bunch of other stuff, but Clean has some nifty stuff around memory management I think due to the uniqueness typing.
13:18:40 <stephenmac7> lyxia: Thank you! I ended up trying something similar, but it's not as pretty
13:35:05 <ReinH> It would be difficult for a language that is similar to Haskell to be faster than the executables produced by GHC.
13:35:26 <ReinH> A significantly different language could be faster in a variety of ways.
13:37:37 <Cale> There were points in time when Clean's implementation was better than GHC.
13:37:44 <Cale> But I highly doubt that now
13:38:07 <bitemyapp> Clean had an advantage in that you could get an implicit ST of sorts for "free"
13:38:14 <bitemyapp> through the uniqueness typing
13:38:15 <koshmar> ReinH I have never tested it or i've never encountered any good comparison, but still... clean is different from haskell in a way of doing IO which may effect performence I assume
13:38:32 <Cale> The last release of the Clean compiler was in 2011
13:40:02 <Cale> (but apparently there has been recent development)
13:44:27 <ski> bitemyapp : hm, i think `ST' gives you something else
13:44:43 <ski> (or perhaps i don't understand what you mean by "implicit ST" ..)
13:44:53 <forker> Hello boys&girls! Being a newb I'm trying to wrap my head around how to implement parsing of partial JSON representations of data types. Would that force me into creating a companion type where all fields are wrapped into a Maybe?
13:45:06 <bitemyapp> ski: Clean can do in-place updates without any change in types AFAIK
13:45:15 <bitemyapp> forker: partial?
13:45:33 <lambdafan> that's my question too
13:45:34 <ski> an `ST' in Clean would allow you to stuff a unique value into a reference cell, getting back a reference to it, that you can copy as much as you like
13:46:13 <ski> (Mercury has both uniqueness, and something `ST'-like (though what corresponds to `runST' doesn't require rank-2))
13:46:44 <ski> bitemyapp : the in-place update is "only" an optimization
13:46:45 <forker> bitemyapp: by partial json doc I mean document that has only a subset of fields that are required to build a value of data type.
13:47:45 <bitemyapp> ski: fair point. Still seems nice.
13:47:46 <forker> bitemyapp: to give context: I'm trying to implement a not-so-restful update call, where I would post those fields that I'd like to update implying that the rest of the fields remain untouched.
13:52:19 <ski> bitemyapp : yes :)
13:54:11 <skyflash> Anyone here able to answer a Cloud Haskell question?  I'm wondering how to implement the equivalent of a distributed transaction - so effects are committed on hosts A, B and C iff all three can process and fully commit their results.  If any failures occur in the chain, nothing happens.  
13:57:48 <bitemyapp> skyflash: consensus is hard. You'll want to layer Raft on it something.
13:58:04 <bitemyapp> skyflash: you don't want to be reinventing distributed transactions yourself.
13:58:45 <bitemyapp> skyflash: http://thesecretlivesofdata.com/raft/ http://bravenewgeek.com/tag/raft/
13:59:34 <cite-reader> Paxos made Live will likely have useful information as well, despite being a different algorithm. http://research.google.com/archive/paxos_made_live.html
14:01:01 <bitemyapp> skyflash: paxos is another option, though Raft is usually easier to implement.
14:01:13 <skyflash> @bitemyapp Thanks.  So, nothing available 'off the shelf' in Haskell as far as you know?  
14:01:13 <lambdabot> Unknown command, try @list
14:02:48 <skyflash> I see a DSTM package, but would like the rest of the distributed semantics of Cloud Haskell too.
14:03:09 <tommd> edwardk: glguy: other committee members: So how much work is involved in the core libraries committee? Could I get an order-of-magnitude or personal experiences?
14:03:19 <bitemyapp> skyflash: there is a Raft implementing in Haskell, but I don't think it uses Cloud Haskell as a transport.
14:03:36 <bitemyapp> skyflash: Cloud Haskell is fine, but it conflates transports in a way that is a bit discomfiting.
14:05:16 <skyflash> @bytemyapp Thanks.
14:05:16 <lambdabot> Unknown command, try @list
14:08:13 <ReinH> bitemyapp: to which are you referring?
14:08:26 <ReinH> Kontiki?
14:08:47 <suppi> is there a command similar to `cabal run` in stack?
14:09:00 <ReinH> stack exec, but you must stack build first
14:09:34 <suppi> ReinH, works. thanks :)
14:09:50 <lispy> Cale: Is Clean able to avoid garbage collection at times? From what I've seen, the times people have beaten GHC it's because they didn't have GC
14:10:02 <ReinH> Kontiki is, at best, a framework for writing your own raft impl. For instance, it does not supply a WAL implementation, which basically means that in order to use Kontiki for a Raft implementation, you must know enough about Raft to write your own implementation.
14:10:15 <Cale> lispy: Yeah, uniqueness types make that somewhat possible.
14:10:22 <ReinH> Writing a correct WAL is not at all easy or obvious.
14:10:22 <Cale> lispy: You can reuse the same memory
14:10:31 <Cale> in some cases
14:10:52 <lispy> Also, is clean strict or lazy?
14:10:58 <Cale> lazy
14:11:32 <lispy> People should resurrect it. It always sounded interesting
14:12:29 <bitemyapp> lispy: I've wanted the GC avoidance in Haskell for awhile.
14:13:46 <ReinH> Last I checked, carter was working on porting a verified raft impl. Not sure where that ended up. There's also some work on a generic WAL / secondary storage management implementation that may be released... soon? eventually?
14:16:31 <ReinH> Cloud Haskell only offers transport and reification of static closures and the beginnings of an OTP-like "standard library", but doesn't offer replicaetd state machines or gossip protocols or any other distsys primitives.
14:17:09 <ReinH> I personally don't see much value in Cloud Haskell for the type of distsys work that I do.
14:18:40 <bitemyapp> ReinH: I've seen it mostly help scientific types that want a quick-n-dirty homogenous cluster but don't want to think about serialization much.
14:18:53 <ReinH> Right.
14:18:56 <bitemyapp> ReinH: doesn't do a lot if you have specific constraints/guarantees and care a great deal about the details.
14:19:38 <ReinH> The idea of a user-space Erlang VM implementation in Haskell with OTP is exciting per se, but what we currently have doesn't excite me.
14:20:12 <bitemyapp> ReinH: to be fair, it's not that much different in Erlang.
14:20:39 <bitemyapp> ReinH: it's not like OTP-in-Erlang has much in the way of recently-popular dist-sys primitives. Supervisor trees are nice but don't suddenly lend you consensus.
14:20:52 <ReinH> Of course not, but what Erlang does have is much more mature.
14:20:55 <bitemyapp> maybe it's nicer with a somewhat universal ecosystem for coordination?
14:21:06 <bitemyapp> then any given dist-sys primitive has a "known good" way to talk?
14:21:17 <bitemyapp> Dunno. I've never minded opening a socket.
14:21:33 <bitemyapp> ReinH: what do you use for binary serialization? binary, cereal, or something else?
14:22:01 <Welkin> an open-minded socket?
14:22:12 <Welkin> it accepts any connection!
14:22:22 <ski> lispy : "Is Clean able to avoid garbage collection at times?" yes. also Mercury
14:22:35 <ReinH> I use bytes. Serial instances are nice.
14:23:07 <ReinH> bitemyapp: I think at this point there aren't a lot of reasons to choose cereal over binary, but I'm used to bytes from back when there was a good reason to have an abstraction over both.
14:23:09 <dredozubov> Has anyone seen a typelevel decimals?
14:23:41 <ReinH> bitemyapp: although in practice I've found that JSON is often nearly as efficient and much easier to debug.
14:24:02 <bitemyapp> ReinH: binary seems to be picking up lately.
14:24:15 <bitemyapp> ReinH: well, Aeson is pretty damn zippy.
14:24:24 <ReinH> bitemyapp: At one point cereal offered some features that binary lacked, but that has since been rectified.
14:24:46 <bitemyapp> this reminds me I still need to fix blacktip's arrow-of-time issue.
14:24:46 <dredozubov> i believe binary performance was also improved this year
14:24:58 <bitemyapp> dredozubov: I think something in the last year happened yes.
14:24:59 <ski> lispy : both reusing the allocation storage of dead values that would otherwise have been picked up by GC later, and by statically inserting a freeing call to immediately mark as unused dead storage
14:25:00 <ReinH> Oh that pesky arrow-of-time...
14:25:21 <lispy> ski: I should take some time to learn mercury. It's been on my radar for a while as well.
14:26:21 <ski> lispy : there is a channel, #mercury. and mailing lists on <https://www.mercurylang.org>
14:26:41 <lispy> thanks
14:26:59 <bitemyapp> ReinH: nix hydra somehow walked its own clock backwards. *shrug* :)
14:27:03 <ReinH> bitemyapp: I'm also referring to space efficiency.
14:27:16 <ski> the paper list <https://www.mercurylang.org/documentation/papers.html> is interesting. reference manual <https://www.mercurylang.org/information/doc-latest/mercury_ref/index.html>
14:27:21 <bitemyapp> what, gzipping JSON vs. a binary format?
14:27:43 <ReinH> Yeah, and ungzipped too. Especially compared to the generic binary instances you get.
14:27:48 <ski> lispy : knowing some Prolog beforehand helps, also
14:27:51 <ReinH> JSON is just a pretty low-noise format.
14:28:41 <ReinH> bitemyapp: We spent some time trying to switch to and tune binary serialization and it didn't really pay off compared to JSON, especially gzipped.
14:29:01 <lispy> ski: definitely :) I recently translated the miniprolog at the PLzoo website to Rust and got a prolog refresher as a side-effect.
14:29:05 <ReinH> as in, it was better, but not as much as we had hoped.
14:29:06 <bitemyapp> ReinH: perhaps part of the problem is that Binary's format has to encompass Haskell datatypes in their full generality?
14:29:15 <ReinH> Yeah, definitely.
14:29:16 <bitemyapp> ReinH: perhaps something custom, more restricted, could be more compact.
14:29:22 <ReinH> Also yes. :)
14:29:42 <ReinH> The takeaway for me is that JSON is surprisingly efficient.
14:29:51 <ski> lispy : see e.g. "Re: [mercury-users] Mercury in academic teaching?" by Richard A. O'Keefe, in 2006-10-09 at <http://www.mercurylang.org/list-archives/users/2006-October/004000.html> and in 2006-10-10 at <http://www.mercurylang.org/list-archives/users/2006-October/004011.html> for some possibly interesting info
14:29:51 <lispy> ski: "Rust is a nice alternative to C" was another favorable outcome
14:30:01 <bitemyapp> ReinH: the unreasonable effectiveness of popular formats.
14:30:05 <ReinH> bitemyapp: :)
14:30:22 <ReinH> Plus you can do some neat things like structural semi-indexing, but we haven't needed to yet
14:30:48 <ReinH> I should say *succinct* structural semi-indexing.
14:30:50 <ReinH> http://www.di.unipi.it/%7Eottavian/files/semi_index_cikm.pdf
14:30:54 <ReinH> Which is really neat.
14:33:34 <helpmeobi1> is haskell 10x better than java?
14:33:35 <ReinH> (This is one of the applications of edwardk's recent infatuation with succinct structures)
14:34:19 <lispy> helpmeobi1: Questions like that are hard to phrase well
14:34:37 <ReinH> FSVO "better", yes. For others, no.
14:34:54 <ReinH> It isn't an interesting question.
14:34:59 <lispy> helpmeobi1: Haskell (the language) certains has some nice features. GHC (the Haskell implementations) can be compared to Oracle's JVM if you construct some specific tests.
14:37:04 <lispy> helpmeobi1: You migth like this site which tries very hard to answer questions related just to performance: http://benchmarksgame.alioth.debian.org/
14:38:16 <ski> lispy : outcome of what ?
14:38:36 <ReinH> bitemyapp: pm
14:39:43 <lispy> ski: I phrased that poorly. I was just trying to say that after playing with rust I'm now of the opinion that it's a nice language for systems-y stuff
14:39:55 <lispy> ski: outcome of me playing with rust
14:40:07 <lispy> ski: but rust was good or not good for systems stuff independent of my tinkering :)
14:41:14 <ski> ok :)
14:41:19 <helpmeobi1> i couldnt seem to pick ada v haskell
14:41:21 <helpmeobi1> on that sire
14:41:23 <helpmeobi1> site
14:41:27 <helpmeobi1> it was all java vs stuff
14:41:29 <helpmeobi1> weird
14:41:54 <niteria> is there a fundamental reason why f1 and f2 here optimize to different things: http://lpaste.net/145206 ?
14:42:08 <niteria> f1 has extra allocations
14:42:25 <rpfun> if i have a class A with two methods f and g to be implemented, but for a particular implementation the functions f and g share lots of information, is there a way to make ghc share it between these functions?
14:44:09 <niteria> :qa
14:44:23 <lispy> niteria: Thanks for flying with Vim!
14:44:46 <niteria> sorry :p
14:44:46 <Sonolin> I prefer :qa! myself
14:44:52 <Sonolin> :P
14:47:42 <stevejb> Hello, I have a value x :: Maybe Text, and a function fn :: Text -> IO (Maybe Q). What is the right way to apply fn to x (say, in ghci)?
14:48:19 <lispy> let Just y = x; fn y
14:48:27 <arkeet> no
14:48:43 <arkeet> unless you want it to explode in case x = Nothing
14:48:51 <ski> stevejb : you have to decide what to do in case there is no `Text' inside `x'
14:48:55 <lispy> For GHCi that should be fine
14:49:06 <stevejb> I would like fn x to be Nothing if x is Nothin
14:49:08 <stevejb> g
14:49:18 <lispy> in that case, fmap is a better choice
14:49:44 <ski> stevejb : `Nothing' is of the wrong type. possibly you meant `return Nothing' (of type `IO (Maybe Q)')
14:50:18 <stevejb> let z  = fmap (x) fn -- z has type Maybe (IO (Maybe Q))
14:50:34 <stevejb> oops, sorry
14:50:41 <stevejb> let z  = fmap fn x
14:51:23 <niteria> maybe (return Nothing) fn $ x
14:51:30 <niteria> $ unnecessary
14:51:30 <stevejb> if I do that, the type is z :: Maybe (IO (Maybe Q))
14:51:46 * ski idly wonders whether stevejb wants `MaybeT' here
14:52:03 <stevejb> ski: possibly
14:52:34 <ski> stevejb : if you'd only want it for this, and not for fitting also into other things, it might be too much of a bother
14:52:45 <ski> but it would capture what you're trying to do here, iiuc
14:52:59 <stevejb> I was hoping that I was just misunderstanding fmap 
14:53:09 <ski> you could use `mapM'/`forM' alternatively, but it'd require some extra massaging
14:53:29 <ski> or you could just use an ordinary `case', or `maybe', to handle the different cases explicitly
14:53:39 <stevejb> yeah I think I will just do that
14:53:43 <stevejb> if isJust .... 
14:54:07 <ski> stevejb : if you had had `fn :: Text -> IO Q', then `mapM'/`forM' would have been a perfect fit
14:54:10 <ski> no !
14:54:14 <ski> don't use `isJust'
14:54:44 <bitemyapp> stevejb: avoid unnecessary boolean expressions. fmap or case expression is better here.
14:54:45 <arkeet> use case
14:54:48 <arkeet> or maybe
14:54:54 <niteria> maybe (return Nothing) fn x should work
14:55:14 <arkeet> case x of { Nothing -> return Nothing; Just x' -> fn x' } 
14:55:14 <arkeet> same thing
14:55:58 <arkeet> @src maybe
14:55:59 <lambdabot> maybe n _ Nothing  = n
14:55:59 <lambdabot> maybe _ f (Just x) = f x
14:55:59 <ski> stevejb : it's seldom a good idea to use `isJust',`fromJust', and `null',`head',`tail', and similar functions
14:56:27 <stevejb> ski: yeah it always feels wrong. I don't want to be manually checking.
14:57:10 <suppi> join <$> sequence (fmap fn x) ?
14:57:13 <xpilot> is there any way to pass around type-level functions as first-class values?
14:58:25 <ski> @src mapM
14:58:25 <lambdabot> mapM f as = sequence (map f as)
14:58:47 <suppi> so, join <$> mapM fn x ? :)
14:59:02 <ski> yes, that's the "some extra massaging" :)
14:59:27 <suppi> I was just thinking about it step by step
14:59:44 <suppi> commute the monads and join the inner one
14:59:48 <stevejb> thanks!
15:00:03 <stevejb> that is exactly what I was looking for
15:00:22 <suppi> oh, first, apply fn :)
15:00:26 <suppi> you welcome
15:00:48 <stevejb> ski and bitemyapp than you too
15:01:28 <ski> np
15:01:52 <bitemyapp> ski: :)
15:02:00 <ski> stevejb : i would still consider/contemplate the `MaybeT' as well
15:03:06 <stevejb> I was thinking that I should write a script that scans my code for any isJust, fromMaybe, etc. and warns me, so I am forced to do things the right way
15:03:19 <stevejb> and any array indexing as well
15:03:31 <bitemyapp> stevejb: possibly. hlint might catch some stuff.
15:03:35 <suppi> use grep :)
15:03:48 <stevejb> bitemyapp: I'll give that a try
15:03:54 <ski> stevejb : array indexing is fine. it's list indexing which is usually a bad idea :)
15:10:37 <Welkin> stevejb: STEVEN JOBS
15:14:56 <xpilot> has anyone ever run into the error: Family instance purports to bind type variables
15:15:06 <xpilot> google turns up zero results
15:16:34 <pikajude> i've never even heard of that
15:18:38 * hackagebot brick 0.2.3 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.2.3 (JonathanDaugherty)
15:34:17 <forker> Is there anything like this available in aeson satellite packages: http://lpaste.net/145207 ? I want to make a parser that would merge partial json representation of data value into a complete value of the same data type.
15:35:04 <forker> (hoogled by signature and haven't found anything)
15:43:48 <pikajude> forker: generally better to hayoo by signature
15:43:53 <pikajude> i think
15:43:57 <pikajude> hayoo can do that right
15:45:24 <MarcelineVQ> yep http://hayoo.fh-wedel.de/?query=a+-%3E+Value+-%3E+Parser+a
15:46:05 <forker> pikajude: thanks! found parseWith :: UpdateFromJSON a => a -> Value -> Parser a . But it's hackage page seems to be dead..
15:46:20 <forker> or maybe it was scanned from a different resource...
15:47:02 <forker> found on github, thank you guys!
15:57:01 <forker> So I'm looking at things like https://github.com/GallagherCommaJack/Haskell-JSON-Patch having almost no forks and stars (which indicative to me of solved problem's prevalence) and wonder what are people using to implement partial updates in their RESTful web services?.. or do even people implement partial updates?
15:59:19 <forker> (really, really need input from people doing restful apis in haskell)
16:10:11 <SrPx> In essence, is the reason type systems on the lambda cube make a system strongly normalizing that they limit the amount of times a function can be called to a constant?
16:19:39 <Cale> SrPx: Well, it may depend on the input, so I don't think that's true.
16:20:38 <Cale> SrPx: You can simulate a Turing machine, where one of the inputs to your simulator is a natural number which is used as "fuel"
16:20:53 <SrPx> But it will still halt when your natural number runs out
16:20:56 <Cale> right
16:21:20 <SrPx> what I mean is, suppose that "foo :: t → t → t". Foo can only be called 2 times before becoming a base type and not being able to be called anymore.
16:21:34 <SrPx> All functions can be called only a specific number of times before becoming a base type, no?
16:21:42 <Cale> no
16:22:03 <SrPx> hmm for example?
16:22:12 <Cale> foo (foo (foo 1 2) (foo 3 4)) (foo (foo 5 6) (foo 7 8))
16:22:29 <SrPx> what about that?
16:22:49 <Cale> foo is used many times in that expression
16:22:54 <SrPx> no, I mean
16:22:56 <tzh> SrPx: do you mean "all functions take a finite number of arguments"? because you can chain `id` calls forever if you really want
16:22:58 <SrPx> each particular foo can only be called 2 times
16:23:14 <Cale> huh?
16:23:24 <SrPx> hm... "foo 1 2 3" is a type error, that is what I mean
16:23:30 <Cale> foldNat z s Zero = z
16:23:44 <Cale> foldNat z s (Succ n) = s (foldNat z s n)
16:24:38 <SrPx> foldNat : t -> (Nat -> t) -> Nat -> t
16:24:46 <Cale> Now consider something like z :: A, and s :: A -> A, then foldNat z s will result in s being applied arbitrarily many times for various naturals
16:24:56 <Cale> No, wrong
16:25:03 <Cale> foldNat :: t -> (t -> t) -> Nat -> t
16:25:10 <SrPx> woops, correct
16:25:44 <SrPx> My bad - so, "z" can't be called in an argument, and each copy of "s" can only be called once.
16:25:46 <ski> SrPx : do you mean "in the reduction sequence of a (well-typed) finite expression, there can only be finitely many beta-reductions corresponding to `foo'" ?
16:25:56 <Cale> "copy of s"?
16:26:14 <SrPx> I see I'm really bad at expressing myself, hold on
16:27:54 <SrPx> s = (+ 1); z = 0; foldNat s z (Succ (Succ (Succ Zero))) => (s (s (s z))) -> (s (s 1)) # --- here, the last "s" was called on "z" ---- => (s 2) ----- here, the second "s" was called on 1 ------ => 3 ------ here, the last "s" was called on "2"
16:28:20 <SrPx> but each individual "s" can only be called a limited amount of times
16:29:24 <Cale> I mean, if you're willing to unfold the expression arbitrarily far, you can get it so that each occurrence of s eventually gets applied exactly once?
16:30:13 <Cale> Keep going and there won't even be any occurrences of s, and your statement will be vacuously true, supposing that I understand what you mean at all
16:30:46 <Cale> But that's a consequence of termination
16:31:31 <SrPx> I feel like I'm really bad at expressing myself, never mind
16:31:42 <fresheyeball> Quick question
16:31:52 <fresheyeball> lets say
16:31:56 <fresheyeball> x : IO Int
16:32:02 <fresheyeball> y : IO Int
16:32:22 <fresheyeball> z = (+) <$> x <*> y 
16:32:36 <fresheyeball> when it comes time to evaluate z
16:32:44 <fresheyeball> will x and y eval in parallel threads 
16:32:46 <fresheyeball> ??
16:33:07 <fresheyeball> in other words
16:33:15 <ski> no
16:33:22 <SrPx> No, Haskell doesn't do any kind of parallelism without annotations 
16:33:35 <ski> if `x' and `y' so specify, they may execute in part in separate threads, though
16:33:43 <SrPx> I always wondered why, though
16:33:50 <fresheyeball> how would I get x and y to evaluate in paralell? 
16:33:51 <ski> (note that execution is distinct from evaluation)
16:33:59 <fresheyeball> what annotation?
16:34:06 <fresheyeball> fair enough
16:34:10 <fresheyeball> I meant execution not evaulation
16:34:11 <glguy> If x was going to throw an exception y shouldn't start executing
16:34:35 <ski> @type Control.Parallel.par
16:34:37 <lambdabot> a -> b -> b
16:34:54 <ski> can be used to hint that you'd like some parallel evaluation (not execution)
16:34:59 <fresheyeball> sorry, I'm new to Parallelism in Haskell
16:35:07 <glguy> There's a library for doing asynchronous evaluation like that though http://hackage.haskell.org/package/async
16:35:12 <glguy> wrapper around the IO type
16:36:28 <ski> fresheyeball : "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://chimera.labs.oreilly.com/books/1230000000929> might be interesting
16:36:37 <ReinH> Definitely interesting, and free.
16:36:41 <fresheyeball> I was just reading that haha
16:37:09 <ReinH> ski: but par is for data parallelism, which this is not? I think async is more appropriate?
16:37:17 <fresheyeball> I just don't understand why applicative IO being parallel would not be easier than this
16:37:31 <fresheyeball> I expected something like
16:37:40 <fresheyeball> {-# PAR -#}
16:37:45 <fresheyeball> for under the function or something
16:37:53 <barrucadu> fresheyeball: Doing IO in parallel does not in general have the same semantics as doing it sequentially
16:38:10 <fresheyeball> right
16:38:14 <joehillen> ski && fresheyeball: ++ that's required reading if you want to write production haskell.
16:38:27 <barrucadu> For example, shared state
16:38:44 <fresheyeball> but in the Applicative case, order of execution does not matter
16:38:51 <ReinH> it isn't that hard: runConcurrently $ (+) <$> Concurrently x <*> Concurrently y
16:38:51 <ski> ReinH : they started talking about parallelism. then indicated they rather wanted concurrent execution
16:38:52 <glguy> fresheyeball: it does matter
16:38:58 <ReinH> ski: Ok :)
16:38:59 <fresheyeball> or it should be possible to annotate that it doesn't matter with a pragma or something
16:39:27 <glguy> (+) <$> initializeResource <*> useResource
16:39:41 <ReinH> fresheyeball: Sure it does. All sorts of IO effects may be order-dependent.
16:39:48 <fresheyeball> right
16:39:54 <ski> fresheyeball : generally, for `Applicative', order of execution does matter
16:39:57 <ReinH> For example, if execution of x deletes a file that execution of y reads.
16:40:06 <fresheyeball> right, I get it
16:40:16 <fresheyeball> I just think I should be able to tell the compiler
16:40:24 <fresheyeball> hey, it doesn't matter the order here
16:40:30 <fresheyeball> or
16:40:34 <glguy> You tell it with types rather than having some one-off special cased way to tell it
16:40:48 <fresheyeball> using order dependent IO in Applicative could just be considered a programmer error
16:40:51 <ReinH> fresheyeball: If you can do it in the language, there's no need to do it outside the language.
16:41:07 <glguy> then you can pass actions around as values knowing which ones use async and which use sync execution
16:41:24 <fresheyeball> thats true
16:41:38 <ReinH> You need an inline pragma because there's no way to write an Inline newtype. You don't need a concurrently pragma because you can write Concurrently.
16:42:09 <fresheyeball> this just seems heavy to me: runConcurrently $ (+) <$> Concurrently x <*> Concurrently y
16:42:28 <ski> fresheyeball : ".. could just be considered a programmer error" -- no, it couldn't. `(<*>)' is an ordinary function, defined in a specific way for `IO'. they only way out would be to not have `Applicative IO'. now that `Monad' requires `Applicative', we'd have to skip `Monad IO' as well, then
16:43:17 <fresheyeball> right, but there is nothing in Haskell to stop programmers from excuting IO out of order by mistake
16:43:45 <glguy> You should expect the Applicative instance to work just like the Monad instance (when there's a Monad instance)
16:43:50 <fresheyeball> is there something like lift2Concurrently ?
16:44:02 <glguy> did you look in the haddocs?
16:44:28 <fresheyeball> I must not have, or am misunderstanding what haddocs is
16:44:38 <glguy> http://hackage.haskell.org/package/async-2.0.2/docs/Control-Concurrent-Async.html
16:45:46 <fresheyeball> cool, I will use that
16:46:53 <fresheyeball> I feel like with that lib I could pretty easily write a concurrent lift
16:47:41 <stephenmac7> Is there a batter way to write (\(x, y) -> x == y) ?
16:48:48 <barrucadu> :t uncurry (==)
16:48:49 <lambdabot> Eq a => (a, a) -> Bool
16:49:10 <stephenmac7> Thanks
16:52:43 <mniip> :t join$(.snd).(==).fst
16:52:44 <lambdabot> Eq b => (b, b) -> Bool
16:58:49 * hackagebot dynobud 1.9.0.0 - your dynamic optimization buddy  https://hackage.haskell.org/package/dynobud-1.9.0.0 (GregHorn)
16:59:48 <MarcelineVQ> That tasty moment you realise stephenmac7 asked for a batter way
17:14:13 <athan> Anyone here know how percent-encoding works for utf-8? I've found some SO links, but nothing on the standard for where the digits come from
17:14:20 <athan> ref: http://stackoverflow.com/questions/912811/what-is-the-proper-way-to-url-encode-unicode-characters
17:14:51 <scshunt> athan: URL-encoding encodes an 8-bit character as %XX, where XX is the 2-digit hex representation
17:15:04 <scshunt> UTF-8 is just encoded directly using URL-encoding
17:15:30 <athan> scshunt: Thank you :) Do you know of any encoders or decoders existing currently?
17:15:49 <athan> I'm guessing it would be pretty trivial to implement
17:16:05 <scshunt> no and yes, respectively
17:16:53 <athan> scshunt: I'm trying to implement a decoder in Attoparsec right now, could you link me the encoder?
17:17:10 <scshunt> yes was your "pretty trivial" statement
17:17:46 <athan> ah :)
17:20:34 <athan> scshunt: What of characters like ȥ? It would have a four-digit hex representation - c8a5
17:21:02 <scshunt> athan: it's encoded as a sequence of octets
17:21:06 <scshunt> %C8%A5
17:21:06 <pixiebot> Unknown Command: C8%A5
17:22:20 <athan> scshunt: But how would you distinguish `8`, then `%A5` as separate characters, from the combination of the two?
17:22:32 <athan> oh jeez, did my text just bork?
17:24:55 <athan> It's suprising an octet encoder / decoder for utf-8 doesn't exist already
17:25:09 <athan> Data.Text.encodeUtf8 might bring hope
17:26:14 <scshunt> athan: %A5 can only occur in UTF-8 as part of another character
17:26:26 <scshunt> but in any case, URL-encoding doesn't care about that
17:26:53 <scshunt> it just turns an octet stream into one that can be safely put in a URL
17:27:10 <scshunt> you could put Shift-JIS into it, and that's not a synchronizing encoding 
17:27:32 <athan> hm, okay.
17:27:57 <athan> I'm not sure an efficient octet lookup system would be possible in pure haskell either
17:28:28 <scshunt> I probably wouldn't bother with attoparsec
17:28:46 <athan> scshunt: Yeah, I'm just trying to figure out a simple character lookup
17:28:57 <athan> which seems to be just a massive pattern match
17:29:00 <scshunt> why?
17:29:03 <athan> on every possible character
17:29:13 <athan> scshunt: To implement percent encoding :P
17:30:57 <aa2> Hello there
17:30:59 <scshunt> decode ('%':'%':cs) = '%' : cs
17:31:16 <aa2> I'm trying understand pattern matching in Haskell
17:31:22 <scshunt> decode ('%':a:b:cs) = ... etc.
17:31:44 <chreekat> aa2: hiya
17:31:57 <aa2> Hello chreekat
17:32:00 <aa2> I'm trying to create a function that adds two tuples
17:32:01 <athan> scshunt: But how would I turn `(a,b)` into it's corrosponding utf-8 character, without any lookup table?
17:32:30 <aa2> addTwoTuples :: (Int, Int) -> (Int, Int) -> (Int, Int)
17:32:34 <athan> aa2: Pattern matching is almost exactly the same as building structure, syntactically
17:32:42 <scshunt> athan: Numeric.readHex?
17:32:55 <athan> scshunt: !!! Okay, thank you!
17:33:08 <aa2> athan: Not quite reached thee yet, I'm learning through "Learn you a Haskell for Great Good!"
17:33:42 <athan> aa2: You'll get there, it's very intuitive
17:33:51 <aa2> So  create a pattern (for fun)  addTwoTuples (0, 0) (0, 0) = (100, 100)
17:33:57 <aa2> This works
17:34:25 <athan> aa2: You could set each `0` to a different variable
17:34:30 <aa2> and then, addTwoTuples (a,b) (x, y) = (a+x, b+y)
17:34:37 <athan> yep :)
17:34:40 <chreekat> seems right
17:34:51 <aa2> However, I want to create a pattern as this
17:35:17 <aa2> addTwoTuples (x,y) (x,y) = (400, 400)
17:35:29 <aa2> Ignoring the absurd logic of this pattern
17:35:43 <aa2> I want to create a pattern that matches two tuples that are the same
17:35:56 <aa2> Am I making sense?
17:36:05 <aa2> This doesn't work for me
17:36:33 <chreekat> aa2: Ahh. Yes, that makes sense, but Haskell isn't quite that smart (at least vanilla Haskell). You need to use something like guards.
17:36:44 <athan> aa2: well, you're binding variables when you make names like that
17:37:09 <aa2> Guards...yeah I remember they cover that later in the book
17:37:30 <athan> aa2: basically if statements
17:38:10 <chreekat> Yeah, maybe it's not about 'smart' necessarily, just understanding what is expected when you use patterns. Haskell thinks you're creating two different things called 'x' when you have a pattern with two x's.
17:38:24 <chreekat> So it doesn't like that, obviously
17:38:43 <chreekat> sorry, obviously is never a good word to use. :) 
17:39:00 <aa2> chreekat: athan: Thanks
17:39:07 <aa2> Will continue my study
17:39:11 <athan> np :)
17:39:15 <aa2> Haskell is real fun!
17:44:39 <athan> scshunt: What would be a good way to create an octet? `Show`ing the number, then prepending "\" manually doesn't seem to work
17:44:49 <scshunt> why prepending a \?
17:45:20 <scshunt> also showHex should work, no?
17:45:30 <athan> scshunt: I'm not sure how to pack the octet :\
17:45:33 <athan> oh!
17:46:00 <scshunt> there's also http://hackage.haskell.org/package/hex-0.1.2/docs/src/Data-Hex.html#hex
17:47:38 <mniip> athan, you mean like
17:47:49 <mniip> Int -> Char or what
17:47:59 <athan> mniip: Yes!
17:48:01 <athan> exactly
17:48:11 <mniip> you know this isn't perl right
17:48:21 <athan> but not like Data.Char.ord, but for utf8
17:48:22 <mniip> :t toEnum
17:48:23 <lambdabot> Enum a => Int -> a
17:48:46 <athan> Really, it's like Word8 -> String, I think
17:48:48 <mniip> well 'chr' would work too
17:48:56 <noctis> Hello, this is my first time in this channel, I don't know much about haskell, but I do have a little C++ under my belt.
17:49:16 <mniip> athan, wait what?
17:49:38 <athan> mniip: Have you ever looked at the strings that Data.Text.encodeUtf8 spits out for unicode?
17:49:46 <athan> I want to recreate those octets from Integers
17:50:14 <athan> because Numeric.readHex gives you the Integer, but not the `\225...` _string_
17:50:31 <mniip> encodeUtf8 doesn't product strings
17:50:33 <athan> I'm just not sure how to turn the actual (225 :: Integer) -> ("\225" :: String)
17:50:42 <athan> ByteStrings I mean
17:50:56 <athan> er wait
17:51:00 <athan> crimeny
17:51:00 <mniip> it makes no sense to contain utf8 in a string
17:51:10 <mniip> because strings are already unicode
17:51:24 <athan> mniip: yeah I derped >.>
17:51:26 <athan> well, really
17:51:28 <noctis> What kinds of things are done with Haskell the most often? To the best of my knowledge it is a langauge for scientific and mathematic simulations. But what kinds of things are you guys doing with it?
17:51:33 <mniip> ByteString is /very/ different from String
17:51:44 <athan> how would I recreate that "\225" with the IsString instance for ByteString?
17:51:48 <mniip> haskell for mathematic simulations? ehhh
17:52:01 <mniip> athan, are you familiar with function composition
17:52:06 <ProofTechnique> Once cartazio's done with it
17:52:21 <athan> mniip: I know this, I'm just wondering how I could manually add a utf8 character into a string literal, which gets typed to ByteString's instance
17:52:32 <noctis> That's just what I have heard, I was thinking about checking out "Learn you a better Haskell".
17:52:47 <athan> noctis: I build web servers with it :)
17:53:08 <athan> Learn-ski a Haskell, breh
17:53:44 <mniip> athan, no
17:53:51 <athan> :(
17:54:32 <mniip> you have to use Data.ByteString.UTF8.fromString
17:54:35 <noctis> Are most of you using Haskell professionally or are you hacking for fun?
17:54:43 <athan> thanks mniip
17:54:54 <athan> mniip: ahhhh that's right, from utf8-string
17:55:08 <mniip> noctis, some are hacking for scientific research
17:55:33 <athan> noctis: It's hard to convice people to buy it from my experience, because it's an alien language and most people in my area are xenophobes >.>
17:56:34 <mniip> athan, I hate the people who put "what's the use of it" before everything else
17:57:31 <athan> That's a good observation
17:57:52 <athan> but, programming languages are use-oriented :P
17:57:57 <mniip> except haskell
17:57:59 <athan> er really tools in general
17:58:02 <athan> :P
17:58:09 <mniip> I mean
17:58:25 <mniip> have you ever looked at someone's code and said "wow" and then proceeded to think about it for days
17:58:32 <noctis> Well yes, but they should be fun to learn and write too.
17:59:10 <athan> mniip: I agree, Haskell is much more valuable that simply a tool
17:59:11 <mniip> haskell is fun to write
17:59:17 <noctis> Coding should be pragmatic, theoretical and enjoyable. 
17:59:51 <noctis> ~ Bjrane STROUGHSFFAJSFGHGP 
18:00:17 * athan gets some halls fruit-breezers
18:00:22 <noctis> However the hell you pronouce that name.
18:00:23 <athan> ere ya go, chap
18:04:23 <chreekat> noctis: It is still used a lot as a test bed for trying out new ideas in language design, and that was its original purpose. For application programming it is used for a lot of things. Network services come to mind since there was recently a presentation on the subject making the rounds. It's also used to write DSLs to great practical effect. 
18:04:37 <mrmyers> I agree. A programming language should be a source of inspiration. It should be a moral guide in difficult times. It should be a reason to live, and perchance even to die for.
18:04:48 <chreekat> I've never used it academically; it started as a hobby but I'm employed with it now
18:06:32 <betaceti> :t bimap
18:06:33 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
18:06:38 <betaceti> :t join bimap
18:06:39 <lambdabot> Bifunctor p => (a -> b) -> p a a -> p b b
18:06:43 <betaceti> :t join
18:06:44 <lambdabot> Monad m => m (m a) -> m a
18:06:51 <betaceti> magic
18:07:03 <mniip> :t join `asAppliedTo` id
18:07:04 <lambdabot>     Occurs check: cannot construct the infinite type: a1 ~ a1 -> a
18:07:04 <lambdabot>     Expected type: a1 -> a1 -> a
18:07:04 <lambdabot>       Actual type: a1 -> a1
18:07:08 <mniip> :t join `asAppliedTo` const
18:07:09 <lambdabot> (a -> a -> a) -> a -> a
18:07:21 <betaceti> :o what does it do?
18:07:25 <mniip> hmm
18:07:29 * mniip fails to demonstrate
18:07:33 <betaceti> just applies a function?
18:07:40 <mniip> anyway, what join does to functions is
18:07:43 <mniip> join f x = f x x
18:11:01 <betaceti> :i asAppliedTo
18:11:25 <betaceti> i can't find that function
18:11:34 <mniip> it's a lambdabot thing iirc
18:11:41 <mniip> type-constrained const
18:11:58 <mniip> (a -> b) -> a -> a -> b
18:12:56 <ski> @type asTypeIn
18:12:57 <lambdabot> a -> (a -> b) -> a
18:12:59 <ski> @src asTypeIn
18:12:59 <lambdabot> a `asTypeIn` f = a where _ = f a
18:12:59 <lambdabot> infixl 0 `asTypeIn`
18:13:25 <mniip> why such a complex definition
18:13:25 <ski>   f `asAppliedTo` x = f `asTypeIn` \f -> f x
18:13:26 <noctis> Does anyone know if there are vim addons for Haskell such as ycm?
18:13:36 <mniip> I could write a simpler one
18:14:02 <mniip> @let aat :: (a -> b) -> a -> a -> b; aat f _ = f
18:14:04 <mniip> literally that
18:14:05 <lambdabot>  Defined.
18:15:15 <ski> i suppose for some reason it wanted to avoid relying on a type signature
18:16:25 <noctis> Do I need to install the Haskell Stack to get started?
18:16:34 <mniip> no
18:16:42 <noctis> Should I anyway?
18:16:46 <mniip> technically you only need GHC but i'm unsure what the procedure is nowadays
18:17:06 <mniip> noctis, windows/linux?
18:21:08 <mgsloan> There are a few different ways to install GHC and related tools (https://www.haskell.org/downloads)
18:21:20 <isomarcte> Most people install the Haskell platform. I prefer to just install stack. I removes some of the magic from the whole thing.
18:21:25 <isomarcte> It*
18:21:46 <mgsloan> Yeah, if you want something that just works without much fuss, use stack
18:22:13 <isomarcte> As far as vim goes, I have heard good things about ghcmod with vim.
18:22:18 <isomarcte> https://github.com/eagletmt/ghcmod-vim
18:22:28 <isomarcte> but I am an emacs user, so YMMV
18:23:04 <ReinH> noctis: you aren't the quake playing noctis, are you?
18:24:42 * mniip shameless advertising https://github.com/mniip/functional-kmp
18:30:16 <noctis> Haskell seems pretty cool https://www.youtube.com/watch?v=6g3QmtUN3dw
18:30:30 <isomarcte> Haskell is pretty cool
18:31:09 <noctis> Seems like more of a academic langauge though.
18:31:47 <isomarcte> noctis: What does that mean?
18:32:23 <isomarcte> noctis: Let me rephrase. How would you define an "academic" language compared to a "non-academic" language?
18:37:24 <mniip> [05:29:53] <noctis> Haskell seems pretty cool https://www.youtube.com/watch?v=6g3QmtUN3dw
18:37:26 <mniip> https://www.youtube.com/watch?v=RqvCNb7fKsg
18:39:25 <betaceti> haskell is used commercially, banks and financial institutions, facebook, (microsoft?), etc.
18:39:33 <no-n> mniip: > Cat Pictures 99
18:46:55 <ReinH> Start-ups. Pretty much anywhere.
18:57:22 <P4Titan> Hi all! I would like to ask if haskell.org is working for yall
18:57:36 <barrucadu> Works for me
18:57:47 <P4Titan> really
18:57:51 <ReinH> Same.
18:57:57 <P4Titan> hackage.haskell.org
18:58:14 <barrucadu> Also works
18:58:25 <barrucadu> http://downforeveryoneorjustme.com/hackage.haskell.org
18:58:43 <P4Titan> dang it
18:58:45 <P4Titan> it is just me
18:58:49 <P4Titan> why is that?
18:59:15 <P4Titan> IDK if you guys can answere, I'll try to figure it out
19:01:37 <P4Titan> I simply reconnected my VPN and it works now
19:07:53 <sanitypassing> is it possible to install the haskell platform under cygwin?
19:30:19 <synergistics> In typed lambda calculus, are term constants instances of a type?
19:31:12 <synergistics> "We also fix a set of term constants for the base types. For example, we might assume a base type nat, and the term constants could be the natural numbers." Asking because of this quote from the wikipedia page on simply typed lambda calculus.
19:34:12 <stephenmac7> Is there any way to check what unicode block a character is in?
19:45:33 <pavonia> stephenmac7: The charset package has information about blocks but apparently no convenient lookup function
19:55:04 <emmanuel_erc>  hello there
20:47:48 <ski> synergistics : basically yes
20:50:36 <ski> synergistics : though, we don't necessarily need to have a term constant for each value of the type in question
21:03:56 <natez> help
21:04:25 <natez> quit
21:41:42 <KaneTW> lol
21:43:37 <Welkin> KaneTW: ROSEBUD
22:23:57 <KaneTW> hm?
22:24:43 <bitemyapp> KaneTW: IRC weather
22:45:41 <noobhaskell> i am facing an issue with my server socket: need some help. I notice that receiveData is duplicating the message.
22:46:11 <noobhaskell> rather, the number of times i am processing an incoming message is equal to the number of connections. Seems like a bug..need some help
22:47:54 <noobhaskell> http://lpaste.net/145217
22:48:33 <noobhaskell> Any hints will help
22:52:27 <noobhaskell> any pointers? http://lpaste.net/145217 to fix this bug?
22:55:38 <Cale> noobhaskell: looking...
22:55:47 <noobhaskell> cale: thanks.
22:56:32 <noobhaskell> i can add more code or link to the github profile..when i have a single connection, things seem ok..as soon as i have multiple connections, it seems like a dup call somewhere. Thanks.
22:56:35 <Cale> So what does the output of this look like?
22:57:04 <noobhaskell> My site gets 2 entries in the drop down list: each corresponding to a valid request to insert a record.
22:57:09 <noobhaskell> let me paste a sample.
22:57:13 <Cale> It may also help to know how the writerThread is created
22:58:17 <noobhaskell> let me add that part..its part of the websockets connection inside a yesod monad. let me put that code there and the output.
22:59:55 <noobhaskell> cale: http://lpaste.net/145218
23:01:00 <noobhaskell> cale: here is the code that creates the thread: http://lpaste.net/145219..its a bit messy.
23:08:17 <noobhaskell> Cale: any pointers?
23:08:49 <Cale> oh, my messages probably didn't get through
23:08:55 <Cale> hang on, I'll paste them in PM
23:09:05 <noobhaskell> thank  you.
23:19:35 <isBEKaml> hi, does anyone know when we can see the next haskell platform release?
23:21:09 <M-Illandan> isBEKaml: work is on, but no definite dates; http://mail.haskell.org/pipermail/haskell-cafe/2015-November/122171.html
23:21:47 <zipper> Hey guys, hackage has this guideline where it expects your module to follow a certain naming scheme as shown here: https://wiki.haskell.org/Hierarchical_module_names
23:22:18 <zipper> However this leaves out a lot of applications and use cases. WHat is your approach to solving this?
23:22:24 <zipper> Do you just ignore it?
23:24:36 <noobhaskell> cale: i pasted some update on the pm. I dont see any exceptions.
23:27:47 <xpilot> question about fundeps: given class C x r | x -> r, should (C x r, X y r) imply x ~ y?
23:28:15 <xpilot> whoops meant (C x r, C y r)
23:28:45 <glguy_> No
23:28:58 <xpilot> oh whoops I have it backwards dont I
23:29:10 <noobhaskell> cale: I have updated the log output.
23:29:26 <glguy_> Yeah, other way around
23:30:39 <xpilot> hm
23:30:55 <xpilot> so I tried to write a function of type: (C x r, C x s) => proxy x -> r :~: s
23:31:12 <xpilot> and it did not type check
23:31:39 <xpilot> r :~: s is defined in Data.Type.Equality
23:31:51 <xpilot> :i (:~:)
23:32:03 <xpilot> oh :i doesn't work here does it
23:33:05 <xpilot> I guess FunDeps don't influence type checking outside of instance resolution?
23:34:07 <glguy_> There's an intensional bug in GHC not to get fun deps quite right. Hugs98 implemented it correctly
23:34:57 <xpilot> glguy_: interesting, do you have a reference?
23:36:05 <glguy_> Not on my phone
23:36:28 <xpilot> wow checking haskell irc on phone, that's dedication :)
23:37:46 <Xnuk> Is this correct?: a *> b = b, a <* b = a
23:57:56 <glguy_> a*>b discards the "result" from a, but it's not interchangeable with b
