00:04:13 <bernalex> is there some sort of established cute way of writing a function f¯¹? just the regular `f . f¯¹ = id` stuff.
00:04:26 * hackagebot megaparsec 4.2.0 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-4.2.0 (mrkkrp)
00:04:55 <quicksilver> inverse? right inverse?
00:05:05 <quicksilver> in general you can't calculate the inverse of a function
00:05:07 <bernalex> quicksilver: I mean for naming f¯¹
00:05:39 <quicksilver> un_f? :)
00:05:42 <bernalex> lol
00:05:53 <quicksilver> unF and runF are quite common
00:05:57 <quicksilver> for particular kinds of inverses
00:06:50 <bernalex> BTW here's a fun gotcha in haskell
00:07:05 <bernalex> > let f = (+1)
00:07:07 <lambdabot>  <no location info>: not an expression: ‘let f = (+1)’
00:07:09 <bernalex> ups
00:07:12 <bernalex> @let f = (+1)
00:07:14 <lambdabot>  Defined.
00:07:16 <bernalex> @let g = (-1)
00:07:17 <lambdabot>  Defined.
00:07:22 <bernalex> :t f . g 
00:07:24 <lambdabot>     Ambiguous occurrence ‘f’
00:07:24 <lambdabot>     It could refer to either ‘L.f’,
00:07:24 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:145:1
00:07:37 * hackagebot servant-swagger 0.0.0.1 - Swagger  https://hackage.haskell.org/package/servant-swagger-0.0.0.1 (DavidJohnson)
00:07:37 * hackagebot megaparsec 4.2.0 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-4.2.0 (mrkkrp)
00:07:58 <bernalex> :t L.f . g 
00:07:59 <lambdabot>     Ambiguous occurrence ‘g’
00:08:00 <lambdabot>     It could refer to either ‘L.g’,
00:08:00 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:146:1
00:08:03 <bernalex> :t L.f . L.g 
00:08:05 <lambdabot> (Num c, Num (a -> c)) => a -> c
00:08:06 <bernalex> geez. :)
00:08:19 <quicksilver> yes, (-1) isn't a section
00:08:26 <bernalex> yes. fun times.
00:08:30 <quicksilver> basically '-' is a terrible blight on the language
00:08:32 <bernalex> I don't very much like unary negation.
00:08:35 <bernalex> yes.
00:08:49 <quicksilver> as a result I have simply sworn off negative numbers and subtraction entirely
00:08:52 <quicksilver> a kind of protest.
00:09:06 <kadoban> Haha
00:09:37 <bernalex> subtraction is not the blight
00:09:40 <bernalex> unary negation is the blight
00:10:04 <quicksilver> subtraction colluded in the blight, it wasn't strong enough to fight its corner
00:10:06 <bernalex> we already have negate in there. I would be 100% in favour of getting rid of unary negation.
00:10:32 <bernalex> (so I guess nobody would put me on haskell' anytime soon ;)
00:10:42 <ent> what about get rid of subtraction and just use x + -y
00:10:48 <ent> less characters
00:11:23 <quicksilver> plenty of people are in favour of getting rid of unary negation, bernalex 
00:11:48 <quicksilver> the main reason people really want it is for "negative literals"
00:11:54 <quicksilver> which, in fact, are not negative literals
00:12:01 <bernalex> I know. it's dumb.
00:12:32 * hackagebot exit-codes 0.1.0.0 - Exit codes as defined by BSD  https://hackage.haskell.org/package/exit-codes-0.1.0.0 (justus)
00:12:44 <bernalex> dumb being, of course, the prudent academic terminology.
00:13:10 <quicksilver> people have suggested a whitespace sensitive solution
00:13:59 <quicksilver> so (- 1) would be (subtract 1) but (-1) would be (negate 1)
00:14:05 <bernalex> I'd very seriously prefer writing "negate 5" for literals.
00:14:09 <quicksilver> but that is another annoying corner case
00:14:22 <quicksilver> that would be hte most consistent and elegant answer, bernalex 
00:14:26 <quicksilver> but unacceptable to some
00:14:51 <quicksilver> how about making people write (read "-5")? :)
00:16:08 <jle`> my solution would be to disallow (+ 5) type sectioning and require (`(+)` 5)
00:16:44 <jle`> it looks like a squinty eyed pig :3
00:16:54 <kadoban> Haha
00:20:40 <jle`> but yeah, it'd get rid of syntactic ambiguity
00:20:47 <jle`> er, corner cases, i mean
00:21:47 <kadoban> nuking unary '-' seems like a much nicer way to get rid of the ambiguity.
00:23:42 <frerich> quicksilver: What do you mean by 'which, in fact, are not negative literals'? You mean that syntactically, there is no 'negative literal' in e.g. '2 * (-3)' because '-3' is not a 'literal'?
00:24:16 <quicksilver> frerich: erm I think that is what I mean.
00:24:30 <quicksilver> -3 is desugared to negate (fromIntegral 3)
00:24:38 <quicksilver> not to (fromIntegral (-3))
00:24:47 <quicksilver> the latter is what I would expect "negative literals" to connote
00:24:47 <frerich> quicksilver: If it's not a literal, then what... oh, syntactic sugar for negate, interesting.
00:25:11 <jle`> @let data Foo = Foo deriving Show
00:25:12 <lambdabot>  Defined.
00:25:34 <jle`> @instance Num Foo where fromIntegral x | x < 0 = error "negative" | otherwise = Foo
00:25:34 <lambdabot> Maybe you meant: instances instances-importing
00:25:39 <jle`> @let instance Num Foo where fromIntegral x | x < 0 = error "negative" | otherwise = Foo
00:25:40 <lambdabot>  .L.hs:152:9:
00:25:41 <lambdabot>      ‘fromIntegral’ is not a (visible) method of class ‘Num’
00:25:50 <jle`> @let instance Num Foo where fromInteger x | x < 0 = error "negative" | otherwise = Foo
00:25:52 <lambdabot>  .L.hs:151:10: Warning:
00:25:52 <lambdabot>      No explicit implementation for
00:25:52 <lambdabot>        ‘+’, ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
00:26:07 <jle`> oh i didn't implement negate
00:26:13 <jle`> > 4 :: Foo
00:26:14 <lambdabot>      No instance for (Num Foo) arising from the literal ‘4’
00:26:15 <lambdabot>      In the expression: 4 :: Foo
00:26:29 <jle`> nvm i'm going to sleep v.v
00:42:38 * hackagebot ho-rewriting 0.2 - Generic rewrite rules with safe treatment of variables and binders  https://hackage.haskell.org/package/ho-rewriting-0.2 (EmilAxelsson)
00:47:38 * hackagebot cacophony 0.2.0 - A library implementing the Noise protocol.  https://hackage.haskell.org/package/cacophony-0.2.0 (jgalt)
00:56:40 <boss14420> ?src ($)
00:56:40 <lambdabot> f $ x = f x
00:56:52 <boss14420> ?src filter
00:56:52 <lambdabot> filter _ []     = []
00:56:52 <lambdabot> filter p (x:xs)
00:56:52 <lambdabot>     | p x       = x : filter p xs
00:56:52 <lambdabot>     | otherwise = filter p xs
01:00:03 <boss14420> @help
01:00:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:00:11 <boss14420> @list
01:00:11 <lambdabot> What module?  Try @listmodules for some ideas.
01:00:29 <boss14420> @pl filter
01:00:29 <lambdabot> filter
01:00:40 <boss14420> @pointful filter
01:00:41 <lambdabot> filter
01:02:59 <boss14420> ?src init
01:02:59 <lambdabot> init [x]    = []
01:02:59 <lambdabot> init (x:xs) = x : init xs
01:02:59 <lambdabot> init []     = undefined
01:03:58 <boss14420> ?src inits
01:03:58 <lambdabot> inits []     = [[]]
01:03:58 <lambdabot> inits (x:xs) = [[]] ++ map (x:) (inits xs)
01:04:16 <merijn> boss14420: Please use private messaging instead of spamming the channel
01:20:25 <nomeata> ttuegel: Hi
01:20:31 <nomeata> ttuegel: About Cabal bug #2398
01:21:11 <nomeata> This is really annoying when we cannot tell whether some package fails on a less-well-supported architecture because it is buggy, or because Cabal is somehow not showing the full log
01:22:23 <nomeata> ttuegel: were you able to reproduce the problem (e.g. by compiling setup without -threaded)?
01:26:21 <nomeata> ttuegel: And while we are at it: It would be nice to have a mode where the test runner is directly connected to stdout and able to detect that it is a terminal, so we get the nice colors.
01:54:59 <Aleksejs> can anyone help me with this problem? http://vpaste.net/aqobj
02:08:47 <saulzar> Aleksejs, Are you using sandboxes? 
02:13:20 <Aleksejs> saulzar: no
02:15:34 <saulzar> Aleksejs, I think you need to - it's super easy, find a directory/new directory for it - type 'cabal sandbox init' and then anything you install with 'cabal install' in that folder goes in the local sandbox.
02:16:08 <saulzar> Aleksejs, The idea is you make sandboxes for different projects which you work on (so if they're unrelated you won't get (so many) version conflicts)
02:17:46 <Aleksejs> cabal: unrecognised command: sandbox
02:17:59 <saulzar> cabal --version ?
02:18:34 <saulzar> cabal sandboxes have been around for a while.. 
02:20:03 <Aleksejs> 1.16
02:20:19 <Aleksejs> updating atm
02:22:41 <anks> can i group list by data constructor ?
02:23:18 <epsilonhalbe> you can use groupBy and write your grouping function 
02:23:20 <anks> or maybe i mean type constructor
02:23:23 <anks> ok
02:25:00 <anks> thanks :)
02:25:29 <epsilonhalbe> @anks type constructor wouldn't be possible lists allow only for one type for the elements
02:25:29 <lambdabot> Maybe you meant: thanks ask
02:26:12 <anks> yup i just wasn't sure which is which ^^
02:26:19 <anks> thank you though
02:26:21 <Aleksejs> what should I do after cabal update to make cabal 1.22 the actual version? Sysem still sees 1.16
02:26:45 <epsilonhalbe> is the cabal in the path
02:28:02 <dcoutts> Aleksejs: yeah, check your $PATH
02:29:38 <Aleksejs> I have cabal in /usr/bin, which is in $PATH
02:29:55 <epsilonhalbe> but your newly updated cabal is where?
02:30:04 <dcoutts> Aleksejs: right, and the one you just installed will probably be in ~/.cabal/bin
02:30:06 <epsilonhalbe> in .cabal/bin/ ?
02:30:54 <Aleksejs> yes, 1.22 is in ~/.cabal
02:31:02 <dcoutts> Aleksejs: so you want to adjust your $PATH to put that location first
02:31:26 <dcoutts> Aleksejs: (or put that at the end of the $PATH, and remove the one from /usr/bin)
02:31:46 <dcoutts> (the /usr/bin/cabal I mean)
02:33:10 <Aleksejs> ok, I initialized sandbox, thanks
02:55:33 <merijn> argh
02:56:11 <merijn> I hate it when my elegant and simple design manages to make my life hell later on :(
02:58:09 * hackagebot nats 1.1 - Natural numbers  https://hackage.haskell.org/package/nats-1.1 (EdwardKmett)
03:14:12 <quchen_> I'm looking for a nontrivial build system using Shake for a live demo. Does anyone know of such a thing? Compiling a popular C library would probably be an excellent example.
03:14:31 <quchen_> The micro-demos usually compile in sub-second time, so there's not much to show off.
03:15:56 <rom1504> http://shakebuild.com/#who-uses-shake
03:16:15 <rom1504> anything under "Several open-source projects make key use of Shake:" will probably take some time to build
03:34:22 <quchen_> Those use Shake as a library :-(
03:34:33 <quchen_> Except GHC, which isn't done being ported to Shake yet
03:58:56 <meditans> hi, I have a question about libraries: I'm writing a library which uses containers. As I'd like to avoid the Ord instance for the users of the library, are there any downsides on using unordered-containers instead of containers, in your experience?
04:03:47 <merijn> meditans: Why do you want to avoid the Ord instance?
04:04:02 <quchen_> nitpick, "Ord constraint", not "Ord instance"
04:04:22 <quicksilver> meditans: unordered-containers will give you a Hashable constraint
04:04:34 <quicksilver> in general I would think a Hashable constraint is neither better nor worse...
04:04:42 <merijn> I'd say worse
04:04:47 <merijn> You can't derive Hashable :p
04:04:52 <quchen_> Hashable is much less common
04:06:21 <quicksilver> you can derive Hashable in GHC
04:06:31 <quicksilver> as long as your type can derive Generic
04:06:37 <meditans> merijn: I've been bitten by trying to write ord constraints just for the need in containers, but for deriving there isenmann http://hackage.haskell.org/package/hashable-1.2.2.0/docs/Data-Hashable.html#g:4
04:06:59 <meditans> there is*
04:07:13 <merijn> Still, then you're writing Hashable constraints instead of Ord
04:07:18 <merijn> I don't see the difference?
04:07:20 <quicksilver> agreed
04:07:33 <quicksilver> you can derive hashable and ord automatically for precisely the same set of types
04:07:38 <quicksilver> 'plain data' types
04:07:48 <meditans> merijn: quicksilver: so, as users, you'd prefer the ord instance
04:07:54 <nomeata> hvr: thanks for the updated MRP proposal. do you have a specification for the "lawful definitions detection" feature?
04:08:04 <quicksilver> as a user I would be pretty unfussed by eitehr I think
04:08:13 <meditans> my reasoning was that hashing is by default opaque, so the instance is used for that, while the ord constraint is used for comparison
04:08:30 <quicksilver> it's a fair point
04:08:40 <quicksilver> and there are some reasons to define 'bad' Ord instances
04:08:47 <quicksilver> and if you do that, your containers will break
04:08:57 <quicksilver> there is no reason to define a 'bad' Hashable afaik
04:09:13 <quicksilver> (on the other hand I don't actually agree with the reasons to define bad Ord instances so I don't do that...)
04:09:39 <nomeata> hvr: especially, do you plan to hard-code this for return/>>, or will it be a general feature of “this looks like a method with a default implementation, but really, it is a top-level definition with the extra bit of information that it allows instances to have this method, as long as it is equivalent”?
04:11:06 <meditans> quicksilver: is there a difference in speed between the two versions?
04:11:44 <quicksilver> the unordered containers are faster for retrieval in many cases
04:11:58 <quicksilver> but the ordered ones possibly exhibit better sharing?
04:12:02 <quicksilver> I'm actually not sure
04:12:19 <quicksilver> they're asymptotically the same, depending what philosphical view you take on log n time.
04:12:33 <quicksilver> benchmark if you care :)
04:13:36 <freinn> hi! I want to use a parser (attoparsec) for parsing a logs file. I have a parser and I want to apply it to all text, and return a list with the parsed types
04:13:38 <meditans> quicksilver: thanks for the info :)
04:14:27 <meditans> quicksilver: I think I'll go with the unordered version in the end, being absent any particular problem
04:14:38 <freinn> my code is here: http://lpaste.net/144643, but now working yet
04:15:31 <quicksilver> when you say not working freinn, what do you mean? does it compile? does it run but not do what you want?
04:15:56 <cocreature> freinn: 'many' lets you turn your parser into a parser that parses a list of those things, then you can just apply it to your text
04:16:36 <freinn> quicksilver nope, is not running, I want a function to receive Text, and then returns me a list of that parsed results
04:16:57 <quicksilver> and what happens when you try to run your code?
04:17:10 <freinn> I want to apply parseBackTrace to a whole text
04:17:27 <freinn> quicksilver doesn't compile at the moment, I'm looking for a magic function
04:17:53 <quicksilver> well cocreature gave you the core answer
04:17:55 <freinn> cocreature thanks, but that gives me a parser function, I want a Text -> [BackTraceInfo] function
04:18:28 <cocreature> freinn: throw parse from Data.Attoparsec.Text on it
04:18:42 <quicksilver> or parseOnly perhaps
04:18:53 <quicksilver> if you don't want to deal with partial parses
04:18:55 <cocreature> ah yeah, that's probably more appropriate
04:19:26 <quicksilver> I have other comments, including "TIO.putStrLn parseResult" doesn't type check, and the explicit use of ICU is not necessary.
04:19:41 <quicksilver> but parseOnly / many is the main answer you need
04:20:14 <freinn> okay, I will try. thanks both quicksilver and cocreature
04:27:13 <quchen_> nomeata: I think the current plan is just hardcoding it, just like the warnings.
04:27:26 <quchen_> A better implementation would give you the "REMOVED" pragma or something like that.
04:43:29 <merijn> edwardk: ping?
04:53:01 <freinn> hi! can anyone help me parsing this?? I've tried a very simple attoparsec parser but doesn't parse anything http://lpaste.net/144649
04:58:21 <lyxia> freinn: isn't many1 anyChar going to consume the whole output?
04:58:49 <quicksilver> yes
04:59:01 <quicksilver> I imagine freinn is hoping it will be terminated by endofline but that's not how many1 works
04:59:20 <quicksilver> try manyTill instead
04:59:29 <freinn> lyxia quicksilver ok, thank you
04:59:41 <quicksilver> errorInfo <- manyTill anyChar endOfLine
04:59:43 <quicksilver> for example
04:59:53 <quicksilver> and the same change in the other places you use many1 anyChar
05:00:02 <freinn> quicksilver thank you
05:00:18 <quicksilver> because anyChar will never fail
05:00:27 <quicksilver> it would never try the endOfLine
05:02:00 <ski> frerich : well, one of them :)
05:02:37 <frerich> freinn: I think ski's last message was meant for you. :o)
05:05:49 <ski> ('twasn't)
05:15:45 <robtaylor> so, I was wondering if there was a non bit wrotten tool to create a haskell envinorment with specific haskell versions. I was pointed to stack, but unfortunatly I need 7.4. Are there any other options?
05:17:35 <obadz> I while back I asked if there was a total function Read a => String -> Maybe a. I was told there wasn't..
05:17:40 <obadz> Turns out there is: Data.Text.readMaybe
05:18:30 <liste> there's also readMay in safe
05:18:32 <MarcelineVQ> For a total read there's also `reads` but it uses a list instead of a maybe to handle failure
05:18:33 <E4xoi> it might be new (<2 years)? 
05:18:38 <obadz> sorry Text.Read.readMaybe
05:19:13 <E4xoi> MarcelineVQ: listToMaybe . reads :P
05:19:19 <MarcelineVQ> :>
05:19:38 <liste> readMaybe haddock reads "Since: 4.6.0.0"
05:20:32 <E4xoi> sounds new, isn't that ghc 7.6?
05:21:35 <ski> > [n | (n,s) <- (reads :: ReadS Integer) " -12  ",("","") <- lex s]
05:21:36 <lambdabot>  [-12]
05:23:14 * hackagebot getopt-generics 0.12 - Create command line interfaces with ease  https://hackage.haskell.org/package/getopt-generics-0.12 (SoenkeHahn)
05:26:41 <tommd> Is someone here familiar with the conjugateGradientDescent operation as it appears in AD?
05:33:22 <quicksilver> robtaylor: I don't think it would be particularly hard to install ghc-7.4 yourself in a subdirectory
05:33:33 <quicksilver> robtaylor: I'm sure it supports PREFIX or similar
05:33:46 <quicksilver> robtaylor: (but no, I don't think there is anything packaged for this)
05:34:50 <robtaylor> quicksilver: thanks :) I was trying to avoid this for the sake of others using the codebase
05:35:13 <robtaylor> will have to just script it up or fix the code
05:38:15 * hackagebot SFML 2.3.2 - SFML bindings  https://hackage.haskell.org/package/SFML-2.3.2 (sulami)
05:59:50 <chenwl> data Union (r :: [ * -> * ]) v where UNow :: t v -> Union (t ': r) v, what does ': mean?
06:00:14 <chenwl> http://okmij.org/ftp/Haskell/extensible/OpenUnion41.hs
06:00:19 <quicksilver> I think it's lifting : to the level of types
06:00:25 <quicksilver> it's a type-level list cons (?)
06:00:57 <quicksilver> yes
06:01:04 <chenwl> quicksilver: lifting? where can I learn further info about that
06:01:15 <quicksilver> well the word 'lift' in my sentence was informal
06:01:16 <merijn> I should sucker someone into writing tests for me as "practice" so I can be lazy... :p
06:01:25 <quicksilver> I'm afraid the word lift is used for all kinds of different concepts
06:01:34 <quicksilver> it means "analogy to a different situation"
06:01:39 <merijn> quicksilver: Technically DataKinds does the lifting, ' just disambiguates
06:01:44 * quicksilver nods
06:01:51 <benzrf> quicksilver: it means something like functor :>
06:02:04 <quicksilver> so, chenwl, do you understand (r :: [ * -> * ]) ?
06:02:23 <quicksilver> because that is the bit to understand first :)
06:02:29 <benzrf> is turtle the preferred option for shelly stuff in haskell?
06:02:35 <JonReed> Can somebody clarify or give a link with an explanation of how some of the magic of haskell's "dependent"-like types work. E.g., in GHC.TypeLists there are kinds like Nat and Symbol. I don't fully get any intermediate steps, but from what I see it has "newtype SNat  (n :: Nat) = SNat Integer". Integers have negative values, however, it does not allow to define negative values. How does that work & can haskell's current trick for "depe
06:02:46 <benzrf> and if so, is there a tutorial or explanation of it that assumes familiarity with haskell?
06:02:50 <chenwl> quicksilver: not really, "type level list" or something like type level value
06:03:10 <JonReed> Here is the source for Nat and Symbol : https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.TypeLits.html#Nat
06:03:12 <quicksilver> chenwl: yes, so it says that the type "Union" takes two parameters
06:03:18 <quicksilver> chenwl: the second parameter is just a normal type
06:03:26 <quicksilver> chenwl: but the first parameter is a *list* of types of kind * -> *
06:03:37 <quicksilver> so for example [Maybe]
06:03:42 <quicksilver> or [Either String, Maybe]
06:03:49 <quicksilver> perhaps merijn will correct me if I get this wrong :)
06:04:59 <quicksilver> then the 'UNow' constructor takes a value of type (t v) ... so t must be of kind * -> *, e.g. t = Maybe, v = Int, UNow takes a parameter of type Maybe Int
06:05:09 <JonReed> In some other explanations I've seen that the value in the "type" is encoded through arity (so * = 1, * -> * = 2, * -> * -> * = 3 and so on). But the source for Nat is confusing.
06:05:14 <chenwl> quicksilver: Is this relevant? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html
06:05:24 <quicksilver> and it constructs a value of type Union (Maybe : r) Int
06:05:32 <chenwl> 7.9.4. Promoted list and tuple types
06:05:34 <quicksilver> so that second paramter (Maybe : r) is a list of types
06:05:44 <quicksilver> and we've just pushed Maybe onto the front of it
06:05:51 <quicksilver> note that the tail of the list is unrestricted
06:06:01 <quicksilver> you can use UNow polymorphically over any possible list tail.
06:06:21 <quicksilver> chenwl: yes, that is relevant.
06:06:43 <quicksilver> "in these cases, if you want to refer to the promoted constructor, you should prefix its name with a quote:"
06:06:53 <chenwl> quicksilver: Thanks, I'll study that first.
06:08:17 <quicksilver> merijn: what *exactly* is ambigous in this case? how could there possibly be a value `:` hanging around there?
06:10:42 <zennist> haskellers! how to write a function that gives the maximum sum of a subsequence in a list?
06:11:07 <zennist> (I know how to do it in a procedural language, just curious on what functional people will come up with)
06:11:10 <merijn> quicksilver: I don't think that case is ambiguous?
06:11:18 <quicksilver> is that not equivalent to finding the longest positive subsequence?
06:11:23 <quicksilver> ok not longest
06:11:32 <zennist> obviously you can do it with accumulators, but maybe some more clever construct?
06:11:41 <quicksilver> but first you restrict to maximal positive subsequences
06:11:46 <quicksilver> which are necessarily non-overlapping
06:11:48 <quicksilver> and then you sum them
06:12:04 <quicksilver> merijn: OK, so the ' here is not needed?
06:12:08 <zennist> quicksilver: not necessarily, you can have a subsequence that contain negative bits but the later positive numbers make up
06:12:21 <quicksilver> oh right
06:12:36 <quicksilver> I don't even know the right algorithm, let alone how to implement it best in haskell :)
06:13:11 <andrybak> zennist this is typical dynamic programming problem, isn't it?
06:13:31 <obadz> zennist: you just compute a running sum and you drop it when it's negative
06:14:49 <JonReed> zennist: Is this what you're looking for? http://rosettacode.org/wiki/Maximum_subarray#Haskell
06:15:11 <andrybak> zennist: obadz is right, compare [1, 1, 1, -2, 100] and [1, 1, 1, -4, 100]
06:18:04 <ob_> anybody know why yum/dnf is wanting to downgrade my ghc from 7.10.2 to 7.10.1?
06:18:06 <andrybak> zennist: that's exactly, what rosettacode suggests : `sofar` is the running sum, if it drops to zero, `a` is reset to (0,[])
06:18:24 <ob_> on fedora 22
06:26:30 <frerich> Hm when somebody writes '(λx.xx)' then that would be "\x -> x x" in Haskell's notation, right?
06:26:43 <frerich> I.e. the '.' separates the arguments and 'xx' means 'x applied to x'?
06:26:48 <obadz> frerich: i think so
06:27:12 <quchen_> Yes.
06:27:18 <merijn> frerich: Normally yes in lambdacalculus
06:27:22 <merijn> frerich: But it's a bit ambiguous
06:27:38 <merijn> frerich: Without spaces it depends on whether you only consider single letter variables
06:27:49 <merijn> 'xx' could also be a single (two letter) free variable
06:28:26 <merijn> Did we have binaries for cabal yet somewhere? Or do I need to build from source?
06:30:16 <c_wraith> merijn: there are binaries
06:30:36 <c_wraith> merijn: https://www.haskell.org/cabal/download.html
06:31:04 <c_wraith> (scroll down a ways.  I don't know why they're hidden)
06:32:01 <merijn> c_wraith: I only see x86 binary there?
06:32:07 <zennist> andrybak: well, resetting is not correct - you need to include the negative numbers in your subsequence when you know that later numbers can be bigger, positive values
06:32:15 <merijn> The others seems to be linked to Halcyon, whatever that is
06:32:32 <c_wraith> merijn: scroll down a ways
06:32:51 <zennist> obadz: so with a procedural language, you'd compute the running sum for n elements, and then scan through that running sum array and spot the span with the maximum difference
06:32:53 <c_wraith> merijn: like past the halcyon stuff
06:32:57 <zennist> in total O(n)
06:33:04 <andrybak> zennist: compare [1,1,1, -2, 100] <- running sum here won't drop below zero
06:33:11 <merijn> c_wraith: Those are source links
06:33:20 <andrybak> [1,1,1,-4, 100] <- running sum will drop below zero
06:33:33 <c_wraith> merijn: "Binary download for ...".  Three paragraphs in a row.  Right past the halcyon stuff.
06:33:36 <merijn> c_wraith: The binary is only for x86 linux, not x64
06:34:07 <merijn> Unless the x86 binary works with x64 ghc...
06:34:13 <zennist> andrybak: think about a scenario where you have a major negative running sum (-100), now if that running sum can become 100 later on, you get a 200 difference and that span would be the maximum sum subsequence
06:34:14 <andrybak> zennist: in first example answer is 101, in second answer is 100
06:34:24 <zennist> so just dropping the running sum is not enough
06:36:15 <andrybak> zennist imagine you want to climb the highest island , positive numbers - you climb up, negative - you go down, if you go below zero - you drawn in water, but you might decide to go to next island on a boat
06:37:22 <epsilonhalbe> i am working with conduit - and get the message "illegal polymorphic or qualified type ... use RankNTypes or Rank2Types ...", having little experience with language extensions are they safe to turn on? 
06:37:31 <quicksilver> yes, epsilonhalbe 
06:37:39 <epsilonhalbe> thx 
06:37:41 <obadz> :t maximum . scanl1 ((max 0 .) . (+))
06:37:42 <lambdabot> (Num c, Ord c) => [c] -> c
06:37:47 <obadz> ^ zennist 
06:38:10 <zennist> andrybak: okay I see, basically, every maximum sum subsequence should begin with a positive number
06:38:47 <obadz> > maximum . scanl1 ((max 0 .) . (+)) $ [1,1,1,-4,100]
06:38:48 <merijn> epsilonhalbe: RankN types are fine, the only problem they have is that they're not inferrable, so you might have to add explicit type signatures sometimes to make them work
06:38:48 <lambdabot>  100
06:40:48 <zennist> > scanl1 ((max 0 .) . (+)) [1,1,1,-4,-5,8,9]
06:40:50 <lambdabot>  [1,2,3,0,0,8,17]
06:41:33 <obadz> in case that's obscore, (max 0 .) . (+) is the same as \ x y -> max 0 (x + y)
06:41:57 <zennist> > scanl1 ((max 0 .) . (+)) [1,3,6,-4,-5,8,9,10]
06:41:58 <lambdabot>  [1,4,10,6,1,9,18,28]
06:42:05 <zennist> obadz: yeah I understand that part
06:42:43 <zennist> okay, that's a really nice solution
06:43:31 <quicksilver> so scanl embodies a really simple dynamic programming style which is just about prefixes of the list?
06:44:40 <obadz> quicksilver: there's no dynamic programming here, this is a shortcut that yield a linear time solution
06:47:23 <quicksilver> well it's re-using the subsequences already calculated isn't it like a very simple case of dynamic programming?
06:47:43 <quicksilver> maybe I'm looking at it wrong
06:47:52 <merijn> quicksilver: I think so
06:48:15 <merijn> In fact, this sounds like the most obvious example of dynamic programing I've heard in a long while
06:48:59 <obadz> is there a way to write f :: Dynamic -> Json.Value (something like fmap toJSON . fromDynamic)
06:49:17 <obadz> I think I might need some existential magic (forall a . (Typeable a, ToJSON a))
06:49:29 <obadz> not sure where to put it or if it's even possible?
06:50:00 <epsilonhalbe> merijn: ah - already had the explicit type signature so no problem there, but good to know
06:50:26 <obadz> (would be Maybe Json.Value)
06:50:34 <quicksilver> obadz: only give a statically calculated list of types
06:50:57 <quicksilver> if you know, in practice, that your Dynamic can only be one ofthe types A,B,C,D,E... each of which have ToJSON instances
06:51:02 <quicksilver> then you can obviously just try them all.
06:51:24 <quicksilver> otherwise, yes, you need another class constraint - which makes it not Dynamic any more
06:51:45 <quicksilver> given that ToJSON is such a simple class you could just bundle in the JSON Value itself tho
06:51:56 <quicksilver> most uses of existential types are a design error :)
06:51:59 <obadz> quicksilver: is this because seeing a different list of instances would yield different behavior?
06:52:13 <quicksilver> I wouldn't put it that way
06:52:32 <quicksilver> I'd say it's because the information about which types implement which classes only exists at compile time, not at runtime
06:52:59 <obadz> don't existential have vtables ?
06:53:23 <obadz> I guess your statement could still be true if that were the case
06:53:43 <ski> obadz : they don't
06:54:15 <obadz> ski: how do you do map show on a list of forall a. Show a => [a] ?
06:54:32 <obadz> ski: without a vtable?
06:55:00 <quicksilver> I would call it a dictionary, not a vtable, but yes existentials bundle the dictionary of the constraints you provided
06:55:15 <quicksilver> since Dynamic doesn't have a ToJSON constraint it doesn't get a ToJSON dictionary
06:55:20 <quicksilver> (it does get a Typeable dictionary)
06:55:45 <obadz> quicksilver: what do you mean by "given that ToJSON is such a simple class you could just bundle in the JSON Value itself" ?
06:55:45 <quicksilver> ... however, in many practical cases, existentials and dictionary bundling are not the simplest solution
06:55:56 <quicksilver> as, indeed, Dynamic is also not the simplest solution
06:55:56 <ski> quicksilver : the `exists' doesn't add a dictionary. the constraint would (in general) require a dictionary at run-time
06:55:59 <ski> er
06:56:00 <ski> obadz ^
06:56:20 <quicksilver> obadz: well if you do forall a . ToJSON a => a
06:56:39 <quicksilver> then you might imagine you are actually producing values of type (ToJSONDict a, a)
06:56:46 <quicksilver> so that the compiler can unwrap it later.
06:56:53 <ski> obadz : .. also, a list of type `forall a. Show a => [a]' is pretty useless. all elements of it must be bottoms
06:57:01 <quicksilver> but if you're going to do that, why not produce a value of type
06:57:10 <quicksilver> (JSON.Value, a)
06:57:18 <quicksilver> and just pick that JSON.Value out when you need it
06:57:27 <quicksilver> because of laziness that's effectively the same thing but needed less machinery
06:57:37 <quicksilver> i.e. you "call toJSON in advance"
06:57:41 <obadz> ski: I'm not sure why.. I thought that was a common example of existantial use?
06:57:46 <quicksilver> but because of laziness you know the work isn't actually done
06:58:05 <quicksilver> ski: obadz actually meant [Showable] where data Showable = forall a  Show a => MkShowable a
06:58:08 <quicksilver> I presume
06:58:09 <ski> obadz : a list of type `[exists a. Show a *> a]', otoh would have a `Show' dictionary bundled with each element
06:58:12 <merijn> obadz: The only thing you can call on an existential value like that is "show", so why not just have a [String]?
06:58:24 <ski> quicksilver : yes, i presume so too :)
06:58:38 <obadz> merijn: agreed ;-)
06:58:47 <quicksilver> ok but merijn's comment is the same as mine
06:58:54 <quicksilver> if the only thing you can do is call toJSON
06:59:00 <obadz> quicksilver: I get your comment now
06:59:03 <quicksilver> then why not just bundle the JSON.Value? :)
06:59:13 <obadz> quicksilver: I'm putting these things in a TVar
06:59:16 <obadz> quicksilver: strictly
06:59:23 <obadz> quicksilver: so would rather avoid the call to ToJSON
06:59:27 <obadz> quicksilver: if I don't need it
06:59:35 <quicksilver> so, don't make that part strict?
06:59:46 <merijn> obadz: Laziness, etc.
06:59:53 <quicksilver> put this in : x `seq` (toJSON x, x)
06:59:57 <quicksilver> that's strict on the x-bit
06:59:58 <obadz> quicksilver: modifyTVar' is strict
07:00:02 <ski> quicksilver : i just fancy trying to make people realize that when they talk about stuff like "a list of forall a. Show a => [a]", it's strictly speaking not what they intended :)
07:00:02 <quicksilver> but not on the toJSON bit
07:00:13 <quicksilver> obadz: yes but only top-level strict
07:00:18 <quicksilver> the tuple intercepts the strictness
07:00:23 <quicksilver> or discharges it
07:00:26 <quicksilver> or whatever you like to say
07:00:29 <obadz> quicksilver: far enough.
07:00:31 <obadz> fair
07:00:57 <quicksilver> also, reconsider yur design to see if you can avoid existentials, Dynamic, or typeclasses :)
07:01:08 <quicksilver> often there is a more elementary design which uses none of those features
07:01:15 <ski> @where existential-antipattern
07:01:15 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
07:01:26 <obadz> quicksilver: I should probably reconsider my design if I need to write code at all ;-)
07:01:42 <obadz> I'm not using existentials so far
07:01:54 <obadz> I don't think I could avoid Dynamic
07:02:05 <obadz> I'm writing an RPC server where the client is Excel
07:02:27 <obadz> for values that Excel can't display (anything other than Bool/Int/Float/String/Day)
07:02:52 <obadz> I store the value in a hashmap and return a key to the value instead
07:03:11 <obadz> which means this map contains value of many types
07:03:17 <obadz> you see a way around Dynamic here?
07:09:26 <ProofTechnique> Is support for first-class functions really sufficient to express recursion schemes? I'm trying to imagine what that looks like in something gross like PHP
07:10:43 <quicksilver> obadz: you have an RPC protocol with an unbounded set of types?
07:10:54 <quicksilver> and five of them are sent directly to Excel
07:11:00 <quicksilver> and "any other type" has to be stored and keyed?
07:11:20 <obadz> quicksilver: it uses Json to communicate with Excel, but yes pretty much
07:11:46 <quicksilver> if you really have to support 'any type' (or at least, an unbounded set of types) then, probably you might as well use Dynamic
07:12:06 <quicksilver> if in fact you only have to support 'the following 8 types' then you could (and possibly should) just put them in an ADT.
07:12:16 <obadz> no it's definitely unbounded
07:12:20 <quicksilver> but if it's an open list you'll end up building something like Dynamic anyway
07:12:53 <obadz> now I'm wondering if there's a way to write Dynamic -> Maybe [Dynamic] that will not return Nothing on toDyn $ [1,2,3]
07:13:29 <obadz> In other words I'd like to write some polymorphic rpc functions...
07:13:51 <ProofTechnique> quicksilver: What about TypeLits? That might give a tiny bit more safety, anyway, so the types don't get mangled
07:14:11 <quicksilver> ProofTechnique: 'Dynamic' is perfectly safe.
07:14:20 <quicksilver> I don't think typelits help here.
07:14:25 <obadz> :t fromDynamic
07:14:26 <lambdabot> Typeable a => Dynamic -> Maybe a
07:14:29 <obadz> ^ ProofTechnique 
07:14:34 <ProofTechnique> Oh, fair enough
07:14:54 <ProofTechnique> :D
07:15:29 <skatenerd> Does anyone have experience getting ghc-mod to play nicely with stack?  I installed Haskell Vim Now and borked my vim environment.  Despite trying to reconfigure cabal, I can't get cabal to see the packages I've installed via Stack...
07:16:05 <skatenerd> https://www.reddit.com/r/haskell/comments/3cf5yd/stack_ghcmod_work_in_progress/cwp24fb
07:16:47 <obadz> https://ghc.haskell.org/trac/ghc/wiki/PolymorphicDynamic <= this might have helped me
07:17:18 <quicksilver> I don't thnk you should be trying to work 'inside' dynamic like that
07:17:37 <quicksilver> I think you should be pulling them out with the right types - as determined by your RPC - and operating on them and then pushing them back if needed
07:18:16 <obadz> quicksilver: say I want to write head :: [a] -> a
07:18:25 <obadz> quicksilver: I'd have to write a specialized version for every a
07:18:44 <phadej> skatenerd: if you use stack, don't use cabal
07:18:56 <phadej> especially remove sandbox and dist directories
07:19:01 <SK0> Is it possible to limit (:: arbitrary) values to a certain range, other than (\x -> x < n ==> ...)?
07:19:30 <phadej> skatenerd: with newtype
07:20:01 <skatenerd> phadej: i'm not using cabal directly
07:20:50 <phadej> skatenerd: is your ghc-mod and stack compiled against same `Cabal` library?
07:20:58 <quicksilver> obadz: I don't follow
07:21:00 <SK0> I am testing a function that works on Vectors (which I generate myself using an arbitrary Double for length), but the Vectors get really big, tests become superslow, computers explode, etc
07:21:29 <obadz> quicksilver: I have a Dynamic that I know is a [something] and I'd like the first something as a dynamic
07:21:44 <obadz> quicksilver: at compile time, I don't know what "something" is
07:22:00 <obadz> quicksilver: (at runtime I can inspect typerep presumably)
07:22:06 <c_wraith> SK0: the easiest approach is to use a newtype around Vector, and write your own arbitrary instance for that newtype
07:22:08 <phadej> SK0: Double for length sounds like not the best idea
07:22:12 <quicksilver> ok but how do you get into a state where you know it's [something] and not know exactly what it is?
07:22:21 <quicksilver> this is a strange state of partial information
07:22:24 <c_wraith> SK0: then you can unwrap it in your test functions
07:22:33 <quicksilver> (perhaps you should actually store it as [Dynamic]!)
07:22:50 <skatenerd> phadej: I know they're compiled against the same GHC, but how do I check which `cabal` library?
07:22:59 <obadz> quicksilver: (actually I don't know it's a [], I'd expect to get a Nothing back if it's not a list..)
07:23:06 <SK0> phadej, the function I generate the Vector with takes seconds as input
07:23:26 <SK0> the function belongs to a typeclass
07:23:49 <quicksilver> obadz: anyhow - as you have realised - the design space for Dynamic is when you actually know the exact type
07:23:51 <SK0> I want to verify that for this class, any arbitrary instance will generate a Vector of the length I put in
07:23:55 <quicksilver> you just want to store it uniformly
07:24:25 <quicksilver> so for a given Dynamic you are expected to know what type it is, at the point of use.
07:24:35 <obadz> k I might just store Json values but that feels like it would cost some performance..
07:24:45 <obadz> I guess it would be no worse than using python
07:25:05 <SK0> c_wraith, I will give that a try
07:25:52 <quicksilver> storing json values is probably many times faster than python
07:26:27 <quicksilver> and it gives you a uniform way to explore the objects and their "types"
07:26:46 <phadej> skatenerd: IIRC you have to use ~same snapshot for you project, and ghc-mod
07:27:34 <phadej> skatenerd: not for stack itself, that I remembered wrong
07:36:22 <obadz> quicksilver: I guess roundtripping from a to Value to a actually involves no text parsing so why not
07:37:24 <danza> hi there, i get an error from the compiler, which i can't understand. here code and error http://lpaste.net/144655
07:37:43 <quicksilver> obadz: yeah.
07:38:49 <joeyh> I want a function to be callable from STM but also from IO, and stacks over IO. What's the way to do that, monad-base or such?
07:39:37 <Ankhers> joeyh: Is this a pure function, or does it actually call IO and or STM functions?
07:40:12 <quicksilver> joeyh: "STM", not "ST" ?
07:40:15 <joeyh> it calls stm
07:40:20 * ski . o O ( s/pure/effectless/ )
07:40:29 <Ankhers> ski: Right, sorry...
07:40:30 <merijn> joeyh: What's wrong with just STM?
07:40:44 <merijn> joeyh: You can just do "atomically $ f x" when you want IO...
07:41:08 <joeyh> well, it's exposed by a library, and many users will just want to use it from IO (but more advanced from STM)
07:41:13 <quicksilver> (FWIW, the MonadBase / PrimMonad stuff is about "ST" and "IO", not STM)
07:41:37 <quicksilver> you'd have to define your own overloading for this
07:41:51 <joeyh> yeah, that's what I did, seemed there should be a general library
07:42:06 <quicksilver> class STMInside m where { runSTM :: STM a -> m a }
07:42:09 <joeyh> maybe I should just export all STM stuff, dunno
07:42:12 <merijn> joeyh: I would just expose STM from your library and let your users use atomically
07:42:18 <stoogenmeyer> hey is this a good resource for learning haskell? http://learnyouahaskell.com/
07:42:19 <quicksilver> but in practice I'd just either expose the STM stuff, or I'd expose it twice
07:42:22 <quicksilver> under different names
07:42:36 <merijn> joeyh: Double exporting everything as IO is kinda redundant
07:42:36 <joeyh> different names got old pretty quick :)
07:42:46 <Ankhers> stoogenmeyer: Depends who you ask.
07:43:02 <stoogenmeyer> Ankhers: um, what if I asked you
07:43:15 <Zekka|Sigfig> stoogenmeyer: I liked it
07:43:21 <merijn> joeyh: Alternatively, define a .STM and .IO module exporting the same functions, but .IO just exposes "foo = atomically . Foo.STM.foo"
07:43:25 <Ankhers> stoogenmeyer: It does not have any exercises, so I do not consider it that great. It was still a fun / interesting read. Though I would not say I learned much after reading it.
07:43:26 <Zekka|Sigfig> A lot of guys have been promoting bitemyapp’s book though
07:43:32 <skatenerd> I liked it too.  It's weird if you already have FP experience.
07:43:44 <merijn> i.e. reexport .STM from .IO with the atomically wrapping it
07:43:47 <skatenerd> because it's like "here's a list, and list comprehensions, and first class functions"
07:43:48 <joeyh> merijn: I find I sometimes mix the two within a singe use of the library
07:44:11 <Zekka|Sigfig> Yeah, it’s a real fast-paced book that’s a little breezy about the theory
07:44:46 <Zekka|Sigfig> there’s a lot of Haskell functionality it’s best to learn just by reimplementing it yourself and there isn’t that much of that in lyah. (Typeclassopedia has much more of that which is why it’s one of my favorite intro texts)
07:44:54 <stoogenmeyer> hm, I didn't know about bitemyapp. maybe I can start doing that after finishing the other one
07:45:09 <Ankhers> @where learnhaskell -- stoogenmeyer 
07:45:17 <Ankhers> @where learnhaskell
07:45:27 <jadus> hi guys
07:45:36 <Zekka|Sigfig> If you get stuck on monads, functors, or applicatives, there’s a chance typeclassopedia will be immediately useful to you
07:45:36 <jadus> dont know if it belongs here, any n00bz help channel or i can ask lame here?
07:45:36 <Ankhers> lambdabot: is failing me :(
07:45:36 <lambdabot> https://github.com/bitemyapp/learnhaskell
07:45:36 <lambdabot> https://github.com/bitemyapp/learnhaskell
07:45:39 <Ankhers> yay
07:45:47 <Zekka|Sigfig> jadus: There’s a beginners channel (I forget the exact name) but people will probably answer your question here too
07:45:48 <merijn> jadus: Any questions are welcome here
07:45:50 <Ankhers> #haskell-beginners
07:46:24 <skatenerd> I wish that LYAH had more examples of functor / monad
07:46:26 <stoogenmeyer> ok that's great. So I will check typeclassopedia out as well
07:46:46 <joeyh> more concretely, this is stuff like openConsoleRegion. It can run in STM, which is handy if you say, want to atomically open several regions etc, but I'd rather not bother users with learning STM exists just to use my library
07:46:49 <skatenerd> I tink the best way to learn that stuff is to just see like 10 different instances
07:46:59 <jadus> Ankhers: thanks
07:47:00 <skatenerd> and let your brain figure out wy they are all th esame abstraction
07:47:05 <quicksilver> the thing about "...that's best to learn just by <X>" is that different people are different
07:47:09 <Ankhers> jadus: No problem.
07:47:13 <quicksilver> different ways of learning and understanding
07:47:26 <Zekka|Sigfig> Yeah — I liked typeclassopedia, which is still pretty abstract, because it makes you demonstrate all the identities yourself
07:47:29 <Zekka|Sigfig> I think a lot of people would not be into that
07:47:44 <quicksilver> that's why we have so many different kinds of books and tutorials
07:47:48 <stoogenmeyer> quicksilver: that's true, but still this was useful because I did not know about those resources and can now use them if needed
07:47:52 <quicksilver> different stokes etc.
07:47:56 <quicksilver> agreed :)
07:48:06 <stoogenmeyer> thanks a bunch guys
07:48:11 <stoogenmeyer> or girls
07:48:12 <Zekka|Sigfig> No worries, have a good time
07:48:23 <joeyh> currently I have my own LiftRegion class but instance MonadIO m => LiftRegion m is problimatic
07:48:46 <quicksilver> joeyh: I don't understand. What is the advantage of the STM version of openConsoleRegion? as a user of the library, why would I ever want to open console regions *inside* STM? is there some why console regions can conflict and cause retries?
07:49:23 <joeyh> quicksilver: you may want to bring up several regional, populate them etc and be assured the the display will not update until the combined transaction completes
07:49:38 <skatenerd> quicksilver: yeah you're right.  I guess I mean that it's an underrepresented approach
07:51:55 <quicksilver> joeyh: ah, interesting.
07:52:13 <joeyh> so it's an 80/20 kind of use pattern..
07:52:26 <quicksilver> joeyh: this is not what I expect STM to be used for
07:52:28 <joeyh> where 80% have your initial reaction
07:52:34 <quicksilver> I expect it to guarantee consistency, not synchronicity
07:52:40 <quicksilver> I find this idea intriguing
07:53:01 <joeyh> well, don't worry, I make use of both. But it's called "atomically" for a reason I guess ;)
07:53:44 <quicksilver> yes - I understood that to be the consistency sense of the word, not the temporal sense
07:53:52 <quicksilver> although I accept that the two are not independent notions
07:54:47 <quicksilver> if I had been asked to design a library to support that (atomic changes to screen layout) I'd have done it diagrams-style, where you build up a pure description of the configuration and then apply it.
07:55:55 <joeyh> that does happen under the hood, it's just that the use cases for this often involve various threads going about their business and updating the display
07:56:37 <quicksilver> yup. makes sense. thanks for explaining.
07:56:54 <joeyh> http://hackage.haskell.org/package/concurrent-output if you're curious
07:57:26 <quicksilver> I have been following your work :)
07:57:34 <quicksilver> you posted a gif here a few days ago
07:57:43 <quicksilver> and your blog is on haskell planet
07:59:15 <joeyh> wonder if I shoud just bite the UndecidableInstances bullet
08:00:10 <joeyh> oh yeah, I remember now, I tried it and things exploded in a way that makes me say "no"
08:00:22 <quicksilver> MonadIO m => LiftRegion m isn't undecidable, it's overlapping
08:00:28 <quicksilver> it overlaps with everything
08:00:31 <joeyh> yeah
08:01:11 <quicksilver> this is what the MonadBase stuff is about
08:01:32 <quicksilver> doing that kind of thing in a way which works :)
08:01:40 <joeyh> that's why I was looking at it, but I ended up seeming to need an instance MonadBase STM IO
08:03:10 <quicksilver> the cleanest thing, for your users, is to provide instances for IO, STM, and MonadTrans
08:03:25 <quicksilver> that doesn't overlap and covers your standard monad stacks over IO
08:03:27 <quicksilver> I think.
08:03:50 <quicksilver> it does mean that 'newtyped' monad stacks will have to derive your instance 
08:03:50 <joeyh> oh, hmm!
08:04:19 <quicksilver> I am unconfident of my advice here; there might be a well-known better trick not known to me.
08:04:31 <joeyh> thanks, I had not thought of MonadTrans
08:04:59 <joeyh> needing to generalized newtype derive would be ok
08:05:22 <quicksilver> also, that way makes it work in monad stackvs over STM
08:05:31 <quicksilver> which are not exactly common but some people might use them
08:06:20 <quicksilver> do you unsafely sneak your IO actions into STM? or does your IO master thread just politely fetch the region config out of STM before drawing?
08:06:59 <joeyh> the latter.. former would be .. 
08:07:47 <joeyh> I do have a global consoleSize :: TVar, which gives me the heebie-jeebies on its own ;)
08:08:44 <joeyh> let's perform unsafe IO driven by unix signals!
08:09:02 <frerich> joeyh: Hmm that .gif on http://hackage.haskell.org/package/concurrent-output makes me wish I had a use case for it...
08:09:19 <frerich> Maybe progress information for a concurrent web crawler...
08:09:41 * sm too, just looking for an excuse 
08:10:14 <joeyh> it kind of needs a corresponding concurrent-input
08:10:57 <sm> at what point does it make sense to go full-console and use something like vty or brick ?
08:11:47 <joeyh> huh, I had not seen brick
08:11:56 <sm> it's great
08:12:29 <sm> now I'm wondering for what use cases the concurrent-output approach makes more sense
08:13:03 <quicksilver> vty is orthogonal to concurrent-output conceptually I think
08:13:27 <quicksilver> I mean, joeyh could use vty in his implementation if he wanted
08:13:40 <quicksilver> but vty doesn't particularly solve anything concurrent-output tries to solve?
08:13:41 <joeyh> yeah, I used ansi-terminal, for portability, but those are lower-level
08:13:44 <quicksilver> brick, on the other hand
08:13:46 <frerich> sm: Hmm, so brick is like ncurses?
08:14:04 <quicksilver> no, brick is a widget library
08:14:10 <quicksilver> ncurses is just like vty
08:14:33 <sm> sure. I guess you'd prefer c-o eg where you want to control more than just the last line of output, yet not disturb what's already in the console
08:14:49 * quicksilver nods at sm
08:14:59 <sm> plus it's closer to existing line-based output, so presumably easier
08:15:02 <quicksilver> sm: but it would entirely reasonable to give concurrent-output a fullscreen mode too
08:16:23 <sm> frerich: brick is a nice higher-level more declarative ui framework on top of vty
08:17:29 <joeyh> it's analagous to a GUI widget library vs a window manager, I think
08:18:19 <luigy> concurrent-output looks nice to add some eyecandy to stack ala ocaml's opam
08:18:30 <sm> +1
08:19:10 <joeyh> does vty require full screen display?
08:19:22 <merijn> joeyh: That question doesn't make sense
08:19:30 <obadz> if I defined a Monad transformer MyMonadT and a corrsponding monad MyMonad = MyMonadT Identity, do I have to defined Functor/Applicative/Monad twice ?
08:19:32 <sm> currently yes
08:19:36 <merijn> joeyh: You can't have part of a terminal
08:19:49 <joeyh> well, curses can actually use both modes, if I vaguely recall correctly
08:20:06 <merijn> "both modes" <- what's that mean?
08:20:10 <merijn> There is only one mode...
08:20:21 <quicksilver> luigy: what kind of eye candy does opam have
08:20:25 <joeyh> not clearing the screen and just doing relative cursor movements below the start line
08:20:27 <quicksilver> merijn: alternate screen vs not
08:20:30 <quicksilver> I imagine.
08:20:38 <joeyh> er yeah, s/clearing/switching/
08:20:58 <merijn> vty doesn't necessarily clean the terminal either
08:21:25 <quicksilver> obadz: no, normally you just define Monad m => Monad (MyMonadT m)
08:21:29 <quicksilver> obadz: that's just once isn't it?
08:21:48 <quicksilver> MyMonad = MyMonadT Identity is just an instance of that scheme
08:22:08 <obadz> but newtype doesn't keep instances does it?
08:22:44 <merijn> obadz: True, but you have GeneralizedNewtypeDeriving ;)
08:22:54 <obadz> dear god what is this now
08:23:15 <obadz> merijn: I see
08:23:50 <obadz> newtype Xl = XlT Identity deriving (Functor, Applicative, Monad) ?
08:24:12 <merijn> Well that doesn't kindcheck
08:24:37 <obadz> merijn: I need the as ? 
08:24:38 <merijn> But "newtype Xl a = Xl (XlT Identity a)" should work
08:24:51 <obadz> Ah
08:25:31 <merijn> (plus the deriving)
08:25:51 <obadz> and if XlT is itself a Monad transformer stack, I suppose that means I don't need to write the F/A/M instances for it either?
08:25:59 <obadz> using the same technology
08:28:22 <quicksilver> newtype deriving is for when nothing has changed
08:28:34 <quicksilver> that's not actually true of monad tranformers
08:28:46 <quicksilver> when writing StateT you have to give instance Monad m => Monad (StateT s m)
08:28:58 <quicksilver> but that is the only instance - it's only one per class per transformer
08:29:15 <quicksilver> you *don't* have the write the instance for State, because that's just an alias for StateT s Identity, which is already covered by the above.
08:29:50 <obadz> quicksilver: not sure what you mean by nothing has changed
08:30:26 <obadz> quicksilver: if newtype SomeTypeT m a = { getSomeTypeT :: WriterT Int (ReaderT String m) a }
08:30:47 <obadz> quicksilver: I would assume the Monad instance should be automatically derivable from the right hand side's instance?
08:31:38 <obadz> return = SomeTypeT . return and (SomeTypeT v) >>= f = SomeTypeT (v >>= getSomeTypeT . f) ?
08:31:53 <quicksilver> obadz: yes.
08:32:16 <quicksilver> obadz: nothing has changed in the sense that SomeTypeT is exactly the same as WriterT Int ReaderT String
08:34:16 <quicksilver> you should be able to derive Monad, Functor, Applicative, MonadWriter and MonadReader on that
08:34:28 <quicksilver> (btw, WriterT Int? did you define a Monoid for Int?)
08:35:08 <obadz> no assume Strign :)
08:35:15 <Zekka|Sigfig> You might want to use WriterT (Sum Int) or WriterT (Product Int) instead of making Int a monod if you can help it
08:35:30 <obadz> was just an example
08:35:36 <Zekka|Sigfig> OK, sure, I get you then
08:36:46 <quicksilver> c_wraith: ping
08:39:43 <obadz> quicksilver: can't derive MonadTrans? kind issues...
08:39:50 <obadz> quicksilver: the others work
08:40:08 <luigy> quicksilver I like their bottom "processing" progress bar for "opam upgrade"
08:40:14 <luigy> quicksilver here is a video https://cldup.com/geMcExkKge.mp4 
08:41:49 <quicksilver> that is almost exactly like apt-get isn't it?
08:42:00 <quicksilver> which is pretty much what joeyh is shooting for :)
08:42:24 <quicksilver> obadz: might need to derive that in a seperate line
08:42:49 <quicksilver> obadz: deriving instance MonadTrans SomeTypeT
08:43:05 <quicksilver> I'm not sure.
08:47:55 <obadz> instance MonadTrans MyMonadT where lift = lift -- this instance seems valid. how is that possible?
08:48:44 <obadz> I guess I'm leveraging the lift from the transformer stack?
08:49:09 <obadz> but I would have expected having to put my newtype constructor somewhere
08:49:17 <obadz> like lift = MyMonadT . lift
08:52:29 <lyxia> lift = lift is a loop
08:53:03 <lyxia> your last proposition looks more reasonable.
08:53:48 <lyxia> x = x is always going to typecheck but doesn't define anything useful
08:54:29 <lyxia> obadz: it gives you undefined
08:58:52 <c_wraith> quicksilver: pong
08:59:41 <quicksilver> c_wraith: I couldn't get Endo [a] to be faster than [a]
08:59:56 <quicksilver> c_wraith: even with what I thought was a binary recursion pattern which should put massive lists on the left
09:00:54 <quicksilver> c_wraith: see my haskell-cafe post let me know if you can explain it :)
09:07:04 <roelof> anyone who knows how to make this work : testCase "PowerTwo 0 " $ powerTwo 0  @=? "Right 1" ? 
09:11:57 <roelof> anyone here or does freenode has problems again ? 
09:12:33 * liste is here
09:13:05 <roelof> he, the people which are always here, liste 
09:15:00 <jophish> roelof: shouldn't that be Right 1 instead of "Right 1"
09:16:44 <roelof> jophish:  I change it but then I see this error message : http://lpaste.net/144661
09:19:01 <jle`> obadz: lift = lift compiles because lift gives you the correct type. it's like saying foo :: Int -> Bool; foo = foo, which trivially typechecks, because foo is an Int -> Bool, so typechecks as a definition of foo
09:20:42 <Denommus> how to match a block comment in alex?
09:20:48 <Denommus> or do I need a parser for that?
09:21:16 <obadz> jle` / lyxia: thanks
09:21:21 <dolio> Parser, I'd guess.
09:21:28 <roelof> jophish:  any idea ? 
09:21:30 <obadz> I guess I just don't know how to write lift for a trivial transformer stack
09:21:45 <dolio> Although it might depend on whether you want to nest comments.
09:21:51 <jle`> what is a "trivial transformer stack"?
09:22:03 <obadz> newtype MyMonadT m a = MyMonadT { getMyMonadT :: WriterT String (ReaderT Int m) a }
09:22:20 <obadz>     deriving (Functor, Applicative, Monad, MonadReader Int, MonadWriter String)
09:22:28 <lookunder> Having an issue with some FFI. I'm wondering if alloca is the good way of doing it. http://lpaste.net/144662
09:23:25 <jle`> obadz: think about the type signature of each lift you use
09:23:31 <jle`> monomorphically
09:24:23 <lyxia> roelof: can you share your code?
09:24:56 <jle`> obadz: and consider working it out pointfully :)
09:25:18 <obadz> lift :: (Monad m, MonadTrans t) => m a -> t m a => lift :: Monad m => m a -> MyMonadT m a 
09:25:20 <jle`> type holes help too
09:25:26 <obadz> looks a lot like return
09:25:32 <roelof> lyxia: the test code and the TwoPower code ? 
09:25:42 <lyxia> roelof: yeah
09:25:59 <obadz> maybe not
09:26:36 <jophish> roelof: what is the type of powerTwo?
09:27:58 <roelof> lyxia:  jophish  here a paste of both files : http://lpaste.net/144664
09:28:01 <jle`> obadz: the only way to "construct" a MyMonadT is with the MyMonadT constructor, so try this
09:28:12 <jle`> lift x = MyMonadT (_ x)
09:28:16 <Zekka|Sigfig> obadz: It’s something you do after return to return even harder
09:28:20 <jle`> and see what ghc tells you it needs there
09:28:47 <Zekka|Sigfig> jle` may be able to explain better, I’m being cute but I shouldn't
09:30:08 <NightRa> What's the current best tool for writing FFIs?
09:30:11 <lyxia> roelof: Well it's as the error message says, testGroup expects a [TestTree] and you gave it a function.
09:30:25 <jophish> roelof: you shouldn't be passing powerTwo as a test on line 13
09:31:12 <jophish> you probable wanted something like testGroup "tests" [unitTests, qcProps]
09:31:17 <roelof> jophish:  no, how does haskell then now which function to tests 
09:31:23 <NightRa> hsc2hs? some other way?
09:32:08 <jle`> obadz: also, you'll see why `lift` alone doesn't fit there, because it doesn't fit what GHC needs
09:32:13 <jophish> roelof: It's in the definition of unitTests
09:32:14 <jle`> it'll be clear with typed holes :)
09:32:51 <roelof> jophish:  yes, now I see it , I named the tests powertwo and later on I named it maxoccurs. Stupid mistake 
09:33:18 <roelof> The problem was line 14 and not line 13
09:37:13 <jophish> roelof: you might want to use hlint on your code too. 
09:37:16 <jophish> @where hlint
09:37:16 <lambdabot> http://community.haskell.org/~ndm/hlint/
09:37:45 <roelof> jophish:  oke, that is something I use after the code and the tests are working 
09:38:33 * hackagebot HaskellNet 0.5 - Client support for POP3, SMTP, and IMAP  https://hackage.haskell.org/package/HaskellNet-0.5 (JonathanDaugherty)
09:38:51 <roelof> Can I also use hlint on a complete stack project or must I do it file by file ? 
09:43:43 <zzing> I want to count lines in a text file using conduit, the closest that I have been able to figure out is:   runResourceT $ sourceFile f =$= lines $$ foldl (\a _ -> a + 1) 0    But it fails with  No instance for (Num ()) arising from a use of ‘+’    Any ideas on how to fix?
09:44:13 <jophish> roelof: you could always do: find . --type f -iname '*.hs' | xargs hlint -i
09:44:37 <monochrom> @type foldl
09:44:38 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
09:47:56 <zzing> monochrom, wrong foldl
09:48:33 * hackagebot geoip2 0.1.0.3 - Pure haskell interface to MaxMind GeoIP database  https://hackage.haskell.org/package/geoip2-0.1.0.3 (ondrap)
09:49:07 <zzing> foldl :: Monad m => (a -> b -> a) -> a -> Consumer b m a
09:49:51 <fizbin> Does anyone have any advice on how to write an HUnit test with a time limit? I've got a certain corner case input that sends my algorithm into an infinite or at least incredibly long loop, and I'd like to add a test for this case now that I think I have a fix.
09:50:35 <eitan> is there a function in base for n-fold Kleisli composition `Monad m => Int -> (a -> m a) -> a -> m a`?
09:51:32 <monochrom> no. we don't even have n-fold function composition :)
09:53:51 <fizbin> @type \n f -> foldr (>=>) return (replicate n f)
09:53:53 <lambdabot> Monad m => Int -> (c -> m c) -> c -> m c
09:54:04 <fizbin> eitan:  ^^^
09:54:18 <lyxia> zzing: I suspect the problem comes from the context, can you show more code?
09:54:28 <zzing> lyxia, yes, one moment
09:54:54 <Iceland_jack> @type \n f -> foldr (Control.Category..) Control.Category.id (replicate n f)
09:54:55 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k). Category cat => Int -> cat b b -> cat b b
09:55:07 <zzing> lyxia, line 30: https://gist.github.com/madebyjeffrey/208acd56a0de79b3c979
09:55:36 <lyxia> zzing: there you go, processFile should return an Int
09:55:47 <lyxia> zzing: or do something with the line count
09:57:27 <zzing> lyxia, awesome it seems compile now with warnings
09:58:10 <zzing> I just modified it so it prints the line count, and it can read 85k lines in about 4 seconds from a 150mb csv file.
09:58:37 <zzing> I was trying to solve the problem on the line before thinking about the whole thing. So it caused me trouble.
09:59:24 <jophish> fizbin: hunit tests are just IO actions, so you could use any timeout functionality whta works in IO
10:00:04 <jophish> :t timeout
10:00:06 <lambdabot> Not in scope: ‘timeout’
10:00:18 <jophish> https://hackage.haskell.org/package/base-4.8.1.0/docs/System-Timeout.html
10:00:23 <jle`> fizbin: i use iterate and !! sometimes
10:06:04 <benzrf> is turtle the preferred option for doing shell scripty stuff in haskell?
10:06:08 <benzrf> and if so, is there a tutorial or explanation of it that assumes familiarity with haskell?
10:10:15 <ReinH> benzrf: I've used shelly and shell-conduit in the past, but ended up mostly rolling what I needed with the process package.
10:10:30 <benzrf> :I
10:10:55 <ReinH> benzrf: did you try the turtle tutorial?
10:12:26 <ReinH> Last time I did shell scripting in Haskell was befure turtle, but it looks good and it's a Tekmo library so it's probably far from awful.
10:12:32 <ReinH> *before
10:25:00 <camm1> Hello.
10:25:48 <camm1> Can somebody help me with this problem "No instance for (H.ToMarkup a6) arising from a use of ‘H.toHtml’"? I'm just typing H.toHtml "Hello".
10:27:24 <isovector> @camml: maybe you need OverloadedStrings?
10:27:24 <lambdabot> Unknown command, try @list
10:27:29 <isovector> camml: maybe you need OverloadedStrings?
10:28:23 <isovector> camm1: maybe you need OverloadedStrings? (sorry for spam, got your username wrong the first time)
10:29:22 <camm1> Thanks isovector.
10:30:08 <zarathostra> Hey I'm currently working on a functional language compiler and interpreter, I was wondering if there was any functional intermediate language for code generation
10:30:34 <zzing_> zarathostra: there are some on hackage, and there is always Core
10:30:34 <roelof> thanks all. it worked like a charm 
10:31:03 <zarathostra> zzing_: i'll check it out thanks
10:31:29 <zzing_> A question about +RTS -s output: https://gist.github.com/madebyjeffrey/a4f573e53010b77ab032  Did the program in fact only allocate 2mb of ram? Also, did this thing allocate 23gb of heap?
10:33:24 <isovector> I'm trying to get a lens into a Maybe. I have an invariant that it will never be Nothing, so I'm okay with non-total solutions. any ideas?
10:33:44 <shachaf> In that case you can just write the lens.
10:34:01 <isovector> shachaf: not super sure how i'd go about doing that. i'm new to the library
10:34:07 <shachaf> Depending on which lens library you use there might be another way to write it.
10:34:31 <isovector> using `lens`
10:34:54 <roelof> jophish:  hlint found one "problem" in the lib.hs function 
10:34:54 <shachaf> You can write something like singular _Just.
10:35:07 <shachaf> But it's better to not rely on this invariant if you don't have to.
10:35:21 <shachaf> Which you probably don't. I shouldn't even have mentioned this solution.
10:35:51 <dolio> zzing_: It did 23 GB of heap allocations, most of which were probably thrown out very quickly, because only 43MB were copied during GC over the lifetime of the program. And I think the 2 MB is how much memory it was using as far as the OS would be concerned.
10:36:09 <zzing> dolio, okay that makes sense.
10:36:13 <lmj> Functor, Applicative, Foldable, Traversable -- any other instances that a user might expect from a data structure?
10:36:21 <isovector> usage: i have a monad which acts like a restricted state, but unrestricted reader. you give it a lens and it only lets you write through that lens
10:36:24 <zzing> Much better than my previous 900mb
10:36:28 <Darwin226> Hey guys. What's wrong with this? `natVal' (proxy# :: Proxy# n)`. I have a KnownNat n context but I'm getting a kind mismatch on proxy#
10:36:29 <arw> lmj: show?
10:36:50 <lmj> arw: right, forgot to list that
10:36:57 <obadz> jle`: instance MonadTrans MyMonadT where lift = MyMonadT . lift . lift ?
10:37:00 <Darwin226> Couldn't match kind `*' with `Nat' Expected type: Proxy# n0   Actual type: Proxy# n1
10:37:16 <obadz> jle`: typedholes did help
10:38:52 <obadz> jle`: I did think lift would apply to the whole stack but in retrospect that of course does not make sense hence lift . lift for a stack of size 2..
10:44:25 <Darwin226> Why does (Proxy :: Proxy 1) work and (Proxy :: Proxy n) doesn't?
10:44:36 <Darwin226> n is Nat and has a KnownNat contraint
10:45:48 <obadz> looks like DeriveAnyClass and GeneralizedNewtypeDeriving don't play nice together
10:47:44 <Tekkkz> Hello haskell'ers!
10:47:55 <Tekkkz> I have an interesting question
10:48:11 <Tekkkz> is it possible to change the global ip of a computer/network via haskell?
10:49:06 <obadz> Tekkkz: System.Cmd.system "ifconfig eth0 1.2.3.4"
10:49:33 <Tekkkz> what is this?
10:49:45 <obadz> Tekkkz: changes the IP of your computer via haskell..
10:49:55 <Tekkkz> the global or local network ip?
10:50:18 <obadz> Tekkkz: the IP on the eth0 network card. Replace to whatever interface you wish to change.
10:51:04 <ReinH> Tekkkz: how would you change the global IP in any other language?
10:51:48 <Tekkkz> idk
10:51:57 <roelof> Is this a valid eta reduce or can I better ignore this hlint message : http://lpaste.net/144672
10:52:12 <Tekkkz> i need to change my global ip to ignore an ip block system
10:53:02 <Ankhers> roelof: It is a valid eta reduction. But you do not have to do everything hlint suggests. It depends on what you focus on in your own code.
10:54:23 <roelof> Ankhers:  oke, I have had people which I asked for feedback say it is not necesarry eta reduce. That is why I asked 
10:54:45 <Ankhers> It is never necessary. It is just a style choice.
10:55:00 <ReinH> roelof: hlint provides suggestions, not demands.
10:55:08 <obadz> Tekkkz: sorry, this is not really a haskell related question.
10:55:34 <roelof> oke, thanks. 
10:55:57 <Tekkkz> yup you are right
10:56:07 <roelof> ReinH:  I know , but I noticed that the suggestions are better 
10:56:35 <ReinH> That's why they are suggested ;)
10:58:26 <Ankhers> roelof: I just added an annotation. That's how I would write it if I were trying to eta reduce.
10:58:37 <Ankhers> roelof: disregard the first line of the annotation.
10:59:50 <roelof> Ankhers:  and it still works with 4 arguments 
11:00:08 <roelof> that is something I still find wierd in Haskell 
11:00:53 <Ankhers> roelof: It does.
11:01:11 <Ankhers> roelof: Rather, it should. I didn't actually try compiling it.
11:01:40 <roelof> Ankhers:  one question : How would you rewrite this one :maxFour2 a b c  = max (max (max a b) c)
11:01:41 <lmj> Should new packages upon the new Foldable/Traversable in Prelude? I assume this is OK as long as base-4.8 is listed.
11:03:17 <Ankhers> roelof: a `max` b `max` c may be a decent start.
11:03:36 * hackagebot sbp 0.51.2 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.51.2 (markfine)
11:03:51 <Ankhers> @pl a `max` b `max` c
11:03:51 <lambdabot> a `max` b `max` c
11:04:04 <Ankhers> @pl \a b c -> a `max` b `max` c
11:04:04 <lambdabot> (max .) . max
11:04:13 <Ankhers> That is not obvious.
11:04:18 <Ankhers> Do no write that.
11:04:39 <Ankhers> roelof: Are you familiar what infix syntax in Haskell?
11:05:16 <monochrom> lmj: I don't think one blanket answer fits all. some code is agnostic to Foldable/Traversable vs [], even without conditional compilation. then it should not care.  some other code needs Foldable-Traversable, then if you don't want to add conditional compilation, then you can insist on base-4.8
11:05:33 <roelof> Ankhers:  I would not do that.I do not find that readable 
11:05:51 <roelof> Ankhers:  it is mentioned in the Craft book 
11:06:03 <Ankhers> roelof: I'm assuming you mean the `(max .) . max' version?
11:06:33 <roelof> Ankhers:  yep, that one 
11:06:53 <Ankhers> Yeah. That is not a good way to write that function. I was just wondering if there was a decent way to write it.
11:07:19 <Taneb> :t \a b c -> maximum [a,b,c]
11:07:21 <lambdabot> Ord a => a -> a -> a -> a
11:07:50 <jophish> you'll like this one Ankhers:
11:07:53 <jophish> @pl \a b c -> maximum [a,b,c]
11:07:53 <lambdabot> ((maximum .) .) . (. ((. return) . (:))) . (.) . (:)
11:07:56 <monochrom> Taneb, they eta-reduced one last argument away. so it is really \a b c d -> maximum [a,b,c,d]
11:08:19 <Ankhers> jophish: That is so beautiful it brings a tear to my eyes :'(
11:08:22 <roelof> a `max` b . I do understand. But I used to first use the functionname and then the arguments 
11:08:23 <Ankhers> :') rather
11:08:46 <jophish> Ankhers: I'd stick with :'(
11:08:51 <Ankhers> lol
11:08:55 <monochrom> roelof: are you also used to "(+) a b"?
11:09:09 <roelof> monochrom:  no, then not 
11:09:27 <roelof> but with max I always write max a b 
11:10:35 <roelof> Another question : Is there some piece of code which makes my code nice to see. I know stylish-haskell but that one does not change everything 
11:10:46 <jophish> roelof: you could try hindent
11:11:05 <monochrom> then you have an artificial, arbitrary distinction "alphabetical things count as function names, punctuation things don't". I am pointing out a cognitive dissonance in your mind.
11:11:59 <denzz> Hello everyone
11:12:12 <denzz> I’m a new haskeller, going through “Haskell Programming from first principles” , and I’m stuck at an exercise in Chapter 5 (Types)
11:12:30 <roelof> monochrom:  thats a lot of difficult words in a sentence 
11:12:31 <denzz> wondering if anyone would be kind enough to help me a bit
11:12:32 <Ankhers> Has anyone seen the "An apology to the functional programming community" article?
11:12:55 <Ankhers> denzz: Feel free to just ask your question.
11:12:55 <denzz> I am shown a type and I need to write a function “co” that corresponds to this function
11:13:04 <denzz> here's the type of the function:
11:13:05 <denzz> co :: (b -> c) -> (a -> b) -> (a -> c)
11:13:20 <denzz> from this I can guess that “co” is a combinator that accepts two function as arguments, and returns another function
11:13:42 <mindphaze> looks like .
11:13:44 <Ankhers> denzz: Have you seen that signature before?
11:13:47 <Ankhers> :t (.)
11:13:48 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:14:04 <denzz> no, I have not
11:14:12 <denzz> oh, wow
11:14:14 <Ankhers> denzz: It does exactly what you said.
11:14:22 <denzz> that's exactly this
11:14:32 <Ankhers> denzz: Though, for the sake of exercise. Lets pretend (.) does not exist.
11:14:39 <denzz> well, I don't know how the authors would expect me to know this
11:14:41 <monochrom> instead, I follow Dijkstra's criterion on which functions should enjoy the infix notation, which should not.
11:15:03 <Ankhers> denzz: I don't think they did. They may introduce it shortly after you write this.
11:15:10 <denzz> yes, okay
11:15:11 <monochrom> the criterion is not based on whether the name consists of letters or punctuation. (clearly, that can be trivially changed.)
11:15:18 <denzz> I could try to reimplement it on my own
11:15:37 <roelof> josephle:  oke, looks interessting. I only have to choose a style 
11:15:38 <Ankhers> denzz: Do you have any specific questions about how to implement it?
11:15:45 <Taneb> denzz: how many arguments should co have?
11:15:46 <monochrom> the criterion is based on whether the function is a 2-ary associative function
11:16:00 <kadoban> denzz: You should probably try to implement it manually, it should be a good exercise.
11:16:48 <denzz> I'm going to try it now, if I have any questions I go back to you (tough it's not precisely clear to me how to proceed for now)
11:16:48 <aweinstock> :t (\f g -> _)
11:16:49 <lambdabot>     Found hole ‘_’ with type: t
11:16:50 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
11:16:50 <lambdabot>                the inferred type of it :: r -> r1 -> t at <interactive>:1:1
11:17:24 <monochrom> for example, + is associative, (plus (plus 1 2) 3) = (plus 1 (plus 2 3)). now you look at that prefix equation and you see it is obfuscation. (1+2)+3 = 1+(2+3) makes the point so much better, and gives you license to write 1+2+3
11:17:36 <Ankhers> denzz: How many arguments does co expect to have?
11:17:48 <monochrom> max is also associative. that justifies writing 1 `max` 2 `max` 3.
11:17:52 <roelof> jophish:  I think I like the chrisdone style 
11:18:03 <aweinstock> monochrom: do you have a link to a Dijkstra paper?
11:18:15 <denzz> Ankhers: I'd say two
11:18:24 <lmj> monochrom: how could code be agnostic to foldr without conditional compilation? Either it comes from Prelude or Data.Foldable.
11:18:30 <Ankhers> denzz: Sounds good to me. co f g = ?
11:18:51 <denzz> co f g = g f
11:18:51 <denzz> ?
11:18:52 <monochrom> yeah, http://www.cs.utexas.edu/users/EWD/transcriptions/EWD13xx/EWD1300.html or http://www.cs.utexas.edu/users/EWD/ewd13xx/EWD1300.PDF
11:19:11 <Ankhers> denzz: Try it. See if it works with the type of the function.
11:19:16 <aweinstock> co (f :: b -> c) (g :: a -> b) = something :: a -> c
11:20:19 <monochrom> lmj: suppose my code is simply "main = print (foldr (+) 0 [1,2,3])". then it is an example of being agnostic. it builds fine against both 4.7 and 4.8. hell, not only that, but also its semantics stays the same.
11:20:26 <aweinstock> lmj: if you use foldr as if it had the list type, that also works for the foldable case
11:20:29 <denzz> Ankhers: no: “Couldn't match expected type ‘a -> c’ with actual type ‘c’”
11:20:51 <monochrom> there is a lot of code similarly agnostic like this. there is more than you think.
11:21:04 <Ankhers> denzz: Do you understand that error?
11:21:45 <denzz> well, yes, the arguments needs to be of the function type
11:22:26 <Ankhers> denzz: Good. Do you have any ideas on how to fix that?
11:23:34 <denzz> I didn't know how to enforce that, but I guess aweinstock just showed me
11:24:02 <mszepien> hello all, for anyone with experience using the accelerate library, I've asked a question on stackoverflow, but I thought I'd ask around here as well, hope that's ok... http://stackoverflow.com/questions/33552666/look-up-table-in-haskell-accelerate
11:24:06 <mszepien> any help appreciated
11:24:42 <aweinstock> :t (\x -> x)
11:24:43 <lambdabot> r -> r
11:25:14 <lmj> right, I had in mind calling foldr on a non-list. If that is the case then one must choose between requiring base-4.8 or conditional compilation, otherwise there will be breakage, unless I'm missing something.
11:25:27 <Ankhers> denzz: Are you familiar with lambdas?
11:26:35 <monochrom> I wonder if "import Prelude hiding (foldr); import Data.Foldable" saves you from conditional compilation
11:26:57 <aweinstock> denzz: since the return value of co needs to have type (a -> c), start with (\x -> _), and fill in the blank with something that should have type c, if x has type a
11:27:44 <aweinstock> denzz: (\x -> y) can be considered shorthand for (let f x = y in f)
11:28:17 <denzz> Ankhers: I need to make sure the args applied to ‘co’ are functions
11:28:17 <denzz> I'm lagging, sorry
11:28:53 <monochrom> yes, it works
11:29:28 <denzz> I can't say I’m really familiar, but I've seen a bit their syntax and how they works
11:30:09 <denzz> aweinstock: thanks – I've not come across 'in' yet
11:30:09 <lmj> monochrom: yeah I was checking that concurrently with you. There will be an eternal warning on newer systems, though, so not ideal.
11:30:20 <lpaste_> monochrom pasted “both base 4.7 and 4.8, no conditional compilation” at http://lpaste.net/144675
11:31:22 <denzz> aweinstock: ahhh, nevermind
11:31:29 <denzz> aweinstock: just understood what you wrote
11:31:41 <aweinstock> denzz: 'in' isn't a construct by itself, the full thing is (let SOME_PATTERN = SOME_EXPRESSION in SOME_OTHER_EXPRESSION)
11:31:42 <zzing> mszepien, have you looked at the lifting operation?  I don't know anything about the accelerate package, but I noticed it does have lifting.
11:32:10 <monochrom> yeah I don't know how to kill the eternal warning. I may fork GHC.
11:33:24 <lmj> ghc-no-eternals Setup.hs
11:34:00 <monochrom> it is ok to make a judgment call "my code looks better if I tailor it for base > 4.8 so I will insist it"
11:34:49 <lmj> >= 4.8, right?
11:34:56 <monochrom> oops, yeah
11:35:02 <dolio> If you insist on supporting N versions back, certainly you will never benefit from any improvements over the last N versions.
11:38:02 <lmj> It looks like most .cabal files list base < 5. Standard/recommended practice?
11:38:45 <c_wraith> lmj: I doubt most do that, since it's totally broken. 
11:39:11 <dolio> In some sense it doesn't matter what you put for bounds on base.
11:39:50 <dolio> Because you cannot install a new version of base to satisfy a dependency that rejects the one you have installed.
11:40:15 <dolio> But you will get an earlier failure if you specify tight versions.
11:40:48 <mszepien> zzing: I have tried eg to lift a list, but I'm still learning haskell and don't understand what lifting is and why it could be useful here.. anything I've tried has failed to compile
11:41:26 <lmj> c_wraith: I checked again and they really have it, even parsec
11:41:27 <dolio> It will tell you that it is impossible to build your package with the version of GHC you have, rather than failing with a compile error later.
11:42:16 <c_wraith> lmj: parsec is not an example of a well maintained package. 
11:42:19 <lmj> and QuickCheck
11:42:59 <lmj> it's hard to find one that doesn't do it
11:49:08 <lmj> Does this function have a name? f (x, y) = do x' <- x ; y' <- y ; return (x', y')
11:49:55 <dolio> uncurry (liftA2 (,))
11:55:52 <caconym> anyone know of any good resources and/or tools to assist in generating standalone .deb packaged executables from cabal packages?
11:56:12 <dcoutts> caconym: I think there's a cabal2deb program
11:56:18 <Clint> cabal-debian
11:56:36 <dcoutts> oh, I've probably got the name wrong
11:57:05 <caconym> cabal-debian looks potentially very helpful, i will start there
11:57:21 <caconym> thanks much
12:02:18 <lmj> dolio: thanks, I thought "undistributing" an applicative might be common enough to have a name, but lift is short enough already
12:07:44 <denzz> Ankhers: aweinstock: I think I got it
12:07:46 <denzz> let co :: (b -> c) -> (a -> b) -> (a -> c); co = (\x y z -> x (y z))
12:08:05 <Ankhers> denzz: nice. Does that work the way you expect it to?
12:08:28 <Ankhers> denzz: Though, you do not need all arguments within the lambda. But that is just style.
12:09:48 <denzz> yes, it seems to work
12:09:50 <denzz> co (+2) (*3)
12:09:51 <denzz> 20
12:09:56 <denzz> sorry
12:09:59 <denzz> co (+2) (*3) 6
12:10:08 <denzz> => 20
12:10:18 <denzz> ok, noted for the lambda and ards
12:10:27 <denzz> args*
12:10:32 <denzz> thanks for your help
12:12:31 <denzz> so in the end it's the type for function composition, just what (.) does
12:14:09 <aweinstock> @src (.)
12:14:09 <lambdabot> (f . g) x = f (g x)
12:14:19 <prsteele> Hello everyone. How do you handle non-total functions that are guaranteed to not error out? For example, let's say I have f :: a -> Maybe b, but in some instances I can prove that we won't get Nothing as a result. Do I just pattern match against Just, and have an incomplete pattern? Or put error in the Nothing case?
12:14:54 <aweinstock> :t fromJust
12:14:55 <lambdabot> Maybe a -> a
12:15:30 <denzz> lambdabot rocks
12:15:33 <denzz> is there a way to look for the source of a function by its name like this in ghci?
12:15:46 <aweinstock> :t fromMaybe (error "Reason why you expect it to not return Nothing") -- prsteele 
12:15:46 <prsteele> aweinstock: I'm aware of the existence of fromJust, and it is probably what I'll use. I'm more asking about the general pattern. Essentially, what do we do when we have a paper proof that we can't express with the type sytem?
12:15:47 <lambdabot> Maybe a -> a
12:16:36 <aweinstock> denzz: lambdabot's @src thingy is some custom database, and I think it might be out-of-date for some functions (not sure which)
12:16:48 <prsteele> so basically use error, and just leave commentary. I can live with that, I guess
12:17:23 <aweinstock> prsteele: the advantage of (fromMaybe . error) is that when it blows up at runtime, the reasoning is there, and it'll take less time to debug
12:17:36 <aweinstock> (hopefully)
12:17:46 <emmanuel_erc> hiya!
12:17:54 <prsteele> yup. Thanks!
12:17:56 <S11001001> fromMaybe (error "this cannot happen")
12:18:40 * hackagebot SFML 2.3.2.1 - SFML bindings  https://hackage.haskell.org/package/SFML-2.3.2.1 (sulami)
12:18:42 * hackagebot concurrent-output 1.6.0 - Ungarble output from several threads  https://hackage.haskell.org/package/concurrent-output-1.6.0 (JoeyHess)
12:18:55 <aweinstock> prsteele: is there a way to implement it without using Maybe? (i.e. to rework the program to prove to the compiler that you're right?)
12:19:25 <aweinstock> btw, I just read through this paper, and found it interesting: http://research.microsoft.com/en-us/um/people/simonpj/Papers/financial-contracts/contracts-icfp.pdf
12:19:56 <prsteele> aweinstock: it's actually much more superficial in my case. I have a constructor :: a -> Maybe b, where Nothing happens when a <= 0 || 1 < a. I want to call that constructor with a hard-coded value of 0.5... so I'll never get Nothing
12:20:06 <denzz> aweinstock: okay, thanks
12:20:44 <prsteele> so yes, I could definitely re-write it in this case, but I was just interested in seeing how people handle it in general
12:21:18 <aweinstock> prsteele: use template haskell to call the constructor at compile-time? (probably overkill relative to (fromMaybe (error "literal should be in range")))
12:22:46 <prsteele> that's a possibility.
12:28:51 <xivix> hey, i've got a bit of a complicated question for you Haskell/functional programming experts
12:28:52 <xivix> https://dpaste.de/2b2r
12:29:02 <denzz> Ankhers: you said “you do not need all arguments within the lambda”, but I’m not sure how I can actually do otherwise, actually
12:29:24 <xivix> i've written this function in JavaScript. Given a list of arrays, it returns a list of values that all arrays have in common
12:30:01 <denzz> I know I can write 3 nested lambdas that each have one argument apiece, to do the currying manually, but I don't know how to extract the args from the lambdas
12:30:08 <xivix> the approach I've taken is to step through the smallest array value-by-value, and make sure each other array has that value
12:30:43 <aweinstock> denzz: (f x y = z), (f x = \y -> z), and (f = \x y -> z) are all the same thing
12:30:45 <xivix> i believe that approach is possible to do efficiently in a purely functional language like Haskell, but I don't know where to start. can anyone give me a hand?
12:32:01 <akegalj> what is the maximum number of users in this channel?
12:32:09 <akegalj> of all time
12:32:11 <aweinstock> xivix: the input is assumed to be sorted?
12:32:43 <denzz> aweinstock: thanks. I'm going to try to rewrite my function with the arguments out of the lambdas
12:33:08 <akegalj> I can't remember seeing this much lately (few years)
12:33:16 <xivix> aweinstock, yes, the array is sorted by sub-array length, and each sub-array is sorted as well
12:33:40 <denzz> aweinstock: I guess that would be let co :: (b -> c) -> (a -> b) -> (a -> c); co x y = (\z -> x (y z))
12:34:34 <aweinstock> :t let f [] = []; f (x:xs) = all (map (`elem` x)) xs in f
12:34:34 <prsteele> xivix: maybe start with f :: (Eq a) => [a] -> [a] -> [a]
12:34:35 <lambdabot>     Couldn't match expected type ‘[t1]’ with actual type ‘Bool’
12:34:36 <lambdabot>     Relevant bindings include
12:34:36 <lambdabot>       f :: [[a1]] -> [t1] (bound at <interactive>:1:5)
12:35:01 <prsteele> xivix: then... foldr1 f yourArrays ?
12:35:13 <aweinstock> :t let f [] = []; f (x:xs) = all (all (`elem` x)) xs in f
12:35:14 <lambdabot>     Couldn't match expected type ‘[t2]’ with actual type ‘Bool’
12:35:15 <lambdabot>     Relevant bindings include
12:35:15 <lambdabot>       f :: [t3 a1] -> [t2] (bound at <interactive>:1:5)
12:35:40 <aweinstock> :t let f [] = []; f (x:xs) = all (all (x `elem`)) xs in f
12:35:42 <lambdabot>     Couldn't match expected type ‘[t2]’ with actual type ‘Bool’
12:35:42 <lambdabot>     Relevant bindings include
12:35:42 <lambdabot>       f :: [a1] -> [t2] (bound at <interactive>:1:5)
12:35:44 <prsteele> xivix: might want foldl1, actually
12:35:56 <lyxia> :t intersect
12:35:58 <lambdabot> Eq a => [a] -> [a] -> [a]
12:36:17 <xivix> aweinstock, would that still be O(n)?
12:36:20 <aweinstock> :t all -- prsteele
12:36:21 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
12:36:31 <lyxia> > foldl1 intersect [[1..100], [2,4..100], [3,6..100], [5,10..100]]
12:36:33 <lambdabot>  [30,60,90]
12:37:18 <aweinstock> xivix: I'd need to come up with working code before analyzing it's speed
12:37:43 <aweinstock> it looks like lyxia already found the solution as a standard library function
12:37:53 <prsteele> well interesect works, but it probably doesn't assume sorted lists
12:37:56 <lyxia> it's going to be slow though
12:38:00 <lyxia> yeah
12:38:01 <prsteele> so you could specialize it to abuse sorted
12:38:10 <prsteele> intersect is n^2
12:38:24 <aweinstock> > all (`elem` [1,2,3]) [1..10]
12:38:25 <prsteele> with sorted lists, should be O(n)
12:38:26 <lambdabot>  False
12:38:41 * hackagebot fn 0.0.0.0 - A functional web framework.  https://hackage.haskell.org/package/fn-0.0.0.0 (DanielPatterson)
12:38:42 <aweinstock> > filter (`elem` [1,2,3]) [1..10]
12:38:44 <lambdabot>  [1,2,3]
12:39:08 <aweinstock> :t \x y -> filter (`elem` x) y
12:39:09 <Zemyla> If a functor is representable, then (a <$ f) = pure a for all a, right?
12:39:09 <lambdabot> (Eq a, Foldable t) => t a -> [a] -> [a]
12:39:18 <Zemyla> All a and all f?
12:39:31 <aweinstock> :t foldl1 (\x y -> filter (`elem` x) y)
12:39:32 <lambdabot> (Eq a, Foldable t) => t [a] -> [a]
12:39:33 <prsteele> foldl1 specializedIntersect yourArrays -- O(n m), n == number arrays, m == length of arrays, I think
12:39:42 <Guest88528> Anybody know how to compose a list of traversals? Say if I had basically :: [Traversal' a b] -> Traversal' a b
12:39:45 <Guest88528> using lens
12:40:24 <james_rth> desperately trying to figure out how to traverse into nested objects in lens-aeson, using "key"
12:40:33 <aweinstock> :t foldl1 (\x y -> filter (`elem` x) y) -- xivix: this should be O(n^2), but you can just replace `elem` with a specialized function that exploit sorting to make it O(n)
12:40:35 <lambdabot> (Eq a, Foldable t) => t [a] -> [a]
12:40:56 <heartvs> Does anyone know a short/simple way of checking if a number is between two variables? I've tried inRange, but it sometimes doesn't work as it can only take a range where the first variable is smaller than the second
12:41:08 <james_rth> say if I had {"a":{"b":"foo"}}
12:41:34 <james_rth> and I wanted ["a", "b"] -> to build the composed Traversal
12:41:43 <prsteele> f x a b = (min a b) <= x && x <= (max a b) -- ?
12:41:51 <james_rth> normally I can just (key "a" . key "b")
12:42:16 <james_rth> but I can't just foldl1 (.) [key "a", key "b"]
12:42:22 <lyxia> O(total number of elements) with every comparison discarding one element.
12:43:41 <aweinstock> :t foldl1 (.)
12:43:42 <lambdabot> Foldable t => t (b -> b) -> b -> b
12:44:08 <aweinstock> james_rth: the functions in the list have to have the same type (have to be endomorphisms)
12:44:51 <james_rth> aweinstock, any ideas how to build out similar behaviour
12:45:01 <james_rth> using other combinators?
12:47:26 <aweinstock> james_rth: what's the type of (key "foo")?
12:47:55 <james_rth> (Applicative f, AsValue t) => (Value -> f Value) -> t -> f t
12:48:05 <james_rth> Traversal' t Value
12:48:44 <james_rth> https://hackage.haskell.org/package/lens-aeson-1.0.0.5/docs/Data-Aeson-Lens.html#v:key
12:50:00 <aweinstock> james_rth: does (key "foo" :: Traversal' Value Value) typecheck?
12:50:39 <james_rth> yep
12:51:06 <james_rth> comes out as :: Applicative f => (Value -> f Value) -> Value -> f Value
12:51:43 <lyxia> so you can (.) this
12:51:45 <aweinstock> if you add more type annotations to the (foldl1 (.)) thing, does it give you a different error than you've previously gotten?
12:51:49 <lamefun> Is there a library that handles integer overflows?
12:51:53 <Jello_Raptor> Hmm, how do I express a functional dependency with a forall? http://lpaste.net/144678 (or is the t -> m dependency I'm using there over-constraining things?) 
12:52:01 <Jello_Raptor> err oops
12:52:11 <aweinstock> lamefun: Integer is arbitrary-precision (Int is bounded, like C's Int)
12:52:39 <Jello_Raptor> http://lpaste.net/144679 <- same example without the obvious error. 
12:52:44 <james_rth> how else to annotate?
12:52:49 <aweinstock> lamefun: Data.Word gives you size-delimited unsigned wraparound values (e.g. Data.Word.Word8 is unsigned char)
12:52:54 <james_rth> in a compiled fn?
12:53:32 <aweinstock> james_rth: foldl1 (.) [key "a" :: Traversal' Value Value, key "b" :: Traversal' Value Value]
12:53:41 <james_rth> ahh
12:53:44 <james_rth> let me check
12:54:16 <lyxia> Jello_Raptor: [a] does not determine m indeed
12:54:35 <james_rth> aweinstock - yeah that works
12:54:39 <james_rth> :-(
12:54:41 <lamefun> aweinstock, I mean as in:
12:54:42 <lamefun> > fromIntegral 10000 :: Word8
12:54:44 <lambdabot>  16
12:55:06 <lamefun> Are there equivalent functions that throw error / Nothing in case of overflow?
12:55:10 <Jello_Raptor> lyxia: right, it can constrain M though. There could be unfolds that need a MonadIO 
12:55:33 <Jello_Raptor> lyxia: should I just be using a Constraint Kind there? 
12:55:44 <bennofs> > toEnum 10000 :: Word8
12:55:46 <lambdabot>  *Exception: Enum.toEnum{Word8}: tag (10000) is outside of bounds (0,255)
12:56:18 <lyxia> Jello_Raptor: Well if in some cases you need MonadIO then put the constraint in the instance definition
12:57:00 <lyxia> Jello_Raptor: But that doesn't really constrain the "shape" of the type m, which is what fundeps do.
12:57:27 <aweinstock> lamefun: possibly something involving this? http://hackage.haskell.org/package/integer-gmp-1.0.0.0/docs/GHC-Integer-GMP-Internals.html#t:Integer
12:57:45 <sena-kun> Hi folks. I want to learn a bit more about practical using of lenses and stuck a little. This is a case where I stucked: for example, I have some impure function like (a -> m a) and I want to do mapM over some list with it. Of course, "over" from lens don't work, because it has type (a -> b) -> s -> t, not (a -> m b) -> s -> t. It's pretty obvious, why this doesn't work, but I can't solve it. What can I 
12:57:51 <sena-kun> do? Can I somehow replace mapM(and extracting/packing of values from complex type) with something from lenses or will be better to leave mapM code with extracting/packing alone? http://pastie.org/10532825 - here is an example of what I meant.
12:58:26 <Jello_Raptor> lyxia: mhmm
12:59:12 <james_rth> sucks that this won't compile
12:59:17 <james_rth> is it a bug?
13:00:17 <lyxia> james_rth: what is?
13:00:35 <aweinstock> :t Control.Lens.Traversal.mapM
13:00:40 <lambdabot>     Not in scope: ‘Control.Lens.Traversal.mapM’
13:00:41 <lambdabot>     Perhaps you meant one of these:
13:00:41 <lambdabot>       data constructor ‘Control.Lens.Traversal’ (imported from Control.Lens),
13:00:56 <aweinstock> :t Control.Lens.mapM
13:00:58 <lambdabot>     Not in scope: ‘Control.Lens.mapM’
13:00:58 <lambdabot>     Perhaps you meant one of these:
13:00:58 <lambdabot>       ‘Control.Lens.imapM’ (imported from Control.Lens),
13:01:21 <aweinstock> :t Control.Lens.mapMOf
13:01:22 <lambdabot> Profunctor p => Over p (WrappedMonad m) s t a b -> p a (m b) -> s -> m t
13:01:56 <aweinstock> sena-kun: does mapMOf do the right thing?
13:02:16 <sena-kun> aweinstock: I'll try it now, thanks.
13:03:13 <sena-kun> aweinstock: it works like charm. Thanks, you are a lifesaver!
13:05:32 <Zakkor> heyo, i was going through LYAH when i stumbled upon some confusing syntax. (a, b, c) = (1, 2, 3)    Does this have anything to do with tuples? Or is it just a way to define multiple variables at once?
13:05:43 <arkeet> those are tuples.
13:05:56 <arkeet> (a,b,c) is a pattern matching a 3-tuple
13:05:58 <arkeet> (1,2,3) is a 3-tuple
13:06:09 <bernalex> both really
13:06:18 <arkeet> well, (a,b,c) is a pattern and (1,2,3) is an expression.
13:06:19 <arkeet> but yes they are tuples.
13:06:23 <bernalex> @let (a, b, c) = (1, 2, 3)
13:06:25 <lambdabot>  Defined.
13:06:29 <bernalex> > b
13:06:31 <lambdabot>      Ambiguous occurrence ‘b’
13:06:31 <lambdabot>      It could refer to either ‘L.b’,
13:06:31 <lambdabot>                               defined at /tmp/mueval14693480941956297539.hs:1...
13:06:32 <bernalex> > L.b
13:06:34 <lambdabot>  2
13:06:50 <arkeet> @let [xa,xb,xc] = [1,2,3] -- not limited to tuples 
13:06:52 <lambdabot>  Defined.
13:06:52 <arkeet> > xc
13:06:54 <lambdabot>  3
13:06:56 <bernalex> true
13:07:13 <Zakkor> i see, so it's just pattern matching, thanks!
13:08:17 <aweinstock> > runState $ do { (x:y:xs) <- replicateM 3 (modify (+1) >> get); return (x:xs) }
13:08:19 <lambdabot>  <Integer -> ([Integer],Integer)>
13:08:40 <aweinstock> > flip runState 0 $ do { (x:y:xs) <- replicateM 3 (modify (+1) >> get); return (x:xs) }
13:08:42 <lambdabot>  ([1,3],3)
13:08:42 * hackagebot brick 0.2.2 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.2.2 (JonathanDaugherty)
13:11:29 <xivix> aweinstock, lyxia, prsteele : I wrote it. Seems to work as long as the first array is the shortest. https://dpaste.de/YLtW
13:11:29 <padre_angolano> really dumb question. if I type (+ 10) in ghci, I get an error about "No instance for (Show (a0 -> a0))", which is pretty clear, but the second error is "No instance for (Num a0) arising from a use of `+'". Why is that? 
13:11:45 <xivix> can you guys help me make that code more idiomatic?
13:12:09 <lyxia> xivix: Ord a, Eq a is just Ord a
13:12:13 <padre_angolano> the second error is nonsensical
13:12:14 <arkeet> padre_angolano: what second error?
13:12:18 <arkeet> I just get one.
13:12:41 <Hijiri> maybe xivix has defaulting off for some reason
13:12:48 <padre_angolano> arkeet: probably it's a bug in my version of ghc: http://lpaste.net/144682
13:12:53 <Hijiri> oh
13:12:55 <Hijiri> not xivix
13:12:57 <Hijiri> I'm dumb
13:13:19 <arkeet> oh, you wrote show (+ 10)
13:13:30 <padre_angolano> arkeet: it's the same without 'show'
13:13:39 <arkeet> I only get it with show.
13:13:41 <arkeet> but anyway.
13:13:43 * hackagebot exact-pi 0.4.0.0 - Exact rational multiples of pi (and integer powers of pi)  https://hackage.haskell.org/package/exact-pi-0.4.0.0 (dmcclean)
13:14:24 <arkeet> it's not a dumb question btw :)
13:14:58 <padre_angolano> arkeet: well, it must be something really trivial but I don't get it :-)
13:15:30 <james_rth> aweinstock - I'll try mapMOf
13:15:32 <arkeet> I guess it's just complaining that it doesn't know how to pick a type for 10.
13:15:53 <arkeet> which doesn't really matter since the whole thing isn't well typed.
13:16:17 <arkeet> interesting that I only see it with show, though.
13:16:47 <Shockk> I'd guess that it's because 10 is of type a constrained by Num a, and not a specific type, and it doesn't infer a default type or something because it's of type (a -> a), but I don't know
13:16:49 <padre_angolano> arkeet: if we do 'let f = (+ 10)', it perfectly knows hot to pick a type for 10 :-)
13:17:11 <arkeet> oh, that's the monomorphism restriction.
13:17:17 <Shockk> :q
13:17:18 <arkeet> which I turn off by default in my ghci
13:17:18 <Shockk> oops
13:17:22 <aweinstock> xivix: replace (== []) with (null) (it's more general, and possibly more efficient)
13:17:48 <Hijiri> :t null
13:17:50 <lambdabot> Foldable t => t a -> Bool
13:18:37 <aweinstock> james_rth: I was suggesting mapMOf to someone who asked a different question, I don't expect it to be relevant to the one you asked (but it might be)
13:18:45 <james_rth> oh
13:18:49 <james_rth> sorry
13:18:52 <padre_angolano> arkeet: another example with the same error: data A a = A [a], then show (A [10]). two errors instead of one
13:19:23 <padre_angolano> arkeet: once we do data A a = A [a] deriving Show, the Num error magically goes away together with the Show error
13:21:56 <lyxia> xivix: elemSorted does two things and I think you can split them for better readability: it removes elements which have no more hope of being in the final intersection (being less than e), and it checks that e is in the list.
13:22:40 <xivix> lyxia, how do I separate them while still doing both at the same time
13:22:58 <xivix> (to avoid unnecessary calculations)
13:23:22 <lyxia> xivix: first you get rid of elements < e: let xs' = dropWhile (< e) xs
13:23:44 <xivix> of course
13:23:49 <xivix> i'm dumb
13:24:20 <lyxia> xivix: Then you check that e is in the list: match xs' with x : xs'' | x == e -> (True, xs'') ; _ -> (False, xs')
13:25:52 <lpaste_> prsteele pasted “xivix” at http://lpaste.net/144683
13:26:01 <prsteele> xivix: ?
13:26:19 <lyxia> xivix: Also commonToAll is just looping through the first list, while updating all the others, that's expressed more functionally with a fold.
13:27:16 <xivix> lyxia, yeah i couldn't figure out how to turn it into a fold
13:27:48 <lpaste_> prsteele revised “xivix”: “xivix” at http://lpaste.net/144683
13:28:08 <lyxia> xivix: so there's the edge case of commonToAll [] = [] which I'd leave
13:31:20 <james_rth> aweinstock - figured it out
13:31:41 <lyxia> xivix: and the other cases would look better with an auxiliary function  commonToAll' xs yss
13:32:12 <james_rth> got a kind sig and rankN type to specify the constraints :: forall (f :: * -> *) . Applicative f => [Text] ->  ((Value -> f Value) -> Value -> f Value)
13:32:33 <james_rth> type checks ok now
13:32:41 <james_rth> works a treat! thanks a lot for your help
13:32:45 <lyxia> xivix: it has one less superflous constructor to construct/destruct repeatedly.
13:32:51 <xivix> prsteele, nice, but wouldn't that be potentially O(n^2) still? for example, if all the arrays are all equal, won't it check against each value more often than needed?
13:33:14 <xivix> lyxia, yeah I probably should have done that, since I'm consistently treating the first array differently
13:33:42 <lyxia> xivix: Exactly.
13:34:24 <lyxia> xivix: In the end I think factoring this as a fold may be taking it too far.
13:34:46 <xivix> lyxia, for the reason I mentioned to prsteele?
13:34:59 <prsteele> xivix: we iterate over each array once, checking each element once. We iterate over the accumulated list many times, but each time we do so we are iterating over another list, and so can credit those operations to that list. Thus there are only a constant number of operations applied to each element of each list
13:35:15 <prsteele> xivix: if you have n lists with O(m) elements, this is O(n m)
13:35:18 <lyxia> xivix: which?
13:35:26 <xivix> prsteele, but what if each list is [1..10000]
13:35:28 <xivix> for instance
13:35:43 <xivix> perhaps I'm thinking about this wrong
13:36:03 <prsteele> xivix: call m = 10000. Then there are O(n m) operations, where n is the number of such lists
13:36:08 <lyxia> prsteele: I'd just say it's O(total number of elements) which doesn't lose precision.
13:36:17 <orion> Is there a sugar function to eliminate: _ <- foo; return () ?
13:36:19 <prsteele> lyxia: that is correct.
13:36:50 <lyxia> :t void -- orion 
13:36:52 <lambdabot> Functor f => f a -> f ()
13:36:58 <orion> Ah yes! Thank you
13:38:40 <emmanuel_erc> hey there #haskell!
13:38:45 <lyxia> xivix: I can't find the reason you mentioned.
13:38:59 <prsteele> hello emmanuel_erc 
13:39:07 <lyxia> xivix: But your algorithm is different from the one we came up with earlier.
13:39:32 <emmanuel_erc> I wasn't a computer science student during undergrad, and I a little confused about how the garbarge collection data GHC's RTS collects.
13:40:09 <emmanuel_erc> Was does it mean when it reports back  how many bytes were collected during Generation 0 and Generation 1?
13:40:13 <emmanuel_erc> Hi hteer prsteele!
13:40:23 <emmanuel_erc> there*
13:40:27 <lyxia> xivix: anyway, I think the outermost "if" construct is also superfluous.
13:40:50 <lyxia> xivix: And you've got some repetition which would be better bound to a single variable.
13:41:05 <xivix> lyxia, what repetition?
13:41:07 <xivix> lyxia, what repetition?
13:41:16 <lyxia> lol
13:41:22 <lyxia> xivix: lines 19-20
13:41:25 <drostie> How does Haskell's parser know that a list comprehension is not a quasiquote? Does it forbid the ] character in quasiquoted text? 
13:41:26 <xivix> yeah i see it now
13:41:40 <thoughtpolice> emmanuel_erc: It probably means the total number of bytes collected over the entire lifetime of the program, which is different from e.g. the max size of the heap at any point in time.
13:41:49 <thoughtpolice> For each respective generation, that is.
13:41:52 <drostie> Or does the leading expression have to be really simple?
13:42:07 <aweinstock> emmanuel_erc: are you familiar with the concept of a "generational garbage collector"?
13:42:14 <emmanuel_erc> I am not aweinstock.
13:42:38 <lyxia> drostie: Doesn't a quasiquote end with |]
13:43:12 <thoughtpolice> emmanuel_erc: Ah, OK, not sure what you meant. Briefly, generational GC is an optimization. Most objects are short lived, and they live in a place in the heap that is very efficient to collect. Very few things you allocate, relatively speaking, normally survive longer than a few garbage collections.
13:43:50 <xivix> prsteele, i just tested it and your version is slightly faster, and definitely has the same complexity. probably because it's not making a load of tuples when it needs to
13:43:53 <drostie> lyxia: yes, but hypothetically it seems like a quasiquoter might be able to define its own syntax within that, possibly including defining ] within. So if brace matching is required within the quasiquote, then that would answer my question, for example.
13:43:58 <thoughtpolice> emmanuel_erc: Every once in a while (every couple of GCs), objects that are kind of old will be 'promoted' to a different part of the heap. These two pieces of the heap are each called a 'generation', and the normal parlace is one is the 'old generation' and the other is the 'young generation'.
13:44:04 <xivix> it's roughly twice as fast as my original version
13:44:05 <lyxia> xivix: also if you're going to map fst and map snd, you might as well unzip the list first
13:44:33 <xivix> lyxia, i probably would switch it to do a dropwhile like you suggested
13:44:33 <lyxia> drostie: ah I see. Good question.
13:44:47 <Zemyla> Hmm, it appears that monad transformer created from the adjunction of f and g is isomorphic to StateT (Rep g).
13:44:48 <emmanuel_erc> Thank you for the explanation thoughtpolice! That's clears things up quite a bit.
13:44:50 <thoughtpolice> emmanuel_erc: So, if a young object survives a few garbage collections, it is promoted to the 'old generation' and becomes an old object. GHC garbage collects the set of old objects more infrequently than it does young ones, and it's faster to GC young objects anyway.
13:44:54 <xivix> then I can just compare against the first element of each one
13:45:50 <thoughtpolice> emmanuel_erc: Naturally the mechanical details are about a jillion times more complicated because reasons, but it's a very popular approach for functional languages, because Haskell programs allocate lots of memory very quickly and release it fast in most cases.
13:45:51 <emmanuel_erc> I see, so is it better to see roughly the same number of bytes collected in both generations (assuming the number is satisfactory)?
13:46:13 <thoughtpolice> Most programs 'normally' allocate at a rate of around 1-2GB/s in my random non-scientific experience.
13:46:21 <thoughtpolice> I'd guess.
13:46:43 <thoughtpolice> emmanuel_erc: Well, the total number of bytes collected over the whole of the program isn't necessarily very useful, since it doesn't necessarily tell you how much time was spent there.
13:47:06 <lyxia> xivix: I think elemSorted is a bit weird anyway. Perhaps I wouldn't write this as a separate function.
13:47:22 <thoughtpolice> So you need to keep track of it with other data, like the ratio of overall GC time vs program time, and what the max 'resident' size was at some point during the program, etc.
13:47:24 <emmanuel_erc> Right... But if you use laziness properly, then the garbage collector shouldn't have to do *too* much work right?
13:47:32 <xivix> lyxia, it was just my starting point. I don't write Haskell very often but I'd like to use it more
13:48:17 <prsteele> xivix: is the idea behind my implementation clear?
13:48:19 <thoughtpolice> It depends on the characteristics of the program in question. Just because your application is lazy in many places doesn't mean it won't allocate a lot of bytes, even if you don't always force everything.
13:48:53 <thoughtpolice> And just because you allocate a lot of bytes doesn't necessarily mean your overall performance is always worse. Sometimes you can make a speed/space tradeoff for example, and use more 'bytes' for a lower overall time.
13:49:20 <xivix> prsteele, yeah, I get the basic concept. Trying to figure out why you needed reverse
13:49:34 <thoughtpolice> In general, the performance characteristics of GC'd languages are complicated when you get into really high performance or detailed scenarios, and it's hard to pin down a particular behavior or pattern without talking about the program in question.
13:49:58 <thoughtpolice> (Of course, GCs are great for tons of things and I like them and GHC has a darn good one.)
13:50:03 <prsteele> xivix: I assumulate the common elements backwards, but we need as an invariant that the common elements are sorted
13:50:23 <xivix> lol assumulate
13:50:32 <prsteele> xivix: since I do (a : acc) and we're processing left-to-right, it ends up backwards
13:50:37 <prsteele> ya, I started writing assume... haha
13:50:39 <emmanuel_erc> Yeah, I think I'm starting to understand what things may need to forced.
13:50:53 <emmanuel_erc> But it is still tricky, and it sometimes feels like I'm guessing.
13:51:06 <prsteele> xivix: we could avoid the reverse by accumulating like (acc ++ [a]), but that is O(n) each time
13:51:15 <xivix> prsteele, could you have used a foldr instead?
13:51:15 <prsteele> xivix: so it's faster to accumulate backwards, then reverse once
13:51:33 <prsteele> xivix: this is independent of the fold
13:51:38 <xivix> oh ok
13:52:11 <prsteele> xivix: we need that sortedIntersect returns a sorted list. We could process the lists backwards to begin with, instead, but then we need two calls to reverse
13:52:40 <xivix> prsteele, could sortedIntersect' be written as a fold instead of "manual" recursion?
13:53:17 <prsteele> xivix: it might be difficult because we can consume the lists at different rates. I don't see how I'd do that, immediately
13:53:31 <xivix> alright, I thought that may have been the issue
13:54:30 <prsteele> xivix: another way to remove the reverse is to make sortedIntersect not tail recursive
13:54:49 <prsteele> xivix: ... a : sortedIntersect' as (b:bs), for example
13:54:58 <xivix> that would be a bad idea though, right?
13:54:59 <emmanuel_erc>  Thanks for your help thoughtpolice!
13:55:10 <lpaste_> lyxia revised “xivix”: “No title” at http://lpaste.net/144683
13:55:18 <lyxia> prsteele: ^
13:56:02 <prsteele> xivix: lyxia's paste has the non-tail recursive version
13:56:41 <drostie> okay, the GHC docs are helpful. Apparently between [ and | there can only occur a single name which may potentially be qualified but is otherwise bare. a bare ] is allowed in a quasiquote which must terminate at the first |] it sees.
13:56:41 <lyxia> hmm...
13:57:07 <SiIky> when running a lil compiled program ive made im getting the following error: "«filename»: <stdin>: hGetContents: illegal operation (handle is closed)". Any ideas on what might be wrong?
13:57:14 <drostie> does make me wonder if GHC will really get confused on [n|n<-[0..9]] though.
13:57:45 <lyxia> prsteele: but laziness...!
13:58:00 <xivix> yeah, I can see the difference. the compiler can't optimize the tail recurion one as well, right?
13:58:05 <drostie> (in that it looks like a quasiquoter at first but then we reach EOF without hitting |] so presumably we'd have to backtrack and look for the matching ] to know that this was a list.)
13:58:08 <xivix> the non-tail-recursive one**
13:58:23 <prsteele> I'm honestly not sure if it would present a problem in this case
13:58:44 * hackagebot Cartesian 0.2.0.0 - Coordinate systems  https://hackage.haskell.org/package/Cartesian-0.2.0.0 (SwiftsNamesake)
14:02:08 <aweinstock> xivix: tail recursion is a bigger deal in strict languages, my understanding is that it's not as important in haskell
14:02:31 <lyxia> drostie: does that happen in some kind of preprocessing phase? I can't picture it happening while parsing into an AST.
14:02:33 <xivix> i checked and they have almost the same run time, but the tail recursive version uses a lot more memory
14:02:35 <aweinstock> (and in some cases, tail recursion is even less efficient than non-tail recursion, e.g. foldl' vs foldl vs foldr
14:02:38 <aweinstock> )
14:02:54 <prsteele> "In Haskell, the function call model is a little different, function calls might not use a new stack frame, so making a function tail-recursive typically isn't as big a deal—being productive, via guarded recursion, is more usually a concern. "
14:03:03 <prsteele> -- https://wiki.haskell.org/Tail_recursion
14:05:54 <xivix> lyxia, prsteele, aweinstock: thanks for all your help. I learned a lot!
14:06:07 <prsteele> xivix: you're welcome!
14:38:46 * hackagebot byline 0.2.1.0 - Library for creating command-line interfaces (colors, menus, etc.)  https://hackage.haskell.org/package/byline-0.2.1.0 (PeterJones)
14:39:48 <sleblanc> trying to install c2hs with cabal; seems to go ok but fails at the end with InstallPlan: internal error: configured package depends on a non-library package
14:41:24 <sleblanc> oh, figured it out
14:41:45 <skatenerd> i'm back with another tooling question
14:41:50 <skatenerd> any ideas? https://github.com/bitc/hdevtools/issues/43
14:43:51 * hackagebot pipes-cacophony 0.1.0 - Pipes for Noise-secured network connections.  https://hackage.haskell.org/package/pipes-cacophony-0.1.0 (jgalt)
14:45:24 <orion> \o/ ^
14:46:04 <orion> tommd: You might be interested in the cacophony and pipes-cacophony packages.
14:46:22 <dominik> Hey, I've just started having a look at stack, but I'm struggeling to use the mtl package the stack's version of ghc-7.10
14:47:14 <kadoban> dominik: What'd you try? What went wrong?
14:47:41 <kadoban> dominik: Also, I like using the stackage based resolvers if you can, they seem to work better.
14:48:09 <dominik> is there a way of starting stack's installed ghc-7.10 and tell it to also use a user's package database (i.e., where mtl is installed)?
14:48:26 <dominik> maybe I'm using it incorrectly or unidiomatically
14:49:04 <dominik> but I'd like to just fire up the ghc that was installed by stack and also have it load the "global" user-defined package database
14:49:06 <dominik> is that possible?
14:49:38 <dominik> or can I only do that when I'm working within a project?
14:50:22 <dominik> ideally, I would like to instead add to the global stack.yaml that I would always also load a certain set of custom packages.
14:51:01 <cite-reader> I'm not 100% on what you're asking, but is this `stack exec ghc`?
14:52:34 <dominik> or put differently, what happens if I add certain extra packages to the packages: field in stack's ~/.stack/global/stack.yaml file?
14:53:05 <dominik> will these packages also get loaded once I fire up any stack exec ghc?
14:54:25 <kadoban> dominik: 'stack exec ghc' doesn't sound like something that's supposed to be generally used I don't think.
14:56:26 <sleblanc> Is there a way to connect arbitrary signals to a Gtk object? Gtk2hs is missing a few definitions for some signals
14:56:44 <sleblanc> (do I need to use the GIO package directly?)
14:59:50 <jacereda> hi... I have a [String] and I want to do something like 'foo >>= fn str0 >>= fn str1 >>= ... >>= fn strn', any hint?
15:00:26 <nek0> jacereda: do notation would be a start....
15:01:07 <jacereda> nek0: how does it help? 
15:01:51 <jacereda> I need to sort of implement a unix pipeline, the elements in the [String] are unix commands and 'fn' would connect the processes
15:02:02 <nek0> jacereda: It makes the code look cleaner. 
15:02:51 <skatenerd> can you add parens
15:03:03 <skatenerd> to your bind statement
15:03:33 <sleblanc> jacereda, just guessing, but that looks like a map: let fns = map fn [str0, str1, str2…], then you could do that: foo >>= (sequence fns)
15:04:08 <jacereda> sleblanc: should mapM also do the trick?
15:04:44 <lyxia> it seems elements of fns have type (a -> m a)
15:05:01 <skatenerd> sounds like foldm
15:05:04 <jacereda> lyxia: right
15:05:18 <sleblanc> lyxia, right, missed that
15:05:38 <jacereda> each function invokes a command passing an input handle and returns the output handle
15:07:16 <arek221b> Hello. Could someone please explain why doesn't it work?  1. let a = 5   2. read "a" :: Int
15:07:50 <skatenerd> you can only "read" a string?
15:08:14 <lyxia> :t foldM
15:08:16 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
15:08:17 <arek221b> Yes. But if works with read "5" :: Int 
15:08:33 <lyxia> skatenerd's suggestion looks right
15:08:40 <shachaf> arek221b: read doesn't evaluate Haskell expressions.
15:08:51 <shachaf> read :: String -> Int is a function that parses integer literals.
15:09:01 <jacereda> great, thanks, will try it
15:09:04 <skatenerd> lambdabot!
15:09:08 <skatenerd> sick
15:09:19 <arek221b> All right. Thanks guys!
15:09:24 <skatenerd> read is cool because it has return-type polymorphism
15:09:54 <skatenerd> there are some strings which could be ambiguous and represent an instance of multiple data structures
15:10:01 <skatenerd> like "(3,4)"
15:10:09 <skatenerd> could be a Point, or it could be a Tuple
15:10:30 <skatenerd> so when you specify the type, you're telling it what data structure to re-hydrate
15:11:06 <skatenerd> :t read
15:11:08 <lambdabot> Read a => String -> a
15:14:38 <dsop_> Whats the best way to guard on the content of a state monad? I have a state monad that I use in a recursive function and I want to abort the recursion and return depending on a state.
15:15:02 <skatenerd> untilM
15:15:03 <skatenerd> ?
15:15:22 <dsop> skatenerd: like untilM pred (return x) ?
15:16:00 <skatenerd> so you have some monadic computation
15:16:08 <skatenerd> could be state monad, or IO or anything
15:16:50 <skatenerd> and "pred" can look inside the monad and say whether or not to stop
15:17:14 <skatenerd> do an experiment with just the IO monad where like, the predicate reads a key from user input and checks if it's "q"
15:17:22 <dsop> skatenerd: i'll try it, i assume you meant unless instead of untilM, untilM doesn't exist?
15:17:58 <dsop> skatenerd: i am more concerned about the return part
15:18:02 <dsop> skatenerd: okay i'll try it. Thanks
15:18:25 <skatenerd> https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
15:19:01 <skatenerd> I just did this in a personal project
15:19:02 <skatenerd> https://github.com/skatenerd/vectorracing/blob/master/src/Main.hs#L48
15:24:56 <mzabani> hi there everyone. I'm having some trouble with some code that is running out of memory. I'm very very new to Haskell and I thought maybe someone could help me. It is very short code, by the way
15:25:17 <emmanuel_erc> Sure, just post the code to lpasete.
15:26:31 <lpaste_> mzabani pasted “Csv parser” at http://lpaste.net/144695
15:28:00 <mzabani> There it is. It is a csv parser. The thing is I'm trying to parse almost 3 million lines, and there is along the way (could sorting 3 million records be the problem?)
15:28:14 <mzabani> oops, there is * a sorting step * along the way
15:29:13 <skatenerd> hmm i wonder if you should be streaming it from a file handle...
15:29:51 <cite-reader> Is this something you're doing to learn Haskell, or are you trying to read this CSV to do useful work?
15:30:05 <mzabani> a little bit of both
15:30:55 <cite-reader> Okay, if you want to do useful things with CSV files, this parser is going to make you sad. You probably want to start with the Cassava package.
15:31:17 <cite-reader> http://hackage.haskell.org/package/cassava
15:31:44 <mzabani> I did see this package before, but before using it for actual work I thought I'd ask what is wrong with my implementation?
15:33:16 <lyxia> I don't see anything wrong
15:33:32 <lyxia> can you paste the rest of your code?
15:33:47 <mzabani> hmm let me write the line I wrote before, just give me a minute
15:33:54 * hackagebot timeless 0.9.0.0 - An Arrow based Functional Reactive Programming library  https://hackage.haskell.org/package/timeless-0.9.0.0 (carldong)
15:36:17 <mzabani> map head $ group $ sort $ map (!! 1) (readCsv file)
15:36:37 <mzabani> before that, file <- readFile "dataset.txt" (3 million lines)
15:38:37 <mzabani> thank you for the help, by the way :)
15:40:06 <lyxia> I don't see how a sort on 3M elements could block either.
15:40:11 <mzabani> I'm trying to get all the distinct values from the second column in the dataset
15:40:52 <monochrom> you don't know that its 3M elements. 3 million lines, each line 10 fields, that may be 30M elements instead
15:41:35 <lyxia> (mapCsv file) has one element by line in file
15:41:50 <lyxia> and you take the first field
15:41:53 <lyxia> second*
15:43:46 <mzabani> hmm, but couldn't only the elements I need be put in memory?
15:44:24 <mzabani> since I'm not really accessing the values of the other fields
15:47:07 <lyxia> how long is a field?
15:47:55 <cite-reader> That line you pasted earlier, "map head $ group $ sort $ map (!! 1) (readCsv file)", what's processing that?
15:48:11 <mzabani> they are 10-20 characters long at most, and there are 6 fields per line
15:48:16 <mzabani> I'm doing this on ghci
15:48:31 <cite-reader> OH. Compiling your code with optimizations will probably help.
15:48:42 <Hamstak> It will be a lot faster
15:48:51 <lyxia> mzabani: ok I just reproduced it and I got OOM too :D
15:49:52 <cite-reader> I'm running this on a world cities population database; feeding that pipeline to `print` all in one go tripped an rlimit, but streaming it with mapM_ print make it actually finish.
15:50:03 <monochrom> how much memory did you throw at it such that it is not enough?
15:50:34 <cite-reader> I forget! It's whatever I configured as a system default.
15:51:15 <cite-reader> I imagine keeping everything as String is not helping.
15:51:18 <lyxia> mzabani: it's only in ghci though
15:53:12 <mzabani> monochrom it's hitting the GB barrier quite quickly
15:53:37 <monochrom> > 30*24
15:53:54 <lambdabot>  720
15:53:59 <mzabani> can I run this with optimizations on ghci? and why is it that on ghci it gives an OOM?
15:54:09 <sleblanc> In gtk2hs, how can one define custom (type-safe) signals? I looked at the source and there is this reference to "connect_NONE__NONE" that I cannot find at all in the other modules
15:54:11 <monochrom> yes it can use 1.4GB
15:54:56 <Hamstak> If GHCI is telling you its out of memory you're using up all the available ram
15:55:32 <Lokathor> or you've got a 32-bit GHCi and it's hitting that limit even though you've got more ram theoretically available
15:56:02 <Hamstak> Or that yeah
15:56:08 <mzabani> it's actually allocating a couple GBs, and it's 64bit ghci
15:56:14 <monochrom> here is how: a list of length n takes at least 24n bytes (if 64-bit GHC). you have a list of 3M items, but each item is a list of 10 chars. that's 30M*24 = 720MB.
15:57:40 <monochrom> next, GHC's garbage collector uses an algorithm that sometimes requires twice as much memory as your data uses. (it is analogous to the double-buffer idea in computer graphics.)  so you have to be prepared for 720MB*2 > 1GB
15:58:05 <Lokathor> quite the hog
15:58:32 <tommd> orion: Nice! Thanks for the pointer!
15:59:06 <mzabani> hmmm... how can I deal with this, then?
15:59:35 <monochrom> P.S. it is 24n bytes because each "cons cell" is 8 bytes (64 bits) of something that stands for "I am a cons cell", then 8 bytes pointing to the item, then 8 bytes pointing to the next cons cell.
16:00:40 <lyxia> Is there no additional overhead to distinguish it from a thunk?
16:00:43 <monochrom> replace String by Bytestring or Text.
16:00:53 <mzabani> And the one thing I'd like to understand is why this runs when compiled but blows in ghci
16:01:55 <monochrom> no, that's the beauty of spending 8 bytes. 64 bits is way more than enough to distinguish cons cells from thunks.
16:02:04 <lyxia> hah
16:02:39 <monochrom> basically it is always a pointer to a piece of code. "cons vs thunk" simply means pointing to trivial code vs pointing to non-trivial code.
16:03:06 <mzabani> monochrom: do you mean to use when reading from disk or to create several bytestrings with the fields' values?
16:03:49 <monochrom> I simply mean, say, s/String/Text/ in your types. then change expressions to match that type.
16:05:34 <mzabani> hmm how can I read from disk returning Text?
16:05:51 <sleblanc> can someone explain where the "connect_NONE__NONE" symbol comes from, in gtk2hs? Example in context: https://github.com/gtk2hs/gtk2hs/blob/5e7acf293e2d9bb78efa87e0e742e4bca7cce7d2/gtk/Graphics/UI/Gtk/MenuComboToolbar/MenuItem.chs
16:06:59 <mzabani> I should probably use Data.Text.Lazy when reading from disk, right?
16:13:37 <mzabani> I'm replacing String with Text. I'll report back soon on how it went
16:21:29 <ProofTechnique> Are first-class functions really the sufficient condition for recursion schemes? I saw the claim in a blog post, and I just want to verify. Thinking about how that would look in PHP or something makes my head hurt. :D
16:21:59 <shachaf> That sounds a bit too vague to be meaningful.
16:22:46 <ProofTechnique> This is the post, if you like: http://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/
16:22:59 <ProofTechnique> "you can express recursion schemes in any language with first-class functions"
16:23:12 <pikhq>  /win 23
16:23:15 <pikhq> :(
16:25:25 <ProofTechnique> It seemed like a pretty big thing, so I was curious
16:25:54 <ezyang> Is there a state-sponsored method to get a Ptr Word8 out of a ByteString, without using castPtr? 
16:26:33 <c_wraith> ProofTechnique: I think that's valid. You just lose a lot of type safety. 
16:27:05 <ProofTechnique> Right, I could definitely see that going right out the window. :D
16:27:32 <shachaf> ezyang: That sounds unsafe.
16:27:47 <ProofTechnique> ezyang: unsafeUseAsCString?
16:28:03 <ezyang> sorry, an API like useAsCStringLen is fine 
16:28:23 <ezyang> the only problem is that that's a Ptr CChar... 
16:28:40 <shachaf> You can match on the ByteString and use withForeignPtr or something.
16:29:09 <shachaf> Maybe that's not state-sposored enough for you.
16:29:19 <ezyang> I... feel like I'd rather castPtr 
16:29:25 <shachaf> Yes, castPtr would be better.
16:29:40 <shachaf> No, I don't think there's anything.
16:29:47 <ezyang> I guess I'm just kind of surprised, given that the internal ForeignPtr is a Word8 pointer 
16:29:51 <ezyang> yeah, looks like it 
16:29:58 <shachaf> useAsCString copies the ByteString, though.
16:30:34 <ezyang> hmm, I wonder why it copies 
16:30:52 <shachaf> Because it adds \0
16:30:55 <Zemyla> ezyang: State sponsored? Like one that the US government uses?
16:30:56 <ezyang> wait, this is dumb 
16:31:03 <ezyang> why does useAsCStringLen also copy 
16:31:16 <shachaf> Because it adds \0
16:31:28 <ezyang> Zemyla: GHCHQ of course 
16:31:45 <Zemyla> And because there's no way to guarantee that the function you're passing it to won't alter it.
16:31:50 <ezyang> oof, so the contract for useAsCStringLen is that it is zero terminated, but you also get the length. Ick. 
16:32:10 <shachaf> There's no ReadOnlyPtr type, anyway.
16:32:27 <ezyang> OK, that's what unsafeUseAsCString is for, haha 
16:32:59 <c_wraith> strtok is one of the most terrifying C functions I've used. Sure, just mutate the argument heavily! 
16:33:32 <ProofTechnique> ezyang: Yeah, my understanding is that the unsafe one is basically just for getting at the pointer.
16:33:56 * hackagebot timeless 0.9.0.1 - An Arrow based Functional Reactive Programming library  https://hackage.haskell.org/package/timeless-0.9.0.1 (carldong)
16:33:59 <ProofTechnique> (safetywise, anyway)
16:35:06 <ProofTechnique> c_wraith: And null pointers everywhere!
16:38:56 * hackagebot geoip2 0.1.0.4 - Pure haskell interface to MaxMind GeoIP database  https://hackage.haskell.org/package/geoip2-0.1.0.4 (ondrap)
16:39:16 <sleblanc> How does one tell cabal to use sources in a local folder, for a specific package?
16:39:21 <max3> is there a way to write this in pointless form: test n = all (\d -> d >= 0 && d < 10) (toDigits n)
16:39:31 <sleblanc> tried sandbox add-source $path, but it does not seem to pick it up
16:39:44 <dcoutts> sleblanc: for one off, use: cabal install ./this ../that ../the/other
16:40:21 <lyxia> @pl  test n = all (\d -> d >= 0 && d < 10) (toDigits n)
16:40:21 <lambdabot> test = all (liftM2 (&&) (>= 0) (< 10)) . toDigits
16:40:23 <sleblanc> dcoutts, wow, great. Didn't know I could do that
16:40:33 <ezyang> not obviously a good idea 
16:40:48 <max3> lyxia: what is liftM2?
16:40:50 <dcoutts> sleblanc: otherwise, use a sandbox and add-source. Iirc, you need to explicitly install it once within the sandbox and thereafter it'll be rebuilt as needed automatically
16:41:18 <lyxia> :t liftM2 -- max3 
16:41:18 <max3> but i guess the answer is composition using the . ?
16:41:19 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:41:22 <Zemyla> So there once was a Control.Monad.Group? But it was removed?
16:41:25 <max3> lol
16:41:29 <lyxia> :)
16:41:32 <lyxia> types!
16:41:52 <ezyang> max3: It's using the reader monad 
16:42:01 <max3> i'll stick to just using . for right now
16:42:16 <max3> when i get to monads i'll think about what it did
16:42:42 <lyxia> this use of liftM2 here is not recommended
16:43:00 <mzabani> guys, thanks for the help. I changed my Strings to Texts but I'm not sure things changed a whole lot. I'll try some more things later on, but I have to go.
16:43:04 <lyxia> the lambda you wrote is perfectly fine max3.
16:43:17 <mzabani> see you later
16:43:24 <max3> lyxia: sure but i wanted it pointless
16:43:37 <max3> composition was what i was looking for
16:48:34 <max3> is there a way to map a list of functions over a list of values? ie [f,g,h] @ [1,2,3] = [f 1, g 2, h 3] ?
16:48:56 * hackagebot MagicHaskeller 0.9.6.4.6 - Automatic inductive functional programmer by systematic search  https://hackage.haskell.org/package/MagicHaskeller-0.9.6.4.6 (SusumuKatayama)
16:49:06 <mightybyte> Is it possible to tell TemplateHaskell to only allow pure code?  i.e. nothing in IO?
16:49:32 <monochrom> max3: it looks like zipWith ($) [f,g,h] [1,2,3]
16:50:08 <max3> monochrom: why the $?
16:50:13 <max3> oh
16:50:15 <max3> i'm silly
16:50:20 <max3> actually no why the $
16:50:44 <max3> why not just zip?
16:50:58 <cite-reader> zip gets you a list of tuples; not what you wanted.
16:51:11 <max3> right
16:51:13 <cite-reader> (In particular, zip = zipWith (,))
16:51:22 <max3> right
16:51:23 <max3> thanks
16:51:43 <ProofTechnique> max3: all ((>=0) *> (<10)) . toDigits . toDigits should work, too
16:51:54 <ProofTechnique> Whoops, extra . toDigits on there
16:51:59 <ProofTechnique> all ((>=0) *> (<10)) . toDigits
16:52:24 <max3> what is *> ?
16:53:07 <ProofTechnique> Oh, actually, that throws away one of the results, so probably bad behavior
16:53:16 <ProofTechnique> Sequencing applicative actions
16:54:24 <ProofTechnique> I'm bad at stuff :/
17:12:09 <SomeGuy> hello all, I'm trying to do something very simliar to this post (http://stackoverflow.com/questions/28137838/creating-monadbasecontrol-instance-for-newtype), except instead of ReaderT I am using StateT, this does not compile though, am I missing something
17:12:15 <SomeGuy> lpast: http://lpaste.net/6648068646415368192
17:15:33 <max3> how can i get [1..n] to give me a list of integers instead of ints?
17:15:53 <tabemann> [1..n] :: [Integer]
17:15:54 <Shockk> [1..n] :: [Integer]
17:16:07 <max3> thank you
17:16:58 <max3> in hugs: 
17:17:00 <max3> *** Term           : enumFromTo 1 n
17:17:01 <max3> *** Type           : [Int]
17:17:03 <max3> *** Does not match : Integer
17:17:03 <Cale> You don't necessarily have to specify though. Numeric defaulting will already give you Integer if that's a type which works in most cases. Also just doing something with the list which requires a list of Integers is sufficient.
17:17:09 <dmj`> [1 :: Integer .. ]
17:17:19 <Cale> What's the type of n?
17:17:26 <max3> returned by length
17:17:28 <max3> so i guess int
17:17:30 <Cale> If n is an Int, then the list will be a list of Int
17:17:42 <Cale> yeah, so you'll want to apply fromIntegral to it to convert
17:17:49 <Cale> (perhaps)
17:17:57 <Cale> Or somehow manage to avoid length
17:18:01 <Shockk> [1..(fromIntegral n)]
17:18:13 <Cale> zipWith const [1..] xs   will be a list with the same length as xs
17:18:22 <max3> yes that i know
17:18:25 <Cale> > zipWith const [1..] "hello"
17:18:27 <lambdabot>  [1,2,3,4,5]
17:18:28 <shachaf> @where e_10
17:18:28 <lambdabot> [show(sum$scanl div(100^n)[1..[4..]!!n])!!n|n<-[0..]]
17:18:44 <shachaf> I like the [1..[4..]!!n]
17:18:55 <shachaf> Though mentioning it in this context gives it away, of course.
17:19:08 <shachaf> @@ @run @where e_10
17:19:11 <lambdabot>  "271828182845904523536028747135266249775724709369995957496696762772407663035...
17:19:24 <tabemann> max3: why're you using hugs?
17:19:37 <max3> because that's was suggested by the edx course i'm taking
17:19:40 <max3> i hav ghci as well
17:19:46 <max3> *have
17:19:56 <tabemann> sigh
17:20:22 <tabemann> the people who set up these courses must not realize that hugs is no longer developed, unsupported, and pretty much obsolete
17:20:38 <max3> it's fine
17:20:45 <max3> i'm not going to get used to it
17:21:00 <SomeGuy> anyne have any ideas on the monadbasecontrol question I posted about? I'm think the state 's' returned is tripping it up, can't think of how to get rid of it though :(
17:21:48 <Cale> tabemann: I would be equally upset about it as you prior to Foldable being in the Prelude.
17:24:45 <max3> is there a good IDE? something that will at least give me tab complete?
17:25:12 <tabemann> there is no IDE for Haskell, but you should probably use GNU Emacs with haskell-mode with it
17:25:37 <max3> i guess there are vim plugins?
17:25:37 <tabemann> and no, haskell-mode does not do tab-completion
17:26:11 <tabemann> there may be support for Haskell in vim, but I myself've never edited Haskell code in vim
17:26:22 <SomeGuy> there is support for vim
17:26:25 <SomeGuy> i use it
17:26:32 <SomeGuy> its very good, just takes a while to setup right
17:27:22 <tabemann> actually, I use yi these days for editing Haskell, since my install of haskell-mode is currently broken for who knows what reason
17:27:40 <Nikotiini> Haskell-mode + ghc-mod has tab-completion
17:29:09 <emmanuel_erc> tabemann: How is the yi community doing these days?
17:29:41 <tabemann> #yi seems dead like all the time, even though there's always quite a few people in it
17:31:30 * tabemann much prefers emacs over  yi, actually, but finds haskell-mode useless in its current state on his machine
17:34:38 <emmanuel_erc> emacs FTW
17:34:48 <emmanuel_erc> (that was lame)
17:37:01 <tabemann> <emmanuel_erc> emacs FTW < ?
17:38:14 <emmanuel_erc> lol, I'm just being silly.
17:41:31 <lamefun> How to make typesafe easily?
17:42:34 <lamefun> I mean, for example, I want a record fields with a list that contains no duplicates, a record field with numbers from 1 to 300, etc.
17:43:05 <Lokathor> a list with no duplicates is not exactly easy to declare as a type.
17:43:17 <Lokathor> but you could set something up
17:43:56 <Lokathor> have you considered just using a Set instead?
17:43:57 <Cale> lamefun: Use a type system which is not Haskell's. Haskell isn't dependently typed.
17:44:01 <Lokathor> and then converting to list when you need to?
17:44:12 <Cale> But yeah, there might be a way to factor the data differently
17:44:36 <Cale> rather than imposing conditions, just change the representation of the data to remove all possibility of failing them
17:45:10 <Lokathor> if you need a number that must be 1 - 300, you could make a newtype of Int with a special constructor
17:45:14 <lamefun> No, I want a list with no duplicates (manually ordered).
17:45:42 <Lokathor> well, you can make a newtype of list and then define a special insert operation that doesn't let in duplicates
17:46:05 <Lokathor> but that'll be a linear cost insertion operation, which is pretty bad
17:46:52 <tabemann> have a list and a set
17:47:12 <tabemann> have the insertion operation check the set for membership, and if not a member, it adds to both the list  *and* the set
17:47:33 <Lokathor> ah, clever, that'd do it
17:48:07 <lamefun> I'm trying this now: http://lpaste.net/3049074073150685184
17:49:28 <andkore> This has probably been asked zillions of times, but cabal install --only-dependencies was running out of backjumps until I added some version constrains. My package only has three dependencies other than base. Shouldn't it be possible to first try resolving dependencies by using the newest versions of everything?
17:49:31 <lamefun> Is it an OK way to do that?
17:50:18 <Lokathor> lamefun, you need to have your insertion function as well, to add to the LicenseList
17:51:04 <lamefun> fromVector (Vector.cons elem (toVector licenseList))?
17:51:14 <Lokathor> andkore, it's probably trying that but not succeeding. If you don't need precise verions, https://www.stackage.org/lts-3.12
17:51:33 <Lokathor> add the cabal.config there to your project and it'll pick out versions of stuff for you that should agree with each other
17:51:56 <andkore> Lokathor: OK, thanks.
17:52:13 <andkore> "base, scotty == 0.10.2, warp == 3.1.8, streaming-commons" is what I have now. I had no constraints before.
17:52:16 <Lokathor> lamefun, i'm not seeing where you're preventing duplicate elements there
17:52:45 <lamefun> 'fromVector vector = LicenseList (backwardDeduplicate vector)'?
17:53:00 <Lokathor> oh de-duplicate
17:53:01 <Lokathor> okay
17:53:08 <Lokathor> wasn't reading that name quite right at first
17:53:15 <andkore> Everything seems to be the newest version. Anyway. Adding version constraints isn't hard.
17:53:32 <Lokathor> andkore, LTS 3.12 has warp at 3.1.3.1
17:53:37 <Lokathor> not 3.1.8
17:53:42 <Lokathor> maybe that's the issue
17:53:53 <andkore> It looks like it picked 3.1.8.
17:54:13 <Lokathor> you might have to run cabal configure again
17:54:22 <Lokathor> but i guess as long as it all works you're good... for now
17:54:28 <Lokathor> until it breaks again :P
17:54:28 <andkore> Does the order of the dependencies matter?
17:58:26 <lamefun> For simple thing like 1-100 numbers I looked into Refined which basically is 'newtype Refined predicateType a = Refined a', but it lacks some instances I want (eg. 'Predicate p a, FromJSON a => FromJSON (Refined p a)'. Is it OK to define my own? How does Haskell handle several packages implementing the same instance?
17:59:06 <Lokathor> andkore, nope, shouldn't matter the order
17:59:11 <Lokathor> it can either solve it or it can't
17:59:30 <andkore> Hm, OK. Thanks for the help Lokathor.
18:00:44 <Lokathor> try taking off the version numbers in your project.cabal thing, and just having the cabal.config for LTS, and seeing if that'll get things going
18:01:00 <Lokathor> you could also try switching to stack perhaps if it still won't build
18:15:19 <isd> Hey. I am clearly missing something obvious, but I'm at a loss. Why is this test passing: http://pastie.org/10533240 ?
18:21:01 <Lokathor> is there a standard lib function for breaking a list into sublists of a given list?
18:21:43 <Lokathor> eg: splitEvery 3 [1,2,3,4,5,6,7,8,9] -> [[1,2,3],[4,5,6],[7,8,9]]
18:22:57 <dmj`> :t splitOn
18:22:58 <lambdabot> Eq a => [a] -> [a] -> [[a]]
18:23:28 <dmj`> > chunksOf 3 [1,2,3,4,5,6,7,8,9]
18:23:29 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9]]
18:23:51 <dmj`> @package split
18:23:51 <lambdabot> http://hackage.haskell.org/package/split
18:23:57 <Lokathor> hmm
18:24:02 <Lokathor> i see
18:24:05 <dmj`> Lokathor: it's not in base
18:24:05 <Lokathor> perfect
18:28:01 <isd> ^ Anyone?
18:32:27 <Kristler> So, I've written a lambda to square the sum of two numbers: (\x y -> sqrt $ x + y)
18:32:38 <Kristler> is it possible to express that as a composition of sqrt and (+)?
18:32:50 <Kristler> My initial thought was sqrt . (+), but that's a bit non-sensical
18:32:59 <shachaf> @pl \x y -> sqrt (x + y)
18:32:59 <lambdabot> (sqrt .) . (+)
18:33:06 <E4xoi> (sqrt .) . (+)
18:33:06 <shachaf> Not in a particularly nice way.
18:33:14 <Kristler> Oh that looks weird
18:33:16 <thimoteus> the lambda definitely looks nicer
18:34:08 <pavonia> Some package has (.:) for that
18:35:14 <mniip> :t fmap sqrt . (+)
18:35:15 <lambdabot> Floating b => b -> b -> b
18:35:37 <Kristler> neat
18:37:04 <Kristler> How do I interpret (sqrt .)? Is that partial application of (.)?
18:37:08 <mniip> yes
18:37:49 <shachaf> It's a section of (.).
18:37:52 <thimoteus> (sqrt .) is the same as \ f -> sqrt . f
18:38:19 <sleblanc> other than defining printDebug = appendFile "/dev/stderr", is there a built-in that prints messages to stderr, ideally based on an environment "debug" variable being set?
18:38:37 <lamefun> How does Haskell handle several packages implementing the same instance?
18:38:53 <mniip> lamefun, how does that work
18:39:21 <lamefun> I don't know how does that work, that's what I'm asking.
18:39:29 <mniip> you mean instance X Y defined in neither X's module nor Y's module?
18:40:01 <mniip> that's an orphan instance
18:40:02 <mniip> don't do that
18:41:10 <lamefun> Why not? Isn't that the exact point of typeclasses?
18:41:44 <Cale> Well "don't do that" -- if you do that in a library setting, put the instance in its own module. You can do it just fine in an application.
18:42:08 <Cale> It's impossible to control the import and export of instances, and colliding instances mean that things can't be used together.
18:42:16 <Cale> So try not to make orphans.
18:46:39 <stoogenmeyer_> hey folks, lets say I have a list of floats, I'm trying to get a list of the ratios between adjacent numbers
18:47:49 <c_wraith> > zipWith (/) <*> tail $ [1.0, 1.1, ..]
18:47:50 <lambdabot>  <hint>:1:35: parse error on input ‘..’
18:47:55 <c_wraith> > zipWith (/) <*> tail $ [1.0, 1.1 ..]
18:47:57 <lambdabot>  [0.9090909090909091,0.9166666666666666,0.923076923076923,0.9285714285714285,...
18:48:11 <c_wraith> ...  Ok, that's the obfuscated way to write it
18:48:48 <stoogenmeyer_> neat!
18:48:54 <stoogenmeyer_> <*> is the list right?
18:49:06 <c_wraith> > let consecutiveRatios xs = zipWith (/) xs (tail xs) in consecutiveRations [1..]
18:49:07 <lambdabot>      Not in scope: ‘consecutiveRations’
18:49:07 <lambdabot>      Perhaps you meant ‘consecutiveRatios’ (line 1)
18:49:11 <c_wraith> > let consecutiveRatios xs = zipWith (/) xs (tail xs) in consecutiveRatios [1..]
18:49:13 <lambdabot>  [0.5,0.6666666666666666,0.75,0.8,0.8333333333333334,0.8571428571428571,0.875...
18:49:20 <mniip> [05:48:32] <stoogenmeyer_> <*> is the list right?
18:49:22 <mniip> what'd you mean
18:49:37 <stoogenmeyer_> you wrote <*>, what's that?
18:49:56 <c_wraith> stoogenmeyer_: actually, in that case, it means something like \f g x -> f x (g x)
18:51:05 <c_wraith> :t (<*>)
18:51:07 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:51:19 <c_wraith> if you pretend f = (c ->)
18:52:15 <mniip> :t (<*>) `asAppliedTo` (undefined :: a -> b -> c)
18:52:17 <lambdabot> (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
18:52:33 <stoogenmeyer_> ok very cool. thank you very much
18:58:23 <lamefun> Cale, then how to use type classes?
18:59:07 <Cale> lamefun: Do you want examples of type classes, or what?
18:59:19 <luigy> anyone has a gist showing a number literal resulting in a compile time out of bounds error.... for example... 101 :: MyCustomBoundedNat  -- compile error? 
18:59:22 <Cale> lamefun: I'm not sure I understand the question
18:59:47 <lamefun> Like FromJSON, what if a type in a library doesn't have FromJSON, then I have to define an instance out of both Aeson and the library that contains the type.
19:00:12 <Cale> lamefun: Yeah, if you're writing an application, you just write the instance, it's fine
19:01:06 <Cale> lamefun: You only have to worry about orphans in libraries, and if you're working on libraries anyway, the right thing to do is to put the instance in the library which defines the type (usually)
19:02:19 <lamefun> So either Aeson has to depend on everything, or everything has to depend on Aeson?
19:02:32 <Cale> Everything which uses Aeson should depend on it already
19:02:47 <Cale> If you need the instance for your library, then you already depend on Aeson
19:03:09 <codygman> This obviously doesn't work, and I'm pretty sure it's because hClose isn't called after bind like I thought it might be. code: writeFile "/tmp/test.txt" "hunter2" >> readFile "/tmp/test.txt" >>= writeFile "/tmp/test.txt"
19:03:39 <Cale> codygman: It's because you're writing to the file that you're reading from, wiping it out.
19:03:53 <anoe> hello, I am blocked with the deltaPart function: http://lpaste.net/144705     I wonder If I am on the wrong way trying to defin fromInteger... Maybe I should rewrite the function as suggested on haskell-beginner. What is your advice please ?
19:04:04 <Cale> codygman: The correct thing to do is to write to a new file, and then move the new file over the old one once you're done.
19:04:21 <codygman> Cale: Say I was trying to simulate "sed -i 's/hunter2/hunter1/g' /tmp/test.txt"
19:04:28 <codygman> Cale: Ah, I had a feeling that might be the way to do it
19:04:37 <codygman> since you can't lazily stream to something you are lazily reading from
19:04:48 <codygman> s/stream/write
19:05:11 <lamefun> I mean, not all libraries with potentially From/ToJSON-able types depend on Aeson and implement From/ToJSON.
19:05:23 <Cale> Yeah, you could also strictify the IO (an easy way to do that would be to use strict Data.ByteString or Data.Text IO stuff)
19:06:45 <Cale> lamefun: What is the situation you're actually in?
19:07:18 <codygman> Cale: Yeah, I thought that might work but still wanted to know how to do it with plain strings. Came up with this: writeFile "/tmp/test.txt" "hunter2" >> readFile "/tmp/test.txt" >>= writeFile "/tmp/test-tmp.txt" >> renameFile "/tmp/test-tmp.txt" "/tmp/test.txt"
19:07:23 <lamefun> There's refined package which is basically 'newtype Refined predicateType a = Refined a', but it lacks some instances I want (eg. 'Predicate p a, FromJSON a => FromJSON (Refined p a)'.
19:07:47 <Cale> lamefun: If you think it's natural for your library to provide a ToJSON/FromJSON instance for its users, then yeah, you need the classes that you're writing instances for, so you depend on aeson.
19:09:03 * hackagebot sync-mht 0.3.8.1 - Fast incremental file transfer using Merkle-Hash-Trees  https://hackage.haskell.org/package/sync-mht-0.3.8.1 (emink)
19:10:01 <Cale> If you're writing a library, rather than an application, which depends on both refined and aeson, you *may* be better off just not defining ToJSON/FromJSON instances, since those only have one method each anyway
19:10:15 <Cale> and you probably don't need the polymorphism?
19:10:29 <Cale> But I don't really have enough details
19:14:06 <anoe> Ok found.
19:19:21 <lamefun> I mean, if I'm writing a library provides types that someone might want to serialize to JSON, do I have to add Aeson dependency or everyone else will have a choice: either not use Aeson's convenient (object .: "property") or define orphan instance?
19:21:24 <lamefun> For example a library like this one: https://hackage.haskell.org/package/semver-0.3.3.1/docs/Data-SemVer.html
19:22:57 <dmj`> lamefun: to get around orphans you can always newtype things, implementing the instance in the same module the newtype was declared
19:30:36 <Guest00000> hello
19:31:39 <Guest00000> is it possible to write a function which compares types:   f :: _ => a -> b -> Bool
19:31:42 <Guest00000> f = True for identical types
19:32:26 <Lokathor> sure don't think so
19:33:05 <mniip> Guest00000, no
19:33:16 <Guest00000> maybe with some constraint on a and b to make them comparable?
19:33:23 <mniip> well you could plug Typeable a, Typeable b
19:33:41 <Lokathor> (typeOf a) == (typeOf b)
19:37:28 <Guest00000> thank you
19:41:43 <Guest00000> hmm
19:42:00 <Guest00000> i need to compare the two values if they are of the same type
19:42:18 <Guest00000> by using (==)
19:43:37 <Lokathor> you mean check if they're the same type, and if they are then check if they're also the same value?
19:43:55 <Guest00000> yes
19:44:04 * hackagebot hworker-ses 0.1.1.0 - Library for sending email with Amazon's SES and hworker  https://hackage.haskell.org/package/hworker-ses-0.1.1.0 (DanielPatterson)
19:44:06 <Lokathor> now that... that thing you cannot do
19:44:11 <Lokathor> :t (==)
19:44:13 <lambdabot> Eq a => a -> a -> Bool
19:44:26 <Lokathor> you see, to use (==) it requires that the two values be of the same type
19:44:51 <Lokathor> so you can't just write, if (typeOf a) == (typeOf b) then a == b else False
19:45:14 <Lokathor> well you could, but it'd be pointless because you wouldn't be able to call it with two different typed things
19:45:23 <arkeet> also
19:45:32 <arkeet> er, never mind.
19:46:05 <Guest00000> so i cannot somehow coerce a to b when i know that a ~ b ?
19:46:10 <Guest00000> uhh
19:46:20 <Guest00000> when i dynamically know that
19:47:21 <Guest00000> i meant typeOf a == typeOf b
19:47:57 <Guest00000> or maybe i can derive (a ~ b) when i dynamically compare
19:49:07 <tzh> Typeable also has `cast`, so you could use that i think
19:50:05 <Guest00000> oh
19:50:09 <Guest00000> i didn't read further >_<
19:50:18 <SuppliedR3lic> I NEED SUPPORT! https://usercontent.irccloud-cdn.com/file/NWoKCxTm/cat_tickle.gif-c200 problem with D.S.L. Modam and // or 56-Khz takeey asjo Adeon saulzar_ ricky_clarkson wanderleyguima psacrifice alpounet trig-ger mikeizbicki Speed cic kosmikus jgornick hvr Geekingfrog chris2 seliopou Nickeeh vikraman COCKSTUFFER! [AMSG]
19:50:21 <Guest00000> thank you
19:50:51 --- mode: ChanServ set +o monochrom
19:51:04 --- mode: monochrom set +b *!*@206.125.41.78
19:51:04 --- kick: SuppliedR3lic was kicked by monochrom (SuppliedR3lic)
20:01:42 <lethjakman-l> Does anyone have an odbc example with persistent? 
20:01:47 <lethjakman-l> Preferably with oracle? 
20:15:36 <Guest00000> so, i'd like to write that function
20:17:45 <Guest00000> i try in ghci: let equal :: (Typeable a, Typeable b) => a -> b -> Bool; equal a b | Just a' <- cast a :: Maybe b, a' == b = True | otherwise = False
20:18:26 <Guest00000> it says:     Could not deduce (Typeable b1) arising from a use of `cast'    from the context (Typeable a, Typeable b)
20:18:38 <Guest00000> even with ScopedTypeVariables
20:18:40 <Guest00000> what's wrong?
20:18:50 <mniip> you don't need the scoped type variables
20:18:58 <mniip> nor the type restriction
20:19:05 * hackagebot fn 0.2.0.0 - A functional web framework.  https://hackage.haskell.org/package/fn-0.2.0.0 (DanielPatterson)
20:20:01 <mniip> if you say a' == b, it will automatically infer that 'cast a' :: Maybe b
20:21:07 <Guest00000> i removed the ":: Maybe b" and it worked huh
20:21:54 <Guest00000> ok, it can infer that cast a :: Maybe b, but how to do the same thing using eqT?
20:22:30 <Guest00000> i write: equal a b | Just Refl <- eqT, .....
20:22:41 <Guest00000> but how to state what type is eqT then
20:23:03 <mniip> well that's more complicated
20:24:03 <Guest00000> i expected that i could do this with ScopedTypeVariables
20:24:04 <mniip> eqT `asTypeOf` ((undefined :: a -> b -> a :~: b) a b)
20:24:05 * hackagebot fn-extra 0.2.0.0 - Extras for Fn, a functional web framework.  https://hackage.haskell.org/package/fn-extra-0.2.0.0 (DanielPatterson)
20:24:16 <mniip> sure you can use scoped tyvars instead
20:29:10 * hackagebot latex-formulae-image 0.1.1.0 - A library for rendering LaTeX formulae as images using an actual LaTeX installation  https://hackage.haskell.org/package/latex-formulae-image-0.1.1.0 (LiamOConnorDavis)
20:29:12 * hackagebot latex-formulae-pandoc 0.1.1.0 - Render LaTeX formulae in pandoc documents to images with an actual LaTeX installation  https://hackage.haskell.org/package/latex-formulae-pandoc-0.1.1.0 (LiamOConnorDavis)
20:30:27 <timmy_tofu> not the exact right channel, but I'm trying to remember a site that gave you an URL (www.whatever.com/8e74ad3) which when hit would capture the request, useful for testing callbacks and such - anyone know what I'm trying to think of?
20:34:22 <Guest00000> omg i forgot the forall
20:35:36 <bernalex> is it theoretically possible to implement a map that works for any nested depth of Functors? if not, is there a deep theoretical reason for why, or are there just something Haskell doesn't have (and if so, what is it)?
20:36:36 <bernalex> s/are/is/
20:36:46 <mniip> bernalex, 'ffmap (const [])'
20:37:04 <mniip> should ffmap be ([a] -> [b]) -> [[a]] -> [[b]]
20:37:04 <Guest00000> :t ffmap
20:37:05 <lambdabot>     Not in scope: ‘ffmap’
20:37:06 <lambdabot>     Perhaps you meant ‘fmap’ (imported from Control.Monad.Writer)
20:37:16 <mniip> or (a -> [b]) -> [a] -> [[b]]
20:37:20 <bernalex> mniip: I don't know what you are trying to tell me.
20:37:29 <bernalex> mniip: oh, right.
20:37:32 <mniip> bernalex, you get ambiguously typed expressions
20:37:59 <mniip> er disregard the second type
20:39:16 <mniip> 'ffmap (const [()]) [[()]]' would either be of type [[()]] or [[[()]]]
20:39:38 <bernalex> hm. I'm not sure I'm following the example.
20:40:52 <bernalex> need to switch from bus to plane, but I'll try replying at the aërodrome.
20:47:54 <stoogenmeyer> I apologize if this question raises some eyebrows but what kind of job prospects exist for people who are proficient in functional programming / haskell?
20:48:41 <Lokathor> facebook
20:48:55 <ackthet> tons of places use it
20:48:58 * mniip adds to Cc
20:49:13 * mniip adds himself to Cc*
20:49:14 <ackthet> a lot of finanical places use it for its bug resistance
20:51:04 <stoogenmeyer> do you guys use it at your work place?
20:51:29 <Guest00000> how to say forall in a constraint? i need (f a) to be instance of Eq, for all a
20:51:32 <Lokathor> ackthet, i know a guy that works at a credit card verification point, and they use ruby and C#, but they have one client that connects to their service with a haskell client
20:51:33 <ackthet> im a grad student in nuclear physics 
20:51:40 <ackthet> so for some definition of 'workplace' yes
20:52:02 <Lokathor> Guest00000, foo :: (Eq a) => a -> a
20:52:04 <ackthet> Lokathor: nice, can you say what company?
20:52:19 <lethjakman-l> So, in _1.mapped._2.mapped %~ succ $ ([(42, "hello")],"world")
20:52:24 <lethjakman-l> What are the mappends doing?
20:52:24 <Lokathor> if there's just one you don't need the parens, if there's more than one you need the parens around the whole list of constraints
20:53:04 <Lokathor> eg, bar :: (Eq a, Num a) => a -> a   baz :: Eq a => a -> a
20:53:30 <Lokathor> ackthet, i cannot, but not because of secrecy, simply because i do not know :P
20:53:53 <ackthet> fair :D
20:53:59 <Lokathor> their company is in a bit of a bind at the moment, with everyone switching to those new e-verify cards
20:54:05 <Lokathor> and christmas coming up
20:54:12 <ackthet> its been a nightmare
20:54:17 <ackthet> swipe card
20:54:20 <ackthet> machine bitches
20:54:24 <ackthet> try and find the slot
20:54:32 <Lokathor> trying to do a lot of testing, but they can't software automate it, so they've had to make little arduino bots to wave a card around and stuff
20:56:00 <lpaste_> athan pasted “withState' - why doesn't this exist?” at http://lpaste.net/144708
20:56:18 <athan> Can anyone alleviate my confusion?
20:56:40 <Guest00000> Lokathor: no, i mean i need something like   foo :: (forall x . Eq (f x)) => ...
20:56:53 <Lokathor> ah, hmm
20:57:14 <Lokathor> i don't... what's f supposed to be?
20:58:38 <athan> Guest00000: Then that `f` would have equality independent of its type parameter
20:59:16 <Guest00000> athan: yes that's what i need
20:59:55 <athan> Guest00000: I advise against needless type arguments - it makes inference and unification a pain
21:01:16 <Guest00000> athan: what do you mean? for the compiler?
21:01:36 <athan> Guest00000: Well, it's a matter of knowing that your proof terms are what they say they are
21:02:44 <athan> Especially when you're dealing with rank2 types like this, you're basically saying that your proof term (the `f` when applied) should support the Eq propositions _for all_ claims in `x`
21:03:34 <athan> which is hard to prove, because you need to prove it in a general way - only for `f`, which couldn't depend on any of its arguments
21:05:29 <athan> Guest00000: You can do it, but I still advise against it
21:05:34 <athan> @let data Foo a = Foo
21:05:35 <lambdabot>  .L.hs:153:1:
21:05:35 <lambdabot>      Multiple declarations of ‘Foo’
21:05:35 <lambdabot>      Declared at: .L.hs:148:1
21:05:41 <athan> @undefine
21:05:41 <lambdabot> Undefined.
21:05:43 <athan> @let data Foo a = Foo
21:05:44 <lambdabot>  Defined.
21:05:59 <athan> @let instance Eq (Foo a) where; Foo == Foo = True
21:06:01 <lambdabot>  Defined.
21:06:15 <athan> > Foo :: forall x. Eq (Foo x) => Foo x
21:06:17 <lambdabot>      No instance for (Show (Foo x0))
21:06:17 <lambdabot>        arising from a use of ‘show_M459913210743968570629333’
21:06:17 <lambdabot>      In the expression:
21:06:22 <athan> @type Foo :: forall x. Eq (Foo x) => Foo x
21:06:23 <lambdabot> forall (k :: BOX) (x :: k). Foo x
21:06:25 <athan> there we go
21:07:07 <athan> However, it would be hard to make a term that could use _every_ instance of `f`, which can support equality for _every_ instance of `x`
21:07:12 <athan> @undefine
21:07:13 <lambdabot> Undefined.
21:09:17 <athan> Guest00000: Check it:
21:09:44 <athan> @let eq' :: forall f. (forall x. Eq (f x) => f x -> f x -> Bool); eq' x y = x == y
21:09:45 <lambdabot>  Defined.
21:10:10 <athan> @let data Foo a = Foo; instance Eq (Foo a) where; Foo == Foo = True
21:10:12 <lambdabot>  Defined.
21:10:20 <athan> > eq' Foo Foo
21:10:21 <lambdabot>  True
21:10:56 <athan> Guest00000: So it actually compiles fine, but idk.. I reserve my weariness ._.
21:11:19 <Guest00000> @let eq'' :: forall x . Eq (f x) => f a -> f a -> Bool; eq'' = (==)
21:11:21 <lambdabot>  .L.hs:153:24: Not in scope: type variable ‘f’
21:11:21 <lambdabot>  
21:11:21 <lambdabot>  .L.hs:153:32: Not in scope: type variable ‘f’
21:11:36 <Guest00000> @let eq'' :: forall f (forall x . Eq (f x) => f a -> f a -> Bool); eq'' = (==)
21:11:36 <lambdabot>  Parse failed: Parse error: forall
21:11:49 <Guest00000> @let eq'' :: forall f . (forall x . Eq (f x) => f a -> f a -> Bool); eq'' = (==)
21:11:50 <lambdabot>  .L.hs:153:9:
21:11:50 <lambdabot>      Could not deduce (Eq (f x0))
21:11:50 <lambdabot>      from the context (Eq (f x))
21:12:01 <Guest00000> it doesn't.
21:12:32 <athan> Guest00000: `x` vs. `a`
21:12:51 <athan> hmm
21:13:19 <athan> @let eq''' :: forall f. (forall x. Eq (f x)) => f a -> f a -> Bool; eq''' = (==)
21:13:19 <lambdabot>  Parse failed: Illegal class assertion
21:13:30 <athan> hum
21:13:39 <athan> > eq' [1] [1]
21:13:41 <lambdabot>  True
21:13:43 <athan> blast
21:13:46 <athan> you're right
21:14:18 <athan> Guest00000: I think you should take away from this that constraints aren't polymorphic like types. It's best to know as much about the types you're constraining against at one time - at the top level
21:35:09 <bernalex> mniip: in the air now, heh. I don't understand your argument. won't that be [[()]] always?
21:36:57 <bernalex> I have thought a bit about implementing abstracting over constraints. someone pay me to do it, or finance a phd for me, and we'll see. :p
21:37:27 <athan> bernalex: You have my awe :o
21:37:46 <bernalex> athan: I said I've thought about it, not that I know how to do it. :p
21:38:08 <bernalex> you'd need kind-level forall for Constraints. not impossible. but needs a couple of papers or so.
21:40:51 <athan> :x
21:44:40 <jakob1> hi, i'm trying to write a parsec parser for cabal files, just to extract all values of "hs-source-dirs:". i want to set Vim's path variable to this paths in order to get the gf command on module imports working. i am new to parsec.
21:45:20 <kadoban> jakob1: Wouldn't the Cabal library already have tools to parse a .cabal file?
21:46:23 <jakob1> oh, nice idea. i quickly googled for "cabal parser" but did not know about the cabal library. i will look at this! thank you.
21:46:46 <kadoban> Sure
21:47:32 <jakob1> but just to understand parsec better:
21:47:32 <jakob1> my approach was:
21:47:32 <jakob1> stuff = comment <|> toplevelStuff <|> nonToplevelDefinition
21:47:32 <jakob1> comment = string "--" >> skipMany ANYCHARACTER >> endOfLine
21:48:02 <jakob1> so how do i just parse a comment?
22:02:00 <pavonia> jakob1: With that approach, anyChar will also consume the end of line character
22:07:52 <jakob1> oh ok. thank you pavonia! i saw an example like this:
22:07:53 <jakob1> .. skipMany (noneOf "\n\r") >> endOfLine
22:07:53 <jakob1> but i'm not convinced... isn't there already a function that skips anything until EOL? do i really have to define EOL ("\n\r") myself?
22:10:19 <pavonia> jakob1: parsec has many parser combinators, I thinl there's also manyTill
22:10:23 <pavonia> *think
22:12:22 <kadoban> jakob1: endOfLine is a parser that parses '\n' or "\r\n". I'd think you'd use that and manyTill
22:12:38 <kadoban> (you might need 'try endOfLine', not sure … probably do)
22:19:55 <Guest00000> i need a constraint which says Eq (f a), Typeable (f a), Typeable (f b) and also for all b for which this constraint holds, the same constraint for (c -> b) instead of b
22:20:13 <Guest00000> cyclical classes are illegal
22:23:04 <Guest00000> in other words i want:    class (Eq (f a), Typeable (f a), Typeable (f b), Constr f a (c -> b)) => Constr f a b
22:23:24 <Guest00000> and then my function will have type (Constr f a b) => ......
22:25:27 <jakob1> pavonia, kadoban: thank you. manyTill sound's good. should still be possible to ignore the parsed data like in skipMany... maybe by appending ">> return ()"? but i'll try to extract the information out of the cabal file by using the cabal library.
22:27:19 <pavonia> :t void
22:27:21 <lambdabot> Functor f => f a -> f ()
22:27:24 <jakob1> Guest00000: i think i've learned in my haskell class, that one usually don't put constraints in the class definition but rather in the "method"/function definion
22:27:59 <jakob1> that was also mentioned in LYAH, i look it up
22:29:31 <Guest00000> how do i put such recursive constraint in the function type then?
22:34:10 <jakob1> sry, i think i was wrong. what i said appies for data definitions:
22:34:11 <jakob1> "However, it's a very strong convention in Haskell to never add typeclass constraints in data declarations."
22:34:11 <jakob1> - http://learnyouahaskell.com/making-our-own-types-and-typeclasses
22:37:53 <Lokathor> jakob1, you're right, but also what you're saying is a little less applicable to Guest00000 becaues they're well into the weeds with advanced type gymnastics
22:45:24 <varaindemian> can anyone explain me this code/function (line by line)? http://pastebin.com/SSrtP5TG
22:47:38 <pavonia> varaindemian: What part don't you understand?
22:47:54 <varaindemian> pavonia: starting with eval (toDigits n) == n
22:48:05 <varaindemian> what is that eval thing?
22:48:19 <thimoteus> basically it turns a list of digits into the number that lists represents
22:48:45 <Lokathor> [1,2,3] becomes 123
22:49:10 <kadoban> varaindemian: It tells you what eval is down at the bottom
22:49:58 <varaindemian> kadoban: how about foldl and that lambda function?
22:50:11 <Lokathor> :t foldl
22:50:13 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
22:50:52 <Lokathor> you take (a function that has an old value, some input, and gives a new value), a starting value, a thing with new values in it
22:51:03 <Lokathor> and it accumulates them all up into a final result
22:51:23 <Lokathor> like so
22:51:23 <Lokathor> > foldl (\x y -> y + (10 * x)) 0 [1,2,3,4,5]
22:51:25 <lambdabot>  12345
22:52:01 <Lokathor> think of it as (\acc new -> new + (10 * acc))
22:52:59 <varaindemian> Lokathor: and all (\d -> d >= 0 && d < 10) (toDigits n) ?
22:53:11 <Lokathor> :t all
22:53:13 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
22:53:46 <Lokathor> all takes a predicate (a function that tests a value), and a thing with values in it, and then says if they all pass the predicate or not
22:54:53 <Lokathor> Foldable t means, roughly, "a structure with values in it that you can use foldl or foldr to combine together in some way"
22:55:36 <Lokathor> the l and r "fold" is because it's usually thought of in terms of lists at the basic level, and you can fold up a list from the left or right
22:55:47 <Lokathor> but it works on other things too, like a binary tree
22:56:34 <Lokathor> so it depends on if you have a left-associative folding operation or a right-associative one
22:56:40 <Lokathor> sometimes it doesn't matter, like (+)
22:56:53 <Lokathor> but sometimes it does a lot, like (^) or (-)
22:57:30 <Lokathor> > foldl (^) 2 [2,3,4]
22:57:31 <lambdabot>  16777216
22:57:33 <Lokathor> > foldr (^) 2 [2,3,4]
22:57:38 <lambdabot>  mueval-core: Time limit exceeded
22:58:22 <echo-area> Is there a way to provide in a class definition default implementations of methods of a constraining class?
22:58:40 <Lokathor> yes
22:58:54 <echo-area> Lokathor: How?
22:59:38 <Lokathor> well, you give a definition, and usually you give it in terms of other methods
22:59:44 <Lokathor> and usually it's circular
22:59:56 <Lokathor> so that the user can define one or the other of two things, for example
23:00:00 <Lokathor> and the other will have a default
23:00:11 <echo-area> I tried that but there were errors like ‘f’ is not a (visible) method of class ‘B’
23:00:12 <Lokathor> like with Eq you can define (==) or (/=) and it'll figure the other one out
23:00:29 <Lokathor> hmm, you should make an lpaste of what you tried
23:01:05 <lpaste_> echo-area pasted “default implementation of constraining class” at http://lpaste.net/144709
23:01:12 <echo-area> I tried this
23:02:00 <Lokathor> ah, hmm, i'm not sure you can do it like that
23:02:16 <Lokathor> you need to have fully defined how a thing fits into A
23:02:26 <Lokathor> before it can be a B
23:02:35 <Lokathor> so at that point it will already have a definition for f
23:03:29 <echo-area> You mean if there were a default implementation in A, then there can be an overridden implementation in B?
23:03:58 <Lokathor> hmm, i also don't think so. Haskell typeclasses don't let you overload in a subclass like you can in Java or Python
23:04:23 <echo-area> I see.  Thanks
23:04:24 <Lokathor> subclasses are strict supersets, they add features only, they don't change the base class definitions
23:04:34 <glguy_> Echo-area: you can't really do that. You can implement a new top level default definition for f in terms of g and manually use that to help implement your A class
23:05:19 <echo-area> glguy_: Oh right, and that way seems cleaner.
23:06:00 <glguy_> See fmapDefault and foldMapDefault as examples from Data.Traversable
23:06:30 <echo-area> Okay, thanks
23:09:34 <Lokathor> PS, printing out foldr (^) 2 [2,3,4] took more digits than fit into the default scrollback history of cmd.exe, but ghci was happy to do it without any overflow nonsense. Thanks Integer
23:23:44 <akegalj> hey, do you think using http://flutter.io/faq/ might be a good way to cmpile haskell to mobile (ios, android). It says it is "a functional-reactive framework" so there might be some route like reflex for Flutter ?
23:28:31 <jle`> Lokathor: thank you for the nice screensaver/pretty show
23:29:35 <Lokathor> the other day i had it print out about 300 million numbers from 1 to 10, but the fact that some of them were 10 made it not end up perfectly even from line to line
23:29:43 <Lokathor> looked like weird ascii flames
23:33:05 <Fylwind> trying to come up with an elegant way to manage a concurrent system where you have 1 consumer and N producers, and the consumer needs to choose between the N producers in a deterministic way (which depends on what the producers are producing) … any ideas?
23:33:46 <Lokathor> can you be more specific at all?
23:34:11 <Lokathor> sounds like you want to pull items out of a message queue
23:34:32 <Fylwind> kind of like that but there the consumer needs to consume them in the right order
23:35:03 <Fylwind> the producers produce a stream of values (say, numbers), and the consumer needs to repeatedly grab the 'least' value out of the N producers 
23:35:24 <Lokathor> well, could they each insert elements into some sort of ordered list
23:35:33 <Lokathor> and when the consumer is ready, it pulls off the top?
23:37:07 <Fylwind> hrm, so I guess could store an ordered list of MVars?
23:37:42 <Lokathor> yeah, with modifyMVar and such
23:38:05 <Lokathor> should work out. as long as they don't overwhelm the consumer
23:38:41 <Fylwind> well the thing is, the producers needs to block if the consumer has not consumed their respective item
23:38:52 <Lokathor> ohh, now that gets tricky
23:39:14 <Fylwind> the difficulty I guess, is that the blocking criterion for producers and consumers are not the same
23:39:29 <Lokathor> i think you could rig up an STM thing
23:39:43 <Lokathor> where each producer holds a TVar
23:40:15 <Lokathor> and the consumer pulls values out, sorts them if there's more than one, puts all the rejects back, and then the transaction returns the one good value
23:41:13 <Lokathor> but... i think you'd hit a lot of problems that way unless the queue was either totally full or totally empty
23:41:27 <bernalex> is there a nice way of generalising f (g a) (h a)?
23:41:38 <Fylwind> Lokathor: what problems? o.o
23:42:02 <Lokathor> well, STM restarts the transaction if any TVar it depends on changes value before it's finished computing the transaction.
23:42:20 <bernalex> I guess liftM2 f g h
23:42:30 <Lokathor> so if the queue was partly full, and someone finishes their production they can put their var in really fast, which would restart the consumer's transaction
23:42:31 <Fylwind> Lokathor: ah, you mean efficiency
23:42:57 <Fylwind> Lokathor: would a mutex make this less of an issue?
23:43:00 <Lokathor> and the consumer would keep getting interrupted trying to compare and sort them all until the queue was full
23:43:17 <Lokathor> MVar would also work
23:43:29 <Lokathor> i guess if the producers are going to block anyway
23:43:43 <Fylwind> I mean I don't expect this to have 10000's of threads so I'm not too concerned as long as it's reasonable
23:44:08 <Fylwind> Lokathor: thanks for the suggestion ^.^
23:44:35 <Lokathor> well, with STM, the queue would fill all the way up before the consumer could pick (probably)
23:45:04 <Lokathor> with MVar, whenever the consumer went to pick a value the producers would have to hold their next value pending while it picked from whatever was available when it started the comparison
23:46:12 <Lokathor> with STM, if values are produced much slower than they're consumed, the queue would stay empty most of the time, and it'd be able to pick 1 value out relateively quickly
23:46:50 <Lokathor> it's all kinda "wibbly wobbly" i think unless you actually test it out
23:49:34 <Fylwind> Lokathor: I don't think I'll notice since all the data will come from the network :P
23:49:46 <Lokathor> oh, :P
23:50:27 <Fylwind> FWIW I'm attempting to write an inverse multiplexer for TCP
23:58:14 <nullx002> hi there
23:58:20 <nullx002> any video tuts for monads?
23:59:34 <Lokathor> nullx002, have you learned about Functor and Applicative yet?
23:59:57 <bernalex> nullx002: what do you mean by "monads"? what do you want to learn about them?
