00:15:54 * hackagebot markup 2.1.0 - Abstraction for markup languages  https://hackage.haskell.org/package/markup-2.1.0 (athanclark)
00:40:54 * hackagebot urlpath 3.2.1.1 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-3.2.1.1 (athanclark)
00:45:48 <NoobsE> Hi, anyone here who works as a programmer in Haskell?
00:50:51 <shanemikel> NoobsE: why?
00:53:02 <zomg> NoobsE: there are many who fit the bill here, I've used haskell professionally a bit as well but not full time
00:53:59 <NoobsE> Just i learning haskell and some times ask myself - why? can i find real work with it?
00:54:43 <shanemikel> NoobsE: not I, so far, but they exist (and afaict it seems to be gaining traction quickly).. if you come back during a US day/afternoon, you're likely to find some anecdotes
00:55:42 <zomg> Yeah, there's adoption in finance and at Facebook at least
00:55:57 <zomg> and those just off the top of my head that I've heard of here :)
00:56:16 <shanemikel> also, if you are a tech lead on a project, you're likely gonna have some freedom to pick the best (in your opinion) tech (often including language) for the job.. I've noticed their has been a growing interest amongst tech companies to diversify their technological interest.. facebook as zomg said, has them, and ship haskell web server as one of the many in their react demo
00:57:15 <zomg> as a CTO I would love to pick Haskell but sadly I'm the only person in our team who speaks it :)
00:57:46 <shanemikel> zomg: I've read some interesting stuff in the google group forum for commercial haskell sig
00:59:09 <shanemikel> if they have other experience with functional language, it's likely not too far off for learning.. functional languages in general also appear to have a significant rise of commercial interest lately
01:04:16 <shanemikel> a lot of interest in funtional reactive programming.. even a haskell look-alike javascript-transpiling language... not to mention the recent growth of scala (functional programming on the JVM)
01:06:10 <shanemikel> besides (and take everything I say with a grain of salt, because I'm new at this, and still a student, but I'm curious about the same things as you, most likely).. the work you might do with haskell vs. a more common language is likely to be more interesting.. such is the nature of a niche, no?
01:10:32 <zomg> Depends on the field, I've used Haskell mostly for web development related things :)
01:11:20 <zomg> Obviously I find that fun, but it might not be what everyone considers "more interesting". But obviously since Haskell is being used in more niche fields like finance and PL research, there are certainly all kinds of things
01:12:41 <shanemikel> yeah, honestly the web is likely a huge factor of the growth of interest in functional lanuages.  with the 'cloud' and interest rising towards web distributed microservice systems (containers especially), you're gonna see a lot more freedom in using a variety of languages for specific tasks
01:13:13 <rvb> I would also like to program in Haskell.  But once in a year, when I get to implement something, I end up using C++ because it has larger libraries. :-/
01:13:42 <ww> rvb: larger libraries is a good thing?
01:15:40 <rvb> ww: If you do not have to implement lots of graph algorithms from scratch because they are already implemented in an efficient way, that is good, yes.
01:16:59 <tabemann> even when it comes to larger libraries, why not Java then? really, the only thing I'd use C++ for new system-wise is when I need to wring the last bit of performance out of the system or when I don't have enough memory space for a "bigger" language but have enough that I don't have to code in straight C
01:18:11 <tabemann> at least with Java you have a garbage collector, whereas with C++ you have to hand-code all your memory management, which is error-prone, or use a separate conservative garbage collector library, which is less efficient than one built into the language environment
01:18:47 <rvb> tabemann: Sorry, manual memory management in C++ is usually unecessary, and so is the garbage collector.
01:18:54 <rvb> Don't use new, then you do not have to "free".
01:19:19 <Juliver_> As a relatively experienced programmer with zero haskell (or any other functionaly programming language), the main factor is that its hard for me to imagine how would big systems with long life-time would be built using haskell. Its so different that OO languages we're so used to, that the concerns amount, and I haven't yet read a case-study of someone building a big system using haskell.
01:19:29 <rvb> Using the standard containers, you do not have to care for memory allocation at all.
01:19:32 <tabemann> the thing is that allocating everything statically limits to what memory usage you can imagine ahead of time and the size of the stack, for stack allocation
01:19:49 <rvb> tabemann: No.
01:19:57 <NoobsE> rvb: why not Lisp? It is old language with huge libraryes.
01:20:01 <rvb> You just use the standard containers, they do all the new/delete stuff.
01:20:30 <rvb> I actually use C++ just like some C with convenient containers and templates. :-)
01:20:35 <tabemann> doing things that way means that you can only encode data structures that can be implemented with, say, STL
01:20:56 * hackagebot diff-gestalt 0.1.0.0 - A diff algorithm based on recursive longest common substrings  https://hackage.haskell.org/package/diff-gestalt-0.1.0.0 (chrismwendt)
01:21:34 <tabemann> and forget about passing data structures between functions except either by reference (where then you can't mutate any of those data structures) or by copying (which is highly inefficient)
01:21:41 <rvb> NoobsE: Depends on what one wants.  I am concretely interested in pre-implemented graph algorithms.
01:22:22 <shanemikel> Juliver_: define big
01:22:41 <tabemann> anyways, I should hit the sack soon
01:22:49 <rvb> And C++ has the very nice COIN-OR library, which implements all that stuff like all-pair shortest paths, uncapacitated min-cost flows, etc.
01:22:59 <Juliver_> shanemikel: big = worked on by 3 talented engineers for 4 months.
01:23:33 <pyon> What's the difference between a mutable array and an immutable array whose contents are reference cells?
01:24:12 <shanemikel> well, for one, haskell itself
01:24:26 <shanemikel> a lot more than 3, a lot more than engineers, and a lot more than 4 months
01:24:45 <rvb> tabemann: Yes, of course using Haskell would be nicer.  But I certainly prefer C++ over Java. :-)
01:26:34 <shanemikel> Juliver_: their are quite a few use studies online
01:26:37 <nitrix> Hi, is there any reason why Ix doesn't have a String instance?
01:27:08 <Juliver_> shanemikel: could you point me to one that you think drived the point home?
01:27:19 <tabemann> because arrays aren't hashtables?
01:29:32 <shanemikel> Juliver_: well, it's difficult to see how long anything took, how big the codebase is, or how many engineers worked on a project when it's not open source
01:29:49 <Juliver_> shanemikel: yep.
01:30:25 <potatoe> there are a lot of places that use Haskell for long term projects (including banks etc)
01:30:36 <potatoe> worked on by a lot more than 3 talented engineers
01:31:23 <shanemikel> Juliver_: what's the domain you're looking for, and what are your concerns?
01:31:55 <potatoe> I'm a beginner myself but I like it because the language forces me to think more about what I write
01:32:44 <potatoe> and I think thats a good thing when working on long term projects as well
01:34:25 <Juliver_> shanemikel: domain: web based service, concerns: how easy would it be to maintain a large code-base. I know the pros/cons of, say, Java OO - and in general I know that if we build it right, it can grow significantly and still be stable and easy to maintain. I don't know how this would work for haskell
01:43:11 <shanemikel> I have read great endorsement's of codebase maintenance ease of haskell programs.  For one, the type system is way smarter than any other, so better compile-time checks.  Two, functional languages encourage writing more modular programs that are, therefore, easier to unit-test (and recursion encourages thinking about errors in terms of base-cases, also several applicatives are designed for implicit error handling).  Three, as far as
01:43:11 <shanemikel> UIs go, FRP has a ways to go, so I'd be hesitant to commit to doing that in haskell. Four, if you design your web service to be modern, you ought not to be concerned about large codebases so much, but a collection of independent, smaller services and cooperation amongst them.  So, I'd look into haskell http clients, database drivers, and haskell idioms and libraries that lend to clean consumption of streaming communications and
01:43:12 <shanemikel> asynchronous operations.
01:45:49 <shanemikel> besides, if you design your system in terms of microservices, it becomes much more realistic to implement parts of the system in various languages.  so easy to experiment with low cost
01:50:30 <shanemikel> Juliver_: maybe you'd be interested in this (provides an example of asynchronous io in haskell) http://chimera.labs.oreilly.com/books/1230000000929/ch08.html
01:56:49 <shanemikel> Juliver_: the PureScript javascript transpiler is written in haskell https://github.com/purescript/purescript, and FP Complete (provides managed hosting and haskell IDE) is a for-profit company, I'd guess they build a lot of their stuff with haskell
02:01:32 <zomg> Funny, I would not consider Java easy to maintain at all :)
02:01:44 <zomg> and I'm a JavaScript developer by day...
02:01:45 <zomg> :P
02:02:20 <Jinxit> how is java comparable to javascript?
02:02:37 <zomg> It isn't, except that they're both fairly hard to maintain :P
02:02:49 <zomg> Well, largely depends on the codebase I guess
02:03:01 <Jinxit> well written java is easy to maintain
02:03:16 <Jinxit> easier than say c++
02:03:24 <zomg> That's true
02:03:45 <zomg> Sadly my professional experience with Java and thus my opinions of it are a bit clouded by the terrible enterprise systems...
02:03:48 <zomg> :D
02:04:49 <shanemikel> he's comparing a language that's regarded as aweful by it's biggest fans, and his experience with it, to the most popular and (by many considered scalable) lanuage in use today
02:05:34 <nitrix> Is there an easier way to write: f x a b = h x a b $ g x a b ?
02:05:55 <nitrix> @pl f x a b = h x a b $ g x a b
02:05:55 <lambdabot> f = ap (ap . (ap .) . h) g
02:06:00 <nitrix> Ew.
02:07:41 <nitrix> @pl f x a b = h (g x a b) a b
02:07:42 <lambdabot> f = flip flip id . (ap .) . join . ((flip . (h .)) .) . g
02:07:52 <nitrix> Not getting any better. Oh well.
02:12:10 <shanemikel> I hope he troubled himself to read the monologue I generously prepared at his request...
02:12:27 <jle`> nitrix: foo x a b = h x a b (g x a b) is what i'd do :)
02:23:34 <Juliver> shanemikel: thanks!
02:28:02 <athan> Is there a way to browse instance definitions from ghci?
02:28:27 <athan> I'm trying to find the associated data type instance for a template-haskell generated Persistent instance :\
02:28:49 <athan> For some reason, it doesn't look like the typeclass magic creates the record fields I need :(
02:34:28 <hc> moin all, i'm using yesod with postgresql, and i'd like to have BIGSERIALs for the ids of the tables, instead of SERIALs. is there a way to achieve this?
02:56:55 <cache> !ping
02:57:50 <joco42> test
02:57:59 <cache> there you go joco42 
02:58:20 <joco42> cache:  i am using limewire client
02:58:30 <joco42> irc-cloud is not working for #haskell
02:58:39 <cache> I'm on irccloud right now
02:58:41 <cache> https://www.irccloud.com/#!/ircs://chat.freenode.net:6697/%23haskell
02:58:43 <cache> try that
02:58:49 <cache> llimewire has irc?
02:58:55 <cache> I thought it was like a P2p file sharing
02:59:27 <zyme_> Hi
02:59:59 <cache> hi zyme_ 
03:00:31 <joco42> sorry limechat
03:00:50 <joco42> is #haskell working fine on irccloud ?
03:00:57 <joco42> for other haskelleres?
03:01:14 * hackagebot urlpath 3.3.0 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-3.3.0 (athanclark)
03:05:00 <joco42> i'm in haskell :)
03:05:18 <joco42> seems to work now
03:05:31 <cache> nice joco42 
03:06:26 <zyme_> I still hadn't tried anything, lol..
03:06:29 <joco42> what i wanted to ask here, from the haskellers is, if there is a way to solve this type error ?
03:06:39 <joco42> https://usercontent.irccloud-cdn.com/file/wsRKnNVG/Screen%20Shot%202015-11-08%20at%2012.50.19.png
03:08:04 <joco42> here is a better picture  - cursor showing the problem https://usercontent.irccloud-cdn.com/file/NvLhnMjv/Screen%20Shot%202015-11-08%20at%2013.07.15.png
03:08:29 <joco42> why can i not abstract over applyTo ?
03:08:39 <joco42> java could do this
03:08:45 <joco42> :)
03:09:59 <joco42> is this again the case of existentials?
03:11:19 * hackagebot markup 2.1.1 - Abstraction for markup languages  https://hackage.haskell.org/package/markup-2.1.1 (athanclark)
03:20:26 <mgsloan> joco42: Yup, existentials.  Should work if you put an explicit type sig on your function
03:21:46 <joco42> mgsloan:  expl. type sig ? with existentials ?
03:22:08 <joco42> the problem is that now i need this code duplication again ... https://usercontent.irccloud-cdn.com/file/QWbS8IcL/Screen%20Shot%202015-11-08%20at%2013.20.52.png
03:22:39 <joco42> so mgsloan  would existentials with explicit type sig solve this problem ?
03:23:54 <joco42> ok, now i put there a todo note :) https://usercontent.irccloud-cdn.com/file/A6AOzqi6/Screen%20Shot%202015-11-08%20at%2013.23.09.png
03:24:04 <joco42> i will do it what i get retired....
03:24:41 <joco42> but for now, i put a pizza into the oven...
03:24:53 <joco42> it seems i really need to learn existentials.... 
03:33:03 <joco42> phadej helped me to solve it :) cheers phadej ! 
03:33:14 <joco42> https://usercontent.irccloud-cdn.com/file/dZqduQBh/Screen%20Shot%202015-11-08%20at%2013.32.06.png
03:33:55 <arianvp> are there any good nice and functional cuda bindings for haskell?
03:34:05 <arianvp> Gotta do image processing.... but C and python are ... inferior
03:34:24 <phadej> arianvp: accelerate ?
03:34:33 <arianvp> https://hackage.haskell.org/package/CV oh this seems nice too
03:34:36 <arianvp> bit undocumented thouh
03:35:45 <arianvp> phadej: that looks nice htanks
03:37:00 <phadej> arianvp: interstengly, I'm thinking of porting http://www.eliteraspberries.com/blog/2013/04/image-interpolation-with-the-fast-fourier-transform.html to JuicyPixels data...
03:37:10 <phadej> but maybe I'll wait till you do it for me ;)
03:38:58 <joco42> now the code looks much nicer :) https://usercontent.irccloud-cdn.com/file/GhRcJXFQ/Screen%20Shot%202015-11-08%20at%2013.35.42.png
03:39:42 <zzing> When I ask run "stack haddock" where does it put stuff? I needed to install hscolour to get the links between documents, but I would need to restart the haddock command - but it only resumes.
03:43:14 <arianvp> phadej: I absolutely hate image processing
03:43:16 <arianvp> tbh
03:43:24 <arianvp> that's why I want a nice library :P
03:45:00 <rmrfroot> anyone familiar with aeson that can tell me why `decode "[1]" :: Maybe [Int]` is parsed and why `decode "1" :: Maybe Int` fails?
03:45:27 <arianvp> rmrfroot: because optional values are encoded to JSON as being [a] or []
03:45:55 <arianvp> (I think)
03:47:08 <rmrfroot> arianvp: ah, ok! thanks! how would i decode responses from a REST API that can return a single scalar? for example the body consists of a single JSON string value.
03:47:58 <phadej> rmrfroot: which aeson version do you use
03:48:32 <rmrfroot> phadej: aeson ==0.8.0.2,
03:49:01 <ChristianS> rmrfroot: try 0.10 or higher
03:49:23 <ChristianS> rmrfroot: older aeson versions only allowed arrays and objects at top level
03:49:42 <rmrfroot> ChristianS: alright, thanks for the heads up :)
03:50:14 <phadej> rmrfroot: or use Data.Aeson.Compat from aeson-extra!
03:51:11 <phadej> λ Prelude Data.Aeson.Compat > decode "1" :: Maybe Int
03:51:11 <phadej> Just 1
03:51:21 * hackagebot hsimport 0.6.7 - A command line program for extending the import list of a Haskell source file.  https://hackage.haskell.org/package/hsimport-0.6.7 (DanielTrstenjak)
03:51:23 <rmrfroot> phadej: ah, cool! will check that out :)
03:51:24 <phadej> with lts-3.11 (aeson-0.9 i guess)
03:52:03 <rmrfroot> phadej: i'm using lts-3.7 ATM
03:52:36 <phadej> rmrfroot: IIRC it made only around 3.10 in actual lts, but works with lts-2.22 and up.
03:53:13 <rmrfroot> phadej: ah ok! i will give it a try
03:54:24 <rmrfroot> phadej: worked like a charm, thanks a lot :)
03:55:05 <meditans> hi all, I'd like to ask a question about the tutorial in https://github.com/bennofs/quickcheck-property-monad
03:56:14 <meditans> in the function `prop_satisfies_invariant`, the function `sized` expects a `Gen a`, but gets a `Property` (generated by `property`)
03:56:44 <meditans> so this doesn't work, but how could I get the effect the tutorial is trying to achieve?
04:02:04 <meditans> ok, solved. The problem was this: http://hackage.haskell.org/package/QuickCheck-2.8.1/docs/Test-QuickCheck-Property.html#t:Property
04:02:15 <meditans> (the backwards compatibility note)
04:06:22 * hackagebot idris 0.9.20 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.9.20 (EdwinBrady)
04:56:23 * hackagebot HaRe 0.8.2.1 - the Haskell Refactorer.  https://hackage.haskell.org/package/HaRe-0.8.2.1 (AlanZimmerman)
04:56:55 <KkK1337> http://umbrella-security.blogspot.com/2015/11/anonymous-proxy-list-sunday-8th-of.html
05:37:25 <zett_zelett> In this rant https://www.youtube.com/watch?v=87re_yIQMDw, someone named Brian Hurt uses length, foldr etc on tuples – how? What library is he using?
05:40:22 <Gurkenglas> It's not a library, tuples have a Foldable instance: It interprets the second argument as the only element of the structure, and the first element as decoration.
05:40:57 <Gurkenglas> > Data.Foldable.toList (undefined, "abc")
05:40:59 <lambdabot>  ["abc"]
05:42:31 <zett_zelett> What definition of length is he using though? “length (1,2)” gives me type errors (as expected) ((which actually made me go “wat” when he showed the result was 1)).
05:42:59 <pavonia> > length (1, 2)
05:43:01 <lambdabot>  1
05:43:08 <Jinxit> > length (1, 2, 3)
05:43:09 <lambdabot>      No instance for (Foldable ((,,) t0 t1))
05:43:10 <lambdabot>        arising from a use of ‘length’
05:43:10 <lambdabot>      In the expression: length (1, 2, 3)    No instance for (Num t0) arising ...
05:43:26 <pavonia> Why is it 1?
05:43:44 <zett_zelett> When I run this in my ghci, I get “Couldn't match expected type ‘[a0]’ with actual type ‘(t0, t1)’”
05:44:05 <Gurkenglas> pavonia, see my last two lines
05:44:12 <zett_zelett> >:t length
05:44:22 <zett_zelett> Do I need to put in a space?
05:44:25 <zett_zelett> > :t length
05:44:26 <pavonia> zett_zelett: Your compiler/base version is too old apparently
05:44:27 <lambdabot>  <hint>:1:1: parse error on input ‘:’
05:45:07 <zett_zelett> Ah, ok.
05:45:26 <gfixler> zett_zelett: ghc --version
05:45:39 <zett_zelett> I have 7.8.4.
05:45:53 <gfixler> zett_zelett: https://wiki.haskell.org/Foldable_Traversable_In_Prelude
05:46:03 <gfixler> the FTP dropped in 7.10
05:46:17 <gfixler> Foldable... Foldable Everywhere
05:48:16 <gfixler> zett_zelett: and there was much gnashing of teeth. https://twitter.com/headinthebox/status/652831657083465728
05:59:50 <meta-coder> How do I get minBound and maxBound of the type of a given value?
06:02:29 <hpc> :t \x -> minBound `asTypeOf` x
06:02:30 <lambdabot> Bounded a => a -> a
06:02:42 <hpc> @let minOf x = minBound `asTypeOf` x
06:02:46 <lambdabot>  Defined.
06:02:51 <hpc> > minOf (100 :: Word8)
06:02:53 <lambdabot>  0
06:02:57 <hpc> > minOf (100 :: Int
06:02:59 <lambdabot>  <hint>:1:18:
06:02:59 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:03:00 <hpc> > minOf (100 :: Int)
06:03:02 <lambdabot>  -9223372036854775808
06:03:20 <breadmonster> :t asTypeOf
06:03:21 <lambdabot> a -> a -> a
06:04:37 <hpc> @src asTypeOf
06:04:37 <lambdabot> asTypeOf = const
06:04:54 <hpc> understanding how that one works is a good exercise
06:06:16 <StoneToad> :t const
06:06:17 <lambdabot> a -> b -> a
06:07:08 <StoneToad> ... oh the actual source for asTypeOf must have an explicit type sig
06:07:43 <hpc> yeah
06:12:58 <gfixler> why is minBound incapable of resolving to Int when given (100 :: Int)?
06:13:11 <hpc> gfixler: typo, missed a paren
06:13:26 <gfixler> hpc: I mean by itself, without asTypeOf
06:13:35 <gfixler> > minBound (100 :: Int)
06:13:36 <hpc> :t minBound
06:13:36 <lambdabot>      No instance for (Show a0)
06:13:37 <lambdabot>        arising from a use of ‘show_M98044857442602634016607’
06:13:37 <lambdabot>      The type variable ‘a0’ is ambiguous
06:13:37 <lambdabot> Bounded a => a
06:13:39 <gfixler> that
06:13:56 <hpc> because minbound doesn't take an argument
06:14:00 <gfixler> hpc: oh, duh
06:14:04 <gfixler> right, not a function
06:14:20 <hpc> though it can if you're a terrible person and write the instance
06:14:25 <gfixler> :)
06:14:25 <hpc> but don't ;)
06:14:40 <gfixler> asTypeOf lightly upsets me
06:14:48 <gfixler> but that's just because it reminds me of 'as' in C#
06:14:58 <gfixler> which coerces types to parent types or something
06:15:01 <meta-coder> I can't do > let x = 1 in minBound `asTypeOf` x  ⏎ but > > let x = (1::Int) in minBound `asTypeOf` x
06:15:35 <gfixler> :t 1
06:15:37 <lambdabot> Num a => a
06:15:40 <gfixler> 1 isn't an Int
06:16:08 <meta-coder> Num doesn't have minBound?
06:16:24 <meta-coder> Oh, why would it.
06:16:44 <hpc> meta-coder: it doesn't know which numeric type to use
06:16:58 <hpc> meta-coder: as you can see from my examples above, the result is very different depending which you pick
06:18:39 <meta-coder> hpc: Got it. Thanks a lot. 
06:18:58 <filsmick> hello! I'm coming the Rust language, and I might give Haskell a try. If there's somebody who knows both Haskell and Rust here, I'd love to learn how they compare.
06:19:16 <filsmick> uh, coming from*
06:19:31 * meta-coder wonders if `asTypeOf' is some special sauce or could I have implemented it? Yeah, I should read the source to know it.
06:22:14 <dcoutts> @src asTypeOf
06:22:15 <lambdabot> asTypeOf = const
06:22:24 <dcoutts> mm, but the type is special
06:22:28 <dcoutts> sTypeOf                :: a -> a -> a
06:22:28 <dcoutts> asTypeOf                =  const
06:22:33 <dcoutts> meta-coder: ^^
06:23:48 <aphocus> does hlint not warn about unused imports?
06:24:12 <meta-coder> StoneToad: dcoutts: gfixler: thanks
06:24:35 <ChristianS> aphocus: ghc -Wall certainly does
06:25:00 <hpc> does it also check for instance-only imports?
06:25:11 <aphocus> ChristianS, Ahh that explains why!
06:26:02 <bennofs> hpc: yes, -Wall does (it tells you to use import Foo() if you only need instances from Foo)
06:29:04 <Ge_> Hi
06:29:11 <lf94> Hey, so I have a problem here. I know how to do it by writing a recursive function but I'm trying to stick to Prelude functions. I have a [[(a,b)]], that needs to be populated with values. Right now it's empty ([[],[],[],[]...1000 more later...]), and I have a list of [("a",1),("b",2)...and so on...]. I need to insert those elements into that list of lists.
06:30:29 <lf94> It's really hard to describe....I guess code will be better.
06:30:32 <Jinxit> sounds like you're solving the wrong problem
06:31:36 <lpaste_> lf94 pasted “List confusion” at http://lpaste.net/144879
06:32:14 <lf94> Like, in a language with mutation...emptyHashMap would be a reference that goes off to be modified
06:32:45 <lf94> My problem is trying to find a function available in Prelude that solves this problem.
06:33:27 <lf94> Basically convert from one data structure to another, but they are very similar...except one can't change in size
06:33:38 <StoneToad> can't change in size?
06:34:06 <lf94> emptyHashMap has to remain (length hashMap)^2
06:34:24 <StoneToad> also, what you want is probably in something like Data.Map or Data.List, rather then in the prelude directly
06:34:26 <lf94> So I literally want to pass an empty data structure to be filled
06:34:31 <mauke> lf94: why are you building a hash on top of a list?!
06:34:43 <lf94> mauke: because fun learning experience? :D
06:34:56 <mauke> learning what?
06:34:58 <lf94> I know, I can use Array and whatever
06:35:06 <lf94> learning how to implement a hash map
06:35:07 <StoneToad> um, I think you're using your tools wrong?
06:35:12 <mauke> the point of a hash is efficient lookup
06:35:17 <lf94> I know
06:35:25 <mauke> if you're going to use lists, you may as well use lookup
06:35:27 <mauke> :t lookup
06:35:29 <lf94> m(
06:35:29 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
06:35:38 <StoneToad> having an empty nonmutable datastructure forced to take up extra space is rather pointless isn't it?
06:35:40 <lf94> I'll change to Array soon enough
06:36:21 <lf94> StoneToad, for now, yes
06:36:26 <lf94> It's just a pointless exercise
06:36:31 <StoneToad> IIRC Vector is the recommended 'array' library for normal stuff atm
06:36:45 <mauke> lf94: this code makes no sense to me
06:36:54 <mauke> what is emptyHashMap good for?
06:37:12 <lf94> at that very moment, the length
06:37:32 <lf94> and being able to have an element inserted anywhere
06:37:37 <lf94> within that length
06:37:44 <StoneToad> also wait, why are you making a 1000 element tuple?
06:37:59 <lf94> So I can insert anywhere within 1000 elements?
06:38:00 <StoneToad> oh nm, it's a nested list
06:38:15 <StoneToad> insert = you get a new list
06:38:38 <lf94> insertOrUpdate
06:38:45 <StoneToad> that still gives you a new list
06:38:49 <lf94> I know
06:38:56 <lf94> A list with 1000 elements still :)
06:39:11 <StoneToad> just use MVectors right away if that's what you want
06:39:28 <lf94> I like pain and torture though
06:39:35 <lf94> why else am I using Haskell?
06:39:39 <lf94> :>
06:39:55 <StoneToad> otherwise, you should probably be using a map
06:40:11 <StoneToad> or at least an assoclist
06:40:11 <lf94> that'd not be as educational
06:40:19 <StoneToad> ... how?
06:40:23 <lf94> The whole hash map is done
06:40:35 <lf94> I just have to grow it once it reaches a certain length now
06:41:34 <lf94> My problem is transforming [("hello",1),("thing",2)] to [[],[],[]...,[("hello",1)],[],[],[],[],[]...,[("thing",2)],[],[]]
06:41:41 <meta-coder> hpc: what if I don't have value of the interesting mytype but of a type:  SomeTypeConstructor mytype?
06:42:21 <umib0zu> Hi all. What’s a partial function? I’m under the impression it’s a function that throws an error on some inputs but I’m not exactly sure.
06:42:45 <hpc> umib0zu: that's exactly it
06:43:05 <hpc> or to be a bit more specific, it's a function that's not defined for some inputs
06:43:54 <umib0zu> ok. I was just reading this discussion and was wondering the context https://www.reddit.com/r/haskell/comments/3rzqxn/more_death_to_partial_functions_add/. So head and tail aren’t “good” because they may crash your program then? I’m guessing they should be wrapped in some sort of Maybe monad correct?
06:45:24 <hpc> umib0zu: you should pattern match on lists, really
06:45:44 <meta-coder> hpc: In a function f :: Ord a => Tree a -> Bool   how do I get maxBound of the type a?
06:45:49 <hpc> umib0zu: or a more non-syntactic answer, you need to know what to do with every case
06:47:54 <varaindemian> head''xs = [fst (a,b) | (a,b) <- zip (show xs) [1..50]] 
06:47:56 <varaindemian> Not in scope: ‘xs’
06:47:57 <varaindemian> Compilation failed.
06:47:58 <varaindemian> λ> 
06:49:50 <MarcelineVQ> head'' xs =
06:50:28 <varaindemian> MarcelineVQ: Yeah, it should have been head'' x
06:51:26 * hackagebot carray 0.1.6.1 - A C-compatible array library.  https://hackage.haskell.org/package/carray-0.1.6.1 (HenningThielemann)
07:06:27 * hackagebot pathtype 0.6 - Type-safe replacement for System.FilePath etc  https://hackage.haskell.org/package/pathtype-0.6 (HenningThielemann)
07:41:01 <varaindemian> how can I make this function to return the same result without using `ord` (without importing Data.Char)? toDigits n = [ord a - 48 | a <- show n]
07:41:08 <orion> Is there a way to have `cabal install` run tests prior to installing?
07:41:43 <varaindemian> It also needs to have this signature toDigitsRev :: Integer -> [Integer] which mine does't have...
07:41:53 <orion> Ah, found it: --run-tests
07:41:59 <varaindemian> sorry, this one: toDigits :: Integer -> [Integer]
07:48:07 <meta-coder> In a function f :: Ord a => Tree a -> Bool   how do I get maxBound of the type a?
07:49:08 <bennofs> meta-coder: for maxBound, you need a Bounded a constraint
07:50:30 <apostolis> Hello! I am learning Haskell from the book learnyouahaskell(.com). I think I found an error on functors.
07:50:31 <meta-coder> bennofs: ok, how would I have done it if it were 'Bounded a' instead of 'Ord a'?
07:51:02 <bennofs> meta-coder: you use the maxBound in a context where a value of type 'a' is expected
07:51:09 <potatoe> apostolis if I may ask, how do you find learning from a book like?
07:51:33 <bennofs> meta-coder: alternatively, you can use ScopedTypeVariables, and the you can write: f :: forall a. Bounded a => Tree a -> Bool; f ... = ... (maxBound :: a) ...
07:52:02 <apostolis> This book is amazing but I have previous experience in catergory theory, so yea .
07:52:13 <meta-coder> bennofs: I  cannot change the prototype of f.
07:52:18 <bennofs> meta-coder: if you have any value of type a laying around, you can also write: maxBound `asTypeOf` someValueOfTypeA
07:52:44 <varaindemian> anyone guys?
07:52:52 <bennofs> meta-coder: alternatively, you can introduce a where clause and write your own `à
07:53:11 <potatoe> apostolis nah I was just wondering because I can't bring myself to actually follow the book at all
07:53:15 <potatoe> that or RWH
07:53:20 <bennofs> meta-coder: ...write your own asTreeTypeOf function: asTreeTypeOf :: a -> Tree a -> a; asTreeTypeOf a _ = a
07:53:43 <bennofs> meta-coder: which you can use like: f tree = (maxBound `asTreeTypeOf` tree) == 0 for example
07:53:45 <apostolis> What do you mean?
07:54:30 <apostolis> It generally takes a lot of time till you start doing some actual work. So you have to wait till the end.
07:54:38 <potatoe> i find that I cannot study from the book. I have learnt more by doing projects and #haskell-beginners 
07:56:01 <apostolis> Well, this is true in general but I already know what the book talks about. I have done it in mathematics, so it is easier to pass things fast.
07:58:32 <apostolis> Anyway, the book says that fmap function takes a functor and returns a functor. That seems wrong.
07:58:48 <potatoe> @type fmap
07:58:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:59:50 <varaindemian> how can I make this function to return the same result  without using `ord` (without importing Data.Char)?  toDigits n = [ord a - 48 | a <- show n]
08:00:18 <apostolis> So it doesn't return a functor but a concrete type. The functor is the process of lifting one function to another function.
08:00:30 <Frankablu> So where is the best description of a Monad?
08:01:33 * hackagebot titlecase 0.1.0.2 - Convert English words to title case  https://hackage.haskell.org/package/titlecase-0.1.0.2 (NikitaKaretnikov)
08:01:44 <liste> varaindemian define your own toDigit with pattern matching, for example
08:02:21 <varaindemian> liste: I'll try
08:02:25 <varaindemian> brb
08:02:39 <apostolis> I hope the author sees this.
08:02:51 <potatoe> Frankablu http://stackoverflow.com/questions/44965/what-is-a-monad 
08:03:04 <meta-coder> bennofs: Why don't types that are totally ordered have upper and lower bounds?
08:03:10 <potatoe> the first answer is practical and helped me personally.
08:03:31 <varaindemian> liste: Actually I need to define my own ord
08:03:40 <nshepperd> apostolis: well, that seems like a vague way of putting it anyway
08:03:48 <Frankablu> Well I've read several descriptions and they all slightly different, so that's why I'm asking for the best, not a description of a monad
08:03:49 <nshepperd> fmap returns a value of the type f b
08:03:54 <Frankablu> *they are
08:03:58 <nshepperd> functions can't return types
08:04:06 <aphocus> apostolis, f b is a functor, I think the key here is to look at what the functor instance is
08:04:10 <potatoe> best is subjective
08:05:07 <nshepperd> yes, it is more accurate to say that 'f' is a functor though
08:05:25 <nshepperd> something of type 'f b' is a 'functorial value' if anything
08:06:38 <green957> hey, I'm trying to use cabal to install bnfc on OSX 10.11 and I keep getting this error "cabal: /usr/bin/ar: permission denied"
08:07:50 <green957> any help?
08:08:40 <rmrfroot> green957: no problem running ar on its own?
08:09:10 <Sornaensis> hello can anyone help me I am trying to build the cabal package certificate-1.3.9 but it is failing, the error says to enable FlexibleContexts but I do not know how to do this when installing a package with cabal
08:09:29 <green957> rmrfroot: idk what it is tbh
08:09:56 <green957> rmrfroot: looks like something to do with archiving
08:10:45 <rmrfroot> green957: seems like you are not alone: https://github.com/haskell/cabal/issues/2653
08:10:59 <varaindemian> liste: toDigits n = [snd (a,b) | (a,b) <- zip (show n) [1..50]]
08:11:18 <varaindemian> Can you think of a better version?
08:11:56 <green957> rmrfroot: trying the 'fixed' binary now
08:12:03 <apostolis> Why is f b a functor? It cannot lift functions. It is not a type construct either? Maybe the definition of a functor in Haskell is eluding me.
08:12:30 <liste> varaindemian you can improve that one a bit: snd (a,b) == b, a is not needed so it can be _, for example
08:13:03 <aphocus> How would I control a c/c++ build option when I compile my app?
08:14:09 <rmrfroot> aphocus: cc-options and cpp-options in your cabal file 
08:14:42 <rmrfroot> aphocus: sorry, cpp-options only applies to Haskell preprocessing. scratch that
08:14:51 <aphocus> rmrfroot, ahh
08:15:11 <rmrfroot> aphocus: ld-options for linker
08:15:16 <meta-coder> How can I constrain the parameter in a data declaration?  'data C a  =>  T a = Cons a' ?
08:15:31 <rmrfroot> aphocus: see "Build information" in https://www.haskell.org/cabal/users-guide/developing-packages.html
08:16:06 <varaindemian> liste: toDigits' n = [snd (_,b) | (_,b) <- zip (show n) [1..50] does't seem to work
08:16:08 <aphocus> rmrfroot, specifically I need to send a build option to GLFW, I guess I might need to modify the default package.
08:17:16 <aphocus> it has VSync hard disabled off with windowed apps in windows >.>
08:17:42 <liste> varaindemian it doesn't, because you can't use _ as a variable
08:17:48 <liste> but snd (_,b) is just b
08:18:32 <rmrfroot> aphocus: ah, maybe you could build it separately and then use extra-libraries to link to your custom build?
08:18:35 <varaindemian> liste: I see, but I have no idea how to can I adapt my code
08:21:08 <liste> varaindemian maybe start with [b | (_,b) <- zip (show n) [1..50]] ?
08:22:50 <Iceland_jack> varaindemian: Check out
08:22:50 <Iceland_jack> > zipWith const [1..50] (show True)
08:22:51 <lambdabot>  [1,2,3,4]
08:23:23 <varaindemian> > :t zipWith
08:23:28 <lambdabot>  mueval-core: Time limit exceeded
08:23:59 <aphocus> rmrfroot, I'm just gonna try cabal get && cabal install, seems easy enough.
08:24:08 <Iceland_jack> Then you can write a function 
08:24:08 <Iceland_jack>     toDigits :: Show a => a -> [Int]
08:24:08 <Iceland_jack>     toDigits = zipWith const [1..50] . show
08:24:28 <Iceland_jack>     zipWith :: (a -> b -> c) -> ([a] -> [b] -> [c])
08:26:36 <Iceland_jack> There are also functions like:
08:26:36 <Iceland_jack> :t imap
08:26:38 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
08:27:32 <MarcelineVQ> "<varaindemian> liste: toDigits' n = [snd (_,b) | (_,b) <- zip (show n) [1..50] does't seem to work" the snd isn't neccesary because you already have the second value of the pair bound to b: toDigits' n = [b | (_,b) <- zip (show n) [1..50]]
08:29:01 <MarcelineVQ> and I see liste already mentioned that and I'm blind
08:31:33 * hackagebot zerobin 1.5.0 - Post to 0bin services  https://hackage.haskell.org/package/zerobin-1.5.0 (ip1981)
08:31:35 * hackagebot markup 2.2.0 - Abstraction for markup languages  https://hackage.haskell.org/package/markup-2.2.0 (athanclark)
08:31:44 <aphocus> rmrfroot, it looks like cabal is doing the job of cmake for the library, so infact using cc-options is actually the correct solution.
08:33:09 <hesiod> Hi. I would like to pipe http-conduits output to a process using streamingProcess from streaming-commons. The former's yields a ResourceT IO (Response (ResumableSource (ResourceT IO) ByteString)), and the typechecker tells me I need a ResumableSource IO ByteString at the end. Now, runResourceT removes the ResourceT, the IO can also be run and responseBody gets the body out of the response, but it's still a
08:33:15 <hesiod>  ResumableSource (ResourceT IO) ByteString at the end (note the extra ResourceT). I'm not really an expert on conduit, so I probably messed something up along the process. Someone got an idea where?
08:33:38 <rmrfroot> aphocus: awesome :)
08:36:51 <c_wraith> hesiod: take a look at https://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html#v:hoist
08:37:11 <c_wraith> hesiod: I'm pretty sure everything in conduit that can be is an instance of MMorph 
08:37:19 <c_wraith> err, MFunctor
08:38:58 <hesiod> c_wraith: thanks, I'll take a look
08:40:09 <aphocus> rmrfroot, and its running at about 60fps :)
08:41:03 <udeos> hello. I'm confused. If I have data with type "IO (Int, StdGen)" how can I get only IO (Int) ?
08:41:25 <pyon> udeos: fmap fst
08:42:32 <pyon> :t fmap fst (undefined :: IO (Int, StdGen)) -- udeos 
08:42:34 <lambdabot> IO Int
08:42:49 <Iceland_jack> :t fmap fst :: IO (Int, StdGen) -> IO Int
08:42:50 <lambdabot> IO (Int, StdGen) -> IO Int
08:44:28 <udeos> fmap fst (random <$> newStdGen) :: IO (Int, StdGen)
08:44:39 <udeos> not worked
08:45:08 <pyon> :t fst . random <$> newStdGen
08:45:09 <lambdabot> Random b => IO b
08:45:21 <Iceland_jack> udeos: What pyon said
08:45:49 <Iceland_jack> Also if you don't actually need the new StdGen you can just write
08:45:50 <Iceland_jack> :t randomIO :: IO Int
08:45:51 <lambdabot> IO Int
08:45:55 <Iceland_jack> and save yourself the trouble
08:46:04 <pyon> Oh, haha. Too bad I don't really know this library. :-p
08:48:14 <udeos> Iceland_jack: I'm actualy dont work with Int, I'm trying to make new instance for special data type
08:48:21 <aphocus> haskells random really does help you understand the math behind it.
08:49:15 <Iceland_jack> udeos: Can you lpaste the code?
08:49:49 <udeos> sure
08:51:47 <udeos> Iceland_jack: how can I write only for you?
08:53:24 <aphocus> Can I make a request? people who still use OpenGLs fixed-function pipeline should be shot.
08:53:41 <Iceland_jack> Sure udeos 
08:56:19 <fractalsea> I’ve got an arcitecture questions: I have a system where a client handler thread recieves data from a socket, which passes to another thread for processing. I’m not sure of the best way to send an ack back to the client once the processing is done. Currently the client thread creates a callback to send along with the data to the processing thread. I’m not a big fan of callbacks though. Is there a better way of doing this?
08:58:07 <impure_hate> what should I use for a program that needs a 1 second timer and stdin polling (filling buffer with zeroes if there's no input)
08:58:42 <aphocus> fractalsea, just use channels
08:59:21 <impure_hate> I need to compute exponential moving average on incoming data with timestamps
08:59:35 <impure_hate> with various window sizes
08:59:38 <fractalsea> aphocus, is that a library?
09:00:09 <aphocus> fractalsea, yeah
09:00:57 <liste> there's Chan type in base too
09:01:19 <fractalsea> aphocus, so the processing thread is initialised with a channel to send acks back to clients?
09:01:42 <fractalsea> Is there a guide that describes an architecture with channels?
09:01:55 <aphocus> fractalsea, yeah, hang on I got a bit of example code that does some channels
09:02:05 <fractalsea> aphocus, thanks
09:04:56 <aphocus> fractalsea, its probably a bit over engineered actually lol
09:05:04 <lpaste_> aphocus pasted “MIDI Relay using STM Channels” at http://lpaste.net/144895
09:05:20 <aphocus> probably doesn't need STM
09:05:44 <fractalsea> Thank you
09:09:27 <aphocus> fractalsea, you'd use this: https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Concurrent-Chan.html
09:10:20 <fractalsea> Thanks
09:10:24 <fractalsea> Looks interesting
09:10:42 <Jeanne-Kamikaze> https://www.indiegogo.com/projects/haskell-web-development-a-freely-available-book#/
09:11:00 <aphocus> newChan, writeChan, readChan makes things quite straight forward
09:12:47 <aphocus> fractalsea, its the only thing in haskell that didn't confuse the hell out of me :P
09:13:49 <MarcelineVQ> Jeanne-Kamikaze: my first impression is, who is this person and how do​I know they know enough to be making a book for people to learn from. Their own personal blog website doesn't even have valid https certs
09:18:13 <MarcelineVQ> What I mean is that if it was legitimate it would be a more effective platform for them to list off their accomplishments that lead them to knowing how to make the related teaching material. Their blog for example only has one post that's clearly related to web-dev and it's simple http.
09:18:38 <rmrfroot> MarcelineVQ: also, $20000 to cover 3 months living expenses? seems like A LOT to me.
09:18:52 <MarcelineVQ> not in the bay area ^^;
09:19:09 <MarcelineVQ> duno how austin compares
09:19:38 <aphocus> Thats my living expenses for the year :-|
09:20:12 <rmrfroot> i could live 18 months on that ^^
09:20:45 <MarcelineVQ> To add, though it's anecdotal, as a pattern 'flexible goal' is code for cash grab
09:20:55 <aphocus> But I am unemployed and frugal as hell.
09:21:15 <bitemyapp> the book'll take much longer than 3 months
09:21:18 <bitemyapp> source: writing a book
09:21:30 <rmrfroot> yeah, seems fishy.
09:21:41 <E4xoi> how cheap are we supposed to live? if it's a cheap life, without car, andwhatnot, over here it could be 2 years and half if you also put the remaining money on fixed rates and whatnot :p 
09:21:54 <bitemyapp> Something good could come out of it. We sponsored it, now in wait-n-see mode.
09:22:22 <udeos> can somebody help me to solve this recursion in randomR func ? http://pastebin.com/suanYqEW
09:22:43 <rmrfroot> E4xoi: hehe, damn! 
09:23:30 <MarcelineVQ> The problem is you forgot Wizard! (joke)
09:25:16 <E4xoi> rmrfroot: that includes pizzas every weekend and coca cola though, so not that cheap! 
09:26:40 <rmrfroot> E4xoi: yes, priorities in check, i see ;D
09:39:31 <^elyse^> I use existential quantification with a type class constraint: data S = forall a. C a => a. Is it possible to add deriving (C) or something like that?
09:44:01 <Iceland_jack> ^elyse^: That's lacking a constructor
09:44:18 <^elyse^> yeah, should be data S = forall a. C a => S a
09:44:21 <Iceland_jack> Is it
09:44:21 <Iceland_jack>     data S = S (forall a. C a => a)
09:44:21 <Iceland_jack> or
09:44:25 <Iceland_jack>     data S = forall a. C s => S a
09:44:27 <jophish> Using HXT, is there a way to convert an XmlTree into a string of XML which it represents
09:44:28 <Iceland_jack> Okay
09:45:12 <Iceland_jack> ^elyse^: You can use StandaloneDeriving I think
09:45:16 <Iceland_jack> You enable StandaloneDeriving by placing {-# LANGUAGE StandaloneDeriving #-} at the top of your source file or by entering the following into GHCi:
09:45:17 <Iceland_jack>     ghci> :set -XStandaloneDeriving
09:45:48 <Iceland_jack> And write
09:45:48 <Iceland_jack>     data S = forall a. Show a => S a
09:45:48 <Iceland_jack>     deriving instance Show S
09:46:07 <shachaf> ^elyse^: Seems unlikely that you'd just be able to derive a C instance in general.
09:46:12 <shachaf> Maybe it depends on the class.
09:46:26 <^elyse^> :[
09:46:27 <shachaf> But if C is Num, for instance, it doesn't make much sense.
09:47:33 <runeks> Is there a Word256 type out there somewhere that will only take up 256 bits of space in memory?
09:49:51 <shachaf> runeks: You can get something from https://hackage.haskell.org/package/largeword
09:50:33 <shachaf> Doesn't seem like an optimal encoding but it's probably OK.
09:51:25 <tippenein> what are my options for managing database environments for test/dev/prod in haskell? Also dependencies for the environments as well (faker for test/dev and _not_ prod)
09:51:27 <quchen> shachaf: This is just defining tuples of WordX to get higher Words, but it's not really concerned about the space usage, is it?
09:51:56 <quchen> It's not even unboxing the fields
09:51:57 <shachaf> Yes. It doesn't actually do what runeks asks, now that I read the whole question.
09:51:58 <luite> well over 256 bits indeed... 6 words overhead if i counted correctly...
09:52:36 <^elyse^> existentials are such a pain to use
09:55:00 <runeks> I guess that answers my other question... what "largeword" takes up in space for a Word256
09:55:04 <jophish> I was looking for xshow
09:55:18 <Jeanne-Kamikaze> MarcelineVQ, I've no idea, the link was in hacker news
09:56:39 <runeks> How much overhead does this type have? https://hackage.haskell.org/package/data-dword-0.3/docs/Data-DoubleWord.html#t:Word256
09:56:50 <runeks> One word for the constructor I know...
09:57:00 <runeks> and for each element?
09:57:41 <shachaf> If it all gets unboxed, yes.
09:58:15 <shachaf> Which it looks like it should.
10:00:14 <Jeanne-Kamikaze> the cool thing about haskell books is that the moment they are published they are already outdated
10:05:38 <varaindemian> how can I remake this function without using ord (without using import Data.Char) toDigits n = [ord a - 48 | a <- show n]
10:05:46 <varaindemian> `ord`
10:06:02 <quchen> Unlike books about other programming languages, where libraries don't change. And books in physics, thank god all the "modern physics" books from 1985 are all still correct. And mathematics! I love the homogeneousness of treatises of differential geometry.
10:06:40 <quchen> varaindemian: ord = fromEnum
10:06:49 <m1dnight_> Do any of you guys use Emacs? And if so, is there a way, like in Vim, to insert a header so that it asks for a word, and then generates a comment header like -----------...------\n--- The word/sentence
10:07:01 <quchen> > fromEnum 'a' -- varaindemian 
10:07:03 <m1dnight_> (... implies that it's 80 chars wide)
10:07:03 <lambdabot>  97
10:07:37 <quchen> varaindemian: And of course I'd like to call out your exercise bad if you can't import things, but some teachers still seem to think it's a good way of doing their jobs
10:07:48 <quchen> Not that you can change anything about that :-(
10:08:00 <Iceland_jack> m1dnight_: You can press 'M-72 -' to generate 72 hyphen-minuses
10:08:33 <m1dnight_> oh, that is _awesome_ :) Thanks
10:09:02 <liste> varaindemian I'd start with toDigits n = [toDigit f | a <- show n] and defining toDigits as toDigit '1' = 1, toDigit '2' = 2 ...
10:09:10 <varaindemian> quchen: also it needs to have this signature toDigits :: Integer -> [Integer]
10:09:11 <liste> toDigit a*
10:09:18 <aphocus> quchen, if the point is to think outside the box then I think its OK.
10:09:36 <orion> How do you add lenses to the export list in TH?
10:09:49 <liste> (for a very basic homework exercise)
10:10:56 <quchen> aphocus: The box is pretty small if all you have is Prelude.
10:11:06 <quchen> And equally hard to get out of.
10:11:26 <quchen> "Use lists for everything" is terrible if someone finds out there is cooler stuff around but can't use it.
10:11:44 <aphocus> I mean the point is to teach someone to program, aka, read documention and see how a function works.
10:12:07 <quchen> Implementing ord yourself is quite challenging.
10:12:29 <aphocus> "The 'Prelude.fromEnum' method restricted to the type 'Data.Char.Char'."
10:13:28 <aweinstock> > map ($'z') [fromEnum, ord]
10:13:30 <lambdabot>  [122,122]
10:14:02 <quchen> ?check \char -> fromEnum char == ord char
10:14:04 <lambdabot>  +++ OK, passed 100 tests.
10:14:45 <liste> that'd be quite a clever hack for homework :D
10:15:28 <aphocus> I've learnt how a lang works better via obfuscation sometimes :D
10:15:54 <aweinstock> > fromEnum otherwise :: Int
10:15:56 <lambdabot>  1
10:16:03 <monochrom> does the exercise require implementing ord? or just 1% of ord?
10:16:18 <aphocus> aweinstock, oh yeah you were the one I showed right?
10:17:57 <aphocus> http://codepad.org/rdor6fup
10:19:21 <platz> there are exactly 3 people on all of github who have actually completed the final nicta excercise "cheque.hs"
10:20:39 <platz> i got a partial solution for it, if i clean it up i can become #4 :)
10:21:11 <aphocus> OK, my OpenGL code is no longer "balls slow" https://youtu.be/bQ6ExYGF5Bs
10:21:32 <runeks> Will Foreign.Storable allow me to create a Word256 type that only takes up 256 bits-ish of memory?
10:23:19 <varaindemian> liste: isn't there a better way of writhing that function instead of typing so much code
10:23:22 <varaindemian> toDigit '1' = 1; toDigit '2' = 2; toDigit '3' = 3; toDigit '4' = 4; toDigit '5' = 5;
10:23:25 <varaindemian> toDigit '0' = 0; toDigit '6' = 6; toDigit '7' = 7; toDigit '8' = 8; toDigit '9' = 9;
10:24:29 <quchen> toDigit x = case x of '1' -> 1; '2' -> 2; …
10:24:36 <quchen> That saves you repeating the function name.
10:24:42 <liste> varaindemian what quchen said
10:25:07 <liste> you'll learn better ways over time, but better keep it simple first
10:25:14 <quchen> You could also use a lookup in a Map which is faster for large data sets.
10:25:20 <quchen> But that requires importing again.
10:25:41 <varaindemian> accidentally closed it
10:26:07 <dutchie> varaindemian: or just `import Data.Char (digitToInt)`
10:26:24 <varaindemian> dutchie: I am not allowed to do that...
10:26:32 <dutchie> oh, no imports
10:26:34 <dutchie> nvm
10:26:37 * hackagebot learn-physics 0.5.2 - Haskell code for learning physics  https://hackage.haskell.org/package/learn-physics-0.5.2 (ScottWalck)
10:26:39 * dutchie scrolls up
10:28:10 <varaindemian> liste: would you mind repeating what you said, cause I accidentally closed irc
10:28:20 <varaindemian> if you said something :D
10:28:30 <aweinstock> aphocus: yes, I remember that obfuscated hello world
10:28:55 <mauke> varaindemian: there are logs in the /topic
10:28:59 <aphocus> aweinstock, ahh, I'm YellowOnion, just having bothed putting my name back after dc.
10:29:05 <aphocus> haven't*
10:29:35 <MarcelineVQ> varaindemian: "<liste> varaindemian what quchen said" "<liste> you'll learn better ways over time, but better keep it simple first" "<quchen> You could also use a lookup in a Map which is faster for large data sets."
10:30:15 <varaindemian> thank you
10:30:24 <liste> also, as others said, ord is just a special case of fromEnum
10:30:32 <aweinstock> > map ((subtract 0x30) . fromEnum) [1.9]
10:30:35 <lambdabot>  [-47]
10:30:43 <aweinstock> > map ((subtract 0x30) . fromEnum) ['1'..'9']
10:30:46 <lambdabot>  [1,2,3,4,5,6,7,8,9]
10:31:03 <quchen> The Enum instance for Double is a bit silly :-/
10:31:19 <aweinstock> > fromEnum 1.9
10:31:22 <lambdabot>  1
10:31:35 <aphocus> func x
10:31:36 <aphocus>   | 0 >= digit > 10 = digit
10:31:36 <aphocus>   where digit = fromEnum x - 48
10:31:55 <aphocus> thats my take on it.
10:32:34 <aweinstock> comparisons don't chain like that (I think)
10:32:48 <Iceland_jack> You can write
10:32:48 <Iceland_jack>     | 0 >= digit, digit > 10 = digit
10:32:59 <Iceland_jack> but you can also compare the character itself to ordering 
10:33:06 <Iceland_jack> > '0' < '6'
10:33:07 <varaindemian> aphocus: toDigits n = [ord a - 48 | a <- show n] and that's my take, but Im not allowed to do that.. nvm I'll stick to toDigit '1' = 1; toDigit '2' = 2....
10:33:08 <lambdabot>  True
10:33:21 <Iceland_jack> > (\n -> '0' < n && n < '9') 'a'
10:33:23 <lambdabot>  False
10:33:58 <aweinstock> > map (let toDigit x | '0' <= x && x <= '9' = fromEnum x - 0x30; f _ = error "toDigit: not a digit") ['0'..'z']
10:33:58 <liste> varaindemian you can replace ord with fromEnum
10:34:00 <lambdabot>  <hint>:1:6: parse error in let binding: missing required 'in'
10:34:06 <aweinstock> > map (let toDigit x | '0' <= x && x <= '9' = fromEnum x - 0x30; f _ = error "toDigit: not a digit" in toDigit) ['0'..'z']
10:34:07 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,*Exception: <interactive>:3:10-61: Non-exhaustive patte...
10:34:18 <aweinstock> > map (let toDigit x | '0' <= x && x <= '9' = fromEnum x - 0x30; toDigit _ = error "toDigit: not a digit" in toDigit) ['0'..'z']
10:34:20 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,*Exception: toDigit: not a digit
10:34:33 <liste> > let toDigits n = [fromEnum a - 48 | a <- show n] in toDigits 127
10:34:35 <lambdabot>  [1,2,7]
10:35:00 <mauke> 48 better written as fromEnum '0'?
10:35:03 <aweinstock> liste: isn't the "normal solution" to that the one using recursion and divMod?
10:35:54 <liste> aweinstock I recall doing something like that
10:36:00 <varaindemian> liste: of course, but it's not of this form toDigits :: Integer -> [Integer]
10:36:12 <liste> varaindemian it can be
10:36:51 <liste> the magic of polymorphism
10:36:54 <mauke> toEnum (fromEnum a - fromEnum '0')
10:36:58 <nkaretnikov> has anyone recently tried to build lighthouse?
10:37:05 <mauke> the magic of fromEnum returning Int
10:37:13 <aweinstock> :t let toDigits n = [fromEnum c - fromEnum '0' | c <- show n] in toDigits
10:37:14 <lambdabot> Show a => a -> [Int]
10:37:32 <aweinstock> :t let toDigits n = [fromIntegral (fromEnum c - fromEnum '0') | c <- show n] in toDigits
10:37:34 <lambdabot> (Num t, Show a) => a -> [t]
10:37:43 <aweinstock> :t let toDigits n = [fromIntegral (fromEnum c - fromEnum '0') | c <- show n] in toDigits :: Integer -> [Integer]
10:37:45 <lambdabot> Integer -> [Integer]
10:40:44 <aphocus> remember that those functions will work on non digits
10:42:02 * hackagebot turtle 1.2.3 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.2.3 (GabrielGonzalez)
10:46:18 <zzing> When I told stack to generate documentation, for some reason it didn't generate it for Conduit and a bunch of other base packages. Further, now it seems that when I try to use Data.MonoTraversable, it says it is part of a hidden package and to add it to the build-depends - I did that but it still saying that — and that package is under the precompiled list under ~/.stack.
10:49:00 <sinelaw> TIL a pattern I use is actually the "cofree comonad"
10:50:27 <GCiubotaru> can someone recommend some good exercises for Functor / Applicative ? 
10:50:34 <varaindemian> how are Integral, Int, Integer and Num related?
10:51:04 <mniip> Integral and Num are typeclasses
10:51:07 <mniip> Int and Integer are types
10:51:21 <ggole> And Int and Integer are instances of (both of) the type classes
10:51:47 <Gurkenglas> sinelaw, also check https://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Free.html , https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html#t:Fix and https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html#v:hylo
10:52:05 <sinelaw> GCiubotaru: implement Functor for lists [] and Maybe
10:53:06 <rmrfroot> anyone familiar with esqueleto?
10:53:24 <GCiubotaru> sinelaw: already did for [], Maybe, some tree but still i don't have a deep understanding of them
10:53:57 <Gurkenglas> When should one use which of Fix, Mu, and Nu?
10:54:53 <varaindemian> mniip: where can I see good presentation of typeclasses and types?
10:55:16 <mniip> hmm?
10:55:29 <mniip> @hackage Prelude
10:55:29 <lambdabot> http://hackage.haskell.org/package/Prelude
10:55:33 <mniip> err
10:55:43 <sinelaw> Gurkenglas: Mu/Nu seem to be opposites
10:55:47 <sinelaw> hmm
10:55:55 <mniip> http://hackage.haskell.org/package/base-4.7.0.2/docs/Prelude.html
10:57:27 <zzing> When I get the message "Perhaps you need to add ‘mono-traversable’ to the build-depends in your .cabal file."  when it is already in the build-depends, how do I fix it? (using stack)
10:58:24 <Gurkenglas> sinelaw, pretty sure they're all equivalent: Note that values of Fix f, Mu f and Nu f all cannot depend on a.
10:58:29 <shachaf> Mu and Nu (and Fix) are isomorphic in Haskell.
10:58:52 <shachaf> Asking efficient one to use without any context is a bit odd.
10:59:06 <sinelaw> I get Fix but not the others
10:59:08 <shachaf> Might as well use Fix by default, I suppose.
10:59:20 <Gurkenglas> How do you decide which one is efficient to use?
10:59:32 <shachaf> fold :: Fix f -> Mu f
10:59:49 <shachaf> unfold :: Nu f -> Fix f
11:00:29 <sinelaw> Fix f = f (Fix f)  ==>   let x = Fix f, so x = f x = f (f (f (f (f ....
11:02:22 * hackagebot bifunctors 5.1 - Bifunctors  https://hackage.haskell.org/package/bifunctors-5.1 (EdwardKmett)
11:03:03 <newtohaskell> Hello! I want to write a function that removes every element from a list that occurs exactly 3 times, such as ["Haskell", "Nice", "Haskell", "Yes", "Haskell", "Yes", "No", "Yes"] -> ["Nice", "No"] How can I achieve this? Thanks in advance!
11:03:48 <Big_G> newtohaskell, One solution would be to count all unique elements and then filter them afterwards
11:03:48 <Gurkenglas> newtohaskell, must order be preserved?
11:04:56 <Gurkenglas> :t concat . filter ((/=3) . length) . group . sort -- If it doesn't have to be and your elements have an Ord instance as strings do
11:04:58 <lambdabot> Ord a => [a] -> [a]
11:06:18 <zzing> Turn it into [(a, Int)] and filter on a being the count of items
11:07:02 <Gurkenglas> :t map snd . sortBy (comparing fst) . concat . filter ((/=3) . length) . groupBy (comparing snd) . sortBy (comparing snd) . zip [0..] -- If it does have to be and your elements still have an Ord instance
11:07:04 <aweinstock> > (\xs -> let m = foldr (\x -> M.insertWith (+) x 1) M.empty xs in filter ((/= Just 3) . flip M.lookup m) xs) [1,1,1,2,3,3,4,4,4,5]
11:07:04 <lambdabot>     Couldn't match type ‘Ordering’ with ‘Bool’
11:07:05 <lambdabot>     Expected type: (Integer, a) -> (Integer, a) -> Bool
11:07:05 <lambdabot>       Actual type: (Integer, a) -> (Integer, a) -> Ordering
11:07:06 <lambdabot>  [2,3,3,5]
11:07:37 <aweinstock> ^ mine preserves order
11:07:53 <Gurkenglas> :t map snd . sortBy (comparing fst) . concat . filter ((/=3) . length) . groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..] -- This I mean
11:07:55 <lambdabot> Ord a => [a] -> [a]
11:08:06 <aweinstock> > (\xs -> let m = foldr (\x -> M.insertWith (+) x 1) M.empty xs in filter ((/= Just 3) . flip M.lookup m) xs) ["Haskell", "Nice", "Haskell", "Yes", "Haskell", "Yes", "No", "Yes"]
11:08:08 <lambdabot>  ["Nice","No"]
11:12:22 * hackagebot propellor 2.13.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.13.0 (JoeyHess)
11:12:31 <Gurkenglas> Why doesn't lambdabot have https://hackage.haskell.org/package/memoize ?
11:13:25 <newtohaskell> thanks!! I will combine this with my two functions (one for unique elements and one for counting the occurences) 
11:16:25 <mpickering> are there any good tools to visualise the call graph of a haskell library?
11:17:27 <aphocus> How do I disable ghc-mod in structured haskell mode?
11:20:40 <aphocus> Wait it seems to have fixed itself
11:22:52 * hackagebot compensated 0.7 - Compensated floating-point arithmetic  https://hackage.haskell.org/package/compensated-0.7 (EdwardKmett)
11:22:54 * hackagebot semigroups 0.18.0.1 - Anything that associates  https://hackage.haskell.org/package/semigroups-0.18.0.1 (EdwardKmett)
11:26:49 <zzing> If I have a [(a,b)] and [c] and I want to zip them together to be [(a,b,c)]  how do I do that?
11:29:03 <Archaeron> zzing: zipWith (\(a, b) c -> (a, b, c))
11:30:36 <zzing> Archaeron, thank you. 
11:34:07 <zzing> Now I am down to an issue where it couldn't match Element (Timestamp, Double, Heading) to (Timestamp, Double, Heading)  - Element appears to be a type family.
11:36:42 <rvxi> hey
11:42:39 <broma0> is there a lib out there somewhere that has a postorder traversal of Data.Tree rosetrees (collecting monadic side-effects like Data.Traversable.traverse)?
11:46:41 <rvxi> what's the best way to do haskell to C++ FFI nowadays?
11:47:27 <xnil> rvxi: not use C++
11:48:56 <aweinstock> rvxi: probably something involving `extern "C" {}` blocks to define a C interface, then calling the C interface from haskell
11:49:34 <rvxi> sigh. C++11 onwards has some nice-ities missing in C though. not to mention there's a substantial library ecosystem.
11:49:55 <rvxi> so if I use a C++ compiler, so long as I do extern "C" there's no name mangling issues?
11:50:38 <aweinstock> `extern "C" {}` only affects name mangling, if I understand it correctly
11:50:58 <aweinstock> (as in, the code inside the {} is still C++ code)
11:53:32 <aweinstock> :t (let traverseTree f (Node x xs) = do { ys <- mapM (traverseTree f) xs; y <- f x; return (Node y ys)} in traverseTree) -- broma0 
11:53:34 <lambdabot> Monad m => (t -> m a) -> Tree t -> m (Tree a)
11:54:14 <aphocus> how do I change > type Point = V2 Double to be any "Floating"?
11:54:41 <aweinstock> aphocus: type Point a = V2 a
11:55:19 <aphocus> aweinstock, does that mean I have to change the type signature of every function that has a Point in it?
11:55:47 <Zemyla> aphocus: Yes, you do.
11:56:05 <aweinstock> aphocus: probably
11:56:38 <aphocus> Last time I tried this I gave up lol
11:57:01 <aweinstock> type Point a = Floating a => V2 a -- I think this means something different (something to do with existential types?), but I'm not sure exactly how
11:57:12 <aweinstock> err, s/Point a/Point/
11:57:33 <Zemyla> aweinstock: That really doesn't work like you would hope it would.
11:58:00 <Zemyla> Because each a in each Point can be of different types, so you can't do anything useful with them.
11:59:04 <aweinstock> you don't even have access to the Floating dictionary?
11:59:32 <aweinstock> @let type SomethingOrOther = Floating a => a
11:59:33 <Zemyla> aweinstock: You do, but you can't use two Points together.
11:59:35 <lambdabot>  .L.hs:159:25: Warning:
11:59:35 <lambdabot>      Variable ‘a’ is implicitly quantified due to a context
11:59:35 <lambdabot>      Use explicit forall syntax instead.
11:59:46 <aweinstock> @let type SomethingOrOther = forall a. Floating a => a
11:59:48 <lambdabot>  Defined.
11:59:56 <aweinstock> > pi :: SomethingOrOther
11:59:58 <lambdabot>  3.141592653589793
12:00:22 <aweinstock> > cos (pi) :: SomethingOrOther
12:00:27 <lambdabot>  mueval-core: Time limit exceeded
12:00:28 <lambdabot>  mueval: ExitFailure 1
12:00:39 <Zemyla> The problem with having it be a type is that you can't really pass it to functions.
12:00:46 <aweinstock> > cos (pi :: SomethingOrOther)
12:00:49 <lambdabot>  -1.0
12:01:09 <Zemyla> aweinstock: Just bite the bullet and change it to Point a.
12:01:20 <Zemyla> Haskell makes it really easy to tell when you've missed one.
12:01:54 <aweinstock> aphocus: ^
12:03:05 <TheKing444> > print "Lambda Bot Please"
12:03:07 <lambdabot>  <IO ()>
12:04:44 <tommd> > "Lambda Bot Please"
12:04:46 <lambdabot>  "Lambda Bot Please"
12:04:50 <aphocus> Zemyla, 23 type signature errors :P atleast structured-haskell-mode is making suggests unlike before.
12:04:53 <mniip> > text "pls"
12:04:55 <lambdabot>  pls
12:06:04 <mniip> :t moo
12:06:05 <lambdabot> look ma no space
12:06:47 * int-e eyes lambdabot suspiciously
12:07:19 <Zemyla> @src moo
12:07:19 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:07:44 <mniip> int-e, just gotta suppress PolyKinds with explicit foralls and voila
12:07:53 * hackagebot pipes 4.1.7 - Compositional pipelines  https://hackage.haskell.org/package/pipes-4.1.7 (GabrielGonzalez)
12:08:10 <int-e> I see it.
12:09:27 <TheKing444> I just wanted to privmsg LambdaBot without going through the huge list.
12:09:36 <rvxi> why is it that if i declare a value in code as
12:09:39 <rvxi> fooBar = 3
12:09:42 <rvxi> the type is Integer
12:09:48 <rvxi> but if I say
12:09:53 <rvxi> let fooBaz = 3 in ghci
12:10:24 <rvxi> the type is the Num typeclasss Num a => a
12:10:26 <rvxi> ?
12:11:54 <srhb> rvxi: Monomorphism restriction
12:12:22 <srhb> rvxi: https://wiki.haskell.org/Monomorphism_restriction
12:12:52 <srhb> If you turn it on in GHCI, or off in your module, you get consistent behaviour across both (with the added annoyance of less inferred polymorphism)
12:12:56 <aphocus> no instance (Num a) arising from literal "1"
12:13:59 <aphocus> oh I need to restrict it to Floating right!
12:15:10 <rvxi> srhb: yikes that's a bit confusing
12:15:28 <srhb> rvxi: It is. You get used to it, though. :-)
12:15:44 <srhb> rvxi: If you'd declared the type that ghci inferred explicitly in your module, you'd also see the same results.
12:16:16 <TheKing444> Literate Haskell Post: https://plus.google.com/112084229900022559058/posts/6eyFYvUEoaz
12:16:33 <TheKing444> It relates to the law of excluded middle.
12:16:56 <rvxi> srhb: did this  change between ghc 7.8 and 7.10?
12:17:06 <srhb> rvxi: Yep.
12:17:19 <srhb> rvxi: In 7.8.1 to be exact.
12:18:38 <rvxi> srhb: double yikes. i guess that's why chris's book says something different..
12:19:03 <srhb> rvxi: Does it?
12:19:29 <srhb> rvxi: What, exactly?
12:20:02 <rvxi> it says that
12:20:07 <rvxi> myNum = 1
12:20:08 <rvxi> should be
12:20:22 <rvxi> "Declaration of a value of type Num a => a"
12:20:32 <srhb> rvxi: OK, that has always been untrue.
12:20:41 <srhb> rvxi: Since 7.8.1, MR is turned _off_ in _ghci_
12:21:18 <rvxi> oh it's not explicit about this being entered in ghci
12:21:30 <rvxi> i'm assuming it's meant to be in a source file
12:21:31 <srhb> Well, myNum = 1 is a parse error in ghci :)
12:21:36 <srhb> Yes, that's what I'm inferring too
12:22:05 <srhb> Which is why I'm saying it has always been untrue. MR was on "in modules" prior to 7.8.1 as well as after 7.8.1
12:22:27 <rvxi> i'm taking bug report notes as i go along :)
12:22:32 <srhb> Cool. :)
12:34:34 <aphocus> :t runState
12:34:36 <lambdabot> State s a -> s -> (a, s)
12:35:02 <aphocus> :t Just . runState
12:35:03 <lambdabot> State s a -> Maybe (s -> (a, s))
12:36:01 <jg_> is there a concat operator (++) for Text?
12:36:21 <mauke> <>
12:36:29 <anonv> I want to try a language that forces me to use the functional programming paradigm. Why should I choose Haskell over Scala that has access to the whole java ecosystem?
12:36:36 <mauke> at least I hope Text implements Monoid
12:36:40 <tommd> jg_: Notice the polymorphic type of <>.
12:39:16 <Lokathor> anonv, the fact that Scala has access to Java means that you're less forced to work in a functional system
12:39:22 <Lokathor> it would run counter to your exact purpose
12:41:47 <aphocus> anonv, its also a multiparadigm lang, you would be better off clojure since its more focused on functional style.
12:42:29 <trubert7> Is there a way to turn a Haskell list [1,2,3] into a foreign pointer (i.e. something that has the type `Ptr Int` from Foreign.Ptr) containing the list [1,2,3] . https://hackage.haskell.org/package/base-4.8.1.0/docs/Foreign-Ptr.html
12:42:52 <mauke> that's not a foreign pointer
12:43:02 <mauke> oh, it is
12:43:06 * mauke thinks
12:43:19 <glguy> trubert7: You can use: withArray
12:43:32 <glguy> http://hackage.haskell.org/package/base-4.8.1.0/docs/Foreign-Marshal-Array.html
12:43:36 <trubert7> glguy: thanks, which module is that defined in?
12:43:36 <trubert7> great!
12:43:37 <mauke> http://hackage.haskell.org/package/base-4.8.1.0/docs/Foreign-Marshal-Array.html#v:newArray
12:43:59 <glguy> withArray for temporary allocation, newArray for long-term (with you freeing it)
12:44:17 <trubert7> glguy: mauke: super, just what I was after, thanks.
12:48:16 <aphocus> :t unfoldr
12:48:17 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:49:02 <aphocus> Is it possible to get back B from that function?
12:49:38 <mauke> what's B?
12:50:53 <aphocus> mauke, in my case? its a stateT with random inside.
12:51:12 <mauke> no, what is B in relation to unfoldr?
12:51:35 <aphocus> :t unfoldr
12:51:36 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:51:45 <aphocus> I mean the b in this.
12:53:33 <mauke> that's an argument
12:53:42 <mauke> you're passing it in, why do you want to get it back out?
12:54:13 <aphocus> Because I want to get the StdGen back out to pass to another function
12:54:32 <slomo> you could make your "a" a tuple that contains the "b" too to get it out of unfoldr
12:54:53 <mauke> aphocus: that's not the same StdGen
12:55:27 <monochrom> no, don't bother retrieving the used StdGen. make a new one for another function.
12:56:53 <monochrom> in fact, don't even bother with unfoldr in the context of random list generation. randoms and randomRs exist.
12:56:55 <mauke> @hoogle (b -> Maybe (a, b)) -> b -> ([a], b)
12:56:57 <lambdabot> No results found
12:57:02 <aphocus> monochrom, I'm currently doing that, but I fear its not random enough, as there's some strange behaviour in my app.
12:57:31 <monochrom> if you use a used StdGen, randomness is only going to be worse, not better.
12:57:54 * hackagebot swagger2 0.1 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-0.1 (NickolayKudasov)
12:58:54 <aphocus> monochrom, funny that someone here said the exact opisite to me a while back.
12:59:49 <aphocus> I guess I could try a different seed for each list
13:00:04 <Lokathor> monochrom, why can't you use the same StdGen over time?
13:00:38 <aphocus> I think he's refering to the cryptographic hacking nature of it.
13:00:38 <monochrom> I take it you mean "why worse" as opposed to "why can't".
13:00:51 <Lokathor> right
13:01:01 <monochrom> if you reuse the same StdGen you get the same sequence again, no?
13:01:34 <aphocus> :t randomR
13:01:35 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
13:01:38 <Lokathor> well, i mean, i guess "yes, but by same I meant that you'd use the advanced StdGen"
13:01:45 <aphocus> it gives you a new one^
13:02:04 <mauke> "by same I meant not the same"
13:02:19 <monochrom> ok, if you do that, then it is not worse, but it is harder to code up.
13:03:03 <monochrom> as empirically evident now by pulling your hair out on "I want unfoldr but I also want the final state"
13:03:22 <aphocus> currently I have both of them with the same seed, I guess
13:03:42 <aphocus> it might just be easy to feed them different seeds.
13:03:52 <Hafydd> I was just struck by an image of a website where people post pictures of themselves opening packages of new items of clothing, called unfoldr.
13:04:05 <monochrom> which first of all doesn't make sense as is, since if the list is going to be infinite, there will not be a "final state"
13:04:40 <monochrom> and then ok, you say you will also pass in a number n, and have it generate n items and then tell you the final state.
13:05:31 <monochrom> ok, but that's what I mean by "harder to code up". it's ugly code and it is extra work and it is more code to debug and it is more code to worry about "but am I leaking memory"?
13:06:11 <monochrom> I am serious because by this stage you're talking about something equivalent to replicateM under State which is known to spend more memory than you like.
13:06:39 <monochrom> Hafydd: oh haha that's a cool usage :)
13:07:58 <Nahiyan> hi. how can I apply the use of the $ or . operators in this expession? let pairs n = zip (f n) (tail (f n))
13:08:02 <Nahiyan> here f n returns a list
13:08:45 <Nahiyan> I think I could use $ in (tail (f n)) but can I use it anywhere else?
13:08:47 <mauke> how about no
13:09:02 <aphocus> monochrom, this is an older past, but line 88: http://lpaste.net/144835
13:09:05 <athan> I somehow managed to deadlock monad-transformer running somehow
13:09:12 <Nahiyan> it's not possible?
13:09:13 <athan> ...somehow
13:09:17 <mauke> (zip $ (f $ n)) $ (tail $ (f $ n))
13:09:24 <RainBowww> haha
13:09:32 <athan> Nahiyan: ($) is generic for any function typ4es
13:09:33 <Nahiyan> well
13:09:36 <aphocus> paste*
13:09:37 <glguy> mauke: Maybe add some uses of raw ($)
13:09:52 <athan> :t ($)
13:09:53 <lambdabot> (a -> b) -> a -> b
13:10:13 <Nahiyan> but how can I use $ to eliminate parentheses?
13:10:22 <glguy> (\f n -> zip (f n) (($)($)($)tail (f n))
13:10:37 <athan> Nahiyan: Imagine it as a barrior
13:10:39 <mauke> Nahiyan: I like parentheses better
13:10:47 <Nahiyan> ok
13:10:50 <aphocus> f1 . f2 . f3 . f4 $ param1
13:10:50 <athan> `f $ ....other things` applies everything into `f`
13:11:03 <Nahiyan> hmmm
13:11:19 <mauke> ap zip tail (f n) -- while we're at it
13:11:33 <athan> lol glguy
13:11:40 <glguy> That version actually reuses the (f n) expression which might be a win here
13:14:13 <glguy> zip<*>tail$f$n
13:14:48 <Nahiyan> wow
13:15:12 <Nahiyan> it works !
13:15:55 <Nahiyan> could you tell me what <*> is ? or its name?
13:16:07 <RainBowww> john
13:16:10 <mauke> <*> is its name
13:16:19 <Nahiyan> ok ok
13:16:47 <mauke> do you know what the S combinator is?
13:17:10 <Nahiyan> I think I did but I have forgotten
13:17:14 <glguy> Since we're going for maximum confusion and not readability it'd probably be worth mixing in &: zip<*>tail$n&f
13:17:16 <athan> note to self - never make monad stacks codependent (unify) when they contain each other
13:17:31 <athan> ie: `MonadStuff m => T m (OtherT m a)`
13:17:34 <athan> it's a pain when you try to runMonadStuff
13:17:39 <mauke> athan: newtype is your friend
13:17:42 <athan> (and I happened to deadlock :c)
13:17:57 <athan> mauke: It is newtyped though!
13:18:06 <mauke> oh
13:18:08 <athan> I just shouldn't be making excessive contexts everywhere
13:18:37 <athan> or really, sharing that context and expecting the `run`ing to work, when you breach the container (while still sharing the same context)
13:18:39 <mauke> Nahiyan: <*> is a method from Applicative. in this case it's used as f <*> g = \x -> f x (g x)
13:20:34 <Nahiyan> hmm
13:20:59 <Nahiyan> ok I think I understand, but not why it was made
13:21:07 <aphocus> why are we trying to obfusicate this? lol
13:22:04 <mauke> I'm surprised no one has used fmap as (.) yet
13:22:07 <Nahiyan> I don't know but I only wanted to know about using $
13:22:18 <mauke> btw, you can use `id` as $
13:22:55 <Nahiyan> hmm
13:26:25 <aphocus> mauke, fmap is too readible, use <$>
13:27:29 <mauke> :t [(.), fmap, (<$>), (<<<)]
13:27:31 <lambdabot> [(b -> c) -> (a -> b) -> a -> c]
13:28:09 <Nahiyan> wow... an array of operators
13:28:17 <mauke> s/array/list/
13:28:22 <Nahiyan> ok
13:29:27 <aphocus> My code has this weird bug appear in a part of code I had't changed... wtf
13:29:31 <Nahiyan> is there a function for rounding to n significant figures?
13:29:37 <mauke> I have a weak spot for the 'return' in filterM (return [True, False])
13:30:04 <mauke> Nahiyan: what type of numbers are you working with? Double?
13:30:31 <mauke> wait, I'm not thinking straight
13:31:01 <Nahiyan> 1.2414 e.g.
13:31:20 <mauke> that's a number, not a type
13:31:34 <Nahiyan> myList :: Fractional t => [t]
13:34:26 <Nahiyan> there's truncate but..
13:36:46 <monochrom> Nahiyan: I am lazy, so I would just use showEFloat (from Numeric) and then read it back
13:36:56 <Nahiyan> hmm ok
13:37:33 <mauke> decimal operations on doubles make me feel unclean
13:41:51 <Darwin226> Hey guys. Can anyone give e up to date information on what the best way to get haskell platform setup on ubuntu is?
13:42:03 <Darwin226> If I just run what they suggest on their page, will I get ghc 7.10?
13:44:41 <aphocus> :t mkStdGen
13:44:43 <lambdabot> Int -> StdGen
13:45:21 <nkaretnikov> anyone familiar with (a)jhc?
13:45:42 <nkaretnikov> i have a reference c file that i'd like to port to (a)jhc, but i have no clue how to do it
13:46:00 <nkaretnikov> since the ffi only allows to import functions
13:50:06 <rvxi> what statistical distribution sampling library in haskell has the best raw performance?
14:03:07 * hackagebot concurrent-output 1.6.1 - Ungarble output from several threads  https://hackage.haskell.org/package/concurrent-output-1.6.1 (JoeyHess)
14:03:09 * hackagebot diff-gestalt 0.2.0.0 - A diff algorithm based on recursive longest common substrings  https://hackage.haskell.org/package/diff-gestalt-0.2.0.0 (chrismwendt)
14:05:53 <jg_> i'm trying to understand how runWriter is implemented
14:06:19 <jg_> as in mtl runWriter method. I can't find its source on hackage...
14:07:29 <mauke> http://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Monad-Trans-Writer-Lazy.html#runWriter
14:09:12 <jg_> what's the relation between mtl and 'transformers'?
14:11:46 <jg_> what do i need to know to really understand what's going on in this line: "newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }" ? There's this unwrapping concept in haskell. Is it described somewhere?
14:12:13 <Iceland_jack> jg_: Do you understand
14:12:13 <Iceland_jack>     data Age = MkAge Int
14:13:12 <jg_> Iceland_jack: it defines the mkAge constructor, right? 
14:13:16 <Iceland_jack> Yes
14:13:22 <jg_> for the Age type
14:13:27 <jg_> or record?
14:13:35 <Iceland_jack> Age is a type
14:13:50 <Iceland_jack> To create something of that value, you write
14:13:50 <Iceland_jack>     MkAge 107
14:14:39 <Iceland_jack> that's the same as writing 
14:14:39 <Iceland_jack>     data Age = MkAge { x :: Int }
14:14:39 <Iceland_jack> except the latter creates a function to access the only field x: 
14:14:39 <Iceland_jack>     x :: Age -> Int
14:15:56 <Iceland_jack> Without the record syntax, your WriterT example would look like
14:15:56 <Iceland_jack>     newtype WriterT w m a = WriterT (m (a, w))
14:15:57 <jg_> right, i think i'm beginning to understand what's going on here
14:16:23 <mniip> :t WriterT
14:16:26 <lambdabot> m (a, w) -> WriterT w m a
14:16:27 <mniip> :t runWriterT
14:16:30 <lambdabot> WriterT w m a -> m (a, w)
14:17:26 <Iceland_jack> But really it's best to understand Writer before WriterT, which basically just removes the 'm' type variable:
14:17:26 <Iceland_jack>     newtype Writer w a = Writer (a, w)
14:17:26 <Iceland_jack>     
14:19:31 <lpaste_> Ste1891 pasted “OpenGL initialisation” at http://lpaste.net/144905
14:19:43 <jg_> i understand it a lot better now. Thanks Iceland_jack
14:19:51 <Ste1891> Hi.  Does anyone know how I could change this OpenGL StateVar arbitrarily?  The above code compiles and works but obviously doesn't cause any change.  I've looked at the constructor for (Color4 GLfloat) but can't yet work out how to change the component values.
14:20:00 <haskell292> What's the simplest way to convert an Int to a float? I'm kind of confused by all the typeclasses
14:20:15 <Iceland_jack> jg_: The important part is, at this point we could just as well make it a type synonym WriterTS
14:20:15 <Iceland_jack>     type WriterTS w a = (a, w)
14:20:15 <Iceland_jack> The main reason Writer isn't a type synonym is that you cannot write
14:20:15 <Iceland_jack>     instance Functor     WriterTS 
14:20:18 <Iceland_jack>     instance Applicative WriterTS 
14:20:24 <Iceland_jack> but you can write them for 'data Writer' or 'newtype Writer'
14:20:27 <Iceland_jack> jg_: aight
14:20:49 <mniip> 'instance Functor     WriterTS' is a kind error
14:21:25 <luite> haskell292: fromIntegral
14:21:29 <jg_> yep, it's a glorified pair container. I see there's nothing magical about it now :p
14:21:37 <Iceland_jack> mniip: Indeed! I meant
14:21:37 <Iceland_jack>     instance Functor (WriterTS w) 
14:21:46 <Iceland_jack> Thank you mniip 
14:21:47 <Iceland_jack> exactly jg_ 
14:23:22 <jg_> had the wrong impression that this runWriter must be somehow special but as it turns out it's just a record field
14:23:24 <tzh> Ste1891: Color4 is defined in Graphics.Rendering.OpenGL.GL.VertexAttribues (apparently) and you should be able to pattern-match on its constructor like any other value, it's r g b a in that order iirc
14:23:36 <Iceland_jack> So stripping away the noise
14:23:37 <Iceland_jack>     newtype WriterT w m a = WriterT { runWriterT :: m (a, w)
14:23:37 <Iceland_jack>   ={ remove record field }
14:23:37 <Iceland_jack>     newtype WriterT w m a = WriterT (m (a, w))
14:23:40 <Iceland_jack>   ={ m = Identity }
14:23:43 <Iceland_jack>     newtype Writer w a = Writer (Identity (a, w))
14:23:46 <Iceland_jack>     newtype Writer w a = Writer (a, w)
14:23:49 <Iceland_jack>     type    Writer w a = (a, w)
14:23:54 <Iceland_jack>  
14:24:17 <rvxi> hm block entry into ghci doesn't seem to work as expected
14:24:18 <tzh> `fun (Color4 r g b a) = ...` should work just fine to get at the values so you can make a new Color4 value
14:24:28 <rvxi> what's wrong with this block entry into ghci? http://lpaste.net/144906
14:24:42 <rvxi> i get an error "parse error in let binding: missing required 'in'"
14:24:58 <jg_> i guess the ghc runtime does the _actual_ running of all those monads
14:25:11 <rvxi> but i'm not sure where the "in" is supposed to go
14:25:15 <Iceland_jack> jg_: The actual 'running' doesn't happen at run time
14:25:35 <Iceland_jack> jg_: Being a 'newtype' should be a friendly hint that 'Reader e a' has the same representation (is representationaly equal) to (e -> a)
14:26:39 <ipdwht> Hi all. I'm new to Haskell. I am really stating to understand what all the fuss is about. :)
14:27:02 <Iceland_jack> Hey ipdwht
14:27:03 <rvxi> hi ipdwht, welcome
14:27:16 <Zemyla> Hmm. Is there an argument for toRational on a RealFloat type returning the simplest Rational within half an ulp of the argument?
14:27:32 <Zemyla> > toRational 1.7
14:27:34 <lambdabot>  7656119366529843 % 4503599627370496
14:27:52 <Zemyla> Is there any reason why it can't return 17 % 10?
14:27:53 <rvxi> ipdwht hope you have fun learning it :)
14:28:01 <ipdwht> Learning it's not very fun....
14:28:32 <ipdwht> But it is like bashing your head against the wall, until you look up, and find you've made a nice little pretty window.
14:29:32 <jg_> Iceland_jack: what do you mean it doesn't happen at runtime? Isn't it the case that writing a haskell program is basically building some monadic expression with IO on top and passing it to ghc to run it?
14:29:46 <rvxi> has "Top-level binding with no type signature:" always been a warning or is that something that's been added recently?
14:30:23 <Iceland_jack> jg_: What I'm saing the conversion between
14:30:23 <Iceland_jack>     WriterT w m a -> m (a, w)
14:30:23 <Iceland_jack> can be erased at compile time
14:30:23 <rvxi> ipdwht the learning paths to haskell need work
14:30:42 <jg_> right
14:30:48 <ipdwht> Man, it's not even the "learning paths" that suck (they do), but haskell is just... hard.
14:31:10 <ipdwht> About as hard as Obj C. You need to know *a lot* just to be able to do very little.
14:31:16 <mniip> Zemyla, interesting
14:31:24 <mniip> I think there's a bug in showFFloat btw
14:31:46 <mniip> because it keeps saying it's 1.7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
14:31:48 <rvxi> idwht i would just play around with whatever you want until you get stuck between beginner and beginner-intermediate. then start over more seriously
14:32:31 <rvxi> with chris allen's book http://haskellbook.com/
14:32:35 <jg_> so what is runWriterT called? I've heard this 'monad unwrapper' expression....
14:32:40 <ipdwht> Eh, I'm working my way through that CIS 194 course. I've attempted to learn Haskell a few times before, but always gave up. But this is working pretty well this time. :)
14:32:49 <Zemyla> mniip: There is a function in Data.Ratio that gives the simplest rational in an interval, and for a RealFloat, you can measure 1/2 ulp with decodeFloat.
14:33:12 <rvxi> ipdwht i found it helps to do one pass where you just get used to hearing functor, monad, etc.
14:33:49 <Iceland_jack> jg_: Usually just called 'wrapping functions' that you 'wrap' and 'unwrap', it's a more of a colloquial term but check out lens https://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Wrapped.html
14:33:50 <mniip> Zemyla, 7656119366529843 % 4503599627370496 is a literal encoding of the float value
14:33:51 <rvxi> ipdwht otherwise it's too slow going of you start rigorously right away. once you have a few toy scripts and get over the nomenclature oddities
14:33:55 <mniip> mantissa / 2^52
14:34:11 <ipdwht> rvxi:  Actually, I'm using Allen's suggestion of cis194 -> NICTA course.
14:34:14 <mniip> that's what showFFloat is supposed to say as well
14:34:18 <mniip> no idea why it doesn't
14:34:26 <rvxi> ipdwht slowly going over basic concepts like typeclasses is more digestable. at least for me.
14:34:33 <Zemyla> Yes, but 17 % 10 encodes the same float.
14:34:53 <mniip> does it
14:34:59 <Iceland_jack> jg_: Or 'field accessors', if you're talking about record in general. 'x' and 'y' would be field accessors in this coordinate example
14:34:59 <Iceland_jack>     data Coordinate = Coord { x :: Int, y :: Int }
14:35:09 <Zemyla> > fromRational (17 % 10) :: Double
14:35:10 <lambdabot>  1.7
14:35:42 <Zemyla> > (fromRational (7656119366529843 % 4503599627370496) :: Double) == fromRational (17 % 10)
14:35:44 <lambdabot>  True
14:38:36 <Zemyla> If they're the same to within the precision of Double, then why shouldn't it return the simpler one?
14:38:51 <dolio> How?
14:39:31 <rvxi> ipdwht have you tried the NICTA course yet?
14:39:54 <ipdwht> rvxi: Nope, still working through the cis194
14:40:43 <Zemyla> @let toBestRat x = let { (m, e) = decodeFloat x; diff = (1 % 2) * (fromInteger $ floatRadix x) ^^ e } in approxRational (toRational x) diff
14:40:45 <lambdabot>  Defined.
14:40:52 <Zemyla> > toBestRat 1.7
14:40:54 <lambdabot>  17 % 10
14:41:01 <rvxi> idpwht that's a good place to start, not that user friendly. but btter than alternatives
14:41:06 <rvxi> ipdwht
14:41:16 <rvxi> ipdwht where are you in the course?
14:41:23 <ipdwht> rvxi:  Pretty early. :P
14:41:39 <ipdwht> rvxi:  Far enough so I can start mucking around in Haskell and start doing my CS courses assignments also in Haskell.
14:41:46 <mjrosenb> > toBestRat 2.718281828
14:41:47 <lambdabot>  147066601 % 54102779
14:41:53 <rvxi> having gone through a SICP course a long time ago
14:42:35 <rvxi> ipdwht i found things pretty smooth, up to around the typeclass stuff
14:42:54 <ipdwht> Typeclasses are great, as far as I can tell.
14:43:21 <rvxi> they are
14:43:31 <ipdwht> It's like interfaces done not stupid.
14:43:37 <rvxi> but that was around the point in the course where the abstraction started making my brain work
14:43:51 <tabemann> they're not like interfaces, though, because they don't have subtyping
14:43:53 <Zemyla> @let testBestRat x = (x :: Double) == fromRational (toBestRat x)
14:43:55 <lambdabot>  Defined.
14:44:18 <Zemyla> > testBestRat (exp 1)
14:44:18 <tabemann> rather they manifest themselves as type constraints, which are different from subtyping
14:44:19 <lambdabot>  True
14:44:58 <Zemyla> tabemann: There is a form of subtyping, though, in that some type constraints can imply others.
14:45:05 <rvxi> tabemann what do you mean? you have specializations like Num to Integer which seems sortof like subtyping, but no method  overriding
14:45:46 <rvxi> it does seem like there are parallels to multiple inheritance, but without the messy parts...
14:46:15 <tabemann> you can't make a heterogeneous list of different values that share the same class constraint but differ in type
14:46:17 <rvxi> i've yet to see someone try to go through the parallels and differences in detail though. i think that would be helpful for some outsiders.
14:47:27 <rvxi> tabemann yes but that's one particular instance of a difference. i think there are other aspects like the dispatch mechanism and specialization that are similar to what people think of as 'subtyping' and 'abstract interfaces'
14:47:56 <rvxi> and i think that has more to do with the way List is defined than something fundamental about the type system
14:48:08 * hackagebot HaskellNet-SSL 0.3.2.0 - Helpers to connect to SSL/TLS mail servers with HaskellNet  https://hackage.haskell.org/package/HaskellNet-SSL-0.3.2.0 (DanielWright)
14:48:08 <tabemann> internally it uses dictionaries to handle the resolution of methods w.r.t. type classes when they cannot be resolved statically, yes
14:48:56 <rvxi> for example with tuples, I could have heterogeneous specializations.
14:49:31 <tabemann> but tuples are different from lists
14:50:20 <rvxi> that's my point, the issue with lists is a consequence of the definition of Lists, moreso than a fundamental aspect of the type system
14:50:27 <tabemann> each item in a tuple can be of a different type, and you cannot do a lot things you can do with lists with tuples
14:50:44 <dolio> You can use existential types to create a list like that.
14:50:47 <tabemann> it has to do with that each item in a list shares the same type variable, whereas each item in a tuple has its own t ype variable
14:50:52 <ipdwht> But -- generally, they're used for similar situations....
14:50:52 <dibblego> ipdwht: if you are in .au then NICTA runs that course in-person on regular occasion
14:51:04 <rvxi> so i don't think the homogeneity of list specializations captures a fundamental difference between abstract interfaces and typeclasses
14:51:05 <tabemann> but existential types with class constraints have gone away in recent versions of GHC
14:51:26 <tabemann> and existential types without class constraints aren't very useful for most applications
14:51:32 <dolio> No, they haven't.
14:52:10 <dolio> There are other examples of subtyping, as well.
14:52:21 <dolio> Even without classes.
14:52:22 <rvxi> ipdwht have you seen this page https://wiki.haskell.org/OOP_vs_type_classes
14:52:33 <Jello_Raptor> does anyone have an example of a generally useful recursive ADT with at least two type parameters? one that isn't just a multi-param ADT used as the parameter for a single-param ADT? I'm blanking at the moment. 
14:52:35 <dolio> a -> a can be seen as a subtype of Int -> Int.
14:52:43 <ipdwht> rvxi:  Yup.
14:52:49 <tabemann> that's not the same sense of subtyping, though
14:53:37 <tabemann> probably the main way of doing subtyping-like behavior in Haskell in an OO-like fashion, existential types aside, is to make records of functions, which of course hide information because they're implemented as closures
14:53:45 <rvxi> tabemann perhaps you're thinking of a specific definition of "subtyping"?
14:53:58 <tabemann> I mean subtyping in the OO sense
14:54:17 <dolio> Which OO sense?
14:54:22 <c_wraith> That's not really subtyping, that you're describing.  It's just multiple values of the same type with different behavior.
14:54:22 <dibblego> well this is weird
14:54:36 <c_wraith> Subtyping is one way to get that result, but not the only way.
14:54:53 <tabemann> dolio:  umm like where a type may have one or more superclasses and may have one or more subclasses
14:54:57 <zzing> When I am inside a runResourceT, how do I get things to be able to print to the terminal?
14:55:30 <dibblego> zzing: ResourceT is an instance of MonadIO last I checked, which was many years ago, so use liftIO
14:55:47 <Ste1891> tzh: OK, thanks.
14:55:53 <dolio> You mean nominal subtyping, where you have to explicitly declare relationships?
14:56:07 <dolio> Because that is not the only sort of subtyping even in the OO world.
14:56:26 <tabemann> well yes, I know there's other ways of doing subtyping in the OO world, such as duck typing
14:57:00 <jophish> > reads "0.x" :: [(Int, String)]
14:57:02 <lambdabot>  [(0,".x")]
14:57:05 <jophish> > reads "0.0" :: [(Int, String)]
14:57:07 <lambdabot>  []
14:57:11 <jophish> What's up with that?
14:57:13 <orion> Hi. When using makeLenses, how do you control which lenses are exported and which are not?
14:57:19 <rjeli> @pl f (v,d) x = f (min x v) (max d (x-v))
14:57:20 <lambdabot> f = fix ((`ap` snd) . (. fst) . (`ap` (flip ((.) . max) . subtract)) . (((.) . ap) .) . (. min) . (.))
14:57:30 <dolio> orion: With the export list at the top of the module.
14:57:31 <dibblego> orion: can you not just use the usual export list of a module?
14:57:41 <zzing> dibblego, thank you.
14:57:47 <zzing> It compiles, and I think it works
14:57:52 <dibblego> zzing: np
14:58:02 <jophish> I'd expect reads "0.0" to return [(0, ".0)]
14:58:06 <rjeli> @pl f (v,d) x = f (min v x) (max d (x-v))
14:58:07 <lambdabot> f = fix ((`ap` snd) . (. fst) . (`ap` (flip ((.) . max) . subtract)) . (((.) . ap) .) . (. min) . (.))
14:58:37 <orion> Oh, so it's incorrect to use Foo(..) in the export list because that'll export the raw record fields as opposed to the lenses, right?
14:59:05 <dolio> It's incorrect if you don't want to export those.
14:59:11 <rjeli> why doesn't lambdabot find me a nice Arrows solution :-(
15:00:15 <rvxi> when does ghci use a b c vs. t t1 t2 ?
15:01:12 <mniip> rvxi, ghc uses type variables as written in the source
15:01:30 <mniip> @let moo :: foo -> bar -> baz; moo = undefined
15:01:31 <lambdabot>  Defined.
15:01:32 <mniip> :t moo
15:01:33 <lambdabot> foo -> bar -> baz
15:02:02 <mniip> however sometimes it needs to make up a type variable from scratch, that's when it just calls it t, t1, t2...
15:02:16 <mniip> :t \a b c -> (a, b, c)
15:02:18 <lambdabot> t -> t1 -> t2 -> (t, t1, t2)
15:02:29 <rvxi> mniip so when does it use the a, b, c convention
15:02:31 <rvxi> ?
15:02:35 <mniip> never
15:03:00 <mniip> it just means that a, b, c were the type variables in the source
15:03:16 <rvxi> mniip it seems to use a b c
15:03:21 <mniip> example
15:03:24 <rvxi> when there's a known typeclass but an unknown type
15:03:29 <rvxi> for example enter into ghci
15:03:29 <rvxi> 3
15:03:31 <rvxi> 3 :: Num a => a
15:03:39 <rvxi> or :t 3
15:03:48 <glguy> That's because fromInteger :: Num a => Integer -> a
15:03:49 <mniip> :t fromInteger
15:03:51 <glguy> is defined in the source
15:03:51 <lambdabot> Num a => Integer -> a
15:04:14 <glguy> \f g x -> f (g x) :: (r1 -> r) -> (r2 -> r1) -> r2 -> r
15:04:20 <rvxi> huh, I didn't realize fromInteger was getting called implicitly.
15:04:27 <mniip> :t \f g x -> f (g x)
15:04:28 <lambdabot> (r1 -> r) -> (r2 -> r1) -> r2 -> r
15:04:46 <mniip> isn't that the renamer?
15:04:56 <andrybak> :t (.)
15:04:58 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:05:13 <rvxi> huh interesting it uses "r" in this case
15:05:18 <rvxi> λ> :t \x -> x
15:05:18 <rvxi> \x -> x :: r -> r
15:05:27 <c_wraith> :t let f g h x = g (h x) in f
15:05:28 <rvxi> where does that r come from?
15:05:28 <lambdabot> (t1 -> t) -> (t2 -> t1) -> t2 -> t
15:06:39 <mniip> yeah I'm wondering that oo
15:08:15 <mniip> ah
15:08:24 <mniip> TcPatSyn.hs:       ; let tv_name = mkInternalName uniq (mkTyVarOcc "r") loc
15:09:08 <mniip> :t \a -> a
15:09:09 <lambdabot> r -> r
15:11:19 <zzing> If I wanted to do binary serialization and deserialization — what library should I use?
15:11:25 <mniip> basically there are multiple things in the source that generate type variables, and there's no clear way to know which one will be used
15:12:13 <rvxi> odd
15:14:06 <mniip> rvxi, it's an unimportant implementation detail
15:14:55 <rvxi> yeah i suppose. confusing for beginners though as one might reasonably suppose there's a significance to the different conventions.
15:20:04 <mniip> rvxi, not at all
15:20:17 <mniip> lowercase type entities are type variables
15:20:32 <mniip> the name doesn't matter, only thing that matters is whether two are equal or not
15:22:18 <rvxi> anyone use emacs haskell-mode + ghci?
15:22:51 <Spaceghost> .wiki ghci
15:27:32 <hxegon> how do I run the tests for the cis194 course? https://www.seas.upenn.edu/~cis194/lectures.html
15:29:11 <sleblanc> Randomly browsing GHC source code: what is {-# RULES … #-} ? https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.List.html#zipWith
15:31:21 <zzing> I like attoparsec, but when I get a parse error I can't really find out where the error is.
15:34:46 <jay6981> sounds like yacc
15:37:17 <zzing> yacc is saner
15:38:07 <zzing> I could probably use the conduit parsers — but I have no evidence it will give me any more information. What options are left to me?
15:38:11 * hackagebot Spock 0.10.0.0 - Another Haskell web framework for rapid development  https://hackage.haskell.org/package/Spock-0.10.0.0 (AlexanderThiemann)
15:38:23 <Jello_Raptor> hmm, is there some way to use quickCheck to verify that "using function f on an infinite lists will hang" ? 
15:38:59 <Jello_Raptor> for reasonable values of "hang"? 
15:39:45 <zzing> Jello_Raptor, sounds like what you are looking for is a turing machine to test another turing machine for termination.
15:39:47 <sleblanc> Jello_Raptor, doesn't that require solving the halting problem?
15:40:14 <muesli4> "reasonable values"! :D
15:40:23 <tommd> In the general case perhaps, but not for all functions.
15:40:29 <Jello_Raptor> zzing: sleblanc: for a perfect solution sure. what i actually want is "this doesn't halt in 3-4 seconds" 
15:40:37 * glguy has also heard of the Turing test and wants to write into channel
15:40:45 <tommd> lol
15:40:52 <Jello_Raptor> :P
15:40:53 * glguy is bot
15:40:55 <tommd> But but, Byron Cook!
15:41:34 <Jello_Raptor> that was a badly worded question, but still, can i use quickCheck to make sure that a function doesn't halt before some fixed amount of time? 
15:41:43 <zzing> glguy, by the way — your solution works, except for I might have to throw it out because of the standard for error reporting is fairly low on attoparsec ;-(
15:42:16 <sleblanc> Jello_Raptor, check if quickcheck supports "timeout"
15:42:20 <muesli4> Jello_Raptor: I tried that once, with threads and killing one. But something didn't work out as expected, so as far as I am concerned, no.
15:44:11 * monochrom tests glguy
15:44:33 <monochrom> glguy: what would you answer if you were asked "do you ever lie?"? :)
15:44:35 <sleblanc> Jello_Raptor, I think you can combine your test with a timeout: https://hackage.haskell.org/package/control-timeout-0.1.2/docs/Control-Timeout.html
15:45:02 <Jello_Raptor> glguy: pm 
15:45:44 <Jello_Raptor> sleblanc: cool, thanks. 
15:46:34 <glguy> monochrom: Time limit exceeded
15:46:40 <zzing> Does an "online" parser combinator mean it can work with streaming data?
15:46:48 <monochrom> haha
15:48:17 <sleblanc> Jello_Raptor, for example, your test can be run in a forked process, you set the timeout and if it reaches the timeout, it kills the process and passes the test. If the forked process returns before the timeout, the test fails
15:48:32 <glguy> zzing: Which solution are we talking about?
15:48:39 <jay6981> everything I say is a lie. except that. and that, … 
15:50:22 <Jello_Raptor> sleblanc: yup, the only awkward bit is keeping test runtimes vaguely low, but that isn't a huge issue.  
15:50:53 <lifter> Is there no standard way in Haskell to print an integer such that there are commas interspersed (1000 becomes "1,000", etc.)
15:50:56 <zzing> glguy, the conduit one with parsing using awaitForever
15:51:15 <sleblanc> Jello_Raptor, if you are not opposed to multi-threading your test, make it the first test, and make it run in parallel with the rest (just an idea)
15:51:31 <zzing> I am thinking now of the uu-parsinglib
15:52:03 * zzing must go for dinner.
15:52:10 <zzing> Watch the monads for me.
15:53:34 <Jello_Raptor> sleblanc: yup, that was my plan. :) 
15:56:14 <Welkin> hm
15:56:32 <Welkin> what is this I keep hearing about people who want to remove monads from haskell?
15:56:56 <Welkin> is this the same vocal minority (who often work at google) who freaked out over FTP?
15:56:57 <Jello_Raptor> Welkin: D: 
15:57:24 <Jello_Raptor> Welkin: wait, people are still freaking out over FTP? (or are we not talking about the file transfer protocol) 
15:57:33 <jay6981> must be something else
15:57:41 <Welkin> FTP, AMP, and more
15:57:46 <Jello_Raptor> Welkin: what is the argument against monads? 
15:57:53 <Welkin> Jello_Raptor: no idea
15:58:42 <Welkin> oleg wrote something about how you can accomplish the same goal that monad transformers solve without using monad transformers
15:59:03 <Welkin> I just see raichoo or gabriel say things on twitter periodically
15:59:08 <Welkin> I don't keep up with the mailing lists
15:59:20 <tzh> lifter: there's always `reverse . intercalate "," . chunksOf 3 . reverse` i suppose... but i don't think there's a single dedicated function to do that
15:59:37 <Jello_Raptor> Welkin: is this the "Extensible Effects" stuff? 
15:59:51 <lifter> tzh, yeah, thanks, I will likely end up using that
16:00:20 <Welkin> Jello_Raptor: that sounds familiar
16:00:48 <Jello_Raptor> Welkin: http://okmij.org/ftp/Haskell/extensible/ ? 
16:01:28 <Welkin> Jello_Raptor: yeah, that was the oleg paper
16:13:03 <ReinH> Welkin: not using monad transformers doesn't mean not using monads.
16:13:23 <ReinH> I don't know of anyone who wants to remove monads from Haskell
16:13:44 <Welkin> ReinH: read it in a tweet from raichoo
16:22:11 <keviv> So I'm doing an anagram kata on codewars, and ere's my code so far: http://paste.pound-python.org/show/xeUFqb54nEHLjnNOWH8g/
16:22:51 <keviv> I keep getting this error: Anagram.hs:10:9-37: Irrefutable pattern failed for pattern (cleanA : cleanAs)("W",".,")
16:23:15 <keviv> (when using the arguments "Hello" and "World")
16:23:28 * hackagebot SFML 2.3.2.2 - SFML bindings  https://hackage.haskell.org/package/SFML-2.3.2.2 (sulami)
16:23:31 <keviv> What exactly does the ("W",".,") mean?
16:24:11 <jophish> Would there be any harm in allowing a module to import itself?
16:24:48 <Welkin> jophish: import itself?
16:24:53 <Welkin> you mean export itself?
16:25:10 <ReinH> Welkin: link to tweet?
16:25:30 <Welkin> ReinH: lost in the intertubes
16:25:59 <jophish> Welkin: no, import as in: module Hello where import Hello as H; ...
16:26:17 <Welkin> jophish: no idea, bu that sounds like it won't work
16:26:58 <jophish> Welkin: it doensn't with ghc :/
16:27:13 <ReinH> jophish: well yes, there would be harm in that it wouldn't work
16:27:18 <ReinH> but I don't see how it would be useful at all either
16:27:48 <jophish> ReinH: I'm generating a bunch of Haskell code and it's a (very minor) pain to have to special case this one file
16:28:06 <ReinH> Well, probably less of a pain than rewriting GHC.
16:28:24 <jophish> also does this make it impossible to use names from the current module qualified?
16:28:48 <dmj> keviv: why not use Data.Set and check if one word is a subset of the other?
16:28:54 <jophish> ReinH: I'd have thought it would be a simple change to allow, 'import ThisModule' declarations: don't do anything at all!
16:29:23 <dmj> > S.isSubsetOf (S.fromList "cinema") (S.fromList "iceman")
16:29:25 <lambdabot>  True
16:29:45 <keviv> oh sweet
16:29:49 <dmj> keviv: unless you want a proper subset
16:29:55 <Shoggoth_> Hi! I’m wanting to cross compile the haskell-platform source;  there’s some seemingly out of date instructions here (http://tim.dreamwidth.org/1715938.html)…  can anyone point me in the right direction?
16:30:02 <dmj> keviv: how do they define anagram?
16:30:11 <keviv> dmj: yeah actually I think it'd need to be proper
16:30:28 <keviv> dmj: "Any word or phrase that exactly reproduces the letters in another order is an anagram."
16:30:40 <keviv> err
16:30:44 <keviv> not proper
16:31:00 <keviv> going in the opposite direction
16:31:12 <dmj> keviv: oh, just sort them both and test equality, since we know length is constant
16:31:13 <sleblanc> keviv, that's a palindrome
16:31:29 <keviv> sleblanc: palindrome is a special case
16:31:44 <jophish> x `isAnagramOf` y = sort x == sort y
16:31:52 <keviv> wow that makes it simple
16:32:17 <jophish> or: (==) `on` sort
16:32:29 <Big_G> Doesn't that need a $ on the right hand side of the ==?
16:32:59 <keviv> prefix has a higher precedence than infix right?
16:33:14 <Big_G> Don't know
16:33:34 <akfp> what's the typical servant error message length?  the first I got was 233 lines long.  where should I start?
16:33:36 <c_wraith> yes, standard function application always has higher precedence than infix operators
16:34:27 <Big_G> c_wraith, I learn something new everyday
16:34:41 <dmj> akfp: I've gotten 600 before :P 
16:34:50 <dmj> akfp: can you paste your API defintion on lpaste.net ?
16:36:02 <keviv> Still, what exactly does the ("W",".,") mean in that traceback?
16:37:14 <dmj> keviv: can you paste the code and the entire error
16:37:20 <keviv> sure
16:38:40 <akfp> dmj: never mind, I had an extra 'manager' argument applied.  seems like the servant examples change over time.
16:39:11 <keviv> hrm
16:39:41 <keviv> dmj: it seems to not be reproducible after some modifications to the code, so I'll go back to the buggier one
16:41:15 <keviv> dmj: code: http://paste.pound-python.org/show/DGP0Wz4Hv9f00u41ZZ7g/
16:41:24 <keviv> exception: http://paste.pound-python.org/show/vNfDSNgypUee1ExqGnsM/
16:44:50 <m1dnight_> I'm having some issues with my alex/happy parser. I have shift reduce conflicts and think I know the cause, but Im not sure.
16:44:58 <m1dnight_> Anyone have aminute to take a look?
16:45:47 <dmj> keviv: there is the possibility that sanitize can return an empty list, '(cleanA:cleanAs) = sanitize a' doesn't account for the empty list case
16:46:26 <dmj> keviv: I'm not sure that is the particular error you are receiving, or why a tuple is involved
16:46:55 <glguy_> m1dnight_ if you wait for someone to ask you to ask your question you're less likely to get help
16:47:43 <dmj> keviv: my thought is that since 'sanitize "," == []' it causes a pattern match failure on (cleanA:cleanAs)
16:47:56 <keviv> dmj: oh that's true of course
16:48:15 <keviv> dmj: but I was wondering about the tuple as well
16:48:29 * hackagebot MagicHaskeller 0.9.6.4.7 - Automatic inductive functional programmer by systematic search  https://hackage.haskell.org/package/MagicHaskeller-0.9.6.4.7 (SusumuKatayama)
16:48:43 <dmj> keviv: are you running a test? can you paste *all* of the code?
16:49:39 <keviv> dmj: here are the tests they have: http://paste.pound-python.org/show/CeycWLfAZSZC8V2KL4Zu/
16:50:01 <keviv> dmj: it looks like lines 22 and 23 are where the error is starting
16:52:32 <m1dnight_> https://www.refheap.com/111482 # This is one part that causes s/r conflicts.
16:52:55 <m1dnight_> Im guessing that it is because it can parse a statement and then shift, or parse statements as well, and then shift
16:53:08 <m1dnight_> But Im unsure how I can fix it with right/left priority..
16:53:22 <m1dnight_> I have inserted %right Statements, but that doesnt seem to do the trick
16:54:08 <m1dnight_> I have the same issue with expressions. So solving either would kill all my s/r conflicts
16:54:59 <Big_G> When creating a web service, are there any best practices for dealing with REST endpoints that can accept multiple kinds of input and can send back different forms of output?
16:55:49 <Daedhel99> Hi, Can someone give me advice on writing a recursive function to build a graph from lists of lists of pointnames and distances between those points  e.g [[[A, B, C, D][1, 2, 3], [[E, D, G], [1, 2, 3]], [[D, E, F], [4, 5, 1]]] etc
16:58:18 <glguy> m1dnight_: I don't think you've properly isolated the problem
16:58:35 <glguy> m1dnight_: It'd be better to paste the whole grammar and possibly the .info file that happy generates for it
16:58:39 <m1dnight_> ijat'
16:58:53 <m1dnight_> wow. sorry about that. "okay" I meant, I have those right here
16:59:01 <dinomode_x> omg i have ghci installed on my computer
16:59:15 <dinomode_x> but i cant use it because i dont know haskell lol
16:59:27 <dinomode_x> should i?
16:59:53 <tzh> Daedhel99: are you familiar with Data.Graph.Inductive? it has a `mkGraph` function that you could probably transform that input to match
17:00:05 <m1dnight_> https://www.refheap.com/111484 <- the Parser.y https://www.refheap.com/111485 <- Parser.info file
17:00:24 <dinomode_x> Why is haskell so weird compared to other languages?
17:00:33 <Daedhel99> linesToGraph(_ :[stn1:stn2:stns] : [dist:dists] :rest) = Edge(stn1, stn1, 0) : Edge(stn1 stn2 dist) : otherEdges where otherEdges =  linesToGraph stn2:stns dists rest
17:00:41 <Daedhel99> i was thinking i could get something like this to work
17:01:57 <Welkin> dinomode_x: you mean, why is haskell so amazing?
17:02:23 <Daedhel99> trying to get a list of nodes and distances between them in the form of [(A, B, 1), (B, C, 2)..] so  i could see that from A to C the cost is 3
17:02:25 <dinomode_x> dunno never used it before. Looks really complicated tho
17:02:47 <m1dnight_> dinomode_x: probably hasnt seen APL before.
17:03:12 <dinomode_x> nope, only the mainstream languages :P
17:03:39 <Iceland_jack> dinomode_x: How do you define a function that doubles its argument?
17:03:39 <Iceland_jack>     foo x = x + x
17:03:39 <Iceland_jack> at least it's not complicated so far :)
17:04:05 <m1dnight_> @pl \x -> x + x
17:04:05 <lambdabot> join (+)
17:04:07 <m1dnight_> ah!
17:04:13 <m1dnight_> I love that feature <3
17:04:36 <tzh> Daedhel99: really unless it's important that you roll your own graph code, i'd recommend using the `fgl` lib; it has shortest-path functions that does that (as well as a lot more) http://hackage.haskell.org/package/fgl-5.5.2.3
17:04:40 <dinomode_x> function(a){return a + a}
17:05:03 <Iceland_jack> Using Monad ((->) r) may prove dinomode_x's point I'm afraid!
17:05:14 <dmj> dinomode_x: it's worth learning, have you ever read 'beating the averages' by paul graham?
17:05:18 <Daedhel99> Yeah unfortunately I have to write it myself tzh :(
17:05:20 <Iceland_jack> dinomode_x: What part do you find complicated
17:05:31 <Daedhel99> and then implement djisktras on it
17:05:33 <Welkin> dmj: lol, paul graham
17:05:44 <Welkin> dmj: really? you are referencing that?
17:05:47 <Iceland_jack> dinomode_x: Not quite the same as what I wrote, what you wrote it more akin to
17:05:47 <Iceland_jack>     \a -> a + a
17:05:47 <Iceland_jack> in Haskell
17:06:37 <Iceland_jack> Not all that scary
17:06:40 <dinomode_x> Actually the syntax is what puts me off but I'm sure it's powerful.. so I may give a go someday
17:07:00 <Welkin> dinomode_x: the syntax is easier to understand/read than other languages
17:07:01 <dmj> Welkin: well, he quotes eric raymond, who spoke on the power of lisp, raymond would go on to say the same about haskell, http://esr.ibiblio.org/?p=1796
17:07:07 <mniip> [04:02:25] <m1dnight_> dinomode_x: probably hasnt seen APL before.
17:07:17 <mniip> apl is a simple array processing language
17:07:17 <m1dnight_> glguy: If I understand correctly, for the first source of s/r conflicts it is because I have the varname. It can either shift and continue with the first rule, or reduce and use the second rule.
17:07:30 <dmj> Welkin: beating the averages is a great article, you should read it
17:07:37 <m1dnight_> The only technical problem I have is how I can write down the precedence of the varname. e.g., %right varname
17:07:46 <m1dnight_> It doesnt seem to fix it right now , so I guess it's wrong..
17:07:55 <glguy> m1dnight_: One of your problems is your "do"
17:07:56 <dinomode_x> Ok I'll try it out sometime thanks :)))
17:08:33 <Iceland_jack> dinomode_x: The syntax put me off initially, I was strongly against the Haskell/ML-syntax but with time it won me over begrudgingly :)
17:08:39 <glguy> m1dnight_: You'll need something like  | do '{' Exprs '}' 
17:09:03 <Welkin> dmj: I have read many of paul graham's essays
17:09:13 <Welkin> dmj: few of them are any good
17:09:16 <m1dnight_> How did you pinpoint the do, if I may ask?
17:10:04 <Welkin> dmj: you are probably talking about the "blub paradox" one
17:10:14 <glguy> m1dnight_: Looking at the info file at State 57
17:10:17 <Welkin> for which lisp itself is a blub
17:10:17 <Welkin> lol
17:11:10 <dmj> Welkin: no, I'm not, I'm referring to this article: http://www.paulgraham.com/avg.html
17:11:46 <dmj> I guess it mentions the blub paradox inside of it
17:12:08 <dmj> but the entire article is about the benefits of functional programming in a startup
17:13:31 <m1dnight_> glguy: But nothing points to the do explicitly, right?
17:13:42 <m1dnight_> Im just trying to learn here, sorry if Im whining :>
17:13:53 <glguy> m1dnight_: I fixed the list of Expr and Statements to be left-recursive first
17:14:05 <m1dnight_> I was trying that, but how do do that?
17:14:06 <glguy> and then it stands out more
17:14:10 <m1dnight_> Im missing the syntax
17:14:20 <m1dnight_> I tried %right Statement/Statements/..
17:14:34 <glguy> | Statements Statement { ... }
17:15:41 <glguy> Oh, actually that solves the rest of it
17:15:52 <glguy> I had a typo, extra 's'
17:15:53 <m1dnight_> oh but that reverses the order so ill have to reverse the list of expressions :D
17:15:57 <glguy> Yeha
17:16:10 <m1dnight_> Funny results that way :>
17:16:37 <glguy> Once you switch exprs/statements to be left-recursive and provide some way to disambiguate your do notation it loads
17:17:57 <m1dnight_> yep I fixed it
17:18:01 <m1dnight_> thanks a bunch :)
17:18:09 <m1dnight_> Never would have though about making it left recursive that way
17:18:20 <m1dnight_> You have made me a more experienced man, thanks :p
17:19:59 <m1dnight_> and on that note im off to bed o/
17:23:14 <glguy> m1dnight_: You're welcome :)
17:52:31 <vektorweg1> hello all
17:53:00 <Iceland_jack> hey vektorweg1 
17:53:38 <vektorweg1> :D
17:53:56 <vektorweg1> when I have to signalize a thing should be stopped, whats a better name than Maybe and the signal Nothing to stop? 
17:55:00 <vektorweg1> i was thinking of Endable or so. but doesn't sound so fleshy also.
17:55:12 <cloj_dev> http://pastebin.com/PCTM18p8
17:55:25 <cloj_dev> I'm trying to get this function to work, but I'm not sure whats wrong with it
17:57:35 <Iceland_jack> cloj_dev: You basically want to implement concat?
17:57:35 <Iceland_jack>     concat :: [[a]] -> [a]
17:57:35 <Iceland_jack> @src concat
17:57:35 <lambdabot> concat = foldr (++) []
17:58:02 <mniip> cloj_dev, x is a list, why are you folding (++) over it
17:58:14 <cloj_dev> no not concat
17:58:30 <cloj_dev> ie fringe [[[1,2],[3,4]]]  returns [1,2,3,4]
17:58:39 <Iceland_jack> Yeah that's not going to work
17:58:42 <mniip> that's what the function does currently
17:58:52 <cloj_dev> concat [[[1,2],[3,4]]] returns [[1,2],[3,4]]
17:59:01 <mniip> @let fringe [] = []; fringe (x:xs) = foldl (++) [] x ++ fringe xs
17:59:02 <lambdabot>  Defined.
17:59:06 <Iceland_jack> > concat [[[1,2],[3,4]]]
17:59:06 <mniip> > fringe [[[1,2],[3,4]]]
17:59:07 <lambdabot>  [[1,2],[3,4]]
17:59:09 <lambdabot>  [1,2,3,4]
17:59:37 <cloj_dev> > fringe [[1,2], [3,4]]
17:59:39 <lambdabot>      No instance for (Show t0)
17:59:39 <lambdabot>        arising from a use of ‘show_M83640940023247368327634’
17:59:39 <lambdabot>      The type variable ‘t0’ is ambiguous
18:00:08 <mniip> you're trying to interpret '1' as a list
18:00:16 <cloj_dev> right
18:00:19 <cloj_dev> interesting
18:00:26 <cloj_dev> so maybe if I used cases?
18:00:34 <Iceland_jack> mniip: What I meant is that it cannot do that while satisfying
18:00:34 <Iceland_jack>     fringe [[1,2],[3,4]] == [1,2,3,4]
18:00:43 <mniip> yeah that is impossible
18:00:52 <cloj_dev> its impossible?
18:01:00 <mniip> what would be the type of such function
18:01:23 <cloj_dev> what's the function that receives [[1,2], [3,4]] and returns [1,2,3,4]?
18:01:28 <mniip> concat
18:01:31 <cloj_dev> ah
18:01:39 <mniip> :t concat
18:01:40 <lambdabot> Foldable t => t [a] -> [a]
18:01:43 <mniip> :t fringe
18:01:44 <lambdabot> Foldable t1 => [t1 [t]] -> [t]
18:01:45 <cloj_dev> interesting
18:01:53 <mniip> ugh
18:02:08 <cloj_dev> why ugh?
18:02:11 <mniip> imagine it says [[a]] -> [a], and [[[a]]] -> [a]
18:02:19 <cloj_dev> hehe
18:02:23 <Iceland_jack>     concat ::  [[a]]  -> [a]
18:02:24 <Iceland_jack>     fringe :: [[[a]]] -> [a]
18:02:52 <vektorweg1> double concat. 
18:03:12 <mniip> :t concat . concat . concat . concat
18:03:14 <lambdabot> Foldable t => t [[[[a]]]] -> [a]
18:03:24 <cloj_dev> I see
18:05:59 <vektorweg1> hm. why isn't concat defined with Monoid in mind? 
18:07:13 <Iceland_jack> vektorweg1: That's basically 'fold'
18:07:15 <Iceland_jack> :t fold
18:07:17 <lambdabot> (Foldable t, Monoid m) => t m -> m
18:07:18 <Iceland_jack>  :: [[a]] -> [a]
18:07:24 <Iceland_jack> :t fold :: [[a]] -> [a]
18:07:24 <vektorweg1> oh. i forgot. we have mconcat
18:07:27 <lambdabot> [[a]] -> [a]
18:07:59 <vektorweg1> but mconcat isn't defined with Foldable. lol. 
18:08:36 <vektorweg1> :t mconcat
18:08:38 <lambdabot> Monoid a => [a] -> a
18:09:54 <vektorweg1> :t foldl mappend mempty
18:09:55 <lambdabot> (Foldable t, Monoid b) => t b -> b
18:11:03 <vektorweg1> ah
18:11:04 <Iceland_jack> They are along different paths
18:11:04 <Iceland_jack>   concat :: [[a]] -> [a] --FOLDABLE-> concat :: F [a] -> [a]
18:11:04 <Iceland_jack>     -MONOID-v                            -MONOID-v
18:11:04 <Iceland_jack>   mconcat :: [M] -> M    --FOLDABLE-> fold :: F M -> M
18:11:05 <vektorweg1> fold
18:11:30 <Iceland_jack> where M = Monoid, F = Foldable
18:11:40 <vektorweg1> so ... best thing is to stick with fold then.
18:11:49 <Iceland_jack> If you want the most general signature
18:11:55 <vektorweg1> always. :p
18:12:14 <Iceland_jack> So you use fmap instead of (.) :)
18:12:19 <keviv> Question about my question, are pastes of a few lines acceptable, or should I use a code paste service?
18:13:28 <vektorweg1> Iceland_jack: no, but i'm thinking about using an own prelude where (.) === fmap . 
18:13:29 <vektorweg1> or so.
18:14:07 <Iceland_jack> I encourage people to experiment with their own ‘defaults’ (Prelude)
18:15:47 <keviv> In this function, why does sort . toLower . filter isAlphaNum (without a map) not match the types correctly?
18:15:50 <keviv> isAnagramOf :: String -> String -> Bool
18:15:50 <keviv> isAnagramOf x y = clean x == clean y
18:15:50 <keviv>   where clean = sort . map toLower . filter isAlphaNum
18:16:36 <Iceland_jack> keviv: it seems to fit fine
18:16:37 <Iceland_jack> :t \x y -> let clean = sort . map toLower . filter isAlphaNum in clean x == clean y
18:16:39 <lambdabot> [Char] -> [Char] -> Bool
18:16:51 <keviv> Iceland_jack: without the map
18:17:23 <Iceland_jack> well without the map it doesn't work because "toLower" only operates on individual characters
18:17:38 <keviv> Iceland_jack: the docs said it can work on Text
18:18:14 <vektorweg1> perhaps there is another toLower in another module than Data.Char ?
18:18:23 <keviv> oh duh
18:18:26 <keviv> yeah
18:18:32 <keviv> It says Data.Text
18:18:35 <rvxi> hmm
18:19:27 <rvxi> Interactive-Haskell seems broken for anything other than 1 file scripts (projects with cabal files)
18:19:33 <rvxi> anyone else have this problem in emacs?
18:19:51 <rvxi> Start interpreter or load file just gives me an unresponsive lambda prompt
18:20:34 <Big_G> :t clean
18:20:36 <lambdabot> Not in scope: ‘clean’
18:21:15 <vektorweg1> Big_G: the Clean programming language irc is elsewhere. :p
18:21:47 <Iceland_jack> keviv: That's a different function in a different module
18:21:58 <Iceland_jack> :t Data.Text.toLower
18:21:59 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text
18:22:00 <Iceland_jack> :t toLower
18:22:02 <lambdabot> Char -> Char
18:22:22 <Iceland_jack> To get the functionality of 'toLower' for String you need
18:22:22 <Iceland_jack> :t map toLower
18:22:23 <lambdabot> [Char] -> [Char]
18:23:04 <wolfcore> rvxi: anything in *Messages* buffer?
18:23:10 <keviv> Iceland_jack: yeah thanks, idk why I didn't see it was in another module
18:23:55 <keviv> I'm really starting to like haskell
18:24:11 <Iceland_jack> :) That means it's working
18:24:12 <rvxi> wolfcore only Scanning declarations in foo.hs... ( 61%)
18:24:12 <rvxi> Sorting declarations in foo.hs...done
18:25:32 <rvxi> incidentally what is emacs doing under the hood when it does "Load File"
18:25:35 <wolfcore> rvxi: hmmm... maybe you have haskell-process-type set to the wrong thing? if you're using stack you need (custom-set-variables '(haskell-process-type 'stack-ghci))
18:25:46 <rvxi> ?
18:25:54 <rvxi> it doesn't seem to be the same thing as ghci or cabal repl
18:26:30 <wolfcore> rvxi: what do you mean?
18:27:01 <wolfcore> it should be haskell-interactive-mode
18:27:49 <vektorweg1> Iceland_jack: got any names for end signal stuff?
18:28:29 <rvxi> i mean if i were to try to get the equivalent behavior of C-c C-l
18:28:35 <rvxi> outside emacs, what would i do?
18:29:27 <keviv> Any builtin function that provides applyTwice f n = f n n?
18:29:45 <Iceland_jack> keviv: join
18:29:56 <Iceland_jack> vektorweg1: Don't know what you mean
18:30:11 <Iceland_jack> :t join :: (r -> r -> a) -> (r -> a)
18:30:13 <lambdabot> (r -> r -> a) -> r -> a
18:30:32 <Iceland_jack> Same as "(+) 5 5"
18:30:33 <Iceland_jack> > join (+) 5
18:30:36 <lambdabot>  10
18:30:45 <keviv> ahh
18:31:16 <Iceland_jack> So applying a function twice is the same operation 'join' as collapsing a list of lists with 'concat'
18:32:34 <keviv> Thanks Iceland_jack 
18:33:10 <Iceland_jack> They're both doing the same thing, collapsing structure: only one collapses lists, the other collapses the structure of a binary function (two argument) into a unary function (one argument), the fact that (->) is infix sometimes obscures this
18:33:10 <Iceland_jack>  
18:33:15 <Iceland_jack> @let type Arr a b = a -> b
18:33:16 <lambdabot>  Defined.
18:33:23 <Iceland_jack> :t join :: Arr r (Arr r a) -> Arr r a
18:33:25 <lambdabot> Arr r (Arr r a) -> Arr r a
18:34:10 <negatratoron> so, yield :: Monad m => o -> ConduitM i o m ()
18:34:24 <negatratoron> is there a function f :: Monad m => m o -> ConduitM i o m ()
18:34:42 <wolfcore> rvxi: ghci
18:34:58 <wolfcore> rvxi: :load
18:35:38 <glguy> yield <=< lift :: Monad m => m o -> ConduitM i o m ()
18:35:48 <rvxi> hm that's definitely not what my instance of emacs is doing
18:36:08 <rvxi> ghci followed by load shows the module as the prompt
18:36:10 <rvxi> and also works
18:36:16 <negatratoron> let me look up <=<
18:36:16 <rvxi> by contrast c-c c-l
18:36:32 <negatratoron> i had tried "lift" on its own; it has the right type signature but didn't do what i expected
18:36:45 <glguy> \m -> yield =<< lift m
18:36:51 <Big_G> :t join
18:36:52 <lambdabot> Monad m => m (m a) -> m a
18:36:53 <rvxi> when i don't have a cabal project, it has this message at the top
18:36:55 <rvxi> The lambdas must flow.
18:36:55 <rvxi> If I break, you can:
18:36:56 <rvxi> ...
18:37:04 <rvxi> and the prompt is a lambda symbol
18:37:11 <rvxi> when i am in a cabal project
18:37:14 <Big_G> Iceland_jack, Why does your def give a different type (beyond the type casting?
18:37:15 <wolfcore> rvxi: that's what I have
18:37:19 <rvxi> it just shows the prompt and gets stuck with no repl
18:37:23 <rvxi> response
18:37:28 <rvxi> i type stuff and get nothing back
18:37:53 <rvxi> none of that happens if i launch ghci or cabal repl from a shell
18:38:35 <wolfcore> rvxi: are you on the latest version of haskell-mode?
18:39:10 <negatratoron> okay, interesting
18:39:20 <negatratoron> it works
18:40:00 <rvxi> wolfcore apparently 20151107.1406
18:40:02 <lethjakman-l> So..I'm looking at wrapping some C libraries in haskell, is there anything else important I should read besides the real world haskell chapter?
18:41:13 <dmj> lethjakman-l: check out 'inline-c' 
18:41:14 <vektorweg1> Iceland_jack: re. sorry, i needed to tell someone that their model wasn't accurate. :p
18:41:14 <vektorweg1> what i mean was my earlier question on how to name a type that can escape/end the computation, as an alias for Maybe.
18:41:34 <dmj> lethjakman-l: https://github.com/fpco/inline-c
18:42:08 <lethjakman-l> dmj: I'll read that as well, thank you!
18:44:36 <vektorweg1> like `f :: a -> Maybe a` where f is called many times and when f returns a Nothing it isn't called again.
18:44:55 <Jello_Raptor> aargh -_- what the fuck haskell " Could not deduce (UnfoldableM t Identity a1)    arising from a use of ‘appendUnfoldM'   from the context (UnfoldableM t Identity a,..." 
18:45:04 <wolfcore> rvxi: here's my config http://sprunge.us/gPHT though some might be outdated
18:45:13 <vektorweg1> but more difficult. so this is an simplified model. 
18:45:47 <Jello_Raptor> I have no idea why haskell can't just unify a and a1 >_< 
18:47:16 <dmj> vektorweg1: \(xs :: [a]) -> catMaybes $ takeWhile isJust (map f xs)
18:47:30 <rvxi> wolfcore hmm i'm still using ghci/cabal repl. haven't migrated to stack for package management yet
18:52:05 <vektorweg1> dmj: i would have done it different, but this wasn't the question. the question whats a good name for a end signal, e.g. good names to replace Maybe, Just, Nothing for an optional end signal. 
18:53:33 * hackagebot HaskellNet-SSL 0.3.2.1 - Helpers to connect to SSL/TLS mail servers with HaskellNet  https://hackage.haskell.org/package/HaskellNet-SSL-0.3.2.1 (DanielWright)
18:53:39 <dmj> vektorweg1: 'Done' ?
18:53:56 <vektorweg1> dmj: uh. not bad. 
18:54:12 <vektorweg1> thank you.
18:54:26 <Jello_Raptor> okay :/ ScopedTypeVariables doesn't help me, since GHC still renames the 'a' in my explicit type declaration  
18:54:28 <dmj> data Status a = Next a | Done
18:55:02 <vektorweg1> dmj: now I feel stupid for not simply calling it status. :p
18:55:24 <glguy> Jello_Raptor: You should paste the code itself if you want help figuring out what you've done wrong
18:56:21 <Jello_Raptor> glguy: i'm trying to pare it down to a minimum working example, but it's a test case for a library with complex sigs. I suppose I could just give you the relevant type sigs and functions.
18:59:52 <saulzar_> I see criterion has this 'env' thing to setup a pre-computation, but apparently it only calls it once for each benchmark, does anyone know how to get it to create a fresh environment for every run?
19:03:36 <Jello_Raptor> here's a (likely) sufficent subset of my code http://lpaste.net/144915 with the error at the end. I genuinely have no idea how to get 'a' and 'a1' to unify :/ not to mention this entire system seems to require *far* too many manual type annotations, any of which just fix issues where haskell won't unify types or use the one valid instance for a typeclass it finds. 
19:04:08 <Jello_Raptor> oh oops, the error is not on like 61 in the paste, it's on 60. I messed that edit up. 
19:16:13 <MarcelineVQ> is there an irc room for the servant package?
19:16:25 <dmj> #servant
19:16:49 <MarcelineVQ> Well now don't I feel silly for not trying that first
19:16:52 <Jello_Raptor> ok here we go. This should be reasonable closure of relevant functions http://lpaste.net/8244079331127590912 I'm honestly not sure i even understand the message I get when i leave off the type annotation (see the very end of the paste). I have a stack of instances that should relate the type variables together, but GHC seems to think it has to decide which?
19:16:53 <MarcelineVQ> thanks :>
19:18:07 <glguy> Jello_Raptor: appendUnfoldEqualityCheck needs to use scoped type variables as written
19:18:14 <glguy> Jello_Raptor: so add a forall a t t'. to the type signature
19:19:09 <glguy> and then the file you pasted 144915 will load
19:19:34 <Jello_Raptor> glguy: The extension needs an explicit forall to work? huh. 
19:20:03 <glguy> Jello_Raptor: It's written that way so that merely turning on the extension doesn't break previously valid type signatures
19:20:15 <glguy> You have to mark type variables that should be scoped explicitly with foralls
19:20:32 <Jello_Raptor> ahh, that makes sense. 
19:20:45 <rvxi> glguy do you do gl in haskell?
19:21:18 <glguy> You mean "OpenGL"?
19:21:49 <rvxi> yes
19:21:54 <glguy> No, I don't.
19:22:03 <rvxi> :(
19:29:50 <Lokathor> but you're the gl guy!
19:31:08 <tommd> Lokathor: Yeah, glguy and lispy should switch names, perhaps
19:34:28 <jamesfordummies> can someone explain this type error to me? http://lpaste.net/791920054449995776
19:34:40 <Gurkenglas> Jello_Raptor, UnfoldM looks like CofreeT with Maybe except that you're doing lists and CofreeT would do a nonempty list
19:35:45 <Lokathor> Gurkenglas, there's too many possible types that the expression could be
19:35:58 <Lokathor> you just have to provide an explicit type signature
19:36:04 <tommd> jamesfordummies: You seem to have forgotten to derive (Ord) for your data type.
19:36:38 <jamesfordummies> tommd: doesn’t 2 get inferred as an Int, and doesn’t Int derive ORd?
19:36:43 <Jello_Raptor> Gurkenglas: oh? i can't say I actually understand comonads though
19:36:53 <Lokathor> Gurkenglas, try: bstInsert (Leaf 2 :: Tree Int) `shouldBe` (Node Leaf 2 Leaf)
19:37:09 <Gurkenglas> Lokathor, you mixed me up with someone
19:37:20 <Lokathor> whoops, jamesfordummies those were for you
19:37:54 <jamesfordummies> Lokathor: bstInsert takes 2 parameters
19:37:56 <jamesfordummies> not 1
19:38:07 <Guest63035> help
19:38:36 <Guest63035> how can I do that 
19:38:36 <keviv> What should I be doing differently here with regarding types? http://paste.pound-python.org/show/YPhGEOLowMZLQz8xqK8z/
19:38:37 <Guest63035> Write a function anyBigNumbers that takes a threshold and a list of numbers and returns True if any of the numbers is > threshold, false otherwise.  anyBigNumbers 100 [4,5,600]   à True  anyBigNumbers 100 [4,5,6]       à False
19:38:39 <Lokathor> oh right, sorry, i had the ( off, i guess: (bstInsert Leaf 2 :: Tree Int) `shouldBe` (Node Leaf 2 Leaf)
19:38:51 <tommd> jamesfordummies:  Indeed my mis-read you don't need or, but the snippet of code you provided, bstInsert, does not have the problem.  It is elswhere with this undefined stuff you included below.
19:39:40 <Guest63035> ?
19:39:42 <Gurkenglas> Jello_Raptor, you might also be interested in https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html#t:Unfoldable
19:40:10 <jamesfordummies> Lokathor: any way to avoid this explicit signature?
19:40:16 * tabemann always assumed that the "gl" in glguy referred to OpenGL
19:41:43 <Lokathor> jamesfordummies, not that i'm aware of.
19:41:49 <jamesfordummies> :/
19:41:56 <jamesfordummies> thanks Lokathor 
19:43:10 <Gurkenglas> (Jello_Raptor, read "Base t" as "f" and "t" as "f (f (f (...)))")
19:43:35 * hackagebot yesod-raml-docs 0.1.1 - A html documentation generator library for RAML.  https://hackage.haskell.org/package/yesod-raml-docs-0.1.1 (junjihashimoto)
19:43:37 <Jello_Raptor> Gurkenglas: *takes a look*, for some context I'm making a PriorityList monad transformer that lets me express non-deterministic computations with a cost at each step, and gives me a list (from cheapest to most costly) of resulting values. Laziness lets it work beautifully as a monad, but I need to be able to control how i unfold all the various subcomputations.
19:43:46 <AjaxCrixum> hello, all
19:43:49 <AjaxCrixum> i am wondering
19:43:57 <AjaxCrixum> is sicp a good book or bad book?
19:44:01 <AjaxCrixum> is it worth my time?
19:44:05 <AjaxCrixum> i don't want to waste my time
19:44:43 <Jello_Raptor> Gurkenglas: in order to turn it into a monad transformer*
19:45:09 <Gurkenglas> No idea. Sounds like something I would want to master myself at some point.
19:45:12 <Lokathor> AjaxCrixum, it's a good book, but it's not in Haskell if you care about that part of things
19:45:41 <AjaxCrixum> i just read it uses a functional language called scheme, like haskell (functional)
19:45:44 <AjaxCrixum> how would you rate it?
19:45:54 <Lokathor> 10/10 on learning about stuff
19:46:03 <Lokathor> but yeah, it's in Scheme (a kind of Lisp)
19:46:52 <rvxi> ajaxcrixum yes it's good, but you won't learn haskell from it. nothing about types
19:46:57 <Lokathor> really easy to pick up scheme though, the book explains all the stuff you'll need to know as you go. Designed for total beginners to learn fast
19:47:27 <rvxi> i'm so glad i had my intro CS class before unis started switching over to python
19:47:48 <rvxi> (taught by professors who suck at python...)
19:48:35 * hackagebot dead-code-detection 0.4 - detect dead code in haskell projects  https://hackage.haskell.org/package/dead-code-detection-0.4 (SoenkeHahn)
19:48:38 <AjaxCrixum> what will reading sicp allow me to do? like, reading, say, that mit algorithms book will teach you about certain algorithms and stuff; what will sicp teach me to do?
19:48:57 <Jello_Raptor> Gurkenglas: do you have any reccomendations for papers and the like that explain this stuff more? Reading the API isn't really helping :/ 
19:49:10 <jamesfordummies> Lokathor: fun fact, if I switch the argument ordering to b -> BST b -> BST b, the explicit type isn’t necessary
19:51:37 <Gurkenglas> Jello_Raptor, I think this one is relevant http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf
19:51:58 <Gurkenglas> (I don't know whether it'll help you with that API though.)
19:53:20 <Gurkenglas> (Judging relevance from the slogan on https://hackage.haskell.org/package/recursion-schemes )
19:53:40 <Gurkenglas> (Also I think someone once linked that paper as relevant to that library? ^^)
19:58:32 <Jello_Raptor> Gurkenglas: I've actually read that before, and it seems relevant, but I'll have to poke at it more carefully at some point. 
20:01:38 <Jello_Raptor> *sigh* I don't know enough cat theory :/ categorical duals, comonads and the like don't make any sense to me yet. 
20:03:29 * tabemann doesn't know like any category theory, and yet can still program in Haskell, even though stuff like the lens library is beyond me
20:03:36 <tabemann> s/me/him
20:04:09 <ackthet> i guess its just a matter of style but would you write (x : xs) or (x:xs)
20:05:02 <Jello_Raptor> ackthet: (x:xs) 
20:06:37 <Jello_Raptor> tabemann: it took a while for me to understand the basics of lens and even that has proved ludicrously useful 
20:23:15 <ReinH> I suppose that SICP would teach you how to structure and interpret computer programs.
20:25:10 <Big_G> id SICP == SICP
20:26:19 <Jello_Raptor> :O
20:29:36 <Jello_Raptor> also, I don't how to feel about this <_< I've been writing all this complex code, and until earlier today my test cases amounted to "does it compile?". I'm a good chunk through writing test cases now though, and i've yet to find an actual issue in my original code. It's all just so type constrained, there's very little for me to mess up that would allow it to still typecheck. 
20:39:12 <haskell977> I want to group a list of tuple by the first value, is there a more elegant way?
20:39:13 <haskell977> groupBy (\(a, _) (a', _) -> a==a')
20:41:52 <tommd> :t groupBy ((==) `on` fst)
20:41:53 <lambdabot> Eq a => [(a, b)] -> [[(a, b)]]
20:42:15 <tommd> :t on
20:42:16 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
20:42:35 <haskell977> oh great, thanks!
20:53:37 * hackagebot double-metaphone 0.0.1 - Haskell bindings to a C double-metaphone implementation.  https://hackage.haskell.org/package/double-metaphone-0.0.1 (ChristianMarie)
21:33:38 * hackagebot JuicyPixels-scale-dct 0.1.0.0 - Scale JuicyPixels images with DCT  https://hackage.haskell.org/package/JuicyPixels-scale-dct-0.1.0.0 (phadej)
22:45:41 <Fylwind> hrm … anyone know how to get Source hyperlinking to work with cabal haddock? I used --hyperlink-source but the HTMLs to display the source are missing …
22:55:14 <Fylwind> oh, oops apparently it's because I didn't have hscolour installed
22:56:12 <Fylwind> I guess I've grown accustomed ignoring haddock's output so I missed the warning …
22:58:37 <crazy3k> I'm getting a "Parse error in pattern" while loading in GHCi. Any ideas what it could be?
22:58:43 <crazy3k> agregarDeltas f1 f2 (i, j):ps = (i, j, diferenciaEntrePixels p1 p2):(agregarDeltas f1 f2 ps)
22:58:45 <crazy3k>     where p1 = (f1 !! i) !! j, p2 = (f2 !! i) !! j
22:58:58 <Axman6> you needf ((i, j):ps)
22:59:08 <ttt_fff> is there any haskell type extension which lets me encode the length of an array?
22:59:10 <crazy3k> Really?
22:59:15 <crazy3k> Thank you!
22:59:17 <mniip> ttt_fff, yes but no
22:59:22 <ttt_fff> i.e. concat :: Array m -> Array n -> Array m+n ?
22:59:33 <ttt_fff> mniip: tell me the yes part
22:59:44 <mniip> you can use typelits to do the 'm+n' part
22:59:46 <mniip> but
22:59:59 <mniip> you will meet so many obstacles on the way
23:00:11 <ttt_fff> I fear not.
23:00:13 <mniip> including having to unsafeCoerce a few things
23:00:20 <ttt_fff> What type extension do I need to use 
23:00:22 <mniip> because the typesystem is not smart enough
23:00:44 <crazy3k> Axman6: It doesn't like the comma in the second line.
23:01:01 <mniip> DataKinds, GADTs, TypeFamilies
23:01:12 <mniip> I warned you though
23:01:19 <ttt_fff> mniip: can you point me to a blog post?
23:01:33 <mniip> I don't think I can
23:01:50 <ttt_fff> how then do you know it's possible?
23:02:08 <mniip> because I've implemented a category of linear spaces using typelits
23:02:18 <mniip> and that's like arrays squared
23:02:34 <jle`> ttt_fff: there are lot of libraries that offer fixed-length arrays
23:02:52 <mniip> jle`, typelits though?
23:03:13 <jle`> not as many, but one popular one is `linear`, edward kmett's library
23:03:19 <ttt_fff> https://hackage.haskell.org/package/fixed-vector
23:03:23 <ttt_fff> what is def of 'statically known' ?
23:03:24 <ttt_fff> hmm
23:03:49 <kadoban> ttt_fff: In this context, "known at compile time" I'd guess.
23:03:58 <jle`> statically known here means roughly that the length is known at compile-time, i think, but you can do some tricks to get around this
23:04:01 <ttt_fff> oh
23:04:02 <ttt_fff> https://hackage.haskell.org/package/linear-1.20.2/docs/Linear-Vector.html#t:Additive
23:04:05 <ttt_fff> that's kinda cute ?
23:04:25 <jle`> this is what i was referring to -- https://hackage.haskell.org/package/linear-1.20.2/docs/Linear-V.html
23:04:38 <jle`> x :: V 10 Double, x is a vector with 10 doubles
23:05:28 <mniip> [10:03:01] <ttt_fff> what is def of 'statically known' ?
23:05:36 <mniip> in this context it means "encoded within the type"
23:05:50 <mniip> and yes, most commonly those are fixed at compile type
23:06:04 <mniip> but then there are higher rank types and quantified data and then it gets complicated
23:06:04 <Lokathor> initial test shows that 7.10.3-rc2 might be all fixed up on ARM
23:06:08 <Lokathor> woooo
23:06:34 <jle`> there are ways to do reflection to get runtime-determined types
23:06:46 <jle`> but yeah, it's not for the faint of heart at this point
23:07:46 <jle`> it's tricky because you can't do induction with TypeLits, so a lot of things that "should be automatically provable" will have to be implemented with very careful/disciplined usage of unsafeCoerce
23:07:58 <mniip> yes
23:08:06 <mniip> there needs to be a library to do that for you
23:08:08 <jle`> something using type-level peano nats would be probably simpler, at the cost of nice typelits -- http://hackage.haskell.org/package/type-combinators-0.1.0.1/docs/Data-Type-Vector.html
23:08:21 <jle`> but there are plenty of these on hackage
23:08:56 <ent> peano nats sound tasty
23:09:20 <jle`> nutritious, too :)
23:09:47 <mniip> peanuts
23:10:06 <jle`> it would be nice if type-level integer literals were "polymorphic", but that'd require "kindclasses"
23:10:29 <mniip> you mean like
23:10:44 <ent> but would it be possible to use type level peano nuts and some template haskell magic to make them ergonomic?
23:10:49 <ent> nats :D
23:11:08 <mniip> class NumK (k :: BOX) where type family FromNat (a :: Nat) :: k
23:11:16 <jle`> ent: yes, and a few libraries provide that too
23:11:35 <jle`> mniip: yeah, something like that, heh
23:12:00 <jle`> i wonder if that actually works
23:12:58 <mniip>     Type variable ‘k’ used in a kind, in the kind ‘k’
23:13:13 <jle`> ttt_fff: but yeah i've had no problem using Linear's V for my fixed-length vector needs
23:13:26 <mniip> and BOX is an internal name for an uninputtable kind
23:13:30 <jle`> especially because they come equipped with dot products, norms, addition, etc.
23:13:57 <jle`> and you have to stomach the occasional unsafeCoerce when you go from runtime values to types
23:14:25 <jle`> but haskell is all about unsafety and living on the edge
23:14:27 <mniip> jle`, imagine though
23:14:32 <jle`> so viva mas
23:14:36 <mniip> >:k 0
23:14:44 <mniip> >NumK k => K
23:14:54 <jle`> i know right
23:15:11 <mniip> would be pretty badass
23:15:53 <jle`> but technically!  all that unsafeCoerce stuff is no similar than trusting `head` and `tail`, etc.; you basically have to make these decisions with careful planning and verification without the help of GHC
23:16:01 <jle`> er, no different than
23:16:39 <mniip> unsafecoercing gadts though
23:16:45 <mniip> can lead to bad results
23:16:55 <jle`> you have to trust your self
23:17:14 <jle`> which actually is the antithesis of haskell, but :|
23:17:52 <jle`> but most of the unsafeCoerce needed to be able to fake induction with typelits is relatively easy to verify (but easy to typo)
23:33:42 * hackagebot hScraper 0.1.0.0 - A Haskell library to scrape and crawl web-pages  https://hackage.haskell.org/package/hScraper-0.1.0.0 (nishant)
23:48:32 <ReinH> jlewis: unsafeCoerce is the antithesis of Haskell too :p
