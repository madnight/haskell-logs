00:01:40 <cocreature> submain: unsafeCoerce doesn’t even work here, because obviously an Int is represented differently than Double in memory
00:01:59 * hackagebot iban 0.1.1.1 - Validate and generate IBANs  https://hackage.haskell.org/package/iban-0.1.1.1 (ibotty)
00:06:42 <Xandaros> submain: Btw. The answer to "is unsafeX the recommended way" is almost always no :P
00:07:32 <submain> yeah, I thought it was weird when that popped up when I typed Int -> Double on hoogle
00:10:08 <Xandaros> It does that
00:14:10 <Yan> Hi, I'm new to Haskell. I hope it's okay if I post my question here.
00:14:18 <Yan> I'm trying to understand: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html
00:14:24 <Yan> How would I go about to make "Vec" an instance of "Show"? My problem is that the following naive approach doesn't work:
00:14:31 <Yan> data Vec :: Nat -> * where { Nil  :: Vec Ze; Cons :: Int -> Vec n -> Vec (Su n) }
00:14:37 <Yan> instance Show (Vec Ze) where show = "[]"
00:14:43 <Yan> instance Show (Vec (Su n)) where show (Cons a as) = show a ++ ":" ++ show as
00:16:01 <Xandaros> Yan: Yes!
00:16:03 <Hijiri> quantumtremor: To answer your earlier question, he meant to make a new type using the "newtype" keyword, something like newtype IntValMap k = MkIntValMap (Map k Int)
00:17:12 <cocreature> Yan: 1. you’re missing an argument in the first instance
00:17:29 <cocreature> 2. you need Show (Vec n) => Show (Vec (Su n)) in the second instance
00:17:34 <cocreature> otherwise you can’t call show as
00:17:39 <cocreature> then it works for me
00:19:03 <quantumtremor> Hijiri: Oh, didn't know that existed. Thanks! But what is "MkIntValMap"? Is it like a value constructor?
00:19:44 <Hijiri> yeah, it would be in that case
00:19:49 <Yan> Fantastic, thank you. Now it works.
00:20:21 * hackagebot git-fmt 0.3.0.2 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.3.0.2 (hjwylde)
00:20:21 * hackagebot iban 0.1.1.1 - Validate and generate IBANs  https://hackage.haskell.org/package/iban-0.1.1.1 (ibotty)
00:20:30 <Hijiri> newtype is similar to data, except it can only have one constructor that has one argument, and the constructor is strict. Also at runtime, the representation is the same
00:21:04 <Hijiri> strict meaning if you try to match on the constructor of ( MkIntValMap undefined), you will error
00:21:28 <Hijiri> (or if instead of undefined it is some nonterminating computation, it nonterminates that way instead)
00:21:57 <Hijiri> well undefined is semantically non-termination anyway
00:22:38 <Freundlich> The other way around: Non-termination is semantically undefined.
00:31:31 <dhalgren> Hijiri: hmmm, I just tried this in ghci: newtype Numb = Numb Int ; let f (Numb _) = "a" ; f (Num undefined) and got an "a". I did match on the constructor, just ignored the value, right?
00:32:23 <dhalgren> last one is also Numb, sry
00:34:21 <pavonia> Yes
00:34:49 <dhalgren> admittedly, it doesn't care if I give it f undefined either, which is surprising
00:36:47 <dhalgren> otoh if it did anything else I'd be surprised too, for newtype is supposed to be isomorphic to the orig type, ie have the same bottom; whereas data sees a difference between its bottom and lifted, Constructor bottom..
00:36:51 <Hijiri> dhalgren: Not sure, maybe I was wrong
00:37:43 <dhalgren> I'll try it w data
00:37:54 <Hijiri> I'm pretty sure you're right about how data should act
00:38:34 <dhalgren> yeah, here there's a difference. f undefined says exeption, whereas f (Numb undefined) is fine as expected
00:38:45 <Hijiri> Maybe it was that if you use seq on NewTypeConstructor undefined, it will error
00:39:10 <dhalgren> there's some subtle difference between unlifted and strict apparently that I don't get
00:39:12 <Hijiri> @let newtype IntThing = IT Int
00:39:14 <lambdabot>  Defined.
00:39:22 <Hijiri> > seq (IT undefined) ()
00:39:23 <lambdabot>  *Exception: Prelude.undefined
00:39:39 <Chobbes> Is JuicyPixels really slow with large images? I read in an 8 million pixel JPEG, and spit out a 8 million pixel PNG copy and it takes like... 6 seconds?
00:40:01 <Hijiri> oh right, I guess matching on newtype constructor is supposed to be literally a no-op
00:40:13 <Hijiri> so it wouldn't make sense for it to be evaluating constructors or anything
00:40:47 <Hijiri> so I was wrong about that, sorry quantumtremor 
00:41:35 <quantumtremor> I didn't really understand anything after your first message, it's ok :)
00:45:57 <dhalgren> Hijiri: also I believe it doesn't make sense to call its strict then, if you need seq to demonstrate the behavior; that's gonna force the evaluation anyhow, and if something else happens w/o it, clearly it wasn't so forced, no?
00:46:19 <Hijiri> the constructor is still strict
00:46:31 <Hijiri> MkNewType _|_ = _|_
00:47:00 <Hijiri> it's just matching on the constructor doesn't evaluate it
00:48:58 <dhalgren> guess that makes sense. I just heard a different term used for this Constructor _|_ = _|_ property; unlifted. and unsure if that's the same thing, still
00:49:25 <Hijiri> it's unlifted
00:50:55 <Hijiri> there are (at least?) two ways to make a constructor for an unlifted type
00:51:10 <Hijiri> One way is so when you match the constructor, it also evaluates the inner argument
00:51:12 <Freundlich> dhalgren: Strict is a property of mathematical functions. In order to call a function implemented in haskell strict, you have to translate the implementation to a function first (which we call denotational semantics).
00:51:28 <Freundlich> Hope that clears up the confusion a bit.
00:51:31 <Hijiri> so then you can't tell the difference between Constructor _|_ and _|_, because matching on either gives _|_
00:51:52 <Hijiri> The other way is make it so that when you match on the constructor, it's a lazy match and doesn't really do evaluation
00:52:46 <Hijiri> making it a no-op and giving the same runtime representation basically acheives this lazy match
00:53:35 <dhalgren> y, thx; does clear things up a bit
00:56:07 <lamefun> https://hackage.haskell.org/package/unix-2.7.1.0/docs/System-Posix-IO.html#v:fdReadBuf -- how to use this?
00:58:28 <tabemann> I have a stupid question
00:58:42 <tabemann> does a Haskell program exit when its initial thread exits?
00:59:00 <tabemann> or if there are outstanding threads at the point that exits, does it wait until every last thread exits?
01:07:14 <lamefun> Wow, what's that?
01:08:33 <Hijiri> tabemann: the whole program will exit if the main thread dies
01:12:15 <lamefun> How to use ByteStrings with C-derived APIs?
01:12:45 <lamefun> https://hackage.haskell.org/package/unix-2.7.1.0/docs/System-Posix-IO.html#v:fdReadBuf - uses (Ptr Word8)
01:12:52 <lamefun> there's nothing Ptr Word8 in ByteString
01:17:03 <peddie> lamefun: https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html#g:22 is close?  but also you could convert the fd to a Handle and use the built-in ByteString I/O functions . . . 
01:18:01 <peddie> lamefun: a CString is a Ptr CChar, and a CChar is a newtype wrapper around Int8
01:18:11 <lamefun> peddie, https://hackage.haskell.org/package/bytestring-0.9.1.4/docs/Data-ByteString-Internal.html#v%3AcreateAndTrim - ideally I'd want this
01:18:17 <lamefun> Is it still there?
01:18:55 <peddie> I've got no idea, I think so
01:18:57 <lamefun> I looked, that function is still there
01:19:10 <lamefun> but Data.ByteString.Internal is undocumented now.
01:19:40 <peddie> to be fair, it's internal . . . 
01:20:08 <lamefun> That one function is perfect for the purpose of using fdReadBuf
01:21:17 <peddie> I think under the hood a ByteString is just a ForeignPtr Word8 along with some metadata, maybe Internal has something more direct
01:21:24 <peddie> not sure what to tell you, sorry
01:21:43 <lamefun> Oh, and indeed that's how ByteString's public hGetSome works...
01:22:09 <peddie> can you convert the fd to a Handle and just use all the public functions?
01:22:53 <peddie> maybe they're too limiting
01:23:51 <lamefun> I couldn't find any alternative.
01:24:34 <lamefun> I mean, that function's perfect for that: allocate buffer, of given size, then fill it with IO, trim it and return - exactly what's needed to process output of fdReadBuf
01:25:02 <peddie> heh
01:25:10 <peddie> well, use it and cross your fingers?
01:25:22 <lamefun> And it's what ByteString uses itself for that one purpose.
01:25:45 <peddie> it seems like there'll likely be some similar function under the hood, even if createAndTrim changes a bit in the future
01:25:58 <peddie> so maybe using the internal one isn't so bad?
01:25:59 <lamefun> No, I looked it up.
01:26:27 <lamefun> it's literally using hReadBuf and createAndTrim in BS.hGetSome
01:26:33 <peddie> right
01:26:50 <peddie> sorry, I've got to run!  good luck!
01:39:16 <jeltsch> > undefined
01:39:26 <lambdabot>  *Exception: Prelude.undefined
01:49:37 <lamefun> Is there a public-API alternative to https://hackage.haskell.org/package/bytestring-0.9.1.4/docs/Data-ByteString-Internal.html#v%3AcreateAndTrim  ?
02:01:51 <bollu> how do I get the parse tree of a haskell program?
02:02:03 <bollu> is there a compiler flag?
02:03:13 <gfixler1> bollu: maybe this? https://hackage.haskell.org/package/haskell-src-1.0.2.0/candidate/docs/Language-Haskell-Parser.html
02:03:40 <bollu> oh, hm, interesting
02:03:41 <bollu> thanks
02:03:44 <cocreature> there is also -ddump-parsed iirc
02:04:36 <cocreature> or the ghc api
02:05:10 <bollu> cocreature: where does it put the parse tree with -ddump-parsed?
02:05:40 <cocreature> probably just to stdout
02:07:09 <gargawel_> bollu: -ddump-parsed does not really do what you want, I guess
02:07:09 <gargawel_> it just pretty-prints the AST
02:07:09 <gargawel_> so basically, you have to re-parse it
02:07:44 <bollu> gargawel_: oh :/
02:07:53 <bollu> gargawel_: https://ghc.haskell.org/trac/ghc/ticket/11024 I've taken that Trac ticket
02:08:00 <bollu> and I want to know how to inspect the AST
02:08:57 <gargawel_> I'd use the GHC API
02:11:25 <gargawel_> bollu: I guess that module could be your entry point: http://downloads.haskell.org/~ghc/7.10-latest/docs/html/libraries/ghc-7.10.2/HsSyn.html
02:11:52 <bollu> gargawel_: thanks :) I'll take a look at it
02:11:56 <merijn> bollu: FYI #ghc is pretty helpful when it comes to hacking ghc (although low traffic, so expect to wait an hour plus before you get a reply)
02:12:07 <merijn> bollu: Same goes for the ghc-devs mailing list
02:12:37 <bollu> I am on #ghc, and I asked the same question there :)
02:30:52 <gargawel_> I'm getting some strange "overlapping instances" message from GHC while playing with type literals: https://gist.github.com/gaeldeest/448684aaf98d6c50d44b
02:31:25 <gargawel_> It looks like GHC pretends being able to derive ToNatty 0, which is clearly impossible
02:31:45 <gargawel_> (unless my coffee cup was significantly undersized)
02:32:00 <gargawel_> Or does the message just mean that it *can't* rule it out ?
02:32:18 <merijn> gargawel_: It means it's incapable of proving that "n" can't be zero
02:32:50 <merijn> gargawel_: Note that overlap checks never take the context in account
02:32:50 <gargawel_> merijn: OK. I guess I just have to add a constraint, then.
02:33:02 <gargawel_> merijn: Oh ?
02:33:40 <merijn> gargawel_: i.e. "instance (ToNatty (n-1)) => ToNatty n where" <- the "(ToNatty (n-1)) =>" part is irrelevant for whether the instance overlaps or not
02:34:14 <gargawel_> That's what I feared your comment implied.
02:35:51 <gargawel_> merijn: is there a way out besides {-# OVERLAPPABLE #-} (or -XOverlappingInstances) ?
02:35:55 <lb5tr> omg
02:37:44 <Xandaros> TypeClassInstanceFamilies, anyone? ;)
02:37:45 <lamefun> What's with leaving and re-joining?
02:38:08 <Xandaros> lamefun: It's called a netsplit
02:40:15 <merijn> gargawel_: Nope
02:42:15 <gargawel_> Xandaros: I'm buying ! ;)
02:45:00 <gargawel_> Why doesn't GHC use the instance declaration context to disprove overlapping ? I'm guessing there are decidability issues, but it could still try to be smart about it.
02:46:14 <joco42> how do i use the mean in this library ? how can i take the mean of [1,2,3] ? https://hackage.haskell.org/package/statistics-0.13.2.1/docs/Statistics-Sample.html
02:46:28 <joco42> using this?
02:49:00 <gargawel_> joco42: transform [1,2,3] into a [Double] ; create an empty vector (empty :: Vector v a => v a
02:49:01 <joco> what does this mean ? mean :: Vector v Double => v Double -> Double
02:49:04 <gargawel_> )
02:49:08 <gargawel_> and then expand it using cons
02:49:24 <joco> gargawel_:  thanks!
02:50:07 <gargawel_> joco: Vector is a typeclass
02:50:15 <joco> what does this Vector v Double mean ?
02:50:15 <joco> what is the kind of v ?
02:50:15 <joco> *->*
02:50:24 <joco> ?
02:50:27 <Shockk> joco: that means it takes a v Double, where v is any type that has a type argument and where it's an instance of the Vector typeclass
02:50:35 <Shockk> joco: yep
02:50:53 <joco> ahh
02:51:20 * hackagebot delimiter-separated 0.1.0.0 - Library for dealing with tab and/or comma (or other) separated files  https://hackage.haskell.org/package/delimiter-separated-0.1.0.0 (AtzeDijkstra)
02:51:20 <gargawel_> joco: you can use :k in GHCi to get the kind of a type :)
02:51:24 <joco> so it can be rewritten as (Vector v) Double ?
02:52:24 <Shockk> Vector v Double means the Vector typeclass has two parameters, so that's correct
02:52:42 <Profpatsch> joco Not THE joco, are you?
02:53:03 <joco> ahh
02:53:04 <joco> ok
02:53:04 <joco> Profpatsch: ?
02:53:14 <Profpatsch> The musician. :)
02:53:19 <joco> no
02:53:33 <joco> my mother calls joco
02:53:33 <joco> calls me
02:58:51 <joco> the examples in this tutorial are a little bit buggy : https://wiki.haskell.org/Numeric_Haskell:_A_Vector_Tutorial
03:05:33 <joco> but yeah, now I can get a mean in haskell, many thanks guys!
03:05:50 <joco> one more step away from numpy :)
03:08:32 <m4lvin> What's the currently recommended way to bundle C and C++ libraries with a Haskell library? Is something like this http://stackoverflow.com/a/18580540 still the right way (TM)?
03:08:47 <m4lvin> (I use stack to build my project.)
03:41:04 <ChristianS> i want to write a small web app -- html frontend with just some bits of javascript, data stored in mysql/postgres. what's a good web framework for that purpose?
03:44:48 <liste> ChristianS any one of them (:
03:45:10 <liste> happstack, yesod, spock for example
03:47:48 <ChristianS> liste: hm, that doesn't make the choice easier...
03:50:26 <liste> ChristianS they have some different design decisions but all do pretty much the same thing
03:52:00 * hackagebot eventstore 0.9.1.1 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.9.1.1 (YorickLaupa)
03:52:01 <liste> yesod is heavy on template haskell, spock achieves better type safety with type families, etc..
03:52:30 <liste> (better type safety in general, not better than yesod)
03:55:34 <ChristianS> ok
03:55:48 <ChristianS> you didn't mention snap, i thought that one's popular as well?
03:57:40 <liste> yes, and servant's popular too (though maybe only for web services? idk)
03:57:44 <liste> and scotty
03:58:00 <Xandaros> snap and yesod are pretty good, but they are more geared towards big web 2.0 sites
03:59:07 <ChristianS> Xandaros: so for a small one you'd use ...?
03:59:44 <liste> ChristianS I'd start with scotty
04:00:22 <liste> it has the least advanced stuff in my knowledge
04:00:32 <Xandaros> hakyll, happstack, scotty ... one of those
04:00:58 <ChristianS> liste, Xandaros: ok, thanks
04:01:20 <merijn> Hakyll is only for static sites, though
04:01:24 <Xandaros> hakyll is very minimalistic iirc. If you are after a static site, go for that
04:02:16 <joco> is there a function to map on (a,a) ?
04:02:39 <Xandaros> joco: fmap? bimap?
04:02:52 <joco> say maptuple2:: a->b->(a,a)->(b,b) /
04:02:55 <joco> bimap?
04:03:01 <joco> lemme check Xandaros
04:03:30 <Xandaros> hmm, bimap for (,) is more like bimap :: (a -> c) -> (b -> d) -> (a,b) -> (c,d)
04:04:06 <joco> yeah...
04:04:08 <phadej> joco: over both
04:04:22 <joco> over both ? ok i have a look thanks
04:04:34 <phadej> from `lens`
04:04:35 <merijn> Only works if he's using lens
04:04:48 <merijn> There's also
04:04:53 <merijn> :t join (&&&)
04:05:03 <joco> nice
04:05:05 <joco> over both length ("hello","world")
04:05:06 <merijn> @botsnack
04:05:10 <merijn> awww
04:05:17 <joco> \over both length ("hello","world")
04:05:25 <joco> how do eval this here ?
04:05:28 <joco> i forgot
04:05:31 <Xandaros> > "Hi!"
04:05:37 <dutchie> unfortunately the bot has been netsplit away
04:05:45 <dutchie> freenode is having some issues
04:05:56 <joco> >over both length ("hello","world")
04:05:57 <joco> ahh
04:05:58 <joco> ok
04:06:11 <Xandaros> I guess that's the downside of filtering away all the joins/leaves
04:06:24 <joco> thanks phadej over both is exactly that i need now
04:07:25 <Xandaros> I wonder why there is nothing like that in Data.Bifunctor. I have needed such a function myself before and ended up using bimap f f
04:07:41 <merijn> Xandaros: "join bimap" :p
04:08:16 <Xandaros> Ho!
04:08:44 <Xandaros> What is this magic?
04:08:49 <dutchie> join in the reader monad
04:08:51 <dutchie> v useful
04:08:53 <joco> oh no
04:09:08 <joco> oh yeah
04:09:09 <joco> :)
04:12:06 <vandenoever> is there a way in cabal to automatically recompile on file changes for faster feedback?
04:15:39 <joco> vandenoever: ghcid ?
04:16:04 <joco> stack install ghcid 
04:16:31 <joco> i think
04:24:38 <nani___> does anyone know the haskell wikibook? Is it good? I am reading it, seems cool
04:28:16 <Digit> i've seen increasing recomendations of the haskell wikibook.
04:34:08 <merijn> nani___: Which one? There's some good wikibook sections (like the one on indentation, do-notation and GADTs), but the quality varies a lot, I think
04:46:58 <Xnuk>  
05:03:56 <Xeironis_> When I type "return 4" or "pure 4" in ghci, it just prints "4". Which monad does it pick for that?
05:04:52 <merijn> Xeironis_: Looks like string?
05:04:56 <merijn> > 4
05:04:58 <lambdabot>  4
05:05:00 <merijn> > pure 4
05:05:02 <lambdabot>      No instance for (Show (f0 a0))
05:05:02 <lambdabot>        arising from a use of ‘show_M368815025255358168110507’
05:05:02 <lambdabot>      The type variables ‘f0’, ‘a0’ are ambiguous
05:05:05 <merijn> hmmm
05:05:05 <Xeironis_> merijn: It doesn't print the "s
05:05:14 <merijn> oh
05:05:19 <merijn> in ghci probably IO
05:05:24 <Xeironis_> ok
05:07:42 <maerwald> is there a typesafe version of printf? And I don't mean format... the API is even more complex than just using "foo" ++ str ++ "bar"
05:07:54 <merijn> maerwald: Plenty
05:08:29 <maerwald> merijn: I seem unable to find the Plenty package on hackage
05:08:46 <bernalex> typesafe in what regard?
05:08:47 <merijn> maerwald: I meant that there are plenty of different printf packages :p
05:08:55 <bernalex> merijn: I think he might be taking the piss
05:09:06 <merijn> bernalex: Presumably format string matching arguments provided
05:09:09 <maerwald> bernalex: printf just throws exceptions during runtime if the argument list doesn't match and so on
05:09:13 <merijn> instead of printf's silly typeclass stuff
05:09:57 <bernalex> merijn: that was what I assumed
05:10:02 <maerwald> I don't even understand why they bothered designing it with typeclasses... it's already unsafe, so they could have just used the C binding, lol
05:10:47 <nrolland> what is the easiest way to prettyprint… some already formated text which is too wide ?
05:10:57 <maerwald> merijn: so what is Plenty?
05:11:07 <merijn> maerwald: A word in the english language?
05:11:13 <maerwald> fascinating
05:11:43 <maerwald> the only useful thing I found was
05:11:43 <maerwald> @hackage formatting
05:11:43 <lambdabot> http://hackage.haskell.org/package/formatting
05:11:57 <maerwald> but looking at the examples, I can just use string concatenation with ++
05:12:02 <maerwald> no improvement there
05:12:40 <merijn> Just hitting "search" for printf on https://hackage.haskell.org/packages/ turns up like 12 hits...
05:12:50 <Xeironis_> there's some video on youtube about how to make a typesafe printf in Idris, you could probably whip up something similar in Haskell with some dependent typing extensions :P I suppose a library would be more convenient though
05:13:14 <maerwald> merijn: I know how to use search engines, thanks... I was looking for explicit answers
05:18:58 <phaazon> hm, I just added a few combinators to my event package
05:19:03 <phaazon> now I have filterE and foldrE
05:19:13 <phaazon> filterE :: (a -> Bool) -> Event a -> Event a
05:19:27 <phaazon> foldrE :: (b -> a -> b) -> b -> Event a -> Event b
05:20:10 <bollu> :info Foldable
05:27:12 <anks> hello, im streaming ~10MB file with Pipes.ByteString, but streaming stops after only a small part of a file?
05:27:16 <anks> why?
05:29:38 <rom1504> how does it stop ?
05:33:51 <anks> with no errors
05:34:19 <anks> i got a program that tries (for now) converting binary data to hexadecimal text representation
05:34:42 <anks> and output file is small and contains only first little part of a input file converted
05:41:34 <joco42> this looks pretty nice(
05:41:36 <joco42> https://github.com/nh2/call-haskell-from-anything
05:41:41 <joco42> anyone using it?
05:41:57 <joco42> any experiences?
05:49:47 <nrolland> joco42 nice…
05:50:52 <nrolland> it makes sense to work at type level
05:54:54 <joco42> nrolland: do u use it?
05:55:09 <nrolland> I don’t
06:07:03 <yogeshs`> how can i define lens for Text.Email.EmailAddress which does not export any data constructor. However, defines "emailAddress :: ByteString -> Maybe EmailAddress" and "toByteString :: EmailAddress -> ByteString"  ? Currently I have defined it as "address f e = emailAddress <$> f (toByteString e)" which gives me a generic lens.
06:16:46 <asdf1234> kcsj
06:17:16 <joco> nrolland:  so that is nice ?
06:17:36 <joco> haskell from anything?
06:17:45 <four4> Is there some haskell'y/ way / existing function for mapping over the inner functor directly (e.g. x = F (F a)). It doesn't feel very elegant to do fmap (fmap f) x, especially as the scenario seems to present itself quite often...
06:17:50 <joco> seems nice, but does it work with ghc 7.10.2?
06:19:29 <suppi> four4, lenses might answer your question :)
06:19:47 <hyPiRion> ffmap f x = fmap (fmap f) x is also alright
06:20:31 <suppi> obviously simpler ^
06:20:33 <yogeshs`> fmap . fmap as given here https://github.com/ekmett/lens/wiki/Derivation
06:20:46 <quchen> :t fmap
06:20:48 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:20:48 <quchen> :t fmap . fmap
06:20:50 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
06:20:52 <quchen> :t fmap . fmap . fmap
06:20:54 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
06:20:59 <quchen> fmaps compose really nicely :-)
06:21:18 <ARM7> is there any way to add ghc flags to my project.cabal file so it's used by all options (build, run, repl, install, what have you)?
06:21:51 <four4> ahha!
06:21:54 <four4> thank you folks! :)
06:22:16 <four4> i have to also look more into lenses
06:22:31 <Unhammer> can I set -L/usr/include -lsomelib in .ghci?
06:23:05 <yogeshs`> how can i define lens for Text.Email.EmailAddress which does not
06:23:05 <yogeshs`>            export any data constructor. However, defines "emailAddress ::
06:23:06 <yogeshs`>            ByteString -> Maybe EmailAddress" and "toByteString :: EmailAddress
06:23:06 <yogeshs`>            -> ByteString"  ? Currently I have defined it as "address f e =
06:23:08 <yogeshs`>            emailAddress <$> f (toByteString e)" which gives me a generic lens.
06:29:18 <joco> four4: x & mapped.mapped %~ f - i think
06:30:06 <joco> is the same as fmap (fmap f) x 
06:30:08 <joco> i think
06:30:27 <joco> the only difference is that it is longer... :)
06:31:12 <four4> ;) 
06:31:14 <four4> thanks
06:31:30 <joco> lenses are nice
06:32:00 <Baughn> "regression-test: executable not found"...
06:32:30 <Baughn> Stack doesn't seem to like my test suite. Anyone have an example of testing an executable that I can look at?
06:32:46 <four4> i think they probably will start to look very tempting when doing something more complex than my example? i have to admit, my knowledge of lenses is extremely limited. :)
06:38:34 <yogsototh> Hi, I'm struggling with the WAI definition. In Wai 2, an Application was simply Request -> IO Response, since Wai 3 it is Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
06:38:41 <joco> four4: x & mapped.mapped . _1 %~ f  - for example applies f to a in [[(  a,b )  ]]
06:38:49 <yogsototh> I'm trying to write a Cache middleware
06:39:05 <yogsototh> But I don't know how to retrieve the Response from an Application and a Request
06:39:08 <Ankhers> Baughn: I think it is generally an accepted practice to create a library with the vast majority of your logic in it. Then just have a "slim" executable that calls various library functions.
06:39:28 <Baughn> Ankhers: Actually, stack just doesn't support detailed-0.9 tests. Known bug. :/
06:39:56 <Ankhers> Baughn: Oh. I didn't know that. I still haven't used stack all that much.
06:40:09 <Baughn> Ankhers: And if this was more than two hundred lines of code, I'd do that. Well, I'm effectively doing that anyway; all the IO code fits in main, five lines.
06:40:47 <four4> joco, oh, cool :)
06:42:18 <joco42> lenses are worth learning, they pay of quickly.... so it seems
06:42:50 <joco42> and #haskell-lens is super helpful
06:42:53 <hodapp> did I step into #photogra- oh
06:51:33 <eacameron> Is there anything special I need to do in order to have stack download/boot the most recent version of GHCJS from github?
06:56:13 <shersh> Hello everyone! I just reading about Eval monad and Parallel strategies. Could anyone explain me what is the purpose of `dot` function, which combines two strategies? In which form `rpar` evaluate its argument (NF, WHNF)? And what is the difference between `rpar`, `rparWith r0`, `rparWith rseq` and `rparWith rdeepseq`?
07:00:46 <Unhammer> to answer my own question, 7.10 is needed to set -l in .ghci https://www.fpcomplete.com/user/icelandj/dynamically-link-against-library-in-ghci
07:22:53 <phaazon> hm, my FRP framework is getting somewhere!
07:22:55 <phaazon> http://lpaste.net/5811487396012752896
07:39:20 <t4nk928> '
07:48:56 <bitonic> Can I prove `foo :: forall (a :: *) (n :: Nat) (m :: Nat). (Typeable n, Typeable m) => proxy n -> proxy m -> (Typeable (n + m) -> a) -> a`? In other words, if I have two typeable `Nat`s, can I add them and have a `Typeable` instance for the added one?
07:50:40 <Xeironis_> If I want to do an IO action for every element in an Ix range, is it advisable to generate the list of all the elements and mapM_ over the list or is there a simple, more efficient way?
07:54:24 <ij> I have an intuitive feeling of what functor instance of parsec's "Parser a" should do, but I can't get it to typecheck. http://sprunge.us/XSjG
07:54:59 <ij> Oh, never mind! read works on strings, not chars.
08:26:16 <haskell_question> Hi, I'm a Haskell beginner - I've looked around, but I'm not sure how to convert the result of the last function in the following example to IO () from IO Int:
08:26:19 <haskell_question> http://pastebin.com/fgRvRkim
08:27:23 <ARM7> you could just add a return ()
08:28:06 <zacts> is static typing the main feature that haskell offers over things like Clojure or Common Lisp?
08:28:36 <ARM7> and functional purity if you consider that a feature
08:28:52 <zacts> ah ok
08:28:56 <haskell_question> ARM7: Thanks
08:29:05 <ij> haskell_question, or compose it with Control.Monad's "void" — void . send ... :: IO ()
08:29:08 <ij> pfft
08:29:24 <ij> Can I shorten (parser `mplus` other) <|> other?
08:31:47 <zerokarmaleft> zacts: it would be inaccurate to think of Haskell as Clojure or Cl + types
08:33:43 <ARM7> I don't think he does, he's just asking about features
08:39:00 <bennofs> ij: shouldn't that be equal to parser <|> other ?
08:39:17 <ij> I'm starting to think mplus doesn't do what I expected.
08:40:23 <bennofs> I think that for things being both MonadPlus and Alternative, mplus = (<|>) should hold
08:40:23 <Ankhers> is zip-archive the suggested package to handle .zip files?
08:41:07 <ij> bennofs, How do I concat two parsers?
08:41:13 <bennofs> ij: (>>) ?
08:41:29 <bennofs> ij: what does concat mean? run in sequence?
08:41:37 <ij> Yeah and get output from both.
08:42:01 <bennofs> ij: how do you want to combine the output of both?
08:42:05 <ij> List.
08:42:17 <bennofs> ij: sequence [parser1, parser2] does that
08:42:17 <ij> hm
08:42:30 <ij> Then they must be the same output, which in this case is true.
08:43:05 <bennofs> ij: if you want them in a list, the they need to have the same output
08:43:11 <ij> Yes, yes.
08:44:56 <ij> bennofs, Is there a parser that expects the end?
08:45:09 <bennofs> ij: depends on your parser library
08:45:12 <ij> Parsec.
08:45:27 <bennofs> ij: eof
08:47:38 <ij> This is quite fun.
08:52:01 <ij> Except for the type errors.
08:56:46 <ij> Nice! yourFavoriteParser <* (void (char '\n') <|> eof)
08:58:49 <anks> How would I, using pipes, await for only n bytes at once of a bytestring ?
09:17:10 * hackagebot parseargs 0.2 - Command-line argument parsing library for Haskell programs  https://hackage.haskell.org/package/parseargs-0.2 (BartonMassey)
09:20:32 <ij> Looks like all haskellers are out clubbin' or something.
09:24:00 <geekosaur> US contingent likely to be mostly  absent...
09:24:19 <ij> Are they back in time?
09:24:25 <ij> I'm from GMT+2.
09:26:34 <Ankhers> It is a holiday in US land.
09:27:07 <Clint> not really
09:29:05 <Ankhers> Isn't today a state holiday for most states?
09:29:42 <geekosaur> it's the day after a holiday and many places give both days off
09:30:06 <geekosaur> (most people are pretty useless for work the day after overeating day :p )
09:44:44 <quicksilver> geekosaur: ij: I think the DDos is having as much effect as thanksgiving
09:45:16 <ij> Having intelligent join/part filter really helps not noticing that.
09:45:26 <bollu> quicksilver: someone is DDOSing freenode?
09:47:11 <Cale> bollu: looks like it
09:48:16 <geekosaur> there was a global notice about it
09:49:43 <quicksilver> I keep having packets dropped; I assume that people are busy firewalling certain IP blocks and things.
09:51:06 <geekosaur> also https://twitter.com/freenodestaff/status/670162459328684032
09:54:06 <Ankhers> I was wondering why I kept getting disconnected.
09:55:30 <glguy> This is how my client deals with join/part activity http://imgur.com/a0ZNb4H
09:56:09 <Ankhers> glguy: I like that. Maybe I should hack ERC to do something similar.
09:56:16 <Ankhers> Or maybe someone else already has...
10:01:03 <Arguggi> .q
10:03:04 <dalastboss> So I've been messing around and trying to get an intuition for some of the common type classes
10:03:40 <dalastboss> I've realized you can recover functor from monad by doing let fmap f m = m >>= (return . f)
10:04:10 <dalastboss> Should that be intuitive?
10:05:18 <geekosaur> @src liftM
10:05:18 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:05:40 <bollu> dalastboss: O
10:05:40 <bollu> dalastboss: I'd say yes
10:05:42 <Hafydd> dalastboss: yes, I think it should be, if the person has learned in a correct way.
10:05:44 <geekosaur> (same thing in do notation)
10:06:08 <bollu> dalastboss: you're simply extracting the monad from the monadic context with the (>>=), applying the function in the non-monadic context since the function is (a -> b), and then "lifting" it back up into the monad world with return
10:07:01 <dalastboss> So (>>=) should be thought of as "pull thing out of monadic context and apply the function"
10:07:06 <dalastboss> or, can be thought of
10:08:12 <lamefun> Is reddit silently censoring posts?
10:09:13 <lamefun> What's wrong with this? https://www.reddit.com/r/haskell/comments/3ug73m/bytestring_and_readbuf/
10:09:22 <cmotoche> Do you know how to run a cabal application using stack?
10:09:53 <dcoutts> cabal run  :-)
10:19:21 <orion> What's the best way to perform path MTU discovery in Haskell?
10:19:59 <lamefun> Are there secret reddit bans or something?
10:23:16 <ackthet> its called shadowban, but not really relevent for this channel 
10:24:40 <geekosaur> ackthet, that was in reference to [27 18:08] <lamefun> What's wrong with this? https://www.reddit.com/r/haskell/comments/3ug73m/bytestring_and_readbuf/
10:25:47 <MarcelineVQ> Shadowbans aren't [removed], they just don't show up to normal browers and can only be seen by direct links
10:27:12 * hackagebot parseargs 0.2.0.1 - Command-line argument parsing library for Haskell programs  https://hackage.haskell.org/package/parseargs-0.2.0.1 (BartonMassey)
10:27:13 <lamefun> That post is [removed]?
10:27:50 <geekosaur> it is here
10:28:01 <MarcelineVQ> It is for me. That's reddit these days :X
10:28:31 <lamefun> I see it as normal.
10:34:01 <dxvxb> stack setup fails with error no 2
10:34:26 <dxvxb> it says no free space while extracting the files in tmp folder..
10:35:03 <Hijiri> if /tmp lives in RAM, you could be maxing it
10:35:04 <dxvxb> while i have around 50% available space...
10:35:53 <dxvxb> so how do i know that?
10:36:20 <S11001001> dxvxb: what does df -h say about the /tmp fs?
10:37:29 <dxvxb> S11001001: -->  tmpfs           738M   80K  738M   1% /tmp
10:38:03 <lamefun> I think it could've been spam filter (it had links in it and phrases like "perfect function", in reference to a Haskell function).
10:40:54 <dxvxb> anybody? what should i do...
10:45:26 <ackthet> geekosaur: ahh missed that
10:47:31 <lamefun> https://www.reddit.com/r/haskell/comments/3uhs1n/is_it_ok_to_use_bytestringinternal_specifically/ - does this work for anybody?
10:47:39 * hackagebot userid 0.1.2.1 - A library which provides the UserId type and useful instances for web development  https://hackage.haskell.org/package/userid-0.1.2.1 (JeremyShaw)
10:47:59 <MarcelineVQ> lamefun: no, how odd
10:48:08 <lamefun> ...
10:48:16 <lamefun> do reddit posts have to be approved by moderators?
10:51:28 <lamefun> Wow.
10:51:54 <lamefun> So k3wl... I knew I shouldn't have deleted my previous post about readability...
10:52:53 <lamefun> This is totally stupid... hidden "punishments", no explanation, no anything.
11:02:40 * hackagebot parseargs 0.2.0.2 - Command-line argument parsing library for Haskell programs  https://hackage.haskell.org/package/parseargs-0.2.0.2 (BartonMassey)
11:07:58 <lamefun> Is /r/haskell pre-moderated?
11:08:16 <lamefun> Because the very same post I posted in preview subreddit is fine: https://www.reddit.com/r/PostPreview/comments/3uhur8/is_it_ok_to_use_bytestringinternal_specifically/
11:12:55 <dxvxb> exit
11:15:33 <luntain> what is this operator: #. Found in lens src code. view :: MonadReader s m => Getting a s a -> m a
11:15:33 <luntain> view l = Reader.asks (getConst #. l Const)
11:17:56 <Xeironis_> huh, I just had some redundant brackets and HLint didn't tell me...
11:18:20 <Taneb> luntain: it's a version of (.) that can pretend the left argument is unsafeCoerce and optimize accordingly
11:18:53 <geekosaur> http://hackage.haskell.org/package/profunctors/docs/Data-Profunctor-Unsafe.html#v:-35-. is my guess per hayoo
11:19:24 <Taneb> luntain: geekosaur has it
11:47:43 <dldl> http://lpaste.net/146065
11:48:05 <dldl> I am, for fun, defining combs/perms using what I have learned so far in Haskell
11:48:42 <dldl> Last time I was on IRC, I learned the susinct way to make permutations (sequence (replicate (length xs), xs)
11:48:50 <dldl> but is there a similar short form for Combinations?
11:50:19 <dldl> http://lpaste.net/146065 (my code for reference)
11:50:31 <mauke> what's a combination?
11:53:32 <bb010g> Is there a guide anywhere on how to write readPrec functions?
11:58:34 <eacameron> Where are GHCJS releases hosted?
12:04:16 <muzzle> hi, do functions in the ST monad have tail call optimization?
12:07:35 <muzzle> hi, do functions in the ST monad have tail call optimization?
12:12:42 * hackagebot aws-ec2 0.3.3 - AWS EC2/VPC, ELB and CloudWatch client library for Haskell  https://hackage.haskell.org/package/aws-ec2-0.3.3 (VladimirKirillov)
12:12:44 * hackagebot hashabler 1.2 - Principled, portable & extensible hashing of data and types, including an implementation of the FNV-1a and SipHash algorithms.  https://hackage.haskell.org/package/hashabler-1.2 (BrandonSimmons)
12:17:30 <hexagoxel> muzzle: you are aware that haskell in general does not have a call stack?
12:45:39 * gciubotaru slaps lambdabot around a bit with a large fishbot
12:45:46 <muzzle> hexagoxel no, can you link me a resource on that ?
12:48:47 <bollu> is anyone else lagging heavily?
12:50:22 <hexagoxel> muzzle: i know no particular good write-up on top of my head, but you can find stuff like: http://stackoverflow.com/questions/13042353/does-haskell-have-tail-recursive-optimization
12:52:02 <hexagoxel> muzzle: or see the resources at https://github.com/bitemyapp/learnhaskell/blob/master/specific_topics.md#laziness-strictness-guarded-recursion
12:52:27 <muzzle> hexagoxel thanks
13:10:10 <muzzle> hi can anyone give me advice on getting this http://lpaste.net/146085 to work? (ST monad related)
13:12:25 <cite-reader> muzzle: Can you be more specific? What are you trying to do, and what doesn't work?
13:12:42 <glguy> muzzle: You "runST" at the very outside of your algorithm
13:12:49 <glguy> The 's' parameter doesn't get to escape
13:13:33 <muzzle> this is the error message btw http://lpaste.net/146086
13:13:33 <glguy> Do you aren't going to be able to write 'runDPLL'
13:14:39 <muzzle> i'm writing a DPLL Algorithm implementation for solving SAT formulas
13:14:50 <muzzle> and the Formula datatype holds STRef s
13:15:05 <muzzle> and the pick function that i use as a parameter should choose literals
13:15:22 <muzzle> but since there are many ways to do that i want to parameterize it
13:15:31 <muzzle> is that impossible to do with ST?
13:15:35 <glguy> muzzle: That's fine you just need to so all of the ST stuff inside the runST
13:16:48 <muzzle> glguy but isn't it in my case?
13:17:19 <glguy> It's not. In your case you're passing in 'pick' and 'f' from "outside"
13:17:46 <glguy> because they're arguments the caller of "runDPLL" gets to pick what type 's' is in that case
13:18:02 <glguy> but runST expects to be able to pick which type 's' was
13:18:04 <glguy> so there's a conflict
13:19:21 <muzzle> So basically I can't have anythin with 's' anywhere in the typesignature of a function except in the result?
13:19:55 <glguy> You can have values that work parametrically in any 's'
13:20:06 <glguy> and then use those to build up your DPLL implementation
13:20:20 <glguy> and then runST would go on the outside
13:20:21 <glguy> to get the final result
13:22:06 <muzzle> So I can't e.g. pass an STRef to a function that returns a value in the STMonad?
13:22:25 <glguy> that's fine, the problem is that you used runST too soon
13:24:04 <glguy> muzzle: Here's an example of using ST I did a while ago http://lpaste.net/119204
13:25:11 <glguy> You can see that the function that uses runST doesn't expose any ST stuff
13:25:30 <glguy> but that you can define functions :: STThing s -> ST s Result
13:25:56 <muzzle> oh, so i have to pack the creation of the formula object into the part that is called by runST ?
13:26:08 <glguy> yeah
13:26:43 <glguy> You might want to have two types:   'ImmutableFormula' and 'MutableFormula s'
13:26:45 <muzzle> and the pick function, i would just declare that in my source code, is that fine?
13:26:48 <glguy> If that's appropriate for what you're doing
13:26:56 <muzzle> yeah, it is
13:27:03 <glguy> Yeah, the problem is that it's a parameter
13:27:08 <muzzle> i just parse them from a [[Int]]
13:27:19 <glguy> There's actually a way to take that function as a parameter using Rank-2 types
13:27:32 <glguy> but you should understand how to use ST first ignoring that
13:27:39 <glguy> before you'll be ready to decide when to use it
13:28:15 <muzzle> hmm i just need it in this case because i need mutable state and I don't want to do it in IO (since it is a deterministic computation)
13:28:38 <muzzle> this has been really helpful, thanks :)
13:42:45 * hackagebot uom-plugin 0.1.1.0 - Units of measure as a GHC typechecker plugin  https://hackage.haskell.org/package/uom-plugin-0.1.1.0 (AdamGundry)
13:42:47 * hackagebot hashabler 1.2.1 - Principled, portable & extensible hashing of data and types, including an implementation of the FNV-1a and SipHash algorithms.  https://hackage.haskell.org/package/hashabler-1.2.1 (BrandonSimmons)
13:57:38 <danilo2> Hello guys! I've got a funny small question to you - is there any reason why int comparison would not work as fastt as constructor pattern matching? I'm asking because I want to choose one of these solutions in a very performance important code and the int based solution is more suitable for the problem here. Of course I'll make tests, but maybe there are some suprising cases derived from GHC nature that are worth notying? :)
14:06:17 <liste> danilo2 you mean f x | x == 0 -> ... | x == 1 -> ... versus f Term1 = ...; f Term2 = ... ?
14:18:06 <danilo2> liste: yes
14:19:25 <liste> danilo2 just make sure you make the function monomorphic
14:19:31 <henceforthingly> \leave
14:20:17 <danilo2> lsite: you mean of course monomorphic on Int, not on output?
14:21:02 <danilo2> liste: is this in fact how GHC works under the hood? (I suppose it has to bee something like that)
14:21:58 <danilo2> Ah and one more thing - unsafeCoerce is 0-time cost? It is only ocmpiler hint, am I right? 
14:22:15 <liste> danilo2 Int yes
14:24:03 <liste> danilo2 ghc could maybe optimize sum-of-units matching to jump table, no idea
14:24:36 <danilo2> liste: ok, thank you :)
14:53:51 <liste> danilo2 yw (:
14:55:40 <SrPx> Hello, there is someone who argued, I don't remember who (paul graham?) that by choosing Haskell for a company, you lose indeed the ability to hire easily, but you also attract the best programmers.
14:55:57 <SrPx> Could someone link me to this text? 
14:58:49 <dmj> SrPx: beating the averages
14:58:59 <dmj> http://www.paulgraham.com/avg.html
14:59:45 <Cale> Paul Graham has been beating the averages for the number of words required to convey an idea for quite some time ;)
15:02:04 <dmj> Cale: hah =)
15:04:14 <bu5hm4n> hi, I am just learning haskell, and I saw the definition intInts :: Monoid m => (Integer -> m) -> m, I understand almost every part, but not "=>" 
15:04:18 <bu5hm4n> what does it define ? 
15:04:41 <Cale> => is punctuation which separates a type class constraint from the rest of a type
15:05:31 <Cale> In this case, intInts, for any type m which is an instance of the type class Monoid, is a function which will accept a function of type (Integer -> m), and produce a result of type m
15:05:54 <Cale> class Monoid m where
15:05:58 <Cale>   mempty :: m
15:06:03 <Cale>   mappend :: m -> m -> m
15:06:41 <Cale> is a type class for types which have some canonical (and associative) way of combining or appending elements of that type, along with an identity for that combining operation
15:08:19 <bu5hm4n> Cale: cool thx :) 
15:08:37 <bu5hm4n> so it just says "what kind of" m is, correct ? 
15:08:55 <bu5hm4n> sorry for not having the correct terms, I am very new to haskell
15:09:01 <Cale> yeah, it restricts the set of types that m is allowed to be chosen from
15:09:16 <Cale> to just those which implement certain functionality
15:09:41 <Cale> Without the constraint, you would be allowed to choose any type whatsoever
15:09:59 <bu5hm4n> ah like in rust if a type implements a special trait, I think I got it :), thx! 
15:10:32 <Cale> bu5hm4n: As another example, there are classes for equality and order comparison
15:10:40 <Cale> bu5hm4n: So like:
15:10:46 <Cale> class Eq a where
15:10:51 <Cale>   (==) :: a -> a -> Bool
15:11:00 <Cale> and
15:11:07 <Cale> class Eq a => Ord a where
15:11:13 <Cale>   (<) :: a -> a -> Bool
15:11:19 <Cale>   ... other comparisons ...
15:11:42 <Cale> so when we write a sorting function which makes use of the order comparisons
15:12:08 <Cale> We don't get a function of type  [a] -> [a], because we need to know that a is a type for which e.g. (<=) has been defined
15:12:20 <Cale> So instead, we have  sort :: (Ord a) => [a] -> [a]
15:13:16 <Cale> Note that the type of the input list and the type of the output list are also required to be the same here (and not just any two types which implement Ord)
15:13:59 <Cale> and also note that just by *using* type class polymorphic things, like the order comparison operations, or sort itself, we can define more type class polymorphic things
15:14:00 <bu5hm4n> yeah, ok :) awesome! very helpfull channel :)
15:14:14 <Cale> e.g. if I write
15:14:22 <Cale> reverseSort xs = reverse (sort xs)
15:14:35 <Cale> this will get the type  (Ord a) => [a] -> [a]  as well
15:14:56 <Cale> this distinguishes type class polymorphism from ad-hoc polymorphism, where you'd be forced to pick an implementation type
15:15:52 <bu5hm4n> ok, cool :) 
15:23:05 * hackagebot swagger2 0.4 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-0.4 (NickolayKudasov)
15:36:32 <bb010g> Can you send multipart/form-data with servant?
15:39:00 <alpounet> bb010g: yes, feel free to take a look at https://github.com/haskell-servant/servant/issues/133
15:39:10 <alpounet> contains some code for that
15:39:28 <alpounet> cannot make it a "simple" content type because decoding this requires IO
15:55:20 <Shersh> Hello everyone! I have existentially quantified data constructor like in HaskellWiki well known example: `data ShowBox = forall a . Show a => SB a`. I wonder if there is a way to automatically derive instances of any type classes and constraints for single constructor existentially quantified data type?
15:56:26 <liste> Shersh you mean data ShowBox = Show a => SB a; deriving instance Show ShowBox ?
15:56:34 <liste> (plus the forall
15:58:33 <Shersh> liste: This will show `SB ()` as "SB ()", but all I want is to apply show to single argument for constructor. Because with such behaviour I can easily implement abstract classes or interfaces like in OOP world without duplicating code of type class for my single constructor.
16:01:03 <liste> Shersh I don't think that's the best way to implement abstract classes / interfaces
16:01:17 <Shersh> liste: and what is the best way?
16:01:34 <liste> I'd recommend records of functions
16:02:13 <liste> e.g. data Service a { start :: a -> IO (); stop :: IO () }
16:02:27 <liste> data Service a = Service { start :: a -> IO (); stop :: IO () } even
16:02:50 <liste> not always the best, but quite safe
16:03:12 <Shersh> liste: ok, I'll think about this way
16:13:39 <ReinH> @google haskell existential antipattern
16:13:40 <lambdabot> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
16:14:00 <ReinH> Shockk: your data type is pretty much the canonical example of this antipattern.
16:16:36 <Shockk> ReinH: hmm?
16:16:57 <liste> Shersh *
16:17:17 <Shockk> oh
16:17:39 <ReinH> woops
16:18:33 <lethjakman-l> Is there a way to tell ghc to "clean up after yourself, you made a mess and left a ton of files everywhere!"
16:18:39 <lethjakman-l> If so, I want it to be ghc --clean-your-room
16:21:21 <Profpatsch> I see that System.Process only works with strings.
16:21:49 <Profpatsch> Are there better packages for calling external programs and capturing their output?
16:21:59 <Profpatsch> That also work with text?
16:29:49 <pavolzetor> hi, I am trying to represent an image without using lists
16:29:55 <pavolzetor> what data type should I use?
16:30:03 <pavolzetor> (it is for ray tracer)
16:31:01 <liste> pavolzetor a bitmap image?
16:31:28 <liste> maybe some kind of Array or Vector
16:32:22 <pavolzetor> yes, I want to write to it randomly
16:33:14 <cite-reader> I'd probably go with an unboxed vector.
16:33:46 <pavolzetor> thanks, let me check
16:51:39 <maerwald> I've hacked on a project which uses the snap framework extensively. I feel like it exposes IO too much (e.g. for the web handlers) instead of trying to delay it for as long as possible. Can anyone say how other frameworks handle this problem?
16:52:21 <maerwald> I'm thinking of some diagrams-like approach where you build all your stuff IO-free and then pipe it into a "builder" function that does the actual IO.
16:54:16 <maerwald> because if you have IO all over the place, people are going to use it... and then you end up with functions that do all sorts of different things at once
17:06:49 <flyzen> if real autodidacts don't read, then how do they learn?
17:11:27 <peddie> maerwald: check out "free monads"
17:12:18 <Digit> sounds like a political campaign pop song
17:20:09 <rvxi> hello
17:22:01 <ReinH> maerwald: The problem is that you either need an escape valve to IO or you are limited to doing whatever operations are provided by the (free) construction.
17:22:25 <ReinH> And if you have an escape valve, then that pretty much defeats the purpose.
17:25:16 <thimoteus> god lambdabot is so useful
17:26:43 <epta> is there any logging libary with logging context support?
17:37:16 <Profpatsch> What is an easy way to read line-wise from an open handle?
17:42:23 <maerwald> ReinH: right, you depend much more on the completeness of the framework
17:43:07 <ReinH> @hoogle hGetLine
17:43:08 <lambdabot> System.IO hGetLine :: Handle -> IO String
17:43:09 <lambdabot> GHC.IO.Handle hGetLine :: Handle -> IO String
17:43:09 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
17:43:26 <Profpatsch> ReinH: Yes, but that will throw an exception on EOF.
17:43:55 <Profpatsch> I could check fo hIsEOF on each line.
17:44:00 <ReinH> @hoogle hIsEOF
17:44:01 <lambdabot> System.IO hIsEOF :: Handle -> IO Bool
17:44:01 <lambdabot> GHC.IO.Handle hIsEOF :: Handle -> IO Bool
17:44:11 <Profpatsch> Or I could catch the Error.
17:44:12 <ReinH> Yes.
17:44:14 <Profpatsch> What is recommended?
17:44:26 <ReinH> I would probably use pipes.
17:44:31 <Profpatsch> The interface seems clumsy.
17:44:37 <ReinH> Which interface?
17:44:41 <Profpatsch> System.IO.
17:44:52 * ReinH shrugs
17:45:01 <Profpatsch> I didn’t want to go overboard, because it’s a rather simple mockup application.
17:45:12 <ReinH> pipes is pretty easy to use
17:45:36 <Profpatsch> As is lens, once you know how it works. :P
17:47:54 <rvxi> could I get some feedback on these fold exercises? This is from Chris Allen's book: http://lpaste.net/146095
17:48:20 <Profpatsch> rvxi: You could ask bitemyapp :P
17:48:22 <rvxi> in particular, i'm not happy with the averaging-by-folding implementation
17:49:00 <rvxi> having to use a second fold in a where clause just to count up the numerical items in the database
17:49:43 <rvxi> bitemyapp: hi chris :-)
17:54:02 <rvxi> anybody have any feedback?
17:54:25 <Profpatsch> rvxi: I’m sorry, too tired right now. Need to go to bed.
17:58:31 <cite-reader> rvxi: I'd probably implement your sumDb and avgDb in terms of folds on the result of filterDbNumber.
18:00:39 <cite-reader> Then sumDb just becomes sum . filterDbNumber. Or if you don't want utility folds, foldl' (+) 0 . filterDbNumber
18:07:04 <cite-reader> I need to go get dinner.
18:08:56 <rvxi> cite-reader: thanks
18:10:40 <dmwit> Profpatsch: For one-offs, hGetContents + lines isn't terrible.
18:10:48 <dmwit> Though it doesn't scale well for production code.
18:12:46 <dmwit> Profpatsch: (http://stackoverflow.com/a/6669453/791604 covers the argument that first convinced me lazy IO was bad for long-term maintenance)
18:14:13 <dhalgren> anyone know if the "gadts meet their match" work is to land in time for 8.0?
18:15:11 <vilasopher> hi
18:15:19 <c_wraith> dhalgren: I believe it did
18:15:25 <seafood> I’m looking at a type signature. Enough new features have been added to GHC in recent years that I’m having trouble reading a type signature
18:15:28 <seafood> runTrace :: Eff '[Trace] w -> IO w
18:15:46 <seafood> So… what the hell does the apostrophe before the [Trace] mean?
18:15:49 <geekosaur> type level list
18:16:02 <dmwit> seafood: Read the docs for DataKinds.
18:16:04 <seafood> And where are they defined?
18:16:10 <seafood> dmwit: thanks.
18:17:22 <dmwit> vilasopher: hi!
18:17:46 <vilasopher> what's everyone up to?
18:17:53 <vilasopher> this is my first time here
18:17:58 <geekosaur> dhalgren, it's in the "In-flight, and likely to land in time" section of https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1#LandedinHEAD
18:18:14 * hackagebot binary-parser 0.5 - A highly-efficient but limited parser API specialised for bytestrings  https://hackage.haskell.org/package/binary-parser-0.5 (NikitaVolkov)
18:18:43 <dmwit> vilasopher: The usual, hangin' out preying on noobs' confusion.
18:18:48 <c_wraith> vilasopher: You just stop because the channel's here, or are you interested in haskell too?  (If you're not, we'll try to make you interested)
18:19:22 <rvxi> hi vilasopher
18:19:30 <vilasopher> I'm interested in haskell... I'm learning it using an online tutorial
18:20:23 <vilasopher> It's really cool so far. I'm used to programming in Java and the like
18:20:39 <rvxi> ok attempt 2 - let me know if you have any feedback for further improvement http://lpaste.net/146095
18:20:44 <dmwit> The first time I saw `data Maybe a = Nothing | Just a` gave me frisson.
18:22:27 <rvxi> I feel like haskell enables the expression of intent better than any other language I've tried.
18:22:43 <rvxi> vilasopher: what tutorials are you learning from. don't start with learn you a haskell...
18:22:45 <dmwit> rvxi: When implementing an averaging operation with folding, it is mandatory to suggest the "Beautiful Folding" blog post.
18:22:51 <dmwit> http://squing.blogspot.com/2008/11/beautiful-folding.html
18:23:03 <vilasopher> why not learn you a haskell? that's the one I'm using
18:23:14 <vilasopher> rvxi: ^
18:23:22 * hackagebot postgresql-binary 0.7.4 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.7.4 (NikitaVolkov)
18:23:24 * hackagebot parseargs 0.2.0.3 - Full-featured command-line argument parsing library.  https://hackage.haskell.org/package/parseargs-0.2.0.3 (BartonMassey)
18:23:44 <rvxi> vilasopher: everyone does that because it's so friendly looking.
18:23:59 <geekosaur> LYAH is good at teaching you how to read Haskell code, but you really need supplementation to learn how to *write* it
18:24:17 <vilasopher> geekosaur, what do you recommend?
18:24:28 <dmwit> ?where gentle
18:24:28 <lambdabot> http://www.haskell.org/tutorial/
18:24:36 <geekosaur> it has no exercises and is generally not too helpful when it comes to learning how to think / write Haskell
18:24:41 <geekosaur> @where learnhaskell
18:24:41 <lambdabot> https://github.com/bitemyapp/learnhaskell
18:24:53 <rvxi> vilasopher: the problem is it's so monkey-see-monkey-do that you follow along thinking you understand it. then the minute you try to start your own project you realize you don't know where to start.
18:25:03 <geekosaur> yes, that
18:25:21 <rvxi> vilospher:  i'm working through chris allen's book (= bitemyapp)
18:25:50 <rvxi> vilasopher: it's still rough around the edges, but it's the best learning resource I've come across
18:26:02 <vilasopher> okay, I'll check that out
18:26:15 <vilasopher> and I'll look at the other tutorials suggested by dmwit and geekosaur
18:26:35 <rvxi> even though it's "early access" it's still better than anything out there IMO https://superginbaby.wordpress.com/tag/haskell-book/
18:26:46 * geekosaur learned from the Gentle Introduction linked above (but, well, that doesn't prove it works for anyone else...)
18:26:57 <rvxi> whoops not the right link
18:27:09 <dmwit> I often wish other languages had a "Gentle Intro"-style introduction.
18:27:12 <vilasopher> I think geekosaur linked bytemyapp
18:27:16 <geekosaur> yes
18:27:23 <dmwit> You know, "Language X for the working programmer who isn't afraid to think a bit after each sentence.".
18:27:27 <ReinH> dmwit: fsvo "gentle", I suppose
18:27:46 <ReinH> dmwit: In much the same sense that Mac Lane is a "gentle" introduction to CT ;)
18:27:47 <dmwit> Don't start me with "variables can store values", I already know that *ahem* stuff.
18:27:51 <rvxi> vilasopher: http://haskellbook.com/
18:28:12 <dmwit> ReinH: yes =)
18:28:37 <rvxi> which kind of speaks to the weakness in the field of beginner->intermediate transition haskell learning materials... when an early access book is the best thing available :/
18:28:47 <dmwit> ReinH: Then again, I didn't mind that it wasn't gentle, because it got all the beautiful stuff up front and center so well.
18:29:26 <rvxi> vilasopher: bitemyapp is chris allen (if that was unclear)
18:29:42 <vilasopher> rvxi: I got it
18:29:48 <vilasopher> maybe I'll get that book
18:30:19 <rvxi> vilasopher: it's totally worth it. nothing breaks down the concepts as precisely and step-by-step
18:30:55 <vilasopher> $59 is a lot of money but it'll probably be more when it's released
18:30:57 <dhalgren> geekosaur: thx! y, saw that, but I think the window closes in a few days, and it seems to still be in flight
18:31:12 <rvxi> vilasopher: most learning materials are in too much of a hurry to get to functors and monads without building a foundation for beginners.
18:31:35 <geekosaur> yeh, I'm not sure how often that page is updated
18:31:44 <ReinH> dmwit: "Haskell for the Working Programmer" could be a good book.
18:31:48 <geekosaur> wopuldn't surprise me if they have been busier landing stuff than updating the page :)
18:31:54 <dhalgren> yy
18:32:33 <geekosaur> also note that there is a stromng "it's ready when it's ready" in ghc dev --- occasionally leading to epi delays in releases
18:32:35 <geekosaur> *epic
18:33:29 <geekosaur> (granting that part of the reason for the cutoff is to try to avoid repeating some of those)
18:36:39 <geekosaur> dhalgren, anyway if you want more up to date information you can try asking in #ghc
18:36:49 <geekosaur> hm, which I should rejoin >.>
18:41:45 <dhalgren> right!
18:43:21 <bb010g> Is there a good library with a polymorphic row type? Or should I just write my own based off another one? (Vinyl's is nice.)
18:54:26 <panovia> bb010g: What do you mean by row type?
18:54:57 <panovia> Ah, records apparently
18:56:01 <cite-reader> A bit subtler, I think; "row polymorphism" means your function can operate on any type that has the correct fields if they have the correct type.
18:56:09 <bb010g> Something like http://hackage.haskell.org/package/vinyl-0.5.1/docs/Data-Vinyl-Core.html , or http://okmij.org/ftp/Haskell/extensible/exteff.pdf . It's kind of like a polymorphic list?
18:56:37 <bb010g> I think I came up with something though.
18:56:43 <cite-reader> OCaml's object-oriented fragment is heavily based on row polymorphism; see also Go's interfaces.
18:59:12 <hodapp> polymorphic list, or heterogenous list?
19:13:02 <dldl> http://lpaste.net/146065
19:13:26 <dldl> Hi.  I want to take a list of elements and create every combination of that list as the output
19:13:37 <redxaxder> bb010g, check out http://hackage.haskell.org/package/record
19:13:54 <thimoteus> dldl: there's permutations from Data.List
19:13:56 <dldl> (if i gave it a deck of cards, it would return every possible shuffled deck as a result
19:14:17 <dldl> hahahahahahaha
19:14:30 <dldl> of course there is a predefined command
19:14:35 <dldl> I should have known
19:14:54 <dldl> my second implementation took forever to debug (I'm pretty new at this)
19:15:04 <dldl> predefined function*
19:17:17 <ReinH> it's a bit tricky to get right
19:17:27 <dldl> thimoteus++
19:17:28 <ReinH> as can be seen by the (perhaps) surprising complexity of the implementation
19:23:16 <bb010g> How do I resolve the nested type family app error in this? The error does not show up for Member. https://www.irccloud.com/pastebin/nMxiGJrH/
19:24:32 <c_wraith> bb010g: I'd try enabling UndecidableInstances, like it suggets.
19:24:35 <c_wraith> *suggests
19:25:05 <dhalgren> redxaxder, bb010g: though I think row polymorphism is closer to what Vinyl, HList, and maybe the newish "extensible" pkgs do
19:25:10 <bb010g> I'd like to avoid it if possible, but I suppose I'll try it. :)
19:25:28 <c_wraith> bb010g: It's a pretty harmless extension.  It's not like OverlappingInstances
19:26:52 <dhalgren> c_wraith: what kind of bad things happen w OverlappingInstances?
19:28:20 <c_wraith> dhalgren: It can make instance resolution harder to predict.  Instance selection when multiple instances match is weird.
19:28:43 <c_wraith> dhalgren: The worst part is that it means that adding an import (that includes another instance) can change the way already-working code works.
19:29:09 <c_wraith> dhalgren: it's not as bad as IncoherentInstances, though, which allow even more overlapping with even less predictability in instance selection.
19:34:43 <bb010g> How bad is FlexibleInstances?
19:35:08 <c_wraith> bb010g: totally harmless
19:35:18 <c_wraith> bb010g: as is its counterpart, FlexibleConstraints
19:35:41 <c_wraith> Err, that's not right.  I forget what it's called.  But it's harmless. :)
19:35:49 <dhalgren> c_wraith: I see. Y, I get why IncoherentInstances is problematic. Guess the manual doesn't make it sound as bad as it could be in practice; says there needs to be a most specific instance in the overlap and that it picks that one. I'd think this is what the programmer would expect to get; the most specific one.. There is this scary warning in the manual : "overlapping instances ... can give rise to incoherence ... even even without
19:35:49 <dhalgren> -XIncoherentInstances. Apparently, from the example, because different modules might "see" different instance contexts to choose from. Which really is an unfortunate choice of implementation; ie not to reject that.
19:36:43 <c_wraith> Actually, you can get incoherent instances with just orphan instances and no extensions in GHC - it doesn't correctly enforce the instance uniqueness rules
19:36:52 <c_wraith> Which is why orphan instances are so bad
19:37:06 <dhalgren> right. but here it happened w/o any orphans too.
19:38:31 <c_wraith> bb010g: Ah.  The other one is FlexibleContexts.  Also totally harmless.
19:50:42 <bb010g> I'm not sure where to go from here. I don't think a phantom type would work. https://www.irccloud.com/pastebin/xHoeBq4X/
19:53:17 <wyvern> I'm wondering how the 'builder' pattern is typically approached in Haskell. In imperative OO, I'd just have a mutable thing and various methods that append, etc. Do I instead create functions for each builder operation that copy over each part of an instance, modifying as needed along the way?
19:53:39 <bitemyapp> athan: dammit dude I can never remember your twitter
19:53:46 <bitemyapp> athan: because it doesn't have your name and it's something bird related
19:54:35 <geekosaur> wyvern, Monoid and WriterT already capture a "builder" concept
19:54:41 <pdxleif> bitemyapp: athan__
19:54:59 <bitemyapp> no that's not him
19:55:02 <osfameron> I'd have thought you don't typically use the builder concept though?
19:55:12 <wyvern> geekosaur: ok, I haven't gotten that far yet... still very much a hs newb.
19:55:34 <pdxleif> How many Bird-related Haskell programmers are there on twitter?
19:55:42 <bitemyapp> that's not the problem
19:55:42 <pdxleif> Oh, "Not related to Richard Bird."
19:55:58 <bitemyapp> Twitter's search doesn't bring him up when I type in Bird
19:56:03 <osfameron> wyvern: yeah, in that case, best to learn about algebraic data types and type-classes and all that, and not worry too much about how it maps to OO
19:56:52 <wyvern> yeah ADTs make sense, and I can see how I could make it work with a lot of mostly boring functions that copy stuff from an old instance into a new instance, but it seemed like there had to be a better way...
19:56:59 <geekosaur> pdxleif, twitter being what it is, I'd assume it overrun with bird puns
19:57:03 <geekosaur> for names
19:57:04 <pdxleif> They're both "Athan Clark" afaik - Not related to Richard Bird.
19:57:15 <pdxleif> whoops, paste fail, sorry; http://athanclark.github.io/
19:57:54 <bitemyapp> pdxleif: I know his GH, but it doesn't list his Twitter
19:58:04 <bitemyapp> pdxleif: it doesn't matter, I just haven't @'d him on the tweet I had in mind.
19:58:15 <pdxleif> That twitter links to that GH
19:58:53 <osfameron> wyvern: mostly you just don't construct data-types in that way, I think
19:59:03 <wyvern> OK, but what if I really want to? :)
19:59:18 <osfameron> then what geekosaur said :D
19:59:21 <wyvern> my sample project I've been using to drive my haskell exploration is porting a url builder
19:59:32 <wyvern> where basically its only point is to manually add on path params, query params, etc
19:59:38 <wyvern> so it fits very naturally into OO builder
19:59:46 <bitemyapp> pdxleif: oh wtf
19:59:53 <bitemyapp> pdxleif: it refused to auto-complete in Twitter
19:59:58 <osfameron> wyvern: but it also fits nicely into a functional approach
19:59:59 <bitemyapp> pdxleif: thank you, that's really annoying
20:00:10 <wyvern> sure, which is why I'm asking how idiomatic haskell would do it
20:00:35 <wyvern> and it sounds like the answer is "wait a bit until you know more haskell"
20:00:42 <wyvern> (which I'm ok with)
20:01:30 <osfameron> wyvern: I mean instead of using a big object to build a URL, you might use function combinators to do it
20:01:36 <osfameron> e.g. the approach is different
20:01:42 <osfameron> but it depends on *what* you want to do
20:02:18 <osfameron> e.g. instead of asking "How do I do OO Builders in Haskell?" an alternative question is "How do I design a way to do X (e.g. build up URLs) in Haskell?"
20:02:25 <osfameron> and you'll learn something different
20:02:36 <wyvern> I think that is what I'm asking ;)
20:02:37 <dhalgren> actually they said "wait a bit" for the approach corresponding to OO builder; likely there's a more idiomati way to do the task itself
20:02:46 <dhalgren> (don't ask me though; noob here)
20:03:41 <wyvern> my goal is to create a syntactically nice looking way of building an ordered, somewhat complex data structure
20:04:00 <wyvern> scheme, host, path segments (with interspersed matrix params), query elements (which may be key = value), fragment
20:04:59 <wyvern> and then I'll also learn how to do the necessary byte wrangling to efficiently whitelist safe chars, encode to %-encoded form, etc. But that part is clearer to me
20:05:16 <osfameron> sounds like a good project
20:05:23 <wyvern> For the moment I'm working my way through LYAH, and then I have a copy of Real World Haskell to get through too
20:05:45 <dhalgren> i gather that's a bit stale now. just a bit, but
20:05:54 <wyvern> which one?
20:05:59 <dhalgren> real world
20:06:00 <wyvern> It's been on my shelf for a long time
20:06:49 <kadoban> RWH has a bit of stuff out of date, mostly just some code doesn't work anymore. LYAH is … up to date, but not good.
20:07:10 <wyvern> got other suggestions? I have no intention to take Haskell to production at the moment, but I'd like to learn how to do practical things with it. If I have enough time I was thinking I'd maybe write a simple queue service to see how Haskell compares to the other platforms I'm used to for I/O performance.
20:07:56 <dhalgren> kadoban: really? thought LYAH was the dominant beginner's choice? not that *that* would be a contradiction, but
20:08:01 <kadoban> wyvern: https://github.com/bitemyapp/learnhaskell and http://haskellbook.com/
20:08:21 <kadoban> dhalgren: It has no exercises at all. At best it's like … light reading that happens to feature haskell.
20:08:40 <dhalgren> thx
20:08:54 <osfameron> it's not as bad as Why's poignant guide to Ruby *shudde*
20:09:02 <osfameron> (that put me off Ruby for years)
20:09:57 <wyvern> Oh, I just work out their sample questions ("sum every odd square less than 10000") myself and call that an exercise
20:09:59 <wyvern> that doesn't bother me
20:10:09 <wyvern> but, more reading queued. :)
20:10:59 <wyvern> I also have "the craft of functional programming". Worth reading, or look elsewhere?
20:12:00 <dhalgren> re learnhaskell: "DO NOT INSTALL HASKELL PLATFORM" -- but that's getting (has gotten?) revived now? I know (from a mailinglist discussion) SPJ and HQ want it to be/stay the way to get haskell
20:12:29 <kadoban> wyvern: Yeah, craft of functional programming is pretty good, from what I've heard.
20:12:38 <wyvern> I can't say I'm a huge fan of system installed libraries under any circumstance
20:12:52 <wyvern> if there's a package manager, why wouldn't you just use that for everything?
20:13:30 <wyvern> ruby, python, etc suffered from the same woes for years before finally the communities decided that system-wide libs were dumb
20:13:32 <Cale> dhalgren: I don't see why you'd avoid Haskell platform...
20:13:41 <kadoban> dhalgren: The recommendation not to use haskell platform existed before HP became questionably maintained.
20:14:09 <Cale> Questionably maintained?
20:14:13 <Cale> Who is maintaining it?
20:14:21 <Clint> that's a question
20:14:24 <Cale> It seems to be using GHC 7.10.2 which is recent enough
20:14:35 <kadoban> Wasn't there basically nobody who was keeping it up anymore? That was what I had heard I thought.
20:14:56 <Cale> It kind of shouldn't matter that it's not maintained at the moment, up until there's another release of GHC
20:15:19 <Cale> Installing the generic linux version sounds like a good quick way to install GHC and cabal-install
20:15:31 <Cale> So I don't hate that as an option for getting set up
20:16:04 <Cale> I mean, it's really just a glorified way to get GHC, cabal install, and a handful of packages which don't actually matter because you have cabal install
20:16:54 <dhalgren> Cale: nah - that wasn't me saying it; I was quoting the recommendation on the linked beginner's resource. Links to some recent-ish discussion re problems w it for explanation why. I remember some controversy re it recently, but also that it got revamped and quickly pushed out new versions, so I don't think that all-caps warning should stay there.
20:17:07 <Cale> ah
20:17:08 <Cale> hm
20:17:16 <Cale> Yeah, probably shouldn't
20:17:23 <pdxleif> I've been using system packages for everything including haskell libs for years. I'd probably recommend something like stack, though.
20:18:00 <kadoban> dhalgren: My, badly worded, point was that the page you're talking about has as far as I know never recommended haskell-platform. It's not a new thing, so what has changed where it should be recommended?
20:18:11 <Cale> The problem with that is that depending on which distribution you're using, those can be *waaaaaay* out of date
20:18:33 <Cale> Like, Debian and everything based on it in particular, tends to be at best a year out of date
20:18:40 <kadoban> Personally I consider it completely outdated since stack exists, and even before that it was just an annoyance … it only worked for me if I only ever used what it came with. As soon as it came time to install more libraries, it broke.
20:18:41 <Cale> and often more
20:18:59 <pdxleif> Arch linux keeps current, doesn't do weird things to packages, and makes it easy to package everything, so it's convenient for me to just stick with one package manager.
20:19:03 <Cale> People really like stack, huh?
20:19:20 <Cale> I was like "if I ever use Yesod, I'll take a look at that"
20:19:21 <kadoban> I do, at least far better than the cabal-install mess.
20:19:37 <pdxleif> Having the dependency versions pinned sounds like a good idea for reproducible builds.
20:19:47 <Cale> But maybe they're getting lots of packages in
20:20:13 <redxaxder> stack is nice, but it doesn't really replace cabal
20:20:23 <pdxleif> I've come to the conclusion most complaints about "cabal" are specifically complaints about cabal-install and it resolving ranged dependencies...
20:21:19 <kadoban> cabal-install is hell until you kind of figure out sandboxes. And then it's just purgatory.
20:21:59 <pdxleif> In the meantime I've been happy w/ Arch-provided packages (though I did switch to /usr/local/bin/ghc that I compiled myself when testing out stuff targeted for GHC 7.10.3)
20:22:30 <Clint> and i am happy with debian packages
20:22:43 <pdxleif> I think having humans try to guess at appropriate version numbers is a bit silly.
20:22:47 <kadoban> I don't use arch, but … I'm skeptical how well that could work. How much of hackage is on arch? What happens when you go outside what they have?
20:23:04 <dhalgren> kadoban: I see. sec, I'll dig through the mailinglist a bit to check re what's changed. Off the top of my head, it comes w stack now :)
20:23:17 <MarcelineVQ> arch has a custom repo you can add that has a lot of hackage
20:23:32 <dhalgren> also, thought that page is recent, since it linked to a discussion from this september
20:24:27 <pdxleif> kadoban: For quick hacking, I can cabal-install on top of those in a sandbox and/or to $HOME/.cabal
20:24:59 <pdxleif> kadoban: Generally I use an automated tool to make package build instructions (PKGBUILD) from the .cabal file, and upload them for others to use: https://aur.archlinux.org/packages/?K=pdxleif&SeB=m
20:25:07 <kadoban> pdxleif: Ah. Yeah cabal sandboxes was what I used before stack. It's mostly okay, as long as you don't mind nuking it every week or two and starting again.
20:25:27 <kadoban> dhalgren: The "why" part was added afterwards, probably he got a lot of people asking
20:25:31 <pdxleif> The thing that makes the [haskell-core]-provided arch packages is itself automated, so I should probably learn to use that, too.
20:26:09 <pdxleif> kadoban: Yeah; I treet $HOME/.cabal and sandboxes as something I can nuke when things get funny.
20:26:26 <dhalgren> ah
20:26:46 <kadoban> pdxleif: Which is pretty tedious :-/ Also sandboxes not sharing stuff gets really old, at least in my old workflow it did.
20:26:57 <pdxleif> Trying to get everything working with the same set of libs can be a pain, though. I submit a lot of fixes and .cabal version range bumps upstream.
20:27:37 <Clint> stackage is good for preempting that
20:28:21 <pdxleif> W/ system packages you don't even have to build stuff for the initial install. :)
20:32:44 <dhalgren> kadoban: this is gonna take a while; but I see it started before this september mail; "wither the platform" thread back in march. and the mailinglist in q has been quiet for months apparently? nothing to do till next release or sign of trouble? why do I have a memory of a much more recent ann on maybe reddit?
20:36:33 <Pamelloes> Nix is nice. You get the isolation of sandbozes, but dependencies are still shared.
20:36:40 <Pamelloes> (when possible)
20:37:25 <Pamelloes> Of course, nix is also a huge can of worms when not on nixos. And it has a pretty steep learning curve.
20:37:56 <wyvern> so is, say, a vagrant box of nixos a reasonable choice to sidestep these issues?
20:39:08 <dhalgren> apparently they also use stackage results, but also hackage directly. and effectively provide another, wider snapshot of the haskell ecosystem, plus all the dependeny tracking goodies
20:40:21 <Maxdamantus> I'd say nix is still easy enough on another system.
20:40:30 <Maxdamantus> It stays fairly isolated.
20:40:48 <Maxdamantus> Just make sure to run nix-daemon inside a separate root.
20:40:55 <Pamelloes> Well, on OS X it is... exciting :)
20:41:14 <Maxdamantus> Maybe not on OS X.
20:42:00 * Maxdamantus set it up in a home directory on OS X once.
20:42:21 <dhalgren> nice text on nix+hs dev : https://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html
20:42:21 <dhalgren>  
20:42:32 <Maxdamantus> It wasn't very successful at compiling things other than nix itself and its dependencies.
20:42:48 <Maxdamantus> well, even that it struggled with.
20:43:01 <Maxdamantus> might've been better in a separate root, but didn't have root access.
20:43:31 <Pamelloes> I have nix installed globally and it works great. It's just that nixpkgs often doesn't have the best support.
20:43:35 <Maxdamantus> Something about XCode tools continuing to refer to a place in the standard filesystem.
20:45:29 <dhalgren> though, wyvern I gather stack makes most ppl satisfied, and its certainly a simpler approach. we're expecting a new & improved module language & system + nixy-cabal in a year, two or so anyhow I hope (backpack; def not in 8.0 but seems to be chugging along, so..)
20:45:55 <dhalgren> um, not module lang -> pkg lang
20:46:36 <wyvern> is cabal meant to be purely a dependency resolution mechanism + basic compiler support, not a full fledged build tool?
20:47:05 <wyvern> like, if I wanted to have a more complex build and do dirty tracking as I generate distribution archives, etc, I would not use cabal for that stuff?
20:47:12 <dmwit> cabal is meant to be a full-fledged build tool.
20:47:48 <dmwit> GHC does dirty tracking.
20:48:10 <dmwit> Generating a distribution archive is generally infrequent and cheap enough that you don't need to do it for that (?).
20:48:17 <wyvern> sure I'm just using it as an example.
20:48:54 <Pamelloes> How random is System.Random? Could I use it for crypto algorithms?
20:49:01 <cite-reader> Oh HELL no.
20:49:35 <Pamelloes> What should I use for better random numbers then?
20:50:00 <Maxdamantus> Use the dual elliptic curve deterministic bit generator algorithm.
20:50:09 <wyvern> heh.
20:50:16 <cite-reader> (DOn't do that either)
20:50:58 <Pamelloes> Seeing as I don't know what that means, I have no plans on doing that :)
20:51:24 <wyvern> that's the rng that it turns out the NSA had paid RSA lots of $$$ to use
20:51:32 <wyvern> leading to widespread speculation that it was backdoored
20:51:50 <Pamelloes> ah
20:51:53 <cite-reader> There's a mathematical proof that such a backdoor exists, and strong suspicion that the NSA has the key.
20:52:29 <Pamelloes> Hmmmm, I wonder if I could get the NSA to pay me to use that algorithm. :P
20:52:34 <Maxdamantus> Indeed, it was already known that there was a possible backdoor, depending on how the specified initial state was produced.
20:52:56 <dhalgren> aha, y read about that: https://en.wikipedia.org/wiki/Dual_EC_DRBG
20:52:56 <dhalgren>  
20:54:03 <Pamelloes> Anyways, what should I use? Will I have to implement an algorithm myself, or is there a library on hackage that can act as a good source of random numbers?
20:54:17 <cite-reader> For crypto you want to hook into your operating system's RNG; I'm not actually sure what the nicest way to do that in Haskell is. Surely someone's built a library.
20:54:32 <wyvern> you can always read from /dev/random if you need to go that low level
20:54:39 <wyvern> assuming your OS has a good source of randomness, etc
20:55:05 <cite-reader> The distinction between /dev/random and /dev/urandom is silly; just use urandom.
20:55:06 <Maxdamantus> The OS' RNG usually isn't considered to be deterministic, if that's what you want.
20:55:27 <dhalgren> i see there's a reasonably popular crypto-random lib. no idea though
20:55:30 <cite-reader> (If you're considering anything for cryptographic use, it most assuredly is _not_ what you want.)
20:55:37 <cite-reader> Er, determinism.
20:55:59 <Maxdamantus> Deterministic RNGs are fairly fundamental to encryption.
20:56:38 <Maxdamantus> You usually want a non-deterministic source to get some initial keys.
20:57:35 <cite-reader> That's... _rather_ lower level than I think we were talking about, though.
20:57:51 <dhalgren> page on that pkg says deprecated in favor of cryptonite
21:00:32 <Pamelloes> hmmm
21:04:57 <bb010g> Normal ADTs and type equality constraints are equivalent to GADTs, right?
21:08:33 * hackagebot ciphersaber2 0.1.1.1 - Implementation of CipherSaber2 RC4 cryptography.  https://hackage.haskell.org/package/ciphersaber2-0.1.1.1 (BartonMassey)
21:09:15 <dmwit> I think so, yes.
21:09:22 <bb010g> Any ideas on fixing the ToJSON here? I'm stuck. https://www.irccloud.com/pastebin/xHoeBq4X/
21:11:55 <ggVGc> man trying scala after a few months of getting into haskell is painful
21:12:09 <bb010g> You'd want ToJSON x for all members of xs, but I don't know how to introduce that as a constraint.
21:12:18 <ggVGc> unfortunately scala is the only viable FP-enabled language for my work..
21:12:31 <bb010g> ggVGc: What about Clojure?
21:12:38 <cite-reader> ggVGc: That's because JVM? Or because coworkers?
21:13:32 <ggVGc> bb010g: nope, my collegues are all very much imperative programmers with experience only in ActionScript and Javascript mostly. I've been slowly moving us towards more FP, using libraries like Lodash in JS, and they ike it. So now I'm going to try moving us away from dynamic, and Scala is the only sane choice I thiknk
21:13:38 <ggVGc> cite-reader: no, just language design/syntax
21:13:44 <ggVGc> really makes me apreciate haskell
21:14:31 <bb010g> ggVGc: I would give Clojure a shot. Here's a good book for getting into it: http://www.braveclojure.com/
21:14:39 <ggVGc> cite-reader: like, for partial application you have to write explicit placeholders(with types!)
21:14:54 <ggVGc> bb010g: they would never go for something so different syntax wise unfortunately
21:14:59 <cite-reader> Yeah, I've done a little Scala. It quickly gets... weird.
21:15:22 <ggVGc> also, I don't have much lisp knowledge, so I couldn't guide very well initially. It's easier with scala I think
21:15:30 <dhalgren> anyone here regularly using some alt-preludes? like classy-prelude or whatever?
21:15:32 <ggVGc> wish a mainstream haskell would come up soon
21:15:34 <bb010g> Lisp isn't that bad after a week.
21:15:41 <dhalgren> just wondering how popular that kind of thing is
21:15:53 <gfixler1> any good explanations on the forall keyword?
21:16:00 <ggVGc> bb010g: yeah, but getting people who've been writing AS/JS for 10 years into a lisp is not a viable project I reckon
21:16:09 <gfixler1> I've tried the wikibooks writeup a few times, but it's just not cutting it for me
21:16:14 <ggVGc> gfixler1: I'd like that too. It's a bit confusing
21:16:14 <bb010g> dhalgren: My main issue with `classy-prelude` is `mono-traversable` everywhere.
21:16:22 <gfixler1> super confusing
21:16:41 <dhalgren> bb010g: w about it?
21:17:03 <gfixler1> ggVGc: why not ggcG?
21:17:07 <bb010g> gfixler1: http://stackoverflow.com/questions/3071136/what-does-the-forall-keyword-in-haskell-ghc-do#3071932 https://www.fpcomplete.com/user/PthariensFlame/guide-to-ghc-extensions/explicit-forall
21:17:13 <ggVGc> gfixler1: http://ggvgc.com
21:17:30 <gfixler1> ah, you are prepared
21:17:50 <gfixler1> I want a text object meaning the whole buffer
21:18:00 <gfixler1> ca!
21:18:09 <gfixler1> maybe ca% would work
21:18:18 <bb010g> dhalgren: You loose your proofs. Lenses are more appropriate there.
21:18:34 * hackagebot hasql 0.14.0.2 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.14.0.2 (NikitaVolkov)
21:18:38 <dhalgren> ah, I see. Does it not play well w lenses?
21:19:12 <dhalgren> i mean classy-prelude
21:19:23 <gfixler1> bb010g: I've read these before, too, but I'll give them another shot (this really is an elusive one)
21:20:03 <ggVGc> gfixler1: why a text object? You can already do :%<command>
21:20:07 <ggVGc> like :%d
21:20:10 <ggVGc> to delete all
21:20:51 <gfixler1> ggVGc: there is a philosophical difference
21:20:56 <ggVGc> hah
21:20:57 <gfixler1> ;)
21:21:08 <gfixler1> there is no feedback
21:23:38 <ggVGc> well, you can implement that text object, so get on it
21:23:57 <gfixler1> I'm leaning more toward implementing my own Vim in Haskell
21:24:05 <bb010g> gfixler1: yi?
21:24:06 <gfixler1> then I can much more easily implement such things
21:24:13 <gfixler1> bb010g: probably not
21:24:37 <gfixler1> bb010g: though I do need to investigate its underpinnings, and those of a few others, before I go reimplementing anything
21:24:38 <dhalgren> bb010g: w/a other ones? like base-prelude; basic-prelude etc? worth it?
21:26:39 <bb010g> dhalgren: No; you can use lenses just fine. It's just that you loose the guarantees Functor &al gives you. http://www.haskellforall.com/2015/10/explicit-is-better-than-implicit.html goes over why lenses work. `length (1,2) === 1` is another example of the same thing. It's a function that works though Foldable, which is the way it is on (,) for a more
21:26:39 <bb010g> category-theoretic reason. These instances and laws associated with them are important. If you don't want those laws, don't fool yourself with typeclasses. Just use lenses.
21:26:55 <dhalgren> thx
21:27:49 <dhalgren> length (1,2) == 1 seems fine to me; its not a list or such
21:27:52 <bb010g> `basic-prelude` looks pretty nice, though.
21:30:59 <Pamelloes> Monolithic projects are scary. My project has 33 direct dependencies and I keep adding more :/
21:32:05 <panovia> What project is that?
21:33:07 <Pamelloes> It's an application I'm making.
21:34:03 <Pamelloes> It's a snap web server with a bunch of complicated stuff thrown in.
21:34:06 <dmj> Pamelloes: Up to 52 deps, no prob. only specify the versions in the library, executables will inherit it
21:34:25 <dmj> Pamelloes: is it live?
21:34:55 <Pamelloes> Nope, I still have several months of more development to do :)
21:35:03 <dhalgren> bb010g: mapping over bits of the bytestring example in that article you linked is really cool ;)
21:35:19 <dmj> Pamelloes: what are you building =)
21:36:18 <Pamelloes> dmj: It's going to be a poker site for EVE Online. I'm not quite sure if I'll ever actually complete it, but it's quite fun to make :)
21:36:41 <dhalgren> hah! interesting
21:36:47 <dmj> very cool
21:38:00 <gfixler1> bb010g: wow, yi is 186 Haskell files containing more than 30kloc
21:38:47 <bb010g> gfixler1: It's a pretty nice project.
21:38:59 <gfixler1> bb010g: I really want something tiny
21:39:06 <bb010g> It's a generic base with both Vim and Emacs on top.
21:39:53 <gfixler1> bb010g: I might be wrong, but this seems rather huge, compared to what I've been craving
21:40:04 <bb010g> What have you been craving exactly?
21:40:19 <gfixler1> bb010g: it's kind of hard to explain, and based on 10 years of power Vim usage
21:40:46 <gfixler1> been feeling the edges of that for a year or two now
21:41:04 <bb010g> Check out kakoune
21:41:06 <gfixler1> it's almost certain that yi doesn't handle keyboard input the way I want
21:41:15 <gfixler1> which is the main thrust of what I care about
21:41:37 <bb010g> I've been using it as a daily driver for a couple of months now and I really like how it interacts
21:41:52 <gfixler1> bb010g: I'm pretty sure nothing that exists is going to be what I want
21:42:14 <gfixler1> that's like hoping a huge random number will end up being the one I'm thinking of
21:42:51 <bb010g> https://github.com/mawww/kakoune is worth a shot though
21:43:20 <gfixler1> bb010g: I'll check it out
21:43:54 <gfixler1> bb010g: reading the introduction, this isn't heading in the direction I want already :)
21:44:09 <bb010g> gfixler1: https://github.com/mawww/kakoune
21:44:19 <gfixler1> bb010g: yeah, reading that
21:44:36 <gfixler1> "most of its commands are similar to vi’s ones" - wrong!
21:44:44 <gfixler1> "it shares Vi’s "keystrokes as a text editing language" model." - no!
21:44:53 <gfixler1> "Kakoune can operate in two modes" - way wrong
21:45:20 <dhalgren> so you have a radically different UI in mind?
21:45:28 <gfixler1> dhalgren: yes - I've never seen anything like it
21:45:40 <gfixler1> I also don't think anyone will like it :)
21:45:46 <gfixler1> which is one of the reasons it doesn't exist, and probably won't
21:45:48 <dhalgren> hah, interesting experiment stil
21:46:19 <bb010g> gfixler1: Sorry, connection issues; didn't think the first one sent
21:47:07 <gfixler1> Vim's composable language of keystrokes is great, but limited - I want higher order composability
21:47:15 <bb010g> gfixler1: Are you talking about kak there, or $future_editor?
21:47:23 <gfixler1> bb010g: not sure
21:48:48 <Pamelloes> How would I go about printing a number with commas? i.e. 1234.56 as "1,234.56"
21:49:05 <gfixler1> Pamelloes: chunksOf?
21:50:18 <Pamelloes> So that means there's no default prettyPrintNumber function?
21:51:26 <gfixler1> https://hackage.haskell.org/package/text-format-0.3.1.1/docs/Data-Text-Format.html ?
21:51:45 <gfixler1> nah, maybe not
21:52:05 <gfixler1> http://stackoverflow.com/questions/3752898/haskell-format-number-with-commas
21:53:50 <Lokathor> any particular reason that haskell uses /= over !=
21:54:19 <Pamelloes> Lokathor: "/=" is closer to ≠
21:54:32 <Lokathor> there is that
21:54:56 <gfixler1> Haskell takes its cues from math where it can
21:55:00 <Pamelloes> But basically, it's just convention.
21:55:21 <gfixler1> programmers use !=, mathematicians use ≠
21:55:22 <Lokathor> well, does any other language ever use /=
21:55:31 <Lokathor> like, did Miranda maybe?
21:55:35 <gfixler1> Idris probably does
21:56:15 <Lokathor> isn't Idris a Haskell decendent?
21:56:26 <gfixler1> Lokathor: yeah, it's written in it, and very much like it
21:56:38 <Lokathor> i'm looking at this thing called frege
21:56:46 <Lokathor> which is a "near haskell but on the JVM"
21:57:18 <Lokathor> and i do like the idea of having access to Swing in a haskell-like language for some things
21:57:20 <gfixler1> aaahhh
21:57:52 <Lokathor> aaahhh?
21:57:58 <gfixler1> hmm... not seeing my messages now
21:58:02 <gfixler1> after that enormous netsplit
21:58:06 <gfixler1> there they are
21:58:10 <gfixler1>  /= is used in Purescript
21:58:12 <Lokathor> i see you
21:58:16 <gfixler1> ah, I can't put /= first
21:58:39 <gfixler1> it's interpreted as a freenode command
21:58:44 <Lokathor> isn't Purescript also a Haskell-family languages? I should refine my quetion: does any language that existed when Haskell first started also use /= ?
21:58:49 <gfixler1> Purescript is also written in Haskell, and inspired by it
21:58:59 <roconnor> Haskell is a Miranda clone
21:59:04 <roconnor> sort of
21:59:39 <Lokathor> i wouldn't even mind going with that, but didn't the Miranda guy say "don't make people think your thing is related to mine" when they asked him?
22:00:47 <MarcelineVQ> /gfixler1: the trick is usually to put // as a sort of escape character for /
22:01:14 <gfixler1> MarcelineVQ: ah, nice
22:01:32 <Lokathor> in Java, it's sometimes appopriate to have a setter and getter that don't directly mirror each other. Sometimes the setter will massage the data a bit to make things work for example
22:01:32 <roconnor> looks like Miranda uses ~=
22:01:47 <Lokathor> wouldn't a thing like that violate the lens laws in haskell?
22:02:01 <MarcelineVQ> Lokathor: iirc in C# those are called properties
22:02:02 <roconnor> Lokathor: yes, but the lens laws are not written in stone.
22:02:25 <gfixler1> == in Miranda created a type synonym
22:02:31 <gfixler1> string == [char], e.g.
22:02:53 <Lokathor> MarcelineVQ, yeah, python also calls them properties. Java sometimes calls them "BeanProperties", though that's also an API thing that some stuff can use as wlel
22:03:32 <Lokathor> roconnor, so i suppose the question is, "how much can you bend the laws before your code snaps in your face?"
22:05:51 <bb010g> Can you use RankNTypes and ExistentialQualification together?
22:06:06 <roconnor> bb010g: yes
22:06:18 <nocturne777> I want to export all the lenses of a record without declaring each lens in the export part of the module. is there a way to do this?
22:16:00 <Pamelloes> nocturne777: You can either export everything or explicitly list what you want to export in the module declaration. There's no hybrid support ;)
22:17:52 <nocturne777> Pamelloes: I have a "smart constructor" and I want to export some getters. by generating lenses for the type, I don't have to type out all the getters manually. I wish I could do something similiar for export as well :)
22:19:27 <c_wraith> Well, you could use -XCPP and some macros
22:20:10 <c_wraith> Though most people just create export lists, because export lists affect haddocks quite a lot, and people want that control.
22:23:30 <nocturne777> c_wraith: I see. I think I will go with export lists as well. 
22:23:47 <nocturne777> c_wraith: In the contexts of smarts constructors, is it a common practice to create lenses for the record to avoid typing out a lot of getters ?
22:25:47 <Lokathor> depends on how many getters is "a lot"
22:25:52 <Lokathor> and how similar they are
22:26:06 <Lokathor> after all you can just copy and paste some stuff around
22:43:37 <bb010g> When would it be considered "safe" to use `unsafeCoerce`?
22:44:49 <tzh> i think the answer is, if you have to ask that question it's not safe
22:46:13 <Arahael> Heh.
22:46:32 <thimoteus> i guess if you're using it as id
22:46:33 <Lokathor> no, the line is "if you have to ask you'll never know"
22:46:52 <cite-reader> There's "any time you could use not-unsafe coerce" I guess.
22:47:17 <thimoteus> safeCoerce :: a -> Maybe b; safeCoerce _ = Nothing
22:47:18 <bb010g> Doesn't Generic use unsafeCoerce under the hood?
22:49:29 <bb010g> I don't really want to transform a value, but rather a phantomish type. Is there a better way to do that?
22:49:52 <cite-reader> Phantom _ish_?
22:51:06 <bb010g> I'm carrying around a heterogeneous phantom list of types for Aeson parsing/serialization
22:51:26 <bb010g> So they're being used for each attempt at parsing, but not actually affecting the value
22:53:53 <bb010g> Which I'm beginning to think more and more was a bad idea, and that I should just go back to a simple sum
23:48:41 * hackagebot sdr 0.1.0.4 - A software defined radio library  https://hackage.haskell.org/package/sdr-0.1.0.4 (adamwalker)
