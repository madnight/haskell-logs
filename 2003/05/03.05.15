00:00:00 <Pseudonym> Right.
00:00:07 <alanl__> in theory anyway....would need to play with an example
00:00:11 * Pseudonym nods
00:01:50 <Pseudonym> http://www.haskell.org/pipermail/haskell-cafe/2002-August/003320.html
00:01:52 <Pseudonym> There's an example.
00:02:49 <Darius> C++ attaches vtbls to values, Haskell attaches them (well something similar) to types. Kind of like the difference between dynamic and static typing.
00:03:00 <Pseudonym> Yeah, kind of.
00:03:09 <Pseudonym> Actually, Haskell passes them around separately.
00:03:11 <Pseudonym> When you see:
00:03:20 <Pseudonym> lessThan :: (Ord a) => a -> a -> Bool
00:03:27 <Pseudonym> That first thing, (Ord a) is actually a parameters.
00:03:30 <Pseudonym> parameters
00:03:31 <Pseudonym> parameter
00:03:34 <Pseudonym> Blerg.
00:03:38 <Pseudonym> It's the vtable for (Ord a).
00:03:44 <wli> is there an embeddable Haskell interpreter around?
00:03:56 <Pseudonym> Not that I know of.
00:04:08 <wli> that vaguely sucks I guess
00:04:12 <Pseudonym> The Haskell philosophy is that Haskell should be in control, not some cruddy low-level language.
00:04:25 <wli> I'd be calling it from Haskell anyway
00:04:29 <Pseudonym> Low level languages are for inner loops.
00:04:57 <wli> low-level tasks, I'd say inner loops are for compilers too =)
00:05:22 * Darius is reminded of his 256-byte raytracer and begins tinkering on it again.
00:05:57 <wli> 256B is microscopic
00:06:56 <Darius> I can cut it down quite a bit, which is what I'm doing now, if I give up my dream of modularity.
00:06:56 <alanl__> is there a command to get a log of this?
00:07:27 <wli> from 256B?
00:07:39 <wli> that's smaller than a bootsector
00:07:47 <Darius> alanl: Probably, it depends on your client.  Also, #haskell is logged. (if you mean what I think you mean)
00:08:08 <alanl__> bitchx? 
00:08:56 <Darius> wli: well, it doesn't exactly provide all the amenities of POV-Ray ;)
00:09:07 <Darius> wli: like any of them
00:09:17 <Pseudonym> POV-Ray == awful
00:09:52 <Pseudonym> Filtering?  What filtering?
00:11:17 <Pseudonym> Sorry, pet peeve.
00:11:29 <Darius> alanl: I don't use BitchX, so I can't help you.
00:12:08 <alanl__> or how i can get hold of the #haskell logs
00:12:10 <wli> 137 distinct replies
00:12:21 <Pseudonym> alan: Try /topic
00:12:23 <wli> IRC is a crappy protool
00:12:30 <Pseudonym> Oh, it is.
00:13:22 <alanl__> danke....
00:13:25 <Darius> http://tunes.org/~nef/logs/haskell/
00:14:39 <alanl__> I'm thinking whether I should get into haskell research....
00:14:52 <alanl__> if I decide that i'm crazy enough to get into research that is
00:15:06 <Pseudonym> It depends what you research.
00:15:18 <Pseudonym> Please don't give us another extension to the type system.
00:15:53 <wli> alanl: I wouldn't mind -ffunction-sections
00:16:28 <alanl__> what about subtypes...? or is it undecidable currently?
00:16:31 <wli> ld --gc-sections can then nuke all bloat from the static libs
00:17:16 <wli> alanl: the type system is big enough; just look at how much of it is currently unused for most programs
00:17:28 <alanl__> LOL
00:17:43 <wli> alanl: seriously
00:17:56 * Darius has used many of the extensions.
00:18:11 <alanl__> what about concurrency then?
00:18:17 <wli> alanl: very very interested
00:18:43 <Darius> Check out Parallel/Concurrent/Distributed Haskell
00:19:06 <alanl__> yes...thats on my to-read pile
00:19:09 <wli> alanl: futexing the Haskell RTS for Linux 2.5.x would be nice
00:19:38 <wli> alanl: (and by extension, 2.6.x)
00:20:30 <Pseudonym> I want a faster implementation of ports and channels.
00:20:44 <Pseudonym> In fact, I'd seriously consider a channel which actually isn't a queue.
00:20:49 <alanl__> excuse my ignorance , but what are futexes anyway?
00:21:06 <Pseudonym> I want something as fast as a mutex.
00:21:22 <wli> alanl: lighter-weight version of sysv semaphores
00:22:39 <alanl__> oh....just as long I have the use of a debugger I'll be happy...
00:25:11 <Pseudonym> I suggest you write an ssh implementation that actually works.
00:25:19 <alanl> bitchx keeps on crashing on me
00:26:45 <alanl> okay anything else that could be interesting research topics?
00:28:56 <alanl> heelloo?
00:29:04 <Pseudonym> What intersts you?
00:29:28 <alanl> don't know.....I don't want to go too low level though
00:29:33 * Pseudonym nods
00:29:37 <Pseudonym> Maybe an optimisation?
00:29:54 <Pseudonym> One that I'd like to see is last call modulo constructor optimisation.
00:30:53 <alanl> tell me about it....
00:31:07 <Pseudonym> OK.  You know how tail recursion is implemented?
00:31:31 <alanl> somewhat...
00:31:38 <Pseudonym> If you have:
00:31:50 <Pseudonym> foo x y = foo p q
00:32:05 <Pseudonym> (Obviously here need to be other rules otherwise you have infinite recursion).
00:32:24 <Pseudonym> Then what you do is rather than call foo recursively, you set up different arguments and then goto the code for foo.
00:32:33 <Pseudonym> That way you save a call stack.
00:32:40 <Pseudonym> Sorry, a call stack frame.
00:33:12 <alanl> so you mean strictness analysis stuff? see what can be safely evaluated now right?
00:33:13 <Pseudonym> You know what I mean?
00:33:17 <Pseudonym> No.,
00:33:29 <Pseudonym> If foo is being evaluated here, then the result of foo is needed.
00:33:46 <Pseudonym> Hence just implementing it with a goto preserves laziness.
00:35:05 <alanl> did you do this for mercury? just googling
00:35:22 <Pseudonym> Uh... no, but I code reviewed it.
00:36:30 <Pseudonym> http://wombat.doc.ic.ac.uk/foldoc/foldoc.cgi?tail+recursion+modulo+cons
00:36:37 <Pseudonym> That's what I want.
00:36:48 <Pseudonym> OK, basically, if you have code like this:
00:36:57 <Pseudonym> f 0 acc = acc
00:37:09 <Pseudonym> f n acc = f (n-1) (n*acc)
00:37:11 <Pseudonym> For example.
00:37:19 <Pseudonym> (SHould be a familiar example.)
00:37:34 <Pseudonym> Then you can implement this as a loop in generated code.
00:37:48 <Pseudonym> Do you get this?
00:38:02 <alanl> so you want the compiler to convert normal code to this style whenever possible right?
00:38:16 <Pseudonym> Right.
00:38:18 <Pseudonym> And it does.
00:38:25 <Pseudonym> Right now, it does.
00:38:35 <Pseudonym> I want an extension of this.
00:38:46 <Pseudonym> Suppose, instead, the code looked like this:
00:38:49 <Pseudonym> f 0 acc = []
00:39:04 <Pseudonym> f n acc = acc : f (n-1) (n*acc)
00:39:23 <Pseudonym> Suppose furthermore that you know that the list will always be fully evaluated.
00:39:37 <Pseudonym> Then I want this tail recursive.
00:40:21 <alanl> ooh....I guess this could speed things up a bit
00:40:28 <Pseudonym> Yes, I think it could.
00:40:48 <Pseudonym> Normally, this is bad Haskell to do this.
00:40:55 <Pseudonym> Because you want the list evaluated lazily.
00:41:45 <Pseudonym> However if you look at your haskell report:
00:41:46 <Pseudonym> http://haskell.org/onlinereport/decls.html#sect4.2.1
00:41:57 <Pseudonym> You will see that in "data" declarations, you can add a ! in some places.
00:42:05 <Pseudonym> This ! means that the argument should be evaluated strictly.
00:42:18 <Pseudonym> Look for "strictness flags".
00:42:58 <alanl> right the strictness flag doesn't work very well right?
00:43:11 <Pseudonym> It works fine, it's just that this case isn't optimised for.
00:43:22 <Pseudonym> This, I think, would be a fine honours project.
00:43:59 <alanl> okay....I guess I should talk to chilli about this when hes back online
00:44:24 <Pseudonym> Sure.
00:44:31 <Pseudonym> This is just a suggestion, of course.
00:44:39 <Pseudonym> It's something I'd find useful.
00:44:59 <Pseudonym> One example where it comes up is inserting into binary trees.
00:45:22 <Pseudonym> If you think of the "obvious" code for inserting into binary trees, this is pretty much what it does.
00:45:34 <alanl> yes...i know this would of come in handy for the project we're giving to the first years
00:45:42 * Pseudonym nods
00:45:56 <Pseudonym> Not that first year project code really needs good optimisation. :-)
00:46:03 <alanl> http://www.cse.unsw.edu.au/~cs1711/project/spec.html
00:46:40 <Pseudonym> Don't have time to look at that now.  Must go home.
00:47:01 <Pseudonym> Bye everyone.
00:47:03 <alanl> no hurry....
00:47:04 <alanl> seeya
00:47:07 <Pseudonym> Good luck with your research aspirations.
00:52:08 <alanl> hello?
01:06:02 * Lilith shudders
01:07:07 <alanl> so quiet!
01:07:15 <seth> alanl: hello
01:07:46 <alanl> so what brings you to haskell seth?
01:08:20 <seth> I'm doing a big program in Haskell, and I hang here to ask questions, and learn things.
01:08:51 <alanl> for research, leisure or profit?
01:09:11 <seth> profit, at least hopefully.  :)
01:09:41 <alanl> what do you intend to write?
01:10:29 <seth> alanl: it's about half written already.  Actually I'm working on two things; one is an web content filtering system, and the other is part of a school records management system.
01:11:27 <seth> I'm very pleased with it so far.  Once I get the compiler to accept my code (  :)  ) it runs and does what I expect.
01:11:56 <alanl> what are you doing to filter p0rn?
01:12:17 <alanl> and how are you going to deal with proxies?
01:12:33 <seth> It's not just a porn filter, it is much more general.  And I deal with proxies easily; I wrote my own proxy.
01:13:05 <juhp> ok, there
01:13:24 <juhp> http://haskell.org/hircules/
01:13:47 <juhp> finally :)
01:14:11 <seth> Question:  Can an exception be thown, and caught in a function that is not the immediate caller?  That is, a calls b, b calls c, c throws an exception, can I catch it in a or do I need to catch it in b, and then raise it again and catch it in a?
01:15:52 <juhp> an exception will rise until it is caught, otherwise your program will terminate, if i'm not mistaken
01:16:16 <seth> juhp: that's what I thought.  Must have an error where I _think_ I'm catching the exception.
01:17:57 <juhp> @topic-cons http://haskell.org/hircules/
01:18:28 <juhp> lambdabot: @topic-cons http://haskell.org/hircules/
01:22:36 <alanl> does anyone know if the haskell graphics library works in ghc?
01:27:45 <Darius> I believe it does.
01:30:04 <alanl> so are you into Haskell for research , leisure or profit Darius?
01:30:32 <Darius> leisure
01:30:39 <Darius> for now
01:32:25 <alanl> how does haskell compare to python or perl in your opinion?
01:33:29 <Darius> Haven't used Python at all, and only did a very little of Perl.  Nevertheless, when I learned (some) Perl I didn't immediately stop programming C++, when I learned Haskell, I more or less did.
01:38:05 <alanl> sad thing is that the IO part of haskell is rather poorly documented
02:12:17 <reltuk> Darius : was haskell just better suited to what you were doing?  or just a better language/paradigm?
02:17:12 <el_diego> python is nice
03:00:22 <reltuk> I prefer ruby
03:12:54 <wli> Haskell makes a good scripting language IMHO (of course it's by no means limited to that)
03:13:16 <reltuk> I've never used it...just started looking
03:13:30 <reltuk> my concern in using it as a scripting language might be i/o restrictions/capabilities though
03:13:41 <reltuk> I'm sure the concern is unfounded though
04:03:09 <delYsid> HaskellPurityTest?
04:05:20 <alanl> where?
04:12:09 <delYsid> empty page on hawiki
04:28:46 <delYsid> hmm, does anyone know of a VerbalHaskell effort?
04:28:56 <delYsid> i.e., transform a Haskell program into spoken words?
04:29:46 <shapr> there's a wiki page "how to read haskell out loud"
04:30:32 <shapr> juhp: wow, cool
04:31:10 <juhp> shapr: did you try it already? :)
04:31:19 <shapr> no, I just saw the screenshot
04:31:24 * shapr quickly downloads
04:31:28 <juhp> ah, right
04:31:54 <juhp> do you have gtk2hs installed?
04:32:04 <shapr> nope
04:32:11 <shapr> not yet
04:33:03 <Marvin--> Koen is insane
04:33:18 <shapr> how so?
04:33:30 <Marvin--> he think we should write an article for HW2003
04:33:39 * juhp tried to topic-cons earlier...
04:35:01 <Marvin--> the deadline for submission is *next Thursday*
04:35:41 <shapr> hrm, gtk2hs isn't happy about ghc 5.05
04:36:12 <shapr> Marvin--: just don't sleep :-)
04:36:34 <Marvin--> shapr: it get worse... I have some stuff to fix first, so he said "right, we could meet on Monday and decide whether to write something or not"
04:37:29 <juhp> shapr: hmmm, I'm running 5.04.3
04:37:41 <juhp> what does 5.05 say? :)
04:39:53 <shapr> Marvin--: maybe he just has great faith in you
04:40:17 <delYsid> hmm
04:40:31 <zealman> hey whatsupp people
04:40:32 <delYsid> how did syntax for retrieving a record work?
04:40:54 <juhp> @hello
04:40:54 <lambdabot> Hello world. 
04:41:16 <zealman> hi world :P
04:41:29 <delYsid> lambdabot: shouldn't that be "Hello ()" ? :-)
04:41:29 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
04:41:39 <zealman> lolly
04:41:43 <zealman> hi shapr
04:41:45 <shapr> hi zealman 
04:41:52 <shapr> hello bikuta 
04:41:52 <zealman> howzit goin?
04:42:02 <bikuta> hi shapr
04:42:04 <shapr> trying to install gtk2hs, how's it going with you?
04:42:24 <shapr> juhp: the error is: 
04:42:25 <shapr> Removing old local entry for "gtk2".
04:42:26 <shapr> /home/shae/build/haskell/gtk2hs/gtk2hs-0.9.2/localpackage.conf: package `gtk2' not found
04:42:32 <zealman> hmm crazy...not too bad...i've managed to do half my assignment but im stuck on the last half :P
04:42:40 <delYsid> can anyone tell me how to retrieve an entry from a record DT?
04:42:47 <shapr> zealman: if you've done half of it, I'm sure you can figure out the rest
04:42:59 <zealman> lol ya think
04:43:12 <bikuta> i'm trying to define an ADT as a list of a list of a type i've predefined.....but i can't seem to get the definition right
04:43:15 <shapr> delYsid: if it's Record { foo :: Int, bar :: String } each of the fields is also a function
04:43:42 <delYsid> huh?
04:43:43 <shapr> delYsid: so you can do myRecord = Record { foo = 1, bar = "baz" } and then bar myRecord will give you "baz"
04:43:51 <juhp> shapr: ok, so it's just a ghc package level problem
04:43:52 <shapr> delYsid: am I answering the wrong question?
04:44:02 <delYsid> I want to retrieve values
04:44:04 <delYsid> not set them
04:44:07 <shapr> right
04:44:28 <delYsid> oh
04:44:28 <juhp> shapr: anyway i'm afraid 0.9.2 is too old for hircules - you need more or less cvs head...
04:44:28 <shapr> the names of the fields are also function names to retrieve those values
04:44:33 <shapr> ohh
04:45:17 <bikuta> data A = [] | [B] : A  <--- will that work?
04:45:18 <shapr> bikuta: try it
04:45:18 <bikuta> well it doest
04:45:18 <shapr> bikuta: I suspect you're from the cs1011 class at unsw, so I can't help you.
04:45:21 <bikuta> i'm not actually
04:45:32 <shapr> oh
04:45:33 <shapr> cool
04:46:32 <shapr> bikuta: is this homework that you're asking about?
04:46:51 <bikuta> sorta
04:46:52 <delYsid> hmm
04:47:05 <zealman> lol
04:47:05 <delYsid> I think I'll use Language.Haskell.Parser to write that toEnglish function...
04:47:20 <shapr> bikuta: we can't help you with homework, that would be unethical.
04:47:35 <shapr> juhp: I'm getting the same error with a cvs checkout
04:47:59 <shapr> any ideas?
04:48:09 <bikuta> well i need just this type definition so i can do the rest of it
04:48:15 <juhp> shapr: you could try my gtk2hs tarball from the hircules homepage
04:48:21 <shapr> ok, I will
04:48:37 <juhp> it has various patches on it
04:48:54 <shapr> bikuta: I would recommend that you search google for "abstract data type" and haskell
04:49:01 <juhp> but i haven't tried cvs ghc, so it may not work
04:49:14 <bikuta> hmm ok
04:53:26 <shapr> juhp: looks like localpackage.conf is generated with empty values, could you send me yours?
04:56:14 <wli> I can't bootstrap ghc with the version I've got
04:56:26 <wli> Seems to barf on some function prologue or other.
04:56:39 <juhp> shapr: ok, sure - hang on
04:56:42 <zealman> can i ask a question about a user defined type...
04:56:56 <shapr> zealman: as long as it's not homework
04:57:01 <zealman> nah
04:57:35 <zealman> its something on my notes that i don't understand, and i can't understand the explanation on it
04:58:36 <zealman> its a [("some string" , (\ n -> (take n (repeat "a few times") ) ) )]
04:58:43 <zealman> it's something about a lambda function
04:59:18 <shapr> have you looked up all the pieces? do you know how take, repeat, and lambda functions work?
04:59:30 <zealman> yeah i know the first two they're easy
04:59:37 <shapr> what about lambda functions?
04:59:42 <zealman> but lambda i can't quite get my head around it
05:00:21 <shapr> what do you know about lambda functions so far?
05:01:07 <zealman> i know they're supposed to replace the syntax of a function?
05:01:33 <shapr> what does that mean? :-)
05:02:02 * juhp thinks enough haskelling for one day and heads off to rest
05:02:03 <shapr> wli: have you tried updating cvs and rebuilding since then?
05:02:13 <juhp> g'nite
05:02:17 <wli> shapr: doesn't work on ghc4 either
05:02:22 <shapr> juhp: can I get your package.conf?
05:02:25 <wli> shapr: probably a problem with my installed version
05:02:28 <shapr> er, localpackage.conf ?
05:02:43 <juhp> shapr: sure
05:02:47 <zealman> defines anonymous functions?
05:02:53 <shapr> zealman: yes
05:03:04 <shapr> wli: using the deb?
05:03:26 <zealman> such as (\n -> n+1) 4
05:03:46 <zealman> is the same as succ:: Int -> Int
05:03:54 <shapr> yup
05:03:58 <zealman> succ n = n+1
05:04:00 <wli> (+1)
05:04:03 <zealman> how is it the same?
05:04:19 <zealman> like...do you have to define succ:Int-> Int 
05:04:39 <zealman> first and then use \ instead of  succ n 
05:04:47 * juhp wonders if anyone has made deb's of gtk2hs recently?
05:05:02 <shapr> zealman: functions are code/instructions/whatever that have names, yah?
05:05:11 <zealman> yepsiree
05:05:44 <shapr> so when you use those functions in a variable, you only care about referring to the variable, not the original name of the function
05:05:54 <zealman> yep
05:05:56 <shapr> so whether the original function was named or anonymous makes no differenc
05:06:05 <zealman> how dat
05:06:27 <shapr> increment x = x + 1 is the same as (\x -> x + 1)
05:06:50 <zealman> mkai...
05:06:53 <shapr> so if you did map increment [1,2,3] it would be no different from map (\x -> x + 1) [1,2,3]
05:07:29 <zealman> so you can use lambda functions all over the place then?
05:07:35 <shapr> zealman: yah sure
05:07:41 <Marvin--> shapr: I wouldn't say that  increment x = x + 1  is the same as  (\x -> x + 1), but *given* the declaration  increment x = x + 1  *increment* and *(\x -> x + 1)* are the same
05:07:55 <zealman> so the \ part .... is the function on that say x
05:08:03 <zealman> and what does the -> do
05:08:03 <shapr> Marvin--: fair enough
05:08:10 <shapr> zealman: it's the = sign
05:08:15 <Marvin--> zealman: -> is just instead of lambda calculus '.'
05:08:28 <zealman> oh ok....
05:08:40 <zealman> i kinda understand....its pretty late.here
05:08:50 <Marvin--> \x.y  is  \x -> y  in haskell
05:09:02 <zealman> coolo...
05:09:08 <shapr> zealman: so, how would you write a lambda function form of " double x = x * x "
05:09:12 <zealman> thanks for that clarification
05:09:16 <shapr> ?
05:09:25 <zealman> \x -> x*x
05:09:29 <shapr> yes, exactly
05:09:34 <zealman> aww true bro
05:09:39 <zealman> :P
05:09:48 <shapr> cool, you understand it!
05:09:56 <zealman> hmm the basics :P
05:10:27 <shapr> juhp: thanks!
05:10:32 <Marvin--> zealman: note that in lambda calculus you often write  \x.\y.z  as  \xy.z  and pretty much the same thing applies to haskell;  \x y -> z  is the same thing as  \x -> \y -> z
05:10:39 <juhp> shapr: sure, np :)
05:11:19 <zealman> commutative ?
05:12:22 <juhp> shapr: downloading a ghc snapshot now - will try build gtk2hs with it tomorrow
05:12:29 <juhp> building even
05:12:30 <shapr> cool, thanks
05:12:32 <zealman> no offence to any americans...but this NRA is a bunch of wackos
05:12:39 <shapr> zealman: depends on your viewpoint
05:12:44 <zealman> *watching abc news*
05:12:51 <Marvin--> NRA?
05:12:56 <shapr> national rifle association
05:12:58 <Marvin--> oh
05:13:02 <zealman> i'm of the viewpoint that running around shooting schoolkids by schoolkids is stupid
05:13:13 <Marvin--> those nuts
05:13:15 <shapr> zealman: sure, I agree with tha.
05:13:24 <Marvin--> zealman: did you see Bowling for Columbine?
05:13:26 <zealman> but thats my viewpoint
05:13:32 <zealman> oh no..i've gotta though
05:13:45 <Marvin--> the interview with Charlton Heston was brilliant :-)
05:13:52 <shapr> zealman: but then people shot each other in the town I was living in, in Finland.
05:13:55 <shapr> and guns were illegal there
05:14:27 <zealman> yeah...but in terms of per capita
05:15:14 <zealman> down here in lil ol noo zeeland we don't need guns
05:15:24 <zealman> seems like we can live without them.
05:15:33 <shapr> yah, they're just tools.
05:16:05 <zealman> and deadly ones at that
05:16:08 <shapr> yup
05:16:10 <zealman> *cough*
05:16:13 <shapr> they have no other purpose
05:16:21 <zealman> exactamundo
05:16:21 <shapr> unlike stun guns
05:16:44 <shapr> zealman: any other questions?
05:16:54 <zealman> hmm...
05:17:09 <zealman> i gotta figure out the rest of this assignment
05:17:20 <zealman> all these brackets mess with my head
05:17:22 <zealman> :P
05:17:33 <Marvin--> ever tried lisp?
05:17:39 <zealman> noop
05:17:50 <Marvin--> lots of irritating silly parentheses
05:18:45 <Riastradh> ((lambda (f) (f f)) (lambda (g) (g g)))
05:18:55 <Riastradh> Well, that won't work in most dialects of Lisp, actually.
05:19:39 <Riastradh> (funcall #'(lambda (f) (funcall f f)) #'(lambda (g) (funcall g g))), but only because most dialects of Lisp have different environments for functions and variables.
05:20:56 * Igloo urgles
05:21:15 <Igloo> I don't think I've ever seen "funcall" or "#" in LISP code before
05:21:22 <Riastradh> There are advantages to the very simple syntax of s-expressions, though.
05:21:50 <Riastradh> Igloo, what dialect have you been seeing, then?
05:22:19 <Igloo> Scheme and CL I guess
05:22:27 <Igloo> I've not done much at all with it, mind
05:22:44 <Riastradh> In Scheme my former expression will work, because Scheme is just so much cleaner and more elegant than most other Lisps.
05:23:06 <Riastradh> CL may not require you to use the #' reader macro, but it does require you to use FUNCALL or APPLY for anonymous functions.
05:23:13 <Igloo> OK, that's the one I've read a book on
05:23:25 * Igloo goes
05:24:32 <Marvin--> Igloo: dang, I was going to bite on your offer to explain the gmap code
05:24:36 <reltuk> Riastradh : You written anything significant in scheme? (if so, what?)
05:24:48 <Riastradh> reltuk - SRFI 43 -- http://srfi.schemers.org/srfi-43
05:28:43 * Riastradh wanders away.
05:30:13 * shapr hotfoots
05:31:46 <Marvin--> concatMap (uncurry (:)) (map floatLetsD ds)
05:31:48 * Marvin-- coughs
05:31:52 <shapr> eh?
05:31:56 <shapr> oh
05:32:18 <shapr> Marvin--: floatlets sound like applets for a city pool ;-)
05:32:30 <Marvin--> tsk
05:32:32 <shapr> I have a membership card for the Nordpoolen here
05:32:40 <shapr> though I still haven't visited.
05:35:35 <Marvin--> Nordpoolen... *groan*
05:37:02 <shapr> ?
05:37:28 <Marvin--> bad pun
05:37:35 <shapr> I don't understand it
05:37:39 <Marvin--> Nordpolen = North pole
05:37:44 <shapr> heh!
05:37:48 <shapr> ok, that is funny
05:38:08 <Marvin--> glad to be of service
05:38:09 <shapr> since we're so close to the arctic circle
05:38:22 * Marvin-- bows and flourishes his cloak
05:38:58 * shapr does the drum crash
05:39:01 <shapr> ba dum BAH
05:40:05 <Marvin--> ba-dum-k-TISCH
05:40:17 <shapr> that's more descriptive
05:40:32 <Marvin--> (don't forget the cymbals)
05:41:23 <Marvin--> ugh, should I build in a pre-processor in my frontend too...
05:41:47 <Marvin--> can I get ghci to run a preprocessor when interpreting my modules?
05:42:55 <Marvin--> aha, nice
05:43:27 <Marvin--> damn, that'd be handy
05:45:00 <Marvin--> uhh
05:45:26 <Marvin--> if I have a file with  #ifdef FOO ... #endif  and run  ghc -cpp -DFOO -E file... shouldn't I get the "..." on stdout?
05:47:12 <shapr> I'm not sure
05:47:18 <shapr> if you figure it out, I wanna know
05:47:31 <shapr> I've tried to fit arrowp into -F
05:47:41 <Marvin--> -F?
05:47:56 <shapr> isn't that the preprocessor param?
05:47:57 * shapr checks
05:48:35 <shapr> yah, -F and -pgmF
05:49:49 <Marvin--> oh
05:50:09 <shapr> you think that's the right GHC flag?
05:50:50 <shapr> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#PRE-PROCESSOR
05:53:19 <Marvin--> but isn't -F _only_ for custom preprocessors?
05:53:48 <Marvin--> well, believe it or not, I think I have more important things to do
06:11:23 <Marvin--> yay, E finds the bug in 37 seconds
06:14:05 <shapr> yay!
06:14:44 <delYsid> hmm, how would you pronounce
06:14:54 <delYsid> f (a:x (b:y) = ...
06:15:29 <delYsid> er, plus the obvious paren
06:15:58 <shapr> yow
06:15:59 <shapr> nested patterns
06:16:11 <Marvin--> delYsid: and plus making x a constructor
06:16:18 <delYsid> shapr: I think what I currently do could be interesting to you, as you always were interesting in spoken programming...
06:16:19 <Marvin--> oh, sorry
06:16:24 <shapr> delYsid: yes!
06:16:25 <Marvin--> you meant (a:x) (b:y)
06:16:50 <delYsid> yup
06:17:12 <Marvin--> oh fuck
06:17:14 * Marvin-- swears
06:17:15 <shapr> ?
06:17:25 <delYsid> shapr: A language-construct name doesnt help much, I need a way to put it into a sentence
06:17:25 <Marvin--> no wonder quickcheck didn't find the bug :/
06:17:57 <Marvin--> let Just s = unify t1 t2 in appSubst s t2 == appSubst s t2   -- see anything strange? :/
06:18:34 <shapr> I can't quite figure out what the order of evaluation is there
06:18:50 <shapr> what does the Just s do?
06:18:57 <Marvin--> oh, that's just a pattern binding
06:19:07 <shapr> oh, you're using t2 twice
06:19:09 <shapr> never t1
06:19:11 <Marvin--> exactly
06:19:11 <shapr> hi opet 
06:19:22 <shapr> shouldn't -Wall catch that?
06:19:23 <opet> hiya
06:19:25 <shapr> unused variable?
06:19:26 <Marvin--> right, now to see if I understand this ... 7800 lines long E proof...
06:19:28 <opet> (hooray for ntl!)
06:19:38 <Marvin--> shapr: no, I do use t1 to produce s
06:19:44 <shapr> nottingnet transport limited?
06:19:50 <shapr> ohh
06:20:00 <delYsid> hmm
06:20:20 <delYsid> f of what euqals ...
06:20:24 <shapr> delYsid: I think what you're doing is related to Marvin--'s discussion of Show not having both str and repr
06:20:49 <delYsid> ?
06:20:50 <shapr> seems to me this should be just another show instance
06:20:53 <shapr> er
06:21:05 <shapr> say instead of Show
06:21:09 <shapr> the Say typeclass
06:21:10 <Marvin--> shapr: actually, point, putting them in the same class, you could give a default implementation for one of them in terms of the other
06:21:15 <shapr> right
06:21:31 <delYsid> You mean
06:21:37 <delYsid> instance Say HsModule where ?
06:21:42 <Marvin--> class Show a where { show :: a -> String ; repr :: a -> String ; show = repr }
06:21:46 <shapr> Marvin--: what's the relationship among str, repr, and Show ?
06:22:12 <shapr> delYsid: yah, that's what I would do
06:22:14 <Marvin--> shapr: in python, there's always a default repr, and if there's no str, str defaults to repr, iirc
06:22:53 <shapr> repr was originally designed to work like (read x) = read (show x)
06:22:57 <Marvin--> shapr: otoh, putting them in different classes means you can say  data Foo = ... deriving Repr ; instance Show Foo where ...
06:23:03 <shapr> str was designed to be a 'showable' representation
06:23:20 <delYsid> anyway, for now, its here : http://lexx.delysid.org/SpokenH.hs
06:23:38 <shapr> delYsid: the nice thing about a Say typeclass is that you could take advantage of the current Show structure
06:23:51 <Marvin--> shapr: I guess you could say  class Repr a => Show a where ... but that's way ugly...
06:24:55 <Marvin--> shapr: I mean, even if you normally would derive Repr, you can't do that if you want circular values
06:25:12 <delYsid> and it does things like
06:25:12 <shapr> huh?
06:25:13 <delYsid> "Type synonym Row is a list of Integer
06:25:14 <delYsid> Type synonym Triangle is a list of Row
06:25:14 <delYsid> pascal is of type Triangle
06:25:14 <delYsid> pascal is p where
06:25:19 <delYsid> p is A list with the head being a list with elements 1 and the tail being a map next p
06:25:20 <delYsid> ..."
06:25:39 <shapr> delYsid: that's spiffy
06:25:43 <Marvin--> you need parentheses :)
06:26:16 <delYsid> nah
06:26:17 <shapr> I think you should mention this on haskell-cafe, ask for ideas/thoughts
06:26:19 <delYsid> I want to avoid them.
06:26:25 <delYsid> and create nice english sentences
06:27:01 <shapr> delYsid: so, does this include um.. 'Read' instances? ;-)
06:27:19 <delYsid> shapr: ?
06:27:31 <delYsid> It uses Language.Haskell.Syntax
06:27:59 <delYsid> and erm, I'm not on haskell-cafe
06:28:05 <delYsid> and too stupid to discuss things with them.
06:29:50 <shapr> delYsid: bullshit :-P
06:31:50 <delYsid> see, thats the kind of reaction I expect :)
06:33:13 <shapr> I don't know the correct german word for that
06:33:42 <shapr> g'day sjj
06:33:51 <shapr> dutch has a nice word "gezeik"
06:33:57 <sjj> howdy
06:34:35 <shapr> mr thirmite sir ;-)
06:35:14 <sjj> :)
06:35:27 <Marvin--> right, this wasn't an optimization at all, dang
06:36:13 * shapr tries to get gtk2hs to build
06:36:27 <shapr> library.mk is broken somehow
06:37:20 <delYsid> http://haskell.org/hawiki/HowToReadHaskell
06:41:34 <o3> hmm
06:41:54 <o3> i wonder if i'm the only fool who reads "x <- newCString "bleh"" as "x comes from newcstring bleh"
06:44:36 <shapr> since I've never spoken to anyone about Haskell sources, I've never thought of how to speak these things.
06:44:47 <shapr> I've never actually met another Haskell programmer in person :-)
06:45:01 <o3> come to my uni
06:45:12 <shapr> would be great :-)
06:45:12 <o3> you'll meet about 700 of them :)
06:45:26 <o3> of course, most of those will be first years, but hey, they count too!
06:45:42 <shapr> truly
06:46:07 <shapr> wow, hircules/lambdabot is getting interest on the mailing list
06:46:08 <shapr> nifty
06:46:10 <shapr> @yow
06:46:15 <lambdabot> ..  or were you driving the PONTIAC that HONKED at me
06:46:15 <lambdabot>  in MIAMI last Tuesday?
06:46:17 <shapr> I guess I better clean up the code quickly
06:52:07 <shapr> grr, anyone else tried to install gtk2hs on ghc 5.05?
06:54:57 <wli> hmm
06:55:05 <wli> looks like someone pounded out an IRC protocol engine
06:55:11 <shapr> where?
06:55:17 <wli> for hircules
06:55:29 <wli> http://haskell.org/hircules/
06:55:33 <shapr> oh, I haven't looked at the sources for hircules yet.
06:55:42 <shapr> hircules is based on lambdabot
06:55:57 <wli> it's actually very incomplete wrt. protocol parsing
06:56:51 <wli> i.e. it looks like it's missing more pieces than it has
07:06:10 * tmoertel d'ls the hircules source tarball
07:06:14 <delYsid> hmm, does haskell  have a kind of mapconcat, like the lisp version?
07:06:32 <tmoertel> concatMap ?
07:06:35 <delYsid> i.e, mapconcat [1,2,3] "and" would result in "1 and 2 and 3"
07:06:48 <Marvin--> delYsid: you want foldr1
07:06:54 <delYsid> s/"and"/" and "/
07:07:02 <tmoertel> mapconcat = (concat.) . intersperse
07:07:09 <Marvin--> delYsid: oh, sorry
07:07:19 <Marvin--> delYsid: I thought you meant function applications, sorry
07:07:28 * Marvin-- is tired
07:07:43 <tmoertel> whoops:  mapconcat = flip ((concat.) . intersperse)
07:08:07 <delYsid> I dont have intersperse
07:08:12 <tmoertel> import List
07:09:06 <tmoertel> (also, your types must be appropriate.  mapconcat [1,2,3] "and" is a type error, but mapconcat ["1","2","3"] " and " would be fine
07:09:09 <delYsid> what does the (concat.) exactly do?
07:09:16 <delYsid> I've never seen that kind of cunstruct yet
07:09:33 <tmoertel> (f . g) x = f (g x)   -- function composition
07:09:53 <delYsid> yeah, but I've never seen a . followed by nothing
07:09:55 <tmoertel> (f.) is a left operator section of the (.) composition operator
07:09:59 <Marvin--> delYsid: (concat .) is a section
07:10:08 <Marvin--> delYsid: equal to   (.) concat
07:10:16 <Marvin--> delYsid: or \x -> concat . x
07:10:19 <tmoertel> yes
07:10:32 * delYsid is confused
07:10:47 <Marvin--> it's like partial application, but on operators
07:11:19 <tmoertel> typically (.) is used to join functions taking one argument, yielding a new function of one argument
07:11:54 <delYsid> yup, that, I understand
07:12:07 <tmoertel> but, here, we want to yield a function of two arguments
07:12:59 <tmoertel> so, looking at the right part of our string, intersperse:
07:13:03 <tmoertel> @type intersperse
07:13:30 <tmoertel> (no lambdabot?)
07:14:00 <tmoertel> ok, then:  intersperse :: [a] -> [[a]] -> [[a]]
07:14:12 <tmoertel> it takes two arguments
07:14:28 <norpan> håhåjaja
07:14:32 <delYsid> forall a. a -> [a] -> [a]
07:14:55 <delYsid> actually
07:15:06 <tmoertel> yes 
07:15:19 <wli> mTwine :: [a -> b] -> [a] -> [b]
07:15:23 <wli> mTwine (f:fs) (x:xs) = f x : mTwine (fs ++ [f]) xs
07:15:23 <wli> mTwine _ [] = []
07:15:41 <wli> twine f g = mtwine [f,g]
07:15:46 <tmoertel> if we tack it onto (concat :: [[a]] -> a)
07:16:02 <tmoertel> using (.) . . .
07:16:32 <tmoertel> type error
07:17:12 <delYsid> erm
07:17:20 <delYsid> this will twist my brain today I think...
07:17:34 <delYsid> erm, any pointer which might try to explain this to a newbie like me?
07:17:49 <tmoertel> because ((.) intersperse) is only going to take one argument and pass it to intersperse before taking the result of that evaluation (of type [a]->[a]) and passing it to concat
07:19:04 <tmoertel> however ([a]->[a]) can be composed rather well with [[a]]->[a], and so (concat.) is what we want to pass the result of giving one argument to intersperse 
07:19:15 * tmoertel doesn't know of any pointers
07:19:42 * tmoertel notices, looking back thru his explanation, that he got several types wrong, no doubt confusing the reader
07:20:15 <opet> correction left as an exercise for the reader? :)
07:20:26 <tmoertel> indeed!  (good save ;-)
07:20:29 <delYsid> heh
07:21:03 <delYsid> addRows of empty list  and empty list  equals the empty list.
07:21:04 <delYsid> yay!
07:21:21 <tmoertel> in short:  ((f.) . g) is an idiom for composing functions when g takes two arguments instead of the more-common single argument
07:21:55 * tmoertel needs coffee
07:22:43 <delYsid> hmm
07:22:53 <delYsid> can you expand this in non-point-free form?
07:23:09 <delYsid> funny that, using a dot is called point-free programming.
07:23:11 <SyntaxPolice> tmoertel: is that on the wiki?
07:25:42 <tmoertel> SyntaxPolice: I don't know....  I think there is idioms page of some sort.
07:25:45 * tmoertel checks
07:26:03 <wli> I thought I heard it called the combinatory style somewhere
07:26:56 <Marvin--> delYsid: that's why the rest of us call it point-less programming
07:27:47 <wli> "My proposed first sentence was, 'The author discusses valueless measures
07:27:47 <wli> in pointless spaces.'"
07:27:47 <wli>         -- Paul R. Halmos, "I want to be a Mathematician"
07:28:02 <tmoertel> mapconcat xs y = concat (intersperse xs y)
07:31:42 <Marvin--> oh well, there goes that article idea
07:36:23 <SyntaxPolice> tmoertel: if its not on the ideoms page, you should add it.
07:38:37 <delYsid> hmm, is there a way to see the arguments of a "Non exhaustive pattern"?
07:40:40 <SyntaxPolice> delYsid: like, which patterns weren't matched?
07:44:13 * tmoertel adds (f.).g entry to PipeliningFunctions on hawiki
07:45:03 <SyntaxPolice> woohoo! Go Wiki!
07:45:42 <wli> (concat.) . zipWith (...) is useful
07:48:09 <delYsid> SyntaxPolice: exactly
07:48:27 <delYsid> -cx does only give me the call-stack, which isn't particularily useful here
07:48:34 <delYsid> s/-cx/xc/
07:49:15 <wli> Prelude> let intertwine = (concat.) . zipWith (flip (:) . (:[])) in intertwine [1,3..9] [2,4..10]
07:49:15 <wli> [2,1,4,3,6,5,8,7,10,9]
07:50:38 <wli> that wasn't quite what I wanted =(
07:51:10 <wli> Prelude> let intertwine = (concat.) . flip (zipWith (flip (:) . (:[]))) in intertwine [1,3..9] [2,4..10]
07:51:11 <wli> [1,2,3,4,5,6,7,8,9,10]
07:55:36 <tmoertel> @prelude Monoid
07:55:40 <lambdabot> No match for "Monoid".
07:55:53 <tmoertel> @prelude mplus
07:55:55 <lambdabot> *** "mplus" prelude "Haskell Standard Prelude Dictionary": text follows
07:55:55 <lambdabot> mplus
07:55:55 <lambdabot>   class Monad m => MonadPlus m where
07:55:55 <lambdabot>     mplus ::  m a -> m a -> m a
07:55:55 <lambdabot>   instance MonadPlus Maybe where
07:55:57 <lambdabot>     Nothing `mplus` ys = ys
07:55:59 <lambdabot>     xs      `mplus` ys = xs
07:56:01 <lambdabot>   instance MonadPlus [ ] where
07:56:03 <lambdabot> [there's @more]
07:56:05 <tmoertel> @more
07:56:05 <lambdabot>     mplus = (++)
07:57:23 <Marvin--> tmoertel: mappend
07:57:37 <SyntaxPolice> delYsid: not sure about that, but you could turn on warnings in ghc which will tell you which patterns aren't complete.
07:57:39 <Marvin--> but it's not in the Prelude
07:57:47 <SyntaxPolice> also Hat might do something for you, don't know.
07:57:59 <SyntaxPolice> (and tell you how to complete the patterns)
08:01:54 <delYsid> how would you pronounce ->?
08:03:55 <wli> dot =)
08:04:29 <delYsid> yay! finally, it translates a whole module
08:04:54 <wli> to what?
08:10:15 <wli> hmm
08:12:54 <wli> taq queued protocol, spawn a lightweight thread for each command and associate a channel, squirt anything with a matching tag down the channel, have a global receiver for the server-initiated bits
08:12:56 <delYsid> wli: Haskell2English
08:14:01 <delYsid> http://lexx.delysid.org/SpokenH.hs -- if anyone wanna play with it, I'd be happy to receive comments.
08:14:29 <tmoertel> delYsid: does H2E use Language.Haskell.Parser ?
08:14:54 * tmoertel looks at code and answers his own question
08:19:59 <Igloo> Marvin: Back now if you're still interested
08:22:45 <Marvin--> Igloo: sure, I could use a break from fighting with this
08:23:08 <Igloo> Marvin: Which bit don't you understand?
08:27:01 <Marvin--> Igloo: let's start in gEnvTraversal, I guess... The "first" thing that happens is that the tree is gEnvTraversal is called recursively with the gmapT...creating what? the whole environment for all transformations?
08:27:51 <Marvin--> Igloo: so in fact the tree is traversed three times?
08:28:28 <Marvin--> but then why would we need both the recursive call and the mkM:s... hmm
08:29:17 <Marvin--> or will the mkM:s only be applied locally since they're not used with a gmapM?
08:29:29 * Marvin-- is confused
08:30:09 <delYsid> tmoertel: yup
08:30:55 <Igloo> Marvin: Lazy evaluation means only one will actually be done
08:31:25 <Igloo> The recursive gmap is only done if the other two don't apply (return Nothing)
08:31:26 <Marvin--> Igloo: yeah, I like that excuse too :)
08:32:13 <Igloo> So it tries the let case first, then the var case and finally falls back on just recursing
08:32:43 <Marvin--> oh, right, I'm confusing fromMaybe with another function
08:33:22 <Marvin--> there's a whole lot of recursive calls going on, so I'm a bit confused
08:34:58 <Igloo> fromMaybe :: a -> Maybe a -> a, uses the maybe if it's a just, otherwise the a
08:35:04 <Marvin--> yeah
08:35:38 <Marvin--> I keep expecting the arguments to be the other way around, maybe that's what confusing me
08:35:47 <Igloo> It's the same as case m_new_let of { Just x -> x; Nothing -> case m_new_var of { Just x -> x; Nothing -> ... }}
08:37:22 <Igloo> And do_let and do_var don't recurse themselves, they call gEnvTraversal again to do the recursion
08:37:22 <Marvin--> I'd probably be less confused if it used mplus instead :)
08:37:44 <Igloo> Ah, yes, that would be a bit nicer
08:37:44 <Marvin--> yes, I'm simplifying away some code
08:37:46 <Marvin--> and it's looking nicer
08:38:05 <Igloo> You can't simplify it that much can you?
08:39:00 <Marvin--> well, I got rid of the get_new_mappings and stuff, introduced some LCs instead of map (\(...) -> ...) et.c.
08:39:12 <Marvin--> call it "reorganize" instead
08:39:30 <Igloo> *nod*
08:44:28 <Marvin--> Ambiguous type variable(s) `a' in the constraint `Term a'
08:44:29 <Marvin--> argh
08:44:33 * Marvin-- is trying to rewrite it to using mplus
08:45:32 <Marvin--> it's not happy about   mkM (do_let s) x `mplus` mkM (do_var s) x `mplus` Just (gmapT (foo s) x)
08:46:18 <Igloo> Does it work if you comment out the type signature?
08:46:40 <Marvin--> nope, then I get a "Inferred type is less polymorphic than expected"
08:47:39 <wli> Marvin: when the inferred type is unified with the declared type the unified type requires substitutions to be performed on the declared type
08:49:42 <Marvin-->     Ambiguous type variable(s) `a' in the constraint `Term a'
08:49:42 <Marvin-->     arising from use of `do_let' at Main.hs:33
08:49:42 <Marvin-->     In the first argument of `mkM', namely `(do_let s)'
08:49:42 <Marvin-->     In the definition of `m1': mkM (do_let s) x
08:51:18 <Marvin--> type system tricks are tricksy
08:51:33 <Marvin--> oh well, I guess I'll try to get used to fromMaybe instead
08:52:39 <Marvin--> right, let's see if I can adjust this to use my slightly more complex AST
08:52:45 <Marvin--> (ugh)
08:52:48 <delYsid> "So, the essence of XML is this: the problem it solves is not hard, and
08:52:49 <delYsid> it does not solve the problem well." -- Jerome Simeon & Phil Wadler
08:52:51 <delYsid> ha!
08:52:56 <delYsid> that one is uberc00l
08:53:14 <Marvin--> hey, it's Wadler, of course it's cool
08:55:01 <Marvin--> Igloo: hey, would you mind using that funky DrIFT thingy on my AST.hs file?
08:57:08 <Marvin--> 'course, another approach would be eating dinner
08:57:56 * Marvin-- has a hunch that after gluing on the special cases, and the more complex AST onto the code, it'll be as big and more cluttered than the simple recursive implementation
08:58:31 <Igloo> Sure, where is it?
08:59:13 <Igloo> It should get any more complex should it?
08:59:14 <Marvin--> http://193.11.232.159:8080/AST.hs
08:59:14 <Igloo> Well, apart from patterns etc
08:59:16 <Igloo> But you won't need loads of recursive calls
09:02:56 <Igloo> http://urchin.earth.li/~ian/AST.hs
09:03:39 <Marvin--> thanks
09:06:30 <Marvin--> too bad I have to do the collecting of declarations and removing of lets in separate passes
09:06:55 <Marvin--> (they were pretty damn simple though ;)
09:08:30 <Igloo> You don't have to, but it would be a lot uglier to read if you didn't
09:09:28 <Marvin--> right, I couldn't use everywhere or everything, since it's both a query and a transformation
09:11:19 <Igloo> Oh, yes, I keep forgetting gmapT can't change the type
09:12:34 <Marvin--> well, how would it do it? I mean, I'd have a function  a -> (a, R)  which is neither query nor transformation...
09:13:31 <Igloo> Yeah, I'm agreeing with you  :-)
09:14:23 <Marvin--> heck, I'm starting to feel that my non-gmap code would be simpler if I split it up in two passes there, but then I'd have to have two sets of recursive functions, no thanks
09:14:44 <Marvin--> I'm still a bit conservative about using gmap in "released" code yet though
09:41:33 <Lilith> :)
09:41:48 <Lilith> hi Cowgirl
09:41:58 <Lilith> i hope you're ok with your assignment now
09:42:27 <Lilith> anyone who haven't seen the Matrix Reloaded, the CG was great. :)
09:43:27 <Cowgirl> lilith...given up
09:43:33 <Cowgirl> at the point i really dont care
09:43:52 <Lilith> Cowgirl: awwr. :( that's no good
09:43:54 <Cowgirl> not even bothering with it tonight....had 2 nights where i was up to 6am, and only had 2 hours sleep
09:44:06 <Lilith> Cowgirl: what did you not understand?
09:44:08 <Cowgirl> i need more sleep, its not helping me
09:44:18 <Cowgirl> i wrote one function out wrong
09:44:22 <Cowgirl> so got to do it again
09:44:23 <Lilith> when's it due?
09:44:27 <Lilith> well
09:44:29 <Cowgirl> sunday midnight!
09:44:45 <Cowgirl> cause of the sleep deprivation, i just cant think
09:44:50 <Lilith> go to bed then
09:44:57 <Cowgirl> so theres no point in trying it until the weekend
09:44:58 <Lilith> get a good night's sleep
09:45:00 <Lilith> well
09:45:01 <Cowgirl> i will...i had to work tonight
09:45:12 <Lilith> Cowgirl: and also, make sure you test each function
09:45:25 <Lilith> that's what interpretors are for
09:45:36 <Cowgirl> i will....just need a break,....i wont finish it, i know that for sure
09:46:10 <Lilith> have you got a friend doing the same subject? talk to your friend about it when you're rested
09:46:19 <Lilith> it helps to talk through the problem
09:46:28 <Lilith> and make sure you check you haven't made typos :)
09:46:34 <Cowgirl> yeah,  thats the thing,  many of us are having problems with it
09:46:44 <Cowgirl> and onyl expect to get a few functions out
09:47:06 <Lilith> are you having problems with the problem design?
09:47:10 <Lilith> or problems with haskell?
09:47:46 <Cowgirl> design
09:47:54 <Lilith> ok
09:47:59 <Lilith> when you're rested
09:48:13 <Lilith> get a bunch of friends, and do a rough design on paper
09:48:24 <Lilith> it helps sometimes to talk through the design
10:05:05 <Lilith> Cowgirl: i'm not in charge of anything, if you have issues, bring it up with the lecturer or grievance officer
10:05:13 <Lilith> and don't bug me with your personal problems
10:05:59 <Cowgirl> lilith, u spoke to me, i didnt ask u a thing!
10:06:11 <Cowgirl> i didnt bring anything up
10:06:17 <Cowgirl> dont turn this around on me
10:06:22 <Lilith> well, i was just asking if you were ok with your assignment
10:06:28 <Lilith> i don't give a shit about your previous assignment
10:06:33 <Cowgirl> the answer is FUCK NO!!!!
10:06:44 <Cowgirl> so why the fuck talk to me
10:06:50 <Cowgirl> jesus christ u got issues
10:06:50 <Lilith> fine
10:06:57 <Cowgirl> u need to chill the hell out
10:16:39 <hdaume> wow, that was intense :)
10:17:22 <delYsid> haha, women
10:17:34 <Lilith> grr
10:18:01 <Lilith> sorry folks, back to coding :p
10:18:37 <Lilith> i'm not going to give free consults ever again
10:18:50 * delYsid remembers Baha
10:19:01 <Smerdyakov> Are you a member of the staff for a class Cowgirl is taking?
10:19:03 <Lilith> all i get from cowgirl was to be called a bitch
10:19:15 <Lilith> Smerdyakov: no
10:19:42 <Lilith> i was just asking how her assignment was going
10:19:52 <Lilith> and was pretty willing to answer any haskell questions
10:20:03 <Lilith> till she started pouring out her sob story about tutors
10:20:10 <Smerdyakov> OK, but I think your "i'm not in charge of anything" exchange was out of line....
10:20:11 <Lilith> so i gave her some practical advice
10:20:33 <delYsid> er
10:20:33 <Lilith> well, the thing was, this was the second time she did it to me
10:20:38 <Lilith> and i'd told her what to do
10:20:41 <delYsid> I think we missed privmsg discussion, right?
10:20:49 <Lilith> i don't need to listen to some sob story over and over again
10:21:04 <Lilith> especially since i don't teach the class she's taking
10:21:06 <delYsid> because given what I have in backlog, you attacked her
10:21:15 <Lilith> delYsid: yes
10:21:21 <delYsid> ic
10:21:24 <Lilith> sorry, she privmsged me
10:21:59 <Smerdyakov> I think it would have been better to explain things in a nicer way in a private message.
10:22:06 <Lilith> i did
10:22:12 <Lilith> she just wasn't getting it
10:22:17 <Smerdyakov> OK
10:22:35 <Lilith> she was ranting on about unfair treatment and i was telling her how to about it
10:22:41 <Lilith> and she was getting pretty worked up
10:22:46 <delYsid> er
10:22:47 <Smerdyakov> Well, when I was a teaching assistant, a student in the class lived next door to me. That was bad. ;-)
10:22:49 <Lilith> and being really rude to me
10:22:53 <delYsid> there is no unfair treatment in programming
10:22:58 <delYsid> only people who dont grok what to do
10:23:30 <Smerdyakov> That is not true, delYsid.
10:23:41 <delYsid> Smerdyakov: no?
10:23:45 <Smerdyakov> People who don't have so much experience often need personal help to understand things.
10:24:03 <delYsid> My experience is that they are just to lazy to read up 
10:24:07 <Lilith> grr
10:24:08 <Smerdyakov> Forcing them to do everything with no one-on-one help from course staff is "unfair treatment."
10:24:10 <delYsid> and want to get this done by someone else
10:24:16 <Lilith> i should have kept a log
10:24:28 <Smerdyakov> delYsid, if you are basing this on people asking for help on IRC, then your sampling is statistically biased.
10:24:46 <Lilith> Smerdyakov: agreed. 
10:24:56 <Lilith> i was happy to help her with issues with haskell
10:24:58 <delYsid> Not particularily IRC, just comp-sci help in general
10:25:10 <Smerdyakov> delYsid, s/IRC/the Internet
10:25:19 <Lilith> but asking me to debug her assignment is not on, since i'm not teaching her class
10:25:22 <delYsid> But I may as well be terribly wrong, since I never studied
10:25:23 <Smerdyakov> delYsid, most students who have trouble suffer silently if they aren't told how to get personal help.
10:26:03 <delYsid> Smerdyakov: and I consider "knowing how to look it up" a quality which needs to be learned
10:26:24 <Lilith> delYsid: well, sometimes you could look something up and not understand it
10:26:39 <delYsid> then your search wasnt complete yet
10:27:04 <Lilith> delYsid: but you could be searching forever! it's what i might call an infinite search tree
10:27:16 <Lilith> since one can't know the bounds of that search tree :)
10:27:23 <Lilith> that why one asks for help
10:27:48 <delYsid> 90% of the questions I get asked daily are just simple, and a laziness on the askees part
10:28:06 <Lilith> telling me that i'm a bitch when i was trying to help is just NOT ON
10:28:32 <Lilith> (she said a whole lot of other stuff as well, but i won't mention it here)
10:29:29 <delYsid> things like "I dont understand regexp" I sometimes just answer by "because you never read regex(7), right?"
10:30:54 <Lilith> some people mightn't know man pages exist or which man page to look at
10:31:19 <dennisb> it's not that easy to read things like that in the beginning (and to find it in the first place)
10:31:24 <delYsid> ok, I stop now :)
10:31:25 <Lilith> you could just simply tell them "man regex(7)"
10:31:35 <delYsid> I would have said "that indicates that they didnt even start to search for their answer"
10:31:37 <delYsid> but oh well
10:31:38 <dennisb> for us it would be faster to read the manual then to ask on irc
10:31:46 <Lilith> heh
10:32:03 * Lilith read a book on regex
10:32:41 * delYsid learned it from perlre(1)
10:32:51 <Lilith> and i'm happy to give help because i know what it's like being a lowly first year
10:33:02 * dennisb don't know he learned it, but he knows it...
10:33:11 <Lilith> but to be called names drives me nuts
10:33:43 <dennisb> Lilith: don't worry, people are frustrated sometimes, just be polite and then ignore them :-)
10:35:03 <Lilith> dennisb: i was trying to
10:35:14 <Lilith> but evidently my proxy isn't doing its job
10:35:25 <Lilith> or at least my irc client was ignoring my /ignore commands
10:35:35 <Lilith> which i haven't worked out why yet :)
10:35:36 <dennisb> I havn't followed the above (it was to much to read), I was just talking in general terms
10:35:52 <dennisb> I usually just ignore myself
10:36:35 <dennisb> tools is cheating
10:36:43 <Lilith> i was trying to be polite to her till she started swearing at me in private because "people are monitoring the main channel"
10:37:22 <Lilith> i'm sorry folks, i should have kept it off channel
11:51:50 <Marvin--> hey Jolta, how'd the project go?
11:52:22 <Marvin--> Jolta: you have no idea how peeved the GU students taking the OO course were about you guys holding up several labs :/
11:52:25 <Jolta> Marvin--: Ok, I guess. We're not done 'til the report is handed in thursday, though.
11:52:48 <Jolta> Marvin--: Yes, I noticed... Tell them to take their domplaints to the Dean. =)
11:53:12 <Jolta> hm... I type like ... something which does not type well... ... today.
11:53:13 <Marvin--> Jolta: but you have to agree that it sucks, badly, they have a deadline pretty damn soon
11:53:35 <Jolta> Marvin--: oh? i didn't know. 
11:53:52 <Marvin--> Jolta: tomorrow, I think, or maybe next Friday
11:54:14 <Jolta> Marvin--: i honestly don't know why the presentations are held at MC instead of somwhere up here at Chalmers
11:54:42 <Marvin--> Jolta: and I honestly don't know why you guys have computers we can't access when you guys obviously can access all of ours :-/
11:54:52 <Jolta> Marvin--: Money. =)
11:55:26 <Marvin--> Jolta: well, true
11:55:31 <Marvin--> Jolta: sucks to be us, though
11:55:47 <Marvin--> Jolta: and you have no idea what a PITA it is to TA chalmers courses as a GU student
11:56:39 <delYsid> hmm, sad that our Uni here is so null with fp
11:56:40 <Jolta> Marvin--: I could always try to argue that OO students could have used the remaining workstations or something, but I know I would be in the wrong...
11:56:50 <Jolta> delYsid: which uni?
11:56:57 <delYsid> they still teach SML, and that in a way that the students call the course "Sado-maso-language"
11:57:20 <delYsid> Jolta: tu-graz
11:57:35 <Marvin--> :)
11:57:51 <delYsid> i.e., if you talk to a student in Graz about FP, he looks at you very scared
11:57:56 <delYsid> and thinks you're completely out of your mind
11:59:13 <Jolta> delYsid: sound like what Chalmers students think of digital curcuit synthesis
12:00:07 <Jolta> delYsid: very badly handled course the last 5 years
12:00:35 <Jolta> delYsid: one year, 80% failed the exam...
12:01:29 <Marvin--> whoops, that's what I get for drooling
12:16:40 <Jolta> grok!
12:41:10 <Jolta> did everyone get disconnected?
12:42:18 <Smerdyakov> No
12:50:01 <Jolta> Smerdyakov: ok, so the conversation just died then. I guess that happens.
12:50:17 <Smerdyakov> Jolta, we are keeping secrets from you.
12:50:40 <Jolta> =)
12:51:03 <Marvin--> Jolta: sucks to be you :)
12:57:48 <Darius> someone tinkering with the logo, eh
12:59:24 <Jolta> which logo is that?
13:00:21 <hdaume> on haskell.org
13:01:14 <Igloo> Hmmm, interesting
13:01:30 <esap> whoa, nice arrows there.
13:02:11 <Jolta> like the forall. =)
13:02:19 <Marvin--> eeew, that's one ugly logo
13:02:45 <Igloo> The dark-on-dark bits on the left are really crap IMO - especially the dots
13:03:04 <Marvin--> I think the concept in itself is horrible
13:03:30 * Igloo isn't 100% convinced either
13:03:59 <esap> I can't really understand the meaning of the round background. The color is just.... hmm.. interesting.
13:04:35 <Igloo> The colours work OK on the right I think
13:04:36 <Jolta> oh, I hadn't noticed the iohc results were up
13:04:37 * Igloo disappears
13:04:44 <Jolta> I'll have to look into those
13:04:47 <Marvin--> esap: you mean, ugly?
13:04:58 <Marvin--> I think it's too cluttered
13:05:23 * delYsid wants IOHCC#2!
13:05:32 <delYsid> I completely missed #0
13:05:40 <esap> marvin: yes. When I say "interesting" I usually mean "questionable" :-)
13:06:01 <delYsid> esap: as in the chinese saying? :)
13:06:06 <Marvin--> esap: so... read any interesting papers lately? ;)
13:06:36 <esap> marvin: there is a difference between "interesting" and interesting :-) 
13:06:51 <Marvin--> esap: oh
13:07:43 <esap> marvin: but sure, I have read both types of papers.
13:08:57 * esap has probably already at some point recommended citeseer.nj.nec.com/fokkinga93adjunction.html or citeseer.nj.nec.com/article/hillman98what.html
13:09:18 <Smerdyakov> Well.... fokkinga is a funny name read as American English.
13:09:46 <delYsid> there is a town in germany called fucking
13:11:15 <hdaume> ah, that's ripe for jokes: "God, I've really gotta get out of here.  I've been living in fucking, germany all my life!"
13:11:27 * Marvin-- groans
13:11:29 <delYsid> they've got Amercian tourists photographing the road-sign all over the place
13:11:36 <hdaume> delYsid: i'm sure
13:20:05 * tmoertel thinks the new haskell.org logo looks like a naval anti-ship mine
13:20:16 <Marvin--> tmoertel: heh, good one
13:20:31 <SyntaxPolice> can anyone suggest a way to compose functions in a way that looks like this:
13:20:45 <SyntaxPolice> (<=) = (||) $ (<) . (==)
13:20:54 <SyntaxPolice> (points-free style)
13:22:28 <Marvin--> SyntaxPolice: hey, that looks like perl-style line noise
13:22:28 <tmoertel> you need different combinators
13:22:32 <Marvin--> SyntaxPolice: you need more $'s though
13:22:48 <esap> syntaxpolice: I'm not sure I understand the question. That does use composition.
13:23:08 <SyntaxPolice> Marvin--: yeah, I was thinking about perl line noisea ctually
13:23:35 <SyntaxPolice> esap: but that doesn't actually work AFAICT
13:24:01 <esap> syntaxpolice: ah, you want to compose binary functions?
13:24:02 <SyntaxPolice> actually, the <= and || aren't the interesting part, I'm just using them to make the illustration clear
13:24:35 <SyntaxPolice> esap: yeah, but its not really composition; the output of one isn't going to the input of another.
13:25:19 <SyntaxPolice> so as tmoertel sorta suggests, I should call it "combine" instead of "compose"
13:26:08 <Vincenz> hmm
13:26:16 <Vincenz> a foldleft?
13:26:16 <esap> syntaxpolice: I'm still not sure what operation you want to do.
13:26:21 <tmoertel> (binGlue glueOp u v) x y = glueOp (u x y) (v x y)
13:28:23 <SyntaxPolice> tmoertel has got it.  I was just wondering if there were a more built-in way to do it.
13:29:04 <tmoertel> Prelude List> let lt x y = binGlue (||) (<) (==) x y
13:29:05 <tmoertel> Prelude List> lt 3 3
13:29:05 <tmoertel> True
13:29:05 <tmoertel> Prelude List> lt 2 3
13:29:05 <tmoertel> True
13:29:05 <tmoertel> Prelude List> lt 3 2
13:29:07 <tmoertel> False
13:29:08 <tmoertel> Prelude List> 
13:29:28 <Vincenz> that should be le
13:29:29 <Vincenz> not lt
13:29:48 * tmoertel groans
13:30:26 <Vincenz> :P
13:31:05 <Marvin--> \leq
13:31:56 * tmoertel thinks it cool that James Clark specified the algorithm for validating Relax NG in Haskell
13:33:47 <tmoertel> s/validating Relax NG/validating XML vs a Relax NG schema/
14:48:20 <esap> Hmm.. is it possible to write the following without unsafePerformIO?  x |-| y = \a -> IOB.unsafePerformIO $ CE.catchJust pm (CE.evaluate (x a)) (\_ -> return (y a)) where { pm (CE.PatternMatchFail _) = Just () ; pm _ = Nothing }
14:51:36 <esap> It has type (|-|) :: (a -> b) -> (a -> b) -> a -> b
14:54:01 <Marvin--> that looks scary
14:54:43 <esap> the idea is that you can do something like ((\ [] -> 1) |-| (\ (a:b) -> 0)) []  and it returns '1'. But with argument [1], it returns 0.
14:55:13 <Marvin--> yeah, I figured
14:55:22 <Marvin--> why not... you know, use case? :)
14:56:15 <esap> because I want to use functions as "building blocks" for pattern matching constructs. It's possible to use the maybe monad, but I figured you should also be able to do that for ordinary functions.
14:56:27 <Marvin--> right
14:56:40 <Marvin--> well, I don't think I can help you, and I'm off to bed
14:57:05 <mgoetze> gnight, Marvin-- 
15:35:18 <tmoertel> esap: have you looked at gmap ?
15:40:46 <esap> tmoertel: yes.
16:00:04 <shapr> oy
16:01:25 * kawfee bounces
16:01:40 * shapr splashes
16:01:51 * shapr caffeinates
16:02:44 <shapr> juhp: oh, the gtk2hs install problem is being discussions on glasgow-haskell-bugs@h.o by Axel Simon and Simon Marlow
16:21:31 * tmoertel ought to caffeinate
17:45:08 <Pseudonym> @yow
17:45:08 <lambdabot> Who wants some OYSTERS with SEN-SEN an' COOL WHIP?
17:50:14 <zealman> howdy yall
17:50:24 <Riastradh> Hi.
17:50:26 <Pseudonym> G'day Mr fellow down under-type person.
17:50:32 <zealman> haha
17:50:37 <zealman> true bo
17:50:40 <zealman> where you from
17:50:48 <Pseudonym> The other side of the Tasman.
17:50:58 <zealman> aww yea
17:51:05 <zealman> not tasmania....
17:51:07 <Pseudonym> No.
17:51:09 <zealman> haha
17:51:16 <zealman> thats not so bad then :P
17:51:40 <Pseudonym> Tasmanis is actually very beautiful.
17:51:56 <zealman> yeah...just the people like to marry their cousins etc...
17:52:06 <zealman> anyways...
17:52:08 <Pseudonym> Well, there's not a lot to do if you don't like nature.
17:52:13 <zealman> lol
17:52:20 <Pseudonym> If you do like nature, it's close to paradise.
17:52:29 <Pseudonym> Well, a kind of cold and wet paradise.
17:52:29 <zealman> thats why i live here mate
17:52:40 <zealman> ;)
17:52:43 <Pseudonym> :-)
17:52:49 <Pseudonym> North or south island?
17:52:55 <zealman> SI bro
17:52:56 <zealman> chch
17:53:33 <Pseudonym> Oh, you live in Middle Earth!
17:53:46 <zealman> and you live in the matrix
17:53:49 <zealman> so we're even :P
17:53:53 <Pseudonym> Nah, that's Sydney.
17:54:01 * Pseudonym is in Melbourne
17:54:09 <zealman> cool, i like melbourne
17:54:10 <Pseudonym> No sentient programs down here.
17:54:13 <zealman> lol
17:54:22 <zealman> i like melbourne better than sydney
17:54:31 <Pseudonym> Oh, I like you.
17:54:34 <zealman> haha
17:54:48 <zealman> its more cosmopolitan...
17:54:53 <zealman> and the shoppings great :d
17:54:55 <Pseudonym> Melbourne and Sydney have a rivalry that's been going on for about 160 years.
17:54:58 <Arnia> I live in Hogwarts :/
17:55:07 <zealman> kind of like a derby type scenario
17:55:16 <zealman> i'll go wif melbourne on that one
17:55:46 <Pseudonym> Well Sydney came first, then Melbourne, then Sydney found some gold, then Melbourne found the richest goldfield in the world...
17:55:55 <zealman> true...
17:56:00 <Pseudonym> Then after WW2, Sydney got more immigration and they've stayed bigger ever since.
17:56:15 <zealman> yeah...but melbournes pretty big too
17:56:26 <Pseudonym> Well, not on a world scale, but yes.
17:56:36 <zealman> yeah, ya know what i mean
17:56:40 <Pseudonym> Sydney is where you visit, Melbourne is where you live.
17:56:40 <Pseudonym> IMO
17:56:50 <zealman> i concur
17:57:08 <Pseudonym> So where are you precisely?
17:57:19 <zealman> Christchurch
17:57:25 <Pseudonym> Ah, very pretty city.
17:57:30 <zealman> yeah it is
17:57:36 <zealman> boring as though...
17:57:41 <zealman> well...not really
17:57:45 <Pseudonym> Supposedly meant to be a model of an English provincial centre.
17:57:56 <zealman> something like that....but in no way am i english :P
17:58:03 <zealman> wel...i am part
17:58:08 <zealman> but thats besidse the point
17:58:19 <Pseudonym> If you go back far enough, many New Zealanders are.
17:58:28 <zealman> i more maori then anything
17:58:38 <Pseudonym> OK, cool.
17:58:53 <Pseudonym> Do you speak Maori?
17:59:17 <Pseudonym> Just curious.
17:59:19 <zealman> everyone knows a little korero maori 
17:59:45 <zealman> ko Zak taku ingoa
17:59:47 <zealman> my name is zak
17:59:49 <zealman> ra ra
18:00:15 <Pseudonym> OK, I have a question.
18:00:24 <Pseudonym> Some of my ancestors came to Australia from New Zealand.
18:00:25 <zealman> ok
18:00:40 <zealman> yep
18:00:52 <Pseudonym> The place they settled they named "Arawatta", apparently after something in New Zealand.
18:01:06 <Pseudonym> I've been told by a separate source that Maori does not have the "w" sound, so it can't be a Maori name.
18:01:08 <Pseudonym> Is that true?
18:01:42 <Pseudonym> Or it might have been "Waihola".
18:01:49 <Pseudonym> Something with a "w" in it, anyway.
18:01:53 <zealman> i've never seen arawatta before
18:02:03 <zealman> i didn't think maori had a double t syntax in it
18:02:15 <Pseudonym> Well that might be part of the Romanisation.
18:02:22 <zealman> arawa would be correct
18:02:34 <zealman> and maori does have w sounds in it
18:02:35 <Pseudonym> In the early days there were many ways to transliterate naitve languages.
18:02:37 <Pseudonym> Oh, OK.
18:02:37 <zealman> like wahine = woman
18:02:45 <Pseudonym> So the guy was wrong.  Gotcha.
18:02:48 <zealman> yep
18:02:51 <Pseudonym> Thanks.
18:02:55 <Pseudonym> What does "arawa" mean?
18:03:03 <zealman> its a place in the NI 
18:03:07 <Pseudonym> And while we're at it, do you know what "waihola" mwans?
18:03:10 <Pseudonym> If anything?
18:03:11 <zealman> some godforsaken area...
18:03:35 <zealman> i don't know about the hola bit... but wai is water
18:03:41 <Pseudonym> Oh, OK.
18:03:46 <Pseudonym> I think Waihola was the ship they arrived on.
18:03:49 <Pseudonym> So that makes sense.
18:03:56 <zealman> hm ok..
18:04:07 <zealman> like Waitemata harbour in auckland means sparkling water
18:04:23 * Pseudonym nods
18:04:24 <Pseudonym> Gotcha.
18:04:26 <zealman> hey do you know haskell
18:04:34 <Pseudonym> Yes.
18:04:37 <zealman> true..
18:04:57 <zealman> i iz havin a bit of trouble with a function...
18:05:01 <Pseudonym> OK.
18:05:21 <zealman> its not returning the right type...
18:05:34 <zealman> and logically it should...but i can't see it
18:05:56 <Pseudonym> Did you give the function a type signature?
18:06:02 <zealman> yeah
18:06:34 <zealman> like type xxx = [(String, Int -> String)]
18:06:57 <Pseudonym> Uhm... I mean did you declare a type for the function
18:07:02 <zealman> yyy:xxx
18:07:08 <Pseudonym> f :: SomeType -> SomeOtherType
18:07:12 <Pseudonym> f x = ...
18:07:31 <zealman> hmm... noop
18:08:11 <Pseudonym> I suggest you do that.
18:08:18 <Pseudonym> Putting in a type declaration is very useful.
18:08:26 <Pseudonym> You get very meaningful error messages if you do that.
18:08:42 <zealman> yyy=[("some x", (\n -> (take n (repeat "sdf"))))] and it says type error 
18:08:47 <Pseudonym> You tell the compiler what type you want the function to return, then it tries to find out why it idin't.
18:08:52 <zealman> so do i have to declare that lambda signature
18:09:03 <Pseudonym> What specifically does it say is a type error?
18:09:12 <Pseudonym> Oh, I see.
18:09:32 <Pseudonym> What does it say the return type should be?
18:09:57 <zealman> Type error in explicitly typed binding
18:09:57 <zealman> *** Term           : toys2
18:09:57 <zealman> *** Type           : [([Char],Int -> [[Char]])]
18:09:57 <zealman> *** Does not match : ToyList2
18:10:11 <Pseudonym> OK.  You know that String is [Char], right?
18:10:20 <zealman> where toys2 is the yyy bit and xxx is the ToyList2
18:10:22 <zealman> yep
18:10:27 <Pseudonym> OK.
18:10:44 <Pseudonym> So compare your type (ToyList2) with what your compiler thinks it is.
18:10:58 <Pseudonym> What's the difference?
18:11:20 <zealman> well the compiler is expecting a String, but its getting [Char]
18:11:26 <Pseudonym> No.
18:11:28 <Pseudonym> Look again.
18:11:42 <zealman> hmm...
18:12:05 <Pseudonym> It's not getting [Char].  It's getting [[Char]]
18:12:22 <Pseudonym> [Char] is String, [[Char]] is [String]
18:12:45 <zealman> so is my type defintion wrong
18:13:01 <Pseudonym> Well, there's a mismatch between your type and your code.
18:13:06 <Pseudonym> At least one of them is therefore wrong.
18:13:22 <zealman> i tried changing the brackets in the lambda function ....
18:13:25 <Pseudonym> If the type is what yoy really mean, then it's your code that's wrong.
18:13:36 <zealman> yeah its the code
18:13:41 <Pseudonym> I'll give you a clue.
18:13:44 <Pseudonym> @prelude repeat
18:13:46 <lambdabot> *** "repeat" prelude "Haskell Standard Prelude Dictionary": text follows
18:13:46 <lambdabot> repeat
18:13:46 <lambdabot>   repeat ::  a -> [a]
18:13:46 <lambdabot>   repeat x          = xs where xs = x:xs
18:14:11 <Pseudonym> I don't think that repeat does what you think it does.
18:14:23 <zealman> no i'm thinking off track
18:14:38 <Pseudonym> Try repeat "sdf" on the command line and see what you get.
18:14:57 <zealman> it goes bananas and prints it out til you ctrl c it
18:15:08 <zealman> ["sdf", "sdf,...]
18:15:16 <Pseudonym> Is that what you wanted?
18:15:47 <zealman> yeah, but restricted by the take n command
18:15:53 <Pseudonym> OK, try that.
18:16:02 <Pseudonym> take 3 (repeat "sdf") or something.
18:16:10 <zealman> oh yeah, like take 4 (repeat "sdf") will do it 4 times
18:16:14 * Pseudonym nods
18:16:18 <Pseudonym> Is that what you wanted?
18:16:49 <zealman> yeah.... and that \n -> take n (repeat "sdf") shoud work
18:16:56 <zealman> in the context of my list
18:17:09 <Pseudonym> Well if that's what you wanted, then you really want the function to return [String] rather than String.
18:17:15 <Pseudonym> Right?
18:17:25 <zealman> yeah...
18:17:33 <zealman> so if i changed the type def would it work
18:17:34 <Pseudonym> So it's your type that's wrong after all.
18:17:40 <zealman> hmm thats what i thought
18:17:41 <Pseudonym> See, that's useful though.
18:17:56 <zealman> nah, i have to fit it into a String
18:18:07 <Pseudonym> Ah.
18:18:16 <Pseudonym> What do you actually want to return, then?
18:18:33 <zealman> well [(String, Int -> String)] should return a list of strings if i take the snd one of it
18:18:36 <zealman> should it not
18:18:49 <Pseudonym> The snd one of what?
18:19:02 <zealman> snd one of the type def
18:19:05 <Pseudonym> [(String, Int -> String)] is a list of pairs
18:19:55 <zealman> so [("ssdf", \n -> take n (repeat "asd")] should return n times "asd" shouldn't it?
18:20:13 <zealman> if i took just the snd 
18:20:45 <Pseudonym> Sorry, you typed take n (repeat "something") on the command line.  You saw what you got.
18:20:49 <Pseudonym> You get a list of Strings.
18:20:54 <zealman> yep
18:21:00 <Pseudonym> And you want a single String.
18:21:18 <Pseudonym> So you have to combine the list of strings somehow.
18:21:22 <Pseudonym> Into one string.
18:21:29 <Riastradh> @prelude concat
18:21:30 <lambdabot> *** "concat" prelude "Haskell Standard Prelude Dictionary": text follows
18:21:30 <lambdabot> concat
18:21:30 <lambdabot>   concat ::  [[a]] -> [a]
18:21:30 <lambdabot>   concat            = foldr (++) []
18:21:37 <Pseudonym> That's one approach.
18:21:39 <zealman> hmm....
18:21:39 <Pseudonym> There's also:
18:21:41 <Pseudonym> @prelude show
18:21:44 <lambdabot> *** "show" prelude "Haskell Standard Prelude Dictionary": text follows
18:21:44 <lambdabot> Show
18:21:44 <lambdabot>   class Show a where
18:21:44 <lambdabot>       show      :: a -> String
18:21:45 <lambdabot>       showsPrec :: Int -> a -> ShowS
18:21:47 <lambdabot>       showList  :: [a] -> ShowS
18:21:49 <lambdabot>       -- Minimal complete definition: show or showsPrec
18:21:51 <lambdabot>       show x          = showsPrec 0 x ""
18:21:53 <lambdabot> [there's @more]
18:21:58 <Riastradh> @more
18:21:58 <lambdabot>       showsPrec _ x s = show x ++ s
18:21:58 <lambdabot>       showList []     = showString "[]"
18:21:59 <lambdabot>       showList (x:xs) = showChar '[' . shows x . showl xs
18:21:59 <Pseudonym> I don't think we need to see more.
18:22:01 <lambdabot>   		      where showl []     = showChar ']'
18:22:03 <lambdabot>   			    showl (x:xs) = showChar ',' . shows x . showl xs
18:22:04 <Riastradh> Too late.
18:22:05 <Pseudonym> Oh, OK. :-)
18:22:06 <Riastradh> I was just curious, anyways.
18:22:07 <lambdabot> show
18:22:09 <lambdabot>   class Show a where
18:22:11 <lambdabot>     show ::  a -> String
18:22:13 <lambdabot> [there's @more]
18:22:18 <zealman> i want my output to be [["asd", "asd"]] if i put 2 into the lambda function
18:22:34 <Pseudonym> Well that's of type [[String]]
18:22:45 <Pseudonym> Make up your mind. :-)
18:23:21 <zealman> lol
18:24:02 <Pseudonym> Some people don't like strongly typed languages.
18:24:10 <Pseudonym> I think they're pretty useful for precisely this reason.
18:24:16 <Pseudonym> You're not sure what you want.
18:24:25 <Pseudonym> Getting it written down in types clarifies your thinking.
18:25:19 <zealman> now it says something different
18:25:38 <Pseudonym> OK.  What's your code now and what's the error message?
18:25:56 <zealman> ERROR - Type error in application
18:25:57 <zealman> *** Expression     : playToys 2 toys2
18:25:57 <zealman> *** Term           : toys2
18:25:57 <zealman> *** Type           : ToyList2
18:25:57 <zealman> *** Does not match : (a,b -> c)
18:26:21 <zealman> type ToyList2  = [(String, Int -> String)]
18:26:24 <Pseudonym> Right.
18:26:28 <Pseudonym> What's the difference there?
18:26:31 <zealman> toys2:ToyList2
18:26:50 <Pseudonym> Note that it says the problem is with "toys2".
18:27:06 <zealman> toys2 = [("sheep", (\n->(take n (repeat "bah"))))]
18:27:11 <Pseudonym> It's of type ToyList2, but it wants something of type (a,b -> c).
18:27:19 <zealman> yeah
18:27:31 <Pseudonym> OK.  Why don't you put a type signature on playToys.
18:27:45 <Pseudonym> I think that would help.
18:27:55 <Pseudonym> In the mean time, I'll get some caffeine.  BRB
18:28:36 <zealman> i did
18:28:38 <zealman> ERROR "/home/zealman/evolution/UniversityWork/cosc230/testlib10.hs":35 - Type error in explicitly typed binding
18:28:38 <zealman> *** Term           : toys2
18:28:38 <zealman> *** Type           : [([Char],Int -> [[Char]])]
18:28:38 <zealman> *** Does not match : ToyList2
18:28:42 <zealman> k
18:34:13 <Pseudonym> OK, back.
18:34:19 <zealman> k
18:34:28 <Pseudonym> Did you want that function to return String or [String]?
18:34:41 <zealman> [String]
18:34:54 <Pseudonym> Then go back to ToyList2 and change it.
18:35:14 * Pseudonym thought you'd done that
18:35:35 <zealman> so my output would be [["bah", "bah"]] isn't that type [[Char]]
18:35:43 <zealman> no sheep jokes either
18:35:47 <Riastradh> No, it's [[String]].
18:35:53 <Riastradh> Or [[[Char]]].
18:36:13 <Pseudonym> zealman, here's some general advice.
18:36:19 <Riastradh> [['a', 'b']] would be [[Char]], which would be the same as ["ab"] and which has the type [String].
18:36:19 <Pseudonym> Write your type signature first.
18:36:29 <Pseudonym> Decide what type you think your function _should_ be.
18:36:31 <Pseudonym> Then write the code.
18:36:37 <zealman> in that case i want to return a String
18:36:46 <Pseudonym> That way, if something is wrong, you get better bessages.
18:37:02 <Pseudonym> In this case, if you want ["foo","bar"], then you want the type [String].
18:37:04 <Pseudonym> So write that.
18:37:10 <Pseudonym> No matter what you think you'll actually get.
18:38:40 <zealman> whats a [["sdf"],["sdf"]]
18:38:50 <zealman> [[[Char]]]
18:38:51 <zealman> ?
18:39:01 <Pseudonym> Here's a suggestion.  You're using hugs, right?
18:39:06 <zealman> yep
18:39:13 <Pseudonym> Then type:
18:39:21 <Pseudonym> :t [["sdf"],["sdf"]]
18:39:39 <Pseudonym> :t is very handy
18:40:47 <zealman> aye
18:40:49 <zealman> it is
18:49:27 <zealman> @prelude repeat
18:49:28 <lambdabot> *** "repeat" prelude "Haskell Standard Prelude Dictionary": text follows
18:49:28 <lambdabot> repeat
18:49:28 <lambdabot>   repeat ::  a -> [a]
18:49:28 <lambdabot>   repeat x          = xs where xs = x:xs
