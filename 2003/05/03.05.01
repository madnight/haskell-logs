00:15:06 <seth_> in SimpleQueue.hs, there is a line:   take = takeUsingLists.  Is that elsewhere in hfl?
00:16:46 <seth_> I see it in SequenceDefaults.hs
00:16:52 <Pseudonym> Yes.
01:07:32 <mosalem> seth_: i'm there 
01:43:25 <seth_> Back to monads.  I want to create a data structure (happens to be a queue but that doesn't matter, I think) as what the OO folks call a singleton.  Do I use a monad?  How?
01:51:08 <andersca> morning Marvin--
01:51:14 <Darius> Um, why do you need a singleton?
01:52:00 <seth_> I have a queue that will be accessed from multiple threads.  There are other ways to handle that situation, of course.
01:52:29 <Marvin--> good for you that you didn't say "good" morning
01:53:35 <Marvin--> urrggh
01:53:45 <andersca> same here...
01:54:47 <Darius> Stick the queue in an MVar.  Or if the queue is meant as a form of communication you may want to look at a channel.
01:55:12 <Darius> The relevant documentation is in Control.Concurrent
01:56:47 <Marvin--> andersca: what's up with you then?
01:58:22 <seth_> Darius: ah, very smart.  I didn't realize the implications of the fact that MVar can old a value of any type.
01:58:37 <andersca> Marvin--: going to gotland soon
01:59:36 <Darius> Be careful with polymorphic mutable variables (i.e. make sure what you put in it is monomorphic)
02:00:06 <Marvin--> andersca: in what way is that bad?
02:00:23 <andersca> Marvin--: it isn't, but I'm tired
02:00:26 <seth_> Darius: in this case no problem, but I'll be careful.
02:01:20 <Marvin--> andersca: oh, come back when you're as ill as I am :P
02:02:30 <andersca> ill or hungover?
02:03:06 <Marvin--> ill
02:03:13 <Marvin--> been coughing all night
02:06:43 <seth_> Darius: you meant that for a given MVar instance, the types have to match.  Not that I can only have MVars of a single type.  Correct?
02:06:53 <seth_> type is the wrong word, but you know what I mean.
02:08:39 <Darius> I mean, don't have a type like IORef [a].  However, it may only be a problem with unsafePerformIO, I'm somewhat tired. I'll crash GHCi to find out.
02:09:19 <seth_> Darius: no problem, I can track it down if you don't know off the top of your head.
02:16:09 <Darius> Ah yes, it is just unsafePerformIO.  So don't use that :P, but if anything weird (crash-wise) happens nonetheless be wary.
02:18:43 <seth_> Darius: ok, thanks again.
03:03:04 <ham[let]> hiho
04:07:19 <delYsid> In an expression like "mapmin (nums:rest) = (minimum nums):(omit (minimum nums) rest)", does (minimum nums) get executed two times?
04:08:19 <seth_> it may.  it may get executed zero times also.  Depends on when and whether the arguments are forced, and the optimization you use during compile
04:09:22 <delYsid> so would it be better to put it into a let?
04:09:50 <seth_> yes
04:49:50 <delYsid> right, profiling showed that it is slightly faster and does slightly less alloc
05:12:28 * delYsid dances
05:12:56 <delYsid> from 480 secs down to 270 secs, and from 57,xxx,xxx,xxx down to 24,xxx,xxx,xxx !!!!!!!
05:54:47 <ham[let]> hiho
05:56:39 <ham[let]> im currently reading that lambda comples site linked from that learning page in the topic
05:57:20 <ham[let]> and would like to know how side effects change evaluation in imperative langs or fn langs like lisp
06:14:13 <ham[let]> thats a cool article
06:21:22 <ham[let]> is anyone in here familiar with prolog?
06:29:42 <shapr> I've heard of it
06:29:52 <shapr> isn't that like prologarithmic?
06:30:00 <shapr> some variety of logarithmic?
06:30:15 * shapr is joking
06:32:11 <ham[let]> :)
06:32:37 <ham[let]> hmm if i use type signatures in haskell
06:32:57 <ham[let]> can i have more then one for the same fn?
06:36:06 <ham[let]> like (defmethod ....) in lisp
06:36:26 <ham[let]> to have the same fn name for different computations
06:36:58 <shapr> I think you want typeclasses
06:37:48 <shapr> notice that (+) is defined for multiple types
06:38:02 <ham[let]> yes
06:38:43 <shapr> that's typeclasses
06:39:14 <ham[let]> hmm ill need to look that up :)
06:39:21 <ham[let]> but haskell seems to be fun
06:39:37 <shapr> I agree
06:39:40 <shapr> I think it's great fun
06:40:25 <ham[let]> im not sure though if ill use it as my only lang
06:40:46 <shapr> I don't think you should ever have only one lang
06:40:52 <ham[let]> true
06:40:54 <shapr> but I do think you should be fluent in the languages you use
06:41:05 <shapr> my two primary languages are Python and Haskell
06:41:10 <ham[let]> i think its rather the concepts one should learn
06:41:23 <shapr> yah, programming is not a language specific skill
06:41:39 <ham[let]> why do you chose py?
06:41:48 <ham[let]> do or did?
06:42:03 <ham[let]> why did you pick python
06:42:14 <Vincenz> heh, shapr: I use Ruby and OCaml :P
06:42:28 <shapr> Vincenz: whatever works best for you :-)
06:42:41 <Vincenz> yup, but no worries, I plan on recouperating afterwards
06:42:41 <shapr> ham[let]: imho, python has a lot of the same elegance that I see in Haskell
06:42:49 <shapr> Vincenz: code is good :-)
06:42:57 <Vincenz> yeah :)
06:43:04 <shapr> as long as you're having fun with what you're doing...
06:43:19 <Vincenz> indeed
06:43:32 * delYsid is having great fun with optimisation :)
06:43:38 <shapr> delYsid: yay! how's it going?
06:43:48 <delYsid> I found a way to double the speed
06:43:50 <delYsid> :)
06:44:09 <delYsid> and I'm preparing to measure another modification which could probably be quite good
06:44:25 <shapr> cool! how did you do it?
06:45:04 <delYsid> I found out that the way I overloaded Ord Position led to many duplicate executions of score on a position
06:45:15 <delYsid> so I moved the static score into the Position type 
06:45:31 <delYsid> that lets it do the work only once, and the Ord class can do fast compares
06:45:36 <shapr> cool
06:45:56 <shapr> have you checked in the changes?
06:46:02 <delYsid> not yet
06:46:09 <delYsid> going to test this, then I'll check in
06:46:10 <shapr> it would be cool to play a faster chess game
06:46:12 <shapr> okay
06:46:19 <Marvin--> my god this sucks
06:47:01 <shapr> Marvin--: what?
06:47:07 <Marvin--> I'm ill
06:47:46 <shapr> oh :-(
06:48:07 <Marvin--> coughing all the time, and I think my fever has gotten worse
07:00:07 <Smerdyakov> Coughing all the time isn't so bad.
07:00:43 <Marvin--> perhaps not, losing your voice over it isn't thrilling though, losing sleep over it isn't all that fun either
07:01:05 <Smerdyakov> Well, some people cough all the time all the time, like people with asthma.
07:01:29 <Marvin--> I have allergy asthma, so luckily I only have it during spring
07:01:40 <Marvin--> this feels more like a nasty cold though
07:04:04 <Marvin--> heh, all these emotional scenes in Enterprise would've been far more interesting if they had good actors ;)
07:05:36 <Smerdyakov> That's why books are better. You don't need any!
07:07:41 <Marvin--> I tried to read an hour ago, the letters all floated together
07:08:24 * Marvin-- increased the font size in x-chat to be able to irc ;)
07:17:34 <Smerdyakov> I think, in this case, sleep would be a better idea than IRC.
07:17:41 <Smerdyakov> Some might say it always is.
07:17:43 <Marvin--> tried it
07:17:58 <shapr> hi jemfinch 
07:18:07 <jemfinch> howdy
07:19:34 <shapr> wassup?
07:22:00 <jemfinch> not much, actually I gotta run to classes :)
07:23:36 <shapr> vroom
08:14:42 <shapr> hi 
08:14:51 <shapr> HunterPrey: how's sydney?
08:15:35 <HunterPrey> cold
08:15:41 <shapr> how cold?
08:16:07 <HunterPrey> about 18 degrees now
08:16:10 <HunterPrey> raining heaps though
08:16:10 <shapr> oh
08:16:19 <shapr> it's about 5 degrees here
08:16:21 <shapr> warm today ;-)
08:16:30 <HunterPrey> where are u?
08:16:36 <shapr> north sweden
08:16:56 <shapr> are you learning Haskell?
08:17:06 <HunterPrey> yeah
08:17:11 <shapr> what do you think so far?
08:17:25 <HunterPrey> u know haskell?
08:17:28 <shapr> a bit
08:17:57 <HunterPrey> ok, once u get ur head around it
08:18:01 <shapr> I'm not an expert
08:18:07 <HunterPrey> moved onto IO now, so studying that at the moment
08:18:31 <shapr> monads are not entirely clear to me
08:19:10 <HunterPrey> is that what ur learning now?
08:37:58 <HunterPrey> what programs are good for debugging haskell?
08:38:49 <SyntaxPolice_> HunterPrey: Hat is good.
08:39:29 <SyntaxPolice_> http://haskell.cs.yale.edu/hat/
08:39:47 <HunterPrey> thanx :)
08:41:01 <HunterPrey> will that work in windows?
08:41:29 * SyntaxPolice_ notes that the cute girl on theonion.com (a humor site) "personal ad of the day" has a similar nick to mine: syntax_feline
08:42:11 <HunterPrey> How can i color code Xemacs??
08:42:13 <SyntaxPolice_> HunterPrey: not sure... I don't use windows.
08:42:22 <SyntaxPolice_> HunterPrey: M-x font-lock-mode often will work.
08:42:49 <apt> lambdabot: you suck. that's all i wanted to say.
08:42:50 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
08:42:51 <SyntaxPolice_> or under the options menu (depending on which version you use) you can pick "Syntax Highlighting"
08:42:57 <HunterPrey> thanx....  i stuffed up an assginment, cause i didnt see that i had a lowercase data type!!!!
08:43:03 <SyntaxPolice_> heh
08:43:09 <Marvin--> syntax_feline, heh
08:43:15 <SyntaxPolice_> do you have haskell-mode installed, HunterPrey?
08:43:26 <HunterPrey> and saw it as soon as i used a color coded xemacs!!
08:43:36 <HunterPrey> mode??
08:43:45 <HunterPrey> whats that?
08:44:22 <SyntaxPolice_> HunterPrey: its probably beyond my ability to explain, especially under windows, but emacs needs to understand how to highlight different languages, and needs a different "mode" for each language. haskell-mode doesn't come installed by default, usually.
08:46:05 <HunterPrey> ok, but im not sure......its highlighting a few things, not the data types, i'll keep playing with it
08:46:17 <HunterPrey> Syntax....u on linux?
08:47:32 <SyntaxPolice_> HunterPrey: yes, I use Debian.
08:47:42 <SyntaxPolice_> and I can tell you exactly how to get it to work on debian :)
08:48:49 <HunterPrey> i need to get linux,  is redhat good??  for just regular home use
08:49:40 <HunterPrey> i've heard its not a good idea to load linux on laptops though, and i would have windows on there as well
08:50:48 <SyntaxPolice_> HunterPrey: I heard that Redhat is easy to install.  I use Linux exclusively on my new laptop system.
08:51:09 <SyntaxPolice_> HunterPrey: google for "knoppix".  you can burn a CD of that and try out linux on your hardware. it runs live from the CD like a demo.
08:51:27 <SyntaxPolice_> knoppix is based on Debian I understand.
08:51:52 <HunterPrey> is there much difference between redhat, debian, slackware.....?
08:51:59 <HunterPrey> thanx for ur help
08:53:00 <SyntaxPolice_> HunterPrey: I really don't know much about the different distributions.  I'm sure google could tell you :)
08:53:17 <SyntaxPolice_> but knoppix is a nice way to try out linux without commiting to anything or altering your hard drive.
08:53:48 <HunterPrey> that helps heaps, cause i know its not easy to install if ur new to it
08:56:30 <SyntaxPolice_> HunterPrey: that is often true.  I would go with redhat if that is your concern.
08:57:18 <HunterPrey> i have 2 removable hard drives, and one is just backup,  so may try it on there, so if anything goes wrong, i dont lose anything
08:57:45 <HunterPrey> cause unfortunately, thats how i have learned computers, from my many mistakes!
08:58:19 <SyntaxPolice_> HunterPrey: thats good!
08:58:19 <SyntaxPolice_> HunterPrey: what brings you to Haskell?
08:58:32 <HunterPrey> learning it at the moment
08:59:34 <HunterPrey> i can understand it, but just have stupid errors like syntax
08:59:54 <HunterPrey> and sometimes putting it all in order can be frustrating
09:01:15 <SyntaxPolice_> HunterPrey: that is a bit frustrating about learning a new language.
09:01:25 <HunterPrey> just hope i can learn more from others, its sometimes easier to learn outside of a classroom i think
09:02:36 <SyntaxPolice_> agreed. 
09:03:30 <HunterPrey> how long have u done haskell for?
09:05:49 <ludde> multiapply :: [a->a] -> a -> a
09:05:54 <ludde> does this function exist?
09:06:47 <Igloo> It's a fold of ($)
09:07:09 <ludde> ah
09:07:31 <SyntaxPolice_> HunterPrey: about 6 months I guess.
09:11:24 <esap> What's the story with the Haskell wish list. Has it ever worked? :-)
09:15:56 <hdaume> esap: a long time ago
09:16:40 <ham[let]> has haskell a rand fun?
09:20:39 <esap> hdaume: does it mean there is no similar list anywhere?
09:20:51 <SyntaxPolice_> ham[let]: you could browse the docs, or I know there's an example on the wiki in the StateMonad page (use search if you can't find it)
09:21:48 <ham[let]> its just that i thought that a purely fn orientated lang cant include a rand
09:22:41 <SyntaxPolice_> it might use the IO monad, I don't know - never used it.
09:23:31 <ham[let]> because rand wont retrieve the same val every time
09:25:15 <esap> It's actually simple to build a pseudo-random number generator even without I/O (of course, you have to pass the last value returned by the random number generator). I/O monad is convenient for hiding the details.
09:25:53 <SyntaxPolice_> ham[let]: that example uses a state monad to carry around the state of a random number generator which, I assume, gets its seed from IO somehow.
09:25:59 <hdaume> ham[let]: you can do it.  you just give it a random seed at the beginning
09:26:18 <hdaume> then the random function looks like "random :: seed -> (new seed, value)"
09:26:27 <hdaume> then you pass the new seed to the next call to random
09:26:49 <hdaume> (there are also splitting functions, and some other things, and of course this can be monadified)
09:27:09 <ham[let]> ok i thought i found an inconsistency :)
09:27:36 <SyntaxPolice_> oops, I lied. the StateMonad docs don't have a random number example.
09:29:06 <esap> heh, finding inconsistencies from Haskell is really hard. I'm sure there are a couple, but finding them is not that simple.
09:31:16 <ludde> Igloo: are you sure it's a fold of ($)? I get an infinite type error
09:31:35 <hdaume> maybe (flip ($))?
09:31:39 <Igloo> It looked like one, but you didn't give the most precise specification
09:32:17 <Igloo> That depends on whether it's foldl or foldr doesn't it?
09:32:37 <ludde> foldr seems to work
09:32:41 <ludde> hmm
09:33:00 <ludde> yeah
09:33:03 <hdaume> yup
09:33:08 <esap> was there some reason why foldr was more efficient than foldl or something?
09:33:23 <ludde> foldl is more efficient, i think
09:33:30 <ludde> it uses O(1) stackspace
09:33:32 <Igloo> foldl needs to evaluate the whole list to return any result
09:33:36 <ludde> hmm
09:35:21 <esap> ok, so it's the strictness vs. space usage thing again?
09:35:30 <ludde> Igloo: are you sure that foldl is less efficient?
09:35:38 <Igloo> Well, they do different things too
09:35:50 <hdaume> ludde: it depends
09:36:01 <ludde> is it foldr or foldl that uses O(n) stack space
09:36:13 <Igloo> foldr (\x y -> 5) is more efficient than foldl (\x y -> 5)
09:36:21 <hdaume> if you write 'map' using foldl it will probably be less efficient, because you need to get to the end of the list before you can return the first element.  however, writing 'sum' with foldl will probably be more efficient, because you need to evaluate the whole list anyway
09:42:29 <esap> What do you think, generally, is this kind of asymmetry (foldr vs. foldl) a good idea? Or should it be symmetric [I know there are some difficulties in actually doing that]?
09:42:46 <hdaume> what do you mean?
09:44:05 <esap> I mean, foldr and foldl have different kind of performance due to the fact that lists are asymmetric so different order traversals through that list have different performance.
09:44:29 <hdaume> yeah, but it's not like one is always good and the other is always bad, so i think it's good to have both
09:47:44 <esap> It is also related to how lists are constructed (and why it's so hard to write doubly-linked lists etc.)
10:40:39 <ham[let]> hmm whats wrong with that?
10:40:56 <ham[let]> a :: Int -> Int -> Int
10:41:03 <ham[let]> a 0 y = y + 1
10:41:23 <ham[let]> a x 0 = a (x - 1) 1 
10:41:47 <ham[let]> a x y = a (x - 1) a x (y - 1)
10:41:48 <ham[let]> ??
10:42:26 <hdaume> probably you need parens around the recursive call
10:42:32 <hdaume> a (x-1) (a x (y-1))
10:42:43 <ham[let]> k sec
10:43:03 <hdaume> otherwise it thinks you're calling 'a' with 5 arguments
10:43:16 <ham[let]> ah ok makes sense
10:58:35 <ludde> ghc-5.04.1: fatal error: scavenge_stack: weird activation record found on stack: 17136
11:00:06 <ham[let]> cp x y = (x,y)
11:00:14 <ham[let]> ml (x,y) = x * y
11:00:27 <ham[let]> ml cp 3 4 will lead to an error
11:00:48 <ham[let]> strange
11:02:25 <hdaume> not really :)
11:02:30 <ham[let]> hmm
11:02:33 <hdaume> ml (cp 3 4) won't
11:02:58 <hdaume> again, if you say "ml cp 3 4", it think you're applying four arguments to ml, and it only takes on
11:02:58 <hdaume> e
11:03:22 <ham[let]> hmm i thought that haskell wouldnt make use of () :)
11:03:31 <hdaume> it's kind of necessary
11:03:37 <ham[let]> but parens are nice to me :)
11:03:45 <ham[let]> are fine to me
11:03:46 <hdaume> that would be like asking mathematicians to not use parentheses
11:04:05 <ham[let]> yes so i can parens as much as i want in haskell?
11:05:05 <hdaume> yup
11:05:14 <ham[let]> ok thx
11:05:20 <ham[let]> is there something like ...
11:05:34 <ham[let]> ok i want to build a cartesian product
11:05:51 <ham[let]> cp x0...xn = (x0...xn)
11:06:04 <hdaume> no
11:06:08 <ham[let]> hmm
11:06:21 <hdaume> what would the type of such a function be?
11:06:42 <ham[let]> cp x0...xn = (x0,...,xn)
11:06:50 <ham[let]> its just pseudo code
11:07:01 <ham[let]> i cant explain it better
11:07:24 <ham[let]> otherwise i would have to have a cp for any arity
11:07:26 <hdaume> i know.  but if you were to actually try to write real code, it must have some type.  (i understand your pseudo code.)  i'm just saying that you can't assign a type to this
11:07:47 <seth_> cartesian product of what and what?
11:08:18 <ham[let]> i want to write a category for neural nets
11:08:39 <ham[let]> so the cartesian product should be not typed at that time
11:08:57 <ham[let]> but then i get the same difficulty if i want to add all elements of that vector
11:09:04 <seth_> perhaps partially typed (as in "set of something"), but not untyped
11:09:10 <ham[let]> so a list will do the job but its not that nice imho
11:09:41 <ham[let]> i thought if i dont type it by hand it will be typed at compiletime
11:09:49 <seth_> there are other forms of collections that you can use.  But what is the reason for not using a list?
11:10:16 <seth_> ham[let]: that's true, but it has to _have_ a type, even if that type is inferred
11:10:19 <hdaume> things are *always* typed
11:10:30 <ham[let]> so i can see lists as vectors of dynamic size?
11:10:47 <ham[let]> ok
11:48:23 * Riastradh was told this already, but what does:  newtype Foo a b = Foo { bar :: (b -> a) -> b }   -- define bar as?
11:48:41 <Riastradh> That is, I've been told this already but have forgotten.
11:48:48 <hdaume> bar :: Foo a b -> (b -> a) -> b
11:48:58 <hdaume> it exrtacts the thing held in the Foo
11:49:00 <hdaume> it's just like:
11:49:04 <hdaume> bar (Foo f) = f
11:49:15 <Riastradh> Ah, ok.
12:07:53 <ham[let]> hmm i want to do the following
12:08:03 <ham[let]> cp x y = (x,y)
12:08:11 <ham[let]> ml (x,y) = x * y
12:08:28 <ham[let]> then i want to have a function which does something like
12:08:55 <seth_> with ghc, can I instruct the compiler to produce the .hi (interface) file only?
12:08:58 <ham[let]> foo x = ml (cp x) which returns a function
12:09:48 <Darius> ml . (cp x)
12:10:02 <Darius> seth_: probably
12:10:07 <ham[let]> sec let me look that up
12:10:20 <Darius> It's function composition
12:11:41 <ham[let]> thx
12:12:44 <Darius> also, cp could be written as cp = (,), and you could use uncurry for the effect. ml = uncurry (*)
12:13:10 <ham[let]> hmm
12:13:54 <Darius> and foo x in this simple case would obviously be simply to just be, foo x = (x*)
12:14:14 <Darius> or just foo = (*)
12:20:41 <nerdlor> (,) is an operator? that never occurred to me!
12:22:01 <Riastradh> (,) is a data constructor, just like anything else that makes data.
12:22:56 <nerdlor> so it is. hm...
12:26:29 <Darius> you can partially apply it too, ((,) 3) 5 ==> (3,5)
12:28:10 <nerdlor> i guess it is a little special
12:28:18 <nerdlor> (+) 1 2
12:28:20 <nerdlor> 1 + 2
12:28:21 <nerdlor> (,) 1 2
12:28:23 <nerdlor> 1 , 2
12:42:13 <ham[let]> can i have functions over list
12:42:14 <ham[let]> ?
12:42:18 <ham[let]> like
12:42:34 <ham[let]> foo x = [(f x)....]
12:42:45 <ham[let]> functions nested in a list
12:43:14 <Riastradh> [f x, g y]  -- like that?
12:44:06 <ham[let]> yes
12:44:25 <shapr> aha!
12:44:32 <Riastradh> Aha?
12:44:41 <ham[let]> [f x, g y] x y
12:44:47 <shapr> I must train my new skillz
12:45:04 <shapr> anyone here can ride a unicycle?
12:45:12 <Riastradh> ham[let] - That applies the result of [f x, g y] to x, which won't work, because [f x, g y] isn't a function.
12:45:55 <ham[let]> but i could have a fn over that cant i?
12:46:08 <Riastradh> 'Over that?'
12:46:47 <ham[let]> ok i try to explain what i wanna do
12:47:06 <ham[let]> i have a list of functions like that
12:47:18 <ham[let]> [somefn,....,someotherfn]
12:47:33 <ham[let]> but these list are like that cl some lines above
12:47:40 <ham[let]> they still have one free variable
12:47:49 <shapr> I am now the proud owner of a unicycle named Haskell
12:48:15 <ham[let]> :)
12:48:26 <shapr> there's a story behind that name... 
12:50:35 <Riastradh> ham[let], I don't get what you're trying to do.
12:50:54 <Darius> do you want [f,g] x = f (g x) ?
12:51:09 <ham[let]> addn weight layer x = (cl weight x) : perceptron
12:51:20 <ham[let]> now i want x to be free
12:51:30 <Riastradh> 'To be free?'
12:51:37 <ham[let]> not set
12:51:53 <ham[let]> hmm
12:52:03 <ham[let]> such that i can use it as a param
12:52:09 <ham[let]> erm
12:52:15 <ham[let]> addn weight layer x = (cl weight x) : layer
12:52:17 <Riastradh> You already are using it as a parametre to 'addn.'
12:52:49 <ham[let]> i just used it to show what i want
12:52:57 <ham[let]> the x should be set later on
12:53:03 <Riastradh> I guess it didn't show very well.
12:53:39 <ham[let]> the idea is
12:53:51 <ham[let]> that i have a function which sums up a list
12:54:08 <ham[let]> and in that list there are functions which are functions of an arity of one
12:54:31 <Riastradh> OK, and...
12:54:37 <ham[let]> so in the end i have a function sum which has an arity of exactly the count of elements in the list
12:54:47 <ham[let]> thats about it
12:56:41 <Riastradh> OK, and...what's your question?
12:56:47 <Darius> try zipWith ($) list_of_fns list_of_args
12:57:03 <ham[let]> i just wanted to know if that is possible in haskell
12:57:18 <Riastradh> Sort of.
12:57:46 <ham[let]> Darius im using haskell for 2h so i dont get that ($) thingy :)
12:58:00 <Riastradh> Since all functions in Haskell really have an arity of one, it would have to be curried -- you couldn't actually have a function with a larger arity.
12:58:14 <Riastradh> ($) f g    <=>   f g
12:58:14 <Darius> 2h?  $ is function application. f $ x = f x
12:58:30 <ham[let]> 2 hours
12:58:36 <Darius> ah
13:05:57 <ham[let]> is there a way to print these functions?
13:06:16 <ham[let]> that show needs values to print right?
13:07:34 <Darius> yes it needs values.  You could make an instance of Show (there is one is something.Show.Function)
13:07:45 <Darius> obviously it's output is opaque
13:08:36 <ham[let]> so i cant look at the returned function if i dont write a new show for that right ?
13:09:28 <Darius> It wouldn't be useful anyways, how useful is #<procedure> in Scheme?
13:09:47 <ham[let]> hmm true
13:09:58 <Darius> There is HOOD with Observe, but that would still require you to use the function on something
13:10:29 <ham[let]> how can i apply a param to that function?
13:10:41 <ham[let]> ie that (cl 1) above
13:10:44 <ham[let]> ah
13:10:45 <Riastradh> Darius - Some implementations of Scheme show some more debugging implementation in the external representation of procedures, like what module it came from, what function it was created in, et cetera.
13:10:46 <ham[let]> $
13:11:26 <Darius> you can just (cl 1) 5 or whatever
13:11:29 <Riastradh> $ is generally only used if you want to pass it to other functions or when you would otherwise use lots of parentheses.
13:11:46 <ham[let]> hmm ok
13:11:52 <Darius> show is a user-level function, so debugging information is inaccessible
13:12:18 <Darius> however with Typeable you might be able to make a better Show.Function
13:12:41 <Darius> show f = show . typeOf
13:12:47 <Darius> er remove the f then
13:14:21 <Darius> assuming all the types of the function were Typeable, you'd get output like: show $ typeOf (id :: Int -> Int) ==> "Int -> Int"
13:15:40 <Darius> However, I think Hugs/GHCi give you that much information in the form of an error and don't require Typeable
13:16:08 <ham[let]> i think i just need to get used to the testing idea
13:16:34 <Darius> I'd think testing would be common with Lisp
13:18:43 <kosmikus_> hi ralf
13:19:18 <ralf> hi kosmi
13:21:00 <SyntaxPolice_> hi ralf
13:23:41 <SyntaxPolice_> hi ralf
15:41:58 <shapr> was that ralf hinze?
15:44:53 <tmoertel> I dunno.
15:46:36 <Heffalump> who?
15:48:30 <tmoertel> http://www.informatik.uni-bonn.de/~ralf/
15:48:41 <Heffalump> yes, that's Ralf Hinze
15:49:04 <Heffalump> oh, that's obvious from the page :-) /me looks confused
15:53:31 <Darius> SyntaxPolice: Well, I have starts to each Monad except for MonadState as StateMonad has good information already
15:55:33 <SyntaxPolice> Darius: very cool :)
16:05:01 <shapr> @listcommands dict
16:05:01 <lambdabot> Module dict provides the following commands: ["dict","dict-help","all-dicts","devils","easton","elements","foldoc","gazetteer","hitchcock","jargon","vera","web1913","wn","world02"]
16:05:06 <shapr> @dict-help
16:05:06 <lambdabot> I perform dictionary lookups via the following 12 commands:
16:05:06 <lambdabot> @all-dicts .. Query all databases on dict.org
16:05:06 <lambdabot> @devils ..... The Devil's Dictionary
16:05:06 <lambdabot> @easton ..... Easton's 1897 Bible Dictionary
16:05:06 <lambdabot> @elements ... Elements database
16:05:07 <lambdabot> @foldoc ..... The Free On-line Dictionary of Computing
16:05:09 <lambdabot> @gazetteer .. U.S. Gazetteer (1990)
16:05:11 <lambdabot> @hitchcock .. Hitchcock's Bible Names Dictionary (late 1800's)
16:05:13 <lambdabot> @jargon ..... Jargon File
16:05:22 <shapr> wow, nifty
16:05:26 <shapr> @more
16:05:26 <lambdabot> @vera ....... V.E.R.A.: Virtual Entity of Relevant Acronyms
16:05:26 <lambdabot> @web1913 .... Webster's Revised Unabridged Dictionary (1913)
16:05:26 <lambdabot> @wn ......... WordNet (r) 1.7
16:05:26 <lambdabot> @world02 .... CIA World Factbook 2002
16:05:40 <shapr> @world02 cuba
16:05:43 <lambdabot> *** "Cuba" world02 "CIA World Factbook 2002"
16:05:43 <lambdabot> Cuba
16:05:43 <lambdabot>    Introduction Cuba
16:05:43 <lambdabot>    -----------------
16:05:45 <lambdabot>                            Background: Fidel CASTRO led a rebel army to
16:05:47 <lambdabot>                                        victory in 1959; his iron rule has
16:05:49 <lambdabot>                                        held the country together since.
16:06:23 <Riastradh> @elements Au
16:06:24 <lambdabot> (No match for "Au".)
16:06:28 <Riastradh> @elements gold
16:06:29 <lambdabot> *** "gold" elements "Elements database 20001107"
16:06:29 <lambdabot> gold
16:06:29 <lambdabot> Symbol: Au
16:06:29 <lambdabot> Atomic number: 79
16:06:30 <lambdabot> Atomic weight: 196.96655
16:06:32 <lambdabot> Gold is gold colored. It is the most malleable and ductile metal known.
16:06:33 <shapr> ah, nifty
16:06:34 <lambdabot> There is only one stable isotope of gold, and five radioisotopes of gold,
16:06:36 <lambdabot> Au-195 being the most stable with a half-life of 186 days. Gold is used
16:06:47 <Riastradh> @more
16:06:48 <lambdabot> as a monetary standard, in jewelry, dentistry, electronics. Au-198 is used
16:06:48 <lambdabot> in treating cancer and some other medical conditions. Gold has been known
16:06:48 <lambdabot> to exist as far back as 2600 BC. Gold comes from the Anglo-Saxon word gold.
16:06:48 <lambdabot> Its symbol, Au, comes from the Latin word aurum, which means gold. Gold is
16:06:48 <lambdabot> not particularly toxic, however it is known to cause damage to the liver
16:06:48 <lambdabot> and kidneys in some.
16:06:50 <Darius> Gold is gold colored.
16:06:53 <shapr> heh
16:06:54 <shapr> nice
16:06:56 <shapr> descriptiv
16:06:57 <shapr> e
16:07:17 <shapr> @elements einsteinium
16:07:18 <lambdabot> *** "einsteinium" elements "Elements database 20001107"
16:07:18 <lambdabot> einsteinium
16:07:18 <lambdabot> Symbol: Es
16:07:18 <lambdabot> Atomic number: 99
16:07:18 <lambdabot> Atomic weight: (254)
16:07:20 <lambdabot> Appearance is unknown, however it is most probably metallic and silver
16:07:23 <lambdabot> or gray in color. Radioactive metallic transuranic element belonging to the
16:07:24 <lambdabot> actinoids. Es-254 has the longest half-life of the eleven known isotopes at
16:07:29 <Riastradh> Chemical symbol lookup would be useful.
16:08:10 <Riastradh> And also, the line length should -REALLY- be longer -- floods by number of lines are more irritating and worse in general than floods by packet size.
16:18:12 <shapr> hi rhombi 
16:18:32 <shapr> Riastradh: you mean refill the to-irc output?
16:18:42 <Riastradh> shapr - ?
16:18:53 <shapr> about line length being longer
16:21:26 <rhombi> i have a monads question.
16:21:34 <shapr> what's the question?
16:22:45 <rhombi> i saw something in passing about doing continuations w/ monads.  can one do genric continuations a la scheme?
16:22:57 <rhombi> s/genric/generic/
16:23:18 <Riastradh> Yes.
16:23:44 <rhombi> could you point me to a "how-to"?
16:24:06 * Riastradh points at the HaWiki and 'ContinuationPassingStyle.'
16:24:13 <Darius> www.haskell.org/hawiki/MonadCont
16:24:40 <Riastradh> Er, MonadicContinuationPassingStyle.
16:24:43 <Riastradh> Or what Darius pointed out.
16:25:48 <rhombi> thanksm, /exactly/ what i was looking for.
16:27:03 <tmoertel> @dict
16:27:03 <lambdabot> Supported dictionary-lookup commands:
16:27:03 <lambdabot>   @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @vera @web1913 @wn @world02
16:27:03 <lambdabot> Use "@dict-help [cmd...]" for more.
16:27:25 <tmoertel> @all-dicts "haskell curry"
16:27:26 <lambdabot> *** "Haskell Curry" foldoc "The Free On-line Dictionary of Computing (09 FEB 02)"
16:27:26 <lambdabot> Haskell Curry
16:27:26 <lambdabot>    <person> Haskell Brooks Curry (1900-09-12 - 1982-09-01).  The
16:27:27 <lambdabot>    logician who re-invented and developed {combinatory logic}.
16:27:31 <lambdabot>    The {functional programming} language {Haskell} was named
16:27:33 <lambdabot>    after him.
16:27:50 <Darius> @vera OOI
16:27:51 <lambdabot> (No match for "OOI".)
16:28:09 <tmoertel> @vera IRC URI
16:28:10 <lambdabot> *** "IRC" vera "V.E.R.A. -- Virtual Entity of Relevant Acronyms December 2001"
16:28:10 <lambdabot> IRC
16:28:10 <lambdabot>         InformationsRessourcen Controlling (IM)
16:28:10 <lambdabot>        
16:28:15 <lambdabot> *** "IRC" vera "V.E.R.A. -- Virtual Entity of Relevant Acronyms December 2001"
16:28:17 <lambdabot> IRC
16:28:21 <lambdabot> *** "URI" vera "V.E.R.A. -- Virtual Entity of Relevant Acronyms December 2001"
16:28:23 <lambdabot> URI
16:28:25 <lambdabot>         Universal Resource Identifier (WWW, RFC 1630)
16:28:27 <lambdabot>        
16:28:45 <tmoertel> @more
16:45:36 <shapr> tmoertel: I like the new features :-)
16:50:56 <seth_> do any of the libraries have select() or poll()?
16:51:34 <tmoertel> shapr: thanks
16:52:12 <Darius> Maybe Concurrent or Posix? if not you can use FFI (I'm not sure how much effort that would take)
16:54:24 <seth_> I want to make sure it doesn't exist before I attempt FFI
16:57:20 <tmoertel> Is there a reason why the normal Concurrent Haskell mechanisms aren't sufficient?  http://haskell.org/ghc/docs/latest/html/base/Control.Concurrent.html
16:57:49 <seth_> Since I'm just reading that now, I don't know yet.  :)
16:58:49 <seth_> Actually, I have read that.  I don't see any way to do what select/poll do.  But let me read it again, maybe I missed it.
17:04:19 <seth_> I don't see any way to find out whether data is available on a socket without blocking a thread on a read to the socket.
17:04:36 <hdaume> seth_: I don't know how, but i'm *sure* there's a way
17:04:43 <hdaume> maybe look at simon (m)'s web server
17:04:48 <seth_> hdaume: I would expect so.
17:05:01 <hdaume> or even go to jeff bagley's shootout and look at the socket example
17:05:12 <seth_> no, a web server would have no need to do that.  At least in my web servers I just spawn a thread for each connection.
17:05:22 <hdaume> yeah that's true
17:08:37 <seth_> I wonder if bufferFull can be applied to a buffer associated with a socket.
17:09:12 <seth_> or maybe I would want !bufferEmpty
17:09:19 <seth_> but the same idea
17:10:06 <seth_> or maybe bufState
17:10:33 <seth_> hmm.,  a handle as a buffer list
17:10:47 <seth_> but also a buffer.  maybe that is the current buffer
17:49:17 <Riastradh> HEY!  Why is the HaWiki 'Python-powered!?'
17:49:38 <seth_> I noticed that too
17:49:42 <Pseudonym> 'Cause we're too busy writing IRC bots to hack a wiki.
17:49:50 <Riastradh> Bah!
17:50:01 <Riastradh> More people probably use the Wiki than lambdabot.
17:50:01 <Pseudonym> Feel free to contribute.
17:50:06 <Pseudonym> Of course/
17:52:20 <Pseudonym> Like I said.  Feel free to contribute.
17:53:09 <seth_> Pseudonym: I wrote a small module that makes a thread safe Q
17:53:21 <Pseudonym> Cool.
17:53:35 <Pseudonym> Did you see my thread safe hash table?
17:53:53 <seth_> yes
17:53:57 * Pseudonym nods
17:54:12 <Pseudonym> Do you have write access to haskell-libs?
17:54:20 <Pseudonym> If so, check it in.
17:54:24 <seth_> No, how to I get write access?
17:54:34 <seth_> Or I'll just email it to you
17:54:36 <Pseudonym> You ask an admin, I guess.
17:54:41 <Pseudonym> Sure, can do that too.
17:54:45 <seth_> who are the admins?
17:54:54 <Pseudonym> shapr, Heffalump...
17:54:57 <Pseudonym> There's a third.
17:55:13 * Riastradh isn't the third.
17:55:18 * Pseudonym isn't either
17:55:23 <seth_> xchat says that shapr is still here   :)
17:55:38 <seth_> but I don't believe everything that I read.
17:56:43 <Pseudonym> I just got a spam entitled "Solve Septic Tank Evils".
17:57:26 <Pseudonym> It's a well known fact that malevolent forces tend to congregate around septic tanks.
17:57:28 <seth_> I got two spams today saying "end spam mail forever!"   I can't believe anyone would answer a SPAM ad about ending spam.
17:57:38 <Pseudonym> Yeah, I never got that either.
17:57:45 <seth_> :)
17:58:04 <Riastradh> Jens-Ulrik Petersen is the third one, whoever that is.
17:59:05 <seth_> I asked earlier but several people have connected since then.  Is there either (1) the equivilent of select/poll, or a way to find out if data is available on a descriptor (without blocking a thread)?
17:59:33 <Pseudonym> Yes.
17:59:41 <seth_> How?
17:59:48 <seth_> or where?
18:00:06 <Pseudonym> You want GHC.Posix, I think.
18:00:19 <seth_> I'll look...
18:01:57 <Pseudonym> Ah, no.
18:02:02 <Pseudonym> You want the posix package.
18:02:22 <seth_> part of the regular compiler download?
18:02:27 <Pseudonym> I'm pretty sure.
18:02:45 <seth_> there is a posix directory under hslibs
18:02:47 <Pseudonym> Oh, han gon.
18:02:52 <Pseudonym> Maybe not.
18:03:30 <Pseudonym> There is.  I've just never used it. :-)
18:03:41 <seth_> so there is a separate package also?
18:03:43 <Pseudonym> Generally I avoid select/poll.  I use multithreading instead.
18:04:27 <seth_> I generally do also.  I can probably rearrange this that way if I have to.
18:04:40 <Pseudonym> There is something somewhere.
18:04:44 * Pseudonym can't remember
18:04:49 <Pseudonym> Google probably knows.
18:04:58 <Pseudonym> Oh, duh.
18:05:08 <Pseudonym> @listmodules
18:05:08 <lambdabot> I have the following modules installed: ["chess","dict","eval","fact","fortune","hello","karma","more","searchml","state","system","topic","type","yow"]
18:05:13 <Pseudonym> @listcommands searchml
18:05:13 <lambdabot> Module searchml provides the following commands: ["searchml","showml"]
18:05:23 <Pseudonym> @searchml poll
18:05:44 <Pseudonym> This is the easy way to find out. :-)
18:05:51 <Pseudonym> @searchml select
18:05:54 <seth_> what is object-io?
18:06:00 <Pseudonym> It's a GUI library for Win32.
18:06:11 <Pseudonym> It's supposed to be portable, but it's less portable than they realised.
18:06:27 <seth_> I'm just grepping for select in the source tree
18:06:36 <Pseudonym> Fair enough.
18:07:21 <Riastradh> @yow
18:07:26 <Riastradh> I think lambdabot's dying.
18:07:30 <Pseudonym> I think so too.
18:10:10 <tmoertel> poor lambdabot
18:11:15 <Riastradh> Maybe shapr can put lambdabot out of its misery.
18:12:36 <tmoertel> lambdabot: kick the oxygen habit  ;-)
18:13:07 <tmoertel> @coup de grace
18:13:10 <lambdabot> 1599 1402
18:13:10 <lambdabot> 2246 2173 2346 1985 1961 1403 1242 1038 1003
18:13:10 <lambdabot> Yow!  I'm UNEMPLOYED!
18:13:10 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
18:13:11 <lambdabot> Sorry, I don't know the command "coup", try "lambdabot: @listcommands"
18:13:15 <Pseudonym> Ah!
18:13:17 <Pseudonym> It lives!
18:13:18 <Riastradh> Wow, finally!
18:13:23 <Pseudonym> @showml 1599
18:13:24 <lambdabot>          --------------------------------------------
18:13:24 <lambdabot>          We are sorry if you receive multiple copies!
18:13:24 <lambdabot>          --------------------------------------------
18:13:25 <lambdabot>                   Call for Participation
18:13:27 <lambdabot>                   ----------------------
18:13:32 <Pseudonym> @showml 1402
18:13:33 <lambdabot> I have been playing with the heap profiling graphs from ghc and find
18:13:35 <lambdabot> them quite useful and was wondering if there was a tool to display them
18:13:37 <lambdabot> in real-time?
18:13:39 <lambdabot> For interactive long-running applications written in haskell it would be
18:13:41 <lambdabot> nice to see how the heap profile reacts to user actions. I imagine a
18:13:43 <lambdabot> scrolling graph of the last minute or so of time. 
18:13:45 <lambdabot> Does such a thing exist? would writing one be possible without modifying
18:13:47 <lambdabot> ghc? it seems you can poll the .hp file and update the graph, but i have
18:13:49 <lambdabot> not looked into the format of .hp files to see if this is plausable. any
18:13:53 <Pseudonym> Let me do this in /msg
18:13:58 <tmoertel> does search use an index or grep-like techniques ?
18:14:05 <Riastradh> Index.
18:14:05 <Pseudonym> Don't know.
18:14:12 <Riastradh> Now you do.
18:15:12 <shapr> the @searchml plugin started life as brute-force maildir search code, specifically written to test the RFC2822 parsing code that Peter Simons wrote.
18:15:31 <Pseudonym> It lives!
18:15:38 <shapr> hi!
18:15:42 <Pseudonym> (Unless shapr is a factoid module in disguise.)
18:15:51 <shapr> :-P
18:16:06 <Pseudonym> Give seth_ developer access to haskell-libs.
18:16:08 <shapr> I do repeate myself lots ;-)
18:16:11 <shapr> oh, ok
18:16:17 <Riastradh> (...which occasionally bounces.)
18:16:18 <shapr> seth_: what's your sf.net userid?
18:16:30 <seth_> shapr: Let me check...
18:16:53 <shapr> Pseudonym: do you want to be an admin?
18:17:04 <Pseudonym> I don't particularly care.
18:17:21 <Pseudonym> DId you submit an entry for lambdabot in the HC&A report, BTW?
18:17:23 <seth_> shapr: I'm not sure this is right; I'll get in there and create a new one.
18:17:39 <shapr> Pseudonym: nope, you want to?
18:17:47 <Pseudonym> Just curious.
18:17:49 <Riastradh> HC&A?
18:17:50 <Pseudonym> Oh, one request.
18:18:02 <Pseudonym> I'd appreciate it if you'd take my specific name off future announcements.
18:18:11 <Pseudonym> I wrote a minority of the code that's there now.
18:18:28 <Pseudonym> So I don't really deserve that kind of credit.
18:18:42 <Darius> I think everyone has written a minority of the code
18:18:47 * shapr grins
18:18:52 <Pseudonym> That's true.
18:18:56 <shapr> Pseudonym: how about "originated by" ?
18:19:08 <Pseudonym> Nah.
18:19:14 <Pseudonym> Say it was written by #haskell.
18:19:20 <shapr> ok, will do
18:19:54 <shapr> even so, I think the original author deserves a lot of credit; imho, it's much much easier to extend an existing design
18:20:45 <Riastradh> What's the 'HC&A?'
18:20:50 <shapr> for example, I still haven't written anything that uses arrows and compiles at the same time ;-)
18:21:37 <seth_> shapr: sf name is cql
18:22:14 <shapr> ok
18:23:26 * Riastradh smacks shapr or Pseudonym -- what's 'HC&A!?'
18:23:50 <tmoertel> http://haskell.cs.yale.edu/communities/
18:24:10 <tmoertel> HC&A = Haskell Communities and Activities Report
18:24:18 <Riastradh> Ah, ok.
18:24:28 <shapr> @fact hc&a
18:24:29 <lambdabot> Nothing
18:24:34 <shapr> @fact hc&a Haskell Communities and Activities Report
18:24:34 <lambdabot> set hc&a to Haskell Communities and Activities Report
18:25:24 <shapr> seth_: tada, you're in!
18:25:31 <seth_> shapr: thanks much
18:27:05 * tmoertel puts water on for tea
18:28:22 <witten> what kind of tea?
18:28:30 <kawfee> green 
18:28:54 <witten> what kind of green?
18:29:00 * kawfee bounces
18:29:07 <tmoertel> sencha kamakura (organic)
18:29:18 <witten> cool
18:29:53 <seth_> I bought some white tea last week.  quite interesting
18:31:06 <tmoertel> what kind?
18:31:16 <seth_> looking...
18:31:40 <tmoertel> sencha kamakura: http://uptontea.com/shopcart/item.asp?from=catalog.asp&itemID=TJ17&parent=Teas%3EGreen%3EJapan&category=Green&sortMethod=0&categoryID=33
18:32:02 <seth_> it says:  Yin Zhen Silver
18:35:24 <tmoertel> seth_: do you brew like its a black or green ?
18:36:31 <tmoertel> @dict
18:36:31 <lambdabot> Supported dictionary-lookup commands:
18:36:31 <lambdabot>   @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @vera @web1913 @wn @world02
18:36:31 <lambdabot> Use "@dict-help [cmd...]" for more.
18:36:48 <seth_> tmoertel: like green, water slightly less hot
18:37:16 <tmoertel> fragrant ?
18:37:27 <seth_> tmoertel: no, not especially
18:37:38 <tmoertel> does it have a sweet taste ?
18:37:59 <seth_> maybe a bit.  I has very little caffeine so I can drink it at night
18:38:18 <seth_> It has more of a black taste I think than a green test, but less strong
18:39:14 <tmoertel> does lambdabot respond to /msg ?
18:39:18 <shapr> yes
18:39:39 <shapr> time for me to sleep, gnite everybody
18:39:43 * shapr falls over
18:39:44 <tmoertel> 'night
18:52:33 <tmoertel> lambdabot: help
18:52:34 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
18:54:39 <seth_> lambdabot: select
18:54:39 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
18:54:51 <seth_> lambdabot: module select
18:54:52 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
18:55:00 <seth_> lambdabot: @listcommands
18:55:00 <lambdabot> I react to the following commands: ["all-dicts","board","define","definitions","del-definition","devils","dict","dict-help","dump","easton","echo","elements","eval","fact","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","more","msg","part","ply","quit","reset-chess","resume","searchml","set-fuel","showml","state","topic-
18:55:13 <seth_> lambdabot searchml select
18:59:37 <Darius> lambdabot: @searchml select
18:59:38 <lambdabot> 2246 2173 2346 1985 1961 1403 1242 1038 1003
18:59:56 <seth_> what do the numbers mean?
19:01:04 <Darius> heck if I know, maybe indexes?
19:01:11 <Darius> @showml 2246
19:01:11 <lambdabot> Would you mind to become a bit more generic?
19:01:11 <lambdabot> The following works with the gmap combinators.
19:01:11 <lambdabot> -- Find an immediate subterm of type y given a subterm of type x
19:01:11 <lambdabot> findOne :: (Term x, Term y) => x -> Maybe y
19:01:12 <lambdabot> findOne =   singleton
19:01:14 <lambdabot>           . foldl unJust [] 
19:01:16 <lambdabot>           . gmapQ (Nothing `mkQ` Just)
19:01:18 <lambdabot>  where
19:01:21 <seth_> maybe, but indices into what?
19:01:51 <Darius> the data structure that contains the messages
20:57:20 * Pseudonym curses computers everywhere
20:57:58 <seth_> Hey, Pseudonym, don't do that.  There is smoke coming out of one of my computers!
20:58:18 <Pseudonym> I have spent two days trying to track down a Heisenbug.
20:58:31 <Pseudonym> Still haven't got it yet.
20:58:33 <seth_> What's it doing?
20:58:47 <Pseudonym> Er... it'd take too long to explain.
20:58:59 <Pseudonym> It's in a Z39.50 database server.
20:59:09 <seth_> ok.  I might have seen it is why I ask.  I've seen _so_ many problems.
20:59:21 <Pseudonym> Nah.  This is very application specific.
20:59:28 <seafood> Igloo: you there?
21:09:07 <seth_> what's the syntax for grouping more than one statement?
21:09:52 <Pseudonym> I assume by "statement" you mean something in a "do" expression?
21:10:48 <seth_> no, I know how to do that.
21:11:06 <Pseudonym> Well what's a "statement", then?
21:11:17 <seth_> expression, I guess is the correct term
21:11:52 <Pseudonym> What do you want to write?
21:12:20 <seth_> if (something) the sClose sock1 sClose sock2 ...  like that
21:12:30 <seth_> s/the/then/
21:12:36 <Pseudonym> sClose is of type IO something?
21:12:52 <seth_> Yes IO () I believe
21:13:05 <Pseudonym> OK, then >>
21:13:18 <Pseudonym> (>>) :: IO a -> IO b -> IO b
21:13:22 <seth_> can I use something like   if (cond) then s1 >> s2 else ...
21:13:28 <Pseudonym> Sure.,
21:13:33 <seth_> OK, didn't know that
21:13:38 <Darius> or do notation
21:13:41 <Smerdyakov> Why wouldn't you be able to?
21:13:53 <Darius> if cond then do s1;s2 else ...
21:13:57 <Pseudonym> Actually, (>>) works for any monad, but IO is fine.
21:14:04 <tmoertel> or sequence_ [s1, s2, s3, ...]
21:14:15 <Pseudonym> Darius, you mean: if cond then do { s1;s2 } else
21:14:23 <seth_> I prefer the combinator to do.  First I know what is happening, and second it doesn't complain about (the last ... must be an expression)
21:14:40 <seth_> Pseudonym: ah, _that's_ where I saw { }
21:14:50 <Smerdyakov> seth_, there's not really any difference....
21:14:55 <Pseudonym> { } is actually just a shorthand for layout
21:15:10 <seth_> I can put them anywhere, more or less?
21:16:23 <seth_> meaning what?  that whatever indentation level is in effect when { is seen, remains in effect until } is seen?
21:16:37 <Pseudonym> Right.
21:16:42 <Pseudonym> With ; being line break.
21:16:47 <Pseudonym> So do foo
21:16:51 <Pseudonym>       bar
21:16:57 <Pseudonym> Is equivalent to do { foo ; bar }
21:17:30 <Darius> seth_: 1) do notation is very simple 2) It only complains about "the last..." if you do the equivalent of s1 >>= s2 where you should do s1 >> s2
21:18:18 <seth_> Darius: no, that isn't true.  It complains about it when the last right side of >> (or >>=) is not monadic
21:18:29 <Smerdyakov> Well, duh.
21:18:30 <Smerdyakov> It has to be!
21:18:39 <seth_> Right, that's why I don't use it.
21:18:50 <seth_> besides, I find it confusing, and the combinators are not confusing
21:18:50 <Smerdyakov> But do notation is just a shortand for using the Monad operators....
21:19:17 <seth_> Except that when I code with the operators the compiler is happy, and when I try to use do the compiler complains.  So I just use the operators.
21:19:34 <Pseudonym> Do you have your tabs set funny?
21:19:36 <Smerdyakov> This means you are misunderstanding something, and it would be good to figure it out.
21:19:59 <seth_> Pseudonym: no, the problem only occurs with do, so the tabs are ok.
21:20:16 <Darius> do s;rest == s >> do rest | do a <- s;rest == s >>= \a -> do rest | do s = s
21:20:19 <seth_> Smerdyakov: you can always fix it by putting return in enough places, but to may that negates any advantage in using it
21:20:24 <Pseudonym> You might have lucked out on the problem only surfacing when using do, though.
21:20:48 <seth_> Pseudonym: I checked, I set it up with only spaces to be sure.
21:21:30 <Pseudonym> I mention this only because it's happened to me.
21:21:40 <Darius> You'd need the return with >> or >>= unless you end in a function that produces a monadic value
21:22:34 <Darius> e.g. l >>= \a -> r >>= \b -> return $ a + b
21:22:39 <seth_> Yes, I know that.  I'll try to find an example where do doesn't do ( :)  ) what I expect.  With the combinators I have no problems, and I can see immediately where I need return
21:23:00 <seth_> Darius: yes, I know, but do is supposed to be easier, and I think it is actually harder.
21:23:42 <Pseudonym> seth, I think you're going to need to supply an existential proof.
21:24:01 <seth_> I'll post one when I come across it.
21:24:11 <Pseudonym> OK.
21:24:18 <seth_> But "harder" or "easier" is not easily proved
21:24:43 <Pseudonym> One example which you find more confusing would be sufficient.
21:25:06 <Pseudonym> There is one case which I find harder.
21:25:09 <Darius> I don't find do-notation "easier".  It's so light-weight as to be insignificant.  I find it "nicer" appearance-wise.
21:25:21 <Pseudonym> And that's where you want to put case notation or if-then-elses inside do blocks.
21:25:45 <seth_> Hmm, that's exactly my example.  The function sIsConnected returns IO Bool.  I want to say:  if the socket is connected, then close it.  
21:26:01 <seth_> sClose returns IO ()
21:26:11 <Pseudonym> Right.
21:26:15 <seth_> the input parameter is Socket
21:26:36 <seth_> so how do I do that?  without using unsafePerformIO
21:27:03 <Pseudonym> do  isconn <- sIsConnected sock
21:27:16 <Pseudonym>     if isconn then sClose sock else return ()
21:27:51 <Darius> when or until might be nicer
21:27:59 <seth_> ah, quoth the compiler:  The last statement in a 'do' construct must be an expression
21:28:11 <Darius> do you have both lines?
21:28:19 <seth_> Obviously
21:28:28 <Pseudonym> That means it can't be a bind.
21:28:32 <Pseudonym> You can't do:
21:28:36 <Pseudonym> do  foo
21:28:37 <Pseudonym>     x <- bar
21:28:44 <Pseudonym> You need to have something after the last line.
21:28:52 <seth_> That's why I use combinators.
21:28:58 <Pseudonym> Why?
21:29:03 <Darius> the tranlation would be foo >> bar >>= \x
21:29:11 <Pseudonym> Which does what exactly?
21:29:24 <Pseudonym> The lambda needs a body.
21:29:27 <seth_> Because there is nothing more to do.  I asked how to do it, and you gave me the code that the compiler won't take.
21:29:54 <Pseudonym> I think there's something you're not telling me.
21:30:03 <Pseudonym> Probably not deliberately, of course. :-)
21:30:11 <seth_> No, my entire function is the lines you just gave me.  So what could I not be telling you?
21:30:17 <Pseudonym> Hmmm.
21:30:34 <Pseudonym> Stick the code of the function in http://www.nomorepasting.com
21:30:55 <Pseudonym> Oh, and whatever non-empty line follows.
21:31:29 <seth_> OK, here it is with combinators, which the compiler accepts:
21:31:33 <Darius> do you have the layout right?  does 'do isConn <- sIsConnected sock; if isConn then sClose sock else return ()' give you the same error?
21:31:47 <seth_> misCloseIO sock =
21:31:50 <Pseudonym> OK.
21:31:59 <seth_> misCloseIO sock = sIsConnected sock
21:31:59 <seth_> 									>>= \isconn -> if isconn then sClose sock else return ()
21:32:11 <seth_> and here it is with do, which the compiler doesn't accept
21:32:24 <seth_> misCloseIO do isconn <- sIsConnected sock
21:32:24 <seth_> 										 if isconn then sClose sock else return ()
21:32:32 <Darius> the layout is wrong
21:32:51 <seth_> where
21:32:52 <Darius> if what I'm seeing is right
21:32:59 <seth_> then what you are seeing isn't right
21:33:08 <Darius> you line up under the expressions not the 'do'
21:33:12 <seth_> it has tabs in it.  the layout is correct
21:33:19 <seth_> I'll untabify
21:33:46 <seth_> misCloseIO sock = sIsConnected sock
21:33:46 <seth_>                   >>= \isconn -> if isconn then sClose sock else return ()
21:33:46 <seth_> misCloseIO do isconn <- sIsConnected sock
21:33:46 <seth_>                      if isconn then sClose sock else return ()
21:35:08 <seth_> even if this can be fixed (likely it can), you have to admit that it causes confusion
21:35:14 <Darius> This one's obviously wrong but for different reasons
21:47:34 <Darius> What do you have your tabstops set at?
21:49:47 <seth_> shouldn't matter, I changed everything to spaces
21:50:19 <Darius> You change everything to spaces before sending to GHC (or whatever)?
21:50:40 <Pseudonym> Sorry, AFK
21:52:58 <seth_> Darius: yes, to eliminate that potential problem.
21:54:34 <Darius> Well with similar code to the above I get the error if it isn't lined up, but I don't if it is.
21:54:57 <Darius> Try misCloseIO sock = do  on it's own line
21:55:04 <seth_> Lined up shouldn't matter, as long as the off side rule is followed.
21:55:05 <Darius> then line the expressions up under
21:55:19 <seth_> If I have to do that, I think I've proven my point
21:55:34 <seth_> I'm perfectly happy using combinators
22:10:10 <Darius> It is following layout.
22:11:24 <seth_> According to all the docs, the precise indentation should not matter as long as you follow the off side rule
22:11:49 <Darius> "For each subsequent line, if it contains only whitespace or is indented more, then the previous item is continued (nothing is inserted)"
22:12:04 <seth_> right
22:12:31 <seth_> so as long as the second line is to the right of "do", how far to the right doesn't matter
22:12:44 <Darius> You've read that wrong.  You WANT the semicolon inserted.  The -expression- is continued, not the do -block-
22:13:04 <seth_> there is no semicolon
22:13:13 <Darius> This is in case you have sIsConnected on one line and sock on the next
22:13:27 <seth_> well, there would be, but I don't
22:13:38 <seth_> your client split the line
22:14:13 <seth_> The indentation is correct, at least according to the docs
22:14:13 <Darius> I didn't say that's what you did, I said "in case" as in if you wanted that
22:14:27 <seth_> that has nothing to do with what we are discussing
22:14:47 <seth_> it's just hopelessly confusing, and with combinators, ALL of this goes away.
22:15:45 <Darius> You'll be having mysterious problems with layout all the time if you don't see the difference
22:16:25 <seth_> I have absolutely NO problems with layout except when I use do
22:16:42 <seth_> and I'm not convinced that is a layout "problem" either, although perhaps a layout bug
22:17:57 <dennis> I don't see neiter a problem nor a bug, but you have written a lot here
22:18:53 <Darius> The rules are setup so the following will work,
22:18:54 <Darius> somevery :: a -> b -> c -> d -> e -> f
22:18:55 <Darius> do a <- somevery long line
22:18:55 <Darius>            that is continued
22:18:55 <Darius>    statement2
22:19:04 <dennis> do x <- y
22:19:04 <dennis>     z
22:19:04 <dennis> is wrong because this is parsed as
22:19:05 <dennis> do x <- y z
22:19:10 <dennis> yes
22:19:20 <seth_> then it doesn't follow the off side rule
22:19:28 <Darius> Yes it does
22:19:45 <Darius> let x = 4
22:19:45 <Darius>      y = 3 in 5
22:19:49 <Darius> won't parse
22:20:12 <seth_> but that's because they are two separate functions.  but this will parse:
22:20:13 <dennis> while:
22:20:13 <dennis> do x <- y
22:20:13 <dennis>    z
22:20:13 <dennis> is parsed as
22:20:13 <dennis> do { x <- y; z }
22:20:17 <seth_>       let x = 1
22:20:20 <seth_> let y = 2
22:20:58 <Darius> That certainly won't parse, vant to paste again.  You don't have any 'in'
22:20:59 <seth_> ok, there is perhaps _some_ way to code it.  However using the combinators it simply follows the same rules as everything else, which I find much easier.
22:21:13 <seth_> right, lose the "let" on both lines
22:21:40 <seth_> although in ghci it does indeed parse with let.  I just did it
22:22:02 <Darius> GHCi is in a do-block
22:22:23 <seth_> right.  so what you claimed is wrong.  the statements aren't aligned, but they parse
22:22:44 <Darius> You can't misalign something on one line!
22:22:51 <dennis> in the first (of my) cases z is indented more so the expression is continued and it's x <- y z in the second case it's indented the same and an ; is inserted and you get x <- y; z
22:22:57 <seth_> I showed you two lines.  what are you talking about?
22:23:02 <Darius> GHCi doesn't do layout at alet x = 4
22:23:03 <Darius>      y = 3 in 5
22:23:25 <Darius> GHCi doesn't do layout at all, it takes each line on it's own
22:23:33 <seth_> dennis: well, whatever, it's confusing
22:23:55 <seth_> and the code with combinators is very easy
22:24:02 <dennis> the layout rule can be confusing
22:24:08 <Darius> If it's confusing then it's not a property of do notation
22:24:16 <seth_> I'm not telling other people not to use do, I'm just saying I don't like it.
22:24:20 <dennis> true, it's the same for let
22:24:37 <seth_> but the compiler _never_ complains about let.
22:24:45 <dennis> sure it does
22:24:56 <Darius> I gave an example that did
22:24:59 <seth_> no, you can have a let statement to the right of a preceding let statement, and it is happy as a clam
22:25:09 <seth_> try it
22:25:17 <Darius> Try my example
22:26:02 <seth_> which example?  I believe you, I just don't see that it follows the rules.  But perhaps I misinterpret them.  And it is NOT the same as what happens with let.  I just compiled a file to make sure I'm correct.
22:26:08 <dennis> bar = let x = 5
22:26:08 <dennis>            y = 4
22:26:08 <dennis>       in 3
22:26:13 <dennis> Bar.hs:2: parse error on input `='
22:26:19 <Darius> let x = y
22:26:19 <Darius>     y = x
22:26:20 <dennis> because it's parsed as
22:26:23 <Darius> let x = y
22:26:23 <Darius>     y = x
22:26:24 <dennis> bar = let x = 5 y = 4
22:26:24 <seth_> dennis: I never code that way, I use let on each line.
22:26:24 <dennis>       in 3
22:26:29 <seth_> let x = 2
22:26:31 <seth_>     let y = 3
22:26:36 <seth_>         let z = 4 in
22:26:50 <seth_> which is really better
22:26:51 <Darius> do the example I just accidentally posted twice
22:26:52 <dennis> if you hava a lot of things to define you indent a lot
22:27:04 <Darius> using let's your way
22:27:11 <seth_> I'm not saying you have to, only that you _can_
22:27:46 <seth_> anyway, I'm sure you are correct that it will parse as you suggest.  but it is very confusing and I find use of combinators not at all confusing.  Which is my only point.
22:28:33 <dennis> maybe this style suits you:
22:28:36 <dennis> foo = do x <- f
22:28:37 <dennis>          do y <- g
22:28:37 <dennis>             do bar
22:28:58 <dennis> it's nothing wrong combinators
22:29:10 <dennis> that is not what I'm saying, I like them too :-)
22:29:16 <Darius> do a <- m;
22:29:17 <Darius>     s
22:29:51 <dennis> yes, inserting the ; yourself is also an alternative
22:30:03 <dennis> and maybe the { }
22:30:39 <Darius> the {}'s aren't necessary
22:31:33 <Darius> Anyways, I still want to see my x = y;y = x example using multiple let's.
22:31:47 <dennis> that could be a problem :-)
22:45:09 * Darius waits
22:48:57 <Pseudonym> Found it.
22:49:01 * Pseudonym sighs deeply
22:49:11 <Pseudonym> Should have used purify.
22:49:31 <seth_> Pseudonym: valgrind is better than purity
22:49:49 <Pseudonym> How well does it work under solaris?
22:50:37 <Pseudonym> And does it work with the beta of forte8?
22:51:40 <Pseudonym> The problem, BTW, was I forgot to initialise something.
22:51:50 <Pseudonym> So it would have found reading uninitialised memory.
22:55:07 <seth_> Pseudonym: I've only used it once under solaris, and it worked quite well.  Plus much easier to use, you avoid all the instrumenting steps
22:55:23 * Pseudonym nods
22:55:25 <seth_> Pseudonym: but no doubt it is more more tested in the x86 environment
22:55:30 <Pseudonym> I might try it out.
22:55:47 <Pseudonym> The difficulty with purify is we don't have a version for forte8 yet.
22:56:04 <Pseudonym> Need to recompile with forte7 (MUCH slower) to use it.
22:56:04 <seth_> Pseudonym: not to mention the cost.
22:56:08 <Pseudonym> So valgrind sounds good.
22:56:21 <Pseudonym> Oh, I don't exactly pay for it out of my pocket. :-)
22:56:40 <seth_> definitely worth a try.  Solaris is a wild card, but it is worth testing as it finds for me many things that purify misses.
22:56:53 <Pseudonym> Thanks.  I'll check it out.
22:57:54 <seth_> even when motorola paid for purify, I found it very annoying on large programs
22:58:10 <Pseudonym> Oh, I certainly find it annoying.
22:58:18 <Pseudonym> Though purecoverage isn't so bad.
22:58:58 <seth_> Yes, that's true, and their profiler can be useful also, although the profiler requires the same instrumentation as purify.  Does pure coverage?  I don't remember
23:00:08 <ibid> any happy people?
23:00:17 <Pseudonym> I think it does.
23:00:22 * Pseudonym is much happier, ibid
23:00:26 <ibid> what causes it fail with "Fail: wibble"
23:00:27 <Pseudonym> Two days tracking down a bug.
23:00:36 <Pseudonym> Purify or GHC?
23:00:39 <ibid> happy
23:00:49 <Pseudonym> A bug, I guess.
23:00:55 <ibid> oh great
23:05:19 <ibid> fortunately wibble is used only once in the sources :-)
23:05:44 <Pseudonym> Meaninful error messages are good. :-)
23:07:32 <ibid> listArray' outputs that if the bounds do not agree with the given list
23:10:42 <seth_> Pseudonym: unsafePerformIO is frowned upon, correct?
23:11:12 <Pseudonym> Yes.
23:11:31 <Pseudonym> There are safe uses.
23:12:13 <seth_> So take a simple case.  I'm calling a close function from somewhere that is not monadic.  I'm using unsafePerformIO to strip the IO from IO ().  What should I be doing instead?  Or is that usage OK?
23:12:29 <Pseudonym> No, it's not OK.
23:12:39 <Pseudonym> You should call your close function from somewhere monadic.;
23:12:54 <seth_> In that case everything will become monadic
23:13:10 <Pseudonym> If it has side effects, it should be.
23:13:13 <seth_> which doesn't seem sensible
23:13:30 <seth_> but maybe it is, let me think on it.
23:20:45 <ibid> found a simple testcase for the bug
23:22:22 <flippo> @yow
23:22:22 <lambdabot> The SAME WAVE keeps coming in and COLLAPSING like a rayon MUU-MUU..
