02:07:09 <Janni> Morning...
02:11:44 <opet> morning!
02:41:52 <shapr> gooood morning!
02:42:59 <mgoetze> hi shapr
02:43:12 <shapr> hiya
03:26:39 <Riastradh> @yow
03:26:39 <lambdabot> ..  over in west Philadelphia a puppy is vomiting..
03:26:39 <lambdabot> [-DONE-]
03:33:29 <Janni> I have a question an IO / lazy evaluation. In the following function (test "abc") always results in a double of equal elements, where (test' "abc") calculates independently. I'm wondering about the fact, that the two (randomElem xs) aren't evaluated only once, yielding the same result, because from (test')s point of view (randomElem) doesn't have any side effects (no IO-monad)...
03:33:38 <Janni>     test  :: [a] -> (a,a)
03:33:41 <Janni>     test  xs = (x, x) where x = randomElem xs
03:33:41 <Janni>     test' xs = (randomElem xs, randomElem xs)
03:33:41 <Janni>     randomElem :: [a] -> a
03:33:41 <Janni>     randomElem xs = xs !! randomInt
03:33:41 <Janni>         where randomInt = unsafePerformIO $ randomRIO (0, length xs - 1)
03:35:39 <Darius> The compiler isn't required to perform CSE, and without that, the two randomElem's aren't the same thunk
03:36:01 * shapr needs to fix @fact and add CSE
03:38:14 <phubuh> i'm writing a trivial brainfuck interpreter. so far, i have an enumerated type representing an operation, but i'm not sure how to represent state
03:38:26 <phubuh> state in brainfuck is an array of integers and an index into it, basically
03:39:15 <shapr> there's an existing brainfuck interpreter in haskell-libs
03:39:22 <shapr> you may want to see how that one works
03:39:33 <phubuh> oh, neat
03:40:14 <phubuh> actually, i'm writing a compiler that compiles to brainfuck
03:40:20 <phubuh> i just needed an interpreter to test it :-)
03:41:31 <Janni> phubuh: What's the input language?
03:43:41 <phubuh> it won't have a syntax proper for a while, since lexing and parsing is so ungodlily boring, but something simple and imperative
03:44:12 <Riastradh> phubuh, use an s-expression syntax.
03:44:27 <phubuh> yeah, that'd be convenient
03:46:37 <Janni> Darius: I don't get really good results searching for CSE. Can I get another hint?
03:48:29 <shapr> common subexpression elimination I think
03:48:38 <Darius> yes
03:50:19 <Janni> Darius: What do you mean by "isn't required to perform CSE"? Just in this case, or in general?
03:50:43 <phubuh> oh by the way, shapr, i moved to a place with bredbandsbolaget :-)
03:51:13 <shapr> mmm, broadband is nice
03:53:26 <Darius> In general, the compiler isn't required to perform CSE.  CSE is an optimization (well, not always hence it not always being done).
03:56:23 <Janni> Oh, gotta run!
04:05:23 * shapr boings happily
04:09:19 * Riastradh kersploings.
04:09:30 * shapr explorbs
04:09:46 * Riastradh shamefully OCamls.
04:10:51 <phubuh> is there a prelude function that does take n (repeat x)?
04:11:15 <shapr> iterate x
04:11:23 <shapr> @prelude iterate
04:11:27 <lambdabot> *** "iterate" prelude "Haskell Standard Prelude Dictionary": text follows
04:11:27 <lambdabot> iterate
04:11:27 <lambdabot>   iterate ::  (a -> a) -> a -> [a]
04:11:27 <lambdabot>   iterate f x       = x : iterate f (f x)
04:11:32 <lambdabot> [-DONE-]
04:11:46 <Darius> replicate n x
04:12:00 <phubuh> ah, replicate is what i want. thanks!
04:12:47 * shapr loses points in the #haskell quiz show ;-)
04:12:53 <phubuh> :-)
04:14:22 <shapr> I have to study the prelude more :-)
04:19:25 * shapr finishes reading the new "science news" issues
04:19:42 <shapr> too bad they don't have a programming news weekly 'zine
04:21:56 <phubuh> whoa, haskell-mode rules
04:22:13 <shapr> yah it does
04:22:18 <shapr> M-x turn-on-haskell-ghci
04:22:39 <shapr> http://www.haskell.org/hawiki/HaskellMode
04:23:04 <Riastradh> The only thing I really hate about it is the fact that it indents with tabs and spaces, instead of just spaces.
04:23:21 <phubuh> huh, it does?
04:23:45 <shapr> It doesn't use tabs here3.
04:23:55 <Riastradh> Hmm.
04:24:05 <Riastradh> Is there some toggle in Emacs to turn of tabs or something?
04:24:09 <Riastradh> s/of/off/1
04:24:11 <shapr> I think so
04:24:21 * shapr looks through his config files
04:24:22 <Riastradh> Ooh, ooh, where?  what?  how?
04:24:32 <phubuh> (setq-default indent-tabs-mode nil)
04:24:39 <Riastradh> ('why' -> I hate tabs; 'when' -> now)
04:24:46 <shapr> yah, I hate tabs too
04:25:10 <shapr> yah, I have that same line
04:27:09 <phubuh> does haskell have something like o'caml's flatten which turns [1, [2, [3, 4], 5]] into [1, 2, 3, 4, 5]?
04:27:27 <shapr> I think concat
04:27:37 * shapr checks
04:27:44 <Smerdyakov> A fixed point iteration of concat would do it.
04:27:49 <Smerdyakov> But I think concat itself is one level.
04:27:53 <shapr> ah
04:27:54 <shapr> right
04:28:25 <phubuh> fixed point iteration?
04:29:17 <phubuh> wait, i just need one level
04:29:23 <phubuh> heh.
04:29:53 <shapr> concat [[2, 5],[3,4]]
04:29:56 <shapr> [2,5,3,4]
04:35:40 <phubuh> agh, i think this brainfuck thing might almost be impossible
04:37:04 <phubuh> since there's no way of knowing what the index is, i can't find my stack pointer
04:38:41 <shapr> gutentag kosmikus 
04:38:47 <shapr> hoe gaat? ;-)
04:38:55 <shapr> kosmikus: are you learning Dutch?
04:39:38 <kosmikus> shapr: ik heb twee cursussen gedaan, maar nu niet meer
04:39:44 * shapr grins
04:39:45 <shapr> nifty!
04:41:00 * kosmikus has just finished presenting a talk that he has prepared all night
04:41:04 * kosmikus is very tired
04:41:16 <shapr> neat, what's the talk?
04:41:36 <kosmikus> about generic programming without Generic Haskell ;)
04:42:08 <kosmikus> among other things, explains the approach to generic programming in Haskell taken by Hinze/Cheney in their HW2002 paper
04:42:14 <Riastradh> Generic Haskell?
04:42:29 <kosmikus> Riastradh: yes, why?
04:42:37 <Riastradh> ?
04:42:42 <Riastradh> Why what?
04:42:56 <kosmikus> Generic Haskell is a language extension I am working on for my PhD
04:43:10 <kosmikus> www.generic-haskell.org
04:43:26 <kosmikus> but don't download the version distributed there, instead ask me for a more recent one
04:49:25 <shapr> kosmikus: could I get a more recent version?
04:49:35 <shapr> what's more generic about GH?
04:49:50 <shapr> can you give me an example of something I can do in GH that I can't do in GHC?
04:50:58 <kosmikus> shapr: have a look at www.cs.uu.nl/~andres and download version 1.35.2
04:51:50 * shapr grabs
04:51:51 <kosmikus> the classic application area of generic programming is as a replacement/generalization of Haskell's "deriving" construct
04:52:59 <kosmikus> similar to DrIFT, you can define functions that work on all datatypes by structural recursion on datatypes, but -- at least in theory -- in a typesafe way
04:53:26 <kosmikus> shapr: the build system is currently quite unstable, so if you have problems compiling or installing it, let me know
04:53:56 <shapr> ok, thanks
05:04:52 <zealman> hey people
05:04:52 <shapr> hello zealman 
05:04:52 <zealman> hey shapr
05:04:52 <shapr> nice nickname, does it mean "passionate person" ?
05:04:52 <zealman> oh no...its a kiwi thing...
05:04:52 <zealman> as in im from new zealand
05:04:52 <zealman> :p
05:04:52 <zealman> i'm a man from zeal....zealand or sumthin
05:04:52 <zealman> is ne1 talkin on here.... 
05:04:54 <shapr> there are people talking on here.
05:04:58 <zealman> true...
05:05:01 <shapr> zealman: are you learning Haskell?
05:05:05 <zealman> yeah....
05:05:10 <zealman> i'm havin a bit of trouble
05:05:40 <zealman> maybe sum1 could help me...
05:05:51 <shapr> what trouble are you having?
05:05:58 * shapr is full of zeal for haskell
05:06:05 <zealman> sweet :p
05:06:26 <zealman> i'm havin trouble mapping a function onto my own user defined type
05:06:50 <zealman> i keep getting a type error in application...etc
05:07:41 <zealman> ...
05:07:42 <shapr> what's the error?
05:07:53 <shapr> you have to give more details...
05:07:59 <zealman> ok...
05:08:28 <zealman> sorry to bug you and all...
05:09:05 <shapr> no worries, we're here because we like Haskell.
05:09:12 <zealman> i have a function called, inflate:: Library1 -> Float -> Library1
05:09:17 <zealman> sweet :p
05:09:25 <shapr> except for lambdabot 
05:09:31 <zealman> lol
05:09:32 <shapr> he's here because we wrote him.
05:09:56 <shapr> lambdabot: sit boy!
05:09:56 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
05:09:56 <lambdabot> [-DONE-]
05:10:18 <zealman> anyways.... Library1 is  , type Library1 = (ToyList1, ClientList)
05:10:44 <zealman> of which type Toylist1 = [(String, Float)]
05:11:05 <zealman> and ClientList = [(String, [String])]
05:11:22 <shapr> ok
05:11:25 <zealman> and i'm trying to map the inflate function onto these
05:11:47 <zealman> such as i want to increase the float value in the ToyList1 
05:12:09 <zealman> and i keep getting a type error in appln...
05:12:20 <zealman> help!
05:12:23 <shapr> what's the error?
05:13:14 <zealman> well for eg,  inflate (toys, clients) increase = map (+increase) (toys, clients)
05:13:42 <shapr> map takes a function and a list
05:13:49 <shapr> and applies that function to each item in the list
05:13:52 <shapr> you've given it a tuple
05:13:59 <shapr> @prelude map
05:14:01 <lambdabot> *** "map" prelude "Haskell Standard Prelude Dictionary": text follows
05:14:01 <lambdabot> map
05:14:01 <lambdabot>   map ::  (a -> b) -> [a] -> [b]
05:14:01 <lambdabot>   map f xs          = [ f x | x <- xs ]
05:14:06 <lambdabot> [-DONE-]
05:14:14 <zealman> so f is the function right
05:14:20 <shapr> yup
05:14:23 <zealman> and xs is the new list?
05:14:35 <shapr> xs is the list you give to the map function
05:14:36 <zealman> whats the (a -> b) bit..
05:14:38 <shapr> it's the input
05:14:57 <shapr> (a -> b) is the type of a function, yah?
05:15:02 <shapr> if you're using hugs or ghci
05:15:12 <zealman> yep... i'm using hugs 98
05:15:17 <shapr> then you can see the type of (+increase)
05:15:19 <shapr> with something like
05:15:23 <shapr> :t (+5)
05:15:28 <shapr> :t is short for :type
05:15:42 <shapr> and, if you passed 5 in for the increase value
05:15:47 <shapr> you'd get (+5), right?
05:15:51 <zealman> yeah i get that...
05:16:05 <shapr> so, what's the type of (+5) ?
05:16:17 <zealman> um Int?
05:16:26 <shapr> nope
05:16:34 <zealman> no no... tuple
05:16:39 <shapr> try ":type (+5)" in hugs
05:16:40 <shapr> then you'll know
05:16:44 <shapr> it's not a tuple either
05:16:47 <zealman> sorry im so dumb :p
05:16:53 <shapr> no worries, I started in the same place
05:17:15 <zealman> what does flip mean
05:17:18 <shapr> maybe even further back, since I had years of procedural programming to unlearn :-)
05:17:30 <shapr> flip switches the order of two arguments
05:17:30 <zealman> lol
05:17:32 <shapr> try this:
05:17:37 <shapr> ":type (5+)"
05:17:58 <shapr> then you won't see the flip
05:18:02 <zealman> true
05:18:09 <shapr> the flip makes the first argument the second, and the second the first
05:18:17 <shapr> flip f x y = f y x
05:18:19 <shapr> see?
05:18:25 <zealman> yep
05:18:46 <shapr> so (5+) is (+5) flipped
05:18:46 <zealman> i'll try your advice above...is it ok if i ask you questions later if your still on
05:18:51 <shapr> yah sure
05:19:01 <zealman> where you from?
05:19:05 <zealman> out if interest
05:19:10 <zealman> out of interest even
05:19:11 <shapr> born in Alabama, living in north sweden
05:19:14 <shapr> what about you?
05:19:17 <zealman> crazy
05:19:28 <zealman> an alabaman in sweden...that's a first :p
05:19:32 * shapr laughs
05:19:37 <zealman> i'm in lil ol noo zeeland
05:19:40 <shapr> it's my great european adventure ;-)
05:19:49 <shapr> I've never been to .nz, but I'd like to visit.
05:19:55 <zealman> how are those swedish girls :P
05:19:59 <shapr> admittedly, I'd be a total tourist and want to see a weta ;-)
05:20:01 <zealman> gotta come here dude
05:20:13 <zealman> if y'all ever down this way stop by
05:20:14 <zealman> :D
05:20:16 <shapr> swedish girls live up to the stereotype and then some extra
05:20:20 <zealman> dang
05:20:22 <shapr> but I have a german/french girl I live with ;-)
05:20:23 <zealman> no shit
05:20:28 <zealman> that's cool
05:20:31 <shapr> and have lived with her for the last four or five years
05:20:41 <zealman> sweet :D
05:20:49 <zealman> i'm suprised you know about weta's
05:20:54 <zealman> i'm impressed :D
05:20:56 <shapr> heh
05:21:02 <shapr> they're touristy things
05:21:11 <zealman> and kiwi's 
05:21:16 <shapr> especially since the special effects company for the LotR is named for a Weta
05:21:16 <mgoetze> shapr: dark assures me that finnish girls are better than swedish girls
05:21:22 <zealman> true
05:21:31 <shapr> mgoetze: I can only compare the northern end of both countries
05:21:31 <zealman> hey i'm not fussy
05:22:32 <shapr> I've lived in north .fi and north .se
05:22:32 <zealman> k i'm off for a minute brb :P
05:22:32 <shapr> and north .se is much more buxom
05:22:32 <shapr> or something
05:22:32 <dennisb> dark obviously don't know what he is talking about
05:22:32 * shapr laguhs
05:22:32 <shapr> @dict-help
05:22:32 <lambdabot> I perform dictionary lookups via the following 13 commands:
05:22:32 <lambdabot> @all-dicts .. Query all databases on dict.org
05:22:32 <lambdabot> @devils ..... The Devil's Dictionary
05:22:32 <lambdabot> @easton ..... Easton's 1897 Bible Dictionary
05:22:32 <lambdabot> @elements ... Elements database
05:22:32 <lambdabot> @foldoc ..... The Free On-line Dictionary of Computing
05:22:32 <lambdabot> @gazetteer .. U.S. Gazetteer (1990)
05:22:32 <lambdabot> @hitchcock .. Hitchcock's Bible Names Dictionary (late 1800's)
05:22:32 <lambdabot> @jargon ..... Jargon File
05:22:32 <lambdabot> [there's @more]
05:22:32 <shapr> @more
05:22:32 <lambdabot> @prelude .... Haskell Standard Prelude
05:22:32 <lambdabot> @vera ....... V.E.R.A.: Virtual Entity of Relevant Acronyms
05:22:32 <lambdabot> @web1913 .... Webster's Revised Unabridged Dictionary (1913)
05:22:32 <lambdabot> @wn ......... WordNet (r) 1.7
05:22:32 <lambdabot> @world02 .... CIA World Factbook 2002
05:22:32 <shapr> ah there it is
05:22:32 <lambdabot> [-DONE-]
05:22:32 <shapr> @web1913 buxom
05:22:32 <lambdabot> *** "Buxom" web1913 "Webster's Revised Unabridged Dictionary (1913)"
05:22:33 <lambdabot> Buxom \Bux"om\, a. [OE. buxum, boxom, buhsum, pliable, obedient,
05:22:35 <lambdabot>    AS. b[=o]csum, b[=u]hsum (akin to D. buigzaam blexible, G.
05:22:37 <lambdabot>    biegsam); b[=u]gan to bow, bend + -sum, E. -some. See {Bow}
05:22:37 <shapr> oh, oops
05:22:39 <lambdabot>    to bend, and {-some}.]
05:22:41 <shapr> that's not what I meant
05:22:41 <lambdabot>    1. Yielding; pliable or compliant; ready to obey; obedient;
05:22:43 <lambdabot>       tractable; docile; meek; humble. [Obs.]
05:22:47 <lambdabot> [there's @more]
05:23:04 <delYsid> isn't dark .nl?
05:23:12 <mgoetze> .nl living in .fi
05:23:12 <shapr> delYsid: from, but lives in helsinki
05:23:17 <shapr> hoi Vincenz 
05:23:23 <shapr> hoe gaat?
05:23:27 <Vincenz> hi 
05:23:29 <Vincenz> shapr: ik ben een tomaat
05:23:29 <shapr> comment ça va?
05:23:36 <Vincenz> je suis un helicoptere
05:23:38 <delYsid> heh, /me wouldn't have left .nl :)
05:23:38 <shapr> ik ben een tandeborstal! :-)
05:23:43 <Vincenz> no!
05:24:13 <shapr> je suis un herison!
05:24:13 <Igloo> kosmikus: I've just sent a mail about the kernel-package style to libraries@
05:24:13 <Vincenz> tandenborstel
05:24:13 <shapr> I wonder if I spelled that anywhere close to correctly
05:24:17 <shapr> Vincenz: sorry, my swedish lessons are getting mixed into my dutch vocab
05:24:17 <delYsid> @dict tandenborstel
05:24:18 <lambdabot> Supported dictionary-lookup commands:
05:24:18 <lambdabot>   @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @prelude @vera @web1913 @wn @world02
05:24:18 <lambdabot> Use "@dict-help [cmd...]" for more.
05:24:18 <lambdabot> [-DONE-]
05:24:30 <shapr> @all-dicts tandeborstal
05:24:31 <lambdabot> No match for "tandeborstal".
05:24:31 <lambdabot> [-DONE-]
05:24:34 <shapr> bzzt
05:24:37 <shapr> @fact
05:24:37 <lambdabot> empty factoid, BZZZT, thank you for playing!
05:24:37 <lambdabot> [-DONE-]
05:24:38 * Igloo learnt "Alles im Eimer!" today
05:24:52 <Vincenz_> what the
05:24:52 <shapr> everybody jump on Elmer?
05:24:56 <Vincenz_> I just got kicked
05:25:00 <Vincenz_> [14:24] * [10053] Software caused connection abort
05:25:00 <shapr> by who?
05:25:02 <Igloo> Which isn't Swedish, but it's foreign, so near enough  :-)
05:25:06 * shapr laughs
05:25:27 <delYsid> Igloo: german.
05:25:38 <Igloo> It means "Everything('s) in the bucket", or idiomatically "It's all gone to pot"
05:25:41 <delYsid> and it translates basicly into snafu
05:25:51 <Vincenz> well
05:25:56 <Vincenz> back to working on my compiler :)
05:25:58 <Igloo> And also just happens to be the name of quite a fun little game
05:26:01 <Vincenz> lexing stage works
05:27:06 <shapr> I have some confused ideas about the Haskell distutils
05:27:11 <shapr> I should really read up on python's distutils
05:27:14 <shapr> I haven't used them recently
05:27:18 <Igloo> Is that as in library building stuff?
05:29:22 <zealman> grrr
05:29:31 <zealman> i'm doin it wrong
05:29:35 <shapr> what?
05:29:42 <shapr> Igloo: yes, for building libraries
05:29:58 <shapr> Igloo: distutils handles installing python sources, and C sources to be built into python modules
05:29:58 <zealman> shapr: ughh...
05:30:19 <shapr> zealman: try unwrapping the tuple and mapping over the list inside
05:30:51 <zealman> shapr:that's what i thought...but im not sure how too
05:30:58 <shapr> what have you tried?
05:31:46 <zealman> well since i'm trying to map a float onto a list inside of a tuple inside of a list :P i just don't know how too
05:31:47 <shapr> zealman: break it down... how would you increase the float value in a Toylist1
05:31:48 <shapr> ?
05:31:59 <shapr> actually, even further...
05:32:02 <zealman> yeah
05:32:08 <zealman> i tried doing that  too
05:32:18 <shapr> how would you increase the value in one item in a Toylist1 ?
05:32:40 <zealman> like mapping the float value onto a [(Float, Float)] and it didn't work
05:32:50 <zealman> but it worked on a [(Float)]
05:33:08 <shapr> that's because [(Float)] is the same as [Float]
05:33:08 <zealman> inflate umm...
05:33:13 <zealman> oh ok
05:33:27 <zealman> how would i map onto a [(Float, Float)]
05:33:45 <kosmikus> Igloo: ack. will read
05:33:57 <shapr> if you break that down further, you get "how do I increase the value of (Float,Float) by another Float?"
05:34:08 <zealman> oh ok...
05:34:13 <shapr> zealman: see if you can answer that question by yourself first... if not, I'll help you out.
05:34:21 <zealman> hmm...
05:34:24 <zealman> ok
05:35:13 <shapr> anyone clueful enough about postgres to know if I can suck the data from a dir on another linux drive into my current postgres db?
05:36:33 <zealman> hmm
05:37:14 <zealman> when i go inflate::[(Float, Float)]->Float->[Float]
05:37:41 <zealman> then say inflate a percentage = map (*percentage) a
05:37:47 <zealman> it throws a wobbly
05:38:17 <zealman> saying that (*percentage) is of type Float -> Float
05:38:28 <shapr> do you know what that type means?
05:38:29 <zealman> does not match (Float, Float) -> Float
05:38:54 <shapr> what does the type Float -> Float mean?
05:38:55 <zealman> does it mean percentage is the first float
05:39:00 <zealman> and a is the second?
05:39:48 <shapr> zealman: can you write a function that increases one float by another?
05:40:26 <zealman> yeah, by using that first inflate function with only [Float] -> Float -> [Float]
05:40:31 <zealman> type sorry
05:40:35 <zealman> then it works
05:40:50 <shapr> well, let's get a bit more general
05:40:55 <shapr> forget about map for a moment ;-)
05:40:58 <zealman> k
05:41:03 <shapr> what's the code for a function that adds two Float values?
05:41:40 <zealman> ermmm....
05:41:49 <shapr> zealman: oh, related question.. have you done programming in other languages before? if so, which languages?
05:42:00 <zealman> java, and i'm learning C at the moment
05:42:08 <shapr> ah, ok...
05:42:14 <zealman> so this stuff is all new to me
05:42:22 <shapr> in Haskell, unlike Java, you are rarely required to give a type signature
05:42:47 <shapr> I've been using Java since it was in beta, some months before 1.0.2 was released, I like Haskell much more :-)
05:42:54 <zealman> oh ok....
05:43:10 <shapr> so, can you show me the code for a function to add two floats?
05:43:12 <zealman> is that why java is called a declaritive language
05:43:18 <zealman> and hugs is imperative
05:43:21 <zealman> ?
05:43:37 <kosmikus> flip
05:43:37 <shapr> it's the other way around, Haskell is declaritive, and Java is imperative
05:43:43 <zealman> jees...
05:43:52 <zealman> sorry its like midnight ish here
05:44:01 <shapr> and it's because Haskell works like an equation, and Java works like a series of steps to be performed one after the other.
05:44:09 <zealman> yeah
05:44:29 <zealman> anyways...
05:44:34 <shapr> yah, anyways...
05:45:30 <zealman> i can't think of it
05:45:46 <shapr> zealman: how would you add two numbers in hugs? if you wanted to treat it like a calculator?
05:46:04 <zealman> you'd go 3 + 3 = 6
05:46:08 <zealman> umm...
05:46:20 <zealman> Int -> Int -> Int
05:46:24 <sjj> Is there an easy way to get the symmetric difference of two lists in Haskell?
05:46:37 <shapr> @prelude disjoint
05:46:39 <lambdabot> No match for "disjoint".
05:46:39 <lambdabot> [-DONE-]
05:46:44 <shapr> hrm
05:46:44 <zealman> ?
05:46:49 <shapr> sjj: there is, I've forgotten the name of it
05:46:53 <Igloo> What is the symmetric difference?
05:47:00 <zealman> ditto
05:47:02 <sjj> shapr: okay, at least that motivates me to keep looking ;)
05:47:08 <sjj> Igloo: xor
05:47:27 <shapr> zealman: so, how do you write a function to add two numbers in Haskell?
05:47:39 <Igloo> Ah, you want things that only exist in one list?
05:47:49 * sjj nods.
05:48:13 <shapr> zealman: say the function is named addNums, and it takes two args, x and y
05:48:17 <Igloo> Well, it's (xs `union` ys) \\ (xs `intersect` ys)
05:48:19 <shapr> addNums x y =
05:48:23 <shapr> zealman: what's the rest of the function?
05:48:34 <Igloo> I didn't think there was a function for it BICBW
05:48:42 <shapr> Igloo: maybe I'm wrong
05:48:52 <shapr> I obviously need to study the prelude a bit more.
05:48:59 <shapr> my #haskell quiz score is dropping fast ;-)
05:49:01 <Igloo> Oh, the above assumes they're sets
05:49:11 <sjj> Igloo: thanks
05:49:14 <sjj> oh...
05:49:16 * shapr innocently wonders why Igloo is thinking about sets a lot lately
05:49:37 * Igloo hasn't thought about sets for months  :-)
05:50:03 * shapr considers asking oleg for a type-system enforced Set datatype
05:50:15 <shapr> zealman: still here?
05:50:18 <zealman> addNums x y = xy
05:50:20 <zealman> ?
05:50:23 <zealman> yea
05:50:32 <sjj> I'll just do it with a simple list comp
05:50:49 <shapr> zealman: wouldn't you want an operator between those two numbers that did the adding?
05:50:56 <zealman> yeah...
05:51:02 <zealman> x+y
05:51:14 <zealman> or prefix?
05:51:22 <shapr> nah, I like x + y
05:51:38 <zealman> rightio
05:51:44 <shapr> zealman: so, can you use that to add two Float values together?
05:52:01 <zealman> hmm...sure
05:52:11 <shapr> say you put that into your source file, "addNums x y = x + y"
05:52:14 <shapr> and then load your source file
05:52:21 <shapr> can you do "addNums 1.0 5.0" ?
05:52:27 <zealman> oh...probably not
05:52:32 <shapr> zealman: try it..
05:52:32 <zealman> unless you define it
05:53:23 <zealman> whooptey do
05:53:47 <zealman> is that why it's called 'lazy' ? 
05:53:52 <zealman> the language i mean
05:53:58 <shapr> nah, that's a different thing ;-)
05:54:03 <zealman> oh ok
05:54:11 <sjj> hrm, I can't really do it without horrible complexity.
05:54:26 <zealman> so yea
05:54:27 <shapr> zealman: ok, so you know how to add two numbers in a function now
05:54:49 <shapr> what's the type of that function?
05:54:51 <zealman> what if the other one is not a simple type and it consists of both
05:55:22 <shapr> ah, that's a good question
05:55:31 <shapr> how can you get one part of a tuple out?
05:55:37 <zealman>  YES!
05:55:42 <zealman> how would i?
05:55:52 <zealman> then i can perform the simple add function on it
05:55:55 <shapr> right!
05:55:58 <zealman> and return the modified list
05:56:04 <shapr> ok, I'll tell you the secret...
05:56:11 <zealman> :P
05:56:11 <shapr> try this in hugs: "fst (1,2)"
05:56:28 <zealman> brings back 1
05:56:35 <zealman> snd brings back 2?
05:56:37 <shapr> now try "snd (1,2)"
05:56:38 <shapr> tada!
05:56:45 <shapr> zealman: see, you know more than you thought ;-)
05:56:56 <zealman> i know...or at least i think i do
05:57:05 <zealman> i don't ... ahh
05:57:14 <shapr> so the next question, how do you create a new tuple with the result?
05:57:29 <zealman> good question
05:57:29 <shapr> so if you want to take (1,2) and 3 as input
05:57:43 <shapr> and then add the 3 to one part of the tuple.
05:57:43 <zealman> yep
05:57:48 <shapr> well, you know how to add, right?
05:57:53 <zealman> lol 
05:58:00 <shapr> and you know how to get parts out of a tuple right?
05:58:07 <zealman> so to the first part of the tuple
05:58:12 <zealman> that's what gets me confuzzled
05:58:19 <zealman> i'm not sure what order to write it in
05:58:22 <shapr> try it
05:58:24 <zealman> well i am sorta
05:58:29 <zealman> holdup
05:58:38 <shapr> from what I know, humans learn better from mistakes than from successes :-)
05:58:48 <zealman> you'd think i'd learned by now
05:58:56 <zealman> i've bin making them all week
05:58:58 <shapr> so I say try anything that looks like it might work, and see if you can figure out why the failures don't work.
05:59:11 <zealman> i've tried sooo much
05:59:14 <shapr> the whole point of this is to build a mental model of how Haskell works
05:59:27 <shapr> I promise you that learning Haskell will improve you ability to program in other languages also.
05:59:48 <shapr> ahem "you" -> "your"
05:59:59 * shapr is doing paying work at the same time, and so is somewhat distracted
06:00:00 <zealman> well one of my lecturers told me the more effort you put into learning something the more you appreciate it
06:00:04 <zealman> lol
06:00:05 <zealman> true
06:00:06 <shapr> yah, I agree with him.
06:00:21 <sjj> Igloo: hrm, those functions exist in List.hs, so I can use them. huzzah.
06:00:24 <zealman> i used to pretend to do paid work :p
06:01:20 <shapr> zealman: so "addTupleNum x y = " ?
06:02:10 <shapr> you want to input (1,3) as x and 3 as y and get back (4,3) 
06:03:26 <zealman> i tried addTupleNum x y = fst (x,y)
06:06:07 <Vincenz> shapr: yes you're completely right.  Ocaml will improve your ability to program in other languages also. :P
06:06:28 * Vincenz has a 's/Haskell/Ocaml/g' filter on shapr's input
06:06:39 * sjj glares at his code
06:07:52 <shapr> zealman: you need to do both of "get out the first number" and "add two numbers together"
06:07:57 <Vincenz> zealman: addTupleNum x y = ((fst(x) + y),(snd(x) + y))
06:08:12 <shapr> Vincenz: hey, it's his homework, he's suppossed to figure out himself
06:08:16 <zealman> lol
06:08:29 <shapr> mostly because a large part of the skill being developed is "how to figure out things"
06:08:30 <zealman> i've seen that one b4...
06:08:39 <zealman> but its' the figuring out bit
06:08:47 <shapr> yah, called "synthesis"
06:08:47 <Vincenz> wekk
06:08:48 <Vincenz> well
06:08:52 <Vincenz> let me give an explanation :)
06:08:56 <Vincenz> in my x I have my tuple
06:08:59 <zealman> and i was just watching volvo drivin soccer mom by everclear :P
06:09:04 <zealman> yep
06:09:05 <Vincenz> so fst(x) gives me the first part, and snd(x) gives me the second part
06:09:08 <Vincenz> then
06:09:14 <Vincenz> I create a new tuple with the (,) thingy
06:09:18 <Vincenz> and in the first part of it
06:09:19 <Marvin--> you normally don't say fst(x), you just say fst x
06:09:23 <Vincenz> I put the fst(x) + y
06:09:32 <Vincenz> Marvin--: I don't know Haskell
06:09:42 <shapr> yah, Vincenz is an OCaml guy
06:09:48 <shapr> his code has humps ;-)
06:09:54 * Vincenz bops shapr
06:09:58 <Marvin--> Vincenz: which is why I suggested the beautification :)
06:09:58 <Vincenz> heh
06:09:59 <zealman> lol
06:10:04 <Vincenz> alright
06:10:15 <Vincenz> ((fst x) + y, (snd x) + y_
06:10:17 <Vincenz> ((fst x) + y, (snd x) + y)
06:10:18 <Marvin--> it wasn't meant as an insult or criticism
06:10:19 <Vincenz> voila
06:10:26 <Vincenz> I know :)
06:10:35 <Vincenz> I'm just bopping shapr
06:10:39 <Marvin--> you don't need the parentheses around fst x and snd x either
06:10:40 * Marvin-- ducks
06:10:43 <Vincenz> hmm
06:10:45 <Vincenz> you don't?
06:10:53 <shapr> function application binds most tightly
06:10:54 <Marvin--> function application binds harder than all operators
06:10:57 <tez> No, function app has higher precedence.
06:10:59 <Vincenz> oh
06:11:03 <shapr> hi tez
06:11:05 <zealman> hmmf
06:11:06 <shapr> wassup?
06:11:07 <tez> :)
06:11:09 <zealman> interestings
06:11:12 <shapr> zealman: did you absord all that? ;-)
06:11:15 <shapr> absorb
06:11:19 <Vincenz> you're right!
06:11:21 <Vincenz> in haskell too
06:11:23 * shapr is being lysdexic today
06:11:26 <Vincenz> I mean ocaml
06:11:35 <tez> lol
06:11:36 <Vincenz> (fst x + y, snd x + y)
06:11:43 <Vincenz> but
06:11:50 <Vincenz> lets say the first part of x is a function
06:11:56 <Vincenz> fst x y won't work will it?
06:11:57 <shapr> Vincenz: whoa, hang on...
06:12:01 <Vincenz> it'll try to match a function with two params
06:12:02 <shapr> wait for student feedback :-)
06:12:22 <Darius> no it will evaluate (fst x) y
06:12:24 <shapr> zealman: so, can you write the function that takes a tuple and a number and adds the number to one part of the tuple now?
06:12:26 <Vincenz> hmm
06:12:37 <zealman> holdup
06:12:46 <Darius> so x better have type: a -> b for some a and b
06:12:47 <Marvin--> Vincenz: fst (id,id) 3  works just fine
06:12:49 <Vincenz> shapr: yeah wait up, he's trying to absurd
06:12:50 <zealman> i was just tryin it on my main project
06:12:56 <Darius> er (a->b,c)
06:13:01 <sjj> shapr: i'm almost finished my uni compiler stuff, which means more time for fun things! ;)
06:13:01 <Marvin--> exactly
06:13:05 <shapr> sjj: yay!
06:13:08 <Vincenz> alright
06:13:09 <shapr> sjj: write a lambdabot plugin!
06:13:19 <Vincenz> sjj: writing a compiler IS fun
06:13:20 <sjj> shapr: tee-hee. doesn't he already do everything?-)
06:13:25 <shapr> hey, Jens is writing an irc client based on lambdabot sources
06:13:29 <shapr> that's gonna rock :-)
06:13:30 <sjj> Vincenz: well yeah, but not a pointless one for school
06:13:34 <Vincenz> I'm writing one in ocaml at the moment but I'm stuck on a small question and #ocaml is as responsive as ever
06:13:51 <shapr> Vincenz: recruit more people for #ocaml then
06:13:59 <sjj> Vincenz: plus, i'm also writing the interpreter in java, which is less fun
06:14:00 <Vincenz> shapr: what do you think I'm doing here?
06:14:07 <Vincenz> sjj: poor you
06:14:09 <shapr> Vincenz: talking about Haskell ;-)
06:14:12 * Vincenz pats sjj on the back
06:14:18 <sjj> :)
06:14:23 <shapr> everyone loves Java... NOT
06:14:23 * Vincenz doesn't mention his main language is java
06:14:33 <Vincenz> though I'd never write a compiler in java, talk about code-bloat
06:14:34 <shapr> Java is the COBOL of the future imho
06:14:42 <sjj> shapr: YES!
06:14:42 <shapr> I worked on a compiler written in Java
06:14:54 <Vincenz> all those classes instead of just using sumtypes
06:14:57 <shapr> part of the cryptix asn1 toolkit
06:15:00 * Vincenz loves sumtypes
06:15:05 <sjj> shapr: ugh ..
06:15:09 <shapr> yah, it was painful
06:15:20 <shapr> I want a Haskell to JVM bytecode compiler backend
06:15:21 <sjj> people use asn1?-)
06:15:30 <Vincenz> what's asn1?
06:15:33 <shapr> far too many people...
06:15:40 <shapr> abstract syntax notation one
06:15:43 <shapr> aka ASN.1
06:15:46 <Vincenz> hmm...?
06:15:51 <shapr> it's scary
06:15:51 <Darius> There's a JVM backend to GCC and GHC can target GCC.
06:15:54 <Vincenz> what's specific about it wrt AST?
06:16:21 <shapr> Vincenz: urf, long story, I'm too busy to explain at the moment, ask me tonite or tommorow and I'll tell ya
06:16:23 <shapr> or google for it
06:16:26 <Vincenz> k
06:16:30 * Vincenz is already googling
06:16:30 <shapr> Darius: that's a good idea
06:17:15 <Vincenz> oh, communication crap
06:17:27 <zealman> stil doesn't like it
06:17:50 <Vincenz> zealman: like what?
06:17:55 <Vincenz> oh
06:18:06 <Vincenz> hmm, does haskell require a 'let'?
06:18:28 <zealman> i'm trying to map it onto a tuple inside a list of a list
06:18:33 <zealman> if that makes any sense
06:18:36 <Vincenz> oh!
06:18:41 <Vincenz> paste the code in private
06:18:51 <zealman> ?
06:19:03 <Vincenz> copy code from editor, open window "message to vincenz" and paste it :)
06:22:33 <zealman> ?
06:22:35 <zealman> did that wrk
06:23:47 <Vincenz> yup
06:24:29 <Marvin--> hey, I post so much on the debian mailing lists that I've forgotten how fast mailing lists are in reality
06:25:39 <shapr> debian lists aren't real?
06:26:03 <Vincenz> hmm
06:26:07 <Vincenz> for all you unix lovers
06:26:20 <shapr> Riastradh: your mail is bouncing
06:27:33 <Vincenz> how do you map stuff in haskell?
06:27:45 <shapr> map (+1) [1,2,3]
06:27:48 <Vincenz> k
06:28:03 <shapr> you guys can discuss this on the channel if you want
06:28:22 <shapr> actually, I would encourage it...
06:28:41 <shapr> I think that's how channels stay active
06:28:49 <Vincenz> hmm
06:28:51 <Vincenz> alright
06:28:53 <Vincenz> anyways
06:28:59 <Vincenz> for lots of laughs about stuff that's still true
06:29:00 <Marvin--> shapr: they're delayed in an attempt to catch mass-spamming
06:29:00 <Vincenz> http://web.mit.edu/~simsong/www/ugh.pdf
06:29:31 <shapr> Marvin--: smart
06:30:04 <Vincenz> so we have
06:30:04 <Marvin--> Vincenz: why is it called ugh.pdf? wouldn't uhh.pdf be more appropriate? :)
06:30:05 <Vincenz> inflate increase (toys,clients) = (fst toys,snd toys + increase)
06:30:09 <Vincenz> Marvin--: no idea
06:30:18 <Vincenz> toys1 = [("sheep", 2.95),("car", 5.99),("bear",0.0)]
06:30:19 <Vincenz> and
06:30:23 <Vincenz> map (inflate 2.5) toys1
06:30:24 <Vincenz> :)
06:30:53 <Vincenz> shapr: part two you should help 
06:30:59 <Vincenz> so we have: clients = [("mary",["sheep"]),("nicolas", ["car", "bear", "sheep"])]
06:31:08 <zealman> which is the second part of the tuple
06:31:09 <Vincenz> and given a toy like "sheep" find all the clients who have such a sheep
06:31:14 <Vincenz> zealman: snd of course
06:31:22 <zealman> snd :P
06:31:24 <Vincenz> "snd" is short for "SecoND"
06:31:28 <zealman> i know
06:31:30 <zealman> haha
06:31:34 <Vincenz> and well "fst" stands for itself
06:31:43 <zealman> yahuh
06:31:53 <Vincenz> Marvin--: I started reading aprt of it, quite funny and scaringly true
06:31:54 <Vincenz> like...
06:32:01 <Vincenz> if you have a file in your directory called "-r"
06:32:03 <Vincenz> and you do...
06:32:05 <Vincenz> rm *
06:32:10 <Vincenz> bye bye all subdirs
06:33:48 <Marvin--> Vincenz: well, which is why some unix lovers say "UNIX *is* user friendly, it's just picky about its friends!"
06:34:16 <Vincenz> hehe :)
06:34:23 <Vincenz> unix is like c++
06:34:32 <Vincenz> screw a small thingy and you're completely fucked
06:34:45 <Vincenz> l
06:34:54 <shapr> that's why users don't have sysadmin privs
06:35:11 <dennisb> what if you have a file called "; rm -rf /" and do ls
06:35:12 <Marvin--> I mean, there *are* graphical file browsers that are quite good, if you're afraid of the command line, don't use it
06:35:24 <dennisb> or ls *
06:35:25 <Marvin--> dennisb: unless you have a broken shell you're safe
06:35:38 <Marvin--> it should first parse and then expand
06:35:40 <dennisb> so, where do I find a broken shell then
06:35:49 <Marvin--> I dunno, write one yourself, I guess
06:36:28 <Vincenz> Marvin--: I don't know....I've heard unix expands first
06:36:45 <Igloo> Each thing a glob expands to is passed to the program as a separate argument
06:36:51 <Vincenz> oh!
06:36:53 <Igloo> so ls would get "; rm -rf /" as an argument
06:37:00 <Janni> ph34r m1 sk1llZ !!1
06:37:04 * Vincenz slaps jak
06:37:06 * Vincenz slaps Janni
06:37:07 <Vincenz> l
06:37:15 * shapr slaps lambdabot 
06:37:19 * Janni doges
06:37:22 <Vincenz> ugh, I have to get away from this intinct of typing "l"
06:37:28 <Vincenz> instinct even
06:37:37 <Marvin--> Vincenz: yeah, you're missing the leading "as"
06:37:45 * Janni casts a +3 firebolt at Vincenz
06:37:50 * Marvin-- ducks again
06:37:52 <Vincenz> Marvin--: no it's mud
06:38:04 <Vincenz> short for l(ook)
06:38:22 <Marvin--> heh, man I had that reflex a long time too
06:38:28 <Marvin--> I don't remember how long I had alias l=ls
06:39:44 <Janni> Marvin: That's a good idea when using Dvorak keyboard layout, becaus for "ls<return>" you have to use the same finger three times...
06:39:50 <zealman> i iz still geting a type error in appln
06:39:53 <zealman> :(
06:40:21 <Janni> But when I get my Kinesis, <return> will be pressed by the thumb...
06:40:41 <Vincenz> hehe
06:40:52 <Vincenz> Marvin--: Ugh on the idiosyncrasies of c++
06:40:52 <Vincenz> double qdiv (p, q)
06:40:52 <Vincenz> double *p, *q;
06:40:52 <Vincenz> {
06:40:52 <Vincenz> return *p/*q;
06:40:53 <Vincenz> }
06:40:58 <Vincenz> note the /*
06:41:04 <Janni> "i iz" <- It's not leet-speach, but what is it?
06:41:17 <Vincenz> Janni: that's dumbspeech
06:41:19 <zealman> its australian
06:41:23 <zealman> touche
06:41:24 <SyntaxPolice_> hiya
06:41:25 <Vincenz> oh oops
06:41:38 <Vincenz> I thought it was a french speaking english
06:41:45 <zealman> lol
06:41:53 <zealman> we're clearly in different modes
06:42:04 <Vincenz> so how many people are reading ugh.pdf?
06:42:11 <Vincenz> zealman: you're so vimmy
06:42:11 <zealman> i'm feelin it
06:42:21 <zealman> huh
06:42:54 <Darius> Vincenz: that isn't C++, that's ancient C
06:43:03 <Vincenz> is it?
06:43:05 <Vincenz> nope
06:43:09 <Vincenz> or wait
06:43:18 <shapr> Darius: hey, are you still using dvorak?
06:43:24 <Darius> Yes
06:43:25 <Vincenz> well the idea is in the /*
06:43:28 <shapr> yay!
06:43:39 <shapr> Darius: you don't seem slowed down at all
06:43:48 <zealman> don't start with pointers my brain hurts enough as it is
06:44:01 <shapr> Darius: are you as fast with dvorak as you were with qwerty?
06:44:02 <Janni> Australian heat?
06:44:05 <Darius> Vincenz: Hmm, I've never had that problem, why cause in C++ you use references
06:44:18 <Vincenz> it's not coming from me, read ugh.pdf
06:44:20 <Darius> shapr: more or less
06:44:26 <zealman> australian heat?
06:44:38 <shapr> any comments on dvorak vs qwerty or switch to dvorak?
06:46:03 <zealman> i hear dvorak is 10 percent faster
06:46:09 <Darius> not really, I've thought dvorak was a better layout since I first heard of it, I just never bothered to switch
06:46:24 <zealman> or get a court stenographer layout...300 wpm
06:46:29 <zealman> talking speeed :D
06:46:56 <shapr> how many dvorak and/or kinesis users here?
06:46:58 * shapr has both
06:47:04 <zealman> kewl
06:47:13 <zealman> ughh....i'm going nowhere
06:47:33 <shapr> zealman: I think you're making progress
06:47:48 <zealman> i could answer ques in an exam
06:47:51 <Vincenz> zealman: yes grasshopper, the first part in making progress is realizing you're going nowhere
06:47:54 <zealman> i think...no don't quote me on that
06:48:14 * Janni is repeating himself when saying he's using Dvorak and will be using a Kinesis as well, when the dumb resellers answer on his emails :(
06:48:26 <zealman> dom origato vicenz san and shapr san
06:48:58 <Darius> domo
06:49:06 <shapr> yazok!
06:49:06 <zealman> one char out
06:49:11 <zealman> :p
06:49:19 <zealman> i gotta hand this thing in tommorow
06:49:27 <zealman> :P
06:49:40 <shapr> zealman: I have a brilliant suggestion... start on an assigment when you are given that assignment.
06:49:45 <zealman> i did
06:50:01 <shapr> good deal :-)
06:50:02 <zealman> but times that by 5...i like to go slow
06:50:17 <shapr> I try to finish my stuff so I can go do fun things.
06:50:24 <zealman> me too
06:50:26 <zealman> but i'm just slow
06:50:35 <Janni> shapr: Isn't it always the same?
06:50:42 <Vincenz> so is dvorak better than qwerty?
06:50:43 <shapr> what?
06:50:45 <shapr> Vincenz: I think so
06:50:53 <Vincenz> on what basis?
06:51:17 <Janni> Having to finish duties to go do fun things
06:51:24 <shapr> common vowels are under your left hand home row, common consonants under the right
06:51:28 <Vincenz> but all you people should download 4,10http://web.mit.edu/~simsong/www/ugh.pdf and read it !!!
06:51:29 <shapr> Janni: not for everyone
06:51:43 <Vincenz> hmm
06:51:46 <Janni> Yes, for me, for example
06:51:47 <shapr> Vincenz: what's the most common letter in english/french/dutch ?
06:51:58 <Vincenz> I don't know...what if you've been using qwerty for a long while?
06:52:00 <Vincenz> shapr: e or a
06:52:11 <Vincenz> italian I'd say a or o
06:52:16 <Janni> I'm done with school (almost :)
06:52:17 <Vincenz> dutch e
06:52:19 <Vincenz> english e
06:52:26 <Vincenz> french...a or e..not sure
06:52:35 <shapr> Vincenz: assuming you can touchtype, what would be the most efficient location for those letters?
06:52:40 <Vincenz> hmm
06:52:45 <Vincenz> I guess...
06:52:46 <Vincenz> but!
06:52:48 <Vincenz> look at it this way
06:52:57 <Darius> It's 360 pages!
06:53:01 <Vincenz> you go to your friend: they have azerty, you go to work they have qwerty....
06:53:10 <Vincenz> so...
06:53:20 <shapr> Vincenz: I can still type on azerty, qwerty, swedish, etc
06:53:20 <Vincenz> besides I'm used to qwerty
06:53:29 <shapr> but at home I type on dvorak, and quickly
06:53:35 <Vincenz> kinesis?
06:53:38 <shapr> yup
06:53:40 * Vincenz drools
06:53:53 <shapr> qwerty typists look to me like they're jumping all around the keyboard for not so much typing
06:55:55 <Vincenz> i guess
06:56:02 <Vincenz> it take a long while to get used to tho
06:56:13 <Vincenz> and most editors bind movement to awsd
06:56:20 <Vincenz> games too
06:56:20 <BlitzNL> I get this strange error in Hugs: *** Expected type : Eq a => Tree a -> HCode -> [a]
06:56:20 <BlitzNL> *** Inferred type : Eq _63 => Tree _63 -> HCode -> [_63]   
06:56:30 <BlitzNL> anyone knows the problem?
06:56:46 <Vincenz> do a search and replace on _63 and a
06:58:17 <zealman> ...
06:58:34 <shapr> Vincenz: a lot of people are used to windows, to C, to lots of things
06:59:12 <Vincenz> don't bash windos
06:59:17 <Vincenz> it's not that bad
06:59:22 <shapr> I continually try new things, hoping to find something more powerful, more userfriendly, more something
06:59:24 <Vincenz> I've used linux, I've used windows
06:59:34 <Vincenz> and I've tried a dozen programming languages
06:59:55 <Vincenz> but!
07:00:00 <Vincenz> I don't have the money for a kinesis
07:00:12 <Vincenz> well I do...but it's a steep price
07:00:24 <zealman> ...
07:01:35 <Vincenz> zealman?
07:01:42 <zealman> i can't figure out the errors...
07:01:50 <zealman> its driving me insane
07:01:52 <zealman> :P
07:01:56 <shapr> Vincenz: you could try dvorak with no extra cost
07:02:10 <Vincenz> how?
07:02:25 <Vincenz> zealman: which errors?
07:02:41 * Vincenz 's leftpinky hurts from typing
07:02:56 <shapr> remap your keyboard
07:03:03 <shapr> you don't need to change the keycaps, just the mappings
07:03:15 <zealman>  Expression     : fst toys
07:03:15 <zealman> *** Term           : toys
07:03:15 <zealman> *** Type           : [([Char],Float)]
07:03:15 <zealman> *** Does not match : (a,b)
07:03:40 <shapr> the square brackets around it mean it's a list of tuples
07:03:41 <zealman> does it on the snd toys too...
07:04:03 <shapr> list of tuple of list of char and float
07:04:06 <zealman> mm.... the char bit is a list of characters inside a tuple with a float as the 2nd tuple
07:04:14 <zealman> inside a list
07:04:18 <Vincenz> I told you to
07:04:22 <Vincenz> map (inflate 2.5) toys1
07:04:23 <Darius> @type fst
07:04:24 <lambdabot> fst :: (a,b) -> a
07:04:24 <lambdabot> [-DONE-]
07:04:31 <Vincenz> @type plop
07:04:42 <zealman> i can't make up a new fn
07:05:00 <zealman> unless i use it as part of the original specified one
07:05:02 <zealman> :P
07:05:17 <phubuh> whee
07:05:19 <phubuh> Main> renderList (factorizeAddition 27)
07:05:19 <phubuh> ">+++++[<+++++>-]<++"
07:05:46 <Vincenz> phubuh: fck?
07:05:51 <phubuh> fck?
07:05:56 <Vincenz> what's that language called?
07:06:00 <phubuh> oh, brainfuck
07:06:03 <Vincenz> yes
07:06:11 <Vincenz> is that brainfuck?
07:06:19 <phubuh> here's a better demonstration by the way
07:06:22 <phubuh> Main> renderList (factorizeAddition 30)
07:06:22 <phubuh> ">+++++[<++++++++++>-]<"
07:06:25 <phubuh> :-)
07:06:27 <phubuh> yes, that's brainfuck
07:06:39 <phubuh> it adds 30 to the current cell in memory
07:06:42 <Vincenz> ever seen fuckfuck?
07:06:45 <phubuh> hah, no
07:06:49 <Vincenz> it's really funny
07:07:04 <Vincenz> works on the same principle of brainfuck
07:07:18 <Vincenz> http://www.chilliwilli.co.uk/ff/
07:07:35 <Vincenz> especially the part on syntax :P
07:07:38 <Vincenz> f**k
07:07:41 <Vincenz> Increment the pointer. 
07:07:47 <Vincenz> and you may change the * by letters
07:07:56 <Vincenz> as long as it's four letters starts with [Ff] and ends with [Kk]
07:08:04 <phubuh> haha
07:08:20 <Vincenz> you also have s**g, b**b, t**s, c**k, k**b, a**e, and b**t
07:08:29 <Vincenz> plus, if y ou want to repeat things you use !
07:08:31 <Vincenz> so you have code like
07:08:35 <Vincenz> FUCK!!! Tits! 
07:08:41 <phubuh> oh, cool
07:08:41 <Vincenz> and it actually compiles
07:09:02 <Vincenz> some people write the oddest interpreters
07:09:23 <Vincenz> here is helloworld in f*ckf*ck
07:09:25 <Vincenz> http://www.chilliwilli.co.uk/ff/hello.ff
07:09:51 <Vincenz> F*ckF*ck: Possibly the most vulgar programming language in existance
07:09:56 <Vincenz> Guaranteed to have you swearing!
07:10:09 <Vincenz> well that's enough of my spam, back to ocamlyacc
07:12:25 <phubuh> what should s**g be?
07:13:20 <phubuh> shag? :-)
07:13:37 <Vincenz> I think s
07:13:38 <Vincenz> so
07:13:56 <Vincenz> reminds me of moo
07:13:58 <Vincenz> same principle
07:14:16 <Vincenz> except all the instructions are the word moo with different capitalization
07:14:57 <Vincenz> they're all basically the same, while !0, (in/de)crease point(er/ee)
07:15:04 <zealman> hmm
07:15:08 <zealman> it works but it doesn't
07:15:10 <zealman> :P
07:15:13 * shapr fight openoffice
07:17:34 <zealman> ...
07:18:36 <Marvin--> damn
07:19:31 <phubuh> how can i transform [1, 2, 3] and [5, 6, 7] to [1, 5, 2, 6, 3, 7]?
07:20:12 <Vincenz> isn't that zipping?
07:20:25 <phubuh> that'd make [(1, 5), (2, 6), ...]
07:20:28 <Vincenz> oh
07:20:40 <phubuh> actually a more accurate question is how can i convert ["foo", "bar", "baz"] to "foo bar baz"
07:20:57 <Darius> that's easy, intersperse
07:21:03 <Vincenz> how come haskell has [,,] and ocaml has [;;] ?
07:21:27 <Darius> 'Cause OCamlers aren't sensible
07:21:36 <phubuh> ah, thanks darius
07:22:19 <Darius> *MLers in general are backwards.
07:22:36 <Vincenz> hey ocaml is a neat language
07:22:47 <Darius> a backwards neat language
07:22:53 <zealman> what does this mean *** Term           : (fst toys,snd toys (map (flip (+) increase)))
07:22:54 <zealman> *** Type           : (a,b)
07:22:54 <zealman> *** Does not match : ((a,([Float] -> [Float]) -> b),b)
07:22:54 <zealman> *** Because        : unification would give infinite type
07:22:59 <Vincenz> Darius: why?
07:23:06 <Darius> datatypes
07:23:33 <Darius> or probably more specifically type constructors
07:23:38 <zealman> hmmf
07:23:42 <phubuh> heh, vincenz, i made a new frontend to the brainfuck thing
07:24:01 <Vincenz> phubuh: like f*ckf*ck?
07:24:08 <phubuh> yeah, it outputs f*ckf*ck
07:24:08 <Vincenz> Darius: why do you hate ocaml?
07:24:16 <Vincenz> oh!
07:24:19 <Vincenz> hehe
07:24:38 <Darius> Impurity, backward type constructors
07:25:04 <Vincenz> backward type constructors?
07:25:16 <Vincenz> and impurity is a good thing pragmatically speakig
07:25:31 <Marvin--> not if you want purity though ;)
07:25:51 <Vincenz> I think ocaml made a good tradeoff
07:25:56 <phubuh> Main> renderFfList (factorizeAddition 57)
07:25:56 <phubuh> "fuck boob!!!!!! arse shag boob!!!!!!!!!!!!!! fuck tits butt shag boob"
07:25:57 <phubuh> :-)
07:26:04 <Vincenz> phubuh lol!
07:26:18 <Vincenz> now you have to randomize the capitalization
07:26:25 <phubuh> oh yes, i was just thinking about that
07:26:26 <Vincenz> makes it sound even worse
07:26:44 <Vincenz> what's Main>
07:26:44 <Vincenz> ?
07:26:52 <phubuh> the hugs shell
07:26:58 <Vincenz> oh
07:27:05 <Darius> I'd randomize on a word basis, not a letter one
07:27:12 <Vincenz> sounds good
07:27:15 <shapr> phubuh: Mr Tourette?
07:29:08 <Vincenz> Mr Tourette/
07:29:09 <Vincenz> ?
07:29:55 <zealman> im outta hair like a bald man
07:30:02 <zealman> thanks for your help people
07:30:11 <Darius> Tourette's syndrome (I guess that's how it's spelled)
07:38:05 <Vincenz> oh
07:38:06 <Vincenz> adhd
07:56:58 <Vincenz> ugh I was reading ugh too much
08:27:45 <martini> whats the M-x command for color coding?
08:27:51 <martini> tmoertel, u there, u told me the other day
08:30:54 <shapr> martini: using gnu emacs or Xemacs?
08:31:19 <shapr> hi fabs 
08:31:26 <fabs> hey. I'm rather new to haskell and come from c and I'm having some problems with the syntax of defining data-structures in haskell. In this line: "data Stack a = Empty | Head a (Stack a)" What are "Head" and "Empty"? Are they type-names or function-names or simply bare-words? Please help out :/
08:31:34 <fabs> hey shapr
08:31:45 <shapr> fabs: they're data constructors.
08:32:13 <shapr> the Maybe type is a bit simpler, it's "data Maybe a = Nothing | Just a"
08:32:28 <shapr> so the type is Maybe a
08:32:35 <shapr> and it can be one of two things
08:32:41 <shapr> a Nothing
08:32:45 <shapr> or Just something
08:33:08 <ibid> fabs: think of them as union tags :-) (constructor is the correct term)
08:33:12 <shapr> fabs: you may find it easier to start with something like "data Seasons = Winter | Summer | Spring | Autumn"
08:34:24 <ibid> (union tags is an imperfect analogy)
08:34:55 <shapr> martini: if you're using Gnu Emacs, try M-x global-font-lock-mode
08:35:03 <shapr> martini: if it's XEmacs, try M-x font-lock-mode
08:35:35 <opet> nobody happens to have a fairly complicated excel sheet sitting around do they?
08:35:55 <kosmikus> actually, constructors are just functions that are defined with the datatype
08:36:03 <kosmikus> you can ask for their type in ghci or hugs
08:36:03 <ibid> kosmikus: not quite
08:36:10 <ibid> kosmikus: but close
08:36:10 <kosmikus> yes, I know
08:36:17 <fabs> Ok, so the line is saying "I have a type called Stack and it is either Empty or it has a Head of type a and a Stack of type a"?
08:36:18 <kosmikus> I was getting to that ;)
08:36:28 <shapr> fabs: yup
08:36:33 <fabs> :)
08:36:50 <ibid> fabs: no, its either Empty or it is a Head with one element of type a and another of type Stack a
08:36:53 <shapr> fabs: the nice thing about the "of type a" means that you can make a Stack that holds any type.
08:37:16 * shapr rereads that
08:37:49 <shapr> I don't see the difference?
08:38:31 <ibid> shapr: "has a Head of type a and a Stack of type a" parses Head a (Stack a) as (Head a) (Stack a)
08:38:42 <ibid> which is wrong
08:38:43 <kosmikus> Empty :: Stack a
08:38:43 <shapr> ohh!
08:38:46 <shapr> I see!
08:38:48 <kosmikus> Head :: a -> Stack a -> Stack a
08:38:54 <ibid> true
08:39:27 <kosmikus> The difference between a constructor and an ordinary function is that you can pattern-match on constructors.
08:39:33 <ibid> true
08:39:39 <kosmikus> :)
08:39:54 <martini> hey, sorry, using Xemacs
08:40:21 <fabs> oh, so in the code I posted, the Head has actually become a data-structure holding a head of a stack and the whole rest of the stack? So calling it head was wrong cause it's not just the head?
08:40:27 <shapr> martini: if the buffer is not in haskell-mode already, you can hit M-x haskell-mode
08:40:30 <martini> so use...  try M-x font-lock-mode
08:40:44 <shapr> martini: if you are in haskell-mode but you don't have pretty colors, then hit M-x font-lock-mode
08:40:50 <ibid> fabs: yeah, i use Empty and NonEmpty usually
08:41:20 <martini> yeah, i want the color coding, makes it easier to read...THANX :)
08:41:23 <Vincenz> if that doesn't work
08:41:24 <kosmikus> or [] and (:) ?
08:41:30 <Vincenz> type C-M-DEL
08:41:44 <shapr> Vincenz: oh be nice :-P
08:41:45 <ibid> kosmikus: [] and (:) cannot be user-defined afaik :-)
08:41:51 <ibid> (unless you do tricks)
08:41:53 <shapr> Vincenz: there's also C-M-BS
08:41:57 <Vincenz> hmm
08:42:00 <Vincenz> not aware of that one
08:42:01 <kosmikus> no, but Stack is isomorphic to []
08:42:05 <ibid> true
08:42:08 <Vincenz> doesn't do anything :P
08:42:08 <shapr> Vincenz: it only works on X
08:42:11 <Vincenz> ah
08:42:23 <shapr> Vincenz: are you using one of those closed source OSes or something?
08:42:26 <shapr> or console-mode?
08:42:27 <delYsid> well, C-_ is always helpful :)
08:42:32 <fabs> AH! Now things get clearer! Yeah, now I also understand the rest of the code. Thx :)
08:42:34 <martini> do i need to restart haskell for the colors to work??
08:42:40 <Vincenz> I'm working under ...no...NOOOOOO...WINDOWS XP!
08:42:42 <shapr> martini: huh?
08:43:09 <shapr> uh oh, he must have hit C-_
08:43:27 <Vincenz> C-_ ?
08:43:43 <martini> i hit m
08:43:45 <martini> or alt x
08:43:54 <Vincenz> M-F4
08:43:55 <shapr> martini: I open a file named Foo.hs, that buffer is in haskell-mode, and shows me pretty colors.
08:43:55 <martini> it loaded something
08:43:57 <martini> but fast
08:44:25 <shapr> martini: when you open a file named Something.hs is the buffer in haskell-mode?
08:45:10 <shapr> martini: you can tell if it's in haskell-mode by seeing "Haskell" in the mode-line
08:45:16 <martini> where are these files saved to??
08:45:19 <martini> the xemacs folder?
08:45:23 <shapr> what files?
08:45:28 <martini> theres only one color coming up.....green
08:45:41 <shapr> martini: what operating system?
08:46:01 <martini> win 98
08:46:09 <martini> the something.hs file
08:46:13 <martini> foo.hs
08:46:33 <shapr> XEmacs decides what major mode to use by looking at the characters at the end of the file
08:46:34 <hdaume> hi all
08:46:36 <shapr> hi hal
08:46:55 <shapr> martini: normally, haskell-mode is invoked on any files ending with .hs or .lhs
08:47:34 <shapr> martini: if you have a haskell source file on your drive, and you open it with XEmacs, is the buffer immediately in haskell-mode, or do you have to manually switch it there?
08:48:16 <martini> manually
08:48:19 <martini> file by file
08:48:25 <shapr> ok, we can fix that.
08:48:39 <martini> each time i load it up, got to do M-x.......
08:48:41 <shapr> do you have a %HOME% environment variable defined in your autoexec.bat ?
08:48:47 <martini> but its only show green for certain parts
08:48:56 <martini> i dont know
08:48:59 <shapr> delYsid: did you hit the dreaded C-_ ?
08:49:08 <delYsid> shapr: erm
08:49:11 <martini> dont know much about autoexec.bat
08:49:17 <delYsid> shapr: It seems the heat here fried my brain
08:49:21 <martini> just that its like shell scripting right?
08:49:22 <shapr> martini: do you know if you have a directory where XEmacs saves its settings?
08:49:31 <shapr> martini: yah, sort of...
08:49:32 <delYsid> I was blindly trying what C-M-DEL actually does in emacs....
08:49:34 * delYsid shakes head
08:49:52 <martini> shapr.....is that the .emacs file?
08:49:57 <martini> that saves settings?
08:50:06 <delYsid> you save your settings in .emacs
08:50:08 <delYsid> by editing it
08:50:12 <shapr> delYsid: heh, reminds of the time deego said we should all try C-h k C-M-BS on our system
08:50:25 <shapr> since C-M-BS kills the X server immediately, half the channel disappeared ;-)
08:50:33 <delYsid> hehe
08:50:42 <delYsid> screen
08:50:50 <shapr> I wish I had a log of that
08:50:55 <martini> shapr, got .emacs loaded
08:50:56 <shapr> martini: yes, the .emacs file
08:50:56 <delYsid> but who actually knows about screen these days.....
08:51:02 <shapr> me me! I use screen!
08:51:02 <martini> opened it in xemacs
08:51:09 <shapr> martini: excellent, add these lines:
08:51:26 <shapr> err
08:51:34 <delYsid> err is not a valid lisp expression
08:51:42 <shapr> :-P I'm hacking them up
08:51:50 <shapr> (setq auto-mode-alist (cons '("\\.hs$" . haskell-mode) auto-mode-alist))
08:51:50 <shapr> (setq auto-mode-alist (cons '("\\.lhs$" . literate-haskell-mode) auto-mode-alist))
08:51:53 <shapr> those two lines
08:52:06 <delYsid> er
08:52:10 <delYsid> those are default in debian
08:52:34 <shapr> he's using win98
08:52:43 <shapr> er, I'll be back in fifteen mins or so, gotta go shopping
08:52:49 <martini> where do i had them?
08:53:04 <martini> under the setq...../lib/emacs.....
08:53:25 <Segora> martini: doesn't matter.
08:53:33 <martini> ok, i'll try
08:56:48 <martini> still only showing green
08:56:54 <martini> two lines put in and saved
08:57:03 <martini> restarted xemacs
08:59:35 <martini> still not working....still green, got to reload each time
08:59:52 <karingo> is there a version of emacs in haskell and where?
09:04:56 <elmex> hi
09:07:14 <delYsid> karingo: hhaha
09:07:27 <delYsid> karingo: no, there is none
09:07:44 <delYsid> and I'd doubt someone could write a functionally equivalent version in <5 years
09:09:11 <delYsid> esp. because Emacs without a lisp engine is just not emacs.
09:11:21 <karingo> is there a limited sub set of emacs in haskell?
09:15:32 <hdaume> karingo: no, why do you want such a thing?
09:17:34 <karingo> i want to give it, the ent.
09:18:32 <BlitzNL> It seems that for some functions that occur in the were clause of another it is not possible to supply a type-definition?
09:18:41 <BlitzNL> s/were/where
09:19:08 <hdaume> BlitzNL: sure it is
09:19:11 <hdaume> foo = bar
09:19:14 <hdaume>     where bar :: Int -> Int
09:19:16 <hdaume>           bar = id
09:19:49 <Smerdyakov> karingo, are you a fan of Haskell now, over elisp?
09:20:29 <BlitzNL> hdaume: ok but not if you have something like : 
09:20:39 <BlitzNL> foo:: Bla a -> Int
09:20:43 <BlitzNL> foo x = bar x
09:21:04 <BlitzNL>   where bar :: Bla a -> Int
09:21:33 <hdaume> oh, you mean because the 'a's aren't the same?
09:22:20 <BlitzNL> well I don't really know why it is, but I run into it ;)
09:22:36 <hdaume> what about:
09:22:59 <hdaume> foo (x::Bla a) :: Int = x  where { bar (y::Bar a) :: Int = ... }
09:23:04 <hdaume> i think that should be okay
09:23:07 <hdaume> maybe even 
09:23:19 <hdaume> foo (x::Bla a) = bar x where { bar :: Bla a -> Int ... }
09:23:21 <hdaume> i'm not sure though
09:23:36 <BlitzNL> well I have this :
09:23:37 <BlitzNL> decodeData :: Tree a -> HCode -> [a]
09:23:37 <BlitzNL> decodeData tr = decodetree tr []
09:23:37 <BlitzNL>   where 
09:23:37 <BlitzNL>     decodetree :: Tree a -> HCode -> [a]
09:23:38 * shapr returns
09:24:13 <BlitzNL> the implementation of decodetree USES tr, and now it have to comment-out the decodetree :: Tree a -> HCode -> [a] part to make it work
09:24:20 <hdaume> uhm
09:24:21 <shapr> aww
09:24:26 <hdaume> your type sig for decodetree is wrong
09:24:27 <shapr> I was going to talk about emacs in Haskell
09:24:44 <hdaume> it should be 'Tree a -> [something] -> HCode -> [a]' or something like that
09:24:56 <BlitzNL> hehe, yeah Hugs says it should be : Tree _62 -> HCode -> [_62]    ;)
09:25:31 <Segora> shapr: yeah. including the ability to load emacs lisp source and byte code. ;)
09:25:58 <shapr> there are editor combinators
09:26:10 <Segora> where?
09:26:14 <shapr> and there's HBase and Michael Sperber's elisp to scheme code
09:26:17 <BlitzNL> hdaume: what is the 'something'?
09:26:22 <shapr> so it could be done
09:26:41 <shapr> Segora: I think Meijer did the editor combinators
09:26:54 <shapr> the elisp engine would be the most interesting part
09:27:20 <Segora> <- searching...
09:28:43 <BlitzNL> hdaume: ow ic now the [] typed in 'decodetree tr []
09:28:44 <hdaume> BlitzNL: i don't know, but if decodeData is Tree a -> HCode -> [a], then 'tr' is Tree a and there's a eta-reduced argument of type HCode.  you then call 'decodetree tr []' which means that decodetree takes tr (a Tree a), some list ([something]) and then that HCode
09:28:47 <BlitzNL>  was not correct.
09:28:49 <hdaume> yeah :)
09:33:29 <BlitzNL> that was a typo from my part, but the problem remains. The thing is I guess that the type of decodeData states that there is a Tree a, but since decodetree get applied to the argument passed to decodeData it should be an instance of that and therefore the typesystem specialized over (\/a.Tree) yielding (_62) or something similar.. Mmm they never mentioned this in my typing systems introductory course ;)
09:37:56 <shapr> I wonder if michael sperber's elisp to scheme code could be extended to soft typing
09:38:00 <shapr> that's sort of what it does now
09:41:53 * shapr finishes applying safety equipment
09:41:57 <shapr> unicycling, bbl
09:42:04 <BlitzNL> I found out that I can reproduce the type error: 
09:42:04 <BlitzNL> test :: [a] -> [a]
09:42:04 <BlitzNL> test is = test' is
09:42:04 <BlitzNL>   where
09:42:04 <BlitzNL>     test' :: [a] -> [a]
09:42:05 <BlitzNL>     test' (x:xs) = xs ++ test' is
09:42:38 <hdaume> what's the error msg
09:42:54 <BlitzNL> hdaume : Inferred type : [_11] -> [_11]    ;)
09:43:41 <BlitzNL> hdaume : it's because I use the 'is' in the second part
09:43:47 <hdaume> right
09:43:52 <Vincenz> odd
09:44:09 <BlitzNL> this is just a restriction to the type system I guess
09:44:10 <hdaume> becaue when you say 'test' :: [a] -> [a]', this means 'test' :: forall a . [a] -> [a]'
09:44:23 <hdaume> but you don't want forall -- you want the same a as before
09:44:47 <hdaume> try replacing 'test is = test' is' with 'test (is :: [a]) = test' is' and see if it works
09:44:48 <Vincenz> heh
09:45:20 <BlitzNL> hdaume: exactly , but I can't express that in a type signature!
09:45:30 <hdaume> no, you cant'
09:45:32 <BlitzNL> hdaume : no it yields Inferred type : [_21]      on the [a]
09:46:02 <Vincenz> BlitzNL: doesn't that create an unendless list of the first element of a list?
09:46:08 <hdaume> stupid hugs :).  it works in ghc(i)....because ghc does stuff about this (some paper by spj exlains it)
09:46:37 <hdaume> i don't think there's a way around it in hugs
09:46:46 <BlitzNL> hdaume : which paper, I'd  like to read it..
09:46:56 <hdaume> it's just an unfortunate side-effect of the implicit universal quantificiation
09:47:22 <hdaume> http://www.research.microsoft.com/~simonpj/papers/scoped-tyvars/
09:47:44 <BlitzNL> hdaume: thnx!
09:49:08 <Vincenz> heh
09:49:12 <Vincenz> works fine in ocaml, HA!
09:49:21 <Vincenz> # let test ls = 
09:49:21 <Vincenz>   let rec test' = function
09:49:21 <Vincenz>   | [] -> []
09:49:21 <Vincenz>   | x::xs -> List.concat [xs; test' ls] in
09:49:21 <Vincenz>   test' ls;;
09:49:22 <Vincenz> val test : 'a list -> 'a list = <fun>
09:49:42 <Vincenz> but isn't that an infinite list?
09:49:46 <hdaume> Vincenz: it works fine in haskell too if you don't supply type sigs, as you haven't in ocaml
09:49:48 <Vincenz> I mean...an infinite function?
09:50:27 <Vincenz> basically....you're concatenating the tails of is an infinite times to itself
09:50:38 <hdaume> "head (test [1])" works fine in Haskell...why don't you try that in ocaml :)
09:50:48 <Vincenz> I know that...lazy eval and stuff
09:50:50 <Vincenz> but what's the use?!?
09:50:53 <hdaume> :)
09:50:57 <hdaume> it's just an example function
09:50:58 <Vincenz> besides, Ocaml has a lazy module
09:51:07 <Vincenz> I just don't know how to work with it
09:51:38 <Vincenz> is there such a thing as lex and yacc for haskell?
09:51:46 <hdaume> Vincenz: yes, happy
09:52:04 <Vincenz> k
09:52:54 <Segora> .. and even better: Parser Combinators. :)
09:53:06 <Vincenz> ?
09:53:26 * Vincenz 's syntax has 62 shift-reduce conflicts
09:53:29 <Vincenz> :P
09:53:49 <Segora> so?
09:54:51 <Vincenz> never mind
09:54:52 <Segora> buy a faster computer and use LL(k) ;)   *run&hide*
09:56:17 <Vincenz> lol
09:56:26 <Vincenz> will you write the parser?
09:56:48 <Segora> sure, recursive descent, manually implemented ;)
09:57:08 <Vincenz> damnit
09:57:17 <Vincenz> ocamlyacc doesn't have the %change directive
09:58:33 <Segora> hmm. what does %change do? I can't find it in the bison docs.
09:59:21 <Vincenz> heh
09:59:26 <Segora> is this special to berkeley yacc?
09:59:30 <Vincenz> from that paper
09:59:44 <Vincenz> GHC now embodies the type-sharind design.  It turns out that O'Caml also uses a similar scheme.
09:59:49 <Vincenz> and...
10:00:03 <Vincenz> %change is used for errorrepair
10:00:18 <Vincenz> it seems ML-yacc (for SML) supports it
10:00:29 <Vincenz> (I'm learning on compiler construction with a book based on SML)
10:01:10 <Segora> ah. thank you.
10:01:32 <Vincenz> welcome :)
10:01:41 * Vincenz flips to chapter 4, AST-generation
10:02:57 <hdaume> Vincenz: is this appel?
10:02:59 <Segora> it seems like ages ago that I completed the compiler construction exam even though it's only a little more than a year....
10:03:04 <Vincenz> hdaume yes:)
10:03:14 <Vincenz> I had the "... in C" version from college
10:03:17 <Vincenz> but taht was suicide
10:03:23 <hdaume> i had the java version :)
10:03:24 <Vincenz> so I ordered the "...in ML" version
10:03:33 <Vincenz> they text is EXACTLY the same, but it's worth it
10:03:41 <Vincenz> s/they/the
10:03:48 <Vincenz> only diff is in the sample codes
10:03:55 <Vincenz> where they show part of the compiler
10:04:11 <Vincenz> hdaume: you ..."had" ?
10:04:33 <hdaume> yeah....my roommate and i both took the class so we only bought one copy...he has it now
10:04:39 <Vincenz> ah
10:05:12 * Vincenz should really clean out his "My Documents\coding" directory
10:05:43 <Vincenz> 11402 files, 694 maps, 653 MB
10:27:13 <ham[let]> hiho
10:33:36 <shapr> ow
10:36:34 <Marvin--> dammit, this isn't good
10:37:33 <shapr> what?
10:37:48 <Marvin--> it's kinda hard to test my program on *correct* specifications
10:38:00 <shapr> why?
10:38:06 <shapr> ohh
10:38:10 <shapr> you need something that's broken?
10:38:28 <shapr> I think QuickCheck needs a "broken" method in the Arbitrary typeclass
10:38:37 <shapr> somehow generate things that are slightly off
10:38:48 <Marvin--> I need an incorrect specification or an incorrect program
10:38:52 * shapr picks gravel out of his palms
10:39:02 <shapr> tomorrow I'm getting hand stopper thingies
10:39:09 <Marvin--> LOL
10:39:57 <shapr> I had a rather spectacular dismount that involved a white picket fence
10:41:33 <Marvin--> ouch
10:42:21 <shapr> at least I made it ten meters or so unassisted!
10:42:25 * shapr bounces happily
10:42:51 <shapr> oh, Peter Simons suggested that we reorganize haskell-libs in such a way that you can check it out directly into your GHC library dirs
10:42:53 <Marvin--> hrrrm, this seems to be incorrect, though I don't know why, damn
10:43:10 <shapr> that sounds like a good idea to me, any other thoughts?
10:43:46 * Marvin-- digs up -fno-implicit-prelude
10:44:42 <Marvin--> d'oh, now I know
10:44:45 * Marvin-- hits himself
10:44:52 <Marvin--> that's what you get when you "assume the program is type correct"
10:47:11 <Marvin--> right, now I'm back to non-termination
10:47:15 <Marvin--> bleagh
10:47:19 <shapr> ?
10:47:23 <Marvin--> damn you John Hughes
10:47:30 * shapr checks to see if he's here
10:47:48 <Marvin--> their chapter in the fun of programming only has *correct* examples
10:48:02 <Marvin--> I need *bad* examples
10:48:12 <shapr> ask him?
10:51:25 <Marvin--> well, I talked to Koen this morning, but I think we thought in the wrong direction
10:58:50 <shapr> SyntaxPolice: you awake?
11:15:23 <Riastradh> shapr, are you awake?
11:16:13 <shapr> yup
11:16:26 <shapr> d00d, your email is bouncing
11:16:26 <Riastradh> With what error did emails to me bounce?
11:16:31 <shapr> er..
11:16:32 * shapr checks
11:16:36 <Riastradh> DNS error?
11:17:28 <shapr> I think that might have been it.
11:18:28 <delYsid> "let hello = "hello" : hello in putStr (unlines hello)"
11:18:29 <delYsid> haha
11:18:42 <jazzman> hi ppl... i have a question - is this the channel that pesco is in regularly?
11:18:54 <shapr> jazzman: yes, he's here regularly
11:19:31 <jazzman> shapr: thx... so it just doesn't seem to be his favorite time of the day :)
11:19:33 <Marvin--> delYsid: just 'cause I happened to cross-post on -devel...
11:20:01 <delYsid> Marvin--: ?
11:20:12 <Marvin--> delYsid: I thought you got it from my sig
11:20:19 <delYsid> yup
11:20:29 <Marvin--> haven't seen you much on -boot lately so I thought it was from -devel
11:20:36 <delYsid> To: 192305@bugs.debian.org
11:20:41 <Marvin--> oh wait
11:20:44 <delYsid> i.e., the ambigious thingy
11:20:45 <Marvin--> I replied to *your* mail
11:20:48 * Marvin-- blushes
11:21:10 <delYsid> I was sort of inactive the last three weeks...
11:24:39 <Marvin--> "MDC and Physics dep. Were involved." wonder if they used the I'm-dumb-and-can't-can't-capitalize-the-first-word-of-the-sentence-myself feature of Word
11:25:28 <delYsid> hehe, and it wasnt done with emacs, obviously
11:25:40 <delYsid> cos that would have rejected this as a sentence end
11:25:43 <andersca> hey Marvin--
11:25:53 <Marvin--> hey andersca
11:26:04 <shapr> y0 andersca 
11:26:18 <shapr> http://www.norvig.com/Gettysburg/index.htm
11:26:22 * shapr cackles happily
11:26:23 <andersca> norvig!
11:26:25 <andersca> he's cool
11:26:50 <shapr> hey andersca, do you use dvorak?
11:27:46 <andersca> nope
11:29:58 <shapr> Power corrupts, and obsolete power corrupts obsoletely.
11:29:59 <shapr>     - Ted Nelson, on the Microsoft DOS operating system
11:37:12 <shapr> y0 SyntaxPolice_
11:37:20 <shapr> you awake?
11:37:22 <SyntaxPolice_> hi shapr.
11:37:24 <SyntaxPolice_> yeah. I'm awake.
11:38:00 <shapr> hey Peter Simons suggested that the CVS tree of haskell-libs be restructured so that each library is already in its hierarchical library dir
11:38:15 <shapr> what do you think?
11:38:52 <SyntaxPolice_> shapr: sounds fine to me, as long as there's no real commitment; in cvs its hard to move stuff, so I wouldn't want to put something in a hierarchy and then resist putting it in a better place because of csv.
11:38:53 <SyntaxPolice_> cvs.
11:43:01 <ham[let]> hey do you think that an stem function for objects would be cool?
11:43:12 <ham[let]> derivation is like A union B
11:43:24 <ham[let]> the other thing would be A intersection B
12:31:51 <shapr> y0 pesco 
12:31:58 <shapr> jazzman asking about you
12:34:03 <pesco> hey
12:35:19 <pesco> jazzman: Hey ho.
12:56:24 <ham[let]> bye
13:02:34 <jazzman> hey ho pesco
13:03:14 <pesco> jazzman: What are you currently up to in Haskell?
13:03:31 <jazzman> pesco: oh... nothing special really
13:03:52 <jazzman> pesco: generally, i'm still looking for a good union of haskell and OO programming
13:04:03 <jazzman> pesco: O'haskell is quite nice, but has its problems too
13:04:19 <Smerdyakov> Why do you want OO programming?
13:04:48 <jazzman> my experience is that for some problems you really need it
13:04:52 <Smerdyakov> Like?
13:05:12 <jazzman> like, i tried to write a native GUI toolkit in haskell (just use painting routines, write the rest yourself)
13:05:25 <jazzman> i found it near impossible to elegantly represent a world of mutable objects
13:05:40 * pesco wears a fat grin
13:05:50 <pesco> jazzman: Look at fruit.
13:05:52 <Smerdyakov> Did you use monads?
13:05:58 <jazzman> has anybody here tried o'haskell?
13:05:58 <Riastradh> Or arrows?
13:06:15 <jazzman> yes, i know monads... i've written my own already :) but they have their limitations too
13:06:28 <jazzman> pesco: what's fruit?
13:06:37 <Riastradh> Have you tried arrows, jazzman?
13:06:42 <jazzman> what's arrows?
13:06:49 <Riastradh> Apparently not.
13:06:58 <Smerdyakov> jazzman, and perhaps you'd be better off without thinking of things as mutable objects, but rather use functions to specify behavior.
13:07:01 <pesco> jazzman: The application of functional reactive programming with arrows to GUI.
13:07:02 * Riastradh points at http://www.haskell.org/arrows ... or something like that.
13:07:18 <jazzman> Riastradh: the url looks good
13:08:27 <jazzman> i mean, it looks correct :)
13:08:34 <jazzman> (not judging the contents yet ;)
13:08:52 <pesco> jazzman: If I understand things correctly, they treat a gui as a kind of signal function.
13:09:11 <jazzman> pesco: alright... but a GUI usually consists of a heap of independent objects
13:09:23 <Smerdyakov> Combinators!
13:09:26 <jazzman> how do you represent changes in individual objects and interactions between them?
13:09:31 <Smerdyakov> COMBINATORS!
13:09:56 <pesco> jazz: They send off events that trigger the changes.
13:09:56 * jazzman thinks Smerdyakov has an obsession with combinators
13:10:16 <jazzman> pesco: hm... i would have to see the code that implements that
13:10:27 <jazzman> pesco: if it's reasonably elegant and efficient, i'll be happy
13:10:45 <pesco> The events are sent through signals which form the affected elements' input.
13:11:07 <pesco> jazz: I haven't seen the implementation of it, yet.
13:11:32 <pesco> jazz: But the whole idea of it is that it _is_ efficient and _really_ elegant.
13:12:03 <pesco> The efficiency (so they say) comes from the use of arrows te represent signal transformers.
13:12:14 <jazzman> pesco: all my attempts in this direction involved a large object table with clumsy methods of updating it. i came to the conclusion that haskell really needs to be extended to handle this
13:12:17 <opet> hmm.. is there a prelude function for rounding doubles?
13:12:25 <jazzman> pesco: which is what o'haskell does, for example
13:13:08 <pesco> jazzman: I've been having a bad feeling about GUIs, too. But I think they've really done it with FRP.
13:13:34 <pesco> @type round
13:13:34 <lambdabot> round :: (RealFrac a, Integral b) => a -> b
13:13:34 <lambdabot> [-DONE-]
13:14:04 <Darius> pesco: that's efficiency relative other FRP.  As for the current implementation of fruit, it's patently obvious that the implementation (on Win32 at least) needs overhaul, which they are aware of
13:14:06 <opet> ah. should've seen that one coming, really :)
13:14:24 <pesco> Dari: Oh, that's sad.
13:14:44 <Darius> I believe that the implementation is still the "proof of concept" one at this point
13:14:48 <pesco> Darius: But they do believe, it's just a matter of producing a better implementation?
13:15:29 <Darius> Yes.  The gratuitous problems I had with it would be straightforward to fix
13:15:40 <pesco> Ok.
13:15:55 <pesco> I want to try it out some time.
13:16:43 <pesco> I really liked the "FRP, Robots, and Arrows" paper, or whatever the title was.
14:03:46 <Janni> n'evening (the 'n' doesn't make sense in English, but it feels right for me as a German)
14:05:39 <jazzman> Janni: moin moin (<-- makse absolutely no sense in English)
14:07:12 <Janni> Honk, honk! Hurrrrz! <= make absolutely no sense at all
14:07:18 * Janni is feeling stupid
14:07:19 <jazzman> Janni: lol
14:07:28 <ibid> moin moin sounds to me like "mine! mine!" :-)
14:07:47 * jazzman enjoys stupidity once in a while
14:08:14 <Janni> ibid: The way Germans think...
14:08:36 <ibid> germans?
14:09:00 <Janni> Moin is a slang form of "Morgen" which means morning.
14:09:30 <ibid> it sounds vaguely french, and since i don't know french, i twist it and make it sound like mine! mine! ;-)
14:10:26 <Janni> It isn't used in my region, but I heard that you can say "moin" all the day, but "moin moin" means only "good morning". Strange... (even for me)
14:16:55 <jazzman> Janni: no, it isn't :) it's a variation of an old word for "good"
14:17:05 <jazzman> Janni: which is why you can say it at any time of the day
14:19:02 <Janni> Really? I didn't know... But I think that the second "moin" in "moin moin" means "morning" and that's why, it can be used only in the morning (that would be a logic explanation)
14:19:38 <jazzman> Janni: yes, really... :)
14:20:57 <jazzman> pesco is collecting underscores
14:33:48 <Janni> I'm not understanding, what's wrong about "sequence_ $ getDirectoryContents "foo" >>= map putStrLn"
14:34:33 <Janni> Ahh, got it!
14:35:11 <Janni> Err, no... (*confused*)
14:35:17 <tmoertel> @prelude sequence_
14:35:18 <lambdabot> *** "sequence_" prelude "Haskell Standard Prelude Dictionary": text follows
14:35:18 <lambdabot> sequence_
14:35:18 <lambdabot>   sequence_ ::  Monad m => [m a] -> m ()
14:35:18 <lambdabot>   sequence_         = foldr (>>) (return ())
14:35:23 <lambdabot> [-DONE-]
14:35:34 <tmoertel> you don't need it in your statement
14:36:14 <Janni> OK, forget about the sequence_. Even "getDirectoryContents "foo" >>= map putStrLn" isn't correct
14:36:29 <tmoertel> try: getDirectoryContents "foo" >>= mapM_ putStrLn
14:36:45 <tmoertel> @prelude mapM_
14:36:47 <lambdabot> *** "mapM_" prelude "Haskell Standard Prelude Dictionary": text follows
14:36:47 <lambdabot> mapM_
14:36:47 <lambdabot>   mapM_ ::  Monad m => (a -> m b) -> [a] -> m ()
14:36:47 <lambdabot>   mapM_ f           = sequence_ . map f
14:36:52 <lambdabot> [-DONE-]
14:38:06 <Marvin--> a @prelude command? neat!
14:38:16 <tmoertel> Marvin--: yup.
14:38:17 <Janni> OK, that works, but I want to understand, what's wrong about my "solution"
14:38:26 <tmoertel> map putStrLn [...list...]  returns a type of  [IO String] but you need a tyhpe of IO [String] 
14:38:41 <tmoertel> scratch that
14:38:50 <Janni> Ahh, ok (wondering why I didn't get that by myself)
14:38:50 <Marvin--> @type map putStrLn
14:38:51 <lambdabot> map putStrLn :: [[Char]] -> [IO ()]
14:38:51 <lambdabot> [-DONE-]
14:38:57 <Marvin--> bah
14:39:15 <tmoertel> map putStrLn [...list...]  returns a type of  [IO ()] but you need a type of IO ()
14:39:24 <Janni> Yeah, it's all clear, thx
18:46:05 <sjj> Is there some kind of mapping type available in the standard library (such as a HashTable) or is it generally suitable to just use a list of tuples and the 'lookup' function ?
18:47:13 <Riastradh> If you're using GHC, use the Data.FiniteMap library.
18:50:17 <sjj> using hugs :\
18:50:42 <Igloo> Ah, in that case use the Data.FiniteMap library.
18:52:58 <sjj> danke ;)
18:53:06 <Riastradh> Hugs has one too?
18:54:58 <Igloo> Yes - I imagine the same one
18:55:13 <Riastradh> :m Data.FiniteMap   doesn't work for me in hugs.
18:56:29 <Igloo> Nor me, but :l Data.FiniteMap does
19:11:42 <usander> can anybody help me to install ghc under Linux (from source)?
19:51:10 <usander> ok, got it
19:53:31 <witten> apt-get install ghc5 works for me :)
20:04:35 <usander> Hmmm, not on SuSE Linux
20:04:46 <kawfee> Debian!
20:05:24 <usander> yep, I know
20:06:21 * kunphuzil huggles his gentoo
20:15:41 <flippo> @yow
20:15:41 <lambdabot> Now, let's SEND OUT for QUICHE!!
20:15:41 <lambdabot> [-DONE-]
21:14:19 <flippo> @yow
21:14:19 <lambdabot> Yow!  Are we in the perfect mood?
21:14:19 <lambdabot> [-DONE-]
22:51:34 <ham[let]> hiho
