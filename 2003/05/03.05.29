00:00:12 <esap> no.
00:06:54 <kyagrd> Well, deepSeq and recursive strict datatypes should be added to the next Haskell and standard library definition.
00:07:33 <kyagrd> Strictness is often needed because of memory problem.
00:07:37 <kyagrd> Thanks a lot !!
00:07:51 <Pseudonym> Recursive strict datatypes are already in the report.
00:08:02 <kyagrd> really ? where ?
00:08:10 <Pseudonym> data Tree k v = Leaf | Branch !(Tree k v) k v !(Tree k v)
00:08:17 <esap> Yes, it might be a good idea. However, I'm not sure deepSeq is the _best_ solution to that problem. You could use strategies as well.
00:08:18 <kyagrd> no I mean
00:08:46 <Pseudonym> I want someting like: deriving (DeeqSeq)
00:09:00 <esap> pseudonym: agreed.
00:09:19 <kyagrd> Or provide strict lists and strict tuples like Clean ...
00:09:47 <Pseudonym> data StrictPair a b = StrictPair !a !b
00:10:15 <kyagrd> well like this
00:10:28 <kyagrd> type strictpair = !! (a,b)
00:10:41 * esap actually thinks strictness should be handled in the language design with just providing a strict function application, and nothing else in the core language.
00:10:54 <Pseudonym> Another thing I would like is strict type signatures.
00:11:20 <Pseudonym> addToFM :: FiniteMap k v -> !k -> v -> FiniteMap k v
00:11:21 <kyagrd> though there are two levels of strictness.
00:11:30 <kyagrd> seq vs deepSeq
00:11:51 <esap> pseudonym: yes, but if you provide strict application, you also need the corresponding types.
00:12:06 <seth> esap: I thought there was already a strict function application.
00:12:24 <kyagrd> no we can just define it though seq
00:12:38 <Pseudonym> f $! x = x `seq` f x
00:12:39 <kyagrd> f' x = f `seq` x
00:12:45 <kyagrd> like somewhat
00:13:03 <wli> what about deepSeq?
00:14:40 <kyagrd> that should be added to the prelude in the next version
00:14:44 <kyagrd> I think
00:15:30 <esap> wli: I think you're right, if core would have just strict application, then deepSeq becomes more difficult to implement (because different function applications would have to be differentiated).
00:17:26 <esap> wli: It's not actually clear whether a strict function application should behave like ($!!) or like ($!).
00:22:33 <esap> But actually, strictness is an effect, and so should be handled using monads.
00:26:38 <kyagrd> How do one make a class derivable ?
00:27:09 <esap> you extend the compiler.
00:28:08 <kyagrd> Then only standard Show, Read, Eq stuff can be derived ? Can't user defined class be a derivable class?
00:28:52 <esap> kyagrd: no. There are various papers discussing such extensions, but for users, the default implementations in the class definition are the only thing provided.
00:29:40 * esap thinks that kind of loses the point of 'deriving', but it's just my opinion.
00:30:44 <esap> so yes, it's just the standard classes.
03:02:27 <ludde> hugs gives me control stack overflow
03:02:30 <ludde> how do I find out why
03:18:36 <o3> kyagrd: GHC can derive newtypes automatically
03:24:49 <ludde> how do I drop the integer part of a floating point number?
03:26:12 <Riastradh> x - (floor x)  ?
03:27:23 <ludde> that doesn't work right for negative numbers
03:29:03 <Riastradh> let y = abs x - floor (abs x) in if x < 0 then - y else y
03:29:37 <dennisb> ludde: try properFraction
03:30:16 <ludde> almost good
03:30:21 <ludde> actually
03:30:32 <ludde> what I need is floating point modulus
03:30:54 <ludde> i can simulate that with dropping the integer part
03:31:02 <ludde> but maybe there is some more direct way
03:32:33 <ludde> actually
03:32:37 <ludde> x - (floor x)
03:32:40 <ludde> is not so bad after all
03:35:01 <thornber> fst . properFraction
04:04:55 <ludde> i'm having huge problems with instances
04:05:10 <ludde> I have a function:
04:05:27 <ludde> eval :: TimeVal -> Time -> Double
04:05:39 <ludde> then I have:
04:05:39 <ludde> class TimeVal a where
04:05:39 <ludde> 	te :: a -> Time -> Double
04:05:57 <ludde> newtype SF = SF (Time -> Double)
04:06:03 <ludde> instance TimeVal SF where
04:06:03 <ludde> 	te (SF s) t = s t
04:06:19 <ludde> instance TimeVal Double where
04:06:19 <ludde> 	te r _ = r
04:06:35 <ludde> and then I want to be able to give eval either a Double or an SF
04:06:40 <ludde> and it should work the same
04:07:10 <esap> ludde: TimeVal is not a type, it's a class.
04:07:11 <ludde> right?
04:07:18 <ludde> yes
04:07:30 <esap> ludde: so you can't write eval :: TimeVar -> ...
04:07:42 <ludde> eval :: TimeVal a => a -> Time -> Double
04:07:46 <ludde> what about this then
04:07:54 <esap> ludde: right, that's the way to do it.
04:08:41 <ludde> when I write "eval 1 1" in ghci, i get errors
04:08:50 <ludde>     Ambiguous type variable(s) `a' in the constraint `TimeVal a'
04:08:50 <ludde>     arising from use of `eval' at <interactive>:1
04:08:50 <ludde>     In the definition of `it': eval 1 1
04:09:30 <esap> ludde: look at the type of '1'.
04:09:42 <ludde> yeah Num
04:09:51 <ludde> how do I extend
04:09:51 <ludde> instance TimeVal Double where
04:09:51 <ludde> 	te r _ = r
04:09:53 <ludde> to work on Nums
04:10:29 <esap> ludde: you can use "instance (Num a) => TimeVal a where  ...". But I think that might be a mistake as well.
04:10:43 <jlouis> I think you are too far out
04:10:57 <jlouis> It should be doable in a simpler and more direct way
04:11:57 <ludde> jlouis: oh, how?
04:12:47 <jlouis> I am not even sure what your eval function is trying to do
04:13:08 <ludde> right now it's a synonyme for 'te'
04:13:15 <jlouis> and te is?
04:13:21 <jlouis> a -> Time -> Double ?
04:13:26 <ludde> yeah
04:13:34 <ludde> it evaluates the function a at time Time
04:13:57 <jlouis> returning a double, because?
04:14:12 <ludde> the result of the function that it evaluated is a Double
04:14:30 <ludde> i'm making a DSL for sound synthesis
04:14:31 <jlouis> would a -> Time -> b be better?
04:14:41 <ludde> no, because it always returns Double
04:14:50 <ludde> Double is the value of the sample
04:14:57 <jlouis> yup, got that point
04:15:43 <jlouis> So functions that can be executed at a given time is ''TimeVals?''
04:16:03 <jlouis> instances of class TimeVal, that is
04:16:12 <ludde> TimeVal is a value that depends on the current time, so yeah.
04:16:35 <jlouis> TimeVal is nothing but a class in the above
04:16:43 <ludde> yeah
04:17:35 <ludde> anyway, i did this:
04:17:36 <ludde> instance (Num a) => TimeVal a where
04:17:36 <ludde> 	te r _ = r
04:17:46 <ludde>     Illegal instance declaration for `TimeVal a'
04:17:46 <ludde>         (The instance type must be of form (T a b c)
04:17:46 <ludde>          where T is not a synonym, and a,b,c are distinct type variables)
04:17:46 <ludde>     In the instance declaration for `TimeVal a'
04:18:32 <ludde> any clue?
04:19:56 <esap> ludde: that was why I said it is not a good idea :-)
04:20:12 <ludde> is it not possible to make Num an instance of TimeVal ?
04:20:13 <jlouis> te r _ = r :: a -> b -> a, you cannot unify that with a -> Time -> Double, unless you make te :: Double -> Time -> Double
04:20:37 <ludde> hmm
04:20:41 <jlouis> at least in the type systems I know of (Haskell has a more abstract type system than SML which I normally code in)
04:21:02 <Riastradh> A more 'abstract' type system?
04:21:09 <Riastradh> How so?
04:21:40 <ludde> instance (Num a) => TimeVal a where
04:21:40 <ludde> 	te r _ = undefined
04:21:43 <ludde> it chokes on this too
04:21:47 <ludde> and that is unifiably
04:21:48 <jlouis> abstract is not the correct word. I have read somewhere Haskell copes with circularity for instance
04:21:48 <ludde> and that is unifiable
04:22:15 <jlouis> SML errors on that
04:22:37 <Riastradh> That's just because Haskell is lazy, I believe.
04:23:10 <socrates2> http://www-groups.dcs.st-and.ac.uk/~history/Posters2/Curry.html
04:23:36 <socrates2> if it wasnt for that guy then none of us would be on here talking :)
04:24:13 <jlouis> Riastradh: occurs check, type inference. I do not think Haskell can avoid addressing that
04:24:25 <jlouis> yet, I know nothing of specifics in Haskell
04:24:41 <Riastradh> Rephrase, please.
04:25:58 <jlouis> When we infer types, we need to do the ''occurs check'' or else we get infinite types (possibly). SML detects that and errors. I think Haskell can take explicit typing and avoid it in some cases
04:26:22 <ludde> GAHJAHSHFASHFDasd
04:26:29 <esap> jlouis: Haskell also performs occurs check.
04:26:36 <ludde> is it not possible to make an instance of Num ?
04:26:43 <ludde> instance TimeVal Double where
04:26:43 <ludde> 	te r _ = r
04:26:44 <ludde> this works
04:27:02 <ludde> why can I not do instance (Num a) => TimeVal a where
04:27:43 <Marvin--> because you don't have any concrete types in the signature
04:27:44 <esap> ludde: The reason is that you might also ask why can you not do 'instance (TimeVal a) => Num a', but having both in the same program will cause problems.
04:28:10 <jlouis> esap: I would believe that... hmmm I should cook up an example
04:30:59 <ludde> in the prelude they have stuff like instance Integral a => Ord (Ratio a) where
04:31:16 <Marvin--> ludde: yes, but Ratio is a concrete type
04:32:01 <esap> ludde: that is possible, the above problem does not occur in that case [because Ratio is a specific type, not a type variable].
04:32:52 <ludde> so there's no way then to make a function that can take either an SF or a Num a ?
04:33:10 <ludde> without having to lift the Num into sf
04:33:34 <esap> ludde: no, because SF is completely different than Num a. SF is a concrete type, Num a is a constraint on 'a'.
04:34:12 <esap> ludde: and constraints obey different rules than types (or type constructors).
04:34:30 <ludde> but SF and Num a are mutually exclusive
04:34:36 <ludde> it can't be both
04:35:46 <esap> ludde: it doesn't matter. Num a is basically a constraint on a type, not a type itself. If constraints were types, then your argument would be valid.
04:37:16 <ludde> is there some way to tell haskell that 1 is a Double and not a Num a
04:37:35 <esap> ludde: you cannot write x :: Num a. It's always something like x :: (Num a) => f a
04:37:45 <ludde> esap: yes i understand that
04:38:09 <esap> ludde: there is a 'default' declaration that can do that. I've never found any use for that though :-)
04:39:26 <ludde> how would I make a function like this:
04:39:26 <ludde> tod:: Num a => a -> Double
04:40:16 <esap> ludde: read section 4.3.4 of http://www.haskell.org/onlinereport/decls.html
04:40:22 <Marvin--> ludde: uh, you can say 1::Double...
04:41:05 <jlouis> or use anything on a from the Num class
04:41:51 <jlouis> the only thing it does is to constrain the polymorpic alpha into a special class on which we have some special operations.
04:42:03 <ludde> jlouis: yeah
04:42:07 <ludde> jlouis: that's what I want to do
04:42:41 * Marvin-- is getting annoyed by the scavenge_stack errors
04:42:44 * esap would investigate why that would be necessary. It's not clear you should need that.
04:42:44 <ludde> otherwise I can't implement: instance Num a => TimeVal a where
04:42:55 <jlouis> so, allowed functions on the Num a => a is ''pure'' polymorphic functions and things from the Num class
04:43:12 <jlouis> I agree with esap here
04:43:13 <Marvin--> ludde: you *cannot* write  instance Num a => TimeVal a
04:43:40 <Marvin--> when you instantiate, you have to instantiate a concrete type, not a type variable
04:43:48 <ludde> -fglasgow-exts -fallow-undecidable-instances -fallow-overlapping-instances
04:43:56 <Marvin--> ugh
04:45:11 <Marvin--> ynk
04:45:16 <ludde> ?
04:45:25 <Marvin--> I have a function returning  m [[[Disj]]]
04:46:31 <esap> marvin: that is already too hard to use, I would split that type into several parts....
04:46:45 <Marvin--> esap: yes, I'm in the middle of some refactoring
04:47:03 <ludde> is there some way to automatically call "constant :: Num a => a -> SF" whenever I try to use a Num a as an SF?
04:47:05 * esap has been in the middle of some refactoring for over half a year....
04:47:07 <Marvin--> I'm rewriting some stuff to be semi-CPS
04:47:31 <Marvin--> guards :: Monad m => [Id] -> RHS -> (Expr -> m [[Disj]]) -> m [[[Disj]]]
04:47:48 <Marvin--> the point is that guards produces a list of expressions, and then applies the given function to them
04:48:41 <esap> marvin: why not generalize that type, i.e. replace [[Disj]] with a type variable? It sounds it could.
04:49:25 <Marvin--> esap: no, guards produces Disj:s on its own
04:49:46 <Marvin--> esap: it takes apart the RHS (which can be either Guarded or UnGuarded) and creates disjunctions
04:50:11 <esap> marvin: ok.
04:52:16 <Marvin--> esap: writing 'guards' is part of the refactoring ;)
04:52:30 <Marvin--> since I had the same code at every place I did something with RHS:es
04:52:48 <esap> marvin: what are you writing? A compiler?
04:53:03 <Marvin--> esap: sort of, a compiler that encodes haskell programs in first order logic
04:53:17 <esap> in first order logic+
04:53:25 <esap> hmm.. interesting.
04:53:49 <esap> Using curry-howard isomorphism?
04:54:15 <socrates2> why the hell in haskell dont you need to specify the parameters of a function?
04:54:39 <socrates2> passs = length.(filter(>40))
04:54:40 <esap> socrates: of course you need to do that.
04:54:46 <socrates2> for example
04:54:58 <Marvin--> socrates2: welcome to the world of partial application :-)
04:55:04 <Marvin--> @type (.)
04:55:05 <lambdabot> (.) :: (a -> b) -> (c -> a) -> c -> b
04:55:14 <esap> socrates: that is just making new functions from old ones, not applying them.
04:55:39 <socrates2> why dont you just do a  passs [a] = length.(filter(>40)) ?
04:56:00 <socrates2> why dont you just do a  passs ls = length.(filter(>40) ls) ?
04:56:37 <Marvin--> esap: *blush* I've never heard of Curry-Howard isomorphism, what is it?
04:56:44 <socrates2> or does it just assume that we are gonna take a list, because we use filter and length? 
04:57:11 <Marvin--> socrates2: passs ls = length (filter (>40) ls)  and  passs = length . filter (>40)  are the same things
04:57:22 <jlouis> socrates2: it infers the types from the context yes
04:57:33 <Marvin--> socrates2: the latter is referred to as "point-free style"
04:57:34 <esap> marvin: it's the mapping between first-order logic and (typed) lambda calculi. Wait a sec, I'll look up some good references on it.
04:57:45 <Marvin--> esap: oh, nice, sounds like a good read for me
04:57:52 <Riastradh> The latter is what most Haskell programmers prefer, because Haskell Curry defined combinators, and combinators are cool.
04:57:55 <Marvin--> funny Koen didn't mention that to me
04:58:20 <Marvin--> Riastradh: whereas some of us use it sometimes and sometimes not, and like to refer to it as "point-less style"
04:58:35 <esap> marvin: citeseer.nj.nec.com/519604.html
04:59:20 <socrates2> ehat about this
04:59:23 <socrates2> extractMarks = map (\(a,b) -> b)
04:59:41 <Marvin--> esap: thanks!
04:59:48 <socrates2> should i tell it to take a list of pairs
04:59:48 <socrates2> ?
05:00:06 <Marvin--> socrates2: you can ask hugs or ghci what type it has :)  :t extractMarks
05:00:13 <Marvin--> hmm
05:00:19 <Marvin--> @type map (\(a,b) -> b)
05:00:20 <socrates2> i know
05:00:21 <lambdabot> map (\(a,b) -> b) :: [(a,b)] -> [b]
05:00:37 <socrates2> but why not specify parameters?
05:00:38 * Marvin-- pats lambdabot's ...eh...head?
05:00:48 <Marvin--> socrates2: because it's not necessary
05:00:54 <jlouis> @type map snd
05:00:55 <lambdabot> map snd :: [(a,b)] -> [b]
05:00:56 <Marvin--> socrates2: functions are values too
05:01:12 <Marvin--> lambdabot: good bot
05:01:13 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
05:01:21 <jlouis> hehe
05:01:23 <Marvin--> jlouis: yeah I know
05:01:29 <socrates2> Marvin--: how would you do it in that case?
05:01:50 <Marvin--> socrates2: if I have   f x y z = (big expression) x y z  I usually take out the parameters, yes
05:19:05 <Marvin--> phew, this is looking better
05:33:49 * Marvin-- brushes up on intuitionistic logic *sigh*
05:54:05 <esap> marvin: intuitionistic logic is one of the important issues though [well depends on what you want to do with it :-)]
05:55:18 <Darius> [12:49] * Darius pats eval module on the head.
05:55:50 <o3> hmm, does anybody here know how to translate first-order logic to a type signature?
05:56:13 <Marvin--> esap: which is why I'm brushing up on it
05:56:15 <o3> as in, something simple like "forall(x) Man(x) -> Mortal(x)"
05:57:13 <Darius> a\/b -> Either a b; a/\b -> (a,b); Man a -> Mortal a
05:57:28 <esap> o3: forall maps to forall. Propositions map to type constructors. and implication maps to function arrow.
05:57:52 <esap> o3: so that would be written as:  "forall x. Man x -> Mortal x" in Haskell :-)
05:58:03 <o3> esap: ok, as i suspected
05:59:32 <Darius> exists a.T a ==> forall b.(forall a.T a -> b) -> b
05:59:52 <o3> what about something like "forall (x, y, l) German(x) AND German(y) AND Speaks(y,l) -> Speaks(x,l)"?  (no, this isn't for an assignment :)
06:00:17 <o3> writing an email to a friend about how type systems are isomorphic to first-order logic, and have promptly forgotten how to translate between the two
06:00:30 <o3> Darius: ?  what's that?
06:00:47 * esap did just paste a reference to 'Lectures on the Curry-Howard isomorphism' :-)
06:01:00 * Marvin-- is happily reading it
06:01:05 <esap> o3: http://citeseer.nj.nec.com/519604.html
06:01:17 <o3> ah, okay, i never knew the name for it
06:01:25 <Darius> o3: forall x y l.(German x,German y, Speaks y l) -> Speaks x l
06:01:34 <Darius> Which can then be curried.
06:01:53 <o3> so German and Speaks are type classes?
06:02:05 <o3> oh, sorry
06:02:09 <Darius> Type constructors, data types.
06:02:10 <o3> was reading it wrongly
06:03:13 <esap> The curry-howard isomorphism is actually sometimes called "propositions-as-types" correspondence.
06:03:42 * Darius has lectures-on-the-curry.ps :P
06:04:09 <o3> hmm, so does "x and y" in first-order logic map to (x,y) in the type system?
06:04:19 <esap> o3: yes.
06:04:34 * o3 is trying to look smart and figure out what ORs would map to
06:04:46 * Darius waits.
06:05:14 <Marvin--> Darius: :P
06:05:26 <Marvin--> o3: you could also try to look smart and read scrollback
06:08:19 <esap> Here's an interesting question: what would be a logic construct corresponding to recursion?
06:09:06 * esap means recursive types, of course.
06:09:41 <o3> hmm, something to do with union types
06:09:47 <o3> *scratches head*
06:10:12 <esap> I would say recursive types would map to some anti-foundation axiom, I'd guess. But it's not actually clear which one.
06:10:24 <Darius> esap: polymorphic recursion may be induction
06:11:13 <Marvin--> how do packages in ghc work anyway? What if I have module M in both packages p and q and start ghc with -package p -package q foo.hs  where foo.hs imports M?
06:12:33 <esap> darius: yes, I'd guess so.
06:13:26 <o3> would you use 'FooOrBar a b = Foo a | Bar b' to represent 'foo(a) || bar(b)'?
06:14:27 <Darius> o3: yes, though there is already a datatype for that
06:14:55 <Darius> esap: data Y = f (Y f) is a legal Haskell datatype
06:15:03 <o3> oh!  Either, you mean.  now i know what Marvin-- meant
06:15:06 <Marvin--> you only need one sum type, really
06:15:19 <Marvin--> o3: :)
06:15:21 <esap> darius: usually it's written data Rec f = In (f (Rec f)).
06:15:27 <o3> ah
06:15:40 * o3 reaches white belt in type theory
06:15:46 <Darius> er yes, forgot the constructor
06:15:53 <o3> thanks guys, you rock
06:17:07 <Darius> I have it, data Fix f = In { out :: f (Fix f) }
06:17:16 <Darius> and that is used in lambdabot for the ASTs
06:17:44 <esap> To me, the most important part of representing recursion with Rec f is that f has kind * -> *. I think this is fundamental to how recursion works.
06:18:36 * Marvin-- eeks at his CPS functions
06:19:15 <Darius> :t y is (a -> a) -> a
06:19:33 <Darius> Fix has kind (* -> *) -> *
06:20:10 <esap> darius: well true. But that was actually not the point there.
06:20:39 <Darius> I misread
06:20:42 <esap> darius: The point is, the argument to Fix is in different type then the result.
06:21:38 <esap> darius: The same thing is also fundamental to function application.
06:21:55 <esap> darius: so fixed point and function application have lot of things in common.
06:22:56 <esap> darius: And since fixed point is a way to construct _loops_, loops should be thought of as very different than ordinary expressions that are not loops.
06:25:15 <esap> darius: In other words, recursion can be thought of as a way to "lift" functions into values.
06:25:54 <esap> darius: where you connect the input to its own output.
06:41:32 <esap> Hmm.. is it possible to universally quantify over two type arguments only present in instance declarations?
06:42:23 <Darius> Example?
06:43:09 <esap> instance A (Rec x) y y where. I would need to have 'y' universally quantified (otherwise unification doesn't work).
06:44:23 <esap> The situation is something like: >data RecS a f g = InS (a (f (RecS a f g)) (g (RecS a f g)))  and class ValueCapsulatingArrow a a2 b c where { encapsulate_values  :: a (req b) (cmd c) -> a2 req cmd ; discover_values     :: a2 req cmd -> a (req b) (cmd c) }
06:45:33 <esap> I would like to write "instance ValueCapsulatingArrow a (RecS a) b b where { encapsulate_values f = InS f }, but it doesn't work.
06:45:53 <Darius> What error does it give you?
06:46:19 <esap> darius: "Cannot unify type signature variable 'b' with the type "RecS a f g".
06:46:32 <shadow84> hey can some1 help a noob :)
06:46:44 <esap> darius: which means that b was not universally quantified.
06:47:37 <esap> darius: or it had constraints that it cannot have in that situation.
06:48:58 <esap> darius: the types it tries to match are: a1 (req (RecS a1 req g)) (g (RecS a1 req g))  and a1 (req b) (cmd b). I think it should be able to do that.
06:49:16 <Smerdyakov> shadow84, we won't know unless you say what you want.
06:50:26 <esap> darius: of course, I could just replace 'b' in the instance declaration with '(RecS a f g)', but I don't want to do that, because it should be more general than that.
06:53:31 <esap> darius: oh maybe universally quantifying the RecS type would work, hmm...
06:54:03 <Darius> I'm thinking it may be the InS constructor, I'm playing with it 
06:54:56 <esap> darius: if I rewrite it as: >data RecS a f g = InS (forall self. a (f self) (g self)), I get 'quantified type variable 'self' escapes. Hmm...
07:00:03 <esap> And interestingly, the same happens, if I try to use existential quantification.
07:02:21 <esap> oh, existential quantification for it can be made to work.
07:02:35 <esap> I just cannot have discover_values in the class.
07:03:00 <shadow84> i have a string "words int - int words" and i need to turn it into ["words", (int,int) , "words"] ... looking to split it into words, find the index of the "-" then verifying it had an int either side but im sooo lost
07:03:55 <ludde> foo = (freq_ ((constant 1) `plus` ramp) $ freq 500 sinus)
07:04:07 <ludde> this is what something looks like in my silly little sound language
07:04:20 <ludde> would it be possible to do this in monad style instead, like:
07:04:20 <ludde> do
07:04:20 <ludde> 	a <- sinus
07:04:20 <ludde> 	b <- freq 500 a
07:04:20 <ludde> 	r <- ramp
07:04:21 <ludde> 	c <- freq (1 + r) b
07:04:23 <ludde> 	return c
07:05:11 <Smerdyakov> shadow84, first things first: the expression that you say you want as a result is ill-typed. All elements of a list must have the same type.
07:06:00 <Darius> ludde: the idea is that in a <- sinus, a is a sample
07:06:02 <Darius> ?
07:06:37 <ludde> Darius: I want to think of it as cables
07:06:46 <ludde> Darius: like cables between boxes
07:06:54 <shadow84> oops i meant ("word(s)" , (Int,Int) , "words(s)")
07:06:57 <ludde> sinus is a box, draw a wire from it to the freq box
07:07:00 <ludde> etc
07:07:18 <ludde> Darius: do you understand what I mean?
07:07:57 <Smerdyakov> shadow84, what is that meant to mean? You have the type Int in the middle of an expression....
07:08:34 <ludde> Darius: the above example will play a 500hz sinus wave, then linearly interpolate it to 1000hz during 1 second (the length of the ramp)
07:08:51 <Darius> ludde: then you may want to use the basis of AFRP.  Earlier, I had a different idea of what you wanted to do, that's why I started changing my mind.
07:09:24 <ludde> Darius: I'm not sure if it's possible to implement "freq" in AFRP
07:09:31 <ludde> Darius: since it modifies time
07:10:16 <shadow84> yeah its some bullshit for an assignment soo lost.. ok i imput a string which contains random words with a number then a dash then another number, and some more words i have to split it up
07:10:25 <Darius> You could use old FRP setup where the signals
07:11:17 <ludde> Darius: I guess you can think of a, b, r and c as (Time -> Double)
07:11:23 <Smerdyakov> shadow84, oh. You shouldn't use what are essentially language keywords to stand for other things in examples. :P
07:11:42 <shadow84> aight
07:11:43 <Smerdyakov> shadow84, and, if you're lost, you should ask an instructor for the class.
07:12:15 <ludde> Darius: However, 1 + r wouldn't be quite right.. I can't add (Time -> Double) to Num a. 
07:12:25 <Darius> you'd lift 1
07:12:39 <ludde> I want this syntax though, or something close to it.
07:12:42 <ludde> since it's nice
07:12:59 <ludde> having to write lift 1 everywhere would be a mess
07:13:20 <Darius> fromIntegral
07:13:36 <ludde> hmm?
07:13:36 <ludde> i mean
07:13:37 <Darius> or use a special +
07:14:03 <Darius> like a .+. s = constant a `plus` s
07:14:08 <ludde> I can't overload + so it becomes (+) :: Double -> (Time -> Double) -> (Time -> Double), can I?
07:14:19 <Marvin--> no
07:14:33 <Marvin--> because (+) :: Num a => a -> a -> a
07:14:45 <ludde> right
07:14:58 <Darius> That's why you make your own (+)
07:15:14 <ludde> hmm, what would be the need for the monadicicty if everything is a (Time -> Double)
07:15:21 <ludde> monadicity
07:16:12 <ludde> 	let a = sinus
07:16:13 <ludde> 	    b = freq 500 a
07:16:13 <ludde> 	    r = ramp
07:16:13 <ludde> 	    c = freq (1 + r) b
07:16:13 <ludde> 	in c
07:16:18 <ludde> I suppose I could just write it like this?
07:16:42 <Marvin--> but what's the point of "a = sinus"?
07:16:48 <Darius> You need to pass time to everything
07:16:59 <ludde> Darius: no, since a is (Time -> Double)
07:17:19 <ludde> everything is (Time -> Double)
07:17:38 <ludde> Marvin--: no point, I just write it like this while reasoning about it
07:20:17 <Marvin--> should I pick a fight with Volker Stolz over copyright and licenses? :/
07:25:36 <Marvin--> damn, I hate legalese
07:26:16 <Marvin--> ah, syntax, maybe you can give me some advice on this
07:27:56 <syntax-laptop> Marvin--: I'll try :)
07:28:28 <Marvin--> In http://haskell.org/pipermail/libraries/2003-May/001019.html I mailed a reference to my mkstemp function, with documentation and everything
07:28:47 <Marvin--> In http://haskell.org/pipermail/libraries/2003-May/001020.html Volker Stolz replies something vague
07:29:34 <Marvin--> later I find (thanks to Alastair Reid) that Volker's checked in a very similar mkstemp in libraries/unix/System/Posix/Temp.hsc but with another license and with copyright assigned to himself
07:29:55 <socrates2> what are the main benefits of currying
07:29:59 <socrates2> ?
07:30:01 <Marvin--> now, Since Volker replied to my mail, I find it hard to believe that he didn't read my version of mkstemp
07:30:19 <steveh> socrates2: Less Irritating and Stupid Parentheses
07:30:29 <Marvin--> socrates2: partial application
07:30:33 <steveh> (Grammatically less should be fewer :)
07:30:43 <ludde> foo = let 
07:30:48 <ludde> 	wave = freq_ 500 sinus
07:30:48 <ludde> 	rampwave = freq_ 3 $ amp 0.01 sinus
07:30:48 <ludde> 	in freq (1 +. rampwave) wave
07:30:50 <socrates2> thats all?
07:30:58 <ludde> Anyone has any idea why this doesn't sound periodic ?
07:31:10 <syntax-laptop> Marvin--: eww.  Probably an oversite.  what license did he use?
07:31:12 <Marvin--> syntax-laptop: now, should I pick a fight with him over this?
07:31:42 <Marvin--> syntax-laptop: I slapped LGPL on mine for the time being and said that it was negotiable, he slapped "BSD-like"
07:31:53 <syntax-laptop> I didn't look at the implementation, is it sufficiently large to be copyrightable?  Would I come up with the same thing if I wrote it in an afternoon?
07:32:42 <Igloo> You can copyright it no matter how small it is can't you?
07:32:44 <Marvin--> I didn't know there was a size limit to being copyrightable, and yes I guess you would since there isn't that many ways of doing it
07:32:49 <steveh> largeness has very little to do with it
07:33:00 <steveh> computer code falls under the "literary work" category
07:33:08 <syntax-laptop> If so, I'd email him about it.  If he says that he came up with it on his own, then its up to you to decide if its worth a little battle.
07:33:19 <Igloo> But it's much easier to convince the law that you wrote it exactly the same way if it's small or there are only a couple of ways of doing it
07:33:29 <steveh> at least in the states
07:33:44 <Marvin--> syntax-laptop: I mean, the reason I'm asking is that I don't *really* want to fight over something this small and silly, but I get annoyed when people do things like this
07:33:55 <syntax-laptop> Igloo: I guess thats what I meant.
07:34:11 * Igloo would point it out as a matter of principle, possibly adding a "But you can use it under the BSD licence" if you want
07:34:30 <steveh> well, since the license was negotiable, maybe asking nicely for co-authorship credit?
07:34:42 <syntax-laptop> Marvin--: yeah, I'd just send him a polite email saying that it looks like the one you wrote, but the license and copyright are wrong.  If he says "oh OK sorry" then thats cool, if he says "No, I hated yours, I wrote that myself." then I guess you have another choice to make :)
07:34:58 <Marvin--> Igloo: yes, I had a discussion with Alastair over licenses and said that if someone was interested in putting it in the standard library we could discuss licenses, which is when he pointed out that someone already *had* added it
07:35:16 <thornber> I've heard a lawyer say that anything above a couple of lines of C code is copyrightable
07:35:31 <steveh> do they compile to the same object code? object code is copyrighted too.
07:35:32 <Marvin--> syntax-laptop: if he says "No, I hated yours" it means he read it and has done something illegal, if he says "I didn't read yours, I made mine up as I went" it'll be harder to contest it :P
07:36:08 <dennisb> thornber: and since 10 lines C is approx the same as 1 line haskel...
07:36:12 <Marvin--> the main difference between mine and his is that I used openFd (to be able to set a filename on the handle) and he used handleToFd
07:36:33 <Marvin--> and his had the usual amount of #ifdef:ing needed in fptools of course
07:36:41 <syntax-laptop> well, eihter way, I see it as a two step process, but I definitly would take the first step of seeing what he was thinking when he did it.
07:36:42 <thornber> dennisb: :) unfortunately it doesn't work like that ...
07:37:53 <ludde> is it possible to implement FM-modlation without integration?
07:39:34 <syntax-laptop> If he says he did it himself without looking at yours, I would drop it, but if he says "I hated yours" then I would argue a bit :)
07:40:13 <Marvin--> exactly
07:40:27 <syntax-laptop> I was thinking that we might ask someone to turn on the "upload file" feature in the wiki; it seems like it would be nice to drop stuff there instead of putting it up on our own web sites.
07:41:33 <steveh> he might not be a jerk, though, and he might give you co-author credit, especially if the license isn't important to you -- a la Darwin and Wallace
07:41:37 <Marvin--> why is there a silly delay in commits to the fptools repository anyway?
07:42:11 <Igloo> The public repository and cvsweb are cynced once a day or something
07:42:32 <Igloo> synced even
07:42:55 <Marvin--> Igloo: it kinda sucks... When Alastair said someone'd checked it in, I had no way of looking at it for several hours
07:43:07 <Marvin--> so all I could say was "uh, okay, huh"
07:43:57 <Marvin--> steveh: I did say that the license was negotiable
07:44:22 <steveh> looks like he negotiated it for you :-P
07:45:06 <Marvin--> yes, which is what I'm objecting to!
07:46:35 <Marvin--> yeech, marketing people are slippery
07:48:55 <steveh> (^) :: forall a b. (Num a, Integral b) => a -> b -> a
07:49:13 <steveh> is there a version that takes fractional b?
07:49:18 <Igloo> (**)
07:49:31 <steveh> aaah
07:49:34 <steveh> good ol fortran
07:49:35 <steveh> thanks
07:49:36 <steveh> :)
07:49:56 <Darius> @type (^)
07:49:57 <lambdabot> (^) :: (Num a, Integral b) => a -> b -> a
07:50:01 <Darius> @type (^^)
07:50:02 <lambdabot> (^^) :: (Fractional a, Integral b) => a -> b -> a
07:50:03 <Darius> @type (**)
07:50:04 <lambdabot> (**) :: Floating a => a -> a -> a
07:56:02 <socrates2> reversels [] = []
07:56:02 <socrates2> reversels ls = ls!!(length(ls)-1) : reversels (filter (ls!!==(length -1)) ls)
07:56:20 <socrates2> i know haskell has a built in reverse 
07:56:36 <socrates2> but can anyone tell me whats wrong with this one
07:56:46 <socrates2> ??
07:57:05 <Marvin--> if Volker says he did it himself without looking at my code, what does that tell me? "Go away you free software fanatic, I don't want to discuss license terms with you, I'd rather reinvent your wheels"?
07:57:48 <Darius> ls!!==(length-1) doesn't make sense
07:58:14 <syntax-laptop> Marvin--: I would attribute the situation to accident in one way or another before worrying about it too much.  See what he says and go from there.  Its obviously upsetting you so be careful w/ your email :)
07:58:31 <steveh> pattern matching is the way to go socrates2
07:58:34 <Marvin--> syntax-laptop: I've already sent it, before I worked myself up too much :P
07:58:49 <steveh> compare [x] and (x:xs) in your mind
08:00:21 <socrates2> Darius: how can i correct it?
08:00:40 <socrates2> i want to copy everything but the last element in the list
08:00:54 <Marvin--> now, if I were SCO, what would I do? ;)
08:01:00 <syntax-laptop> hehe
08:01:37 * Marvin-- drinks some coffee and tries to relax
08:01:51 <Marvin--> I worked myself up enough just deciding whether to make a fuss of this or not :/
08:02:17 <steveh> Marvin--: threaten to sue all the Haskell people at MS Research? :)
08:02:40 <steveh> something strikes me as odd about drinking a stimulant to relax
08:02:50 <Marvin--> steveh: well, I'm odd
08:03:47 <Marvin--> I've always regarded coffee as relaxing, probably mostly because I only drink coffee in relaxing situations, like taking a break from working, or sitting at a cafe or something
08:04:01 <steveh> I can see that
08:05:53 <steveh> are there already silly functions in Haskell like degs->rads or should I just program the constant myself?
08:11:44 <Marvin--> oh lookie, 6.0 is out
08:12:57 <Igloo> So it is
08:13:09 * Igloo looks around for a bouncing shapr  :-)
08:13:28 <Darius> No win binary.  If I could build it I'd have it already :P
08:13:34 <Marvin--> um, what with all the movement among the libraries and hslibs directories... how on earth do I write a program that works with both ghc 5.04 and ghc 6.0?
08:14:00 <Igloo> Both should support H98 libraries
08:14:14 <Igloo> If you relied on non-standard extensions then you deserve what you get  :-P
08:14:21 <Marvin--> bleh :)
08:15:27 <Igloo> If they're marked stable, or possibly provisional, in 5.04 you migth have a little cause to complain
08:15:28 <Darius> "Non-blocking IO is now supported on Windows"
08:15:38 * Darius has noticed that.
08:16:22 <Marvin--> how do packages work anyway? In fptools/libraries I see an overlap between base/ and unix/, for example System/Posix/
08:16:40 <socrates2> removeDup ls = filter (elem (head ls) (tail ls)) ls 
08:16:49 <socrates2> can u see whats wrong with this?
08:17:09 <socrates2> i can
08:17:42 <Darius> So can I (assuming it's meant to do what I think it's meant to do)
08:17:54 <Igloo> Well, I assume it's meant to typecheck at least  :-)
08:17:57 <Marvin--> Igloo: it's just that it's hard to write programs with just H98 if you don't want to duplicate a lot of work
08:18:10 <Marvin--> Igloo: Luxuary!</montypython>
08:18:33 <Igloo> Marvin: Well, it's a convenience vs stability trade-off
08:18:51 <Marvin--> I guess I want Haskell2 NOW
08:18:52 <Igloo> I'd much prefer you had some hassle now and we ended up with the Right library hierarchy
08:19:02 <Marvin--> yeah, indeed
08:20:25 <Marvin--> Ketil had a good point about deep hierarchies
08:20:44 * Darius doesn't see what's different about defining Typeable instances
08:20:51 <socrates2> Darius: I dont know again
08:21:02 <socrates2> Darius: Iwhat do you think is wrong?
08:22:14 <Marvin--> and a good example of it is the discussion of FileFormat and Codec and stuff, some time in April
08:22:25 <Darius> @type filter
08:22:26 <lambdabot> filter :: (a -> Bool) -> [a] -> [a]
08:22:55 <Darius> @type let ls = [1,3,5] in elem (head ls) (tail ls)
08:22:56 <lambdabot> let {ls ($0 (0 [1,3,5]) $0) $0 $0} in head ls `elem` tail ls :: Num a => Bool
08:23:12 <Darius> hmm, that was bizarre
08:23:16 <Marvin--> uhhh, yes
08:23:31 <socrates2> yeah good point
08:23:44 <Marvin--> Num a => Bool is...bad
08:24:35 <Marvin--> Igloo: I'm a bit scared of too deep hierarchies myself, and there's also the damn packages that I don't understand
08:25:28 * Darius *blinks* *blinks* at Data.Tree.
08:25:45 <Darius> Also why is Data.Graph not FGL or FGL-like?
08:30:02 <Darius> oh, Typeable can be derived :P  That'll be nice.
08:31:02 <socrates2> Darius: 
08:31:03 <socrates2> dup [] = []
08:31:03 <socrates2> dup ls = if elem (head ls) ls then dup (tail ls) else (head ls) : dup (tail ls)   
08:32:32 <Darius> 1) pattern matching will make that nicer looking 2) that will always return [] I'm pretty sure
08:33:56 <socrates2> if elem (head ls) (tail ls) 
08:34:02 <socrates2> whats pattern matching?
08:34:03 <Darius> aye
08:34:05 <socrates2> Im new to this
08:34:15 <socrates2> yeah works now.
08:35:00 <socrates2> but whats this pattern matching, you speak so highly of, i will redesign my function, with it if you tell me what it is
08:35:03 <Smerdyakov> LOL
08:35:10 <Smerdyakov> I recommend no one help socrates2 with anything else.
08:35:20 <Smerdyakov> Until he proves he has read enough to be doing these things.
08:38:48 <socrates2> Smerdyakov: I recommend to Smerdyakov to keep quiet. I have read. And everybody can make their own mindds up on whether to help me or not. Who do you think you are?
08:40:32 <Smerdyakov> Someone who remembers how you were acting here before and kind remind people who don't.
08:40:35 <Smerdyakov> s/kind/can
08:41:04 <stefp> This will not stand. These aggressions will not stand. /me pours oil on socrates2 and Smerdyakov and sets fire. ethical preemptive strike.
08:41:09 <socrates2> Smerdyakov: get a life.
08:41:45 * stefp tries to diffuse tension with lame humor
08:41:59 * Smerdyakov gives stefp a kiss.
08:42:03 <socrates2> Who is with me and who is with mr. Vokda ?
08:42:42 * SyntaxPolice raises fist in the air in an act of ambiguous solidarity
08:43:59 <hdaume> grr
08:44:05 <socrates2> ow do i get everything but the last element in a list without doing a reverse?
08:44:20 * Smerdyakov creates a suspension that will contain his memoirs as soon as anyone cares to read them.
08:44:21 <hdaume> init
08:44:33 <hdaume> or inits
08:44:36 <hdaume> @type inits
08:44:51 <Darius> @type init
08:44:51 <lambdabot> init :: [a] -> [a]
08:45:00 <Smerdyakov> hdaume, watch out! socrates2 has been asking silly questions for a while, and just revealed that he doesn't know what pattern matching is!
08:45:04 <socrates2> yeah thanks
08:45:23 <hdaume> eh, no biggie
08:45:38 <socrates2> Smerdyakov: oh no, somebody call the police!!!!!!!!!!!!!!!!!
08:46:12 <Darius> 7.4.15.1. Generalising the deriving clause
08:46:15 <Darius> Cool!
08:46:47 * Smerdyakov calls the SyntaxPlease.
08:46:52 <Smerdyakov> or SyntaxPolice
08:48:29 <socrates2> Smerdyakov:set me up with a challenge, gimmie a function to write, set a time limit on it, and if cant do it, then you may have a point.
08:48:45 <socrates2> reversels [] = []
08:48:45 <socrates2> reversels ls = ls!!(length(ls)-1) : reversels (init ls)
08:49:10 <Darius> @eval lenght [1]
08:49:11 <lambdabot> unbound variable: lenght
08:49:12 <Smerdyakov> OK, the challenge is give the correct spelling of the English word you tried to use for that function name within 10 seconds.
08:49:18 <Darius> @eval length [1]
08:49:19 <lambdabot> 1
08:49:28 <socrates2> reverse
08:49:50 <Smerdyakov> Time's up! It's "reversals"!
08:50:16 <socrates2> no its short for reverse-list
08:50:40 <stefp> I hope for hos ownerthat lambdabot does not support the system() call. 
08:50:48 <Marvin--> hmm, so hierarchal modules in different packages cannot overlap?
08:50:49 <socrates2> god man, with these lame jokes, you are really proving how sad u are.
08:50:55 <Darius> @eval fix (\rev l.if null l then [] else nth (length l - 1) : rev (init l)) [1,2,3,4]
08:50:55 <lambdabot> [<<EM Dynamic -> EM Dynamic>>, <<EM Dynamic -> EM Dynamic>>, <<EM Dynamic -> EM Dynamic>>, <<EM Dynamic -> EM Dynamic>>]
08:51:14 <Darius> @eval fix (\rev l.if null l then [] else nth (length l - 1) l : rev (init l)) [1,2,3,4]
08:51:14 <lambdabot> [4, 3, 2, 1]
08:51:33 <Darius> @eval foldl (\x y.y:x) [] [1,2,3,4]
08:51:34 <lambdabot> [4, 3, 2, 1]
08:51:57 <socrates2> whats that darius:?
08:52:10 * stefp remember when taught Unix and C  and yold by his tutor that the system was secure; the first thing he did  was to set up a fork bomb
08:52:47 <stefp> that is called gratitude
08:53:47 <socrates2> Smerdyakov: i notice you have nothing to say in reply to that :)
08:54:22 <stefp> he, I did say I was pouring oil :)
08:57:00 <socrates2> is pattern matching the use of guards?
08:57:14 <Smerdyakov> stefp, acting like this is personal bickering is odd. I think anyone who really cares about helping someone else learn will want to avoid encouraging people to go asking questions better answered by reading.
08:57:21 <socrates2> i use that sometimes it makes things a bit clearer.
08:57:52 <socrates2> Smerdyakov: why are you here?
08:58:06 <Smerdyakov> Because I'm interested in Haskell. What do you think?
08:58:13 <socrates2> Smerdyakov: you enjoy moaning, about crap?
08:58:36 <jlouis> stefp: that is called total incompetance...
08:59:52 <socrates2> Smerdyakov: but you dont like people asking questions, if nobody asked questions then there would be no conversation. The there would be no opportunity to learn any haskell.
09:00:17 <socrates2> or hear of something interesting.
09:00:34 * stefp is an ignoramus in haskell and go back to what he should do:  lurking before he knows enough to ask smart questions
09:00:38 <Smerdyakov> socrates2, no, I don't like people trying to use personal conversation as a substitute for reading books that have already been written (and well).
09:00:45 <SyntaxPolice> socrates2: http://haskell.cs.yale.edu/tutorial/patterns.html
09:01:15 <SyntaxPolice> they're very important to designing haskell code that looks like haskell.
09:01:53 <socrates2> Smerdyakov: can you stop moaning
09:03:02 <socrates2> Smerdyakov: if haskell curry was around now, he would that he never invented the language.
09:03:03 <Smerdyakov> socrates2, no, because I'm genuinely interested in helping people learn things well.
09:03:46 <socrates2> Smerdyakov: what books do you recommend? 
09:04:13 <socrates2> two dozen short lessons in haskell, it so easy it worthless reading it
09:04:24 <Smerdyakov> I don't know.
09:04:42 <socrates2> btw, whats the point in haskell, its not used at all in industry, is it?
09:04:43 <Smerdyakov> I learned ML before Haskell, which creates completely different educational needs to make the jump.
09:04:55 <socrates2> ML?
09:05:05 <SyntaxPolice> Here's a summary of some recommendations: http://www.haskell.org/hawiki/LearningHaskell
09:05:30 <Smerdyakov> ML smells a lot like Haskell, except it's impure and has eager evaluation.
09:05:34 <Darius> Anyone know how to get CVS to update/checkout everything -but- a particular file/directory?
09:05:42 <socrates2> btw, whats the point in haskell, its not used at all in industry, is it?
09:05:54 * SyntaxPolice uses haskell in industry.
09:06:02 <Smerdyakov> Which contribute somewhat to the fact that it as actually a viable replacement for almost all uses of C, C++, etc., since it's easier to compile to efficient machine code.
09:06:04 <socrates2> for what?
09:06:32 * Smerdyakov uses industry as a dishrag.
09:06:46 <ludde> is it easier to compile haskell into efficient machine code?
09:07:15 <socrates2> yeah, what use is it?
09:07:47 <steveh> socrates2: "so easy it's worthless reading it?"
09:07:47 <socrates2> what gives it an edge?
09:07:59 <stefp> I am learning compiler technique. Modern compiler internally  use "Single Static Assignment" which means convert code to functional code.
09:08:04 <steveh> socrates2: did you bother doing the exercises without looking?
09:08:19 <steveh> socrates2: if you had I think you wouldn't be asking such silly questions
09:08:37 <socrates2> steveh: my lecturer agrees with me
09:08:52 <stefp> not that I would make me an advocate of pure functional language.
09:08:55 <Smerdyakov> socrates2, how about answering his question?
09:09:05 <stefp> I just think one have to know the paradigm
09:09:09 <Smerdyakov> stefp, that's somewhat of a red herring in terms of justification for learning FP.
09:09:36 <Smerdyakov> stefp, but, ML/Haskell family of languages ARE the best for writing compilers, so you needn't look far for a better reason of the same type. :-)
09:09:45 <stefp> indeed, let say it is omne of my current motivations
09:10:17 <socrates2> what excercises in particular, are u on about
09:10:23 <jlouis> though that SSA form has a functional representation it is not the best thing about it
09:11:00 <Smerdyakov> socrates2, !
09:11:12 <Smerdyakov> socrates2, that book has exercises for you to try EVERYWHERE, and he means all of them!
09:11:37 <jlouis> what book are we talking about?
09:11:39 <stefp> for me that proves a point, that functional representation is good when you want to do computer driven processing.
09:11:47 <steveh> jlouis: http://www.cs.ou.edu/~rlpage/fpclassCurrent/textbook/haskell.shtml
09:11:54 <jlouis> oh
09:13:16 <Smerdyakov> I wonder why that book isn't on the haskell.org learning page anymore.
09:13:43 <steveh> Smerdyakov: it's on Haskell in Education
09:14:08 <steveh> socrates2: Chapter 5 and after should all be pretty relevant to what you're doing
09:14:09 <Smerdyakov> But... isn't it a good choice in the same vein as the tutorials given on the learning.html page?
09:14:33 <steveh> all the --you write this function notations :)
09:14:59 <steveh> Smerdyakov: Personally I'd think so, but I don't run haskell.org
09:16:34 <socrates2> i have read that
09:16:41 <socrates2> done the excercises
09:17:11 <socrates2> removeBPC str = (rb.rp.rc)str
09:17:12 <socrates2>                where rb = filter (/=' ') 
09:17:12 <socrates2>                      rp = filter (/='.')
09:17:12 <socrates2>                      rc = filter (/=',')     
09:17:17 <socrates2> there you go
09:17:25 <socrates2> its a piece of piss for me
09:17:29 <steveh> ah, but do you know what's going on?
09:17:43 <socrates2> yeah why not?
09:17:45 <steveh> actually I was thinking of the more general version
09:18:31 <socrates2> remove cha str = [ x| x<- str, x /= cha] ?
09:18:54 <socrates2> im better than you originally though hey :)
09:19:50 <jlouis> that removeBPC surely gets some deforestation if I am right
09:20:00 <steveh> page 89
09:20:01 <steveh> do all those
09:20:05 <steveh> then we will talk
09:22:04 <socrates2> the 'modules' section? 
09:22:08 <Darius> jlouis: yes
09:22:16 <Darius> jlouis: in GHC
09:22:33 <steveh> they call it "EncryptionUtilities"
09:22:54 <Darius> "filterFB"	  forall c p q. filterFB (filterFB c p) q = filterFB c (\x -> q x && p x)
09:23:29 <steveh> alternatively rewrite remove cha str with a map
09:23:30 <steveh> :)
09:23:56 <Darius> and removeBPC as one filter (why would you use three?)
09:24:11 <jlouis> steveh: sounds illogical to me
09:24:19 <jlouis> Darius: agreed
09:24:24 <socrates2> remove cha str = filter (/=cha) str 
09:24:43 <steveh> jlouis: remove c = map replace where replace x = if x == c then ' ' else x
09:25:13 <steveh> doh, looks like I disqualified that one for socrates2 :)
09:25:15 <socrates2> steveh: good :? 
09:25:25 <jlouis> that does not have the same semantics
09:26:08 <socrates2> steveh: one more.
09:26:22 <socrates2> A difficult one.
09:26:30 <socrates2> come hit me :)
09:26:46 <jlouis> remove c = filter (/=c) is the prettiest imo
09:27:32 <thornber> you're not going to get it much more concise
09:27:56 <Darius> @eval (filter . (\x y.x/=y)) 2 [1,2,3,4]
09:27:56 <lambdabot> unbound variable: filter
09:28:23 <socrates2> any more?
09:28:44 <Darius> @define filter \p.foldr (\x y.if p x then x:y else y) []
09:28:44 <lambdabot> filter defined
09:28:46 <Darius> @eval (filter . (\x y.x/=y)) 2 [1,2,3,4]
09:28:46 <lambdabot> [1, 3, 4]
09:28:58 <Darius> remove = filter . (/=)
09:29:01 <socrates2> i will write a function to test for a palendrome
09:29:09 <socrates2> @define filter
09:29:09 <lambdabot> (line 1, column 1):
09:29:09 <lambdabot> unexpected end of input
09:29:09 <lambdabot> expecting white space or simple term
09:30:09 <socrates2> good night :)
09:32:01 <thornber> remove x xs = [z | z <- xs, z /= x]
09:32:06 <thornber> damn, missed him
09:38:39 <Smerdyakov> Hm. People eager to show off their knowledge make up the biggest threat to online learning. :P
09:40:23 <thornber> I see he'd already got that one anyway
09:50:47 <steveh> none of those are particularly efficient
09:51:12 <steveh> at least not when applied to multiple chars
09:53:14 <thornber> what would be more efficient ?  building a predicate that had all the tests and then filtering once ?
09:58:00 <thornber> removeAll xs ys = filter (pred) ys where pred y = foldl1 (&&) [(y /=x) | x <- xs]
09:58:04 <thornber> ??
09:58:55 <Darius> @eval elem
09:58:56 <lambdabot> unbound variable: elem
10:01:06 <Darius> @eval (\removeAll.removeAll "aeiou" "foobar") (filter . elem)
10:01:06 <lambdabot> type error
10:02:06 <Darius> @eval (\removeAll.removeAll "aeiou" "foobar") (filter . flip elem)
10:02:07 <lambdabot> ooa
10:02:32 <thornber> (\\) = foldl (flip delete)
10:02:34 <Darius> @eval (\removeAll.removeAll "aeiou" "foobar") (filter . not .flip elem)
10:02:35 <lambdabot> type error
10:03:20 <Darius> @eval (\removeAll.removeAll "aeiou" "foobar") (filter . flip (not . elem))
10:03:21 <lambdabot> type error
10:39:04 <kloo> hi.
10:41:19 <Lilith> hi kloo
10:42:56 <kloo> i've come to spy on what haskell users talk about.
10:43:36 <Marvin--> naughty
10:43:55 <Lilith> kloo: what for? :)
10:44:12 <Darius> Haskell users talk about Haskell.
10:44:31 <kloo> learning at least some haskell would benefit me, i think.
10:44:46 <Darius> Damn skippy.
10:44:52 <kloo> i've been studying, amoung other things, the FOOL book about the foundations of object-oriented languages.
10:45:20 <thornber> a functional language should be a good antidote to that then
10:45:24 <kloo> it uses several lambda calculi, type constructors, kinding rules, etc.
10:45:43 <kloo> it seems haskell might make some of that more tangible to me.
10:46:14 <kloo> well the book is about type systems, and static type checkers are functional programs, no? :)
10:46:29 <thornber> speaking as another newbie it is the most elegant language I've seen
10:58:38 <kloo> is there a haskell book that starts at the beginning and does not gloss over monads?
11:00:50 <hdaume> kloo: i'm partial to http://www.isi.edu/~hdaume/htut
11:01:31 <kloo> thanks.
11:04:21 <kloo> i see how you would be partial to it, hdaume. :)
11:05:04 <hdaume> *grin*
11:05:31 <kloo> your stated audience fits me well.
11:05:44 <hdaume> kloo: well that's good.  who knows whether it accomplishes that though
11:06:03 <kloo> if you like, i will let you know.
11:07:09 <hdaume> i'd like :)
11:12:04 <Riastradh> Bleh.
11:12:26 <Riastradh> I sha'n't be able to go to the ICFP or HW.
11:13:08 <Igloo> :-(
11:13:11 <Igloo> How come?
11:58:53 * esap browses through the GHC-6.0 announcement.
12:07:26 <socrates2> fs =  /ls -> map (*2+1) ls  
12:07:34 <socrates2> whats wrong with this?
12:07:49 <Riastradh> The '/'.
12:07:53 <Riastradh> It should be a backslash.
12:08:04 <socrates2> i dont understand the lambda function.
12:08:11 <Riastradh> The lambda function?
12:08:21 <Riastradh> There is no 'lambda function' in Haskell.
12:08:31 <socrates2> It it just a case of specifying the parameter inside the function
12:08:48 <Riastradh> Rephrase, please, so I can correct you a little better.
12:09:24 <socrates2>  is it just a case of specifying the parameter to the right of the '=' sign of a function
12:09:52 <Riastradh> If you use it only in function definitions, then it is -- but lambda can be used anywhere.
12:11:04 <socrates2> what its other uses?
12:11:17 <Riastradh> Any function context.
12:11:41 <Riastradh> map (\f -> f x y) [(\x y -> stuff), etc]
12:13:48 <Lilith> ouch
12:13:54 <socrates2> oh i see
12:19:13 <jazzman> GHC 6.0 is here!!!
12:19:23 <Riastradh> With template Haskell yet?
12:19:26 <jazzman> yes!
12:19:41 <Riastradh> OOH!
12:19:44 <jazzman> it came out today
12:19:47 * Riastradh explorbs and implorbs simultaneously.
12:19:59 * jazzman tingles with excitement
12:20:16 <Darius> Riastradh: Check out section 7.4.15 (I think)
12:20:20 <esap> and it appears to have deriving support for gfoldl etc.
12:20:22 <jazzman> http://haskell.cs.yale.edu/ghc/docs/6.0/html/users_guide/release-6-0.html
12:20:52 <Darius> and Typeable
12:21:01 <jazzman> yeah!
12:21:07 <Riastradh> Argh.
12:21:11 * Riastradh waits for an OS X binary.
12:21:12 <jazzman> type reification... how cool is that
12:21:26 * Darius builds from CVS.
12:21:31 <Marvin--> oh, there's gmap support? niiice
12:22:07 <esap> it's in "Experimental features" section of the doc [haven't yet tried it]
12:22:12 <Darius> 6 is chock full of cool things
12:23:20 <jazzman> what's gmap?
12:23:23 <Marvin--> hmm, what do I have to import to get gmap, gfoldl et.c.?
12:23:54 <Darius> seemingly import Data.Generics but the documentation doesn't seem to be there
12:24:05 <thornber> is it possible to get 'Non-exhaustive patterns in function aux' if the last guard in aux is an 'otherwise' ?
12:24:06 <jazzman> "There is now a native code generator for PowerPC platforms." ghc has native code generators
12:24:15 <jazzman> i thought it always emits C
12:24:16 <Darius> (don't confuse this with the (likely to go) Generics extension)
12:24:27 <Darius> Guards aren't patterns.
12:25:29 <Darius> Marvin--: you'd also derive Data to use it (seemingly)
12:25:41 <thornber> Darius: thanks, that helps
12:26:03 <Marvin--> Darius: Data?
12:26:19 * esap suspects using ghc-6.0 will reduce the amount of code in my compiler by 40% or so :-)
12:26:40 <Darius> Yes, I believe it's the Strafunski Term class renamed.
12:27:01 <Darius> There is also extended deriving support for newtypes.
12:27:25 <Darius> So if you have (their example) newtype Dollar = Dollar Int you can derive Num
12:34:49 <Marvin--> hrrm... no instance Data Int?
12:35:58 <thornber> is there a standard Data.?? type that I can use to implement a priority queue ? (eg, LeftistHeap from Okasaki)
12:37:14 <Marvin--> why is there an instance for Float, but not for Int? I'm confused
12:38:38 <Marvin--> never mind, though, it's still cute :-)
12:45:16 <Marvin--> oh for...
12:45:30 * Marvin-- hacks up an instance for pairs so his program compiles
12:55:20 * esap panics. ghc-6.0 did too.
12:55:50 <jazzman> on which platform, esap?
12:56:04 <esap> jazzman: linux.
12:56:31 <esap> coreSyn/CoreUtils.lhs:1188: Non-exhaustive patterns in function isCrossDllArg
12:58:24 <Darius> Another panic, http://haskell.org/pipermail/glasgow-haskell-bugs/2003-May/003267.html
12:58:29 <Darius> TH related though
12:58:42 <Darius> and apparently CVS
12:58:45 <Lilith> Darius: that's the cvs version?
12:59:44 <Lilith> ah
13:04:08 <Marvin--> Igloo: help?
13:04:17 * Marvin-- boggles
13:07:16 <Marvin--> with this type signature, I get "Mismatched contexts", without it, I get "Could not deduce (Data a1) from the context (Data a)"
13:07:55 <Marvin--> hooray :-/
13:09:28 <Marvin--> damn
13:50:02 <jak> whoo hoo
13:50:08 <jak> ghc 6 
13:50:44 <jazzman> jak: yeah
13:51:23 <jak> what is the effect of this change: "Sweeping internal changes to switch the evaluation model from
13:51:23 <jak>     "push/enter" to "eval/apply"."
13:51:26 <jak> ?
13:51:55 <jazzman> jak: i don't have a freakin clue :)
13:52:00 <jak> heh
13:52:10 <hdaume> jak: it means your programs should run faster
13:52:25 <jak> excellent
13:52:31 <jak> more speed fantastic
13:52:31 <hdaume> jak: see http://www.research.microsoft.com/~simonpj/papers/eval-apply/
15:14:53 <steveh> man!
15:15:13 <steveh> i really want to program something in my free time but I am having no end of trouble thinking of something to work on
15:23:49 <Riastradh> lambdabot!
15:24:07 <Riastradh> @yow , you should write some cool modules for it!
15:24:07 <lambdabot> Toes, knees, NIPPLES.  Toes, knees, nipples, KNUCKLES...
15:24:07 <lambdabot>  Nipples, dimples, knuckles, NICKLES, wrinkles, pimples!!
15:24:07 <lambdabot>  I don't like FRANK SINATRA or his CHILDREN.
15:45:41 <Riastradh> @prelude delete
15:45:43 <lambdabot> *** "delete" prelude "Haskell Standard Prelude Dictionary": text follows
15:45:43 <lambdabot> delete
15:45:43 <lambdabot>   delete ::  (Eq a) => a -> [a] -> [a]
15:45:43 <lambdabot>   delete                   = deleteBy (==)
15:45:53 <Riastradh> Hmm.
15:45:56 <Riastradh> @type List.delete
15:46:01 <Riastradh> Grumble.
15:46:04 <Riastradh> @type delete
15:47:44 <steveh> is the okasaki book worth purchasing?
15:47:56 <Riastradh> Yes.
15:49:07 <steveh> what's the best part about it?
15:51:51 <Riastradh> The 'best' part about it?
15:52:02 <Riastradh> How do you define 'best' here?
15:52:41 <steveh> something that sets it apart, say, from Algorithms: A Functional Programming Approach
15:53:03 <Riastradh> Well, that would be an algorithms book, not a datastructures book, wouldn't it?
15:53:40 <steveh> the two are not easily separable in my mind
15:53:57 <steveh> most of CLR's "Introduction to Algorithms" covers data structures
15:54:27 <Riastradh> Algorithms is a very broad topic; datastructures is broad, too, but it is nevertheless a narrower field of algorithms, which an algorithms book may only glance over.
16:13:23 <mattam> I've read an introduction to tries and wonder where they're used except for dictionaries (and language parsers, as I know now) ?
16:16:58 <mattam> it seemed like i 'invented' them too before reading about them (in a LZ-78 impl.) as i never heard of them since i study CS
16:18:15 <shapr> oy
16:19:08 <hdaume> mattam: they're used in natural language process to try to identify common prefixes and suffixes...
16:19:28 <mattam> yes, i just read that in a paper about adaptive parsing
16:22:20 <mattam> why aren't they part of standard libraries, is a string hashing function so easy to find ?
16:22:52 <shapr> Hm, now there really is an HSU
16:23:28 <mattam> an HSU ?
16:25:10 <shapr> Haskell Secret Underground ;-)
16:25:35 <mattam> hmmm, reminds me of the PSU
16:25:49 <shapr> I strongly suspect they're related.
16:25:51 <mattam> oops
16:25:58 <shapr> but then, I'm not a member of either, so I wouldn't know ;-)
16:26:12 <mattam> I ^H
16:26:21 <shapr> yes, exacty
16:26:37 <shapr> obviously one of the organizations is censoring your computer
16:26:52 <Verbed> Hello
16:26:55 <shapr> hi Verbed 
16:27:08 <Verbed> #trivia
16:27:16 <shapr> nay, not tonite
16:27:25 * Verbed sighs
16:27:44 <shapr> maybe Smerdyakov will challenge you, he was doing very well last time
16:29:03 <shapr> oooh aaah
16:29:06 <shapr> GHC 6.0
16:29:26 <shapr> @topic-init #haskell
16:29:27 <lambdabot> topic doesn't parse
16:29:32 <shapr> yes it does
16:29:33 <shapr> !
16:29:54 --- topic: set to '["mo' nads than you","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","Order Haskell 98 Report in Hardcopy - http://titles.cambridge.org/catalogue.asp?isbn=0521826144","foo"]' by shapr
16:30:00 <shapr> @topic-init #haskell
16:30:00 --- topic: set to '["mo' nads than you","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","Order Haskell 98 Report in Hardcopy - http://titles.cambridge.org/catalogue.asp?isbn=0521826144"]' by lambdabot
16:31:07 <shapr> @topic-snoc #haskell GHC 6.0 Released - http://www.haskell.org/ghc/
16:31:07 --- topic: set to '["mo' nads than you","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","Order Haskell 98 Report in Hardcopy - http://titles.cambridge.org/catalogue.asp?isbn=0521826144","GHC 6.0 Released - http://www.haskell.org/ghc/"]' by lambdabot
16:33:42 <shapr> yay, Template Haskell
16:33:44 <shapr> ohh, mdo
16:33:59 <shapr> wow! typeable can be derived!
16:34:03 * shapr bounces excitedly
16:37:45 <shapr> hrm
16:37:52 <shapr> Data.Generic docs are missing
16:38:11 <shapr> that sucks
16:38:31 <shapr> oh, Vincenzo already mentioned that
16:46:19 <Riastradh> shapr, I'm afraid I sha'n't be able to go to the ICFP or HW, unless something drastic happens soon.
16:46:30 <shapr> that sucks
16:46:47 <shapr> no unicycling for you till next year ;-)
16:46:53 <Riastradh> Heh.
16:58:11 * shapr bounces
16:58:14 <shapr> WHEEE
16:58:34 * shapr zooms around the room
16:59:12 <Riastradh> shapr, that's going to happen until you learn how to ride the unicycle properly.
16:59:27 <shapr> hah
16:59:41 <shapr> I'm still not very stable on my uni
17:05:47 <shapr> hi firstein 
17:15:04 <|Fo|Ns> hi
17:15:13 <Riastradh> Hi.
17:25:40 <shapr> y0
17:27:42 <Riastradh> I must decide by tomorrow what I shall teach over the summer...hmm...
17:27:48 <stepcut> good think my gf is out of town for the weekend, ghc 6.0 will be keeping me busy
17:27:54 <Riastradh> Heh.
17:29:28 <stepcut> the biggest problem I have is reading/writing binary file formats (wavs, pngs, etc) in haskell
17:51:43 * jazzman reads the push/enter eval/apply paper
18:14:54 <Igloo> Hmmm, the problem with living on the bleeding edge is that nothing works
18:15:03 <jazzman> hehe
18:15:12 <jazzman> what doesn't work, anyway?
18:15:14 <Igloo> Unfortunately the same is true when falling back to the Debian versions and trying to use something recent off the web
18:15:34 <Igloo> c2hs doesn't know about GHC 6
18:15:54 <jazzman> what's c2hs?
18:17:08 <Igloo> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
18:19:16 <jazzman> ah, i see
18:19:31 <jazzman> well, i'd be surprised if it supported a compiler that was released today :)
18:19:52 <Igloo> :-)
20:21:00 <inkedmn> ok, going through a tutorial and i'm working on one of the exercises...
20:21:26 <inkedmn> says to write some code that takes a list of pairs and grabs the first item from the second pair in the list
20:22:47 <inkedmn> firstsec l 
20:22:48 <inkedmn>     | length l > 2  = fst (l!!1) 
20:22:48 <inkedmn>     | otherwise     = -1
20:23:00 <inkedmn> that's what i've got and i get an error when i try to load it into hugs...
20:24:14 <inkedmn> ERROR "/code/haskell/code/Ch3.hs":21 - Inferred type is not general enough
20:25:14 <inkedmn> (line 21 is the first guard)
20:25:44 <stepcut> works for me in ghci
20:25:51 <inkedmn> hmm
20:26:23 <stepcut> might not like the -1
20:26:33 <inkedmn> hmm, could be...
20:26:35 * inkedmn changes
20:26:48 <stepcut> which line is line 21?
20:28:20 <stepcut> inkedmn: the way you wrote the function, it will only work if the first element in every pair is and integar
20:28:36 <inkedmn> firstsec l = fst (l!!1)  
20:28:38 <inkedmn> that works
20:28:44 <inkedmn> took out the guards, etc.
20:53:18 * stepcut ponders dynamics
20:54:23 * kunphuzil ponders stepcut pondering dynamics
20:55:39 <stepcut> i am working on a mysql interface for haskell. One of the issues I have is making sure that the types in the haskell program and the mysql database are the same
20:55:52 <stepcut> since the database returns everything as strings
20:57:02 <stepcut> and more importantly, the database can change the type of a field without the haskell program being recompiled, so even if everything was verified at compile time, it could change later
20:57:10 * steveh wonders if Darius is around...
20:57:37 <Darius> ish
20:58:08 <steveh> I hear you wrote @eval -- can you point me to any docs that you might have?
21:00:52 <Darius> The main ideas it uses are from "Monad Transformers and Modular Interpreters" a related paper is "Language Prototyping Using Modular Monadic Semantics"
21:01:14 <Darius> Those should be approximately the correct titles and both should be able to be found on citeseer.
21:01:21 <steveh> ok
21:01:39 <steveh> thanks :)
21:02:00 <Darius>  @eval is extremely simplistic.  There are armies of optimizations that could be made.
21:02:51 <Darius> Right now though, I prefer it easy to mess with.
21:03:13 <steveh> makes sense
21:09:05 <wli> is that the LPS thing from the guy from .es?
21:11:42 <Darius> I think the 2nd paper was a bit before that, but yah, I think that's them.
21:36:12 <cale> @eval S K K
21:36:13 <lambdabot> <<EM Dynamic -> EM Dynamic>>
21:36:36 <cale> @eval S I I (S I I)
21:36:40 <lambdabot> out of fuel - use @resume to continue
21:37:36 <cale> @eval S K K "a"
21:37:37 <lambdabot> a
21:38:35 <cale> @define rot S ( S (K S) (S (K K) (S (K S) (S (K (S (S K K)))K))))(K K)
21:38:35 <lambdabot> rot defined
21:38:51 <cale> @eval rot "a" "b" "c"
21:38:51 <lambdabot> type error
21:40:31 <cale> oh, of course - "b" and "b" "c" both need to be functions for that to work...
21:41:01 <cale> @eval +
21:41:02 <lambdabot> (line 1, column 1):
21:41:02 <lambdabot> unexpected "+"
21:41:02 <lambdabot> expecting white space or simple term
21:41:14 <cale> @eval add
21:41:14 <lambdabot> unbound variable: add
21:41:37 <cale> @eval 3 + 4
21:41:37 <lambdabot> 7
21:42:00 <cale> @define add \x. y. x+y
21:42:01 <lambdabot> add defined
21:42:09 <cale> @eval add 3 4
21:42:10 <lambdabot> type error
21:42:32 <cale> @define add \x.\y.x+y
21:42:33 <lambdabot> add defined
21:42:38 <cale> @eval add 3 4
21:42:40 <lambdabot> 7
21:42:52 <cale> @eval rot 3 add 4
21:42:52 <lambdabot> type error
21:43:08 <cale> @help
21:43:09 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
21:43:22 <cale> lambdabot: @listcommands
21:43:23 <lambdabot> I react to the following commands: ["all-dicts","board","define","definitions","del-definition","devils","dict","dict-help","dump","easton","echo","elements","eval","fact","flip-board","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","more","msg","part","ply","prelude","quit","reset-chess","resume","searchml","set-fuel","
21:44:45 <cale> @eval ((add 6) 7)
21:44:45 <lambdabot> 13
21:47:44 <cale> @define rot \x.\y.\z. ((y z) x)
21:47:44 <lambdabot> rot defined
21:47:54 <cale> @eval rot 3 add 4
21:47:55 <lambdabot> 7
21:48:59 <cale> hrm, that works. Maybe my definition for the SK variant of rot had a typo.
21:49:08 <wli> @eval let primes = 2 : 3 : 5 : [ p | p <- [7,9..], all ((/=0) . (mod p)) (takeWhile (<=(ceiling . sqrt . fromInteger $ p)) primes)] in take 10 primes
21:49:09 <lambdabot> (line 1, column 12):
21:49:09 <lambdabot> unexpected "="
21:49:09 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or end of input
21:49:52 <cale> lambdabot doesn't evaluate haskell.
21:50:10 <wli> woops
21:51:38 <Darius> no, it's an LC interpreter
21:52:28 <Darius> Things are targetted at being as Haskell like as possible though, the most notable exception (not of omission) is \x. instead of \x->
21:52:52 <cale> and you can't \x y. it seems
21:53:04 <Darius> Yes you can.
21:53:05 <cale> or can you?
21:53:22 <Darius> @get-definition K
21:53:22 <lambdabot> K = \x y.x
21:53:28 <cale> ah
21:53:41 <Darius> @listcommands eval
21:53:42 <lambdabot> Module eval provides the following commands: ["eval","define","get-definition","definitions","del-definition","dump","set-fuel","resume"]
21:54:03 <cale> is there a way to get the type information for something?
21:54:39 <Darius> Not for @eval, as it's dynamically typed and I haven't/don't provide access to the type.
21:54:46 <Darius> For Haskell there's @type and @prelude
21:56:18 <cale> It seems to use parsec for parsing - I've just been playing around with parsec. It's really nice.
21:57:17 * Darius really likes Parsec.
21:57:25 <Darius> Of course, I haven't used too many others...
22:01:45 <cale> @listcommands
22:01:46 <lambdabot> I react to the following commands: ["all-dicts","board","define","definitions","del-definition","devils","dict","dict-help","dump","easton","echo","elements","eval","fact","flip-board","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","more","msg","part","ply","prelude","quit","reset-chess","resume","searchml","set-fuel","
22:01:52 <cale> @hello
22:01:52 <lambdabot> Hello world. 
22:01:59 <cale> @hello rest
22:01:59 <lambdabot> Hello world. rest
22:02:14 <cale> okay.
22:07:57 <flippo> @yow
22:07:57 <lambdabot> Yes, Private DOBERMAN!!
22:14:20 <lament> @board
22:14:21 <lambdabot>  r n b q k b n r
22:14:21 <lambdabot>  p p p p p p p p
22:14:21 <lambdabot>  - - - - - - - -
22:14:21 <lambdabot>  - - - - - - - -
22:14:21 <lambdabot>  - - - - - - - -
22:14:22 <lambdabot>  - - - - - - - -
22:14:24 <lambdabot>  P P P P P P P P
22:14:26 <lambdabot>  R N B Q K B N R
22:14:27 <lament> whoa.
22:14:31 <lament> I hate chess.
22:18:10 <cale> cale@zaphod[~/downloads/lambdabot]$ ./lambdabot
22:18:13 <cale> Running reader loop...
22:18:14 <cale> Exception: end of file
22:18:18 <flippo> that list of commands appears truncated
22:18:20 <cale> Action: hGetChar
22:18:21 <cale> Handle: {loc=<socket: 3>,type=duplex (read-write),binary=True,buffering=none}
22:18:27 <cale> File: <socket: 3>
22:18:33 <cale> hmm..
22:27:40 <cale> @state
22:27:40 <lambdabot> nothing yet
22:28:07 <Darius> flippo: indeed, it's (I'm pretty sure) the IRC layer.  It truncates things greater than ~512 characters.
22:28:26 <Darius>  @state and @hello are demo modules.
22:28:44 <flippo> maybe the bot needs to break long lines into multiple messages
22:28:49 <cale> yeah - I'm just looking at them now.
22:29:22 <cale> I'm trying to work my S K evaluator into lambdabot. I need a state to maintain the dictionary of defined terms.
22:29:35 <Darius> flippo: indeed again, it needs to merge multiple messages into one as well.
22:31:16 <Darius> eval module (obviously) has code that does that, though the EvalModule.hs file is rather... hectic.
22:33:47 <Darius> No one happens to know why Sylpheed-Claws won't let me delete news messages do they?
22:34:38 <Darius> @definitions j
22:34:38 <lambdabot> ["joy","joyBinOp","joyDefs","joyIFTE"]
22:44:50 <cale> although I barely understand what is going on there, I think I understand it enough to make use of it.
22:50:40 <cale> I have a function returning type IO a (where a is actually Dict PComb PComb, but that's not important). Will I be able to modify it to use ircPrivmsg instead of putStrLn?
22:51:09 <cale> Seems I should be able to - what should the type be?
22:51:40 <Darius> You'll need to return IRC a instead and liftIO any IO functions you use.
22:52:06 <cale> alright, cool
23:15:15 * andersca boings
23:23:47 <cale> okay, I've now got it down to the totally bizarre error messages.
23:25:48 <cale> mostly things like "No instance for (Data.Dynamic.Typeable (StateT IRCRWState (Control.Monad.Reader.ReaderT IRCState IO) (Dict PComb PComb)))
23:27:03 <cale> or perhaps the easier looking No instance for (Data.Dynamic.Typeable (Dict a b))
23:27:13 <cale> what is this class?
23:41:31 <Smerdyakov> If anyone would like to see an interesting gizmo, visit http://www.hprog.org/applet.html !
23:42:49 <cale> oops - my java plugin doesn't want to register the mime type "application/x-java-vm" for some reason (I've had that problem quite a bit lately).
23:48:30 <demoncrat> smerdyakov - neato :)
23:48:43 <demoncrat> i did manage to hang it with my incorrect definition of Y
23:51:51 <Smerdyakov> This was not unexpected. ;-)
23:52:15 <Smerdyakov> Are there any Haskell interpreters written in Java?
23:52:25 <demoncrat> not so far as i know
23:53:10 <Smerdyakov> Hm... so is your applet actually closed now? Because if so, the server doesn't know that! :-O
23:53:19 <demoncrat> heheh
23:53:34 * Lilith perks up
23:53:43 <demoncrat> just reconnected - i guess it's still stuck on h8oracle
23:54:15 <stepcut> you wouldn't have to have a haskell interpreter written in Java, just one compiled to java byte-code
23:54:30 <Smerdyakov> OK, pretend I said that!
23:54:54 <stepcut> the answer is still no :)
23:54:59 <demoncrat> actually yes, you would need an interpreter for an applet, because of the lameo security scheme
23:55:28 <demoncrat> (unless you upload the bytecode to the server and then redownload it)
23:55:44 <Lilith> why?
23:55:47 <Smerdyakov> Well, the lameo security scheme makes it easy for people to participate in this without worrying about running malicious code.
23:56:01 <demoncrat> lilith - applets can't define their own classloader
23:56:06 <Lilith> if it's already in java bytecode, you should bve able to run it?
23:56:07 <Smerdyakov> And this includes the server :-)
23:56:08 <demoncrat> which is necessary to run generated bytecode
23:56:15 <demoncrat> lilith - i agree
23:56:22 <wli> Java is pretty gross.
23:56:29 <Lilith> heh
23:56:55 <demoncrat> smerdyakov - sure protections are needed, java just doesn't do it very well
23:56:58 <Lilith> i'm doing a haskell->java thing for my thesis..
23:57:05 <demoncrat> compiler?
23:57:47 <stepcut> lilith: does it convert haskell code to java code or haskell code to java byte-code?
23:58:05 <Lilith> stepcut: http://www.cse.unsw.edu.au/~shuyingw/thesis
