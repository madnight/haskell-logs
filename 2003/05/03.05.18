00:30:58 <wli> flip (\x -> (.) (flip ($) x) (flip ($) x))
00:31:00 <wli> okay
00:31:01 <wli> what next?
00:32:24 <wli> (\x -> (.) (flip ($) x) . (flip ($)) $ x)
00:32:34 <wli> okay
00:36:26 <wli> flip (\x -> (flip (.)) (flip ($)) ((.) (flip ($) x)) $ x)
00:36:31 <wli> more progress
00:38:32 <wli> flip (\x -> (flip (.)) (flip ($)) ((.) . (flip ($)) $ x) $ x)
00:41:05 <wli> flip (\x -> (((flip (.)) (flip ($))) (((.) . (flip ($))) x)) x)
00:44:19 <wli> flip (\x -> ((.) ((flip (.)) (flip ($))) ((.) . (flip ($))) x) x)
00:47:19 <wli> Util> :type let f g h x y = g (h x) (h y) in f
00:47:19 <wli> forall t t1 t2. (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
00:47:24 <wli> that's what I actually need
00:47:31 <wli> f . ($) should do it
00:47:38 <Darius> or S
00:47:38 <wli> er
00:47:41 <wli> S?
00:47:45 <wli> oh
00:47:47 <wli> yeah
00:48:09 <wli> do I have enough combinators to express S? nfi
00:48:21 <elmex> ohuh... what are you pastinck there? tryinck to confuze me?
00:52:15 <Darius> @eval S (K (S I (K I))) (K I) (\x y.x*y) 4
00:52:15 <lambdabot> 4
00:52:38 <Darius> @eval S (S I (K I)) (K I) (\x y.x*y) 4
00:52:38 <lambdabot> type error
00:52:55 <wli> I've written the bicomposition thing before
00:53:21 <wli> should be flip (bicomp . ($)) or something
00:55:27 <Darius> @eval S (S (K S) (S (S (K S) (S (K K) I)) (K I))) (K I) (\x y.x*y) 4
00:55:27 <lambdabot> 16
00:56:01 <wli> damn I don't remember how I did it
00:56:45 <Darius> @eval joy "4 dup *"
00:56:47 <lambdabot> [16]
00:57:05 <elmex> uhm, i'm a bit.. curious what that S K I stuff is?
00:57:17 <Darius> combinatory logic
00:57:24 <wli> well
00:57:27 <Darius> I is just sugar I == S K K
00:58:06 <elmex> and what is combinatory logic? :) (never studied CS)
00:58:33 * Darius has never studied CS formally.
00:58:38 <wli> I'm trying to reduce \f -> \x -> (f x x) to something in terms of flip, (.), ($), and others
00:58:53 <wli> things that exist in haskell
00:58:59 <Darius> flip == C, (.) == B 
00:59:34 <Darius> $ is (id.) ?
00:59:40 <Darius> @type (id.)
00:59:41 <lambdabot> (id .) :: (a -> b) -> a -> b
00:59:41 <elmex> what is ($) again?
00:59:49 <Darius> @prelude ($)
00:59:50 <elmex> oh, uhm?
00:59:54 <lambdabot> *** "($)" prelude "Haskell Standard Prelude Dictionary": text follows
00:59:54 <lambdabot> ($)
00:59:54 <lambdabot>   infixr 0 $
00:59:54 <lambdabot>   ($) ::  (a -> b) -> a -> b
01:00:00 <elmex> ah, yes..
01:01:32 <wli> ewll B and C probably aren't complete
01:01:46 <Darius> I think it needs a few more
01:01:54 <Darius> (in fact I'm sure it does)
01:02:17 <wli> who knows
01:03:49 <Darius> @eval B B (\x y.x*y) 4
01:03:49 <lambdabot> <<EM Dynamic -> EM Dynamic>>
01:05:20 <elmex> hm, is it possible to resize an array?
01:05:34 <Darius> Sure, make a new bigger one.
01:05:47 <Darius> (or smaller)
01:06:10 <elmex> oh.hm...i'm not familiar with that array concept in haskell yet :)
01:06:44 <Darius> Well, if you are using functional (standard Haskell 98) arrays, then resizing is not something you want to do.
01:06:58 <Darius> Functional arrays should be write once.
01:07:53 <elmex> :) how to have associative lists? which i may resize and able to access by an index?
01:09:10 <Darius> Use lists? or if you want more performance finite maps or see Purely Functional Datastructures by Chris Okasaki.
01:10:10 <Darius> @type Assoc
01:10:16 <Darius> @prelude Assoc
01:10:17 <lambdabot> No match for "Assoc".
01:10:31 <Darius> oh well
01:10:36 <Darius> @type lookup
01:10:36 <lambdabot> lookup :: Eq a => a -> [(a,b)] -> Maybe b
01:10:53 <elmex> hmm, i don't have that book
01:12:21 <Darius> There's a paper on citeseer too.
01:14:00 <elmex> Purely Functional Random-Access Lists - Okasaki (1995) ?
01:15:52 <Darius> Well, that's not the one I was talking about, but sure!  There's a Purely Functional Data Structures on there too.
01:16:07 <elmex> well, i don't want to implement one :) i want to use them
01:18:20 <Darius> Edison has implementations for the things described (and you can just copy and paste the code if it's Haskell).
01:18:48 <elmex> Functional Data Structures (1996) ?
01:19:10 <Darius> Edison is no longer maintained by Chris Okasaki, but Pseudonym is now "maintaining" it as HFL.
01:19:48 <Darius> That's probably it.  It's a good read.  I don't remember if it's SML or Haskell.
01:21:40 <elmex> isn't there some random access list/array implementation in hslibs or somewhere already?
01:22:24 <Darius> That would probably be in Edison.
01:22:43 <elmex> what was Edison?
01:23:17 <Darius> A library of purely functional data structures.  It's still available and comes with GHC, it's just not being maintained anymore.
01:23:35 <elmex> uh
01:25:55 <seth_> Darius: don't forget the updated version pseudonym is working on:  hfl
01:26:08 <Darius> I already mentioned that earlier.
01:26:16 <seth_> Darius: ok, I just got here.  :)
01:26:22 <seth_> I've been using it, it is quite good.
01:26:46 <elmex> oh, ok
01:26:54 <elmex> i will give it a try. thansk
01:26:56 <elmex> thanks
01:27:27 <seth_> elmex: if you can find the Okasaki book it has a lot of information about the data structures.  Darius probably already said that, too.  :)
01:27:52 <elmex> seth_: well... i'm a student... don'
01:27:57 <elmex> t have much money
01:28:05 <seth_> elmex: maybe in the library?
01:30:06 <elmex> seth_: nah, none local lib i know here has that englisch book (i'm in germany, and the local university/college hasn't those books...well, at least i don't guess it has)
01:30:56 <Darius> Seems to be quite a few German/Dutch/other people here, you may still want to check.
01:31:16 <elmex> yes, ok :)
01:31:34 <elmex> well. i just see, there is some hashtable implementation in Data
01:32:04 <seth_> elmex: yes.  the library ones are richer, but the data one works well.
01:32:42 <elmex> works well?
01:32:52 <Darius> If you mean Data as the GHC hierarchical libraries, then Edison is in the old libraries.
01:33:15 <elmex> fptools/libraries/base/Data
01:33:30 <Darius> That would be the hierarchical libs.
01:34:04 <Darius> fptools/hslib is the old libraries.
01:34:29 <elmex> ah, yes. 
01:35:01 <elmex> well, if it is not maintained, does that mean it's buggy? or is it reliable?
01:36:47 <Darius> It means if you find a bug, there is no one to tell.  HFL has been updated some, I'm not sure what needs to be tweaked with it.  hfl.sf.net is th URL I believe.
01:37:50 <elmex> yes, i found that already. well, i guess, i only need a hashtable for my purposes...
01:39:46 <Darius> It's probably easiest just to use Data.FiniteMap if that's all you really need.  Unfortunately, I don't think it has documentation of the time complexity (though assumedly it's reasonable).
01:43:03 <elmex> well, ok. thanks for the informations!
01:49:35 * shapr yawns
01:49:47 <shapr> gooood morning #haskell!
01:50:51 <shapr> hi Marvin-- 
01:51:32 * andersca bounces
01:51:37 * shapr boings
01:51:41 <Marvin--> morning
01:51:46 <shapr> hej andersca, how's the funky keyboard?
01:52:16 <andersca> I'm seriously considering swapping my alt and altgr keys
01:52:32 <shapr> if it works for you, do it.
01:52:38 <andersca> to write {[]} and \ I need to use only one hand
01:52:40 <andersca> and I'd rather use two
01:53:04 <shapr> you'd rather use two hands?
01:53:12 <andersca> yeah
01:54:02 <Marvin--> ]}\ is pretty okay, IMO, but {[ is somewhat painful
02:03:27 <Darius> @type (/)
02:03:28 <lambdabot> (/) :: Fractional a => a -> a -> a
02:03:37 <Darius> @type (%)
02:03:38 <lambdabot> (%) :: Integral a => a -> a -> Ratio a
02:04:07 <Darius> @prelude foldl
02:04:09 <lambdabot> *** "foldl" prelude "Haskell Standard Prelude Dictionary": text follows
02:04:09 <lambdabot> foldl
02:04:09 <lambdabot>   foldl ::  (a -> b -> a) -> a -> [b] -> a
02:04:09 <lambdabot>   foldl f z []      = z
02:04:09 <lambdabot>   foldl f z (x:xs)  = foldl f (f z x) xs
02:16:54 * shapr boings
02:17:21 <andersca> coool!
02:17:30 <andersca> @prelude length
02:17:32 <lambdabot> *** "length" prelude "Haskell Standard Prelude Dictionary": text follows
02:17:32 <lambdabot> length
02:17:32 <lambdabot>   length ::  [a] -> Int
02:17:32 <lambdabot>   length            = foldl' (\n _ -> n + 1) 0
02:18:25 <andersca> @prelude Monad
02:18:27 <lambdabot> *** "Monad" prelude "Haskell Standard Prelude Dictionary": text follows
02:18:27 <lambdabot> Monad
02:18:27 <lambdabot>   class Monad m where
02:18:27 <lambdabot>       return :: a -> m a
02:18:28 <lambdabot>       (>>=)  :: m a -> (a -> m b) -> m b
02:18:30 <lambdabot>       (>>)   :: m a -> m b -> m b
02:18:32 <lambdabot>       fail   :: String -> m a
02:18:34 <lambdabot>       -- Minimal complete definition: (>>=), return
02:18:36 <lambdabot> [there's @more]
02:18:44 <andersca> @more
02:18:44 <lambdabot>       p >> q  = p >>= \ _ -> q
02:18:44 <lambdabot>       fail s  = error s
02:19:19 * Marvin-- is waiting for the Frozen Throne
02:19:22 <ludde> @eval 1+2
02:19:23 <lambdabot> 3
02:19:28 <ludde> @eval sum [1..]
02:19:28 <lambdabot> (line 1, column 7):
02:19:28 <lambdabot> unexpected "."
02:19:28 <lambdabot> expecting digit, operator, simple term, "," or "]"
02:19:32 <andersca> @eval 1/0
02:19:33 <lambdabot> divide by zero
02:19:34 <andersca> woo
02:19:39 <ludde> @eval 0/0
02:19:39 <lambdabot> divide by zero
02:19:47 <Darius> .. notation isn't implemented
02:19:57 <ludde> @eval let f = 1 in f
02:19:57 <lambdabot> (line 1, column 7):
02:19:57 <lambdabot> unexpected "="
02:19:57 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or end of input
02:20:04 <Darius> nor lets
02:20:14 <ludde> @eval f where f=1
02:20:14 <lambdabot> (line 1, column 10):
02:20:14 <lambdabot> unexpected "="
02:20:14 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or end of input
02:20:15 <andersca> time to write the article
02:20:23 <ludde> maybe that's not valid syntax anyway
02:20:26 <Marvin--> andersca: what article?
02:20:27 <Darius> It's an extended lambda calculus intepreter, not haskell.
02:20:29 <andersca> Marvin--: for guadec
02:20:31 <andersca> about d-bus
02:20:33 <Marvin--> andersca: aha
02:20:37 <ludde> @eval (\x.x) 1
02:20:37 <lambdabot> 1
02:20:44 <ludde> @eval (\x.x)(\x.x)
02:20:44 <lambdabot> <<EM Dynamic -> EM Dynamic>>
02:20:54 <ludde> @eval (\x.x x) 1
02:20:54 <Darius> @eval id id
02:20:55 <lambdabot> <<EM Dynamic -> EM Dynamic>>
02:20:55 <lambdabot> type error
02:21:05 <ludde> @eval (\x.x x) (\x.x x)
02:21:09 <lambdabot> out of fuel - use @resume to continue
02:21:09 <Darius> @definitions
02:21:09 <lambdabot> ["B","Branch"]
02:21:09 <lambdabot> ["C","Cons"]
02:21:09 <lambdabot> ["False"]
02:21:09 <lambdabot> ["I"]
02:21:10 <lambdabot> ["Just"]
02:21:12 <lambdabot> ["K"]
02:21:14 <lambdabot> ["Leaf","Left"]
02:21:15 <ludde> @resume
02:21:16 <lambdabot> ["MonadError","MonadParser","MonadReader","MonadState","MonadWriter","MonadWriter_"]
02:21:18 <lambdabot> ["Nil","Nothing"]
02:21:20 <lambdabot> [there's @more]
02:21:22 <lambdabot> out of fuel - use @resume to continue
02:21:32 <ludde> how does it detect when it's out of fuel?
02:21:54 <Darius> It decrements a counter on each variable lookup
02:22:05 <ludde> i see
02:22:22 <ludde> @eval sum [1,2,3]
02:22:22 <lambdabot> 6
02:22:49 <ludde> @eval sum $ [1,2] ++ [1,2]
02:22:49 <lambdabot> (line 1, column 5):
02:22:49 <lambdabot> unexpected "$"
02:22:49 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or end of input
02:22:53 <ludde> @eval sum ([1,2] ++ [1,2])
02:22:54 <lambdabot> 6
02:23:08 <ludde> does it have a recursion combinator?
02:23:51 <Darius> You can @define definitions that can be (mutually) recursive, and since it's dynamically typed Y is fine.
02:23:59 <Darius> @get-definition Y
02:23:59 <lambdabot> Y = \f. U (\g. f (U g))
02:24:10 <ludde> @get-definition U
02:24:11 <Darius> gah
02:24:11 <lambdabot> U = \f. f f
02:24:17 <Darius> @get-definition Y'
02:24:18 <lambdabot> Y' not defined
02:24:23 <ludde> how do I use Y?
02:24:36 <Darius> @define Y' \f.U(\g.f(U g))
02:24:37 <lambdabot> Y' defined
02:24:53 <Darius> @eval take 10 (Y' (\a.1:a))
02:24:53 <lambdabot> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
02:25:05 <Darius> @define Y \f.f(Y f)
02:25:05 <lambdabot> Y defined
02:25:11 <Darius> @dump
02:25:12 <lambdabot> dumped
02:25:27 <ludde> @eval take 100 (Y' (\a.1:a))
02:25:28 <lambdabot> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
02:25:35 <ludde> @eval sum (take 10000 (Y' (\a.1:a)))
02:25:41 <lambdabot> out of fuel - use @resume to continue
02:25:45 <ludde> @eval sum (take 1000 (Y' (\a.1:a)))
02:25:47 <lambdabot> 1000
02:25:55 <ludde> is there no way to crash it?
02:26:17 <Darius> Certainly. Iell me if you find one.
02:26:33 <Marvin--> heh
02:26:38 <ludde> what happens if it crashes, does lambdabot exit?
02:27:09 <shapr> usually
02:27:18 <ludde> cool
02:27:26 <shapr> or it eats all the ram on my box
02:27:42 <ludde> @eval length (take 1000 (Y' (\a.1:a)))
02:27:44 <lambdabot> 2
02:27:47 <ludde> hmm
02:27:53 <ludde> @eval length (take 10 (Y' (\a.1:a)))
02:27:54 <lambdabot> 2
02:28:00 <ludde> what's up here
02:28:03 <Darius> @get-definition lenght
02:28:03 <lambdabot> lenght not defined
02:28:06 <Darius> @get-definition length
02:28:06 <lambdabot> length = foldl (\x y.1+y) 0
02:28:09 <ludde> @eval take 10 (Y' (\a.1:a))
02:28:10 <lambdabot> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
02:28:18 <ludde> is it broken?
02:28:30 <ludde> @eval length (take 10 (Y' (\a.1:a)))
02:28:30 <lambdabot> 2
02:28:32 <Darius> Yeah, I think I mistyped foldl
02:28:40 <Darius> I fixed it but didn't dump the changes.
02:28:42 <ludde> @get-definition foldl
02:28:42 <lambdabot> foldl = \c n l.if null l then n else foldl c (c n (head l)) (tail l)
02:29:07 <ludde> are there any known ways to crash it?
02:29:51 <ludde> @eval head null
02:29:52 <lambdabot> type error
02:29:58 <ludde> @eval head []
02:29:59 <lambdabot> head of empty list
02:30:17 <Darius> @define length foldl (\x y.x+1) 0
02:30:18 <lambdabot> length defined
02:30:30 <Darius> @eval length [1,3,5,6]
02:30:30 <lambdabot> 4
02:30:32 <ludde> ah heh
02:30:44 <Darius> @dump
02:30:45 <lambdabot> dumped
02:30:52 <ludde> @dump saves it to disk?
02:30:53 <lambdabot> not enough privileges
02:31:05 <Darius> Yes
02:31:21 <ludde> @help
02:31:21 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
02:31:25 <ludde> @listcommands
02:31:25 <lambdabot> I react to the following commands: ["all-dicts","board","define","definitions","del-definition","devils","dict","dict-help","dump","easton","echo","elements","eval","flip-board","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","more","msg","part","ply","prelude","quit","reset-chess","resume","set-fuel","state","topic-cons
02:31:36 <Darius> hehe, you wish (uber @help)
02:31:39 <elmex> does putStrLn output "
02:31:40 <ludde> @set-fuel 10000
02:31:41 <lambdabot> not enough privileges
02:31:48 <elmex> does putStrLn output "\r\n
02:31:54 <elmex> on windows systems
02:32:13 <ludde> @ply
02:32:14 <lambdabot> must give a valid move
02:32:18 <elmex> (i hate this keyboard)
02:32:20 <ludde> @ply 3d-e
02:32:21 <lambdabot> not a valid move
02:32:29 <ludde> @help ply
02:32:29 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
02:32:32 <Darius> @listmodules
02:32:33 <lambdabot> I have the following modules installed: ["chess","dict","eval","fortune","hello","karma","more","state","system","topic","type","yow"]
02:32:39 <ludde> @ply help
02:32:39 <lambdabot> not a valid move
02:32:40 <Darius> @listcommands chess
02:32:40 <lambdabot> Module chess provides the following commands: ["ply","reset-chess","validmoves","board","flip-board"]
02:32:45 <ludde> @validmoves
02:32:46 <lambdabot> [Ng1-h3,Ng1-f3,Nb1-c3,Nb1-a3,Ph2-h3,Ph2-h4,Pg2-g3,Pg2-g4,Pf2-f3,Pf2-f4,Pe2-e3,Pe2-e4,Pd2-d3,Pd2-d4,Pc2-c3,Pc2-c4,Pb2-b3,Pb2-b4,Pa2-a3,Pa2-a4]
02:32:52 <shapr> @help would be a good module
02:32:52 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
02:33:03 <shapr> it's been on the to-do list for sometime
02:33:08 <ludde> @board
02:33:08 <lambdabot>  r n b q k b n r
02:33:08 <lambdabot>  p p p p p p p p
02:33:08 <lambdabot>  - - - - - - - -
02:33:08 <lambdabot>  - - - - - - - -
02:33:08 <lambdabot>  - - - - - - - -
02:33:09 <lambdabot>  - - - - - - - -
02:33:11 <lambdabot>  P P P P P P P P
02:33:13 <lambdabot>  R N B Q K B N R
02:33:47 <ludde> NB1-a3
02:33:56 <ludde> @ply Nb1-a3
02:34:04 <lambdabot> I move: Pc7-c6
02:34:10 <ludde> oh, it has AI too
02:34:15 <ludde> @board
02:34:15 <lambdabot>  r n b q k b n r
02:34:15 <lambdabot>  p p - p p p p p
02:34:15 <lambdabot>  - - p - - - - -
02:34:15 <lambdabot>  - - - - - - - -
02:34:15 <lambdabot>  - - - - - - - -
02:34:16 <lambdabot>  N - - - - - - -
02:34:18 <lambdabot>  P P P P P P P P
02:34:20 <lambdabot>  R - B Q K B N R
02:34:35 <ludde> @reset-chess
02:34:54 <andersca> I like the new logo on haskell.org
02:35:13 <Marvin--> I don't
02:35:14 <shapr> me too
02:35:29 <shapr> Marvin--: you think the simpler logo is better?
02:35:32 <Marvin--> yes
02:35:39 <esap> Colors are too dark.
02:35:42 <Darius> I'm with Marvin-- on this
02:35:43 <Marvin--> this one's too cluttered, and the colours really suck
02:35:47 <ludde> I prefer the older logo too
02:35:53 <ludde> I don't like the greenish circle
02:36:21 <Darius> Marvin--: It wouldn't be too bad, but some symbols are somewhat ridiculous, e.g. '::' and '=>'
02:38:51 <esap> The logo should have both depth and simplicity. That green stuff is clearly shallow and the symbols denote complexity. Not good.
02:39:22 <shapr> the lambda by itself is simple and clear
02:39:23 <Darius> Personally, I found the old one simple and attractive.  I find the new one less of both.
02:40:11 <shapr> well, let's mention that on haskell@h.o then
02:40:30 <shapr> I could go with something like a lambda inside a circle
02:40:50 <shapr> I liked the brighter blue of the old lambda
02:40:58 <shapr> maybe we should come up with better options?
02:41:35 <Darius> I'm not sure why it was changed. (Presumably from the off-hand comment that Haskell.org could use graphic designers)
02:41:39 * Marvin-- blushes and admits he's not subscribed to h@h.o
02:42:15 * esap also blushes and goes read the archives.
02:42:51 <Darius> Personally, I could go for a little CSS, but I -definitely- don't want to load a bunch of jpgs just to browse (not that that has changed ... yet)
02:44:16 <shapr> anyone here has enough graphics skill to come up with other logo ideas?
02:44:33 <Marvin--> no :)
02:44:41 <Marvin--> but I'd be happy to say "yeah, that sucks too" ;)
02:44:43 <shapr> heh
02:44:54 <shapr> I took a bunch of art classes in college
02:44:57 * Marvin-- subscribes to h@h.o
02:45:01 <Marvin--> been meaning to for a long time
02:45:17 <Darius> I haven't tried, but my position is "what's wrong with the old one?"
02:45:29 <Darius> There are a lot more boring lambda logos out there.
02:45:56 <shapr> actually, I think the symbols in the logo match the words in the graphic
02:46:18 <shapr> :: for static typing, -> for higher order functions, => for polymorphism, >> for monadic effects
02:46:30 <Marvin--> yes they do
02:46:34 <Marvin--> it's still butt ugly though
02:46:40 <shapr> :)
02:47:22 <shapr> tetryl: hey, have you heard from the HToolkit guys?
02:48:43 <Igloo> => are classes, \forall is polymorphism I thought
02:48:49 <shapr> ah
02:48:55 <shapr> right :-)
02:48:56 <shapr> oops
02:48:58 * Igloo forgets the word/phrase used for classes
02:49:04 <shapr> type classes
02:49:29 <Darius> Why not >>=?  >> isn't helpful.
02:49:47 * Igloo still thinks the LHS needs to be lighter or something, though
02:49:55 <Darius> Either way, I don't think the logo is the appropriate place to put "features"
02:50:20 <Marvin--> definitely not
02:50:28 <Igloo> Well, it's essentially the same idea as a coat of arms
02:51:06 * Marvin-- swears
02:51:06 <Marvin--> dammit
02:51:17 <Marvin--> gmap is starting to look more and more like a viable alternative
02:51:18 <Igloo> ?
02:51:25 <Darius> The left side by itself, yes.  But without the right side, then it's just meaningless arbitrary symbols.
02:51:27 <Igloo> How come?
02:51:37 <Marvin--> because I keep adding different transformations :)
02:51:43 <shapr> Well, what about a real shield then?
02:51:50 <Igloo> Darius: No more so than a coat of arms  :-)
02:51:51 <Marvin--> they're all subtly different though, so maybe it's not worth it
02:52:22 <shapr> hm, what's the latin for "we put the funk in funktional" ?
02:52:22 * shapr grins
02:52:43 <Igloo> :-)
02:52:49 * shapr suddenly wishes for a wacom tablet
02:52:50 <Darius> Igloo: Can't say that I've examined many coat of arms, but I think they look nicer than that typically, with or without meaning.
02:53:01 * Darius me too. *sigh*
02:53:08 <Darius> Nice Intuous.
02:53:25 <Igloo> Oh, I wasn't defending the actual design, just the concept
02:53:40 <shapr> I used to be pretty good with the wacom tablet attached the top-of-the-line Mac IIci we had in my graphics classes.
02:53:43 <Igloo> I'm not sure I was even defending the concept, actually, just drawing a parallel  :-)
02:54:05 <shapr> it's a good parallel
02:54:14 <shapr> gives us some ideas to explore :-)
02:56:47 <o3> "why that A upside down?"
02:56:48 <o3> teehee
02:57:20 <Marvin--> heh
02:57:24 <Marvin--> o3: go sleep
02:57:39 <o3> 8pm, bit too early to sleep :)
02:57:57 <shapr> yow
02:58:11 <shapr> I've been getting up at 7am :-/
02:58:46 <o3> i've been going to sleep at 7am
02:59:08 <Darius> 6am now and I haven't gone to sleep.
02:59:34 <Darius> but I didn't exactly get up at 7am yesterday.
03:00:10 <shapr> I slept late today, 10am
03:00:17 <shapr> class tomorrow at 9am
03:00:46 <shapr> in english, semicolons are 'metacommas' aren't they?
03:00:50 <o3> it's amazing how many people who do languages don't know about modern typing systems
03:01:04 <shapr> you mean don't know about HM and derivatives?
03:01:20 <shapr> what fits into the list of modern typing systems?
03:01:32 <o3> basically, yes.  e.g. haskell, ml
03:01:42 <o3> shapr: here's some quotes from my thesis writing style
03:01:48 <o3> If the list items contain internal punctuation, but are not all complete sentences, then their first word is not  capitalised and each item is terminated by a semicolon (except the last, which is terminated by a full stop). Example: see the summary at the end of the general advise.
03:01:52 <Marvin--> ghc-5.04.2: fatal error: scavenge_stack: weird activation record found on stack: 0
03:01:52 <Marvin--> eh
03:02:01 <shapr> hey o3, I think you can forward one wiki page to another, thereby having AndrePang go directly to AndréPang
03:02:03 <o3> hmm
03:02:19 <o3> shapr: oh, yeah, i'll bother with that some day :)
03:02:20 <shapr> Marvin--: that's been around forever
03:02:25 <shapr> Marvin--: seems fixed in 5.05
03:02:36 <o3> shapr: oh, hmm, doesn't have anything here about semicolons
03:02:45 <o3> want me to get elements of style and look it up?
03:02:50 <shapr> nah, it won't kill me
03:02:52 <o3> (no, i'm not procrastinating or anything)
03:03:04 <shapr> I was just wondering if that could be used for http://www.haskell.org/hawiki/HowToReadHaskell
03:03:49 <shapr> while reading the english transcription of the code chunk second from the bottom, I realized the missing commas are very confusing
03:03:59 <shapr> and that it might need semicolons
03:04:58 <shapr> there's a way to get Haskell code highlighting in the {{{ }}} chunks
03:05:04 <shapr> someone told me about it...
03:05:35 * shapr explores
03:05:47 <Darius> someone was saying enscript (I thought it was you or to you)
03:06:00 <shapr> yah, it is enscript
03:06:19 <shapr> but there's something special I have to do to get it to recognize Haskell
03:07:03 <opet> enscript -Ehaskell
03:07:52 <Marvin--> is there no concatMapM?
03:07:53 <ludde> do all imperative languages have mutable variables?
03:07:54 * Marvin-- grumbles
03:08:19 <Marvin--> shapr: for .hs it detects haskell automatically
03:08:34 <Darius> ludde: to some, that's the definition of imperative
03:08:43 <ludde> okay
03:10:14 <Marvin--> yeah... implicit state is sort of defining for imperative programming
03:10:46 <Marvin--> but then I guess it depends what you mean with mutable variables
03:10:52 <Marvin--> in some sense, python doesn't have mutable variables, only mutable values
03:11:59 <o3> mutable values?  you can change the value of, say, 5? :)
03:12:18 <Marvin--> no
03:12:22 <Marvin--> not all values are mutable
03:12:24 <Darius> you could do it in FORTRAN!
03:12:40 <o3> :)
03:12:41 <ludde> you can change the value of 5 in fortran?
03:12:53 <ludde> how does that work, heh?
03:13:02 <ludde> all constants are stored as variables in the data segment?
03:13:04 <shapr> yargh
03:13:09 <shapr> galeon does *not* like korean chars
03:13:56 <Darius> At one point in time a couple of bad decisions were made such that constants were passed by reference and you -could- change the value of references, so you could make code to change 1 to 3 say.
03:14:43 <Darius> Actually, they weren't bad decisions by themselves, but together...
03:15:44 <Marvin--> transP (PAs i p) = ifM inlineAsPats (transP p) (return (EVar i))
03:15:44 <Marvin--> yay
03:17:02 <Darius> shapr: what Korean are you reading?
03:17:33 <Darius> (not that I've never been to a Korean, or Bengali, or Telugu, or Japanese, etc. page)
03:17:51 <Marvin--> try unicode.org :)
03:18:25 <shapr> Darius: there's some way I can specify that a chunk of code inside {{{ }}} should use enscript with the Haskell settings, but I've forgotten how...
03:18:35 <shapr> so I'm looking at examples on other Moin wikis
03:18:39 <Marvin--> hrrm, my fonts are really broken *looks at WhatIsUnicode.html*
03:18:51 <Darius> shapr: ah
03:19:24 <o3> works fine on mac os x :)
03:20:09 <o3> wow, i even get anti-aliased chinese characters
03:20:16 <Marvin--> interesting how I see an actor on TV, and then spend an hour thinking "oh, I've seen him somewhere, what was his name again...", go look it up on imdb, say "oh yes, now I remember", and then don't recognize a single movie the actor's been in
03:20:47 <o3> Marvin--: that usually happens to me, but with actresses, not actors ;)
03:22:05 <Marvin--> o3: in this case, I meant it in a rather gender-neutral way (even though I said "his")
03:22:40 <o3> in my case, i didn't.  teehee
03:22:55 <shapr> hi yomega 
03:22:57 <shapr> hello jao
03:23:00 <Darius> agh, my hiragana is rusty
03:23:02 <yomega> lo
03:23:04 <Marvin--> "actor" is probably used more gender-neutrally than "actress", yes ;)
03:23:16 <yomega> anyone has seen "Janni"?
03:23:17 <yomega> :D
03:23:20 <yomega> searchin for him
03:24:19 <yomega> heard he was chatting around here often...
03:24:55 <Darius> Yes, logged off about 12 hours ago
03:25:15 <yomega> ok thx....then i will idle a lit and wait for him :)
03:25:20 <basti_> hi again
03:25:31 <shapr> hi basti_ 
03:25:36 <basti_> hi shapr :)
03:25:41 <shapr> what's up?
03:25:53 <basti_> not much... just wanted to visit again...
03:27:13 <Marvin--> god I hate fonts
03:27:16 <shapr> we're just so much fun ;-)
03:27:24 * Igloo wonders whether special datastrctures for Newtypes in TH are worthwhile
03:27:34 <basti_> yep.... this chan is definitely one of the coolest coder channels I ever saw.
03:27:37 <shapr> yay!
03:28:16 <Darius> Igloo: Oh yeah, I was thinkiing about that.  My thoughts now and earlier are no.  I was wondering if they ever made a significant difference from data.
03:29:14 <o3> they do for the ffi
03:29:23 <Igloo> Darius: I think I wasn't clear - I mean special Constr types as newtype can only have a single argument. Newtype itself is important I think
03:30:00 <shapr> hi buggs 
03:30:52 <buggs> hoi shapr
03:31:02 <Marvin--> god I hate fonts
03:31:02 <o3> hmm, haskell + lengthy variable names don't mix too well
03:31:09 <o3> instancesOfSuperclass classHierarchy originalClassName              currentSuperclassName (lookupWithDefaultFM classHierarchy currentSuperclassName currentSuperclassName)
03:31:23 <Marvin--> heh
03:31:23 * Igloo wishes GHC had a better build system
03:31:50 <Darius> from what I've seen FP languages seem to syntactically grow down and righward.
03:31:51 <esap> I'd guess it works better with do-notation. Imperative programming needs long names :-)
03:32:30 <shapr> buggs: what's up?
03:32:48 <shapr> Igloo: for building GHC itself?
03:33:02 <o3> Darius: how do you mean?
03:33:02 <Igloo> Yup
03:33:12 <buggs> i finally decided to write my own email client, they all suck
03:33:16 <o3> in terms of code presentation, you mean?
03:33:23 <shapr> buggs: in Haskell?
03:33:51 <buggs> nopes ruby
03:33:55 <Darius> o3: if you mean presentation roughly how I think then yes.  How the actual code is laid out in a file.
03:34:07 <wli> I want to use some unusual operating system hooks so I'm stuck doing it at a fairly low-level.
03:38:18 <wli> (basically async io and virtwin)
03:40:56 <wli> I don't intend to support idiotic polling delivery methods
03:41:16 <shapr> heh
03:52:13 <elmex> hm, what is '
03:52:21 <elmex> arh... waht is lex for?
03:52:32 <Marvin--> hrrm, now I want those dup functions
03:54:17 <shapr> elmex: a lexer?
03:54:35 <Darius> elemx: ' isn't much by itself.  It can be part of an identifier otherwise it works like in most languages, 'a'.
03:55:00 <elmex> so, i just splits my string?
03:55:04 <Darius> The only place I've seen lex used is in descriptions of derived Read instances.
03:55:20 <Darius> @type lex
03:55:20 <lambdabot> lex :: ReadS String
03:55:29 <Darius> @prelude lex
03:55:31 <lambdabot> *** "lex" prelude "Haskell Standard Prelude Dictionary": text follows
03:55:31 <lambdabot> lex
03:55:31 <lambdabot>   lex ::  ReadS String
03:55:31 <lambdabot>   lex ""                  = [("","")]
03:55:32 <lambdabot>   lex (c:s) | isSpace c   = lex (dropWhile isSpace s)
03:55:34 <lambdabot>   lex ('\'':s)            = [('\'':ch++"'", t) | (ch,'\'':t)  <- lexLitChar s,
03:55:34 <elmex> i want to parse some string like "bla -> foo"
03:55:36 <lambdabot>   					       ch /= "'"                ]
03:55:38 <lambdabot>   lex ('"':s)             = [('"':str, t)      | (str,t) <- lexString s]
03:55:40 <lambdabot> [there's @more]
03:55:50 <wli> @more
03:55:50 <lambdabot>   			  where
03:55:50 <lambdabot>   			  lexString ('"':s) = [("\"",s)]
03:55:50 <lambdabot>   			  lexString s = [(ch++str, u)
03:55:50 <lambdabot>   						| (ch,t)  <- lexStrItem s,
03:55:50 <lambdabot>   						  (str,u) <- lexString t  ]
03:55:52 <lambdabot>   			  lexStrItem ('\\':'&':s) = [("\\&",s)]
03:55:54 <lambdabot>   			  lexStrItem ('\\':c:s) | isSpace c
03:55:56 <lambdabot>   			      = [("",t) | '\\':t <- [dropWhile isSpace s]]
03:55:58 <lambdabot>   			  lexStrItem s            = lexLitChar s
03:56:00 <lambdabot> [there's @more]
03:56:08 <wli> @more
03:56:09 <lambdabot>   lex (c:s) | isSingle c  = [([c],s)]
03:56:09 <lambdabot>   	  | isSym c     = [(c:sym,t)         | (sym,t) <- [span isSym s]]
03:56:09 <lambdabot>   	  | isAlpha c   = [(c:nam,t)         | (nam,t) <- [span isIdChar s]]
03:56:09 <lambdabot>   	  | isDigit c   = [(c:ds++fe,t)      | (ds,s)  <- [span isDigit s],
03:56:10 <lambdabot>   					       (fe,t)  <- lexFracExp s     ]
03:56:13 <basti_> whoo
03:56:13 <lambdabot>   	  | otherwise   = []    -- bad character
03:56:14 <lambdabot>   		where
03:56:16 <lambdabot>   		isSingle c  =  c `elem` ",;()[]{}_`"
03:56:18 <lambdabot>   		isSym c     =  c `elem` "!@#$%&*+./<=>?\\^|:-~"
03:56:19 <elmex> why do you flood the channel?
03:56:20 <lambdabot> [there's @more]
03:56:26 <wli> no reason
03:57:05 <Darius> if the things are as simple as "bar -> foo" then words might be enough.  There is also a regex library.
03:57:09 <elmex> i guess, evereyone interested can look at the prelude himself ... and i'm only wondering, how i should parse something like "bla -> foo" if i want "bla" and "foo" in some seperate string
03:57:31 <elmex> yes, but i wanted to look for a way without regexes ;)
03:57:53 <wli> regexes aren't that far out
03:58:01 <wli> optimizing the DFA's is kind of painful though
03:58:12 <Marvin--> guh, there's no "finally" function, only bracket?
03:58:12 <elmex> DFA ?
03:58:21 <saz> elmex: all your strings are in that format exactly?
03:58:27 <wli> Deterministic Finite Automata
03:59:01 <elmex> saz: hm, no, not really. maybe some more whitespaces
03:59:18 <saz> elmex: takewhile and dropwhile?
03:59:38 <elmex> saz: what is that?
04:00:03 <Darius> If whitespace is all you are worried about then words "foo -> bar" gives you (I think) ["foo","->","bar"]
04:00:33 <elmex> and where to find that out? i mean, where are all those useful functions?
04:00:42 <saz> elmex: Prelude> :t dropWhile
04:00:42 <saz> forall a. (a -> Bool) -> [a] -> [a]
04:00:52 <Darius> in the prelude or the standard libraries
04:00:56 <saz> but yeah, words would probably be best
04:01:27 <elmex> Darius: i mean, how to find the right function if i don't know where to look?
04:01:40 <saz> elmex: look in the tour of the prelude?
04:02:25 <elmex> tour?
04:02:38 <Darius> There's an online reference (linked in the Books and tutorials section of haskell.org)
04:02:43 <elmex> ah, thre
04:04:04 <elmex> hm, ok, thanks
04:07:30 <wli> HDLE appears to have some good regex stuff
04:07:35 <wli> albeit with ^M everywhere
04:11:34 <wli> it'd be nice if it used some decent data structures
04:13:54 <wli> it's also polymorphic if I'm reading it right
04:14:12 <Darius> @get-definition joy
04:14:13 <lambdabot> joy = \s.either id (\past.eval (fst past) []) (parse s)
04:14:14 <wli> no not quite
04:14:33 <Darius> @get-definition eval
04:14:33 <lambdabot> eval = \l.foldr (flip B) id (map (lookupDef joyDefs) l)
04:14:36 <wli> polymorphic on the input type would be nice
04:15:33 <Darius> Someone was mentioning a regex library that only required the input to be a list of Eq'able things earlier.
04:16:32 <Darius> @get-definition parse
04:16:33 <lambdabot> parse = runMonad MonadParser expr
04:17:00 <wli> something that just took grammars over arbitrary alphabets and had functions to construct and interpret the resulting automata would be nice
04:17:37 <wli> LR(k) and/or LALR(k) would be nice
04:18:43 <wli> as would be regular
04:20:52 <basti_> wli you know what kind of a program you need for LALR(k)?
04:21:31 <wli> yes
04:21:49 <wli> mostly like LALR(1) but I'm not sure how the k generalizes it
04:22:06 <basti_> I was told in class...
04:22:10 <basti_> not that I remember...
04:22:15 <wli> heh
04:22:22 <basti_> its like "a stack automaton that rewrites its own program"
04:22:27 <wli> I've yet to find a reference on how the k generalizes the things
04:22:57 <basti_> Ive one in a old script but its written in german
04:23:20 <wli> send it my way please
04:23:25 <basti_> uhm
04:23:25 <wli> (I can read German)
04:23:31 <basti_> lets see if I can find it digitally
04:23:52 <basti_> ive got a print'd version
04:25:49 <basti_> looking good
04:27:28 <basti_> hmm
04:27:36 <basti_> first ive got an abbreviated version
04:27:58 <basti_> that contains the facts only
04:28:00 <basti_> do you want that?
04:28:17 <wli> I can zen it out relatively easily from a vague description so long as it deals with how the k in LR(k) generalizes over LR(1) and/or LR(0)
04:28:19 <wli> yeah
04:28:29 <wli> DCC or email wli@holomorphy.com
04:29:38 <wli> bad postscript
04:29:42 <wli> I can only read a page or two of it
04:29:42 <basti_> mh
04:29:47 <basti_> uh s___
04:30:11 <basti_> can I make it better in some way?
04:30:15 <wli> I don't know.
04:30:27 <basti_> theres a tool called ps2ps
04:30:35 <basti_> or something
04:30:52 <basti_> i think it reparses its input and can do funny stuff with it...
04:31:04 <wli> it's an optimizer
04:31:27 <basti_> I think it could help you
04:31:42 <wli> it's an optimizer, it won't fix it
04:32:36 <basti_> sad.
04:34:26 <wli> it doesn't have LR(k)
04:34:34 <wli> it only has LL(k) (which is kind of wimpy)
04:34:41 <basti_> uhm.
04:34:45 <basti_> really?
04:34:45 <basti_> ;)
04:34:49 <basti_> *looks again*
04:36:38 <basti_> uh sorry :(
04:37:20 <basti_> looks like my fault
04:38:37 <wli> basti: okay it's obvious
04:38:49 <wli> http://www.cs.rpi.edu/courses/spring01/modcomp1-2/handout13.LRparsing.PDF
04:41:20 <basti_> *reads*
04:41:36 <basti_> uhm.
04:41:37 <basti_> yes.
04:41:38 <basti_> :)
04:41:55 * shapr boings
04:42:29 * shapr splishes on kawfee 
04:42:31 <basti_> I wouldnt call LLk wimpy though.
04:42:31 <basti_> ;)
04:43:18 <wli> spiffy
04:43:22 <wli> it's got the state reduction bits
04:43:38 <basti_> lets say: "we know how to do it" ;)
04:46:20 <wli> well the reason to do it would be polymorphism on the input type
04:46:33 <basti_> uh.
04:46:38 <wli> so you could parse strings of anything in LR(k)
04:46:47 <wli> though in truth
04:47:03 <wli> alex is trivially generalizable to work on Eq a => a
04:47:19 <wli> so the value add would likely be LR(k)
04:47:25 <basti_> uh.
04:47:35 <wli> w0t?
04:47:44 * basti_ cant follow anymore.
04:47:44 <basti_> ;)
04:47:45 <shapr> n0th1n
04:47:56 * shapr boings furiously
04:48:42 <wli> I think it'd also be nice to allow things to be incremental
04:51:51 <shapr> hi cfork 
04:52:05 <cfork> hi
04:52:13 <shapr> learning Haskell?
04:52:39 <cfork> actually I did it at university a few semesters ago
04:52:42 <cfork> I really like it
04:53:23 <cfork> I'm one of those idiots who tries as many programming languages as they can in a futile effort to find the best one
04:53:38 <shapr> so am I
04:53:50 * basti_ is too
04:53:50 <cfork> I suspect Haskell is up there
04:53:56 <shapr> Yah, Haskell is my favorite so far.
04:54:00 <cfork> But there are other contenders :)
04:54:05 <shapr> and I've learned about a large number of languages.
04:54:11 <cfork> Scheme, Python
04:54:19 <shapr> I jumped from Python to Haskell
04:54:36 <shapr> Python started feeling constrictive in some ways.
04:54:44 <cfork> I haven't used OCaml/SML, and I have only had a brief look at Oz
04:54:44 <shapr> Even though Python is my first love :-)
04:54:47 * esap jumped from C++ to Haskell.
04:54:54 <cfork> shapr is a familiar name
04:54:58 <shapr> really?
04:55:01 <shapr> from where?
04:55:04 <cfork> I've seen it before :)
04:55:06 <cfork> on irc
04:55:06 <basti_> my first language was actually hp-41...
04:55:09 <cfork> I mean, on here
04:55:14 <wli> my first language was C
04:55:15 <shapr> cfork: which channels?
04:55:22 <cfork> you've been in #python or maybe #haskell ages ago?
04:55:26 <shapr> yah, both
04:55:27 <wli> I know a lot of languages.
04:55:50 <cfork> under different names I've resided in #python/#debian/#schem
04:55:51 <shapr> I got on efnet#python when there were eleven people, and freenode#python when there were eight people.
04:55:53 <cfork> #scheme
04:55:55 <wli> Haskell just looks supersexy to math geeks which is where I come in =)
04:56:05 <shapr> and freenode#haskell when there were zero people ;-)
04:56:13 <cfork> I desperately wish I did a Maths degree, rather than an IT degree
04:56:15 <cfork> I hate IT
04:56:19 <cfork> I love programming though
04:56:23 <shapr> me too
04:56:40 <shapr> programming is second only to women in my list of priorities :-)
04:56:53 <cfork> tehehehe
04:56:57 <Igloo> programming is second to women?!
04:57:00 * esap thinks shapr should re-prioritize :-)
04:57:03 <cfork> I suspect shapr is right
04:57:12 <cfork> women do dominate the male mind :)
04:57:14 <andersca> TeX is SeXy
04:57:16 <Igloo> cfork: Did you do a software engineering type degree rather than computer science?
04:57:21 <shapr> yes, I enjoy women more than programming... well, *woman*
04:57:29 <shapr> I'm planning to marry this one :-)
04:57:31 <cfork> Bachelor of Information Technology, majoring in Software Engineering
04:57:45 <cfork> at my local uni
04:57:47 <Smerdyakov> cfork, why did you do that?
04:57:56 <cfork> because it was offered locally?
04:58:03 <shapr> cfork: well, now's your chance to learn lots about Haskell.
04:58:03 <Smerdyakov> No computer science locally?
04:58:09 <cfork> nope
04:58:17 <cfork> halfway between sydney and brisbane
04:58:17 <Igloo> Thought so
04:58:18 <shapr> I had a computer class once.
04:58:21 <cfork> I regret my choice.
04:58:21 <Smerdyakov> You live in an interesting locality! :O
04:58:28 <cfork> :)
04:58:33 <cfork> Australia
04:58:48 <cfork> Is it possible that other courses are better than my crummy one?
04:58:49 <shapr> writing ROM BASIC on IBM XTs... we had to save our sources to 5.25 floppies.
04:58:59 <cfork> I mean, we did do a Haskell subject
04:59:01 <cfork> so its not all bad
04:59:21 <saz> cfork: which uni?
04:59:29 <shapr> I think there are advantages to being self-taught.
04:59:34 <cfork> Southern Cross University
04:59:55 <shapr> cfork: so, can you do IO in Haskell? do you understand Monads?
05:00:03 * shapr thinks cute warm fluffy monad things
05:00:12 <cfork> shapr: Monads .. I don't understand
05:00:13 * Smerdyakov punches anyone who "doesn't understand Monads."
05:00:18 * Smerdyakov punches cfork.
05:00:18 * shapr ows
05:00:26 <Smerdyakov> The only explanation is bad teaching, if it was covered.
05:00:29 * esap thinks _nobody_ understands monads.
05:00:30 <cfork> I haven't used Haskell outside of one subject
05:00:31 <shapr> Smerdyakov: teach me!
05:00:36 <cfork> they didn't cover monads
05:00:39 <wli> "Anyone who cannot cope with mathematics is not fully human. At best he
05:00:39 <wli> is a tolerable subhuman who has learned to wear shoes, bathe, and not make
05:00:39 <wli> messes in the house."
05:00:39 <wli>         -- R. A. Heinlein, "Time Enough for Love"
05:00:47 <cfork> can you explain it fairly simply here? :)
05:01:01 <cfork> Note: I tend towards Scheme, for its simplicity
05:01:05 <shapr> "Specialization is for insects -- Lazarus Long"
05:01:08 <Smerdyakov> It's an algebraic structure for combining atomic things into bigger things.
05:01:12 <cfork> are monads anything like call/cc on steroids?
05:01:18 <shapr> "TANSTAAFL -- Lazurus Long"
05:01:23 <wli> programming language monads aren't like category theoretical monads
05:01:30 <Smerdyakov> Order is important in the combination operator, and each thing has a type parameter.
05:01:32 <Smerdyakov> That's it!
05:01:34 * shapr can quote Heinlein
05:01:38 <esap> cfork: no, they are like command pattern on steroids.
05:01:46 <wli> I just found that one quote
05:01:50 <cfork> So monads are used to combine atomic things into bigger things
05:02:06 <shapr> Smerdyakov: your explanation of monads that you gave to seth_ helped me understand a bit more.
05:02:10 <cfork> Perhaps I should read some web pages on it :)
05:02:18 <cfork> incidently
05:02:29 <cfork> is SML/OCaml worth checking out?
05:02:35 <Smerdyakov> shapr, OK. I think I've written less than 20 lines of Haskell code in my life. You should be ashamed. :D
05:02:49 <shapr> Smerdyakov: nah, you're just good at explaining ;-)
05:02:50 <Smerdyakov> cfork, yes, especially if you want efficient compiled code.
05:03:01 <shapr> cfork: Smerdyakov is boss of the #sml channel, he's biased ;-)
05:03:14 <shapr> of course, I'm boss of #haskell, so I'm biased too....
05:03:28 <Smerdyakov> shapr is the only one who has this concept of "boss," I think.
05:03:32 <shapr> maybe "head organizer" is better 
05:03:32 <cfork> I don't like efficient code, so much as fun languages
05:03:58 <cfork> Lets take a vote: Say "Haskell" if I should devote my time to Haskell, or "ML" if to *ML
05:04:01 <wli> maybe I should make an aio binding for Haskell
05:04:02 <shapr> Smerdyakov: ok, what about head advertiser, main greeter, etc?
05:04:09 <wli> cfork: Haskell
05:04:12 <Smerdyakov> Haskell
05:04:14 <shapr> cfork: you're asking on the #haskell channel..
05:04:15 <shapr> Haskell
05:04:17 <shapr> Smerdyakov: eh?
05:04:18 <cfork> tehehhe
05:04:23 <wli> cfork: it's significantly more futuristic than *ML =)
05:04:31 <Smerdyakov> Go ask on #ocaml, cfork.
05:04:41 <shapr> excellent monad links: http://www.abercrombiegroup.co.uk/~noel/research/monads.html 
05:05:27 <shapr> http://www.cs.fit.edu/~satkin/monads.html
05:05:34 <shapr> those are my two favorite, in order
05:05:42 <cfork> one other thing
05:05:51 <cfork> has Haskell got a nice (doesnt have to be big) community?
05:05:57 <shapr> hej d-bugd, hur är det med dig?
05:06:01 <shapr> cfork: I think so
05:06:07 <wli> yep
05:06:17 <Darius> This channel has been described as nice(r) by many passers-by
05:06:23 <cfork> it seems
05:06:25 <cfork> nicer
05:06:27 <cfork> than #python or #lisp
05:06:31 <cfork> :)
05:06:36 <shapr> #python used to be really nice... years ago
05:06:39 <Darius> Augh, I think spilling water on keyboard is making my bottom row flaky.
05:06:39 <cfork> yep
05:06:42 <shapr> then the language got really popular
05:06:46 <cfork> yes
05:07:01 <shapr> of course, Darius made a famous quote recently...
05:07:17 <cfork> yes?
05:07:24 <Darius> The Quotes Page is famous?
05:07:30 <d-bugd> hej shapr, det är ok, hur är det själv?
05:07:34 <Darius> It was already on the internet.
05:07:44 <shapr>  after a long pointless discussion with a fanatically loyal C programmer on comp.lang.functional:
05:07:45 <shapr> "The best thing to get out of this, I guess, 
05:07:45 <shapr> is that Haskell IS becoming more mainstream and even morons have heard of it." -- DerekElkins
05:07:54 <shapr> d-bugd: bara bra
05:08:19 <andersca> hi d-bugd
05:08:25 <cfork> haha
05:08:25 <andersca> do you go to chalmers?
05:08:50 <shapr> I got a kick out of that quote.
05:09:03 <Darius> Personally, I don't think ALIEN is much of a C programmer, but I have no objective basis for that.
05:09:06 <shapr> heheh
05:09:23 <d-bugd> nix, i'm working these days, but i did some cs courses back in 96-97
05:09:40 <d-bugd> (at gu)
05:10:05 * dennisb also took cs courses at gu during that time
05:10:42 <d-bugd> "Datalogins Grunder" & "Beräkningbarhet" :)
05:10:53 <cfork> designed by a committe?
05:10:59 <cfork> nice :)
05:11:10 <Marvin--> d-bugd: both courses kinda suck
05:11:22 <d-bugd> why?
05:11:23 <dennisb> d-bugd: I don't remember exactly what year I took these, but maybe we was in the same class
05:11:33 <Marvin--> d-bugd: well, I took "Beräkningsmodeller" which is a redesigned "Beräkningsbarhet", and that one sure sucked
05:11:33 <shapr> Haskell was designed by committee, but changed by requests and ideas
05:11:53 <Marvin--> d-bugd: at least when I took them
05:12:00 <wli> The only thing I really miss is higher-order modules.
05:12:01 <Smerdyakov> How wonderful! Changed by ideas!
05:12:09 <cfork> Is there a particular implementation that is "the" implementation?
05:12:25 <dennisb> Marvin--: It was good when it was called "Beräkningsbarhet"
05:12:26 <wli> basically ghc =)
05:12:42 <Marvin--> dennisb: oh, okay
05:12:58 <d-bugd> Marvin--: I think those two were excellent mostly, a lot of student complained, thought the books were too hard, that the teacher was arrogant(Åke Wikström), but I liked him and the litterature
05:13:39 <dennisb> Marvin--: I don't know what happend after that, but I enjoyed it at least. Henrik Person gave the course back then and he is a really good teacher (not at chalmers any more though)
05:13:56 <Darius> Smerdyakov: much better than changed by shiny flashy things
05:14:01 <Marvin--> d-bugd: I don't have any good experience of Åke myself, and when I took datalogins grunder it was java based and the literature really really sucked
05:14:14 <d-bugd> Henrik did the Ber. course, yes
05:14:25 <Marvin--> dennisb: well, Bengt Nordström isn't a wonderful teacher, exactly
05:15:01 <d-bugd> Marvin--: Java? Bah, we used Modula-2 :)
05:15:01 <d-bugd> gives you hair on the chest ;)
05:15:20 <shapr> hey wli, here's all the HEmacs resources I know, http://www.haskell.org/hawiki/HaskellEditor feel free to add more if you know of any.
05:16:06 <wli> shapr: my deal is that I'm mostly interested in non-GUI and efficient io
05:16:17 <shapr> anyone else know of code or papers that might be used in a Haskell Emacs clone?
05:16:22 <shapr> ah, ok
05:16:25 <wli> (cpu isn't a big deal apart from avoiding moronic algorithms)
05:16:45 <shapr> Yes, I've often seen the moron combinator used on #java
05:16:50 <cfork> ok, I'll do Haskell, I don't speak much French at all, for OCaml :)
05:17:27 <shapr> welcome to the world of purely function programming!
05:17:32 <shapr> er "functional"
05:17:42 <wli> shapr: most of what I've been trying to do is figuring out how to combine a block buffering back end with an efficiently indexed line buffering layer
05:18:36 <wli> shapr: which oddly appears to share at least some of its problems with my MUA notions
05:19:05 <shapr> is there some way to combine those two flavors of buffering?
05:19:18 <cfork> does Haskell do tail recursion optimisation?
05:19:22 <shapr> yup
05:19:38 <cfork> excellent :) I'm a Schemer
05:19:42 <shapr> actually, I think it's implementation specific, but most implementations do it.
05:19:55 <shapr> I don't remember if it's part of the spec
05:20:23 <wli> shapr: which are basically that the OS stuff I want to call to do it with is doesn't have a Haskell interface and/or doesn't mix well with Haskell, and that lazy rearrangement of file contents is very hairy
05:20:30 <d-bugd> wouldn't it be kind of odd to have lazy evaluation and still don't do tail-rec. opts?
05:21:18 <wli> shapr: i.e. shifting contents up or down by some offset when you decide to delete a line from a text file or an email message from an mbox
05:22:03 <wli> shapr: I want it to be driven by basically the need to reclaim memory, timeouts, and up-to-dateness of file contents on exit
05:22:26 <wli> e.e.
05:22:46 <wli> e.g. if you have stale disk contents that have sat around for so long you want to do writeback on them
05:23:21 <wli> the kernel side is also a bit hairy
05:23:36 <wli> it looks like there's several bits of missing functionality
05:23:45 <shapr> which ones?
05:23:49 <wli> (1) there's an API for efficiently performing complex memory mappings
05:23:56 <wli> (2) this API is not async
05:24:46 <wli> (3) terminal io is missing the functionality needed to be treated uniformly with disk io
05:25:37 <wli> (4) the kernel side forbids complex mappings to span files which creates a space management problem
05:26:37 <wli> (4) is basically because "ideally" you'd want to use any portion of the process' space to cache any block of any file you're looking at
05:26:54 <shapr> yah, I see that.
05:27:33 <shapr> you could cheese past it with the DOS doublespace trick, make a single huge file that works like separate files
05:27:41 <wli> the restriction there means you have to know which ranges belong to which files and do less efficient mappings on the things.
05:28:00 <wli> well that doesn't work; reorganizing the files is infeasible b/c a format must be respected.
05:28:36 <shapr> hm, I see
05:29:01 <wli> you also go from the case of 1 of the files you're looking at can be mapped in the area at a time to 0 of them (b/c you're using a file not otherwise of interest apart from being the backing store for a mapping)
05:29:12 <shapr> right
05:29:13 <shapr> that would suck
05:29:25 <wli> shapr: basically you have a set of "spools"
05:29:32 <wli> shapr: each is an mbox and an index file
05:29:39 <shapr> hook up a userspace filesystem driver that's smarter?
05:30:33 <wli> shapr: the index file is bag of on-disk data structures describing message boundaries and that does thread indexing, and is randomly accessed (complex mapping #1)
05:31:13 <shapr> I would like to have that available in Haskell for a variety of reasons
05:31:19 <wli> shapr: the mbox is jumbled; messages all come in out-of-order and are "reordered" by doing data structure traversal etc. in the index file and then essentially random access to the messages in the threads
05:32:07 <shapr> does maildir format have a similar index file?
05:32:09 * shapr looks
05:32:13 <wli> shapr: note Haskell has no interface for mmap(); this is basically a twisted form of mmap() that allows scary jumblings of the order of the pages mixedup in the files
05:32:14 <wli> no
05:32:17 <wli> maildir is retarded
05:32:26 <shapr> that's strange
05:32:29 <shapr> you'd think it would
05:32:31 <wli> maildir creates buttloads of tiny files and uses the fs inappropriately
05:33:22 <wli> this is actually worse for my purposes than mbox
05:33:32 <shapr> I was thinking of a similar structure for an on-disk database in Haskell
05:33:35 <wli> because the technique consumes pinned memory in the operating system
05:33:41 <wli> don't do it
05:33:45 <shapr> since I can't figure out how to only load parts of a file into memory
05:33:46 <wli> it's wrong
05:34:01 <wli> shapr: well, hSeek etc.
05:34:49 <shapr> that would work, though it would also feel cheesy
05:35:31 <shapr> why does the kernel forbid complex memory mappings to span files?
05:35:36 <wli> shapr: commercial databases do this but with a special interface that implies zero copying being done within the operating system (basically the OS refrains from cacheing and it figures it out on its own)
05:35:43 <shapr> ah
05:36:03 <wli> shapr: Normal Haskell IO could hook into that 
05:37:32 <wli> shapr: the region reserved to do complex mappings in is associated with a data structure that is in turn associated with a file, and so you get a file <-> complex mapping region relation that's 1:1 by coincidence (but also a necessity for various algorithms and due to some data structure arrangements preventing further generalization)
05:38:16 <wli> i.e. it's not just pointing at the file, the file also has it on a list and it's only got 1 set of links (not an arbitrary number)
05:38:24 <shapr> oh
05:38:56 <shapr> would some of the LVM code get around that?
05:39:00 <wli> no
05:39:06 <shapr> does the fs have some way to 'merge' files?
05:39:23 <shapr> temporary file merging might cheese around that
05:39:32 <wli> the LVM code works at layers beneath filesystems or memory management, it fakes a representation of a disk device
05:40:40 <wli> it basically just generalizes the functionality used to fake one disk device being many via partitions by making the disk : fake disk relation M:N instead of 1:N
05:41:20 <shapr> hrm
05:41:25 <shapr> so how could it be done?
05:41:41 <wli> might not be worth trying
05:41:46 <wli> might be best to ignore the issue
05:42:19 <wli> but anyway
05:42:25 <wli> the thing I want to do is in the operating system
05:42:45 <wli> there is an API for submitting io requests and not blocking on them
05:43:04 <wli> (and they are shipped off to wherever and are in progress while you remain running)
05:43:16 <wli> this API has a number of "commands"
05:44:28 <wli> the commands don't include establishing a complex mapping that's fully paged into memory (it has two options: (1) just make the mapping and fault things in as needed and (2) read things in right away in order to establish the mapping to something definitely resident)
05:44:54 <wli> the option (1) implies blocking on io when you access things, which is bad
05:45:12 <wli> the option (2) implies blocking when you establish the mapping which is also bad
05:45:53 <wli> getting the new io command means you can send a message to the OS "establish this mapping" and keep running, then the OS lets you know when it's done by some method or other
05:46:20 <wli> it could either interrupt you with a signal or alter some memory behind your back while you're not looking
05:47:56 <wli> (the memory it alters being a mailbox it's supposed to deliver a message into)
05:48:32 <wli> so basically
05:48:51 <wli> the question is how on earth do you make Haskell understand what a memory mapped file is
05:49:09 <shapr> I don't know
05:49:12 <wli> and then how do you teach it what a complex mapping is
05:49:26 <wli> even supposing you can do it in the RTS
05:49:36 <wli> how do you refer to raw memory?
05:50:07 <wli> maybe since it is a very low-level efficiency hack it shouldn't be done in Haskell at all
05:50:13 <wli> hell
05:50:31 <wli> it even requires extensions on top of a dev version of an OS
05:51:01 <wli> that's just to stay async
05:51:04 <shapr> what about an array?
05:51:28 <shapr> there are unboxed arrays in Haskell, I think that's the closest thing to raw memory
05:51:36 <wli> no idea
05:51:43 <andersca> you can also use peek and poke :)
05:52:07 <wli> peek and poke? where are they in the GHC docs?
05:52:08 <shapr> heh
05:52:15 <shapr> that's from the C=64 
05:52:22 <shapr> actually
05:52:41 <shapr> Peek and Poke are in the FFI I think
05:53:11 <elmex> is there somewhere documentation, which explains StateT and all that State and Control.Monad stuff?
05:53:34 <shapr> do you understand monads?
05:53:37 <wli> Storable
05:53:50 <elmex> shapr: a bit
05:54:00 <elmex> (err.. not really)
05:54:52 <shapr> http://www.abercrombiegroup.co.uk/~noel/research/monads.html http://www.cs.fit.edu/~satkin/monads.html
05:55:15 <wli> I can probably work with peek, poke, and basic C stubs
05:55:30 <wli> the OS hook is trivial
05:55:56 <wli> Although I'm moderately certain a number of people will scream bloody murder
05:56:08 <wli> A number of people hate the complex mapping API
05:56:17 <wli> A number of people also hate the async io stuff
05:56:18 * esap just used a type "b w m -> a (w (b w m)) (m (b w m))", anyone what it's type for? :-)
05:56:20 <elmex> shapr: ah, yes, that url. ok, thanks
05:56:25 <wli> the intersection is moderate
05:56:33 <wli> I'm likely to get the union of both
05:56:57 <shapr> esap: Y combinator? :-)
05:57:09 <esap> shapr: close, but not quite.
05:57:32 <shapr> looks like Y with some sort of wrapper
05:57:43 <shapr> and a left/right filter thingy
05:58:31 <wli> hmm
05:58:46 <esap> shapr: It's a type of the method application in what I'd like to be an OO library for Haskell.
05:59:08 <wli> there's an async fsync() which should suffice for kicking off writeback
06:04:09 <wli> at some point I should figure out how to do jack with the FFI
06:07:39 <wli> something makes me recoil in terror at the thought of implementing an on-disk data structure this way
06:07:57 <wli> (esp. a B-tree)
06:08:32 <wli> or, as it were, a K-D-B tree
06:09:02 <wli> actually one of the higher-dimensional data structures sounds appropriate since queries could proceed on multiple keys simultaneously
06:10:39 <wli> possibly even variadic
06:10:51 <wli> external string table sounds appropriate also
06:14:08 <wli> hell at the rate I'm going I might as well just start writing a database back-end and after I've gotten somewhere see what's missing and ignore doing the rest of everything I don't need.
06:14:23 <wli> Either that or just punt the whole damn thing off to postgresql or something
06:17:20 <cfork> really I'm amazed that more people haven't taken up Haskell
06:17:24 <cfork> It's fun
06:18:38 <shapr> me too
06:20:54 <Darius> Part of it may be that many programmers haven't even heard of it.  I certainly hadn't until immediately before I started using it.
06:21:06 <cfork> After I did my Haskell subject, and went on to use Scheme
06:21:09 <wli> hmm
06:21:20 <wli> FFI docs appear to be in scarce supply
06:21:22 <cfork> I found myself defining take, takeWhile, etc
06:21:25 <wli> or I'm looking in the wrong place
06:21:31 <Darius> There's a standard.
06:21:34 <Darius> wli
06:22:04 <Darius> cfork: get familiar with the prelude, there are tons of useful things in it
06:22:51 <wli> I just found the standard.
06:22:59 <wli> it looks almost identical to the ghc doc
06:23:17 <wli> either I'm being dense or it's not obvious how to use it; I may have to start fishing around ghc for examples
06:23:39 <wli> nm
06:23:50 <wli> foreign export ccall "foo" :: ...
06:24:05 <wli> Should be able to wing lots of stuff there.
06:24:24 <wli> sysv shm, hugetlb, aio, mmap(), remap_file_pages(), etc.
06:25:21 <cfork> is ffi easy?
06:25:21 <wli> futexes and epoll too
06:25:30 <wli> cfork: looks like it
06:25:35 <Darius> it's pretty straightforward
06:25:55 <cfork> so it allows you to call .so librarys?
06:26:04 <cfork> or dlls, or whatever?
06:26:05 <wli> well
06:26:05 <Darius> Plus there are a variety of tools to simplify repetitive tasks
06:26:31 <wli> dynamic linking is still some kind of bizarre low-level issue with assembly mangling
06:27:44 <cfork> er, ffi has more purposes than that?
06:28:16 <Darius> FFI is how to talk one way or the other to a program written in another language
06:28:25 <Darius> How it's linked matters less.
06:28:54 <cfork> Lets say I have a C function I want to be able to call
06:29:02 <cfork> is it relatively simple to do so?
06:29:34 <Darius> foreign import ccall "putchar" :: CChar -> IO ()
06:29:42 <Darius> then just use it.
06:29:56 <cfork> ok
06:56:53 * shapr boinks
07:09:28 <cfork> Hmm quite a bit of "complex" stuff we didn't cover
07:09:32 <cfork> in my course
07:10:11 <shapr> like what?
07:12:05 <shapr> hi Escalade 
07:12:08 <cfork> monads
07:12:22 <CowGirl> hey
07:12:29 <shapr> cfork: monads are where Haskell goes from nifty to immensely cool.
07:12:36 <Lilith> has anyone looked at JNI/Haskell?
07:12:49 <shapr> Lilith: Ashley Yakeley's thingy?
07:13:01 <cfork> I'll learn them later :)
07:13:06 <cfork> Still re-learning
07:13:12 <shapr> yah, it's good to start with the basics
07:13:43 <Lilith> shapr: nope. Lambada
07:14:11 <shapr> oh, I've heard of it, but nothing more.
07:14:18 <shapr> do you have an url for it?
07:14:22 <Lilith> i don't know greatly about FFI, but I was wondering how it compares
07:14:30 <Lilith> had
07:14:37 <cfork> my head still doesn't fit around generational recursion :
07:14:44 <shapr> cfork: huh? like what?
07:14:46 <cfork> :(
07:14:53 <Lilith> shapr: "Lambada, Haskell as a better Java" by Meijer & Finne
07:15:00 <cfork> fib             = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
07:15:04 <shapr> ah
07:15:12 <shapr> fib = 1 : 1 : zipWith (+) fib (tail fib)
07:15:19 <shapr> I find that version easier to understand.
07:15:26 <cfork> yes
07:15:34 <jak> lol
07:15:49 <jak> it's funny how Haskell expresses things like fib and fact really well
07:16:02 <jak> much better than any other language I know
07:16:15 <cfork> Like when I first learnt Scheme, they had a really tiny algorithm for fib, and a big one
07:16:19 <jak> but other things take some getting used to...
07:16:28 <shapr> yah, recursion is the standard way of doing things in Haskell.
07:16:31 <cfork> I understood the iterative big one instantly
07:16:32 <cfork> yeah :)
07:16:58 <shapr> the first step down the road to lazy lists is "ones = 1 : ones"
07:17:00 <cfork> I can handle recursion, until it gets generative- that is more than 1 recursion
07:17:42 <shapr> I think fib is singly recursive
07:17:49 <shapr> it's just lazily calculated
07:18:04 <shapr> admittedly, it uses each 'index' twice
07:19:14 <shapr> I still don't perfectly understand lazy lists
07:20:05 <wli> did you see my recurrence function?
07:20:09 <wli> I posted it to haskell-cafe
07:20:18 <cfork> I suspect if I just sat there doing more complex recursion exercises, I would understand it better
07:20:36 <shapr> wli: I saw it, but I didn't understand it :-0
07:20:52 <shapr> Lilith: does lambada work on Linux?
07:21:11 <wli> what's lambada?
07:21:11 <Lilith> shapr: haven't tried it yet. i just saw the paper this mornign
07:21:31 <shapr> wli: haskell calling Java via JNI
07:21:37 <wli> oh
07:21:41 <wli> totally uninterested then
07:21:55 <wli> Subject: n-term recurrences
07:21:56 <shapr> I'd be interested in GHC generating Java bytecode or Java source
07:22:15 <Lilith> shapr: i've got the cvs version of that
07:22:22 <Lilith> except i cant release it
07:22:25 <Lilith> it's broken :-)
07:23:21 <wli> shapr: fibs would be recurrence [0.1,1] [1,1]
07:23:24 <wli> er
07:23:27 <wli> shapr: fibs would be recurrence [0,1,1] [1,1]
07:23:49 <wli> Util> take 10 $ recurrence [0,1,1] [1,1]
07:23:50 <wli> [1,1,2,3,5,8,13,21,34,55]
07:24:17 <shapr> ohhh
07:24:27 <shapr> Lilith: what's broken about it?
07:24:49 <wli> [0,1,1] means f(n+1) = 0 + 1*f(n) + 1*f(n-1)
07:25:04 <shapr> wli: I understand it now, that's nifty
07:25:08 <wli> [0,1] means f(0) = 0, f(1) = 1
07:25:17 <wli> it can be used for more interesting stuff
07:25:23 <wli> Ápery numbers would be...
07:25:26 <shapr> never heard of Apery numbers
07:26:31 <wli> nm I need to handle coefficients that are polynomials in n
07:26:37 <wli> er
07:26:41 * shapr wonders what that means...
07:26:41 <wli> perhaps even rational functions
07:27:05 <shapr> esap: seen http://research.microsoft.com/Users/simonpj/Papers/oo-haskell/index.htm ?
07:27:41 <o3> ah, that paper rocks
07:28:42 <o3> rightio
07:28:48 <o3> time to nap
07:28:49 <o3> night!
07:28:52 <esap> shapr: hmm.. at least I don't remember seeing that. Thanks for the link.
07:29:24 <shapr> g'night o3 
07:32:33 <cfork> hmm whats the "default" for pattern matching again?
07:32:38 <cfork> foo x = 1
07:32:40 <cfork> er
07:32:48 <cfork> foo x | x == 1 = [blah]
07:32:53 <cfork> foo x | else   = [blah]
07:33:08 <cfork> rather than that
07:33:08 <cfork> what is it?
07:33:14 <esap> cfork: otherwise  [which is defined in std prelude as otherwise = True]
07:33:24 <cfork> ah, thanks :) I see
07:41:31 * shapr reads bureaucratic documents
07:45:55 <esap> shapr: That oo-haskell paper was nice, although I would have added discussion about layering and how to represent it properly.
07:46:08 <shapr> you could ask 'me
07:46:11 <shapr> them
07:47:08 <esap> well, I think I'll first try to solve the same problem without language extensions.
07:47:16 <shapr> ok
07:47:30 <jak> which paper is this
07:47:35 <jak> I'd like to read it :)
07:47:40 <esap> It might be I'm missing something (that it would not be possible without extension)
07:47:57 <shapr> jak: the oo-haskell url I pasted above.
07:48:05 <jak> ahh
07:48:14 <jak> good old simon pj
07:48:24 <shapr> the man with the plan
07:49:09 <esap> My current thinking to build OO with Haskell is to use a message-passing based approach and a generalization of arrows.
07:49:38 <shapr> scary thought
07:49:43 <shapr> a generalization of arrows :-)
07:50:25 <jak> heh
07:50:36 <jak> arrows are already a generalization of monads aren't they?
07:50:39 <shapr> yup
07:51:23 <esap> Actually, when you generalize the arrows, it's useful to then also generalize monads to allow for higher-order operations.
07:52:55 <esap> here's a snippet of what I'm thinking:
07:54:03 <esap> class StrictArrow a where { (<<<<) :: a c d -> a b c -> a b d ; unitS :: a b b } class (StrictArrow a) => StrictMonad a req cmd where { buildS :: a (req input) (req output) -> a (req input) (cmd output) ; bindS :: a (req input) (cmd output) -> a (cmd input) (cmd output) }
07:59:33 * shapr swears at EU Project people who consider MS Excel a tool for designing visual database schemas
08:00:05 <esap> shapr: what is a "visual database schema"? That sounds like a contradiction in terms.
08:00:20 <shapr> for extra evil, I'll make you a screenshot
08:01:28 <shapr> http://kungens.kemi.fi/~shae/exceldbschema.png
08:01:34 <shapr> isn't that useful?
08:02:50 <esap> oh, now excel is an UML tool? I thought powerpoint was the UML tool of choice.
08:03:19 <shapr> I also find it difficult to believe.
08:03:44 <shapr> I'd much rather use SQL to design a database (shocking, eh?)
08:03:58 <shapr> I'd be even happier if there were text in those boxes.
08:04:09 <shapr> looks like gnumeric isn't 100% ms excel compatible.
08:05:02 <esap> shapr: but it says "possible database schema", maybe it's just a template that you can fill the texts? :-)
08:05:10 <shapr> heh
08:06:22 <esap> shapr: what is that border on top with the 'dpkg -s gnumeric'-texts? Does gnumeric now have that kind of window border?
08:06:39 * Lilith blinks
08:06:47 <Lilith> lots of blank boxes
08:07:19 <shapr> esap: nah, that's my semi-window manager, ion
08:07:22 <wli> hmm
08:07:28 <esap> shapr: ion? hmm. never heard of that.
08:07:44 <wli> if S is denumerable then S[x] is denumerable
08:07:51 <shapr> ion allows me to keep away from using the mouse 99% of the time.
08:08:18 <wli> yet what would be a surjective function from N -> S[x] given f surjective from N -> S?
08:08:39 <shapr> esap: it also comes from .fi along with many of my favorite softwarez
08:09:02 <wli> ah
08:09:07 <wli> presumably one diagonalizes
08:09:15 <shapr> linux, ssh, irc, ion, multi-layer neural networks... all originally from .fi
08:09:43 <shapr> Lilith: the moral of that screenshot: friends don't let friends use microsoft products.
08:10:11 <shapr> I have been tempted to buy microsoft products for my enemies though.
08:10:46 <opet> "take this copy of ms project! ahahaaha!"
08:10:57 <jak> lol
08:11:10 <shapr> munitions like bombs only screw you over once....
08:11:18 <shapr> with ms products, you could lead a long empty life...
08:11:23 <esap> shapr: hmm.. I guess I need to try that WM, might remove some of my current window overlap problems :-)
08:11:23 <shapr> ok, ok, I'm overdoing it :-)
08:11:34 <Lilith> yes. ion rocks :-)
08:11:40 <shapr> yes, ion rocks
08:11:44 * Lilith is an ion weenie
08:11:46 <shapr> me too
08:11:53 <Lilith> it's great for coding
08:12:02 <shapr> I have a thoroughly customized ion config file
08:12:04 <Lilith> i switch to twm when i need to watch dvds
08:12:08 <Lilith> oh?
08:12:28 <esap> shapr: does it need much configuring to work well?
08:12:28 <Lilith> i just need as much of a black background as possible and no fancy fluff
08:12:29 <shapr> yah, the standard keybindings clashed with emacs
08:12:37 <shapr> esap: nah, it's easy to start with
08:12:42 <shapr> and fun to customize
08:12:44 <Lilith> shapr: oh? hmm. not that i've noticed
08:12:58 <shapr> Lilith: could be just the standard debian keybindings
08:12:59 <Lilith> i use most of the default settings and it's ok
08:13:06 <Lilith> shapr: could be
08:13:16 <shapr> I moved all the ion specific stuff under M-i
08:14:12 <Lilith> i wonder when the full screen mode will be available on stable ion
08:14:30 <Lilith> the version i'm using doesn't support full screen mode
08:15:20 <Lilith> esap: you could also try ratpoison/pwm
08:15:48 <esap> lilith: haven't heard of those either :-) Hmm.. I must be out of touch of current software.
08:16:20 <Lilith> esap: i just have friends who don't use KDE/Gnome :-)
08:18:39 <wli> I need permutations
08:19:42 <shapr> Lilith: I can still play tribes2 and other games in ion, fullscreen works fine here
08:19:46 <wli> ListUtils
08:20:03 <shapr> counterstrike inside winex does not work with ion
08:20:08 <shapr> something about the keyboard handler
08:20:14 <Lilith> oh
08:20:15 <Lilith> hmm
08:20:29 <Lilith> xine doesn't work full screen in ion
08:20:45 <shapr> I haven't tried that, I don't watch DVDs on my computer.
08:21:37 <Lilith> do you have problems with screen resizing?
08:21:46 <shapr> ?
08:21:51 <shapr> like what?
08:22:08 <Lilith> i need to run resize everytime i resize my xterms
08:22:26 <Lilith> otherwise programs like less and vi won't display properly
08:22:47 <shapr> er, I never resize anything...
08:22:59 <shapr> I have two workspaces, one with a column on the right for emacs speedbar
08:23:13 <Lilith> d'oh. i tend to split my workspace 
08:23:13 <shapr> and the other for fullscreen everything
08:23:24 <Lilith> emacs speedbar?
08:23:30 <shapr> yah
08:23:39 <shapr> http://kungens.kemi.fi/~shae/erc.png
08:24:30 <shapr> speedbar is sort of like the windows explorer tree control, but much spiffier
08:25:03 <wli> hmmm
08:25:15 <wli> is there a way to be guaranteed to get all elements given Enum?
08:25:28 <shapr> interesting question
08:25:40 <shapr> you could require Bounded
08:25:46 <wli> doesn't look like it
08:25:51 <Lilith> oh
08:26:13 <Lilith> shapr: that's cool. does it come with vanilla emacs or do i have to download some special package?
08:26:20 <shapr> Lilith: it's standard
08:26:25 <wli> I'm trying to use Cantor diagonalization -style crud to make polynomials over a ring instances of Enum
08:26:50 <shapr> Lilith: I can point you to a bunch of emacs nifty tricks :-)
08:27:04 <Lilith> shapr: cool! 
08:27:16 <Lilith> incl. stuff on how to get the speedbar
08:27:34 <shapr> M-x speedbar
08:28:12 <wli> well
08:28:37 <wli> I can use the N -> Z surjection and do map toEnum on that
08:28:57 <shapr> Lilith: start here: http://emacswiki.org/cgi-bin/wiki.pl?EmacsNiftyTricks
08:29:46 <Lilith> shapr: ah. thanks :-)
08:31:08 <wli> better yet
08:31:24 <wli> I'll do it over naturals and then use that projection plus toEnum 
08:32:00 <shapr> wli: wouldn't maxBound give you everything in an Enum?
08:32:05 <wli> no
08:32:11 <wli> it's not necessarily finite
08:32:14 <wli> Integer is Enum
08:32:26 <shapr> oh
08:33:20 <wli> I need all, then all pairs, then all triples, etc....
08:35:05 <wli> allFiniteLists :: (Num a, Enum a) => [[a]]
08:35:05 <wli> allFiniteLists = map (:[]) allEnum : undefined
08:35:05 <wli>         where
08:35:05 <wli>                 allEnum = toEnum 0 : map (toEnum . z) [2..]
08:35:05 <wli>                 z n = if even n then n' else -n' where n' = n `div` 2
08:35:52 <wli> now what to use for undefined?
08:40:07 <esap> this ion has strange defaults. "run-mailcap"? :-)
08:40:32 * shapr shrugs
08:42:03 <wli> allFiniteLists :: (Num a, Enum a) => [[[a]]]
08:42:03 <wli> allFiniteLists = map (:[]) allEnum : [map (x:) xs | x <- allEnum, xs <- tail all
08:42:03 <wli> FiniteLists]
08:42:03 <wli>         where
08:42:03 <wli>                 allEnum = toEnum 0 : map (toEnum . z) [2..]
08:42:04 <wli>                 z n = if even n then n' else -n' where n' = n `div` 2
08:42:15 <wli> so far so good
08:52:56 <wli> I'm golden
08:59:24 <shapr> y0 Marvin-- 
09:00:02 <Marvin--> yo
09:00:09 <shapr> wassup?
09:00:17 <Marvin--> nothing much
09:00:28 <Marvin--> having a hard time focusing on the project
09:00:35 <shapr> sounds like you're making great progress
09:00:41 <shapr> can I play with it? :-)
09:01:41 <elmex> does anyone know some simple examples for using the State and StateT stuff?
09:02:12 * Riastradh points at the 'What the Hell are Monads?' page, which you can find on the 'Books and Tutorials' section of haskell.org.
09:03:02 <shapr> elmex: lambdabot uses StateT 
09:03:55 <Marvin--> shapr: uh, yeah, I guess...
09:04:18 <elmex> shapr: hmm
09:04:33 <shapr> Marvin--: yes yes!
09:04:41 <elmex> shapr: i will take some book and hit my head agains it
09:05:11 <shapr> elmex: that didn't help me much. Instead I tried to write code using State and StateT, and then days later, I understood.
09:05:32 <Marvin--> shapr: do you have any theorem provers installed? ;)
09:05:54 <shapr> no, but if you tell me which ones to install, I'll do it.
09:06:12 <shapr> I'm seriously thinking of buying a "coding hat"
09:06:34 <shapr> so then people who walk past will know they shouldn't even talk to me.
09:06:51 <Marvin--> shapr: I could put an eprover binary in the tarball, we're both on linux-i386 right?
09:06:56 <shapr> yah!
09:06:59 <shapr> debian/unstable
09:07:05 * shapr bounces happily
09:07:08 <elmex> shapr: same is waht i want to try ;) i need some kind of state to program my programs ;)
09:07:10 <Marvin--> right
09:07:44 <shapr> elmex: I'd suggest looking at the two urls I pasted above, first the Noel Winstanley and then the Steve Atkin
09:08:02 <shapr> elmex: and try to modify Steve Atkins interpreters to do something extra
09:08:09 <Marvin--> shapr: http://193.11.232.159:8080/foo.tar.gz  <- that's probably all the files you need, if not, bonk me
09:08:20 * shapr bounces cheerfully
09:09:28 <Marvin--> most of the code is pretty horrible
09:09:55 <shapr> your system date is off, I think
09:09:58 <shapr> or mine is..
09:10:06 <shapr> 794s in the future?
09:10:30 <elmex> shapr: i looked at those monad tutorials... but i still don't have a very clear image of that all
09:10:41 <Marvin--> shapr: I think mine's pretty accurate, I use ntp
09:11:11 <shapr> elmex: I had to use what I read to effectively integrate it, I would suggest you try the same.
09:11:11 <elmex> shapr: do you mean the examples of atkin?
09:11:19 <shapr> elmex: yes, those examples
09:11:24 <Marvin--> 794s is quite a lot
09:11:31 <elmex> shapr: ok, i will try that. thanks
09:12:15 <shapr> elmex: heuristic: play with it till it breaks, fix it, understand why/how it broke and why/how that fixed it.
09:12:26 <Igloo> Does anyoen happen to know of a good paper on efficiently implementing regexps with backreferences?
09:12:40 <elmex> shapr: *g* yea, exactly my way to learn things. thanks
09:12:49 <shapr> Marvin--: I run ./build right?
09:12:53 <Marvin--> shapr: yah
09:12:57 <shapr> ok
09:13:11 <shapr> Marvin--: you're using 5.04, yah?
09:13:35 <Marvin--> yes
09:13:50 <shapr> I'll see if I can get it working with 5.05
09:13:55 <Marvin--> Michael's package, I haven't bothered building myself
09:15:29 <shapr> it can't find bracket in Main2.hs
09:15:43 <shapr> @type bracket
09:16:12 <Igloo> Does it import IO?
09:16:18 <Marvin--> huh, I thought it was in System.IO
09:16:29 <shapr> guess not...
09:16:41 <shapr> I wonder if that's changed in 5.05
09:16:46 <Marvin--> apparently
09:17:09 <shapr> urf
09:17:25 <shapr> yay
09:17:40 <shapr> I had to "import Control.Exception hiding ( finally )"
09:17:55 <shapr> Marvin--: what do I do with a.out ?
09:18:00 <Marvin--> oh, there is a finally?
09:18:07 <Marvin--> shapr: ./a.out --help
09:18:17 <shapr> oh, cool
09:18:45 <Marvin--> gotta love getopt
09:19:06 <shapr> ok, I have outfiles...
09:19:11 <Marvin--> grmbl, there's no finally in my version
09:19:11 <shapr> I feed them into eprover, yes?
09:19:31 <Marvin--> into eprover --tptp-format
09:19:40 <Marvin--> and then you wait for a minute
09:19:46 <Marvin--> and then you don't understand the proof :-)
09:19:59 <shapr> what does the proof mean?
09:20:10 <Marvin--> if it finds a proof, it means there's a contradiction in the program
09:20:20 <shapr> Q2 is nearly instantly proved
09:20:26 <Marvin--> yes, Q2 is a small example
09:20:32 <Marvin--> Unify takes 30-40 seconds on my computer
09:20:33 <shapr> Unify is taking a bit longer.
09:20:41 <shapr> can I run this on the lambdabot sources?
09:20:44 <Marvin--> no :)
09:20:52 <shapr> oh, it found a proof for Unify
09:21:07 <Marvin--> first of all, it only works on the Helium subset of Haskell
09:21:09 <shapr> ok
09:21:17 <Marvin--> second, higher order functions are currently not taken care of
09:21:23 <shapr> ok
09:21:27 <Marvin--> third, moduels aren't taken care of either
09:21:30 <Marvin--> modules
09:21:33 <shapr> ok
09:21:47 <shapr> I can write a tiny Haskell program to stuff all the code into a single source file.
09:21:59 <Marvin--> yeah, but "no modules" also means "no prelude"
09:22:04 <Marvin--> monadic code isn't handled either
09:22:04 <shapr> that's okay with me.
09:22:12 <shapr> what's missing in Helium?
09:22:17 <Marvin--> mainly overloading
09:22:25 <shapr> oh, so I have to do without typeclasses?
09:22:27 <Marvin--> yes
09:22:31 <shapr> anything else?
09:22:42 <Marvin--> the module system is very straightforward, there's only one name space
09:22:45 <Marvin--> other than that I don't remember
09:23:13 <shapr> aww, HsNegApp not supported
09:23:14 <wli> GRRR
09:23:20 <wli> my division function isn't working
09:23:22 <shapr> Fail: HsNegApp (HsLit (HsFrac (2 % 1))) -- Not supported! :(
09:23:24 <Marvin--> shapr: no, 'cause I don't really have any ints yet :-)
09:23:34 <Marvin--> shapr: no prelude also means no preludeprim ;)
09:27:26 <Marvin--> so anyway, the --help looks pretty impressive, doesn't it? ;)
09:27:40 * Lilith grins
09:28:00 <Lilith> woah. ircing in emacs is a bit weird
09:33:03 <shapr> heh
09:33:26 <shapr> Marvin--: it looks *very* cool.
09:34:16 <shapr> när kan jag har mer? Jag vil ha Int ocksa
09:34:46 <Marvin--> I don't know... I'm meeting with Koen tomorrow to decide where to go next
09:36:27 <shapr> ska du skriva dit på journal?
09:36:47 <d-bug> är det svensktimmen? :)
09:36:54 <shapr> even if you don't pursue this, you should write up the prototype, I think this is a very cool piece of software.
09:37:09 <shapr> d-bug: alltid!
09:37:18 <wli>                 | otherwise = (q + q', r)
09:37:18 <wli>                         where
09:37:18 <wli>                                 q = Poly [(last xs) `div` (last ys)]
09:37:18 <wli>                                         * (Poly [0,1])^(degree n - degree d)
09:37:18 <wli>                                 r' = n - q*d
09:37:19 <wli>                                 (q', r) = quotRem r' d
09:37:23 <wli> where did I goof?
09:37:34 <Marvin--> good god I hate cvs
09:37:40 <shapr> switch to darcs!
09:37:41 <Marvin--> shapr: huh?
09:37:52 <Marvin--> shapr: what are you talking about (not darcs)
09:38:15 <wli> doh
09:38:35 <shapr> you said you'll decide tomorrow where to go next, and I got the impression you might want to go in a different direction, away from turning code into auto-proof material.
09:38:49 <shapr> Lilith: wie geht es?
09:38:58 <Marvin--> shapr: oh, no no no... just setting up priorities, what parts of it is more important
09:39:03 <shapr> ah, ok
09:39:09 * shapr whews
09:39:16 <Marvin--> shapr: and how far to go before stamping it a valid degree project so I get my degree ;)
09:39:28 <shapr> SlowProve is very spiffy.
09:39:35 <Marvin--> shapr: and whether we're going to write an article for HW or not
09:39:41 <shapr> I think you shoudl.
09:39:46 <Lilith> shapr: es geht
09:39:48 <Marvin--> yeah it'd be fun
09:39:52 <Lilith> hmm
09:40:10 <Marvin--> I mean, it'll be a "work in progress" type of article, but hey, it's a workshop
09:40:15 <shapr> yah, exactly
09:41:04 <wli> need to check for actually reducing degree
09:42:45 <d-bug> Marvin--: "HW"?
09:43:05 <Marvin--> d-bug: Haskell Workshop
09:43:32 <Marvin--> shapr: oh, and I think I've convinced two friends to form a icfp team with me :)
09:43:40 <d-bug> Marvin--: is that open to non-students like me? :)
09:43:40 <shapr> yay!
09:43:58 <Marvin--> shapr: didn't need much convincing ;) "you guys wanna participate in the icfp contest?" "yeah!"
09:44:01 <shapr> heh
09:44:02 <shapr> cool
09:44:14 <Marvin--> d-bug: I think it's open to anyway who pays the entrance fee, I wouldn't know though since I've never been to one
09:44:57 <shapr> d-bug: you're lucky, it's in Uppsala this year.
09:45:25 <Marvin--> yeah
09:46:17 <d-bug> shapr & Marvin--: i thought HW was some sort of regular meeting at Chalmers :)
09:46:31 <d-bug> i better learn haskell till that meeting :^)
09:46:36 <Marvin--> d-bug: no, it's always in conjunction with the international conference of functional programming
09:46:46 <Marvin--> which moves around
09:46:46 <shapr> last year it was in Pittsburgh I think
09:48:34 <Marvin--> "Tritnity uses Nmap to find a vulnerable SSH server, and then exploits it using the SSH1 CRC32 exploit from 2001."  LOL
09:48:51 <shapr> eh?
09:48:56 <Marvin--> in the Matrix
09:48:59 <Marvin--> the new one
09:49:31 <Marvin--> http://images.insecure.org/nmap/images/matrix/nmap-matrix2log.jpg
09:49:46 <elmex> shapr: those examles are a bit.. hm... i don't really understand them somehow by them self
09:50:22 <wli> circular definition of negate
09:50:24 <wli> fsck
09:50:29 <wli> Main> quotRem (Poly [6,4,8]) (Poly [4,6])
09:50:29 <wli> (Poly [0,1],Poly [6,0,2])
09:50:34 <shapr> elmex: did you read the first url first?
09:50:48 <wli> I'll probably take a crack at Gosper-Zeilberger summation and some other crap
09:50:54 <elmex> shapr: that 'What the heck are monads'  ?
09:50:55 <shapr> elmex: also, try to extend/break/fix the atkin examples.
09:51:03 <shapr> elmex: yah, I think that's it.
09:51:15 <elmex> shapr: but what are they for? what is that Div stuff and Con stuff for? ;)
09:52:57 <Marvin--> time to grab some food
09:53:03 <shapr> it's a calculator
09:53:11 <shapr> elmex: which example are you looking at?
09:53:22 <elmex> shapr: Eval3.hs
09:53:51 <Marvin--> shapr: btw, if you can think of an example program that has a subtle bug that quickcheck won't find but my program will, *do tell* :)
09:54:12 <shapr> heh, ok
09:54:15 <shapr> Lilith: erc?
09:54:27 <Lilith>  For example, the new _Helium_ project apparently generates Java.
09:54:34 <Lilith> ^ has anyone heard about this?
09:54:42 <Lilith> shapr: yeah. 
09:54:54 <Lilith> it looks like it needs a lot of tweaks before i can use it
09:55:07 <shapr> want to see my erc init file?
09:55:22 <Lilith> shapr: ok
09:55:35 <shapr> Marvin--: what about the commutative list monad thingy?
09:55:48 <Marvin--> shapr: the what and the what?
09:56:14 <shapr> Lilith: http://kungens.kemi.fi/~shae/src/elisp/shae-erc.el
09:56:35 <shapr> the commutative list monad discussion on ... either haskell or haskell-cafe
09:57:03 <Marvin--> the list monad transformation thingy?
09:57:25 <shapr> can quickcheck find that the list monad is not commutative?
09:57:32 <Marvin--> I have no idea
09:58:03 <shapr> what about stuff like the dining philosophers? can you prove deadlock?
09:58:37 <Marvin--> how the heck would I deal with multithreading?
09:59:32 * shapr considers that
10:05:34 <shapr> Marvin--: can you deal with monads?
10:07:13 <Marvin--> shapr: no
10:07:37 <shapr> I think multithreading could be expressed with monads
10:09:41 <elmex> shapr: hmm.. that example is ... messing with my mind
10:10:05 <shapr> elmex: that's the point :-)
10:10:12 <shapr> afterwards your mind will be stretched
10:10:21 <elmex> shapr: cool
10:14:18 <mgoetze> ph34r me, for my terminal is transparent and anti-aliased!
10:14:29 <shapr> whee
10:14:35 <shapr> my terminal allows inline elisp
10:14:48 <Lilith> eye candy!
10:14:56 <mgoetze> shapr: well, but what about anti-aliased fonts? :)
10:15:51 <wli> Main> take 5 $ recurrence [0, -1, Poly [0,2]] [1, Poly [0,2]]
10:15:51 <wli> [Poly [1],Poly [0,2],Poly [-1,0,4],Poly [0,-4,0,8],Poly [1,0,-12,0,16]]
10:15:57 <wli> I have Hermite polynomials =)
10:16:18 <shapr> mgoetze: yep, that too.
10:16:49 <wli> woops
10:16:52 <wli> that's wrong
10:16:52 <shapr> sadly, neither emacs nor xterms deal well with TTF fonts, and I haven't found any decent tengwar bcf fonts
10:17:01 <wli> hmm
10:17:11 <mgoetze> of course, ttf fonts suck anyway... so...
10:18:39 <wli> hm
10:18:44 <shapr> ?
10:18:46 <wli> basically bivariate polynomials
10:21:15 <shapr> gutentag kosmikus 
10:21:24 <shapr> wie geht es?
10:21:30 <kosmikus> hi shapr
10:21:48 <mgoetze> shapr: you wouldn't confuse dutch and german, now would you? :)
10:22:05 <kosmikus> no, I guess I wouldn't -- why do you ask?
10:22:37 <kosmikus> sorry, I didn't read the message
10:22:47 <kosmikus> shapr knows I am German ...
10:22:58 <Marvin--> shapr: yes it can be expressed with monads, Koen's wrote a paper on it a while back
10:23:10 <shapr> Marvin--: cool, good to know I'm right :-)
10:23:28 <shapr> mgoetze: the hostname is .nl, but the person is .de :-)
10:24:46 <Marvin--> shapr: you've got almost the same thing in unbiased parallel parsing too
10:25:47 <Lilith> Marvin--: the prover that you're writing...it's called vampire?
10:25:53 <Marvin--> Lilith: no
10:25:58 <Marvin--> Lilith: vampire is an existing first order logic prover
10:26:19 * mgoetze has a .de hostname, if you make the effort of WHOISing it :)
10:26:53 <Lilith> Marvin--: oh. sorry. ok
10:27:15 <Lilith> now comes the odious part of referring to papers
10:27:21 <Marvin--> Lilith: I don't even have a working title, though shapr keeps calling it SlowProve as a pun on QuickCheck
10:27:52 <shapr> Marvin--: I thought you started that?
10:28:05 <shapr> I'm 99% sure you came up with that name, and I just repeat it a lot.
10:28:14 <shapr> or maybe I'm just confused :-)
10:28:30 <shapr> I am often confused.
10:29:50 <Marvin--> shapr: that was just a joke
10:30:15 <shapr> it's a good joke.
10:30:28 <Marvin--> not exactly a selling name though
10:30:39 <shapr> oh
10:30:44 <shapr> I hadn't thought of that.
10:31:17 <Lilith> yeah. i reckon "slow" in a product name isn't usually a good thing :-0
10:31:49 <Lilith> hmm
10:31:52 <Lilith> this is difficult
10:32:08 * Lilith wonders which channel would be more appropriate to put my question to
10:32:14 <wli> Main> let { polymap f (Poly xs) = Poly (map f xs) ; polyval (Poly (c:cs)) x = c + x * polyval (Poly cs) x ; polyval (Poly []) _ = 0 } in take 5 $ zipWith (\p x -> polymap (flip polyval $ x) p) (recurrence [0, -1, Poly [0,2]] [1, Poly [Poly [2]]]) [0..]
10:32:14 <wli> [Poly [1],Poly [2],Poly [-1,4],Poly [-2,-2,8],Poly [1,-8,-4,16]]
10:33:14 <shapr> Lilith: what's your question?
10:33:56 <Lilith> shapr: i'm writing up my slides, and i wrote "easier to prove the correctness of a haskell program compared to one in java"
10:34:11 <Lilith> and someone pointed me out to various java tools
10:34:12 <wli> hmm
10:34:15 <Lilith> i'm just wondering how they compare
10:34:17 <wli> I wonder if that's correct
10:35:19 <shapr> Lilith: btw, many of the best from #java hang out on #javapro
10:35:40 <Lilith> shapr: ok
10:36:48 <wli> polyrecur coefs vals = zipWith (\p x -> polymap (`polyval` x) p)
10:36:48 <wli>                                 (recurrence coefs vals) [0..]   
10:36:52 <wli> that works
10:37:27 * shapr wanders off for a few hours
10:49:23 <wli> okay I can do the orthogonal version too
10:49:30 <wli> er
10:49:37 <wli> orthonormal too
10:52:40 <wli> polydiff (Poly xs) = Poly . tail $ zipWith (*) xs [0..]
12:03:07 <andersca> http://www.beatnix.org/
12:13:29 <wli> crap
12:13:32 <wli> where is this going wrong?
12:14:25 <wli> found it
12:14:44 <wli> Main> map hermite [0..5]
12:14:44 <wli> [Poly [1],Poly [0,2],Poly [-2,0,4],Poly [0,-12,0,8],Poly [12,0,-48,0,16],Poly [0,120,0,-160,0,32]]
12:14:55 <wli> I was evaluating the outer polynomials in polyrecur
12:15:15 <wli> the coefficients are the inner polynomials
12:16:33 <wli> Main> :type polyrecur
12:16:33 <wli> forall b.
12:16:33 <wli> (Num (Poly b), Num b) =>
12:16:33 <wli> [Poly (Poly b)] -> [Poly b] -> [Poly b]
12:28:41 <andersca> @prelude null
12:28:43 <lambdabot> *** "null" prelude "Haskell Standard Prelude Dictionary": text follows
12:28:43 <lambdabot> null
12:28:43 <lambdabot>   null ::  [a] -> Bool
12:28:43 <lambdabot>   null []           = True
12:28:44 <lambdabot>   null (_:_)        = False
12:30:17 <wli> let's try legendre
12:34:43 <wli> ergh
12:34:46 <wli> I need rational functions
12:37:36 <andersca> dennisb?
12:55:14 <wli> I'm in multiparameter type class hell
12:57:43 * esap thinks there is no such thing as a multiparameter type class hell. YMMV :-)
12:58:46 <wli> Main.hs:123:
12:58:46 <wli>     Could not deduce (Valuation (Poly a) b1 t, Valuation (Poly a) b t)
12:58:46 <wli>         from the context (Num t, Valuation (Poly t') t'' t)
12:59:29 <wli>     arising from use of `polyrecur' at Main.hs:123
12:59:29 <wli>     In the first argument of `(!!)', namely
12:59:29 <wli>         `polyrecur [0, Poly [Poly [2, -2]], Poly [0, 2]] [1, Poly [0, 2]]'
12:59:29 <wli>     In the definition of `hermite':
12:59:29 <wli>         (polyrecur [0, Poly [Poly [2, -2]], Poly [0, 2]] [1, Poly [0, 2]])
12:59:30 <wli>         !! n
13:00:38 <wli> instance (Num t, Integral t') => Valuation (Poly t) t' t where
13:00:38 <wli>         eval p x = polyval p $ fromIntegral x
13:00:41 <wli> should cover it
13:00:56 <esap> what's not even bad. [but you need to look at the type of polyrecur].
13:01:12 <wli> Main> :type polyrecur
13:01:12 <wli> forall f t' b b1.
13:01:12 <wli> (Valuation f b1 t', Num b1, Valuation f b t', Num b, Num (Poly
13:01:12 <wli>                                                               t')) =>
13:01:12 <wli> [Poly f] -> [Poly t'] -> [Poly t']
13:03:34 <esap> how come only few of the parameters to the type class are used for polyrecur. Doesn't sound very nice.
13:03:50 <wli> that was not the intended effect
13:05:00 <esap> But the type of polyrecur only refers to f and t'  (what are b1 and b?)
13:05:27 <wli> it should refer to t''
13:08:25 <esap> no I mean in the [poly f] -> [poly t'] -> [poly t'], not the error. Why would that function only use a part of that interface's parameters?
13:08:37 <wli> I have no idea
13:08:38 * shapr sighs
13:11:06 <wli> you're supposed to be able to promote the argument to a valuation
13:11:34 <wli> instance Fractional t => Valuation (Poly (Poly t)) t (Poly t) where
13:11:34 <wli>         eval p x = polymap (flip polyval $ x) p
13:12:56 <wli> that's what it's there for
13:14:10 <wli> class Valuation f t t' where
13:14:10 <wli>         eval :: f -> t -> t'
13:15:28 <esap> wli: you shouldn't do that. You should express the dependency between the arguments and return value of the eval function explicitly, not through instance declarations only.
13:15:43 <wli> esap: what do you mean?
13:17:26 <esap> wli: I mean, the type checker has some trouble connecting those. The problem is that for each type of 'f', there is potentially many choices of t and t' that could be instances of Valuation. It's not that easy for the compiler to match those.
13:17:48 <esap> Unless you explicitly describe the connection.
13:19:01 <wli> esap: well it is a true ternary relation
13:19:34 <wli> one input is (Poly (Poly t)), the next t, and the output (Poly t)
13:19:49 <esap> And in your case, since polyrecur does not require a particular value for some of the type class parameters, they are chosen as separate type variables. Then when they are unified, they will not match.
13:21:59 <esap> And this causes that the type checker tries to instantiate those classes based on type variables you have not written in the code.
13:22:12 <esap> And of course that will then fail.
13:23:44 <wli> I don't quite get it.
13:24:02 <wli> okay let me try it this way
13:24:05 <esap> Actually, this is one place where I would hope the type checking could simply disallow writing a function that does not bind all type variables of a class but that depends on it.
13:24:36 <esap> The problem is like writing (Num a) => Integer. It does not make sense.
13:25:18 <esap> Your polyrecur function has that problem.
13:25:44 <wli> I basically want nesting of the type constructor to arbitrary depth to be evaluable to one less nesting depth
13:25:53 <wli> polyrecur coefs vals
13:25:54 <wli>         | length coefs /= length vals + 1 =
13:25:54 <wli>                         error "mismatched lengths of coefficients and values"
13:25:54 <wli>         | otherwise = vals ++ zipWith coefSum ys [length vals ..]
13:25:54 <wli>         where
13:25:54 <wli>                 xs = polyrecur coefs vals
13:25:56 <wli>                 ys = transpose [drop k xs | k <- [0..length coefs - 1]]
13:25:58 <wli>                 transpose xs = map head xs : transpose (map tail xs)
13:26:00 <wli>                 coefs' n = map (polymap (flip eval $ fromIntegral n)) coefs
13:26:02 <wli>                 coefSum xs n = head (coefs' n)
13:26:04 <wli>                                 + sum (zipWith (*) (tail $ coefs' n) xs)
13:26:06 <wli> that's the function
13:27:14 <wli> it is a true 3-place relation 
13:27:49 <wli> for some reason that function isn't seeing much of it
13:28:52 <esap> wli: you mean that for eval, the type of the return value does not in any way depend on the type of its arguments?
13:28:55 <wli> so basically how the heck do I do this
13:29:10 <wli> it does depend on the type of its arguments
13:29:37 <esap> wli: your class says there is no such link.
13:29:57 <wli> it's bull
13:30:05 <wli> there's a fromIntegral in there that shouldn't be
13:30:13 <wli> nuke that and:
13:30:14 <wli> Main> :type polyrecur
13:30:14 <wli> forall f t'.
13:30:14 <wli> (Valuation f Int t', Num (Poly t')) =>
13:30:14 <wli> [Poly f] -> [Poly t'] -> [Poly t']
13:30:24 <wli> plain old ambiguous type variable
13:31:21 <esap> hmm... yea, fromIntegral can be a bit dangerous :-)
13:36:04 <esap> Hmm.. would it be possible to fix these kinds of problems by enhancing the type checker to not complain on universally quantified uninstantiated variables?
13:37:57 <wli> possible
13:40:07 <esap> Something like represent universally quantified type variables at runtime as bare "dispatch tables"
16:25:47 <tic_> ghc can't seem to find mkRegex...
16:26:06 <tic_> even though I've imported Regex
16:26:21 <tic_> "variable not in scope, mkRegex
16:26:22 <tic_> "
16:37:18 <kosmikus> I think you have to import RegexString
16:39:36 <tic_> DoSearch.cgi.hs:34: Variable not in scope: `matchRegex'
16:39:41 <tic_> hm
16:40:20 <tic_> cool, thanks!
16:40:56 <kosmikus> ?
16:41:06 <kosmikus> matchRegex is also exported by RegexString
16:42:47 <tic_> okay
16:42:56 <tic_> I thought I should import Regex only
16:43:24 <tic_> I get an error on a case (matchRegex (mkRegex "j.*") str) -- Non-exhaustive patterns in case 
16:43:50 <kosmikus> which patterns do you match?
16:44:25 <tic_> ["java", "jiujitsu", "tic"] and some more
16:45:28 <tic_>  regexMatches (x,(_,_)) = case (matchRegex (mkRegex ("("++regexp++")")) x) of
16:45:29 <tic_>                          Just (x:xs) -> True
16:45:29 <kosmikus> matchRegex returns a "Maybe [String]", so you should provide a case for "Nothing", for example ...
16:45:30 <tic_>                          Just [] -> False
16:45:42 <tic_> aha
16:45:57 <tic_> I could just replace the last line with _ -> False then, right?
16:46:32 <kosmikus> probably
16:46:46 <kosmikus> I am not sure if I remember the function correctly
16:47:17 <tic_> okay
16:47:19 <tic_> goodie.
16:47:23 <kosmikus> but I assume that if the match succeeds, it returns "Just <the list of strings that have matched the subexpressions>"
16:47:23 <tic_> but you're probably right.
16:47:27 <tic_> yeah
16:47:34 <kosmikus> if the match fails, then it returns "Nothing"
16:47:50 <tic_> well
16:47:51 <kosmikus> so what you want to do with it, you have to know yourself ;)
16:47:54 <tic_> I was told it returned Just []
16:48:17 <kosmikus> yeah, it does ... if you don't have any subexpressions to match
16:48:36 <tic_> hm?
16:48:39 <tic_> what's that mean?
16:49:28 <kosmikus> if you have a part enclosed in parentheses in your regexp, then the part of your input string that actually matches the part in parentheses is returned ...
16:49:56 <tic_> if I want to filter "j.*" on the list ["java", "jiujitsu", "tic", "cofee"], the regex would be the following: "j.*" ?  or would it be "(.j*)" ?
16:50:03 <tic_> I only care if it matched or not
16:50:13 <kosmikus> maybe even the whole expression that matched is always returned
16:50:43 <tic_> m'kay.
16:51:07 <kosmikus> lets start ghci :)
16:51:29 <kosmikus> Prelude RegexString> matchRegex (mkRegex "a*") "b"
16:51:35 <kosmikus> Just [""]
16:51:48 <kosmikus> Prelude RegexString> matchRegex (mkRegex "a*") "aaa"
16:51:54 <kosmikus> Just ["aaa"]
16:52:07 <kosmikus> Prelude RegexString> matchRegex (mkRegex "a*") "aaabb"
16:52:07 <kosmikus> Just ["aaa"]
16:52:10 <tic_> how do I start in RegexString?
16:53:14 <tic_> (start ghci in RegexString)
16:53:35 <kosmikus> say "ghci -package text", then ":m RegexString" on the prompt
16:53:40 <tic_> ah
16:54:05 <tic_> kosmikus, in the last regex you tried, it did return the submatch.  What if I wanted to know if it matched the entire string or not?
16:54:36 <kosmikus> Prelude RegexString> matchRegex (mkRegex "a*$") "aaabb"
16:54:47 <kosmikus> but I have to check first
16:54:52 <tic_> ah, checking myself.
16:55:31 <kosmikus> what are you working on?
16:55:58 <tic_> kosmikus, a search function for a lab assignment...
16:56:00 <tic_> (school)
16:56:24 <tic_> heh:
16:56:25 <tic_>  RegexString> matchRegex (mkRegex "a*") "aaa"
16:56:25 <tic_>  Just ["","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]   
16:56:29 <tic_> how about that one?
16:56:35 <kosmikus> so you are learning Haskell?
16:56:46 <tic_> yeah, I haven't written much code in it.
16:57:09 <kosmikus> I get "Just ["aaa"]" on the same input. Are you sure?
16:57:14 <tic_> yes indeed.
16:57:19 <tic_> ghci 5.02.2
16:57:32 <tic_> on solaris
16:57:58 <kosmikus> what does "matchRegexAll" say?
16:58:41 <tic_>  RegexString> matchRegexAll (mkRegex "a*") "aaa"
16:58:42 <tic_>  Just ("","aaa","","",["","","","","","","","","","","","","","","","","","","","","","","","","","","","",""])
16:59:46 <kosmikus> okay, it obviously behaves different from my version (ghc 5.04.3 on Linux) ...
17:00:05 <kosmikus> probably the list contains just matches _real_ subexpressions in your version
17:00:12 <tic_> yeah
17:00:15 <tic_> well
17:00:19 <tic_> it does give out a Nothing
17:00:26 <kosmikus> can you try   matchRegex (mkRegex "(a*)") "aaa"
17:00:31 <tic_> so I could test for Nothing (-> True), or _ -> False
17:00:39 <tic_> (or actually, flip those two)
17:00:41 <tic_> okay, sec
17:00:44 <tic_> hm
17:01:01 <kosmikus> yes, I guess that for your application, that would be sufficient
17:01:13 <tic_> Just ["aaa","","","","","","","","","","","","","","","","","","","","","","","","","","","",""] 
17:01:38 <kosmikus> that seems logical (in consequence)
17:02:14 <kosmikus> so   matchRegex (mkRegex "(a*)(b*)") "aaabbbbbb"   probably gives
17:02:23 <kosmikus> ["aaa","bbbbbb","", ...]
17:02:55 <tic_> Just ["aaa","bbbbbb","","","","","","","","","","","","","","","","","","","","","","","","","","",""] 
17:02:55 <tic_> yup
17:02:58 <kosmikus> are you actually supposed to use regexps for your task?
17:03:07 <tic_> yup
17:03:19 <kosmikus> okay
17:03:21 <tic_> i'm supposed to implement a search where you can specify a regexp
17:03:28 <tic_> well, got that working at least.
17:03:32 <tic_> Now, something else's failing :)
17:03:33 <tic_> Fail: DoSearch.cgi.hs:41: Non-exhaustive patterns in function dictify 
17:03:48 <tic_> of course you don't know anything about what exactly my files or functions does
17:03:56 <tic_> although maybe you know what a non-exhaustive pattern is?
17:04:52 <kosmikus> yes, it's what you had before -- you have a case where you match against a few patterns, but not against all patterns that can occur
17:05:45 <kosmikus> so, for instance, if you match on a "Maybe" type, it can be either a "Just" or a "Nothing". If you match on only one of the two, and the other one occurs in your program run, then a run-time error is raised.
17:05:57 <tic_> hmm
17:05:58 <tic_> strange
17:06:03 <kosmikus> why?
17:06:05 <tic_> I match against Nothing and _
17:06:11 <tic_> shouldn't that take everything?
17:06:21 <kosmikus> yes
17:06:50 <tic_> good.
17:06:52 <kosmikus> but maybe you have another case/pattern-match somewhere inside the definition
17:07:00 <tic_> seems so, yeah
17:07:06 <tic_> my regexMatches function works at least.
17:07:20 <tic_>  regexMatches :: String -> (String,(String,String)) -> Bool
17:07:20 <tic_>  regexMatches regexp (x,(_,_)) = case (matchRegex (mkRegex regexp) x) of
17:07:21 <tic_>          Nothing -> False
17:07:21 <tic_>          _ -> True    
17:07:25 <tic_> shouldn't be anything wrong with that one
17:08:34 <kosmikus> I can't tell whether it is correct w.r.t. the task, but yes, it seems okay.
17:08:41 <tic_> actually:
17:08:41 <tic_> http://www.dtek.chalmers.se/~tic/cgi-bin/ptc-lab4/Search.cgi
17:08:52 <tic_> and for the main list of definitions: http://www.dtek.chalmers.se/~tic/cgi-bin/ptc-lab4/Main.cgi
17:09:54 <kosmikus> sorry, but I am not going to look at the exercises. after all, the idea is that you learn by solving them yourself ;)
17:10:56 <tic_> hehehe
17:10:59 <tic_> I think I found it.
17:11:16 <tic_> you asked what the task was about, I just wanted to show you why I wanted to use a regex
17:11:35 <tic_> I'm not the guy who puts out assignments on others
17:11:46 <kosmikus> no offense intended ...
17:12:43 <tic_> 'tis cool. :)
17:12:58 <kosmikus> what?
17:13:20 <tic_> "no offense intended" <-> no offense taken.
17:20:46 <tic_> wee! worked
17:20:48 <tic_> thanks for the help
17:21:28 <kosmikus> great!
17:21:46 <tic_> I matched for j.* and couldn't figure out why I wouldn't get java or jiujitsu
17:21:51 <tic_> turned out they were in upper case .... :)
17:22:09 <kosmikus> how do you like Haskell?
17:23:06 <tic_> well..
17:23:09 <tic_> I prefer Python. :)
17:23:14 <tic_> although I like it for list processing
17:23:41 <tic_> I find myself spending a lot of time dealing with language issues rather than getting things done, like I would in, say, Python
17:23:44 <kosmikus> python is quite nice as well, although I prefer static types :)
17:23:59 <tic_> *nods
17:24:18 <tic_> though, haskell code is art.
17:24:29 <tic_> it's so beautiful
17:24:54 <kosmikus> yes, the syntax is quite nice (mostly)
17:25:26 <kosmikus> which year are you in (studying)?
17:26:17 <tic_> first year, computer science and engineering at Chalmers University of Technology
17:26:24 <tic_> (yup, I've been tutored by J. Hughes)
17:26:25 <tic_> :)
17:26:33 <kosmikus> can imagine :)
17:26:57 <tic_> he's cool
17:27:26 <kosmikus> yeah, I've seen him a few times -- seems to be a nice person, and he can talk ...
17:28:04 <kosmikus> d'you know Patrik Jansson?
17:28:22 <tic_> nopes.
17:28:36 <tic_> *hmm*
17:28:56 <tic_> matchRegex (mkRegex "t*") "tic" => Just ["","","",....]
17:29:01 <tic_> matchRegex (mkRegex "t.*") "tic" => Just ["","","",....]
17:29:12 <tic_> which is wrong; only one of them should return something valid (the last one)
17:29:49 <tic_> a-ha! matchRegex (mkRegex "(t*)$") "tic"
17:30:27 <kosmikus> yes, otherwise you only match on the beginning of a string
17:30:53 <tic_> yup
17:30:59 <tic_> I want to match to the end of the line.
17:31:05 <tic_> (end of the string, actually)
17:31:30 <tic_> wee! :)
17:31:35 <tic_> so now I'm _really_ done
17:31:44 <tic_> now I have to write a report comparing Java to Haskell
17:31:52 <tic_> ("java sucks, haskell rewlz")
17:31:59 <kosmikus> of course :)
17:32:00 <tic_> but now it's nitey time.
17:32:06 <tic_> again, thanks.. and sleep tight.
17:32:15 <kosmikus> right -- I should go to bed, too ...
17:32:21 <tic_> yeh
17:32:23 <tic_> 02:35 here
17:32:24 <kosmikus> you're welcome -- see you around
17:32:28 <kosmikus> me too
17:32:36 <tic_> *Zzz*
17:32:41 <kosmikus> (I'm in NL)
17:34:50 <tic_> yeah, saw that.
20:30:40 <wli> hmm
20:41:05 <wli> hmm
20:42:05 <wli> I need to have a way of saying a valuation function projects R[x_1,...,x_n] onto R[x_1,...,x_(n-1)]
20:42:45 <wli> eval : R[x_1,...,x_n] X R -> R[x_1,...,x_(n-1)]
20:43:24 <wli> where R[] = R
20:46:03 <wli> multiparam typeclasses aren't doing it
23:34:26 * shapr yawns
23:34:37 <shapr> good morning #haskell!
23:46:16 <Lilith> j #java
23:46:19 <Lilith> whoops
23:49:42 <wli> hm
23:54:04 <jdrake> without using any imperative style, how (theoretically) would a functional program output information
23:54:29 <wli> continuation-passing style and wrappers thereof (e.g. monads)
23:55:26 <jdrake> i have been looking for information on what monads are, but google seems very tight lipped and circular in references
23:57:48 <seth_> jdrake: did you have specific questions?
23:58:29 <shapr> @topic-snoc #haskell yay
23:58:29 <lambdabot> topic doesn't parse
23:58:49 <jdrake> my imperative mind is not really grasping how one would write an actual program can be written in a functional language
23:58:58 --- topic: set to '["mo' nads than you","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","Order Haskell 98 Report in Hardcopy - http://titles.cambridge.org/catalogue.asp?isbn=0521826144","HaWiki - http://www.haskell.org/hawiki","0th IOHCC Results - http://iohcc.mgoetze.net/winners.html"]' by shapr
23:59:00 <shapr> @topic-snoc #haskell yay
23:59:01 --- topic: set to '["mo' nads than you","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","Order Haskell 98 Report in Hardcopy - http://titles.cambridge.org/catalogue.asp?isbn=0521826144","HaWiki - http://www.haskell.org/hawiki","0th IOHCC Results - http://iohcc.mgoetze.net/winners.html","yay"]' by lambdabot
23:59:14 <shapr> jdrake: any specific questions?
23:59:19 <seth_> jdrake: that is overly broad.  I just completed a fairly large program, and much of it does use monadic coding.
23:59:19 <shapr> lambdabot is written in Haskell
23:59:33 <shapr> @topic-init #haskell
23:59:33 --- topic: set to '["mo' nads than you","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","Order Haskell 98 Report in Hardcopy - http://titles.cambridge.org/catalogue.asp?isbn=0521826144","HaWiki - http://www.haskell.org/hawiki","0th IOHCC Results - http://iohcc.mgoetze.net/winners.html"]' by lambdabot
23:59:52 <jdrake> hmm
