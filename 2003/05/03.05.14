01:12:56 <delYsid> darn, Clean is non-free :(
01:13:15 <Marvin--> yeah, I noticed that too
01:13:15 <delYsid> I would have looked at it more closely now, if it weren't so.
01:13:59 <o3> hmm, does anyone know how to splice in a Type in template haskell?  i'm trying to do something like this:
01:14:00 <delYsid> somehow strange, they list LGPL and dual-licensed... and then you get a LICENSE file which states only for non-commercial use...
01:14:05 <delYsid> I wonder if all that is sooo legal..
01:14:06 <o3> stringType = [t| String |]
01:14:16 <o3> foo :: $(stringType) -> $(stringType)
01:14:24 <o3> foo s = s ++ " foo"
01:14:28 <o3> which doesn't work
01:15:59 <o3> and something like
01:16:05 <o3> data Foo = Foo $(t1)
01:16:07 <o3> doesn't work either
01:17:22 <Marvin--> o3: clarify "doesn't work"? Not that I've experimented with TH yet, but "doesn't work" doesn't tell me a whole lot
01:17:36 <o3> Marvin--: sorry, it gives me a parse error
01:17:54 <Marvin--> a parse error? hmm, that's strange, isn't it?
01:18:03 <Marvin--> where's the TH spec?
01:18:15 <o3> spec? 8)
01:18:27 <o3> only spec i know of is the source code
01:18:27 <Marvin--> bleh
01:18:49 <Marvin--> so there is no spec on where you can splice and where you can't?
01:19:10 <o3> i'm having a look at the original TH document now to see if there are any examples
01:19:39 <Marvin--> the meta-haskell one?
01:19:49 <o3> nod
01:23:49 <Marvin--> there doesn't seem to be much type splicing in the paper
01:24:01 <o3> yeah, i'll post a message to the th mailing list
01:28:28 * Marvin-- laughs at PvP
01:30:06 <Marvin--> http://www.pvponline.com/archive/2003/pvp20030513.gif
01:44:28 <seth> there's a ghc option to get ghc to run a program before compiling the file.  I've used it, but I don't remember the flag and I can't find it in the user's guide.  Does anyone remember it?
01:44:58 <seth> never mind, I just found it.  :)
01:48:14 <Marvin--> you mean preprocessing?
01:48:35 <seth> Right, the -F option.  It's late, I missed it the first time.
02:18:12 * shapr yows
02:19:20 <shapr> @yow
02:19:21 <lambdabot> ..  If I had heart failure right now, I couldn't be a more fortunate man!!
02:35:31 <shapr> how is everyone this fine morning?
02:40:24 <mgoetze> shapr: quite well, thanks :)
02:40:44 <shapr> It's a beautiful day out there.
02:41:04 <mgoetze> except that it's raining, of course
02:41:30 <shapr> aren't you lucky you're inside watching the rain?
02:41:36 <shapr> better than being outside standing in it ;-)
02:41:50 <mgoetze> no, i'm lucky being inside watching my new ibook :)
02:52:36 <shapr> so, what exciting things are happening in the world of Haskell today?
02:58:30 <Marvin--> heh, devious Swedish school children
02:59:22 <Marvin--> there's a big strike among others for the cleaner staff... so now there's kids littering the schools on purpose in an attempt to get summer break sooner
03:01:06 <shapr> yow
03:54:20 <shapr> hi Chilli 
04:46:48 <shapr> hi baha
04:46:54 <shapr> wassup?
04:46:54 <baha> hi
04:47:05 <baha> doing my own code
04:47:07 <baha> -_-
04:47:07 * andersca bounces
04:47:25 * shapr boings
04:47:27 <baha> whats a .lhs file?
04:47:30 <baha> is it still haskell?
04:47:38 <shapr> y0 andersca, any new thoughts on kinesis?
04:47:52 <shapr> baha: yes, it's a literate Haskell file
04:47:57 <baha> meaning?
04:48:03 <shapr> it's where code is specially delimited instead of comments
04:48:15 <baha> ic
04:48:26 <baha> im just analysing delysid's chess code
04:48:27 <shapr> unless the line starts with greater than and space ---> "> " then it's a comment
04:48:34 <andersca> shapr: thinking about switching the alt and alt gr keys
04:48:41 <shapr> if it does start with greater than and space, then it's code
04:48:57 <shapr> baha: oh, there's a second type of literate haskell
04:49:03 <shapr> where it's combined with LaTeX
04:49:16 <shapr> everything in the file is LaTeX except the \{code} sections
04:49:16 <baha> im fine with not having my brain overloaded tks ;p
04:49:46 <baha> whats the -- creates new board
04:49:47 <baha> --
04:49:47 <baha> newBoard :: (Row,Column) -> HPBoard
04:49:47 <baha> newBoard row col = HPBoard row col board
04:49:48 <baha>  where
04:49:48 <baha>   board = [replicate col "Black"] ++ replicate (row-2)(replicate col "Neither") ++ [replicate col "White"]
04:49:49 <baha> --  black   = [replicate col "Black"]
04:49:51 <baha> --  neither = replicate (row -2) (replicate col "Neither")
04:49:53 <baha> --  white   = [replicate col "White"]
04:49:55 <baha> wtf
04:49:55 <shapr> hey delYsid, which parts need to be rewritten for pure GPL chess code?
04:50:00 <baha> fuck
04:50:04 <shapr> baha: -- starts a comment
04:50:08 <shapr> that's for single line comments
04:50:14 <shapr> baha: are you using vim or emacs for an editor?
04:50:15 <baha> dun worry what i posted
04:50:23 <baha> im using conTEXT
04:50:33 <shapr> never heard of it
04:50:44 <baha> its more user friendly kinda
04:50:50 <baha> anyhow
04:50:57 <baha> what does Maybe a
04:51:01 <baha> do
04:51:18 <shapr> it's a type that encapsulates failure or success
04:51:30 <shapr> look at Data.Maybe in the GHC docs
04:51:30 <baha> meaning?
04:51:44 <baha> dun have the docs
04:51:45 <baha> :O
04:51:53 <shapr> http://www.haskell.org/ghc/docs/latest/html/base/Data.Maybe.html
04:52:02 <shapr> you can download the docs
04:52:14 <shapr> baha: you'll probably get further faster if you try to write your own code
04:52:19 <shapr> and start out with the basics
04:52:31 <shapr> I'd suggest looking at http://www.haskell.org/learning.html
04:52:35 <baha> i jus wanna kno what does Just a do
04:52:53 <shapr> read the Data.Maybe docs
04:53:17 <baha> ic
04:53:26 <baha> btw who logs this chan
04:53:34 <shapr> the bot named clog 
04:53:40 <shapr> it's a service of tunes.org
04:53:53 <baha> ic
04:54:18 <shapr> you go to unsw also?
04:54:39 <baha> ahuh
04:54:57 <baha> and i hope im not gunna get fucked over cos i accidentally pasted my own codes :/
04:55:00 <baha> in this
04:55:39 <shapr> I don't think so
04:55:58 <shapr> I think you'll only get in trouble if you get other people to do the work for you.
04:56:18 <Rafterman> or if someone submits the code you pasted into channel
04:56:19 <shapr> but I'm not your teacher
04:56:26 <saz> baha: you don't know if there's any other students here
04:56:26 <shapr> hi Rafterman 
04:56:37 <Rafterman> hello
04:56:46 <shapr> are you learning Haskell?
04:57:00 <shapr> are you also going to unsw? :-)
04:57:08 <baha> saz: i dunno if theres any other students here, but i know for sure theres atleast staff here
04:57:09 <baha> -_-
04:57:36 <saz> heh
04:57:44 <shapr> hi htuch 
04:57:58 <htuch> evening shapr
04:58:00 <baha> shapr
04:58:03 <baha> i dun see the Maybe.doc
04:58:08 <shapr> http://www.haskell.org/ghc/docs/latest/html/base/Data.Maybe.html
04:58:33 <shapr> htuch: lemme guess, unsw?
04:58:54 <htuch> yep :)
04:59:17 <shapr> amazing
04:59:23 <baha> u kno what i hate about programming?
04:59:29 <shapr> baha: managers?
04:59:31 <opet> emacs?
04:59:32 <baha> sometimes u can spend 5-6 fkn hours on it and not do a thing
04:59:34 <Rafterman> the fact that other people won't do it for you?
04:59:37 <opet> ;p
04:59:39 <baha> sometimes tho, u jus click it in 15 mins
04:59:39 <shapr> Rafterman: heheh
04:59:41 <htuch> hah
04:59:49 <shapr> baha: there's a solution to that problem
04:59:54 <baha> wat
05:00:01 <shapr> baha: eXtreme Programming has something called Unit Test First
05:00:03 <shapr> it really works.
05:00:13 <baha> english?
05:00:18 <shapr> google?
05:00:30 <baha> anyhow
05:00:31 <Rafterman> touche'
05:00:38 <baha> think im jus gunna stick with doing it
05:00:49 <baha> gotta learn this crap
05:00:57 <baha> i truly hate computing :(
05:01:21 <shapr> baha: why are you doing it then?
05:01:21 <saz> baha: then why are you studying it?
05:01:49 <baha> cos my previous preferences for unsw didnt make it :<
05:02:06 <baha> and what im doin now is my last pref for unsw
05:02:24 <shapr> so do something else.
05:02:25 <htuch> why not go to another uni and do what you want to do?
05:02:47 <baha> cos the degree that i really wanted to do
05:02:52 <baha> not high nuff uai fer it
05:03:01 <baha> for macq, uts, usyd or unsw
05:03:01 <htuch> what degree?
05:03:03 <baha> :<<
05:03:05 <baha> comm
05:03:12 <saz> hmm
05:03:19 <saz> no wonder you hate computing 
05:03:20 <baha> and thing about unsw is
05:03:25 <baha> they dont let u change degree mid yr
05:03:36 <shapr> baha: psst, this is #haskell
05:03:37 <baha> i like playin comp games alrite, but i definitely dont like programming
05:03:40 <baha> just not my cuppa :(
05:03:45 <shapr> baha: write games then
05:03:48 <htuch> they used to allow you to do that...
05:03:50 <shapr> it's easier than you think.
05:04:02 <baha> i think i wanna stick with being a money man :(
05:04:03 <saz> shapr: i think his assignment is a game
05:04:08 <shapr> I suspect it is.
05:04:19 <saz> I know it is
05:04:20 <shapr> saz: in fact, I think I've read the assignment myself.
05:04:21 <baha> ANYWAY
05:04:26 <baha> enuff rambling
05:04:34 <saz> shapr: I believe i have too!
05:04:36 <shapr> with that scary warning at the bottom, eh?
05:04:40 <baha> back to coding with my eyes like this -> o.O
05:08:23 <shapr> I'm here because I love programming, and Haskell is my favorite programming language.
05:08:32 <shapr> hi pseiko, what's up?
05:08:50 <shapr> pseiko: one or two other people have expressed interest in resurrecting O'Haskell
05:16:49 <pseiko> hello all  
05:17:01 <shapr> hi pseiko 
05:17:30 <shapr> pseiko: I have to ask, is a pseiko a watch that communicates telepathically? you just have to mentally wonder what time it is, and suddenly you know? :-)
05:17:59 <pseiko> i really like these obfuscated contest programms :-)
05:18:17 <shapr> yah, they're great. I wish we could have given prizes to everyone who entered.
05:18:37 <shapr> http://iohcc.mgoetze.net/winners.html
05:18:57 <shapr> for anyone who missed it, the IOHCC winners have been announced.
05:19:07 <pseiko> oh, you are the first one, who guess my nicks meaning, congratulation :-)
05:19:22 <delYsid> haha, baha :)
05:19:23 <shapr> pseiko: is that really it?
05:19:29 <shapr> I hear sarcasm ;-)
05:19:59 <pseiko> no, but thats my way to make a long story short *g*
05:20:04 <shapr> heh, ok
05:20:20 <delYsid> shapr: I loved the .sig entry
05:20:21 <shapr> hey delYsid, can you point me to the parts of chess/ that need to be rewritten/replaced to make it GPL?
05:20:26 <shapr> yah, that's a cool one.
05:20:56 <delYsid> shapr: Move.hs and Board.hs, only parts of them...
05:21:08 <pseiko> What about this?  Haskell:  that's where I just curry until fail, unwords any error,  drop all undefined, maybe break, otherwise in  sequence span isControl and take max $, id: (d:[])  
05:21:21 <delYsid> shapr: I had to try it also :)
05:21:22 <delYsid> import Char;k=r"("++"9'"++r"%"++"6*5"++r"&"++"$7"++r":8"++"&$%7*968"++r"7"++"6"
05:21:22 <shapr> The reason we didn't make all entries public is so entrants can improve their entry and then enter again next year
05:21:22 <delYsid>   ++"-$-(),$5%7:+#8(&$%";main=putStr$(concatMap(\e->if e=="O"then"debian.org"
05:21:22 <delYsid>  else if e==";"then"\n       | "else e)$map(\c->[c])("CYa,\n Mario | Debian"++
05:21:23 <delYsid>  " Developer <http://O/>;Finger my public key at mlang@db.O;"))++reverse[chr.
05:21:23 <delYsid>      (+(flip(-)28.ord$head k))$ord c|c<-k]++"\n";r=concatMap$replicate 2
05:21:34 * Igloo gets very confused by SPJ's name
05:21:50 <shapr> Igloo: eh?
05:22:07 <Igloo> I think e-mail is the only place he uses a -
05:22:19 * shapr tries to rectangle-copy delYsid's code
05:22:39 <Igloo> Oh, it's probably because OE has a "surname" field you can't press space in or something
05:24:03 <delYsid> anyway, its too long and not really obfuscated enough
05:24:24 <shapr> delYsid: cute :-)
05:24:33 <shapr> nifty code
05:24:54 <shapr> I had to put spaces after all the $ chars so 5.05 wouldn't try to do template stuff at me.
05:25:01 * shapr thinks about TH obfuscation
05:25:52 <delYsid> anyway, remorse was really cool
05:26:09 <delYsid> I always wondered why Marvin-- would want to rename haskell functions :)
05:26:17 <shapr> yah, remorse is very spiffy
05:26:19 <delYsid> NOw I know of at least one application for that :)
05:26:23 <shapr> heh
05:26:48 <shapr> I think we should have another 'real' IOHCC soon.
05:27:05 <pseiko> shapr: please tell me more about these people (OHaskell)
05:27:06 * delYsid will enter
05:27:08 <shapr> with a longer submission deadline, and a shorter judging deadline ;-)
05:27:18 <delYsid> although I'll most probably have no chance against those Hardcore haskellers.
05:27:53 <shapr> pseiko: one of the #haskellwars guys wants OOP in Haskell, and I've forgotten who the other person is...
05:27:58 <shapr> if I remember I'll tell you.
05:28:04 <shapr> pseiko: have you made any progress?
05:28:16 <shapr> pseiko: I think you could do the reactive stuff with AFRP
05:30:17 <pseiko> this reactive stuff is not that important for my work, i focus to records and subtyping
05:30:37 <pseiko> what the hell is haskellwars?
05:30:55 <shapr> http://www.haskellwars.com/
05:32:36 <delYsid> heh
05:32:44 <delYsid> shapr: any idea how the current status is?
05:33:41 <shapr> delYsid: of what? haskellwars? or do you mean the RTS game?
05:33:49 <shapr> hej dennisb, hur är det med dig?
05:34:51 <shapr> How's Nottingham?
05:34:58 <dennisb> shapr: hej hopp, det är bara bra. Själv då?
05:35:11 <shapr> bra ocksa
05:35:24 <delYsid> shapr: I thought the RTS and HaskellWars was sort of the same?
05:35:30 <dennisb> Who is in nottingham?
05:35:35 <delYsid> oh damn!  They write a GUI client
05:35:39 <delYsid> Big Big Big SUCKAGE!
05:35:59 <shapr> HaskellWars is a project some chalmers students are doing.
05:36:30 * delYsid kills it from his "interest" list
05:37:14 <delYsid> where did the "Keep It Simple" philosophy go these days???
05:37:49 <delYsid> It got lost in "If it doesn't have a shiny GUI, it isn't worth anything" philosophies... :/
05:44:11 <delYsid> hmm, can anyone here explain Uniqueness typing?
05:44:25 <delYsid> It seems Clean uses that to solve the IO problem.
05:44:29 <delYsid> BUt I'd like to know how...
05:45:52 <o3> pseiko: you're doing subtyping stuff in haskell?
05:46:18 * Igloo looks interested
05:47:27 <wli> what subtyping model?
05:48:05 <o3> wli: inheritance (in OO languages like c++/java/etc)
05:48:12 <wli> oh
05:49:06 <wli> any idea what McBride is on about?
05:49:29 <shapr> where?
05:49:43 <wli> the Prolog programs at the level of types
05:49:45 <pseiko> o3: yes
05:49:52 <Marvin--> delYsid: what application?
05:50:00 <pseiko> o3: and you?
05:50:36 <wli> I can sort of vaguely see something like that going on
05:51:14 <shapr> hi wax- 
05:51:20 <shapr> wli: which mailing list?
05:51:33 <wli> haskell-cafe
05:51:48 <wli> the one alastair reid just flamed
05:51:54 * shapr looks
05:52:57 <Marvin--> it's kinda boring to read these entrires with syntax highlighting on
05:53:14 <Marvin--> maybe next year we should have a category "best messed up syntax highlighting"
05:54:25 <delYsid> Marvin--: HaskellWars
05:54:51 <Marvin--> delYsid: no, you were talking about my function renaming
05:55:28 <pseiko> hey, there is a kind of sunshine out there :-) have to leave, ciao
05:57:49 * Marvin-- doesn't understand how to play Pseudonym's tictactoe game
06:02:31 <BlitzNL> I am reading this book on type systems by B.C.Pierce and it uses (OCa)ML. I am trying to port some code to haskell but ML has this conditional pattern match using the when keyword, like 'Bla _ a when (a > 3) -> True'. I am strugle with a nice way to map this to haskell, any suggestions?
06:03:17 <shapr> BlitzNL: what does the rest of that function look like?
06:03:52 <Marvin--> BlitzNL: don't haskell's guards do the same thing?
06:04:02 <Marvin--> BlitzNL: Bla _ a | a > 3   = True
06:04:16 <shapr> hi nbd 
06:04:31 <shapr> nbd: have any questions about Haskell?
06:05:06 * Marvin-- is starting to suspect shapr is a bot
06:05:10 <shapr> :-P
06:05:23 <BlitzNL> Marvin--: well ofcourse, but your example the pattern matching succeeds on Bla _ a and then it checks the guard, but it should not match!
06:05:42 <Marvin--> BlitzNL: huh? come again?
06:05:48 <Marvin--> BlitzNL: please rephrase or something
06:05:51 <shapr> BlitzNL: you can have multiple guards
06:06:09 <Marvin--> BlitzNL: you can write   f p1 | e1 = e2 ; f p2 | e3 = e4 ...
06:06:35 <Marvin--> hmm, what's the layout rule for guards anyway?
06:06:45 <BlitzNL> Marvin--: ok you're absolutely right, it solves it thnx!
06:07:14 <Marvin--> BlitzNL: the fall-through property of guards is something I found very recently :)
06:07:21 <Marvin--> and boy is it neat
06:07:52 <wli> hmm
06:08:00 <BlitzNL> Marvin--: it sure is, now mapping from ML to Haskell is not that difficult after all
06:09:25 <wli> so I did data Mu x = Mu (x (Mu x)) ; type Nat = Mu Maybe and am trying to get to a sorting function with a proof of correctness encoded in its type ...
06:09:48 <wli> (using type classes)
06:10:20 <Marvin--> wli: sicko
06:13:24 <delYsid> Marvin--: ah, I was talkiing about remorse :)
06:14:10 <Marvin--> delYsid: aha
06:14:33 <Marvin--> delYsid: no, it never occurred to me to use it in a obfuscator, I need it to get unique naming
06:15:00 <Marvin--> hrrm, I can't find anything in the report about layout of guards
06:15:03 <delYsid> unique naming?
06:15:15 <delYsid> isn't that something the coder initially does?
06:15:45 <delYsid> hmm, efficienty question, the dsp lib defines the following, the commented version is what I think is "better"?
06:15:46 <delYsid> zn 0 a = a
06:15:46 <delYsid> zn n a = 0 : zn (n - 1) a
06:15:47 <delYsid> --zn n a = replicate n 0 ++ a
06:16:29 <wli> instance Enum Nat where
06:16:29 <wli>         toEnum 0 = Mu Nothing
06:16:29 <wli>         toEnum (n+1) = Mu . Just $ toEnum n
06:16:29 <wli>         fromEnum (Mu (Just n)) = 1 + fromEnum n
06:16:29 <wli>         fromEnum (Mu Nothing) = 0
06:16:43 <Marvin--> delYsid: not when I have flattened out all let:s to top level
06:17:16 <Marvin--> delYsid: I'd say  zn 0 a = a ; zn n a = zn (n-1) (0:a)  would be better than both
06:17:26 <Marvin--> delYsid: profile and see
06:17:50 <Marvin--> delYsid: generally  longlist ++ shortlist  should be avoided since it's O(length longlist)
06:18:21 <delYsid> ah yeah, I remember that ++ was expensive...
06:21:44 <Igloo> But the other definition will be just as expensive
06:22:04 <Marvin--> "the other"?
06:22:35 <Igloo> Oh, I think I'm misreading
06:23:01 <Marvin--> delYsid's both functions will probably be roughly equally expensive, mine is hopefully a bit better
06:23:44 <Igloo> No, yours will be the same as the replicate one, del's uncommented one will be better
06:24:00 <Igloo> Getting the first element of del's is a constant time operation
06:24:14 <Marvin--> oh, right
06:24:21 <Marvin--> it's all in what you need
06:24:53 <Marvin--> if you need the entire list fast, tail recursion is the way to go, otherwise not
06:27:19 * Igloo gets a reply from Ralf re gma[
06:28:28 <Marvin--> ...
06:28:31 <Marvin--> oh p
06:28:55 * Marvin-- had to remap the keyboard in his head to understand that
06:29:10 <Igloo> Heh - dvorak or just foreign?
06:29:20 <Marvin--> foreign
06:29:24 <Marvin--> Swedish
06:29:41 <Marvin--> I've got ] on altgr+9
06:30:32 <Igloo> Do you want a copy?
06:30:38 <Marvin--> yes, please
06:30:48 <Igloo> To where?  :-)
06:31:12 <wli> hmm
06:31:33 <wli> okay now I've got these maybe integers doing something useless
06:31:41 <Marvin--> Igloo: md9ms@mdstud.chalmers.se
06:33:09 <Igloo> Ah, the bug he talks about is why I couldn't use cast where I initially tried
06:34:43 <delYsid> wow, that DTMF module code is cool!
06:35:10 <Igloo> As in phone dialing?
06:35:25 <Vincenz> yes
06:35:31 <Vincenz> dual tone multiple frequency
06:36:19 <wli> instance Natable () where
06:36:19 <wli>         mkNat = const $ Mu Nothing
06:36:24 <wli> instance Natable t => Natable (Maybe t) where
06:36:24 <wli>         mkNat Nothing = Mu Nothing
06:36:24 <wli>         mkNat (Just x) = Mu . Just $ mkNat x
06:36:50 <wli> that could get interesting
06:37:11 <delYsid> Igloo: yup
06:37:19 <delYsid> sample module of the DSP librarty
06:37:54 <Igloo> Ah
06:38:44 <wli> that would actually be something more like a "less than or equal to N"
06:39:03 <Marvin--> Igloo: I still don't understand it :) but I'll keep reading it ;)
06:39:20 <Igloo> Marvin: Did you understand my original one?
06:40:00 <Cowgirl2> is this how u spell Potassium?
06:40:31 <Marvin--> Igloo: no :)
06:40:50 <shapr> Cowgirl2: yes
06:41:09 <Igloo> Hmmm, OK, I can try to explain if you want - which bit are you confused by?
06:41:50 <Cowgirl2> thank u :)
06:43:26 <o3> re
06:43:33 <Marvin--> Igloo: I have 60-70 lines of two sets of recursive functions right now, and they work, so... I think I'll pass for now
06:43:41 <Lilith> Guten Tag o3
06:43:43 <Igloo> OK  :-)
06:43:53 <o3> pseiko: sorry, i was away for a while.  you mentioned you're working on subtyping?
06:44:03 <o3> Lilith: how goes it?
06:44:56 <Lilith> o3: both good and bad
06:50:20 <pseiko> o3: hello again, no problem, I am adopting the nordlander approach
06:51:32 <o3> pseiko: what's the nordlander approach?  i'm working on an objective-c to haskell binding right now, and any papers on subtyping in haskell would come in very handy
06:51:57 <pseiko> i can give you the link, mom
06:52:25 <o3> thanks!
06:52:30 <pseiko> www.math.chalmers.se/~nordland/ohaskell/
06:53:14 <o3> ah, it's ohaskell
06:53:55 <pseiko> yup, you know about it already?
06:54:35 <o3> i haven't actually read the papers, stupidly enough
06:54:48 <o3> the "coolest" paper i've found so far is shields/peyton-jones
06:55:18 <pseiko> can you provide the link?
06:55:22 <o3> i'm not looking for full-blown subtyping, just a semi-decent way to model the objc oo hierachy (within ghc).  doesn't have to be complete
06:55:24 <o3> sure
06:55:49 * wli wants structural subtyping =(
06:56:03 <pseiko> i am interested in an even completer way of subtyping than nordlanders
06:56:07 <pseiko> :-)
06:56:35 <o3> http://research.microsoft.com/~simonpj/Papers/oo-haskell/index.htm
06:57:06 <pseiko> thank you, sorry, i have to go, see you later
06:57:30 <wli> class FromNat t where
06:57:30 <wli>         fromNat :: Nat -> t
06:57:33 <wli> instance FromNat () where
06:57:33 <wli>         fromNat = const ()
06:57:38 <wli> instance FromNat t => FromNat (Maybe t) where
06:57:39 <wli>         fromNat (Mu Nothing) = Nothing
06:57:39 <wli>         fromNat (Mu (Just n)) = Just $ fromNat n
07:01:31 * wli fails to converge to remotely useful code and runs off to do something else
07:31:43 <Marvin--> Ig-doh
07:36:02 <shapr> ?
07:36:34 <Marvin--> I was going to bite on his offer to explain the code, but now he's missing
07:37:39 <Segora> re
07:39:06 <shapr> hi Segora 
07:59:01 <peti> Good afternoon. :-)
08:03:45 <SyntaxPolice> how is everyone this morning?
08:03:59 <Smerdyakov> We're fine, SyntaxPolice.
08:04:16 * peti is waiting for the new Enterprise episodes to arrive. :-)
08:04:34 <peti> Anybody watching "Enterprise" here?
08:05:18 * SyntaxPolice loves star trek, but is without TV or time to watch TV
08:05:22 <Marvin--> peti: alas, yes
08:05:31 <Marvin--> SyntaxPolice: your time zone is broken :)
08:05:48 * peti hasn't seen anything since TNG.
08:05:56 <peti> So I am quite "hungry" for new Trek
08:06:11 <SyntaxPolice> peti: same here.
08:06:23 <SyntaxPolice> Marvin--: you mean because its not morning where you are?
08:06:24 <Marvin--> peti: I haven't seen TNG but VOY really sucked, and I haven't really heard good things about DS9
08:06:27 <Marvin--> SyntaxPolice: yes!
08:06:29 <peti> The good thing is that because I didn't watch DS9 or Voyager, I won't be bothered because Enterprise doesn't have any original scripts. I don't know them  anyway. :-)
08:06:34 <Marvin--> peti: not that I was that fond of TOS
08:07:14 <peti> Marvin: I have heard repeatedly that DS9 improved drastically by the third season. But I didn't watch it at the time, so I can't say.
08:07:29 <peti> Marvin: But apparently DS9 was the only Trek series ever to have an "arc". :-)
08:08:12 <Marvin--> peti: the way I heard it is that DS9 was Star Trek trying to be B5, and Crusade was B5 trying to be Star Trek - both failing miserably
08:08:49 <peti> Marvin: You're probably right. But I didn't see B5 either -- so I could actually watch DS9 and find it to be original, I guess. Just like with Enterprise. :-)
08:09:16 <Marvin--> peti: I simply loved B5 :)
08:09:39 * peti is a bit worried about T'Pol getting pon farr in this episode, though. I just hope it's not another Berman&Braga patented childish sex episode.
08:10:17 <Marvin--> peti: heh, I've seen that one
08:10:30 <peti> Marvin: Bounty? You saw it already?
08:10:49 <Marvin--> maybe I'm mixing it up with something else
08:11:12 <peti> Marvin: I guess you do. Bounty is brand new; it's airing officially tonight, I think.
08:11:21 <Marvin--> oh
08:11:50 <Marvin--> peti: then I'm probably confusing it with some other crap episode with T'Pol in
08:11:54 <shapr> hiiiii peti!
08:11:56 <peti> Marvin: Not that B&B didn't have a few childish sex episodes already, though. You probably refer to "A night in sickbay" ...
08:12:02 <Marvin--> peti: maybe
08:12:12 <Marvin--> peti: or all those silly detox scenes
08:12:16 <peti> Marvin: Or "Fusion", where they met these emotion-vulcans.
08:12:17 <shapr> peti: oh, I like Enterprise lots, except that the theme music makes me ill
08:12:33 <peti> shapr: Hey! I'm just writing up the posting on -libraries ...
08:12:36 <shapr> the ST:TNG,DS9, and Voyager themes are wonderful, but Enterprise.... no way
08:12:50 * peti kinda likes "Faith of heart".
08:13:17 <shapr> what's that?
08:13:18 <Marvin--> peti: my biggest bone with VOY and Enterprise though (I don't remember if TOS was as bad) is that some of them can be really good, simply beautiful for the first 39 minutes, and then they blow the whole story in the last minute
08:13:20 <peti> The problem with these "rock songs" is that they get boring once you've heard them a few dozen times. I think the orchestral themes were better in that regard.
08:13:42 <shapr> yah, orchestral themes can be timeless more easily than rock songs
08:13:46 <peti> shapr: The theme song of Enterprise? "Faith of the Heart", if I'm not mistaken.
08:14:18 <peti> Marvin: Yes, they use deux ex machine endings a lot.
08:14:28 <Marvin--> peti: no kiddin'
08:14:33 <peti> Marvin: Or dex ex Daniels / deux ex time travel for that matter. :-)
08:14:45 <peti> s/machine/machina/g
08:14:56 <shapr> oh, I didn't know its name
08:15:20 <Marvin--> in VOY every other episode ended with janeway-talks-to-everybody-and-everybody-get-on-with-their-lives-happily-and-peacefully
08:16:00 <Marvin--> ... and then there's all the stupid holodeck episodes
08:16:00 <peti> Marvin: From what I've been hearing, Janeway obliterated a few aliens during the course of their mission, though? I always read about her infamous "killing sprees"?
08:16:20 <peti> Ugh. Holo deckt episodes ... The perfect reset button for the lazy writer. :-*
08:16:50 <Marvin--> peti: oh yes, she gets a really bad reputation in the delta quadrant, not that her self-righteous american-way-of-life persona cares
08:17:09 <shapr> I still haven't found anything better than ST though
08:17:22 <Marvin--> shapr: I guess it depends on what you're looking for
08:17:25 <shapr> Andromeda(?) is good, but the sets and the actors aren't
08:17:29 <Marvin--> shapr: if you want a story arc, there's B5
08:17:37 <shapr> the plot and the interplay of Andromeda is great
08:17:49 <shapr> very strong characters, set up in a fascinating balance
08:17:52 <Marvin--> if you want aimless-flying-around-in-space-finding-another-alien-race-with-funky-heads, there's Star Trek
08:17:58 <peti> Hasn't Andromeda been cancelled in the U.S.?
08:18:13 <shapr> peti: I don't know, I generally order DVDs
08:18:28 <wli> star blech the next degradation
08:18:28 <peti> shapr: You must be earning good money then! :-)
08:18:42 <shapr> imho, the good point of Star Trek is the way it treats issues that are on the forefront of society
08:19:07 <shapr> I think it turns things inside out a lot
08:19:07 <Smerdyakov> Heh. I doubt it treats the _important_ issues.
08:19:09 <Marvin--> it does? where?
08:19:13 <peti> shapr: It's getting rare that they do, though.
08:19:16 <shapr> Smerdyakov: depends on what's important to you of course
08:19:19 <shapr> peti: yes, it's sad, but I agree
08:19:24 <peti> shapr: Mostly, Enterprise seems to be about nothing at all ...
08:19:28 <shapr> yah, that's true.
08:19:40 <shapr> I think that's what Gene Roddenberry did best
08:20:00 <shapr> he brought distant issues but pressing issues closer to the everyday people.
08:20:00 <Marvin--> peti: polarize the hull plating - 'cause we're too lazy to think of battle without shielded ships
08:20:01 <Smerdyakov> Has a Trek show _ever_ had an episode that brought the basic ideas of capitalism into question?
08:20:22 <shapr> Smerdyakov: not everyone is obsessed with capitalism et al ;-)
08:20:48 <peti> shapr: The times where TV would actually have something to say are over, I guess. The target demographic of  12-18 year old children fancies explosions and chicks in catsuits more than thought-provoking ethical dilemmas, I guess.
08:20:50 <Smerdyakov> No, but most of the world population thinks about these things "at the forefront" of their societies.
08:21:09 <Marvin--> peti: chicks in catsuits, oooh
08:21:20 <peti> Wasn't TOS the first TV series ever to utter a "damn" on screen? :-)
08:21:25 <Smerdyakov> peti, what's the problem? People who want to think have always read books, anyway.
08:21:35 <shapr> and the first series to have a black actress as one of the main characters?
08:21:47 <Marvin--> yes, TOS had a point
08:21:49 <Marvin--> VOY sure doesn't
08:22:08 <shapr> even so, that point is still sometimes found in the Star Trek series
08:22:42 <Marvin--> indeed, they're not very inventive
08:22:47 <peti> Smerdyakov: True ... but I don't think that books are intrinsically worth more than TV (or movies). If you can put those other senses to work, why don't do it? A story can be smart, entertaining and great to watch at the same time.
08:23:12 <shapr> yah, limit your input according to quality, not media ;-)
08:23:35 <shapr> that's a lesson I had to learn...
08:23:49 <shapr> I used to think only books were provoking and/or stimulating
08:23:50 * peti for one is sure looking forward to seeing "The Matrix Reloaded". That is going to be one thought-provoking movie ... *grin*
08:23:54 <shapr> heheh
08:24:12 <Marvin--> peti: I thought it was chick-in-catsuit reloaded
08:24:36 <peti> Marvin: No ... you're _way_ off on this one. It's chicks in spandex! Not catsuits.
08:25:04 <Lilith> vinyl!
08:25:38 <Marvin--> peti: details, details
08:25:50 <peti> Well, let them showcase their actresses ... I don't mind at all. Let's just hope it's _more_ than just stylish clothes.
08:26:30 <Marvin--> you mean like the first one? ;)
08:26:37 <Lilith> peti: apparently, the movie is supposed to be imbued with religious undertones
08:26:45 <Marvin--> Lilith: the first one is too
08:26:51 <peti> Marvin: I thought that "The Matrix" was one _excellent_ movie.
08:27:10 <peti> Marvin: I have no idea how often I watched it, but it must have been at least 15 times by now.
08:27:19 <Marvin--> peti: I didn't, but then, I've never been big on the conspiracy theme
08:27:44 <Marvin--> I saw Fight Club again the other week, now *that* is one good movie
08:27:49 <peti> By the way, if you ever want to see a really stylish movie, which is not that well-known, unfortunately, get a copy of "Lola Rennt".
08:27:59 <Marvin--> the name rings a bell
08:28:17 <peti> Marvin: It's a german low-budget production, but the film is awesome.
08:28:35 <peti> Marvin: The soundtrack ruled the charts word-wide for several weeks.
08:28:46 * wli takes the rope away from Smerdyakov
08:28:55 * wli owns Lola Rennt on DVD
08:29:11 <Marvin--> peti: that doesn't mean a lot to me, since I rarely listen to chart music
08:29:13 <peti> Marvin: Fight Club is amazing, too, though. It did cost the boss of the studio his job, though. :-)
08:29:36 <o3> peti: it did?  how so?
08:29:53 <peti> Marvin: If you ever have the chance ... Just see it. It's really energetic and flimed extremely well. They made up for their small bugdet with _lots_ of good ideas, and the result is amazing.
08:29:55 <Lilith> peti: it has nothing to do with run lola run, has it?
08:29:58 <Smerdyakov> wli, rope?
08:30:19 <peti> Lilith: Yet, that's the same. "Lola Rennt" is just the (original) german title.
08:30:33 <Lilith> ah :-)
08:30:48 <o3> Lilith: that's recommended by manuel too
08:30:54 <Lilith> it's somewhat like sliding doors
08:30:56 <peti> I would avoid the dubbed version at all costs, though. :-) Better watch it in German.
08:31:07 <Lilith> peti: yeah. i watched it in german
08:31:10 <wli> Smerdyakov: watch out for old Fyodor =)
08:31:17 <Lilith> o3: what is? run lola run?
08:31:28 <shapr> isn't Fyodor one of those russian authors?
08:31:37 <wli> well
08:31:55 <wli> I had in mind Fyodor Karamazov
08:32:03 * shapr laughs
08:32:28 <Marvin--> peti: it did? because of the ... scene in the end?
08:33:00 <peti> Marvin: Sorry ... I'm not sure I understand the question.
08:33:07 <Lilith> o3: going to the matrix reloaded premier?
08:33:17 <Marvin--> peti: <peti> ... It did cost the boss of the studio his job, though. :-)
08:33:37 <shapr> didn't that other fyodor write war and peace?
08:33:40 <Smerdyakov> wli, Fyodor Karamazov was killed. He didn't do no killin'.
08:33:46 <shapr> umm, dostoyevsky or something
08:33:51 <o3> Lilith: yep, and nope (thesis due soon!)
08:33:57 <o3> actually ...
08:33:58 <Smerdyakov> shapr, I'm crushink your head.
08:34:02 <o3> when's the reloaded premiere? :)
08:34:03 <Lilith> heh
08:34:07 <Lilith> that's reminds me 
08:34:12 <Lilith> o3: tomorrow night!
08:34:14 <shapr> Smerdyakov: heh, you realized I'm teasing you, eh? ;-)
08:34:19 <Smerdyakov> shapr, I'm crushink your head.
08:34:19 <wli> Smerdyakov: and what did he do while alive?
08:34:23 * shapr laughs
08:34:31 <Smerdyakov> wli, wine, women, and song?
08:34:36 <peti> Marvin: Ah ... Apparently Murdoch (who owned the studio) was opposed to "Fight Club" very much and the boss of the studio kept most of the production etc. secret from him. When Murdoch found out the film was produced after all, he told the guy "this one will better make 100+ million of you're out of job".
08:34:39 <Lilith> o3: i bet i'll see a lot of people in black :-)
08:34:46 <Smerdyakov> wli, it's been a while since I read the book =)
08:34:47 <Marvin--> shapr: no, dostoyevsky didn't write war and peace, Tolstoy did
08:34:52 <shapr> Marvin--: I know, I know
08:34:57 <shapr> I was teasing Smerdyakov :-)
08:35:02 <peti> Marvin: Unfortunately, Fight Club was no commercial success at all ... so the guy was thrown out.
08:35:07 <Marvin--> peti: heh
08:35:11 <Marvin--> shapr: oh
08:35:20 <peti> Marvin: He said later, he'd do it all over again, though. The film was worth it.
08:35:20 <wli> it wasn't a commercial success?
08:35:28 * peti agrees with him.
08:35:31 <Marvin--> peti: :)
08:35:37 <shapr> I still haven't seen Fight Club
08:35:44 <Marvin--> shapr: !
08:35:51 <shapr> I loved "The Shawshank Redemption"
08:35:53 <shapr> that was awesome
08:35:53 <peti> wli: No, not at all. Barely brought back the costs for production.
08:36:22 <Marvin--> shapr: You need to see Fight Club. And then you should see Fight Club.
08:36:24 <shapr> I bet the studio makes lots of money off of Fight Club from the right/royalties/etc
08:36:29 <Marvin--> shapr: (two totally different movies)
08:36:29 <shapr> I may see it this weekend
08:36:39 <peti> Marvin: Don't talk about it. *grin*
08:36:39 <shapr> Bea is going to Germany tomorrow
08:36:48 <o3> Lilith: well, i'm definitely not going to see the premiere -- running out of time for thesis.  if things are better on the weekend, maybe i'll go see it then
08:36:50 <shapr> So I'll have the weekend to hack and watch movies
08:37:00 <o3> Marvin--: oi!  the first rule of fight club is ...
08:37:01 <shapr> peti: hey, are you near Erlangen?
08:37:08 <Marvin--> o3: heh
08:37:28 <peti> shapr: Not really. I live in Berlin, that's about 300 - 400 km north of Erlangen, if I remember correcly.
08:37:31 <shapr> hm, I think you told me which part of .de but I've forgotten.
08:37:33 <shapr> ah, Berlin
08:37:43 <Marvin--> well, I'm off to play D&D
08:37:45 <peti> shapr: The only place to be in Germany. :-)
08:37:47 <shapr> Bea is going to Munich and Erlangen
08:37:49 <Marvin--> have a good evening, people
08:37:52 <shapr> I had fun last time I was in Munich
08:37:54 <peti> With the possible exception of the Rheinland, of course.
08:37:59 <shapr> though I didn't get to see Chicks on Speed :-(
08:38:48 <peti> shapr: You should come to Berlin, if at all possible. If you like to go out, then Berlin will beat Munich (and Hamburg, and Cologne)  by a mile.
08:39:00 <peti> shapr: Also, living here is quite cheap, compared to other big cities.
08:39:18 <peti> shapr: Where do you live? Was it Norway?
08:39:38 <shapr> nah, Sweden
08:39:50 <peti> shapr: Where in Sweden?
08:39:58 <shapr> way north
08:40:02 <shapr> 800km north of Stockholm
08:40:12 <shapr> I lived in Seattle for six months, that was expensive
08:40:18 <peti> shapr: Ok, then I won't know the place anyway. :-)
08:40:34 <peti> shapr: Isn't Sweden the place with those enormous taxes?
08:40:43 <shapr> yes, very much so 
08:40:49 <shapr> but it makes up for it
08:41:06 <Marvin--> peti: heh, I misread that as "Where is Sweden?" and was about to beat you up :P
08:41:19 <peti> Marvin: *hehe*
08:41:34 <peti> Marvin: Hey, I know my european union ... *grin*
08:41:44 <Marvin--> peti: so you don't know Norway? :)
08:41:53 <shapr> I still wish Sweden had the Euro
08:41:54 <peti> Marvin: What's that? :-)
08:42:12 <Marvin--> shapr: quick! become Swedish before the vote!
08:42:33 * peti wishes the whole bloody continent would finally get their act together and unite.
08:43:15 * Smerdyakov wishes the whole bloody world would get together and unite against money. :-)
08:43:26 <Marvin--> Smerdyakov: commie :)
08:43:39 <peti> Smerdyakov: I doubt we'll see that happen any time soon. :-(
08:44:00 <shapr> Smerdyakov: see, you like Star Trek more than you know
08:44:47 <peti> Let's found a country where all computer software must be open source and written in Haskell. :-)
08:45:00 <Marvin--> peti: eew
08:45:04 <wli> well
08:45:12 <Smerdyakov> shapr, OK!
08:45:35 <Marvin--> hmm, now where did I put my dice
08:45:40 <Lilith> peti: not possible i think. 
08:45:56 <peti> Lilith: Probably not ...
08:46:00 <Marvin--> ah, there, under a pile of crap on the desk
08:46:06 <Lilith> operating systems can't be written in haskell
08:46:23 <shapr> yes they can
08:46:34 <shapr> they'd just be reallllly slow!
08:46:34 <peti> Lillith: At least not completely. But I am sure a hybrid Haskell/C OS could work just fine.
08:46:39 <Lilith> with automatic garbage collection?
08:46:41 <wli> I was about to mention that
08:46:58 <wli> automatic garbage collection and implicit allocations nail you hard
08:46:58 <shapr> what about a Haskell assembler?
08:47:15 <Marvin--> well, now I'm off *waves*
08:47:39 <peti> How about a micro kernel OS? The kernel itself would be C (or C++) and the rest would be written in Haskell. That should work.
08:47:48 <Lilith> hmm
08:47:50 <Smerdyakov> wli, well, if you count Haskell prorgrams you write now as being "in Haskell" even with a C runtime system, then what's the problem?
08:48:10 <Lilith> peti: take L4, and the write the rest in haskell?
08:48:24 <peti> Lilith: What's 'L4'?
08:48:26 <wli> smerdyakov: doesn't work that way
08:48:32 <shapr> I wonder how you could run the STG on raw hardware
08:48:32 <Lilith> peti: microkernel
08:48:39 <Lilith> hmm
08:48:42 <shapr> does the STG allow for parallelization?
08:48:55 <peti> Lilith: Never heard of it, sorry. I only know Mach ...
08:49:01 <shapr> could an STG running on raw hardware partition the tasks out to multiple CPUs?
08:49:05 <Lilith> anyhow, it's  just not possible for *all* software to be written in haskell
08:49:23 <Smerdyakov> wli, why not?
08:49:55 <peti> Lillith: It might not be possible today, but there's no reason why Haskell could not evolve in a way that would make that possible.
08:50:04 <Lilith> i guess
08:50:09 <shapr> what are the primary fpimplementation schemes? STG... graph reduction?
08:50:17 <Lilith> they'd be like the lisp machines, in that case?
08:50:25 <peti> Lilith: Even today you have pretty much low-level control over your resources, if you use 'Ptr a' and friends.
08:50:34 <wli> smerdyakov: in a kernel you've got situations where (1) memory allocation can fail (2) you cannot allocate memory b/c you may block (3) there's buttloads of manipulation of raw memory in ways that would horrify userspace programmers
08:50:39 <shapr> I can't think of any others..
08:50:42 <Lilith> ugh
08:50:45 <wli> for instance
08:50:46 * Lilith shudders
08:50:49 <wli> editing pte's on the fly
08:50:54 <shapr> what's a PTE?
08:51:08 <Lilith> Page Table Entry?
08:51:16 <wli> randomly sprinkling data you have to get at in assembly across things
08:51:18 <Smerdyakov> wli, that can be part of the runtime system....
08:51:19 <wli> bounded stacks
08:51:20 <Lilith> </hazards>
08:51:30 <wli> PTE == Page Table Entry
08:51:38 <wli> on i386 they matter, anyway
08:51:56 <shapr> does haskell have an out of memory exception?
08:52:01 <wli> sane arches they don't but clearly sane arches are dead
08:52:06 <shapr> what happens when you do run out of memory?
08:52:18 <wli> you do get an exception
08:52:20 <Lilith> wli: i don't think STG/Haskell can run purely on current machines
08:52:28 <peti> Maybe a whole OS is a bit much to ask for. I'd be _very_ happy if there'd be an "hemacs", which would use Haskell instead of Elisp ...
08:52:33 <shapr> peti: me too
08:52:39 <shapr> there's already some code to support that
08:52:47 <shapr> Michael Sperber did the elisp to scheme translation code
08:52:47 <peti> shapr: You're kidding?
08:52:49 <wli> thing is you need very deterministic error handling
08:52:58 <shapr> and Ashley Yakeley wrote HScheme, which is a scheme written in Haskell
08:53:13 <shapr> also, there XEmacs to Haskell connective it the UniForM workbench
08:53:33 <shapr> UniForM is more well known for the Haskell to Tk bindings, HTk
08:53:39 <peti> shapr: Oh, I didn't know that.
08:54:02 <shapr> sadly, it uses XEmacs extents, which are not portable to Gnumacs
08:54:18 <peti> By the way: Is there any effort to translate Haskell sources into, say, C++ source code? I guess you could do that pretty well ...
08:54:18 <wli> erm
08:54:25 <wli> why not just make it Haskell from the ground up?
08:54:41 <shapr> wli: an editor? or an OS?
08:54:42 <peti> wli: You mean, write the whole editor in Haskell?
08:55:28 <wli> peti: No reason to bother. Spew a stack language or 3-address code out the back end and it's trivial to translate that to C, or with more intelligence you can use it as an IR and spit out asm
08:55:29 <shapr> it would be nice to take advantage of all the elisp code that exists
08:55:36 <wli> peti: yes
08:55:45 <shapr> on the other hand, some major improvements over emacs could be done...
08:55:57 <shapr> for example, an editor that uses ASTs as its native format
08:55:58 <Smerdyakov> I think thinking of such a thing as "an editor" is foolhardy. It should be a complete GUI system to replace XWindows (or maybe work within it), without any attention to maintaining 'nostalgic' yet crufty emacs-isms.
08:55:58 <wli> shapr: well, I was thinking vi
08:56:29 <shapr> so that scripts would be able to operate on multiple languages, since they'd all have a tree representation.
08:56:55 <shapr> of course, in that case you're running into a generic refactoring framework built into an editor
08:57:07 <shapr> that would fix every syntax highlight problem emacs/vi has ever had :-)
08:57:13 <Smerdyakov> Why "an editor"??
08:57:26 <Smerdyakov> Why should the mechanism of extension be limited to "an editor"?
08:57:37 <peti> wli: I would assume that a high-level translation to C++ would be much more effecient, because the compiler can perform better optimizations.
08:57:40 <wli> I just want a less stupid vi that I can stand to look at b/c my wants/needs are limited.
08:58:23 <wli> peti: not really, you have no way of getting there apart from the usual back-end mechanisms
08:59:04 <peti> wli: You're sure? I think that using boost::function, boost::bind and templates you could translate Haskell source to C++ source almost one-to-one.
08:59:20 <wli> not even close
08:59:27 <peti> wli: At least I have been doing that manually, when using Haskell to prototype code to be implemented in C++ later.
09:00:06 <wli> my Haskell code doesn't look much like C++
09:00:23 <Smerdyakov> peti, why are you writing the final versions in C++?
09:00:40 <wli> instance Integral t => Stack (RWS () [ROp] (t, [t])) where
09:00:40 <wli>         pushVal n = do
09:00:40 <wli>                                         (ctr, stk) <- get
09:00:40 <wli>                                         put (ctr, fromIntegral n : stk)
09:00:40 <wli>         popVal = do
09:00:41 <wli>                                         (ctr, top:stk) <- get
09:00:43 <wli>                                         put (ctr, stk)
09:00:45 <wli>                                         return (fromIntegral top)
09:00:47 <wli>         push n = do
09:00:49 <wli>                                 (ctr, stk) <- get
09:00:51 <wli>                                 put (ctr, stk!!fromIntegral n : stk)
09:00:53 <wli> and so on
09:01:02 <peti> wli: Mine neither, but the mechanisms are pretty much the same. In C++, functions are first-order citizens, and templates and overloading can represent the type system _almost_ completely.
09:01:19 <peti> Smerdyakov: Because people won't pay you for Haskell code. :-(
09:01:32 <Smerdyakov> peti, and you are using some crufty way of getting closured in C++?
09:01:36 <Smerdyakov> closures
09:02:03 <wli> I'm guessing neither closures nor laziness are made essential use of
09:02:30 <Smerdyakov> peti, and no one will pay you for ML code, either?
09:02:35 <peti> Smerdyakov: There are various libabries that implement closures in C++ template code, such as LL, Phoenix, and whatever else there is.
09:03:24 <wli> well
09:03:30 <wli> since you can overload ()
09:03:50 <wli> there are tricks you can play
09:03:53 <peti> Smerdyakov: If the rest of the system is written in C (or C++), they want their libraries written in the same language ...
09:04:12 <peti> Smerdyakov: And you can actually simulate lazy evaluation using proxy classes in C++.
09:04:21 <peti> By the way ....
09:04:40 <wli> and higher-order types?
09:04:48 <wli> multiparameter type classes?
09:04:50 <Smerdyakov> This sounds like the problem is that you are working for people who have the rest of their system written in C (or C++). =)
09:05:21 <wli> I'm doing outright kernel hacking so prototyping in Haskell isn't even feasible
09:05:29 <peti> wli: That's going to be interesting. You can simulate that, if you want to, but you don't really want to because C++ won't type-check that very well.
09:05:49 <wli> I basically use Haskell instead of perl b/c perl is disgusting
09:06:09 * Smerdyakov is disgusted by so many people making new OS's.
09:06:14 <peti> wli: multi-parameter type classes are just templates. That's no problem.
09:06:38 <wli> not quite
09:06:59 <peti> wli: Where's the problem?
09:07:02 <wli> Smerdyakov: I do that too but I don't get so worked up about it. I hack on the Linux kernel for $$
09:07:13 <delYsid> cute
09:07:42 <Smerdyakov> wli, oh. You're happy with that job?
09:07:52 <delYsid> http://lexx.delysid.org/Pascal.hs
09:08:24 <peti> wli, Smerdyakov: Don't get me wrong ... It's not like I enjoy writing in C++. That's why I'd like some automated translator. :-)
09:09:06 <wli> Smerdyakov: yep, it's interesting and IBM gives me relatively large boxen to hack on
09:10:00 <Smerdyakov> Hm. I'm expecting I'll prefer being a PhD student to that, but we'll see. =)
09:10:12 <wli> Smerdyakov: e.g. I got first post on 64GB x86, hack on 16x/32x boxen all the time
09:10:51 <Smerdyakov> wli, OK. I geuss these big numbers satisfy some kind of primal urge for you?
09:11:00 <wli> yep
09:11:01 <peti> My guess is that it will be another 5 years before Haskell (or something similar) makes it into the industry. :-( Other languages, like C++, took that long to "mature" as well.
09:11:22 <Smerdyakov> peti, that sounds right. Tjat
09:11:32 <Smerdyakov> That's about how long until my PhD dissertation is done ;-)
09:11:42 <peti> Smerdyakov: Good timing. :-)
09:11:56 <Smerdyakov> Oh, it will be no coincidence!
09:12:13 <wli> peti: no idea what you mean, I'm using it all the time and I'm in industry
09:12:41 <peti> ** Press release: 2008-05-14, Haskell and Smerdyakov join the industry simultaneously! :-)
09:13:05 <peti> wli: I mean before it will be known (and used) in the industry on a "large scale", like C/C++ are used today.
09:13:12 <wli> plenty of log parsing, collecting data from kernel reporting stuff, fishing around through kernel source looking for patterns of bugs, etc. to do
09:13:28 <wli> peti: perl isn't and it's vaguely popular
09:14:28 <wli> peti: big apps written in Haskell or anything I'll never be in tune with as long as I'm hacking the kernel. Haskell would be good there, too, though.
09:15:27 <peti> wli: The point is that today's software could be written in Haskell, it's just that people don't do it. The vast majority of professional programmers don't even know Haskell exists. Most have no idea about functional programming whatsoever!
09:15:47 <peti> At least that's my impression.
09:16:30 <wli> peti: the majority don't need to ever be taught; the point of more effective tools is wiping out the need for such armies of programmers in favor of far fewer skilled ones
09:17:31 <peti> wli: IMHO knowledge of functional programming and some CS theory is invaluable for designing any software whatsoever. People could benefit from that knowledge a lot ... if they had it.
09:17:44 <o3> wli: i completely disagree
09:18:12 <o3> hmm, shouldn't have said anything.  don't have time right now to get into such a debate :)
09:18:31 <wli> well, it's my notion of how they make the world more efficient
09:20:17 <peti> Alright ... The first E episode is there. Gotta watch "First Flight" now. :-)
09:37:54 <delYsid> is there a zipWith which does id on excessive elements?
09:38:23 <delYsid> i.e. zipSomehow (+) [1] [] -- [1]
09:38:25 <delYsid> ?
09:39:08 <delYsid> guess not.
09:41:33 <wli> delYsid: easiest to sim with FM code and addToFM_C
09:41:57 <delYsid> huh?
09:42:08 <delYsid> I have
09:42:08 <delYsid> addRows (a:x) (b:y) = a+b : addRows x y
09:42:08 <delYsid> addRows [a]   []    =  [a]
09:42:08 <delYsid> addRows []    []    =  []
09:42:29 <wli> okay that's the way to do it by writing it out =)
09:42:55 <delYsid> and I thought zipWith would basicly do the same, except for that shortest-list wins rule
09:43:36 * wli ponders writing a Haskell-based spamassassin
09:44:36 <shapr> wli: there's a bayesian spam filter in haskell-libs
09:44:42 <shapr> libs/email/paskalle
09:44:49 * shapr disappears for a few hours
09:44:50 <wli> already done, then
09:45:03 <shapr> wli: actually, mine sucks, wanna fix it? ;-)
09:45:07 <shapr> it only gets 85%
09:45:20 <wli> shapr: should mostly be training
10:09:24 <ludde> what does the ... operator do
10:09:49 <delYsid> ...?
10:10:01 <delYsid> never saw that
10:10:05 <wli> you mean .. ?
10:10:17 <wli> like [0..] ?
10:10:19 <ludde> no, three dots.
10:10:23 <ludde> it's in a paper
10:10:29 <ludde> maybe it means "put stuff here later"
10:10:48 <pseiko> or it is defined in an extra module
10:11:54 <Igloo> It probably means "large, boring stuff omitted"
10:17:35 <wli> gerrit: basically what happens is the truncate operation fails to wipe some of the ptes and the already racy app sees state file contents.
10:17:41 <wli> er
10:49:59 <delYsid> shapr: I fear I killed lambdabot
10:54:38 <Vincenz> heh, I've done that before too :P
11:09:04 <Cowgirl> n
11:45:29 <tmoertel> @prelude mzero
11:46:30 * Riastradh points at the lack of lambdabot.
11:47:44 * tmoertel looks at vacuousness
14:15:00 <shapr> delYsid: how did you kill lambdabot?
14:15:05 <shapr> lambdabot segfaulted
14:16:22 <shapr> hi Verbed 
14:16:34 <Verbed> Hello
14:16:39 <shapr> Verbed: learning Haskell?
14:16:53 <shapr> long time user?
14:17:19 <Verbed> I'm at the moment reading various introductions :)
14:17:29 <shapr> Do you have any questions?
14:17:40 <shapr> tmoertel: lambdabot has returned
14:17:46 <shapr> @prelude mzero
14:17:48 <lambdabot> *** "mzero" prelude "Haskell Standard Prelude Dictionary": text follows
14:17:48 <lambdabot> mzero
14:17:48 <lambdabot>   class Monad m => MonadPlus m where
14:17:48 <lambdabot>     mzero ::  m a
14:17:52 <Verbed> None at the moment, I just wanted to observe any conversations that might be occuring
14:17:52 <lambdabot>   instance MonadPlus Maybe where
14:17:52 <lambdabot>     mzero              = Nothing
14:17:53 <lambdabot>   instance MonadPlus [ ] where
14:17:55 <lambdabot>     mzero = []
14:17:58 <lambdabot> [there's @more]
14:18:10 <Verbed> I was also curious as to how many people would be in here.
14:18:21 <Verbed> More than #ocaml!
14:18:27 <shapr> Verbed: nothing's happening at the moment, most of the activity here happens during european afternoon and evening
14:18:39 <Vincenz> yup
14:18:41 <Vincenz> Europe rules
14:19:05 <shapr> Verbed: #haskell hasn't gotten over sixty people at a time yet, but we're steadily gaining new people.
14:19:14 <shapr> we have some very cool discussions here.
14:20:11 <shapr> Verbed: the url for the logs is in the topic if you want to look at the archives of our discussions.
14:20:33 <Verbed> Thanks
14:22:17 <shapr> Verbed: also, there's a Wiki called the HaWiki ( http://www.haskell.org/hawiki/RecentChanges ) a sourceforge project that lots of #haskell people use for a cvs-wiki ( http://sf.net/projects/haskell-libs/ ) and various mailing lists.
14:23:03 <Verbed> shapr: I'm there already :)
14:23:33 <Verbed> I followed all the links in the topic shortly after joining.
14:23:37 <shapr> spiffy!
14:23:46 <shapr> have you come up with any questions since joining? :-)
14:24:20 <Verbed> Yes.. Have you checked your blood sugar level recently? :P
14:24:30 <shapr> why, do I sound manic? :-P
14:24:57 <Verbed> Hmm.. "pleasantly enthusiastic"
14:25:02 <shapr> heheh
14:25:17 <shapr> this is mild, I get lots worse ;-)
14:25:52 <shapr> Though I have a decent reason now, I did my first paying Haskell work this last weekend.
14:26:01 * shapr bounces ecstatically
14:26:06 <grem> getaline :: (forall s.ST s (STRef s [a])) -> (a,[a])    is there anything wrong with this line?
14:26:25 <juhp> shapr: really
14:26:26 <shapr> I don't really understand forall, so I'm not sure.
14:26:32 <shapr> hiii juhp!
14:26:39 <shapr> juhp: how's the irc client?
14:26:42 <juhp> hey
14:27:04 <shapr> juhp: yes, my job was to turn the content of some ms.doc files into a custom XML flavor
14:27:16 <shapr> rather than doing manual editing, I used HxmlToolbox
14:27:23 <juhp> shapr: coming along thanks - hopefully get a release out today :)
14:27:30 <shapr> via the openoffice native XML format
14:27:33 <shapr> cool!
14:27:41 <juhp> nice
14:28:40 <shapr> you think there will be any useful changes we can merge into lambdabot?
14:28:54 <shapr> grem: are you getting an error?
14:29:05 <juhp> shapr: well I hope so
14:29:40 <grem> shapr: 
14:30:07 <Segora> shapr:/tmp/foo.hs:3: parse error on input `.'
14:30:18 <grem> shapr: yes, a parse error on input `.`
14:30:24 <shapr> that doesn't help much.
14:30:32 <shapr> err
14:30:38 <Segora> let's see. I am not aware of the correct syntex for quantification
14:30:42 <shapr> doesn't the dot come directly after the forall ?
14:30:45 * shapr looks
14:31:26 <shapr> grem: this is from the lambdabot sources "data ModuleState = forall a. (Typeable a) => ModuleState a"
14:31:39 <shapr> but that's not a type signature
14:32:23 <juhp> perhaps the biggest change i made to the IRC module was splitting IRCMessage's msgParams field into a field for the middle params and one for the tail params (ie the stuff after the first leading colon)
14:32:46 <juhp> that makes quite a few things cleaner...
14:33:13 <shapr> cool, I can barely wait to see it.
14:33:28 <grem> shapr: so wouldnt that be correct?
14:33:56 <grem> getaline :: (forall s.ST s (STRef s [a])) -> (a,[a])
14:34:07 <Segora> grem: did you use -fglasgow-exts ?
14:34:15 <grem> Segora: no
14:34:31 <Segora> haskell 98 has no syntax for universal quantification
14:34:51 <grem> Segora: oh, ok
14:35:04 <Segora> (see The Report, 4.1.2 Syntax of Types)
14:36:56 <shapr> juhp: I'll look into doing multiple servers with lambdabot, would that be helpful for your irc client?
14:37:15 <juhp> shapr: definitely :)
14:37:44 <shapr> anything else?
14:38:06 <juhp> that would be really useful - certainly something I want for Hircules
14:38:15 <shapr> heh, good name
14:38:30 <juhp> there's also auto-reconnection
14:38:33 <shapr> yah, good point
14:39:06 * shapr adds those to the TODO list
14:39:15 <juhp> I think it would be really good of a nice clean IRC library could be factored out
14:39:29 <juhp> s/of/if/
14:39:54 <shapr> I agree, though I'm not sure where to begin on that...
14:39:55 <Segora> grem: I'm curious, what should the function 'getaline' do? As far as I can see from its type, it will return the same line in every call (assuming you don't modify the input state elsewhere) because it cannot change the state.
14:40:59 <juhp> shapr: right - perhaps taking out common stuff from lambdabot and hircules could be a starting point
14:41:37 <Segora> happy refactoring :)
14:42:54 <Smerdyakov> shapr, oh, I just looked up and saw: data ModuleState = forall a. (Typeable a) => ModuleState a
14:43:00 <Smerdyakov> shapr, isn't the forall unnecessary there?
14:43:46 <Segora> Well, time to go home... Bye. [off console]
14:44:39 <shapr> Marvin--: d00d, it's midnight in sweden, you should be asleep.
14:45:06 <shapr> Smerdyakov: I don't know, I don't really understand forall
14:45:19 <shapr> juhp: that's a good point
14:45:21 <Marvin--> shapr: and you shouldn't?
14:45:24 <Marvin--> shapr: I just came home
14:45:26 <shapr> Marvin--: shhh!
14:45:28 <Smerdyakov> All type variables outside forall's/exist's/etc. are implicitly universally quantified over the whole type, I think.
14:45:30 * shapr looks furtive
14:45:45 * Riastradh furtively looks.
14:45:49 <shapr> hi Riastradh 
14:45:50 <Riastradh> [at shapr]
14:45:59 <Riastradh> Hi?  I've been here for hours.
14:46:00 <shapr> looks like it might be a lambdabot weekend.
14:46:16 <Riastradh> For me it'll be an OCaml weekend.
14:46:27 <shapr> how's your game going?
14:46:34 <Riastradh> I'm missing typeclasses and typeclass constraints very much in OCaml.
14:46:36 <Riastradh> Somewhat well.
14:46:52 <Riastradh> I just started last week, so it hasn't progressed very far; but the backend is almost complete now.
14:47:09 <shapr> Marvin--: meet any nasty monsters?
14:47:33 <shapr> @yow
14:47:34 <lambdabot> Why is it that when you DIE, you can't take your
14:47:34 <lambdabot>  HOME ENTERTAINMENT CENTER with you??
14:47:44 * shapr swaps the bot to another yow file
14:47:54 <Marvin--> shapr: just a two-headed giant (that we met the previous session too), two trolls or ogres or something
14:48:01 <shapr> kill anything?
14:48:10 <Marvin--> shapr: and an angry mob of villagers with torches and pitchforks *cough*
14:48:41 <Marvin--> we killed the trolls, and unfortunately about half the villagers in the mob (about 20 people all in all)
14:48:58 <shapr> are you guys lawful evil or something?
14:49:07 <Marvin--> oh yeah, we ran into some orcs and the silly clerics talked us past them
14:49:21 <Marvin--> shapr: no, not at all... the situation is kinda complicated
14:49:49 <Marvin--> shapr: the troll actually turned out to be a human cleric under a curse... he controls one of the two heads, so he's in control while the other head is sleeping
14:49:53 * juhp finishes cleaning his mouse ;)
14:50:12 <shapr> I cleaned a cat once, wasn't much fun.
14:50:13 <Marvin--> shapr: alas, the evil head had killed the sheriff of the village and his son was kinda...mad, and was the leader of the mob...
14:50:56 <shapr> if I were the cursed cleric, I'd walk into the wilderness
14:51:16 <shapr> lambdabot: @quit
14:51:18 <Riastradh> shapr - People claim that cats really hate being bathed, but mine doesn't seem to mind -- in fact, he quite likes it.  The only problem is that when I'm finished, my tongue is covered with fur.
14:51:19 <Marvin--> the cursed cleric was a coward (whoops, in character)
14:51:33 <SyntaxPolice> Riastradh: lol
14:51:34 <Marvin--> Riastradh: eeew
14:51:40 <shapr> Riastradh: heheh
14:51:44 <Marvin--> Riastradh: *you* are not supposed to lick it, they do that themselves
14:52:03 <shapr> Riastradh: new @yow file
14:52:13 <shapr> @yow
14:52:14 <Riastradh> @yow , tongue-bathing!
14:52:15 <lambdabot> Is something VIOLENT going to happen to a GARBAGE CAN?
14:52:15 <lambdabot> Impudent..  Yet possessing a certain ALUMINUM SILICATE
14:52:15 <lambdabot>  overbite....Needs REDDY-WHIP!!
14:52:39 <shapr> @yow
14:52:40 <lambdabot> PUNK ROCK!!  DISCO DUCK!!  BIRTH CONTROL!!
14:53:09 <shapr> now lambdabot is using the XEmacs yow.lines
14:54:33 <Marvin--> gotta hate those angry mobs with torches and pitchforks
14:54:46 <Marvin--> oh well, that's where a heavy warhorse comes in handy
14:54:48 <Marvin--> trample
14:54:49 <Riastradh> Marvin--, what is this thing about which you are speaking?
14:54:59 <Marvin--> Riastradh: I just came home from a D&D session
14:55:09 <Riastradh> Oh, silly D&D.
14:59:54 <grem> Marvin--: D&D eh?  Have a good DM?
15:00:57 * SyntaxPolice prepares for The Matrix II tonight :)
15:01:13 <grem> SyntaxPolice: opens at 12 am?
15:02:05 <Riastradh> SyntaxPolice, beware of Smerdyakov when mentioning anything related to The Matrix!
15:02:29 <SyntaxPolice> grem: no I think its at 10:00. its some sort of "advanced" thing I think.
15:02:41 * SyntaxPolice runs away
15:02:47 <Riastradh> 2200 today or 1000 tomorrow?
15:02:55 <SyntaxPolice> 2200 today
15:02:57 <grem> SyntaxPolice: ah, i won't get to see it till monday :(
15:03:25 <Marvin--> grem: only had two sessions yet, but yeah it's working well
15:03:52 <grem> Marvin--: its good fun to role play with a good GM/DM... 
15:04:15 <Marvin--> grem: I find it depends more on the players than the GM...
15:04:26 <grem> Marvin--: thats true also
15:04:49 <grem> Marvin--: a good GM/DM will keep the stupid players in line though  :)
15:05:04 <Marvin--> yeah
15:17:17 <tmoertel> "Gygax: Here. Take my plus-one mace."
15:24:51 <Marvin--> +1 maces? luxuary!
15:25:34 <Marvin--> well, I'm off to bed
15:41:24 * Vincenz wishes he could play D&D but noone plays here
16:15:14 * Verbed suggests #trivia
16:15:38 <shapr> tmoertel: ooh, someone who knows the name Gygax
16:18:02 <Verbed> I wonder why #trivia is so unpopular.
16:18:36 <shapr> I'm usually trying to make something work
16:18:51 <shapr> so playing a trivia game would distract me
16:19:12 <shapr> hey, any lambdabot clueful people here?
16:19:17 <Verbed> Don't you ever find yourself in a mental condition that prevents you from thinking productively?
16:19:26 <shapr> Verbed: yes, but I have xmame and crack-attack for that
16:19:30 <shapr> and my unicycle
16:19:33 * Verbed sighs
16:19:45 <shapr> ok I'll drop by next time I'm feeling unproductive :-)
16:29:12 <grem> shapr: can you answer me a quick question...?
16:29:21 <grem>        if isFirstPacket == True
16:29:22 <grem>        then do {
16:29:22 <grem>                 (ReadResult firstPack rc) <- misReceiveBlockUnlimited sock;}
16:29:22 <grem>        else do{
16:29:22 <grem>                (ReadResult str rc2) <- misReceiveBlockUnlimited sock;}
16:29:33 <grem> whats wrong with that?
16:57:56 <shapr> y0 Pseudonym 
16:58:23 <Pseudonym> gr
16:58:28 <Pseudonym> G'day, I mean.
16:58:43 <grem> whats the easiest way to create a counter in haskell?
16:58:58 <wli> monads
16:59:01 <Pseudonym> What do you want to count?
16:59:49 <grem> Pseudonym: i just want to use a int to keep track of what has happened in a thread... It comes in as 0, when something happens i want to add 1 to it...
17:01:12 <Pseudonym> http://haskell.org/hawiki/PaulGrahamAccumulatorProblem
17:02:24 <grem> theres no easy way to do n = n +1?
17:04:40 <Pseudonym> That doesn't make any logical sense.
17:04:50 <Pseudonym> n = n + 1 is invalid for any finite number.
17:05:12 <grem> Pseudonym: this is my first functional language, i'm still in java and C++ land here
17:05:47 <Pseudonym> Sure.  I'm just pointing out that in Haskell, '=' means strong equality.
17:05:52 <Pseudonym> n = n + 1 is a logical impossibility
17:11:24 <Pseudonym> Let me put it this way:
17:11:30 <Pseudonym> You know about design patterns?
17:11:55 <grem> yes
17:12:03 <Pseudonym> OK.  Take, for example, the iterator pattern.
17:12:08 <Pseudonym> Very common both in C++ and Java.
17:12:15 <Pseudonym> In Haskell, you get that for free.
17:12:25 <shapr> you do?
17:12:28 <Pseudonym> Because you have lazy streams.
17:12:32 <shapr> oh yeah
17:12:46 * andersca bounces
17:12:50 <Pseudonym> You just write a function to turn your data structure into a list, and you effectively get iterators.
17:13:01 <Pseudonym> So that's unnecessary in Haskell.
17:13:15 <Pseudonym> In the same way "state" comes for free in C++/Java.
17:13:29 <Pseudonym> But not in Haskell.
17:14:03 <Pseudonym> You kind of get what I mean?
17:14:19 <Pseudonym> G'day andersca
17:14:23 * shapr boings
17:14:25 * grem thinks haskell is going over his head now
17:15:01 <grem> It would seem that adding 1 to a number shouldnt be that difficult
17:15:14 <Pseudonym> Adding 1 to a number is very easy.
17:15:25 <Pseudonym> That's not the difficult part.
17:15:30 <grem> ok, lets start there
17:15:34 <Pseudonym> 1 + n
17:15:36 <Pseudonym> There you are.
17:15:48 <Pseudonym> That returns a value which is one more than n.
17:16:16 <grem> but its NOT possible to add 1 to n and set it = to n again
17:16:17 <andersca> hey Pseudonym
17:16:18 <grem> ?
17:16:28 <Pseudonym> Yes and no.
17:16:37 <Pseudonym> You could, for example, have a function which you call recursively.
17:16:42 <Pseudonym> f n = f (n+1)
17:17:01 <Pseudonym> When you call f recursively, n gets a new binding.
17:17:09 <Pseudonym> But it's actually a "different" variable.
17:17:18 <grem> there isn't a function to do that built into haskell?
17:17:33 <Pseudonym> No, because Haskell is aggressively call-by-value.
17:17:53 <Pseudonym> You can't modify the value of n any more than you can modify the value of 4.
17:18:07 <Pseudonym> If you want to do that, you have to use a technique to simulate it.
17:18:10 <Pseudonym> References are one example.
17:18:39 <grem> Pseudonym: either i'm missing the point of that or it seems to be a whole lot of extra work... (i know i've gotta be missing the point)
17:18:56 * andersca adds himself to the haskell grading belt
17:19:14 <Pseudonym> Well, it depends what you're trying to do.
17:19:48 <Pseudonym> The "best" C solution to a problem and the "best" Java solution to a problem are going to be a lot different.
17:19:56 <Pseudonym> Same with the "best" Haskell solution.
17:20:06 <Pseudonym> Fact is, most of the time you don't actually need modifiable variables.
17:20:13 <Pseudonym> Nor more than you really need pointers.
17:20:50 <Pseudonym> As a C++ programmer, you would know that a lot of C's use of pointers are really references in disguise.
17:21:14 <Pseudonym> And a lot of Fortran IV's use of GOTO are really "for" loops in disguise.
17:21:37 <Pseudonym> Well, a lot of C++/Java's modifiable variables are really write-once variables in disguise.
17:22:29 <Pseudonym> I'm not saying you never need them, but when you think declaratively, you need them a lot less.
17:22:45 <Pseudonym> And those times when you do need them, it's not so bad to put up with a little extra work.
17:23:07 <Pseudonym> And I do say "a little", because, of course, you only need to write the infrastructure once.
17:23:18 <Pseudonym> And it's not _that_ hard.
17:24:27 <grem> Pseudonym: it still just blows my mind ...
17:24:36 <Pseudonym> I'm not surprised.
17:24:44 <Pseudonym> Objects blew my mind when I first saw them way back when.
17:24:50 <shapr> same here
17:25:13 <shapr> monads still blow my mind
17:25:17 <shapr> but I'm slowly getting clueful
17:25:30 <shapr> I noticed I wanted pure FP long before I found it
17:25:31 <grem> Objects are cool, OO programming languages i get, not Funktional ones though
17:25:34 <Pseudonym> Arrows don't quite blow my mind, but they do seem like the Dark Arts.
17:25:49 <shapr> imho, monads are more powerful than objects
17:26:18 <Pseudonym> Monads are somewhat orthogonal to objects.
17:26:24 <Pseudonym> IMO
17:26:36 <shapr> really?
17:26:39 <Pseudonym> Yes.
17:26:43 <shapr> I wanna hear this one :-)
17:26:49 <Pseudonym> Monads don't give you everything that objects do.
17:26:49 <grem> inc n = return(n+1)  then       num <- inc num    this would work?
17:27:12 <Pseudonym> grem: Yes, that would work, HOWEVER, "num" is actually a new binding there.
17:27:17 <Pseudonym> I's not the same "num".
17:27:34 <Pseudonym> It's actually something like this in C:
17:27:34 <grem> it shouldn't really matter should it?
17:27:39 <Pseudonym> int num = something();
17:27:46 <Pseudonym> int temp = num;
17:27:52 <Pseudonym> { int num = temp + 1;
17:27:56 <Pseudonym>   /* stuff */
17:27:56 <Pseudonym> }
17:28:07 <Pseudonym> Well no, it doesn't matter if it works for you.
17:28:20 <grem> for this situation it works
17:28:24 <Pseudonym> See?
17:28:32 <Pseudonym> You didn't need modifyable variables after all. :-)
17:28:47 <Pseudonym> What you wanted was a _new_ variable with the same name.
17:28:48 <grem> still a pain in my ass :)
17:29:33 <Pseudonym> shapr: For example, monads don't by default give you concurrent modifications to the same object.
17:29:35 <grem> is there an else if in haskell?
17:29:55 <Pseudonym> grem: No, but there's guards.
17:29:56 <shapr> grem: if then else is just sugar for a case statement
17:30:01 <shapr> so are guards
17:30:09 <Pseudonym> Guards look prettier than else if, IMO.
17:30:14 <shapr> yah, they do
17:30:24 <Pseudonym> f x | x == 0  = "zero"
17:30:32 <Pseudonym>     | x == 1  = "one"
17:30:39 <Pseudonym>     | otherwise = "something else"
17:31:07 <Pseudonym> shapr: I think the closest Haskell equivalent to objects is some combination of threads and channels.
17:31:14 <Pseudonym> Like you do in erlang.
17:31:30 <Pseudonym> Now that's a powerful technique.
17:31:40 <grem> where do i find info on "guards"
17:31:47 <shapr> in the H98 report
17:32:01 <Pseudonym> Let me take a look for a more tutorial-like explanation. :-)
17:32:26 <grem> i can't find guards in the contents
17:34:12 <Pseudonym> http://www.cs.uu.nl/~afie/haskell/tourofsyntax.html#Guards
17:38:25 <grem> if i create a variable in a thread that is looping (calling itself at the end) will a value i created the first time around be there the 2nd time around, if i don't override it with another value?
17:39:09 <Pseudonym> If I may dissect the question...
17:39:17 <Pseudonym> You're doing multi-threaded programming?
17:39:21 <grem> yes
17:39:23 <Pseudonym> OK.
17:39:41 <Pseudonym> Your thread code is some kind of server loop?
17:40:01 <Pseudonym> You know, get a request, do something, send a response.
17:40:21 <grem> yes, there is a server loop, when the server recieves a connection it spawns off a thread for each connection
17:40:26 <Pseudonym> OK.
17:40:49 <Pseudonym> So you say you "create a variable".
17:41:00 <Pseudonym> What do you mean by that?
17:41:13 <grem> as in                (ReadResult firstPack rc) <- misReceiveBlockUnlimited sock;
17:41:24 <Pseudonym> OK.
17:41:24 <grem> the variable firstPack
17:41:28 <Pseudonym> Gotcha.
17:41:42 <Pseudonym> I think the answer to your question is: Not in the way you want it to be.
17:41:59 <Pseudonym> The variable is only valid while it's in scope.
17:42:06 <grem> I need the contents of the varible to live as long as the thread...
17:42:18 <Pseudonym> If you need it to be around next time you go around the loop, you need to pass it in as a function parameter.
17:42:25 <grem> would i solution be to pass it around with the loop of the thread?
17:42:28 <Pseudonym> Right.
17:42:32 <grem> ah, ok
17:42:42 <Pseudonym> grem, got some code which might help you out.
17:42:50 <grem> Good deal
17:44:23 <Pseudonym> Here we are.
17:44:26 <Pseudonym> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/hashtable/HashTable.hs?rev=1.6&content-type=text/vnd.viewcvs-markup
17:44:37 <Pseudonym> This is a concurrently accessible hash table.
17:44:43 <Pseudonym> Go down to serverThreadHT.
17:44:53 <Pseudonym> Or, in fact, start with runServerThreadHT.
17:44:57 <Pseudonym> WHich is the entry point of the thread.
17:46:08 <Pseudonym> A SyncChan is kind of like a socket.
17:48:48 <Pseudonym> I dunno if that helps or not.
17:48:54 <grem> ok, i will look at it when i have a few min.  I'm getting the Concurrent thing down
17:48:59 <Pseudonym> Cool.
17:53:10 <grem> I will read it on the plane tomorrow
17:53:12 <grem> :)
17:53:20 <Pseudonym> WHere are you going?
18:54:58 <o3> would somebody here be knowledgeable and kind enough to give an example of how rank-2 polymorphism is useful?
18:55:12 <o3> i had a read of the RankTwoPolymorphism page on hawiki, and my head is spinning
18:58:40 <o3> ah, don't worry, found a good example
19:07:39 <witten> what's rank-2 polymorphism?
19:15:59 <o3> http://www.haskell.org/hawiki/RankTwoPolymorphism
19:16:13 <o3> http://ist.unibw-muenchen.de/Haskell/NamedInstances/thesis/documentation/html/sect2ndorderfunctors.html
19:16:21 <o3> i think the second link has a better example
19:44:45 <Riastradh> @yow
19:44:46 <lambdabot> YOW!!  I am having FUN!!
19:44:57 <Riastradh> Oh, come on -- that was a boring Zippy quote.
19:45:03 <Riastradh> @yow , I want a good one!
19:45:03 <lambdabot> Yow!  It's a hole all the way to downtown Burbank!
19:45:09 <Riastradh> Bah!
19:45:16 <Riastradh> @yow , this is your last chance, lambdabot.
19:45:16 <lambdabot> JAPAN is a WONDERFUL planet -- I wonder if we'll ever reach
19:45:16 <lambdabot>  their level of COMPARATIVE SHOPPING...
19:45:23 <Riastradh> Much better.
19:46:30 <Arnia> @fact latin
19:46:30 <lambdabot> Sorry, I don't know the command "fact", try "lambdabot: @listcommands"
21:30:21 * shapr wibbles
21:31:35 * tmoertel wobbles
21:33:08 * Pseudonym wybbles in Middle English
21:33:38 * Pseudonym sighs happily
21:33:48 <Pseudonym> CS theory discussion which doesn't involve type theory.
21:37:56 <shapr> Pseudonym: that physics stuff is very nifty
21:40:41 * Pseudonym thought so
21:41:07 <Pseudonym> A colleague of mine implemented it in C++.  I just thought I'd do it in Haskell to prove it can be done.
21:41:36 <Pseudonym> The only problem with the Haskell version is you can't use "real" mathematical operators.
22:04:48 <shapr> hi cale 
22:05:13 <shapr> Learning Haskell?
22:21:04 * LilithAFK suspects shapr is a bot
22:22:46 <Pseudonym> Yes, he's the fact command.
22:23:27 <Pseudonym> Actually, I reckon you could implement an Eliza-like bot to simulate shapr.
22:25:17 <Pseudonym> There are three kinds of responses: greeting people (with different code paths for people you know and people you don't know), interjecting in the middle of a discussion with "really?" and coming up with the occasional factoid.
22:25:51 * Pseudonym ducks
22:26:01 * Lilith grins
22:26:06 <Lilith> Pseudonym: you don't say
22:26:20 <shapr> Pseudonym: :-PP
22:26:29 <Pseudonym> Oh, I forgot the emoticon response.
22:26:30 <Lilith> Pseudonym: i'm writing a boyfriend bot myself
22:26:38 <shapr> Pseudonym: oh, and there's the "laugh at Pseudonym's jokes" subroutine
22:27:04 <shapr> and the channel organizer subroutine
22:27:09 <Pseudonym> Oh, yes.
22:27:19 <Lilith> channel organiser?
22:27:26 <shapr> someone obviously needs to rewrite the IOHCC organizer subroutine, it wasn't very efficient in a recent unit test ;-)
22:27:28 <Pseudonym> You need the bot to scan the mailing list and occasionally add and drop topic items.
22:27:32 <shapr> right, that too
22:27:53 <Pseudonym> Lilith, I'm curious what the boyfriend bot does.
22:27:58 <Pseudonym> Presumably not a lot.
22:28:00 <shapr> heh
22:28:11 <shapr> Lilith: I'm the 'founder' of #haskell
22:28:21 <Lilith> Pseudonym: oh. actually it was on a friends suggestion
22:28:31 <Lilith> she started talking to this bot on this channel i'm on
22:28:39 <Lilith> and saying how it's practically like a boyfriend
22:28:45 <shapr> though I'm not the person who first registered it, I did pick up the registration when no one else was on the channel for several weeks.
22:28:59 <Lilith> or even better, since the bot responds a lot quicker than the average boyfriend would
22:29:05 * shapr grins
22:29:09 * Pseudonym laughs
22:29:26 * Pseudonym thinks the husband bot would be even easier to write
22:29:38 <shapr> "yes, dear"
22:29:41 <Pseudonym> The boyfriend bot at least has to be mildly proactive.
22:29:48 <shapr> "right away, dear"
22:30:03 <Lilith> "your wish is my command, dear"
22:30:25 <shapr> the husband 'bot would agree and then do nothing ;-)
22:30:30 * Pseudonym is prohibited from using the moniker "dear"
22:30:33 <Lilith> "you look gorgeous in that new haircut, dear"
22:30:33 <Lilith> ;)
22:30:40 <Lilith> Pseudonym: why?
22:30:48 <Pseudonym> For precisely the above reasons.
22:30:56 <Lilith> ah
22:31:09 * Pseudonym doesn't do it, but a previous guy did
22:31:24 <Lilith> i've written up the requirements for a boyfriend bot
22:31:25 <shapr> I've prohibited "sweetie" for the same reasons
22:31:30 <Pseudonym> "your butt looks fine in those pants"
22:31:31 <Lilith> i'm just get to speed on erlang
22:31:32 <shapr> Lilith: as quickcheck tests?
22:31:54 <Lilith> shapr: nope. i havent implemented tests yet
22:31:55 <shapr> bah, I think I'm about to give in to the sleep monster
22:32:19 <Pseudonym> By all means hack lambdabot if you want.
22:32:29 <Pseudonym> Or fork it.
22:32:34 <shapr> Pseudonym: hey, you know about Hircules?
22:32:51 <Lilith> Pseudonym: what does lambdabot use?
22:32:56 <Pseudonym> You mean the lesser known politically correct Greek hero?
22:33:01 <Pseudonym> Lilith: Haskell, of course.
22:33:03 <Lilith> the bot i know of uses markov chains
22:33:05 <shapr> juhp's gtk2 irc client based on lambdabot code
22:33:07 <Pseudonym> @fact lambdabot
22:33:07 <lambdabot> Sorry, I don't know the command "fact", try "lambdabot: @listcommands"
22:33:13 <Pseudonym> Er...
22:33:16 <Pseudonym> @listcommands
22:33:17 <lambdabot> I react to the following commands: ["all-dicts","board","define","definitions","del-definition","devils","dict","dict-help","dump","easton","echo","elements","eval","flip-board","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","more","msg","part","ply","prelude","quit","reset-chess","resume","set-fuel","state","topic-cons
22:33:19 <shapr> sorry, @fact is down till I import the old data
22:33:22 <Pseudonym> Ah.
22:33:40 <Lilith> Pseudonym: yes, haskell, but it has to be based on some algorithm :-)
22:33:40 <shapr> I gave away my database host
22:34:08 <Pseudonym> BRB.  Have to w*rk.
22:34:09 <shapr> ok, I give in... good morning everyone (and good night for me)
22:34:12 <Pseudonym> Night.
22:34:17 <Lilith> night shapr
22:34:17 * shapr falls over asleep
22:34:27 <Pseudonym> lambdabot uses whatever it wants for each module
22:34:35 <Pseudonym> It's modular, so you plug in anything.
22:35:24 <Lilith> Pseudonym: is the code for lambdabot somewhere?
22:40:00 <Darius> www.sourceforge.net/projects/haskell-libs in CVS /libs/lambdabot
22:41:31 <Lilith> Darius: thnx
22:51:08 <alanl> hello?
22:51:10 <Darius> http://www.inflatablechurch.com/mainpage.htm
22:51:15 <Pseudonym> G'day.
22:51:38 <Pseudonym> Unfortunately shapr isn't here to ask you if you're learning Haskell, so I guess I'll have to.
22:51:44 <Pseudonym> alanl, are you learning Haskell?
22:55:27 <Pseudonym> G'day again.
22:56:51 <alanl_> oops...sorry my ssh term hung for no good reason...I have seen the results from IOHCC, now how did those entries bypass the parser?
22:57:02 <Pseudonym> Hmmm?
22:57:15 <Pseudonym> I don't understand the question.
22:57:40 <alanl_> i mean your entry in the osfucated haskell comp
22:57:47 <Pseudonym> Yes.
22:57:57 * juhp hopes his third attempt at packaging gtk2hs will succeed
22:57:59 <Pseudonym> What do you mean "bypass the parser"?
22:58:11 <Pseudonym> Mine was vanilla H98.
22:59:45 <alanl_> I'm just confused on how did you manageto make that H98 compliant
23:00:02 <Pseudonym> There's nothing in it that's not H98.
23:00:12 <Pseudonym> I did mix layout with brace notation.
23:00:15 <Pseudonym> That helped.
23:00:41 <Pseudonym> You'll notice, for example, that the board is indented one space.
23:00:47 <Pseudonym> I had to do that to get over the offside rule.
23:01:19 <Pseudonym> But it's legal.
23:01:35 <alanl_> what about the semicolons?
23:01:46 <Pseudonym> They're legal too.
23:02:33 <Pseudonym> http://haskell.org/onlinereport/syntax-iso.html#layout
23:02:44 <alanl_> so I have been lied to by my lecturers?
23:03:06 <Pseudonym> Education is mostly lying.
23:03:10 <Lilith> Pseudonym: you're awesome :-)
23:03:14 <Pseudonym> Or, rather, oversimplifying.
23:03:32 <Pseudonym> But oversimplifying is a kind of lying.
23:03:36 <Pseudonym> Oh, what did I do now?
23:03:53 <Lilith> Pseudonym: (compliment from someone from another channel who was looking at the tictac toe game)
23:04:02 <Pseudonym> Oh. :-)
23:04:21 <Pseudonym> Unfortunately the AI isn't very smart.
23:04:31 <alanl_> well I think my lecturer will have a few words with you when he sees that...
23:04:38 * Pseudonym laughs
23:04:43 <Pseudonym> I used to teach Haskell.
23:04:44 <alanl_> :-)
23:04:49 <Pseudonym> Believe me, I'd have marked it down.
23:05:05 <Lilith> alanl: who's your lecturer? richardb?
23:05:16 <alanl_> uh huh
23:05:40 <alanl_> I now subject first years to painful assignments now
23:06:12 <Pseudonym> By all means show this to your students if you want.
23:06:24 <Pseudonym> Just to show that Haskell can be as readable as C if you really, really try.
23:06:31 <Lilith> alanl: what's with the ping huh
23:06:54 <alanl_> oh I'm just trying to see where you're from...are you from cse lilith?
23:07:08 <Lilith> alanl: no. i'm a pretender
23:07:21 <Pseudonym> Lilith hacked a machine there.
23:07:30 <Pseudonym> IRCing from an 0wn3d box.
23:07:37 <Lilith> Pseudonym: hehe
23:07:57 <alanl_> oh really.....? did you get root?
23:09:25 <alanl_> does chilli hang out here much?
23:09:40 <Pseudonym> Not lately.
23:09:54 <Pseudonym> I believe he's busy with his new offspring or something.
23:10:07 <Pseudonym> Or maybe he's just snowed under.
23:10:13 <Pseudonym> Sing ho! for the life of an academic!
23:10:18 <alanl_> uh huh....well yes....
23:10:25 <alanl_> its supposed to be a secret
23:10:33 <Pseudonym> Is it?
23:10:39 <alanl_> I think anyway
23:10:43 <Pseudonym> It's in the logs of this channel.
23:10:52 * Pseudonym shrugs
23:12:03 <Lilith> Pseudonym: yes. the little baby :-) i've seen him. looks like chilli ;)
23:12:10 <Pseudonym> :-)
23:12:21 * Pseudonym has little idea what Chilli looks like
23:12:27 <Pseudonym> From his name I can hazard a guess.
23:12:39 <Pseudonym> But that would be horribly stereotypical of me.
23:12:46 <Lilith> Pseudonym: the baby attends our weekly meetings
23:12:58 <Lilith> so i've a chance to compare
23:13:04 <Pseudonym> Ah, there's his picture.
23:13:15 <Pseudonym> Chilli, not the baby.
23:14:07 <Pseudonym> I should bring one of my daughters along to meetings.
23:14:18 * Chilli coughs silently...
23:14:46 <Chilli> Not saying much, but lurking regularily ;-)
23:14:51 <Pseudonym> Ah!
23:15:08 <Pseudonym> Chilli kibozes #haskell.
23:15:24 <sjj> Is there a bitwise or operator in Haskell?
23:15:25 <Chilli> Re picture of the baby: http://www.cse.unsw.edu.au/~chak/leon-schlaeft.small.jpg
23:15:31 <alanl__> damn server...
23:15:35 <Chilli> sjj: yes, in the Bits module
23:15:45 <sjj> thanks.
23:15:47 <Pseudonym> That's a pretty fresh picture.
23:15:55 <Pseudonym> Still some swelling there?
23:16:03 <seth> Chilli: how old?
23:16:28 * juhp curses and starts another build
23:16:35 <Chilli> Tomorrow he is4 weeks
23:16:47 <Chilli> the picture is from when he was about 1 week
23:16:50 <alanl__> well have you been getting any sleep lately?
23:16:54 <cale> heh, sorry about that - opened the channel and left to reply to some stuff on the Haskell wiki.
23:17:23 <Pseudonym> Since we're showing off pictures:
23:17:26 <Pseudonym> http://bromage.org/kids/gallery/misc_Oct-Nov-Dec_02/aaa
23:17:34 <Chilli> alanl: no real problem with sleep
23:17:45 <Pseudonym> Quiet baby, then?
23:17:55 <Chilli> alanl: he is a good baby; I had less sleep during writing my PhD thesis!!
23:18:44 <Pseudonym> Babies are easy compared to dissertations.
23:19:08 <Pseudonym> Babies only take nine months to make, for starters.
23:19:28 <alanl__> I shall keep this in mind incase I'm crazy enough to persue something like that
23:19:37 <Pseudonym> What, a baby or a thesis?
23:19:41 <alanl__> thesis
23:19:45 * Pseudonym nods
23:19:59 <Chilli> Pseudonym: good reasoning :-)
23:20:10 <Chilli> ok, I am off for a while
23:20:24 <Pseudonym> Bye.
23:20:27 <alanl__> bye!
23:21:24 <alanl__> er....does this mean bonni is your other half? no wonder your name sounded somewhat familiar...
23:21:36 <Pseudonym> Yes.
23:21:43 <Pseudonym> Why, do you know her?
23:22:48 <alanl__> no...but I have been to bonni.net from time to time
23:22:52 <Pseudonym> Ah, OK.
23:23:07 <Pseudonym> Vanity domains are so 1998.
23:23:15 <alanl__> damn this world is small
23:23:23 <Pseudonym> Indeed it is.
23:23:58 <cale> If I wanted to write a programmable editor that used Haskell as the extension language, what do people think would be the easiest way to do that?
23:24:21 <Pseudonym> cale: You don't by any chance have a simpler question, do you? :-)
23:24:33 <cale> heh
23:24:51 <wli> nothing wrong with having 50-100 vanity domains
23:25:09 <Pseudonym> cale: I'd concentrate on the data model first.
23:25:20 <wli> more than 2000 or so is excessive
23:25:25 <Pseudonym> Are you thinking of basing it on any existing editor interface?
23:26:00 <seth> cale: what is your reason for reinventing this particular wheel?
23:26:11 <Pseudonym> I'd start here: http://www.softpanorama.org/Editors/index.shtml
23:26:26 <Pseudonym> It explores the design space of existing text editors.
23:26:31 <cale> Not any in particular. I prefer vim's UI, but other than that I don't have any preference.
23:27:50 <cale> I like the idea of emacs as a programmable editor, but I don't care much for lisp syntax.
23:28:11 <Pseudonym> Someone, I believe, is working in a Haskell binding for vim.
23:28:15 <seth> cale: I don't like lisp either, but writing a good editor is a massive effort.
23:28:15 <delYsid> so what? learn lisp :)
23:28:15 <Pseudonym> Or is that you?
23:28:28 <delYsid> Lisp is nice
23:28:35 <Pseudonym> Lisp is OK.
23:28:46 <Pseudonym> It's a functional language, so I'm certainly in favour of it.
23:28:47 <seth> Pseudonym: what do you mean by binding?  Vim already is aware of Haskell, does syntax highlighting for it.
23:28:58 <Pseudonym> I mean as a scripting engine for the editor itself.
23:29:17 <delYsid> I doubt that would work well
23:29:22 <delYsid> monadic scripting, all over the place
23:29:44 <Pseudonym> I'm not convinced it would either, but there's only one way to find out.
23:30:01 <Pseudonym> Problem is Haskell isn't optimised for text.
23:30:10 <Pseudonym> You can tell this because String == [Char]
23:30:35 <seth> Pseudonym: well, yes, but that's equally true of many languages, including C/C++
23:30:56 <wli> Most of what I want is a "principle of least surprise -compliant vi"
23:30:58 <Pseudonym> No, C++ has actual strings.
23:31:05 <Pseudonym> wli: Logical impossibility, I suspect.
23:31:10 <lament> And C has char arrays
23:31:15 <lament> which is quite different from [Char]
23:31:18 <Pseudonym> Char arrays aren't string.
23:31:20 <seth> Pseudonym: it has a library class of strings, but it isn't part of the language
23:31:21 <Pseudonym> strings
23:31:31 <Pseudonym> seth: I don't see that as a problem.
23:31:40 <Pseudonym> It's integrated with all of the standard libraries.
23:31:54 <Pseudonym> At least all of the C++ standard libraries, not the C-only parts necessarilt.
23:32:03 <alanl__> the slowness of lists are more of a problem i think
23:32:05 <seth> Pseudonym: neither do I; I'm just pointing out that in that respect, haskell and C++ are equal.  Strings are implemented as a library based on character arrays.
23:32:17 <Pseudonym> I disagree.
23:32:22 <Pseudonym> In C++, strings are a unique type.
23:32:32 <Pseudonym> In C, they're probably equal.
23:32:33 <seth> Pseudonym: no, they are just a class.
23:32:47 <Pseudonym> I don't see why this is an issue.
23:33:05 <wli> Pseudonym: not really, nvi does most of it except for a couple of corner cases
23:33:06 <Pseudonym> Strings are supported types.  They just happen to be supported in libraries.
23:33:29 <seth> Pseudonym: because there was an implication that string handling is more efficient in C++ vs. haskell, and, if so, it is _not_ because an array of characters is used.
23:33:48 <Pseudonym> I disagree.  It think that's a lot of the reason.
23:34:00 <Pseudonym> Lists have memory overhead, both in usage and in fragmentation.
23:34:16 <seth> Pseudonym: I didn't say I disagree with that, I only said that C++ has the same problem.
23:34:44 <wli> chunked lists can mitigate some of that
23:34:45 <Pseudonym> C++ strings are very cache efficient, for example.
23:35:09 <Pseudonym> No, I don't think C++ strings have the same fragmentation problems.
23:35:10 <seth> Pseudonym: but that's an implementation issue, not a language, or representation, issue.
23:35:19 <Pseudonym> It's a representation issue in Haskell.
23:35:42 <seth> Pseudonym: but the representation is the same in both languages, so it is also a representation issue in C++
23:35:54 <Pseudonym> What, in Haskell and in C++?
23:36:09 <seth> Pseudonym: right, both use an array of character
23:36:19 <Pseudonym> No.  Strings in Haskell are lists of characters.
23:36:27 <seth> and c++ strings absolutely fragment memory.
23:36:51 <Pseudonym> Yes, they fragment memory (assuming you use the standard allocator, though that is pluggable in C++).
23:36:55 <seth> Pseudonym: yes, you are right about the list overhead.
23:37:09 <Pseudonym> But a C++ string is stored in continuous memory.  The string itself is not fragmented.
23:37:19 <Pseudonym> OK, that's a slight lie.  There's the "string" type and the character data.
23:37:35 <seth> Pseudonym: that's true, but in fact that can cause _more_ fragmentation.
23:37:49 <Pseudonym> Yes it can, especially in string-heavy programs.
23:38:01 * Pseudonym is paid to work on a text database engine.
23:38:04 <Pseudonym> I know this, believe me.
23:38:20 <wli> that would be "contiguous" =)
23:38:27 <Pseudonym> Uh, yes.
23:38:39 * Pseudonym imagines continuous memory
23:39:41 <Pseudonym> Presumably you need some kind of partial ordering on location contents and addresses.
23:40:53 <alanl__> do pointers or references exist in haskell in any form?
23:41:02 <Pseudonym> Memory is then a function subject to the constrant that if A is a set of addresses, then Mem[lub A] = lub { Mem[a] | a \in A }
23:41:22 <Pseudonym> haskell.org
23:41:24 <seth> alanl__: there are in place arrays
23:41:26 <Pseudonym> Good stuff there.
23:41:29 <Pseudonym> Ohg.
23:41:30 <Pseudonym> Sorry.
23:41:34 * Pseudonym dugs
23:41:37 * Pseudonym duhs too
23:41:49 <Pseudonym> There are also references, which exist in stateful monads.
23:41:51 <Pseudonym> Like IO and ST.
23:42:05 <wli> are are the in-place arrays implemented with contiguous memory?
23:42:19 <Pseudonym> Not in hugs, I believe.
23:42:25 <Pseudonym> They are in GHC, though.
23:42:59 <Pseudonym> See, I think String == [Char] was a mistake.
23:43:09 <Pseudonym> It makes first-year lab exercises a lot easier, admittedly.
23:43:15 <Pseudonym> But I think String should be an opaque type.
23:43:57 <seth> Pseudonym: It could be added.  Java has separate types for character array strings and "real" strings.
23:44:04 <Pseudonym> Yes, true.
23:44:12 <Pseudonym> GHC has PackedString.
23:44:23 <seth> right, I forgot about that.
23:44:41 <alanl__> where should one start in trying to understand the inner workings of GHC?
23:44:54 <Pseudonym> Oh, gee.
23:44:56 * Pseudonym laughs
23:45:09 <Pseudonym> Uhm... OK.  There's a wonderful book from the mid-80s.
23:45:19 <wli> I think it would behoove one not to emulate Java.
23:45:23 <seth> Simon P-J has two books.
23:45:24 <Pseudonym> "The Implementation of Functional Programming Languages", by Simon Peyton-Jones.
23:45:31 <alanl__> er...thats out of print though
23:45:34 <Pseudonym> Plus there's the online other book.
23:45:42 <Pseudonym> Yes, but your university library almost certainly has a copy.
23:45:52 <seth> alanl__: I did a used book search and found one.
23:46:10 <alanl__> believe it or not our library doesn't have one..
23:46:14 <Pseudonym> http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/
23:46:16 <Pseudonym> There's the other one.
23:46:47 <Pseudonym> Now once you've done that, you want to read "Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine" also by Simon P-J.
23:47:04 <Pseudonym> You want to read one of the books first, though, because the paper assumes a lot.
23:47:05 <seth> Pseudonym: that one is on line, right?
23:47:08 <Pseudonym> Yes.
23:48:05 <Pseudonym> Actually, all of the papers here are pretty good:
23:48:06 <Pseudonym> http://research.microsoft.com/Users/simonpj/Papers/papers.html#compiler
23:48:19 <Pseudonym> Except for the one on the lambda lifter.  You don't need to know about that.
23:48:56 <wli> actually you do
23:49:00 <wli> but wait until later
23:49:02 <alanl__> I assume i'll need to read up on type theory as well right?
23:49:04 <Pseudonym> Not to understand how GHC works.
23:49:10 <Pseudonym> Uhm.. that depends.
23:49:30 <Pseudonym> If you ignore type classes, the type system is pretty simple and is covered in the Simon P-J book.
23:49:49 <Pseudonym> If you then ignore non-H98 extensions, the type system is not simple, but fairly comprehensible.
23:50:27 <alanl__> okay...what is this universial/existantial type business about anyway?
23:50:50 <Pseudonym> Oh, well that's pretty straightforward in principle.
23:51:33 <Pseudonym> Existential types kind of like a generalisation OO polymorphism in Haskell.
23:51:41 <Pseudonym> You understand type classes, right?
23:51:45 <alanl__> yes..
23:51:48 <Pseudonym> OK.
23:52:03 <Pseudonym> Suppose you have a type class Dictionary with various operations like insert, delete etc.
23:52:16 <Pseudonym> For dictionary data structures (e.g. binary search trees, hash tables etc).
23:52:34 <Pseudonym> Now think of how you'd do that in Java or C++.
23:52:52 <Pseudonym> You'd have some kind of base class, probably abstract, called Dictionary.
23:52:58 <Pseudonym> Then derive HashTable, BinarySearchTree etc.
23:52:58 <alanl__> uh huh
23:53:24 <Pseudonym> Now in, say, C++, you could have a std::vector<Dictionary>
23:53:29 <Pseudonym> Not so in Haskell.
23:53:47 <Pseudonym> The equivalent would be (Dictionary a) => [a]
23:53:48 <Pseudonym> or something.
23:53:53 <Pseudonym> Which is not quite the same thing.
23:54:07 <Pseudonym> The Haskell type says that it's a list of a where a is a member of Dictionary.
23:54:20 <Pseudonym> But every element in the list has to be the same type.
23:54:22 <wli> Arrays are parametrizable also
23:54:35 <Pseudonym> Yeah.
23:54:44 <Pseudonym> [] was easier to type
23:54:50 <Pseudonym> With me so far?
23:54:54 <alanl__> yes
23:55:13 <Pseudonym> In C++, you could have a std::vector of Dictionary, and put both a HashTable and a BinarySearchTree in there.
23:55:28 <Pseudonym> In Haskell, you can have a list of HashTable and a list of BinarySearchTree, but not both.
23:55:52 <Pseudonym> The reason for this is the way that Haskell handles what C++ would call "virtual function tables".
23:56:09 <Pseudonym> In Haskell, a class is not a type.
23:56:14 <Pseudonym> It's a set of types.
23:57:02 <Pseudonym> The benefit is that you can effectively take an existing type and make it a member of an existing class without changing the type's definition.
23:57:27 <Pseudonym> In C++, you'd have to go back to the original type and add another ": public BaseClass" to it.
23:57:30 <Pseudonym> You with me?
23:57:47 <alanl__> yes
23:57:53 <Pseudonym> OK.
23:58:01 <Pseudonym> So the solution is existential types.
23:58:08 <Pseudonym> What you can do is this:
23:58:29 <Pseudonym> data DICTIONARY = exists a. (Dictionary a) => DICTIONARY a
23:58:44 <Pseudonym> (Only in GHC and hugs, "exists" is unfortunately misspelled as "forall".)
23:59:23 <Pseudonym> This is kind of like: data DICTIONARY = DICTIONARY a
23:59:37 <Pseudonym> Only a is constrained to be a member of Dictionary.
23:59:41 <Pseudonym> Do you understand that?
23:59:56 <wli> heterogeneous collections hmm
