00:54:46 * Marvin-- reads Volker Stolz' sig and groans
01:22:29 <thornber> morning all
01:27:36 <kosmikus> morning thornber
01:57:20 <shapr> goood morning!
01:57:28 <shapr> Marvin--: what's Stolz' sig?
01:57:54 <Marvin--> "rage against the finite state machine"
01:58:08 <shapr> heh
01:58:18 <Marvin--> damn the delayed commits
01:59:09 <Marvin--> Alastair Reid said something about somebody already committing my mkstemp, but I can't see where
02:00:22 <Marvin--> confusing
02:02:18 <Marvin--> hm, I thought there was a viewcvs interface on haskell.org
02:02:27 <shapr> me too
02:03:31 <Marvin--> well, I can't find it
03:06:36 * shapr boings
03:06:56 <shapr> Marvin--: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/
03:06:57 <shapr> ?
03:07:43 <shapr> hi firstein__ 
03:10:56 <Marvin--> where'd you find the link?
03:11:11 <shapr> google
03:11:25 <shapr> for haskell cvsweb
03:11:36 <Marvin--> ah
03:13:08 <Marvin--> sneaky
03:13:18 <shapr> yes, why play fair?
03:13:46 * Marvin-- is reminded of a scene in Scrubs
03:14:31 <shapr> what's Scrubs?
03:15:10 <Marvin--> a parody on hospital soaps
03:15:20 <shapr> oh
03:15:32 <Marvin--> there's this scene where one of the intern doctors is playing four-in-a-row with Death
03:16:05 <shapr> yikes
03:16:15 <Marvin--> "I WIN." "What? Where, I don't see it?" "HERE, DIAGONALLY." "Pretty sneaky, Death!"
03:16:25 <Marvin--> (discworld-style capital letters added for clarity ;)
03:16:55 <shapr> heh
03:19:25 <Marvin--> bleagh
03:19:35 <shapr> ?
03:20:12 <Marvin--> it's my birthday soon, and my parents and grandparents and whatnot want to know what I want
03:20:19 <tic> heh
03:20:22 <Marvin--> and I suck at making a wish list
03:20:23 <tic> money, computer crap
03:20:35 <shapr> tic: eh?
03:20:35 <Marvin--> and this year I suck even more at it since I'm so busy with my degree project
03:20:37 <shapr> oh
03:20:51 <shapr> Marvin--: it's easy enough, ask for GoT cards and Frozen Throne
03:21:02 <shapr> Marvin--: and maybe some short-order logic
03:21:26 <Marvin--> Frozen Throne isn't out by my birthday
03:21:43 <shapr> so ask for a gift certificate for FT
03:22:19 <Marvin--> maybe I'll ask for Civ3 instead, I still have a bad conscious about not having bought it yet
03:23:09 <Marvin--> I guess I could keep asking for Knuth books, hard to have too many
03:29:49 <shapr> I really enjoyed the "laziness: a hack?" discussion on comp.lang.functional
03:32:26 <Marvin--> I can't find the first post in the thread, what groups.google says is the first post has a subject that starts with "Re:"
03:32:49 <shapr> it starts with "Haskell: Am I missing something?" by David Wang
03:33:23 <shapr> Wang thinks that laziness sucks ass, and that everyone should use ML and monads
03:33:57 <shapr> Personally, I like laziness, but makes some points worth thinking about.
03:34:02 <Marvin--> grrrr, the search only finds "Re:" posts too
03:34:16 <shapr> I don't agree with what he says, but he came up with some neat thoughts.
03:34:45 <cale> Marvin--: If it's on my newsfeed, I'll let you know.
03:34:46 <Marvin--> do you mean Michael Park, "Haskell: Am I missing something?"
03:35:02 <shapr> Maybe that's it
03:37:02 <shapr> I read posts from Jerzy Karczmarczuk even if I'm not interested in the thread, he should do standup comedy.
03:38:54 <shapr> for example, in that laziness thread he says: "But I can hardly imagine Simon Peyton Jones schizoplicating himself into the Lazy Guy who continues, and the Strict Guy, who makes a new strict Haskell compiler."
03:39:04 * shapr snickers
03:39:51 <shapr> his post about producing physics code that makes extremely elegant use of laziness is hysterically funny.
03:40:33 <shapr> If you produce some "real stuff", then you kill your oponents mercilessly, and you remain alone. Yes, you remain alone, and it might be difficult to publish anything, 
03:40:33 <shapr> since the a FP-guReviewer will say "the paper misses its audience, nobody will understand this theoretical physics stuff", 
03:40:33 <shapr> and a physicist will say: "please, understand that you aren't producing any new physics here, go to a conference devoted to functional programming"...
03:40:57 * shapr laughs
03:41:02 <shapr> I've been in that same bind myself
03:42:30 <shapr> "show me a toy program in Haskell" "I can do that in the language I'm already using!" "If you want to use Haskell, get a job doing functional programming"
03:43:49 <shapr> if Faassen and Karczmarczuk did a computer comedy special we'd have to screen the audience for heart problems.
04:14:31 <Marvin--> "Perhaps a lambda with eyes and a mouth? Like a mascot!" heh
04:14:42 <Marvin--> that'd be scarily close to a paperclip
04:15:12 <shapr> lambdaclippachu, variable immunity!
04:15:24 <shapr> lambdaclippachu, monad attack!
04:16:26 <shapr> have you tried apt-get install vigor ?
04:16:59 <Marvin--> yeah :-)
04:17:16 <shapr> I wonder if I should make up some logo suggestions
04:17:56 <Marvin--> bleh
04:18:03 <Marvin--> after all this time, I only have two items on my wish list after all
04:18:39 <shapr> those are?
04:19:06 <Marvin--> Civ3 and Knuth books
04:19:25 <shapr> GoT cards?
04:19:29 <shapr> Steve Jackson games?
04:19:37 <shapr> Icehouse set?
04:19:51 <Marvin--> I think it's next to impossible for my parents to get GoT cards
04:19:52 <shapr> more ram?
04:20:02 <shapr> a new mouse?
04:20:06 <Marvin--> hmm, good point
04:20:08 <Marvin--> I do need that new mouse
04:20:20 <Marvin--> but I do *not* want them to buy one
04:20:22 <shapr> a subscription to the Journal of Functional Programming?
04:20:31 <Marvin--> I have to try them out
04:20:39 <shapr> the H98 Report in hardcover?
04:20:50 <shapr> a subscription to transgaming.com ?
04:24:38 <Marvin--> heh, War3:FT is no 5 on tradition.se's top selling list, and it won't even be released for another month
04:24:49 <shapr> no surprise there
04:24:54 <shapr> when is Doom III coming out?
04:25:01 <shapr> I've heard NiN is doing the music
04:25:44 <Marvin--> grmbl, Tradition don't have Illuminati
04:26:48 <d-bug> Half-Life 2 looks awesome
04:27:09 <shapr> the Half-Life engine has been very popular
04:27:33 <d-bug> http://38.118.133.70/gt_vault/t_halflife2_e3_2k3_gameplay.wmv
04:27:37 <Marvin--> and they don't seem to have any board games that I'm particularly interested in
04:27:49 <d-bug> there's a 500+MB QT movie as well with better quality
04:27:52 <Marvin--> wmv? isn't that the sekhrut micros~1 media format?
04:28:23 <d-bug> Marvin: I'll find the QT for you WMV impaired ;)
04:28:24 <shapr> yup
04:28:30 <shapr> QT isn't much better
04:28:46 <Marvin--> qt isn't much better
04:28:51 <Marvin--> qt is mostly sekhrut too
04:28:54 <shapr> yup
04:29:04 <Marvin--> but I think xine has some of the newer codecs now
04:29:12 <shapr> I can barely wait till Ogg does their video stuff
04:29:25 <d-bug> what is this? Linux quizz and MS haters club?
04:29:45 <Marvin--> no, it's the "we can't view your crappy formats because you keep them secret" club
04:29:48 <shapr> right
04:29:53 <shapr> it's about closed source and closed formats
04:30:15 <d-bug> then don't play the games
04:30:19 <shapr> I don't :-)
04:30:39 <Marvin--> I've sold my soul to Blizzard :-/ but Blizzard games are basically all I play
04:30:43 <shapr> I would like to play those games
04:30:44 <Marvin--> I'd get a mac
04:30:47 <Marvin--> but
04:30:52 <Marvin--> a) they're expensive
04:31:11 <Marvin--> and b) I think I'd have to buy new versions of the games I do have since the CDs are incompatible, no?
04:31:11 <d-bug> ftp://194.109.6.22/pub/Games/misc/hl2/half_life_2_full_gsi.zip 
04:31:13 <shapr> but I have decided that an Open Source system is so far superior and less frustrating that I don't want it that much
04:31:20 <d-bug> zipped qt movie, 500+MB
04:31:32 <Marvin--> uh, doesn't qt have compression in itself?
04:31:37 <Riastradh> Marvin, for Blizzard games, I think they may come on the same CD.
04:31:48 <Marvin--> Riastradh: you may be right
04:31:49 <shapr> for example, I'm trying to build WineX right now, without so much success
04:31:56 <Marvin--> Riastradh: I lack a mac to test the theory on though :-)
04:32:02 <Riastradh> Heh.
04:32:04 <Marvin--> shapr: flex issues?
04:32:08 <d-bug> Riastradh: yes, i have the win and mac versions on my StarCraft and WCIII CDs
04:32:09 * Riastradh looks about for his copy of SC.
04:32:13 <shapr> Marvin--: yes, how did you know?
04:32:14 <Riastradh> Ah, there, I needn't.
04:32:39 <Marvin--> shapr: because there's been endless discussions about the sid version of flex and how it breaks backwards compatability
04:32:43 <shapr> the Linux native version of RailRoad Tycoon II is gorgeous, fast, smooth...
04:32:52 <shapr> how do I get one that works?
04:32:56 <Riastradh> Marvin - As for a), I believe you get what you pay for, or at least close to it.
04:32:57 <Marvin--> oldflex, I think
04:33:00 <shapr> ok
04:33:11 <Marvin--> no, flex-old
04:33:14 <shapr> d-bug: also, Counterstrike is far more stable on Linux than ever on win32
04:33:24 <d-bug> i think that large movie is worth a reboot into windows/macos to see it
04:33:43 <shapr> the few times it did crash and burn I just killed the wine process
04:33:50 <Marvin--> Riastradh: probably, yes, but I bought this PC about a year ago, and I bought a cheap laptop under half a year ago, I don't have the intention of buying a new computer some time soon
04:33:59 <shapr> plus winex lets me use both CPUs for Counterstrike =)
04:34:03 <Marvin--> .oO(and how on earth do you play blizzard games on a one-button mac mouse?)
04:34:18 <d-bug> keyboard?
04:34:31 <Marvin--> but the right-click is so nice :-/
04:34:44 <shapr> yah it is
04:34:53 <shapr> Marvin--: do you use lots of shift-right click?
04:35:04 <shapr> and Control-commands?
04:35:06 <d-bug> ergonomically and ui-wise, one button makes sense, but it's a bit hard after being used to at least 3 buttons
04:35:09 <shapr> they're really handy
04:35:19 <Marvin--> shapr: oh yes
04:35:43 <Marvin--> shift-right click is very useful for scouting
04:35:50 <shapr> how so?
04:36:08 <Marvin--> you queue up the movements your scout is to make to cover maximal ground
04:36:14 <shapr> I use it for repairing, for telling a peon to cut trees after making a building, that sort of thing
04:36:16 <Marvin--> especially useful for fast scouting units of course
04:36:20 <Marvin--> yeah, that oo
04:36:22 <Marvin--> too
04:37:31 <shapr> anything else?
04:37:38 <Marvin--> HERETICS! Tradition.se has a board game called Game of Life
04:37:44 <shapr> ?
04:37:54 <shapr> is it the cellular automaton game?
04:37:55 <Marvin--> it's not about bacterial reproduction
04:38:00 <Marvin--> thus they are HERETICS
04:38:06 <shapr> oh
04:39:06 <opet> http://www.kuro5hin.org/comments/2003/5/26/22429/7674/37
04:39:06 <Marvin--> I use the order queue mainly for peons and for scouting, and for ordering attacking troups to not take short-cuts of course
04:39:07 <opet> teehee
04:39:38 <Marvin--> opet: "Sorry, you don't have permission to see comments in the queue."
04:39:47 <opet> bleh.
04:39:58 <Marvin--> do you have a subscription or something?
04:40:03 <opet> "apparently, if you generate a large enough template error you will find the complete works of shakespeare in there, somewhere..."
04:40:09 <opet> you have to have an account, yeah
04:40:09 <Marvin--> heh
04:40:22 <shapr> to not take shortcuts?
04:40:44 <Marvin--> shapr: yeah, you may want to avoid walking by big bad creeps when attacking your opponent
04:40:49 <shapr> oh
04:40:56 <shapr> do you use formation?
04:41:00 <shapr> I've only used it a tiny bit
04:41:17 <Marvin--> you mean the "aggressive attack formation"?
04:41:31 <shapr> nah, the formation toggle
04:41:49 <Marvin--> hmm, I don't know of that one, what is it? what does it do? Do you have a link?
04:42:12 <shapr> it's the topmost icon next to the minimap
04:42:17 <shapr> Alt-F is the shortcut
04:42:31 * Marvin-- checks battle.net
04:42:32 <shapr> you can set up your troops in a certain shape and they'll maintain that shape as they advance
04:42:48 <shapr> I think it could be extremely useful, but I'm not sure yet
04:42:50 <Marvin--> I find that using attack-move does that decently automatically
04:44:58 <Marvin--> huh, I didn't know about holding down alt to see health bars
04:45:05 <shapr> eh?
04:45:07 <shapr> g'day Lilith 
04:45:22 <Lilith> hullo shapr and everyone else
04:45:25 <Marvin--> oh, it's new for FT
04:45:33 <Marvin--> Health Bars (Warcraft III: The Frozen Throne)
04:45:33 <Marvin--> You can display the Health Bars of units and buildings on screen by holding down the Alt key.
04:45:40 <Marvin--> neato
04:46:13 <Marvin--> ah cool, in FT, you'll be able to see, on the screen, the waypoint you give when using shift-queuing
04:46:36 <shapr> flex-old fixed it, thanks
04:46:49 <Marvin--> ph33r my leet debian unstable skillz
04:49:09 <shapr> now if only I had a copy of war3 handy
04:49:37 <shapr> hm, I have dark reign 2 handy
04:51:11 <Marvin--> gawd I miss the subgroups when playing SC
04:51:24 <Marvin--> I can't wait for SC2
04:55:01 <shapr> I wish there were some way to steal items from enemy heroes
04:55:19 <Marvin--> http://www.blizzard.com/images/broodwar/xmas-kerr.jpg  hahahaha
04:55:34 <Marvin--> shapr: yeah, that'd be neat
05:00:51 <Marvin--> I'm off to the university to see Koen
05:04:21 <Lilith> hmm
05:04:48 <Lilith> what's a good example of STG code for closures
06:27:20 * shapr boings
06:28:22 <ChilliX> Seen this? http://pragprog.com/pragdave/Practices/MoreKata.rdoc,v
06:29:01 <shapr> no, I haven't
06:29:02 * shapr reads
06:31:20 <shapr> that's spiffy
06:31:59 <Lilith> my sensei didn't agree with traditional karate practices
06:33:14 <shapr> I'm a great fan of the pragprog guys
06:33:41 <d-bug> shapr: PragDave is often in #ruby-lang
06:34:10 <shapr> http://pragprog.com/pragdave/Practices/Kata
06:34:21 <Lilith> ah
06:34:25 <Lilith> so he wrote that book :)
06:34:35 <shapr> d-bug: yah, I've chatted with him on #loty and he was on #haskell when Haskell was the LotY
06:35:02 <shapr> We should try this in Haskell: http://pragprog.com/pragdave/Practices/Kata
06:35:06 <shapr> starting with Kata One
06:35:16 <ChilliX> can out it on the wiki...
06:35:32 <ChilliX> Lilith: your Karate sensein didn't agree with traditioal Karate practices?
06:35:56 <Lilith> ChilliX: yes. he asserted we should practice sparring from the start
06:36:11 <ChilliX> no kata?
06:36:27 <ChilliX> or just not waiting with the sparring?
06:36:34 <shapr> The idea of Kata fits very well with the belt levels on the HaskellIrcChannel wiki page
06:36:44 <ChilliX> shapr: indeed ;-)
06:36:53 <Lilith> we have kata, but not having to wait to pass the first kata, as is usually the case
06:37:20 <shapr> Hey, is Koen's threads as monads idea connected with with NDP and SPJ's mdo or unsequenced monad ideas?
06:37:30 <ChilliX> my experience is, if people to too much emphasis on sparring too early, techniques become very sloppy
06:38:13 <shapr> Does that question actually parse?
06:38:31 <ChilliX> shapr: barely...
06:38:58 <ChilliX> shapr: where did Koen explain his idea?
06:39:03 <Lilith> but you'd get a feel for sparring much earlier?
06:39:33 <ChilliX> Lilith: you definitely should do partner training from the start
06:39:35 <shapr> In a functional pearl, Poor Man's Concurrency something, and another one that's on his pubs page
06:39:36 * shapr looks
06:39:59 <shapr> ah, parallel parsing
06:40:03 <ChilliX> Lilith: but that's partner training with fixed techniques or a small set of those
06:40:28 <Lilith> ChilliX: ah. it seems that different clubs have different practices
06:41:01 <Lilith> basically we learnt a set of techiniques, then have to spar using those techniques
06:41:33 <shapr> I'm not sure if mdo and unsequenced monads are the same thing
06:41:40 <Lilith> shapr: url?
06:41:46 <shapr> for which?
06:41:57 <Lilith> functional pearl?
06:42:16 <shapr> Koen has published two, one of which is linked from here: http://www.math.chalmers.se/~koen/publications.html
06:42:19 <ChilliX> Lilith: ah, ok - so the techniques were restricted; then it's a matter of terminology; I wouldn't call this sparring, just partner work
06:42:29 <shapr> it's the parallel parsing processes pearl
06:42:49 <SyntaxPolice> good morning
06:42:54 <shapr> here's the other: http://citeseer.nj.nec.com/claessen99functional.html
06:42:58 <ChilliX> Lilith: to have partner work early on is good
06:43:07 <shapr> I wonder if those three ideas are related.
06:43:13 <shapr> g'mornin Mr. Jones
06:43:31 * Lilith blinks
06:43:34 <SyntaxPolice> shapr: how's it going?
06:43:36 <Lilith> i think that's a name of a song
06:44:00 <shapr> SyntaxPolice: lief is good
06:44:04 <shapr> but he really needs to shave
06:44:37 <shapr> hi firstein_
06:44:42 <shapr> SyntaxPolice: how's life on your end of the wire?
06:45:34 <shapr> ChilliX: do you know if mdo the 'not-so-sequenced' monads idea from the Hair Shirt retrospective are the same thing?
06:45:37 <ChilliX> shapr: re the relation, yes and no
06:46:22 <ChilliX> mdo is basically mfix integrated into the do notation
06:46:29 <ChilliX> very useful for some apps of monads
06:47:12 <SyntaxPolice> shapr: life over here is good ntoo.  I attended a pretty fun wedding this weekend in N. Carolina.
06:47:17 <ChilliX> the thing with NDP and monads is that lists and arrays are monads
06:47:42 <shapr> SyntaxPolice: you use dvorak?
06:48:16 <shapr> does that mean that NDP can be used for a class of monads other than just lists and arrays?
06:48:28 <ChilliX> with threads its a bit different in that some ops in monads cannot interact and hence can be run concurrentl;y
06:48:55 <ChilliX> shapr: yes
06:49:01 <shapr> here's the unsequenced thing I was talking about: http://kungens.kemi.fi/~shae/retro/img36.jpg http://kungens.kemi.fi/~shae/retro/img37.jpg
06:49:08 <shapr> he calls them commutative monads there
06:50:33 <Darius> "I'm storing 1,000,000 integers in a binary tree, roughly how many nodes ... can I expect to have?"?
06:50:44 <shapr> I sort of understand mfix
06:50:45 <SyntaxPolice> shapr: no, no Dvorak.  I've tried it, though.
06:52:05 <shapr> it allows monadic ops to be recursively defined in terms of other monadic ops, yes?
06:52:29 <shapr> even if that's true, I wouldn't really know what to do with it :-)
06:52:51 <ChilliX> shapr: commutative monads already appear here: http://www.cse.ogi.edu/~mpj/pubs/par.html
06:53:53 <Smerdyakov> Darius, did I miss context that made your last statement connect to something?
06:53:55 <shapr> hm
06:54:08 <ChilliX> shapr: and I would guess that the semantics guys have observed the usefulness of commutative monads for concurrency already much earlier
06:54:18 <shapr> Smerdyakov: I think it's a "who's buried in Grant's Tomb?" kind of question.
06:54:30 <ChilliX> shapr: in fact this has all kinds of connections
06:54:36 <Darius> It's one of the "katas" from the above site.
06:54:40 <Darius> Or part of one.
06:54:43 <Smerdyakov> O
06:55:01 <ChilliX> shapr: in concurrent logic programming, people exploit the concurrency in the semantics of the logic connective "and"
06:55:22 <ChilliX> shapr: this is from a mathematical persepctive the same thing as a commutative monad
06:55:28 <Smerdyakov> Darius, hm. I guess we should expect questions like that from people who _don't_ already write lots of little programs of the kind he's suggesting.
06:55:31 <Smerdyakov> ;)
06:56:16 <ChilliX> shapr: I guess, all I am trying to say is that certain mathematical structures that appear in a number of flavours very naturally have a concurrent feel
06:57:08 <ChilliX> as for mfix: simple application: suppose you write a GUI in a monadic GUI library
06:57:40 <ChilliX> if you create a widget that in its creation function gets a callback function that needs to include a reference to that GUI widget, you need mfix
06:58:11 <ChilliX> it's the same sort of situation, as where you would write "let x = ....x... in ..." outside of a monad
06:59:40 <Darius> @eval take 4 $ fix (\x -> 1:[x])
06:59:41 <lambdabot> (line 1, column 18):
06:59:41 <lambdabot> unexpected "-"
06:59:41 <lambdabot> expecting identifier or "."
06:59:49 <Darius> @eval take 4 $ fix (\x.1:[x])
06:59:57 <lambdabot> out of fuel - use @resume to continue
07:01:08 <Igloo> Do you mean 1:x?
07:01:14 <Darius> No
07:01:27 <shapr> ChilliX: thanks, I'll digest that
07:01:46 <Igloo> OK  :-)
07:02:27 <ChilliX> Darius: I take it that lambdabot doesn't include a type checker
07:02:51 <Darius> that would work, but I wanted to see what this would do it works with dynamic types.  Unfortunately, it's [1,[1,1..][[[1,1..],..]]] so showing it is hard.
07:03:31 <Igloo> I'm not sure what you mean
07:03:40 <Igloo> fix (\x.1:[x]) has length 2
07:04:02 <shapr> ChilliX: when do you expect the next release of parr?
07:04:07 <Igloo> Unless I am confused
07:04:57 <shapr> @get-definition fix
07:04:57 <lambdabot> fix = \f.f (fix f)
07:05:00 <Darius> er yes, it's [1,[1,[1,...
07:05:43 <Igloo> Right
07:05:54 <ChilliX> shapr: the thing is that we have an idea for an extension of GHC that would make using parr *much* more convenient
07:06:08 <shapr> like what?
07:06:13 <shapr> or is it secret until published?
07:06:22 <ChilliX> shapr: we want to get that going first (but got side tracked, by the baby ;-)
07:06:33 <shapr> I can understand that.
07:06:47 <ChilliX> shapr: I don't believe in secrets in research :-)
07:07:19 <shapr> that seems sensible
07:07:51 <shapr> soooo, any info on this parreasy extension?
07:07:56 <ChilliX> shapr: one way of viewing it is as an extension of the deriving type classes stuff of Hinze/SPJ to multi-parameter type classes
07:08:45 <ChilliX> then we could much more easily have instances of the paar classes for all kinds of data types
07:08:49 <shapr> I see
07:08:51 <ChilliX> paar = parr
07:09:03 <ChilliX> I am not 100% sure yet that it'll work out
07:09:13 <ChilliX> but if it does, it might have many more applications
07:09:41 <shapr> sounds nifty
07:10:40 <ChilliX> *if* it works...
07:10:51 <shapr> when will you know?
07:11:34 <ChilliX> well, the point with the baby wasn't a joke in this case
07:11:44 <ChilliX> nori isn't getting much done at the moment
07:12:05 <ChilliX> I hope we get a bit more organised again in a couple weeks
07:12:15 <ChilliX> then, our teaching session is also over
07:12:44 <shapr> You'll have more time during the summer?
07:12:48 <shapr> hello jnewbern 
07:13:02 <ChilliX> except that it is winter here ;-)
07:13:10 <shapr> oh yeh :-)
07:13:30 <jnewbern> hello shapr
07:13:30 <kosmikus> ChilliX: why so pessimistic?
07:13:52 <ChilliX> kosmikus: am I?
07:14:04 <kosmikus> *if* it works... ??
07:14:27 <ChilliX> ah ok, this part
07:14:34 <kosmikus> what's the idea?
07:15:46 <ChilliX> well, it's type stuff; so, in the end it has to be consistent and fit well into the existing type system
07:16:00 <ChilliX> if it can somehow be made to work, but is awkward, it won't be practical
07:16:52 <kosmikus> see -- you're pessimistic ;)
07:17:03 <ChilliX> kosmikus: the idea is to exploit the fact that we can view MPTCs with fundeps as functions over types
07:17:21 <kosmikus> yes
07:17:38 <kosmikus> well, they are
07:17:43 <ChilliX> which is related to the idea of type-indexed types and Harper/Morrisett's Typerec constructor for intensional type analysis
07:18:20 <ChilliX> so, we try to use MPTCs with fundeps to realise a Typerec
07:19:19 <kosmikus> apropos Typerec: ...
07:19:26 <ChilliX> if this works, it would be a cheap and easy implementation of type-indexed types that has less interpretative overhead than the Cheney/Hinze-style of modelling similar thingfs
07:19:46 <kosmikus> have you seen http://www.informatik.uni-bonn.de/~ralf/publications/Phantom.ps.gz ?
07:19:51 <ChilliX> yes
07:19:54 <kosmikus> okay
07:20:06 <ChilliX> which is also cool
07:20:35 <kosmikus> do you have a draft?
07:21:01 <ChilliX> not really
07:21:58 <kosmikus> no problem -- but feel free to send me anything on that topic to proofread ;)
07:22:00 <ChilliX> but if you are interested, I have some kind of mock code
07:22:35 <kosmikus> ?
07:22:35 <ChilliX> which shows how the source should look like and what its supposed to be translated into
07:22:56 <kosmikus> yeah, that'd be great to get an impression
07:23:17 <Igloo> Chilli: Are you happy with some single letter suffixes and some full type suffixes? (your latest message implies so but I thought you said not in an earlier one)
07:24:34 <ChilliX> Igloo: what should get full type suffixes?
07:25:06 <Igloo> Well, if Type has T then Tag can't have it, for example
07:26:56 <ChilliX> *urgh* I knew the stinginess would backfire...
07:27:33 <ChilliX> maybe we can call Tag something else?
07:27:43 <ChilliX> why is it called Tag anyway?
07:27:50 <Igloo> Heh
07:28:01 <ChilliX> how about Constructor (or Constr)?
07:28:07 <Igloo> RHS and Range would also collide
07:28:23 <Igloo> That might get confused with Clause
07:28:48 <Igloo> And there's already a Con
07:28:52 <ChilliX> well, one letter abrevs are going to lead to some confusion
07:29:06 <ChilliX> and SPJ doesn't seem to want to go for anything longer...
07:29:36 <ChilliX> having RHS instead of only R is maybe the least of the evils
07:30:09 <Igloo> (DotDot would collide with Dec, so that's no better)
07:31:09 <ChilliX> instead of RHS, we could use Body
07:32:22 <ChilliX> Tag is the tricky one
07:32:49 <ChilliX> T(ag) is taken, C(onstr) is taken, D(Con) is taken
07:33:26 <ChilliX> hmm
07:33:53 <ChilliX> nasty idea: is it so bad, if two catagories share the same suffix letter?
07:34:41 <ChilliX> we can have   data Constr = TupleC | ArrowC | ListC | NameConstr String
07:35:06 <SyntaxPolice> shapr: do you know if moin has an xmlrpc interface or anything? I'd like to write a program to visit wikis I'm interested in and tell me if there are any new changes.
07:35:09 <Igloo> Yes, it is bad
07:35:09 <ChilliX> and at the same time  data Con = NormalC String [StrictTyp] | RecC ...
07:35:19 <SyntaxPolice> shapr: btw, did youw rite an xmlrpc for haskell?
07:35:29 <ChilliX> Igloo: why?
07:35:44 <ChilliX> (I know that it is not optimal, but is it really that bad)
07:36:26 <ChilliX> we have the suffixes for two reasons: disambiguate constructors that occur in multiple categories and to avoid the collision of constructor *functions* with keywords
07:36:28 <Igloo> Because when I get confused and have NormalC and TupleC being returned by a function I will get even more confused at being told the types don't match
07:36:32 <ChilliX> none of that is comporimised
07:37:15 <ChilliX> I agree, then you will have to look the difference up in the API docu
07:37:25 <Igloo> What disadvantage is there to putting Tag back into Type?
07:37:30 <ChilliX> that's the price for being stingy and only having one letetr suffixec
07:37:47 <Igloo> TupleT(yp) Int etc
07:38:04 <ChilliX> that's fine with me
07:38:15 <Igloo> AFK
07:38:40 <ChilliX> actually, as my comment indicates
07:38:49 <ChilliX> I don't understand why we have ListTag at all
07:38:56 <ChilliX> or ArrowTag
07:39:31 <Igloo> Back
07:39:50 <ChilliX> why ListTag and not use ConNameTag "PrelList.[]"
07:40:03 <Igloo> Well, they are the ones you couldn't define yourself
07:40:06 <shapr> SyntaxPolice: I think you can get RSS? RDF? whatever that summary feed is called
07:40:20 <shapr> SyntaxPolice: no, I haven't done the xmlrpc lib yet
07:40:25 <Igloo> I think there are plans for valid lexeme chexking to be introduced
07:40:45 <Igloo> But I guess special cases could still be made
07:41:14 <ChilliX> but "(,) 1 2" is perfectly fine Haskell
07:41:36 <steveh> morning all
07:41:38 <shapr> hi steveh 
07:41:57 <steveh> what's new?
07:42:13 <ChilliX> as is "(,) Int Int" (hmm, is it; GHC is ok with it)
07:42:24 <SyntaxPolice> shapr: hm. I'll look into that.
07:42:39 <steveh> hi SyntaxPolice :)
07:42:50 <Igloo> You couldn't say data Foo = (,) Bar if (,) wasn't builtin though
07:43:16 <thornber> is that 'The Fun of Programming' book any good (see mailing list)
07:43:39 <shapr> personally, I agree with ChilliX on the "regular and matching names, no exceptions"
07:43:44 * steveh has heard about it quite a bit on comp.lang.functional and ars ...
07:43:45 <Igloo> But yes, it is valid in types, via special cases in the grammar
07:43:49 <steveh> at least I think that's the one
07:44:05 <Igloo> shapr: Where exactly do you stand?
07:44:06 <ChilliX> Igloo: I don't see how the point about not being able to define these types
07:44:22 <ChilliX> has anything to do with their use in type expressions
07:44:27 <shapr> Igloo: more letters if means there's a single common pattern in the naming system
07:44:33 <ChilliX> (which is the ony place Tag is used)
07:44:53 <ChilliX> shapr: SPJ and TimS want to save characters
07:45:00 <shapr> I know, I disagree with them.
07:45:08 <ChilliX> thanks :-)
07:45:16 * Igloo encourages shapr to post to the list
07:45:19 <shapr> ok, I will
07:45:20 <ChilliX> me too
07:45:45 <ChilliX> my point is that the super-experts are not the best people to decide on a naming scheme that works for the rest of us
07:45:56 * Lilith grins
07:46:08 <ChilliX> hehehe, revolution!!
07:46:10 <ChilliX> ;-)
07:46:27 <Igloo> I'll reply giving the suggested renamings and mergings and asking for opinions in a minute, and add the guy who mentioned it in another thread to the CC list
07:46:45 <ChilliX> thanks
07:47:00 <SyntaxPolice> hi steveh
07:47:13 <Lilith> hmm
07:47:14 <shapr> I just know that emacs function names *SUCK* and that you can learn all the python function names once you know just a few
07:47:20 <Lilith> this dump of stg stuff makes no sense to me
07:48:06 <ChilliX> Lilith: there are a lot of annotations etc in there that are not really impotant (most of the time)
07:48:47 <Lilith> ChilliX: i was just trying to get a stg version of the length code :)
07:49:05 <Lilith> maybe i should just write it out manually
07:49:25 <ChilliX> yeah, do that
07:50:19 <Lilith> is there a way of turning off annotations?
07:50:30 <ChilliX> not that I know off
07:50:54 <Igloo> Remind me, did people prefer Char or CharL?
07:51:19 <shapr> I forget details very easily, but I try to fill them in by interpolating from what else I know about the system. Interpolation works well in Python, where everything is named/called/etc as I expect it to be... 
07:51:23 <shapr> It's much more trouble in Emacs, where replace-regexp and replace-string are tab-completed from replace, not from string-replace or regexp-replace. In general, I (and many humans) think in subject-verb terms, and emacs doesn't
07:51:38 <ChilliX> Igloo: if everything has a suffix, why not Char?
07:52:11 <Igloo> Well, things like Callconv, Strict, Safety won't (can't)
07:52:18 <shapr> in short, as few rules as possible, as few exceptions as is sensible
07:52:36 <Igloo> I'm calling them leaf datatypes, but Lit is a bit in the middle
07:53:07 <Lilith> shapr: really? i'd have thought "verb-subject" would be easier
07:53:10 <steveh> shapr: that's a good point about emacs.
07:53:34 <Igloo> Oh, any objections to renaming Program to Module?
07:53:52 <shapr> Lilith: for me, I think of what I want to operate on... then I think of what I want to do with it.
07:53:56 <shapr> Lilith: that might be just me
07:54:15 <steveh> shapr: that's The Mac Way. :)
07:54:29 <shapr> I realized a lot of the Java code I see can be refactored according to the StudlyCaps
07:55:20 <shapr> I started rewriting all of my method names, instead of getAdjectiveNoun it's nounGet().adjective() or so
07:55:21 <steveh> http://developer.apple.com/techpubs/mac/HIGuidelines/HIGuidelines-19.html#HEADING19-0
07:55:23 <steveh> :)
07:55:45 <Lilith> hmm
07:55:53 <shapr> does that make sense?
07:56:00 <Lilith> but that's not how you'd think in natural language?
07:56:15 <shapr> I don't think in natural language, I think in concepts
07:56:27 <shapr> and that method naming scheme fits my conceptual thinking much more
07:56:34 <ChilliX> Igloo: please rename Program to Module!!
07:56:39 <shapr> yes, I'd prefer Module
07:56:39 <steveh> "get" isn't a very useful verb to know in that case, either
07:56:41 <Igloo> :-)
07:56:56 <steveh> it's really a byproduct of encapsulation
07:56:56 <Lilith> fetcg?
07:57:02 <shapr> steveh: yah, I know
07:57:06 <shapr> I've thought about that
07:57:07 <steveh> it's just kind of superfluous in general
07:57:14 <steveh> noun()
07:57:20 <shapr> yah, why not?
07:57:23 <ChilliX> Igloo: ok, I think you have a point with Safety etc
07:57:25 <steveh> and the setter noun(newval)
07:57:32 <steveh> it confuses people? :)
07:57:43 <ChilliX> Igloo: they are just enums
07:57:52 <shapr> steveh: imho, the next step down that road is to drop the separate class/instance hierarchy, and go with Self
07:58:06 <ChilliX> Igloo: for the 'Lit's, I think, I prefer the suffix L
07:58:08 <shapr> Then you have only a single instance tree
07:58:12 <shapr> no duplication
07:58:13 <steveh> there's an advantage to pure functional languages, no getting and setting to be done
07:58:20 <shapr> yah, I like that.
07:58:21 <SyntaxPolice> steveh: chekc your msgs.
07:58:38 <shapr> Lilith: what's fetcg?
07:58:43 <shapr> oh, fetch
07:59:41 <steveh> SyntaxPolice: doh :)
07:59:50 <SyntaxPolice> :)
08:00:54 <Igloo> @fact shapr
08:00:55 <lambdabot> Nothing
08:01:14 <shapr> More of what makes me crazy, buffer-list gets a list of buffers in emacs, current-buffer gets the current buffer
08:01:37 <shapr> I'd be happy with verb-subject or subject-verb as long at it's CONSISTENT.
08:01:37 * Lilith nods
08:01:40 <steveh> shapr: that's why c-x c-b is good to know :)
08:01:49 <shapr> yah, I use ibuffer
08:01:59 <shapr> I'm thinking more of writing elisp
08:02:11 <ChilliX> shapr: I think inconsistency is the root of all bad naming schemes
08:02:21 <shapr> I agree
08:02:30 <Lilith> Amen!
08:02:42 <shapr> I'd rather the new naming scheme broke the old one rather than have two different consistent naming schemes at the same time
08:03:11 <ChilliX> shapr: for example, the Haskell libraries use verb-noun (eg, newMVar), but the good thing is that they always use it
08:03:19 <shapr> yah
08:03:36 <shapr> Igloo: I still haven't imported the old data
08:03:52 <shapr> but @fact is back
08:04:02 <Igloo> shapr: What's your e-mail address?
08:04:16 <shapr> shae at ScannedInAvian  dot com
08:04:33 <Igloo> Ta
08:05:29 <shapr> I really like the simple basis/basics of functional programming.
08:05:53 <shapr> in my opinion it removes much of the accidental complexity of programming, allowing us to focus on the essential difficulties.
08:06:05 <ChilliX> indeed
08:06:42 <steveh> shapr: except it's more difficult for compiler and API vendors to come out with a revision that "solves all your problems"
08:07:48 <shapr> That's true, Microsoft would have more trouble forcing an upgrade path with a system that has such a simple basis
08:07:54 <shapr> or maybe I'm underestimating them ;-)
08:08:00 <kosmikus> Template Haskell: for what its worth, I'm also with the "no-exceptions" faction ...
08:08:59 <ChilliX> kosmikus: email on the list!!
08:09:11 * steveh needs a haskell book that isn't (c) 1992
08:10:11 * esap thinks functional programming needs to be extended to cover other ways of design as well.
08:10:45 <ChilliX> esap: like?
08:11:44 <esap> chilli: like layered design.
08:12:34 <ChilliX> why does that not work in FP?
08:13:58 <esap> chilli: because you cannot express the constraints that you need for layering to work. Well I'm actually not sure you cannot do that, but it's at least not immediately obvious how to do it.
08:13:59 <o3> re
08:15:33 <shapr> g'day o3
08:15:37 <esap> chilli: For example, how would you represent callback functions?
08:16:43 <o3> esap: f :: Foo -> Bar?
08:16:45 <Lilith> ChilliX: would you mind looking at my updated thesis slides?
08:16:49 <o3> i don't understand the question
08:17:04 * Lilith hates presentations
08:17:30 <esap> o3: that's not a callback. A callback function has client that registers for the callback and server that invokes the callback when an event occurs.
08:18:43 <ChilliX> esap: callbacks are just higher-order functions
08:19:00 <o3> client code: (assuming 'server' is the thing you want to register the callback with) "registerCallback server f"
08:19:05 <o3> done
08:19:16 <o3> esap: and as proof, i've done callback systems in haskell with no problem
08:19:30 <o3> in fact, doing callbacks in haskell are really nice, because you can supply a partial function
08:21:10 <esap> chilli: well I think higher-order functions are close, but not quite the same as callbacks.
08:21:10 <o3> here, let me show you a concrete example, from a markup language i was working on which used callbacks & plugins to handle rendering of arbitrary markup tags
08:21:57 <o3> here's a datatype for you:
08:21:59 <o3> data Plugin = PhrasePlugin { name :: FunctionName, abbreviation :: Maybe Abbreviation, callback :: ([String] -> PluginData), provides :: [Environment], depends :: [Environment], arguments :: Arguments }
08:22:42 <ChilliX> I think, I leave this for o3 to argue (I agree with him anyway) and go to bed now
08:22:51 <shapr> g'night ChilliX
08:22:57 <ChilliX> 'night
08:23:07 * shapr sends off his TH email asking for consistency
08:23:09 <o3> here's how a plugin registers a callback:
08:23:09 <o3> registerPlugins :: [Plugin]
08:23:10 <o3> registerPlugins = [PhrasePlugin { name = "Bold", abbreviation = Just 'B', callback = makeBoldData, provides = [], depends = [], arguments = 1 }]
08:23:10 <o3> makeBoldData :: [String] -> PluginData
08:23:10 <o3> makeBoldData = -- implementation goes here
08:23:12 <o3> getBoldData :: BoldData -> String
08:23:15 <o3> getBoldData = -- implementation goes here
08:23:17 <o3> thank you, drive through
08:23:21 <ChilliX> shapr: cool!
08:23:35 <Igloo> Bah
08:23:39 <shapr> ?
08:23:40 <o3> shapr: please, any more support against the dragons of inconsistency would be nice
08:23:41 * Igloo realises I forgot to trim Simon's post
08:24:13 <shapr> Haskell is consistent so far.
08:24:15 <esap> o3: I think that would be very fine, if you didn't make any assumptions about what is in the client side, other than the input and the output.
08:24:46 <shapr> oh, I forgot to put a swedish quote at the bottom of my email.
08:24:47 <o3> esap: i don't understand what you mean.  can you give me a concrete example?
08:24:47 <shapr> dang
08:25:59 <esap> o3: like how would I build a client that registers a callback that makes I/O operations in the callback function. If you assume it doesn't do I/O, then you are making too many assumptions.
08:26:52 <esap> o3: the callback registration interface must not require any particular implementation for the client side.
08:26:57 <o3> esap: so make the type signature IO
08:27:31 <Igloo> shapr: Why did you want to?
08:27:39 <shapr> Igloo: I like your naming suggestion
08:28:01 <shapr> hej ralejs 
08:28:08 <ralejs> hej
08:28:10 <shapr> hur är det med dig?
08:28:16 <esap> o3: you can also not assume it's in I/O monad.
08:28:25 <andersca> eek, it's ralejs
08:29:03 <ralejs> Oh, gosh, I'm just entering this channel and people start making 
08:29:05 <esap> o3: the problem is, I don't see a good way to write the constraint that would be desired for that. You always seem to make too many assumptions about the client side.
08:29:08 <ralejs> a big deal out of it,....
08:29:33 <o3> shapr: trust you to worm emacs into a discussion about naming ;)
08:29:48 * shapr cackles evilly
08:30:07 <o3> esap: i don't understand.  if the callback has type sig IO a, then it has a type sig of IO a, and the server has to be running in the IO monad to call it
08:30:09 <shapr> well, it is a good anti-example
08:30:22 * andersca gaboings
08:30:28 * shapr kesplats
08:30:30 <esap> o3: true. But that means that the client side also has to run in the IO monad.
08:30:38 <shapr> ralejs: so, do you want to learn Haskell? ;-)
08:30:43 <o3> esap: of course, it's doing IO
08:30:54 <esap> o3: it might not be, it might be in state monad.
08:31:07 <esap> o3: you don't know that.
08:31:11 <ralejs> shapr: well, can you give me some good examples to learn from?
08:31:13 <o3> s/IO a/m a/
08:31:37 <shapr> @fact learning
08:31:38 <lambdabot> http://www.haskell.org/learning.html
08:31:41 <esap> o3: ok, so your data type has to take the monad type as argument then?
08:32:08 <o3> esap: if you want to allow the client to be running in a monad, then sure
08:32:19 <shapr> ralejs: are you the hIDE/haIDE guy?
08:33:09 <esap> o3: ok, I think that will then be very close to what I mean. But how do you write the server side then? How do you register two clients using different monad?
08:33:25 <ralejs> shapr: No I'm not that guy. Why would you think I am?
08:34:43 * shapr checks
08:35:19 <shapr> oh, I think I may have you confused with Josef Svensson
08:35:29 <shapr> Jonas Svensson
08:35:31 <o3> esap: i don't understand what you mean ... the server just goes the callback from whatever monad it's in
08:35:32 <shapr> sorry :-)
08:36:03 <o3> (not trying to be spiteful, i'm sincerely not understanding what the problem is)
08:37:08 <esap> o3: I mean, you have data X m = X { ... ; callback :: A -> m B }. Now, this only allows you to register one CB. If you have two clients for the same server, then you need callback :: [X -> m Y], where m can be different for each element of the list, basically.
08:37:38 <shapr> ralejs: so, should I assume you have some experience with Haskell?
08:37:42 <esap> o3: so you need: callback :: [forall m . (Monad m) => X -> m Y]
08:37:51 <ralejs> shapr: That's safe to say :)
08:38:14 * shapr grins
08:38:15 <esap> o3: and I guess that might be a problem for the server side.
08:39:07 <shapr> ralejs: cool, you're part of the Multigroup
08:39:14 * shapr finds ralejs' webpage
08:39:21 <shapr> nice sausage.
08:39:30 <ralejs> shapr: Yep, that's right. Thanks!
08:40:04 <shapr> That looks like an american sausage?
08:40:50 <ralejs> shapr: To be honest I have NO idea. That sausage has a long history :0
08:41:00 * shapr is afraid to ask
08:41:24 <andersca> I think I've been to lectures that ralejs had
08:41:40 <shapr> Just wondering why the package is in english. Most of the sausages I've spotted in this part of sweden had swedish documentation attached.
08:41:46 <o3> esap: i'm still unsure why that presents a problem
08:41:59 <shapr> ralejs: heey, do you know arrows?
08:42:24 <ralejs> Well, my first homepage as a PhD student was just this sausage and I decided to keep it.
08:42:38 <ralejs> I do know something about arrows, yes.
08:43:48 <shapr> Some of us have been bouncing around the idea of writing a real-time strategy game in Haskell, one of the thoughts has been to use something like the rpSwitch combinator to hold a list of units as arrows
08:43:57 <esap> o3: Oh actually, sorry, I put the responsibility in the wrong place. it is more like: callback :: [exists m. (Monad m) => X -> m Y], not forall. The responsibility to ensure that no unnecessry aspects of clients is used is with the server.
08:44:31 <ralejs> shapr: Yes....?
08:44:39 <shapr> Does that sound reasonable to you?
08:44:39 <esap> o3: the point is that clients can be anything satisfying the specified interface and no unnecessary constraints are made.
08:44:52 <shapr> would you model it differently?
08:45:25 <o3> esap: i don't think that'd be the problem; the server (at least, the way i would do it) uses the same type for each callback that it knows about
08:45:49 <ralejs> What is a unit in your case?
08:45:54 <esap> o3: but are you saying it's OK to fix the monad that the client is allowed to use then?
08:46:17 <shapr> a military unit, infantry/tank/etc
08:46:55 <esap> o3: because I would view that as an unnecessary constraint.
08:47:00 <shapr> Is shortcut fusion related to deforestation?
08:47:06 <shapr> I guess I could just read the paper :-)
08:47:16 <o3> no, you don't need the fix the monad, you give it as part of the data type so it's parameterised.  data Plugin m = { name :: String, callback :: Foo -> Bar -> m SomeADT }, say
08:47:44 <ralejs> I don't remember the details of the various *switch function to give an accurate answer right now.
08:47:58 <ralejs> And yes, shortcut fusion relates alot to deforestation.
08:48:29 <esap> o3: Hmm.. I think I misunderstood you somehow. What is the interpretation of 'Plugin'? Would that represent 'server' or 'client' side w.r.t. to the callback interface?
08:49:07 <shapr> Are you doing your PhD in the area of deforestation/shortcut fusion?
08:49:56 <esap> o3: because from what I understood, it would be server side [which means that you have to fix 'm' eventually].
08:50:05 <o3> esap: the way i do it, i make the client hand a Plugin data type to the server, rather than a function
08:50:09 <ralejs> shapr: Nope, program analysis is my subject. The shortcut fusion was just a flash of sudden inspiration I had one late evening in the office....
08:50:31 <o3> esap: the client fixes the monad it wants when it hands it over to the server
08:51:42 <shapr> What sort of program analysis? I don't see anything about it on your site.
08:51:59 <esap> o3: oh ok. What would be the type of the function used for registering the callback function?
08:52:36 <esap> o3: that the client invokes, that is.
08:52:53 <ralejs> Well, any of the other papers relates to program analysis. One of them is a usage analysis for Haskell programs and one is a bit more algorithmic paper on general principles on program analysis
08:53:04 <o3> esap: the way i did it, each client is a separate module which has a function named 'registerPlugins :: [Plugin]', so it can register more than one plugin/callback if it likes
08:53:39 <o3> esap: the server, upon loading the module, looks for a function named registerPlugins, and executes it and stores the results if it finds one
08:53:49 * shapr downloads
08:54:14 <esap> o3: oh, ok, that does, I guess, work if you dynamically load the client to the server.
08:54:41 <o3> esap: oh, sorry, yes ... i'm dynamically loading in the client.  i think a callback system is half-useless without that facility :)
08:55:02 <shapr> ralejs: oh, I probably haven't introduced myself, I'm Shae Erisson, you may have seen me post to c.l.functional or some of the Haskell mailing lists.
08:55:10 <esap> o3: of course, you can also list all the modules you want in the main program.
08:55:42 <o3> esap: yep, sure
08:56:13 <o3> esap: but i actually did use a partial function as a callback, which is really neat
08:56:19 <ralejs> shapr: yes, I do recognize you. How come you're a Haskellite?
08:56:30 <shapr> It's cool?
08:57:14 <shapr> I started programming some years ago, but I quickly saw flaws in the languages I was using.
08:57:42 <shapr> Haskell is the closest to the nebulous perfect language I have in my head.
08:57:48 <shapr> hey Arnia 
08:58:04 <ralejs> So close, yet so far away....
08:58:08 <Arnia> shapr: Heya
08:58:18 <Arnia> ralejs: Not so far...
08:58:22 <shapr> ralejs: Why are you a Haskellite?
08:58:41 <esap> o3: hmm.. I didn't actually realize that this kind of "initialize" function would also work for that purpose also for this kind of case. But that's actually obvious solution to the problem.
08:58:44 <o3> esap: i'd actually love to see haskell become a more dynamic language.  pretty much all the work i've done with haskell so far is twisting it that way :)
08:58:49 <Arnia> shapr: I've decided haskell is the world's first arrowdic language. We should celebrate this :)
08:58:54 * shapr celebrates
08:59:00 <shapr> Truly, Haskell is good for arrows.
08:59:01 <ralejs> shapr: I was fed Haskell when I started Chalmers and I still like it. That's why.
08:59:08 <shapr> Good reason
08:59:14 <o3> esap: honsetly, i think that's haskell's current major weakness
08:59:31 <shapr> I haven't found many (any) pro-haskell people in the Luleå area.
08:59:43 <Lilith> o3: why?
08:59:55 <esap> o3: Yes, first class modules would be the feature we need.
08:59:58 <o3> esap: yeah, i found that sometimes haskell has these really simple solutions which you completely overlook ...
09:00:18 <o3> esap: hehe, i don't think we need first class modules
09:00:32 <o3> but proper dynamic loading, oh man ... don't get me started
09:00:45 * Arnia has fallen for fruit and decides to start work on expanding it as soon as exams are over with
09:00:48 <esap> o3: Ok, I'd say proper dynamic loading _is_ the first class modules facility.
09:00:56 <shapr> Gee, I've heard of only one decent dynamic loading system for Haskell
09:01:03 <o3> Lilith: dynamism is, IMHO, the _only_ way you can build truly extensible applications
09:01:07 <shapr> though I've heard it doesn't work with ghc 5.04.3 yet
09:01:19 <o3> shapr: i'll just make it work with 6.0 when that comes out, ok? :)
09:01:26 <shapr> ok, fair enough :-)
09:01:33 <o3> give me a little bit of time, i have thesis + work deadline + assignments due all simultaneously
09:01:33 <esap> o3: then you have to have some mechanism of passing "references to modules" around to be able to refer to symbols in dynamically loaded modules.
09:01:33 <Darius> It comes out in a week or two.
09:02:03 <o3> Darius: hey, maybe i can stall them by talking more about naming schemes on template-haskell :D
09:02:16 <Arnia> shapr: I think I will be able to add AFRP IO to the GUI arrow quite easily... fingers crossed
09:02:17 <o3> esap: the current runtimeloader stuff does that
09:02:28 <o3> (although, as shapr says, it only works with 5.04.2 right now because i'm a lazy bum)
09:02:34 <Lilith> AFRP?
09:02:38 <Smerdyakov> o3, are you a masters student?
09:02:45 <shapr> arrowized functional reactive programming
09:02:49 <o3> (except that i was up until 6am this morning working on my thesis)
09:02:51 <shapr> @fact afrp arrowized functional reactive programming
09:02:52 <lambdabot> set afrp to arrowized functional reactive programming
09:02:53 <o3> Smerdyakov: no, undergrad
09:03:14 * esap thinks I will have to look at the dynamic loading stuff for implementing my OO library :-)
09:03:42 <o3> you're doing an OO library in haskell?  *raises eyebrow*
09:03:47 * esap is.
09:03:56 <Arnia> shapr: Lambdabot - evidence for #python that haskell works in the real world :)
09:04:07 <shapr> truly
09:04:29 * Lilith blinks
09:04:30 <Lilith> omg
09:04:34 <o3> esap: are you extending haskell to do it?
09:04:37 <shapr> Lilith: what?
09:05:08 * Lilith just finds it amusing
09:05:09 <esap> o3: no, the intention was not to do any extensions. But the reason for doing this is to find out what kind of extensions are needed, if any.
09:05:19 <Lilith> maybe one day we will just have one language
09:05:20 <o3> esap: cool :)
09:05:29 <shapr> Lilith: btw, there's a guy who shows up here on #haskell with the irc nickname jewel, he wrote the kissme JVM, and he was working on integrating JRVM and Gnu Classpath at one point.
09:05:50 <Arnia> And that language will be super-haskell with DSELs sprouting out the ears
09:05:54 <shapr> yah really
09:05:59 <shapr> DSELs are the way of the future
09:06:02 <esap> o3: Because I want to implement OO for my compiler, which has very close to Haskell semantics by default.
09:06:05 <Lilith> shapr: ah cool. chilli doesn't want me to work with any other jvm other than rjvm and orp
09:06:20 <shapr> Where's orp?
09:06:25 <o3> esap: ah.  have fun with subtyping :D
09:06:42 <esap> o3: I already know how to do subtyping.
09:07:00 <Lilith> shapr: orp.sf.net
09:07:12 <o3> cool, with type inference?  is this stuff that's beyond o'haskell?
09:07:37 <Lilith> Arnia: what's DSEL?
09:07:59 <shapr> @fact dsel domain specific embedded language
09:08:00 <lambdabot> set dsel to domain specific embedded language
09:08:27 <o3> @fact edsl Embedded Domain Specific Language.  Also see dsel
09:08:28 <lambdabot> set edsl to Embedded Domain Specific Language.  Also see dsel
09:08:34 <o3> (i've always known it as edsl)
09:08:42 <esap> o3: basically, I think I am using quite close to o'haskell's approach (message passing). Subtyping can be implemented with universal quantification. But I'm generalizing monads to allow for proper layering.
09:09:07 <Arnia> @fact FMUI Functionally Modelled User Interfaces. Also see Fruit
09:09:07 <lambdabot> set fmui to Functionally Modelled User Interfaces. Also see Fruit
09:09:38 <shapr> @fact fruit
09:09:38 <lambdabot> Nothing
09:09:39 <Arnia> @fact Fruit Functionally Reactive User Interfaces
09:09:40 <lambdabot> set fruit to Functionally Reactive User Interfaces
09:09:42 <shapr> @fact yampa
09:09:42 <lambdabot> http://www.haskell.org/yampa/
09:10:00 <shapr> gee, that looks like FRUI to me
09:10:17 <Arnia> Harder to pronounce :)
09:10:32 <shapr> @fact dsel Also see edsl
09:10:32 <lambdabot> set dsel to Also see edsl
09:10:41 <shapr> @fact dsel
09:10:41 <lambdabot> domain specific embedded language, Also see edsl
09:10:45 <andersca> @fact recursion See recursion
09:10:46 <lambdabot> set recursion to See recursion
09:11:04 <Arnia> Who here has looked at Fruit?
09:11:05 <o3> esap: you might be interested in my thesis ... i'll send you an email when i've finished it, if you like (~3 weeks)
09:11:08 <esap> o3: type casting operations and object references are actually harder (because they both rely on existential quantification).
09:11:15 <shapr> ORP is nice
09:11:38 <shapr> Lilith: is ORP faster than Jalapeño?
09:11:43 <Lilith> shapr: yes
09:11:54 <shapr> gee, not much reason to use Jalapeño then
09:12:04 <Lilith> but it's in C++
09:12:32 <esap> o3: sure, please do send you thesis.
09:12:32 <o3> what's jalapeno written in?
09:12:39 <Lilith> C/Java
09:12:44 <esap> o3: s/you/your/
09:14:23 <esap> o3: I was actually thinking about simulating proper existential quantification using recursion. But I guess dynamic loading modules will also do.
09:14:31 <o3> great, acrobat 6.0 reader has freaking advertising in the corner
09:14:52 <Lilith> o3: fey. what's wrong with xpdf?
09:15:20 <o3> Lilith: doesn't have an aqua interface, for one thing :)
09:15:41 <Lilith> hmm. you go for eyecandy? :)
09:16:14 <o3> i go for things which work.  acrobat reader 5 works quite a bit better than xpdf
09:17:59 <Arnia> I shamelessly go for things that fit into the environment and don't jar me from concentration. If that's eyecandy then I personally go for eyecandy :)
09:21:35 <o3> anyway, time to do some work
09:21:43 <o3> Lilith: see you in a few hours, good luck with preparation :)
09:22:06 <Lilith> o3: cya. good luck with your thesis writing :)
09:22:14 <o3> merci!
09:22:38 * Lilith hopes everyone falls asleep tomorrow
09:22:45 <esap> o3: see you.
09:28:10 <Arnia> Does anyone know of any schemes to access the IO monad in an AFRP signal function without using performUnsafeIO
09:33:31 <Arnia> Or should I build an AFRP IO arrow that has a controlled use of the evil typebreaking function?
09:36:22 <Arnia> I take it that no one knows then :)
10:50:33 <andersca> does mark p jones come here?
11:40:47 * steveh unidles.
11:52:25 <kunphuzil> What does it mean when it says "We've seen that multiplication binds more tightly than division" ?
12:03:29 <Darius> kunphuzil: literally it means 5/4*9 is 5/(4*9) which is abnormal.
12:08:32 <Riastradh> Hmm.  Why is there no `updateFM' function in Data.FiniteMap? -- updateFM (\prevElt -> modifyPrevElt) someFM key
12:36:24 <Darius> Riastradh: there are a lot of odd things about Data.FiniteMap.
12:51:02 <thornber> is there anything I need to do to get 'import Data.FiniteMap' to work with ghci ?
12:51:14 <thornber> (it gives 'can't find module' ATM)
12:51:26 <Darius> What version are you using?
12:51:32 <dennisb> thornber: probably -package data
12:51:33 <thornber> 5.02.2
12:51:46 <dennisb> (if there is such a package, I don't remember)
12:51:59 <Darius> FiniteMap wasn't moved to the hierarchical libs until 5.04 (3?)
12:52:16 <Darius> So import FiniteMap and use -package data
12:52:24 <thornber> dennisb: y, that worked if I change the import to plain old FiniteMap, thanks
12:52:25 <Darius> or upgrade
12:52:51 <thornber> time to do an apt-get update :(
12:53:26 <Darius> Well, GHC6 will be out soon
12:53:57 <thornber> big changes ?
12:54:08 * tmoertel thinks ~2 weeks
12:54:11 <Darius> I'm not sure about changes, but some big additions
12:55:10 <thornber> I'm still a complete novice, so it probably wont effect me much
12:55:13 <Smerdyakov> Tetris easter egg?
12:55:55 <Darius> Smerdyakov: yes, but you need to set every flag in a specific order
12:56:14 <Smerdyakov> What order?
12:56:42 <Darius> ah, you'll have to go through all the permutations to find out
12:57:44 <Smerdyakov> OK. I'll write a Perl script to do it.
13:01:30 <thornber> which haskell modes do people generally use in emacs ?
13:10:56 * steveh uses whatever comes with xemacs
13:11:36 <Smerdyakov> Hoooot... xemacs comes with sml-mode, too.
13:11:42 <steveh> " Major mode for editing Haskell programs.  Last adapted for Haskell 1.4. 
13:11:42 <steveh>   Blank lines separate paragraphs, comments start with `-- '. "
13:11:46 <thornber> do you use an interaction mode ?
13:11:50 <steveh> is what the help for haskell-mode says
13:12:10 <thornber> I'm using one I found on haskell.org, but notice there are a couple of others
13:13:44 <steveh> humm
13:14:19 <steveh> the line says (C) 1992, 1997-1998 Simon Marlow, Graeme E Moss, and Tommy Thorn
13:14:30 <steveh> haskell-mode v1.43
13:14:40 <steveh> http://www.haskell.org/haskell-mode/
13:15:02 <thornber> y, that's the one I'm using, thx
13:15:20 <steveh> it works pretty well for me
13:15:21 <thornber> I need to get used to it's indentation style
13:15:49 <Riastradh> The only thing I don't like about it is when you try to indent 'case' with it.
13:15:53 <Riastradh> It tries to indent it like:
13:15:58 <Riastradh> case this is a long expression here of
13:16:00 <wli> haskell modes never did do much for me
13:16:05 <Riastradh>                                    stuff ->
13:16:13 <wli> but I'm a vi guy anyway
13:17:22 * thornber is addicted to electric-tab
13:17:36 <wli> what's electric tab?
13:18:19 <thornber> autoindent, emacs calls special behaviour bound to keys 'electric'
13:18:30 <steveh> it's electric!
13:18:34 <steveh> boogywoogyoogy
13:18:41 * steveh ducks.
13:18:45 <wli> oh
13:18:52 <thornber> eg, you could have an electric semicolon in c-mode that automatically puts in the newline (yuck)
13:18:59 <steveh> python-mode seems to have that set by default
13:19:09 <steveh> not the semicolon, the indents
13:19:22 <steveh> I started programming C in emacs after a stint with python
13:19:33 <steveh> and was like "sheesh, it's not indenting my lines!"
13:20:00 <thornber> C mode is excellent in emacs
13:20:18 <wli> You're talking to a guy who uses vi most of the time and ed regularly when tty's are hosed.
13:20:21 <steveh> it's had a while to get perfected
13:20:24 <wli> This stuff is lost on me
13:20:33 <steveh> wli: join us, emacs is great
13:20:44 <steveh> well, I use xemacs personally because that's what was installed at school
13:20:48 <Riastradh> wli - Resistance is futile.
13:20:54 <steveh> but they are 99.9% the same
13:20:57 <wli> Not likely to change.
13:21:05 <wli> I work in hostile environments.
13:21:10 <steveh> as far as I can tell the only difference is how they are drawn in X11
13:21:20 <thornber> wli: y, ignore me, I'm probably not worthy of being a kernel hacker simply because I use an editor rather than cat > a.out :)
13:21:22 <Riastradh> steveh, lots of elisp incompatibilities between them.
13:21:38 <Riastradh> Of course, elisp is gross anyways.
13:21:43 <wli> well
13:21:44 <steveh> hmm hmm
13:21:51 <steveh> I've not done substantial elisp programming
13:21:59 <steveh> a few things to mess around with it
13:22:02 <wli> when various system calls stop working
13:22:08 <wli> or when the tty's are hosed
13:22:12 <wli> that's when you need it
13:22:13 <steveh> it's a very slow lisp from what I can tell :)
13:22:15 <Riastradh> Schemacs or Haskmacs would be much nicer.
13:22:25 <wli> hemlock?
13:22:31 <Riastradh> Hemlock?
13:22:52 <thornber> I would happily work on a haskmacs
13:22:57 <wli> hemlock uses cmucl as its back end
13:23:22 * Riastradh dislikes CL too, though not as much as elisp.
13:24:00 <Riastradh> I'd help out with a Haskmacs, but I've got...*counts*...five projects to be working on right now.
13:24:42 * steveh would help too but is a haskell neophyte
13:24:48 <Riastradh> Four of the five have to do with ML and Haskell, too.
13:25:13 <steveh> Riastradh: not bad :)
13:25:20 <wli> I'm maintaining a couple of monstrously huge kernel patches
13:25:33 <wli> so I'm pretty much out of the running for anything besides potshots
13:25:38 <steveh> c, python, and LaTeX are pretty much what I'm working in now
13:25:50 <Riastradh> Eww, C.
13:26:21 * steveh works with a guy who does all his web CGI programming in C
13:26:32 <steveh> let me tell you it's not so fun
13:26:45 <steveh> i haven't the heart to tell him how many wheels he's reinvented
13:27:29 <Verbed> It's about time you 'spoke' to him..
13:27:30 <Verbed> ...
13:27:31 <Riastradh> What's worse than just reïnventing wheels in C and C++ is that the resulting new wheels tend to be squarish.
13:27:55 <thornber> y, but you learn a hell of a lot inventing even square wheels
13:27:56 <steveh> well, he's oldish, and he's my "boss," and I don't have to work directly with the web stuff he's doing
13:28:13 <Riastradh> e.g., C++ templates as opposed to a real macro system, functors (in the ML sense), and parametric types.
13:28:28 <steveh> and he's defined his own personal scripting language which I guess works well enough for him
13:29:19 <steveh> "Defined" might be a strong word
13:29:29 <steveh> "developed?"
13:29:34 <steveh> "evolved?"
13:29:38 <steveh> something like that
13:29:38 <steveh> :)
13:29:57 <steveh> to be fair to him he started work on it back in 1995-96 or so
13:30:04 <steveh> I think there was Cold Fusion and not much else then
13:30:09 <steveh> not sure when PHP took off
13:30:43 <wli> if the operational behavior matters it could make sense
13:30:47 <wli> it probably doesn't, though
13:31:13 <steveh> no, he's doing pretty much standard web hosting duties
13:31:27 <steveh> has a shopping cart and form processing system
13:31:48 <thornber> sounds like he's trying to make his job interesting
13:31:56 <steveh> his idea is to just sell it for hella cheaper than everyone else
13:31:57 <steveh> :)
13:32:10 <steveh> I think his son got in on the ground floor at Excite.com
13:32:25 <andersca> hello mr norpa
13:32:25 <steveh> and he worked in industrial engineering for many years
13:32:44 <steveh> so he's probably getting retirement pay from there too
13:33:06 <wli> I just need some kernel interfaces ...
13:33:33 <wli> a Haskell FFI interface to futexes and an aio remap_file_pages() thing I'm going to brew up.
13:34:14 <thornber> wli: I'd be interested in what you come up with (just from a learning point of view)
13:34:26 <steveh> futexes?
13:34:31 <thornber> I wonder if I should write a dm regression suite in haskell
13:35:02 <wli> thornber: it should probably get used to back-end mvars or something, which could make it hard
13:35:08 <steveh> aah, they are what they sound like 
14:03:23 <thornber> how do I override a function that has been instanced with the 'deriving keyword'
14:03:26 <thornber> eg.
14:03:38 <thornber> data Foo = Foo deriving (Ord)
14:03:51 <thornber> instance Ord Foo where
14:03:59 <thornber>   compare = ???
14:04:09 <Darius> you don't 
14:04:47 <thornber> oh
14:05:49 <thornber> how can you use 'deriving (Eq)' then since == and /= are defined in terms of each other ?
14:06:17 <Darius> deriving and defaults are orthogonal features
14:06:57 <Darius> The defaults hold whether you derive or not
14:07:01 <Riastradh> How does 'deriving' work, anyways?
14:07:40 <Darius> Riastradh: www.haskell.org/onlinereport get at it, if you mean exactly.  Otherwise it should be relatively obvious.
14:07:41 <Smerdyakov> It's a fancy thing that Template Haskell obsoletes, I think. :-)
14:08:12 <Darius> Smerdyakov: A TH library(/ies)
14:08:12 <Riastradh> Darius, er, it's not very obvious to me, and the onlinereport description confused me...or maybe I just forgot it.
14:10:24 <Darius> Riastradh: what aspect of it is non-obvious?
14:11:41 <thornber> Riastradh: look at 10.1
14:13:29 <Riastradh> Oh, oops, I get it now.
14:13:42 * Riastradh hadn't noticed condition 1.
14:13:59 <Igloo> Riastradh: Basically deriving makes an instance according to a standard pattern
14:14:28 <thornber> and that standard patcan be defined ? or is it hard coded ?
14:14:33 <Igloo> Hardcoded
14:14:39 <thornber> ahh
14:14:42 <thornber> yuck
14:15:31 <Igloo> With TH you could define your own. You can do similar things with GH
14:16:02 <Riastradh> GH?
14:16:52 <Igloo> Generic Haskell
14:17:27 <Riastradh> What is it?
14:17:55 <Darius> www.generic-haskell.org (or .com or .net)
14:18:54 <Smerdyakov> or .co.nz? =)
14:29:41 <Darius> Igloo, how much of SDL do you have wrapped?
14:31:00 <Igloo> Darius: Virtually nothing
14:31:30 <Igloo> And one of the first things I'd want to do will hit the foo->type bug  :-(
14:31:51 <Darius> yeah, that's probably the largest thing I need for Kyra.
14:33:21 <Igloo> Kyra?
14:33:48 <Darius> The C++ sprite library over SDL.
14:33:56 <Igloo> Ah, right
14:42:08 <||Zeus||> Can anybody tell me what this error message means
14:42:08 <||Zeus||> ?
14:42:21 <||Zeus||> ERROR - Illegal Haskell 98 class constraint in inferred type
14:42:23 <||Zeus||> *** Expression : partition 3 [12,3,4]
14:42:23 <||Zeus||> *** Type       : (Num [a], Num a, Ord a) => [a]
14:42:35 <||Zeus||> thats it
14:42:38 <||Zeus||> ?
14:43:20 <Darius> Num [a] isn't a legal Haskell 98 constraint
14:43:20 <Riastradh> Is this partition from the List module?
14:43:20 <Igloo> Is that List.partition?
14:43:37 <||Zeus||> its what i wrote
14:43:46 <||Zeus||> partition a b = (smaller a b) ++ a ++(bigger a b)
14:43:46 <||Zeus||> smaller a b = [ x | x <- b, a < b]
14:43:46 <||Zeus||> bigger a b = [ x | x <- b, a > b ]
14:43:48 <||Zeus||> that
14:44:36 <Igloo> Ah, you mean [a] in the first line
14:44:37 <Riastradh> It's the '++ a ++' bit.
14:44:55 <Riastradh> ...what Igloo said -- change '++ a ++' to '++ [a] ++'.
14:45:28 <socrates2> did that
14:45:45 <socrates2> R "C:\HugsDeclarative\part.txt.txt":1 - Type error in application
14:45:45 <socrates2> *** Expression     : [a] ++ bigger a b
14:45:45 <socrates2> *** Term           : [a]
14:45:45 <socrates2> *** Type           : [[a]]
14:45:45 <socrates2> *** Does not match : [a]
14:45:45 <socrates2> *** Because        : unification would give infinite type  
14:45:46 <Riastradh> And now does it work?
14:45:55 <socrates2> Riastradh: no.
14:46:20 <Riastradh> a < b and a > b should probably be a < x and a > x, respectively.
14:46:33 <Darius> b is a list not an element
14:46:36 <Riastradh> (I dunno if that's the problem, but it doesn't look right as 'a > b')
14:46:58 <Igloo> *nod*
14:46:59 <socrates2> ok thanks
14:47:22 <Riastradh> Of course, you could avoid list comprehensions at all and do:  smaller a b = filter (a<) b; bigger a b = filter (a>) b
14:48:18 <socrates2> oh yeah filter
14:48:30 <socrates2> thanks
14:48:38 <steveh> do they compile to the same code?
14:49:07 <socrates2> yeah that works now thanks
14:49:24 <Riastradh> steveh, with a decent optimizer, probably.
14:51:27 <Darius> socrates2: how long have you been programming Haskell?
14:51:30 <socrates2> i will now finish the quick sort function
14:51:32 <socrates2> :)
14:51:51 * Darius sounds like shapr.
14:53:13 <steveh> Darius: :)
14:54:16 <socrates2> Darius:  5 weeks
14:57:18 <Darius> You may find Helium helpful, http://www.cs.uu.nl/~afie/helium/
14:57:51 <Smerdyakov> I heard it's not done yet, Darius!!
14:59:40 <Darius> Indeed, it's still missing support for type classes, that doesn't mean it isn't useful.  I'm sure it would give a much clearer answer for this error.
14:59:53 * Darius is dling Helium to find out what exactly it would say.
15:00:24 <socrates2> quicksort in haskell is not at all like it is in other languages 
15:00:50 <Riastradh> That's because Haskell is so great.
15:01:00 <socrates2> it does  loads more comparisons
15:01:15 <socrates2> its proabbly just as slow as bubble
15:02:22 <steveh> Riastradh: :)
15:04:47 <Darius> An efficient quicksort wouldn't be written the way you have it.
15:04:57 <socrates2> Darius: how?
15:06:00 * shapr yawns
15:06:41 <steveh> ++ is the culprit in that definition, right?
15:07:05 <steveh> not so much comparisons as it is traversing the list to the end
15:08:29 <steveh> besides, quicksort's only advantage over other n lg n sorts is space efficiency
15:08:51 <steveh> and you won't be able to get that easily in haskell anyway :)
15:10:50 <Darius> Here's a definition of qsort from GHC: http://www.haskell.org/hawiki/HaskellIrcPastePage
15:11:12 <steveh> hmm
15:11:21 <Darius> Of course, for lists you'd want mergesort (which is the new sort definition) anyways.
15:12:50 <socrates2> cheers darius danesh :)
15:12:57 * steveh wonders how often an anti-stable sort is necessary...
15:14:07 <Darius> Of course that definition is a bit gung-ho.  You could probably get the same asymptotic efficiency and a decent actual efficiency without such efforts.
15:14:22 <ad^am> hmmm my brain is not working today, how does one extract the fraction part of a number, like 0.14 from 3.14?
15:14:37 <Riastradh> n - (floor n), maybe?
15:14:59 <Darius> @prelude RealFloat
15:15:03 <ad^am> ah, definatly a posibility
15:15:07 <lambdabot> *** "RealFloat" prelude "Haskell Standard Prelude Dictionary": text follows
15:15:07 <lambdabot> RealFloat
15:15:07 <lambdabot>   class (RealFrac a, Floating a) => RealFloat a where
15:15:07 <lambdabot>       floatRadix       :: a -> Integer
15:15:07 <lambdabot>       floatDigits      :: a -> Int
15:15:09 <lambdabot>       floatRange       :: a -> (Int,Int)
15:15:11 <lambdabot>       decodeFloat      :: a -> (Integer,Int)
15:15:13 <lambdabot>       encodeFloat      :: Integer -> Int -> a
15:15:15 <lambdabot> [there's @more]
15:15:46 <Darius> mm, Floating is probably closer.
15:15:54 <Riastradh> @prelude Floating
15:15:56 <lambdabot> *** "Floating" prelude "Haskell Standard Prelude Dictionary": text follows
15:15:56 <lambdabot> Floating
15:15:56 <lambdabot>   class (Fractional a) => Floating a where
15:15:56 <lambdabot>       pi                  :: a
15:15:57 <lambdabot>       exp, log, sqrt      :: a -> a
15:15:59 <lambdabot>       (**), logBase       :: a -> a -> a
15:16:01 <steveh> why do you say it's gung-ho?
15:16:01 <lambdabot>       sin, cos, tan       :: a -> a
15:16:03 <lambdabot>       asin, acos, atan    :: a -> a
15:16:05 <lambdabot> [there's @more]
15:16:48 <socrates2> -----------
15:16:50 <socrates2> nonZero [] = []
15:16:51 <socrates2> nonZero ls = if head ls == 0 then nonZero (tail ls) else (head ls)  
15:16:52 <socrates2> -------------
15:16:54 <steveh> i think people might attach too much significance to sorting algorithms' complexity in general :)
15:17:07 <socrates2> anyone know whats wrong with this function?
15:17:40 <socrates2> trying to remove a zero values from a list with recursion
15:17:51 <steveh> good ol' homework
15:18:05 <Darius> That's what filter is for
15:18:15 <Riastradh> nonZero = filter (/=0)
15:18:30 <socrates2> yea but i need to use recursion
15:18:42 <socrates2> its the question
15:19:31 <steveh> with a function like that it's best to just try to run it in your head
15:19:46 <Riastradh> Where are you recurring other than in the 'then' branch, socrates2?
15:19:51 <thornber> nonZero [] = []
15:19:52 <thornber> nonZero x:xs | (x == 0) = nonZero xs
15:20:03 <thornber>       | otherwise = x : nonZero xs
15:20:33 <Riastradh> thornber, gah, don't answer his homework problem for him.
15:20:39 <steveh> :)
15:20:43 <thornber> sorry :(
15:21:06 <steveh> socrates2: is this your first programming class?
15:21:50 <socrates2> steveh: in haskell yeah
15:22:09 <steveh> sorry, I meant functional programming
15:22:15 <socrates2> thornber:thanks
15:22:23 <mattam> there is a big typing problem in your definition socrates2 , try giving the type before writing the function
15:22:34 <socrates2> ok
15:23:14 <socrates2> Riastradh: im trying to understand stuff for an exam, its not homework
15:23:29 <steveh> socrates2: the online book at http://www.cs.ou.edu/~rlpage/fpclassCurrent/textbook/haskell.shtml will teach you all you want to know
15:23:30 <Riastradh> OK, so it's not homework, but nevertheless you should be able to figure it out yourself.
15:23:42 <steveh> at least it worked for me
15:25:09 <thornber> is there a quick way to get the index of an item in a list ?
15:25:17 <Riastradh> list !! index
15:25:20 <Riastradh> Oh, no.
15:25:25 <steveh> heheh
15:25:26 <thornber> other way round :)
15:25:27 <Riastradh> List.findIndex list elem
15:25:31 <Riastradh> I think.
15:25:36 <thornber> thx
15:25:38 <Riastradh> @prelude findIndex
15:25:40 <lambdabot> *** "findIndex" prelude "Haskell Standard Prelude Dictionary": text follows
15:25:40 <lambdabot> findIndex
15:25:40 <lambdabot>   findIndex ::  (a -> Bool) -> [a] -> Maybe Int
15:25:40 <lambdabot>   findIndex p              = listToMaybe . findIndices p
15:25:51 <Riastradh> OK, not List.findIndex, but just findIndex from the Prelude.
15:26:01 <Riastradh> Er.
15:26:06 <Riastradh> findIndex (==elem) list
15:26:10 <Riastradh> Er.
15:26:15 <Riastradh> That gets you a Maybe.
15:26:36 <Riastradh> If you're confident it's in there, use 'fromJust (findIndex (==elem) list)'.
15:27:28 <thornber> k
15:27:29 <steveh> that's in the prelude?
15:27:30 <steveh> hmmm
15:29:37 <Darius> the prelude is full of interesting things.  However, @prelude gets things from -all- the standard libraries.
15:29:42 <Darius> @prelude fromJust
15:29:43 <lambdabot> *** "fromJust" prelude "Haskell Standard Prelude Dictionary": text follows
15:29:43 <lambdabot> fromJust
15:29:43 <lambdabot>   fromJust ::  Maybe a -> a
15:29:43 <lambdabot>   fromJust (Just a)      = a
15:29:44 <lambdabot>   fromJust Nothing       = error "Maybe.fromJust: Nothing"
15:29:45 <Riastradh> Oh.
15:29:47 <steveh> ah good
15:29:49 <Riastradh> OK, maybe it is in List.
15:29:54 <steveh> I was getting concerned
15:30:07 <steveh> "wtf is wrong with my ghc install?!?"
15:30:07 <steveh> :)
15:30:20 <steveh> they are all "preludes"
15:30:26 <steveh> but there is only one "Standard Prelude"
15:31:21 <steveh> who maintains lambdabot, shapr?
15:31:31 <steveh> maybe it should give the qualified name at some point
15:31:31 <steveh> :)
15:31:48 <Darius> tmoertel wrote @prelude
15:31:55 <Darius> (I believe)
15:32:39 <Darius> As I responded to Pseudonym at one point, "no one has written a majority of lambdabot"
15:33:12 <steveh> fascinating
15:33:34 <thornber> can I wrap top level decls with a let ?
15:34:17 <Darius> what do you mean?
15:34:49 <thornber> let (letters = "PNBQK") where
15:34:56 <thornber>   charToPiece = ...
15:35:04 <thornber>   pieceToChar = ...
15:35:20 <thornber> (not used let before, so the syntax will be wrong)
15:35:23 <steveh> why don't you like plain  letters = "PNBQK"
15:35:40 <steveh> ?
15:36:04 <thornber> because I don't want to pollute the global namespace
15:36:04 <Riastradh> Presumably, charToPiece and pieceToChar both use letters.
15:36:08 <thornber> y
15:36:46 * thornber tries it ...
15:38:30 <Igloo> Anyone who knows anything about macs, Debian and OS X around?
15:38:49 <steveh> how much debian knowledge do you need?
15:38:58 * steveh is on an OS X machine
15:39:01 * steveh has used debian
15:39:04 * steveh runs freebsd, though
15:39:06 <thornber> I have an iBook, and run debian on my Linux machines
15:39:32 <steveh> ok
15:39:40 <Igloo> Oh, never mind. I was going to ask about the Mac OS 9 disk drivers option, but then noticed it was for the whole disk not per partition
15:39:51 <steveh> :)
15:40:17 <steveh> OS 9 isn't so fun anymore
15:41:58 <Igloo> Do you happen to know the state of HFS+ support on Linux OOI?
15:43:03 <mgoetze> why would linux support such crap? :)
15:43:36 <Igloo> Because my girlfriend wants most of the disk to use it and I want to be able to put useful things on it  :-)
15:44:04 <steveh> what could you possibly want on PPC Linux that you can't have on OS X?
15:44:31 <Igloo> An OS OS and tools
15:44:38 <steveh> well
15:44:58 <steveh> the tools are all there
15:45:08 <steveh> as far as actually running the OS
15:45:32 <steveh> I suppose if you have to run Linux just because it's open-source, then you have to run it :)
15:45:33 <thornber> Darwin is open
15:45:43 <steveh> but I am hard-pressed to think of a Unix tool that won't build under OS X
15:45:54 <steveh> it includes the standard ones already
15:46:00 <Igloo> Ouch, 2.1G to install OS X. I wonder how much is included in that
15:46:17 <steveh> Igloo: what tools do you see yourself running?
15:46:29 <Igloo> steveh: Hey, if I could afford it I'd be buying FPGAs and working on Opencores towards a fully open computer  :-)
15:47:22 * steveh is all for open source but dual-booting is more trouble than it's worth\
15:47:24 <Igloo> My reasons for installing Debian are partly Open principles, partly because I am very familiar with it so can use it easily and partly so I can't break OS X and my GF can't break Debian
15:47:25 <steveh> especially on PPC
15:48:22 <steveh> see, I see that as twice as many things that can break :)
15:48:29 * thornber sleep, bye all
15:48:46 <Igloo> Ah, but I don't care if OS X breaks  :-)
15:49:01 <steveh> you will if it decides that your Debian partition needs to go!
15:49:05 <steveh> not that I expect it will, but.
15:49:09 <grem> In the haskell networking is there any way to make a program read until the end of a packet?
15:49:35 <steveh> Linux is undersupported on PPC
15:49:46 <steveh> and OS X runs just about any tool you care to name
15:50:26 <steveh> plus you won't have the annoyance of rebooting all the time
15:50:42 <steveh> If you really want to, you can run an X11 environment
15:51:07 <steveh> plus I suppose the filesystem is arranged differently under OS X than it is in Debian
15:51:10 * Igloo probably won't use it much, but this means I can borrow it if I go away with no hassle
15:51:37 <steveh> s/filesystem/file hierarchy/
15:51:37 <Igloo> Although lack of GHC might be annoying
15:52:00 <steveh> there is hugs
15:52:04 <steveh> in a pinch
15:52:53 <Igloo> But a lot of what I do uses TH
15:53:47 <Igloo> Maybe it will motivate me to try and get a working PPC build into Debian
15:53:52 <steveh> I'm sure the ghc project would like a maintainer for ghc-ppc
15:53:54 <steveh> exactly
15:53:56 <steveh> :)
15:53:59 <Igloo> I think someone had it working under OS X, so hopefully porting it shouldn't be *too* hard
15:54:17 <Igloo> Once it's built once it shouldn't need a separate maintainer
15:54:30 <Darius> Didn't pesco get it working on ppc?
15:54:49 <Igloo> That would be easier still
15:56:51 <steveh> none of this helps to dissuade from installing the dual-boot :)
15:57:15 <Darius> yes it does
15:57:32 <Igloo> 1.5 hours remaining...*sigh*
15:57:34 <Darius> If GHC were a nightmare to support on linux/ppc then it would be less worthwhile.
16:04:14 <steveh> actually the ghc page has an installer for OS X
16:04:29 <steveh> fascinating, when I last looked into it it wasn't supported
16:04:41 <steveh> Wolfgang Thaller is the man to thank for that, apparently
16:04:42 <Darius> That doesn't help Igloo though
16:04:58 <steveh> ooooh I see
16:05:01 <Darius> In a month though it may.
16:05:33 <steveh> the build for ppc/linux is "without ghci support"
16:05:33 <Igloo> Well, I think it makes it easier to port
16:05:43 <steveh> according to the ghc page
16:18:10 <Igloo> Every time I look at the installer it's installing printer drivers
16:19:57 * Igloo coincidentally reads a commit message from wolfgang for the PPC NCG  :-)
16:22:48 <Igloo> What's OS X doing when it says "Optimizing system performance"?
16:23:10 <Smerdyakov> Prank calling Bill Gates
16:31:56 <opet> OS X does some kind of prebinding I think.. maybe it's sorting that out?
16:34:28 <Igloo> Is that like prelinking?
16:40:30 <opet> I think they're the same thing, although I don't know much about it
16:40:39 <opet> so I'm probably wrong
16:42:21 <Igloo> :-)
16:42:51 * opet has just been trying to work out freebsd-current thread on prebinding
16:44:09 <opet> not knowing much about elf, executables and linking in general doesn't help
16:52:56 * steveh is back
16:53:25 <steveh> yes, "optimizing system performance" is a more userfriendly way of saying "update_prebinding"
16:55:04 <steveh> all it does is decrease application startup time afaik
16:55:46 <Igloo> It's not more Igloo-friendly  :-)
16:56:41 <steveh> in software and hardware development there is a common maxim "optimize for the common case" :)
16:58:03 * steveh ponders checking this ghc .dmg out
16:58:23 <steveh> seems silly though when I already have a perfectly good ghc on my other machine
16:58:35 <Igloo> Hmmm, I'd pronounce that "damage"...how fitting  :-)
16:58:59 <steveh> as in, "What's your major damage, Heather?"
16:59:19 <Igloo> IDGI
16:59:54 <steveh> never mind, the quote isn't "major damage," just "damage"
17:00:10 <steveh> and it's actually "Heather, what's your damage?
17:00:39 <steveh> or not
17:00:47 <steveh> google is sketchy on the matter ... oh well
17:00:47 <steveh> :)
17:01:33 <steveh> http://us.imdb.com/Title?0097493
17:02:03 <ad^am> google mostly puts heather after whats your damage
17:02:23 <steveh> ad^am: I think you're right ... been a while since I've seen the film
17:03:27 <ad^am> http://www.best.com/~sirlou/damage.WAV
17:03:49 <ad^am> er gotta get it from the page i think
17:03:50 <Igloo> Ah, haven't seen it
17:04:04 <ad^am> hrm nope, that doesn't work either, bah
17:06:28 <steveh> aah yes
17:06:31 <steveh> "This is Ohio. If you don't have a brewski in your hand you might as well be wearing a dress."
17:07:43 <ad^am> i've actually never seen heathers, its near the top of my list of movies to see though
18:55:27 * Riastradh needs to decide what sort of a class he'll teach over the summer, and he thinks he wants to teach something about Haskell.
18:55:53 <Riastradh> Exactly what sort of class, that is.
19:04:08 <steveh> what level of class is it?
19:04:24 <saz> teaching haskell is pretty fun
19:05:01 * Riastradh hasn't decided, steveh.
19:05:29 <steveh> well, are we talking primary, secondary, higher education?
19:05:29 <steveh> :)
19:05:47 <Riastradh> Er...
19:07:09 <Riastradh> @yow
19:07:10 <lambdabot> Why are these athletic shoe salesmen following me??
19:07:47 <steveh> what is the origin of @yow?
19:07:59 <Riastradh> @yow , it's a scary origin.
19:08:00 <lambdabot> .. If I cover this entire WALL with MAZOLA, wdo I have to give my
19:08:00 <lambdabot>  AGENT ten per cent??
19:08:35 <flippo> steveh: "Yow!" was a frequent exclamation of Zippy the Pinhead, the source for those quotes
19:09:39 * steveh is afraid that shed no light on the subject.
19:10:03 <Riastradh> You've never heard of Zippy the Pinhead!??
19:10:04 <flippo> steveh: http://www.zippythepinhead.com/
19:28:32 * Pseudonym thinks Riastradh has some requirements analysis to do
19:29:41 <Riastradh> 'Requirements analysis?'
19:29:43 <Pseudonym> Does anyone here know anything about linear programming algorithms, in particular for very sparse problems?
19:29:53 * Riastradh doesn't know anything about the students yet.
19:29:57 <Pseudonym> Ah, I see.
19:30:04 <Riastradh> The students will sign up based on what the class is.
19:30:29 <Pseudonym> Chicken, egg, etc.
19:30:36 <Lilith> sparse problems?
19:30:37 <Lilith> hmm
19:30:40 <Pseudonym> Yes.
19:30:48 * Pseudonym doesn't want to use a dense matrix if he can avoid it
19:31:23 * Lilith just had her thesis presentation today
19:31:24 <Lilith> whee
19:31:27 <Lilith> one thing over
19:31:28 <Lilith> :)
19:31:30 <Pseudonym> Woohoo.
19:31:33 <saz> yay :)
19:31:34 <Pseudonym> How'd you go?
19:31:41 <Lilith> it sucked, but i pass
19:32:02 <Lilith> (it's pass/fail)
19:32:18 <Pseudonym> Congrats.
19:32:36 <Chilli> Lilith: it didn't suck!  You did fine.
19:32:47 <flippo> I recommend fermented beverages to celebrate
19:33:04 <Lilith> hehe
19:33:18 <Chilli> Besides, you put a lot of effort into the slides, which is always good, because independent of whether you are nervous or not, they don't change :-)
19:33:27 <Lilith> i'll put up what i actually meant to say on my website 
19:33:28 <Lilith> hehe
19:33:35 <Chilli> ok :-)
19:33:37 <Lilith> i was going to have that backup sheet as you said
19:33:37 * Pseudonym would be interested in that, actually
19:33:52 <Lilith> but i forgot to print it :p
19:33:56 <Chilli> oh
