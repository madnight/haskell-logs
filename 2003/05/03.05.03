02:08:02 <seth_> I'm trying to get rid of calls to unsafePerformIO.  I'm stuck on how to check whether a value of type IO String has zero length.  I can write a function that returns IO Bool, but I'm not sure how to code a test (such as == True) for an IO Bool
02:11:04 <Marvin--> if you're in IO, you're in IO, you cannot safely get out (that's why it's called *unsafe*PerformIO :)
02:12:02 <Marvin--> you could write an  ifM :: IO Bool -> IO a -> IO a -> IO a  function
02:13:11 <seth_> Let me be more specific.  I have a recursive function, and one of the arguments is set by a call to hGetLine.  I want to terminate the recursion when hGetLine returns IO "".
02:13:22 <seth_> Is there a pattern for that?
02:13:28 <seth_> Or something I can use in a guard?
02:14:25 <Marvin--> uh, what does the call look like? What's the type of the recursive function?
02:14:54 <seth_> Socket -> IO String -> [IO String] -> [IO String]
02:15:13 <Marvin--> and what is it supposed to do?
02:15:32 <Marvin--> no IO will "happen" in that function
02:15:37 <seth_> If the IO String parameter is not "", add it to the list of [IO String]
02:16:00 <Marvin--> but IO String is not String, you can't compare IO String to a String
02:16:03 <seth_> OK, then let's back up.  I want to read lines from a file, add them to a list of lines, and stop when I read a blank line
02:16:07 <Marvin--> IO is a type, like any other
02:16:25 <seth_> OK, but IO String is the only thing that the IO functions return.
02:16:25 <Marvin--> then you most likely want  IO [String]  as return type
02:16:40 <seth_> Oh, OK, but I don't see how that solves this problem.
02:16:45 <Marvin--> yes, you have to be in a function of type IO a for some a to be able to inspect the result
02:17:02 <seth_> I am, but I still don't see where that helps.
02:17:32 <Marvin--> what do the various parameters do? What does the [IO String] do? and what is the IO String?
02:17:36 <Marvin--> where is the actual reading?
02:18:10 <seth_> Again, instead of looking at my code, which is probably wrong, let's talk about what I need to do.  I have a socket.  I read lines from the socket, and I put the lines in a list until I read a blank line.
02:18:21 <seth_> How do I do that?
02:18:47 <seth_> I can do it with unsafePerformIO, but as I understand it I should try to avoid that
02:19:01 <Marvin--> no you cannot do it with unsafePerformIO, that will break sooner or later :)
02:19:12 <seth_> ok, then what is the correct way to do it?
02:19:48 <Marvin--> I'd do it like this:  getLines sock = do { l <- hGetLine sock ; if null l then return [] else do { ls <- getLines sock ; return (l:ls) } }
02:20:02 <Marvin--> (feel free to break it up in lines :)
02:20:34 <Marvin--> getLines :: Socket -> IO [String]   in this case
02:20:42 <Marvin--> @type hGetLine
02:20:50 * Marvin-- prods lambdabot
02:20:58 <seth_> Its IO String
02:21:07 <seth_> let me try that.
02:22:35 <seth_> I can't do it that way, because I have to process the hGetLine output before I test it, but maybe I can fit that into this method.
02:23:10 <seth_> I can just make a function that does what I need and returns IO String, and call that instead of hGetLine
02:24:18 <seth_> Oh, I see what you did, you put the recursive call inside of a nested combinator
02:24:59 <Marvin--> the point is that inside 'do', you use x <- f to be able to inspect the result of f
02:25:35 <seth_> That's not the point at all.  I didn't have any trouble inspecting the string.  I had trouble doing something useful after I inspected the string.
02:25:43 <Marvin--> uh, okay
02:26:22 <seth_> I often get the wrong advise, because everyone assumes that the problem is getting the String from IO String.  But that is trivial.
02:26:43 <Marvin--> well, I simply must not understand what it is you want
02:26:57 <seth_> The problem in this case is that I was trying to inspect the string in a separate function, or inspect the string in a guard.
02:27:25 <seth_> And a separate function returns IO Bool instead of Bool, which doesn't help.  And you apparently can't use the tricks for removing the IO within a guard
02:27:53 <seth_> The reason that what you wrote may work is that you nested a do within another do, and made the recursive call from within the nested do.
02:27:56 <Marvin--> of course not, a guard takes a boolean expression, not a monadic expression
02:28:10 <Marvin--> well, that's what you always do
02:28:30 <seth_> Nowhere, in ANY documentation, will you find a single word about that.
02:28:53 <seth_> And, in a normal (that is, not monadic) setting, you don't have to do that at all.
02:29:07 <seth_> you can have a pattern like    func whatever "" whatever = do something
02:29:16 <seth_> which you can't do in the monadic setting
02:29:40 <seth_> but all the documentation shows examples like that, and ONLY examples like that.
02:29:40 <Marvin--> huh? I'm not following
02:30:15 <seth_> I'm just trying to explain why the documentation is so confusing.
02:30:37 <seth_> because, in most cases, you can't do in the monadic settings any of the techniques shown in all the books and papers.
02:31:16 <seth_> And you won't find, in Thompson's book, or Hudak's book, a single example with nested do's.  I know, I've read both twice.
02:31:49 <Marvin--> if you think about it, it's pretty natural though, the if expression is a function :: Bool -> a -> a, and in the monadic code, you've got (>>=) :: Monad m => m a -> (a -> m b) -> m b, so both branches of the if must also have monadic values, how do you usually create monadic values? Using do
02:32:28 <seth_> You are missing the point.  The problem is not that I don't know how to create monadic values.
02:32:50 <seth_> That's explained in the second paragraph in Thompson's book when talking about monads
02:32:59 <Marvin--> and at least Thompson's book doesn't have a whole lot about monads at all
02:33:06 <seth_> That's quite true.
02:33:41 <seth_> But look at any of the docs, in wiki, in the doc pages for the various monads.  You won't see examples of how to do anything typical.
02:33:55 <seth_> My point is this.
02:34:15 <Marvin--> I'm looking at page 388 in Thompson here..   putNtimes n str = if n <= 1 then putStrLn str else do { putStrLn str ; putNtimes (n-1) str }
02:34:25 <Marvin--> well, all right, still only one 'do'
02:34:29 <seth_> exactly
02:34:35 <seth_> and not the same situation at all.
02:34:57 <seth_> The key here is where you make the recursive call, not monadic values.
02:35:01 <Marvin--> okay
02:35:15 <seth_> Now that you showed me, I see it, but it isn't obvious.
02:35:36 <Marvin--> on page 392 he creates a while function...   while test action = do { res <- test ; if res then do { action ; while test action } else return () }
02:35:44 <seth_> I think I'll write a "monads for the functionally challanged"
02:35:49 <Marvin--> heh
02:36:05 <seth_> but that won't work, because in any real situation test action would have to be monadic, and we just said you can't do that.
02:36:24 <seth_> if I could have written "while test xxx"  where xxx is that my string is empty, it would have been no problem.
02:36:32 <seth_> although it is a nested do which I missed.
02:36:38 <Marvin--> but test *is* monadic, it's Monad m => m Bool
02:36:44 <seth_> but the first test action is outside the do
02:36:59 <Marvin--> no, that's the lhs of the function definition
02:37:07 <seth_> you can't say  if XXXXX then,   if XXXXX is IO Bool
02:37:29 <Marvin--> exactly, which is why the code says  do { res <- test ; if res then ...
02:37:59 <seth_> no, you don't get there unless the while test action is true, so that is the wrong part of the statement to look at.
02:38:11 <seth_> it's not the same situation at all.
02:38:16 <Marvin--> I'm not following
02:38:36 <seth_> I know, I'm not explaining it correctly.
02:39:02 <seth_> let me finish coding this function and see if the compiler accepts it.
02:40:31 <seth_> no, it almost works, but says:
02:40:42 <seth_>     Couldn't match `[a]' against `IO String'
02:40:43 <seth_> 	Expected type: [a]
02:40:43 <seth_> 	Inferred type: IO String
02:40:43 <seth_>     In the first argument of `null', namely `li'
02:40:43 <seth_>     In the predicate expression: null li
02:40:57 <Marvin--> can you put the code online somewhere?
02:41:13 <seth_> OK, hold on.
02:41:14 <Marvin--> or we could go to #flood
02:41:24 <seth_> let's do #flood, it isn't very big.
02:56:55 <seth_> I have this large program almost completed implemented in Haskell (and Ruby and ocaml), and I was stuck there.
02:57:20 <seth_> ocaml didn't force me to really do functional programming
02:58:21 <Marvin--> that's the bad thing about ocaml :)
02:58:58 <seth_> when I did the first pass from ruby, I implemented a lot of things as classes.  Then I went back to see where I _really_ needed a class.  Answer:  nowhere.
02:59:39 <seth_> there wasn't a single case where using a class was better.  which surprised me a bit.
03:04:23 <Jerub> classes in single instances are irrelevent.
03:04:33 <Jerub> its reuse and interaction that make them useful.
03:05:12 <seth_> you get exactly the same reuse from a properly constructed module.
03:05:24 <seth_> The class is only better if dynamic dispatching is necessary
03:06:38 <Jerub> *shrug*
03:31:41 <BlitzNL> I am working on my haskell skills lately and it seems that I run into the situation where I want to apply a function 'n' times and eventually apply it to the initial value. To accomplish this I wrote a function exec, but there must be a better way, right ;)
03:31:42 <BlitzNL> exec f i ini
03:31:42 <BlitzNL>   | i > 0     = f (exec f (i-1) ini)
03:31:42 <BlitzNL>   | otherwise = f ini
04:07:45 <seth_> BlitzNL: there isn't anything especially wrong with that.
04:07:52 <seth_> You could do it this way:
04:08:07 <seth_> no, forget it.
04:08:24 <seth_> I was going to use a pattern, but that won't work with i > 0, only with i == 0
04:08:40 <seth_> but wait
04:09:18 <seth_> is f a function of one variable?
04:10:43 <opet> hmm.. what do you guys use to typeset haskell in latex?
04:11:51 <seth_> opet: I'm not one of the guys who knows that.  :)
04:12:33 <BlitzNL> seth_: f is a function
04:12:51 <seth_> BlitzNL: right, with how many arguments?
04:12:59 <seth_> BlitzNL: One?
04:13:17 <BlitzNL> no two
04:13:37 <seth_> then I don't think the  | otherwise = f ini   is what you want.  Did you intend a partial application there?
04:14:37 <BlitzNL> why not it works but it just looks like something that is in the prelude or something. I can paste the rest wait
04:14:54 <seth_> BlitzNL: no reason why not, if that is what you meant to do.
04:14:55 <dennis> BlitzNL: take a look at iterate
04:15:05 <BlitzNL> unbwt enc = exec (shiftenc enc) (length enc - 3) initcolumns
04:15:05 <BlitzNL>   where
04:15:05 <BlitzNL>     initcolumns = sort (shiftenc enc ((map (\c -> [c])) (sort enc)))
04:15:05 <BlitzNL>     shiftenc enc rest = sort (zipWith (\a b -> a : b) enc rest)
04:15:13 <BlitzNL> dennis: mm ok i will
04:15:37 <dennis> http://www.haskell.org/onlinereport/standard-prelude.html#$viterate
04:30:56 <BlitzNL> dennis: using iterate works fine 'last (take (length n) (iterate (shiftenc enc) initcolums))', thnx
04:31:36 <dennis> BlitzNL: it's not much easier then to write your own function, but at least it's a prelude function
04:32:10 <BlitzNL> dennis: yeah my goal is indeed to use as much prelude as possible
04:33:30 <BlitzNL> dennis: and it also turns out to be slightly more efficient ((3600 reductions, 7856 cells) against (3531 reductions, 7763 cells)) ;-)
04:34:51 <dennis> BlitzNL: you could make your more efficent also I think. Also, this is in the interpreter, a compiler might take away the difference
04:35:28 <dennis> BlitzNL: you don't have to pass around ini in each recursive call, maybe it would make it faster
04:35:45 <BlitzNL> dennis: don't spoil my moment ;)
04:36:06 <Marvin--> BlitzNL: ehhh... last (take (length n) ...)  sounds silly, why not  head (drop (length n - 1) ...) ?
04:37:11 <dennis> or use !! if one never use it with negative values 
04:38:29 <BlitzNL> Marvin--, dennis: mmm
04:44:49 <BlitzNL> Marvin--: you're right, it much better thnx
05:07:21 * shapr boings happily
05:07:25 <shapr> tmoertel: you called?
05:15:51 <sjj> shapr! ;)
05:16:02 <shapr> y0 sjj 
05:16:03 <shapr> wassup?
05:16:15 <sjj> doing a bit of work, hacking selectmodule.c .. you?
05:16:27 <shapr> doing a bit of paying work
05:16:35 <sjj> *nod*
05:16:48 <shapr> and playing with lambdabot in the bits of spare time
05:17:01 <sjj> I know this is the wrong channel, but do you know much about hotshot?
05:19:10 <shapr> never heard of it
05:19:40 <shapr> what is it?
05:19:42 <sjj> profiler module
05:20:35 <shapr> oh, for python
05:28:24 * shapr wishes for a Haskell nntp module
05:29:33 <opet> no genie about?
05:30:38 <shapr> I have a nice little art deco lamp here I could rub
05:30:49 <shapr> though it might electrocute me if I'm not careful
05:34:31 <BlitzNL> I can do something like 'data Bla = ... deriving Show', but can I influence the way a datatype is pprinted ?
05:35:40 <opet> do the instance declaration yourself
05:37:02 <BlitzNL> opet: ok I'll look into it thnx
06:10:48 <elmex> hey, i don't want to post this to the ghc-users-mailing list, maybe it's a stupid question, but when looking at the examples in the directory ghc/misc/examples/ (in the current ghc­5.05.20030430 tarball) and trying to compile them, it comes out that it is missing readSocket
06:11:00 <elmex> (compiled with ghc -o tet Main.hs -package net)
06:19:02 * shapr looks
06:19:24 <shapr> hi elmex 
06:19:25 <elmex> it's using SocketPrim, which seems to be moved to Network.Socket
06:19:31 <elmex> shapr: hi ;-))
06:20:57 <shapr> the name of your gateway box is cute
06:21:11 <elmex> pandora.labs.dn-systems.de ?
06:21:22 <elmex> it's just temporary... from my company
06:21:30 <elmex> it should be elmex.x-paste.de ;-)
06:21:34 <shapr> I call a computer a "box" so that would be "pandora's box"
06:21:42 <elmex> ;-))
06:22:12 <elmex> btw. how experimental is the Concurrent stuff?
06:22:23 <elmex> has it at least a bit matured? ;-)
06:22:25 <shapr> works for me
06:22:29 <elmex> okay
06:22:31 <shapr> lambdabot is using concurrent
06:23:01 <shapr> lambdabot: @hello
06:23:05 <elmex> well *g* i just thinking about some irc-client too... but argh... it just sucks writing an irc-clinet in every new language i learn
06:23:22 * shapr pokes lambdabot 
06:23:23 <shapr> lambdabot: y0
06:23:35 <shapr> oh, it's lagging
06:23:41 <lambdabot> Hello world. 
06:23:42 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
06:23:47 <elmex> does it understand ping?
06:24:01 <elmex> oh, no, he doesn't know ctcp ;-)
06:24:04 <shapr> I don't think so
06:24:08 <shapr> you could add that ;-)
06:24:09 <shapr> @fact source
06:24:09 <lambdabot>  http://sf.net/projects/haskell-libs/, http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
06:24:28 <shapr> oh, I have to update the chess plugin
06:24:30 <shapr> lambdabot: @quit
06:26:45 <elmex> hm, i guess, i will look for some other crap to create some code for, nooone ever needs
06:27:08 <shapr> I need an nntp module
06:27:21 <shapr> elmex: look at http://sf.net/projects/haskell-libs/
06:27:23 <elmex> uh, hm, i don't read much usenetnews
06:27:33 <shapr> bunch of people getting together to write libraries for Haskell
06:28:31 <elmex> i'm not much of a haskell/functional programmer (yet)
06:28:57 <shapr> that sourceforge projects is sort of a cvs-wiki for this channel
06:29:05 <shapr> and for haskell developers in general
06:29:18 <elmex> cvs-wiki? everyone throws code in?
06:29:30 <shapr> something like that, yah
06:29:49 <shapr> right now we have a web-server, an irc 'bot, chess playing code, some crypto code, some email code
06:29:58 <shapr> exact real number code
06:30:02 <shapr> lots of interesting bits
06:30:24 <elmex> you need a ircd in haskell ;-)))
06:30:42 <elmex> but i hate to write the routing-code for it. so i won't write any ;)))
06:31:25 <shapr> lambdabot uses two threads, one for reading one for writing
06:31:35 <shapr> I bet it would fun to extend it to bridging between networks
06:31:57 <elmex> you mean, using a client as gateway?
06:32:03 <shapr> yah
06:32:06 <shapr> between two networks
06:32:16 <elmex> uh, hm, why?
06:32:24 <shapr> I wonder if there's a #haskell on oftc, EFNet, etc
06:32:34 <shapr> just for the fun of writing code :-)
06:32:44 <elmex> ;-)))) well, yes 
06:32:45 <opet> it's virtually empty on efnet
06:32:55 <shapr> @listmodules
06:32:55 <lambdabot> I have the following modules installed: ["chess","dict","eval","fact","fortune","hello","karma","more","searchml","state","system","topic","type","yow"]
06:33:05 <opet> and only has ibid in on oftc
06:33:20 <elmex> i wrote a quick and dirty client with my knowledge of haskell yet, here is the main routine:
06:33:29 <elmex>   do args <- getArgs
06:33:30 <elmex>     case args of
06:33:30 <elmex>       [] -> putStr "Usage: client <hostname>\n"
06:33:30 <elmex>       x  -> do putStr $ "Connecting " ++ (head args) ++  " ...\n"
06:33:30 <elmex>                conn $ head args
06:33:37 <elmex> wait
06:33:53 <elmex> the cool thing, i love are those forkIO
06:33:54 <elmex>      forkIO $ readLines sock
06:33:54 <elmex>      forkIO $ sendLines sock 0
06:33:54 <elmex>      readConsole sock
06:34:14 <shapr> elmex: lambdabot will stretch your brain
06:34:27 <elmex> at some points this is MUCH easier in haskell than in Perl 
06:34:46 <shapr> @board
06:34:46 <lambdabot>  r n b q k b n r
06:34:46 <lambdabot>  p p p p p p p p
06:34:46 <lambdabot>  - - - - - - - -
06:34:46 <lambdabot>  - - - - - - - -
06:34:46 <lambdabot>  - - - - - - - -
06:34:47 <lambdabot>  - - - - - - - -
06:34:49 <lambdabot>  P P P P P P P P
06:34:51 <lambdabot>  R N B Q K B N R
06:34:57 <elmex> stretch my brain?
06:35:17 <elmex> ohmygodachessinircchannelpleasenot
06:35:21 <shapr> yah, lambdabot sources range in difficulty from the simplicity of writing plugins to the insanity of layered monad transformers
06:35:55 <elmex> monad transformers?
06:36:19 <shapr> you know about monads?
06:36:44 * tmoertel makes steel-cut oats for breakfast
06:36:45 <elmex> well, yes, i know how to do some stuff with it and that >> >>= stuff. and do and all that.
06:37:02 <shapr> right, so you know that "IO a" is the IO monad, yah?
06:37:11 <shapr> good morning tmoertel!
06:37:21 <tmoertel> 'morning, shapr!
06:37:38 <shapr> tmoertel: I saw the new dict commands, spiffy!
06:37:45 <elmex> shapr: well.. uh.. hm. not really
06:37:55 <elmex> i'm still a bit confused about that type-stuff
06:37:59 <tmoertel> @prelude monad
06:38:01 <lambdabot> *** "monad" prelude "Haskell Standard Prelude": text follows
06:38:01 <lambdabot> Monad
06:38:01 <lambdabot>   class Monad m where
06:38:01 <lambdabot>       return :: a -> m a
06:38:02 <lambdabot>       (>>=)  :: m a -> (a -> m b) -> m b
06:38:04 <lambdabot>       (>>)   :: m a -> m b -> m b
06:38:06 <lambdabot>       fail   :: String -> m a
06:38:09 <lambdabot>       -- Minimal complete definition: (>>=), return
06:38:14 <tmoertel> @more
06:38:15 <shapr> tmoertel: whoa, where'd that come from?
06:38:15 <lambdabot>       p >> q  = p >>= \ _ -> q
06:38:15 <lambdabot>       fail s  = error s
06:38:18 <lambdabot> [ DONE ]
06:38:21 <shapr> @dict-help
06:38:23 <lambdabot> I perform dictionary lookups via the following 13 commands:
06:38:23 <lambdabot> @all-dicts .. Query all databases on dict.org
06:38:24 <lambdabot> @devils ..... The Devil's Dictionary
06:38:26 <lambdabot> @easton ..... Easton's 1897 Bible Dictionary
06:38:28 <lambdabot> @elements ... Elements database
06:38:30 <lambdabot> @foldoc ..... The Free On-line Dictionary of Computing
06:38:32 <lambdabot> @gazetteer .. U.S. Gazetteer (1990)
06:38:34 <lambdabot> @hitchcock .. Hitchcock's Bible Names Dictionary (late 1800's)
06:38:35 <shapr> oy
06:38:36 <lambdabot> @jargon ..... Jargon File
06:38:41 <shapr> @more
06:38:41 <lambdabot> @prelude .... Haskell Standard Prelude
06:38:41 <lambdabot> @vera ....... V.E.R.A.: Virtual Entity of Relevant Acronyms
06:38:42 <lambdabot> @web1913 .... Webster's Revised Unabridged Dictionary (1913)
06:38:44 <shapr> aha
06:38:44 <lambdabot> @wn ......... WordNet (r) 1.7
06:38:45 <shapr> there it is!
06:38:46 <lambdabot> @world02 .... CIA World Factbook 2002
06:38:59 <shapr> wow, that's handy
06:39:21 <tmoertel> that was kind of the point of the dict module
06:39:27 <shapr> :-)
06:39:29 <tmoertel> the other dictionaries are icing on the cake, so to say
06:39:57 <shapr> I'd like to write a haddock module, but I rely on ghci to play with the code I've written, and FastMutInt.hs kills ghci
06:40:41 <tmoertel> I had to tease the definitions out of the Prelude code in Hugs
06:41:01 <tmoertel> I hacked -- and I *do* mean hacked -- together a bit of Perl to do it
06:41:04 <shapr> have you seen fit.c2.com ?
06:41:10 * tmoertel looks
06:41:31 <shapr> lets you use a wiki to input unit tests
06:42:11 <tmoertel> interesting
06:43:20 <shapr> I have this idea for some combination of haddock and hws-wp to allow you to input unit tests and see the results immediately on the haddock docs
06:44:55 <shapr> any thoughts?
06:44:59 <tmoertel> So you specify a category for test cases in your source code?
06:45:14 <tmoertel> And haddock/hws-wp/shapr-thing then grabs all the cases in that
06:45:26 <tmoertel> category, runs them, and places the results into the commentary for
06:45:31 <tmoertel> your code in the haddock docs?
06:46:17 <shapr> yup
06:47:16 <elmex> shapr: the type IO a means i have to use this action stuff >> or do?
06:47:20 <shapr> of course, haddocks could include both quickcheck and hunit tests
06:47:32 <shapr> elmex: yah, sort of
06:47:58 <elmex> shapr: hmm, ok... well
06:48:13 <shapr> elmex: thing is, there's some invisible state being passed along with the >> or >>= calls
06:48:40 <shapr> tmoertel: one advantage would be the ability to write demo code that is both unit test and demo
06:48:49 <shapr> tmoertel: what do you think? would it be useful/interesting?
06:49:07 <elmex> shapr: ah, ok
06:49:27 <shapr> elmex: http://www.dcs.gla.ac.uk/~nww/Monad.html
06:49:31 <tmoertel> it would be useful in that the results of test cases would be visible to users of the docs
06:50:25 <shapr> might make it easier to get unit tests for ghc stuff also
06:50:36 <elmex> shapr: ah, okay. thanks. will read that... once i got out of this flirt-chat here ;-))
06:50:42 <elmex> (not #haskell)
06:50:45 * shapr laughs
06:50:46 <shapr> aww
06:51:54 <elmex> there is no other way for a geek to find contact to girls
06:57:11 <elmex> 'He, 18, searchs a girl for sex and exchanging haskell sources.'
06:57:37 <shapr> well, my fiancee just fixed her mandrake installation today
06:57:43 <shapr> and I wasn't able to do that yesterday ;-)
07:04:15 <elmex> mandrake... uh
07:04:32 <shapr> she got tired of having to ask me to fix her debian installation.
07:04:43 <shapr> she wanted one she could install and admin by herself
07:04:44 <elmex> whats bad about debia?
07:04:45 <elmex> an
07:04:50 <elmex> uh, ok
07:18:47 <shapr> haskell r0xx0rs!
07:19:53 <elmex> hm
07:20:01 <shapr> ?
07:20:02 <elmex> h42k311
07:20:09 <shapr> whoa
07:20:10 <elmex> ah, no
07:20:12 <elmex> h45k311
07:20:17 <shapr> that too 1337 for me
07:21:52 <elmex> hm, my post-code is totally eleet
07:22:08 <elmex> it's 31137
07:22:24 <shapr> post code?
07:22:29 <shapr> power on self test?
07:22:44 <elmex> hm, no i mean for the mail-delivery (real mail ;)
07:22:50 <elmex> it's germany
07:22:59 <elmex> i don't know how to translate it
07:23:31 <shapr> oh
07:23:48 <opet> for the US it's zip code, we use post code in the UK
07:23:49 <shapr> well, post is the correct british way to say it
07:24:25 <elmex> yes, postcode, or zipcode
07:34:40 * shapr bounces happily
07:37:00 <shapr> anyone here knows whether MS Access supports "select * from bar where bar.foo like '%blah%';" ?
07:37:32 <shapr> I've been unable to figure out a valid Jet 4.0 query that uses "like"
07:41:33 <Segora> shapr: is there no grammar for valid queries?
07:41:37 <Segora> (hi btw)
07:41:40 <shapr> hi
07:41:42 <shapr> I don't know
07:41:58 <Segora> hmm. got no docs?
07:42:01 <shapr> I don't own a copy of ms access, but the mdac components come with the Jet 4.0 engine
07:42:15 <Segora> what's jet 4.0?
07:42:25 <shapr> the actual engine that ms access uses
07:42:32 <Segora> ah
07:43:50 <shapr> a client asked me to do some MS Access work, and I don't feel like putting more money into Bill's pocket.
07:45:39 <Segora> hmm. I only found a 3.0 quickref which doesn't seem to completely describe where clauses.
07:46:26 <shapr> I found an intro that shows an example with one single percent wildcard
07:46:33 <shapr> maybe it just doesn't like me using two wildcards
07:47:23 <Segora> hmm
07:54:17 * shapr wishes for a working HaskellDB
07:55:13 <shapr> y03
08:03:10 * shapr boings
08:03:16 <shapr> @yow
08:03:16 <lambdabot> My LIBRARY CARD expired...
08:03:22 <shapr> hi dnm 
08:11:40 <Igloo> <-- graduate!
08:11:45 * Igloo bounces
08:12:25 * Smerdyakov has to take 4 final exams before graduating =(
08:12:31 <shapr> Igloo: you graduated?
08:13:12 <Igloo> Yup
08:13:19 <Smerdyakov> So. Does anyone want to recommend interesting summer jobs that I could still arrange?
08:13:31 <Smerdyakov> I can travel anywhere, especially if you pay ;-)
08:14:07 <Marvin--> Igloo: cool, congratulations
08:14:18 <shapr> Igloo: congraduations!
08:14:51 <Marvin--> shapr: *groan*
08:15:09 <shapr> :-)
08:28:35 * shapr boings
08:37:45 * Segora bum-tchaks.
08:38:21 * shapr shebangs
08:45:12 <shapr> hrm, how does UNIQUE fit into a SQL query?
08:45:15 <shapr> I've forgotten :-/
08:46:00 <Smerdyakov> I don't think it has to do with queries, but rather with table definitions.
08:46:38 <shapr> I thought I could "select unique foo from bar"
08:46:47 <Smerdyakov> Do you mean DISTINCT?
08:46:53 <shapr> ohhh maybe so
08:47:34 <shapr> Smerdyakov: thanks!
08:47:41 <shapr> that was a braino on my part
08:47:48 <Smerdyakov> Draino in the braino?
08:48:46 <shapr> yah, something like that
08:50:22 <shapr> hi jak 
08:50:30 <jak> yo shapr
08:50:34 <shapr> wassup?
08:50:37 <jak> lol
08:50:45 <jak> trying to build a debian kernel atm
08:50:55 <jak> but I am sorely confused by --initrd option to make-kpkg
08:51:54 <jak> what you up to?
08:54:21 <shapr> I've never used the initrd option with make-kpkg
08:54:29 <shapr> but I do like make-kpkg lots
09:02:38 <jak> the hawiki is pretty cool
09:04:10 <shapr> yah it is
09:04:22 <elmex> btw. is there some mysql binding for haskell?
09:04:35 <shapr> @fact htoolkit
09:04:35 <lambdabot>  http://sf.net/projects/htoolkit,  postgresql mysql and odbc bindings
09:04:49 <shapr> the @fact plugin is using the postgresql binding
09:05:22 <jak> do you understand the 'pass' function for MonadWriter class?
09:05:28 <shapr> not me
09:25:49 <shapr> hi HunterPrey 
09:32:16 <tmoertel> jak: it looks like 'pass' is used to modify what's "inside" the writer
09:41:00 <HunterPrey> hey
09:41:58 <Darius> My take on pass is it's the most general primitive for filtering in a Writer monad.  I imagine censor would be a more common usage.
09:42:39 <shapr> any odbc clueful people here?
09:42:52 <shapr> I'm getting a unicode conversion error with code and data that formerly worked...
09:51:00 <jak> tmoertel: yes, it's a bit strange -- I don't understand why the wiki stresses the "first" argument
09:56:37 <Darius> I wrote that
09:57:27 <Darius> It's because I think of it as filtering what is written, but it's only what is written in the first argument, which is the same thing that's returning the filtering function.
09:58:28 <Darius> However, I haven't really used Writer and I'm somewhat fuzzy on what pass is used for.  tell and listen are obvious enough
09:58:38 <jak> yeah
09:58:45 <jak> same here
09:59:09 <Smerdyakov> So HaskellWiki uses MoinMoin?
09:59:13 <shapr> yup
09:59:25 <shapr> that is, if you mean the new HaWiki
09:59:38 <shapr> the older one used PyWiki, and was called HaskellWiki
10:00:05 <elmex> hmm
10:00:10 <elmex> what about curses bindings?
10:00:31 <shapr> too many ;-)
10:00:31 <kaninchen> hat irgendjemand lust mal was f?r mich zu testen ?
10:00:34 <Smerdyakov> Do you recommend MoinMoin, then?
10:00:38 <shapr> ich habbe keine ahnung!
10:00:40 <shapr> Smerdyakov: I do
10:01:13 <Smerdyakov> OK. Any reasons?
10:01:56 <shapr> yah, lots
10:02:30 <Smerdyakov> OK. A fellow in #wiki is telling me to use it, too. =)
10:02:33 <shapr> macro support, lots of extra charset support, subpages, file attachments, various per-user customizations, access controls
10:02:41 <shapr> if it's snibril, then that's the author ;-)
10:02:55 <Smerdyakov> No, though I know snibril from ancient days in #c on EFNet. =)
10:03:01 <shapr> wow, cool
10:05:12 <elmex> kaninchen: ja?
10:05:41 <kaninchen> elmex: so you wanna test sth for me ? (actually it was an amsg for quakenet but nevermind)
10:05:54 <elmex> quakenet? lol
10:05:59 <elmex> you are hanging around there too?
10:06:20 <elmex> kaninchen: what are you doing over there?
10:06:26 <kaninchen> hehe sure, I was once playing cs (about 6 months ago)
10:06:41 <elmex> oh, hm.. i don't like cyber sex that much
10:06:42 <kaninchen> so I'm an ex player ...
10:06:52 <kaninchen> hmm cs = counterstrike :)
10:06:57 <elmex> cs sucks, quakeworld for ever
10:07:03 <kaninchen> hehe :)
10:07:04 <kaninchen> nevermind
10:07:09 <elmex> quake is atleast GPL!!!
10:07:12 <kaninchen> do you still want to test sth for me ? :)
10:07:14 <elmex> and that cs-engine is still closed
10:07:20 <elmex> kaninchen: i don't know, what is it?
10:07:21 <kaninchen> yepp
10:07:49 <kaninchen> and the cs engine is still one of the worst one could emagine
10:08:03 <kaninchen> elmex: http://lotux.homelinux.org:1000/~camold/page/
10:08:19 <elmex> The requested URL /~camold/page/ was not found on this server.
10:08:23 <kaninchen> it is yet a login system but it will be more in within the next week :)
10:08:36 <kaninchen> hmm mom
10:08:38 <elmex> crappy mozilla
10:08:39 <elmex> wait
10:08:41 <elmex> i got it
10:08:52 <elmex> what the heck???
10:08:59 <kaninchen> you didn't typ the port ?
10:09:00 <elmex> thats a fuckn big picture
10:09:10 <kaninchen> hmm well yes :)
10:09:13 <elmex> kaninchen: well, somehow it wasn't copied correctly
10:09:27 <kaninchen> ahh ok
10:09:37 <elmex> kaninchen: so, waht are you doing in #haskell?
10:09:51 <elmex> haha,cool. at least apache :)
10:09:54 <kaninchen> I made several projects in haskel
10:10:03 <elmex> kaninchen: what kind of projects?
10:10:05 <kaninchen> :%s/haskel/haskell/
10:10:16 <kaninchen> elmex: http://lotux.homelinux.org/
10:10:56 <elmex> lotux?
10:11:14 <kaninchen> and brandubh
10:11:26 <elmex> scary
10:11:48 <elmex> i'm not into game development... i somehow love to write never finished network-applications
10:11:48 <kaninchen> why ?
10:11:56 <kaninchen> elmex: hehe
10:12:14 <kaninchen> elmex: so if you like that -> write a graphical client for the brandubh server !!!
10:12:19 <kaninchen> I still have none :)
10:12:55 <elmex> hmm
10:13:07 <elmex> i'm more into playing Go not other board games
10:13:16 <kaninchen> :)
10:13:26 <elmex> and why is that page in php and not even perl or haskell?
10:13:56 <kaninchen> haskell was to dificult as cgi scripts (php is more simple for such purposes ...)
10:14:08 <kaninchen> and I cannot write in perl
10:14:15 <elmex> ah, yes...
10:14:24 <elmex> perl is too easy for people who come from php
10:14:29 <Smerdyakov> Were you writing CGI programs directly, instead of using a functional CGI library?
10:14:47 <elmex> if you know perl, and you are going to php, you feel like being shot into both legs and you have to run
10:15:30 <kaninchen> elmex: really ? hmm perhaps I will try perl in the next time ...
10:15:33 <kaninchen> we'll see that
10:16:08 <elmex> kaninchen: well, perl isn't exactly something you can plugin for php or something. but there are good perl-modules who are much easier for CGI than php
10:16:41 <kaninchen> hmm well ok
10:16:50 <kaninchen> perhaps in the next project :)
10:17:17 <kaninchen> currently I have no time to learn new languages but perhaps in 2 weeks or so
10:17:46 <elmex> well, i don't promise everthing to be easier or something. but perl is much more flexible somehow. and it's just cool for writing system-scripts and all
10:18:07 <kaninchen> aha
10:18:11 <kaninchen> sounds great
10:19:14 <elmex> hm... that cvs server for ghc seems to be a bit slow
10:23:35 <elmex> what is that Network.CGI good for?
10:26:50 <shapr> elmex: it's a CGI library
10:27:01 <elmex> shapr: what does a CGI library do?
10:27:10 <shapr> CGI is short for common gateway interface
10:27:23 <shapr> long ago and far away, web servers only served static html
10:27:39 <shapr> some bright person had a brilliant idea...
10:28:15 <shapr> whenever an executable was requested, instead of returning the raw source of that executable, give it a bunch of environment variables, and return whatever the executable returned
10:28:36 <shapr> that set of environment variables and calling conventions is CGI
10:30:07 <elmex> scary
10:30:33 <elmex> i somehow want at least some ... more complete CGI lib
10:30:38 <elmex> what is about file-uploads?
10:30:47 <elmex> i never got around implementing a cgi lib for that
10:30:58 <elmex> (don't want to read the MIME rfc ;-))
10:31:57 <shapr> just grab the POST env var
10:32:06 <Darius> There are more complete CGI libraries.
10:32:14 <elmex> shapr: nope
10:32:34 <elmex> shapr: the file-upload isn't handled by POST env vars
10:33:08 <jak> back in a sec
10:36:22 <shapr> elmex: I'm pretty sure it is
10:37:14 <shapr> elmex: I've done it that way before
10:39:15 <elmex> shapr: i can't see the functions which catch the multipart/form-data 
10:40:03 <shapr> the way I've done it in the past is to POST a file, and then look in the environment variable to find the filename that was saved into
10:40:18 <elmex> shapr: and you don't want a 40MB big file in a ENV var
10:40:32 <shapr> no, the *filename* is in the env var
10:40:47 <elmex> shapr: that saving is done in the CGI lib 
10:41:27 <shapr> ok
10:41:37 <shapr> if you say so :-)
10:41:39 <elmex> at least it is done in the perl CGI lib
10:42:22 <elmex> shapr: the http server transmitts that file mime encoded as mulripart/form-data, and the CGI script has to save that somewhere
10:43:02 <shapr> I think you get to choose how the file is encoded when you design the form
10:43:38 <elmex> yes, but any other encoding isn't really good....well...
10:45:24 <shapr> why is that?
10:47:05 <elmex> because multipart/form-data is for files, and the other application/x-www-form-urlencoded is for small data normally.
10:52:10 <elmex> hm, from this rfc thre is some part saying:
10:52:11 <elmex> 5.8 File transfer with ENCTYPE=x-www-form-urlencoded
10:52:11 <elmex>     If a form contains <INPUT TYPE=file> elements but does not contain an ENCTYPE in the enclosing <FORM>, the behavior is not specified. It is probably inappropriate to attempt to URN-encode large quantities of data to servers that don't expect it. 
10:52:15 <elmex> http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc1867.html
11:00:07 <shapr> oy
11:23:37 <shapr> oy
13:15:34 <shapr> anyone here dealt with the arrowp preprocessor?
13:19:32 <shapr> I've run the small Eval.as demo through the preprocessor, but the resulting output won't compile
13:23:13 <shapr> what's the param to give ghc a custom preprocessor?
13:27:36 <shapr> I can't find where -F is documented...
13:27:37 <shapr> hmm
13:28:57 <Darius> The parser doesn't like the ~(Num u) etc.
13:29:15 <shapr> oh is that it?
13:29:32 <shapr> do you also get the conflicting definitions for `u'
13:29:34 <shapr> ?
13:29:54 <Darius> Yes before removing the ~'s it compiles after.
13:30:03 * shapr tries
13:31:23 <Darius> Arrow notation isn't 100% correct the same for refutable patterns.  Perhaps the preprocessor handles making the irrefutable patterns automatically now. 
13:31:38 <Darius> s/the same//
13:32:04 <shapr> where do you get your Arrow import?
13:32:12 <Darius> Control.Arrow
13:32:14 <shapr> oh
13:34:27 <shapr> yay, it compiles!
13:38:25 <shapr> hm
13:42:04 <shapr> what's the trick to using arrowp on .las files?
13:45:58 <Darius> heck if I know.  Try putting it through GHC first with the appropriate phase option, or alternatively insert arrowp as a replacement for cpp.
13:46:05 <shapr> hm
13:46:28 <shapr> ok
13:46:33 <Darius> Does hmake handle arrow files?
13:46:55 * shapr tries
13:47:33 <shapr> doesn't seem so
14:41:53 * shapr read about Arrows
14:42:25 * shapr boings
14:44:09 <shapr> I wonder if the rpSwitch combinator is a good way to represent a collection of units in a realtime strategy game
14:45:16 * shapr is reading the "yampa continued" paper
15:20:39 <shapr> yargh
15:20:52 <Igloo> Hey shapr
15:21:33 <seth_> I have two functions, which I'd like to combine into one, but I can't figure out exactly how.  Here are the two functions (just 6 lines):
15:21:35 <shapr> hi Igloo 
15:21:42 <seth_> mrex re str =
15:21:42 <seth_>     do mme <- regexec re str
15:21:42 <seth_>        if (isNothing mme) then throwDyn exInternalError else (return (fromJust mme))
15:21:42 <seth_> shortenUrl url =
15:21:42 <seth_>     do re <- reShortUrl
15:21:43 <seth_>        (b,m,a,s) <- mrex re url
15:21:45 <seth_>        return m
15:21:59 <shapr> Igloo: I'm reading the yampa continued paper repeatedly, trying to find an RTS starting point
15:22:14 <seth_> the problem is I can't figure out how to first treat the output of regexec as Maybe x, and then treat the x as (b,m,a,s)
15:22:24 <Igloo> shapr: I got distracted half way through writing a do-nothing SDL app
15:22:43 * Igloo probably shouldn't work on it before May 22nd  :-/
15:22:52 <shapr> what happens may 22nd?
15:23:23 <Igloo> HW deadline
15:23:25 <shapr> oh!
15:23:47 <shapr> I'm trying to get all the framework bits worked out, like getting the arrowp preprocessor to work smoothly
15:24:07 <shapr> Bea is going to germany for a week or so
15:24:25 <shapr> I'm hoping I'll be able to dedicate my time during that week to fun projects.
15:24:47 <shapr> sadly, I've forgotten exactly when she's going.
15:25:00 <Igloo> shortenUrl url =
15:25:01 <Igloo>     do re <- reShortUrl 
15:25:01 <Igloo>        mme <- regexec re url
15:25:01 <Igloo>        (b,m,a,s) <- if (isNothing mme) then throwDyn exInternalError else return (fromJust mme)
15:25:04 <Igloo>        return m
15:26:58 <seth_> Igloo: thanks..  That's obvious, now that you point it out.
15:27:11 <Igloo> :-)
15:27:50 <seth_> I was trying  (b,m,a,s) <- fromJust mme
15:27:58 <seth_> those return's again
15:43:36 <seth_> simple question:  In the regex and posix.regex docs, I don't see functions for replace.  Are these somewhere else, or do I need to code them myself?
15:46:13 <elmex> seth_: i don't think that posix has substitution
15:46:28 <seth_> didn't see it.  so I code that part myself?
15:46:35 <elmex> seth_: i geuss so
15:46:58 <seth_> ok, just wanted to check that I wasn't missing something obvious.  :)
15:50:10 <elmex> elmex = putStr "ZzZz" >> elmex
15:50:22 <elmex> good night
15:50:33 <seth_> night
16:53:13 <mp00> hello
16:53:29 <mp00> there is a Haskell to C or Haskell to Java converter around ?
16:55:41 <shapr> what about -fvia-C
16:55:41 <shapr> ?
16:55:54 <mp00> dunno
16:55:56 <mp00> any good ?
16:56:14 <shapr> it's one of the normal boring ways of compiling Haskell programs.
16:56:15 <Fractal> mp00 : ghc can compile to C code...
16:56:37 <mp00> z
16:56:39 <mp00> a
16:56:50 <shapr> p?
16:56:58 <mp00> can convert the code to C?
16:56:58 <shapr> g?
16:57:01 <mp00> heh
16:57:21 <shapr> mp00: have you used Haskell before?
16:57:40 <mp00> yeap
16:58:24 <mp00> y?
16:59:17 <Riastradh> f?
16:59:24 <mp00> s?
16:59:29 <Riastradh> q!
16:59:48 <mp00> a
16:59:50 <mp00> k?
17:00:05 <delYsid> heh, since I'm playing with expressions like "putStrLn $ unlines $ map show $ take 100 $ zip [1..] $ map (^3) fib" now, I think I should go to sleep :)
17:00:23 * shapr grins
17:01:41 <Riastradh> What, you use $ and not . in most of those cases?
17:02:29 <Riastradh> Weirdo.
17:02:43 <mp00> heh
17:03:00 <delYsid> doesnt . only work if the last function in the chain requires args?
17:03:36 <Riastradh> The last one should be $.
17:03:40 <Riastradh> Hence 'most.'
17:04:37 <delYsid> ah
17:05:59 <shapr> what's the precedence of . ?
17:06:35 <Riastradh> RTFSC.
17:06:44 <delYsid> *ChessModule Control.Arrow Control.Monad.Writer> :info .
17:06:44 <delYsid> -- . is a variable
17:06:44 <delYsid> infixr 9 .
17:06:44 <delYsid> (.) :: forall b c a. (b -> c) -> (a -> b) -> a -> c
17:06:54 <shapr> ah
17:07:07 <shapr> thanks
17:07:14 <delYsid> :info is useful
17:07:16 <delYsid> and :browse
17:07:19 <shapr> so . does bind more tightly than $
17:10:35 <seafood> Igloo: are you there?
17:10:44 <Darius> shapr: much!
17:11:18 <Darius> but I prefer f $ g $ h $ x rather than f . g . h $ x
17:11:22 <tmoertel> @prelude (.) ($)
17:11:25 <lambdabot> *** "(.)" prelude "Haskell Standard Prelude Dictionary": text follows
17:11:25 <lambdabot> (.)
17:11:25 <lambdabot>   infixr 9 .
17:11:25 <lambdabot>   (.) ::  (b -> c) -> (a -> b) -> (a -> c)
17:11:25 <lambdabot>   (f . g) x       = f (g x)
17:11:31 <lambdabot> -DONE-
17:11:35 <lambdabot> *** "($)" prelude "Haskell Standard Prelude Dictionary": text follows
17:11:35 <shapr> mmmm
17:11:37 <lambdabot> ($)
17:11:39 <lambdabot>   infixr 0 $
17:11:41 <lambdabot>   ($) ::  (a -> b) -> a -> b
17:11:45 <shapr> that's awesome
17:11:45 <tmoertel> @more
17:11:47 <lambdabot> -DONE-
17:13:34 <tmoertel> 0 and 9, I'd say that's a pretty big difference in binding strength
17:14:26 <shapr> could all of the ghc docs be in @prelude?
17:14:42 <shapr> @predule hGetLine
17:14:43 <lambdabot> Sorry, I don't know the command "predule", try "lambdabot: @listcommands"
17:14:45 <shapr> er
17:14:52 <shapr> @prelude hGetLine
17:14:54 <lambdabot> *** "hGetLine" prelude "Haskell Standard Prelude Dictionary": text follows
17:14:54 <lambdabot> hGetLine
17:14:54 <lambdabot>   hGetLine ::  Handle -> IO String
17:14:54 <lambdabot>   hGetLine h             = do c <- hGetChar h
17:14:54 <tmoertel> if you can fit them into a dict, which isn't too difficult
17:14:55 <lambdabot>                               if c=='\n' then return ""
17:14:56 <shapr> oh
17:14:57 <lambdabot>                                 else do cs <- hGetLine h
17:14:58 <shapr> wow
17:14:59 <lambdabot>                                         return (c:cs)
17:15:06 <shapr> @prelude run
17:15:08 <lambdabot> No match for "run".
17:15:53 <seafood> 
17:20:02 <shapr> hi Arnia 
17:20:10 <Arnia> Heya
17:20:30 <shapr> what's up?
17:22:25 <Arnia> Just getting freaked out by watching Harry Potter and the Chamber of Secrets and seeing where I've matriculated, where I've sat down and revised, where I've got drunk... where I've watched things being filmed thirty yards from my bedroom window
17:23:42 <shapr> heh :-)
17:24:06 <tmoertel> shapr: would you mind pulling the most-recent dict module?
17:24:25 * tmoertel fixed a bug that caused -DONE- to be printed more than once in a multi-lookup query
17:24:28 <Arnia> I have to say that seeing Durham as Hogwarts worries me
17:24:36 <shapr> tmoertel: sure
17:24:41 <shapr> tmoertel: er, I wouldn't mind
17:24:41 <tmoertel> thx!
17:28:17 <shapr> @quit
17:29:18 <shapr> @listcommands dict
17:29:19 <lambdabot> Module dict provides the following commands: ["dict","dict-help","all-dicts","devils","easton","elements","foldoc","gazetteer","hitchcock","jargon","prelude","vera","web1913","wn","world02"]
17:29:30 * tmoertel tests via /msg
17:30:35 <tmoertel> seems to be working
17:30:40 <tmoertel> @dict-help prelude
17:30:41 <lambdabot> @prelude .... Haskell Standard Prelude
17:30:57 <tmoertel> shapr: thanks!
17:31:00 <shapr> sure
17:31:16 <shapr> it's fun to get new lambdabot code to play with
17:31:43 <shapr> Arnia: the chamber is open!
17:32:36 * tmoertel is thinking about seeing the new X-Men movie
17:32:37 <shapr> tmoertel: any suggestions for lambdabot improvements?
17:32:59 <tmoertel> shapr: it ought to let you know when there is @more
17:33:12 <shapr> yah, I agree
17:34:22 <tmoertel> how 'bout: @stock aapl ibm rhat
17:34:28 <tmoertel> :-;
17:34:33 * shapr grins
17:34:47 <shapr> is there a stock lookup service?
17:35:10 <tmoertel> probably, but if not we could just scrape ticker info from a web site
17:35:19 <shapr> sounds like fun
17:35:58 * shapr adds a "there's @more" message
17:38:28 <tmoertel> how many lines (or chars) can lambdabot write before getting kicked?
17:38:37 <tmoertel> (or being labled a bad citizen?)
17:38:40 <shapr> I'm not exactly sure
17:38:50 <tmoertel> it seems execessive to send one message per line
17:39:14 <shapr> you're thinking of refilling output to turn short lines into longer ones?
17:39:20 <shapr> er, reformatting?
17:39:36 <tmoertel> more like sending two or three lines at once
17:39:54 <shapr> ?
17:40:06 <shapr> hi archie
17:40:11 <archie_sihir> hi shapr
17:40:13 <shapr> what's up?
17:40:28 <archie_sihir> hehe playing around with nhc98
17:40:43 <tmoertel> right now each line of a response (via ircPrivmsg) is send via its own call to ircWrite
17:41:55 <shapr> tmoertel: you want to send multiple lines at a time?
17:42:02 <tmoertel> shapr: yes
17:42:23 <shapr> I don't think you can send multi-line messages to the irc server
17:42:39 <shapr> but I do think we can send multi-line batches to ircWrite
17:42:44 * tmoertel does a test via Chatzilla
17:42:46 <shapr> if it can handle them
17:43:08 <shapr> part of the reasond I think this is that @fact originally didn't escape anything,
17:43:24 <tmoertel_moz> this
17:43:26 <tmoertel_moz> is
17:43:28 <tmoertel_moz> more than one line
17:43:36 <tmoertel> shapr is correct !
17:43:37 <shapr> factoids with \n in the output would end up sending everything after the the first \n as a command to the server
17:46:21 <Riastradh> @fact test
17:46:22 <lambdabot> Nothing
17:46:27 <Riastradh> @fact test foo\nbar\nbaz
17:46:27 <lambdabot> set test to foo\\nbar\\nbaz
17:46:32 <Riastradh> @fact test
17:46:33 <lambdabot> foo\nbar\nbaz
17:46:39 <shapr> happily, I escaped \n
17:46:49 <shapr> and tmoertel escaped some other stuff
17:47:12 <shapr> re archie
17:47:20 <shapr> did nhc98 eat your machine?
17:47:45 <archie_sihir> hehe
17:48:43 * Riastradh imagines a fuzzball labeled 'compiler' walking up to a computer and taking a big bite out of a computer.
17:49:05 <shapr> *chomp*
17:49:18 <shapr> does that mean that fuzzball on userfriendly is a compiler?
17:49:31 <Riastradh> ?
17:49:36 <Riastradh> 'On userfriendly?'
17:49:42 <shapr> have you seen the web cartoon called userfriendly?
17:49:47 <Riastradh> No.
17:50:04 <shapr> look at userfriendly.org
17:50:19 <Riastradh> Is the fuzzball that you referred to labeled 'compiler?'
17:50:36 <shapr> no, I've forgotten his name..
17:50:56 <Riastradh> Well, then, no, I doubt it's a compiler.
17:51:29 <shapr> I think his name might be peter.
17:51:37 <shapr> he's an animated ball of dust I think
17:51:38 * Riastradh prefers fuzzballs named Crunchly.
18:02:42 <shapr> @jargon clue-by-four
18:02:44 <lambdabot> *** "clue-by-four" jargon "Jargon File (4.3.0, 30 APR 2001)"
18:02:44 <lambdabot> clue-by-four [Usenet: portmanteau, clue + two-by-four] The notional
18:02:44 <lambdabot>    stick with which one whacks an aggressively clueless person. This term
18:02:44 <lambdabot>    derives from a western American folk saying about training a mule
18:02:44 <lambdabot>    "First, you got to hit him with a two-by-four. That's to get his
18:02:46 <lambdabot>    attention." The clue-by-four is a close relative of the {LART}. Syn.
18:02:48 <lambdabot>    `clue stick'. This metaphor is commonly elaborated; your editor once
18:02:50 <lambdabot>    heard a hacker say "I smite you with the great sword Cluebringer!"
18:02:52 <lambdabot> there's @more
18:03:14 <shapr> @more message added
18:03:14 <lambdabot> -DONE-
18:03:38 <tmoertel> ha!  "there's more" -> "-DONE-"  ;-)
18:03:47 <shapr> it wasn't much @more
18:03:54 <tmoertel> nope.
18:04:09 <tmoertel> Maybe the "there's more" code should add the "-DONE-" notice.
18:05:03 <shapr> I'm not sure
18:05:35 <tmoertel> it's the only code that knows whether the output is broken into multiple-@more segments
18:05:48 <shapr> that's a good point
18:06:01 <shapr> when would you add the -DONE- then?
18:06:17 <tmoertel> the logic would work like this:
18:06:30 <tmoertel> ircPrivmsg gets a block of lines
18:06:47 <tmoertel> if the number of lines is more than the cutoff, it adds "-DONE-" after
18:07:01 <tmoertel> the last line, prints the first block of lines, and waits for a @more
18:07:11 <tmoertel> that's it.
18:07:26 <shapr> ok
18:07:42 <shapr> finished :-)
18:07:49 <shapr> just have to recompile lambdabot 
18:07:59 * tmoertel takes the -DONE- out of DictModule
18:09:02 * tmoertel checks it in
18:09:11 * shapr rebuilds
18:09:16 <shapr> lambdabot: @quit
18:10:20 <shapr> the only disadvantage to this is that one line factoids will have -DONE- also
18:10:29 <shapr> @fact foo
18:10:29 <lambdabot> foo\bar
18:10:29 <lambdabot> -DONE-
18:10:40 <Darius> It should only kick in for multipart messages.
18:10:54 <tmoertel> Only add the -DONE- *if* the output is broken into segments.
18:11:21 <tmoertel> And we should say "[there is @more]" and "[DONE]" so that people won't think the lambdabot-added messages are part of the result text.
18:11:27 <shapr> ok
18:12:37 <shapr> hrm
18:19:23 <mp00> Agrrrr
18:19:29 <mp00> stack again in the same thing
18:19:46 <mp00> inside my funciton I got :  do char 'f' digit
18:19:55 <mp00> but still can't figure out what this do 
18:20:00 * tmoertel is leaving to see the new X-Men movie !
18:20:19 * tmoertel hopes it is good
18:20:46 * mp00 It is nice , DreamCatcher SAX though
18:20:54 <seth_> I'm getting can't find module `Network.Socket' from ghci, but it finds all other modules in the same file.  What's that about?
18:21:06 <seth_> the same file compiles fine with ghc
18:22:34 <mp00> inside my funciton I got :  <do char 'f' digit> I now know that with do I add a parsing parameter to my parser (using Parselib) but char 'f' digit is not easy to fin what it does , which string add to my parser
18:28:01 <shapr> seth_: :set -package network
18:29:05 <seth_> shapr: I found it.  But why didn't -i/usr/local/..../imports/network work with ghci?
18:31:44 <shapr> see what "ghc-pkg -s network" gives you
18:32:41 <seth_> show me Package {name = "network",    etc.
18:33:01 <mp00> I have imported ParseLib lib and I have the following code inside a function :
18:33:02 <mp00> char 'f' digit
18:33:06 <mp00> what this do ?
18:33:16 <shapr> mp00: are you using Parsec?
18:33:27 <seth_> mp00: a hex digit?
18:33:53 <mp00> nope , Parser
18:34:35 <mp00> hex digit.. hm..  that's the only thing I havent tried :)
18:34:38 <shapr> I would assume it's looking for the character 'f' and then a digit
18:34:48 <mp00> oh.. 
18:34:56 <mp00> that good Idea as well
18:35:40 <mp00> shapr got it !!!! ;)
18:35:49 <mp00> exactly what you said
18:36:23 <mp00> so .. if I have   many (char 'f' digit)
18:36:33 <shapr> mp00: read the Parsec tutorial
18:36:57 <mp00> means that the parsing data should have from 0 to 1   times char 'f' digit
18:37:27 <mp00> heh.. I think I got it :)
18:41:25 <seth_> how do I convert an Int to a Word16?
18:42:39 <seth_> with I16#?
20:27:40 <seth_> Hey, all, I'm working with threads.  forkIO takes no arguments.  So how to I pass information to a thread?  I can do something indexed by the thread identifier, but maybe there is an easier way?
20:29:18 <Smerdyakov> Looks to me like forkIO takes IO () as an argument.
20:32:49 <seth_> Well, yes, but you can't pass info with IO (), or am I wrong?
20:32:57 <Smerdyakov> Pass info to what?
20:33:16 <seth_> whatever data I need to use in the thread.
20:33:40 <Smerdyakov> How would you "use this data"?
20:33:59 <seth_> it depends on the thread.  What difference does it make?
20:34:24 <Smerdyakov> I think there is no reasonable definition of what it means for an IO () to "use data," and you are confused.
20:34:49 <seth_> Smerdyakov: that's silly.  For example, I spawn a thread to handle a new connection, and I have to pass the socket handle to the thread
20:35:06 <Smerdyakov> So? How is that different from doing the same thing in the current thread?
20:35:26 <seth_> because the current thread receives the connection and spawns a new thread to handle it.
20:35:32 <Smerdyakov> So?
20:35:42 <seth_> the new thread needs the socket descriptor
20:35:56 <Smerdyakov> Why doesn't it have access to it the same way you would without spawning a new thread?
20:36:22 <seth_> because I don't use global variables.
20:36:35 <seth_> even in a C program I would never to that.
20:36:51 <seth_> besides, if I have 20 active descriptors, how would the thread know which one to fetch?
20:36:53 <Smerdyakov> Nonetheless, the Haskell compiler magically makes sure all threads have access to the appropriate values.
20:37:22 <Smerdyakov> It's done with the same lexical scoping as everywhere else.
20:37:23 <seth_> You aren't making sense.  If I call, for example, hGetLine, I have to give it the file handle as part of the call.
20:37:40 <Smerdyakov> Yes. You have the file handle.
20:37:46 <seth_> how?
20:37:55 <Smerdyakov> All you're doing is adding an extra call to forkIO around what you would have done before.
20:38:02 <seth_> be specific
20:38:28 <Smerdyakov> How about YOU be specific and give me a concrete code example showing your claimed problem?
20:38:44 <seth_> It isn't a claimed problem.  It is functionality that I have to implement.
20:38:45 <seth_> ok.
20:38:55 <seth_> I make a call:  forkIO func
20:39:04 <seth_> where func is a function that handles the processing for the thread.
20:39:14 <Smerdyakov> But.... forkIO takes an IO () as a parameter.
20:39:16 <seth_> in func, I want to invoke:  hGetLine handle
20:39:17 <Smerdyakov> It can't take a function.
20:39:40 <seth_> No, that's not true.  I have it running with the function already.  Besides, from the docs:
20:39:58 <seth_> This sparks off a new thread to run the IO computation passed as the first argument, and returns the ThreadId of the newly created thread. 
20:40:16 <Smerdyakov> Yes, I have type: forkIO :: IO () -> IO ThreadId
20:40:21 <seth_> You pass it a function of type IO ()
20:40:24 <Smerdyakov> IO () is NOT a function type. You must be mistaken.
20:40:42 <seth_> No, I'm not.  its easy enough to create a function with type IO ()
20:40:49 <Smerdyakov> OK. Example of one?
20:41:16 <seth_> func1 :: IO ()
20:41:21 <Smerdyakov> That's not a function.
20:41:23 <seth_> func1 = do putStrLn "hello"
20:41:24 <Smerdyakov> It's an IO action.
20:41:27 <Smerdyakov> There is a difference.
20:41:40 <seth_> please, don't quibble about words.  I'm trying to do something here.
20:41:47 <seth_> besides, this isn't a function?
20:41:51 <Smerdyakov> OK, but it's good not to misuse standard terminology.
20:41:53 <seth_> func1 = do putStrLn "hello"?
20:41:56 <Smerdyakov> No
20:42:05 <Smerdyakov> Every function takes exactly one parameter.
20:42:09 <Smerdyakov> Your func1 has no parameter.
20:42:16 <seth_> whatever.  the fact remains that I need to pass information to the whatever you want to call it.
20:42:47 <Smerdyakov> OK. So, in the expression let x = 3 in x + 9, how do you pass information to the inner expression x + 9?
20:42:54 <Smerdyakov> So that it gets the right value of x?
20:43:16 <seth_> you don't, it's implied.  But you don't get it
20:43:29 <seth_> The same "action" is invoked for many different threads
20:43:31 <Smerdyakov> OK. How does this "implied passing" not solve your problem?
20:43:38 <Smerdyakov> OK, so how about this.
20:43:42 <Smerdyakov> addone x = x + 1
20:43:59 <seth_> first of all, I think even you will admit that this is a function
20:44:02 <Smerdyakov> How do we pass information to x + 1 for each call to the function, and make sure it always gets the right x?
20:44:12 <Smerdyakov> After all, the function is invoked many times.
20:44:17 <seth_> contextually.  You haven't written threaded programs.
20:45:01 <Smerdyakov> The values of variables in the IO () you pass will be those dictated by lexical scope.....
20:45:15 <Smerdyakov> They are preserved by the wonderfulness that is the Haskell compiler, garbage collector, etc.!
20:45:20 <seth_> OK, how do I associate a variable with an IO ()
20:45:50 <Smerdyakov> You use that variable in the expression that creates the IO ()....
20:46:46 <seth_> show mean an expression to create an IO () with a value, any value, say 10
20:47:02 <Smerdyakov> What does it mean to "create an IO () with a value"?
20:47:28 <seth_> you said "You use that variable in the expression that creates the IO ()...."  and I'm asking you how to do that.  Please don't quibble over language.
20:47:54 <Smerdyakov> I'm not being testy. I am genuinely not understanding you.
20:48:07 <seth_> if you can "use that variable in the expression that creates the IO ()", then you must be able to create the IO (), no?
20:48:11 <Smerdyakov> let val mystring = "Hi there" in putstr mystring
20:48:19 <Smerdyakov> That uses mystring in an IO () expression.
20:48:44 <Smerdyakov> I don't know if putstr is a real function, but I hope you can guess what I mean for it to do if it isn't. =)
20:49:17 <seth_> I don't see how I could provide that as an argument to forkIO
20:49:20 <Smerdyakov> And remove the "val" above =)
20:49:25 <Smerdyakov> Why not?
20:49:30 <seth_> show me how
20:49:34 <Smerdyakov> forkIO (let mystring = "Hi there" in putstr mystring)
20:51:43 <Smerdyakov> Got it?
20:51:49 <seth_> I'm trying it
20:52:55 <seth_> well, it compiles, but I can't use mystring in the thread's context.
20:53:11 <Smerdyakov> What do you mean?
20:53:51 <seth_> I think I may see what you are getting at.  I'll have to play with this.
20:54:26 <seth_> But it isn't clear to me that I can call other functions from within the ( ) defined code
20:54:30 <Smerdyakov> Good. If it works out for you, you'll see that there are no special mechanisms at play here and what you are really learning is lexical scoping.
20:55:05 <Smerdyakov> Why wouldn't you be able to? It's an expression like any other....
20:55:58 <seth_> People here are always thinking that I don't know something entirely different than what I don't know.  I understand lexical scope perfectly.  I didn't know that I could define a function in line that way by putting it in parentheses in the forkIO invocation.
20:56:54 <Smerdyakov> First, you're not defining a function.
20:56:58 <seth_> thanks for the help, that let's me continue.
20:57:01 <seth_> ok, action.  
20:57:06 <Smerdyakov> You're not defining anything.
20:57:10 <Smerdyakov> It's just an expression.
20:57:19 <Smerdyakov> It's not a special type of expression. It's a regular expression.
20:57:50 <Smerdyakov> And, if you really do understand lexical scoping, then what you don't understand is expressions, types, or something equally central.
20:59:34 <seth_> there is a difference between not understanding expressions and not understanding all the contexts in which you can _use_ expressions.  You can't do _anything_ in this context, can you?  For example, I don't think you can use guards.
21:00:32 <Smerdyakov> That's right. Guards are parts of declarations, not expressions.
21:00:55 <Smerdyakov> Maybe you still use them with anonymous functions, though.
21:01:05 <seth_> so it isn't entirely surprising that I didn't know that, in a context where I can't use guards, I _can_ use let
21:01:29 <seth_> I didn't know it, of course, but it isn't 100% stupid
21:02:32 <Smerdyakov> Yes, like I said, it just means you don't understand what an expression is yet.
21:02:36 <Smerdyakov> Plus, you could just as easily do:
21:02:46 <Smerdyakov> let mystring = "Hi" in forkIO (putstr mystring)
21:14:40 <Smerdyakov> Oh, and I hope you can also see that forkIO (putstr "Hi") is equivalent.....
21:44:49 <seth_> the last one is the only one I thought of.  :)
21:47:11 <Smerdyakov> So you have it all worked out now?
21:48:30 <seth_> yes, I think so.
21:51:22 * tmoertel liked the X2 X-Men movie
21:52:13 <seth_> actually, no.
21:52:40 <seth_> well, maybe.
21:52:42 <seth_> let me try it.
22:01:33 <o3> seth_: you need to understand something about the type system
22:01:37 <o3> and partial functions
22:01:56 <o3> seth_: ok, forkIO takes in one argument, which is of type "IO ()"
22:02:06 <seth_> right
22:02:11 <o3> seth_: the way you pass that function some information is this ...
22:02:23 <o3> the type of the function is IO ()
22:02:34 <o3> that means that you can call whatever function you want as long as it returns an IO ()
22:02:41 <o3> for example
22:02:44 <o3> main :: IO ()
22:02:52 <o3> main = foo
22:03:10 <o3> as long as foo's type is IO (), that's okay.  but how about this ...
22:03:12 <seth_> I understood that all along.  The problem I was having is:  how do I pass arguments _to_ that function.
22:03:17 <o3> bar :: Int -> IO ()
22:03:22 <o3> bar n = putStrLn (show n)
22:03:25 <o3> main :: IO ()
22:03:26 <o3> main = bar 5
22:03:31 <o3> that's how you do it
22:03:47 <o3> as long as the "return type" of the function is IO (), that's ok
22:03:52 <seth_> so I can say:  forkIO (xyz arg1 arg2 arg3)
22:03:58 <o3> yes
22:04:08 <seth_> that is really all I needed to know.
22:04:10 <o3> and as long as xyz's type is :: a -> b -> c -> IO ()
22:04:12 <o3> it's ok
22:04:23 <seth_> right.
22:04:39 <o3> well, it's one of the powerful things about haskell, you are allowed to have partial functions
22:04:47 <o3> you could do something like
22:04:56 <o3> square :: Int -> Int -> Int
22:04:59 <o3> square n = n * n
22:05:07 <o3> err
22:05:10 <o3> let's try again :)
22:05:14 <o3> multiply :: Int -> Int -> Int
22:05:20 <o3> multiply n = n * n
22:05:26 <o3> and then you could have a bunch of other functions
22:05:33 <o3> multiply4 :: Int -> Int
22:05:48 <seth_> I know about partial application, but I don't see how it applies the forkIO call.
22:05:50 <o3> multply4 = multiply 4
22:06:35 <o3> well, i guess it's not really partial application, but imho it uses the same idea
22:06:52 <seth_> o3: OK, I just don't want to miss the point.
22:06:56 <o3> even though forkIO takes in a single argument, you can call your own function and just 'fill in' its arguments
22:07:05 <o3> to make the types match up
22:07:08 <o3> that's how i think of it, anyway
22:07:12 <tmoertel> seth_: see the use of forkIO in http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/hws-wp/hws-wp/src/Main.hs?rev=1.1&content-type=text/vnd.viewcvs-markup
22:07:34 <o3> seth_: the nice thing is that you can do this for any function
22:07:50 <seth_> tmoertel:  Thanks a lot.  It appears, not that I'm beginning to understand it, that it is fact much easier than what you have to do in other languages.
22:07:55 <seth_> s/not/now/
22:08:25 <o3> and the people who designed forkIO expect you to know this, because it means you don't need to have some special "callback function" type in which you're only allowed to pass, e.g. one argument
22:08:30 <tmoertel> seth_: yes, much more convenient than, say, Java
22:08:59 <seth_> tmoertel: that kind of goes without saying.  :)  But also much more convenient than ocaml and Ruby
22:09:14 <o3> you just call whatever function you write and fill in the arguments as necessary; haskell doesn't care as long as the final type of that function is IO ()
22:09:32 <o3> anyway
22:09:32 <tmoertel> Another good forkIO example: http://icfpcontest.cse.ogi.edu/simulator/pfe.cgi?Server
22:09:38 <o3> you get it now, i think
22:09:58 <o3> anyway, time to watch x2 :)
22:10:05 <seth_> o3, tmoertel, Yes, I think I'm getting it, thanks much for the help.
22:10:14 <tmoertel> o3: I just saw it.  Good.
22:10:19 <o3> all good then
22:10:21 <o3> later
22:10:23 <seth_> tmoertel:  thanks for both of those examples.
22:10:30 <tmoertel> seth_: no problem
22:11:04 <seth_> I'm doing well today.  I think I actually understand the basics of monads, too.
22:31:11 * tmoertel is going to bed
23:58:45 <seth_> I'm using forkIO, and when I try to use as an argument a function defined in another file (and imported), the compiler says it can't resolve the symbol.
