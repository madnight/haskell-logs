00:41:03 <andersca> morning marvin
00:41:49 <Marvin--> morning
01:00:22 <d-bug> morning
01:00:55 <andersca> yay, owen's been triaging bugs
01:21:38 <Dark-Star> What's the difference between "Int" and "Integer"?
01:21:54 <Marvin--> Int is limited to 32 bits, Integer is not
01:22:02 <seth_> Int is 32 bits, Integer is kind of a BCD sort of thing
01:24:02 <Dark-Star> so why doesn't the following piece of code work with "Integer" but only with "Int"?
01:24:12 <Dark-Star> find::String->(Char->Bool)->[Integer]
01:24:33 <Dark-Star> find l p = [i | i <- [0..(length l)-1], p(l !! i) ]
01:24:42 <Marvin--> because length returns an Int
01:24:43 <Dark-Star> ?
01:24:59 <Dark-Star> ah ok, that might explain it...
01:25:03 <Marvin--> try  [0 .. fromInteger (length l) - 1]
01:25:05 <Marvin--> er
01:25:09 <Marvin--> toInteger obviously
01:25:19 <Marvin--> or import List and use genericLength instead
01:25:32 <Dark-Star> ...or I change all my Integer's to Int's :)
01:25:43 <Marvin--> I guess it depends on how long strings you want to have :)
01:26:23 <seth_> or v.v.
01:26:23 <Dark-Star> well, that's not that big a problem... it's only for an assignment I have to do, nothing big
01:26:47 <Marvin--> then go with Ints
01:27:27 <cfork> Lots of people seem to be doing haskell assignments
01:27:43 <andersca> you can't do assignments in haskell, it has no side-effects!
01:27:47 <seth_> Not me, I'm writing code that has to be delivered and work.
01:27:48 * andersca hides
01:27:50 <Marvin--> andersca: *groan*
01:28:01 <cfork> seth_: wow, real practical use of Haskell?
01:28:10 <seth_> cfork: sure, why not?
01:28:12 <cfork> I didn't think it possible :)
01:28:14 * cfork ducks
01:28:20 <Marvin--> well, I guess that's what I'm doing too
01:28:27 <seth_> cfork: I'm actually quite pleased with the way this is turning out.
01:28:33 <Marvin--> but since it's a degree project maybe it's not "real, practical use"
01:28:40 <cfork> seth_: do you find Haskell productive?
01:28:49 <cfork> seth_: compared with other good languages, that is
01:29:07 <seth_> cfork: yes, I do.  I find that there is more up front work, but it pays off.
01:29:25 <cfork> interesting
01:29:41 <seth_> Marvin--: hey, there is no law saying work done for a degree can't also be used.
01:30:01 <Marvin--> seth_: well, except that the institution owns the code ;)
01:30:21 <seth_> Marvin--: that just means you can't get paid for it, not that it can't be used.  :)
01:30:39 <Marvin--> seth_: actually, Koen, my supervisor, wanted to use some of my code in one of their research projects
01:30:58 <seth_> Marvin--: good.  leverage that work
01:31:00 <cfork> Marvin: can you tell us what you are doing your project on?
01:31:50 <Marvin--> cfork: encoding Haskell programs as equational first order logic to prove the existence of bugs
01:32:27 <cfork> well, I don't know what equatational first order logic is, but it sounds fun :)
01:32:49 <Marvin--> do you know what first order logic is?
01:33:10 <seth_> Marvin--: to prove the existence of bugs in the Haskell programs?
01:33:41 <Marvin--> seth_: yes
01:33:42 <cfork> No, but google reveals The language describing the truth of mathematical formulas
01:34:06 <cfork> People seem to speak a different language, to what I've done in my degree
01:34:23 <cfork> I guess I should have done a Maths degree rather than a IT degree
01:34:24 <Marvin--> seth_: since a bug will be encoded as a contradiction, which an automatic theorem prover should<tm> find
01:34:47 <seth_> Marvin--: very interesting.  How is it working out?
01:35:30 <Marvin--> seth_: currently, without any optimizations whatsoever, I have a buggy unification algorithm that I can find a bug in in something like 35 seconds *cough*
01:35:54 <Marvin--> and I have some buggy example programs that it doesn't seem to handle, so I'm going to mail those to the author of the theorem prover I'm using
01:36:22 <seth_> I doubt the running time is  the important thing, at least not initially.
01:37:27 <Marvin--> exactly
01:38:02 <Marvin--> but due to the semi-decidability of FOL it's hard to know if an execution is going to terminate at all or if it's just taking a heck of a long time
01:46:55 <seth_> I don't know the underlying logic at that level of detail.
01:59:07 <Dark-Star> is there something like "for-each" (like in scheme) in haskell?
02:00:14 <Darius> map
02:00:22 <Darius> I guess
02:00:38 <Darius> maybe mapM would be more appropriate
02:52:38 <Kokko> hullo
02:53:57 <lambda> hey
03:16:33 <shapr> hi
03:16:44 <Riastradh> Hi.
03:16:48 <shapr> what's up?
03:16:52 <shapr> lambda: nice nickname
03:17:00 * Riastradh is in vain attempting to figure out how to wear a toga.
03:17:11 <shapr> Riastradh: that sounds nifty
03:17:21 <shapr> don't they fasten at your shoulder?
03:17:25 <Riastradh> No.
03:17:30 <shapr> oh
03:18:17 <shapr> gooood morning #haskell!
03:18:19 <shapr> wassup?
03:18:20 <Marvin--> togas are just a long piece of cloth that you wrap around yourself a few times and hold it together with your arm or hand, isn't it?
03:18:43 <Riastradh> Semicircular pieces of cloth.
03:18:46 <Marvin--> yeah
03:18:55 <Marvin--> but pretty long
03:20:21 <shapr> hah, I got asked to be nice on haskell@haskell.org
03:22:59 <Marvin--> yeah I saw
03:23:19 <Marvin--> I use LGPL for haskell modules, since they're basically always libraries
03:24:00 <shapr> Igloo came up with a nice summary, "lGPL for libraries, GPL for applications"
03:24:19 <shapr> I probably should have said that instead...
03:25:49 <Marvin--> yes, but the border between library and application is kinda blurry for haskell
03:27:31 <shapr> that's true
03:29:25 * Riastradh just tries to avoid the LGPL and the GPL -- too much legalese is dangerous for your health.
03:30:15 <Marvin--> I like the idea of getting contributions back from people who use my stuff, that's why I like the LGPL
03:30:32 <Marvin--> I've released precious few applications so I haven't really worried about the GPL
03:30:48 <shapr> maybe I should encourage that for haskell-libs
03:31:00 <Riastradh> If I wanted that I could simply amend the BSD licence, and still the BSD licence would contain a twentieth of the legalese in the [L]GPL.
03:31:18 <shapr> Igloo: could you write a sentence or two explaining why you think lGPL is good for libs and GPL for apps?
03:31:29 <Marvin--> I'm very very wary of amending existing famous licenses, since IANAL
03:31:35 <Riastradh> IANAL?
03:31:42 <Marvin--> I Am Not A Lawyer
03:33:04 <Riastradh> I don't think you should need to be a lawyer in order to say 'this stuff is free, you can use it wherever you want, just make sure you credit me; and if you make any changes, send 'em back to me.'
03:33:26 <Marvin--> I definitely don't want to say "credit me", that sounds a lot like the advertising clause
03:33:37 <Marvin--> I'd dig up the Hans Reiser thread on debian-devel for you, but it's just way too scary
03:33:48 <Riastradh> What's that thread about?
03:34:32 <Marvin--> the reiserfsck debian maintainer had removed a page-long listing of credits for reiserfs when running reiserfsck at boot since it just flooded your boot screen
03:34:38 <Marvin--> Hans Reiser was really really upset over this
03:35:08 <shapr> why?
03:35:31 <Riastradh> Were the people given credit elsewhere, e.g., in the manpage or in some flag to the program or something?
03:35:53 <Marvin--> I don't remember
03:51:00 * Riastradh sort of figured out how to get this toga on...
03:51:14 <lambda> Riastradh: yes
03:51:36 <lambda> one of the main things now is that in the gfdl (free doc. license) there are so called Invariant sections
03:52:06 <lambda> you can not change them (which is good) and you cannot remove them as a whole (which is probably not so good)... 
03:52:26 <lambda> lots of people at debian are thinking that the dfgl is probably not free at all..
03:52:30 <lambda> (or not free enough)
03:54:04 <Marvin--> that's the current verdict of debian-legal, yes
03:54:11 <shapr> nyehowma Lilith 
03:54:19 <Marvin--> we'll probably have RMS come to debconf3 this summer to discuss the gfdl
03:54:23 <shapr> hello lambda, are you new to #haskell?
03:54:30 <lambda> Marvin--: have they decided yet on whether to exclude stuff from the distro?
03:54:41 <Marvin--> lambda: I don't know, I don't actively follow -legal
03:54:58 <lambda> shapr: yes ;) i have done some haskell programming, and also some Clean, and i like functional languages 
03:55:08 <lambda> hehe, btw. one question
03:55:08 <shapr> welcome to #haskell, do you have any questions?
03:55:17 <shapr> yes?
03:55:21 <Marvin--> train from here to Oslo and back, student tickets bought in advance... ridiculously cheap
03:55:34 <Marvin--> (40 euros)
03:56:03 <lambda> assume i want to code a windowing system (like x windows, or just some add-ons, like gtk or qt..) how would i do e.g. window movement (= changing the windows position)? a pure functional approach would be to copy the window to the new position, but i obviously don't want to do this.. 
03:56:23 <lambda> the question is not about implementation, but about theoretical stuff.. like, a functional way to do that..
03:56:46 <lambda> i know i can do things with state-transformer-monads and so on.. but is there any "clearer" way?
03:56:56 <shapr> check out http://www.haskell.org/yampa/
03:57:09 <shapr> yampa uses arrows instead of monads
03:57:12 <shapr> and that gives some advantages
03:57:33 <lambda> k, will do ;) txalot
03:59:09 <Lilith> aloha shapr
04:01:34 <shapr> aloha Lilith 
04:02:28 <shapr> what's up?
04:02:37 <shapr> Lilith: how did you presentation go?
04:02:54 <Marvin--> aloe?
04:03:33 <shapr> nah, aloe is a plant, aloha is a greeting
04:03:40 <shapr> it's hawaaian
04:03:45 <shapr> hawaiian?
04:03:52 * Marvin-- was trying to be funny :/
04:03:59 <shapr> Hawaiian
04:04:06 <shapr> sorry, I'm not awake yet :-)
04:07:34 <Lilith> shapr: needs rewriting
04:08:09 <Lilith> plus too nervous. my supervisor suggested i write down my points for backup
04:12:34 <shapr> Lilith: so when do you give your presentation again?
04:14:04 <Lilith> shapr: sometime next week. meanwhile i'll practise often
04:17:59 * shapr bounces
04:21:09 <shapr> y0 cfork 
04:39:11 <Kokko> bon j'me casse du bureau moi
04:39:20 <Kokko> y en a marre
05:08:41 * shapr bounces
05:09:08 <cfork> hihi shapr
05:10:09 <shapr> y0 cfork 
05:10:12 <shapr> wazzup?
05:10:59 <cfork> doing assignment on fat12/32
05:11:23 <Smerdyakov> Ew. For what?
05:11:24 <cfork> its kinda nice to learn how the fat filesystem works
05:11:37 <cfork> Computer Architecture and Operating Systems
05:11:42 <cfork> (is the subject)
05:11:53 <shapr> sounds nifty
05:12:06 <shapr> next you'll write a FAT32 reader for Haskell, eh? :-)
05:12:41 <Smerdyakov> Sounds gross.
05:12:48 <shapr> would be nifty code
05:13:40 <cfork> heh
05:13:59 <Igloo> First step towards HaskOS  :-)
05:13:59 <cfork> I'm a bit annoyed at the moment, my horrible computer doesn't like ghc in either Linux or Windows
05:14:04 <shapr> that sucks
05:14:16 <Smerdyakov> I think it's insulting to your intelligence to think that you need to "do an assignment" to understand such a thing.
05:14:38 <cfork> hmm?
05:14:45 <shapr> I often have to use knowledge before it's really integrated.
05:15:25 <cfork> I mean stuff like what bytes 22-23 are used for on the fat12 filesystem
05:15:36 <shapr> sometimes I understand a lot more than the assignment was actually trying to communicate to me.
05:15:36 <Smerdyakov> Not simple knowledge like filesystem layout, AND this stuff doesn't NEED to be integrated. It's just historical curiosity for most students.
05:15:41 <cfork> manually hex editing the bytes on the floppy to undelete files
05:15:53 <shapr> Smerdyakov: that's a good point
05:16:03 <cfork> fat32 is a good thing to support
05:16:11 <cfork> well, if you ever want to write an OS :)
05:16:11 <shapr> do you think it would be more intelligent to get the students to write their own basic filesystem driver?
05:16:19 <cfork> of course
05:16:26 <cfork> University is undiluted poo
05:16:29 <shapr> heh
05:16:46 <Smerdyakov> cfork, if it takes you more than a minute to understand what you need to understand after taking a version of this course that doesn't cover FAT32 specifically, then the course has failed.
05:17:22 <cfork> the course isn't specific on fat32, this is just one assignment
05:17:46 <cfork> I'm approaching the end of my course, and have come to the conclusion I learnt nothing
05:17:54 <cfork> except in management and maths
05:18:01 <cfork> and economics
05:18:33 <cfork> ok, and I was introduced to Haskell, but we did very basic stuff, just a tokeniser
05:19:31 <cfork> how about all you, how was your computer-related courses?
05:20:05 <Smerdyakov> Most were worthless.
05:20:13 <Smerdyakov> A few were awesome.
05:20:21 <Smerdyakov> I just graduated on Sunday. :-)
05:20:25 <cfork> eh? what kinda awesome stuff?
05:20:55 <Smerdyakov> Discrete math and logic
05:20:59 <cfork> ah
05:21:24 <cfork> Discrete Maths was great, and statistics was too
05:21:27 <Smerdyakov> And I can tell you that I sure as hell didn't take a single class in management or economics, in my life! :D
05:21:32 <Smerdyakov> I don't know why you would pick such a degree.
05:21:37 <cfork> really, management is quite good
05:21:44 <cfork> forgot what you think about it :)
05:22:08 <cfork> Smerdyakov: because its a local university, and I couldnt afford to go to any non-two-bit ones :)
05:22:08 <shapr> g'day Lilith 
05:22:26 <shapr> bonjour mattam 
05:22:32 <shapr> comment ça va?
05:22:37 <cfork> this is in a non-capital city in Australia, I can't expect too much from it
05:22:46 * shapr bounces around
05:22:47 <Smerdyakov> cfork, if it takes capitalism as assumed, then it's not for me.
05:22:48 <Lilith> hullo shapr
05:22:56 <Lilith> shapr: so how many languages can you speak?
05:23:49 <shapr> english is my native tongue, and I can talk your ear off in passable French or Swedish, and I can understand and speak a bit of German, Dutch, and Finnish.
05:23:52 <shapr> I can't think of anything else.
05:24:06 <shapr> unless lojban counts :-)
05:24:29 <shapr> languages are fun
05:24:32 <cfork> uno deux tre vier go seis...
05:24:42 <shapr> oh, a bit of spanish also
05:25:03 <shapr> ¿hola, como est as?
05:25:21 <cfork> Buonas noches?
05:25:27 <shapr> yah that too
05:25:32 <Smerdyakov> Misspelled
05:26:17 <cfork> Your not American then shapr? :)
05:26:22 <shapr> oh, I am.
05:26:24 <shapr> I'm from Alabama.
05:26:27 <cfork> but your not mono-linguist
05:26:31 * cfork ducks
05:26:51 <shapr> I was called 'very european' even when I was a teenager.
05:27:05 <shapr> I spent a lot of time an the International House at the university I went to..
05:27:17 <norpan> svenska är kul
05:27:20 <shapr> ja!
05:27:41 <cfork> I'm too shy to speak to the international students at my university
05:27:41 <shapr> svenska är jättekul
05:27:45 <cfork> oh.. and I don't know much korean or japanese
05:27:51 <shapr> cfork: how else will you learn?
05:28:06 * Lilith wonders what's the best way to hunt for papers
05:28:09 <shapr> Lilith: citeseer
05:28:13 <shapr> what are you looking for?
05:28:39 <shapr> hi jdrake 
05:28:49 * shapr boings
05:28:59 <Lilith> shapr: tail recursions
05:29:02 <shapr> oh
05:29:09 <shapr> on the JVM specifically?
05:29:12 <Lilith> yes
05:29:29 <shapr> I've heard that was a problem for the JScheme implementation
05:29:35 <shapr> you may want to see what they have to say about it.
05:29:42 <cfork> shapr: so, what do you think of Scheme? :)
05:30:07 <shapr> cfork: it's nice, I like the attitude
05:30:13 <cfork> I like it too
05:30:18 <shapr> but I also like referential transparency
05:30:22 <shapr> bonjour mattam_
05:30:32 <andersca> spliff
05:30:37 <shapr> sloof
05:30:52 <Lilith> sheesh. everytime i do an update, my fonts get all screwed
05:30:59 <shapr> debian?
05:31:46 <cfork> I like Scheme especially because it has a killer distribution, PLT
05:31:54 <cfork> er, implementation
05:32:07 <shapr> I like scheme's minimalist attitude as opposed to Common Lisp
05:32:46 <mattam_> (re)bonjour shapr 
05:32:53 <cfork> yes.. you get minimalisation, and quite fine librarys such as slib
05:33:32 <shapr> mattam: do you have any Haskell questions?
05:34:36 <mattam> oh no, i'm lying here, I read the Gentle Introduction and i'm currently searching for a little project to get my hands dirty on
05:35:04 <shapr> What sort of projects do you like?
05:36:18 <mattam> i'd like something like doing a regexp engine (i learnt automata theory this year), but I already did that in caml :)
05:36:53 <shapr> I'd like to see a simple regexp engine in Haskell.
05:36:53 <Lilith> haha.this is funny
05:36:54 <mattam> something that embrass the pure functionnal style well
05:37:35 <shapr> hi fabs 
05:37:37 <shapr> Lilith: what what?
05:38:38 <cfork> mattam: a fast fourier algorithm
05:38:53 <cfork> or even better, a simple speech recognition engine
05:39:06 <shapr> whoa, that would be rough
05:39:22 <cfork> hmm, you could just have someone say a word, and use that to logon
05:39:23 <mattam> cfork: if there are places where i can learn ff, why not :)
05:39:50 <d-bug> there's a regexp engine written in 100% common lisp that is faster that Perl's engine(written in C, proably very optimized)
05:40:01 <cfork> mattam: grab a book out on complex numbers, and get the algorithm off a website
05:40:03 <d-bug> i think that's very very impressive
05:40:26 <lambda> d-bug: what's it called?
05:40:39 <cfork> d-bug: very.. I'd like to see a faster one in haskell though :)
05:40:47 <andersca> afternoon, Jolta
05:41:11 <cfork> Someone punch me please
05:41:21 * Lilith punches cfork
05:41:24 <cfork> Thanks
05:41:37 <d-bug> lambda: http://weitz.de/cl-ppcre/
05:42:03 <Lilith> shapr: JScheme == Scheme in Java?
05:42:32 <cfork> I believe http://sisc.sourceforge.net/
05:42:43 <cfork> is a much more fully featured
05:42:47 <cfork> Scheme in Java
05:43:17 <cfork> it outperforms JScheme by orders of magnitude :)
05:43:35 <d-bug> and is more complete :)
05:44:15 <cfork> and programs which use call/cc are reported to be faster in sisc than compiled Scheme programs :)
05:44:22 <d-bug> "CL-PPCRE is faster than Perl in 1511 of 1545 cases - in 1045 cases it's more than twice as fast."
05:44:23 <cfork> (er, which use call/cc heavily)
05:44:44 <d-bug> spank me and call me charlie :)
05:45:09 * cfork spanks d-bug
05:45:17 <cfork> d-bug: charlie
05:45:22 <cfork> :)
05:45:28 <d-charlie> hehe
05:45:42 <Jolta> andersca: hi
05:45:51 <Lilith> cfork: thanks, but i'm not very excited by it
05:46:06 <cfork> SISC?
05:46:22 <cfork> I use PLT Scheme myself, but users of SISC tend to rave about it
05:48:01 <d-charlie> maybe that could in a way solve the lack of libraries and a give access to Java's FFI, JNI
05:50:00 <cfork> SISC programs can access the massive java librarys
05:50:10 <cfork> and use swing
05:53:23 <cfork> actually, if someone wants to make a write a wonderful Haskell program
05:53:31 <cfork> er, program for Haskell
05:53:39 <cfork> I've got just the problem for them
05:55:41 <Jolta> anyone here got a good idea on how to represent "bind" in LaTeX?
05:56:20 <Jolta> I used \gg \hspace{-6pt}= , and it looks ok, but I'm not really happy with it
05:56:50 <Jolta> (that's >>= with the = moved a bit to the left)
06:19:50 <Jolta> so, no TeX gurus here I take it. =)
06:20:14 <Smerdyakov> I've used basic LaTeX a lot, but I'm no guru.
06:23:32 <Jolta> well, I can't seem to find a better solution. 
06:23:56 <Jolta> there should be one, though, considering how many people write papers on monads
06:26:14 <shapr> there's some way that overlaps the three chars
06:26:27 <shapr> what's lilith's email address?
06:28:05 <Smerdyakov> You can use negative hspace to overlap character if you're careful, I think. :-)
06:31:02 * shapr finds Lilith's email addy
06:31:28 <shapr> this is a much better interface to the channel logs: http://tunes.org/~coreyr/ 
06:31:56 <o3> shapr: shuyingw@cse.unsw.edu.au
06:31:57 <shapr> yay, #haskell is in the top three most active of the channels logged by clog 
06:32:05 <shapr> o3: thanks
06:32:07 <o3> hmm, probably shouldn't have clagged that in public.  o well
06:32:28 * Smerdyakov growls at tunes.org
06:32:36 <o3> i hope the loggers obsfuscates email addresses :)
06:32:41 <shapr> I don't know
06:32:42 <Jolta> Smerdyakov: yes, that's what I used (\hspace)
06:33:27 <o3> shapr: it should be easy to store it in morse code form.  any haskell programmer worth their salt will know how to read it ;)
06:33:35 <shapr> heh
06:33:45 <shapr> just keep a copy of remorse handy
06:34:45 <shapr> cfork: what was your wonderful Haskell program idea?
06:35:18 <cfork> hmm, an environment like DrScheme :)
06:35:24 <cfork> but for Haskell
06:35:40 <shapr> what about hIDE with emacs/vim ?
06:35:51 <shapr> http://kungens.kemi.fi/~shae/hIDE.png
06:36:55 <cfork> hIDE\ looks nice too
06:37:11 <shapr> it uses emacs or vim for the editing part
06:37:30 <cfork> hmm thats nice I guess, emacs is ok
06:37:50 <shapr> I should write up Haskell support for speedbar ...
06:37:59 <shapr> would be easy enough to do with the haskell-mode fume stuff
06:38:02 <o3> <evangalise>wait a month and you can use project builder on mac os x :)</evangalise>
06:41:47 <shapr> y0 Mr Jones
06:42:03 <SyntaxPolice> hi shapr; whats up?
06:42:10 <shapr> ceilings!
06:42:37 <shapr> what's up with you?
06:43:00 <SyntaxPolice> I just got rained on.  I'm trying to decide if I can dry off a bit before going out o fmy office to make coffee.
06:59:33 <shapr> so, if I want access to some C functions in an .so file, I use the FFI, right?
07:03:42 <Jolta> um... I guess
07:03:52 <Jolta> never had to do that though
07:03:58 <shapr> Neither have I
07:04:01 <shapr> but it seems a good thing to try
07:05:25 <cfork> Good night
07:05:29 <shapr> g'night
07:05:35 * shapr looks for an hsc2hs tutorial
08:11:27 <shapr> oy
08:16:29 <tmoertel> yo
08:18:43 <pesco> yo
08:40:09 <shapr> y0y
08:40:18 <shapr> so, what's on the menu today?
08:48:47 <pesco> CDR encoding.
08:49:07 <shapr> how does that work?
08:49:32 <pesco> No, I haven't started yet. :)
08:49:40 <shapr> oh
08:49:40 <pesco> But I'll send you any progress I make if you like.
08:50:12 <shapr> sure
08:50:23 <pesco> Do you read comp.lang.functional?
08:51:15 <shapr> yup
08:51:19 <shapr> though not in the last week
08:51:59 <pesco> I've just reinstalle the good old pimp-ass newsreader the other day.
08:52:06 <pesco> Newsgroups are such fun.
08:52:12 <shapr> yah, they're exciting
09:11:37 <shapr> hi hal
09:11:39 <hdaume> morning
09:11:43 <shapr> what's up?
09:11:54 <hdaume> not much....actually a bit ill :(
09:12:04 <shapr> :-(
09:12:15 <shapr> it's hard to code while ill
09:13:15 <hdaume> i concur :)
09:14:05 <shapr> y0 esa
09:14:20 <esap> hi!
09:14:56 <shapr> what's up?
09:15:24 <esap> I'm trying to build a sensible mapping of OO to Haskell.
09:15:54 <shapr> is it working?
09:16:13 <esap> Well almost. I already got layering to work.
09:17:03 <esap> The current problem is how to represent implementations of methods without requiring lots of class constraints.
09:17:57 <shapr> is there a way with lots of class constraints?
09:18:44 <esap> Yes. [Well I still need to fix a couple of "cound not deduce" errors, then I'll see for sure].
09:20:08 <shapr> how does it work?
09:20:40 <esap> My representation for objects is: >newtype Object a w m = New { obj_self :: a (w (Object a w m)) (m (Object a w m)) }
09:21:22 <esap> where 'a' is an arrow, 'w' is the type of requests that can be sent to the object and 'm' is a "strict monad".
09:22:31 <Janni> Long time no see...
09:22:40 <shapr> hi Janni 
09:22:48 <Janni> hi!
09:23:26 <shapr> esap: that's interesting and not totally clear
09:24:07 <shapr> oh, I understand
09:24:17 <esap> shapr: see http://www.kotiposti.net/epulkkin/Functionality.lhs, maybe that's more clear?
09:24:45 <shapr> esap: that's really cool, has anyone else tried to build OO into haskell this way?
09:25:08 <esap> shapr: well O'Haskell has quite similar approach, I guess.
09:25:21 <shapr> but requires a specially modified Hugs
09:25:38 <esap> shapr: at least it uses the message-passing paradigm for it. It does require language extensions.
09:29:00 <esap> shapr: the major idea here is the StrictMonad class which represents a version of Monad that can express layering.
09:30:12 <esap> shapr: in particular, look at 'liftS', which provides a way to go from a higher layer to a lower layer.
09:31:02 <shapr> I don't understand the layered monad part yet..
09:31:20 <shapr> but an object as an arrow from a message to an action is crystal clear
09:32:45 <esap> shapr: ok. compare bindS with (>>=) :: m a -> (a -> m b) -> m b. If you switch the order of the arguments there, you get (=<<) :: (a -> m b) -> m a -> m b. Now look at the type of bindS, it's very close to that, but using arrows.
09:34:03 * shapr ponders that
09:34:37 <esap> The difference is that 'a -> m b' is replaced with 'req a |-> m b' 
09:34:38 <shapr> oh, ok
09:34:48 <shapr> what's the req short for?
09:34:49 <shapr> required?
09:34:56 <esap> request
09:34:58 <shapr> ah
09:35:34 <shapr> so, what's the difference between a request and a command?
09:35:38 <shapr> oh
09:35:41 <esap> they are at different layers.
09:35:50 <shapr> hm
09:36:15 <Smerdyakov> These are pretty arbitrary names. Are you intending this class to be used by others, esap
09:36:16 <Smerdyakov> ?
09:36:17 <shapr> a request is 'a method' ? and those requests actually happen inside the monad?
09:36:53 <esap> smerdyakov: yes, for declaring layers.
09:37:10 <Smerdyakov> esap, OK. You should change the terminology. It's mega-cryptic.
09:37:21 <esap> smerdyakov: it's possible I will rename it once I get it working.
09:37:50 <esap> smerdyakov: what would be better terminology? (Layer for the name of the class? :-)
09:38:42 <esap> But I will definitely have to think about those names.
09:38:44 <Smerdyakov> I don't know, but I doubt anyone in the world would take "request" and "command" to have the meanings you give them, upon first reading.
09:39:47 <shapr> esap: do you have some demo usages of this code?
09:39:48 <esap> Well I don't have better names for those. And will actually correspond to requests sent to the object and commands made by the object.
09:40:01 <Smerdyakov> "in" and "out" based names don't make sense?
09:40:05 <esap> shapr: the 'newpoint' stuff is one.
09:40:06 <shapr> maybe a simple inheritance tree, and some simple instances?
09:40:26 <esap> shapr: I don't have inheritance examples yet, haven't thought of it through yet.
09:40:32 <shapr> ok
09:40:54 <shapr> this is nifty stuff, you should post it to one of the mailing lists
09:41:02 <shapr> I think you'd get some useful or interesting feedback
09:41:05 <esap> well maybe once it compiles :-)
09:41:25 <shapr> :-)
09:43:07 <esap> smerdyakov: hmm.. in and out might be good idea for the specific instances that represent non-monadic version of the requests and commands.
09:43:43 <Smerdyakov> "Request" and "command" are not associated in the least with layer-based transformations, as far as I know....
09:44:30 <esap> smerdyakov: well the name command comes from command pattern used in C++. Monads are really very similar.
09:44:59 <Smerdyakov> Ugh. "Patterns" are not as common knowledge as you may think.
09:45:08 <shapr> I thought they were.
09:45:11 <Smerdyakov> I've never studied them, and I'm almost a PhD student of CS. =)
09:45:20 <shapr> They're useful high level vocabulary.
09:45:39 <Smerdyakov> They're mostly weaker versions of simple functional constructs, as far as I know.
09:45:43 <esap> And the name request comes from message-passing paradigm (and stands for exactly the same thing!)
09:46:49 <Smerdyakov> Well, maybe there are well-regarded computer science programs that require students to learn about "patterns," but I don't know of any.
09:47:07 <Smerdyakov> And it would be a mistake to choose terminology that would be cryptic to people with the main career path of functional programmers.
09:47:29 <shapr> whatever CS programs think, patterns are useful
09:47:58 <shapr> it's like saying "higher order functions," they're just a name for concepts
09:48:16 <shapr> facade, decorator, memento, visitor, etc
09:48:17 <Smerdyakov> Funny how I've gotten along without them!
09:48:22 <shapr> you probably haven't ;-)
09:48:24 <esap> smerdyakov: I think O'Haskell did you command as a name for the same thing, actually, maybe that should be known  to functional programmers? :-)
09:48:59 <shapr> Smerdyakov: I strongly suspect that if you read the GoF book, you'd say, "everyone does this sort of stuff"
09:49:20 <shapr> and we'd say "yup, but now we have shared names for those concepts"
09:49:58 <Smerdyakov> shapr, maybe so. I know that I've read that "visitor," at least, is a weaker version of fold, or something like that. Most of these seem to be worthless when you have functional power available.
09:50:35 <esap> smerdyakov: yes, visitor is the same as fold. And the weaker part is just due to just restrictions in C++ or java, the concept is really the same.
09:50:36 <shapr> Smerdyakov: read the GoF book, come back and talk to us about it.
09:51:18 <Smerdyakov> shapr, sorry, I'm allergic to software engineering :P
09:51:24 * shapr shrugs
09:51:25 <shapr> ok
09:51:46 * esap thinks it's not possible to understand CS without SE.
09:52:04 <Smerdyakov> esap, then I guess I've relied on divine intervention so far.....
09:52:28 <Smerdyakov> esap, how old were you when you first learned programming?
09:52:40 <Jolta> anyone know what the mime-type for Postscript files should be?
09:52:40 <esap> smerdyakov: 9
09:52:52 <Smerdyakov> esap, I was 6. That's probably why. ;-)
09:53:17 <shapr> Smerdyakov: I think you should read the GoF book anyway.
09:53:25 <shapr> because it's good stuff to know.
09:53:50 <andersca> Jolta: application/postscript afaik
09:54:07 <Smerdyakov> I think I have to study a minute amount of software engineering for my Programming Systems qualification exam, so maybe!
09:54:16 <esap> GoF is one of those books that are immediately obvious _after_ you have read it [a bit like SICP]
09:54:22 <shapr> yah, I agree.
09:54:34 <shapr> have you read Fowler's Refactoring book?
09:55:13 <esap> I think I've read a couple of Fowler's books.. I think refactoring was one of them.
09:58:09 <shapr> Smerdyakov: you've probably heard the saying "in theory practice works just like theory, but in practice, they're nothing alike"
09:58:21 <shapr> y0 delYsid!
09:58:22 <Smerdyakov> shapr, maaaaybe
09:58:26 <shapr> gutentag, wie geht es?
09:58:44 <delYsid> ganz gut, danke :)
09:58:56 <delYsid> und selbst?
09:58:56 <shapr> Smerdyakov: I belive that the only way to become a good programmer is to have a balanced diet of theory and practice
09:59:07 <shapr> ich habbe keine ahnung ;-)
09:59:18 <shapr> gut, danke :-)
09:59:20 <delYsid> good reply :)
09:59:23 <shapr> heh
09:59:31 <shapr> you have now seen all the german I know :-)
09:59:58 <delYsid> I'll have to send bea some mail telling her she needs to educate you a bit in that area :)
10:00:02 <shapr> Smerdyakov: I'm a self-employed programmer, if my theories are wrong, I starve :-)
10:00:06 <shapr> heh
10:00:53 <delYsid> hmm, I've just read that Yampa tutorial and now see why people here want to write a RTS
10:01:09 <shapr> so, I think books like "Design Patterns" "The Pragmatic Programmer" "Extreme Programming" are much more about theories/practices to keep self-employed programmers eating.
10:01:38 <Smerdyakov> The only way to become a good programmer is to write programs.
10:01:43 <Smerdyakov> It's that simple. :-)
10:01:57 <esap> smerdyakov: but it's not enough, of course.
10:02:40 <esap> smerdyakov: you also need to see programs written by others. I spent about 10 years just writing OO programs since I didn't know anything better.
10:05:01 <esap> smerdyakov: and even reading about the other paradigms didn't help. You do need to see the architecture that the other paradigms cause to understand how they really work.
10:08:23 * shapr returns from phone call
10:08:34 <shapr> delYsid: yes, yampa is immensely cool stuff
10:08:56 <shapr> delYsid: have you read the Yampa Continued paper where they talk about the tailgating simulation?
10:09:09 <delYsid> nah, where is that?
10:09:15 * shapr gets url
10:09:35 <shapr> http://www.haskell.org/yale/papers/haskellworkshop02/index.html
10:09:48 <shapr> it's also linked from http://www.haskell.org/yampa/ but further down the page.
10:10:18 <shapr> Smerdyakov: just programming isn't enough, it requires a conscious effort to improve your skills.
10:11:05 <Smerdyakov> I don't really agree with you on that. It just requires a conscious effort to create good software, which leads to improving wherever necessary.
10:11:09 <shapr> my Haskillz jumped forward when we had the ICFP contest last year.
10:11:26 <wli> I still need to figure out the valuation ring problem
10:11:45 <esap> wli: what is the valuation ring problem?
10:11:56 <shapr> wli: hey, I was thinking about your recurrence code, that's nitfy stuff
10:12:26 <shapr> I was trying to figure out how I could write a tetration operator to put into the recurrence code, and whether I could ackermann's function by doing something along those lines.
10:12:35 <wli> esap: I need a valuation ring parametrized by the type of function, so either rational functions or polynomial coefficients in terms of n can be handled.
10:12:46 <wli> shapr: hmm
10:13:11 <shapr> iirc, the recurrence code assumed +
10:13:15 * shapr looks
10:13:25 <wli> yes
10:13:29 <wli> they would be instanced of Num
10:13:57 <shapr> I thought it would be nifty to allow the operator to be specified also
10:14:08 <shapr> which is where I started wondering about tetration
10:15:04 <shapr> delYsid: the rpSwitch combinator in the tailgating simulation suffused my brain with niftiness for days.
10:15:35 <shapr> it seems like the perfect way to model any sort of game where you direct semi-independent units/processes/etc
10:16:52 <shapr> I don't understand arrows well enough to know if the Signal functions would be perfect for an RTS game, or if there would be something more suited to the problem domain.
10:17:49 <shapr> Signal arrows mainly deal with time, is that the right focus for an RTS game also?
10:18:58 * Igloo tried to do a bit of coding for that last night, but ran into c2hs problems
10:19:09 <Igloo> I got a black window to appear on the screen for about a second, though  :-)
10:19:12 <shapr> cool
10:19:22 <shapr> are you using dark's haSDL?
10:19:36 <shapr> I wonder if dark will come back to #haskell 
10:19:39 <Igloo> No, using c2hs to effectively call it directly
10:19:42 <shapr> ah
10:19:57 <shapr> dark was rewriting "Programming Linux Games" in Haskell.
10:20:00 <shapr> pretty spiffy stuff.
10:20:15 <shapr> I can give joystick input to a Haskell program =)
10:20:17 * Igloo flops
10:20:26 * shapr megaflops
10:20:49 <shapr> what's the opposite of a flop? an iop?
10:21:22 <shapr> Igloo: what's the difference between c2hs and hsc2hs ?
10:21:26 <shapr> which one should I start with?
10:22:07 <reltuk>  wouldn't c2hs just create imperative haskell?
10:22:15 <Igloo> I haven't used hsc2hs for ages. I assume I thought c2hs was more powerful or I wouldn't have switched, but I might have just been trying it out and forgot to go back
10:22:31 <Igloo> reltuk: It doesn't do what you think it does
10:22:42 <Igloo> It's basically a layer of abstraction on top of the FFI
10:24:02 <reltuk> ahhh, it creates bindings
10:54:36 * Igloo wonders if it is possible to make X DISPLAY aliases
10:54:48 <shapr> ?
10:54:55 <shapr> ssh does something like that
10:55:51 <Igloo> I want to have a DISPLAY whereiam that is either localhost:10.0 (as set by SSH) or :0.0 so that I can have things in screen start in the right place
10:56:10 <Igloo> I could use a preexec, but that's a bit hackier and I can't find an equivalent for bash
10:56:19 <shapr> zsh has a great preexec
10:56:31 <shapr> don't have zsh available in all places?
10:56:54 <Igloo> Haven't even got bash2 in all places  :-)   Although to be fair I have zsh everywhere I want screen
10:57:49 <Igloo> I guess .ing a file isn't that expensive anyway
11:00:18 <ham[star]> esap are you reading?
11:00:20 <ham[star]> hiho
11:00:24 * esap is here.
11:00:39 <Igloo> Oh, preexecs seem to happen in a different shell
11:02:22 <shapr> really?
11:02:43 * Igloo can't make it do anything now - I must be being stupid
11:04:11 * Igloo sighs and tries it in zsh not bash
11:04:21 <shapr> afaik, bash doesn't have a preexec hook
11:04:34 <Igloo> No, that's why it wasn't working  :-)
11:04:59 <shapr> heh
11:05:21 <Igloo> So actually I need zsh everywhere I use screen anyway
11:07:08 <shapr> zsh is spiffy
11:07:27 <Igloo> Do you know if I can say "Add this line to the preexec function" nicely?
11:07:32 <shapr> http://kungens.kemi.fi/~shae/src/zsh/thunderbird.zshrc
11:07:47 <shapr> that may not be the latest version
11:07:47 * shapr checks
11:08:04 <Igloo> I could probably hack something together with which preexec, but it won't be pretty
11:08:22 <shapr> my .zshrc has a preexec function
11:08:45 <shapr> so I can see whether commands have finished by looking at the term titlebar, I don't need to actually check the term
11:08:56 <shapr> that's actually why I switched in the first place
11:09:08 <shapr> zsh is waaay cooler than anything else imho
11:09:25 <reltuk> shapr : you use dvorak?
11:09:31 <shapr> yes, how did you know?
11:09:37 * shapr has dvorak spellcorrect
11:09:39 <Igloo> I haven't got around to *term titles yet, but I have
11:09:41 <Igloo>     precmd() {
11:09:41 <Igloo>         print -nP "\033kzsh: %~\033\134"
11:09:41 <Igloo>     }
11:09:41 <Igloo>     preexec() {
11:09:43 <Igloo>         print -nP "\033k$1\033\134"
11:09:46 <Igloo>     }
11:09:50 <Igloo> for the screen window list
11:10:13 <shapr> oh, I'm using a prompt that does something like that
11:10:20 <reltuk> shapr : when did you switch? and why...
11:10:33 <Igloo> You can't do it with just a prompt
11:10:36 <shapr> 1992, and because I wanted to know if dvorak is better than qwerty
11:10:50 <Igloo> I mean say ^A" in screen gives you something useful rather than a list of n "zsh"s
11:10:56 <reltuk> do ya know?
11:11:05 <shapr> reltuk: know what?
11:11:16 <reltuk> if dvorak is better than qwerty
11:11:22 <shapr> reltuk: I'm still using it :-)
11:11:46 <shapr> imho, YES
11:12:08 <reltuk> did you buy another keyboard, or what?
11:12:13 <shapr> Igloo: yah, I'd rather move ^A to something else, I use ^A as "move-begin-of-line"
11:12:19 <shapr> that too, but much later.
11:12:23 <shapr> I'm using a kinesis
11:12:26 <Igloo> s/say/so/
11:12:29 <andersca> me too!
11:13:02 <reltuk> which one?
11:13:07 <shapr> ergo elan
11:13:14 <reltuk> do you have RSI or something?
11:13:27 <andersca> yeah :/
11:13:28 <shapr> nope, but I don't want to get it either :-)
11:13:46 <jazzman> hm... anybody know pesco's mail address?
11:13:53 <shapr> I've noticed that most people get 'emacs pinky' or so...
11:13:56 <andersca> my RSI is much much better since I got the kinesis
11:14:32 <shapr> so I've moved all of my modifier keys under my thumbs, according to my theory that all chording should be done with the thumbs
11:14:34 <reltuk> did you buy a dvorak keyboard for learning, or did you get it later?  learning on a qwerty seems like it would be hard
11:14:42 <jazzman> ah, found it, forget it
11:14:44 <shapr> just ignore the keycaps
11:14:57 <shapr> I got an IBM clicky and remapped it later
11:15:23 <reltuk> so you just quite cold turkey?  wasn't it frustrating?
11:15:27 <shapr> reltuk: you can learn the home row in a few hours, the upper row in a few days, and the edges may take weeks
11:15:37 <shapr> imho that's the sign of a good layout though :-)
11:16:27 <shapr> reltuk: yah, it was frustrating at first, but I wanted to learn it.
11:16:51 <shapr> isn't everything frustrating at first?
11:17:06 <opet> ice cream isn't
11:17:14 <opet> unless you can't get the lid off the tub
11:17:16 <reltuk> everything worth learning is  :-p
11:17:17 <shapr> heh
11:17:19 <opet> then it's frustrating
11:17:37 <reltuk> not to imply everything frustrating is worth learning of course
11:17:44 <shapr> ice cream is frustrating afterwards
11:17:50 <shapr> when you have to go to the gym to get rid of it
11:18:11 <Igloo> :-)
11:18:25 <reltuk> just seems like I've been typing since I was a small child...seems like it would take years to get back up
11:18:59 <shapr> I'd been typing a lot for four years or so when I switched.
11:19:20 * Igloo goes home
11:19:25 <shapr> bye Igloo!
11:19:44 <reltuk> but you'd say you were back up to speed in like a month?
11:20:20 <shapr> not in everything, but for most things, yes
11:21:13 <Riastradh> Boo!
11:21:18 <shapr> y0 Riastradh 
11:24:12 * shapr boings
11:24:59 * Riastradh attempts to boing but gets his toga caught in the process, resulting in a large pile containing a dazed Riastradh and a confuddled toga.
11:25:14 * shapr snickers
11:25:50 * Riastradh says 'hey, I'd like to see you try and boing in a toga!'
11:26:01 <shapr> I doubt I would do a good job of it.
11:26:08 <shapr> I'd probably get frustrated and boing naked.
11:26:16 * Riastradh milky ways.
11:29:00 * syntax-laptop pops up and looks around
11:29:05 * syntax-laptop pops down
11:29:11 * shapr pops a paper bag
11:41:11 * shapr boings
11:41:23 <shapr> I've been looking at HaskellDB, does anyone know how TREX works?
11:41:56 * buggs slaps shapr with a truck load of lambdas
11:42:20 * shapr does some lambda lifting 
11:42:24 <shapr> the brain is a muscle, ya know
11:43:42 <buggs> no wonder it feels like pudding
11:43:47 <shapr> heh
11:43:52 * shapr flexes
11:44:21 * Riastradh feels shapr's smartness eminating, and therefore collapses to the floor in Latin.
11:53:09 <shapr> anyone here tried HaskellDB?
11:53:15 <shapr> I can't find a license for the code.
13:10:55 * delYsid wonders how to "execute" an arrow
13:11:26 <delYsid> something like run :: a b c -> b -> c
13:12:20 <hdaume> delYsid: wouldn't that be something like 'unsafePerformArrow'?
13:12:46 <hdaume> note that: /me knows next to nothing about arrows 
13:15:25 <esap> delysid: it is actually quite hard. You need to define semantics for 'arrow application'. This is often quite hard to define.
13:18:06 <esap> delysid: in the basic arrow mechanism, arrow application is translated as follows: proc p -> f -< e ===  arr (\p -> e) >>> f   or   arr (\p -> (f,e)) >>> app   depending on bound variables.
13:19:35 <delYsid> hmm
13:19:53 <delYsid> I was just playing with ghci, and wondered if I could get minimal useage working...
13:20:05 <delYsid> guess this concept is even more above my horizon than monads
13:20:13 <esap> delysid: anyway, note that this translation _ignores_ the input (p) [not good] and the second form requires ArrowApply to work.
13:20:40 <delYsid> I ended up with ((arr (+1)) >>> (arr (*2))), and was wondering how to actually use such a beast
13:22:17 <esap> delysid: the arrow interfaces do not themselves provide that. However, most instances should provide a mechanism for applying the arrow [usually some kind of run :: a b c -> b -> IO c or something like that.
13:23:14 <esap> delysid: it's also possible to use run :: a b c -> a2 b c, where a2 is another arrow.
13:23:25 <esap> delysid: but then you just postpone the problem :-)
13:25:41 <esap> delysid: the reason why arrows do not provide any mechanism for applying it is that this would require the arrow interfaces to fix the "base" on which the arrow runs. This should be decided for each instance separately.
13:37:14 <ham[star]> bye
15:59:40 <jdrake> i asked before about speed of haskell but gave no specific examples, I have two now. If we were to take C vs. haskell, which would be faster for a video filter that would remove all the colour in a given frame, and another filter that would add a lense flare to a frame?
16:01:23 <kl4rk\ZzZ> i am a haskell novice but, when speed is an issue good C programming should be best, i've read somewhere
16:01:29 <Darius> Comparing well-optimized C to well-optimized Haskell for the same algorithm, probably C.
16:02:13 <Darius> Haskell likely wouldn't be that far behind, but if you are going for every last bit, you'd still probably be better off with C.
16:03:13 <hdaume> ...and your haskell code will most likely look like C code at that point...
16:03:41 <Darius> Depends on the algorithm, but more or less yes.
16:04:09 <Igloo> I'm not sure I'd agree with that - you'd just have to make sure the right strictness could be inferred
16:04:25 <jdrake> the first filter is a straight brute force thing, where the second is more math than anything
16:05:24 <kl4rk\ZzZ> if you need a very fast code then C, else whatever u like i think
16:06:51 <jdrake> are there any other languages around that are relatively fast too? (slow==python, fast==native compiled)
16:07:20 <reltuk> ocaml ends up being about as fast as C normally
16:07:39 <hdaume> as does sml (using, eg, mlton)
16:08:41 <jdrake> what would make ocaml faster than haskell
16:09:06 <Darius> It's compiler
16:09:07 <mattam> the compiler is optimizing for a particular architecture
16:09:33 <Darius> Languages aren't faster or slower, implementations are.
16:09:59 <ludde> jdrake: it's not lazy
16:10:32 <kl4rk\ZzZ> I don't really agree, higher level languages are slower as they give you less control
16:11:46 <Darius> If some hypothetical compiler always found the fastest opcode sequence (say through brute-force, this is hypothetical) how would it be slower?
16:11:49 <reltuk> that's not true...ocaml is higher level than C, and just as fast
16:12:07 <mattam> Darius: it wouldn't
16:12:26 <Darius> I'm not saying that in reality languages don't make a difference, but that implementations are the main issue.
16:12:38 <buggs> well, a language might allow dynamics that prevent optimization
16:12:56 <kl4rk\ZzZ> Yes, but a perfect compiler can't exist.
16:13:25 <kl4rk\ZzZ> anyway i agree, implementations are the main issue.
16:13:25 <mattam> but it's easier to say than to write. Brute-force isn't the best way, some research are made into adaptation of implementations for a specific need 
16:13:59 <kl4rk\ZzZ> there must be studies comparing hugs to a true haskell compiler, i suppose
16:14:21 <reltuk> what's different about hugs?
16:14:22 <kl4rk\ZzZ> assuming hugs is just an interpreter, which is something i don't really know
16:14:34 <Darius> buggs: yes, the claim is a bit wide, some languages could in theory as well as practice be slower
16:15:08 <kl4rk\ZzZ> so hugs should be slower
16:16:02 <jazzman> mainly, implementations are the issue - but some languages leave out information that can be very hard to extract automatically
16:16:04 <buggs> take scripting languages as an example, or lisp, much of it is in the language
16:16:07 <Darius> buggs: e.g. see "Pure v. Impure Lisp" and "More Haste, Less Speed"
16:16:09 <jazzman> for example, the strictness/laziness issue
16:17:23 <jazzman> C, on the other hand, leaves out other vital information - primarily, the range of side effects
16:17:45 <jazzman> the range of side effects in Haskell is nicely limited... it is exactly zero :o)
16:17:58 <jdrake> isn't that the point of functional languages?
16:18:08 <jazzman> jdrake: yes, of course
16:18:09 <jdrake> anyone use pascal recently?
16:19:01 <Darius> jazzman: Monads are very similar to effect typing systems, which allows you to introduce just as much effects as you need.
16:19:05 <jazzman> jdrake: i saw a Delphi/C comparison recently... Delphi apparently still sucks at optimizing as badly as Turbo Pascal did a decade ago
16:19:52 <jdrake> how about freepascal for gnu pascal
16:20:11 <jazzman> oh... no idea
16:20:42 <jdrake> are there other options for compiled native languages (or languages that convert to C). 
16:21:04 <jazzman> gnu pascal should be a lot better - doesn't it just the gcc optimizer and backend?
16:21:54 <mattam> I think it would be in gcc if it did
16:22:01 <jazzman> jdrake: i saw a language somewhere that was specifically designed as an intermediate language... it looked a bit like c, but had support for tail-end recursion and other nice features
16:22:11 <jazzman> s/just/use/
16:22:55 <Darius> One aspect that no one has mentioned though (as I don't believe it's immediately applicable to jdrake) is parallelism where FP theoretically (though it's becoming reality now) shines.
16:22:55 <hdaume> c--?
16:23:06 <jazzman> hdaume: oh... yeah, that's it
16:23:15 <jazzman> Darius: true, true
16:24:11 <kl4rk\ZzZ> Haskell apps should be easily parallelizable as well wouldn't them
16:24:33 <jazzman> kl4rk\ZzZ: shut up, you're talking in your sleep ;o)
16:24:33 <kl4rk\ZzZ> wouldn't/shouldn't
16:25:02 <kl4rk\ZzZ> heh true
16:25:17 <kl4rk\ZzZ> and nick changing when away is very lame, also
16:25:40 <jazzman> it is?
16:26:07 <kl4rk\ZzZ> i was told so
16:26:26 <kl4rk\ZzZ> but ppl kept msging me while i was away
16:26:41 <kl4rk\ZzZ> i should get more elite friends or something
16:28:21 * jazzman finds nick changing ok
16:28:31 <buggs> there is a parallel haskell
16:30:25 <jazzman> buggs: but who has a MP machine to test it?
16:30:30 <Darius> there's more than -a- parallel haskell
16:30:32 <Darius> shapr
16:30:38 <Darius> no not massively
16:30:52 <Darius> wli has 32 processors
16:30:59 <jazzman> wli?
16:31:19 <kl4rk\ZzZ> he/she must be rich
16:32:32 <Darius> I don't think that it's his personal computer, or at least he didn't pay for it.  I believe he works at IBM
16:33:03 <buggs> Darius just remebered that i was in a lecture about it on it some british guy afair
16:38:10 <seth_> can I do this:  addToFM.emptyFM foo
16:38:35 <Darius> why not unitFM (or whatever)
16:39:26 <seth_> Darius: because I really want to do    addToFM.addToFM.addToFm.emptyFM foo foo foo
16:39:56 <seth_> or addToFM.addToFM.unitFM foo foo foo
16:40:00 <Darius> why not addListToFM emptyFM [foo,foo,foo]
16:40:43 <seth_> Darius: that's probably better.  I still want to know whether something like addToFM.unitFM foo foo    is a correct use of function composition.
16:41:16 <jazzman> it's an example of missing parens (or isn't it?)
16:41:29 <Darius> well, I believe you need (or at least should) have a space, but that should work
16:41:37 <Pseudonym> The latter is correct, the former is incorrect.
16:41:39 <Pseudonym> I think.
16:41:45 <jazzman> shouldn't it read: (addtoFM.emptyFM) foo ?
16:41:46 <Pseudonym> Hmmm.
16:41:49 <Darius> the former isn't correct
16:41:51 <seth_> Pseudonym: you mean all the functions must take one argument?
16:42:02 <seth_> jazzman: Yes, you are correct about the parentheses
16:42:05 <jazzman> function application has precedence over composition
16:42:10 <Pseudonym> Right.
16:42:14 <Darius> addToFM.emptyFM foo
16:42:18 <Pseudonym> So in the first example you're calling "emptyFM foo foo foo"
16:42:24 <jazzman> yes... which is incorrect
16:42:42 <Pseudonym> You could use (addToFM . emptyFM) foo
16:42:47 <Pseudonym> Or: addToFM . emptyFM $ foo
16:43:05 <Pseudonym> Erm.
16:43:14 <seth_> Pseudonym: ok, but once I get the signatures and parentheses correctly placed, I can compose functions in that manner?
16:43:35 <Darius> Pseudonym: A modified for lists (as opposed to powerlists) version of the "Program Optimisation, Naturally" seems about twice as fast as yours.
16:43:48 <Pseudonym> seth_: Yes.
16:43:58 <Pseudonym> Wow, interesting.
16:44:01 * Pseudonym was curious about that
16:44:15 <Pseudonym> Mine might be even less efficient once eval/apply goes in.
16:44:17 <jazzman> i'm not sure if  (addToFM.addToFM.unitFM foo) foo foo  would work... it looks weird
16:44:24 <Darius> I'll post the code, I used.
16:44:28 <Pseudonym> Please.
16:45:26 <jazzman> maybe someone who looks at Haskell code with his brains rather than his guts can clarify this?
16:46:04 <Pseudonym> Did you know that there are more neurons in the gut than in the brain?
16:46:11 <Pseudonym> A pathology student told me this once.
16:46:13 <jazzman> neurons...?
16:46:20 <Pseudonym> Nerve cells.
16:46:31 <jazzman> hm... i know there are neurons in the spine
16:46:32 <Pseudonym> The gut works autonomously even when the brain is taken out.
16:46:37 <kl4rk\ZzZ> But some people have spread these neurons all over the world
16:46:57 <Pseudonym> Just goes to show, if you think with your stomach, you might actually be smarter.
16:47:10 <kl4rk\ZzZ> haha
16:47:13 <jazzman> Pseudonym: crazy theory
16:47:35 <Pseudonym> But this is a guy who dissected rat duodenum glands for a living.  What would he know?
16:47:52 <jazzman> it's all the same... rats, apes, humans
16:48:04 <Pseudonym> Well yes, eventually he was going to get to humans.
16:48:19 <Pseudonym> But he only needed rats to get a PhD.
16:48:23 <jazzman> lol
16:48:39 <Pseudonym> Computer scientists should try this some time.
16:48:44 * Verbed suggests #trivia
16:49:13 * Pseudonym suggests implementing a gut neural simulator in Haskell, thus bringing us back on topic
16:49:36 <Pseudonym> Anyway, jazzman, what about your code?
16:53:45 <jazzman> Pseudonym?
16:56:27 <Pseudonym> Yes?
16:56:33 <Pseudonym> Oh, he's gone.
16:56:47 <hdaume> suppose i have 'newtype IdT m a = IdT (m a)' and make it an instance of Monad (when Monad m).  i get something like 'instance Monad m => Monad (IdT m) where return a = Id (return a)'.  is this call to return considered recursive?  i don't really think so, but i don't know another name for it
16:57:21 <Pseudonym> It's hard to say what's recursive and what isn't in the case of overloading.
16:57:34 <kl4rk\ZzZ> bye ppl
16:57:37 <Pseudonym> Bye.
16:57:54 <hdaume> Pseudonym: yeah :)
16:57:58 <Pseudonym> It also makes profiling a complete bitch.
16:58:03 <hdaume> :)
16:58:34 <Pseudonym> If you have "foldr" at the top level, which then goes deep, deep down and calls "foldr" again, how can you meaningfully tell how much time is spent inside foldr?
16:59:13 <Pseudonym> A colleague of mine did some research on this before cost centre profiling hit the streets, but his supervisor didn't let jim write it up until a month ago.
16:59:18 <Pseudonym> him, not jim
16:59:21 <Pseudonym> His name is not jim.
16:59:57 <Pseudonym> I personally think that "recursion" is in the intent rather than in the use.
17:00:12 <Pseudonym> I don't know what to call this, though.
17:00:31 <hdaume> i mean, i would not really call this recursion, since the same function isn't getting called.  i just don't know what to call it :)
17:00:44 <Pseudonym> It's fairly close to the "chain of responsibility" design pattern from the Gang of Four.
17:00:51 <hdaume> yeah
17:01:04 <Pseudonym> I might be tempted to give it a name based on that.
17:01:33 <Pseudonym> Oh, interesting.
17:01:39 <Pseudonym> On the wiki, I called it "stacked delegation".
17:01:41 <Pseudonym> I like that.
17:01:51 <hdaume> i like that too :) thanks
17:02:05 <Darius> I was wondering about that too in OO.
17:02:12 <Pseudonym> http://haskell.org/hawiki/ChainOfResponsibility
17:04:58 <Pseudonym> Is there a good tutorial around on using IORefs?  I'd like to point someone to one if there is.
17:05:20 <hdaume> Pseudonym: not that i know of, but they're not very complicated
17:05:40 * Pseudonym nods
17:05:42 <Darius> Is it recursion when you call the same virtual method on an object in that method when the object may or may not be the same/same 'type'
17:06:05 <Pseudonym> Darius: Like I said, I think recursion is in the intent.
17:06:49 <Pseudonym> In Haskell, there aren't really "virtual method calls".  Type-based dispatch is actually overloading.  (Though they are somewhat equivalent.)
17:07:04 <Darius> anyways, http://www.haskell.org/hawiki/HaskellIrcPastePage
17:07:37 <seth_> Pseudonym: there are in effect virtual function calls when you have a default class function and that function is overridden
17:07:57 <Pseudonym> Sure.
17:08:07 <Pseudonym> Like I said, they're equivalent.
17:08:13 <Pseudonym> They do the same job.
17:08:51 <seth_> Pseudonym: oh, ok, when you said 'type based dispatch' I thought you meant the argument type, not the "object" type.
17:10:01 <Pseudonym> Well there isn't really an "object" type in Haskell, of course.
17:10:13 <seth_> right, that's why I used quotes
17:10:29 <Pseudonym> Though one of these days I'm going to find a use for an idiom which I dreamed up which kind of does.
17:10:48 <seth_> what't the idiom?
17:10:53 <Pseudonym> It's kind of the dual to phantom types.
17:11:02 <Pseudonym> You know about phantom types?
17:11:20 <seth_> I thing I've seen the term, but no, not really.
17:11:38 <Pseudonym> The idea is you use the type system to check well-formedness for you.
17:11:50 <Pseudonym> You do this by using polymorphism where there otherwise is none.
17:12:03 <Pseudonym> Here's an example: http://www.haskell.org/hawiki/SimulatingDependentTypes
17:12:12 <Pseudonym> That uses the type system to guarantee that a tree is balanced.
17:12:38 <Pseudonym> By introducing polymorphic type variables which don't appear in the structure itself.
17:13:21 <seth_> ok, I'll have to read that carefully but I get the general idea.
17:13:37 * Pseudonym nods
17:13:47 <Pseudonym> An example that I came up with recently is here:
17:14:14 <Pseudonym> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/physics/
17:14:34 <Pseudonym> This uses the type system to ensure that your physics computations are unit-correct.
17:14:45 <Pseudonym> So I can type this:
17:14:45 <Pseudonym> newtonsSecondLaw :: Mass -> Acceleration -> Force
17:14:46 <Pseudonym> newtonsSecondLaw m a = m `mult` a
17:14:52 <Pseudonym> and it's all checked by the type system.
17:15:02 * Darius was frustrated right at the end when the code didn't compile, then he realized that that's what is was supposed to do :P
17:15:15 * Pseudonym laughs
17:15:19 <Darius> the error message was great though
17:15:35 <seth_> Darius: you mean the compiler is supposed to barf on it due to the error in units?
17:15:48 <Pseudonym> OK.  the point is that phantom types use types which are not backed by real data.
17:16:03 <Darius> I was talking about SimulatingDependentTypes
17:16:12 <Pseudonym> Anyway, my idea is something like C++ traits classes.
17:16:21 <Darius> I didn't have ex4 commented the second to last time
17:16:34 <Pseudonym> Where you have data which is not backed by types.
17:16:49 <Pseudonym> Consider, for example, how you would implement "limits.h" in Haskell.
17:17:28 <Pseudonym> In C, you have definitions like MAX_INT, MAX_LONG etc.
17:17:44 <Pseudonym> In C++, you have traits classes, so you have, say, numeric_traits<int>::max().
17:18:01 <Pseudonym> In Haskell, what you want is something like this:
17:18:05 <seth_> Pseudonym: ok...
17:18:07 <Pseudonym> class NumericTraits t where
17:18:16 <Pseudonym>     max :: t
17:18:38 <Pseudonym> instance NumericTraits Int where { etc }
17:18:44 <Pseudonym> That's the easy part.
17:18:57 <Pseudonym> Now consider FLT_RADIX, DBL_RADIX etc.
17:19:09 <Pseudonym> These are integers.
17:19:12 <Pseudonym> So you want:
17:19:18 <Pseudonym> class FloatTraits t where
17:19:21 <Pseudonym>     radix :: Int
17:19:25 <Pseudonym> Which is illegal in Haskell.
17:19:49 <Pseudonym> You need "t" somewhere in the type of radix otherwise there's no way to tell which version you want.
17:20:21 <seth_> Pseudonym: why is that illegal?
17:20:33 <Pseudonym> Well, suppose you had a couple of instances:
17:20:34 <seth_> I don't see the multiple versions
17:20:42 <Pseudonym> class FloatTraits Float where { radix = 10 }
17:20:47 <Pseudonym> class FloatTraits Double where { radix = 10 }
17:20:51 <Pseudonym> Now you use "radix" somewhere.
17:21:09 <Pseudonym> Actually make taht:
17:21:12 <Pseudonym> class FloatTraits Double where { radix = 2 }
17:21:19 <Pseudonym> Now you call "radix".
17:21:22 <Pseudonym> Which version do you get?
17:22:00 <seth_> I see what you mean, because radix doesn't operate on the class data.
17:22:05 <Pseudonym> More to the point, how do you tell Haskell which version you want?
17:22:16 <Pseudonym> Exactly.
17:22:21 <seth_> right, so what is your solution?
17:22:24 <Pseudonym> OK, now there are a couple of possible solutions.
17:22:30 <Pseudonym> One is to use an exemplar.
17:22:39 <Pseudonym> class FloatTraits t where
17:22:42 <Pseudonym>     radix :: Int
17:22:44 <Pseudonym>     zero :: t
17:22:46 <Pseudonym> Sorry
17:22:49 <Pseudonym>     radix :: t -> Int
17:22:49 <Darius> t -> Int
17:22:58 <Pseudonym> Then you could use radix (zero :: Float)
17:23:20 <Pseudonym> I can envisage a situation where not all types have a convenient exemplar, though.
17:23:27 <Pseudonym> There's always:
17:23:32 <Pseudonym> Then you could use radix (undefined :: Float)
17:23:43 <Pseudonym> That'd also work.
17:23:45 <Darius> Go inconsistency!
17:23:49 <Pseudonym> Yup.
17:24:25 <Pseudonym> Another solution is to introduce a data constructor whose only purpose is to be a type.
17:24:33 <Pseudonym> data TyFloat = TyFloat
17:24:38 <Pseudonym> data TyDouble = TyDouble
17:24:58 <Pseudonym> class FloatTraits ty t | ty -> t, t -> ty where
17:25:03 <Pseudonym>     radix :: ty -> Int
17:25:22 <Pseudonym> Now this is not a good solution for this specific case.
17:25:38 <Pseudonym> However, with it, you can implement something like the "strategy" pattern from GoF.
17:26:00 <Pseudonym> For example, if you're implementing a TCP stack, you could do this:
17:26:32 <Pseudonym> class TcpPacket state where
17:26:43 <Pseudonym>     processPacket :: state -> Packet -> IO ()
17:27:20 <Pseudonym> data FIN_WAIT_1 = FIN_WAIT_1
17:27:36 <Pseudonym> data ESTABLISHED = ESTABLISHED
17:27:37 <Pseudonym> etc
17:27:40 <Pseudonym> Then:
17:27:53 <Pseudonym> instance TcpPacket ESTABLISHED where
17:28:02 <Pseudonym>     processPacket _ packet = ...
17:28:06 <Pseudonym> Actually, you probably want:
17:28:10 <Pseudonym>     processPacket :: state -> Packet -> IO state
17:28:21 <Pseudonym> Because in general, processing some kinds of packets put you in a new state.
17:28:37 <Pseudonym> Kind of get the idea?
17:28:52 <Pseudonym> I suspect this is a solution looking for a problem.
17:29:19 <seth_> I see what you mean.  But the code would be difficult to eyeball
17:29:27 <Pseudonym> Yes, it possibly would.
17:29:40 <Pseudonym> But you never know.  There might be a problem for which this is less worse than the alternatives.
17:29:44 <seth_> If you need some object features, then might as well go ahead and add those features.
17:30:23 <Pseudonym> One thing that constantly surprises me about Haskell is how much you can do with just the base language (including all the GHC extensions).
17:30:27 <Pseudonym> Kind of like C++ templates.
17:30:34 <Pseudonym> They keep on surprising me too.
17:30:53 <seth_> But C++ templates are really bad things.
17:31:13 <Pseudonym> I'm not so sure.  As generics, they're pretty good.
17:31:25 <Pseudonym> As compile-time execution mechanisms, they do the job, but they're pretty ugly.
17:31:35 <seth_> they tie the C++ compilers in knots.
17:31:56 <Pseudonym> I'm not so sure that the SimulatingDependentTypes code doesn't.
17:31:58 <seth_> and i see so much poor usage of c++ templates in code that I review.
17:32:07 <Pseudonym> Ah, well.  There you go.
17:32:12 <Pseudonym> You can't help a bad programmer.
17:32:18 <Pseudonym> OK, that's not true.
17:32:22 <Pseudonym> You can help a bad programmer.
17:32:32 <Pseudonym> You can LART them if they misuse language features.
17:32:39 <seth_> Pseudonym: how, alternative job training?
17:33:28 <Pseudonym> No, I find a cricket bat works fine.
17:33:48 <Pseudonym> In the US, it would be a baseball bat.
17:33:50 <Darius> I was thinking of using fundeps to make indexed combinations, e.g. class SMonoid selector a | selector -> a where ...; data AddInt = AddInt; instance AddInt Int where ...
17:34:07 <Pseudonym> There's an interesting idea.
17:34:16 * Pseudonym has got to go
17:34:18 <Pseudonym> Free cakes.
17:34:24 <Pseudonym> Free cakes are important, IMO.
17:34:30 <Pseudonym> BBIAB
17:35:20 * Verbed suggests #trivia
17:37:54 <Igloo> Hiyas
17:39:39 <Darius> heya
17:39:49 <ChilliX> Moin
17:40:51 <ChilliX> Igloo: sorry, haven't read your 2nd paper yet (too much stuff at uni atm...)
17:41:55 <Igloo> No problem - I sent it off this afternoon anyway
17:44:09 <Igloo> So that's my first submission done, and I suspect I'll have my first rejection before too long  :-)
17:45:44 <ChilliX> so much optimism? ;-)
17:46:17 <Darius> Hey, when you're a pessimist and surprised you are happy, when you aren't surprised you're prepared.
17:46:42 <Igloo> Well, I will be very happy if one gets accepted, but if both do I'll be amazed  :-)
17:47:01 <ChilliX> ok, fair enough
17:47:15 <ChilliX> I sent you the bib entry for the C->HS paper
17:47:25 <ChilliX> you are right about the bib entries for my web page
17:47:35 <ChilliX> I am just too lazy, that's the problem
17:47:41 * Igloo got the impression more than one TH paper was unlikely
17:48:12 <Igloo> No, the problem is everyone else is also lazy
17:48:24 <Darius> Damn Haskellers!
17:48:38 <Igloo> It would be much more efficient for everyone to just do their own and not then have to expend effort making entries for everyone elses  :-)
17:48:47 <ChilliX> true
17:49:07 <ChilliX> plus everybody makes their own anyway
17:49:18 <Igloo> I did my best not to  :-)
17:49:34 <Igloo> Curious, Oege told me I should get page numbers for all of them
17:49:35 <ChilliX> I have mine in this gigantic file where I have all the others, too
17:49:48 <ChilliX> :-)
17:50:14 * Igloo will update the entry for the final copy if accepted, thanks
17:50:15 <ChilliX> yeah, in theory, one should do that, but sometimes I am again too lazy ;-)
17:51:06 <Igloo> Ah, well that's not so bad to do yourself. But having to go to the library to find page numbers is a real PITA  :-)
17:51:17 <Igloo> Although I did get to gaze in wonder at how much space LNCS takes up
17:53:38 <ChilliX> :-)
17:53:47 <Igloo> So, have you started your kid programming yet?
17:54:11 <ChilliX> only some very basic routines
17:54:31 <Igloo> :-)
17:57:05 <ChilliX> will you go to PLI anyway or only if one of your papers is accepted?
17:58:15 <Igloo> I haven't asked Oege what-ifs
17:58:38 <Igloo> I hope I'll be able to go anyway, but I don't know how easy he will be to convince of that
17:59:15 <ChilliX> ic
17:59:27 <Igloo> Why do you ask?
17:59:35 <ChilliX> just curious
18:00:09 <Igloo> I guess the backup plan is to win the ICFP contest  :-)
18:00:20 <ChilliX> hehehe
18:01:32 <Igloo> Will you be going?
18:01:48 <ChilliX> yep, definitely want to go
18:02:33 <ChilliX> I have applied for SSP (= sabbatical) for next session
18:02:40 <ChilliX> PLI is part of that
18:02:52 <Igloo> Is a session a third of a year?
18:03:02 <ChilliX> session = semester
18:03:13 <Igloo> Is a semester a third of a year?
18:03:32 <ChilliX> semester = half; trimester = 1/3
18:03:41 <Igloo> Aha
18:04:06 <Igloo> So does that mean UNSW will pay for you to go?
18:04:31 <ChilliX> I probably pay it from a research grant
18:04:50 * Igloo guesses the kid is part of the reason for the SSP?
18:05:18 <ChilliX> kind of, although ssp doesn't mean less work
18:05:40 <Igloo> Ah, OK
18:05:51 <ChilliX> but nori is going to visit her parents with Leon
18:06:04 <ChilliX> and so it is nice if I can be in Europe at the same time
18:06:14 <ChilliX> we maybe bring him to PLI actually
18:07:26 <Igloo> Nori is your wife, Leon your child and her parents are in Europe?
18:07:48 <ChilliX> aherm, yeah
18:07:54 <ChilliX> thought you know nori
18:08:03 <ChilliX> we are both German
18:08:12 <ChilliX> all our families are in Germany
18:08:24 <Igloo> I don't think so - I've only met you at AFPSS I think
18:08:37 <Igloo> nori is a type of dried seaweed apparently
18:08:50 <ChilliX> didn't mean you know her in RL, just know of her
18:09:05 <ChilliX> true (about the dried seaweed)
18:09:20 <Igloo> Oh, OK, don't think so, but that might just be me being dopey
18:09:27 <ChilliX> nori = http://www.cse.unsw.edu.au/~keller/
18:09:51 <Igloo> Oh, a colleague!
18:10:00 <Igloo> Hmmm
18:11:12 <Igloo> She doesn't have bibtex entries either  :-)
18:11:43 <ChilliX> she is lazy, too ;-)
18:11:48 * Igloo giggles at the percentage of coauthored papers - how sweet  :-)
18:12:32 <ChilliX> if you talk about the stuff anyway, writing the paper together is kind of natrual, I guess
18:13:34 <Igloo> Yeah, makes sense
18:13:57 <Igloo> Oh, you probably talked about her WRT parr stuff but I would have missed the relationship
18:14:25 <ChilliX> yes, parr is our joint project
18:14:41 <ChilliX> a lot of it is actually from her PhD thesis
18:15:34 <ChilliX> a lot of it = many of the core ideas
18:18:58 <ChilliX> (in her thesis, it wasn't about Haskell yet, just a model for parallel programming)
18:19:17 <Igloo> *nod*
18:19:47 * Igloo checks the HW page and wonders how I'm meant to wait a whole month before hearing back
18:20:29 <ChilliX> my strategy is to forget about it
18:20:49 <ChilliX> just ignore that papers until the emails from the PC suprise you one morning
18:21:31 <Igloo> :-)
18:21:43 <Igloo> Maybe I should try and compile hat again to take my mind off of it
18:22:19 <Igloo> Ewww, but then I'd have to worry about how hat and packages interoperate
18:22:20 * Darius built Buddha (on Win2k), but has nothing to use it on
18:25:53 <ChilliX> Darius: just write a buggy program; shouldn't be that hard!
18:26:46 <Darius> ChilliX: Buddha doesn't work on C ;)
18:27:25 <ChilliX> Darius: write a buggy Haskell program?
18:27:45 <ChilliX> Igloo: what's the story with THSyntax and the changes that were discussed a while ago?
18:28:12 <ChilliX> (parametrisiation of datatypes, names, etc)
18:28:44 <Igloo> I've deparameterised things and renamed Expr -> ExpQ etc
18:29:05 <ChilliX> cool
18:29:17 <Igloo> I meant to ask you to clarify what you meant about LetE etc, but I can't remember the details
18:29:27 <Igloo> Maybe it was the letE functions actually
18:29:33 <Darius> bah, I'll need to rewrite my TH code... again.
18:29:35 <ChilliX> yeah, it was letE
18:29:51 <Darius> But first I need to get GHC to build again.
18:30:03 <ChilliX> some of these tree constructor functions are named without a suffix E and some with E
18:30:08 <Igloo> Darius: I *think* it's currently broken, but that could just be my local tree
18:30:31 <Igloo> Chilli: But was it just the Exp (and Dec) datastructures or all of them you wanted renamed?
18:30:44 <ChilliX> they have a suffix E if the name would otherwise be a reserved identifier
18:30:49 <Darius> I haven't hit the broken parts yet, I still need to have enough memory free and deal with annoying path issues
18:30:56 <ChilliX> that's not nice
18:31:12 <ChilliX> the scheme should be uniformly so that there is never a clash
18:31:26 <Igloo> letExp would be silly as it would mean binSt should be bindStatement which is far too long
18:31:48 <Igloo> OK, so you'd also want pvarP for example?
18:33:34 <ChilliX> to be honest, I don't like the naming of the constructors of Pat either
18:33:55 <ChilliX> I'd called them LitPat, VarPat, etc
18:34:13 <ChilliX> then, the functions could just be litPat, varPat
18:34:24 <Igloo> Do the same to Exp and just lowercasing the first letter would work again
18:34:27 <Igloo> Yeah
18:34:31 <ChilliX> exactly
18:34:36 <ChilliX> that would be a uniform scheme
18:34:59 <ChilliX> instead of the current jungle of exceptions
18:35:00 <Igloo> So do you think Statement should be renamed to Stmt?
18:35:23 <ChilliX> that would probably be best
18:35:32 <ChilliX> it is a common abbrev
18:35:51 <ChilliX> and would allow for a uniform scheme
18:36:59 <ChilliX> I know it is a lot of renaming, but it might be worthwhile before 6.0 comes out
18:37:04 <ChilliX> and it is baked in stone
18:37:37 <Igloo> Yeah
18:37:48 <Igloo> Did you notice version numbers being updated in CVS?
18:38:10 <ChilliX> nope, have they?
18:38:15 <Igloo> Yup
18:38:19 <ChilliX> urgh
18:38:27 <ChilliX> I need to do some last FFI stuff...
18:39:01 <ChilliX> better do it today, I guess
18:41:12 * Igloo wonders if it's worth mailing the list again before renaming the datatypes
18:41:28 <Igloo> Probably not, no-one else answers anyway
18:42:32 <ChilliX> hmm, you are probably right
18:43:32 <Igloo> SimonM has given THSyntax Stability   :  provisional
18:43:38 * Igloo goes to look for a list of stabilities
18:45:51 <saz> hi ChilliX :)
18:46:25 <ChilliX> saz: hi
18:47:31 <ChilliX> Igloo: I guess the provisional is for after the 6.0 release
18:47:43 <ChilliX> even more reason to get everything done now
18:47:53 <Igloo> Chilli: Huh?
18:48:27 <ChilliX> well after 6.0 is released with TH, people will be less happy to accept changes
18:48:44 <ChilliX> that's what SPJ said in one email on the TH list, too
18:48:52 <ChilliX> didn't he?
18:49:50 <Igloo> Not in [Template-haskell] Release AFAICS
18:51:05 <Igloo> I think I might change it to experimental when I next touch it with a comment of a big renaming coming
18:51:28 <Igloo> Or I could just do the renaming
18:51:50 <ChilliX> maybe I was just inferring this from SimonM's comment " We want to treat 6.0 as a beta-quality release
18:51:50 <ChilliX> - get the new technology out there for people to test (mainly Template
18:51:50 <ChilliX> Haskell)"
18:52:18 <ChilliX> ones people test it and write code, changing names will lead to more complaints
18:52:46 <Igloo> Yeah, fair enough
19:55:19 * Igloo bounces
19:55:43 <ChilliX> ?
19:55:43 * cfork bounces
19:56:06 <Igloo> Things working, that's all  :-)
19:56:15 <ChilliX> what's working?
19:56:45 <Igloo> And I've just committed a change to fptools/ghc/compiler/main/Main.hs, which is scary  :-)
19:56:48 <Igloo> GHC
19:57:00 <ChilliX> indeed
19:57:26 <cfork> elite of the elite- committing to that :)
20:03:41 <Igloo> Right, bedtime - night all
20:03:46 <ChilliX> night Igloo
20:04:39 <cfork> g'night
20:39:51 <flippo> @yow
20:39:52 <lambdabot> ..  the MYSTERIANS are in here with my CORDUROY SOAP DISH!!
20:41:17 <Pseudonym> @yow
20:41:18 <lambdabot> If elected, Zippy pledges to each and every American
20:41:18 <lambdabot>  a 55-year-old houseboy...
20:42:45 <cfork> @yow
20:42:46 <lambdabot> Is this my STOP??
20:43:04 * Darius wonders how close to named instances he can get with fundeps and implicit parameters
20:44:02 <Pseudonym> Actually, going back in the thread for a bit, my daughter knew how to suspend a process from the age of about 12 months.
20:44:23 <Pseudonym> It helps that Ctrl and Z are close on the keyboard.
20:44:58 <wli> I'm still stuck on the valuation ring problem.
20:47:25 <Darius> Hey, Z is just as close to Ctrl on Dvorak as it is on QWERTY
20:47:37 <Pseudonym> The one thing I don't want is to force all "interesting" Haskell applications to be a certain licence, or to be non-commercial.
20:48:17 <Pseudonym> There's an argument for making all libraries shipped with the distro being the same licence (or effectively the same licence).
20:48:33 <Pseudonym> (e.g. some could be MIT, some LGPL, the effect is all is distributable under LGPL)
20:49:04 <Pseudonym> We could also get around the GPL by mandating that Haskell be distributed with all computers.  That way we make it into the "system component" clause.
20:49:11 * Pseudonym would be in favour of that
21:26:18 <ozone> Igloo: thanks for fixing those TH bugs :)
21:27:24 <ChilliX> ozone: he's already asleep...
21:27:46 <ozone> ChilliX: ah
21:31:00 <Pseudonym> Has anyone been following the monad transformer thread on libraries?
21:31:45 * Pseudonym is just curious if any other MTL users have opinions on the question of how many instances are reasonable
21:36:23 <Darius> I noticed a post about (e->) and (Either e) being unreasonable.
21:37:39 * shapr yawns
21:40:43 <shapr> @yow
21:40:43 <lambdabot> It was a JOKE!!  Get it??  I was receiving messages
21:40:43 <lambdabot>  from DAVID LETTERMAN!!  YOW!!
21:40:57 <cfork> @yow
21:40:57 <lambdabot> Should I start with the time I SWITCHED personalities with a BEATNIK
21:40:57 <lambdabot>  hair stylist or my failure to refer five TEENAGERS to a good OCULIST?
21:40:58 <Pseudonym> Go sleep.
21:41:21 <shapr> I have just awakened!
21:41:35 <Pseudonym> Oh.
21:41:37 <Pseudonym> G'day, then!
21:41:43 <shapr> g'day Pseudonym
21:41:46 * shapr bounces around
21:42:08 <cfork> g'day shapr! howzzit goin
21:42:12 <cfork> :)
21:42:20 <shapr> g'day cfork 
21:42:26 <shapr> it's sunny and warm
21:43:18 <cfork> hmm same here
21:43:26 <Fractal> I'm impressed! Haskell User Libs is really coming along...
21:43:36 * shapr cheers
21:43:52 <shapr> hi Fractal, people were asking about your code on haskell@h.o
21:43:54 <ozone> i see the australians are infecting the rest of the channel
21:44:02 <Fractal> I may be submitting an async DNS library soon...
21:44:07 <shapr> cool!
21:44:10 <Fractal> shapr : haskell@h.o ?
21:44:17 <shapr> Fractal: the main haskell mailing list
21:44:22 <Fractal> Oh ya? Cool..
21:44:28 <Fractal> What did they ask?
21:44:46 <shapr> They asked about the license, and for your email in case no license could be found.
21:44:55 <shapr> I pointed them to the crypto dir on haskell-libs
21:45:04 <Fractal> Oh, cool.. They're all GPL
21:45:09 <Fractal> Cool, thanks.
21:45:14 <Pseudonym> Haskell is very big in Australian universities.
21:45:24 <Pseudonym> As is logic programming.
21:45:34 <shapr> seems there's a Haskell crypto collection coming together
21:45:37 <Pseudonym> Someone smart worked out that Haskell is easier to teach to first years than Prolog.
21:45:44 <Pseudonym> And it's infected most of the country.
21:45:46 <shapr> Pseudonym: is that true?
21:45:53 <Pseudonym> It's mostly true.
21:46:08 <Pseudonym> Some important universities have caught the bug.
21:46:19 <Pseudonym> And since academics move around occasionally, it is spreading slowly.
21:46:23 <cfork> Haskell is certainly taught in my Australian university
21:46:33 <Pseudonym> And in the one I used to go to.
21:46:39 <cfork> It is *not* received well by many students, though
21:46:47 <Pseudonym> Yeah, well.
21:47:01 <cfork> Last person I talked to said he thought they taught Haskell to show how good C++ is
21:47:02 <shapr> Is that because of prior procedural programming experience?
21:47:09 <cfork> possibly
21:47:09 <shapr> ah, I see
21:47:11 <Pseudonym> They no doubt ask "why are you teaching us Haskell when we should be learning something useful like C++"?
21:47:33 <Pseudonym> Only 10 years ago they were asking "why are you teaching us C++ when we should be learning something useful like Pascal"?
21:47:34 <cfork> Pseudonym: yes- most of the people in my classes can't program
21:47:41 <cfork> (very well)
21:47:51 <Pseudonym> And 10 years before that "why are you teaching us Pascal when we should be learning something useful like Fortran"?
21:48:04 * Pseudonym nods
21:48:11 <Pseudonym> IMO, Haskell is an excellent equaliser.
21:48:25 <shapr> how so?
21:48:41 <Pseudonym> Not only does it mean that people who already are Visual Basic script kiddies don't get an advantage, you start learning computer science from the very start (as opposed to, say, Java syntax).
21:49:03 <shapr> I hadn't thought of that.
21:49:16 <Pseudonym> IMO, the latter reason is WAY more important.
21:49:31 <shapr> I guess there aren't many who arrive in university with preconceived notions about pure FP
21:49:32 <Pseudonym> If you can teach binary search trees in the first six months of undergraduate degree, that's a big advantage.
21:49:44 <ChilliX> because we got so sick of this question (why teach Haskell), here the final answer: http://www.cse.unsw.edu.au/~chak/papers/CK02a.html
21:49:53 <Pseudonym> If not, you spend the entire course learning the peculiarities of some language.
21:49:57 <shapr> hi ChilliX!
21:50:07 <ChilliX> Should appear in the Journal of Functional Programming soon
21:50:14 <Pseudonym> I remember putting it less politely, ChilliX.
21:50:27 <Pseudonym> One of the sysadmins created a cs.holywars newsgroup and I wrote the FAQ.
21:50:37 <Darius> And the former is why programmers coming to Haskell don't like it.  How many programmers are used to picking up a new language in about a week.
21:51:14 <ChilliX> Hi shapr!
21:51:36 <cfork> I'm quite glad Haskell is reportadly getting taught widely in Australia.. maybe some jobs will be created?
21:51:39 <Pseudonym> Basically, I said that you're not here to learn language X, you're here to learn computer science.
21:51:50 <ChilliX> Pseudonym: the equaliser argument is one of those in the paper
21:51:54 * Pseudonym nods
21:52:36 <ozone> Darius: good ones ;)
21:52:51 <ChilliX> what I also like very much, is a quote from a paper by Matthias Felleisen et al: to free the teaching of programming from the tyranny of syntax
21:52:55 <Pseudonym> Look, if you want to learn how to use some language, go to a TAFE, CAE or some kind of professional training thing.  You shouldn't be at an institute of higher learning for that reason.
21:52:59 <shapr> heh --> "there is a short mention of putStr on page 51"
21:53:01 <Pseudonym> Right!
21:53:06 <Pseudonym> I think that's what I said.
21:53:09 <Pseudonym> Sort of.
21:53:28 <Pseudonym> IMO, a far more valuable skill is how to pick up a new language quickly.
21:53:57 <shapr> ChilliX: does your book follow the idea of this paper?
21:54:10 <Pseudonym> Every large application has a scripting system built in.  If you want to be paid to work on it, you'd better be able to pick up the new scripting system without being taught it.
21:54:20 <shapr> if so, how can I get a copy?
21:56:47 <shapr> The university in the next town teaches Haskell in their intro to programming course
21:57:34 <cfork> Principles of Programming was taught using C++, in my University
21:57:35 <shapr> I spoke to a bunch of people who had taken that class, the most detailed response I got was "Haskell is like lisp, you have bits of code that never end"
21:58:58 <Pseudonym> ChilliX, have you read the Unimelb paper on low-contact learning?
21:59:09 <ChilliX> I am sick and tierd of courses that go like "today we learn about structs. structs start with the keyword struct followed by an opening curly brace..."
21:59:18 <shapr> :-)
21:59:28 <ChilliX> shapr: yeah, the books goes in the direction, but it could be more so
21:59:48 <ChilliX> shapr: but the way I teach it, is very much in the spirit of the article
21:59:56 <shapr> spiffy
21:59:58 <flippo> ChilliX: nice paper
22:00:28 <ChilliX> flippo: thanks
22:04:16 <Pseudonym> This is a good paper.
22:04:23 <shapr> yah, it's nifty
22:05:17 <shapr> 30% failure, yow
22:05:30 <ChilliX> :-)
22:06:07 <ChilliX> (the ':-)' is re the comments about the paper not the failure rate...)
22:06:11 <shapr> heh
22:06:26 <ChilliX> well, it could be read as I like high failure rates
22:06:46 <ChilliX> which is not the case, but they are inevitable in 1st year classes of several hundreds of students
22:08:03 <shapr> I do think the imperative world is missing out on algebraic data structures
22:10:27 <ChilliX> and higher kinded type systems ;-)
22:11:26 <shapr> and one or two other things...
22:11:43 <cfork> The functional world is missing out on some thing too though :)
22:12:38 <ChilliX> cfork: like?
22:12:51 <ozone> ChilliX: subtyping! :D
22:12:56 * ozone kicks subtyping
22:13:01 <cfork> hmm.. the bulk of funding? :)
22:13:18 <shapr> hah
22:13:31 <ChilliX> ozone: hehehe - but look at O'Haskell and others
22:13:46 <ChilliX> cfork: I don't have trouble getting funding
22:14:12 <cfork> seriously though
22:14:30 <ChilliX> well, two ARC Discovery grants; that's the max anyway
22:14:34 <cfork> People spend huge amounts of money on programming environments for imperative languages
22:14:35 <ozone> ChilliX: btw, i had an interesting idea for future work
22:14:47 <ChilliX> cfork: that's true
22:14:55 <ozone> ChilliX: once this project is done -- objc can be used as a dynamic typing system for haskell
22:15:07 <ChilliX> ozone: heh?
22:16:25 <ozone> objc makes it very easy to load in new classes on the fly at runtime, send any message to any object (even if you don't know its type) etc -- haskell can take advantage of that
22:16:35 <cfork> If programming environments for Haskell/Scheme/Whatever had the same effort put into as C++/Java/VB
22:16:40 <cfork> I'd really be quite happy :)
22:17:11 <shapr> cfork: hook up with the hIDE/haIDE guys and go for it
22:17:58 <cfork> hmm, for my university work, I use custom programs, as well as many java things
22:18:17 <cfork> I don't like using two environments on my computer (windows and linux)
22:18:38 <shapr> emacs works everywhere
22:18:43 <cfork> sure does :)
22:18:50 <cfork> but hIDE is gtk+
22:18:54 <shapr> that's true
22:19:08 <shapr> so you think it would be more useful to put effort into haskell-mode ?
22:19:24 <ChilliX> ozone: so, not only dynamic typing, more like runtime loading and dynamic typing thing?
22:19:37 <cfork> hmm I think emacs is nice, but im not sure that it could be the best haskell environment
22:20:07 <shapr> what would be better?
22:20:12 <cfork> no idea
22:20:35 <cfork> In my Java work, we use more integrated environments
22:20:56 <cfork> including gui builders very much built into the editor (or the other way around)
22:21:29 <ozone> ChilliX: yep.  you could use it as a way to encapsulate haskell functions into objects, and then use the objc runtime system to pass messages back and forth between these haskell objects, which gains you all of objc's nice dynamic features: runtime loading, dynamic typing ...
22:21:59 <shapr> cfork: yah, I've used those
22:22:10 <cfork> Eclipse, JBuilder, etc
22:22:26 <shapr> I had to deal with them a lot in my last job
22:22:48 <cfork> They range from awful to awesome
22:22:51 <cfork> I reckon
22:23:31 <shapr> cfork: the downside I ran into was that my colleagues depended on those tools to build a GUI, then when we had to develop for MIDP/SymbianOS/etc they were totally lost.
22:24:46 <cfork> ok
22:24:56 <shapr> I'm often wary of the 'cool tools syndrome'
22:25:02 <cfork> I really don't know what the perfect IDE is, but there are some I feel comfy in
22:25:11 <shapr> as you say, that isn't really a problem in the Haskell world.
22:25:59 <shapr> cfork: write down what makes you feel comfy, then we can put it into hIDE :-)
22:26:05 <cfork> haha ok :)
22:26:08 <Darius> I'm not a real fan of IDEs, but I'm a bit of a minimalist
22:26:18 <cfork> same
22:26:26 <shapr> Darius: do you consider emacs speedbar to be eye-candy?
22:26:43 <cfork> One thing I do like, is either pure console mode or pure gtk
22:26:43 <Darius> Never used emacs so I don't know
22:26:59 <shapr> maybe a better question would be, what sort of features fit into 'IDE' for you?
22:27:15 <cfork> I can't stand multi-window interfaces
22:27:19 <cfork> they drive me nuts
22:27:33 <Darius> I get mildly pissed off programming in GUI editors/IDEs
22:27:46 <cfork> in an ide
22:28:22 <Darius> ChilliX: do you use uncurried functions or just ignore the fact that they are curried?
22:30:37 <ChilliX> Darius: not sure that I understand your question
22:31:08 <ChilliX> I partially apply functions (in haskell) if convenient
22:31:16 <shapr> "In the whole process of teaching I/O to freshmen, it is imperative to avoid the monad-based heritage of I/O in Haskell." <-- was that use of imperative purposefully humorous?
22:31:17 <Darius> when teaching
22:33:06 <ChilliX> shapr: well, there was that slight grin...
22:33:36 <shapr> :-)
22:33:40 <ChilliX> Darius: I largely ignore it
22:33:46 <cfork> grrr.. my Scheme bot is connecting, but timing out straight away
22:34:12 <ChilliX> Darius: meaning, I don't make it a central point anywhere, but mention it so that the better students can use it if they like
22:34:24 <shapr> I think the 60% "very helpful" about GHCi is correct
22:34:49 <shapr> I've realized I have a hard time writing Haskell code if I can't interact with in-progress versions in GHCi
22:35:43 <Fractal> That's the greatest strength of functional programming languages, I think... Testing it component wise is quick and easy...
22:36:30 <Fractal> I liked forth for similar reasons... But even with forth, you sometimes have to worry about side effects and external variables and such...
22:37:02 <Fractal> But no, HUGS and GHCi are great for program testing..
22:37:17 <shapr> I discovered that writing unit tests first in Python had a variety of beneficial effects on my code
22:37:54 <Pseudonym> ChilliX: We will have high failure rates while our criterion for who we accept at university is based almost entirely on how they did in high school.
22:38:11 <shapr> I think my code ended up being much more functional, 'component'-ized 
22:38:34 <Darius> Hmm, I rather meant do you have f :: (a,b) -> c or f :: a -> b -> c?  I'd imagine the former.
22:38:47 <ChilliX> Pseudonym: exactly
22:39:28 <Pseudonym> There's a good argument for the US sysem of doing a general liberal arts degree first.
22:39:29 <shapr> I bet a GHCi plugin for lambdabot would be great for teaching via #haskell
22:39:30 <ChilliX> Darius: no, I use curried functions (ie, the natural way to define funs in Haskell), but I rarely exploit the fact that I can apply them partially
22:39:31 <shapr> if it could be safe
22:39:51 <Pseudonym> shapr doesn't want his box r00+k1t+3d
22:39:57 <ChilliX> Darius: one interesting observation is that partial application almost always only confuses people with previous programming experience
22:39:59 <shapr> yah, really
22:41:03 <Darius> ChilliX: I can agree with that, though my personal experience is otherwise.  However, do you get odd or non-existent error messages with curried functions at times?
22:42:03 <Darius> Also, with C as the follow-up language, uncurried would seem a bit more consistent.
22:42:40 <Pseudonym> This suggests that ML might be a better first language.
22:42:45 <Pseudonym> But then of course, there's the syntax issue.
22:42:56 * Pseudonym got really confused with ML syntax when he first tried it
22:43:06 <Pseudonym> Mind you, I came _from_ the Miranda family.
22:43:24 <Pseudonym> And my first ML was SML, which has a lot of warts in it.
22:43:51 <cfork> My first language was BASIC, same for most people I know (all?)
22:44:12 <Pseudonym> Once upon a time I would have thought so.
22:44:16 <Darius> OCaml, Haskell, and SML were the languages I was thinking of learning when I chose Haskell (which would've happened at any rate).  I distinctly found the OCaml syntax more awkward.
22:44:30 <Pseudonym> I reckon a new geek growing up now might start off with something different.
22:44:43 <Darius> Java eh
22:44:50 <Pseudonym> Or JavaScript perhaps.
22:44:51 <Darius> I started with BASIC
22:45:02 <Pseudonym> Certainly wouldn't be BASIC with line numbers.,
22:45:25 <Darius> I didn't start with a BASIC with line numbers.
22:45:53 <Pseudonym> These young people today...
22:45:58 <Darius> My BASIC code was horrible.  Spaghetti code galore!
22:46:02 <ChilliX> Darius: GHC error messages are pretty good, they usually suggest as a probable cause that you left of arguments (or have too many)
22:46:30 <ChilliX> it's really not what people have problems with
22:46:42 <ChilliX> they have a million times more problems understanding the concept of recursion
22:46:49 <ChilliX> (just as an example)
22:46:54 <Pseudonym> Especially accumulator recursion.
22:47:38 <Pseudonym> I found it helped if I taught them proof by induction first.
22:47:44 <Darius> Especially polymorphic recursion :P
22:47:59 <Darius> the brp function is polymorphically recursive
22:48:16 <Pseudonym> I started off by doing a proof by induction, then translating it into Haskell.;
22:48:38 <Pseudonym> Unfortunately, not all of them had seen induction first.
22:49:36 <Darius> I certainly used recursion before mathematical induction, but I'm self-taught
22:49:51 <Pseudonym> ChilliX: At the University of Melbourne, we actually solved the problem of students who thought they knew everything.
22:49:58 <Pseudonym> They didn't have to go to lectures.
22:50:19 <Pseudonym> On the other hand, students who elected to go this route were required to submit answers to tutorial exercises electronically.
22:50:50 <Pseudonym> And if they weren't keeping up, they got moved back into the "go to lectures" stream.
22:51:09 <ChilliX> Pseudonym: ic
22:52:14 <cfork> Pseudonym: I like that solution
22:52:56 <cfork> Pseudonym: I had a class I never turned up to, I got an HD. The next semester I was still lazy, and got crummy results, because the subjects were harder
22:53:17 <Pseudonym> There's only one class I didn't turn up to, and that was the second semester of first year.
22:53:32 <Pseudonym> But it was REALLY basic stuff.
22:54:28 <Pseudonym> And there's only one class I genuinely fell asleep in.
22:54:34 <Pseudonym> That was statistics.
22:56:09 <Pseudonym> Something interesting.
22:56:19 <Pseudonym> In this paper, it mentions advanced uses of higher order programming.
22:56:31 <Pseudonym> As I write more and more complex Haskell code, I find myself using higher-order programming _less_.
22:56:52 <Pseudonym> I'm far more likely to use type classes instead.
22:57:11 <cfork> Statistics
22:57:14 <cfork> was my favourite class
22:57:16 <Pseudonym> As type classes can be used for many tasks for which higher order programming may also be an appropriate solution.
22:57:27 <Pseudonym> Interesting.
22:57:34 <cfork> I was told I was snoring in the middle of a statistics tutorial
22:57:39 <cfork> despite it being my favourite class
22:57:41 * Pseudonym laughs
22:57:51 <cfork> (I wouldn't know if I was snoring- I was asleep)
22:58:17 <ddarius> cfork: was it your favorite because you always left it feeling reenergized?
22:58:36 <cfork> possibly.. possibly
22:58:41 <cfork> I got an HD is stats though :P
22:58:47 <cfork> since then its all been downhill
23:07:45 <seth_> hd?
23:08:48 <Pseudonym> I think it's high distinction.
23:11:00 <Darius> With the dictionary implementation of type classes, type classes basically are a form of higher-order function use
23:14:04 <Darius> However, type classes aren't as dynamic as explicit use of function parameters.
23:14:11 * Pseudonym nods
23:14:23 <Pseudonym> Type classes give you a restricted kind of higher-order programming.
23:14:35 <Pseudonym> THough I think that a lot of uses of HOFs is really type classes in disguise.
23:14:39 <Pseudonym> Or something.
23:14:43 <wli> um
23:14:50 <wli> don't you mean structured overloading?
23:17:10 <Pseudonym> I don't think so.
23:17:33 <Pseudonym> Though type classes were, of course, originally motivated as making overloading "less ad-hoc".
23:17:58 <Pseudonym> In Miranda, "show" had type * -> string
23:18:07 <Pseudonym> But if you typed "f = show" that was a type error.
23:18:17 <Pseudonym> Mind you, it's _still_ a type error, but for different reasons. :-)
23:20:41 <Darius> Well, with the dictionary passing implementation, type classes take a lot of tedium out of something that could otherwise be handled with HOFs.
23:20:43 <wli> Main> :type let f = show in f
23:20:44 <wli> forall a. (Show a) => a -> String
23:20:55 <Darius> @type fmap
23:20:55 <lambdabot> fmap :: Functor a => (b -> c) -> a b -> a c
23:22:23 <Pseudonym> Test.hs:1:
23:22:23 <Pseudonym>     Ambiguous type variable(s) `a' in the constraint `Show a'
23:22:23 <Pseudonym>     arising from use of `show' at Test.hs:1
23:22:23 <Pseudonym>     In a right-hand side of function `f': show
23:22:23 <Pseudonym>     In the definition of `f': f = show
23:22:44 <wli> monomorphism restriction
23:22:47 <Pseudonym> Right.
23:24:56 <Darius> e.g. sort and sortBy.
23:25:24 <Pseudonym> Of course in Haskell you put in a type signature and all is good.
23:25:31 <Pseudonym> In Miranda, there wasn't a valid type signature.
23:25:49 <Pseudonym> Because show had a polymorphic type, but it was actually only defined on the union of monotypes.
